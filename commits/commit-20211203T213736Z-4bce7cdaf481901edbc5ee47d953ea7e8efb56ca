{
  "sha": "4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
  "node_id": "C_kwDOANOeidoAKDRiY2U3Y2RhZjQ4MTkwMWVkYmM1ZWU0N2Q5NTNlYTdlOGVmYjU2Y2E",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-11-08T21:06:07Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-12-03T21:37:36Z"
    },
    "message": "gdbsupport: add array_view copy function\n\nAn assertion was recently added to array_view::operator[] to ensure we\ndon't do out of bounds accesses.  However, when the array_view is copied\nto or from using memcpy, it bypasses that safety.\n\nTo address this, add a `copy` free function that copies data from an\narray view to another, ensuring that the destination and source array\nviews have the same size.  When copying to or from parts of an\narray_view, we are expected to use gdb::array_view::slice, which does\nits own bounds check.  With all that, any copy operation that goes out\nof bounds should be caught by an assertion at runtime.\n\ncopy is implemented using std::copy and std::copy_backward, which, at\nleast on libstdc++, appears to pick memmove when copying trivial data.\nSo in the end there shouldn't be much difference vs using a bare memcpy,\nas we do right now.  When copying non-trivial data, std::copy and\nstd::copy_backward assigns each element in a loop.\n\nTo properly support overlapping ranges, we must use std::copy or\nstd::copy_backward, depending on whether the destination is before the\nsource or vice-versa.  std::copy and std::copy_backward don't support\ncopying exactly overlapping ranges (where the source range is equal to\nthe destination range).  But in this case, no copy is needed anyway, so\nwe do nothing.\n\nThe order of parameters of the new copy function is based on std::copy\nand std::copy_backward, where the source comes before the destination.\n\nChange a few randomly selected spots to use the new function, to show\nhow it can be used.\n\nAdd a test for the new function, testing both with arrays of a trivial\ntype (int) and of a non-trivial type (foo).  Test non-overlapping\nranges as well as three kinds of overlapping ranges: source before dest,\ndest before source, and dest == source.\n\nChange-Id: Ibeaca04e0028410fd44ce82f72e60058d6230a03",
    "tree": {
      "sha": "f085df5b718a9438b5d5174b5e3c9be15e2cea7c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f085df5b718a9438b5d5174b5e3c9be15e2cea7c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7509b82979550970342a4494d727b3fb06bffd65",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7509b82979550970342a4494d727b3fb06bffd65",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7509b82979550970342a4494d727b3fb06bffd65"
    }
  ],
  "stats": {
    "total": 246,
    "additions": 184,
    "deletions": 62
  },
  "files": [
    {
      "sha": "c6cefe9d8e89c89d7bef5fe0332253da9f632405",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 6,
      "deletions": 11,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
      "patch": "@@ -2586,9 +2586,7 @@ ada_value_assign (struct value *toval, struct value *fromval)\n       write_memory_with_notification (to_addr, buffer, len);\n \n       val = value_copy (toval);\n-      memcpy (value_contents_raw (val).data (),\n-\t      value_contents (fromval).data (),\n-\t      TYPE_LENGTH (type));\n+      copy (value_contents (fromval), value_contents_raw (val));\n       deprecated_set_value_type (val, type);\n \n       return val;\n@@ -4184,9 +4182,7 @@ ada_convert_actual (struct value *actual, struct type *formal_type0)\n \n \t      actual_type = ada_check_typedef (value_type (actual));\n \t      val = allocate_value (actual_type);\n-\t      memcpy ((char *) value_contents_raw (val).data (),\n-\t\t      (char *) value_contents (actual).data (),\n-\t\t      TYPE_LENGTH (actual_type));\n+\t      copy (value_contents (actual), value_contents_raw (val));\n \t      actual = ensure_lval (val);\n \t    }\n \t  result = value_addr (actual);\n@@ -8898,7 +8894,6 @@ ada_promote_array_of_integrals (struct type *type, struct value *val)\n {\n   struct type *elt_type = TYPE_TARGET_TYPE (type);\n   LONGEST lo, hi;\n-  struct value *res;\n   LONGEST i;\n \n   /* Verify that both val and type are arrays of scalars, and\n@@ -8914,16 +8909,16 @@ ada_promote_array_of_integrals (struct type *type, struct value *val)\n   if (!get_array_bounds (type, &lo, &hi))\n     error (_(\"unable to determine array bounds\"));\n \n-  res = allocate_value (type);\n+  value *res = allocate_value (type);\n+  gdb::array_view<gdb_byte> res_contents = value_contents_writeable (res);\n \n   /* Promote each array element.  */\n   for (i = 0; i < hi - lo + 1; i++)\n     {\n       struct value *elt = value_cast (elt_type, value_subscript (val, lo + i));\n+      int elt_len = TYPE_LENGTH (elt_type);\n \n-      memcpy ((value_contents_writeable (res).data ()\n-\t       + (i * TYPE_LENGTH (elt_type))),\n-\t      value_contents_all (elt).data (), TYPE_LENGTH (elt_type));\n+      copy (value_contents_all (elt), res_contents.slice (elt_len * i, elt_len));\n     }\n \n   return res;"
    },
    {
      "sha": "592dbe19d562c9e71597da0af64c3b5c024a5ef9",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
      "patch": "@@ -1037,8 +1037,8 @@ dwarf_expr_context::fetch_result (struct type *type, struct type *subobj_type,\n \t    if (gdbarch_byte_order (arch) == BFD_ENDIAN_BIG)\n \t      subobj_offset += n - max;\n \n-\t    memcpy (value_contents_raw (retval).data (),\n-\t\t    value_contents_all (val).data () + subobj_offset, len);\n+\t    copy (value_contents_all (val).slice (subobj_offset, len),\n+\t\t  value_contents_raw (retval));\n \t  }\n \t  break;\n "
    },
    {
      "sha": "998bd3a5781238657251e5cdcae905d456721169",
      "filename": "gdb/unittests/array-view-selftests.c",
      "status": "modified",
      "additions": 104,
      "deletions": 0,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/unittests/array-view-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/unittests/array-view-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/array-view-selftests.c?ref=4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
      "patch": "@@ -546,6 +546,108 @@ run_tests ()\n   }\n }\n \n+template <typename T>\n+void\n+run_copy_test ()\n+{\n+  /* Test non-overlapping copy.  */\n+  {\n+    const std::vector<T> src_v = {1, 2, 3, 4};\n+    std::vector<T> dest_v (4, -1);\n+\n+    SELF_CHECK (dest_v != src_v);\n+    copy (gdb::array_view<const T> (src_v), gdb::array_view<T> (dest_v));\n+    SELF_CHECK (dest_v == src_v);\n+  }\n+\n+  /* Test overlapping copy, where the source is before the destination.  */\n+  {\n+    std::vector<T> vec = {1, 2, 3, 4, 5, 6, 7, 8};\n+    gdb::array_view<T> v = vec;\n+\n+    copy (v.slice (1, 4),\n+\t  v.slice (2, 4));\n+\n+    std::vector<T> expected = {1, 2, 2, 3, 4, 5, 7, 8};\n+    SELF_CHECK (vec == expected);\n+  }\n+\n+  /* Test overlapping copy, where the source is after the destination.  */\n+  {\n+    std::vector<T> vec = {1, 2, 3, 4, 5, 6, 7, 8};\n+    gdb::array_view<T> v = vec;\n+\n+    copy (v.slice (2, 4),\n+\t  v.slice (1, 4));\n+\n+    std::vector<T> expected = {1, 3, 4, 5, 6, 6, 7, 8};\n+    SELF_CHECK (vec == expected);\n+  }\n+\n+  /* Test overlapping copy, where the source is the same as the destination.  */\n+  {\n+    std::vector<T> vec = {1, 2, 3, 4, 5, 6, 7, 8};\n+    gdb::array_view<T> v = vec;\n+\n+    copy (v.slice (2, 4),\n+\t  v.slice (2, 4));\n+\n+    std::vector<T> expected = {1, 2, 3, 4, 5, 6, 7, 8};\n+    SELF_CHECK (vec == expected);\n+  }\n+}\n+\n+/* Class with a non-trivial copy assignment operator, used to test the\n+   array_view copy function.  */\n+struct foo\n+{\n+  /* Can be implicitly constructed from an int, such that we can use the same\n+     templated test function to test against array_view<int> and\n+     array_view<foo>.  */\n+  foo (int n)\n+    : n (n)\n+  {}\n+\n+  /* Needed to avoid -Wdeprecated-copy-with-user-provided-copy error with\n+     Clang.  */\n+  foo (const foo &other) = default;\n+\n+  void operator= (const foo &other)\n+  {\n+    this->n = other.n;\n+    this->n_assign_op_called++;\n+  }\n+\n+  bool operator==(const foo &other) const\n+  {\n+    return this->n == other.n;\n+  }\n+\n+  int n;\n+\n+  /* Number of times the assignment operator has been called.  */\n+  static int n_assign_op_called;\n+};\n+\n+int foo::n_assign_op_called = 0;\n+\n+/* Test the array_view copy free function.  */\n+\n+static void\n+run_copy_tests ()\n+{\n+  /* Test with a trivial type.  */\n+  run_copy_test<int> ();\n+\n+  /* Test with a non-trivial type.  */\n+  foo::n_assign_op_called = 0;\n+  run_copy_test<foo> ();\n+\n+  /* Make sure that for the non-trivial type foo, the assignment operator was\n+     called an amount of times that makes sense.  */\n+  SELF_CHECK (foo::n_assign_op_called == 12);\n+}\n+\n } /* namespace array_view_tests */\n } /* namespace selftests */\n \n@@ -555,4 +657,6 @@ _initialize_array_view_selftests ()\n {\n   selftests::register_test (\"array_view\",\n \t\t\t    selftests::array_view_tests::run_tests);\n+  selftests::register_test (\"array_view-copy\",\n+\t\t\t    selftests::array_view_tests::run_copy_tests);\n }"
    },
    {
      "sha": "32898f9005b8d253a2dc0e1ccb9774623e0b0d0c",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 27,
      "deletions": 22,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
      "patch": "@@ -1537,7 +1537,7 @@ value_vector_widen (struct value *scalar_value, struct type *vector_type)\n {\n   /* Widen the scalar to a vector.  */\n   struct type *eltype, *scalar_type;\n-  struct value *val, *elval;\n+  struct value *elval;\n   LONGEST low_bound, high_bound;\n   int i;\n \n@@ -1560,11 +1560,14 @@ value_vector_widen (struct value *scalar_value, struct type *vector_type)\n       && !value_equal (elval, scalar_value))\n     error (_(\"conversion of scalar to vector involves truncation\"));\n \n-  val = allocate_value (vector_type);\n+  value *val = allocate_value (vector_type);\n+  gdb::array_view<gdb_byte> val_contents = value_contents_writeable (val);\n+  int elt_len = TYPE_LENGTH (eltype);\n+\n   for (i = 0; i < high_bound - low_bound + 1; i++)\n     /* Duplicate the contents of elval into the destination vector.  */\n-    memcpy (value_contents_writeable (val).data () + (i * TYPE_LENGTH (eltype)),\n-\t    value_contents_all (elval).data (), TYPE_LENGTH (eltype));\n+    copy (value_contents_all (elval),\n+\t  val_contents.slice (i * elt_len, elt_len));\n \n   return val;\n }\n@@ -1575,7 +1578,6 @@ value_vector_widen (struct value *scalar_value, struct type *vector_type)\n static struct value *\n vector_binop (struct value *val1, struct value *val2, enum exp_opcode op)\n {\n-  struct value *val, *tmp, *mark;\n   struct type *type1, *type2, *eltype1, *eltype2;\n   int t1_is_vec, t2_is_vec, elsize, i;\n   LONGEST low_bound1, high_bound1, low_bound2, high_bound2;\n@@ -1605,15 +1607,15 @@ vector_binop (struct value *val1, struct value *val2, enum exp_opcode op)\n       || low_bound1 != low_bound2 || high_bound1 != high_bound2)\n     error (_(\"Cannot perform operation on vectors with different types\"));\n \n-  val = allocate_value (type1);\n-  mark = value_mark ();\n+  value *val = allocate_value (type1);\n+  gdb::array_view<gdb_byte> val_contents = value_contents_writeable (val);\n+  value *mark = value_mark ();\n   for (i = 0; i < high_bound1 - low_bound1 + 1; i++)\n     {\n-      tmp = value_binop (value_subscript (val1, i),\n-\t\t\t value_subscript (val2, i), op);\n-      memcpy (value_contents_writeable (val).data () + i * elsize,\n-\t      value_contents_all (tmp).data (),\n-\t      elsize);\n+      value *tmp = value_binop (value_subscript (val1, i),\n+\t\t\t\tvalue_subscript (val2, i), op);\n+      copy (value_contents_all (tmp),\n+\t    val_contents.slice (i * elsize, elsize));\n      }\n   value_free_to_mark (mark);\n \n@@ -1894,20 +1896,22 @@ value_neg (struct value *arg1)\n     return value_binop (value_zero (type, not_lval), arg1, BINOP_SUB);\n   else if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     {\n-      struct value *tmp, *val = allocate_value (type);\n+      struct value *val = allocate_value (type);\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));\n       int i;\n       LONGEST low_bound, high_bound;\n \n       if (!get_array_bounds (type, &low_bound, &high_bound))\n \terror (_(\"Could not determine the vector bounds\"));\n \n+      gdb::array_view<gdb_byte> val_contents = value_contents_writeable (val);\n+      int elt_len = TYPE_LENGTH (eltype);\n+\n       for (i = 0; i < high_bound - low_bound + 1; i++)\n \t{\n-\t  tmp = value_neg (value_subscript (arg1, i));\n-\t  memcpy ((value_contents_writeable (val).data ()\n-\t\t   + i * TYPE_LENGTH (eltype)),\n-\t\t  value_contents_all (tmp).data (), TYPE_LENGTH (eltype));\n+\t  value *tmp = value_neg (value_subscript (arg1, i));\n+\t  copy (value_contents_all (tmp),\n+\t\tval_contents.slice (i * elt_len, elt_len));\n \t}\n       return val;\n     }\n@@ -1937,7 +1941,6 @@ value_complement (struct value *arg1)\n     val = value_from_longest (type, ~value_as_long (arg1));\n   else if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     {\n-      struct value *tmp;\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type));\n       int i;\n       LONGEST low_bound, high_bound;\n@@ -1946,12 +1949,14 @@ value_complement (struct value *arg1)\n \terror (_(\"Could not determine the vector bounds\"));\n \n       val = allocate_value (type);\n+      gdb::array_view<gdb_byte> val_contents = value_contents_writeable (val);\n+      int elt_len = TYPE_LENGTH (eltype);\n+\n       for (i = 0; i < high_bound - low_bound + 1; i++)\n \t{\n-\t  tmp = value_complement (value_subscript (arg1, i));\n-\t  memcpy ((value_contents_writeable (val).data ()\n-\t\t   + i * TYPE_LENGTH (eltype)),\n-\t\t  value_contents_all (tmp).data (), TYPE_LENGTH (eltype));\n+\t  value *tmp = value_complement (value_subscript (arg1, i));\n+\t  copy (value_contents_all (tmp),\n+\t\tval_contents.slice (i * elt_len, elt_len));\n \t}\n     }\n   else if (type->code () == TYPE_CODE_COMPLEX)"
    },
    {
      "sha": "ca71c128de9cf471482381fbfe40033eacd1e528",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 19,
      "deletions": 16,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
      "patch": "@@ -954,18 +954,19 @@ value_one (struct type *type)\n       struct type *eltype = check_typedef (TYPE_TARGET_TYPE (type1));\n       int i;\n       LONGEST low_bound, high_bound;\n-      struct value *tmp;\n \n       if (!get_array_bounds (type1, &low_bound, &high_bound))\n \terror (_(\"Could not determine the vector bounds\"));\n \n       val = allocate_value (type);\n+      gdb::array_view<gdb_byte> val_contents = value_contents_writeable (val);\n+      int elt_len = TYPE_LENGTH (eltype);\n+\n       for (i = 0; i < high_bound - low_bound + 1; i++)\n \t{\n-\t  tmp = value_one (eltype);\n-\t  memcpy ((value_contents_writeable (val).data ()\n-\t\t   + i * TYPE_LENGTH (eltype)),\n-\t\t  value_contents_all (tmp).data (), TYPE_LENGTH (eltype));\n+\t  value *tmp = value_one (eltype);\n+\t  copy (value_contents_all (tmp),\n+\t\tval_contents.slice (i * elt_len, elt_len));\n \t}\n     }\n   else\n@@ -1342,8 +1343,7 @@ value_assign (struct value *toval, struct value *fromval)\n      implies the returned value is not lazy, even if TOVAL was.  */\n   val = value_copy (toval);\n   set_value_lazy (val, 0);\n-  memcpy (value_contents_raw (val).data (), value_contents (fromval).data (),\n-\t  TYPE_LENGTH (type));\n+  copy (value_contents (fromval), value_contents_raw (val));\n \n   /* We copy over the enclosing type and pointed-to offset from FROMVAL\n      in the case of pointer types.  For object types, the enclosing type\n@@ -4058,10 +4058,13 @@ value_literal_complex (struct value *arg1,\n   arg1 = value_cast (real_type, arg1);\n   arg2 = value_cast (real_type, arg2);\n \n-  memcpy (value_contents_raw (val).data (),\n-\t  value_contents (arg1).data (), TYPE_LENGTH (real_type));\n-  memcpy (value_contents_raw (val).data () + TYPE_LENGTH (real_type),\n-\t  value_contents (arg2).data (), TYPE_LENGTH (real_type));\n+  int len = TYPE_LENGTH (real_type);\n+\n+  copy (value_contents (arg1),\n+\tvalue_contents_raw (val).slice (0, len));\n+  copy (value_contents (arg2),\n+\tvalue_contents_raw (val).slice (len, len));\n+\n   return val;\n }\n \n@@ -4102,12 +4105,12 @@ cast_into_complex (struct type *type, struct value *val)\n       struct type *val_real_type = TYPE_TARGET_TYPE (value_type (val));\n       struct value *re_val = allocate_value (val_real_type);\n       struct value *im_val = allocate_value (val_real_type);\n+      int len = TYPE_LENGTH (val_real_type);\n \n-      memcpy (value_contents_raw (re_val).data (),\n-\t      value_contents (val).data (), TYPE_LENGTH (val_real_type));\n-      memcpy (value_contents_raw (im_val).data (),\n-\t      value_contents (val).data () + TYPE_LENGTH (val_real_type),\n-\t      TYPE_LENGTH (val_real_type));\n+      copy (value_contents (val).slice (0, len),\n+\t    value_contents_raw (re_val));\n+      copy (value_contents (val).slice (len, len),\n+\t    value_contents_raw (im_val));\n \n       return value_literal_complex (re_val, im_val, type);\n     }"
    },
    {
      "sha": "4e66329e82c5fa193859a1a668b00796a7d5e9ff",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
      "patch": "@@ -1344,9 +1344,13 @@ value_contents_copy_raw (struct value *dst, LONGEST dst_offset,\n \t\t\t\t\t     TARGET_CHAR_BIT * length));\n \n   /* Copy the data.  */\n-  memcpy (value_contents_all_raw (dst).data () + dst_offset * unit_size,\n-\t  value_contents_all_raw (src).data () + src_offset * unit_size,\n-\t  length * unit_size);\n+  gdb::array_view<gdb_byte> dst_contents\n+    = value_contents_all_raw (dst).slice (dst_offset * unit_size,\n+\t\t\t\t\t  length * unit_size);\n+  gdb::array_view<const gdb_byte> src_contents\n+    = value_contents_all_raw (src).slice (src_offset * unit_size,\n+\t\t\t\t\t  length * unit_size);\n+  copy (src_contents, dst_contents);\n \n   /* Copy the meta-data, adjusted.  */\n   src_bit_offset = src_offset * unit_size * HOST_CHAR_BIT;\n@@ -1721,13 +1725,11 @@ value_copy (struct value *arg)\n   val->stack = arg->stack;\n   val->is_zero = arg->is_zero;\n   val->initialized = arg->initialized;\n+\n   if (!value_lazy (val))\n-    {\n-      memcpy (value_contents_all_raw (val).data (),\n-\t      value_contents_all_raw (arg).data (),\n-\t      TYPE_LENGTH (value_enclosing_type (arg)));\n+    copy (value_contents_all_raw (arg),\n+\t  value_contents_all_raw (val));\n \n-    }\n   val->unavailable = arg->unavailable;\n   val->optimized_out = arg->optimized_out;\n   val->parent = arg->parent;\n@@ -1772,9 +1774,7 @@ value_non_lval (struct value *arg)\n       struct type *enc_type = value_enclosing_type (arg);\n       struct value *val = allocate_value (enc_type);\n \n-      memcpy (value_contents_all_raw (val).data (),\n-\t      value_contents_all (arg).data (),\n-\t      TYPE_LENGTH (enc_type));\n+      copy (value_contents_all (arg), value_contents_all_raw (val));\n       val->type = arg->type;\n       set_value_embedded_offset (val, value_embedded_offset (arg));\n       set_value_pointed_to_offset (val, value_pointed_to_offset (arg));"
    },
    {
      "sha": "5f1f46b16b920043ececee8808c43289fb7a881c",
      "filename": "gdbsupport/array-view.h",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdbsupport/array-view.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4bce7cdaf481901edbc5ee47d953ea7e8efb56ca/gdbsupport/array-view.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbsupport/array-view.h?ref=4bce7cdaf481901edbc5ee47d953ea7e8efb56ca",
      "patch": "@@ -19,6 +19,7 @@\n #define COMMON_ARRAY_VIEW_H\n \n #include \"traits.h\"\n+#include <algorithm>\n #include <type_traits>\n \n /* An array_view is an abstraction that provides a non-owning view\n@@ -206,6 +207,20 @@ class array_view\n   size_type m_size;\n };\n \n+/* Copy the contents referenced by the array view SRC to the array view DEST.\n+\n+   The two array views must have the same length.  */\n+\n+template <typename U, typename T>\n+void copy (gdb::array_view<U> src, gdb::array_view<T> dest)\n+{\n+  gdb_assert (dest.size () == src.size ());\n+  if (dest.data () < src.data ())\n+    std::copy (src.begin (), src.end (), dest.begin ());\n+  else if (dest.data () > src.data ())\n+    std::copy_backward (src.begin (), src.end (), dest.end ());\n+}\n+\n /* Compare LHS and RHS for (deep) equality.  That is, whether LHS and\n    RHS have the same sizes, and whether each pair of elements of LHS\n    and RHS at the same position compares equal.  */"
    }
  ]
}