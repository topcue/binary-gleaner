{
  "sha": "8227d9e2f4af14c7e36f1792747bd5d7edf71d6a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODIyN2Q5ZTJmNGFmMTRjN2UzNmYxNzkyNzQ3YmQ1ZDdlZGY3MWQ2YQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:37Z"
    },
    "message": "Add operation-related methods to parser_state\n\nThis adds several operation-related methods to parser_state.  These\nmethods make it more convenient to change the parsers to be\noperation-based.\n\nBecause byacc has poor support for C++, a stack of operations is added\nto parser_state.  A parser can push operations, then later pop them\nfor combination into new operations.  This approach avoids the memory\nleaks that would result if raw pointers were used in the parsers, at\nthe cost of parser productions not being type-safe (they can't\nindicate that they return an operation).\n\nThis also introduces analogs of some write_exp functions, like\nwrite_exp_string_vector, write_dollar_variable, and\nwrite_exp_symbol_reference.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* parser-defs.h (struct parser_state) <push, push_new,\n\tpush_c_string, push_symbol, push_dollar, pop, pop_vector, wrap,\n\twrap2>: New methods.\n\t<m_operations>: New member.\n\t* parse.c (parser_state::push_c_string)\n\t(parser_state::push_symbol, parser_state::push_dollar): New\n\tmethods.",
    "tree": {
      "sha": "ccd72473a386dc22c44b237893aea832b1e78451",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ccd72473a386dc22c44b237893aea832b1e78451"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4933522da0d59823d2bfef3706e2252203365e9c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4933522da0d59823d2bfef3706e2252203365e9c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4933522da0d59823d2bfef3706e2252203365e9c"
    }
  ],
  "stats": {
    "total": 200,
    "additions": 200,
    "deletions": 0
  },
  "files": [
    {
      "sha": "060b9a12b359637d9bf7a929e5741f3dcce5d646",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8227d9e2f4af14c7e36f1792747bd5d7edf71d6a",
      "patch": "@@ -1,3 +1,13 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* parser-defs.h (struct parser_state) <push, push_new,\n+\tpush_c_string, push_symbol, push_dollar, pop, pop_vector, wrap,\n+\twrap2>: New methods.\n+\t<m_operations>: New member.\n+\t* parse.c (parser_state::push_c_string)\n+\t(parser_state::push_symbol, parser_state::push_dollar): New\n+\tmethods.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* parser-defs.h (struct expr_completion_state) <expout_last_op>:"
    },
    {
      "sha": "d6f98bf33cf1441fed75ee5b1999827383bbc98e",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 127,
      "deletions": 0,
      "changes": 127,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=8227d9e2f4af14c7e36f1792747bd5d7edf71d6a",
      "patch": "@@ -545,6 +545,133 @@ parser_state::mark_completion_tag (enum type_code tag, const char *ptr,\n   m_completion_state.expout_completion_name.reset (xstrndup (ptr, length));\n }\n \n+/* See parser-defs.h.  */\n+\n+void\n+parser_state::push_c_string (int kind, struct stoken_vector *vec)\n+{\n+  std::vector<std::string> data (vec->len);\n+  for (int i = 0; i < vec->len; ++i)\n+    data[i] = std::string (vec->tokens[i].ptr, vec->tokens[i].length);\n+\n+  push_new<expr::c_string_operation> ((enum c_string_type_values) kind,\n+\t\t\t\t      std::move (data));\n+}\n+\n+/* See parser-defs.h.  */\n+\n+void\n+parser_state::push_symbol (const char *name, block_symbol sym)\n+{\n+  if (sym.symbol != nullptr)\n+    {\n+      if (symbol_read_needs_frame (sym.symbol))\n+\tblock_tracker->update (sym);\n+      push_new<expr::var_value_operation> (sym.symbol, sym.block);\n+    }\n+  else\n+    {\n+      struct bound_minimal_symbol msymbol = lookup_bound_minimal_symbol (name);\n+      if (msymbol.minsym != NULL)\n+\tpush_new<expr::var_msym_value_operation> (msymbol.minsym,\n+\t\t\t\t\t\t  msymbol.objfile);\n+      else if (!have_full_symbols () && !have_partial_symbols ())\n+\terror (_(\"No symbol table is loaded.  Use the \\\"file\\\" command.\"));\n+      else\n+\terror (_(\"No symbol \\\"%s\\\" in current context.\"), name);\n+    }\n+}\n+\n+/* See parser-defs.h.  */\n+\n+void\n+parser_state::push_dollar (struct stoken str)\n+{\n+  struct block_symbol sym;\n+  struct bound_minimal_symbol msym;\n+  struct internalvar *isym = NULL;\n+  std::string copy;\n+\n+  /* Handle the tokens $digits; also $ (short for $0) and $$ (short for $$1)\n+     and $$digits (equivalent to $<-digits> if you could type that).  */\n+\n+  int negate = 0;\n+  int i = 1;\n+  /* Double dollar means negate the number and add -1 as well.\n+     Thus $$ alone means -1.  */\n+  if (str.length >= 2 && str.ptr[1] == '$')\n+    {\n+      negate = 1;\n+      i = 2;\n+    }\n+  if (i == str.length)\n+    {\n+      /* Just dollars (one or two).  */\n+      i = -negate;\n+      goto handle_last;\n+    }\n+  /* Is the rest of the token digits?  */\n+  for (; i < str.length; i++)\n+    if (!(str.ptr[i] >= '0' && str.ptr[i] <= '9'))\n+      break;\n+  if (i == str.length)\n+    {\n+      i = atoi (str.ptr + 1 + negate);\n+      if (negate)\n+\ti = -i;\n+      goto handle_last;\n+    }\n+\n+  /* Handle tokens that refer to machine registers:\n+     $ followed by a register name.  */\n+  i = user_reg_map_name_to_regnum (gdbarch (),\n+\t\t\t\t   str.ptr + 1, str.length - 1);\n+  if (i >= 0)\n+    goto handle_register;\n+\n+  /* Any names starting with $ are probably debugger internal variables.  */\n+\n+  copy = copy_name (str);\n+  isym = lookup_only_internalvar (copy.c_str () + 1);\n+  if (isym)\n+    {\n+      push_new<expr::internalvar_operation> (isym);\n+      return;\n+    }\n+\n+  /* On some systems, such as HP-UX and hppa-linux, certain system routines\n+     have names beginning with $ or $$.  Check for those, first.  */\n+\n+  sym = lookup_symbol (copy.c_str (), NULL, VAR_DOMAIN, NULL);\n+  if (sym.symbol)\n+    {\n+      push_new<expr::var_value_operation> (sym.symbol, sym.block);\n+      return;\n+    }\n+  msym = lookup_bound_minimal_symbol (copy.c_str ());\n+  if (msym.minsym)\n+    {\n+      push_new<expr::var_msym_value_operation> (msym.minsym, msym.objfile);\n+      return;\n+    }\n+\n+  /* Any other names are assumed to be debugger internal variables.  */\n+\n+  push_new<expr::internalvar_operation>\n+    (create_internalvar (copy.c_str () + 1));\n+  return;\n+handle_last:\n+  push_new<expr::last_operation> (i);\n+  return;\n+handle_register:\n+  str.length--;\n+  str.ptr++;\n+  push_new<expr::register_operation> (copy_name (str));\n+  block_tracker->update (expression_context_block,\n+\t\t\t INNERMOST_BLOCK_FOR_REGISTERS);\n+  return;\n+}\n+\n \f\n /* Recognize tokens that start with '$'.  These include:\n "
    },
    {
      "sha": "69325596f363bef54407b9715be7ba01661c744b",
      "filename": "gdb/parser-defs.h",
      "status": "modified",
      "additions": 63,
      "deletions": 0,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a/gdb/parser-defs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8227d9e2f4af14c7e36f1792747bd5d7edf71d6a/gdb/parser-defs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parser-defs.h?ref=8227d9e2f4af14c7e36f1792747bd5d7edf71d6a",
      "patch": "@@ -173,6 +173,66 @@ struct parser_state : public expr_builder\n \n   void mark_completion_tag (enum type_code tag, const char *ptr, int length);\n \n+  /* Push an operation on the stack.  */\n+  void push (expr::operation_up &&op)\n+  {\n+    m_operations.push_back (std::move (op));\n+  }\n+\n+  /* Create a new operation and push it on the stack.  */\n+  template<typename T, typename... Arg>\n+  void push_new (Arg... args)\n+  {\n+    m_operations.emplace_back (new T (std::forward<Arg> (args)...));\n+  }\n+\n+  /* Push a new C string operation.  */\n+  void push_c_string (int, struct stoken_vector *vec);\n+\n+  /* Push a symbol reference.  If SYM is nullptr, look for a minimal\n+     symbol.  */\n+  void push_symbol (const char *name, block_symbol sym);\n+\n+  /* Push a reference to $mumble.  This may result in a convenience\n+     variable, a history reference, or a register.  */\n+  void push_dollar (struct stoken str);\n+\n+  /* Pop an operation from the stack.  */\n+  expr::operation_up pop ()\n+  {\n+    expr::operation_up result = std::move (m_operations.back ());\n+    m_operations.pop_back ();\n+    return result;\n+  }\n+\n+  /* Pop N elements from the stack and return a vector.  */\n+  std::vector<expr::operation_up> pop_vector (int n)\n+  {\n+    std::vector<expr::operation_up> result (n);\n+    for (int i = 1; i <= n; ++i)\n+      result[n - i] = pop ();\n+    return result;\n+  }\n+\n+  /* A helper that pops an operation, wraps it in some other\n+     operation, and pushes it again.  */\n+  template<typename T>\n+  void wrap ()\n+  {\n+    using namespace expr;\n+    operation_up v = ::expr::make_operation<T> (pop ());\n+    push (std::move (v));\n+  }\n+\n+  /* A helper that pops two operations, wraps them in some other\n+     operation, and pushes the result.  */\n+  template<typename T>\n+  void wrap2 ()\n+  {\n+    expr::operation_up rhs = pop ();\n+    expr::operation_up lhs = pop ();\n+    push (expr::make_operation<T> (std::move (lhs), std::move (rhs)));\n+  }\n \n   /* If this is nonzero, this block is used as the lexical context for\n      symbol names.  */\n@@ -221,6 +281,9 @@ struct parser_state : public expr_builder\n      arguments contain other function calls.  */\n \n   std::vector<int> m_funcall_chain;\n+\n+  /* Stack of operations.  */\n+  std::vector<expr::operation_up> m_operations;\n };\n \n /* When parsing expressions we track the innermost block that was"
    }
  ]
}