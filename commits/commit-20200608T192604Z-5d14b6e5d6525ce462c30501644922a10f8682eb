{
  "sha": "5d14b6e5d6525ce462c30501644922a10f8682eb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWQxNGI2ZTVkNjUyNWNlNDYyYzMwNTAxNjQ0OTIyYTEwZjg2ODJlYg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-08T19:26:04Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-08T19:26:04Z"
    },
    "message": "gdb: add field::type / field::set_type\n\nAdd the `type` and `set_type` methods on `struct field`, in order to\nremoremove the `FIELD_TYPE` macro.  In this patch, the `FIELD_TYPE`\nmacro is changed to use `field::type`, so all the call sites that are\nuseused to set the field's type are changed to use `field::set_type`.\nThe next patch will remove `FIELD_TYPE` completely.\n\nNote that because of the name clash between the existing field named\n`type` and the new method, I renamed the field `m_type`.  It is not\nprivate per-se, because we can't make `struct field` a non-POD yet, but\nit should be considered private anyway (not accessed outside `struct\nfield`).\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (struct field) <type, set_type>: New methods.\n\tRename `type` field to...\n\t<m_type>: ... this.  Change references throughout to use type or\n\tset_type methods.\n\t(FIELD_TYPE): Use field::type.  Change call sites that modify\n\tthe field's type to use field::set_type instead.\n\nChange-Id: Ie21f866e3b7f8a51ea49b722d07d272a724459a0",
    "tree": {
      "sha": "0f1ce729b9393dc161bbcc4fc70f5b7b0a3ff335",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0f1ce729b9393dc161bbcc4fc70f5b7b0a3ff335"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5d14b6e5d6525ce462c30501644922a10f8682eb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5d14b6e5d6525ce462c30501644922a10f8682eb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5d14b6e5d6525ce462c30501644922a10f8682eb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5d14b6e5d6525ce462c30501644922a10f8682eb/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3d967001ecd3b325fc39d7f53ebf7054d1ecd503",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3d967001ecd3b325fc39d7f53ebf7054d1ecd503",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3d967001ecd3b325fc39d7f53ebf7054d1ecd503"
    }
  ],
  "stats": {
    "total": 161,
    "additions": 90,
    "deletions": 71
  },
  "files": [
    {
      "sha": "7d3bcfc4d22d47a5d3e19f9a39a6b0e6aa3404ba",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -1,3 +1,12 @@\n+2020-06-08  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (struct field) <type, set_type>: New methods.\n+\tRename `type` field to...\n+\t<m_type>: ... this.  Change references throughout to use type or\n+\tset_type methods.\n+\t(FIELD_TYPE): Use field::type.  Change call sites that modify\n+\tthe field's type to use field::set_type instead.\n+\n 2020-06-08  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (TYPE_INDEX_TYPE): Remove.  Change all call sites"
    },
    {
      "sha": "20c27c4e8aa09211614b39da6dd364d7451513dd",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -1432,7 +1432,7 @@ ada_fixup_array_indexes_type (struct type *index_desc_type)\n      struct type *raw_type = ada_check_typedef (ada_find_any_type (name));\n \n      if (raw_type)\n-       TYPE_FIELD_TYPE (index_desc_type, i) = raw_type;\n+       index_desc_type->field (i).set_type (raw_type);\n    }\n }\n \n@@ -8088,7 +8088,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t     record size.  */\n \t  ada_ensure_varsize_limit (field_type);\n \n-\t  TYPE_FIELD_TYPE (rtype, f) = field_type;\n+\t  rtype->field (f).set_type (field_type);\n           TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);\n \t  /* The multiplication can potentially overflow.  But because\n \t     the field length has been size-checked just above, and\n@@ -8111,7 +8111,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t     structure, the typedef is the only clue which allows us\n \t     to distinguish between the two options.  Stripping it\n \t     would prevent us from printing this field appropriately.  */\n-          TYPE_FIELD_TYPE (rtype, f) = TYPE_FIELD_TYPE (type, f);\n+          rtype->field (f).set_type (TYPE_FIELD_TYPE (type, f));\n           TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);\n           if (TYPE_FIELD_BITSIZE (type, f) > 0)\n             fld_bit_len =\n@@ -8173,7 +8173,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n         }\n       else\n         {\n-          TYPE_FIELD_TYPE (rtype, variant_field) = branch_type;\n+          rtype->field (variant_field).set_type (branch_type);\n           TYPE_FIELD_NAME (rtype, variant_field) = \"S\";\n           fld_bit_len =\n             TYPE_LENGTH (TYPE_FIELD_TYPE (rtype, variant_field)) *\n@@ -8289,7 +8289,7 @@ template_to_static_fixed_type (struct type *type0)\n \t      TYPE_FIXED_INSTANCE (type) = 1;\n \t      TYPE_LENGTH (type) = 0;\n \t    }\n-\t  TYPE_FIELD_TYPE (type, f) = new_type;\n+\t  type->field (f).set_type (new_type);\n \t  TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (type0, f);\n \t}\n     }\n@@ -8358,7 +8358,7 @@ to_record_with_fixed_variant_part (struct type *type, const gdb_byte *valaddr,\n     }\n   else\n     {\n-      TYPE_FIELD_TYPE (rtype, variant_field) = branch_type;\n+      rtype->field (variant_field).set_type (branch_type);\n       TYPE_FIELD_NAME (rtype, variant_field) = \"S\";\n       TYPE_FIELD_BITSIZE (rtype, variant_field) = 0;\n       TYPE_LENGTH (rtype) += TYPE_LENGTH (branch_type);"
    },
    {
      "sha": "0c4c3007eaf231d284a03631e426a719b3107a07",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -286,7 +286,7 @@ buildsym_compunit::finish_block_internal\n \n \t\t  if (SYMBOL_IS_ARGUMENT (sym))\n \t\t    {\n-\t\t      TYPE_FIELD_TYPE (ftype, iparams) = SYMBOL_TYPE (sym);\n+\t\t      ftype->field (iparams).set_type (SYMBOL_TYPE (sym));\n \t\t      TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;\n \t\t      iparams++;\n \t\t    }"
    },
    {
      "sha": "2636a5387cfc973aadbb04f7e3e43ce61d6a63cc",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -302,7 +302,7 @@ cp_type_print_method_args (struct type *mtype, const char *prefix,\n \t  if (FIELD_ARTIFICIAL (arg))\n \t    continue;\n \n-\t  c_print_type (arg.type, \"\", stream, 0, 0, flags);\n+\t  c_print_type (arg.type (), \"\", stream, 0, 0, flags);\n \n \t  if (i == nargs && varargs)\n \t    fprintf_filtered (stream, \", ...\");\n@@ -327,8 +327,8 @@ cp_type_print_method_args (struct type *mtype, const char *prefix,\n       struct type *domain;\n \n       gdb_assert (nargs > 0);\n-      gdb_assert (args[0].type->code () == TYPE_CODE_PTR);\n-      domain = TYPE_TARGET_TYPE (args[0].type);\n+      gdb_assert (args[0].type ()->code () == TYPE_CODE_PTR);\n+      domain = TYPE_TARGET_TYPE (args[0].type ());\n \n       if (TYPE_CONST (domain))\n \tfprintf_filtered (stream, \" const\");"
    },
    {
      "sha": "1592dc645cdb7e07dc64b2f285f43d9ef86fe711",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -2008,8 +2008,8 @@ coff_read_struct_type (int index, int length, int lastsym,\n \n \t  /* Save the data.  */\n \t  list->field.name = obstack_strdup (&objfile->objfile_obstack, name);\n-\t  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type,\n-\t\t\t\t\t\t  &sub_aux, objfile);\n+\t  list->field.set_type (decode_type (ms, ms->c_type, &sub_aux,\n+\t\t\t\t\t     objfile));\n \t  SET_FIELD_BITPOS (list->field, 8 * ms->c_value);\n \t  FIELD_BITSIZE (list->field) = 0;\n \t  nfields++;\n@@ -2024,8 +2024,8 @@ coff_read_struct_type (int index, int length, int lastsym,\n \n \t  /* Save the data.  */\n \t  list->field.name = obstack_strdup (&objfile->objfile_obstack, name);\n-\t  FIELD_TYPE (list->field) = decode_type (ms, ms->c_type,\n-\t\t\t\t\t\t  &sub_aux, objfile);\n+\t  list->field.set_type (decode_type (ms, ms->c_type, &sub_aux,\n+\t\t\t\t\t     objfile));\n \t  SET_FIELD_BITPOS (list->field, ms->c_value);\n \t  FIELD_BITSIZE (list->field) = sub_aux.x_sym.x_misc.x_lnsz.x_size;\n \t  nfields++;"
    },
    {
      "sha": "e296b133c2f487b9dd1043556c575335100a658c",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -379,7 +379,7 @@ ctf_add_member_cb (const char *name,\n   if (kind == CTF_K_STRUCT || kind == CTF_K_UNION)\n     process_struct_members (ccp, tid, t);\n \n-  FIELD_TYPE (*fp) = t;\n+  fp->set_type (t);\n   SET_FIELD_BITPOS (*fp, offset / TARGET_CHAR_BIT);\n   FIELD_BITSIZE (*fp) = get_bitsize (ccp->fp, tid, kind);\n \n@@ -401,7 +401,7 @@ ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n \n   fp = &new_field.field;\n   FIELD_NAME (*fp) = name;\n-  FIELD_TYPE (*fp) = NULL;\n+  fp->set_type (NULL);\n   SET_FIELD_ENUMVAL (*fp, enum_value);\n   FIELD_BITSIZE (*fp) = 0;\n \n@@ -1152,9 +1152,9 @@ add_stt_func (struct ctf_context *ccp, unsigned long idx)\n     {\n       atyp = get_tid_type (ccp->of, argv[iparam]);\n       if (atyp)\n-\tTYPE_FIELD_TYPE (ftype, iparam) = atyp;\n+\tftype->field (iparam).set_type (atyp);\n       else\n-\tTYPE_FIELD_TYPE (ftype, iparam) = void_type;\n+\tftype->field (iparam).set_type (void_type);\n     }\n \n   sym = new_symbol (ccp, ftype, tid);"
    },
    {
      "sha": "52feff0b23d73c54626d046a593524fb919eaa27",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -9504,7 +9504,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t((struct field *) TYPE_ZALLOC (type, 3 * sizeof (struct field)));\n \n       /* Put the discriminant at index 0.  */\n-      TYPE_FIELD_TYPE (type, 0) = field_type;\n+      type->field (0).set_type (field_type);\n       TYPE_FIELD_ARTIFICIAL (type, 0) = 1;\n       TYPE_FIELD_NAME (type, 0) = \"<<discriminant>>\";\n       SET_FIELD_BITPOS (type->field (0), bit_offset);\n@@ -9523,7 +9523,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t\t\t      name);\n       struct type *dataless_type = init_type (objfile, TYPE_CODE_VOID, 0,\n \t\t\t\t\t      dataless_name);\n-      TYPE_FIELD_TYPE (type, 2) = dataless_type;\n+      type->field (2).set_type (dataless_type);\n       /* NAME points into the original discriminant name, which\n \t already has the correct lifetime.  */\n       TYPE_FIELD_NAME (type, 2) = name;\n@@ -14539,7 +14539,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       /* Data member other than a C++ static data member.  */\n \n       /* Get type of field.  */\n-      fp->type = die_type (die, cu);\n+      fp->set_type (die_type (die, cu));\n \n       SET_FIELD_BITPOS (*fp, 0);\n \n@@ -14593,7 +14593,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \t\t     the bit field must be inferred from the type\n \t\t     attribute of the data member containing the\n \t\t     bit field.  */\n-\t\t  anonymous_size = TYPE_LENGTH (fp->type);\n+\t\t  anonymous_size = TYPE_LENGTH (fp->type ());\n \t\t}\n \t      SET_FIELD_BITPOS (*fp,\n \t\t\t\t(FIELD_BITPOS (*fp)\n@@ -14659,16 +14659,16 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       /* The name is already allocated along with this objfile, so we don't\n \t need to duplicate it for the type.  */\n       SET_FIELD_PHYSNAME (*fp, physname ? physname : \"\");\n-      FIELD_TYPE (*fp) = die_type (die, cu);\n+      fp->set_type (die_type (die, cu));\n       FIELD_NAME (*fp) = fieldname;\n     }\n   else if (die->tag == DW_TAG_inheritance)\n     {\n       /* C++ base class field.  */\n       handle_data_member_location (die, cu, fp);\n       FIELD_BITSIZE (*fp) = 0;\n-      FIELD_TYPE (*fp) = die_type (die, cu);\n-      FIELD_NAME (*fp) = fp->type->name ();\n+      fp->set_type (die_type (die, cu));\n+      FIELD_NAME (*fp) = fp->type ()->name ();\n     }\n   else\n     gdb_assert_not_reached (\"missing case in dwarf2_add_field\");\n@@ -17227,7 +17227,7 @@ read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)\n       /* TYPE_FIELD_TYPE must never be NULL.  Pre-fill the array to ensure it\n \t even if we error out during the parameters reading below.  */\n       for (iparams = 0; iparams < nparams; iparams++)\n-\tTYPE_FIELD_TYPE (ftype, iparams) = void_type;\n+\tftype->field (iparams).set_type (void_type);\n \n       iparams = 0;\n       child_die = die->child;\n@@ -17284,7 +17284,7 @@ read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)\n \t\t\t\t\t     arg_type, 0);\n \t\t}\n \n-\t      TYPE_FIELD_TYPE (ftype, iparams) = arg_type;\n+\t      ftype->field (iparams).set_type (arg_type);\n \t      iparams++;\n \t    }\n \t  child_die = child_die->sibling;"
    },
    {
      "sha": "61f5ba77d833403c7d4dbf8fd04819635b33c924",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -686,7 +686,7 @@ fake_method::fake_method (type_instance_flags flags,\n     ((struct field *) xzalloc (sizeof (struct field) * num_types));\n \n   while (num_types-- > 0)\n-    TYPE_FIELD_TYPE (type, num_types) = param_types[num_types];\n+    type->field (num_types).set_type (param_types[num_types]);\n }\n \n fake_method::~fake_method ()"
    },
    {
      "sha": "58aae9f137b4e4cc5b3e13f9b85cd558df207141",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -566,7 +566,7 @@ lookup_function_type_with_arguments (struct type *type,\n   fn->set_fields\n     ((struct field *) TYPE_ZALLOC (fn, nparams * sizeof (struct field)));\n   for (i = 0; i < nparams; ++i)\n-    TYPE_FIELD_TYPE (fn, i) = param_types[i];\n+    fn->field (i).set_type (param_types[i]);\n \n   return fn;\n }\n@@ -1405,7 +1405,7 @@ create_set_type (struct type *result_type, struct type *domain_type)\n       if (low_bound >= 0)\n \tTYPE_UNSIGNED (result_type) = 1;\n     }\n-  TYPE_FIELD_TYPE (result_type, 0) = domain_type;\n+  result_type->field (0).set_type (domain_type);\n \n   return result_type;\n }\n@@ -2263,7 +2263,7 @@ resolve_dynamic_union (struct type *type,\n \n       t = resolve_dynamic_type_internal (TYPE_FIELD_TYPE (resolved_type, i),\n \t\t\t\t\t addr_stack, 0);\n-      TYPE_FIELD_TYPE (resolved_type, i) = t;\n+      resolved_type->field (i).set_type (t);\n       if (TYPE_LENGTH (t) > max_len)\n \tmax_len = TYPE_LENGTH (t);\n     }\n@@ -2511,9 +2511,9 @@ resolve_dynamic_struct (struct type *type,\n \t   + (TYPE_FIELD_BITPOS (resolved_type, i) / TARGET_CHAR_BIT));\n       pinfo.next = addr_stack;\n \n-      TYPE_FIELD_TYPE (resolved_type, i)\n-\t= resolve_dynamic_type_internal (TYPE_FIELD_TYPE (resolved_type, i),\n-\t\t\t\t\t &pinfo, 0);\n+      resolved_type->field (i).set_type\n+\t(resolve_dynamic_type_internal (TYPE_FIELD_TYPE (resolved_type, i),\n+\t\t\t\t\t&pinfo, 0));\n       gdb_assert (TYPE_FIELD_LOC_KIND (resolved_type, i)\n \t\t  == FIELD_LOC_KIND_BITPOS);\n \n@@ -3011,7 +3011,7 @@ check_stub_method (struct type *type, int method_id, int signature_id)\n     argcount = 0;\n   else\n     {\n-      argtypes[0].type = lookup_pointer_type (type);\n+      argtypes[0].set_type (lookup_pointer_type (type));\n       argcount = 1;\n     }\n \n@@ -3027,8 +3027,8 @@ check_stub_method (struct type *type, int method_id, int signature_id)\n \t      if (strncmp (argtypetext, \"...\", p - argtypetext) != 0\n \t\t  && strncmp (argtypetext, \"void\", p - argtypetext) != 0)\n \t\t{\n-\t\t  argtypes[argcount].type =\n-\t\t    safe_parse_type (gdbarch, argtypetext, p - argtypetext);\n+\t\t  argtypes[argcount].set_type\n+\t\t    (safe_parse_type (gdbarch, argtypetext, p - argtypetext));\n \t\t  argcount += 1;\n \t\t}\n \t      argtypetext = p + 1;\n@@ -4712,7 +4712,7 @@ print_args (struct field *args, int nargs, int spaces)\n \t{\n \t  printfi_filtered (spaces, \"[%d] name '%s'\\n\", i,\n \t\t\t    args[i].name != NULL ? args[i].name : \"<NULL>\");\n-\t  recursive_dump_type (args[i].type, spaces + 2);\n+\t  recursive_dump_type (args[i].type (), spaces + 2);\n \t}\n     }\n }\n@@ -5321,9 +5321,9 @@ copy_type_recursive (struct objfile *objfile,\n \t    TYPE_FIELD_ARTIFICIAL (type, i);\n \t  TYPE_FIELD_BITSIZE (new_type, i) = TYPE_FIELD_BITSIZE (type, i);\n \t  if (TYPE_FIELD_TYPE (type, i))\n-\t    TYPE_FIELD_TYPE (new_type, i)\n-\t      = copy_type_recursive (objfile, TYPE_FIELD_TYPE (type, i),\n-\t\t\t\t     copied_types);\n+\t    new_type->field (i).set_type\n+\t      (copy_type_recursive (objfile, TYPE_FIELD_TYPE (type, i),\n+\t\t\t\t    copied_types));\n \t  if (TYPE_FIELD_NAME (type, i))\n \t    TYPE_FIELD_NAME (new_type, i) = \n \t      xstrdup (TYPE_FIELD_NAME (type, i));\n@@ -5596,7 +5596,7 @@ append_flags_type_field (struct type *type, int start_bitpos, int nr_bits,\n   gdb_assert (name != NULL);\n \n   TYPE_FIELD_NAME (type, field_nr) = xstrdup (name);\n-  TYPE_FIELD_TYPE (type, field_nr) = field_type;\n+  type->field (field_nr).set_type (field_type);\n   SET_FIELD_BITPOS (type->field (field_nr), start_bitpos);\n   TYPE_FIELD_BITSIZE (type, field_nr) = nr_bits;\n   type->set_num_fields (type->num_fields () + 1);\n@@ -5647,7 +5647,7 @@ append_composite_type_field_raw (struct type *t, const char *name,\n \t\t\t     t->num_fields ()));\n   f = &t->field (t->num_fields () - 1);\n   memset (f, 0, sizeof f[0]);\n-  FIELD_TYPE (f[0]) = field;\n+  f[0].set_type (field);\n   FIELD_NAME (f[0]) = name;\n   return f;\n }"
    },
    {
      "sha": "af5587592a4525b57eb3c570e9415a90fa0ddb13",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 14,
      "deletions": 4,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -635,6 +635,16 @@ union field_location\n \n struct field\n {\n+  struct type *type () const\n+  {\n+    return this->m_type;\n+  }\n+\n+  void set_type (struct type *type)\n+  {\n+    this->m_type = type;\n+  }\n+\n   union field_location loc;\n \n   /* * For a function or member type, this is 1 if the argument is\n@@ -660,7 +670,7 @@ struct field\n      - In a function or member type, type of this argument.\n      - In an array type, the domain-type of the array.  */\n \n-  struct type *type;\n+  struct type *m_type;\n \n   /* * Name of field, value or argument.\n      NULL for range bounds, array domains, and member function\n@@ -935,12 +945,12 @@ struct type\n \n   type *index_type () const\n   {\n-    return this->field (0).type;\n+    return this->field (0).type ();\n   }\n \n   void set_index_type (type *index_type)\n   {\n-    this->field (0).type = index_type;\n+    this->field (0).set_type (index_type);\n   }\n \n   /* * Return the dynamic property of the requested KIND from this type's\n@@ -1600,7 +1610,7 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n   (TYPE_CPLUS_SPECIFIC(thistype)->virtual_field_bits == NULL ? 0 \\\n     : B_TST(TYPE_CPLUS_SPECIFIC(thistype)->virtual_field_bits, (index)))\n \n-#define FIELD_TYPE(thisfld) ((thisfld).type)\n+#define FIELD_TYPE(thisfld) ((thisfld).type ())\n #define FIELD_NAME(thisfld) ((thisfld).name)\n #define FIELD_LOC_KIND(thisfld) ((thisfld).loc_kind)\n #define FIELD_BITPOS_LVAL(thisfld) ((thisfld).loc.bitpos)"
    },
    {
      "sha": "8209d1b653d599b9d32198ce9814a4f4051f0899",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -135,28 +135,28 @@ build_gdb_vtable_type (struct gdbarch *arch)\n \n   /* ptrdiff_t vcall_and_vbase_offsets[0]; */\n   FIELD_NAME (*field) = \"vcall_and_vbase_offsets\";\n-  FIELD_TYPE (*field) = lookup_array_range_type (ptrdiff_type, 0, -1);\n+  field->set_type (lookup_array_range_type (ptrdiff_type, 0, -1));\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (FIELD_TYPE (*field));\n   field++;\n \n   /* ptrdiff_t offset_to_top; */\n   FIELD_NAME (*field) = \"offset_to_top\";\n-  FIELD_TYPE (*field) = ptrdiff_type;\n+  field->set_type (ptrdiff_type);\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (FIELD_TYPE (*field));\n   field++;\n \n   /* void *type_info; */\n   FIELD_NAME (*field) = \"type_info\";\n-  FIELD_TYPE (*field) = void_ptr_type;\n+  field->set_type (void_ptr_type);\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (FIELD_TYPE (*field));\n   field++;\n \n   /* void (*virtual_functions[0]) (); */\n   FIELD_NAME (*field) = \"virtual_functions\";\n-  FIELD_TYPE (*field) = lookup_array_range_type (ptr_to_void_fn_type, 0, -1);\n+  field->set_type (lookup_array_range_type (ptr_to_void_fn_type, 0, -1));\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (FIELD_TYPE (*field));\n   field++;\n@@ -1039,14 +1039,14 @@ build_std_type_info_type (struct gdbarch *arch)\n \n   /* The vtable.  */\n   FIELD_NAME (*field) = \"_vptr.type_info\";\n-  FIELD_TYPE (*field) = void_ptr_type;\n+  field->set_type (void_ptr_type);\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (FIELD_TYPE (*field));\n   field++;\n \n   /* The name.  */\n   FIELD_NAME (*field) = \"__name\";\n-  FIELD_TYPE (*field) = char_ptr_type;\n+  field->set_type (char_ptr_type);\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (FIELD_TYPE (*field));\n   field++;"
    },
    {
      "sha": "cd53ec7bde339746384a7ebe6fb98a50d5abc98a",
      "filename": "gdb/iq2000-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/iq2000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/iq2000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/iq2000-tdep.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -607,7 +607,7 @@ iq2000_pass_8bytetype_by_address (struct type *type)\n   if (type->num_fields () != 1)\n     return 1;\n   /* Get field type.  */\n-  ftype = type->field (0).type;\n+  ftype = type->field (0).type ();\n   /* The field type must have size 8, otherwise pass by address.  */\n   if (TYPE_LENGTH (ftype) != 8)\n     return 1;"
    },
    {
      "sha": "07613a5b356d7bc012c7cc728585ba5dd7b0025c",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -1051,7 +1051,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t\t  break;\n \n \t\tSET_FIELD_ENUMVAL (*f, tsym.value);\n-\t\tFIELD_TYPE (*f) = t;\n+\t\tf->set_type (t);\n \t\tFIELD_NAME (*f) = debug_info->ss + cur_fdr->issBase + tsym.iss;\n \t\tFIELD_BITSIZE (*f) = 0;\n \n@@ -1198,7 +1198,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \n \t\t      if (SYMBOL_IS_ARGUMENT (sym))\n \t\t\t{\n-\t\t\t  TYPE_FIELD_TYPE (ftype, iparams) = SYMBOL_TYPE (sym);\n+\t\t\t  ftype->field (iparams).set_type (SYMBOL_TYPE (sym));\n \t\t\t  TYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;\n \t\t\t  iparams++;\n \t\t\t}\n@@ -1238,8 +1238,8 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \tFIELD_NAME (*f) = name;\n \tSET_FIELD_BITPOS (*f, sh->value);\n \tbitsize = 0;\n-\tFIELD_TYPE (*f) = parse_type (cur_fd, ax, sh->index,\n-\t\t\t\t      &bitsize, bigend, name);\n+\tf->set_type (parse_type (cur_fd, ax, sh->index, &bitsize, bigend,\n+\t\t\t\t name));\n \tFIELD_BITSIZE (*f) = bitsize;\n       }\n       break;"
    },
    {
      "sha": "20bfbd6bc50f2526d002c61e92a1341fb4ed2a53",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -988,7 +988,7 @@ rust_composite_type (struct type *original,\n       bitpos += TYPE_LENGTH (type1) * TARGET_CHAR_BIT;\n \n       FIELD_NAME (*field) = field1;\n-      FIELD_TYPE (*field) = type1;\n+      field->set_type (type1);\n       ++i;\n     }\n   if (field2 != NULL)\n@@ -1008,7 +1008,7 @@ rust_composite_type (struct type *original,\n       SET_FIELD_BITPOS (*field, bitpos);\n \n       FIELD_NAME (*field) = field2;\n-      FIELD_TYPE (*field) = type2;\n+      field->set_type (type2);\n       ++i;\n     }\n "
    },
    {
      "sha": "6d581ba862d1eb31a578de7dc32eed27d217d329",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -1007,7 +1007,7 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \t         FIXME: Do we need a new builtin_promoted_int_arg ?  */\n \t      if (ptype->code () == TYPE_CODE_VOID)\n \t\tptype = objfile_type (objfile)->builtin_int;\n-\t      TYPE_FIELD_TYPE (ftype, nparams) = ptype;\n+\t      ftype->field (nparams).set_type (ptype);\n \t      TYPE_FIELD_ARTIFICIAL (ftype, nparams++) = 0;\n \t    }\n \t  ftype->set_num_fields (nparams);\n@@ -1849,7 +1849,7 @@ read_type (const char **pp, struct objfile *objfile)\n              when we read it, so the list is reversed.  Build the\n              fields array right-to-left.  */\n           for (t = arg_types, i = num_args - 1; t; t = t->next, i--)\n-            TYPE_FIELD_TYPE (func_type, i) = t->type;\n+            func_type->field (i).set_type (t->type);\n         }\n         func_type->set_num_fields (num_args);\n         TYPE_PROTOTYPED (func_type) = 1;\n@@ -2788,7 +2788,7 @@ read_cpp_abbrev (struct stab_field_info *fip, const char **pp,\n \t  invalid_cpp_abbrev_complaint (*pp);\n \t  return 0;\n \t}\n-      fip->list->field.type = read_type (pp, objfile);\n+      fip->list->field.set_type (read_type (pp, objfile));\n       if (**pp == ',')\n \t(*pp)++;\t\t/* Skip the comma.  */\n       else\n@@ -2840,7 +2840,7 @@ read_one_struct_field (struct stab_field_info *fip, const char **pp,\n       fip->list->visibility = VISIBILITY_PUBLIC;\n     }\n \n-  fip->list->field.type = read_type (pp, objfile);\n+  fip->list->field.set_type (read_type (pp, objfile));\n   if (**pp == ':')\n     {\n       p = ++(*pp);\n@@ -3161,8 +3161,8 @@ read_baseclasses (struct stab_field_info *fip, const char **pp,\n          base class.  Read it, and remember it's type name as this\n          field's name.  */\n \n-      newobj->field.type = read_type (pp, objfile);\n-      newobj->field.name = newobj->field.type->name ();\n+      newobj->field.set_type (read_type (pp, objfile));\n+      newobj->field.name = newobj->field.type ()->name ();\n \n       /* Skip trailing ';' and bump count of number of fields seen.  */\n       if (**pp == ';')\n@@ -4242,7 +4242,7 @@ read_args (const char **pp, int end, struct objfile *objfile, int *nargsp,\n \n   rval = XCNEWVEC (struct field, n);\n   for (i = 0; i < n; i++)\n-    rval[i].type = types[i];\n+    rval[i].set_type (types[i]);\n   *nargsp = n;\n   return rval;\n }"
    },
    {
      "sha": "eb7fd6e54e9ccc85da5edca1ba79884d4ecb6104",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d14b6e5d6525ce462c30501644922a10f8682eb/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=5d14b6e5d6525ce462c30501644922a10f8682eb",
      "patch": "@@ -1707,15 +1707,15 @@ typecmp (int staticp, int varargs, int nargs,\n     t2 ++;\n \n   for (i = 0;\n-       (i < nargs) && t1[i].type->code () != TYPE_CODE_VOID;\n+       (i < nargs) && t1[i].type ()->code () != TYPE_CODE_VOID;\n        i++)\n     {\n       struct type *tt1, *tt2;\n \n       if (!t2[i])\n \treturn i + 1;\n \n-      tt1 = check_typedef (t1[i].type);\n+      tt1 = check_typedef (t1[i].type ());\n       tt2 = check_typedef (value_type (t2[i]));\n \n       if (TYPE_IS_REFERENCE (tt1)\n@@ -1754,7 +1754,7 @@ typecmp (int staticp, int varargs, int nargs,\n       /* We should be doing much hairier argument matching (see\n          section 13.2 of the ARM), but as a quick kludge, just check\n          for the same type code.  */\n-      if (t1[i].type->code () != value_type (t2[i])->code ())\n+      if (t1[i].type ()->code () != value_type (t2[i])->code ())\n \treturn i + 1;\n     }\n   if (varargs || t2[i] == NULL)\n@@ -2967,7 +2967,7 @@ find_oload_champ (gdb::array_view<value *> args,\n \t  for (jj = 0; jj < nparms; jj++)\n \t    {\n \t      type *t = (methods != NULL\n-\t\t\t ? (TYPE_FN_FIELD_ARGS (methods, ix)[jj].type)\n+\t\t\t ? (TYPE_FN_FIELD_ARGS (methods, ix)[jj].type ())\n \t\t\t : TYPE_FIELD_TYPE (SYMBOL_TYPE (functions[ix]),\n \t\t\t\t\t    jj));\n \t      parm_types.push_back (t);"
    }
  ]
}