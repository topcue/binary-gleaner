{
  "sha": "78f28b89e8c7a2c9e262e2819f0da5629f226efc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzhmMjhiODllOGM3YTJjOWUyNjJlMjgxOWYwZGE1NjI5ZjIyNmVmYw==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-01-27T19:41:49Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-02-04T16:01:53Z"
    },
    "message": "libctf: rip out dead code handling typedefs with no name\n\nThere is special code in libctf to handle typedefs with no name, which\nthe code calls \"anonymous typedef nodes\".\n\nThese monsters are obviously not something C programs can include: the\nwhole point of a ttypedef is to introduce a new name.  Looking back at\nthe history of DWARF in GCC, the only thing (outside C++ anonymous\nnamespaces) which can generate a DW_TAG_typedef without a DW_AT_name is\nobsolete code to handle the long-removed -feliminate-dwarf2-dups option.\nLooking at OpenSolaris, typedef nodes with no name couldn't be generated\nby the DWARF->CTF converter at all (and its deduplicator barfed on\nthem): the only reason for the existence of this code is a special case\nworking around a peculiarity of stabs whereby types could sometimes be\nreferenced before they were introduced.\n\nWe don't need to carry code in libctf to handle special cases in an\nobsolete OpenSolaris converter (that yields a format that isn't readable\nby libctf anyway).  So drop it.\n\nlibctf/ChangeLog\n2021-01-27  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-open.c (init_types): Rip out code to check anonymous typedef\n\tnodes.\n\t* ctf-create.c (ctf_add_reftype): Likewise.\n\t* ctf-lookup.c (refresh_pptrtab): Likewise.",
    "tree": {
      "sha": "e900c4a1676fdcb53141054e68160a844b58ad7d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e900c4a1676fdcb53141054e68160a844b58ad7d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/78f28b89e8c7a2c9e262e2819f0da5629f226efc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78f28b89e8c7a2c9e262e2819f0da5629f226efc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/78f28b89e8c7a2c9e262e2819f0da5629f226efc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78f28b89e8c7a2c9e262e2819f0da5629f226efc/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "35a01a045442f6860abba7246f215adefc9dfa5b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/35a01a045442f6860abba7246f215adefc9dfa5b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/35a01a045442f6860abba7246f215adefc9dfa5b"
    }
  ],
  "stats": {
    "total": 75,
    "additions": 14,
    "deletions": 61
  },
  "files": [
    {
      "sha": "9b0dad92b0710e9c9e470cb916d5310242ab329a",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78f28b89e8c7a2c9e262e2819f0da5629f226efc/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78f28b89e8c7a2c9e262e2819f0da5629f226efc/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=78f28b89e8c7a2c9e262e2819f0da5629f226efc",
      "patch": "@@ -1,3 +1,10 @@\n+2021-01-27  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-open.c (init_types): Rip out code to check anonymous typedef\n+\tnodes.\n+\t* ctf-create.c (ctf_add_reftype): Likewise.\n+\t* ctf-lookup.c (refresh_pptrtab): Likewise.\n+\n 2021-01-27  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.c (_libctf_nonnull_): Add parameters."
    },
    {
      "sha": "cf47384284687aa849aea716aac73bf4c6ffb2da",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 6,
      "deletions": 17,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78f28b89e8c7a2c9e262e2819f0da5629f226efc/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78f28b89e8c7a2c9e262e2819f0da5629f226efc/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=78f28b89e8c7a2c9e262e2819f0da5629f226efc",
      "patch": "@@ -1629,29 +1629,18 @@ ctf_add_reftype (ctf_dict_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n   if (kind != CTF_K_POINTER)\n     return type;\n \n-  /* If we are adding a pointer, update the ptrtab, both the directly pointed-to\n-     type and (if an anonymous typedef node is being pointed at) the type that\n-     points at too.  Note that ctf_typemax is at this point one higher than we\n-     want to check against, because it's just been incremented for the addition\n-     of this type.  The pptrtab is lazily-updated as needed, so is not touched\n-     here.  */\n+  /* If we are adding a pointer, update the ptrtab, pointing at this type from\n+     the type it points to.  Note that ctf_typemax is at this point one higher\n+     than we want to check against, because it's just been incremented for the\n+     addition of this type.  The pptrtab is lazily-updated as needed, so is not\n+     touched here.  */\n \n   uint32_t type_idx = LCTF_TYPE_TO_INDEX (fp, type);\n   uint32_t ref_idx = LCTF_TYPE_TO_INDEX (fp, ref);\n \n   if (LCTF_TYPE_ISCHILD (fp, ref) == child\n       && ref_idx < fp->ctf_typemax)\n-    {\n-      fp->ctf_ptrtab[ref_idx] = type_idx;\n-\n-      ctf_id_t refref_idx = LCTF_TYPE_TO_INDEX (fp, dtd->dtd_data.ctt_type);\n-\n-      if (tmp == fp\n-\t  && (LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info) == CTF_K_TYPEDEF)\n-\t  && strcmp (ctf_strptr (fp, dtd->dtd_data.ctt_name), \"\") == 0\n-\t  && refref_idx < fp->ctf_typemax)\n-\tfp->ctf_ptrtab[refref_idx] = type_idx;\n-    }\n+    fp->ctf_ptrtab[ref_idx] = type_idx;\n \n   return type;\n }"
    },
    {
      "sha": "72f6a2a24c7062b961186d052fadac5309c9543b",
      "filename": "libctf/ctf-lookup.c",
      "status": "modified",
      "additions": 0,
      "deletions": 24,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78f28b89e8c7a2c9e262e2819f0da5629f226efc/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78f28b89e8c7a2c9e262e2819f0da5629f226efc/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=78f28b89e8c7a2c9e262e2819f0da5629f226efc",
      "patch": "@@ -51,7 +51,6 @@ refresh_pptrtab (ctf_dict_t *fp, ctf_dict_t *pfp)\n     {\n       ctf_id_t type = LCTF_INDEX_TO_TYPE (fp, i, 1);\n       ctf_id_t reffed_type;\n-      int updated;\n \n       if (ctf_type_kind (fp, type) != CTF_K_POINTER)\n \tcontinue;\n@@ -65,29 +64,6 @@ refresh_pptrtab (ctf_dict_t *fp, ctf_dict_t *pfp)\n \t  /* Guard against references to invalid types.  No need to consider\n \t     the CTF dict corrupt in this case: this pointer just can't be a\n \t     pointer to any type we know about.  */\n-\t  if (idx <= pfp->ctf_typemax)\n-\t    {\n-\t      if (idx >= fp->ctf_pptrtab_len\n-\t\t  && grow_pptrtab (fp, pfp->ctf_ptrtab_len) < 0)\n-\t\treturn -1;\t\t\t/* errno is set for us.  */\n-\n-\t      fp->ctf_pptrtab[idx] = i;\n-\t      updated = 1;\n-\t    }\n-\t}\n-      if (!updated)\n-\tcontinue;\n-\n-      /* If we updated the ptrtab entry for this type's referent, and it's an\n-\t anonymous typedef node, we also want to chase down its referent and\n-\t change that as well.  */\n-\n-      if ((ctf_type_kind (fp, reffed_type) == CTF_K_TYPEDEF)\n-\t  && strcmp (ctf_type_name_raw (fp, reffed_type), \"\") == 0)\n-\t{\n-\t  uint32_t idx;\n-\t  idx = LCTF_TYPE_TO_INDEX (pfp, ctf_type_reference (fp, reffed_type));\n-\n \t  if (idx <= pfp->ctf_typemax)\n \t    {\n \t      if (idx >= fp->ctf_pptrtab_len"
    },
    {
      "sha": "67d9f84c361820ced0bb2865ee2ffcccb8657ae8",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 1,
      "deletions": 20,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78f28b89e8c7a2c9e262e2819f0da5629f226efc/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78f28b89e8c7a2c9e262e2819f0da5629f226efc/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=78f28b89e8c7a2c9e262e2819f0da5629f226efc",
      "patch": "@@ -683,7 +683,7 @@ init_types (ctf_dict_t *fp, ctf_header_t *cth)\n \n   unsigned long pop[CTF_K_MAX + 1] = { 0 };\n   const ctf_type_t *tp;\n-  uint32_t id, dst;\n+  uint32_t id;\n   uint32_t *xp;\n \n   /* We determine whether the dict is a child or a parent based on the value of\n@@ -953,25 +953,6 @@ init_types (ctf_dict_t *fp, ctf_header_t *cth)\n   ctf_dprintf (\"%u base type names hashed\\n\",\n \t       ctf_hash_size (fp->ctf_names.ctn_readonly));\n \n-  /* Make an additional pass through the pointer table to find pointers that\n-     point to anonymous typedef nodes.  If we find one, modify the pointer table\n-     so that the pointer is also known to point to the node that is referenced\n-     by the anonymous typedef node.  */\n-\n-  for (id = 1; id <= fp->ctf_typemax; id++)\n-    {\n-      if ((dst = fp->ctf_ptrtab[id]) != 0)\n-\t{\n-\t  tp = LCTF_INDEX_TO_TYPEPTR (fp, id);\n-\n-\t  if (LCTF_INFO_KIND (fp, tp->ctt_info) == CTF_K_TYPEDEF\n-\t      && strcmp (ctf_strptr (fp, tp->ctt_name), \"\") == 0\n-\t      && LCTF_TYPE_ISCHILD (fp, tp->ctt_type) == child\n-\t      && LCTF_TYPE_TO_INDEX (fp, tp->ctt_type) <= fp->ctf_typemax)\n-\t      fp->ctf_ptrtab[LCTF_TYPE_TO_INDEX (fp, tp->ctt_type)] = dst;\n-\t}\n-    }\n-\n   return 0;\n }\n "
    }
  ]
}