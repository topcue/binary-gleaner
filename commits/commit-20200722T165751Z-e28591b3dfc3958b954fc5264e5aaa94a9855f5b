{
  "sha": "e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTI4NTkxYjNkZmMzOTU4Yjk1NGZjNTI2NGU1YWFhOTRhOTg1NWY1Yg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-06-03T15:36:18Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-07-22T16:57:51Z"
    },
    "message": "libctf, next, hash: add dynhash and dynset _next iteration\n\nThis lets you iterate over dynhashes and dynsets using the _next API.\ndynhashes can be iterated over in sorted order, which works by\npopulating an array of key/value pairs using ctf_dynhash_next itself,\nthen sorting it with qsort.\n\nConvenience inline functions named ctf_dyn{hash,set}_cnext are also\nprovided that take (-> return) const keys and values.\n\nlibctf/\n\t* ctf-impl.h (ctf_next_hkv_t): New, kv-pairs passed to\n\tsorting functions.\n\t(ctf_next_t) <u.ctn_sorted_hkv>: New, sorted kv-pairs for\n\tctf_dynhash_next_sorted.\n\t<cu.ctn_h>: New, pointer to the dynhash under iteration.\n\t<cu.ctn_s>: New, pointer to the dynset under iteration.\n\t(ctf_hash_sort_f): Sorting function passed to...\n\t(ctf_dynhash_next_sorted): ... this new function.\n\t(ctf_dynhash_next): New.\n\t(ctf_dynset_next): New.\n\t* ctf-inlines.h (ctf_dynhash_cnext_sorted): New.\n\t(ctf_dynhash_cnext): New.\n\t(ctf_dynset_cnext): New.\n\t* ctf-hash.c (ctf_dynhash_next_sorted): New.\n\t(ctf_dynhash_next): New.\n\t(ctf_dynset_next): New.\n\t* ctf-util.c (ctf_next_destroy): Free the u.ctn_sorted_hkv if\n\tneeded.\n\t(ctf_next_copy): Alloc-and-copy the u.ctn_sorted_hkv if needed.",
    "tree": {
      "sha": "861c605a95b4a6c2b5dc2ebcd46fd00f0161e1c1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/861c605a95b4a6c2b5dc2ebcd46fd00f0161e1c1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "688d28f62146bf07b2ce1efd5380768d5ead418d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/688d28f62146bf07b2ce1efd5380768d5ead418d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/688d28f62146bf07b2ce1efd5380768d5ead418d"
    }
  ],
  "stats": {
    "total": 306,
    "additions": 305,
    "deletions": 1
  },
  "files": [
    {
      "sha": "779f7b1cc873cc35e4a5b4cc26f38e574ba19312",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
      "patch": "@@ -1,3 +1,25 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_next_hkv_t): New, kv-pairs passed to\n+\tsorting functions.\n+\t(ctf_next_t) <u.ctn_sorted_hkv>: New, sorted kv-pairs for\n+\tctf_dynhash_next_sorted.\n+\t<cu.ctn_h>: New, pointer to the dynhash under iteration.\n+\t<cu.ctn_s>: New, pointer to the dynset under iteration.\n+\t(ctf_hash_sort_f): Sorting function passed to...\n+\t(ctf_dynhash_next_sorted): ... this new function.\n+\t(ctf_dynhash_next): New.\n+\t(ctf_dynset_next): New.\n+\t* ctf-inlines.h (ctf_dynhash_cnext_sorted): New.\n+\t(ctf_dynhash_cnext): New.\n+\t(ctf_dynset_cnext): New.\n+\t* ctf-hash.c (ctf_dynhash_next_sorted): New.\n+\t(ctf_dynhash_next): New.\n+\t(ctf_dynset_next): New.\n+\t* ctf-util.c (ctf_next_destroy): Free the u.ctn_sorted_hkv if\n+\tneeded.\n+\t(ctf_next_copy): Alloc-and-copy the u.ctn_sorted_hkv if needed.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.h (ctf_next): New."
    },
    {
      "sha": "a026ef225da8b6779ca4a40c1742466d57920ec5",
      "filename": "libctf/ctf-hash.c",
      "status": "modified",
      "additions": 225,
      "deletions": 0,
      "changes": 225,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
      "patch": "@@ -378,6 +378,163 @@ ctf_dynhash_iter_remove (ctf_dynhash_t *hp, ctf_hash_iter_remove_f fun,\n   htab_traverse (hp->htab, ctf_hashtab_traverse_remove, &arg);\n }\n \n+/* Traverse a dynhash in arbitrary order, in _next iterator form.\n+\n+   Mutating the dynhash while iterating is not supported (just as it isn't for\n+   htab_traverse).\n+\n+   Note: unusually, this returns zero on success and a *positive* value on\n+   error, because it does not take an fp, taking an error pointer would be\n+   incredibly clunky, and nearly all error-handling ends up stuffing the result\n+   of this into some sort of errno or ctf_errno, which is invariably\n+   positive.  So doing this simplifies essentially all callers.  */\n+int\n+ctf_dynhash_next (ctf_dynhash_t *h, ctf_next_t **it, void **key, void **value)\n+{\n+  ctf_next_t *i = *it;\n+  ctf_helem_t *slot;\n+\n+  if (!i)\n+    {\n+      size_t size = htab_size (h->htab);\n+\n+      /* If the table has too many entries to fit in an ssize_t, just give up.\n+\t This might be spurious, but if any type-related hashtable has ever been\n+\t nearly as large as that then something very odd is going on.  */\n+      if (((ssize_t) size) < 0)\n+\treturn EDOM;\n+\n+      if ((i = ctf_next_create ()) == NULL)\n+\treturn ENOMEM;\n+\n+      i->u.ctn_hash_slot = h->htab->entries;\n+      i->cu.ctn_h = h;\n+      i->ctn_n = 0;\n+      i->ctn_size = (ssize_t) size;\n+      i->ctn_iter_fun = (void (*) (void)) ctf_dynhash_next;\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_dynhash_next != i->ctn_iter_fun)\n+    return ECTF_NEXT_WRONGFUN;\n+\n+  if (h != i->cu.ctn_h)\n+    return ECTF_NEXT_WRONGFP;\n+\n+  if ((ssize_t) i->ctn_n == i->ctn_size)\n+    goto hash_end;\n+\n+  while ((ssize_t) i->ctn_n < i->ctn_size\n+\t && (*i->u.ctn_hash_slot == HTAB_EMPTY_ENTRY\n+\t     || *i->u.ctn_hash_slot == HTAB_DELETED_ENTRY))\n+    {\n+      i->u.ctn_hash_slot++;\n+      i->ctn_n++;\n+    }\n+\n+  if ((ssize_t) i->ctn_n == i->ctn_size)\n+    goto hash_end;\n+\n+  slot = *i->u.ctn_hash_slot;\n+\n+  if (key)\n+    *key = slot->key;\n+  if (value)\n+    *value = slot->value;\n+\n+  i->u.ctn_hash_slot++;\n+  i->ctn_n++;\n+\n+  return 0;\n+\n+ hash_end:\n+  ctf_next_destroy (i);\n+  *it = NULL;\n+  return ECTF_NEXT_END;\n+}\n+\n+/* Traverse a sorted dynhash, in _next iterator form.\n+\n+   See ctf_dynhash_next for notes on error returns, etc.\n+\n+   Sort keys before iterating over them using the SORT_FUN and SORT_ARG.\n+\n+   If SORT_FUN is null, thunks to ctf_dynhash_next.  */\n+int\n+ctf_dynhash_next_sorted (ctf_dynhash_t *h, ctf_next_t **it, void **key,\n+\t\t\t void **value, ctf_hash_sort_f sort_fun, void *sort_arg)\n+{\n+  ctf_next_t *i = *it;\n+\n+  if (sort_fun == NULL)\n+    return ctf_dynhash_next (h, it, key, value);\n+\n+  if (!i)\n+    {\n+      size_t els = ctf_dynhash_elements (h);\n+      ctf_next_t *accum_i = NULL;\n+      void *key, *value;\n+      int err;\n+      ctf_next_hkv_t *walk;\n+\n+      if (((ssize_t) els) < 0)\n+\treturn EDOM;\n+\n+      if ((i = ctf_next_create ()) == NULL)\n+\treturn ENOMEM;\n+\n+      if ((i->u.ctn_sorted_hkv = calloc (els, sizeof (ctf_next_hkv_t))) == NULL)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  return ENOMEM;\n+\t}\n+      walk = i->u.ctn_sorted_hkv;\n+\n+      i->cu.ctn_h = h;\n+\n+      while ((err = ctf_dynhash_next (h, &accum_i, &key, &value)) == 0)\n+\t{\n+\t  walk->hkv_key = key;\n+\t  walk->hkv_value = value;\n+\t  walk++;\n+\t}\n+      if (err != ECTF_NEXT_END)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  return err;\n+\t}\n+\n+      if (sort_fun)\n+\t  ctf_qsort_r (i->u.ctn_sorted_hkv, els, sizeof (ctf_next_hkv_t),\n+\t\t       (int (*) (const void *, const void *, void *)) sort_fun,\n+\t\t       sort_arg);\n+      i->ctn_n = 0;\n+      i->ctn_size = (ssize_t) els;\n+      i->ctn_iter_fun = (void (*) (void)) ctf_dynhash_next_sorted;\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_dynhash_next_sorted != i->ctn_iter_fun)\n+    return ECTF_NEXT_WRONGFUN;\n+\n+  if (h != i->cu.ctn_h)\n+    return ECTF_NEXT_WRONGFP;\n+\n+  if ((ssize_t) i->ctn_n == i->ctn_size)\n+    {\n+      ctf_next_destroy (i);\n+      *it = NULL;\n+      return ECTF_NEXT_END;\n+    }\n+\n+  if (key)\n+    *key = i->u.ctn_sorted_hkv[i->ctn_n].hkv_key;\n+  if (value)\n+    *value = i->u.ctn_sorted_hkv[i->ctn_n].hkv_value;\n+  i->ctn_n++;\n+  return 0;\n+}\n+\n void\n ctf_dynhash_destroy (ctf_dynhash_t *hp)\n {\n@@ -515,6 +672,74 @@ ctf_dynset_lookup_any (ctf_dynset_t *hp)\n   return NULL;\n }\n \n+/* Traverse a dynset in arbitrary order, in _next iterator form.\n+\n+   Otherwise, just like ctf_dynhash_next.  */\n+int\n+ctf_dynset_next (ctf_dynset_t *hp, ctf_next_t **it, void **key)\n+{\n+  struct htab *htab = (struct htab *) hp;\n+  ctf_next_t *i = *it;\n+  void *slot;\n+\n+  if (!i)\n+    {\n+      size_t size = htab_size (htab);\n+\n+      /* If the table has too many entries to fit in an ssize_t, just give up.\n+\t This might be spurious, but if any type-related hashtable has ever been\n+\t nearly as large as that then somthing very odd is going on.  */\n+\n+      if (((ssize_t) size) < 0)\n+\treturn EDOM;\n+\n+      if ((i = ctf_next_create ()) == NULL)\n+\treturn ENOMEM;\n+\n+      i->u.ctn_hash_slot = htab->entries;\n+      i->cu.ctn_s = hp;\n+      i->ctn_n = 0;\n+      i->ctn_size = (ssize_t) size;\n+      i->ctn_iter_fun = (void (*) (void)) ctf_dynset_next;\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_dynset_next != i->ctn_iter_fun)\n+    return ECTF_NEXT_WRONGFUN;\n+\n+  if (hp != i->cu.ctn_s)\n+    return ECTF_NEXT_WRONGFP;\n+\n+  if ((ssize_t) i->ctn_n == i->ctn_size)\n+    goto set_end;\n+\n+  while ((ssize_t) i->ctn_n < i->ctn_size\n+\t && (*i->u.ctn_hash_slot == HTAB_EMPTY_ENTRY\n+\t     || *i->u.ctn_hash_slot == HTAB_DELETED_ENTRY))\n+    {\n+      i->u.ctn_hash_slot++;\n+      i->ctn_n++;\n+    }\n+\n+  if ((ssize_t) i->ctn_n == i->ctn_size)\n+    goto set_end;\n+\n+  slot = *i->u.ctn_hash_slot;\n+\n+  if (key)\n+    *key = internal_to_key (slot);\n+\n+  i->u.ctn_hash_slot++;\n+  i->ctn_n++;\n+\n+  return 0;\n+\n+ set_end:\n+  ctf_next_destroy (i);\n+  *it = NULL;\n+  return ECTF_NEXT_END;\n+}\n+\n /* ctf_hash, used for fixed-size maps from const char * -> ctf_id_t without\n    removal.  This is a straight cast of a hashtab.  */\n "
    },
    {
      "sha": "eea5204c51dd6d9ebdca02ded6302bec897180d4",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 20,
      "deletions": 1,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
      "patch": "@@ -328,6 +328,13 @@ struct ctf_archive_internal\n \n /* Iterator state for the *_next() functions.  */\n \n+/* A single hash key/value pair.  */\n+typedef struct ctf_next_hkv\n+{\n+  void *hkv_key;\n+  void *hkv_value;\n+} ctf_next_hkv_t;\n+\n struct ctf_next\n {\n   void (*ctn_iter_fun) (void);\n@@ -346,13 +353,17 @@ struct ctf_next\n     const ctf_dmdef_t *ctn_dmd;\n     const ctf_enum_t *ctn_en;\n     const ctf_dvdef_t *ctn_dvd;\n+    ctf_next_hkv_t *ctn_sorted_hkv;\n+    void **ctn_hash_slot;\n   } u;\n   /* This union is of various sorts of container we can iterate over:\n-     currently dictionaries and archives.  */\n+     currently dictionaries and archives, dynhashes, and dynsets.  */\n   union\n   {\n     const ctf_file_t *ctn_fp;\n     const ctf_archive_t *ctn_arc;\n+    const ctf_dynhash_t *ctn_h;\n+    const ctf_dynset_t *ctn_s;\n   } cu;\n };\n \n@@ -411,6 +422,8 @@ typedef void (*ctf_hash_free_fun) (void *);\n typedef void (*ctf_hash_iter_f) (void *key, void *value, void *arg);\n typedef int (*ctf_hash_iter_remove_f) (void *key, void *value, void *arg);\n typedef int (*ctf_hash_iter_find_f) (void *key, void *value, void *arg);\n+typedef int (*ctf_hash_sort_f) (const ctf_next_hkv_t *, const ctf_next_hkv_t *,\n+\t\t\t\tvoid *arg);\n \n extern ctf_hash_t *ctf_hash_create (unsigned long, ctf_hash_fun, ctf_hash_eq_fun);\n extern int ctf_hash_insert_type (ctf_hash_t *, ctf_file_t *, uint32_t, uint32_t);\n@@ -434,6 +447,11 @@ extern void ctf_dynhash_iter_remove (ctf_dynhash_t *, ctf_hash_iter_remove_f,\n \t\t\t\t     void *);\n extern void *ctf_dynhash_iter_find (ctf_dynhash_t *, ctf_hash_iter_find_f,\n \t\t\t\t    void *);\n+extern int ctf_dynhash_next (ctf_dynhash_t *, ctf_next_t **,\n+\t\t\t     void **key, void **value);\n+extern int ctf_dynhash_next_sorted (ctf_dynhash_t *, ctf_next_t **,\n+\t\t\t\t    void **key, void **value, ctf_hash_sort_f,\n+\t\t\t\t    void *);\n \n extern ctf_dynset_t *ctf_dynset_create (htab_hash, htab_eq, ctf_hash_free_fun);\n extern int ctf_dynset_insert (ctf_dynset_t *, void *);\n@@ -442,6 +460,7 @@ extern void ctf_dynset_destroy (ctf_dynset_t *);\n extern void *ctf_dynset_lookup (ctf_dynset_t *, const void *);\n extern int ctf_dynset_exists (ctf_dynset_t *, const void *key,\n \t\t\t      const void **orig_key);\n+extern int ctf_dynset_next (ctf_dynset_t *, ctf_next_t **, void **key);\n extern void *ctf_dynset_lookup_any (ctf_dynset_t *);\n \n #define\tctf_list_prev(elem)\t((void *)(((ctf_list_t *)(elem))->l_prev))"
    },
    {
      "sha": "a35b6cd5a77f2c60970eb083344eb9a3a7e37ca1",
      "filename": "libctf/ctf-inlines.h",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ctf-inlines.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ctf-inlines.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-inlines.h?ref=e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
      "patch": "@@ -46,13 +46,34 @@ ctf_forwardable_kind (int kind)\n   return (kind == CTF_K_STRUCT || kind == CTF_K_UNION || kind == CTF_K_ENUM);\n }\n \n+static inline int\n+ctf_dynhash_cnext_sorted (ctf_dynhash_t *h, ctf_next_t **i, const void **key,\n+\t\t\t  const void **value, ctf_hash_sort_f sort_fun,\n+\t\t\t  void *sort_arg)\n+{\n+  return ctf_dynhash_next_sorted (h, i, (void **) key, (void **) value,\n+\t\t\t\t  sort_fun, sort_arg);\n+}\n+\n+static inline int\n+ctf_dynhash_cnext (ctf_dynhash_t *h, ctf_next_t **it,\n+\t\t  const void **key, const void **value)\n+{\n+  return ctf_dynhash_next (h, it, (void **) key, (void **) value);\n+}\n \n static inline int\n ctf_dynhash_cinsert (ctf_dynhash_t *h, const void *k, const void *v)\n {\n   return ctf_dynhash_insert (h, (void *) k, (void *) v);\n }\n \n+static inline int\n+ctf_dynset_cnext (ctf_dynset_t *h, ctf_next_t **it, const void **key)\n+{\n+  return ctf_dynset_next (h, it, (void **) key);\n+}\n+\n static inline int\n ctf_dynset_cinsert (ctf_dynset_t *h, const void *k)\n {"
    },
    {
      "sha": "c113dfc559640436b2b95cb001ff1235317456ea",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e28591b3dfc3958b954fc5264e5aaa94a9855f5b/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=e28591b3dfc3958b954fc5264e5aaa94a9855f5b",
      "patch": "@@ -187,6 +187,11 @@ ctf_next_create (void)\n void\n ctf_next_destroy (ctf_next_t *i)\n {\n+  if (i == NULL)\n+    return;\n+\n+  if (i->ctn_iter_fun == (void (*) (void)) ctf_dynhash_next_sorted)\n+    free (i->u.ctn_sorted_hkv);\n   free (i);\n }\n \n@@ -200,5 +205,17 @@ ctf_next_copy (ctf_next_t *i)\n   if ((i2 = ctf_next_create()) == NULL)\n     return NULL;\n   memcpy (i2, i, sizeof (struct ctf_next));\n+\n+  if (i2->ctn_iter_fun == (void (*) (void)) ctf_dynhash_next_sorted)\n+    {\n+      size_t els = ctf_dynhash_elements ((ctf_dynhash_t *) i->cu.ctn_h);\n+      if ((i2->u.ctn_sorted_hkv = calloc (els, sizeof (ctf_next_hkv_t))) == NULL)\n+\t{\n+\t  free (i2);\n+\t  return NULL;\n+\t}\n+      memcpy (i2->u.ctn_sorted_hkv, i->u.ctn_sorted_hkv,\n+\t      els * sizeof (ctf_next_hkv_t));\n+    }\n   return i2;\n }"
    }
  ]
}