{
  "sha": "09ba997f323198495bcf6884dd402fa5b9cc8978",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDliYTk5N2YzMjMxOTg0OTViY2Y2ODg0ZGQ0MDJmYTViOWNjODk3OA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:43:24Z"
    },
    "message": "Add some methods to dwarf2_per_cu_data\n\nThis changes a few helper functions to be methods on\ndwarf2_per_cu_data.\n\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/loc.c (dwarf2_find_location_expression)\n\t(dwarf_evaluate_loc_desc::get_tls_address)\n\t(dwarf_evaluate_loc_desc::push_dwarf_reg_entry_value)\n\t(rw_pieced_value, dwarf2_evaluate_loc_desc_full)\n\t(dwarf2_locexpr_baton_eval, dwarf2_evaluate_property)\n\t(dwarf2_compile_property_to_c)\n\t(dwarf2_loc_desc_get_symbol_read_needs)\n\t(dwarf2_compile_expr_to_ax, locexpr_describe_location)\n\t(locexpr_tracepoint_var_ref, locexpr_generate_c_location)\n\t(loclist_describe_location, loclist_tracepoint_var_ref)\n\t(loclist_generate_c_location): Update.\n\t* compile/compile-loc2c.c (do_compile_dwarf_expr_to_c): Update.\n\t* dwarf2/loc.h (dwarf2_per_cu_objfile, dwarf2_per_cu_addr_size)\n\t(dwarf2_per_cu_ref_addr_size, dwarf2_per_cu_offset_size)\n\t(dwarf2_per_cu_text_offset, dwarf2_version): Don't declare.\n\t* dwarf2/read.c (dwarf2_per_cu_data::objfile)\n\t(dwarf2_per_cu_data::addr_size)\n\t(dwarf2_per_cu_data::ref_addr_size)\n\t(dwarf2_per_cu_data::text_offset)\n\t(dwarf2_per_cu_data::addr_type): Now methods.\n\t(per_cu_header_read_in): Make per_cu \"const\".\n\t(dwarf2_version): Remove.\n\t(dwarf2_per_cu_data::int_type): Now a method.\n\t(dwarf2_per_cu_data::_addr_sized_int_type): Likewise.\n\t(set_die_type, read_array_type, read_subrange_index_type)\n\t(read_tag_string_type, read_subrange_type): Update.\n\t* dwarf2/read.h (struct dwarf2_per_cu_data) <addr_size,\n\toffset_size, ref_addr_size, text_offset, addr_type, version,\n\tobjfile, int_type, addr_sized_int_type>: Declare methods.\n\nChange-Id: I07a42fa26e00795352389fa7a0cc1c12997d26f7",
    "tree": {
      "sha": "5d883bb6d9ee48fc11cc6e8418582a222c3d1b63",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5d883bb6d9ee48fc11cc6e8418582a222c3d1b63"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/09ba997f323198495bcf6884dd402fa5b9cc8978",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/09ba997f323198495bcf6884dd402fa5b9cc8978",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/09ba997f323198495bcf6884dd402fa5b9cc8978",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/09ba997f323198495bcf6884dd402fa5b9cc8978/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "96c738c02fe6cee17476fb4a904e3af3d9dff3a6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/96c738c02fe6cee17476fb4a904e3af3d9dff3a6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/96c738c02fe6cee17476fb4a904e3af3d9dff3a6"
    }
  ],
  "stats": {
    "total": 291,
    "additions": 157,
    "deletions": 134
  },
  "files": [
    {
      "sha": "6bce0eb8159297da40d244ed0924c06d18d2ea91",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=09ba997f323198495bcf6884dd402fa5b9cc8978",
      "patch": "@@ -1,3 +1,35 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/loc.c (dwarf2_find_location_expression)\n+\t(dwarf_evaluate_loc_desc::get_tls_address)\n+\t(dwarf_evaluate_loc_desc::push_dwarf_reg_entry_value)\n+\t(rw_pieced_value, dwarf2_evaluate_loc_desc_full)\n+\t(dwarf2_locexpr_baton_eval, dwarf2_evaluate_property)\n+\t(dwarf2_compile_property_to_c)\n+\t(dwarf2_loc_desc_get_symbol_read_needs)\n+\t(dwarf2_compile_expr_to_ax, locexpr_describe_location)\n+\t(locexpr_tracepoint_var_ref, locexpr_generate_c_location)\n+\t(loclist_describe_location, loclist_tracepoint_var_ref)\n+\t(loclist_generate_c_location): Update.\n+\t* compile/compile-loc2c.c (do_compile_dwarf_expr_to_c): Update.\n+\t* dwarf2/loc.h (dwarf2_per_cu_objfile, dwarf2_per_cu_addr_size)\n+\t(dwarf2_per_cu_ref_addr_size, dwarf2_per_cu_offset_size)\n+\t(dwarf2_per_cu_text_offset, dwarf2_version): Don't declare.\n+\t* dwarf2/read.c (dwarf2_per_cu_data::objfile)\n+\t(dwarf2_per_cu_data::addr_size)\n+\t(dwarf2_per_cu_data::ref_addr_size)\n+\t(dwarf2_per_cu_data::text_offset)\n+\t(dwarf2_per_cu_data::addr_type): Now methods.\n+\t(per_cu_header_read_in): Make per_cu \"const\".\n+\t(dwarf2_version): Remove.\n+\t(dwarf2_per_cu_data::int_type): Now a method.\n+\t(dwarf2_per_cu_data::_addr_sized_int_type): Likewise.\n+\t(set_die_type, read_array_type, read_subrange_index_type)\n+\t(read_tag_string_type, read_subrange_type): Update.\n+\t* dwarf2/read.h (struct dwarf2_per_cu_data) <addr_size,\n+\toffset_size, ref_addr_size, text_offset, addr_type, version,\n+\tobjfile, int_type, addr_sized_int_type>: Declare methods.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.h (struct dwarf2_per_cu_data) <imported_symtabs>:"
    },
    {
      "sha": "06a044de0483f5d17bcd6acfaac965a307bf87f5",
      "filename": "gdb/compile/compile-loc2c.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/compile/compile-loc2c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/compile/compile-loc2c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-loc2c.c?ref=09ba997f323198495bcf6884dd402fa5b9cc8978",
      "patch": "@@ -21,6 +21,7 @@\n #include \"dwarf2.h\"\n #include \"dwarf2/expr.h\"\n #include \"dwarf2/loc.h\"\n+#include \"dwarf2/read.h\"\n #include \"ui-file.h\"\n #include \"utils.h\"\n #include \"compile-internal.h\"\n@@ -718,7 +719,7 @@ do_compile_dwarf_expr_to_c (int indent, string_file *stream,\n \t     index, not an address.  We don't support things like\n \t     branching between the address and the TLS op.  */\n \t  if (op_ptr >= op_end || *op_ptr != DW_OP_GNU_push_tls_address)\n-\t    uoffset += dwarf2_per_cu_text_offset (per_cu);\n+\t    uoffset += per_cu->text_offset ();\n \t  push (indent, stream, uoffset);\n \t  break;\n "
    },
    {
      "sha": "ad13e8920ff4c7f3d6ebf5a2af9c7b39be7059e1",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 36,
      "deletions": 37,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=09ba997f323198495bcf6884dd402fa5b9cc8978",
      "patch": "@@ -312,13 +312,13 @@ const gdb_byte *\n dwarf2_find_location_expression (struct dwarf2_loclist_baton *baton,\n \t\t\t\t size_t *locexpr_length, CORE_ADDR pc)\n {\n-  struct objfile *objfile = dwarf2_per_cu_objfile (baton->per_cu);\n+  struct objfile *objfile = baton->per_cu->objfile ();\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  unsigned int addr_size = dwarf2_per_cu_addr_size (baton->per_cu);\n+  unsigned int addr_size = baton->per_cu->addr_size ();\n   int signed_addr_p = bfd_get_sign_extend_vma (objfile->obfd);\n   /* Adjust base_address for relocatable objects.  */\n-  CORE_ADDR base_offset = dwarf2_per_cu_text_offset (baton->per_cu);\n+  CORE_ADDR base_offset = baton->per_cu->text_offset ();\n   CORE_ADDR base_address = baton->base_address + base_offset;\n   const gdb_byte *loc_ptr, *buf_end;\n \n@@ -336,7 +336,7 @@ dwarf2_find_location_expression (struct dwarf2_loclist_baton *baton,\n \tkind = decode_debug_loc_dwo_addresses (baton->per_cu,\n \t\t\t\t\t       loc_ptr, buf_end, &new_ptr,\n \t\t\t\t\t       &low, &high, byte_order);\n-      else if (dwarf2_version (baton->per_cu) < 5)\n+      else if (baton->per_cu->version () < 5)\n \tkind = decode_debug_loc_addresses (loc_ptr, buf_end, &new_ptr,\n \t\t\t\t\t   &low, &high,\n \t\t\t\t\t   byte_order, addr_size,\n@@ -382,7 +382,7 @@ dwarf2_find_location_expression (struct dwarf2_loclist_baton *baton,\n \t  high += base_address;\n \t}\n \n-      if (dwarf2_version (baton->per_cu) < 5)\n+      if (baton->per_cu->version () < 5)\n \t{\n \t  length = extract_unsigned_integer (loc_ptr, 2, byte_order);\n \t  loc_ptr += 2;\n@@ -643,7 +643,7 @@ class dwarf_evaluate_loc_desc : public dwarf_expr_context\n      current thread's thread-local storage with offset OFFSET.  */\n   CORE_ADDR get_tls_address (CORE_ADDR offset) override\n   {\n-    struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);\n+    struct objfile *objfile = per_cu->objfile ();\n \n     return target_translate_tls_address (objfile, offset);\n   }\n@@ -730,12 +730,11 @@ class dwarf_evaluate_loc_desc : public dwarf_expr_context\n \t\t\t\t\t\t\t(CORE_ADDR) 0);\n \n     scoped_restore save_arch = make_scoped_restore (&this->gdbarch);\n-    this->gdbarch\n-      = get_objfile_arch (dwarf2_per_cu_objfile (per_cu));\n+    this->gdbarch = get_objfile_arch (per_cu->objfile ());\n     scoped_restore save_addr_size = make_scoped_restore (&this->addr_size);\n-    this->addr_size = dwarf2_per_cu_addr_size (per_cu);\n+    this->addr_size = per_cu->addr_size ();\n     scoped_restore save_offset = make_scoped_restore (&this->offset);\n-    this->offset = dwarf2_per_cu_text_offset (per_cu);\n+    this->offset = per_cu->text_offset ();\n \n     this->eval (data_src, size);\n   }\n@@ -1819,7 +1818,7 @@ rw_pieced_value (struct value *v, struct value *from)\n \t\tbreak;\n \t      }\n \n-\t    struct objfile *objfile = dwarf2_per_cu_objfile (c->per_cu);\n+\t    struct objfile *objfile = c->per_cu->objfile ();\n \t    struct gdbarch *objfile_gdbarch = get_objfile_arch (objfile);\n \t    ULONGEST stack_value_size_bits\n \t      = 8 * TYPE_LENGTH (value_type (p->v.value));\n@@ -2176,7 +2175,7 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n \t\t\t       LONGEST subobj_byte_offset)\n {\n   struct value *retval;\n-  struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);\n+  struct objfile *objfile = per_cu->objfile ();\n \n   if (subobj_type == NULL)\n     {\n@@ -2197,9 +2196,9 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n   scoped_value_mark free_values;\n \n   ctx.gdbarch = get_objfile_arch (objfile);\n-  ctx.addr_size = dwarf2_per_cu_addr_size (per_cu);\n-  ctx.ref_addr_size = dwarf2_per_cu_ref_addr_size (per_cu);\n-  ctx.offset = dwarf2_per_cu_text_offset (per_cu);\n+  ctx.addr_size = per_cu->addr_size ();\n+  ctx.ref_addr_size = per_cu->ref_addr_size ();\n+  ctx.offset = per_cu->text_offset ();\n \n   try\n     {\n@@ -2411,12 +2410,12 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n   ctx.per_cu = dlbaton->per_cu;\n   ctx.obj_address = addr;\n \n-  objfile = dwarf2_per_cu_objfile (dlbaton->per_cu);\n+  objfile = dlbaton->per_cu->objfile ();\n \n   ctx.gdbarch = get_objfile_arch (objfile);\n-  ctx.addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);\n-  ctx.ref_addr_size = dwarf2_per_cu_ref_addr_size (dlbaton->per_cu);\n-  ctx.offset = dwarf2_per_cu_text_offset (dlbaton->per_cu);\n+  ctx.addr_size = dlbaton->per_cu->addr_size ();\n+  ctx.ref_addr_size = dlbaton->per_cu->ref_addr_size ();\n+  ctx.offset = dlbaton->per_cu->text_offset ();\n \n   try\n     {\n@@ -2504,7 +2503,7 @@ dwarf2_evaluate_property (const struct dynamic_prop *prop,\n \t\t       CORE_ADDR on 64bit machine has 8 bytes but address\n \t\t       size of an 32bit application is bytes.  */\n \t\t    const int addr_size\n-\t\t      = (dwarf2_per_cu_addr_size (baton->locexpr.per_cu)\n+\t\t      = (baton->locexpr.per_cu->addr_size ()\n \t\t\t * TARGET_CHAR_BIT);\n \t\t    const CORE_ADDR neg_mask\n \t\t      = (~((CORE_ADDR) 0) <<  (addr_size - 1));\n@@ -2610,7 +2609,7 @@ dwarf2_compile_property_to_c (string_file *stream,\n \n   compile_dwarf_bounds_to_c (stream, result_name, prop, sym, pc,\n \t\t\t     gdbarch, registers_used,\n-\t\t\t     dwarf2_per_cu_addr_size (per_cu),\n+\t\t\t     per_cu->addr_size (),\n \t\t\t     data, data + size, per_cu);\n }\n \n@@ -2732,7 +2731,7 @@ dwarf2_loc_desc_get_symbol_read_needs (const gdb_byte *data, size_t size,\n \t\t\t\t       struct dwarf2_per_cu_data *per_cu)\n {\n   int in_reg;\n-  struct objfile *objfile = dwarf2_per_cu_objfile (per_cu);\n+  struct objfile *objfile = per_cu->objfile ();\n \n   scoped_value_mark free_values;\n \n@@ -2741,9 +2740,9 @@ dwarf2_loc_desc_get_symbol_read_needs (const gdb_byte *data, size_t size,\n   ctx.needs = SYMBOL_NEEDS_NONE;\n   ctx.per_cu = per_cu;\n   ctx.gdbarch = get_objfile_arch (objfile);\n-  ctx.addr_size = dwarf2_per_cu_addr_size (per_cu);\n-  ctx.ref_addr_size = dwarf2_per_cu_ref_addr_size (per_cu);\n-  ctx.offset = dwarf2_per_cu_text_offset (per_cu);\n+  ctx.addr_size = per_cu->addr_size ();\n+  ctx.ref_addr_size = per_cu->ref_addr_size ();\n+  ctx.offset = per_cu->text_offset ();\n \n   ctx.eval (data, size);\n \n@@ -2984,7 +2983,7 @@ dwarf2_compile_expr_to_ax (struct agent_expr *expr, struct axs_value *loc,\n \t     index, not an address.  We don't support things like\n \t     branching between the address and the TLS op.  */\n \t  if (op_ptr >= op_end || *op_ptr != DW_OP_GNU_push_tls_address)\n-\t    uoffset += dwarf2_per_cu_text_offset (per_cu);\n+\t    uoffset += per_cu->text_offset ();\n \t  ax_const_l (expr, uoffset);\n \t  break;\n \n@@ -4292,9 +4291,9 @@ locexpr_describe_location (struct symbol *symbol, CORE_ADDR addr,\n {\n   struct dwarf2_locexpr_baton *dlbaton\n     = (struct dwarf2_locexpr_baton *) SYMBOL_LOCATION_BATON (symbol);\n-  struct objfile *objfile = dwarf2_per_cu_objfile (dlbaton->per_cu);\n-  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);\n-  int offset_size = dwarf2_per_cu_offset_size (dlbaton->per_cu);\n+  struct objfile *objfile = dlbaton->per_cu->objfile ();\n+  unsigned int addr_size = dlbaton->per_cu->addr_size ();\n+  int offset_size = dlbaton->per_cu->offset_size ();\n \n   locexpr_describe_location_1 (symbol, addr, stream,\n \t\t\t       dlbaton->data, dlbaton->size,\n@@ -4311,7 +4310,7 @@ locexpr_tracepoint_var_ref (struct symbol *symbol, struct agent_expr *ax,\n {\n   struct dwarf2_locexpr_baton *dlbaton\n     = (struct dwarf2_locexpr_baton *) SYMBOL_LOCATION_BATON (symbol);\n-  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);\n+  unsigned int addr_size = dlbaton->per_cu->addr_size ();\n \n   if (dlbaton->size == 0)\n     value->optimized_out = 1;\n@@ -4330,7 +4329,7 @@ locexpr_generate_c_location (struct symbol *sym, string_file *stream,\n {\n   struct dwarf2_locexpr_baton *dlbaton\n     = (struct dwarf2_locexpr_baton *) SYMBOL_LOCATION_BATON (sym);\n-  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);\n+  unsigned int addr_size = dlbaton->per_cu->addr_size ();\n \n   if (dlbaton->size == 0)\n     error (_(\"symbol \\\"%s\\\" is optimized out\"), sym->natural_name ());\n@@ -4429,14 +4428,14 @@ loclist_describe_location (struct symbol *symbol, CORE_ADDR addr,\n   struct dwarf2_loclist_baton *dlbaton\n     = (struct dwarf2_loclist_baton *) SYMBOL_LOCATION_BATON (symbol);\n   const gdb_byte *loc_ptr, *buf_end;\n-  struct objfile *objfile = dwarf2_per_cu_objfile (dlbaton->per_cu);\n+  struct objfile *objfile = dlbaton->per_cu->objfile ();\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);\n-  int offset_size = dwarf2_per_cu_offset_size (dlbaton->per_cu);\n+  unsigned int addr_size = dlbaton->per_cu->addr_size ();\n+  int offset_size = dlbaton->per_cu->offset_size ();\n   int signed_addr_p = bfd_get_sign_extend_vma (objfile->obfd);\n   /* Adjust base_address for relocatable objects.  */\n-  CORE_ADDR base_offset = dwarf2_per_cu_text_offset (dlbaton->per_cu);\n+  CORE_ADDR base_offset = dlbaton->per_cu->text_offset ();\n   CORE_ADDR base_address = dlbaton->base_address + base_offset;\n   int done = 0;\n \n@@ -4520,7 +4519,7 @@ loclist_tracepoint_var_ref (struct symbol *symbol, struct agent_expr *ax,\n     = (struct dwarf2_loclist_baton *) SYMBOL_LOCATION_BATON (symbol);\n   const gdb_byte *data;\n   size_t size;\n-  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);\n+  unsigned int addr_size = dlbaton->per_cu->addr_size ();\n \n   data = dwarf2_find_location_expression (dlbaton, &size, ax->scope);\n   if (size == 0)\n@@ -4540,7 +4539,7 @@ loclist_generate_c_location (struct symbol *sym, string_file *stream,\n {\n   struct dwarf2_loclist_baton *dlbaton\n     = (struct dwarf2_loclist_baton *) SYMBOL_LOCATION_BATON (sym);\n-  unsigned int addr_size = dwarf2_per_cu_addr_size (dlbaton->per_cu);\n+  unsigned int addr_size = dlbaton->per_cu->addr_size ();\n   const gdb_byte *data;\n   size_t size;\n "
    },
    {
      "sha": "2cc7e066a339451ef5b10b52ac257f7a02764976",
      "filename": "gdb/dwarf2/loc.h",
      "status": "modified",
      "additions": 0,
      "deletions": 23,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/dwarf2/loc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/dwarf2/loc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.h?ref=09ba997f323198495bcf6884dd402fa5b9cc8978",
      "patch": "@@ -35,29 +35,6 @@ struct axs_value;\n /* `set debug entry-values' setting.  */\n extern unsigned int entry_values_debug;\n \n-/* Return the OBJFILE associated with the compilation unit CU.  If CU\n-   came from a separate debuginfo file, then the master objfile is\n-   returned.  */\n-struct objfile *dwarf2_per_cu_objfile (struct dwarf2_per_cu_data *cu);\n-\n-/* Return the address size given in the compilation unit header for CU.  */\n-int dwarf2_per_cu_addr_size (struct dwarf2_per_cu_data *cu);\n-\n-/* Return the DW_FORM_ref_addr size given in the compilation unit header for\n-   CU.  */\n-int dwarf2_per_cu_ref_addr_size (struct dwarf2_per_cu_data *cu);\n-\n-/* Return the offset size given in the compilation unit header for CU.  */\n-int dwarf2_per_cu_offset_size (struct dwarf2_per_cu_data *cu);\n-\n-/* Return the text offset of the CU.  The returned offset comes from\n-   this CU's objfile.  If this objfile came from a separate debuginfo\n-   file, then the offset may be different from the corresponding\n-   offset in the parent objfile.  */\n-CORE_ADDR dwarf2_per_cu_text_offset (struct dwarf2_per_cu_data *cu);\n-\n-short dwarf2_version (struct dwarf2_per_cu_data *per_cu);\n-\n /* Find a particular location expression from a location list.  */\n const gdb_byte *dwarf2_find_location_expression\n   (struct dwarf2_loclist_baton *baton,"
    },
    {
      "sha": "474ed4d9b49b87b560d7091c682fe8dc81380f76",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 44,
      "deletions": 73,
      "changes": 117,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=09ba997f323198495bcf6884dd402fa5b9cc8978",
      "patch": "@@ -1639,13 +1639,6 @@ static void queue_comp_unit (struct dwarf2_per_cu_data *per_cu,\n \n static void process_queue (struct dwarf2_per_objfile *dwarf2_per_objfile);\n \n-static struct type *dwarf2_per_cu_addr_type (struct dwarf2_per_cu_data *per_cu);\n-static struct type *dwarf2_per_cu_addr_sized_int_type\n-\t(struct dwarf2_per_cu_data *per_cu, bool unsigned_p);\n-static struct type *dwarf2_per_cu_int_type\n-\t(struct dwarf2_per_cu_data *per_cu, int size_in_bytes,\n-\t bool unsigned_p);\n-\n /* Class, the destructor of which frees all allocated queue entries.  This\n    will only have work to do if an error was thrown while processing the\n    dwarf.  If no error was thrown then the queue entries should have all\n@@ -13169,7 +13162,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n       newobj->static_link\n \t= XOBNEW (&objfile->objfile_obstack, struct dynamic_prop);\n       attr_to_dynamic_prop (attr, die, cu, newobj->static_link,\n-\t\t\t    dwarf2_per_cu_addr_type (cu->per_cu));\n+\t\t\t    cu->per_cu->addr_type ());\n     }\n \n   cu->list_in_scope = cu->get_builder ()->get_local_symbols ();\n@@ -16006,8 +15999,7 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n   if (attr != NULL)\n     {\n       int stride_ok;\n-      struct type *prop_type\n-\t= dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+      struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n \n       byte_stride_prop\n \t= (struct dynamic_prop *) alloca (sizeof (struct dynamic_prop));\n@@ -16809,13 +16801,13 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n \t  /* Pass 0 as the default as we know this attribute is constant\n \t     and the default value will not be returned.  */\n \t  LONGEST sz = dwarf2_get_attr_constant_value (len, 0);\n-\t  prop_type = dwarf2_per_cu_int_type (cu->per_cu, sz, true);\n+\t  prop_type = cu->per_cu->int_type (sz, true);\n \t}\n       else\n \t{\n \t  /* If the size is not specified then we assume it is the size of\n \t     an address on this target.  */\n-\t  prop_type = dwarf2_per_cu_addr_sized_int_type (cu->per_cu, true);\n+\t  prop_type = cu->per_cu->addr_sized_int_type (true);\n \t}\n \n       /* Convert the attribute into a dynamic property.  */\n@@ -17417,14 +17409,12 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n   return 1;\n }\n \n-/* Find an integer type SIZE_IN_BYTES bytes in size and return it.\n-   UNSIGNED_P controls if the integer is unsigned or not.  */\n+/* See read.h.  */\n \n-static struct type *\n-dwarf2_per_cu_int_type (struct dwarf2_per_cu_data *per_cu,\n-\t\t\tint size_in_bytes, bool unsigned_p)\n+struct type *\n+dwarf2_per_cu_data::int_type (int size_in_bytes, bool unsigned_p) const\n {\n-  struct objfile *objfile = per_cu->dwarf2_per_objfile->objfile;\n+  struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct type *int_type;\n \n   /* Helper macro to examine the various builtin types.  */\n@@ -17446,16 +17436,13 @@ dwarf2_per_cu_int_type (struct dwarf2_per_cu_data *per_cu,\n   gdb_assert_not_reached (\"unable to find suitable integer type\");\n }\n \n-/* Find an integer type the same size as the address size given in the\n-   compilation unit header for PER_CU.  UNSIGNED_P controls if the integer\n-   is unsigned or not.  */\n+/* See read.h.  */\n \n-static struct type *\n-dwarf2_per_cu_addr_sized_int_type (struct dwarf2_per_cu_data *per_cu,\n-\t\t\t\t   bool unsigned_p)\n+struct type *\n+dwarf2_per_cu_data::addr_sized_int_type (bool unsigned_p) const\n {\n-  int addr_size = dwarf2_per_cu_addr_size (per_cu);\n-  return dwarf2_per_cu_int_type (per_cu, addr_size, unsigned_p);\n+  int addr_size = this->addr_size ();\n+  return int_type (addr_size, unsigned_p);\n }\n \n /* Read the DW_AT_type attribute for a sub-range.  If this attribute is not\n@@ -17480,7 +17467,7 @@ read_subrange_index_type (struct die_info *die, struct dwarf2_cu *cu)\n      FIXME: muller/2010-05-28: Possible references to object for low bound,\n      high bound or count are not yet handled by this code.  */\n   if (TYPE_CODE (index_type) == TYPE_CODE_VOID)\n-    index_type = dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+    index_type = cu->per_cu->addr_sized_int_type (false);\n \n   return index_type;\n }\n@@ -17610,8 +17597,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n   attribute *attr_byte_stride = dwarf2_attr (die, DW_AT_byte_stride, cu);\n   if (attr_byte_stride != nullptr)\n     {\n-      struct type *prop_type\n-\t= dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+      struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n       attr_to_dynamic_prop (attr_byte_stride, die, cu, &byte_stride_prop,\n \t\t\t    prop_type);\n     }\n@@ -17631,8 +17617,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \t}\n       else\n \t{\n-\t  struct type *prop_type\n-\t    = dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+\t  struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n \t  attr_to_dynamic_prop (attr_bit_stride, die, cu, &bit_stride_prop,\n \t\t\t\tprop_type);\n \t}\n@@ -24523,14 +24508,12 @@ dwarf2_symbol_mark_computed (const struct attribute *attr, struct symbol *sym,\n     }\n }\n \n-/* Return the OBJFILE associated with the compilation unit CU.  If CU\n-   came from a separate debuginfo file, then the master objfile is\n-   returned.  */\n+/* See read.h.  */\n \n struct objfile *\n-dwarf2_per_cu_objfile (struct dwarf2_per_cu_data *per_cu)\n+dwarf2_per_cu_data::objfile () const\n {\n-  struct objfile *objfile = per_cu->dwarf2_per_objfile->objfile;\n+  struct objfile *objfile = dwarf2_per_objfile->objfile;\n \n   /* Return the master objfile, so that we can report and look up the\n      correct file containing this variable.  */\n@@ -24546,7 +24529,7 @@ dwarf2_per_cu_objfile (struct dwarf2_per_cu_data *per_cu)\n \n static const struct comp_unit_head *\n per_cu_header_read_in (struct comp_unit_head *cu_headerp,\n-\t\t       struct dwarf2_per_cu_data *per_cu)\n+\t\t       const struct dwarf2_per_cu_data *per_cu)\n {\n   const gdb_byte *info_ptr;\n \n@@ -24562,85 +24545,75 @@ per_cu_header_read_in (struct comp_unit_head *cu_headerp,\n   return cu_headerp;\n }\n \n-/* Return the address size given in the compilation unit header for CU.  */\n+/* See read.h.  */\n \n int\n-dwarf2_per_cu_addr_size (struct dwarf2_per_cu_data *per_cu)\n+dwarf2_per_cu_data::addr_size () const\n {\n   struct comp_unit_head cu_header_local;\n   const struct comp_unit_head *cu_headerp;\n \n-  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);\n+  cu_headerp = per_cu_header_read_in (&cu_header_local, this);\n \n   return cu_headerp->addr_size;\n }\n \n-/* Return the offset size given in the compilation unit header for CU.  */\n+/* See read.h.  */\n \n int\n-dwarf2_per_cu_offset_size (struct dwarf2_per_cu_data *per_cu)\n+dwarf2_per_cu_data::offset_size () const\n {\n   struct comp_unit_head cu_header_local;\n   const struct comp_unit_head *cu_headerp;\n \n-  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);\n+  cu_headerp = per_cu_header_read_in (&cu_header_local, this);\n \n   return cu_headerp->offset_size;\n }\n \n-/* See its dwarf2loc.h declaration.  */\n+/* See read.h.  */\n \n int\n-dwarf2_per_cu_ref_addr_size (struct dwarf2_per_cu_data *per_cu)\n+dwarf2_per_cu_data::ref_addr_size () const\n {\n   struct comp_unit_head cu_header_local;\n   const struct comp_unit_head *cu_headerp;\n \n-  cu_headerp = per_cu_header_read_in (&cu_header_local, per_cu);\n+  cu_headerp = per_cu_header_read_in (&cu_header_local, this);\n \n   if (cu_headerp->version == 2)\n     return cu_headerp->addr_size;\n   else\n     return cu_headerp->offset_size;\n }\n \n-/* Return the text offset of the CU.  The returned offset comes from\n-   this CU's objfile.  If this objfile came from a separate debuginfo\n-   file, then the offset may be different from the corresponding\n-   offset in the parent objfile.  */\n+/* See read.h.  */\n \n CORE_ADDR\n-dwarf2_per_cu_text_offset (struct dwarf2_per_cu_data *per_cu)\n+dwarf2_per_cu_data::text_offset () const\n {\n-  return per_cu->dwarf2_per_objfile->objfile->text_section_offset ();\n+  struct objfile *objfile = dwarf2_per_objfile->objfile;\n+\n+  return objfile->text_section_offset ();\n }\n \n-/* Return a type that is a generic pointer type, the size of which matches\n-   the address size given in the compilation unit header for PER_CU.  */\n-static struct type *\n-dwarf2_per_cu_addr_type (struct dwarf2_per_cu_data *per_cu)\n+/* See read.h.  */\n+\n+struct type *\n+dwarf2_per_cu_data::addr_type () const\n {\n-  struct objfile *objfile = per_cu->dwarf2_per_objfile->objfile;\n+  struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct type *void_type = objfile_type (objfile)->builtin_void;\n   struct type *addr_type = lookup_pointer_type (void_type);\n-  int addr_size = dwarf2_per_cu_addr_size (per_cu);\n+  int addr_size = this->addr_size ();\n \n   if (TYPE_LENGTH (addr_type) == addr_size)\n     return addr_type;\n \n-  addr_type\n-    = dwarf2_per_cu_addr_sized_int_type (per_cu, TYPE_UNSIGNED (addr_type));\n+  addr_type = addr_sized_int_type (TYPE_UNSIGNED (addr_type));\n   return addr_type;\n }\n \n-/* Return DWARF version number of PER_CU.  */\n-\n-short\n-dwarf2_version (struct dwarf2_per_cu_data *per_cu)\n-{\n-  return per_cu->dwarf_version;\n-}\n-\n /* Locate the .debug_info compilation unit from CU's objfile which contains\n    the DIE at OFFSET.  Raises an error on failure.  */\n \n@@ -24899,8 +24872,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_allocated, cu);\n   if (attr != NULL && attr->form_is_block ())\n     {\n-      struct type *prop_type\n-\t= dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+      struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n       if (attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n         add_dyn_prop (DYN_PROP_ALLOCATED, prop, type);\n     }\n@@ -24915,8 +24887,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n   attr = dwarf2_attr (die, DW_AT_associated, cu);\n   if (attr != NULL && attr->form_is_block ())\n     {\n-      struct type *prop_type\n-\t= dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+      struct type *prop_type = cu->per_cu->addr_sized_int_type (false);\n       if (attr_to_dynamic_prop (attr, die, cu, &prop, prop_type))\n         add_dyn_prop (DYN_PROP_ASSOCIATED, prop, type);\n     }\n@@ -24930,7 +24901,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n   /* Read DW_AT_data_location and set in type.  */\n   attr = dwarf2_attr (die, DW_AT_data_location, cu);\n   if (attr_to_dynamic_prop (attr, die, cu, &prop,\n-\t\t\t    dwarf2_per_cu_addr_type (cu->per_cu)))\n+\t\t\t    cu->per_cu->addr_type ()))\n     add_dyn_prop (DYN_PROP_DATA_LOCATION, prop, type);\n \n   if (dwarf2_per_objfile->die_type_hash == NULL)"
    },
    {
      "sha": "b06c2e218c13542fdc911feaf8f900505c813c83",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 43,
      "deletions": 0,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/09ba997f323198495bcf6884dd402fa5b9cc8978/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=09ba997f323198495bcf6884dd402fa5b9cc8978",
      "patch": "@@ -394,6 +394,49 @@ struct dwarf2_per_cu_data\n     delete imported_symtabs;\n     imported_symtabs = nullptr;\n   }\n+\n+  /* Return the OBJFILE associated with this compilation unit.  If\n+     this compilation unit came from a separate debuginfo file, then\n+     the master objfile is returned.  */\n+  struct objfile *objfile () const;\n+\n+  /* Return the address size given in the compilation unit header for\n+     this CU.  */\n+  int addr_size () const;\n+\n+  /* Return the offset size given in the compilation unit header for\n+     this CU.  */\n+  int offset_size () const;\n+\n+  /* Return the DW_FORM_ref_addr size given in the compilation unit\n+     header for this CU.  */\n+  int ref_addr_size () const;\n+\n+  /* Return the text offset of the CU.  The returned offset comes from\n+     this CU's objfile.  If this objfile came from a separate\n+     debuginfo file, then the offset may be different from the\n+     corresponding offset in the parent objfile.  */\n+  CORE_ADDR text_offset () const;\n+\n+  /* Return a type that is a generic pointer type, the size of which\n+     matches the address size given in the compilation unit header for\n+     this CU.  */\n+  struct type *addr_type () const;\n+\n+  /* Find an integer type SIZE_IN_BYTES bytes in size and return it.\n+     UNSIGNED_P controls if the integer is unsigned or not.  */\n+  struct type *int_type (int size_in_bytes, bool unsigned_p) const;\n+\n+  /* Find an integer type the same size as the address size given in\n+     the compilation unit header for this CU.  UNSIGNED_P controls if\n+     the integer is unsigned or not.  */\n+  struct type *addr_sized_int_type (bool unsigned_p) const;\n+\n+  /* Return DWARF version number of this CU.  */\n+  short version () const\n+  {\n+    return dwarf_version;\n+  }\n };\n \n /* Entry in the signatured_types hash table.  */"
    }
  ]
}