{
  "sha": "d1183b064cae59353c3a80d27dc250ca440cb879",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDExODNiMDY0Y2FlNTkzNTNjM2E4MGQyN2RjMjUwY2E0NDBjYjg3OQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-03-02T20:00:45Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-03-02T20:00:45Z"
    },
    "message": "Return a vector from ada_lookup_symbol_list\n\nThis changes ada_lookup_symbol_list to return a std::vector, and\nchanges various other helper functions to follow.  This simplifies the\ncode, and makes it more type-safe (by using a vector where an obstack\nhad been used).\n\ngdb/ChangeLog\n2021-03-02  Tom Tromey  <tromey@adacore.com>\n\n\t* ada-lang.h (ada_lookup_symbol_list): Return a vector.\n\t* ada-lang.c (resolve_subexp): Update.\n\t(ada_resolve_function): Accept a vector.\n\t(is_nonfunction, add_defn_to_vec)\n\t(add_symbols_from_enclosing_procs): Likewise.\n\t(num_defns_collected, defns_collected): Remove.\n\t(remove_extra_symbols): Return a vector.\n\t(remove_irrelevant_renamings): Return void.\n\t(ada_add_local_symbols): Accept a vector.\n\t(struct match_data) <obstackp>: Remove.\n\t<resultp>: New member.\n\t(aux_add_nonlocal_symbols): Update.\n\t(ada_add_block_renamings, add_nonlocal_symbols)\n\t(ada_add_all_symbols): Accept a vector.\n\t(ada_lookup_symbol_list_worker, ada_lookup_symbol_list): Return a\n\tvector.\n\t(ada_lookup_symbol): Update.\n\t(ada_add_block_symbols): Accept a vector.\n\t(get_var_value, iterate_over_symbols): Update.\n\t* ada-exp.y (block_lookup, write_var_or_type, write_name_assoc):\n\tUpdate.",
    "tree": {
      "sha": "3c785263d8956cffeacc78319fd7dace968f3daa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3c785263d8956cffeacc78319fd7dace968f3daa"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d1183b064cae59353c3a80d27dc250ca440cb879",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d1183b064cae59353c3a80d27dc250ca440cb879",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d1183b064cae59353c3a80d27dc250ca440cb879",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d1183b064cae59353c3a80d27dc250ca440cb879/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "886d459fbea73da4b07bae37f4526b766cbd90e8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/886d459fbea73da4b07bae37f4526b766cbd90e8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/886d459fbea73da4b07bae37f4526b766cbd90e8"
    }
  ],
  "stats": {
    "total": 363,
    "additions": 158,
    "deletions": 205
  },
  "files": [
    {
      "sha": "049e463b7ff1436e71f0944be01f3b56a032c16e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1183b064cae59353c3a80d27dc250ca440cb879/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1183b064cae59353c3a80d27dc250ca440cb879/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d1183b064cae59353c3a80d27dc250ca440cb879",
      "patch": "@@ -1,3 +1,27 @@\n+2021-03-02  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ada-lang.h (ada_lookup_symbol_list): Return a vector.\n+\t* ada-lang.c (resolve_subexp): Update.\n+\t(ada_resolve_function): Accept a vector.\n+\t(is_nonfunction, add_defn_to_vec)\n+\t(add_symbols_from_enclosing_procs): Likewise.\n+\t(num_defns_collected, defns_collected): Remove.\n+\t(remove_extra_symbols): Return a vector.\n+\t(remove_irrelevant_renamings): Return void.\n+\t(ada_add_local_symbols): Accept a vector.\n+\t(struct match_data) <obstackp>: Remove.\n+\t<resultp>: New member.\n+\t(aux_add_nonlocal_symbols): Update.\n+\t(ada_add_block_renamings, add_nonlocal_symbols)\n+\t(ada_add_all_symbols): Accept a vector.\n+\t(ada_lookup_symbol_list_worker, ada_lookup_symbol_list): Return a\n+\tvector.\n+\t(ada_lookup_symbol): Update.\n+\t(ada_add_block_symbols): Accept a vector.\n+\t(get_var_value, iterate_over_symbols): Update.\n+\t* ada-exp.y (block_lookup, write_var_or_type, write_name_assoc):\n+\tUpdate.\n+\n 2021-03-02  Tom Tromey  <tromey@adacore.com>\n \n \t* ada-lang.c (resolve_subexp): Use any_of and erase-remove idiom."
    },
    {
      "sha": "a7e0ccbe5b133639ad1e4f735f020f70003030a1",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 16,
      "deletions": 19,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1183b064cae59353c3a80d27dc250ca440cb879/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1183b064cae59353c3a80d27dc250ca440cb879/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=d1183b064cae59353c3a80d27dc250ca440cb879",
      "patch": "@@ -948,8 +948,6 @@ static const struct block*\n block_lookup (const struct block *context, const char *raw_name)\n {\n   const char *name;\n-  std::vector<struct block_symbol> syms;\n-  int nsyms;\n   struct symtab *symtab;\n   const struct block *result = NULL;\n \n@@ -965,17 +963,18 @@ block_lookup (const struct block *context, const char *raw_name)\n       name = name_storage.c_str ();\n     }\n \n-  nsyms = ada_lookup_symbol_list (name, context, VAR_DOMAIN, &syms);\n+  std::vector<struct block_symbol> syms\n+    = ada_lookup_symbol_list (name, context, VAR_DOMAIN);\n \n   if (context == NULL\n-      && (nsyms == 0 || SYMBOL_CLASS (syms[0].symbol) != LOC_BLOCK))\n+      && (syms.empty () || SYMBOL_CLASS (syms[0].symbol) != LOC_BLOCK))\n     symtab = lookup_symtab (name);\n   else\n     symtab = NULL;\n \n   if (symtab != NULL)\n     result = BLOCKVECTOR_BLOCK (SYMTAB_BLOCKVECTOR (symtab), STATIC_BLOCK);\n-  else if (nsyms == 0 || SYMBOL_CLASS (syms[0].symbol) != LOC_BLOCK)\n+  else if (syms.empty () || SYMBOL_CLASS (syms[0].symbol) != LOC_BLOCK)\n     {\n       if (context == NULL)\n \terror (_(\"No file or function \\\"%s\\\".\"), raw_name);\n@@ -984,7 +983,7 @@ block_lookup (const struct block *context, const char *raw_name)\n     }\n   else\n     {\n-      if (nsyms > 1)\n+      if (syms.size () > 1)\n \twarning (_(\"Function name \\\"%s\\\" ambiguous here\"), raw_name);\n       result = SYMBOL_BLOCK_VALUE (syms[0].symbol);\n     }\n@@ -1216,8 +1215,6 @@ write_var_or_type (struct parser_state *par_state,\n       tail_index = name_len;\n       while (tail_index > 0)\n \t{\n-\t  int nsyms;\n-\t  std::vector<struct block_symbol> syms;\n \t  struct symbol *type_sym;\n \t  struct symbol *renaming_sym;\n \t  const char* renaming;\n@@ -1226,15 +1223,15 @@ write_var_or_type (struct parser_state *par_state,\n \t  int terminator = encoded_name[tail_index];\n \n \t  encoded_name[tail_index] = '\\0';\n-\t  nsyms = ada_lookup_symbol_list (encoded_name, block,\n-\t\t\t\t\t  VAR_DOMAIN, &syms);\n+\t  std::vector<struct block_symbol> syms\n+\t    = ada_lookup_symbol_list (encoded_name, block, VAR_DOMAIN);\n \t  encoded_name[tail_index] = terminator;\n \n \t  type_sym = select_possible_type_sym (syms);\n \n \t  if (type_sym != NULL)\n \t    renaming_sym = type_sym;\n-\t  else if (nsyms == 1)\n+\t  else if (syms.size () == 1)\n \t    renaming_sym = syms[0].symbol;\n \t  else \n \t    renaming_sym = NULL;\n@@ -1285,7 +1282,7 @@ write_var_or_type (struct parser_state *par_state,\n \t\terror (_(\"Invalid attempt to select from type: \\\"%s\\\".\"),\n \t\t       name0.ptr);\n \t    }\n-\t  else if (tail_index == name_len && nsyms == 0)\n+\t  else if (tail_index == name_len && syms.empty ())\n \t    {\n \t      struct type *type = find_primitive_type (par_state,\n \t\t\t\t\t\t       encoded_name);\n@@ -1294,13 +1291,13 @@ write_var_or_type (struct parser_state *par_state,\n \t\treturn type;\n \t    }\n \n-\t  if (nsyms == 1)\n+\t  if (syms.size () == 1)\n \t    {\n \t      write_var_from_sym (par_state, syms[0].block, syms[0].symbol);\n \t      write_selectors (par_state, encoded_name + tail_index);\n \t      return NULL;\n \t    }\n-\t  else if (nsyms == 0) \n+\t  else if (syms.empty ()) \n \t    {\n \t      struct bound_minimal_symbol msym\n \t\t= ada_lookup_simple_minsym (encoded_name);\n@@ -1362,12 +1359,12 @@ write_name_assoc (struct parser_state *par_state, struct stoken name)\n {\n   if (strchr (name.ptr, '.') == NULL)\n     {\n-      std::vector<struct block_symbol> syms;\n-      int nsyms = ada_lookup_symbol_list (name.ptr,\n-\t\t\t\t\t  par_state->expression_context_block,\n-\t\t\t\t\t  VAR_DOMAIN, &syms);\n+      std::vector<struct block_symbol> syms\n+\t= ada_lookup_symbol_list (name.ptr,\n+\t\t\t\t  par_state->expression_context_block,\n+\t\t\t\t  VAR_DOMAIN);\n \n-      if (nsyms != 1 || SYMBOL_CLASS (syms[0].symbol) == LOC_TYPEDEF)\n+      if (syms.size () != 1 || SYMBOL_CLASS (syms[0].symbol) == LOC_TYPEDEF)\n \twrite_exp_op_with_string (par_state, OP_NAME, name);\n       else\n \twrite_var_from_sym (par_state, syms[0].block, syms[0].symbol);"
    },
    {
      "sha": "b7da0f3db53f21a006075f8ad3ba61aa5ca99752",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 116,
      "deletions": 183,
      "changes": 299,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1183b064cae59353c3a80d27dc250ca440cb879/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1183b064cae59353c3a80d27dc250ca440cb879/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=d1183b064cae59353c3a80d27dc250ca440cb879",
      "patch": "@@ -100,24 +100,22 @@ static int ada_args_match (struct symbol *, struct value **, int);\n \n static struct value *make_array_descriptor (struct type *, struct value *);\n \n-static void ada_add_block_symbols (struct obstack *,\n+static void ada_add_block_symbols (std::vector<struct block_symbol> &,\n \t\t\t\t   const struct block *,\n \t\t\t\t   const lookup_name_info &lookup_name,\n \t\t\t\t   domain_enum, struct objfile *);\n \n-static void ada_add_all_symbols (struct obstack *, const struct block *,\n+static void ada_add_all_symbols (std::vector<struct block_symbol> &,\n+\t\t\t\t const struct block *,\n \t\t\t\t const lookup_name_info &lookup_name,\n \t\t\t\t domain_enum, int, int *);\n \n-static int is_nonfunction (struct block_symbol *, int);\n+static int is_nonfunction (const std::vector<struct block_symbol> &);\n \n-static void add_defn_to_vec (struct obstack *, struct symbol *,\n+static void add_defn_to_vec (std::vector<struct block_symbol> &,\n+\t\t\t     struct symbol *,\n \t\t\t     const struct block *);\n \n-static int num_defns_collected (struct obstack *);\n-\n-static struct block_symbol *defns_collected (struct obstack *, int);\n-\n static struct value *resolve_subexp (expression_up *, int *, int,\n \t\t\t\t     struct type *, int,\n \t\t\t\t     innermost_block_tracker *);\n@@ -205,7 +203,7 @@ static struct value *ada_search_struct_field (const char *, struct value *, int,\n static int find_struct_field (const char *, struct type *, int,\n \t\t\t      struct type **, int *, int *, int *, int *);\n \n-static int ada_resolve_function (struct block_symbol *, int,\n+static int ada_resolve_function (std::vector<struct block_symbol> &,\n \t\t\t\t struct value **, int, const char *,\n \t\t\t\t struct type *, int);\n \n@@ -3653,15 +3651,9 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n     case OP_VAR_VALUE:\n       if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)\n \t{\n-\t  std::vector<struct block_symbol> candidates;\n-\t  int n_candidates;\n-\n-\t  n_candidates =\n-\t    ada_lookup_symbol_list (exp->elts[pc + 2].symbol->linkage_name (),\n-\t\t\t\t    exp->elts[pc + 1].block, VAR_DOMAIN,\n-\t\t\t\t    &candidates);\n-\t  /* Paranoia.  */\n-\t  candidates.resize (n_candidates);\n+\t  std::vector<struct block_symbol> candidates\n+\t    = ada_lookup_symbol_list (exp->elts[pc + 2].symbol->linkage_name (),\n+\t\t\t\t      exp->elts[pc + 1].block, VAR_DOMAIN);\n \n \t  if (std::any_of (candidates.begin (),\n \t\t\t   candidates.end (),\n@@ -3693,19 +3685,17 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n \t\t    return SYMBOL_CLASS (sym.symbol) == LOC_TYPEDEF;\n \t\t  }),\n \t\t candidates.end ());\n-\t      n_candidates = candidates.size ();\n \t    }\n \n-\t  if (n_candidates == 0)\n+\t  if (candidates.empty ())\n \t    error (_(\"No definition found for %s\"),\n \t\t   exp->elts[pc + 2].symbol->print_name ());\n-\t  else if (n_candidates == 1)\n+\t  else if (candidates.size () == 1)\n \t    i = 0;\n-\t  else if (deprocedure_p\n-\t\t   && !is_nonfunction (candidates.data (), n_candidates))\n+\t  else if (deprocedure_p && !is_nonfunction (candidates))\n \t    {\n \t      i = ada_resolve_function\n-\t\t(candidates.data (), n_candidates, NULL, 0,\n+\t\t(candidates, NULL, 0,\n \t\t exp->elts[pc + 2].symbol->linkage_name (),\n \t\t context_type, parse_completion);\n \t      if (i < 0)\n@@ -3716,7 +3706,7 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n \t    {\n \t      printf_filtered (_(\"Multiple matches for %s\\n\"),\n \t\t\t       exp->elts[pc + 2].symbol->print_name ());\n-\t      user_select_syms (candidates.data (), n_candidates, 1);\n+\t      user_select_syms (candidates.data (), candidates.size (), 1);\n \t      i = 0;\n \t    }\n \n@@ -3741,20 +3731,16 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n \tif (exp->elts[pc + 3].opcode == OP_VAR_VALUE\n \t    && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n \t  {\n-\t    std::vector<struct block_symbol> candidates;\n-\t    int n_candidates;\n+\t    std::vector<struct block_symbol> candidates\n+\t      = ada_lookup_symbol_list (exp->elts[pc + 5].symbol->linkage_name (),\n+\t\t\t\t\texp->elts[pc + 4].block, VAR_DOMAIN);\n \n-\t    n_candidates =\n-\t      ada_lookup_symbol_list (exp->elts[pc + 5].symbol->linkage_name (),\n-\t\t\t\t      exp->elts[pc + 4].block, VAR_DOMAIN,\n-\t\t\t\t      &candidates);\n-\n-\t    if (n_candidates == 1)\n+\t    if (candidates.size () == 1)\n \t      i = 0;\n \t    else\n \t      {\n \t\ti = ada_resolve_function\n-\t\t  (candidates.data (), n_candidates,\n+\t\t  (candidates,\n \t\t   argvec, nargs,\n \t\t   exp->elts[pc + 5].symbol->linkage_name (),\n \t\t   context_type, parse_completion);\n@@ -3792,15 +3778,11 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n     case UNOP_ABS:\n       if (possible_user_operator_p (op, argvec))\n \t{\n-\t  std::vector<struct block_symbol> candidates;\n-\t  int n_candidates;\n-\n-\t  n_candidates =\n-\t    ada_lookup_symbol_list (ada_decoded_op_name (op),\n-\t\t\t\t    NULL, VAR_DOMAIN,\n-\t\t\t\t    &candidates);\n+\t  std::vector<struct block_symbol> candidates\n+\t    = ada_lookup_symbol_list (ada_decoded_op_name (op),\n+\t\t\t\t      NULL, VAR_DOMAIN);\n \n-\t  i = ada_resolve_function (candidates.data (), n_candidates, argvec,\n+\t  i = ada_resolve_function (candidates, argvec,\n \t\t\t\t    nargs, ada_decoded_op_name (op), NULL,\n \t\t\t\t    parse_completion);\n \t  if (i < 0)\n@@ -3966,8 +3948,8 @@ return_match (struct type *func_type, struct type *context_type)\n    the process; the index returned is for the modified vector.  */\n \n static int\n-ada_resolve_function (struct block_symbol syms[],\n-\t\t      int nsyms, struct value **args, int nargs,\n+ada_resolve_function (std::vector<struct block_symbol> &syms,\n+\t\t      struct value **args, int nargs,\n \t\t      const char *name, struct type *context_type,\n \t\t      int parse_completion)\n {\n@@ -3981,7 +3963,7 @@ ada_resolve_function (struct block_symbol syms[],\n      where every function is accepted.  */\n   for (fallback = 0; m == 0 && fallback < 2; fallback++)\n     {\n-      for (k = 0; k < nsyms; k += 1)\n+      for (k = 0; k < syms.size (); k += 1)\n \t{\n \t  struct type *type = ada_check_typedef (SYMBOL_TYPE (syms[k].symbol));\n \n@@ -4003,7 +3985,7 @@ ada_resolve_function (struct block_symbol syms[],\n   else if (m > 1 && !parse_completion)\n     {\n       printf_filtered (_(\"Multiple matches for %s\\n\"), name);\n-      user_select_syms (syms, m, 1);\n+      user_select_syms (syms.data (), m, 1);\n       return 0;\n     }\n   return 0;\n@@ -4737,14 +4719,12 @@ standard_lookup (const char *name, const struct block *block,\n    in the symbol fields of SYMS[0..N-1].  We treat enumerals as functions, \n    since they contend in overloading in the same way.  */\n static int\n-is_nonfunction (struct block_symbol syms[], int n)\n+is_nonfunction (const std::vector<struct block_symbol> &syms)\n {\n-  int i;\n-\n-  for (i = 0; i < n; i += 1)\n-    if (SYMBOL_TYPE (syms[i].symbol)->code () != TYPE_CODE_FUNC\n-\t&& (SYMBOL_TYPE (syms[i].symbol)->code () != TYPE_CODE_ENUM\n-\t    || SYMBOL_CLASS (syms[i].symbol) != LOC_CONST))\n+  for (const block_symbol &sym : syms)\n+    if (SYMBOL_TYPE (sym.symbol)->code () != TYPE_CODE_FUNC\n+\t&& (SYMBOL_TYPE (sym.symbol)->code () != TYPE_CODE_ENUM\n+\t    || SYMBOL_CLASS (sym.symbol) != LOC_CONST))\n       return 1;\n \n   return 0;\n@@ -4817,17 +4797,14 @@ lesseq_defined_than (struct symbol *sym0, struct symbol *sym1)\n     }\n }\n \n-/* Append (SYM,BLOCK,SYMTAB) to the end of the array of struct block_symbol\n-   records in OBSTACKP.  Do nothing if SYM is a duplicate.  */\n+/* Append (SYM,BLOCK) to the end of the array of struct block_symbol\n+   records in RESULT.  Do nothing if SYM is a duplicate.  */\n \n static void\n-add_defn_to_vec (struct obstack *obstackp,\n+add_defn_to_vec (std::vector<struct block_symbol> &result,\n \t\t struct symbol *sym,\n \t\t const struct block *block)\n {\n-  int i;\n-  struct block_symbol *prevDefns = defns_collected (obstackp, 0);\n-\n   /* Do not try to complete stub types, as the debugger is probably\n      already scanning all symbols matching a certain name at the\n      time when this function is called.  Trying to replace the stub\n@@ -4837,46 +4814,22 @@ add_defn_to_vec (struct obstack *obstackp,\n      matches, with at least one of them complete.  It can then filter\n      out the stub ones if needed.  */\n \n-  for (i = num_defns_collected (obstackp) - 1; i >= 0; i -= 1)\n+  for (int i = result.size () - 1; i >= 0; i -= 1)\n     {\n-      if (lesseq_defined_than (sym, prevDefns[i].symbol))\n+      if (lesseq_defined_than (sym, result[i].symbol))\n \treturn;\n-      else if (lesseq_defined_than (prevDefns[i].symbol, sym))\n+      else if (lesseq_defined_than (result[i].symbol, sym))\n \t{\n-\t  prevDefns[i].symbol = sym;\n-\t  prevDefns[i].block = block;\n+\t  result[i].symbol = sym;\n+\t  result[i].block = block;\n \t  return;\n \t}\n     }\n \n-  {\n-    struct block_symbol info;\n-\n-    info.symbol = sym;\n-    info.block = block;\n-    obstack_grow (obstackp, &info, sizeof (struct block_symbol));\n-  }\n-}\n-\n-/* Number of block_symbol structures currently collected in current vector in\n-   OBSTACKP.  */\n-\n-static int\n-num_defns_collected (struct obstack *obstackp)\n-{\n-  return obstack_object_size (obstackp) / sizeof (struct block_symbol);\n-}\n-\n-/* Vector of block_symbol structures currently collected in current vector in\n-   OBSTACKP.  If FINISH, close off the vector and return its final address.  */\n-\n-static struct block_symbol *\n-defns_collected (struct obstack *obstackp, int finish)\n-{\n-  if (finish)\n-    return (struct block_symbol *) obstack_finish (obstackp);\n-  else\n-    return (struct block_symbol *) obstack_base (obstackp);\n+  struct block_symbol info;\n+  info.symbol = sym;\n+  info.block = block;\n+  result.push_back (info);\n }\n \n /* Return a bound minimal symbol matching NAME according to Ada\n@@ -4922,7 +4875,7 @@ ada_lookup_simple_minsym (const char *name)\n    with a wildcard prefix.  */\n \n static void\n-add_symbols_from_enclosing_procs (struct obstack *obstackp,\n+add_symbols_from_enclosing_procs (std::vector<struct block_symbol> &result,\n \t\t\t\t  const lookup_name_info &lookup_name,\n \t\t\t\t  domain_enum domain)\n {\n@@ -5048,7 +5001,7 @@ symbols_are_identical_enums (const std::vector<struct block_symbol> &syms)\n    debugging symbols)).  Modifies SYMS to squeeze out deleted entries.\n    Returns the number of items in the modified list.  */\n \n-static int\n+static void\n remove_extra_symbols (std::vector<struct block_symbol> *syms)\n {\n   int i, j;\n@@ -5057,7 +5010,7 @@ remove_extra_symbols (std::vector<struct block_symbol> *syms)\n      cannot be any extra symbol in that case.  But it's easy to\n      handle, since we have nothing to do in that case.  */\n   if (syms->size () < 2)\n-    return syms->size ();\n+    return;\n \n   i = 0;\n   while (i < syms->size ())\n@@ -5122,8 +5075,6 @@ remove_extra_symbols (std::vector<struct block_symbol> *syms)\n      isn't missing some choices that were identical and yet distinct.  */\n   if (symbols_are_identical_enums (*syms))\n     syms->resize (1);\n-\n-  return syms->size ();\n }\n \n /* Given a type that corresponds to a renaming entity, use the type name\n@@ -5215,8 +5166,8 @@ old_renaming_is_invisible (const struct symbol *sym, const char *function_name)\n    is not visible from the function associated with CURRENT_BLOCK or\n    that is superfluous due to the presence of more specific renaming\n    information.  Places surviving symbols in the initial entries of\n-   SYMS and returns the number of surviving symbols.\n-   \n+   SYMS.\n+\n    Rationale:\n    First, in cases where an object renaming is implemented as a\n    reference variable, GNAT may produce both the actual reference\n@@ -5248,7 +5199,7 @@ old_renaming_is_invisible (const struct symbol *sym, const char *function_name)\n \thas been changed by an \"Export\" pragma.  As a consequence,\n \tthe user will be unable to print such rename entities.  */\n \n-static int\n+static void\n remove_irrelevant_renamings (std::vector<struct block_symbol> *syms,\n \t\t\t     const struct block *current_block)\n {\n@@ -5297,22 +5248,23 @@ remove_irrelevant_renamings (std::vector<struct block_symbol> *syms,\n \t      (*syms)[k] = (*syms)[j];\n \t      k += 1;\n \t    }\n-      return k;\n+      syms->resize (k);\n+      return;\n     }\n \n   /* Extract the function name associated to CURRENT_BLOCK.\n      Abort if unable to do so.  */\n \n   if (current_block == NULL)\n-    return syms->size ();\n+    return;\n \n   current_function = block_linkage_function (current_block);\n   if (current_function == NULL)\n-    return syms->size ();\n+    return;\n \n   current_function_name = current_function->linkage_name ();\n   if (current_function_name == NULL)\n-    return syms->size ();\n+    return;\n \n   /* Check each of the symbols, and remove it from the list if it is\n      a type corresponding to a renaming that is out of the scope of\n@@ -5329,22 +5281,20 @@ remove_irrelevant_renamings (std::vector<struct block_symbol> *syms,\n       else\n \ti += 1;\n     }\n-\n-  return syms->size ();\n }\n \n-/* Add to OBSTACKP all symbols from BLOCK (and its super-blocks)\n+/* Add to RESULT all symbols from BLOCK (and its super-blocks)\n    whose name and domain match NAME and DOMAIN respectively.\n    If no match was found, then extend the search to \"enclosing\"\n    routines (in other words, if we're inside a nested function,\n    search the symbols defined inside the enclosing functions).\n    If WILD_MATCH_P is nonzero, perform the naming matching in\n    \"wild\" mode (see function \"wild_match\" for more info).\n \n-   Note: This function assumes that OBSTACKP has 0 (zero) element in it.  */\n+   Note: This function assumes that RESULT has 0 (zero) element in it.  */\n \n static void\n-ada_add_local_symbols (struct obstack *obstackp,\n+ada_add_local_symbols (std::vector<struct block_symbol> &result,\n \t\t       const lookup_name_info &lookup_name,\n \t\t       const struct block *block, domain_enum domain)\n {\n@@ -5353,20 +5303,19 @@ ada_add_local_symbols (struct obstack *obstackp,\n   while (block != NULL)\n     {\n       block_depth += 1;\n-      ada_add_block_symbols (obstackp, block, lookup_name, domain, NULL);\n+      ada_add_block_symbols (result, block, lookup_name, domain, NULL);\n \n       /* If we found a non-function match, assume that's the one.  */\n-      if (is_nonfunction (defns_collected (obstackp, 0),\n-\t\t\t  num_defns_collected (obstackp)))\n+      if (is_nonfunction (result))\n \treturn;\n \n       block = BLOCK_SUPERBLOCK (block);\n     }\n \n   /* If no luck so far, try to find NAME as a local symbol in some lexically\n      enclosing subprogram.  */\n-  if (num_defns_collected (obstackp) == 0 && block_depth > 2)\n-    add_symbols_from_enclosing_procs (obstackp, lookup_name, domain);\n+  if (result.empty () && block_depth > 2)\n+    add_symbols_from_enclosing_procs (result, lookup_name, domain);\n }\n \n /* An object of this type is used as the user_data argument when\n@@ -5375,7 +5324,7 @@ ada_add_local_symbols (struct obstack *obstackp,\n struct match_data\n {\n   struct objfile *objfile;\n-  struct obstack *obstackp;\n+  std::vector<struct block_symbol> *resultp;\n   struct symbol *arg_sym;\n   int found_sym;\n };\n@@ -5399,7 +5348,7 @@ aux_add_nonlocal_symbols (struct block_symbol *bsym,\n   if (sym == NULL)\n     {\n       if (!data->found_sym && data->arg_sym != NULL) \n-\tadd_defn_to_vec (data->obstackp,\n+\tadd_defn_to_vec (*data->resultp,\n \t\t\t fixup_symbol_section (data->arg_sym, data->objfile),\n \t\t\t block);\n       data->found_sym = 0;\n@@ -5414,7 +5363,7 @@ aux_add_nonlocal_symbols (struct block_symbol *bsym,\n       else\n \t{\n \t  data->found_sym = 1;\n-\t  add_defn_to_vec (data->obstackp,\n+\t  add_defn_to_vec (*data->resultp,\n \t\t\t   fixup_symbol_section (sym, data->objfile),\n \t\t\t   block);\n \t}\n@@ -5427,13 +5376,13 @@ aux_add_nonlocal_symbols (struct block_symbol *bsym,\n    symbols to OBSTACKP.  Return whether we found such symbols.  */\n \n static int\n-ada_add_block_renamings (struct obstack *obstackp,\n+ada_add_block_renamings (std::vector<struct block_symbol> &result,\n \t\t\t const struct block *block,\n \t\t\t const lookup_name_info &lookup_name,\n \t\t\t domain_enum domain)\n {\n   struct using_direct *renaming;\n-  int defns_mark = num_defns_collected (obstackp);\n+  int defns_mark = result.size ();\n \n   symbol_name_matcher_ftype *name_match\n     = ada_get_symbol_name_matcher (lookup_name);\n@@ -5471,12 +5420,12 @@ ada_add_block_renamings (struct obstack *obstackp,\n \t{\n \t  lookup_name_info decl_lookup_name (renaming->declaration,\n \t\t\t\t\t     lookup_name.match_type ());\n-\t  ada_add_all_symbols (obstackp, block, decl_lookup_name, domain,\n+\t  ada_add_all_symbols (result, block, decl_lookup_name, domain,\n \t\t\t       1, NULL);\n \t}\n       renaming->searched = 0;\n     }\n-  return num_defns_collected (obstackp) != defns_mark;\n+  return result.size () != defns_mark;\n }\n \n /* Implements compare_names, but only applying the comparision using\n@@ -5579,14 +5528,14 @@ ada_lookup_name (const lookup_name_info &lookup_name)\n    symbols otherwise.  */\n \n static void\n-add_nonlocal_symbols (struct obstack *obstackp,\n+add_nonlocal_symbols (std::vector<struct block_symbol> &result,\n \t\t      const lookup_name_info &lookup_name,\n \t\t      domain_enum domain, int global)\n {\n   struct match_data data;\n \n   memset (&data, 0, sizeof data);\n-  data.obstackp = obstackp;\n+  data.resultp = &result;\n \n   bool is_wild_match = lookup_name.ada ().wild_match_p ();\n \n@@ -5610,13 +5559,13 @@ add_nonlocal_symbols (struct obstack *obstackp,\n \t  const struct block *global_block\n \t    = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cu), GLOBAL_BLOCK);\n \n-\t  if (ada_add_block_renamings (obstackp, global_block, lookup_name,\n+\t  if (ada_add_block_renamings (result, global_block, lookup_name,\n \t\t\t\t       domain))\n \t    data.found_sym = 1;\n \t}\n     }\n \n-  if (num_defns_collected (obstackp) == 0 && global && !is_wild_match)\n+  if (result.empty () && global && !is_wild_match)\n     {\n       const char *name = ada_lookup_name (lookup_name);\n       std::string bracket_name = std::string (\"<_ada_\") + name + '>';\n@@ -5651,7 +5600,7 @@ add_nonlocal_symbols (struct obstack *obstackp,\n    to lookup global symbols.  */\n \n static void\n-ada_add_all_symbols (struct obstack *obstackp,\n+ada_add_all_symbols (std::vector<struct block_symbol> &result,\n \t\t     const struct block *block,\n \t\t     const lookup_name_info &lookup_name,\n \t\t     domain_enum domain,\n@@ -5678,15 +5627,15 @@ ada_add_all_symbols (struct obstack *obstackp,\n   if (block != NULL)\n     {\n       if (full_search)\n-\tada_add_local_symbols (obstackp, lookup_name, block, domain);\n+\tada_add_local_symbols (result, lookup_name, block, domain);\n       else\n \t{\n \t  /* In the !full_search case we're are being called by\n \t     iterate_over_symbols, and we don't want to search\n \t     superblocks.  */\n-\t  ada_add_block_symbols (obstackp, block, lookup_name, domain, NULL);\n+\t  ada_add_block_symbols (result, block, lookup_name, domain, NULL);\n \t}\n-      if (num_defns_collected (obstackp) > 0 || !full_search)\n+      if (!result.empty () || !full_search)\n \treturn;\n     }\n \n@@ -5698,7 +5647,7 @@ ada_add_all_symbols (struct obstack *obstackp,\n \t\t\t    domain, &sym, &block))\n     {\n       if (sym != NULL)\n-\tadd_defn_to_vec (obstackp, sym, block);\n+\tadd_defn_to_vec (result, sym, block);\n       return;\n     }\n \n@@ -5707,21 +5656,20 @@ ada_add_all_symbols (struct obstack *obstackp,\n \n   /* Search symbols from all global blocks.  */\n  \n-  add_nonlocal_symbols (obstackp, lookup_name, domain, 1);\n+  add_nonlocal_symbols (result, lookup_name, domain, 1);\n \n   /* Now add symbols from all per-file blocks if we've gotten no hits\n      (not strictly correct, but perhaps better than an error).  */\n \n-  if (num_defns_collected (obstackp) == 0)\n-    add_nonlocal_symbols (obstackp, lookup_name, domain, 0);\n+  if (result.empty ())\n+    add_nonlocal_symbols (result, lookup_name, domain, 0);\n }\n \n /* Find symbols in DOMAIN matching LOOKUP_NAME, in BLOCK and, if FULL_SEARCH\n-   is non-zero, enclosing scope and in global scopes, returning the number of\n-   matches.\n-   Fills *RESULTS with (SYM,BLOCK) tuples, indicating the symbols\n-   found and the blocks and symbol tables (if any) in which they were\n-   found.\n+   is non-zero, enclosing scope and in global scopes.\n+\n+   Returns (SYM,BLOCK) tuples, indicating the symbols found and the\n+   blocks and symbol tables (if any) in which they were found.\n \n    When full_search is non-zero, any non-function/non-enumeral\n    symbol match within the nest of blocks whose innermost member is BLOCK,\n@@ -5732,55 +5680,44 @@ ada_add_all_symbols (struct obstack *obstackp,\n    Names prefixed with \"standard__\" are handled specially: \"standard__\"\n    is first stripped off, and only static and global symbols are searched.  */\n \n-static int\n+static std::vector<struct block_symbol>\n ada_lookup_symbol_list_worker (const lookup_name_info &lookup_name,\n \t\t\t       const struct block *block,\n \t\t\t       domain_enum domain,\n-\t\t\t       std::vector<struct block_symbol> *results,\n \t\t\t       int full_search)\n {\n   int syms_from_global_search;\n-  int ndefns;\n-  auto_obstack obstack;\n+  std::vector<struct block_symbol> results;\n \n-  ada_add_all_symbols (&obstack, block, lookup_name,\n+  ada_add_all_symbols (results, block, lookup_name,\n \t\t       domain, full_search, &syms_from_global_search);\n \n-  ndefns = num_defns_collected (&obstack);\n-\n-  struct block_symbol *base = defns_collected (&obstack, 1);\n-  for (int i = 0; i < ndefns; ++i)\n-    results->push_back (base[i]);\n+  remove_extra_symbols (&results);\n \n-  ndefns = remove_extra_symbols (results);\n-\n-  if (ndefns == 0 && full_search && syms_from_global_search)\n+  if (results.empty () && full_search && syms_from_global_search)\n     cache_symbol (ada_lookup_name (lookup_name), domain, NULL, NULL);\n \n-  if (ndefns == 1 && full_search && syms_from_global_search)\n+  if (results.size () == 1 && full_search && syms_from_global_search)\n     cache_symbol (ada_lookup_name (lookup_name), domain,\n-\t\t  (*results)[0].symbol, (*results)[0].block);\n-\n-  ndefns = remove_irrelevant_renamings (results, block);\n+\t\t  results[0].symbol, results[0].block);\n \n-  return ndefns;\n+  remove_irrelevant_renamings (&results, block);\n+  return results;\n }\n \n /* Find symbols in DOMAIN matching NAME, in BLOCK and enclosing scope and\n-   in global scopes, returning the number of matches, and filling *RESULTS\n-   with (SYM,BLOCK) tuples.\n+   in global scopes, returning (SYM,BLOCK) tuples.\n \n    See ada_lookup_symbol_list_worker for further details.  */\n \n-int\n+std::vector<struct block_symbol>\n ada_lookup_symbol_list (const char *name, const struct block *block,\n-\t\t\tdomain_enum domain,\n-\t\t\tstd::vector<struct block_symbol> *results)\n+\t\t\tdomain_enum domain)\n {\n   symbol_name_match_type name_match_type = name_match_type_from_name (name);\n   lookup_name_info lookup_name (name, name_match_type);\n \n-  return ada_lookup_symbol_list_worker (lookup_name, block, domain, results, 1);\n+  return ada_lookup_symbol_list_worker (lookup_name, block, domain, 1);\n }\n \n /* The result is as for ada_lookup_symbol_list with FULL_SEARCH set\n@@ -5816,12 +5753,10 @@ struct block_symbol\n ada_lookup_symbol (const char *name, const struct block *block0,\n \t\t   domain_enum domain)\n {\n-  std::vector<struct block_symbol> candidates;\n-  int n_candidates;\n+  std::vector<struct block_symbol> candidates\n+    = ada_lookup_symbol_list (name, block0, domain);\n \n-  n_candidates = ada_lookup_symbol_list (name, block0, domain, &candidates);\n-\n-  if (n_candidates == 0)\n+  if (candidates.empty ())\n     return {};\n \n   block_symbol info = candidates[0];\n@@ -6080,12 +6015,11 @@ wild_match (const char *name, const char *patn)\n     }\n }\n \n-/* Add symbols from BLOCK matching LOOKUP_NAME in DOMAIN to vector\n-   *defn_symbols, updating the list of symbols in OBSTACKP (if\n+/* Add symbols from BLOCK matching LOOKUP_NAME in DOMAIN to RESULT (if\n    necessary).  OBJFILE is the section containing BLOCK.  */\n \n static void\n-ada_add_block_symbols (struct obstack *obstackp,\n+ada_add_block_symbols (std::vector<struct block_symbol> &result,\n \t\t       const struct block *block,\n \t\t       const lookup_name_info &lookup_name,\n \t\t       domain_enum domain, struct objfile *objfile)\n@@ -6112,7 +6046,7 @@ ada_add_block_symbols (struct obstack *obstackp,\n \t      else\n \t\t{\n \t\t  found_sym = 1;\n-\t\t  add_defn_to_vec (obstackp,\n+\t\t  add_defn_to_vec (result,\n \t\t\t\t   fixup_symbol_section (sym, objfile),\n \t\t\t\t   block);\n \t\t}\n@@ -6122,12 +6056,12 @@ ada_add_block_symbols (struct obstack *obstackp,\n \n   /* Handle renamings.  */\n \n-  if (ada_add_block_renamings (obstackp, block, lookup_name, domain))\n+  if (ada_add_block_renamings (result, block, lookup_name, domain))\n     found_sym = 1;\n \n   if (!found_sym && arg_sym != NULL)\n     {\n-      add_defn_to_vec (obstackp,\n+      add_defn_to_vec (result,\n \t\t       fixup_symbol_section (arg_sym, objfile),\n \t\t       block);\n     }\n@@ -6166,7 +6100,7 @@ ada_add_block_symbols (struct obstack *obstackp,\n \t\t    else\n \t\t      {\n \t\t\tfound_sym = 1;\n-\t\t\tadd_defn_to_vec (obstackp,\n+\t\t\tadd_defn_to_vec (result,\n \t\t\t\t\t fixup_symbol_section (sym, objfile),\n \t\t\t\t\t block);\n \t\t      }\n@@ -6179,7 +6113,7 @@ ada_add_block_symbols (struct obstack *obstackp,\n \t They aren't parameters, right?  */\n       if (!found_sym && arg_sym != NULL)\n \t{\n-\t  add_defn_to_vec (obstackp,\n+\t  add_defn_to_vec (result,\n \t\t\t   fixup_symbol_section (arg_sym, objfile),\n \t\t\t   block);\n \t}\n@@ -11319,12 +11253,12 @@ get_var_value (const char *name, const char *err_msg)\n \n   lookup_name_info lookup_name (quoted_name, symbol_name_match_type::FULL);\n \n-  std::vector<struct block_symbol> syms;\n-  int nsyms = ada_lookup_symbol_list_worker (lookup_name,\n-\t\t\t\t\t     get_selected_block (0),\n-\t\t\t\t\t     VAR_DOMAIN, &syms, 1);\n+  std::vector<struct block_symbol> syms\n+    = ada_lookup_symbol_list_worker (lookup_name,\n+\t\t\t\t     get_selected_block (0),\n+\t\t\t\t     VAR_DOMAIN, 1);\n \n-  if (nsyms != 1)\n+  if (syms.size () != 1)\n     {\n       if (err_msg == NULL)\n \treturn 0;\n@@ -13854,9 +13788,8 @@ class ada_language : public language_defn\n \t domain_enum domain,\n \t gdb::function_view<symbol_found_callback_ftype> callback) const override\n   {\n-    std::vector<struct block_symbol> results;\n-\n-    ada_lookup_symbol_list_worker (name, block, domain, &results, 0);\n+    std::vector<struct block_symbol> results\n+      = ada_lookup_symbol_list_worker (name, block, domain, 0);\n     for (block_symbol &sym : results)\n       {\n \tif (!callback (&sym))"
    },
    {
      "sha": "8be4bf4ba6991b09f488525539cb39c5e4b23514",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1183b064cae59353c3a80d27dc250ca440cb879/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1183b064cae59353c3a80d27dc250ca440cb879/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=d1183b064cae59353c3a80d27dc250ca440cb879",
      "patch": "@@ -218,9 +218,8 @@ extern const char *ada_decode_symbol (const struct general_symbol_info *);\n \n extern std::string ada_decode (const char*);\n \n-extern int ada_lookup_symbol_list (const char *, const struct block *,\n-\t\t\t\t   domain_enum,\n-\t\t\t\t   std::vector<struct block_symbol> *);\n+extern std::vector<struct block_symbol> ada_lookup_symbol_list\n+     (const char *, const struct block *, domain_enum);\n \n extern struct block_symbol ada_lookup_symbol (const char *,\n \t\t\t\t\t      const struct block *,"
    }
  ]
}