{
  "sha": "688d28f62146bf07b2ce1efd5380768d5ead418d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Njg4ZDI4ZjYyMTQ2YmYwN2IyY2UxZWZkNTM4MDc2OGQ1ZWFkNDE4ZA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-06-03T14:13:24Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-07-22T16:57:50Z"
    },
    "message": "libctf, next: introduce new class of easier-to-use iterators\n\nThe libctf machinery currently only provides one way to iterate over its\ndata structures: ctf_*_iter functions that take a callback and an arg\nand repeatedly call it.\n\nThis *works*, but if you are doing a lot of iteration it is really quite\ninconvenient: you have to package up your local variables into\nstructures over and over again and spawn lots of little functions even\nif it would be clearer in a single run of code.  Look at ctf-string.c\nfor an extreme example of how unreadable this can get, with\nthree-line-long functions proliferating wildly.\n\nThe deduplicator takes this to the Nth level. It iterates over a whole\nbunch of things: if we'd had to use _iter-class iterators for all of\nthem there would be twenty additional functions in the deduplicator\nalone, for no other reason than that the iterator API requires it.\n\nLet's do something better. strtok_r gives us half the design: generators\nin a number of other languages give us the other half.\n\nThe *_next API allows you to iterate over CTF-like entities in a single\nfunction using a normal while loop. e.g. here we are iterating over all\nthe types in a dict:\n\nctf_next_t *i = NULL;\nint *hidden;\nctf_id_t id;\n\nwhile ((id = ctf_type_next (fp, &i, &hidden, 1)) != CTF_ERR)\n  {\n    /* do something with 'hidden' and 'id' */\n  }\nif (ctf_errno (fp) != ECTF_NEXT_END)\n    /* iteration error */\n\nHere we are walking through the members of a struct with CTF ID\n'struct_type':\n\nctf_next_t *i = NULL;\nssize_t offset;\nconst char *name;\nctf_id_t membtype;\n\nwhile ((offset = ctf_member_next (fp, struct_type, &i, &name,\n                                  &membtype)) >= 0\n  {\n    /* do something with offset, name, and membtype */\n  }\nif (ctf_errno (fp) != ECTF_NEXT_END)\n    /* iteration error */\n\nLike every other while loop, this means you have access to all the local\nvariables outside the loop while inside it, with no need to tiresomely\npackage things up in structures, move the body of the loop into a\nseparate function, etc, as you would with an iterator taking a callback.\n\nctf_*_next allocates 'i' for you on first entry (when it must be NULL),\nand frees and NULLs it and returns a _next-dependent flag value when the\niteration is over: the fp errno is set to ECTF_NEXT_END when the\niteartion ends normally.  If you want to exit early, call\nctf_next_destroy on the iterator.  You can copy iterators using\nctf_next_copy, which copies their current iteration position so you can\nremember loop positions and go back to them later (or ctf_next_destroy\nthem if you don't need them after all).\n\nEach _next function returns an always-likely-to-be-useful property of\nthe thing being iterated over, and takes pointers to parameters for the\nothers: with very few exceptions all those parameters can be NULLs if\nyou're not interested in them, so e.g. you can iterate over only the\noffsets of members of a structure this way:\n\nwhile ((offset = ctf_member_next (fp, struct_id, &i, NULL, NULL)) >= 0)\n\nIf you pass an iterator in use by one iteration function to another one,\nyou get the new error ECTF_NEXT_WRONGFUN back; if you try to change\nctf_file_t in mid-iteration, you get ECTF_NEXT_WRONGFP back.\n\nInternally the ctf_next_t remembers the iteration function in use,\nvarious sizes and increments useful for almost all iterations, then\nuses unions to overlap the actual entities being iterated over to keep\nctf_next_t size down.\n\nIterators available in the public API so far (all tested in actual use\nin the deduplicator):\n\n/* Iterate over the members of a STRUCT or UNION, returning each member's\n   offset and optionally name and member type in turn.  On end-of-iteration,\n   returns -1.  */\nssize_t\nctf_member_next (ctf_file_t *fp, ctf_id_t type, ctf_next_t **it,\n                 const char **name, ctf_id_t *membtype);\n\n/* Iterate over the members of an enum TYPE, returning each enumerand's\n   NAME or NULL at end of iteration or error, and optionally passing\n   back the enumerand's integer VALue.  */\nconst char *\nctf_enum_next (ctf_file_t *fp, ctf_id_t type, ctf_next_t **it,\n              int *val);\n\n/* Iterate over every type in the given CTF container (not including\n   parents), optionally including non-user-visible types, returning\n   each type ID and optionally the hidden flag in turn. Returns CTF_ERR\n   on end of iteration or error.  */\nctf_id_t\nctf_type_next (ctf_file_t *fp, ctf_next_t **it, int *flag,\n               int want_hidden);\n\n/* Iterate over every variable in the given CTF container, in arbitrary\n   order, returning the name and type of each variable in turn.  The\n   NAME argument is not optional.  Returns CTF_ERR on end of iteration\n   or error.  */\nctf_id_t\nctf_variable_next (ctf_file_t *fp, ctf_next_t **it, const char **name);\n\n/* Iterate over all CTF files in an archive, returning each dict in turn as a\n   ctf_file_t, and NULL on error or end of iteration.  It is the caller's\n   responsibility to close it.  Parent dicts may be skipped.  Regardless of\n   whether they are skipped or not, the caller must ctf_import the parent if\n   need be.  */\nctf_file_t *\nctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it,\n                  const char **name, int skip_parent, int *errp);\n\nctf_label_next is prototyped but not implemented yet.\n\ninclude/\n\t* ctf-api.h (ECTF_NEXT_END): New error.\n\t(ECTF_NEXT_WRONGFUN): Likewise.\n\t(ECTF_NEXT_WRONGFP): Likewise.\n\t(ECTF_NERR): Adjust.\n\t(ctf_next_t): New.\n\t(ctf_next_create): New prototype.\n\t(ctf_next_destroy): Likewise.\n\t(ctf_next_copy): Likewise.\n\t(ctf_member_next): Likewise.\n\t(ctf_enum_next): Likewise.\n\t(ctf_type_next): Likewise.\n\t(ctf_label_next): Likewise.\n\t(ctf_variable_next): Likewise.\n\nlibctf/\n\t* ctf-impl.h (ctf_next): New.\n\t(ctf_get_dict): New prototype.\n\t* ctf-lookup.c (ctf_get_dict): New, split out of...\n\t(ctf_lookup_by_id): ... here.\n\t* ctf-util.c (ctf_next_create): New.\n\t(ctf_next_destroy): New.\n\t(ctf_next_copy): New.\n\t* ctf-types.c (includes): Add <assert.h>.\n\t(ctf_member_next): New.\n\t(ctf_enum_next): New.\n\t(ctf_type_iter): Document the lack of iteration over parent\n\ttypes.\n\t(ctf_type_next): New.\n\t(ctf_variable_next): New.\n\t* ctf-archive.c (ctf_archive_next): New.\n\t* libctf.ver: Add new public functions.",
    "tree": {
      "sha": "012be4c1a996e44a8b04616c24d2ee29360efd09",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/012be4c1a996e44a8b04616c24d2ee29360efd09"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/688d28f62146bf07b2ce1efd5380768d5ead418d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/688d28f62146bf07b2ce1efd5380768d5ead418d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/688d28f62146bf07b2ce1efd5380768d5ead418d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/688d28f62146bf07b2ce1efd5380768d5ead418d/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2399827bfa1062c7f782499e6dcd9f988318d422",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2399827bfa1062c7f782499e6dcd9f988318d422",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2399827bfa1062c7f782499e6dcd9f988318d422"
    }
  ],
  "stats": {
    "total": 616,
    "additions": 606,
    "deletions": 10
  },
  "files": [
    {
      "sha": "9f47c8bff7741c61c7d8d4c707a29a14e31358df",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -1,3 +1,19 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ECTF_NEXT_END): New error.\n+\t(ECTF_NEXT_WRONGFUN): Likewise.\n+\t(ECTF_NEXT_WRONGFP): Likewise.\n+\t(ECTF_NERR): Adjust.\n+\t(ctf_next_t): New.\n+\t(ctf_next_create): New prototype.\n+\t(ctf_next_destroy): Likewise.\n+\t(ctf_next_copy): Likewise.\n+\t(ctf_member_next): Likewise.\n+\t(ctf_enum_next): Likewise.\n+\t(ctf_type_next): Likewise.\n+\t(ctf_label_next): Likewise.\n+\t(ctf_variable_next): Likewise.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_ref): New."
    },
    {
      "sha": "47a1f732f0ebd54f9c00387d461aed68c5b17c18",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 29,
      "deletions": 4,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -204,10 +204,13 @@ enum\n    ECTF_DUMPSECTCHANGED, /* Section changed in middle of dump.  */\n    ECTF_NOTYET,\t\t/* Feature not yet implemented.  */\n    ECTF_INTERNAL,\t/* Internal error in link.  */\n-   ECTF_NONREPRESENTABLE /* Type not representable in CTF.  */\n+   ECTF_NONREPRESENTABLE, /* Type not representable in CTF.  */\n+   ECTF_NEXT_END,\t/* End of iteration.  */\n+   ECTF_NEXT_WRONGFUN,\t/* Wrong iteration function called.  */\n+   ECTF_NEXT_WRONGFP\t/* Iteration entity changed in mid-iterate.  */\n   };\n \n-#define ECTF_NERR (ECTF_NONREPRESENTABLE - ECTF_BASE + 1)\t/* Count of CTF errors.  */\n+#define ECTF_NERR (ECTF_NEXT_WRONGFP - ECTF_BASE + 1)\t/* Count of CTF errors.  */\n \n /* The CTF data model is inferred to be the caller's data model or the data\n    model of the given object, unless ctf_setmodel() is explicitly called.  */\n@@ -227,8 +230,9 @@ enum\n #define\tCTF_ADD_NONROOT\t0\t/* Type only visible in nested scope.  */\n #define\tCTF_ADD_ROOT\t1\t/* Type visible at top-level scope.  */\n \n-/* These typedefs are used to define the signature for callback functions\n-   that can be used with the iteration and visit functions below.  */\n+/* These typedefs are used to define the signature for callback functions that\n+   can be used with the iteration and visit functions below.  There is also a\n+   family of iteration functions that do not require callbacks.  */\n \n typedef int ctf_visit_f (const char *name, ctf_id_t type, unsigned long offset,\n \t\t\t int depth, void *arg);\n@@ -248,6 +252,15 @@ typedef char *ctf_dump_decorate_f (ctf_sect_names_t sect,\n \n typedef struct ctf_dump_state ctf_dump_state_t;\n \n+/* Iteration state for the _next() functions, and allocators/copiers/freers for\n+   it.  (None of these are needed for the simple case of iterating to the end:\n+   the _next() function allocate and free the iterators for you.)  */\n+\n+typedef struct ctf_next ctf_next_t;\n+extern ctf_next_t *ctf_next_create (void);\n+extern void ctf_next_destroy (ctf_next_t *);\n+extern ctf_next_t *ctf_next_copy (ctf_next_t *);\n+\n /* Opening.  These mostly return an abstraction over both CTF files and CTF\n    archives: so they can be used to open both.  CTF files will appear to be an\n    archive with one member named '.ctf'.  The low-level functions\n@@ -353,13 +366,25 @@ extern int ctf_label_info (ctf_file_t *, const char *, ctf_lblinfo_t *);\n \n extern int ctf_member_count (ctf_file_t *, ctf_id_t);\n extern int ctf_member_iter (ctf_file_t *, ctf_id_t, ctf_member_f *, void *);\n+extern ssize_t ctf_member_next (ctf_file_t *, ctf_id_t, ctf_next_t **,\n+\t\t\t\tconst char **name, ctf_id_t *membtype);\n extern int ctf_enum_iter (ctf_file_t *, ctf_id_t, ctf_enum_f *, void *);\n+extern const char *ctf_enum_next (ctf_file_t *, ctf_id_t, ctf_next_t **,\n+\t\t\t\t  int *);\n extern int ctf_type_iter (ctf_file_t *, ctf_type_f *, void *);\n extern int ctf_type_iter_all (ctf_file_t *, ctf_type_all_f *, void *);\n+extern ctf_id_t ctf_type_next (ctf_file_t *, ctf_next_t **,\n+\t\t\t       int *flag, int want_hidden);\n extern int ctf_label_iter (ctf_file_t *, ctf_label_f *, void *);\n+extern int ctf_label_next (ctf_file_t *, ctf_next_t **, const char **); /* TBD */\n extern int ctf_variable_iter (ctf_file_t *, ctf_variable_f *, void *);\n+extern ctf_id_t ctf_variable_next (ctf_file_t *, ctf_next_t **,\n+\t\t\t\t   const char **);\n extern int ctf_archive_iter (const ctf_archive_t *, ctf_archive_member_f *,\n \t\t\t     void *);\n+extern ctf_file_t *ctf_archive_next (const ctf_archive_t *, ctf_next_t **,\n+\t\t\t\t     const char **, int skip_parent, int *errp);\n+\n /* This function alone does not currently operate on CTF files masquerading\n    as archives, and returns -EINVAL: the raw data is no longer available.  It is\n    expected to be used only by archiving tools, in any case, which have no need"
    },
    {
      "sha": "3009f4ed9e7687e0708c2833b8fae9703683b588",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -1,3 +1,22 @@\n+2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_next): New.\n+\t(ctf_get_dict): New prototype.\n+\t* ctf-lookup.c (ctf_get_dict): New, split out of...\n+\t(ctf_lookup_by_id): ... here.\n+\t* ctf-util.c (ctf_next_create): New.\n+\t(ctf_next_destroy): New.\n+\t(ctf_next_copy): New.\n+\t* ctf-types.c (includes): Add <assert.h>.\n+\t(ctf_member_next): New.\n+\t(ctf_enum_next): New.\n+\t(ctf_type_iter): Document the lack of iteration over parent\n+\ttypes.\n+\t(ctf_type_next): New.\n+\t(ctf_variable_next): New.\n+\t* ctf-archive.c (ctf_archive_next): New.\n+\t* libctf.ver: Add new public functions.\n+\n 2020-07-22  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* libctf.ver (ctf_ref): New."
    },
    {
      "sha": "54d3d0a48f8f2b6db2da64b9e7b61091e9bc0bb8",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 107,
      "deletions": 0,
      "changes": 107,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -732,6 +732,113 @@ ctf_archive_iter (const ctf_archive_t *arc, ctf_archive_member_f *func,\n   return func (arc->ctfi_file, _CTF_SECTION, data);\n }\n \n+/* Iterate over all CTF files in an archive, returning each dict in turn as a\n+   ctf_file_t, and NULL on error or end of iteration.  It is the caller's\n+   responsibility to close it.  Parent dicts may be skipped.  Regardless of\n+   whether they are skipped or not, the caller must ctf_import the parent if\n+   need be.\n+\n+   We identify parents by name rather than by flag value: for now, with the\n+   linker only emitting parents named _CTF_SECTION, this works well enough.  */\n+\n+ctf_file_t *\n+ctf_archive_next (const ctf_archive_t *wrapper, ctf_next_t **it, const char **name,\n+\t\t  int skip_parent, int *errp)\n+{\n+  ctf_file_t *f;\n+  ctf_next_t *i = *it;\n+  struct ctf_archive *arc;\n+  struct ctf_archive_modent *modent;\n+  const char *nametbl;\n+  const char *name_;\n+\n+  if (!i)\n+    {\n+      if ((i = ctf_next_create()) == NULL)\n+\t{\n+\t  if (errp)\n+\t    *errp = ENOMEM;\n+\t  return NULL;\n+\t}\n+      i->cu.ctn_arc = wrapper;\n+      i->ctn_iter_fun = (void (*) (void)) ctf_archive_next;\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_archive_next != i->ctn_iter_fun)\n+    {\n+      if (errp)\n+\t*errp = ECTF_NEXT_WRONGFUN;\n+      return NULL;\n+    }\n+\n+  if (wrapper != i->cu.ctn_arc)\n+    {\n+      if (errp)\n+\t*errp = ECTF_NEXT_WRONGFP;\n+      return NULL;\n+    }\n+\n+  /* Iteration is made a bit more complex by the need to handle ctf_file_t's\n+     transparently wrapped in a single-member archive.  These are parents: if\n+     skip_parent is on, they are skipped and the iterator terminates\n+     immediately.  */\n+\n+  if (!wrapper->ctfi_is_archive && i->ctn_n == 0)\n+    {\n+      i->ctn_n++;\n+      if (!skip_parent)\n+\t{\n+\t  wrapper->ctfi_file->ctf_refcnt++;\n+\t  return wrapper->ctfi_file;\n+\t}\n+    }\n+\n+  arc = wrapper->ctfi_archive;\n+\n+  /* The loop keeps going when skip_parent is on as long as the member we find\n+     is the parent (i.e. at most two iterations, but possibly an early return if\n+     *all* we have is a parent).  */\n+\n+  const ctf_sect_t *symsect;\n+  const ctf_sect_t *strsect;\n+\n+  do\n+    {\n+      if ((!wrapper->ctfi_is_archive) || (i->ctn_n >= le64toh (arc->ctfa_nfiles)))\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  *it = NULL;\n+\t  if (errp)\n+\t    *errp = ECTF_NEXT_END;\n+\t  return NULL;\n+\t}\n+\n+      symsect = &wrapper->ctfi_symsect;\n+      strsect = &wrapper->ctfi_strsect;\n+\n+      if (symsect->cts_name == NULL)\n+\tsymsect = NULL;\n+      if (strsect->cts_name == NULL)\n+\tstrsect = NULL;\n+\n+      modent = (ctf_archive_modent_t *) ((char *) arc\n+\t\t\t\t\t + sizeof (struct ctf_archive));\n+      nametbl = (((const char *) arc) + le64toh (arc->ctfa_names));\n+\n+      name_ = &nametbl[le64toh (modent[i->ctn_n].name_offset)];\n+      i->ctn_n++;\n+    } while (skip_parent && strcmp (name_, _CTF_SECTION) == 0);\n+\n+  if (name)\n+    *name = name_;\n+\n+  f = ctf_arc_open_by_name_internal (arc, symsect, strsect,\n+\t\t\t\t     name_, errp);\n+  f->ctf_archive = (ctf_archive_t *) wrapper;\n+  return f;\n+}\n+\n #ifdef HAVE_MMAP\n /* Map the header in.  Only used on new, empty files.  */\n static void *arc_mmap_header (int fd, size_t headersz)"
    },
    {
      "sha": "b18ba9465244e4aa83a2a12d2fc9e4b4d77550a2",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -326,6 +326,36 @@ struct ctf_archive_internal\n   void (*ctfi_bfd_close) (struct ctf_archive_internal *);\n };\n \n+/* Iterator state for the *_next() functions.  */\n+\n+struct ctf_next\n+{\n+  void (*ctn_iter_fun) (void);\n+  ctf_id_t ctn_type;\n+  ssize_t ctn_size;\n+  ssize_t ctn_increment;\n+  uint32_t ctn_n;\n+  /* We can save space on this side of things by noting that a container is\n+     either dynamic or not, as a whole, and a given iterator can only iterate\n+     over one kind of thing at once: so we can overlap the DTD and non-DTD\n+     members, and the structure, variable and enum members, etc.  */\n+  union\n+  {\n+    const ctf_member_t *ctn_mp;\n+    const ctf_lmember_t *ctn_lmp;\n+    const ctf_dmdef_t *ctn_dmd;\n+    const ctf_enum_t *ctn_en;\n+    const ctf_dvdef_t *ctn_dvd;\n+  } u;\n+  /* This union is of various sorts of container we can iterate over:\n+     currently dictionaries and archives.  */\n+  union\n+  {\n+    const ctf_file_t *ctn_fp;\n+    const ctf_archive_t *ctn_arc;\n+  } cu;\n+};\n+\n /* Return x rounded up to an alignment boundary.\n    eg, P2ROUNDUP(0x1234, 0x100) == 0x1300 (0x13*align)\n    eg, P2ROUNDUP(0x5600, 0x100) == 0x5600 (0x56*align)  */\n@@ -362,6 +392,8 @@ extern ctf_id_t ctf_lookup_by_rawname (ctf_file_t *, int, const char *);\n extern ctf_id_t ctf_lookup_by_rawhash (ctf_file_t *, ctf_names_t *, const char *);\n extern void ctf_set_ctl_hashes (ctf_file_t *);\n \n+extern ctf_file_t *ctf_get_dict (ctf_file_t *fp, ctf_id_t type);\n+\n typedef unsigned int (*ctf_hash_fun) (const void *ptr);\n extern unsigned int ctf_hash_integer (const void *ptr);\n extern unsigned int ctf_hash_string (const void *ptr);"
    },
    {
      "sha": "8daab632dca3ae64f6c754e8455925be2fe3f0b4",
      "filename": "libctf/ctf-lookup.c",
      "status": "modified",
      "additions": 15,
      "deletions": 4,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -305,24 +305,35 @@ ctf_lookup_by_symbol (ctf_file_t *fp, unsigned long symidx)\n   return type;\n }\n \n+/* Return the native dict of a given type: if called on a child and the\n+   type is in the parent, return the parent.  Needed if you plan to access\n+   the type directly, without using the API.  */\n+ctf_file_t *\n+ctf_get_dict (ctf_file_t *fp, ctf_id_t type)\n+{\n+    if ((fp->ctf_flags & LCTF_CHILD) && LCTF_TYPE_ISPARENT (fp, type))\n+      return fp->ctf_parent;\n+\n+    return fp;\n+}\n+\n /* Return the pointer to the internal CTF type data corresponding to the\n    given type ID.  If the ID is invalid, the function returns NULL.\n    This function is not exported outside of the library.  */\n \n const ctf_type_t *\n ctf_lookup_by_id (ctf_file_t **fpp, ctf_id_t type)\n {\n-  ctf_file_t *fp = *fpp;\t/* Caller passes in starting CTF container.  */\n+  ctf_file_t *fp = *fpp;\t/* Caller passes in starting CTF dict.  */\n   ctf_id_t idx;\n \n-  if ((fp->ctf_flags & LCTF_CHILD) && LCTF_TYPE_ISPARENT (fp, type)\n-      && (fp = fp->ctf_parent) == NULL)\n+  if ((fp = ctf_get_dict (fp, type)) == NULL)\n     {\n       (void) ctf_set_errno (*fpp, ECTF_NOPARENT);\n       return NULL;\n     }\n \n-  /* If this container is writable, check for a dynamic type.  */\n+  /* If this dict is writable, check for a dynamic type.  */\n \n   if (fp->ctf_flags & LCTF_RDWR)\n     {"
    },
    {
      "sha": "d7ed0e31dca3d3926e59f9a4d15c439d5e7ee135",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 350,
      "deletions": 2,
      "changes": 352,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -18,6 +18,7 @@\n    <http://www.gnu.org/licenses/>.  */\n \n #include <ctf-impl.h>\n+#include <assert.h>\n #include <string.h>\n \n /* Determine whether a type is a parent or a child.  */\n@@ -103,6 +104,125 @@ ctf_member_iter (ctf_file_t *fp, ctf_id_t type, ctf_member_f *func, void *arg)\n   return 0;\n }\n \n+/* Iterate over the members of a STRUCT or UNION, returning each member's\n+   offset and optionally name and member type in turn.  On end-of-iteration,\n+   returns -1.  */\n+\n+ssize_t\n+ctf_member_next (ctf_file_t *fp, ctf_id_t type, ctf_next_t **it,\n+\t\t const char **name, ctf_id_t *membtype)\n+{\n+  ctf_file_t *ofp = fp;\n+  uint32_t kind;\n+  ssize_t offset;\n+  ctf_next_t *i = *it;\n+\n+  if (!i)\n+    {\n+      const ctf_type_t *tp;\n+      ctf_dtdef_t *dtd;\n+\n+      if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n+\treturn -1;\t\t\t/* errno is set for us.  */\n+\n+      if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+\treturn -1;\t\t\t/* errno is set for us.  */\n+\n+      if ((i = ctf_next_create ()) == NULL)\n+\treturn ctf_set_errno (ofp, ENOMEM);\n+      i->cu.ctn_fp = ofp;\n+\n+      (void) ctf_get_ctt_size (fp, tp, &i->ctn_size,\n+\t\t\t       &i->ctn_increment);\n+      kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n+\n+      if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  return (ctf_set_errno (ofp, ECTF_NOTSOU));\n+\t}\n+\n+      dtd = ctf_dynamic_type (fp, type);\n+      i->ctn_iter_fun = (void (*) (void)) ctf_member_next;\n+\n+      /* We depend below on the RDWR state indicating whether the DTD-related\n+\t fields or the DMD-related fields have been initialized.  */\n+\n+      assert ((dtd && (fp->ctf_flags & LCTF_RDWR))\n+\t      || (!dtd && (!(fp->ctf_flags & LCTF_RDWR))));\n+\n+      if (dtd == NULL)\n+\t{\n+\t  i->ctn_n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n+\n+\t  if (i->ctn_size < CTF_LSTRUCT_THRESH)\n+\t    i->u.ctn_mp = (const ctf_member_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t  i->ctn_increment);\n+\t  else\n+\t    i->u.ctn_lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n+\t\t\t\t\t\t    i->ctn_increment);\n+\t}\n+      else\n+\ti->u.ctn_dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_member_next != i->ctn_iter_fun)\n+    return (ctf_set_errno (ofp, ECTF_NEXT_WRONGFUN));\n+\n+  if (ofp != i->cu.ctn_fp)\n+    return (ctf_set_errno (ofp, ECTF_NEXT_WRONGFP));\n+\n+  /* Resolve to the native dict of this type.  */\n+  if ((fp = ctf_get_dict (ofp, type)) == NULL)\n+    return (ctf_set_errno (ofp, ECTF_NOPARENT));\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    {\n+      if (i->ctn_n == 0)\n+\tgoto end_iter;\n+\n+      if (i->ctn_size < CTF_LSTRUCT_THRESH)\n+\t{\n+\t  if (name)\n+\t    *name = ctf_strptr (fp, i->u.ctn_mp->ctm_name);\n+\t  if (membtype)\n+\t    *membtype = i->u.ctn_mp->ctm_type;\n+\t  offset = i->u.ctn_mp->ctm_offset;\n+\t  i->u.ctn_mp++;\n+\t}\n+      else\n+\t{\n+\t  if (name)\n+\t    *name = ctf_strptr (fp, i->u.ctn_lmp->ctlm_name);\n+\t  if (membtype)\n+\t    *membtype = i->u.ctn_lmp->ctlm_type;\n+\t  offset = (unsigned long) CTF_LMEM_OFFSET (i->u.ctn_lmp);\n+\t  i->u.ctn_lmp++;\n+\t}\n+      i->ctn_n--;\n+    }\n+  else\n+    {\n+      if (i->u.ctn_dmd == NULL)\n+\tgoto end_iter;\n+      if (name)\n+\t*name = i->u.ctn_dmd->dmd_name;\n+      if (membtype)\n+\t*membtype = i->u.ctn_dmd->dmd_type;\n+      offset = i->u.ctn_dmd->dmd_offset;\n+      i->u.ctn_dmd = ctf_list_next (i->u.ctn_dmd);\n+    }\n+\n+  return offset;\n+\n+ end_iter:\n+  ctf_next_destroy (i);\n+  *it = NULL;\n+  return ctf_set_errno (ofp, ECTF_NEXT_END);\n+}\n+\n /* Iterate over the members of an ENUM.  We pass the string name and associated\n    integer value of each enum element to the specified callback function.  */\n \n@@ -154,8 +274,126 @@ ctf_enum_iter (ctf_file_t *fp, ctf_id_t type, ctf_enum_f *func, void *arg)\n   return 0;\n }\n \n+/* Iterate over the members of an enum TYPE, returning each enumerand's NAME or\n+   NULL at end of iteration or error, and optionally passing back the\n+   enumerand's integer VALue.  */\n+\n+const char *\n+ctf_enum_next (ctf_file_t *fp, ctf_id_t type, ctf_next_t **it,\n+\t       int *val)\n+{\n+  ctf_file_t *ofp = fp;\n+  uint32_t kind;\n+  const char *name;\n+  ctf_next_t *i = *it;\n+\n+  if (!i)\n+    {\n+      const ctf_type_t *tp;\n+      ctf_dtdef_t *dtd;\n+\n+      if ((type = ctf_type_resolve_unsliced (fp, type)) == CTF_ERR)\n+\treturn NULL;\t\t\t/* errno is set for us.  */\n+\n+      if ((tp = ctf_lookup_by_id (&fp, type)) == NULL)\n+\treturn NULL;\t\t\t/* errno is set for us.  */\n+\n+      if ((i = ctf_next_create ()) == NULL)\n+\t{\n+\t  ctf_set_errno (ofp, ENOMEM);\n+\t  return NULL;\n+\t}\n+      i->cu.ctn_fp = ofp;\n+\n+      (void) ctf_get_ctt_size (fp, tp, NULL,\n+\t\t\t       &i->ctn_increment);\n+      kind = LCTF_INFO_KIND (fp, tp->ctt_info);\n+\n+      if (kind != CTF_K_ENUM)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  ctf_set_errno (ofp, ECTF_NOTENUM);\n+\t  return NULL;\n+\t}\n+\n+      dtd = ctf_dynamic_type (fp, type);\n+      i->ctn_iter_fun = (void (*) (void)) ctf_enum_next;\n+\n+      /* We depend below on the RDWR state indicating whether the DTD-related\n+\t fields or the DMD-related fields have been initialized.  */\n+\n+      assert ((dtd && (fp->ctf_flags & LCTF_RDWR))\n+\t      || (!dtd && (!(fp->ctf_flags & LCTF_RDWR))));\n+\n+      if (dtd == NULL)\n+\t{\n+\t  i->ctn_n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n+\n+\t  i->u.ctn_en = (const ctf_enum_t *) ((uintptr_t) tp +\n+\t\t\t\t\t      i->ctn_increment);\n+\t}\n+      else\n+\ti->u.ctn_dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_enum_next != i->ctn_iter_fun)\n+    {\n+      ctf_set_errno (ofp, ECTF_NEXT_WRONGFUN);\n+      return NULL;\n+    }\n+\n+  if (ofp != i->cu.ctn_fp)\n+    {\n+      ctf_set_errno (ofp, ECTF_NEXT_WRONGFP);\n+      return NULL;\n+    }\n+\n+  /* Resolve to the native dict of this type.  */\n+  if ((fp = ctf_get_dict (ofp, type)) == NULL)\n+    {\n+      ctf_set_errno (ofp, ECTF_NOPARENT);\n+      return NULL;\n+    }\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    {\n+      if (i->ctn_n == 0)\n+\tgoto end_iter;\n+\n+      name = ctf_strptr (fp, i->u.ctn_en->cte_name);\n+      if (val)\n+\t*val = i->u.ctn_en->cte_value;\n+      i->u.ctn_en++;\n+      i->ctn_n--;\n+    }\n+  else\n+    {\n+      if (i->u.ctn_dmd == NULL)\n+\tgoto end_iter;\n+\n+      name = i->u.ctn_dmd->dmd_name;\n+      if (val)\n+\t*val = i->u.ctn_dmd->dmd_value;\n+      i->u.ctn_dmd = ctf_list_next (i->u.ctn_dmd);\n+    }\n+\n+  return name;\n+\n+ end_iter:\n+  ctf_next_destroy (i);\n+  *it = NULL;\n+  ctf_set_errno (ofp, ECTF_NEXT_END);\n+  return NULL;\n+}\n+\n /* Iterate over every root (user-visible) type in the given CTF container.\n-   We pass the type ID of each type to the specified callback function.  */\n+   We pass the type ID of each type to the specified callback function.\n+\n+   Does not traverse parent types: you have to do that explicitly.  This is by\n+   design, to avoid traversing them more than once if traversing many children\n+   of a single parent.  */\n \n int\n ctf_type_iter (ctf_file_t *fp, ctf_type_f *func, void *arg)\n@@ -175,7 +413,11 @@ ctf_type_iter (ctf_file_t *fp, ctf_type_f *func, void *arg)\n }\n \n /* Iterate over every type in the given CTF container, user-visible or not.\n-   We pass the type ID of each type to the specified callback function.  */\n+   We pass the type ID of each type to the specified callback function.\n+\n+   Does not traverse parent types: you have to do that explicitly.  This is by\n+   design, to avoid traversing them more than once if traversing many children\n+   of a single parent.  */\n \n int\n ctf_type_iter_all (ctf_file_t *fp, ctf_type_all_f *func, void *arg)\n@@ -195,6 +437,55 @@ ctf_type_iter_all (ctf_file_t *fp, ctf_type_all_f *func, void *arg)\n   return 0;\n }\n \n+/* Iterate over every type in the given CTF container, optionally including\n+   non-user-visible types, returning each type ID and hidden flag in turn.\n+   Returns CTF_ERR on end of iteration or error.\n+\n+   Does not traverse parent types: you have to do that explicitly.  This is by\n+   design, to avoid traversing them more than once if traversing many children\n+   of a single parent.  */\n+\n+ctf_id_t\n+ctf_type_next (ctf_file_t *fp, ctf_next_t **it, int *flag, int want_hidden)\n+{\n+  ctf_next_t *i = *it;\n+\n+  if (!i)\n+    {\n+      if ((i = ctf_next_create ()) == NULL)\n+\treturn ctf_set_errno (fp, ENOMEM);\n+\n+      i->cu.ctn_fp = fp;\n+      i->ctn_type = 1;\n+      i->ctn_iter_fun = (void (*) (void)) ctf_type_next;\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_type_next != i->ctn_iter_fun)\n+    return (ctf_set_errno (fp, ECTF_NEXT_WRONGFUN));\n+\n+  if (fp != i->cu.ctn_fp)\n+    return (ctf_set_errno (fp, ECTF_NEXT_WRONGFP));\n+\n+  while (i->ctn_type <= fp->ctf_typemax)\n+    {\n+      const ctf_type_t *tp = LCTF_INDEX_TO_TYPEPTR (fp, i->ctn_type);\n+\n+      if ((!want_hidden) && (!LCTF_INFO_ISROOT (fp, tp->ctt_info)))\n+\t{\n+\t  i->ctn_type++;\n+\t  continue;\n+\t}\n+\n+      if (flag)\n+\t*flag = LCTF_INFO_ISROOT (fp, tp->ctt_info);\n+      return LCTF_INDEX_TO_TYPE (fp, i->ctn_type++, fp->ctf_flags & LCTF_CHILD);\n+    }\n+  ctf_next_destroy (i);\n+  *it = NULL;\n+  return ctf_set_errno (fp, ECTF_NEXT_END);\n+}\n+\n /* Iterate over every variable in the given CTF container, in arbitrary order.\n    We pass the name of each variable to the specified callback function.  */\n \n@@ -229,6 +520,63 @@ ctf_variable_iter (ctf_file_t *fp, ctf_variable_f *func, void *arg)\n   return 0;\n }\n \n+/* Iterate over every variable in the given CTF container, in arbitrary order,\n+   returning the name and type of each variable in turn.  The name argument is\n+   not optional.  Returns CTF_ERR on end of iteration or error.  */\n+\n+ctf_id_t\n+ctf_variable_next (ctf_file_t *fp, ctf_next_t **it, const char **name)\n+{\n+  ctf_next_t *i = *it;\n+\n+  if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parent == NULL))\n+    return (ctf_set_errno (fp, ECTF_NOPARENT));\n+\n+  if (!i)\n+    {\n+      if ((i = ctf_next_create ()) == NULL)\n+\treturn ctf_set_errno (fp, ENOMEM);\n+\n+      i->cu.ctn_fp = fp;\n+      i->ctn_iter_fun = (void (*) (void)) ctf_variable_next;\n+      if (fp->ctf_flags & LCTF_RDWR)\n+\ti->u.ctn_dvd = ctf_list_next (&fp->ctf_dvdefs);\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_variable_next != i->ctn_iter_fun)\n+    return (ctf_set_errno (fp, ECTF_NEXT_WRONGFUN));\n+\n+  if (fp != i->cu.ctn_fp)\n+    return (ctf_set_errno (fp, ECTF_NEXT_WRONGFP));\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    {\n+      if (i->ctn_n >= fp->ctf_nvars)\n+\tgoto end_iter;\n+\n+      *name = ctf_strptr (fp, fp->ctf_vars[i->ctn_n].ctv_name);\n+      return fp->ctf_vars[i->ctn_n++].ctv_type;\n+    }\n+  else\n+    {\n+      ctf_id_t id;\n+\n+      if (i->u.ctn_dvd == NULL)\n+\tgoto end_iter;\n+\n+      *name = i->u.ctn_dvd->dvd_name;\n+      id = i->u.ctn_dvd->dvd_type;\n+      i->u.ctn_dvd = ctf_list_next (i->u.ctn_dvd);\n+      return id;\n+    }\n+\n+ end_iter:\n+  ctf_next_destroy (i);\n+  *it = NULL;\n+  return ctf_set_errno (fp, ECTF_NEXT_END);\n+}\n+\n /* Follow a given type through the graph for TYPEDEF, VOLATILE, CONST, and\n    RESTRICT nodes until we reach a \"base\" type node.  This is useful when\n    we want to follow a type ID to a node that has members or a size.  To guard"
    },
    {
      "sha": "5abea6a70bb126f45712f11ff06be9e093f5e8b5",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -173,3 +173,32 @@ ctf_set_errno (ctf_file_t * fp, int err)\n   fp->ctf_errno = err;\n   return CTF_ERR;\n }\n+\n+/* Create a ctf_next_t.  */\n+\n+ctf_next_t *\n+ctf_next_create (void)\n+{\n+  return calloc (1, sizeof (struct ctf_next));\n+}\n+\n+/* Destroy a ctf_next_t, for early exit from iterators.  */\n+\n+void\n+ctf_next_destroy (ctf_next_t *i)\n+{\n+  free (i);\n+}\n+\n+/* Copy a ctf_next_t.  */\n+\n+ctf_next_t *\n+ctf_next_copy (ctf_next_t *i)\n+{\n+  ctf_next_t *i2;\n+\n+  if ((i2 = ctf_next_create()) == NULL)\n+    return NULL;\n+  memcpy (i2, i, sizeof (struct ctf_next));\n+  return i2;\n+}"
    },
    {
      "sha": "e99f890e0e1fb5a1a7fdbe2397e7dd2ee6bdde45",
      "filename": "libctf/libctf.ver",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/libctf.ver",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/688d28f62146bf07b2ce1efd5380768d5ead418d/libctf/libctf.ver",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/libctf.ver?ref=688d28f62146bf07b2ce1efd5380768d5ead418d",
      "patch": "@@ -73,6 +73,7 @@ LIBCTF_1.0 {\n \tctf_type_compat;\n \n \tctf_member_info;\n+\tctf_member_next;\n \tctf_array_info;\n \tctf_member_count;\n \n@@ -87,10 +88,17 @@ LIBCTF_1.0 {\n \n \tctf_member_iter;\n \tctf_enum_iter;\n+\tctf_enum_next;\n \tctf_type_iter;\n+\tctf_type_next;\n \tctf_type_iter_all;\n \tctf_label_iter;\n \tctf_variable_iter;\n+\tctf_variable_next;\n+\n+\tctf_next_create;\n+\tctf_next_destroy;\n+\tctf_next_copy;\n \n \tctf_add_array;\n \tctf_add_const;\n@@ -138,6 +146,7 @@ LIBCTF_1.0 {\n \tctf_arc_open_by_name_sections;\n \tctf_archive_count;\n \tctf_archive_iter;\n+\tctf_archive_next;\n \tctf_archive_raw_iter;\n \tctf_get_arc;\n "
    }
  ]
}