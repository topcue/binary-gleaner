{
  "sha": "6a7ee0010e63a3eac4c58c48f2484a0fafdb7d2e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmE3ZWUwMDEwZTYzYTNlYWM0YzU4YzQ4ZjI0ODRhMGZhZmRiN2QyZQ==",
  "commit": {
    "author": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-08-04T10:53:47Z"
    },
    "committer": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-08-04T10:53:47Z"
    },
    "message": "[gdb/symtab] Implement addrmap_mutable_find\n\nCurrently addrmap_mutable_find is not implemented:\n...\nstatic void *\naddrmap_mutable_find (struct addrmap *self, CORE_ADDR addr)\n{\n  /* Not needed yet.  */\n  internal_error (__FILE__, __LINE__,\n                  _(\"addrmap_find is not implemented yet \"\n                    \"for mutable addrmaps\"));\n}\n...\n\nI implemented this because I needed it during debugging, to be able to do:\n...\n(gdb) p ((dwarf2_psymtab *)addrmap_find (map, addr))->filename\n...\nbefore and after a call to addrmap_set_empty.\n\nSince this is not used otherwise, added addrmap unit test.\n\nBuild on x86_64-linux, tested by doing:\n...\n$ gdb -q -batch -ex \"maint selftest addrmap\"\nRunning selftest addrmap.\nRan 1 unit tests, 0 failed\n...\n\ngdb/ChangeLog:\n\n2021-08-03  Tom de Vries  <tdevries@suse.de>\n\n        * gdb/addrmap.c (addrmap_mutable_find): Implement\n        [GDB_SELF_TESTS] (CHECK_ADDRMAP_FIND): New macro.\n        [GDB_SELF_TESTS] (core_addr, addrmap_foreach_check, test_addrmap)\n\t(_initialize_addrmap): New function.",
    "tree": {
      "sha": "1ee105086a4085c759131cb02827edefb851887f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1ee105086a4085c759131cb02827edefb851887f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6a7ee0010e63a3eac4c58c48f2484a0fafdb7d2e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6a7ee0010e63a3eac4c58c48f2484a0fafdb7d2e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6a7ee0010e63a3eac4c58c48f2484a0fafdb7d2e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6a7ee0010e63a3eac4c58c48f2484a0fafdb7d2e/comments",
  "author": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a83ef1c760b4146d49d0f5729989e300ed4261fa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a83ef1c760b4146d49d0f5729989e300ed4261fa",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a83ef1c760b4146d49d0f5729989e300ed4261fa"
    }
  ],
  "stats": {
    "total": 130,
    "additions": 126,
    "deletions": 4
  },
  "files": [
    {
      "sha": "2cb472604f479c396d127fe0b6b406e464238cff",
      "filename": "gdb/addrmap.c",
      "status": "modified",
      "additions": 126,
      "deletions": 4,
      "changes": 130,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a7ee0010e63a3eac4c58c48f2484a0fafdb7d2e/gdb/addrmap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a7ee0010e63a3eac4c58c48f2484a0fafdb7d2e/gdb/addrmap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/addrmap.c?ref=6a7ee0010e63a3eac4c58c48f2484a0fafdb7d2e",
      "patch": "@@ -21,6 +21,7 @@\n #include \"splay-tree.h\"\n #include \"gdb_obstack.h\"\n #include \"addrmap.h\"\n+#include \"gdbsupport/selftest.h\"\n \n /* Make sure splay trees can actually hold the values we want to\n    store in them.  */\n@@ -390,10 +391,22 @@ addrmap_mutable_set_empty (struct addrmap *self,\n static void *\n addrmap_mutable_find (struct addrmap *self, CORE_ADDR addr)\n {\n-  /* Not needed yet.  */\n-  internal_error (__FILE__, __LINE__,\n-\t\t  _(\"addrmap_find is not implemented yet \"\n-\t\t    \"for mutable addrmaps\"));\n+  struct addrmap_mutable *map = (struct addrmap_mutable *) self;\n+  splay_tree_node n = addrmap_splay_tree_lookup (map, addr);\n+  if (n != nullptr)\n+    {\n+      gdb_assert (addrmap_node_key (n) == addr);\n+      return addrmap_node_value (n);\n+    }\n+\n+  n = addrmap_splay_tree_predecessor (map, addr);\n+  if (n != nullptr)\n+    {\n+      gdb_assert (addrmap_node_key (n) < addr);\n+      return addrmap_node_value (n);\n+    }\n+\n+  return nullptr;\n }\n \n \n@@ -576,3 +589,112 @@ addrmap_create_mutable (struct obstack *obstack)\n \n   return (struct addrmap *) map;\n }\n+\n+#if GDB_SELF_TEST\n+namespace selftests {\n+\n+/* Convert P to CORE_ADDR.  */\n+\n+static CORE_ADDR\n+core_addr (void *p)\n+{\n+  return (CORE_ADDR)(uintptr_t)p;\n+}\n+\n+/* Check that &ARRAY[LOW]..&ARRAY[HIGH] has VAL in MAP.  */\n+\n+#define CHECK_ADDRMAP_FIND(MAP, ARRAY, LOW, HIGH, VAL)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      for (unsigned i = LOW; i <= HIGH; ++i)\t\t\t\t\\\n+\tSELF_CHECK (addrmap_find (MAP, core_addr (&ARRAY[i])) == VAL);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* We'll verify using the addresses of the elements of this array.  */\n+static char *array;\n+/* We'll verify using these values stored into the map.  */\n+static void *val1;\n+static void *val2;\n+\n+/* Callback for addrmap_foreach to check transitions.  */\n+\n+static int\n+addrmap_foreach_check (CORE_ADDR start_addr, void *obj)\n+{\n+  if (start_addr == core_addr (nullptr))\n+    SELF_CHECK (obj == nullptr);\n+  else if (start_addr == core_addr (&array[10]))\n+    SELF_CHECK (obj == val1);\n+  else if (start_addr == core_addr (&array[13]))\n+    SELF_CHECK (obj == nullptr);\n+  else\n+    SELF_CHECK (false);\n+  return 0;\n+}\n+\n+/* Entry point for addrmap unit tests.  */\n+\n+static void\n+test_addrmap ()\n+{\n+  /* Initialize static variables.  */\n+  char local_array[20];\n+  array = local_array;\n+  val1 = &array[1];\n+  val2 = &array[2];\n+\n+  /* Create mutable addrmap.  */\n+  static struct obstack temp_obstack;\n+  obstack_init (&temp_obstack);\n+  struct addrmap *map = addrmap_create_mutable (&temp_obstack);\n+  SELF_CHECK (map != nullptr);\n+\n+  /* Check initial state.  */\n+  CHECK_ADDRMAP_FIND (map, array, 0, 19, nullptr);\n+\n+  /* Insert address range into mutable addrmap.  */\n+  addrmap_set_empty (map, core_addr (&array[10]), core_addr (&array[12]),\n+\t\t     val1);\n+  CHECK_ADDRMAP_FIND (map, array, 0, 9, nullptr);\n+  CHECK_ADDRMAP_FIND (map, array, 10, 12, val1);\n+  CHECK_ADDRMAP_FIND (map, array, 13, 19, nullptr);\n+\n+  /* Create corresponding fixed addrmap.  */\n+  struct addrmap *map2 = addrmap_create_fixed (map, &temp_obstack);\n+  SELF_CHECK (map2 != nullptr);\n+  CHECK_ADDRMAP_FIND (map2, array, 0, 9, nullptr);\n+  CHECK_ADDRMAP_FIND (map2, array, 10, 12, val1);\n+  CHECK_ADDRMAP_FIND (map2, array, 13, 19, nullptr);\n+\n+  /* Iterate over both addrmaps.  */\n+  SELF_CHECK (addrmap_foreach (map, addrmap_foreach_check) == 0);\n+  SELF_CHECK (addrmap_foreach (map2, addrmap_foreach_check) == 0);\n+\n+  /* Relocate fixed addrmap.  */\n+  addrmap_relocate (map2, 1);\n+  CHECK_ADDRMAP_FIND (map2, array, 0, 10, nullptr);\n+  CHECK_ADDRMAP_FIND (map2, array, 11, 13, val1);\n+  CHECK_ADDRMAP_FIND (map2, array, 14, 19, nullptr);\n+\n+  /* Insert partially overlapping address range into mutable addrmap.  */\n+  addrmap_set_empty (map, core_addr (&array[11]), core_addr (&array[13]),\n+\t\t     val2);\n+  CHECK_ADDRMAP_FIND (map, array, 0, 9, nullptr);\n+  CHECK_ADDRMAP_FIND (map, array, 10, 12, val1);\n+  CHECK_ADDRMAP_FIND (map, array, 13, 13, val2);\n+  CHECK_ADDRMAP_FIND (map, array, 14, 19, nullptr);\n+\n+  /* Cleanup.  */\n+  obstack_free (&temp_obstack, NULL);\n+}\n+\n+} // namespace selftests\n+\n+void _initialize_addrmap ();\n+void\n+_initialize_addrmap ()\n+{\n+  selftests::register_test (\"addrmap\", selftests::test_addrmap);\n+}\n+#endif /* GDB_SELF_TEST */"
    }
  ]
}