{
  "sha": "48db3297342d798e58a00771a67b9b4c93412920",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDhkYjMyOTczNDJkNzk4ZTU4YTAwNzcxYTY3YjliNGM5MzQxMjkyMA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-10-14T03:20:48Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-10-14T06:17:13Z"
    },
    "message": "qsort: elf_sort_sections use of target_index\n\nelf_sort_sections tried to ensure a stable qsort by using target_index\nas the final comparison, but target_index hasn't been set by anything\nat the time elf_sort_sections was run.  This patch arrange to have\ntarget_index set.\n\n\t* elf.c (_bfd_elf_map_sections_to_segments): Init target_index\n\tfor sections about to be sorted.\n\t(assign_file_positions_for_load_sections): Likewise.\n\t(elf_sort_sections): Don't bother optimising both TOEND case.\n\t* elflink.c (bfd_elf_final_link): Reset target_index.",
    "tree": {
      "sha": "610c95421aade3fa9371ccb796f8b99d83e56077",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/610c95421aade3fa9371ccb796f8b99d83e56077"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/48db3297342d798e58a00771a67b9b4c93412920",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/48db3297342d798e58a00771a67b9b4c93412920",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/48db3297342d798e58a00771a67b9b4c93412920",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/48db3297342d798e58a00771a67b9b4c93412920/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8c1c5e5de46f415bbdeabb3cad3fd1383f5fb995"
    }
  ],
  "stats": {
    "total": 33,
    "additions": 23,
    "deletions": 10
  },
  "files": [
    {
      "sha": "6a5f673dea2f454aff707187a207962518a6f73e",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48db3297342d798e58a00771a67b9b4c93412920/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48db3297342d798e58a00771a67b9b4c93412920/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=48db3297342d798e58a00771a67b9b4c93412920",
      "patch": "@@ -1,3 +1,11 @@\n+2019-10-14  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf.c (_bfd_elf_map_sections_to_segments): Init target_index\n+\tfor sections about to be sorted.\n+\t(assign_file_positions_for_load_sections): Likewise.\n+\t(elf_sort_sections): Don't bother optimising both TOEND case.\n+\t* elflink.c (bfd_elf_final_link): Reset target_index.\n+\n 2019-10-14  Alan Modra  <amodra@gmail.com>\n \n \t* elflink.c (elf_get_linked_section_vma): Delete."
    },
    {
      "sha": "314c866c3f10ba6e8e4b8ed8fd4ba66fbf83d7d2",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 11,
      "deletions": 10,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48db3297342d798e58a00771a67b9b4c93412920/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48db3297342d798e58a00771a67b9b4c93412920/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=48db3297342d798e58a00771a67b9b4c93412920",
      "patch": "@@ -4703,6 +4703,10 @@ _bfd_elf_map_sections_to_segments (bfd *abfd, struct bfd_link_info *info)\n \t{\n \t  if ((s->flags & SEC_ALLOC) != 0)\n \t    {\n+\t      /* target_index is unused until bfd_elf_final_link\n+\t\t starts output of section symbols.  Use it to make\n+\t\t qsort stable.  */\n+\t      s->target_index = i;\n \t      sections[i] = s;\n \t      ++i;\n \t      /* A wrapping section potentially clashes with header.  */\n@@ -5270,14 +5274,7 @@ elf_sort_sections (const void *arg1, const void *arg2)\n \n   if (TOEND (sec1))\n     {\n-      if (TOEND (sec2))\n-\t{\n-\t  /* If the indices are the same, do not return 0\n-\t     here, but continue to try the next comparison.  */\n-\t  if (sec1->target_index - sec2->target_index != 0)\n-\t    return sec1->target_index - sec2->target_index;\n-\t}\n-      else\n+      if (!TOEND (sec2))\n \treturn 1;\n     }\n   else if (TOEND (sec2))\n@@ -5479,8 +5476,12 @@ assign_file_positions_for_load_sections (bfd *abfd,\n       if (m->count > 1\n \t  && !(elf_elfheader (abfd)->e_type == ET_CORE\n \t       && m->p_type == PT_NOTE))\n-\tqsort (m->sections, (size_t) m->count, sizeof (asection *),\n-\t       elf_sort_sections);\n+\t{\n+\t  for (i = 0; i < m->count; i++)\n+\t    m->sections[i]->target_index = i;\n+\t  qsort (m->sections, (size_t) m->count, sizeof (asection *),\n+\t\t elf_sort_sections);\n+\t}\n \n       /* An ELF segment (described by Elf_Internal_Phdr) may contain a\n \t number of sections with contents contributing to both p_filesz"
    },
    {
      "sha": "bfd0f019aad402b0743677d2e57a07aa1a9a0810",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/48db3297342d798e58a00771a67b9b4c93412920/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/48db3297342d798e58a00771a67b9b4c93412920/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=48db3297342d798e58a00771a67b9b4c93412920",
      "patch": "@@ -12048,6 +12048,10 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)\n \t    goto error_return;\n \t}\n \n+      /* _bfd_elf_compute_section_file_positions makes temporary use\n+\t of target_index.  Reset it.  */\n+      o->target_index = 0;\n+\n       /* Now, reset REL_COUNT and REL_COUNT2 so that we can use them\n \t to count upwards while actually outputting the relocations.  */\n       esdo->rel.count = 0;"
    }
  ]
}