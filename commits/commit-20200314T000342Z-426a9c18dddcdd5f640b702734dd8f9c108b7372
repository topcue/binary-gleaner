{
  "sha": "426a9c18dddcdd5f640b702734dd8f9c108b7372",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDI2YTljMThkZGRjZGQ1ZjY0MGI3MDI3MzRkZDhmOWMxMDhiNzM3Mg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-13T23:39:52Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-14T00:03:42Z"
    },
    "message": "Remove val_print\n\nWe can finally remove val_print and various helper functions that are\nno longer needed.\n\ngdb/ChangeLog\n2020-03-13  Tom Tromey  <tom@tromey.com>\n\n\t* value.h (val_print): Don't declare.\n\t* valprint.h (val_print_array_elements)\n\t(val_print_scalar_formatted, generic_val_print): Don't declare.\n\t* valprint.c (generic_val_print_array): Take a struct value.\n\t(generic_val_print_ptr, generic_val_print_memberptr)\n\t(generic_val_print_bool, generic_val_print_int)\n\t(generic_val_print_char, generic_val_print_complex)\n\t(generic_val_print): Remove.\n\t(generic_value_print): Update.\n\t(do_val_print): Remove unused parameters.  Don't call\n\tla_val_print.\n\t(val_print): Remove.\n\t(common_val_print): Update.  Don't call value_check_printable.\n\t(val_print_scalar_formatted, val_print_array_elements): Remove.\n\t* rust-lang.c (rust_val_print): Remove.\n\t(rust_language_defn): Update.\n\t* p-valprint.c (pascal_val_print): Remove.\n\t(pascal_value_print_inner): Update.\n\t(pascal_object_print_val_fields, pascal_object_print_val):\n\tRemove.\n\t(pascal_object_print_static_field): Update.\n\t* p-lang.h (pascal_val_print): Don't declare.\n\t* p-lang.c (pascal_language_defn): Update.\n\t* opencl-lang.c (opencl_language_defn): Update.\n\t* objc-lang.c (objc_language_defn): Update.\n\t* m2-valprint.c (m2_print_unbounded_array, m2_val_print): Remove.\n\t* m2-lang.h (m2_val_print): Don't declare.\n\t* m2-lang.c (m2_language_defn): Update.\n\t* language.h (struct language_defn) <la_val_print>: Remove.\n\t* language.c (unk_lang_value_print_inner): Rename.  Change\n\targument types.\n\t(unknown_language_defn, auto_language_defn): Update.\n\t* go-valprint.c (go_val_print): Remove.\n\t* go-lang.h (go_val_print): Don't declare.\n\t* go-lang.c (go_language_defn): Update.\n\t* f-valprint.c (f_val_print): Remove.\n\t* f-lang.h (f_value_print): Don't declare.\n\t* f-lang.c (f_language_defn): Update.\n\t* d-valprint.c (d_val_print): Remove.\n\t* d-lang.h (d_value_print): Don't declare.\n\t* d-lang.c (d_language_defn): Update.\n\t* cp-valprint.c (cp_print_value_fields)\n\t(cp_print_value_fields_rtti, cp_print_value): Remove.\n\t(cp_print_static_field): Update.\n\t* c-valprint.c (c_val_print_array, c_val_print_ptr)\n\t(c_val_print_struct, c_val_print_union, c_val_print_int)\n\t(c_val_print_memberptr, c_val_print): Remove.\n\t* c-lang.h (c_val_print_array, cp_print_value_fields)\n\t(cp_print_value_fields_rtti): Don't declare.\n\t* c-lang.c (c_language_defn, cplus_language_defn)\n\t(asm_language_defn, minimal_language_defn): Update.\n\t* ada-valprint.c (ada_val_print_ptr, ada_val_print_num): Remove.\n\t(ada_val_print_enum): Take a struct value.\n\t(ada_val_print_flt, ada_val_print_array, ada_val_print_1)\n\t(ada_val_print): Remove.\n\t(ada_value_print_1): Update.\n\t(printable_val_type): Remove.\n\t* ada-lang.h (ada_val_print): Don't declare.\n\t* ada-lang.c (ada_language_defn): Update.",
    "tree": {
      "sha": "d9ba80f648c60ab6d3a95de00187889200459f8f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d9ba80f648c60ab6d3a95de00187889200459f8f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/426a9c18dddcdd5f640b702734dd8f9c108b7372",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/426a9c18dddcdd5f640b702734dd8f9c108b7372",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/426a9c18dddcdd5f640b702734dd8f9c108b7372",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/426a9c18dddcdd5f640b702734dd8f9c108b7372/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "42331a1ea2a13ce15ec202c5f0fbef3e5171253c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/42331a1ea2a13ce15ec202c5f0fbef3e5171253c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/42331a1ea2a13ce15ec202c5f0fbef3e5171253c"
    }
  ],
  "stats": {
    "total": 3255,
    "additions": 169,
    "deletions": 3086
  },
  "files": [
    {
      "sha": "a4ed994440707e401e559afbfc8ca9afecce2c8e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 62,
      "deletions": 0,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -1,3 +1,65 @@\n+2020-03-13  Tom Tromey  <tom@tromey.com>\n+\n+\t* value.h (val_print): Don't declare.\n+\t* valprint.h (val_print_array_elements)\n+\t(val_print_scalar_formatted, generic_val_print): Don't declare.\n+\t* valprint.c (generic_val_print_array): Take a struct value.\n+\t(generic_val_print_ptr, generic_val_print_memberptr)\n+\t(generic_val_print_bool, generic_val_print_int)\n+\t(generic_val_print_char, generic_val_print_complex)\n+\t(generic_val_print): Remove.\n+\t(generic_value_print): Update.\n+\t(do_val_print): Remove unused parameters.  Don't call\n+\tla_val_print.\n+\t(val_print): Remove.\n+\t(common_val_print): Update.  Don't call value_check_printable.\n+\t(val_print_scalar_formatted, val_print_array_elements): Remove.\n+\t* rust-lang.c (rust_val_print): Remove.\n+\t(rust_language_defn): Update.\n+\t* p-valprint.c (pascal_val_print): Remove.\n+\t(pascal_value_print_inner): Update.\n+\t(pascal_object_print_val_fields, pascal_object_print_val):\n+\tRemove.\n+\t(pascal_object_print_static_field): Update.\n+\t* p-lang.h (pascal_val_print): Don't declare.\n+\t* p-lang.c (pascal_language_defn): Update.\n+\t* opencl-lang.c (opencl_language_defn): Update.\n+\t* objc-lang.c (objc_language_defn): Update.\n+\t* m2-valprint.c (m2_print_unbounded_array, m2_val_print): Remove.\n+\t* m2-lang.h (m2_val_print): Don't declare.\n+\t* m2-lang.c (m2_language_defn): Update.\n+\t* language.h (struct language_defn) <la_val_print>: Remove.\n+\t* language.c (unk_lang_value_print_inner): Rename.  Change\n+\targument types.\n+\t(unknown_language_defn, auto_language_defn): Update.\n+\t* go-valprint.c (go_val_print): Remove.\n+\t* go-lang.h (go_val_print): Don't declare.\n+\t* go-lang.c (go_language_defn): Update.\n+\t* f-valprint.c (f_val_print): Remove.\n+\t* f-lang.h (f_value_print): Don't declare.\n+\t* f-lang.c (f_language_defn): Update.\n+\t* d-valprint.c (d_val_print): Remove.\n+\t* d-lang.h (d_value_print): Don't declare.\n+\t* d-lang.c (d_language_defn): Update.\n+\t* cp-valprint.c (cp_print_value_fields)\n+\t(cp_print_value_fields_rtti, cp_print_value): Remove.\n+\t(cp_print_static_field): Update.\n+\t* c-valprint.c (c_val_print_array, c_val_print_ptr)\n+\t(c_val_print_struct, c_val_print_union, c_val_print_int)\n+\t(c_val_print_memberptr, c_val_print): Remove.\n+\t* c-lang.h (c_val_print_array, cp_print_value_fields)\n+\t(cp_print_value_fields_rtti): Don't declare.\n+\t* c-lang.c (c_language_defn, cplus_language_defn)\n+\t(asm_language_defn, minimal_language_defn): Update.\n+\t* ada-valprint.c (ada_val_print_ptr, ada_val_print_num): Remove.\n+\t(ada_val_print_enum): Take a struct value.\n+\t(ada_val_print_flt, ada_val_print_array, ada_val_print_1)\n+\t(ada_val_print): Remove.\n+\t(ada_value_print_1): Update.\n+\t(printable_val_type): Remove.\n+\t* ada-lang.h (ada_val_print): Don't declare.\n+\t* ada-lang.c (ada_language_defn): Update.\n+\n 2020-03-13  Tom Tromey  <tom@tromey.com>\n \n \t* valprint.c (do_val_print): Update."
    },
    {
      "sha": "2822d40c8cd46f432ec007a7a871eeba7fd2903b",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -14109,7 +14109,6 @@ extern const struct language_defn ada_language_defn = {\n   emit_char,                    /* Function to print single char (not used) */\n   ada_print_type,               /* Print a type using appropriate syntax */\n   ada_print_typedef,            /* Print a typedef using appropriate syntax */\n-  ada_val_print,                /* Print a value using appropriate syntax */\n   ada_value_print_inner,\t/* la_value_print_inner */\n   ada_value_print,              /* Print a top-level value */\n   ada_read_var_value,\t\t/* la_read_var_value */"
    },
    {
      "sha": "1f427b0494d6035d66ded26d8df33f4fd13c4285",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -164,11 +164,6 @@ extern void ada_print_type (struct type *, const char *, struct ui_file *, int,\n extern void ada_print_typedef (struct type *type, struct symbol *new_symbol,\n \t\t\t       struct ui_file *stream);\n \n-extern void ada_val_print (struct type *, int, CORE_ADDR,\n-\t\t\t   struct ui_file *, int,\n-\t\t\t   struct value *,\n-\t\t\t   const struct value_print_options *);\n-\n /* Implement la_value_print_inner for Ada.  */\n \n extern void ada_value_print_inner (struct value *, struct ui_file *, int,"
    },
    {
      "sha": "abf7ba4b959f9083fb63da4ef549f4145019b1f2",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 7,
      "deletions": 302,
      "changes": 309,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -274,12 +274,6 @@ val_print_packed_array_elements (struct type *type, const gdb_byte *valaddr,\n   value_free_to_mark (mark);\n }\n \n-static struct type *\n-printable_val_type (struct type *type, const gdb_byte *valaddr)\n-{\n-  return ada_to_fixed_type (ada_aligned_type (type), valaddr, 0, NULL, 1);\n-}\n-\n /* Print the character C on STREAM as part of the contents of a literal\n    string whose delimiter is QUOTER.  TYPE_LEN is the length in bytes\n    of the character.  */\n@@ -782,32 +776,6 @@ ada_val_print_gnat_array (struct value *val,\n \t\t      language_def (language_ada));\n }\n \n-/* Implement Ada val_print'ing for the case where TYPE is\n-   a TYPE_CODE_PTR.  */\n-\n-static void\n-ada_val_print_ptr (struct type *type, const gdb_byte *valaddr,\n-\t\t   int offset, int offset_aligned, CORE_ADDR address,\n-\t\t   struct ui_file *stream, int recurse,\n-\t\t   struct value *original_value,\n-\t\t   const struct value_print_options *options)\n-{\n-  val_print (type, offset, address, stream, recurse,\n-\t     original_value, options, language_def (language_c));\n-\n-  if (ada_is_tag_type (type))\n-    {\n-      struct value *val =\n-\tvalue_from_contents_and_address (type,\n-\t\t\t\t\t valaddr + offset_aligned,\n-\t\t\t\t\t address + offset_aligned);\n-      const char *name = ada_tag_name (val);\n-\n-      if (name != NULL)\n-\tfprintf_filtered (stream, \" (%s)\", name);\n-    }\n-}\n-\n /* Implement Ada value_print'ing for the case where TYPE is a\n    TYPE_CODE_PTR.  */\n \n@@ -828,109 +796,6 @@ ada_value_print_ptr (struct value *val,\n     }\n }\n \n-/* Implement Ada val_print'ing for the case where TYPE is\n-   a TYPE_CODE_INT or TYPE_CODE_RANGE.  */\n-\n-static void\n-ada_val_print_num (struct type *type, const gdb_byte *valaddr,\n-\t\t   int offset, int offset_aligned, CORE_ADDR address,\n-\t\t   struct ui_file *stream, int recurse,\n-\t\t   struct value *original_value,\n-\t\t   const struct value_print_options *options)\n-{\n-  if (ada_is_fixed_point_type (type))\n-    {\n-      struct value *scale = ada_scaling_factor (type);\n-      struct value *v = value_from_contents (type, valaddr + offset_aligned);\n-      v = value_cast (value_type (scale), v);\n-      v = value_binop (v, scale, BINOP_MUL);\n-\n-      const char *fmt = TYPE_LENGTH (type) < 4 ? \"%.11g\" : \"%.17g\";\n-      std::string str\n-\t= target_float_to_string (value_contents (v), value_type (v), fmt);\n-      fputs_filtered (str.c_str (), stream);\n-      return;\n-    }\n-  else if (TYPE_CODE (type) == TYPE_CODE_RANGE\n-\t   && (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ENUM\n-\t       || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_BOOL\n-\t       || TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_CHAR))\n-    {\n-      /* For enum-valued ranges, we want to recurse, because we'll end\n-\t up printing the constant's name rather than its numeric\n-\t value.  Character and fixed-point types are also printed\n-\t differently, so recuse for those as well.  */\n-      struct type *target_type = TYPE_TARGET_TYPE (type);\n-\n-      if (TYPE_LENGTH (type) != TYPE_LENGTH (target_type))\n-\t{\n-\t  /* Obscure case of range type that has different length from\n-\t     its base type.  Perform a conversion, or we will get a\n-\t     nonsense value.  Actually, we could use the same\n-\t     code regardless of lengths; I'm just avoiding a cast.  */\n-\t  struct value *v1\n-\t    = value_from_contents_and_address (type, valaddr + offset, 0);\n-\t  struct value *v = value_cast (target_type, v1);\n-\n-\t  val_print (target_type,\n-\t\t     value_embedded_offset (v), 0, stream,\n-\t\t     recurse + 1, v, options,\n-\t\t     language_def (language_ada));\n-\t}\n-      else\n-\tval_print (TYPE_TARGET_TYPE (type), offset,\n-\t\t   address, stream, recurse, original_value,\n-\t\t   options, language_def (language_ada));\n-      return;\n-    }\n-  else\n-    {\n-      int format = (options->format ? options->format\n-\t\t    : options->output_format);\n-\n-      if (format)\n-\t{\n-\t  struct value_print_options opts = *options;\n-\n-\t  opts.format = format;\n-\t  val_print_scalar_formatted (type, offset_aligned,\n-\t\t\t\t      original_value, &opts, 0, stream);\n-\t}\n-      else if (ada_is_system_address_type (type))\n-\t{\n-\t  /* FIXME: We want to print System.Address variables using\n-\t     the same format as for any access type.  But for some\n-\t     reason GNAT encodes the System.Address type as an int,\n-\t     so we have to work-around this deficiency by handling\n-\t     System.Address values as a special case.  */\n-\n-\t  struct gdbarch *gdbarch = get_type_arch (type);\n-\t  struct type *ptr_type = builtin_type (gdbarch)->builtin_data_ptr;\n-\t  CORE_ADDR addr = extract_typed_address (valaddr + offset_aligned,\n-\t\t\t\t\t\t  ptr_type);\n-\n-\t  fprintf_filtered (stream, \"(\");\n-\t  type_print (type, \"\", stream, -1);\n-\t  fprintf_filtered (stream, \") \");\n-\t  fputs_filtered (paddress (gdbarch, addr), stream);\n-\t}\n-      else\n-\t{\n-\t  val_print_scalar_formatted (type, offset_aligned,\n-\t\t\t\t      original_value, options, 0, stream);\n-\t  if (ada_is_character_type (type))\n-\t    {\n-\t      LONGEST c;\n-\n-\t      fputs_filtered (\" \", stream);\n-\t      c = unpack_long (type, valaddr + offset_aligned);\n-\t      ada_printchar (c, type, stream);\n-\t    }\n-\t}\n-      return;\n-    }\n-}\n-\n /* Implement Ada val_print'ing for the case where TYPE is\n    a TYPE_CODE_INT or TYPE_CODE_RANGE.  */\n \n@@ -1017,10 +882,7 @@ ada_value_print_num (struct value *val, struct ui_file *stream, int recurse,\n    a TYPE_CODE_ENUM.  */\n \n static void\n-ada_val_print_enum (struct type *type, const gdb_byte *valaddr,\n-\t\t    int offset, int offset_aligned, CORE_ADDR address,\n-\t\t    struct ui_file *stream, int recurse,\n-\t\t    struct value *original_value,\n+ada_val_print_enum (struct value *value, struct ui_file *stream, int recurse,\n \t\t    const struct value_print_options *options)\n {\n   int i;\n@@ -1029,11 +891,14 @@ ada_val_print_enum (struct type *type, const gdb_byte *valaddr,\n \n   if (options->format)\n     {\n-      val_print_scalar_formatted (type, offset_aligned,\n-\t\t\t\t  original_value, options, 0, stream);\n+      value_print_scalar_formatted (value, options, 0, stream);\n       return;\n     }\n \n+  struct type *type = ada_check_typedef (value_type (value));\n+  const gdb_byte *valaddr = value_contents_for_printing (value);\n+  int offset_aligned = ada_aligned_value_addr (type, valaddr) - valaddr;\n+\n   len = TYPE_NFIELDS (type);\n   val = unpack_long (type, valaddr + offset_aligned);\n   for (i = 0; i < len; i++)\n@@ -1058,26 +923,6 @@ ada_val_print_enum (struct type *type, const gdb_byte *valaddr,\n     print_longest (stream, 'd', 0, val);\n }\n \n-/* Implement Ada val_print'ing for the case where TYPE is\n-   a TYPE_CODE_FLT.  */\n-\n-static void\n-ada_val_print_flt (struct type *type, const gdb_byte *valaddr,\n-\t\t   int offset, int offset_aligned, CORE_ADDR address,\n-\t\t   struct ui_file *stream, int recurse,\n-\t\t   struct value *original_value,\n-\t\t   const struct value_print_options *options)\n-{\n-  if (options->format)\n-    {\n-      val_print (type, offset, address, stream, recurse,\n-\t\t original_value, options, language_def (language_c));\n-      return;\n-    }\n-\n-  ada_print_floating (valaddr + offset, type, stream);\n-}\n-\n /* Implement Ada val_print'ing for the case where TYPE is\n    a TYPE_CODE_STRUCT or TYPE_CODE_UNION.  */\n \n@@ -1109,37 +954,6 @@ ada_val_print_struct_union\n   fprintf_filtered (stream, \")\");\n }\n \n-/* Implement Ada val_print'ing for the case where TYPE is\n-   a TYPE_CODE_ARRAY.  */\n-\n-static void\n-ada_val_print_array (struct type *type, const gdb_byte *valaddr,\n-\t\t     int offset, int offset_aligned, CORE_ADDR address,\n-\t\t     struct ui_file *stream, int recurse,\n-\t\t     struct value *original_value,\n-\t\t     const struct value_print_options *options)\n-{\n-  /* For an array of characters, print with string syntax.  */\n-  if (ada_is_string_type (type)\n-      && (options->format == 0 || options->format == 's'))\n-    {\n-      ada_val_print_string (type, valaddr, offset_aligned,\n-\t\t\t    stream, recurse, options);\n-      return;\n-    }\n-\n-  fprintf_filtered (stream, \"(\");\n-  print_optional_low_bound (stream, type, options);\n-  if (TYPE_FIELD_BITSIZE (type, 0) > 0)\n-    val_print_packed_array_elements (type, valaddr, offset_aligned,\n-\t\t\t\t     stream, recurse, options);\n-  else\n-    val_print_array_elements (type, offset_aligned, address,\n-\t\t\t      stream, recurse, original_value,\n-\t\t\t      options, 0);\n-  fprintf_filtered (stream, \")\");\n-}\n-\n /* Implement Ada value_print'ing for the case where TYPE is a\n    TYPE_CODE_ARRAY.  */\n \n@@ -1238,113 +1052,6 @@ ada_val_print_ref (struct type *type, const gdb_byte *valaddr,\n \t\t    options, language_def (language_ada));\n }\n \n-/* See the comment on ada_val_print.  This function differs in that it\n-   does not catch evaluation errors (leaving that to ada_val_print).  */\n-\n-static void\n-ada_val_print_1 (struct type *type,\n-\t\t int offset, CORE_ADDR address,\n-\t\t struct ui_file *stream, int recurse,\n-\t\t struct value *original_value,\n-\t\t const struct value_print_options *options)\n-{\n-  int offset_aligned;\n-  const gdb_byte *valaddr = value_contents_for_printing (original_value);\n-\n-  type = ada_check_typedef (type);\n-\n-  if (ada_is_array_descriptor_type (type)\n-      || (ada_is_constrained_packed_array_type (type)\n-\t  && TYPE_CODE (type) != TYPE_CODE_PTR))\n-    {\n-      struct value *val = value_from_contents_and_address (type,\n-\t\t\t\t\t\t\t   valaddr + offset,\n-\t\t\t\t\t\t\t   address);\n-      ada_val_print_gnat_array (val, stream, recurse, options);\n-      return;\n-    }\n-\n-  offset_aligned = offset + ada_aligned_value_addr (type, valaddr) - valaddr;\n-  type = printable_val_type (type, valaddr + offset_aligned);\n-  type = resolve_dynamic_type (type, valaddr + offset_aligned,\n-\t\t\t       address + offset_aligned);\n-\n-  switch (TYPE_CODE (type))\n-    {\n-    default:\n-      val_print (type, offset, address, stream, recurse,\n-\t\t original_value, options, language_def (language_c));\n-      break;\n-\n-    case TYPE_CODE_PTR:\n-      ada_val_print_ptr (type, valaddr, offset, offset_aligned,\n-\t\t\t address, stream, recurse, original_value,\n-\t\t\t options);\n-      break;\n-\n-    case TYPE_CODE_INT:\n-    case TYPE_CODE_RANGE:\n-      ada_val_print_num (type, valaddr, offset, offset_aligned,\n-\t\t\t address, stream, recurse, original_value,\n-\t\t\t options);\n-      break;\n-\n-    case TYPE_CODE_ENUM:\n-      ada_val_print_enum (type, valaddr, offset, offset_aligned,\n-\t\t\t  address, stream, recurse, original_value,\n-\t\t\t  options);\n-      break;\n-\n-    case TYPE_CODE_FLT:\n-      ada_val_print_flt (type, valaddr, offset, offset_aligned,\n-\t\t\t address, stream, recurse, original_value,\n-\t\t\t options);\n-      break;\n-\n-    case TYPE_CODE_UNION:\n-    case TYPE_CODE_STRUCT:\n-      ada_val_print_struct_union (type, valaddr, offset, offset_aligned,\n-\t\t\t\t  address, stream, recurse,\n-\t\t\t\t  original_value, options);\n-      break;\n-\n-    case TYPE_CODE_ARRAY:\n-      ada_val_print_array (type, valaddr, offset, offset_aligned,\n-\t\t\t   address, stream, recurse, original_value,\n-\t\t\t   options);\n-      return;\n-\n-    case TYPE_CODE_REF:\n-      ada_val_print_ref (type, valaddr, offset, offset_aligned,\n-\t\t\t address, stream, recurse, original_value,\n-\t\t\t options);\n-      break;\n-    }\n-}\n-\n-/* See val_print for a description of the various parameters of this\n-   function; they are identical.  */\n-\n-void\n-ada_val_print (struct type *type,\n-\t       int embedded_offset, CORE_ADDR address,\n-\t       struct ui_file *stream, int recurse,\n-\t       struct value *val,\n-\t       const struct value_print_options *options)\n-{\n-  try\n-    {\n-      ada_val_print_1 (type, embedded_offset, address,\n-\t\t       stream, recurse, val, options);\n-    }\n-  catch (const gdb_exception_error &except)\n-    {\n-      fprintf_styled (stream, metadata_style.style (),\n-\t\t      _(\"<error reading variable: %s>\"),\n-\t\t      except.what ());\n-    }\n-}\n-\n /* See the comment on ada_value_print.  This function differs in that\n    it does not catch evaluation errors (leaving that to\n    ada_value_print).  */\n@@ -1393,9 +1100,7 @@ ada_value_print_1 (struct value *val, struct ui_file *stream, int recurse,\n       break;\n \n     case TYPE_CODE_ENUM:\n-      ada_val_print_enum (type, valaddr, 0, 0,\n-\t\t\t  address, stream, recurse, val,\n-\t\t\t  options);\n+      ada_val_print_enum (val, stream, recurse, options);\n       break;\n \n     case TYPE_CODE_FLT:"
    },
    {
      "sha": "c335044b06b148590df71bece01acd62a9fb2f67",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -903,7 +903,6 @@ extern const struct language_defn c_language_defn =\n   c_emit_char,\t\t\t/* Print a single char */\n   c_print_type,\t\t\t/* Print a type using appropriate syntax */\n   c_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  c_val_print,\t\t\t/* Print a value using appropriate syntax */\n   c_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */\n@@ -1049,7 +1048,6 @@ extern const struct language_defn cplus_language_defn =\n   c_emit_char,\t\t\t/* Print a single char */\n   c_print_type,\t\t\t/* Print a type using appropriate syntax */\n   c_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  c_val_print,\t\t\t/* Print a value using appropriate syntax */\n   c_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */\n@@ -1104,7 +1102,6 @@ extern const struct language_defn asm_language_defn =\n   c_emit_char,\t\t\t/* Print a single char */\n   c_print_type,\t\t\t/* Print a type using appropriate syntax */\n   c_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  c_val_print,\t\t\t/* Print a value using appropriate syntax */\n   c_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */\n@@ -1159,7 +1156,6 @@ extern const struct language_defn minimal_language_defn =\n   c_emit_char,\t\t\t/* Print a single char */\n   c_print_type,\t\t\t/* Print a type using appropriate syntax */\n   c_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  c_val_print,\t\t\t/* Print a value using appropriate syntax */\n   c_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "642157125a848d3d093e4d30f40de28dc84396a5",
      "filename": "gdb/c-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 20,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/c-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/c-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -81,12 +81,6 @@ extern void c_print_typedef (struct type *,\n \t\t\t     struct symbol *,\n \t\t\t     struct ui_file *);\n \n-extern void c_val_print (struct type *,\n-\t\t\t int, CORE_ADDR,\n-\t\t\t struct ui_file *, int,\n-\t\t\t struct value *,\n-\t\t\t const struct value_print_options *);\n-\n /* Implement la_value_print_inner for the C family of languages.  */\n \n extern void c_value_print_inner (struct value *, struct ui_file *, int,\n@@ -140,20 +134,6 @@ extern void cp_print_value_fields (struct value *,\n \t\t\t\t   const struct value_print_options *,\n \t\t\t\t   struct type **, int);\n \n-extern void cp_print_value_fields (struct type *, struct type *,\n-\t\t\t\t   LONGEST, CORE_ADDR,\n-\t\t\t\t   struct ui_file *, int,\n-\t\t\t\t   struct value *,\n-\t\t\t\t   const struct value_print_options *,\n-\t\t\t\t   struct type **, int);\n-\n-extern void cp_print_value_fields_rtti (struct type *,\n-\t\t\t\t\tconst gdb_byte *, LONGEST, CORE_ADDR,\n-\t\t\t\t\tstruct ui_file *, int,\n-\t\t\t\t\tstruct value *,\n-\t\t\t\t\tconst struct value_print_options *,\n-\t\t\t\t\tstruct type **, int);\n-\n /* gcc-2.6 or later (when using -fvtable-thunks)\n    emits a unique named type for a vtable entry.\n    Some gdb code depends on that specific name.  */"
    },
    {
      "sha": "76a86faea6aca84f07327afd94bf00eca044d44b",
      "filename": "gdb/c-valprint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 330,
      "changes": 330,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/c-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/c-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -228,113 +228,6 @@ print_unpacked_pointer (struct type *type, struct type *elttype,\n     }\n }\n \n-/* c_val_print helper for TYPE_CODE_ARRAY.  */\n-\n-static void\n-c_val_print_array (struct type *type, const gdb_byte *valaddr,\n-\t\t   int embedded_offset, CORE_ADDR address,\n-\t\t   struct ui_file *stream, int recurse,\n-\t\t   struct value *original_value,\n-\t\t   const struct value_print_options *options)\n-{\n-  struct type *unresolved_elttype = TYPE_TARGET_TYPE (type);\n-  struct type *elttype = check_typedef (unresolved_elttype);\n-  struct gdbarch *arch = get_type_arch (type);\n-  int unit_size = gdbarch_addressable_memory_unit_size (arch);\n-\n-  if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (unresolved_elttype) > 0)\n-    {\n-      LONGEST low_bound, high_bound;\n-      int eltlen, len;\n-      enum bfd_endian byte_order = type_byte_order (type);\n-\n-      if (!get_array_bounds (type, &low_bound, &high_bound))\n-\terror (_(\"Could not determine the array high bound\"));\n-\n-      eltlen = TYPE_LENGTH (elttype);\n-      len = high_bound - low_bound + 1;\n-      if (options->prettyformat_arrays)\n-\t{\n-\t  print_spaces_filtered (2 + 2 * recurse, stream);\n-\t}\n-\n-      /* Print arrays of textual chars with a string syntax, as\n-\t long as the entire array is valid.  */\n-      if (c_textual_element_type (unresolved_elttype,\n-\t\t\t\t  options->format)\n-\t  && value_bytes_available (original_value, embedded_offset,\n-\t\t\t\t    TYPE_LENGTH (type))\n-\t  && !value_bits_any_optimized_out (original_value,\n-\t\t\t\t\t    TARGET_CHAR_BIT * embedded_offset,\n-\t\t\t\t\t    TARGET_CHAR_BIT * TYPE_LENGTH (type)))\n-\t{\n-\t  int force_ellipses = 0;\n-\n-\t  /* If requested, look for the first null char and only\n-\t     print elements up to it.  */\n-\t  if (options->stop_print_at_null)\n-\t    {\n-\t      unsigned int temp_len;\n-\n-\t      for (temp_len = 0;\n-\t\t   (temp_len < len\n-\t\t    && temp_len < options->print_max\n-\t\t    && extract_unsigned_integer (valaddr\n-\t\t\t\t\t\t + embedded_offset * unit_size\n-\t\t\t\t\t\t + temp_len * eltlen,\n-\t\t\t\t\t\t eltlen, byte_order) != 0);\n-\t\t   ++temp_len)\n-\t\t;\n-\n-\t      /* Force LA_PRINT_STRING to print ellipses if\n-\t\t we've printed the maximum characters and\n-\t\t the next character is not \\000.  */\n-\t      if (temp_len == options->print_max && temp_len < len)\n-\t\t{\n-\t\t  ULONGEST val\n-\t\t    = extract_unsigned_integer (valaddr\n-\t\t\t\t\t\t+ embedded_offset * unit_size\n-\t\t\t\t\t\t+ temp_len * eltlen,\n-\t\t\t\t\t\teltlen, byte_order);\n-\t\t  if (val != 0)\n-\t\t    force_ellipses = 1;\n-\t\t}\n-\n-\t      len = temp_len;\n-\t    }\n-\n-\t  LA_PRINT_STRING (stream, unresolved_elttype,\n-\t\t\t   valaddr + embedded_offset * unit_size, len,\n-\t\t\t   NULL, force_ellipses, options);\n-\t}\n-      else\n-\t{\n-\t  unsigned int i = 0;\n-\t  fprintf_filtered (stream, \"{\");\n-\t  /* If this is a virtual function table, print the 0th\n-\t     entry specially, and the rest of the members\n-\t     normally.  */\n-\t  if (cp_is_vtbl_ptr_type (elttype))\n-\t    {\n-\t      i = 1;\n-\t      fprintf_filtered (stream, _(\"%d vtable entries\"),\n-\t\t\t\tlen - 1);\n-\t    }\n-\t  val_print_array_elements (type, embedded_offset,\n-\t\t\t\t    address, stream,\n-\t\t\t\t    recurse, original_value, options, i);\n-\t  fprintf_filtered (stream, \"}\");\n-\t}\n-    }\n-  else\n-    {\n-      /* Array of unspecified length: treat like pointer to first elt.  */\n-      print_unpacked_pointer (type, elttype, unresolved_elttype, valaddr,\n-\t\t\t      embedded_offset, address + embedded_offset,\n-\t\t\t      stream, recurse, options);\n-    }\n-}\n-\n /* c_value_print helper for TYPE_CODE_ARRAY.  */\n \n static void\n@@ -431,46 +324,6 @@ c_value_print_array (struct value *val,\n     }\n }\n \n-/* c_val_print helper for TYPE_CODE_PTR.  */\n-\n-static void\n-c_val_print_ptr (struct type *type, const gdb_byte *valaddr,\n-\t\t int embedded_offset, struct ui_file *stream, int recurse,\n-\t\t struct value *original_value,\n-\t\t const struct value_print_options *options)\n-{\n-  struct gdbarch *arch = get_type_arch (type);\n-  int unit_size = gdbarch_addressable_memory_unit_size (arch);\n-\n-  if (options->format && options->format != 's')\n-    {\n-      val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t  original_value, options, 0, stream);\n-    }\n-  else if (options->vtblprint && cp_is_vtbl_ptr_type (type))\n-    {\n-      /* Print the unmangled name if desired.  */\n-      /* Print vtable entry - we only get here if we ARE using\n-\t -fvtable_thunks.  (Otherwise, look under\n-\t TYPE_CODE_STRUCT.)  */\n-      CORE_ADDR addr\n-\t= extract_typed_address (valaddr + embedded_offset, type);\n-      struct gdbarch *gdbarch = get_type_arch (type);\n-\n-      print_function_pointer_address (options, gdbarch, addr, stream);\n-    }\n-  else\n-    {\n-      struct type *unresolved_elttype = TYPE_TARGET_TYPE (type);\n-      struct type *elttype = check_typedef (unresolved_elttype);\n-      CORE_ADDR addr = unpack_pointer (type,\n-\t\t\t\t       valaddr + embedded_offset * unit_size);\n-\n-      print_unpacked_pointer (type, elttype, unresolved_elttype, valaddr,\n-\t\t\t      embedded_offset, addr, stream, recurse, options);\n-    }\n-}\n-\n /* c_value_print_inner helper for TYPE_CODE_PTR.  */\n \n static void\n@@ -508,38 +361,6 @@ c_value_print_ptr (struct value *val, struct ui_file *stream, int recurse,\n     }\n }\n \n-/* c_val_print helper for TYPE_CODE_STRUCT.  */\n-\n-static void\n-c_val_print_struct (struct type *type, const gdb_byte *valaddr,\n-\t\t    int embedded_offset, CORE_ADDR address,\n-\t\t    struct ui_file *stream, int recurse,\n-\t\t    struct value *original_value,\n-\t\t    const struct value_print_options *options)\n-{\n-  if (options->vtblprint && cp_is_vtbl_ptr_type (type))\n-    {\n-      /* Print the unmangled name if desired.  */\n-      /* Print vtable entry - we only get here if NOT using\n-\t -fvtable_thunks.  (Otherwise, look under\n-\t TYPE_CODE_PTR.)  */\n-      struct gdbarch *gdbarch = get_type_arch (type);\n-      int offset = (embedded_offset\n-\t\t    + TYPE_FIELD_BITPOS (type,\n-\t\t\t\t\t VTBL_FNADDR_OFFSET) / 8);\n-      struct type *field_type = TYPE_FIELD_TYPE (type, VTBL_FNADDR_OFFSET);\n-      CORE_ADDR addr = extract_typed_address (valaddr + offset, field_type);\n-\n-      print_function_pointer_address (options, gdbarch, addr, stream);\n-    }\n-  else\n-    cp_print_value_fields_rtti (type, valaddr,\n-\t\t\t\tembedded_offset, address,\n-\t\t\t\tstream, recurse,\n-\t\t\t\toriginal_value, options,\n-\t\t\t\tNULL, 0);\n-}\n-\n /* c_value_print helper for TYPE_CODE_STRUCT and TYPE_CODE_UNION.  */\n \n static void\n@@ -568,64 +389,6 @@ c_value_print_struct (struct value *val, struct ui_file *stream, int recurse,\n     cp_print_value_fields (val, stream, recurse, options, NULL, 0);\n }\n \n-/* c_val_print helper for TYPE_CODE_UNION.  */\n-\n-static void\n-c_val_print_union (struct type *type, const gdb_byte *valaddr,\n-\t\t   int embedded_offset, CORE_ADDR address,\n-\t\t   struct ui_file *stream, int recurse,\n-\t\t   struct value *original_value,\n-\t\t   const struct value_print_options *options)\n-{\n-  if (recurse && !options->unionprint)\n-    {\n-      fprintf_filtered (stream, \"{...}\");\n-     }\n-  else\n-    {\n-      c_val_print_struct (type, valaddr, embedded_offset, address, stream,\n-\t\t\t  recurse, original_value, options);\n-    }\n-}\n-\n-/* c_val_print helper for TYPE_CODE_INT.  */\n-\n-static void\n-c_val_print_int (struct type *type, struct type *unresolved_type,\n-\t\t const gdb_byte *valaddr, int embedded_offset,\n-\t\t struct ui_file *stream, struct value *original_value,\n-\t\t const struct value_print_options *options)\n-{\n-  struct gdbarch *arch = get_type_arch (type);\n-  int unit_size = gdbarch_addressable_memory_unit_size (arch);\n-\n-  if (options->format || options->output_format)\n-    {\n-      struct value_print_options opts = *options;\n-\n-      opts.format = (options->format ? options->format\n-\t\t     : options->output_format);\n-      val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t  original_value, &opts, 0, stream);\n-    }\n-  else\n-    {\n-      val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t  original_value, options, 0, stream);\n-      /* C and C++ has no single byte int type, char is used\n-\t instead.  Since we don't know whether the value is really\n-\t intended to be used as an integer or a character, print\n-\t the character equivalent as well.  */\n-      if (c_textual_element_type (unresolved_type, options->format))\n-\t{\n-\t  fputs_filtered (\" \", stream);\n-\t  LA_PRINT_CHAR (unpack_long (type,\n-\t\t\t\t      valaddr + embedded_offset * unit_size),\n-\t\t\t unresolved_type, stream);\n-\t}\n-    }\n-}\n-\n /* c_value_print helper for TYPE_CODE_INT.  */\n \n static void\n@@ -657,26 +420,6 @@ c_value_print_int (struct value *val, struct ui_file *stream,\n     }\n }\n \n-/* c_val_print helper for TYPE_CODE_MEMBERPTR.  */\n-\n-static void\n-c_val_print_memberptr (struct type *type, const gdb_byte *valaddr,\n-\t\t       int embedded_offset, CORE_ADDR address,\n-\t\t       struct ui_file *stream, int recurse,\n-\t\t       struct value *original_value,\n-\t\t       const struct value_print_options *options)\n-{\n-  if (!options->format)\n-    {\n-      cp_print_class_member (valaddr + embedded_offset, type, stream, \"&\");\n-    }\n-  else\n-    {\n-      generic_val_print (type, embedded_offset, address, stream,\n-\t\t\t recurse, original_value, options, &c_decorations);\n-    }\n-}\n-\n /* c_value_print helper for TYPE_CODE_MEMBERPTR.  */\n \n static void\n@@ -694,79 +437,6 @@ c_value_print_memberptr (struct value *val, struct ui_file *stream,\n     generic_value_print (val, stream, recurse, options, &c_decorations);\n }\n \n-/* See val_print for a description of the various parameters of this\n-   function; they are identical.  */\n-\n-void\n-c_val_print (struct type *type,\n-\t     int embedded_offset, CORE_ADDR address,\n-\t     struct ui_file *stream, int recurse,\n-\t     struct value *original_value,\n-\t     const struct value_print_options *options)\n-{\n-  struct type *unresolved_type = type;\n-  const gdb_byte *valaddr = value_contents_for_printing (original_value);\n-\n-  type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n-    {\n-    case TYPE_CODE_ARRAY:\n-      c_val_print_array (type, valaddr, embedded_offset, address, stream,\n-\t\t\t recurse, original_value, options);\n-      break;\n-\n-    case TYPE_CODE_METHODPTR:\n-      cplus_print_method_ptr (valaddr + embedded_offset, type, stream);\n-      break;\n-\n-    case TYPE_CODE_PTR:\n-      c_val_print_ptr (type, valaddr, embedded_offset, stream, recurse,\n-\t\t       original_value, options);\n-      break;\n-\n-    case TYPE_CODE_UNION:\n-      c_val_print_union (type, valaddr, embedded_offset, address, stream,\n-\t\t\t recurse, original_value, options);\n-      break;\n-\n-    case TYPE_CODE_STRUCT:\n-      c_val_print_struct (type, valaddr, embedded_offset, address, stream,\n-\t\t\t  recurse, original_value, options);\n-      break;\n-\n-    case TYPE_CODE_INT:\n-      c_val_print_int (type, unresolved_type, valaddr, embedded_offset, stream,\n-\t\t       original_value, options);\n-      break;\n-\n-    case TYPE_CODE_MEMBERPTR:\n-      c_val_print_memberptr (type, valaddr, embedded_offset, address, stream,\n-\t\t\t     recurse, original_value, options);\n-      break;\n-\n-    case TYPE_CODE_REF:\n-    case TYPE_CODE_RVALUE_REF:\n-    case TYPE_CODE_ENUM:\n-    case TYPE_CODE_FLAGS:\n-    case TYPE_CODE_FUNC:\n-    case TYPE_CODE_METHOD:\n-    case TYPE_CODE_BOOL:\n-    case TYPE_CODE_RANGE:\n-    case TYPE_CODE_FLT:\n-    case TYPE_CODE_DECFLOAT:\n-    case TYPE_CODE_VOID:\n-    case TYPE_CODE_ERROR:\n-    case TYPE_CODE_UNDEF:\n-    case TYPE_CODE_COMPLEX:\n-    case TYPE_CODE_CHAR:\n-    default:\n-      generic_val_print (type, embedded_offset, address,\n-\t\t\t stream, recurse, original_value, options,\n-\t\t\t &c_decorations);\n-      break;\n-    }\n-}\n-\n /* See c-lang.h.  */\n \n void"
    },
    {
      "sha": "5625a58ee750d0e3051b3c35dd5082a40f8e3dc7",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 511,
      "changes": 514,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -47,13 +47,6 @@ static void cp_print_static_field (struct type *, struct value *,\n \t\t\t\t   struct ui_file *, int,\n \t\t\t\t   const struct value_print_options *);\n \n-static void cp_print_value (struct type *, struct type *,\n-\t\t\t    LONGEST,\n-\t\t\t    CORE_ADDR, struct ui_file *,\n-\t\t\t    int, struct value *,\n-\t\t\t    const struct value_print_options *,\n-\t\t\t    struct type **);\n-\n static void cp_print_value (struct value *, struct ui_file *,\n \t\t\t    int, const struct value_print_options *,\n \t\t\t    struct type **);\n@@ -124,287 +117,6 @@ cp_is_vtbl_member (struct type *type)\n    DONT_PRINT is an array of baseclass types that we should not print,\n    or zero if called from top level.  */\n \n-void\n-cp_print_value_fields (struct type *type, struct type *real_type,\n-\t\t       LONGEST offset,\n-\t\t       CORE_ADDR address, struct ui_file *stream,\n-\t\t       int recurse, struct value *val,\n-\t\t       const struct value_print_options *options,\n-\t\t       struct type **dont_print_vb,\n-\t\t       int dont_print_statmem)\n-{\n-  int i, len, n_baseclasses;\n-  int fields_seen = 0;\n-  static int last_set_recurse = -1;\n-\n-  type = check_typedef (type);\n-  \n-  if (recurse == 0)\n-    {\n-      /* Any object can be left on obstacks only during an unexpected\n-\t error.  */\n-\n-      if (obstack_object_size (&dont_print_statmem_obstack) > 0)\n-\t{\n-\t  obstack_free (&dont_print_statmem_obstack, NULL);\n-\t  obstack_begin (&dont_print_statmem_obstack,\n-\t\t\t 32 * sizeof (CORE_ADDR));\n-\t}\n-      if (obstack_object_size (&dont_print_stat_array_obstack) > 0)\n-\t{\n-\t  obstack_free (&dont_print_stat_array_obstack, NULL);\n-\t  obstack_begin (&dont_print_stat_array_obstack,\n-\t\t\t 32 * sizeof (struct type *));\n-\t}\n-    }\n-\n-  fprintf_filtered (stream, \"{\");\n-  len = TYPE_NFIELDS (type);\n-  n_baseclasses = TYPE_N_BASECLASSES (type);\n-\n-  /* First, print out baseclasses such that we don't print\n-     duplicates of virtual baseclasses.  */\n-\n-  if (n_baseclasses > 0)\n-    cp_print_value (type, real_type,\n-\t\t    offset, address, stream,\n-\t\t    recurse + 1, val, options,\n-\t\t    dont_print_vb);\n-\n-  /* Second, print out data fields */\n-\n-  /* If there are no data fields, skip this part */\n-  if (len == n_baseclasses || !len)\n-    fprintf_styled (stream, metadata_style.style (), \"<No data fields>\");\n-  else\n-    {\n-      size_t statmem_obstack_initial_size = 0;\n-      size_t stat_array_obstack_initial_size = 0;\n-      struct type *vptr_basetype = NULL;\n-      int vptr_fieldno;\n-\n-      if (dont_print_statmem == 0)\n-\t{\n-\t  statmem_obstack_initial_size =\n-\t    obstack_object_size (&dont_print_statmem_obstack);\n-\n-\t  if (last_set_recurse != recurse)\n-\t    {\n-\t      stat_array_obstack_initial_size =\n-\t\tobstack_object_size (&dont_print_stat_array_obstack);\n-\n-\t      last_set_recurse = recurse;\n-\t    }\n-\t}\n-\n-      vptr_fieldno = get_vptr_fieldno (type, &vptr_basetype);\n-      for (i = n_baseclasses; i < len; i++)\n-\t{\n-\t  const gdb_byte *valaddr = value_contents_for_printing (val);\n-\n-\t  /* If requested, skip printing of static fields.  */\n-\t  if (!options->static_field_print\n-\t      && field_is_static (&TYPE_FIELD (type, i)))\n-\t    continue;\n-\n-\t  if (fields_seen)\n-\t    {\n-\t      fputs_filtered (\",\", stream);\n-\t      if (!options->prettyformat)\n-\t\tfputs_filtered (\" \", stream);\n-\t    }\n-\t  else if (n_baseclasses > 0)\n-\t    {\n-\t      if (options->prettyformat)\n-\t\t{\n-\t\t  fprintf_filtered (stream, \"\\n\");\n-\t\t  print_spaces_filtered (2 + 2 * recurse, stream);\n-\t\t  fputs_filtered (\"members of \", stream);\n-\t\t  fputs_filtered (TYPE_NAME (type), stream);\n-\t\t  fputs_filtered (\":\", stream);\n-\t\t}\n-\t    }\n-\t  fields_seen = 1;\n-\n-\t  if (options->prettyformat)\n-\t    {\n-\t      fprintf_filtered (stream, \"\\n\");\n-\t      print_spaces_filtered (2 + 2 * recurse, stream);\n-\t    }\n-\t  else\n-\t    {\n-\t      wrap_here (n_spaces (2 + 2 * recurse));\n-\t    }\n-\n-\t  annotate_field_begin (TYPE_FIELD_TYPE (type, i));\n-\n-\t  if (field_is_static (&TYPE_FIELD (type, i)))\n-\t    {\n-\t      fputs_filtered (\"static \", stream);\n-\t      fprintf_symbol_filtered (stream,\n-\t\t\t\t       TYPE_FIELD_NAME (type, i),\n-\t\t\t\t       current_language->la_language,\n-\t\t\t\t       DMGL_PARAMS | DMGL_ANSI);\n-\t    }\n-\t  else\n-\t    fputs_styled (TYPE_FIELD_NAME (type, i),\n-\t\t\t  variable_name_style.style (), stream);\n-\t  annotate_field_name_end ();\n-\n-\t  /* We tweak various options in a few cases below.  */\n-\t  value_print_options options_copy = *options;\n-\t  value_print_options *opts = &options_copy;\n-\n-\t  /* Do not print leading '=' in case of anonymous\n-\t     unions.  */\n-\t  if (strcmp (TYPE_FIELD_NAME (type, i), \"\"))\n-\t    fputs_filtered (\" = \", stream);\n-\t  else\n-\t    {\n-\t      /* If this is an anonymous field then we want to consider it\n-\t\t as though it is at its parent's depth when it comes to the\n-\t\t max print depth.  */\n-\t      if (opts->max_depth != -1 && opts->max_depth < INT_MAX)\n-\t\t++opts->max_depth;\n-\t    }\n-\t  annotate_field_value ();\n-\n-\t  if (!field_is_static (&TYPE_FIELD (type, i))\n-\t      && TYPE_FIELD_PACKED (type, i))\n-\t    {\n-\t      struct value *v;\n-\n-\t      /* Bitfields require special handling, especially due to\n-\t         byte order problems.  */\n-\t      if (TYPE_FIELD_IGNORE (type, i))\n-\t\t{\n-\t\t  fputs_styled (\"<optimized out or zero length>\",\n-\t\t\t\tmetadata_style.style (), stream);\n-\t\t}\n-\t      else if (value_bits_synthetic_pointer (val,\n-\t\t\t\t\t\t     TYPE_FIELD_BITPOS (type,\n-\t\t\t\t\t\t\t\t\ti),\n-\t\t\t\t\t\t     TYPE_FIELD_BITSIZE (type,\n-\t\t\t\t\t\t\t\t\t i)))\n-\t\t{\n-\t\t  fputs_styled (_(\"<synthetic pointer>\"),\n-\t\t\t\tmetadata_style.style (), stream);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  opts->deref_ref = 0;\n-\n-\t\t  v = value_field_bitfield (type, i, valaddr, offset, val);\n-\n-\t\t  common_val_print (v, stream, recurse + 1,\n-\t\t\t\t    opts, current_language);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TYPE_FIELD_IGNORE (type, i))\n-\t\t{\n-\t\t  fputs_styled (\"<optimized out or zero length>\",\n-\t\t\t\tmetadata_style.style (), stream);\n-\t\t}\n-\t      else if (field_is_static (&TYPE_FIELD (type, i)))\n-\t\t{\n-\t\t  try\n-\t\t    {\n-\t\t      struct value *v = value_static_field (type, i);\n-\n-\t\t      cp_print_static_field (TYPE_FIELD_TYPE (type, i),\n-\t\t\t\t\t     v, stream, recurse + 1,\n-\t\t\t\t\t     opts);\n-\t\t    }\n-\t\t  catch (const gdb_exception_error &ex)\n-\t\t    {\n-\t\t      fprintf_styled (stream, metadata_style.style (),\n-\t\t\t\t      _(\"<error reading variable: %s>\"),\n-\t\t\t\t      ex.what ());\n-\t\t    }\n-\t\t}\n-\t      else if (i == vptr_fieldno && type == vptr_basetype)\n-\t\t{\n-\t\t  int i_offset = offset + TYPE_FIELD_BITPOS (type, i) / 8;\n-\t\t  struct type *i_type = TYPE_FIELD_TYPE (type, i);\n-\n-\t\t  if (valprint_check_validity (stream, i_type, i_offset, val))\n-\t\t    {\n-\t\t      CORE_ADDR addr;\n-\t\t      \n-\t\t      i_offset += value_embedded_offset (val);\n-\t\t      addr = extract_typed_address (valaddr + i_offset, i_type);\n-\t\t      print_function_pointer_address (opts,\n-\t\t\t\t\t\t      get_type_arch (type),\n-\t\t\t\t\t\t      addr, stream);\n-\t\t    }\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  opts->deref_ref = 0;\n-\t\t  val_print (TYPE_FIELD_TYPE (type, i),\n-\t\t\t     offset + TYPE_FIELD_BITPOS (type, i) / 8,\n-\t\t\t     address,\n-\t\t\t     stream, recurse + 1, val, opts,\n-\t\t\t     current_language);\n-\t\t}\n-\t    }\n-\t  annotate_field_end ();\n-\t}\n-\n-      if (dont_print_statmem == 0)\n-\t{\n-\t  size_t obstack_final_size =\n-           obstack_object_size (&dont_print_statmem_obstack);\n-\n-\t  if (obstack_final_size > statmem_obstack_initial_size)\n-\t    {\n-\t      /* In effect, a pop of the printed-statics stack.  */\n-\t      size_t shrink_bytes\n-\t\t= statmem_obstack_initial_size - obstack_final_size;\n-\t      obstack_blank_fast (&dont_print_statmem_obstack, shrink_bytes);\n-\t    }\n-\n-\t  if (last_set_recurse != recurse)\n-\t    {\n-\t      obstack_final_size =\n-\t\tobstack_object_size (&dont_print_stat_array_obstack);\n-\t      \n-\t      if (obstack_final_size > stat_array_obstack_initial_size)\n-\t\t{\n-\t\t  void *free_to_ptr =\n-\t\t    (char *) obstack_next_free (&dont_print_stat_array_obstack)\n-\t\t    - (obstack_final_size\n-\t\t       - stat_array_obstack_initial_size);\n-\n-\t\t  obstack_free (&dont_print_stat_array_obstack,\n-\t\t\t\tfree_to_ptr);\n-\t\t}\n-\t      last_set_recurse = -1;\n-\t    }\n-\t}\n-\n-      if (options->prettyformat)\n-\t{\n-\t  fprintf_filtered (stream, \"\\n\");\n-\t  print_spaces_filtered (2 * recurse, stream);\n-\t}\n-    }\t\t\t\t/* if there are data fields */\n-\n-  fprintf_filtered (stream, \"}\");\n-}\n-\n-/* Mutually recursive subroutines of cp_print_value and c_value_print\n-   to print out a structure's fields: cp_print_value_fields and\n-   cp_print_value.\n-\n-   VAL, ADDRESS, STREAM, RECURSE, and OPTIONS have the same meanings\n-   as in cp_print_value and c_value_print.\n-\n-   DONT_PRINT is an array of baseclass types that we should not print,\n-   or zero if called from top level.  */\n-\n void\n cp_print_value_fields (struct value *val, struct ui_file *stream,\n \t\t       int recurse, const struct value_print_options *options,\n@@ -669,222 +381,6 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n   fprintf_filtered (stream, \"}\");\n }\n \n-/* Like cp_print_value_fields, but find the runtime type of the object\n-   and pass it as the `real_type' argument to cp_print_value_fields.\n-   This function is a hack to work around the fact that\n-   common_val_print passes the embedded offset to val_print, but not\n-   the enclosing type.  */\n-\n-void\n-cp_print_value_fields_rtti (struct type *type,\n-\t\t\t    const gdb_byte *valaddr, LONGEST offset,\n-\t\t\t    CORE_ADDR address,\n-\t\t\t    struct ui_file *stream, int recurse,\n-\t\t\t    struct value *val,\n-\t\t\t    const struct value_print_options *options,\n-\t\t\t    struct type **dont_print_vb, \n-\t\t\t    int dont_print_statmem)\n-{\n-  struct type *real_type = NULL;\n-\n-  /* We require all bits to be valid in order to attempt a\n-     conversion.  */\n-  if (!value_bits_any_optimized_out (val,\n-\t\t\t\t     TARGET_CHAR_BIT * offset,\n-\t\t\t\t     TARGET_CHAR_BIT * TYPE_LENGTH (type)))\n-    {\n-      struct value *value;\n-      int full, using_enc;\n-      LONGEST top;\n-\n-      /* Ugh, we have to convert back to a value here.  */\n-      value = value_from_contents_and_address (type, valaddr + offset,\n-\t\t\t\t\t       address + offset);\n-      type = value_type (value);\n-      /* We don't actually care about most of the result here -- just\n-\t the type.  We already have the correct offset, due to how\n-\t val_print was initially called.  */\n-      real_type = value_rtti_type (value, &full, &top, &using_enc);\n-    }\n-\n-  if (!real_type)\n-    real_type = type;\n-\n-  cp_print_value_fields (type, real_type, offset,\n-\t\t\t address, stream, recurse, val, options,\n-\t\t\t dont_print_vb, dont_print_statmem);\n-}\n-\n-/* Special value_print routine to avoid printing multiple copies of\n-   virtual baseclasses.  */\n-\n-static void\n-cp_print_value (struct type *type, struct type *real_type,\n-\t\tLONGEST offset,\n-\t\tCORE_ADDR address, struct ui_file *stream,\n-\t\tint recurse, struct value *val,\n-\t\tconst struct value_print_options *options,\n-\t\tstruct type **dont_print_vb)\n-{\n-  struct type **last_dont_print\n-    = (struct type **) obstack_next_free (&dont_print_vb_obstack);\n-  struct obstack tmp_obstack = dont_print_vb_obstack;\n-  int i, n_baseclasses = TYPE_N_BASECLASSES (type);\n-  LONGEST thisoffset;\n-  struct type *thistype;\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n-\n-  if (dont_print_vb == 0)\n-    {\n-      /* If we're at top level, carve out a completely fresh chunk of\n-         the obstack and use that until this particular invocation\n-         returns.  */\n-      /* Bump up the high-water mark.  Now alpha is omega.  */\n-      obstack_finish (&dont_print_vb_obstack);\n-    }\n-\n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      LONGEST boffset = 0;\n-      int skip = 0;\n-      struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));\n-      const char *basename = TYPE_NAME (baseclass);\n-      struct value *base_val = NULL;\n-\n-      if (BASETYPE_VIA_VIRTUAL (type, i))\n-\t{\n-\t  struct type **first_dont_print\n-\t    = (struct type **) obstack_base (&dont_print_vb_obstack);\n-\n-\t  int j = (struct type **)\n-\t    obstack_next_free (&dont_print_vb_obstack) - first_dont_print;\n-\n-\t  while (--j >= 0)\n-\t    if (baseclass == first_dont_print[j])\n-\t      goto flush_it;\n-\n-\t  obstack_ptr_grow (&dont_print_vb_obstack, baseclass);\n-\t}\n-\n-      thisoffset = offset;\n-      thistype = real_type;\n-\n-      try\n-\t{\n-\t  boffset = baseclass_offset (type, i, valaddr, offset, address, val);\n-\t}\n-      catch (const gdb_exception_error &ex)\n-\t{\n-\t  if (ex.error == NOT_AVAILABLE_ERROR)\n-\t    skip = -1;\n-\t  else\n-\t    skip = 1;\n-\t}\n-\n-      if (skip == 0)\n-\t{\n-\t  if (BASETYPE_VIA_VIRTUAL (type, i))\n-\t    {\n-\t      /* The virtual base class pointer might have been\n-\t\t clobbered by the user program. Make sure that it\n-\t\t still points to a valid memory location.  */\n-\n-\t      if ((boffset + offset) < 0\n-\t\t  || (boffset + offset) >= TYPE_LENGTH (real_type))\n-\t\t{\n-\t\t  gdb::byte_vector buf (TYPE_LENGTH (baseclass));\n-\n-\t\t  if (target_read_memory (address + boffset, buf.data (),\n-\t\t\t\t\t  TYPE_LENGTH (baseclass)) != 0)\n-\t\t    skip = 1;\n-\t\t  base_val = value_from_contents_and_address (baseclass,\n-\t\t\t\t\t\t\t      buf.data (),\n-\t\t\t\t\t\t\t      address + boffset);\n-\t\t  baseclass = value_type (base_val);\n-\t\t  thisoffset = 0;\n-\t\t  boffset = 0;\n-\t\t  thistype = baseclass;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  base_val = val;\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      base_val = val;\n-\t    }\n-\t}\n-\n-      /* Now do the printing.  */\n-      if (options->prettyformat)\n-\t{\n-\t  fprintf_filtered (stream, \"\\n\");\n-\t  print_spaces_filtered (2 * recurse, stream);\n-\t}\n-      fputs_filtered (\"<\", stream);\n-      /* Not sure what the best notation is in the case where there is\n-         no baseclass name.  */\n-      fputs_filtered (basename ? basename : \"\", stream);\n-      fputs_filtered (\"> = \", stream);\n-\n-      if (skip < 0)\n-\tval_print_unavailable (stream);\n-      else if (skip > 0)\n-\tval_print_invalid_address (stream);\n-      else\n-\t{\n-\t  int result = 0;\n-\n-\t  if (options->max_depth > -1\n-\t      && recurse >= options->max_depth)\n-\t    {\n-\t      const struct language_defn *language = current_language;\n-\t      gdb_assert (language->la_struct_too_deep_ellipsis != NULL);\n-\t      fputs_filtered (language->la_struct_too_deep_ellipsis, stream);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Attempt to run an extension language pretty-printer on the\n-\t\t baseclass if possible.  */\n-\t      if (!options->raw)\n-\t\t{\n-\t\t  struct value *v\n-\t\t    = value_from_component (base_val, baseclass,\n-\t\t\t\t\t    thisoffset + boffset);\n-\t\t  result\n-\t\t    = apply_ext_lang_val_pretty_printer (v, stream, recurse,\n-\t\t\t\t\t\t\t options,\n-\t\t\t\t\t\t\t current_language);\n-\t\t}\n-\n-\t      if (!result)\n-\t\tcp_print_value_fields (baseclass, thistype,\n-\t\t\t\t       thisoffset + boffset,\n-\t\t\t\t       value_address (base_val),\n-\t\t\t\t       stream, recurse, base_val, options,\n-\t\t\t\t       ((struct type **)\n-\t\t\t\t\tobstack_base (&dont_print_vb_obstack)),\n-\t\t\t\t       0);\n-\t    }\n-\t}\n-      fputs_filtered (\", \", stream);\n-\n-    flush_it:\n-      ;\n-    }\n-\n-  if (dont_print_vb == 0)\n-    {\n-      /* Free the space used to deal with the printing\n-         of this type from top level.  */\n-      obstack_free (&dont_print_vb_obstack, last_dont_print);\n-      /* Reset watermark so that we can continue protecting\n-         ourselves from whatever we were protecting ourselves.  */\n-      dont_print_vb_obstack = tmp_obstack;\n-    }\n-}\n-\n /* Special val_print routine to avoid printing multiple copies of\n    virtual baseclasses.  */\n \n@@ -1070,7 +566,7 @@ cp_print_static_field (struct type *type,\n   if (TYPE_CODE (real_type) == TYPE_CODE_STRUCT)\n     {\n       CORE_ADDR *first_dont_print;\n-      CORE_ADDR addr;\n+      CORE_ADDR addr = value_address (val);\n       int i;\n \n       first_dont_print\n@@ -1080,7 +576,7 @@ cp_print_static_field (struct type *type,\n \n       while (--i >= 0)\n \t{\n-\t  if (value_address (val) == first_dont_print[i])\n+\t  if (addr == first_dont_print[i])\n \t    {\n \t      fputs_styled (_(\"<same as static member of an already\"\n \t\t\t      \" seen type>\"),\n@@ -1089,13 +585,9 @@ cp_print_static_field (struct type *type,\n \t    }\n \t}\n \n-      addr = value_address (val);\n       obstack_grow (&dont_print_statmem_obstack, (char *) &addr,\n \t\t    sizeof (CORE_ADDR));\n-      cp_print_value_fields (type, value_enclosing_type (val),\n-\t\t\t     value_embedded_offset (val), addr,\n-\t\t\t     stream, recurse, val,\n-\t\t\t     options, NULL, 1);\n+      cp_print_value_fields (val, stream, recurse, options, NULL, 1);\n       return;\n     }\n "
    },
    {
      "sha": "f50c31a018eb0ba89af97e66d4f2dbc3fc214631",
      "filename": "gdb/d-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/d-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/d-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -224,7 +224,6 @@ extern const struct language_defn d_language_defn =\n   c_print_type,\t\t\t/* Print a type using appropriate syntax.  */\n   c_print_typedef,\t\t/* Print a typedef using appropriate\n \t\t\t\t   syntax.  */\n-  d_val_print,\t\t\t/* Print a value using appropriate syntax.  */\n   d_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value.  */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "a0319f1a48fe9ff3a051673012f3af56aa35a681",
      "filename": "gdb/d-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/d-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/d-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-lang.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -76,14 +76,6 @@ extern struct block_symbol d_lookup_symbol_nonlocal (const struct language_defn\n extern struct block_symbol d_lookup_nested_symbol (struct type *, const char *,\n \t\t\t\t\t\t   const struct block *);\n \n-/* Defined in d-valprint.c  */\n-\n-extern void d_val_print (struct type *type,\n-\t\t\t int embedded_offset, CORE_ADDR address,\n-\t\t\t struct ui_file *stream, int recurse,\n-\t\t\t struct value *val,\n-\t\t\t const struct value_print_options *options);\n-\n /* Implement la_value_print_inner for D.  */\n \n extern void d_value_print_inner (struct value *val,"
    },
    {
      "sha": "109049cd1dea7ca5f00bd0e5b7e147e43ae51ca4",
      "filename": "gdb/d-valprint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 24,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/d-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/d-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -69,30 +69,6 @@ dynamic_array_type (struct type *type,\n   return 1;\n }\n \n-/* Implements the la_val_print routine for language D.  */\n-void\n-d_val_print (struct type *type, int embedded_offset,\n-             CORE_ADDR address, struct ui_file *stream, int recurse,\n-\t     struct value *val,\n-             const struct value_print_options *options)\n-{\n-  int ret;\n-\n-  type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n-    {\n-      case TYPE_CODE_STRUCT:\n-\tret = dynamic_array_type (type, embedded_offset, address,\n-\t\t\t\t  stream, recurse, val, options);\n-\tif (ret == 0)\n-\t  break;\n-\t/* Fall through.  */\n-      default:\n-\tc_val_print (type, embedded_offset, address, stream,\n-\t\t     recurse, val, options);\n-    }\n-}\n-\n /* See d-lang.h.  */\n \n void"
    },
    {
      "sha": "75a131d76d8230c128b4b8d860271a13f2abf317",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -646,7 +646,6 @@ extern const struct language_defn f_language_defn =\n   f_emit_char,\t\t\t/* Function to print a single character */\n   f_print_type,\t\t\t/* Print a type using appropriate syntax */\n   f_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  f_val_print,\t\t\t/* Print a value using appropriate syntax */\n   f_value_print_innner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* FIXME */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "84a63a8a410133194f5cb0da83789f250d9771c6",
      "filename": "gdb/f-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/f-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/f-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -36,11 +36,6 @@ extern void f_print_typedef (struct type *type, struct symbol *new_symbol,\n extern void f_print_type (struct type *, const char *, struct ui_file *, int,\n \t\t\t  int, const struct type_print_options *);\n \n-extern void f_val_print (struct type *, int, CORE_ADDR,\n-\t\t\t struct ui_file *, int,\n-\t\t\t struct value *,\n-\t\t\t const struct value_print_options *);\n-\n /* Implement la_value_print_inner for Fortran.  */\n \n extern void f_value_print_innner (struct value *val, struct ui_file *stream,"
    },
    {
      "sha": "36328c796ca3e58ff1b893a581dc081bf13c75e6",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 186,
      "changes": 186,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -208,192 +208,6 @@ static const struct generic_val_print_decorations f_decorations =\n   \"}\"\n };\n \n-/* See val_print for a description of the various parameters of this\n-   function; they are identical.  */\n-\n-void\n-f_val_print (struct type *type, int embedded_offset,\n-\t     CORE_ADDR address, struct ui_file *stream, int recurse,\n-\t     struct value *original_value,\n-\t     const struct value_print_options *options)\n-{\n-  struct gdbarch *gdbarch = get_type_arch (type);\n-  int printed_field = 0; /* Number of fields printed.  */\n-  struct type *elttype;\n-  CORE_ADDR addr;\n-  int index;\n-  const gdb_byte *valaddr =value_contents_for_printing (original_value);\n-\n-  type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n-    {\n-    case TYPE_CODE_STRING:\n-      f77_get_dynamic_length_of_aggregate (type);\n-      LA_PRINT_STRING (stream, builtin_type (gdbarch)->builtin_char,\n-\t\t       valaddr + embedded_offset,\n-\t\t       TYPE_LENGTH (type), NULL, 0, options);\n-      break;\n-\n-    case TYPE_CODE_ARRAY:\n-      if (TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_CHAR)\n-\t{\n-\t  fprintf_filtered (stream, \"(\");\n-\t  f77_print_array (type, valaddr, embedded_offset,\n-\t\t\t   address, stream, recurse, original_value, options);\n-\t  fprintf_filtered (stream, \")\");\n-\t}\n-      else\n-\t{\n-\t  struct type *ch_type = TYPE_TARGET_TYPE (type);\n-\n-\t  f77_get_dynamic_length_of_aggregate (type);\n-\t  LA_PRINT_STRING (stream, ch_type,\n-\t\t\t   valaddr + embedded_offset,\n-\t\t\t   TYPE_LENGTH (type) / TYPE_LENGTH (ch_type),\n-\t\t\t   NULL, 0, options);\n-\t}\n-      break;\n-\n-    case TYPE_CODE_PTR:\n-      if (options->format && options->format != 's')\n-\t{\n-\t  val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t      original_value, options, 0, stream);\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  int want_space = 0;\n-\n-\t  addr = unpack_pointer (type, valaddr + embedded_offset);\n-\t  elttype = check_typedef (TYPE_TARGET_TYPE (type));\n-\n-\t  if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)\n-\t    {\n-\t      /* Try to print what function it points to.  */\n-\t      print_function_pointer_address (options, gdbarch, addr, stream);\n-\t      return;\n-\t    }\n-\n-\t  if (options->symbol_print)\n-\t    want_space = print_address_demangle (options, gdbarch, addr,\n-\t\t\t\t\t\t stream, demangle);\n-\t  else if (options->addressprint && options->format != 's')\n-\t    {\n-\t      fputs_filtered (paddress (gdbarch, addr), stream);\n-\t      want_space = 1;\n-\t    }\n-\n-\t  /* For a pointer to char or unsigned char, also print the string\n-\t     pointed to, unless pointer is null.  */\n-\t  if (TYPE_LENGTH (elttype) == 1\n-\t      && TYPE_CODE (elttype) == TYPE_CODE_INT\n-\t      && (options->format == 0 || options->format == 's')\n-\t      && addr != 0)\n-\t    {\n-\t      if (want_space)\n-\t\tfputs_filtered (\" \", stream);\n-\t      val_print_string (TYPE_TARGET_TYPE (type), NULL, addr, -1,\n-\t\t\t\tstream, options);\n-\t    }\n-\t  return;\n-\t}\n-      break;\n-\n-    case TYPE_CODE_INT:\n-      if (options->format || options->output_format)\n-\t{\n-\t  struct value_print_options opts = *options;\n-\n-\t  opts.format = (options->format ? options->format\n-\t\t\t : options->output_format);\n-\t  val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t      original_value, &opts, 0, stream);\n-\t}\n-      else\n-\tval_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t    original_value, options, 0, stream);\n-      break;\n-\n-    case TYPE_CODE_STRUCT:\n-    case TYPE_CODE_UNION:\n-      /* Starting from the Fortran 90 standard, Fortran supports derived\n-         types.  */\n-      fprintf_filtered (stream, \"( \");\n-      for (index = 0; index < TYPE_NFIELDS (type); index++)\n-        {\n-\t  struct value *field = value_field\n-\t    ((struct value *)original_value, index);\n-\n-\t  struct type *field_type = check_typedef (TYPE_FIELD_TYPE (type, index));\n-\n-\n-\t  if (TYPE_CODE (field_type) != TYPE_CODE_FUNC)\n-\t    {\n-\t      const char *field_name;\n-\n-\t      if (printed_field > 0)\n-\t\tfputs_filtered (\", \", stream);\n-\n-\t      field_name = TYPE_FIELD_NAME (type, index);\n-\t      if (field_name != NULL)\n-\t\t{\n-\t\t  fputs_styled (field_name, variable_name_style.style (),\n-\t\t\t\tstream);\n-\t\t  fputs_filtered (\" = \", stream);\n-\t\t}\n-\n-\t      common_val_print (field, stream, recurse + 1,\n-\t\t\t\toptions, current_language);\n-\n-\t      ++printed_field;\n-\t    }\n-\t }\n-      fprintf_filtered (stream, \" )\");\n-      break;     \n-\n-    case TYPE_CODE_BOOL:\n-      if (options->format || options->output_format)\n-\t{\n-\t  struct value_print_options opts = *options;\n-\t  opts.format = (options->format ? options->format\n-\t\t\t : options->output_format);\n-\t  val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t      original_value, &opts, 0, stream);\n-\t}\n-      else\n-\t{\n-\t  int unit_size = gdbarch_addressable_memory_unit_size (gdbarch);\n-\t  LONGEST val\n-\t    = unpack_long (type, valaddr + embedded_offset * unit_size);\n-\t  /* The Fortran standard doesn't specify how logical types are\n-\t     represented.  Different compilers use different non zero\n-\t     values to represent logical true.  */\n-\t  if (val == 0)\n-\t    fputs_filtered (f_decorations.false_name, stream);\n-\t  else\n-\t    fputs_filtered (f_decorations.true_name, stream);\n-\t}\n-      break;\n-\n-    case TYPE_CODE_REF:\n-    case TYPE_CODE_FUNC:\n-    case TYPE_CODE_FLAGS:\n-    case TYPE_CODE_FLT:\n-    case TYPE_CODE_VOID:\n-    case TYPE_CODE_ERROR:\n-    case TYPE_CODE_RANGE:\n-    case TYPE_CODE_UNDEF:\n-    case TYPE_CODE_COMPLEX:\n-    case TYPE_CODE_CHAR:\n-    default:\n-      generic_val_print (type, embedded_offset, address,\n-\t\t\t stream, recurse, original_value, options,\n-\t\t\t &f_decorations);\n-      break;\n-    }\n-}\n-\n /* See f-lang.h.  */\n \n void"
    },
    {
      "sha": "53e342963d911df54cd3343b7d2f61b0c15d1ef3",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -595,7 +595,6 @@ extern const struct language_defn go_language_defn =\n   go_print_type,\t\t/* Print a type using appropriate syntax.  */\n   c_print_typedef,\t\t/* Print a typedef using appropriate\n \t\t\t\t   syntax.  */\n-  go_val_print,\t\t\t/* Print a value using appropriate syntax.  */\n   go_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value.  */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "1f0790719950fd39b340314f31c706c45c5051f5",
      "filename": "gdb/go-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/go-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/go-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -80,14 +80,6 @@ extern void go_print_type (struct type *type, const char *varstring,\n \t\t\t   struct ui_file *stream, int show, int level,\n \t\t\t   const struct type_print_options *flags);\n \n-/* Defined in go-valprint.c.  */\n-\n-extern void go_val_print (struct type *type,\n-\t\t\t  int embedded_offset, CORE_ADDR address,\n-\t\t\t  struct ui_file *stream, int recurse,\n-\t\t\t  struct value *val,\n-\t\t\t  const struct value_print_options *options);\n-\n /* Implement la_value_print_inner for Go.  */\n \n extern void go_value_print_inner (struct value *value,"
    },
    {
      "sha": "fe2ee46ef1d565588cf22ef060f3392c02776684",
      "filename": "gdb/go-valprint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 39,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/go-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/go-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -84,45 +84,6 @@ print_go_string (struct type *type,\n   val_print_string (elt_type, NULL, addr, length, stream, options);\n }\n \n-/* Implements the la_val_print routine for language Go.  */\n-\n-void\n-go_val_print (struct type *type, int embedded_offset,\n-\t      CORE_ADDR address, struct ui_file *stream, int recurse,\n-\t      struct value *val,\n-\t      const struct value_print_options *options)\n-{\n-  type = check_typedef (type);\n-\n-  switch (TYPE_CODE (type))\n-    {\n-      case TYPE_CODE_STRUCT:\n-\t{\n-\t  enum go_type go_type = go_classify_struct_type (type);\n-\n-\t  switch (go_type)\n-\t    {\n-\t    case GO_TYPE_STRING:\n-\t      if (! options->raw)\n-\t\t{\n-\t\t  print_go_string (type, embedded_offset, address,\n-\t\t\t\t   stream, recurse, val, options);\n-\t\t  return;\n-\t\t}\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-\t/* Fall through.  */\n-\n-      default:\n-\tc_val_print (type, embedded_offset, address, stream,\n-\t\t     recurse, val, options);\n-\tbreak;\n-    }\n-}\n-\n /* See go-lang.h.  */\n \n void"
    },
    {
      "sha": "454c6dc45a76d187dc6118e9001d08a705409801",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 6,
      "deletions": 10,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -792,14 +792,12 @@ unk_lang_print_type (struct type *type, const char *varstring,\n }\n \n static void\n-unk_lang_val_print (struct type *type,\n-\t\t    int embedded_offset, CORE_ADDR address,\n-\t\t    struct ui_file *stream, int recurse,\n-\t\t    struct value *val,\n-\t\t    const struct value_print_options *options)\n+unk_lang_value_print_inner (struct value *val,\n+\t\t\t    struct ui_file *stream, int recurse,\n+\t\t\t    const struct value_print_options *options)\n {\n   error (_(\"internal error - unimplemented \"\n-\t   \"function unk_lang_val_print called.\"));\n+\t   \"function unk_lang_value_print_inner called.\"));\n }\n \n static void\n@@ -859,8 +857,7 @@ const struct language_defn unknown_language_defn =\n   unk_lang_emit_char,\n   unk_lang_print_type,\t\t/* Print a type using appropriate syntax */\n   default_print_typedef,\t/* Print a typedef using appropriate syntax */\n-  unk_lang_val_print,\t\t/* Print a value using appropriate syntax */\n-  nullptr,\t\t\t/* la_value_print_inner */\n+  unk_lang_value_print_inner,\t/* la_value_print_inner */\n   unk_lang_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */\n   unk_lang_trampoline,\t\t/* Language specific skip_trampoline */\n@@ -911,8 +908,7 @@ const struct language_defn auto_language_defn =\n   unk_lang_emit_char,\n   unk_lang_print_type,\t\t/* Print a type using appropriate syntax */\n   default_print_typedef,\t/* Print a typedef using appropriate syntax */\n-  unk_lang_val_print,\t\t/* Print a value using appropriate syntax */\n-  nullptr,\t\t\t/* la_value_print_inner */\n+  unk_lang_value_print_inner,\t/* la_value_print_inner */\n   unk_lang_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */\n   unk_lang_trampoline,\t\t/* Language specific skip_trampoline */"
    },
    {
      "sha": "ea8aae511b0fbb703a78412f27b8248f5c6810c1",
      "filename": "gdb/language.h",
      "status": "modified",
      "additions": 0,
      "deletions": 24,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/language.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/language.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -248,30 +248,6 @@ struct language_defn\n     void (*la_print_typedef) (struct type *type, struct symbol *new_symbol,\n \t\t\t      struct ui_file *stream);\n \n-    /* Print a value using syntax appropriate for this language.\n-       \n-       TYPE is the type of the sub-object to be printed.\n-\n-       EMBEDDED_OFFSET is the offset into the outermost object of the\n-       sub-object represented by TYPE.  This is the object which this\n-       call should print.  Note that the enclosing type is not\n-       available.\n-\n-       ADDRESS is the address in the inferior of the enclosing object.\n-\n-       STREAM is the stream on which the value is to be printed.\n-\n-       RECURSE is the recursion depth.  It is zero-based.\n-\n-       OPTIONS are the formatting options to be used when\n-       printing.  */\n-\n-    void (*la_val_print) (struct type *type,\n-\t\t\t  int embedded_offset, CORE_ADDR address,\n-\t\t\t  struct ui_file *stream, int recurse,\n-\t\t\t  struct value *val,\n-\t\t\t  const struct value_print_options *options);\n-\n     /* Print a value using syntax appropriate for this language.\n        RECURSE is the recursion depth.  It is zero-based.  */\n "
    },
    {
      "sha": "af3cf3ad85f2847ed3ebea46b7ce017fbf81e0e5",
      "filename": "gdb/m2-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/m2-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/m2-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -393,7 +393,6 @@ extern const struct language_defn m2_language_defn =\n   m2_emit_char,\t\t\t/* Function to print a single character */\n   m2_print_type,\t\t/* Print a type using appropriate syntax */\n   m2_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  m2_val_print,\t\t\t/* Print a value using appropriate syntax */\n   m2_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "de477e58d5abf2b20b73e128d8f0bf117ea8044c",
      "filename": "gdb/m2-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/m2-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/m2-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -35,11 +35,6 @@ extern void m2_print_typedef (struct type *, struct symbol *,\n extern int m2_is_long_set (struct type *type);\n extern int m2_is_unbounded_array (struct type *type);\n \n-extern void m2_val_print (struct type *, int, CORE_ADDR,\n-\t\t\t  struct ui_file *, int,\n-\t\t\t  struct value *,\n-\t\t\t  const struct value_print_options *);\n-\n /* Implement la_value_print_inner for Modula-2.  */\n \n extern void m2_value_print_inner (struct value *, struct ui_file *, int,"
    },
    {
      "sha": "844a63f3bd69a40aa8e015ca4d4e43f0efa672a2",
      "filename": "gdb/m2-valprint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 223,
      "changes": 223,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/m2-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/m2-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -181,31 +181,6 @@ m2_print_unbounded_array (struct value *value,\n   fprintf_filtered (stream, \", HIGH = %d}\", (int) len);\n }\n \n-static void\n-m2_print_unbounded_array (struct type *type, const gdb_byte *valaddr,\n-\t\t\t  int embedded_offset, CORE_ADDR address,\n-\t\t\t  struct ui_file *stream, int recurse,\n-\t\t\t  const struct value_print_options *options)\n-{\n-  CORE_ADDR addr;\n-  LONGEST len;\n-  struct value *val;\n-\n-  type = check_typedef (type);\n-\n-  addr = unpack_pointer (TYPE_FIELD_TYPE (type, 0),\n-\t\t\t (TYPE_FIELD_BITPOS (type, 0) / 8) +\n-\t\t\t valaddr + embedded_offset);\n-\n-  val = value_at_lazy (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type, 0)),\n-\t\t       addr);\n-  len = unpack_field_as_long (type, valaddr + embedded_offset, 1);\n-\n-  fprintf_filtered (stream, \"{\");  \n-  m2_print_array_contents (val, stream, recurse, options, len);\n-  fprintf_filtered (stream, \", HIGH = %d}\", (int) len);\n-}\n-\n static int\n print_unpacked_pointer (struct type *type,\n \t\t\tCORE_ADDR address, CORE_ADDR addr,\n@@ -323,204 +298,6 @@ static const struct generic_val_print_decorations m2_decorations =\n   \"}\"\n };\n \n-/* See val_print for a description of the various parameters of this\n-   function; they are identical.  */\n-\n-void\n-m2_val_print (struct type *type, int embedded_offset,\n-\t      CORE_ADDR address, struct ui_file *stream, int recurse,\n-\t      struct value *original_value,\n-\t      const struct value_print_options *options)\n-{\n-  unsigned len;\n-  struct type *elttype;\n-  CORE_ADDR addr;\n-  const gdb_byte *valaddr = value_contents_for_printing (original_value);\n-\n-  type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n-    {\n-    case TYPE_CODE_ARRAY:\n-      if (TYPE_LENGTH (type) > 0 && TYPE_LENGTH (TYPE_TARGET_TYPE (type)) > 0)\n-\t{\n-\t  elttype = check_typedef (TYPE_TARGET_TYPE (type));\n-\t  len = TYPE_LENGTH (type) / TYPE_LENGTH (elttype);\n-\t  if (options->prettyformat_arrays)\n-\t    print_spaces_filtered (2 + 2 * recurse, stream);\n-\t  /* For an array of chars, print with string syntax.  */\n-\t  if (TYPE_LENGTH (elttype) == 1 &&\n-\t      ((TYPE_CODE (elttype) == TYPE_CODE_INT)\n-\t       || ((current_language->la_language == language_m2)\n-\t\t   && (TYPE_CODE (elttype) == TYPE_CODE_CHAR)))\n-\t      && (options->format == 0 || options->format == 's'))\n-\t    {\n-\t      /* If requested, look for the first null char and only print\n-\t         elements up to it.  */\n-\t      if (options->stop_print_at_null)\n-\t\t{\n-\t\t  unsigned int temp_len;\n-\n-\t\t  /* Look for a NULL char.  */\n-\t\t  for (temp_len = 0;\n-\t\t       (valaddr + embedded_offset)[temp_len]\n-\t\t\t && temp_len < len && temp_len < options->print_max;\n-\t\t       temp_len++);\n-\t\t  len = temp_len;\n-\t\t}\n-\n-\t      LA_PRINT_STRING (stream, TYPE_TARGET_TYPE (type),\n-\t\t\t       valaddr + embedded_offset, len, NULL,\n-\t\t\t       0, options);\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf_filtered (stream, \"{\");\n-\t      val_print_array_elements (type, embedded_offset,\n-\t\t\t\t\taddress, stream,\n-\t\t\t\t\trecurse, original_value,\n-\t\t\t\t\toptions, 0);\n-\t      fprintf_filtered (stream, \"}\");\n-\t    }\n-\t  break;\n-\t}\n-      /* Array of unspecified length: treat like pointer to first elt.  */\n-      print_unpacked_pointer (type, address, address, options, stream);\n-      break;\n-\n-    case TYPE_CODE_PTR:\n-      if (TYPE_CONST (type))\n-\tprint_variable_at_address (type, valaddr + embedded_offset,\n-\t\t\t\t   stream, recurse, options);\n-      else if (options->format && options->format != 's')\n-\tval_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t    original_value, options, 0, stream);\n-      else\n-\t{\n-\t  addr = unpack_pointer (type, valaddr + embedded_offset);\n-\t  print_unpacked_pointer (type, addr, address, options, stream);\n-\t}\n-      break;\n-\n-    case TYPE_CODE_UNION:\n-      if (recurse && !options->unionprint)\n-\t{\n-\t  fprintf_filtered (stream, \"{...}\");\n-\t  break;\n-\t}\n-      /* Fall through.  */\n-    case TYPE_CODE_STRUCT:\n-      if (m2_is_long_set (type))\n-\tm2_print_long_set (type, valaddr, embedded_offset, address,\n-\t\t\t   stream);\n-      else if (m2_is_unbounded_array (type))\n-\tm2_print_unbounded_array (type, valaddr, embedded_offset,\n-\t\t\t\t  address, stream, recurse, options);\n-      else\n-\tcp_print_value_fields (type, type, embedded_offset,\n-\t\t\t       address, stream, recurse, original_value,\n-\t\t\t       options, NULL, 0);\n-      break;\n-\n-    case TYPE_CODE_SET:\n-      elttype = TYPE_INDEX_TYPE (type);\n-      elttype = check_typedef (elttype);\n-      if (TYPE_STUB (elttype))\n-\t{\n-\t  fprintf_styled (stream, metadata_style.style (),\n-\t\t\t  _(\"<incomplete type>\"));\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  struct type *range = elttype;\n-\t  LONGEST low_bound, high_bound;\n-\t  int i;\n-\t  int need_comma = 0;\n-\n-\t  fputs_filtered (\"{\", stream);\n-\n-\t  i = get_discrete_bounds (range, &low_bound, &high_bound);\n-\tmaybe_bad_bstring:\n-\t  if (i < 0)\n-\t    {\n-\t      fputs_styled (_(\"<error value>\"), metadata_style.style (),\n-\t\t\t    stream);\n-\t      goto done;\n-\t    }\n-\n-\t  for (i = low_bound; i <= high_bound; i++)\n-\t    {\n-\t      int element = value_bit_index (type, valaddr + embedded_offset,\n-\t\t\t\t\t     i);\n-\n-\t      if (element < 0)\n-\t\t{\n-\t\t  i = element;\n-\t\t  goto maybe_bad_bstring;\n-\t\t}\n-\t      if (element)\n-\t\t{\n-\t\t  if (need_comma)\n-\t\t    fputs_filtered (\", \", stream);\n-\t\t  print_type_scalar (range, i, stream);\n-\t\t  need_comma = 1;\n-\n-\t\t  if (i + 1 <= high_bound\n-\t\t      && value_bit_index (type, valaddr + embedded_offset,\n-\t\t\t\t\t  ++i))\n-\t\t    {\n-\t\t      int j = i;\n-\n-\t\t      fputs_filtered (\"..\", stream);\n-\t\t      while (i + 1 <= high_bound\n-\t\t\t     && value_bit_index (type,\n-\t\t\t\t\t\t valaddr + embedded_offset,\n-\t\t\t\t\t\t ++i))\n-\t\t\tj = i;\n-\t\t      print_type_scalar (range, j, stream);\n-\t\t    }\n-\t\t}\n-\t    }\n-\tdone:\n-\t  fputs_filtered (\"}\", stream);\n-\t}\n-      break;\n-\n-    case TYPE_CODE_RANGE:\n-      if (TYPE_LENGTH (type) == TYPE_LENGTH (TYPE_TARGET_TYPE (type)))\n-\t{\n-\t  m2_val_print (TYPE_TARGET_TYPE (type), embedded_offset,\n-\t\t\taddress, stream, recurse, original_value, options);\n-\t  break;\n-\t}\n-      /* FIXME: create_static_range_type does not set the unsigned bit in a\n-         range type (I think it probably should copy it from the target\n-         type), so we won't print values which are too large to\n-         fit in a signed integer correctly.  */\n-      /* FIXME: Doesn't handle ranges of enums correctly.  (Can't just\n-         print with the target type, though, because the size of our type\n-         and the target type might differ).  */\n-      /* FALLTHROUGH */\n-\n-    case TYPE_CODE_REF:\n-    case TYPE_CODE_ENUM:\n-    case TYPE_CODE_FUNC:\n-    case TYPE_CODE_INT:\n-    case TYPE_CODE_FLT:\n-    case TYPE_CODE_METHOD:\n-    case TYPE_CODE_VOID:\n-    case TYPE_CODE_ERROR:\n-    case TYPE_CODE_UNDEF:\n-    case TYPE_CODE_BOOL:\n-    case TYPE_CODE_CHAR:\n-    default:\n-      generic_val_print (type, embedded_offset, address,\n-\t\t\t stream, recurse, original_value, options,\n-\t\t\t &m2_decorations);\n-      break;\n-    }\n-}\n-\n /* See m2-lang.h.  */\n \n void"
    },
    {
      "sha": "1c7ec5601979e0cd5c9bed1359cd388b2c60e4ea",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -381,7 +381,6 @@ extern const struct language_defn objc_language_defn = {\n   c_emit_char,\n   c_print_type,\t\t\t/* Print a type using appropriate syntax */\n   c_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  c_val_print,\t\t\t/* Print a value using appropriate syntax */\n   c_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "a4fdc5a1176cd8fd9c3c0b368f5bf45751ee1835",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -1060,7 +1060,6 @@ extern const struct language_defn opencl_language_defn =\n   c_emit_char,\t\t\t/* Print a single char */\n   opencl_print_type,\t\t/* Print a type using appropriate syntax */\n   c_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  c_val_print,\t\t\t/* Print a value using appropriate syntax */\n   c_value_print_inner,\t\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "944a077506c45ad02d910a4c1bebb95001aa9d14",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -447,7 +447,6 @@ extern const struct language_defn pascal_language_defn =\n   pascal_emit_char,\t\t/* Print a single char */\n   pascal_print_type,\t\t/* Print a type using appropriate syntax */\n   pascal_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  pascal_val_print,\t\t/* Print a value using appropriate syntax */\n   pascal_value_print_inner,\t/* la_value_print_inner */\n   pascal_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "9ce61318761ecc4a03fcb088629c4d0c2bed717f",
      "filename": "gdb/p-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/p-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/p-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -37,11 +37,6 @@ extern void pascal_print_type (struct type *, const char *, struct ui_file *,\n extern void pascal_print_typedef (struct type *, struct symbol *,\n \t\t\t\t  struct ui_file *);\n \n-extern void pascal_val_print (struct type *, int,\n-\t\t\t      CORE_ADDR, struct ui_file *, int,\n-\t\t\t      struct value *,\n-\t\t\t      const struct value_print_options *);\n-\n /* Implement la_value_print_inner for Pascal.  */\n \n extern void pascal_value_print_inner (struct value *, struct ui_file *, int,"
    },
    {
      "sha": "35a4e59d250137f189a82e682acf8b729b2fd6a2",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 79,
      "deletions": 776,
      "changes": 855,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -42,14 +42,6 @@\n #include \"cli/cli-style.h\"\n \f\n \n-static void pascal_object_print_value_fields (struct type *, const gdb_byte *,\n-\t\t\t\t\t      LONGEST,\n-\t\t\t\t\t      CORE_ADDR, struct ui_file *,\n-\t\t\t\t\t      int,\n-\t\t\t\t\t      struct value *,\n-\t\t\t\t\t      const struct value_print_options *,\n-\t\t\t\t\t      struct type **, int);\n-\n static void pascal_object_print_value_fields (struct value *, struct ui_file *,\n \t\t\t\t\t      int,\n \t\t\t\t\t      const struct value_print_options *,\n@@ -69,16 +61,15 @@ static const struct generic_val_print_decorations p_decorations =\n   \"}\"\n };\n \n-/* See val_print for a description of the various parameters of this\n-   function; they are identical.  */\n+/* See p-lang.h.  */\n \n void\n-pascal_val_print (struct type *type,\n-\t\t  int embedded_offset, CORE_ADDR address,\n-\t\t  struct ui_file *stream, int recurse,\n-\t\t  struct value *original_value,\n-\t\t  const struct value_print_options *options)\n+pascal_value_print_inner (struct value *val, struct ui_file *stream,\n+\t\t\t  int recurse,\n+\t\t\t  const struct value_print_options *options)\n+\n {\n+  struct type *type = check_typedef (value_type (val));\n   struct gdbarch *gdbarch = get_type_arch (type);\n   enum bfd_endian byte_order = type_byte_order (type);\n   unsigned int i = 0;\t/* Number of characters printed */\n@@ -89,9 +80,8 @@ pascal_val_print (struct type *type,\n   struct type *char_type;\n   CORE_ADDR addr;\n   int want_space = 0;\n-  const gdb_byte *valaddr = value_contents_for_printing (original_value);\n+  const gdb_byte *valaddr = value_contents_for_printing (val);\n \n-  type = check_typedef (type);\n   switch (TYPE_CODE (type))\n     {\n     case TYPE_CODE_ARRAY:\n@@ -123,17 +113,15 @@ pascal_val_print (struct type *type,\n \n \t\t    /* Look for a NULL char.  */\n \t\t    for (temp_len = 0;\n-\t\t\t extract_unsigned_integer (valaddr + embedded_offset +\n-\t\t\t\t\t\t   temp_len * eltlen, eltlen,\n-\t\t\t\t\t\t   byte_order)\n+\t\t\t extract_unsigned_integer (valaddr + temp_len * eltlen,\n+\t\t\t\t\t\t   eltlen, byte_order)\n \t\t\t   && temp_len < len && temp_len < options->print_max;\n \t\t\t temp_len++);\n \t\t    len = temp_len;\n \t\t  }\n \n \t\tLA_PRINT_STRING (stream, TYPE_TARGET_TYPE (type),\n-\t\t\t\t valaddr + embedded_offset, len, NULL, 0,\n-\t\t\t\t options);\n+\t\t\t\t valaddr, len, NULL, 0, options);\n \t\ti = len;\n \t      }\n \t    else\n@@ -150,23 +138,20 @@ pascal_val_print (struct type *type,\n \t\t  {\n \t\t    i = 0;\n \t\t  }\n-\t\tval_print_array_elements (type, embedded_offset,\n-\t\t\t\t\t  address, stream, recurse,\n-\t\t\t\t\t  original_value, options, i);\n+\t\tvalue_print_array_elements (val, stream, recurse, options, i);\n \t\tfprintf_filtered (stream, \"}\");\n \t      }\n \t    break;\n \t  }\n \t/* Array of unspecified length: treat like pointer to first elt.  */\n-\taddr = address + embedded_offset;\n+\taddr = value_address (val);\n       }\n       goto print_unpacked_pointer;\n \n     case TYPE_CODE_PTR:\n       if (options->format && options->format != 's')\n \t{\n-\t  val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t      original_value, options, 0, stream);\n+\t  value_print_scalar_formatted (val, options, 0, stream);\n \t  break;\n \t}\n       if (options->vtblprint && pascal_object_is_vtbl_ptr_type (type))\n@@ -175,14 +160,14 @@ pascal_val_print (struct type *type,\n \t  /* Print vtable entry - we only get here if we ARE using\n \t     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_STRUCT.)  */\n \t  /* Extract the address, assume that it is unsigned.  */\n-\t  addr = extract_unsigned_integer (valaddr + embedded_offset,\n+\t  addr = extract_unsigned_integer (valaddr,\n \t\t\t\t\t   TYPE_LENGTH (type), byte_order);\n \t  print_address_demangle (options, gdbarch, addr, stream, demangle);\n \t  break;\n \t}\n       check_typedef (TYPE_TARGET_TYPE (type));\n \n-      addr = unpack_pointer (type, valaddr + embedded_offset);\n+      addr = unpack_pointer (type, valaddr);\n     print_unpacked_pointer:\n       elttype = check_typedef (TYPE_TARGET_TYPE (type));\n \n@@ -240,8 +225,7 @@ pascal_val_print (struct type *type,\n       else if (pascal_object_is_vtbl_member (type))\n \t{\n \t  /* Print vtbl's nicely.  */\n-\t  CORE_ADDR vt_address = unpack_pointer (type,\n-\t\t\t\t\t\t valaddr + embedded_offset);\n+\t  CORE_ADDR vt_address = unpack_pointer (type, valaddr);\n \t  struct bound_minimal_symbol msymbol =\n \t    lookup_minimal_symbol_by_pc (vt_address);\n \n@@ -306,9 +290,7 @@ pascal_val_print (struct type *type,\n     case TYPE_CODE_UNDEF:\n     case TYPE_CODE_BOOL:\n     case TYPE_CODE_CHAR:\n-      generic_val_print (type, embedded_offset, address,\n-\t\t\t stream, recurse, original_value, options,\n-\t\t\t &p_decorations);\n+      generic_value_print (val, stream, recurse, options, &p_decorations);\n       break;\n \n     case TYPE_CODE_UNION:\n@@ -327,7 +309,7 @@ pascal_val_print (struct type *type,\n \t  /* Extract the address, assume that it is unsigned.  */\n \t  print_address_demangle\n \t    (options, gdbarch,\n-\t     extract_unsigned_integer (valaddr + embedded_offset\n+\t     extract_unsigned_integer (valaddr\n \t\t\t\t       + TYPE_FIELD_BITPOS (type,\n \t\t\t\t\t\t\t    VTBL_FNADDR_OFFSET) / 8,\n \t\t\t\t       TYPE_LENGTH (TYPE_FIELD_TYPE (type,\n@@ -340,18 +322,14 @@ pascal_val_print (struct type *type,\n           if (is_pascal_string_type (type, &length_pos, &length_size,\n                                      &string_pos, &char_type, NULL))\n \t    {\n-\t      len = extract_unsigned_integer (valaddr + embedded_offset\n-\t\t\t\t\t      + length_pos, length_size,\n-\t\t\t\t\t      byte_order);\n-\t      LA_PRINT_STRING (stream, char_type,\n-\t\t\t       valaddr + embedded_offset + string_pos,\n+\t      len = extract_unsigned_integer (valaddr + length_pos,\n+\t\t\t\t\t      length_size, byte_order);\n+\t      LA_PRINT_STRING (stream, char_type, valaddr + string_pos,\n \t\t\t       len, NULL, 0, options);\n \t    }\n \t  else\n-\t    pascal_object_print_value_fields (type, valaddr, embedded_offset,\n-\t\t\t\t\t      address, stream, recurse,\n-\t\t\t\t\t      original_value, options,\n-\t\t\t\t\t      NULL, 0);\n+\t    pascal_object_print_value_fields (val, stream, recurse,\n+\t\t\t\t\t      options, NULL, 0);\n \t}\n       break;\n \n@@ -389,8 +367,7 @@ pascal_val_print (struct type *type,\n \n \t  for (i = low_bound; i <= high_bound; i++)\n \t    {\n-\t      int element = value_bit_index (type,\n-\t\t\t\t\t     valaddr + embedded_offset, i);\n+\t      int element = value_bit_index (type, valaddr, i);\n \n \t      if (element < 0)\n \t\t{\n@@ -405,16 +382,13 @@ pascal_val_print (struct type *type,\n \t\t  need_comma = 1;\n \n \t\t  if (i + 1 <= high_bound\n-\t\t      && value_bit_index (type,\n-\t\t\t\t\t  valaddr + embedded_offset, ++i))\n+\t\t      && value_bit_index (type, valaddr, ++i))\n \t\t    {\n \t\t      int j = i;\n \n \t\t      fputs_filtered (\"..\", stream);\n \t\t      while (i + 1 <= high_bound\n-\t\t\t     && value_bit_index (type,\n-\t\t\t\t\t\t valaddr + embedded_offset,\n-\t\t\t\t\t\t ++i))\n+\t\t\t     && value_bit_index (type, valaddr, ++i))\n \t\t\tj = i;\n \t\t      print_type_scalar (range, j, stream);\n \t\t    }\n@@ -431,428 +405,75 @@ pascal_val_print (struct type *type,\n     }\n }\n \n-/* See p-lang.h.  */\n-\n+\f\n void\n-pascal_value_print_inner (struct value *val, struct ui_file *stream,\n-\t\t\t  int recurse,\n-\t\t\t  const struct value_print_options *options)\n-\n+pascal_value_print (struct value *val, struct ui_file *stream,\n+\t\t    const struct value_print_options *options)\n {\n-  struct type *type = check_typedef (value_type (val));\n-  struct gdbarch *gdbarch = get_type_arch (type);\n-  enum bfd_endian byte_order = type_byte_order (type);\n-  unsigned int i = 0;\t/* Number of characters printed */\n-  unsigned len;\n-  struct type *elttype;\n-  unsigned eltlen;\n-  int length_pos, length_size, string_pos;\n-  struct type *char_type;\n-  CORE_ADDR addr;\n-  int want_space = 0;\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n-\n-  switch (TYPE_CODE (type))\n-    {\n-    case TYPE_CODE_ARRAY:\n-      {\n-\tLONGEST low_bound, high_bound;\n+  struct type *type = value_type (val);\n+  struct value_print_options opts = *options;\n \n-\tif (get_array_bounds (type, &low_bound, &high_bound))\n-\t  {\n-\t    len = high_bound - low_bound + 1;\n-\t    elttype = check_typedef (TYPE_TARGET_TYPE (type));\n-\t    eltlen = TYPE_LENGTH (elttype);\n-\t    if (options->prettyformat_arrays)\n-\t      {\n-\t\tprint_spaces_filtered (2 + 2 * recurse, stream);\n-\t      }\n-\t    /* If 's' format is used, try to print out as string.\n-\t       If no format is given, print as string if element type\n-\t       is of TYPE_CODE_CHAR and element size is 1,2 or 4.  */\n-\t    if (options->format == 's'\n-\t\t|| ((eltlen == 1 || eltlen == 2 || eltlen == 4)\n-\t\t    && TYPE_CODE (elttype) == TYPE_CODE_CHAR\n-\t\t    && options->format == 0))\n-\t      {\n-\t\t/* If requested, look for the first null char and only print\n-\t\t   elements up to it.  */\n-\t\tif (options->stop_print_at_null)\n-\t\t  {\n-\t\t    unsigned int temp_len;\n+  opts.deref_ref = 1;\n \n-\t\t    /* Look for a NULL char.  */\n-\t\t    for (temp_len = 0;\n-\t\t\t extract_unsigned_integer (valaddr + temp_len * eltlen,\n-\t\t\t\t\t\t   eltlen, byte_order)\n-\t\t\t   && temp_len < len && temp_len < options->print_max;\n-\t\t\t temp_len++);\n-\t\t    len = temp_len;\n-\t\t  }\n+  /* If it is a pointer, indicate what it points to.\n \n-\t\tLA_PRINT_STRING (stream, TYPE_TARGET_TYPE (type),\n-\t\t\t\t valaddr, len, NULL, 0, options);\n-\t\ti = len;\n-\t      }\n-\t    else\n-\t      {\n-\t\tfprintf_filtered (stream, \"{\");\n-\t\t/* If this is a virtual function table, print the 0th\n-\t\t   entry specially, and the rest of the members normally.  */\n-\t\tif (pascal_object_is_vtbl_ptr_type (elttype))\n-\t\t  {\n-\t\t    i = 1;\n-\t\t    fprintf_filtered (stream, \"%d vtable entries\", len - 1);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    i = 0;\n-\t\t  }\n-\t\tvalue_print_array_elements (val, stream, recurse, options, i);\n-\t\tfprintf_filtered (stream, \"}\");\n-\t      }\n-\t    break;\n-\t  }\n-\t/* Array of unspecified length: treat like pointer to first elt.  */\n-\taddr = value_address (val);\n-      }\n-      goto print_unpacked_pointer;\n+     Print type also if it is a reference.\n \n-    case TYPE_CODE_PTR:\n-      if (options->format && options->format != 's')\n+     Object pascal: if it is a member pointer, we will take care\n+     of that when we print it.  */\n+  if (TYPE_CODE (type) == TYPE_CODE_PTR\n+      || TYPE_CODE (type) == TYPE_CODE_REF)\n+    {\n+      /* Hack:  remove (char *) for char strings.  Their\n+         type is indicated by the quoted string anyway.  */\n+      if (TYPE_CODE (type) == TYPE_CODE_PTR\n+\t  && TYPE_NAME (type) == NULL\n+\t  && TYPE_NAME (TYPE_TARGET_TYPE (type)) != NULL\n+\t  && strcmp (TYPE_NAME (TYPE_TARGET_TYPE (type)), \"char\") == 0)\n \t{\n-\t  value_print_scalar_formatted (val, options, 0, stream);\n-\t  break;\n+\t  /* Print nothing.  */\n \t}\n-      if (options->vtblprint && pascal_object_is_vtbl_ptr_type (type))\n+      else\n \t{\n-\t  /* Print the unmangled name if desired.  */\n-\t  /* Print vtable entry - we only get here if we ARE using\n-\t     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_STRUCT.)  */\n-\t  /* Extract the address, assume that it is unsigned.  */\n-\t  addr = extract_unsigned_integer (valaddr,\n-\t\t\t\t\t   TYPE_LENGTH (type), byte_order);\n-\t  print_address_demangle (options, gdbarch, addr, stream, demangle);\n-\t  break;\n+\t  fprintf_filtered (stream, \"(\");\n+\t  type_print (type, \"\", stream, -1);\n+\t  fprintf_filtered (stream, \") \");\n \t}\n-      check_typedef (TYPE_TARGET_TYPE (type));\n+    }\n+  common_val_print (val, stream, 0, &opts, current_language);\n+}\n \n-      addr = unpack_pointer (type, valaddr);\n-    print_unpacked_pointer:\n-      elttype = check_typedef (TYPE_TARGET_TYPE (type));\n \n-      if (TYPE_CODE (elttype) == TYPE_CODE_FUNC)\n-\t{\n-\t  /* Try to print what function it points to.  */\n-\t  print_address_demangle (options, gdbarch, addr, stream, demangle);\n-\t  return;\n-\t}\n+static void\n+show_pascal_static_field_print (struct ui_file *file, int from_tty,\n+\t\t\t\tstruct cmd_list_element *c, const char *value)\n+{\n+  fprintf_filtered (file, _(\"Printing of pascal static members is %s.\\n\"),\n+\t\t    value);\n+}\n \n-      if (options->addressprint && options->format != 's')\n-\t{\n-\t  fputs_filtered (paddress (gdbarch, addr), stream);\n-\t  want_space = 1;\n-\t}\n+static struct obstack dont_print_vb_obstack;\n+static struct obstack dont_print_statmem_obstack;\n \n-      /* For a pointer to char or unsigned char, also print the string\n-\t pointed to, unless pointer is null.  */\n-      if (((TYPE_LENGTH (elttype) == 1\n-\t   && (TYPE_CODE (elttype) == TYPE_CODE_INT\n-\t      || TYPE_CODE (elttype) == TYPE_CODE_CHAR))\n-\t  || ((TYPE_LENGTH (elttype) == 2 || TYPE_LENGTH (elttype) == 4)\n-\t      && TYPE_CODE (elttype) == TYPE_CODE_CHAR))\n-\t  && (options->format == 0 || options->format == 's')\n-\t  && addr != 0)\n-\t{\n-\t  if (want_space)\n-\t    fputs_filtered (\" \", stream);\n-\t  /* No wide string yet.  */\n-\t  i = val_print_string (elttype, NULL, addr, -1, stream, options);\n-\t}\n-      /* Also for pointers to pascal strings.  */\n-      /* Note: this is Free Pascal specific:\n-\t as GDB does not recognize stabs pascal strings\n-\t Pascal strings are mapped to records\n-\t with lowercase names PM.  */\n-      if (is_pascal_string_type (elttype, &length_pos, &length_size,\n-\t\t\t\t &string_pos, &char_type, NULL)\n-\t  && addr != 0)\n-\t{\n-\t  ULONGEST string_length;\n-\t  gdb_byte *buffer;\n+static void pascal_object_print_static_field (struct value *,\n+\t\t\t\t\t      struct ui_file *, int,\n+\t\t\t\t\t      const struct value_print_options *);\n \n-\t  if (want_space)\n-\t    fputs_filtered (\" \", stream);\n-\t  buffer = (gdb_byte *) xmalloc (length_size);\n-\t  read_memory (addr + length_pos, buffer, length_size);\n-\t  string_length = extract_unsigned_integer (buffer, length_size,\n-\t\t\t\t\t\t    byte_order);\n-\t  xfree (buffer);\n-\t  i = val_print_string (char_type, NULL,\n-\t\t\t\taddr + string_pos, string_length,\n-\t\t\t\tstream, options);\n-\t}\n-      else if (pascal_object_is_vtbl_member (type))\n-\t{\n-\t  /* Print vtbl's nicely.  */\n-\t  CORE_ADDR vt_address = unpack_pointer (type, valaddr);\n-\t  struct bound_minimal_symbol msymbol =\n-\t    lookup_minimal_symbol_by_pc (vt_address);\n+static void pascal_object_print_value (struct value *, struct ui_file *, int,\n+\t\t\t\t       const struct value_print_options *,\n+\t\t\t\t       struct type **);\n \n-\t  /* If 'symbol_print' is set, we did the work above.  */\n-\t  if (!options->symbol_print\n-\t      && (msymbol.minsym != NULL)\n-\t      && (vt_address == BMSYMBOL_VALUE_ADDRESS (msymbol)))\n-\t    {\n-\t      if (want_space)\n-\t\tfputs_filtered (\" \", stream);\n-\t      fputs_filtered (\"<\", stream);\n-\t      fputs_filtered (msymbol.minsym->print_name (), stream);\n-\t      fputs_filtered (\">\", stream);\n-\t      want_space = 1;\n-\t    }\n-\t  if (vt_address && options->vtblprint)\n-\t    {\n-\t      struct value *vt_val;\n-\t      struct symbol *wsym = NULL;\n-\t      struct type *wtype;\n+/* It was changed to this after 2.4.5.  */\n+const char pascal_vtbl_ptr_name[] =\n+{'_', '_', 'v', 't', 'b', 'l', '_', 'p', 't', 'r', '_', 't', 'y', 'p', 'e', 0};\n \n-\t      if (want_space)\n-\t\tfputs_filtered (\" \", stream);\n+/* Return truth value for assertion that TYPE is of the type\n+   \"pointer to virtual function\".  */\n \n-\t      if (msymbol.minsym != NULL)\n-\t\t{\n-\t\t  const char *search_name = msymbol.minsym->search_name ();\n-\t\t  wsym = lookup_symbol_search_name (search_name, NULL,\n-\t\t\t\t\t\t    VAR_DOMAIN).symbol;\n-\t\t}\n-\n-\t      if (wsym)\n-\t\t{\n-\t\t  wtype = SYMBOL_TYPE (wsym);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  wtype = TYPE_TARGET_TYPE (type);\n-\t\t}\n-\t      vt_val = value_at (wtype, vt_address);\n-\t      common_val_print (vt_val, stream, recurse + 1, options,\n-\t\t\t\tcurrent_language);\n-\t      if (options->prettyformat)\n-\t\t{\n-\t\t  fprintf_filtered (stream, \"\\n\");\n-\t\t  print_spaces_filtered (2 + 2 * recurse, stream);\n-\t\t}\n-\t    }\n-\t}\n-\n-      return;\n-\n-    case TYPE_CODE_REF:\n-    case TYPE_CODE_ENUM:\n-    case TYPE_CODE_FLAGS:\n-    case TYPE_CODE_FUNC:\n-    case TYPE_CODE_RANGE:\n-    case TYPE_CODE_INT:\n-    case TYPE_CODE_FLT:\n-    case TYPE_CODE_VOID:\n-    case TYPE_CODE_ERROR:\n-    case TYPE_CODE_UNDEF:\n-    case TYPE_CODE_BOOL:\n-    case TYPE_CODE_CHAR:\n-      generic_value_print (val, stream, recurse, options, &p_decorations);\n-      break;\n-\n-    case TYPE_CODE_UNION:\n-      if (recurse && !options->unionprint)\n-\t{\n-\t  fprintf_filtered (stream, \"{...}\");\n-\t  break;\n-\t}\n-      /* Fall through.  */\n-    case TYPE_CODE_STRUCT:\n-      if (options->vtblprint && pascal_object_is_vtbl_ptr_type (type))\n-\t{\n-\t  /* Print the unmangled name if desired.  */\n-\t  /* Print vtable entry - we only get here if NOT using\n-\t     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_PTR.)  */\n-\t  /* Extract the address, assume that it is unsigned.  */\n-\t  print_address_demangle\n-\t    (options, gdbarch,\n-\t     extract_unsigned_integer (valaddr\n-\t\t\t\t       + TYPE_FIELD_BITPOS (type,\n-\t\t\t\t\t\t\t    VTBL_FNADDR_OFFSET) / 8,\n-\t\t\t\t       TYPE_LENGTH (TYPE_FIELD_TYPE (type,\n-\t\t\t\t\t\t\t\t     VTBL_FNADDR_OFFSET)),\n-\t\t\t\t       byte_order),\n-\t     stream, demangle);\n-\t}\n-      else\n-\t{\n-          if (is_pascal_string_type (type, &length_pos, &length_size,\n-                                     &string_pos, &char_type, NULL))\n-\t    {\n-\t      len = extract_unsigned_integer (valaddr + length_pos,\n-\t\t\t\t\t      length_size, byte_order);\n-\t      LA_PRINT_STRING (stream, char_type, valaddr + string_pos,\n-\t\t\t       len, NULL, 0, options);\n-\t    }\n-\t  else\n-\t    pascal_object_print_value_fields (type, valaddr, 0,\n-\t\t\t\t\t      value_address (val), stream,\n-\t\t\t\t\t      recurse, val, options,\n-\t\t\t\t\t      NULL, 0);\n-\t}\n-      break;\n-\n-    case TYPE_CODE_SET:\n-      elttype = TYPE_INDEX_TYPE (type);\n-      elttype = check_typedef (elttype);\n-      if (TYPE_STUB (elttype))\n-\t{\n-\t  fprintf_styled (stream, metadata_style.style (), \"<incomplete type>\");\n-\t  break;\n-\t}\n-      else\n-\t{\n-\t  struct type *range = elttype;\n-\t  LONGEST low_bound, high_bound;\n-\t  int need_comma = 0;\n-\n-\t  fputs_filtered (\"[\", stream);\n-\n-\t  int bound_info = get_discrete_bounds (range, &low_bound, &high_bound);\n-\t  if (low_bound == 0 && high_bound == -1 && TYPE_LENGTH (type) > 0)\n-\t    {\n-\t      /* If we know the size of the set type, we can figure out the\n-\t      maximum value.  */\n-\t      bound_info = 0;\n-\t      high_bound = TYPE_LENGTH (type) * TARGET_CHAR_BIT - 1;\n-\t      TYPE_HIGH_BOUND (range) = high_bound;\n-\t    }\n-\tmaybe_bad_bstring:\n-\t  if (bound_info < 0)\n-\t    {\n-\t      fputs_styled (\"<error value>\", metadata_style.style (), stream);\n-\t      goto done;\n-\t    }\n-\n-\t  for (i = low_bound; i <= high_bound; i++)\n-\t    {\n-\t      int element = value_bit_index (type, valaddr, i);\n-\n-\t      if (element < 0)\n-\t\t{\n-\t\t  i = element;\n-\t\t  goto maybe_bad_bstring;\n-\t\t}\n-\t      if (element)\n-\t\t{\n-\t\t  if (need_comma)\n-\t\t    fputs_filtered (\", \", stream);\n-\t\t  print_type_scalar (range, i, stream);\n-\t\t  need_comma = 1;\n-\n-\t\t  if (i + 1 <= high_bound\n-\t\t      && value_bit_index (type, valaddr, ++i))\n-\t\t    {\n-\t\t      int j = i;\n-\n-\t\t      fputs_filtered (\"..\", stream);\n-\t\t      while (i + 1 <= high_bound\n-\t\t\t     && value_bit_index (type, valaddr, ++i))\n-\t\t\tj = i;\n-\t\t      print_type_scalar (range, j, stream);\n-\t\t    }\n-\t\t}\n-\t    }\n-\tdone:\n-\t  fputs_filtered (\"]\", stream);\n-\t}\n-      break;\n-\n-    default:\n-      error (_(\"Invalid pascal type code %d in symbol table.\"),\n-\t     TYPE_CODE (type));\n-    }\n-}\n-\n-\f\n-void\n-pascal_value_print (struct value *val, struct ui_file *stream,\n-\t\t    const struct value_print_options *options)\n-{\n-  struct type *type = value_type (val);\n-  struct value_print_options opts = *options;\n-\n-  opts.deref_ref = 1;\n-\n-  /* If it is a pointer, indicate what it points to.\n-\n-     Print type also if it is a reference.\n-\n-     Object pascal: if it is a member pointer, we will take care\n-     of that when we print it.  */\n-  if (TYPE_CODE (type) == TYPE_CODE_PTR\n-      || TYPE_CODE (type) == TYPE_CODE_REF)\n-    {\n-      /* Hack:  remove (char *) for char strings.  Their\n-         type is indicated by the quoted string anyway.  */\n-      if (TYPE_CODE (type) == TYPE_CODE_PTR\n-\t  && TYPE_NAME (type) == NULL\n-\t  && TYPE_NAME (TYPE_TARGET_TYPE (type)) != NULL\n-\t  && strcmp (TYPE_NAME (TYPE_TARGET_TYPE (type)), \"char\") == 0)\n-\t{\n-\t  /* Print nothing.  */\n-\t}\n-      else\n-\t{\n-\t  fprintf_filtered (stream, \"(\");\n-\t  type_print (type, \"\", stream, -1);\n-\t  fprintf_filtered (stream, \") \");\n-\t}\n-    }\n-  common_val_print (val, stream, 0, &opts, current_language);\n-}\n-\n-\n-static void\n-show_pascal_static_field_print (struct ui_file *file, int from_tty,\n-\t\t\t\tstruct cmd_list_element *c, const char *value)\n-{\n-  fprintf_filtered (file, _(\"Printing of pascal static members is %s.\\n\"),\n-\t\t    value);\n-}\n-\n-static struct obstack dont_print_vb_obstack;\n-static struct obstack dont_print_statmem_obstack;\n-\n-static void pascal_object_print_static_field (struct value *,\n-\t\t\t\t\t      struct ui_file *, int,\n-\t\t\t\t\t      const struct value_print_options *);\n-\n-static void pascal_object_print_value (struct type *, const gdb_byte *,\n-\t\t\t\t       LONGEST,\n-\t\t\t\t       CORE_ADDR, struct ui_file *, int,\n-\t\t\t\t       struct value *,\n-\t\t\t\t       const struct value_print_options *,\n-\t\t\t\t       struct type **);\n-\n-static void pascal_object_print_value (struct value *, struct ui_file *, int,\n-\t\t\t\t       const struct value_print_options *,\n-\t\t\t\t       struct type **);\n-\n-/* It was changed to this after 2.4.5.  */\n-const char pascal_vtbl_ptr_name[] =\n-{'_', '_', 'v', 't', 'b', 'l', '_', 'p', 't', 'r', '_', 't', 'y', 'p', 'e', 0};\n-\n-/* Return truth value for assertion that TYPE is of the type\n-   \"pointer to virtual function\".  */\n-\n-int\n-pascal_object_is_vtbl_ptr_type (struct type *type)\n-{\n-  const char *type_name = TYPE_NAME (type);\n+int\n+pascal_object_is_vtbl_ptr_type (struct type *type)\n+{\n+  const char *type_name = TYPE_NAME (type);\n \n   return (type_name != NULL\n \t  && strcmp (type_name, pascal_vtbl_ptr_name) == 0);\n@@ -883,194 +504,6 @@ pascal_object_is_vtbl_member (struct type *type)\n   return 0;\n }\n \n-/* Mutually recursive subroutines of pascal_object_print_value and\n-   c_val_print to print out a structure's fields:\n-   pascal_object_print_value_fields and pascal_object_print_value.\n-\n-   TYPE, VALADDR, ADDRESS, STREAM, RECURSE, and OPTIONS have the\n-   same meanings as in pascal_object_print_value and c_val_print.\n-\n-   DONT_PRINT is an array of baseclass types that we\n-   should not print, or zero if called from top level.  */\n-\n-static void\n-pascal_object_print_value_fields (struct type *type, const gdb_byte *valaddr,\n-\t\t\t\t  LONGEST offset,\n-\t\t\t\t  CORE_ADDR address, struct ui_file *stream,\n-\t\t\t\t  int recurse,\n-\t\t\t\t  struct value *val,\n-\t\t\t\t  const struct value_print_options *options,\n-\t\t\t\t  struct type **dont_print_vb,\n-\t\t\t\t  int dont_print_statmem)\n-{\n-  int i, len, n_baseclasses;\n-  char *last_dont_print\n-    = (char *) obstack_next_free (&dont_print_statmem_obstack);\n-\n-  type = check_typedef (type);\n-\n-  fprintf_filtered (stream, \"{\");\n-  len = TYPE_NFIELDS (type);\n-  n_baseclasses = TYPE_N_BASECLASSES (type);\n-\n-  /* Print out baseclasses such that we don't print\n-     duplicates of virtual baseclasses.  */\n-  if (n_baseclasses > 0)\n-    pascal_object_print_value (type, valaddr, offset, address,\n-\t\t\t       stream, recurse + 1, val,\n-\t\t\t       options, dont_print_vb);\n-\n-  if (!len && n_baseclasses == 1)\n-    fprintf_styled (stream, metadata_style.style (), \"<No data fields>\");\n-  else\n-    {\n-      struct obstack tmp_obstack = dont_print_statmem_obstack;\n-      int fields_seen = 0;\n-\n-      if (dont_print_statmem == 0)\n-\t{\n-\t  /* If we're at top level, carve out a completely fresh\n-\t     chunk of the obstack and use that until this particular\n-\t     invocation returns.  */\n-\t  obstack_finish (&dont_print_statmem_obstack);\n-\t}\n-\n-      for (i = n_baseclasses; i < len; i++)\n-\t{\n-\t  /* If requested, skip printing of static fields.  */\n-\t  if (!options->pascal_static_field_print\n-\t      && field_is_static (&TYPE_FIELD (type, i)))\n-\t    continue;\n-\t  if (fields_seen)\n-\t    fprintf_filtered (stream, \", \");\n-\t  else if (n_baseclasses > 0)\n-\t    {\n-\t      if (options->prettyformat)\n-\t\t{\n-\t\t  fprintf_filtered (stream, \"\\n\");\n-\t\t  print_spaces_filtered (2 + 2 * recurse, stream);\n-\t\t  fputs_filtered (\"members of \", stream);\n-\t\t  fputs_filtered (TYPE_NAME (type), stream);\n-\t\t  fputs_filtered (\": \", stream);\n-\t\t}\n-\t    }\n-\t  fields_seen = 1;\n-\n-\t  if (options->prettyformat)\n-\t    {\n-\t      fprintf_filtered (stream, \"\\n\");\n-\t      print_spaces_filtered (2 + 2 * recurse, stream);\n-\t    }\n-\t  else\n-\t    {\n-\t      wrap_here (n_spaces (2 + 2 * recurse));\n-\t    }\n-\n-\t  annotate_field_begin (TYPE_FIELD_TYPE (type, i));\n-\n-\t  if (field_is_static (&TYPE_FIELD (type, i)))\n-\t    {\n-\t      fputs_filtered (\"static \", stream);\n-\t      fprintf_symbol_filtered (stream,\n-\t\t\t\t       TYPE_FIELD_NAME (type, i),\n-\t\t\t\t       current_language->la_language,\n-\t\t\t\t       DMGL_PARAMS | DMGL_ANSI);\n-\t    }\n-\t  else\n-\t    fputs_styled (TYPE_FIELD_NAME (type, i),\n-\t\t\t  variable_name_style.style (), stream);\n-\t  annotate_field_name_end ();\n-\t  fputs_filtered (\" = \", stream);\n-\t  annotate_field_value ();\n-\n-\t  if (!field_is_static (&TYPE_FIELD (type, i))\n-\t      && TYPE_FIELD_PACKED (type, i))\n-\t    {\n-\t      struct value *v;\n-\n-\t      /* Bitfields require special handling, especially due to byte\n-\t         order problems.  */\n-\t      if (TYPE_FIELD_IGNORE (type, i))\n-\t\t{\n-\t\t  fputs_styled (\"<optimized out or zero length>\",\n-\t\t\t\tmetadata_style.style (), stream);\n-\t\t}\n-\t      else if (value_bits_synthetic_pointer (val,\n-\t\t\t\t\t\t     TYPE_FIELD_BITPOS (type,\n-\t\t\t\t\t\t\t\t\ti),\n-\t\t\t\t\t\t     TYPE_FIELD_BITSIZE (type,\n-\t\t\t\t\t\t\t\t\t i)))\n-\t\t{\n-\t\t  fputs_styled (_(\"<synthetic pointer>\"),\n-\t\t\t\tmetadata_style.style (), stream);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  struct value_print_options opts = *options;\n-\n-\t\t  v = value_field_bitfield (type, i, valaddr, offset, val);\n-\n-\t\t  opts.deref_ref = 0;\n-\t\t  common_val_print (v, stream, recurse + 1, &opts,\n-\t\t\t\t    current_language);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      if (TYPE_FIELD_IGNORE (type, i))\n-\t\t{\n-\t\t  fputs_styled (\"<optimized out or zero length>\",\n-\t\t\t\tmetadata_style.style (), stream);\n-\t\t}\n-\t      else if (field_is_static (&TYPE_FIELD (type, i)))\n-\t\t{\n-\t\t  /* struct value *v = value_static_field (type, i);\n-\t\t     v4.17 specific.  */\n-\t\t  struct value *v;\n-\n-\t\t  v = value_field_bitfield (type, i, valaddr, offset, val);\n-\n-\t\t  if (v == NULL)\n-\t\t    val_print_optimized_out (NULL, stream);\n-\t\t  else\n-\t\t    pascal_object_print_static_field (v, stream, recurse + 1,\n-\t\t\t\t\t\t      options);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  struct value_print_options opts = *options;\n-\n-\t\t  opts.deref_ref = 0;\n-\t\t  /* val_print (TYPE_FIELD_TYPE (type, i),\n-\t\t     valaddr + TYPE_FIELD_BITPOS (type, i) / 8,\n-\t\t     address + TYPE_FIELD_BITPOS (type, i) / 8, 0,\n-\t\t     stream, format, 0, recurse + 1, pretty); */\n-\t\t  val_print (TYPE_FIELD_TYPE (type, i),\n-\t\t\t     offset + TYPE_FIELD_BITPOS (type, i) / 8,\n-\t\t\t     address, stream, recurse + 1, val, &opts,\n-\t\t\t     current_language);\n-\t\t}\n-\t    }\n-\t  annotate_field_end ();\n-\t}\n-\n-      if (dont_print_statmem == 0)\n-\t{\n-\t  /* Free the space used to deal with the printing\n-\t     of the members from top level.  */\n-\t  obstack_free (&dont_print_statmem_obstack, last_dont_print);\n-\t  dont_print_statmem_obstack = tmp_obstack;\n-\t}\n-\n-      if (options->prettyformat)\n-\t{\n-\t  fprintf_filtered (stream, \"\\n\");\n-\t  print_spaces_filtered (2 * recurse, stream);\n-\t}\n-    }\n-  fprintf_filtered (stream, \"}\");\n-}\n-\n /* Mutually recursive subroutines of pascal_object_print_value and\n    pascal_value_print to print out a structure's fields:\n    pascal_object_print_value_fields and pascal_object_print_value.\n@@ -1253,132 +686,6 @@ pascal_object_print_value_fields (struct value *val, struct ui_file *stream,\n   fprintf_filtered (stream, \"}\");\n }\n \n-/* Special val_print routine to avoid printing multiple copies of virtual\n-   baseclasses.  */\n-\n-static void\n-pascal_object_print_value (struct type *type, const gdb_byte *valaddr,\n-\t\t\t   LONGEST offset,\n-\t\t\t   CORE_ADDR address, struct ui_file *stream,\n-\t\t\t   int recurse,\n-\t\t\t   struct value *val,\n-\t\t\t   const struct value_print_options *options,\n-\t\t\t   struct type **dont_print_vb)\n-{\n-  struct type **last_dont_print\n-    = (struct type **) obstack_next_free (&dont_print_vb_obstack);\n-  struct obstack tmp_obstack = dont_print_vb_obstack;\n-  int i, n_baseclasses = TYPE_N_BASECLASSES (type);\n-\n-  if (dont_print_vb == 0)\n-    {\n-      /* If we're at top level, carve out a completely fresh\n-         chunk of the obstack and use that until this particular\n-         invocation returns.  */\n-      /* Bump up the high-water mark.  Now alpha is omega.  */\n-      obstack_finish (&dont_print_vb_obstack);\n-    }\n-\n-  for (i = 0; i < n_baseclasses; i++)\n-    {\n-      LONGEST boffset = 0;\n-      struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));\n-      const char *basename = TYPE_NAME (baseclass);\n-      const gdb_byte *base_valaddr = NULL;\n-      LONGEST thisoffset;\n-      int skip = 0;\n-      gdb::byte_vector buf;\n-\n-      if (BASETYPE_VIA_VIRTUAL (type, i))\n-\t{\n-\t  struct type **first_dont_print\n-\t    = (struct type **) obstack_base (&dont_print_vb_obstack);\n-\n-\t  int j = (struct type **) obstack_next_free (&dont_print_vb_obstack)\n-\t    - first_dont_print;\n-\n-\t  while (--j >= 0)\n-\t    if (baseclass == first_dont_print[j])\n-\t      goto flush_it;\n-\n-\t  obstack_ptr_grow (&dont_print_vb_obstack, baseclass);\n-\t}\n-\n-      thisoffset = offset;\n-\n-      try\n-\t{\n-\t  boffset = baseclass_offset (type, i, valaddr, offset, address, val);\n-\t}\n-      catch (const gdb_exception_error &ex)\n-\t{\n-\t  if (ex.error == NOT_AVAILABLE_ERROR)\n-\t    skip = -1;\n-\t  else\n-\t    skip = 1;\n-\t}\n-\n-      if (skip == 0)\n-\t{\n-\t  /* The virtual base class pointer might have been clobbered by the\n-\t     user program. Make sure that it still points to a valid memory\n-\t     location.  */\n-\n-\t  if (boffset < 0 || boffset >= TYPE_LENGTH (type))\n-\t    {\n-\t      buf.resize (TYPE_LENGTH (baseclass));\n-\n-\t      base_valaddr = buf.data ();\n-\t      if (target_read_memory (address + boffset, buf.data (),\n-\t\t\t\t      TYPE_LENGTH (baseclass)) != 0)\n-\t\tskip = 1;\n-\t      address = address + boffset;\n-\t      thisoffset = 0;\n-\t      boffset = 0;\n-\t    }\n-\t  else\n-\t    base_valaddr = valaddr;\n-\t}\n-\n-      if (options->prettyformat)\n-\t{\n-\t  fprintf_filtered (stream, \"\\n\");\n-\t  print_spaces_filtered (2 * recurse, stream);\n-\t}\n-      fputs_filtered (\"<\", stream);\n-      /* Not sure what the best notation is in the case where there is no\n-         baseclass name.  */\n-\n-      fputs_filtered (basename ? basename : \"\", stream);\n-      fputs_filtered (\"> = \", stream);\n-\n-      if (skip < 0)\n-\tval_print_unavailable (stream);\n-      else if (skip > 0)\n-\tval_print_invalid_address (stream);\n-      else\n-\tpascal_object_print_value_fields (baseclass, base_valaddr,\n-\t\t\t\t\t  thisoffset + boffset, address,\n-\t\t\t\t\t  stream, recurse, val, options,\n-\t\t     (struct type **) obstack_base (&dont_print_vb_obstack),\n-\t\t\t\t\t  0);\n-      fputs_filtered (\", \", stream);\n-\n-    flush_it:\n-      ;\n-    }\n-\n-  if (dont_print_vb == 0)\n-    {\n-      /* Free the space used to deal with the printing\n-         of this type from top level.  */\n-      obstack_free (&dont_print_vb_obstack, last_dont_print);\n-      /* Reset watermark so that we can continue protecting\n-         ourselves from whatever we were protecting ourselves.  */\n-      dont_print_vb_obstack = tmp_obstack;\n-    }\n-}\n-\n /* Special val_print routine to avoid printing multiple copies of virtual\n    baseclasses.  */\n \n@@ -1548,12 +855,8 @@ pascal_object_print_static_field (struct value *val,\n \t\t    sizeof (CORE_ADDR));\n \n       type = check_typedef (type);\n-      pascal_object_print_value_fields (type,\n-\t\t\t\t\tvalue_contents_for_printing (val),\n-\t\t\t\t\tvalue_embedded_offset (val),\n-\t\t\t\t\taddr,\n-\t\t\t\t\tstream, recurse,\n-\t\t\t\t\tval, options, NULL, 1);\n+      pascal_object_print_value_fields (val, stream, recurse,\n+\t\t\t\t\toptions, NULL, 1);\n       return;\n     }\n "
    },
    {
      "sha": "139e4c2f2ce4577a21afd88886044dd63121cf3b",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 13,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -545,18 +545,6 @@ static const struct generic_val_print_decorations rust_decorations =\n   \"]\"\n };\n \n-/* la_val_print implementation for Rust.  */\n-\n-static void\n-rust_val_print (struct type *type, int embedded_offset,\n-\t\tCORE_ADDR address, struct ui_file *stream, int recurse,\n-\t\tstruct value *val,\n-\t\tconst struct value_print_options *options)\n-{\n-  generic_val_print (type, embedded_offset, address, stream,\n-\t\t     recurse, val, options, &rust_decorations);\n-}\n-\n /* la_value_print_inner implementation for Rust.  */\n static void\n rust_value_print_inner (struct value *val, struct ui_file *stream,\n@@ -2157,7 +2145,6 @@ extern const struct language_defn rust_language_defn =\n   rust_emitchar,\t\t/* Print a single char */\n   rust_print_type,\t\t/* Print a type using appropriate syntax */\n   rust_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n-  rust_val_print,\t\t/* Print a value using appropriate syntax */\n   rust_value_print_inner,\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */"
    },
    {
      "sha": "108a21b684964eda724e34d141cd1c5c8910447e",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 554,
      "changes": 566,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -424,14 +424,13 @@ print_unpacked_pointer (struct type *type, struct type *elttype,\n /* generic_val_print helper for TYPE_CODE_ARRAY.  */\n \n static void\n-generic_val_print_array (struct type *type,\n-\t\t\t int embedded_offset, CORE_ADDR address,\n+generic_val_print_array (struct value *val,\n \t\t\t struct ui_file *stream, int recurse,\n-\t\t\t struct value *original_value,\n \t\t\t const struct value_print_options *options,\n \t\t\t const struct\n \t\t\t     generic_val_print_decorations *decorations)\n {\n+  struct type *type = check_typedef (value_type (val));\n   struct type *unresolved_elttype = TYPE_TARGET_TYPE (type);\n   struct type *elttype = check_typedef (unresolved_elttype);\n \n@@ -448,48 +447,18 @@ generic_val_print_array (struct type *type,\n \t}\n \n       fputs_filtered (decorations->array_start, stream);\n-      val_print_array_elements (type, embedded_offset,\n-\t\t\t\taddress, stream,\n-\t\t\t\trecurse, original_value, options, 0);\n+      value_print_array_elements (val, stream, recurse, options, 0);\n       fputs_filtered (decorations->array_end, stream);\n     }\n   else\n     {\n       /* Array of unspecified length: treat like pointer to first elt.  */\n-      print_unpacked_pointer (type, elttype, address + embedded_offset, stream,\n-\t\t\t      options);\n+      print_unpacked_pointer (type, elttype, value_address (val),\n+\t\t\t      stream, options);\n     }\n \n }\n \n-/* generic_val_print helper for TYPE_CODE_PTR.  */\n-\n-static void\n-generic_val_print_ptr (struct type *type,\n-\t\t       int embedded_offset, struct ui_file *stream,\n-\t\t       struct value *original_value,\n-\t\t       const struct value_print_options *options)\n-{\n-  struct gdbarch *gdbarch = get_type_arch (type);\n-  int unit_size = gdbarch_addressable_memory_unit_size (gdbarch);\n-\n-  if (options->format && options->format != 's')\n-    {\n-      val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t  original_value, options, 0, stream);\n-    }\n-  else\n-    {\n-      struct type *unresolved_elttype = TYPE_TARGET_TYPE(type);\n-      struct type *elttype = check_typedef (unresolved_elttype);\n-      const gdb_byte *valaddr = value_contents_for_printing (original_value);\n-      CORE_ADDR addr = unpack_pointer (type,\n-\t\t\t\t       valaddr + embedded_offset * unit_size);\n-\n-      print_unpacked_pointer (type, elttype, addr, stream, options);\n-    }\n-}\n-\n /* generic_value_print helper for TYPE_CODE_PTR.  */\n \n static void\n@@ -511,18 +480,6 @@ generic_value_print_ptr (struct value *val, struct ui_file *stream,\n }\n \n \n-/* generic_val_print helper for TYPE_CODE_MEMBERPTR.  */\n-\n-static void\n-generic_val_print_memberptr (struct type *type,\n-\t\t\t     int embedded_offset, struct ui_file *stream,\n-\t\t\t     struct value *original_value,\n-\t\t\t     const struct value_print_options *options)\n-{\n-  val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t      original_value, options, 0, stream);\n-}\n-\n /* Print '@' followed by the address contained in ADDRESS_BUFFER.  */\n \n static void\n@@ -754,41 +711,6 @@ generic_val_print_func (struct type *type,\n   print_address_demangle (options, gdbarch, address, stream, demangle);\n }\n \n-/* generic_val_print helper for TYPE_CODE_BOOL.  */\n-\n-static void\n-generic_val_print_bool (struct type *type,\n-\t\t\tint embedded_offset, struct ui_file *stream,\n-\t\t\tstruct value *original_value,\n-\t\t\tconst struct value_print_options *options,\n-\t\t\tconst struct generic_val_print_decorations *decorations)\n-{\n-  LONGEST val;\n-  struct gdbarch *gdbarch = get_type_arch (type);\n-  int unit_size = gdbarch_addressable_memory_unit_size (gdbarch);\n-\n-  if (options->format || options->output_format)\n-    {\n-      struct value_print_options opts = *options;\n-      opts.format = (options->format ? options->format\n-\t\t     : options->output_format);\n-      val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t  original_value, &opts, 0, stream);\n-    }\n-  else\n-    {\n-      const gdb_byte *valaddr = value_contents_for_printing (original_value);\n-\n-      val = unpack_long (type, valaddr + embedded_offset * unit_size);\n-      if (val == 0)\n-\tfputs_filtered (decorations->false_name, stream);\n-      else if (val == 1)\n-\tfputs_filtered (decorations->true_name, stream);\n-      else\n-\tprint_longest (stream, 'd', 0, val);\n-    }\n-}\n-\n /* generic_value_print helper for TYPE_CODE_BOOL.  */\n \n static void\n@@ -818,22 +740,6 @@ generic_value_print_bool\n     }\n }\n \n-/* generic_val_print helper for TYPE_CODE_INT.  */\n-\n-static void\n-generic_val_print_int (struct type *type,\n-\t\t       int embedded_offset, struct ui_file *stream,\n-\t\t       struct value *original_value,\n-\t\t       const struct value_print_options *options)\n-{\n-  struct value_print_options opts = *options;\n-\n-  opts.format = (options->format ? options->format\n-\t\t : options->output_format);\n-  val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t      original_value, &opts, 0, stream);\n-}\n-\n /* generic_value_print helper for TYPE_CODE_INT.  */\n \n static void\n@@ -847,42 +753,6 @@ generic_value_print_int (struct value *val, struct ui_file *stream,\n   value_print_scalar_formatted (val, &opts, 0, stream);\n }\n \n-/* generic_val_print helper for TYPE_CODE_CHAR.  */\n-\n-static void\n-generic_val_print_char (struct type *type, struct type *unresolved_type,\n-\t\t\tint embedded_offset,\n-\t\t\tstruct ui_file *stream,\n-\t\t\tstruct value *original_value,\n-\t\t\tconst struct value_print_options *options)\n-{\n-  LONGEST val;\n-  struct gdbarch *gdbarch = get_type_arch (type);\n-  int unit_size = gdbarch_addressable_memory_unit_size (gdbarch);\n-\n-  if (options->format || options->output_format)\n-    {\n-      struct value_print_options opts = *options;\n-\n-      opts.format = (options->format ? options->format\n-\t\t     : options->output_format);\n-      val_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t  original_value, &opts, 0, stream);\n-    }\n-  else\n-    {\n-      const gdb_byte *valaddr = value_contents_for_printing (original_value);\n-\n-      val = unpack_long (type, valaddr + embedded_offset * unit_size);\n-      if (TYPE_UNSIGNED (type))\n-\tfprintf_filtered (stream, \"%u\", (unsigned int) val);\n-      else\n-\tfprintf_filtered (stream, \"%d\", (int) val);\n-      fputs_filtered (\" \", stream);\n-      LA_PRINT_CHAR (val, unresolved_type, stream);\n-    }\n-}\n-\n /* generic_value_print helper for TYPE_CODE_CHAR.  */\n \n static void\n@@ -931,41 +801,6 @@ generic_val_print_float (struct type *type,\n   print_floating (valaddr + embedded_offset * unit_size, type, stream);\n }\n \n-/* generic_val_print helper for TYPE_CODE_COMPLEX.  */\n-\n-static void\n-generic_val_print_complex (struct type *type,\n-\t\t\t   int embedded_offset, struct ui_file *stream,\n-\t\t\t   struct value *original_value,\n-\t\t\t   const struct value_print_options *options,\n-\t\t\t   const struct generic_val_print_decorations\n-\t\t\t     *decorations)\n-{\n-  struct gdbarch *gdbarch = get_type_arch (type);\n-  int unit_size = gdbarch_addressable_memory_unit_size (gdbarch);\n-  const gdb_byte *valaddr = value_contents_for_printing (original_value);\n-\n-  fprintf_filtered (stream, \"%s\", decorations->complex_prefix);\n-  if (options->format)\n-    val_print_scalar_formatted (TYPE_TARGET_TYPE (type),\n-\t\t\t\tembedded_offset, original_value, options, 0,\n-\t\t\t\tstream);\n-  else\n-    print_floating (valaddr + embedded_offset * unit_size,\n-\t\t    TYPE_TARGET_TYPE (type), stream);\n-  fprintf_filtered (stream, \"%s\", decorations->complex_infix);\n-  if (options->format)\n-    val_print_scalar_formatted (TYPE_TARGET_TYPE (type),\n-\t\t\t\tembedded_offset\n-\t\t\t\t+ type_length_units (TYPE_TARGET_TYPE (type)),\n-\t\t\t\toriginal_value, options, 0, stream);\n-  else\n-    print_floating (valaddr + embedded_offset * unit_size\n-\t\t    + TYPE_LENGTH (TYPE_TARGET_TYPE (type)),\n-\t\t    TYPE_TARGET_TYPE (type), stream);\n-  fprintf_filtered (stream, \"%s\", decorations->complex_suffix);\n-}\n-\n /* generic_value_print helper for TYPE_CODE_COMPLEX.  */\n \n static void\n@@ -990,144 +825,6 @@ generic_value_print_complex (struct value *val, struct ui_file *stream,\n   fprintf_filtered (stream, \"%s\", decorations->complex_suffix);\n }\n \n-/* A generic val_print that is suitable for use by language\n-   implementations of the la_val_print method.  This function can\n-   handle most type codes, though not all, notably exception\n-   TYPE_CODE_UNION and TYPE_CODE_STRUCT, which must be implemented by\n-   the caller.\n-   \n-   Most arguments are as to val_print.\n-   \n-   The additional DECORATIONS argument can be used to customize the\n-   output in some small, language-specific ways.  */\n-\n-void\n-generic_val_print (struct type *type,\n-\t\t   int embedded_offset, CORE_ADDR address,\n-\t\t   struct ui_file *stream, int recurse,\n-\t\t   struct value *original_value,\n-\t\t   const struct value_print_options *options,\n-\t\t   const struct generic_val_print_decorations *decorations)\n-{\n-  struct type *unresolved_type = type;\n-\n-  type = check_typedef (type);\n-  switch (TYPE_CODE (type))\n-    {\n-    case TYPE_CODE_ARRAY:\n-      generic_val_print_array (type, embedded_offset, address, stream,\n-\t\t\t       recurse, original_value, options, decorations);\n-      break;\n-\n-    case TYPE_CODE_MEMBERPTR:\n-      generic_val_print_memberptr (type, embedded_offset, stream,\n-\t\t\t\t   original_value, options);\n-      break;\n-\n-    case TYPE_CODE_PTR:\n-      generic_val_print_ptr (type, embedded_offset, stream,\n-\t\t\t     original_value, options);\n-      break;\n-\n-    case TYPE_CODE_REF:\n-    case TYPE_CODE_RVALUE_REF:\n-      generic_val_print_ref (type, embedded_offset, stream, recurse,\n-\t\t\t     original_value, options);\n-      break;\n-\n-    case TYPE_CODE_ENUM:\n-      if (options->format)\n-\tval_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t    original_value, options, 0, stream);\n-      else\n-\tgeneric_val_print_enum (type, embedded_offset, stream,\n-\t\t\t\toriginal_value, options);\n-      break;\n-\n-    case TYPE_CODE_FLAGS:\n-      if (options->format)\n-\tval_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t    original_value, options, 0, stream);\n-      else\n-\tval_print_type_code_flags (type, original_value, embedded_offset,\n-\t\t\t\t   stream);\n-      break;\n-\n-    case TYPE_CODE_FUNC:\n-    case TYPE_CODE_METHOD:\n-      if (options->format)\n-\tval_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t    original_value, options, 0, stream);\n-      else\n-\tgeneric_val_print_func (type, embedded_offset, address, stream,\n-\t\t\t\toriginal_value, options);\n-      break;\n-\n-    case TYPE_CODE_BOOL:\n-      generic_val_print_bool (type, embedded_offset, stream,\n-\t\t\t      original_value, options, decorations);\n-      break;\n-\n-    case TYPE_CODE_RANGE:\n-      /* FIXME: create_static_range_type does not set the unsigned bit in a\n-         range type (I think it probably should copy it from the\n-         target type), so we won't print values which are too large to\n-         fit in a signed integer correctly.  */\n-      /* FIXME: Doesn't handle ranges of enums correctly.  (Can't just\n-         print with the target type, though, because the size of our\n-         type and the target type might differ).  */\n-\n-      /* FALLTHROUGH */\n-\n-    case TYPE_CODE_INT:\n-      generic_val_print_int (type, embedded_offset, stream,\n-\t\t\t     original_value, options);\n-      break;\n-\n-    case TYPE_CODE_CHAR:\n-      generic_val_print_char (type, unresolved_type, embedded_offset,\n-\t\t\t      stream, original_value, options);\n-      break;\n-\n-    case TYPE_CODE_FLT:\n-    case TYPE_CODE_DECFLOAT:\n-      if (options->format)\n-\tval_print_scalar_formatted (type, embedded_offset,\n-\t\t\t\t    original_value, options, 0, stream);\n-      else\n-\tgeneric_val_print_float (type, embedded_offset, stream,\n-\t\t\t\t original_value, options);\n-      break;\n-\n-    case TYPE_CODE_VOID:\n-      fputs_filtered (decorations->void_name, stream);\n-      break;\n-\n-    case TYPE_CODE_ERROR:\n-      fprintf_filtered (stream, \"%s\", TYPE_ERROR_NAME (type));\n-      break;\n-\n-    case TYPE_CODE_UNDEF:\n-      /* This happens (without TYPE_STUB set) on systems which don't use\n-         dbx xrefs (NO_DBX_XREFS in gcc) if a file has a \"struct foo *bar\"\n-         and no complete type for struct foo in that file.  */\n-      fprintf_styled (stream, metadata_style.style (), _(\"<incomplete type>\"));\n-      break;\n-\n-    case TYPE_CODE_COMPLEX:\n-      generic_val_print_complex (type, embedded_offset, stream,\n-\t\t\t\t original_value, options, decorations);\n-      break;\n-\n-    case TYPE_CODE_UNION:\n-    case TYPE_CODE_STRUCT:\n-    case TYPE_CODE_METHODPTR:\n-    default:\n-      error (_(\"Unhandled type code %d in symbol table.\"),\n-\t     TYPE_CODE (type));\n-    }\n-}\n-\n /* See valprint.h.  */\n \n void\n@@ -1141,8 +838,7 @@ generic_value_print (struct value *val, struct ui_file *stream, int recurse,\n   switch (TYPE_CODE (type))\n     {\n     case TYPE_CODE_ARRAY:\n-      generic_val_print_array (type, 0, value_address (val), stream,\n-\t\t\t       recurse, val, options, decorations);\n+      generic_val_print_array (val, stream, recurse, options, decorations);\n       break;\n \n     case TYPE_CODE_MEMBERPTR:\n@@ -1247,15 +943,13 @@ generic_value_print (struct value *val, struct ui_file *stream, int recurse,\n    the value to be printed.  */\n \n static void\n-do_val_print (struct value *full_value,\n-\t      struct type *type, LONGEST embedded_offset,\n-\t      CORE_ADDR address, struct ui_file *stream, int recurse,\n-\t      struct value *val,\n+do_val_print (struct value *value, struct ui_file *stream, int recurse,\n \t      const struct value_print_options *options,\n \t      const struct language_defn *language)\n {\n   int ret = 0;\n   struct value_print_options local_opts = *options;\n+  struct type *type = value_type (value);\n   struct type *real_type = check_typedef (type);\n \n   if (local_opts.prettyformat == Val_prettyformat_default)\n@@ -1274,17 +968,12 @@ do_val_print (struct value *full_value,\n       return;\n     }\n \n-  if (!valprint_check_validity (stream, real_type, embedded_offset, val))\n+  if (!valprint_check_validity (stream, real_type, 0, value))\n     return;\n \n   if (!options->raw)\n     {\n-      struct value *v = full_value;\n-\n-      if (v == nullptr)\n-\tv = value_from_component (val, type, embedded_offset);\n-\n-      ret = apply_ext_lang_val_pretty_printer (v, stream, recurse, options,\n+      ret = apply_ext_lang_val_pretty_printer (value, stream, recurse, options,\n \t\t\t\t\t       language);\n       if (ret)\n \treturn;\n@@ -1305,13 +994,7 @@ do_val_print (struct value *full_value,\n \n   try\n     {\n-      if (full_value != nullptr && language->la_value_print_inner != nullptr)\n-\tlanguage->la_value_print_inner (full_value, stream, recurse,\n-\t\t\t\t\t&local_opts);\n-      else\n-\tlanguage->la_val_print (type, embedded_offset, address,\n-\t\t\t\tstream, recurse, val,\n-\t\t\t\t&local_opts);\n+      language->la_value_print_inner (value, stream, recurse, &local_opts);\n     }\n   catch (const gdb_exception_error &except)\n     {\n@@ -1320,36 +1003,6 @@ do_val_print (struct value *full_value,\n     }\n }\n \n-/* Print using the given LANGUAGE the data of type TYPE located at\n-   VAL's contents buffer + EMBEDDED_OFFSET (within GDB), which came\n-   from the inferior at address ADDRESS + EMBEDDED_OFFSET, onto\n-   stdio stream STREAM according to OPTIONS.  VAL is the whole object\n-   that came from ADDRESS.\n-\n-   The language printers will pass down an adjusted EMBEDDED_OFFSET to\n-   further helper subroutines as subfields of TYPE are printed.  In\n-   such cases, VAL is passed down unadjusted, so\n-   that VAL can be queried for metadata about the contents data being\n-   printed, using EMBEDDED_OFFSET as an offset into VAL's contents\n-   buffer.  For example: \"has this field been optimized out\", or \"I'm\n-   printing an object while inspecting a traceframe; has this\n-   particular piece of data been collected?\".\n-\n-   RECURSE indicates the amount of indentation to supply before\n-   continuation lines; this amount is roughly twice the value of\n-   RECURSE.  */\n-\n-void\n-val_print (struct type *type, LONGEST embedded_offset,\n-\t   CORE_ADDR address, struct ui_file *stream, int recurse,\n-\t   struct value *val,\n-\t   const struct value_print_options *options,\n-\t   const struct language_defn *language)\n-{\n-  do_val_print (nullptr, type, embedded_offset, address, stream,\n-\t\trecurse, val, options, language);\n-}\n-\n /* See valprint.h.  */\n \n bool\n@@ -1434,9 +1087,6 @@ common_val_print (struct value *val, struct ui_file *stream, int recurse,\n \t\t  const struct value_print_options *options,\n \t\t  const struct language_defn *language)\n {\n-  if (!value_check_printable (val, stream, options))\n-    return;\n-\n   if (language->la_language == language_ada)\n     /* The value might have a dynamic type, which would cause trouble\n        below when trying to extract the value contents (since the value\n@@ -1447,10 +1097,7 @@ common_val_print (struct value *val, struct ui_file *stream, int recurse,\n   if (value_lazy (val))\n     value_fetch_lazy (val);\n \n-  do_val_print (val, value_type (val),\n-\t\tvalue_embedded_offset (val), value_address (val),\n-\t\tstream, recurse,\n-\t\tval, options, language);\n+  do_val_print (val, stream, recurse, options, language);\n }\n \n /* See valprint.h.  */\n@@ -1543,57 +1190,6 @@ val_print_type_code_flags (struct type *type, struct value *original_value,\n   fputs_filtered (\" ]\", stream);\n }\n \n-/* Print a scalar of data of type TYPE, pointed to in GDB by VALADDR,\n-   according to OPTIONS and SIZE on STREAM.  Format i is not supported\n-   at this level.\n-\n-   This is how the elements of an array or structure are printed\n-   with a format.  */\n-\n-void\n-val_print_scalar_formatted (struct type *type,\n-\t\t\t    LONGEST embedded_offset,\n-\t\t\t    struct value *val,\n-\t\t\t    const struct value_print_options *options,\n-\t\t\t    int size,\n-\t\t\t    struct ui_file *stream)\n-{\n-  struct gdbarch *arch = get_type_arch (type);\n-  int unit_size = gdbarch_addressable_memory_unit_size (arch);\n-\n-  gdb_assert (val != NULL);\n-\n-  /* If we get here with a string format, try again without it.  Go\n-     all the way back to the language printers, which may call us\n-     again.  */\n-  if (options->format == 's')\n-    {\n-      struct value_print_options opts = *options;\n-      opts.format = 0;\n-      opts.deref_ref = 0;\n-      val_print (type, embedded_offset, 0, stream, 0, val, &opts,\n-\t\t current_language);\n-      return;\n-    }\n-\n-  /* value_contents_for_printing fetches all VAL's contents.  They are\n-     needed to check whether VAL is optimized-out or unavailable\n-     below.  */\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n-\n-  /* A scalar object that does not have all bits available can't be\n-     printed, because all bits contribute to its representation.  */\n-  if (value_bits_any_optimized_out (val,\n-\t\t\t\t    TARGET_CHAR_BIT * embedded_offset,\n-\t\t\t\t    TARGET_CHAR_BIT * TYPE_LENGTH (type)))\n-    val_print_optimized_out (val, stream);\n-  else if (!value_bytes_available (val, embedded_offset, TYPE_LENGTH (type)))\n-    val_print_unavailable (stream);\n-  else\n-    print_scalar_formatted (valaddr + embedded_offset * unit_size, type,\n-\t\t\t    options, size, stream);\n-}\n-\n /* See valprint.h.  */\n \n void\n@@ -2275,144 +1871,6 @@ maybe_print_array_index (struct type *index_type, LONGEST index,\n   LA_PRINT_ARRAY_INDEX (index_value, stream, options);\n }\n \n-/*  Called by various <lang>_val_print routines to print elements of an\n-   array in the form \"<elem1>, <elem2>, <elem3>, ...\".\n-\n-   (FIXME?)  Assumes array element separator is a comma, which is correct\n-   for all languages currently handled.\n-   (FIXME?)  Some languages have a notation for repeated array elements,\n-   perhaps we should try to use that notation when appropriate.  */\n-\n-void\n-val_print_array_elements (struct type *type,\n-\t\t\t  LONGEST embedded_offset,\n-\t\t\t  CORE_ADDR address, struct ui_file *stream,\n-\t\t\t  int recurse,\n-\t\t\t  struct value *val,\n-\t\t\t  const struct value_print_options *options,\n-\t\t\t  unsigned int i)\n-{\n-  unsigned int things_printed = 0;\n-  unsigned len;\n-  struct type *elttype, *index_type, *base_index_type;\n-  unsigned eltlen;\n-  /* Position of the array element we are examining to see\n-     whether it is repeated.  */\n-  unsigned int rep1;\n-  /* Number of repetitions we have detected so far.  */\n-  unsigned int reps;\n-  LONGEST low_bound, high_bound;\n-  LONGEST low_pos, high_pos;\n-\n-  elttype = TYPE_TARGET_TYPE (type);\n-  eltlen = type_length_units (check_typedef (elttype));\n-  index_type = TYPE_INDEX_TYPE (type);\n-\n-  if (get_array_bounds (type, &low_bound, &high_bound))\n-    {\n-      if (TYPE_CODE (index_type) == TYPE_CODE_RANGE)\n-\tbase_index_type = TYPE_TARGET_TYPE (index_type);\n-      else\n-\tbase_index_type = index_type;\n-\n-      /* Non-contiguous enumerations types can by used as index types\n-\t in some languages (e.g. Ada).  In this case, the array length\n-\t shall be computed from the positions of the first and last\n-\t literal in the enumeration type, and not from the values\n-\t of these literals.  */\n-      if (!discrete_position (base_index_type, low_bound, &low_pos)\n-\t  || !discrete_position (base_index_type, high_bound, &high_pos))\n-\t{\n-\t  warning (_(\"unable to get positions in array, use bounds instead\"));\n-\t  low_pos = low_bound;\n-\t  high_pos = high_bound;\n-\t}\n-\n-      /* The array length should normally be HIGH_POS - LOW_POS + 1.\n-         But we have to be a little extra careful, because some languages\n-\t such as Ada allow LOW_POS to be greater than HIGH_POS for\n-\t empty arrays.  In that situation, the array length is just zero,\n-\t not negative!  */\n-      if (low_pos > high_pos)\n-\tlen = 0;\n-      else\n-\tlen = high_pos - low_pos + 1;\n-    }\n-  else\n-    {\n-      warning (_(\"unable to get bounds of array, assuming null array\"));\n-      low_bound = 0;\n-      len = 0;\n-    }\n-\n-  annotate_array_section_begin (i, elttype);\n-\n-  for (; i < len && things_printed < options->print_max; i++)\n-    {\n-      if (i != 0)\n-\t{\n-\t  if (options->prettyformat_arrays)\n-\t    {\n-\t      fprintf_filtered (stream, \",\\n\");\n-\t      print_spaces_filtered (2 + 2 * recurse, stream);\n-\t    }\n-\t  else\n-\t    {\n-\t      fprintf_filtered (stream, \", \");\n-\t    }\n-\t}\n-      wrap_here (n_spaces (2 + 2 * recurse));\n-      maybe_print_array_index (index_type, i + low_bound,\n-                               stream, options);\n-\n-      rep1 = i + 1;\n-      reps = 1;\n-      /* Only check for reps if repeat_count_threshold is not set to\n-\t UINT_MAX (unlimited).  */\n-      if (options->repeat_count_threshold < UINT_MAX)\n-\t{\n-\t  while (rep1 < len\n-\t\t && value_contents_eq (val,\n-\t\t\t\t       embedded_offset + i * eltlen,\n-\t\t\t\t       val,\n-\t\t\t\t       (embedded_offset\n-\t\t\t\t\t+ rep1 * eltlen),\n-\t\t\t\t       eltlen))\n-\t    {\n-\t      ++reps;\n-\t      ++rep1;\n-\t    }\n-\t}\n-\n-      if (reps > options->repeat_count_threshold)\n-\t{\n-\t  val_print (elttype, embedded_offset + i * eltlen,\n-\t\t     address, stream, recurse + 1, val, options,\n-\t\t     current_language);\n-\t  annotate_elt_rep (reps);\n-\t  fprintf_filtered (stream, \" %p[<repeats %u times>%p]\",\n-\t\t\t    metadata_style.style ().ptr (), reps, nullptr);\n-\t  annotate_elt_rep_end ();\n-\n-\t  i = rep1 - 1;\n-\t  things_printed += options->repeat_count_threshold;\n-\t}\n-      else\n-\t{\n-\t  val_print (elttype, embedded_offset + i * eltlen,\n-\t\t     address,\n-\t\t     stream, recurse + 1, val, options, current_language);\n-\t  annotate_elt ();\n-\t  things_printed++;\n-\t}\n-    }\n-  annotate_array_section_end ();\n-  if (i < len)\n-    {\n-      fprintf_filtered (stream, \"...\");\n-    }\n-}\n-\n /* See valprint.h.  */\n \n void"
    },
    {
      "sha": "57bc0339fcb7ce7e3bf3f27edae57a104f64015f",
      "filename": "gdb/valprint.h",
      "status": "modified",
      "additions": 0,
      "deletions": 19,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/valprint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/valprint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -128,25 +128,13 @@ extern void maybe_print_array_index (struct type *index_type, LONGEST index,\n                                      struct ui_file *stream,\n \t\t\t\t     const struct value_print_options *);\n \n-extern void val_print_array_elements (struct type *, LONGEST,\n-\t\t\t\t      CORE_ADDR, struct ui_file *, int,\n-\t\t\t\t      struct value *,\n-\t\t\t\t      const struct value_print_options *,\n-\t\t\t\t      unsigned int);\n \n /* Print elements of an array.  */\n \n extern void value_print_array_elements (struct value *, struct ui_file *, int,\n \t\t\t\t\tconst struct value_print_options *,\n \t\t\t\t\tunsigned int);\n \n-extern void val_print_scalar_formatted (struct type *,\n-\t\t\t\t\tLONGEST,\n-\t\t\t\t\tstruct value *,\n-\t\t\t\t\tconst struct value_print_options *,\n-\t\t\t\t\tint,\n-\t\t\t\t\tstruct ui_file *);\n-\n /* Print a scalar according to OPTIONS and SIZE on STREAM.  Format 'i'\n    is not supported at this level.\n \n@@ -220,13 +208,6 @@ struct generic_val_print_decorations\n };\n \n \n-extern void generic_val_print (struct type *type,\n-\t\t\t       int embedded_offset, CORE_ADDR address,\n-\t\t\t       struct ui_file *stream, int recurse,\n-\t\t\t       struct value *original_value,\n-\t\t\t       const struct value_print_options *options,\n-\t\t\t       const struct generic_val_print_decorations *);\n-\n /* Print a value in a generic way.  VAL is the value, STREAM is where\n    to print it, RECURSE is the recursion depth, OPTIONS describe how\n    the printing should be done, and D is the language-specific"
    },
    {
      "sha": "e4fd258aa8f43025904f9fbcb0ad39af4f2f7cf9",
      "filename": "gdb/value.h",
      "status": "modified",
      "additions": 0,
      "deletions": 7,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/value.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/426a9c18dddcdd5f640b702734dd8f9c108b7372/gdb/value.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.h?ref=426a9c18dddcdd5f640b702734dd8f9c108b7372",
      "patch": "@@ -1097,13 +1097,6 @@ extern void value_print_array_elements (struct value *val,\n extern std::vector<value_ref_ptr> value_release_to_mark\n     (const struct value *mark);\n \n-extern void val_print (struct type *type,\n-\t\t       LONGEST embedded_offset, CORE_ADDR address,\n-\t\t       struct ui_file *stream, int recurse,\n-\t\t       struct value *val,\n-\t\t       const struct value_print_options *options,\n-\t\t       const struct language_defn *language);\n-\n extern void common_val_print (struct value *val,\n \t\t\t      struct ui_file *stream, int recurse,\n \t\t\t      const struct value_print_options *options,"
    }
  ]
}