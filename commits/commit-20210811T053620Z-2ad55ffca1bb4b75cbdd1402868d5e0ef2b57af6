{
  "sha": "2ad55ffca1bb4b75cbdd1402868d5e0ef2b57af6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmFkNTVmZmNhMWJiNGI3NWNiZGQxNDAyODY4ZDVlMGVmMmI1N2FmNg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-08-11T05:36:20Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-08-11T05:36:20Z"
    },
    "message": "PR28163, Segment fault in function rl78_special_reloc\n\nRelocation offset checks were completely missing in the rl78 backend,\nallowing a relocation to write over memory anywhere.  This was true\nfor rl78_special_reloc, a function primarily used when applying debug\nrelocations, and in rl78_elf_relocate_section used by the linker.\n\nThis patch fixes those problems by correcting inaccuracies in the\nrelocation howtos, then uses those howtos to sanity check relocation\noffsets before applying relocations.  In addition, the patch\nimplements overflow checking using the howto information rather than\nthe ad-hoc scheme implemented in relocate_section.  I implemented the\noverflow checking in rl78_special_reloc too.\n\n\t* elf32-rl78.c (RL78REL, RL78_OP_REL): Add mask parameter.\n\t(rl78_elf_howto_table): Set destination masks.  Correct size and\n\tbitsize of DIR32_REV.  Correct complain_on_overflow for many relocs\n\tas per tests in relocate_section.  Add RH_SFR.  Correct bitsize\n\tfor RH_SADDR.  Set size to 3 and bitsize to 0 for all OP relocs.\n\t(check_overflow): New function.\n\t(rl78_special_reloc): Check that reloc address is within section.\n\tApply relocations using reloc howto.  Check for overflow.\n\t(RANGE): Delete.\n\t(rl78_elf_relocate_section): Sanity check r_offset.  Perform\n\toverflow checking using reloc howto.",
    "tree": {
      "sha": "2e4b8ddb7eaff71bb8b1c7468bd1917f979ac429",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2e4b8ddb7eaff71bb8b1c7468bd1917f979ac429"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2ad55ffca1bb4b75cbdd1402868d5e0ef2b57af6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2ad55ffca1bb4b75cbdd1402868d5e0ef2b57af6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2ad55ffca1bb4b75cbdd1402868d5e0ef2b57af6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2ad55ffca1bb4b75cbdd1402868d5e0ef2b57af6/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c0e94211e1ac05049a4ce7c192c9d14d1764eb3e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c0e94211e1ac05049a4ce7c192c9d14d1764eb3e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c0e94211e1ac05049a4ce7c192c9d14d1764eb3e"
    }
  ],
  "stats": {
    "total": 725,
    "additions": 360,
    "deletions": 365
  },
  "files": [
    {
      "sha": "489656a800b76a11502b2d03c8f693abb4a4f179",
      "filename": "bfd/elf32-rl78.c",
      "status": "modified",
      "additions": 360,
      "deletions": 365,
      "changes": 725,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2ad55ffca1bb4b75cbdd1402868d5e0ef2b57af6/bfd/elf32-rl78.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2ad55ffca1bb4b75cbdd1402868d5e0ef2b57af6/bfd/elf32-rl78.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rl78.c?ref=2ad55ffca1bb4b75cbdd1402868d5e0ef2b57af6",
      "patch": "@@ -27,43 +27,42 @@\n \n #define valid_16bit_address(v) ((v) <= 0x0ffff || (v) >= 0xf0000)\n \n-#define RL78REL(n,sz,bit,shift,complain,pcrel)\t\t\t\t     \\\n+#define RL78REL(n,sz,bit,mask,shift,complain,pcrel) \\\n   HOWTO (R_RL78_##n, shift, sz, bit, pcrel, 0, complain_overflow_ ## complain, \\\n-\t bfd_elf_generic_reloc, \"R_RL78_\" #n, false, 0, ~0, false)\n+\t bfd_elf_generic_reloc, \"R_RL78_\" #n, false, 0, mask, false)\n \n static bfd_reloc_status_type rl78_special_reloc (bfd *, arelent *, asymbol *, void *,\n \t\t\t\t\t\t asection *, bfd *, char **);\n \n-/* FIXME: We could omit the SHIFT parameter, it is always zero.  */\n-#define RL78_OP_REL(n,sz,bit,shift,complain,pcrel)\t\t\t\\\n+#define RL78_OP_REL(n,sz,bit,mask,shift,complain,pcrel)\t\t\t\\\n   HOWTO (R_RL78_##n, shift, sz, bit, pcrel, 0, complain_overflow_ ## complain, \\\n-\t rl78_special_reloc, \"R_RL78_\" #n, false, 0, ~0, false)\n+\t rl78_special_reloc, \"R_RL78_\" #n, false, 0, mask, false)\n \n /* Note that the relocations around 0x7f are internal to this file;\n    feel free to move them as needed to avoid conflicts with published\n    relocation numbers.  */\n \n static reloc_howto_type rl78_elf_howto_table [] =\n {\n-  RL78REL (NONE,\t 3,  0, 0, dont,     false),\n-  RL78REL (DIR32,\t 2, 32, 0, signed,   false),\n-  RL78REL (DIR24S,\t 2, 24, 0, signed,   false),\n-  RL78REL (DIR16,\t 1, 16, 0, dont,     false),\n-  RL78REL (DIR16U,\t 1, 16, 0, unsigned, false),\n-  RL78REL (DIR16S,\t 1, 16, 0, signed,   false),\n-  RL78REL (DIR8,\t 0,  8, 0, dont,     false),\n-  RL78REL (DIR8U,\t 0,  8, 0, unsigned, false),\n-  RL78REL (DIR8S,\t 0,  8, 0, signed,   false),\n-  RL78REL (DIR24S_PCREL, 2, 24, 0, signed,   true),\n-  RL78REL (DIR16S_PCREL, 1, 16, 0, signed,   true),\n-  RL78REL (DIR8S_PCREL,\t 0,  8, 0, signed,   true),\n-  RL78REL (DIR16UL,\t 1, 16, 2, unsigned, false),\n-  RL78REL (DIR16UW,\t 1, 16, 1, unsigned, false),\n-  RL78REL (DIR8UL,\t 0,  8, 2, unsigned, false),\n-  RL78REL (DIR8UW,\t 0,  8, 1, unsigned, false),\n-  RL78REL (DIR32_REV,\t 1, 16, 0, dont,     false),\n-  RL78REL (DIR16_REV,\t 1, 16, 0, dont,     false),\n-  RL78REL (DIR3U_PCREL,\t 0,  3, 0, dont,     true),\n+  RL78REL (NONE,\t 3,  0, 0,          0, dont,     false),\n+  RL78REL (DIR32,\t 2, 32, 0xffffffff, 0, dont,     false),\n+  RL78REL (DIR24S,\t 2, 24, 0xffffff,   0, signed,   false),\n+  RL78REL (DIR16,\t 1, 16, 0xffff,     0, bitfield, false),\n+  RL78REL (DIR16U,\t 1, 16, 0xffff,     0, unsigned, false),\n+  RL78REL (DIR16S,\t 1, 16, 0xffff,     0, bitfield, false),\n+  RL78REL (DIR8,\t 0,  8, 0xff,       0, dont,     false),\n+  RL78REL (DIR8U,\t 0,  8, 0xff,       0, unsigned, false),\n+  RL78REL (DIR8S,\t 0,  8, 0xff,       0, bitfield, false),\n+  RL78REL (DIR24S_PCREL, 2, 24, 0xffffff,   0, signed,   true),\n+  RL78REL (DIR16S_PCREL, 1, 16, 0xffff,     0, signed,   true),\n+  RL78REL (DIR8S_PCREL,\t 0,  8, 0xff,       0, signed,   true),\n+  RL78REL (DIR16UL,\t 1, 16, 0xffff,     2, unsigned, false),\n+  RL78REL (DIR16UW,\t 1, 16, 0xffff,     1, unsigned, false),\n+  RL78REL (DIR8UL,\t 0,  8, 0xff,       2, unsigned, false),\n+  RL78REL (DIR8UW,\t 0,  8, 0xff,       1, unsigned, false),\n+  RL78REL (DIR32_REV,\t 2, 32, 0xffffffff, 0, dont,     false),\n+  RL78REL (DIR16_REV,\t 1, 16, 0xffff,     0, bitfield, false),\n+  RL78REL (DIR3U_PCREL,\t 0,  3, 0x7,        0, unsigned, true),\n \n   EMPTY_HOWTO (0x13),\n   EMPTY_HOWTO (0x14),\n@@ -92,10 +91,11 @@ static reloc_howto_type rl78_elf_howto_table [] =\n   EMPTY_HOWTO (0x2a),\n   EMPTY_HOWTO (0x2b),\n   EMPTY_HOWTO (0x2c),\n-  RL78REL (RH_RELAX, 0,\t 0, 0, dont,\t false),\n \n-  EMPTY_HOWTO (0x2e),\n-  RL78REL (RH_SADDR, 0,\t 0, 0, dont,\t false),\n+  RL78REL (RH_RELAX,\t 3,  0, 0,          0, dont,\t false),\n+  RL78REL (RH_SFR,\t 0,  8, 0xff,       0, unsigned, false),\n+  RL78REL (RH_SADDR,\t 0,  8, 0xff,       0, unsigned, false),\n+\n   EMPTY_HOWTO (0x30),\n   EMPTY_HOWTO (0x31),\n   EMPTY_HOWTO (0x32),\n@@ -114,23 +114,23 @@ static reloc_howto_type rl78_elf_howto_table [] =\n   EMPTY_HOWTO (0x3f),\n   EMPTY_HOWTO (0x40),\n \n-  RL78_OP_REL (ABS32,\t     2, 32, 0, dont,\t false),\n-  RL78_OP_REL (ABS24S,\t     2, 24, 0, signed,\t false),\n-  RL78_OP_REL (ABS16,\t     1, 16, 0, dont,\t false),\n-  RL78_OP_REL (ABS16U,\t     1, 16, 0, unsigned, false),\n-  RL78_OP_REL (ABS16S,\t     1, 16, 0, signed,\t false),\n-  RL78_OP_REL (ABS8,\t     0,\t 8, 0, dont,\t false),\n-  RL78_OP_REL (ABS8U,\t     0,\t 8, 0, unsigned, false),\n-  RL78_OP_REL (ABS8S,\t     0,\t 8, 0, signed,\t false),\n-  RL78_OP_REL (ABS24S_PCREL, 2, 24, 0, signed,\t true),\n-  RL78_OP_REL (ABS16S_PCREL, 1, 16, 0, signed,\t true),\n-  RL78_OP_REL (ABS8S_PCREL,  0,\t 8, 0, signed,\t true),\n-  RL78_OP_REL (ABS16UL,\t     1, 16, 0, unsigned, false),\n-  RL78_OP_REL (ABS16UW,\t     1, 16, 0, unsigned, false),\n-  RL78_OP_REL (ABS8UL,\t     0,\t 8, 0, unsigned, false),\n-  RL78_OP_REL (ABS8UW,\t     0,\t 8, 0, unsigned, false),\n-  RL78_OP_REL (ABS32_REV,    2, 32, 0, dont,\t false),\n-  RL78_OP_REL (ABS16_REV,    1, 16, 0, dont,\t false),\n+  RL78_OP_REL (ABS32,\t     2, 32, 0xffffffff, 0, dont,\tfalse),\n+  RL78_OP_REL (ABS24S,\t     2, 24, 0xffffff,   0, signed,\tfalse),\n+  RL78_OP_REL (ABS16,\t     1, 16, 0xffff,     0, bitfield,\tfalse),\n+  RL78_OP_REL (ABS16U,\t     1, 16, 0xffff,     0, unsigned,\tfalse),\n+  RL78_OP_REL (ABS16S,\t     1, 16, 0xffff,     0, signed,\tfalse),\n+  RL78_OP_REL (ABS8,\t     0,\t 8, 0xff,       0, bitfield,\tfalse),\n+  RL78_OP_REL (ABS8U,\t     0,\t 8, 0xff,       0, unsigned,\tfalse),\n+  RL78_OP_REL (ABS8S,\t     0,\t 8, 0xff,       0, signed,\tfalse),\n+  RL78_OP_REL (ABS24S_PCREL, 2, 24, 0xffffff,   0, signed,\ttrue),\n+  RL78_OP_REL (ABS16S_PCREL, 1, 16, 0xffff,     0, signed,\ttrue),\n+  RL78_OP_REL (ABS8S_PCREL,  0,\t 8, 0xff,       0, signed,\ttrue),\n+  RL78_OP_REL (ABS16UL,\t     1, 16, 0xffff,     0, unsigned,\tfalse),\n+  RL78_OP_REL (ABS16UW,\t     1, 16, 0xffff,     0, unsigned,\tfalse),\n+  RL78_OP_REL (ABS8UL,\t     0,\t 8, 0xff,       0, unsigned,\tfalse),\n+  RL78_OP_REL (ABS8UW,\t     0,\t 8, 0xff,       0, unsigned,\tfalse),\n+  RL78_OP_REL (ABS32_REV,    2, 32, 0xffffffff, 0, dont,\tfalse),\n+  RL78_OP_REL (ABS16_REV,    1, 16, 0xffff,     0, bitfield,\tfalse),\n \n #define STACK_REL_P(x) ((x) <= R_RL78_ABS16_REV && (x) >= R_RL78_ABS32)\n \n@@ -182,29 +182,29 @@ static reloc_howto_type rl78_elf_howto_table [] =\n   EMPTY_HOWTO (0x7e),\n   EMPTY_HOWTO (0x7f),\n \n-  RL78_OP_REL (SYM,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPneg,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPadd,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPsub,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPmul,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPdiv,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPshla,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPshra,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPsctsize, 2, 32, 0, dont, false),\n+  RL78_OP_REL (SYM,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPneg,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPadd,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPsub,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPmul,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPdiv,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPshla,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPshra,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPsctsize, 3, 0, 0, 0, dont, false),\n   EMPTY_HOWTO (0x89),\n   EMPTY_HOWTO (0x8a),\n   EMPTY_HOWTO (0x8b),\n   EMPTY_HOWTO (0x8c),\n-  RL78_OP_REL (OPscttop,  2, 32, 0, dont, false),\n+  RL78_OP_REL (OPscttop,  3, 0, 0, 0, dont, false),\n   EMPTY_HOWTO (0x8e),\n   EMPTY_HOWTO (0x8f),\n-  RL78_OP_REL (OPand,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPor,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPxor,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPnot,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPmod,\t  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPromtop,  2, 32, 0, dont, false),\n-  RL78_OP_REL (OPramtop,  2, 32, 0, dont, false)\n+  RL78_OP_REL (OPand,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPor,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPxor,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPnot,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPmod,\t  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPromtop,  3, 0, 0, 0, dont, false),\n+  RL78_OP_REL (OPramtop,  3, 0, 0, 0, dont, false)\n };\n \f\n /* Map BFD reloc types to RL78 ELF reloc types.  */\n@@ -559,7 +559,36 @@ rl78_compute_complex_reloc (unsigned long  r_type,\n   return relocation;\n }\n \n-#define OP(i)      (contents[reloc->address + (i)])\n+/* Check whether RELOCATION overflows a relocation field described by\n+   HOWTO.  */\n+\n+static bfd_reloc_status_type\n+check_overflow (reloc_howto_type *howto, bfd_vma relocation)\n+{\n+  switch (howto->complain_on_overflow)\n+    {\n+    case complain_overflow_dont:\n+      break;\n+\n+    case complain_overflow_bitfield:\n+      if ((bfd_signed_vma) relocation < -(1LL << (howto->bitsize - 1))\n+\t  || (bfd_signed_vma) relocation >= 1LL << howto->bitsize)\n+\treturn bfd_reloc_overflow;\n+      break;\n+\n+    case complain_overflow_signed:\n+      if ((bfd_signed_vma) relocation < -(1LL << (howto->bitsize - 1))\n+\t  || (bfd_signed_vma) relocation >= 1LL << (howto->bitsize - 1))\n+\treturn bfd_reloc_overflow;\n+      break;\n+\n+    case complain_overflow_unsigned:\n+      if (relocation >= 1ULL << howto->bitsize)\n+\treturn bfd_reloc_overflow;\n+      break;\n+    }\n+  return bfd_reloc_ok;\n+}\n \n static bfd_reloc_status_type\n rl78_special_reloc (bfd *      input_bfd,\n@@ -600,67 +629,42 @@ rl78_special_reloc (bfd *      input_bfd,\n   relocation = rl78_compute_complex_reloc (r_type, relocation, input_section,\n \t\t\t\t\t   &r, error_message);\n \n-  /* If the relocation alters the contents of the section then apply it now.\n-     Note - since this function is called from\n-     bfd_generic_get_relocated_section_contents via bfd_perform_relocation,\n-     and not from the linker, we do not perform any range checking.  The\n-     clients who are calling us are only interested in some relocated section\n-     contents, and not any linkage problems that might occur later.  */\n-  switch (r_type)\n+  if (STACK_REL_P (r_type))\n     {\n-    case R_RL78_ABS32:\n-      OP (0) = relocation;\n-      OP (1) = relocation >> 8;\n-      OP (2) = relocation >> 16;\n-      OP (3) = relocation >> 24;\n-      break;\n-\n-    case R_RL78_ABS32_REV:\n-      OP (3) = relocation;\n-      OP (2) = relocation >> 8;\n-      OP (1) = relocation >> 16;\n-      OP (0) = relocation >> 24;\n-      break;\n-\n-    case R_RL78_ABS24S_PCREL:\n-    case R_RL78_ABS24S:\n-      OP (0) = relocation;\n-      OP (1) = relocation >> 8;\n-      OP (2) = relocation >> 16;\n-      break;\n-\n-    case R_RL78_ABS16_REV:\n-      OP (1) = relocation;\n-      OP (0) = relocation >> 8;\n-      break;\n-\n-    case R_RL78_ABS16S_PCREL:\n-    case R_RL78_ABS16:\n-    case R_RL78_ABS16S:\n-    case R_RL78_ABS16U:\n-    case R_RL78_ABS16UL:\n-    case R_RL78_ABS16UW:\n-      OP (0) = relocation;\n-      OP (1) = relocation >> 8;\n-      break;\n-\n-    case R_RL78_ABS8S_PCREL:\n-    case R_RL78_ABS8:\n-    case R_RL78_ABS8U:\n-    case R_RL78_ABS8UL:\n-    case R_RL78_ABS8UW:\n-    case R_RL78_ABS8S:\n-      OP (0) = relocation;\n-      break;\n+      bfd_size_type limit;\n+      unsigned int nbytes;\n+\n+      if (r == bfd_reloc_ok)\n+\tr = check_overflow (reloc->howto, relocation);\n+\n+      if (r_type == R_RL78_ABS16_REV)\n+\trelocation = ((relocation & 0xff) << 8) | ((relocation >> 8) & 0xff);\n+      else if (r_type == R_RL78_ABS32_REV)\n+\trelocation = (((relocation & 0xff) << 24)\n+\t\t      | ((relocation & 0xff00) << 8)\n+\t\t      | ((relocation >> 8) & 0xff00)\n+\t\t      | ((relocation >> 24) & 0xff));\n+\n+      limit = bfd_get_section_limit_octets (input_bfd, input_section);\n+      nbytes = reloc->howto->bitsize / 8;\n+      if (reloc->address < limit\n+\t  && nbytes <= limit - reloc->address)\n+\t{\n+\t  unsigned int i;\n \n-    default:\n-      break;\n+\t  for (i = 0; i < nbytes; i++)\n+\t    {\n+\t      contents[reloc->address + i] = relocation;\n+\t      relocation >>= 8;\n+\t    }\n+\t}\n+      else\n+\tr = bfd_reloc_outofrange;\n     }\n \n   return r;\n }\n \n-#undef  OP\n #define OP(i)      (contents[rel->r_offset + (i)])\n \n /* Relocate an RL78 ELF section.\n@@ -848,256 +852,247 @@ rl78_elf_relocate_section\n \t}\n \n       r = bfd_reloc_ok;\n+      if (howto->bitsize != 0\n+\t  && (rel->r_offset >= input_section->size\n+\t      || ((howto->bitsize + 7u) / 8\n+\t\t  > input_section->size - rel->r_offset)))\n+\tr = bfd_reloc_outofrange;\n+      else\n+\tswitch (r_type)\n+\t  {\n+\t  case R_RL78_NONE:\n+\t    break;\n+\n+\t  case R_RL78_RH_RELAX:\n+\t    break;\n+\n+\t  case R_RL78_DIR8S_PCREL:\n+\t    OP (0) = relocation;\n+\t    break;\n+\n+\t  case R_RL78_DIR8S:\n+\t    OP (0) = relocation;\n+\t    break;\n+\n+\t  case R_RL78_DIR8U:\n+\t    OP (0) = relocation;\n+\t    break;\n+\n+\t  case R_RL78_DIR16S_PCREL:\n+\t    OP (0) = relocation;\n+\t    OP (1) = relocation >> 8;\n+\t    break;\n+\n+\t  case R_RL78_DIR16S:\n+\t    if ((relocation & 0xf0000) == 0xf0000)\n+\t      relocation &= 0xffff;\n+\t    OP (0) = relocation;\n+\t    OP (1) = relocation >> 8;\n+\t    break;\n+\n+\t  case R_RL78_DIR16U:\n+\t    OP (0) = relocation;\n+\t    OP (1) = relocation >> 8;\n+\t    break;\n+\n+\t  case R_RL78_DIR16:\n+\t    OP (0) = relocation;\n+\t    OP (1) = relocation >> 8;\n+\t    break;\n+\n+\t  case R_RL78_DIR16_REV:\n+\t    OP (1) = relocation;\n+\t    OP (0) = relocation >> 8;\n+\t    break;\n+\n+\t  case R_RL78_DIR3U_PCREL:\n+\t    OP (0) &= 0xf8;\n+\t    OP (0) |= relocation & 0x07;\n+\t    /* Map [3, 10] to [0, 7].  The code below using howto\n+\t       bitsize will check for unsigned overflow.  */\n+\t    relocation -= 3;\n+\t    break;\n+\n+\t  case R_RL78_DIR24S_PCREL:\n+\t    OP (0) = relocation;\n+\t    OP (1) = relocation >> 8;\n+\t    OP (2) = relocation >> 16;\n+\t    break;\n+\n+\t  case R_RL78_DIR24S:\n+\t    OP (0) = relocation;\n+\t    OP (1) = relocation >> 8;\n+\t    OP (2) = relocation >> 16;\n+\t    break;\n+\n+\t  case R_RL78_DIR32:\n+\t    OP (0) = relocation;\n+\t    OP (1) = relocation >> 8;\n+\t    OP (2) = relocation >> 16;\n+\t    OP (3) = relocation >> 24;\n+\t    break;\n+\n+\t  case R_RL78_DIR32_REV:\n+\t    OP (3) = relocation;\n+\t    OP (2) = relocation >> 8;\n+\t    OP (1) = relocation >> 16;\n+\t    OP (0) = relocation >> 24;\n+\t    break;\n+\n+\t  case R_RL78_RH_SFR:\n+\t    relocation -= 0xfff00;\n+\t    OP (0) = relocation;\n+\t    break;\n+\n+\t  case R_RL78_RH_SADDR:\n+\t    relocation -= 0xffe20;\n+\t    OP (0) = relocation;\n+\t    break;\n+\n+\t    /* Complex reloc handling:  */\n+\t  case R_RL78_ABS32:\n+\t  case R_RL78_ABS32_REV:\n+\t  case R_RL78_ABS24S_PCREL:\n+\t  case R_RL78_ABS24S:\n+\t  case R_RL78_ABS16:\n+\t  case R_RL78_ABS16_REV:\n+\t  case R_RL78_ABS16S_PCREL:\n+\t  case R_RL78_ABS16S:\n+\t  case R_RL78_ABS16U:\n+\t  case R_RL78_ABS16UL:\n+\t  case R_RL78_ABS16UW:\n+\t  case R_RL78_ABS8:\n+\t  case R_RL78_ABS8U:\n+\t  case R_RL78_ABS8UL:\n+\t  case R_RL78_ABS8UW:\n+\t  case R_RL78_ABS8S_PCREL:\n+\t  case R_RL78_ABS8S:\n+\t  case R_RL78_OPneg:\n+\t  case R_RL78_OPadd:\n+\t  case R_RL78_OPsub:\n+\t  case R_RL78_OPmul:\n+\t  case R_RL78_OPdiv:\n+\t  case R_RL78_OPshla:\n+\t  case R_RL78_OPshra:\n+\t  case R_RL78_OPsctsize:\n+\t  case R_RL78_OPscttop:\n+\t  case R_RL78_OPand:\n+\t  case R_RL78_OPor:\n+\t  case R_RL78_OPxor:\n+\t  case R_RL78_OPnot:\n+\t  case R_RL78_OPmod:\n+\t    relocation = rl78_compute_complex_reloc (r_type, 0, input_section,\n+\t\t\t\t\t\t     &r, &error_message);\n+\n+\t    switch (r_type)\n+\t      {\n+\t      case R_RL78_ABS32:\n+\t\tOP (0) = relocation;\n+\t\tOP (1) = relocation >> 8;\n+\t\tOP (2) = relocation >> 16;\n+\t\tOP (3) = relocation >> 24;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS32_REV:\n+\t\tOP (3) = relocation;\n+\t\tOP (2) = relocation >> 8;\n+\t\tOP (1) = relocation >> 16;\n+\t\tOP (0) = relocation >> 24;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS24S_PCREL:\n+\t      case R_RL78_ABS24S:\n+\t\tOP (0) = relocation;\n+\t\tOP (1) = relocation >> 8;\n+\t\tOP (2) = relocation >> 16;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS16:\n+\t\tOP (0) = relocation;\n+\t\tOP (1) = relocation >> 8;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS16_REV:\n+\t\tOP (1) = relocation;\n+\t\tOP (0) = relocation >> 8;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS16S_PCREL:\n+\t      case R_RL78_ABS16S:\n+\t\tOP (0) = relocation;\n+\t\tOP (1) = relocation >> 8;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS16U:\n+\t      case R_RL78_ABS16UL:\n+\t      case R_RL78_ABS16UW:\n+\t\tOP (0) = relocation;\n+\t\tOP (1) = relocation >> 8;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS8:\n+\t\tOP (0) = relocation;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS8U:\n+\t      case R_RL78_ABS8UL:\n+\t      case R_RL78_ABS8UW:\n+\t\tOP (0) = relocation;\n+\t\tbreak;\n+\n+\t      case R_RL78_ABS8S_PCREL:\n+\t      case R_RL78_ABS8S:\n+\t\tOP (0) = relocation;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t    break;\n+\n+\t  case R_RL78_SYM:\n+\t    if (r_symndx < symtab_hdr->sh_info)\n+\t      relocation = sec->output_section->vma + sec->output_offset\n+\t\t+ sym->st_value + rel->r_addend;\n+\t    else if (h != NULL\n+\t\t     && (h->root.type == bfd_link_hash_defined\n+\t\t\t || h->root.type == bfd_link_hash_defweak))\n+\t      relocation = h->root.u.def.value\n+\t\t+ sec->output_section->vma\n+\t\t+ sec->output_offset\n+\t\t+ rel->r_addend;\n+\t    else\n+\t      {\n+\t\trelocation = 0;\n+\t\tif (h->root.type != bfd_link_hash_undefweak)\n+\t\t  _bfd_error_handler\n+\t\t    (_(\"warning: RL78_SYM reloc with an unknown symbol\"));\n+\t      }\n+\t    (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n+\t\t\t\t\t       &r, &error_message);\n+\t    break;\n+\n+\t  case R_RL78_OPromtop:\n+\t    relocation = get_romstart (info, input_bfd, input_section,\n+\t\t\t\t       rel->r_offset);\n+\t    (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n+\t\t\t\t\t       &r, &error_message);\n+\t    break;\n+\n+\t  case R_RL78_OPramtop:\n+\t    relocation = get_ramstart (info, input_bfd, input_section,\n+\t\t\t\t       rel->r_offset);\n+\t    (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n+\t\t\t\t\t       &r, &error_message);\n+\t    break;\n+\n+\t  default:\n+\t    r = bfd_reloc_notsupported;\n+\t    break;\n+\t  }\n \n-#define RANGE(a,b) if (a > (long) relocation || (long) relocation > b) r = bfd_reloc_overflow\n-\n-      /* Opcode relocs are always big endian.  Data relocs are bi-endian.  */\n-      switch (r_type)\n-\t{\n-\tcase R_RL78_NONE:\n-\t  break;\n-\n-\tcase R_RL78_RH_RELAX:\n-\t  break;\n-\n-\tcase R_RL78_DIR8S_PCREL:\n-\t  RANGE (-128, 127);\n-\t  OP (0) = relocation;\n-\t  break;\n-\n-\tcase R_RL78_DIR8S:\n-\t  RANGE (-128, 255);\n-\t  OP (0) = relocation;\n-\t  break;\n-\n-\tcase R_RL78_DIR8U:\n-\t  RANGE (0, 255);\n-\t  OP (0) = relocation;\n-\t  break;\n-\n-\tcase R_RL78_DIR16S_PCREL:\n-\t  RANGE (-32768, 32767);\n-\t  OP (0) = relocation;\n-\t  OP (1) = relocation >> 8;\n-\t  break;\n-\n-\tcase R_RL78_DIR16S:\n-\t  if ((relocation & 0xf0000) == 0xf0000)\n-\t    relocation &= 0xffff;\n-\t  RANGE (-32768, 65535);\n-\t  OP (0) = relocation;\n-\t  OP (1) = relocation >> 8;\n-\t  break;\n-\n-\tcase R_RL78_DIR16U:\n-\t  RANGE (0, 65536);\n-\t  OP (0) = relocation;\n-\t  OP (1) = relocation >> 8;\n-\t  break;\n-\n-\tcase R_RL78_DIR16:\n-\t  RANGE (-32768, 65536);\n-\t  OP (0) = relocation;\n-\t  OP (1) = relocation >> 8;\n-\t  break;\n-\n-\tcase R_RL78_DIR16_REV:\n-\t  RANGE (-32768, 65536);\n-\t  OP (1) = relocation;\n-\t  OP (0) = relocation >> 8;\n-\t  break;\n-\n-\tcase R_RL78_DIR3U_PCREL:\n-\t  RANGE (3, 10);\n-\t  OP (0) &= 0xf8;\n-\t  OP (0) |= relocation & 0x07;\n-\t  break;\n-\n-\tcase R_RL78_DIR24S_PCREL:\n-\t  RANGE (-0x800000, 0x7fffff);\n-\t  OP (0) = relocation;\n-\t  OP (1) = relocation >> 8;\n-\t  OP (2) = relocation >> 16;\n-\t  break;\n-\n-\tcase R_RL78_DIR24S:\n-\t  RANGE (-0x800000, 0x7fffff);\n-\t  OP (0) = relocation;\n-\t  OP (1) = relocation >> 8;\n-\t  OP (2) = relocation >> 16;\n-\t  break;\n-\n-\tcase R_RL78_DIR32:\n-\t  OP (0) = relocation;\n-\t  OP (1) = relocation >> 8;\n-\t  OP (2) = relocation >> 16;\n-\t  OP (3) = relocation >> 24;\n-\t  break;\n-\n-\tcase R_RL78_DIR32_REV:\n-\t  OP (3) = relocation;\n-\t  OP (2) = relocation >> 8;\n-\t  OP (1) = relocation >> 16;\n-\t  OP (0) = relocation >> 24;\n-\t  break;\n-\n-\tcase R_RL78_RH_SFR:\n-\t  RANGE (0xfff00, 0xfffff);\n-\t  OP (0) = relocation & 0xff;\n-\t  break;\n-\n-\tcase R_RL78_RH_SADDR:\n-\t  RANGE (0xffe20, 0xfff1f);\n-\t  OP (0) = (relocation - 0x20) & 0xff;\n-\t  break;\n-\n-\t  /* Complex reloc handling:  */\n-\tcase R_RL78_ABS32:\n-\tcase R_RL78_ABS32_REV:\n-\tcase R_RL78_ABS24S_PCREL:\n-\tcase R_RL78_ABS24S:\n-\tcase R_RL78_ABS16:\n-\tcase R_RL78_ABS16_REV:\n-\tcase R_RL78_ABS16S_PCREL:\n-\tcase R_RL78_ABS16S:\n-\tcase R_RL78_ABS16U:\n-\tcase R_RL78_ABS16UL:\n-\tcase R_RL78_ABS16UW:\n-\tcase R_RL78_ABS8:\n-\tcase R_RL78_ABS8U:\n-\tcase R_RL78_ABS8UL:\n-\tcase R_RL78_ABS8UW:\n-\tcase R_RL78_ABS8S_PCREL:\n-\tcase R_RL78_ABS8S:\n-\tcase R_RL78_OPneg:\n-\tcase R_RL78_OPadd:\n-\tcase R_RL78_OPsub:\n-\tcase R_RL78_OPmul:\n-\tcase R_RL78_OPdiv:\n-\tcase R_RL78_OPshla:\n-\tcase R_RL78_OPshra:\n-\tcase R_RL78_OPsctsize:\n-\tcase R_RL78_OPscttop:\n-\tcase R_RL78_OPand:\n-\tcase R_RL78_OPor:\n-\tcase R_RL78_OPxor:\n-\tcase R_RL78_OPnot:\n-\tcase R_RL78_OPmod:\n-\t  relocation = rl78_compute_complex_reloc (r_type, 0, input_section,\n-\t\t\t\t\t\t   &r, &error_message);\n-\n-\t  switch (r_type)\n-\t    {\n-\t    case R_RL78_ABS32:\n-\t      OP (0) = relocation;\n-\t      OP (1) = relocation >> 8;\n-\t      OP (2) = relocation >> 16;\n-\t      OP (3) = relocation >> 24;\n-\t      break;\n-\n-\t    case R_RL78_ABS32_REV:\n-\t      OP (3) = relocation;\n-\t      OP (2) = relocation >> 8;\n-\t      OP (1) = relocation >> 16;\n-\t      OP (0) = relocation >> 24;\n-\t      break;\n-\n-\t    case R_RL78_ABS24S_PCREL:\n-\t    case R_RL78_ABS24S:\n-\t      RANGE (-0x800000, 0x7fffff);\n-\t      OP (0) = relocation;\n-\t      OP (1) = relocation >> 8;\n-\t      OP (2) = relocation >> 16;\n-\t      break;\n-\n-\t    case R_RL78_ABS16:\n-\t      RANGE (-32768, 65535);\n-\t      OP (0) = relocation;\n-\t      OP (1) = relocation >> 8;\n-\t      break;\n-\n-\t    case R_RL78_ABS16_REV:\n-\t      RANGE (-32768, 65535);\n-\t      OP (1) = relocation;\n-\t      OP (0) = relocation >> 8;\n-\t      break;\n-\n-\t    case R_RL78_ABS16S_PCREL:\n-\t    case R_RL78_ABS16S:\n-\t      RANGE (-32768, 32767);\n-\t      OP (0) = relocation;\n-\t      OP (1) = relocation >> 8;\n-\t      break;\n-\n-\t    case R_RL78_ABS16U:\n-\t    case R_RL78_ABS16UL:\n-\t    case R_RL78_ABS16UW:\n-\t      RANGE (0, 65536);\n-\t      OP (0) = relocation;\n-\t      OP (1) = relocation >> 8;\n-\t      break;\n-\n-\t    case R_RL78_ABS8:\n-\t      RANGE (-128, 255);\n-\t      OP (0) = relocation;\n-\t      break;\n-\n-\t    case R_RL78_ABS8U:\n-\t    case R_RL78_ABS8UL:\n-\t    case R_RL78_ABS8UW:\n-\t      RANGE (0, 255);\n-\t      OP (0) = relocation;\n-\t      break;\n-\n-\t    case R_RL78_ABS8S_PCREL:\n-\t    case R_RL78_ABS8S:\n-\t      RANGE (-128, 127);\n-\t      OP (0) = relocation;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tcase R_RL78_SYM:\n-\t  if (r_symndx < symtab_hdr->sh_info)\n-\t    relocation = sec->output_section->vma + sec->output_offset\n-\t      + sym->st_value + rel->r_addend;\n-\t  else if (h != NULL\n-\t\t   && (h->root.type == bfd_link_hash_defined\n-\t\t       || h->root.type == bfd_link_hash_defweak))\n-\t    relocation = h->root.u.def.value\n-\t      + sec->output_section->vma\n-\t      + sec->output_offset\n-\t      + rel->r_addend;\n-\t  else\n-\t    {\n-\t      relocation = 0;\n-\t      if (h->root.type != bfd_link_hash_undefweak)\n-\t\t_bfd_error_handler\n-\t\t  (_(\"warning: RL78_SYM reloc with an unknown symbol\"));\n-\t    }\n-\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n-\t\t\t\t\t     &r, &error_message);\n-\t  break;\n-\n-\tcase R_RL78_OPromtop:\n-\t  relocation = get_romstart (info, input_bfd, input_section, rel->r_offset);\n-\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n-\t\t\t\t\t     &r, &error_message);\n-\t  break;\n-\n-\tcase R_RL78_OPramtop:\n-\t  relocation = get_ramstart (info, input_bfd, input_section, rel->r_offset);\n-\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n-\t\t\t\t\t     &r, &error_message);\n-\t  break;\n-\n-\tdefault:\n-\t  r = bfd_reloc_notsupported;\n-\t  break;\n-\t}\n+      if (r == bfd_reloc_ok)\n+\tr = check_overflow (howto, relocation);\n \n       if (r != bfd_reloc_ok)\n \t{"
    }
  ]
}