{
  "sha": "408f66864a1a823591b26420410c982174c239a2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDA4ZjY2ODY0YTFhODIzNTkxYjI2NDIwNDEwYzk4MjE3NGMyMzlhMg==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-01-11T20:01:58Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-02-03T01:15:19Z"
    },
    "message": "detach in all-stop with threads running\n\nA following patch will add a testcase that has a number of threads\nconstantly stepping over a breakpoint, and then has GDB detach the\nprocess, while threads are running.  If we have more than one inferior\nrunning, and we detach from just one of the inferiors, we expect that\nthe remaining inferior continues running.  However, in all-stop, if\nGDB needs to pause the target for the detach, nothing is re-resuming\nthe other inferiors after the detach.  \"info threads\" shows the\nthreads as running, but they really aren't.  This fixes it.\n\ngdb/ChangeLog:\n\n\t* infcmd.c (detach_command): Hold strong reference to target, and\n\tif all-stop on entry, restart threads on exit.\n\t* infrun.c (switch_back_to_stepped_thread): Factor out bits to ...\n\t(restart_stepped_thread): ... this new function.  Also handle\n\ttrap_expected.\n\t(restart_after_all_stop_detach): New function.\n\t* infrun.h (restart_after_all_stop_detach): Declare.",
    "tree": {
      "sha": "ebca2b15942730a15f70b27dcb4b54b6c69eac24",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ebca2b15942730a15f70b27dcb4b54b6c69eac24"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/408f66864a1a823591b26420410c982174c239a2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/408f66864a1a823591b26420410c982174c239a2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/408f66864a1a823591b26420410c982174c239a2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/408f66864a1a823591b26420410c982174c239a2/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3"
    }
  ],
  "stats": {
    "total": 190,
    "additions": 138,
    "deletions": 52
  },
  "files": [
    {
      "sha": "4a02a64e71b04c8adec1155e40d5fa3a37126f78",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/408f66864a1a823591b26420410c982174c239a2/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/408f66864a1a823591b26420410c982174c239a2/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=408f66864a1a823591b26420410c982174c239a2",
      "patch": "@@ -1,3 +1,13 @@\n+2021-02-03  Pedro Alves  <pedro@palves.net>\n+\n+\t* infcmd.c (detach_command): Hold strong reference to target, and\n+\tif all-stop on entry, restart threads on exit.\n+\t* infrun.c (switch_back_to_stepped_thread): Factor out bits to ...\n+\t(restart_stepped_thread): ... this new function.  Also handle\n+\ttrap_expected.\n+\t(restart_after_all_stop_detach): New function.\n+\t* infrun.h (restart_after_all_stop_detach): Declare.\n+\n 2021-02-03  Pedro Alves  <pedro@palves.net>\n \n \t* infrun.c (struct step_over_info): Initialize fields."
    },
    {
      "sha": "ebaf57592ef5746a30a293cd38e8e34211b3e104",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/408f66864a1a823591b26420410c982174c239a2/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/408f66864a1a823591b26420410c982174c239a2/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=408f66864a1a823591b26420410c982174c239a2",
      "patch": "@@ -2750,6 +2750,16 @@ detach_command (const char *args, int from_tty)\n \n   disconnect_tracing ();\n \n+  /* Hold a strong reference to the target while (maybe)\n+     detaching the parent.  Otherwise detaching could close the\n+     target.  */\n+  auto target_ref\n+    = target_ops_ref::new_reference (current_inferior ()->process_target ());\n+\n+  /* Save this before detaching, since detaching may unpush the\n+     process_stratum target.  */\n+  bool was_non_stop_p = target_is_non_stop_p ();\n+\n   target_detach (current_inferior (), from_tty);\n \n   /* The current inferior process was just detached successfully.  Get\n@@ -2766,6 +2776,9 @@ detach_command (const char *args, int from_tty)\n \n   if (deprecated_detach_hook)\n     deprecated_detach_hook ();\n+\n+  if (!was_non_stop_p)\n+    restart_after_all_stop_detach (as_process_stratum_target (target_ref.get ()));\n }\n \n /* Disconnect from the current target without resuming it (leaving it"
    },
    {
      "sha": "f2abfe4a7c251fcc130851d26194bc8c74b08fec",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 111,
      "deletions": 52,
      "changes": 163,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/408f66864a1a823591b26420410c982174c239a2/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/408f66864a1a823591b26420410c982174c239a2/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=408f66864a1a823591b26420410c982174c239a2",
      "patch": "@@ -7110,6 +7110,9 @@ process_event_stop_test (struct execution_control_state *ecs)\n   keep_going (ecs);\n }\n \n+static bool restart_stepped_thread (process_stratum_target *resume_target,\n+\t\t\t\t    ptid_t resume_ptid);\n+\n /* In all-stop mode, if we're currently stepping but have stopped in\n    some other thread, we may need to switch back to the stepped\n    thread.  Returns true we set the inferior running, false if we left\n@@ -7120,8 +7123,6 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n {\n   if (!target_is_non_stop_p ())\n     {\n-      struct thread_info *stepping_thread;\n-\n       /* If any thread is blocked on some internal breakpoint, and we\n \t simply need to step over that breakpoint to get it going\n \t again, do that first.  */\n@@ -7184,78 +7185,136 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n       if (!signal_program[ecs->event_thread->suspend.stop_signal])\n \tecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n \n-      /* Do all pending step-overs before actually proceeding with\n-\t step/next/etc.  */\n-      if (start_step_over ())\n+      if (restart_stepped_thread (ecs->target, ecs->ptid))\n \t{\n \t  prepare_to_wait (ecs);\n \t  return true;\n \t}\n \n-      /* Look for the stepping/nexting thread.  */\n-      stepping_thread = NULL;\n+      switch_to_thread (ecs->event_thread);\n+    }\n \n-      for (thread_info *tp : all_non_exited_threads ())\n-\t{\n-\t  switch_to_thread_no_regs (tp);\n+  return false;\n+}\n \n-\t  /* Ignore threads of processes the caller is not\n-\t     resuming.  */\n-\t  if (!sched_multi\n-\t      && (tp->inf->process_target () != ecs->target\n-\t\t  || tp->inf->pid != ecs->ptid.pid ()))\n-\t    continue;\n+/* Look for the thread that was stepping, and resume it.\n+   RESUME_TARGET / RESUME_PTID indicate the set of threads the caller\n+   is resuming.  Return true if a thread was started, false\n+   otherwise.  */\n \n-\t  /* When stepping over a breakpoint, we lock all threads\n-\t     except the one that needs to move past the breakpoint.\n-\t     If a non-event thread has this set, the \"incomplete\n-\t     step-over\" check above should have caught it earlier.  */\n-\t  if (tp->control.trap_expected)\n-\t    {\n-\t      internal_error (__FILE__, __LINE__,\n-\t\t\t      \"[%s] has inconsistent state: \"\n-\t\t\t      \"trap_expected=%d\\n\",\n-\t\t\t      target_pid_to_str (tp->ptid).c_str (),\n-\t\t\t      tp->control.trap_expected);\n-\t    }\n+static bool\n+restart_stepped_thread (process_stratum_target *resume_target,\n+\t\t\tptid_t resume_ptid)\n+{\n+  /* Do all pending step-overs before actually proceeding with\n+     step/next/etc.  */\n+  if (start_step_over ())\n+    return true;\n \n-\t  /* Did we find the stepping thread?  */\n-\t  if (tp->control.step_range_end)\n-\t    {\n-\t      /* Yep.  There should only one though.  */\n-\t      gdb_assert (stepping_thread == NULL);\n+  for (thread_info *tp : all_threads_safe ())\n+    {\n+      if (tp->state == THREAD_EXITED)\n+\tcontinue;\n+\n+      if (tp->suspend.waitstatus_pending_p)\n+\tcontinue;\n \n-\t      /* The event thread is handled at the top, before we\n-\t\t enter this loop.  */\n-\t      gdb_assert (tp != ecs->event_thread);\n+      /* Ignore threads of processes the caller is not\n+\t resuming.  */\n+      if (!sched_multi\n+\t  && (tp->inf->process_target () != resume_target\n+\t      || tp->inf->pid != resume_ptid.pid ()))\n+\tcontinue;\n \n-\t      /* If some thread other than the event thread is\n-\t\t stepping, then scheduler locking can't be in effect,\n-\t\t otherwise we wouldn't have resumed the current event\n-\t\t thread in the first place.  */\n-\t      gdb_assert (!schedlock_applies (tp));\n+      if (tp->control.trap_expected)\n+\t{\n+\t  infrun_debug_printf (\"switching back to stepped thread (step-over)\");\n \n-\t      stepping_thread = tp;\n-\t    }\n+\t  if (keep_going_stepped_thread (tp))\n+\t    return true;\n \t}\n+    }\n+\n+  for (thread_info *tp : all_threads_safe ())\n+    {\n+      if (tp->state == THREAD_EXITED)\n+\tcontinue;\n+\n+      if (tp->suspend.waitstatus_pending_p)\n+\tcontinue;\n \n-      if (stepping_thread != NULL)\n+      /* Ignore threads of processes the caller is not\n+\t resuming.  */\n+      if (!sched_multi\n+\t  && (tp->inf->process_target () != resume_target\n+\t      || tp->inf->pid != resume_ptid.pid ()))\n+\tcontinue;\n+\n+      /* Did we find the stepping thread?  */\n+      if (tp->control.step_range_end)\n \t{\n-\t  infrun_debug_printf (\"switching back to stepped thread\");\n+\t  infrun_debug_printf (\"switching back to stepped thread (stepping)\");\n \n-\t  if (keep_going_stepped_thread (stepping_thread))\n-\t    {\n-\t      prepare_to_wait (ecs);\n-\t      return true;\n-\t    }\n+\t  if (keep_going_stepped_thread (tp))\n+\t    return true;\n \t}\n-\n-      switch_to_thread (ecs->event_thread);\n     }\n \n   return false;\n }\n \n+/* See infrun.h.  */\n+\n+void\n+restart_after_all_stop_detach (process_stratum_target *proc_target)\n+{\n+  /* Note we don't check target_is_non_stop_p() here, because the\n+     current inferior may no longer have a process_stratum target\n+     pushed, as we just detached.  */\n+\n+  /* See if we have a THREAD_RUNNING thread that need to be\n+     re-resumed.  If we have any thread that is already executing,\n+     then we don't need to resume the target -- it is already been\n+     resumed.  With the remote target (in all-stop), it's even\n+     impossible to issue another resumption if the target is already\n+     resumed, until the target reports a stop.  */\n+  for (thread_info *thr : all_threads (proc_target))\n+    {\n+      if (thr->state != THREAD_RUNNING)\n+\tcontinue;\n+\n+      /* If we have any thread that is already executing, then we\n+\t don't need to resume the target -- it is already been\n+\t resumed.  */\n+      if (thr->executing)\n+\treturn;\n+\n+      /* If we have a pending event to process, skip resuming the\n+\t target and go straight to processing it.  */\n+      if (thr->resumed && thr->suspend.waitstatus_pending_p)\n+\treturn;\n+    }\n+\n+  /* Alright, we need to re-resume the target.  If a thread was\n+     stepping, we need to restart it stepping.  */\n+  if (restart_stepped_thread (proc_target, minus_one_ptid))\n+    return;\n+\n+  /* Otherwise, find the first THREAD_RUNNING thread and resume\n+     it.  */\n+  for (thread_info *thr : all_threads (proc_target))\n+    {\n+      if (thr->state != THREAD_RUNNING)\n+\tcontinue;\n+\n+      execution_control_state ecs;\n+      reset_ecs (&ecs, thr);\n+      switch_to_thread (thr);\n+      keep_going (&ecs);\n+      return;\n+    }\n+}\n+\n /* Set a previously stepped thread back to stepping.  Returns true on\n    success, false if the resume is not possible (e.g., the thread\n    vanished).  */"
    },
    {
      "sha": "e643c84dd80ea7a957178f5fa0bd6e1684d2fa37",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/408f66864a1a823591b26420410c982174c239a2/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/408f66864a1a823591b26420410c982174c239a2/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=408f66864a1a823591b26420410c982174c239a2",
      "patch": "@@ -269,4 +269,8 @@ extern void all_uis_check_sync_execution_done (void);\n    started or re-started).  */\n extern void all_uis_on_sync_execution_starting (void);\n \n+/* In all-stop, restart the target if it had to be stopped to\n+   detach.  */\n+extern void restart_after_all_stop_detach (process_stratum_target *proc_target);\n+\n #endif /* INFRUN_H */"
    }
  ]
}