{
  "sha": "1428b37afbd8a5199e1c4b2a53ef8700208a12d4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTQyOGIzN2FmYmQ4YTUxOTllMWM0YjJhNTNlZjg3MDAyMDhhMTJkNA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:36Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:36Z"
    },
    "message": "gdb: add all_breakpoints_safe function\n\nSame as the previous patch, but intended to replace the\nALL_BREAKPOINTS_SAFE macro, which allows deleting the current breakpoint\nwhile iterating.  The new range type simply wraps the range added by the\nprevious patch with basic_safe_range.\n\nI didn't remove the ALL_BREAKPOINTS_SAFE macro, because there is one\nspot where it's more tricky to remove, in the\ncheck_longjmp_breakpoint_for_call_dummy function.  More thought it\nneeded for this one.\n\ngdb/ChangeLog:\n\n\t* breakpoint.c (breakpoint_safe_range): New.\n\t(all_breakpoints_safe): New.  Use instead of\n\tALL_BREAKPOINTS_SAFE where possible.\n\nChange-Id: Ifccab29f135e1f85700e3697ed60f0b643c7682f",
    "tree": {
      "sha": "ca93ce7681b1b3436a3815f5052dae3e7d6caed3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ca93ce7681b1b3436a3815f5052dae3e7d6caed3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1428b37afbd8a5199e1c4b2a53ef8700208a12d4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1428b37afbd8a5199e1c4b2a53ef8700208a12d4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1428b37afbd8a5199e1c4b2a53ef8700208a12d4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1428b37afbd8a5199e1c4b2a53ef8700208a12d4/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "43892fdfa1aecb67d4830c47c9a40b0d74ed4c47",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47"
    }
  ],
  "stats": {
    "total": 115,
    "additions": 47,
    "deletions": 68
  },
  "files": [
    {
      "sha": "d855454c0433a429d41337957ed12bc3d9b9c988",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1428b37afbd8a5199e1c4b2a53ef8700208a12d4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1428b37afbd8a5199e1c4b2a53ef8700208a12d4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1428b37afbd8a5199e1c4b2a53ef8700208a12d4",
      "patch": "@@ -1,3 +1,9 @@\n+2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* breakpoint.c (breakpoint_safe_range): New.\n+\t(all_breakpoints_safe): New.  Use instead of\n+\tALL_BREAKPOINTS_SAFE where possible.\n+\n 2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* breakpoint.c (ALL_BREAKPOINTS): Remove, replace all uses with"
    },
    {
      "sha": "c5aea77c1600b87846b8b97d239ee57ddadf982c",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 41,
      "deletions": 68,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1428b37afbd8a5199e1c4b2a53ef8700208a12d4/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1428b37afbd8a5199e1c4b2a53ef8700208a12d4/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=1428b37afbd8a5199e1c4b2a53ef8700208a12d4",
      "patch": "@@ -540,6 +540,20 @@ all_breakpoints ()\n   return breakpoint_range (breakpoint_chain);\n }\n \n+/* Breakpoint linked list range, safe against deletion of the current\n+   breakpoint while iterating.  */\n+\n+using breakpoint_safe_range = basic_safe_range<breakpoint_range>;\n+\n+/* Return a range to iterate over all breakpoints.  This range is safe against\n+   deletion of the current breakpoint while iterating.  */\n+\n+static breakpoint_safe_range\n+all_breakpoints_safe ()\n+{\n+  return breakpoint_safe_range (all_breakpoints ());\n+}\n+\n /* Array is sorted by bp_location_is_less_than - primarily by the ADDRESS.  */\n \n static struct bp_location **bp_locations;\n@@ -2889,15 +2903,12 @@ of catchpoint.\"), bl->owner->number);\n void\n breakpoint_program_space_exit (struct program_space *pspace)\n {\n-  struct breakpoint *b, *b_temp;\n   struct bp_location *loc, **loc_temp;\n \n   /* Remove any breakpoint that was set through this program space.  */\n-  ALL_BREAKPOINTS_SAFE (b, b_temp)\n-    {\n-      if (b->pspace == pspace)\n-\tdelete_breakpoint (b);\n-    }\n+  for (breakpoint *b : all_breakpoints_safe ())\n+    if (b->pspace == pspace)\n+      delete_breakpoint (b);\n \n   /* Breakpoints set through other program spaces could have locations\n      bound to PSPACE as well.  Remove those.  */\n@@ -3143,9 +3154,7 @@ remove_breakpoints (void)\n static void\n remove_threaded_breakpoints (struct thread_info *tp, int silent)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     {\n       if (b->thread == tp->global_num && user_breakpoint_p (b))\n \t{\n@@ -3653,7 +3662,6 @@ breakpoint_event_location_empty_p (const struct breakpoint *b)\n void\n update_breakpoints_after_exec (void)\n {\n-  struct breakpoint *b, *b_tmp;\n   struct bp_location *bploc, **bplocp_tmp;\n \n   /* We're about to delete breakpoints from GDB's lists.  If the\n@@ -3668,7 +3676,7 @@ update_breakpoints_after_exec (void)\n     if (bploc->pspace == current_program_space)\n       gdb_assert (!bploc->inserted);\n \n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n   {\n     if (b->pspace != current_program_space)\n       continue;\n@@ -4002,7 +4010,6 @@ mark_breakpoints_out (void)\n void\n breakpoint_init_inferior (enum inf_context context)\n {\n-  struct breakpoint *b, *b_tmp;\n   struct program_space *pspace = current_program_space;\n \n   /* If breakpoint locations are shared across processes, then there's\n@@ -4012,7 +4019,7 @@ breakpoint_init_inferior (enum inf_context context)\n \n   mark_breakpoints_out ();\n \n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n   {\n     if (b->loc && b->loc->pspace != pspace)\n       continue;\n@@ -7354,14 +7361,13 @@ set_raw_breakpoint (struct gdbarch *gdbarch,\n void\n set_longjmp_breakpoint (struct thread_info *tp, struct frame_id frame)\n {\n-  struct breakpoint *b, *b_tmp;\n   int thread = tp->global_num;\n \n   /* To avoid having to rescan all objfile symbols at every step,\n      we maintain a list of continually-inserted but always disabled\n      longjmp \"master\" breakpoints.  Here, we simply create momentary\n      clones of those and enable them for the requested thread.  */\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->pspace == current_program_space\n \t&& (b->type == bp_longjmp_master\n \t    || b->type == bp_exception_master))\n@@ -7383,9 +7389,7 @@ set_longjmp_breakpoint (struct thread_info *tp, struct frame_id frame)\n void\n delete_longjmp_breakpoint (int thread)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->type == bp_longjmp || b->type == bp_exception)\n       {\n \tif (b->thread == thread)\n@@ -7396,9 +7400,7 @@ delete_longjmp_breakpoint (int thread)\n void\n delete_longjmp_breakpoint_at_next_stop (int thread)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->type == bp_longjmp || b->type == bp_exception)\n       {\n \tif (b->thread == thread)\n@@ -7505,9 +7507,7 @@ disable_overlay_breakpoints (void)\n void\n set_std_terminate_breakpoint (void)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->pspace == current_program_space\n \t&& b->type == bp_std_terminate_master)\n       {\n@@ -7520,9 +7520,7 @@ set_std_terminate_breakpoint (void)\n void\n delete_std_terminate_breakpoint (void)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->type == bp_std_terminate)\n       delete_breakpoint (b);\n }\n@@ -7564,9 +7562,7 @@ create_jit_event_breakpoint (struct gdbarch *gdbarch, CORE_ADDR address)\n void\n remove_jit_event_breakpoints (void)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->type == bp_jit_event\n \t&& b->loc->pspace == current_program_space)\n       delete_breakpoint (b);\n@@ -7575,9 +7571,7 @@ remove_jit_event_breakpoints (void)\n void\n remove_solib_event_breakpoints (void)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->type == bp_shlib_event\n \t&& b->loc->pspace == current_program_space)\n       delete_breakpoint (b);\n@@ -7588,9 +7582,7 @@ remove_solib_event_breakpoints (void)\n void\n remove_solib_event_breakpoints_at_next_stop (void)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->type == bp_shlib_event\n \t&& b->loc->pspace == current_program_space)\n       b->disposition = disp_del_at_next_stop;\n@@ -11625,19 +11617,15 @@ clear_command (const char *arg, int from_tty)\n void\n breakpoint_auto_delete (bpstat bs)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n   for (; bs; bs = bs->next)\n     if (bs->breakpoint_at\n \t&& bs->breakpoint_at->disposition == disp_del\n \t&& bs->stop)\n       delete_breakpoint (bs->breakpoint_at);\n \n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n-  {\n+  for (breakpoint *b : all_breakpoints_safe ())\n     if (b->disposition == disp_del_at_next_stop)\n       delete_breakpoint (b);\n-  }\n }\n \n /* A comparison function for bp_location AP and BP being interfaced to\n@@ -13375,8 +13363,6 @@ iterate_over_related_breakpoints (struct breakpoint *b,\n static void\n delete_command (const char *arg, int from_tty)\n {\n-  breakpoint *b_tmp;\n-\n   dont_repeat ();\n \n   if (arg == 0)\n@@ -13396,13 +13382,9 @@ delete_command (const char *arg, int from_tty)\n       /* Ask user only if there are some breakpoints to delete.  */\n       if (!from_tty\n \t  || (breaks_to_delete && query (_(\"Delete all breakpoints? \"))))\n-\t{\n-\t  breakpoint *b;\n-\n-\t  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n-\t    if (user_breakpoint_p (b))\n-\t      delete_breakpoint (b);\n-\t}\n+\tfor (breakpoint *b : all_breakpoints_safe ())\n+\t  if (user_breakpoint_p (b))\n+\t    delete_breakpoint (b);\n     }\n   else\n     map_breakpoint_numbers\n@@ -13974,8 +13956,6 @@ breakpoint_re_set_one (breakpoint *b)\n void\n breakpoint_re_set (void)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n   {\n     scoped_restore_current_language save_language;\n     scoped_restore save_input_radix = make_scoped_restore (&input_radix);\n@@ -13999,7 +13979,7 @@ breakpoint_re_set (void)\n        breakpoint 1, we'd insert the locations of breakpoint 2, which\n        hadn't been re-set yet, and thus may have stale locations.  */\n \n-    ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+    for (breakpoint *b : all_breakpoints_safe ())\n       {\n \ttry\n \t  {\n@@ -14126,13 +14106,11 @@ map_breakpoint_number_range (std::pair<int, int> bp_num_range,\n     }\n   else\n     {\n-      struct breakpoint *b, *tmp;\n-\n       for (int i = bp_num_range.first; i <= bp_num_range.second; i++)\n \t{\n \t  bool match = false;\n \n-\t  ALL_BREAKPOINTS_SAFE (b, tmp)\n+\t  for (breakpoint *b : all_breakpoints_safe ())\n \t    if (b->number == i)\n \t      {\n \t\tmatch = true;\n@@ -14927,20 +14905,19 @@ disable_trace_command (const char *args, int from_tty)\n static void\n delete_trace_command (const char *arg, int from_tty)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n   dont_repeat ();\n \n   if (arg == 0)\n     {\n       int breaks_to_delete = 0;\n+      breakpoint *tp;\n \n       /* Delete all breakpoints if no argument.\n \t Do not delete internal or call-dummy breakpoints, these\n \t have to be deleted with an explicit breakpoint number \n \t argument.  */\n-      ALL_TRACEPOINTS (b)\n-\tif (is_tracepoint (b) && user_breakpoint_p (b))\n+      ALL_TRACEPOINTS (tp)\n+\tif (is_tracepoint (tp) && user_breakpoint_p (tp))\n \t  {\n \t    breaks_to_delete = 1;\n \t    break;\n@@ -14950,7 +14927,7 @@ delete_trace_command (const char *arg, int from_tty)\n       if (!from_tty\n \t  || (breaks_to_delete && query (_(\"Delete all tracepoints? \"))))\n \t{\n-\t  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n+\t  for (breakpoint *b : all_breakpoints_safe ())\n \t    if (is_tracepoint (b) && user_breakpoint_p (b))\n \t      delete_breakpoint (b);\n \t}\n@@ -15352,13 +15329,9 @@ add_catch_command (const char *name, const char *docstring,\n struct breakpoint *\n iterate_over_breakpoints (gdb::function_view<bool (breakpoint *)> callback)\n {\n-  struct breakpoint *b, *b_tmp;\n-\n-  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n-    {\n-      if (callback (b))\n-\treturn b;\n-    }\n+  for (breakpoint *b : all_breakpoints_safe ())\n+    if (callback (b))\n+      return b;\n \n   return NULL;\n }"
    }
  ]
}