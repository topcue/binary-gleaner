{
  "sha": "2f98abe174b50cf347761345c5e2dc8859dc63b9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmY5OGFiZTE3NGI1MGNmMzQ3NzYxMzQ1YzVlMmRjODg1OWRjNjNiOQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:30Z"
    },
    "message": "Introduce fortran_undetermined\n\nThis adds class fortran_undetermined, which implements\nOP_F77_UNDETERMINED_ARGLIST.  fortran_range_operation is also added\nhere, as it is needed by fortran_undetermined.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* expop.h (class unop_addr_operation) <get_expression>: New\n\tmethod.\n\t* f-lang.c (fortran_undetermined::value_subarray)\n\t(fortran_undetermined::evaluate): New methods.\n\t(fortran_prepare_argument): New overload.\n\t* f-exp.h (class fortran_range_operation)\n\t(class fortran_undetermined): New classes.",
    "tree": {
      "sha": "aece5b5b55152198aa72d5f796e18bcd63e8f3cf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/aece5b5b55152198aa72d5f796e18bcd63e8f3cf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2f98abe174b50cf347761345c5e2dc8859dc63b9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2f98abe174b50cf347761345c5e2dc8859dc63b9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2f98abe174b50cf347761345c5e2dc8859dc63b9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2f98abe174b50cf347761345c5e2dc8859dc63b9/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "638fd74a616e095159e88ed4e596a71153bef88e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/638fd74a616e095159e88ed4e596a71153bef88e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/638fd74a616e095159e88ed4e596a71153bef88e"
    }
  ],
  "stats": {
    "total": 610,
    "additions": 610,
    "deletions": 0
  },
  "files": [
    {
      "sha": "66f770539188569aa8dcc7d743528d9738e7ac9c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2f98abe174b50cf347761345c5e2dc8859dc63b9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2f98abe174b50cf347761345c5e2dc8859dc63b9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2f98abe174b50cf347761345c5e2dc8859dc63b9",
      "patch": "@@ -1,3 +1,13 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* expop.h (class unop_addr_operation) <get_expression>: New\n+\tmethod.\n+\t* f-lang.c (fortran_undetermined::value_subarray)\n+\t(fortran_undetermined::evaluate): New methods.\n+\t(fortran_prepare_argument): New overload.\n+\t* f-exp.h (class fortran_range_operation)\n+\t(class fortran_undetermined): New classes.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* rust-lang.c (rust_structop::evaluate_funcall): New method."
    },
    {
      "sha": "44d9d2e1600e5fc7a9490b576f12cdeaa4606b57",
      "filename": "gdb/expop.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2f98abe174b50cf347761345c5e2dc8859dc63b9/gdb/expop.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2f98abe174b50cf347761345c5e2dc8859dc63b9/gdb/expop.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expop.h?ref=2f98abe174b50cf347761345c5e2dc8859dc63b9",
      "patch": "@@ -1656,6 +1656,12 @@ class unop_addr_operation\n   enum exp_opcode opcode () const override\n   { return UNOP_ADDR; }\n \n+  /* Return the subexpression.  */\n+  const operation_up &get_expression () const\n+  {\n+    return std::get<0> (m_storage);\n+  }\n+\n protected:\n \n   void do_generate_ax (struct expression *exp,"
    },
    {
      "sha": "b569c33ad9cbee207e4bcff7f8dd73a34c5e3b79",
      "filename": "gdb/f-exp.h",
      "status": "modified",
      "additions": 63,
      "deletions": 0,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2f98abe174b50cf347761345c5e2dc8859dc63b9/gdb/f-exp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2f98abe174b50cf347761345c5e2dc8859dc63b9/gdb/f-exp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.h?ref=2f98abe174b50cf347761345c5e2dc8859dc63b9",
      "patch": "@@ -96,6 +96,69 @@ class fortran_cmplx_operation\n   { return BINOP_FORTRAN_CMPLX; }\n };\n \n+/* OP_RANGE for Fortran.  */\n+class fortran_range_operation\n+  : public tuple_holding_operation<enum range_flag, operation_up, operation_up,\n+\t\t\t\t   operation_up>\n+{\n+public:\n+\n+  using tuple_holding_operation::tuple_holding_operation;\n+\n+  value *evaluate (struct type *expect_type,\n+\t\t   struct expression *exp,\n+\t\t   enum noside noside) override\n+  {\n+    error (_(\"ranges not allowed in this context\"));\n+  }\n+\n+  range_flag get_flags () const\n+  {\n+    return std::get<0> (m_storage);\n+  }\n+\n+  value *evaluate0 (struct expression *exp, enum noside noside) const\n+  {\n+    return std::get<1> (m_storage)->evaluate (nullptr, exp, noside);\n+  }\n+\n+  value *evaluate1 (struct expression *exp, enum noside noside) const\n+  {\n+    return std::get<2> (m_storage)->evaluate (nullptr, exp, noside);\n+  }\n+\n+  value *evaluate2 (struct expression *exp, enum noside noside) const\n+  {\n+    return std::get<3> (m_storage)->evaluate (nullptr, exp, noside);\n+  }\n+\n+  enum exp_opcode opcode () const override\n+  { return OP_RANGE; }\n+};\n+\n+/* In F77, functions, substring ops and array subscript operations\n+   cannot be disambiguated at parse time.  This operation handles\n+   both, deciding which do to at evaluation time.  */\n+class fortran_undetermined\n+  : public tuple_holding_operation<operation_up, std::vector<operation_up>>\n+{\n+public:\n+\n+  using tuple_holding_operation::tuple_holding_operation;\n+\n+  value *evaluate (struct type *expect_type,\n+\t\t   struct expression *exp,\n+\t\t   enum noside noside) override;\n+\n+  enum exp_opcode opcode () const override\n+  { return OP_F77_UNDETERMINED_ARGLIST; }\n+\n+private:\n+\n+  value *value_subarray (value *array, struct expression *exp,\n+\t\t\t enum noside noside);\n+};\n+\n } /* namespace expr */\n \n #endif /* FORTRAN_EXP_H */"
    },
    {
      "sha": "6f7217dc94af453770570baceff5ffeb9c592f05",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 531,
      "deletions": 0,
      "changes": 531,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2f98abe174b50cf347761345c5e2dc8859dc63b9/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2f98abe174b50cf347761345c5e2dc8859dc63b9/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=2f98abe174b50cf347761345c5e2dc8859dc63b9",
      "patch": "@@ -73,6 +73,10 @@ static value *fortran_prepare_argument (struct expression *exp, int *pos,\n \t\t\t\t\tint arg_num, bool is_internal_call_p,\n \t\t\t\t\tstruct type *func_type,\n \t\t\t\t\tenum noside noside);\n+static value *fortran_prepare_argument (struct expression *exp,\n+\t\t\t\t\texpr::operation *subexp,\n+\t\t\t\t\tint arg_num, bool is_internal_call_p,\n+\t\t\t\t\tstruct type *func_type, enum noside noside);\n \n /* Return the encoding that should be used for the character type\n    TYPE.  */\n@@ -1395,6 +1399,474 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n   return nullptr;\n }\n \n+namespace expr\n+{\n+\n+/* Called from evaluate to perform array indexing, and sub-range\n+   extraction, for Fortran.  As well as arrays this function also\n+   handles strings as they can be treated like arrays of characters.\n+   ARRAY is the array or string being accessed.  EXP and NOSIDE are as\n+   for evaluate.  */\n+\n+value *\n+fortran_undetermined::value_subarray (value *array,\n+\t\t\t\t      struct expression *exp,\n+\t\t\t\t      enum noside noside)\n+{\n+  type *original_array_type = check_typedef (value_type (array));\n+  bool is_string_p = original_array_type->code () == TYPE_CODE_STRING;\n+  const std::vector<operation_up> &ops = std::get<1> (m_storage);\n+  int nargs = ops.size ();\n+\n+  /* Perform checks for ARRAY not being available.  The somewhat overly\n+     complex logic here is just to keep backward compatibility with the\n+     errors that we used to get before FORTRAN_VALUE_SUBARRAY was\n+     rewritten.  Maybe a future task would streamline the error messages we\n+     get here, and update all the expected test results.  */\n+  if (ops[0]->opcode () != OP_RANGE)\n+    {\n+      if (type_not_associated (original_array_type))\n+\terror (_(\"no such vector element (vector not associated)\"));\n+      else if (type_not_allocated (original_array_type))\n+\terror (_(\"no such vector element (vector not allocated)\"));\n+    }\n+  else\n+    {\n+      if (type_not_associated (original_array_type))\n+\terror (_(\"array not associated\"));\n+      else if (type_not_allocated (original_array_type))\n+\terror (_(\"array not allocated\"));\n+    }\n+\n+  /* First check that the number of dimensions in the type we are slicing\n+     matches the number of arguments we were passed.  */\n+  int ndimensions = calc_f77_array_dims (original_array_type);\n+  if (nargs != ndimensions)\n+    error (_(\"Wrong number of subscripts\"));\n+\n+  /* This will be initialised below with the type of the elements held in\n+     ARRAY.  */\n+  struct type *inner_element_type;\n+\n+  /* Extract the types of each array dimension from the original array\n+     type.  We need these available so we can fill in the default upper and\n+     lower bounds if the user requested slice doesn't provide that\n+     information.  Additionally unpacking the dimensions like this gives us\n+     the inner element type.  */\n+  std::vector<struct type *> dim_types;\n+  {\n+    dim_types.reserve (ndimensions);\n+    struct type *type = original_array_type;\n+    for (int i = 0; i < ndimensions; ++i)\n+      {\n+\tdim_types.push_back (type);\n+\ttype = TYPE_TARGET_TYPE (type);\n+      }\n+    /* TYPE is now the inner element type of the array, we start the new\n+       array slice off as this type, then as we process the requested slice\n+       (from the user) we wrap new types around this to build up the final\n+       slice type.  */\n+    inner_element_type = type;\n+  }\n+\n+  /* As we analyse the new slice type we need to understand if the data\n+     being referenced is contiguous.  Do decide this we must track the size\n+     of an element at each dimension of the new slice array.  Initially the\n+     elements of the inner most dimension of the array are the same inner\n+     most elements as the original ARRAY.  */\n+  LONGEST slice_element_size = TYPE_LENGTH (inner_element_type);\n+\n+  /* Start off assuming all data is contiguous, this will be set to false\n+     if access to any dimension results in non-contiguous data.  */\n+  bool is_all_contiguous = true;\n+\n+  /* The TOTAL_OFFSET is the distance in bytes from the start of the\n+     original ARRAY to the start of the new slice.  This is calculated as\n+     we process the information from the user.  */\n+  LONGEST total_offset = 0;\n+\n+  /* A structure representing information about each dimension of the\n+     resulting slice.  */\n+  struct slice_dim\n+  {\n+    /* Constructor.  */\n+    slice_dim (LONGEST l, LONGEST h, LONGEST s, struct type *idx)\n+      : low (l),\n+\thigh (h),\n+\tstride (s),\n+\tindex (idx)\n+    { /* Nothing.  */ }\n+\n+    /* The low bound for this dimension of the slice.  */\n+    LONGEST low;\n+\n+    /* The high bound for this dimension of the slice.  */\n+    LONGEST high;\n+\n+    /* The byte stride for this dimension of the slice.  */\n+    LONGEST stride;\n+\n+    struct type *index;\n+  };\n+\n+  /* The dimensions of the resulting slice.  */\n+  std::vector<slice_dim> slice_dims;\n+\n+  /* Process the incoming arguments.   These arguments are in the reverse\n+     order to the array dimensions, that is the first argument refers to\n+     the last array dimension.  */\n+  if (fortran_array_slicing_debug)\n+    debug_printf (\"Processing array access:\\n\");\n+  for (int i = 0; i < nargs; ++i)\n+    {\n+      /* For each dimension of the array the user will have either provided\n+\t a ranged access with optional lower bound, upper bound, and\n+\t stride, or the user will have supplied a single index.  */\n+      struct type *dim_type = dim_types[ndimensions - (i + 1)];\n+      fortran_range_operation *range_op\n+\t= dynamic_cast<fortran_range_operation *> (ops[i].get ());\n+      if (range_op != nullptr)\n+\t{\n+\t  enum range_flag range_flag = range_op->get_flags ();\n+\n+\t  LONGEST low, high, stride;\n+\t  low = high = stride = 0;\n+\n+\t  if ((range_flag & RANGE_LOW_BOUND_DEFAULT) == 0)\n+\t    low = value_as_long (range_op->evaluate0 (exp, noside));\n+\t  else\n+\t    low = f77_get_lowerbound (dim_type);\n+\t  if ((range_flag & RANGE_HIGH_BOUND_DEFAULT) == 0)\n+\t    high = value_as_long (range_op->evaluate1 (exp, noside));\n+\t  else\n+\t    high = f77_get_upperbound (dim_type);\n+\t  if ((range_flag & RANGE_HAS_STRIDE) == RANGE_HAS_STRIDE)\n+\t    stride = value_as_long (range_op->evaluate2 (exp, noside));\n+\t  else\n+\t    stride = 1;\n+\n+\t  if (stride == 0)\n+\t    error (_(\"stride must not be 0\"));\n+\n+\t  /* Get information about this dimension in the original ARRAY.  */\n+\t  struct type *target_type = TYPE_TARGET_TYPE (dim_type);\n+\t  struct type *index_type = dim_type->index_type ();\n+\t  LONGEST lb = f77_get_lowerbound (dim_type);\n+\t  LONGEST ub = f77_get_upperbound (dim_type);\n+\t  LONGEST sd = index_type->bit_stride ();\n+\t  if (sd == 0)\n+\t    sd = TYPE_LENGTH (target_type) * 8;\n+\n+\t  if (fortran_array_slicing_debug)\n+\t    {\n+\t      debug_printf (\"|-> Range access\\n\");\n+\t      std::string str = type_to_string (dim_type);\n+\t      debug_printf (\"|   |-> Type: %s\\n\", str.c_str ());\n+\t      debug_printf (\"|   |-> Array:\\n\");\n+\t      debug_printf (\"|   |   |-> Low bound: %s\\n\", plongest (lb));\n+\t      debug_printf (\"|   |   |-> High bound: %s\\n\", plongest (ub));\n+\t      debug_printf (\"|   |   |-> Bit stride: %s\\n\", plongest (sd));\n+\t      debug_printf (\"|   |   |-> Byte stride: %s\\n\", plongest (sd / 8));\n+\t      debug_printf (\"|   |   |-> Type size: %s\\n\",\n+\t\t\t    pulongest (TYPE_LENGTH (dim_type)));\n+\t      debug_printf (\"|   |   '-> Target type size: %s\\n\",\n+\t\t\t    pulongest (TYPE_LENGTH (target_type)));\n+\t      debug_printf (\"|   |-> Accessing:\\n\");\n+\t      debug_printf (\"|   |   |-> Low bound: %s\\n\",\n+\t\t\t    plongest (low));\n+\t      debug_printf (\"|   |   |-> High bound: %s\\n\",\n+\t\t\t    plongest (high));\n+\t      debug_printf (\"|   |   '-> Element stride: %s\\n\",\n+\t\t\t    plongest (stride));\n+\t    }\n+\n+\t  /* Check the user hasn't asked for something invalid.  */\n+\t  if (high > ub || low < lb)\n+\t    error (_(\"array subscript out of bounds\"));\n+\n+\t  /* Calculate what this dimension of the new slice array will look\n+\t     like.  OFFSET is the byte offset from the start of the\n+\t     previous (more outer) dimension to the start of this\n+\t     dimension.  E_COUNT is the number of elements in this\n+\t     dimension.  REMAINDER is the number of elements remaining\n+\t     between the last included element and the upper bound.  For\n+\t     example an access '1:6:2' will include elements 1, 3, 5 and\n+\t     have a remainder of 1 (element #6).  */\n+\t  LONGEST lowest = std::min (low, high);\n+\t  LONGEST offset = (sd / 8) * (lowest - lb);\n+\t  LONGEST e_count = std::abs (high - low) + 1;\n+\t  e_count = (e_count + (std::abs (stride) - 1)) / std::abs (stride);\n+\t  LONGEST new_low = 1;\n+\t  LONGEST new_high = new_low + e_count - 1;\n+\t  LONGEST new_stride = (sd * stride) / 8;\n+\t  LONGEST last_elem = low + ((e_count - 1) * stride);\n+\t  LONGEST remainder = high - last_elem;\n+\t  if (low > high)\n+\t    {\n+\t      offset += std::abs (remainder) * TYPE_LENGTH (target_type);\n+\t      if (stride > 0)\n+\t\terror (_(\"incorrect stride and boundary combination\"));\n+\t    }\n+\t  else if (stride < 0)\n+\t    error (_(\"incorrect stride and boundary combination\"));\n+\n+\t  /* Is the data within this dimension contiguous?  It is if the\n+\t     newly computed stride is the same size as a single element of\n+\t     this dimension.  */\n+\t  bool is_dim_contiguous = (new_stride == slice_element_size);\n+\t  is_all_contiguous &= is_dim_contiguous;\n+\n+\t  if (fortran_array_slicing_debug)\n+\t    {\n+\t      debug_printf (\"|   '-> Results:\\n\");\n+\t      debug_printf (\"|       |-> Offset = %s\\n\", plongest (offset));\n+\t      debug_printf (\"|       |-> Elements = %s\\n\", plongest (e_count));\n+\t      debug_printf (\"|       |-> Low bound = %s\\n\", plongest (new_low));\n+\t      debug_printf (\"|       |-> High bound = %s\\n\",\n+\t\t\t    plongest (new_high));\n+\t      debug_printf (\"|       |-> Byte stride = %s\\n\",\n+\t\t\t    plongest (new_stride));\n+\t      debug_printf (\"|       |-> Last element = %s\\n\",\n+\t\t\t    plongest (last_elem));\n+\t      debug_printf (\"|       |-> Remainder = %s\\n\",\n+\t\t\t    plongest (remainder));\n+\t      debug_printf (\"|       '-> Contiguous = %s\\n\",\n+\t\t\t    (is_dim_contiguous ? \"Yes\" : \"No\"));\n+\t    }\n+\n+\t  /* Figure out how big (in bytes) an element of this dimension of\n+\t     the new array slice will be.  */\n+\t  slice_element_size = std::abs (new_stride * e_count);\n+\n+\t  slice_dims.emplace_back (new_low, new_high, new_stride,\n+\t\t\t\t   index_type);\n+\n+\t  /* Update the total offset.  */\n+\t  total_offset += offset;\n+\t}\n+      else\n+\t{\n+\t  /* There is a single index for this dimension.  */\n+\t  LONGEST index\n+\t    = value_as_long (ops[i]->evaluate_with_coercion (exp, noside));\n+\n+\t  /* Get information about this dimension in the original ARRAY.  */\n+\t  struct type *target_type = TYPE_TARGET_TYPE (dim_type);\n+\t  struct type *index_type = dim_type->index_type ();\n+\t  LONGEST lb = f77_get_lowerbound (dim_type);\n+\t  LONGEST ub = f77_get_upperbound (dim_type);\n+\t  LONGEST sd = index_type->bit_stride () / 8;\n+\t  if (sd == 0)\n+\t    sd = TYPE_LENGTH (target_type);\n+\n+\t  if (fortran_array_slicing_debug)\n+\t    {\n+\t      debug_printf (\"|-> Index access\\n\");\n+\t      std::string str = type_to_string (dim_type);\n+\t      debug_printf (\"|   |-> Type: %s\\n\", str.c_str ());\n+\t      debug_printf (\"|   |-> Array:\\n\");\n+\t      debug_printf (\"|   |   |-> Low bound: %s\\n\", plongest (lb));\n+\t      debug_printf (\"|   |   |-> High bound: %s\\n\", plongest (ub));\n+\t      debug_printf (\"|   |   |-> Byte stride: %s\\n\", plongest (sd));\n+\t      debug_printf (\"|   |   |-> Type size: %s\\n\",\n+\t\t\t    pulongest (TYPE_LENGTH (dim_type)));\n+\t      debug_printf (\"|   |   '-> Target type size: %s\\n\",\n+\t\t\t    pulongest (TYPE_LENGTH (target_type)));\n+\t      debug_printf (\"|   '-> Accessing:\\n\");\n+\t      debug_printf (\"|       '-> Index: %s\\n\",\n+\t\t\t    plongest (index));\n+\t    }\n+\n+\t  /* If the array has actual content then check the index is in\n+\t     bounds.  An array without content (an unbound array) doesn't\n+\t     have a known upper bound, so don't error check in that\n+\t     situation.  */\n+\t  if (index < lb\n+\t      || (dim_type->index_type ()->bounds ()->high.kind () != PROP_UNDEFINED\n+\t\t  && index > ub)\n+\t      || (VALUE_LVAL (array) != lval_memory\n+\t\t  && dim_type->index_type ()->bounds ()->high.kind () == PROP_UNDEFINED))\n+\t    {\n+\t      if (type_not_associated (dim_type))\n+\t\terror (_(\"no such vector element (vector not associated)\"));\n+\t      else if (type_not_allocated (dim_type))\n+\t\terror (_(\"no such vector element (vector not allocated)\"));\n+\t      else\n+\t\terror (_(\"no such vector element\"));\n+\t    }\n+\n+\t  /* Calculate using the type stride, not the target type size.  */\n+\t  LONGEST offset = sd * (index - lb);\n+\t  total_offset += offset;\n+\t}\n+    }\n+\n+  /* Build a type that represents the new array slice in the target memory\n+     of the original ARRAY, this type makes use of strides to correctly\n+     find only those elements that are part of the new slice.  */\n+  struct type *array_slice_type = inner_element_type;\n+  for (const auto &d : slice_dims)\n+    {\n+      /* Create the range.  */\n+      dynamic_prop p_low, p_high, p_stride;\n+\n+      p_low.set_const_val (d.low);\n+      p_high.set_const_val (d.high);\n+      p_stride.set_const_val (d.stride);\n+\n+      struct type *new_range\n+\t= create_range_type_with_stride ((struct type *) NULL,\n+\t\t\t\t\t TYPE_TARGET_TYPE (d.index),\n+\t\t\t\t\t &p_low, &p_high, 0, &p_stride,\n+\t\t\t\t\t true);\n+      array_slice_type\n+\t= create_array_type (nullptr, array_slice_type, new_range);\n+    }\n+\n+  if (fortran_array_slicing_debug)\n+    {\n+      debug_printf (\"'-> Final result:\\n\");\n+      debug_printf (\"    |-> Type: %s\\n\",\n+\t\t    type_to_string (array_slice_type).c_str ());\n+      debug_printf (\"    |-> Total offset: %s\\n\",\n+\t\t    plongest (total_offset));\n+      debug_printf (\"    |-> Base address: %s\\n\",\n+\t\t    core_addr_to_string (value_address (array)));\n+      debug_printf (\"    '-> Contiguous = %s\\n\",\n+\t\t    (is_all_contiguous ? \"Yes\" : \"No\"));\n+    }\n+\n+  /* Should we repack this array slice?  */\n+  if (!is_all_contiguous && (repack_array_slices || is_string_p))\n+    {\n+      /* Build a type for the repacked slice.  */\n+      struct type *repacked_array_type = inner_element_type;\n+      for (const auto &d : slice_dims)\n+\t{\n+\t  /* Create the range.  */\n+\t  dynamic_prop p_low, p_high, p_stride;\n+\n+\t  p_low.set_const_val (d.low);\n+\t  p_high.set_const_val (d.high);\n+\t  p_stride.set_const_val (TYPE_LENGTH (repacked_array_type));\n+\n+\t  struct type *new_range\n+\t    = create_range_type_with_stride ((struct type *) NULL,\n+\t\t\t\t\t     TYPE_TARGET_TYPE (d.index),\n+\t\t\t\t\t     &p_low, &p_high, 0, &p_stride,\n+\t\t\t\t\t     true);\n+\t  repacked_array_type\n+\t    = create_array_type (nullptr, repacked_array_type, new_range);\n+\t}\n+\n+      /* Now copy the elements from the original ARRAY into the packed\n+\t array value DEST.  */\n+      struct value *dest = allocate_value (repacked_array_type);\n+      if (value_lazy (array)\n+\t  || (total_offset + TYPE_LENGTH (array_slice_type)\n+\t      > TYPE_LENGTH (check_typedef (value_type (array)))))\n+\t{\n+\t  fortran_array_walker<fortran_lazy_array_repacker_impl> p\n+\t    (array_slice_type, value_address (array) + total_offset, dest);\n+\t  p.walk ();\n+\t}\n+      else\n+\t{\n+\t  fortran_array_walker<fortran_array_repacker_impl> p\n+\t    (array_slice_type, value_address (array) + total_offset,\n+\t     total_offset, array, dest);\n+\t  p.walk ();\n+\t}\n+      array = dest;\n+    }\n+  else\n+    {\n+      if (VALUE_LVAL (array) == lval_memory)\n+\t{\n+\t  /* If the value we're taking a slice from is not yet loaded, or\n+\t     the requested slice is outside the values content range then\n+\t     just create a new lazy value pointing at the memory where the\n+\t     contents we're looking for exist.  */\n+\t  if (value_lazy (array)\n+\t      || (total_offset + TYPE_LENGTH (array_slice_type)\n+\t\t  > TYPE_LENGTH (check_typedef (value_type (array)))))\n+\t    array = value_at_lazy (array_slice_type,\n+\t\t\t\t   value_address (array) + total_offset);\n+\t  else\n+\t    array = value_from_contents_and_address (array_slice_type,\n+\t\t\t\t\t\t     (value_contents (array)\n+\t\t\t\t\t\t      + total_offset),\n+\t\t\t\t\t\t     (value_address (array)\n+\t\t\t\t\t\t      + total_offset));\n+\t}\n+      else if (!value_lazy (array))\n+\tarray = value_from_component (array, array_slice_type, total_offset);\n+      else\n+\terror (_(\"cannot subscript arrays that are not in memory\"));\n+    }\n+\n+  return array;\n+}\n+\n+value *\n+fortran_undetermined::evaluate (struct type *expect_type,\n+\t\t\t\tstruct expression *exp,\n+\t\t\t\tenum noside noside)\n+{\n+  value *callee = std::get<0> (m_storage)->evaluate (nullptr, exp, noside);\n+  struct type *type = check_typedef (value_type (callee));\n+  enum type_code code = type->code ();\n+\n+  if (code == TYPE_CODE_PTR)\n+    {\n+      /* Fortran always passes variable to subroutines as pointer.\n+\t So we need to look into its target type to see if it is\n+\t array, string or function.  If it is, we need to switch\n+\t to the target value the original one points to.  */\n+      struct type *target_type = check_typedef (TYPE_TARGET_TYPE (type));\n+\n+      if (target_type->code () == TYPE_CODE_ARRAY\n+\t  || target_type->code () == TYPE_CODE_STRING\n+\t  || target_type->code () == TYPE_CODE_FUNC)\n+\t{\n+\t  callee = value_ind (callee);\n+\t  type = check_typedef (value_type (callee));\n+\t  code = type->code ();\n+\t}\n+    }\n+\n+  switch (code)\n+    {\n+    case TYPE_CODE_ARRAY:\n+    case TYPE_CODE_STRING:\n+      return value_subarray (callee, exp, noside);\n+\n+    case TYPE_CODE_PTR:\n+    case TYPE_CODE_FUNC:\n+    case TYPE_CODE_INTERNAL_FUNCTION:\n+      {\n+\t/* It's a function call.  Allocate arg vector, including\n+\t   space for the function to be called in argvec[0] and a\n+\t   termination NULL.  */\n+\tconst std::vector<operation_up> &actual (std::get<1> (m_storage));\n+\tstd::vector<value *> argvec (actual.size ());\n+\tbool is_internal_func = (code == TYPE_CODE_INTERNAL_FUNCTION);\n+\tfor (int tem = 0; tem < argvec.size (); tem++)\n+\t  argvec[tem] = fortran_prepare_argument (exp, actual[tem].get (),\n+\t\t\t\t\t\t  tem, is_internal_func,\n+\t\t\t\t\t\t  value_type (callee),\n+\t\t\t\t\t\t  noside);\n+\treturn evaluate_subexp_do_call (exp, noside, callee, argvec,\n+\t\t\t\t\tnullptr, expect_type);\n+      }\n+\n+    default:\n+      error (_(\"Cannot perform substring on this type\"));\n+    }\n+}\n+\n+} /* namespace expr */\n+\n /* Special expression lengths for Fortran.  */\n \n static void\n@@ -1915,6 +2387,65 @@ fortran_prepare_argument (struct expression *exp, int *pos,\n   return fortran_argument_convert (arg_val, is_artificial);\n }\n \n+/* Prepare (and return) an argument value ready for an inferior function\n+   call to a Fortran function.  EXP and POS are the expressions describing\n+   the argument to prepare.  ARG_NUM is the argument number being\n+   prepared, with 0 being the first argument and so on.  FUNC_TYPE is the\n+   type of the function being called.\n+\n+   IS_INTERNAL_CALL_P is true if this is a call to a function of type\n+   TYPE_CODE_INTERNAL_FUNCTION, otherwise this parameter is false.\n+\n+   NOSIDE has its usual meaning for expression parsing (see eval.c).\n+\n+   Arguments in Fortran are normally passed by address, we coerce the\n+   arguments here rather than in value_arg_coerce as otherwise the call to\n+   malloc (to place the non-lvalue parameters in target memory) is hit by\n+   this Fortran specific logic.  This results in malloc being called with a\n+   pointer to an integer followed by an attempt to malloc the arguments to\n+   malloc in target memory.  Infinite recursion ensues.  */\n+\n+static value *\n+fortran_prepare_argument (struct expression *exp,\n+\t\t\t  expr::operation *subexp,\n+\t\t\t  int arg_num, bool is_internal_call_p,\n+\t\t\t  struct type *func_type, enum noside noside)\n+{\n+  if (is_internal_call_p)\n+    return subexp->evaluate_with_coercion (exp, noside);\n+\n+  bool is_artificial = ((arg_num >= func_type->num_fields ())\n+\t\t\t? true\n+\t\t\t: TYPE_FIELD_ARTIFICIAL (func_type, arg_num));\n+\n+  /* If this is an artificial argument, then either, this is an argument\n+     beyond the end of the known arguments, or possibly, there are no known\n+     arguments (maybe missing debug info).\n+\n+     For these artificial arguments, if the user has prefixed it with '&'\n+     (for address-of), then lets always allow this to succeed, even if the\n+     argument is not actually in inferior memory.  This will allow the user\n+     to pass arguments to a Fortran function even when there's no debug\n+     information.\n+\n+     As we already pass the address of non-artificial arguments, all we\n+     need to do if skip the UNOP_ADDR operator in the expression and mark\n+     the argument as non-artificial.  */\n+  if (is_artificial)\n+    {\n+      expr::unop_addr_operation *addrop\n+\t= dynamic_cast<expr::unop_addr_operation *> (subexp);\n+      if (addrop != nullptr)\n+\t{\n+\t  subexp = addrop->get_expression ().get ();\n+\t  is_artificial = false;\n+\t}\n+    }\n+\n+  struct value *arg_val = subexp->evaluate_with_coercion (exp, noside);\n+  return fortran_argument_convert (arg_val, is_artificial);\n+}\n+\n /* See f-lang.h.  */\n \n struct type *"
    }
  ]
}