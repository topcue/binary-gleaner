{
  "sha": "bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmFiNmFlYzEyNTViYTJlYzhkZTNhZTAzNjM5NThlMmZmMjZjZTI1ZA==",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2019-11-08T08:03:23Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2019-11-08T08:03:23Z"
    },
    "message": "x86: introduce operand type \"class\"\n\nMany operand types, in particular the various kinds of registers, can't\nbe combined with one another (neither in templates nor in register\nentries), and hence it is not a good use of resources (memory as well as\nexecution time) to represent them as individual bits of a bit field.",
    "tree": {
      "sha": "efe48ee35c00c178caec897d69237980ef1f83cf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/efe48ee35c00c178caec897d69237980ef1f83cf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "831bd6aa3b2d5e36c94b89756f58bb99f35026ca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/831bd6aa3b2d5e36c94b89756f58bb99f35026ca",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/831bd6aa3b2d5e36c94b89756f58bb99f35026ca"
    }
  ],
  "stats": {
    "total": 384,
    "additions": 238,
    "deletions": 146
  },
  "files": [
    {
      "sha": "a2937f8663aed767c28fe82c2a6fe2f60305243f",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
      "patch": "@@ -1,3 +1,17 @@\n+2019-11-08  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* config/tc-i386.c (operand_type_set, operand_type_and,\n+\toperand_type_and_not, operand_type_or, operand_type_xor): Handle\n+\t\"class\" field specially.\n+\t(anyimm): New.\n+\t(operand_type_check, operand_size_match,\n+\toperand_type_register_match, pi, md_assemble, is_short_form,\n+\tprocess_suffix, check_byte_reg, check_long_reg, check_qword_reg,\n+\tcheck_word_reg, process_operands, build_modrm_byte): Use \"class\"\n+\tinstead of \"reg\" field.\n+\t(optimize_imm): Likewise. Reduce redundancy. Adjust calculation\n+\tof \"allowed\".\n+\n 2019-11-07  Mihail Ionescu  <mihail.ionescu@arm.com>\n \n \t* testsuite/gas/aarch64/dgh.s: New test."
    },
    {
      "sha": "32f855020329498108468657bf25a430548ae5d8",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 59,
      "deletions": 41,
      "changes": 100,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
      "patch": "@@ -1611,6 +1611,8 @@ operand_type_set (union i386_operand_type *x, unsigned int v)\n     default:\n       abort ();\n     }\n+\n+  x->bitfield.class = ClassNone;\n }\n \n static INLINE int\n@@ -1825,6 +1827,9 @@ cpu_flags_match (const insn_template *t)\n static INLINE i386_operand_type\n operand_type_and (i386_operand_type x, i386_operand_type y)\n {\n+  if (x.bitfield.class != y.bitfield.class)\n+    x.bitfield.class = ClassNone;\n+\n   switch (ARRAY_SIZE (x.array))\n     {\n     case 3:\n@@ -1845,6 +1850,8 @@ operand_type_and (i386_operand_type x, i386_operand_type y)\n static INLINE i386_operand_type\n operand_type_and_not (i386_operand_type x, i386_operand_type y)\n {\n+  gas_assert (y.bitfield.class == ClassNone);\n+\n   switch (ARRAY_SIZE (x.array))\n     {\n     case 3:\n@@ -1865,6 +1872,10 @@ operand_type_and_not (i386_operand_type x, i386_operand_type y)\n static INLINE i386_operand_type\n operand_type_or (i386_operand_type x, i386_operand_type y)\n {\n+  gas_assert (x.bitfield.class == ClassNone ||\n+              y.bitfield.class == ClassNone ||\n+              x.bitfield.class == y.bitfield.class);\n+\n   switch (ARRAY_SIZE (x.array))\n     {\n     case 3:\n@@ -1885,6 +1896,8 @@ operand_type_or (i386_operand_type x, i386_operand_type y)\n static INLINE i386_operand_type\n operand_type_xor (i386_operand_type x, i386_operand_type y)\n {\n+  gas_assert (y.bitfield.class == ClassNone);\n+\n   switch (ARRAY_SIZE (x.array))\n     {\n     case 3:\n@@ -1906,8 +1919,8 @@ static const i386_operand_type disp16 = OPERAND_TYPE_DISP16;\n static const i386_operand_type disp32 = OPERAND_TYPE_DISP32;\n static const i386_operand_type disp32s = OPERAND_TYPE_DISP32S;\n static const i386_operand_type disp16_32 = OPERAND_TYPE_DISP16_32;\n-static const i386_operand_type anydisp\n-  = OPERAND_TYPE_ANYDISP;\n+static const i386_operand_type anydisp = OPERAND_TYPE_ANYDISP;\n+static const i386_operand_type anyimm = OPERAND_TYPE_ANYIMM;\n static const i386_operand_type regxmm = OPERAND_TYPE_REGXMM;\n static const i386_operand_type regmask = OPERAND_TYPE_REGMASK;\n static const i386_operand_type imm8 = OPERAND_TYPE_IMM8;\n@@ -1934,7 +1947,7 @@ operand_type_check (i386_operand_type t, enum operand_type c)\n   switch (c)\n     {\n     case reg:\n-      return t.bitfield.reg;\n+      return t.bitfield.class == Reg;\n \n     case imm:\n       return (t.bitfield.imm8\n@@ -2052,11 +2065,11 @@ operand_size_match (const insn_template *t)\n   /* Check memory and accumulator operand size.  */\n   for (j = 0; j < i.operands; j++)\n     {\n-      if (!i.types[j].bitfield.reg && !i.types[j].bitfield.regsimd\n+      if (i.types[j].bitfield.class != Reg && !i.types[j].bitfield.regsimd\n \t  && t->operand_types[j].bitfield.anysize)\n \tcontinue;\n \n-      if (t->operand_types[j].bitfield.reg\n+      if (t->operand_types[j].bitfield.class == Reg\n \t  && !match_operand_size (t, j, j))\n \t{\n \t  match = 0;\n@@ -2099,7 +2112,7 @@ operand_size_match (const insn_template *t)\n     {\n       unsigned int given = i.operands - j - 1;\n \n-      if (t->operand_types[j].bitfield.reg\n+      if (t->operand_types[j].bitfield.class == Reg\n \t  && !match_operand_size (t, j, given))\n \tgoto mismatch;\n \n@@ -2159,14 +2172,14 @@ operand_type_register_match (i386_operand_type g0,\n \t\t\t     i386_operand_type g1,\n \t\t\t     i386_operand_type t1)\n {\n-  if (!g0.bitfield.reg\n+  if (g0.bitfield.class != Reg\n       && !g0.bitfield.regsimd\n       && (!operand_type_check (g0, anymem)\n \t  || g0.bitfield.unspecified\n \t  || !t0.bitfield.regsimd))\n     return 1;\n \n-  if (!g1.bitfield.reg\n+  if (g1.bitfield.class != Reg\n       && !g1.bitfield.regsimd\n       && (!operand_type_check (g1, anymem)\n \t  || g1.bitfield.unspecified\n@@ -3032,7 +3045,7 @@ pi (const char *line, i386_insn *x)\n       fprintf (stdout, \"    #%d:  \", j + 1);\n       pt (x->types[j]);\n       fprintf (stdout, \"\\n\");\n-      if (x->types[j].bitfield.reg\n+      if (x->types[j].bitfield.class == Reg\n \t  || x->types[j].bitfield.regmmx\n \t  || x->types[j].bitfield.regsimd\n \t  || x->types[j].bitfield.sreg\n@@ -4506,12 +4519,12 @@ md_assemble (char *line)\n      instruction already has a prefix, we need to convert old\n      registers to new ones.  */\n \n-  if ((i.types[0].bitfield.reg && i.types[0].bitfield.byte\n+  if ((i.types[0].bitfield.class == Reg && i.types[0].bitfield.byte\n        && (i.op[0].regs->reg_flags & RegRex64) != 0)\n-      || (i.types[1].bitfield.reg && i.types[1].bitfield.byte\n+      || (i.types[1].bitfield.class == Reg && i.types[1].bitfield.byte\n \t  && (i.op[1].regs->reg_flags & RegRex64) != 0)\n-      || (((i.types[0].bitfield.reg && i.types[0].bitfield.byte)\n-\t   || (i.types[1].bitfield.reg && i.types[1].bitfield.byte))\n+      || (((i.types[0].bitfield.class == Reg && i.types[0].bitfield.byte)\n+\t   || (i.types[1].bitfield.class == Reg && i.types[1].bitfield.byte))\n \t  && i.rex != 0))\n     {\n       int x;\n@@ -4520,7 +4533,7 @@ md_assemble (char *line)\n       for (x = 0; x < 2; x++)\n \t{\n \t  /* Look for 8 bit operand that uses old registers.  */\n-\t  if (i.types[x].bitfield.reg && i.types[x].bitfield.byte\n+\t  if (i.types[x].bitfield.class == Reg && i.types[x].bitfield.byte\n \t      && (i.op[x].regs->reg_flags & RegRex64) == 0)\n \t    {\n \t      /* In case it is \"hi\" register, give up.  */\n@@ -4545,7 +4558,7 @@ md_assemble (char *line)\n \t the REX_OPCODE byte.  */\n       int x;\n       for (x = 0; x < 2; x++)\n-\tif (i.types[x].bitfield.reg\n+\tif (i.types[x].bitfield.class == Reg\n \t    && i.types[x].bitfield.byte\n \t    && (i.op[x].regs->reg_flags & RegRex64) == 0\n \t    && i.op[x].regs->reg_num > 3)\n@@ -5066,22 +5079,24 @@ optimize_imm (void)\n \t but the following works for instructions with immediates.\n \t In any case, we can't set i.suffix yet.  */\n       for (op = i.operands; --op >= 0;)\n-\tif (i.types[op].bitfield.reg && i.types[op].bitfield.byte)\n+\tif (i.types[op].bitfield.class != Reg)\n+\t  continue;\n+\telse if (i.types[op].bitfield.byte)\n \t  {\n \t    guess_suffix = BYTE_MNEM_SUFFIX;\n \t    break;\n \t  }\n-\telse if (i.types[op].bitfield.reg && i.types[op].bitfield.word)\n+\telse if (i.types[op].bitfield.word)\n \t  {\n \t    guess_suffix = WORD_MNEM_SUFFIX;\n \t    break;\n \t  }\n-\telse if (i.types[op].bitfield.reg && i.types[op].bitfield.dword)\n+\telse if (i.types[op].bitfield.dword)\n \t  {\n \t    guess_suffix = LONG_MNEM_SUFFIX;\n \t    break;\n \t  }\n-\telse if (i.types[op].bitfield.reg && i.types[op].bitfield.qword)\n+\telse if (i.types[op].bitfield.qword)\n \t  {\n \t    guess_suffix = QWORD_MNEM_SUFFIX;\n \t    break;\n@@ -5170,8 +5185,10 @@ optimize_imm (void)\n \t      for (t = current_templates->start;\n \t\t   t < current_templates->end;\n \t\t   ++t)\n-\t\tallowed = operand_type_or (allowed,\n-\t\t\t\t\t   t->operand_types[op]);\n+\t\t{\n+\t\t  allowed = operand_type_or (allowed, t->operand_types[op]);\n+\t\t  allowed = operand_type_and (allowed, anyimm);\n+\t\t}\n \t      switch (guess_suffix)\n \t\t{\n \t\tcase QWORD_MNEM_SUFFIX:\n@@ -6248,7 +6265,8 @@ process_suffix (void)\n \t     Destination register type is more significant than source\n \t     register type.  crc32 in SSE4.2 prefers source register\n \t     type. */\n-\t  if (i.tm.base_opcode == 0xf20f38f0 && i.types[0].bitfield.reg)\n+\t  if (i.tm.base_opcode == 0xf20f38f0\n+\t      && i.types[0].bitfield.class == Reg)\n \t    {\n \t      if (i.types[0].bitfield.byte)\n \t\ti.suffix = BYTE_MNEM_SUFFIX;\n@@ -6276,7 +6294,7 @@ process_suffix (void)\n \t\tif (!i.tm.operand_types[op].bitfield.inoutportreg\n \t\t    && !i.tm.operand_types[op].bitfield.shiftcount)\n \t\t  {\n-\t\t    if (!i.types[op].bitfield.reg)\n+\t\t    if (i.types[op].bitfield.class != Reg)\n \t\t      continue;\n \t\t    if (i.types[op].bitfield.byte)\n \t\t      i.suffix = BYTE_MNEM_SUFFIX;\n@@ -6451,7 +6469,7 @@ process_suffix (void)\n \t size prefix, except for instructions that will ignore this\n \t prefix anyway.  */\n       if (i.reg_operands > 0\n-\t  && i.types[0].bitfield.reg\n+\t  && i.types[0].bitfield.class == Reg\n \t  && i.tm.opcode_modifier.addrprefixopreg\n \t  && (i.tm.opcode_modifier.immext\n \t      || i.operands == 1))\n@@ -6519,7 +6537,7 @@ process_suffix (void)\n \t}\n \n       for (op = 0; op < i.operands; op++)\n-\tif (i.types[op].bitfield.reg\n+\tif (i.types[op].bitfield.class == Reg\n \t    && ((need == need_word\n \t\t && !i.op[op].regs->reg_type.bitfield.word)\n \t\t|| (need == need_dword\n@@ -6544,7 +6562,7 @@ check_byte_reg (void)\n   for (op = i.operands; --op >= 0;)\n     {\n       /* Skip non-register operands. */\n-      if (!i.types[op].bitfield.reg)\n+      if (i.types[op].bitfield.class != Reg)\n \tcontinue;\n \n       /* If this is an eight bit register, it's OK.  If it's the 16 or\n@@ -6583,7 +6601,7 @@ check_byte_reg (void)\n \t  continue;\n \t}\n       /* Any other register is bad.  */\n-      if (i.types[op].bitfield.reg\n+      if (i.types[op].bitfield.class == Reg\n \t  || i.types[op].bitfield.regmmx\n \t  || i.types[op].bitfield.regsimd\n \t  || i.types[op].bitfield.sreg\n@@ -6609,12 +6627,12 @@ check_long_reg (void)\n \n   for (op = i.operands; --op >= 0;)\n     /* Skip non-register operands. */\n-    if (!i.types[op].bitfield.reg)\n+    if (i.types[op].bitfield.class != Reg)\n       continue;\n     /* Reject eight bit registers, except where the template requires\n        them. (eg. movzb)  */\n     else if (i.types[op].bitfield.byte\n-\t     && (i.tm.operand_types[op].bitfield.reg\n+\t     && (i.tm.operand_types[op].bitfield.class == Reg\n \t\t || i.tm.operand_types[op].bitfield.acc)\n \t     && (i.tm.operand_types[op].bitfield.word\n \t\t || i.tm.operand_types[op].bitfield.dword))\n@@ -6629,7 +6647,7 @@ check_long_reg (void)\n     /* Warn if the e prefix on a general reg is missing.  */\n     else if ((!quiet_warnings || flag_code == CODE_64BIT)\n \t     && i.types[op].bitfield.word\n-\t     && (i.tm.operand_types[op].bitfield.reg\n+\t     && (i.tm.operand_types[op].bitfield.class == Reg\n \t\t || i.tm.operand_types[op].bitfield.acc)\n \t     && i.tm.operand_types[op].bitfield.dword)\n       {\n@@ -6651,7 +6669,7 @@ check_long_reg (void)\n       }\n     /* Warn if the r prefix on a general reg is present.  */\n     else if (i.types[op].bitfield.qword\n-\t     && (i.tm.operand_types[op].bitfield.reg\n+\t     && (i.tm.operand_types[op].bitfield.class == Reg\n \t\t || i.tm.operand_types[op].bitfield.acc)\n \t     && i.tm.operand_types[op].bitfield.dword)\n       {\n@@ -6680,12 +6698,12 @@ check_qword_reg (void)\n \n   for (op = i.operands; --op >= 0; )\n     /* Skip non-register operands. */\n-    if (!i.types[op].bitfield.reg)\n+    if (i.types[op].bitfield.class != Reg)\n       continue;\n     /* Reject eight bit registers, except where the template requires\n        them. (eg. movzb)  */\n     else if (i.types[op].bitfield.byte\n-\t     && (i.tm.operand_types[op].bitfield.reg\n+\t     && (i.tm.operand_types[op].bitfield.class == Reg\n \t\t || i.tm.operand_types[op].bitfield.acc)\n \t     && (i.tm.operand_types[op].bitfield.word\n \t\t || i.tm.operand_types[op].bitfield.dword))\n@@ -6700,7 +6718,7 @@ check_qword_reg (void)\n     /* Warn if the r prefix on a general reg is missing.  */\n     else if ((i.types[op].bitfield.word\n \t      || i.types[op].bitfield.dword)\n-\t     && (i.tm.operand_types[op].bitfield.reg\n+\t     && (i.tm.operand_types[op].bitfield.class == Reg\n \t\t || i.tm.operand_types[op].bitfield.acc)\n \t     && i.tm.operand_types[op].bitfield.qword)\n       {\n@@ -6730,12 +6748,12 @@ check_word_reg (void)\n   int op;\n   for (op = i.operands; --op >= 0;)\n     /* Skip non-register operands. */\n-    if (!i.types[op].bitfield.reg)\n+    if (i.types[op].bitfield.class != Reg)\n       continue;\n     /* Reject eight bit registers, except where the template requires\n        them. (eg. movzb)  */\n     else if (i.types[op].bitfield.byte\n-\t     && (i.tm.operand_types[op].bitfield.reg\n+\t     && (i.tm.operand_types[op].bitfield.class == Reg\n \t\t || i.tm.operand_types[op].bitfield.acc)\n \t     && (i.tm.operand_types[op].bitfield.word\n \t\t || i.tm.operand_types[op].bitfield.dword))\n@@ -6751,7 +6769,7 @@ check_word_reg (void)\n     else if ((!quiet_warnings || flag_code == CODE_64BIT)\n \t     && (i.types[op].bitfield.dword\n \t\t || i.types[op].bitfield.qword)\n-\t     && (i.tm.operand_types[op].bitfield.reg\n+\t     && (i.tm.operand_types[op].bitfield.class == Reg\n \t\t || i.tm.operand_types[op].bitfield.acc)\n \t     && i.tm.operand_types[op].bitfield.word)\n       {\n@@ -7049,7 +7067,7 @@ process_operands (void)\n     {\n       /* The register or float register operand is in operand\n \t 0 or 1.  */\n-      unsigned int op = !i.tm.operand_types[0].bitfield.reg;\n+      unsigned int op = i.tm.operand_types[0].bitfield.class != Reg;\n \n       /* Register goes in low 3 bits of opcode.  */\n       i.tm.base_opcode |= i.op[op].regs->reg_num;\n@@ -7284,7 +7302,7 @@ build_modrm_byte (void)\n \n \t      op = i.tm.operand_types[vvvv];\n \t      if ((dest + 1) >= i.operands\n-\t\t  || ((!op.bitfield.reg\n+\t\t  || ((op.bitfield.class != Reg\n \t\t       || (!op.bitfield.dword && !op.bitfield.qword))\n \t\t      && !op.bitfield.regsimd\n \t\t      && !operand_type_equal (&op, &regmask)))\n@@ -7661,7 +7679,7 @@ build_modrm_byte (void)\n \n \t  for (op = 0; op < i.operands; op++)\n \t    {\n-\t      if (i.types[op].bitfield.reg\n+\t      if (i.types[op].bitfield.class == Reg\n \t\t  || i.types[op].bitfield.regbnd\n \t\t  || i.types[op].bitfield.regmask\n \t\t  || i.types[op].bitfield.sreg\n@@ -7743,7 +7761,7 @@ build_modrm_byte (void)\n \t    {\n \t      i386_operand_type *type = &i.tm.operand_types[vex_reg];\n \n-\t      if ((!type->bitfield.reg\n+\t      if ((type->bitfield.class != Reg\n \t\t   || (!type->bitfield.dword && !type->bitfield.qword))\n \t\t  && !type->bitfield.regsimd\n \t\t  && !operand_type_equal (type, &regmask))"
    },
    {
      "sha": "fab75c4d83385063806733c06949a433b7606e4e",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
      "patch": "@@ -1,3 +1,21 @@\n+2019-11-08  Jan Beulich  <jbeulich@suse.com>\n+\n+\t* i386-gen.c (operand_type_init): Add Class=. New\n+\tOPERAND_TYPE_ANYIMM entry.\n+\t(operand_classes): New.\n+\t(operand_types): Drop Reg entry.\n+\t(output_operand_type): New parameter \"class\". Process it.\n+\t(process_i386_operand_type): New local variable \"class\".\n+\t(main): Adjust static assertions.\n+\t* i386-opc.h (CLASS_WIDTH): Define.\n+\t(enum operand_class): New.\n+\t(Reg): Replace by Class. Adjust comment.\n+\t(union i386_operand_type): Replace reg by class.\n+\t* i386-opc.tbl (Reg8, Reg16, Reg32, Reg64, FloatReg): Add\n+\tClass=.\n+\t* i386-reg.tbl: Replace Reg by Class=Reg.\n+\t* i386-init.h: Re-generate.\n+\n 2019-11-07  Mihail Ionescu  <mihail.ionescu@arm.com>\n \n \t* opcodes/aarch64-tbl.h (V8_6_INSN): New macro for v8.6 instructions."
    },
    {
      "sha": "a15be805a86e446d92377adc14ad26e9c0a9cbc2",
      "filename": "opcodes/i386-gen.c",
      "status": "modified",
      "additions": 42,
      "deletions": 13,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-gen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-gen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-gen.c?ref=bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
      "patch": "@@ -388,13 +388,13 @@ static initializer operand_type_init[] =\n   { \"OPERAND_TYPE_NONE\",\n     \"0\" },\n   { \"OPERAND_TYPE_REG8\",\n-    \"Reg|Byte\" },\n+    \"Class=Reg|Byte\" },\n   { \"OPERAND_TYPE_REG16\",\n-    \"Reg|Word\" },\n+    \"Class=Reg|Word\" },\n   { \"OPERAND_TYPE_REG32\",\n-    \"Reg|Dword\" },\n+    \"Class=Reg|Dword\" },\n   { \"OPERAND_TYPE_REG64\",\n-    \"Reg|Qword\" },\n+    \"Class=Reg|Qword\" },\n   { \"OPERAND_TYPE_IMM1\",\n     \"Imm1\" },\n   { \"OPERAND_TYPE_IMM8\",\n@@ -432,7 +432,7 @@ static initializer operand_type_init[] =\n   { \"OPERAND_TYPE_DEBUG\",\n     \"Debug\" },\n   { \"OPERAND_TYPE_FLOATREG\",\n-    \"Reg|Tbyte\" },\n+    \"Class=Reg|Tbyte\" },\n   { \"OPERAND_TYPE_FLOATACC\",\n     \"Acc|Tbyte\" },\n   { \"OPERAND_TYPE_SREG\",\n@@ -479,6 +479,8 @@ static initializer operand_type_init[] =\n     \"Imm32|Imm32S|Imm64|Disp32\" },\n   { \"OPERAND_TYPE_IMM32_32S_64_DISP32_64\",\n     \"Imm32|Imm32S|Imm64|Disp32|Disp64\" },\n+  { \"OPERAND_TYPE_ANYIMM\",\n+    \"Imm1|Imm8|Imm8S|Imm16|Imm32|Imm32S|Imm64\" },\n   { \"OPERAND_TYPE_REGBND\",\n     \"RegBND\" },\n };\n@@ -674,9 +676,19 @@ static bitfield opcode_modifiers[] =\n   BITFIELD (Intel64),\n };\n \n+#define CLASS(n) #n, n\n+\n+static const struct {\n+  const char *name;\n+  enum operand_class value;\n+} operand_classes[] = {\n+  CLASS (Reg),\n+};\n+\n+#undef CLASS\n+\n static bitfield operand_types[] =\n {\n-  BITFIELD (Reg),\n   BITFIELD (RegMMX),\n   BITFIELD (RegSIMD),\n   BITFIELD (RegMask),\n@@ -1134,20 +1146,21 @@ enum stage {\n };\n \n static void\n-output_operand_type (FILE *table, bitfield *types, unsigned int size,\n+output_operand_type (FILE *table, enum operand_class class,\n+\t\t     const bitfield *types, unsigned int size,\n \t\t     enum stage stage, const char *indent)\n {\n   unsigned int i;\n \n-  fprintf (table, \"{ { \");\n+  fprintf (table, \"{ { %d, \", class);\n \n   for (i = 0; i < size - 1; i++)\n     {\n-      if (((i + 1) % 20) != 0)\n+      if (((i + 2) % 20) != 0)\n \tfprintf (table, \"%d, \", types[i].value);\n       else\n \tfprintf (table, \"%d,\", types[i].value);\n-      if (((i + 1) % 20) == 0)\n+      if (((i + 2) % 20) == 0)\n \t{\n \t  /* We need \\\\ for macro.  */\n \t  if (stage == stage_macros)\n@@ -1165,6 +1178,7 @@ process_i386_operand_type (FILE *table, char *op, enum stage stage,\n \t\t\t   const char *indent, int lineno)\n {\n   char *str, *next, *last;\n+  enum operand_class class = ClassNone;\n   bitfield types [ARRAY_SIZE (operand_types)];\n \n   /* Copy the default operand type.  */\n@@ -1178,6 +1192,21 @@ process_i386_operand_type (FILE *table, char *op, enum stage stage,\n       for (next = op; next && next < last; )\n \t{\n \t  str = next_field (next, '|', &next, last);\n+\t  if (str)\n+\t    {\n+\t      unsigned int i;\n+\n+\t      if (!strncmp(str, \"Class=\", 6))\n+\t\t{\n+\t\t  for (i = 0; i < ARRAY_SIZE(operand_classes); ++i)\n+\t\t    if (!strcmp(str + 6, operand_classes[i].name))\n+\t\t      {\n+\t\t\tclass = operand_classes[i].value;\n+\t\t\tstr = NULL;\n+\t\t\tbreak;\n+\t\t      }\n+\t\t}\n+\t    }\n \t  if (str)\n \t    {\n \t      set_bitfield (str, types, 1, ARRAY_SIZE (types), lineno);\n@@ -1197,7 +1226,7 @@ process_i386_operand_type (FILE *table, char *op, enum stage stage,\n \t    set_bitfield(\"Disp32S\", types, 1, ARRAY_SIZE (types), lineno);\n \t}\n     }\n-  output_operand_type (table, types, ARRAY_SIZE (types), stage,\n+  output_operand_type (table, class, types, ARRAY_SIZE (types), stage,\n \t\t       indent);\n }\n \n@@ -1688,9 +1717,9 @@ main (int argc, char **argv)\n \n   /* Check the unused bitfield in i386_operand_type.  */\n #ifdef OTUnused\n-  static_assert (ARRAY_SIZE (operand_types) == OTNum + 1);\n+  static_assert (ARRAY_SIZE (operand_types) + CLASS_WIDTH == OTNum + 1);\n #else\n-  static_assert (ARRAY_SIZE (operand_types) == OTNum);\n+  static_assert (ARRAY_SIZE (operand_types) + CLASS_WIDTH == OTNum);\n \n   c = OTNumOfBits - OTMax - 1;\n   if (c)"
    },
    {
      "sha": "66e5f11b2367327ff3383ff2eaa37fbd3c1efe5f",
      "filename": "opcodes/i386-init.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-init.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-init.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-init.h?ref=bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
      "patch": "@@ -1551,6 +1551,10 @@\n   { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, \\\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n \n+#define OPERAND_TYPE_ANYIMM \\\n+  { { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, \\\n+      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }\n+\n #define OPERAND_TYPE_REGBND \\\n   { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0 } }"
    },
    {
      "sha": "5c49ac1a528f590acc38203352dd262d04fafefa",
      "filename": "opcodes/i386-opc.h",
      "status": "modified",
      "additions": 13,
      "deletions": 4,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-opc.h?ref=bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
      "patch": "@@ -702,12 +702,21 @@ typedef struct i386_opcode_modifier\n   unsigned int intel64:1;\n } i386_opcode_modifier;\n \n+/* Operand classes.  */\n+\n+#define CLASS_WIDTH 4\n+enum operand_class\n+{\n+  ClassNone,\n+  Reg, /* GPRs and FP regs, distinguished by operand size */\n+};\n+\n /* Position of operand_type bits.  */\n \n enum\n {\n-  /* Register (qualified by Byte, Word, etc) */\n-  Reg = 0,\n+  /* Class */\n+  Class = CLASS_WIDTH - 1,\n   /* MMX register */\n   RegMMX,\n   /* Vector registers */\n@@ -791,7 +800,7 @@ enum\n   /* Bound register.  */\n   RegBND,\n \n-  /* The number of bitfields in i386_operand_type.  */\n+  /* The number of bits in i386_operand_type.  */\n   OTNum\n };\n \n@@ -808,7 +817,7 @@ typedef union i386_operand_type\n {\n   struct\n     {\n-      unsigned int reg:1;\n+      unsigned int class:CLASS_WIDTH;\n       unsigned int regmmx:1;\n       unsigned int regsimd:1;\n       unsigned int regmask:1;"
    },
    {
      "sha": "e4a3d7c2e806c742f55a566c1672af2914d6d5b3",
      "filename": "opcodes/i386-opc.tbl",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-opc.tbl",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-opc.tbl",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-opc.tbl?ref=bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
      "patch": "@@ -22,13 +22,13 @@\n #include \"i386-opc.h\"\n #undef None\n \n-#define Reg8  Reg|Byte\n-#define Reg16 Reg|Word\n-#define Reg32 Reg|Dword\n-#define Reg64 Reg|Qword\n+#define Reg8  Class=Reg|Byte\n+#define Reg16 Class=Reg|Word\n+#define Reg32 Class=Reg|Dword\n+#define Reg64 Class=Reg|Qword\n \n #define FloatAcc Acc|Tbyte\n-#define FloatReg Reg|Tbyte\n+#define FloatReg Class=Reg|Tbyte\n \n #define RegXMM RegSIMD|Xmmword\n #define RegYMM RegSIMD|Ymmword"
    },
    {
      "sha": "8e6a2df2ee5e92f572d1c030f1a563ec068abb28",
      "filename": "opcodes/i386-reg.tbl",
      "status": "modified",
      "additions": 83,
      "deletions": 83,
      "changes": 166,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-reg.tbl",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bab6aec1255ba2ec8de3ae0363958e2ff26ce25d/opcodes/i386-reg.tbl",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-reg.tbl?ref=bab6aec1255ba2ec8de3ae0363958e2ff26ce25d",
      "patch": "@@ -19,82 +19,82 @@\n // 02110-1301, USA.\n \n // Make %st first as we test for it.\n-st, Reg|Acc|Tbyte, 0, 0, 11, 33\n+st, Class=Reg|Acc|Tbyte, 0, 0, 11, 33\n // 8 bit regs\n-al, Reg|Acc|Byte, 0, 0, Dw2Inval, Dw2Inval\n-cl, Reg|Byte|ShiftCount, 0, 1, Dw2Inval, Dw2Inval\n-dl, Reg|Byte, 0, 2, Dw2Inval, Dw2Inval\n-bl, Reg|Byte, 0, 3, Dw2Inval, Dw2Inval\n-ah, Reg|Byte, 0, 4, Dw2Inval, Dw2Inval\n-ch, Reg|Byte, 0, 5, Dw2Inval, Dw2Inval\n-dh, Reg|Byte, 0, 6, Dw2Inval, Dw2Inval\n-bh, Reg|Byte, 0, 7, Dw2Inval, Dw2Inval\n-axl, Reg|Byte, RegRex64, 0, Dw2Inval, Dw2Inval\n-cxl, Reg|Byte, RegRex64, 1, Dw2Inval, Dw2Inval\n-dxl, Reg|Byte, RegRex64, 2, Dw2Inval, Dw2Inval\n-bxl, Reg|Byte, RegRex64, 3, Dw2Inval, Dw2Inval\n-spl, Reg|Byte, RegRex64, 4, Dw2Inval, Dw2Inval\n-bpl, Reg|Byte, RegRex64, 5, Dw2Inval, Dw2Inval\n-sil, Reg|Byte, RegRex64, 6, Dw2Inval, Dw2Inval\n-dil, Reg|Byte, RegRex64, 7, Dw2Inval, Dw2Inval\n-r8b, Reg|Byte, RegRex|RegRex64, 0, Dw2Inval, Dw2Inval\n-r9b, Reg|Byte, RegRex|RegRex64, 1, Dw2Inval, Dw2Inval\n-r10b, Reg|Byte, RegRex|RegRex64, 2, Dw2Inval, Dw2Inval\n-r11b, Reg|Byte, RegRex|RegRex64, 3, Dw2Inval, Dw2Inval\n-r12b, Reg|Byte, RegRex|RegRex64, 4, Dw2Inval, Dw2Inval\n-r13b, Reg|Byte, RegRex|RegRex64, 5, Dw2Inval, Dw2Inval\n-r14b, Reg|Byte, RegRex|RegRex64, 6, Dw2Inval, Dw2Inval\n-r15b, Reg|Byte, RegRex|RegRex64, 7, Dw2Inval, Dw2Inval\n+al, Class=Reg|Acc|Byte, 0, 0, Dw2Inval, Dw2Inval\n+cl, Class=Reg|Byte|ShiftCount, 0, 1, Dw2Inval, Dw2Inval\n+dl, Class=Reg|Byte, 0, 2, Dw2Inval, Dw2Inval\n+bl, Class=Reg|Byte, 0, 3, Dw2Inval, Dw2Inval\n+ah, Class=Reg|Byte, 0, 4, Dw2Inval, Dw2Inval\n+ch, Class=Reg|Byte, 0, 5, Dw2Inval, Dw2Inval\n+dh, Class=Reg|Byte, 0, 6, Dw2Inval, Dw2Inval\n+bh, Class=Reg|Byte, 0, 7, Dw2Inval, Dw2Inval\n+axl, Class=Reg|Byte, RegRex64, 0, Dw2Inval, Dw2Inval\n+cxl, Class=Reg|Byte, RegRex64, 1, Dw2Inval, Dw2Inval\n+dxl, Class=Reg|Byte, RegRex64, 2, Dw2Inval, Dw2Inval\n+bxl, Class=Reg|Byte, RegRex64, 3, Dw2Inval, Dw2Inval\n+spl, Class=Reg|Byte, RegRex64, 4, Dw2Inval, Dw2Inval\n+bpl, Class=Reg|Byte, RegRex64, 5, Dw2Inval, Dw2Inval\n+sil, Class=Reg|Byte, RegRex64, 6, Dw2Inval, Dw2Inval\n+dil, Class=Reg|Byte, RegRex64, 7, Dw2Inval, Dw2Inval\n+r8b, Class=Reg|Byte, RegRex|RegRex64, 0, Dw2Inval, Dw2Inval\n+r9b, Class=Reg|Byte, RegRex|RegRex64, 1, Dw2Inval, Dw2Inval\n+r10b, Class=Reg|Byte, RegRex|RegRex64, 2, Dw2Inval, Dw2Inval\n+r11b, Class=Reg|Byte, RegRex|RegRex64, 3, Dw2Inval, Dw2Inval\n+r12b, Class=Reg|Byte, RegRex|RegRex64, 4, Dw2Inval, Dw2Inval\n+r13b, Class=Reg|Byte, RegRex|RegRex64, 5, Dw2Inval, Dw2Inval\n+r14b, Class=Reg|Byte, RegRex|RegRex64, 6, Dw2Inval, Dw2Inval\n+r15b, Class=Reg|Byte, RegRex|RegRex64, 7, Dw2Inval, Dw2Inval\n // 16 bit regs\n-ax, Reg|Acc|Word, 0, 0, Dw2Inval, Dw2Inval\n-cx, Reg|Word, 0, 1, Dw2Inval, Dw2Inval\n-dx, Reg|Word|InOutPortReg, 0, 2, Dw2Inval, Dw2Inval\n-bx, Reg|Word|BaseIndex, 0, 3, Dw2Inval, Dw2Inval\n-sp, Reg|Word, 0, 4, Dw2Inval, Dw2Inval\n-bp, Reg|Word|BaseIndex, 0, 5, Dw2Inval, Dw2Inval\n-si, Reg|Word|BaseIndex, 0, 6, Dw2Inval, Dw2Inval\n-di, Reg|Word|BaseIndex, 0, 7, Dw2Inval, Dw2Inval\n-r8w, Reg|Word, RegRex, 0, Dw2Inval, Dw2Inval\n-r9w, Reg|Word, RegRex, 1, Dw2Inval, Dw2Inval\n-r10w, Reg|Word, RegRex, 2, Dw2Inval, Dw2Inval\n-r11w, Reg|Word, RegRex, 3, Dw2Inval, Dw2Inval\n-r12w, Reg|Word, RegRex, 4, Dw2Inval, Dw2Inval\n-r13w, Reg|Word, RegRex, 5, Dw2Inval, Dw2Inval\n-r14w, Reg|Word, RegRex, 6, Dw2Inval, Dw2Inval\n-r15w, Reg|Word, RegRex, 7, Dw2Inval, Dw2Inval\n+ax, Class=Reg|Acc|Word, 0, 0, Dw2Inval, Dw2Inval\n+cx, Class=Reg|Word, 0, 1, Dw2Inval, Dw2Inval\n+dx, Class=Reg|Word|InOutPortReg, 0, 2, Dw2Inval, Dw2Inval\n+bx, Class=Reg|Word|BaseIndex, 0, 3, Dw2Inval, Dw2Inval\n+sp, Class=Reg|Word, 0, 4, Dw2Inval, Dw2Inval\n+bp, Class=Reg|Word|BaseIndex, 0, 5, Dw2Inval, Dw2Inval\n+si, Class=Reg|Word|BaseIndex, 0, 6, Dw2Inval, Dw2Inval\n+di, Class=Reg|Word|BaseIndex, 0, 7, Dw2Inval, Dw2Inval\n+r8w, Class=Reg|Word, RegRex, 0, Dw2Inval, Dw2Inval\n+r9w, Class=Reg|Word, RegRex, 1, Dw2Inval, Dw2Inval\n+r10w, Class=Reg|Word, RegRex, 2, Dw2Inval, Dw2Inval\n+r11w, Class=Reg|Word, RegRex, 3, Dw2Inval, Dw2Inval\n+r12w, Class=Reg|Word, RegRex, 4, Dw2Inval, Dw2Inval\n+r13w, Class=Reg|Word, RegRex, 5, Dw2Inval, Dw2Inval\n+r14w, Class=Reg|Word, RegRex, 6, Dw2Inval, Dw2Inval\n+r15w, Class=Reg|Word, RegRex, 7, Dw2Inval, Dw2Inval\n // 32 bit regs\n-eax, Reg|Acc|Dword|BaseIndex, 0, 0, 0, Dw2Inval\n-ecx, Reg|Dword|BaseIndex, 0, 1, 1, Dw2Inval\n-edx, Reg|Dword|BaseIndex, 0, 2, 2, Dw2Inval\n-ebx, Reg|Dword|BaseIndex, 0, 3, 3, Dw2Inval\n-esp, Reg|Dword, 0, 4, 4, Dw2Inval\n-ebp, Reg|Dword|BaseIndex, 0, 5, 5, Dw2Inval\n-esi, Reg|Dword|BaseIndex, 0, 6, 6, Dw2Inval\n-edi, Reg|Dword|BaseIndex, 0, 7, 7, Dw2Inval\n-r8d, Reg|Dword|BaseIndex, RegRex, 0, Dw2Inval, Dw2Inval\n-r9d, Reg|Dword|BaseIndex, RegRex, 1, Dw2Inval, Dw2Inval\n-r10d, Reg|Dword|BaseIndex, RegRex, 2, Dw2Inval, Dw2Inval\n-r11d, Reg|Dword|BaseIndex, RegRex, 3, Dw2Inval, Dw2Inval\n-r12d, Reg|Dword|BaseIndex, RegRex, 4, Dw2Inval, Dw2Inval\n-r13d, Reg|Dword|BaseIndex, RegRex, 5, Dw2Inval, Dw2Inval\n-r14d, Reg|Dword|BaseIndex, RegRex, 6, Dw2Inval, Dw2Inval\n-r15d, Reg|Dword|BaseIndex, RegRex, 7, Dw2Inval, Dw2Inval\n-rax, Reg|Acc|Qword|BaseIndex, 0, 0, Dw2Inval, 0\n-rcx, Reg|Qword|BaseIndex, 0, 1, Dw2Inval, 2\n-rdx, Reg|Qword|BaseIndex, 0, 2, Dw2Inval, 1\n-rbx, Reg|Qword|BaseIndex, 0, 3, Dw2Inval, 3\n-rsp, Reg|Qword, 0, 4, Dw2Inval, 7\n-rbp, Reg|Qword|BaseIndex, 0, 5, Dw2Inval, 6\n-rsi, Reg|Qword|BaseIndex, 0, 6, Dw2Inval, 4\n-rdi, Reg|Qword|BaseIndex, 0, 7, Dw2Inval, 5\n-r8, Reg|Qword|BaseIndex, RegRex, 0, Dw2Inval, 8\n-r9, Reg|Qword|BaseIndex, RegRex, 1, Dw2Inval, 9\n-r10, Reg|Qword|BaseIndex, RegRex, 2, Dw2Inval, 10\n-r11, Reg|Qword|BaseIndex, RegRex, 3, Dw2Inval, 11\n-r12, Reg|Qword|BaseIndex, RegRex, 4, Dw2Inval, 12\n-r13, Reg|Qword|BaseIndex, RegRex, 5, Dw2Inval, 13\n-r14, Reg|Qword|BaseIndex, RegRex, 6, Dw2Inval, 14\n-r15, Reg|Qword|BaseIndex, RegRex, 7, Dw2Inval, 15\n+eax, Class=Reg|Acc|Dword|BaseIndex, 0, 0, 0, Dw2Inval\n+ecx, Class=Reg|Dword|BaseIndex, 0, 1, 1, Dw2Inval\n+edx, Class=Reg|Dword|BaseIndex, 0, 2, 2, Dw2Inval\n+ebx, Class=Reg|Dword|BaseIndex, 0, 3, 3, Dw2Inval\n+esp, Class=Reg|Dword, 0, 4, 4, Dw2Inval\n+ebp, Class=Reg|Dword|BaseIndex, 0, 5, 5, Dw2Inval\n+esi, Class=Reg|Dword|BaseIndex, 0, 6, 6, Dw2Inval\n+edi, Class=Reg|Dword|BaseIndex, 0, 7, 7, Dw2Inval\n+r8d, Class=Reg|Dword|BaseIndex, RegRex, 0, Dw2Inval, Dw2Inval\n+r9d, Class=Reg|Dword|BaseIndex, RegRex, 1, Dw2Inval, Dw2Inval\n+r10d, Class=Reg|Dword|BaseIndex, RegRex, 2, Dw2Inval, Dw2Inval\n+r11d, Class=Reg|Dword|BaseIndex, RegRex, 3, Dw2Inval, Dw2Inval\n+r12d, Class=Reg|Dword|BaseIndex, RegRex, 4, Dw2Inval, Dw2Inval\n+r13d, Class=Reg|Dword|BaseIndex, RegRex, 5, Dw2Inval, Dw2Inval\n+r14d, Class=Reg|Dword|BaseIndex, RegRex, 6, Dw2Inval, Dw2Inval\n+r15d, Class=Reg|Dword|BaseIndex, RegRex, 7, Dw2Inval, Dw2Inval\n+rax, Class=Reg|Acc|Qword|BaseIndex, 0, 0, Dw2Inval, 0\n+rcx, Class=Reg|Qword|BaseIndex, 0, 1, Dw2Inval, 2\n+rdx, Class=Reg|Qword|BaseIndex, 0, 2, Dw2Inval, 1\n+rbx, Class=Reg|Qword|BaseIndex, 0, 3, Dw2Inval, 3\n+rsp, Class=Reg|Qword, 0, 4, Dw2Inval, 7\n+rbp, Class=Reg|Qword|BaseIndex, 0, 5, Dw2Inval, 6\n+rsi, Class=Reg|Qword|BaseIndex, 0, 6, Dw2Inval, 4\n+rdi, Class=Reg|Qword|BaseIndex, 0, 7, Dw2Inval, 5\n+r8, Class=Reg|Qword|BaseIndex, RegRex, 0, Dw2Inval, 8\n+r9, Class=Reg|Qword|BaseIndex, RegRex, 1, Dw2Inval, 9\n+r10, Class=Reg|Qword|BaseIndex, RegRex, 2, Dw2Inval, 10\n+r11, Class=Reg|Qword|BaseIndex, RegRex, 3, Dw2Inval, 11\n+r12, Class=Reg|Qword|BaseIndex, RegRex, 4, Dw2Inval, 12\n+r13, Class=Reg|Qword|BaseIndex, RegRex, 5, Dw2Inval, 13\n+r14, Class=Reg|Qword|BaseIndex, RegRex, 6, Dw2Inval, 14\n+r15, Class=Reg|Qword|BaseIndex, RegRex, 7, Dw2Inval, 15\n // Vector mask registers.\n k0, RegMask, 0, 0, 93, 118\n k1, RegMask, 0, 1, 94, 119\n@@ -283,23 +283,23 @@ bnd0, RegBND, 0, 0, Dw2Inval, Dw2Inval\n bnd1, RegBND, 0, 1, Dw2Inval, Dw2Inval\n bnd2, RegBND, 0, 2, Dw2Inval, Dw2Inval\n bnd3, RegBND, 0, 3, Dw2Inval, Dw2Inval\n-// No Reg will make these registers rejected for all purposes except\n+// No Class=Reg will make these registers rejected for all purposes except\n // for addressing.  This saves creating one extra type for RIP/EIP.\n rip, Qword, RegRex64, RegIP, Dw2Inval, 16\n eip, Dword, RegRex64, RegIP, 8, Dw2Inval\n-// No Reg will make these registers rejected for all purposes except\n+// No Class=Reg will make these registers rejected for all purposes except\n // for addressing.\n riz, Qword|BaseIndex, RegRex64, RegIZ, Dw2Inval, Dw2Inval\n eiz, Dword|BaseIndex, 0, RegIZ, Dw2Inval, Dw2Inval\n // fp regs.\n-st(0), Reg|Acc|Tbyte, 0, 0, 11, 33\n-st(1), Reg|Tbyte, 0, 1, 12, 34\n-st(2), Reg|Tbyte, 0, 2, 13, 35\n-st(3), Reg|Tbyte, 0, 3, 14, 36\n-st(4), Reg|Tbyte, 0, 4, 15, 37\n-st(5), Reg|Tbyte, 0, 5, 16, 38\n-st(6), Reg|Tbyte, 0, 6, 17, 39\n-st(7), Reg|Tbyte, 0, 7, 18, 40\n+st(0), Class=Reg|Acc|Tbyte, 0, 0, 11, 33\n+st(1), Class=Reg|Tbyte, 0, 1, 12, 34\n+st(2), Class=Reg|Tbyte, 0, 2, 13, 35\n+st(3), Class=Reg|Tbyte, 0, 3, 14, 36\n+st(4), Class=Reg|Tbyte, 0, 4, 15, 37\n+st(5), Class=Reg|Tbyte, 0, 5, 16, 38\n+st(6), Class=Reg|Tbyte, 0, 6, 17, 39\n+st(7), Class=Reg|Tbyte, 0, 7, 18, 40\n // Pseudo-register names only used in .cfi_* directives\n eflags, 0, 0, 0, 9, 49\n rflags, 0, 0, 0, Dw2Inval, 49"
    }
  ]
}