{
  "sha": "cf608cc40c523537046efde52e9d68303e8bde00",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2Y2MDhjYzQwYzUyMzUzNzA0NmVmZGU1MmU5ZDY4MzAzZThiZGUwMA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-12-16T00:39:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-12-16T00:41:29Z"
    },
    "message": "C++-ify Ada component interval handling\n\nThe Ada component interval handling code, used for aggregate\nassignments, does a pre-pass over the sub-expressions so that it can\nsize an array.  For my expression rewrite, it was handy to C++-ify\nthis.\n\ngdb/ChangeLog\n2020-12-15  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (num_component_specs): Remove.\n\t(assign_aggregate): Update.\n\t(aggregate_assign_positional, aggregate_assign_from_choices)\n\t(aggregate_assign_others, add_component_interval): Change\n\targuments.",
    "tree": {
      "sha": "5600f5a6b055109909977be83388f37be460b5a1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5600f5a6b055109909977be83388f37be460b5a1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cf608cc40c523537046efde52e9d68303e8bde00",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cf608cc40c523537046efde52e9d68303e8bde00",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cf608cc40c523537046efde52e9d68303e8bde00",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cf608cc40c523537046efde52e9d68303e8bde00/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e1b2362cbf5a03b273e3b69630484710c598ac3f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e1b2362cbf5a03b273e3b69630484710c598ac3f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e1b2362cbf5a03b273e3b69630484710c598ac3f"
    }
  ],
  "stats": {
    "total": 117,
    "additions": 43,
    "deletions": 74
  },
  "files": [
    {
      "sha": "5f2c5b82aa87b3695b150d53a0e91894f8ef5e8a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf608cc40c523537046efde52e9d68303e8bde00/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf608cc40c523537046efde52e9d68303e8bde00/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=cf608cc40c523537046efde52e9d68303e8bde00",
      "patch": "@@ -1,3 +1,11 @@\n+2020-12-15  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (num_component_specs): Remove.\n+\t(assign_aggregate): Update.\n+\t(aggregate_assign_positional, aggregate_assign_from_choices)\n+\t(aggregate_assign_others, add_component_interval): Change\n+\targuments.\n+\n 2020-12-15  Tom Tromey  <tromey@adacore.com>\n \n \t* cli/cli-decode.c (deprecated_cmd_warning): Use title style for"
    },
    {
      "sha": "8f437fcff3c87dcd8a2eb10b67ee1058da8d031a",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 35,
      "deletions": 74,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf608cc40c523537046efde52e9d68303e8bde00/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf608cc40c523537046efde52e9d68303e8bde00/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=cf608cc40c523537046efde52e9d68303e8bde00",
      "patch": "@@ -218,23 +218,24 @@ static struct value *assign_aggregate (struct value *, struct value *,\n \t\t\t\t       struct expression *,\n \t\t\t\t       int *, enum noside);\n \n-static void aggregate_assign_from_choices (struct value *, struct value *, \n+static void aggregate_assign_from_choices (struct value *, struct value *,\n \t\t\t\t\t   struct expression *,\n-\t\t\t\t\t   int *, LONGEST *, int *,\n-\t\t\t\t\t   int, LONGEST, LONGEST);\n+\t\t\t\t\t   int *, std::vector<LONGEST> &,\n+\t\t\t\t\t   LONGEST, LONGEST);\n \n static void aggregate_assign_positional (struct value *, struct value *,\n \t\t\t\t\t struct expression *,\n-\t\t\t\t\t int *, LONGEST *, int *, int,\n+\t\t\t\t\t int *, std::vector<LONGEST> &,\n \t\t\t\t\t LONGEST, LONGEST);\n \n \n static void aggregate_assign_others (struct value *, struct value *,\n \t\t\t\t     struct expression *,\n-\t\t\t\t     int *, LONGEST *, int, LONGEST, LONGEST);\n+\t\t\t\t     int *, std::vector<LONGEST> &,\n+\t\t\t\t     LONGEST, LONGEST);\n \n \n-static void add_component_interval (LONGEST, LONGEST, LONGEST *, int *, int);\n+static void add_component_interval (LONGEST, LONGEST, std::vector<LONGEST> &);\n \n \n static struct value *ada_evaluate_subexp (struct type *, struct expression *,\n@@ -9471,34 +9472,6 @@ ada_value_equal (struct value *arg1, struct value *arg2)\n   return value_equal (arg1, arg2);\n }\n \n-/* Total number of component associations in the aggregate starting at\n-   index PC in EXP.  Assumes that index PC is the start of an\n-   OP_AGGREGATE.  */\n-\n-static int\n-num_component_specs (struct expression *exp, int pc)\n-{\n-  int n, m, i;\n-\n-  m = exp->elts[pc + 1].longconst;\n-  pc += 3;\n-  n = 0;\n-  for (i = 0; i < m; i += 1)\n-    {\n-      switch (exp->elts[pc].opcode) \n-\t{\n-\tdefault:\n-\t  n += 1;\n-\t  break;\n-\tcase OP_CHOICES:\n-\t  n += exp->elts[pc + 1].longconst;\n-\t  break;\n-\t}\n-      ada_evaluate_subexp (NULL, exp, &pc, EVAL_SKIP);\n-    }\n-  return n;\n-}\n-\n /* Assign the result of evaluating EXP starting at *POS to the INDEXth \n    component of LHS (a simple array or a record), updating *POS past\n    the expression, assuming that LHS is contained in CONTAINER.  Does\n@@ -9552,9 +9525,6 @@ assign_aggregate (struct value *container,\n   struct type *lhs_type;\n   int n = exp->elts[*pos+1].longconst;\n   LONGEST low_index, high_index;\n-  int num_specs;\n-  LONGEST *indices;\n-  int max_indices, num_indices;\n   int i;\n \n   *pos += 3;\n@@ -9588,32 +9558,27 @@ assign_aggregate (struct value *container,\n   else\n     error (_(\"Left-hand side must be array or record.\"));\n \n-  num_specs = num_component_specs (exp, *pos - 3);\n-  max_indices = 4 * num_specs + 4;\n-  indices = XALLOCAVEC (LONGEST, max_indices);\n+  std::vector<LONGEST> indices (4);\n   indices[0] = indices[1] = low_index - 1;\n   indices[2] = indices[3] = high_index + 1;\n-  num_indices = 4;\n \n   for (i = 0; i < n; i += 1)\n     {\n       switch (exp->elts[*pos].opcode)\n \t{\n \t  case OP_CHOICES:\n-\t    aggregate_assign_from_choices (container, lhs, exp, pos, indices, \n-\t\t\t\t\t   &num_indices, max_indices,\n+\t    aggregate_assign_from_choices (container, lhs, exp, pos, indices,\n \t\t\t\t\t   low_index, high_index);\n \t    break;\n \t  case OP_POSITIONAL:\n \t    aggregate_assign_positional (container, lhs, exp, pos, indices,\n-\t\t\t\t\t &num_indices, max_indices,\n \t\t\t\t\t low_index, high_index);\n \t    break;\n \t  case OP_OTHERS:\n \t    if (i != n-1)\n \t      error (_(\"Misplaced 'others' clause\"));\n-\t    aggregate_assign_others (container, lhs, exp, pos, indices, \n-\t\t\t\t     num_indices, low_index, high_index);\n+\t    aggregate_assign_others (container, lhs, exp, pos, indices,\n+\t\t\t\t     low_index, high_index);\n \t    break;\n \t  default:\n \t    error (_(\"Internal error: bad aggregate clause\"));\n@@ -9625,23 +9590,22 @@ assign_aggregate (struct value *container,\n \t      \n /* Assign into the component of LHS indexed by the OP_POSITIONAL\n    construct at *POS, updating *POS past the construct, given that\n-   the positions are relative to lower bound LOW, where HIGH is the \n-   upper bound.  Record the position in INDICES[0 .. MAX_INDICES-1]\n-   updating *NUM_INDICES as needed.  CONTAINER is as for\n+   the positions are relative to lower bound LOW, where HIGH is the\n+   upper bound.  Record the position in INDICES.  CONTAINER is as for\n    assign_aggregate.  */\n static void\n aggregate_assign_positional (struct value *container,\n \t\t\t     struct value *lhs, struct expression *exp,\n-\t\t\t     int *pos, LONGEST *indices, int *num_indices,\n-\t\t\t     int max_indices, LONGEST low, LONGEST high) \n+\t\t\t     int *pos, std::vector<LONGEST> &indices,\n+\t\t\t     LONGEST low, LONGEST high)\n {\n   LONGEST ind = longest_to_int (exp->elts[*pos + 1].longconst) + low;\n   \n   if (ind - 1 == high)\n     warning (_(\"Extra components in aggregate ignored.\"));\n   if (ind <= high)\n     {\n-      add_component_interval (ind, ind, indices, num_indices, max_indices);\n+      add_component_interval (ind, ind, indices);\n       *pos += 3;\n       assign_component (container, lhs, ind, exp, pos);\n     }\n@@ -9652,13 +9616,12 @@ aggregate_assign_positional (struct value *container,\n /* Assign into the components of LHS indexed by the OP_CHOICES\n    construct at *POS, updating *POS past the construct, given that\n    the allowable indices are LOW..HIGH.  Record the indices assigned\n-   to in INDICES[0 .. MAX_INDICES-1], updating *NUM_INDICES as\n-   needed.  CONTAINER is as for assign_aggregate.  */\n+   to in INDICES.  CONTAINER is as for assign_aggregate.  */\n static void\n aggregate_assign_from_choices (struct value *container,\n \t\t\t       struct value *lhs, struct expression *exp,\n-\t\t\t       int *pos, LONGEST *indices, int *num_indices,\n-\t\t\t       int max_indices, LONGEST low, LONGEST high) \n+\t\t\t       int *pos, std::vector<LONGEST> &indices,\n+\t\t\t       LONGEST low, LONGEST high)\n {\n   int j;\n   int n_choices = longest_to_int (exp->elts[*pos+1].longconst);\n@@ -9718,8 +9681,7 @@ aggregate_assign_from_choices (struct value *container,\n       if (lower <= upper && (lower < low || upper > high))\n \terror (_(\"Index in component association out of bounds.\"));\n \n-      add_component_interval (lower, upper, indices, num_indices,\n-\t\t\t      max_indices);\n+      add_component_interval (lower, upper, indices);\n       while (lower <= upper)\n \t{\n \t  int pos1;\n@@ -9734,17 +9696,18 @@ aggregate_assign_from_choices (struct value *container,\n /* Assign the value of the expression in the OP_OTHERS construct in\n    EXP at *POS into the components of LHS indexed from LOW .. HIGH that\n    have not been previously assigned.  The index intervals already assigned\n-   are in INDICES[0 .. NUM_INDICES-1].  Updates *POS to after the \n-   OP_OTHERS clause.  CONTAINER is as for assign_aggregate.  */\n+   are in INDICES.  Updates *POS to after the OP_OTHERS clause.\n+   CONTAINER is as for assign_aggregate.  */\n static void\n aggregate_assign_others (struct value *container,\n \t\t\t struct value *lhs, struct expression *exp,\n-\t\t\t int *pos, LONGEST *indices, int num_indices,\n+\t\t\t int *pos, std::vector<LONGEST> &indices,\n \t\t\t LONGEST low, LONGEST high) \n {\n   int i;\n   int expr_pc = *pos + 1;\n   \n+  int num_indices = indices.size ();\n   for (i = 0; i < num_indices - 2; i += 2)\n     {\n       LONGEST ind;\n@@ -9760,41 +9723,39 @@ aggregate_assign_others (struct value *container,\n   ada_evaluate_subexp (NULL, exp, pos, EVAL_SKIP);\n }\n \n-/* Add the interval [LOW .. HIGH] to the sorted set of intervals \n-   [ INDICES[0] .. INDICES[1] ],..., [ INDICES[*SIZE-2] .. INDICES[*SIZE-1] ],\n-   modifying *SIZE as needed.  It is an error if *SIZE exceeds\n-   MAX_SIZE.  The resulting intervals do not overlap.  */\n+/* Add the interval [LOW .. HIGH] to the sorted set of intervals\n+   [ INDICES[0] .. INDICES[1] ],...  The resulting intervals do not\n+   overlap.  */\n static void\n add_component_interval (LONGEST low, LONGEST high, \n-\t\t\tLONGEST* indices, int *size, int max_size)\n+\t\t\tstd::vector<LONGEST> &indices)\n {\n   int i, j;\n \n-  for (i = 0; i < *size; i += 2) {\n+  int size = indices.size ();\n+  for (i = 0; i < size; i += 2) {\n     if (high >= indices[i] && low <= indices[i + 1])\n       {\n \tint kh;\n \n-\tfor (kh = i + 2; kh < *size; kh += 2)\n+\tfor (kh = i + 2; kh < size; kh += 2)\n \t  if (high < indices[kh])\n \t    break;\n \tif (low < indices[i])\n \t  indices[i] = low;\n \tindices[i + 1] = indices[kh - 1];\n \tif (high > indices[i + 1])\n \t  indices[i + 1] = high;\n-\tmemcpy (indices + i + 2, indices + kh, *size - kh);\n-\t*size -= kh - i - 2;\n+\tmemcpy (indices.data () + i + 2, indices.data () + kh, size - kh);\n+\tindices.resize (kh - i - 2);\n \treturn;\n       }\n     else if (high < indices[i])\n       break;\n   }\n \t\n-  if (*size == max_size)\n-    error (_(\"Internal error: miscounted aggregate components.\"));\n-  *size += 2;\n-  for (j = *size-1; j >= i+2; j -= 1)\n+  indices.resize (indices.size () + 2);\n+  for (j = size - 1; j >= i + 2; j -= 1)\n     indices[j] = indices[j - 2];\n   indices[i] = low;\n   indices[i + 1] = high;"
    }
  ]
}