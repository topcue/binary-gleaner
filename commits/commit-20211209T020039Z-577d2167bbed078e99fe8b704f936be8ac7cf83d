{
  "sha": "577d2167bbed078e99fe8b704f936be8ac7cf83d",
  "node_id": "C_kwDOANOeidoAKDU3N2QyMTY3YmJlZDA3OGU5OWZlOGI3MDRmOTM2YmU4YWM3Y2Y4M2Q",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-01T14:40:03Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-09T02:00:39Z"
    },
    "message": "gdb: move clearing of tp->pending_follow to follow_fork_inferior\n\nA following patch will change targets so that when they detach an\ninferior, they also detach any pending fork children this inferior may\nhave.  While doing this, I hit a case where we couldn't differentiate\ntwo cases, where in one we should detach the fork detach but not in the\nother.\n\nSuppose we continue past a fork with \"follow-fork-mode == child\" &&\n\"detach-on-fork on\".  follow_fork_inferior calls target_detach to detach\nthe parent.  In that case the target should not detach the fork\nchild, as we'll continue debugging the child.  As of now, the\ntp->pending_follow field of the thread who called fork still contains\nthe details about the fork.\n\nThen, suppose we run to a fork catchpoint and the user types \"detach\".\nIn that case, the target should detach the fork child in addition to the\nparent.  In that case as well, the tp->pending_follow field contains\nthe details about the fork.\n\nTo allow targets to differentiate the two cases, clear\ntp->pending_follow a bit earlier, when following a fork.  Targets will\nthen see that tp->pending_follow contains TARGET_WAITKIND_SPURIOUS, and\nwon't detach the fork child.\n\nAs of this patch, no behavior changes are expected.\n\nChange-Id: I537741859ed712cb531baaefc78bb934e2a28153",
    "tree": {
      "sha": "7718ef8811dfd386cc891ab2180dfecd7271386c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7718ef8811dfd386cc891ab2180dfecd7271386c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/577d2167bbed078e99fe8b704f936be8ac7cf83d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/577d2167bbed078e99fe8b704f936be8ac7cf83d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/577d2167bbed078e99fe8b704f936be8ac7cf83d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/577d2167bbed078e99fe8b704f936be8ac7cf83d/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "28561a655942f8e2a70a3b64e867223a60aae7b1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/28561a655942f8e2a70a3b64e867223a60aae7b1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/28561a655942f8e2a70a3b64e867223a60aae7b1"
    }
  ],
  "stats": {
    "total": 28,
    "additions": 18,
    "deletions": 10
  },
  "files": [
    {
      "sha": "a1264f77f9bf2db3842107a753e94f75d658db58",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 18,
      "deletions": 10,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/577d2167bbed078e99fe8b704f936be8ac7cf83d/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/577d2167bbed078e99fe8b704f936be8ac7cf83d/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=577d2167bbed078e99fe8b704f936be8ac7cf83d",
      "patch": "@@ -601,6 +601,23 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n   if (child_inf != nullptr)\n     gdb_assert (!child_inf->thread_list.empty ());\n \n+  /* Clear the parent thread's pending follow field.  Do this before calling\n+     target_detach, so that the target can differentiate the two following\n+     cases:\n+\n+      - We continue past a fork with \"follow-fork-mode == child\" &&\n+\t\"detach-on-fork on\", and therefore detach the parent.  In that\n+\tcase the target should not detach the fork child.\n+      - We run to a fork catchpoint and the user types \"detach\".  In that\n+\tcase, the target should detach the fork child in addition to the\n+\tparent.\n+\n+     The former case will have pending_follow cleared, the later will have\n+     pending_follow set.  */\n+  thread_info *parent_thread = find_thread_ptid (parent_inf, parent_ptid);\n+  gdb_assert (parent_thread != nullptr);\n+  parent_thread->pending_follow.set_spurious ();\n+\n   /* Detach the parent if needed.  */\n   if (follow_child)\n     {\n@@ -668,7 +685,6 @@ follow_fork ()\n {\n   bool follow_child = (follow_fork_mode_string == follow_fork_mode_child);\n   bool should_resume = true;\n-  struct thread_info *tp;\n \n   /* Copy user stepping state to the new inferior thread.  FIXME: the\n      followed fork child thread should have a copy of most of the\n@@ -714,7 +730,7 @@ follow_fork ()\n \t}\n     }\n \n-  tp = inferior_thread ();\n+  thread_info *tp = inferior_thread ();\n \n   /* If there were any forks/vforks that were caught and are now to be\n      followed, then do so now.  */\n@@ -768,14 +784,6 @@ follow_fork ()\n \t  }\n \telse\n \t  {\n-\t    /* This pending follow fork event is now handled, one way\n-\t       or another.  The previous selected thread may be gone\n-\t       from the lists by now, but if it is still around, need\n-\t       to clear the pending follow request.  */\n-\t    tp = find_thread_ptid (parent_targ, parent);\n-\t    if (tp)\n-\t      tp->pending_follow.set_spurious ();\n-\n \t    /* This makes sure we don't try to apply the \"Switched\n \t       over from WAIT_PID\" logic above.  */\n \t    nullify_last_target_wait_ptid ();"
    }
  ]
}