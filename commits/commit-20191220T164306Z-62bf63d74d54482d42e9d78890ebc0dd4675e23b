{
  "sha": "62bf63d74d54482d42e9d78890ebc0dd4675e23b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjJiZjYzZDc0ZDU0NDgyZDQyZTlkNzg4OTBlYmMwZGQ0Njc1ZTIzYg==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2019-12-20T16:43:06Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2019-12-20T16:43:06Z"
    },
    "message": "infcall, c++: collect more pass-by-reference information\n\nWalk through a given type to collect information about whether the\ntype is copy constructible, destructible, trivially copyable,\ntrivially copy constructible, trivially destructible.  The previous\nalgorithm returned only a boolean result about whether the type is\ntrivially copyable.  This patch computes more info.  Additionally, it\nutilizes DWARF attributes that were previously not taken into account;\nnamely, DW_AT_deleted, DW_AT_defaulted, and DW_AT_calling_convention.\n\ngdb/ChangeLog:\n2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* gnu-v3-abi.c (enum definition_style): New enum type.\n\t(get_def_style): New function.\n\t(is_user_provided_def): New function.\n\t(is_implicit_def): New function.\n\t(is_copy_or_move_constructor_type): New function.\n\t(is_copy_constructor_type): New function.\n\t(is_move_constructor_type): New function.\n\t(gnuv3_pass_by_reference): Collect language_pass_by_ref_info\n\tfor a given type.\n\nChange-Id: Ic05bd98a962d07ec3c1ad041f709687eabda3bb9",
    "tree": {
      "sha": "a55c8cb475dfa18494d139f454e5be69af72392a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a55c8cb475dfa18494d139f454e5be69af72392a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/62bf63d74d54482d42e9d78890ebc0dd4675e23b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62bf63d74d54482d42e9d78890ebc0dd4675e23b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/62bf63d74d54482d42e9d78890ebc0dd4675e23b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/62bf63d74d54482d42e9d78890ebc0dd4675e23b/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9d084466d740e40c655609f9c04b3bb2b9b9ca76",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9d084466d740e40c655609f9c04b3bb2b9b9ca76",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9d084466d740e40c655609f9c04b3bb2b9b9ca76"
    }
  ],
  "stats": {
    "total": 299,
    "additions": 248,
    "deletions": 51
  },
  "files": [
    {
      "sha": "43b86f2c023554c0c79112ae19c1e64c6e56daa5",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62bf63d74d54482d42e9d78890ebc0dd4675e23b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62bf63d74d54482d42e9d78890ebc0dd4675e23b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=62bf63d74d54482d42e9d78890ebc0dd4675e23b",
      "patch": "@@ -1,3 +1,15 @@\n+2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* gnu-v3-abi.c (enum definition_style): New enum type.\n+\t(get_def_style): New function.\n+\t(is_user_provided_def): New function.\n+\t(is_implicit_def): New function.\n+\t(is_copy_or_move_constructor_type): New function.\n+\t(is_copy_constructor_type): New function.\n+\t(is_move_constructor_type): New function.\n+\t(gnuv3_pass_by_reference): Collect language_pass_by_ref_info\n+\tfor a given type.\n+\n 2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* language.h (struct language_pass_by_ref_info): New struct."
    },
    {
      "sha": "33be218b93a048ec581eb52f8828be22f0629977",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 236,
      "deletions": 51,
      "changes": 287,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/62bf63d74d54482d42e9d78890ebc0dd4675e23b/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/62bf63d74d54482d42e9d78890ebc0dd4675e23b/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=62bf63d74d54482d42e9d78890ebc0dd4675e23b",
      "patch": "@@ -23,6 +23,7 @@\n #include \"cp-abi.h\"\n #include \"cp-support.h\"\n #include \"demangle.h\"\n+#include \"dwarf2.h\"\n #include \"objfiles.h\"\n #include \"valprint.h\"\n #include \"c-lang.h\"\n@@ -1230,6 +1231,127 @@ gnuv3_skip_trampoline (struct frame_info *frame, CORE_ADDR stop_pc)\n   return real_stop_pc;\n }\n \n+/* A member function is in one these states.  */\n+\n+enum definition_style\n+{\n+  DOES_NOT_EXIST_IN_SOURCE,\n+  DEFAULTED_INSIDE,\n+  DEFAULTED_OUTSIDE,\n+  DELETED,\n+  EXPLICIT,\n+};\n+\n+/* Return how the given field is defined.  */\n+\n+static definition_style\n+get_def_style (struct fn_field *fn, int fieldelem)\n+{\n+  if (TYPE_FN_FIELD_DELETED (fn, fieldelem))\n+    return DELETED;\n+\n+  if (TYPE_FN_FIELD_ARTIFICIAL (fn, fieldelem))\n+    return DOES_NOT_EXIST_IN_SOURCE;\n+\n+  switch (TYPE_FN_FIELD_DEFAULTED (fn, fieldelem))\n+    {\n+    case DW_DEFAULTED_no:\n+      return EXPLICIT;\n+    case DW_DEFAULTED_in_class:\n+      return DEFAULTED_INSIDE;\n+    case DW_DEFAULTED_out_of_class:\n+      return DEFAULTED_OUTSIDE;\n+    default:\n+      break;\n+    }\n+\n+  return EXPLICIT;\n+}\n+\n+/* Helper functions to determine whether the given definition style\n+   denotes that the definition is user-provided or implicit.\n+   Being defaulted outside the class decl counts as an explicit\n+   user-definition, while being defaulted inside is implicit.  */\n+\n+static bool\n+is_user_provided_def (definition_style def)\n+{\n+  return def == EXPLICIT || def == DEFAULTED_OUTSIDE;\n+}\n+\n+static bool\n+is_implicit_def (definition_style def)\n+{\n+  return def == DOES_NOT_EXIST_IN_SOURCE || def == DEFAULTED_INSIDE;\n+}\n+\n+/* Helper function to decide if METHOD_TYPE is a copy/move\n+   constructor type for CLASS_TYPE.  EXPECTED is the expected\n+   type code for the \"right-hand-side\" argument.\n+   This function is supposed to be used by the IS_COPY_CONSTRUCTOR_TYPE\n+   and IS_MOVE_CONSTRUCTOR_TYPE functions below.  Normally, you should\n+   not need to call this directly.  */\n+\n+static bool\n+is_copy_or_move_constructor_type (struct type *class_type,\n+\t\t\t\t  struct type *method_type,\n+\t\t\t\t  type_code expected)\n+{\n+  /* The method should take at least two arguments...  */\n+  if (TYPE_NFIELDS (method_type) < 2)\n+    return false;\n+\n+  /* ...and the second argument should be the same as the class\n+     type, with the expected type code...  */\n+  struct type *arg_type = TYPE_FIELD_TYPE (method_type, 1);\n+\n+  if (TYPE_CODE (arg_type) != expected)\n+    return false;\n+\n+  struct type *target = check_typedef (TYPE_TARGET_TYPE (arg_type));\n+  if (!(class_types_same_p (target, class_type)))\n+    return false;\n+\n+  /* ...and if any of the remaining arguments don't have a default value\n+     then this is not a copy or move constructor, but just a\n+     constructor.  */\n+  for (int i = 2; i < TYPE_NFIELDS (method_type); i++)\n+    {\n+      arg_type = TYPE_FIELD_TYPE (method_type, i);\n+      /* FIXME aktemur/2019-10-31: As of this date, neither\n+\t clang++-7.0.0 nor g++-8.2.0 produce a DW_AT_default_value\n+\t attribute.  GDB is also not set to read this attribute, yet.\n+\t Hence, we immediately return false if there are more than\n+\t 2 parameters.\n+\t GCC bug link:\n+\t https://gcc.gnu.org/bugzilla/show_bug.cgi?id=42959\n+      */\n+      return false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Return true if METHOD_TYPE is a copy ctor type for CLASS_TYPE.  */\n+\n+static bool\n+is_copy_constructor_type (struct type *class_type,\n+\t\t\t  struct type *method_type)\n+{\n+  return is_copy_or_move_constructor_type (class_type, method_type,\n+\t\t\t\t\t   TYPE_CODE_REF);\n+}\n+\n+/* Return true if METHOD_TYPE is a move ctor type for CLASS_TYPE.  */\n+\n+static bool\n+is_move_constructor_type (struct type *class_type,\n+\t\t\t  struct type *method_type)\n+{\n+  return is_copy_or_move_constructor_type (class_type, method_type,\n+\t\t\t\t\t   TYPE_CODE_RVALUE_REF);\n+}\n+\n /* Return pass-by-reference information for the given TYPE.\n \n    The rule in the v3 ABI document comes from section 3.1.1.  If the\n@@ -1238,16 +1360,15 @@ gnuv3_skip_trampoline (struct frame_info *frame, CORE_ADDR stop_pc)\n    is one or perform the copy itself otherwise), pass the address of\n    the copy, and then destroy the temporary (if necessary).\n \n-   For return values with non-trivial copy constructors or\n+   For return values with non-trivial copy/move constructors or\n    destructors, space will be allocated in the caller, and a pointer\n    will be passed as the first argument (preceding \"this\").\n \n    We don't have a bulletproof mechanism for determining whether a\n-   constructor or destructor is trivial.  For GCC and DWARF2 debug\n-   information, we can check the artificial flag.\n-\n-   We don't do anything with the constructors or destructors,\n-   but we have to get the argument passing right anyway.  */\n+   constructor or destructor is trivial.  For GCC and DWARF5 debug\n+   information, we can check the calling_convention attribute,\n+   the 'artificial' flag, the 'defaulted' attribute, and the\n+   'deleted' attribute.  */\n \n static struct language_pass_by_ref_info\n gnuv3_pass_by_reference (struct type *type)\n@@ -1260,21 +1381,39 @@ gnuv3_pass_by_reference (struct type *type)\n   struct language_pass_by_ref_info info\n     = default_pass_by_reference (type);\n \n-  /* FIXME: Currently, this implementation only fills in the\n-     'trivially-copyable' field to preserve GDB's existing behavior.  */\n+  bool has_cc_attr = false;\n+  bool is_pass_by_value = false;\n+  bool is_dynamic = false;\n+  definition_style cctor_def = DOES_NOT_EXIST_IN_SOURCE;\n+  definition_style dtor_def = DOES_NOT_EXIST_IN_SOURCE;\n+  definition_style mctor_def = DOES_NOT_EXIST_IN_SOURCE;\n \n   /* We're only interested in things that can have methods.  */\n   if (TYPE_CODE (type) != TYPE_CODE_STRUCT\n       && TYPE_CODE (type) != TYPE_CODE_UNION)\n     return info;\n \n+  /* The compiler may have emitted the calling convention attribute.\n+     Note: GCC does not produce this attribute as of version 9.2.1.\n+     Bug link: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=92418  */\n+  if (TYPE_CPLUS_CALLING_CONVENTION (type) == DW_CC_pass_by_value)\n+    {\n+      has_cc_attr = true;\n+      is_pass_by_value = true;\n+      /* Do not return immediately.  We have to find out if this type\n+\t is copy_constructible and destructible.  */\n+    }\n+\n+  if (TYPE_CPLUS_CALLING_CONVENTION (type) == DW_CC_pass_by_reference)\n+    {\n+      has_cc_attr = true;\n+      is_pass_by_value = false;\n+    }\n+\n   /* A dynamic class has a non-trivial copy constructor.\n      See c++98 section 12.8 Copying class objects [class.copy].  */\n   if (gnuv3_dynamic_class (type))\n-    {\n-      info.trivially_copyable = false;\n-      return info;\n-    }\n+    is_dynamic = true;\n \n   for (fieldnum = 0; fieldnum < TYPE_NFN_FIELDS (type); fieldnum++)\n     for (fieldelem = 0; fieldelem < TYPE_FN_FIELDLIST_LENGTH (type, fieldnum);\n@@ -1284,49 +1423,75 @@ gnuv3_pass_by_reference (struct type *type)\n \tconst char *name = TYPE_FN_FIELDLIST_NAME (type, fieldnum);\n \tstruct type *fieldtype = TYPE_FN_FIELD_TYPE (fn, fieldelem);\n \n-\t/* If this function is marked as artificial, it is compiler-generated,\n-\t   and we assume it is trivial.  */\n-\tif (TYPE_FN_FIELD_ARTIFICIAL (fn, fieldelem))\n-\t  continue;\n-\n-\t/* If we've found a destructor, we must pass this by reference.  */\n \tif (name[0] == '~')\n \t  {\n-\t    info.trivially_copyable = false;\n-\t    return info;\n+\t    /* We've found a destructor.\n+\t       There should be at most one dtor definition.  */\n+\t    gdb_assert (dtor_def == DOES_NOT_EXIST_IN_SOURCE);\n+\t    dtor_def = get_def_style (fn, fieldelem);\n \t  }\n-\n-\t/* If the mangled name of this method doesn't indicate that it\n-\t   is a constructor, we're not interested.\n-\n-\t   FIXME drow/2007-09-23: We could do this using the name of\n-\t   the method and the name of the class instead of dealing\n-\t   with the mangled name.  We don't have a convenient function\n-\t   to strip off both leading scope qualifiers and trailing\n-\t   template arguments yet.  */\n-\tif (!is_constructor_name (TYPE_FN_FIELD_PHYSNAME (fn, fieldelem))\n-\t    && !TYPE_FN_FIELD_CONSTRUCTOR (fn, fieldelem))\n-\t  continue;\n-\n-\t/* If this method takes two arguments, and the second argument is\n-\t   a reference to this class, then it is a copy constructor.  */\n-\tif (TYPE_NFIELDS (fieldtype) == 2)\n+\telse if (is_constructor_name (TYPE_FN_FIELD_PHYSNAME (fn, fieldelem))\n+\t\t || TYPE_FN_FIELD_CONSTRUCTOR (fn, fieldelem))\n \t  {\n-\t    struct type *arg_type = TYPE_FIELD_TYPE (fieldtype, 1);\n-\n-\t    if (TYPE_CODE (arg_type) == TYPE_CODE_REF)\n+\t    /* FIXME drow/2007-09-23: We could do this using the name of\n+\t       the method and the name of the class instead of dealing\n+\t       with the mangled name.  We don't have a convenient function\n+\t       to strip off both leading scope qualifiers and trailing\n+\t       template arguments yet.  */\n+\t    if (is_copy_constructor_type (type, fieldtype))\n+\t      {\n+\t\t/* There may be more than one cctors.  E.g.: one that\n+\t\t   take a const parameter and another that takes a\n+\t\t   non-const parameter.  Such as:\n+\n+\t\t   class K {\n+\t\t     K (const K &k)...\n+\t\t     K (K &k)...\n+\t\t   };\n+\n+\t\t   It is sufficient for the type to be non-trivial\n+\t\t   even only one of the cctors is explicit.\n+\t\t   Therefore, update the cctor_def value in the\n+\t\t   implicit -> explicit direction, not backwards.  */\n+\n+\t\tif (is_implicit_def (cctor_def))\n+\t\t  cctor_def = get_def_style (fn, fieldelem);\n+\t      }\n+\t    else if (is_move_constructor_type (type, fieldtype))\n \t      {\n-\t\tstruct type *arg_target_type\n-\t\t  = check_typedef (TYPE_TARGET_TYPE (arg_type));\n-\t\tif (class_types_same_p (arg_target_type, type))\n-\t\t  {\n-\t\t    info.trivially_copyable = false;\n-\t\t    return info;\n-\t\t  }\n+\t\t/* Again, there may be multiple move ctors.  Update the\n+\t\t   mctor_def value if we found an explicit def and the\n+\t\t   existing one is not explicit.  Otherwise retain the\n+\t\t   existing value.  */\n+\t\tif (is_implicit_def (mctor_def))\n+\t\t  mctor_def = get_def_style (fn, fieldelem);\n \t      }\n \t  }\n       }\n \n+  bool cctor_implicitly_deleted\n+    = (mctor_def != DOES_NOT_EXIST_IN_SOURCE\n+       && cctor_def == DOES_NOT_EXIST_IN_SOURCE);\n+\n+  bool cctor_explicitly_deleted = (cctor_def == DELETED);\n+\n+  if (cctor_implicitly_deleted || cctor_explicitly_deleted)\n+    info.copy_constructible = false;\n+\n+  if (dtor_def == DELETED)\n+    info.destructible = false;\n+\n+  info.trivially_destructible = is_implicit_def (dtor_def);\n+\n+  info.trivially_copy_constructible\n+    = (is_implicit_def (cctor_def)\n+       && !is_dynamic);\n+\n+  info.trivially_copyable\n+    = (info.trivially_copy_constructible\n+       && info.trivially_destructible\n+       && !is_user_provided_def (mctor_def));\n+\n   /* Even if all the constructors and destructors were artificial, one\n      of them may have invoked a non-artificial constructor or\n      destructor in a base class.  If any base class needs to be passed\n@@ -1337,15 +1502,35 @@ gnuv3_pass_by_reference (struct type *type)\n   for (fieldnum = 0; fieldnum < TYPE_NFIELDS (type); fieldnum++)\n     if (!field_is_static (&TYPE_FIELD (type, fieldnum)))\n       {\n+\tstruct type *field_type = TYPE_FIELD_TYPE (type, fieldnum);\n+\n+\t/* For arrays, make the decision based on the element type.  */\n+\tif (TYPE_CODE (field_type) == TYPE_CODE_ARRAY)\n+\t  field_type = check_typedef (TYPE_TARGET_TYPE (field_type));\n+\n \tstruct language_pass_by_ref_info field_info\n-\t  = gnuv3_pass_by_reference (TYPE_FIELD_TYPE (type, fieldnum));\n+\t  = gnuv3_pass_by_reference (field_type);\n+\n+\tif (!field_info.copy_constructible)\n+\t  info.copy_constructible = false;\n+\tif (!field_info.destructible)\n+\t  info.destructible = false;\n \tif (!field_info.trivially_copyable)\n-\t  {\n-\t    info.trivially_copyable = false;\n-\t    return info;\n-\t  }\n+\t  info.trivially_copyable = false;\n+\tif (!field_info.trivially_copy_constructible)\n+\t  info.trivially_copy_constructible = false;\n+\tif (!field_info.trivially_destructible)\n+\t  info.trivially_destructible = false;\n       }\n \n+  /* Consistency check.  */\n+  if (has_cc_attr && info.trivially_copyable != is_pass_by_value)\n+    {\n+      /* DWARF CC attribute is not the same as the inferred value;\n+\t use the DWARF attribute.  */\n+      info.trivially_copyable = is_pass_by_value;\n+    }\n+\n   return info;\n }\n "
    }
  ]
}