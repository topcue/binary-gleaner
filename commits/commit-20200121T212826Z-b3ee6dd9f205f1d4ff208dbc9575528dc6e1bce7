{
  "sha": "b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjNlZTZkZDlmMjA1ZjFkNGZmMjA4ZGJjOTU3NTUyOGRjNmUxYmNlNw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-01-21T21:28:25Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-01-21T21:28:26Z"
    },
    "message": "gdb: remove uses of iterate_over_inferiors in remote-sim.c\n\nThis removes the two uses of iterate_over_inferiors, in favor of\nrange-based loops.\n\ngdb/ChangeLog:\n\n\t* remote-sim.c (check_for_duplicate_sim_descriptor): Remove.\n\t(get_sim_inferior_data): Remove use of iterate_over_inferiors,\n\treplace with range-based for.\n\t(gdbsim_interrupt_inferior): Remove.\n\t(gdbsim_target::interrupt): Replace iterate_over_inferiors use\n\twith a range-based for.  Inline code from\n\tgdbsim_interrupt_inferior.",
    "tree": {
      "sha": "b9b133948139c3c74d989ee18ffe40eee4d045fd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b9b133948139c3c74d989ee18ffe40eee4d045fd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f9fac3c81b322a3c0d2e50d19769c06fdada7a94",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f9fac3c81b322a3c0d2e50d19769c06fdada7a94",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f9fac3c81b322a3c0d2e50d19769c06fdada7a94"
    }
  ],
  "stats": {
    "total": 88,
    "additions": 38,
    "deletions": 50
  },
  "files": [
    {
      "sha": "3ed9150c4927534c60ce746c08111546ac193e9a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7",
      "patch": "@@ -1,3 +1,13 @@\n+2020-01-21  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* remote-sim.c (check_for_duplicate_sim_descriptor): Remove.\n+\t(get_sim_inferior_data): Remove use of iterate_over_inferiors,\n+\treplace with range-based for.\n+\t(gdbsim_interrupt_inferior): Remove.\n+\t(gdbsim_target::interrupt): Replace iterate_over_inferiors use\n+\twith a range-based for.  Inline code from\n+\tgdbsim_interrupt_inferior.\n+\n 2020-01-21  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* infrun.c (proceed): Fix indentation."
    },
    {
      "sha": "281232cc4e5bfa104d3a41cd0a72aea5de976ba9",
      "filename": "gdb/remote-sim.c",
      "status": "modified",
      "additions": 28,
      "deletions": 50,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7/gdb/remote-sim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7/gdb/remote-sim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-sim.c?ref=b3ee6dd9f205f1d4ff208dbc9575528dc6e1bce7",
      "patch": "@@ -189,21 +189,6 @@ static char **sim_argv = NULL;\n static host_callback gdb_callback;\n static int callbacks_initialized = 0;\n \n-/* Callback for iterate_over_inferiors.  It checks to see if the sim\n-   descriptor passed via ARG is the same as that for the inferior\n-   designated by INF.  Return true if so; false otherwise.  */\n-\n-static int\n-check_for_duplicate_sim_descriptor (struct inferior *inf, void *arg)\n-{\n-  struct sim_inferior_data *sim_data;\n-  SIM_DESC new_sim_desc = (SIM_DESC) arg;\n-\n-  sim_data = sim_inferior_data_key.get (inf);\n-\n-  return (sim_data != NULL && sim_data->gdbsim_desc == new_sim_desc);\n-}\n-\n /* Flags indicating whether or not a sim instance is needed.  One of these\n    flags should be passed to get_sim_inferior_data().  */\n \n@@ -225,27 +210,33 @@ get_sim_inferior_data (struct inferior *inf, int sim_instance_needed)\n   if (sim_instance_needed == SIM_INSTANCE_NEEDED\n       && (sim_data == NULL || sim_data->gdbsim_desc == NULL))\n     {\n-      struct inferior *idup;\n       sim_desc = sim_open (SIM_OPEN_DEBUG, &gdb_callback, exec_bfd, sim_argv);\n       if (sim_desc == NULL)\n \terror (_(\"Unable to create simulator instance for inferior %d.\"),\n \t       inf->num);\n \n-      idup = iterate_over_inferiors (check_for_duplicate_sim_descriptor,\n-\t\t\t\t     sim_desc);\n-      if (idup != NULL)\n+      /* Check if the sim descriptor is the same as that of another\n+\t inferior.  */\n+      for (inferior *other_inf : all_inferiors ())\n \t{\n-\t  /* We don't close the descriptor due to the fact that it's\n-\t     shared with some other inferior.  If we were to close it,\n-\t     that might needlessly muck up the other inferior.  Of\n-\t     course, it's possible that the damage has already been\n-\t     done...  Note that it *will* ultimately be closed during\n-\t     cleanup of the other inferior.  */\n-\t  sim_desc = NULL;\n-\t  error (\n- _(\"Inferior %d and inferior %d would have identical simulator state.\\n\"\n-   \"(This simulator does not support the running of more than one inferior.)\"),\n-\t\t inf->num, idup->num);\n+\t  sim_inferior_data *other_sim_data\n+\t    = sim_inferior_data_key.get (other_inf);\n+\n+\t  if (other_sim_data != NULL\n+\t      && other_sim_data->gdbsim_desc == sim_desc)\n+\t    {\n+\t      /* We don't close the descriptor due to the fact that it's\n+\t\t shared with some other inferior.  If we were to close it,\n+\t\t that might needlessly muck up the other inferior.  Of\n+\t\t course, it's possible that the damage has already been\n+\t\t done...  Note that it *will* ultimately be closed during\n+\t\t cleanup of the other inferior.  */\n+\t      sim_desc = NULL;\n+\t      error (\n+_(\"Inferior %d and inferior %d would have identical simulator state.\\n\"\n+ \"(This simulator does not support the running of more than one inferior.)\"),\n+\t\t     inf->num, other_inf->num);\n+\t    }\n \t}\n     }\n \n@@ -896,30 +887,17 @@ gdbsim_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n \n    For simulators that do not support this operation, just abort.  */\n \n-static int\n-gdbsim_interrupt_inferior (struct inferior *inf, void *arg)\n+void\n+gdbsim_target::interrupt ()\n {\n-  struct sim_inferior_data *sim_data\n-    = get_sim_inferior_data (inf, SIM_INSTANCE_NEEDED);\n-\n-  if (sim_data)\n+  for (inferior *inf : all_inferiors ())\n     {\n-      if (!sim_stop (sim_data->gdbsim_desc))\n-\t{\n+      sim_inferior_data *sim_data\n+\t= get_sim_inferior_data (inf, SIM_INSTANCE_NEEDED);\n+\n+      if (sim_data != nullptr && !sim_stop (sim_data->gdbsim_desc))\n \t  quit ();\n-\t}\n     }\n-\n-  /* When called from iterate_over_inferiors, a zero return causes the\n-     iteration process to proceed until there are no more inferiors to\n-     consider.  */\n-  return 0;\n-}\n-\n-void\n-gdbsim_target::interrupt ()\n-{\n-  iterate_over_inferiors (gdbsim_interrupt_inferior, NULL);\n }\n \n /* GDB version of os_poll_quit callback."
    }
  ]
}