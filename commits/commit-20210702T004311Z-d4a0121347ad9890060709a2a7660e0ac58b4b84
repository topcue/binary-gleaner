{
  "sha": "d4a0121347ad9890060709a2a7660e0ac58b4b84",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDRhMDEyMTM0N2FkOTg5MDA2MDcwOWEyYTc2NjBlMGFjNThiNGI4NA==",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-07-01T04:17:38Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-07-02T00:43:11Z"
    },
    "message": "sim: m32r: replace custom endian helpers with sim-endian\n\nThis improves the logic a bit by making the host<->target translations\na bit more clear.  The structs still bleed way too much between the two\nworlds, but let's fix one thing at a time.",
    "tree": {
      "sha": "73238b501bfbfbf1b09c179b92889e7f172877e1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/73238b501bfbfbf1b09c179b92889e7f172877e1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d4a0121347ad9890060709a2a7660e0ac58b4b84",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d4a0121347ad9890060709a2a7660e0ac58b4b84",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d4a0121347ad9890060709a2a7660e0ac58b4b84",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d4a0121347ad9890060709a2a7660e0ac58b4b84/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "055a3f27e8c704a459a84ef6deeadd06a4a55d23",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/055a3f27e8c704a459a84ef6deeadd06a4a55d23",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/055a3f27e8c704a459a84ef6deeadd06a4a55d23"
    }
  ],
  "stats": {
    "total": 197,
    "additions": 90,
    "deletions": 107
  },
  "files": [
    {
      "sha": "1a5f772274bcfb8475401165a9c09ac31dd795ab",
      "filename": "sim/m32r/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d4a0121347ad9890060709a2a7660e0ac58b4b84/sim/m32r/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d4a0121347ad9890060709a2a7660e0ac58b4b84/sim/m32r/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/ChangeLog?ref=d4a0121347ad9890060709a2a7660e0ac58b4b84",
      "patch": "@@ -1,3 +1,13 @@\n+2021-07-01  Mike Frysinger  <vapier@gentoo.org>\n+\n+\t* traps-linux.c (conv_endian, conv_endian16,\n+\ttranslate_endian): Delete.\n+\t(translate_endian_h2t): New host-to-target function.\n+\t(translate_endian_t2h): New target-to-host function.\n+\t(m32r_trap): Replace conv_endian with H2T_4 & T2H_4, conv_endian16\n+\twith H2T_2 & T2H_2, and translate_endian with translate_endian_h2t\n+\t& translate_endian_t2h.\n+\n 2021-07-01  Mike Frysinger  <vapier@gentoo.org>\n \n \t* traps-linux.c (m32r_trap): Change OPERATING_ENVIRONMENT check to"
    },
    {
      "sha": "4d86a0a4e3618ecd9aea0044d3c4a5d400479590",
      "filename": "sim/m32r/traps-linux.c",
      "status": "modified",
      "additions": 80,
      "deletions": 107,
      "changes": 187,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d4a0121347ad9890060709a2a7660e0ac58b4b84/sim/m32r/traps-linux.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d4a0121347ad9890060709a2a7660e0ac58b4b84/sim/m32r/traps-linux.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/m32r/traps-linux.c?ref=d4a0121347ad9890060709a2a7660e0ac58b4b84",
      "patch": "@@ -137,61 +137,34 @@ t2h_addr (host_callback *cb, struct cb_syscall *sc,\n   return sim_core_trans_addr (sd, cpu, read_map, taddr);\n }\n \n-static unsigned int\n-conv_endian (unsigned int tvalue)\n-{\n-  unsigned int hvalue;\n-  unsigned int t1, t2, t3, t4;\n-\n-  if (HOST_BYTE_ORDER == BFD_ENDIAN_LITTLE)\n-    {\n-      t1 = tvalue & 0xff000000;\n-      t2 = tvalue & 0x00ff0000;\n-      t3 = tvalue & 0x0000ff00;\n-      t4 = tvalue & 0x000000ff;\n-\n-      hvalue =  t1 >> 24;\n-      hvalue += t2 >> 8;\n-      hvalue += t3 << 8;\n-      hvalue += t4 << 24;\n-    }\n-  else\n-    hvalue = tvalue;\n+/* TODO: These functions are a big hack and assume that the host runtime has\n+   type sizes and struct layouts that match the target.  So the Linux emulation\n+   probaly only really works in 32-bit runtimes.  */\n \n-  return hvalue;\n-}\n-\n-static unsigned short\n-conv_endian16 (unsigned short tvalue)\n+static void\n+translate_endian_h2t (void *addr, size_t size)\n {\n-  unsigned short hvalue;\n-  unsigned short t1, t2;\n-\n-  if (HOST_BYTE_ORDER == BFD_ENDIAN_LITTLE)\n-    {\n-      t1 = tvalue & 0xff00;\n-      t2 = tvalue & 0x00ff;\n+  unsigned int *p = (unsigned int *) addr;\n+  int i;\n \n-      hvalue =  t1 >> 8;\n-      hvalue += t2 << 8;\n-    }\n-  else\n-    hvalue = tvalue;\n+  for (i = 0; i <= size - 4; i += 4,p++)\n+    *p = H2T_4 (*p);\n \n-  return hvalue;\n+  if (i <= size - 2)\n+    *((unsigned short *) p) = H2T_2 (*((unsigned short *) p));\n }\n \n static void\n-translate_endian(void *addr, size_t size)\n+translate_endian_t2h (void *addr, size_t size)\n {\n   unsigned int *p = (unsigned int *) addr;\n   int i;\n-  \n+\n   for (i = 0; i <= size - 4; i += 4,p++)\n-    *p = conv_endian(*p);\n-  \n+    *p = T2H_4 (*p);\n+\n   if (i <= size - 2)\n-    *((unsigned short *) p) = conv_endian16(*((unsigned short *) p));\n+    *((unsigned short *) p) = T2H_2 (*((unsigned short *) p));\n }\n \n /* Trap support.\n@@ -326,7 +299,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n                   if (result != 0)\n                     break;\n \n-                  translate_endian((void *) &t, sizeof(t));\n+                  t = H2T_4 (t);\n                   if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t)) != sizeof(t))\n                     {\n                       result = -1;\n@@ -382,7 +355,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               else\n                 {\n                   buf = *((struct utimbuf *) t2h_addr(cb, &s, arg2));\n-                  translate_endian((void *) &buf, sizeof(buf));\n+                  translate_endian_t2h (&buf, sizeof(buf));\n                   result = utime((char *) t2h_addr(cb, &s, arg1), &buf);\n                   errcode = errno;\n                 }\n@@ -404,10 +377,10 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              t.time = conv_endian(t.time);\n-              t.millitm = conv_endian16(t.millitm);\n-              t.timezone = conv_endian16(t.timezone);\n-              t.dstflag = conv_endian16(t.dstflag);\n+              t.time = H2T_4 (t.time);\n+              t.millitm = H2T_2 (t.millitm);\n+              t.timezone = H2T_2 (t.timezone);\n+              t.dstflag = H2T_2 (t.dstflag);\n               if ((s.write_mem) (cb, &s, arg1, (char *) &t, sizeof(t))\n                   != sizeof(t))\n                 {\n@@ -501,7 +474,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &rlim, sizeof(rlim));\n+              translate_endian_h2t (&rlim, sizeof(rlim));\n               if ((s.write_mem) (cb, &s, arg2, (char *) &rlim, sizeof(rlim))\n                   != sizeof(rlim))\n                 {\n@@ -521,7 +494,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &usage, sizeof(usage));\n+              translate_endian_h2t (&usage, sizeof(usage));\n               if ((s.write_mem) (cb, &s, arg2, (char *) &usage, sizeof(usage))\n                   != sizeof(usage))\n                 {\n@@ -542,15 +515,15 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &tv, sizeof(tv));\n+              translate_endian_h2t (&tv, sizeof(tv));\n               if ((s.write_mem) (cb, &s, arg1, (char *) &tv, sizeof(tv))\n                   != sizeof(tv))\n                 {\n                   result = -1;\n                   errcode = EINVAL;\n                 }\n \n-              translate_endian((void *) &tz, sizeof(tz));\n+              translate_endian_h2t (&tz, sizeof(tz));\n               if ((s.write_mem) (cb, &s, arg2, (char *) &tz, sizeof(tz))\n                   != sizeof(tz))\n                 {\n@@ -574,7 +547,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) list, arg1 * sizeof(gid_t));\n+              translate_endian_h2t (list, arg1 * sizeof(gid_t));\n               if (arg1 > 0)\n                 if ((s.write_mem) (cb, &s, arg2, (char *) list, arg1 * sizeof(gid_t))\n                     != arg1 * sizeof(gid_t))\n@@ -606,7 +579,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (treadfdsp != NULL)\n                 {\n                   readfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) treadfdsp));\n-                  translate_endian((void *) &readfds, sizeof(readfds));\n+                  translate_endian_t2h (&readfds, sizeof(readfds));\n                   hreadfdsp = &readfds;\n                 }\n               else\n@@ -616,7 +589,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (twritefdsp != NULL)\n                 {\n                   writefds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) twritefdsp));\n-                  translate_endian((void *) &writefds, sizeof(writefds));\n+                  translate_endian_t2h (&writefds, sizeof(writefds));\n                   hwritefdsp = &writefds;\n                 }\n               else\n@@ -626,15 +599,15 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (texceptfdsp != NULL)\n                 {\n                   exceptfds = *((fd_set *) t2h_addr(cb, &s, (unsigned int) texceptfdsp));\n-                  translate_endian((void *) &exceptfds, sizeof(exceptfds));\n+                  translate_endian_t2h (&exceptfds, sizeof(exceptfds));\n                   hexceptfdsp = &exceptfds;\n                 }\n               else\n                 hexceptfdsp = NULL;\n               \n               ttimeoutp = (struct timeval *) arg5;\n               timeout = *((struct timeval *) t2h_addr(cb, &s, (unsigned int) ttimeoutp));\n-              translate_endian((void *) &timeout, sizeof(timeout));\n+              translate_endian_t2h (&timeout, sizeof(timeout));\n \n               result = select(n, hreadfdsp, hwritefdsp, hexceptfdsp, &timeout);\n               errcode = errno;\n@@ -644,7 +617,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n \n               if (treadfdsp != NULL)\n                 {\n-                  translate_endian((void *) &readfds, sizeof(readfds));\n+                  translate_endian_h2t (&readfds, sizeof(readfds));\n                   if ((s.write_mem) (cb, &s, (unsigned long) treadfdsp,\n                        (char *) &readfds, sizeof(readfds)) != sizeof(readfds))\n                     {\n@@ -655,7 +628,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n \n               if (twritefdsp != NULL)\n                 {\n-                  translate_endian((void *) &writefds, sizeof(writefds));\n+                  translate_endian_h2t (&writefds, sizeof(writefds));\n                   if ((s.write_mem) (cb, &s, (unsigned long) twritefdsp,\n                        (char *) &writefds, sizeof(writefds)) != sizeof(writefds))\n                     {\n@@ -666,7 +639,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n \n               if (texceptfdsp != NULL)\n                 {\n-                  translate_endian((void *) &exceptfds, sizeof(exceptfds));\n+                  translate_endian_h2t (&exceptfds, sizeof(exceptfds));\n                   if ((s.write_mem) (cb, &s, (unsigned long) texceptfdsp,\n                        (char *) &exceptfds, sizeof(exceptfds)) != sizeof(exceptfds))\n                     {\n@@ -675,7 +648,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n                     }\n                 }\n \n-              translate_endian((void *) &timeout, sizeof(timeout));\n+              translate_endian_h2t (&timeout, sizeof(timeout));\n               if ((s.write_mem) (cb, &s, (unsigned long) ttimeoutp,\n                    (char *) &timeout, sizeof(timeout)) != sizeof(timeout))\n                 {\n@@ -760,12 +733,12 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               fildes = *((int *)    t2h_addr(cb, &s, arg1 + 16));\n               off    = *((off_t *)  t2h_addr(cb, &s, arg1 + 20));\n \n-              addr   = (void *) conv_endian((unsigned int) addr);\n-              len    = conv_endian(len);\n-              prot   = conv_endian(prot);\n-              flags  = conv_endian(flags);\n-              fildes = conv_endian(fildes);\n-              off    = conv_endian(off);\n+              addr   = (void *) T2H_4 ((unsigned int) addr);\n+              len    = T2H_4 (len);\n+              prot   = T2H_4 (prot);\n+              flags  = T2H_4 (flags);\n+              fildes = T2H_4 (fildes);\n+              off    = T2H_4 (off);\n \n               //addr   = (void *) t2h_addr(cb, &s, (unsigned int) addr);\n               result = (int) mmap(addr, len, prot, flags, fildes, off);\n@@ -825,7 +798,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &statbuf, sizeof(statbuf));\n+              translate_endian_h2t (&statbuf, sizeof(statbuf));\n               if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n                   != sizeof(statbuf))\n                 {\n@@ -845,7 +818,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &statbuf, sizeof(statbuf));\n+              translate_endian_h2t (&statbuf, sizeof(statbuf));\n               if ((s.write_mem) (cb, &s, arg2, (char *) &statbuf, sizeof(statbuf))\n                   != sizeof(statbuf))\n                 {\n@@ -865,7 +838,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               struct itimerval value, ovalue;\n \n               value = *((struct itimerval *) t2h_addr(cb, &s, arg2));\n-              translate_endian((void *) &value, sizeof(value));\n+              translate_endian_t2h (&value, sizeof(value));\n \n               if (arg2 == 0)\n                 {\n@@ -880,7 +853,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n                   if (result != 0)\n                     break;\n \n-                  translate_endian((void *) &ovalue, sizeof(ovalue));\n+                  translate_endian_h2t (&ovalue, sizeof(ovalue));\n                   if ((s.write_mem) (cb, &s, arg3, (char *) &ovalue, sizeof(ovalue))\n                       != sizeof(ovalue))\n                     {\n@@ -901,7 +874,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &value, sizeof(value));\n+              translate_endian_h2t (&value, sizeof(value));\n               if ((s.write_mem) (cb, &s, arg2, (char *) &value, sizeof(value))\n                   != sizeof(value))\n                 {\n@@ -1020,21 +993,21 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              info.uptime    = conv_endian(info.uptime);\n-              info.loads[0]  = conv_endian(info.loads[0]);\n-              info.loads[1]  = conv_endian(info.loads[1]);\n-              info.loads[2]  = conv_endian(info.loads[2]);\n-              info.totalram  = conv_endian(info.totalram);\n-              info.freeram   = conv_endian(info.freeram);\n-              info.sharedram = conv_endian(info.sharedram);\n-              info.bufferram = conv_endian(info.bufferram);\n-              info.totalswap = conv_endian(info.totalswap);\n-              info.freeswap  = conv_endian(info.freeswap);\n-              info.procs     = conv_endian16(info.procs);\n+              info.uptime    = H2T_4 (info.uptime);\n+              info.loads[0]  = H2T_4 (info.loads[0]);\n+              info.loads[1]  = H2T_4 (info.loads[1]);\n+              info.loads[2]  = H2T_4 (info.loads[2]);\n+              info.totalram  = H2T_4 (info.totalram);\n+              info.freeram   = H2T_4 (info.freeram);\n+              info.sharedram = H2T_4 (info.sharedram);\n+              info.bufferram = H2T_4 (info.bufferram);\n+              info.totalswap = H2T_4 (info.totalswap);\n+              info.freeswap  = H2T_4 (info.freeswap);\n+              info.procs     = H2T_2 (info.procs);\n #if LINUX_VERSION_CODE >= 0x20400\n-              info.totalhigh = conv_endian(info.totalhigh);\n-              info.freehigh  = conv_endian(info.freehigh);\n-              info.mem_unit  = conv_endian(info.mem_unit);\n+              info.totalhigh = H2T_4 (info.totalhigh);\n+              info.freehigh  = H2T_4 (info.freehigh);\n+              info.mem_unit  = H2T_4 (info.mem_unit);\n #endif\n               if ((s.write_mem) (cb, &s, arg1, (char *) &info, sizeof(info))\n                   != sizeof(info))\n@@ -1077,7 +1050,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &buf, sizeof(buf));\n+              translate_endian_h2t (&buf, sizeof(buf));\n               if ((s.write_mem) (cb, &s, arg1, (char *) &buf, sizeof(buf))\n                   != sizeof(buf))\n                 {\n@@ -1120,7 +1093,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &buf, sizeof(buf));\n+              translate_endian_h2t (&buf, sizeof(buf));\n               if ((s.write_mem) (cb, &s, t2h_addr(cb, &s, arg4),\n                                  (char *) &buf, sizeof(buf)) != sizeof(buf))\n                 {\n@@ -1140,9 +1113,9 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              dir.d_ino = conv_endian(dir.d_ino);\n-              dir.d_off = conv_endian(dir.d_off);\n-              dir.d_reclen = conv_endian16(dir.d_reclen);\n+              dir.d_ino = H2T_4 (dir.d_ino);\n+              dir.d_off = H2T_4 (dir.d_off);\n+              dir.d_reclen = H2T_2 (dir.d_reclen);\n               if ((s.write_mem) (cb, &s, arg2, (char *) &dir, sizeof(dir))\n                   != sizeof(dir))\n                 {\n@@ -1168,7 +1141,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               struct iovec vector;\n \n               vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n-              translate_endian((void *) &vector, sizeof(vector));\n+              translate_endian_t2h (&vector, sizeof(vector));\n \n               result = readv(arg1, &vector, arg3);\n               errcode = errno;\n@@ -1180,7 +1153,7 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               struct iovec vector;\n \n               vector = *((struct iovec *) t2h_addr(cb, &s, arg2));\n-              translate_endian((void *) &vector, sizeof(vector));\n+              translate_endian_t2h (&vector, sizeof(vector));\n \n               result = writev(arg1, &vector, arg3);\n               errcode = errno;\n@@ -1207,15 +1180,15 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               struct timespec req, rem;\n \n               req = *((struct timespec *) t2h_addr(cb, &s, arg2));\n-              translate_endian((void *) &req, sizeof(req));\n+              translate_endian_t2h (&req, sizeof(req));\n \n               result = nanosleep(&req, &rem);\n               errcode = errno;\n \n               if (result != 0)\n                 break;\n \n-              translate_endian((void *) &rem, sizeof(rem));\n+              translate_endian_h2t (&rem, sizeof(rem));\n               if ((s.write_mem) (cb, &s, arg2, (char *) &rem, sizeof(rem))\n                   != sizeof(rem))\n                 {\n@@ -1241,9 +1214,9 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              *((uid_t *) t2h_addr(cb, &s, arg1)) = conv_endian(ruid);\n-              *((uid_t *) t2h_addr(cb, &s, arg2)) = conv_endian(euid);\n-              *((uid_t *) t2h_addr(cb, &s, arg3)) = conv_endian(suid);\n+              *((uid_t *) t2h_addr(cb, &s, arg1)) = H2T_4 (ruid);\n+              *((uid_t *) t2h_addr(cb, &s, arg2)) = H2T_4 (euid);\n+              *((uid_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (suid);\n             }\n             break;\n \n@@ -1252,9 +1225,9 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               struct pollfd ufds;\n \n               ufds = *((struct pollfd *) t2h_addr(cb, &s, arg1));\n-              ufds.fd = conv_endian(ufds.fd);\n-              ufds.events = conv_endian16(ufds.events);\n-              ufds.revents = conv_endian16(ufds.revents);\n+              ufds.fd = T2H_4 (ufds.fd);\n+              ufds.events = T2H_2 (ufds.events);\n+              ufds.revents = T2H_2 (ufds.revents);\n \n               result = poll(&ufds, arg2, arg3);\n               errcode = errno;\n@@ -1272,9 +1245,9 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               if (result != 0)\n                 break;\n \n-              *((uid_t *) t2h_addr(cb, &s, arg1)) = conv_endian(rgid);\n-              *((uid_t *) t2h_addr(cb, &s, arg2)) = conv_endian(egid);\n-              *((uid_t *) t2h_addr(cb, &s, arg3)) = conv_endian(sgid);\n+              *((uid_t *) t2h_addr(cb, &s, arg1)) = H2T_4 (rgid);\n+              *((uid_t *) t2h_addr(cb, &s, arg2)) = H2T_4 (egid);\n+              *((uid_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (sgid);\n             }\n             break;\n \n@@ -1304,15 +1277,15 @@ m32r_trap (SIM_CPU *current_cpu, PCADDR pc, int num)\n               off_t offset;\n \n               offset = *((off_t *) t2h_addr(cb, &s, arg3));\n-              offset = conv_endian(offset);\n+              offset = T2H_4 (offset);\n \n               result = sendfile(arg1, arg2, &offset, arg3);\n               errcode = errno;\n \n               if (result != 0)\n                 break;\n \n-              *((off_t *) t2h_addr(cb, &s, arg3)) = conv_endian(offset);\n+              *((off_t *) t2h_addr(cb, &s, arg3)) = H2T_4 (offset);\n             }\n             break;\n "
    }
  ]
}