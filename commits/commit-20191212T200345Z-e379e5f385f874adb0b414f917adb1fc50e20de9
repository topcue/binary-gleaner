{
  "sha": "e379e5f385f874adb0b414f917adb1fc50e20de9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTM3OWU1ZjM4NWY4NzRhZGIwYjQxNGY5MTdhZGIxZmM1MGUyMGRlOQ==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2019-12-12T19:56:06Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2019-12-12T20:03:45Z"
    },
    "message": "i386: Align branches within a fixed boundary\n\nAdd 3 command-line options to align branches within a fixed boundary\nwith segment prefixes or NOPs:\n\n1. -malign-branch-boundary=NUM aligns branches within NUM byte boundary.\n2. -malign-branch=TYPE[+TYPE...] specifies types of branches to align.\nThe supported branches are:\n  a. Conditional jump.\n  b. Fused conditional jump.\n  c. Unconditional jump.\n  d. Call.\n  e. Ret.\n  f. Indirect jump and call.\n3. -malign-branch-prefix-size=NUM aligns branches with NUM segment\nprefixes per instruction.\n\n3 new rs_machine_dependent frag types are added:\n\n1. BRANCH_PADDING.  The variable size frag to insert NOP before branch.\n2. BRANCH_PREFIX.  The variable size frag to insert segment prefixes to\nan instruction.  The choices of prefixes are:\n   a. Use the existing segment prefix if there is one.\n   b. Use CS segment prefix in 64-bit mode.\n   c. In 32-bit mode, use SS segment prefix with ESP/EBP base register\n   and use DS segment prefix without ESP/EBP base register.\n3. FUSED_JCC_PADDING.  The variable size frag to insert NOP before fused\nconditional jump.\n\nThe new rs_machine_dependent frags aren't inserted if the previous item\nis a prefix or a constant directive, which may be used to hardcode an\ninstruction, since there is no clear instruction boundary.  Segment\nprefixes and NOP padding are disabled before relaxable TLS relocations\nand tls_get_addr calls to keep TLS instruction sequence unchanged.\n\nmd_estimate_size_before_relax() and i386_generic_table_relax_frag() are\nused to handled BRANCH_PADDING, BRANCH_PREFIX and FUSED_JCC_PADDING frags.\ni386_generic_table_relax_frag() grows or shrinks sizes of segment prefix\nand NOP to align the next branch frag:\n\n1. First try to add segment prefixes to instructions before a branch.\n2. If there is no sufficient room to add segment prefixes, NOP will be\ninserted before a branch.\n\n\t* config/tc-i386.c (_i386_insn): Add has_gotpc_tls_reloc.\n\t(tls_get_addr): New.\n\t(last_insn): New.\n\t(align_branch_power): New.\n\t(align_branch_kind): New.\n\t(align_branch_bit): New.\n\t(align_branch): New.\n\t(MAX_FUSED_JCC_PADDING_SIZE): New.\n\t(align_branch_prefix_size): New.\n\t(BRANCH_PADDING): New.\n\t(BRANCH_PREFIX): New.\n\t(FUSED_JCC_PADDING): New.\n\t(i386_generate_nops): Support BRANCH_PADDING and FUSED_JCC_PADDING.\n\t(md_begin): Abort if align_branch_prefix_size <\n\tMAX_FUSED_JCC_PADDING_SIZE.\n\t(md_assemble): Set last_insn.\n\t(maybe_fused_with_jcc_p): New.\n\t(add_fused_jcc_padding_frag_p): New.\n\t(add_branch_prefix_frag_p): New.\n\t(add_branch_padding_frag_p): New.\n\t(output_insn): Generate a BRANCH_PADDING, FUSED_JCC_PADDING or\n\tBRANCH_PREFIX frag and terminate each frag to align branches.\n\t(output_disp): Set i.has_gotpc_tls_reloc to TRUE for GOTPC and\n\trelaxable TLS relocations.\n\t(output_imm): Likewise.\n\t(i386_next_non_empty_frag): New.\n\t(i386_next_jcc_frag): New.\n\t(i386_classify_machine_dependent_frag): New.\n\t(i386_branch_padding_size): New.\n\t(i386_generic_table_relax_frag): New.\n\t(md_estimate_size_before_relax): Handle COND_JUMP_PADDING,\n\tFUSED_JCC_PADDING and COND_JUMP_PREFIX frags.\n\t(md_convert_frag): Handle BRANCH_PADDING, BRANCH_PREFIX and\n\tFUSED_JCC_PADDING frags.\n\t(OPTION_MALIGN_BRANCH_BOUNDARY): New.\n\t(OPTION_MALIGN_BRANCH_PREFIX_SIZE): New.\n\t(OPTION_MALIGN_BRANCH): New.\n\t(md_longopts): Add -malign-branch-boundary=,\n\t-malign-branch-prefix-size= and -malign-branch=.\n\t(md_parse_option): Handle -malign-branch-boundary=,\n\t-malign-branch-prefix-size= and -malign-branch=.\n\t(md_show_usage): Display -malign-branch-boundary=,\n\t-malign-branch-prefix-size= and -malign-branch=.\n\t(i386_target_format): Set tls_get_addr.\n\t(i386_cons_align): New.\n\t* config/tc-i386.h (i386_cons_align): New.\n\t(md_cons_align): New.\n\t(i386_generic_table_relax_frag): New.\n\t(md_generic_table_relax_frag): New.\n\t(i386_tc_frag_data): Add u, padding_address, length,\n\tmax_prefix_length, prefix_length, default_prefix, cmp_size,\n\tclassified and branch_type.\n\t(TC_FRAG_INIT): Initialize u, padding_address, length,\n\tmax_prefix_length, prefix_length, default_prefix, cmp_size,\n\tclassified and branch_type.\n\t* doc/c-i386.texi: Document -malign-branch-boundary=,\n\t-malign-branch= and -malign-branch-prefix-size=.",
    "tree": {
      "sha": "e9a1ad41c0582dd54bfebe9391afb382105f907c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e9a1ad41c0582dd54bfebe9391afb382105f907c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e379e5f385f874adb0b414f917adb1fc50e20de9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e379e5f385f874adb0b414f917adb1fc50e20de9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e379e5f385f874adb0b414f917adb1fc50e20de9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e379e5f385f874adb0b414f917adb1fc50e20de9/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b65d68b8d60338a860e169aac3bac54e6bac60db",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b65d68b8d60338a860e169aac3bac54e6bac60db",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b65d68b8d60338a860e169aac3bac54e6bac60db"
    }
  ],
  "stats": {
    "total": 1163,
    "additions": 1160,
    "deletions": 3
  },
  "files": [
    {
      "sha": "7b83a0abd13cebb2afc17ff7ddad02b67b27ee5e",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 60,
      "deletions": 0,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e379e5f385f874adb0b414f917adb1fc50e20de9/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e379e5f385f874adb0b414f917adb1fc50e20de9/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=e379e5f385f874adb0b414f917adb1fc50e20de9",
      "patch": "@@ -1,3 +1,63 @@\n+2019-12-12  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/tc-i386.c (_i386_insn): Add has_gotpc_tls_reloc.\n+\t(tls_get_addr): New.\n+\t(last_insn): New.\n+\t(align_branch_power): New.\n+\t(align_branch_kind): New.\n+\t(align_branch_bit): New.\n+\t(align_branch): New.\n+\t(MAX_FUSED_JCC_PADDING_SIZE): New.\n+\t(align_branch_prefix_size): New.\n+\t(BRANCH_PADDING): New.\n+\t(BRANCH_PREFIX): New.\n+\t(FUSED_JCC_PADDING): New.\n+\t(i386_generate_nops): Support BRANCH_PADDING and FUSED_JCC_PADDING.\n+\t(md_begin): Abort if align_branch_prefix_size <\n+\tMAX_FUSED_JCC_PADDING_SIZE.\n+\t(md_assemble): Set last_insn.\n+\t(maybe_fused_with_jcc_p): New.\n+\t(add_fused_jcc_padding_frag_p): New.\n+\t(add_branch_prefix_frag_p): New.\n+\t(add_branch_padding_frag_p): New.\n+\t(output_insn): Generate a BRANCH_PADDING, FUSED_JCC_PADDING or\n+\tBRANCH_PREFIX frag and terminate each frag to align branches.\n+\t(output_disp): Set i.has_gotpc_tls_reloc to TRUE for GOTPC and\n+\trelaxable TLS relocations.\n+\t(output_imm): Likewise.\n+\t(i386_next_non_empty_frag): New.\n+\t(i386_next_jcc_frag): New.\n+\t(i386_classify_machine_dependent_frag): New.\n+\t(i386_branch_padding_size): New.\n+\t(i386_generic_table_relax_frag): New.\n+\t(md_estimate_size_before_relax): Handle COND_JUMP_PADDING,\n+\tFUSED_JCC_PADDING and COND_JUMP_PREFIX frags.\n+\t(md_convert_frag): Handle BRANCH_PADDING, BRANCH_PREFIX and\n+\tFUSED_JCC_PADDING frags.\n+\t(OPTION_MALIGN_BRANCH_BOUNDARY): New.\n+\t(OPTION_MALIGN_BRANCH_PREFIX_SIZE): New.\n+\t(OPTION_MALIGN_BRANCH): New.\n+\t(md_longopts): Add -malign-branch-boundary=,\n+\t-malign-branch-prefix-size= and -malign-branch=.\n+\t(md_parse_option): Handle -malign-branch-boundary=,\n+\t-malign-branch-prefix-size= and -malign-branch=.\n+\t(md_show_usage): Display -malign-branch-boundary=,\n+\t-malign-branch-prefix-size= and -malign-branch=.\n+\t(i386_target_format): Set tls_get_addr.\n+\t(i386_cons_align): New.\n+\t* config/tc-i386.h (i386_cons_align): New.\n+\t(md_cons_align): New.\n+\t(i386_generic_table_relax_frag): New.\n+\t(md_generic_table_relax_frag): New.\n+\t(i386_tc_frag_data): Add u, padding_address, length,\n+\tmax_prefix_length, prefix_length, default_prefix, cmp_size,\n+\tclassified and branch_type.\n+\t(TC_FRAG_INIT): Initialize u, padding_address, length,\n+\tmax_prefix_length, prefix_length, default_prefix, cmp_size,\n+\tclassified and branch_type.\n+\t* doc/c-i386.texi: Document -malign-branch-boundary=,\n+\t-malign-branch= and -malign-branch-prefix-size=.\n+\n 2019-12-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* write.c (md_generic_table_relax_frag): New.  Defined to"
    },
    {
      "sha": "41a6a0817a832c76e57685b49876abc3b92a04dd",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 1043,
      "deletions": 3,
      "changes": 1046,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e379e5f385f874adb0b414f917adb1fc50e20de9/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e379e5f385f874adb0b414f917adb1fc50e20de9/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=e379e5f385f874adb0b414f917adb1fc50e20de9",
      "patch": "@@ -368,6 +368,9 @@ struct _i386_insn\n     /* Has ZMM register operands.  */\n     bfd_boolean has_regzmm;\n \n+    /* Has GOTPC or TLS relocation.  */\n+    bfd_boolean has_gotpc_tls_reloc;\n+\n     /* RM and SIB are the modrm byte and the sib byte where the\n        addressing modes of this insn are encoded.  */\n     modrm_byte rm;\n@@ -562,6 +565,8 @@ static enum flag_code flag_code;\n static unsigned int object_64bit;\n static unsigned int disallow_64bit_reloc;\n static int use_rela_relocations = 0;\n+/* __tls_get_addr/___tls_get_addr symbol for TLS.  */\n+static const char *tls_get_addr;\n \n #if ((defined (OBJ_MAYBE_COFF) && defined (OBJ_MAYBE_AOUT)) \\\n      || defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF) \\\n@@ -622,6 +627,21 @@ static int omit_lock_prefix = 0;\n    \"lock addl $0, (%{re}sp)\".  */\n static int avoid_fence = 0;\n \n+/* Type of the previous instruction.  */\n+static struct\n+  {\n+    segT seg;\n+    const char *file;\n+    const char *name;\n+    unsigned int line;\n+    enum last_insn_kind\n+      {\n+\tlast_insn_other = 0,\n+\tlast_insn_directive,\n+\tlast_insn_prefix\n+      } kind;\n+  } last_insn;\n+\n /* 1 if the assembler should generate relax relocations.  */\n \n static int generate_relax_relocations\n@@ -635,6 +655,44 @@ static enum check_kind\n   }\n sse_check, operand_check = check_warning;\n \n+/* Non-zero if branches should be aligned within power of 2 boundary.  */\n+static int align_branch_power = 0;\n+\n+/* Types of branches to align.  */\n+enum align_branch_kind\n+  {\n+    align_branch_none = 0,\n+    align_branch_jcc = 1,\n+    align_branch_fused = 2,\n+    align_branch_jmp = 3,\n+    align_branch_call = 4,\n+    align_branch_indirect = 5,\n+    align_branch_ret = 6\n+  };\n+\n+/* Type bits of branches to align.  */\n+enum align_branch_bit\n+  {\n+    align_branch_jcc_bit = 1 << align_branch_jcc,\n+    align_branch_fused_bit = 1 << align_branch_fused,\n+    align_branch_jmp_bit = 1 << align_branch_jmp,\n+    align_branch_call_bit = 1 << align_branch_call,\n+    align_branch_indirect_bit = 1 << align_branch_indirect,\n+    align_branch_ret_bit = 1 << align_branch_ret\n+  };\n+\n+static unsigned int align_branch = (align_branch_jcc_bit\n+\t\t\t\t    | align_branch_fused_bit\n+\t\t\t\t    | align_branch_jmp_bit);\n+\n+/* The maximum padding size for fused jcc.  CMP like instruction can\n+   be 9 bytes and jcc can be 6 bytes.  Leave room just in case for\n+   prefixes.   */\n+#define MAX_FUSED_JCC_PADDING_SIZE 20\n+\n+/* The maximum number of prefixes added for an instruction.  */\n+static unsigned int align_branch_prefix_size = 5;\n+\n /* Optimization:\n    1. Clear the REX_W bit with register operand if possible.\n    2. Above plus use 128bit vector instruction to clear the full vector\n@@ -738,12 +796,19 @@ int x86_cie_data_alignment;\n /* Interface to relax_segment.\n    There are 3 major relax states for 386 jump insns because the\n    different types of jumps add different sizes to frags when we're\n-   figuring out what sort of jump to choose to reach a given label.  */\n+   figuring out what sort of jump to choose to reach a given label.\n+\n+   BRANCH_PADDING, BRANCH_PREFIX and FUSED_JCC_PADDING are used to align\n+   branches which are handled by md_estimate_size_before_relax() and\n+   i386_generic_table_relax_frag().  */\n \n /* Types.  */\n #define UNCOND_JUMP 0\n #define COND_JUMP 1\n #define COND_JUMP86 2\n+#define BRANCH_PADDING 3\n+#define BRANCH_PREFIX 4\n+#define FUSED_JCC_PADDING 5\n \n /* Sizes.  */\n #define CODE16\t1\n@@ -1384,6 +1449,12 @@ i386_generate_nops (fragS *fragP, char *where, offsetT count, int limit)\n     case rs_fill_nop:\n     case rs_align_code:\n       break;\n+    case rs_machine_dependent:\n+      /* Allow NOP padding for jumps and calls.  */\n+      if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == BRANCH_PADDING\n+\t  || TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == FUSED_JCC_PADDING)\n+\tbreak;\n+      /* Fall through.  */\n     default:\n       return;\n     }\n@@ -1528,7 +1599,7 @@ i386_generate_nops (fragS *fragP, char *where, offsetT count, int limit)\n \t  return;\n \t}\n     }\n-  else\n+  else if (fragP->fr_type != rs_machine_dependent)\n     fragP->fr_var = count;\n \n   if ((count / max_single_nop_size) > max_number_of_nops)\n@@ -3011,6 +3082,11 @@ md_begin (void)\n       x86_dwarf2_return_column = 8;\n       x86_cie_data_alignment = -4;\n     }\n+\n+  /* NB: FUSED_JCC_PADDING frag must have sufficient room so that it\n+     can be turned into BRANCH_PREFIX frag.  */\n+  if (align_branch_prefix_size > MAX_FUSED_JCC_PADDING_SIZE)\n+    abort ();\n }\n \n void\n@@ -4539,6 +4615,17 @@ md_assemble (char *line)\n \n   /* We are ready to output the insn.  */\n   output_insn ();\n+\n+  last_insn.seg = now_seg;\n+\n+  if (i.tm.opcode_modifier.isprefix)\n+    {\n+      last_insn.kind = last_insn_prefix;\n+      last_insn.name = i.tm.name;\n+      last_insn.file = as_where (&last_insn.line);\n+    }\n+  else\n+    last_insn.kind = last_insn_other;\n }\n \n static char *\n@@ -8196,11 +8283,206 @@ encoding_length (const fragS *start_frag, offsetT start_off,\n   return len - start_off + (frag_now_ptr - frag_now->fr_literal);\n }\n \n+/* Return 1 for test, and, cmp, add, sub, inc and dec which may\n+   be macro-fused with conditional jumps.  */\n+\n+static int\n+maybe_fused_with_jcc_p (void)\n+{\n+  /* No RIP address.  */\n+  if (i.base_reg && i.base_reg->reg_num == RegIP)\n+    return 0;\n+\n+  /* No VEX/EVEX encoding.  */\n+  if (is_any_vex_encoding (&i.tm))\n+    return 0;\n+\n+  /* and, add, sub with destination register.  */\n+  if ((i.tm.base_opcode >= 0x20 && i.tm.base_opcode <= 0x25)\n+      || i.tm.base_opcode <= 5\n+      || (i.tm.base_opcode >= 0x28 && i.tm.base_opcode <= 0x2d)\n+      || ((i.tm.base_opcode | 3) == 0x83\n+\t  && ((i.tm.extension_opcode | 1) == 0x5\n+\t      || i.tm.extension_opcode == 0x0)))\n+    return (i.types[1].bitfield.class == Reg\n+\t    || i.types[1].bitfield.instance == Accum);\n+\n+  /* test, cmp with any register.  */\n+  if ((i.tm.base_opcode | 1) == 0x85\n+      || (i.tm.base_opcode | 1) == 0xa9\n+      || ((i.tm.base_opcode | 1) == 0xf7\n+\t  && i.tm.extension_opcode == 0)\n+      || (i.tm.base_opcode >= 0x38 && i.tm.base_opcode <= 0x3d)\n+      || ((i.tm.base_opcode | 3) == 0x83\n+\t  && (i.tm.extension_opcode == 0x7)))\n+    return (i.types[0].bitfield.class == Reg\n+\t    || i.types[0].bitfield.instance == Accum\n+\t    || i.types[1].bitfield.class == Reg\n+\t    || i.types[1].bitfield.instance == Accum);\n+\n+  /* inc, dec with any register.   */\n+  if ((i.tm.cpu_flags.bitfield.cpuno64\n+       && (i.tm.base_opcode | 0xf) == 0x4f)\n+      || ((i.tm.base_opcode | 1) == 0xff\n+\t  && i.tm.extension_opcode <= 0x1))\n+    return (i.types[0].bitfield.class == Reg\n+\t    || i.types[0].bitfield.instance == Accum);\n+\n+  return 0;\n+}\n+\n+/* Return 1 if a FUSED_JCC_PADDING frag should be generated.  */\n+\n+static int\n+add_fused_jcc_padding_frag_p (void)\n+{\n+  /* NB: Don't work with COND_JUMP86 without i386.  */\n+  if (!align_branch_power\n+      || now_seg == absolute_section\n+      || !cpu_arch_flags.bitfield.cpui386\n+      || !(align_branch & align_branch_fused_bit))\n+    return 0;\n+\n+  if (maybe_fused_with_jcc_p ())\n+    {\n+      if (last_insn.kind == last_insn_other\n+\t  || last_insn.seg != now_seg)\n+\treturn 1;\n+      if (flag_debug)\n+\tas_warn_where (last_insn.file, last_insn.line,\n+\t\t       _(\"`%s` skips -malign-branch-boundary on `%s`\"),\n+\t\t       last_insn.name, i.tm.name);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Return 1 if a BRANCH_PREFIX frag should be generated.  */\n+\n+static int\n+add_branch_prefix_frag_p (void)\n+{\n+  /* NB: Don't work with COND_JUMP86 without i386.  Don't add prefix\n+     to PadLock instructions since they include prefixes in opcode.  */\n+  if (!align_branch_power\n+      || !align_branch_prefix_size\n+      || now_seg == absolute_section\n+      || i.tm.cpu_flags.bitfield.cpupadlock\n+      || !cpu_arch_flags.bitfield.cpui386)\n+    return 0;\n+\n+  /* Don't add prefix if it is a prefix or there is no operand in case\n+     that segment prefix is special.  */\n+  if (!i.operands || i.tm.opcode_modifier.isprefix)\n+    return 0;\n+\n+  if (last_insn.kind == last_insn_other\n+      || last_insn.seg != now_seg)\n+    return 1;\n+\n+  if (flag_debug)\n+    as_warn_where (last_insn.file, last_insn.line,\n+\t\t   _(\"`%s` skips -malign-branch-boundary on `%s`\"),\n+\t\t   last_insn.name, i.tm.name);\n+\n+  return 0;\n+}\n+\n+/* Return 1 if a BRANCH_PADDING frag should be generated.  */\n+\n+static int\n+add_branch_padding_frag_p (enum align_branch_kind *branch_p)\n+{\n+  int add_padding;\n+\n+  /* NB: Don't work with COND_JUMP86 without i386.  */\n+  if (!align_branch_power\n+      || now_seg == absolute_section\n+      || !cpu_arch_flags.bitfield.cpui386)\n+    return 0;\n+\n+  add_padding = 0;\n+\n+  /* Check for jcc and direct jmp.  */\n+  if (i.tm.opcode_modifier.jump == JUMP)\n+    {\n+      if (i.tm.base_opcode == JUMP_PC_RELATIVE)\n+\t{\n+\t  *branch_p = align_branch_jmp;\n+\t  add_padding = align_branch & align_branch_jmp_bit;\n+\t}\n+      else\n+\t{\n+\t  *branch_p = align_branch_jcc;\n+\t  if ((align_branch & align_branch_jcc_bit))\n+\t    add_padding = 1;\n+\t}\n+    }\n+  else if (is_any_vex_encoding (&i.tm))\n+    return 0;\n+  else if ((i.tm.base_opcode | 1) == 0xc3)\n+    {\n+      /* Near ret.  */\n+      *branch_p = align_branch_ret;\n+      if ((align_branch & align_branch_ret_bit))\n+\tadd_padding = 1;\n+    }\n+  else\n+    {\n+      /* Check for indirect jmp, direct and indirect calls.  */\n+      if (i.tm.base_opcode == 0xe8)\n+\t{\n+\t  /* Direct call.  */\n+\t  *branch_p = align_branch_call;\n+\t  if ((align_branch & align_branch_call_bit))\n+\t    add_padding = 1;\n+\t}\n+      else if (i.tm.base_opcode == 0xff\n+\t       && (i.tm.extension_opcode == 2\n+\t\t   || i.tm.extension_opcode == 4))\n+\t{\n+\t  /* Indirect call and jmp.  */\n+\t  *branch_p = align_branch_indirect;\n+\t  if ((align_branch & align_branch_indirect_bit))\n+\t    add_padding = 1;\n+\t}\n+\n+      if (add_padding\n+\t  && i.disp_operands\n+\t  && tls_get_addr\n+\t  && (i.op[0].disps->X_op == O_symbol\n+\t      || (i.op[0].disps->X_op == O_subtract\n+\t\t  && i.op[0].disps->X_op_symbol == GOT_symbol)))\n+\t{\n+\t  symbolS *s = i.op[0].disps->X_add_symbol;\n+\t  /* No padding to call to global or undefined tls_get_addr.  */\n+\t  if ((S_IS_EXTERNAL (s) || !S_IS_DEFINED (s))\n+\t      && strcmp (S_GET_NAME (s), tls_get_addr) == 0)\n+\t    return 0;\n+\t}\n+    }\n+\n+  if (add_padding\n+      && last_insn.kind != last_insn_other\n+      && last_insn.seg == now_seg)\n+    {\n+      if (flag_debug)\n+\tas_warn_where (last_insn.file, last_insn.line,\n+\t\t       _(\"`%s` skips -malign-branch-boundary on `%s`\"),\n+\t\t       last_insn.name, i.tm.name);\n+      return 0;\n+    }\n+\n+  return add_padding;\n+}\n+\n static void\n output_insn (void)\n {\n   fragS *insn_start_frag;\n   offsetT insn_start_off;\n+  fragS *fragP = NULL;\n+  enum align_branch_kind branch = align_branch_none;\n \n #if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)\n   if (IS_ELF && x86_used_note)\n@@ -8291,6 +8573,31 @@ output_insn (void)\n   insn_start_frag = frag_now;\n   insn_start_off = frag_now_fix ();\n \n+  if (add_branch_padding_frag_p (&branch))\n+    {\n+      char *p;\n+      /* Branch can be 8 bytes.  Leave some room for prefixes.  */\n+      unsigned int max_branch_padding_size = 14;\n+\n+      /* Align section to boundary.  */\n+      record_alignment (now_seg, align_branch_power);\n+\n+      /* Make room for padding.  */\n+      frag_grow (max_branch_padding_size);\n+\n+      /* Start of the padding.  */\n+      p = frag_more (0);\n+\n+      fragP = frag_now;\n+\n+      frag_var (rs_machine_dependent, max_branch_padding_size, 0,\n+\t\tENCODE_RELAX_STATE (BRANCH_PADDING, 0),\n+\t\tNULL, 0, p);\n+\n+      fragP->tc_frag_data.branch_type = branch;\n+      fragP->tc_frag_data.max_bytes = max_branch_padding_size;\n+    }\n+\n   /* Output jumps.  */\n   if (i.tm.opcode_modifier.jump == JUMP)\n     output_branch ();\n@@ -8329,6 +8636,41 @@ output_insn (void)\n \t  i.prefix[LOCK_PREFIX] = 0;\n \t}\n \n+      if (branch)\n+\t/* Skip if this is a branch.  */\n+\t;\n+      else if (add_fused_jcc_padding_frag_p ())\n+\t{\n+\t  /* Make room for padding.  */\n+\t  frag_grow (MAX_FUSED_JCC_PADDING_SIZE);\n+\t  p = frag_more (0);\n+\n+\t  fragP = frag_now;\n+\n+\t  frag_var (rs_machine_dependent, MAX_FUSED_JCC_PADDING_SIZE, 0,\n+\t\t    ENCODE_RELAX_STATE (FUSED_JCC_PADDING, 0),\n+\t\t    NULL, 0, p);\n+\n+\t  fragP->tc_frag_data.branch_type = align_branch_fused;\n+\t  fragP->tc_frag_data.max_bytes = MAX_FUSED_JCC_PADDING_SIZE;\n+\t}\n+      else if (add_branch_prefix_frag_p ())\n+\t{\n+\t  unsigned int max_prefix_size = align_branch_prefix_size;\n+\n+\t  /* Make room for padding.  */\n+\t  frag_grow (max_prefix_size);\n+\t  p = frag_more (0);\n+\n+\t  fragP = frag_now;\n+\n+\t  frag_var (rs_machine_dependent, max_prefix_size, 0,\n+\t\t    ENCODE_RELAX_STATE (BRANCH_PREFIX, 0),\n+\t\t    NULL, 0, p);\n+\n+\t  fragP->tc_frag_data.max_bytes = max_prefix_size;\n+\t}\n+\n       /* Since the VEX/EVEX prefix contains the implicit prefix, we\n \t don't need the explicit prefix.  */\n       if (!i.tm.opcode_modifier.vex && !i.tm.opcode_modifier.evex)\n@@ -8476,9 +8818,105 @@ output_insn (void)\n \t  if (j > 15)\n \t    as_warn (_(\"instruction length of %u bytes exceeds the limit of 15\"),\n \t\t     j);\n+\t  else if (fragP)\n+\t    {\n+\t      /* NB: Don't add prefix with GOTPC relocation since\n+\t\t output_disp() above depends on the fixed encoding\n+\t\t length.  Can't add prefix with TLS relocation since\n+\t\t it breaks TLS linker optimization.  */\n+\t      unsigned int max = i.has_gotpc_tls_reloc ? 0 : 15 - j;\n+\t      /* Prefix count on the current instruction.  */\n+\t      unsigned int count = i.vex.length;\n+\t      unsigned int k;\n+\t      for (k = 0; k < ARRAY_SIZE (i.prefix); k++)\n+\t\t/* REX byte is encoded in VEX/EVEX prefix.  */\n+\t\tif (i.prefix[k] && (k != REX_PREFIX || !i.vex.length))\n+\t\t  count++;\n+\n+\t      /* Count prefixes for extended opcode maps.  */\n+\t      if (!i.vex.length)\n+\t\tswitch (i.tm.opcode_length)\n+\t\t  {\n+\t\t  case 3:\n+\t\t    if (((i.tm.base_opcode >> 16) & 0xff) == 0xf)\n+\t\t      {\n+\t\t\tcount++;\n+\t\t\tswitch ((i.tm.base_opcode >> 8) & 0xff)\n+\t\t\t  {\n+\t\t\t  case 0x38:\n+\t\t\t  case 0x3a:\n+\t\t\t    count++;\n+\t\t\t    break;\n+\t\t\t  default:\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t      }\n+\t\t    break;\n+\t\t  case 2:\n+\t\t    if (((i.tm.base_opcode >> 8) & 0xff) == 0xf)\n+\t\t      count++;\n+\t\t    break;\n+\t\t  case 1:\n+\t\t    break;\n+\t\t  default:\n+\t\t    abort ();\n+\t\t  }\n+\n+\t      if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype)\n+\t\t  == BRANCH_PREFIX)\n+\t\t{\n+\t\t  /* Set the maximum prefix size in BRANCH_PREFIX\n+\t\t     frag.  */\n+\t\t  if (fragP->tc_frag_data.max_bytes > max)\n+\t\t    fragP->tc_frag_data.max_bytes = max;\n+\t\t  if (fragP->tc_frag_data.max_bytes > count)\n+\t\t    fragP->tc_frag_data.max_bytes -= count;\n+\t\t  else\n+\t\t    fragP->tc_frag_data.max_bytes = 0;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Remember the maximum prefix size in FUSED_JCC_PADDING\n+\t\t     frag.  */\n+\t\t  unsigned int max_prefix_size;\n+\t\t  if (align_branch_prefix_size > max)\n+\t\t    max_prefix_size = max;\n+\t\t  else\n+\t\t    max_prefix_size = align_branch_prefix_size;\n+\t\t  if (max_prefix_size > count)\n+\t\t    fragP->tc_frag_data.max_prefix_length\n+\t\t      = max_prefix_size - count;\n+\t\t}\n+\n+\t      /* Use existing segment prefix if possible.  Use CS\n+\t\t segment prefix in 64-bit mode.  In 32-bit mode, use SS\n+\t\t segment prefix with ESP/EBP base register and use DS\n+\t\t segment prefix without ESP/EBP base register.  */\n+\t      if (i.prefix[SEG_PREFIX])\n+\t\tfragP->tc_frag_data.default_prefix = i.prefix[SEG_PREFIX];\n+\t      else if (flag_code == CODE_64BIT)\n+\t\tfragP->tc_frag_data.default_prefix = CS_PREFIX_OPCODE;\n+\t      else if (i.base_reg\n+\t\t       && (i.base_reg->reg_num == 4\n+\t\t\t   || i.base_reg->reg_num == 5))\n+\t\tfragP->tc_frag_data.default_prefix = SS_PREFIX_OPCODE;\n+\t      else\n+\t\tfragP->tc_frag_data.default_prefix = DS_PREFIX_OPCODE;\n+\t    }\n \t}\n     }\n \n+  /* NB: Don't work with COND_JUMP86 without i386.  */\n+  if (align_branch_power\n+      && now_seg != absolute_section\n+      && cpu_arch_flags.bitfield.cpui386)\n+    {\n+      /* Terminate each frag so that we can add prefix and check for\n+         fused jcc.  */\n+      frag_wane (frag_now);\n+      frag_new (0);\n+    }\n+\n #ifdef DEBUG386\n   if (flag_debug)\n     {\n@@ -8588,6 +9026,7 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)\n \t\t  if (!object_64bit)\n \t\t    {\n \t\t      reloc_type = BFD_RELOC_386_GOTPC;\n+\t\t      i.has_gotpc_tls_reloc = TRUE;\n \t\t      i.op[n].imms->X_add_number +=\n \t\t\tencoding_length (insn_start_frag, insn_start_off, p);\n \t\t    }\n@@ -8599,6 +9038,27 @@ output_disp (fragS *insn_start_frag, offsetT insn_start_off)\n \t\t       insn, and that is taken care of in other code.  */\n \t\t    reloc_type = BFD_RELOC_X86_64_GOTPC32;\n \t\t}\n+\t      else if (align_branch_power)\n+\t\t{\n+\t\t  switch (reloc_type)\n+\t\t    {\n+\t\t    case BFD_RELOC_386_TLS_GD:\n+\t\t    case BFD_RELOC_386_TLS_LDM:\n+\t\t    case BFD_RELOC_386_TLS_IE:\n+\t\t    case BFD_RELOC_386_TLS_IE_32:\n+\t\t    case BFD_RELOC_386_TLS_GOTIE:\n+\t\t    case BFD_RELOC_386_TLS_GOTDESC:\n+\t\t    case BFD_RELOC_386_TLS_DESC_CALL:\n+\t\t    case BFD_RELOC_X86_64_TLSGD:\n+\t\t    case BFD_RELOC_X86_64_TLSLD:\n+\t\t    case BFD_RELOC_X86_64_GOTTPOFF:\n+\t\t    case BFD_RELOC_X86_64_GOTPC32_TLSDESC:\n+\t\t    case BFD_RELOC_X86_64_TLSDESC_CALL:\n+\t\t      i.has_gotpc_tls_reloc = TRUE;\n+\t\t    default:\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t      fixP = fix_new_exp (frag_now, p - frag_now->fr_literal,\n \t\t\t\t  size, i.op[n].disps, pcrel,\n \t\t\t\t  reloc_type);\n@@ -8740,6 +9200,7 @@ output_imm (fragS *insn_start_frag, offsetT insn_start_off)\n \t\t    reloc_type = BFD_RELOC_X86_64_GOTPC32;\n \t\t  else if (size == 8)\n \t\t    reloc_type = BFD_RELOC_X86_64_GOTPC64;\n+\t\t  i.has_gotpc_tls_reloc = TRUE;\n \t\t  i.op[n].imms->X_add_number +=\n \t\t    encoding_length (insn_start_frag, insn_start_off, p);\n \t\t}\n@@ -10365,6 +10826,362 @@ elf_symbol_resolved_in_segment_p (symbolS *fr_symbol, offsetT fr_var)\n }\n #endif\n \n+/* Return the next non-empty frag.  */\n+\n+static fragS *\n+i386_next_non_empty_frag (fragS *fragP)\n+{\n+  /* There may be a frag with a \".fill 0\" when there is no room in\n+     the current frag for frag_grow in output_insn.  */\n+  for (fragP = fragP->fr_next;\n+       (fragP != NULL\n+\t&& fragP->fr_type == rs_fill\n+\t&& fragP->fr_fix == 0);\n+       fragP = fragP->fr_next)\n+    ;\n+  return fragP;\n+}\n+\n+/* Return the next jcc frag after BRANCH_PADDING.  */\n+\n+static fragS *\n+i386_next_jcc_frag (fragS *fragP)\n+{\n+  if (!fragP)\n+    return NULL;\n+\n+  if (fragP->fr_type == rs_machine_dependent\n+      && (TYPE_FROM_RELAX_STATE (fragP->fr_subtype)\n+\t  == BRANCH_PADDING))\n+    {\n+      fragP = i386_next_non_empty_frag (fragP);\n+      if (fragP->fr_type != rs_machine_dependent)\n+\treturn NULL;\n+      if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == COND_JUMP)\n+\treturn fragP;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Classify BRANCH_PADDING, BRANCH_PREFIX and FUSED_JCC_PADDING frags.  */\n+\n+static void\n+i386_classify_machine_dependent_frag (fragS *fragP)\n+{\n+  fragS *cmp_fragP;\n+  fragS *pad_fragP;\n+  fragS *branch_fragP;\n+  fragS *next_fragP;\n+  unsigned int max_prefix_length;\n+\n+  if (fragP->tc_frag_data.classified)\n+    return;\n+\n+  /* First scan for BRANCH_PADDING and FUSED_JCC_PADDING.  Convert\n+     FUSED_JCC_PADDING and merge BRANCH_PADDING.  */\n+  for (next_fragP = fragP;\n+       next_fragP != NULL;\n+       next_fragP = next_fragP->fr_next)\n+    {\n+      next_fragP->tc_frag_data.classified = 1;\n+      if (next_fragP->fr_type == rs_machine_dependent)\n+\tswitch (TYPE_FROM_RELAX_STATE (next_fragP->fr_subtype))\n+\t  {\n+\t  case BRANCH_PADDING:\n+\t    /* The BRANCH_PADDING frag must be followed by a branch\n+\t       frag.  */\n+\t    branch_fragP = i386_next_non_empty_frag (next_fragP);\n+\t    next_fragP->tc_frag_data.u.branch_fragP = branch_fragP;\n+\t    break;\n+\t  case FUSED_JCC_PADDING:\n+\t    /* Check if this is a fused jcc:\n+\t       FUSED_JCC_PADDING\n+\t       CMP like instruction\n+\t       BRANCH_PADDING\n+\t       COND_JUMP\n+\t       */\n+\t    cmp_fragP = i386_next_non_empty_frag (next_fragP);\n+\t    pad_fragP = i386_next_non_empty_frag (cmp_fragP);\n+\t    branch_fragP = i386_next_jcc_frag (pad_fragP);\n+\t    if (branch_fragP)\n+\t      {\n+\t\t/* The BRANCH_PADDING frag is merged with the\n+\t\t   FUSED_JCC_PADDING frag.  */\n+\t\tnext_fragP->tc_frag_data.u.branch_fragP = branch_fragP;\n+\t\t/* CMP like instruction size.  */\n+\t\tnext_fragP->tc_frag_data.cmp_size = cmp_fragP->fr_fix;\n+\t\tfrag_wane (pad_fragP);\n+\t\t/* Skip to branch_fragP.  */\n+\t\tnext_fragP = branch_fragP;\n+\t      }\n+\t    else if (next_fragP->tc_frag_data.max_prefix_length)\n+\t      {\n+\t\t/* Turn FUSED_JCC_PADDING into BRANCH_PREFIX if it isn't\n+\t\t   a fused jcc.  */\n+\t\tnext_fragP->fr_subtype\n+\t\t  = ENCODE_RELAX_STATE (BRANCH_PREFIX, 0);\n+\t\tnext_fragP->tc_frag_data.max_bytes\n+\t\t  = next_fragP->tc_frag_data.max_prefix_length;\n+\t\t/* This will be updated in the BRANCH_PREFIX scan.  */\n+\t\tnext_fragP->tc_frag_data.max_prefix_length = 0;\n+\t      }\n+\t    else\n+\t      frag_wane (next_fragP);\n+\t    break;\n+\t  }\n+    }\n+\n+  /* Stop if there is no BRANCH_PREFIX.  */\n+  if (!align_branch_prefix_size)\n+    return;\n+\n+  /* Scan for BRANCH_PREFIX.  */\n+  for (; fragP != NULL; fragP = fragP->fr_next)\n+    {\n+      if (fragP->fr_type != rs_machine_dependent\n+\t  || (TYPE_FROM_RELAX_STATE (fragP->fr_subtype)\n+\t      != BRANCH_PREFIX))\n+\tcontinue;\n+\n+      /* Count all BRANCH_PREFIX frags before BRANCH_PADDING and\n+\t COND_JUMP_PREFIX.  */\n+      max_prefix_length = 0;\n+      for (next_fragP = fragP;\n+\t   next_fragP != NULL;\n+\t   next_fragP = next_fragP->fr_next)\n+\t{\n+\t  if (next_fragP->fr_type == rs_fill)\n+\t    /* Skip rs_fill frags.  */\n+\t    continue;\n+\t  else if (next_fragP->fr_type != rs_machine_dependent)\n+\t    /* Stop for all other frags.  */\n+\t    break;\n+\n+\t  /* rs_machine_dependent frags.  */\n+\t  if (TYPE_FROM_RELAX_STATE (next_fragP->fr_subtype)\n+\t      == BRANCH_PREFIX)\n+\t    {\n+\t      /* Count BRANCH_PREFIX frags.  */\n+\t      if (max_prefix_length >= MAX_FUSED_JCC_PADDING_SIZE)\n+\t\t{\n+\t\t  max_prefix_length = MAX_FUSED_JCC_PADDING_SIZE;\n+\t\t  frag_wane (next_fragP);\n+\t\t}\n+\t      else\n+\t\tmax_prefix_length\n+\t\t  += next_fragP->tc_frag_data.max_bytes;\n+\t    }\n+\t  else if ((TYPE_FROM_RELAX_STATE (next_fragP->fr_subtype)\n+\t\t    == BRANCH_PADDING)\n+\t\t   || (TYPE_FROM_RELAX_STATE (next_fragP->fr_subtype)\n+\t\t       == FUSED_JCC_PADDING))\n+\t    {\n+\t      /* Stop at BRANCH_PADDING and FUSED_JCC_PADDING.  */\n+\t      fragP->tc_frag_data.u.padding_fragP = next_fragP;\n+\t      break;\n+\t    }\n+\t  else\n+\t    /* Stop for other rs_machine_dependent frags.  */\n+\t    break;\n+\t}\n+\n+      fragP->tc_frag_data.max_prefix_length = max_prefix_length;\n+\n+      /* Skip to the next frag.  */\n+      fragP = next_fragP;\n+    }\n+}\n+\n+/* Compute padding size for\n+\n+\tFUSED_JCC_PADDING\n+\tCMP like instruction\n+\tBRANCH_PADDING\n+\tCOND_JUMP/UNCOND_JUMP\n+\n+   or\n+\n+\tBRANCH_PADDING\n+\tCOND_JUMP/UNCOND_JUMP\n+ */\n+\n+static int\n+i386_branch_padding_size (fragS *fragP, offsetT address)\n+{\n+  unsigned int offset, size, padding_size;\n+  fragS *branch_fragP = fragP->tc_frag_data.u.branch_fragP;\n+\n+  /* The start address of the BRANCH_PADDING or FUSED_JCC_PADDING frag.  */\n+  if (!address)\n+    address = fragP->fr_address;\n+  address += fragP->fr_fix;\n+\n+  /* CMP like instrunction size.  */\n+  size = fragP->tc_frag_data.cmp_size;\n+\n+  /* The base size of the branch frag.  */\n+  size += branch_fragP->fr_fix;\n+\n+  /* Add opcode and displacement bytes for the rs_machine_dependent\n+     branch frag.  */\n+  if (branch_fragP->fr_type == rs_machine_dependent)\n+    size += md_relax_table[branch_fragP->fr_subtype].rlx_length;\n+\n+  /* Check if branch is within boundary and doesn't end at the last\n+     byte.  */\n+  offset = address & ((1U << align_branch_power) - 1);\n+  if ((offset + size) >= (1U << align_branch_power))\n+    /* Padding needed to avoid crossing boundary.  */\n+    padding_size = (1U << align_branch_power) - offset;\n+  else\n+    /* No padding needed.  */\n+    padding_size = 0;\n+\n+  /* The return value may be saved in tc_frag_data.length which is\n+     unsigned byte.  */\n+  if (!fits_in_unsigned_byte (padding_size))\n+    abort ();\n+\n+  return padding_size;\n+}\n+\n+/* i386_generic_table_relax_frag()\n+\n+   Handle BRANCH_PADDING, BRANCH_PREFIX and FUSED_JCC_PADDING frags to\n+   grow/shrink padding to align branch frags.  Hand others to\n+   relax_frag().  */\n+\n+long\n+i386_generic_table_relax_frag (segT segment, fragS *fragP, long stretch)\n+{\n+  if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == BRANCH_PADDING\n+      || TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == FUSED_JCC_PADDING)\n+    {\n+      long padding_size = i386_branch_padding_size (fragP, 0);\n+      long grow = padding_size - fragP->tc_frag_data.length;\n+\n+      /* When the BRANCH_PREFIX frag is used, the computed address\n+         must match the actual address and there should be no padding.  */\n+      if (fragP->tc_frag_data.padding_address\n+\t  && (fragP->tc_frag_data.padding_address != fragP->fr_address\n+\t      || padding_size))\n+\tabort ();\n+\n+      /* Update the padding size.  */\n+      if (grow)\n+\tfragP->tc_frag_data.length = padding_size;\n+\n+      return grow;\n+    }\n+  else if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == BRANCH_PREFIX)\n+    {\n+      fragS *padding_fragP, *next_fragP;\n+      long padding_size, left_size, last_size;\n+\n+      padding_fragP = fragP->tc_frag_data.u.padding_fragP;\n+      if (!padding_fragP)\n+\t/* Use the padding set by the leading BRANCH_PREFIX frag.  */\n+\treturn (fragP->tc_frag_data.length\n+\t\t- fragP->tc_frag_data.last_length);\n+\n+      /* Compute the relative address of the padding frag in the very\n+        first time where the BRANCH_PREFIX frag sizes are zero.  */\n+      if (!fragP->tc_frag_data.padding_address)\n+\tfragP->tc_frag_data.padding_address\n+\t  = padding_fragP->fr_address - (fragP->fr_address - stretch);\n+\n+      /* First update the last length from the previous interation.  */\n+      left_size = fragP->tc_frag_data.prefix_length;\n+      for (next_fragP = fragP;\n+\t   next_fragP != padding_fragP;\n+\t   next_fragP = next_fragP->fr_next)\n+\tif (next_fragP->fr_type == rs_machine_dependent\n+\t    && (TYPE_FROM_RELAX_STATE (next_fragP->fr_subtype)\n+\t\t== BRANCH_PREFIX))\n+\t  {\n+\t    if (left_size)\n+\t      {\n+\t\tint max = next_fragP->tc_frag_data.max_bytes;\n+\t\tif (max)\n+\t\t  {\n+\t\t    int size;\n+\t\t    if (max > left_size)\n+\t\t      size = left_size;\n+\t\t    else\n+\t\t      size = max;\n+\t\t    left_size -= size;\n+\t\t    next_fragP->tc_frag_data.last_length = size;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      next_fragP->tc_frag_data.last_length = 0;\n+\t  }\n+\n+      /* Check the padding size for the padding frag.  */\n+      padding_size = i386_branch_padding_size\n+\t(padding_fragP, (fragP->fr_address\n+\t\t\t + fragP->tc_frag_data.padding_address));\n+\n+      last_size = fragP->tc_frag_data.prefix_length;\n+      /* Check if there is change from the last interation.  */\n+      if (padding_size == last_size)\n+\t{\n+\t  /* Update the expected address of the padding frag.  */\n+\t  padding_fragP->tc_frag_data.padding_address\n+\t    = (fragP->fr_address + padding_size\n+\t       + fragP->tc_frag_data.padding_address);\n+\t  return 0;\n+\t}\n+\n+      if (padding_size > fragP->tc_frag_data.max_prefix_length)\n+\t{\n+\t  /* No padding if there is no sufficient room.  Clear the\n+\t     expected address of the padding frag.  */\n+\t  padding_fragP->tc_frag_data.padding_address = 0;\n+\t  padding_size = 0;\n+\t}\n+      else\n+\t/* Store the expected address of the padding frag.  */\n+\tpadding_fragP->tc_frag_data.padding_address\n+\t  = (fragP->fr_address + padding_size\n+\t     + fragP->tc_frag_data.padding_address);\n+\n+      fragP->tc_frag_data.prefix_length = padding_size;\n+\n+      /* Update the length for the current interation.  */\n+      left_size = padding_size;\n+      for (next_fragP = fragP;\n+\t   next_fragP != padding_fragP;\n+\t   next_fragP = next_fragP->fr_next)\n+\tif (next_fragP->fr_type == rs_machine_dependent\n+\t    && (TYPE_FROM_RELAX_STATE (next_fragP->fr_subtype)\n+\t\t== BRANCH_PREFIX))\n+\t  {\n+\t    if (left_size)\n+\t      {\n+\t\tint max = next_fragP->tc_frag_data.max_bytes;\n+\t\tif (max)\n+\t\t  {\n+\t\t    int size;\n+\t\t    if (max > left_size)\n+\t\t      size = left_size;\n+\t\t    else\n+\t\t      size = max;\n+\t\t    left_size -= size;\n+\t\t    next_fragP->tc_frag_data.length = size;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      next_fragP->tc_frag_data.length = 0;\n+\t  }\n+\n+      return (fragP->tc_frag_data.length\n+\t      - fragP->tc_frag_data.last_length);\n+    }\n+  return relax_frag (segment, fragP, stretch);\n+}\n+\n /* md_estimate_size_before_relax()\n \n    Called just before relax() for rs_machine_dependent frags.  The x86\n@@ -10381,6 +11198,14 @@ elf_symbol_resolved_in_segment_p (symbolS *fr_symbol, offsetT fr_var)\n int\n md_estimate_size_before_relax (fragS *fragP, segT segment)\n {\n+  if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == BRANCH_PADDING\n+      || TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == BRANCH_PREFIX\n+      || TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == FUSED_JCC_PADDING)\n+    {\n+      i386_classify_machine_dependent_frag (fragP);\n+      return fragP->tc_frag_data.length;\n+    }\n+\n   /* We've already got fragP->fr_subtype right;  all we have to do is\n      check for un-relaxable symbols.  On an ELF system, we can't relax\n      an externally visible symbol, because it may be overridden by a\n@@ -10514,6 +11339,106 @@ md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, segT sec ATTRIBUTE_UNUSED,\n   unsigned int extension = 0;\n   offsetT displacement_from_opcode_start;\n \n+  if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == BRANCH_PADDING\n+      || TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == FUSED_JCC_PADDING\n+      || TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == BRANCH_PREFIX)\n+    {\n+      /* Generate nop padding.  */\n+      unsigned int size = fragP->tc_frag_data.length;\n+      if (size)\n+\t{\n+\t  if (size > fragP->tc_frag_data.max_bytes)\n+\t    abort ();\n+\n+\t  if (flag_debug)\n+\t    {\n+\t      const char *msg;\n+\t      const char *branch = \"branch\";\n+\t      const char *prefix = \"\";\n+\t      fragS *padding_fragP;\n+\t      if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype)\n+\t\t  == BRANCH_PREFIX)\n+\t\t{\n+\t\t  padding_fragP = fragP->tc_frag_data.u.padding_fragP;\n+\t\t  switch (fragP->tc_frag_data.default_prefix)\n+\t\t    {\n+\t\t    default:\n+\t\t      abort ();\n+\t\t      break;\n+\t\t    case CS_PREFIX_OPCODE:\n+\t\t      prefix = \" cs\";\n+\t\t      break;\n+\t\t    case DS_PREFIX_OPCODE:\n+\t\t      prefix = \" ds\";\n+\t\t      break;\n+\t\t    case ES_PREFIX_OPCODE:\n+\t\t      prefix = \" es\";\n+\t\t      break;\n+\t\t    case FS_PREFIX_OPCODE:\n+\t\t      prefix = \" fs\";\n+\t\t      break;\n+\t\t    case GS_PREFIX_OPCODE:\n+\t\t      prefix = \" gs\";\n+\t\t      break;\n+\t\t    case SS_PREFIX_OPCODE:\n+\t\t      prefix = \" ss\";\n+\t\t      break;\n+\t\t    }\n+\t\t  if (padding_fragP)\n+\t\t    msg = _(\"%s:%u: add %d%s at 0x%llx to align \"\n+\t\t\t    \"%s within %d-byte boundary\\n\");\n+\t\t  else\n+\t\t    msg = _(\"%s:%u: add additional %d%s at 0x%llx to \"\n+\t\t\t    \"align %s within %d-byte boundary\\n\");\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  padding_fragP = fragP;\n+\t\t  msg = _(\"%s:%u: add %d%s-byte nop at 0x%llx to align \"\n+\t\t\t  \"%s within %d-byte boundary\\n\");\n+\t\t}\n+\n+\t      if (padding_fragP)\n+\t\tswitch (padding_fragP->tc_frag_data.branch_type)\n+\t\t  {\n+\t\t  case align_branch_jcc:\n+\t\t    branch = \"jcc\";\n+\t\t    break;\n+\t\t  case align_branch_fused:\n+\t\t    branch = \"fused jcc\";\n+\t\t    break;\n+\t\t  case align_branch_jmp:\n+\t\t    branch = \"jmp\";\n+\t\t    break;\n+\t\t  case align_branch_call:\n+\t\t    branch = \"call\";\n+\t\t    break;\n+\t\t  case align_branch_indirect:\n+\t\t    branch = \"indiret branch\";\n+\t\t    break;\n+\t\t  case align_branch_ret:\n+\t\t    branch = \"ret\";\n+\t\t    break;\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\n+\t      fprintf (stdout, msg,\n+\t\t       fragP->fr_file, fragP->fr_line, size, prefix,\n+\t\t       (long long) fragP->fr_address, branch,\n+\t\t       1 << align_branch_power);\n+\t    }\n+\t  if (TYPE_FROM_RELAX_STATE (fragP->fr_subtype) == BRANCH_PREFIX)\n+\t    memset (fragP->fr_opcode,\n+\t\t    fragP->tc_frag_data.default_prefix, size);\n+\t  else\n+\t    i386_generate_nops (fragP, (char *) fragP->fr_opcode,\n+\t\t\t\tsize, 0);\n+\t  fragP->fr_fix += size;\n+\t}\n+      return;\n+    }\n+\n   opcode = (unsigned char *) fragP->fr_opcode;\n \n   /* Address we want to reach in file space.  */\n@@ -11072,6 +11997,9 @@ const char *md_shortopts = \"qnO::\";\n #define OPTION_MFENCE_AS_LOCK_ADD (OPTION_MD_BASE + 24)\n #define OPTION_X86_USED_NOTE (OPTION_MD_BASE + 25)\n #define OPTION_MVEXWIG (OPTION_MD_BASE + 26)\n+#define OPTION_MALIGN_BRANCH_BOUNDARY (OPTION_MD_BASE + 27)\n+#define OPTION_MALIGN_BRANCH_PREFIX_SIZE (OPTION_MD_BASE + 28)\n+#define OPTION_MALIGN_BRANCH (OPTION_MD_BASE + 29)\n \n struct option md_longopts[] =\n {\n@@ -11107,6 +12035,9 @@ struct option md_longopts[] =\n   {\"mfence-as-lock-add\", required_argument, NULL, OPTION_MFENCE_AS_LOCK_ADD},\n   {\"mrelax-relocations\", required_argument, NULL, OPTION_MRELAX_RELOCATIONS},\n   {\"mevexrcig\", required_argument, NULL, OPTION_MEVEXRCIG},\n+  {\"malign-branch-boundary\", required_argument, NULL, OPTION_MALIGN_BRANCH_BOUNDARY},\n+  {\"malign-branch-prefix-size\", required_argument, NULL, OPTION_MALIGN_BRANCH_PREFIX_SIZE},\n+  {\"malign-branch\", required_argument, NULL, OPTION_MALIGN_BRANCH},\n   {\"mamd64\", no_argument, NULL, OPTION_MAMD64},\n   {\"mintel64\", no_argument, NULL, OPTION_MINTEL64},\n   {NULL, no_argument, NULL, 0}\n@@ -11117,7 +12048,7 @@ int\n md_parse_option (int c, const char *arg)\n {\n   unsigned int j;\n-  char *arch, *next, *saved;\n+  char *arch, *next, *saved, *type;\n \n   switch (c)\n     {\n@@ -11495,6 +12426,80 @@ md_parse_option (int c, const char *arg)\n         as_fatal (_(\"invalid -mrelax-relocations= option: `%s'\"), arg);\n       break;\n \n+    case OPTION_MALIGN_BRANCH_BOUNDARY:\n+      {\n+\tchar *end;\n+\tlong int align = strtoul (arg, &end, 0);\n+\tif (*end == '\\0')\n+\t  {\n+\t    if (align == 0)\n+\t      {\n+\t\talign_branch_power = 0;\n+\t\tbreak;\n+\t      }\n+\t    else if (align >= 16)\n+\t      {\n+\t\tint align_power;\n+\t\tfor (align_power = 0;\n+\t\t     (align & 1) == 0;\n+\t\t     align >>= 1, align_power++)\n+\t\t  continue;\n+\t\t/* Limit alignment power to 31.  */\n+\t\tif (align == 1 && align_power < 32)\n+\t\t  {\n+\t\t    align_branch_power = align_power;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n+\tas_fatal (_(\"invalid -malign-branch-boundary= value: %s\"), arg);\n+      }\n+      break;\n+\n+    case OPTION_MALIGN_BRANCH_PREFIX_SIZE:\n+      {\n+\tchar *end;\n+\tint align = strtoul (arg, &end, 0);\n+\t/* Some processors only support 5 prefixes.  */\n+\tif (*end == '\\0' && align >= 0 && align < 6)\n+\t  {\n+\t    align_branch_prefix_size = align;\n+\t    break;\n+\t  }\n+\tas_fatal (_(\"invalid -malign-branch-prefix-size= value: %s\"),\n+\t\t  arg);\n+      }\n+      break;\n+\n+    case OPTION_MALIGN_BRANCH:\n+      align_branch = 0;\n+      saved = xstrdup (arg);\n+      type = saved;\n+      do\n+\t{\n+\t  next = strchr (type, '+');\n+\t  if (next)\n+\t    *next++ = '\\0';\n+\t  if (strcasecmp (type, \"jcc\") == 0)\n+\t    align_branch |= align_branch_jcc_bit;\n+\t  else if (strcasecmp (type, \"fused\") == 0)\n+\t    align_branch |= align_branch_fused_bit;\n+\t  else if (strcasecmp (type, \"jmp\") == 0)\n+\t    align_branch |= align_branch_jmp_bit;\n+\t  else if (strcasecmp (type, \"call\") == 0)\n+\t    align_branch |= align_branch_call_bit;\n+\t  else if (strcasecmp (type, \"ret\") == 0)\n+\t    align_branch |= align_branch_ret_bit;\n+\t  else if (strcasecmp (type, \"indirect\") == 0)\n+\t    align_branch |= align_branch_indirect_bit;\n+\t  else\n+\t    as_fatal (_(\"invalid -malign-branch= option: `%s'\"), arg);\n+\t  type = next;\n+\t}\n+      while (next != NULL);\n+      free (saved);\n+      break;\n+\n     case OPTION_MAMD64:\n       intel64 = 0;\n       break;\n@@ -11747,6 +12752,17 @@ md_show_usage (FILE *stream)\n   fprintf (stream, _(\"\\\n                           generate relax relocations\\n\"));\n   fprintf (stream, _(\"\\\n+  -malign-branch-boundary=NUM (default: 0)\\n\\\n+                          align branches within NUM byte boundary\\n\"));\n+  fprintf (stream, _(\"\\\n+  -malign-branch=TYPE[+TYPE...] (default: jcc+fused+jmp)\\n\\\n+                          TYPE is combination of jcc, fused, jmp, call, ret,\\n\\\n+                           indirect\\n\\\n+                          specify types of branches to align\\n\"));\n+  fprintf (stream, _(\"\\\n+  -malign-branch-prefix-size=NUM (default: 5)\\n\\\n+                          align branches with NUM prefixes per instruction\\n\"));\n+  fprintf (stream, _(\"\\\n   -mamd64                 accept only AMD64 ISA [default]\\n\"));\n   fprintf (stream, _(\"\\\n   -mintel64               accept only Intel64 ISA\\n\"));\n@@ -11830,15 +12846,24 @@ i386_target_format (void)\n \t  {\n \t  default:\n \t    format = ELF_TARGET_FORMAT;\n+#ifndef TE_SOLARIS\n+\t    tls_get_addr = \"___tls_get_addr\";\n+#endif\n \t    break;\n \t  case X86_64_ABI:\n \t    use_rela_relocations = 1;\n \t    object_64bit = 1;\n+#ifndef TE_SOLARIS\n+\t    tls_get_addr = \"__tls_get_addr\";\n+#endif\n \t    format = ELF_TARGET_FORMAT64;\n \t    break;\n \t  case X86_64_X32_ABI:\n \t    use_rela_relocations = 1;\n \t    object_64bit = 1;\n+#ifndef TE_SOLARIS\n+\t    tls_get_addr = \"__tls_get_addr\";\n+#endif\n \t    disallow_64bit_reloc = 1;\n \t    format = ELF_TARGET_FORMAT32;\n \t    break;\n@@ -11955,6 +12980,21 @@ s_bss (int ignore ATTRIBUTE_UNUSED)\n \n #endif\n \n+/* Remember constant directive.  */\n+\n+void\n+i386_cons_align (int ignore ATTRIBUTE_UNUSED)\n+{\n+  if (last_insn.kind != last_insn_directive\n+      && (bfd_section_flags (now_seg) & SEC_CODE))\n+    {\n+      last_insn.seg = now_seg;\n+      last_insn.kind = last_insn_directive;\n+      last_insn.name = \"constant directive\";\n+      last_insn.file = as_where (&last_insn.line);\n+    }\n+}\n+\n void\n i386_validate_fix (fixS *fixp)\n {"
    },
    {
      "sha": "28f03cf2dbe21d64621489a136710e2db1717a9a",
      "filename": "gas/config/tc-i386.h",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e379e5f385f874adb0b414f917adb1fc50e20de9/gas/config/tc-i386.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e379e5f385f874adb0b414f917adb1fc50e20de9/gas/config/tc-i386.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.h?ref=e379e5f385f874adb0b414f917adb1fc50e20de9",
      "patch": "@@ -210,12 +210,19 @@ if ((n)\t\t\t\t\t\t\t\t\t\\\n \n #define MAX_MEM_FOR_RS_ALIGN_CODE  (alignment ? ((1 << alignment) - 1) : 1)\n \n+extern void i386_cons_align (int);\n+#define md_cons_align(nbytes) i386_cons_align (nbytes)\n+\n void i386_print_statistics (FILE *);\n #define tc_print_statistics i386_print_statistics\n \n extern unsigned int i386_frag_max_var (fragS *);\n #define md_frag_max_var i386_frag_max_var\n \n+extern long i386_generic_table_relax_frag (segT, fragS *, long);\n+#define md_generic_table_relax_frag(segment, fragP, stretch) \\\n+  i386_generic_table_relax_frag (segment, fragP, stretch)\n+\n #define md_number_to_chars number_to_chars_littleendian\n \n enum processor_type\n@@ -250,10 +257,24 @@ extern i386_cpu_flags cpu_arch_isa_flags;\n \n struct i386_tc_frag_data\n {\n+  union\n+    {\n+      fragS *padding_fragP;\n+      fragS *branch_fragP;\n+    } u;\n+  addressT padding_address;\n   enum processor_type isa;\n   i386_cpu_flags isa_flags;\n   enum processor_type tune;\n   unsigned int max_bytes;\n+  unsigned char length;\n+  unsigned char last_length;\n+  unsigned char max_prefix_length;\n+  unsigned char prefix_length;\n+  unsigned char default_prefix;\n+  unsigned char cmp_size;\n+  unsigned int classified : 1;\n+  unsigned int branch_type : 3;\n };\n \n /* We need to emit the right NOP pattern in .align frags.  This is\n@@ -264,10 +285,20 @@ struct i386_tc_frag_data\n #define TC_FRAG_INIT(FRAGP, MAX_BYTES)\t\t\t\t\\\n  do\t\t\t\t\t\t\t\t\\\n    {\t\t\t\t\t\t\t\t\\\n+     (FRAGP)->tc_frag_data.u.padding_fragP = NULL;\t\t\\\n+     (FRAGP)->tc_frag_data.padding_address = 0;\t\t\t\\\n      (FRAGP)->tc_frag_data.isa = cpu_arch_isa;\t\t\t\\\n      (FRAGP)->tc_frag_data.isa_flags = cpu_arch_isa_flags;\t\\\n      (FRAGP)->tc_frag_data.tune = cpu_arch_tune;\t\t\\\n      (FRAGP)->tc_frag_data.max_bytes = (MAX_BYTES);\t\t\\\n+     (FRAGP)->tc_frag_data.length = 0;\t\t\t\t\\\n+     (FRAGP)->tc_frag_data.last_length = 0;\t\t\t\\\n+     (FRAGP)->tc_frag_data.max_prefix_length = 0;\t\t\\\n+     (FRAGP)->tc_frag_data.prefix_length = 0;\t\t\t\\\n+     (FRAGP)->tc_frag_data.default_prefix = 0;\t\t\t\\\n+     (FRAGP)->tc_frag_data.cmp_size = 0;\t\t\t\\\n+     (FRAGP)->tc_frag_data.classified = 0;\t\t\t\\\n+     (FRAGP)->tc_frag_data.branch_type = 0;\t\t\t\\\n    }\t\t\t\t\t\t\t\t\\\n  while (0)\n "
    },
    {
      "sha": "74296e61f698966e92cb22a1807f576623eafad3",
      "filename": "gas/doc/c-i386.texi",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e379e5f385f874adb0b414f917adb1fc50e20de9/gas/doc/c-i386.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e379e5f385f874adb0b414f917adb1fc50e20de9/gas/doc/c-i386.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/doc/c-i386.texi?ref=e379e5f385f874adb0b414f917adb1fc50e20de9",
      "patch": "@@ -423,6 +423,32 @@ R_X86_64_REX_GOTPCRELX, in 64-bit mode.\n relocations.  The default can be controlled by a configure option\n @option{--enable-x86-relax-relocations}.\n \n+@cindex @samp{-malign-branch-boundary=} option, i386\n+@cindex @samp{-malign-branch-boundary=} option, x86-64\n+@item -malign-branch-boundary=@var{NUM}\n+This option controls how the assembler should align branches with segment\n+prefixes or NOP.  @var{NUM} must be a power of 2.  It should be 0 or\n+no less than 16.  Branches will be aligned within @var{NUM} byte\n+boundary.  @option{-malign-branch-boundary=0}, which is the default,\n+doesn't align branches.\n+\n+@cindex @samp{-malign-branch=} option, i386\n+@cindex @samp{-malign-branch=} option, x86-64\n+@item -malign-branch=@var{TYPE}[+@var{TYPE}...]\n+This option specifies types of branches to align. @var{TYPE} is\n+combination of @samp{jcc}, which aligns conditional jumps,\n+@samp{fused}, which aligns fused conditional jumps, @samp{jmp},\n+which aligns unconditional jumps, @samp{call} which aligns calls,\n+@samp{ret}, which aligns rets, @samp{indirect}, which aligns indirect\n+jumps and calls.  The default is @option{-malign-branch=jcc+fused+jmp}.\n+\n+@cindex @samp{-malign-branch-prefix-size=} option, i386\n+@cindex @samp{-malign-branch-prefix-size=} option, x86-64\n+@item -malign-branch-prefix-size=@var{NUM}\n+This option specifies the maximum number of prefixes on an instruction\n+to align branches.  @var{NUM} should be between 0 and 5.  The default\n+@var{NUM} is 5.\n+\n @cindex @samp{-mx86-used-note=} option, i386\n @cindex @samp{-mx86-used-note=} option, x86-64\n @item -mx86-used-note=@var{no}"
    }
  ]
}