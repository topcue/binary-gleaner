{
  "sha": "ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWM3ZDcxN2MxZWIyNDIxZDY0MTM1ZWYwZTZjZjE5ZGU3NGI4ZDVkMw==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-01-11T23:11:57Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-02-03T01:15:16Z"
    },
    "message": "detach with in-line step over in progress\n\nA following patch will add a testcase that has a number of threads\nconstantly stepping over a breakpoint, and then has GDB detach the\nprocess.  That testcase exercises both \"set displaced-stepping\non/off\".  Testing with \"set displaced-stepping off\" reveals that GDB\ndoes not handle the case of the user typing \"detach\" just while some\nthread is in the middle of an in-line step over.  If that thread\nbelongs to the inferior that is being detached, then the step-over\nnever finishes, and threads of other inferiors are never re-resumed.\nThis fixes it.\n\ngdb/ChangeLog:\n\n\t* infrun.c (struct step_over_info): Initialize fields.\n\t(prepare_for_detach): Handle ongoing in-line step over.",
    "tree": {
      "sha": "53a4eeb69008dd409f66134ca0e9af4b72812ee6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/53a4eeb69008dd409f66134ca0e9af4b72812ee6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e87f0fe82375ffe508da44172fcfe04e258ddc9c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e87f0fe82375ffe508da44172fcfe04e258ddc9c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e87f0fe82375ffe508da44172fcfe04e258ddc9c"
    }
  ],
  "stats": {
    "total": 50,
    "additions": 46,
    "deletions": 4
  },
  "files": [
    {
      "sha": "365d1375b9d16d36a024decd2d53531b80ce420a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3",
      "patch": "@@ -1,3 +1,8 @@\n+2021-02-03  Pedro Alves  <pedro@palves.net>\n+\n+\t* infrun.c (struct step_over_info): Initialize fields.\n+\t(prepare_for_detach): Handle ongoing in-line step over.\n+\n 2021-02-03  Pedro Alves  <pedro@palves.net>\n \n \t* linux-nat.c (linux_nat_target::detach): Remove breakpoints"
    },
    {
      "sha": "6585dddc6f8ff91c614460cb3cc6a3b889de3eb6",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 41,
      "deletions": 4,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=ac7d717c1eb2421d64135ef0e6cf19de74b8d5d3",
      "patch": "@@ -1261,15 +1261,15 @@ struct step_over_info\n      and address of the instruction the breakpoint is set at.  We'll\n      skip inserting all breakpoints here.  Valid iff ASPACE is\n      non-NULL.  */\n-  const address_space *aspace;\n-  CORE_ADDR address;\n+  const address_space *aspace = nullptr;\n+  CORE_ADDR address = 0;\n \n   /* The instruction being stepped over triggers a nonsteppable\n      watchpoint.  If true, we'll skip inserting watchpoints.  */\n-  int nonsteppable_watchpoint_p;\n+  int nonsteppable_watchpoint_p = 0;\n \n   /* The thread's global number.  */\n-  int thread;\n+  int thread = -1;\n };\n \n /* The step-over info of the location that is being stepped over.\n@@ -3566,6 +3566,7 @@ struct wait_one_event\n };\n \n static bool handle_one (const wait_one_event &event);\n+static void restart_threads (struct thread_info *event_thread);\n \n /* Prepare and stabilize the inferior for detaching it.  E.g.,\n    detaching while a thread is displaced stepping is a recipe for\n@@ -3593,6 +3594,35 @@ prepare_for_detach (void)\n \tglobal_thread_step_over_chain_remove (tp);\n     }\n \n+  /* If we were already in the middle of an inline step-over, and the\n+     thread stepping belongs to the inferior we're detaching, we need\n+     to restart the threads of other inferiors.  */\n+  if (step_over_info.thread != -1)\n+    {\n+      infrun_debug_printf (\"inline step-over in-process while detaching\");\n+\n+      thread_info *thr = find_thread_global_id (step_over_info.thread);\n+      if (thr->inf == inf)\n+\t{\n+\t  /* Since we removed threads of INF from the step-over chain,\n+\t     we know this won't start a step-over for INF.  */\n+\t  clear_step_over_info ();\n+\n+\t  if (target_is_non_stop_p ())\n+\t    {\n+\t      /* Start a new step-over in another thread if there's\n+\t\t one that needs it.  */\n+\t      start_step_over ();\n+\n+\t      /* Restart all other threads (except the\n+\t\t previously-stepping thread, since that one is still\n+\t\t running).  */\n+\t      if (!step_over_info_valid_p ())\n+\t\trestart_threads (thr);\n+\t    }\n+\t}\n+    }\n+\n   if (displaced_step_in_progress (inf))\n     {\n       infrun_debug_printf (\"displaced-stepping in-process while detaching\");\n@@ -5528,6 +5558,13 @@ restart_threads (struct thread_info *event_thread)\n \n   for (thread_info *tp : all_non_exited_threads ())\n     {\n+      if (tp->inf->detaching)\n+\t{\n+\t  infrun_debug_printf (\"restart threads: [%s] inferior detaching\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t  continue;\n+\t}\n+\n       switch_to_thread_no_regs (tp);\n \n       if (tp == event_thread)"
    }
  ]
}