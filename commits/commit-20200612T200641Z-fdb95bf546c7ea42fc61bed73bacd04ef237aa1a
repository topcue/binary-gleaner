{
  "sha": "fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmRiOTViZjU0NmM3ZWE0MmZjNjFiZWQ3M2JhY2QwNGVmMjM3YWExYQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-12T20:06:41Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-12T20:06:41Z"
    },
    "message": "gdbserver: remove support for LynxOS\n\nThis port has been unmaintained for years, remove it.\n\ngdbserver/ChangeLog:\n\n\t* configure: Re-generate.\n\t* configure.ac: Remove srv_lynxos test.\n\t* configure.srv: Remove lynxos cases.\n\t* lynx-i386-low.cc, lynx-low.cc, lynx-low.h, lynx-ppc-low.c:\n\tRemove.\n\nChange-Id: I239d1cf1fc7b4c7a174251bc7981707eaba7d972",
    "tree": {
      "sha": "616dc8cfab607b056e489b8667eb0e4d57008dd0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/616dc8cfab607b056e489b8667eb0e4d57008dd0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c00094dc7ac4a527ff23b15adc96b4750d8365d7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c00094dc7ac4a527ff23b15adc96b4750d8365d7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c00094dc7ac4a527ff23b15adc96b4750d8365d7"
    }
  ],
  "stats": {
    "total": 1417,
    "additions": 8,
    "deletions": 1409
  },
  "files": [
    {
      "sha": "c6cc5f1b1264dbc77382d3cc30c84c5ae2504d6e",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "patch": "@@ -1,3 +1,11 @@\n+2020-06-12  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* configure: Re-generate.\n+\t* configure.ac: Remove srv_lynxos test.\n+\t* configure.srv: Remove lynxos cases.\n+\t* lynx-i386-low.cc, lynx-low.cc, lynx-low.h, lynx-ppc-low.c:\n+\tRemove.\n+\n 2020-06-12  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* README: Fix a few outdated or incoherent things."
    },
    {
      "sha": "dc818736b0ec60e328368fbe38a6a9d13399f6d1",
      "filename": "gdbserver/configure",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure?ref=fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "patch": "@@ -10254,8 +10254,6 @@ elif test \"${srv_mingw}\" = \"yes\"; then\n   LIBS=\"$LIBS $WIN32APILIBS\"\n elif test \"${srv_qnx}\" = \"yes\"; then\n   LIBS=\"$LIBS -lsocket\"\n-elif test \"${srv_lynxos}\" = \"yes\"; then\n-  LIBS=\"$LIBS -lnetinet\"\n fi\n \n if test \"${srv_linux_usrregs}\" = \"yes\"; then"
    },
    {
      "sha": "0b1c81d6af541ffd770fe864b00530b76c4845d0",
      "filename": "gdbserver/configure.ac",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure.ac?ref=fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "patch": "@@ -227,8 +227,6 @@ elif test \"${srv_mingw}\" = \"yes\"; then\n   LIBS=\"$LIBS $WIN32APILIBS\"\n elif test \"${srv_qnx}\" = \"yes\"; then\n   LIBS=\"$LIBS -lsocket\"\n-elif test \"${srv_lynxos}\" = \"yes\"; then\n-  LIBS=\"$LIBS -lnetinet\"\n fi\n \n if test \"${srv_linux_usrregs}\" = \"yes\"; then"
    },
    {
      "sha": "24a9306240132ab19775b6030c4d3f3a40554e91",
      "filename": "gdbserver/configure.srv",
      "status": "modified",
      "additions": 0,
      "deletions": 13,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/configure.srv",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/configure.srv",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure.srv?ref=fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "patch": "@@ -117,12 +117,6 @@ case \"${gdbserver_host}\" in\n \t\t\tipa_obj=\"linux-i386-ipa.o linux-x86-tdesc-ipa.o\"\n \t\t\tipa_obj=\"${ipa_obj} arch/i386-ipa.o\"\n \t\t\t;;\n-  i[34567]86-*-lynxos*)\tsrv_regobj=\"\"\n-\t\t\tsrv_tgtobj=\"lynx-low.o lynx-i386-low.o fork-child.o\"\n-\t\t\tsrv_tgtobj=\"${srv_tgtobj} nat/fork-inferior.o\"\n-\t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/i386.o\"\n-\t\t\tsrv_lynxos=yes\n-\t\t\t;;\n   i[34567]86-*-mingw32ce*)\n \t\t\tsrv_regobj=\"\"\n \t\t\tsrv_tgtobj=\"x86-low.o nat/x86-dregs.o win32-low.o\"\n@@ -274,13 +268,6 @@ case \"${gdbserver_host}\" in\n \t\t\tsrv_linux_thread_db=yes\n \t\t\tipa_obj=\"${ipa_ppc_linux_regobj} linux-ppc-ipa.o\"\n \t\t\t;;\n-  powerpc-*-lynxos*)\tsrv_regobj=\"powerpc-32.o\"\n-\t\t\tsrv_tgtobj=\"lynx-low.o lynx-ppc-low.o\"\n-\t\t\tsrv_xmlfiles=\"rs6000/powerpc-32.xml\"\n-\t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/power-core.xml\"\n-\t\t\tsrv_xmlfiles=\"${srv_xmlfiles} rs6000/power-fpu.xml\"\n-\t\t\tsrv_lynxos=yes\n-\t\t\t;;\n   riscv*-*-linux*)\tsrv_tgtobj=\"arch/riscv.o nat/riscv-linux-tdesc.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} linux-riscv-low.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} ${srv_linux_obj}\""
    },
    {
      "sha": "d00e1a1677198baa2e571d61973e50dcf06093ff",
      "filename": "gdbserver/lynx-i386-low.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 358,
      "changes": 358,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c00094dc7ac4a527ff23b15adc96b4750d8365d7/gdbserver/lynx-i386-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c00094dc7ac4a527ff23b15adc96b4750d8365d7/gdbserver/lynx-i386-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/lynx-i386-low.cc?ref=c00094dc7ac4a527ff23b15adc96b4750d8365d7",
      "patch": "@@ -1,358 +0,0 @@\n-/* Copyright (C) 2010-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"server.h\"\n-#include \"lynx-low.h\"\n-#include <limits.h>\n-#include <sys/ptrace.h>\n-#include \"gdbsupport/x86-xstate.h\"\n-#include \"arch/i386.h\"\n-#include \"x86-tdesc.h\"\n-\n-/* The following two typedefs are defined in a .h file which is not\n-   in the standard include path (/sys/include/family/x86/ucontext.h),\n-   so we just duplicate them here.\n-\n-   Unfortunately for us, the definition of this structure differs between\n-   LynxOS 5.x and LynxOS 178.  Rather than duplicate the code, we use\n-   different definitions depending on the target.  */\n-\n-#ifdef VMOS_DEV\n-#define LYNXOS_178\n-#endif\n-\n-/* General register context */\n-typedef struct usr_econtext {\n-\n-    uint32_t    uec_fault;\n-    uint32_t    uec_es;\n-    uint32_t    uec_ds;\n-    uint32_t    uec_edi;\n-    uint32_t    uec_esi;\n-    uint32_t    uec_ebp;\n-    uint32_t    uec_temp;\n-    uint32_t    uec_ebx;\n-    uint32_t    uec_edx;\n-    uint32_t    uec_ecx;\n-    uint32_t    uec_eax;\n-    uint32_t    uec_inum;\n-    uint32_t    uec_ecode;\n-    uint32_t    uec_eip;\n-    uint32_t    uec_cs;\n-    uint32_t    uec_eflags;\n-    uint32_t    uec_esp;\n-    uint32_t    uec_ss;\n-    uint32_t    uec_fs;\n-    uint32_t    uec_gs;\n-} usr_econtext_t;\n-\n-#if defined(LYNXOS_178)\n-\n-/* Floating point register context                                                                                      */\n-typedef struct usr_fcontext {\n-        uint32_t         ufc_control;\n-        uint32_t         ufc_status;\n-        uint32_t         ufc_tag;\n-        uint8_t         *ufc_inst_off;\n-        uint32_t         ufc_inst_sel;\n-        uint8_t         *ufc_data_off;\n-        uint32_t         ufc_data_sel;\n-        struct ufp387_real {\n-                uint16_t        umant4;\n-        uint16_t        umant3;\n-        uint16_t        umant2;\n-        uint16_t        umant1;\n-        uint16_t        us_and_e;\n-        } ufc_reg[8];\n-} usr_fcontext_t;\n-\n-#else /* This is LynxOS 5.x.  */\n-\n-/* Floating point and SIMD register context */\n-typedef struct usr_fcontext {\n-        uint16_t         ufc_control;\n-        uint16_t         ufc_status;\n-        uint16_t         ufc_tag;\n-        uint16_t         ufc_opcode;\n-        uint8_t         *ufc_inst_off;\n-        uint32_t         ufc_inst_sel;\n-        uint8_t         *ufc_data_off;\n-        uint32_t         ufc_data_sel;\n-        uint32_t         usse_mxcsr;\n-        uint32_t         usse_mxcsr_mask;\n-        struct ufp387_real {\n-                uint16_t umant4;\n-                uint16_t umant3;\n-                uint16_t umant2;\n-                uint16_t umant1;\n-                uint16_t us_and_e;\n-                uint16_t ureserved_1;\n-                uint16_t ureserved_2;\n-                uint16_t ureserved_3;\n-        } ufc_reg[8];\n-        struct uxmm_register {\n-                uint16_t uchunk_1;\n-                uint16_t uchunk_2;\n-                uint16_t uchunk_3;\n-                uint16_t uchunk_4;\n-                uint16_t uchunk_5;\n-                uint16_t uchunk_6;\n-                uint16_t uchunk_7;\n-                uint16_t uchunk_8;\n-        } uxmm_reg[8];\n-        char ureserved[16][14];\n-} usr_fcontext_t;\n-\n-#endif\n-\n-/* The index of various registers inside the regcache.  */\n-\n-enum lynx_i386_gdb_regnum\n-{\n-  I386_EAX_REGNUM,\n-  I386_ECX_REGNUM,\n-  I386_EDX_REGNUM,\n-  I386_EBX_REGNUM,\n-  I386_ESP_REGNUM,\n-  I386_EBP_REGNUM,\n-  I386_ESI_REGNUM,\n-  I386_EDI_REGNUM,\n-  I386_EIP_REGNUM,\n-  I386_EFLAGS_REGNUM,\n-  I386_CS_REGNUM,\n-  I386_SS_REGNUM,\n-  I386_DS_REGNUM,\n-  I386_ES_REGNUM,\n-  I386_FS_REGNUM,\n-  I386_GS_REGNUM,\n-  I386_ST0_REGNUM,\n-  I386_FCTRL_REGNUM = I386_ST0_REGNUM + 8,\n-  I386_FSTAT_REGNUM,\n-  I386_FTAG_REGNUM,\n-  I386_FISEG_REGNUM,\n-  I386_FIOFF_REGNUM,\n-  I386_FOSEG_REGNUM,\n-  I386_FOOFF_REGNUM,\n-  I386_FOP_REGNUM,\n-  I386_XMM0_REGNUM = 32,\n-  I386_MXCSR_REGNUM = I386_XMM0_REGNUM + 8,\n-  I386_SENTINEL_REGUM\n-};\n-\n-/* The fill_function for the general-purpose register set.  */\n-\n-static void\n-lynx_i386_fill_gregset (struct regcache *regcache, char *buf)\n-{\n-#define lynx_i386_collect_gp(regnum, fld) \\\n-  collect_register (regcache, regnum, \\\n-                    buf + offsetof (usr_econtext_t, uec_##fld))\n-\n-  lynx_i386_collect_gp (I386_EAX_REGNUM, eax);\n-  lynx_i386_collect_gp (I386_ECX_REGNUM, ecx);\n-  lynx_i386_collect_gp (I386_EDX_REGNUM, edx);\n-  lynx_i386_collect_gp (I386_EBX_REGNUM, ebx);\n-  lynx_i386_collect_gp (I386_ESP_REGNUM, esp);\n-  lynx_i386_collect_gp (I386_EBP_REGNUM, ebp);\n-  lynx_i386_collect_gp (I386_ESI_REGNUM, esi);\n-  lynx_i386_collect_gp (I386_EDI_REGNUM, edi);\n-  lynx_i386_collect_gp (I386_EIP_REGNUM, eip);\n-  lynx_i386_collect_gp (I386_EFLAGS_REGNUM, eflags);\n-  lynx_i386_collect_gp (I386_CS_REGNUM, cs);\n-  lynx_i386_collect_gp (I386_SS_REGNUM, ss);\n-  lynx_i386_collect_gp (I386_DS_REGNUM, ds);\n-  lynx_i386_collect_gp (I386_ES_REGNUM, es);\n-  lynx_i386_collect_gp (I386_FS_REGNUM, fs);\n-  lynx_i386_collect_gp (I386_GS_REGNUM, gs);\n-}\n-\n-/* The store_function for the general-purpose register set.  */\n-\n-static void\n-lynx_i386_store_gregset (struct regcache *regcache, const char *buf)\n-{\n-#define lynx_i386_supply_gp(regnum, fld) \\\n-  supply_register (regcache, regnum, \\\n-                   buf + offsetof (usr_econtext_t, uec_##fld))\n-\n-  lynx_i386_supply_gp (I386_EAX_REGNUM, eax);\n-  lynx_i386_supply_gp (I386_ECX_REGNUM, ecx);\n-  lynx_i386_supply_gp (I386_EDX_REGNUM, edx);\n-  lynx_i386_supply_gp (I386_EBX_REGNUM, ebx);\n-  lynx_i386_supply_gp (I386_ESP_REGNUM, esp);\n-  lynx_i386_supply_gp (I386_EBP_REGNUM, ebp);\n-  lynx_i386_supply_gp (I386_ESI_REGNUM, esi);\n-  lynx_i386_supply_gp (I386_EDI_REGNUM, edi);\n-  lynx_i386_supply_gp (I386_EIP_REGNUM, eip);\n-  lynx_i386_supply_gp (I386_EFLAGS_REGNUM, eflags);\n-  lynx_i386_supply_gp (I386_CS_REGNUM, cs);\n-  lynx_i386_supply_gp (I386_SS_REGNUM, ss);\n-  lynx_i386_supply_gp (I386_DS_REGNUM, ds);\n-  lynx_i386_supply_gp (I386_ES_REGNUM, es);\n-  lynx_i386_supply_gp (I386_FS_REGNUM, fs);\n-  lynx_i386_supply_gp (I386_GS_REGNUM, gs);\n-}\n-\n-/* Extract the first 16 bits of register REGNUM in the REGCACHE,\n-   and store these 2 bytes at DEST.\n-\n-   This is useful to collect certain 16bit registers which are known\n-   by GDBserver as 32bit registers (such as the Control Register\n-   for instance).  */\n-\n-static void\n-collect_16bit_register (struct regcache *regcache, int regnum, char *dest)\n-{\n-  gdb_byte word[4];\n-\n-  collect_register (regcache, regnum, word);\n-  memcpy (dest, word, 2);\n-}\n-\n-/* The fill_function for the floating-point register set.  */\n-\n-static void\n-lynx_i386_fill_fpregset (struct regcache *regcache, char *buf)\n-{\n-  int i;\n-\n-  /* Collect %st0 .. %st7.  */\n-  for (i = 0; i < 8; i++)\n-    collect_register (regcache, I386_ST0_REGNUM + i,\n-                      buf + offsetof (usr_fcontext_t, ufc_reg)\n-\t\t      + i * sizeof (struct ufp387_real));\n-\n-  /* Collect the other FPU registers.  */\n-  collect_16bit_register (regcache, I386_FCTRL_REGNUM,\n-                          buf + offsetof (usr_fcontext_t, ufc_control));\n-  collect_16bit_register (regcache, I386_FSTAT_REGNUM,\n-                          buf + offsetof (usr_fcontext_t, ufc_status));\n-  collect_16bit_register (regcache, I386_FTAG_REGNUM,\n-                          buf + offsetof (usr_fcontext_t, ufc_tag));\n-  collect_register (regcache, I386_FISEG_REGNUM,\n-                    buf + offsetof (usr_fcontext_t, ufc_inst_sel));\n-  collect_register (regcache, I386_FIOFF_REGNUM,\n-                    buf + offsetof (usr_fcontext_t, ufc_inst_off));\n-  collect_register (regcache, I386_FOSEG_REGNUM,\n-                    buf + offsetof (usr_fcontext_t, ufc_data_sel));\n-  collect_register (regcache, I386_FOOFF_REGNUM,\n-                    buf + offsetof (usr_fcontext_t, ufc_data_off));\n-#if !defined(LYNXOS_178)\n-  collect_16bit_register (regcache, I386_FOP_REGNUM,\n-                          buf + offsetof (usr_fcontext_t, ufc_opcode));\n-\n-  /* Collect the XMM registers.  */\n-  for (i = 0; i < 8; i++)\n-    collect_register (regcache, I386_XMM0_REGNUM + i,\n-                      buf + offsetof (usr_fcontext_t, uxmm_reg)\n-\t\t      + i * sizeof (struct uxmm_register));\n-  collect_register (regcache, I386_MXCSR_REGNUM,\n-                    buf + offsetof (usr_fcontext_t, usse_mxcsr));\n-#endif\n-}\n-\n-/* This is the supply counterpart for collect_16bit_register:\n-   It extracts a 2byte value from BUF, and uses that value to\n-   set REGNUM's value in the regcache.\n-\n-   This is useful to supply the value of certain 16bit registers\n-   which are known by GDBserver as 32bit registers (such as the Control\n-   Register for instance).  */\n-\n-static void\n-supply_16bit_register (struct regcache *regcache, int regnum, const char *buf)\n-{\n-  gdb_byte word[4];\n-\n-  memcpy (word, buf, 2);\n-  memset (word + 2, 0, 2);\n-  supply_register (regcache, regnum, word);\n-}\n-\n-/* The store_function for the floating-point register set.  */\n-\n-static void\n-lynx_i386_store_fpregset (struct regcache *regcache, const char *buf)\n-{\n-  int i;\n-\n-  /* Store the %st0 .. %st7 registers.  */\n-  for (i = 0; i < 8; i++)\n-    supply_register (regcache, I386_ST0_REGNUM + i,\n-                     buf + offsetof (usr_fcontext_t, ufc_reg)\n-\t\t     + i * sizeof (struct ufp387_real));\n-\n-  /* Store the other FPU registers.  */\n-  supply_16bit_register (regcache, I386_FCTRL_REGNUM,\n-                         buf + offsetof (usr_fcontext_t, ufc_control));\n-  supply_16bit_register (regcache, I386_FSTAT_REGNUM,\n-                         buf + offsetof (usr_fcontext_t, ufc_status));\n-  supply_16bit_register (regcache, I386_FTAG_REGNUM,\n-                         buf + offsetof (usr_fcontext_t, ufc_tag));\n-  supply_register (regcache, I386_FISEG_REGNUM,\n-                   buf + offsetof (usr_fcontext_t, ufc_inst_sel));\n-  supply_register (regcache, I386_FIOFF_REGNUM,\n-                   buf + offsetof (usr_fcontext_t, ufc_inst_off));\n-  supply_register (regcache, I386_FOSEG_REGNUM,\n-                   buf + offsetof (usr_fcontext_t, ufc_data_sel));\n-  supply_register (regcache, I386_FOOFF_REGNUM,\n-                   buf + offsetof (usr_fcontext_t, ufc_data_off));\n-#if !defined(LYNXOS_178)\n-  supply_16bit_register (regcache, I386_FOP_REGNUM,\n-                         buf + offsetof (usr_fcontext_t, ufc_opcode));\n-\n-  /* Store the XMM registers.  */\n-  for (i = 0; i < 8; i++)\n-    supply_register (regcache, I386_XMM0_REGNUM + i,\n-                     buf + offsetof (usr_fcontext_t, uxmm_reg)\n-\t\t     + i * sizeof (struct uxmm_register));\n-  supply_register (regcache, I386_MXCSR_REGNUM,\n-                   buf + offsetof (usr_fcontext_t, usse_mxcsr));\n-#endif\n-}\n-\n-/* Implements the lynx_target_ops.arch_setup routine.  */\n-\n-static void\n-lynx_i386_arch_setup (void)\n-{\n-  struct target_desc *tdesc\n-    = i386_create_target_description (X86_XSTATE_SSE_MASK, false, false);\n-\n-  init_target_desc (tdesc, i386_expedite_regs);\n-\n-  lynx_tdesc = tdesc;\n-}\n-\n-/* Description of all the x86-lynx register sets.  */\n-\n-struct lynx_regset_info lynx_target_regsets[] = {\n-  /* General Purpose Registers.  */\n-  {PTRACE_GETREGS, PTRACE_SETREGS, sizeof(usr_econtext_t),\n-   lynx_i386_fill_gregset, lynx_i386_store_gregset},\n-  /* Floating Point Registers.  */\n-  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, sizeof(usr_fcontext_t),\n-    lynx_i386_fill_fpregset, lynx_i386_store_fpregset },\n-  /* End of list marker.  */\n-  {0, 0, -1, NULL, NULL }\n-};\n-\n-/* The lynx_target_ops vector for x86-lynx.  */\n-\n-struct lynx_target_ops the_low_target = {\n-  lynx_i386_arch_setup,\n-};"
    },
    {
      "sha": "a8e4e6079bd0717d46cd390d450d35888002654b",
      "filename": "gdbserver/lynx-low.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 747,
      "changes": 747,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c00094dc7ac4a527ff23b15adc96b4750d8365d7/gdbserver/lynx-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c00094dc7ac4a527ff23b15adc96b4750d8365d7/gdbserver/lynx-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/lynx-low.cc?ref=c00094dc7ac4a527ff23b15adc96b4750d8365d7",
      "patch": "@@ -1,747 +0,0 @@\n-/* Copyright (C) 2009-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"server.h\"\n-#include \"target.h\"\n-#include \"lynx-low.h\"\n-\n-#include <limits.h>\n-#include <sys/ptrace.h>\n-#include <sys/piddef.h> /* Provides PIDGET, TIDGET, BUILDPID, etc.  */\n-#include <unistd.h>\n-#include <sys/ioctl.h>\n-#include <sys/types.h>\n-#include \"gdbsupport/gdb_wait.h\"\n-#include <signal.h>\n-#include \"gdbsupport/filestuff.h\"\n-#include \"gdbsupport/common-inferior.h\"\n-#include \"nat/fork-inferior.h\"\n-\n-int using_threads = 1;\n-\n-const struct target_desc *lynx_tdesc;\n-\n-/* Per-process private data.  */\n-\n-struct process_info_private\n-{\n-  /* The PTID obtained from the last wait performed on this process.\n-     Initialized to null_ptid until the first wait is performed.  */\n-  ptid_t last_wait_event_ptid;\n-};\n-\n-/* Print a debug trace on standard output if debug_threads is set.  */\n-\n-static void\n-lynx_debug (char *string, ...)\n-{\n-  va_list args;\n-\n-  if (!debug_threads)\n-    return;\n-\n-  va_start (args, string);\n-  fprintf (stderr, \"DEBUG(lynx): \");\n-  vfprintf (stderr, string, args);\n-  fprintf (stderr, \"\\n\");\n-  va_end (args);\n-}\n-\n-/* Build a ptid_t given a PID and a LynxOS TID.  */\n-\n-static ptid_t\n-lynx_ptid_t (int pid, long tid)\n-{\n-  /* brobecker/2010-06-21: It looks like the LWP field in ptids\n-     should be distinct for each thread (see write_ptid where it\n-     writes the thread ID from the LWP).  So instead of storing\n-     the LynxOS tid in the tid field of the ptid, we store it in\n-     the lwp field.  */\n-  return ptid_t (pid, tid, 0);\n-}\n-\n-/* Return the process ID of the given PTID.\n-\n-   This function has little reason to exist, it's just a wrapper around\n-   ptid_get_pid.  But since we have a getter function for the lynxos\n-   ptid, it feels cleaner to have a getter for the pid as well.  */\n-\n-static int\n-lynx_ptid_get_pid (ptid_t ptid)\n-{\n-  return ptid.pid ();\n-}\n-\n-/* Return the LynxOS tid of the given PTID.  */\n-\n-static long\n-lynx_ptid_get_tid (ptid_t ptid)\n-{\n-  /* See lynx_ptid_t: The LynxOS tid is stored inside the lwp field\n-     of the ptid.  */\n-  return ptid.lwp ();\n-}\n-\n-/* For a given PTID, return the associated PID as known by the LynxOS\n-   ptrace layer.  */\n-\n-static int\n-lynx_ptrace_pid_from_ptid (ptid_t ptid)\n-{\n-  return BUILDPID (lynx_ptid_get_pid (ptid), lynx_ptid_get_tid (ptid));\n-}\n-\n-/* Return a string image of the ptrace REQUEST number.  */\n-\n-static char *\n-ptrace_request_to_str (int request)\n-{\n-#define CASE(X) case X: return #X\n-  switch (request)\n-    {\n-      CASE(PTRACE_TRACEME);\n-      CASE(PTRACE_PEEKTEXT);\n-      CASE(PTRACE_PEEKDATA);\n-      CASE(PTRACE_PEEKUSER);\n-      CASE(PTRACE_POKETEXT);\n-      CASE(PTRACE_POKEDATA);\n-      CASE(PTRACE_POKEUSER);\n-      CASE(PTRACE_CONT);\n-      CASE(PTRACE_KILL);\n-      CASE(PTRACE_SINGLESTEP);\n-      CASE(PTRACE_ATTACH);\n-      CASE(PTRACE_DETACH);\n-      CASE(PTRACE_GETREGS);\n-      CASE(PTRACE_SETREGS);\n-      CASE(PTRACE_GETFPREGS);\n-      CASE(PTRACE_SETFPREGS);\n-      CASE(PTRACE_READDATA);\n-      CASE(PTRACE_WRITEDATA);\n-      CASE(PTRACE_READTEXT);\n-      CASE(PTRACE_WRITETEXT);\n-      CASE(PTRACE_GETFPAREGS);\n-      CASE(PTRACE_SETFPAREGS);\n-      CASE(PTRACE_GETWINDOW);\n-      CASE(PTRACE_SETWINDOW);\n-      CASE(PTRACE_SYSCALL);\n-      CASE(PTRACE_DUMPCORE);\n-      CASE(PTRACE_SETWRBKPT);\n-      CASE(PTRACE_SETACBKPT);\n-      CASE(PTRACE_CLRBKPT);\n-      CASE(PTRACE_GET_UCODE);\n-#ifdef PT_READ_GPR\n-      CASE(PT_READ_GPR);\n-#endif\n-#ifdef PT_WRITE_GPR\n-      CASE(PT_WRITE_GPR);\n-#endif\n-#ifdef PT_READ_FPR\n-      CASE(PT_READ_FPR);\n-#endif\n-#ifdef PT_WRITE_FPR\n-      CASE(PT_WRITE_FPR);\n-#endif\n-#ifdef PT_READ_VPR\n-      CASE(PT_READ_VPR);\n-#endif\n-#ifdef PT_WRITE_VPR\n-      CASE(PT_WRITE_VPR);\n-#endif\n-#ifdef PTRACE_PEEKUSP\n-      CASE(PTRACE_PEEKUSP);\n-#endif\n-#ifdef PTRACE_POKEUSP\n-      CASE(PTRACE_POKEUSP);\n-#endif\n-      CASE(PTRACE_PEEKTHREAD);\n-      CASE(PTRACE_THREADUSER);\n-      CASE(PTRACE_FPREAD);\n-      CASE(PTRACE_FPWRITE);\n-      CASE(PTRACE_SETSIG);\n-      CASE(PTRACE_CONT_ONE);\n-      CASE(PTRACE_KILL_ONE);\n-      CASE(PTRACE_SINGLESTEP_ONE);\n-      CASE(PTRACE_GETLOADINFO);\n-      CASE(PTRACE_GETTRACESIG);\n-#ifdef PTRACE_GETTHREADLIST\n-      CASE(PTRACE_GETTHREADLIST);\n-#endif\n-    }\n-#undef CASE\n-\n-  return \"<unknown-request>\";\n-}\n-\n-/* A wrapper around ptrace that allows us to print debug traces of\n-   ptrace calls if debug traces are activated.  */\n-\n-static int\n-lynx_ptrace (int request, ptid_t ptid, int addr, int data, int addr2)\n-{\n-  int result;\n-  const int pid = lynx_ptrace_pid_from_ptid (ptid);\n-  int saved_errno;\n-\n-  if (debug_threads)\n-    fprintf (stderr, \"PTRACE (%s, pid=%d(pid=%d, tid=%d), addr=0x%x, \"\n-             \"data=0x%x, addr2=0x%x)\",\n-             ptrace_request_to_str (request), pid, PIDGET (pid), TIDGET (pid),\n-             addr, data, addr2);\n-  result = ptrace (request, pid, addr, data, addr2);\n-  saved_errno = errno;\n-  if (debug_threads)\n-    fprintf (stderr, \" -> %d (=0x%x)\\n\", result, result);\n-\n-  errno = saved_errno;\n-  return result;\n-}\n-\n-/* Call add_process with the given parameters, and initializes\n-   the process' private data.  */\n-\n-static struct process_info *\n-lynx_add_process (int pid, int attached)\n-{\n-  struct process_info *proc;\n-\n-  proc = add_process (pid, attached);\n-  proc->tdesc = lynx_tdesc;\n-  proc->priv = XCNEW (struct process_info_private);\n-  proc->priv->last_wait_event_ptid = null_ptid;\n-\n-  return proc;\n-}\n-\n-/* Callback used by fork_inferior to start tracing the inferior.  */\n-\n-static void\n-lynx_ptrace_fun ()\n-{\n-  int pgrp;\n-\n-  /* Switch child to its own process group so that signals won't\n-     directly affect GDBserver. */\n-  pgrp = getpid();\n-  if (pgrp < 0)\n-    trace_start_error_with_name (\"pgrp\");\n-  if (setpgid (0, pgrp) < 0)\n-    trace_start_error_with_name (\"setpgid\");\n-  if (ioctl (0, TIOCSPGRP, &pgrp) < 0)\n-    trace_start_error_with_name (\"ioctl\");\n-  if (lynx_ptrace (PTRACE_TRACEME, null_ptid, 0, 0, 0) < 0)\n-    trace_start_error_with_name (\"lynx_ptrace\");\n-}\n-\n-/* Implement the create_inferior method of the target_ops vector.  */\n-\n-int\n-lynx_process_target::create_inferior (const char *program,\n-\t\t\t\t      const std::vector<char *> &program_args)\n-{\n-  int pid;\n-  std::string str_program_args = construct_inferior_arguments (program_args);\n-\n-  lynx_debug (\"create_inferior ()\");\n-\n-  pid = fork_inferior (program,\n-\t\t       str_program_args.c_str (),\n-\t\t       get_environ ()->envp (), lynx_ptrace_fun,\n-\t\t       NULL, NULL, NULL, NULL);\n-\n-  post_fork_inferior (pid, program);\n-\n-  lynx_add_process (pid, 0);\n-  /* Do not add the process thread just yet, as we do not know its tid.\n-     We will add it later, during the wait for the STOP event corresponding\n-     to the lynx_ptrace (PTRACE_TRACEME) call above.  */\n-  return pid;\n-}\n-\n-/* Assuming we've just attached to a running inferior whose pid is PID,\n-   add all threads running in that process.  */\n-\n-static void\n-lynx_add_threads_after_attach (int pid)\n-{\n-  /* Ugh!  There appears to be no way to get the list of threads\n-     in the program we just attached to.  So get the list by calling\n-     the \"ps\" command.  This is only needed now, as we will then\n-     keep the thread list up to date thanks to thread creation and\n-     exit notifications.  */\n-  FILE *f;\n-  char buf[256];\n-  int thread_pid, thread_tid;\n-\n-  f = popen (\"ps atx\", \"r\");\n-  if (f == NULL)\n-    perror_with_name (\"Cannot get thread list\");\n-\n-  while (fgets (buf, sizeof (buf), f) != NULL)\n-    if ((sscanf (buf, \"%d %d\", &thread_pid, &thread_tid) == 2\n-\t && thread_pid == pid))\n-    {\n-      ptid_t thread_ptid = lynx_ptid_t (pid, thread_tid);\n-\n-      if (!find_thread_ptid (thread_ptid))\n-\t{\n-\t  lynx_debug (\"New thread: (pid = %d, tid = %d)\",\n-\t\t      pid, thread_tid);\n-\t  add_thread (thread_ptid, NULL);\n-\t}\n-    }\n-\n-  pclose (f);\n-}\n-\n-/* Implement the attach target_ops method.  */\n-\n-int\n-lynx_process_target::attach (unsigned long pid)\n-{\n-  ptid_t ptid = lynx_ptid_t (pid, 0);\n-\n-  if (lynx_ptrace (PTRACE_ATTACH, ptid, 0, 0, 0) != 0)\n-    error (\"Cannot attach to process %lu: %s (%d)\\n\", pid,\n-\t   safe_strerror (errno), errno);\n-\n-  lynx_add_process (pid, 1);\n-  lynx_add_threads_after_attach (pid);\n-\n-  return 0;\n-}\n-\n-/* Implement the resume target_ops method.  */\n-\n-void\n-lynx_process_target::resume (thread_resume *resume_info, size_t n)\n-{\n-  ptid_t ptid = resume_info[0].thread;\n-  const int request\n-    = (resume_info[0].kind == resume_step\n-       ? (n == 1 ? PTRACE_SINGLESTEP_ONE : PTRACE_SINGLESTEP)\n-       : PTRACE_CONT);\n-  const int signal = resume_info[0].sig;\n-\n-  /* If given a minus_one_ptid, then try using the current_process'\n-     private->last_wait_event_ptid.  On most LynxOS versions,\n-     using any of the process' thread works well enough, but\n-     LynxOS 178 is a little more sensitive, and triggers some\n-     unexpected signals (Eg SIG61) when we resume the inferior\n-     using a different thread.  */\n-  if (ptid == minus_one_ptid)\n-    ptid = current_process()->priv->last_wait_event_ptid;\n-\n-  /* The ptid might still be minus_one_ptid; this can happen between\n-     the moment we create the inferior or attach to a process, and\n-     the moment we resume its execution for the first time.  It is\n-     fine to use the current_thread's ptid in those cases.  */\n-  if (ptid == minus_one_ptid)\n-    ptid = ptid_of (current_thread);\n-\n-  regcache_invalidate_pid (ptid.pid ());\n-\n-  errno = 0;\n-  lynx_ptrace (request, ptid, 1, signal, 0);\n-  if (errno)\n-    perror_with_name (\"ptrace\");\n-}\n-\n-/* Resume the execution of the given PTID.  */\n-\n-static void\n-lynx_continue (ptid_t ptid)\n-{\n-  struct thread_resume resume_info;\n-\n-  resume_info.thread = ptid;\n-  resume_info.kind = resume_continue;\n-  resume_info.sig = 0;\n-\n-  lynx_resume (&resume_info, 1);\n-}\n-\n-/* A wrapper around waitpid that handles the various idiosyncrasies\n-   of LynxOS' waitpid.  */\n-\n-static int\n-lynx_waitpid (int pid, int *stat_loc)\n-{\n-  int ret = 0;\n-\n-  while (1)\n-    {\n-      ret = waitpid (pid, stat_loc, WNOHANG);\n-      if (ret < 0)\n-        {\n-\t  /* An ECHILD error is not indicative of a real problem.\n-\t     It happens for instance while waiting for the inferior\n-\t     to stop after attaching to it.  */\n-\t  if (errno != ECHILD)\n-\t    perror_with_name (\"waitpid (WNOHANG)\");\n-\t}\n-      if (ret > 0)\n-        break;\n-      /* No event with WNOHANG.  See if there is one with WUNTRACED.  */\n-      ret = waitpid (pid, stat_loc, WNOHANG | WUNTRACED);\n-      if (ret < 0)\n-        {\n-\t  /* An ECHILD error is not indicative of a real problem.\n-\t     It happens for instance while waiting for the inferior\n-\t     to stop after attaching to it.  */\n-\t  if (errno != ECHILD)\n-\t    perror_with_name (\"waitpid (WNOHANG|WUNTRACED)\");\n-\t}\n-      if (ret > 0)\n-        break;\n-      usleep (1000);\n-    }\n-  return ret;\n-}\n-\n-/* Implement the wait target_ops method.  */\n-\n-static ptid_t\n-lynx_wait_1 (ptid_t ptid, struct target_waitstatus *status, int options)\n-{\n-  int pid;\n-  int ret;\n-  int wstat;\n-  ptid_t new_ptid;\n-\n-  if (ptid == minus_one_ptid)\n-    pid = lynx_ptid_get_pid (ptid_of (current_thread));\n-  else\n-    pid = BUILDPID (lynx_ptid_get_pid (ptid), lynx_ptid_get_tid (ptid));\n-\n-retry:\n-\n-  ret = lynx_waitpid (pid, &wstat);\n-  new_ptid = lynx_ptid_t (ret, ((union wait *) &wstat)->w_tid);\n-  find_process_pid (ret)->priv->last_wait_event_ptid = new_ptid;\n-\n-  /* If this is a new thread, then add it now.  The reason why we do\n-     this here instead of when handling new-thread events is because\n-     we need to add the thread associated to the \"main\" thread - even\n-     for non-threaded applications where the new-thread events are not\n-     generated.  */\n-  if (!find_thread_ptid (new_ptid))\n-    {\n-      lynx_debug (\"New thread: (pid = %d, tid = %d)\",\n-\t\t  lynx_ptid_get_pid (new_ptid), lynx_ptid_get_tid (new_ptid));\n-      add_thread (new_ptid, NULL);\n-    }\n-\n-  if (WIFSTOPPED (wstat))\n-    {\n-      status->kind = TARGET_WAITKIND_STOPPED;\n-      status->value.integer = gdb_signal_from_host (WSTOPSIG (wstat));\n-      lynx_debug (\"process stopped with signal: %d\",\n-                  status->value.integer);\n-    }\n-  else if (WIFEXITED (wstat))\n-    {\n-      status->kind = TARGET_WAITKIND_EXITED;\n-      status->value.integer = WEXITSTATUS (wstat);\n-      lynx_debug (\"process exited with code: %d\", status->value.integer);\n-    }\n-  else if (WIFSIGNALED (wstat))\n-    {\n-      status->kind = TARGET_WAITKIND_SIGNALLED;\n-      status->value.integer = gdb_signal_from_host (WTERMSIG (wstat));\n-      lynx_debug (\"process terminated with code: %d\",\n-                  status->value.integer);\n-    }\n-  else\n-    {\n-      /* Not sure what happened if we get here, or whether we can\n-\t in fact get here.  But if we do, handle the event the best\n-\t we can.  */\n-      status->kind = TARGET_WAITKIND_STOPPED;\n-      status->value.integer = gdb_signal_from_host (0);\n-      lynx_debug (\"unknown event ????\");\n-    }\n-\n-  /* SIGTRAP events are generated for situations other than single-step/\n-     breakpoint events (Eg. new-thread events).  Handle those other types\n-     of events, and resume the execution if necessary.  */\n-  if (status->kind == TARGET_WAITKIND_STOPPED\n-      && status->value.integer == GDB_SIGNAL_TRAP)\n-    {\n-      const int realsig = lynx_ptrace (PTRACE_GETTRACESIG, new_ptid, 0, 0, 0);\n-\n-      lynx_debug (\"(realsig = %d)\", realsig);\n-      switch (realsig)\n-\t{\n-\t  case SIGNEWTHREAD:\n-\t    /* We just added the new thread above.  No need to do anything\n-\t       further.  Just resume the execution again.  */\n-\t    lynx_continue (new_ptid);\n-\t    goto retry;\n-\n-\t  case SIGTHREADEXIT:\n-\t    remove_thread (find_thread_ptid (new_ptid));\n-\t    lynx_continue (new_ptid);\n-\t    goto retry;\n-\t}\n-    }\n-\n-  return new_ptid;\n-}\n-\n-/* A wrapper around lynx_wait_1 that also prints debug traces when\n-   such debug traces have been activated.  */\n-\n-ptid_t\n-lynx_process_target::wait (ptid_t ptid, target_waitstatus *status,\n-\t\t\t   int options)\n-{\n-  ptid_t new_ptid;\n-\n-  lynx_debug (\"wait (pid = %d, tid = %ld)\",\n-              lynx_ptid_get_pid (ptid), lynx_ptid_get_tid (ptid));\n-  new_ptid = lynx_wait_1 (ptid, status, options);\n-  lynx_debug (\"          -> (pid=%d, tid=%ld, status->kind = %d)\",\n-\t      lynx_ptid_get_pid (new_ptid), lynx_ptid_get_tid (new_ptid),\n-\t      status->kind);\n-  return new_ptid;\n-}\n-\n-/* Implement the kill target_ops method.  */\n-\n-int\n-lynx_process_target::kill (process_info *process)\n-{\n-  ptid_t ptid = lynx_ptid_t (process->pid, 0);\n-  struct target_waitstatus status;\n-\n-  lynx_ptrace (PTRACE_KILL, ptid, 0, 0, 0);\n-  lynx_wait (ptid, &status, 0);\n-  mourn (process);\n-  return 0;\n-}\n-\n-/* Implement the detach target_ops method.  */\n-\n-int\n-lynx_process_target::detach (process_info *process)\n-{\n-  ptid_t ptid = lynx_ptid_t (process->pid, 0);\n-\n-  lynx_ptrace (PTRACE_DETACH, ptid, 0, 0, 0);\n-  mourn (process);\n-  return 0;\n-}\n-\n-/* Implement the mourn target_ops method.  */\n-\n-void\n-lynx_process_target::mourn (struct process_info *proc)\n-{\n-  for_each_thread (proc->pid, remove_thread);\n-\n-  /* Free our private data.  */\n-  free (proc->priv);\n-  proc->priv = NULL;\n-\n-  remove_process (proc);\n-}\n-\n-/* Implement the join target_ops method.  */\n-\n-void\n-lynx_process_target::join (int pid)\n-{\n-  /* The PTRACE_DETACH is sufficient to detach from the process.\n-     So no need to do anything extra.  */\n-}\n-\n-/* Implement the thread_alive target_ops method.  */\n-\n-bool\n-lynx_process_target::thread_alive (ptid_t ptid)\n-{\n-  /* The list of threads is updated at the end of each wait, so it\n-     should be up to date.  No need to re-fetch it.  */\n-  return (find_thread_ptid (ptid) != NULL);\n-}\n-\n-/* Implement the fetch_registers target_ops method.  */\n-\n-void\n-lynx_process_target::fetch_registers (regcache *regcache, int regno)\n-{\n-  struct lynx_regset_info *regset = lynx_target_regsets;\n-  ptid_t inferior_ptid = ptid_of (current_thread);\n-\n-  lynx_debug (\"fetch_registers (regno = %d)\", regno);\n-\n-  while (regset->size >= 0)\n-    {\n-      char *buf;\n-      int res;\n-\n-      buf = xmalloc (regset->size);\n-      res = lynx_ptrace (regset->get_request, inferior_ptid, (int) buf, 0, 0);\n-      if (res < 0)\n-        perror (\"ptrace\");\n-      regset->store_function (regcache, buf);\n-      free (buf);\n-      regset++;\n-    }\n-}\n-\n-/* Implement the store_registers target_ops method.  */\n-\n-void\n-lynx_process_target::store_registers (regcache *regcache, int regno)\n-{\n-  struct lynx_regset_info *regset = lynx_target_regsets;\n-  ptid_t inferior_ptid = ptid_of (current_thread);\n-\n-  lynx_debug (\"store_registers (regno = %d)\", regno);\n-\n-  while (regset->size >= 0)\n-    {\n-      char *buf;\n-      int res;\n-\n-      buf = xmalloc (regset->size);\n-      res = lynx_ptrace (regset->get_request, inferior_ptid, (int) buf, 0, 0);\n-      if (res == 0)\n-        {\n-\t  /* Then overlay our cached registers on that.  */\n-\t  regset->fill_function (regcache, buf);\n-\t  /* Only now do we write the register set.  */\n-\t  res = lynx_ptrace (regset->set_request, inferior_ptid, (int) buf,\n-\t\t\t     0, 0);\n-        }\n-      if (res < 0)\n-        perror (\"ptrace\");\n-      free (buf);\n-      regset++;\n-    }\n-}\n-\n-/* Implement the read_memory target_ops method.  */\n-\n-int\n-lynx_process_target::read_memory (CORE_ADDR memaddr, unsigned char *myaddr,\n-\t\t\t\t  int len)\n-{\n-  /* On LynxOS, memory reads needs to be performed in chunks the size\n-     of int types, and they should also be aligned accordingly.  */\n-  int buf;\n-  const int xfer_size = sizeof (buf);\n-  CORE_ADDR addr = memaddr & -(CORE_ADDR) xfer_size;\n-  ptid_t inferior_ptid = ptid_of (current_thread);\n-\n-  while (addr < memaddr + len)\n-    {\n-      int skip = 0;\n-      int truncate = 0;\n-\n-      errno = 0;\n-      if (addr < memaddr)\n-        skip = memaddr - addr;\n-      if (addr + xfer_size > memaddr + len)\n-        truncate = addr + xfer_size - memaddr - len;\n-      buf = lynx_ptrace (PTRACE_PEEKTEXT, inferior_ptid, addr, 0, 0);\n-      if (errno)\n-        return errno;\n-      memcpy (myaddr + (addr - memaddr) + skip, (gdb_byte *) &buf + skip,\n-              xfer_size - skip - truncate);\n-      addr += xfer_size;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Implement the write_memory target_ops method.  */\n-\n-int\n-lynx_process_target::write_memory (CORE_ADDR memaddr,\n-\t\t\t\t   const unsigned char *myaddr, int len)\n-{\n-  /* On LynxOS, memory writes needs to be performed in chunks the size\n-     of int types, and they should also be aligned accordingly.  */\n-  int buf;\n-  const int xfer_size = sizeof (buf);\n-  CORE_ADDR addr = memaddr & -(CORE_ADDR) xfer_size;\n-  ptid_t inferior_ptid = ptid_of (current_thread);\n-\n-  while (addr < memaddr + len)\n-    {\n-      int skip = 0;\n-      int truncate = 0;\n-\n-      if (addr < memaddr)\n-        skip = memaddr - addr;\n-      if (addr + xfer_size > memaddr + len)\n-        truncate = addr + xfer_size - memaddr - len;\n-      if (skip > 0 || truncate > 0)\n-\t{\n-\t  /* We need to read the memory at this address in order to preserve\n-\t     the data that we are not overwriting.  */\n-\t  read_memory (addr, (unsigned char *) &buf, xfer_size);\n-\t  if (errno)\n-\t    return errno;\n-\t}\n-      memcpy ((gdb_byte *) &buf + skip, myaddr + (addr - memaddr) + skip,\n-              xfer_size - skip - truncate);\n-      errno = 0;\n-      lynx_ptrace (PTRACE_POKETEXT, inferior_ptid, addr, buf, 0);\n-      if (errno)\n-        return errno;\n-      addr += xfer_size;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Implement the kill_request target_ops method.  */\n-\n-void\n-lynx_process_target::request_interrupt ()\n-{\n-  ptid_t inferior_ptid = ptid_of (get_first_thread ());\n-\n-  kill (lynx_ptid_get_pid (inferior_ptid), SIGINT);\n-}\n-\n-bool\n-lynx_process_target::supports_hardware_single_step ()\n-{\n-  return true;\n-}\n-\n-const gdb_byte *\n-lynx_process_target::sw_breakpoint_from_kind (int kind, int *size)\n-{\n-  error (_(\"Target does not implement the sw_breakpoint_from_kind op\"));\n-}\n-\n-/* The LynxOS target ops object.  */\n-\n-static lynx_process_target the_lynx_target;\n-\n-void\n-initialize_low (void)\n-{\n-  set_target_ops (&the_lynx_target);\n-  the_low_target.arch_setup ();\n-}\n-"
    },
    {
      "sha": "fa975a21f30cbf42eec06e3f62abfdda6f744390",
      "filename": "gdbserver/lynx-low.h",
      "status": "removed",
      "additions": 0,
      "deletions": 102,
      "changes": 102,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c00094dc7ac4a527ff23b15adc96b4750d8365d7/gdbserver/lynx-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c00094dc7ac4a527ff23b15adc96b4750d8365d7/gdbserver/lynx-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/lynx-low.h?ref=c00094dc7ac4a527ff23b15adc96b4750d8365d7",
      "patch": "@@ -1,102 +0,0 @@\n-/* Copyright (C) 2010-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GDBSERVER_LYNX_LOW_H\n-#define GDBSERVER_LYNX_LOW_H\n-\n-struct regcache;\n-struct target_desc;\n-\n-/*  Some information relative to a given register set.   */\n-\n-struct lynx_regset_info\n-{\n-  /* The ptrace request needed to get/set registers of this set.  */\n-  int get_request, set_request;\n-  /* The size of the register set.  */\n-  int size;\n-  /* Fill the buffer BUF from the contents of the given REGCACHE.  */\n-  void (*fill_function) (struct regcache *regcache, char *buf);\n-  /* Store the register value in BUF in the given REGCACHE.  */\n-  void (*store_function) (struct regcache *regcache, const char *buf);\n-};\n-\n-/* A list of regsets for the target being debugged, terminated by an entry\n-   where the size is negative.\n-\n-   This list should be created by the target-specific code.  */\n-\n-extern struct lynx_regset_info lynx_target_regsets[];\n-\n-/* The target-specific operations for LynxOS support.  */\n-\n-struct lynx_target_ops\n-{\n-  /* Architecture-specific setup.  */\n-  void (*arch_setup) (void);\n-};\n-\n-extern struct lynx_target_ops the_low_target;\n-\n-/* Target ops definitions for a LynxOS target.  */\n-\n-class lynx_process_target : public process_stratum_target\n-{\n-public:\n-\n-  int create_inferior (const char *program,\n-\t\t       const std::vector<char *> &program_args) override;\n-\n-  int attach (unsigned long pid) override;\n-\n-  int kill (process_info *proc) override;\n-\n-  int detach (process_info *proc) override;\n-\n-  void mourn (process_info *proc) override;\n-\n-  void join (int pid) override;\n-\n-  bool thread_alive (ptid_t pid) override;\n-\n-  void resume (thread_resume *resume_info, size_t n) override;\n-\n-  ptid_t wait (ptid_t ptid, target_waitstatus *status,\n-\t       int options) override;\n-\n-  void fetch_registers (regcache *regcache, int regno) override;\n-\n-  void store_registers (regcache *regcache, int regno) override;\n-\n-  int read_memory (CORE_ADDR memaddr, unsigned char *myaddr,\n-\t\t   int len) override;\n-\n-  int write_memory (CORE_ADDR memaddr, const unsigned char *myaddr,\n-\t\t    int len) override;\n-\n-  void request_interrupt () override;\n-\n-  bool supports_hardware_single_step () override;\n-\n-  const gdb_byte *sw_breakpoint_from_kind (int kind, int *size) override;\n-};\n-\n-/* The inferior's target description.  This is a global because the\n-   LynxOS ports support neither bi-arch nor multi-process.  */\n-extern const struct target_desc *lynx_tdesc;\n-\n-#endif /* GDBSERVER_LYNX_LOW_H */"
    },
    {
      "sha": "f93fc1d8d87f03790cd422647b59ca545a1d4026",
      "filename": "gdbserver/lynx-ppc-low.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 185,
      "changes": 185,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c00094dc7ac4a527ff23b15adc96b4750d8365d7/gdbserver/lynx-ppc-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c00094dc7ac4a527ff23b15adc96b4750d8365d7/gdbserver/lynx-ppc-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/lynx-ppc-low.cc?ref=c00094dc7ac4a527ff23b15adc96b4750d8365d7",
      "patch": "@@ -1,185 +0,0 @@\n-/* Copyright (C) 2009-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"server.h\"\n-#include \"lynx-low.h\"\n-#include <limits.h>\n-#include <sys/ptrace.h>\n-\n-/* The following two typedefs are defined in a .h file which is not\n-   in the standard include path (/sys/include/family/ppc/ucontext.h),\n-   so we just duplicate them here.  */\n-\n-/* General register context */\n-typedef struct usr_econtext_s\n-{\n-        uint32_t        uec_iregs[32];\n-        uint32_t        uec_inum;\n-        uint32_t        uec_srr0;\n-        uint32_t        uec_srr1;\n-        uint32_t        uec_lr;\n-        uint32_t        uec_ctr;\n-        uint32_t        uec_cr;\n-        uint32_t        uec_xer;\n-        uint32_t        uec_dar;\n-        uint32_t        uec_mq;\n-        uint32_t        uec_msr;\n-        uint32_t        uec_sregs[16];\n-        uint32_t        uec_ss_count;\n-        uint32_t        uec_ss_addr1;\n-        uint32_t        uec_ss_addr2;\n-        uint32_t        uec_ss_code1;\n-        uint32_t        uec_ss_code2;\n-} usr_econtext_t;\n-\n-/* Floating point register context */\n-typedef struct usr_fcontext_s\n-{\n-        uint64_t        ufc_freg[32];\n-        uint32_t        ufc_fpscr[2];\n-} usr_fcontext_t;\n-\n-/* Index of for various registers inside the regcache.  */\n-#define R0_REGNUM    0\n-#define F0_REGNUM    32\n-#define PC_REGNUM    64\n-#define MSR_REGNUM   65\n-#define CR_REGNUM    66\n-#define LR_REGNUM    67\n-#define CTR_REGNUM   68\n-#define XER_REGNUM   69\n-#define FPSCR_REGNUM 70\n-\n-/* Defined in auto-generated file powerpc-32.c.  */\n-extern void init_registers_powerpc_32 (void);\n-extern const struct target_desc *tdesc_powerpc_32;\n-\n-/* The fill_function for the general-purpose register set.  */\n-\n-static void\n-lynx_ppc_fill_gregset (struct regcache *regcache, char *buf)\n-{\n-  int i;\n-\n-  /* r0 - r31 */\n-  for (i = 0; i < 32; i++)\n-    collect_register (regcache, R0_REGNUM + i,\n-                      buf + offsetof (usr_econtext_t, uec_iregs[i]));\n-\n-  /* The other registers provided in the GP register context.  */\n-  collect_register (regcache, PC_REGNUM,\n-                    buf + offsetof (usr_econtext_t, uec_srr0));\n-  collect_register (regcache, MSR_REGNUM,\n-                    buf + offsetof (usr_econtext_t, uec_srr1));\n-  collect_register (regcache, CR_REGNUM,\n-                    buf + offsetof (usr_econtext_t, uec_cr));\n-  collect_register (regcache, LR_REGNUM,\n-                    buf + offsetof (usr_econtext_t, uec_lr));\n-  collect_register (regcache, CTR_REGNUM,\n-                    buf + offsetof (usr_econtext_t, uec_ctr));\n-  collect_register (regcache, XER_REGNUM,\n-                    buf + offsetof (usr_econtext_t, uec_xer));\n-}\n-\n-/* The store_function for the general-purpose register set.  */\n-\n-static void\n-lynx_ppc_store_gregset (struct regcache *regcache, const char *buf)\n-{\n-  int i;\n-\n-  /* r0 - r31 */\n-  for (i = 0; i < 32; i++)\n-    supply_register (regcache, R0_REGNUM + i,\n-                      buf + offsetof (usr_econtext_t, uec_iregs[i]));\n-\n-  /* The other registers provided in the GP register context.  */\n-  supply_register (regcache, PC_REGNUM,\n-                   buf + offsetof (usr_econtext_t, uec_srr0));\n-  supply_register (regcache, MSR_REGNUM,\n-                   buf + offsetof (usr_econtext_t, uec_srr1));\n-  supply_register (regcache, CR_REGNUM,\n-                   buf + offsetof (usr_econtext_t, uec_cr));\n-  supply_register (regcache, LR_REGNUM,\n-                   buf + offsetof (usr_econtext_t, uec_lr));\n-  supply_register (regcache, CTR_REGNUM,\n-                   buf + offsetof (usr_econtext_t, uec_ctr));\n-  supply_register (regcache, XER_REGNUM,\n-                   buf + offsetof (usr_econtext_t, uec_xer));\n-}\n-\n-/* The fill_function for the floating-point register set.  */\n-\n-static void\n-lynx_ppc_fill_fpregset (struct regcache *regcache, char *buf)\n-{\n-  int i;\n-\n-  /* f0 - f31 */\n-  for (i = 0; i < 32; i++)\n-    collect_register (regcache, F0_REGNUM + i,\n-                      buf + offsetof (usr_fcontext_t, ufc_freg[i]));\n-\n-  /* fpscr */\n-  collect_register (regcache, FPSCR_REGNUM,\n-                    buf + offsetof (usr_fcontext_t, ufc_fpscr));\n-}\n-\n-/* The store_function for the floating-point register set.  */\n-\n-static void\n-lynx_ppc_store_fpregset (struct regcache *regcache, const char *buf)\n-{\n-  int i;\n-\n-  /* f0 - f31 */\n-  for (i = 0; i < 32; i++)\n-    supply_register (regcache, F0_REGNUM + i,\n-                     buf + offsetof (usr_fcontext_t, ufc_freg[i]));\n-\n-  /* fpscr */\n-  supply_register (regcache, FPSCR_REGNUM,\n-                   buf + offsetof (usr_fcontext_t, ufc_fpscr));\n-}\n-\n-/* Implements the lynx_target_ops.arch_setup routine.  */\n-\n-static void\n-lynx_ppc_arch_setup (void)\n-{\n-  init_registers_powerpc_32 ();\n-  lynx_tdesc = tdesc_powerpc_32;\n-}\n-\n-/* Description of all the powerpc-lynx register sets.  */\n-\n-struct lynx_regset_info lynx_target_regsets[] = {\n-  /* General Purpose Registers.  */\n-  {PTRACE_GETREGS, PTRACE_SETREGS, sizeof(usr_econtext_t),\n-   lynx_ppc_fill_gregset, lynx_ppc_store_gregset},\n-  /* Floating Point Registers.  */\n-  { PTRACE_GETFPREGS, PTRACE_SETFPREGS, sizeof(usr_fcontext_t),\n-    lynx_ppc_fill_fpregset, lynx_ppc_store_fpregset },\n-  /* End of list marker.  */\n-  {0, 0, -1, NULL, NULL }\n-};\n-\n-/* The lynx_target_ops vector for powerpc-lynxos.  */\n-\n-struct lynx_target_ops the_low_target = {\n-  lynx_ppc_arch_setup,\n-};"
    }
  ]
}