{
  "sha": "82a5082ed3f00b8d7bd1e3810c6eeb4351e35286",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODJhNTA4MmVkM2YwMGI4ZDdiZDFlMzgxMGM2ZWViNDM1MWUzNTI4Ng==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-06-17T10:57:56Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-06-17T10:57:56Z"
    },
    "message": "Make the TUI command window support the mouse\n\nCurrently, when the focus is on the command window, we disable the\nkeypad.  This means that when the command window has the focus, keys\nsuch as up/down/home/end etc. are not processed by curses, and their\nescape sequences go straight to readline.\n\nA side effect of disabling keypad mode is that wgetch no longer\nprocesses mouse escape sequences, with the end result being the mouse\ndoesn't work, and worse, the raw mouse escape sequences are printed on\nthe terminal.\n\nThis commit makes the TUI command window support the mouse as well, by\nalways enabling the keypad, and then to avoid losing support for\nup/down browsing the command history, home/end/left/right moving the\ncursor position, etc., we forward those keys as raw escape sequences\nto readline.  Note we don't make an effort to pass down to readline\nall keys returned by curses, only the common ones that readline\nunderstands by default.  Given users can specify their own readline\nbindings (inputrc file, bind utility), this approach is good in\npractice, though not 100% transparent or perfect.\n\nNote that the patch makes it so that CTLC-L is always passed to\nreadline even if the command window does not have the focus.  It was\nsimpler to implement that way, and it just seems correct to me.  I\ndon't know of a reason we shouldn't do that.\n\nThe patch improves the TUI behavior in a related way.  Now we can pass\nspecial keys to readline irrespective of which window has the focus.\nFirst, we try to dispatch the key to a window, via\ntui_displatch_ctrl_char.  If the key is dispatched, then we don't pass\nit to readline.  E.g., pressing \"up\" when you have the source window\nin focus results in scrolling the source window, and nothing else.  If\nhowever, you press ctrl-del instead, that results in killing the next\nword in the command window, no matter which window has has focus.\nBefore, it would only work if you had the command window in focus.\nSimilarly, ctrl-left/ctrl-right to move between words, etc.\n\nSimilarly, the previous spot where we handled mouse events was\nincorrect.  It was never reached if the window with focus can't\nscroll, which is the case for the command window.  Mouse scrolling\naffects the window under the mouse cursor, not the window in focus.\nWe now always try to dispatch mouse events.\n\nOne last bit in the patch -- now if we don't recognize the non-8-bit\ncurses key, then we don't pass it down to readline at all.  Before\nthat would result in bogus characters in the input line.\n\ngdb/ChangeLog:\nyyyy-mm-dd  Pedro Alves  <pedro@palves.net>\n\n\t* tui/tui-io.c (tui_dispatch_mouse_event): New, factored out from\n\t...\n\t(tui_dispatch_ctrl_char): ... this.  Move CTRL-L handling to\n\ttui_getc_1.\n\t(cur_seq, start_sequence): New.\n\t(tui_getc_1): Pass key escape sequences for curses control keys to\n\treadline.  Handle mouse and ctrl-l here.\n\t(tui_resize_all): Disable/reenable the keypad if the command\n\twindow has the focus too.\n\t* tui/tui-win.c (tui_set_focus_command): Don't change keypad\n\tsetting.\n\t* tui/tui.c (tui_rl_other_window): Don't change keypad setting.\n\nChange-Id: Ie0a7d849943cfb47f4a6589e1c73341563740fa9",
    "tree": {
      "sha": "3338caad52b5f5cb9d272de8a9f5e78035781ca5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3338caad52b5f5cb9d272de8a9f5e78035781ca5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3478a63d7ed68d666f842f5b8fb5bdade619c817",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3478a63d7ed68d666f842f5b8fb5bdade619c817",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3478a63d7ed68d666f842f5b8fb5bdade619c817"
    }
  ],
  "stats": {
    "total": 238,
    "additions": 186,
    "deletions": 52
  },
  "files": [
    {
      "sha": "497d9f6aee48b3a5c9b864194659919a269a2574",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=82a5082ed3f00b8d7bd1e3810c6eeb4351e35286",
      "patch": "@@ -1,3 +1,18 @@\n+2021-06-17  Pedro Alves  <pedro@palves.net>\n+\n+\t* tui/tui-io.c (tui_dispatch_mouse_event): New, factored out from\n+\t...\n+\t(tui_dispatch_ctrl_char): ... this.  Move CTRL-L handling to\n+\ttui_getc_1.\n+\t(cur_seq, start_sequence): New.\n+\t(tui_getc_1): Pass key escape sequences for curses control keys to\n+\treadline.  Handle mouse and ctrl-l here.\n+\t(tui_resize_all): Disable/reenable the keypad if the command\n+\twindow has the focus too.\n+\t* tui/tui-win.c (tui_set_focus_command): Don't change keypad\n+\tsetting.\n+\t* tui/tui.c (tui_rl_other_window): Don't change keypad setting.\n+\n 2021-06-16  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* silent-rules.mk (ECHO_CCLD, ECHO_AR, ECHO_RANLIB): New."
    },
    {
      "sha": "bd443dc0c0c76f4ccade59acb0655e0c612594cb",
      "filename": "gdb/tui/tui-io.c",
      "status": "modified",
      "additions": 167,
      "deletions": 39,
      "changes": 206,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/gdb/tui/tui-io.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/gdb/tui/tui-io.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-io.c?ref=82a5082ed3f00b8d7bd1e3810c6eeb4351e35286",
      "patch": "@@ -946,17 +946,49 @@ tui_initialize_io (void)\n #endif\n }\n \n+/* Dispatch the correct tui function based upon the mouse event.  */\n+\n+#ifdef NCURSES_MOUSE_VERSION\n+\n+static void\n+tui_dispatch_mouse_event ()\n+{\n+  MEVENT mev;\n+  if (getmouse (&mev) != OK)\n+    return;\n+\n+  for (tui_win_info *wi : all_tui_windows ())\n+    if (mev.x > wi->x && mev.x < wi->x + wi->width - 1\n+\t&& mev.y > wi->y && mev.y < wi->y + wi->height - 1)\n+      {\n+\tif ((mev.bstate & BUTTON1_CLICKED) != 0\n+\t    || (mev.bstate & BUTTON2_CLICKED) != 0\n+\t    || (mev.bstate & BUTTON3_CLICKED) != 0)\n+\t  {\n+\t    int button = (mev.bstate & BUTTON1_CLICKED) != 0 ? 1\n+\t      :         ((mev.bstate & BUTTON2_CLICKED) != 0 ? 2\n+\t\t\t : 3);\n+\t    wi->click (mev.x - wi->x - 1, mev.y - wi->y - 1, button);\n+\t  }\n+#ifdef BUTTON5_PRESSED\n+\telse if ((mev.bstate & BUTTON4_PRESSED) != 0)\n+\t  wi->backward_scroll (3);\n+\telse if ((mev.bstate & BUTTON5_PRESSED) != 0)\n+\t  wi->forward_scroll (3);\n+#endif\n+\tbreak;\n+      }\n+}\n+\n+#endif\n+\n /* Dispatch the correct tui function based upon the control\n    character.  */\n static unsigned int\n tui_dispatch_ctrl_char (unsigned int ch)\n {\n   struct tui_win_info *win_info = tui_win_with_focus ();\n \n-  /* Handle the CTRL-L refresh for each window.  */\n-  if (ch == '\\f')\n-    tui_refresh_all_win ();\n-\n   /* If no window has the focus, or if the focus window can't scroll,\n      just pass the character through.  */\n   if (win_info == NULL || !win_info->can_scroll ())\n@@ -984,39 +1016,6 @@ tui_dispatch_ctrl_char (unsigned int ch)\n     case KEY_LEFT:\n       win_info->right_scroll (1);\n       break;\n-#ifdef NCURSES_MOUSE_VERSION\n-    case KEY_MOUSE:\n-\t{\n-\t  MEVENT mev;\n-\t  if (getmouse (&mev) != OK)\n-\t    break;\n-\n-\t  for (tui_win_info *wi : all_tui_windows ())\n-\t    if (mev.x > wi->x && mev.x < wi->x + wi->width - 1\n-\t\t&& mev.y > wi->y && mev.y < wi->y + wi->height - 1)\n-\t      {\n-\t\tif ((mev.bstate & BUTTON1_CLICKED) != 0\n-\t\t    || (mev.bstate & BUTTON2_CLICKED) != 0\n-\t\t    || (mev.bstate & BUTTON3_CLICKED) != 0)\n-\t\t  {\n-\t\t    int button = (mev.bstate & BUTTON1_CLICKED) != 0 ? 1\n-\t\t      :         ((mev.bstate & BUTTON2_CLICKED) != 0 ? 2\n-\t\t\t\t : 3);\n-\t\t    wi->click (mev.x - wi->x - 1, mev.y - wi->y - 1, button);\n-\t\t  }\n-#ifdef BUTTON5_PRESSED\n-\t\telse if ((mev.bstate & BUTTON4_PRESSED) != 0)\n-\t\t  wi->backward_scroll (3);\n-\t\telse if ((mev.bstate & BUTTON5_PRESSED) != 0)\n-\t\t  wi->forward_scroll (3);\n-#endif\n-\t\tbreak;\n-\t      }\n-\t}\n-      break;\n-#endif\n-    case '\\f':\n-      break;\n     default:\n       /* We didn't recognize the character as a control character, so pass it\n \t through.  */\n@@ -1067,6 +1066,24 @@ tui_inject_newline_into_command_window ()\n     }\n }\n \n+/* If we're passing an escape sequence to readline, this points to a\n+   string holding the remaining characters of the sequence to pass.\n+   We advance the pointer one character at a time until '\\0' is\n+   reached.  */\n+static const char *cur_seq = nullptr;\n+\n+/* Set CUR_SEQ to point at the current sequence to pass to readline,\n+   setup to call the input handler again so we complete the sequence\n+   shortly, and return the first character to start the sequence.  */\n+\n+static int\n+start_sequence (const char *seq)\n+{\n+  call_stdin_event_handler_again_p = 1;\n+  cur_seq = seq + 1;\n+  return seq[0];\n+}\n+\n /* Main worker for tui_getc.  Get a character from the command window.\n    This is called from the readline package, but wrapped in a\n    try/catch by tui_getc.  */\n@@ -1084,11 +1101,115 @@ tui_getc_1 (FILE *fp)\n   tui_readline_output (0, 0);\n #endif\n \n-  ch = gdb_wgetch (w);\n+  /* We enable keypad mode so that curses's wgetch processes mouse\n+     escape sequences.  In keypad mode, wgetch also processes the\n+     escape sequences for keys such as up/down etc. and returns KEY_UP\n+     / KEY_DOWN etc.  When we have the focus on the command window\n+     though, we want to pass the raw up/down etc. escape codes to\n+     readline so readline understands them.  */\n+  if (cur_seq != nullptr)\n+    {\n+      ch = *cur_seq++;\n+\n+      /* If we've reached the end of the string, we're done with the\n+\t sequence.  Otherwise, setup to get back here again for\n+\t another character.  */\n+      if (*cur_seq == '\\0')\n+\tcur_seq = nullptr;\n+      else\n+\tcall_stdin_event_handler_again_p = 1;\n+      return ch;\n+    }\n+  else\n+    ch = gdb_wgetch (w);\n \n   /* Handle prev/next/up/down here.  */\n   ch = tui_dispatch_ctrl_char (ch);\n-  \n+\n+#ifdef NCURSES_MOUSE_VERSION\n+  if (ch == KEY_MOUSE)\n+    {\n+      tui_dispatch_mouse_event ();\n+      return 0;\n+    }\n+#endif\n+\n+  /* Translate curses keys back to escape sequences so that readline\n+     can understand them.  We do this irrespective of which window has\n+     the focus.  If e.g., we're focused on a non-command window, then\n+     the up/down keys will already have been filtered by\n+     tui_dispatch_ctrl_char.  Keys that haven't been intercepted will\n+     be passed down to readline.  */\n+  if (current_ui->command_editing)\n+    {\n+      /* For the standard arrow keys + home/end, hardcode sequences\n+\t readline understands.  See bind_arrow_keys_internal in\n+\t readline/readline.c.  */\n+      switch (ch)\n+\t{\n+\tcase KEY_UP:\n+\t  return start_sequence (\"\\033[A\");\n+\tcase KEY_DOWN:\n+\t  return start_sequence (\"\\033[B\");\n+\tcase KEY_RIGHT:\n+\t  return start_sequence (\"\\033[C\");\n+\tcase KEY_LEFT:\n+\t  return start_sequence (\"\\033[D\");\n+\tcase KEY_HOME:\n+\t  return start_sequence (\"\\033[H\");\n+\tcase KEY_END:\n+\t  return start_sequence (\"\\033[F\");\n+\n+\t/* del and ins are unfortunately not hardcoded in readline for\n+\t   all systems.  */\n+\n+\tcase KEY_DC: /* del */\n+#ifdef __MINGW32__\n+\t  return start_sequence (\"\\340S\");\n+#else\n+\t  return start_sequence (\"\\033[3~\");\n+#endif\n+\n+\tcase KEY_IC: /* ins */\n+#if defined __MINGW32__\n+\t  return start_sequence (\"\\340R\");\n+#else\n+\t  return start_sequence (\"\\033[2~\");\n+#endif\n+\t}\n+\n+      /* Keycodes above KEY_MAX are not garanteed to be stable.\n+\t Compare keyname instead.  */\n+      if (ch >= KEY_MAX)\n+\t{\n+\t  auto name = gdb::string_view (keyname (ch));\n+\n+\t  /* The following sequences are hardcoded in readline as\n+\t     well.  */\n+\n+\t  /* ctrl-arrow keys */\n+\t  if (name == \"kLFT5\") /* ctrl-left */\n+\t    return start_sequence (\"\\033[1;5D\");\n+\t  else if (name == \"kRIT5\") /* ctrl-right */\n+\t    return start_sequence (\"\\033[1;5C\");\n+\t  else if (name == \"kDC5\") /* ctrl-del */\n+\t    return start_sequence (\"\\033[3;5~\");\n+\n+\t  /* alt-arrow keys */\n+\t  else if (name == \"kLFT3\") /* alt-left */\n+\t    return start_sequence (\"\\033[1;3D\");\n+\t  else if (name == \"kRIT3\") /* alt-right */\n+\t    return start_sequence (\"\\033[1;3C\");\n+\t}\n+    }\n+\n+  /* Handle the CTRL-L refresh for each window.  */\n+  if (ch == '\\f')\n+    {\n+      tui_refresh_all_win ();\n+      return ch;\n+    }\n+\n   if (ch == KEY_BACKSPACE)\n     return '\\b';\n \n@@ -1118,6 +1239,13 @@ tui_getc_1 (FILE *fp)\n \t}\n     }\n \n+  if (ch > 0xff)\n+    {\n+      /* Readline doesn't understand non-8-bit curses keys, filter\n+\t them out.  */\n+      return 0;\n+    }\n+\n   return ch;\n }\n "
    },
    {
      "sha": "a51e7b9f6da5ec9b2cd9f0d035e003e46855c4ee",
      "filename": "gdb/tui/tui-win.c",
      "status": "modified",
      "additions": 3,
      "deletions": 9,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/gdb/tui/tui-win.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/gdb/tui/tui-win.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-win.c?ref=82a5082ed3f00b8d7bd1e3810c6eeb4351e35286",
      "patch": "@@ -498,14 +498,11 @@ tui_resize_all (void)\n   height_diff = screenheight - tui_term_height ();\n   if (height_diff || width_diff)\n     {\n-      struct tui_win_info *win_with_focus = tui_win_with_focus ();\n-\n #ifdef HAVE_RESIZE_TERM\n       resize_term (screenheight, screenwidth);\n #endif      \n       /* Turn keypad off while we resize.  */\n-      if (win_with_focus != TUI_CMD_WIN)\n-\tkeypad (TUI_CMD_WIN->handle.get (), FALSE);\n+      keypad (TUI_CMD_WIN->handle.get (), FALSE);\n       tui_update_gdb_sizes ();\n       tui_set_term_height_to (screenheight);\n       tui_set_term_width_to (screenwidth);\n@@ -515,10 +512,8 @@ tui_resize_all (void)\n       erase ();\n       clearok (curscr, TRUE);\n       tui_apply_current_layout ();\n-      /* Turn keypad back on, unless focus is in the command\n-\t window.  */\n-      if (win_with_focus != TUI_CMD_WIN)\n-\tkeypad (TUI_CMD_WIN->handle.get (), TRUE);\n+      /* Turn keypad back on.  */\n+      keypad (TUI_CMD_WIN->handle.get (), TRUE);\n     }\n }\n \n@@ -703,7 +698,6 @@ tui_set_focus_command (const char *arg, int from_tty)\n     error (_(\"Window \\\"%s\\\" is not visible\"), arg);\n \n   tui_set_win_focus_to (win_info);\n-  keypad (TUI_CMD_WIN->handle.get (), win_info != TUI_CMD_WIN);\n   printf_filtered (_(\"Focus set to %s window.\\n\"),\n \t\t   tui_win_with_focus ()->name ());\n }"
    },
    {
      "sha": "5f0c87c05e143beb4449366eb1e6f2b414076dcc",
      "filename": "gdb/tui/tui.c",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/gdb/tui/tui.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/82a5082ed3f00b8d7bd1e3810c6eeb4351e35286/gdb/tui/tui.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui.c?ref=82a5082ed3f00b8d7bd1e3810c6eeb4351e35286",
      "patch": "@@ -179,10 +179,7 @@ tui_rl_other_window (int count, int key)\n \n   win_info = tui_next_win (tui_win_with_focus ());\n   if (win_info)\n-    {\n-      tui_set_win_focus_to (win_info);\n-      keypad (TUI_CMD_WIN->handle.get (), win_info != TUI_CMD_WIN);\n-    }\n+    tui_set_win_focus_to (win_info);\n   return 0;\n }\n "
    }
  ]
}