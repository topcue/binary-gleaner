{
  "sha": "1c7148dd0d370175b7ed6ef47de0a6958b1abac8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWM3MTQ4ZGQwZDM3MDE3NWI3ZWQ2ZWY0N2RlMGE2OTU4YjFhYmFjOA==",
  "commit": {
    "author": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2019-12-20T22:30:17Z"
    },
    "committer": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2019-12-20T22:30:17Z"
    },
    "message": "Address Tom Tromey's comments on the CTF reader.\n\n * Use the type-safe registry for ctf_file_key;\n * Drop \"typedef\" when defining \"struct ctf_context\";\n * Use ANOFFSET with SECT_OFF_TEXT to get the text base address;\n\ngdb/ChangeLog\n2019-12-20  Weimin Pan  <weimin.pan@oracle.com>\n        * ctfread.c (ctf_file_key): Change type to objfile_key.\n        (struct ctf_context): Remove typedef.\n        (get_objfile_text_range): Use ANOFFSET to get text base.",
    "tree": {
      "sha": "db7a70db661b3d6433ad0cb95032752cb258e91d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/db7a70db661b3d6433ad0cb95032752cb258e91d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1c7148dd0d370175b7ed6ef47de0a6958b1abac8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1c7148dd0d370175b7ed6ef47de0a6958b1abac8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1c7148dd0d370175b7ed6ef47de0a6958b1abac8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1c7148dd0d370175b7ed6ef47de0a6958b1abac8/comments",
  "author": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7f2d7a0d0d827788394ba7a5a8f4b6b4e0671a7c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7f2d7a0d0d827788394ba7a5a8f4b6b4e0671a7c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7f2d7a0d0d827788394ba7a5a8f4b6b4e0671a7c"
    }
  ],
  "stats": {
    "total": 150,
    "additions": 75,
    "deletions": 75
  },
  "files": [
    {
      "sha": "b58e4f54d5b43d715918538d5000d658eccb10c0",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c7148dd0d370175b7ed6ef47de0a6958b1abac8/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c7148dd0d370175b7ed6ef47de0a6958b1abac8/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1c7148dd0d370175b7ed6ef47de0a6958b1abac8",
      "patch": "@@ -1,3 +1,8 @@\n+2019-12-20  Weimin Pan  <weimin.pan@oracle.com>\n+\t* ctfread.c (ctf_file_key): Change type to objfile_key.\n+\t(struct ctf_context): Remove typedef.\n+\t(get_objfile_text_range): Use ANOFFSET to get text base.\n+\n 2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* dwarf2read.c (is_valid_DW_AT_calling_convention_for_subroutine):"
    },
    {
      "sha": "65e6ebbf91b4aea44d13c44bd608c2e3345385d9",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 70,
      "deletions": 75,
      "changes": 145,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c7148dd0d370175b7ed6ef47de0a6958b1abac8/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c7148dd0d370175b7ed6ef47de0a6958b1abac8/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=1c7148dd0d370175b7ed6ef47de0a6958b1abac8",
      "patch": "@@ -85,16 +85,35 @@\n #include \"ctf-api.h\"\n \n static const struct objfile_key<htab, htab_deleter> ctf_tid_key;\n-static const struct objfile_data *ctf_file_key;\n+\n+struct ctf_fp_info\n+{\n+    explicit ctf_fp_info (ctf_file_t *cfp) : fp (cfp) {}\n+    ~ctf_fp_info ();\n+    ctf_file_t *fp;\n+};\n+\n+/* Cleanup function for the ctf_file_key data.  */\n+ctf_fp_info::~ctf_fp_info ()\n+{\n+  if (!fp)\n+    return;\n+\n+  ctf_archive_t *arc = ctf_get_arc (fp);\n+  ctf_file_close (fp);\n+  ctf_close (arc);\n+}\n+\n+static const objfile_key<ctf_fp_info> ctf_file_key;\n \n /* A CTF context consists of a file pointer and an objfile pointer.  */\n \n-typedef struct ctf_context\n+struct ctf_context\n {\n   ctf_file_t *fp;\n   struct objfile *of;\n   struct buildsym_compunit *builder;\n-} ctf_context_t;\n+};\n \n /* The routines that read and process fields/members of a C struct, union,\n    or enumeration, pass lists of data member fields in an instance of a\n@@ -111,7 +130,7 @@ struct ctf_field_info\n   std::vector<struct ctf_nextfield> fields;\n \n   /* Context.  */\n-  ctf_context_t *cur_context;\n+  struct ctf_context *cur_context;\n \n   /* Parent type.  */\n   struct type *ptype;\n@@ -132,26 +151,26 @@ static void psymtab_to_symtab (struct partial_symtab *);\n \n static int ctf_add_type_cb (ctf_id_t tid, void *arg);\n \n-static struct type *read_array_type (ctf_context_t *ccp, ctf_id_t tid);\n+static struct type *read_array_type (struct ctf_context *cp, ctf_id_t tid);\n \n-static struct type *read_pointer_type (ctf_context_t *ccp, ctf_id_t tid,\n+static struct type *read_pointer_type (struct ctf_context *cp, ctf_id_t tid,\n \t\t\t\t       ctf_id_t btid);\n \n-static struct type *read_structure_type (ctf_context_t *ccp, ctf_id_t tid);\n+static struct type *read_structure_type (struct ctf_context *cp, ctf_id_t tid);\n \n-static struct type *read_enum_type (ctf_context_t *ccp, ctf_id_t tid);\n+static struct type *read_enum_type (struct ctf_context *cp, ctf_id_t tid);\n \n-static struct type *read_typedef_type (ctf_context_t *ccp, ctf_id_t tid,\n+static struct type *read_typedef_type (struct ctf_context *cp, ctf_id_t tid,\n \t\t\t\t       ctf_id_t btid, const char *name);\n \n-static struct type *read_type_record (ctf_context_t *ccp, ctf_id_t tid);\n+static struct type *read_type_record (struct ctf_context *cp, ctf_id_t tid);\n \n-static void process_structure_type (ctf_context_t *ccp, ctf_id_t tid);\n+static void process_structure_type (struct ctf_context *cp, ctf_id_t tid);\n \n-static void process_struct_members (ctf_context_t *ccp, ctf_id_t tid,\n+static void process_struct_members (struct ctf_context *cp, ctf_id_t tid,\n \t\t\t\t    struct type *type);\n \n-static struct symbol *new_symbol (ctf_context_t *ccp, struct type *type,\n+static struct symbol *new_symbol (struct ctf_context *cp, struct type *type,\n \t\t\t\t  ctf_id_t tid);\n \n struct ctf_tid_and_type\n@@ -323,7 +342,7 @@ ctf_add_member_cb (const char *name,\n \t\t   void *arg)\n {\n   struct ctf_field_info *fip = (struct ctf_field_info *) arg;\n-  ctf_context_t *ccp = fip->cur_context;\n+  struct ctf_context *ccp = fip->cur_context;\n   struct ctf_nextfield new_field;\n   struct field *fp;\n   struct type *t;\n@@ -366,7 +385,7 @@ ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n   struct ctf_field_info *fip = (struct ctf_field_info *) arg;\n   struct ctf_nextfield new_field;\n   struct field *fp;\n-  ctf_context_t *ccp = fip->cur_context;\n+  struct ctf_context *ccp = fip->cur_context;\n \n   fp = &new_field.field;\n   FIELD_NAME (*fp) = name;\n@@ -396,7 +415,7 @@ ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n    domain from TID's kind, and its type from TYPE.  */\n \n static struct symbol *\n-new_symbol (ctf_context_t *ccp, struct type *type, ctf_id_t tid)\n+new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n {\n   struct objfile *objfile = ccp->of;\n   ctf_file_t *fp = ccp->fp;\n@@ -459,7 +478,7 @@ new_symbol (ctf_context_t *ccp, struct type *type, ctf_id_t tid)\n    and create the symbol for it.  */\n \n static struct type *\n-read_base_type (ctf_context_t *ccp, ctf_id_t tid)\n+read_base_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n   ctf_file_t *fp = ccp->fp;\n@@ -538,7 +557,7 @@ read_base_type (ctf_context_t *ccp, ctf_id_t tid)\n }\n \n static void\n-process_base_type (ctf_context_t *ccp, ctf_id_t tid)\n+process_base_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct type *type;\n \n@@ -554,7 +573,7 @@ process_base_type (ctf_context_t *ccp, ctf_id_t tid)\n    (assuming the type has a name).  */\n \n static struct type *\n-read_structure_type (ctf_context_t *ccp, ctf_id_t tid)\n+read_structure_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n   ctf_file_t *fp = ccp->fp;\n@@ -583,7 +602,7 @@ read_structure_type (ctf_context_t *ccp, ctf_id_t tid)\n    and create the symbol for it.  */\n \n static void\n-process_struct_members (ctf_context_t *ccp,\n+process_struct_members (struct ctf_context *ccp,\n \t\t\tctf_id_t tid,\n \t\t\tstruct type *type)\n {\n@@ -601,7 +620,7 @@ process_struct_members (ctf_context_t *ccp,\n }\n \n static void\n-process_structure_type (ctf_context_t *ccp, ctf_id_t tid)\n+process_structure_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct type *type;\n \n@@ -612,7 +631,7 @@ process_structure_type (ctf_context_t *ccp, ctf_id_t tid)\n /* Create a function type for TID and set its return type.  */\n \n static struct type *\n-read_func_kind_type (ctf_context_t *ccp, ctf_id_t tid)\n+read_func_kind_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n   ctf_file_t *fp = ccp->fp;\n@@ -638,7 +657,7 @@ read_func_kind_type (ctf_context_t *ccp, ctf_id_t tid)\n    enumeration, and create the symbol for the enumeration type.  */\n \n static struct type *\n-read_enum_type (ctf_context_t *ccp, ctf_id_t tid)\n+read_enum_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n   ctf_file_t *fp = ccp->fp;\n@@ -662,7 +681,7 @@ read_enum_type (ctf_context_t *ccp, ctf_id_t tid)\n }\n \n static void\n-process_enum_type (ctf_context_t *ccp, ctf_id_t tid)\n+process_enum_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct type *type;\n   struct ctf_field_info fi;\n@@ -684,7 +703,7 @@ process_enum_type (ctf_context_t *ccp, ctf_id_t tid)\n /* Add given cv-qualifiers CNST+VOLTL to the BASE_TYPE of array TID.  */\n \n static struct type *\n-add_array_cv_type (ctf_context_t *ccp,\n+add_array_cv_type (struct ctf_context *ccp,\n \t\t   ctf_id_t tid,\n \t\t   struct type *base_type,\n \t\t   int cnst,\n@@ -713,7 +732,7 @@ add_array_cv_type (ctf_context_t *ccp,\n /* Read all information from a TID of CTF_K_ARRAY.  */\n \n static struct type *\n-read_array_type (ctf_context_t *ccp, ctf_id_t tid)\n+read_array_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *objfile = ccp->of;\n   ctf_file_t *fp = ccp->fp;\n@@ -755,7 +774,7 @@ read_array_type (ctf_context_t *ccp, ctf_id_t tid)\n /* Read TID of kind CTF_K_CONST with base type BTID.  */\n \n static struct type *\n-read_const_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n+read_const_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n {\n   struct objfile *objfile = ccp->of;\n   struct type *base_type, *cv_type;\n@@ -778,7 +797,7 @@ read_const_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n /* Read TID of kind CTF_K_VOLATILE with base type BTID.  */\n \n static struct type *\n-read_volatile_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n+read_volatile_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n {\n   struct objfile *objfile = ccp->of;\n   ctf_file_t *fp = ccp->fp;\n@@ -805,7 +824,7 @@ read_volatile_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n /* Read TID of kind CTF_K_RESTRICT with base type BTID.  */\n \n static struct type *\n-read_restrict_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n+read_restrict_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n {\n   struct objfile *objfile = ccp->of;\n   struct type *base_type, *cv_type;\n@@ -828,7 +847,7 @@ read_restrict_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n /* Read TID of kind CTF_K_TYPEDEF with its NAME and base type BTID.  */\n \n static struct type *\n-read_typedef_type (ctf_context_t *ccp, ctf_id_t tid,\n+read_typedef_type (struct ctf_context *ccp, ctf_id_t tid,\n \t\t   ctf_id_t btid, const char *name)\n {\n   struct objfile *objfile = ccp->of;\n@@ -850,7 +869,7 @@ read_typedef_type (ctf_context_t *ccp, ctf_id_t tid,\n /* Read TID of kind CTF_K_POINTER with base type BTID.  */\n \n static struct type *\n-read_pointer_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n+read_pointer_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n {\n   struct objfile *of = ccp->of;\n   struct type *target_type, *type;\n@@ -875,7 +894,7 @@ read_pointer_type (ctf_context_t *ccp, ctf_id_t tid, ctf_id_t btid)\n /* Read information associated with type TID.  */\n \n static struct type *\n-read_type_record (ctf_context_t *ccp, ctf_id_t tid)\n+read_type_record (struct ctf_context *ccp, ctf_id_t tid)\n {\n   ctf_file_t *fp = ccp->fp;\n   uint32_t kind;\n@@ -939,7 +958,7 @@ read_type_record (ctf_context_t *ccp, ctf_id_t tid)\n static int\n ctf_add_type_cb (ctf_id_t tid, void *arg)\n {\n-  ctf_context_t *ccp = (ctf_context_t *) arg;\n+  struct ctf_context *ccp = (struct ctf_context *) arg;\n   struct type *type;\n   uint32_t kind;\n \n@@ -1004,7 +1023,7 @@ ctf_add_type_cb (ctf_id_t tid, void *arg)\n static int\n ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n {\n-  ctf_context_t *ccp = (ctf_context_t *) arg;\n+  struct ctf_context *ccp = (struct ctf_context *) arg;\n   struct symbol *sym = NULL;\n   struct type *type;\n   uint32_t kind;\n@@ -1062,7 +1081,7 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n /* Add an ELF STT_OBJ symbol with index IDX to the symbol table.  */\n \n static struct symbol *\n-add_stt_obj (ctf_context_t *ccp, unsigned long idx)\n+add_stt_obj (struct ctf_context *ccp, unsigned long idx)\n {\n   struct symbol *sym;\n   struct type *type;\n@@ -1083,7 +1102,7 @@ add_stt_obj (ctf_context_t *ccp, unsigned long idx)\n /* Add an ELF STT_FUNC symbol with index IDX to the symbol table.  */\n \n static struct symbol *\n-add_stt_func (ctf_context_t *ccp, unsigned long idx)\n+add_stt_func (struct ctf_context *ccp, unsigned long idx)\n {\n   struct type *ftype, *atyp, *rettyp;\n   struct symbol *sym;\n@@ -1141,23 +1160,12 @@ add_stt_func (ctf_context_t *ccp, unsigned long idx)\n static CORE_ADDR\n get_objfile_text_range (struct objfile *of, int *tsize)\n {\n-  CORE_ADDR text_base;\n   bfd *abfd = of->obfd;\n   const asection *codes;\n \n   codes = bfd_get_section_by_name (abfd, \".text\");\n-  if (codes == NULL)\n-    {\n-      text_base = 0;\n-      *tsize = 0;\n-    }\n-  else\n-    {\n-      text_base = bfd_section_vma (codes);\n-      *tsize = codes->size;\n-    }\n-\n-  return text_base;\n+  *tsize = codes ? bfd_section_size (codes) : 0;\n+  return ANOFFSET (of->section_offsets, SECT_OFF_TEXT (of));\n }\n \n /* Start a symtab for OBJFILE in CTF format.  */\n@@ -1166,9 +1174,9 @@ static void\n ctf_start_symtab (struct partial_symtab *pst,\n \t\t  struct objfile *of, CORE_ADDR text_offset)\n {\n-  ctf_context_t *ccp;\n+  struct ctf_context *ccp;\n \n-  ccp = (ctf_context_t *) pst->read_symtab_private;\n+  ccp = (struct ctf_context *) pst->read_symtab_private;\n   ccp->builder = new buildsym_compunit\n \t\t       (of, of->original_name, NULL,\n \t\t       language_c, text_offset);\n@@ -1183,9 +1191,9 @@ static struct compunit_symtab *\n ctf_end_symtab (struct partial_symtab *pst,\n \t\tCORE_ADDR end_addr, int section)\n {\n-  ctf_context_t *ccp;\n+  struct ctf_context *ccp;\n \n-  ccp = (ctf_context_t *) pst->read_symtab_private;\n+  ccp = (struct ctf_context *) pst->read_symtab_private;\n   struct compunit_symtab *result\n     = ccp->builder->end_symtab (end_addr, section);\n   delete ccp->builder;\n@@ -1199,11 +1207,11 @@ static void\n psymtab_to_symtab (struct partial_symtab *pst)\n {\n   struct symbol *sym;\n-  ctf_context_t *ccp;\n+  struct ctf_context *ccp;\n \n   gdb_assert (!pst->readin);\n \n-  ccp = (ctf_context_t *) pst->read_symtab_private;\n+  ccp = (struct ctf_context *) pst->read_symtab_private;\n \n   /* Iterate over entries in data types section.  */\n   if (ctf_type_iter (ccp->fp, ctf_add_type_cb, ccp) == CTF_ERR)\n@@ -1271,17 +1279,6 @@ ctf_read_symtab (struct partial_symtab *pst, struct objfile *objfile)\n     }\n }\n \n-/* Cleanup function for the ctf_file_key data.  */\n-\n-static void\n-ctf_close_objfile (struct objfile *of, void *datum)\n-{\n-  ctf_file_t *fp = static_cast<ctf_file_t *> (datum);\n-  ctf_archive_t *arc = ctf_get_arc (fp);\n-  ctf_file_close (fp);\n-  ctf_close (arc);\n-}\n-\n /* Allocate a new partial_symtab NAME.\n \n    Each source file that has not been fully read in is represented by\n@@ -1300,11 +1297,11 @@ create_partial_symtab (const char *name,\n \t\t       struct objfile *objfile)\n {\n   struct partial_symtab *pst;\n-  ctf_context_t *ccx;\n+  struct ctf_context *ccx;\n \n   pst = start_psymtab_common (objfile, name, 0);\n \n-  ccx = XOBNEW (&objfile->objfile_obstack, ctf_context_t);\n+  ccx = XOBNEW (&objfile->objfile_obstack, struct ctf_context);\n   ccx->fp = cfp;\n   ccx->of = objfile;\n   pst->read_symtab_private = (void *) ccx;\n@@ -1318,11 +1315,11 @@ create_partial_symtab (const char *name,\n static int\n ctf_psymtab_type_cb (ctf_id_t tid, void *arg)\n {\n-  ctf_context_t *ccp;\n+  struct ctf_context *ccp;\n   uint32_t kind;\n   short section = -1;\n \n-  ccp = (ctf_context_t *) arg;\n+  ccp = (struct ctf_context *) arg;\n   gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (ccp->fp, tid));\n   if (name == NULL || strlen (name.get ()) == 0)\n     return 0;\n@@ -1378,7 +1375,7 @@ ctf_psymtab_type_cb (ctf_id_t tid, void *arg)\n static int\n ctf_psymtab_var_cb (const char *name, ctf_id_t id, void *arg)\n {\n-  ctf_context_t *ccp = (ctf_context_t *) arg;\n+  struct ctf_context *ccp = (struct ctf_context *) arg;\n \n   add_psymbol_to_list (name, true,\n \t\t       VAR_DOMAIN, LOC_STATIC, -1,\n@@ -1393,7 +1390,7 @@ ctf_psymtab_var_cb (const char *name, ctf_id_t id, void *arg)\n static void\n scan_partial_symbols (ctf_file_t *cfp, struct objfile *of)\n {\n-  ctf_context_t ccx;\n+  struct ctf_context ccx;\n   bfd *abfd = of->obfd;\n   const char *name = bfd_get_filename (abfd);\n   struct partial_symtab *pst = create_partial_symtab (name, cfp, of);\n@@ -1473,14 +1470,12 @@ elfctf_build_psymtabs (struct objfile *of)\n   if (fp == NULL)\n     error (_(\"ctf_arc_open_by_name failed on %s - %s\"),\n \t   bfd_get_filename (abfd), ctf_errmsg (err));\n-  set_objfile_data (of, ctf_file_key, fp);\n+  ctf_file_key.emplace (of, fp);\n \n   scan_partial_symbols (fp, of);\n }\n \n void\n _initialize_ctfread (void)\n {\n-  ctf_file_key\n-    = register_objfile_data_with_cleanup (NULL, ctf_close_objfile);\n }"
    }
  ]
}