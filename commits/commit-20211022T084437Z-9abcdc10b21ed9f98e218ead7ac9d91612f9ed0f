{
  "sha": "9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
  "node_id": "C_kwDOANOeidoAKDlhYmNkYzEwYjIxZWQ5Zjk4ZTIxOGVhZDdhYzlkOTE2MTJmOWVkMGY",
  "commit": {
    "author": {
      "name": "Lewis Revill",
      "email": "lewis.revill@embecosm.com",
      "date": "2021-10-21T03:15:47Z"
    },
    "committer": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-10-22T08:44:37Z"
    },
    "message": "RISC-V: Don't separate pcgp relaxation to another relax pass.\n\nCommit abd20cb637008da9d32018b4b03973e119388a0a and\nebdcad3fddf6ec21f6d4dcc702379a12718cf0c4 introduced additional\ncomplexity into the paths run by the RISC-V relaxation pass in order to\nresolve the issue of accurately keeping track of pcrel_hi and pcrel_lo\npairs. The first commit split up relaxation of these relocs into a pass\nwhich occurred after other relaxations in order to prevent the situation\nwhere bytes were deleted in between a pcrel_lo/pcrel_hi pair, inhibiting\nour ability to find the corresponding pcrel_hi relocation from the\naddress attached to the pcrel_lo.\n\nSince the relaxation was split into two passes the 'again' parameter\ncould not be used to perform the entire relaxation process again and so\nthe second commit added a way to restart ldelf_map_segments, thus\nstarting the whole process again.\n\nUnfortunately this process could not account for the fact that we were\nnot finished with the relaxation process so in some cases - such as the\ncase where code would not fit in a memory region before the\nR_RISCV_ALIGN relocation was relaxed - sanity checks in generic code\nwould fail.\n\nThis patch fixes all three of these concerns by reverting back to a\nsystem of having only one target relax pass but updating entries in the\ntable of pcrel_hi/pcrel_lo relocs every time any bytes are deleted. Thus\nwe can keep track of the pairs accurately, and we can use the 'again'\nparameter to restart the entire target relax pass, behaving in the way\nthat generic code expects. Unfortunately we must still have an\nadditional pass to delay deleting AUIPC bytes to avoid ambiguity between\npcrel_hi relocs stored in the table after deletion. This pass can only\nbe run once so we may potentially miss out on relaxation opportunities\nbut this is likely to be rare.\n\nhttps://sourceware.org/bugzilla/show_bug.cgi?id=28410\n\nbfd/\n\t* elfnn-riscv.c (riscv_elf_link_hash_table): Removed restart_relax.\n\t(riscv_elf_link_hash_table_create): Updated.\n\t(riscv_relax_delete_bytes): Moved after the riscv_update_pcgp_relocs.\n\tUpdate the pcgp_relocs table whenever bytes are deleted.\n\t(riscv_update_pcgp_relocs): Add function to update the section\n\toffset of pcrel_hi and pcrel_lo, and also update the symbol value\n\tof pcrel_hi.\n\t(_bfd_riscv_relax_call): Need to update the pcgp_relocs table\n\twhen deleting codes.\n\t(_bfd_riscv_relax_lui): Likewise.\n\t(_bfd_riscv_relax_tls_le): Likewise.\n\t(_bfd_riscv_relax_align): Once we've handled an R_RISCV_ALIGN,\n\twe can't relax anything else, so set the sec->sec_flg0 to true.\n\tBesides, we don't need to update the pcgp_relocs table at this\n\tstage, so just pass NULL pointer as the pcgp_relocs table for\n\triscv_relax_delete_bytes.\n\t(_bfd_riscv_relax_section): Use only one pass for all target\n\trelaxations.\n\t(_bfd_riscv_relax_delete): Likewise, we don't need to update\n\tthe pcgp_relocs table at this stage, and don't need to set\n\tthe `again' since restart_relax mechanism is abandoned.\n\t(bfd_elfNN_riscv_restart_relax_sections): Removed.\n\t(_bfd_riscv_relax_section): Updated.\n\t* elfxx-riscv.h (bfd_elf32_riscv_restart_relax_sections): Removed.\n\t(bfd_elf64_riscv_restart_relax_sections): Likewise.\nld/\n\t* emultempl/riscvelf.em: Revert restart_relax changes and set\n\trelax_pass to 3.\n\t* testsuite/ld-riscv-elf/align-small-region.d: New testcase.\n\t* testsuite/ld-riscv-elf/align-small-region.ld: Likewise.\n\t* testsuite/ld-riscv-elf/align-small-region.s: Likewise.\n\t* testsuite/ld-riscv-elf/restart-relax.d: Removed sine the\n\trestart_relax mechanism is abandoned.\n\t* testsuite/ld-riscv-elf/restart-relax.s: Likewise.\n\t* testsuite/ld-riscv-elf/ld-riscv-elf.exp: Updated.",
    "tree": {
      "sha": "e0c51e3c37a1e462dec834b0a334a1ae2aa38f73",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e0c51e3c37a1e462dec834b0a334a1ae2aa38f73"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/comments",
  "author": {
    "login": "lewis-revill",
    "id": 40796884,
    "node_id": "MDQ6VXNlcjQwNzk2ODg0",
    "avatar_url": "https://avatars.githubusercontent.com/u/40796884?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lewis-revill",
    "html_url": "https://github.com/lewis-revill",
    "followers_url": "https://api.github.com/users/lewis-revill/followers",
    "following_url": "https://api.github.com/users/lewis-revill/following{/other_user}",
    "gists_url": "https://api.github.com/users/lewis-revill/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lewis-revill/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lewis-revill/subscriptions",
    "organizations_url": "https://api.github.com/users/lewis-revill/orgs",
    "repos_url": "https://api.github.com/users/lewis-revill/repos",
    "events_url": "https://api.github.com/users/lewis-revill/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lewis-revill/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": null,
  "parents": [
    {
      "sha": "66cc044255f805fd052b9cb9352915cbdf3040b5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/66cc044255f805fd052b9cb9352915cbdf3040b5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/66cc044255f805fd052b9cb9352915cbdf3040b5"
    }
  ],
  "stats": {
    "total": 431,
    "additions": 215,
    "deletions": 216
  },
  "files": [
    {
      "sha": "2bae1e9a76546c062f9caa95e221d13405099b73",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 181,
      "deletions": 173,
      "changes": 354,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
      "patch": "@@ -131,9 +131,6 @@ struct riscv_elf_link_hash_table\n   /* The index of the last unused .rel.iplt slot.  */\n   bfd_vma last_iplt_index;\n \n-  /* Re-run the relaxations from relax pass 0 if TRUE.  */\n-  bool restart_relax;\n-\n   /* The data segment phase, don't relax the section\n      when it is exp_seg_relro_adjust.  */\n   int *data_segment_phase;\n@@ -405,7 +402,6 @@ riscv_elf_link_hash_table_create (bfd *abfd)\n     }\n \n   ret->max_alignment = (bfd_vma) -1;\n-  ret->restart_relax = false;\n \n   /* Create hash table for local ifunc.  */\n   ret->loc_hash_table = htab_try_create (1024,\n@@ -3923,115 +3919,6 @@ _bfd_riscv_elf_merge_private_bfd_data (bfd *ibfd, struct bfd_link_info *info)\n   return false;\n }\n \n-/* Delete some bytes from a section while relaxing.  */\n-\n-static bool\n-riscv_relax_delete_bytes (bfd *abfd, asection *sec, bfd_vma addr, size_t count,\n-\t\t\t  struct bfd_link_info *link_info)\n-{\n-  unsigned int i, symcount;\n-  bfd_vma toaddr = sec->size;\n-  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (abfd);\n-  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;\n-  unsigned int sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);\n-  struct bfd_elf_section_data *data = elf_section_data (sec);\n-  bfd_byte *contents = data->this_hdr.contents;\n-\n-  /* Actually delete the bytes.  */\n-  sec->size -= count;\n-  memmove (contents + addr, contents + addr + count, toaddr - addr - count);\n-\n-  /* Adjust the location of all of the relocs.  Note that we need not\n-     adjust the addends, since all PC-relative references must be against\n-     symbols, which we will adjust below.  */\n-  for (i = 0; i < sec->reloc_count; i++)\n-    if (data->relocs[i].r_offset > addr && data->relocs[i].r_offset < toaddr)\n-      data->relocs[i].r_offset -= count;\n-\n-  /* Adjust the local symbols defined in this section.  */\n-  for (i = 0; i < symtab_hdr->sh_info; i++)\n-    {\n-      Elf_Internal_Sym *sym = (Elf_Internal_Sym *) symtab_hdr->contents + i;\n-      if (sym->st_shndx == sec_shndx)\n-\t{\n-\t  /* If the symbol is in the range of memory we just moved, we\n-\t     have to adjust its value.  */\n-\t  if (sym->st_value > addr && sym->st_value <= toaddr)\n-\t    sym->st_value -= count;\n-\n-\t  /* If the symbol *spans* the bytes we just deleted (i.e. its\n-\t     *end* is in the moved bytes but its *start* isn't), then we\n-\t     must adjust its size.\n-\n-\t     This test needs to use the original value of st_value, otherwise\n-\t     we might accidentally decrease size when deleting bytes right\n-\t     before the symbol.  But since deleted relocs can't span across\n-\t     symbols, we can't have both a st_value and a st_size decrease,\n-\t     so it is simpler to just use an else.  */\n-\t  else if (sym->st_value <= addr\n-\t\t   && sym->st_value + sym->st_size > addr\n-\t\t   && sym->st_value + sym->st_size <= toaddr)\n-\t    sym->st_size -= count;\n-\t}\n-    }\n-\n-  /* Now adjust the global symbols defined in this section.  */\n-  symcount = ((symtab_hdr->sh_size / sizeof (ElfNN_External_Sym))\n-\t      - symtab_hdr->sh_info);\n-\n-  for (i = 0; i < symcount; i++)\n-    {\n-      struct elf_link_hash_entry *sym_hash = sym_hashes[i];\n-\n-      /* The '--wrap SYMBOL' option is causing a pain when the object file,\n-\t containing the definition of __wrap_SYMBOL, includes a direct\n-\t call to SYMBOL as well. Since both __wrap_SYMBOL and SYMBOL reference\n-\t the same symbol (which is __wrap_SYMBOL), but still exist as two\n-\t different symbols in 'sym_hashes', we don't want to adjust\n-\t the global symbol __wrap_SYMBOL twice.\n-\n-\t The same problem occurs with symbols that are versioned_hidden, as\n-\t foo becomes an alias for foo@BAR, and hence they need the same\n-\t treatment.  */\n-      if (link_info->wrap_hash != NULL\n-\t  || sym_hash->versioned != unversioned)\n-\t{\n-\t  struct elf_link_hash_entry **cur_sym_hashes;\n-\n-\t  /* Loop only over the symbols which have already been checked.  */\n-\t  for (cur_sym_hashes = sym_hashes; cur_sym_hashes < &sym_hashes[i];\n-\t       cur_sym_hashes++)\n-\t    {\n-\t      /* If the current symbol is identical to 'sym_hash', that means\n-\t\t the symbol was already adjusted (or at least checked).  */\n-\t      if (*cur_sym_hashes == sym_hash)\n-\t\tbreak;\n-\t    }\n-\t  /* Don't adjust the symbol again.  */\n-\t  if (cur_sym_hashes < &sym_hashes[i])\n-\t    continue;\n-\t}\n-\n-      if ((sym_hash->root.type == bfd_link_hash_defined\n-\t   || sym_hash->root.type == bfd_link_hash_defweak)\n-\t  && sym_hash->root.u.def.section == sec)\n-\t{\n-\t  /* As above, adjust the value if needed.  */\n-\t  if (sym_hash->root.u.def.value > addr\n-\t      && sym_hash->root.u.def.value <= toaddr)\n-\t    sym_hash->root.u.def.value -= count;\n-\n-\t  /* As above, adjust the size if needed.  */\n-\t  else if (sym_hash->root.u.def.value <= addr\n-\t\t   && sym_hash->root.u.def.value + sym_hash->size > addr\n-\t\t   && sym_hash->root.u.def.value + sym_hash->size <= toaddr)\n-\t    sym_hash->size -= count;\n-\t}\n-    }\n-\n-  return true;\n-}\n-\n /* A second format for recording PC-relative hi relocations.  This stores the\n    information required to relax them to GP-relative addresses.  */\n \n@@ -4162,6 +4049,155 @@ riscv_find_pcgp_lo_reloc (riscv_pcgp_relocs *p, bfd_vma hi_sec_off)\n   return false;\n }\n \n+static void\n+riscv_update_pcgp_relocs (riscv_pcgp_relocs *p, asection *deleted_sec,\n+\t\t\t  bfd_vma deleted_addr, size_t deleted_count)\n+{\n+  /* Bytes have already been deleted and toaddr should match the old section\n+     size for our checks, so adjust it here.  */\n+  bfd_vma toaddr = deleted_sec->size + deleted_count;\n+  riscv_pcgp_lo_reloc *l;\n+  riscv_pcgp_hi_reloc *h;\n+\n+  /* Update section offsets of corresponding pcrel_hi relocs for the pcrel_lo\n+     entries where they occur after the deleted bytes.  */\n+  for (l = p->lo; l != NULL; l = l->next)\n+    if (l->hi_sec_off > deleted_addr\n+\t&& l->hi_sec_off < toaddr)\n+      l->hi_sec_off -= deleted_count;\n+\n+  /* Update both section offsets, and symbol values of pcrel_hi relocs where\n+     these values occur after the deleted bytes.  */\n+  for (h = p->hi; h != NULL; h = h->next)\n+    {\n+      if (h->hi_sec_off > deleted_addr\n+\t  && h->hi_sec_off < toaddr)\n+\th->hi_sec_off -= deleted_count;\n+      if (h->sym_sec == deleted_sec\n+\t  && h->hi_addr > deleted_addr\n+\t  && h->hi_addr < toaddr)\n+      h->hi_addr -= deleted_count;\n+    }\n+}\n+\n+/* Delete some bytes from a section while relaxing.  */\n+\n+static bool\n+riscv_relax_delete_bytes (bfd *abfd,\n+\t\t\t  asection *sec,\n+\t\t\t  bfd_vma addr,\n+\t\t\t  size_t count,\n+\t\t\t  struct bfd_link_info *link_info,\n+\t\t\t  riscv_pcgp_relocs *p)\n+{\n+  unsigned int i, symcount;\n+  bfd_vma toaddr = sec->size;\n+  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (abfd);\n+  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;\n+  unsigned int sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);\n+  struct bfd_elf_section_data *data = elf_section_data (sec);\n+  bfd_byte *contents = data->this_hdr.contents;\n+\n+  /* Actually delete the bytes.  */\n+  sec->size -= count;\n+  memmove (contents + addr, contents + addr + count, toaddr - addr - count);\n+\n+  /* Adjust the location of all of the relocs.  Note that we need not\n+     adjust the addends, since all PC-relative references must be against\n+     symbols, which we will adjust below.  */\n+  for (i = 0; i < sec->reloc_count; i++)\n+    if (data->relocs[i].r_offset > addr && data->relocs[i].r_offset < toaddr)\n+      data->relocs[i].r_offset -= count;\n+\n+  /* Adjust the hi_sec_off, and the hi_addr of any entries in the pcgp relocs\n+     table for which these values occur after the deleted bytes.  */\n+  if (p)\n+    riscv_update_pcgp_relocs (p, sec, addr, count);\n+\n+  /* Adjust the local symbols defined in this section.  */\n+  for (i = 0; i < symtab_hdr->sh_info; i++)\n+    {\n+      Elf_Internal_Sym *sym = (Elf_Internal_Sym *) symtab_hdr->contents + i;\n+      if (sym->st_shndx == sec_shndx)\n+\t{\n+\t  /* If the symbol is in the range of memory we just moved, we\n+\t     have to adjust its value.  */\n+\t  if (sym->st_value > addr && sym->st_value <= toaddr)\n+\t    sym->st_value -= count;\n+\n+\t  /* If the symbol *spans* the bytes we just deleted (i.e. its\n+\t     *end* is in the moved bytes but its *start* isn't), then we\n+\t     must adjust its size.\n+\n+\t     This test needs to use the original value of st_value, otherwise\n+\t     we might accidentally decrease size when deleting bytes right\n+\t     before the symbol.  But since deleted relocs can't span across\n+\t     symbols, we can't have both a st_value and a st_size decrease,\n+\t     so it is simpler to just use an else.  */\n+\t  else if (sym->st_value <= addr\n+\t\t   && sym->st_value + sym->st_size > addr\n+\t\t   && sym->st_value + sym->st_size <= toaddr)\n+\t    sym->st_size -= count;\n+\t}\n+    }\n+\n+  /* Now adjust the global symbols defined in this section.  */\n+  symcount = ((symtab_hdr->sh_size / sizeof (ElfNN_External_Sym))\n+\t      - symtab_hdr->sh_info);\n+\n+  for (i = 0; i < symcount; i++)\n+    {\n+      struct elf_link_hash_entry *sym_hash = sym_hashes[i];\n+\n+      /* The '--wrap SYMBOL' option is causing a pain when the object file,\n+\t containing the definition of __wrap_SYMBOL, includes a direct\n+\t call to SYMBOL as well. Since both __wrap_SYMBOL and SYMBOL reference\n+\t the same symbol (which is __wrap_SYMBOL), but still exist as two\n+\t different symbols in 'sym_hashes', we don't want to adjust\n+\t the global symbol __wrap_SYMBOL twice.\n+\n+\t The same problem occurs with symbols that are versioned_hidden, as\n+\t foo becomes an alias for foo@BAR, and hence they need the same\n+\t treatment.  */\n+      if (link_info->wrap_hash != NULL\n+\t  || sym_hash->versioned != unversioned)\n+\t{\n+\t  struct elf_link_hash_entry **cur_sym_hashes;\n+\n+\t  /* Loop only over the symbols which have already been checked.  */\n+\t  for (cur_sym_hashes = sym_hashes; cur_sym_hashes < &sym_hashes[i];\n+\t       cur_sym_hashes++)\n+\t    {\n+\t      /* If the current symbol is identical to 'sym_hash', that means\n+\t\t the symbol was already adjusted (or at least checked).  */\n+\t      if (*cur_sym_hashes == sym_hash)\n+\t\tbreak;\n+\t    }\n+\t  /* Don't adjust the symbol again.  */\n+\t  if (cur_sym_hashes < &sym_hashes[i])\n+\t    continue;\n+\t}\n+\n+      if ((sym_hash->root.type == bfd_link_hash_defined\n+\t   || sym_hash->root.type == bfd_link_hash_defweak)\n+\t  && sym_hash->root.u.def.section == sec)\n+\t{\n+\t  /* As above, adjust the value if needed.  */\n+\t  if (sym_hash->root.u.def.value > addr\n+\t      && sym_hash->root.u.def.value <= toaddr)\n+\t    sym_hash->root.u.def.value -= count;\n+\n+\t  /* As above, adjust the size if needed.  */\n+\t  else if (sym_hash->root.u.def.value <= addr\n+\t\t   && sym_hash->root.u.def.value + sym_hash->size > addr\n+\t\t   && sym_hash->root.u.def.value + sym_hash->size <= toaddr)\n+\t    sym_hash->size -= count;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n typedef bool (*relax_func_t) (bfd *, asection *, asection *,\n \t\t\t      struct bfd_link_info *,\n \t\t\t      Elf_Internal_Rela *,\n@@ -4179,7 +4215,7 @@ _bfd_riscv_relax_call (bfd *abfd, asection *sec, asection *sym_sec,\n \t\t       bfd_vma max_alignment,\n \t\t       bfd_vma reserve_size ATTRIBUTE_UNUSED,\n \t\t       bool *again,\n-\t\t       riscv_pcgp_relocs *pcgp_relocs ATTRIBUTE_UNUSED,\n+\t\t       riscv_pcgp_relocs *pcgp_relocs,\n \t\t       bool undefined_weak ATTRIBUTE_UNUSED)\n {\n   bfd_byte *contents = elf_section_data (sec)->this_hdr.contents;\n@@ -4243,7 +4279,7 @@ _bfd_riscv_relax_call (bfd *abfd, asection *sec, asection *sym_sec,\n   /* Delete unnecessary JALR.  */\n   *again = true;\n   return riscv_relax_delete_bytes (abfd, sec, rel->r_offset + len, 8 - len,\n-\t\t\t\t   link_info);\n+\t\t\t\t   link_info, pcgp_relocs);\n }\n \n /* Traverse all output sections and return the max alignment.  */\n@@ -4275,7 +4311,7 @@ _bfd_riscv_relax_lui (bfd *abfd,\n \t\t      bfd_vma max_alignment,\n \t\t      bfd_vma reserve_size,\n \t\t      bool *again,\n-\t\t      riscv_pcgp_relocs *pcgp_relocs ATTRIBUTE_UNUSED,\n+\t\t      riscv_pcgp_relocs *pcgp_relocs,\n \t\t      bool undefined_weak)\n {\n   bfd_byte *contents = elf_section_data (sec)->this_hdr.contents;\n@@ -4337,7 +4373,7 @@ _bfd_riscv_relax_lui (bfd *abfd,\n \t  rel->r_info = ELFNN_R_INFO (0, R_RISCV_NONE);\n \t  *again = true;\n \t  return riscv_relax_delete_bytes (abfd, sec, rel->r_offset, 4,\n-\t\t\t\t\t   link_info);\n+\t\t\t\t\t   link_info, pcgp_relocs);\n \n \tdefault:\n \t  abort ();\n@@ -4370,7 +4406,7 @@ _bfd_riscv_relax_lui (bfd *abfd,\n \n       *again = true;\n       return riscv_relax_delete_bytes (abfd, sec, rel->r_offset + 2, 2,\n-\t\t\t\t       link_info);\n+\t\t\t\t       link_info, pcgp_relocs);\n     }\n \n   return true;\n@@ -4388,7 +4424,7 @@ _bfd_riscv_relax_tls_le (bfd *abfd,\n \t\t\t bfd_vma max_alignment ATTRIBUTE_UNUSED,\n \t\t\t bfd_vma reserve_size ATTRIBUTE_UNUSED,\n \t\t\t bool *again,\n-\t\t\t riscv_pcgp_relocs *prcel_relocs ATTRIBUTE_UNUSED,\n+\t\t\t riscv_pcgp_relocs *pcgp_relocs,\n \t\t\t bool undefined_weak ATTRIBUTE_UNUSED)\n {\n   /* See if this symbol is in range of tp.  */\n@@ -4411,7 +4447,8 @@ _bfd_riscv_relax_tls_le (bfd *abfd,\n       /* We can delete the unnecessary instruction and reloc.  */\n       rel->r_info = ELFNN_R_INFO (0, R_RISCV_NONE);\n       *again = true;\n-      return riscv_relax_delete_bytes (abfd, sec, rel->r_offset, 4, link_info);\n+      return riscv_relax_delete_bytes (abfd, sec, rel->r_offset, 4, link_info,\n+\t\t\t\t       pcgp_relocs);\n \n     default:\n       abort ();\n@@ -4430,7 +4467,7 @@ _bfd_riscv_relax_align (bfd *abfd, asection *sec,\n \t\t\tbfd_vma max_alignment ATTRIBUTE_UNUSED,\n \t\t\tbfd_vma reserve_size ATTRIBUTE_UNUSED,\n \t\t\tbool *again ATTRIBUTE_UNUSED,\n-\t\t\triscv_pcgp_relocs *pcrel_relocs ATTRIBUTE_UNUSED,\n+\t\t\triscv_pcgp_relocs *pcgp_relocs ATTRIBUTE_UNUSED,\n \t\t\tbool undefined_weak ATTRIBUTE_UNUSED)\n {\n   bfd_byte *contents = elf_section_data (sec)->this_hdr.contents;\n@@ -4442,6 +4479,9 @@ _bfd_riscv_relax_align (bfd *abfd, asection *sec,\n   bfd_vma aligned_addr = ((symval - 1) & ~(alignment - 1)) + alignment;\n   bfd_vma nop_bytes = aligned_addr - symval;\n \n+  /* Once we've handled an R_RISCV_ALIGN, we can't relax anything else.  */\n+  sec->sec_flg0 = true;\n+\n   /* Make sure there are enough NOPs to actually achieve the alignment.  */\n   if (rel->r_addend < nop_bytes)\n     {\n@@ -4471,7 +4511,8 @@ _bfd_riscv_relax_align (bfd *abfd, asection *sec,\n \n   /* Delete the excess bytes.  */\n   return riscv_relax_delete_bytes (abfd, sec, rel->r_offset + nop_bytes,\n-\t\t\t\t   rel->r_addend - nop_bytes, link_info);\n+\t\t\t\t   rel->r_addend - nop_bytes, link_info,\n+\t\t\t\t   NULL);\n }\n \n /* Relax PC-relative references to GP-relative references.  */\n@@ -4637,15 +4678,14 @@ _bfd_riscv_relax_delete (bfd *abfd,\n \t\t\t bfd_vma symval ATTRIBUTE_UNUSED,\n \t\t\t bfd_vma max_alignment ATTRIBUTE_UNUSED,\n \t\t\t bfd_vma reserve_size ATTRIBUTE_UNUSED,\n-\t\t\t bool *again,\n+\t\t\t bool *again ATTRIBUTE_UNUSED,\n \t\t\t riscv_pcgp_relocs *pcgp_relocs ATTRIBUTE_UNUSED,\n \t\t\t bool undefined_weak ATTRIBUTE_UNUSED)\n {\n   if (!riscv_relax_delete_bytes (abfd, sec, rel->r_offset, rel->r_addend,\n-\t\t\t\t link_info))\n+\t\t\t\t link_info, NULL))\n     return false;\n   rel->r_info = ELFNN_R_INFO (0, R_RISCV_NONE);\n-  *again = true;\n   return true;\n }\n \n@@ -4660,35 +4700,11 @@ bfd_elfNN_riscv_set_data_segment_info (struct bfd_link_info *info,\n   htab->data_segment_phase = data_segment_phase;\n }\n \n-/* Called by after_allocation to check if we need to run the whole\n-   relaxations again.  */\n-\n-bool\n-bfd_elfNN_riscv_restart_relax_sections (struct bfd_link_info *info)\n-{\n-  struct riscv_elf_link_hash_table *htab = riscv_elf_hash_table (info);\n-  bool restart = htab->restart_relax;\n-  /* Reset the flag.  */\n-  htab->restart_relax = false;\n-  return restart;\n-}\n-\n /* Relax a section.\n \n-   Pass 0: Shortens code sequences for LUI/CALL/TPREL relocs.\n-   Pass 1: Shortens code sequences for PCREL relocs.\n-   Pass 2: Deletes the bytes that pass 1 made obsolete.\n-   Pass 3: Which cannot be disabled, handles code alignment directives.\n-\n-   The `again` is used to determine whether the relax pass itself needs to\n-   run again.  And the `restart_relax` is used to determine if we need to\n-   run the whole relax passes again from 0 to 2.  Once we have deleted the\n-   code between relax pass 0 to 2, the restart_relax will be set to TRUE,\n-   and we should run the whole relaxations again to give them more chances\n-   to shorten the code.\n-\n-   Since we can't relax anything else once we start to handle the alignments,\n-   we will only enter into the relax pass 3 when the restart_relax is FALSE.  */\n+   Pass 0: Shortens code sequences for LUI/CALL/TPREL/PCREL relocs.\n+   Pass 1: Deletes the bytes that PCREL relaxation in pass 0 made obsolete.\n+   Pass 2: Which cannot be disabled, handles code alignment directives.  */\n \n static bool\n _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n@@ -4707,12 +4723,11 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n   *again = false;\n \n   if (bfd_link_relocatable (info)\n+      || sec->sec_flg0\n       || (sec->flags & SEC_RELOC) == 0\n       || sec->reloc_count == 0\n       || (info->disable_target_specific_optimizations\n-\t  && info->relax_pass < 2)\n-      || (htab->restart_relax\n-\t  && info->relax_pass == 3)\n+\t  && info->relax_pass == 0)\n       /* The exp_seg_relro_adjust is enum phase_enum (0x4),\n \t and defined in ld/ldexp.h.  */\n       || *(htab->data_segment_phase) == 4)\n@@ -4765,24 +4780,14 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n \t\t   || type == R_RISCV_TPREL_LO12_I\n \t\t   || type == R_RISCV_TPREL_LO12_S)\n \t    relax_func = _bfd_riscv_relax_tls_le;\n+\t  else if (!bfd_link_pic (info)\n+\t\t   && (type == R_RISCV_PCREL_HI20\n+\t\t       || type == R_RISCV_PCREL_LO12_I\n+\t\t       || type == R_RISCV_PCREL_LO12_S))\n+\t    relax_func = _bfd_riscv_relax_pc;\n \t  else\n \t    continue;\n-\t}\n-      else if (info->relax_pass == 1\n-\t       && !bfd_link_pic (info)\n-\t       && (type == R_RISCV_PCREL_HI20\n-\t\t   || type == R_RISCV_PCREL_LO12_I\n-\t\t   || type == R_RISCV_PCREL_LO12_S))\n-\trelax_func = _bfd_riscv_relax_pc;\n-      else if (info->relax_pass == 2 && type == R_RISCV_DELETE)\n-\trelax_func = _bfd_riscv_relax_delete;\n-      else if (info->relax_pass == 3 && type == R_RISCV_ALIGN)\n-\trelax_func = _bfd_riscv_relax_align;\n-      else\n-\tcontinue;\n \n-      if (info->relax_pass < 2)\n-\t{\n \t  /* Only relax this reloc if it is paired with R_RISCV_RELAX.  */\n \t  if (i == sec->reloc_count - 1\n \t      || ELFNN_R_TYPE ((rel + 1)->r_info) != R_RISCV_RELAX\n@@ -4792,6 +4797,12 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n \t  /* Skip over the R_RISCV_RELAX.  */\n \t  i++;\n \t}\n+      else if (info->relax_pass == 1 && type == R_RISCV_DELETE)\n+\trelax_func = _bfd_riscv_relax_delete;\n+      else if (info->relax_pass == 2 && type == R_RISCV_ALIGN)\n+\trelax_func = _bfd_riscv_relax_align;\n+      else\n+\tcontinue;\n \n       data->relocs = relocs;\n \n@@ -4954,9 +4965,6 @@ _bfd_riscv_relax_section (bfd *abfd, asection *sec,\n     free (relocs);\n   riscv_free_pcgp_relocs (&pcgp_relocs, abfd, sec);\n \n-  if (*again)\n-    htab->restart_relax = true;\n-\n   return ret;\n }\n "
    },
    {
      "sha": "3af8fd99d9a173f121dd1e5b86d7434eb1251ca3",
      "filename": "bfd/elfxx-riscv.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/bfd/elfxx-riscv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/bfd/elfxx-riscv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-riscv.h?ref=9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
      "patch": "@@ -92,11 +92,6 @@ riscv_estimate_digit (unsigned);\n extern int\n riscv_compare_subsets (const char *, const char *);\n \n-extern bool\n-bfd_elf32_riscv_restart_relax_sections (struct bfd_link_info *);\n-extern bool\n-bfd_elf64_riscv_restart_relax_sections (struct bfd_link_info *);\n-\n extern void\n bfd_elf32_riscv_set_data_segment_info (struct bfd_link_info *, int *);\n extern void"
    },
    {
      "sha": "80b7b3707d5e73eca45e74c1aa771d72b3673664",
      "filename": "ld/emultempl/riscvelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/emultempl/riscvelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/emultempl/riscvelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/riscvelf.em?ref=9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
      "patch": "@@ -42,7 +42,7 @@ riscv_elf_before_allocation (void)\n \tENABLE_RELAXATION;\n     }\n \n-  link_info.relax_pass = 4;\n+  link_info.relax_pass = 3;\n }\n \n static void\n@@ -76,11 +76,7 @@ gld${EMULATION_NAME}_after_allocation (void)\n   enum phase_enum *phase = &(expld.dataseg.phase);\n   bfd_elf${ELFSIZE}_riscv_set_data_segment_info (&link_info, (int *) phase);\n \n-  do\n-    {\n-      ldelf_map_segments (need_layout);\n-    }\n-  while (bfd_elf${ELFSIZE}_riscv_restart_relax_sections (&link_info));\n+  ldelf_map_segments (need_layout);\n }\n \n /* This is a convenient point to tell BFD about target specific flags."
    },
    {
      "sha": "3799129c6651443953106c9c5dde3ec9fb3c504f",
      "filename": "ld/testsuite/ld-riscv-elf/align-small-region.d",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/testsuite/ld-riscv-elf/align-small-region.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/testsuite/ld-riscv-elf/align-small-region.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-riscv-elf/align-small-region.d?ref=9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
      "patch": "@@ -0,0 +1,12 @@\n+#source: align-small-region.s\n+#as: -march=rv32i\n+#ld: -melf32lriscv --relax -Talign-small-region.ld --defsym=_start=0x100\n+#objdump: -d\n+\n+.*:[ \t]+file format .*\n+\n+Disassembly of section \\.entry:\n+\n+00000000 <_reset>:\n+.*:[ \t]+[0-9a-f]+[ \t]+j[ \t]+100[ \t]+<_start>\n+#pass"
    },
    {
      "sha": "a5a37835c650af234197d4c98e1d1a7a9ec1a01d",
      "filename": "ld/testsuite/ld-riscv-elf/align-small-region.ld",
      "status": "added",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/testsuite/ld-riscv-elf/align-small-region.ld",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/testsuite/ld-riscv-elf/align-small-region.ld",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-riscv-elf/align-small-region.ld?ref=9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
      "patch": "@@ -0,0 +1,12 @@\n+MEMORY\n+{\n+ reset : ORIGIN = 0x0, LENGTH = 32\n+}\n+\n+SECTIONS\n+{\n+ .entry :\n+ {\n+ KEEP (*(.entry))\n+ } > reset\n+}"
    },
    {
      "sha": "1c0f3ccbe559a6f66c84de73e0134c05a4830e68",
      "filename": "ld/testsuite/ld-riscv-elf/align-small-region.s",
      "status": "added",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/testsuite/ld-riscv-elf/align-small-region.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/testsuite/ld-riscv-elf/align-small-region.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-riscv-elf/align-small-region.s?ref=9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
      "patch": "@@ -0,0 +1,7 @@\n+ .section .entry, \"xa\"\n+ .align 5\n+ .globl _reset\n+ .type _reset, @function\n+_reset:\n+ tail _start\n+ .size _reset, . - _reset"
    },
    {
      "sha": "20ca3bdb1959b71ca81490fb69999e5ae137c4be",
      "filename": "ld/testsuite/ld-riscv-elf/ld-riscv-elf.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/testsuite/ld-riscv-elf/ld-riscv-elf.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f/ld/testsuite/ld-riscv-elf/ld-riscv-elf.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-riscv-elf/ld-riscv-elf.exp?ref=9abcdc10b21ed9f98e218ead7ac9d91612f9ed0f",
      "patch": "@@ -119,6 +119,7 @@ proc run_relax_twice_test {} {\n }\n \n if [istarget \"riscv*-*-*\"] {\n+    run_dump_test \"align-small-region\"\n     run_dump_test \"call-relax\"\n     run_dump_test \"pcgp-relax\"\n     run_dump_test \"c-lui\"\n@@ -130,7 +131,6 @@ if [istarget \"riscv*-*-*\"] {\n     run_dump_test \"pcrel-lo-addend-3a\"\n     run_dump_test \"pcrel-lo-addend-3b\"\n     run_dump_test \"pcrel-lo-addend-3c\"\n-    run_dump_test \"restart-relax\"\n     run_dump_test \"attr-merge-arch-01\"\n     run_dump_test \"attr-merge-arch-02\"\n     run_dump_test \"attr-merge-arch-03\""
    },
    {
      "sha": "57b62eb20efc3f15be40bbcfa7779d353f70afe0",
      "filename": "ld/testsuite/ld-riscv-elf/restart-relax.d",
      "status": "removed",
      "additions": 0,
      "deletions": 14,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66cc044255f805fd052b9cb9352915cbdf3040b5/ld/testsuite/ld-riscv-elf/restart-relax.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66cc044255f805fd052b9cb9352915cbdf3040b5/ld/testsuite/ld-riscv-elf/restart-relax.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-riscv-elf/restart-relax.d?ref=66cc044255f805fd052b9cb9352915cbdf3040b5",
      "patch": "@@ -1,14 +0,0 @@\n-#source: restart-relax.s\n-#as:\n-#ld:\n-#objdump: -d\n-\n-#...\n-Disassembly of section .text:\n-\n-0+[0-9a-f]+ <_start>:\n-.*:[ \t]+[0-9a-f]+[ \t]+addi[ \t]+.*\n-#...\n-.*:[ \t]+[0-9a-f]+[ \t]+jal[ \t]+ra,[0-9a-f]+ <_start>\n-.*:[ \t]+[0-9a-f]+[ \t]+add[ \t]+a0,a1,a2\n-#pass"
    },
    {
      "sha": "efc881d14e0d08526d3fcd7f85598eada4ab50be",
      "filename": "ld/testsuite/ld-riscv-elf/restart-relax.s",
      "status": "removed",
      "additions": 0,
      "deletions": 17,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/66cc044255f805fd052b9cb9352915cbdf3040b5/ld/testsuite/ld-riscv-elf/restart-relax.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/66cc044255f805fd052b9cb9352915cbdf3040b5/ld/testsuite/ld-riscv-elf/restart-relax.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-riscv-elf/restart-relax.s?ref=66cc044255f805fd052b9cb9352915cbdf3040b5",
      "patch": "@@ -1,17 +0,0 @@\n-\t.text\n-\t.global _start\n-_start:\n-\tlla\ta0, data_g\n-.rept 0x3fffe\n-\tnop\n-.endr\n-\tcall _start\n-\t.option rvc\n-\t.align 2\n-\tadd\ta0, a1, a2\n-\n-\t.data\n-\t.global data_g\n-\t.dword 0x0\n-data_g:\n-\t.word 0x1000"
    }
  ]
}