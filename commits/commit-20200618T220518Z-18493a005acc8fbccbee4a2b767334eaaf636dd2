{
  "sha": "18493a005acc8fbccbee4a2b767334eaaf636dd2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTg0OTNhMDA1YWNjOGZiY2NiZWU0YTJiNzY3MzM0ZWFhZjYzNmRkMg==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-06-18T20:28:21Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-06-18T22:05:18Z"
    },
    "message": "Don't write to inferior_ptid in infrun.c\n\ngdb/ChangeLog:\n2020-06-18  Pedro Alves  <palves@redhat.com>\n\n\t* infrun.c (generic_mourn_inferior): Use switch_to_thread instead\n\tof writing to inferior_ptid.\n\t(scoped_restore_exited_inferior): Delete.\n\t(handle_vfork_child_exec_or_exit): Simplify using\n\tscoped_restore_current_pspace_and_thread.  Use switch_to_thread\n\tinstead of writing to inferior_ptid.\n\t(THREAD_STOPPED_BY): Delete.\n\t(thread_stopped_by_watchpoint, thread_stopped_by_sw_breakpoint)\n\t(thread_stopped_by_hw_breakpoint): Delete.\n\t(save_waitstatus): Use\n\tscoped_restore_current_thread+switch_to_thread, and call\n\ttarget_stopped_by_watchpoint instead of\n\tthread_stopped_by_watchpoint, target_stopped_by_sw_breakpoint\n\tinstead of thread_stopped_by_sw_breakpoint, and\n\ttarget_stopped_by_hw_breakpoint instead of\n\tthread_stopped_by_hw_breakpoint.\n\t(handle_inferior_event)\n\t<TARGET_WAITKIND_EXITED/TARGET_WAITKIND_SIGNALLED>: Don't write to\n\tinferior_ptid directly, nor\n\tset_current_inferior/set_current_program_space.  Use\n\tswitch_to_thread / switch_to_inferior_no_thread instead.",
    "tree": {
      "sha": "feefc799b5c90063c949a32f059fc76cda55a866",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/feefc799b5c90063c949a32f059fc76cda55a866"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/18493a005acc8fbccbee4a2b767334eaaf636dd2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/18493a005acc8fbccbee4a2b767334eaaf636dd2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/18493a005acc8fbccbee4a2b767334eaaf636dd2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/18493a005acc8fbccbee4a2b767334eaaf636dd2/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a0776b131d7a154125fdc4d22b1dda967c790ae9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a0776b131d7a154125fdc4d22b1dda967c790ae9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a0776b131d7a154125fdc4d22b1dda967c790ae9"
    }
  ],
  "stats": {
    "total": 125,
    "additions": 64,
    "deletions": 61
  },
  "files": [
    {
      "sha": "3af6af35de89295e09e3965f9c78a8497d42f790",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/18493a005acc8fbccbee4a2b767334eaaf636dd2/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/18493a005acc8fbccbee4a2b767334eaaf636dd2/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=18493a005acc8fbccbee4a2b767334eaaf636dd2",
      "patch": "@@ -1,3 +1,27 @@\n+2020-06-18  Pedro Alves  <palves@redhat.com>\n+\n+\t* infrun.c (generic_mourn_inferior): Use switch_to_thread instead\n+\tof writing to inferior_ptid.\n+\t(scoped_restore_exited_inferior): Delete.\n+\t(handle_vfork_child_exec_or_exit): Simplify using\n+\tscoped_restore_current_pspace_and_thread.  Use switch_to_thread\n+\tinstead of writing to inferior_ptid.\n+\t(THREAD_STOPPED_BY): Delete.\n+\t(thread_stopped_by_watchpoint, thread_stopped_by_sw_breakpoint)\n+\t(thread_stopped_by_hw_breakpoint): Delete.\n+\t(save_waitstatus): Use\n+\tscoped_restore_current_thread+switch_to_thread, and call\n+\ttarget_stopped_by_watchpoint instead of\n+\tthread_stopped_by_watchpoint, target_stopped_by_sw_breakpoint\n+\tinstead of thread_stopped_by_sw_breakpoint, and\n+\ttarget_stopped_by_hw_breakpoint instead of\n+\tthread_stopped_by_hw_breakpoint.\n+\t(handle_inferior_event)\n+\t<TARGET_WAITKIND_EXITED/TARGET_WAITKIND_SIGNALLED>: Don't write to\n+\tinferior_ptid directly, nor\n+\tset_current_inferior/set_current_program_space.  Use\n+\tswitch_to_thread / switch_to_inferior_no_thread instead.\n+\n 2020-06-18  Pedro Alves  <palves@redhat.com>\n \n \t* target.c (generic_mourn_inferior): Use switch_to_no_thread"
    },
    {
      "sha": "7bc405f103844cc527ba2c4b186b9f0d2123d9af",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 40,
      "deletions": 61,
      "changes": 101,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/18493a005acc8fbccbee4a2b767334eaaf636dd2/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/18493a005acc8fbccbee4a2b767334eaaf636dd2/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=18493a005acc8fbccbee4a2b767334eaaf636dd2",
      "patch": "@@ -485,8 +485,8 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t  switch_to_no_thread ();\n \t  child_inf->symfile_flags = SYMFILE_NO_READ;\n \t  push_target (parent_inf->process_target ());\n-\t  add_thread_silent (child_inf->process_target (), child_ptid);\n-\t  inferior_ptid = child_ptid;\n+\t  thread_info *child_thr\n+\t    = add_thread_silent (child_inf->process_target (), child_ptid);\n \n \t  /* If this is a vfork child, then the address-space is\n \t     shared with the parent.  */\n@@ -504,6 +504,11 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t      child_inf->pending_detach = 0;\n \t      parent_inf->vfork_child = child_inf;\n \t      parent_inf->pending_detach = 0;\n+\n+\t      /* Now that the inferiors and program spaces are all\n+\t\t wired up, we can switch to the child thread (which\n+\t\t switches inferior and program space too).  */\n+\t      switch_to_thread (child_thr);\n \t    }\n \t  else\n \t    {\n@@ -513,6 +518,10 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t      set_current_program_space (child_inf->pspace);\n \t      clone_program_space (child_inf->pspace, parent_inf->pspace);\n \n+\t      /* solib_create_inferior_hook relies on the current\n+\t\t thread.  */\n+\t      switch_to_thread (child_thr);\n+\n \t      /* Let the shared library layer (e.g., solib-svr4) learn\n \t\t about this new process, relocate the cloned exec, pull\n \t\t in shared libraries, and install the solib event\n@@ -628,8 +637,7 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \tpush_target (target);\n       }\n \n-      add_thread_silent (target, child_ptid);\n-      inferior_ptid = child_ptid;\n+      thread_info *child_thr = add_thread_silent (target, child_ptid);\n \n       /* If this is a vfork child, then the address-space is shared\n \t with the parent.  If we detached from the parent, then we can\n@@ -657,6 +665,8 @@ holding the child stopped.  Try \\\"set detach-on-fork\\\" or \\\n \t     the core, this wouldn't be required.  */\n \t  solib_create_inferior_hook (0);\n \t}\n+\n+      switch_to_thread (child_thr);\n     }\n \n   return target_follow_fork (follow_child, detach_fork);\n@@ -904,22 +914,6 @@ proceed_after_vfork_done (struct thread_info *thread,\n   return 0;\n }\n \n-/* Save/restore inferior_ptid, current program space and current\n-   inferior.  Only use this if the current context points at an exited\n-   inferior (and therefore there's no current thread to save).  */\n-class scoped_restore_exited_inferior\n-{\n-public:\n-  scoped_restore_exited_inferior ()\n-    : m_saved_ptid (&inferior_ptid)\n-  {}\n-\n-private:\n-  scoped_restore_tmpl<ptid_t> m_saved_ptid;\n-  scoped_restore_current_program_space m_pspace;\n-  scoped_restore_current_inferior m_inferior;\n-};\n-\n /* Called whenever we notice an exec or exit event, to handle\n    detaching or resuming a vfork parent.  */\n \n@@ -942,28 +936,17 @@ handle_vfork_child_exec_or_exit (int exec)\n \t time.  */\n       if (vfork_parent->pending_detach)\n \t{\n-\t  struct thread_info *tp;\n \t  struct program_space *pspace;\n \t  struct address_space *aspace;\n \n \t  /* follow-fork child, detach-on-fork on.  */\n \n \t  vfork_parent->pending_detach = 0;\n \n-\t  gdb::optional<scoped_restore_exited_inferior>\n-\t    maybe_restore_inferior;\n-\t  gdb::optional<scoped_restore_current_pspace_and_thread>\n-\t    maybe_restore_thread;\n-\n-\t  /* If we're handling a child exit, then inferior_ptid points\n-\t     at the inferior's pid, not to a thread.  */\n-\t  if (!exec)\n-\t    maybe_restore_inferior.emplace ();\n-\t  else\n-\t    maybe_restore_thread.emplace ();\n+\t  scoped_restore_current_pspace_and_thread restore_thread;\n \n \t  /* We're letting loose of the parent.  */\n-\t  tp = any_live_thread_of_inferior (vfork_parent);\n+\t  thread_info *tp = any_live_thread_of_inferior (vfork_parent);\n \t  switch_to_thread (tp);\n \n \t  /* We're about to detach from the parent, which implicitly\n@@ -1032,11 +1015,11 @@ handle_vfork_child_exec_or_exit (int exec)\n \t     go ahead and create a new one for this exiting\n \t     inferior.  */\n \n-\t  /* Switch to null_ptid while running clone_program_space, so\n+\t  /* Switch to no-thread while running clone_program_space, so\n \t     that clone_program_space doesn't want to read the\n \t     selected frame of a dead process.  */\n-\t  scoped_restore restore_ptid\n-\t    = make_scoped_restore (&inferior_ptid, null_ptid);\n+\t  scoped_restore_current_thread restore_thread;\n+\t  switch_to_no_thread ();\n \n \t  inf->pspace = new program_space (maybe_new_address_space ());\n \t  inf->aspace = inf->pspace->aspace;\n@@ -4622,25 +4605,6 @@ wait_one ()\n     }\n }\n \n-/* Generate a wrapper for target_stopped_by_REASON that works on PTID\n-   instead of the current thread.  */\n-#define THREAD_STOPPED_BY(REASON)\t\t\\\n-static int\t\t\t\t\t\\\n-thread_stopped_by_ ## REASON (ptid_t ptid)\t\\\n-{\t\t\t\t\t\t\\\n-  scoped_restore save_inferior_ptid = make_scoped_restore (&inferior_ptid); \\\n-  inferior_ptid = ptid;\t\t\t\t\\\n-\t\t\t\t\t\t\\\n-  return target_stopped_by_ ## REASON ();\t\\\n-}\n-\n-/* Generate thread_stopped_by_watchpoint.  */\n-THREAD_STOPPED_BY (watchpoint)\n-/* Generate thread_stopped_by_sw_breakpoint.  */\n-THREAD_STOPPED_BY (sw_breakpoint)\n-/* Generate thread_stopped_by_hw_breakpoint.  */\n-THREAD_STOPPED_BY (hw_breakpoint)\n-\n /* Save the thread's event and stop reason to process it later.  */\n \n static void\n@@ -4672,19 +4636,22 @@ save_waitstatus (struct thread_info *tp, const target_waitstatus *ws)\n \n       adjust_pc_after_break (tp, &tp->suspend.waitstatus);\n \n-      if (thread_stopped_by_watchpoint (tp->ptid))\n+      scoped_restore_current_thread restore_thread;\n+      switch_to_thread (tp);\n+\n+      if (target_stopped_by_watchpoint ())\n \t{\n \t  tp->suspend.stop_reason\n \t    = TARGET_STOPPED_BY_WATCHPOINT;\n \t}\n       else if (target_supports_stopped_by_sw_breakpoint ()\n-\t       && thread_stopped_by_sw_breakpoint (tp->ptid))\n+\t       && target_stopped_by_sw_breakpoint ())\n \t{\n \t  tp->suspend.stop_reason\n \t    = TARGET_STOPPED_BY_SW_BREAKPOINT;\n \t}\n       else if (target_supports_stopped_by_hw_breakpoint ()\n-\t       && thread_stopped_by_hw_breakpoint (tp->ptid))\n+\t       && target_stopped_by_hw_breakpoint ())\n \t{\n \t  tp->suspend.stop_reason\n \t    = TARGET_STOPPED_BY_HW_BREAKPOINT;\n@@ -5338,9 +5305,21 @@ handle_inferior_event (struct execution_control_state *ecs)\n \n     case TARGET_WAITKIND_EXITED:\n     case TARGET_WAITKIND_SIGNALLED:\n-      inferior_ptid = ecs->ptid;\n-      set_current_inferior (find_inferior_ptid (ecs->target, ecs->ptid));\n-      set_current_program_space (current_inferior ()->pspace);\n+      {\n+\t/* Depending on the system, ecs->ptid may point to a thread or\n+\t   to a process.  On some targets, target_mourn_inferior may\n+\t   need to have access to the just-exited thread.  That is the\n+\t   case of GNU/Linux's \"checkpoint\" support, for example.\n+\t   Call the switch_to_xxx routine as appropriate.  */\n+\tthread_info *thr = find_thread_ptid (ecs->target, ecs->ptid);\n+\tif (thr != nullptr)\n+\t  switch_to_thread (thr);\n+\telse\n+\t  {\n+\t    inferior *inf = find_inferior_ptid (ecs->target, ecs->ptid);\n+\t    switch_to_inferior_no_thread (inf);\n+\t  }\n+      }\n       handle_vfork_child_exec_or_exit (0);\n       target_terminal::ours ();\t/* Must do this before mourn anyway.  */\n "
    }
  ]
}