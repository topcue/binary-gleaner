{
  "sha": "14a8ad62e6a7885296d234c3765bfab08df3dc6f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTRhOGFkNjJlNmE3ODg1Mjk2ZDIzNGMzNzY1YmZhYjA4ZGYzZGM2Zg==",
  "commit": {
    "author": {
      "name": "Samuel Thibault",
      "email": "samuel.thibault@ens-lyon.org",
      "date": "2020-05-31T07:42:10Z"
    },
    "committer": {
      "name": "Samuel Thibault",
      "email": "samuel.thibault@ens-lyon.org",
      "date": "2020-05-31T07:42:10Z"
    },
    "message": "gnu-nat: Move local functions inside gnu_nat_target class\n\nThis allows to have the process_stratum_target object at hand for future use in\nthe gdb API, and only use gnu_target from external calls.\n\ngdb/Changelog:\n\n\t* gnu-nat.h (inf_validate_procs, inf_suspend, inf_set_traced,\n\tsteal_exc_port, proc_get_state, inf_clear_wait, inf_cleanup,\n\tinf_startup, inf_update_suspends, inf_set_pid, inf_steal_exc_ports,\n\tinf_validate_procinfo, inf_validate_task_sc, inf_restore_exc_ports,\n\tinf_set_threads_resume_sc, inf_set_threads_resume_sc_for_signal_thread,\n\tinf_resume, inf_set_step_thread, inf_detach, inf_attach, inf_signal,\n\tinf_continue, make_proc, proc_abort, _proc_free, proc_update_sc,\n\tproc_get_exception_port, proc_set_exception_port, _proc_get_exc_port,\n\tproc_steal_exc_port, proc_restore_exc_port, proc_trace): Move functions\n\tto gnu_nat_target class.\n\t* gnu-nat.c: Likewise.\n\t(inf_update_procs, S_proc_wait_reply, set_task_pause_cmd,\n\tset_task_exc_port_cmd, set_signals_cmd, set_thread_pause_cmd,\n\tset_thread_exc_port_cmd): Call inf_validate_procs through gnu_target\n\tobject.\n\t(gnu_nat_target::create_inferior, gnu_nat_target::detach): Pass `this'\n\tinstead of `gnu_target'.",
    "tree": {
      "sha": "5bc2090a36258c3f8397142e67c0a95637859bbe",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5bc2090a36258c3f8397142e67c0a95637859bbe"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/14a8ad62e6a7885296d234c3765bfab08df3dc6f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/14a8ad62e6a7885296d234c3765bfab08df3dc6f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/14a8ad62e6a7885296d234c3765bfab08df3dc6f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/14a8ad62e6a7885296d234c3765bfab08df3dc6f/comments",
  "author": {
    "login": "sthibaul",
    "id": 5405051,
    "node_id": "MDQ6VXNlcjU0MDUwNTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5405051?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/sthibaul",
    "html_url": "https://github.com/sthibaul",
    "followers_url": "https://api.github.com/users/sthibaul/followers",
    "following_url": "https://api.github.com/users/sthibaul/following{/other_user}",
    "gists_url": "https://api.github.com/users/sthibaul/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/sthibaul/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/sthibaul/subscriptions",
    "organizations_url": "https://api.github.com/users/sthibaul/orgs",
    "repos_url": "https://api.github.com/users/sthibaul/repos",
    "events_url": "https://api.github.com/users/sthibaul/events{/privacy}",
    "received_events_url": "https://api.github.com/users/sthibaul/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "sthibaul",
    "id": 5405051,
    "node_id": "MDQ6VXNlcjU0MDUwNTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5405051?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/sthibaul",
    "html_url": "https://github.com/sthibaul",
    "followers_url": "https://api.github.com/users/sthibaul/followers",
    "following_url": "https://api.github.com/users/sthibaul/following{/other_user}",
    "gists_url": "https://api.github.com/users/sthibaul/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/sthibaul/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/sthibaul/subscriptions",
    "organizations_url": "https://api.github.com/users/sthibaul/orgs",
    "repos_url": "https://api.github.com/users/sthibaul/repos",
    "events_url": "https://api.github.com/users/sthibaul/events{/privacy}",
    "received_events_url": "https://api.github.com/users/sthibaul/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "40dba2056227af4b1d9855b40adc5fb32505b0a5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/40dba2056227af4b1d9855b40adc5fb32505b0a5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/40dba2056227af4b1d9855b40adc5fb32505b0a5"
    }
  ],
  "stats": {
    "total": 203,
    "additions": 115,
    "deletions": 88
  },
  "files": [
    {
      "sha": "a974b43afd47e59372cfe2132828aef4d4af4c31",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14a8ad62e6a7885296d234c3765bfab08df3dc6f/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14a8ad62e6a7885296d234c3765bfab08df3dc6f/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=14a8ad62e6a7885296d234c3765bfab08df3dc6f",
      "patch": "@@ -1,3 +1,23 @@\n+2020-05-30  Samuel Thibault  <samuel.thibault@ens-lyon.org>\n+\n+\t* gnu-nat.h (inf_validate_procs, inf_suspend, inf_set_traced,\n+\tsteal_exc_port, proc_get_state, inf_clear_wait, inf_cleanup,\n+\tinf_startup, inf_update_suspends, inf_set_pid, inf_steal_exc_ports,\n+\tinf_validate_procinfo, inf_validate_task_sc, inf_restore_exc_ports,\n+\tinf_set_threads_resume_sc, inf_set_threads_resume_sc_for_signal_thread,\n+\tinf_resume, inf_set_step_thread, inf_detach, inf_attach, inf_signal,\n+\tinf_continue, make_proc, proc_abort, _proc_free, proc_update_sc,\n+\tproc_get_exception_port, proc_set_exception_port, _proc_get_exc_port,\n+\tproc_steal_exc_port, proc_restore_exc_port, proc_trace): Move functions\n+\tto gnu_nat_target class.\n+\t* gnu-nat.c: Likewise.\n+\t(inf_update_procs, S_proc_wait_reply, set_task_pause_cmd,\n+\tset_task_exc_port_cmd, set_signals_cmd, set_thread_pause_cmd,\n+\tset_thread_exc_port_cmd): Call inf_validate_procs through gnu_target\n+\tobject.\n+\t(gnu_nat_target::create_inferior, gnu_nat_target::detach): Pass `this'\n+\tinstead of `gnu_target'.\n+\n 2020-05-30  Samuel Thibault  <samuel.thibault@ens-lyon.org>\n \n \t* i386-gnu-tdep.c: Include \"gdbcore.h\""
    },
    {
      "sha": "bb277da4b97c488fce81ceed4903d607967f6287",
      "filename": "gdb/gnu-nat.c",
      "status": "modified",
      "additions": 52,
      "deletions": 82,
      "changes": 134,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14a8ad62e6a7885296d234c3765bfab08df3dc6f/gdb/gnu-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14a8ad62e6a7885296d234c3765bfab08df3dc6f/gdb/gnu-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.c?ref=14a8ad62e6a7885296d234c3765bfab08df3dc6f",
      "patch": "@@ -101,42 +101,12 @@ bool gnu_debug_flag = false;\n /* Forward decls */\n \n static struct inf *make_inf ();\n-void inf_clear_wait (struct inf *inf);\n-void inf_cleanup (struct inf *inf);\n-void inf_startup (struct inf *inf, int pid);\n-int inf_update_suspends (struct inf *inf);\n-void inf_set_pid (struct inf *inf, pid_t pid);\n-void inf_validate_procs (struct inf *inf);\n-void inf_steal_exc_ports (struct inf *inf);\n-void inf_restore_exc_ports (struct inf *inf);\n-void inf_set_threads_resume_sc (struct inf *inf,\n-\t\t\t\tstruct proc *run_thread,\n-\t\t\t\tint run_others);\n-int inf_set_threads_resume_sc_for_signal_thread (struct inf *inf);\n-void inf_suspend (struct inf *inf);\n-void inf_resume (struct inf *inf);\n-void inf_set_step_thread (struct inf *inf, struct proc *proc);\n-void inf_detach (struct inf *inf);\n-void inf_attach (struct inf *inf, int pid);\n-void inf_signal (struct inf *inf, enum gdb_signal sig);\n-void inf_continue (struct inf *inf);\n \n #define inf_debug(_inf, msg, args...) \\\n   do { struct inf *__inf = (_inf); \\\n        debug (\"{inf %d %s}: \" msg, __inf->pid, \\\n        host_address_to_string (__inf) , ##args); } while (0)\n \n-void proc_abort (struct proc *proc, int force);\n-struct proc *make_proc (struct inf *inf, mach_port_t port, int tid);\n-struct proc *_proc_free (struct proc *proc);\n-int proc_update_sc (struct proc *proc);\n-kern_return_t proc_get_exception_port (struct proc *proc, mach_port_t * port);\n-kern_return_t proc_set_exception_port (struct proc *proc, mach_port_t port);\n-static mach_port_t _proc_get_exc_port (struct proc *proc);\n-void proc_steal_exc_port (struct proc *proc, mach_port_t exc_port);\n-void proc_restore_exc_port (struct proc *proc);\n-int proc_trace (struct proc *proc, int set);\n-\n /* Evaluate RPC_EXPR in a scope with the variables MSGPORT and REFPORT bound\n    to INF's msg port and task port respectively.  If it has no msg port,\n    EIEIO is returned.  INF must refer to a running process!  */\n@@ -265,7 +235,7 @@ __proc_pid (struct proc *proc)\n /* Update PROC's real suspend count to match it's desired one.  Returns true\n    if we think PROC is now in a runnable state.  */\n int\n-proc_update_sc (struct proc *proc)\n+gnu_nat_target::proc_update_sc (struct proc *proc)\n {\n   int running;\n   int err = 0;\n@@ -331,7 +301,7 @@ proc_update_sc (struct proc *proc)\n    In particular, a thread is precious if it's running (in which case forcing\n    it includes suspending it first), or if it has an exception pending.  */\n void\n-proc_abort (struct proc *proc, int force)\n+gnu_nat_target::proc_abort (struct proc *proc, int force)\n {\n   gdb_assert (proc_is_thread (proc));\n \n@@ -368,7 +338,7 @@ proc_abort (struct proc *proc, int force)\n    that the thread is stopped and aborted first, and sets the state_changed\n    field in PROC to true.  */\n thread_state_t\n-proc_get_state (struct proc *proc, int will_modify)\n+gnu_nat_target::proc_get_state (struct proc *proc, int will_modify)\n {\n   int was_aborted = proc->aborted;\n \n@@ -405,7 +375,7 @@ proc_get_state (struct proc *proc, int will_modify)\n \f\n /* Set PORT to PROC's exception port.  */\n kern_return_t\n-proc_get_exception_port (struct proc * proc, mach_port_t * port)\n+gnu_nat_target::proc_get_exception_port (struct proc * proc, mach_port_t * port)\n {\n   if (proc_is_task (proc))\n     return task_get_exception_port (proc->port, port);\n@@ -415,7 +385,7 @@ proc_get_exception_port (struct proc * proc, mach_port_t * port)\n \n /* Set PROC's exception port to PORT.  */\n kern_return_t\n-proc_set_exception_port (struct proc * proc, mach_port_t port)\n+gnu_nat_target::proc_set_exception_port (struct proc * proc, mach_port_t port)\n {\n   proc_debug (proc, \"setting exception port: %lu\", port);\n   if (proc_is_task (proc))\n@@ -425,8 +395,8 @@ proc_set_exception_port (struct proc * proc, mach_port_t port)\n }\n \n /* Get PROC's exception port, cleaning up a bit if proc has died.  */\n-static mach_port_t\n-_proc_get_exc_port (struct proc *proc)\n+mach_port_t\n+gnu_nat_target::_proc_get_exc_port (struct proc *proc)\n {\n   mach_port_t exc_port;\n   kern_return_t err = proc_get_exception_port (proc, &exc_port);\n@@ -449,7 +419,7 @@ _proc_get_exc_port (struct proc *proc)\n    been done.  Stash away any existing exception port so we can\n    restore it later.  */\n void\n-proc_steal_exc_port (struct proc *proc, mach_port_t exc_port)\n+gnu_nat_target::proc_steal_exc_port (struct proc *proc, mach_port_t exc_port)\n {\n   mach_port_t cur_exc_port = _proc_get_exc_port (proc);\n \n@@ -492,7 +462,7 @@ proc_steal_exc_port (struct proc *proc, mach_port_t exc_port)\n    found there at the time, unless *our* exception port has since been\n    overwritten, in which case who knows what's going on.  */\n void\n-proc_restore_exc_port (struct proc *proc)\n+gnu_nat_target::proc_restore_exc_port (struct proc *proc)\n {\n   mach_port_t cur_exc_port = _proc_get_exc_port (proc);\n \n@@ -522,7 +492,7 @@ proc_restore_exc_port (struct proc *proc)\n /* Turns hardware tracing in PROC on or off when SET is true or false,\n    respectively.  Returns true on success.  */\n int\n-proc_trace (struct proc *proc, int set)\n+gnu_nat_target::proc_trace (struct proc *proc, int set)\n {\n   thread_state_t state = proc_get_state (proc, 1);\n \n@@ -552,7 +522,7 @@ static int next_thread_id = 1;\n /* Returns a new proc structure with the given fields.  Also adds a\n    notification for PORT becoming dead to be sent to INF's notify port.  */\n struct proc *\n-make_proc (struct inf *inf, mach_port_t port, int tid)\n+gnu_nat_target::make_proc (struct inf *inf, mach_port_t port, int tid)\n {\n   kern_return_t err;\n   mach_port_t prev_port = MACH_PORT_NULL;\n@@ -616,7 +586,7 @@ make_proc (struct inf *inf, mach_port_t port, int tid)\n /* Frees PROC and any resources it uses, and returns the value of PROC's \n    next field.  */\n struct proc *\n-_proc_free (struct proc *proc)\n+gnu_nat_target::_proc_free (struct proc *proc)\n {\n   struct inf *inf = proc->inf;\n   struct proc *next = proc->next;\n@@ -685,7 +655,7 @@ make_inf (void)\n \n /* Clear INF's target wait status.  */\n void\n-inf_clear_wait (struct inf *inf)\n+gnu_nat_target::inf_clear_wait (struct inf *inf)\n {\n   inf_debug (inf, \"clearing wait\");\n   inf->wait.status.kind = TARGET_WAITKIND_SPURIOUS;\n@@ -705,7 +675,7 @@ inf_clear_wait (struct inf *inf)\n \n \f\n void\n-inf_cleanup (struct inf *inf)\n+gnu_nat_target::inf_cleanup (struct inf *inf)\n {\n   inf_debug (inf, \"cleanup\");\n \n@@ -728,7 +698,7 @@ inf_cleanup (struct inf *inf)\n }\n \n void\n-inf_startup (struct inf *inf, int pid)\n+gnu_nat_target::inf_startup (struct inf *inf, int pid)\n {\n   kern_return_t err;\n \n@@ -751,7 +721,7 @@ inf_startup (struct inf *inf, int pid)\n \f\n /* Close current process, if any, and attach INF to process PORT.  */\n void\n-inf_set_pid (struct inf *inf, pid_t pid)\n+gnu_nat_target::inf_set_pid (struct inf *inf, pid_t pid)\n {\n   task_t task_port;\n   struct proc *task = inf->task;\n@@ -803,8 +773,8 @@ inf_set_pid (struct inf *inf, pid_t pid)\n    proc server state.  Note that the traced field is only updated from\n    the proc server state if we do not have a message port.  If we do\n    have a message port we'd better look at the tracemask itself.  */\n-static void\n-inf_validate_procinfo (struct inf *inf)\n+void\n+gnu_nat_target::inf_validate_procinfo (struct inf *inf)\n {\n   char *noise;\n   mach_msg_type_number_t noise_len = 0;\n@@ -830,8 +800,8 @@ inf_validate_procinfo (struct inf *inf)\n \n /* Validates INF's task suspend count.  If it's higher than we expect,\n    verify with the user before `stealing' the extra count.  */\n-static void\n-inf_validate_task_sc (struct inf *inf)\n+void\n+gnu_nat_target::inf_validate_task_sc (struct inf *inf)\n {\n   char *noise;\n   mach_msg_type_number_t noise_len = 0;\n@@ -882,8 +852,8 @@ inf_validate_task_sc (struct inf *inf)\n    is.  If INF is running, the resume_sc count of INF's threads will\n    be modified, and the signal thread will briefly be run to change\n    the trace state.  */\n-static void\n-inf_set_traced (struct inf *inf, int on)\n+void\n+gnu_nat_target::inf_set_traced (struct inf *inf, int on)\n {\n   if (on == inf->traced)\n     return;\n@@ -919,7 +889,7 @@ inf_set_traced (struct inf *inf, int on)\n    counts in the safe order.  Returns true if at least one thread is\n    thought to be running.  */\n int\n-inf_update_suspends (struct inf *inf)\n+gnu_nat_target::inf_update_suspends (struct inf *inf)\n {\n   struct proc *task = inf->task;\n \n@@ -1010,7 +980,7 @@ inf_threads (struct inf *inf, inf_threads_ftype *f, void *arg)\n \f\n /* Make INF's list of threads be consistent with reality of TASK.  */\n void\n-inf_validate_procs (struct inf *inf)\n+gnu_nat_target::inf_validate_procs (struct inf *inf)\n {\n   thread_array_t threads;\n   mach_msg_type_number_t num_threads, i;\n@@ -1109,12 +1079,12 @@ inf_validate_procs (struct inf *inf)\n \t    if (inferior_ptid == ptid_t (inf->pid))\n \t      /* This is the first time we're hearing about thread\n \t\t ids, after a fork-child.  */\n-\t      thread_change_ptid (gnu_target, inferior_ptid, ptid);\n+\t      thread_change_ptid (this, inferior_ptid, ptid);\n \t    else if (inf->pending_execs != 0)\n \t      /* This is a shell thread.  */\n-\t      add_thread_silent (gnu_target, ptid);\n+\t      add_thread_silent (this, ptid);\n \t    else\n-\t      add_thread (gnu_target, ptid);\n+\t      add_thread (this, ptid);\n \t  }\n       }\n \n@@ -1131,16 +1101,16 @@ inf_update_procs (struct inf *inf)\n   if (!inf->task)\n     return 0;\n   if (!inf->threads_up_to_date)\n-    inf_validate_procs (inf);\n+    gnu_target->inf_validate_procs (inf);\n   return !!inf->task;\n }\n \n /* Sets the resume_sc of each thread in inf.  That of RUN_THREAD is set to 0,\n    and others are set to their run_sc if RUN_OTHERS is true, and otherwise\n    their pause_sc.  */\n void\n-inf_set_threads_resume_sc (struct inf *inf,\n-\t\t\t   struct proc *run_thread, int run_others)\n+gnu_nat_target::inf_set_threads_resume_sc (struct inf *inf,\n+\t\t\t\t\t   struct proc *run_thread, int run_others)\n {\n   struct proc *thread;\n \n@@ -1158,7 +1128,7 @@ inf_set_threads_resume_sc (struct inf *inf,\n /* Cause INF to continue execution immediately; individual threads may still\n    be suspended (but their suspend counts will be updated).  */\n void\n-inf_resume (struct inf *inf)\n+gnu_nat_target::inf_resume (struct inf *inf)\n {\n   struct proc *thread;\n \n@@ -1183,7 +1153,7 @@ inf_resume (struct inf *inf)\n /* Cause INF to stop execution immediately; individual threads may still\n    be running.  */\n void\n-inf_suspend (struct inf *inf)\n+gnu_nat_target::inf_suspend (struct inf *inf)\n {\n   struct proc *thread;\n \n@@ -1203,7 +1173,7 @@ inf_suspend (struct inf *inf)\n    function changes it to be PROC, changing any old step_thread to be\n    a normal one.  A PROC of 0 clears any existing value.  */\n void\n-inf_set_step_thread (struct inf *inf, struct proc *thread)\n+gnu_nat_target::inf_set_step_thread (struct inf *inf, struct proc *thread)\n {\n   gdb_assert (!thread || proc_is_thread (thread));\n \n@@ -1229,7 +1199,7 @@ inf_set_step_thread (struct inf *inf, struct proc *thread)\n    (plus whatever other thread are set to always run).  Returns true if we\n    did so, or false if we can't find a signal thread.  */\n int\n-inf_set_threads_resume_sc_for_signal_thread (struct inf *inf)\n+gnu_nat_target::inf_set_threads_resume_sc_for_signal_thread (struct inf *inf)\n {\n   if (inf->signal_thread)\n     {\n@@ -1251,7 +1221,7 @@ inf_update_signal_thread (struct inf *inf)\n \f\n /* Detachs from INF's inferior task, letting it run once again...  */\n void\n-inf_detach (struct inf *inf)\n+gnu_nat_target::inf_detach (struct inf *inf)\n {\n   struct proc *task = inf->task;\n \n@@ -1293,7 +1263,7 @@ inf_detach (struct inf *inf)\n /* Attaches INF to the process with process id PID, returning it in a\n    suspended state suitable for debugging.  */\n void\n-inf_attach (struct inf *inf, int pid)\n+gnu_nat_target::inf_attach (struct inf *inf, int pid)\n {\n   inf_debug (inf, \"attaching: %d\", pid);\n \n@@ -1306,7 +1276,7 @@ inf_attach (struct inf *inf, int pid)\n \f\n /* Makes sure that we've got our exception ports entrenched in the process.  */\n void\n-inf_steal_exc_ports (struct inf *inf)\n+gnu_nat_target::inf_steal_exc_ports (struct inf *inf)\n {\n   struct proc *thread;\n \n@@ -1321,7 +1291,7 @@ inf_steal_exc_ports (struct inf *inf)\n \n /* Makes sure the process has its own exception ports.  */\n void\n-inf_restore_exc_ports (struct inf *inf)\n+gnu_nat_target::inf_restore_exc_ports (struct inf *inf)\n {\n   struct proc *thread;\n \n@@ -1339,7 +1309,7 @@ inf_restore_exc_ports (struct inf *inf)\n    signal 0, will continue it.  INF is assumed to be in a paused state, and\n    the resume_sc's of INF's threads may be affected.  */\n void\n-inf_signal (struct inf *inf, enum gdb_signal sig)\n+gnu_nat_target::inf_signal (struct inf *inf, enum gdb_signal sig)\n {\n   kern_return_t err = 0;\n   int host_sig = gdb_signal_to_host (sig);\n@@ -1427,7 +1397,7 @@ inf_signal (struct inf *inf, enum gdb_signal sig)\n /* Continue INF without delivering a signal.  This is meant to be used\n    when INF does not have a message port.  */\n void\n-inf_continue (struct inf *inf)\n+gnu_nat_target::inf_continue (struct inf *inf)\n {\n   process_t proc;\n   kern_return_t err = proc_pid2proc (proc_server, inf->pid, &proc);\n@@ -1458,7 +1428,7 @@ struct inf *gnu_current_inf = 0;\n \n /* The inferior being waited for by gnu_wait.  Since GDB is decidely not\n    multi-threaded, we don't bother to lock this.  */\n-struct inf *waiting_inf;\n+static struct inf *waiting_inf;\n \n /* MIG stubs are not yet ready for C++ compilation.  */\n extern \"C\" int exc_server (mach_msg_header_t *, mach_msg_header_t *);\n@@ -1852,7 +1822,7 @@ S_proc_wait_reply (mach_port_t reply, kern_return_t err,\n \t  inf->no_wait = 1;\n \n \t  /* Since we can't see the inferior's signals, don't trap them.  */\n-\t  inf_set_traced (inf, 0);\n+\t  gnu_target->inf_set_traced (inf, 0);\n \t}\n     }\n   else if (pid == inf->pid)\n@@ -2155,7 +2125,7 @@ gnu_nat_target::create_inferior (const char *exec_file,\n   /* We have something that executes now.  We'll be running through\n      the shell at this point (if startup-with-shell is true), but the\n      pid shouldn't change.  */\n-  add_thread_silent (gnu_target, ptid_t (pid));\n+  add_thread_silent (this, ptid_t (pid));\n \n   /* Attach to the now stopped child, which is actually a shell...  */\n   inf_debug (inf, \"attaching to child: %d\", pid);\n@@ -2171,7 +2141,7 @@ gnu_nat_target::create_inferior (const char *exec_file,\n   inf_resume (inf);\n \n   /* We now have thread info.  */\n-  thread_change_ptid (gnu_target, inferior_ptid,\n+  thread_change_ptid (this, inferior_ptid,\n \t\t      ptid_t (inf->pid, inf_pick_first_thread (), 0));\n \n   gdb_startup_inferior (pid, START_INFERIOR_TRAPS_EXPECTED);\n@@ -2277,7 +2247,7 @@ gnu_nat_target::detach (inferior *inf, int from_tty)\n   inf_detach (gnu_current_inf);\n \n   inferior_ptid = null_ptid;\n-  detach_inferior (find_inferior_pid (gnu_target, pid));\n+  detach_inferior (find_inferior_pid (this, pid));\n \n   maybe_unpush_target ();\n }\n@@ -2842,7 +2812,7 @@ set_task_pause_cmd (int arg, int from_tty)\n   if (old_sc == 0 && inf->pause_sc != 0)\n     /* If the task is currently unsuspended, immediately suspend it,\n        otherwise wait until the next time it gets control.  */\n-    inf_suspend (inf);\n+    gnu_target->inf_suspend (inf);\n }\n \n static void\n@@ -2938,8 +2908,8 @@ show_thread_default_detach_sc_cmd (const char *args, int from_tty)\n \f\n /* Steal a send right called NAME in the inferior task, and make it PROC's\n    saved exception port.  */\n-static void\n-steal_exc_port (struct proc *proc, mach_port_t name)\n+void\n+gnu_nat_target::steal_exc_port (struct proc *proc, mach_port_t name)\n {\n   kern_return_t err;\n   mach_port_t port;\n@@ -2980,7 +2950,7 @@ set_task_exc_port_cmd (const char *args, int from_tty)\n \n   if (!args)\n     error (_(\"No argument to \\\"set task exception-port\\\" command.\"));\n-  steal_exc_port (inf->task, parse_and_eval_address (args));\n+  gnu_target->steal_exc_port (inf->task, parse_and_eval_address (args));\n }\n \n static void\n@@ -3040,7 +3010,7 @@ set_signals_cmd (int arg, int from_tty)\n \n   if (inf->task && inf->want_signals != inf->traced)\n     /* Make this take effect immediately in a running process.  */\n-    inf_set_traced (inf, inf->want_signals);\n+    gnu_target->inf_set_traced (inf, inf->want_signals);\n }\n \n static void\n@@ -3338,7 +3308,7 @@ set_thread_pause_cmd (const char *args, int from_tty)\n   if (old_sc == 0 && thread->pause_sc != 0 && thread->inf->pause_sc == 0)\n     /* If the task is currently unsuspended, immediately suspend it,\n        otherwise wait until the next time it gets control.  */\n-    inf_suspend (thread->inf);\n+    gnu_target->inf_suspend (thread->inf);\n }\n \n static void\n@@ -3399,7 +3369,7 @@ set_thread_exc_port_cmd (const char *args, int from_tty)\n \n   if (!args)\n     error (_(\"No argument to \\\"set thread exception-port\\\" command.\"));\n-  steal_exc_port (thread, parse_and_eval_address (args));\n+  gnu_target->steal_exc_port (thread, parse_and_eval_address (args));\n }\n \n #if 0"
    },
    {
      "sha": "0e7ff8d5aa93f34afbd880e829bdd4569f489141",
      "filename": "gdb/gnu-nat.h",
      "status": "modified",
      "additions": 43,
      "deletions": 6,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/14a8ad62e6a7885296d234c3765bfab08df3dc6f/gdb/gnu-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/14a8ad62e6a7885296d234c3765bfab08df3dc6f/gdb/gnu-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.h?ref=14a8ad62e6a7885296d234c3765bfab08df3dc6f",
      "patch": "@@ -96,12 +96,6 @@ struct proc\n \n extern int __proc_pid (struct proc *proc);\n \n-/* Make sure that the state field in PROC is up to date, and return a\n-   pointer to it, or 0 if something is wrong.  If WILL_MODIFY is true,\n-   makes sure that the thread is stopped and aborted first, and sets\n-   the state_changed field in PROC to true.  */\n-extern thread_state_t proc_get_state (struct proc *proc, int will_modify);\n-\n /* Return printable description of proc.  */\n extern char *proc_string (struct proc *proc);\n \n@@ -148,6 +142,49 @@ struct gnu_nat_target : public inf_child_target\n   bool thread_alive (ptid_t ptid) override;\n   std::string pid_to_str (ptid_t) override;\n   void stop (ptid_t) override;\n+\n+  void inf_validate_procs (struct inf *inf);\n+  void inf_suspend (struct inf *inf);\n+  void inf_set_traced (struct inf *inf, int on);\n+  void steal_exc_port (struct proc *proc, mach_port_t name);\n+\n+  /* Make sure that the state field in PROC is up to date, and return a\n+     pointer to it, or 0 if something is wrong.  If WILL_MODIFY is true,\n+     makes sure that the thread is stopped and aborted first, and sets\n+     the state_changed field in PROC to true.  */\n+  thread_state_t proc_get_state (struct proc *proc, int will_modify);\n+\n+private:\n+  void inf_clear_wait (struct inf *inf);\n+  void inf_cleanup (struct inf *inf);\n+  void inf_startup (struct inf *inf, int pid);\n+  int inf_update_suspends (struct inf *inf);\n+  void inf_set_pid (struct inf *inf, pid_t pid);\n+  void inf_steal_exc_ports (struct inf *inf);\n+  void inf_validate_procinfo (struct inf *inf);\n+  void inf_validate_task_sc (struct inf *inf);\n+  void inf_restore_exc_ports (struct inf *inf);\n+  void inf_set_threads_resume_sc (struct inf *inf,\n+  \t\t\t\tstruct proc *run_thread,\n+  \t\t\t\tint run_others);\n+  int inf_set_threads_resume_sc_for_signal_thread (struct inf *inf);\n+  void inf_resume (struct inf *inf);\n+  void inf_set_step_thread (struct inf *inf, struct proc *proc);\n+  void inf_detach (struct inf *inf);\n+  void inf_attach (struct inf *inf, int pid);\n+  void inf_signal (struct inf *inf, enum gdb_signal sig);\n+  void inf_continue (struct inf *inf);\n+\n+  struct proc *make_proc (struct inf *inf, mach_port_t port, int tid);\n+  void proc_abort (struct proc *proc, int force);\n+  struct proc *_proc_free (struct proc *proc);\n+  int proc_update_sc (struct proc *proc);\n+  kern_return_t proc_get_exception_port (struct proc *proc, mach_port_t * port);\n+  kern_return_t proc_set_exception_port (struct proc *proc, mach_port_t port);\n+  mach_port_t _proc_get_exc_port (struct proc *proc);\n+  void proc_steal_exc_port (struct proc *proc, mach_port_t exc_port);\n+  void proc_restore_exc_port (struct proc *proc);\n+  int proc_trace (struct proc *proc, int set);\n };\n \n /* The final/concrete instance.  */"
    }
  ]
}