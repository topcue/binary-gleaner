{
  "sha": "c202f69e5130fed314afa079ce30abaad4d34991",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzIwMmY2OWU1MTMwZmVkMzE0YWZhMDc5Y2UzMGFiYWFkNGQzNDk5MQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-10T12:52:10Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-11T01:08:24Z"
    },
    "message": "ubsan: cris: signed integer overflow\n\nThis was the following in print_with_operands\ncase 4:\n  number\n    = buffer[2] + buffer[3] * 256 + buffer[4] * 65536\n    + buffer[5] * 0x1000000;\nand buffer[5] * 0x1000000 can indeed overflow.  So to fix this we need\nto use unsigned arithmetic where overflow semantics are specified.\nBut number is a long, and the expression is int which will be sign\nextended to long.  If we make the expression unsigned it will be zero\nextended.  So make number an int32_t and rearrange a little for some\nof the places that need fixing.\n\n\t* cris-dis.c (print_with_operands): Avoid signed integer\n\toverflow when collecting bytes of a 32-bit integer.",
    "tree": {
      "sha": "c4e19f714b47d869d10de621416ebd7436d24ba6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c4e19f714b47d869d10de621416ebd7436d24ba6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c202f69e5130fed314afa079ce30abaad4d34991",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c202f69e5130fed314afa079ce30abaad4d34991",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c202f69e5130fed314afa079ce30abaad4d34991",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c202f69e5130fed314afa079ce30abaad4d34991/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0ef562a4b5da6bc1f16b2ea801b228acafd033d8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0ef562a4b5da6bc1f16b2ea801b228acafd033d8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0ef562a4b5da6bc1f16b2ea801b228acafd033d8"
    }
  ],
  "stats": {
    "total": 40,
    "additions": 21,
    "deletions": 19
  },
  "files": [
    {
      "sha": "6b76f158c952f54e32afc212f47f6ca997ed2fb8",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c202f69e5130fed314afa079ce30abaad4d34991/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c202f69e5130fed314afa079ce30abaad4d34991/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=c202f69e5130fed314afa079ce30abaad4d34991",
      "patch": "@@ -1,3 +1,8 @@\n+2019-12-11  Alan Modra  <amodra@gmail.com>\n+\n+\t* cris-dis.c (print_with_operands): Avoid signed integer\n+\toverflow when collecting bytes of a 32-bit integer.\n+\n 2019-12-11  Alan Modra  <amodra@gmail.com>\n \n \t* cr16-dis.c (EXTRACT, SBM): Rewrite."
    },
    {
      "sha": "c501ba002c66e9846d0e99c4fc1e0b861052a34c",
      "filename": "opcodes/cris-dis.c",
      "status": "modified",
      "additions": 16,
      "deletions": 19,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c202f69e5130fed314afa079ce30abaad4d34991/opcodes/cris-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c202f69e5130fed314afa079ce30abaad4d34991/opcodes/cris-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/cris-dis.c?ref=c202f69e5130fed314afa079ce30abaad4d34991",
      "patch": "@@ -850,32 +850,31 @@ print_with_operands (const struct cris_opcode *opcodep,\n       case 'n':\n \t{\n \t  /* Like N but pc-relative to the start of the insn.  */\n-\t  unsigned long number\n-\t    = (buffer[2] + buffer[3] * 256 + buffer[4] * 65536\n-\t       + buffer[5] * 0x1000000 + addr);\n+\t  int32_t number = (buffer[2] + buffer[3] * 256 + buffer[4] * 65536\n+\t\t\t    + buffer[5] * 0x1000000u);\n \n \t  /* Finish off and output previous formatted bytes.  */\n \t  *tp = 0;\n \t  if (temp[0])\n \t    (*info->fprintf_func) (info->stream, \"%s\", temp);\n \t  tp = temp;\n \n-\t  (*info->print_address_func) ((bfd_vma) number, info);\n+\t  (*info->print_address_func) (addr + number, info);\n \t}\n \tbreak;\n \n       case 'u':\n \t{\n \t  /* Like n but the offset is bits <3:0> in the instruction.  */\n-\t  unsigned long number = (buffer[0] & 0xf) * 2 + addr;\n+\t  unsigned int number = (buffer[0] & 0xf) * 2;\n \n \t  /* Finish off and output previous formatted bytes.  */\n \t  *tp = 0;\n \t  if (temp[0])\n \t    (*info->fprintf_func) (info->stream, \"%s\", temp);\n \t  tp = temp;\n \n-\t  (*info->print_address_func) ((bfd_vma) number, info);\n+\t  (*info->print_address_func) (addr + number, info);\n \t}\n \tbreak;\n \n@@ -889,7 +888,7 @@ print_with_operands (const struct cris_opcode *opcodep,\n \t  {\n \t    /* We're looking at [pc+], i.e. we need to output an immediate\n \t       number, where the size can depend on different things.  */\n-\t    long number;\n+\t    int32_t number;\n \t    int signedp\n \t      = ((*cs == 'z' && (insn & 0x20))\n \t\t || opcodep->match == BDAP_QUICK_OPCODE);\n@@ -940,9 +939,8 @@ print_with_operands (const struct cris_opcode *opcodep,\n \t\tbreak;\n \n \t      case 4:\n-\t\tnumber\n-\t\t  = buffer[2] + buffer[3] * 256 + buffer[4] * 65536\n-\t\t  + buffer[5] * 0x1000000;\n+\t\tnumber = (buffer[2] + buffer[3] * 256 + buffer[4] * 65536\n+\t\t\t  + buffer[5] * 0x1000000u);\n \t\tbreak;\n \n \t      default:\n@@ -1042,10 +1040,10 @@ print_with_operands (const struct cris_opcode *opcodep,\n \t\t      {\n \t\t\t/* It's [pc+].  This cannot possibly be anything\n \t\t\t   but an address.  */\n-\t\t\tunsigned long number\n-\t\t\t  = prefix_buffer[2] + prefix_buffer[3] * 256\n-\t\t\t  + prefix_buffer[4] * 65536\n-\t\t\t  + prefix_buffer[5] * 0x1000000;\n+\t\t\tint32_t number = (prefix_buffer[2]\n+\t\t\t\t\t  + prefix_buffer[3] * 256\n+\t\t\t\t\t  + prefix_buffer[4] * 65536\n+\t\t\t\t\t  + prefix_buffer[5] * 0x1000000u);\n \n \t\t\tinfo->target = (bfd_vma) number;\n \n@@ -1131,7 +1129,7 @@ print_with_operands (const struct cris_opcode *opcodep,\n \n \t\t    if ((prefix_insn & 0x400) && (prefix_insn & 15) == 15)\n \t\t      {\n-\t\t\tlong number;\n+\t\t\tint32_t number;\n \t\t\tunsigned int nbytes;\n \n \t\t\t/* It's a value.  Get its size.  */\n@@ -1157,10 +1155,9 @@ print_with_operands (const struct cris_opcode *opcodep,\n \t\t\t    break;\n \n \t\t\t  case 4:\n-\t\t\t    number\n-\t\t\t      = prefix_buffer[2] + prefix_buffer[3] * 256\n-\t\t\t      + prefix_buffer[4] * 65536\n-\t\t\t      + prefix_buffer[5] * 0x1000000;\n+\t\t\t    number = (prefix_buffer[2] + prefix_buffer[3] * 256\n+\t\t\t\t      + prefix_buffer[4] * 65536\n+\t\t\t\t      + prefix_buffer[5] * 0x1000000u);\n \t\t\t    break;\n \n \t\t\t  default:"
    }
  ]
}