{
  "sha": "5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWNkZTgwOWI3YjlkYTNhZDNhYTBkNjVmMGU1ZTkyYWIxOTlkNjRmMA==",
  "commit": {
    "author": {
      "name": "Cary Coutant",
      "email": "ccoutant@gmail.com",
      "date": "2021-03-18T04:31:15Z"
    },
    "committer": {
      "name": "Cary Coutant",
      "email": "ccoutant@gmail.com",
      "date": "2021-03-19T20:55:35Z"
    },
    "message": "Add DWARF 5 support in gold.\n\nelfcpp/\n\tPR gold/27246\n\t* dwarf.h (enum DW_LNCT): Add line number table content type codes.\n\t(enum DW_LINE_OPS): Reformat.\n\t(enum DW_LINE_EXTENDED_OPS): Reformat.\n\t(enum DW_CHILDREN): Reformat.\n\t(enum DW_RLE): Add range list entry types.\n\t(enum DW_SECT): Update values for DWARF 5.\n\ngold/\n\tPR gold/27246\n\t* dwarf_reader.cc (Dwarf_abbrev_table::do_get_abbrev): Handle\n\tDW_FORM_implicit_const.\n\t(Dwarf_ranges_table::read_ranges_table): Add version parameter;\n\tAdjust all callers.  Look for .debug_rnglists section if DWARF 5.\n\t(Dwarf_ranges_table::read_range_list_v5): New method.\n\t(Dwarf_die::read_attributes): Handle new DWARF 5 DW_FORM codes.\n\t(Dwarf_die::skip_attributes): Likewise.\n\t(Dwarf_info_reader::do_parse): Support DWARF 5 unit header format.\n\t(Dwarf_info_reader::read_3bytes_from_pointer): New method.\n\t(Sized_dwarf_line_info::Sized_dwarf_line_info): Initialize\n\tstr_buffer_, str_buffer_start, reloc_map_, line_number_map_.\n\tLook for .debug_line_str section.\n\t(Sized_dwarf_line_info::read_header_prolog): Support DWARF 5 prolog.\n\t(Sized_dwarf_line_info::read_header_tables): Rename to...\n\t(Sized_dwarf_line_info::read_header_tables_v2): ... this.\n\t(Sized_dwarf_line_info::read_header_tables_v5): New method.\n\t(Sized_dwarf_line_info::process_one_opcode): Insert missing \"this->\".\n\tChange advance_line to signed int64_t.\n\t(Sized_dwarf_line_info::read_lines): Add endptr parameter; adjust\n\tcallers.  Insert missing \"this->\".\n\t(Sized_dwarf_line_info::read_line_mappings): Support DWARF 5.\n\t(Sized_dwarf_line_info::do_addr2line): Add debug code.\n\t* dwarf_reader.h (Dwarf_abbrev_table::Attribute): Add implicit_const\n\tfield. Adjust constructor.\n\t(Dwarf_abbrev_table::add_sttribute): Add implicit_const parameter.\n\t(Dwarf_ranges_table::read_ranges_table): Add version parameter.\n\t(Dwarf_ranges_table::read_range_list_v5): New method.\n\t(Dwarf_die): Remove unused attr_off field.\n\t(Dwarf_info_reader::Dwarf_info_reader): Initialize unit_type_ field.\n\t(Dwarf_info_reader::is_type_unit): New method.\n\t(Dwarf_info_reader::read_3bytes_from_pointer): New method.\n\t(Dwarf_info_reader::read_range_list): Call read_range_list_v5 for\n\tDWARF 5 range lists.\n\t(Dwarf_info_reader::is_type_unit_): Remove.\n\t(Dwarf_info_reader::unit_type_): New field.\n\t(Sized_dwarf_line_info::~Sized_dwarf_line_info): Delete\n\tstr_buffer_start_.\n\t(Sized_dwarf_line_info::read_header_tables): Rename to...\n\t(Sized_dwarf_line_info::read_header_tables_v2): ... this.\n\t(Sized_dwarf_line_info::read_header_tables_v5): New method.\n\t(Sized_dwarf_line_info::read_lines): Add endptr parameter.\n\t(Sized_dwarf_line_info::Dwarf_line_infoHeader): Add address_size field.\n\t(Sized_dwarf_line_info::str_buffer_): New field.\n\t(Sized_dwarf_line_info::str_buffer_end_): New field.\n\t(Sized_dwarf_line_info::str_buffer_start_): New field.\n\t(Sized_dwarf_line_info::end_of_header_length_): New field.\n\t(Sized_dwarf_line_info::end_of_unit_): New field.",
    "tree": {
      "sha": "35266cd948da34e9848af2519d2faef4b813d260",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/35266cd948da34e9848af2519d2faef4b813d260"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/comments",
  "author": {
    "login": "ccoutant",
    "id": 1442098,
    "node_id": "MDQ6VXNlcjE0NDIwOTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1442098?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ccoutant",
    "html_url": "https://github.com/ccoutant",
    "followers_url": "https://api.github.com/users/ccoutant/followers",
    "following_url": "https://api.github.com/users/ccoutant/following{/other_user}",
    "gists_url": "https://api.github.com/users/ccoutant/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ccoutant/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ccoutant/subscriptions",
    "organizations_url": "https://api.github.com/users/ccoutant/orgs",
    "repos_url": "https://api.github.com/users/ccoutant/repos",
    "events_url": "https://api.github.com/users/ccoutant/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ccoutant/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ccoutant",
    "id": 1442098,
    "node_id": "MDQ6VXNlcjE0NDIwOTg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1442098?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ccoutant",
    "html_url": "https://github.com/ccoutant",
    "followers_url": "https://api.github.com/users/ccoutant/followers",
    "following_url": "https://api.github.com/users/ccoutant/following{/other_user}",
    "gists_url": "https://api.github.com/users/ccoutant/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ccoutant/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ccoutant/subscriptions",
    "organizations_url": "https://api.github.com/users/ccoutant/orgs",
    "repos_url": "https://api.github.com/users/ccoutant/repos",
    "events_url": "https://api.github.com/users/ccoutant/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ccoutant/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e0d6d274068b02d952852b18adb3feaca1d2bb8a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e0d6d274068b02d952852b18adb3feaca1d2bb8a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e0d6d274068b02d952852b18adb3feaca1d2bb8a"
    }
  ],
  "stats": {
    "total": 844,
    "additions": 715,
    "deletions": 129
  },
  "files": [
    {
      "sha": "afc32c9b065b28ed90e76bd5eef057cb519dabde",
      "filename": "elfcpp/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/elfcpp/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/elfcpp/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/elfcpp/ChangeLog?ref=5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
      "patch": "@@ -1,3 +1,13 @@\n+2021-03-19  Cary Coutant  <ccoutant@gmail.com>\n+\n+\tPR gold/27246\n+\t* dwarf.h (enum DW_LNCT): Add line number table content type codes.\n+\t(enum DW_LINE_OPS): Reformat.\n+\t(enum DW_LINE_EXTENDED_OPS): Reformat.\n+\t(enum DW_CHILDREN): Reformat.\n+\t(enum DW_RLE): Add range list entry types.\n+\t(enum DW_SECT): Update values for DWARF 5.\n+\n 2021-01-09  Nick Clifton  <nickc@redhat.com>\n \n \t* 2.36 release branch crated."
    },
    {
      "sha": "c9a9e02369cef636aa3fb354be89d6eea73d9635",
      "filename": "elfcpp/dwarf.h",
      "status": "modified",
      "additions": 61,
      "deletions": 28,
      "changes": 89,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/elfcpp/dwarf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/elfcpp/dwarf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/elfcpp/dwarf.h?ref=5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
      "patch": "@@ -152,35 +152,48 @@ enum DW_EH_PE\n   DW_EH_PE_indirect = 0x80\n };\n \n+// Line number table content type codes.\n+\n+enum DW_LNCT\n+{\n+  DW_LNCT_path            = 0x1,\n+  DW_LNCT_directory_index = 0x2,\n+  DW_LNCT_timestamp       = 0x3,\n+  DW_LNCT_size            = 0x4,\n+  DW_LNCT_MD5             = 0x5,\n+  DW_LNCT_lo_user         = 0x2000,\n+  DW_LNCT_hi_user         = 0x3fff\n+};\n+\n // Line number opcodes.\n \n enum DW_LINE_OPS\n {\n-  DW_LNS_extended_op = 0,\n-  DW_LNS_copy = 1,\n-  DW_LNS_advance_pc = 2,\n-  DW_LNS_advance_line = 3,\n-  DW_LNS_set_file = 4,\n-  DW_LNS_set_column = 5,\n-  DW_LNS_negate_stmt = 6,\n-  DW_LNS_set_basic_block = 7,\n-  DW_LNS_const_add_pc = 8,\n-  DW_LNS_fixed_advance_pc = 9,\n+  DW_LNS_extended_op        = 0x00,\n+  DW_LNS_copy               = 0x01,\n+  DW_LNS_advance_pc         = 0x02,\n+  DW_LNS_advance_line       = 0x03,\n+  DW_LNS_set_file           = 0x04,\n+  DW_LNS_set_column         = 0x05,\n+  DW_LNS_negate_stmt        = 0x06,\n+  DW_LNS_set_basic_block    = 0x07,\n+  DW_LNS_const_add_pc       = 0x08,\n+  DW_LNS_fixed_advance_pc   = 0x09,\n   // DWARF 3.\n-  DW_LNS_set_prologue_end = 10,\n-  DW_LNS_set_epilogue_begin = 11,\n-  DW_LNS_set_isa = 12\n+  DW_LNS_set_prologue_end   = 0x0a,\n+  DW_LNS_set_epilogue_begin = 0x0b,\n+  DW_LNS_set_isa            = 0x0c\n };\n \n // Line number extended opcodes.\n \n enum DW_LINE_EXTENDED_OPS\n {\n-  DW_LNE_end_sequence = 1,\n-  DW_LNE_set_address = 2,\n-  DW_LNE_define_file = 3,\n+  DW_LNE_end_sequence                = 0x01,\n+  DW_LNE_set_address                 = 0x02,\n+  DW_LNE_define_file                 = 0x03,\n   // DWARF4.\n-  DW_LNE_set_discriminator = 4,\n+  DW_LNE_set_discriminator           = 0x04,\n   // HP extensions.\n   DW_LNE_HP_negate_is_UV_update      = 0x11,\n   DW_LNE_HP_push_context             = 0x12,\n@@ -191,13 +204,15 @@ enum DW_LINE_EXTENDED_OPS\n   DW_LNE_HP_negate_post_semantics    = 0x17,\n   DW_LNE_HP_negate_function_exit     = 0x18,\n   DW_LNE_HP_negate_front_end_logical = 0x19,\n-  DW_LNE_HP_define_proc              = 0x20\n+  DW_LNE_HP_define_proc              = 0x20,\n+  DW_LNE_lo_user                     = 0x80,\n+  DW_LNE_hi_user                     = 0xff\n };\n \n enum DW_CHILDREN\n {\n-  DW_CHILDREN_no\t\t     =0x00,\n-  DW_CHILDREN_yes\t\t     =0x01\n+  DW_CHILDREN_no  = 0,\n+  DW_CHILDREN_yes = 1\n };\n \n // Source language names and codes.\n@@ -247,20 +262,38 @@ enum DW_LANG\n   DW_LANG_HP_Assembler = 0x8007\n };\n \n+// Range list entry kinds in .debug_rnglists* section.\n+\n+enum DW_RLE\n+{\n+  DW_RLE_end_of_list   = 0x00,\n+  DW_RLE_base_addressx = 0x01,\n+  DW_RLE_startx_endx   = 0x02,\n+  DW_RLE_startx_length = 0x03,\n+  DW_RLE_offset_pair   = 0x04,\n+  DW_RLE_base_address  = 0x05,\n+  DW_RLE_start_end     = 0x06,\n+  DW_RLE_start_length  = 0x07\n+};\n+\n // DWARF section identifiers used in the package format.\n // Extensions for Fission.  See http://gcc.gnu.org/wiki/DebugFissionDWP.\n+// Added (with changes) in DWARF 5.\n \n enum DW_SECT\n {\n-  DW_SECT_INFO = 1,\n-  DW_SECT_TYPES = 2,\n-  DW_SECT_ABBREV = 3,\n-  DW_SECT_LINE = 4,\n-  DW_SECT_LOC = 5,\n+  DW_SECT_INFO        = 1,\n+  DW_SECT_ABBREV      = 3,\n+  DW_SECT_LINE        = 4,\n+  DW_SECT_LOCLISTS    = 5,\n   DW_SECT_STR_OFFSETS = 6,\n-  DW_SECT_MACINFO = 7,\n-  DW_SECT_MACRO = 8,\n-  DW_SECT_MAX = DW_SECT_MACRO,\n+  DW_SECT_MACINFO     = 7,\n+  DW_SECT_RNGLISTS    = 8,\n+  DW_SECT_MAX = DW_SECT_RNGLISTS,\n+  // These were used only for the experimental Fission support in DWARF 4.\n+  DW_SECT_TYPES       = 2,\n+  DW_SECT_LOC         = 5,\n+  DW_SECT_MACRO       = 8\n };\n \n } // End namespace elfcpp."
    },
    {
      "sha": "09e1fc505acc05a036837062a89c37e2dcf54f5c",
      "filename": "gold/ChangeLog",
      "status": "modified",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/gold/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/gold/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/ChangeLog?ref=5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
      "patch": "@@ -1,3 +1,54 @@\n+2021-03-19  Cary Coutant  <ccoutant@gmail.com>\n+\n+\tPR gold/27246\n+\t* dwarf_reader.cc (Dwarf_abbrev_table::do_get_abbrev): Handle\n+\tDW_FORM_implicit_const.\n+\t(Dwarf_ranges_table::read_ranges_table): Add version parameter;\n+\tAdjust all callers.  Look for .debug_rnglists section if DWARF 5.\n+\t(Dwarf_ranges_table::read_range_list_v5): New method.\n+\t(Dwarf_die::read_attributes): Handle new DWARF 5 DW_FORM codes.\n+\t(Dwarf_die::skip_attributes): Likewise.\n+\t(Dwarf_info_reader::do_parse): Support DWARF 5 unit header format.\n+\t(Dwarf_info_reader::read_3bytes_from_pointer): New method.\n+\t(Sized_dwarf_line_info::Sized_dwarf_line_info): Initialize\n+\tstr_buffer_, str_buffer_start, reloc_map_, line_number_map_.\n+\tLook for .debug_line_str section.\n+\t(Sized_dwarf_line_info::read_header_prolog): Support DWARF 5 prolog.\n+\t(Sized_dwarf_line_info::read_header_tables): Rename to...\n+\t(Sized_dwarf_line_info::read_header_tables_v2): ... this.\n+\t(Sized_dwarf_line_info::read_header_tables_v5): New method.\n+\t(Sized_dwarf_line_info::process_one_opcode): Insert missing \"this->\".\n+\tChange advance_line to signed int64_t.\n+\t(Sized_dwarf_line_info::read_lines): Add endptr parameter; adjust\n+\tcallers.  Insert missing \"this->\".\n+\t(Sized_dwarf_line_info::read_line_mappings): Support DWARF 5.\n+\t(Sized_dwarf_line_info::do_addr2line): Add debug code.\n+\t* dwarf_reader.h (Dwarf_abbrev_table::Attribute): Add implicit_const\n+\tfield. Adjust constructor.\n+\t(Dwarf_abbrev_table::add_sttribute): Add implicit_const parameter.\n+\t(Dwarf_ranges_table::read_ranges_table): Add version parameter.\n+\t(Dwarf_ranges_table::read_range_list_v5): New method.\n+\t(Dwarf_die): Remove unused attr_off field.\n+\t(Dwarf_info_reader::Dwarf_info_reader): Initialize unit_type_ field.\n+\t(Dwarf_info_reader::is_type_unit): New method.\n+\t(Dwarf_info_reader::read_3bytes_from_pointer): New method.\n+\t(Dwarf_info_reader::read_range_list): Call read_range_list_v5 for\n+\tDWARF 5 range lists.\n+\t(Dwarf_info_reader::is_type_unit_): Remove.\n+\t(Dwarf_info_reader::unit_type_): New field.\n+\t(Sized_dwarf_line_info::~Sized_dwarf_line_info): Delete\n+\tstr_buffer_start_.\n+\t(Sized_dwarf_line_info::read_header_tables): Rename to...\n+\t(Sized_dwarf_line_info::read_header_tables_v2): ... this.\n+\t(Sized_dwarf_line_info::read_header_tables_v5): New method.\n+\t(Sized_dwarf_line_info::read_lines): Add endptr parameter.\n+\t(Sized_dwarf_line_info::Dwarf_line_infoHeader): Add address_size field.\n+\t(Sized_dwarf_line_info::str_buffer_): New field.\n+\t(Sized_dwarf_line_info::str_buffer_end_): New field.\n+\t(Sized_dwarf_line_info::str_buffer_start_): New field.\n+\t(Sized_dwarf_line_info::end_of_header_length_): New field.\n+\t(Sized_dwarf_line_info::end_of_unit_): New field.\n+\n 2021-01-28  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR gold/27246"
    },
    {
      "sha": "83a0114ed39f7077250050c19157d04c9a8fd4cb",
      "filename": "gold/dwarf_reader.cc",
      "status": "modified",
      "additions": 513,
      "deletions": 78,
      "changes": 591,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/gold/dwarf_reader.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/gold/dwarf_reader.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/dwarf_reader.cc?ref=5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
      "patch": "@@ -26,6 +26,7 @@\n #include <utility>\n #include <vector>\n \n+#include \"debug.h\"\n #include \"elfcpp_swap.h\"\n #include \"dwarf.h\"\n #include \"object.h\"\n@@ -275,14 +276,22 @@ Dwarf_abbrev_table::do_get_abbrev(unsigned int code)\n \t  uint64_t form = read_unsigned_LEB_128(this->buffer_pos_, &len);\n \t  this->buffer_pos_ += len;\n \n+\t  // For DW_FORM_implicit_const, read the constant.\n+\t  int64_t implicit_const = 0;\n+\t  if (form == elfcpp::DW_FORM_implicit_const)\n+\t    {\n+\t      implicit_const = read_signed_LEB_128(this->buffer_pos_, &len);\n+\t      this->buffer_pos_ += len;\n+\t    }\n+\n \t  // A (0,0) pair terminates the list.\n \t  if (attr == 0 && form == 0)\n \t    break;\n \n \t  if (attr == elfcpp::DW_AT_sibling)\n \t    entry->has_sibling_attribute = true;\n \n-\t  entry->add_attribute(attr, form);\n+\t  entry->add_attribute(attr, form, implicit_const);\n \t}\n \n       this->store_abbrev(nextcode, entry);\n@@ -302,8 +311,16 @@ Dwarf_ranges_table::read_ranges_table(\n     Relobj* object,\n     const unsigned char* symtab,\n     off_t symtab_size,\n-    unsigned int ranges_shndx)\n+    unsigned int ranges_shndx,\n+    unsigned int version)\n {\n+  const std::string section_name(version < 5\n+\t\t\t\t ? \".debug_ranges\"\n+\t\t\t\t : \".debug_rnglists\");\n+  const std::string compressed_section_name(version < 5\n+\t\t\t\t\t    ? \".zdebug_ranges\"\n+\t\t\t\t\t    : \".zdebug_rnglists\");\n+\n   // If we've already read this abbrev table, return immediately.\n   if (this->ranges_shndx_ > 0\n       && this->ranges_shndx_ == ranges_shndx)\n@@ -318,7 +335,7 @@ Dwarf_ranges_table::read_ranges_table(\n       for (unsigned int i = 1; i < object->shnum(); ++i)\n \t{\n \t  std::string name = object->section_name(i);\n-\t  if (name == \".debug_ranges\" || name == \".zdebug_ranges\")\n+\t  if (name == section_name || name == compressed_section_name)\n \t    {\n \t      ranges_shndx = i;\n \t      this->output_section_offset_ = object->output_section_offset(i);\n@@ -393,7 +410,7 @@ Dwarf_ranges_table::read_range_list(\n {\n   Dwarf_range_list* ranges;\n \n-  if (!this->read_ranges_table(object, symtab, symtab_size, ranges_shndx))\n+  if (!this->read_ranges_table(object, symtab, symtab_size, ranges_shndx, 4))\n     return NULL;\n \n   // Correct the offset.  For incremental update links, we have a\n@@ -459,6 +476,125 @@ Dwarf_ranges_table::read_range_list(\n   return ranges;\n }\n \n+// Read a DWARF 5 range list from section RANGES_SHNDX at offset RANGES_OFFSET.\n+\n+Dwarf_range_list*\n+Dwarf_ranges_table::read_range_list_v5(\n+    Relobj* object,\n+    const unsigned char* symtab,\n+    off_t symtab_size,\n+    unsigned int addr_size,\n+    unsigned int ranges_shndx,\n+    off_t offset)\n+{\n+  Dwarf_range_list* ranges;\n+\n+  if (!this->read_ranges_table(object, symtab, symtab_size, ranges_shndx, 5))\n+    return NULL;\n+\n+  ranges = new Dwarf_range_list();\n+  off_t base = 0;\n+  unsigned int shndx0 = 0;\n+\n+  // Correct the offset.  For incremental update links, we have a\n+  // relocated offset that is relative to the output section, but\n+  // here we need an offset relative to the input section.\n+  offset -= this->output_section_offset_;\n+\n+  // Read the range list at OFFSET.\n+  const unsigned char* prle = this->ranges_buffer_ + offset;\n+  while (prle < this->ranges_buffer_end_)\n+    {\n+      off_t start;\n+      off_t end;\n+      unsigned int shndx1 = 0;\n+      unsigned int shndx2 = 0;\n+      size_t len;\n+\n+      // Read the entry type.\n+      unsigned int rle_type = *prle++;\n+      offset += 1;\n+\n+      if (rle_type == elfcpp::DW_RLE_end_of_list)\n+\tbreak;\n+\n+      switch (rle_type)\n+\t{\n+\t  case elfcpp::DW_RLE_base_address:\n+\t    if (addr_size == 4)\n+\t      base = this->dwinfo_->read_from_pointer<32>(prle);\n+\t    else\n+\t      base = this->dwinfo_->read_from_pointer<64>(prle);\n+\t    if (this->ranges_reloc_mapper_ != NULL)\n+\t\tshndx0 = this->lookup_reloc(offset, &base);\n+\t    prle += addr_size;\n+\t    offset += addr_size;\n+\t    break;\n+\n+\t  case elfcpp::DW_RLE_offset_pair:\n+\t    start = read_unsigned_LEB_128(prle, &len);\n+\t    prle += len;\n+\t    offset += len;\n+\t    end = read_unsigned_LEB_128(prle, &len);\n+\t    prle += len;\n+\t    offset += len;\n+\t    if (shndx0 == 0 || object->is_section_included(shndx0))\n+\t      ranges->add(shndx0, base + start, base + end);\n+\t    break;\n+\n+\t  case elfcpp::DW_RLE_start_end:\n+\t    if (addr_size == 4)\n+\t      {\n+\t\tstart = this->dwinfo_->read_from_pointer<32>(prle);\n+\t\tend = this->dwinfo_->read_from_pointer<32>(prle + 4);\n+\t      }\n+\t    else\n+\t      {\n+\t\tstart = this->dwinfo_->read_from_pointer<64>(prle);\n+\t\tend = this->dwinfo_->read_from_pointer<64>(prle + 8);\n+\t      }\n+\t    if (this->ranges_reloc_mapper_ != NULL)\n+\t      {\n+\t\tshndx1 = this->lookup_reloc(offset, &start);\n+\t\tshndx2 = this->lookup_reloc(offset + addr_size, &end);\n+\t\tif (shndx1 != shndx2)\n+\t\t  gold_warning(_(\"%s: DWARF info may be corrupt; offsets in a \"\n+\t\t\t\t \"range list entry are in different sections\"),\n+\t\t\t       object->name().c_str());\n+\t      }\n+\t    prle += addr_size * 2;\n+\t    offset += addr_size * 2;\n+\t    if (shndx1 == 0 || object->is_section_included(shndx1))\n+\t      ranges->add(shndx1, start, end);\n+\t    break;\n+\n+\t  case elfcpp::DW_RLE_start_length:\n+\t    if (addr_size == 4)\n+\t      start = this->dwinfo_->read_from_pointer<32>(prle);\n+\t    else\n+\t      start = this->dwinfo_->read_from_pointer<64>(prle);\n+\t    if (this->ranges_reloc_mapper_ != NULL)\n+\t      shndx1 = this->lookup_reloc(offset, &start);\n+\t    prle += addr_size;\n+\t    offset += addr_size;\n+\t    end = start + read_unsigned_LEB_128(prle, &len);\n+\t    prle += len;\n+\t    offset += len;\n+\t    if (shndx1 == 0 || object->is_section_included(shndx1))\n+\t      ranges->add(shndx1, start, end);\n+\t    break;\n+\n+\t  default:\n+\t    gold_warning(_(\"%s: DWARF range list contains \"\n+\t\t\t   \"unsupported entry type (%d)\"),\n+\t\t\t object->name().c_str(), rle_type);\n+\t    break;\n+\t}\n+    }\n+\n+  return ranges;\n+}\n+\n // Look for a relocation at offset OFF in the range table,\n // and return the section index and offset of the target.\n \n@@ -709,7 +845,13 @@ Dwarf_die::read_attributes()\n \t  case elfcpp::DW_FORM_flag_present:\n \t    attr_value.val.intval = 1;\n \t    break;\n+\t  case elfcpp::DW_FORM_implicit_const:\n+\t    attr_value.val.intval =\n+\t\tthis->abbrev_code_->attributes[i].implicit_const;\n+\t    break;\n \t  case elfcpp::DW_FORM_strp:\n+\t  case elfcpp::DW_FORM_strp_sup:\n+\t  case elfcpp::DW_FORM_line_strp:\n \t    {\n \t      off_t str_off;\n \t      if (this->dwinfo_->offset_size() == 4)\n@@ -722,6 +864,26 @@ Dwarf_die::read_attributes()\n \t      attr_value.val.refval = str_off;\n \t      break;\n \t    }\n+\t  case elfcpp::DW_FORM_strx:\n+\t  case elfcpp::DW_FORM_GNU_str_index:\n+\t    attr_value.val.uintval = read_unsigned_LEB_128(pattr, &len);\n+\t    pattr += len;\n+\t    break;\n+\t  case elfcpp::DW_FORM_strx1:\n+\t    attr_value.val.uintval = *pattr++;\n+\t    break;\n+\t  case elfcpp::DW_FORM_strx2:\n+\t    attr_value.val.uintval =\n+\t\tthis->dwinfo_->read_from_pointer<16>(&pattr);\n+\t    break;\n+\t  case elfcpp::DW_FORM_strx3:\n+\t    attr_value.val.uintval =\n+\t\tthis->dwinfo_->read_3bytes_from_pointer(&pattr);\n+\t    break;\n+\t  case elfcpp::DW_FORM_strx4:\n+\t    attr_value.val.uintval =\n+\t\tthis->dwinfo_->read_from_pointer<32>(&pattr);\n+\t    break;\n \t  case elfcpp::DW_FORM_sec_offset:\n \t    {\n \t      off_t sec_off;\n@@ -747,7 +909,6 @@ Dwarf_die::read_attributes()\n \t\t  this->dwinfo_->lookup_reloc(attr_off, &sec_off);\n \t      attr_value.aux.shndx = shndx;\n \t      attr_value.val.refval = sec_off;\n-\t      ref_form = true;\n \t      break;\n \t    }\n \t  case elfcpp::DW_FORM_ref_addr:\n@@ -815,6 +976,7 @@ Dwarf_die::read_attributes()\n \t      break;\n \t    }\n \t  case elfcpp::DW_FORM_ref4:\n+\t  case elfcpp::DW_FORM_ref_sup4:\n \t    {\n \t      off_t sec_off;\n \t      sec_off = this->dwinfo_->read_from_pointer<32>(&pattr);\n@@ -835,11 +997,20 @@ Dwarf_die::read_attributes()\n \t      attr_value.val.intval = sec_off;\n \t      break;\n \t    }\n+\t  case elfcpp::DW_FORM_data16:\n+\t    {\n+\t      // For now, treat this as a 16-byte block.\n+\t      attr_value.val.blockval = pattr;\n+\t      attr_value.aux.blocklen = 16;\n+\t      pattr += 16;\n+\t      break;\n+\t    }\n \t  case elfcpp::DW_FORM_ref_sig8:\n \t    attr_value.val.uintval =\n \t\tthis->dwinfo_->read_from_pointer<64>(&pattr);\n \t    break;\n \t  case elfcpp::DW_FORM_ref8:\n+\t  case elfcpp::DW_FORM_ref_sup8:\n \t    {\n \t      off_t sec_off;\n \t      sec_off = this->dwinfo_->read_from_pointer<64>(&pattr);\n@@ -856,11 +1027,29 @@ Dwarf_die::read_attributes()\n \t    pattr += len;\n \t    break;\n \t  case elfcpp::DW_FORM_udata:\n+\t    attr_value.val.uintval = read_unsigned_LEB_128(pattr, &len);\n+\t    pattr += len;\n+\t    break;\n+\t  case elfcpp::DW_FORM_addrx:\n \t  case elfcpp::DW_FORM_GNU_addr_index:\n-\t  case elfcpp::DW_FORM_GNU_str_index:\n \t    attr_value.val.uintval = read_unsigned_LEB_128(pattr, &len);\n \t    pattr += len;\n \t    break;\n+\t  case elfcpp::DW_FORM_addrx1:\n+\t    attr_value.val.uintval = *pattr++;\n+\t    break;\n+\t  case elfcpp::DW_FORM_addrx2:\n+\t    attr_value.val.uintval =\n+\t\tthis->dwinfo_->read_from_pointer<16>(&pattr);\n+\t    break;\n+\t  case elfcpp::DW_FORM_addrx3:\n+\t    attr_value.val.uintval =\n+\t\tthis->dwinfo_->read_3bytes_from_pointer(&pattr);\n+\t    break;\n+\t  case elfcpp::DW_FORM_addrx4:\n+\t    attr_value.val.uintval =\n+\t\tthis->dwinfo_->read_from_pointer<32>(&pattr);\n+\t    break;\n \t  case elfcpp::DW_FORM_sdata:\n \t    attr_value.val.intval = read_signed_LEB_128(pattr, &len);\n \t    pattr += len;\n@@ -870,6 +1059,11 @@ Dwarf_die::read_attributes()\n \t    len = strlen(attr_value.val.stringval);\n \t    pattr += len + 1;\n \t    break;\n+\t  case elfcpp::DW_FORM_loclistx:\n+\t  case elfcpp::DW_FORM_rnglistx:\n+\t    attr_value.val.uintval = read_unsigned_LEB_128(pattr, &len);\n+\t    pattr += len;\n+\t    break;\n \t  default:\n \t    return false;\n \t}\n@@ -954,9 +1148,12 @@ Dwarf_die::skip_attributes()\n       switch(form)\n \t{\n \t  case elfcpp::DW_FORM_flag_present:\n+\t  case elfcpp::DW_FORM_implicit_const:\n \t    break;\n \t  case elfcpp::DW_FORM_strp:\n \t  case elfcpp::DW_FORM_sec_offset:\n+\t  case elfcpp::DW_FORM_strp_sup:\n+\t  case elfcpp::DW_FORM_line_strp:\n \t    pattr += this->dwinfo_->offset_size();\n \t    break;\n \t  case elfcpp::DW_FORM_addr:\n@@ -993,23 +1190,42 @@ Dwarf_die::skip_attributes()\n \t  case elfcpp::DW_FORM_data1:\n \t  case elfcpp::DW_FORM_ref1:\n \t  case elfcpp::DW_FORM_flag:\n+\t  case elfcpp::DW_FORM_strx1:\n+\t  case elfcpp::DW_FORM_addrx1:\n \t    pattr += 1;\n \t    break;\n \t  case elfcpp::DW_FORM_data2:\n \t  case elfcpp::DW_FORM_ref2:\n+\t  case elfcpp::DW_FORM_strx2:\n+\t  case elfcpp::DW_FORM_addrx2:\n \t    pattr += 2;\n \t    break;\n+\t  case elfcpp::DW_FORM_strx3:\n+\t  case elfcpp::DW_FORM_addrx3:\n+\t    pattr += 3;\n+\t    break;\n \t  case elfcpp::DW_FORM_data4:\n \t  case elfcpp::DW_FORM_ref4:\n+\t  case elfcpp::DW_FORM_ref_sup4:\n+\t  case elfcpp::DW_FORM_strx4:\n+\t  case elfcpp::DW_FORM_addrx4:\n \t    pattr += 4;\n \t    break;\n \t  case elfcpp::DW_FORM_data8:\n \t  case elfcpp::DW_FORM_ref8:\n \t  case elfcpp::DW_FORM_ref_sig8:\n+\t  case elfcpp::DW_FORM_ref_sup8:\n \t    pattr += 8;\n \t    break;\n+\t  case elfcpp::DW_FORM_data16:\n+\t    pattr += 16;\n+\t    break;\n \t  case elfcpp::DW_FORM_ref_udata:\n \t  case elfcpp::DW_FORM_udata:\n+\t  case elfcpp::DW_FORM_addrx:\n+\t  case elfcpp::DW_FORM_strx:\n+\t  case elfcpp::DW_FORM_loclistx:\n+\t  case elfcpp::DW_FORM_rnglistx:\n \t  case elfcpp::DW_FORM_GNU_addr_index:\n \t  case elfcpp::DW_FORM_GNU_str_index:\n \t    read_unsigned_LEB_128(pattr, &len);\n@@ -1313,6 +1529,13 @@ Dwarf_info_reader::do_parse()\n \t  elfcpp::Swap_unaligned<16, big_endian>::readval(pinfo);\n       pinfo += 2;\n \n+      // DWARF 5: Read the unit type (1 byte) and address size (1 byte).\n+      if (this->cu_version_ >= 5)\n+\t{\n+\t  this->unit_type_ = *pinfo++;\n+\t  this->address_size_ = *pinfo++;\n+\t}\n+\n       // Read debug_abbrev_offset (4 or 8 bytes).\n       if (this->offset_size_ == 4)\n \tabbrev_offset = elfcpp::Swap_unaligned<32, big_endian>::readval(pinfo);\n@@ -1333,13 +1556,14 @@ Dwarf_info_reader::do_parse()\n \t}\n       pinfo += this->offset_size_;\n \n-      // Read address_size (1 byte).\n-      this->address_size_ = *pinfo++;\n+      // DWARF 2-4: Read address_size (1 byte).\n+      if (this->cu_version_ < 5)\n+\tthis->address_size_ = *pinfo++;\n \n       // For type units, read the two extra fields.\n       uint64_t signature = 0;\n       off_t type_offset = 0;\n-      if (this->is_type_unit_)\n+      if (this->is_type_unit())\n         {\n \t  if (!this->check_buffer(pinfo + 8 + this->offset_size_))\n \t    break;\n@@ -1369,7 +1593,7 @@ Dwarf_info_reader::do_parse()\n       if (root_die.tag() != 0)\n \t{\n \t  // Visit the CU or TU.\n-\t  if (this->is_type_unit_)\n+\t  if (this->is_type_unit())\n \t    this->visit_type_unit(section_offset + this->cu_offset_,\n \t\t\t\t  cu_end - cu_start, type_offset, signature,\n \t\t\t\t  &root_die);\n@@ -1460,6 +1684,19 @@ Dwarf_info_reader::read_from_pointer(const unsigned char** source)\n   return return_value;\n }\n \n+// Read a 3-byte integer.  Update SOURCE after read.\n+inline typename elfcpp::Valtype_base<32>::Valtype\n+Dwarf_info_reader::read_3bytes_from_pointer(const unsigned char** source)\n+{\n+  typename elfcpp::Valtype_base<32>::Valtype return_value;\n+  if (this->object_->is_big_endian())\n+    return_value = ((*source)[0] << 16) | ((*source)[1] << 8) | (*source)[2];\n+  else\n+    return_value = ((*source)[2] << 16) | ((*source)[1] << 8) | (*source)[0];\n+  *source += 3;\n+  return return_value;\n+}\n+\n // Look for a relocation at offset ATTR_OFF in the dwarf info,\n // and return the section index and offset of the target.\n \n@@ -1561,27 +1798,40 @@ Sized_dwarf_line_info<size, big_endian>::Sized_dwarf_line_info(\n     Object* object,\n     unsigned int read_shndx)\n   : data_valid_(false), buffer_(NULL), buffer_start_(NULL),\n+    str_buffer_(NULL), str_buffer_start_(NULL),\n     reloc_mapper_(NULL), symtab_buffer_(NULL), directories_(), files_(),\n-    current_header_index_(-1)\n+    current_header_index_(-1), reloc_map_(), line_number_map_()\n {\n-  unsigned int debug_shndx;\n+  unsigned int debug_line_shndx = 0;\n+  unsigned int debug_line_str_shndx = 0;\n \n-  for (debug_shndx = 1; debug_shndx < object->shnum(); ++debug_shndx)\n+  for (unsigned int i = 1; i < object->shnum(); ++i)\n     {\n+      section_size_type buffer_size;\n+      bool is_new = false;\n+\n       // FIXME: do this more efficiently: section_name() isn't super-fast\n-      std::string name = object->section_name(debug_shndx);\n+      std::string name = object->section_name(i);\n       if (name == \".debug_line\" || name == \".zdebug_line\")\n \t{\n-\t  section_size_type buffer_size;\n-\t  bool is_new = false;\n-\t  this->buffer_ = object->decompressed_section_contents(debug_shndx,\n-\t\t\t\t\t\t\t\t&buffer_size,\n-\t\t\t\t\t\t\t\t&is_new);\n+\t  this->buffer_ =\n+\t      object->decompressed_section_contents(i, &buffer_size, &is_new);\n \t  if (is_new)\n \t    this->buffer_start_ = this->buffer_;\n \t  this->buffer_end_ = this->buffer_ + buffer_size;\n-\t  break;\n+\t  debug_line_shndx = i;\n+\t}\n+      else if (name == \".debug_line_str\" || name == \".zdebug_line_str\")\n+\t{\n+\t  this->str_buffer_ =\n+\t      object->decompressed_section_contents(i, &buffer_size, &is_new);\n+\t  if (is_new)\n+\t    this->str_buffer_start_ = this->str_buffer_;\n+\t  this->str_buffer_end_ = this->str_buffer_ + buffer_size;\n+\t  debug_line_str_shndx = i;\n \t}\n+      if (debug_line_shndx > 0 && debug_line_str_shndx > 0)\n+        break;\n     }\n   if (this->buffer_ == NULL)\n     return;\n@@ -1594,7 +1844,7 @@ Sized_dwarf_line_info<size, big_endian>::Sized_dwarf_line_info(\n       unsigned int reloc_sh_type = object->section_type(i);\n       if ((reloc_sh_type == elfcpp::SHT_REL\n \t   || reloc_sh_type == elfcpp::SHT_RELA)\n-\t  && object->section_info(i) == debug_shndx)\n+\t  && object->section_info(i) == debug_line_shndx)\n \t{\n \t  reloc_shndx = i;\n \t  this->track_relocs_type_ = reloc_sh_type;\n@@ -1640,65 +1890,80 @@ Sized_dwarf_line_info<size, big_endian>::read_header_prolog(\n   uint32_t initial_length = elfcpp::Swap_unaligned<32, big_endian>::readval(lineptr);\n   lineptr += 4;\n \n-  // In DWARF2/3, if the initial length is all 1 bits, then the offset\n+  // In DWARF, if the initial length is all 1 bits, then the offset\n   // size is 8 and we need to read the next 8 bytes for the real length.\n   if (initial_length == 0xffffffff)\n     {\n-      header_.offset_size = 8;\n+      this->header_.offset_size = 8;\n       initial_length = elfcpp::Swap_unaligned<64, big_endian>::readval(lineptr);\n       lineptr += 8;\n     }\n   else\n-    header_.offset_size = 4;\n+    this->header_.offset_size = 4;\n \n-  header_.total_length = initial_length;\n+  this->header_.total_length = initial_length;\n \n-  gold_assert(lineptr + header_.total_length <= buffer_end_);\n+  this->end_of_unit_ = lineptr + initial_length;\n+  gold_assert(this->end_of_unit_ <= buffer_end_);\n \n-  header_.version = elfcpp::Swap_unaligned<16, big_endian>::readval(lineptr);\n+  this->header_.version =\n+      elfcpp::Swap_unaligned<16, big_endian>::readval(lineptr);\n   lineptr += 2;\n \n-  // Skip address size and segment selector for DWARF5.\n-  if (header_.version >= 5)\n-    lineptr += 2;\n+  // We can only read versions 2-5 of the DWARF line number table.\n+  // For other versions, just skip the entire line number table.\n+  if (this->header_.version < 2 || this->header_.version > 5)\n+    return this->end_of_unit_;\n \n-  if (header_.offset_size == 4)\n-    header_.prologue_length = elfcpp::Swap_unaligned<32, big_endian>::readval(lineptr);\n+  // DWARF 5 only: address size and segment selector.\n+  if (this->header_.version >= 5)\n+    {\n+      this->header_.address_size = *lineptr;\n+      // We ignore the segment selector.\n+      lineptr += 2;\n+    }\n+\n+  if (this->header_.offset_size == 4)\n+    this->header_.prologue_length =\n+\telfcpp::Swap_unaligned<32, big_endian>::readval(lineptr);\n   else\n-    header_.prologue_length = elfcpp::Swap_unaligned<64, big_endian>::readval(lineptr);\n-  lineptr += header_.offset_size;\n+    this->header_.prologue_length =\n+\telfcpp::Swap_unaligned<64, big_endian>::readval(lineptr);\n+  lineptr += this->header_.offset_size;\n \n-  header_.min_insn_length = *lineptr;\n+  this->end_of_header_length_ = lineptr;\n+\n+  this->header_.min_insn_length = *lineptr;\n   lineptr += 1;\n \n-  if (header_.version < 4)\n-    header_.max_ops_per_insn = 1;\n+  if (this->header_.version < 4)\n+    this->header_.max_ops_per_insn = 1;\n   else\n     {\n       // DWARF 4 added the maximum_operations_per_instruction field.\n-      header_.max_ops_per_insn = *lineptr;\n+      this->header_.max_ops_per_insn = *lineptr;\n       lineptr += 1;\n       // TODO: Add support for values other than 1.\n-      gold_assert(header_.max_ops_per_insn == 1);\n+      gold_assert(this->header_.max_ops_per_insn == 1);\n     }\n \n-  header_.default_is_stmt = *lineptr;\n+  this->header_.default_is_stmt = *lineptr;\n   lineptr += 1;\n \n-  header_.line_base = *reinterpret_cast<const signed char*>(lineptr);\n+  this->header_.line_base = *reinterpret_cast<const signed char*>(lineptr);\n   lineptr += 1;\n \n-  header_.line_range = *lineptr;\n+  this->header_.line_range = *lineptr;\n   lineptr += 1;\n \n-  header_.opcode_base = *lineptr;\n+  this->header_.opcode_base = *lineptr;\n   lineptr += 1;\n \n-  header_.std_opcode_lengths.resize(header_.opcode_base + 1);\n-  header_.std_opcode_lengths[0] = 0;\n-  for (int i = 1; i < header_.opcode_base; i++)\n+  this->header_.std_opcode_lengths.resize(this->header_.opcode_base + 1);\n+  this->header_.std_opcode_lengths[0] = 0;\n+  for (int i = 1; i < this->header_.opcode_base; i++)\n     {\n-      header_.std_opcode_lengths[i] = *lineptr;\n+      this->header_.std_opcode_lengths[i] = *lineptr;\n       lineptr += 1;\n     }\n \n@@ -1707,10 +1972,11 @@ Sized_dwarf_line_info<size, big_endian>::read_header_prolog(\n \n // The header for a debug_line section is mildly complicated, because\n // the line info is very tightly encoded.\n+// This routine is for DWARF versions 2, 3, and 4.\n \n template<int size, bool big_endian>\n const unsigned char*\n-Sized_dwarf_line_info<size, big_endian>::read_header_tables(\n+Sized_dwarf_line_info<size, big_endian>::read_header_tables_v2(\n     const unsigned char* lineptr)\n {\n   ++this->current_header_index_;\n@@ -1775,6 +2041,169 @@ Sized_dwarf_line_info<size, big_endian>::read_header_tables(\n   return lineptr;\n }\n \n+// This routine is for DWARF version 5.\n+\n+template<int size, bool big_endian>\n+const unsigned char*\n+Sized_dwarf_line_info<size, big_endian>::read_header_tables_v5(\n+    const unsigned char* lineptr)\n+{\n+  size_t len;\n+\n+  ++this->current_header_index_;\n+\n+  gold_assert(static_cast<int>(this->directories_.size())\n+\t      == this->current_header_index_);\n+  gold_assert(static_cast<int>(this->files_.size())\n+\t      == this->current_header_index_);\n+\n+  // Read the directory list.\n+  unsigned int format_count = *lineptr;\n+  lineptr += 1;\n+\n+  unsigned int *types = new unsigned int[format_count];\n+  unsigned int *forms = new unsigned int[format_count];\n+\n+  for (unsigned int i = 0; i < format_count; i++)\n+    {\n+      types[i] = read_unsigned_LEB_128(lineptr, &len);\n+      lineptr += len;\n+      forms[i] = read_unsigned_LEB_128(lineptr, &len);\n+      lineptr += len;\n+    }\n+\n+  uint64_t entry_count = read_unsigned_LEB_128(lineptr, &len);\n+  lineptr += len;\n+  this->directories_.push_back(std::vector<std::string>(0));\n+  std::vector<std::string>& dir_list = this->directories_.back();\n+\n+  for (unsigned int j = 0; j < entry_count; j++)\n+    {\n+      std::string dirname;\n+\n+      for (unsigned int i = 0; i < format_count; i++)\n+       {\n+\t if (types[i] == elfcpp::DW_LNCT_path)\n+\t   {\n+\t     if (forms[i] == elfcpp::DW_FORM_string)\n+\t       {\n+\t\t dirname = reinterpret_cast<const char*>(lineptr);\n+\t\t lineptr += dirname.size() + 1;\n+\t       }\n+\t     else if (forms[i] == elfcpp::DW_FORM_line_strp)\n+\t       {\n+\t\t uint64_t offset;\n+\t\t if (this->header_.offset_size == 4)\n+\t\t   offset =\n+\t\t       elfcpp::Swap_unaligned<32, big_endian>::readval(lineptr);\n+\t\t else\n+\t\t   offset =\n+\t\t       elfcpp::Swap_unaligned<64, big_endian>::readval(lineptr);\n+\t\t typename Reloc_map::const_iterator it\n+\t\t     = this->reloc_map_.find(lineptr - this->buffer_);\n+\t\t if (it != reloc_map_.end())\n+\t\t   {\n+\t\t     if (this->track_relocs_type_ == elfcpp::SHT_RELA)\n+\t\t       offset = 0;\n+\t\t     offset += it->second.second;\n+\t\t   }\n+\t\t lineptr += this->header_.offset_size;\n+\t\t dirname = reinterpret_cast<const char*>(this->str_buffer_\n+\t\t\t\t\t\t\t + offset);\n+\t       }\n+\t     else\n+\t       return lineptr;\n+\t   }\n+\t else\n+\t   return lineptr;\n+       }\n+      dir_list.push_back(dirname);\n+    }\n+\n+  delete[] types;\n+  delete[] forms;\n+\n+  // Read the filenames list.\n+  format_count = *lineptr;\n+  lineptr += 1;\n+\n+  types = new unsigned int[format_count];\n+  forms = new unsigned int[format_count];\n+\n+  for (unsigned int i = 0; i < format_count; i++)\n+    {\n+      types[i] = read_unsigned_LEB_128(lineptr, &len);\n+      lineptr += len;\n+      forms[i] = read_unsigned_LEB_128(lineptr, &len);\n+      lineptr += len;\n+    }\n+\n+  entry_count = read_unsigned_LEB_128(lineptr, &len);\n+  lineptr += len;\n+  this->files_.push_back(\n+      std::vector<std::pair<int, std::string> >(0));\n+  std::vector<std::pair<int, std::string> >& file_list = this->files_.back();\n+\n+  for (unsigned int j = 0; j < entry_count; j++)\n+    {\n+      const char* path = NULL;\n+      int dirindex = 0;\n+\n+      for (unsigned int i = 0; i < format_count; i++)\n+       {\n+\t if (types[i] == elfcpp::DW_LNCT_path)\n+\t   {\n+\t     if (forms[i] == elfcpp::DW_FORM_string)\n+\t       {\n+\t\t path = reinterpret_cast<const char*>(lineptr);\n+\t\t lineptr += strlen(path) + 1;\n+\t       }\n+\t     else if (forms[i] == elfcpp::DW_FORM_line_strp)\n+\t       {\n+\t\t uint64_t offset;\n+\t\t if (this->header_.offset_size == 4)\n+\t\t   offset = elfcpp::Swap_unaligned<32, big_endian>::readval(lineptr);\n+\t\t else\n+\t\t   offset = elfcpp::Swap_unaligned<64, big_endian>::readval(lineptr);\n+\t\t typename Reloc_map::const_iterator it\n+\t\t     = this->reloc_map_.find(lineptr - this->buffer_);\n+\t\t if (it != reloc_map_.end())\n+\t\t   {\n+\t\t     if (this->track_relocs_type_ == elfcpp::SHT_RELA)\n+\t\t       offset = 0;\n+\t\t     offset += it->second.second;\n+\t\t   }\n+\t\t lineptr += this->header_.offset_size;\n+\t\t path = reinterpret_cast<const char*>(this->str_buffer_\n+\t\t\t\t\t\t      + offset);\n+\t       }\n+\t     else\n+\t       return lineptr;\n+\t   }\n+\t else if (types[i] == elfcpp::DW_LNCT_directory_index)\n+\t   {\n+\t     if (forms[i] == elfcpp::DW_FORM_udata)\n+\t       {\n+\t\t dirindex = read_unsigned_LEB_128(lineptr, &len);\n+\t\t lineptr += len;\n+\t       }\n+\t     else\n+\t       return lineptr;\n+\t   }\n+\t else\n+\t   return lineptr;\n+       }\n+      gold_debug(DEBUG_LOCATION, \"File %3d: %s\",\n+\t\t static_cast<int>(file_list.size()), path);\n+      file_list.push_back(std::make_pair(dirindex, path));\n+    }\n+\n+  delete[] types;\n+  delete[] forms;\n+\n+  return lineptr;\n+}\n+\n // Process a single opcode in the .debug.line structure.\n \n template<int size, bool big_endian>\n@@ -1790,15 +2219,15 @@ Sized_dwarf_line_info<size, big_endian>::process_one_opcode(\n \n   // If the opcode is great than the opcode_base, it is a special\n   // opcode. Most line programs consist mainly of special opcodes.\n-  if (opcode >= header_.opcode_base)\n+  if (opcode >= this->header_.opcode_base)\n     {\n-      opcode -= header_.opcode_base;\n-      const int advance_address = ((opcode / header_.line_range)\n-                                   * header_.min_insn_length);\n+      opcode -= this->header_.opcode_base;\n+      const int advance_address = ((opcode / this->header_.line_range)\n+                                   * this->header_.min_insn_length);\n       lsm->address += advance_address;\n \n-      const int advance_line = ((opcode % header_.line_range)\n-                                + header_.line_base);\n+      const int advance_line = ((opcode % this->header_.line_range)\n+                                + this->header_.line_base);\n       lsm->line_num += advance_line;\n       lsm->basic_block = true;\n       *len = oplen;\n@@ -1818,13 +2247,13 @@ Sized_dwarf_line_info<size, big_endian>::process_one_opcode(\n         const uint64_t advance_address\n             = read_unsigned_LEB_128(start, &templen);\n         oplen += templen;\n-        lsm->address += header_.min_insn_length * advance_address;\n+        lsm->address += this->header_.min_insn_length * advance_address;\n       }\n       break;\n \n     case elfcpp::DW_LNS_advance_line:\n       {\n-        const uint64_t advance_line = read_signed_LEB_128(start, &templen);\n+        const int64_t advance_line = read_signed_LEB_128(start, &templen);\n         oplen += templen;\n         lsm->line_num += advance_line;\n       }\n@@ -1865,9 +2294,9 @@ Sized_dwarf_line_info<size, big_endian>::process_one_opcode(\n \n     case elfcpp::DW_LNS_const_add_pc:\n       {\n-        const int advance_address = (header_.min_insn_length\n-                                     * ((255 - header_.opcode_base)\n-                                        / header_.line_range));\n+        const int advance_address = (this->header_.min_insn_length\n+                                     * ((255 - this->header_.opcode_base)\n+                                        / this->header_.line_range));\n         lsm->address += advance_address;\n       }\n       break;\n@@ -1950,7 +2379,7 @@ Sized_dwarf_line_info<size, big_endian>::process_one_opcode(\n     default:\n       {\n         // Ignore unknown opcode  silently\n-        for (int i = 0; i < header_.std_opcode_lengths[opcode]; i++)\n+        for (int i = 0; i < this->header_.std_opcode_lengths[opcode]; i++)\n           {\n             size_t templen;\n             read_unsigned_LEB_128(start, &templen);\n@@ -1970,28 +2399,24 @@ Sized_dwarf_line_info<size, big_endian>::process_one_opcode(\n template<int size, bool big_endian>\n unsigned const char*\n Sized_dwarf_line_info<size, big_endian>::read_lines(unsigned const char* lineptr,\n+                                                    unsigned const char* endptr,\n                                                     unsigned int shndx)\n {\n   struct LineStateMachine lsm;\n \n-  // LENGTHSTART is the place the length field is based on.  It is the\n-  // point in the header after the initial length field.\n-  const unsigned char* lengthstart = buffer_;\n-\n-  // In 64 bit dwarf, the initial length is 12 bytes, because of the\n-  // 0xffffffff at the start.\n-  if (header_.offset_size == 8)\n-    lengthstart += 12;\n-  else\n-    lengthstart += 4;\n-\n-  while (lineptr < lengthstart + header_.total_length)\n+  while (lineptr < endptr)\n     {\n-      ResetLineStateMachine(&lsm, header_.default_is_stmt);\n+      ResetLineStateMachine(&lsm, this->header_.default_is_stmt);\n       while (!lsm.end_sequence)\n         {\n           size_t oplength;\n+\n+\t  if (lineptr >= endptr)\n+\t    break;\n+\n           bool add_line = this->process_one_opcode(lineptr, &lsm, &oplength);\n+          lineptr += oplength;\n+\n           if (add_line\n               && (shndx == -1U || lsm.shndx == -1U || shndx == lsm.shndx))\n             {\n@@ -2012,11 +2437,10 @@ Sized_dwarf_line_info<size, big_endian>::read_lines(unsigned const char* lineptr\n \t\tmap.back().last_line_for_offset = false;\n \t      map.push_back(entry);\n             }\n-          lineptr += oplength;\n         }\n     }\n \n-  return lengthstart + header_.total_length;\n+  return endptr;\n }\n \n // Read the relocations into a Reloc_map.\n@@ -2057,9 +2481,17 @@ Sized_dwarf_line_info<size, big_endian>::read_line_mappings(unsigned int shndx)\n     {\n       const unsigned char* lineptr = this->buffer_;\n       lineptr = this->read_header_prolog(lineptr);\n-      lineptr = this->read_header_tables(lineptr);\n-      lineptr = this->read_lines(lineptr, shndx);\n-      this->buffer_ = lineptr;\n+      if (this->header_.version >= 2 && this->header_.version <= 4)\n+\t{\n+\t  lineptr = this->read_header_tables_v2(lineptr);\n+\t  lineptr = this->read_lines(lineptr, this->end_of_unit_, shndx);\n+\t}\n+      else if (this->header_.version == 5)\n+\t{\n+\t  lineptr = this->read_header_tables_v5(lineptr);\n+\t  lineptr = this->read_lines(lineptr, this->end_of_unit_, shndx);\n+\t}\n+      this->buffer_ = this->end_of_unit_;\n     }\n \n   // Sort the lines numbers, so addr2line can use binary search.\n@@ -2215,6 +2647,9 @@ Sized_dwarf_line_info<size, big_endian>::do_addr2line(\n     off_t offset,\n     std::vector<std::string>* other_lines)\n {\n+  gold_debug(DEBUG_LOCATION, \"do_addr2line: shndx %u offset %08x\",\n+\t     shndx, static_cast<int>(offset));\n+\n   if (this->data_valid_ == false)\n     return \"\";\n "
    },
    {
      "sha": "921a1f7c8765b61e6b7a6a083ad5abe6608cac90",
      "filename": "gold/dwarf_reader.h",
      "status": "modified",
      "additions": 80,
      "deletions": 23,
      "changes": 103,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/gold/dwarf_reader.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0/gold/dwarf_reader.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/dwarf_reader.h?ref=5cde809b7b9da3ad3aa0d65f0e5e92ab199d64f0",
      "patch": "@@ -173,11 +173,12 @@ class Dwarf_abbrev_table\n   // An attribute list entry.\n   struct Attribute\n   {\n-    Attribute(unsigned int a, unsigned int f)\n-      : attr(a), form(f)\n+    Attribute(unsigned int a, unsigned int f, int c)\n+      : attr(a), form(f), implicit_const(c)\n     { }\n     unsigned int attr;\n     unsigned int form;\n+    int implicit_const;\n   };\n \n   // An abbrev code entry.\n@@ -190,9 +191,9 @@ class Dwarf_abbrev_table\n     }\n \n     void\n-    add_attribute(unsigned int attr, unsigned int form)\n+    add_attribute(unsigned int attr, unsigned int form, int implicit_const)\n     {\n-      this->attributes.push_back(Attribute(attr, form));\n+      this->attributes.push_back(Attribute(attr, form, implicit_const));\n     }\n \n     // The DWARF tag.\n@@ -349,14 +350,15 @@ class Dwarf_ranges_table\n       delete this->ranges_reloc_mapper_;\n   }\n \n-  // Read the ranges table from an object file.\n+  // Fetch the contents of the ranges table from an object file.\n   bool\n   read_ranges_table(Relobj* object,\n \t\t    const unsigned char* symtab,\n \t\t    off_t symtab_size,\n-\t\t    unsigned int ranges_shndx);\n+\t\t    unsigned int ranges_shndx,\n+\t\t    unsigned int version);\n \n-  // Read the range table from an object file.\n+  // Read the DWARF 2/3/4 range table.\n   Dwarf_range_list*\n   read_range_list(Relobj* object,\n \t\t  const unsigned char* symtab,\n@@ -365,6 +367,15 @@ class Dwarf_ranges_table\n \t\t  unsigned int ranges_shndx,\n \t\t  off_t ranges_offset);\n \n+  // Read the DWARF 5 rnglists table.\n+  Dwarf_range_list*\n+  read_range_list_v5(Relobj* object,\n+\t\t     const unsigned char* symtab,\n+\t\t     off_t symtab_size,\n+\t\t     unsigned int address_size,\n+\t\t     unsigned int ranges_shndx,\n+\t\t     off_t ranges_offset);\n+\n   // Look for a relocation at offset OFF in the range table,\n   // and return the section index and offset of the target.\n   unsigned int\n@@ -490,8 +501,6 @@ class Dwarf_die\n       unsigned int shndx;\n       // Block length for block forms.\n       unsigned int blocklen;\n-      // Attribute offset for DW_FORM_strp.\n-      unsigned int attr_off;\n     } aux;\n   };\n \n@@ -684,6 +693,10 @@ class Dwarf_die\n // calls the various visit_xxx() methods for each header.  Clients\n // should derive a new class from this one and implement the\n // visit_compilation_unit() and visit_type_unit() functions.\n+// IS_TYPE_UNIT is true if we are reading from a .debug_types section,\n+// which is used only in DWARF 4. For DWARF 5, it will be false,\n+// and we will determine whether it's a type init when we parse the\n+// header.\n \n class Dwarf_info_reader\n {\n@@ -695,15 +708,20 @@ class Dwarf_info_reader\n \t\t    unsigned int shndx,\n \t\t    unsigned int reloc_shndx,\n \t\t    unsigned int reloc_type)\n-    : is_type_unit_(is_type_unit), object_(object), symtab_(symtab),\n+    : object_(object), symtab_(symtab),\n       symtab_size_(symtab_size), shndx_(shndx), reloc_shndx_(reloc_shndx),\n       reloc_type_(reloc_type), abbrev_shndx_(0), string_shndx_(0),\n       buffer_(NULL), buffer_end_(NULL), cu_offset_(0), cu_length_(0),\n       offset_size_(0), address_size_(0), cu_version_(0),\n       abbrev_table_(), ranges_table_(this),\n       reloc_mapper_(NULL), string_buffer_(NULL), string_buffer_end_(NULL),\n       owns_string_buffer_(false), string_output_section_offset_(0)\n-  { }\n+  {\n+    // For DWARF 4, we infer the unit type from the section name.\n+    // For DWARF 5, we will read this from the unit header.\n+    this->unit_type_ =\n+\t(is_type_unit ? elfcpp::DW_UT_type : elfcpp::DW_UT_compile);\n+  }\n \n   virtual\n   ~Dwarf_info_reader()\n@@ -714,6 +732,13 @@ class Dwarf_info_reader\n       delete[] this->string_buffer_;\n   }\n \n+  bool\n+  is_type_unit() const\n+  {\n+    return (this->unit_type_ == elfcpp::DW_UT_type\n+\t    || this->unit_type_ == elfcpp::DW_UT_split_type);\n+  }\n+\n   // Begin parsing the debug info.  This calls visit_compilation_unit()\n   // or visit_type_unit() for each compilation or type unit found in the\n   // section, and visit_die() for each top-level DIE.\n@@ -745,6 +770,9 @@ class Dwarf_info_reader\n   inline typename elfcpp::Valtype_base<valsize>::Valtype\n   read_from_pointer(const unsigned char** source);\n \n+  inline typename elfcpp::Valtype_base<32>::Valtype\n+  read_3bytes_from_pointer(const unsigned char** source);\n+\n   // Look for a relocation at offset ATTR_OFF in the dwarf info,\n   // and return the section index and offset of the target.\n   unsigned int\n@@ -818,12 +846,20 @@ class Dwarf_info_reader\n   Dwarf_range_list*\n   read_range_list(unsigned int ranges_shndx, off_t ranges_offset)\n   {\n-    return this->ranges_table_.read_range_list(this->object_,\n-\t\t\t\t\t       this->symtab_,\n-\t\t\t\t\t       this->symtab_size_,\n-\t\t\t\t\t       this->address_size_,\n-\t\t\t\t\t       ranges_shndx,\n-\t\t\t\t\t       ranges_offset);\n+    if (this->cu_version_ < 5)\n+      return this->ranges_table_.read_range_list(this->object_,\n+\t\t\t\t\t\t this->symtab_,\n+\t\t\t\t\t\t this->symtab_size_,\n+\t\t\t\t\t\t this->address_size_,\n+\t\t\t\t\t\t ranges_shndx,\n+\t\t\t\t\t\t ranges_offset);\n+    else\n+      return this->ranges_table_.read_range_list_v5(this->object_,\n+\t\t\t\t\t\t    this->symtab_,\n+\t\t\t\t\t\t    this->symtab_size_,\n+\t\t\t\t\t\t    this->address_size_,\n+\t\t\t\t\t\t    ranges_shndx,\n+\t\t\t\t\t\t    ranges_offset);\n   }\n \n   // Return the object.\n@@ -873,8 +909,8 @@ class Dwarf_info_reader\n   bool\n   do_read_string_table(unsigned int string_shndx);\n \n-  // True if this is a type unit; false for a compilation unit.\n-  bool is_type_unit_;\n+  // The unit type (DW_UT_xxx).\n+  unsigned int unit_type_;\n   // The object containing the .debug_info or .debug_types input section.\n   Relobj* object_;\n   // The ELF symbol table.\n@@ -1008,6 +1044,8 @@ class Sized_dwarf_line_info : public Dwarf_line_info\n   {\n     if (this->buffer_start_ != NULL)\n       delete[] this->buffer_start_;\n+    if (this->str_buffer_start_ != NULL)\n+      delete[] this->str_buffer_start_;\n   }\n \n  private:\n@@ -1030,19 +1068,23 @@ class Sized_dwarf_line_info : public Dwarf_line_info\n   void\n   read_relocs();\n \n-  // Reads the DWARF2/3 header for this line info.  Each takes as input\n+  // Reads the DWARF header for this line info.  Each takes as input\n   // a starting buffer position, and returns the ending position.\n   const unsigned char*\n   read_header_prolog(const unsigned char* lineptr);\n \n   const unsigned char*\n-  read_header_tables(const unsigned char* lineptr);\n+  read_header_tables_v2(const unsigned char* lineptr);\n+\n+  const unsigned char*\n+  read_header_tables_v5(const unsigned char* lineptr);\n \n-  // Reads the DWARF2/3 line information.  If shndx is non-negative,\n+  // Reads the DWARF line information.  If shndx is non-negative,\n   // discard all line information that doesn't pertain to the given\n   // section.\n   const unsigned char*\n-  read_lines(const unsigned char* lineptr, unsigned int shndx);\n+  read_lines(const unsigned char* lineptr, const unsigned char* endptr,\n+\t     unsigned int shndx);\n \n   // Process a single line info opcode at START using the state\n   // machine at LSM.  Return true if we should define a line using the\n@@ -1069,6 +1111,7 @@ class Sized_dwarf_line_info : public Dwarf_line_info\n   {\n     off_t total_length;\n     int version;\n+    int address_size;\n     off_t prologue_length;\n     int min_insn_length; // insn stands for instruction\n     int max_ops_per_insn; // Added in DWARF-4.\n@@ -1089,6 +1132,20 @@ class Sized_dwarf_line_info : public Dwarf_line_info\n   // of the buffer.\n   const unsigned char* buffer_start_;\n \n+  // str_buffer is the buffer for the line table strings.\n+  const unsigned char* str_buffer_;\n+  const unsigned char* str_buffer_end_;\n+  // If the buffer was allocated temporarily, and therefore must be\n+  // deallocated in the dtor, this contains a pointer to the start\n+  // of the buffer.\n+  const unsigned char* str_buffer_start_;\n+\n+  // Pointer to the end of the header_length field (aka prologue_length).\n+  const unsigned char* end_of_header_length_;\n+\n+  // Pointer to the end of the current compilation unit.\n+  const unsigned char* end_of_unit_;\n+\n   // This has relocations that point into buffer.\n   Sized_elf_reloc_mapper<size, big_endian>* reloc_mapper_;\n   // The type of the reloc section in track_relocs_--SHT_REL or SHT_RELA."
    }
  ]
}