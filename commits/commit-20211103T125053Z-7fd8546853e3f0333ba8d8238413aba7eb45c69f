{
  "sha": "7fd8546853e3f0333ba8d8238413aba7eb45c69f",
  "node_id": "C_kwDOANOeidoAKDdmZDg1NDY4NTNlM2YwMzMzYmE4ZDgyMzg0MTNhYmE3ZWI0NWM2OWY",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-10-29T17:54:36Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-11-03T12:50:53Z"
    },
    "message": "[AArch64] Make gdbserver register set selection dynamic\n\nThe current register set selection mechanism for AArch64 is static, based\non a pre-populated array of register sets.\n\nThis means that we might potentially probe register sets that are not\navailable. This is OK if the kernel errors out during ptrace, but probing the\ntag_ctl register, for example, does not result in a ptrace error if the kernel\nsupports the tagged address ABI but not MTE (PR 28355).\n\nMaking the register set selection dynamic, based on feature checks, solves\nthis and simplifies the code a bit. It allows us to list all of the register\nsets only once, and pick and choose based on HWCAP/HWCAP2 or other properties.\n\nI plan to backport this fix to GDB 11 as well.\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=28355",
    "tree": {
      "sha": "2714fa190e169b928e56618cfdaaaa45d32117b8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2714fa190e169b928e56618cfdaaaa45d32117b8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7fd8546853e3f0333ba8d8238413aba7eb45c69f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7fd8546853e3f0333ba8d8238413aba7eb45c69f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7fd8546853e3f0333ba8d8238413aba7eb45c69f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7fd8546853e3f0333ba8d8238413aba7eb45c69f/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5fff6115feae7aaa23c0ae8d144e1c8418ee2ee1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5fff6115feae7aaa23c0ae8d144e1c8418ee2ee1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5fff6115feae7aaa23c0ae8d144e1c8418ee2ee1"
    }
  ],
  "stats": {
    "total": 195,
    "additions": 110,
    "deletions": 85
  },
  "files": [
    {
      "sha": "95edb664b5517e2f34c255733e797e4d8f1db35f",
      "filename": "gdb/arch/aarch64.h",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7fd8546853e3f0333ba8d8238413aba7eb45c69f/gdb/arch/aarch64.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7fd8546853e3f0333ba8d8238413aba7eb45c69f/gdb/arch/aarch64.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch/aarch64.h?ref=7fd8546853e3f0333ba8d8238413aba7eb45c69f",
      "patch": "@@ -22,6 +22,15 @@\n \n #include \"gdbsupport/tdesc.h\"\n \n+/* Holds information on what architectural features are available.  This is\n+   used to select register sets.  */\n+struct aarch64_features\n+{\n+  bool sve = false;\n+  bool pauth = false;\n+  bool mte = false;\n+};\n+\n /* Create the aarch64 target description.  A non zero VQ value indicates both\n    the presence of SVE and the Vector Quotient - the number of 128bit chunks in\n    an SVE Z register.  HAS_PAUTH_P indicates the presence of the PAUTH"
    },
    {
      "sha": "9a8cb4169a7101ef911fe7a70dba8c9c17316190",
      "filename": "gdbserver/linux-aarch64-low.cc",
      "status": "modified",
      "additions": 101,
      "deletions": 85,
      "changes": 186,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7fd8546853e3f0333ba8d8238413aba7eb45c69f/gdbserver/linux-aarch64-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7fd8546853e3f0333ba8d8238413aba7eb45c69f/gdbserver/linux-aarch64-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-aarch64-low.cc?ref=7fd8546853e3f0333ba8d8238413aba7eb45c69f",
      "patch": "@@ -196,16 +196,6 @@ is_64bit_tdesc (void)\n   return register_size (regcache->tdesc, 0) == 8;\n }\n \n-/* Return true if the regcache contains the number of SVE registers.  */\n-\n-static bool\n-is_sve_tdesc (void)\n-{\n-  struct regcache *regcache = get_thread_regcache (current_thread, 0);\n-\n-  return tdesc_contains_feature (regcache->tdesc, \"org.gnu.gdb.aarch64.sve\");\n-}\n-\n static void\n aarch64_fill_gregset (struct regcache *regcache, void *buf)\n {\n@@ -680,40 +670,6 @@ aarch64_target::low_new_fork (process_info *parent,\n   *child->priv->arch_private = *parent->priv->arch_private;\n }\n \n-/* Matches HWCAP_PACA in kernel header arch/arm64/include/uapi/asm/hwcap.h.  */\n-#define AARCH64_HWCAP_PACA (1 << 30)\n-\n-/* Implementation of linux target ops method \"low_arch_setup\".  */\n-\n-void\n-aarch64_target::low_arch_setup ()\n-{\n-  unsigned int machine;\n-  int is_elf64;\n-  int tid;\n-\n-  tid = lwpid_of (current_thread);\n-\n-  is_elf64 = linux_pid_exe_is_elf_64_file (tid, &machine);\n-\n-  if (is_elf64)\n-    {\n-      uint64_t vq = aarch64_sve_get_vq (tid);\n-      unsigned long hwcap = linux_get_hwcap (8);\n-      unsigned long hwcap2 = linux_get_hwcap2 (8);\n-      bool pauth_p = hwcap & AARCH64_HWCAP_PACA;\n-      /* MTE is AArch64-only.  */\n-      bool mte_p = hwcap2 & HWCAP2_MTE;\n-\n-      current_process ()->tdesc\n-\t= aarch64_linux_read_description (vq, pauth_p, mte_p);\n-    }\n-  else\n-    current_process ()->tdesc = aarch32_linux_read_description ();\n-\n-  aarch64_linux_get_debug_reg_capacity (lwpid_of (current_thread));\n-}\n-\n /* Wrapper for aarch64_sve_regs_copy_to_reg_buf.  */\n \n static void\n@@ -730,69 +686,132 @@ aarch64_sve_regs_copy_from_regcache (struct regcache *regcache, void *buf)\n   return aarch64_sve_regs_copy_from_reg_buf (regcache, buf);\n }\n \n+/* Array containing all the possible register sets for AArch64/Linux.  During\n+   architecture setup, these will be checked against the HWCAP/HWCAP2 bits for\n+   validity and enabled/disabled accordingly.\n+\n+   Their sizes are set to 0 here, but they will be adjusted later depending\n+   on whether each register set is available or not.  */\n static struct regset_info aarch64_regsets[] =\n {\n+  /* GPR registers.  */\n   { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_PRSTATUS,\n-    sizeof (struct user_pt_regs), GENERAL_REGS,\n+    0, GENERAL_REGS,\n     aarch64_fill_gregset, aarch64_store_gregset },\n+  /* Floating Point (FPU) registers.  */\n   { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_FPREGSET,\n-    sizeof (struct user_fpsimd_state), FP_REGS,\n+    0, FP_REGS,\n     aarch64_fill_fpregset, aarch64_store_fpregset\n   },\n+  /* Scalable Vector Extension (SVE) registers.  */\n+  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_ARM_SVE,\n+    0, EXTENDED_REGS,\n+    aarch64_sve_regs_copy_from_regcache, aarch64_sve_regs_copy_to_regcache\n+  },\n+  /* PAC registers.  */\n   { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_ARM_PAC_MASK,\n-    AARCH64_PAUTH_REGS_SIZE, OPTIONAL_REGS,\n-    NULL, aarch64_store_pauthregset },\n+    0, OPTIONAL_REGS,\n+    nullptr, aarch64_store_pauthregset },\n+  /* Tagged address control / MTE registers.  */\n   { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_ARM_TAGGED_ADDR_CTRL,\n-    AARCH64_LINUX_SIZEOF_MTE, OPTIONAL_REGS, aarch64_fill_mteregset,\n-    aarch64_store_mteregset },\n+    0, OPTIONAL_REGS,\n+    aarch64_fill_mteregset, aarch64_store_mteregset },\n   NULL_REGSET\n };\n \n static struct regsets_info aarch64_regsets_info =\n   {\n     aarch64_regsets, /* regsets */\n     0, /* num_regsets */\n-    NULL, /* disabled_regsets */\n+    nullptr, /* disabled_regsets */\n   };\n \n static struct regs_info regs_info_aarch64 =\n   {\n-    NULL, /* regset_bitmap */\n-    NULL, /* usrregs */\n+    nullptr, /* regset_bitmap */\n+    nullptr, /* usrregs */\n     &aarch64_regsets_info,\n   };\n \n-static struct regset_info aarch64_sve_regsets[] =\n+/* Given FEATURES, adjust the available register sets by setting their\n+   sizes.  A size of 0 means the register set is disabled and won't be\n+   used.  */\n+\n+static void\n+aarch64_adjust_register_sets (const struct aarch64_features &features)\n {\n-  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_PRSTATUS,\n-    sizeof (struct user_pt_regs), GENERAL_REGS,\n-    aarch64_fill_gregset, aarch64_store_gregset },\n-  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_ARM_SVE,\n-    SVE_PT_SIZE (AARCH64_MAX_SVE_VQ, SVE_PT_REGS_SVE), EXTENDED_REGS,\n-    aarch64_sve_regs_copy_from_regcache, aarch64_sve_regs_copy_to_regcache\n-  },\n-  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_ARM_PAC_MASK,\n-    AARCH64_PAUTH_REGS_SIZE, OPTIONAL_REGS,\n-    NULL, aarch64_store_pauthregset },\n-  { PTRACE_GETREGSET, PTRACE_SETREGSET, NT_ARM_TAGGED_ADDR_CTRL,\n-    AARCH64_LINUX_SIZEOF_MTE, OPTIONAL_REGS, aarch64_fill_mteregset,\n-    aarch64_store_mteregset },\n-  NULL_REGSET\n-};\n+  struct regset_info *regset;\n \n-static struct regsets_info aarch64_sve_regsets_info =\n-  {\n-    aarch64_sve_regsets, /* regsets.  */\n-    0, /* num_regsets.  */\n-    NULL, /* disabled_regsets.  */\n-  };\n+  for (regset = aarch64_regsets; regset->size >= 0; regset++)\n+    {\n+      switch (regset->nt_type)\n+\t{\n+\tcase NT_PRSTATUS:\n+\t  /* General purpose registers are always present.  */\n+\t  regset->size = sizeof (struct user_pt_regs);\n+\t  break;\n+\tcase NT_FPREGSET:\n+\t  /* This is unavailable when SVE is present.  */\n+\t  if (!features.sve)\n+\t    regset->size = sizeof (struct user_fpsimd_state);\n+\t  break;\n+\tcase NT_ARM_SVE:\n+\t  if (features.sve)\n+\t    regset->size = SVE_PT_SIZE (AARCH64_MAX_SVE_VQ, SVE_PT_REGS_SVE);\n+\t  break;\n+\tcase NT_ARM_PAC_MASK:\n+\t  if (features.pauth)\n+\t    regset->size = AARCH64_PAUTH_REGS_SIZE;\n+\t  break;\n+\tcase NT_ARM_TAGGED_ADDR_CTRL:\n+\t  if (features.mte)\n+\t    regset->size = AARCH64_LINUX_SIZEOF_MTE;\n+\t  break;\n+\tdefault:\n+\t  gdb_assert_not_reached (\"Unknown register set found.\");\n+\t}\n+    }\n+}\n \n-static struct regs_info regs_info_aarch64_sve =\n-  {\n-    NULL, /* regset_bitmap.  */\n-    NULL, /* usrregs.  */\n-    &aarch64_sve_regsets_info,\n-  };\n+/* Matches HWCAP_PACA in kernel header arch/arm64/include/uapi/asm/hwcap.h.  */\n+#define AARCH64_HWCAP_PACA (1 << 30)\n+\n+/* Implementation of linux target ops method \"low_arch_setup\".  */\n+\n+void\n+aarch64_target::low_arch_setup ()\n+{\n+  unsigned int machine;\n+  int is_elf64;\n+  int tid;\n+\n+  tid = lwpid_of (current_thread);\n+\n+  is_elf64 = linux_pid_exe_is_elf_64_file (tid, &machine);\n+\n+  if (is_elf64)\n+    {\n+      struct aarch64_features features;\n+\n+      uint64_t vq = aarch64_sve_get_vq (tid);\n+      features.sve = (vq > 0);\n+      /* A-profile PAC is 64-bit only.  */\n+      features.pauth = linux_get_hwcap (8) & AARCH64_HWCAP_PACA;\n+      /* A-profile MTE is 64-bit only.  */\n+      features.mte = linux_get_hwcap2 (8) & HWCAP2_MTE;\n+\n+      current_process ()->tdesc\n+\t= aarch64_linux_read_description (vq, features.pauth, features.mte);\n+\n+      /* Adjust the register sets we should use for this particular set of\n+\t features.  */\n+      aarch64_adjust_register_sets (features);\n+    }\n+  else\n+    current_process ()->tdesc = aarch32_linux_read_description ();\n+\n+  aarch64_linux_get_debug_reg_capacity (lwpid_of (current_thread));\n+}\n \n /* Implementation of linux target ops method \"get_regs_info\".  */\n \n@@ -802,9 +821,7 @@ aarch64_target::get_regs_info ()\n   if (!is_64bit_tdesc ())\n     return &regs_info_aarch32;\n \n-  if (is_sve_tdesc ())\n-    return &regs_info_aarch64_sve;\n-\n+  /* AArch64 64-bit registers.  */\n   return &regs_info_aarch64;\n }\n \n@@ -3294,5 +3311,4 @@ initialize_low_arch (void)\n   initialize_low_arch_aarch32 ();\n \n   initialize_regsets_info (&aarch64_regsets_info);\n-  initialize_regsets_info (&aarch64_sve_regsets_info);\n }"
    }
  ]
}