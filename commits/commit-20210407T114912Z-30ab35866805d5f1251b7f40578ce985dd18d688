{
  "sha": "30ab35866805d5f1251b7f40578ce985dd18d688",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzBhYjM1ODY2ODA1ZDVmMTI1MWI3ZjQwNTc4Y2U5ODVkZDE4ZDY4OA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-03-09T11:11:14Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-04-07T11:49:12Z"
    },
    "message": "gdb: allow casting to rvalue reference in more cases\n\nIt is not currently possible to cast some values to an rvaule\nreference.  This happens when simple scalar values are cast to an\nrvalue reference of the same type, e.g.:\n\n  int global_var;\n\nThen in GDB:\n\n  (gdb) p static_cast<int&&> (global_var)\n  Attempt to take address of value not located in memory.\n\nWhich is clearly silly.\n\nThe problem is that as part of the cast an intermediate value is\ncreated within GDB that becomes an lval_none rather than the original\nlval_memory.  The casting logic basically goes like this:\n\nThe call tree that leads to the error looks like this:\n\n  value_cast\n    value_cast\n    value_ref\n      value_addr\n        error\n\nThe first value_cast call is casting the value for 'global_var' to\ntype 'int&&'.  GDB spots that the target type is a reference, and so\ncalls value_cast again, this time casting 'global_var' to type 'int'.\nWe then call value_ref to convert the result of the second value_cast\ninto a reference.\n\nUnfortunately, the second cast results in the value (for global_var)\nchanging from an lval_memory to an lval_none.  This is because int to\nint casting calls extract_unsigned_integer and then\nvalue_from_longest.\n\nIn theory value_cast has a check at its head that should help in this\ncase, the code is:\n\n  if (value_type (arg2) == type)\n    return arg2;\n\nHowever, this only works in some cases.  In our case\n'value_type (arg2)' will be an objfile owned type, while the type from\nthe expression parser 'int&&' will be gdbarch owned.  The pointers\nwill not be equal, but the meaning of the type will be equal.\n\nI did consider making the int to int casting case smarter, but this\nobviously is only one example.  We must also consider things like\nfloat to float, or pointer to pointer....\n\nSo, I instead decided to try and make the initial check smarter.\nInstead of a straight pointer comparison, I now propose that we use\ntypes_deeply_equal.  If this is true then we are casting something\nback to its current type, in which case we can preserve the lval\nsetting by using value_copy.\n\ngdb/ChangeLog:\n\n\t* valops.c (value_cast): Call value_deeply_equal before performing\n\tany cast.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.cp/rvalue-ref-params.cc (f3): New function.\n\t(f4): New function.\n\t(global_int): New global variable.\n\t(global_float): Likeiwse.\n\t(main): Call both new functions.\n\t* gdb.cp/rvalue-ref-params.exp: Add new tests.",
    "tree": {
      "sha": "5fb292bf5ccb72f9c38fe3bc96ec6701472036fb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5fb292bf5ccb72f9c38fe3bc96ec6701472036fb"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/30ab35866805d5f1251b7f40578ce985dd18d688",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30ab35866805d5f1251b7f40578ce985dd18d688",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/30ab35866805d5f1251b7f40578ce985dd18d688",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/30ab35866805d5f1251b7f40578ce985dd18d688/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5e18990f1f2957e59fa4b62d64ed0cb683b65b58",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5e18990f1f2957e59fa4b62d64ed0cb683b65b58",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5e18990f1f2957e59fa4b62d64ed0cb683b65b58"
    }
  ],
  "stats": {
    "total": 63,
    "additions": 61,
    "deletions": 2
  },
  "files": [
    {
      "sha": "072fa09e2cab9c071b33a6e299358fd7b397b97e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=30ab35866805d5f1251b7f40578ce985dd18d688",
      "patch": "@@ -1,3 +1,8 @@\n+2021-04-07  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* valops.c (value_cast): Call value_deeply_equal before performing\n+\tany cast.\n+\n 2021-04-07  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdbtypes.c (types_equal): Move pointer equality check earlier in"
    },
    {
      "sha": "0a081fc073412ce3165ffa800a418281f46f0ce7",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=30ab35866805d5f1251b7f40578ce985dd18d688",
      "patch": "@@ -1,3 +1,12 @@\n+2021-04-07  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.cp/rvalue-ref-params.cc (f3): New function.\n+\t(f4): New function.\n+\t(global_int): New global variable.\n+\t(global_float): Likeiwse.\n+\t(main): Call both new functions.\n+\t* gdb.cp/rvalue-ref-params.exp: Add new tests.\n+\n 2021-04-07  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.dwarf2/fission-relative-dwo.c: New file."
    },
    {
      "sha": "d6340fa32e8626067067f767792ef3673c40ee68",
      "filename": "gdb/testsuite/gdb.cp/rvalue-ref-params.cc",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/testsuite/gdb.cp/rvalue-ref-params.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/testsuite/gdb.cp/rvalue-ref-params.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/rvalue-ref-params.cc?ref=30ab35866805d5f1251b7f40578ce985dd18d688",
      "patch": "@@ -42,6 +42,18 @@ f2 (Child &&C)\n   return f1 (std::move (C));                 /* Set breakpoint marker2 here.  */\n }\n \n+int\n+f3 (int &&var_i)\n+{\n+  return var_i + 1;\n+}\n+\n+int\n+f4 (float &&var_f)\n+{\n+  return static_cast <int> (var_f);\n+}\n+\n struct OtherParent\n {\n   OtherParent (int other_id0) : other_id (other_id0) { }\n@@ -65,6 +77,10 @@ mf2 (MultiChild &&C)\n   return mf1 (std::move (C));\n }\n \n+/* These are used from within GDB.  */\n+int global_int = 7;\n+float global_float = 3.5f;\n+\n int\n main ()\n {\n@@ -81,5 +97,8 @@ main ()\n \n   mf2 (std::move (MQ));\t\t\t/* Set breakpoint MQ here.  */\n \n+  (void) f3 (-1);\n+  (void) f4 (3.5);\n+\n   return 0;\n }"
    },
    {
      "sha": "1fd3edb0584517f761e006db3222c6a0a2cab3fa",
      "filename": "gdb/testsuite/gdb.cp/rvalue-ref-params.exp",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/testsuite/gdb.cp/rvalue-ref-params.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/testsuite/gdb.cp/rvalue-ref-params.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/rvalue-ref-params.exp?ref=30ab35866805d5f1251b7f40578ce985dd18d688",
      "patch": "@@ -40,6 +40,15 @@ set t \"print value of f1 on (Child&&) in main\"\n gdb_start_again \"marker1 here\" $t\n gdb_test \"print f1(static_cast<Child&&>(Q))\" \".* = 40.*\" $t\n \n+gdb_test \"print f3(static_cast<int&&> (global_int))\" \" = 8\"\n+gdb_test \"print f4(static_cast<float&&> (global_float))\" \" = 3\"\n+\n+gdb_test \"print static_cast<int&> (global_int)\" \" = \\\\(int &\\\\) @$hex: 7\"\n+gdb_test \"print static_cast<int&&> (global_int)\" \" = \\\\(int &&\\\\) @$hex: 7\"\n+\n+gdb_test \"print static_cast<float&> (global_float)\" \" = \\\\(float &\\\\) @$hex: 3\\\\.$decimal\"\n+gdb_test \"print static_cast<float&&> (global_float)\" \" = \\\\(float &&\\\\) @$hex: 3\\\\.$decimal\"\n+\n set t \"print value of f2 on (Child&&) in main\" \n gdb_start_again \"marker1 here\" $t\n gdb_test \"print f2(static_cast<Child&&>(Q))\" \".* = 40.*\" $t"
    },
    {
      "sha": "8694c124b5248a468d8debdfa94d594dee1911c5",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 19,
      "deletions": 2,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/30ab35866805d5f1251b7f40578ce985dd18d688/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=30ab35866805d5f1251b7f40578ce985dd18d688",
      "patch": "@@ -415,8 +415,25 @@ value_cast (struct type *type, struct value *arg2)\n \n   int convert_to_boolean = 0;\n \n-  if (value_type (arg2) == type)\n-    return arg2;\n+  /* TYPE might be equal in meaning to the existing type of ARG2, but for\n+     many reasons, might be a different type object (e.g. TYPE might be a\n+     gdbarch owned type, while VALUE_TYPE (ARG2) could be an objfile owned\n+     type).\n+\n+     In this case we want to preserve the LVAL of ARG2 as this allows the\n+     resulting value to be used in more places.  We do this by calling\n+     VALUE_COPY if appropriate.  */\n+  if (types_deeply_equal (value_type (arg2), type))\n+    {\n+      /* If the types are exactly equal then we can avoid creating a new\n+\t value completely.  */\n+      if (value_type (arg2) != type)\n+\t{\n+\t  arg2 = value_copy (arg2);\n+\t  deprecated_set_value_type (arg2, type);\n+\t}\n+      return arg2;\n+    }\n \n   if (is_fixed_point_type (type))\n     return value_cast_to_fixed_point (type, arg2);"
    }
  ]
}