{
  "sha": "3b00ef10a2a4750a86a04bb66eda3bf33d298be1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2IwMGVmMTBhMmE0NzUwYTg2YTA0YmI2NmVkYTNiZjMzZDI5OGJlMQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-07-08T12:23:16Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-09-10T14:30:45Z"
    },
    "message": "Add Ada support for .debug_names\n\nThis patch adds support for Ada to .debug_names.  I opted to leave\n.gdb_index alone, because in my view it is a defunct format.\n\ngdb/ChangeLog\n2019-09-10  Tom Tromey  <tromey@adacore.com>\n\n\t* dwarf-index-write.c (write_psymbols): Extend error message.\n\t(debug_names::insert): Add Ada code.\n\t(debug_names::write_psymbols): Remove Ada check.\n\t(debug_names) <m_string_obstack>: New member.\n\t* dwarf2read.c (gdb_index_symbol_name_matcher): Remove.\n\t(gdb_index_symbol_name_matcher::matches): Remove.\n\t(mapped_index_base::find_name_components_bounds): Add \"lang\"\n\tparameter.\n\t(mapped_index_base::build_name_components): Also split names\n\taccording to Ada syntax.\n\t(dw2_expand_symtabs_matching_symbol): Loop over languages.  Change\n\ttype of \"match_callback\".\n\t(check_match, check_find_bounds_finds)\n\t(dw2_expand_symtabs_matching): Update.\n\t(dw2_debug_names_iterator): Add new constructor.\n\t(dw2_debug_names_map_matching_symbols): New function.\n\t(dw2_debug_names_expand_symtabs_matching): Update.\n\t(dwarf2_debug_names_functions): Use\n\tdw2_debug_names_map_matching_symbols.",
    "tree": {
      "sha": "727c40c0df3bfc1a1da24df5e4d5162067b5c13a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/727c40c0df3bfc1a1da24df5e4d5162067b5c13a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3b00ef10a2a4750a86a04bb66eda3bf33d298be1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3b00ef10a2a4750a86a04bb66eda3bf33d298be1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3b00ef10a2a4750a86a04bb66eda3bf33d298be1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3b00ef10a2a4750a86a04bb66eda3bf33d298be1/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "aa3916548076c159ae00a922690694094a37fcd0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aa3916548076c159ae00a922690694094a37fcd0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/aa3916548076c159ae00a922690694094a37fcd0"
    }
  ],
  "stats": {
    "total": 353,
    "additions": 223,
    "deletions": 130
  },
  "files": [
    {
      "sha": "dace64e6be336a1d4d26c1d2d0793dcccbffebe3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b00ef10a2a4750a86a04bb66eda3bf33d298be1/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b00ef10a2a4750a86a04bb66eda3bf33d298be1/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3b00ef10a2a4750a86a04bb66eda3bf33d298be1",
      "patch": "@@ -1,3 +1,25 @@\n+2019-09-10  Tom Tromey  <tromey@adacore.com>\n+\n+\t* dwarf-index-write.c (write_psymbols): Extend error message.\n+\t(debug_names::insert): Add Ada code.\n+\t(debug_names::write_psymbols): Remove Ada check.\n+\t(debug_names) <m_string_obstack>: New member.\n+\t* dwarf2read.c (gdb_index_symbol_name_matcher): Remove.\n+\t(gdb_index_symbol_name_matcher::matches): Remove.\n+\t(mapped_index_base::find_name_components_bounds): Add \"lang\"\n+\tparameter.\n+\t(mapped_index_base::build_name_components): Also split names\n+\taccording to Ada syntax.\n+\t(dw2_expand_symtabs_matching_symbol): Loop over languages.  Change\n+\ttype of \"match_callback\".\n+\t(check_match, check_find_bounds_finds)\n+\t(dw2_expand_symtabs_matching): Update.\n+\t(dw2_debug_names_iterator): Add new constructor.\n+\t(dw2_debug_names_map_matching_symbols): New function.\n+\t(dw2_debug_names_expand_symtabs_matching): Update.\n+\t(dwarf2_debug_names_functions): Use\n+\tdw2_debug_names_map_matching_symbols.\n+\n 2019-09-10  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf2read.c (dw2_get_file_names_reader): Add the"
    },
    {
      "sha": "153c6792f0c2d08cf7f6a24230899a04c505ba0a",
      "filename": "gdb/dwarf-index-write.c",
      "status": "modified",
      "additions": 43,
      "deletions": 5,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b00ef10a2a4750a86a04bb66eda3bf33d298be1/gdb/dwarf-index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b00ef10a2a4750a86a04bb66eda3bf33d298be1/gdb/dwarf-index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf-index-write.c?ref=3b00ef10a2a4750a86a04bb66eda3bf33d298be1",
      "patch": "@@ -34,6 +34,7 @@\n #include \"gdbcmd.h\"\n #include \"objfiles.h\"\n #include \"psympriv.h\"\n+#include \"ada-lang.h\"\n \n #include <algorithm>\n #include <cmath>\n@@ -541,7 +542,8 @@ write_psymbols (struct mapped_symtab *symtab,\n       struct partial_symbol *psym = *psymp;\n \n       if (psym->ginfo.language == language_ada)\n-\terror (_(\"Ada is not currently supported by the index\"));\n+\terror (_(\"Ada is not currently supported by the index; \"\n+\t\t \"use the DWARF 5 index instead\"));\n \n       /* Only add a given psymbol once.  */\n       if (psyms_seen.insert (psym).second)\n@@ -684,7 +686,43 @@ class debug_names\n     const int dwarf_tag = psymbol_tag (psym);\n     if (dwarf_tag == 0)\n       return;\n-    const char *const name = symbol_search_name (&psym->ginfo);\n+    const char *name = symbol_search_name (&psym->ginfo);\n+\n+    if (psym->ginfo.language == language_ada)\n+      {\n+\t/* We want to ensure that the Ada main function's name appears\n+\t   verbatim in the index.  However, this name will be of the\n+\t   form \"_ada_mumble\", and will be rewritten by ada_decode.\n+\t   So, recognize it specially here and add it to the index by\n+\t   hand.  */\n+\tif (strcmp (main_name (), name) == 0)\n+\t  {\n+\t    const auto insertpair\n+\t      = m_name_to_value_set.emplace (c_str_view (name),\n+\t\t\t\t\t     std::set<symbol_value> ());\n+\t    std::set<symbol_value> &value_set = insertpair.first->second;\n+\t    value_set.emplace (symbol_value (dwarf_tag, cu_index, is_static,\n+\t\t\t\t\t     kind));\n+\t  }\n+\n+\t/* In order for the index to work when read back into gdb, it\n+\t   has to supply a funny form of the name: it should be the\n+\t   encoded name, with any suffixes stripped.  Using the\n+\t   ordinary encoded name will not work properly with the\n+\t   searching logic in find_name_components_bounds; nor will\n+\t   using the decoded name.  Furthermore, an Ada \"verbatim\"\n+\t   name (of the form \"<MumBle>\") must be entered without the\n+\t   angle brackets.  Note that the current index is unusual,\n+\t   see PR symtab/24820 for details.  */\n+\tconst char *decoded = ada_decode (name);\n+\tif (decoded[0] == '<')\n+\t  name = (char *) obstack_copy0 (&m_string_obstack,\n+\t\t\t\t\t decoded + 1,\n+\t\t\t\t\t strlen (decoded + 1) - 1);\n+\telse\n+\t  name = obstack_strdup (&m_string_obstack, ada_encode (decoded));\n+      }\n+\n     const auto insertpair\n       = m_name_to_value_set.emplace (c_str_view (name),\n \t\t\t\t     std::set<symbol_value> ());\n@@ -1181,9 +1219,6 @@ class debug_names\n       {\n \tstruct partial_symbol *psym = *psymp;\n \n-\tif (psym->ginfo.language == language_ada)\n-\t  error (_(\"Ada is not currently supported by the index\"));\n-\n \t/* Only add a given psymbol once.  */\n \tif (psyms_seen.insert (psym).second)\n \t  insert (psym, cu_index, is_static, kind);\n@@ -1244,6 +1279,9 @@ class debug_names\n \n   /* .debug_names entry pool.  */\n   data_buf m_entry_pool;\n+\n+  /* Temporary storage for Ada names.  */\n+  auto_obstack m_string_obstack;\n };\n \n /* Return iff any of the needed offsets does not fit into 32-bit"
    },
    {
      "sha": "c94fc245fdf6ff14e03d37eda9b56b3713d87829",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 158,
      "deletions": 125,
      "changes": 283,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3b00ef10a2a4750a86a04bb66eda3bf33d298be1/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3b00ef10a2a4750a86a04bb66eda3bf33d298be1/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=3b00ef10a2a4750a86a04bb66eda3bf33d298be1",
      "patch": "@@ -179,7 +179,8 @@ struct mapped_index_base\n      vector.  */\n   std::pair<std::vector<name_component>::const_iterator,\n \t    std::vector<name_component>::const_iterator>\n-    find_name_components_bounds (const lookup_name_info &ln_no_params) const;\n+    find_name_components_bounds (const lookup_name_info &ln_no_params,\n+\t\t\t\t enum language lang) const;\n \n   /* Prevent deleting/destroying via a base class pointer.  */\n protected:\n@@ -4202,93 +4203,6 @@ dw2_map_matching_symbols\n      does not look for non-Ada symbols this function should just return.  */\n }\n \n-/* Symbol name matcher for .gdb_index names.\n-\n-   Symbol names in .gdb_index have a few particularities:\n-\n-   - There's no indication of which is the language of each symbol.\n-\n-     Since each language has its own symbol name matching algorithm,\n-     and we don't know which language is the right one, we must match\n-     each symbol against all languages.  This would be a potential\n-     performance problem if it were not mitigated by the\n-     mapped_index::name_components lookup table, which significantly\n-     reduces the number of times we need to call into this matcher,\n-     making it a non-issue.\n-\n-   - Symbol names in the index have no overload (parameter)\n-     information.  I.e., in C++, \"foo(int)\" and \"foo(long)\" both\n-     appear as \"foo\" in the index, for example.\n-\n-     This means that the lookup names passed to the symbol name\n-     matcher functions must have no parameter information either\n-     because (e.g.) symbol search name \"foo\" does not match\n-     lookup-name \"foo(int)\" [while swapping search name for lookup\n-     name would match].\n-*/\n-class gdb_index_symbol_name_matcher\n-{\n-public:\n-  /* Prepares the vector of comparison functions for LOOKUP_NAME.  */\n-  gdb_index_symbol_name_matcher (const lookup_name_info &lookup_name);\n-\n-  /* Walk all the matcher routines and match SYMBOL_NAME against them.\n-     Returns true if any matcher matches.  */\n-  bool matches (const char *symbol_name);\n-\n-private:\n-  /* A reference to the lookup name we're matching against.  */\n-  const lookup_name_info &m_lookup_name;\n-\n-  /* A vector holding all the different symbol name matchers, for all\n-     languages.  */\n-  std::vector<symbol_name_matcher_ftype *> m_symbol_name_matcher_funcs;\n-};\n-\n-gdb_index_symbol_name_matcher::gdb_index_symbol_name_matcher\n-  (const lookup_name_info &lookup_name)\n-    : m_lookup_name (lookup_name)\n-{\n-  /* Prepare the vector of comparison functions upfront, to avoid\n-     doing the same work for each symbol.  Care is taken to avoid\n-     matching with the same matcher more than once if/when multiple\n-     languages use the same matcher function.  */\n-  auto &matchers = m_symbol_name_matcher_funcs;\n-  matchers.reserve (nr_languages);\n-\n-  matchers.push_back (default_symbol_name_matcher);\n-\n-  for (int i = 0; i < nr_languages; i++)\n-    {\n-      const language_defn *lang = language_def ((enum language) i);\n-      symbol_name_matcher_ftype *name_matcher\n-\t= get_symbol_name_matcher (lang, m_lookup_name);\n-\n-      /* Don't insert the same comparison routine more than once.\n-\t Note that we do this linear walk instead of a seemingly\n-\t cheaper sorted insert, or use a std::set or something like\n-\t that, because relative order of function addresses is not\n-\t stable.  This is not a problem in practice because the number\n-\t of supported languages is low, and the cost here is tiny\n-\t compared to the number of searches we'll do afterwards using\n-\t this object.  */\n-      if (name_matcher != default_symbol_name_matcher\n-\t  && (std::find (matchers.begin (), matchers.end (), name_matcher)\n-\t      == matchers.end ()))\n-\tmatchers.push_back (name_matcher);\n-    }\n-}\n-\n-bool\n-gdb_index_symbol_name_matcher::matches (const char *symbol_name)\n-{\n-  for (auto matches_name : m_symbol_name_matcher_funcs)\n-    if (matches_name (symbol_name, m_lookup_name, NULL))\n-      return true;\n-\n-  return false;\n-}\n-\n /* Starting from a search name, return the string that finds the upper\n    bound of all strings that start with SEARCH_NAME in a sorted name\n    list.  Returns the empty string to indicate that the upper bound is\n@@ -4367,13 +4281,13 @@ make_sort_after_prefix_name (const char *search_name)\n std::pair<std::vector<name_component>::const_iterator,\n \t  std::vector<name_component>::const_iterator>\n mapped_index_base::find_name_components_bounds\n-  (const lookup_name_info &lookup_name_without_params) const\n+  (const lookup_name_info &lookup_name_without_params, language lang) const\n {\n   auto *name_cmp\n     = this->name_components_casing == case_sensitive_on ? strcmp : strcasecmp;\n \n-  const char *cplus\n-    = lookup_name_without_params.cplus ().lookup_name ().c_str ();\n+  const char *lang_name\n+    = lookup_name_without_params.language_lookup_name (lang).c_str ();\n \n   /* Comparison function object for lower_bound that matches against a\n      given symbol name.  */\n@@ -4401,10 +4315,10 @@ mapped_index_base::find_name_components_bounds\n   /* Find the lower bound.  */\n   auto lower = [&] ()\n     {\n-      if (lookup_name_without_params.completion_mode () && cplus[0] == '\\0')\n+      if (lookup_name_without_params.completion_mode () && lang_name[0] == '\\0')\n \treturn begin;\n       else\n-\treturn std::lower_bound (begin, end, cplus, lookup_compare_lower);\n+\treturn std::lower_bound (begin, end, lang_name, lookup_compare_lower);\n     } ();\n \n   /* Find the upper bound.  */\n@@ -4423,14 +4337,14 @@ mapped_index_base::find_name_components_bounds\n \t     We find the upper bound by looking for the insertion\n \t     point of \"func\"-with-last-character-incremented,\n \t     i.e. \"fund\".  */\n-\t  std::string after = make_sort_after_prefix_name (cplus);\n+\t  std::string after = make_sort_after_prefix_name (lang_name);\n \t  if (after.empty ())\n \t    return end;\n \t  return std::lower_bound (lower, end, after.c_str (),\n \t\t\t\t   lookup_compare_lower);\n \t}\n       else\n-\treturn std::upper_bound (lower, end, cplus, lookup_compare_upper);\n+\treturn std::upper_bound (lower, end, lang_name, lookup_compare_upper);\n     } ();\n \n   return {lower, upper};\n@@ -4450,11 +4364,7 @@ mapped_index_base::build_name_components ()\n \n   /* The code below only knows how to break apart components of C++\n      symbol names (and other languages that use '::' as\n-     namespace/module separator).  If we add support for wild matching\n-     to some language that uses some other operator (E.g., Ada, Go and\n-     D use '.'), then we'll need to try splitting the symbol name\n-     according to that language too.  Note that Ada does support wild\n-     matching, but doesn't currently support .gdb_index.  */\n+     namespace/module separator) and Ada symbol names.  */\n   auto count = this->symbol_name_count ();\n   for (offset_type idx = 0; idx < count; idx++)\n     {\n@@ -4465,16 +4375,33 @@ mapped_index_base::build_name_components ()\n \n       /* Add each name component to the name component table.  */\n       unsigned int previous_len = 0;\n-      for (unsigned int current_len = cp_find_first_component (name);\n-\t   name[current_len] != '\\0';\n-\t   current_len += cp_find_first_component (name + current_len))\n+\n+      if (strstr (name, \"::\") != nullptr)\n+\t{\n+\t  for (unsigned int current_len = cp_find_first_component (name);\n+\t       name[current_len] != '\\0';\n+\t       current_len += cp_find_first_component (name + current_len))\n+\t    {\n+\t      gdb_assert (name[current_len] == ':');\n+\t      this->name_components.push_back ({previous_len, idx});\n+\t      /* Skip the '::'.  */\n+\t      current_len += 2;\n+\t      previous_len = current_len;\n+\t    }\n+\t}\n+      else\n \t{\n-\t  gdb_assert (name[current_len] == ':');\n-\t  this->name_components.push_back ({previous_len, idx});\n-\t  /* Skip the '::'.  */\n-\t  current_len += 2;\n-\t  previous_len = current_len;\n+\t  /* Handle the Ada encoded (aka mangled) form here.  */\n+\t  for (const char *iter = strstr (name, \"__\");\n+\t       iter != nullptr;\n+\t       iter = strstr (iter, \"__\"))\n+\t    {\n+\t      this->name_components.push_back ({previous_len, idx});\n+\t      iter += 2;\n+\t      previous_len = iter - name;\n+\t    }\n \t}\n+\n       this->name_components.push_back ({previous_len, idx});\n     }\n \n@@ -4509,22 +4436,15 @@ dw2_expand_symtabs_matching_symbol\n    const lookup_name_info &lookup_name_in,\n    gdb::function_view<expand_symtabs_symbol_matcher_ftype> symbol_matcher,\n    enum search_domain kind,\n-   gdb::function_view<void (offset_type)> match_callback)\n+   gdb::function_view<bool (offset_type)> match_callback)\n {\n   lookup_name_info lookup_name_without_params\n     = lookup_name_in.make_ignore_params ();\n-  gdb_index_symbol_name_matcher lookup_name_matcher\n-    (lookup_name_without_params);\n \n   /* Build the symbol name component sorted vector, if we haven't\n      yet.  */\n   index.build_name_components ();\n \n-  auto bounds = index.find_name_components_bounds (lookup_name_without_params);\n-\n-  /* Now for each symbol name in range, check to see if we have a name\n-     match, and if so, call the MATCH_CALLBACK callback.  */\n-\n   /* The same symbol may appear more than once in the range though.\n      E.g., if we're looking for symbols that complete \"w\", and we have\n      a symbol named \"w1::w2\", we'll find the two name components for\n@@ -4533,17 +4453,61 @@ dw2_expand_symtabs_matching_symbol\n      indexes that matched in a temporary vector and ignore\n      duplicates.  */\n   std::vector<offset_type> matches;\n-  matches.reserve (std::distance (bounds.first, bounds.second));\n \n-  for (; bounds.first != bounds.second; ++bounds.first)\n+  struct name_and_matcher\n+  {\n+    symbol_name_matcher_ftype *matcher;\n+    const std::string &name;\n+\n+    bool operator== (const name_and_matcher &other) const\n     {\n-      const char *qualified = index.symbol_name_at (bounds.first->idx);\n+      return matcher == other.matcher && name == other.name;\n+    }\n+  };\n+\n+  /* A vector holding all the different symbol name matchers, for all\n+     languages.  */\n+  std::vector<name_and_matcher> matchers;\n+\n+  for (int i = 0; i < nr_languages; i++)\n+    {\n+      enum language lang_e = (enum language) i;\n+\n+      const language_defn *lang = language_def (lang_e);\n+      symbol_name_matcher_ftype *name_matcher\n+\t= get_symbol_name_matcher (lang, lookup_name_without_params);\n+\n+      name_and_matcher key {\n+         name_matcher,\n+\t lookup_name_without_params.language_lookup_name (lang_e)\n+      };\n \n-      if (!lookup_name_matcher.matches (qualified)\n-\t  || (symbol_matcher != NULL && !symbol_matcher (qualified)))\n+      /* Don't insert the same comparison routine more than once.\n+\t Note that we do this linear walk.  This is not a problem in\n+\t practice because the number of supported languages is\n+\t low.  */\n+      if (std::find (matchers.begin (), matchers.end (), key)\n+\t  != matchers.end ())\n \tcontinue;\n+      matchers.push_back (std::move (key));\n+\n+      auto bounds\n+\t= index.find_name_components_bounds (lookup_name_without_params,\n+\t\t\t\t\t     lang_e);\n+\n+      /* Now for each symbol name in range, check to see if we have a name\n+\t match, and if so, call the MATCH_CALLBACK callback.  */\n+\n+      for (; bounds.first != bounds.second; ++bounds.first)\n+\t{\n+\t  const char *qualified = index.symbol_name_at (bounds.first->idx);\n \n-      matches.push_back (bounds.first->idx);\n+\t  if (!name_matcher (qualified, lookup_name_without_params, NULL)\n+\t      || (symbol_matcher != NULL && !symbol_matcher (qualified)))\n+\t    continue;\n+\n+\t  matches.push_back (bounds.first->idx);\n+\t}\n     }\n \n   std::sort (matches.begin (), matches.end ());\n@@ -4554,7 +4518,8 @@ dw2_expand_symtabs_matching_symbol\n     {\n       if (prev != idx)\n \t{\n-\t  match_callback (idx);\n+\t  if (!match_callback (idx))\n+\t    break;\n \t  prev = idx;\n \t}\n     }\n@@ -4649,6 +4614,7 @@ check_match (const char *file, int line,\n \n     if (expected_str == NULL || strcmp (expected_str, matched_name) != 0)\n       mismatch (expected_str, matched_name);\n+    return true;\n   });\n \n   const char *expected_str\n@@ -4715,7 +4681,8 @@ check_find_bounds_finds (mapped_index_base &index,\n   lookup_name_info lookup_name (search_name,\n \t\t\t\tsymbol_name_match_type::FULL, true);\n \n-  auto bounds = index.find_name_components_bounds (lookup_name);\n+  auto bounds = index.find_name_components_bounds (lookup_name,\n+\t\t\t\t\t\t   language_cplus);\n \n   size_t distance = std::distance (bounds.first, bounds.second);\n   if (distance != expected_syms.size ())\n@@ -5200,6 +5167,7 @@ dw2_expand_symtabs_matching\n     {\n       dw2_expand_marked_cus (dwarf2_per_objfile, idx, file_matcher,\n \t\t\t     expansion_notify, kind);\n+      return true;\n     });\n }\n \n@@ -5684,6 +5652,13 @@ class dw2_debug_names_iterator\n       m_addr (find_vec_in_debug_names (map, namei))\n   {}\n \n+  dw2_debug_names_iterator (const mapped_debug_names &map,\n+\t\t\t    block_enum block_index, domain_enum domain,\n+\t\t\t    uint32_t namei)\n+    : m_map (map), m_block_index (block_index), m_domain (domain),\n+      m_addr (find_vec_in_debug_names (map, namei))\n+  {}\n+\n   /* Return the next matching CU or NULL if there are no more.  */\n   dwarf2_per_cu_data *next ();\n \n@@ -6101,6 +6076,63 @@ dw2_debug_names_expand_symtabs_for_function (struct objfile *objfile,\n     }\n }\n \n+static void\n+dw2_debug_names_map_matching_symbols\n+  (struct objfile *objfile,\n+   const lookup_name_info &name, domain_enum domain,\n+   int global,\n+   gdb::function_view<symbol_found_callback_ftype> callback,\n+   symbol_compare_ftype *ordered_compare)\n+{\n+  struct dwarf2_per_objfile *dwarf2_per_objfile\n+    = get_dwarf2_per_objfile (objfile);\n+\n+  /* debug_names_table is NULL if OBJF_READNOW.  */\n+  if (!dwarf2_per_objfile->debug_names_table)\n+    return;\n+\n+  mapped_debug_names &map = *dwarf2_per_objfile->debug_names_table;\n+  const block_enum block_kind = global ? GLOBAL_BLOCK : STATIC_BLOCK;\n+\n+  const char *match_name = name.ada ().lookup_name ().c_str ();\n+  auto matcher = [&] (const char *symname)\n+    {\n+      if (ordered_compare == nullptr)\n+\treturn true;\n+      return ordered_compare (symname, match_name) == 0;\n+    };\n+\n+  dw2_expand_symtabs_matching_symbol (map, name, matcher, ALL_DOMAIN,\n+\t\t\t\t      [&] (offset_type namei)\n+    {\n+      /* The name was matched, now expand corresponding CUs that were\n+\t marked.  */\n+      dw2_debug_names_iterator iter (map, block_kind, domain, namei);\n+\n+      struct dwarf2_per_cu_data *per_cu;\n+      while ((per_cu = iter.next ()) != NULL)\n+\tdw2_expand_symtabs_matching_one (per_cu, nullptr, nullptr);\n+      return true;\n+    });\n+\n+  /* It's a shame we couldn't do this inside the\n+     dw2_expand_symtabs_matching_symbol callback, but that skips CUs\n+     that have already been expanded.  Instead, this loop matches what\n+     the psymtab code does.  */\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+    {\n+      struct compunit_symtab *cust = per_cu->v.quick->compunit_symtab;\n+      if (cust != nullptr)\n+\t{\n+\t  const struct block *block\n+\t    = BLOCKVECTOR_BLOCK (COMPUNIT_BLOCKVECTOR (cust), block_kind);\n+\t  if (!iterate_over_symbols_terminated (block, name,\n+\t\t\t\t\t\tdomain, callback))\n+\t    break;\n+\t}\n+    }\n+}\n+\n static void\n dw2_debug_names_expand_symtabs_matching\n   (struct objfile *objfile,\n@@ -6133,6 +6165,7 @@ dw2_debug_names_expand_symtabs_matching\n       while ((per_cu = iter.next ()) != NULL)\n \tdw2_expand_symtabs_matching_one (per_cu, file_matcher,\n \t\t\t\t\t expansion_notify);\n+      return true;\n     });\n }\n \n@@ -6148,7 +6181,7 @@ const struct quick_symbol_functions dwarf2_debug_names_functions =\n   dw2_debug_names_expand_symtabs_for_function,\n   dw2_expand_all_symtabs,\n   dw2_expand_symtabs_with_fullname,\n-  dw2_map_matching_symbols,\n+  dw2_debug_names_map_matching_symbols,\n   dw2_debug_names_expand_symtabs_matching,\n   dw2_find_pc_sect_compunit_symtab,\n   NULL,"
    }
  ]
}