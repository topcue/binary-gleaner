{
  "sha": "275ee935b336458aea19b63ce745cacee9b68d12",
  "node_id": "C_kwDOANOeidoAKDI3NWVlOTM1YjMzNjQ1OGFlYTE5YjYzY2U3NDVjYWNlZTliNjhkMTI",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-05-26T21:03:23Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-09-27T10:17:21Z"
    },
    "message": "gdb: prevent an assertion when computing the frame_id for an inline frame\n\nI ran into this assertion while GDB was trying to unwind the stack:\n\n  gdb/inline-frame.c:173: internal-error: void inline_frame_this_id(frame_info*, void**, frame_id*): Assertion `frame_id_p (*this_id)' failed.\n\nThat is, when building the frame_id for an inline frame, GDB asks for\nthe frame_id of the previous frame.  Unfortunately, no valid frame_id\nwas returned for the previous frame, and so the assertion triggers.\n\nWhat is happening is this, I had a stack that looked something like\nthis (the arrows '->' point from caller to callee):\n\n  normal_frame -> inline_frame\n\nHowever, for whatever reason (e.g. broken debug information, or\ncorrupted stack contents in the inferior), when GDB tries to unwind\n\"normal_frame\", it ends up getting back effectively the same frame,\nthus the call stack looks like this to GDB:\n\n  .-> normal_frame -> inline_frame\n  |     |\n  '-----'\n\nGiven such a situation we would expect GDB to terminate the stack with\nan error like this:\n\n  Backtrace stopped: previous frame identical to this frame (corrupt stack?)\n\nHowever, the inline_frame causes a problem, and here's why:\n\nWhen unwinding we start from the sentinel frame and call\nget_prev_frame.  We eventually end up in get_prev_frame_if_no_cycle,\nin here we create a raw frame, and as this is frame #0 we immediately\nreturn.\n\nHowever, eventually we will try to unwind the stack further.  When we\ndo this we inevitably needing to know the frame_id for frame #0, and\nso, eventually, we end up in compute_frame_id.\n\nIn compute_frame_id we first find the right unwinder for this frame,\nin our case (i.e. for inline_frame) the $pc is within the function\nnormal_frame, but also within a block associated with the inlined\nfunction inline_frame, as such the inline frame unwinder claims this\nframe.\n\nBack in compute_frame_id we next compute the frame_id, for our\ninline_frame this means a call to inline_frame_this_id.\n\nThe ID of an inline frame is based on the id of the previous frame, so\nfrom inline_frame_this_id we call get_prev_frame_always, this\neventually calls get_prev_frame_if_no_cycle again, which creates\nanother raw frame and calls compute_frame_id (for frames other than\nframe 0 we immediately compute the frame_id).\n\nIn compute_frame_id we again identify the correct unwinder for this\nframe.  Our $pc is unchanged, however, the fact that the next frame is\nof type INLINE_FRAME prevents the inline frame unwinder from claiming\nthis frame again, and so, the standard DWARF frame unwinder claims\nnormal_frame.\n\nWe return to compute_frame_id and call the standard DWARF function to\nbuild the frame_id for normal_frame.\n\nWith the frame_id of normal_frame figured out we return to\ncompute_frame_id, and then to get_prev_frame_if_no_cycle, where we add\nthe ID for normal_frame into the frame_id cache, and return the frame\nback to inline_frame_this_id.\n\nFrom inline_frame_this_id we build a frame_id for inline_frame and\nreturn to compute_frame_id, and then to get_prev_frame_if_no_cycle,\nwhich adds the frame_id for inline_frame into the frame_id cache.\n\nSo far, so good.\n\nHowever, as we are trying to unwind the complete stack, we eventually\nask for the previous frame of normal_frame, remember, at this point\nGDB doesn't know the stack is corrupted (with a cycle), GDB still\nneeds to figure that out.\n\nSo, we eventually end up in get_prev_frame_if_no_cycle where we create\na raw frame and call compute_frame_id, remember, this is for the frame\nbefore normal_frame.\n\nThe first task for compute_frame_id is to find the unwinder for this\nframe, so all of the frame sniffers are tried in order, this includes\nthe inline frame sniffer.\n\nThe inline frame sniffer asks for the $pc, this request is sent up the\nstack to normal_frame, which, due to its cyclic behaviour, tells GDB\nthat the $pc in the previous frame was the same as the $pc in\nnormal_frame.\n\nGDB spots that this $pc corresponds to both the function normal_frame\nand also the inline function inline_frame.  As the next frame is not\nan INLINE_FRAME then GDB figures that we have not yet built a frame to\ncover inline_frame, and so the inline sniffer claims this new frame.\nOur stack is now looking like this:\n\n  inline_frame -> normal_frame -> inline_frame\n\nBut, we have not yet computed the frame id for the outer most (on the\nleft) inline_frame.  After the frame sniffer has claimed the inline\nframe GDB returns to compute_frame_id and calls inline_frame_this_id.\n\nIn here GDB calls get_prev_frame_always, which eventually ends up\nin get_prev_frame_if_no_cycle again, where we create a raw frame and\ncall compute_frame_id.\n\nJust like before, compute_frame_id tries to find an unwinder for this\nnew frame, it sees that the $pc is within both normal_frame and\ninline_frame, but the next frame is, again, an INLINE_FRAME, so, just\nlike before the standard DWARF unwinder claims this frame.  Back in\ncompute_frame_id we again call the standard DWARF function to build\nthe frame_id for this new copy of normal_frame.\n\nAt this point the stack looks like this:\n\n  normal_frame -> inline_frame -> normal_frame -> inline_frame\n\nAfter compute_frame_id we return to get_prev_frame_if_no_cycle, where\nwe try to add the frame_id for the new normal_frame into the frame_id\ncache, however, unlike before, we fail to add this frame_id as it is\na duplicate of the previous normal_frame frame_id.  Having found a\nduplicate get_prev_frame_if_no_cycle unlinks the new frame from the\nstack, and returns nullptr, the stack now looks like this:\n\n  inline_frame -> normal_frame -> inline_frame\n\nThe nullptr result from get_prev_frame_if_no_cycle is fed back to\ninline_frame_this_id, which forwards this to get_frame_id, which\nimmediately returns null_frame_id.  As null_frame_id is not considered\na valid frame_id, this is what triggers the assertion.\n\nIn summary then:\n\n - inline_frame_this_id currently assumes that as the inline frame\n   exists, we will always get a valid frame back from\n   get_prev_frame_always,\n\n - get_prev_frame_if_no_cycle currently assumes that it is safe to\n   return nullptr when it sees a cycle.\n\nNotice that in frame.c:compute_frame_id, this code:\n\n  fi->this_id.value = outer_frame_id;\n  fi->unwind->this_id (fi, &fi->prologue_cache, &fi->this_id.value);\n  gdb_assert (frame_id_p (fi->this_id.value));\n\nThe assertion makes it clear that the this_id function must always\nreturn a valid frame_id (e.g. null_frame_id is not a valid return\nvalue), and similarly in inline_frame.c:inline_frame_this_id this\ncode:\n\n  *this_id = get_frame_id (get_prev_frame_always (this_frame));\n  /* snip comment */\n  gdb_assert (frame_id_p (*this_id));\n\nMakes it clear that every inline frame expects to be able to get a\nprevious frame, which will have a valid frame_id.\n\nAs I have discussed above, these assumptions don't currently hold in\nall cases.\n\nOne possibility would be to move the call to get_prev_frame_always\nforward from inline_frame_this_id to inline_frame_sniffer, however,\nthis falls foul of (in frame.c:frame_cleanup_after_sniffer) this\nassertion:\n\n  /* No sniffer should extend the frame chain; sniff based on what is\n     already certain.  */\n  gdb_assert (!frame->prev_p);\n\nThis assert prohibits any sniffer from trying to get the previous\nframe, as getting the previous frame is likely to depend on the next\nframe, I can understand why this assertion is a good thing, and I'm in\nno rush to alter this rule.\n\nThe solution proposed here takes onboard feedback from both Pedro, and\nSimon (see the links below).  The get_prev_frame_if_no_cycle function\nis renamed to get_prev_frame_maybe_check_cycle, and will now not do\ncycle detection for inline frames, even when we spot a duplicate frame\nit is still returned.  This is fine, as, if the normal frame has a\nduplicate frame-id then the inline frame will also have a duplicate\nframe-id.  And so, when we reject the inline frame, the duplicate\nnormal frame, which is previous to the inline frame, will also be\nrejected.\n\nIn inline-frame.c the call to get_prev_frame_always is no longer\nnested inside the call to get_frame_id.  There are reasons why\nget_prev_frame_always can return nullptr, for example, if there is a\nmemory error while trying to get the previous frame, if this should\nhappen then we now give a more informative error message.\n\nHistorical Links:\n\n Patch v2: https://sourceware.org/pipermail/gdb-patches/2021-June/180208.html\n Feedback: https://sourceware.org/pipermail/gdb-patches/2021-July/180651.html\n           https://sourceware.org/pipermail/gdb-patches/2021-July/180663.html\n\n Patch v3: https://sourceware.org/pipermail/gdb-patches/2021-July/181029.html\n Feedback: https://sourceware.org/pipermail/gdb-patches/2021-July/181035.html\n\n Additional input: https://sourceware.org/pipermail/gdb-patches/2021-September/182040.html",
    "tree": {
      "sha": "4a2dede23bfe61baeb7425dbca0de4b772ded154",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4a2dede23bfe61baeb7425dbca0de4b772ded154"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/275ee935b336458aea19b63ce745cacee9b68d12",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/275ee935b336458aea19b63ce745cacee9b68d12",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/275ee935b336458aea19b63ce745cacee9b68d12",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/275ee935b336458aea19b63ce745cacee9b68d12/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ee2ff2eaa51ab83e24a14feae968cd575276e6a7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ee2ff2eaa51ab83e24a14feae968cd575276e6a7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ee2ff2eaa51ab83e24a14feae968cd575276e6a7"
    }
  ],
  "stats": {
    "total": 353,
    "additions": 344,
    "deletions": 9
  },
  "files": [
    {
      "sha": "16673258373d39337a2db76c35205ae1f8cf48fb",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 52,
      "deletions": 8,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/275ee935b336458aea19b63ce745cacee9b68d12/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/275ee935b336458aea19b63ce745cacee9b68d12/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=275ee935b336458aea19b63ce745cacee9b68d12",
      "patch": "@@ -2044,14 +2044,23 @@ frame_register_unwind_location (struct frame_info *this_frame, int regnum,\n    outermost, with UNWIND_SAME_ID stop reason.  Unlike the other\n    validity tests, that compare THIS_FRAME and the next frame, we do\n    this right after creating the previous frame, to avoid ever ending\n-   up with two frames with the same id in the frame chain.  */\n+   up with two frames with the same id in the frame chain.\n+\n+   There is however, one case where this cycle detection is not desirable,\n+   when asking for the previous frame of an inline frame, in this case, if\n+   the previous frame is a duplicate and we return nullptr then we will be\n+   unable to calculate the frame_id of the inline frame, this in turn\n+   causes inline_frame_this_id() to fail.  So for inline frames (and only\n+   for inline frames), the previous frame will always be returned, even when it\n+   has a duplicate frame_id.  We're not worried about cycles in the frame\n+   chain as, if the previous frame returned here has a duplicate frame_id,\n+   then the frame_id of the inline frame, calculated based off the frame_id\n+   of the previous frame, should also be a duplicate.  */\n \n static struct frame_info *\n-get_prev_frame_if_no_cycle (struct frame_info *this_frame)\n+get_prev_frame_maybe_check_cycle (struct frame_info *this_frame)\n {\n-  struct frame_info *prev_frame;\n-\n-  prev_frame = get_prev_frame_raw (this_frame);\n+  struct frame_info *prev_frame = get_prev_frame_raw (this_frame);\n \n   /* Don't compute the frame id of the current frame yet.  Unwinding\n      the sentinel frame can fail (e.g., if the thread is gone and we\n@@ -2070,7 +2079,42 @@ get_prev_frame_if_no_cycle (struct frame_info *this_frame)\n   try\n     {\n       compute_frame_id (prev_frame);\n-      if (!frame_stash_add (prev_frame))\n+\n+      bool cycle_detection_p = get_frame_type (this_frame) != INLINE_FRAME;\n+\n+      /* This assert checks GDB's state with respect to calculating the\n+\t frame-id of THIS_FRAME, in the case where THIS_FRAME is an inline\n+\t frame.\n+\n+\t If THIS_FRAME is frame #0, and is an inline frame, then we put off\n+\t calculating the frame_id until we specifically make a call to\n+\t get_frame_id().  As a result we can enter this function in two\n+\t possible states.  If GDB asked for the previous frame of frame #0\n+\t then THIS_FRAME will be frame #0 (an inline frame), and the\n+\t frame_id will be in the NOT_COMPUTED state.  However, if GDB asked\n+\t for the frame_id of frame #0, then, as getting the frame_id of an\n+\t inline frame requires us to get the frame_id of the previous\n+\t frame, we will still end up in here, and the frame_id status will\n+\t be COMPUTING.\n+\n+\t If, instead, THIS_FRAME is at a level greater than #0 then things\n+\t are simpler.  For these frames we immediately compute the frame_id\n+\t when the frame is initially created, and so, for those frames, we\n+\t will always enter this function with the frame_id status of\n+\t COMPUTING.  */\n+      gdb_assert (cycle_detection_p\n+\t\t  || (this_frame->level > 0\n+\t\t      && (this_frame->this_id.p\n+\t\t\t  == frame_id_status::COMPUTING))\n+\t\t  || (this_frame->level == 0\n+\t\t      && (this_frame->this_id.p\n+\t\t\t  != frame_id_status::COMPUTED)));\n+\n+      /* We must do the CYCLE_DETECTION_P check after attempting to add\n+\t PREV_FRAME into the cache; if PREV_FRAME is unique then we do want\n+\t it in the cache, but if it is a duplicate and CYCLE_DETECTION_P is\n+\t false, then we don't want to unlink it.  */\n+      if (!frame_stash_add (prev_frame) && cycle_detection_p)\n \t{\n \t  /* Another frame with the same id was already in the stash.  We just\n \t     detected a cycle.  */\n@@ -2147,7 +2191,7 @@ get_prev_frame_always_1 (struct frame_info *this_frame)\n      until we have unwound all the way down to the previous non-inline\n      frame.  */\n   if (get_frame_type (this_frame) == INLINE_FRAME)\n-    return get_prev_frame_if_no_cycle (this_frame);\n+    return get_prev_frame_maybe_check_cycle (this_frame);\n \n   /* If this_frame is the current frame, then compute and stash its\n      frame id prior to fetching and computing the frame id of the\n@@ -2248,7 +2292,7 @@ get_prev_frame_always_1 (struct frame_info *this_frame)\n \t}\n     }\n \n-  return get_prev_frame_if_no_cycle (this_frame);\n+  return get_prev_frame_maybe_check_cycle (this_frame);\n }\n \n /* Return a \"struct frame_info\" corresponding to the frame that called"
    },
    {
      "sha": "df7bd826ff54e6794fbd9f8c77f8c0f5f109d5f4",
      "filename": "gdb/inline-frame.c",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/275ee935b336458aea19b63ce745cacee9b68d12/gdb/inline-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/275ee935b336458aea19b63ce745cacee9b68d12/gdb/inline-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inline-frame.c?ref=275ee935b336458aea19b63ce745cacee9b68d12",
      "patch": "@@ -163,7 +163,10 @@ inline_frame_this_id (struct frame_info *this_frame,\n      function, there must be previous frames, so this is safe - as\n      long as we're careful not to create any cycles.  See related\n      comments in get_prev_frame_always_1.  */\n-  *this_id = get_frame_id (get_prev_frame_always (this_frame));\n+  frame_info *prev_frame = get_prev_frame_always (this_frame);\n+  if (prev_frame == nullptr)\n+    error (_(\"failed to find previous frame when computing inline frame id\"));\n+  *this_id = get_frame_id (prev_frame);\n \n   /* We need a valid frame ID, so we need to be based on a valid\n      frame.  FSF submission NOTE: this would be a good assertion to"
    },
    {
      "sha": "183c40928b66bbb002422e62ce86952815675bbb",
      "filename": "gdb/testsuite/gdb.base/inline-frame-cycle-unwind.c",
      "status": "added",
      "additions": 58,
      "deletions": 0,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/275ee935b336458aea19b63ce745cacee9b68d12/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/275ee935b336458aea19b63ce745cacee9b68d12/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.c?ref=275ee935b336458aea19b63ce745cacee9b68d12",
      "patch": "@@ -0,0 +1,58 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+static void inline_func (void);\n+static void normal_func (void);\n+\n+volatile int global_var;\n+volatile int level_counter;\n+\n+static void __attribute__((noinline))\n+normal_func (void)\n+{\n+  /* Do some work.  */\n+  ++global_var;\n+\n+  /* Now the inline function.  */\n+  --level_counter;\n+  inline_func ();\n+  ++level_counter;\n+\n+  /* Do some work.  */\n+  ++global_var;\n+}\n+\n+static inline void __attribute__((__always_inline__))\n+inline_func (void)\n+{\n+  if (level_counter > 1)\n+    {\n+      --level_counter;\n+      normal_func ();\n+      ++level_counter;\n+    }\n+  else\n+    ++global_var;\t/* Break here.  */\n+}\n+\n+int\n+main ()\n+{\n+  level_counter = 6;\n+  normal_func ();\n+  return 0;\n+}"
    },
    {
      "sha": "2801b683a037d0a11ca2f54db0b75cfe1ed54a91",
      "filename": "gdb/testsuite/gdb.base/inline-frame-cycle-unwind.exp",
      "status": "added",
      "additions": 145,
      "deletions": 0,
      "changes": 145,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/275ee935b336458aea19b63ce745cacee9b68d12/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/275ee935b336458aea19b63ce745cacee9b68d12/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.exp?ref=275ee935b336458aea19b63ce745cacee9b68d12",
      "patch": "@@ -0,0 +1,145 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This test checks for an edge case when unwinding inline frames which\n+# occur towards the older end of the stack when the stack ends with a\n+# cycle.  Consider this well formed stack:\n+#\n+#   main -> normal_frame -> inline_frame\n+#\n+# Now consider that, for whatever reason, the stack unwinding of\n+# \"normal_frame\" becomes corrupted, such that the stack appears to be\n+# this:\n+#\n+#   .-> normal_frame -> inline_frame\n+#   |      |\n+#   '------'\n+#\n+# When confronted with such a situation we would expect GDB to detect\n+# the stack frame cycle and terminate the backtrace at the first\n+# instance of \"normal_frame\" with a message:\n+#\n+#   Backtrace stopped: previous frame identical to this frame (corrupt stack?)\n+#\n+# However, at one point there was a bug in GDB's inline frame\n+# mechanism such that the fact that \"inline_frame\" was inlined into\n+# \"normal_frame\" would cause GDB to trigger an assertion.\n+#\n+# This text makes use of a Python unwinder which can fake the cyclic\n+# stack cycle, further the test sets up multiple levels of normal and\n+# inline frames.  At the point of testing the stack looks like this:\n+#\n+#   main -> normal_func -> inline_func -> normal_func -> inline_func -> normal_func -> inline_func\n+#\n+# Where \"normal_func\" is a normal frame, and \"inline_func\" is an inline frame.\n+#\n+# The python unwinder is then used to force a stack cycle at each\n+# \"normal_func\" frame in turn, we then check that GDB can successfully unwind\n+# the stack.\n+\n+standard_testfile\n+\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}]} {\n+    return -1\n+}\n+\n+# Skip this test if Python scripting is not enabled.\n+if { [skip_python_tests] } { continue }\n+\n+if ![runto_main] then {\n+    fail \"can't run to main\"\n+    return 0\n+}\n+\n+set pyfile [gdb_remote_download host ${srcdir}/${subdir}/${testfile}.py]\n+\n+# Run to the breakpoint where we will carry out the test.\n+gdb_breakpoint [gdb_get_line_number \"Break here\"]\n+gdb_continue_to_breakpoint \"stop at test breakpoint\"\n+\n+# Load the script containing the unwinder, this must be done at the\n+# testing point as the script will examine the stack as it is loaded.\n+gdb_test_no_output \"source ${pyfile}\"\\\n+    \"import python scripts\"\n+\n+# Check the unbroken stack.\n+gdb_test_sequence \"bt\" \"backtrace when the unwind is left unbroken\" {\n+    \"\\\\r\\\\n#0 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \"\n+    \"\\\\r\\\\n#1 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \"\n+    \"\\\\r\\\\n#2 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \"\n+    \"\\\\r\\\\n#3 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \"\n+    \"\\\\r\\\\n#4 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \"\n+    \"\\\\r\\\\n#5 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \"\n+    \"\\\\r\\\\n#6 \\[^\\r\\n\\]* main \\\\(\\\\) at \"\n+}\n+\n+with_test_prefix \"cycle at level 5\" {\n+    # Arrange to introduce a stack cycle at frame 5.\n+    gdb_test_no_output \"python stop_at_level=5\"\n+    gdb_test \"maint flush register-cache\" \\\n+\t\"Register cache flushed\\\\.\"\n+    gdb_test_lines \"bt\" \"backtrace when the unwind is broken at frame 5\" \\\n+\t[multi_line \\\n+\t     \"#0 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#1 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#2 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#3 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#4 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#5 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"Backtrace stopped: previous frame identical to this frame \\\\(corrupt stack\\\\?\\\\)\"]\n+}\n+\n+with_test_prefix \"cycle at level 3\" {\n+    # Arrange to introduce a stack cycle at frame 3.\n+    gdb_test_no_output \"python stop_at_level=3\"\n+    gdb_test \"maint flush register-cache\" \\\n+\t\"Register cache flushed\\\\.\"\n+    gdb_test_lines \"bt\" \"backtrace when the unwind is broken at frame 3\" \\\n+\t[multi_line \\\n+\t     \"#0 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#1 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#2 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#3 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"Backtrace stopped: previous frame identical to this frame \\\\(corrupt stack\\\\?\\\\)\"]\n+}\n+\n+with_test_prefix \"cycle at level 1\" {\n+    # Arrange to introduce a stack cycle at frame 1.\n+    gdb_test_no_output \"python stop_at_level=1\"\n+    gdb_test \"maint flush register-cache\" \\\n+\t\"Register cache flushed\\\\.\"\n+    gdb_test_lines \"bt\" \"backtrace when the unwind is broken at frame 1\" \\\n+\t[multi_line \\\n+\t     \"#0 \\[^\\r\\n\\]* inline_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"#1 \\[^\\r\\n\\]* normal_func \\\\(\\\\) at \\[^\\r\\n\\]+\" \\\n+\t     \"Backtrace stopped: previous frame identical to this frame \\\\(corrupt stack\\\\?\\\\)\"]\n+}\n+\n+# Flush the register cache (which also flushes the frame cache) so we\n+# get a full backtrace again, then switch on frame debugging and try\n+# to back trace.  At one point this triggered an assertion.\n+gdb_test \"maint flush register-cache\" \\\n+    \"Register cache flushed\\\\.\" \"\"\n+gdb_test_no_output \"set debug frame 1\"\n+gdb_test_multiple \"bt\" \"backtrace with debugging on\" {\n+    -re \"^$gdb_prompt $\" {\n+\tpass $gdb_test_name\n+    }\n+    -re \"\\[^\\r\\n\\]+\\r\\n\" {\n+\texp_continue\n+    }\n+}\n+gdb_test \"p 1 + 2 + 3\" \" = 6\" \\\n+    \"ensure GDB is still alive\""
    },
    {
      "sha": "99c571f973c82b501602d0677d5fd73e069dab86",
      "filename": "gdb/testsuite/gdb.base/inline-frame-cycle-unwind.py",
      "status": "added",
      "additions": 85,
      "deletions": 0,
      "changes": 85,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/275ee935b336458aea19b63ce745cacee9b68d12/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/275ee935b336458aea19b63ce745cacee9b68d12/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/inline-frame-cycle-unwind.py?ref=275ee935b336458aea19b63ce745cacee9b68d12",
      "patch": "@@ -0,0 +1,85 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+import gdb\n+from gdb.unwinder import Unwinder\n+\n+# Set this to the stack level the backtrace should be corrupted at.\n+# This will only work for frame 1, 3, or 5 in the test this unwinder\n+# was written for.\n+stop_at_level = None\n+\n+# Set this to the stack frame size of frames 1, 3, and 5.  These\n+# frames will all have the same stack frame size as they are the same\n+# function called recursively.\n+stack_adjust = None\n+\n+\n+class FrameId(object):\n+    def __init__(self, sp, pc):\n+        self._sp = sp\n+        self._pc = pc\n+\n+    @property\n+    def sp(self):\n+        return self._sp\n+\n+    @property\n+    def pc(self):\n+        return self._pc\n+\n+\n+class TestUnwinder(Unwinder):\n+    def __init__(self):\n+        Unwinder.__init__(self, \"stop at level\")\n+\n+    def __call__(self, pending_frame):\n+        global stop_at_level\n+        global stack_adjust\n+\n+        if stop_at_level is None or pending_frame.level() != stop_at_level:\n+            return None\n+\n+        if stack_adjust is None:\n+            raise gdb.GdbError(\"invalid stack_adjust\")\n+\n+        if not stop_at_level in [1, 3, 5]:\n+            raise gdb.GdbError(\"invalid stop_at_level\")\n+\n+        sp_desc = pending_frame.architecture().registers().find(\"sp\")\n+        sp = pending_frame.read_register(sp_desc) + stack_adjust\n+        pc = (gdb.lookup_symbol(\"normal_func\"))[0].value().address\n+        unwinder = pending_frame.create_unwind_info(FrameId(sp, pc))\n+\n+        for reg in pending_frame.architecture().registers(\"general\"):\n+            val = pending_frame.read_register(reg)\n+            unwinder.add_saved_register(reg, val)\n+        return unwinder\n+\n+\n+gdb.unwinder.register_unwinder(None, TestUnwinder(), True)\n+\n+# When loaded, it is expected that the stack looks like:\n+#\n+#   main -> normal_func -> inline_func -> normal_func -> inline_func -> normal_func -> inline_func\n+#\n+# Compute the stack frame size of normal_func, which has inline_func\n+# inlined within it.\n+f0 = gdb.newest_frame()\n+f1 = f0.older()\n+f2 = f1.older()\n+f0_sp = f0.read_register(\"sp\")\n+f2_sp = f2.read_register(\"sp\")\n+stack_adjust = f2_sp - f0_sp"
    }
  ]
}