{
  "sha": "ab31da6aff52fe3206cba98c03d7f74159da8677",
  "node_id": "C_kwDOANOeidoAKGFiMzFkYTZhZmY1MmZlMzIwNmNiYTk4YzAzZDdmNzQxNTlkYTg2Nzc",
  "commit": {
    "author": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2022-01-17T09:26:43Z"
    },
    "committer": {
      "name": "Jan Beulich",
      "email": "jbeulich@suse.com",
      "date": "2022-01-17T09:26:43Z"
    },
    "message": "x86: adjust struct instr_info field types\n\nNow that this lives on the stack, let's have it be a little less\nwasteful in terms of space. Switch boolean fields to \"bool\" (also when\nthis doesn't change their size) and also limit the widths of \"rex\",\n\"rex_used\", \"op_ad\", and \"op_index\". Do a little bit of re-ordering as\nwell to limit the number of padding holes.",
    "tree": {
      "sha": "5fc25701cc3f59ea37ccb4771a1f5f059d1f8118",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5fc25701cc3f59ea37ccb4771a1f5f059d1f8118"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ab31da6aff52fe3206cba98c03d7f74159da8677",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ab31da6aff52fe3206cba98c03d7f74159da8677",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ab31da6aff52fe3206cba98c03d7f74159da8677",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ab31da6aff52fe3206cba98c03d7f74159da8677/comments",
  "author": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jbeulich",
    "id": 5610135,
    "node_id": "MDQ6VXNlcjU2MTAxMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5610135?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jbeulich",
    "html_url": "https://github.com/jbeulich",
    "followers_url": "https://api.github.com/users/jbeulich/followers",
    "following_url": "https://api.github.com/users/jbeulich/following{/other_user}",
    "gists_url": "https://api.github.com/users/jbeulich/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jbeulich/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jbeulich/subscriptions",
    "organizations_url": "https://api.github.com/users/jbeulich/orgs",
    "repos_url": "https://api.github.com/users/jbeulich/repos",
    "events_url": "https://api.github.com/users/jbeulich/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jbeulich/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "71b94817f314db6ddb428e804378a30e7521a2ad",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/71b94817f314db6ddb428e804378a30e7521a2ad",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/71b94817f314db6ddb428e804378a30e7521a2ad"
    }
  ],
  "stats": {
    "total": 75,
    "additions": 39,
    "deletions": 36
  },
  "files": [
    {
      "sha": "862bd80b1bc8a2d6b6c1d3984b26d1598f8fdea8",
      "filename": "opcodes/i386-dis.c",
      "status": "modified",
      "additions": 39,
      "deletions": 36,
      "changes": 75,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ab31da6aff52fe3206cba98c03d7f74159da8677/opcodes/i386-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ab31da6aff52fe3206cba98c03d7f74159da8677/opcodes/i386-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-dis.c?ref=ab31da6aff52fe3206cba98c03d7f74159da8677",
      "patch": "@@ -147,9 +147,12 @@ struct instr_info\n   int prefixes;\n \n   /* REX prefix the current instruction.  See below.  */\n-  int rex;\n+  unsigned char rex;\n   /* Bits of REX we've already used.  */\n-  int rex_used;\n+  unsigned char rex_used;\n+\n+  bool need_modrm;\n+  bool need_vex;\n \n   /* Flags for ins->prefixes which we somehow handled when printing the\n      current instruction.  */\n@@ -191,7 +194,6 @@ struct instr_info\n     int rm;\n   }\n   modrm;\n-  unsigned char need_modrm;\n \n   struct\n   {\n@@ -206,25 +208,26 @@ struct instr_info\n     int register_specifier;\n     int length;\n     int prefix;\n-    int w;\n-    int evex;\n-    int r;\n-    int v;\n     int mask_register_specifier;\n-    int zeroing;\n     int ll;\n-    int b;\n-    int no_broadcast;\n+    bool w;\n+    bool evex;\n+    bool r;\n+    bool v;\n+    bool zeroing;\n+    bool b;\n+    bool no_broadcast;\n   }\n   vex;\n-  unsigned char need_vex;\n \n   /* Remember if the current op is a jump instruction.  */\n   bool op_is_jump;\n \n+  bool two_source_ops;\n+\n+  unsigned char op_ad;\n+  signed char op_index[MAX_OPERANDS];\n   char op_out[MAX_OPERANDS][100];\n-  int op_ad, op_index[MAX_OPERANDS];\n-  int two_source_ops;\n   bfd_vma op_address[MAX_OPERANDS];\n   bfd_vma op_riprel[MAX_OPERANDS];\n   bfd_vma start_pc;\n@@ -237,7 +240,7 @@ struct instr_info\n    * The function returns the length of this instruction in bytes.\n    */\n   char intel_syntax;\n-  char intel_mnemonic;\n+  bool intel_mnemonic;\n   char open_char;\n   char close_char;\n   char separator_char;\n@@ -2348,7 +2351,7 @@ static const struct dis386 dis386_twobyte[] = {\n   { \"ud0S\",\t\t{ Gv, Ev }, 0 },\n };\n \n-static const unsigned char onebyte_has_modrm[256] = {\n+static const bool onebyte_has_modrm[256] = {\n   /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */\n   /*       -------------------------------        */\n   /* 00 */ 1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0, /* 00 */\n@@ -2371,7 +2374,7 @@ static const unsigned char onebyte_has_modrm[256] = {\n   /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */\n };\n \n-static const unsigned char twobyte_has_modrm[256] = {\n+static const bool twobyte_has_modrm[256] = {\n   /*       0 1 2 3 4 5 6 7 8 9 a b c d e f        */\n   /*       -------------------------------        */\n   /* 00 */ 1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1, /* 0f */\n@@ -9029,7 +9032,7 @@ get_valid_dis386 (const struct dis386 *dp, instr_info *ins)\n \t  ins->vex.prefix = REPNE_PREFIX_OPCODE;\n \t  break;\n \t}\n-      ins->need_vex = 1;\n+      ins->need_vex = true;\n       ins->codep++;\n       vindex = *ins->codep++;\n       dp = &xop_table[vex_table_index][vindex];\n@@ -9095,7 +9098,7 @@ get_valid_dis386 (const struct dis386 *dp, instr_info *ins)\n \t  ins->vex.prefix = REPNE_PREFIX_OPCODE;\n \t  break;\n \t}\n-      ins->need_vex = 1;\n+      ins->need_vex = true;\n       ins->codep++;\n       vindex = *ins->codep++;\n       dp = &vex_table[vex_table_index][vindex];\n@@ -9133,7 +9136,7 @@ get_valid_dis386 (const struct dis386 *dp, instr_info *ins)\n \t  ins->vex.prefix = REPNE_PREFIX_OPCODE;\n \t  break;\n \t}\n-      ins->need_vex = 1;\n+      ins->need_vex = true;\n       ins->codep++;\n       vindex = *ins->codep++;\n       dp = &vex_table[dp->op[1].bytemode][vindex];\n@@ -9152,13 +9155,13 @@ get_valid_dis386 (const struct dis386 *dp, instr_info *ins)\n       if (!ins->need_vex)\n \tabort ();\n \n-      dp = &vex_w_table[dp->op[1].bytemode][ins->vex.w ? 1 : 0];\n+      dp = &vex_w_table[dp->op[1].bytemode][ins->vex.w];\n       break;\n \n     case USE_EVEX_TABLE:\n-      ins->two_source_ops = 0;\n+      ins->two_source_ops = false;\n       /* EVEX prefix.  */\n-      ins->vex.evex = 1;\n+      ins->vex.evex = true;\n       FETCH_DATA (ins->info, ins->codep + 4);\n       /* The first byte after 0x62.  */\n       ins->rex = ~(*ins->codep >> 5) & 0x7;\n@@ -9216,7 +9219,7 @@ get_valid_dis386 (const struct dis386 *dp, instr_info *ins)\n \n       /* Remember the static rounding bits.  */\n       ins->vex.ll = (*ins->codep >> 5) & 3;\n-      ins->vex.b = (*ins->codep & 0x10) != 0;\n+      ins->vex.b = *ins->codep & 0x10;\n \n       ins->vex.v = *ins->codep & 0x8;\n       ins->vex.mask_register_specifier = *ins->codep & 0x7;\n@@ -9226,10 +9229,10 @@ get_valid_dis386 (const struct dis386 *dp, instr_info *ins)\n \t{\n \t  /* In 16/32-bit mode silently ignore following bits.  */\n \t  ins->rex &= ~REX_B;\n-\t  ins->vex.r = 1;\n+\t  ins->vex.r = true;\n \t}\n \n-      ins->need_vex = 1;\n+      ins->need_vex = true;\n       ins->codep++;\n       vindex = *ins->codep++;\n       dp = &evex_table[vex_table_index][vindex];\n@@ -9353,13 +9356,13 @@ print_insn (bfd_vma pc, instr_info *ins)\n \t{\n \t  ins->intel_syntax = 1;\n \t  if (startswith (p + 5, \"-mnemonic\"))\n-\t    ins->intel_mnemonic = 1;\n+\t    ins->intel_mnemonic = true;\n \t}\n       else if (startswith (p, \"att\"))\n \t{\n \t  ins->intel_syntax = 0;\n \t  if (startswith (p + 3, \"-mnemonic\"))\n-\t    ins->intel_mnemonic = 0;\n+\t    ins->intel_mnemonic = false;\n \t}\n       else if (startswith (p, \"addr\"))\n \t{\n@@ -9535,7 +9538,7 @@ print_insn (bfd_vma pc, instr_info *ins)\n   else\n     memset (&ins->modrm, 0, sizeof (ins->modrm));\n \n-  ins->need_vex = 0;\n+  ins->need_vex = false;\n   memset (&ins->vex, 0, sizeof (ins->vex));\n \n   if (dp->name == NULL && dp->op[0].bytemode == FLOATCODE)\n@@ -10402,7 +10405,7 @@ putop (instr_info *ins, const char *in_template, int sizeflag)\n \t    }\n \t  else if (l == 1 && last[0] == 'X')\n \t    {\n-\t      if (ins->vex.w == 0)\n+\t      if (!ins->vex.w)\n \t\t*ins->obufp++ = 'h';\n \t      else\n \t\toappend (ins, \"{bad}\");\n@@ -10922,7 +10925,7 @@ intel_operand_size (instr_info *ins, int bytemode, int sizeflag)\n \t    oappend (ins, \"WORD PTR \");\n \t    break;\n \t  default:\n-\t    ins->vex.no_broadcast = 1;\n+\t    ins->vex.no_broadcast = true;\n \t    break;\n \t  }\n       return;\n@@ -11750,7 +11753,7 @@ OP_E_memory (instr_info *ins, int bytemode, int sizeflag)\n \n       /* Broadcast can only ever be valid for memory sources.  */\n       if (ins->obufp == ins->op_out[0])\n-\tins->vex.no_broadcast = 1;\n+\tins->vex.no_broadcast = true;\n \n       if (!ins->vex.no_broadcast)\n \t{\n@@ -11778,7 +11781,7 @@ OP_E_memory (instr_info *ins, int bytemode, int sizeflag)\n \t    }\n \t  else if (bytemode == q_mode\n \t\t   || bytemode == ymmq_mode)\n-\t    ins->vex.no_broadcast = 1;\n+\t    ins->vex.no_broadcast = true;\n \t  else if (ins->vex.w\n \t\t   || bytemode == evex_half_bcst_xmmqdh_mode\n \t\t   || bytemode == evex_half_bcst_xmmq_mode)\n@@ -11817,7 +11820,7 @@ OP_E_memory (instr_info *ins, int bytemode, int sizeflag)\n \t\t}\n \t    }\n \t  else\n-\t    ins->vex.no_broadcast = 1;\n+\t    ins->vex.no_broadcast = true;\n \t}\n       if (ins->vex.no_broadcast)\n \toappend (ins, \"{bad}\");\n@@ -12547,7 +12550,7 @@ OP_XMM (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n   if (bytemode == tmm_mode)\n     ins->modrm.reg = reg;\n   else if (bytemode == scalar_mode)\n-    ins->vex.no_broadcast = 1;\n+    ins->vex.no_broadcast = true;\n \n   print_vector_reg (ins, reg, bytemode);\n }\n@@ -12912,7 +12915,7 @@ OP_Mwait (instr_info *ins, int bytemode, int sizeflag ATTRIBUTE_UNUSED)\n       strcpy (ins->op_out[1], att_names32[1] + ins->intel_syntax);\n       if (bytemode == eBX_reg)\n \tstrcpy (ins->op_out[2], att_names32[3] + ins->intel_syntax);\n-      ins->two_source_ops = 1;\n+      ins->two_source_ops = true;\n     }\n   /* Skip mod/rm byte.  */\n   MODRM_CHECK;\n@@ -12942,7 +12945,7 @@ OP_Monitor (instr_info *ins, int bytemode ATTRIBUTE_UNUSED,\n       strcpy (ins->op_out[0], names[0] + ins->intel_syntax);\n       strcpy (ins->op_out[1], att_names32[1] + ins->intel_syntax);\n       strcpy (ins->op_out[2], att_names32[2] + ins->intel_syntax);\n-      ins->two_source_ops = 1;\n+      ins->two_source_ops = true;\n     }\n   /* Skip mod/rm byte.  */\n   MODRM_CHECK;"
    }
  ]
}