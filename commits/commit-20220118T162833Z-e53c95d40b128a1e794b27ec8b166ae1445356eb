{
  "sha": "e53c95d40b128a1e794b27ec8b166ae1445356eb",
  "node_id": "C_kwDOANOeidoAKGU1M2M5NWQ0MGIxMjhhMWU3OTRiMjdlYzhiMTY2YWUxNDQ1MzU2ZWI",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2022-01-16T04:45:06Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2022-01-18T16:28:33Z"
    },
    "message": "gdb: use ptid_t::to_string instead of target_pid_to_str in debug statements\n\nSame idea as 0fab79556484 (\"gdb: use ptid_t::to_string in infrun debug\nmessages\"), but throughout GDB.\n\nChange-Id: I62ba36eaef29935316d7187b9b13d7b88491acc1",
    "tree": {
      "sha": "27ee9e14035d4bc48982bd172ce8cce80436375a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/27ee9e14035d4bc48982bd172ce8cce80436375a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e53c95d40b128a1e794b27ec8b166ae1445356eb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e53c95d40b128a1e794b27ec8b166ae1445356eb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e53c95d40b128a1e794b27ec8b166ae1445356eb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e53c95d40b128a1e794b27ec8b166ae1445356eb/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cced7cacecad104fff03e94814a3fca1d304b16f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cced7cacecad104fff03e94814a3fca1d304b16f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cced7cacecad104fff03e94814a3fca1d304b16f"
    }
  ],
  "stats": {
    "total": 142,
    "additions": 71,
    "deletions": 71
  },
  "files": [
    {
      "sha": "dc4d686ac4bc8c01a5803f2a663a59fb5fb02c0d",
      "filename": "gdb/btrace.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/btrace.c?ref=e53c95d40b128a1e794b27ec8b166ae1445356eb",
      "patch": "@@ -1616,7 +1616,7 @@ btrace_enable (struct thread_info *tp, const struct btrace_config *conf)\n #endif /* !defined (HAVE_LIBIPT) */\n \n   DEBUG (\"enable thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str ());\n+\t tp->ptid.to_string ().c_str ());\n \n   tp->btrace.target = target_enable_btrace (tp->ptid, conf);\n \n@@ -1671,7 +1671,7 @@ btrace_disable (struct thread_info *tp)\n \t   print_thread_id (tp), target_pid_to_str (tp->ptid).c_str ());\n \n   DEBUG (\"disable thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str ());\n+\t tp->ptid.to_string ().c_str ());\n \n   target_disable_btrace (btp->target);\n   btp->target = NULL;\n@@ -1690,7 +1690,7 @@ btrace_teardown (struct thread_info *tp)\n     return;\n \n   DEBUG (\"teardown thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str ());\n+\t tp->ptid.to_string ().c_str ());\n \n   target_teardown_btrace (btp->target);\n   btp->target = NULL;\n@@ -1912,7 +1912,7 @@ btrace_fetch (struct thread_info *tp, const struct btrace_cpu *cpu)\n   int errcode;\n \n   DEBUG (\"fetch thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str ());\n+\t tp->ptid.to_string ().c_str ());\n \n   btinfo = &tp->btrace;\n   tinfo = btinfo->target;\n@@ -1989,7 +1989,7 @@ btrace_clear (struct thread_info *tp)\n   struct btrace_thread_info *btinfo;\n \n   DEBUG (\"clear thread %s (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str ());\n+\t tp->ptid.to_string ().c_str ());\n \n   /* Make sure btrace frames that may hold a pointer into the branch\n      trace data are destroyed.  */"
    },
    {
      "sha": "e2afbe42f582f43a950571dc1ecb34688e472416",
      "filename": "gdb/displaced-stepping.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/displaced-stepping.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/displaced-stepping.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/displaced-stepping.c?ref=e53c95d40b128a1e794b27ec8b166ae1445356eb",
      "patch": "@@ -232,7 +232,7 @@ displaced_step_buffers::finish (gdbarch *arch, thread_info *thread,\n \t\t     buffer->saved_copy.data (), len);\n \n   displaced_debug_printf (\"restored %s %s\",\n-\t\t\t  target_pid_to_str (thread->ptid).c_str (),\n+\t\t\t  thread->ptid.to_string ().c_str (),\n \t\t\t  paddress (arch, buffer->addr));\n \n   regcache *rc = get_thread_regcache (thread);\n@@ -285,7 +285,7 @@ displaced_step_buffers::restore_in_ptid (ptid_t ptid)\n       write_memory_ptid (ptid, buffer.addr, buffer.saved_copy.data (), len);\n \n       displaced_debug_printf (\"restored in ptid %s %s\",\n-\t\t\t      target_pid_to_str (ptid).c_str (),\n+\t\t\t      ptid.to_string ().c_str (),\n \t\t\t      paddress (arch, buffer.addr));\n     }\n }"
    },
    {
      "sha": "db7aaacdc5aec40e8b66bc99d0d2bc4397f97896",
      "filename": "gdb/dummy-frame.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/dummy-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/dummy-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dummy-frame.c?ref=e53c95d40b128a1e794b27ec8b166ae1445356eb",
      "patch": "@@ -408,7 +408,7 @@ fprint_dummy_frames (struct ui_file *file)\n     fprintf_filtered (file, \"%s: id=%s, ptid=%s\\n\",\n \t\t      host_address_to_string (s),\n \t\t      s->id.id.to_string ().c_str (),\n-\t\t      target_pid_to_str (s->id.thread->ptid).c_str ());\n+\t\t      s->id.thread->ptid.to_string ().c_str ());\n }\n \n static void"
    },
    {
      "sha": "1586a738dee240c7ad365e7c8c7862b9b23570b0",
      "filename": "gdb/gnu-nat.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/gnu-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/gnu-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.c?ref=e53c95d40b128a1e794b27ec8b166ae1445356eb",
      "patch": "@@ -1463,7 +1463,7 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n   waiting_inf = inf;\n \n-  inf_debug (inf, \"waiting for: %s\", target_pid_to_str (ptid).c_str ());\n+  inf_debug (inf, \"waiting for: %s\", ptid.to_string ().c_str ());\n \n rewait:\n   if (proc_wait_pid != inf->pid && !inf->no_wait)\n@@ -1621,7 +1621,7 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     }\n \n   inf_debug (inf, \"returning ptid = %s, %s\",\n-\t     target_pid_to_str (ptid).c_str (),\n+\t     ptid.to_string ().c_str (),\n \t     status->to_string ().c_str ());\n \n   return ptid;\n@@ -1973,7 +1973,7 @@ gnu_nat_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n   struct inf *inf = gnu_current_inf;\n \n   inf_debug (inf, \"ptid = %s, step = %d, sig = %d\",\n-\t     target_pid_to_str (ptid).c_str (), step, sig);\n+\t     ptid.to_string ().c_str (), step, sig);\n \n   inf_validate_procinfo (inf);\n \n@@ -2021,7 +2021,7 @@ gnu_nat_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n \terror (_(\"Can't run single thread id %s: no such thread!\"),\n \t       target_pid_to_str (ptid).c_str ());\n       inf_debug (inf, \"running one thread: %s\",\n-\t\t target_pid_to_str (ptid).c_str ());\n+\t\t ptid.to_string ().c_str ());\n       inf_set_threads_resume_sc (inf, thread, 0);\n     }\n \n@@ -2033,7 +2033,7 @@ gnu_nat_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n \t\t target_pid_to_str (ptid).c_str ());\n       else\n \tinf_debug (inf, \"stepping thread: %s\",\n-\t\t   target_pid_to_str (ptid).c_str ());\n+\t\t   ptid.to_string ().c_str ());\n     }\n   if (step_thread != inf->step_thread)\n     inf_set_step_thread (inf, step_thread);"
    },
    {
      "sha": "0cc6923ad0233901503e2ef25138a9dfac9ca0b8",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 46,
      "deletions": 46,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=e53c95d40b128a1e794b27ec8b166ae1445356eb",
      "patch": "@@ -1123,7 +1123,7 @@ attach_proc_task_lwp_callback (ptid_t ptid)\n       else\n \t{\n \t  linux_nat_debug_printf (\"PTRACE_ATTACH %s, 0, 0 (OK)\",\n-\t\t\t\t  target_pid_to_str (ptid).c_str ());\n+\t\t\t\t  ptid.to_string ().c_str ());\n \n \t  lp = add_lwp (ptid);\n \n@@ -1356,18 +1356,18 @@ get_detach_signal (struct lwp_info *lp)\n   if (signo == GDB_SIGNAL_0)\n     {\n       linux_nat_debug_printf (\"lwp %s has no pending signal\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n     }\n   else if (!signal_pass_state (signo))\n     {\n       linux_nat_debug_printf\n \t(\"lwp %s had signal %s but it is in no pass state\",\n-\t target_pid_to_str (lp->ptid).c_str (), gdb_signal_to_string (signo));\n+\t lp->ptid.to_string ().c_str (), gdb_signal_to_string (signo));\n     }\n   else\n     {\n       linux_nat_debug_printf (\"lwp %s has pending signal %s\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t      lp->ptid.to_string ().c_str (),\n \t\t\t      gdb_signal_to_string (signo));\n \n       return gdb_signal_to_host (signo);\n@@ -1433,13 +1433,13 @@ detach_one_lwp (struct lwp_info *lp, int *signo_p)\n   if (lp->status != 0)\n     linux_nat_debug_printf (\"Pending %s for %s on detach.\",\n \t\t\t    strsignal (WSTOPSIG (lp->status)),\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t    lp->ptid.to_string ().c_str ());\n \n   /* If there is a pending SIGSTOP, get rid of it.  */\n   if (lp->signalled)\n     {\n       linux_nat_debug_printf (\"Sending SIGCONT to %s\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n \n       kill_lwp (lwpid, SIGCONT);\n       lp->signalled = 0;\n@@ -1630,12 +1630,12 @@ resume_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)\n       if (inf->vfork_child != NULL)\n \t{\n \t  linux_nat_debug_printf (\"Not resuming %s (vfork parent)\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \t}\n       else if (!lwp_status_pending_p (lp))\n \t{\n \t  linux_nat_debug_printf (\"Resuming sibling %s, %s, %s\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t\t  lp->ptid.to_string ().c_str (),\n \t\t\t\t  (signo != GDB_SIGNAL_0\n \t\t\t\t   ? strsignal (gdb_signal_to_host (signo))\n \t\t\t\t   : \"0\"),\n@@ -1646,12 +1646,12 @@ resume_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)\n       else\n \t{\n \t  linux_nat_debug_printf (\"Not resuming sibling %s (has pending)\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \t}\n     }\n   else\n     linux_nat_debug_printf (\"Not resuming sibling %s (not stopped)\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t    lp->ptid.to_string ().c_str ());\n }\n \n /* Callback for iterate_over_lwps.  If LWP is EXCEPT, do nothing.\n@@ -1705,10 +1705,10 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n \n   linux_nat_debug_printf (\"Preparing to %s %s, %s, inferior_ptid %s\",\n \t\t\t  step ? \"step\" : \"resume\",\n-\t\t\t  target_pid_to_str (ptid).c_str (),\n+\t\t\t  ptid.to_string ().c_str (),\n \t\t\t  (signo != GDB_SIGNAL_0\n \t\t\t   ? strsignal (gdb_signal_to_host (signo)) : \"0\"),\n-\t\t\t  target_pid_to_str (inferior_ptid).c_str ());\n+\t\t\t  inferior_ptid.to_string ().c_str ());\n \n   /* A specific PTID means `step only this process id'.  */\n   resume_many = (minus_one_ptid == ptid\n@@ -1780,7 +1780,7 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n \n   linux_nat_debug_printf (\"%s %s, %s (resume event thread)\",\n \t\t\t  step ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t  lp->ptid.to_string ().c_str (),\n \t\t\t  (signo != GDB_SIGNAL_0\n \t\t\t   ? strsignal (gdb_signal_to_host (signo)) : \"0\"));\n \n@@ -2167,7 +2167,7 @@ wait_lwp (struct lwp_info *lp)\n \t     the top of the file.  */\n \t  thread_dead = 1;\n \t  linux_nat_debug_printf (\"%s vanished.\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \t}\n       if (pid != 0)\n \tbreak;\n@@ -2191,7 +2191,7 @@ wait_lwp (struct lwp_info *lp)\n \t{\n \t  thread_dead = 1;\n \t  linux_nat_debug_printf (\"Thread group leader %s vanished.\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \t  break;\n \t}\n \n@@ -2211,7 +2211,7 @@ wait_lwp (struct lwp_info *lp)\n       gdb_assert (pid == lp->ptid.lwp ());\n \n       linux_nat_debug_printf (\"waitpid %s received %s\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t      lp->ptid.to_string ().c_str (),\n \t\t\t      status_to_str (status).c_str ());\n \n       /* Check if the thread has exited.  */\n@@ -2232,7 +2232,7 @@ wait_lwp (struct lwp_info *lp)\n \n \t  thread_dead = 1;\n \t  linux_nat_debug_printf (\"%s exited.\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \t}\n     }\n \n@@ -2294,7 +2294,7 @@ stop_callback (struct lwp_info *lp)\n       int ret;\n \n       linux_nat_debug_printf (\"kill %s **<SIGSTOP>**\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n \n       errno = 0;\n       ret = kill_lwp (lp->ptid.lwp (), SIGSTOP);\n@@ -2388,7 +2388,7 @@ maybe_clear_ignore_sigint (struct lwp_info *lp)\n   if (!linux_nat_has_pending_sigint (lp->ptid.lwp ()))\n     {\n       linux_nat_debug_printf (\"Clearing bogus flag for %s\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n       lp->ignore_sigint = 0;\n     }\n }\n@@ -2486,7 +2486,7 @@ stop_wait_callback (struct lwp_info *lp)\n \t  lp->stopped = 0;\n \t  linux_nat_debug_printf\n \t    (\"PTRACE_CONT %s, 0, 0 (%s) (discarding SIGINT)\",\n-\t     target_pid_to_str (lp->ptid).c_str (),\n+\t     lp->ptid.to_string ().c_str (),\n \t     errno ? safe_strerror (errno) : \"OK\");\n \n \t  return stop_wait_callback (lp);\n@@ -2500,7 +2500,7 @@ stop_wait_callback (struct lwp_info *lp)\n \n \t  linux_nat_debug_printf (\"Pending event %s in %s\",\n \t\t\t\t  status_to_str ((int) status).c_str (),\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \n \t  /* Save the sigtrap event.  */\n \t  lp->status = status;\n@@ -2512,7 +2512,7 @@ stop_wait_callback (struct lwp_info *lp)\n \t  /* We caught the SIGSTOP that we intended to catch.  */\n \n \t  linux_nat_debug_printf (\"Expected SIGSTOP caught for %s.\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \n \t  lp->signalled = 0;\n \n@@ -2557,7 +2557,7 @@ status_callback (struct lwp_info *lp)\n       if (pc != lp->stop_pc)\n \t{\n \t  linux_nat_debug_printf (\"PC of %s changed.  was=%s, now=%s\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t\t  lp->ptid.to_string ().c_str (),\n \t\t\t\t  paddress (target_gdbarch (), lp->stop_pc),\n \t\t\t\t  paddress (target_gdbarch (), pc));\n \t  discard = 1;\n@@ -2567,7 +2567,7 @@ status_callback (struct lwp_info *lp)\n       else if (!breakpoint_inserted_here_p (regcache->aspace (), pc))\n \t{\n \t  linux_nat_debug_printf (\"previous breakpoint of %s, at %s gone\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str (),\n+\t\t\t\t  lp->ptid.to_string ().c_str (),\n \t\t\t\t  paddress (target_gdbarch (), lp->stop_pc));\n \n \t  discard = 1;\n@@ -2577,7 +2577,7 @@ status_callback (struct lwp_info *lp)\n       if (discard)\n \t{\n \t  linux_nat_debug_printf (\"pending event of %s cancelled.\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \n \t  lp->status = 0;\n \t  linux_resume_one_lwp (lp, lp->step, GDB_SIGNAL_0);\n@@ -2701,7 +2701,7 @@ save_stop_reason (struct lwp_info *lp)\n \t  else if (siginfo.si_code == TRAP_TRACE)\n \t    {\n \t      linux_nat_debug_printf (\"%s stopped by trace\",\n-\t\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t      lp->ptid.to_string ().c_str ());\n \n \t      /* We may have single stepped an instruction that\n \t\t triggered a watchpoint.  In that case, on some\n@@ -2732,7 +2732,7 @@ save_stop_reason (struct lwp_info *lp)\n   if (lp->stop_reason == TARGET_STOPPED_BY_SW_BREAKPOINT)\n     {\n       linux_nat_debug_printf (\"%s stopped by software breakpoint\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n \n       /* Back up the PC if necessary.  */\n       if (pc != sw_bp_pc)\n@@ -2744,12 +2744,12 @@ save_stop_reason (struct lwp_info *lp)\n   else if (lp->stop_reason == TARGET_STOPPED_BY_HW_BREAKPOINT)\n     {\n       linux_nat_debug_printf (\"%s stopped by hardware breakpoint\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n     }\n   else if (lp->stop_reason == TARGET_STOPPED_BY_WATCHPOINT)\n     {\n       linux_nat_debug_printf (\"%s stopped by hardware watchpoint\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n     }\n \n   lp->stop_pc = pc;\n@@ -2824,7 +2824,7 @@ select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)\n       if (event_lp != NULL)\n \t{\n \t  linux_nat_debug_printf (\"Select single-step %s\",\n-\t\t\t\t  target_pid_to_str (event_lp->ptid).c_str ());\n+\t\t\t\t  event_lp->ptid.to_string ().c_str ());\n \t}\n     }\n \n@@ -2978,7 +2978,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t  && num_lwps (lp->ptid.pid ()) > 1)\n \t{\n \t  linux_nat_debug_printf (\"%s exited.\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \n \t  /* If there is at least one more LWP, then the exit signal\n \t     was not the end of the debugged application and should be\n@@ -3013,7 +3013,7 @@ linux_nat_filter_event (int lwpid, int status)\n       if (lp->last_resume_kind == resume_stop)\n \t{\n \t  linux_nat_debug_printf (\"resume_stop SIGSTOP caught for %s.\",\n-\t\t\t\t  target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t\t  lp->ptid.to_string ().c_str ());\n \t}\n       else\n \t{\n@@ -3022,7 +3022,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t  linux_nat_debug_printf\n \t    (\"%s %s, 0, 0 (discard delayed SIGSTOP)\",\n \t     lp->step ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t     target_pid_to_str (lp->ptid).c_str ());\n+\t     lp->ptid.to_string ().c_str ());\n \n \t  linux_resume_one_lwp (lp, lp->step, GDB_SIGNAL_0);\n \t  gdb_assert (lp->resumed);\n@@ -3036,15 +3036,15 @@ linux_nat_filter_event (int lwpid, int status)\n       && WIFSTOPPED (status) && WSTOPSIG (status) == SIGINT)\n     {\n       linux_nat_debug_printf (\"Delayed SIGINT caught for %s.\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n \n       /* This is a delayed SIGINT.  */\n       lp->ignore_sigint = 0;\n \n       linux_resume_one_lwp (lp, lp->step, GDB_SIGNAL_0);\n       linux_nat_debug_printf (\"%s %s, 0, 0 (discard SIGINT)\",\n \t\t\t      lp->step ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n       gdb_assert (lp->resumed);\n \n       /* Discard the event.  */\n@@ -3094,7 +3094,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t  linux_nat_debug_printf\n \t    (\"%s %s, %s (preempt 'handle')\",\n \t     lp->step ? \"PTRACE_SINGLESTEP\" : \"PTRACE_CONT\",\n-\t     target_pid_to_str (lp->ptid).c_str (),\n+\t     lp->ptid.to_string ().c_str (),\n \t     (signo != GDB_SIGNAL_0\n \t      ? strsignal (gdb_signal_to_host (signo)) : \"0\"));\n \t  return;\n@@ -3212,7 +3212,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n     {\n       linux_nat_debug_printf (\"Using pending wait status %s for %s.\",\n \t\t\t      status_to_str (lp->status).c_str (),\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n     }\n \n   /* But if we don't find a pending event, we'll have to wait.  Always\n@@ -3364,7 +3364,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   if (linux_target->low_status_is_event (status))\n     {\n       linux_nat_debug_printf (\"trap ptid is %s.\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n     }\n \n   if (lp->waitstatus.kind () != TARGET_WAITKIND_IGNORE)\n@@ -3410,17 +3410,17 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n   if (!lp->stopped)\n     {\n       linux_nat_debug_printf (\"NOT resuming LWP %s, not stopped\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n     }\n   else if (!lp->resumed)\n     {\n       linux_nat_debug_printf (\"NOT resuming LWP %s, not resumed\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n     }\n   else if (lwp_status_pending_p (lp))\n     {\n       linux_nat_debug_printf (\"NOT resuming LWP %s, has pending status\",\n-\t\t\t      target_pid_to_str (lp->ptid).c_str ());\n+\t\t\t      lp->ptid.to_string ().c_str ());\n     }\n   else\n     {\n@@ -3444,7 +3444,7 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n \t    {\n \t      linux_nat_debug_printf\n \t\t(\"resuming stopped-resumed LWP %s at %s: step=%d\",\n-\t\t target_pid_to_str (lp->ptid).c_str (), paddress (gdbarch, pc),\n+\t\t lp->ptid.to_string ().c_str (), paddress (gdbarch, pc),\n \t\t lp->step);\n \n \t      linux_resume_one_lwp_throw (lp, lp->step, GDB_SIGNAL_0);\n@@ -3466,7 +3466,7 @@ linux_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n {\n   ptid_t event_ptid;\n \n-  linux_nat_debug_printf (\"[%s], [%s]\", target_pid_to_str (ptid).c_str (),\n+  linux_nat_debug_printf (\"[%s], [%s]\", ptid.to_string ().c_str (),\n \t\t\t  target_options_to_string (target_options).c_str ());\n \n   /* Flush the async file first.  */\n@@ -4295,7 +4295,7 @@ linux_nat_stop_lwp (struct lwp_info *lwp)\n   if (!lwp->stopped)\n     {\n       linux_nat_debug_printf (\"running -> suspending %s\",\n-\t\t\t      target_pid_to_str (lwp->ptid).c_str ());\n+\t\t\t      lwp->ptid.to_string ().c_str ());\n \n \n       if (lwp->last_resume_kind == resume_stop)\n@@ -4316,10 +4316,10 @@ linux_nat_stop_lwp (struct lwp_info *lwp)\n \t{\n \t  if (find_thread_ptid (linux_target, lwp->ptid)->stop_requested)\n \t    linux_nat_debug_printf (\"already stopped/stop_requested %s\",\n-\t\t\t\t    target_pid_to_str (lwp->ptid).c_str ());\n+\t\t\t\t    lwp->ptid.to_string ().c_str ());\n \t  else\n \t    linux_nat_debug_printf (\"already stopped/no stop_requested yet %s\",\n-\t\t\t\t    target_pid_to_str (lwp->ptid).c_str ());\n+\t\t\t\t    lwp->ptid.to_string ().c_str ());\n \t}\n     }\n   return 0;"
    },
    {
      "sha": "c594372e66262ab00c0f4d95a19a9c14675cd633",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=e53c95d40b128a1e794b27ec8b166ae1445356eb",
      "patch": "@@ -1962,7 +1962,7 @@ record_btrace_resume_thread (struct thread_info *tp,\n   struct btrace_thread_info *btinfo;\n \n   DEBUG (\"resuming thread %s (%s): %x (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str (), flag,\n+\t tp->ptid.to_string ().c_str (), flag,\n \t btrace_thread_flag_to_str (flag));\n \n   btinfo = &tp->btrace;\n@@ -2125,7 +2125,7 @@ record_btrace_target::resume (ptid_t ptid, int step, enum gdb_signal signal)\n {\n   enum btrace_thread_flag flag, cflag;\n \n-  DEBUG (\"resume %s: %s%s\", target_pid_to_str (ptid).c_str (),\n+  DEBUG (\"resume %s: %s%s\", ptid.to_string ().c_str (),\n \t ::execution_direction == EXEC_REVERSE ? \"reverse-\" : \"\",\n \t step ? \"step\" : \"cont\");\n \n@@ -2205,7 +2205,7 @@ record_btrace_cancel_resume (struct thread_info *tp)\n \n   DEBUG (\"cancel resume thread %s (%s): %x (%s)\",\n \t print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str (), flags.raw (),\n+\t tp->ptid.to_string ().c_str (), flags.raw (),\n \t btrace_thread_flag_to_str (flags));\n \n   tp->btrace.flags &= ~(BTHR_MOVE | BTHR_STOP);\n@@ -2431,7 +2431,7 @@ record_btrace_step_thread (struct thread_info *tp)\n   btinfo->flags &= ~(BTHR_MOVE | BTHR_STOP);\n \n   DEBUG (\"stepping thread %s (%s): %x (%s)\", print_thread_id (tp),\n-\t target_pid_to_str (tp->ptid).c_str (), flags.raw (),\n+\t tp->ptid.to_string ().c_str (), flags.raw (),\n \t btrace_thread_flag_to_str (flags));\n \n   /* We can't step without an execution history.  */\n@@ -2519,7 +2519,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n   /* Clear this, if needed we'll re-mark it below.  */\n   clear_async_event_handler (record_btrace_async_inferior_event_handler);\n \n-  DEBUG (\"wait %s (0x%x)\", target_pid_to_str (ptid).c_str (),\n+  DEBUG (\"wait %s (0x%x)\", ptid.to_string ().c_str (),\n \t (unsigned) options);\n \n   /* As long as we're not replaying, just forward the request.  */\n@@ -2539,7 +2539,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     {\n       *status = btrace_step_no_resumed ();\n \n-      DEBUG (\"wait ended by %s: %s\", target_pid_to_str (null_ptid).c_str (),\n+      DEBUG (\"wait ended by %s: %s\", null_ptid.to_string ().c_str (),\n \t     status->to_string ().c_str ());\n \n       return null_ptid;\n@@ -2630,7 +2630,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n   DEBUG (\"wait ended by thread %s (%s): %s\",\n \t print_thread_id (eventing),\n-\t target_pid_to_str (eventing->ptid).c_str (),\n+\t eventing->ptid.to_string ().c_str (),\n \t status->to_string ().c_str ());\n \n   return eventing->ptid;\n@@ -2641,7 +2641,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n void\n record_btrace_target::stop (ptid_t ptid)\n {\n-  DEBUG (\"stop %s\", target_pid_to_str (ptid).c_str ());\n+  DEBUG (\"stop %s\", ptid.to_string ().c_str ());\n \n   /* As long as we're not replaying, just forward the request.  */\n   if ((::execution_direction != EXEC_REVERSE)"
    },
    {
      "sha": "b093ad866750dbe9c884afa3b07b1800c3129764",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=e53c95d40b128a1e794b27ec8b166ae1445356eb",
      "patch": "@@ -7436,7 +7436,7 @@ remote_target::remote_notif_remove_queued_reply (ptid_t ptid)\n   if (notif_debug)\n     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\"notif: discard queued event: 'Stop' in %s\\n\",\n-\t\t\ttarget_pid_to_str (ptid).c_str ());\n+\t\t\tptid.to_string ().c_str ());\n \n   return result;\n }\n@@ -7474,7 +7474,7 @@ remote_target::push_stop_reply (struct stop_reply *new_event)\n   if (notif_debug)\n     fprintf_unfiltered (gdb_stdlog,\n \t\t\t\"notif: push 'Stop' %s to queue %d\\n\",\n-\t\t\ttarget_pid_to_str (new_event->ptid).c_str (),\n+\t\t\tnew_event->ptid.to_string ().c_str (),\n \t\t\tint (rs->stop_reply_queue.size ()));\n \n   /* Mark the pending event queue only if async mode is currently enabled."
    },
    {
      "sha": "0f9fbe325bc77137cbd649924278b8e0e1cbe8fb",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e53c95d40b128a1e794b27ec8b166ae1445356eb/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=e53c95d40b128a1e794b27ec8b166ae1445356eb",
      "patch": "@@ -424,7 +424,7 @@ void\n global_thread_step_over_chain_enqueue (struct thread_info *tp)\n {\n   infrun_debug_printf (\"enqueueing thread %s in global step over chain\",\n-\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t       tp->ptid.to_string ().c_str ());\n \n   gdb_assert (!thread_is_in_step_over_chain (tp));\n   global_thread_step_over_list.push_back (*tp);\n@@ -444,7 +444,7 @@ void\n global_thread_step_over_chain_remove (struct thread_info *tp)\n {\n   infrun_debug_printf (\"removing thread %s from global step over chain\",\n-\t\t       target_pid_to_str (tp->ptid).c_str ());\n+\t\t       tp->ptid.to_string ().c_str ());\n \n   gdb_assert (thread_is_in_step_over_chain (tp));\n   auto it = global_thread_step_over_list.iterator_to (*tp);"
    }
  ]
}