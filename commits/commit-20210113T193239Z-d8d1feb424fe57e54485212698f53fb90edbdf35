{
  "sha": "d8d1feb424fe57e54485212698f53fb90edbdf35",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDhkMWZlYjQyNGZlNTdlNTQ0ODUyMTI2OThmNTNmYjkwZWRiZGYzNQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-13T19:32:39Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-13T19:32:39Z"
    },
    "message": "gdb: convert arc to new-style debug macros\n\nAdd the standard arc_debug_printf, but also arc_linux_debug_printf,\narc_linux_nat_debug_printf and arc_newlib_debug_printf to match the\nprefixes currently used in the debug messages.\n\ngdb/ChangeLog:\n\n\t* arc-tdep.h (arc_debug_printf): New.\n\t* arc-tdep.c: Use arc_debug_printf.\n\t* arc-linux-nat.c (arc_linux_nat_debug_printf): Add and use.\n\t* arc-linux-tdep.c (arc_linux_debug_printf): Add and use.\n\t* arc-newlib-tdep.c (arc_newlib_debug_printf): Add and use.\n\nChange-Id: I5d937566ed7a1925f7982e8809802c8f0560d8c6",
    "tree": {
      "sha": "8dcd8e0c4ce53efdf35f503ddd4a7ad7a958bbf0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8dcd8e0c4ce53efdf35f503ddd4a7ad7a958bbf0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d8d1feb424fe57e54485212698f53fb90edbdf35",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8d1feb424fe57e54485212698f53fb90edbdf35",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d8d1feb424fe57e54485212698f53fb90edbdf35",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d8d1feb424fe57e54485212698f53fb90edbdf35/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fb0f5031bbbe2bed505fe413e178e05807e8db19",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fb0f5031bbbe2bed505fe413e178e05807e8db19",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fb0f5031bbbe2bed505fe413e178e05807e8db19"
    }
  ],
  "stats": {
    "total": 218,
    "additions": 98,
    "deletions": 120
  },
  "files": [
    {
      "sha": "23f6356ceef3e63c587a0d282a1c6eb74576060c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d8d1feb424fe57e54485212698f53fb90edbdf35",
      "patch": "@@ -1,3 +1,11 @@\n+2021-01-13  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* arc-tdep.h (arc_debug_printf): New.\n+\t* arc-tdep.c: Use arc_debug_printf.\n+\t* arc-linux-nat.c (arc_linux_nat_debug_printf): Add and use.\n+\t* arc-linux-tdep.c (arc_linux_debug_printf): Add and use.\n+\t* arc-newlib-tdep.c (arc_newlib_debug_printf): Add and use.\n+\n 2021-01-13  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* arc-tdep.h (arc_debug): Change type to bool."
    },
    {
      "sha": "642f3a769bd6239a6480c2c3f7602f0e53a4dac0",
      "filename": "gdb/arc-linux-nat.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-linux-nat.c?ref=d8d1feb424fe57e54485212698f53fb90edbdf35",
      "patch": "@@ -46,6 +46,11 @@\n /* Defines ps_err_e, struct ps_prochandle.  */\n #include \"gdb_proc_service.h\"\n \n+/* Print an \"arc-linux-nat\" debug statement.  */\n+\n+#define arc_linux_nat_debug_printf(fmt, ...) \\\n+  debug_prefixed_printf_cond (arc_debug, \"arc-linux-nat\", fmt, ##__VA_ARGS__)\n+\n /* Linux starting with 4.12 supports NT_ARC_V2 note type, which adds R30,\n    R58 and R59 registers, which are specific to ARC HS and aren't\n    available in ARC 700.  */\n@@ -219,9 +224,7 @@ void\n fill_fpregset (const struct regcache *regcache,\n \t       gdb_fpregset_t *fpregsetp, int regnum)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc-linux-nat: fill_fpregset called.\");\n-  return;\n+  arc_linux_nat_debug_printf (\"called\");\n }\n \n /* ARC doesn't have separate FP registers.  This function is exported\n@@ -230,9 +233,7 @@ fill_fpregset (const struct regcache *regcache,\n void\n supply_fpregset (struct regcache *regcache, const gdb_fpregset_t *fpregsetp)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc-linux-nat: supply_fpregset called.\");\n-  return;\n+  arc_linux_nat_debug_printf (\"called\");\n }\n \n /* Implement the \"read_description\" method of linux_nat_target.  */\n@@ -295,8 +296,7 @@ ps_err_e\n ps_get_thread_area (struct ps_prochandle *ph, lwpid_t lwpid, int idx,\n \t\t    void **base)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc-linux-nat: ps_get_thread_area called\");\n+  arc_linux_nat_debug_printf (\"called\");\n \n   if (ptrace (PTRACE_GET_THREAD_AREA, lwpid, NULL, base) != 0)\n     return PS_ERR;"
    },
    {
      "sha": "f41cb203358ea1ec16a6e29f34f0e41dfde8f0d5",
      "filename": "gdb/arc-linux-tdep.c",
      "status": "modified",
      "additions": 18,
      "deletions": 25,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-linux-tdep.c?ref=d8d1feb424fe57e54485212698f53fb90edbdf35",
      "patch": "@@ -31,6 +31,11 @@\n #include \"arc-tdep.h\"\n #include \"arch/arc.h\"\n \n+/* Print an \"arc-linux\" debug statement.  */\n+\n+#define arc_linux_debug_printf(fmt, ...) \\\n+  debug_prefixed_printf_cond (arc_debug, \"arc-linux\", fmt, ##__VA_ARGS__)\n+\n #define REGOFF(offset) (offset * ARC_REGISTER_SIZE)\n \n /* arc_linux_sc_reg_offsets[i] is the offset of register i in the `struct\n@@ -158,11 +163,7 @@ arc_linux_is_sigtramp (struct frame_info *this_frame)\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n   CORE_ADDR pc = get_frame_pc (this_frame);\n \n-  if (arc_debug)\n-    {\n-      debug_printf (\"arc-linux: arc_linux_is_sigtramp, pc=%s\\n\",\n-\t\t    paddress(gdbarch, pc));\n-    }\n+  arc_linux_debug_printf (\"pc=%s\", paddress(gdbarch, pc));\n \n   static const gdb_byte insns_be_hs[] = {\n     0x20, 0x8a, 0x12, 0xc2,\t/* mov  r8,nr_rt_sigreturn */\n@@ -383,15 +384,12 @@ arc_linux_software_single_step (struct regcache *regcache)\n \t  regcache_cooked_read_unsigned (regcache, ARC_LP_COUNT_REGNUM,\n \t\t\t\t\t &lp_count);\n \n-\t  if (arc_debug)\n-\t    {\n-\t      debug_printf (\"arc-linux: lp_start = %s, lp_end = %s, \"\n-\t\t\t    \"lp_count = %s, next_pc = %s\\n\",\n-\t\t\t    paddress (gdbarch, lp_start),\n-\t\t\t    paddress (gdbarch, lp_end),\n-\t\t\t    pulongest (lp_count),\n-\t\t\t    paddress (gdbarch, next_pc));\n-\t    }\n+\t  arc_linux_debug_printf (\"lp_start = %s, lp_end = %s, \"\n+\t\t\t\t  \"lp_count = %s, next_pc = %s\",\n+\t\t\t\t  paddress (gdbarch, lp_start),\n+\t\t\t\t  paddress (gdbarch, lp_end),\n+\t\t\t\t  pulongest (lp_count),\n+\t\t\t\t  paddress (gdbarch, next_pc));\n \n \t  if (next_pc == lp_end && lp_count > 1)\n \t    {\n@@ -436,17 +434,13 @@ arc_linux_skip_solib_resolver (struct gdbarch *gdbarch, CORE_ADDR pc)\n       if (resolver.minsym != nullptr)\n \t{\n \t  CORE_ADDR res_addr = BMSYMBOL_VALUE_ADDRESS (resolver);\n-\t  debug_printf (\"arc-linux: skip_solib_resolver (): \"\n-\t\t\t\"pc = %s, resolver at %s\\n\",\n-\t\t\tprint_core_address (gdbarch, pc),\n-\t\t\tprint_core_address (gdbarch, res_addr));\n+\t  arc_linux_debug_printf (\"pc = %s, resolver at %s\",\n+\t\t\t\t  print_core_address (gdbarch, pc),\n+\t\t\t\t  print_core_address (gdbarch, res_addr));\n \t}\n       else\n-\t{\n-\t  debug_printf (\"arc-linux: skip_solib_resolver (): \"\n-\t\t\t\"pc = %s, no resolver found\\n\",\n-\t\t\tprint_core_address (gdbarch, pc));\n-\t}\n+\tarc_linux_debug_printf (\"pc = %s, no resolver found\",\n+\t\t\t\tprint_core_address (gdbarch, pc));\n     }\n \n   if (resolver.minsym != nullptr && BMSYMBOL_VALUE_ADDRESS (resolver) == pc)\n@@ -625,8 +619,7 @@ arc_linux_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n-  if (arc_debug)\n-    debug_printf (\"arc-linux: GNU/Linux OS/ABI initialization.\\n\");\n+  arc_linux_debug_printf (\"GNU/Linux OS/ABI initialization.\");\n \n   /* Fill in target-dependent info in ARC-private structure.  */\n   tdep->is_sigtramp = arc_linux_is_sigtramp;"
    },
    {
      "sha": "325e11b39a2d92701e4363df3a7a247bc961e3c0",
      "filename": "gdb/arc-newlib-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-newlib-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-newlib-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-newlib-tdep.c?ref=d8d1feb424fe57e54485212698f53fb90edbdf35",
      "patch": "@@ -24,13 +24,17 @@\n #include \"arc-tdep.h\"\n #include \"osabi.h\"\n \n+/* Print an \"arc-newlib\" debug statement.  */\n+\n+#define arc_newlib_debug_printf(fmt, ...) \\\n+  debug_prefixed_printf_cond (arc_debug, \"arc-newlib\", fmt, ##__VA_ARGS__)\n+\n /* Implement the 'init_osabi' method of struct gdb_osabi_handler.  */\n \n static void\n arc_newlib_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc-newlib: Initialization.\\n\");\n+  arc_newlib_debug_printf (\"Initialization.\");\n \n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \n@@ -44,8 +48,7 @@ arc_newlib_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n static enum gdb_osabi\n arc_newlib_osabi_sniffer (bfd *abfd)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc-newlib: OS/ABI sniffer.\\n\");\n+  arc_newlib_debug_printf (\"OS/ABI sniffer.\");\n \n   /* crt0.S in libgloss for ARC defines .ivt section for interrupt handlers.\n      If this section is not present then this is likely not a newlib - could be"
    },
    {
      "sha": "8385ad79f9f33c3362db59df408edf5a86374fa9",
      "filename": "gdb/arc-tdep.c",
      "status": "modified",
      "additions": 52,
      "deletions": 83,
      "changes": 135,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.c?ref=d8d1feb424fe57e54485212698f53fb90edbdf35",
      "patch": "@@ -601,9 +601,8 @@ arc_write_pc (struct regcache *regcache, CORE_ADDR new_pc)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n \n-  if (arc_debug)\n-    debug_printf (\"arc: Writing PC, new value=%s\\n\",\n-\t\t  paddress (gdbarch, new_pc));\n+  arc_debug_printf (\"Writing PC, new value=%s\",\n+\t\t    paddress (gdbarch, new_pc));\n \n   regcache_cooked_write_unsigned (regcache, gdbarch_pc_regnum (gdbarch),\n \t\t\t\t  new_pc);\n@@ -614,13 +613,10 @@ arc_write_pc (struct regcache *regcache, CORE_ADDR new_pc)\n \n   if ((status32 & ARC_STATUS32_DE_MASK) != 0)\n     {\n-      if (arc_debug)\n-\t{\n-\t  debug_printf (\"arc: Changing PC while in delay slot.  Will \"\n+      arc_debug_printf (\"Changing PC while in delay slot.  Will \"\n \t\t\t\"reset STATUS32.DE bit to zero.  Value of STATUS32 \"\n-\t\t\t\"register is 0x%s\\n\",\n+\t\t\t\"register is 0x%s\",\n \t\t\tphex (status32, ARC_REGISTER_SIZE));\n-\t}\n \n       /* Reset bit and write to the cache.  */\n       status32 &= ~0x40;\n@@ -734,8 +730,7 @@ arc_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t     function_call_return_method return_method,\n \t\t     CORE_ADDR struct_addr)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: push_dummy_call (nargs = %d)\\n\", nargs);\n+  arc_debug_printf (\"nargs = %d\", nargs);\n \n   int arg_reg = ARC_FIRST_ARG_REGNUM;\n \n@@ -751,9 +746,8 @@ arc_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       /* Pass the return address in the first argument register.  */\n       regcache_cooked_write_unsigned (regcache, arg_reg, struct_addr);\n \n-      if (arc_debug)\n-\tdebug_printf (\"arc: struct return address %s passed in R%d\",\n-\t\t      print_core_address (gdbarch, struct_addr), arg_reg);\n+      arc_debug_printf (\"struct return address %s passed in R%d\",\n+\t\t\tprint_core_address (gdbarch, struct_addr), arg_reg);\n \n       arg_reg++;\n     }\n@@ -771,8 +765,7 @@ arc_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \n \t  total_space += space;\n \n-\t  if (arc_debug)\n-\t    debug_printf (\"arc: arg %d: %u bytes -> %u\\n\", i, len, space);\n+\t  arc_debug_printf (\"arg %d: %u bytes -> %u\", i, len, space);\n \t}\n \n       /* Allocate a buffer to hold a memory image of the arguments.  */\n@@ -786,9 +779,8 @@ arc_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t  unsigned int space = align_up (len, 4);\n \n \t  memcpy (data, value_contents (args[i]), (size_t) len);\n-\t  if (arc_debug)\n-\t    debug_printf (\"arc: copying arg %d, val 0x%08x, len %d to mem\\n\",\n-\t\t\t  i, *((int *) value_contents (args[i])), len);\n+\t  arc_debug_printf (\"copying arg %d, val 0x%08x, len %d to mem\",\n+\t\t\t    i, *((int *) value_contents (args[i])), len);\n \n \t  data += space;\n \t}\n@@ -797,9 +789,8 @@ arc_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       data = memory_image;\n       while (arg_reg <= ARC_LAST_ARG_REGNUM)\n \t{\n-\t  if (arc_debug)\n-\t    debug_printf (\"arc: passing 0x%02x%02x%02x%02x in register R%d\\n\",\n-\t\t\t  data[0], data[1], data[2], data[3], arg_reg);\n+\t  arc_debug_printf (\"passing 0x%02x%02x%02x%02x in register R%d\",\n+\t\t\t    data[0], data[1], data[2], data[3], arg_reg);\n \n \t  /* Note we don't use write_unsigned here, since that would convert\n \t     the byte order, but we are already in the correct byte order.  */\n@@ -819,8 +810,7 @@ arc_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t operation).  */\n       if (total_space > 0)\n \t{\n-\t  if (arc_debug)\n-\t    debug_printf (\"arc: passing %d bytes on stack\\n\", total_space);\n+\t  arc_debug_printf (\"passing %d bytes on stack\\n\", total_space);\n \n \t  sp -= total_space;\n \t  write_memory (sp, data, (int) total_space);\n@@ -916,8 +906,7 @@ arc_extract_return_value (struct gdbarch *gdbarch, struct type *type,\n {\n   unsigned int len = TYPE_LENGTH (type);\n \n-  if (arc_debug)\n-    debug_printf (\"arc: extract_return_value\\n\");\n+  arc_debug_printf (\"called\");\n \n   if (len <= ARC_REGISTER_SIZE)\n     {\n@@ -928,8 +917,7 @@ arc_extract_return_value (struct gdbarch *gdbarch, struct type *type,\n       store_unsigned_integer (valbuf, (int) len,\n \t\t\t      gdbarch_byte_order (gdbarch), val);\n \n-      if (arc_debug)\n-\tdebug_printf (\"arc: returning 0x%s\\n\", phex (val, ARC_REGISTER_SIZE));\n+      arc_debug_printf (\"returning 0x%s\", phex (val, ARC_REGISTER_SIZE));\n     }\n   else if (len <= ARC_REGISTER_SIZE * 2)\n     {\n@@ -945,10 +933,9 @@ arc_extract_return_value (struct gdbarch *gdbarch, struct type *type,\n \t\t\t      (int) len - ARC_REGISTER_SIZE,\n \t\t\t      gdbarch_byte_order (gdbarch), high);\n \n-      if (arc_debug)\n-\tdebug_printf (\"arc: returning 0x%s%s\\n\",\n-\t\t      phex (high, ARC_REGISTER_SIZE),\n-\t\t      phex (low, ARC_REGISTER_SIZE));\n+      arc_debug_printf (\"returning 0x%s%s\",\n+\t\t\tphex (high, ARC_REGISTER_SIZE),\n+\t\t\tphex (low, ARC_REGISTER_SIZE));\n     }\n   else\n     error (_(\"arc: extract_return_value: type length %u too large\"), len);\n@@ -970,8 +957,7 @@ arc_store_return_value (struct gdbarch *gdbarch, struct type *type,\n {\n   unsigned int len = TYPE_LENGTH (type);\n \n-  if (arc_debug)\n-    debug_printf (\"arc: store_return_value\\n\");\n+  arc_debug_printf (\"called\");\n \n   if (len <= ARC_REGISTER_SIZE)\n     {\n@@ -982,8 +968,7 @@ arc_store_return_value (struct gdbarch *gdbarch, struct type *type,\n \t\t\t\t      gdbarch_byte_order (gdbarch));\n       regcache_cooked_write_unsigned (regcache, ARC_R0_REGNUM, val);\n \n-      if (arc_debug)\n-\tdebug_printf (\"arc: storing 0x%s\\n\", phex (val, ARC_REGISTER_SIZE));\n+      arc_debug_printf (\"storing 0x%s\", phex (val, ARC_REGISTER_SIZE));\n     }\n   else if (len <= ARC_REGISTER_SIZE * 2)\n     {\n@@ -999,10 +984,9 @@ arc_store_return_value (struct gdbarch *gdbarch, struct type *type,\n       regcache_cooked_write_unsigned (regcache, ARC_R0_REGNUM, low);\n       regcache_cooked_write_unsigned (regcache, ARC_R1_REGNUM, high);\n \n-      if (arc_debug)\n-\tdebug_printf (\"arc: storing 0x%s%s\\n\",\n-\t\t      phex (high, ARC_REGISTER_SIZE),\n-\t\t      phex (low, ARC_REGISTER_SIZE));\n+      arc_debug_printf (\"storing 0x%s%s\",\n+\t\t\tphex (high, ARC_REGISTER_SIZE),\n+\t\t\tphex (low, ARC_REGISTER_SIZE));\n     }\n   else\n     error (_(\"arc_store_return_value: type length too large.\"));\n@@ -1013,8 +997,7 @@ arc_store_return_value (struct gdbarch *gdbarch, struct type *type,\n static int\n arc_get_longjmp_target (struct frame_info *frame, CORE_ADDR *pc)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: get_longjmp_target\\n\");\n+  arc_debug_printf (\"called\");\n \n   struct gdbarch *gdbarch = get_frame_arch (frame);\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n@@ -1046,10 +1029,9 @@ arc_return_value (struct gdbarch *gdbarch, struct value *function,\n \t\t\t  || valtype->code () == TYPE_CODE_UNION\n \t\t\t  || TYPE_LENGTH (valtype) > 2 * ARC_REGISTER_SIZE);\n \n-  if (arc_debug)\n-    debug_printf (\"arc: return_value (readbuf = %s, writebuf = %s)\\n\",\n-\t\t  host_address_to_string (readbuf),\n-\t\t  host_address_to_string (writebuf));\n+  arc_debug_printf (\"readbuf = %s, writebuf = %s\",\n+\t\t    host_address_to_string (readbuf),\n+\t\t    host_address_to_string (writebuf));\n \n   if (writebuf != NULL)\n     {\n@@ -1400,10 +1382,9 @@ static CORE_ADDR\n arc_analyze_prologue (struct gdbarch *gdbarch, const CORE_ADDR entrypoint,\n \t\t      const CORE_ADDR limit_pc, struct arc_frame_cache *cache)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: analyze_prologue (entrypoint=%s, limit_pc=%s)\\n\",\n-\t\t  paddress (gdbarch, entrypoint),\n-\t\t  paddress (gdbarch, limit_pc));\n+  arc_debug_printf (\"entrypoint=%s, limit_pc=%s\",\n+\t\t    paddress (gdbarch, entrypoint),\n+\t\t    paddress (gdbarch, limit_pc));\n \n   /* Prologue values.  Only core registers can be stored.  */\n   pv_t regs[ARC_LAST_CORE_REGNUM + 1];\n@@ -1429,9 +1410,8 @@ arc_analyze_prologue (struct gdbarch *gdbarch, const CORE_ADDR entrypoint,\n       if (!arc_is_in_prologue (gdbarch, insn, regs, &stack))\n \t{\n \t  /* Found an instruction that is not in the prologue.  */\n-\t  if (arc_debug)\n-\t    debug_printf (\"arc: End of prologue reached at address %s\\n\",\n-\t\t\t  paddress (gdbarch, insn.address));\n+\t  arc_debug_printf (\"End of prologue reached at address %s\",\n+\t\t\t    paddress (gdbarch, insn.address));\n \t  break;\n \t}\n \n@@ -1492,8 +1472,7 @@ const static int MAX_PROLOGUE_LENGTH\n static CORE_ADDR\n arc_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: skip_prologue\\n\");\n+  arc_debug_printf (\"called\");\n \n   CORE_ADDR func_addr;\n   const char *func_name;\n@@ -1665,19 +1644,19 @@ static void\n arc_print_frame_cache (struct gdbarch *gdbarch, const char *message,\n \t\t       struct arc_frame_cache *cache, int addresses_known)\n {\n-  debug_printf (\"arc: frame_info %s\\n\", message);\n-  debug_printf (\"arc: prev_sp = %s\\n\", paddress (gdbarch, cache->prev_sp));\n-  debug_printf (\"arc: frame_base_reg = %i\\n\", cache->frame_base_reg);\n-  debug_printf (\"arc: frame_base_offset = %s\\n\",\n-\t\tplongest (cache->frame_base_offset));\n+  arc_debug_printf (\"frame_info %s\", message);\n+  arc_debug_printf (\"prev_sp = %s\", paddress (gdbarch, cache->prev_sp));\n+  arc_debug_printf (\"frame_base_reg = %i\", cache->frame_base_reg);\n+  arc_debug_printf (\"frame_base_offset = %s\",\n+\t\t    plongest (cache->frame_base_offset));\n \n   for (int i = 0; i <= ARC_BLINK_REGNUM; i++)\n     {\n       if (trad_frame_addr_p (cache->saved_regs, i))\n-\tdebug_printf (\"arc: saved register %s at %s %s\\n\",\n-\t\t      gdbarch_register_name (gdbarch, i),\n-\t\t      (addresses_known) ? \"address\" : \"offset\",\n-\t\t      paddress (gdbarch, cache->saved_regs[i].addr ()));\n+\tarc_debug_printf (\"saved register %s at %s %s\",\n+\t\t\t  gdbarch_register_name (gdbarch, i),\n+\t\t\t  (addresses_known) ? \"address\" : \"offset\",\n+\t\t\t      paddress (gdbarch, cache->saved_regs[i].addr ()));\n     }\n }\n \n@@ -1686,8 +1665,7 @@ arc_print_frame_cache (struct gdbarch *gdbarch, const char *message,\n static struct arc_frame_cache *\n arc_make_frame_cache (struct frame_info *this_frame)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: frame_cache\\n\");\n+  arc_debug_printf (\"called\");\n \n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n \n@@ -1755,8 +1733,7 @@ static void\n arc_frame_this_id (struct frame_info *this_frame, void **this_cache,\n \t\t   struct frame_id *this_id)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: frame_this_id\\n\");\n+  arc_debug_printf (\"called\");\n \n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n \n@@ -1851,8 +1828,7 @@ arc_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,\n static struct arc_frame_cache *\n arc_make_sigtramp_frame_cache (struct frame_info *this_frame)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: sigtramp_frame_cache\\n\");\n+  arc_debug_printf (\"called\");\n \n   struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n \n@@ -1891,8 +1867,7 @@ static void\n arc_sigtramp_frame_this_id (struct frame_info *this_frame,\n \t\t\t    void **this_cache, struct frame_id *this_id)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: sigtramp_frame_this_id\\n\");\n+  arc_debug_printf (\"called\");\n \n   if (*this_cache == NULL)\n     *this_cache = arc_make_sigtramp_frame_cache (this_frame);\n@@ -1911,8 +1886,7 @@ static struct value *\n arc_sigtramp_frame_prev_register (struct frame_info *this_frame,\n \t\t\t\t  void **this_cache, int regnum)\n {\n-  if (arc_debug)\n-    debug_printf (\"arc: sigtramp_frame_prev_register (regnum = %d)\\n\", regnum);\n+  arc_debug_printf (\"regnum = %d\", regnum);\n \n   /* Make sure we've initialized the cache.  */\n   if (*this_cache == NULL)\n@@ -1932,8 +1906,7 @@ arc_sigtramp_frame_sniffer (const struct frame_unwind *self,\n {\n   struct gdbarch_tdep *tdep;\n \n-  if (arc_debug)\n-    debug_printf (\"arc: sigtramp_frame_sniffer\\n\");\n+  arc_debug_printf (\"called\");\n \n   tdep = gdbarch_tdep (get_frame_arch (this_frame));\n \n@@ -2193,8 +2166,7 @@ arc_tdesc_init (struct gdbarch_info info, const struct target_desc **tdesc,\n \t\ttdesc_arch_data_up *tdesc_data)\n {\n   const struct target_desc *tdesc_loc = info.target_desc;\n-  if (arc_debug)\n-    debug_printf (\"arc: Target description initialization.\\n\");\n+  arc_debug_printf (\"Target description initialization.\");\n \n   /* If target doesn't provide a description, use the default ones.  */\n   if (!tdesc_has_registers (tdesc_loc))\n@@ -2206,8 +2178,7 @@ arc_tdesc_init (struct gdbarch_info info, const struct target_desc **tdesc,\n     }\n   gdb_assert (tdesc_loc != nullptr);\n \n-  if (arc_debug)\n-    debug_printf (\"arc: Have got a target description\\n\");\n+  arc_debug_printf (\"Have got a target description\");\n \n   const struct tdesc_feature *feature_core\n     = tdesc_find_feature (tdesc_loc, ARC_CORE_FEATURE_NAME);\n@@ -2253,8 +2224,7 @@ arc_tdesc_init (struct gdbarch_info info, const struct target_desc **tdesc,\n \n   if (!valid_p)\n     {\n-      if (arc_debug)\n-\tdebug_printf (\"arc: Target description is not valid\\n\");\n+      arc_debug_printf (\"Target description is not valid\");\n       return false;\n     }\n \n@@ -2300,8 +2270,7 @@ arc_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   const struct target_desc *tdesc;\n   tdesc_arch_data_up tdesc_data;\n \n-  if (arc_debug)\n-    debug_printf (\"arc: Architecture initialization.\\n\");\n+  arc_debug_printf (\"Architecture initialization.\");\n \n   if (!arc_tdesc_init (info, &tdesc, &tdesc_data))\n     return nullptr;"
    },
    {
      "sha": "8bb005cc7d4d4342cab712f5d2768460c9940283",
      "filename": "gdb/arc-tdep.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d8d1feb424fe57e54485212698f53fb90edbdf35/gdb/arc-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.h?ref=d8d1feb424fe57e54485212698f53fb90edbdf35",
      "patch": "@@ -114,6 +114,11 @@ enum arc_regnum\n \n extern bool arc_debug;\n \n+/* Print an \"arc\" debug statement.  */\n+\n+#define arc_debug_printf(fmt, ...) \\\n+  debug_prefixed_printf_cond (arc_debug, \"arc\", fmt, ##__VA_ARGS__)\n+\n /* Target-dependent information.  */\n \n struct gdbarch_tdep"
    }
  ]
}