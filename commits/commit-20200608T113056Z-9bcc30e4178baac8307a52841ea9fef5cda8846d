{
  "sha": "9bcc30e4178baac8307a52841ea9fef5cda8846d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWJjYzMwZTQxNzhiYWFjODMwN2E1Mjg0MWVhOWZlZjVjZGE4ODQ2ZA==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-08T11:24:04Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-08T11:30:56Z"
    },
    "message": "ELF: Move tlsdesc_plt/tlsdesc_got to elf_link_hash_table\n\nAll ELF backends with TLS descriptor support have\n\n  /* The offset into splt of the PLT entry for the TLS descriptor\n     resolver.  Special values are 0, if not necessary (or not found\n     to be necessary yet), and -1 if needed but not determined\n     yet.  */\n  bfd_vma tlsdesc_plt;\n\n  /* The GOT offset for the lazy trampoline.  Communicated to the\n     loader via DT_TLSDESC_GOT.  The magic value (bfd_vma) -1\n     indicates an offset is not allocated.  */\n  bfd_vma tlsdesc_got;\n\nin symbol hash entry.  Move tlsdesc_plt/tlsdesc_got to elf_link_hash_entry\nto reduce code duplication.\n\n\t* elf-bfd.h (elf_link_hash_entry): Add tlsdesc_plt and\n\ttlsdesc_got.\n\t* elf32-arm.c (elf32_arm_link_hash_table): Remove tlsdesc_plt\n\tand dt_tlsdesc_got.\n\t(elf32_arm_size_dynamic_sections): Updated.  Clear\n\troot.tlsdesc_plt for DF_BIND_NOW.\n\t(elf32_arm_finish_dynamic_sections): Updated.\n\t(elf32_arm_output_arch_local_syms): Likewise.\n\t* elf32-nds32.c (nds32_elf_size_dynamic_sections): Updated.\n\tClear root.tlsdesc_plt for DF_BIND_NOW.\n\t(nds32_elf_finish_dynamic_sections): Updated.\n\t* elf32-nds32.h (elf_nds32_link_hash_table): Remove\n\tdt_tlsdesc_plt and dt_tlsdesc_got.\n\t* elf64-x86-64.c (elf_x86_64_finish_dynamic_sections): Updated.\n\t* elfnn-aarch64.c (elf_aarch64_link_hash_table): Remove\n\ttlsdesc_plt and dt_tlsdesc_got.\n\t(elfNN_aarch64_allocate_dynrelocs): Updated.\n\t(elfNN_aarch64_finish_dynamic_sections): Likewise.\n\t(elfNN_aarch64_size_dynamic_sections): Updated.  Clear\n\troot.tlsdesc_plt for DF_BIND_NOW.  Don't check DF_BIND_NOW\n\ttwice.\n\t* elfxx-x86.c (elf_x86_allocate_dynrelocs): Updated.\n\t(_bfd_x86_elf_size_dynamic_sections): Likewise.\n\t(_bfd_x86_elf_finish_dynamic_sections): Likewise.\n\t* elfxx-x86.h (elf_x86_link_hash_table): Remove tlsdesc_plt and\n\ttlsdesc_got.",
    "tree": {
      "sha": "b55be2375cd10a5b9a55f5000458b730b8a3bed6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b55be2375cd10a5b9a55f5000458b730b8a3bed6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9bcc30e4178baac8307a52841ea9fef5cda8846d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9bcc30e4178baac8307a52841ea9fef5cda8846d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9bcc30e4178baac8307a52841ea9fef5cda8846d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9bcc30e4178baac8307a52841ea9fef5cda8846d/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b37a7714400cdc264ed236f72668b8956477b2ed",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b37a7714400cdc264ed236f72668b8956477b2ed",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b37a7714400cdc264ed236f72668b8956477b2ed"
    }
  ],
  "stats": {
    "total": 210,
    "additions": 108,
    "deletions": 102
  },
  "files": [
    {
      "sha": "7765dd363592687267218986575b6c0cb3913bc9",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -1,3 +1,32 @@\n+2020-06-08  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* elf-bfd.h (elf_link_hash_entry): Add tlsdesc_plt and\n+\ttlsdesc_got.\n+\t* elf32-arm.c (elf32_arm_link_hash_table): Remove tlsdesc_plt\n+\tand dt_tlsdesc_got.\n+\t(elf32_arm_size_dynamic_sections): Updated.  Clear\n+\troot.tlsdesc_plt for DF_BIND_NOW.\n+\t(elf32_arm_finish_dynamic_sections): Updated.\n+\t(elf32_arm_output_arch_local_syms): Likewise.\n+\t* elf32-nds32.c (nds32_elf_size_dynamic_sections): Updated.\n+\tClear root.tlsdesc_plt for DF_BIND_NOW.\n+\t(nds32_elf_finish_dynamic_sections): Updated.\n+\t* elf32-nds32.h (elf_nds32_link_hash_table): Remove\n+\tdt_tlsdesc_plt and dt_tlsdesc_got.\n+\t* elf64-x86-64.c (elf_x86_64_finish_dynamic_sections): Updated.\n+\t* elfnn-aarch64.c (elf_aarch64_link_hash_table): Remove\n+\ttlsdesc_plt and dt_tlsdesc_got.\n+\t(elfNN_aarch64_allocate_dynrelocs): Updated.\n+\t(elfNN_aarch64_finish_dynamic_sections): Likewise.\n+\t(elfNN_aarch64_size_dynamic_sections): Updated.  Clear\n+\troot.tlsdesc_plt for DF_BIND_NOW.  Don't check DF_BIND_NOW\n+\ttwice.\n+\t* elfxx-x86.c (elf_x86_allocate_dynrelocs): Updated.\n+\t(_bfd_x86_elf_size_dynamic_sections): Likewise.\n+\t(_bfd_x86_elf_finish_dynamic_sections): Likewise.\n+\t* elfxx-x86.h (elf_x86_link_hash_table): Remove tlsdesc_plt and\n+\ttlsdesc_got.\n+\n 2020-06-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* elf32-tic6x.c (elf32_bed): Defined the default to"
    },
    {
      "sha": "0e31ed1c3eb31ec9c8bb4ecd791b0abf3c69dfa2",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -650,6 +650,17 @@ struct elf_link_hash_table\n   asection *tls_sec;\n   bfd_size_type tls_size;  /* Bytes.  */\n \n+  /* The offset into splt of the PLT entry for the TLS descriptor\n+     resolver.  Special values are 0, if not necessary (or not found\n+     to be necessary yet), and -1 if needed but not determined\n+     yet.  */\n+  bfd_vma tlsdesc_plt;\n+\n+  /* The GOT offset for the lazy trampoline.  Communicated to the\n+     loader via DT_TLSDESC_GOT.  The magic value (bfd_vma) -1\n+     indicates an offset is not allocated.  */\n+  bfd_vma tlsdesc_got;\n+\n   /* Target OS for linker output.  */\n   enum elf_target_os target_os;\n "
    },
    {
      "sha": "35eee87a6d67dd406d752a8705d87a3c0745d3db",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 19,
      "deletions": 26,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -3380,16 +3380,6 @@ struct elf32_arm_link_hash_table\n   /* The (unloaded but important) VxWorks .rela.plt.unloaded section.  */\n   asection *srelplt2;\n \n-  /* The offset into splt of the PLT entry for the TLS descriptor\n-     resolver.  Special values are 0, if not necessary (or not found\n-     to be necessary yet), and -1 if needed but not determined\n-     yet.  */\n-  bfd_vma dt_tlsdesc_plt;\n-\n-  /* The offset into sgot of the GOT entry used by the PLT entry\n-     above.  */\n-  bfd_vma dt_tlsdesc_got;\n-\n   /* Offset in .plt section of tls_arm_trampoline.  */\n   bfd_vma tls_trampoline;\n \n@@ -16971,12 +16961,14 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \n       /* If we're not using lazy TLS relocations, don't generate the\n \t PLT and GOT entries they require.  */\n-      if (!(info->flags & DF_BIND_NOW))\n+      if ((info->flags & DF_BIND_NOW))\n+\thtab->root.tlsdesc_plt = 0;\n+      else\n \t{\n-\t  htab->dt_tlsdesc_got = htab->root.sgot->size;\n+\t  htab->root.tlsdesc_got = htab->root.sgot->size;\n \t  htab->root.sgot->size += 4;\n \n-\t  htab->dt_tlsdesc_plt = htab->root.splt->size;\n+\t  htab->root.tlsdesc_plt = htab->root.splt->size;\n \t  htab->root.splt->size += 4 * ARRAY_SIZE (dl_tlsdesc_lazy_trampoline);\n \t}\n     }\n@@ -17077,7 +17069,7 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t      || !add_dynamic_entry (DT_JMPREL, 0))\n \t    return FALSE;\n \n-\t  if (htab->dt_tlsdesc_plt\n+\t  if (htab->root.tlsdesc_plt\n \t      && (!add_dynamic_entry (DT_TLSDESC_PLT,0)\n \t\t  || !add_dynamic_entry (DT_TLSDESC_GOT,0)))\n \t    return FALSE;\n@@ -17462,14 +17454,14 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t    case DT_TLSDESC_PLT:\n \t      s = htab->root.splt;\n \t      dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset\n-\t\t\t\t+ htab->dt_tlsdesc_plt);\n+\t\t\t\t+ htab->root.tlsdesc_plt);\n \t      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);\n \t      break;\n \n \t    case DT_TLSDESC_GOT:\n \t      s = htab->root.sgot;\n \t      dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset\n-\t\t\t\t+ htab->dt_tlsdesc_got);\n+\t\t\t\t+ htab->root.tlsdesc_got);\n \t      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);\n \t      break;\n \n@@ -17580,7 +17572,7 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n       if (splt->output_section->owner == output_bfd)\n \telf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;\n \n-      if (htab->dt_tlsdesc_plt)\n+      if (htab->root.tlsdesc_plt)\n \t{\n \t  bfd_vma got_address\n \t    = sgot->output_section->vma + sgot->output_offset;\n@@ -17590,18 +17582,18 @@ elf32_arm_finish_dynamic_sections (bfd * output_bfd, struct bfd_link_info * info\n \t    = splt->output_section->vma + splt->output_offset;\n \n \t  arm_put_trampoline (htab, output_bfd,\n-\t\t\t      splt->contents + htab->dt_tlsdesc_plt,\n+\t\t\t      splt->contents + htab->root.tlsdesc_plt,\n \t\t\t      dl_tlsdesc_lazy_trampoline, 6);\n \n \t  bfd_put_32 (output_bfd,\n-\t\t      gotplt_address + htab->dt_tlsdesc_got\n-\t\t      - (plt_address + htab->dt_tlsdesc_plt)\n+\t\t      gotplt_address + htab->root.tlsdesc_got\n+\t\t      - (plt_address + htab->root.tlsdesc_plt)\n \t\t      - dl_tlsdesc_lazy_trampoline[6],\n-\t\t      splt->contents + htab->dt_tlsdesc_plt + 24);\n+\t\t      splt->contents + htab->root.tlsdesc_plt + 24);\n \t  bfd_put_32 (output_bfd,\n-\t\t      got_address - (plt_address + htab->dt_tlsdesc_plt)\n+\t\t      got_address - (plt_address + htab->root.tlsdesc_plt)\n \t\t      - dl_tlsdesc_lazy_trampoline[7],\n-\t\t      splt->contents + htab->dt_tlsdesc_plt + 24 + 4);\n+\t\t      splt->contents + htab->root.tlsdesc_plt + 24 + 4);\n \t}\n \n       if (htab->tls_trampoline)\n@@ -18374,14 +18366,15 @@ elf32_arm_output_arch_local_syms (bfd *output_bfd,\n \t    }\n \t}\n     }\n-  if (htab->dt_tlsdesc_plt != 0)\n+  if (htab->root.tlsdesc_plt != 0)\n     {\n       /* Mapping symbols for the lazy tls trampoline.  */\n-      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM, htab->dt_tlsdesc_plt))\n+      if (!elf32_arm_output_map_sym (&osi, ARM_MAP_ARM,\n+\t\t\t\t     htab->root.tlsdesc_plt))\n \treturn FALSE;\n \n       if (!elf32_arm_output_map_sym (&osi, ARM_MAP_DATA,\n-\t\t\t\t     htab->dt_tlsdesc_plt + 24))\n+\t\t\t\t     htab->root.tlsdesc_plt + 24))\n \treturn FALSE;\n     }\n   if (htab->tls_trampoline != 0)"
    },
    {
      "sha": "d8726359d568f9a78ab83a5d545c5b97a7153912",
      "filename": "bfd/elf32-nds32.c",
      "status": "modified",
      "additions": 11,
      "deletions": 9,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf32-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf32-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.c?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -4405,12 +4405,14 @@ nds32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       /* If we're not using lazy TLS relocations, don't generate the\n \t PLT and GOT entries they require.  */\n-      if (!(info->flags & DF_BIND_NOW))\n+      if ((info->flags & DF_BIND_NOW))\n+\thtab->root.tlsdesc_plt = 0;\n+      else\n \t{\n-\t  htab->dt_tlsdesc_got = htab->root.sgot->size;\n+\t  htab->root.tlsdesc_got = htab->root.sgot->size;\n \t  htab->root.sgot->size += 4;\n \n-\t  htab->dt_tlsdesc_plt = htab->root.splt->size;\n+\t  htab->root.tlsdesc_plt = htab->root.splt->size;\n \t  htab->root.splt->size += 4 * ARRAY_SIZE (dl_tlsdesc_lazy_trampoline);\n \t}\n     }\n@@ -4509,7 +4511,7 @@ nds32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \n       if (htab->tls_desc_trampoline && plt)\n \t{\n-\t  if (htab->dt_tlsdesc_plt\n+\t  if (htab->root.tlsdesc_plt\n \t      && (!add_dynamic_entry (DT_TLSDESC_PLT, 0)\n \t\t  || !add_dynamic_entry (DT_TLSDESC_GOT, 0)))\n \t    return FALSE;\n@@ -6435,14 +6437,14 @@ nds32_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t    case DT_TLSDESC_PLT:\n \t      s = htab->root.splt;\n \t      dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset\n-\t\t\t\t+ htab->dt_tlsdesc_plt);\n+\t\t\t\t+ htab->root.tlsdesc_plt);\n \t      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);\n \t      break;\n \n \t    case DT_TLSDESC_GOT:\n \t      s = htab->root.sgot;\n \t      dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset\n-\t\t\t\t+ htab->dt_tlsdesc_got);\n+\t\t\t\t+ htab->root.tlsdesc_got);\n \t      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);\n \t      break;\n \t    }\n@@ -6505,14 +6507,14 @@ nds32_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t    PLT_ENTRY_SIZE;\n \t}\n \n-      if (htab->dt_tlsdesc_plt)\n+      if (htab->root.tlsdesc_plt)\n \t{\n \t  /* Calculate addresses.  */\n \t  asection *sgot = sgot = ehtab->sgot;\n \t  bfd_vma pltgot = sgotplt->output_section->vma\n \t    + sgotplt->output_offset;\n \t  bfd_vma tlsdesc_got = sgot->output_section->vma + sgot->output_offset\n-\t    + htab->dt_tlsdesc_got;\n+\t    + htab->root.tlsdesc_got;\n \n \t  /* Get GP offset.  */\n \t  pltgot -= elf_gp (output_bfd) - 4; /* PLTGOT[1]  */\n@@ -6525,7 +6527,7 @@ nds32_elf_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t  dl_tlsdesc_lazy_trampoline[5] +=  0xfff & pltgot;\n \n \t  /* Insert .plt.  */\n-\t  nds32_put_trampoline (splt->contents + htab->dt_tlsdesc_plt,\n+\t  nds32_put_trampoline (splt->contents + htab->root.tlsdesc_plt,\n \t\t\t\tdl_tlsdesc_lazy_trampoline,\n \t\t\t\tARRAY_SIZE (dl_tlsdesc_lazy_trampoline));\n \t}"
    },
    {
      "sha": "b33ca99b6cba3ae99e61c7d74afd49a15f4966d2",
      "filename": "bfd/elf32-nds32.h",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf32-nds32.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf32-nds32.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.h?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -138,16 +138,6 @@ struct elf_nds32_link_hash_table\n   /* Disable if linking a dynamically linked executable.  */\n   int load_store_relax;\n \n-  /* The offset into splt of the PLT entry for the TLS descriptor\n-     resolver.  Special values are 0, if not necessary (or not found\n-     to be necessary yet), and -1 if needed but not determined\n-     yet.  */\n-  bfd_vma dt_tlsdesc_plt;\n-\n-  /* The offset into sgot of the GOT entry used by the PLT entry\n-     above.  */\n-  bfd_vma dt_tlsdesc_got;\n-\n   /* Offset in .plt section of tls_nds32_trampoline.  */\n   bfd_vma tls_trampoline;\n "
    },
    {
      "sha": "8562f33fb8665cd776e081cdcfb9ff0c7237f266",
      "filename": "bfd/elf64-x86-64.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf64-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elf64-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-x86-64.c?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -4667,12 +4667,12 @@ elf_x86_64_finish_dynamic_sections (bfd *output_bfd,\n \t\t       + htab->lazy_plt->plt0_got2_offset));\n \t}\n \n-      if (htab->tlsdesc_plt)\n+      if (htab->elf.tlsdesc_plt)\n \t{\n \t  bfd_put_64 (output_bfd, (bfd_vma) 0,\n-\t\t      htab->elf.sgot->contents + htab->tlsdesc_got);\n+\t\t      htab->elf.sgot->contents + htab->elf.tlsdesc_got);\n \n-\t  memcpy (htab->elf.splt->contents + htab->tlsdesc_plt,\n+\t  memcpy (htab->elf.splt->contents + htab->elf.tlsdesc_plt,\n \t\t  htab->lazy_plt->plt_tlsdesc_entry,\n \t\t  htab->lazy_plt->plt_tlsdesc_entry_size);\n \n@@ -4685,24 +4685,24 @@ elf_x86_64_finish_dynamic_sections (bfd *output_bfd,\n \t\t       + 8\n \t\t       - htab->elf.splt->output_section->vma\n \t\t       - htab->elf.splt->output_offset\n-\t\t       - htab->tlsdesc_plt\n+\t\t       - htab->elf.tlsdesc_plt\n \t\t       - htab->lazy_plt->plt_tlsdesc_got1_insn_end),\n \t\t      (htab->elf.splt->contents\n-\t\t       + htab->tlsdesc_plt\n+\t\t       + htab->elf.tlsdesc_plt\n \t\t       + htab->lazy_plt->plt_tlsdesc_got1_offset));\n \t  /* Add offset for indirect branch via GOT+TDG, where TDG\n \t     stands for htab->tlsdesc_got, subtracting the offset\n \t     to the end of that instruction.  */\n \t  bfd_put_32 (output_bfd,\n \t\t      (htab->elf.sgot->output_section->vma\n \t\t       + htab->elf.sgot->output_offset\n-\t\t       + htab->tlsdesc_got\n+\t\t       + htab->elf.tlsdesc_got\n \t\t       - htab->elf.splt->output_section->vma\n \t\t       - htab->elf.splt->output_offset\n-\t\t       - htab->tlsdesc_plt\n+\t\t       - htab->elf.tlsdesc_plt\n \t\t       - htab->lazy_plt->plt_tlsdesc_got2_insn_end),\n \t\t      (htab->elf.splt->contents\n-\t\t       + htab->tlsdesc_plt\n+\t\t       + htab->elf.tlsdesc_plt\n \t\t       + htab->lazy_plt->plt_tlsdesc_got2_offset));\n \t}\n     }"
    },
    {
      "sha": "6857c4cc8b00b6594fb62c1124aec17d37cadc61",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 21,
      "deletions": 30,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -2682,20 +2682,9 @@ struct elf_aarch64_link_hash_table\n   /* JUMP_SLOT relocs for variant PCS symbols may be present.  */\n   int variant_pcs;\n \n-  /* The offset into splt of the PLT entry for the TLS descriptor\n-     resolver.  Special values are 0, if not necessary (or not found\n-     to be necessary yet), and -1 if needed but not determined\n-     yet.  */\n-  bfd_vma tlsdesc_plt;\n-\n   /* The number of bytes in the PLT enty for the TLS descriptor.  */\n   bfd_size_type tlsdesc_plt_entry_size;\n \n-  /* The GOT offset for the lazy trampoline.  Communicated to the\n-     loader via DT_TLSDESC_GOT.  The magic value (bfd_vma) -1\n-     indicates an offset is not allocated.  */\n-  bfd_vma dt_tlsdesc_got;\n-\n   /* Used by local STT_GNU_IFUNC symbols.  */\n   htab_t loc_hash_table;\n   void * loc_hash_memory;\n@@ -2932,7 +2921,7 @@ elfNN_aarch64_link_hash_table_create (bfd *abfd)\n   ret->plt_entry = elfNN_aarch64_small_plt_entry;\n   ret->tlsdesc_plt_entry_size = PLT_TLSDESC_ENTRY_SIZE;\n   ret->obfd = abfd;\n-  ret->dt_tlsdesc_got = (bfd_vma) - 1;\n+  ret->root.tlsdesc_got = (bfd_vma) - 1;\n \n   if (!bfd_hash_table_init (&ret->stub_hash_table, stub_hash_newfunc,\n \t\t\t    sizeof (struct elf_aarch64_stub_hash_entry)))\n@@ -8682,7 +8671,7 @@ elfNN_aarch64_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t\t     type.  */\n \n \t\t  /* TLSDESC PLT is now needed, but not yet determined.  */\n-\t\t  htab->tlsdesc_plt = (bfd_vma) - 1;\n+\t\t  htab->root.tlsdesc_plt = (bfd_vma) - 1;\n \t\t}\n \n \t      if (got_type & GOT_TLS_GD)\n@@ -8968,7 +8957,7 @@ elfNN_aarch64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t    {\n \t\t      htab->root.srelplt->size += RELOC_SIZE (htab);\n \t\t      /* Note RELOC_COUNT not incremented here! */\n-\t\t      htab->tlsdesc_plt = (bfd_vma) - 1;\n+\t\t      htab->root.tlsdesc_plt = (bfd_vma) - 1;\n \t\t    }\n \n \t\t  if (got_type & GOT_TLS_GD)\n@@ -9011,19 +9000,21 @@ elfNN_aarch64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n   if (htab->root.srelplt)\n     htab->sgotplt_jump_table_size = aarch64_compute_jump_table_size (htab);\n \n-  if (htab->tlsdesc_plt)\n+  if (htab->root.tlsdesc_plt)\n     {\n       if (htab->root.splt->size == 0)\n \thtab->root.splt->size += htab->plt_header_size;\n \n       /* If we're not using lazy TLS relocations, don't generate the\n \t GOT and PLT entry required.  */\n-      if (!(info->flags & DF_BIND_NOW))\n+      if ((info->flags & DF_BIND_NOW))\n+\thtab->root.tlsdesc_plt = 0;\n+      else\n \t{\n-\t  htab->tlsdesc_plt = htab->root.splt->size;\n+\t  htab->root.tlsdesc_plt = htab->root.splt->size;\n \t  htab->root.splt->size += htab->tlsdesc_plt_entry_size;\n \n-\t  htab->dt_tlsdesc_got = htab->root.sgot->size;\n+\t  htab->root.tlsdesc_got = htab->root.sgot->size;\n \t  htab->root.sgot->size += GOT_ENTRY_SIZE;\n \t}\n     }\n@@ -9129,8 +9120,7 @@ elfNN_aarch64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t      && !add_dynamic_entry (DT_AARCH64_VARIANT_PCS, 0))\n \t    return FALSE;\n \n-\t  if (htab->tlsdesc_plt\n-\t      && !(info->flags & DF_BIND_NOW)\n+\t  if (htab->root.tlsdesc_plt\n \t      && (!add_dynamic_entry (DT_TLSDESC_PLT, 0)\n \t\t  || !add_dynamic_entry (DT_TLSDESC_GOT, 0)))\n \t    return FALSE;\n@@ -9639,14 +9629,14 @@ elfNN_aarch64_finish_dynamic_sections (bfd *output_bfd,\n \t    case DT_TLSDESC_PLT:\n \t      s = htab->root.splt;\n \t      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset\n-\t\t+ htab->tlsdesc_plt;\n+\t\t+ htab->root.tlsdesc_plt;\n \t      break;\n \n \t    case DT_TLSDESC_GOT:\n \t      s = htab->root.sgot;\n-\t      BFD_ASSERT (htab->dt_tlsdesc_got != (bfd_vma)-1);\n+\t      BFD_ASSERT (htab->root.tlsdesc_got != (bfd_vma)-1);\n \t      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset\n-\t\t+ htab->dt_tlsdesc_got;\n+\t\t+ htab->root.tlsdesc_got;\n \t      break;\n \t    }\n \n@@ -9664,11 +9654,11 @@ elfNN_aarch64_finish_dynamic_sections (bfd *output_bfd,\n \tthis_hdr.sh_entsize = htab->plt_entry_size;\n \n \n-      if (htab->tlsdesc_plt && !(info->flags & DF_BIND_NOW))\n+      if (htab->root.tlsdesc_plt && !(info->flags & DF_BIND_NOW))\n \t{\n-\t  BFD_ASSERT (htab->dt_tlsdesc_got != (bfd_vma)-1);\n+\t  BFD_ASSERT (htab->root.tlsdesc_got != (bfd_vma)-1);\n \t  bfd_put_NN (output_bfd, (bfd_vma) 0,\n-\t\t      htab->root.sgot->contents + htab->dt_tlsdesc_got);\n+\t\t      htab->root.sgot->contents + htab->root.tlsdesc_got);\n \n \t  const bfd_byte *entry = elfNN_aarch64_tlsdesc_small_plt_entry;\n \t  htab->tlsdesc_plt_entry_size = PLT_TLSDESC_ENTRY_SIZE;\n@@ -9679,13 +9669,14 @@ elfNN_aarch64_finish_dynamic_sections (bfd *output_bfd,\n \t      entry = elfNN_aarch64_tlsdesc_small_plt_bti_entry;\n \t    }\n \n-\t  memcpy (htab->root.splt->contents + htab->tlsdesc_plt,\n+\t  memcpy (htab->root.splt->contents + htab->root.tlsdesc_plt,\n \t\t  entry, htab->tlsdesc_plt_entry_size);\n \n \t  {\n \t    bfd_vma adrp1_addr =\n \t      htab->root.splt->output_section->vma\n-\t      + htab->root.splt->output_offset + htab->tlsdesc_plt + 4;\n+\t      + htab->root.splt->output_offset\n+\t      + htab->root.tlsdesc_plt + 4;\n \n \t    bfd_vma adrp2_addr = adrp1_addr + 4;\n \n@@ -9697,10 +9688,10 @@ elfNN_aarch64_finish_dynamic_sections (bfd *output_bfd,\n \t      htab->root.sgotplt->output_section->vma\n \t      + htab->root.sgotplt->output_offset;\n \n-\t    bfd_vma dt_tlsdesc_got = got_addr + htab->dt_tlsdesc_got;\n+\t    bfd_vma dt_tlsdesc_got = got_addr + htab->root.tlsdesc_got;\n \n \t    bfd_byte *plt_entry =\n-\t      htab->root.splt->contents + htab->tlsdesc_plt;\n+\t      htab->root.splt->contents + htab->root.tlsdesc_plt;\n \n \t   /* First instruction in BTI enabled PLT stub is a BTI\n \t      instruction so skip it.  */"
    },
    {
      "sha": "f02024096e01615a29095b66e7b8d64066848094",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -369,7 +369,7 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t{\n \t  htab->elf.srelplt->size += htab->sizeof_reloc;\n \t  if (bed->target_id == X86_64_ELF_DATA)\n-\t    htab->tlsdesc_plt = (bfd_vma) -1;\n+\t    htab->elf.tlsdesc_plt = (bfd_vma) -1;\n \t}\n     }\n   else\n@@ -1116,7 +1116,7 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t\t    {\n \t\t      htab->elf.srelplt->size += htab->sizeof_reloc;\n \t\t      if (bed->target_id == X86_64_ELF_DATA)\n-\t\t\thtab->tlsdesc_plt = (bfd_vma) -1;\n+\t\t\thtab->elf.tlsdesc_plt = (bfd_vma) -1;\n \t\t    }\n \t\t}\n \t    }\n@@ -1163,22 +1163,22 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n   else if (htab->elf.irelplt)\n     htab->next_irelative_index = htab->elf.irelplt->reloc_count - 1;\n \n-  if (htab->tlsdesc_plt)\n+  if (htab->elf.tlsdesc_plt)\n     {\n       /* NB: tlsdesc_plt is set only for x86-64.  If we're not using\n \t lazy TLS relocations, don't generate the PLT and GOT entries\n \t they require.  */\n       if ((info->flags & DF_BIND_NOW))\n-\thtab->tlsdesc_plt = 0;\n+\thtab->elf.tlsdesc_plt = 0;\n       else\n \t{\n-\t  htab->tlsdesc_got = htab->elf.sgot->size;\n+\t  htab->elf.tlsdesc_got = htab->elf.sgot->size;\n \t  htab->elf.sgot->size += htab->got_entry_size;\n \t  /* Reserve room for the initial entry.\n \t     FIXME: we could probably do away with it in this case.  */\n \t  if (htab->elf.splt->size == 0)\n \t    htab->elf.splt->size = htab->plt.plt_entry_size;\n-\t  htab->tlsdesc_plt = htab->elf.splt->size;\n+\t  htab->elf.tlsdesc_plt = htab->elf.splt->size;\n \t  htab->elf.splt->size += htab->plt.plt_entry_size;\n \t}\n     }\n@@ -1395,7 +1395,7 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t    return FALSE;\n \t}\n \n-      if (htab->tlsdesc_plt\n+      if (htab->elf.tlsdesc_plt\n \t  && (!add_dynamic_entry (DT_TLSDESC_PLT, 0)\n \t      || !add_dynamic_entry (DT_TLSDESC_GOT, 0)))\n \treturn FALSE;\n@@ -1544,13 +1544,13 @@ _bfd_x86_elf_finish_dynamic_sections (bfd *output_bfd,\n \tcase DT_TLSDESC_PLT:\n \t  s = htab->elf.splt;\n \t  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset\n-\t    + htab->tlsdesc_plt;\n+\t    + htab->elf.tlsdesc_plt;\n \t  break;\n \n \tcase DT_TLSDESC_GOT:\n \t  s = htab->elf.sgot;\n \t  dyn.d_un.d_ptr = s->output_section->vma + s->output_offset\n-\t    + htab->tlsdesc_got;\n+\t    + htab->elf.tlsdesc_got;\n \t  break;\n \t}\n "
    },
    {
      "sha": "dc7e6beb76bc435a95b367216c72d8c8be4a3cdb",
      "filename": "bfd/elfxx-x86.h",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elfxx-x86.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9bcc30e4178baac8307a52841ea9fef5cda8846d/bfd/elfxx-x86.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.h?ref=9bcc30e4178baac8307a52841ea9fef5cda8846d",
      "patch": "@@ -478,10 +478,6 @@ struct elf_x86_link_hash_table\n   htab_t loc_hash_table;\n   void * loc_hash_memory;\n \n-  /* The offset into sgot of the GOT entry used by the PLT entry\n-     above.  */\n-  bfd_vma tlsdesc_got;\n-\n   /* The index of the next R_X86_64_JUMP_SLOT entry in .rela.plt.  */\n   bfd_vma next_jump_slot_index;\n   /* The index of the next R_X86_64_IRELATIVE entry in .rela.plt.  */\n@@ -499,12 +495,6 @@ struct elf_x86_link_hash_table\n      is only used for i386.  */\n   bfd_vma next_tls_desc_index;\n \n-  /* The offset into splt of the PLT entry for the TLS descriptor\n-     resolver.  Special values are 0, if not necessary (or not found\n-     to be necessary yet), and -1 if needed but not determined\n-     yet.  This is only used for x86-64.  */\n-  bfd_vma tlsdesc_plt;\n-\n    /* Value used to fill the unused bytes of the first PLT entry.  This\n       is only used for i386.  */\n   bfd_byte plt0_pad_byte;"
    }
  ]
}