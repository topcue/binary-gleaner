{
  "sha": "314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzE0YWQ4OGRmNjNjMjZhOTg2ZTFlY2QxOGJmZTFkZTgxYTNjYzBmYg==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-09-14T20:16:56Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-09-14T20:16:56Z"
    },
    "message": "Use type_instance_flags more throughout\n\nA later patch in this series will rewrite enum_flags fixing some API\nholes.  That would cause build failures around code using\ntype_instance_flags.  Or rather, that should be using it, but wasn't.\n\nThis patch fixes it by using type_instance_flags throughout instead of\nplain integers.\n\nNote that we can't make the seemingly obvious change to struct\ntype::instance_flags:\n\n -  unsigned instance_flags : 9;\n +  ENUM_BITFIELD (type_instance_flag_value) instance_flags : 9;\n\nBecause G++ complains then that 9 bits isn't sufficient for holding\nall values of type_instance_flag_value.\n\nSo the patch adds an type::instance_flags() method, which takes care\nof casting appropriately, and adds a separate type::set_instance_flags\nmethod, following the pattern of the ongoing TYPE_XXX macro\nelimination.  This converts uses of TYPE_INSTANCE_FLAGS to\ntype::instance_flags() in the places where the code was already being\ntouched, but there are still many references to the\nTYPE_INSTANCE_FLAGS macro left behind.  Those could/should be fully\nreplaced at some point.\n\ngdb/ChangeLog:\n\n\t* avr-tdep.c (avr_address_class_type_flags): Return\n\ttype_instance_flags.\n\t(avr_address_class_type_flags_to_name): Take a\n\ttype_instance_flags.\n\t(avr_address_class_name_to_type_flags): Return bool and take a\n\ttype_instance_flags.\n\t* d-lang.c (build_d_types): Use type::set_instance_flags.\n\t* ft32-tdep.c (ft32_address_class_type_flags): Return\n\ttype_instance_flags.\n\t(ft32_address_class_type_flags_to_name): Take a\n\ttype_instance_flags.\n\t(ft32_address_class_name_to_type_flags): Return bool and take a\n\ttype_instance_flags.\n\t(ft32_gdbarch_init): Use type::set_instance_flags.\n\t* eval.c (fake_method::fake_method): Use type::set_instance_flags.\n\t* gdbarch.h, gdbarch.c: Regenerate.\n\t* gdbarch.sh (address_class_type_flags): Use type_instance_flags.\n\t(address_class_name_to_type_flags): Use type_instance_flags and\n\tbool.\n\t* gdbtypes.c (address_space_name_to_int)\n\t(address_space_int_to_name, make_qualified_type): Use\n\ttype_instance_flags.\n\t(make_qualified_type): Use type_instance_flags and\n\ttype::set_instance_flags.\n\t(make_type_with_address_space, make_cv_type, make_vector_type)\n\t(check_typedef): Use type_instance_flags.\n\t(recursive_dump_type): Cast type_instance_flags to unsigned for\n\tprinting.\n\t(copy_type_recursive): Use type::set_instance_flags.\n\t(gdbtypes_post_init): Use type::set_instance_flags.\n\t* gdbtypes.h (struct type) <instance_flags>: Rename to ...\n\t<m_instance_flags>: ... this.\n\t<instance_flags, set_instance_flags>: New methods.\n\t(TYPE_INSTANCE_FLAGS): Use the instance_flags method.\n\t(SET_TYPE_INSTANCE_FLAGS): New.\n\t(address_space_name_to_int, address_space_int_to_name)\n\t(make_type_with_address_space): Pass flags using\n\ttype_instance_flags instead of int.\n\t* stabsread.c (cleanup_undefined_types_noname): Use\n\ttype::set_instance_flags.\n\t* s390-tdep.c (s390_address_class_type_flags): Return\n\ttype_instance_flags.\n\t(s390_address_class_type_flags_to_name): Take a\n\ttype_instance_flags.\n\t(s390_address_class_name_to_type_flags): Return bool and take a\n\ttype_instance_flags.\n\t* type-stack.c (type_stack::follow_types): Use\n\ttype_instance_flags.\n\t* dwarf2/read.c (read_tag_pointer_type): Use type_instance_flags.",
    "tree": {
      "sha": "065ea5edf44305781b2d1f4677ed7a92447dc9f2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/065ea5edf44305781b2d1f4677ed7a92447dc9f2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "27087b7f6ce8c6d304b149df2484436d97e6334b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/27087b7f6ce8c6d304b149df2484436d97e6334b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/27087b7f6ce8c6d304b149df2484436d97e6334b"
    }
  ],
  "stats": {
    "total": 253,
    "additions": 168,
    "deletions": 85
  },
  "files": [
    {
      "sha": "7d4800b0b02689829c7c9cfab14ffd1786711313",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 53,
      "deletions": 0,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -1,3 +1,56 @@\n+2020-09-14  Pedro Alves  <pedro@palves.net>\n+\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* avr-tdep.c (avr_address_class_type_flags): Return\n+\ttype_instance_flags.\n+\t(avr_address_class_type_flags_to_name): Take a\n+\ttype_instance_flags.\n+\t(avr_address_class_name_to_type_flags): Return bool and take a\n+\ttype_instance_flags.\n+\t* d-lang.c (build_d_types): Use type::set_instance_flags.\n+\t* ft32-tdep.c (ft32_address_class_type_flags): Return\n+\ttype_instance_flags.\n+\t(ft32_address_class_type_flags_to_name): Take a\n+\ttype_instance_flags.\n+\t(ft32_address_class_name_to_type_flags): Return bool and take a\n+\ttype_instance_flags.\n+\t(ft32_gdbarch_init): Use type::set_instance_flags.\n+\t* eval.c (fake_method::fake_method): Use type::set_instance_flags.\n+\t* gdbarch.h, gdbarch.c: Regenerate.\n+\t* gdbarch.sh (address_class_type_flags): Use type_instance_flags.\n+\t(address_class_name_to_type_flags): Use type_instance_flags and\n+\tbool.\n+\t* gdbtypes.c (address_space_name_to_int)\n+\t(address_space_int_to_name, make_qualified_type): Use\n+\ttype_instance_flags.\n+\t(make_qualified_type): Use type_instance_flags and\n+\ttype::set_instance_flags.\n+\t(make_type_with_address_space, make_cv_type, make_vector_type)\n+\t(check_typedef): Use type_instance_flags.\n+\t(recursive_dump_type): Cast type_instance_flags to unsigned for\n+\tprinting.\n+\t(copy_type_recursive): Use type::set_instance_flags.\n+\t(gdbtypes_post_init): Use type::set_instance_flags.\n+\t* gdbtypes.h (struct type) <instance_flags>: Rename to ...\n+\t<m_instance_flags>: ... this.\n+\t<instance_flags, set_instance_flags>: New methods.\n+\t(TYPE_INSTANCE_FLAGS): Use the instance_flags method.\n+\t(SET_TYPE_INSTANCE_FLAGS): New.\n+\t(address_space_name_to_int, address_space_int_to_name)\n+\t(make_type_with_address_space): Pass flags using\n+\ttype_instance_flags instead of int.\n+\t* stabsread.c (cleanup_undefined_types_noname): Use\n+\ttype::set_instance_flags.\n+\t* s390-tdep.c (s390_address_class_type_flags): Return\n+\ttype_instance_flags.\n+\t(s390_address_class_type_flags_to_name): Take a\n+\ttype_instance_flags.\n+\t(s390_address_class_name_to_type_flags): Return bool and take a\n+\ttype_instance_flags.\n+\t* type-stack.c (type_stack::follow_types): Use\n+\ttype_instance_flags.\n+\t* dwarf2/read.c (read_tag_pointer_type): Use type_instance_flags.\n+\n 2020-09-14  Tom Tromey  <tromey@adacore.com>\n \n \t* x86-tdep.h (x86_in_indirect_branch_thunk): Update."
    },
    {
      "sha": "68b8487de79bb0d418e4530d2731723a3432f28d",
      "filename": "gdb/avr-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 7,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/avr-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/avr-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/avr-tdep.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -1372,7 +1372,7 @@ avr_dwarf_reg_to_regnum (struct gdbarch *gdbarch, int reg)\n    This method maps DW_AT_address_class attributes to a\n    type_instance_flag_value.  */\n \n-static int\n+static type_instance_flags\n avr_address_class_type_flags (int byte_size, int dwarf2_addr_class)\n {\n   /* The value 1 of the DW_AT_address_class attribute corresponds to the\n@@ -1389,7 +1389,8 @@ avr_address_class_type_flags (int byte_size, int dwarf2_addr_class)\n    Convert a type_instance_flag_value to an address space qualifier.  */\n \n static const char*\n-avr_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)\n+avr_address_class_type_flags_to_name (struct gdbarch *gdbarch,\n+\t\t\t\t      type_instance_flags type_flags)\n {\n   if (type_flags & AVR_TYPE_INSTANCE_FLAG_ADDRESS_CLASS_FLASH)\n     return \"flash\";\n@@ -1401,18 +1402,18 @@ avr_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)\n \n    Convert an address space qualifier to a type_instance_flag_value.  */\n \n-static int\n+static bool\n avr_address_class_name_to_type_flags (struct gdbarch *gdbarch,\n-                                      const char* name,\n-                                      int *type_flags_ptr)\n+\t\t\t\t      const char* name,\n+\t\t\t\t      type_instance_flags *type_flags_ptr)\n {\n   if (strcmp (name, \"flash\") == 0)\n     {\n       *type_flags_ptr = AVR_TYPE_INSTANCE_FLAG_ADDRESS_CLASS_FLASH;\n-      return 1;\n+      return true;\n     }\n   else\n-    return 0;\n+    return false;\n }\n \n /* Initialize the gdbarch structure for the AVR's.  */"
    },
    {
      "sha": "abef3b6fa4378101057a80be69d11bc6c020b6b6",
      "filename": "gdb/d-lang.c",
      "status": "modified",
      "additions": 7,
      "deletions": 4,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/d-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/d-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-lang.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -321,10 +321,13 @@ build_d_types (struct gdbarch *gdbarch)\n     = arch_float_type (gdbarch, gdbarch_long_double_bit (gdbarch),\n \t\t       \"real\", gdbarch_long_double_format (gdbarch));\n \n-  TYPE_INSTANCE_FLAGS (builtin_d_type->builtin_byte)\n-    |= TYPE_INSTANCE_FLAG_NOTTEXT;\n-  TYPE_INSTANCE_FLAGS (builtin_d_type->builtin_ubyte)\n-    |= TYPE_INSTANCE_FLAG_NOTTEXT;\n+  builtin_d_type->builtin_byte->set_instance_flags\n+    (builtin_d_type->builtin_byte->instance_flags ()\n+     | TYPE_INSTANCE_FLAG_NOTTEXT);\n+\n+  builtin_d_type->builtin_ubyte->set_instance_flags\n+    (builtin_d_type->builtin_ubyte->instance_flags ()\n+     | TYPE_INSTANCE_FLAG_NOTTEXT);\n \n   /* Imaginary and complex types.  */\n   builtin_d_type->builtin_ifloat"
    },
    {
      "sha": "2c554d6d5c91f2a28cdc5b6879bccabcbf22a131",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -17296,10 +17296,9 @@ read_tag_pointer_type (struct die_info *die, struct dwarf2_cu *cu)\n     {\n       if (gdbarch_address_class_type_flags_p (gdbarch))\n \t{\n-\t  int type_flags;\n-\n-\t  type_flags = gdbarch_address_class_type_flags\n-\t\t\t (gdbarch, byte_size, addr_class);\n+\t  type_instance_flags type_flags\n+\t    = gdbarch_address_class_type_flags (gdbarch, byte_size,\n+\t\t\t\t\t\taddr_class);\n \t  gdb_assert ((type_flags & ~TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL)\n \t\t      == 0);\n \t  type = make_type_with_address_space (type, type_flags);"
    },
    {
      "sha": "1177f7444e6814ffac2aa0ce5bdd0202aeddb9c7",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -659,7 +659,7 @@ fake_method::fake_method (type_instance_flags flags,\n   TYPE_LENGTH (type) = 1;\n   type->set_code (TYPE_CODE_METHOD);\n   TYPE_CHAIN (type) = type;\n-  TYPE_INSTANCE_FLAGS (type) = flags;\n+  type->set_instance_flags (flags);\n   if (num_types > 0)\n     {\n       if (param_types[num_types - 1] == NULL)"
    },
    {
      "sha": "57c1bbba0c4d7c3519846e02abff07d69172f78e",
      "filename": "gdb/ft32-tdep.c",
      "status": "modified",
      "additions": 9,
      "deletions": 7,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/ft32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/ft32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ft32-tdep.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -341,7 +341,7 @@ ft32_pointer_to_address (struct gdbarch *gdbarch,\n    This method maps DW_AT_address_class attributes to a\n    type_instance_flag_value.  */\n \n-static int\n+static type_instance_flags\n ft32_address_class_type_flags (int byte_size, int dwarf2_addr_class)\n {\n   /* The value 1 of the DW_AT_address_class attribute corresponds to the\n@@ -357,7 +357,8 @@ ft32_address_class_type_flags (int byte_size, int dwarf2_addr_class)\n    Convert a type_instance_flag_value to an address space qualifier.  */\n \n static const char*\n-ft32_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)\n+ft32_address_class_type_flags_to_name (struct gdbarch *gdbarch,\n+\t\t\t\t       type_instance_flags type_flags)\n {\n   if (type_flags & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1)\n     return \"flash\";\n@@ -369,18 +370,18 @@ ft32_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)\n \n    Convert an address space qualifier to a type_instance_flag_value.  */\n \n-static int\n+static bool\n ft32_address_class_name_to_type_flags (struct gdbarch *gdbarch,\n \t\t\t\t       const char* name,\n-\t\t\t\t       int *type_flags_ptr)\n+\t\t\t\t       type_instance_flags *type_flags_ptr)\n {\n   if (strcmp (name, \"flash\") == 0)\n     {\n       *type_flags_ptr = TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;\n-      return 1;\n+      return true;\n     }\n   else\n-    return 0;\n+    return false;\n }\n \n /* Given a return value in `regbuf' with a type `valtype',\n@@ -576,7 +577,8 @@ ft32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   func_void_type = make_function_type (void_type, NULL);\n   tdep->pc_type = arch_pointer_type (gdbarch, 4 * TARGET_CHAR_BIT, NULL,\n \t\t\t\t     func_void_type);\n-  TYPE_INSTANCE_FLAGS (tdep->pc_type) |= TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;\n+  tdep->pc_type->set_instance_flags (tdep->pc_type->instance_flags ()\n+\t\t\t\t     | TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1);\n \n   set_gdbarch_num_regs (gdbarch, FT32_NUM_REGS);\n   set_gdbarch_sp_regnum (gdbarch, FT32_SP_REGNUM);"
    },
    {
      "sha": "5e44047c2a969231c344ca1f45ed0705ac60ea95",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -3546,7 +3546,7 @@ gdbarch_address_class_type_flags_p (struct gdbarch *gdbarch)\n   return gdbarch->address_class_type_flags != NULL;\n }\n \n-int\n+type_instance_flags\n gdbarch_address_class_type_flags (struct gdbarch *gdbarch, int byte_size, int dwarf2_addr_class)\n {\n   gdb_assert (gdbarch != NULL);\n@@ -3571,7 +3571,7 @@ gdbarch_address_class_type_flags_to_name_p (struct gdbarch *gdbarch)\n }\n \n const char *\n-gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)\n+gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, type_instance_flags type_flags)\n {\n   gdb_assert (gdbarch != NULL);\n   gdb_assert (gdbarch->address_class_type_flags_to_name != NULL);\n@@ -3611,8 +3611,8 @@ gdbarch_address_class_name_to_type_flags_p (struct gdbarch *gdbarch)\n   return gdbarch->address_class_name_to_type_flags != NULL;\n }\n \n-int\n-gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name, int *type_flags_ptr)\n+bool\n+gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name, type_instance_flags *type_flags_ptr)\n {\n   gdb_assert (gdbarch != NULL);\n   gdb_assert (gdbarch->address_class_name_to_type_flags != NULL);"
    },
    {
      "sha": "9f98ae835667fa9b2cff5cae743bf0f1d5c7f136",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -854,14 +854,14 @@ extern void set_gdbarch_have_nonsteppable_watchpoint (struct gdbarch *gdbarch, i\n \n extern int gdbarch_address_class_type_flags_p (struct gdbarch *gdbarch);\n \n-typedef int (gdbarch_address_class_type_flags_ftype) (int byte_size, int dwarf2_addr_class);\n-extern int gdbarch_address_class_type_flags (struct gdbarch *gdbarch, int byte_size, int dwarf2_addr_class);\n+typedef type_instance_flags (gdbarch_address_class_type_flags_ftype) (int byte_size, int dwarf2_addr_class);\n+extern type_instance_flags gdbarch_address_class_type_flags (struct gdbarch *gdbarch, int byte_size, int dwarf2_addr_class);\n extern void set_gdbarch_address_class_type_flags (struct gdbarch *gdbarch, gdbarch_address_class_type_flags_ftype *address_class_type_flags);\n \n extern int gdbarch_address_class_type_flags_to_name_p (struct gdbarch *gdbarch);\n \n-typedef const char * (gdbarch_address_class_type_flags_to_name_ftype) (struct gdbarch *gdbarch, int type_flags);\n-extern const char * gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags);\n+typedef const char * (gdbarch_address_class_type_flags_to_name_ftype) (struct gdbarch *gdbarch, type_instance_flags type_flags);\n+extern const char * gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, type_instance_flags type_flags);\n extern void set_gdbarch_address_class_type_flags_to_name (struct gdbarch *gdbarch, gdbarch_address_class_type_flags_to_name_ftype *address_class_type_flags_to_name);\n \n /* Execute vendor-specific DWARF Call Frame Instruction.  OP is the instruction.\n@@ -872,13 +872,13 @@ extern bool gdbarch_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdb_by\n extern void set_gdbarch_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdbarch_execute_dwarf_cfa_vendor_op_ftype *execute_dwarf_cfa_vendor_op);\n \n /* Return the appropriate type_flags for the supplied address class.\n-   This function should return 1 if the address class was recognized and\n-   type_flags was set, zero otherwise. */\n+   This function should return true if the address class was recognized and\n+   type_flags was set, false otherwise. */\n \n extern int gdbarch_address_class_name_to_type_flags_p (struct gdbarch *gdbarch);\n \n-typedef int (gdbarch_address_class_name_to_type_flags_ftype) (struct gdbarch *gdbarch, const char *name, int *type_flags_ptr);\n-extern int gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name, int *type_flags_ptr);\n+typedef bool (gdbarch_address_class_name_to_type_flags_ftype) (struct gdbarch *gdbarch, const char *name, type_instance_flags *type_flags_ptr);\n+extern bool gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, const char *name, type_instance_flags *type_flags_ptr);\n extern void set_gdbarch_address_class_name_to_type_flags (struct gdbarch *gdbarch, gdbarch_address_class_name_to_type_flags_ftype *address_class_name_to_type_flags);\n \n /* Is a register in a group */"
    },
    {
      "sha": "f9aed71fa7c3b5b0c8dda54740d7b4b8eb227ef8",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -691,16 +691,16 @@ v;int;cannot_step_breakpoint;;;0;0;;0\n # See comment in target.h about continuable, steppable and\n # non-steppable watchpoints.\n v;int;have_nonsteppable_watchpoint;;;0;0;;0\n-F;int;address_class_type_flags;int byte_size, int dwarf2_addr_class;byte_size, dwarf2_addr_class\n-M;const char *;address_class_type_flags_to_name;int type_flags;type_flags\n+F;type_instance_flags;address_class_type_flags;int byte_size, int dwarf2_addr_class;byte_size, dwarf2_addr_class\n+M;const char *;address_class_type_flags_to_name;type_instance_flags type_flags;type_flags\n # Execute vendor-specific DWARF Call Frame Instruction.  OP is the instruction.\n # FS are passed from the generic execute_cfa_program function.\n m;bool;execute_dwarf_cfa_vendor_op;gdb_byte op, struct dwarf2_frame_state *fs;op, fs;;default_execute_dwarf_cfa_vendor_op;;0\n \n # Return the appropriate type_flags for the supplied address class.\n-# This function should return 1 if the address class was recognized and\n-# type_flags was set, zero otherwise.\n-M;int;address_class_name_to_type_flags;const char *name, int *type_flags_ptr;name, type_flags_ptr\n+# This function should return true if the address class was recognized and\n+# type_flags was set, false otherwise.\n+M;bool;address_class_name_to_type_flags;const char *name, type_instance_flags *type_flags_ptr;name, type_flags_ptr\n # Is a register in a group\n m;int;register_reggroup_p;int regnum, struct reggroup *reggroup;regnum, reggroup;;default_register_reggroup_p;;0\n # Fetch the pointer to the ith function argument."
    },
    {
      "sha": "b57353dec3051b6c2cbdc93e88e0cff323c02804",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 40,
      "deletions": 30,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -578,11 +578,11 @@ lookup_function_type_with_arguments (struct type *type,\n /* Identify address space identifier by name --\n    return the integer flag defined in gdbtypes.h.  */\n \n-int\n+type_instance_flags\n address_space_name_to_int (struct gdbarch *gdbarch,\n \t\t\t   const char *space_identifier)\n {\n-  int type_flags;\n+  type_instance_flags type_flags;\n \n   /* Check for known address space delimiters.  */\n   if (!strcmp (space_identifier, \"code\"))\n@@ -602,7 +602,8 @@ address_space_name_to_int (struct gdbarch *gdbarch,\n    gdbtypes.h -- return the string version of the adress space name.  */\n \n const char *\n-address_space_int_to_name (struct gdbarch *gdbarch, int space_flag)\n+address_space_int_to_name (struct gdbarch *gdbarch,\n+\t\t\t   type_instance_flags space_flag)\n {\n   if (space_flag & TYPE_INSTANCE_FLAG_CODE_SPACE)\n     return \"code\";\n@@ -621,7 +622,7 @@ address_space_int_to_name (struct gdbarch *gdbarch, int space_flag)\n    STORAGE must be in the same obstack as TYPE.  */\n \n static struct type *\n-make_qualified_type (struct type *type, int new_flags,\n+make_qualified_type (struct type *type, type_instance_flags new_flags,\n \t\t     struct type *storage)\n {\n   struct type *ntype;\n@@ -661,7 +662,7 @@ make_qualified_type (struct type *type, int new_flags,\n   TYPE_CHAIN (type) = ntype;\n \n   /* Now set the instance flags and return the new type.  */\n-  TYPE_INSTANCE_FLAGS (ntype) = new_flags;\n+  ntype->set_instance_flags (new_flags);\n \n   /* Set length of new type to that of the original type.  */\n   TYPE_LENGTH (ntype) = TYPE_LENGTH (type);\n@@ -679,13 +680,14 @@ make_qualified_type (struct type *type, int new_flags,\n    representations.  */\n \n struct type *\n-make_type_with_address_space (struct type *type, int space_flag)\n+make_type_with_address_space (struct type *type,\n+\t\t\t      type_instance_flags space_flag)\n {\n-  int new_flags = ((TYPE_INSTANCE_FLAGS (type)\n-\t\t    & ~(TYPE_INSTANCE_FLAG_CODE_SPACE\n-\t\t\t| TYPE_INSTANCE_FLAG_DATA_SPACE\n-\t\t        | TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL))\n-\t\t   | space_flag);\n+  type_instance_flags new_flags = ((type->instance_flags ()\n+\t\t\t\t    & ~(TYPE_INSTANCE_FLAG_CODE_SPACE\n+\t\t\t\t\t| TYPE_INSTANCE_FLAG_DATA_SPACE\n+\t\t\t\t\t| TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL))\n+\t\t\t\t   | space_flag);\n \n   return make_qualified_type (type, new_flags, NULL);\n }\n@@ -709,9 +711,9 @@ make_cv_type (int cnst, int voltl,\n {\n   struct type *ntype;\t/* New type */\n \n-  int new_flags = (TYPE_INSTANCE_FLAGS (type)\n-\t\t   & ~(TYPE_INSTANCE_FLAG_CONST \n-\t\t       | TYPE_INSTANCE_FLAG_VOLATILE));\n+  type_instance_flags new_flags = (type->instance_flags ()\n+\t\t\t\t   & ~(TYPE_INSTANCE_FLAG_CONST\n+\t\t\t\t       | TYPE_INSTANCE_FLAG_VOLATILE));\n \n   if (cnst)\n     new_flags |= TYPE_INSTANCE_FLAG_CONST;\n@@ -1412,7 +1414,6 @@ void\n make_vector_type (struct type *array_type)\n {\n   struct type *inner_array, *elt_type;\n-  int flags;\n \n   /* Find the innermost array type, in case the array is\n      multi-dimensional.  */\n@@ -1423,7 +1424,8 @@ make_vector_type (struct type *array_type)\n   elt_type = TYPE_TARGET_TYPE (inner_array);\n   if (elt_type->code () == TYPE_CODE_INT)\n     {\n-      flags = TYPE_INSTANCE_FLAGS (elt_type) | TYPE_INSTANCE_FLAG_NOTTEXT;\n+      type_instance_flags flags\n+\t= elt_type->instance_flags () | TYPE_INSTANCE_FLAG_NOTTEXT;\n       elt_type = make_qualified_type (elt_type, flags, NULL);\n       TYPE_TARGET_TYPE (inner_array) = elt_type;\n     }\n@@ -2734,12 +2736,13 @@ struct type *\n check_typedef (struct type *type)\n {\n   struct type *orig_type = type;\n-  /* While we're removing typedefs, we don't want to lose qualifiers.\n-     E.g., const/volatile.  */\n-  int instance_flags = TYPE_INSTANCE_FLAGS (type);\n \n   gdb_assert (type);\n \n+  /* While we're removing typedefs, we don't want to lose qualifiers.\n+     E.g., const/volatile.  */\n+  type_instance_flags instance_flags = type->instance_flags ();\n+\n   while (type->code () == TYPE_CODE_TYPEDEF)\n     {\n       if (!TYPE_TARGET_TYPE (type))\n@@ -2780,10 +2783,13 @@ check_typedef (struct type *type)\n \t outer cast in a chain of casting win), instead of assuming\n \t \"it can't happen\".  */\n       {\n-\tconst int ALL_SPACES = (TYPE_INSTANCE_FLAG_CODE_SPACE\n-\t\t\t\t| TYPE_INSTANCE_FLAG_DATA_SPACE);\n-\tconst int ALL_CLASSES = TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL;\n-\tint new_instance_flags = TYPE_INSTANCE_FLAGS (type);\n+\tconst type_instance_flags ALL_SPACES\n+\t  = (TYPE_INSTANCE_FLAG_CODE_SPACE\n+\t     | TYPE_INSTANCE_FLAG_DATA_SPACE);\n+\tconst type_instance_flags ALL_CLASSES\n+\t  = TYPE_INSTANCE_FLAG_ADDRESS_CLASS_ALL;\n+\n+\ttype_instance_flags new_instance_flags = type->instance_flags ();\n \n \t/* Treat code vs data spaces and address classes separately.  */\n \tif ((instance_flags & ALL_SPACES) != 0)\n@@ -5028,7 +5034,7 @@ recursive_dump_type (struct type *type, int spaces)\n   gdb_print_host_address (TYPE_CHAIN (type), gdb_stdout);\n   printf_filtered (\"\\n\");\n   printfi_filtered (spaces, \"instance_flags 0x%x\", \n-\t\t    TYPE_INSTANCE_FLAGS (type));\n+\t\t    (unsigned) type->instance_flags ());\n   if (TYPE_CONST (type))\n     {\n       puts_filtered (\" TYPE_CONST\");\n@@ -5302,7 +5308,7 @@ copy_type_recursive (struct objfile *objfile,\n   if (type->name ())\n     new_type->set_name (xstrdup (type->name ()));\n \n-  TYPE_INSTANCE_FLAGS (new_type) = TYPE_INSTANCE_FLAGS (type);\n+  new_type->set_instance_flags (type->instance_flags ());\n   TYPE_LENGTH (new_type) = TYPE_LENGTH (type);\n \n   /* Copy the fields.  */\n@@ -5429,7 +5435,7 @@ copy_type (const struct type *type)\n   gdb_assert (TYPE_OBJFILE_OWNED (type));\n \n   new_type = alloc_type_copy (type);\n-  TYPE_INSTANCE_FLAGS (new_type) = TYPE_INSTANCE_FLAGS (type);\n+  new_type->set_instance_flags (type->instance_flags ());\n   TYPE_LENGTH (new_type) = TYPE_LENGTH (type);\n   memcpy (TYPE_MAIN_TYPE (new_type), TYPE_MAIN_TYPE (type),\n \t  sizeof (struct main_type));\n@@ -5822,10 +5828,14 @@ gdbtypes_post_init (struct gdbarch *gdbarch)\n     = arch_integer_type (gdbarch, 128, 0, \"int128_t\");\n   builtin_type->builtin_uint128\n     = arch_integer_type (gdbarch, 128, 1, \"uint128_t\");\n-  TYPE_INSTANCE_FLAGS (builtin_type->builtin_int8) |=\n-    TYPE_INSTANCE_FLAG_NOTTEXT;\n-  TYPE_INSTANCE_FLAGS (builtin_type->builtin_uint8) |=\n-    TYPE_INSTANCE_FLAG_NOTTEXT;\n+\n+  builtin_type->builtin_int8->set_instance_flags\n+    (builtin_type->builtin_int8->instance_flags ()\n+     | TYPE_INSTANCE_FLAG_NOTTEXT);\n+\n+  builtin_type->builtin_uint8->set_instance_flags\n+    (builtin_type->builtin_uint8->instance_flags ()\n+     | TYPE_INSTANCE_FLAG_NOTTEXT);\n \n   /* Wide character types.  */\n   builtin_type->builtin_char16"
    },
    {
      "sha": "cdd136ef52524c48efae2fa63bcbfa6151d7532f",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 20,
      "deletions": 6,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -963,6 +963,18 @@ struct type\n     this->field (0).set_type (index_type);\n   }\n \n+  /* Return the instance flags converted to the correct type.  */\n+  const type_instance_flags instance_flags () const\n+  {\n+    return (enum type_instance_flag_value) this->m_instance_flags;\n+  }\n+\n+  /* Set the instance flags.  */\n+  void set_instance_flags (type_instance_flags flags)\n+  {\n+    this->m_instance_flags = flags;\n+  }\n+\n   /* Get the bounds bounds of this type.  The type must be a range type.  */\n   range_bounds *bounds () const\n   {\n@@ -1212,7 +1224,7 @@ struct type\n      instance flags are completely inherited from the target type.  No\n      qualifiers can be cleared by the typedef.  See also\n      check_typedef.  */\n-  unsigned instance_flags : 9;\n+  unsigned m_instance_flags : 9;\n \n   /* * Length of storage for a value of this type.  The value is the\n      expression in host bytes of what sizeof(type) would return.  This\n@@ -1672,7 +1684,7 @@ extern void allocate_gnat_aux_type (struct type *);\n      TYPE_ZALLOC (type,\t\t\t\t\t\t\t       \\\n \t\t  sizeof (*TYPE_MAIN_TYPE (type)->type_specific.func_stuff)))\n \n-#define TYPE_INSTANCE_FLAGS(thistype) (thistype)->instance_flags\n+#define TYPE_INSTANCE_FLAGS(thistype) ((thistype)->instance_flags ())\n #define TYPE_MAIN_TYPE(thistype) (thistype)->main_type\n #define TYPE_TARGET_TYPE(thistype) TYPE_MAIN_TYPE(thistype)->target_type\n #define TYPE_POINTER_TYPE(thistype) (thistype)->pointer_type\n@@ -2205,12 +2217,14 @@ extern struct type *make_atomic_type (struct type *);\n \n extern void replace_type (struct type *, struct type *);\n \n-extern int address_space_name_to_int (struct gdbarch *, const char *);\n+extern type_instance_flags address_space_name_to_int (struct gdbarch *,\n+\t\t\t\t\t\t      const char *);\n \n-extern const char *address_space_int_to_name (struct gdbarch *, int);\n+extern const char *address_space_int_to_name (struct gdbarch *,\n+\t\t\t\t\t      type_instance_flags);\n \n-extern struct type *make_type_with_address_space (struct type *type, \n-\t\t\t\t\t\t  int space_identifier);\n+extern struct type *make_type_with_address_space\n+  (struct type *type, type_instance_flags space_identifier);\n \n extern struct type *lookup_memberptr_type (struct type *, struct type *);\n "
    },
    {
      "sha": "b95c8c13594c5bd612dcbd16e0ebd34b0dc84d6a",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -1583,7 +1583,7 @@ s390_addr_bits_remove (struct gdbarch *gdbarch, CORE_ADDR addr)\n /* Implement addr_class_type_flags gdbarch method.\n    Only used for ABI_LINUX_ZSERIES.  */\n \n-static int\n+static type_instance_flags\n s390_address_class_type_flags (int byte_size, int dwarf2_addr_class)\n {\n   if (byte_size == 4)\n@@ -1596,7 +1596,8 @@ s390_address_class_type_flags (int byte_size, int dwarf2_addr_class)\n    Only used for ABI_LINUX_ZSERIES.  */\n \n static const char *\n-s390_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)\n+s390_address_class_type_flags_to_name (struct gdbarch *gdbarch,\n+\t\t\t\t       type_instance_flags type_flags)\n {\n   if (type_flags & TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1)\n     return \"mode32\";\n@@ -1607,18 +1608,18 @@ s390_address_class_type_flags_to_name (struct gdbarch *gdbarch, int type_flags)\n /* Implement addr_class_name_to_type_flags gdbarch method.\n    Only used for ABI_LINUX_ZSERIES.  */\n \n-static int\n+static bool\n s390_address_class_name_to_type_flags (struct gdbarch *gdbarch,\n \t\t\t\t       const char *name,\n-\t\t\t\t       int *type_flags_ptr)\n+\t\t\t\t       type_instance_flags *type_flags_ptr)\n {\n   if (strcmp (name, \"mode32\") == 0)\n     {\n       *type_flags_ptr = TYPE_INSTANCE_FLAG_ADDRESS_CLASS_1;\n-      return 1;\n+      return true;\n     }\n   else\n-    return 0;\n+    return false;\n }\n \n /* Inferior function calls.  */"
    },
    {
      "sha": "02fc8ccfd2b41342dcc9d23ec9840a884dec395a",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -4398,7 +4398,7 @@ cleanup_undefined_types_noname (struct objfile *objfile)\n              and needs to be copied over from the reference type.\n              Since replace_type expects them to be identical, we need\n              to set these flags manually before hand.  */\n-          TYPE_INSTANCE_FLAGS (nat.type) = TYPE_INSTANCE_FLAGS (*type);\n+          nat.type->set_instance_flags ((*type)->instance_flags ());\n           replace_type (nat.type, *type);\n         }\n     }"
    },
    {
      "sha": "608142c849460d10d9999b882cf22a0feb02b1f3",
      "filename": "gdb/type-stack.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/type-stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/314ad88df63c26a986e1ecd18bfe1de81a3cc0fb/gdb/type-stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/type-stack.c?ref=314ad88df63c26a986e1ecd18bfe1de81a3cc0fb",
      "patch": "@@ -109,7 +109,7 @@ type_stack::follow_types (struct type *follow_type)\n   int done = 0;\n   int make_const = 0;\n   int make_volatile = 0;\n-  int make_addr_space = 0;\n+  type_instance_flags make_addr_space = 0;\n   bool make_restrict = false;\n   bool make_atomic = false;\n   int array_size;\n@@ -128,7 +128,7 @@ type_stack::follow_types (struct type *follow_type)\n \tmake_volatile = 1;\n \tbreak;\n       case tp_space_identifier:\n-\tmake_addr_space = pop_int ();\n+\tmake_addr_space = (enum type_instance_flag_value) pop_int ();\n \tbreak;\n       case tp_atomic:\n \tmake_atomic = true;"
    }
  ]
}