{
  "sha": "78c1c35437a013c63acbff6926ff8d254e283d69",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzhjMWMzNTQzN2EwMTNjNjNhY2JmZjY5MjZmZjhkMjU0ZTI4M2Q2OQ==",
  "commit": {
    "author": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-05-28T14:53:54Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-05-28T19:52:31Z"
    },
    "message": "cpu,opcodes: add instruction semantics to bpf.cpu and minor fixes\n\nThis patch adds semantic RTL descriptions to the eBPF instructions\ndefined in cpu/bpf.cpu.  It also contains a couple of minor\nimprovements.\n\nTested in bpf-unknown-none targets.\nNo regressions.\n\ncpu/ChangeLog:\n\n2020-05-28  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\t    David Faust <david.faust@oracle.com>\n\n\t* bpf.cpu (define-alu-insn-un): Add definitions of semantics.\n\t(define-alu-insn-mov): Likewise.\n\t(daib): Likewise.\n\t(define-alu-instructions): Likewise.\n\t(define-endian-insn): Likewise.\n\t(define-lddw): Likewise.\n\t(dlabs): Likewise.\n\t(dlind): Likewise.\n\t(dxli): Likewise.\n\t(dxsi): Likewise.\n\t(dsti): Likewise.\n\t(define-ldstx-insns): Likewise.\n\t(define-st-insns): Likewise.\n\t(define-cond-jump-insn): Likewise.\n\t(dcji): Likewise.\n\t(define-condjump-insns): Likewise.\n\t(define-call-insn): Likewise.\n\t(ja): Likewise.\n\t(\"exit\"): Likewise.\n\t(define-atomic-insns): Likewise.\n\t(sem-exchange-and-add): New macro.\n\t* bpf.cpu (\"brkpt\"): New instruction.\n\t(bpfbf): Set word-bitsize to 32 and insn-endian big.\n\t(h-gpr): Prefer r0 to `a' and r6 to `ctx'.\n\t(h-pc): Expand definition.\n\t* bpf.opc (bpf_print_insn): Set endian_code to BIG.\n\nopcodes/ChangeLog:\n\n2020-05-28  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\t    David Faust <david.faust@oracle.com>\n\n\t* bpf-desc.c: Regenerate.\n\t* bpf-opc.h: Likewise.\n\t* bpf-opc.c: Likewise.\n\t* bpf-dis.c: Likewise.",
    "tree": {
      "sha": "96a630975112891435c7b7dc926c75d1204ccbc0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/96a630975112891435c7b7dc926c75d1204ccbc0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/78c1c35437a013c63acbff6926ff8d254e283d69",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78c1c35437a013c63acbff6926ff8d254e283d69",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/78c1c35437a013c63acbff6926ff8d254e283d69",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78c1c35437a013c63acbff6926ff8d254e283d69/comments",
  "author": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "989ade05525047fc6b94f24ece5fc09e076027b0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/989ade05525047fc6b94f24ece5fc09e076027b0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/989ade05525047fc6b94f24ece5fc09e076027b0"
    }
  ],
  "stats": {
    "total": 810,
    "additions": 515,
    "deletions": 295
  },
  "files": [
    {
      "sha": "30b884c9512ace0e52d9f6f1b12a727d8e506929",
      "filename": "cpu/ChangeLog",
      "status": "modified",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78c1c35437a013c63acbff6926ff8d254e283d69/cpu/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78c1c35437a013c63acbff6926ff8d254e283d69/cpu/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/ChangeLog?ref=78c1c35437a013c63acbff6926ff8d254e283d69",
      "patch": "@@ -1,3 +1,33 @@\n+2020-05-28  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\t    David Faust <david.faust@oracle.com>\n+\n+\t* bpf.cpu (define-alu-insn-un): Add definitions of semantics.\n+\t(define-alu-insn-mov): Likewise.\n+\t(daib): Likewise.\n+\t(define-alu-instructions): Likewise.\n+\t(define-endian-insn): Likewise.\n+\t(define-lddw): Likewise.\n+\t(dlabs): Likewise.\n+\t(dlind): Likewise.\n+\t(dxli): Likewise.\n+\t(dxsi): Likewise.\n+\t(dsti): Likewise.\n+\t(define-ldstx-insns): Likewise.\n+\t(define-st-insns): Likewise.\n+\t(define-cond-jump-insn): Likewise.\n+\t(dcji): Likewise.\n+\t(define-condjump-insns): Likewise.\n+\t(define-call-insn): Likewise.\n+\t(ja): Likewise.\n+\t(\"exit\"): Likewise.\n+\t(define-atomic-insns): Likewise.\n+\t(sem-exchange-and-add): New macro.\n+\t* bpf.cpu (\"brkpt\"): New instruction.\n+\t(bpfbf): Set word-bitsize to 32 and insn-endian big.\n+\t(h-gpr): Prefer r0 to `a' and r6 to `ctx'.\n+\t(h-pc): Expand definition.\n+\t* bpf.opc (bpf_print_insn): Set endian_code to BIG.\n+\n 2020-05-21  Alan Modra  <amodra@gmail.com>\n \n \t* mep.opc (mep_cgen_expand_macros_and_parse_operand): Replace"
    },
    {
      "sha": "47d7cb0f1580b4ece1c0b831ad2dddfe73fd2328",
      "filename": "cpu/bpf.cpu",
      "status": "modified",
      "additions": 241,
      "deletions": 91,
      "changes": 332,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78c1c35437a013c63acbff6926ff8d254e283d69/cpu/bpf.cpu",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78c1c35437a013c63acbff6926ff8d254e283d69/cpu/bpf.cpu",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/bpf.cpu?ref=78c1c35437a013c63acbff6926ff8d254e283d69",
      "patch": "@@ -32,6 +32,10 @@\n   (name bpf)\n   (comment \"Linux kernel BPF\")\n   (insn-lsb0? #t)\n+  ;; XXX explain the default-alignment setting is for the simulator.\n+  ;; It is confusing that the simulator follows the emulated memory\n+  ;; access conventions for fetching instructions by pieces...\n+  (default-alignment unaligned)\n   (machs bpf)\n   (isas ebpfle ebpfbe))\n \n@@ -121,7 +125,8 @@\n (define-cpu\n   (name bpfbf)\n   (comment \"Linux kernel eBPF virtual CPU\")\n-  (word-bitsize 32))\n+  (insn-endian big)\n+  (word-bitsize 64))\n \n (define-mach\n   (name bpf)\n@@ -159,13 +164,19 @@\n             (r0 0) (r1 1) (r2 2) (r3 3) (r4 4) (r5 5) (r6 6)\n             (r7 7) (r8 8) (r9 9) (fp 10)\n             ;; Additional names recognized when assembling.\n-            (a 0) (ctx 6) (r10 10))))\n+            (r0 0) (r6 6) (r10 10))))\n \n ;; The program counter.  CGEN requires it, even if it is not visible\n ;; to eBPF programs.\n \n-(dnh h-pc \"program counter\" (PC PROFILE) (pc) () () ())\n-\n+(define-hardware\n+  (name h-pc)\n+  (comment \"program counter\")\n+  (attrs PC PROFILE all-isas)\n+  (type pc UDI)\n+  (get () (raw-reg h-pc))\n+  (set (newval) (set (raw-reg h-pc) newval)))\n+  \n ;; A 64-bit h-sint to be used by the imm64 operand below.  XXX this\n ;; shouldn't be needed, as h-sint is supposed to be able to hold\n ;; 64-bit values.  However, in practice CGEN limits h-sint to 32 bits\n@@ -361,60 +372,101 @@\n ;;   ADD[32]{i,r}le for the little-endian ISA\n ;;   ADD[32]{i,r}be for the big-endian ISA\n ;;\n-;; The `i' variants perform `src OP dst -> dst' operations.\n-;; The `r' variants perform `dst OP imm32 -> dst' operations.\n+;; The `i' variants perform `dst OP imm32 -> dst' operations.\n+;; The `r' variants perform `dst OP src -> dst' operations.\n ;;\n ;; The variants with 32 in their name are of ALU class.  Otherwise\n ;; they are ALU64 class.\n \n-(define-pmacro (define-alu-insn-un x-basename x-suffix x-op-class x-op-code x-endian)\n+(define-pmacro (define-alu-insn-un x-basename x-suffix x-op-class x-op-code\n+                 x-endian x-mode x-semop)\n   (dni (.sym x-basename x-suffix x-endian)\n        (.str x-basename x-suffix)\n        ((ISA (.sym ebpf x-endian)))\n        (.str x-basename x-suffix \" $dst\" x-endian)\n        (+ (f-imm32 0) (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n-          x-op-class OP_SRC_K x-op-code) () ()))\n+          x-op-class OP_SRC_K x-op-code)\n+       (set x-mode (.sym dst x-endian) (x-semop x-mode (.sym dst x-endian)))\n+       ()))\n \n-(define-pmacro (define-alu-insn-bin x-basename x-suffix x-op-class x-op-code x-endian)\n+(define-pmacro (define-alu-insn-bin x-basename x-suffix x-op-class x-op-code\n+                 x-endian x-mode x-semop)\n   (begin\n+    ;; dst = dst OP immediate\n     (dni (.sym x-basename x-suffix \"i\" x-endian)\n          (.str x-basename x-suffix \" immediate\")\n          ((ISA (.sym ebpf x-endian)))\n          (.str x-basename x-suffix \" $dst\" x-endian \",$imm32\")\n          (+ imm32 (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n-            x-op-class OP_SRC_K x-op-code) () ())\n+            x-op-class OP_SRC_K x-op-code)\n+         (set x-mode (.sym dst x-endian) (x-semop x-mode (.sym dst x-endian) imm32))\n+         ())\n+    ;; dst = dst OP src\n     (dni (.sym x-basename x-suffix \"r\" x-endian)\n          (.str x-basename x-suffix \" register\")\n          ((ISA (.sym ebpf x-endian)))\n          (.str x-basename x-suffix \" $dst\" x-endian \",$src\" x-endian)\n          (+ (f-imm32 0) (f-offset16 0) (.sym src x-endian) (.sym dst x-endian)\n-            x-op-class OP_SRC_X x-op-code) () ())))\n+            x-op-class OP_SRC_X x-op-code)\n+         (set x-mode (.sym dst x-endian)\n+                      (x-semop x-mode (.sym dst x-endian) (.sym src x-endian)))\n+         ())))\n+\n+(define-pmacro (define-alu-insn-mov x-basename x-suffix x-op-class x-op-code\n+                 x-endian x-mode)\n+  (begin\n+    (dni (.sym mov x-suffix \"i\" x-endian)\n+         (.str mov x-suffix \" immediate\")\n+         ((ISA (.sym ebpf x-endian)))\n+         (.str x-basename x-suffix \" $dst\" x-endian \",$imm32\")\n+         (+ imm32 (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian)\n+            x-op-class OP_SRC_K x-op-code)\n+         (set x-mode (.sym dst x-endian) imm32)\n+         ())\n+    (dni (.sym mov x-suffix \"r\" x-endian)\n+         (.str mov x-suffix \" register\")\n+         ((ISA (.sym ebpf x-endian)))\n+         (.str x-basename x-suffix \" $dst\" x-endian \",$src\" x-endian)\n+         (+ (f-imm32 0) (f-offset16 0) (.sym src x-endian) (.sym dst x-endian)\n+            x-op-class OP_SRC_X x-op-code)\n+         (set x-mode (.sym dst x-endian) (.sym src x-endian))\n+         ())))\n+\n \n-(define-pmacro (daiu x-basename x-op-code x-endian)\n+;; Unary ALU instructions (neg)\n+(define-pmacro (daiu x-basename x-op-code x-endian x-semop)\n   (begin\n-    (define-alu-insn-un x-basename \"\" OP_CLASS_ALU64 x-op-code x-endian)\n-    (define-alu-insn-un x-basename \"32\" OP_CLASS_ALU x-op-code x-endian)))\n+    (define-alu-insn-un x-basename \"\" OP_CLASS_ALU64 x-op-code x-endian DI x-semop)\n+    (define-alu-insn-un x-basename \"32\" OP_CLASS_ALU x-op-code x-endian USI x-semop)))\n \n-(define-pmacro (daib x-basename x-op-code x-endian)\n+;; Binary ALU instructions (all the others)\n+;; For ALU32: DST = (u32) DST OP (u32) SRC is correct semantics\n+(define-pmacro (daib x-basename x-op-code x-endian x-semop)\n   (begin\n-    (define-alu-insn-bin x-basename \"\" OP_CLASS_ALU64 x-op-code x-endian)\n-    (define-alu-insn-bin x-basename \"32\" OP_CLASS_ALU x-op-code x-endian)))\n+    (define-alu-insn-bin x-basename \"\" OP_CLASS_ALU64 x-op-code x-endian DI x-semop)\n+    (define-alu-insn-bin x-basename \"32\" OP_CLASS_ALU x-op-code x-endian USI x-semop)))\n+\n+;; Move ALU instructions (mov)\n+(define-pmacro (daim x-basename x-op-code x-endian)\n+  (begin\n+    (define-alu-insn-mov x-basename \"\" OP_CLASS_ALU64 x-op-code x-endian DI)\n+    (define-alu-insn-mov x-basename \"32\" OP_CLASS_ALU x-op-code x-endian USI)))\n \n (define-pmacro (define-alu-instructions x-endian)\n   (begin\n-    (daib add OP_CODE_ADD x-endian)\n-    (daib sub OP_CODE_SUB x-endian)\n-    (daib mul OP_CODE_MUL x-endian)\n-    (daib div OP_CODE_DIV x-endian)\n-    (daib or  OP_CODE_OR x-endian)\n-    (daib and OP_CODE_AND x-endian)\n-    (daib lsh OP_CODE_LSH x-endian)\n-    (daib rsh OP_CODE_RSH x-endian)\n-    (daib mod OP_CODE_MOD x-endian)\n-    (daib xor OP_CODE_XOR x-endian)\n-    (daib mov OP_CODE_MOV x-endian)\n-    (daib arsh OP_CODE_ARSH x-endian)\n-    (daiu neg OP_CODE_NEG x-endian)))\n+    (daib add OP_CODE_ADD x-endian add)\n+    (daib sub OP_CODE_SUB x-endian sub)\n+    (daib mul OP_CODE_MUL x-endian mul)\n+    (daib div OP_CODE_DIV x-endian div)\n+    (daib or  OP_CODE_OR x-endian or)\n+    (daib and OP_CODE_AND x-endian and)\n+    (daib lsh OP_CODE_LSH x-endian sll)\n+    (daib rsh OP_CODE_RSH x-endian srl)\n+    (daib mod OP_CODE_MOD x-endian mod)\n+    (daib xor OP_CODE_XOR x-endian xor)\n+    (daib arsh OP_CODE_ARSH x-endian sra)\n+    (daiu neg OP_CODE_NEG x-endian neg)\n+    (daim mov OP_CODE_MOV x-endian)))\n \n (define-alu-instructions le)\n (define-alu-instructions be)\n@@ -438,7 +490,10 @@\n        ((ISA (.sym ebpf x-endian)))\n        (.str \"end\" x-suffix \" $dst\" x-endian \",$endsize\")\n        (+  (f-offset16 0) ((.sym f-src x-endian) 0) (.sym dst x-endian) endsize\n-           OP_CLASS_ALU x-op-src OP_CODE_END) () ()))\n+           OP_CLASS_ALU x-op-src OP_CODE_END)\n+       (set (.sym dst x-endian)\n+            (c-call DI \"bpfbf_end\" (.sym dst x-endian) endsize))\n+       ()))\n \n (define-endian-insn \"le\" OP_SRC_K le)\n (define-endian-insn \"be\" OP_SRC_X le)\n@@ -461,7 +516,9 @@\n        (.str \"lddw $dst\" x-endian \",$imm64\")\n        (+ imm64 (f-offset16 0) ((.sym f-src x-endian) 0)\n           (.sym dst x-endian)\n-          OP_CLASS_LD OP_SIZE_DW OP_MODE_IMM) () ()))\n+          OP_CLASS_LD OP_SIZE_DW OP_MODE_IMM)\n+       (set DI (.sym dst x-endian) imm64)\n+       ()))\n \n (define-lddw le)\n (define-lddw be)\n@@ -471,41 +528,71 @@\n ;;\n ;; LDABS{w,h,b,dw}\n \n-(define-pmacro (dlabs x-suffix x-size)\n+(define-pmacro (dlabs x-suffix x-size x-smode)\n   (dni (.sym \"ldabs\" x-suffix)\n        (.str \"ldabs\" x-suffix)\n        (all-isas)\n        (.str \"ldabs\" x-suffix \" $imm32\")\n        (+ imm32 (f-offset16 0) (f-regs 0)\n           OP_CLASS_LD OP_MODE_ABS (.sym OP_SIZE_ x-size))\n-       () ()))\n-\n-(dlabs \"w\" W)\n-(dlabs \"h\" H)\n-(dlabs \"b\" B)\n-(dlabs \"dw\" DW)\n+       (set x-smode\n+            (reg x-smode h-gpr 0)\n+            (mem x-smode\n+                 (add DI\n+                      (mem DI\n+                           (add DI\n+                                (reg DI h-gpr 6) ;; Pointer to struct sk_buff\n+                                (const DI 0)))   ;; XXX offsetof\n+                      ;; (struct sk_buff, data) XXX but the offset\n+                      ;; depends on CONFIG_* options, so this should\n+                      ;; be configured in the simulator and driven by\n+                      ;; command-line options.  Handle with a c-call.\n+                      imm32)))\n+       ;; XXX this clobbers R1-R5\n+       ()))\n+\n+(dlabs \"w\" W SI)\n+(dlabs \"h\" H HI)\n+(dlabs \"b\" B QI)\n+(dlabs \"dw\" DW DI)\n \n ;; The indirect load instructions are non-generic loads designed to be\n ;; used in socket filters.  They come in several variants:\n ;;\n ;; LDIND{w,h,b,dw}le for the little-endian ISA\n ;; LDIND[w,h,b,dw}be for the big-endian ISA\n \n-(define-pmacro (dlind x-suffix x-size x-endian)\n+(define-pmacro (dlind x-suffix x-size x-endian x-smode)\n   (dni (.sym \"ldind\" x-suffix x-endian)\n        (.str \"ldind\" x-suffix)\n        ((ISA (.sym ebpf x-endian)))\n        (.str \"ldind\" x-suffix \" $src\" x-endian \",$imm32\")\n        (+ imm32 (f-offset16 0) ((.sym f-dst x-endian) 0) (.sym src x-endian)\n           OP_CLASS_LD OP_MODE_IND (.sym OP_SIZE_ x-size))\n-       () ()))\n+       (set x-smode\n+            (reg x-smode h-gpr 0)\n+            (mem x-smode\n+                 (add DI\n+                      (mem DI\n+                           (add DI\n+                                (reg DI h-gpr 6) ;; Pointer to struct sk_buff\n+                                (const DI 0)))   ;; XXX offsetof\n+                      ;; (struct sk_buff, data) XXX but the offset\n+                      ;; depends on CONFIG_* options, so this should\n+                      ;; be configured in the simulator and driven by\n+                      ;; command-line options.  Handle with a c-call.\n+                      (add DI\n+                           (.sym src x-endian)\n+                           imm32))))\n+       ;; XXX this clobbers R1-R5\n+       ()))\n \n (define-pmacro (define-ldind x-endian)\n   (begin    \n-    (dlind \"w\" W x-endian)\n-    (dlind \"h\" H x-endian)\n-    (dlind \"b\" B x-endian)\n-    (dlind \"dw\" DW x-endian)))\n+    (dlind \"w\" W x-endian SI)\n+    (dlind \"h\" H x-endian HI)\n+    (dlind \"b\" B x-endian QI)\n+    (dlind \"dw\" DW x-endian DI)))\n \n (define-ldind le)\n (define-ldind be)\n@@ -520,35 +607,41 @@\n ;; Loads operate on [$SRC+-OFFSET] -> $DST\n ;; Stores operate on $SRC -> [$DST+-OFFSET]\n \n-(define-pmacro (dxli x-basename x-suffix x-size x-endian)\n+(define-pmacro (dxli x-basename x-suffix x-size x-endian x-mode)\n   (dni (.sym x-basename x-suffix x-endian)\n        (.str x-basename x-suffix)\n        ((ISA (.sym ebpf x-endian)))\n        (.str x-basename x-suffix \" $dst\" x-endian \",[$src\" x-endian \"+$offset16]\")\n        (+ (f-imm32 0) offset16 (.sym src x-endian) (.sym dst x-endian)\n           OP_CLASS_LDX (.sym OP_SIZE_ x-size) OP_MODE_MEM)\n-       () ()))\n+       (set x-mode\n+            (.sym dst x-endian)\n+            (mem x-mode (add DI (.sym src x-endian) (ext DI (trunc HI offset16)))))\n+       ()))\n \n-(define-pmacro (dxsi x-basename x-suffix x-size x-endian)\n+(define-pmacro (dxsi x-basename x-suffix x-size x-endian x-mode)\n   (dni (.sym x-basename x-suffix x-endian)\n        (.str x-basename x-suffix)\n        ((ISA (.sym ebpf x-endian)))\n        (.str x-basename x-suffix \" [$dst\" x-endian \"+$offset16],$src\" x-endian)\n        (+ (f-imm32 0) offset16 (.sym src x-endian) (.sym dst x-endian)\n           OP_CLASS_STX (.sym OP_SIZE_ x-size) OP_MODE_MEM)\n-       () ()))\n+       (set x-mode\n+            (mem x-mode (add DI (.sym dst x-endian) (ext DI (trunc HI offset16))))\n+            (.sym src x-endian)) ;; XXX address is section-relative\n+       ()))\n \n (define-pmacro (define-ldstx-insns x-endian)\n   (begin\n-    (dxli \"ldx\" \"w\" W x-endian)\n-    (dxli \"ldx\" \"h\" H x-endian)\n-    (dxli \"ldx\" \"b\" B x-endian)\n-    (dxli \"ldx\" \"dw\" DW x-endian)\n+    (dxli \"ldx\" \"w\" W x-endian SI)\n+    (dxli \"ldx\" \"h\" H x-endian HI)\n+    (dxli \"ldx\" \"b\" B x-endian QI)\n+    (dxli \"ldx\" \"dw\" DW x-endian DI)\n \n-    (dxsi \"stx\" \"w\" W x-endian)\n-    (dxsi \"stx\" \"h\" H x-endian)\n-    (dxsi \"stx\" \"b\" B x-endian)\n-    (dxsi \"stx\" \"dw\" DW x-endian)))\n+    (dxsi \"stx\" \"w\" W x-endian SI)\n+    (dxsi \"stx\" \"h\" H x-endian HI)\n+    (dxsi \"stx\" \"b\" B x-endian QI)\n+    (dxsi \"stx\" \"dw\" DW x-endian DI)))\n \n (define-ldstx-insns le)\n (define-ldstx-insns be)\n@@ -559,20 +652,24 @@\n ;;  ST{b,h,w,dw}le for the little-endian ISA\n ;;  ST{b,h,w,dw}be for the big-endian ISA\n \n-(define-pmacro (dsti x-suffix x-size x-endian)\n+(define-pmacro (dsti x-suffix x-size x-endian x-mode)\n   (dni (.sym \"st\" x-suffix x-endian)\n        (.str \"st\" x-suffix)\n        ((ISA (.sym ebpf x-endian)))\n        (.str \"st\" x-suffix \" [$dst\" x-endian \"+$offset16],$imm32\")\n        (+ imm32 offset16 ((.sym f-src x-endian) 0) (.sym dst x-endian)\n-          OP_CLASS_ST (.sym OP_SIZE_ x-size) OP_MODE_MEM) () ()))\n+          OP_CLASS_ST (.sym OP_SIZE_ x-size) OP_MODE_MEM)\n+       (set x-mode\n+            (mem x-mode (add DI (.sym dst x-endian) offset16))\n+            imm32) ;; XXX address is section-relative\n+       ()))\n \n (define-pmacro (define-st-insns x-endian)\n   (begin\n-    (dsti \"b\" B x-endian)\n-    (dsti \"h\" H x-endian)\n-    (dsti \"w\" W x-endian)\n-    (dsti \"dw\" DW x-endian)))\n+    (dsti \"b\" B x-endian QI)\n+    (dsti \"h\" H x-endian HI)\n+    (dsti \"w\" W x-endian SI)\n+    (dsti \"dw\" DW x-endian DI)))\n \n (define-st-insns le)\n (define-st-insns be)\n@@ -588,78 +685,131 @@\n ;;   J{eq,gt,ge,lt,le,set,ne.sgt,sge,slt,sle}[32]{i,r}be for the\n ;;   big-endian ISA.\n \n-(define-pmacro (define-cond-jump-insn x-cond x-suffix x-op-class x-op-code x-endian)\n+(define-pmacro (define-cond-jump-insn x-cond x-suffix x-op-class x-op-code x-endian x-mode x-semop)\n   (begin\n     (dni (.sym j x-cond x-suffix i x-endian)\n          (.str j x-cond x-suffix \" i\")\n          ((ISA (.sym ebpf x-endian)))\n          (.str \"j\" x-cond x-suffix \" $dst\" x-endian \",$imm32,$disp16\")\n          (+ imm32 disp16 ((.sym f-src x-endian) 0) (.sym dst x-endian)\n-            x-op-class OP_SRC_K (.sym OP_CODE_ x-op-code)) () ())\n+            x-op-class OP_SRC_K (.sym OP_CODE_ x-op-code))\n+         (if VOID (x-semop x-mode (.sym dst x-endian) imm32)\n+             (set DI\n+                  (reg DI h-pc) (add DI (reg DI h-pc)\n+                                     (mul DI (add HI disp16 1) 8))))\n+         ())\n     (dni (.sym j x-cond x-suffix r x-endian)\n          (.str j x-cond x-suffix \" r\")\n          ((ISA (.sym ebpf x-endian)))\n          (.str \"j\" x-cond x-suffix \" $dst\" x-endian \",$src\" x-endian \",$disp16\")\n          (+ (f-imm32 0) disp16 (.sym src x-endian) (.sym dst x-endian)\n-            x-op-class OP_SRC_X (.sym OP_CODE_ x-op-code)) () ())))\n-\n-(define-pmacro (dcji x-cond x-op-code x-endian)\n+            x-op-class OP_SRC_X (.sym OP_CODE_ x-op-code))\n+         (if VOID (x-semop x-mode (.sym dst x-endian) (.sym src x-endian))\n+             (set DI\n+                  (reg DI h-pc) (add DI (reg DI h-pc)\n+                                     (mul DI (add HI disp16 1) 8))))\n+         ())))\n+\n+(define-pmacro (dcji x-cond x-op-code x-endian x-semop)\n   (begin\n-    (define-cond-jump-insn x-cond \"\" OP_CLASS_JMP x-op-code x-endian)\n-    (define-cond-jump-insn x-cond \"32\" OP_CLASS_JMP32 x-op-code x-endian)))\n+    (define-cond-jump-insn x-cond \"\" OP_CLASS_JMP x-op-code x-endian DI x-semop)\n+    (define-cond-jump-insn x-cond \"32\" OP_CLASS_JMP32 x-op-code x-endian SI x-semop )))\n \n (define-pmacro (define-condjump-insns x-endian)\n   (begin\n-    (dcji \"eq\" JEQ x-endian)\n-    (dcji \"gt\" JGT x-endian)\n-    (dcji \"ge\" JGE x-endian)\n-    (dcji \"lt\" JLT x-endian)\n-    (dcji \"le\" JLE x-endian)\n-    (dcji \"set\" JSET x-endian)\n-    (dcji \"ne\" JNE x-endian)\n-    (dcji \"sgt\" JSGT x-endian)\n-    (dcji \"sge\" JSGE x-endian)\n-    (dcji \"slt\" JSLT x-endian)\n-    (dcji \"sle\" JSLE x-endian)))\n+    (dcji \"eq\" JEQ x-endian eq)\n+    (dcji \"gt\" JGT x-endian gtu)\n+    (dcji \"ge\" JGE x-endian geu)\n+    (dcji \"lt\" JLT x-endian ltu)\n+    (dcji \"le\" JLE x-endian leu)\n+    (dcji \"set\" JSET x-endian and)\n+    (dcji \"ne\" JNE x-endian ne)\n+    (dcji \"sgt\" JSGT x-endian gt)\n+    (dcji \"sge\" JSGE x-endian ge)\n+    (dcji \"slt\" JSLT x-endian lt)\n+    (dcji \"sle\" JSLE x-endian le)))\n \n (define-condjump-insns le)\n (define-condjump-insns be)\n \n-;; The jump-always, `call' and `exit' instructions dont make use of\n-;; either source nor destination registers, so only one variant per\n+;; The `call' instruction doesn't make use of registers, but the\n+;; semantic routine should have access to the src register in order to\n+;; properly interpret the meaning of disp32.  Therefore we need one\n+;; version per ISA.\n+\n+(define-pmacro (define-call-insn x-endian)\n+  (dni (.sym call x-endian)\n+       \"call\"\n+       ((ISA (.sym ebpf x-endian)))\n+       \"call $disp32\"\n+       (+ disp32 (f-offset16 0) (f-regs 0)\n+          OP_CLASS_JMP OP_SRC_K OP_CODE_CALL)\n+       (c-call VOID\n+               \"bpfbf_call\" disp32 (ifield (.sym f-src x-endian)))\n+       ()))\n+\n+(define-call-insn le)\n+(define-call-insn be)\n+\n+;; The jump-always and `exit' instructions dont make use of either\n+;; source nor destination registers, so only one variant per\n ;; instruction is defined.\n \n (dni ja \"ja\" (all-isas) \"ja $disp16\"\n      (+ (f-imm32 0) disp16 (f-regs 0)\n-        OP_CLASS_JMP OP_SRC_K OP_CODE_JA) () ())\n-\n-(dni call \"call\" (all-isas) \"call $disp32\"\n-     (+ disp32 (f-offset16 0) (f-regs 0)\n-        OP_CLASS_JMP OP_SRC_K OP_CODE_CALL) () ())\n+        OP_CLASS_JMP OP_SRC_K OP_CODE_JA)\n+     (set DI (reg DI h-pc) (add DI (reg DI h-pc)\n+                                (mul DI (add HI disp16 1) 8)))\n+     ())\n \n (dni \"exit\" \"exit\" (all-isas) \"exit\"\n      (+ (f-imm32 0) (f-offset16 0) (f-regs 0)\n-        OP_CLASS_JMP (f-op-src 0) OP_CODE_EXIT) () ())\n+        OP_CLASS_JMP (f-op-src 0) OP_CODE_EXIT)\n+     (c-call VOID \"bpfbf_exit\")\n+     ())\n \n ;;; Atomic instructions\n \n ;; The atomic exchange-and-add instructions come in two flavors: one\n ;; for swapping 64-bit quantities and another for 32-bit quantities.\n \n+(define-pmacro (sem-exchange-and-add x-endian x-mode)\n+  (sequence VOID ((x-mode tmp))\n+            ;; XXX acquire lock in simulator...  as a hardware element?\n+            (set x-mode tmp (mem x-mode (add DI (.sym dst x-endian) offset16)))\n+            (set x-mode\n+                 (mem x-mode (add DI (.sym dst x-endian) offset16))\n+                 (add x-mode tmp (.sym src x-endian)))))\n+\n (define-pmacro (define-atomic-insns x-endian)\n   (begin\n     (dni (.str \"xadddw\" x-endian)\n          \"xadddw\"\n          ((ISA (.sym ebpf x-endian)))\n          (.str \"xadddw [$dst\" x-endian \"+$offset16],$src\" x-endian)\n          (+ (f-imm32 0) (.sym src x-endian) (.sym dst x-endian)\n-            offset16 OP_MODE_XADD OP_SIZE_DW OP_CLASS_STX) () ())\n+            offset16 OP_MODE_XADD OP_SIZE_DW OP_CLASS_STX)\n+         (sem-exchange-and-add x-endian DI)\n+         ())\n     (dni (.str \"xaddw\" x-endian)\n          \"xaddw\"\n          ((ISA (.sym ebpf x-endian)))\n          (.str \"xaddw [$dst\" x-endian \"+$offset16],$src\" x-endian)\n          (+ (f-imm32 0) (.sym src x-endian) (.sym dst x-endian)\n-            offset16 OP_MODE_XADD OP_SIZE_W OP_CLASS_STX) () ())))\n+            offset16 OP_MODE_XADD OP_SIZE_W OP_CLASS_STX)\n+         (sem-exchange-and-add x-endian SI)\n+         ())))\n \n (define-atomic-insns le)\n (define-atomic-insns be)\n+\n+;;; Breakpoint instruction\n+\n+;; The brkpt instruction is used by the BPF simulator and it doesn't\n+;; really belong to the eBPF instruction set.\n+\n+(dni \"brkpt\" \"brkpt\" (all-isas)  \"brkpt\"\n+     (+ (f-imm32 0) (f-offset16 0) (f-regs 0)\n+        OP_CLASS_ALU OP_SRC_X OP_CODE_NEG)\n+     (c-call VOID \"bpfbf_breakpoint\")\n+     ())"
    },
    {
      "sha": "e2acaa4341ca1b68dffbe8f0ccf8198a4942702e",
      "filename": "cpu/bpf.opc",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78c1c35437a013c63acbff6926ff8d254e283d69/cpu/bpf.opc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78c1c35437a013c63acbff6926ff8d254e283d69/cpu/bpf.opc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/bpf.opc?ref=78c1c35437a013c63acbff6926ff8d254e283d69",
      "patch": "@@ -129,6 +129,7 @@ bpf_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)\n \n   info->bytes_per_chunk = 1;\n   info->bytes_per_line = 8;\n+  info->endian_code = BFD_ENDIAN_BIG;\n \n   /* Attempt to read the base part of the insn.  */\n   buflen = cd->base_insn_bitsize / 8;"
    },
    {
      "sha": "15405a52157431030cc8ffe0771f5e658a774289",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=78c1c35437a013c63acbff6926ff8d254e283d69",
      "patch": "@@ -1,3 +1,11 @@\n+2020-05-28  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\t    David Faust <david.faust@oracle.com>\n+\n+\t* bpf-desc.c: Regenerate.\n+\t* bpf-opc.h: Likewise.\n+\t* bpf-opc.c: Likewise.\n+\t* bpf-dis.c: Likewise.\n+\n 2020-05-28  Alan Modra  <amodra@gmail.com>\n \n \t* nios2-dis.c (nios2_print_insn_arg): Avoid shift left of negative"
    },
    {
      "sha": "ddd55b9fb65c5e92286d483a52113d3c2ce5f185",
      "filename": "opcodes/bpf-desc.c",
      "status": "modified",
      "additions": 158,
      "deletions": 140,
      "changes": 298,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/bpf-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/bpf-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-desc.c?ref=78c1c35437a013c63acbff6926ff8d254e283d69",
      "patch": "@@ -144,8 +144,8 @@ static CGEN_KEYWORD_ENTRY bpf_cgen_opval_h_gpr_entries[] =\n   { \"%r8\", 8, {0, {{{0, 0}}}}, 0, 0 },\n   { \"%r9\", 9, {0, {{{0, 0}}}}, 0, 0 },\n   { \"%fp\", 10, {0, {{{0, 0}}}}, 0, 0 },\n-  { \"%a\", 0, {0, {{{0, 0}}}}, 0, 0 },\n-  { \"%ctx\", 6, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r0\", 0, {0, {{{0, 0}}}}, 0, 0 },\n+  { \"%r6\", 6, {0, {{{0, 0}}}}, 0, 0 },\n   { \"%r10\", 10, {0, {{{0, 0}}}}, 0, 0 }\n };\n \n@@ -169,7 +169,7 @@ const CGEN_HW_ENTRY bpf_cgen_hw_table[] =\n   { \"h-addr\", HW_H_ADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n   { \"h-iaddr\", HW_H_IADDR, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n   { \"h-gpr\", HW_H_GPR, CGEN_ASM_KEYWORD, (PTR) & bpf_cgen_opval_h_gpr, { 0, { { { (1<<MACH_BPF), 0 } }, { { 1, \"\\xc0\" } } } } },\n-  { \"h-pc\", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PROFILE)|A(PC), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } },\n+  { \"h-pc\", HW_H_PC, CGEN_ASM_NONE, 0, { 0|A(PROFILE)|A(PC), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n   { \"h-sint64\", HW_H_SINT64, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } } },\n   { 0, 0, CGEN_ASM_NONE, 0, { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } } }\n };\n@@ -494,26 +494,6 @@ static const CGEN_IBASE bpf_cgen_insn_table[MAX_INSNS] =\n     BPF_INSN_XOR32RLE, \"xor32rle\", \"xor32\", 64,\n     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n-/* mov $dstle,$imm32 */\n-  {\n-    BPF_INSN_MOVILE, \"movile\", \"mov\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n-  },\n-/* mov $dstle,$srcle */\n-  {\n-    BPF_INSN_MOVRLE, \"movrle\", \"mov\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n-  },\n-/* mov32 $dstle,$imm32 */\n-  {\n-    BPF_INSN_MOV32ILE, \"mov32ile\", \"mov32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n-  },\n-/* mov32 $dstle,$srcle */\n-  {\n-    BPF_INSN_MOV32RLE, \"mov32rle\", \"mov32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n-  },\n /* arsh $dstle,$imm32 */\n   {\n     BPF_INSN_ARSHILE, \"arshile\", \"arsh\", 64,\n@@ -544,6 +524,26 @@ static const CGEN_IBASE bpf_cgen_insn_table[MAX_INSNS] =\n     BPF_INSN_NEG32LE, \"neg32le\", \"neg32\", 64,\n     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n+/* mov $dstle,$imm32 */\n+  {\n+    BPF_INSN_MOVILE, \"movile\", \"mov\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mov $dstle,$srcle */\n+  {\n+    BPF_INSN_MOVRLE, \"movrle\", \"mov\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mov32 $dstle,$imm32 */\n+  {\n+    BPF_INSN_MOV32ILE, \"mov32ile\", \"mov32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n+/* mov32 $dstle,$srcle */\n+  {\n+    BPF_INSN_MOV32RLE, \"mov32rle\", \"mov32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+  },\n /* add $dstbe,$imm32 */\n   {\n     BPF_INSN_ADDIBE, \"addibe\", \"add\", 64,\n@@ -744,26 +744,6 @@ static const CGEN_IBASE bpf_cgen_insn_table[MAX_INSNS] =\n     BPF_INSN_XOR32RBE, \"xor32rbe\", \"xor32\", 64,\n     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n-/* mov $dstbe,$imm32 */\n-  {\n-    BPF_INSN_MOVIBE, \"movibe\", \"mov\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n-  },\n-/* mov $dstbe,$srcbe */\n-  {\n-    BPF_INSN_MOVRBE, \"movrbe\", \"mov\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n-  },\n-/* mov32 $dstbe,$imm32 */\n-  {\n-    BPF_INSN_MOV32IBE, \"mov32ibe\", \"mov32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n-  },\n-/* mov32 $dstbe,$srcbe */\n-  {\n-    BPF_INSN_MOV32RBE, \"mov32rbe\", \"mov32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n-  },\n /* arsh $dstbe,$imm32 */\n   {\n     BPF_INSN_ARSHIBE, \"arshibe\", \"arsh\", 64,\n@@ -794,6 +774,26 @@ static const CGEN_IBASE bpf_cgen_insn_table[MAX_INSNS] =\n     BPF_INSN_NEG32BE, \"neg32be\", \"neg32\", 64,\n     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n+/* mov $dstbe,$imm32 */\n+  {\n+    BPF_INSN_MOVIBE, \"movibe\", \"mov\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mov $dstbe,$srcbe */\n+  {\n+    BPF_INSN_MOVRBE, \"movrbe\", \"mov\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mov32 $dstbe,$imm32 */\n+  {\n+    BPF_INSN_MOV32IBE, \"mov32ibe\", \"mov32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* mov32 $dstbe,$srcbe */\n+  {\n+    BPF_INSN_MOV32RBE, \"mov32rbe\", \"mov32\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n /* endle $dstle,$endsize */\n   {\n     BPF_INSN_ENDLELE, \"endlele\", \"endle\", 64,\n@@ -1007,452 +1007,457 @@ static const CGEN_IBASE bpf_cgen_insn_table[MAX_INSNS] =\n /* jeq $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JEQILE, \"jeqile\", \"jeq\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jeq $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JEQRLE, \"jeqrle\", \"jeq\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jeq32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JEQ32ILE, \"jeq32ile\", \"jeq32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jeq32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JEQ32RLE, \"jeq32rle\", \"jeq32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jgt $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JGTILE, \"jgtile\", \"jgt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jgt $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JGTRLE, \"jgtrle\", \"jgt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jgt32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JGT32ILE, \"jgt32ile\", \"jgt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jgt32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JGT32RLE, \"jgt32rle\", \"jgt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jge $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JGEILE, \"jgeile\", \"jge\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jge $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JGERLE, \"jgerle\", \"jge\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jge32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JGE32ILE, \"jge32ile\", \"jge32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jge32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JGE32RLE, \"jge32rle\", \"jge32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jlt $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JLTILE, \"jltile\", \"jlt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jlt $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JLTRLE, \"jltrle\", \"jlt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jlt32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JLT32ILE, \"jlt32ile\", \"jlt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jlt32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JLT32RLE, \"jlt32rle\", \"jlt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jle $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JLEILE, \"jleile\", \"jle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jle $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JLERLE, \"jlerle\", \"jle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jle32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JLE32ILE, \"jle32ile\", \"jle32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jle32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JLE32RLE, \"jle32rle\", \"jle32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jset $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSETILE, \"jsetile\", \"jset\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jset $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSETRLE, \"jsetrle\", \"jset\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jset32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSET32ILE, \"jset32ile\", \"jset32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jset32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSET32RLE, \"jset32rle\", \"jset32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jne $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JNEILE, \"jneile\", \"jne\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jne $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JNERLE, \"jnerle\", \"jne\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jne32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JNE32ILE, \"jne32ile\", \"jne32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jne32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JNE32RLE, \"jne32rle\", \"jne32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsgt $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGTILE, \"jsgtile\", \"jsgt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsgt $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSGTRLE, \"jsgtrle\", \"jsgt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsgt32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGT32ILE, \"jsgt32ile\", \"jsgt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsgt32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSGT32RLE, \"jsgt32rle\", \"jsgt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsge $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGEILE, \"jsgeile\", \"jsge\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsge $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSGERLE, \"jsgerle\", \"jsge\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsge32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGE32ILE, \"jsge32ile\", \"jsge32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsge32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSGE32RLE, \"jsge32rle\", \"jsge32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jslt $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLTILE, \"jsltile\", \"jslt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jslt $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSLTRLE, \"jsltrle\", \"jslt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jslt32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLT32ILE, \"jslt32ile\", \"jslt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jslt32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSLT32RLE, \"jslt32rle\", \"jslt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsle $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLEILE, \"jsleile\", \"jsle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsle $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSLERLE, \"jslerle\", \"jsle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsle32 $dstle,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLE32ILE, \"jsle32ile\", \"jsle32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jsle32 $dstle,$srcle,$disp16 */\n   {\n     BPF_INSN_JSLE32RLE, \"jsle32rle\", \"jsle32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* jeq $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JEQIBE, \"jeqibe\", \"jeq\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jeq $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JEQRBE, \"jeqrbe\", \"jeq\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jeq32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JEQ32IBE, \"jeq32ibe\", \"jeq32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jeq32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JEQ32RBE, \"jeq32rbe\", \"jeq32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jgt $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JGTIBE, \"jgtibe\", \"jgt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jgt $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JGTRBE, \"jgtrbe\", \"jgt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jgt32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JGT32IBE, \"jgt32ibe\", \"jgt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jgt32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JGT32RBE, \"jgt32rbe\", \"jgt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jge $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JGEIBE, \"jgeibe\", \"jge\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jge $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JGERBE, \"jgerbe\", \"jge\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jge32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JGE32IBE, \"jge32ibe\", \"jge32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jge32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JGE32RBE, \"jge32rbe\", \"jge32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jlt $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JLTIBE, \"jltibe\", \"jlt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jlt $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JLTRBE, \"jltrbe\", \"jlt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jlt32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JLT32IBE, \"jlt32ibe\", \"jlt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jlt32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JLT32RBE, \"jlt32rbe\", \"jlt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jle $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JLEIBE, \"jleibe\", \"jle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jle $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JLERBE, \"jlerbe\", \"jle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jle32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JLE32IBE, \"jle32ibe\", \"jle32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jle32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JLE32RBE, \"jle32rbe\", \"jle32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jset $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSETIBE, \"jsetibe\", \"jset\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jset $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSETRBE, \"jsetrbe\", \"jset\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jset32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSET32IBE, \"jset32ibe\", \"jset32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jset32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSET32RBE, \"jset32rbe\", \"jset32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jne $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JNEIBE, \"jneibe\", \"jne\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jne $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JNERBE, \"jnerbe\", \"jne\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jne32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JNE32IBE, \"jne32ibe\", \"jne32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jne32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JNE32RBE, \"jne32rbe\", \"jne32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsgt $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGTIBE, \"jsgtibe\", \"jsgt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsgt $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSGTRBE, \"jsgtrbe\", \"jsgt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsgt32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGT32IBE, \"jsgt32ibe\", \"jsgt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsgt32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSGT32RBE, \"jsgt32rbe\", \"jsgt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsge $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGEIBE, \"jsgeibe\", \"jsge\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsge $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSGERBE, \"jsgerbe\", \"jsge\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsge32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSGE32IBE, \"jsge32ibe\", \"jsge32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsge32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSGE32RBE, \"jsge32rbe\", \"jsge32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jslt $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLTIBE, \"jsltibe\", \"jslt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jslt $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSLTRBE, \"jsltrbe\", \"jslt\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jslt32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLT32IBE, \"jslt32ibe\", \"jslt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jslt32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSLT32RBE, \"jslt32rbe\", \"jslt32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsle $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLEIBE, \"jsleibe\", \"jsle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsle $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSLERBE, \"jslerbe\", \"jsle\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsle32 $dstbe,$imm32,$disp16 */\n   {\n     BPF_INSN_JSLE32IBE, \"jsle32ibe\", \"jsle32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n /* jsle32 $dstbe,$srcbe,$disp16 */\n   {\n     BPF_INSN_JSLE32RBE, \"jsle32rbe\", \"jsle32\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+    { 0|A(COND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n-/* ja $disp16 */\n+/* call $disp32 */\n   {\n-    BPF_INSN_JA, \"ja\", \"ja\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    BPF_INSN_CALLLE, \"callle\", \"call\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x80\" } } } }\n   },\n /* call $disp32 */\n   {\n-    BPF_INSN_CALL, \"call\", \"call\", 64,\n-    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+    BPF_INSN_CALLBE, \"callbe\", \"call\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n+  },\n+/* ja $disp16 */\n+  {\n+    BPF_INSN_JA, \"ja\", \"ja\", 64,\n+    { 0|A(UNCOND_CTI), { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n   },\n /* exit */\n   {\n@@ -1479,6 +1484,11 @@ static const CGEN_IBASE bpf_cgen_insn_table[MAX_INSNS] =\n     BPF_INSN_XADDWBE, \"xaddwbe\", \"xaddw\", 64,\n     { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\x40\" } } } }\n   },\n+/* brkpt */\n+  {\n+    BPF_INSN_BRKPT, \"brkpt\", \"brkpt\", 64,\n+    { 0, { { { (1<<MACH_BASE), 0 } }, { { 1, \"\\xc0\" } } } }\n+  },\n };\n \n #undef OP\n@@ -1821,10 +1831,18 @@ bpf_cgen_cpu_close (CGEN_CPU_DESC cd)\n \t  regfree (CGEN_INSN_RX (insns));\n     }\n \n-  free ((CGEN_INSN *) cd->macro_insn_table.init_entries);\n-  free ((CGEN_INSN *) cd->insn_table.init_entries);\n-  free ((CGEN_HW_ENTRY *) cd->hw_table.entries);\n-  free ((CGEN_HW_ENTRY *) cd->operand_table.entries);\n+  if (cd->macro_insn_table.init_entries)\n+    free ((CGEN_INSN *) cd->macro_insn_table.init_entries);\n+\n+  if (cd->insn_table.init_entries)\n+    free ((CGEN_INSN *) cd->insn_table.init_entries);\n+\n+  if (cd->hw_table.entries)\n+    free ((CGEN_HW_ENTRY *) cd->hw_table.entries);\n+\n+  if (cd->operand_table.entries)\n+    free ((CGEN_HW_ENTRY *) cd->operand_table.entries);\n+\n   free (cd);\n }\n "
    },
    {
      "sha": "60e0d960c875db1bde5a5902b2dab2ae91876dc5",
      "filename": "opcodes/bpf-dis.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/bpf-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/bpf-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-dis.c?ref=78c1c35437a013c63acbff6926ff8d254e283d69",
      "patch": "@@ -75,6 +75,7 @@ bpf_print_insn (CGEN_CPU_DESC cd, bfd_vma pc, disassemble_info *info)\n \n   info->bytes_per_chunk = 1;\n   info->bytes_per_line = 8;\n+  info->endian_code = BFD_ENDIAN_BIG;\n \n   /* Attempt to read the base part of the insn.  */\n   buflen = cd->base_insn_bitsize / 8;"
    },
    {
      "sha": "3ecd35d8bcef66f28b7548c5730e8c1689b75ca5",
      "filename": "opcodes/bpf-opc.c",
      "status": "modified",
      "additions": 66,
      "deletions": 54,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/bpf-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/bpf-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-opc.c?ref=78c1c35437a013c63acbff6926ff8d254e283d69",
      "patch": "@@ -133,11 +133,11 @@ static const CGEN_IFMT ifmt_jeqrbe ATTRIBUTE_UNUSED = {\n   8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_DSTBE) }, { F (F_OP_CODE) }, { F (F_SRCBE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n };\n \n-static const CGEN_IFMT ifmt_ja ATTRIBUTE_UNUSED = {\n+static const CGEN_IFMT ifmt_callle ATTRIBUTE_UNUSED = {\n   8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_REGS) }, { F (F_OP_CODE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n };\n \n-static const CGEN_IFMT ifmt_call ATTRIBUTE_UNUSED = {\n+static const CGEN_IFMT ifmt_ja ATTRIBUTE_UNUSED = {\n   8, 64, 0xff, { { F (F_IMM32) }, { F (F_OFFSET16) }, { F (F_REGS) }, { F (F_OP_CODE) }, { F (F_OP_SRC) }, { F (F_OP_CLASS) }, { 0 } }\n };\n \n@@ -400,30 +400,6 @@ static const CGEN_OPCODE bpf_cgen_insn_opcode_table[MAX_INSNS] =\n     { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n     & ifmt_addrle, { 0xac }\n   },\n-/* mov $dstle,$imm32 */\n-  {\n-    { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n-    & ifmt_addile, { 0xb7 }\n-  },\n-/* mov $dstle,$srcle */\n-  {\n-    { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n-    & ifmt_addrle, { 0xbf }\n-  },\n-/* mov32 $dstle,$imm32 */\n-  {\n-    { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n-    & ifmt_addile, { 0xb4 }\n-  },\n-/* mov32 $dstle,$srcle */\n-  {\n-    { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n-    & ifmt_addrle, { 0xbc }\n-  },\n /* arsh $dstle,$imm32 */\n   {\n     { 0, 0, 0, 0 },\n@@ -460,6 +436,30 @@ static const CGEN_OPCODE bpf_cgen_insn_opcode_table[MAX_INSNS] =\n     { { MNEM, ' ', OP (DSTLE), 0 } },\n     & ifmt_negle, { 0x84 }\n   },\n+/* mov $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0xb7 }\n+  },\n+/* mov $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xbf }\n+  },\n+/* mov32 $dstle,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (IMM32), 0 } },\n+    & ifmt_addile, { 0xb4 }\n+  },\n+/* mov32 $dstle,$srcle */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTLE), ',', OP (SRCLE), 0 } },\n+    & ifmt_addrle, { 0xbc }\n+  },\n /* add $dstbe,$imm32 */\n   {\n     { 0, 0, 0, 0 },\n@@ -700,30 +700,6 @@ static const CGEN_OPCODE bpf_cgen_insn_opcode_table[MAX_INSNS] =\n     { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n     & ifmt_addrbe, { 0xac }\n   },\n-/* mov $dstbe,$imm32 */\n-  {\n-    { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n-    & ifmt_addibe, { 0xb7 }\n-  },\n-/* mov $dstbe,$srcbe */\n-  {\n-    { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n-    & ifmt_addrbe, { 0xbf }\n-  },\n-/* mov32 $dstbe,$imm32 */\n-  {\n-    { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n-    & ifmt_addibe, { 0xb4 }\n-  },\n-/* mov32 $dstbe,$srcbe */\n-  {\n-    { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n-    & ifmt_addrbe, { 0xbc }\n-  },\n /* arsh $dstbe,$imm32 */\n   {\n     { 0, 0, 0, 0 },\n@@ -760,6 +736,30 @@ static const CGEN_OPCODE bpf_cgen_insn_opcode_table[MAX_INSNS] =\n     { { MNEM, ' ', OP (DSTBE), 0 } },\n     & ifmt_negbe, { 0x84 }\n   },\n+/* mov $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0xb7 }\n+  },\n+/* mov $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xbf }\n+  },\n+/* mov32 $dstbe,$imm32 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (IMM32), 0 } },\n+    & ifmt_addibe, { 0xb4 }\n+  },\n+/* mov32 $dstbe,$srcbe */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), 0 } },\n+    & ifmt_addrbe, { 0xbc }\n+  },\n /* endle $dstle,$endsize */\n   {\n     { 0, 0, 0, 0 },\n@@ -1540,17 +1540,23 @@ static const CGEN_OPCODE bpf_cgen_insn_opcode_table[MAX_INSNS] =\n     { { MNEM, ' ', OP (DSTBE), ',', OP (SRCBE), ',', OP (DISP16), 0 } },\n     & ifmt_jeqrbe, { 0xde }\n   },\n-/* ja $disp16 */\n+/* call $disp32 */\n   {\n     { 0, 0, 0, 0 },\n-    { { MNEM, ' ', OP (DISP16), 0 } },\n-    & ifmt_ja, { 0x5 }\n+    { { MNEM, ' ', OP (DISP32), 0 } },\n+    & ifmt_callle, { 0x85 }\n   },\n /* call $disp32 */\n   {\n     { 0, 0, 0, 0 },\n     { { MNEM, ' ', OP (DISP32), 0 } },\n-    & ifmt_call, { 0x85 }\n+    & ifmt_callle, { 0x85 }\n+  },\n+/* ja $disp16 */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, ' ', OP (DISP16), 0 } },\n+    & ifmt_ja, { 0x5 }\n   },\n /* exit */\n   {\n@@ -1582,6 +1588,12 @@ static const CGEN_OPCODE bpf_cgen_insn_opcode_table[MAX_INSNS] =\n     { { MNEM, ' ', '[', OP (DSTBE), '+', OP (OFFSET16), ']', ',', OP (SRCBE), 0 } },\n     & ifmt_ldxwbe, { 0xc3 }\n   },\n+/* brkpt */\n+  {\n+    { 0, 0, 0, 0 },\n+    { { MNEM, 0 } },\n+    & ifmt_exit, { 0x8c }\n+  },\n };\n \n #undef A"
    },
    {
      "sha": "ec0c2d328e87e317962ef15c34bc3e03193c360c",
      "filename": "opcodes/bpf-opc.h",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/bpf-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78c1c35437a013c63acbff6926ff8d254e283d69/opcodes/bpf-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-opc.h?ref=78c1c35437a013c63acbff6926ff8d254e283d69",
      "patch": "@@ -58,9 +58,9 @@ typedef enum cgen_insn_type {\n  , BPF_INSN_LSH32RLE, BPF_INSN_RSHILE, BPF_INSN_RSHRLE, BPF_INSN_RSH32ILE\n  , BPF_INSN_RSH32RLE, BPF_INSN_MODILE, BPF_INSN_MODRLE, BPF_INSN_MOD32ILE\n  , BPF_INSN_MOD32RLE, BPF_INSN_XORILE, BPF_INSN_XORRLE, BPF_INSN_XOR32ILE\n- , BPF_INSN_XOR32RLE, BPF_INSN_MOVILE, BPF_INSN_MOVRLE, BPF_INSN_MOV32ILE\n- , BPF_INSN_MOV32RLE, BPF_INSN_ARSHILE, BPF_INSN_ARSHRLE, BPF_INSN_ARSH32ILE\n- , BPF_INSN_ARSH32RLE, BPF_INSN_NEGLE, BPF_INSN_NEG32LE, BPF_INSN_ADDIBE\n+ , BPF_INSN_XOR32RLE, BPF_INSN_ARSHILE, BPF_INSN_ARSHRLE, BPF_INSN_ARSH32ILE\n+ , BPF_INSN_ARSH32RLE, BPF_INSN_NEGLE, BPF_INSN_NEG32LE, BPF_INSN_MOVILE\n+ , BPF_INSN_MOVRLE, BPF_INSN_MOV32ILE, BPF_INSN_MOV32RLE, BPF_INSN_ADDIBE\n  , BPF_INSN_ADDRBE, BPF_INSN_ADD32IBE, BPF_INSN_ADD32RBE, BPF_INSN_SUBIBE\n  , BPF_INSN_SUBRBE, BPF_INSN_SUB32IBE, BPF_INSN_SUB32RBE, BPF_INSN_MULIBE\n  , BPF_INSN_MULRBE, BPF_INSN_MUL32IBE, BPF_INSN_MUL32RBE, BPF_INSN_DIVIBE\n@@ -70,10 +70,10 @@ typedef enum cgen_insn_type {\n  , BPF_INSN_LSHRBE, BPF_INSN_LSH32IBE, BPF_INSN_LSH32RBE, BPF_INSN_RSHIBE\n  , BPF_INSN_RSHRBE, BPF_INSN_RSH32IBE, BPF_INSN_RSH32RBE, BPF_INSN_MODIBE\n  , BPF_INSN_MODRBE, BPF_INSN_MOD32IBE, BPF_INSN_MOD32RBE, BPF_INSN_XORIBE\n- , BPF_INSN_XORRBE, BPF_INSN_XOR32IBE, BPF_INSN_XOR32RBE, BPF_INSN_MOVIBE\n- , BPF_INSN_MOVRBE, BPF_INSN_MOV32IBE, BPF_INSN_MOV32RBE, BPF_INSN_ARSHIBE\n+ , BPF_INSN_XORRBE, BPF_INSN_XOR32IBE, BPF_INSN_XOR32RBE, BPF_INSN_ARSHIBE\n  , BPF_INSN_ARSHRBE, BPF_INSN_ARSH32IBE, BPF_INSN_ARSH32RBE, BPF_INSN_NEGBE\n- , BPF_INSN_NEG32BE, BPF_INSN_ENDLELE, BPF_INSN_ENDBELE, BPF_INSN_ENDLEBE\n+ , BPF_INSN_NEG32BE, BPF_INSN_MOVIBE, BPF_INSN_MOVRBE, BPF_INSN_MOV32IBE\n+ , BPF_INSN_MOV32RBE, BPF_INSN_ENDLELE, BPF_INSN_ENDBELE, BPF_INSN_ENDLEBE\n  , BPF_INSN_ENDBEBE, BPF_INSN_LDDWLE, BPF_INSN_LDDWBE, BPF_INSN_LDABSW\n  , BPF_INSN_LDABSH, BPF_INSN_LDABSB, BPF_INSN_LDABSDW, BPF_INSN_LDINDWLE\n  , BPF_INSN_LDINDHLE, BPF_INSN_LDINDBLE, BPF_INSN_LDINDDWLE, BPF_INSN_LDINDWBE\n@@ -105,16 +105,16 @@ typedef enum cgen_insn_type {\n  , BPF_INSN_JSGTRBE, BPF_INSN_JSGT32IBE, BPF_INSN_JSGT32RBE, BPF_INSN_JSGEIBE\n  , BPF_INSN_JSGERBE, BPF_INSN_JSGE32IBE, BPF_INSN_JSGE32RBE, BPF_INSN_JSLTIBE\n  , BPF_INSN_JSLTRBE, BPF_INSN_JSLT32IBE, BPF_INSN_JSLT32RBE, BPF_INSN_JSLEIBE\n- , BPF_INSN_JSLERBE, BPF_INSN_JSLE32IBE, BPF_INSN_JSLE32RBE, BPF_INSN_JA\n- , BPF_INSN_CALL, BPF_INSN_EXIT, BPF_INSN_XADDDWLE, BPF_INSN_XADDWLE\n- , BPF_INSN_XADDDWBE, BPF_INSN_XADDWBE\n+ , BPF_INSN_JSLERBE, BPF_INSN_JSLE32IBE, BPF_INSN_JSLE32RBE, BPF_INSN_CALLLE\n+ , BPF_INSN_CALLBE, BPF_INSN_JA, BPF_INSN_EXIT, BPF_INSN_XADDDWLE\n+ , BPF_INSN_XADDWLE, BPF_INSN_XADDDWBE, BPF_INSN_XADDWBE, BPF_INSN_BRKPT\n } CGEN_INSN_TYPE;\n \n /* Index of `invalid' insn place holder.  */\n #define CGEN_INSN_INVALID BPF_INSN_INVALID\n \n /* Total number of insns in table.  */\n-#define MAX_INSNS ((int) BPF_INSN_XADDWBE + 1)\n+#define MAX_INSNS ((int) BPF_INSN_BRKPT + 1)\n \n /* This struct records data prior to insertion or after extraction.  */\n struct cgen_fields"
    }
  ]
}