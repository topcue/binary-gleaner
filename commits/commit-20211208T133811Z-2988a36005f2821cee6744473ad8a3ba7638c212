{
  "sha": "2988a36005f2821cee6744473ad8a3ba7638c212",
  "node_id": "C_kwDOANOeidoAKDI5ODhhMzYwMDVmMjgyMWNlZTY3NDQ0NzNhZDhhM2JhNzYzOGMyMTI",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-17T11:55:37Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-08T13:38:11Z"
    },
    "message": "gdb/python: Use tp_init instead of tp_new to setup gdb.Value\n\nThe documentation suggests that we implement gdb.Value.__init__,\nhowever, this is not currently true, we really implement\ngdb.Value.__new__.  This will cause confusion if a user tries to\nsub-class gdb.Value.  They might write:\n\n  class MyVal (gdb.Value):\n      def __init__ (self, val):\n          gdb.Value.__init__(self, val)\n\n  obj = MyVal(123)\n  print (\"Got: %s\" % obj)\n\nBut, when they source this code they'll see:\n\n  (gdb) source ~/tmp/value-test.py\n  Traceback (most recent call last):\n    File \"/home/andrew/tmp/value-test.py\", line 7, in <module>\n      obj = MyVal(123)\n    File \"/home/andrew/tmp/value-test.py\", line 5, in __init__\n      gdb.Value.__init__(self, val)\n  TypeError: object.__init__() takes exactly one argument (the instance to initialize)\n  (gdb)\n\nThe reason for this is that, as we don't implement __init__ for\ngdb.Value, Python ends up calling object.__init__ instead, which\ndoesn't expect any arguments.\n\nThe Python docs suggest that the reason why we might take this\napproach is because we want gdb.Value to be immutable:\n\n   https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_new\n\nBut I don't see any reason why we should require gdb.Value to be\nimmutable when other types defined in GDB are not.  This current\nimmutability can be seen in this code:\n\n  obj = gdb.Value(1234)\n  print(\"Got: %s\" % obj)\n  obj.__init__ (5678)\n  print(\"Got: %s\" % obj)\n\nWhich currently runs without error, but prints:\n\n  Got: 1234\n  Got: 1234\n\nIn this commit I propose that we switch to using __init__ to\ninitialize gdb.Value objects.\n\nThis does introduce some additional complexity, during the __init__\ncall a gdb.Value might already be associated with a gdb value object,\nin which case we need to cleanly break that association before\ninstalling the new gdb value object.  However, the cost of doing this\nis not great, and the benefit - being able to easily sub-class\ngdb.Value seems worth it.\n\nAfter this commit the first example above works without error, while\nthe second example now prints:\n\n  Got: 1234\n  Got: 5678\n\nIn order to make it easier to override the gdb.Value.__init__ method,\nI have tweaked the definition of gdb.Value.__init__.  The second,\noptional argument to __init__ is a gdb.Type, if this argument is not\npresent then GDB figures out a suitable type.\n\nHowever, if we want to override the __init__ method in a sub-class,\nand still support the default argument, it is easier to write:\n\n  class MyVal (gdb.Value):\n      def __init__ (self, val, type=None):\n          gdb.Value.__init__(self, val, type)\n\nCurrently, passing None for the Type will result in an error:\n\n  TypeError: type argument must be a gdb.Type.\n\nAfter this commit I now allow the type argument to be None, in which\ncase GDB figures out a suitable type just as if the type had not been\npassed at all.\n\nUnless a user is trying to reinitialize a value, or create sub-classes\nof gdb.Value, there should be no user visible changes after this\ncommit.",
    "tree": {
      "sha": "0a73e963ee794a86b5ee41058331d4837cd56601",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0a73e963ee794a86b5ee41058331d4837cd56601"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2988a36005f2821cee6744473ad8a3ba7638c212",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2988a36005f2821cee6744473ad8a3ba7638c212",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2988a36005f2821cee6744473ad8a3ba7638c212",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2988a36005f2821cee6744473ad8a3ba7638c212/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "a5d8391846052cde835015c894237c799089c8cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a5d8391846052cde835015c894237c799089c8cd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a5d8391846052cde835015c894237c799089c8cd"
    }
  ],
  "stats": {
    "total": 178,
    "additions": 126,
    "deletions": 52
  },
  "files": [
    {
      "sha": "568aabc4885b6be1daf22bcf0f2d1a7ab1225cbe",
      "filename": "gdb/doc/python.texi",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2988a36005f2821cee6744473ad8a3ba7638c212/gdb/doc/python.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2988a36005f2821cee6744473ad8a3ba7638c212/gdb/doc/python.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/python.texi?ref=2988a36005f2821cee6744473ad8a3ba7638c212",
      "patch": "@@ -827,6 +827,9 @@ This second form of the @code{gdb.Value} constructor returns a\n from the Python buffer object specified by @var{val}.  The number of\n bytes in the Python buffer object must be greater than or equal to the\n size of @var{type}.\n+\n+If @var{type} is @code{None} then this version of @code{__init__}\n+behaves as though @var{type} was not passed at all.\n @end defun\n \n @defun Value.cast (type)"
    },
    {
      "sha": "255a30875be5c4df45514e3c2b49189100345349",
      "filename": "gdb/python/py-value.c",
      "status": "modified",
      "additions": 69,
      "deletions": 47,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2988a36005f2821cee6744473ad8a3ba7638c212/gdb/python/py-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2988a36005f2821cee6744473ad8a3ba7638c212/gdb/python/py-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-value.c?ref=2988a36005f2821cee6744473ad8a3ba7638c212",
      "patch": "@@ -70,41 +70,64 @@ struct value_object {\n    work around a linker bug on MacOS.  */\n static value_object *values_in_python = NULL;\n \n+/* Clear out an old GDB value stored within SELF, and reset the fields to\n+   nullptr.  This should be called when a gdb.Value is deallocated, and\n+   also if a gdb.Value is reinitialized with a new value.  */\n+\n+static void\n+valpy_clear_value (value_object *self)\n+{\n+  /* Indicate we are no longer interested in the value object.  */\n+  value_decref (self->value);\n+  self->value = nullptr;\n+\n+  Py_CLEAR (self->address);\n+  Py_CLEAR (self->type);\n+  Py_CLEAR (self->dynamic_type);\n+}\n+\n /* Called by the Python interpreter when deallocating a value object.  */\n static void\n valpy_dealloc (PyObject *obj)\n {\n   value_object *self = (value_object *) obj;\n \n-  /* Remove SELF from the global list.  */\n-  if (self->prev)\n-    self->prev->next = self->next;\n-  else\n+  /* If SELF failed to initialize correctly then it may not have a value\n+     contained within it.  */\n+  if (self->value != nullptr)\n     {\n-      gdb_assert (values_in_python == self);\n-      values_in_python = self->next;\n-    }\n-  if (self->next)\n-    self->next->prev = self->prev;\n-\n-  value_decref (self->value);\n+      /* Remove SELF from the global list of values.  */\n+      if (self->prev != nullptr)\n+\tself->prev->next = self->next;\n+      else\n+\t{\n+\t  gdb_assert (values_in_python == self);\n+\t  values_in_python = self->next;\n+\t}\n+      if (self->next != nullptr)\n+\tself->next->prev = self->prev;\n \n-  Py_XDECREF (self->address);\n-  Py_XDECREF (self->type);\n-  Py_XDECREF (self->dynamic_type);\n+      /* Release the value object and any cached Python objects.  */\n+      valpy_clear_value (self);\n+    }\n \n   Py_TYPE (self)->tp_free (self);\n }\n \n-/* Helper to push a Value object on the global list.  */\n+/* Helper to push a gdb.Value object on to the global list of values.  If\n+   VALUE_OBJ is already on the lit then this does nothing.  */\n+\n static void\n note_value (value_object *value_obj)\n {\n-  value_obj->next = values_in_python;\n-  if (value_obj->next)\n-    value_obj->next->prev = value_obj;\n-  value_obj->prev = NULL;\n-  values_in_python = value_obj;\n+  if (value_obj->next == nullptr)\n+    {\n+      gdb_assert (value_obj->prev == nullptr);\n+      value_obj->next = values_in_python;\n+      if (value_obj->next != nullptr)\n+\tvalue_obj->next->prev = value_obj;\n+      values_in_python = value_obj;\n+    }\n }\n \n /* Convert a python object OBJ with type TYPE to a gdb value.  The\n@@ -142,60 +165,55 @@ convert_buffer_and_type_to_value (PyObject *obj, struct type *type)\n   return value_from_contents (type, (const gdb_byte *) py_buf.buf);\n }\n \n-/* Called when a new gdb.Value object needs to be allocated.  Returns NULL on\n-   error, with a python exception set.  */\n-static PyObject *\n-valpy_new (PyTypeObject *subtype, PyObject *args, PyObject *kwargs)\n+/* Implement gdb.Value.__init__.  */\n+\n+static int\n+valpy_init (PyObject *self, PyObject *args, PyObject *kwds)\n {\n   static const char *keywords[] = { \"val\", \"type\", NULL };\n   PyObject *val_obj = nullptr;\n   PyObject *type_obj = nullptr;\n \n-  if (!gdb_PyArg_ParseTupleAndKeywords (args, kwargs, \"O|O\", keywords,\n+  if (!gdb_PyArg_ParseTupleAndKeywords (args, kwds, \"O|O\", keywords,\n \t\t\t\t\t&val_obj, &type_obj))\n-    return nullptr;\n+    return -1;\n \n   struct type *type = nullptr;\n-\n-  if (type_obj != nullptr)\n+  if (type_obj != nullptr && type_obj != Py_None)\n     {\n       type = type_object_to_type (type_obj);\n       if (type == nullptr)\n \t{\n \t  PyErr_SetString (PyExc_TypeError,\n \t\t\t   _(\"type argument must be a gdb.Type.\"));\n-\t  return nullptr;\n+\t  return -1;\n \t}\n     }\n \n-  value_object *value_obj = (value_object *) subtype->tp_alloc (subtype, 1);\n-  if (value_obj == NULL)\n-    {\n-      PyErr_SetString (PyExc_MemoryError, _(\"Could not allocate memory to \"\n-\t\t\t\t\t    \"create Value object.\"));\n-      return NULL;\n-    }\n-\n   struct value *value;\n-\n   if (type == nullptr)\n     value = convert_value_from_python (val_obj);\n   else\n     value = convert_buffer_and_type_to_value (val_obj, type);\n-\n   if (value == nullptr)\n     {\n-      subtype->tp_free (value_obj);\n-      return NULL;\n+      gdb_assert (PyErr_Occurred ());\n+      return -1;\n     }\n \n+  /* There might be a previous value here.  */\n+  value_object *value_obj = (value_object *) self;\n+  if (value_obj->value != nullptr)\n+    valpy_clear_value (value_obj);\n+\n+  /* Store the value into this Python object.  */\n   value_obj->value = release_value (value).release ();\n-  value_obj->address = NULL;\n-  value_obj->type = NULL;\n-  value_obj->dynamic_type = NULL;\n+\n+  /* Ensure that this gdb.Value is in the set of all gdb.Value objects.  If\n+     we are already in the set then this is call does nothing.  */\n   note_value (value_obj);\n \n-  return (PyObject *) value_obj;\n+  return 0;\n }\n \n /* Iterate over all the Value objects, calling preserve_one_value on\n@@ -1784,6 +1802,8 @@ value_to_value_object (struct value *val)\n   if (val_obj != NULL)\n     {\n       val_obj->value = release_value (val).release ();\n+      val_obj->next = nullptr;\n+      val_obj->prev = nullptr;\n       val_obj->address = NULL;\n       val_obj->type = NULL;\n       val_obj->dynamic_type = NULL;\n@@ -1805,6 +1825,8 @@ value_to_value_object_no_release (struct value *val)\n     {\n       value_incref (val);\n       val_obj->value = val;\n+      val_obj->next = nullptr;\n+      val_obj->prev = nullptr;\n       val_obj->address = NULL;\n       val_obj->type = NULL;\n       val_obj->dynamic_type = NULL;\n@@ -2232,7 +2254,7 @@ PyTypeObject value_object_type = {\n   0,\t\t\t\t  /* tp_descr_get */\n   0,\t\t\t\t  /* tp_descr_set */\n   0,\t\t\t\t  /* tp_dictoffset */\n-  0,\t\t\t\t  /* tp_init */\n+  valpy_init,\t\t\t  /* tp_init */\n   0,\t\t\t\t  /* tp_alloc */\n-  valpy_new\t\t\t  /* tp_new */\n+  PyType_GenericNew,\t\t  /* tp_new */\n };"
    },
    {
      "sha": "297b128da4785aa9ba087e460b9481399b6b3b88",
      "filename": "gdb/testsuite/gdb.python/py-value.exp",
      "status": "modified",
      "additions": 54,
      "deletions": 5,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2988a36005f2821cee6744473ad8a3ba7638c212/gdb/testsuite/gdb.python/py-value.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2988a36005f2821cee6744473ad8a3ba7638c212/gdb/testsuite/gdb.python/py-value.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-value.exp?ref=2988a36005f2821cee6744473ad8a3ba7638c212",
      "patch": "@@ -51,6 +51,7 @@ proc test_value_creation {} {\n \n   gdb_py_test_silent_cmd \"python i = gdb.Value (True)\" \"create boolean value\" 1\n   gdb_py_test_silent_cmd \"python i = gdb.Value (5)\" \"create integer value\" 1\n+  gdb_py_test_silent_cmd \"python i = gdb.Value (3,None)\" \"create integer value, with None type\" 1\n   if { $gdb_py_is_py3k == 0 } {\n     gdb_py_test_silent_cmd \"python i = gdb.Value (5L)\" \"create long value\" 1\n   }\n@@ -77,6 +78,18 @@ proc test_value_creation {} {\n   gdb_test \"python print ('result = %s' % i.address)\" \"= None\" \"test address attribute in non-addressable value\"\n }\n \n+# Check that we can call gdb.Value.__init__ to change a value.\n+proc test_value_reinit {} {\n+    gdb_py_test_silent_cmd \"python v = gdb.Value (3)\" \\\n+\t\"create initial integer value\" 1\n+    gdb_test \"python print(v)\" \"3\" \\\n+\t\"check initial value contents\"\n+    gdb_py_test_silent_cmd \"python v.__init__(5)\" \\\n+\t\"call gdb.Value.__init__ manually\" 1\n+    gdb_test \"python print(v)\" \"5\" \\\n+\t\"check new value contents\"\n+}\n+\n proc test_value_numeric_ops {} {\n   global gdb_prompt\n   global gdb_py_is_py3k\n@@ -531,10 +544,14 @@ proc test_float_conversion {} {\n     gdb_test \"python print(float(gdb.Value(0)))\" \"0\\\\.0\"\n }\n \n-proc test_value_from_buffer {} {\n-  global gdb_prompt\n-  global gdb_py_is_py3k\n-\n+# Setup some Python variables:\n+#   tp      : a gdb.Type for 'int',\n+#   size_a  : the size of array 'a' from the inferior,\n+#   size_a0 : the size of array element 'a[0] from the inferior,\n+#   addr    : the address of 'a[0]' from the inferior,\n+#   b       : a buffer containing the full contents of array 'a' from the\n+#             inferior.\n+proc prepare_type_and_buffer {} {\n   gdb_py_test_silent_cmd \"python tp=gdb.lookup_type('int')\" \"look up int type\" 0\n   gdb_py_test_silent_cmd \"python size_a=gdb.parse_and_eval('sizeof(a)')\" \\\n                          \"find size of a\" 0\n@@ -543,7 +560,14 @@ proc test_value_from_buffer {} {\n   gdb_py_test_silent_cmd \"python addr=gdb.parse_and_eval('&a')\" \\\n                          \"find address of a\" 0\n   gdb_py_test_silent_cmd \"python b=gdb.selected_inferior().read_memory(addr,size_a)\" \\\n-                         \"read buffer from memory\" 1\n+                         \"read buffer from memory\" 0\n+}\n+\n+proc test_value_from_buffer {} {\n+  global gdb_prompt\n+  global gdb_py_is_py3k\n+\n+  prepare_type_and_buffer\n   gdb_test \"python v=gdb.Value(b,tp); print(v)\" \"1\" \\\n             \"construct value from buffer\"\n   gdb_test \"python v=gdb.Value(b\\[size_a0:\\],tp); print(v)\" \"2\" \\\n@@ -600,6 +624,29 @@ proc test_add_to_history {} {\n \t\"TypeError: Could not convert Python object: .*\"\n }\n \n+# Check we can create sub-classes of gdb.Value.\n+proc test_value_sub_classes {} {\n+    prepare_type_and_buffer\n+\n+    gdb_test_multiline \"Create sub-class of gdb.Value\" \\\n+\t\"python\" \"\" \\\n+\t\"class MyValue(gdb.Value):\" \"\" \\\n+\t\"  def __init__(self,val,type=None):\" \"\" \\\n+\t\"    gdb.Value.__init__(self,val,type)\" \"\" \\\n+\t\"    print(\\\"In MyValue.__init__\\\")\" \"\" \\\n+\t\"end\"\n+\n+    gdb_test \"python obj = MyValue (123)\" \"In MyValue.__init__\" \\\n+\t\"create instance of MyValue\"\n+    gdb_test \"python print(obj)\" \"123\" \\\n+\t\"check printing of MyValue\"\n+\n+    gdb_test \"python obj = MyValue(b\\[size_a0:\\],tp)\" \"In MyValue.__init__\" \\\n+\t\"convert 2nd elem of buffer to a MyValue\"\n+    gdb_test \"python print(obj)\" \"2\" \\\n+\t\"check printing of MyValue when initiaized with a type\"\n+}\n+\n # Build C version of executable.  C++ is built later.\n if { [build_inferior \"${binfile}\" \"c\"] < 0 } {\n     return -1\n@@ -612,6 +659,7 @@ clean_restart ${binfile}\n if { [skip_python_tests] } { continue }\n \n test_value_creation\n+test_value_reinit\n test_value_numeric_ops\n test_value_boolean\n test_value_compare\n@@ -629,6 +677,7 @@ if ![runto_main] then {\n \n test_value_in_inferior\n test_value_from_buffer\n+test_value_sub_classes\n test_inferior_function_call\n test_value_after_death\n "
    }
  ]
}