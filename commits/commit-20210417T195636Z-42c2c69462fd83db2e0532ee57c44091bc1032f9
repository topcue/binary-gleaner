{
  "sha": "42c2c69462fd83db2e0532ee57c44091bc1032f9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDJjMmM2OTQ2MmZkODNkYjJlMDUzMmVlNTdjNDQwOTFiYzEwMzJmOQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-04-17T19:56:36Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-04-17T19:56:36Z"
    },
    "message": "Handle unaligned mapping of .gdb_index\n\nThe .gdb_index was designed such that all data would be aligned.\nUnfortunately, we neglected to require this alignment in the objcopy\ninstructions in the manual.  As a result, in many cases, a .gdb_index\nin the wild will not be properly aligned by mmap.  This yields\nundefined behavior, which is PR gdb/23743.\n\nThis patch fixes the bug by always assuming that the mapping is\nunaligned, and using extract_unsigned_integer when needed.  A new\nhelper class is introduced to make this less painful.\n\ngdb/ChangeLog\n2021-04-17  Tom Tromey  <tom@tromey.com>\n\n\tPR gdb/23743:\n\t* dwarf2/read.c (class offset_view): New.\n\t(struct symbol_table_slot): Remove.\n\t(struct mapped_index) <symbol_table, constant_pool>: Change type.\n\t<symbol_name_index, symbol_vec_index>: New methods.\n\t<symbol_name_slot_invalid, symbol_name_at, symbol_name_count>:\n\tRewrite.\n\t(read_gdb_index_from_buffer): Update.\n\t(struct dw2_symtab_iterator) <vec>: Change type.\n\t(dw2_symtab_iter_init_common, dw2_symtab_iter_init)\n\t(dw2_symtab_iter_next, dw2_expand_marked_cus): Update.\n\t* dwarf2/index-write.c (class data_buf) <append_data>: Remove.\n\t<append_array, append_offset>: New methods.\n\t(write_hash_table, add_address_entry, write_gdbindex_1)\n\t(write_debug_names): Update.\n\t* dwarf2/index-common.h (byte_swap, MAYBE_SWAP): Remove.",
    "tree": {
      "sha": "13355973b52c4ffc51df5db1838a4907138e6270",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/13355973b52c4ffc51df5db1838a4907138e6270"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/42c2c69462fd83db2e0532ee57c44091bc1032f9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/42c2c69462fd83db2e0532ee57c44091bc1032f9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/42c2c69462fd83db2e0532ee57c44091bc1032f9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/42c2c69462fd83db2e0532ee57c44091bc1032f9/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "da314dd397ab967af558f2929a79349aa5f96ac8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/da314dd397ab967af558f2929a79349aa5f96ac8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/da314dd397ab967af558f2929a79349aa5f96ac8"
    }
  ],
  "stats": {
    "total": 213,
    "additions": 132,
    "deletions": 81
  },
  "files": [
    {
      "sha": "678ad2772f386811eacb76b90cbaef303cb1cb14",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/42c2c69462fd83db2e0532ee57c44091bc1032f9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/42c2c69462fd83db2e0532ee57c44091bc1032f9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=42c2c69462fd83db2e0532ee57c44091bc1032f9",
      "patch": "@@ -1,3 +1,22 @@\n+2021-04-17  Tom Tromey  <tom@tromey.com>\n+\n+\tPR gdb/23743:\n+\t* dwarf2/read.c (class offset_view): New.\n+\t(struct symbol_table_slot): Remove.\n+\t(struct mapped_index) <symbol_table, constant_pool>: Change type.\n+\t<symbol_name_index, symbol_vec_index>: New methods.\n+\t<symbol_name_slot_invalid, symbol_name_at, symbol_name_count>:\n+\tRewrite.\n+\t(read_gdb_index_from_buffer): Update.\n+\t(struct dw2_symtab_iterator) <vec>: Change type.\n+\t(dw2_symtab_iter_init_common, dw2_symtab_iter_init)\n+\t(dw2_symtab_iter_next, dw2_expand_marked_cus): Update.\n+\t* dwarf2/index-write.c (class data_buf) <append_data>: Remove.\n+\t<append_array, append_offset>: New methods.\n+\t(write_hash_table, add_address_entry, write_gdbindex_1)\n+\t(write_debug_names): Update.\n+\t* dwarf2/index-common.h (byte_swap, MAYBE_SWAP): Remove.\n+\n 2021-04-17  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/index-write.c (write_psymtabs_to_index): Check"
    },
    {
      "sha": "861807475332b9bb938c4527029c587da82152ab",
      "filename": "gdb/dwarf2/index-common.h",
      "status": "modified",
      "additions": 4,
      "deletions": 17,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/42c2c69462fd83db2e0532ee57c44091bc1032f9/gdb/dwarf2/index-common.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/42c2c69462fd83db2e0532ee57c44091bc1032f9/gdb/dwarf2/index-common.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-common.h?ref=42c2c69462fd83db2e0532ee57c44091bc1032f9",
      "patch": "@@ -29,28 +29,15 @@\n    architecture-independent.  */\n typedef uint32_t offset_type;\n \n-#if WORDS_BIGENDIAN\n-\n-/* Convert VALUE between big- and little-endian.  */\n+/* Unpack a 32-bit little-endian value.  */\n \n static inline offset_type\n-byte_swap (offset_type value)\n+gdb_index_unpack (const gdb_byte *value)\n {\n-  offset_type result;\n-\n-  result = (value & 0xff) << 24;\n-  result |= (value & 0xff00) << 8;\n-  result |= (value & 0xff0000) >> 8;\n-  result |= (value & 0xff000000) >> 24;\n-  return result;\n+  return (offset_type) extract_unsigned_integer (value, sizeof (offset_type),\n+\t\t\t\t\t\t BFD_ENDIAN_LITTLE);\n }\n \n-#define MAYBE_SWAP(V)  byte_swap (V)\n-\n-#else\n-#define MAYBE_SWAP(V) static_cast<offset_type> (V)\n-#endif /* WORDS_BIGENDIAN */\n-\n /* The hash function for strings in the mapped index.  This is the same as\n    SYMBOL_HASH_NEXT, but we keep a separate copy to maintain control over the\n    implementation.  This is necessary because the hash function is tied to the"
    },
    {
      "sha": "e27e1e8cf7dd31335d4fa36ec4ac5131d6495ac4",
      "filename": "gdb/dwarf2/index-write.c",
      "status": "modified",
      "additions": 22,
      "deletions": 19,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/42c2c69462fd83db2e0532ee57c44091bc1032f9/gdb/dwarf2/index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/42c2c69462fd83db2e0532ee57c44091bc1032f9/gdb/dwarf2/index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-write.c?ref=42c2c69462fd83db2e0532ee57c44091bc1032f9",
      "patch": "@@ -94,13 +94,10 @@ file_write (FILE *file, const std::vector<Elem, Alloc> &vec)\n class data_buf\n {\n public:\n-  /* Copy DATA to the end of the buffer.  */\n-  template<typename T>\n-  void append_data (const T &data)\n+  /* Copy ARRAY to the end of the buffer.  */\n+  void append_array (gdb::array_view<const gdb_byte> array)\n   {\n-    std::copy (reinterpret_cast<const gdb_byte *> (&data),\n-\t       reinterpret_cast<const gdb_byte *> (&data + 1),\n-\t       grow (sizeof (data)));\n+    std::copy (array.begin (), array.end (), grow (array.size ()));\n   }\n \n   /* Copy CSTR (a zero-terminated string) to the end of buffer.  The\n@@ -120,7 +117,7 @@ class data_buf\n \tinput >>= 7;\n \tif (input)\n \t  output |= 0x80;\n-\tappend_data (output);\n+\tm_vec.push_back (output);\n \tif (input == 0)\n \t  break;\n       }\n@@ -133,6 +130,12 @@ class data_buf\n     ::store_unsigned_integer (grow (len), len, byte_order, val);\n   }\n \n+  /* Copy VALUE to the end of the buffer, little-endian.  */\n+  void append_offset (offset_type value)\n+  {\n+    append_uint (sizeof (value), BFD_ENDIAN_LITTLE, value);\n+  }\n+\n   /* Return the size of the buffer.  */\n   size_t size () const\n   {\n@@ -371,9 +374,9 @@ write_hash_table (mapped_symtab *symtab, data_buf &output, data_buf &cpool)\n \n \tsymbol_hash_table.emplace (entry.cu_indices, cpool.size ());\n \tentry.index_offset = cpool.size ();\n-\tcpool.append_data (MAYBE_SWAP (entry.cu_indices.size ()));\n+\tcpool.append_offset (entry.cu_indices.size ());\n \tfor (const auto index : entry.cu_indices)\n-\t  cpool.append_data (MAYBE_SWAP (index));\n+\t  cpool.append_offset (index);\n       }\n   }\n \n@@ -399,8 +402,8 @@ write_hash_table (mapped_symtab *symtab, data_buf &output, data_buf &cpool)\n \t  vec_off = 0;\n \t}\n \n-      output.append_data (MAYBE_SWAP (str_off));\n-      output.append_data (MAYBE_SWAP (vec_off));\n+      output.append_offset (str_off);\n+      output.append_offset (vec_off);\n     }\n }\n \n@@ -434,7 +437,7 @@ add_address_entry (data_buf &addr_vec,\n {\n   addr_vec.append_uint (8, BFD_ENDIAN_LITTLE, start);\n   addr_vec.append_uint (8, BFD_ENDIAN_LITTLE, end);\n-  addr_vec.append_data (MAYBE_SWAP (cu_index));\n+  addr_vec.append_offset (cu_index);\n }\n \n /* Worker function for traversing an addrmap to build the address table.  */\n@@ -1374,26 +1377,26 @@ write_gdbindex_1 (FILE *out_file,\n   offset_type total_len = size_of_header;\n \n   /* The version number.  */\n-  contents.append_data (MAYBE_SWAP (8));\n+  contents.append_offset (8);\n \n   /* The offset of the CU list from the start of the file.  */\n-  contents.append_data (MAYBE_SWAP (total_len));\n+  contents.append_offset (total_len);\n   total_len += cu_list.size ();\n \n   /* The offset of the types CU list from the start of the file.  */\n-  contents.append_data (MAYBE_SWAP (total_len));\n+  contents.append_offset (total_len);\n   total_len += types_cu_list.size ();\n \n   /* The offset of the address table from the start of the file.  */\n-  contents.append_data (MAYBE_SWAP (total_len));\n+  contents.append_offset (total_len);\n   total_len += addr_vec.size ();\n \n   /* The offset of the symbol table from the start of the file.  */\n-  contents.append_data (MAYBE_SWAP (total_len));\n+  contents.append_offset (total_len);\n   total_len += symtab_vec.size ();\n \n   /* The offset of the constant pool from the start of the file.  */\n-  contents.append_data (MAYBE_SWAP (total_len));\n+  contents.append_offset (total_len);\n   total_len += constant_pool.size ();\n \n   gdb_assert (contents.size () == size_of_header);\n@@ -1611,7 +1614,7 @@ write_debug_names (dwarf2_per_objfile *per_objfile,\n      string.  This value is rounded up to a multiple of 4.  */\n   static_assert (sizeof (dwarf5_gdb_augmentation) % 4 == 0, \"\");\n   header.append_uint (4, dwarf5_byte_order, sizeof (dwarf5_gdb_augmentation));\n-  header.append_data (dwarf5_gdb_augmentation);\n+  header.append_array (dwarf5_gdb_augmentation);\n \n   gdb_assert (header.size () == bytes_of_header);\n "
    },
    {
      "sha": "40aeb298c14d70279413c90d33539ab7dac45310",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 87,
      "deletions": 45,
      "changes": 132,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/42c2c69462fd83db2e0532ee57c44091bc1032f9/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/42c2c69462fd83db2e0532ee57c44091bc1032f9/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=42c2c69462fd83db2e0532ee57c44091bc1032f9",
      "patch": "@@ -223,43 +223,93 @@ struct mapped_index_base\n   ~mapped_index_base() = default;\n };\n \n+/* This is a view into the index that converts from bytes to an\n+   offset_type, and allows indexing.  Unaligned bytes are specifically\n+   allowed here, and handled via unpacking.  */\n+\n+class offset_view\n+{\n+public:\n+  offset_view () = default;\n+\n+  explicit offset_view (gdb::array_view<const gdb_byte> bytes)\n+    : m_bytes (bytes)\n+  {\n+  }\n+\n+  /* Extract the INDEXth offset_type from the array.  */\n+  offset_type operator[] (size_t index) const\n+  {\n+    const gdb_byte *bytes = &m_bytes[index * sizeof (offset_type)];\n+    return (offset_type) extract_unsigned_integer (bytes,\n+\t\t\t\t\t\t   sizeof (offset_type),\n+\t\t\t\t\t\t   BFD_ENDIAN_LITTLE);\n+  }\n+\n+  /* Return the number of offset_types in this array.  */\n+  size_t size () const\n+  {\n+    return m_bytes.size () / sizeof (offset_type);\n+  }\n+\n+  /* Return true if this view is empty.  */\n+  bool empty () const\n+  {\n+    return m_bytes.empty ();\n+  }\n+\n+private:\n+  /* The underlying bytes.  */\n+  gdb::array_view<const gdb_byte> m_bytes;\n+};\n+\n /* A description of the mapped index.  The file format is described in\n    a comment by the code that writes the index.  */\n struct mapped_index final : public mapped_index_base\n {\n-  /* A slot/bucket in the symbol table hash.  */\n-  struct symbol_table_slot\n-  {\n-    const offset_type name;\n-    const offset_type vec;\n-  };\n-\n   /* Index data format version.  */\n   int version = 0;\n \n   /* The address table data.  */\n   gdb::array_view<const gdb_byte> address_table;\n \n   /* The symbol table, implemented as a hash table.  */\n-  gdb::array_view<symbol_table_slot> symbol_table;\n+  offset_view symbol_table;\n \n   /* A pointer to the constant pool.  */\n-  const char *constant_pool = nullptr;\n+  gdb::array_view<const gdb_byte> constant_pool;\n+\n+  /* Return the index into the constant pool of the name of the IDXth\n+     symbol in the symbol table.  */\n+  offset_type symbol_name_index (offset_type idx) const\n+  {\n+    return symbol_table[2 * idx];\n+  }\n+\n+  /* Return the index into the constant pool of the CU vector of the\n+     IDXth symbol in the symbol table.  */\n+  offset_type symbol_vec_index (offset_type idx) const\n+  {\n+    return symbol_table[2 * idx + 1];\n+  }\n \n   bool symbol_name_slot_invalid (offset_type idx) const override\n   {\n-    const auto &bucket = this->symbol_table[idx];\n-    return bucket.name == 0 && bucket.vec == 0;\n+    return (symbol_name_index (idx) == 0\n+\t    && symbol_vec_index (idx) == 0);\n   }\n \n   /* Convenience method to get at the name of the symbol at IDX in the\n      symbol table.  */\n   const char *symbol_name_at\n     (offset_type idx, dwarf2_per_objfile *per_objfile) const override\n-  { return this->constant_pool + MAYBE_SWAP (this->symbol_table[idx].name); }\n+  {\n+    return (const char *) (this->constant_pool.data ()\n+\t\t\t   + symbol_name_index (idx));\n+  }\n \n   size_t symbol_name_count () const override\n-  { return this->symbol_table.size (); }\n+  { return this->symbol_table.size () / 2; }\n };\n \n /* A description of the mapped .debug_names.\n@@ -2950,9 +3000,10 @@ read_gdb_index_from_buffer (const char *filename,\n \t\t\t    offset_type *types_list_elements)\n {\n   const gdb_byte *addr = &buffer[0];\n+  offset_view metadata (buffer);\n \n   /* Version check.  */\n-  offset_type version = MAYBE_SWAP (*(offset_type *) addr);\n+  offset_type version = metadata[0];\n   /* Versions earlier than 3 emitted every copy of a psymbol.  This\n      causes the index to behave very poorly for certain requests.  Version 3\n      contained incomplete addrmap.  So, it seems better to just ignore such\n@@ -3005,35 +3056,29 @@ to use the section anyway.\"),\n \n   map->version = version;\n \n-  offset_type *metadata = (offset_type *) (addr + sizeof (offset_type));\n-\n-  int i = 0;\n-  *cu_list = addr + MAYBE_SWAP (metadata[i]);\n-  *cu_list_elements = ((MAYBE_SWAP (metadata[i + 1]) - MAYBE_SWAP (metadata[i]))\n-\t\t       / 8);\n+  int i = 1;\n+  *cu_list = addr + metadata[i];\n+  *cu_list_elements = (metadata[i + 1] - metadata[i]) / 8;\n   ++i;\n \n-  *types_list = addr + MAYBE_SWAP (metadata[i]);\n-  *types_list_elements = ((MAYBE_SWAP (metadata[i + 1])\n-\t\t\t   - MAYBE_SWAP (metadata[i]))\n-\t\t\t  / 8);\n+  *types_list = addr + metadata[i];\n+  *types_list_elements = (metadata[i + 1] - metadata[i]) / 8;\n   ++i;\n \n-  const gdb_byte *address_table = addr + MAYBE_SWAP (metadata[i]);\n-  const gdb_byte *address_table_end = addr + MAYBE_SWAP (metadata[i + 1]);\n+  const gdb_byte *address_table = addr + metadata[i];\n+  const gdb_byte *address_table_end = addr + metadata[i + 1];\n   map->address_table\n     = gdb::array_view<const gdb_byte> (address_table, address_table_end);\n   ++i;\n \n-  const gdb_byte *symbol_table = addr + MAYBE_SWAP (metadata[i]);\n-  const gdb_byte *symbol_table_end = addr + MAYBE_SWAP (metadata[i + 1]);\n+  const gdb_byte *symbol_table = addr + metadata[i];\n+  const gdb_byte *symbol_table_end = addr + metadata[i + 1];\n   map->symbol_table\n-    = gdb::array_view<mapped_index::symbol_table_slot>\n-       ((mapped_index::symbol_table_slot *) symbol_table,\n-\t(mapped_index::symbol_table_slot *) symbol_table_end);\n+    = offset_view (gdb::array_view<const gdb_byte> (symbol_table,\n+\t\t\t\t\t\t    symbol_table_end));\n \n   ++i;\n-  map->constant_pool = (char *) (addr + MAYBE_SWAP (metadata[i]));\n+  map->constant_pool = buffer.slice (metadata[i]);\n \n   return 1;\n }\n@@ -3317,7 +3362,7 @@ struct dw2_symtab_iterator\n   domain_enum domain;\n   /* The list of CUs from the index entry of the symbol,\n      or NULL if not found.  */\n-  offset_type *vec;\n+  offset_view vec;\n   /* The next element in VEC to look at.  */\n   int next;\n   /* The number of elements in VEC, or zero if there is no match.  */\n@@ -3342,7 +3387,7 @@ dw2_symtab_iter_init (struct dw2_symtab_iterator *iter,\n   iter->domain = domain;\n   iter->next = 0;\n   iter->global_seen = 0;\n-  iter->vec = NULL;\n+  iter->vec = {};\n   iter->length = 0;\n \n   mapped_index *index = per_objfile->per_bfd->index_table.get ();\n@@ -3351,11 +3396,10 @@ dw2_symtab_iter_init (struct dw2_symtab_iterator *iter,\n     return;\n \n   gdb_assert (!index->symbol_name_slot_invalid (namei));\n-  const auto &bucket = index->symbol_table[namei];\n+  offset_type vec_idx = index->symbol_vec_index (namei);\n \n-  iter->vec = (offset_type *) (index->constant_pool\n-\t\t\t       + MAYBE_SWAP (bucket.vec));\n-  iter->length = MAYBE_SWAP (*iter->vec);\n+  iter->vec = offset_view (index->constant_pool.slice (vec_idx));\n+  iter->length = iter->vec[0];\n }\n \n /* Return the next matching CU or NULL if there are no more.  */\n@@ -3367,8 +3411,7 @@ dw2_symtab_iter_next (struct dw2_symtab_iterator *iter)\n \n   for ( ; iter->next < iter->length; ++iter->next)\n     {\n-      offset_type cu_index_and_attrs =\n-\tMAYBE_SWAP (iter->vec[iter->next + 1]);\n+      offset_type cu_index_and_attrs = iter->vec[iter->next + 1];\n       offset_type cu_index = GDB_INDEX_CU_VALUE (cu_index_and_attrs);\n       gdb_index_symbol_kind symbol_kind =\n \tGDB_INDEX_SYMBOL_KIND_VALUE (cu_index_and_attrs);\n@@ -4387,16 +4430,15 @@ dw2_expand_marked_cus\n    block_search_flags search_flags,\n    search_domain kind)\n {\n-  offset_type *vec, vec_len, vec_idx;\n+  offset_type vec_len, vec_idx;\n   bool global_seen = false;\n   mapped_index &index = *per_objfile->per_bfd->index_table;\n \n-  vec = (offset_type *) (index.constant_pool\n-\t\t\t + MAYBE_SWAP (index.symbol_table[idx].vec));\n-  vec_len = MAYBE_SWAP (vec[0]);\n+  offset_view vec (index.constant_pool.slice (index.symbol_vec_index (idx)));\n+  vec_len = vec[0];\n   for (vec_idx = 0; vec_idx < vec_len; ++vec_idx)\n     {\n-      offset_type cu_index_and_attrs = MAYBE_SWAP (vec[vec_idx + 1]);\n+      offset_type cu_index_and_attrs = vec[vec_idx + 1];\n       /* This value is only valid for index versions >= 7.  */\n       int is_static = GDB_INDEX_SYMBOL_STATIC_VALUE (cu_index_and_attrs);\n       gdb_index_symbol_kind symbol_kind ="
    }
  ]
}