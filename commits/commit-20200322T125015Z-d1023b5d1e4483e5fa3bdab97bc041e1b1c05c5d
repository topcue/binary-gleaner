{
  "sha": "d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDEwMjNiNWQxZTQ0ODNlNWZhM2JkYWI5N2JjMDQxZTFiMWMwNWM1ZA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-22T04:32:27Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-22T12:50:15Z"
    },
    "message": "s12z disassembler tidy\n\nDon't ignore buffer memory read failure, or malloc failure.  Lots of\nfunctions get a return status to pass these failures up the chain in\nthis patch.\n\nopcodes/\n\t* s12z-dis.c (abstract_read_memory): Don't print error on EOI.\n\t* s12z-opc.c: Formatting.\n\t(operands_f): Return an int.\n\t(opr_n_bytes_p1): Return -1 on reaching buffer memory limit.\n\t(opr_n_bytes2, bfextins_n_bytes, mul_n_bytes, bm_n_bytes),\n\t(shift_n_bytes, mov_imm_opr_n_bytes, loop_prim_n_bytes),\n\t(exg_sex_discrim): Likewise.\n\t(create_immediate_operand, create_bitfield_operand),\n\t(create_register_operand_with_size, create_register_all_operand),\n\t(create_register_all16_operand, create_simple_memory_operand),\n\t(create_memory_operand, create_memory_auto_operand): Don't\n\tsegfault on malloc failure.\n\t(z_ext24_decode): Return an int status, negative on fail, zero\n\ton success.\n\t(x_imm1, imm1_decode, trap_decode, z_opr_decode, z_opr_decode2),\n\t(imm1234, reg_s_imm, reg_s_opr, z_imm1234_8base, z_imm1234_0base),\n\t(z_tfr, z_reg, reg_xy, lea_reg_xys_opr, lea_reg_xys, rel_15_7),\n\t(decode_rel_15_7, cmp_xy, sub_d6_x_y, sub_d6_y_x),\n\t(ld_18bit_decode, mul_decode, bm_decode, bm_rel_decode),\n\t(mov_imm_opr, ld_18bit_decode, exg_sex_decode),\n\t(loop_primitive_decode, shift_decode, psh_pul_decode),\n\t(bit_field_decode): Similarly.\n\t(z_decode_signed_value, decode_signed_value): Similarly.  Add arg\n\tto return value, update callers.\n\t(x_opr_decode_with_size): Check all reads, returning NULL on fail.\n\tDon't segfault on NULL operand.\n\t(decode_operation): Return OP_INVALID on first fail.\n\t(decode_s12z): Check all reads, returning -1 on fail.\ngas/\n\t* testsuite/gas/s12z/truncated.d: Update expected output.",
    "tree": {
      "sha": "e56983195a13ceeaeda818485bdcbfd1e6c11387",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e56983195a13ceeaeda818485bdcbfd1e6c11387"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "da2efc2050edf4641a22462beeb4c6b9a1a827f2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/da2efc2050edf4641a22462beeb4c6b9a1a827f2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/da2efc2050edf4641a22462beeb4c6b9a1a827f2"
    }
  ],
  "stats": {
    "total": 1085,
    "additions": 765,
    "deletions": 320
  },
  "files": [
    {
      "sha": "dcac44c638ea4f361ac687f132305b6cf55e2fe1",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
      "patch": "@@ -1,3 +1,7 @@\n+2020-03-22  Alan Modra  <amodra@gmail.com>\n+\n+\t* testsuite/gas/s12z/truncated.d: Update expected output.\n+\n 2020-03-17  Sergey Belyashov  <sergey.belyashov@gmail.com>\n \n \tPR 25690"
    },
    {
      "sha": "f4bbb5903e9ecf3d1b29963c3412494f1fb2b8e9",
      "filename": "gas/testsuite/gas/s12z/truncated.d",
      "status": "modified",
      "additions": 1,
      "deletions": 5,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/gas/testsuite/gas/s12z/truncated.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/gas/testsuite/gas/s12z/truncated.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/s12z/truncated.d?ref=d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
      "patch": "@@ -10,8 +10,4 @@ Disassembly of section .text:\n \n 00000000 <.text>:\n    0:\t01          \tnop\n-   1:\tAddress 0x0000000000000002 is out of bounds.\n-Address 0x0000000000000002 is out of bounds.\n-Address 0x0000000000000002 is out of bounds.\n-!!invalid!!\n-\n+   1:\t14          \t!!invalid!!"
    },
    {
      "sha": "7ca7a644cdc18ec9aa0a97d6004fb7f3c23e3360",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
      "patch": "@@ -1,3 +1,34 @@\n+2020-03-22  Alan Modra  <amodra@gmail.com>\n+\n+\t* s12z-dis.c (abstract_read_memory): Don't print error on EOI.\n+\t* s12z-opc.c: Formatting.\n+\t(operands_f): Return an int.\n+\t(opr_n_bytes_p1): Return -1 on reaching buffer memory limit.\n+\t(opr_n_bytes2, bfextins_n_bytes, mul_n_bytes, bm_n_bytes),\n+\t(shift_n_bytes, mov_imm_opr_n_bytes, loop_prim_n_bytes),\n+\t(exg_sex_discrim): Likewise.\n+\t(create_immediate_operand, create_bitfield_operand),\n+\t(create_register_operand_with_size, create_register_all_operand),\n+\t(create_register_all16_operand, create_simple_memory_operand),\n+\t(create_memory_operand, create_memory_auto_operand): Don't\n+\tsegfault on malloc failure.\n+\t(z_ext24_decode): Return an int status, negative on fail, zero\n+\ton success.\n+\t(x_imm1, imm1_decode, trap_decode, z_opr_decode, z_opr_decode2),\n+\t(imm1234, reg_s_imm, reg_s_opr, z_imm1234_8base, z_imm1234_0base),\n+\t(z_tfr, z_reg, reg_xy, lea_reg_xys_opr, lea_reg_xys, rel_15_7),\n+\t(decode_rel_15_7, cmp_xy, sub_d6_x_y, sub_d6_y_x),\n+\t(ld_18bit_decode, mul_decode, bm_decode, bm_rel_decode),\n+\t(mov_imm_opr, ld_18bit_decode, exg_sex_decode),\n+\t(loop_primitive_decode, shift_decode, psh_pul_decode),\n+\t(bit_field_decode): Similarly.\n+\t(z_decode_signed_value, decode_signed_value): Similarly.  Add arg\n+\tto return value, update callers.\n+\t(x_opr_decode_with_size): Check all reads, returning NULL on fail.\n+\tDon't segfault on NULL operand.\n+\t(decode_operation): Return OP_INVALID on first fail.\n+\t(decode_s12z): Check all reads, returning -1 on fail.\n+\n 2020-03-20  Alan Modra  <amodra@gmail.com>\n \n \t* metag-dis.c (print_insn_metag): Don't ignore status from"
    },
    {
      "sha": "46d4d7c64cf99bf600ab1a84cee7758e17406524",
      "filename": "opcodes/s12z-dis.c",
      "status": "modified",
      "additions": 3,
      "deletions": 11,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/opcodes/s12z-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/opcodes/s12z-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/s12z-dis.c?ref=d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
      "patch": "@@ -59,16 +59,9 @@ abstract_read_memory (struct mem_read_abstraction_base *b,\n {\n   struct mem_read_abstraction *mra = (struct mem_read_abstraction *) b;\n \n-  int status =\n-    (*mra->info->read_memory_func) (mra->memaddr + offset,\n-\t\t\t\t    bytes, n, mra->info);\n-\n-  if (status != 0)\n-    {\n-      (*mra->info->memory_error_func) (status, mra->memaddr, mra->info);\n-      return -1;\n-    }\n-  return 0;\n+  int status = (*mra->info->read_memory_func) (mra->memaddr + offset,\n+\t\t\t\t\t       bytes, n, mra->info);\n+  return status != 0 ? -1 : 0;\n }\n \n /* Start of disassembly file.  */\n@@ -390,7 +383,6 @@ print_insn_s12z (bfd_vma memaddr, struct disassemble_info* info)\n \t      else\n \t\t(*mra.info->fprintf_func) (mra.info->stream, \"%c\",\n \t\t\t\t\t   shift_size_table[osize]);\n-\t\t\n \t    }\n \t}\n     }"
    },
    {
      "sha": "b68a4b815c42c69c4e4e6f6e25d6086f84147ad0",
      "filename": "opcodes/s12z-opc.c",
      "status": "modified",
      "additions": 726,
      "deletions": 304,
      "changes": 1030,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/opcodes/s12z-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d/opcodes/s12z-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/s12z-opc.c?ref=d1023b5d1e4483e5fa3bdab97bc041e1b1c05c5d",
      "patch": "@@ -31,13 +31,13 @@\n #include \"s12z-opc.h\"\n \n \n-typedef int (* insn_bytes_f) (struct mem_read_abstraction_base *);\n+typedef int (*insn_bytes_f) (struct mem_read_abstraction_base *);\n \n-typedef void (*operands_f) (struct mem_read_abstraction_base *,\n-\t\t\t    int *n_operands, struct operand **operand);\n+typedef int (*operands_f) (struct mem_read_abstraction_base *,\n+\t\t\t   int *n_operands, struct operand **operand);\n \n typedef enum optr (*discriminator_f) (struct mem_read_abstraction_base *,\n-\t\t\t\t\t  enum optr hint);\n+\t\t\t\t      enum optr hint);\n \n enum OPR_MODE\n   {\n@@ -127,15 +127,22 @@ x_opr_n_bytes (struct mem_read_abstraction_base *mra, int offset)\n static int\n opr_n_bytes_p1 (struct mem_read_abstraction_base *mra)\n {\n-  return 1 + x_opr_n_bytes (mra, 0);\n+  int n = x_opr_n_bytes (mra, 0);\n+  if (n < 0)\n+    return n;\n+  return 1 + n;\n }\n \n static int\n opr_n_bytes2 (struct mem_read_abstraction_base *mra)\n {\n   int s = x_opr_n_bytes (mra, 0);\n-  s += x_opr_n_bytes (mra, s);\n-  return s + 1;\n+  if (s < 0)\n+    return s;\n+  int n = x_opr_n_bytes (mra, s);\n+  if (n < 0)\n+    return n;\n+  return s + n + 1;\n }\n \n enum BB_MODE\n@@ -188,7 +195,12 @@ bfextins_n_bytes (struct mem_read_abstraction_base *mra)\n \n   int n = bbs->n_operands;\n   if (bbs->opr)\n-    n += x_opr_n_bytes (mra, n - 1);\n+    {\n+      int x = x_opr_n_bytes (mra, n - 1);\n+      if (x < 0)\n+\treturn x;\n+      n += x;\n+    }\n \n   return n;\n }\n@@ -261,10 +273,12 @@ create_immediate_operand (int value)\n {\n   struct immediate_operand *op = malloc (sizeof (*op));\n \n-  ((struct operand *)op)->cl = OPND_CL_IMMEDIATE;\n-  op->value = value;\n-  ((struct operand *)op)->osize = -1;\n-\n+  if (op != NULL)\n+    {\n+      op->parent.cl = OPND_CL_IMMEDIATE;\n+      op->parent.osize = -1;\n+      op->value = value;\n+    }\n   return (struct operand *) op;\n }\n \n@@ -273,11 +287,13 @@ create_bitfield_operand (int width, int offset)\n {\n   struct bitfield_operand *op = malloc (sizeof (*op));\n \n-  ((struct operand *)op)->cl = OPND_CL_BIT_FIELD;\n-  op->width = width;\n-  op->offset = offset;\n-  ((struct operand *)op)->osize = -1;\n-\n+  if (op != NULL)\n+    {\n+      op->parent.cl = OPND_CL_BIT_FIELD;\n+      op->parent.osize = -1;\n+      op->width = width;\n+      op->offset = offset;\n+    }\n   return (struct operand *) op;\n }\n \n@@ -286,10 +302,12 @@ create_register_operand_with_size (int reg, short osize)\n {\n   struct register_operand *op = malloc (sizeof (*op));\n \n-  ((struct operand *)op)->cl = OPND_CL_REGISTER;\n-  op->reg = reg;\n-  ((struct operand *)op)->osize = osize;\n-\n+  if (op != NULL)\n+    {\n+      op->parent.cl = OPND_CL_REGISTER;\n+      op->parent.osize = osize;\n+      op->reg = reg;\n+    }\n   return (struct operand *) op;\n }\n \n@@ -304,9 +322,11 @@ create_register_all_operand (void)\n {\n   struct register_operand *op = malloc (sizeof (*op));\n \n-  ((struct operand *)op)->cl = OPND_CL_REGISTER_ALL;\n-  ((struct operand *)op)->osize = -1;\n-\n+  if (op != NULL)\n+    {\n+      op->parent.cl = OPND_CL_REGISTER_ALL;\n+      op->parent.osize = -1;\n+    }\n   return (struct operand *) op;\n }\n \n@@ -315,26 +335,30 @@ create_register_all16_operand (void)\n {\n   struct register_operand *op = malloc (sizeof (*op));\n \n-  ((struct operand *)op)->cl = OPND_CL_REGISTER_ALL16;\n-  ((struct operand *)op)->osize = -1;\n-\n+  if (op != NULL)\n+    {\n+      op->parent.cl = OPND_CL_REGISTER_ALL16;\n+      op->parent.osize = -1;\n+    }\n   return (struct operand *) op;\n }\n \n \n static struct operand *\n create_simple_memory_operand (bfd_vma addr, bfd_vma base, bool relative)\n {\n-  struct simple_memory_operand *op = malloc (sizeof (*op));\n-\n-  ((struct operand *)op)->cl = OPND_CL_SIMPLE_MEMORY;\n-  op->addr = addr;\n-  op->base = base;\n-  op->relative = relative;\n-  ((struct operand *)op)->osize = -1;\n+  struct simple_memory_operand *op;\n \n   assert (relative || base == 0);\n-\n+  op = malloc (sizeof (*op));\n+  if (op != NULL)\n+    {\n+      op->parent.cl = OPND_CL_SIMPLE_MEMORY;\n+      op->parent.osize = -1;\n+      op->addr = addr;\n+      op->base = base;\n+      op->relative = relative;\n+    }\n   return (struct operand *) op;\n }\n \n@@ -343,15 +367,17 @@ create_memory_operand (bool indirect, int base, int n_regs, int reg0, int reg1)\n {\n   struct memory_operand *op = malloc (sizeof (*op));\n \n-  ((struct operand *)op)->cl = OPND_CL_MEMORY;\n-  op->indirect = indirect;\n-  op->base_offset = base;\n-  op->mutation = OPND_RM_NONE;\n-  op->n_regs = n_regs;\n-  op->regs[0] = reg0;\n-  op->regs[1] = reg1;\n-  ((struct operand *)op)->osize = -1;\n-\n+  if (op != NULL)\n+    {\n+      op->parent.cl = OPND_CL_MEMORY;\n+      op->parent.osize = -1;\n+      op->indirect = indirect;\n+      op->base_offset = base;\n+      op->mutation = OPND_RM_NONE;\n+      op->n_regs = n_regs;\n+      op->regs[0] = reg0;\n+      op->regs[1] = reg1;\n+    }\n   return (struct operand *) op;\n }\n \n@@ -360,28 +386,31 @@ create_memory_auto_operand (enum op_reg_mutation mutation, int reg)\n {\n   struct memory_operand *op = malloc (sizeof (*op));\n \n-  ((struct operand *)op)->cl = OPND_CL_MEMORY;\n-  op->indirect = false;\n-  op->base_offset = 0;\n-  op->mutation = mutation;\n-  op->n_regs = 1;\n-  op->regs[0] = reg;\n-  op->regs[1] = -1;\n-  ((struct operand *)op)->osize = -1;\n-\n+  if (op != NULL)\n+    {\n+      op->parent.cl = OPND_CL_MEMORY;\n+      op->parent.osize = -1;\n+      op->indirect = false;\n+      op->base_offset = 0;\n+      op->mutation = mutation;\n+      op->n_regs = 1;\n+      op->regs[0] = reg;\n+      op->regs[1] = -1;\n+    }\n   return (struct operand *) op;\n }\n \n \f\n \n-static void\n+static int\n z_ext24_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n \t\tstruct operand **operand)\n {\n+  struct operand *op;\n   uint8_t buffer[3];\n   int status = mra->read (mra, 0, 3, buffer);\n   if (status < 0)\n-    return;\n+    return status;\n \n   int i;\n   uint32_t addr = 0;\n@@ -391,21 +420,24 @@ z_ext24_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n       addr |= buffer[i];\n     }\n \n-  operand[(*n_operands)++] = create_simple_memory_operand (addr, 0, false);\n+  op = create_simple_memory_operand (addr, 0, false);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n \n-static uint32_t\n+static int\n z_decode_signed_value (struct mem_read_abstraction_base *mra, int offset,\n-\t\t       short size)\n+\t\t       short size, uint32_t *result)\n {\n   assert (size >0);\n   assert (size <= 4);\n   bfd_byte buffer[4];\n-  if (0 > mra->read (mra, offset, size, buffer))\n-    {\n-      return 0;\n-    }\n+  int status = mra->read (mra, offset, size, buffer);\n+  if (status < 0)\n+    return status;\n \n   int i;\n   uint32_t value = 0;\n@@ -415,43 +447,50 @@ z_decode_signed_value (struct mem_read_abstraction_base *mra, int offset,\n   if (buffer[0] & 0x80)\n     {\n       /* Deal with negative values */\n-      value -= 0x1UL << (size * 8);\n+      value -= 1u << (size * 4) << (size * 4);\n     }\n-  return value;\n+  *result = value;\n+  return 0;\n }\n \n-static uint32_t\n-decode_signed_value (struct mem_read_abstraction_base *mra, short size)\n+static int\n+decode_signed_value (struct mem_read_abstraction_base *mra, short size,\n+\t\t     uint32_t *result)\n {\n-  return z_decode_signed_value (mra, 0, size);\n+  return z_decode_signed_value (mra, 0, size, result);\n }\n \n-static void\n+static int\n x_imm1 (struct mem_read_abstraction_base *mra,\n \tint offset,\n \tint *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   bfd_byte byte;\n   int status = mra->read (mra, offset, 1, &byte);\n   if (status < 0)\n-    return;\n+    return status;\n \n-  operand[(*n_operands)++] = create_immediate_operand (byte);\n+  op = create_immediate_operand (byte);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n /* An eight bit immediate operand.  */\n-static void\n+static int\n imm1_decode (struct mem_read_abstraction_base *mra,\n \t     int *n_operands, struct operand **operand)\n {\n-  x_imm1 (mra, 0, n_operands, operand);\n+  return x_imm1 (mra, 0, n_operands, operand);\n }\n \n-static void\n+static int\n trap_decode (struct mem_read_abstraction_base *mra,\n \t     int *n_operands, struct operand **operand)\n {\n-  x_imm1 (mra, -1, n_operands, operand);\n+  return x_imm1 (mra, -1, n_operands, operand);\n }\n \n \n@@ -520,7 +559,9 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n     case OPR_IDX_INDIRECT:\n       {\n \tuint8_t x1;\n-\tmra->read (mra, offset, 1, &x1);\n+\tstatus = mra->read (mra, offset, 1, &x1);\n+\tif (status < 0)\n+\t  return NULL;\n \tint idx = x1;\n \n \tif (postbyte & 0x01)\n@@ -537,7 +578,9 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n     case OPR_IDX3_DIRECT:\n       {\n \tuint8_t x[3];\n-\tmra->read (mra, offset, 3, x);\n+\tstatus = mra->read (mra, offset, 3, x);\n+\tif (status < 0)\n+\t  return NULL;\n \tint idx = x[0] << 16 | x[1] << 8 | x[2];\n \n \tif (x[0] & 0x80)\n@@ -554,7 +597,9 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n     case OPR_IDX3_DIRECT_REG:\n       {\n \tuint8_t x[3];\n-\tmra->read (mra, offset, 3, x);\n+\tstatus = mra->read (mra, offset, 3, x);\n+\tif (status < 0)\n+\t  return NULL;\n \tint idx = x[0] << 16 | x[1] << 8 | x[2];\n \n \tif (x[0] & 0x80)\n@@ -570,7 +615,9 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n     case OPR_IDX3_INDIRECT:\n       {\n \tuint8_t x[3];\n-\tmra->read (mra, offset, 3, x);\n+\tstatus = mra->read (mra, offset, 3, x);\n+\tif (status < 0)\n+\t  return NULL;\n \tint idx = x[0] << 16 | x[1] << 8 | x[2];\n \n \tif (x[0] & 0x80)\n@@ -587,7 +634,9 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n     case OPR_IDX_DIRECT:\n       {\n \tuint8_t x1;\n-\tmra->read (mra, offset, 1, &x1);\n+\tstatus = mra->read (mra, offset, 1, &x1);\n+\tif (status < 0)\n+\t  return NULL;\n \tint idx = x1;\n \n \tif (postbyte & 0x01)\n@@ -604,7 +653,9 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n     case OPR_IDX2_REG:\n       {\n \tuint8_t x[2];\n-\tmra->read (mra, offset, 2, x);\n+\tstatus = mra->read (mra, offset, 2, x);\n+\tif (status < 0)\n+\t  return NULL;\n \tuint32_t idx = x[1] | x[0] << 8 ;\n \tidx |= (postbyte & 0x30) << 12;\n \n@@ -653,7 +704,7 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n \tbfd_byte buffer[4];\n \tstatus = mra->read (mra, offset, size, buffer);\n \tif (status < 0)\n-\t  operand = NULL;\n+\t  return NULL;\n \n \tuint32_t ext18 = 0;\n \tfor (i = 0; i < size; ++i)\n@@ -672,7 +723,9 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n     case OPR_EXT1:\n       {\n \tuint8_t x1 = 0;\n-\tmra->read (mra, offset, 1, &x1);\n+\tstatus = mra->read (mra, offset, 1, &x1);\n+\tif (status < 0)\n+\t  return NULL;\n \tint16_t addr;\n \taddr = x1;\n \taddr |= (postbyte & 0x3f) << 8;\n@@ -687,7 +740,7 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n \tbfd_byte buffer[4];\n \tstatus = mra->read (mra, offset, size, buffer);\n \tif (status < 0)\n-\t  operand = NULL;\n+\t  return NULL;\n \n \tuint32_t ext24 = 0;\n \tfor (i = 0; i < size; ++i)\n@@ -705,7 +758,7 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n \tbfd_byte buffer[4];\n \tstatus = mra->read (mra, offset, size, buffer);\n \tif (status < 0)\n-\t  operand = NULL;\n+\t  return NULL;\n \n \tuint32_t ext24 = 0;\n \tfor (i = 0; i < size; ++i)\n@@ -722,7 +775,8 @@ x_opr_decode_with_size (struct mem_read_abstraction_base *mra, int offset,\n       abort ();\n     }\n \n-  operand->osize = osize;\n+  if (operand != NULL)\n+    operand->osize = osize;\n \n   return operand;\n }\n@@ -733,124 +787,181 @@ x_opr_decode (struct mem_read_abstraction_base *mra, int offset)\n   return x_opr_decode_with_size (mra, offset, -1);\n }\n \n-static void\n+static int\n z_opr_decode (struct mem_read_abstraction_base *mra,\n \t      int *n_operands, struct operand **operand)\n {\n-  operand[(*n_operands)++] = x_opr_decode (mra, 0);\n+  struct operand *op = x_opr_decode (mra, 0);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n z_opr_decode2 (struct mem_read_abstraction_base *mra,\n \t       int *n_operands, struct operand **operand)\n {\n   int n = x_opr_n_bytes (mra, 0);\n-\n-  operand[(*n_operands)++] = x_opr_decode (mra, 0);\n-  operand[(*n_operands)++] = x_opr_decode (mra, n);\n+  if (n < 0)\n+    return n;\n+  struct operand *op = x_opr_decode (mra, 0);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = x_opr_decode (mra, n);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n imm1234 (struct mem_read_abstraction_base *mra, int base,\n \t int *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   bfd_byte opcode;\n   int status = mra->read (mra, -1, 1, &opcode);\n   if (status < 0)\n-    return;\n+    return status;\n \n   opcode -= base;\n \n   int size = registers[opcode & 0xF].bytes;\n \n-  uint32_t imm = decode_signed_value (mra, size);\n+  uint32_t imm;\n+  if (decode_signed_value (mra, size, &imm) < 0)\n+    return -1;\n \n-  operand[(*n_operands)++] = create_immediate_operand (imm);\n+  op = create_immediate_operand (imm);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n \n /* Special case of LD and CMP with register S and IMM operand */\n-static void\n+static int\n reg_s_imm (struct mem_read_abstraction_base *mra, int *n_operands,\n \t   struct operand **operand)\n {\n-  operand[(*n_operands)++] = create_register_operand (REG_S);\n+  struct operand *op;\n+\n+  op = create_register_operand (REG_S);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n \n-  uint32_t imm = decode_signed_value (mra, 3);\n-  operand[(*n_operands)++] = create_immediate_operand (imm);\n+  uint32_t imm;\n+  if (decode_signed_value (mra, 3, &imm) < 0)\n+    return -1;\n+  op = create_immediate_operand (imm);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n /* Special case of LD, CMP and ST with register S and OPR operand */\n-static void\n+static int\n reg_s_opr (struct mem_read_abstraction_base *mra, int *n_operands,\n \t   struct operand **operand)\n {\n-  operand[(*n_operands)++] = create_register_operand (REG_S);\n-  operand[(*n_operands)++] = x_opr_decode (mra, 0);\n+  struct operand *op;\n+\n+  op = create_register_operand (REG_S);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = x_opr_decode (mra, 0);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n z_imm1234_8base (struct mem_read_abstraction_base *mra, int *n_operands,\n \t\t struct operand **operand)\n {\n-  imm1234 (mra, 8, n_operands, operand);\n+  return imm1234 (mra, 8, n_operands, operand);\n }\n \n-static void\n+static int\n z_imm1234_0base (struct mem_read_abstraction_base *mra, int *n_operands,\n \t\t struct operand **operand)\n {\n-  imm1234 (mra, 0, n_operands, operand);\n+  return imm1234 (mra, 0, n_operands, operand);\n }\n \n \n-static void\n+static int\n z_tfr (struct mem_read_abstraction_base *mra, int *n_operands,\n        struct operand **operand)\n {\n+  struct operand *op;\n   bfd_byte byte;\n   int status = mra->read (mra, 0, 1, &byte);\n   if (status < 0)\n-    return;\n+    return status;\n \n-  operand[(*n_operands)++] = create_register_operand (byte >> 4);\n-  operand[(*n_operands)++] = create_register_operand (byte & 0x0F);\n+  op = create_register_operand (byte >> 4);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = create_register_operand (byte & 0x0F);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n z_reg (struct mem_read_abstraction_base *mra, int *n_operands,\n        struct operand **operand)\n {\n+  struct operand *op;\n   bfd_byte byte;\n   int status = mra->read (mra, -1, 1, &byte);\n   if (status < 0)\n-    return;\n+    return status;\n \n-  operand[(*n_operands)++] = create_register_operand (byte & 0x07);\n+  op = create_register_operand (byte & 0x07);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n \n-static void\n+static int\n reg_xy (struct mem_read_abstraction_base *mra,\n \tint *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   bfd_byte byte;\n   int status = mra->read (mra, -1, 1, &byte);\n   if (status < 0)\n-    return;\n+    return status;\n \n-  operand[(*n_operands)++] =\n-    create_register_operand ((byte & 0x01) ? REG_Y : REG_X);\n+  op = create_register_operand ((byte & 0x01) ? REG_Y : REG_X);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n lea_reg_xys_opr (struct mem_read_abstraction_base *mra,\n \t\t int *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   bfd_byte byte;\n   int status = mra->read (mra, -1, 1, &byte);\n   if (status < 0)\n-    return;\n+    return status;\n \n   int reg_xys = -1;\n   switch (byte & 0x03)\n@@ -866,18 +977,26 @@ lea_reg_xys_opr (struct mem_read_abstraction_base *mra,\n       break;\n     }\n \n-  operand[(*n_operands)++] = create_register_operand (reg_xys);\n-  operand[(*n_operands)++] = x_opr_decode (mra, 0);\n+  op = create_register_operand (reg_xys);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = x_opr_decode (mra, 0);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n lea_reg_xys (struct mem_read_abstraction_base *mra,\n \t     int *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   bfd_byte byte;\n   int status = mra->read (mra, -1, 1, &byte);\n   if (status < 0)\n-    return;\n+    return status;\n \n   int reg_n = -1;\n   switch (byte & 0x03)\n@@ -895,23 +1014,30 @@ lea_reg_xys (struct mem_read_abstraction_base *mra,\n \n   status = mra->read (mra, 0, 1, &byte);\n   if (status < 0)\n-    return;\n+    return status;\n \n-  operand[(*n_operands)++] = create_register_operand (reg_n);\n-  operand[(*n_operands)++] = create_memory_operand (false, (int8_t) byte,\n-\t\t\t\t\t\t    1, reg_n, -1);\n+  op = create_register_operand (reg_n);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = create_memory_operand (false, (int8_t) byte, 1, reg_n, -1);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n \n /* PC Relative offsets of size 15 or 7 bits */\n-static void\n+static int\n rel_15_7 (struct mem_read_abstraction_base *mra, int offset,\n \t  int *n_operands, struct operand **operands)\n {\n+  struct operand *op;\n   bfd_byte upper;\n   int status = mra->read (mra, offset - 1, 1, &upper);\n   if (status < 0)\n-    return;\n+    return status;\n \n   bool rel_size = (upper & 0x80);\n \n@@ -922,7 +1048,7 @@ rel_15_7 (struct mem_read_abstraction_base *mra, int offset,\n       bfd_byte lower;\n       status = mra->read (mra, offset, 1, &lower);\n       if (status < 0)\n-\treturn;\n+\treturn status;\n \n       addr <<= 8;\n       addr |= lower;\n@@ -942,17 +1068,20 @@ rel_15_7 (struct mem_read_abstraction_base *mra, int offset,\n \taddr = addr - 0x40;\n     }\n \n-  operands[(*n_operands)++] =\n-    create_simple_memory_operand (addr, mra->posn (mra) - 1, true);\n+  op = create_simple_memory_operand (addr, mra->posn (mra) - 1, true);\n+  if (op == NULL)\n+    return -1;\n+  operands[(*n_operands)++] = op;\n+  return 0;\n }\n \n \n /* PC Relative offsets of size 15 or 7 bits */\n-static void\n+static int\n decode_rel_15_7 (struct mem_read_abstraction_base *mra,\n \t\t int *n_operands, struct operand **operand)\n {\n-  rel_15_7 (mra, 1, n_operands, operand);\n+  return rel_15_7 (mra, 1, n_operands, operand);\n }\n \n static int shift_n_bytes (struct mem_read_abstraction_base *);\n@@ -962,15 +1091,15 @@ static int bm_rel_n_bytes (struct mem_read_abstraction_base *);\n static int mul_n_bytes (struct mem_read_abstraction_base *);\n static int bm_n_bytes (struct mem_read_abstraction_base *);\n \n-static void psh_pul_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n-static void shift_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n-static void mul_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n-static void bm_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n-static void bm_rel_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n-static void mov_imm_opr (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n-static void loop_primitive_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n-static void bit_field_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n-static void exg_sex_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n+static int psh_pul_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static int shift_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static int mul_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static int bm_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static int bm_rel_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static int mov_imm_opr (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operand);\n+static int loop_primitive_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n+static int bit_field_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n+static int exg_sex_decode (struct mem_read_abstraction_base *mra, int *n_operands, struct operand **operands);\n \n \n static enum optr shift_discrim (struct mem_read_abstraction_base *mra, enum optr hint);\n@@ -981,33 +1110,66 @@ static enum optr bit_field_discrim (struct mem_read_abstraction_base *mra, enum\n static enum optr exg_sex_discrim (struct mem_read_abstraction_base *mra, enum optr hint);\n \n \n-static void\n+static int\n cmp_xy (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,\n \tint *n_operands, struct operand **operand)\n {\n-  operand[(*n_operands)++] = create_register_operand (REG_X);\n-  operand[(*n_operands)++] = create_register_operand (REG_Y);\n+  struct operand *op;\n+\n+  op = create_register_operand (REG_X);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = create_register_operand (REG_Y);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n sub_d6_x_y (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,\n \t    int *n_operands, struct operand **operand)\n {\n-  operand[(*n_operands)++] = create_register_operand (REG_D6);\n-  operand[(*n_operands)++] = create_register_operand (REG_X);\n-  operand[(*n_operands)++] = create_register_operand (REG_Y);\n+  struct operand *op;\n+\n+  op = create_register_operand (REG_D6);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = create_register_operand (REG_X);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = create_register_operand (REG_Y);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n sub_d6_y_x (struct mem_read_abstraction_base *mra ATTRIBUTE_UNUSED,\n \t    int *n_operands, struct operand **operand)\n {\n-  operand[(*n_operands)++] = create_register_operand (REG_D6);\n-  operand[(*n_operands)++] = create_register_operand (REG_Y);\n-  operand[(*n_operands)++] = create_register_operand (REG_X);\n+  struct operand *op;\n+\n+  op = create_register_operand (REG_D6);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = create_register_operand (REG_Y);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = create_register_operand (REG_X);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n-static void\n+static int\n ld_18bit_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n \t\t struct operand **operand);\n \n@@ -1628,19 +1790,20 @@ static const struct mb mul_table[] = {\n };\n \n \n-static void\n+static int\n mul_decode (struct mem_read_abstraction_base *mra,\n \t    int *n_operands, struct operand **operand)\n {\n   uint8_t mb;\n+  struct operand *op;\n   int status = mra->read (mra, 0, 1, &mb);\n   if (status < 0)\n-    return;\n+    return status;\n \n   uint8_t byte;\n   status = mra->read (mra, -1, 1, &byte);\n   if (status < 0)\n-    return;\n+    return status;\n \n   enum MUL_MODE mode = -1;\n   size_t i;\n@@ -1653,48 +1816,79 @@ mul_decode (struct mem_read_abstraction_base *mra,\n \t  break;\n \t}\n     }\n-  operand[(*n_operands)++] = create_register_operand (byte & 0x07);\n+  op = create_register_operand (byte & 0x07);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n \n   switch (mode)\n     {\n     case MUL_REG_IMM:\n       {\n \tint size = (mb & 0x3);\n-\toperand[(*n_operands)++] =\n-\t  create_register_operand_with_size ((mb & 0x38) >> 3, size);\n-\tuint32_t imm = z_decode_signed_value (mra, 1, size + 1);\n-\toperand[(*n_operands)++] = create_immediate_operand (imm);\n+\top = create_register_operand_with_size ((mb & 0x38) >> 3, size);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperand[(*n_operands)++] = op;\n+\n+\tuint32_t imm;\n+\tif (z_decode_signed_value (mra, 1, size + 1, &imm) < 0)\n+\t  return -1;\n+\top = create_immediate_operand (imm);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperand[(*n_operands)++] = op;\n       }\n       break;\n     case MUL_REG_REG:\n-      operand[(*n_operands)++] = create_register_operand ((mb & 0x38) >> 3);\n-      operand[(*n_operands)++] = create_register_operand (mb & 0x07);\n+      op = create_register_operand ((mb & 0x38) >> 3);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n+      op = create_register_operand (mb & 0x07);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case MUL_REG_OPR:\n-      operand[(*n_operands)++] = create_register_operand ((mb & 0x38) >> 3);\n-      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, mb & 0x3);\n+      op = create_register_operand ((mb & 0x38) >> 3);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n+      op = x_opr_decode_with_size (mra, 1, mb & 0x3);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case MUL_OPR_OPR:\n       {\n \tint first = x_opr_n_bytes (mra, 1);\n-\toperand[(*n_operands)++] = x_opr_decode_with_size (mra, 1,\n-\t\t\t\t\t\t\t   (mb & 0x30) >> 4);\n-\toperand[(*n_operands)++] = x_opr_decode_with_size (mra, first + 1,\n-\t\t\t\t\t\t\t   (mb & 0x0c) >> 2);\n+\tif (first < 0)\n+\t  return first;\n+\top = x_opr_decode_with_size (mra, 1, (mb & 0x30) >> 4);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperand[(*n_operands)++] = op;\n+\top = x_opr_decode_with_size (mra, first + 1, (mb & 0x0c) >> 2);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperand[(*n_operands)++] = op;\n \tbreak;\n       }\n     }\n+  return 0;\n }\n \n \n static int\n mul_n_bytes (struct mem_read_abstraction_base *mra)\n {\n   int nx = 2;\n+  int first, second;\n   uint8_t mb;\n   int status = mra->read (mra, 0, 1, &mb);\n   if (status < 0)\n-    return 0;\n+    return status;\n \n   enum MUL_MODE mode = -1;\n   size_t i;\n@@ -1718,15 +1912,20 @@ mul_n_bytes (struct mem_read_abstraction_base *mra)\n     case MUL_REG_REG:\n       break;\n     case MUL_REG_OPR:\n-      nx += x_opr_n_bytes (mra, 1);\n+      first = x_opr_n_bytes (mra, 1);\n+      if (first < 0)\n+\treturn first;\n+      nx += first;\n       break;\n     case MUL_OPR_OPR:\n-      {\n-\tint first = x_opr_n_bytes (mra, nx - 1);\n-\tnx += first;\n-\tint second = x_opr_n_bytes (mra, nx - 1);\n-\tnx += second;\n-      }\n+      first = x_opr_n_bytes (mra, nx - 1);\n+      if (first < 0)\n+\treturn first;\n+      nx += first;\n+      second = x_opr_n_bytes (mra, nx - 1);\n+      if (second < 0)\n+\treturn second;\n+      nx += second;\n       break;\n     }\n \n@@ -1772,14 +1971,15 @@ static const  struct bm bm_table[] = {\n   { 0x87, 0x84,     BM_RESERVED1},\n };\n \n-static void\n+static int\n bm_decode (struct mem_read_abstraction_base *mra,\n \t   int *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   uint8_t bm;\n   int status = mra->read (mra, 0, 1, &bm);\n   if (status < 0)\n-    return;\n+    return status;\n \n   size_t i;\n   enum BM_MODE mode = -1;\n@@ -1797,28 +1997,44 @@ bm_decode (struct mem_read_abstraction_base *mra,\n     {\n     case BM_REG_IMM:\n     case BM_RESERVED0:\n-      operand[(*n_operands)++] = create_register_operand (bm & 0x07);\n+      op = create_register_operand (bm & 0x07);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_OPR_B:\n-      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 0);\n+      op = x_opr_decode_with_size (mra, 1, 0);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_OPR_W:\n-      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 1);\n+      op = x_opr_decode_with_size (mra, 1, 1);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_OPR_L:\n-      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 3);\n+      op = x_opr_decode_with_size (mra, 1, 3);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_OPR_REG:\n     case BM_RESERVED1:\n       {\n \tuint8_t xb;\n-\tmra->read (mra, 1, 1, &xb);\n+\tstatus = mra->read (mra, 1, 1, &xb);\n+\tif (status < 0)\n+\t  return status;\n \t/* Don't emit a size suffix for register operands */\n \tif ((xb & 0xF8) != 0xB8)\n-\t  operand[(*n_operands)++] =\n-\t    x_opr_decode_with_size (mra, 1, (bm & 0x0c) >> 2);\n+\t  op = x_opr_decode_with_size (mra, 1, (bm & 0x0c) >> 2);\n \telse\n-\t  operand[(*n_operands)++] = x_opr_decode (mra, 1);\n+\t  op = x_opr_decode (mra, 1);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperand[(*n_operands)++] = op;\n       }\n       break;\n     }\n@@ -1829,7 +2045,10 @@ bm_decode (struct mem_read_abstraction_base *mra,\n     case BM_REG_IMM:\n     case BM_RESERVED0:\n       imm = (bm & 0x38) >> 3;\n-      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      op = create_immediate_operand (imm);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_OPR_L:\n       imm |= (bm & 0x03) << 3;\n@@ -1839,24 +2058,32 @@ bm_decode (struct mem_read_abstraction_base *mra,\n       /* fallthrough */\n     case BM_OPR_B:\n       imm |= (bm & 0x70) >> 4;\n-      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      op = create_immediate_operand (imm);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_OPR_REG:\n     case BM_RESERVED1:\n-      operand[(*n_operands)++] = create_register_operand ((bm & 0x70) >> 4);\n+      op = create_register_operand ((bm & 0x70) >> 4);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     }\n+  return 0;\n }\n \n \n-static void\n+static int\n bm_rel_decode (struct mem_read_abstraction_base *mra,\n \t       int *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   uint8_t bm;\n   int status = mra->read (mra, 0, 1, &bm);\n   if (status < 0)\n-    return;\n+    return status;\n \n   size_t i;\n   enum BM_MODE mode = -1;\n@@ -1875,39 +2102,64 @@ bm_rel_decode (struct mem_read_abstraction_base *mra,\n     {\n     case BM_REG_IMM:\n     case BM_RESERVED0:\n-      operand[(*n_operands)++] = create_register_operand (bm & 0x07);\n+      op = create_register_operand (bm & 0x07);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_OPR_B:\n-      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 0);\n-      n = 1 + x_opr_n_bytes (mra, 1);\n+      op = x_opr_decode_with_size (mra, 1, 0);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n+      n = x_opr_n_bytes (mra, 1);\n+      if (n < 0)\n+\treturn n;\n+      n += 1;\n       break;\n     case BM_OPR_W:\n-      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 1);\n-      n = 1 + x_opr_n_bytes (mra, 1);\n+      op = x_opr_decode_with_size (mra, 1, 1);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n+      n = x_opr_n_bytes (mra, 1);\n+      if (n < 0)\n+\treturn n;\n+      n += 1;\n       break;\n     case BM_OPR_L:\n-      operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, 3);\n-      n = 1 + x_opr_n_bytes (mra, 1);\n+      op = x_opr_decode_with_size (mra, 1, 3);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n+      n = x_opr_n_bytes (mra, 1);\n+      if (n < 0)\n+\treturn n;\n+      n += 1;\n       break;\n     case BM_OPR_REG:\n     case BM_RESERVED1:\n       {\n \tuint8_t xb;\n-\tmra->read (mra, +1, 1, &xb);\n+\tstatus = mra->read (mra, +1, 1, &xb);\n+\tif (status < 0)\n+\t  return status;\n \t/* Don't emit a size suffix for register operands */\n \tif ((xb & 0xF8) != 0xB8)\n \t  {\n \t    short os = (bm & 0x0c) >> 2;\n-\t    operand[(*n_operands)++] = x_opr_decode_with_size (mra, 1, os);\n+\t    op = x_opr_decode_with_size (mra, 1, os);\n \t  }\n \telse\n-\t  operand[(*n_operands)++] = x_opr_decode (mra, 1);\n-\n+\t  op = x_opr_decode (mra, 1);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperand[(*n_operands)++] = op;\n       }\n       break;\n     }\n \n-  int imm = 0;\n+  int x, imm = 0;\n   switch (mode)\n     {\n     case BM_OPR_L:\n@@ -1918,24 +2170,39 @@ bm_rel_decode (struct mem_read_abstraction_base *mra,\n       /* fall through */\n     case BM_OPR_B:\n       imm |= (bm & 0x70) >> 4;\n-      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      op = create_immediate_operand (imm);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_RESERVED0:\n       imm = (bm & 0x38) >> 3;\n-      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      op = create_immediate_operand (imm);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_REG_IMM:\n       imm = (bm & 0xF8) >> 3;\n-      operand[(*n_operands)++] = create_immediate_operand (imm);\n+      op = create_immediate_operand (imm);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n       break;\n     case BM_OPR_REG:\n     case BM_RESERVED1:\n-      operand[(*n_operands)++] = create_register_operand ((bm & 0x70) >> 4);\n-      n += x_opr_n_bytes (mra, 1);\n+      op = create_register_operand ((bm & 0x70) >> 4);\n+      if (op == NULL)\n+\treturn -1;\n+      operand[(*n_operands)++] = op;\n+      x = x_opr_n_bytes (mra, 1);\n+      if (x < 0)\n+\treturn x;\n+      n += x;\n       break;\n     }\n \n-  rel_15_7 (mra, n + 1, n_operands, operand);\n+  return rel_15_7 (mra, n + 1, n_operands, operand);\n }\n \n static int\n@@ -1958,7 +2225,7 @@ bm_n_bytes (struct mem_read_abstraction_base *mra)\n \t}\n     }\n \n-  int n = 2;\n+  int n = 0;\n   switch (mode)\n     {\n     case BM_REG_IMM:\n@@ -1968,15 +2235,15 @@ bm_n_bytes (struct mem_read_abstraction_base *mra)\n     case BM_OPR_B:\n     case BM_OPR_W:\n     case BM_OPR_L:\n-      n += x_opr_n_bytes (mra, 1);\n-      break;\n     case BM_OPR_REG:\n     case BM_RESERVED1:\n-      n += x_opr_n_bytes (mra, 1);\n+      n = x_opr_n_bytes (mra, 1);\n+      if (n < 0)\n+\treturn n;\n       break;\n     }\n \n-  return n;\n+  return n + 2;\n }\n \n static int\n@@ -2043,6 +2310,7 @@ static int\n shift_n_bytes (struct mem_read_abstraction_base *mra)\n {\n   bfd_byte sb;\n+  int opr1, opr2;\n   int status = mra->read (mra, 0, 1, &sb);\n   if (status != 0)\n     return status;\n@@ -2060,20 +2328,24 @@ shift_n_bytes (struct mem_read_abstraction_base *mra)\n     {\n     case SB_REG_REG_N_EFF:\n       return 2;\n-      break;\n     case SB_REG_OPR_EFF:\n     case SB_ROT:\n-      return 2 + x_opr_n_bytes (mra, 1);\n-      break;\n+      opr1 = x_opr_n_bytes (mra, 1);\n+      if (opr1 < 0)\n+\treturn opr1;\n+      return 2 + opr1;\n     case SB_REG_OPR_OPR:\n-      {\n-\tint opr1 = x_opr_n_bytes (mra, 1);\n-\tint opr2 = 0;\n-\tif ((sb & 0x30) != 0x20)\n+      opr1 = x_opr_n_bytes (mra, 1);\n+      if (opr1 < 0)\n+\treturn opr1;\n+      opr2 = 0;\n+      if ((sb & 0x30) != 0x20)\n+\t{\n \t  opr2 = x_opr_n_bytes (mra, opr1 + 1);\n-\treturn 2 + opr1 + opr2;\n-      }\n-      break;\n+\t  if (opr2 < 0)\n+\t    return opr2;\n+\t}\n+      return 2 + opr1 + opr2;\n     default:\n       return 3;\n     }\n@@ -2084,50 +2356,63 @@ shift_n_bytes (struct mem_read_abstraction_base *mra)\n \f\n \n static int\n-\n mov_imm_opr_n_bytes (struct mem_read_abstraction_base *mra)\n {\n   bfd_byte byte;\n-  int status = mra->read (mra, -1, 1,  &byte);\n+  int status = mra->read (mra, -1, 1, &byte);\n   if (status < 0)\n     return status;\n \n   int size = byte - 0x0c + 1;\n+  int n = x_opr_n_bytes (mra, size);\n+  if (n < 0)\n+    return n;\n \n-  return size + x_opr_n_bytes (mra, size) + 1;\n+  return size + n + 1;\n }\n \n-static void\n+static int\n mov_imm_opr (struct mem_read_abstraction_base *mra,\n \t     int *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   bfd_byte byte;\n   int status = mra->read (mra, -1, 1, &byte);\n   if (status < 0)\n-    return ;\n+    return status;\n \n   int size = byte - 0x0c + 1;\n-  uint32_t imm = decode_signed_value (mra, size);\n+  uint32_t imm;\n+  if (decode_signed_value (mra, size, &imm))\n+    return -1;\n \n-  operand[(*n_operands)++] = create_immediate_operand (imm);\n-  operand[(*n_operands)++] = x_opr_decode (mra, size);\n+  op = create_immediate_operand (imm);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  op = x_opr_decode (mra, size);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n \f\n \n-static void\n+static int\n ld_18bit_decode (struct mem_read_abstraction_base *mra,\n \t\t int *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   size_t size = 3;\n   bfd_byte buffer[3];\n   int status = mra->read (mra, 0, 2, buffer + 1);\n   if (status < 0)\n-    return ;\n+    return status;\n \n   status = mra->read (mra, -1, 1, buffer);\n   if (status < 0)\n-    return ;\n+    return status;\n \n   buffer[0] = (buffer[0] & 0x30) >> 4;\n \n@@ -2138,7 +2423,11 @@ ld_18bit_decode (struct mem_read_abstraction_base *mra,\n       imm |= buffer[i] << (8 * (size - i - 1));\n     }\n \n-  operand[(*n_operands)++] = create_immediate_operand (imm);\n+  op = create_immediate_operand (imm);\n+  if (op == NULL)\n+    return -1;\n+  operand[(*n_operands)++] = op;\n+  return 0;\n }\n \n \f\n@@ -2170,7 +2459,9 @@ loop_prim_n_bytes (struct mem_read_abstraction_base *mra)\n {\n   int mx = 0;\n   uint8_t lb;\n-  mra->read (mra, mx++, 1, &lb);\n+  int status = mra->read (mra, mx++, 1, &lb);\n+  if (status < 0)\n+    return status;\n \n   enum LP_MODE mode = -1;\n   size_t i;\n@@ -2186,11 +2477,16 @@ loop_prim_n_bytes (struct mem_read_abstraction_base *mra)\n \n   if (mode == LP_OPR)\n     {\n-      mx += x_opr_n_bytes (mra, mx) ;\n+      int n = x_opr_n_bytes (mra, mx);\n+      if (n < 0)\n+\treturn n;\n+      mx += n;\n     }\n \n   uint8_t rb;\n-  mra->read (mra, mx++, 1, &rb);\n+  status = mra->read (mra, mx++, 1, &rb);\n+  if (status < 0)\n+    return status;\n   if (rb & 0x80)\n     mx++;\n \n@@ -2211,7 +2507,11 @@ exg_sex_discrim (struct mem_read_abstraction_base *mra,\n     return operator;\n \n   struct operand *op0 = create_register_operand ((eb & 0xf0) >> 4);\n+  if (op0 == NULL)\n+    return -1;\n   struct operand *op1 = create_register_operand (eb & 0xf);\n+  if (op1 == NULL)\n+    return -1;\n \n   int reg0 = ((struct register_operand *) op0)->reg;\n   int reg1 = ((struct register_operand *) op1)->reg;\n@@ -2231,18 +2531,26 @@ exg_sex_discrim (struct mem_read_abstraction_base *mra,\n }\n \n \n-static void\n+static int\n exg_sex_decode (struct mem_read_abstraction_base *mra,\n \t\tint *n_operands, struct operand **operands)\n {\n+  struct operand *op;\n   uint8_t eb;\n   int status = mra->read (mra, 0, 1, &eb);\n   if (status < 0)\n-    return;\n+    return status;\n \n   /* Ship out the operands.  */\n-  operands[(*n_operands)++] =  create_register_operand ((eb & 0xf0) >> 4);\n-  operands[(*n_operands)++] =  create_register_operand (eb & 0xf);\n+  op = create_register_operand ((eb & 0xf0) >> 4);\n+  if (op == NULL)\n+    return -1;\n+  operands[(*n_operands)++] = op;\n+  op = create_register_operand (eb & 0xf);\n+  if (op == NULL)\n+    return -1;\n+  operands[(*n_operands)++] = op;\n+  return 0;\n }\n \n static enum optr\n@@ -2258,15 +2566,16 @@ loop_primitive_discrim (struct mem_read_abstraction_base *mra,\n   return opbase + ((lb & 0x70) >> 4);\n }\n \n-static void\n+static int\n loop_primitive_decode (struct mem_read_abstraction_base *mra,\n \t\t       int *n_operands, struct operand **operands)\n {\n-  int offs = 1;\n+  struct operand *op;\n+  int n, offs = 1;\n   uint8_t lb;\n   int status = mra->read (mra, 0, 1, &lb);\n   if (status < 0)\n-    return ;\n+    return status;\n \n   enum LP_MODE mode = -1;\n   size_t i;\n@@ -2283,19 +2592,30 @@ loop_primitive_decode (struct mem_read_abstraction_base *mra,\n   switch (mode)\n     {\n     case LP_REG:\n-      operands[(*n_operands)++] = create_register_operand (lb & 0x07);\n+      op = create_register_operand (lb & 0x07);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     case LP_XY:\n-      operands[(*n_operands)++] =\n-\tcreate_register_operand ((lb & 0x01) + REG_X);\n+      op = create_register_operand ((lb & 0x01) + REG_X);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     case LP_OPR:\n-      offs += x_opr_n_bytes (mra, 1);\n-      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1, lb & 0x03);\n+      n = x_opr_n_bytes (mra, 1);\n+      if (n < 0)\n+\treturn n;\n+      offs += n;\n+      op = x_opr_decode_with_size (mra, 1, lb & 0x03);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     }\n \n-  rel_15_7 (mra, offs + 1, n_operands, operands);\n+  return rel_15_7 (mra, offs + 1, n_operands, operands);\n }\n \n \n@@ -2329,21 +2649,21 @@ shift_discrim (struct mem_read_abstraction_base *mra,\n }\n \n \n-static void\n+static int\n shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n \t      struct operand **operands)\n {\n+  struct operand *op;\n   size_t i;\n-\n   uint8_t byte;\n   int status = mra->read (mra, -1, 1, &byte);\n   if (status < 0)\n-    return ;\n+    return status;\n \n   uint8_t sb;\n   status = mra->read (mra, 0, 1, &sb);\n   if (status < 0)\n-    return ;\n+    return status;\n \n   enum SB_MODE mode = -1;\n   for (i = 0; i < sizeof (sb_table) / sizeof (sb_table[0]); ++i)\n@@ -2364,7 +2684,9 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n     case SB_OPR_N:\n       {\n \tuint8_t xb;\n-\tmra->read (mra, 1, 1, &xb);\n+\tstatus = mra->read (mra, 1, 1, &xb);\n+\tif (status < 0)\n+\t  return status;\n \t/* The size suffix is not printed if the OPR operand refers\n \t   directly to a register, because the size is implied by the\n \t   size of that register. */\n@@ -2381,15 +2703,24 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n     {\n     case SB_REG_REG_N_EFF:\n     case SB_REG_REG_N:\n-      operands[(*n_operands)++] = create_register_operand (byte & 0x07);\n+      op = create_register_operand (byte & 0x07);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     case SB_REG_OPR_EFF:\n     case SB_REG_OPR_OPR:\n-      operands[(*n_operands)++] = create_register_operand (byte & 0x07);\n+      op = create_register_operand (byte & 0x07);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n \n     case SB_ROT:\n-      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1, osize);\n+      op = x_opr_decode_with_size (mra, 1, osize);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n \n     default:\n@@ -2401,12 +2732,17 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n     {\n     case SB_REG_REG_N_EFF:\n     case SB_REG_REG_N:\n-      operands[(*n_operands)++] =\n-\tcreate_register_operand_with_size (sb & 0x07, osize);\n+      op = create_register_operand_with_size (sb & 0x07, osize);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n \n     case SB_REG_OPR_OPR:\n-      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1, osize);\n+      op = x_opr_decode_with_size (mra, 1, osize);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n \n     default:\n@@ -2418,13 +2754,18 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n     {\n     case SB_REG_OPR_EFF:\n     case SB_OPR_N:\n-      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1, osize);\n+      op = x_opr_decode_with_size (mra, 1, osize);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n \n     case SB_REG_REG_N:\n       {\n \tuint8_t xb;\n-\tmra->read (mra, 1, 1, &xb);\n+\tstatus = mra->read (mra, 1, 1, &xb);\n+\tif (status < 0)\n+\t  return status;\n \n \t/* This case is slightly unusual.\n \t   If XB matches the binary pattern 0111XXXX, then instead of\n@@ -2435,7 +2776,10 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n \t    if (byte & 0x10)\n \t      {\n \t\tint shift = ((sb & 0x08) >> 3) | ((xb & 0x0f) << 1);\n-\t\toperands[(*n_operands)++] = create_immediate_operand (shift);\n+\t\top = create_immediate_operand (shift);\n+\t\tif (op == NULL)\n+\t\t  return -1;\n+\t\toperands[(*n_operands)++] = op;\n \t      }\n \t    else\n \t      {\n@@ -2445,26 +2789,39 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n \t  }\n \telse\n \t  {\n-\t    operands[(*n_operands)++] = x_opr_decode (mra, 1);\n+\t    op = x_opr_decode (mra, 1);\n+\t    if (op == NULL)\n+\t      return -1;\n+\t    operands[(*n_operands)++] = op;\n \t  }\n       }\n       break;\n     case SB_REG_OPR_OPR:\n       {\n \tuint8_t xb;\n \tint n = x_opr_n_bytes (mra, 1);\n-\tmra->read (mra, 1 + n, 1, &xb);\n+\tif (n < 0)\n+\t  return n;\n+\tstatus = mra->read (mra, 1 + n, 1, &xb);\n+\tif (status < 0)\n+\t  return status;\n \n \tif ((xb & 0xF0) == 0x70)\n \t  {\n \t    int imm = xb & 0x0F;\n \t    imm <<= 1;\n \t    imm |= (sb & 0x08) >> 3;\n-\t    operands[(*n_operands)++] = create_immediate_operand (imm);\n+\t    op = create_immediate_operand (imm);\n+\t    if (op == NULL)\n+\t      return -1;\n+\t    operands[(*n_operands)++] = op;\n \t  }\n \telse\n \t  {\n-\t    operands[(*n_operands)++] = x_opr_decode (mra, 1 + n);\n+\t    op = x_opr_decode (mra, 1 + n);\n+\t    if (op == NULL)\n+\t      return -1;\n+\t    operands[(*n_operands)++] = op;\n \t  }\n       }\n       break;\n@@ -2479,13 +2836,17 @@ shift_decode (struct mem_read_abstraction_base *mra, int *n_operands,\n     case SB_OPR_N:\n       {\n \tint imm = (sb & 0x08) ? 2 : 1;\n-\toperands[(*n_operands)++] = create_immediate_operand (imm);\n+\top = create_immediate_operand (imm);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperands[(*n_operands)++] = op;\n       }\n       break;\n \n     default:\n       break;\n     }\n+  return 0;\n }\n \n static enum optr\n@@ -2501,41 +2862,59 @@ psh_pul_discrim (struct mem_read_abstraction_base *mra,\n }\n \n \n-static void\n+static int\n psh_pul_decode (struct mem_read_abstraction_base *mra,\n \t\tint *n_operands, struct operand **operand)\n {\n+  struct operand *op;\n   uint8_t byte;\n   int status = mra->read (mra, 0, 1, &byte);\n   if (status != 0)\n-    return;\n+    return status;\n   int bit;\n   if (byte & 0x40)\n     {\n       if ((byte & 0x3F) == 0)\n-\toperand[(*n_operands)++] = create_register_all16_operand ();\n+\t{\n+\t  op = create_register_all16_operand ();\n+\t  if (op == NULL)\n+\t    return -1;\n+\t  operand[(*n_operands)++] = op;\n+\t}\n       else\n \tfor (bit = 5; bit >= 0; --bit)\n \t  {\n \t    if (byte & (0x1 << bit))\n \t      {\n-\t\toperand[(*n_operands)++] = create_register_operand (oprregs2[bit]);\n+\t\top = create_register_operand (oprregs2[bit]);\n+\t\tif (op == NULL)\n+\t\t  return -1;\n+\t\toperand[(*n_operands)++] = op;\n \t      }\n \t  }\n     }\n   else\n     {\n       if ((byte & 0x3F) == 0)\n-\toperand[(*n_operands)++] = create_register_all_operand ();\n+\t{\n+\t  op = create_register_all_operand ();\n+\t  if (op == NULL)\n+\t    return -1;\n+\t  operand[(*n_operands)++] = op;\n+\t}\n       else\n \tfor (bit = 5; bit >= 0; --bit)\n \t  {\n \t    if (byte & (0x1 << bit))\n \t      {\n-\t\toperand[(*n_operands)++] = create_register_operand (oprregs1[bit]);\n+\t\top = create_register_operand (oprregs1[bit]);\n+\t\tif (op == NULL)\n+\t\t  return -1;\n+\t\toperand[(*n_operands)++] = op;\n \t      }\n \t  }\n     }\n+  return 0;\n }\n \n static enum optr\n@@ -2548,24 +2927,25 @@ bit_field_discrim (struct mem_read_abstraction_base *mra,\n   if (status != 0)\n     return OP_INVALID;\n \n-  return  (bb & 0x80) ? OP_bfins : OP_bfext;\n+  return (bb & 0x80) ? OP_bfins : OP_bfext;\n }\n \n-static void\n+static int\n bit_field_decode (struct mem_read_abstraction_base *mra,\n \t\t  int *n_operands, struct operand **operands)\n {\n+  struct operand *op;\n   int status;\n \n   bfd_byte byte2;\n   status = mra->read (mra, -1, 1, &byte2);\n   if (status != 0)\n-    return;\n+    return status;\n \n   bfd_byte bb;\n   status = mra->read (mra, 0, 1, &bb);\n   if (status != 0)\n-    return;\n+    return status;\n \n   enum BB_MODE mode = -1;\n   size_t i;\n@@ -2587,15 +2967,22 @@ bit_field_decode (struct mem_read_abstraction_base *mra,\n     case BB_REG_REG_IMM:\n     case BB_REG_OPR_REG:\n     case BB_REG_OPR_IMM:\n-      operands[(*n_operands)++] = create_register_operand (reg1);\n+      op = create_register_operand (reg1);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     case BB_OPR_REG_REG:\n-      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1,\n-\t\t\t\t\t\t\t  (bb >> 2) & 0x03);\n+      op = x_opr_decode_with_size (mra, 1, (bb >> 2) & 0x03);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     case BB_OPR_REG_IMM:\n-      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 2,\n-\t\t\t\t\t\t\t  (bb >> 2) & 0x03);\n+      op = x_opr_decode_with_size (mra, 2, (bb >> 2) & 0x03);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     }\n \n@@ -2606,23 +2993,33 @@ bit_field_decode (struct mem_read_abstraction_base *mra,\n     case BB_REG_REG_IMM:\n       {\n \tint reg_src = (bb >> 2) & 0x07;\n-\toperands[(*n_operands)++] = create_register_operand (reg_src);\n+\top = create_register_operand (reg_src);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperands[(*n_operands)++] = op;\n       }\n       break;\n     case BB_OPR_REG_REG:\n     case BB_OPR_REG_IMM:\n       {\n \tint reg_src = (byte2 & 0x07);\n-\toperands[(*n_operands)++] = create_register_operand (reg_src);\n+\top = create_register_operand (reg_src);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperands[(*n_operands)++] = op;\n       }\n       break;\n     case BB_REG_OPR_REG:\n-      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 1,\n-\t\t\t\t\t\t\t  (bb >> 2) & 0x03);\n+      op = x_opr_decode_with_size (mra, 1, (bb >> 2) & 0x03);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     case BB_REG_OPR_IMM:\n-      operands[(*n_operands)++] = x_opr_decode_with_size (mra, 2,\n-\t\t\t\t\t\t\t  (bb >> 2) & 0x03);\n+      op = x_opr_decode_with_size (mra, 2, (bb >> 2) & 0x03);\n+      if (op == NULL)\n+\treturn -1;\n+      operands[(*n_operands)++] = op;\n       break;\n     }\n \n@@ -2634,23 +3031,32 @@ bit_field_decode (struct mem_read_abstraction_base *mra,\n     case BB_REG_OPR_REG:\n       {\n \tint reg_parm = bb & 0x03;\n-\toperands[(*n_operands)++] = create_register_operand (reg_parm);\n+\top = create_register_operand (reg_parm);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperands[(*n_operands)++] = op;\n       }\n       break;\n     case BB_REG_REG_IMM:\n     case BB_OPR_REG_IMM:\n     case BB_REG_OPR_IMM:\n       {\n \tbfd_byte i1;\n-\tmra->read (mra, 1, 1, &i1);\n+\tstatus = mra->read (mra, 1, 1, &i1);\n+\tif (status < 0)\n+\t  return status;\n \tint offset = i1 & 0x1f;\n \tint width = bb & 0x03;\n \twidth <<= 3;\n \twidth |= i1 >> 5;\n-\toperands[(*n_operands)++] = create_bitfield_operand (width, offset);\n+\top = create_bitfield_operand (width, offset);\n+\tif (op == NULL)\n+\t  return -1;\n+\toperands[(*n_operands)++] = op;\n       }\n       break;\n     }\n+  return 0;\n }\n \n \n@@ -2665,13 +3071,19 @@ decode_operation (const struct opcode *opc,\n {\n   enum optr op = opc->operator;\n   if (opc->discriminator)\n-    op = opc->discriminator (mra, opc->operator);\n+    {\n+      op = opc->discriminator (mra, opc->operator);\n+      if (op == OP_INVALID)\n+\treturn op;\n+    }\n \n   if (opc->operands)\n-    opc->operands (mra, n_operands, operands);\n+    if (opc->operands (mra, n_operands, operands) < 0)\n+      return OP_INVALID;\n \n   if (opc->operands2)\n-    opc->operands2 (mra, n_operands, operands);\n+    if (opc->operands2 (mra, n_operands, operands) < 0)\n+      return OP_INVALID;\n \n   return op;\n }\n@@ -2685,7 +3097,7 @@ decode_s12z (enum optr *myoperator, short *osize,\n   bfd_byte byte;\n \n   int status = mra->read (mra, 0, 1, &byte);\n-  if (status != 0)\n+  if (status < 0)\n     return status;\n \n   mra->advance (mra);\n@@ -2697,15 +3109,25 @@ decode_s12z (enum optr *myoperator, short *osize,\n       n_bytes++;\n \n       bfd_byte byte2;\n-      mra->read (mra, 0, 1, &byte2);\n+      status = mra->read (mra, 0, 1, &byte2);\n+      if (status < 0)\n+\treturn status;\n       mra->advance (mra);\n       opc = page2 + byte2;\n     }\n   *myoperator = decode_operation (opc, mra, n_operands, operands);\n   *osize = opc->osize;\n \n   /* Return the number of bytes in the instruction.  */\n-  n_bytes += (opc && opc->insn_bytes) ? opc->insn_bytes (mra) : 0;\n+  if (*myoperator != OP_INVALID && opc->insn_bytes)\n+    {\n+      int n = opc->insn_bytes (mra);\n+      if (n < 0)\n+\treturn n;\n+      n_bytes += n;\n+    }\n+  else\n+    n_bytes += 1;\n \n   return n_bytes;\n }"
    }
  ]
}