{
  "sha": "4c12d936003909cecc63edba0bebe10c6eccae98",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGMxMmQ5MzYwMDM5MDljZWNjNjNlZGJhMGJlYmUxMGM2ZWNjYWU5OA==",
  "commit": {
    "author": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2017-09-20T22:40:14Z"
    },
    "committer": {
      "name": "Kevin Buettner",
      "email": "kevinb@redhat.com",
      "date": "2019-12-10T22:43:58Z"
    },
    "message": "OpenMP parallel region scope tests\n\nAdd tests which check for accessibility of variables from within\nvarious OpenMP parallel regions.\n\nTested on Fedora 27, 28, 29, 30, and 31.  I also tested with my OpenMP\nwork on Fedora 30.  The test has been annotated with setup_xfail and\nsetup_kfail statements so that there are no unexpected failures on any\nof these platforms when using gcc.  Better still, for my own testing\nanyway, is that there are also no XPASSes or KPASSes either.  So,\nregardless of platform, when using gcc, and regardless of whether my\n(not yet public) OpenMP work is used, seeing a FAIL indicates a real\nproblem.\n\nFedora 27 results:\n\n        # of expected passes            85\n        # of expected failures          65\n\n(Note: I have not retested F27 since v1 of the patch; it's possible\nthat the numbers will be slightly different for v2.)\n\nFedora 28, 29, 30 results:\n\n        # of expected passes            131\n        # of expected failures          4\n        # of known failures             16\n\nFedora 30, 31 results w/ my OpenMP work:\n\n        # of expected passes            151\n\nThe above results all use gcc, either the system gcc or a development\ngcc (when testing against my OpenMP work in GDB).  I've also tested\nwith clang 9.0.0 and icc 19.0.5.281 20190815 on Fedora 31.\n\nFedora 31, clang:\n\nFAIL: gdb.threads/omp-par-scope.exp: single_scope: first thread: print s1\nFAIL: gdb.threads/omp-par-scope.exp: single_scope: first thread: print s3\nFAIL: gdb.threads/omp-par-scope.exp: single_scope: first thread: print i1\nFAIL: gdb.threads/omp-par-scope.exp: single_scope: first thread: print i3\nFAIL: gdb.threads/omp-par-scope.exp: single_scope: second thread: print s1\nFAIL: gdb.threads/omp-par-scope.exp: single_scope: second thread: print s3\nFAIL: gdb.threads/omp-par-scope.exp: single_scope: second thread: print i1\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: first thread: print i02\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: first thread: print i11\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: first thread: print i12\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: first thread: print i22\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: first thread: print file_scope_var\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: second thread: print i11\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: second thread: print file_scope_var\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: after parallel: print file_scope_var\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 1st stop: print file_scope_var\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 1st stop: print num\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 1st stop: print l\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 1st stop: print k\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 2nd stop: print file_scope_var\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 2nd stop: print num\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 3rd stop: print file_scope_var\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 3rd stop: print num\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 3rd stop: print l\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 3rd stop: print k\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 4th stop: print file_scope_var\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 4th stop: print num\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: outer_threads: outer stop: print file_scope_var\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: outer_threads: outer stop: print i\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: outer_threads: outer stop: print j\n\nFedora 31, icc:\n\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: first thread: print i12\nFAIL: gdb.threads/omp-par-scope.exp: multi_scope: first thread: print i22\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 1st call: 1st thread: print s1\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 1st call: 1st thread: print i\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 1st call: 1st thread: print j\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 1st call: 2nd thread: print s1\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 1st call: 2nd thread: print i\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 1st call: 2nd thread: print j\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 1st call: 2nd thread: print k\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 1st call: 2nd thread: print z\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 2nd call: 1st thread: print s1\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 2nd call: 1st thread: print i\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 2nd call: 1st thread: print j\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 2nd call: 2nd thread: print s1\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 2nd call: 2nd thread: print i\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 2nd call: 2nd thread: print j\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 2nd call: 2nd thread: print k\nFAIL: gdb.threads/omp-par-scope.exp: nested_func: 2nd call: 2nd thread: print z\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 1st stop: print l\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 1st stop: print k\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 3rd stop: print l\nFAIL: gdb.threads/omp-par-scope.exp: nested_parallel: inner_threads: 3rd stop: print k\n\nFor both clang and icc, it turns out that there are some problems with\nthe DWARF that these compilers generate.  Of the two, icc does at\nleast nest the subprogram of the outlined function representing the\nparallel region within the function that it's defined, but does not\nhandle inner scopes if they exist.  clang places the subprogram for\nthe outlined function at the same level as the containing function, so\nvariables declared within the function aren't visible at all.\n\nI could call setup_xfail to avoid FAILs for clang and icc also, but I don't\nwant to further complicate the test.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.threads/omp-par-scope.c: New file.\n\t* gdb/threads/omp-par-scope.exp: New file.\n\nChange-Id: Icb9c991730d84ca7509380af817dfcc778e764ea",
    "tree": {
      "sha": "51cff2af752b33764a40aa4e132881c2b27dd1a7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/51cff2af752b33764a40aa4e132881c2b27dd1a7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4c12d936003909cecc63edba0bebe10c6eccae98",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4c12d936003909cecc63edba0bebe10c6eccae98",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4c12d936003909cecc63edba0bebe10c6eccae98",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4c12d936003909cecc63edba0bebe10c6eccae98/comments",
  "author": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "KevinBuettner",
    "id": 65747518,
    "node_id": "MDQ6VXNlcjY1NzQ3NTE4",
    "avatar_url": "https://avatars.githubusercontent.com/u/65747518?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/KevinBuettner",
    "html_url": "https://github.com/KevinBuettner",
    "followers_url": "https://api.github.com/users/KevinBuettner/followers",
    "following_url": "https://api.github.com/users/KevinBuettner/following{/other_user}",
    "gists_url": "https://api.github.com/users/KevinBuettner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/KevinBuettner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/KevinBuettner/subscriptions",
    "organizations_url": "https://api.github.com/users/KevinBuettner/orgs",
    "repos_url": "https://api.github.com/users/KevinBuettner/repos",
    "events_url": "https://api.github.com/users/KevinBuettner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/KevinBuettner/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bb47f919bfdb8908361de74a0daf1af208ae425b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb47f919bfdb8908361de74a0daf1af208ae425b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bb47f919bfdb8908361de74a0daf1af208ae425b"
    }
  ],
  "stats": {
    "total": 461,
    "additions": 461,
    "deletions": 0
  },
  "files": [
    {
      "sha": "8b846a13e8bd3662ce55cdc5c883352068a21b85",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c12d936003909cecc63edba0bebe10c6eccae98/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c12d936003909cecc63edba0bebe10c6eccae98/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=4c12d936003909cecc63edba0bebe10c6eccae98",
      "patch": "@@ -1,3 +1,8 @@\n+2019-12-10  Kevin Buettner  <kevinb@redhat.com>\n+\n+\t* gdb.threads/omp-par-scope.c: New file.\n+\t* gdb/threads/omp-par-scope.exp: New file.\n+\n 2019-12-10  Kevin Buettner  <kevinb@redhat.com>\n \n \t* lib/gdb.exp (support_nested_function_tests): New proc."
    },
    {
      "sha": "c60e3762f5729375f703a569c79f3b51648827fb",
      "filename": "gdb/testsuite/gdb.threads/omp-par-scope.c",
      "status": "added",
      "additions": 166,
      "deletions": 0,
      "changes": 166,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c12d936003909cecc63edba0bebe10c6eccae98/gdb/testsuite/gdb.threads/omp-par-scope.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c12d936003909cecc63edba0bebe10c6eccae98/gdb/testsuite/gdb.threads/omp-par-scope.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/omp-par-scope.c?ref=4c12d936003909cecc63edba0bebe10c6eccae98",
      "patch": "@@ -0,0 +1,166 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2017-2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <stdio.h>\n+#include <omp.h>\n+\n+/* Testcase for checking access to variables in a single / outer scope.\n+   Make sure that variables not referred to in the parallel section are\n+   accessible from the debugger.  */\n+\n+void\n+single_scope (void)\n+{\n+  static int s1 = -41, s2 = -42, s3 = -43;\n+  int i1 = 11, i2 = 12, i3 = 13;\n+\n+#pragma omp parallel num_threads (2) shared (s1, i1) private (s2, i2)\n+  {\n+    int thread_num = omp_get_thread_num ();\n+\n+    s2 = 100 * (thread_num + 1) + 2;\n+    i2 = s2 + 10;\n+\n+    #pragma omp critical\n+    printf (\"single_scope: thread_num=%d, s1=%d, i1=%d, s2=%d, i2=%d\\n\",\n+\t    thread_num, s1, i1, s2, i2);\n+  }\n+\n+  printf (\"single_scope: s1=%d, s2=%d, s3=%d, i1=%d, i2=%d, i3=%d\\n\",\n+\t  s1, s2, s3, i1, i2, i3);\n+}\n+\n+static int file_scope_var = 9876;\n+\n+/* Testcase for checking access to variables from parallel region\n+   nested within more than one lexical scope.  Of particular interest\n+   are variables which are not referenced in the parallel section.  */\n+\n+void\n+multi_scope (void)\n+{\n+  int i01 = 1, i02 = 2;\n+\n+  {\n+    int i11 = 11, i12 = 12;\n+\n+    {\n+      int i21 = -21, i22 = 22;\n+\n+#pragma omp parallel num_threads (2) \\\n+\t\t     firstprivate (i01) \\\n+\t\t     shared (i11) \\\n+\t\t     private (i21)\n+\t{\n+\t  int thread_num = omp_get_thread_num ();\n+\t  i21 = 100 * (thread_num + 1) + 21;\n+\n+\t  #pragma omp critical\n+\t  printf (\"multi_scope: thread_num=%d, i01=%d, i11=%d, i21=%d\\n\",\n+\t\t  thread_num, i01, i11, i21);\n+\t}\n+\n+\tprintf (\"multi_scope: i01=%d, i02=%d, i11=%d, \"\n+\t\t\"i12=%d, i21=%d, i22=%d\\n\",\n+\t\ti01, i02, i11, i12, i21, i22);\n+    }\n+  }\n+}\n+\n+/* Nested functions in C is a GNU extension.  Some non-GNU compilers\n+   define __GNUC__, but they don't support nested functions.  So,\n+   unfortunately, we can't use that for our test.  */\n+#if HAVE_NESTED_FUNCTION_SUPPORT\n+\n+/* Testcase for checking access of variables from within parallel\n+   region in a lexically nested function.  */\n+\n+void\n+nested_func (void)\n+{\n+  static int s1 = -42;\n+  int i = 1, j = 2, k = 3;\n+\n+  void\n+  foo (int p, int q, int r)\n+  {\n+    int x = 4;\n+\n+    {\n+      int y = 5, z = 6;\n+#pragma omp parallel num_threads (2) shared (i, p, x) private (j, q, y)\n+      {\n+\tint tn = omp_get_thread_num ();\n+\n+\tj = 1000 * (tn + 1);\n+\tq = j + 1;\n+\ty = q + 1;\n+\t#pragma omp critical\n+\tprintf (\"nested_func: tn=%d: i=%d, p=%d, x=%d, j=%d, q=%d, y=%d\\n\",\n+\t\t tn, i, p, x, j, q, y);\n+      }\n+    }\n+  }\n+\n+  foo (10, 11, 12);\n+\n+  i = 101; j = 102; k = 103;\n+  foo (20, 21, 22);\n+}\n+#endif\n+\n+/* Testcase for checking access to variables from within a nested parallel\n+   region. */\n+\n+void\n+nested_parallel (void)\n+{\n+  int i = 1, j = 2;\n+  int l = -1;\n+\n+  omp_set_nested (1);\n+  omp_set_dynamic (0);\n+#pragma omp parallel num_threads (2) private (l)\n+  {\n+    int num = omp_get_thread_num ();\n+    int nthr = omp_get_num_threads ();\n+    int off = num * nthr;\n+    int k = off + 101;\n+    l = off + 102;\n+#pragma omp parallel num_threads (2) shared (num)\n+    {\n+      int inner_num = omp_get_thread_num ();\n+      #pragma omp critical\n+      printf (\"nested_parallel (inner threads): outer thread num = %d, thread num = %d\\n\", num, inner_num);\n+    }\n+    #pragma omp critical\n+    printf (\"nested_parallel (outer threads) %d: k = %d, l = %d\\n\", num, k, l);\n+  }\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  single_scope ();\n+  multi_scope ();\n+#if HAVE_NESTED_FUNCTION_SUPPORT\n+  nested_func ();\n+#endif\n+  nested_parallel ();\n+  return 0;\n+}\n+"
    },
    {
      "sha": "e237b91b547797bddec922de400ed907adb9d4e7",
      "filename": "gdb/testsuite/gdb.threads/omp-par-scope.exp",
      "status": "added",
      "additions": 290,
      "deletions": 0,
      "changes": 290,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4c12d936003909cecc63edba0bebe10c6eccae98/gdb/testsuite/gdb.threads/omp-par-scope.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4c12d936003909cecc63edba0bebe10c6eccae98/gdb/testsuite/gdb.threads/omp-par-scope.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/omp-par-scope.exp?ref=4c12d936003909cecc63edba0bebe10c6eccae98",
      "patch": "@@ -0,0 +1,290 @@\n+# Copyright 2017-2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file is part of the gdb testsuite.\n+\n+# Tests which verify (or not) that GDB can access in-scope variables\n+# when stopped within an OpenMP parallel region.\n+\n+standard_testfile\n+\n+set have_nested_function_support 0\n+set opts {openmp debug}\n+if [support_nested_function_tests] {\n+    lappend opts \"additional_flags=-DHAVE_NESTED_FUNCTION_SUPPORT\"\n+    set have_nested_function_support 1\n+}\n+\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile $opts]} {\n+    return -1\n+}\n+\n+# gdb_openmp_setup may be defined to set auto-load safe-path and possibly\n+# sysroot.  These settings are required for gdb to be able to find\n+# the libgomp python plugin.  (sysroot only needs to be defined for\n+# remote debugging.)\n+#\n+# This approach has both pros and cons.  On the plus side, it's easy\n+# to automatically set a precise auto-load safe-path.  (It's easy because\n+# the output of ldd on the binary may be examined to learn the location\n+# of libgomp.so.)\n+#\n+# However, making these settings is also a drawback due to potentially\n+# overriding settings made by a board file.  Therefore, this proc\n+# is optional and will only be called if it's defined.\n+\n+if {[info procs gdb_openmp_setup] != \"\"} {\n+    if {[gdb_openmp_setup $binfile] != \"\"} {\n+\tuntested \"could not set up OpenMP environment\"\n+\treturn -1\n+    }\n+}\n+\n+if {![runto_main]} {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+# We want to invoke setup_kfail (and in some cases setup_xfail) when\n+# GDB does not yet have support for finding the values of variables in\n+# (non-master) threads.  We'll check this by looking at the output of\n+# \"maint print thread-parent\".  If this command is undefined, then GDB\n+# does not yet have thread parent support, and it makes sense to kfail\n+# tests which won't work.  It's possible for GDB to have this support,\n+# but not work.  E.g. it may be the case that the plugin doesn't\n+# exist or is not found.  We may eventually need to add additional\n+# constraints related to setting allow_kfail to 0.  But, for the moment,\n+# this simple test should be sufficient.\n+\n+set allow_kfail 1\n+gdb_test_multiple \"maint print thread-parent\" \"maint print thread-parent\" {\n+    -re \"Undefined maintenance print command.*$gdb_prompt\" {\n+\tpass \"maint print thread-parent (does not exist)\"\n+    }\n+    -re \"No parent found.*\" {\n+\tpass \"maint print thread-parent\"\n+\tset allow_kfail 0\n+    }\n+}\n+\n+# Determine whether to xfail some of the tests based on GCC version.\n+#\n+# This may need to be tweaked somewhat.  Testing shows that GCC 7.3.1\n+# needs the xfails.  GCC 8.3.1 and 9.1.1 do not.  The assumption made\n+# below is that all versions of gcc 8 and above won't require the\n+# XFAIL setup and that all versions of gcc 7 and below will, but it's\n+# possible that there are versions in between 7.3.1 and 8.3.1 for\n+# which this assumption is invalid.\n+\n+set have_older_gcc 0\n+if {[test_compiler_info {gcc-[0-7]-*}]} {\n+    set have_older_gcc 1\n+}\n+\n+# maybe_setup_kfail will set up a kfail for gdb/22214 when COND holds in\n+# addition to considering the values of $have_older_gcc and $allow_kfail.\n+#\n+# When $have_older_gcc evaluates to true, setup_xfail will invoked\n+# instead.\n+\n+proc maybe_setup_kfail {cond} {\n+    global have_older_gcc allow_kfail\n+    if {$have_older_gcc} {\n+\tsetup_xfail *-*-*\n+    } elseif {[uplevel 1 [list expr $cond]] && $allow_kfail} {\n+\tsetup_kfail \"gdb/22214\" *-*-*\n+    }\n+}\n+\n+with_test_prefix \"single_scope\" {\n+\n+    gdb_breakpoint [gdb_get_line_number \"single_scope: thread_num=\"]\n+    gdb_breakpoint [gdb_get_line_number \"single_scope: s1=\"]\n+\n+    foreach pref {\"first thread\" \"second thread\"} {\n+\twith_test_prefix $pref {\n+\t    gdb_continue_to_breakpoint \"at printf\"\n+\n+\t    if {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t    set thread_num [get_valueof \"\" thread_num \"unknown\"]\n+\t    if {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t    gdb_test \"print s1\" \"= -41\"\n+\t    gdb_test \"print s2\" \"= \\[12\\]02\"\n+\t    if {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t    gdb_test \"print s3\" \"= -43\"\n+\t    gdb_test \"print i1\" \"= 11\"\n+\t    gdb_test \"print i2\" \"= \\[12]12\"\n+\t    maybe_setup_kfail {$thread_num != 0}\n+\t    gdb_test \"print i3\" \"= 13\"\n+\t}\n+    }\n+\n+    with_test_prefix \"after parallel region\" {\n+\tgdb_continue_to_breakpoint \"at printf\"\n+\n+\tgdb_test \"print s1\" \"= -41\"\n+\tgdb_test \"print s2\" \"= -42\"\n+\tgdb_test \"print s3\" \"= -43\"\n+\tgdb_test \"print i1\" \"= 11\"\n+\tgdb_test \"print i2\" \"= 12\"\n+\tgdb_test \"print i3\" \"= 13\"\n+    }\n+\n+}\n+\n+with_test_prefix \"multi_scope\" {\n+    gdb_breakpoint [gdb_get_line_number \"multi_scope: thread_num=\"]\n+    gdb_breakpoint [gdb_get_line_number \"multi_scope: i01=\"]\n+\n+    foreach pref {\"first thread\" \"second thread\"} {\n+\twith_test_prefix $pref {\n+\t    gdb_continue_to_breakpoint \"at printf\"\n+\n+\t    if {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t    set thread_num [get_valueof \"\" thread_num \"unknown\"]\n+\n+\t    gdb_test \"print i01\" \"= 1\"\n+\t    maybe_setup_kfail {$thread_num != 0}\n+\t    gdb_test \"print i02\" \"= 2\"\n+\t    gdb_test \"print i11\" \"= 11\"\n+\t    maybe_setup_kfail {$thread_num != 0}\n+\t    gdb_test \"print i12\" \"= 12\"\n+\t    gdb_test \"print i21\" \"= \\[12\\]21\"\n+\t    maybe_setup_kfail {$thread_num != 0}\n+\t    gdb_test \"print i22\" \"= 22\"\n+\t    gdb_test \"print file_scope_var\" \"= 9876\"\n+\t}\n+    }\n+\n+    with_test_prefix \"after parallel\" {\n+\tgdb_continue_to_breakpoint \"at printf\"\n+\n+\tgdb_test \"print i01\" \"= 1\"\n+\tgdb_test \"print i02\" \"= 2\"\n+\tgdb_test \"print i11\" \"= 11\"\n+\tgdb_test \"print i12\" \"= 12\"\n+\tgdb_test \"print i21\" \"= -21\"\n+\tgdb_test \"print i22\" \"= 22\"\n+\tgdb_test \"print file_scope_var\" \"= 9876\"\n+    }\n+}\n+\n+# Nested functions in C are a GNU extension, so only do the nested function\n+# tests if compiling with -DHAVE_NESTED_FUNCTION_SUPPORT was successful.\n+\n+if $have_nested_function_support {\n+    with_test_prefix \"nested_func\" {\n+\tgdb_breakpoint [gdb_get_line_number \"nested_func: tn=\"]\n+\n+\tforeach call_prefix {\"1st call\" \"2nd call\"} {\n+\t    with_test_prefix $call_prefix {\n+\t\tforeach thread_prefix {\"1st thread\" \"2nd thread\"} {\n+\t\t    with_test_prefix $thread_prefix {\n+\t\t\tgdb_continue_to_breakpoint \"at printf\"\n+\n+\t\t\tif {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t\t\tset thread_num [get_valueof \"\" \"tn\" \"unknown\"]\n+\n+\t\t\tgdb_test \"print file_scope_var\" \"= 9876\"\n+\t\t\tif {$have_older_gcc} { setup_xfail *-*-* }\n+\t\t\tgdb_test \"print s1\" \"= -42\"\n+\t\t\tif {$call_prefix eq \"1st call\"} {\n+\t\t\t    gdb_test \"print i\" \"= 1\"\n+\t\t\t} else {\n+\t\t\t    gdb_test \"print i\" \"= 101\"\n+\t\t\t}\n+\t\t\tgdb_test \"print j\" \"= \\[12\\]000\"\n+\t\t\tmaybe_setup_kfail {$thread_num != 0}\n+\t\t\tif {$call_prefix eq \"1st call\"} {\n+\t\t\t    gdb_test \"print k\" \"= 3\"\n+\t\t\t} else {\n+\t\t\t    gdb_test \"print k\" \"= 103\"\n+\t\t\t}\n+\t\t\tif {$call_prefix eq \"1st call\"} {\n+\t\t\t    gdb_test \"print p\" \"= 10\"\n+\t\t\t} else {\n+\t\t\t    gdb_test \"print p\" \"= 20\"\n+\t\t\t}\n+\t\t\tgdb_test \"print q\" \"= \\[12\\]001\"\n+\t\t\tmaybe_setup_kfail {$thread_num != 0}\n+\t\t\tif {$call_prefix eq \"1st call\"} {\n+\t\t\t    gdb_test \"print r\" \"= 12\"\n+\t\t\t} else {\n+\t\t\t    gdb_test \"print r\" \"= 22\"\n+\t\t\t}\n+\t\t\tgdb_test \"print x\" \"= 4\"\n+\t\t\tgdb_test \"print y\" \"= \\[12\\]002\"\n+\t\t\tmaybe_setup_kfail {$thread_num != 0}\n+\t\t\tgdb_test \"print z\" \"= 6\"\n+\t\t\tif {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t\t\tgdb_test \"print tn\" \"= \\[01\\]\"\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+with_test_prefix \"nested_parallel\" {\n+    gdb_breakpoint [gdb_get_line_number \"nested_parallel (inner threads)\"]\n+\n+    with_test_prefix \"inner_threads\" {\n+\tforeach pref {\"1st stop\" \"2nd stop\" \"3rd stop\" \"4th stop\"} {\n+\t    with_test_prefix $pref {\n+\t\tgdb_continue_to_breakpoint \"at printf\"\n+\n+\t\t# Don't need setup_xfail here due to fact that num is made\n+\t\t# made known to the inner parallel region.\n+\t\tset thread_num [get_valueof \"\" \"num\" \"unknown\"]\n+\n+\t\tif {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t\tset inner_thread_num [get_valueof \"\" \"inner_num\" \"unknown\"]\n+\n+\t\tgdb_test \"print file_scope_var\" \"= 9876\"\n+\t\tgdb_test \"print num\" \"= \\[01\\]\"\n+\t\tmaybe_setup_kfail {$thread_num != 0 || $inner_thread_num != 0}\n+\t\tgdb_test \"print i\" \"= 1\"\n+\t\tmaybe_setup_kfail {$thread_num != 0 || $inner_thread_num != 0}\n+\t\tgdb_test \"print j\" \"= 2\"\n+\t\tif {$have_older_gcc || ($inner_thread_num != 0 && $allow_kfail)} { setup_xfail *-*-* }\n+\t\tgdb_test \"print l\" \"= 10\\[24\\]\"\n+\t\tif {$have_older_gcc ||( $inner_thread_num != 0 && $allow_kfail)} { setup_xfail *-*-* }\n+\t\tgdb_test \"print k\" \"= 10\\[13\\]\"\n+\t    }\n+\t}\n+    }\n+\n+    with_test_prefix \"outer_threads\" {\n+\tgdb_breakpoint [gdb_get_line_number \"nested_parallel (outer threads)\"]\n+\n+\twith_test_prefix \"outer stop\" {\n+\t    gdb_continue_to_breakpoint \"at printf\"\n+\n+\t    if {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t    set thread_num [get_valueof \"\" \"num\" \"unknown\"]\n+\n+\t    gdb_test \"print file_scope_var\" \"= 9876\"\n+\t    if {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t    gdb_test \"print num\" \"= \\[01\\]\"\n+\t    maybe_setup_kfail {$thread_num != 0}\n+\t    gdb_test \"print i\" \"= 1\"\n+\t    maybe_setup_kfail {$thread_num != 0}\n+\t    gdb_test \"print j\" \"= 2\"\n+\t    gdb_test \"print l\" \"= 10\\[24\\]\"\n+\t    if {$have_older_gcc} { setup_xfail \"*-*-*\" }\n+\t    gdb_test \"print k\" \"= 10\\[13\\]\"\n+\t}\n+    }\n+}"
    }
  ]
}