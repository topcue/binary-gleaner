{
  "sha": "4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGJlMWU4ZGJiM2Y4ZGE4MDU4ZWQ5M2RmYzIyMmVlNmRmZmIwMmU2MA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-25T04:06:20Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-25T05:37:08Z"
    },
    "message": "asan: _bfd_elf_parse_attributes heap buffer overflow\n\nI exposed a problem with the change in commit 574ec1084d to the outer\nloop of _bfd_elf_parse_attributes.  \"p_end - p >= 4\" is better than\n\"p < p_end - 4\" as far as pointer UB is concerned if the size of the\nattritbute section is say, 3 bytes.  However you do need to ensure p\nnever exceeds p_end, and that length remaining is kept consistent with\nthe pointer.\n\n\t* elf-attrs.c (elf_attr_strdup): New function.\n\t(_bfd_elf_attr_strdup): Use it here.\n\t(elf_add_obj_attr_string): New function, extracted from..\n\t(bfd_elf_add_obj_attr_string): ..here.\n\t(elf_add_obj_attr_int_string): New function, extracted from..\n\t(bfd_elf_add_obj_attr_int_string): ..here.\n\t(_bfd_elf_parse_attributes): Don't allocate an extra byte for a\n\tstring terminator.  Instead ensure parsing doesn't go past\n\tend of sub-section.  Use size_t variables for lengths.",
    "tree": {
      "sha": "80e545d4cf7a8bc7386b0af657b6efefb905123a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/80e545d4cf7a8bc7386b0af657b6efefb905123a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e63e5f9f9f9c7922dfc348b1637d1fd0a2b353d2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e63e5f9f9f9c7922dfc348b1637d1fd0a2b353d2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e63e5f9f9f9c7922dfc348b1637d1fd0a2b353d2"
    }
  ],
  "stats": {
    "total": 121,
    "additions": 81,
    "deletions": 40
  },
  "files": [
    {
      "sha": "516b81635853af95a3bf010c3e2a7ce34543cd57",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60",
      "patch": "@@ -1,3 +1,15 @@\n+2021-05-25  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf-attrs.c (elf_attr_strdup): New function.\n+\t(_bfd_elf_attr_strdup): Use it here.\n+\t(elf_add_obj_attr_string): New function, extracted from..\n+\t(bfd_elf_add_obj_attr_string): ..here.\n+\t(elf_add_obj_attr_int_string): New function, extracted from..\n+\t(bfd_elf_add_obj_attr_int_string): ..here.\n+\t(_bfd_elf_parse_attributes): Don't allocate an extra byte for a\n+\tstring terminator.  Instead ensure parsing doesn't go past\n+\tend of sub-section.  Use size_t variables for lengths.\n+\n 2021-05-22  Alan Modra  <amodra@gmail.com>\n \n \t* libbfd.c (_bfd_safe_read_leb128): Remove length_return parameter."
    },
    {
      "sha": "11a81a3ba74ff024bc0285ed0d543c664dcfb443",
      "filename": "bfd/elf-attrs.c",
      "status": "modified",
      "additions": 69,
      "deletions": 40,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60/bfd/elf-attrs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60/bfd/elf-attrs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-attrs.c?ref=4be1e8dbb3f8da8058ed93dfc222ee6dffb02e60",
      "patch": "@@ -303,40 +303,69 @@ bfd_elf_add_obj_attr_int (bfd *abfd, int vendor, unsigned int tag, unsigned int\n }\n \n /* Duplicate an object attribute string value.  */\n-char *\n-_bfd_elf_attr_strdup (bfd *abfd, const char * s)\n+static char *\n+elf_attr_strdup (bfd *abfd, const char *s, const char *end)\n {\n-  char * p;\n-  int len;\n+  char *p;\n+  size_t len;\n+\n+  if (end)\n+    len = strnlen (s, end - s);\n+  else\n+    len = strlen (s);\n+\n+  p = (char *) bfd_alloc (abfd, len + 1);\n+  if (p != NULL)\n+    {\n+      memcpy (p, s, len);\n+      p[len] = 0;\n+    }\n+  return p;\n+}\n \n-  len = strlen (s) + 1;\n-  p = (char *) bfd_alloc (abfd, len);\n-  return (char *) memcpy (p, s, len);\n+char *\n+_bfd_elf_attr_strdup (bfd *abfd, const char *s)\n+{\n+  return elf_attr_strdup (abfd, s, NULL);\n }\n \n /* Add a string object attribute.  */\n-void\n-bfd_elf_add_obj_attr_string (bfd *abfd, int vendor, unsigned int tag, const char *s)\n+static void\n+elf_add_obj_attr_string (bfd *abfd, int vendor, unsigned int tag,\n+\t\t\t const char *s, const char *end)\n {\n   obj_attribute *attr;\n \n   attr = elf_new_obj_attr (abfd, vendor, tag);\n   attr->type = _bfd_elf_obj_attrs_arg_type (abfd, vendor, tag);\n-  attr->s = _bfd_elf_attr_strdup (abfd, s);\n+  attr->s = elf_attr_strdup (abfd, s, end);\n }\n \n-/* Add a int+string object attribute.  */\n void\n-bfd_elf_add_obj_attr_int_string (bfd *abfd, int vendor,\n-\t\t\t\t unsigned int tag,\n-\t\t\t\t unsigned int i, const char *s)\n+bfd_elf_add_obj_attr_string (bfd *abfd, int vendor, unsigned int tag,\n+\t\t\t     const char *s)\n+{\n+  elf_add_obj_attr_string (abfd, vendor, tag, s, NULL);\n+}\n+\n+/* Add a int+string object attribute.  */\n+static void\n+elf_add_obj_attr_int_string (bfd *abfd, int vendor, unsigned int tag,\n+\t\t\t     unsigned int i, const char *s, const char *end)\n {\n   obj_attribute *attr;\n \n   attr = elf_new_obj_attr (abfd, vendor, tag);\n   attr->type = _bfd_elf_obj_attrs_arg_type (abfd, vendor, tag);\n   attr->i = i;\n-  attr->s = _bfd_elf_attr_strdup (abfd, s);\n+  attr->s = elf_attr_strdup (abfd, s, end);\n+}\n+\n+void\n+bfd_elf_add_obj_attr_int_string (bfd *abfd, int vendor, unsigned int tag,\n+\t\t\t\t unsigned int i, const char *s)\n+{\n+  elf_add_obj_attr_int_string (abfd, vendor, tag, i, s, NULL);\n }\n \n /* Copy the object attributes from IBFD to OBFD.  */\n@@ -434,7 +463,6 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n   bfd_byte *contents;\n   bfd_byte *p;\n   bfd_byte *p_end;\n-  bfd_vma len;\n   const char *std_sec;\n   ufile_ptr filesize;\n \n@@ -452,7 +480,7 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n       return;\n     }\n \n-  contents = (bfd_byte *) bfd_malloc (hdr->sh_size + 1);\n+  contents = (bfd_byte *) bfd_malloc (hdr->sh_size);\n   if (!contents)\n     return;\n   if (!bfd_get_section_contents (abfd, hdr->bfd_section, contents, 0,\n@@ -461,20 +489,17 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n       free (contents);\n       return;\n     }\n-  /* Ensure that the buffer is NUL terminated.  */\n-  contents[hdr->sh_size] = 0;\n   p = contents;\n   p_end = p + hdr->sh_size;\n   std_sec = get_elf_backend_data (abfd)->obj_attrs_vendor;\n \n-  if (*(p++) == 'A')\n+  if (*p++ == 'A')\n     {\n-      len = hdr->sh_size - 1;\n-\n-      while (len > 0 && p_end - p >= 4)\n+      while (p_end - p >= 4)\n \t{\n-\t  unsigned namelen;\n-\t  bfd_vma section_len;\n+\t  size_t len = p_end - p;\n+\t  size_t namelen;\n+\t  size_t section_len;\n \t  int vendor;\n \n \t  section_len = bfd_get_32 (abfd, p);\n@@ -483,36 +508,35 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n \t    break;\n \t  if (section_len > len)\n \t    section_len = len;\n-\t  len -= section_len;\n \t  if (section_len <= 4)\n \t    {\n \t      _bfd_error_handler\n-\t\t(_(\"%pB: error: attribute section length too small: %\" PRId64),\n-\t\t abfd, (int64_t) section_len);\n+\t\t(_(\"%pB: error: attribute section length too small: %ld\"),\n+\t\t abfd, (long) section_len);\n \t      break;\n \t    }\n \t  section_len -= 4;\n \t  namelen = strnlen ((char *) p, section_len) + 1;\n-\t  if (namelen == 0 || namelen >= section_len)\n+\t  if (namelen >= section_len)\n \t    break;\n-\t  section_len -= namelen;\n \t  if (std_sec && strcmp ((char *) p, std_sec) == 0)\n \t    vendor = OBJ_ATTR_PROC;\n \t  else if (strcmp ((char *) p, \"gnu\") == 0)\n \t    vendor = OBJ_ATTR_GNU;\n \t  else\n \t    {\n \t      /* Other vendor section.  Ignore it.  */\n-\t      p += namelen + section_len;\n+\t      p += section_len;\n \t      continue;\n \t    }\n \n \t  p += namelen;\n-\t  while (section_len > 0 && p < p_end)\n+\t  section_len -= namelen;\n+\t  while (section_len > 0)\n \t    {\n \t      unsigned int tag;\n \t      unsigned int val;\n-\t      bfd_vma subsection_len;\n+\t      size_t subsection_len;\n \t      bfd_byte *end, *orig_p;\n \n \t      orig_p = p;\n@@ -546,14 +570,20 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n \t\t\t{\n \t\t\tcase ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL:\n \t\t\t  val = _bfd_safe_read_leb128 (abfd, &p, false, end);\n-\t\t\t  bfd_elf_add_obj_attr_int_string (abfd, vendor, tag,\n-\t\t\t\t\t\t\t   val, (char *) p);\n-\t\t\t  p += strlen ((char *)p) + 1;\n+\t\t\t  elf_add_obj_attr_int_string (abfd, vendor, tag, val,\n+\t\t\t\t\t\t       (char *) p,\n+\t\t\t\t\t\t       (char *) end);\n+\t\t\t  p += strnlen ((char *) p, end - p);\n+\t\t\t  if (p < end)\n+\t\t\t    p++;\n \t\t\t  break;\n \t\t\tcase ATTR_TYPE_FLAG_STR_VAL:\n-\t\t\t  bfd_elf_add_obj_attr_string (abfd, vendor, tag,\n-\t\t\t\t\t\t       (char *) p);\n-\t\t\t  p += strlen ((char *)p) + 1;\n+\t\t\t  elf_add_obj_attr_string (abfd, vendor, tag,\n+\t\t\t\t\t\t   (char *) p,\n+\t\t\t\t\t\t   (char *) end);\n+\t\t\t  p += strnlen ((char *) p, end - p);\n+\t\t\t  if (p < end)\n+\t\t\t    p++;\n \t\t\t  break;\n \t\t\tcase ATTR_TYPE_FLAG_INT_VAL:\n \t\t\t  val = _bfd_safe_read_leb128 (abfd, &p, false, end);\n@@ -571,7 +601,6 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n \t\tdefault:\n \t\t  /* Ignore things we don't know about.  */\n \t\t  p = end;\n-\t\t  subsection_len = 0;\n \t\t  break;\n \t\t}\n \t    }"
    }
  ]
}