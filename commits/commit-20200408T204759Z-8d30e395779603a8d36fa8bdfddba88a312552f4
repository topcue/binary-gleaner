{
  "sha": "8d30e395779603a8d36fa8bdfddba88a312552f4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGQzMGUzOTU3Nzk2MDNhOGQzNmZhOGJkZmRkYmE4OGEzMTI1NTJmNA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-08T20:33:35Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-08T20:47:59Z"
    },
    "message": "Share handle_exception\n\nBoth gdb and gdbserver have a \"handle_exception\" function, the bulk of\nwhich is shared between the two implementations.  This patch arranges\nfor the entire thing to be moved into nat/windows-nat.c, with the\ndifferences handled by callbacks.  This patch introduces one more\ncallback to make this possible.\n\ngdb/ChangeLog\n2020-04-08  Tom Tromey  <tromey@adacore.com>\n\n\t* windows-nat.c (MS_VC_EXCEPTION): Move to nat/windows-nat.c.\n\t(handle_exception_result): Move to nat/windows-nat.h.\n\t(DEBUG_EXCEPTION_SIMPLE): Remove.\n\t(windows_nat::handle_ms_vc_exception): New function.\n\t(handle_exception): Move to nat/windows-nat.c.\n\t(get_windows_debug_event): Update.\n\t(STATUS_WX86_BREAKPOINT, STATUS_WX86_SINGLE_STEP): Move to\n\tnat/windows-nat.c.\n\t* nat/windows-nat.h (handle_ms_vc_exception): Declare.\n\t(handle_exception_result): Move from windows-nat.c.\n\t(handle_exception): Declare.\n\t* nat/windows-nat.c (MS_VC_EXCEPTION, handle_exception)\n\t(STATUS_WX86_SINGLE_STEP, STATUS_WX86_BREAKPOINT): Move from\n\twindows-nat.c.\n\ngdbserver/ChangeLog\n2020-04-08  Tom Tromey  <tromey@adacore.com>\n\n\t* win32-low.c (handle_exception): Remove.\n\t(windows_nat::handle_ms_vc_exception): New function.\n\t(get_child_debug_event): Add \"continue_status\" parameter.\n\tUpdate.\n\t(win32_wait): Update.",
    "tree": {
      "sha": "469d9065623bf700d4a4fa02988fc58f415f9195",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/469d9065623bf700d4a4fa02988fc58f415f9195"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8d30e395779603a8d36fa8bdfddba88a312552f4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8d30e395779603a8d36fa8bdfddba88a312552f4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8d30e395779603a8d36fa8bdfddba88a312552f4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8d30e395779603a8d36fa8bdfddba88a312552f4/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "29de418deeac717886df20ef0419240aa0dfc32a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/29de418deeac717886df20ef0419240aa0dfc32a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/29de418deeac717886df20ef0419240aa0dfc32a"
    }
  ],
  "stats": {
    "total": 570,
    "additions": 266,
    "deletions": 304
  },
  "files": [
    {
      "sha": "663e2af7dc20b3225b1f21591c2cbff6550ba2df",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d30e395779603a8d36fa8bdfddba88a312552f4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d30e395779603a8d36fa8bdfddba88a312552f4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8d30e395779603a8d36fa8bdfddba88a312552f4",
      "patch": "@@ -1,3 +1,20 @@\n+2020-04-08  Tom Tromey  <tromey@adacore.com>\n+\n+\t* windows-nat.c (MS_VC_EXCEPTION): Move to nat/windows-nat.c.\n+\t(handle_exception_result): Move to nat/windows-nat.h.\n+\t(DEBUG_EXCEPTION_SIMPLE): Remove.\n+\t(windows_nat::handle_ms_vc_exception): New function.\n+\t(handle_exception): Move to nat/windows-nat.c.\n+\t(get_windows_debug_event): Update.\n+\t(STATUS_WX86_BREAKPOINT, STATUS_WX86_SINGLE_STEP): Move to\n+\tnat/windows-nat.c.\n+\t* nat/windows-nat.h (handle_ms_vc_exception): Declare.\n+\t(handle_exception_result): Move from windows-nat.c.\n+\t(handle_exception): Declare.\n+\t* nat/windows-nat.c (MS_VC_EXCEPTION, handle_exception)\n+\t(STATUS_WX86_SINGLE_STEP, STATUS_WX86_BREAKPOINT): Move from\n+\twindows-nat.c.\n+\n 2020-04-08  Tom Tromey  <tromey@adacore.com>\n \n \t* windows-nat.c (exception_count, event_count): Remove."
    },
    {
      "sha": "6bbf41c7b131bce92eaeffa1d3a01afef0d5669b",
      "filename": "gdb/nat/windows-nat.c",
      "status": "modified",
      "additions": 175,
      "deletions": 0,
      "changes": 175,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d30e395779603a8d36fa8bdfddba88a312552f4/gdb/nat/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d30e395779603a8d36fa8bdfddba88a312552f4/gdb/nat/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/windows-nat.c?ref=8d30e395779603a8d36fa8bdfddba88a312552f4",
      "patch": "@@ -18,6 +18,10 @@\n \n #include \"gdbsupport/common-defs.h\"\n #include \"nat/windows-nat.h\"\n+#include \"gdbsupport/common-debug.h\"\n+\n+#define STATUS_WX86_BREAKPOINT 0x4000001F\n+#define STATUS_WX86_SINGLE_STEP 0x4000001E\n \n namespace windows_nat\n {\n@@ -137,4 +141,175 @@ get_image_name (HANDLE h, void *address, int unicode)\n   return buf;\n }\n \n+/* The exception thrown by a program to tell the debugger the name of\n+   a thread.  The exception record contains an ID of a thread and a\n+   name to give it.  This exception has no documented name, but MSDN\n+   dubs it \"MS_VC_EXCEPTION\" in one code example.  */\n+#define MS_VC_EXCEPTION 0x406d1388\n+\n+handle_exception_result\n+handle_exception (struct target_waitstatus *ourstatus, bool debug_exceptions)\n+{\n+#define DEBUG_EXCEPTION_SIMPLE(x)       if (debug_exceptions) \\\n+  debug_printf (\"gdb: Target exception %s at %s\\n\", x, \\\n+    host_address_to_string (\\\n+      current_event.u.Exception.ExceptionRecord.ExceptionAddress))\n+\n+  EXCEPTION_RECORD *rec = &current_event.u.Exception.ExceptionRecord;\n+  DWORD code = rec->ExceptionCode;\n+  handle_exception_result result = HANDLE_EXCEPTION_HANDLED;\n+\n+  memcpy (&siginfo_er, rec, sizeof siginfo_er);\n+\n+  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n+\n+  /* Record the context of the current thread.  */\n+  thread_rec (ptid_t (current_event.dwProcessId, current_event.dwThreadId, 0),\n+\t      DONT_SUSPEND);\n+\n+  switch (code)\n+    {\n+    case EXCEPTION_ACCESS_VIOLATION:\n+      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ACCESS_VIOLATION\");\n+      ourstatus->value.sig = GDB_SIGNAL_SEGV;\n+#ifdef __CYGWIN__\n+      {\n+\t/* See if the access violation happened within the cygwin DLL\n+\t   itself.  Cygwin uses a kind of exception handling to deal\n+\t   with passed-in invalid addresses.  gdb should not treat\n+\t   these as real SEGVs since they will be silently handled by\n+\t   cygwin.  A real SEGV will (theoretically) be caught by\n+\t   cygwin later in the process and will be sent as a\n+\t   cygwin-specific-signal.  So, ignore SEGVs if they show up\n+\t   within the text segment of the DLL itself.  */\n+\tconst char *fn;\n+\tCORE_ADDR addr = (CORE_ADDR) (uintptr_t) rec->ExceptionAddress;\n+\n+\tif ((!cygwin_exceptions && (addr >= cygwin_load_start\n+\t\t\t\t    && addr < cygwin_load_end))\n+\t    || (find_pc_partial_function (addr, &fn, NULL, NULL)\n+\t\t&& startswith (fn, \"KERNEL32!IsBad\")))\n+\t  return HANDLE_EXCEPTION_UNHANDLED;\n+      }\n+#endif\n+      break;\n+    case STATUS_STACK_OVERFLOW:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_STACK_OVERFLOW\");\n+      ourstatus->value.sig = GDB_SIGNAL_SEGV;\n+      break;\n+    case STATUS_FLOAT_DENORMAL_OPERAND:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_DENORMAL_OPERAND\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n+      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case STATUS_FLOAT_INEXACT_RESULT:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_INEXACT_RESULT\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case STATUS_FLOAT_INVALID_OPERATION:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_INVALID_OPERATION\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case STATUS_FLOAT_OVERFLOW:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_OVERFLOW\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case STATUS_FLOAT_STACK_CHECK:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_STACK_CHECK\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case STATUS_FLOAT_UNDERFLOW:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_UNDERFLOW\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case STATUS_FLOAT_DIVIDE_BY_ZERO:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_DIVIDE_BY_ZERO\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case STATUS_INTEGER_DIVIDE_BY_ZERO:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_INTEGER_DIVIDE_BY_ZERO\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case STATUS_INTEGER_OVERFLOW:\n+      DEBUG_EXCEPTION_SIMPLE (\"STATUS_INTEGER_OVERFLOW\");\n+      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      break;\n+    case EXCEPTION_BREAKPOINT:\n+#ifdef __x86_64__\n+      if (ignore_first_breakpoint)\n+\t{\n+\t  /* For WOW64 processes, there are always 2 breakpoint exceptions\n+\t     on startup, first a BREAKPOINT for the 64bit ntdll.dll,\n+\t     then a WX86_BREAKPOINT for the 32bit ntdll.dll.\n+\t     Here we only care about the WX86_BREAKPOINT's.  */\n+\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ignore_first_breakpoint = false;\n+\t}\n+#endif\n+      /* FALLTHROUGH */\n+    case STATUS_WX86_BREAKPOINT:\n+      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_BREAKPOINT\");\n+      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n+#ifdef _WIN32_WCE\n+      /* Remove the initial breakpoint.  */\n+      check_breakpoints ((CORE_ADDR) (long) current_event\n+\t\t\t .u.Exception.ExceptionRecord.ExceptionAddress);\n+#endif\n+      break;\n+    case DBG_CONTROL_C:\n+      DEBUG_EXCEPTION_SIMPLE (\"DBG_CONTROL_C\");\n+      ourstatus->value.sig = GDB_SIGNAL_INT;\n+      break;\n+    case DBG_CONTROL_BREAK:\n+      DEBUG_EXCEPTION_SIMPLE (\"DBG_CONTROL_BREAK\");\n+      ourstatus->value.sig = GDB_SIGNAL_INT;\n+      break;\n+    case EXCEPTION_SINGLE_STEP:\n+    case STATUS_WX86_SINGLE_STEP:\n+      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_SINGLE_STEP\");\n+      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n+      break;\n+    case EXCEPTION_ILLEGAL_INSTRUCTION:\n+      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ILLEGAL_INSTRUCTION\");\n+      ourstatus->value.sig = GDB_SIGNAL_ILL;\n+      break;\n+    case EXCEPTION_PRIV_INSTRUCTION:\n+      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_PRIV_INSTRUCTION\");\n+      ourstatus->value.sig = GDB_SIGNAL_ILL;\n+      break;\n+    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n+      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_NONCONTINUABLE_EXCEPTION\");\n+      ourstatus->value.sig = GDB_SIGNAL_ILL;\n+      break;\n+    case MS_VC_EXCEPTION:\n+      DEBUG_EXCEPTION_SIMPLE (\"MS_VC_EXCEPTION\");\n+      if (handle_ms_vc_exception (rec))\n+\t{\n+\t  ourstatus->value.sig = GDB_SIGNAL_TRAP;\n+\t  result = HANDLE_EXCEPTION_IGNORED;\n+\t  break;\n+\t}\n+\t/* treat improperly formed exception as unknown */\n+\t/* FALLTHROUGH */\n+    default:\n+      /* Treat unhandled first chance exceptions specially.  */\n+      if (current_event.u.Exception.dwFirstChance)\n+\treturn HANDLE_EXCEPTION_UNHANDLED;\n+      debug_printf (\"gdb: unknown target exception 0x%08x at %s\\n\",\n+\t(unsigned) current_event.u.Exception.ExceptionRecord.ExceptionCode,\n+\thost_address_to_string (\n+\t  current_event.u.Exception.ExceptionRecord.ExceptionAddress));\n+      ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;\n+      break;\n+    }\n+\n+  last_sig = ourstatus->value.sig;\n+  return result;\n+\n+#undef DEBUG_EXCEPTION_SIMPLE\n+}\n+\n }"
    },
    {
      "sha": "a4e0b39fcab432e938f136faf88b8afc783466e5",
      "filename": "gdb/nat/windows-nat.h",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d30e395779603a8d36fa8bdfddba88a312552f4/gdb/nat/windows-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d30e395779603a8d36fa8bdfddba88a312552f4/gdb/nat/windows-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/windows-nat.h?ref=8d30e395779603a8d36fa8bdfddba88a312552f4",
      "patch": "@@ -143,6 +143,16 @@ extern void handle_load_dll ();\n \n extern void handle_unload_dll ();\n \n+/* Handle MS_VC_EXCEPTION when processing a stop.  MS_VC_EXCEPTION is\n+   somewhat undocumented but is used to tell the debugger the name of\n+   a thread.\n+\n+   Return true if the exception was handled; return false otherwise.\n+\n+   This function must be supplied by the embedding application.  */\n+\n+extern bool handle_ms_vc_exception (const EXCEPTION_RECORD *rec);\n+\n \n /* Currently executing process */\n extern HANDLE current_process_handle;\n@@ -205,6 +215,16 @@ extern EXCEPTION_RECORD siginfo_er;\n    get_image_name.  */\n extern const char *get_image_name (HANDLE h, void *address, int unicode);\n \n+typedef enum\n+{\n+  HANDLE_EXCEPTION_UNHANDLED = 0,\n+  HANDLE_EXCEPTION_HANDLED,\n+  HANDLE_EXCEPTION_IGNORED\n+} handle_exception_result;\n+\n+extern handle_exception_result handle_exception\n+  (struct target_waitstatus *ourstatus, bool debug_exceptions);\n+\n }\n \n #endif"
    },
    {
      "sha": "d48f90a5c7afff0ef14da453373fa75f136f7187",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 29,
      "deletions": 189,
      "changes": 218,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d30e395779603a8d36fa8bdfddba88a312552f4/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d30e395779603a8d36fa8bdfddba88a312552f4/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=8d30e395779603a8d36fa8bdfddba88a312552f4",
      "patch": "@@ -72,9 +72,6 @@\n #include \"gdbsupport/gdb_wait.h\"\n #include \"nat/windows-nat.h\"\n \n-#define STATUS_WX86_BREAKPOINT 0x4000001F\n-#define STATUS_WX86_SINGLE_STEP 0x4000001E\n-\n using namespace windows_nat;\n \n #define AdjustTokenPrivileges\t\tdyn_AdjustTokenPrivileges\n@@ -213,19 +210,6 @@ static int debug_registers_used;\n static int windows_initialization_done;\n #define DR6_CLEAR_VALUE 0xffff0ff0\n \n-/* The exception thrown by a program to tell the debugger the name of\n-   a thread.  The exception record contains an ID of a thread and a\n-   name to give it.  This exception has no documented name, but MSDN\n-   dubs it \"MS_VC_EXCEPTION\" in one code example.  */\n-#define MS_VC_EXCEPTION 0x406d1388\n-\n-typedef enum\n-{\n-  HANDLE_EXCEPTION_UNHANDLED = 0,\n-  HANDLE_EXCEPTION_HANDLED,\n-  HANDLE_EXCEPTION_IGNORED\n-} handle_exception_result;\n-\n /* The string sent by cygwin when it processes a signal.\n    FIXME: This should be in a cygwin include file.  */\n #ifndef _CYGWIN_SIGNAL_STRING\n@@ -1203,189 +1187,45 @@ display_selectors (const char * args, int from_tty)\n     }\n }\n \n-#define DEBUG_EXCEPTION_SIMPLE(x)       if (debug_exceptions) \\\n-  printf_unfiltered (\"gdb: Target exception %s at %s\\n\", x, \\\n-    host_address_to_string (\\\n-      current_event.u.Exception.ExceptionRecord.ExceptionAddress))\n+/* See nat/windows-nat.h.  */\n \n-static handle_exception_result\n-handle_exception (struct target_waitstatus *ourstatus)\n+bool\n+windows_nat::handle_ms_vc_exception (const EXCEPTION_RECORD *rec)\n {\n-  EXCEPTION_RECORD *rec = &current_event.u.Exception.ExceptionRecord;\n-  DWORD code = rec->ExceptionCode;\n-  handle_exception_result result = HANDLE_EXCEPTION_HANDLED;\n-\n-  memcpy (&siginfo_er, rec, sizeof siginfo_er);\n-\n-  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\n-  /* Record the context of the current thread.  */\n-  thread_rec (ptid_t (current_event.dwProcessId, current_event.dwThreadId, 0),\n-\t      DONT_SUSPEND);\n-\n-  switch (code)\n+  if (rec->NumberParameters >= 3\n+      && (rec->ExceptionInformation[0] & 0xffffffff) == 0x1000)\n     {\n-    case EXCEPTION_ACCESS_VIOLATION:\n-      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ACCESS_VIOLATION\");\n-      ourstatus->value.sig = GDB_SIGNAL_SEGV;\n-#ifdef __CYGWIN__\n-      {\n-\t/* See if the access violation happened within the cygwin DLL\n-\t   itself.  Cygwin uses a kind of exception handling to deal\n-\t   with passed-in invalid addresses.  gdb should not treat\n-\t   these as real SEGVs since they will be silently handled by\n-\t   cygwin.  A real SEGV will (theoretically) be caught by\n-\t   cygwin later in the process and will be sent as a\n-\t   cygwin-specific-signal.  So, ignore SEGVs if they show up\n-\t   within the text segment of the DLL itself.  */\n-\tconst char *fn;\n-\tCORE_ADDR addr = (CORE_ADDR) (uintptr_t) rec->ExceptionAddress;\n-\n-\tif ((!cygwin_exceptions && (addr >= cygwin_load_start\n-\t\t\t\t    && addr < cygwin_load_end))\n-\t    || (find_pc_partial_function (addr, &fn, NULL, NULL)\n-\t\t&& startswith (fn, \"KERNEL32!IsBad\")))\n-\t  return HANDLE_EXCEPTION_UNHANDLED;\n-      }\n-#endif\n-      break;\n-    case STATUS_STACK_OVERFLOW:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_STACK_OVERFLOW\");\n-      ourstatus->value.sig = GDB_SIGNAL_SEGV;\n-      break;\n-    case STATUS_FLOAT_DENORMAL_OPERAND:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_DENORMAL_OPERAND\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n-      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_INEXACT_RESULT:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_INEXACT_RESULT\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_INVALID_OPERATION:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_INVALID_OPERATION\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_OVERFLOW:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_OVERFLOW\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_STACK_CHECK:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_STACK_CHECK\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_UNDERFLOW:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_UNDERFLOW\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_DIVIDE_BY_ZERO:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_DIVIDE_BY_ZERO\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_INTEGER_DIVIDE_BY_ZERO:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_INTEGER_DIVIDE_BY_ZERO\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_INTEGER_OVERFLOW:\n-      DEBUG_EXCEPTION_SIMPLE (\"STATUS_INTEGER_OVERFLOW\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case EXCEPTION_BREAKPOINT:\n-#ifdef __x86_64__\n-      if (ignore_first_breakpoint)\n-\t{\n-\t  /* For WOW64 processes, there are always 2 breakpoint exceptions\n-\t     on startup, first a BREAKPOINT for the 64bit ntdll.dll,\n-\t     then a WX86_BREAKPOINT for the 32bit ntdll.dll.\n-\t     Here we only care about the WX86_BREAKPOINT's.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n-\t  ignore_first_breakpoint = false;\n-\t}\n-#endif\n-      /* FALLTHROUGH */\n-    case STATUS_WX86_BREAKPOINT:\n-      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_BREAKPOINT\");\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-      break;\n-    case DBG_CONTROL_C:\n-      DEBUG_EXCEPTION_SIMPLE (\"DBG_CONTROL_C\");\n-      ourstatus->value.sig = GDB_SIGNAL_INT;\n-      break;\n-    case DBG_CONTROL_BREAK:\n-      DEBUG_EXCEPTION_SIMPLE (\"DBG_CONTROL_BREAK\");\n-      ourstatus->value.sig = GDB_SIGNAL_INT;\n-      break;\n-    case EXCEPTION_SINGLE_STEP:\n-    case STATUS_WX86_SINGLE_STEP:\n-      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_SINGLE_STEP\");\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-      break;\n-    case EXCEPTION_ILLEGAL_INSTRUCTION:\n-      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ILLEGAL_INSTRUCTION\");\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n-      break;\n-    case EXCEPTION_PRIV_INSTRUCTION:\n-      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_PRIV_INSTRUCTION\");\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n-      break;\n-    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n-      DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_NONCONTINUABLE_EXCEPTION\");\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n-      break;\n-    case MS_VC_EXCEPTION:\n-      if (rec->NumberParameters >= 3\n-\t  && (rec->ExceptionInformation[0] & 0xffffffff) == 0x1000)\n-\t{\n-\t  DWORD named_thread_id;\n-\t  windows_thread_info *named_thread;\n-\t  CORE_ADDR thread_name_target;\n+      DWORD named_thread_id;\n+      windows_thread_info *named_thread;\n+      CORE_ADDR thread_name_target;\n \n-\t  DEBUG_EXCEPTION_SIMPLE (\"MS_VC_EXCEPTION\");\n+      thread_name_target = rec->ExceptionInformation[1];\n+      named_thread_id = (DWORD) (0xffffffff & rec->ExceptionInformation[2]);\n \n-\t  thread_name_target = rec->ExceptionInformation[1];\n-\t  named_thread_id = (DWORD) (0xffffffff & rec->ExceptionInformation[2]);\n+      if (named_thread_id == (DWORD) -1)\n+\tnamed_thread_id = current_event.dwThreadId;\n \n-\t  if (named_thread_id == (DWORD) -1)\n-\t    named_thread_id = current_event.dwThreadId;\n+      named_thread = thread_rec (ptid_t (current_event.dwProcessId,\n+\t\t\t\t\t named_thread_id, 0),\n+\t\t\t\t DONT_INVALIDATE_CONTEXT);\n+      if (named_thread != NULL)\n+\t{\n+\t  int thread_name_len;\n+\t  gdb::unique_xmalloc_ptr<char> thread_name;\n \n-\t  named_thread = thread_rec (ptid_t (current_event.dwProcessId,\n-\t\t\t\t\t     named_thread_id, 0),\n-\t\t\t\t     DONT_INVALIDATE_CONTEXT);\n-\t  if (named_thread != NULL)\n+\t  thread_name_len = target_read_string (thread_name_target,\n+\t\t\t\t\t\t&thread_name, 1025, NULL);\n+\t  if (thread_name_len > 0)\n \t    {\n-\t      int thread_name_len;\n-\t      gdb::unique_xmalloc_ptr<char> thread_name;\n-\n-\t      thread_name_len = target_read_string (thread_name_target,\n-\t\t\t\t\t\t    &thread_name, 1025, NULL);\n-\t      if (thread_name_len > 0)\n-\t\t{\n-\t\t  thread_name.get ()[thread_name_len - 1] = '\\0';\n-\t\t  named_thread->name = std::move (thread_name);\n-\t\t}\n+\t      thread_name.get ()[thread_name_len - 1] = '\\0';\n+\t      named_thread->name = std::move (thread_name);\n \t    }\n-\t  ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-\t  result = HANDLE_EXCEPTION_IGNORED;\n-\t  break;\n \t}\n-\t/* treat improperly formed exception as unknown */\n-\t/* FALLTHROUGH */\n-    default:\n-      /* Treat unhandled first chance exceptions specially.  */\n-      if (current_event.u.Exception.dwFirstChance)\n-\treturn HANDLE_EXCEPTION_UNHANDLED;\n-      printf_unfiltered (\"gdb: unknown target exception 0x%08x at %s\\n\",\n-\t(unsigned) current_event.u.Exception.ExceptionRecord.ExceptionCode,\n-\thost_address_to_string (\n-\t  current_event.u.Exception.ExceptionRecord.ExceptionAddress));\n-      ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;\n-      break;\n+\n+      return true;\n     }\n-  last_sig = ourstatus->value.sig;\n-  return result;\n+\n+  return false;\n }\n \n /* Resume thread specified by ID, or all artificially suspended\n@@ -1876,7 +1716,7 @@ windows_nat_target::get_windows_debug_event (int pid,\n \t\t     \"EXCEPTION_DEBUG_EVENT\"));\n       if (saw_create != 1)\n \tbreak;\n-      switch (handle_exception (ourstatus))\n+      switch (handle_exception (ourstatus, debug_exceptions))\n \t{\n \tcase HANDLE_EXCEPTION_UNHANDLED:\n \tdefault:"
    },
    {
      "sha": "a00176aa4251aa3ac0f642513a6ece4a69eaa7ac",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d30e395779603a8d36fa8bdfddba88a312552f4/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d30e395779603a8d36fa8bdfddba88a312552f4/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=8d30e395779603a8d36fa8bdfddba88a312552f4",
      "patch": "@@ -1,3 +1,11 @@\n+2020-04-08  Tom Tromey  <tromey@adacore.com>\n+\n+\t* win32-low.c (handle_exception): Remove.\n+\t(windows_nat::handle_ms_vc_exception): New function.\n+\t(get_child_debug_event): Add \"continue_status\" parameter.\n+\tUpdate.\n+\t(win32_wait): Update.\n+\n 2020-04-08  Tom Tromey  <tromey@adacore.com>\n \n \t* win32-low.c (windows_nat::handle_load_dll): Rename from"
    },
    {
      "sha": "7018083746ba479a6179a859b014908b0fa2a2fc",
      "filename": "gdbserver/win32-low.cc",
      "status": "modified",
      "additions": 17,
      "deletions": 115,
      "changes": 132,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d30e395779603a8d36fa8bdfddba88a312552f4/gdbserver/win32-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d30e395779603a8d36fa8bdfddba88a312552f4/gdbserver/win32-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/win32-low.cc?ref=8d30e395779603a8d36fa8bdfddba88a312552f4",
      "patch": "@@ -1154,117 +1154,6 @@ windows_nat::handle_unload_dll ()\n   unloaded_dll (NULL, load_addr);\n }\n \n-static void\n-handle_exception (struct target_waitstatus *ourstatus)\n-{\n-  DWORD code = current_event.u.Exception.ExceptionRecord.ExceptionCode;\n-\n-  memcpy (&siginfo_er, &current_event.u.Exception.ExceptionRecord,\n-\t  sizeof siginfo_er);\n-\n-  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\n-  switch (code)\n-    {\n-    case EXCEPTION_ACCESS_VIOLATION:\n-      OUTMSG2 ((\"EXCEPTION_ACCESS_VIOLATION\"));\n-      ourstatus->value.sig = GDB_SIGNAL_SEGV;\n-      break;\n-    case STATUS_STACK_OVERFLOW:\n-      OUTMSG2 ((\"STATUS_STACK_OVERFLOW\"));\n-      ourstatus->value.sig = GDB_SIGNAL_SEGV;\n-      break;\n-    case STATUS_FLOAT_DENORMAL_OPERAND:\n-      OUTMSG2 ((\"STATUS_FLOAT_DENORMAL_OPERAND\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n-      OUTMSG2 ((\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_INEXACT_RESULT:\n-      OUTMSG2 ((\"STATUS_FLOAT_INEXACT_RESULT\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_INVALID_OPERATION:\n-      OUTMSG2 ((\"STATUS_FLOAT_INVALID_OPERATION\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_OVERFLOW:\n-      OUTMSG2 ((\"STATUS_FLOAT_OVERFLOW\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_STACK_CHECK:\n-      OUTMSG2 ((\"STATUS_FLOAT_STACK_CHECK\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_UNDERFLOW:\n-      OUTMSG2 ((\"STATUS_FLOAT_UNDERFLOW\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_FLOAT_DIVIDE_BY_ZERO:\n-      OUTMSG2 ((\"STATUS_FLOAT_DIVIDE_BY_ZERO\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_INTEGER_DIVIDE_BY_ZERO:\n-      OUTMSG2 ((\"STATUS_INTEGER_DIVIDE_BY_ZERO\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case STATUS_INTEGER_OVERFLOW:\n-      OUTMSG2 ((\"STATUS_INTEGER_OVERFLOW\"));\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n-      break;\n-    case EXCEPTION_BREAKPOINT:\n-      OUTMSG2 ((\"EXCEPTION_BREAKPOINT\"));\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-#ifdef _WIN32_WCE\n-      /* Remove the initial breakpoint.  */\n-      check_breakpoints ((CORE_ADDR) (long) current_event\n-\t\t\t .u.Exception.ExceptionRecord.ExceptionAddress);\n-#endif\n-      break;\n-    case DBG_CONTROL_C:\n-      OUTMSG2 ((\"DBG_CONTROL_C\"));\n-      ourstatus->value.sig = GDB_SIGNAL_INT;\n-      break;\n-    case DBG_CONTROL_BREAK:\n-      OUTMSG2 ((\"DBG_CONTROL_BREAK\"));\n-      ourstatus->value.sig = GDB_SIGNAL_INT;\n-      break;\n-    case EXCEPTION_SINGLE_STEP:\n-      OUTMSG2 ((\"EXCEPTION_SINGLE_STEP\"));\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-      break;\n-    case EXCEPTION_ILLEGAL_INSTRUCTION:\n-      OUTMSG2 ((\"EXCEPTION_ILLEGAL_INSTRUCTION\"));\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n-      break;\n-    case EXCEPTION_PRIV_INSTRUCTION:\n-      OUTMSG2 ((\"EXCEPTION_PRIV_INSTRUCTION\"));\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n-      break;\n-    case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n-      OUTMSG2 ((\"EXCEPTION_NONCONTINUABLE_EXCEPTION\"));\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n-      break;\n-    default:\n-      if (current_event.u.Exception.dwFirstChance)\n-\t{\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n-\t  return;\n-\t}\n-      OUTMSG2 ((\"gdbserver: unknown target exception 0x%08x at 0x%s\",\n-\t    (unsigned) current_event.u.Exception.ExceptionRecord.ExceptionCode,\n-\t    phex_nz ((uintptr_t) current_event.u.Exception.ExceptionRecord.\n-\t    ExceptionAddress, sizeof (uintptr_t))));\n-      ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;\n-      break;\n-    }\n-  OUTMSG2 ((\"\\n\"));\n-  last_sig = ourstatus->value.sig;\n-}\n-\n-\n static void\n suspend_one_thread (thread_info *thread)\n {\n@@ -1297,15 +1186,25 @@ auto_delete_breakpoint (CORE_ADDR stop_pc)\n }\n #endif\n \n+/* See nat/windows-nat.h.  */\n+\n+bool\n+windows_nat::handle_ms_vc_exception (const EXCEPTION_RECORD *rec)\n+{\n+  return false;\n+}\n+\n /* Get the next event from the child.  */\n \n static int\n-get_child_debug_event (struct target_waitstatus *ourstatus)\n+get_child_debug_event (DWORD *continue_status,\n+\t\t       struct target_waitstatus *ourstatus)\n {\n   ptid_t ptid;\n \n   last_sig = GDB_SIGNAL_0;\n   ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+  *continue_status = DBG_CONTINUE;\n \n   /* Check if GDB sent us an interrupt request.  */\n   check_remote_input_interrupt_request ();\n@@ -1488,7 +1387,9 @@ get_child_debug_event (struct target_waitstatus *ourstatus)\n \t\t\"for pid=%u tid=%x\\n\",\n \t\t(unsigned) current_event.dwProcessId,\n \t\t(unsigned) current_event.dwThreadId));\n-      handle_exception (ourstatus);\n+      if (handle_exception (ourstatus, debug_threads)\n+\t  == HANDLE_EXCEPTION_UNHANDLED)\n+\t*continue_status = DBG_EXCEPTION_NOT_HANDLED;\n       break;\n \n     case OUTPUT_DEBUG_STRING_EVENT:\n@@ -1536,7 +1437,8 @@ win32_process_target::wait (ptid_t ptid, target_waitstatus *ourstatus,\n \n   while (1)\n     {\n-      if (!get_child_debug_event (ourstatus))\n+      DWORD continue_status;\n+      if (!get_child_debug_event (&continue_status, ourstatus))\n \tcontinue;\n \n       switch (ourstatus->kind)\n@@ -1560,7 +1462,7 @@ win32_process_target::wait (ptid_t ptid, target_waitstatus *ourstatus,\n \t  /* fall-through */\n \tcase TARGET_WAITKIND_SPURIOUS:\n \t  /* do nothing, just continue */\n-\t  child_continue (DBG_CONTINUE, -1);\n+\t  child_continue (continue_status, -1);\n \t  break;\n \t}\n     }"
    }
  ]
}