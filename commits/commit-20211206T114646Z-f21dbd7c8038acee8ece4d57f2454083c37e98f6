{
  "sha": "f21dbd7c8038acee8ece4d57f2454083c37e98f6",
  "node_id": "C_kwDOANOeidoAKGYyMWRiZDdjODAzOGFjZWU4ZWNlNGQ1N2YyNDU0MDgzYzM3ZTk4ZjY",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-11-24T13:30:50Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-12-06T11:46:46Z"
    },
    "message": "[GOLD] PowerPC64 inline plt sequences\n\nThe fixes gold failures to handle inline PLT sequences properly.\nPowerPC gold was always turning these back into direct calls due to\ngsym->use_plt_offset() returning false.  This is fixed for dynamic\nlinking by correcting get_reference_flags, and for static linking by\noverriding use_plt_offset() in relocate().  The rest of the patch\nrevolves around needing to create PLT entries for inline PLT calls\nwhen statically linking (for gcc -mlongcall).  The lplt section\nhandled that for local symbols, now it does globals too.\n\n\t* powerpc.cc (Target_powerpc::plt_off): Return proper section\n\tfor static link.\n\t(Target_powerpc::symval_for_branch): Make public.\n\t(Target_powerpc::make_lplt_section): Add Symbol_table* param.\n\tAdjust all calls.\n\t(Target_powerpc::make_local_plt_entry): Likewise.\n\t(Target_powerpc::make_local_plt_entry): New variant for global syms.\n\t(Powerpc_relobj::do_relocate_sections): Don't write lplt contents.\n\t(Output_data_plt_powerpc::do_write): Write lplt contents here.\n\t(Output_data_plt_powerpc::Output_data_plt_powerpc): Save\n\tsymbol table pointer.  Adjust all uses.\n\t(Output_data_plt_powerpc::add_entry): Add stash parameter.  Don't\n\tdo dynamic reloc handling when no reloc section.  Save symbol\n\tfor local plt entries.\n\t(Output_data_plt_powerpc::add_local_entry): Save symbol.\n\t(Output_data_plt_powerpc::Local_plt_ent): New class.\n\t(Output_data_plt_powerpc::sym_ents_): New vector.\n\t(Target_powerpc::Scan::get_reference_flags): Return\n\tFUNCTION_CALL|RELATIVE_REF for inline plt relocs.\n\t(Target_powerpc::Scan::global): Make entries in lplt for inline\n\tplt call relocation symbols.\n\t(Target_powerpc::Relocate::relocate): Rename has_plt_offset to\n\tuse_plt_offset.  Set use_plt_offset for inline plt relocs.",
    "tree": {
      "sha": "e7d3d9725fd59d0385bbdcbe1cdfcc8527c4e2e7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e7d3d9725fd59d0385bbdcbe1cdfcc8527c4e2e7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f21dbd7c8038acee8ece4d57f2454083c37e98f6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f21dbd7c8038acee8ece4d57f2454083c37e98f6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f21dbd7c8038acee8ece4d57f2454083c37e98f6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f21dbd7c8038acee8ece4d57f2454083c37e98f6/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "74044dc84074abca775c63462ecccc10a7900987",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74044dc84074abca775c63462ecccc10a7900987",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/74044dc84074abca775c63462ecccc10a7900987"
    }
  ],
  "stats": {
    "total": 226,
    "additions": 162,
    "deletions": 64
  },
  "files": [
    {
      "sha": "103eef85943ca5bff898882c7159d4b6b2a564c4",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 162,
      "deletions": 64,
      "changes": 226,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f21dbd7c8038acee8ece4d57f2454083c37e98f6/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f21dbd7c8038acee8ece4d57f2454083c37e98f6/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=f21dbd7c8038acee8ece4d57f2454083c37e98f6",
      "patch": "@@ -927,8 +927,10 @@ class Target_powerpc : public Sized_target<size, big_endian>\n     if (gsym->type() == elfcpp::STT_GNU_IFUNC\n \t&& gsym->can_use_relative_reloc(false))\n       *sec = this->iplt_section();\n-    else\n+    else if (!parameters->doing_static_link())\n       *sec = this->plt_section();\n+    else\n+      *sec = this->lplt_section();\n     return gsym->plt_offset();\n   }\n \n@@ -1262,6 +1264,12 @@ class Target_powerpc : public Sized_target<size, big_endian>\n   void\n   merge_object_attributes(const Object*, const Attributes_section_data*);\n \n+  bool\n+  symval_for_branch(const Symbol_table* symtab,\n+\t\t    const Sized_symbol<size>* gsym,\n+\t\t    Powerpc_relobj<size, big_endian>* object,\n+\t\t    Address *value, unsigned int *dest_shndx);\n+\n  private:\n \n   class Track_tls\n@@ -1464,12 +1472,6 @@ class Target_powerpc : public Sized_target<size, big_endian>\n     bool issued_non_pic_error_;\n   };\n \n-  bool\n-  symval_for_branch(const Symbol_table* symtab,\n-\t\t    const Sized_symbol<size>* gsym,\n-\t\t    Powerpc_relobj<size, big_endian>* object,\n-\t\t    Address *value, unsigned int *dest_shndx);\n-\n   // The class which implements relocation.\n   class Relocate : protected Track_tls\n   {\n@@ -1569,7 +1571,7 @@ class Target_powerpc : public Sized_target<size, big_endian>\n   make_iplt_section(Symbol_table*, Layout*);\n \n   void\n-  make_lplt_section(Layout*);\n+  make_lplt_section(Symbol_table*, Layout*);\n \n   void\n   make_brlt_section(Layout*);\n@@ -1586,10 +1588,12 @@ class Target_powerpc : public Sized_target<size, big_endian>\n \n   // Create a PLT entry for a local non-IFUNC symbol.\n   void\n-  make_local_plt_entry(Layout*,\n+  make_local_plt_entry(Symbol_table*, Layout*,\n \t\t       Sized_relobj_file<size, big_endian>*,\n \t\t       unsigned int);\n \n+  void\n+  make_local_plt_entry(Symbol_table*, Layout*, Symbol*);\n \n   // Create a GOT entry for local dynamic __tls_get_addr.\n   unsigned int\n@@ -2771,33 +2775,6 @@ Powerpc_relobj<size, big_endian>::do_relocate_sections(\n     }\n   this->relocate_section_range(symtab, layout, pshdrs, of, pviews,\n \t\t\t       start, this->shnum() - 1);\n-\n-  if (!parameters->options().output_is_position_independent())\n-    {\n-      Target_powerpc<size, big_endian>* target\n-\t= static_cast<Target_powerpc<size, big_endian>*>(\n-\t    parameters->sized_target<size, big_endian>());\n-      if (target->lplt_section() && target->lplt_section()->data_size() != 0)\n-\t{\n-\t  const section_size_type offset = target->lplt_section()->offset();\n-\t  const section_size_type oview_size\n-\t    = convert_to_section_size_type(target->lplt_section()->data_size());\n-\t  unsigned char* const oview = of->get_output_view(offset, oview_size);\n-\n-\t  bool modified = false;\n-\t  unsigned int nsyms = this->local_symbol_count();\n-\t  for (unsigned int i = 0; i < nsyms; i++)\n-\t    if (this->local_has_plt_offset(i))\n-\t      {\n-\t\tAddress value = this->local_symbol_value(i, 0);\n-\t\tsize_t off = this->local_plt_offset(i);\n-\t\telfcpp::Swap<size, big_endian>::writeval(oview + off, value);\n-\t\tmodified = true;\n-\t      }\n-\t  if (modified)\n-\t    of->write_output_view(offset, oview_size, oview);\n-\t}\n-    }\n }\n \n // Set up some symbols.\n@@ -4047,17 +4024,16 @@ class Output_data_plt_powerpc : public Output_section_data_build\n \t\t\t    size, big_endian> Reloc_section;\n \n   Output_data_plt_powerpc(Target_powerpc<size, big_endian>* targ,\n+\t\t\t  Symbol_table* symtab,\n \t\t\t  Reloc_section* plt_rel,\n \t\t\t  const char* name)\n     : Output_section_data_build(size == 32 ? 4 : 8),\n-      rel_(plt_rel),\n-      targ_(targ),\n-      name_(name)\n+      rel_(plt_rel), targ_(targ), symtab_(symtab), name_(name), sym_ents_()\n   { }\n \n   // Add an entry to the PLT.\n   void\n-  add_entry(Symbol*);\n+  add_entry(Symbol*, bool = false);\n \n   void\n   add_ifunc_entry(Symbol*);\n@@ -4098,6 +4074,23 @@ class Output_data_plt_powerpc : public Output_section_data_build\n   { mapfile->print_output_data(this, this->name_); }\n \n  private:\n+  struct Local_plt_ent\n+  {\n+    Local_plt_ent(Sized_relobj_file<size, big_endian>* obj, unsigned int rsym)\n+    { rsym_ = rsym; u.obj_ = obj; }\n+    Local_plt_ent(Symbol* sym)\n+    { rsym_ = -1u; u.gsym_ = sym; }\n+    ~Local_plt_ent()\n+    { }\n+\n+    unsigned int rsym_;\n+    union\n+    {\n+      Sized_relobj_file<size, big_endian>* obj_;\n+      Symbol* gsym_;\n+    } u;\n+  };\n+\n   // Return the offset of the first non-reserved PLT entry.\n   unsigned int\n   first_plt_entry_offset() const\n@@ -4123,27 +4116,39 @@ class Output_data_plt_powerpc : public Output_section_data_build\n   Reloc_section* rel_;\n   // Allows access to .glink for do_write.\n   Target_powerpc<size, big_endian>* targ_;\n+  Symbol_table* symtab_;\n   // What to report in map file.\n   const char *name_;\n+\n+  std::vector<Local_plt_ent> sym_ents_;\n };\n \n // Add an entry to the PLT.\n \n template<int size, bool big_endian>\n void\n-Output_data_plt_powerpc<size, big_endian>::add_entry(Symbol* gsym)\n+Output_data_plt_powerpc<size, big_endian>::add_entry(Symbol* gsym,\n+\t\t\t\t\t\t     bool stash)\n {\n   if (!gsym->has_plt_offset())\n     {\n       section_size_type off = this->current_data_size();\n       if (off == 0)\n \toff += this->first_plt_entry_offset();\n       gsym->set_plt_offset(off);\n-      gsym->set_needs_dynsym_entry();\n-      unsigned int dynrel = elfcpp::R_POWERPC_JMP_SLOT;\n-      this->rel_->add_global(gsym, dynrel, this, off, 0);\n+      if (this->rel_)\n+\t{\n+\t  gsym->set_needs_dynsym_entry();\n+\t  unsigned int dynrel = elfcpp::R_POWERPC_JMP_SLOT;\n+\t  this->rel_->add_global(gsym, dynrel, this, off, 0);\n+\t}\n       off += this->plt_entry_size();\n       this->set_current_data_size(off);\n+      if (stash)\n+\t{\n+\t  Local_plt_ent sym(gsym);\n+\t  this->sym_ents_.push_back(sym);\n+\t}\n     }\n }\n \n@@ -4188,6 +4193,8 @@ Output_data_plt_powerpc<size, big_endian>::add_local_entry(\n \t}\n       off += this->plt_entry_size();\n       this->set_current_data_size(off);\n+      Local_plt_ent sym(relobj, local_sym_index);\n+      this->sym_ents_.push_back(sym);\n     }\n }\n \n@@ -4326,6 +4333,58 @@ template<int size, bool big_endian>\n void\n Output_data_plt_powerpc<size, big_endian>::do_write(Output_file* of)\n {\n+  if (!this->sym_ents_.empty())\n+    {\n+      const section_size_type offset = this->offset();\n+      const section_size_type oview_size\n+\t= convert_to_section_size_type(this->data_size());\n+      unsigned char* const oview = of->get_output_view(offset, oview_size);\n+      unsigned char* pov = oview;\n+      unsigned char* endpov = oview + oview_size;\n+\n+      for (typename std::vector<Local_plt_ent>::iterator e\n+\t     = this->sym_ents_.begin();\n+\t   e != this->sym_ents_.end();\n+\t   e++)\n+\t{\n+\t  typename elfcpp::Elf_types<size>::Elf_Addr val;\n+\t  Sized_symbol<size>* gsym = NULL;\n+\t  Powerpc_relobj<size, big_endian>* obj = NULL;\n+\t  if (e->rsym_ == -1u)\n+\t    {\n+\t      gsym = static_cast<Sized_symbol<size>*>(e->u.gsym_);\n+\t      val = gsym->value();\n+\t    }\n+\t  else\n+\t    {\n+\t      obj = static_cast<Powerpc_relobj<size, big_endian>*>(e->u.obj_);\n+\t      val = obj->local_symbol(e->rsym_)->value(obj, 0);\n+\t    }\n+\t  if (this->targ_->abiversion() >= 2)\n+\t    {\n+\t      elfcpp::Swap<size, big_endian>::writeval(pov, val);\n+\t      pov += size / 8;\n+\t    }\n+\t  else\n+\t    {\n+\t      unsigned int shndx;\n+\t      this->targ_->symval_for_branch(this->symtab_, gsym, obj,\n+\t\t\t\t\t     &val, &shndx);\n+\t      elfcpp::Swap<size, big_endian>::writeval(pov, val);\n+\t      pov += size / 8;\n+\t      val = this->targ_->toc_pointer();\n+\t      elfcpp::Swap<size, big_endian>::writeval(pov, val);\n+\t      pov += size / 8;\n+\t      if (this->plt_entry_size() > 16)\n+\t\t{\n+\t\t  elfcpp::Swap<size, big_endian>::writeval(pov, 0);\n+\t\t  pov += size / 8;\n+\t\t}\n+\t    }\n+\t}\n+      gold_assert(pov == endpov);\n+    }\n+\n   if (size == 32 && (this->name_[3] != 'I' && this->name_[3] != 'L'))\n     {\n       const section_size_type offset = this->offset();\n@@ -4376,7 +4435,7 @@ Target_powerpc<size, big_endian>::make_plt_section(Symbol_table* symtab,\n \t\t\t\t      elfcpp::SHF_ALLOC, plt_rel,\n \t\t\t\t      ORDER_DYNAMIC_PLT_RELOCS, false);\n       this->plt_\n-\t= new Output_data_plt_powerpc<size, big_endian>(this, plt_rel,\n+\t= new Output_data_plt_powerpc<size, big_endian>(this, symtab, plt_rel,\n \t\t\t\t\t\t\t\"** PLT\");\n       layout->add_output_section_data(\".plt\",\n \t\t\t\t      (size == 32\n@@ -4404,13 +4463,13 @@ Target_powerpc<size, big_endian>::make_iplt_section(Symbol_table* symtab,\n   if (this->iplt_ == NULL)\n     {\n       this->make_plt_section(symtab, layout);\n-      this->make_lplt_section(layout);\n+      this->make_lplt_section(symtab, layout);\n \n       Reloc_section* iplt_rel = new Reloc_section(false);\n       if (this->rela_dyn_->output_section())\n \tthis->rela_dyn_->output_section()->add_output_section_data(iplt_rel);\n       this->iplt_\n-\t= new Output_data_plt_powerpc<size, big_endian>(this, iplt_rel,\n+\t= new Output_data_plt_powerpc<size, big_endian>(this, symtab, iplt_rel,\n \t\t\t\t\t\t\t\"** IPLT\");\n       if (this->plt_->output_section())\n \tthis->plt_->output_section()->add_output_section_data(this->iplt_);\n@@ -4421,7 +4480,8 @@ Target_powerpc<size, big_endian>::make_iplt_section(Symbol_table* symtab,\n \n template<int size, bool big_endian>\n void\n-Target_powerpc<size, big_endian>::make_lplt_section(Layout* layout)\n+Target_powerpc<size, big_endian>::make_lplt_section(Symbol_table* symtab,\n+\t\t\t\t\t\t    Layout* layout)\n {\n   if (this->lplt_ == NULL)\n     {\n@@ -4435,7 +4495,7 @@ Target_powerpc<size, big_endian>::make_lplt_section(Layout* layout)\n \t      ->add_output_section_data(lplt_rel);\n \t}\n       this->lplt_\n-\t= new Output_data_plt_powerpc<size, big_endian>(this, lplt_rel,\n+\t= new Output_data_plt_powerpc<size, big_endian>(this, symtab, lplt_rel,\n \t\t\t\t\t\t\t\"** LPLT\");\n       this->make_brlt_section(layout);\n       if (this->brlt_section_ && this->brlt_section_->output_section())\n@@ -7416,15 +7476,27 @@ Target_powerpc<size, big_endian>::make_plt_entry(Symbol_table* symtab,\n template<int size, bool big_endian>\n void\n Target_powerpc<size, big_endian>::make_local_plt_entry(\n+    Symbol_table* symtab,\n     Layout* layout,\n     Sized_relobj_file<size, big_endian>* relobj,\n     unsigned int r_sym)\n {\n   if (this->lplt_ == NULL)\n-    this->make_lplt_section(layout);\n+    this->make_lplt_section(symtab, layout);\n   this->lplt_->add_local_entry(relobj, r_sym);\n }\n \n+template<int size, bool big_endian>\n+void\n+Target_powerpc<size, big_endian>::make_local_plt_entry(Symbol_table* symtab,\n+\t\t\t\t\t\t       Layout* layout,\n+\t\t\t\t\t\t       Symbol* gsym)\n+{\n+  if (this->lplt_ == NULL)\n+    this->make_lplt_section(symtab, layout);\n+  this->lplt_->add_entry(gsym, true);\n+}\n+\n // Make a PLT entry for a local STT_GNU_IFUNC symbol.\n \n template<int size, bool big_endian>\n@@ -7552,6 +7624,16 @@ Target_powerpc<size, big_endian>::Scan::get_reference_flags(\n     case elfcpp::R_POWERPC_REL14:\n     case elfcpp::R_POWERPC_REL14_BRTAKEN:\n     case elfcpp::R_POWERPC_REL14_BRNTAKEN:\n+    case elfcpp::R_POWERPC_PLT16_LO:\n+    case elfcpp::R_POWERPC_PLT16_HI:\n+    case elfcpp::R_POWERPC_PLT16_HA:\n+    case elfcpp::R_PPC64_PLT16_LO_DS:\n+    case elfcpp::R_POWERPC_PLTSEQ:\n+    case elfcpp::R_PPC64_PLTSEQ_NOTOC:\n+    case elfcpp::R_POWERPC_PLTCALL:\n+    case elfcpp::R_PPC64_PLTCALL_NOTOC:\n+    case elfcpp::R_PPC64_PLT_PCREL34:\n+    case elfcpp::R_PPC64_PLT_PCREL34_NOTOC:\n       ref = Symbol::FUNCTION_CALL | Symbol::RELATIVE_REF;\n       break;\n \n@@ -7568,12 +7650,6 @@ Target_powerpc<size, big_endian>::Scan::get_reference_flags(\n     case elfcpp::R_PPC64_TOC16_HA:\n     case elfcpp::R_PPC64_TOC16_DS:\n     case elfcpp::R_PPC64_TOC16_LO_DS:\n-    case elfcpp::R_POWERPC_PLT16_LO:\n-    case elfcpp::R_POWERPC_PLT16_HI:\n-    case elfcpp::R_POWERPC_PLT16_HA:\n-    case elfcpp::R_PPC64_PLT16_LO_DS:\n-    case elfcpp::R_PPC64_PLT_PCREL34:\n-    case elfcpp::R_PPC64_PLT_PCREL34_NOTOC:\n       ref = Symbol::RELATIVE_REF;\n       break;\n \n@@ -8040,7 +8116,7 @@ Target_powerpc<size, big_endian>::Scan::local(\n       if (!is_ifunc)\n \t{\n \t  unsigned int r_sym = elfcpp::elf_r_sym<size>(reloc.get_r_info());\n-\t  target->make_local_plt_entry(layout, object, r_sym);\n+\t  target->make_local_plt_entry(symtab, layout, object, r_sym);\n \t}\n       break;\n \n@@ -8785,7 +8861,12 @@ Target_powerpc<size, big_endian>::Scan::global(\n     case elfcpp::R_POWERPC_PLT16_HA:\n     case elfcpp::R_PPC64_PLT16_LO_DS:\n       if (!pushed_ifunc)\n-\ttarget->make_plt_entry(symtab, layout, gsym);\n+\t{\n+\t  if (!parameters->doing_static_link())\n+\t    target->make_plt_entry(symtab, layout, gsym);\n+\t  else\n+\t    target->make_local_plt_entry(symtab, layout, gsym);\n+\t}\n       break;\n \n     case elfcpp::R_PPC64_REL24_NOTOC:\n@@ -10469,11 +10550,28 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n   bool has_stub_value = false;\n   bool localentry0 = false;\n   unsigned int r_sym = elfcpp::elf_r_sym<size>(rela.get_r_info());\n-  bool has_plt_offset\n+  bool use_plt_offset\n     = (gsym != NULL\n        ? gsym->use_plt_offset(Scan::get_reference_flags(r_type, target))\n        : object->local_has_plt_offset(r_sym));\n-  if (has_plt_offset\n+  if (is_plt16_reloc<size>(r_type)\n+      || r_type == elfcpp::R_PPC64_PLT_PCREL34\n+      || r_type == elfcpp::R_PPC64_PLT_PCREL34_NOTOC\n+      || r_type == elfcpp::R_POWERPC_PLTSEQ\n+      || r_type == elfcpp::R_PPC64_PLTSEQ_NOTOC\n+      || r_type == elfcpp::R_POWERPC_PLTCALL\n+      || r_type == elfcpp::R_PPC64_PLTCALL_NOTOC)\n+    {\n+      // It would be possible to replace inline plt calls with direct\n+      // calls if the PLTCALL is in range.  The only difficulty is\n+      // that the decision depends on the PLTCALL reloc, and we don't\n+      // know the address of that instruction when processing others\n+      // in the sequence.  So the decision needs to be made in\n+      // do_relax().  For now, don't optimise inline plt calls.\n+      if (gsym)\n+\tuse_plt_offset = gsym->has_plt_offset();\n+    }\n+  if (use_plt_offset\n       && !is_got_reloc(r_type)\n       && !is_plt16_reloc<size>(r_type)\n       && r_type != elfcpp::R_PPC64_PLT_PCREL34\n@@ -10567,7 +10665,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       gold_assert(has_stub_value || !(os->flags() & elfcpp::SHF_ALLOC));\n     }\n \n-  if (has_plt_offset && (is_plt16_reloc<size>(r_type)\n+  if (use_plt_offset && (is_plt16_reloc<size>(r_type)\n \t\t\t || r_type == elfcpp::R_PPC64_PLT_PCREL34\n \t\t\t || r_type == elfcpp::R_PPC64_PLT_PCREL34_NOTOC))\n     {\n@@ -10597,7 +10695,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t    value -= target->toc_pointer();\n \t}\n     }\n-  else if (!has_plt_offset\n+  else if (!use_plt_offset\n \t   && (is_plt16_reloc<size>(r_type)\n \t       || r_type == elfcpp::R_POWERPC_PLTSEQ\n \t       || r_type == elfcpp::R_PPC64_PLTSEQ_NOTOC))\n@@ -10606,7 +10704,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       elfcpp::Swap<32, big_endian>::writeval(iview, nop);\n       r_type = elfcpp::R_POWERPC_NONE;\n     }\n-  else if (!has_plt_offset\n+  else if (!use_plt_offset\n \t   && (r_type == elfcpp::R_PPC64_PLT_PCREL34\n \t       || r_type == elfcpp::R_PPC64_PLT_PCREL34_NOTOC))\n     {\n@@ -11085,7 +11183,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n     }\n   else if (!has_stub_value)\n     {\n-      if (!has_plt_offset && (r_type == elfcpp::R_POWERPC_PLTCALL\n+      if (!use_plt_offset && (r_type == elfcpp::R_POWERPC_PLTCALL\n \t\t\t      || r_type == elfcpp::R_PPC64_PLTCALL_NOTOC))\n \t{\n \t  // PLTCALL without plt entry => convert to direct call"
    }
  ]
}