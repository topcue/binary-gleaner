{
  "sha": "9ecab40c77fd414fe408967d0f92f00494aa11b9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OWVjYWI0MGM3N2ZkNDE0ZmU0MDg5NjdkMGY5MmYwMDQ5NGFhMTFiOQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-11-13T16:58:37Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-11-13T16:58:37Z"
    },
    "message": "gdb/arm: avoid undefined behavior shift when decoding immediate value\n\nWhen loading the code file provided in PR 26828 and GDB is build with\nUBSan, we get:\n\n    Core was generated by `./Foo'.\n    Program terminated with signal SIGABRT, Aborted.\n    #0  0xb6c3809c in pthread_cond_wait () from /home/simark/build/binutils-gdb/gdb/repo/lib/libpthread.so.0\n    [Current thread is 1 (LWP 29367)]\n    (gdb) bt\n    /home/simark/src/binutils-gdb/gdb/arm-tdep.c:1551:30: runtime error: shift exponent 32 is too large for 32-bit type 'unsigned int'\n\nThe sequence of instructions at pthread_cond_wait, in the\nlibpthread.so.0 library, contains this instruction with an immediate\nconstant with a \"rotate amount\" of 0:\n\n    e24dd044        sub     sp, sp, #68     ; 0x44\n\nSince arm_analyze_prologue shifts by \"32 - rotate amount\", it does a 32\nbit shift of a 32 bit type, which is caught by UBSan.\n\nFix it by factoring out the decoding of immediates in a new function,\narm_expand_immediate.\n\nI added a selftest for arm_analyze_prologue that replicates the\ninstruction sequence.  Without the fix, it crashes GDB if it is build\nwith --enable-ubsan.\n\nI initially wanted to re-use the abstract_memory_reader class already in\narm-tdep.c, used to make arm_process_record testable.  However,\narm_process_record and arm_analyze_prologue don't use the same kind of\nmemory reading functions.  arm_process_record uses a function that\nreturns an error status on failure while arm_analyze_prologue uses one\nthat throws an exception.  Since i didn't want to introduce any other\nbehavior change, I decided to just introduce a separate interface\n(arm_instruction_reader).  It is derived from\nabstract_instruction_reader in aarch64-tdep.c.\n\ngdb/ChangeLog:\n\n\tPR gdb/26835\n\t* arm-tdep.c (class arm_instruction_reader): New.\n\t(target_arm_instruction_reader): New.\n\t(arm_analyze_prologue): Add instruction reader parameter and use\n\tit.  Use arm_expand_immediate.\n\t(class target_arm_instruction_reader): Adjust.\n\t(arm_skip_prologue): Adjust.\n\t(arm_expand_immediate): New.\n\t(arm_scan_prologue): Adjust.\n\t(arm_analyze_prologue_test): New.\n\t(class test_arm_instruction_reader): New.\n\nChange-Id: Ieb1c1799bd66f8c7421384f44f5c2777b578ff8d",
    "tree": {
      "sha": "4ae41d9712eb61de51c4c815a3859f56de54b4cf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4ae41d9712eb61de51c4c815a3859f56de54b4cf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9ecab40c77fd414fe408967d0f92f00494aa11b9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9ecab40c77fd414fe408967d0f92f00494aa11b9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9ecab40c77fd414fe408967d0f92f00494aa11b9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9ecab40c77fd414fe408967d0f92f00494aa11b9/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5643c500fef1ef50449e120deddcb65cf4af4b7b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5643c500fef1ef50449e120deddcb65cf4af4b7b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5643c500fef1ef50449e120deddcb65cf4af4b7b"
    }
  ],
  "stats": {
    "total": 156,
    "additions": 133,
    "deletions": 23
  },
  "files": [
    {
      "sha": "4eb64c139be41d23edf1432b2924685568b7d271",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9ecab40c77fd414fe408967d0f92f00494aa11b9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9ecab40c77fd414fe408967d0f92f00494aa11b9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9ecab40c77fd414fe408967d0f92f00494aa11b9",
      "patch": "@@ -1,3 +1,17 @@\n+2020-11-13  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\tPR gdb/26835\n+\t* arm-tdep.c (class arm_instruction_reader): New.\n+\t(target_arm_instruction_reader): New.\n+\t(arm_analyze_prologue): Add instruction reader parameter and use\n+\tit.  Use arm_expand_immediate.\n+\t(class target_arm_instruction_reader): Adjust.\n+\t(arm_skip_prologue): Adjust.\n+\t(arm_expand_immediate): New.\n+\t(arm_scan_prologue): Adjust.\n+\t(arm_analyze_prologue_test): New.\n+\t(class test_arm_instruction_reader): New.\n+\n 2020-11-13  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* f-lang.c (fortran_argument_convert): Add declaration.  Add"
    },
    {
      "sha": "3f584b94a6b0827b176e432b16d57f240ae2ce12",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 119,
      "deletions": 23,
      "changes": 142,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9ecab40c77fd414fe408967d0f92f00494aa11b9/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9ecab40c77fd414fe408967d0f92f00494aa11b9/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=9ecab40c77fd414fe408967d0f92f00494aa11b9",
      "patch": "@@ -285,10 +285,34 @@ struct arm_prologue_cache\n   struct trad_frame_saved_reg *saved_regs;\n };\n \n-static CORE_ADDR arm_analyze_prologue (struct gdbarch *gdbarch,\n-\t\t\t\t       CORE_ADDR prologue_start,\n-\t\t\t\t       CORE_ADDR prologue_end,\n-\t\t\t\t       struct arm_prologue_cache *cache);\n+namespace {\n+\n+/* Abstract class to read ARM instructions from memory.  */\n+\n+class arm_instruction_reader\n+{\n+public:\n+  /* Read a 4 bytes instruction bytes from memory using the BYTE_ORDER\n+     endianness.  */\n+  virtual uint32_t read (CORE_ADDR memaddr, bfd_endian byte_order) const = 0;\n+};\n+\n+/* Read instructions from target memory.  */\n+\n+class target_arm_instruction_reader : public arm_instruction_reader\n+{\n+public:\n+  uint32_t read (CORE_ADDR memaddr, bfd_endian byte_order) const override\n+  {\n+    return read_code_unsigned_integer (memaddr, 4, byte_order);\n+  }\n+};\n+\n+} /* namespace */\n+\n+static CORE_ADDR arm_analyze_prologue\n+  (struct gdbarch *gdbarch, CORE_ADDR prologue_start, CORE_ADDR prologue_end,\n+   struct arm_prologue_cache *cache, const arm_instruction_reader &insn_reader);\n \n /* Architecture version for displaced stepping.  This effects the behaviour of\n    certain instructions, and really should not be hard-wired.  */\n@@ -1383,8 +1407,9 @@ arm_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n \t    analyzed_limit = thumb_analyze_prologue (gdbarch, func_addr,\n \t\t\t\t\t\t     post_prologue_pc, NULL);\n \t  else\n-\t    analyzed_limit = arm_analyze_prologue (gdbarch, func_addr,\n-\t\t\t\t\t\t   post_prologue_pc, NULL);\n+\t    analyzed_limit\n+\t      = arm_analyze_prologue (gdbarch, func_addr, post_prologue_pc,\n+\t\t\t\t      NULL, target_arm_instruction_reader ());\n \n \t  if (analyzed_limit != post_prologue_pc)\n \t    return func_addr;\n@@ -1409,7 +1434,8 @@ arm_skip_prologue (struct gdbarch *gdbarch, CORE_ADDR pc)\n   if (arm_pc_is_thumb (gdbarch, pc))\n     return thumb_analyze_prologue (gdbarch, pc, limit_pc, NULL);\n   else\n-    return arm_analyze_prologue (gdbarch, pc, limit_pc, NULL);\n+    return arm_analyze_prologue (gdbarch, pc, limit_pc, NULL,\n+\t\t\t\t target_arm_instruction_reader ());\n }\n \n /* *INDENT-OFF* */\n@@ -1485,6 +1511,26 @@ arm_instruction_restores_sp (unsigned int insn)\n   return 0;\n }\n \n+/* Implement immediate value decoding, as described in section A5.2.4\n+   (Modified immediate constants in ARM instructions) of the ARM Architecture\n+   Reference Manual (ARMv7-A and ARMv7-R edition).  */\n+\n+static uint32_t\n+arm_expand_immediate (uint32_t imm)\n+{\n+  /* Immediate values are 12 bits long.  */\n+  gdb_assert ((imm & 0xfffff000) == 0);\n+\n+  uint32_t unrotated_value = imm & 0xff;\n+  uint32_t rotate_amount = (imm & 0xf00) >> 7;\n+\n+  if (rotate_amount == 0)\n+    return unrotated_value;\n+\n+  return ((unrotated_value >> rotate_amount)\n+\t  | (unrotated_value << (32 - rotate_amount)));\n+}\n+\n /* Analyze an ARM mode prologue starting at PROLOGUE_START and\n    continuing no further than PROLOGUE_END.  If CACHE is non-NULL,\n    fill it in.  Return the first address not recognized as a prologue\n@@ -1498,7 +1544,8 @@ arm_instruction_restores_sp (unsigned int insn)\n static CORE_ADDR\n arm_analyze_prologue (struct gdbarch *gdbarch,\n \t\t      CORE_ADDR prologue_start, CORE_ADDR prologue_end,\n-\t\t      struct arm_prologue_cache *cache)\n+\t\t      struct arm_prologue_cache *cache,\n+\t\t      const arm_instruction_reader &insn_reader)\n {\n   enum bfd_endian byte_order_for_code = gdbarch_byte_order_for_code (gdbarch);\n   int regno;\n@@ -1524,8 +1571,7 @@ arm_analyze_prologue (struct gdbarch *gdbarch,\n        current_pc < prologue_end;\n        current_pc += 4)\n     {\n-      unsigned int insn\n-\t= read_code_unsigned_integer (current_pc, 4, byte_order_for_code);\n+      uint32_t insn = insn_reader.read (current_pc, byte_order_for_code);\n \n       if (insn == 0xe1a0c00d)\t\t/* mov ip, sp */\n \t{\n@@ -1535,20 +1581,16 @@ arm_analyze_prologue (struct gdbarch *gdbarch,\n       else if ((insn & 0xfff00000) == 0xe2800000\t/* add Rd, Rn, #n */\n \t       && pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))\n \t{\n-\t  unsigned imm = insn & 0xff;                   /* immediate value */\n-\t  unsigned rot = (insn & 0xf00) >> 7;           /* rotate amount */\n+\t  uint32_t imm = arm_expand_immediate (insn & 0xfff);\n \t  int rd = bits (insn, 12, 15);\n-\t  imm = (imm >> rot) | (imm << (32 - rot));\n \t  regs[rd] = pv_add_constant (regs[bits (insn, 16, 19)], imm);\n \t  continue;\n \t}\n       else if ((insn & 0xfff00000) == 0xe2400000\t/* sub Rd, Rn, #n */\n \t       && pv_is_register (regs[bits (insn, 16, 19)], ARM_SP_REGNUM))\n \t{\n-\t  unsigned imm = insn & 0xff;                   /* immediate value */\n-\t  unsigned rot = (insn & 0xf00) >> 7;           /* rotate amount */\n+\t  uint32_t imm = arm_expand_immediate (insn & 0xfff);\n \t  int rd = bits (insn, 12, 15);\n-\t  imm = (imm >> rot) | (imm << (32 - rot));\n \t  regs[rd] = pv_add_constant (regs[bits (insn, 16, 19)], -imm);\n \t  continue;\n \t}\n@@ -1604,16 +1646,12 @@ arm_analyze_prologue (struct gdbarch *gdbarch,\n \t}\n       else if ((insn & 0xfffff000) == 0xe24cb000)\t/* sub fp, ip #n */\n \t{\n-\t  unsigned imm = insn & 0xff;\t\t\t/* immediate value */\n-\t  unsigned rot = (insn & 0xf00) >> 7;\t\t/* rotate amount */\n-\t  imm = (imm >> rot) | (imm << (32 - rot));\n+\t  uint32_t imm = arm_expand_immediate (insn & 0xfff);\n \t  regs[ARM_FP_REGNUM] = pv_add_constant (regs[ARM_IP_REGNUM], -imm);\n \t}\n       else if ((insn & 0xfffff000) == 0xe24dd000)\t/* sub sp, sp #n */\n \t{\n-\t  unsigned imm = insn & 0xff;\t\t\t/* immediate value */\n-\t  unsigned rot = (insn & 0xf00) >> 7;\t\t/* rotate amount */\n-\t  imm = (imm >> rot) | (imm << (32 - rot));\n+\t  uint32_t imm = arm_expand_immediate(insn & 0xfff);\n \t  regs[ARM_SP_REGNUM] = pv_add_constant (regs[ARM_SP_REGNUM], -imm);\n \t}\n       else if ((insn & 0xffff7fff) == 0xed6d0103\t/* stfe f?,\n@@ -1841,7 +1879,8 @@ arm_scan_prologue (struct frame_info *this_frame,\n   if (prev_pc < prologue_end)\n     prologue_end = prev_pc;\n \n-  arm_analyze_prologue (gdbarch, prologue_start, prologue_end, cache);\n+  arm_analyze_prologue (gdbarch, prologue_start, prologue_end, cache,\n+\t\t\ttarget_arm_instruction_reader ());\n }\n \n static struct arm_prologue_cache *\n@@ -9492,6 +9531,7 @@ arm_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n namespace selftests\n {\n static void arm_record_test (void);\n+static void arm_analyze_prologue_test ();\n }\n #endif\n \n@@ -9618,6 +9658,7 @@ vfp - VFP co-processor.\"),\n \n #if GDB_SELF_TEST\n   selftests::register_test (\"arm-record\", selftests::arm_record_test);\n+  selftests::register_test (\"arm_analyze_prologue\", selftests::arm_analyze_prologue_test);\n #endif\n \n }\n@@ -13254,6 +13295,61 @@ arm_record_test (void)\n     SELF_CHECK (arm_record.arm_regs[0] == 7);\n   }\n }\n+\n+/* Instruction reader from manually cooked instruction sequences.  */\n+\n+class test_arm_instruction_reader : public arm_instruction_reader\n+{\n+public:\n+  explicit test_arm_instruction_reader (gdb::array_view<const uint32_t> insns)\n+    : m_insns (insns)\n+  {}\n+\n+  uint32_t read (CORE_ADDR memaddr, enum bfd_endian byte_order) const override\n+  {\n+    SELF_CHECK (memaddr % 4 == 0);\n+    SELF_CHECK (memaddr / 4 < m_insns.size ());\n+\n+    return m_insns[memaddr / 4];\n+  }\n+\n+private:\n+  const gdb::array_view<const uint32_t> m_insns;\n+};\n+\n+static void\n+arm_analyze_prologue_test ()\n+{\n+  for (bfd_endian endianness : {BFD_ENDIAN_LITTLE, BFD_ENDIAN_BIG})\n+    {\n+      struct gdbarch_info info;\n+      gdbarch_info_init (&info);\n+      info.byte_order = endianness;\n+      info.byte_order_for_code = endianness;\n+      info.bfd_arch_info = bfd_scan_arch (\"arm\");\n+\n+      struct gdbarch *gdbarch = gdbarch_find_by_info (info);\n+\n+      SELF_CHECK (gdbarch != NULL);\n+\n+      /* The \"sub\" instruction contains an immediate value rotate count of 0,\n+\t which resulted in a 32-bit shift of a 32-bit value, caught by\n+\t UBSan.  */\n+      const uint32_t insns[] = {\n+\t  0xe92d4ff0, /* push    {r4, r5, r6, r7, r8, r9, sl, fp, lr} */\n+\t  0xe1a05000, /* mov     r5, r0 */\n+\t  0xe5903020, /* ldr     r3, [r0, #32] */\n+\t  0xe24dd044, /* sub     sp, sp, #68     ; 0x44 */\n+      };\n+\n+      test_arm_instruction_reader mem_reader (insns);\n+      arm_prologue_cache cache;\n+      cache.saved_regs = trad_frame_alloc_saved_regs (gdbarch);\n+\n+      arm_analyze_prologue (gdbarch, 0, sizeof (insns) - 1, &cache, mem_reader);\n+    }\n+}\n+\n } // namespace selftests\n #endif /* GDB_SELF_TEST */\n "
    }
  ]
}