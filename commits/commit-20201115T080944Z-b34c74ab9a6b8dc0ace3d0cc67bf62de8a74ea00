{
  "sha": "b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjM0Yzc0YWI5YTZiOGRjMGFjZTNkMGNjNjdiZjYyZGU4YTc0ZWEwMA==",
  "commit": {
    "author": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2020-11-15T08:09:44Z"
    },
    "committer": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2020-11-15T08:09:44Z"
    },
    "message": "gmp-utils: New API to simply use of GMP's integer/rational/float objects\n\nThis API was motivated by a number of reasons:\n  - GMP's API does not handle \"long long\" and \"unsigned long long\",\n    so using LONGEST and ULONGEST is not straightforward;\n  - Automate the need to initialize GMP objects before use, and\n    clear them when no longer used.\n\nHowever, this API grew also to help with similar matter such\nas formatting to a string, and also reading/writing fixed-point\nvalues from byte buffers.\n\nDedicated unit testing is also added.\n\ngdb/ChangeLog:\n\n        * gmp-utils.h,  gmp-utils.h: New file.\n        * unittests/gmp-utils-selftests.c: New file.\n        * Makefile.in (SUBDIR_UNITTESTS_SRCS): Add\n        unittests/gmp-utils-selftests.c.\n        (COMMON_SFILES) Add gmp-utils.c.\n        (HFILES_NO_SRCDIR): Add gmp-utils.h.",
    "tree": {
      "sha": "cebf5c4bc8bee8820f497d92258416be8e997564",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cebf5c4bc8bee8820f497d92258416be8e997564"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/comments",
  "author": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1b4ac058f7daeb9bac9ab0e63a7e73535208dfef",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1b4ac058f7daeb9bac9ab0e63a7e73535208dfef",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1b4ac058f7daeb9bac9ab0e63a7e73535208dfef"
    }
  ],
  "stats": {
    "total": 926,
    "additions": 926,
    "deletions": 0
  },
  "files": [
    {
      "sha": "a0291092e29e538bc06c409cd0c259678cba2ae1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
      "patch": "@@ -1,3 +1,12 @@\n+2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n+\n+\t* gmp-utils.h,  gmp-utils.h: New file.\n+\t* unittests/gmp-utils-selftests.c: New file.\n+\t* Makefile.in (SUBDIR_UNITTESTS_SRCS): Add\n+\tunittests/gmp-utils-selftests.c.\n+\t(COMMON_SFILES) Add gmp-utils.c.\n+\t(HFILES_NO_SRCDIR): Add gmp-utils.h.\n+\n 2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n \n \t* configure.ac: Generate an error if a usable GMP library"
    },
    {
      "sha": "9b48f7375306c966e83079bd63485155f532a62d",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
      "patch": "@@ -446,6 +446,7 @@ SELFTESTS_SRCS = \\\n \tunittests/filtered_iterator-selftests.c \\\n \tunittests/format_pieces-selftests.c \\\n \tunittests/function-view-selftests.c \\\n+\tunittests/gmp-utils-selftests.c \\\n \tunittests/lookup_name_info-selftests.c \\\n \tunittests/memory-map-selftests.c \\\n \tunittests/memrange-selftests.c \\\n@@ -1059,6 +1060,7 @@ COMMON_SFILES = \\\n \tgdb_regex.c \\\n \tgdbarch.c \\\n \tgdbtypes.c \\\n+\tgmp-utils.c \\\n \tgnu-v2-abi.c \\\n \tgnu-v3-abi.c \\\n \tgo-lang.c \\\n@@ -1304,6 +1306,7 @@ HFILES_NO_SRCDIR = \\\n \tgdbthread.h \\\n \tgdbtypes.h \\\n \tglibc-tdep.h \\\n+\tgmp-utils.h \\\n \tgnu-nat.h \\\n \tgo-lang.h \\\n \tgregset.h \\"
    },
    {
      "sha": "db92e57316c5b9a958aeb3ddb9c970e0672e810d",
      "filename": "gdb/gmp-utils.c",
      "status": "added",
      "additions": 172,
      "deletions": 0,
      "changes": 172,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/gmp-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/gmp-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gmp-utils.c?ref=b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
      "patch": "@@ -0,0 +1,172 @@\n+/* Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"gmp-utils.h\"\n+\n+/* See gmp-utils.h.  */\n+\n+gdb::unique_xmalloc_ptr<char>\n+gmp_string_asprintf (const char *fmt, ...)\n+{\n+  va_list vp;\n+  char *buf;\n+\n+  va_start (vp, fmt);\n+  gmp_vasprintf (&buf, fmt, vp);\n+  va_end (vp);\n+\n+  return gdb::unique_xmalloc_ptr<char> (buf);\n+}\n+\n+/* See gmp-utils.h.  */\n+\n+void\n+gdb_mpz::read (const gdb_byte *buf, int len, enum bfd_endian byte_order,\n+\t       bool unsigned_p)\n+{\n+  mpz_import (val, 1 /* count */, -1 /* order */, len /* size */,\n+\t      byte_order == BFD_ENDIAN_BIG ? 1 : -1 /* endian */,\n+\t      0 /* nails */, buf /* op */);\n+\n+  if (!unsigned_p)\n+    {\n+      /* The value was imported as if it was a positive value,\n+\t as mpz_import does not handle signs. If the original value\n+\t was in fact negative, we need to adjust VAL accordingly.  */\n+      gdb_mpz max;\n+\n+      mpz_ui_pow_ui (max.val, 2, len * TARGET_CHAR_BIT - 1);\n+      if (mpz_cmp (val, max.val) >= 0)\n+\tmpz_submul_ui (val, max.val, 2);\n+    }\n+}\n+\n+/* See gmp-utils.h.  */\n+\n+void\n+gdb_mpz::write (gdb_byte *buf, int len, enum bfd_endian byte_order,\n+\t\tbool unsigned_p) const\n+{\n+  gdb_mpz exported_val (val);\n+\n+  if (mpz_cmp_ui (val, 0) < 0)\n+    {\n+      /* mpz_export does not handle signed values, so create a positive\n+\t value whose bit representation as an unsigned of the same length\n+\t would be the same as our negative value.  */\n+      gdb_mpz neg_offset;\n+\n+      mpz_ui_pow_ui (neg_offset.val, 2, len * TARGET_CHAR_BIT);\n+      mpz_add (exported_val.val, exported_val.val, neg_offset.val);\n+    }\n+\n+  /* Start by clearing the buffer, as mpz_export only writes as many\n+     bytes as it needs (including none, if the value to export is zero.  */\n+  memset (buf, 0, len);\n+  mpz_export (buf, NULL /* count */, -1 /* order */, len /* size */,\n+\t      byte_order == BFD_ENDIAN_BIG ? 1 : -1 /* endian */,\n+\t      0 /* nails */, exported_val.val);\n+}\n+\n+/* See gmp-utils.h.  */\n+\n+gdb_mpz\n+gdb_mpq::get_rounded () const\n+{\n+  /* Work with a positive number so as to make the \"floor\" rounding\n+     always round towards zero.  */\n+\n+  gdb_mpq abs_val (val);\n+  mpq_abs (abs_val.val, abs_val.val);\n+\n+  /* Convert our rational number into a quotient and remainder,\n+     with \"floor\" rounding, which in our case means rounding\n+     towards zero.  */\n+\n+  gdb_mpz quotient, remainder;\n+  mpz_fdiv_qr (quotient.val, remainder.val,\n+\t       mpq_numref (abs_val.val), mpq_denref (abs_val.val));\n+\n+  /* Multiply the remainder by 2, and see if it is greater or equal\n+     to abs_val's denominator.  If yes, round to the next integer.  */\n+\n+  mpz_mul_ui (remainder.val, remainder.val, 2);\n+  if (mpz_cmp (remainder.val, mpq_denref (abs_val.val)) >= 0)\n+    mpz_add_ui (quotient.val, quotient.val, 1);\n+\n+  /* Re-apply the sign if needed.  */\n+  if (mpq_sgn (val) < 0)\n+    mpz_neg (quotient.val, quotient.val);\n+\n+  return quotient;\n+}\n+\n+/* See gmp-utils.h.  */\n+\n+void\n+gdb_mpq::read_fixed_point (const gdb_byte *buf, int len,\n+\t\t\t   enum bfd_endian byte_order, bool unsigned_p,\n+\t\t\t   const gdb_mpq &scaling_factor)\n+{\n+  gdb_mpz vz;\n+  vz.read (buf, len, byte_order, unsigned_p);\n+\n+  mpq_set_z (val, vz.val);\n+  mpq_mul (val, val, scaling_factor.val);\n+}\n+\n+/* See gmp-utils.h.  */\n+\n+void\n+gdb_mpq::write_fixed_point (gdb_byte *buf, int len,\n+\t\t\t    enum bfd_endian byte_order, bool unsigned_p,\n+\t\t\t    const gdb_mpq &scaling_factor) const\n+{\n+  gdb_mpq unscaled (val);\n+\n+  mpq_div (unscaled.val, unscaled.val, scaling_factor.val);\n+\n+  gdb_mpz unscaled_z = unscaled.get_rounded ();\n+  unscaled_z.write (buf, len, byte_order, unsigned_p);\n+}\n+\n+/* A wrapper around xrealloc that we can then register with GMP\n+   as the \"realloc\" function.  */\n+\n+static void *\n+xrealloc_for_gmp (void *ptr, size_t old_size, size_t new_size)\n+{\n+  return xrealloc (ptr, new_size);\n+}\n+\n+/* A wrapper around xfree that we can then register with GMP\n+   as the \"free\" function.  */\n+\n+static void\n+xfree_for_gmp (void *ptr, size_t size)\n+{\n+  xfree (ptr);\n+}\n+\n+void _initialize_gmp_utils ();\n+\n+void\n+_initialize_gmp_utils ()\n+{\n+  /* Tell GMP to use GDB's memory management routines.  */\n+  mp_set_memory_functions (xmalloc, xrealloc_for_gmp, xfree_for_gmp);\n+}"
    },
    {
      "sha": "1214b645367a1b514dc788257e01374637c5ab4e",
      "filename": "gdb/gmp-utils.h",
      "status": "added",
      "additions": 282,
      "deletions": 0,
      "changes": 282,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/gmp-utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/gmp-utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gmp-utils.h?ref=b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
      "patch": "@@ -0,0 +1,282 @@\n+/* Miscellaneous routines making it easier to use GMP within GDB's framework.\n+\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GMP_UTILS_H\n+#define GMP_UTILS_H\n+\n+#include \"defs.h\"\n+\n+/* Include <stdio.h> and <stdarg.h> ahead of <gmp.h>, so as to get\n+   access to GMP's various formatting functions.  */\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include <gmp.h>\n+#include \"gdbsupport/traits.h\"\n+\n+/* Same as gmp_asprintf, but returning a convenient wrapper type.  */\n+\n+gdb::unique_xmalloc_ptr<char> gmp_string_asprintf (const char *fmt, ...);\n+\n+/* A class to make it easier to use GMP's mpz_t values within GDB.  */\n+\n+struct gdb_mpz\n+{\n+  mpz_t val;\n+\n+  /* Constructors.  */\n+  gdb_mpz () { mpz_init (val); }\n+\n+  explicit gdb_mpz (const mpz_t &from_val)\n+  {\n+    mpz_init (val);\n+    mpz_set (val, from_val);\n+  }\n+\n+  gdb_mpz (const gdb_mpz &from)\n+  {\n+    mpz_init (val);\n+    mpz_set (val, from.val);\n+  }\n+\n+  /* Initialize using the given integral value.\n+\n+     The main advantage of this method is that it handles both signed\n+     and unsigned types, with no size restriction.  */\n+  template<typename T, typename = gdb::Requires<std::is_integral<T>>>\n+  explicit gdb_mpz (T src)\n+  {\n+    mpz_init (val);\n+    set (src);\n+  }\n+\n+  explicit gdb_mpz (gdb_mpz &&from)\n+  {\n+    mpz_init (val);\n+    mpz_swap (val, from.val);\n+  }\n+\n+  \n+  gdb_mpz &operator= (const gdb_mpz &from)\n+  {\n+    mpz_set (val, from.val);\n+    return *this;\n+  }\n+\n+  gdb_mpz &operator= (gdb_mpz &&other)\n+  {\n+    mpz_swap (val, other.val);\n+    return *this;\n+  }\n+\n+  template<typename T, typename = gdb::Requires<std::is_integral<T>>>\n+  gdb_mpz &operator= (T src)\n+  {\n+    set (src);\n+    return *this;\n+  }\n+\n+  /* Convert VAL to an integer of the given type.\n+\n+     The return type can signed or unsigned, with no size restriction.  */\n+  template<typename T> T as_integer () const;\n+\n+  /* Set VAL by importing the number stored in the byte buffer (BUF),\n+     given its size (LEN) and BYTE_ORDER.\n+\n+     UNSIGNED_P indicates whether the number has an unsigned type.  */\n+  void read (const gdb_byte *buf, int len, enum bfd_endian byte_order,\n+\t     bool unsigned_p);\n+\n+  /* Write VAL into BUF as a LEN-bytes number with the given BYTE_ORDER.\n+\n+     UNSIGNED_P indicates whether the number has an unsigned type.  */\n+  void write (gdb_byte *buf, int len, enum bfd_endian byte_order,\n+\t      bool unsigned_p) const;\n+\n+  /* Return a string containing VAL.  */\n+  gdb::unique_xmalloc_ptr<char> str () const\n+  { return gmp_string_asprintf (\"%Zd\", val); }\n+\n+  /* The destructor.  */\n+  ~gdb_mpz () { mpz_clear (val); }\n+\n+private:\n+\n+  /* Helper template for constructor and operator=.  */\n+  template<typename T> void set (T src);\n+};\n+\n+/* A class to make it easier to use GMP's mpq_t values within GDB.  */\n+\n+struct gdb_mpq\n+{\n+  mpq_t val;\n+\n+  /* Constructors.  */\n+  gdb_mpq () { mpq_init (val); }\n+\n+  explicit gdb_mpq (const mpq_t &from_val)\n+  {\n+    mpq_init (val);\n+    mpq_set (val, from_val);\n+  }\n+\n+  gdb_mpq (const gdb_mpq &from)\n+  {\n+    mpq_init (val);\n+    mpq_set (val, from.val);\n+  }\n+\n+  explicit gdb_mpq (gdb_mpq &&from)\n+  {\n+    mpq_init (val);\n+    mpq_swap (val, from.val);\n+  }\n+\n+  /* Copy assignment operator.  */\n+  gdb_mpq &operator= (const gdb_mpq &from)\n+  {\n+    mpq_set (val, from.val);\n+    return *this;\n+  }\n+\n+  gdb_mpq &operator= (gdb_mpq &&from)\n+  {\n+    mpq_swap (val, from.val);\n+    return *this;\n+  }\n+\n+  /* Return a string representing VAL as \"<numerator> / <denominator>\".  */\n+  gdb::unique_xmalloc_ptr<char> str () const\n+  { return gmp_string_asprintf (\"%Qd\", val); }\n+\n+  /* Return VAL rounded to the nearest integer.  */\n+  gdb_mpz get_rounded () const;\n+\n+  /* Set VAL from the contents of the given buffer (BUF), which\n+     contains the unscaled value of a fixed point type object\n+     with the given size (LEN) and byte order (BYTE_ORDER).\n+\n+     UNSIGNED_P indicates whether the number has an unsigned type.\n+     SCALING_FACTOR is the scaling factor to apply after having\n+     read the unscaled value from our buffer.  */\n+  void read_fixed_point (const gdb_byte *buf, int len,\n+\t\t\t enum bfd_endian byte_order, bool unsigned_p,\n+\t\t\t const gdb_mpq &scaling_factor);\n+\n+  /* Write VAL into BUF as a LEN-bytes fixed point value following\n+     the given BYTE_ORDER.\n+\n+     UNSIGNED_P indicates whether the number has an unsigned type.\n+     SCALING_FACTOR is the scaling factor to apply before writing\n+     the unscaled value to our buffer.  */\n+  void write_fixed_point (gdb_byte *buf, int len,\n+\t\t\t  enum bfd_endian byte_order, bool unsigned_p,\n+\t\t\t  const gdb_mpq &scaling_factor) const;\n+\n+  /* The destructor.  */\n+  ~gdb_mpq () { mpq_clear (val); }\n+};\n+\n+/* A class to make it easier to use GMP's mpf_t values within GDB.\n+\n+   Should MPFR become a required dependency, we should probably\n+   drop this class in favor of using MPFR.  */\n+\n+struct gdb_mpf\n+{\n+  mpf_t val;\n+\n+  /* Constructors.  */\n+  gdb_mpf () { mpf_init (val); }\n+\n+  DISABLE_COPY_AND_ASSIGN (gdb_mpf);\n+\n+  /* Set VAL from the contents of the given buffer (BUF), which\n+     contains the unscaled value of a fixed point type object\n+     with the given size (LEN) and byte order (BYTE_ORDER).\n+\n+     UNSIGNED_P indicates whether the number has an unsigned type.\n+     SCALING_FACTOR is the scaling factor to apply after having\n+     read the unscaled value from our buffer.  */\n+  void read_fixed_point (const gdb_byte *buf, int len,\n+\t\t\t enum bfd_endian byte_order, bool unsigned_p,\n+\t\t\t const gdb_mpq &scaling_factor)\n+  {\n+    gdb_mpq tmp_q;\n+\n+    tmp_q.read_fixed_point (buf, len, byte_order, unsigned_p, scaling_factor);\n+    mpf_set_q (val, tmp_q.val);\n+  }\n+\n+  /* The destructor.  */\n+  ~gdb_mpf () { mpf_clear (val); }\n+};\n+\n+/* See declaration above.  */\n+\n+template<typename T>\n+void\n+gdb_mpz::set (T src)\n+{\n+  mpz_import (val, 1 /* count */, -1 /* order */,\n+\t      sizeof (T) /* size */, 0 /* endian (0 = native) */,\n+\t      0 /* nails */, &src /* op */);\n+  if (std::is_signed<T>::value && src < 0)\n+    {\n+      /* mpz_import does not handle the sign, so our value was imported\n+\t as an unsigned. Adjust that imported value so as to make it\n+\t the correct negative value.  */\n+      gdb_mpz neg_offset;\n+\n+      mpz_ui_pow_ui (neg_offset.val, 2, sizeof (T) * HOST_CHAR_BIT);\n+      mpz_sub (val, val, neg_offset.val);\n+    }\n+}\n+\n+/* See declaration above.  */\n+\n+template<typename T>\n+T\n+gdb_mpz::as_integer () const\n+{\n+  /* Initialize RESULT, because mpz_export only write the minimum\n+     number of bytes, including none if our value is zero!  */\n+  T result = 0;\n+\n+  gdb_mpz exported_val (val);\n+  if (std::is_signed<T>::value && mpz_cmp_ui (val, 0) < 0)\n+    {\n+      /* We want to use mpz_export to set the return value, but\n+\t this function does not handle the sign. So give exported_val\n+\t a value which is at the same time positive, and has the same\n+\t bit representation as our negative value.  */\n+      gdb_mpz neg_offset;\n+\n+      mpz_ui_pow_ui (neg_offset.val, 2, sizeof (T) * HOST_CHAR_BIT);\n+      mpz_add (exported_val.val, exported_val.val, neg_offset.val);\n+    }\n+\n+  mpz_export (&result, NULL /* count */, -1 /* order */,\n+\t      sizeof (T) /* size */, 0 /* endian (0 = native) */,\n+\t      0 /* nails */, exported_val.val);\n+  return result;\n+}\n+\n+#endif"
    },
    {
      "sha": "e8c3c5c1cb5f6ee397322c56f27562fbc7ad7b64",
      "filename": "gdb/unittests/gmp-utils-selftests.c",
      "status": "added",
      "additions": 460,
      "deletions": 0,
      "changes": 460,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/unittests/gmp-utils-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00/gdb/unittests/gmp-utils-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/gmp-utils-selftests.c?ref=b34c74ab9a6b8dc0ace3d0cc67bf62de8a74ea00",
      "patch": "@@ -0,0 +1,460 @@\n+/* Self tests of the gmp-utils API.\n+\n+   Copyright (C) 2019-2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"gmp-utils.h\"\n+#include \"gdbsupport/selftest.h\"\n+\n+#include <math.h>\n+\n+namespace selftests {\n+\n+/* Perform a series of general tests of gdb_mpz's as_integer method.\n+\n+   This function tries to be reasonably exhaustive, by testing the edges,\n+   as well as a resonable set of values including negative ones, zero,\n+   and positive values.  */\n+\n+static void\n+gdb_mpz_as_integer ()\n+{\n+  /* Test a range of values, both as LONGEST and ULONGEST.  */\n+  gdb_mpz v;\n+  LONGEST l_expected;\n+  ULONGEST ul_expected;\n+\n+  /* Start with the smallest LONGEST  */\n+  l_expected = (LONGEST) 1 << (sizeof (LONGEST) * 8 - 1);\n+\n+  mpz_ui_pow_ui (v.val, 2, sizeof (LONGEST) * 8 - 1);\n+  mpz_neg (v.val, v.val);\n+\n+  SELF_CHECK (v.as_integer<LONGEST> () == l_expected);\n+\n+  /* Try with a small range of integers including negative, zero,\n+     and positive values.  */\n+  for (int i = -256; i <= 256; i++)\n+    {\n+      l_expected = (LONGEST) i;\n+      mpz_set_si (v.val, i);\n+      SELF_CHECK (v.as_integer<LONGEST> () == l_expected);\n+\n+      if (i >= 0)\n+\t{\n+\t  ul_expected = (ULONGEST) i;\n+\t  mpz_set_ui (v.val, i);\n+\t  SELF_CHECK (v.as_integer<ULONGEST> () == ul_expected);\n+\t}\n+    }\n+\n+  /* Try with LONGEST_MAX.  */\n+  l_expected = LONGEST_MAX;\n+  ul_expected = (ULONGEST) l_expected;\n+\n+  mpz_ui_pow_ui (v.val, 2, sizeof (LONGEST) * 8 - 1);\n+  mpz_sub_ui (v.val, v.val, 1);\n+\n+  SELF_CHECK (v.as_integer<LONGEST> () == l_expected);\n+  SELF_CHECK (v.as_integer<ULONGEST> () == ul_expected);\n+\n+  /* Try with ULONGEST_MAX.  */\n+  ul_expected = ULONGEST_MAX;\n+  mpz_ui_pow_ui (v.val, 2, sizeof (LONGEST) * 8);\n+  mpz_sub_ui (v.val, v.val, 1);\n+\n+  SELF_CHECK (v.as_integer<ULONGEST> () == ul_expected);\n+}\n+\n+/* A helper function to store the given integer value into a buffer,\n+   before reading it back into a gdb_mpz.  Sets ACTUAL to the value\n+   read back, while at the same time setting EXPECTED as the value\n+   we would expect to be read back.\n+\n+   Note that this function does not perform the comparison between\n+   EXPECTED and ACTUAL.  The caller will do it inside a SELF_CHECK\n+   call, allowing the line information shown when the test fails\n+   to provide a bit more information about the kind of values\n+   that were used when the check failed.  This makes the writing\n+   of the tests a little more verbose, but the debugging in case\n+   of problems should hopefuly be easier.  */\n+\n+template<typename T>\n+void\n+store_and_read_back (T val, int buf_len, enum bfd_endian byte_order,\n+\t\t     gdb_mpz &expected, gdb_mpz &actual)\n+{\n+  gdb_byte *buf;\n+\n+  expected = val;\n+\n+  buf = (gdb_byte *) alloca (buf_len);\n+  store_integer (buf, buf_len, byte_order, val);\n+\n+  /* Pre-initialize ACTUAL to something that's not the expected value.  */\n+  mpz_set (actual.val, expected.val);\n+  mpz_sub_ui (actual.val, actual.val, 500);\n+\n+  actual.read (buf, buf_len, byte_order, !std::is_signed<T>::value);\n+}\n+\n+/* Test the gdb_mpz::read method over a reasonable range of values.\n+\n+   The testing is done by picking an arbitrary buffer length, after\n+   which we test every possible value that this buffer allows, both\n+   with signed numbers as well as unsigned ones.  */\n+\n+static void\n+gdb_mpz_read_all_from_small ()\n+{\n+  /* Start with a type whose size is small enough that we can afford\n+     to check the complete range.  */\n+\n+  int buf_len = 1;\n+  LONGEST l_min = -pow (2, buf_len * 8 - 1);\n+  LONGEST l_max = pow (2, buf_len * 8 - 1) - 1;\n+\n+  for (LONGEST l = l_min; l <= l_max; l++)\n+    {\n+      gdb_mpz expected, actual;\n+\n+      store_and_read_back (l, buf_len, BFD_ENDIAN_BIG, expected, actual);\n+      SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+      store_and_read_back (l, buf_len, BFD_ENDIAN_LITTLE, expected, actual);\n+      SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+    }\n+\n+  /* Do the same as above, but with an unsigned type.  */\n+  ULONGEST ul_min = 0;\n+  ULONGEST ul_max = pow (2, buf_len * 8) - 1;\n+\n+  for (ULONGEST ul = ul_min; ul <= ul_max; ul++)\n+    {\n+      gdb_mpz expected, actual;\n+\n+      store_and_read_back (ul, buf_len, BFD_ENDIAN_BIG, expected, actual);\n+      SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+      store_and_read_back (ul, buf_len, BFD_ENDIAN_LITTLE, expected, actual);\n+      SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+    }\n+}\n+\n+/* Test the gdb_mpz::read the extremes of LONGEST and ULONGEST.  */\n+\n+static void\n+gdb_mpz_read_min_max ()\n+{\n+  gdb_mpz expected, actual;\n+\n+  /* Start with the smallest LONGEST.  */\n+\n+  LONGEST l_min = (LONGEST) 1 << (sizeof (LONGEST) * 8 - 1);\n+\n+  store_and_read_back (l_min, sizeof (LONGEST), BFD_ENDIAN_BIG,\n+\t\t       expected, actual);\n+  SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+  store_and_read_back (l_min, sizeof (LONGEST), BFD_ENDIAN_LITTLE,\n+\t\t       expected, actual);\n+  SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+  /* Same with LONGEST_MAX.  */\n+\n+  LONGEST l_max = LONGEST_MAX;\n+\n+  store_and_read_back (l_max, sizeof (LONGEST), BFD_ENDIAN_BIG,\n+\t\t       expected, actual);\n+  SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+  store_and_read_back (l_max, sizeof (LONGEST), BFD_ENDIAN_LITTLE,\n+\t\t       expected, actual);\n+  SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+  /* Same with the smallest ULONGEST.  */\n+\n+  ULONGEST ul_min = 0;\n+\n+  store_and_read_back (ul_min, sizeof (ULONGEST), BFD_ENDIAN_BIG,\n+\t\t       expected, actual);\n+  SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+  store_and_read_back (ul_min, sizeof (ULONGEST), BFD_ENDIAN_LITTLE,\n+\t\t       expected, actual);\n+  SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+  /* Same with ULONGEST_MAX.  */\n+\n+  ULONGEST ul_max = ULONGEST_MAX;\n+\n+  store_and_read_back (ul_max, sizeof (ULONGEST), BFD_ENDIAN_BIG,\n+\t\t       expected, actual);\n+  SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+\n+  store_and_read_back (ul_max, sizeof (ULONGEST), BFD_ENDIAN_LITTLE,\n+\t\t       expected, actual);\n+  SELF_CHECK (mpz_cmp (actual.val, expected.val) == 0);\n+}\n+\n+/* A helper function which creates a gdb_mpz object from the given\n+   integer VAL, and then writes it using its gdb_mpz::write method.\n+\n+   The written value is then extracted from the buffer and returned,\n+   for comparison with the original.\n+\n+   Note that this function does not perform the comparison between\n+   VAL and the returned value.  The caller will do it inside a SELF_CHECK\n+   call, allowing the line information shown when the test fails\n+   to provide a bit more information about the kind of values\n+   that were used when the check failed.  This makes the writing\n+   of the tests a little more verbose, but the debugging in case\n+   of problems should hopefuly be easier.  */\n+\n+template<typename T>\n+T\n+write_and_extract (T val, int buf_len, enum bfd_endian byte_order)\n+{\n+  gdb_mpz v (val);\n+\n+  SELF_CHECK (v.as_integer<T> () == val);\n+\n+  gdb_byte *buf = (gdb_byte *) alloca (buf_len);\n+  v.write (buf, buf_len, byte_order, !std::is_signed<T>::value);\n+\n+  return extract_integer<T> (buf, buf_len, byte_order);\n+}\n+\n+/* Test the gdb_mpz::write method over a reasonable range of values.\n+\n+   The testing is done by picking an arbitrary buffer length, after\n+   which we test every possible value that this buffer allows.  */\n+\n+static void\n+gdb_mpz_write_all_from_small ()\n+{\n+  int buf_len = 1;\n+  LONGEST l_min = -pow (2, buf_len * 8 - 1);\n+  LONGEST l_max = pow (2, buf_len * 8 - 1) - 1;\n+\n+  for (LONGEST l = l_min; l <= l_max; l++)\n+    {\n+      SELF_CHECK (write_and_extract (l, buf_len, BFD_ENDIAN_BIG) == l);\n+      SELF_CHECK (write_and_extract (l, buf_len, BFD_ENDIAN_LITTLE) == l);\n+    }\n+\n+    /* Do the same as above, but with an unsigned type.  */\n+  ULONGEST ul_min = 0;\n+  ULONGEST ul_max = pow (2, buf_len * 8) - 1;\n+\n+  for (ULONGEST ul = ul_min; ul <= ul_max; ul++)\n+    {\n+      SELF_CHECK (write_and_extract (ul, buf_len, BFD_ENDIAN_BIG) == ul);\n+      SELF_CHECK (write_and_extract (ul, buf_len, BFD_ENDIAN_LITTLE) == ul);\n+    }\n+}\n+\n+/* Test the gdb_mpz::write the extremes of LONGEST and ULONGEST.  */\n+\n+static void\n+gdb_mpz_write_min_max ()\n+{\n+  /* Start with the smallest LONGEST.  */\n+\n+  LONGEST l_min = (LONGEST) 1 << (sizeof (LONGEST) * 8 - 1);\n+  SELF_CHECK (write_and_extract (l_min, sizeof (LONGEST), BFD_ENDIAN_BIG)\n+\t      == l_min);\n+  SELF_CHECK (write_and_extract (l_min, sizeof (LONGEST), BFD_ENDIAN_LITTLE)\n+\t      == l_min);\n+\n+  /* Same with LONGEST_MAX.  */\n+\n+  LONGEST l_max = LONGEST_MAX;\n+  SELF_CHECK (write_and_extract (l_max, sizeof (LONGEST), BFD_ENDIAN_BIG)\n+\t      == l_max);\n+  SELF_CHECK (write_and_extract (l_max, sizeof (LONGEST), BFD_ENDIAN_LITTLE)\n+\t      == l_max);\n+\n+  /* Same with the smallest ULONGEST.  */\n+\n+  ULONGEST ul_min = (ULONGEST) 1 << (sizeof (ULONGEST) * 8 - 1);\n+  SELF_CHECK (write_and_extract (ul_min, sizeof (ULONGEST), BFD_ENDIAN_BIG)\n+\t      == ul_min);\n+  SELF_CHECK (write_and_extract (ul_min, sizeof (ULONGEST), BFD_ENDIAN_LITTLE)\n+\t      == ul_min);\n+\n+  /* Same with ULONGEST_MAX.  */\n+\n+  ULONGEST ul_max = ULONGEST_MAX;\n+  SELF_CHECK (write_and_extract (ul_max, sizeof (ULONGEST), BFD_ENDIAN_BIG)\n+\t      == ul_max);\n+  SELF_CHECK (write_and_extract (ul_max, sizeof (ULONGEST), BFD_ENDIAN_LITTLE)\n+\t      == ul_max);\n+}\n+\n+/* A helper function which stores the signed number, the unscaled value\n+   of a fixed point object, into a buffer, and then uses gdb_mpq's\n+   read_fixed_point to read it as a fixed_point value, with\n+   the given parameters.\n+\n+   EXPECTED is set to the value we expected to get after the call\n+   to read_fixed_point.  ACTUAL is the value we actually do get.\n+\n+   Note that this function does not perform the comparison between\n+   EXPECTED and ACTUAL.  The caller will do it inside a SELF_CHECK\n+   call, allowing the line information shown when the test fails\n+   to provide a bit more information about the kind of values\n+   that were used when the check failed.  This makes the writing\n+   of the tests a little more verbose, but the debugging in case\n+   of problems should hopefuly be easier.  */\n+\n+static void\n+read_fp_test (int unscaled, const gdb_mpq &scaling_factor,\n+\t      enum bfd_endian byte_order,\n+\t      gdb_mpq &expected, gdb_mpq &actual)\n+{\n+  /* For this kind of testing, we'll use a buffer the same size as\n+     our unscaled parameter.  */\n+  const int len = sizeof (unscaled);\n+  gdb_byte buf[len];\n+  store_signed_integer (buf, len, byte_order, unscaled);\n+\n+  actual.read_fixed_point (buf, len, byte_order, 0, scaling_factor);\n+\n+  mpq_set_si (expected.val, unscaled, 1);\n+  mpq_mul (expected.val, expected.val, scaling_factor.val);\n+}\n+\n+/* Perform various tests of the gdb_mpq::read_fixed_point method.  */\n+\n+static void\n+gdb_mpq_read_fixed_point ()\n+{\n+  gdb_mpq expected, actual;\n+  gdb_mpq scaling_factor;\n+\n+  /* Pick an arbitrary scaling_factor; this operation is trivial enough\n+     thanks to GMP that the value we use isn't really important.  */\n+  mpq_set_ui (scaling_factor.val, 3, 5);\n+\n+  /* Try a few values, both negative and positive... */\n+\n+  read_fp_test (-256, scaling_factor, BFD_ENDIAN_BIG, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+  read_fp_test (-256, scaling_factor, BFD_ENDIAN_LITTLE, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+\n+  read_fp_test (-1, scaling_factor, BFD_ENDIAN_BIG, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+  read_fp_test (-1, scaling_factor, BFD_ENDIAN_LITTLE, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+\n+  read_fp_test (0, scaling_factor, BFD_ENDIAN_BIG, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+  read_fp_test (0, scaling_factor, BFD_ENDIAN_LITTLE, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+\n+  read_fp_test (1, scaling_factor, BFD_ENDIAN_BIG, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+  read_fp_test (1, scaling_factor, BFD_ENDIAN_LITTLE, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+\n+  read_fp_test (1025, scaling_factor, BFD_ENDIAN_BIG, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+  read_fp_test (1025, scaling_factor, BFD_ENDIAN_LITTLE, expected, actual);\n+  SELF_CHECK (mpq_cmp (actual.val, expected.val) == 0);\n+}\n+\n+/* A helper function which builds a gdb_mpq object from the given\n+   NUMERATOR and DENOMINATOR, and then calls gdb_mpq's write_fixed_point\n+   method to write it to a buffer.\n+\n+   The value written into the buffer is then read back as is,\n+   and returned.  */\n+\n+static LONGEST\n+write_fp_test (int numerator, unsigned int denominator,\n+\t       const gdb_mpq &scaling_factor,\n+\t       enum bfd_endian byte_order)\n+{\n+  /* For this testing, we'll use a buffer the size of LONGEST.\n+     This is really an arbitrary decision, as long as the buffer\n+     is long enough to hold the unscaled values that we'll be\n+     writing.  */\n+  const int len = sizeof (LONGEST);\n+  gdb_byte buf[len];\n+  memset (buf, 0, len);\n+\n+  gdb_mpq v;\n+  mpq_set_ui (v.val, numerator, denominator);\n+  mpq_canonicalize (v.val);\n+  v.write_fixed_point (buf, len, byte_order, 0, scaling_factor);\n+\n+  return extract_unsigned_integer (buf, len, byte_order);\n+}\n+\n+/* Perform various tests of the gdb_mpq::write_fixed_point method.  */\n+\n+static void\n+gdb_mpq_write_fixed_point ()\n+{\n+  /* Pick an arbitrary factor; this operations is sufficiently trivial\n+     with the use of GMP that the value of this factor is not really\n+     all that important.  */\n+  gdb_mpq scaling_factor;\n+  mpq_set_ui (scaling_factor.val, 1, 3);\n+\n+  gdb_mpq vq;\n+\n+  /* Try a few multiples of the scaling factor, both negative,\n+     and positive... */\n+\n+  SELF_CHECK (write_fp_test (-8, 1, scaling_factor, BFD_ENDIAN_BIG) == -24);\n+  SELF_CHECK (write_fp_test (-8, 1, scaling_factor, BFD_ENDIAN_LITTLE) == -24);\n+\n+  SELF_CHECK (write_fp_test (-2, 3, scaling_factor, BFD_ENDIAN_BIG) == -2);\n+  SELF_CHECK (write_fp_test (-2, 3, scaling_factor, BFD_ENDIAN_LITTLE) == -2);\n+\n+  SELF_CHECK (write_fp_test (0, 3, scaling_factor, BFD_ENDIAN_BIG) == 0);\n+  SELF_CHECK (write_fp_test (0, 3, scaling_factor, BFD_ENDIAN_LITTLE) == 0);\n+\n+  SELF_CHECK (write_fp_test (5, 3, scaling_factor, BFD_ENDIAN_BIG) == 5);\n+  SELF_CHECK (write_fp_test (5, 3, scaling_factor, BFD_ENDIAN_LITTLE) == 5);\n+}\n+\n+}\n+\n+void _initialize_gmp_utils_selftests ();\n+\n+void\n+_initialize_gmp_utils_selftests ()\n+{\n+  selftests::register_test (\"gdb_mpz_as_integer\",\n+\t\t\t    selftests::gdb_mpz_as_integer);\n+  selftests::register_test (\"gdb_mpz_read_all_from_small\",\n+\t\t\t    selftests::gdb_mpz_read_all_from_small);\n+  selftests::register_test (\"gdb_mpz_read_min_max\",\n+\t\t\t    selftests::gdb_mpz_read_min_max);\n+  selftests::register_test (\"gdb_mpz_write_all_from_small\",\n+\t\t\t    selftests::gdb_mpz_write_all_from_small);\n+  selftests::register_test (\"gdb_mpz_write_min_max\",\n+\t\t\t    selftests::gdb_mpz_write_min_max);\n+  selftests::register_test (\"gdb_mpq_read_fixed_point\",\n+\t\t\t    selftests::gdb_mpq_read_fixed_point);\n+  selftests::register_test (\"gdb_mpq_write_fixed_point\",\n+\t\t\t    selftests::gdb_mpq_write_fixed_point);\n+}"
    }
  ]
}