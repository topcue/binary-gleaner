{
  "sha": "b622494ee378fd0a490c934c509364b4c7735273",
  "node_id": "C_kwDOANOeidoAKGI2MjI0OTRlZTM3OGZkMGE0OTBjOTM0YzUwOTM2NGI0Yzc3MzUyNzM",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-10-04T14:48:11Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-23T12:18:54Z"
    },
    "message": "gdb/remote: handle attach when stop packet lacks thread-id\n\nBug PR gdb/28405 reports a regression when using attach with an\nextended-remote target.  In this case the target is not including a\nthread-id in the stop packet it sends back after the attach.\n\nThe regression was introduced with this commit:\n\n  commit 8f66807b98f7634c43149ea62e454ea8f877691d\n  Date:   Wed Jan 13 20:26:58 2021 -0500\n\n      gdb: better handling of 'S' packets\n\nThe problem is that when GDB processes the stop packet, it sees that\nthere is no thread-id and so has to \"guess\" which thread the stop\nshould apply to.\n\nIn this case the target only has one thread, so really, there's no\nguessing needed, but GDB still runs through the same process, this\nshouldn't cause us any problems.\n\nHowever, after the above commit, GDB now expects itself to be more\ninternally consistent, specifically, only a thread that GDB thinks is\nresumed, can be a candidate for having stopped.\n\nIt turns out that, when GDB attaches to a process through an\nextended-remote target, the threads of the process being attached too,\nare not, initially, marked as resumed.\n\nAnd so, when GDB tries to figure out which thread the stop might apply\ntoo, it finds no threads in the processes marked resumed, and so an\nassert triggers.\n\nIn extended_remote_target::attach we create a new thread with a call\nto add_thread_silent, rather than remote_target::remote_add_thread,\nthe reason is that calling the latter will result in a call to\n'add_thread' rather than 'add_thread_silent'.  However,\nremote_target::remote_add_thread includes additional\nactions (i.e. calling remote_thread_info::set_resumed and set_running)\nwhich are missing from extended_remote_target::attach.  These missing\ncalls are what would serve to mark the new thread as resumed.\n\nIn this commit I propose that we add an extra parameter to\nremote_target::remote_add_thread.  This new parameter will force the\nnew thread to be added with a call to add_thread_silent.  We can now\ncall remote_add_thread from the ::attach method, the extra\nactions (listed above) will now be performed, and the thread will be\nleft in the correct state.\n\nAdditionally, in PR gdb/28405, a segfault is reported.  This segfault\ntriggers when 'set debug remote 1' is used before trying to reproduce\nthe original assertion failure.  The cause of this is in\nremote_target::select_thread_for_ambiguous_stop_reply, where we do\nthis:\n\n  remote_debug_printf (\"first resumed thread is %s\",\n\t\t       pid_to_str (first_resumed_thread->ptid).c_str ());\n  remote_debug_printf (\"is this guess ambiguous? = %d\", ambiguous);\n\n  gdb_assert (first_resumed_thread != nullptr);\n\nNotice that when debug printing is on we dereference\nfirst_resumed_thread before we assert that the pointer is not\nnullptr.  This is the cause of the segfault, and is resolved by moving\nthe assert before the debug printing code.\n\nI've extended an existing test, ext-attach.exp, so that the original\ntest is run multiple times; we run in the original mode, as normal,\nbut also, we now run with different packets disabled in gdbserver.  In\nparticular, disabling Tthread would trigger the assertion as it was\nreported in the original bug.  I also run the test in all-stop and\nnon-stop modes now for extra coverage, we also run the tests with\ntarget-async enabled, and disabled.\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=28405",
    "tree": {
      "sha": "db03098df0e571e32865e032db0952f0756a14c1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/db03098df0e571e32865e032db0952f0756a14c1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b622494ee378fd0a490c934c509364b4c7735273",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b622494ee378fd0a490c934c509364b4c7735273",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b622494ee378fd0a490c934c509364b4c7735273",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b622494ee378fd0a490c934c509364b4c7735273/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": null,
  "parents": [
    {
      "sha": "b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b1718fcdd1d2a5c514f8ee504ba07fb3f42b8608"
    }
  ],
  "stats": {
    "total": 129,
    "additions": 77,
    "deletions": 52
  },
  "files": [
    {
      "sha": "46cd352ef90594acff470d4b2f4adbe3b542a623",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 16,
      "deletions": 15,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b622494ee378fd0a490c934c509364b4c7735273/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b622494ee378fd0a490c934c509364b4c7735273/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=b622494ee378fd0a490c934c509364b4c7735273",
      "patch": "@@ -760,7 +760,8 @@ class remote_target : public process_stratum_target\n   void print_one_stopped_thread (thread_info *thread);\n   void process_initial_stop_replies (int from_tty);\n \n-  thread_info *remote_add_thread (ptid_t ptid, bool running, bool executing);\n+  thread_info *remote_add_thread (ptid_t ptid, bool running, bool executing,\n+\t\t\t\t  bool silent_p);\n \n   void btrace_sync_conf (const btrace_config *conf);\n \n@@ -2551,10 +2552,13 @@ static remote_thread_info *get_remote_thread_info (remote_target *target,\n \t\t\t\t\t\t   ptid_t ptid);\n \n /* Add thread PTID to GDB's thread list.  Tag it as executing/running\n-   according to RUNNING.  */\n+   according to EXECUTING and RUNNING respectively.  If SILENT_P (or the\n+   remote_state::starting_up flag) is true then the new thread is added\n+   silently, otherwise the new thread will be announced to the user.  */\n \n thread_info *\n-remote_target::remote_add_thread (ptid_t ptid, bool running, bool executing)\n+remote_target::remote_add_thread (ptid_t ptid, bool running, bool executing,\n+\t\t\t\t  bool silent_p)\n {\n   struct remote_state *rs = get_remote_state ();\n   struct thread_info *thread;\n@@ -2565,7 +2569,7 @@ remote_target::remote_add_thread (ptid_t ptid, bool running, bool executing)\n      consider that a single-threaded target, mentioning a new thread\n      might be confusing to the user.  Be silent then, preserving the\n      age old behavior.  */\n-  if (rs->starting_up)\n+  if (rs->starting_up || silent_p)\n     thread = add_thread_silent (this, ptid);\n   else\n     thread = add_thread (this, ptid);\n@@ -2603,7 +2607,7 @@ remote_target::remote_notice_new_inferior (ptid_t currthread, bool executing)\n     {\n       /* We're seeing an event on a thread id we knew had exited.\n \t This has to be a new thread reusing the old id.  Add it.  */\n-      remote_add_thread (currthread, running, executing);\n+      remote_add_thread (currthread, running, executing, false);\n       return;\n     }\n \n@@ -2625,7 +2629,7 @@ remote_target::remote_notice_new_inferior (ptid_t currthread, bool executing)\n \t  else\n \t    {\n \t      thread_info *thr\n-\t\t= remote_add_thread (currthread, running, executing);\n+\t\t= remote_add_thread (currthread, running, executing, false);\n \t      switch_to_thread (thr);\n \t    }\n \t  return;\n@@ -2657,7 +2661,7 @@ remote_target::remote_notice_new_inferior (ptid_t currthread, bool executing)\n \n       /* This is really a new thread.  Add it.  */\n       thread_info *new_thr\n-\t= remote_add_thread (currthread, running, executing);\n+\t= remote_add_thread (currthread, running, executing, false);\n \n       /* If we found a new inferior, let the common code do whatever\n \t it needs to with it (e.g., read shared libraries, insert\n@@ -6171,14 +6175,11 @@ extended_remote_target::attach (const char *args, int from_tty)\n \t ptid.  */\n       ptid_t curr_ptid = remote_current_thread (ptid_t (pid));\n \n-      /* Add the main thread to the thread list.  */\n-      thread_info *thr = add_thread_silent (this, curr_ptid);\n+      /* Add the main thread to the thread list.  We add the thread\n+\t silently in this case (the final true parameter).  */\n+      thread_info *thr = remote_add_thread (curr_ptid, true, true, true);\n \n       switch_to_thread (thr);\n-\n-      /* Don't consider the thread stopped until we've processed the\n-\t saved stop reply.  */\n-      set_executing (this, thr->ptid, true);\n     }\n \n   /* Next, if the target can specify a description, read it.  We do\n@@ -8010,12 +8011,12 @@ remote_target::select_thread_for_ambiguous_stop_reply\n \tambiguous = true;\n     }\n \n+  gdb_assert (first_resumed_thread != nullptr);\n+\n   remote_debug_printf (\"first resumed thread is %s\",\n \t\t       pid_to_str (first_resumed_thread->ptid).c_str ());\n   remote_debug_printf (\"is this guess ambiguous? = %d\", ambiguous);\n \n-  gdb_assert (first_resumed_thread != nullptr);\n-\n   /* Warn if the remote target is sending ambiguous stop replies.  */\n   if (ambiguous)\n     {"
    },
    {
      "sha": "0babae2ebd09868d6d809e5cd54764e8d1107d13",
      "filename": "gdb/testsuite/gdb.server/ext-attach.exp",
      "status": "modified",
      "additions": 61,
      "deletions": 37,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b622494ee378fd0a490c934c509364b4c7735273/gdb/testsuite/gdb.server/ext-attach.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b622494ee378fd0a490c934c509364b4c7735273/gdb/testsuite/gdb.server/ext-attach.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.server/ext-attach.exp?ref=b622494ee378fd0a490c934c509364b4c7735273",
      "patch": "@@ -30,53 +30,77 @@ if {![can_spawn_for_attach]} {\n     return 0\n }\n \n-save_vars { GDBFLAGS } {\n-    # If GDB and GDBserver are both running locally, set the sysroot to avoid\n-    # reading files via the remote protocol.\n-    if { ![is_remote host] && ![is_remote target] } {\n-\tset GDBFLAGS \"$GDBFLAGS -ex \\\"set sysroot\\\"\"\n-    }\n+if {[build_executable \"failed to prepare\" $testfile $srcfile debug]} {\n+    return -1\n+}\n \n-    if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile debug]} {\n-\treturn -1\n+# Run the test.  TARGET_NON_STOP and TARGET_ASYNC should be 'on'\n+# or 'off'.  TO_DISABLE should be either the empty string, or\n+# something that can be passed to gdbserver's --disable-packet command\n+# line option.\n+proc run_test { target_async target_non_stop to_disable } {\n+    save_vars { ::GDBFLAGS } {\n+\tappend ::GDBFLAGS \" -ex \\\"maint set target-non-stop $target_non_stop\\\"\"\n+\tappend ::GDBFLAGS \" -ex \\\"maintenance set target-async ${target_async}\\\"\"\n+\n+\t# If GDB and GDBserver are both running locally, set the sysroot to avoid\n+\t# reading files via the remote protocol.\n+\tif { ![is_remote host] && ![is_remote target] } {\n+\t    set ::GDBFLAGS \"$::GDBFLAGS -ex \\\"set sysroot\\\"\"\n+\t}\n+\n+\tclean_restart $::binfile\n     }\n-}\n \n-# Make sure we're disconnected, in case we're testing with an\n-# extended-remote board, therefore already connected.\n-gdb_test \"disconnect\" \".*\"\n+    # Make sure we're disconnected, in case we're testing with an\n+    # extended-remote board, therefore already connected.\n+    gdb_test \"disconnect\" \".*\"\n \n-set target_exec [gdbserver_download_current_prog]\n-gdbserver_start_extended\n+    if { [gdb_target_supports_trace] } then {\n+\t# Test predefined TSVs are uploaded.\n+\tgdb_test_sequence \"info tvariables\" \"check uploaded tsv\" {\n+\t    \"\\[\\r\\n\\]+Name\\[\\t \\]+Initial\\[\\t \\]+Current\"\n+\t    \"\\[\\r\\n\\]+\\\\\\$trace_timestamp 0\"\n+\t}\n+    }\n \n-gdb_test_no_output \"set remote exec-file $target_exec\" \"set remote exec-file\"\n+    set target_exec [gdbserver_download_current_prog]\n+    if { $to_disable != \"\" } {\n+\tset gdbserver_opts \"--disable-packet=${to_disable}\"\n+    } else {\n+\tset gdbserver_opts \"\"\n+    }\n+    gdbserver_start_extended $gdbserver_opts\n \n-set test_spawn_id [spawn_wait_for_attach $binfile]\n-set testpid [spawn_id_get_pid $test_spawn_id]\n+    gdb_test_no_output \"set remote exec-file $target_exec\" \"set remote exec-file\"\n \n-gdb_test \"attach $testpid\" \\\n-    \"Attaching to program: .*, process $testpid.*(in|at).*\" \\\n-    \"attach to remote program 1\"\n+    set test_spawn_id [spawn_wait_for_attach $::binfile]\n+    set testpid [spawn_id_get_pid $test_spawn_id]\n \n-if { [gdb_target_supports_trace] } then {\n-    # Test predefined TSVs are uploaded.\n-    gdb_test_sequence \"info tvariables\" \"check uploaded tsv\" {\n-\t\"\\[\\r\\n\\]+Name\\[\\t \\]+Initial\\[\\t \\]+Current\"\n-\t\"\\[\\r\\n\\]+\\\\\\$trace_timestamp 0\"\n-    }\n-}\n+    gdb_test \"attach $testpid\" \\\n+\t\"Attaching to program: .*, process $testpid.*(in|at).*\" \\\n+\t\"attach to remote program 1\"\n+\n+    gdb_test \"backtrace\" \".*main.*\" \"backtrace 1\"\n \n-gdb_test \"backtrace\" \".*main.*\" \"backtrace 1\"\n+    gdb_test \"detach\" \"Detaching from program.*process.*\"\n+    gdb_test \"backtrace\" \"No stack\\\\.\" \"backtrace with no program\"\n \n-gdb_test \"detach\" \"Detaching from program.*process.*\"\n-gdb_test \"backtrace\" \"No stack\\\\.\" \"backtrace with no program\"\n+    gdb_test \"attach $testpid\" \\\n+\t\"Attaching to program: .*, process $testpid.*(in|at).*\" \\\n+\t\"attach to remote program 2\"\n+    gdb_test \"backtrace\" \".*main.*\" \"backtrace 2\"\n \n-gdb_test \"attach $testpid\" \\\n-    \"Attaching to program: .*, process $testpid.*(in|at).*\" \\\n-    \"attach to remote program 2\"\n-gdb_test \"backtrace\" \".*main.*\" \"backtrace 2\"\n+    gdb_test \"kill\" \"\" \"kill\" \"Kill the program being debugged. .y or n. \" \"y\"\n+    gdb_test_no_output \"monitor exit\"\n \n-gdb_test \"kill\" \"\" \"kill\" \"Kill the program being debugged. .y or n. \" \"y\"\n-gdb_test_no_output \"monitor exit\"\n+    kill_wait_spawned_process $test_spawn_id\n+}\n \n-kill_wait_spawned_process $test_spawn_id\n+foreach_with_prefix target_async {\"on\" \"off\" } {\n+    foreach_with_prefix target_non_stop {\"off\" \"on\"} {\n+\tforeach_with_prefix to_disable { \"\" Tthread T } {\n+\t    run_test ${target_async} ${target_non_stop} $to_disable\n+\t}\n+    }\n+}"
    }
  ]
}