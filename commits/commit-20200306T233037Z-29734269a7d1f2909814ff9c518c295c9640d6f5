{
  "sha": "29734269a7d1f2909814ff9c518c295c9640d6f5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Mjk3MzQyNjlhN2QxZjI5MDk4MTRmZjljNTE4YzI5NWM5NjQwZDZmNQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-03-06T23:04:52Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-03-06T23:30:37Z"
    },
    "message": "Pass thread_info pointer to various inferior control functions\n\n[ Migrating this from Gerrit: https://gnutoolchain-gerrit.osci.io/r/c/binutils-gdb/+/321 ]\n\nI noticed that some functions in infcmd and infrun call each other and\nall call inferior_thread, while they could just get the thread_info\npointer from their caller.  That means less calls to inferior_thread, so\nless reliance on global state, since inferior_thread reads\ninferior_ptid.\n\nThe paths I am unsure about are:\n\n  - fetch_inferior_event calls...\n  - step_command_fsm::should_stop calls...\n  - prepare_one_step\n\nand\n\n - process_event_stop_test calls...\n - set_step_info\n\nBefore this patch, prepare_one_step gets the thread pointer using\ninferior_thread.  After this patch, it gets it from the\nexecution_control_state structure in fetch_inferior_event.  Are we sure\nthat the thread from the execution_control_state structure is the same\nas the one inferior_thread would return?  This code path is used when a\nthread completes a step, but the user had specified a step count (e.g.\n\"step 5\") so we decide to do one more step.  It would be strange (and\neven a bug I suppose) if the thread in the ecs structure in\nfetch_inferior_event was not the same thread that is prepared to stepped\nby prepare_one_step.  So I believe passing the ecs thread is fine.\n\nThe same logic applies to process_event_stop_test calling\nset_step_info.\n\ngdb/ChangeLog:\n\n\t* infrun.h: Forward-declare thread_info.\n\t(set_step_info): Add thread_info parameter, add doc.\n\t* infrun.c (set_step_info): Add thread_info parameter, move doc\n\tto header.\n\t* infrun.c (process_event_stop_test): Pass thread to\n\tset_step_info call.\n\t* infcmd.c (set_step_frame): Add thread_info pointer, pass it to\n\tset_step_info.\n\t(prepare_one_step): Add thread_info parameter, pass it to\n\tset_step_frame and prepare_one_step (recursive) call.\n\t(step_1): Pass thread to prepare_one_step call.\n\t(step_command_fsm::should_stop): Pass thread to\n\tprepare_one_step.\n\t(until_next_fsm): Pass thread to set_step_frame call.\n\t(finish_command): Pass thread to set_step_info call.",
    "tree": {
      "sha": "bd97651fa4027721737d72eddff2ae0be8978883",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bd97651fa4027721737d72eddff2ae0be8978883"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/29734269a7d1f2909814ff9c518c295c9640d6f5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/29734269a7d1f2909814ff9c518c295c9640d6f5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/29734269a7d1f2909814ff9c518c295c9640d6f5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/29734269a7d1f2909814ff9c518c295c9640d6f5/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b7d64b29094ef58448c9b41bcde299fad2976237",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b7d64b29094ef58448c9b41bcde299fad2976237",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b7d64b29094ef58448c9b41bcde299fad2976237"
    }
  ],
  "stats": {
    "total": 72,
    "additions": 49,
    "deletions": 23
  },
  "files": [
    {
      "sha": "0de37948a084392fc1df5408a34a823234e3ad06",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/29734269a7d1f2909814ff9c518c295c9640d6f5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/29734269a7d1f2909814ff9c518c295c9640d6f5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=29734269a7d1f2909814ff9c518c295c9640d6f5",
      "patch": "@@ -1,3 +1,21 @@\n+2020-03-06  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* infrun.h: Forward-declare thread_info.\n+\t(set_step_info): Add thread_info parameter, add doc.\n+\t* infrun.c (set_step_info): Add thread_info parameter, move doc\n+\tto header.\n+\t* infrun.c (process_event_stop_test): Pass thread to\n+\tset_step_info call.\n+\t* infcmd.c (set_step_frame): Add thread_info pointer, pass it to\n+\tset_step_info.\n+\t(prepare_one_step): Add thread_info parameter, pass it to\n+\tset_step_frame and prepare_one_step (recursive) call.\n+\t(step_1): Pass thread to prepare_one_step call.\n+\t(step_command_fsm::should_stop): Pass thread to\n+\tprepare_one_step.\n+\t(until_next_fsm): Pass thread to set_step_frame call.\n+\t(finish_command): Pass thread to set_step_info call.\n+\n 2020-03-06  Hannes Domani  <ssbssa@yahoo.de>\n \n \t* windows-tdep.c (windows_solib_create_inferior_hook):"
    },
    {
      "sha": "b4b128b287353e074ccb599a2be1f18d34c988a2",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 19,
      "deletions": 18,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/29734269a7d1f2909814ff9c518c295c9640d6f5/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/29734269a7d1f2909814ff9c518c295c9640d6f5/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=29734269a7d1f2909814ff9c518c295c9640d6f5",
      "patch": "@@ -914,18 +914,21 @@ continue_command (const char *args, int from_tty)\n   continue_1 (all_threads_p);\n }\n \f\n-/* Record the starting point of a \"step\" or \"next\" command.  */\n+/* Record in TP the starting point of a \"step\" or \"next\" command.  */\n \n static void\n-set_step_frame (void)\n+set_step_frame (thread_info *tp)\n {\n+  /* This can be removed once this function no longer implicitly relies on the\n+     inferior_ptid value.  */\n+  gdb_assert (inferior_ptid == tp->ptid);\n+\n   frame_info *frame = get_current_frame ();\n \n   symtab_and_line sal = find_frame_sal (frame);\n-  set_step_info (frame, sal);\n+  set_step_info (tp, frame, sal);\n \n   CORE_ADDR pc = get_frame_pc (frame);\n-  thread_info *tp = inferior_thread ();\n   tp->control.step_start_function = find_pc_function (pc);\n }\n \n@@ -1002,7 +1005,7 @@ step_command_fsm_prepare (struct step_command_fsm *sm,\n   thread->control.stepping_command = 1;\n }\n \n-static int prepare_one_step (struct step_command_fsm *sm);\n+static int prepare_one_step (thread_info *, struct step_command_fsm *sm);\n \n static void\n step_1 (int skip_subroutines, int single_inst, const char *count_string)\n@@ -1040,7 +1043,7 @@ step_1 (int skip_subroutines, int single_inst, const char *count_string)\n      loop.  Let the continuation figure out how many other steps we\n      need to do, and handle them one at the time, through\n      step_once.  */\n-  if (!prepare_one_step (step_sm))\n+  if (!prepare_one_step (thr, step_sm))\n     proceed ((CORE_ADDR) -1, GDB_SIGNAL_DEFAULT);\n   else\n     {\n@@ -1070,7 +1073,7 @@ step_command_fsm::should_stop (struct thread_info *tp)\n       /* There are more steps to make, and we did stop due to\n \t ending a stepping range.  Do another step.  */\n       if (--count > 0)\n-\treturn prepare_one_step (this);\n+\treturn prepare_one_step (tp, this);\n \n       set_finished ();\n     }\n@@ -1102,19 +1105,17 @@ step_command_fsm::do_async_reply_reason ()\n    resumed.  */\n \n static int\n-prepare_one_step (struct step_command_fsm *sm)\n+prepare_one_step (thread_info *tp, struct step_command_fsm *sm)\n {\n+  /* This can be removed once this function no longer implicitly relies on the\n+     inferior_ptid value.  */\n+  gdb_assert (inferior_ptid == tp->ptid);\n+\n   if (sm->count > 0)\n     {\n       struct frame_info *frame = get_current_frame ();\n \n-      /* Don't assume THREAD is a valid thread id.  It is set to -1 if\n-\t the longjmp breakpoint was not required.  Use the\n-\t INFERIOR_PTID thread instead, which is the same thread when\n-\t THREAD is set.  */\n-      struct thread_info *tp = inferior_thread ();\n-\n-      set_step_frame ();\n+      set_step_frame (tp);\n \n       if (!sm->single_inst)\n \t{\n@@ -1146,7 +1147,7 @@ prepare_one_step (struct step_command_fsm *sm)\n \t\t  || !function_name_is_marked_for_skip (fn, sal))\n \t\t{\n \t\t  sm->count--;\n-\t\t  return prepare_one_step (sm);\n+\t\t  return prepare_one_step (tp, sm);\n \t\t}\n \t    }\n \n@@ -1488,7 +1489,7 @@ until_next_command (int from_tty)\n   struct until_next_fsm *sm;\n \n   clear_proceed_status (0);\n-  set_step_frame ();\n+  set_step_frame (tp);\n \n   frame = get_current_frame ();\n \n@@ -1945,7 +1946,7 @@ finish_command (const char *arg, int from_tty)\n \t called by that frame.  We don't use the magic \"1\" value for\n \t step_range_end, because then infrun will think this is nexti,\n \t and not step over the rest of this inlined function call.  */\n-      set_step_info (frame, {});\n+      set_step_info (tp, frame, {});\n       tp->control.step_range_start = get_frame_pc (frame);\n       tp->control.step_range_end = tp->control.step_range_start;\n       tp->control.step_over_calls = STEP_OVER_ALL;"
    },
    {
      "sha": "2a319295d361eef94b42014a6fc9e6e0f9e7a284",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/29734269a7d1f2909814ff9c518c295c9640d6f5/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/29734269a7d1f2909814ff9c518c295c9640d6f5/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=29734269a7d1f2909814ff9c518c295c9640d6f5",
      "patch": "@@ -4102,11 +4102,15 @@ fetch_inferior_event (void *client_data)\n     printf_unfiltered (_(\"completed.\\n\"));\n }\n \n-/* Record the frame and location we're currently stepping through.  */\n+/* See infrun.h.  */\n+\n void\n-set_step_info (struct frame_info *frame, struct symtab_and_line sal)\n+set_step_info (thread_info *tp, struct frame_info *frame,\n+\t       struct symtab_and_line sal)\n {\n-  struct thread_info *tp = inferior_thread ();\n+  /* This can be removed once this function no longer implicitly relies on the\n+     inferior_ptid value.  */\n+  gdb_assert (inferior_ptid == tp->ptid);\n \n   tp->control.step_frame_id = get_frame_id (frame);\n   tp->control.step_stack_frame_id = get_stack_frame_id (frame);\n@@ -7200,7 +7204,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n   ecs->event_thread->control.step_range_start = stop_pc_sal.pc;\n   ecs->event_thread->control.step_range_end = stop_pc_sal.end;\n   ecs->event_thread->control.may_range_step = 1;\n-  set_step_info (frame, stop_pc_sal);\n+  set_step_info (ecs->event_thread, frame, stop_pc_sal);\n \n   if (debug_infrun)\n      fprintf_unfiltered (gdb_stdlog, \"infrun: keep going\\n\");"
    },
    {
      "sha": "980854135197c7fd2c66a0c8b40e5746ec10aa2d",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/29734269a7d1f2909814ff9c518c295c9640d6f5/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/29734269a7d1f2909814ff9c518c295c9640d6f5/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=29734269a7d1f2909814ff9c518c295c9640d6f5",
      "patch": "@@ -26,6 +26,7 @@ struct frame_info;\n struct address_space;\n struct return_value_info;\n struct process_stratum_target;\n+struct thread_info;\n \n /* True if we are debugging run control.  */\n extern unsigned int debug_infrun;\n@@ -150,7 +151,9 @@ extern int thread_is_stepping_over_breakpoint (int thread);\n    triggers a non-steppable watchpoint.  */\n extern int stepping_past_nonsteppable_watchpoint (void);\n \n-extern void set_step_info (struct frame_info *frame,\n+/* Record in TP the frame and location we're currently stepping through.  */\n+extern void set_step_info (thread_info *tp,\n+\t\t\t   struct frame_info *frame,\n \t\t\t   struct symtab_and_line sal);\n \n /* Several print_*_reason helper functions to print why the inferior"
    }
  ]
}