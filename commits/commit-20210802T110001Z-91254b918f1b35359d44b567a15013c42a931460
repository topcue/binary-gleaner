{
  "sha": "91254b918f1b35359d44b567a15013c42a931460",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTEyNTRiOTE4ZjFiMzUzNTlkNDRiNTY3YTE1MDEzYzQyYTkzMTQ2MA==",
  "commit": {
    "author": {
      "name": "Shahab Vahedi",
      "email": "shahab@synopsys.com",
      "date": "2021-07-19T14:13:47Z"
    },
    "committer": {
      "name": "Shahab Vahedi",
      "email": "shahab@synopsys.com",
      "date": "2021-08-02T11:00:01Z"
    },
    "message": "gdb: Make the builtin \"boolean\" type an unsigned type\n\nWhen printing the fields of a register that is of a custom struct type,\nthe \"unpack_bits_as_long ()\" function is used:\n\n    do_val_print (...)\n      cp_print_value_fields (...)\n        value_field_bitfield (...)\n          unpack_value_bitfield (...)\n            unpack_bits_as_long (...)\n\nThis function may sign-extend the extracted field while returning it:\n\n    val >>= lsbcount;\n\n    if (...)\n      {\n        valmask = (((ULONGEST) 1) << bitsize) - 1;\n        val &= valmask;\n        if (!field_type->is_unsigned ())\n  \t  if (val & (valmask ^ (valmask >> 1)))\n  \t      val |= ~valmask;\n      }\n\n    return val;\n\nlsbcount:   Number of lower bits to get rid of.\nbitsize:    The bit length of the field to be extracted.\nval:        The register value.\nfield_type: The type of field that is being handled.\n\nWhile the logic here is correct, there is a problem when it is\nhandling \"field_type\"s of \"boolean\".  Those types are NOT marked\nas \"unsigned\" and therefore they end up being sign extended.\nAlthough this is not a problem for \"false\" (0), it definitely\ncauses trouble for \"true\".\n\nThis patch constructs the builtin boolean type as such that it is\nmarked as an \"unsigned\" entity.\n\nThe issue tackled here was first encountered for arc-elf32 target\nrunning on an x86_64 machine.  The unit-test introduced in this change\nhas passed for all the targets (--enable-targets=all) running on the\nsame x86_64 host.\n\nFixes: https://sourceware.org/PR28104",
    "tree": {
      "sha": "87f915fff7d9fbdbe26e6f7014195b3c4bf36b28",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/87f915fff7d9fbdbe26e6f7014195b3c4bf36b28"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/91254b918f1b35359d44b567a15013c42a931460",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/91254b918f1b35359d44b567a15013c42a931460",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/91254b918f1b35359d44b567a15013c42a931460",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/91254b918f1b35359d44b567a15013c42a931460/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "7d315ef225c1553d30180fd5690c688c09151c52",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d315ef225c1553d30180fd5690c688c09151c52",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7d315ef225c1553d30180fd5690c688c09151c52"
    }
  ],
  "stats": {
    "total": 70,
    "additions": 69,
    "deletions": 1
  },
  "files": [
    {
      "sha": "7442ec0743e1bafcb41eba747b2ee8562ed8cd73",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 68,
      "deletions": 0,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/91254b918f1b35359d44b567a15013c42a931460/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/91254b918f1b35359d44b567a15013c42a931460/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=91254b918f1b35359d44b567a15013c42a931460",
      "patch": "@@ -38,6 +38,8 @@\n #include \"gdbsupport/byte-vector.h\"\n #include \"gdbarch.h\"\n #include \"cli/cli-style.h\"\n+#include \"gdbsupport/selftest.h\"\n+#include \"selftest-arch.h\"\n \n static struct obstack dont_print_vb_obstack;\n static struct obstack dont_print_statmem_obstack;\n@@ -715,11 +717,77 @@ cp_print_class_member (const gdb_byte *valaddr, struct type *type,\n     fprintf_filtered (stream, \"%ld\", (long) val);\n }\n \n+#if GDB_SELF_TEST\n+\n+/* Test printing of TYPE_CODE_STRUCT values.  */\n+\n+static void\n+test_print_fields (gdbarch *arch)\n+{\n+  struct field *f;\n+  type *uint8_type = builtin_type (arch)->builtin_uint8;\n+  type *bool_type = builtin_type (arch)->builtin_bool;\n+  type *the_struct = arch_composite_type (arch, NULL, TYPE_CODE_STRUCT);\n+  TYPE_LENGTH (the_struct) = 4;\n+\n+  /* Value:  1110 1001\n+     Fields: C-BB B-A- */\n+  if (gdbarch_byte_order (arch) == BFD_ENDIAN_LITTLE)\n+    {\n+      f = append_composite_type_field_raw (the_struct, \"A\", bool_type);\n+      SET_FIELD_BITPOS (*f, 1);\n+      FIELD_BITSIZE (*f) = 1;\n+      f = append_composite_type_field_raw (the_struct, \"B\", uint8_type);\n+      SET_FIELD_BITPOS (*f, 3);\n+      FIELD_BITSIZE (*f) = 3;\n+      f = append_composite_type_field_raw (the_struct, \"C\", bool_type);\n+      SET_FIELD_BITPOS (*f, 7);\n+      FIELD_BITSIZE (*f) = 1;\n+    }\n+  /* According to the logic commented in \"make_gdb_type_struct ()\" of\n+   * target-descriptions.c, bit positions are numbered differently for\n+   * little and big endians.  */\n+  else\n+    {\n+      f = append_composite_type_field_raw (the_struct, \"A\", bool_type);\n+      SET_FIELD_BITPOS (*f, 30);\n+      FIELD_BITSIZE (*f) = 1;\n+      f = append_composite_type_field_raw (the_struct, \"B\", uint8_type);\n+      SET_FIELD_BITPOS (*f, 26);\n+      FIELD_BITSIZE (*f) = 3;\n+      f = append_composite_type_field_raw (the_struct, \"C\", bool_type);\n+      SET_FIELD_BITPOS (*f, 24);\n+      FIELD_BITSIZE (*f) = 1;\n+    }\n+\n+  value *val = allocate_value (the_struct);\n+  gdb_byte *contents = value_contents_writeable (val);\n+  store_unsigned_integer (contents, TYPE_LENGTH (value_enclosing_type (val)),\n+\t\t\t  gdbarch_byte_order (arch), 0xe9);\n+\n+  string_file out;\n+  struct value_print_options opts;\n+  get_no_prettyformat_print_options (&opts);\n+  cp_print_value_fields(val, &out, 0, &opts, NULL, 0);\n+  SELF_CHECK (out.string () == \"{A = false, B = 5, C = true}\");\n+\n+  out.clear();\n+  opts.format = 'x';\n+  cp_print_value_fields(val, &out, 0, &opts, NULL, 0);\n+  SELF_CHECK (out.string () == \"{A = 0x0, B = 0x5, C = 0x1}\");\n+}\n+\n+#endif\n+\n \n void _initialize_cp_valprint ();\n void\n _initialize_cp_valprint ()\n {\n+#if GDB_SELF_TEST\n+  selftests::register_test_foreach_arch (\"print-fields\", test_print_fields);\n+#endif\n+\n   obstack_begin (&dont_print_stat_array_obstack,\n \t\t 32 * sizeof (struct type *));\n   obstack_begin (&dont_print_statmem_obstack,"
    },
    {
      "sha": "74ad5d6f7fef9f63da01806cf8ff1e183de4bdeb",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/91254b918f1b35359d44b567a15013c42a931460/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/91254b918f1b35359d44b567a15013c42a931460/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=91254b918f1b35359d44b567a15013c42a931460",
      "patch": "@@ -6101,7 +6101,7 @@ gdbtypes_post_init (struct gdbarch *gdbarch)\n   builtin_type->builtin_string\n     = arch_type (gdbarch, TYPE_CODE_STRING, TARGET_CHAR_BIT, \"string\");\n   builtin_type->builtin_bool\n-    = arch_type (gdbarch, TYPE_CODE_BOOL, TARGET_CHAR_BIT, \"bool\");\n+    = arch_boolean_type (gdbarch, TARGET_CHAR_BIT, 1, \"bool\");\n \n   /* The following three are about decimal floating point types, which\n      are 32-bits, 64-bits and 128-bits respectively.  */"
    }
  ]
}