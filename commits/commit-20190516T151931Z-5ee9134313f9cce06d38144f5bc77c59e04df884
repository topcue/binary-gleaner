{
  "sha": "5ee9134313f9cce06d38144f5bc77c59e04df884",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWVlOTEzNDMxM2Y5Y2NlMDZkMzgxNDRmNWJjNzdjNTllMDRkZjg4NA==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-15T15:50:58Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T15:19:31Z"
    },
    "message": "[PATCH 2/57][Arm][GAS] Add support for MVE instructions: vpst, vadd, vsub and vabd\n\ngas/ChangeLog:\n2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\n\t* config/tc-arm.c (enum it_instruction_type): Rename to...\n\t(enum pred_instruction_type): ... this. Include VPT types.\n\t(it_insn_type): Rename to ...\n\t(pred_insn_type): .. this.\n\t(arm_it): Change comment.\n\t(enum arm_reg_type): Add new value.\n\t(reg_expected_msgs): New entry.\n\t(asm_opcode): Add mayBeVecPred member.\n\t(BAD_SYNTAX, BAD_NOT_VPT, BAD_OUT_VPT, BAD_VPT_COND, MVE_NOT_IT,\n\t MVE_NOT_VPT, MVE_BAD_PC, MVE_BAD_SP): New diagnostic MACROS.\n\t(arm_vcond_hsh): New table for vector condition codes.\n\t(now_it): Rename to ...\n\t(now_pred): ... this.\n\t(now_it_compatible): Rename to ...\n\t(now_pred_compatible): ... this.\n\t(in_it_block): Rename to ...\n\t(in_pred_block): ... this.\n\t(handle_it_state): Rename to ...\n\t(handle_pred_state): ... this. And change it to accept VPT blocks.\n\t(set_it_insn_type): Rename to ...\n\t(set_pred_insn_type): ... this.\n\t(set_it_insn_type_nonvoid): Rename to ...\n\t(set_pred_insn_type_nonvoid): ... this.\n\t(set_it_insn_type_last): Rename to ...\n\t(set_pred_insn_type_last): ... this.\n\t(record_feature_use): Moved.\n\t(mark_feature_used): Likewise.\n\t(parse_typed_reg_or_scalar): Add new case for REG_TYPE_MQ.\n\t(emit_insn): Use renamed functions and variables.\n\t(enum operand_parse_code): Add new operands.\n\t(parse_operands): Handle new operands.\n\t(do_scalar_fp16_v82_encode): Change predication detection.\n\t(do_it): Use renamed functions and variables.\n\t(do_t_add_sub): Likewise.\n\t(do_t_arit3): Likewise.\n\t(do_t_arit3c): Likewise.\n\t(do_t_blx): Likewise.\n\t(do_t_branch): Likewise.\n\t(do_t_bkpt_hlt1): Likewise.\n\t(do_t_branch23): Likewise.\n\t(do_t_bx): Likewise.\n\t(do_t_bxj): Likewise.\n\t(do_t_cond): Likewise.\n\t(do_t_csdb): Likewise.\n\t(do_t_cps): Likewise.\n\t(do_t_cpsi): Likewise.\n\t(do_t_cbz): Likewise.\n\t(do_t_it): Likewise.\n\t(do_mve_vpt): New function to handle VPT blocks.\n\t(encode_thumb2_multi): Use renamed functions and variables.\n\t(do_t_ldst): Use renamed functions and variables.\n\t(do_t_mov_cmp): Likewise.\n\t(do_t_mvn_tst): Likewise.\n\t(do_t_mul): Likewise.\n\t(do_t_nop): Likewise.\n\t(do_t_neg): Likewise.\n\t(do_t_rsb): Likewise.\n\t(do_t_setend): Likewise.\n\t(do_t_shift): Likewise.\n\t(do_t_smc): Likewise.\n\t(do_t_tb): Likewise.\n\t(do_t_udf): Likewise.\n\t(do_t_loloop): Likewise.\n\t(do_neon_cvt_1): Likewise.\n\t(do_vfp_nsyn_cvt_fpv8): Likewise.\n\t(do_vsel): Likewise.\n\t(do_vmaxnm): Likewise.\n\t(do_vrint_1): Likewise.\n\t(do_crypto_2op_1): Likewise.\n\t(do_crypto_3op_1): Likewise.\n\t(do_crc32_1): Likewise.\n\t(it_fsm_pre_encode): Likewise.\n\t(it_fsm_post_encode): Likewise.\n\t(force_automatic_it_block_close): Likewise.\n\t(check_it_blocks_finished): Likewise.\n\t(check_pred_blocks_finished): Likewise.\n\t(arm_cleanup): Likewise.\n\t(now_it_add_mask): Rename to ...\n\t(now_pred_add_mask): ... this. And use new variables and functions.\n\t(NEON_ENC_TAB): Add entries for vabdl, vaddl and vsubl.\n\t(N_I_MVE, N_F_MVE, N_SU_MVE): New MACROs.\n\t(neon_check_type): Generalize error message.\n\t(mve_encode_qqr): New MVE generic encoding function.\n\t(neon_dyadic_misc): Change to accept MVE variants.\n\t(do_neon_dyadic_if_su): Likewise.\n\t(do_neon_addsub_if_i): Likewise.\n\t(do_neon_dyadic_long): Likewise.\n\t(vfp_or_neon_is_neon): Add extra checks.\n\t(check_simd_pred_availability): Helper function to check SIMD\n\tinstruction availability with respect to predication.\n\t(enum opcode_tag): New suffix value.\n\t(opcode_lookup): Change to handle VPT blocks.\n\t(new_automatic_it_block): Rename to ...\n\t(close_automatic_it_block): ...this.\n\t(TxCE, TxC3, TxC3w, TUE, TUEc, TUF, CE, C3, ToC, ToU,\n\t toC, toU, CL, cCE, cCL, C3E, xCM_, UE, UF, NUF, nUF,\n\t NCE_tag, NCE, NCEF, nCE_tag, nCE, nCEF): Add default value for new\n\tfield.\n\t(mCEF, mnCEF, mnCE, MNUF, mnUF, mToC, MNCE, MNCEF): New MACROs.\n\t(insns): Redefine vadd, vsub, cabd, vabdl, vaddl, vsubl to accept MVE\n\tvariants. Add entries for vscclrm, and vpst.\n\t(md_begin): Add arm_vcond_hsh initialization.\n\t* config/tc-arm.h (enum it_state): Rename to...\n\t(enum pred_state): ...this.\n\t(struct current_it): Rename to...\n\t(struct current_pred): ...this.\n\t(enum pred_type): New enum.\n\t(struct arm_segment_info_type): Use current_pred.\n\t* testsuite/gas/arm/armv8_3-a-fp-bad.l: Update error message.\n\t* testsuite/gas/arm/armv8_3-a-simd-bad.l: Update error message.\n\t* testsuite/gas/arm/dotprod-illegal.l: Update error message.\n\t* testsuite/gas/arm/mve-vaddsubabd-bad-1.d: New test.\n\t* testsuite/gas/arm/mve-vaddsubabd-bad-1.l: New test.\n\t* testsuite/gas/arm/mve-vaddsubabd-bad-1.s: New test.\n\t* testsuite/gas/arm/mve-vaddsubabd-bad-2.d: New test.\n\t* testsuite/gas/arm/mve-vaddsubabd-bad-2.l: New test.\n\t* testsuite/gas/arm/mve-vaddsubabd-bad-2.s: New test.\n\t* testsuite/gas/arm/mve-vpst-bad.d: New test.\n\t* testsuite/gas/arm/mve-vpst-bad.l: New test.\n\t* testsuite/gas/arm/mve-vpst-bad.s: New test.\n\t* testsuite/gas/arm/neon-ldst-es-bad.l: Updated error message.",
    "tree": {
      "sha": "0ea75a63a0895331abbc0c17c562c4b3691dd73f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0ea75a63a0895331abbc0c17c562c4b3691dd73f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5ee9134313f9cce06d38144f5bc77c59e04df884",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5ee9134313f9cce06d38144f5bc77c59e04df884",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5ee9134313f9cce06d38144f5bc77c59e04df884",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5ee9134313f9cce06d38144f5bc77c59e04df884/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a7ad558c377fd5f5cc7bc77837c532f907f2c53b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a7ad558c377fd5f5cc7bc77837c532f907f2c53b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a7ad558c377fd5f5cc7bc77837c532f907f2c53b"
    }
  ],
  "stats": {
    "total": 1681,
    "additions": 1328,
    "deletions": 353
  },
  "files": [
    {
      "sha": "c26396d27346b8af955b5453730d4c076896974e",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 124,
      "deletions": 0,
      "changes": 124,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -1,3 +1,127 @@\n+2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\n+\t* config/tc-arm.c (enum it_instruction_type): Rename to...\n+\t(enum pred_instruction_type): ... this. Include VPT types.\n+\t(it_insn_type): Rename to ...\n+\t(pred_insn_type): .. this.\n+\t(arm_it): Change comment.\n+\t(enum arm_reg_type): Add new value.\n+\t(reg_expected_msgs): New entry.\n+\t(asm_opcode): Add mayBeVecPred member.\n+\t(BAD_SYNTAX, BAD_NOT_VPT, BAD_OUT_VPT, BAD_VPT_COND, MVE_NOT_IT,\n+\t MVE_NOT_VPT, MVE_BAD_PC, MVE_BAD_SP): New diagnostic MACROS.\n+\t(arm_vcond_hsh): New table for vector condition codes.\n+\t(now_it): Rename to ...\n+\t(now_pred): ... this.\n+\t(now_it_compatible): Rename to ...\n+\t(now_pred_compatible): ... this.\n+\t(in_it_block): Rename to ...\n+\t(in_pred_block): ... this.\n+\t(handle_it_state): Rename to ...\n+\t(handle_pred_state): ... this. And change it to accept VPT blocks.\n+\t(set_it_insn_type): Rename to ...\n+\t(set_pred_insn_type): ... this.\n+\t(set_it_insn_type_nonvoid): Rename to ...\n+\t(set_pred_insn_type_nonvoid): ... this.\n+\t(set_it_insn_type_last): Rename to ...\n+\t(set_pred_insn_type_last): ... this.\n+\t(record_feature_use): Moved.\n+\t(mark_feature_used): Likewise.\n+\t(parse_typed_reg_or_scalar): Add new case for REG_TYPE_MQ.\n+\t(emit_insn): Use renamed functions and variables.\n+\t(enum operand_parse_code): Add new operands.\n+\t(parse_operands): Handle new operands.\n+\t(do_scalar_fp16_v82_encode): Change predication detection.\n+\t(do_it): Use renamed functions and variables.\n+\t(do_t_add_sub): Likewise.\n+\t(do_t_arit3): Likewise.\n+\t(do_t_arit3c): Likewise.\n+\t(do_t_blx): Likewise.\n+\t(do_t_branch): Likewise.\n+\t(do_t_bkpt_hlt1): Likewise.\n+\t(do_t_branch23): Likewise.\n+\t(do_t_bx): Likewise.\n+\t(do_t_bxj): Likewise.\n+\t(do_t_cond): Likewise.\n+\t(do_t_csdb): Likewise.\n+\t(do_t_cps): Likewise.\n+\t(do_t_cpsi): Likewise.\n+\t(do_t_cbz): Likewise.\n+\t(do_t_it): Likewise.\n+\t(do_mve_vpt): New function to handle VPT blocks.\n+\t(encode_thumb2_multi): Use renamed functions and variables.\n+\t(do_t_ldst): Use renamed functions and variables.\n+\t(do_t_mov_cmp): Likewise.\n+\t(do_t_mvn_tst): Likewise.\n+\t(do_t_mul): Likewise.\n+\t(do_t_nop): Likewise.\n+\t(do_t_neg): Likewise.\n+\t(do_t_rsb): Likewise.\n+\t(do_t_setend): Likewise.\n+\t(do_t_shift): Likewise.\n+\t(do_t_smc): Likewise.\n+\t(do_t_tb): Likewise.\n+\t(do_t_udf): Likewise.\n+\t(do_t_loloop): Likewise.\n+\t(do_neon_cvt_1): Likewise.\n+\t(do_vfp_nsyn_cvt_fpv8): Likewise.\n+\t(do_vsel): Likewise.\n+\t(do_vmaxnm): Likewise.\n+\t(do_vrint_1): Likewise.\n+\t(do_crypto_2op_1): Likewise.\n+\t(do_crypto_3op_1): Likewise.\n+\t(do_crc32_1): Likewise.\n+\t(it_fsm_pre_encode): Likewise.\n+\t(it_fsm_post_encode): Likewise.\n+\t(force_automatic_it_block_close): Likewise.\n+\t(check_it_blocks_finished): Likewise.\n+\t(check_pred_blocks_finished): Likewise.\n+\t(arm_cleanup): Likewise.\n+\t(now_it_add_mask): Rename to ...\n+\t(now_pred_add_mask): ... this. And use new variables and functions.\n+\t(NEON_ENC_TAB): Add entries for vabdl, vaddl and vsubl.\n+\t(N_I_MVE, N_F_MVE, N_SU_MVE): New MACROs.\n+\t(neon_check_type): Generalize error message.\n+\t(mve_encode_qqr): New MVE generic encoding function.\n+\t(neon_dyadic_misc): Change to accept MVE variants.\n+\t(do_neon_dyadic_if_su): Likewise.\n+\t(do_neon_addsub_if_i): Likewise.\n+\t(do_neon_dyadic_long): Likewise.\n+\t(vfp_or_neon_is_neon): Add extra checks.\n+\t(check_simd_pred_availability): Helper function to check SIMD\n+\tinstruction availability with respect to predication.\n+\t(enum opcode_tag): New suffix value.\n+\t(opcode_lookup): Change to handle VPT blocks.\n+\t(new_automatic_it_block): Rename to ...\n+\t(close_automatic_it_block): ...this.\n+\t(TxCE, TxC3, TxC3w, TUE, TUEc, TUF, CE, C3, ToC, ToU,\n+\t toC, toU, CL, cCE, cCL, C3E, xCM_, UE, UF, NUF, nUF,\n+\t NCE_tag, NCE, NCEF, nCE_tag, nCE, nCEF): Add default value for new\n+\tfield.\n+\t(mCEF, mnCEF, mnCE, MNUF, mnUF, mToC, MNCE, MNCEF): New MACROs.\n+\t(insns): Redefine vadd, vsub, cabd, vabdl, vaddl, vsubl to accept MVE\n+\tvariants. Add entries for vscclrm, and vpst.\n+\t(md_begin): Add arm_vcond_hsh initialization.\n+\t* config/tc-arm.h (enum it_state): Rename to...\n+\t(enum pred_state): ...this.\n+\t(struct current_it): Rename to...\n+\t(struct current_pred): ...this.\n+\t(enum pred_type): New enum.\n+\t(struct arm_segment_info_type): Use current_pred.\n+\t* testsuite/gas/arm/armv8_3-a-fp-bad.l: Update error message.\n+\t* testsuite/gas/arm/armv8_3-a-simd-bad.l: Update error message.\n+\t* testsuite/gas/arm/dotprod-illegal.l: Update error message.\n+\t* testsuite/gas/arm/mve-vaddsubabd-bad-1.d: New test.\n+\t* testsuite/gas/arm/mve-vaddsubabd-bad-1.l: New test.\n+\t* testsuite/gas/arm/mve-vaddsubabd-bad-1.s: New test.\n+\t* testsuite/gas/arm/mve-vaddsubabd-bad-2.d: New test.\n+\t* testsuite/gas/arm/mve-vaddsubabd-bad-2.l: New test.\n+\t* testsuite/gas/arm/mve-vaddsubabd-bad-2.s: New test.\n+\t* testsuite/gas/arm/mve-vpst-bad.d: New test.\n+\t* testsuite/gas/arm/mve-vpst-bad.l: New test.\n+\t* testsuite/gas/arm/mve-vpst-bad.s: New test.\n+\t* testsuite/gas/arm/neon-ldst-es-bad.l: Updated error message.\n+\n 2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \n \t* config/tc-arm.c (mve_ext, mve_fp_ext): New features."
    },
    {
      "sha": "46d0f4e7b59914ebc7e01730b549215a4dd435bf",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 895,
      "deletions": 324,
      "changes": 1219,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -453,16 +453,20 @@ struct neon_type\n   unsigned elems;\n };\n \n-enum it_instruction_type\n+enum pred_instruction_type\n {\n-   OUTSIDE_IT_INSN,\n+   OUTSIDE_PRED_INSN,\n+   INSIDE_VPT_INSN,\n    INSIDE_IT_INSN,\n    INSIDE_IT_LAST_INSN,\n    IF_INSIDE_IT_LAST_INSN, /* Either outside or inside;\n \t\t\t      if inside, should be the last one.  */\n    NEUTRAL_IT_INSN,        /* This could be either inside or outside,\n \t\t\t      i.e. BKPT and NOP.  */\n-   IT_INSN                 /* The IT insn has been parsed.  */\n+   IT_INSN,\t\t   /* The IT insn has been parsed.  */\n+   VPT_INSN,\t\t   /* The VPT/VPST insn has been parsed.  */\n+   MVE_OUTSIDE_PRED_INSN   /* Instruction to indicate a MVE instruction without\n+\t\t\t      a predication code.  */\n };\n \n /* The maximum number of operands we need.  */\n@@ -494,7 +498,7 @@ struct arm_it\n     int\t\t\t     pc_rel;\n   } relocs[ARM_IT_MAX_RELOCS];\n \n-  enum it_instruction_type it_insn_type;\n+  enum pred_instruction_type pred_insn_type;\n \n   struct\n   {\n@@ -511,7 +515,7 @@ struct arm_it\n        instructions. This allows us to disambiguate ARM <-> vector insns.  */\n     unsigned regisimm   : 1;  /* 64-bit immediate, reg forms high 32 bits.  */\n     unsigned isvec      : 1;  /* Is a single, double or quad VFP/Neon reg.  */\n-    unsigned isquad     : 1;  /* Operand is Neon quad-precision register.  */\n+    unsigned isquad     : 1;  /* Operand is SIMD quad register.  */\n     unsigned issingle   : 1;  /* Operand is VFP single-precision register.  */\n     unsigned hasreloc\t: 1;  /* Operand has relocation suffix.  */\n     unsigned writeback\t: 1;  /* Operand has trailing !  */\n@@ -630,12 +634,13 @@ enum arm_reg_type\n   REG_TYPE_MVFX,\n   REG_TYPE_MVDX,\n   REG_TYPE_MVAX,\n+  REG_TYPE_MQ,\n   REG_TYPE_DSPSC,\n   REG_TYPE_MMXWR,\n   REG_TYPE_MMXWC,\n   REG_TYPE_MMXWCG,\n   REG_TYPE_XSCALE,\n-  REG_TYPE_RNB\n+  REG_TYPE_RNB,\n };\n \n /* Structure for a hash table entry for a register.\n@@ -677,6 +682,7 @@ const char * const reg_expected_msgs[] =\n   [REG_TYPE_MMXWC]  = N_(\"iWMMXt control register expected\"),\n   [REG_TYPE_MMXWCG] = N_(\"iWMMXt scalar register expected\"),\n   [REG_TYPE_XSCALE] = N_(\"XScale accumulator register expected\"),\n+  [REG_TYPE_MQ]\t    = N_(\"MVE vector register expected\"),\n   [REG_TYPE_RNB]    = N_(\"\")\n };\n \n@@ -716,6 +722,9 @@ struct asm_opcode\n \n   /* Function to call to encode instruction in Thumb format.  */\n   void (* tencode) (void);\n+\n+  /* Indicates whether this instruction may be vector predicated.  */\n+  unsigned int mayBeVecPred : 1;\n };\n \n /* Defines for various bits that we will want to toggle.  */\n@@ -838,6 +847,7 @@ struct asm_opcode\n #define THUMB_LOAD_BIT 0x0800\n #define THUMB2_LOAD_BIT 0x00100000\n \n+#define BAD_SYNTAX\t_(\"syntax error\")\n #define BAD_ARGS\t_(\"bad arguments to instruction\")\n #define BAD_SP          _(\"r13 not allowed here\")\n #define BAD_PC\t\t_(\"r15 not allowed here\")\n@@ -849,9 +859,13 @@ struct asm_opcode\n #define BAD_BRANCH\t_(\"branch must be last instruction in IT block\")\n #define BAD_BRANCH_OFF\t_(\"branch out of range or not a multiple of 2\")\n #define BAD_NOT_IT\t_(\"instruction not allowed in IT block\")\n+#define BAD_NOT_VPT\t_(\"instruction missing MVE vector predication code\")\n #define BAD_FPU\t\t_(\"selected FPU does not support instruction\")\n #define BAD_OUT_IT \t_(\"thumb conditional instruction should be in IT block\")\n+#define BAD_OUT_VPT\t\\\n+\t_(\"vector predicated instruction should be in VPT/VPST block\")\n #define BAD_IT_COND\t_(\"incorrect condition in IT block\")\n+#define BAD_VPT_COND\t_(\"incorrect condition in VPT/VPST block\")\n #define BAD_IT_IT \t_(\"IT falling in the range of a previous IT block\")\n #define MISSING_FNSTART\t_(\"missing .fnstart before unwinding directive\")\n #define BAD_PC_ADDRESSING \\\n@@ -862,9 +876,18 @@ struct asm_opcode\n #define BAD_FP16\t_(\"selected processor does not support fp16 instruction\")\n #define UNPRED_REG(R)\t_(\"using \" R \" results in unpredictable behaviour\")\n #define THUMB1_RELOC_ONLY  _(\"relocation valid in thumb1 code only\")\n+#define MVE_NOT_IT\t_(\"Warning: instruction is UNPREDICTABLE in an IT \" \\\n+\t\t\t  \"block\")\n+#define MVE_NOT_VPT\t_(\"Warning: instruction is UNPREDICTABLE in a VPT \" \\\n+\t\t\t  \"block\")\n+#define MVE_BAD_PC\t_(\"Warning: instruction is UNPREDICTABLE with PC\" \\\n+\t\t\t  \" operand\")\n+#define MVE_BAD_SP\t_(\"Warning: instruction is UNPREDICTABLE with SP\" \\\n+\t\t\t  \" operand\")\n \n static struct hash_control * arm_ops_hsh;\n static struct hash_control * arm_cond_hsh;\n+static struct hash_control * arm_vcond_hsh;\n static struct hash_control * arm_shift_hsh;\n static struct hash_control * arm_psr_hsh;\n static struct hash_control * arm_v7m_psr_hsh;\n@@ -916,15 +939,15 @@ typedef enum asmfunc_states\n static asmfunc_states asmfunc_state = OUTSIDE_ASMFUNC;\n \n #ifdef OBJ_ELF\n-#  define now_it seg_info (now_seg)->tc_segment_info_data.current_it\n+#  define now_pred seg_info (now_seg)->tc_segment_info_data.current_pred\n #else\n-static struct current_it now_it;\n+static struct current_pred now_pred;\n #endif\n \n static inline int\n-now_it_compatible (int cond)\n+now_pred_compatible (int cond)\n {\n-  return (cond & ~1) == (now_it.cc & ~1);\n+  return (cond & ~1) == (now_pred.cc & ~1);\n }\n \n static inline int\n@@ -933,39 +956,39 @@ conditional_insn (void)\n   return inst.cond != COND_ALWAYS;\n }\n \n-static int in_it_block (void);\n+static int in_pred_block (void);\n \n-static int handle_it_state (void);\n+static int handle_pred_state (void);\n \n static void force_automatic_it_block_close (void);\n \n static void it_fsm_post_encode (void);\n \n-#define set_it_insn_type(type)\t\t\t\\\n+#define set_pred_insn_type(type)\t\t\t\\\n   do\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\\\n-      inst.it_insn_type = type;\t\t\t\\\n-      if (handle_it_state () == FAIL)\t\t\\\n+      inst.pred_insn_type = type;\t\t\t\\\n+      if (handle_pred_state () == FAIL)\t\t\\\n \treturn;\t\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n   while (0)\n \n-#define set_it_insn_type_nonvoid(type, failret) \\\n+#define set_pred_insn_type_nonvoid(type, failret) \\\n   do\t\t\t\t\t\t\\\n     {                                           \\\n-      inst.it_insn_type = type;\t\t\t\\\n-      if (handle_it_state () == FAIL)\t\t\\\n+      inst.pred_insn_type = type;\t\t\t\\\n+      if (handle_pred_state () == FAIL)\t\t\\\n \treturn failret;\t\t\t\t\\\n     }\t\t\t\t\t\t\\\n   while(0)\n \n-#define set_it_insn_type_last()\t\t\t\t\\\n+#define set_pred_insn_type_last()\t\t\t\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       if (inst.cond == COND_ALWAYS)\t\t\t\\\n-\tset_it_insn_type (IF_INSIDE_IT_LAST_INSN);\t\\\n+\tset_pred_insn_type (IF_INSIDE_IT_LAST_INSN);\t\\\n       else\t\t\t\t\t\t\\\n-\tset_it_insn_type (INSIDE_IT_LAST_INSN);\t\t\\\n+\tset_pred_insn_type (INSIDE_IT_LAST_INSN);\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n@@ -1497,6 +1520,32 @@ parse_neon_operand_type (struct neon_type_el *vectype, char **ccp)\n #define NEON_ALL_LANES\t\t15\n #define NEON_INTERLEAVE_LANES\t14\n \n+/* Record a use of the given feature.  */\n+static void\n+record_feature_use (const arm_feature_set *feature)\n+{\n+  if (thumb_mode)\n+    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used, *feature);\n+  else\n+    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used, *feature);\n+}\n+\n+/* If the given feature available in the selected CPU, mark it as used.\n+   Returns TRUE iff feature is available.  */\n+static bfd_boolean\n+mark_feature_used (const arm_feature_set *feature)\n+{\n+  /* Ensure the option is valid on the current architecture.  */\n+  if (!ARM_CPU_HAS_FEATURE (cpu_variant, *feature))\n+    return FALSE;\n+\n+  /* Add the appropriate architecture feature for the barrier option used.\n+     */\n+  record_feature_use (feature);\n+\n+  return TRUE;\n+}\n+\n /* Parse either a register or a scalar, with an optional type. Return the\n    register number, and optionally fill in the actual type of the register\n    when multiple alternatives were given (NEON_TYPE_NDQ) in *RTYPE, and\n@@ -1543,6 +1592,26 @@ parse_typed_reg_or_scalar (char **ccp, enum arm_reg_type type,\n \t  && (reg->type == REG_TYPE_MMXWCG)))\n     type = (enum arm_reg_type) reg->type;\n \n+  if (type == REG_TYPE_MQ)\n+    {\n+      if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+\treturn FAIL;\n+\n+      if (!reg || reg->type != REG_TYPE_NQ)\n+\treturn FAIL;\n+\n+      if (reg->number > 14 && !mark_feature_used (&fpu_vfp_ext_d32))\n+\t{\n+\t  first_error (_(\"expected MVE register [q0..q7]\"));\n+\t  return FAIL;\n+\t}\n+      type = REG_TYPE_NQ;\n+    }\n+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext)\n+\t   && (type == REG_TYPE_NQ))\n+    return FAIL;\n+\n+\n   if (type != reg->type)\n     return FAIL;\n \n@@ -3762,10 +3831,10 @@ emit_insn (expressionS *exp, int nbytes)\n \t    }\n \t  else\n \t    {\n-\t      if (now_it.state == AUTOMATIC_IT_BLOCK)\n-\t\tset_it_insn_type_nonvoid (OUTSIDE_IT_INSN, 0);\n+\t      if (now_pred.state == AUTOMATIC_PRED_BLOCK)\n+\t\tset_pred_insn_type_nonvoid (OUTSIDE_PRED_INSN, 0);\n \t      else\n-\t\tset_it_insn_type_nonvoid (NEUTRAL_IT_INSN, 0);\n+\t\tset_pred_insn_type_nonvoid (NEUTRAL_IT_INSN, 0);\n \n \t      if (thumb_mode && (size > THUMB_SIZE) && !target_big_endian)\n \t\temit_thumb32_expr (exp);\n@@ -6293,31 +6362,6 @@ parse_cond (char **str)\n   return c->value;\n }\n \n-/* Record a use of the given feature.  */\n-static void\n-record_feature_use (const arm_feature_set *feature)\n-{\n-  if (thumb_mode)\n-    ARM_MERGE_FEATURE_SETS (thumb_arch_used, thumb_arch_used, *feature);\n-  else\n-    ARM_MERGE_FEATURE_SETS (arm_arch_used, arm_arch_used, *feature);\n-}\n-\n-/* If the given feature is currently allowed, mark it as used and return TRUE.\n-   Return FALSE otherwise.  */\n-static bfd_boolean\n-mark_feature_used (const arm_feature_set *feature)\n-{\n-  /* Ensure the option is currently allowed.  */\n-  if (!ARM_CPU_HAS_FEATURE (cpu_variant, *feature))\n-    return FALSE;\n-\n-  /* Add the appropriate architecture feature for the barrier option used.  */\n-  record_feature_use (feature);\n-\n-  return TRUE;\n-}\n-\n /* Parse an option for a barrier instruction.  Returns the encoding for the\n    option, or FAIL.  */\n static int\n@@ -6643,10 +6687,15 @@ enum operand_parse_code\n   OP_RVS,\t/* VFP single precision register */\n   OP_RVD,\t/* VFP double precision register (0..15) */\n   OP_RND,       /* Neon double precision register (0..31) */\n+  OP_RNDMQ,     /* Neon double precision (0..31) or MVE vector register.  */\n+  OP_RNDMQR,    /* Neon double precision (0..31), MVE vector or ARM register.\n+\t\t */\n   OP_RNQ,\t/* Neon quad precision register */\n+  OP_RNQMQ,\t/* Neon quad or MVE vector register.  */\n   OP_RVSD,\t/* VFP single or double precision register */\n   OP_RNSD,      /* Neon single or double precision register */\n   OP_RNDQ,      /* Neon double or quad precision register */\n+  OP_RNDQMQ,     /* Neon double, quad or MVE vector register.  */\n   OP_RNSDQ,\t/* Neon single, double or quad precision register */\n   OP_RNSC,      /* Neon scalar D[X] */\n   OP_RVC,\t/* VFP control register */\n@@ -6661,6 +6710,10 @@ enum operand_parse_code\n   OP_RIWG,\t/* iWMMXt wCG register */\n   OP_RXA,\t/* XScale accumulator register */\n \n+  OP_RNSDQMQ,\t/* Neon single, double or quad register or MVE vector register\n+\t\t */\n+  OP_RNSDQMQR,\t/* Neon single, double or quad register, MVE vector register or\n+\t\t   GPR (no SP/SP)  */\n   /* New operands for Armv8.1-M Mainline.  */\n   OP_LR,\t/* ARM LR register */\n   OP_RRnpcsp_I32, /* ARM register (no BadReg) or literal 1 .. 32 */\n@@ -6753,8 +6806,11 @@ enum operand_parse_code\n   OP_oRRw,\t /* ARM register, not r15, optional trailing ! */\n   OP_oRND,       /* Optional Neon double precision register */\n   OP_oRNQ,       /* Optional Neon quad precision register */\n+  OP_oRNDQMQ,     /* Optional Neon double, quad or MVE vector register.  */\n   OP_oRNDQ,      /* Optional Neon double or quad precision register */\n   OP_oRNSDQ,\t /* Optional single, double or quad precision vector register */\n+  OP_oRNSDQMQ,\t /* Optional single, double or quad register or MVE vector\n+\t\t    register.  */\n   OP_oSHll,\t /* LSL immediate */\n   OP_oSHar,\t /* ASR immediate */\n   OP_oSHllar,\t /* LSL or ASR immediate */\n@@ -6926,6 +6982,14 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \tcase OP_RVS:   po_reg_or_fail (REG_TYPE_VFS);\t  break;\n \tcase OP_RVD:   po_reg_or_fail (REG_TYPE_VFD);\t  break;\n \tcase OP_oRND:\n+\tcase OP_RNDMQR:\n+\t  po_reg_or_goto (REG_TYPE_RN, try_rndmq);\n+\t  break;\n+\ttry_rndmq:\n+\tcase OP_RNDMQ:\n+\t  po_reg_or_goto (REG_TYPE_MQ, try_rnd);\n+\t  break;\n+\ttry_rnd:\n \tcase OP_RND:   po_reg_or_fail (REG_TYPE_VFD);\t  break;\n \tcase OP_RVC:\n \t  po_reg_or_goto (REG_TYPE_VFC, coproc_reg);\n@@ -6945,14 +7009,34 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \tcase OP_RIWG:  po_reg_or_fail (REG_TYPE_MMXWCG);  break;\n \tcase OP_RXA:   po_reg_or_fail (REG_TYPE_XSCALE);  break;\n \tcase OP_oRNQ:\n+\tcase OP_RNQMQ:\n+\t  po_reg_or_goto (REG_TYPE_MQ, try_nq);\n+\t  break;\n+\ttry_nq:\n \tcase OP_RNQ:   po_reg_or_fail (REG_TYPE_NQ);      break;\n \tcase OP_RNSD:  po_reg_or_fail (REG_TYPE_NSD);     break;\n+\tcase OP_oRNDQMQ:\n+\tcase OP_RNDQMQ:\n+\t  po_reg_or_goto (REG_TYPE_MQ, try_rndq);\n+\t  break;\n+\ttry_rndq:\n \tcase OP_oRNDQ:\n \tcase OP_RNDQ:  po_reg_or_fail (REG_TYPE_NDQ);     break;\n \tcase OP_RVSD:  po_reg_or_fail (REG_TYPE_VFSD);    break;\n \tcase OP_oRNSDQ:\n \tcase OP_RNSDQ: po_reg_or_fail (REG_TYPE_NSDQ);    break;\n-\n+\tcase OP_RNSDQMQR:\n+\t  po_reg_or_goto (REG_TYPE_RN, try_mq);\n+\t  break;\n+\t  try_mq:\n+\tcase OP_oRNSDQMQ:\n+\tcase OP_RNSDQMQ:\n+\t  po_reg_or_goto (REG_TYPE_MQ, try_nsdq2);\n+\t  break;\n+\t  try_nsdq2:\n+\t  po_reg_or_fail (REG_TYPE_NSDQ);\n+\t  inst.error = 0;\n+\t  break;\n \t/* Neon scalar. Using an element size of 8 means that some invalid\n \t   scalars are accepted here, so deal with those in later code.  */\n \tcase OP_RNSC:  po_scalar_or_goto (8, failure);    break;\n@@ -7490,7 +7574,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \t  /* The parse routine should already have set inst.error, but set a\n \t     default here just in case.  */\n \t  if (!inst.error)\n-\t    inst.error = _(\"syntax error\");\n+\t    inst.error = BAD_SYNTAX;\n \t  return FAIL;\n \t}\n \n@@ -7502,7 +7586,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n \t  && upat[i+1] == OP_stop)\n \t{\n \t  if (!inst.error)\n-\t    inst.error = _(\"syntax error\");\n+\t    inst.error = BAD_SYNTAX;\n \t  return FAIL;\n \t}\n \n@@ -7583,7 +7667,7 @@ parse_operands (char *str, const unsigned int *pattern, bfd_boolean thumb)\n static void\n do_scalar_fp16_v82_encode (void)\n {\n-  if (inst.cond != COND_ALWAYS)\n+  if (inst.cond < COND_ALWAYS)\n     as_warn (_(\"ARMv8.2 scalar fp16 instruction cannot be conditional,\"\n \t       \" the behaviour is UNPREDICTABLE\"));\n   constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_fp16),\n@@ -9056,9 +9140,9 @@ do_it (void)\n   inst.size = 0;\n   if (unified_syntax)\n     {\n-      set_it_insn_type (IT_INSN);\n-      now_it.mask = (inst.instruction & 0xf) | 0x10;\n-      now_it.cc = inst.operands[0].imm;\n+      set_pred_insn_type (IT_INSN);\n+      now_pred.mask = (inst.instruction & 0xf) | 0x10;\n+      now_pred.cc = inst.operands[0].imm;\n     }\n }\n \n@@ -10800,7 +10884,7 @@ do_t_add_sub (void)\n \t: inst.operands[0].reg);  /* Rd, foo -> Rd, Rd, foo */\n \n   if (Rd == REG_PC)\n-    set_it_insn_type_last ();\n+    set_pred_insn_type_last ();\n \n   if (unified_syntax)\n     {\n@@ -10811,9 +10895,9 @@ do_t_add_sub (void)\n       flags = (inst.instruction == T_MNEM_adds\n \t       || inst.instruction == T_MNEM_subs);\n       if (flags)\n-\tnarrow = !in_it_block ();\n+\tnarrow = !in_pred_block ();\n       else\n-\tnarrow = in_it_block ();\n+\tnarrow = in_pred_block ();\n       if (!inst.operands[2].isreg)\n \t{\n \t  int add;\n@@ -11090,9 +11174,9 @@ do_t_arit3 (void)\n \n \t  /* See if we can do this with a 16-bit instruction.  */\n \t  if (THUMB_SETS_FLAGS (inst.instruction))\n-\t    narrow = !in_it_block ();\n+\t    narrow = !in_pred_block ();\n \t  else\n-\t    narrow = in_it_block ();\n+\t    narrow = in_pred_block ();\n \n \t  if (Rd > 7 || Rn > 7 || Rs > 7)\n \t    narrow = FALSE;\n@@ -11178,9 +11262,9 @@ do_t_arit3c (void)\n \n \t  /* See if we can do this with a 16-bit instruction.  */\n \t  if (THUMB_SETS_FLAGS (inst.instruction))\n-\t    narrow = !in_it_block ();\n+\t    narrow = !in_pred_block ();\n \t  else\n-\t    narrow = in_it_block ();\n+\t    narrow = in_pred_block ();\n \n \t  if (Rd > 7 || Rn > 7 || Rs > 7)\n \t    narrow = FALSE;\n@@ -11319,7 +11403,7 @@ do_t_bfx (void)\n static void\n do_t_blx (void)\n {\n-  set_it_insn_type_last ();\n+  set_pred_insn_type_last ();\n \n   if (inst.operands[0].isreg)\n     {\n@@ -11343,9 +11427,9 @@ do_t_branch (void)\n   bfd_reloc_code_real_type reloc;\n \n   cond = inst.cond;\n-  set_it_insn_type (IF_INSIDE_IT_LAST_INSN);\n+  set_pred_insn_type (IF_INSIDE_IT_LAST_INSN);\n \n-  if (in_it_block ())\n+  if (in_pred_block ())\n     {\n       /* Conditional branches inside IT blocks are encoded as unconditional\n \t branches.  */\n@@ -11412,7 +11496,7 @@ do_t_bkpt_hlt1 (int range)\n       inst.instruction |= inst.operands[0].imm;\n     }\n \n-  set_it_insn_type (NEUTRAL_IT_INSN);\n+  set_pred_insn_type (NEUTRAL_IT_INSN);\n }\n \n static void\n@@ -11430,7 +11514,7 @@ do_t_bkpt (void)\n static void\n do_t_branch23 (void)\n {\n-  set_it_insn_type_last ();\n+  set_pred_insn_type_last ();\n   encode_branch (BFD_RELOC_THUMB_PCREL_BRANCH23);\n \n   /* md_apply_fix blows up with 'bl foo(PLT)' where foo is defined in\n@@ -11458,7 +11542,7 @@ do_t_branch23 (void)\n static void\n do_t_bx (void)\n {\n-  set_it_insn_type_last ();\n+  set_pred_insn_type_last ();\n   inst.instruction |= inst.operands[0].reg << 3;\n   /* ??? FIXME: Should add a hacky reloc here if reg is REG_PC.\t The reloc\n      should cause the alignment to be checked once it is known.\t This is\n@@ -11470,7 +11554,7 @@ do_t_bxj (void)\n {\n   int Rm;\n \n-  set_it_insn_type_last ();\n+  set_pred_insn_type_last ();\n   Rm = inst.operands[0].reg;\n   reject_bad_reg (Rm);\n   inst.instruction |= Rm << 16;\n@@ -11496,20 +11580,20 @@ do_t_clz (void)\n static void\n do_t_csdb (void)\n {\n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n }\n \n static void\n do_t_cps (void)\n {\n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n   inst.instruction |= inst.operands[0].imm;\n }\n \n static void\n do_t_cpsi (void)\n {\n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n   if (unified_syntax\n       && (inst.operands[1].present || inst.size_req == 4)\n       && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6_notm))\n@@ -11556,7 +11640,7 @@ do_t_cpy (void)\n static void\n do_t_cbz (void)\n {\n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n   constraint (inst.operands[0].reg > 7, BAD_HIREG);\n   inst.instruction |= inst.operands[0].reg;\n   inst.relocs[0].pc_rel = 1;\n@@ -11602,10 +11686,11 @@ do_t_it (void)\n {\n   unsigned int cond = inst.operands[0].imm;\n \n-  set_it_insn_type (IT_INSN);\n-  now_it.mask = (inst.instruction & 0xf) | 0x10;\n-  now_it.cc = cond;\n-  now_it.warn_deprecated = FALSE;\n+  set_pred_insn_type (IT_INSN);\n+  now_pred.mask = (inst.instruction & 0xf) | 0x10;\n+  now_pred.cc = cond;\n+  now_pred.warn_deprecated = FALSE;\n+  now_pred.type = SCALAR_PRED;\n \n   /* If the condition is a negative condition, invert the mask.  */\n   if ((cond & 0x1) == 0x0)\n@@ -11615,22 +11700,22 @@ do_t_it (void)\n       if ((mask & 0x7) == 0)\n \t{\n \t  /* No conversion needed.  */\n-\t  now_it.block_length = 1;\n+\t  now_pred.block_length = 1;\n \t}\n       else if ((mask & 0x3) == 0)\n \t{\n \t  mask ^= 0x8;\n-\t  now_it.block_length = 2;\n+\t  now_pred.block_length = 2;\n \t}\n       else if ((mask & 0x1) == 0)\n \t{\n \t  mask ^= 0xC;\n-\t  now_it.block_length = 3;\n+\t  now_pred.block_length = 3;\n \t}\n       else\n \t{\n \t  mask ^= 0xE;\n-\t  now_it.block_length = 4;\n+\t  now_pred.block_length = 4;\n \t}\n \n       inst.instruction &= 0xfff0;\n@@ -11640,6 +11725,18 @@ do_t_it (void)\n   inst.instruction |= cond << 4;\n }\n \n+static void\n+do_mve_vpt (void)\n+{\n+  /* We are dealing with a vector predicated block.  */\n+  set_pred_insn_type (VPT_INSN);\n+  now_pred.cc = 0;\n+  now_pred.mask = ((inst.instruction & 0x00400000) >> 19)\n+\t\t  | ((inst.instruction & 0xe000) >> 13);\n+  now_pred.warn_deprecated = FALSE;\n+  now_pred.type = VECTOR_PRED;\n+}\n+\n /* Helper function used for both push/pop and ldm/stm.  */\n static void\n encode_thumb2_multi (bfd_boolean do_io, int base, unsigned mask,\n@@ -11666,7 +11763,7 @@ encode_thumb2_multi (bfd_boolean do_io, int base, unsigned mask,\n \t  if (mask & (1 << 14))\n \t    inst.error = _(\"LR and PC should not both be in register list\");\n \t  else\n-\t    set_it_insn_type_last ();\n+\t    set_pred_insn_type_last ();\n \t}\n     }\n   else if (store)\n@@ -11880,7 +11977,7 @@ do_t_ldst (void)\n   if (inst.operands[0].isreg\n       && !inst.operands[0].preind\n       && inst.operands[0].reg == REG_PC)\n-    set_it_insn_type_last ();\n+    set_pred_insn_type_last ();\n \n   opcode = inst.instruction;\n   if (unified_syntax)\n@@ -12139,7 +12236,7 @@ do_t_mov_cmp (void)\n   Rm = inst.operands[1].reg;\n \n   if (Rn == REG_PC)\n-    set_it_insn_type_last ();\n+    set_pred_insn_type_last ();\n \n   if (unified_syntax)\n     {\n@@ -12151,7 +12248,7 @@ do_t_mov_cmp (void)\n \n       low_regs = (Rn <= 7 && Rm <= 7);\n       opcode = inst.instruction;\n-      if (in_it_block ())\n+      if (in_pred_block ())\n \tnarrow = opcode != T_MNEM_movs;\n       else\n \tnarrow = opcode != T_MNEM_movs || low_regs;\n@@ -12222,7 +12319,7 @@ do_t_mov_cmp (void)\n       if (!inst.operands[1].isreg)\n \t{\n \t  /* Immediate operand.  */\n-\t  if (!in_it_block () && opcode == T_MNEM_mov)\n+\t  if (!in_pred_block () && opcode == T_MNEM_mov)\n \t    narrow = 0;\n \t  if (low_regs && narrow)\n \t    {\n@@ -12258,7 +12355,7 @@ do_t_mov_cmp (void)\n \t  /* Register shifts are encoded as separate shift instructions.  */\n \t  bfd_boolean flags = (inst.instruction == T_MNEM_movs);\n \n-\t  if (in_it_block ())\n+\t  if (in_pred_block ())\n \t    narrow = !flags;\n \t  else\n \t    narrow = flags;\n@@ -12314,7 +12411,7 @@ do_t_mov_cmp (void)\n \t      && (inst.instruction == T_MNEM_mov\n \t\t  || inst.instruction == T_MNEM_movs))\n \t    {\n-\t      if (in_it_block ())\n+\t      if (in_pred_block ())\n \t\tnarrow = (inst.instruction == T_MNEM_mov);\n \t      else\n \t\tnarrow = (inst.instruction == T_MNEM_movs);\n@@ -12493,9 +12590,9 @@ do_t_mvn_tst (void)\n \t       || inst.instruction == T_MNEM_tst)\n \tnarrow = TRUE;\n       else if (THUMB_SETS_FLAGS (inst.instruction))\n-\tnarrow = !in_it_block ();\n+\tnarrow = !in_pred_block ();\n       else\n-\tnarrow = in_it_block ();\n+\tnarrow = in_pred_block ();\n \n       if (!inst.operands[1].isreg)\n \t{\n@@ -12660,9 +12757,9 @@ do_t_mul (void)\n \t  || Rm > 7)\n \tnarrow = FALSE;\n       else if (inst.instruction == T_MNEM_muls)\n-\tnarrow = !in_it_block ();\n+\tnarrow = !in_pred_block ();\n       else\n-\tnarrow = in_it_block ();\n+\tnarrow = in_pred_block ();\n     }\n   else\n     {\n@@ -12728,7 +12825,7 @@ do_t_mull (void)\n static void\n do_t_nop (void)\n {\n-  set_it_insn_type (NEUTRAL_IT_INSN);\n+  set_pred_insn_type (NEUTRAL_IT_INSN);\n \n   if (unified_syntax)\n     {\n@@ -12766,9 +12863,9 @@ do_t_neg (void)\n       bfd_boolean narrow;\n \n       if (THUMB_SETS_FLAGS (inst.instruction))\n-\tnarrow = !in_it_block ();\n+\tnarrow = !in_pred_block ();\n       else\n-\tnarrow = in_it_block ();\n+\tnarrow = in_pred_block ();\n       if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)\n \tnarrow = FALSE;\n       if (inst.size_req == 4)\n@@ -13030,9 +13127,9 @@ do_t_rsb (void)\n       bfd_boolean narrow;\n \n       if ((inst.instruction & 0x00100000) != 0)\n-\tnarrow = !in_it_block ();\n+\tnarrow = !in_pred_block ();\n       else\n-\tnarrow = in_it_block ();\n+\tnarrow = in_pred_block ();\n \n       if (Rd > 7 || Rs > 7)\n \tnarrow = FALSE;\n@@ -13070,7 +13167,7 @@ do_t_setend (void)\n       && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8))\n       as_tsktsk (_(\"setend use is deprecated for ARMv8\"));\n \n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n   if (inst.operands[0].imm)\n     inst.instruction |= 0x8;\n }\n@@ -13100,9 +13197,9 @@ do_t_shift (void)\n \t}\n \n       if (THUMB_SETS_FLAGS (inst.instruction))\n-\tnarrow = !in_it_block ();\n+\tnarrow = !in_pred_block ();\n       else\n-\tnarrow = in_it_block ();\n+\tnarrow = in_pred_block ();\n       if (inst.operands[0].reg > 7 || inst.operands[1].reg > 7)\n \tnarrow = FALSE;\n       if (!inst.operands[2].isreg && shift_kind == SHIFT_ROR)\n@@ -13272,7 +13369,7 @@ do_t_smc (void)\n   inst.instruction |= (value & 0x0ff0);\n   inst.instruction |= (value & 0x000f) << 16;\n   /* PR gas/15623: SMC instructions must be last in an IT block.  */\n-  set_it_insn_type_last ();\n+  set_pred_insn_type_last ();\n }\n \n static void\n@@ -13447,7 +13544,7 @@ do_t_tb (void)\n   int half;\n \n   half = (inst.instruction & 0x10) != 0;\n-  set_it_insn_type_last ();\n+  set_pred_insn_type_last ();\n   constraint (inst.operands[0].immisreg,\n \t      _(\"instruction requires register index\"));\n \n@@ -13483,7 +13580,7 @@ do_t_udf (void)\n       inst.instruction |= inst.operands[0].imm;\n     }\n \n-  set_it_insn_type (NEUTRAL_IT_INSN);\n+  set_pred_insn_type (NEUTRAL_IT_INSN);\n }\n \n \n@@ -13671,7 +13768,7 @@ do_t_loloop (void)\n {\n   unsigned long insn = inst.instruction;\n \n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n   inst.instruction = THUMB_OP32 (inst.instruction);\n \n   switch (insn)\n@@ -13713,13 +13810,16 @@ struct neon_tab_entry\n /* Map overloaded Neon opcodes to their respective encodings.  */\n #define NEON_ENC_TAB\t\t\t\t\t\\\n   X(vabd,\t0x0000700, 0x1200d00, N_INV),\t\t\\\n+  X(vabdl,\t0x0800700, N_INV,     N_INV),\t\t\\\n   X(vmax,\t0x0000600, 0x0000f00, N_INV),\t\t\\\n   X(vmin,\t0x0000610, 0x0200f00, N_INV),\t\t\\\n   X(vpadd,\t0x0000b10, 0x1000d00, N_INV),\t\t\\\n   X(vpmax,\t0x0000a00, 0x1000f00, N_INV),\t\t\\\n   X(vpmin,\t0x0000a10, 0x1200f00, N_INV),\t\t\\\n   X(vadd,\t0x0000800, 0x0000d00, N_INV),\t\t\\\n+  X(vaddl,\t0x0800000, N_INV,     N_INV),\t\t\\\n   X(vsub,\t0x1000800, 0x0200d00, N_INV),\t\t\\\n+  X(vsubl,\t0x0800200, N_INV,     N_INV),\t\t\\\n   X(vceq,\t0x1000810, 0x0000e00, 0x1b10100),\t\\\n   X(vcge,\t0x0000310, 0x1000e00, 0x1b10080),\t\\\n   X(vcgt,\t0x0000300, 0x1200e00, 0x1b10000),\t\\\n@@ -13862,6 +13962,7 @@ NEON_ENC_TAB\n   X(3, (Q, Q, I), QUAD),\t\t\\\n   X(3, (D, D, S), DOUBLE),\t\t\\\n   X(3, (Q, Q, S), QUAD),\t\t\\\n+  X(3, (Q, Q, R), QUAD),\t\t\\\n   X(2, (D, D), DOUBLE),\t\t\t\\\n   X(2, (Q, Q), QUAD),\t\t\t\\\n   X(2, (D, S), DOUBLE),\t\t\t\\\n@@ -14051,6 +14152,9 @@ enum neon_type_mask\n #define N_I_ALL    (N_I8 | N_I16 | N_I32 | N_I64)\n #define N_IF_32    (N_I8 | N_I16 | N_I32 | N_F16 | N_F32)\n #define N_F_ALL    (N_F16 | N_F32 | N_F64)\n+#define N_I_MVE\t   (N_I8 | N_I16 | N_I32)\n+#define N_F_MVE\t   (N_F16 | N_F32)\n+#define N_SU_MVE   (N_S8 | N_S16 | N_S32 | N_U8 | N_U16 | N_U32)\n \n /* Pass this as the first type argument to neon_check_type to ignore types\n    altogether.  */\n@@ -14579,7 +14683,7 @@ neon_check_type (unsigned els, enum neon_shape ns, ...)\n \n \t\t  if ((given_type & types_allowed) == 0)\n \t\t    {\n-\t\t      first_error (_(\"bad type in Neon instruction\"));\n+\t\t      first_error (_(\"bad type in SIMD instruction\"));\n \t\t      return badtype;\n \t\t    }\n \t\t}\n@@ -15022,6 +15126,45 @@ neon_logbits (unsigned x)\n #define LOW4(R) ((R) & 0xf)\n #define HI1(R) (((R) >> 4) & 1)\n \n+static void\n+mve_encode_qqr (int size, int fp)\n+{\n+  if (inst.operands[2].reg == REG_SP)\n+    as_tsktsk (MVE_BAD_SP);\n+  else if (inst.operands[2].reg == REG_PC)\n+    as_tsktsk (MVE_BAD_PC);\n+\n+  if (fp)\n+    {\n+      /* vadd.  */\n+      if (((unsigned)inst.instruction) == 0xd00)\n+\tinst.instruction = 0xee300f40;\n+      /* vsub.  */\n+      else if (((unsigned)inst.instruction) == 0x200d00)\n+\tinst.instruction = 0xee301f40;\n+\n+      /* Setting size which is 1 for F16 and 0 for F32.  */\n+      inst.instruction |= (size == 16) << 28;\n+    }\n+  else\n+    {\n+      /* vadd.  */\n+      if (((unsigned)inst.instruction) == 0x800)\n+\tinst.instruction = 0xee010f40;\n+      /* vsub.  */\n+      else if (((unsigned)inst.instruction) == 0x1000800)\n+\tinst.instruction = 0xee011f40;\n+      /* Setting bits for size.  */\n+      inst.instruction |= neon_logbits (size) << 20;\n+    }\n+  inst.instruction |= LOW4 (inst.operands[0].reg) << 12;\n+  inst.instruction |= HI1 (inst.operands[0].reg) << 22;\n+  inst.instruction |= LOW4 (inst.operands[1].reg) << 16;\n+  inst.instruction |= HI1 (inst.operands[1].reg) << 7;\n+  inst.instruction |= inst.operands[2].reg;\n+  inst.is_neon = 1;\n+}\n+\n /* Encode insns with bit pattern:\n \n   |28/24|23|22 |21 20|19 16|15 12|11    8|7|6|5|4|3  0|\n@@ -15343,26 +15486,27 @@ static void\n neon_dyadic_misc (enum neon_el_type ubit_meaning, unsigned types,\n \t\t  unsigned destbits)\n {\n-  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_NULL);\n+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_QQR, NS_NULL);\n   struct neon_type_el et = neon_check_type (3, rs, N_EQK | destbits, N_EQK,\n \t\t\t\t\t    types | N_KEY);\n   if (et.type == NT_float)\n     {\n       NEON_ENCODE (FLOAT, inst);\n-      neon_three_same (neon_quad (rs), 0, et.size == 16 ? (int) et.size : -1);\n+      if (rs == NS_QQR)\n+\tmve_encode_qqr (et.size, 1);\n+      else\n+\tneon_three_same (neon_quad (rs), 0, et.size == 16 ? (int) et.size : -1);\n     }\n   else\n     {\n       NEON_ENCODE (INTEGER, inst);\n-      neon_three_same (neon_quad (rs), et.type == ubit_meaning, et.size);\n+      if (rs == NS_QQR)\n+\tmve_encode_qqr (et.size, 0);\n+      else\n+\tneon_three_same (neon_quad (rs), et.type == ubit_meaning, et.size);\n     }\n }\n \n-static void\n-do_neon_dyadic_if_su (void)\n-{\n-  neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);\n-}\n \n static void\n do_neon_dyadic_if_su_d (void)\n@@ -15421,32 +15565,93 @@ vfp_or_neon_is_neon (unsigned check)\n \tinst.instruction |= inst.uncond_value << 28;\n     }\n \n-  if ((check & NEON_CHECK_ARCH)\n-      && !mark_feature_used (&fpu_neon_ext_v1))\n+\n+    if (((check & NEON_CHECK_ARCH) && !mark_feature_used (&fpu_neon_ext_v1))\n+\t|| ((check & NEON_CHECK_ARCH8)\n+\t    && !mark_feature_used (&fpu_neon_ext_armv8)))\n+      {\n+\tfirst_error (_(BAD_FPU));\n+\treturn FAIL;\n+      }\n+\n+  return SUCCESS;\n+}\n+\n+static int\n+check_simd_pred_availability (int fp, unsigned check)\n+{\n+  if (inst.cond > COND_ALWAYS)\n     {\n-      first_error (_(BAD_FPU));\n-      return FAIL;\n+      if (!ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+\t{\n+\t  inst.error = BAD_FPU;\n+\t  return 1;\n+\t}\n+      inst.pred_insn_type = INSIDE_VPT_INSN;\n     }\n-\n-  if ((check & NEON_CHECK_ARCH8)\n-      && !mark_feature_used (&fpu_neon_ext_armv8))\n+  else if (inst.cond < COND_ALWAYS)\n     {\n-      first_error (_(BAD_FPU));\n-      return FAIL;\n+      if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+\tinst.pred_insn_type = MVE_OUTSIDE_PRED_INSN;\n+      else if (vfp_or_neon_is_neon (check) == FAIL)\n+\treturn 2;\n     }\n+  else\n+    {\n+      if (!ARM_CPU_HAS_FEATURE (cpu_variant, fp ? mve_fp_ext : mve_ext)\n+\t  && vfp_or_neon_is_neon (check) == FAIL)\n+\treturn 3;\n \n-  return SUCCESS;\n+      if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+\tinst.pred_insn_type = MVE_OUTSIDE_PRED_INSN;\n+    }\n+  return 0;\n }\n \n static void\n-do_neon_addsub_if_i (void)\n+do_neon_dyadic_if_su (void)\n {\n-  if (try_vfp_nsyn (3, do_vfp_nsyn_add_sub) == SUCCESS)\n+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_QQR, NS_NULL);\n+  struct neon_type_el et = neon_check_type (3, rs, N_EQK , N_EQK,\n+\t\t\t\t\t    N_SUF_32 | N_KEY);\n+\n+  if (check_simd_pred_availability (et.type == NT_float,\n+\t\t\t\t    NEON_CHECK_ARCH | NEON_CHECK_CC))\n     return;\n \n-  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)\n+  neon_dyadic_misc (NT_unsigned, N_SUF_32, 0);\n+}\n+\n+static void\n+do_neon_addsub_if_i (void)\n+{\n+  if (ARM_CPU_HAS_FEATURE (cpu_variant, fpu_vfp_ext_v1xd)\n+      && try_vfp_nsyn (3, do_vfp_nsyn_add_sub) == SUCCESS)\n     return;\n \n+  enum neon_shape rs = neon_select_shape (NS_DDD, NS_QQQ, NS_QQR, NS_NULL);\n+  struct neon_type_el et = neon_check_type (3, rs, N_EQK,\n+\t\t\t\t\t    N_EQK, N_IF_32 | N_I64 | N_KEY);\n+\n+  constraint (rs == NS_QQR && et.size == 64, BAD_FPU);\n+  /* If we are parsing Q registers and the element types match MVE, which NEON\n+     also supports, then we must check whether this is an instruction that can\n+     be used by both MVE/NEON.  This distinction can be made based on whether\n+     they are predicated or not.  */\n+  if ((rs == NS_QQQ || rs == NS_QQR) && et.size != 64)\n+    {\n+      if (check_simd_pred_availability (et.type == NT_float,\n+\t\t\t\t\tNEON_CHECK_ARCH | NEON_CHECK_CC))\n+\treturn;\n+    }\n+  else\n+    {\n+      /* If they are either in a D register or are using an unsupported.  */\n+      if (rs != NS_QQR\n+\t  && vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH) == FAIL)\n+\treturn;\n+    }\n+\n   /* The \"untyped\" case can't happen. Do this to stop the \"U\" bit being\n      affected if we specify unsigned args.  */\n   neon_dyadic_misc (NT_untyped, N_IF_32 | N_I64, 0);\n@@ -16128,7 +16333,7 @@ do_vfp_nsyn_cvt_fpv8 (enum neon_cvt_flavour flavour,\n     constraint (!ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_fp16),\n \t\t_(BAD_FP16));\n \n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n \n   switch (flavour)\n     {\n@@ -16283,7 +16488,7 @@ do_neon_cvt_1 (enum neon_cvt_mode mode)\n       if (mode != neon_cvt_mode_x && mode != neon_cvt_mode_z)\n \t{\n \t  NEON_ENCODE (FLOAT, inst);\n-\t  set_it_insn_type (OUTSIDE_IT_INSN);\n+\t  set_pred_insn_type (OUTSIDE_PRED_INSN);\n \n \t  if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)\n \t    return;\n@@ -16584,10 +16789,49 @@ neon_mixed_length (struct neon_type_el et, unsigned size)\n static void\n do_neon_dyadic_long (void)\n {\n-  /* FIXME: Type checking for lengthening op.  */\n-  struct neon_type_el et = neon_check_type (3, NS_QDD,\n-    N_EQK | N_DBL, N_EQK, N_SU_32 | N_KEY);\n-  neon_mixed_length (et, et.size);\n+  enum neon_shape rs = neon_select_shape (NS_QDD, NS_QQQ, NS_QQR, NS_NULL);\n+  if (rs == NS_QDD)\n+    {\n+      if (vfp_or_neon_is_neon (NEON_CHECK_ARCH | NEON_CHECK_CC) == FAIL)\n+\treturn;\n+\n+      NEON_ENCODE (INTEGER, inst);\n+      /* FIXME: Type checking for lengthening op.  */\n+      struct neon_type_el et = neon_check_type (3, NS_QDD,\n+\tN_EQK | N_DBL, N_EQK, N_SU_32 | N_KEY);\n+      neon_mixed_length (et, et.size);\n+    }\n+  else if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext)\n+\t   && (inst.cond == 0xf || inst.cond == 0x10))\n+    {\n+      /* If parsing for MVE, vaddl/vsubl/vabdl{e,t} can only be vadd/vsub/vabd\n+\t in an IT block with le/lt conditions.  */\n+\n+      if (inst.cond == 0xf)\n+\tinst.cond = 0xb;\n+      else if (inst.cond == 0x10)\n+\tinst.cond = 0xd;\n+\n+      inst.pred_insn_type = INSIDE_IT_INSN;\n+\n+      if (inst.instruction == N_MNEM_vaddl)\n+\t{\n+\t  inst.instruction = N_MNEM_vadd;\n+\t  do_neon_addsub_if_i ();\n+\t}\n+      else if (inst.instruction == N_MNEM_vsubl)\n+\t{\n+\t  inst.instruction = N_MNEM_vsub;\n+\t  do_neon_addsub_if_i ();\n+\t}\n+      else if (inst.instruction == N_MNEM_vabdl)\n+\t{\n+\t  inst.instruction = N_MNEM_vabd;\n+\t  do_neon_dyadic_if_su ();\n+\t}\n+    }\n+  else\n+    first_error (BAD_FPU);\n }\n \n static void\n@@ -17860,7 +18104,7 @@ do_vfp_nsyn_fpv8 (enum neon_shape rs)\n static void\n do_vsel (void)\n {\n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n \n   if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) != SUCCESS)\n     first_error (_(\"invalid instruction shape\"));\n@@ -17869,7 +18113,7 @@ do_vsel (void)\n static void\n do_vmaxnm (void)\n {\n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n \n   if (try_vfp_nsyn (3, do_vfp_nsyn_fpv8) == SUCCESS)\n     return;\n@@ -17902,7 +18146,7 @@ do_vrint_1 (enum neon_cvt_mode mode)\n       /* VFP encodings.  */\n       if (mode == neon_cvt_mode_a || mode == neon_cvt_mode_n\n \t  || mode == neon_cvt_mode_p || mode == neon_cvt_mode_m)\n-\tset_it_insn_type (OUTSIDE_IT_INSN);\n+\tset_pred_insn_type (OUTSIDE_PRED_INSN);\n \n       NEON_ENCODE (FPV8, inst);\n       if (rs == NS_FF || rs == NS_HH)\n@@ -17938,7 +18182,7 @@ do_vrint_1 (enum neon_cvt_mode mode)\n       if (et.type == NT_invtype)\n \treturn;\n \n-      set_it_insn_type (OUTSIDE_IT_INSN);\n+      set_pred_insn_type (OUTSIDE_PRED_INSN);\n       NEON_ENCODE (FLOAT, inst);\n \n       if (vfp_or_neon_is_neon (NEON_CHECK_CC | NEON_CHECK_ARCH8) == FAIL)\n@@ -18167,7 +18411,7 @@ do_neon_dotproduct_u (void)\n static void\n do_crypto_2op_1 (unsigned elttype, int op)\n {\n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n \n   if (neon_check_type (2, NS_QQ, N_EQK | N_UNT, elttype | N_UNT | N_KEY).type\n       == NT_invtype)\n@@ -18192,7 +18436,7 @@ do_crypto_2op_1 (unsigned elttype, int op)\n static void\n do_crypto_3op_1 (int u, int op)\n {\n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n \n   if (neon_check_type (3, NS_QQQ, N_EQK | N_UNT, N_EQK | N_UNT,\n \t\t       N_32 | N_UNT | N_KEY).type == NT_invtype)\n@@ -18295,7 +18539,7 @@ do_crc32_1 (unsigned int poly, unsigned int sz)\n   unsigned int Rn = inst.operands[1].reg;\n   unsigned int Rm = inst.operands[2].reg;\n \n-  set_it_insn_type (OUTSIDE_IT_INSN);\n+  set_pred_insn_type (OUTSIDE_PRED_INSN);\n   inst.instruction |= LOW4 (Rd) << (thumb_mode ? 8 : 12);\n   inst.instruction |= LOW4 (Rn) << 16;\n   inst.instruction |= LOW4 (Rm);\n@@ -18537,9 +18781,10 @@ enum opcode_tag\n   OT_unconditionalF,\t/* Instruction cannot be conditionalized\n \t\t\t   and carries 0xF in its ARM condition field.  */\n   OT_csuffix,\t\t/* Instruction takes a conditional suffix.  */\n-  OT_csuffixF,\t\t/* Some forms of the instruction take a conditional\n-\t\t\t   suffix, others place 0xF where the condition field\n-\t\t\t   would be.  */\n+  OT_csuffixF,\t\t/* Some forms of the instruction take a scalar\n+\t\t\t   conditional suffix, others place 0xF where the\n+\t\t\t   condition field would be, others take a vector\n+\t\t\t   conditional suffix.  */\n   OT_cinfix3,\t\t/* Instruction takes a conditional infix,\n \t\t\t   beginning at character index 3.  (In\n \t\t\t   unified mode, it becomes a suffix.)  */\n@@ -18685,17 +18930,35 @@ opcode_lookup (char **str)\n       inst.cond = cond->value;\n       return opcode;\n     }\n+ if (ARM_CPU_HAS_FEATURE (cpu_variant, mve_ext))\n+   {\n+    /* Cannot have a conditional suffix on a mnemonic of less than a character.\n+     */\n+    if (end - base < 2)\n+      return NULL;\n+     affix = end - 1;\n+     cond = (const struct asm_cond *) hash_find_n (arm_vcond_hsh, affix, 1);\n+     opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,\n+\t\t\t\t\t\t      affix - base);\n+     /* If this opcode can not be vector predicated then don't accept it with a\n+\tvector predication code.  */\n+     if (opcode && !opcode->mayBeVecPred)\n+       opcode = NULL;\n+   }\n+  if (!opcode || !cond)\n+    {\n+      /* Cannot have a conditional suffix on a mnemonic of less than two\n+\t characters.  */\n+      if (end - base < 3)\n+\treturn NULL;\n \n-  /* Cannot have a conditional suffix on a mnemonic of less than two\n-     characters.  */\n-  if (end - base < 3)\n-    return NULL;\n+      /* Look for suffixed mnemonic.  */\n+      affix = end - 2;\n+      cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);\n+      opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,\n+\t\t\t\t\t\t\taffix - base);\n+    }\n \n-  /* Look for suffixed mnemonic.  */\n-  affix = end - 2;\n-  cond = (const struct asm_cond *) hash_find_n (arm_cond_hsh, affix, 2);\n-  opcode = (const struct asm_opcode *) hash_find_n (arm_ops_hsh, base,\n-\t\t\t\t\t\t    affix - base);\n   if (opcode && cond)\n     {\n       /* step CE */\n@@ -18774,7 +19037,7 @@ opcode_lookup (char **str)\n \n /* This function generates an initial IT instruction, leaving its block\n    virtually open for the new instructions. Eventually,\n-   the mask will be updated by now_it_add_mask () each time\n+   the mask will be updated by now_pred_add_mask () each time\n    a new instruction needs to be included in the IT block.\n    Finally, the block is closed with close_automatic_it_block ().\n    The block closure can be requested either from md_assemble (),\n@@ -18783,14 +19046,14 @@ opcode_lookup (char **str)\n static void\n new_automatic_it_block (int cond)\n {\n-  now_it.state = AUTOMATIC_IT_BLOCK;\n-  now_it.mask = 0x18;\n-  now_it.cc = cond;\n-  now_it.block_length = 1;\n+  now_pred.state = AUTOMATIC_PRED_BLOCK;\n+  now_pred.mask = 0x18;\n+  now_pred.cc = cond;\n+  now_pred.block_length = 1;\n   mapping_state (MAP_THUMB);\n-  now_it.insn = output_it_inst (cond, now_it.mask, NULL);\n-  now_it.warn_deprecated = FALSE;\n-  now_it.insn_cond = TRUE;\n+  now_pred.insn = output_it_inst (cond, now_pred.mask, NULL);\n+  now_pred.warn_deprecated = FALSE;\n+  now_pred.insn_cond = TRUE;\n }\n \n /* Close an automatic IT block.\n@@ -18799,39 +19062,39 @@ new_automatic_it_block (int cond)\n static void\n close_automatic_it_block (void)\n {\n-  now_it.mask = 0x10;\n-  now_it.block_length = 0;\n+  now_pred.mask = 0x10;\n+  now_pred.block_length = 0;\n }\n \n /* Update the mask of the current automatically-generated IT\n    instruction. See comments in new_automatic_it_block ().  */\n \n static void\n-now_it_add_mask (int cond)\n+now_pred_add_mask (int cond)\n {\n #define CLEAR_BIT(value, nbit)  ((value) & ~(1 << (nbit)))\n #define SET_BIT_VALUE(value, bitvalue, nbit)  (CLEAR_BIT (value, nbit) \\\n \t\t\t\t\t      | ((bitvalue) << (nbit)))\n   const int resulting_bit = (cond & 1);\n \n-  now_it.mask &= 0xf;\n-  now_it.mask = SET_BIT_VALUE (now_it.mask,\n+  now_pred.mask &= 0xf;\n+  now_pred.mask = SET_BIT_VALUE (now_pred.mask,\n \t\t\t\t   resulting_bit,\n-\t\t\t\t  (5 - now_it.block_length));\n-  now_it.mask = SET_BIT_VALUE (now_it.mask,\n+\t\t\t\t  (5 - now_pred.block_length));\n+  now_pred.mask = SET_BIT_VALUE (now_pred.mask,\n \t\t\t\t   1,\n-\t\t\t\t   ((5 - now_it.block_length) - 1) );\n-  output_it_inst (now_it.cc, now_it.mask, now_it.insn);\n+\t\t\t\t   ((5 - now_pred.block_length) - 1));\n+  output_it_inst (now_pred.cc, now_pred.mask, now_pred.insn);\n \n #undef CLEAR_BIT\n #undef SET_BIT_VALUE\n }\n \n /* The IT blocks handling machinery is accessed through the these functions:\n      it_fsm_pre_encode ()               from md_assemble ()\n-     set_it_insn_type ()                optional, from the tencode functions\n-     set_it_insn_type_last ()           ditto\n-     in_it_block ()                     ditto\n+     set_pred_insn_type ()\t\toptional, from the tencode functions\n+     set_pred_insn_type_last ()\t\tditto\n+     in_pred_block ()\t\t\tditto\n      it_fsm_post_encode ()              from md_assemble ()\n      force_automatic_it_block_close ()  from label handling functions\n \n@@ -18841,195 +19104,401 @@ now_it_add_mask (int cond)\n \ton the inst.condition.\n      2) During the tencode function, two things may happen:\n \ta) The tencode function overrides the IT insn type by\n-\t   calling either set_it_insn_type (type) or set_it_insn_type_last ().\n+\t   calling either set_pred_insn_type (type) or\n+\t   set_pred_insn_type_last ().\n \tb) The tencode function queries the IT block state by\n-\t   calling in_it_block () (i.e. to determine narrow/not narrow mode).\n+\t   calling in_pred_block () (i.e. to determine narrow/not narrow mode).\n \n-\tBoth set_it_insn_type and in_it_block run the internal FSM state\n-\thandling function (handle_it_state), because: a) setting the IT insn\n+\tBoth set_pred_insn_type and in_pred_block run the internal FSM state\n+\thandling function (handle_pred_state), because: a) setting the IT insn\n \ttype may incur in an invalid state (exiting the function),\n \tand b) querying the state requires the FSM to be updated.\n \tSpecifically we want to avoid creating an IT block for conditional\n \tbranches, so it_fsm_pre_encode is actually a guess and we can't\n \tdetermine whether an IT block is required until the tencode () routine\n \thas decided what type of instruction this actually it.\n-\tBecause of this, if set_it_insn_type and in_it_block have to be used,\n-\tset_it_insn_type has to be called first.\n+\tBecause of this, if set_pred_insn_type and in_pred_block have to be\n+\tused, set_pred_insn_type has to be called first.\n \n-\tset_it_insn_type_last () is a wrapper of set_it_insn_type (type), that\n-\tdetermines the insn IT type depending on the inst.cond code.\n+\tset_pred_insn_type_last () is a wrapper of set_pred_insn_type (type),\n+\tthat determines the insn IT type depending on the inst.cond code.\n \tWhen a tencode () routine encodes an instruction that can be\n \teither outside an IT block, or, in the case of being inside, has to be\n-\tthe last one, set_it_insn_type_last () will determine the proper\n+\tthe last one, set_pred_insn_type_last () will determine the proper\n \tIT instruction type based on the inst.cond code. Otherwise,\n-\tset_it_insn_type can be called for overriding that logic or\n+\tset_pred_insn_type can be called for overriding that logic or\n \tfor covering other cases.\n \n-\tCalling handle_it_state () may not transition the IT block state to\n-\tOUTSIDE_IT_BLOCK immediately, since the (current) state could be\n+\tCalling handle_pred_state () may not transition the IT block state to\n+\tOUTSIDE_PRED_BLOCK immediately, since the (current) state could be\n \tstill queried. Instead, if the FSM determines that the state should\n-\tbe transitioned to OUTSIDE_IT_BLOCK, a flag is marked to be closed\n+\tbe transitioned to OUTSIDE_PRED_BLOCK, a flag is marked to be closed\n \tafter the tencode () function: that's what it_fsm_post_encode () does.\n \n-\tSince in_it_block () calls the state handling function to get an\n+\tSince in_pred_block () calls the state handling function to get an\n \tupdated state, an error may occur (due to invalid insns combination).\n \tIn that case, inst.error is set.\n \tTherefore, inst.error has to be checked after the execution of\n \tthe tencode () routine.\n \n      3) Back in md_assemble(), it_fsm_post_encode () is called to commit\n \tany pending state change (if any) that didn't take place in\n-\thandle_it_state () as explained above.  */\n+\thandle_pred_state () as explained above.  */\n \n static void\n it_fsm_pre_encode (void)\n {\n   if (inst.cond != COND_ALWAYS)\n-    inst.it_insn_type = INSIDE_IT_INSN;\n+    inst.pred_insn_type =  INSIDE_IT_INSN;\n   else\n-    inst.it_insn_type = OUTSIDE_IT_INSN;\n+    inst.pred_insn_type = OUTSIDE_PRED_INSN;\n \n-  now_it.state_handled = 0;\n+  now_pred.state_handled = 0;\n }\n \n /* IT state FSM handling function.  */\n+/* MVE instructions and non-MVE instructions are handled differently because of\n+   the introduction of VPT blocks.\n+   Specifications say that any non-MVE instruction inside a VPT block is\n+   UNPREDICTABLE, with the exception of the BKPT instruction.  Whereas most MVE\n+   instructions are deemed to be UNPREDICTABLE if inside an IT block.  For the\n+   few exceptions this will be handled at their respective handler functions.\n+   The error messages provided depending on the different combinations possible\n+   are described in the cases below:\n+   For 'most' MVE instructions:\n+   1) In an IT block, with an IT code: syntax error\n+   2) In an IT block, with a VPT code: error: must be in a VPT block\n+   3) In an IT block, with no code: warning: UNPREDICTABLE\n+   4) In a VPT block, with an IT code: syntax error\n+   5) In a VPT block, with a VPT code: OK!\n+   6) In a VPT block, with no code: error: missing code\n+   7) Outside a pred block, with an IT code: error: syntax error\n+   8) Outside a pred block, with a VPT code: error: should be in a VPT block\n+   9) Outside a pred block, with no code: OK!\n+   For non-MVE instructions:\n+   10) In an IT block, with an IT code: OK!\n+   11) In an IT block, with a VPT code: syntax error\n+   12) In an IT block, with no code: error: missing code\n+   13) In a VPT block, with an IT code: error: should be in an IT block\n+   14) In a VPT block, with a VPT code: syntax error\n+   15) In a VPT block, with no code: UNPREDICTABLE\n+   16) Outside a pred block, with an IT code: error: should be in an IT block\n+   17) Outside a pred block, with a VPT code: syntax error\n+   18) Outside a pred block, with no code: OK!\n+ */\n+\n \n static int\n-handle_it_state (void)\n+handle_pred_state (void)\n {\n-  now_it.state_handled = 1;\n-  now_it.insn_cond = FALSE;\n+  now_pred.state_handled = 1;\n+  now_pred.insn_cond = FALSE;\n \n-  switch (now_it.state)\n+  switch (now_pred.state)\n     {\n-    case OUTSIDE_IT_BLOCK:\n-      switch (inst.it_insn_type)\n+    case OUTSIDE_PRED_BLOCK:\n+      switch (inst.pred_insn_type)\n \t{\n-\tcase OUTSIDE_IT_INSN:\n+\tcase MVE_OUTSIDE_PRED_INSN:\n+\t  if (inst.cond < COND_ALWAYS)\n+\t    {\n+\t      /* Case 7: Outside a pred block, with an IT code: error: syntax\n+\t\t error.  */\n+\t      inst.error = BAD_SYNTAX;\n+\t      return FAIL;\n+\t    }\n+\t  /* Case 9:  Outside a pred block, with no code: OK!  */\n+\t  break;\n+\tcase OUTSIDE_PRED_INSN:\n+\t  if (inst.cond > COND_ALWAYS)\n+\t    {\n+\t      /* Case 17:  Outside a pred block, with a VPT code: syntax error.\n+\t       */\n+\t      inst.error = BAD_SYNTAX;\n+\t      return FAIL;\n+\t    }\n+\t  /* Case 18: Outside a pred block, with no code: OK!  */\n \t  break;\n \n+\tcase INSIDE_VPT_INSN:\n+\t  /* Case 8: Outside a pred block, with a VPT code: error: should be in\n+\t     a VPT block.  */\n+\t  inst.error = BAD_OUT_VPT;\n+\t  return FAIL;\n+\n \tcase INSIDE_IT_INSN:\n \tcase INSIDE_IT_LAST_INSN:\n-\t  if (thumb_mode == 0)\n-\t    {\n-\t      if (unified_syntax\n-\t\t  && !(implicit_it_mode & IMPLICIT_IT_MODE_ARM))\n-\t\tas_tsktsk (_(\"Warning: conditional outside an IT block\"\\\n-\t\t\t     \" for Thumb.\"));\n-\t    }\n-\t  else\n+\t  if (inst.cond < COND_ALWAYS)\n \t    {\n-\t      if ((implicit_it_mode & IMPLICIT_IT_MODE_THUMB)\n-\t\t  && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6t2))\n+\t      /* Case 16: Outside a pred block, with an IT code: error: should\n+\t\t be in an IT block.  */\n+\t      if (thumb_mode == 0)\n \t\t{\n-\t\t  /* Automatically generate the IT instruction.  */\n-\t\t  new_automatic_it_block (inst.cond);\n-\t\t  if (inst.it_insn_type == INSIDE_IT_LAST_INSN)\n-\t\t    close_automatic_it_block ();\n+\t\t  if (unified_syntax\n+\t\t      && !(implicit_it_mode & IMPLICIT_IT_MODE_ARM))\n+\t\t    as_tsktsk (_(\"Warning: conditional outside an IT block\"\\\n+\t\t\t\t \" for Thumb.\"));\n \t\t}\n \t      else\n \t\t{\n-\t\t  inst.error = BAD_OUT_IT;\n-\t\t  return FAIL;\n+\t\t  if ((implicit_it_mode & IMPLICIT_IT_MODE_THUMB)\n+\t\t      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6t2))\n+\t\t    {\n+\t\t      /* Automatically generate the IT instruction.  */\n+\t\t      new_automatic_it_block (inst.cond);\n+\t\t      if (inst.pred_insn_type == INSIDE_IT_LAST_INSN)\n+\t\t\tclose_automatic_it_block ();\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      inst.error = BAD_OUT_IT;\n+\t\t      return FAIL;\n+\t\t    }\n \t\t}\n+\t      break;\n \t    }\n-\t  break;\n-\n+\t  else if (inst.cond > COND_ALWAYS)\n+\t    {\n+\t      /* Case 17: Outside a pred block, with a VPT code: syntax error.\n+\t       */\n+\t      inst.error = BAD_SYNTAX;\n+\t      return FAIL;\n+\t    }\n+\t  else\n+\t    gas_assert (0);\n \tcase IF_INSIDE_IT_LAST_INSN:\n \tcase NEUTRAL_IT_INSN:\n \t  break;\n \n+\tcase VPT_INSN:\n+\t  if (inst.cond != COND_ALWAYS)\n+\t    first_error (BAD_SYNTAX);\n+\t  now_pred.state = MANUAL_PRED_BLOCK;\n+\t  now_pred.block_length = 0;\n+\t  now_pred.type = VECTOR_PRED;\n+\t  now_pred.cc = 0;\n+\t  break;\n \tcase IT_INSN:\n-\t  now_it.state = MANUAL_IT_BLOCK;\n-\t  now_it.block_length = 0;\n+\t  now_pred.state = MANUAL_PRED_BLOCK;\n+\t  now_pred.block_length = 0;\n+\t  now_pred.type = SCALAR_PRED;\n \t  break;\n \t}\n       break;\n \n-    case AUTOMATIC_IT_BLOCK:\n+    case AUTOMATIC_PRED_BLOCK:\n       /* Three things may happen now:\n \t a) We should increment current it block size;\n \t b) We should close current it block (closing insn or 4 insns);\n \t c) We should close current it block and start a new one (due\n \t to incompatible conditions or\n \t 4 insns-length block reached).  */\n \n-      switch (inst.it_insn_type)\n+      switch (inst.pred_insn_type)\n \t{\n-\tcase OUTSIDE_IT_INSN:\n+\tcase INSIDE_VPT_INSN:\n+\tcase VPT_INSN:\n+\tcase MVE_OUTSIDE_PRED_INSN:\n+\t  gas_assert (0);\n+\tcase OUTSIDE_PRED_INSN:\n \t  /* The closure of the block shall happen immediately,\n-\t     so any in_it_block () call reports the block as closed.  */\n+\t     so any in_pred_block () call reports the block as closed.  */\n \t  force_automatic_it_block_close ();\n \t  break;\n \n \tcase INSIDE_IT_INSN:\n \tcase INSIDE_IT_LAST_INSN:\n \tcase IF_INSIDE_IT_LAST_INSN:\n-\t  now_it.block_length++;\n+\t  now_pred.block_length++;\n \n-\t  if (now_it.block_length > 4\n-\t      || !now_it_compatible (inst.cond))\n+\t  if (now_pred.block_length > 4\n+\t      || !now_pred_compatible (inst.cond))\n \t    {\n \t      force_automatic_it_block_close ();\n-\t      if (inst.it_insn_type != IF_INSIDE_IT_LAST_INSN)\n+\t      if (inst.pred_insn_type != IF_INSIDE_IT_LAST_INSN)\n \t\tnew_automatic_it_block (inst.cond);\n \t    }\n \t  else\n \t    {\n-\t      now_it.insn_cond = TRUE;\n-\t      now_it_add_mask (inst.cond);\n+\t      now_pred.insn_cond = TRUE;\n+\t      now_pred_add_mask (inst.cond);\n \t    }\n \n-\t  if (now_it.state == AUTOMATIC_IT_BLOCK\n-\t      && (inst.it_insn_type == INSIDE_IT_LAST_INSN\n-\t\t  || inst.it_insn_type == IF_INSIDE_IT_LAST_INSN))\n+\t  if (now_pred.state == AUTOMATIC_PRED_BLOCK\n+\t      && (inst.pred_insn_type == INSIDE_IT_LAST_INSN\n+\t\t  || inst.pred_insn_type == IF_INSIDE_IT_LAST_INSN))\n \t    close_automatic_it_block ();\n \t  break;\n \n \tcase NEUTRAL_IT_INSN:\n-\t  now_it.block_length++;\n-\t  now_it.insn_cond = TRUE;\n+\t  now_pred.block_length++;\n+\t  now_pred.insn_cond = TRUE;\n \n-\t  if (now_it.block_length > 4)\n+\t  if (now_pred.block_length > 4)\n \t    force_automatic_it_block_close ();\n \t  else\n-\t    now_it_add_mask (now_it.cc & 1);\n+\t    now_pred_add_mask (now_pred.cc & 1);\n \t  break;\n \n \tcase IT_INSN:\n \t  close_automatic_it_block ();\n-\t  now_it.state = MANUAL_IT_BLOCK;\n+\t  now_pred.state = MANUAL_PRED_BLOCK;\n \t  break;\n \t}\n       break;\n \n-    case MANUAL_IT_BLOCK:\n+    case MANUAL_PRED_BLOCK:\n       {\n-\t/* Check conditional suffixes.  */\n-\tconst int cond = now_it.cc ^ ((now_it.mask >> 4) & 1) ^ 1;\n-\tint is_last;\n-\tnow_it.mask <<= 1;\n-\tnow_it.mask &= 0x1f;\n-\tis_last = (now_it.mask == 0x10);\n-\tnow_it.insn_cond = TRUE;\n-\n-\tswitch (inst.it_insn_type)\n+\tint cond, is_last;\n+\tif (now_pred.type == SCALAR_PRED)\n \t  {\n-\t  case OUTSIDE_IT_INSN:\n-\t    inst.error = BAD_NOT_IT;\n-\t    return FAIL;\n+\t    /* Check conditional suffixes.  */\n+\t    cond = now_pred.cc ^ ((now_pred.mask >> 4) & 1) ^ 1;\n+\t    now_pred.mask <<= 1;\n+\t    now_pred.mask &= 0x1f;\n+\t    is_last = (now_pred.mask == 0x10);\n+\t  }\n+\telse\n+\t  {\n+\t    now_pred.cc ^= (now_pred.mask >> 4);\n+\t    cond = now_pred.cc + 0xf;\n+\t    now_pred.mask <<= 1;\n+\t    now_pred.mask &= 0x1f;\n+\t    is_last = now_pred.mask == 0x10;\n+\t  }\n+\tnow_pred.insn_cond = TRUE;\n \n+\tswitch (inst.pred_insn_type)\n+\t  {\n+\t  case OUTSIDE_PRED_INSN:\n+\t    if (now_pred.type == SCALAR_PRED)\n+\t      {\n+\t\tif (inst.cond == COND_ALWAYS)\n+\t\t  {\n+\t\t    /* Case 12: In an IT block, with no code: error: missing\n+\t\t       code.  */\n+\t\t    inst.error = BAD_NOT_IT;\n+\t\t    return FAIL;\n+\t\t  }\n+\t\telse if (inst.cond > COND_ALWAYS)\n+\t\t  {\n+\t\t    /* Case 11: In an IT block, with a VPT code: syntax error.\n+\t\t     */\n+\t\t    inst.error = BAD_SYNTAX;\n+\t\t    return FAIL;\n+\t\t  }\n+\t\telse if (thumb_mode)\n+\t\t  {\n+\t\t    /* This is for some special cases where a non-MVE\n+\t\t       instruction is not allowed in an IT block, such as cbz,\n+\t\t       but are put into one with a condition code.\n+\t\t       You could argue this should be a syntax error, but we\n+\t\t       gave the 'not allowed in IT block' diagnostic in the\n+\t\t       past so we will keep doing so.  */\n+\t\t    inst.error = BAD_NOT_IT;\n+\t\t    return FAIL;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Case 15: In a VPT block, with no code: UNPREDICTABLE.  */\n+\t\tas_tsktsk (MVE_NOT_VPT);\n+\t\treturn SUCCESS;\n+\t      }\n+\t  case MVE_OUTSIDE_PRED_INSN:\n+\t    if (now_pred.type == SCALAR_PRED)\n+\t      {\n+\t\tif (inst.cond == COND_ALWAYS)\n+\t\t  {\n+\t\t    /* Case 3: In an IT block, with no code: warning:\n+\t\t       UNPREDICTABLE.  */\n+\t\t    as_tsktsk (MVE_NOT_IT);\n+\t\t    return SUCCESS;\n+\t\t  }\n+\t\telse if (inst.cond < COND_ALWAYS)\n+\t\t  {\n+\t\t    /* Case 1: In an IT block, with an IT code: syntax error.\n+\t\t     */\n+\t\t    inst.error = BAD_SYNTAX;\n+\t\t    return FAIL;\n+\t\t  }\n+\t\telse\n+\t\t  gas_assert (0);\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (inst.cond < COND_ALWAYS)\n+\t\t  {\n+\t\t    /* Case 4: In a VPT block, with an IT code: syntax error.\n+\t\t     */\n+\t\t    inst.error = BAD_SYNTAX;\n+\t\t    return FAIL;\n+\t\t  }\n+\t\telse if (inst.cond == COND_ALWAYS)\n+\t\t  {\n+\t\t    /* Case 6: In a VPT block, with no code: error: missing\n+\t\t       code.  */\n+\t\t    inst.error = BAD_NOT_VPT;\n+\t\t    return FAIL;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    gas_assert (0);\n+\t\t  }\n+\t      }\n \t  case INSIDE_IT_INSN:\n-\t    if (cond != inst.cond)\n+\t    if (inst.cond > COND_ALWAYS)\n \t      {\n-\t\tinst.error = BAD_IT_COND;\n+\t\t/* Case 11: In an IT block, with a VPT code: syntax error.  */\n+\t\t/* Case 14: In a VPT block, with a VPT code: syntax error.  */\n+\t\tinst.error = BAD_SYNTAX;\n+\t\treturn FAIL;\n+\t      }\n+\t    else if (now_pred.type == SCALAR_PRED)\n+\t      {\n+\t\t/* Case 10: In an IT block, with an IT code: OK!  */\n+\t\tif (cond != inst.cond)\n+\t\t  {\n+\t\t    inst.error = now_pred.type == SCALAR_PRED ? BAD_IT_COND :\n+\t\t      BAD_VPT_COND;\n+\t\t    return FAIL;\n+\t\t  }\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* Case 13: In a VPT block, with an IT code: error: should be\n+\t\t   in an IT block.  */\n+\t\tinst.error = BAD_OUT_IT;\n \t\treturn FAIL;\n \t      }\n \t    break;\n \n+\t  case INSIDE_VPT_INSN:\n+\t    if (now_pred.type == SCALAR_PRED)\n+\t      {\n+\t\t/* Case 2: In an IT block, with a VPT code: error: must be in a\n+\t\t   VPT block.  */\n+\t\tinst.error = BAD_OUT_VPT;\n+\t\treturn FAIL;\n+\t      }\n+\t    /* Case 5:  In a VPT block, with a VPT code: OK!  */\n+\t    else if (cond != inst.cond)\n+\t      {\n+\t\tinst.error = BAD_VPT_COND;\n+\t\treturn FAIL;\n+\t      }\n+\t    break;\n \t  case INSIDE_IT_LAST_INSN:\n \t  case IF_INSIDE_IT_LAST_INSN:\n-\t    if (cond != inst.cond)\n+\t    if (now_pred.type == VECTOR_PRED || inst.cond > COND_ALWAYS)\n+\t      {\n+\t\t/* Case 4: In a VPT block, with an IT code: syntax error.  */\n+\t\t/* Case 11: In an IT block, with a VPT code: syntax error.  */\n+\t\tinst.error = BAD_SYNTAX;\n+\t\treturn FAIL;\n+\t      }\n+\t    else if (cond != inst.cond)\n \t      {\n \t\tinst.error = BAD_IT_COND;\n \t\treturn FAIL;\n@@ -19042,14 +19511,37 @@ handle_it_state (void)\n \t    break;\n \n \t  case NEUTRAL_IT_INSN:\n-\t    /* The BKPT instruction is unconditional even in an IT block.  */\n+\t    /* The BKPT instruction is unconditional even in a IT or VPT\n+\t       block.  */\n \t    break;\n \n \t  case IT_INSN:\n-\t    inst.error = BAD_IT_IT;\n-\t    return FAIL;\n+\t    if (now_pred.type == SCALAR_PRED)\n+\t      {\n+\t\tinst.error = BAD_IT_IT;\n+\t\treturn FAIL;\n+\t      }\n+\t    /* fall through.  */\n+\t  case VPT_INSN:\n+\t    if (inst.cond == COND_ALWAYS)\n+\t      {\n+\t\t/* Executing a VPT/VPST instruction inside an IT block or a\n+\t\t   VPT/VPST/IT instruction inside a VPT block is UNPREDICTABLE.\n+\t\t */\n+\t\tif (now_pred.type == SCALAR_PRED)\n+\t\t  as_tsktsk (MVE_NOT_IT);\n+\t\telse\n+\t\t  as_tsktsk (MVE_NOT_VPT);\n+\t\treturn SUCCESS;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* VPT/VPST do not accept condition codes.  */\n+\t\tinst.error = BAD_SYNTAX;\n+\t\treturn FAIL;\n+\t      }\n \t  }\n-      }\n+\t}\n       break;\n     }\n \n@@ -19083,11 +19575,11 @@ it_fsm_post_encode (void)\n {\n   int is_last;\n \n-  if (!now_it.state_handled)\n-    handle_it_state ();\n+  if (!now_pred.state_handled)\n+    handle_pred_state ();\n \n-  if (now_it.insn_cond\n-      && !now_it.warn_deprecated\n+  if (now_pred.insn_cond\n+      && !now_pred.warn_deprecated\n       && warn_on_deprecated\n       && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v8)\n       && !ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_m))\n@@ -19096,7 +19588,7 @@ it_fsm_post_encode (void)\n \t{\n \t  as_tsktsk (_(\"IT blocks containing 32-bit Thumb instructions are \"\n \t\t     \"performance deprecated in ARMv8-A and ARMv8-R\"));\n-\t  now_it.warn_deprecated = TRUE;\n+\t  now_pred.warn_deprecated = TRUE;\n \t}\n       else\n \t{\n@@ -19110,49 +19602,49 @@ it_fsm_post_encode (void)\n \t\t\t       \"instructions of the following class are \"\n \t\t\t       \"performance deprecated in ARMv8-A and \"\n \t\t\t       \"ARMv8-R: %s\"), p->description);\n-\t\t  now_it.warn_deprecated = TRUE;\n+\t\t  now_pred.warn_deprecated = TRUE;\n \t\t  break;\n \t\t}\n \n \t      ++p;\n \t    }\n \t}\n \n-      if (now_it.block_length > 1)\n+      if (now_pred.block_length > 1)\n \t{\n \t  as_tsktsk (_(\"IT blocks containing more than one conditional \"\n \t\t     \"instruction are performance deprecated in ARMv8-A and \"\n \t\t     \"ARMv8-R\"));\n-\t  now_it.warn_deprecated = TRUE;\n+\t  now_pred.warn_deprecated = TRUE;\n \t}\n     }\n \n-  is_last = (now_it.mask == 0x10);\n-  if (is_last)\n-    {\n-      now_it.state = OUTSIDE_IT_BLOCK;\n-      now_it.mask = 0;\n-    }\n+    is_last = (now_pred.mask == 0x10);\n+    if (is_last)\n+      {\n+\tnow_pred.state = OUTSIDE_PRED_BLOCK;\n+\tnow_pred.mask = 0;\n+      }\n }\n \n static void\n force_automatic_it_block_close (void)\n {\n-  if (now_it.state == AUTOMATIC_IT_BLOCK)\n+  if (now_pred.state == AUTOMATIC_PRED_BLOCK)\n     {\n       close_automatic_it_block ();\n-      now_it.state = OUTSIDE_IT_BLOCK;\n-      now_it.mask = 0;\n+      now_pred.state = OUTSIDE_PRED_BLOCK;\n+      now_pred.mask = 0;\n     }\n }\n \n static int\n-in_it_block (void)\n+in_pred_block (void)\n {\n-  if (!now_it.state_handled)\n-    handle_it_state ();\n+  if (!now_pred.state_handled)\n+    handle_pred_state ();\n \n-  return now_it.state != OUTSIDE_IT_BLOCK;\n+  return now_pred.state != OUTSIDE_PRED_BLOCK;\n }\n \n /* Whether OPCODE only has T32 encoding.  Since this function is only used by\n@@ -19305,7 +19797,7 @@ md_assemble (char *str)\n \n       if (!parse_operands (p, opcode->operands, /*thumb=*/TRUE))\n \t{\n-\t  /* Prepare the it_insn_type for those encodings that don't set\n+\t  /* Prepare the pred_insn_type for those encodings that don't set\n \t     it.  */\n \t  it_fsm_pre_encode ();\n \n@@ -19408,21 +19900,30 @@ md_assemble (char *str)\n }\n \n static void\n-check_it_blocks_finished (void)\n+check_pred_blocks_finished (void)\n {\n #ifdef OBJ_ELF\n   asection *sect;\n \n   for (sect = stdoutput->sections; sect != NULL; sect = sect->next)\n-    if (seg_info (sect)->tc_segment_info_data.current_it.state\n-\t== MANUAL_IT_BLOCK)\n+    if (seg_info (sect)->tc_segment_info_data.current_pred.state\n+\t== MANUAL_PRED_BLOCK)\n       {\n-\tas_warn (_(\"section '%s' finished with an open IT block.\"),\n-\t\t sect->name);\n+\tif (now_pred.type == SCALAR_PRED)\n+\t  as_warn (_(\"section '%s' finished with an open IT block.\"),\n+\t\t   sect->name);\n+\telse\n+\t  as_warn (_(\"section '%s' finished with an open VPT/VPST block.\"),\n+\t\t   sect->name);\n       }\n #else\n-  if (now_it.state == MANUAL_IT_BLOCK)\n-    as_warn (_(\"file finished with an open IT block.\"));\n+  if (now_pred.state == MANUAL_PRED_BLOCK)\n+    {\n+      if (now_pred.type == SCALAR_PRED)\n+       as_warn (_(\"file finished with an open IT block.\"));\n+      else\n+\tas_warn (_(\"file finished with an open VPT/VPST block.\"));\n+    }\n #endif\n }\n \n@@ -19824,7 +20325,7 @@ static struct reloc_entry reloc_names[] =\n };\n #endif\n \n-/* Table of all conditional affixes.  0xF is not defined as a condition code.  */\n+/* Table of all conditional affixes.  */\n static const struct asm_cond conds[] =\n {\n   {\"eq\", 0x0},\n@@ -19843,6 +20344,11 @@ static const struct asm_cond conds[] =\n   {\"le\", 0xd},\n   {\"al\", 0xe}\n };\n+static const struct asm_cond vconds[] =\n+{\n+    {\"t\", 0xf},\n+    {\"e\", 0x10}\n+};\n \n #define UL_BARRIER(L,U,CODE,FEAT) \\\n   { L, CODE, ARM_FEATURE_CORE_LOW (FEAT) }, \\\n@@ -19901,7 +20407,7 @@ static struct asm_barrier_opt barrier_opt_names[] =\n /* The normal sort of mnemonic; has a Thumb variant; takes a conditional suffix.  */\n #define TxCE(mnem, op, top, nops, ops, ae, te) \\\n   { mnem, OPS##nops ops, OT_csuffix, 0x##op, top, ARM_VARIANT, \\\n-    THUMB_VARIANT, do_##ae, do_##te }\n+    THUMB_VARIANT, do_##ae, do_##te, 0 }\n \n /* Two variants of the above - TCE for a numeric Thumb opcode, tCE for\n    a T_MNEM_xyz enumerator.  */\n@@ -19914,10 +20420,10 @@ static struct asm_barrier_opt barrier_opt_names[] =\n    infix after the third character.  */\n #define TxC3(mnem, op, top, nops, ops, ae, te) \\\n   { mnem, OPS##nops ops, OT_cinfix3, 0x##op, top, ARM_VARIANT, \\\n-    THUMB_VARIANT, do_##ae, do_##te }\n+    THUMB_VARIANT, do_##ae, do_##te, 0 }\n #define TxC3w(mnem, op, top, nops, ops, ae, te) \\\n   { mnem, OPS##nops ops, OT_cinfix3_deprecated, 0x##op, top, ARM_VARIANT, \\\n-    THUMB_VARIANT, do_##ae, do_##te }\n+    THUMB_VARIANT, do_##ae, do_##te, 0 }\n #define TC3(mnem, aop, top, nops, ops, ae, te) \\\n       TxC3 (mnem, aop, 0x##top, nops, ops, ae, te)\n #define TC3w(mnem, aop, top, nops, ops, ae, te) \\\n@@ -19932,74 +20438,74 @@ static struct asm_barrier_opt barrier_opt_names[] =\n    conditionally, so this is checked separately.  */\n #define TUE(mnem, op, top, nops, ops, ae, te)\t\t\t\t\\\n   { mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \\\n-    THUMB_VARIANT, do_##ae, do_##te }\n+    THUMB_VARIANT, do_##ae, do_##te, 0 }\n \n /* Same as TUE but the encoding function for ARM and Thumb modes is the same.\n    Used by mnemonics that have very minimal differences in the encoding for\n    ARM and Thumb variants and can be handled in a common function.  */\n #define TUEc(mnem, op, top, nops, ops, en) \\\n   { mnem, OPS##nops ops, OT_unconditional, 0x##op, 0x##top, ARM_VARIANT, \\\n-    THUMB_VARIANT, do_##en, do_##en }\n+    THUMB_VARIANT, do_##en, do_##en, 0 }\n \n /* Mnemonic that cannot be conditionalized, and bears 0xF in its ARM\n    condition code field.  */\n #define TUF(mnem, op, top, nops, ops, ae, te)\t\t\t\t\\\n   { mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##top, ARM_VARIANT, \\\n-    THUMB_VARIANT, do_##ae, do_##te }\n+    THUMB_VARIANT, do_##ae, do_##te, 0 }\n \n /* ARM-only variants of all the above.  */\n #define CE(mnem,  op, nops, ops, ae)\t\\\n-  { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }\n+  { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL, 0 }\n \n #define C3(mnem, op, nops, ops, ae)\t\\\n-  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }\n+  { #mnem, OPS##nops ops, OT_cinfix3, 0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL, 0 }\n \n /* Thumb-only variants of TCE and TUE.  */\n #define ToC(mnem, top, nops, ops, te) \\\n   { mnem, OPS##nops ops, OT_csuffix, 0x0, 0x##top, 0, THUMB_VARIANT, NULL, \\\n-    do_##te }\n+    do_##te, 0 }\n \n #define ToU(mnem, top, nops, ops, te) \\\n   { mnem, OPS##nops ops, OT_unconditional, 0x0, 0x##top, 0, THUMB_VARIANT, \\\n-    NULL, do_##te }\n+    NULL, do_##te, 0 }\n \n /* T_MNEM_xyz enumerator variants of ToC.  */\n #define toC(mnem, top, nops, ops, te) \\\n   { mnem, OPS##nops ops, OT_csuffix, 0x0, T_MNEM##top, 0, THUMB_VARIANT, NULL, \\\n-    do_##te }\n+    do_##te, 0 }\n \n /* T_MNEM_xyz enumerator variants of ToU.  */\n #define toU(mnem, top, nops, ops, te) \\\n   { mnem, OPS##nops ops, OT_unconditional, 0x0, T_MNEM##top, 0, THUMB_VARIANT, \\\n-    NULL, do_##te }\n+    NULL, do_##te, 0 }\n \n /* Legacy mnemonics that always have conditional infix after the third\n    character.  */\n #define CL(mnem, op, nops, ops, ae)\t\\\n   { mnem, OPS##nops ops, OT_cinfix3_legacy, \\\n-    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }\n+    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL, 0 }\n \n /* Coprocessor instructions.  Isomorphic between Arm and Thumb-2.  */\n #define cCE(mnem,  op, nops, ops, ae)\t\\\n-  { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }\n+  { mnem, OPS##nops ops, OT_csuffix, 0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae, 0 }\n \n /* Legacy coprocessor instructions where conditional infix and conditional\n    suffix are ambiguous.  For consistency this includes all FPA instructions,\n    not just the potentially ambiguous ones.  */\n #define cCL(mnem, op, nops, ops, ae)\t\\\n   { mnem, OPS##nops ops, OT_cinfix3_legacy, \\\n-    0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }\n+    0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae, 0 }\n \n /* Coprocessor, takes either a suffix or a position-3 infix\n    (for an FPA corner case). */\n #define C3E(mnem, op, nops, ops, ae) \\\n   { mnem, OPS##nops ops, OT_csuf_or_in3, \\\n-    0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae }\n+    0x##op, 0xe##op, ARM_VARIANT, ARM_VARIANT, do_##ae, do_##ae, 0 }\n \n #define xCM_(m1, m2, m3, op, nops, ops, ae)\t\\\n   { m1 #m2 m3, OPS##nops ops, \\\n     sizeof (#m2) == 1 ? OT_odd_infix_unc : OT_odd_infix_0 + sizeof (m1) - 1, \\\n-    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL }\n+    0x##op, 0x0, ARM_VARIANT, 0, do_##ae, NULL, 0 }\n \n #define CM(m1, m2, op, nops, ops, ae)\t\\\n   xCM_ (m1,   , m2, op, nops, ops, ae),\t\\\n@@ -20023,47 +20529,83 @@ static struct asm_barrier_opt barrier_opt_names[] =\n   xCM_ (m1, al, m2, op, nops, ops, ae)\n \n #define UE(mnem, op, nops, ops, ae)\t\\\n-  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }\n+  { #mnem, OPS##nops ops, OT_unconditional, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL, 0 }\n \n #define UF(mnem, op, nops, ops, ae)\t\\\n-  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL }\n+  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0, ARM_VARIANT, 0, do_##ae, NULL, 0 }\n \n /* Neon data-processing. ARM versions are unconditional with cond=0xf.\n    The Thumb and ARM variants are mostly the same (bits 0-23 and 24/28), so we\n    use the same encoding function for each.  */\n #define NUF(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n   { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##op,\t\t\\\n-    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }\n+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc, 0 }\n \n /* Neon data processing, version which indirects through neon_enc_tab for\n    the various overloaded versions of opcodes.  */\n #define nUF(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n   { #mnem, OPS##nops ops, OT_unconditionalF, N_MNEM##op, N_MNEM##op,\t\\\n-    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }\n+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc, 0 }\n \n /* Neon insn with conditional suffix for the ARM version, non-overloaded\n    version.  */\n-#define NCE_tag(mnem, op, nops, ops, enc, tag)\t\t\t\t\\\n+#define NCE_tag(mnem, op, nops, ops, enc, tag, mve_p)\t\t\t\t\\\n   { #mnem, OPS##nops ops, tag, 0x##op, 0x##op, ARM_VARIANT,\t\t\\\n-    THUMB_VARIANT, do_##enc, do_##enc }\n+    THUMB_VARIANT, do_##enc, do_##enc, mve_p }\n \n #define NCE(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n-   NCE_tag (mnem, op, nops, ops, enc, OT_csuffix)\n+   NCE_tag (mnem, op, nops, ops, enc, OT_csuffix, 0)\n \n #define NCEF(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n-    NCE_tag (mnem, op, nops, ops, enc, OT_csuffixF)\n+    NCE_tag (mnem, op, nops, ops, enc, OT_csuffixF, 0)\n \n /* Neon insn with conditional suffix for the ARM version, overloaded types.  */\n-#define nCE_tag(mnem, op, nops, ops, enc, tag)\t\t\t\t\\\n+#define nCE_tag(mnem, op, nops, ops, enc, tag, mve_p)\t\t\t\t\\\n   { #mnem, OPS##nops ops, tag, N_MNEM##op, N_MNEM##op,\t\t\\\n-    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc }\n+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc, mve_p }\n \n #define nCE(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n-   nCE_tag (mnem, op, nops, ops, enc, OT_csuffix)\n+   nCE_tag (mnem, op, nops, ops, enc, OT_csuffix, 0)\n \n #define nCEF(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n-    nCE_tag (mnem, op, nops, ops, enc, OT_csuffixF)\n+    nCE_tag (mnem, op, nops, ops, enc, OT_csuffixF, 0)\n+\n+/*   */\n+#define mCEF(mnem, op, nops, ops, enc)\t\t\t\t\\\n+  { #mnem, OPS##nops ops, OT_csuffixF, 0, M_MNEM##op,\t\t\\\n+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc, 1 }\n+\n+\n+/* nCEF but for MVE predicated instructions.  */\n+#define mnCEF(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n+    nCE_tag (mnem, op, nops, ops, enc, OT_csuffixF, 1)\n+\n+/* nCE but for MVE predicated instructions.  */\n+#define mnCE(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n+   nCE_tag (mnem, op, nops, ops, enc, OT_csuffix, 1)\n \n+/* NUF but for potentially MVE predicated instructions.  */\n+#define MNUF(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n+  { #mnem, OPS##nops ops, OT_unconditionalF, 0x##op, 0x##op,\t\t\\\n+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc, 1 }\n+\n+/* nUF but for potentially MVE predicated instructions.  */\n+#define mnUF(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n+  { #mnem, OPS##nops ops, OT_unconditionalF, N_MNEM##op, N_MNEM##op,\t\\\n+    ARM_VARIANT, THUMB_VARIANT, do_##enc, do_##enc, 1 }\n+\n+/* ToC but for potentially MVE predicated instructions.  */\n+#define mToC(mnem, top, nops, ops, te) \\\n+  { mnem, OPS##nops ops, OT_csuffix, 0x0, 0x##top, 0, THUMB_VARIANT, NULL, \\\n+    do_##te, 1 }\n+\n+/* NCE but for MVE predicated instructions.  */\n+#define MNCE(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n+   NCE_tag (mnem, op, nops, ops, enc, OT_csuffix, 1)\n+\n+/* NCEF but for MVE predicated instructions.  */\n+#define MNCEF(mnem, op, nops, ops, enc)\t\t\t\t\t\\\n+    NCE_tag (mnem, op, nops, ops, enc, OT_csuffixF, 1)\n #define do_0 0\n \n static const struct asm_opcode insns[] =\n@@ -21367,9 +21909,6 @@ static const struct asm_opcode insns[] =\n  nCEF(vmla,     _vmla,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),\n  nCEF(vmls,     _vmls,    3, (RNSDQ, oRNSDQ, RNSDQ_RNSC), neon_mac_maybe_scalar),\n \n- nCEF(vadd,     _vadd,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),\n- nCEF(vsub,     _vsub,    3, (RNSDQ, oRNSDQ, RNSDQ), neon_addsub_if_i),\n-\n  NCEF(vabs,     1b10300, 2, (RNSDQ, RNSDQ), neon_abs_neg),\n  NCEF(vneg,     1b10380, 2, (RNSDQ, RNSDQ), neon_abs_neg),\n \n@@ -21462,7 +22001,6 @@ static const struct asm_opcode insns[] =\n  NUF(vbif,      1300110, 3, (RNDQ, RNDQ, RNDQ), neon_bitfield),\n  NUF(vbifq,     1300110, 3, (RNQ,  RNQ,  RNQ),  neon_bitfield),\n   /* Int and float variants, types S8 S16 S32 U8 U16 U32 F16 F32.  */\n- nUF(vabd,      _vabd,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),\n  nUF(vabdq,     _vabd,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),\n  nUF(vmax,      _vmax,    3, (RNDQ, oRNDQ, RNDQ), neon_dyadic_if_su),\n  nUF(vmaxq,     _vmax,    3, (RNQ,  oRNQ,  RNQ),  neon_dyadic_if_su),\n@@ -21563,9 +22101,6 @@ static const struct asm_opcode insns[] =\n   /* Data processing, three registers of different lengths.  */\n   /* Dyadic, long insns. Types S8 S16 S32 U8 U16 U32.  */\n  NUF(vabal,     0800500, 3, (RNQ, RND, RND),  neon_abal),\n- NUF(vabdl,     0800700, 3, (RNQ, RND, RND),  neon_dyadic_long),\n- NUF(vaddl,     0800000, 3, (RNQ, RND, RND),  neon_dyadic_long),\n- NUF(vsubl,     0800200, 3, (RNQ, RND, RND),  neon_dyadic_long),\n   /* If not scalar, fall back to neon_dyadic_long.\n      Vector types as above, scalar types S16 S32 U16 U32.  */\n  nUF(vmlal,     _vmlal,   3, (RNQ, RND, RND_RNSC), neon_mac_maybe_scalar_long),\n@@ -22080,7 +22615,40 @@ static const struct asm_opcode insns[] =\n  toU(\"le\",  _le,  2, (oLR, EXP),\t t_loloop),\n \n  ToC(\"clrm\",\te89f0000, 1, (CLRMLST),  t_clrm),\n- ToC(\"vscclrm\",\tec9f0a00, 1, (VRSDVLST), t_vscclrm)\n+ ToC(\"vscclrm\",\tec9f0a00, 1, (VRSDVLST), t_vscclrm),\n+\n+#undef  THUMB_VARIANT\n+#define THUMB_VARIANT & mve_ext\n+ ToC(\"vpst\",\tfe710f4d, 0, (), mve_vpt),\n+ ToC(\"vpstt\",\tfe318f4d, 0, (), mve_vpt),\n+ ToC(\"vpste\",\tfe718f4d, 0, (), mve_vpt),\n+ ToC(\"vpsttt\",\tfe314f4d, 0, (), mve_vpt),\n+ ToC(\"vpstte\",\tfe31cf4d, 0, (), mve_vpt),\n+ ToC(\"vpstet\",\tfe71cf4d, 0, (), mve_vpt),\n+ ToC(\"vpstee\",\tfe714f4d, 0, (), mve_vpt),\n+ ToC(\"vpstttt\",\tfe312f4d, 0, (), mve_vpt),\n+ ToC(\"vpsttte\", fe316f4d, 0, (), mve_vpt),\n+ ToC(\"vpsttet\",\tfe31ef4d, 0, (), mve_vpt),\n+ ToC(\"vpsttee\",\tfe31af4d, 0, (), mve_vpt),\n+ ToC(\"vpstett\",\tfe71af4d, 0, (), mve_vpt),\n+ ToC(\"vpstete\",\tfe71ef4d, 0, (), mve_vpt),\n+ ToC(\"vpsteet\",\tfe716f4d, 0, (), mve_vpt),\n+ ToC(\"vpsteee\",\tfe712f4d, 0, (), mve_vpt),\n+\n+#undef  ARM_VARIANT\n+#define ARM_VARIANT    & fpu_vfp_ext_v1xd\n+#undef  THUMB_VARIANT\n+#define THUMB_VARIANT  & arm_ext_v6t2\n+\n+ mnCEF(vadd,     _vadd,    3, (RNSDQMQ, oRNSDQMQ, RNSDQMQR), neon_addsub_if_i),\n+ mnCEF(vsub,     _vsub,    3, (RNSDQMQ, oRNSDQMQ, RNSDQMQR), neon_addsub_if_i),\n+\n+#undef ARM_VARIANT\n+#define ARM_VARIANT & fpu_neon_ext_v1\n+ mnUF(vabd,      _vabd,    3, (RNDQMQ, oRNDQMQ, RNDQMQ), neon_dyadic_if_su),\n+ mnUF(vabdl,     _vabdl,\t  3, (RNQMQ, RNDMQ, RNDMQ),   neon_dyadic_long),\n+ mnUF(vaddl,     _vaddl,\t  3, (RNQMQ, RNDMQ, RNDMQR),  neon_dyadic_long),\n+ mnUF(vsubl,     _vsubl,\t  3, (RNQMQ, RNDMQ, RNDMQR),  neon_dyadic_long),\n };\n #undef ARM_VARIANT\n #undef THUMB_VARIANT\n@@ -25959,8 +26527,8 @@ arm_cleanup (void)\n {\n   literal_pool * pool;\n \n-  /* Ensure that all the IT blocks are properly closed.  */\n-  check_it_blocks_finished ();\n+  /* Ensure that all the predication blocks are properly closed.  */\n+  check_pred_blocks_finished ();\n \n   for (pool = list_of_pools; pool; pool = pool->next)\n     {\n@@ -26152,6 +26720,7 @@ md_begin (void)\n \n   if (\t (arm_ops_hsh = hash_new ()) == NULL\n       || (arm_cond_hsh = hash_new ()) == NULL\n+      || (arm_vcond_hsh = hash_new ()) == NULL\n       || (arm_shift_hsh = hash_new ()) == NULL\n       || (arm_psr_hsh = hash_new ()) == NULL\n       || (arm_v7m_psr_hsh = hash_new ()) == NULL\n@@ -26164,6 +26733,8 @@ md_begin (void)\n     hash_insert (arm_ops_hsh, insns[i].template_name, (void *) (insns + i));\n   for (i = 0; i < sizeof (conds) / sizeof (struct asm_cond); i++)\n     hash_insert (arm_cond_hsh, conds[i].template_name, (void *) (conds + i));\n+  for (i = 0; i < sizeof (vconds) / sizeof (struct asm_cond); i++)\n+    hash_insert (arm_vcond_hsh, vconds[i].template_name, (void *) (vconds + i));\n   for (i = 0; i < sizeof (shift_names) / sizeof (struct asm_shift_name); i++)\n     hash_insert (arm_shift_hsh, shift_names[i].name, (void *) (shift_names + i));\n   for (i = 0; i < sizeof (psrs) / sizeof (struct asm_psr); i++)"
    },
    {
      "sha": "39cc9680b96524c730c15fff1af22b180b9c70d1",
      "filename": "gas/config/tc-arm.h",
      "status": "modified",
      "additions": 10,
      "deletions": 6,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/config/tc-arm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/config/tc-arm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.h?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -254,21 +254,25 @@ arm_min (int am_p1, int am_p2)\n /* Registers are generally saved at negative offsets to the CFA.  */\n #define DWARF2_CIE_DATA_ALIGNMENT     (-4)\n \n-/* State variables for IT block handling.  */\n-enum it_state\n+/* State variables for predication block handling.  */\n+enum pred_state\n {\n-  OUTSIDE_IT_BLOCK, MANUAL_IT_BLOCK, AUTOMATIC_IT_BLOCK\n+  OUTSIDE_PRED_BLOCK, MANUAL_PRED_BLOCK, AUTOMATIC_PRED_BLOCK\n };\n-struct current_it\n+enum pred_type {\n+  SCALAR_PRED, VECTOR_PRED\n+};\n+struct current_pred\n {\n   int mask;\n-  enum it_state state;\n+  enum pred_state state;\n   int cc;\n   int block_length;\n   char *insn;\n   int state_handled;\n   int warn_deprecated;\n   int insn_cond;\n+  enum pred_type type;\n };\n \n #ifdef OBJ_ELF\n@@ -303,7 +307,7 @@ struct arm_segment_info_type\n      emitted only once per section, to save unnecessary bloat.  */\n   unsigned int marked_pr_dependency;\n \n-  struct current_it current_it;\n+  struct current_pred current_pred;\n };\n \n /* We want .cfi_* pseudo-ops for generating unwind info.  */"
    },
    {
      "sha": "6b7e30ff1d96bf0cc1e49141bd3924bf8afa2b13",
      "filename": "gas/testsuite/gas/arm/armv8_3-a-fp-bad.l",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/armv8_3-a-fp-bad.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/armv8_3-a-fp-bad.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/armv8_3-a-fp-bad.l?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -3,5 +3,5 @@\n [^:]+:4: Error: VFP single precision register expected -- `vjcvt\\.s32\\.f64 r0,d1'\n [^:]+:5: Error: VFP/Neon double precision register expected -- `vjcvt\\.s32\\.f64 s0,s1'\n [^:]+:6: Error: VFP/Neon double precision register expected -- `vjcvt\\.s32\\.f32 s0,s1'\n-[^:]+:7: Error: bad type in Neon instruction -- `vjcvt\\.s32\\.f32 s0,d1'\n-[^:]+:8: Error: bad type in Neon instruction -- `vjcvt\\.f32\\.f64 s0,d1'\n+[^:]+:7: Error: bad type in SIMD instruction -- `vjcvt\\.s32\\.f32 s0,d1'\n+[^:]+:8: Error: bad type in SIMD instruction -- `vjcvt\\.f32\\.f64 s0,d1'"
    },
    {
      "sha": "d440d64011f63b687691a7e05e4e0f5cedcfb19b",
      "filename": "gas/testsuite/gas/arm/armv8_3-a-simd-bad.l",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/armv8_3-a-simd-bad.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/armv8_3-a-simd-bad.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/armv8_3-a-simd-bad.l?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -3,15 +3,15 @@\n [^:]+:7: Error: immediate out of range -- `vcadd\\.f32 q0,q1,q2,#0'\n [^:]+:8: Error: immediate out of range -- `vcadd\\.f32 q0,q1,q2,#180'\n [^:]+:9: Error: Neon double or quad precision register expected -- `vcadd\\.f16 s0,s1,s2,#90'\n-[^:]+:10: Error: bad type in Neon instruction -- `vcadd\\.f64 d0,d1,d2,#90'\n-[^:]+:11: Error: bad type in Neon instruction -- `vcadd\\.f64 q0,q1,q2,#90'\n+[^:]+:10: Error: bad type in SIMD instruction -- `vcadd\\.f64 d0,d1,d2,#90'\n+[^:]+:11: Error: bad type in SIMD instruction -- `vcadd\\.f64 q0,q1,q2,#90'\n [^:]+:13: Error: operand types can't be inferred -- `vcmla d0,d1,d2,#90'\n [^:]+:14: Error: immediate out of range -- `vcmla\\.f32 q0,q1,q2,#-90'\n [^:]+:15: Error: immediate out of range -- `vcmla\\.f32 q0,q1,q2,#120'\n [^:]+:16: Error: immediate out of range -- `vcmla\\.f32 q0,q1,q2,#360'\n [^:]+:17: Error: Neon double or quad precision register expected -- `vcmla\\.f16 s0,s1,s2,#90'\n-[^:]+:18: Error: bad type in Neon instruction -- `vcmla\\.f64 d0,d1,d2,#90'\n-[^:]+:19: Error: bad type in Neon instruction -- `vcmla\\.f64 q0,q1,q2,#90'\n+[^:]+:18: Error: bad type in SIMD instruction -- `vcmla\\.f64 d0,d1,d2,#90'\n+[^:]+:19: Error: bad type in SIMD instruction -- `vcmla\\.f64 q0,q1,q2,#90'\n [^:]+:21: Error: only D registers may be indexed -- `vcmla\\.f16 q0,q1,q2\\[0\\],#90'\n [^:]+:22: Error: only D registers may be indexed -- `vcmla\\.f32 q0,q1,q2\\[0\\],#90'\n [^:]+:23: Error: scalar out of range -- `vcmla\\.f16 d0,d1,d2\\[2\\],#90'\n@@ -22,15 +22,15 @@\n [^:]+:32: Error: immediate out of range -- `vcadd\\.f32 q0,q1,q2,#0'\n [^:]+:33: Error: immediate out of range -- `vcadd\\.f32 q0,q1,q2,#180'\n [^:]+:34: Error: Neon double or quad precision register expected -- `vcadd\\.f16 s0,s1,s2,#90'\n-[^:]+:35: Error: bad type in Neon instruction -- `vcadd\\.f64 d0,d1,d2,#90'\n-[^:]+:36: Error: bad type in Neon instruction -- `vcadd\\.f64 q0,q1,q2,#90'\n+[^:]+:35: Error: bad type in SIMD instruction -- `vcadd\\.f64 d0,d1,d2,#90'\n+[^:]+:36: Error: bad type in SIMD instruction -- `vcadd\\.f64 q0,q1,q2,#90'\n [^:]+:38: Error: operand types can't be inferred -- `vcmla d0,d1,d2,#90'\n [^:]+:39: Error: immediate out of range -- `vcmla\\.f32 q0,q1,q2,#-90'\n [^:]+:40: Error: immediate out of range -- `vcmla\\.f32 q0,q1,q2,#120'\n [^:]+:41: Error: immediate out of range -- `vcmla\\.f32 q0,q1,q2,#360'\n [^:]+:42: Error: Neon double or quad precision register expected -- `vcmla\\.f16 s0,s1,s2,#90'\n-[^:]+:43: Error: bad type in Neon instruction -- `vcmla\\.f64 d0,d1,d2,#90'\n-[^:]+:44: Error: bad type in Neon instruction -- `vcmla\\.f64 q0,q1,q2,#90'\n+[^:]+:43: Error: bad type in SIMD instruction -- `vcmla\\.f64 d0,d1,d2,#90'\n+[^:]+:44: Error: bad type in SIMD instruction -- `vcmla\\.f64 q0,q1,q2,#90'\n [^:]+:46: Error: only D registers may be indexed -- `vcmla\\.f16 q0,q1,q2\\[0\\],#90'\n [^:]+:47: Error: only D registers may be indexed -- `vcmla\\.f32 q0,q1,q2\\[0\\],#90'\n [^:]+:48: Error: scalar out of range -- `vcmla\\.f16 d0,d1,d2\\[2\\],#90'"
    },
    {
      "sha": "c0c8708b367ef14c36cb8ecc6d57722d3200591e",
      "filename": "gas/testsuite/gas/arm/dotprod-illegal.l",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/dotprod-illegal.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/dotprod-illegal.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/dotprod-illegal.l?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -1,9 +1,9 @@\n [^:]*: Assembler messages:\n-[^:]*:4: Error: bad type in Neon instruction -- `vudot.s8 d0,d2,d5'\n-[^:]*:6: Error: bad type in Neon instruction -- `vudot.u16 d0,d2,d5'\n-[^:]*:7: Error: bad type in Neon instruction -- `vsdot.s16 d1,d12,d18'\n-[^:]*:9: Error: bad type in Neon instruction -- `vudot.u32 d2,d22,d1'\n-[^:]*:10: Error: bad type in Neon instruction -- `vsdot.s32 d3,d30,d9'\n+[^:]*:4: Error: bad type in SIMD instruction -- `vudot.s8 d0,d2,d5'\n+[^:]*:6: Error: bad type in SIMD instruction -- `vudot.u16 d0,d2,d5'\n+[^:]*:7: Error: bad type in SIMD instruction -- `vsdot.s16 d1,d12,d18'\n+[^:]*:9: Error: bad type in SIMD instruction -- `vudot.u32 d2,d22,d1'\n+[^:]*:10: Error: bad type in SIMD instruction -- `vsdot.s32 d3,d30,d9'\n [^:]*:12: Error: scalar out of range for multiply instruction -- `vudot.u8 d31,d2,d16\\[0\\]'\n [^:]*:13: Error: scalar out of range for multiply instruction -- `vsdot.s8 q13,q14,d22\\[1\\]'\n [^:]*:15: Error: scalar out of range for multiply instruction -- `vudot.u8 d1,d8,d15\\[2\\]'"
    },
    {
      "sha": "86394e3edbda1b9a9760a44ce07263bbfa9de694",
      "filename": "gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.d",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.d?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,5 @@\n+#name: bad MVE VADD, VSUB and VABD instructions\n+#as: -march=armv8.1-m.main+mve\n+#error_output: mve-vaddsubabd-bad-1.l\n+\n+.*: +file format .*arm.*"
    },
    {
      "sha": "d4d7bfe7f89b688de35744f19a4c3bd7f3519546",
      "filename": "gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.l",
      "status": "added",
      "additions": 55,
      "deletions": 0,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.l?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,55 @@\n+[^:]*: Assembler messages:\n+[^:]*:11: Error: bad type in SIMD instruction -- `vadd.p8 q0,q1,q2'\n+[^:]*:12: Error: selected FPU does not support instruction -- `vadd.f16 q0,q1,q2'\n+[^:]*:13: Error: selected FPU does not support instruction -- `vadd.f32 q0,q1,q2'\n+[^:]*:14: Error: selected FPU does not support instruction -- `vadd.i64 q0,q1,q2'\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:16: Error: bad type in SIMD instruction -- `vsub.p8 q0,q1,q2'\n+[^:]*:17: Error: selected FPU does not support instruction -- `vsub.f16 q0,q1,q2'\n+[^:]*:18: Error: selected FPU does not support instruction -- `vsub.f32 q0,q1,q2'\n+[^:]*:19: Error: selected FPU does not support instruction -- `vsub.i64 q0,q1,q2'\n+[^:]*:20: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:20: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:20: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:20: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:20: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:20: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:21: Error: bad type in SIMD instruction -- `vadd.p8 q0,q1,r2'\n+[^:]*:22: Error: selected FPU does not support instruction -- `vadd.f16 q0,q1,r2'\n+[^:]*:23: Error: selected FPU does not support instruction -- `vadd.f32 q0,q1,r2'\n+[^:]*:24: Error: selected FPU does not support instruction -- `vadd.i64 q0,q1,r2'\n+[^:]*:25: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:25: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:25: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:25: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:25: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:25: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:26: Error: bad type in SIMD instruction -- `vsub.p8 q0,q1,r2'\n+[^:]*:27: Error: selected FPU does not support instruction -- `vsub.f16 q0,q1,r2'\n+[^:]*:28: Error: selected FPU does not support instruction -- `vsub.f32 q0,q1,r2'\n+[^:]*:29: Error: selected FPU does not support instruction -- `vsub.i64 q0,q1,r2'\n+[^:]*:30: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:30: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:30: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:30: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:30: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:30: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:31: Error: bad type in SIMD instruction -- `vabd.p8 q0,q1,q2'\n+[^:]*:32: Error: selected FPU does not support instruction -- `vabd.f16 q0,q1,q2'\n+[^:]*:33: Error: selected FPU does not support instruction -- `vabd.f32 q0,q1,q2'\n+[^:]*:34: Error: bad type in SIMD instruction -- `vabd.i64 q0,q1,q2'\n+[^:]*:35: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:35: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:35: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:35: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:35: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:35: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:36: Warning: instruction is UNPREDICTABLE with SP operand\n+[^:]*:37: Warning: instruction is UNPREDICTABLE with SP operand\n+[^:]*:38: Warning: instruction is UNPREDICTABLE with PC operand\n+[^:]*:39: Warning: instruction is UNPREDICTABLE with PC operand"
    },
    {
      "sha": "809937d4c1ed99974b1670ce95edb70c2edf8ed1",
      "filename": "gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.s",
      "status": "added",
      "additions": 39,
      "deletions": 0,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vaddsubabd-bad-1.s?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,39 @@\n+.macro cond op, lastreg, size\n+.irp cond, eq, ne, gt, ge, lt, le\n+it \\cond\n+\\op\\size q0, q1, \\lastreg\n+.endr\n+.endm\n+\n+.syntax unified\n+.text\n+.thumb\n+vadd.p8 q0, q1, q2\n+vadd.f16 q0, q1, q2\n+vadd.f32 q0, q1, q2\n+vadd.i64 q0, q1, q2\n+cond vadd, q2, .i32\n+vsub.p8 q0, q1, q2\n+vsub.f16 q0, q1, q2\n+vsub.f32 q0, q1, q2\n+vsub.i64 q0, q1, q2\n+cond vsub, q2, .i32\n+vadd.p8 q0, q1, r2\n+vadd.f16 q0, q1, r2\n+vadd.f32 q0, q1, r2\n+vadd.i64 q0, q1, r2\n+cond vadd, r2, .i32\n+vsub.p8 q0, q1, r2\n+vsub.f16 q0, q1, r2\n+vsub.f32 q0, q1, r2\n+vsub.i64 q0, q1, r2\n+cond vsub, r2, .i32\n+vabd.p8 q0, q1, q2\n+vabd.f16 q0, q1, q2\n+vabd.f32 q0, q1, q2\n+vabd.i64 q0, q1, q2\n+cond vabd, q2, .s32\n+vadd.i32 q0, q1, sp\n+vsub.i32 q0, q1, sp\n+vadd.i32 q0, q1, pc\n+vsub.i32 q0, q1, pc"
    },
    {
      "sha": "602dc3276ae1f916196f777ad9d934fbe229ec68",
      "filename": "gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.d",
      "status": "added",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.d?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,6 @@\n+#name: bad MVE FP VADD, VSUB and VABD instructions\n+#as: -march=armv8.1-m.main+mve.fp\n+#error_output: mve-vaddsubabd-bad-2.l\n+\n+.*: +file format .*arm.*\n+"
    },
    {
      "sha": "77d634c45618edabd6f95174741dd66772b111cb",
      "filename": "gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.l",
      "status": "added",
      "additions": 46,
      "deletions": 0,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.l?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,46 @@\n+[^:]*: Assembler messages:\n+[^:]*:13: Error: bad type in SIMD instruction -- `vadd.p8 q0,q1,q2'\n+[^:]*:14: Error: selected FPU does not support instruction -- `vadd.i64 q0,q1,q2'\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:16: Error: bad type in SIMD instruction -- `vsub.p8 q0,q1,q2'\n+[^:]*:17: Error: selected FPU does not support instruction -- `vsub.i64 q0,q1,q2'\n+[^:]*:18: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:18: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:18: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:18: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:18: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:18: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:19: Error: bad type in SIMD instruction -- `vadd.p8 q0,q1,r2'\n+[^:]*:20: Error: selected FPU does not support instruction -- `vadd.i64 q0,q1,r2'\n+[^:]*:21: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:21: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:21: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:21: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:21: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:21: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:22: Error: bad type in SIMD instruction -- `vsub.p8 q0,q1,r2'\n+[^:]*:23: Error: selected FPU does not support instruction -- `vsub.i64 q0,q1,r2'\n+[^:]*:24: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:24: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:24: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:24: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:24: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:24: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:25: Error: bad type in SIMD instruction -- `vabd.p8 q0,q1,q2'\n+[^:]*:26: Error: bad type in SIMD instruction -- `vabd.i64 q0,q1,q2'\n+[^:]*:27: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:27: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:27: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:27: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:27: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:27: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:28: Warning: instruction is UNPREDICTABLE with SP operand\n+[^:]*:29: Warning: instruction is UNPREDICTABLE with SP operand\n+[^:]*:30: Warning: instruction is UNPREDICTABLE with PC operand\n+[^:]*:31: Warning: instruction is UNPREDICTABLE with PC operand\n+"
    },
    {
      "sha": "15242909d9657ba56709c128d96928e677af2036",
      "filename": "gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.s",
      "status": "added",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vaddsubabd-bad-2.s?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,32 @@\n+.macro cond op, lastreg\n+.irp cond, eq, ne, gt, ge, lt, le\n+it \\cond\n+\\op\\().f32 q0, q1, \\lastreg\n+.endr\n+.endm\n+\n+\n+\n+.syntax unified\n+.text\n+.thumb\n+vadd.p8 q0, q1, q2\n+vadd.i64 q0, q1, q2\n+cond vadd, q2\n+vsub.p8 q0, q1, q2\n+vsub.i64 q0, q1, q2\n+cond vsub, q2\n+vadd.p8 q0, q1, r2\n+vadd.i64 q0, q1, r2\n+cond vadd, r2\n+vsub.p8 q0, q1, r2\n+vsub.i64 q0, q1, r2\n+cond vsub, r2\n+vabd.p8 q0, q1, q2\n+vabd.i64 q0, q1, q2\n+cond vabd, q2\n+vadd.i32 q0, q1, sp\n+vsub.i32 q0, q1, sp\n+vadd.i32 q0, q1, pc\n+vsub.i32 q0, q1, pc\n+"
    },
    {
      "sha": "f328abc80f188ded287273fe04edee4ed42e4f15",
      "filename": "gas/testsuite/gas/arm/mve-vpst-bad.d",
      "status": "added",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vpst-bad.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vpst-bad.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vpst-bad.d?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,6 @@\n+#name: bad VPST instructions\n+#as: -march=armv8.1-m.main+mve\n+#error_output: mve-vpst-bad.l\n+\n+.*: +file format .*arm.*\n+"
    },
    {
      "sha": "9a396ae6459db53939d0cfc9f58358c965712697",
      "filename": "gas/testsuite/gas/arm/mve-vpst-bad.l",
      "status": "added",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vpst-bad.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vpst-bad.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vpst-bad.l?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,19 @@\n+[^:]*: Assembler messages:\n+[^:]*:6: Error: syntax error -- `vpsteq'\n+[^:]*:9: Error: vector predicated instruction should be in VPT/VPST block -- `vaddt.i32 q0,q1,q2'\n+[^:]*:12: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:15: Error: syntax error -- `vaddeq.i32 q0,q1,q2'\n+[^:]*:21: Error: instruction missing MVE vector predication code -- `vadd.i32 q0,q1,q2'\n+[^:]*:23: Error: syntax error -- `vaddeq.i32 q0,q1,q2'\n+[^:]*:25: Error: vector predicated instruction should be in VPT/VPST block -- `vaddt.i32 q0,q1,q2'\n+[^:]*:33: Error: bad instruction `addt r0,r0,r1'\n+[^:]*:37: Error: instruction not allowed in IT block -- `add r0,r0,r1'\n+[^:]*:40: Error: thumb conditional instruction should be in IT block -- `addeq r0,r0,r1'\n+[^:]*:43: Error: bad instruction `addt r0,r0,r1'\n+[^:]*:47: Warning: instruction is UNPREDICTABLE in a VPT block\n+[^:]*:49: Error: thumb conditional instruction should be in IT block -- `addeq r0,r0,r1'\n+[^:]*:51: Error: bad instruction `addt r0,r0,r1'\n+[^:]*:55: Warning: instruction is UNPREDICTABLE in an IT block\n+[^:]*:62: Error: incorrect condition in VPT/VPST block -- `vaddt.i32 q0,q1,q2'\n+[^:]*:65: Error: syntax error -- `vaddeq.i32 q0,q1,q2'\n+[^:]*:68: Warning: .* finished with an open VPT/VPST block."
    },
    {
      "sha": "f41d66bfccb136cf042a7d82a13f8b639b7cc556",
      "filename": "gas/testsuite/gas/arm/mve-vpst-bad.s",
      "status": "added",
      "additions": 68,
      "deletions": 0,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vpst-bad.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/mve-vpst-bad.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/mve-vpst-bad.s?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -0,0 +1,68 @@\n+.syntax unified\n+.text\n+.thumb\n+@ Case 1\n+it eq\n+vpsteq\n+@ Case 2\n+it eq\n+vaddt.i32 q0, q1, q2\n+@ Case 3\n+it eq\n+vadd.i32 q0, q1, q2\n+@ Case 4\n+vpst\n+vaddeq.i32 q0, q1, q2\n+@ Case 5\n+vpst\n+vaddt.i32 q0, q1, q2\n+@ Case 6\n+vpst\n+vadd.i32 q0, q1, q2\n+@ Case 7\n+vaddeq.i32 q0, q1, q2\n+@ Case 8\n+vaddt.i32 q0, q1, q2\n+@ Case 9\n+vadd.i32 q0, q1, q2\n+@ Case 10\n+it eq\n+addeq r0, r0, r1\n+@ Case 11\n+it eq\n+addt r0, r0, r1\n+addeq r0, r0, r1\n+@ Case 12\n+it eq\n+add r0, r0, r1\n+@ Case 13\n+vpst\n+addeq r0, r0, r1\n+@ Case 14\n+vpst\n+addt r0, r0, r1\n+vaddt.i32 q0, q0, q1\n+@ Case 15\n+vpst\n+add r0, r0, r1\n+@ Case 16\n+addeq r0, r0, r1\n+@ Case 17\n+addt r0, r0, r1\n+@ Case 18\n+add r0, r0, r1\n+it le\n+vpstete\n+vaddt.i32 q0, q1, q2\n+vadde.i32 q0, q1, q2\n+vaddt.i32 q0, q1, q2\n+vadde.i32 q0, q1, q2\n+vpste\n+vaddt.i32 q0, q1, q2\n+vaddt.i32 q0, q1, q2\n+vpste\n+vaddt.i32 q0, q1, q2\n+vaddeq.i32 q0, q1, q2\n+vpstet\n+vaddt.i32 q0, q1, q2\n+vadde.i32 q0, q1, q2"
    },
    {
      "sha": "84758c6b2b338be20160e63586b01b7fca4ef35b",
      "filename": "gas/testsuite/gas/arm/neon-ldst-es-bad.l",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/neon-ldst-es-bad.l",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ee9134313f9cce06d38144f5bc77c59e04df884/gas/testsuite/gas/arm/neon-ldst-es-bad.l",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/arm/neon-ldst-es-bad.l?ref=5ee9134313f9cce06d38144f5bc77c59e04df884",
      "patch": "@@ -1,12 +1,12 @@\n [^:]*: Assembler messages:\n-[^:]*:2: Error: bad type in Neon instruction -- `vld1\\.64 {d0\\[1\\]},\\[r0\\]'\n-[^:]*:3: Error: bad type in Neon instruction -- `vld1\\.64 {d0\\[\\]},\\[r0\\]'\n-[^:]*:4: Error: bad type in Neon instruction -- `vld2\\.64 {d0\\[1\\]},\\[r0\\]'\n-[^:]*:5: Error: bad type in Neon instruction -- `vld2\\.64 {d0\\[\\]},\\[r0\\]'\n+[^:]*:2: Error: bad type in SIMD instruction -- `vld1\\.64 {d0\\[1\\]},\\[r0\\]'\n+[^:]*:3: Error: bad type in SIMD instruction -- `vld1\\.64 {d0\\[\\]},\\[r0\\]'\n+[^:]*:4: Error: bad type in SIMD instruction -- `vld2\\.64 {d0\\[1\\]},\\[r0\\]'\n+[^:]*:5: Error: bad type in SIMD instruction -- `vld2\\.64 {d0\\[\\]},\\[r0\\]'\n [^:]*:6: Error: bad element type for instruction -- `vld2\\.64 {d0-d1},\\[r0\\]'\n-[^:]*:7: Error: bad type in Neon instruction -- `vld3\\.64 {d0\\[1\\]},\\[r0\\]'\n-[^:]*:8: Error: bad type in Neon instruction -- `vld3\\.64 {d0\\[\\]},\\[r0\\]'\n+[^:]*:7: Error: bad type in SIMD instruction -- `vld3\\.64 {d0\\[1\\]},\\[r0\\]'\n+[^:]*:8: Error: bad type in SIMD instruction -- `vld3\\.64 {d0\\[\\]},\\[r0\\]'\n [^:]*:9: Error: bad element type for instruction -- `vld3\\.64 {d0-d2},\\[r0\\]'\n-[^:]*:10: Error: bad type in Neon instruction -- `vld4\\.64 {d0\\[1\\]},\\[r0\\]'\n-[^:]*:11: Error: bad type in Neon instruction -- `vld4\\.64 {d0\\[\\]},\\[r0\\]'\n+[^:]*:10: Error: bad type in SIMD instruction -- `vld4\\.64 {d0\\[1\\]},\\[r0\\]'\n+[^:]*:11: Error: bad type in SIMD instruction -- `vld4\\.64 {d0\\[\\]},\\[r0\\]'\n [^:]*:12: Error: bad element type for instruction -- `vld4\\.64 {d0-d3},\\[r0\\]'"
    }
  ]
}