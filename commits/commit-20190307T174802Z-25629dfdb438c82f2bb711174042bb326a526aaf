{
  "sha": "25629dfdb438c82f2bb711174042bb326a526aaf",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjU2MjlkZmRiNDM4YzgyZjJiYjcxMTE3NDA0MmJiMzI2YTUyNmFhZg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-03-07T11:20:19Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-03-07T17:48:02Z"
    },
    "message": "C++-ify bcache\n\nThis somewhat C++-ifies bcache.  It replaces bcache_xmalloc and\nbcache_xfree with constructors; changes some functions into methods;\nand changes various structures to include a bcache directly (as\nopposed to a pointer to a bcache).\n\nTested by the buildbot.\n\ngdb/ChangeLog\n2019-03-07  Tom Tromey  <tom@tromey.com>\n\n\t* symmisc.c (print_symbol_bcache_statistics): Update.\n\t(print_objfile_statistics): Update.\n\t* symfile.c (allocate_symtab): Update.\n\t* stabsread.c: Don't include bcache.h.\n\t* psymtab.h (struct psymbol_bcache): Don't declare.\n\t(class psymtab_storage) <psymbol_cache>: Now a bcache.\n\t(psymbol_bcache_init, psymbol_bcache_free)\n\t(psymbol_bcache_get_bcache): Don't declare.\n\t* psymtab.c (struct psymbol_bcache): Remove.\n\t(psymtab_storage::psymtab_storage): Update.\n\t(psymtab_storage::~psymtab_storage): Update.\n\t(psymbol_bcache_init, psymbol_bcache_free)\n\t(psymbol_bcache_get_bcache, psymbol_bcache_full): Remove.\n\t(add_psymbol_to_bcache): Update.\n\t(allocate_psymtab): Update.\n\t* objfiles.h (struct objfile_per_bfd_storage) <filename_cache,\n\tmacro_cache>: No longer pointers.\n\t* objfiles.c (get_objfile_bfd_data): Don't call bcache_xmalloc.\n\t(free_objfile_per_bfd_storage): Don't call bcache_xfree.\n\t* macrotab.c (macro_bcache): Update.\n\t* macroexp.c: Don't include bcache.h.\n\t* gdbtypes.c (check_types_worklist): Update.\n\t(types_deeply_equal): Remove TRY/CATCH.  Update.\n\t* elfread.c (elf_symtab_read): Update.\n\t* dwarf2read.c: Don't include bcache.h.\n\t* buildsym.c (buildsym_compunit::get_macro_table): Update.\n\t* bcache.h (bcache, bcache_full, bcache_xffree, bcache_xmalloc)\n\t(print_bcache_statistics, bcache_memory_used): Don't declare.\n\t(struct bcache): Move from bcache.c.  Add constructor, destructor,\n\tmethods.  Rename all data members.\n\t* bcache.c (struct bcache): Move to bcache.h.\n\t(bcache::expand_hash_table): Rename from expand_hash_table.\n\t(bcache): Remove.\n\t(bcache::insert): Rename from bcache_full.\n\t(bcache::compare): Rename from bcache_compare.\n\t(bcache_xmalloc): Remove.\n\t(bcache::~bcache): Rename from bcache_xfree.\n\t(bcache::print_statistics): Rename from print_bcache_statistics.\n\t(bcache::memory_used): Rename from bcache_memory_used.",
    "tree": {
      "sha": "f0bd8f98faa31b5124de5963abe119507a095622",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f0bd8f98faa31b5124de5963abe119507a095622"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/25629dfdb438c82f2bb711174042bb326a526aaf",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/25629dfdb438c82f2bb711174042bb326a526aaf",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/25629dfdb438c82f2bb711174042bb326a526aaf",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/25629dfdb438c82f2bb711174042bb326a526aaf/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fe7266674110f34eacf2e9d2b308f76d33ce50ed",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fe7266674110f34eacf2e9d2b308f76d33ce50ed",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fe7266674110f34eacf2e9d2b308f76d33ce50ed"
    }
  ],
  "stats": {
    "total": 544,
    "additions": 228,
    "deletions": 316
  },
  "files": [
    {
      "sha": "de5e74a1c5950b805bee5e115c825e81288aed1e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 42,
      "deletions": 0,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -1,3 +1,45 @@\n+2019-03-07  Tom Tromey  <tom@tromey.com>\n+\n+\t* symmisc.c (print_symbol_bcache_statistics): Update.\n+\t(print_objfile_statistics): Update.\n+\t* symfile.c (allocate_symtab): Update.\n+\t* stabsread.c: Don't include bcache.h.\n+\t* psymtab.h (struct psymbol_bcache): Don't declare.\n+\t(class psymtab_storage) <psymbol_cache>: Now a bcache.\n+\t(psymbol_bcache_init, psymbol_bcache_free)\n+\t(psymbol_bcache_get_bcache): Don't declare.\n+\t* psymtab.c (struct psymbol_bcache): Remove.\n+\t(psymtab_storage::psymtab_storage): Update.\n+\t(psymtab_storage::~psymtab_storage): Update.\n+\t(psymbol_bcache_init, psymbol_bcache_free)\n+\t(psymbol_bcache_get_bcache, psymbol_bcache_full): Remove.\n+\t(add_psymbol_to_bcache): Update.\n+\t(allocate_psymtab): Update.\n+\t* objfiles.h (struct objfile_per_bfd_storage) <filename_cache,\n+\tmacro_cache>: No longer pointers.\n+\t* objfiles.c (get_objfile_bfd_data): Don't call bcache_xmalloc.\n+\t(free_objfile_per_bfd_storage): Don't call bcache_xfree.\n+\t* macrotab.c (macro_bcache): Update.\n+\t* macroexp.c: Don't include bcache.h.\n+\t* gdbtypes.c (check_types_worklist): Update.\n+\t(types_deeply_equal): Remove TRY/CATCH.  Update.\n+\t* elfread.c (elf_symtab_read): Update.\n+\t* dwarf2read.c: Don't include bcache.h.\n+\t* buildsym.c (buildsym_compunit::get_macro_table): Update.\n+\t* bcache.h (bcache, bcache_full, bcache_xffree, bcache_xmalloc)\n+\t(print_bcache_statistics, bcache_memory_used): Don't declare.\n+\t(struct bcache): Move from bcache.c.  Add constructor, destructor,\n+\tmethods.  Rename all data members.\n+\t* bcache.c (struct bcache): Move to bcache.h.\n+\t(bcache::expand_hash_table): Rename from expand_hash_table.\n+\t(bcache): Remove.\n+\t(bcache::insert): Rename from bcache_full.\n+\t(bcache::compare): Rename from bcache_compare.\n+\t(bcache_xmalloc): Remove.\n+\t(bcache::~bcache): Rename from bcache_xfree.\n+\t(bcache::print_statistics): Rename from print_bcache_statistics.\n+\t(bcache::memory_used): Rename from bcache_memory_used.\n+\n 2019-03-07  Pedro Alves  <palves@redhat.com>\n \n \t* infrun.c (normal_stop): Also check for"
    },
    {
      "sha": "14a7847496226d5b9e4165226d1bd46dd373757c",
      "filename": "gdb/bcache.c",
      "status": "modified",
      "additions": 76,
      "deletions": 162,
      "changes": 238,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/bcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/bcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bcache.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -49,48 +49,6 @@ struct bstring\n   d;\n };\n \n-\n-/* The structure for a bcache itself.  The bcache is initialized, in\n-   bcache_xmalloc(), by filling it with zeros and then setting the\n-   corresponding obstack's malloc() and free() methods.  */\n-\n-struct bcache\n-{\n-  /* All the bstrings are allocated here.  */\n-  struct obstack cache;\n-\n-  /* How many hash buckets we're using.  */\n-  unsigned int num_buckets;\n-  \n-  /* Hash buckets.  This table is allocated using malloc, so when we\n-     grow the table we can return the old table to the system.  */\n-  struct bstring **bucket;\n-\n-  /* Statistics.  */\n-  unsigned long unique_count;\t/* number of unique strings */\n-  long total_count;\t/* total number of strings cached, including dups */\n-  long unique_size;\t/* size of unique strings, in bytes */\n-  long total_size;      /* total number of bytes cached, including dups */\n-  long structure_size;\t/* total size of bcache, including infrastructure */\n-  /* Number of times that the hash table is expanded and hence\n-     re-built, and the corresponding number of times that a string is\n-     [re]hashed as part of entering it into the expanded table.  The\n-     total number of hashes can be computed by adding TOTAL_COUNT to\n-     expand_hash_count.  */\n-  unsigned long expand_count;\n-  unsigned long expand_hash_count;\n-  /* Number of times that the half-hash compare hit (compare the upper\n-     16 bits of hash values) hit, but the corresponding combined\n-     length/data compare missed.  */\n-  unsigned long half_hash_miss_count;\n-\n-  /* Hash function to be used for this bcache object.  */\n-  unsigned long (*hash_function)(const void *addr, int length);\n-\n-  /* Compare function to be used for this bcache object.  */\n-  int (*compare_function)(const void *, const void *, int length);\n-};\n-\n /* The old hash function was stolen from SDBM. This is what DB 3.0\n    uses now, and is better than the old one.  */\n \f\n@@ -123,8 +81,8 @@ hash_continue (const void *addr, int length, unsigned long h)\n    resize our hash table.  */\n #define CHAIN_LENGTH_THRESHOLD (5)\n \n-static void\n-expand_hash_table (struct bcache *bcache)\n+void\n+bcache::expand_hash_table ()\n {\n   /* A table of good hash table sizes.  Whenever we grow, we pick the\n      next larger size from this table.  sizes[i] is close to 1 << (i+10),\n@@ -143,13 +101,13 @@ expand_hash_table (struct bcache *bcache)\n \n   /* Count the stats.  Every unique item needs to be re-hashed and\n      re-entered.  */\n-  bcache->expand_count++;\n-  bcache->expand_hash_count += bcache->unique_count;\n+  m_expand_count++;\n+  m_expand_hash_count += m_unique_count;\n \n   /* Find the next size.  */\n-  new_num_buckets = bcache->num_buckets * 2;\n+  new_num_buckets = m_num_buckets * 2;\n   for (i = 0; i < (sizeof (sizes) / sizeof (sizes[0])); i++)\n-    if (sizes[i] > bcache->num_buckets)\n+    if (sizes[i] > m_num_buckets)\n       {\n \tnew_num_buckets = sizes[i];\n \tbreak;\n@@ -162,34 +120,31 @@ expand_hash_table (struct bcache *bcache)\n     new_buckets = (struct bstring **) xmalloc (new_size);\n     memset (new_buckets, 0, new_size);\n \n-    bcache->structure_size -= (bcache->num_buckets\n-\t\t\t       * sizeof (bcache->bucket[0]));\n-    bcache->structure_size += new_size;\n+    m_structure_size -= m_num_buckets * sizeof (m_bucket[0]);\n+    m_structure_size += new_size;\n   }\n \n   /* Rehash all existing strings.  */\n-  for (i = 0; i < bcache->num_buckets; i++)\n+  for (i = 0; i < m_num_buckets; i++)\n     {\n       struct bstring *s, *next;\n \n-      for (s = bcache->bucket[i]; s; s = next)\n+      for (s = m_bucket[i]; s; s = next)\n \t{\n \t  struct bstring **new_bucket;\n \t  next = s->next;\n \n-\t  new_bucket = &new_buckets[(bcache->hash_function (&s->d.data,\n-\t\t\t\t\t\t\t    s->length)\n+\t  new_bucket = &new_buckets[(m_hash_function (&s->d.data, s->length)\n \t\t\t\t     % new_num_buckets)];\n \t  s->next = *new_bucket;\n \t  *new_bucket = s;\n \t}\n     }\n \n   /* Plug in the new table.  */\n-  if (bcache->bucket)\n-    xfree (bcache->bucket);\n-  bcache->bucket = new_buckets;\n-  bcache->num_buckets = new_num_buckets;\n+  xfree (m_bucket);\n+  m_bucket = new_buckets;\n+  m_num_buckets = new_num_buckets;\n }\n \n \f\n@@ -199,23 +154,14 @@ expand_hash_table (struct bcache *bcache)\n    is N bytes long.  */\n #define BSTRING_SIZE(n) (offsetof (struct bstring, d.data) + (n))\n \n-/* Find a copy of the LENGTH bytes at ADDR in BCACHE.  If BCACHE has\n-   never seen those bytes before, add a copy of them to BCACHE.  In\n-   either case, return a pointer to BCACHE's copy of that string.  */\n-const void *\n-bcache (const void *addr, int length, struct bcache *cache)\n-{\n-  return bcache_full (addr, length, cache, NULL);\n-}\n-\n /* Find a copy of the LENGTH bytes at ADDR in BCACHE.  If BCACHE has\n    never seen those bytes before, add a copy of them to BCACHE.  In\n    either case, return a pointer to BCACHE's copy of that string.  If\n    optional ADDED is not NULL, return 1 in case of new entry or 0 if\n    returning an old entry.  */\n \n const void *\n-bcache_full (const void *addr, int length, struct bcache *bcache, int *added)\n+bcache::insert (const void *addr, int length, int *added)\n {\n   unsigned long full_hash;\n   unsigned short half_hash;\n@@ -227,56 +173,56 @@ bcache_full (const void *addr, int length, struct bcache *bcache, int *added)\n \n   /* Lazily initialize the obstack.  This can save quite a bit of\n      memory in some cases.  */\n-  if (bcache->total_count == 0)\n+  if (m_total_count == 0)\n     {\n       /* We could use obstack_specify_allocation here instead, but\n \t gdb_obstack.h specifies the allocation/deallocation\n \t functions.  */\n-      obstack_init (&bcache->cache);\n+      obstack_init (&m_cache);\n     }\n \n   /* If our average chain length is too high, expand the hash table.  */\n-  if (bcache->unique_count >= bcache->num_buckets * CHAIN_LENGTH_THRESHOLD)\n-    expand_hash_table (bcache);\n+  if (m_unique_count >= m_num_buckets * CHAIN_LENGTH_THRESHOLD)\n+    expand_hash_table ();\n \n-  bcache->total_count++;\n-  bcache->total_size += length;\n+  m_total_count++;\n+  m_total_size += length;\n \n-  full_hash = bcache->hash_function (addr, length);\n+  full_hash = m_hash_function (addr, length);\n \n   half_hash = (full_hash >> 16);\n-  hash_index = full_hash % bcache->num_buckets;\n+  hash_index = full_hash % m_num_buckets;\n \n-  /* Search the hash bucket for a string identical to the caller's.\n+  /* Search the hash m_bucket for a string identical to the caller's.\n      As a short-circuit first compare the upper part of each hash\n      values.  */\n-  for (s = bcache->bucket[hash_index]; s; s = s->next)\n+  for (s = m_bucket[hash_index]; s; s = s->next)\n     {\n       if (s->half_hash == half_hash)\n \t{\n \t  if (s->length == length\n-\t      && bcache->compare_function (&s->d.data, addr, length))\n+\t      && m_compare_function (&s->d.data, addr, length))\n \t    return &s->d.data;\n \t  else\n-\t    bcache->half_hash_miss_count++;\n+\t    m_half_hash_miss_count++;\n \t}\n     }\n \n   /* The user's string isn't in the list.  Insert it after *ps.  */\n   {\n     struct bstring *newobj\n-      = (struct bstring *) obstack_alloc (&bcache->cache,\n+      = (struct bstring *) obstack_alloc (&m_cache,\n \t\t\t\t\t  BSTRING_SIZE (length));\n \n     memcpy (&newobj->d.data, addr, length);\n     newobj->length = length;\n-    newobj->next = bcache->bucket[hash_index];\n+    newobj->next = m_bucket[hash_index];\n     newobj->half_hash = half_hash;\n-    bcache->bucket[hash_index] = newobj;\n+    m_bucket[hash_index] = newobj;\n \n-    bcache->unique_count++;\n-    bcache->unique_size += length;\n-    bcache->structure_size += BSTRING_SIZE (length);\n+    m_unique_count++;\n+    m_unique_size += length;\n+    m_structure_size += BSTRING_SIZE (length);\n \n     if (added)\n       *added = 1;\n@@ -289,51 +235,19 @@ bcache_full (const void *addr, int length, struct bcache *bcache, int *added)\n /* Compare the byte string at ADDR1 of lenght LENGHT to the\n    string at ADDR2.  Return 1 if they are equal.  */\n \n-static int\n-bcache_compare (const void *addr1, const void *addr2, int length)\n+int\n+bcache::compare (const void *addr1, const void *addr2, int length)\n {\n   return memcmp (addr1, addr2, length) == 0;\n }\n \n-/* Allocating and freeing bcaches.  */\n-\n-/* Allocated a bcache.  HASH_FUNCTION and COMPARE_FUNCTION can be used\n-   to pass in custom hash, and compare functions to be used by this\n-   bcache.  If HASH_FUNCTION is NULL hash() is used and if\n-   COMPARE_FUNCTION is NULL memcmp() is used.  */\n-\n-struct bcache *\n-bcache_xmalloc (unsigned long (*hash_function)(const void *, int length),\n-                int (*compare_function)(const void *, \n-\t\t\t\t\tconst void *, \n-\t\t\t\t\tint length))\n-{\n-  /* Allocate the bcache pre-zeroed.  */\n-  struct bcache *b = XCNEW (struct bcache);\n-\n-  if (hash_function)\n-    b->hash_function = hash_function;\n-  else\n-    b->hash_function = hash;\n-\n-  if (compare_function)\n-    b->compare_function = compare_function;\n-  else\n-    b->compare_function = bcache_compare;\n-  return b;\n-}\n-\n /* Free all the storage associated with BCACHE.  */\n-void\n-bcache_xfree (struct bcache *bcache)\n+bcache::~bcache ()\n {\n-  if (bcache == NULL)\n-    return;\n   /* Only free the obstack if we actually initialized it.  */\n-  if (bcache->total_count > 0)\n-    obstack_free (&bcache->cache, 0);\n-  xfree (bcache->bucket);\n-  xfree (bcache);\n+  if (m_total_count > 0)\n+    obstack_free (&m_cache, 0);\n+  xfree (m_bucket);\n }\n \n \n@@ -356,7 +270,7 @@ print_percentage (int portion, int total)\n    BCACHE holds.  Statistics are printed using `printf_filtered' and\n    its ilk.  */\n void\n-print_bcache_statistics (struct bcache *c, const char *type)\n+bcache::print_statistics (const char *type)\n {\n   int occupied_buckets;\n   int max_chain_length;\n@@ -368,15 +282,15 @@ print_bcache_statistics (struct bcache *c, const char *type)\n      lengths, and measure chain lengths.  */\n   {\n     unsigned int b;\n-    int *chain_length = XCNEWVEC (int, c->num_buckets + 1);\n-    int *entry_size = XCNEWVEC (int, c->unique_count + 1);\n+    int *chain_length = XCNEWVEC (int, m_num_buckets + 1);\n+    int *entry_size = XCNEWVEC (int, m_unique_count + 1);\n     int stringi = 0;\n \n     occupied_buckets = 0;\n \n-    for (b = 0; b < c->num_buckets; b++)\n+    for (b = 0; b < m_num_buckets; b++)\n       {\n-\tstruct bstring *s = c->bucket[b];\n+\tstruct bstring *s = m_bucket[b];\n \n \tchain_length[b] = 0;\n \n@@ -386,9 +300,9 @@ print_bcache_statistics (struct bcache *c, const char *type)\n \t    \n \t    while (s)\n \t      {\n-\t\tgdb_assert (b < c->num_buckets);\n+\t\tgdb_assert (b < m_num_buckets);\n \t\tchain_length[b]++;\n-\t\tgdb_assert (stringi < c->unique_count);\n+\t\tgdb_assert (stringi < m_unique_count);\n \t\tentry_size[stringi++] = s->length;\n \t\ts = s->next;\n \t      }\n@@ -397,25 +311,25 @@ print_bcache_statistics (struct bcache *c, const char *type)\n \n     /* To compute the median, we need the set of chain lengths\n        sorted.  */\n-    qsort (chain_length, c->num_buckets, sizeof (chain_length[0]),\n+    qsort (chain_length, m_num_buckets, sizeof (chain_length[0]),\n \t   compare_positive_ints);\n-    qsort (entry_size, c->unique_count, sizeof (entry_size[0]),\n+    qsort (entry_size, m_unique_count, sizeof (entry_size[0]),\n \t   compare_positive_ints);\n \n-    if (c->num_buckets > 0)\n+    if (m_num_buckets > 0)\n       {\n-\tmax_chain_length = chain_length[c->num_buckets - 1];\n-\tmedian_chain_length = chain_length[c->num_buckets / 2];\n+\tmax_chain_length = chain_length[m_num_buckets - 1];\n+\tmedian_chain_length = chain_length[m_num_buckets / 2];\n       }\n     else\n       {\n \tmax_chain_length = 0;\n \tmedian_chain_length = 0;\n       }\n-    if (c->unique_count > 0)\n+    if (m_unique_count > 0)\n       {\n-\tmax_entry_size = entry_size[c->unique_count - 1];\n-\tmedian_entry_size = entry_size[c->unique_count / 2];\n+\tmax_entry_size = entry_size[m_unique_count - 1];\n+\tmedian_entry_size = entry_size[m_unique_count / 2];\n       }\n     else\n       {\n@@ -427,23 +341,23 @@ print_bcache_statistics (struct bcache *c, const char *type)\n     xfree (entry_size);\n   }\n \n-  printf_filtered (_(\"  Cached '%s' statistics:\\n\"), type);\n-  printf_filtered (_(\"    Total object count:  %ld\\n\"), c->total_count);\n-  printf_filtered (_(\"    Unique object count: %lu\\n\"), c->unique_count);\n+  printf_filtered (_(\"  M_Cached '%s' statistics:\\n\"), type);\n+  printf_filtered (_(\"    Total object count:  %ld\\n\"), m_total_count);\n+  printf_filtered (_(\"    Unique object count: %lu\\n\"), m_unique_count);\n   printf_filtered (_(\"    Percentage of duplicates, by count: \"));\n-  print_percentage (c->total_count - c->unique_count, c->total_count);\n+  print_percentage (m_total_count - m_unique_count, m_total_count);\n   printf_filtered (\"\\n\");\n \n-  printf_filtered (_(\"    Total object size:   %ld\\n\"), c->total_size);\n-  printf_filtered (_(\"    Unique object size:  %ld\\n\"), c->unique_size);\n+  printf_filtered (_(\"    Total object size:   %ld\\n\"), m_total_size);\n+  printf_filtered (_(\"    Unique object size:  %ld\\n\"), m_unique_size);\n   printf_filtered (_(\"    Percentage of duplicates, by size:  \"));\n-  print_percentage (c->total_size - c->unique_size, c->total_size);\n+  print_percentage (m_total_size - m_unique_size, m_total_size);\n   printf_filtered (\"\\n\");\n \n   printf_filtered (_(\"    Max entry size:     %d\\n\"), max_entry_size);\n   printf_filtered (_(\"    Average entry size: \"));\n-  if (c->unique_count > 0)\n-    printf_filtered (\"%ld\\n\", c->unique_size / c->unique_count);\n+  if (m_unique_count > 0)\n+    printf_filtered (\"%ld\\n\", m_unique_size / m_unique_count);\n   else\n     /* i18n: \"Average entry size: (not applicable)\".  */\n     printf_filtered (_(\"(not applicable)\\n\"));    \n@@ -452,28 +366,28 @@ print_bcache_statistics (struct bcache *c, const char *type)\n \n   printf_filtered (_(\"    \\\n Total memory used by bcache, including overhead: %ld\\n\"),\n-\t\t   c->structure_size);\n+\t\t   m_structure_size);\n   printf_filtered (_(\"    Percentage memory overhead: \"));\n-  print_percentage (c->structure_size - c->unique_size, c->unique_size);\n+  print_percentage (m_structure_size - m_unique_size, m_unique_size);\n   printf_filtered (_(\"    Net memory savings:         \"));\n-  print_percentage (c->total_size - c->structure_size, c->total_size);\n+  print_percentage (m_total_size - m_structure_size, m_total_size);\n   printf_filtered (\"\\n\");\n \n   printf_filtered (_(\"    Hash table size:           %3d\\n\"), \n-\t\t   c->num_buckets);\n+\t\t   m_num_buckets);\n   printf_filtered (_(\"    Hash table expands:        %lu\\n\"),\n-\t\t   c->expand_count);\n+\t\t   m_expand_count);\n   printf_filtered (_(\"    Hash table hashes:         %lu\\n\"),\n-\t\t   c->total_count + c->expand_hash_count);\n+\t\t   m_total_count + m_expand_hash_count);\n   printf_filtered (_(\"    Half hash misses:          %lu\\n\"),\n-\t\t   c->half_hash_miss_count);\n+\t\t   m_half_hash_miss_count);\n   printf_filtered (_(\"    Hash table population:     \"));\n-  print_percentage (occupied_buckets, c->num_buckets);\n+  print_percentage (occupied_buckets, m_num_buckets);\n   printf_filtered (_(\"    Median hash chain length:  %3d\\n\"),\n \t\t   median_chain_length);\n   printf_filtered (_(\"    Average hash chain length: \"));\n-  if (c->num_buckets > 0)\n-    printf_filtered (\"%3lu\\n\", c->unique_count / c->num_buckets);\n+  if (m_num_buckets > 0)\n+    printf_filtered (\"%3lu\\n\", m_unique_count / m_num_buckets);\n   else\n     /* i18n: \"Average hash chain length: (not applicable)\".  */\n     printf_filtered (_(\"(not applicable)\\n\"));\n@@ -483,9 +397,9 @@ Total memory used by bcache, including overhead: %ld\\n\"),\n }\n \n int\n-bcache_memory_used (struct bcache *bcache)\n+bcache::memory_used ()\n {\n-  if (bcache->total_count == 0)\n+  if (m_total_count == 0)\n     return 0;\n-  return obstack_memory_used (&bcache->cache);\n+  return obstack_memory_used (&m_cache);\n }"
    },
    {
      "sha": "15dcc63440f144e659dd076904fc5dfe0236605b",
      "filename": "gdb/bcache.h",
      "status": "modified",
      "additions": 80,
      "deletions": 32,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/bcache.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/bcache.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bcache.h?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -136,41 +136,89 @@\n   \n */\n \n-\n-struct bcache;\n-\n-/* Find a copy of the LENGTH bytes at ADDR in BCACHE.  If BCACHE has\n-   never seen those bytes before, add a copy of them to BCACHE.  In\n-   either case, return a pointer to BCACHE's copy of that string.\n-   Since the cached value is ment to be read-only, return a const\n-   buffer.  */\n-extern const void *bcache (const void *addr, int length,\n-\t\t\t   struct bcache *bcache);\n-\n-/* Like bcache, but if ADDED is not NULL, set *ADDED to true if the\n-   bytes were newly added to the cache, or to false if the bytes were\n-   found in the cache.  */\n-extern const void *bcache_full (const void *addr, int length,\n-\t\t\t\tstruct bcache *bcache, int *added);\n-\n-/* Free all the storage used by BCACHE.  */\n-extern void bcache_xfree (struct bcache *bcache);\n-\n-/* Create a new bcache object.  */\n-extern struct bcache *bcache_xmalloc (\n-    unsigned long (*hash_function)(const void *, int length),\n-    int (*compare_function)(const void *, const void *, int length));\n-\n-/* Print statistics on BCACHE's memory usage and efficacity at\n-   eliminating duplication.  TYPE should be a string describing the\n-   kind of data BCACHE holds.  Statistics are printed using\n-   `printf_filtered' and its ilk.  */\n-extern void print_bcache_statistics (struct bcache *bcache, const char *type);\n-extern int bcache_memory_used (struct bcache *bcache);\n+struct bstring;\n \n /* The hash functions */\n-extern unsigned long hash(const void *addr, int length);\n+extern unsigned long hash (const void *addr, int length);\n extern unsigned long hash_continue (const void *addr, int length,\n                                     unsigned long h);\n \n+struct bcache\n+{\n+  /* Allocate a bcache.  HASH_FN and COMPARE_FN can be used to pass in\n+     custom hash, and compare functions to be used by this bcache.  If\n+     HASH_FUNCTION is NULL hash() is used and if COMPARE_FUNCTION is\n+     NULL memcmp() is used.  */\n+\n+  explicit bcache (unsigned long (*hash_fn)(const void *,\n+\t\t\t\t\t    int length) = nullptr,\n+\t\t   int (*compare_fn)(const void *, const void *,\n+\t\t\t\t     int length) = nullptr)\n+    : m_hash_function (hash_fn == nullptr ? hash : hash_fn),\n+      m_compare_function (compare_fn == nullptr ? compare : compare_fn)\n+  {\n+  }\n+\n+  ~bcache ();\n+\n+  /* Find a copy of the LENGTH bytes at ADDR in BCACHE.  If BCACHE has\n+     never seen those bytes before, add a copy of them to BCACHE.  In\n+     either case, return a pointer to BCACHE's copy of that string.\n+     Since the cached value is ment to be read-only, return a const\n+     buffer.  If ADDED is not NULL, set *ADDED to true if the bytes\n+     were newly added to the cache, or to false if the bytes were\n+     found in the cache.  */\n+\n+  const void *insert (const void *addr, int length, int *added = nullptr);\n+\n+  /* Print statistics on this bcache's memory usage and efficacity at\n+     eliminating duplication.  TYPE should be a string describing the\n+     kind of data this bcache holds.  Statistics are printed using\n+     `printf_filtered' and its ilk.  */\n+  void print_statistics (const char *type);\n+  int memory_used ();\n+\n+private:\n+\n+  /* All the bstrings are allocated here.  */\n+  struct obstack m_cache {};\n+\n+  /* How many hash buckets we're using.  */\n+  unsigned int m_num_buckets = 0;\n+\n+  /* Hash buckets.  This table is allocated using malloc, so when we\n+     grow the table we can return the old table to the system.  */\n+  struct bstring **m_bucket = nullptr;\n+\n+  /* Statistics.  */\n+  unsigned long m_unique_count = 0;\t/* number of unique strings */\n+  long m_total_count = 0;\t/* total number of strings cached, including dups */\n+  long m_unique_size = 0;\t/* size of unique strings, in bytes */\n+  long m_total_size = 0;      /* total number of bytes cached, including dups */\n+  long m_structure_size = 0;\t/* total size of bcache, including infrastructure */\n+  /* Number of times that the hash table is expanded and hence\n+     re-built, and the corresponding number of times that a string is\n+     [re]hashed as part of entering it into the expanded table.  The\n+     total number of hashes can be computed by adding TOTAL_COUNT to\n+     expand_hash_count.  */\n+  unsigned long m_expand_count = 0;\n+  unsigned long m_expand_hash_count = 0;\n+  /* Number of times that the half-hash compare hit (compare the upper\n+     16 bits of hash values) hit, but the corresponding combined\n+     length/data compare missed.  */\n+  unsigned long m_half_hash_miss_count = 0;\n+\n+  /* Hash function to be used for this bcache object.  */\n+  unsigned long (*m_hash_function)(const void *addr, int length);\n+\n+  /* Compare function to be used for this bcache object.  */\n+  int (*m_compare_function)(const void *, const void *, int length);\n+\n+  /* Default compare function.  */\n+  static int compare (const void *addr1, const void *addr2, int length);\n+\n+  /* Expand the hash table.  */\n+  void expand_hash_table ();\n+};\n+\n #endif /* BCACHE_H */"
    },
    {
      "sha": "9a23c8f52545299e664138163184334be7533bd3",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -122,7 +122,7 @@ buildsym_compunit::get_macro_table ()\n {\n   if (m_pending_macros == nullptr)\n     m_pending_macros = new_macro_table (&m_objfile->per_bfd->storage_obstack,\n-\t\t\t\t\tm_objfile->per_bfd->macro_cache,\n+\t\t\t\t\t&m_objfile->per_bfd->macro_cache,\n \t\t\t\t\tm_compunit_symtab);\n   return m_pending_macros;\n }"
    },
    {
      "sha": "0c59dcd20427fb56da99d6e382e151918d42d1ac",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -46,7 +46,6 @@\n #include \"macrotab.h\"\n #include \"language.h\"\n #include \"complaints.h\"\n-#include \"bcache.h\"\n #include \"dwarf2expr.h\"\n #include \"dwarf2loc.h\"\n #include \"cp-support.h\""
    },
    {
      "sha": "55a16bb2f8e1e5a08bc37c4b2d22df549b2ba4a4",
      "filename": "gdb/elfread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/elfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/elfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/elfread.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -334,8 +334,8 @@ elf_symtab_read (minimal_symbol_reader &reader,\n       if (sym->flags & BSF_FILE)\n \t{\n \t  filesymname\n-\t    = (const char *) bcache (sym->name, strlen (sym->name) + 1,\n-\t\t\t\t     objfile->per_bfd->filename_cache);\n+\t    = ((const char *) objfile->per_bfd->filename_cache.insert\n+\t       (sym->name, strlen (sym->name) + 1));\n \t}\n       else if (sym->flags & BSF_SECTION_SYM)\n \tcontinue;"
    },
    {
      "sha": "8e48587caa42fc7c47a7d986553512b2b087adc9",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 3,
      "deletions": 28,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -3732,7 +3732,7 @@ check_types_worklist (std::vector<type_equality_entry> *worklist,\n \n       /* If the type pair has already been visited, we know it is\n \t ok.  */\n-      bcache_full (&entry, sizeof (entry), cache, &added);\n+      cache->insert (&entry, sizeof (entry), &added);\n       if (!added)\n \tcontinue;\n \n@@ -3749,9 +3749,6 @@ check_types_worklist (std::vector<type_equality_entry> *worklist,\n bool\n types_deeply_equal (struct type *type1, struct type *type2)\n {\n-  struct gdb_exception except = exception_none;\n-  bool result = false;\n-  struct bcache *cache;\n   std::vector<type_equality_entry> worklist;\n \n   gdb_assert (type1 != NULL && type2 != NULL);\n@@ -3760,31 +3757,9 @@ types_deeply_equal (struct type *type1, struct type *type2)\n   if (type1 == type2)\n     return true;\n \n-  cache = bcache_xmalloc (NULL, NULL);\n-\n+  struct bcache cache (nullptr, nullptr);\n   worklist.emplace_back (type1, type2);\n-\n-  /* check_types_worklist calls several nested helper functions, some\n-     of which can raise a GDB exception, so we just check and rethrow\n-     here.  If there is a GDB exception, a comparison is not capable\n-     (or trusted), so exit.  */\n-  TRY\n-    {\n-      result = check_types_worklist (&worklist, cache);\n-    }\n-  CATCH (ex, RETURN_MASK_ALL)\n-    {\n-      except = ex;\n-    }\n-  END_CATCH\n-\n-  bcache_xfree (cache);\n-\n-  /* Rethrow if there was a problem.  */\n-  if (except.reason < 0)\n-    throw_exception (except);\n-\n-  return result;\n+  return check_types_worklist (&worklist, &cache);\n }\n \n /* Allocated status of type TYPE.  Return zero if type TYPE is allocated."
    },
    {
      "sha": "33a72a7271fb60937be47fd739e0374f25c0372a",
      "filename": "gdb/macroexp.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/macroexp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/macroexp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macroexp.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -19,7 +19,6 @@\n \n #include \"defs.h\"\n #include \"gdb_obstack.h\"\n-#include \"bcache.h\"\n #include \"macrotab.h\"\n #include \"macroexp.h\"\n #include \"c-lang.h\""
    },
    {
      "sha": "90f29439c098a0b187967db4678ca66d9a9057c9",
      "filename": "gdb/macrotab.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/macrotab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/macrotab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macrotab.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -113,7 +113,7 @@ static const void *\n macro_bcache (struct macro_table *t, const void *addr, int len)\n {\n   if (t->bcache)\n-    return bcache (addr, len, t->bcache);\n+    return t->bcache->insert (addr, len);\n   else\n     {\n       void *copy = xmalloc (len);"
    },
    {
      "sha": "4091b42dbf17fb404cc30b655bd36d8e1ffa7f87",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -157,8 +157,6 @@ get_objfile_bfd_data (struct objfile *objfile, struct bfd *abfd)\n       if (abfd != NULL)\n \tstorage->gdbarch = gdbarch_from_bfd (abfd);\n \n-      storage->filename_cache = bcache_xmalloc (NULL, NULL);\n-      storage->macro_cache = bcache_xmalloc (NULL, NULL);\n       storage->language_of_main = language_unknown;\n     }\n \n@@ -170,8 +168,6 @@ get_objfile_bfd_data (struct objfile *objfile, struct bfd *abfd)\n static void\n free_objfile_per_bfd_storage (struct objfile_per_bfd_storage *storage)\n {\n-  bcache_xfree (storage->filename_cache);\n-  bcache_xfree (storage->macro_cache);\n   if (storage->demangled_names_hash)\n     htab_delete (storage->demangled_names_hash);\n   storage->~objfile_per_bfd_storage ();"
    },
    {
      "sha": "c5ce9eec95546fc9d815b20601e8a8de81a3aada",
      "filename": "gdb/objfiles.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/objfiles.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/objfiles.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.h?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -240,11 +240,11 @@ struct objfile_per_bfd_storage\n \n   /* Byte cache for file names.  */\n \n-  struct bcache *filename_cache = NULL;\n+  struct bcache filename_cache;\n \n   /* Byte cache for macros.  */\n \n-  struct bcache *macro_cache = NULL;\n+  struct bcache macro_cache;\n \n   /* The gdbarch associated with the BFD.  Note that this gdbarch is\n      determined solely from BFD information, without looking at target"
    },
    {
      "sha": "96b4fa0bf88da0445c3d74ac686db51fd8c12f45",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 9,
      "deletions": 59,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -26,7 +26,6 @@\n #include \"source.h\"\n #include \"addrmap.h\"\n #include \"gdbtypes.h\"\n-#include \"bcache.h\"\n #include \"ui-out.h\"\n #include \"command.h\"\n #include \"readline/readline.h\"\n@@ -38,11 +37,6 @@\n #include <algorithm>\n #include <set>\n \n-struct psymbol_bcache\n-{\n-  struct bcache *bcache;\n-};\n-\n static struct partial_symbol *match_partial_symbol (struct objfile *,\n \t\t\t\t\t\t    struct partial_symtab *,\n \t\t\t\t\t\t    int,\n@@ -67,14 +61,16 @@ static struct compunit_symtab *psymtab_to_symtab (struct objfile *objfile,\n \n \f\n \n+static unsigned long psymbol_hash (const void *addr, int length);\n+static int psymbol_compare (const void *addr1, const void *addr2, int length);\n+\n psymtab_storage::psymtab_storage ()\n-  : psymbol_cache (psymbol_bcache_init ())\n+  : psymbol_cache (psymbol_hash, psymbol_compare)\n {\n }\n \n psymtab_storage::~psymtab_storage ()\n {\n-  psymbol_bcache_free (psymbol_cache);\n }\n \n /* See psymtab.h.  */\n@@ -1589,52 +1585,6 @@ psymbol_compare (const void *addr1, const void *addr2, int length)\n           && sym1->name == sym2->name);\n }\n \n-/* Initialize a partial symbol bcache.  */\n-\n-struct psymbol_bcache *\n-psymbol_bcache_init (void)\n-{\n-  struct psymbol_bcache *bcache = XCNEW (struct psymbol_bcache);\n-\n-  bcache->bcache = bcache_xmalloc (psymbol_hash, psymbol_compare);\n-  return bcache;\n-}\n-\n-/* Free a partial symbol bcache.  */\n-\n-void\n-psymbol_bcache_free (struct psymbol_bcache *bcache)\n-{\n-  if (bcache == NULL)\n-    return;\n-\n-  bcache_xfree (bcache->bcache);\n-  xfree (bcache);\n-}\n-\n-/* Return the internal bcache of the psymbol_bcache BCACHE.  */\n-\n-struct bcache *\n-psymbol_bcache_get_bcache (struct psymbol_bcache *bcache)\n-{\n-  return bcache->bcache;\n-}\n-\n-/* Find a copy of the SYM in BCACHE.  If BCACHE has never seen this\n-   symbol before, add a copy to BCACHE.  In either case, return a pointer\n-   to BCACHE's copy of the symbol.  If optional ADDED is not NULL, return\n-   1 in case of new entry or 0 if returning an old entry.  */\n-\n-static struct partial_symbol *\n-psymbol_bcache_full (struct partial_symbol *sym,\n-                     struct psymbol_bcache *bcache,\n-                     int *added)\n-{\n-  return ((struct partial_symbol *)\n-\t  bcache_full (sym, sizeof (struct partial_symbol), bcache->bcache,\n-\t\t       added));\n-}\n-\n /* Helper function, initialises partial symbol structure and stashes\n    it into objfile's bcache.  Note that our caching mechanism will\n    use all fields of struct partial_symbol to determine hash value of the\n@@ -1664,9 +1614,9 @@ add_psymbol_to_bcache (const char *name, int namelength, int copy_name,\n   symbol_set_names (&psymbol, name, namelength, copy_name, objfile->per_bfd);\n \n   /* Stash the partial symbol away in the cache.  */\n-  return psymbol_bcache_full (&psymbol,\n-\t\t\t      objfile->partial_symtabs->psymbol_cache,\n-\t\t\t      added);\n+  return ((struct partial_symbol *)\n+\t  objfile->partial_symtabs->psymbol_cache.insert\n+\t  (&psymbol, sizeof (struct partial_symbol), added));\n }\n \n /* Helper function, adds partial symbol to the given partial symbol list.  */\n@@ -1741,8 +1691,8 @@ allocate_psymtab (const char *filename, struct objfile *objfile)\n     = objfile->partial_symtabs->allocate_psymtab ();\n \n   psymtab->filename\n-    = (const char *) bcache (filename, strlen (filename) + 1,\n-\t\t\t     objfile->per_bfd->filename_cache);\n+    = ((const char *) objfile->per_bfd->filename_cache.insert\n+       (filename, strlen (filename) + 1));\n   psymtab->compunit_symtab = NULL;\n \n   if (symtab_create_debug)"
    },
    {
      "sha": "c761fa72222603a0f1d6d3e0a584256c1c22f0f4",
      "filename": "gdb/psymtab.h",
      "status": "modified",
      "additions": 2,
      "deletions": 9,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/psymtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/psymtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.h?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -23,13 +23,10 @@\n #include \"gdb_obstack.h\"\n #include \"symfile.h\"\n #include \"common/next-iterator.h\"\n+#include \"bcache.h\"\n \n struct partial_symbol;\n \n-/* A bcache for partial symbols.  */\n-\n-struct psymbol_bcache;\n-\n /* An instance of this class manages the partial symbol tables and\n    partial symbols for a given objfile.\n \n@@ -119,7 +116,7 @@ class psymtab_storage\n   /* A byte cache where we can stash arbitrary \"chunks\" of bytes that\n      will not change.  */\n \n-  struct psymbol_bcache *psymbol_cache;\n+  struct bcache psymbol_cache;\n \n   /* Vectors of all partial symbols read in from file.  The actual data\n      is stored in the objfile_obstack.  */\n@@ -140,10 +137,6 @@ class psymtab_storage\n };\n \n \n-extern struct psymbol_bcache *psymbol_bcache_init (void);\n-extern void psymbol_bcache_free (struct psymbol_bcache *);\n-extern struct bcache *psymbol_bcache_get_bcache (struct psymbol_bcache *);\n-\n extern const struct quick_symbol_functions psym_functions;\n \n extern const struct quick_symbol_functions dwarf2_gdb_index_functions;"
    },
    {
      "sha": "3f340dbf20d8a661a208aaeadc2dbe9329f87f27",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -44,7 +44,6 @@\n #include \"target-float.h\"\n #include \"cp-abi.h\"\n #include \"cp-support.h\"\n-#include \"bcache.h\"\n #include <ctype.h>\n \n #include \"stabsread.h\""
    },
    {
      "sha": "2214f16b4310a0dcfd810643cdcede428902d416",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -2795,8 +2795,8 @@ allocate_symtab (struct compunit_symtab *cust, const char *filename)\n     = OBSTACK_ZALLOC (&objfile->objfile_obstack, struct symtab);\n \n   symtab->filename\n-    = (const char *) bcache (filename, strlen (filename) + 1,\n-\t\t\t     objfile->per_bfd->filename_cache);\n+    = ((const char *) objfile->per_bfd->filename_cache.insert\n+       (filename, strlen (filename) + 1));\n   symtab->fullname = NULL;\n   symtab->language = deduce_language_from_filename (filename);\n "
    },
    {
      "sha": "cb0b5a52e47ef123357384402287cc7c3d8b644c",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 8,
      "deletions": 11,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/25629dfdb438c82f2bb711174042bb326a526aaf/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=25629dfdb438c82f2bb711174042bb326a526aaf",
      "patch": "@@ -69,13 +69,11 @@ print_symbol_bcache_statistics (void)\n \tQUIT;\n \tprintf_filtered (_(\"Byte cache statistics for '%s':\\n\"),\n \t\t\t objfile_name (objfile));\n-\tprint_bcache_statistics\n-\t  (psymbol_bcache_get_bcache (objfile->partial_symtabs->psymbol_cache),\n-\t   \"partial symbol cache\");\n-\tprint_bcache_statistics (objfile->per_bfd->macro_cache,\n-\t\t\t\t \"preprocessor macro cache\");\n-\tprint_bcache_statistics (objfile->per_bfd->filename_cache,\n-\t\t\t\t \"file name cache\");\n+\tobjfile->partial_symtabs->psymbol_cache.print_statistics\n+\t  (\"partial symbol cache\");\n+\tobjfile->per_bfd->macro_cache.print_statistics\n+\t  (\"preprocessor macro cache\");\n+\tobjfile->per_bfd->filename_cache.print_statistics (\"file name cache\");\n       }\n }\n \n@@ -136,12 +134,11 @@ print_objfile_statistics (void)\n \t\t\t\t\t\t       ->storage_obstack)));\n       printf_filtered\n \t(_(\"  Total memory used for psymbol cache: %d\\n\"),\n-\t bcache_memory_used (psymbol_bcache_get_bcache\n-\t\t\t     (objfile->partial_symtabs->psymbol_cache)));\n+\t objfile->partial_symtabs->psymbol_cache.memory_used ());\n       printf_filtered (_(\"  Total memory used for macro cache: %d\\n\"),\n-\t\t       bcache_memory_used (objfile->per_bfd->macro_cache));\n+\t\t       objfile->per_bfd->macro_cache.memory_used ());\n       printf_filtered (_(\"  Total memory used for file name cache: %d\\n\"),\n-\t\t       bcache_memory_used (objfile->per_bfd->filename_cache));\n+\t\t       objfile->per_bfd->filename_cache.memory_used ());\n     }\n }\n "
    }
  ]
}