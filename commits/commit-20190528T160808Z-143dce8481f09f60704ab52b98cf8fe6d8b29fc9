{
  "sha": "143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTQzZGNlODQ4MWYwOWY2MDcwNGFiNTJiOThjZjhmZTZkOGIyOWZjOQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-24T09:46:39Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:08:08Z"
    },
    "message": "libctf: ELF file opening via BFD\n\nThese functions let you open an ELF file with a customarily-named CTF\nsection in it, automatically opening the CTF file or archive and\nassociating the symbol and string tables in the ELF file with the CTF\ncontainer, so that you can look up the types of symbols in the ELF file\nvia ctf_lookup_by_symbol(), and so that strings can be shared between\nthe ELF file and CTF container, to save space.\n\nIt uses BFD machinery to do so.  This has now been lightly tested and\nseems to work.  In particular, if you already have a bfd you can pass\nit in to ctf_bfdopen(), and if you want a bfd made for you you can\ncall ctf_open() or ctf_fdopen(), optionally specifying a target (or\ntry once without a target and then again with one if you get\nECTF_BFD_AMBIGUOUS back).\n\nWe use a forward declaration for the struct bfd in ctf-api.h, so that\nctf-api.h users are not required to pull in <bfd.h>.  (This is mostly\nfor the sake of readelf.)\n\nlibctf/\n\t* ctf-open-bfd.c: New file.\n\t* ctf-open.c (ctf_close): New.\n\t* ctf-impl.h: Include bfd.h.\n\t(ctf_file): New members ctf_data_mmapped, ctf_data_mmapped_len.\n\t(ctf_archive_internal): New members ctfi_abfd, ctfi_data,\n\tctfi_bfd_close.\n\t(ctf_bfdopen_ctfsect): New declaration.\n\t(_CTF_SECTION): likewise.\n\ninclude/\n\t* ctf-api.h (struct bfd): New forward.\n\t(ctf_fdopen): New.\n\t(ctf_bfdopen): Likewise.\n\t(ctf_open): Likewise.\n\t(ctf_arc_open): Likewise.",
    "tree": {
      "sha": "0c7fdc61341278f34fc4e0e6d7cce936971ec3dc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0c7fdc61341278f34fc4e0e6d7cce936971ec3dc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9402cc593f4aa54677203efa9a92c4f28d3033eb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9402cc593f4aa54677203efa9a92c4f28d3033eb"
    }
  ],
  "stats": {
    "total": 404,
    "additions": 404,
    "deletions": 0
  },
  "files": [
    {
      "sha": "e8e80f872fc668ad4e6f4290d552472302fb30cb",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
      "patch": "@@ -1,3 +1,11 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (struct bfd): New forward.\n+\t(ctf_fdopen): New.\n+\t(ctf_bfdopen): Likewise.\n+\t(ctf_open): Likewise.\n+\t(ctf_arc_open): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf.h (CTFA_MAGIC): New."
    },
    {
      "sha": "ee68efefe37b9541d617d84dbe5685659ad9b208",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
      "patch": "@@ -45,6 +45,11 @@ typedef struct ctf_file ctf_file_t;\n typedef struct ctf_archive_internal ctf_archive_t;\n typedef long ctf_id_t;\n \n+/* This opaque definition allows libctf to accept BFD data structures without\n+   importing all the BFD noise into users' namespaces.  */\n+\n+struct bfd;\n+\n /* If the debugger needs to provide the CTF library with a set of raw buffers\n    for use as the CTF data, symbol table, and string table, it can do so by\n    filling in ctf_sect_t structures and passing them to ctf_bufopen().\n@@ -205,8 +210,23 @@ typedef int ctf_archive_member_f (ctf_file_t *fp, const char *name, void *arg);\n typedef int ctf_archive_raw_member_f (const char *name, const void *content,\n \t\t\t\t      size_t len, void *arg);\n \n+/* Opening.  These mostly return an abstraction over both CTF files and CTF\n+   archives: so they can be used to open both.  CTF files will appear to be an\n+   archive with one member named '.ctf'.  The low-level functions\n+   ctf_simple_open() and ctf_bufopen() return ctf_file_t's directly, and cannot\n+   be used on CTF archives.  */\n+\n+extern ctf_archive_t *ctf_bfdopen (struct bfd *, int *);\n+extern ctf_archive_t *ctf_bfdopen_ctfsect (struct bfd *, const ctf_sect_t *,\n+\t\t\t\t\t   int *);\n+extern ctf_archive_t *ctf_fdopen (int fd, const char *filename,\n+\t\t\t\t  const char *target, int *errp);\n+extern ctf_archive_t *ctf_open (const char *filename,\n+\t\t\t\tconst char *target, int *errp);\n+extern void ctf_close (ctf_archive_t *);\n extern ctf_sect_t ctf_getdatasect (const ctf_file_t *);\n extern ctf_archive_t *ctf_get_arc (const ctf_file_t *);\n+extern ctf_archive_t *ctf_arc_open (const char *, int *);\n extern void ctf_arc_close (ctf_archive_t *);\n extern ctf_file_t *ctf_arc_open_by_name (const ctf_archive_t *,\n \t\t\t\t\t const char *, int *);"
    },
    {
      "sha": "23a8b893ebc06cd8b8e915b3a67645b7c967ca1a",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
      "patch": "@@ -1,3 +1,14 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-open-bfd.c: New file.\n+\t* ctf-open.c (ctf_close): New.\n+\t* ctf-impl.h: Include bfd.h.\n+\t(ctf_file): New members ctf_data_mmapped, ctf_data_mmapped_len.\n+\t(ctf_archive_internal): New members ctfi_abfd, ctfi_data,\n+\tctfi_bfd_close.\n+\t(ctf_bfdopen_ctfsect): New declaration.\n+\t(_CTF_SECTION): likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-archive.c: New."
    },
    {
      "sha": "8522a032dd806614479f63478ded1da1cafd1647",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
      "patch": "@@ -31,6 +31,7 @@\n #include <limits.h>\n #include <ctype.h>\n #include <elf.h>\n+#include <bfd.h>\n \n #ifdef\t__cplusplus\n extern \"C\"\n@@ -188,6 +189,8 @@ struct ctf_file\n   ctf_sect_t ctf_data;\t\t    /* CTF data from object file.  */\n   ctf_sect_t ctf_symtab;\t    /* Symbol table from object file.  */\n   ctf_sect_t ctf_strtab;\t    /* String table from object file.  */\n+  void *ctf_data_mmapped;\t    /* CTF data we mmapped, to free later.  */\n+  size_t ctf_data_mmapped_len;\t    /* Length of CTF data we mmapped.  */\n   ctf_hash_t *ctf_structs;\t    /* Hash table of struct types.  */\n   ctf_hash_t *ctf_unions;\t    /* Hash table of union types.  */\n   ctf_hash_t *ctf_enums;\t    /* Hash table of enum types.  */\n@@ -240,6 +243,8 @@ struct ctf_archive_internal\n   ctf_sect_t ctfi_symsect;\n   ctf_sect_t ctfi_strsect;\n   void *ctfi_data;\n+  bfd *ctfi_abfd;\t\t    /* Optional source of section data.  */\n+  void (*ctfi_bfd_close) (struct ctf_archive_internal *);\n };\n \n /* Return x rounded up to an alignment boundary.\n@@ -358,6 +363,7 @@ extern Elf64_Sym *ctf_sym_to_elf64 (const Elf32_Sym *src, Elf64_Sym *dst);\n \n /* Variables, all underscore-prepended. */\n \n+extern const char _CTF_SECTION[];\t/* name of CTF ELF section */\n extern const char _CTF_NULLSTR[];\t/* empty string */\n \n extern int _libctf_debug;\t/* debugging messages enabled */"
    },
    {
      "sha": "d6d442ea42580b0510d59608447eddd7ed59a8d0",
      "filename": "libctf/ctf-open-bfd.c",
      "status": "added",
      "additions": 351,
      "deletions": 0,
      "changes": 351,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/libctf/ctf-open-bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/libctf/ctf-open-bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open-bfd.c?ref=143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
      "patch": "@@ -0,0 +1,351 @@\n+/* Opening CTF files with BFD.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <stddef.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <errno.h>\n+#include <string.h>\n+#include <fcntl.h>\n+#include <elf.h>\n+#include <bfd.h>\n+\n+#include \"elf-bfd.h\"\n+\n+/* Make a new struct ctf_archive_internal wrapper for a ctf_archive or a\n+   ctf_file.  Closes ARC and/or FP on error.  Arrange to free the SYMSECT and\n+   STRSECT interior on close.  */\n+\n+static struct ctf_archive_internal *\n+ctf_new_archive_internal (int is_archive, struct ctf_archive *arc,\n+\t\t\t  ctf_file_t *fp, const ctf_sect_t *symsect,\n+\t\t\t  const ctf_sect_t *strsect,\n+\t\t\t  int *errp)\n+{\n+  struct ctf_archive_internal *arci;\n+\n+  if ((arci = calloc (1, sizeof (struct ctf_archive_internal))) == NULL)\n+    {\n+      if (is_archive)\n+\tctf_arc_close_internal (arc);\n+      else\n+\tctf_file_close (fp);\n+      return (ctf_set_open_errno (errp, errno));\n+    }\n+  arci->ctfi_is_archive = is_archive;\n+  if (is_archive)\n+    arci->ctfi_archive = arc;\n+  else\n+    arci->ctfi_file = fp;\n+  if (symsect)\n+     memcpy (&arci->ctfi_symsect, symsect, sizeof (struct ctf_sect));\n+  if (strsect)\n+     memcpy (&arci->ctfi_strsect, strsect, sizeof (struct ctf_sect));\n+\n+  return arci;\n+}\n+\n+/* Free the BFD bits of a CTF file on ctf_file_close().  */\n+\n+static void\n+ctf_bfdclose (struct ctf_archive_internal *arci)\n+{\n+  if (arci->ctfi_abfd != NULL)\n+    if (!bfd_close_all_done (arci->ctfi_abfd))\n+      ctf_dprintf (\"Cannot close BFD: %s\\n\", bfd_errmsg (bfd_get_error()));\n+}\n+\n+/* Open a CTF file given the specified BFD.  */\n+\n+ctf_archive_t *\n+ctf_bfdopen (struct bfd *abfd, int *errp)\n+{\n+  ctf_archive_t *arc;\n+  asection *ctf_asect;\n+  bfd_byte *contents;\n+  ctf_sect_t ctfsect;\n+\n+  libctf_init_debug();\n+\n+  if ((ctf_asect = bfd_get_section_by_name (abfd, _CTF_SECTION)) == NULL)\n+    {\n+      return (ctf_set_open_errno (errp, ECTF_NOCTFDATA));\n+    }\n+\n+  if (!bfd_malloc_and_get_section (abfd, ctf_asect, &contents))\n+    {\n+      ctf_dprintf (\"ctf_bfdopen(): cannot malloc CTF section: %s\\n\",\n+\t\t   bfd_errmsg (bfd_get_error()));\n+      return (ctf_set_open_errno (errp, ECTF_FMT));\n+    }\n+\n+  ctfsect.cts_name = _CTF_SECTION;\n+  ctfsect.cts_type = SHT_PROGBITS;\n+  ctfsect.cts_flags = 0;\n+  ctfsect.cts_entsize = 1;\n+  ctfsect.cts_offset = 0;\n+  ctfsect.cts_size = bfd_section_size (abfd, ctf_asect);\n+  ctfsect.cts_data = contents;\n+\n+  if ((arc = ctf_bfdopen_ctfsect (abfd, &ctfsect, errp)) != NULL)\n+    {\n+      arc->ctfi_data = (void *) ctfsect.cts_data;\n+      return arc;\n+    }\n+\n+  free (contents);\n+  return NULL;\t\t\t\t/* errno is set for us.  */\n+}\n+\n+/* Open a CTF file given the specified BFD and CTF section (which may contain a\n+   CTF archive or a file).  Takes ownership of the ctfsect, and frees it\n+   later.  */\n+\n+ctf_archive_t *\n+ctf_bfdopen_ctfsect (struct bfd *abfd, const ctf_sect_t *ctfsect, int *errp)\n+{\n+  struct ctf_archive *arc = NULL;\n+  ctf_archive_t *arci;\n+  ctf_file_t *fp = NULL;\n+  ctf_sect_t *symsectp = NULL;\n+  ctf_sect_t *strsectp = NULL;\n+  const char *bfderrstr = NULL;\n+  int is_archive;\n+\n+  asection *sym_asect;\n+  ctf_sect_t symsect, strsect;\n+  /* TODO: handle SYMTAB_SHNDX.  */\n+\n+  if ((sym_asect = bfd_section_from_elf_index (abfd,\n+\t\t\t\t\t       elf_onesymtab (abfd))) != NULL)\n+    {\n+      Elf_Internal_Shdr *symhdr = &elf_symtab_hdr (abfd);\n+      asection *str_asect = NULL;\n+      bfd_byte *contents;\n+\n+      if (symhdr->sh_link != SHN_UNDEF &&\n+\t  symhdr->sh_link <= elf_numsections (abfd))\n+\tstr_asect = bfd_section_from_elf_index (abfd, symhdr->sh_link);\n+\n+      Elf_Internal_Shdr *strhdr = elf_elfsections (abfd)[symhdr->sh_link];\n+\n+      if (sym_asect && str_asect)\n+\t{\n+\t  if (!bfd_malloc_and_get_section (abfd, str_asect, &contents))\n+\t    {\n+\t      bfderrstr = \"Cannot malloc string table\";\n+\t      free (contents);\n+\t      goto err;\n+\t    }\n+\t  strsect.cts_data = contents;\n+\t  strsect.cts_name = (char *) strsect.cts_data + strhdr->sh_name;\n+\t  strsect.cts_type = strhdr->sh_type;\n+\t  strsect.cts_flags = strhdr->sh_flags;\n+\t  strsect.cts_entsize = strhdr->sh_size;\n+\t  strsect.cts_offset = strhdr->sh_offset;\n+\t  strsectp = &strsect;\n+\n+\t  if (!bfd_malloc_and_get_section (abfd, sym_asect, &contents))\n+\t    {\n+\t      bfderrstr = \"Cannot malloc symbol table\";\n+\t      free (contents);\n+\t      goto err_free_str;\n+\t    }\n+\n+\t  symsect.cts_name = (char *) strsect.cts_data + symhdr->sh_name;\n+\t  symsect.cts_type = symhdr->sh_type;\n+\t  symsect.cts_flags = symhdr->sh_flags;\n+\t  symsect.cts_entsize = symhdr->sh_size;\n+\t  symsect.cts_data = contents;\n+\t  symsect.cts_offset = symhdr->sh_offset;\n+\t  symsectp = &symsect;\n+\t}\n+    }\n+\n+  if (ctfsect->cts_size > sizeof (uint64_t) &&\n+      ((*(uint64_t *) ctfsect->cts_data) == CTFA_MAGIC))\n+    {\n+      is_archive = 1;\n+      if ((arc = ctf_arc_bufopen ((void *) ctfsect->cts_data,\n+\t\t\t\t  ctfsect->cts_size, errp)) == NULL)\n+\tgoto err_free_sym;\n+    }\n+  else\n+    {\n+      is_archive = 0;\n+      if ((fp = ctf_bufopen (ctfsect, symsectp, strsectp, errp)) == NULL)\n+\t{\n+\t  ctf_dprintf (\"ctf_internal_open(): cannot open CTF: %s\\n\",\n+\t\t       ctf_errmsg (*errp));\n+\t  goto err_free_sym;\n+\t}\n+    }\n+  arci = ctf_new_archive_internal (is_archive, arc, fp, symsectp, strsectp,\n+\t\t\t\t   errp);\n+\n+  if (arci)\n+    return arci;\n+ err_free_sym:\n+  free ((void *) symsect.cts_data);\n+err_free_str:\n+  free ((void *) strsect.cts_data);\n+err: _libctf_unused_;\n+  if (bfderrstr)\n+    {\n+      ctf_dprintf (\"ctf_bfdopen(): %s: %s\\n\", bfderrstr,\n+\t\t   bfd_errmsg (bfd_get_error()));\n+      ctf_set_open_errno (errp, ECTF_FMT);\n+    }\n+  return NULL;\n+}\n+\n+/* Open the specified file descriptor and return a pointer to a CTF archive that\n+   contains one or more CTF containers.  The file can be an ELF file, a raw CTF\n+   file, or a CTF archive.  The caller is responsible for closing the file\n+   descriptor when it is no longer needed.  If this is an ELF file, TARGET, if\n+   non-NULL, should be the name of a suitable BFD target.  */\n+\n+ctf_archive_t *\n+ctf_fdopen (int fd, const char *filename, const char *target, int *errp)\n+{\n+  ctf_archive_t *arci;\n+  bfd *abfd;\n+  int nfd;\n+\n+  struct stat st;\n+  ssize_t nbytes;\n+\n+  ctf_preamble_t ctfhdr;\n+  uint64_t arc_magic;\n+\n+  memset (&ctfhdr, 0, sizeof (ctfhdr));\n+\n+  libctf_init_debug();\n+\n+  if (fstat (fd, &st) == -1)\n+    return (ctf_set_open_errno (errp, errno));\n+\n+  if ((nbytes = ctf_pread (fd, &ctfhdr, sizeof (ctfhdr), 0)) <= 0)\n+    return (ctf_set_open_errno (errp, nbytes < 0 ? errno : ECTF_FMT));\n+\n+  /* If we have read enough bytes to form a CTF header and the magic\n+     string matches, attempt to interpret the file as raw CTF.  */\n+\n+  if ((size_t) nbytes >= sizeof (ctf_preamble_t) &&\n+      ctfhdr.ctp_magic == CTF_MAGIC)\n+    {\n+      ctf_file_t *fp = NULL;\n+      void *data;\n+\n+      if (ctfhdr.ctp_version > CTF_VERSION)\n+\treturn (ctf_set_open_errno (errp, ECTF_CTFVERS));\n+\n+      if ((data = ctf_mmap (st.st_size, 0, fd)) == NULL)\n+\treturn (ctf_set_open_errno (errp, errno));\n+\n+      if ((fp = ctf_simple_open (data, (size_t) st.st_size, NULL, 0, 0,\n+\t\t\t\t NULL, 0, errp)) == NULL)\n+\tctf_munmap (data, (size_t) st.st_size);\n+      fp->ctf_data_mmapped = data;\n+      fp->ctf_data_mmapped_len = (size_t) st.st_size;\n+\n+      return ctf_new_archive_internal (0, NULL, fp, NULL, NULL, errp);\n+    }\n+\n+  if ((nbytes = ctf_pread (fd, &arc_magic, sizeof (arc_magic), 0)) <= 0)\n+    return (ctf_set_open_errno (errp, nbytes < 0 ? errno : ECTF_FMT));\n+\n+  if ((size_t) nbytes >= sizeof (uint64_t) && arc_magic == CTFA_MAGIC)\n+    {\n+      struct ctf_archive *arc;\n+\n+      if ((arc = ctf_arc_open_internal (filename, errp)) == NULL)\n+\treturn NULL;\t\t\t/* errno is set for us.  */\n+\n+      return ctf_new_archive_internal (1, arc, NULL, NULL, NULL, errp);\n+    }\n+\n+  /* Attempt to open the file with BFD.  We must dup the fd first, since bfd\n+     takes ownership of the passed fd.  */\n+\n+  if ((nfd = dup (fd)) < 0)\n+      return (ctf_set_open_errno (errp, errno));\n+\n+  if ((abfd = bfd_fdopenr (filename, target, nfd)) == NULL)\n+    {\n+      ctf_dprintf (\"Cannot open BFD from %s: %s\\n\",\n+\t\t   filename ? filename : \"(unknown file)\",\n+\t\t   bfd_errmsg (bfd_get_error()));\n+      return (ctf_set_open_errno (errp, ECTF_FMT));\n+    }\n+\n+  if (!bfd_check_format (abfd, bfd_object))\n+    {\n+      ctf_dprintf (\"BFD format problem in %s: %s\\n\",\n+\t\t   filename ? filename : \"(unknown file)\",\n+\t\t   bfd_errmsg (bfd_get_error()));\n+      if (bfd_get_error() == bfd_error_file_ambiguously_recognized)\n+\treturn (ctf_set_open_errno (errp, ECTF_BFD_AMBIGUOUS));\n+      else\n+\treturn (ctf_set_open_errno (errp, ECTF_FMT));\n+    }\n+\n+  if ((arci = ctf_bfdopen (abfd, errp)) == NULL)\n+    {\n+      if (!bfd_close_all_done (abfd))\n+\tctf_dprintf (\"Cannot close BFD: %s\\n\", bfd_errmsg (bfd_get_error()));\n+      return NULL;\t\t\t/* errno is set for us.  */\n+    }\n+  arci->ctfi_bfd_close = ctf_bfdclose;\n+  arci->ctfi_abfd = abfd;\n+\n+  return arci;\n+}\n+\n+/* Open the specified file and return a pointer to a CTF container.  The file\n+   can be either an ELF file or raw CTF file.  This is just a convenient\n+   wrapper around ctf_fdopen() for callers.  */\n+\n+ctf_archive_t *\n+ctf_open (const char *filename, const char *target, int *errp)\n+{\n+  ctf_archive_t *arc;\n+  int fd;\n+\n+  if ((fd = open (filename, O_RDONLY)) == -1)\n+    {\n+      if (errp != NULL)\n+\t*errp = errno;\n+      return NULL;\n+    }\n+\n+  arc = ctf_fdopen (fd, filename, target, errp);\n+  (void) close (fd);\n+  return arc;\n+}\n+\n+/* Public entry point: open a CTF archive, or CTF file.  Returns the archive, or\n+   NULL and an error in *err.  Despite the fact that this uses CTF archives, it\n+   must be in this file to avoid dragging in BFD into non-BFD-using programs.  */\n+ctf_archive_t *\n+ctf_arc_open (const char *filename, int *errp)\n+{\n+  return ctf_open (filename, NULL, errp);\n+}"
    },
    {
      "sha": "5230d09a97fec5c1a40c3dd9a85b1bcf9d166366",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/143dce8481f09f60704ab52b98cf8fe6d8b29fc9/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=143dce8481f09f60704ab52b98cf8fe6d8b29fc9",
      "patch": "@@ -1572,6 +1572,14 @@ ctf_file_close (ctf_file_t *fp)\n   ctf_free (fp);\n }\n \n+/* The converse of ctf_open().  ctf_open() disguises whatever it opens as an\n+   archive, so closing one is just like closing an archive.  */\n+void\n+ctf_close (ctf_archive_t *arc)\n+{\n+  ctf_arc_close (arc);\n+}\n+\n /* Get the CTF archive from which this ctf_file_t is derived.  */\n ctf_archive_t *\n ctf_get_arc (const ctf_file_t *fp)"
    }
  ]
}