{
  "sha": "d3a70e03cf51c8fb6bc183eaff7559edffec2045",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDNhNzBlMDNjZjUxYzhmYjZiYzE4M2VhZmY3NTU5ZWRmZmVjMjA0NQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-03-04T19:05:03Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-03-12T16:45:35Z"
    },
    "message": "Change iterate_over_lwps to take a gdb::function_view\n\nThis changes iterate_over_lwps to use a gdb::function_view.  This was\nneeded in order to make null_ptid and minus_one_ptid 'const'.\n\ngdb/ChangeLog\n2019-03-12  Tom Tromey  <tromey@adacore.com>\n\n\t* linux-nat.c (iterate_over_lwps): Update.\n\t(stop_callback): Remove parameter.\n\t(stop_wait_callback, detach_callback, resume_set_callback)\n\t(select_singlestep_lwp_callback, set_ignore_sigint)\n\t(status_callback, resumed_callback, resume_clear_callback)\n\t(kill_callback, kill_wait_callback, linux_nat_stop_lwp): Remove\n\tdata parameter.\n\t(linux_nat_target::detach, linux_nat_target::resume)\n\t(linux_stop_and_wait_all_lwps, select_event_lwp)\n\t(linux_nat_filter_event, linux_nat_wait_1)\n\t(linux_nat_target::kill, linux_nat_target::stop)\n\t(linux_nat_target::stop): Update.\n\t(linux_nat_resume_callback): Change type.\n\t(resume_stopped_resumed_lwps, count_events_callback)\n\t(select_event_lwp_callback): Likewise.\n\t(linux_stop_lwp, linux_nat_stop_lwp): Update.\n\t* arm-linux-nat.c (struct update_registers_data): Remove.\n\t(update_registers_callback): Change type.\n\t(arm_linux_insert_hw_breakpoint1): Update.\n\t* nat/x86-linux-dregs.c (update_debug_registers_callback): Remove\n\tparameter.\n\t(x86_linux_dr_set_addr): Update.\n\t(x86_linux_dr_set_control): Update.\n\t* nat/linux-nat.h (iterate_over_lwps_ftype): Remove parameter.\n\t(iterate_over_lwps): Use gdb::function_view.\n\t* nat/aarch64-linux-hw-point.c (struct\n\taarch64_dr_update_callback_param): Remove.\n\t(debug_reg_change_callback): Change type.\n\t(aarch64_notify_debug_reg_change): Update.\n\t* s390-linux-nat.c (s390_refresh_per_info): Update.\n\ngdb/gdbserver/ChangeLog\n2019-03-12  Tom Tromey  <tromey@adacore.com>\n\n\t* linux-low.c (iterate_over_lwps): Update.",
    "tree": {
      "sha": "a482ecb424eec253f95a9a065f48d8ebeb1acd70",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a482ecb424eec253f95a9a065f48d8ebeb1acd70"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d3a70e03cf51c8fb6bc183eaff7559edffec2045",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3a70e03cf51c8fb6bc183eaff7559edffec2045",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d3a70e03cf51c8fb6bc183eaff7559edffec2045",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3a70e03cf51c8fb6bc183eaff7559edffec2045/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7a6e0d89bb018cef0d8d13c497d8f340aa2a0fc8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7a6e0d89bb018cef0d8d13c497d8f340aa2a0fc8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7a6e0d89bb018cef0d8d13c497d8f340aa2a0fc8"
    }
  ],
  "stats": {
    "total": 252,
    "additions": 143,
    "deletions": 109
  },
  "files": [
    {
      "sha": "5e9beb9b7a6736e36ff49df448dd38a3e6d74c25",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -1,3 +1,36 @@\n+2019-03-12  Tom Tromey  <tromey@adacore.com>\n+\n+\t* linux-nat.c (iterate_over_lwps): Update.\n+\t(stop_callback): Remove parameter.\n+\t(stop_wait_callback, detach_callback, resume_set_callback)\n+\t(select_singlestep_lwp_callback, set_ignore_sigint)\n+\t(status_callback, resumed_callback, resume_clear_callback)\n+\t(kill_callback, kill_wait_callback, linux_nat_stop_lwp): Remove\n+\tdata parameter.\n+\t(linux_nat_target::detach, linux_nat_target::resume)\n+\t(linux_stop_and_wait_all_lwps, select_event_lwp)\n+\t(linux_nat_filter_event, linux_nat_wait_1)\n+\t(linux_nat_target::kill, linux_nat_target::stop)\n+\t(linux_nat_target::stop): Update.\n+\t(linux_nat_resume_callback): Change type.\n+\t(resume_stopped_resumed_lwps, count_events_callback)\n+\t(select_event_lwp_callback): Likewise.\n+\t(linux_stop_lwp, linux_nat_stop_lwp): Update.\n+\t* arm-linux-nat.c (struct update_registers_data): Remove.\n+\t(update_registers_callback): Change type.\n+\t(arm_linux_insert_hw_breakpoint1): Update.\n+\t* nat/x86-linux-dregs.c (update_debug_registers_callback): Remove\n+\tparameter.\n+\t(x86_linux_dr_set_addr): Update.\n+\t(x86_linux_dr_set_control): Update.\n+\t* nat/linux-nat.h (iterate_over_lwps_ftype): Remove parameter.\n+\t(iterate_over_lwps): Use gdb::function_view.\n+\t* nat/aarch64-linux-hw-point.c (struct\n+\taarch64_dr_update_callback_param): Remove.\n+\t(debug_reg_change_callback): Change type.\n+\t(aarch64_notify_debug_reg_change): Update.\n+\t* s390-linux-nat.c (s390_refresh_per_info): Update.\n+\n 2019-03-11  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf2read.c (dwarf2_find_containing_comp_unit): Remove"
    },
    {
      "sha": "8c98a7189fe4090e6b6fc8712f24fb7dd0905471",
      "filename": "gdb/arm-linux-nat.c",
      "status": "modified",
      "additions": 10,
      "deletions": 16,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/arm-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/arm-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-linux-nat.c?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -952,26 +952,18 @@ arm_linux_hw_breakpoint_equal (const struct arm_linux_hw_breakpoint *p1,\n /* Callback to mark a watch-/breakpoint to be updated in all threads of\n    the current process.  */\n \n-struct update_registers_data\n-{\n-  int watch;\n-  int index;\n-};\n-\n static int\n-update_registers_callback (struct lwp_info *lwp, void *arg)\n+update_registers_callback (struct lwp_info *lwp, int watch, int index)\n {\n-  struct update_registers_data *data = (struct update_registers_data *) arg;\n-\n   if (lwp->arch_private == NULL)\n     lwp->arch_private = XCNEW (struct arch_lwp_info);\n \n   /* The actual update is done later just before resuming the lwp,\n      we just mark that the registers need updating.  */\n-  if (data->watch)\n-    lwp->arch_private->wpts_changed[data->index] = 1;\n+  if (watch)\n+    lwp->arch_private->wpts_changed[index] = 1;\n   else\n-    lwp->arch_private->bpts_changed[data->index] = 1;\n+    lwp->arch_private->bpts_changed[index] = 1;\n \n   /* If the lwp isn't stopped, force it to momentarily pause, so\n      we can update its breakpoint registers.  */\n@@ -991,7 +983,6 @@ arm_linux_insert_hw_breakpoint1 (const struct arm_linux_hw_breakpoint* bpt,\n   ptid_t pid_ptid;\n   gdb_byte count, i;\n   struct arm_linux_hw_breakpoint* bpts;\n-  struct update_registers_data data;\n \n   pid = inferior_ptid.pid ();\n   pid_ptid = ptid_t (pid);\n@@ -1010,10 +1001,13 @@ arm_linux_insert_hw_breakpoint1 (const struct arm_linux_hw_breakpoint* bpt,\n   for (i = 0; i < count; ++i)\n     if (!arm_hwbp_control_is_enabled (bpts[i].control))\n       {\n-        data.watch = watchpoint;\n-        data.index = i;\n         bpts[i] = *bpt;\n-        iterate_over_lwps (pid_ptid, update_registers_callback, &data);\n+        iterate_over_lwps (pid_ptid,\n+\t\t\t   [=] (struct lwp_info *info)\n+\t\t\t   {\n+\t\t\t     return update_registers_callback (info, watch,\n+\t\t\t\t\t\t\t       index);\n+\t\t\t   });\n         break;\n       }\n "
    },
    {
      "sha": "3eb9ec05efaa58f3a14fd801667a4672cc1133e2",
      "filename": "gdb/gdbserver/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/ChangeLog?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -1,3 +1,7 @@\n+2019-03-12  Tom Tromey  <tromey@adacore.com>\n+\n+\t* linux-low.c (iterate_over_lwps): Update.\n+\n 2019-03-06  Tom Tromey  <tom@tromey.com>\n \n \t* server.c (detach_or_kill_for_exit_cleanup): Remove parameter."
    },
    {
      "sha": "b1a9d1289902ed6a88a7d1dbd731da4ec48b5e29",
      "filename": "gdb/gdbserver/linux-low.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/gdbserver/linux-low.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/gdbserver/linux-low.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/linux-low.c?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -1843,14 +1843,13 @@ num_lwps (int pid)\n \n struct lwp_info *\n iterate_over_lwps (ptid_t filter,\n-\t\t   iterate_over_lwps_ftype callback,\n-\t\t   void *data)\n+\t\t   gdb::function_view<iterate_over_lwps_ftype> callback)\n {\n   thread_info *thread = find_thread (filter, [&] (thread_info *thr_arg)\n     {\n       lwp_info *lwp = get_thread_lwp (thr_arg);\n \n-      return callback (lwp, data);\n+      return callback (lwp);\n     });\n \n   if (thread == NULL)"
    },
    {
      "sha": "ad5ec3d0b570bffd8be895321108dcec36f1c5fb",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 75,
      "deletions": 63,
      "changes": 138,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -262,8 +262,7 @@ async_file_mark (void)\n \n static int kill_lwp (int lwpid, int signo);\n \n-static int stop_callback (struct lwp_info *lp, void *data);\n-static int resume_stopped_resumed_lwps (struct lwp_info *lp, void *data);\n+static int stop_callback (struct lwp_info *lp);\n \n static void block_child_signals (sigset_t *prev_mask);\n static void restore_child_signals_mask (sigset_t *prev_mask);\n@@ -807,8 +806,8 @@ linux_nat_target::pass_signals\n \f\n \n /* Prototypes for local functions.  */\n-static int stop_wait_callback (struct lwp_info *lp, void *data);\n-static int resume_stopped_resumed_lwps (struct lwp_info *lp, void *data);\n+static int stop_wait_callback (struct lwp_info *lp);\n+static int resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid);\n static int check_ptrace_stopped_lwp_gone (struct lwp_info *lp);\n \n \f\n@@ -960,8 +959,7 @@ find_lwp_pid (ptid_t ptid)\n \n struct lwp_info *\n iterate_over_lwps (ptid_t filter,\n-\t\t   iterate_over_lwps_ftype callback,\n-\t\t   void *data)\n+\t\t   gdb::function_view<iterate_over_lwps_ftype> callback)\n {\n   struct lwp_info *lp, *lpnext;\n \n@@ -971,7 +969,7 @@ iterate_over_lwps (ptid_t filter,\n \n       if (lp->ptid.matches (filter))\n \t{\n-\t  if ((*callback) (lp, data) != 0)\n+\t  if (callback (lp) != 0)\n \t    return lp;\n \t}\n     }\n@@ -1456,7 +1454,7 @@ detach_one_lwp (struct lwp_info *lp, int *signo_p)\n }\n \n static int\n-detach_callback (struct lwp_info *lp, void *data)\n+detach_callback (struct lwp_info *lp)\n {\n   /* We don't actually detach from the thread group leader just yet.\n      If the thread group exits, we must reap the zombie clone lwps\n@@ -1477,12 +1475,12 @@ linux_nat_target::detach (inferior *inf, int from_tty)\n \n   /* Stop all threads before detaching.  ptrace requires that the\n      thread is stopped to sucessfully detach.  */\n-  iterate_over_lwps (ptid_t (pid), stop_callback, NULL);\n+  iterate_over_lwps (ptid_t (pid), stop_callback);\n   /* ... and wait until all of them have reported back that\n      they're no longer running.  */\n-  iterate_over_lwps (ptid_t (pid), stop_wait_callback, NULL);\n+  iterate_over_lwps (ptid_t (pid), stop_wait_callback);\n \n-  iterate_over_lwps (ptid_t (pid), detach_callback, NULL);\n+  iterate_over_lwps (ptid_t (pid), detach_callback);\n \n   /* Only the initial process should be left right now.  */\n   gdb_assert (num_lwps (pid) == 1);\n@@ -1646,7 +1644,7 @@ resume_lwp (struct lwp_info *lp, int step, enum gdb_signal signo)\n    Resume LWP with the last stop signal, if it is in pass state.  */\n \n static int\n-linux_nat_resume_callback (struct lwp_info *lp, void *except)\n+linux_nat_resume_callback (struct lwp_info *lp, struct lwp_info *except)\n {\n   enum gdb_signal signo = GDB_SIGNAL_0;\n \n@@ -1670,15 +1668,15 @@ linux_nat_resume_callback (struct lwp_info *lp, void *except)\n }\n \n static int\n-resume_clear_callback (struct lwp_info *lp, void *data)\n+resume_clear_callback (struct lwp_info *lp)\n {\n   lp->resumed = 0;\n   lp->last_resume_kind = resume_stop;\n   return 0;\n }\n \n static int\n-resume_set_callback (struct lwp_info *lp, void *data)\n+resume_set_callback (struct lwp_info *lp)\n {\n   lp->resumed = 1;\n   lp->last_resume_kind = resume_continue;\n@@ -1705,7 +1703,7 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n \t\t || ptid.is_pid ());\n \n   /* Mark the lwps we're resuming as resumed.  */\n-  iterate_over_lwps (ptid, resume_set_callback, NULL);\n+  iterate_over_lwps (ptid, resume_set_callback);\n \n   /* See if it's the current inferior that should be handled\n      specially.  */\n@@ -1766,7 +1764,10 @@ linux_nat_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n     }\n \n   if (resume_many)\n-    iterate_over_lwps (ptid, linux_nat_resume_callback, lp);\n+    iterate_over_lwps (ptid, [=] (struct lwp_info *info)\n+\t\t\t     {\n+\t\t\t       return linux_nat_resume_callback (info, lp);\n+\t\t\t     });\n \n   if (debug_linux_nat)\n     fprintf_unfiltered (gdb_stdlog,\n@@ -2305,7 +2306,7 @@ wait_lwp (struct lwp_info *lp)\n /* Send a SIGSTOP to LP.  */\n \n static int\n-stop_callback (struct lwp_info *lp, void *data)\n+stop_callback (struct lwp_info *lp)\n {\n   if (!lp->stopped && !lp->signalled)\n     {\n@@ -2339,7 +2340,7 @@ stop_callback (struct lwp_info *lp, void *data)\n void\n linux_stop_lwp (struct lwp_info *lwp)\n {\n-  stop_callback (lwp, NULL);\n+  stop_callback (lwp);\n }\n \n /* See linux-nat.h  */\n@@ -2348,11 +2349,11 @@ void\n linux_stop_and_wait_all_lwps (void)\n {\n   /* Stop all LWP's ...  */\n-  iterate_over_lwps (minus_one_ptid, stop_callback, NULL);\n+  iterate_over_lwps (minus_one_ptid, stop_callback);\n \n   /* ... and wait until all of them have reported back that\n      they're no longer running.  */\n-  iterate_over_lwps (minus_one_ptid, stop_wait_callback, NULL);\n+  iterate_over_lwps (minus_one_ptid, stop_wait_callback);\n }\n \n /* See linux-nat.h  */\n@@ -2361,7 +2362,10 @@ void\n linux_unstop_all_lwps (void)\n {\n   iterate_over_lwps (minus_one_ptid,\n-\t\t     resume_stopped_resumed_lwps, &minus_one_ptid);\n+\t\t     [] (struct lwp_info *info)\n+\t\t     {\n+\t\t       return resume_stopped_resumed_lwps (info, minus_one_ptid);\n+\t\t     });\n }\n \n /* Return non-zero if LWP PID has a pending SIGINT.  */\n@@ -2383,7 +2387,7 @@ linux_nat_has_pending_sigint (int pid)\n /* Set a flag in LP indicating that we should ignore its next SIGINT.  */\n \n static int\n-set_ignore_sigint (struct lwp_info *lp, void *data)\n+set_ignore_sigint (struct lwp_info *lp)\n {\n   /* If a thread has a pending SIGINT, consume it; otherwise, set a\n      flag to consume the next one.  */\n@@ -2484,7 +2488,7 @@ linux_nat_target::low_status_is_event (int status)\n /* Wait until LP is stopped.  */\n \n static int\n-stop_wait_callback (struct lwp_info *lp, void *data)\n+stop_wait_callback (struct lwp_info *lp)\n {\n   struct inferior *inf = find_inferior_ptid (lp->ptid);\n \n@@ -2516,7 +2520,7 @@ stop_wait_callback (struct lwp_info *lp, void *data)\n \t\t\t\ttarget_pid_to_str (lp->ptid),\n \t\t\t\terrno ? safe_strerror (errno) : \"OK\");\n \n-\t  return stop_wait_callback (lp, NULL);\n+\t  return stop_wait_callback (lp);\n \t}\n \n       maybe_clear_ignore_sigint (lp);\n@@ -2566,7 +2570,7 @@ stop_wait_callback (struct lwp_info *lp, void *data)\n    caused the stop became uninteresting.  */\n \n static int\n-status_callback (struct lwp_info *lp, void *data)\n+status_callback (struct lwp_info *lp)\n {\n   /* Only report a pending wait status if we pretend that this has\n      indeed been resumed.  */\n@@ -2628,10 +2632,8 @@ status_callback (struct lwp_info *lp, void *data)\n /* Count the LWP's that have had events.  */\n \n static int\n-count_events_callback (struct lwp_info *lp, void *data)\n+count_events_callback (struct lwp_info *lp, int *count)\n {\n-  int *count = (int *) data;\n-\n   gdb_assert (count != NULL);\n \n   /* Select only resumed LWPs that have an event pending.  */\n@@ -2644,7 +2646,7 @@ count_events_callback (struct lwp_info *lp, void *data)\n /* Select the LWP (if any) that is currently being single-stepped.  */\n \n static int\n-select_singlestep_lwp_callback (struct lwp_info *lp, void *data)\n+select_singlestep_lwp_callback (struct lwp_info *lp)\n {\n   if (lp->last_resume_kind == resume_step\n       && lp->status != 0)\n@@ -2667,10 +2669,8 @@ lwp_status_pending_p (struct lwp_info *lp)\n /* Select the Nth LWP that has had an event.  */\n \n static int\n-select_event_lwp_callback (struct lwp_info *lp, void *data)\n+select_event_lwp_callback (struct lwp_info *lp, int *selector)\n {\n-  int *selector = (int *) data;\n-\n   gdb_assert (selector != NULL);\n \n   /* Select only resumed LWPs that have an event pending.  */\n@@ -2869,8 +2869,7 @@ select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)\n      signal.  */\n   if (!target_is_non_stop_p ())\n     {\n-      event_lp = iterate_over_lwps (filter,\n-\t\t\t\t    select_singlestep_lwp_callback, NULL);\n+      event_lp = iterate_over_lwps (filter, select_singlestep_lwp_callback);\n       if (event_lp != NULL)\n \t{\n \t  if (debug_linux_nat)\n@@ -2885,7 +2884,11 @@ select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)\n       /* Pick one at random, out of those which have had events.  */\n \n       /* First see how many events we have.  */\n-      iterate_over_lwps (filter, count_events_callback, &num_events);\n+      iterate_over_lwps (filter,\n+\t\t\t [&] (struct lwp_info *info)\n+\t\t\t {\n+\t\t\t   return count_events_callback (info, &num_events);\n+\t\t\t });\n       gdb_assert (num_events > 0);\n \n       /* Now randomly pick a LWP out of those that have had\n@@ -2898,9 +2901,14 @@ select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)\n \t\t\t    \"SEL: Found %d events, selecting #%d\\n\",\n \t\t\t    num_events, random_selector);\n \n-      event_lp = iterate_over_lwps (filter,\n-\t\t\t\t    select_event_lwp_callback,\n-\t\t\t\t    &random_selector);\n+      event_lp\n+\t= (iterate_over_lwps\n+\t   (filter,\n+\t    [&] (struct lwp_info *info)\n+\t    {\n+\t      return select_event_lwp_callback (info,\n+\t\t\t\t\t\t&random_selector);\n+\t    }));\n     }\n \n   if (event_lp != NULL)\n@@ -2917,7 +2925,7 @@ select_event_lwp (ptid_t filter, struct lwp_info **orig_lp, int *status)\n /* Return non-zero if LP has been resumed.  */\n \n static int\n-resumed_callback (struct lwp_info *lp, void *data)\n+resumed_callback (struct lwp_info *lp)\n {\n   return lp->resumed;\n }\n@@ -3136,8 +3144,7 @@ linux_nat_filter_event (int lwpid, int status)\n \t\t will receive it - unless they're using CLONE_THREAD to\n \t\t share signals.  Since we only want to report it once, we\n \t\t mark it as ignored for all LWPs except this one.  */\n-\t      iterate_over_lwps (ptid_t (lp->ptid.pid ()),\n-\t\t\t\t\t      set_ignore_sigint, NULL);\n+\t      iterate_over_lwps (ptid_t (lp->ptid.pid ()), set_ignore_sigint);\n \t      lp->ignore_sigint = 0;\n \t    }\n \t  else\n@@ -3279,7 +3286,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   block_child_signals (&prev_mask);\n \n   /* First check if there is a LWP with a wait status pending.  */\n-  lp = iterate_over_lwps (ptid, status_callback, NULL);\n+  lp = iterate_over_lwps (ptid, status_callback);\n   if (lp != NULL)\n     {\n       if (debug_linux_nat)\n@@ -3336,11 +3343,14 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n       /* Now that we've pulled all events out of the kernel, resume\n \t LWPs that don't have an interesting event to report.  */\n       iterate_over_lwps (minus_one_ptid,\n-\t\t\t resume_stopped_resumed_lwps, &minus_one_ptid);\n+\t\t\t [] (struct lwp_info *info)\n+\t\t\t {\n+\t\t\t   return resume_stopped_resumed_lwps (info, minus_one_ptid);\n+\t\t\t });\n \n       /* ... and find an LWP with a status to report to the core, if\n \t any.  */\n-      lp = iterate_over_lwps (ptid, status_callback, NULL);\n+      lp = iterate_over_lwps (ptid, status_callback);\n       if (lp != NULL)\n \tbreak;\n \n@@ -3350,7 +3360,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n       /* If there are no resumed children left, bail.  We'd be stuck\n \t forever in the sigsuspend call below otherwise.  */\n-      if (iterate_over_lwps (ptid, resumed_callback, NULL) == NULL)\n+      if (iterate_over_lwps (ptid, resumed_callback) == NULL)\n \t{\n \t  if (debug_linux_nat)\n \t    fprintf_unfiltered (gdb_stdlog, \"LLW: exit (no resumed LWP)\\n\");\n@@ -3388,11 +3398,11 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   if (!target_is_non_stop_p ())\n     {\n       /* Now stop all other LWP's ...  */\n-      iterate_over_lwps (minus_one_ptid, stop_callback, NULL);\n+      iterate_over_lwps (minus_one_ptid, stop_callback);\n \n       /* ... and wait until all of them have reported back that\n \t they're no longer running.  */\n-      iterate_over_lwps (minus_one_ptid, stop_wait_callback, NULL);\n+      iterate_over_lwps (minus_one_ptid, stop_wait_callback);\n     }\n \n   /* If we're not waiting for a specific LWP, choose an event LWP from\n@@ -3431,11 +3441,11 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n     {\n       /* In all-stop, from the core's perspective, all LWPs are now\n \t stopped until a new resume action is sent over.  */\n-      iterate_over_lwps (minus_one_ptid, resume_clear_callback, NULL);\n+      iterate_over_lwps (minus_one_ptid, resume_clear_callback);\n     }\n   else\n     {\n-      resume_clear_callback (lp, NULL);\n+      resume_clear_callback (lp);\n     }\n \n   if (linux_target->low_status_is_event (status))\n@@ -3485,10 +3495,8 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n    to report, but are resumed from the core's perspective.  */\n \n static int\n-resume_stopped_resumed_lwps (struct lwp_info *lp, void *data)\n+resume_stopped_resumed_lwps (struct lwp_info *lp, const ptid_t wait_ptid)\n {\n-  ptid_t *wait_ptid_p = (ptid_t *) data;\n-\n   if (!lp->stopped)\n     {\n       if (debug_linux_nat)\n@@ -3522,7 +3530,7 @@ resume_stopped_resumed_lwps (struct lwp_info *lp, void *data)\n \n \t  /* Don't bother if there's a breakpoint at PC that we'd hit\n \t     immediately, and we're not waiting for this LWP.  */\n-\t  if (!lp->ptid.matches (*wait_ptid_p))\n+\t  if (!lp->ptid.matches (wait_ptid))\n \t    {\n \t      if (breakpoint_inserted_here_p (regcache->aspace (), pc))\n \t\tleave_stopped = 1;\n@@ -3579,7 +3587,11 @@ linux_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n      meanwhile the event became uninteresting.  Don't bother resuming\n      LWPs we're not going to wait for if they'd stop immediately.  */\n   if (target_is_non_stop_p ())\n-    iterate_over_lwps (minus_one_ptid, resume_stopped_resumed_lwps, &ptid);\n+    iterate_over_lwps (minus_one_ptid,\n+\t\t       [=] (struct lwp_info *info)\n+\t\t       {\n+\t\t\t return resume_stopped_resumed_lwps (info, ptid);\n+\t\t       });\n \n   event_ptid = linux_nat_wait_1 (ptid, ourstatus, target_options);\n \n@@ -3662,7 +3674,7 @@ kill_wait_one_lwp (pid_t pid)\n /* Callback for iterate_over_lwps.  */\n \n static int\n-kill_callback (struct lwp_info *lp, void *data)\n+kill_callback (struct lwp_info *lp)\n {\n   kill_one_lwp (lp->ptid.lwp ());\n   return 0;\n@@ -3671,7 +3683,7 @@ kill_callback (struct lwp_info *lp, void *data)\n /* Callback for iterate_over_lwps.  */\n \n static int\n-kill_wait_callback (struct lwp_info *lp, void *data)\n+kill_wait_callback (struct lwp_info *lp)\n {\n   kill_wait_one_lwp (lp->ptid.lwp ());\n   return 0;\n@@ -3720,16 +3732,16 @@ linux_nat_target::kill ()\n \n       /* Stop all threads before killing them, since ptrace requires\n \t that the thread is stopped to sucessfully PTRACE_KILL.  */\n-      iterate_over_lwps (ptid, stop_callback, NULL);\n+      iterate_over_lwps (ptid, stop_callback);\n       /* ... and wait until all of them have reported back that\n \t they're no longer running.  */\n-      iterate_over_lwps (ptid, stop_wait_callback, NULL);\n+      iterate_over_lwps (ptid, stop_wait_callback);\n \n       /* Kill all LWP's ...  */\n-      iterate_over_lwps (ptid, kill_callback, NULL);\n+      iterate_over_lwps (ptid, kill_callback);\n \n       /* ... and wait until we've flushed all events.  */\n-      iterate_over_lwps (ptid, kill_wait_callback, NULL);\n+      iterate_over_lwps (ptid, kill_wait_callback);\n     }\n \n   target_mourn_inferior (inferior_ptid);\n@@ -4415,7 +4427,7 @@ linux_nat_target::async (int enable)\n    event came out.  */\n \n static int\n-linux_nat_stop_lwp (struct lwp_info *lwp, void *data)\n+linux_nat_stop_lwp (struct lwp_info *lwp)\n {\n   if (!lwp->stopped)\n     {\n@@ -4435,7 +4447,7 @@ linux_nat_stop_lwp (struct lwp_info *lwp, void *data)\n \t  return 0;\n \t}\n \n-      stop_callback (lwp, NULL);\n+      stop_callback (lwp);\n       lwp->last_resume_kind = resume_stop;\n     }\n   else\n@@ -4461,7 +4473,7 @@ linux_nat_stop_lwp (struct lwp_info *lwp, void *data)\n void\n linux_nat_target::stop (ptid_t ptid)\n {\n-  iterate_over_lwps (ptid, linux_nat_stop_lwp, NULL);\n+  iterate_over_lwps (ptid, linux_nat_stop_lwp);\n }\n \n void"
    },
    {
      "sha": "1efec9a268cc9a0dd2fda99fe362ee40c79a01fd",
      "filename": "gdb/nat/aarch64-linux-hw-point.c",
      "status": "modified",
      "additions": 9,
      "deletions": 18,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/nat/aarch64-linux-hw-point.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/nat/aarch64-linux-hw-point.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/aarch64-linux-hw-point.c?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -278,27 +278,17 @@ aarch64_align_watchpoint (CORE_ADDR addr, int len, CORE_ADDR *aligned_addr_p,\n     *next_addr_orig_p = align_down (*next_addr_orig_p + alignment, alignment);\n }\n \n-struct aarch64_dr_update_callback_param\n-{\n-  int is_watchpoint;\n-  unsigned int idx;\n-};\n-\n-/* Callback for iterate_over_lwps.  Records the\n+/* Helper for aarch64_notify_debug_reg_change.  Records the\n    information about the change of one hardware breakpoint/watchpoint\n    setting for the thread LWP.\n-   The information is passed in via PTR.\n    N.B.  The actual updating of hardware debug registers is not\n    carried out until the moment the thread is resumed.  */\n \n static int\n-debug_reg_change_callback (struct lwp_info *lwp, void *ptr)\n+debug_reg_change_callback (struct lwp_info *lwp, int is_watchpoint,\n+\t\t\t   unsigned int idx)\n {\n-  struct aarch64_dr_update_callback_param *param_p\n-    = (struct aarch64_dr_update_callback_param *) ptr;\n   int tid = ptid_of_lwp (lwp).lwp ();\n-  int idx = param_p->idx;\n-  int is_watchpoint = param_p->is_watchpoint;\n   struct arch_lwp_info *info = lwp_arch_private_info (lwp);\n   dr_changed_t *dr_changed_ptr;\n   dr_changed_t dr_changed;\n@@ -356,13 +346,14 @@ static void\n aarch64_notify_debug_reg_change (const struct aarch64_debug_reg_state *state,\n \t\t\t\t int is_watchpoint, unsigned int idx)\n {\n-  struct aarch64_dr_update_callback_param param;\n   ptid_t pid_ptid = ptid_t (current_lwp_ptid ().pid ());\n \n-  param.is_watchpoint = is_watchpoint;\n-  param.idx = idx;\n-\n-  iterate_over_lwps (pid_ptid, debug_reg_change_callback, (void *) &param);\n+  iterate_over_lwps (pid_ptid, [=] (struct lwp_info *info)\n+\t\t\t       {\n+\t\t\t\t return debug_reg_change_callback (info,\n+\t\t\t\t\t\t\t\t   is_watchpoint,\n+\t\t\t\t\t\t\t\t   idx);\n+\t\t\t       });\n }\n \n /* Reconfigure STATE to be compatible with Linux kernels with the PR"
    },
    {
      "sha": "29f43d8dfa56de4645a65f175f31c0492a5feb50",
      "filename": "gdb/nat/linux-nat.h",
      "status": "modified",
      "additions": 5,
      "deletions": 4,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/nat/linux-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/nat/linux-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/linux-nat.h?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -20,6 +20,7 @@\n #ifndef NAT_LINUX_NAT_H\n #define NAT_LINUX_NAT_H\n \n+#include \"common/function-view.h\"\n #include \"target/waitstatus.h\"\n \n struct lwp_info;\n@@ -43,17 +44,17 @@ struct arch_lwp_info;\n extern ptid_t current_lwp_ptid (void);\n \n /* Function type for the CALLBACK argument of iterate_over_lwps.  */\n-typedef int (iterate_over_lwps_ftype) (struct lwp_info *lwp, void *arg);\n+typedef int (iterate_over_lwps_ftype) (struct lwp_info *lwp);\n \n /* Iterate over all LWPs.  Calls CALLBACK with its second argument set\n    to DATA for every LWP in the list.  If CALLBACK returns nonzero for\n    a particular LWP, return a pointer to the structure describing that\n    LWP immediately.  Otherwise return NULL.  This function must be\n    provided by the client.  */\n \n-extern struct lwp_info *iterate_over_lwps (ptid_t filter,\n-\t\t\t\t\t   iterate_over_lwps_ftype callback,\n-\t\t\t\t\t   void *data);\n+extern struct lwp_info *iterate_over_lwps\n+    (ptid_t filter,\n+     gdb::function_view<iterate_over_lwps_ftype> callback);\n \n /* Return the ptid of LWP.  */\n "
    },
    {
      "sha": "29b4ee16b60aeb6a8067f0b0308ef9dcf2e079a7",
      "filename": "gdb/nat/x86-linux-dregs.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/nat/x86-linux-dregs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/nat/x86-linux-dregs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/x86-linux-dregs.c?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -76,7 +76,7 @@ x86_linux_dr_set (ptid_t ptid, int regnum, unsigned long value)\n    the actual debug registers immediately prior to LWP resuming.  */\n \n static int\n-update_debug_registers_callback (struct lwp_info *lwp, void *arg)\n+update_debug_registers_callback (struct lwp_info *lwp)\n {\n   lwp_set_debug_registers_changed (lwp, 1);\n \n@@ -106,7 +106,7 @@ x86_linux_dr_set_addr (int regnum, CORE_ADDR addr)\n \n   gdb_assert (DR_FIRSTADDR <= regnum && regnum <= DR_LASTADDR);\n \n-  iterate_over_lwps (pid_ptid, update_debug_registers_callback, NULL);\n+  iterate_over_lwps (pid_ptid, update_debug_registers_callback);\n }\n \n /* See nat/x86-linux-dregs.h.  */\n@@ -124,7 +124,7 @@ x86_linux_dr_set_control (unsigned long control)\n {\n   ptid_t pid_ptid = ptid_t (current_lwp_ptid ().pid ());\n \n-  iterate_over_lwps (pid_ptid, update_debug_registers_callback, NULL);\n+  iterate_over_lwps (pid_ptid, update_debug_registers_callback);\n }\n \n /* See nat/x86-linux-dregs.h.  */"
    },
    {
      "sha": "5f6c5be8e023a8f0d092816856df5efecdb8526d",
      "filename": "gdb/s390-linux-nat.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/s390-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a70e03cf51c8fb6bc183eaff7559edffec2045/gdb/s390-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-linux-nat.c?ref=d3a70e03cf51c8fb6bc183eaff7559edffec2045",
      "patch": "@@ -833,7 +833,7 @@ s390_linux_nat_target::low_delete_thread (struct arch_lwp_info *arch_lwp)\n /* Iterator callback for s390_refresh_per_info.  */\n \n static int\n-s390_refresh_per_info_cb (struct lwp_info *lp, void *arg)\n+s390_refresh_per_info_cb (struct lwp_info *lp)\n {\n   s390_mark_per_info_changed (lp);\n \n@@ -849,7 +849,7 @@ s390_refresh_per_info (void)\n {\n   ptid_t pid_ptid = ptid_t (current_lwp_ptid ().pid ());\n \n-  iterate_over_lwps (pid_ptid, s390_refresh_per_info_cb, NULL);\n+  iterate_over_lwps (pid_ptid, s390_refresh_per_info_cb);\n   return 0;\n }\n "
    }
  ]
}