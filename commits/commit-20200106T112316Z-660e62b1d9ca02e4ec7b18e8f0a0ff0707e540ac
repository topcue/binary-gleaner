{
  "sha": "660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjYwZTYyYjFkOWNhMDJlNGVjN2IxOGU4ZjBhMGZmMDcwN2U1NDBhYw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-05T22:22:39Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-06T11:23:16Z"
    },
    "message": "PR25344, z80 disassembler recursion\n\n\tPR 25344\n\t* z80-dis.c (suffix): Don't use a local struct buffer copy.\n\tPeek at next byte to prevent recursion on repeated prefix bytes.\n\tEnsure uninitialised \"mybuf\" is not accessed.\n\t(print_insn_z80): Don't zero n_fetch and n_used here,..\n\t(print_insn_z80_buf): ..do it here instead.",
    "tree": {
      "sha": "c6e6dd4219926ac7d44d2d0562879ca90f43d1a5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c6e6dd4219926ac7d44d2d0562879ca90f43d1a5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "01335edbac3f0fa0c06d088598e09f602833de87",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/01335edbac3f0fa0c06d088598e09f602833de87",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/01335edbac3f0fa0c06d088598e09f602833de87"
    }
  ],
  "stats": {
    "total": 69,
    "additions": 40,
    "deletions": 29
  },
  "files": [
    {
      "sha": "92ba6558c7fb00fd4b5f8a58bc99a79d383bbad2",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac",
      "patch": "@@ -1,3 +1,12 @@\n+2020-01-06  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25344\n+\t* z80-dis.c (suffix): Don't use a local struct buffer copy.\n+\tPeek at next byte to prevent recursion on repeated prefix bytes.\n+\tEnsure uninitialised \"mybuf\" is not accessed.\n+\t(print_insn_z80): Don't zero n_fetch and n_used here,..\n+\t(print_insn_z80_buf): ..do it here instead.\n+\n 2020-01-04  Alan Modra  <amodra@gmail.com>\n \n \t* m32r-ibld.c: Regenerate."
    },
    {
      "sha": "581d4f4871249aaf883ddf771c775bebfc7acb55",
      "filename": "opcodes/z80-dis.c",
      "status": "modified",
      "additions": 31,
      "deletions": 29,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac/opcodes/z80-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac/opcodes/z80-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/z80-dis.c?ref=660e62b1d9ca02e4ec7b18e8f0a0ff0707e540ac",
      "patch": "@@ -713,55 +713,57 @@ static int\n print_insn_z80_buf (struct buffer *buf, disassemble_info *info);\n \n static int\n-suffix (struct buffer *buf_in, disassemble_info *info, const char *txt)\n+suffix (struct buffer *buf, disassemble_info *info, const char *txt)\n {\n-  struct buffer buf;\n   char mybuf[TXTSIZ*4];\n   fprintf_ftype old_fprintf;\n   void *old_stream;\n   char *p;\n \n-  buf_in->n_used++;\n-  buf = *buf_in;\n-  buf.n_fetch = 0;\n-  buf.n_used = 0;\n-  buf.base++;\n   switch (txt[2])\n     {\n     case 'l': /* SIL or LIL */\n-      buf.nn_len = 3;\n+      buf->nn_len = 3;\n       break;\n     case 's': /* SIS or LIS */\n-      buf.nn_len = 2;\n+      buf->nn_len = 2;\n       break;\n     default:\n-      /* unknown suffix */\n-      return -1;\n+      abort ();\n+    }\n+  if (!fetch_data (buf, info, 1)\n+      || buf->data[1] == 0x40\n+      || buf->data[1] == 0x49\n+      || buf->data[1] == 0x52\n+      || buf->data[1] == 0x5b)\n+    {\n+      /* Double prefix, or end of data.  */\n+      info->fprintf_func (info->stream, \"nop ;%s\", txt);\n+      buf->n_used = 1;\n+      return buf->n_used;\n     }\n+\n   old_fprintf = info->fprintf_func;\n   old_stream = info->stream;\n-  info->fprintf_func = (fprintf_ftype)&sprintf;\n+  info->fprintf_func = (fprintf_ftype) &sprintf;\n   info->stream = mybuf;\n-  print_insn_z80_buf(&buf, info);\n+  buf->base++;\n+  if (print_insn_z80_buf (buf, info) >= 0)\n+    buf->n_used++;\n   info->fprintf_func = old_fprintf;\n   info->stream = old_stream;\n \n-  for (p = &mybuf[0]; *p && *p != ' ' && *p != '.'; ++p)\n-    ;\n-\n-  if (*p == '.') /* suffix already present */\n+  for (p = mybuf; *p; ++p)\n+    if (*p == ' ')\n+      break;\n+  if (*p)\n     {\n-      info->fprintf_func(info->stream, \"nop ;%s\", txt); /* double prefix */\n-      return buf_in->n_used;\n+      *p++ = '\\0';\n+      info->fprintf_func (info->stream, \"%s.%s %s\", mybuf, txt, p);\n     }\n-\n-  *p++ = '\\0';\n-  info->fprintf_func(info->stream, *p ? \"%s.%s %s\" : \"%s.%s\", mybuf, txt, p);\n-\n-  memcpy(&buf_in->data[1], buf.data, sizeof(buf.data)-1);\n-  buf_in->n_used += buf.n_used;\n-  buf_in->n_fetch += buf.n_fetch;\n-  return buf_in->n_used;\n+  else\n+    info->fprintf_func (info->stream, \"%s.%s\", mybuf, txt);\n+  return buf->n_used;\n }\n \n /* Table to disassemble machine codes without prefix.  */\n@@ -839,8 +841,6 @@ print_insn_z80 (bfd_vma addr, disassemble_info * info)\n   struct buffer buf;\n \n   buf.base = addr;\n-  buf.n_fetch = 0;\n-  buf.n_used = 0;\n   buf.inss = 1 << info->mach;\n   buf.nn_len = info->mach == bfd_mach_ez80_adl ? 3 : 2;\n   info->bytes_per_line = (buf.inss & INSS_EZ80) ? 6 : 4; /* <ss pp oo nn mm MM> OR <pp oo nn mm> */\n@@ -853,6 +853,8 @@ print_insn_z80_buf (struct buffer *buf, disassemble_info *info)\n {\n   struct tab_elt *p;\n \n+  buf->n_fetch = 0;\n+  buf->n_used = 0;\n   if (! fetch_data (buf, info, 1))\n     return -1;\n "
    }
  ]
}