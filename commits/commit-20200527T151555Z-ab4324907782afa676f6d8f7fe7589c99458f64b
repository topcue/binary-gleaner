{
  "sha": "ab4324907782afa676f6d8f7fe7589c99458f64b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWI0MzI0OTA3NzgyYWZhNjc2ZjZkOGY3ZmU3NTg5Yzk5NDU4ZjY0Yg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-05-27T15:13:55Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:15:55Z"
    },
    "message": "Add dwarf2_per_objfile parameter to cutu_reader's constructors\n\nThe cutu_reader type is used for reading the CU represented by the\npassed dwarf2_per_cu_data object.  This reading is done in the context\nof a given obfile, which is currently the one associated to the passed\ndwarf2_per_cu_data object.  Since the dwarf2_per_cu_data type will\nbecome objfile-independent, we will need to pass the objfile separately.\n\nThis patch therefore adds a dwarf2_per_objfile parameter to the\ncutu_reader constructors, as well as to their callers, up until the\npoint where we can get the dwarf2_per_objfile object from somewhere\nelse.  In the end, this allows removing the reference to\ndwarf2_per_cu_data::dwarf2_per_objfile in cutu_reader::cutu_reader.\n\nA few dwarf2_per_cu_data::dwarf2_per_objfile references are added (e.g.\nin dwarf2_fetch_die_type_sect_off).  This is temporary, this will be\nremoved once these functions will get re-worked in subsequent patches.\n\ngdb/ChangeLog:\n\n\t* dwarf2/read.c (class cutu_reader) <cutu_reader>: Add\n\tper_objfile parameter.\n\t(load_full_type_unit): Add per_objfile parameter.\n\t(read_signatured_type): Likewise.\n\t(load_full_comp_unit): Likewise.\n\t(load_cu): Likewise.\n\t(dw2_do_instantiate_symtab): Likewise.\n\t(dw2_get_file_names): Likewise.\n\t(dw2_map_symtabs_matching_filename): Update.\n\t(dw_expand_symtabs_matching_file_matcher): Update.\n\t(dw2_map_symbol_filenames): Update.\n\t(process_psymtab_comp_unit): Add per_objfile parameter.\n\t(build_type_psymtabs_1): Update.\n\t(process_skeletonless_type_unit): Update.\n\t(dwarf2_build_psymtabs_hard): Update.\n\t(load_partial_comp_unit): Add per_objfile parameter.\n\t(scan_partial_symbols): Update.\n\t(load_full_comp_unit): Add per_objfile parameter.\n\t(process_imported_unit_die): Update.\n\t(create_cus_hash_table): Update.\n\t(find_partial_die): Update.\n\t(dwarf2_read_addr_index): Update.\n\t(follow_die_offset): Update.\n\t(dwarf2_fetch_die_loc_sect_off): Update.\n\t(dwarf2_fetch_constant_bytes): Update.\n\t(dwarf2_fetch_die_type_sect_off): Update.\n\t(follow_die_sig_1): Update.\n\t(load_full_type_unit): Add per_objfile parameter.\n\t(read_signatured_type): Likewise.\n\nChange-Id: Ibd7bbc443df8b9b8b6f96ff18e93a60ee721b85f",
    "tree": {
      "sha": "a602f487f5ff0bae43d9bbbdca62ce002c98a225",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a602f487f5ff0bae43d9bbbdca62ce002c98a225"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ab4324907782afa676f6d8f7fe7589c99458f64b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ab4324907782afa676f6d8f7fe7589c99458f64b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ab4324907782afa676f6d8f7fe7589c99458f64b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ab4324907782afa676f6d8f7fe7589c99458f64b/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "313bad1bc60b24722cd44c196acf3482b5b63efd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/313bad1bc60b24722cd44c196acf3482b5b63efd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/313bad1bc60b24722cd44c196acf3482b5b63efd"
    }
  ],
  "stats": {
    "total": 153,
    "additions": 103,
    "deletions": 50
  },
  "files": [
    {
      "sha": "d6c28a5a84ba4d355ba34683e4e02e1b4aa9e694",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ab4324907782afa676f6d8f7fe7589c99458f64b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ab4324907782afa676f6d8f7fe7589c99458f64b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=ab4324907782afa676f6d8f7fe7589c99458f64b",
      "patch": "@@ -1,3 +1,35 @@\n+2020-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* dwarf2/read.c (class cutu_reader) <cutu_reader>: Add\n+\tper_objfile parameter.\n+\t(load_full_type_unit): Add per_objfile parameter.\n+\t(read_signatured_type): Likewise.\n+\t(load_full_comp_unit): Likewise.\n+\t(load_cu): Likewise.\n+\t(dw2_do_instantiate_symtab): Likewise.\n+\t(dw2_get_file_names): Likewise.\n+\t(dw2_map_symtabs_matching_filename): Update.\n+\t(dw_expand_symtabs_matching_file_matcher): Update.\n+\t(dw2_map_symbol_filenames): Update.\n+\t(process_psymtab_comp_unit): Add per_objfile parameter.\n+\t(build_type_psymtabs_1): Update.\n+\t(process_skeletonless_type_unit): Update.\n+\t(dwarf2_build_psymtabs_hard): Update.\n+\t(load_partial_comp_unit): Add per_objfile parameter.\n+\t(scan_partial_symbols): Update.\n+\t(load_full_comp_unit): Add per_objfile parameter.\n+\t(process_imported_unit_die): Update.\n+\t(create_cus_hash_table): Update.\n+\t(find_partial_die): Update.\n+\t(dwarf2_read_addr_index): Update.\n+\t(follow_die_offset): Update.\n+\t(dwarf2_fetch_die_loc_sect_off): Update.\n+\t(dwarf2_fetch_constant_bytes): Update.\n+\t(dwarf2_fetch_die_type_sect_off): Update.\n+\t(follow_die_sig_1): Update.\n+\t(load_full_type_unit): Add per_objfile parameter.\n+\t(read_signatured_type): Likewise.\n+\n 2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* dwarf2/read.c (lookup_dwo_unit): Use bfd_get_filename instead"
    },
    {
      "sha": "ec32804bd1d654f446769da602382a2334ab9d58",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 71,
      "deletions": 50,
      "changes": 121,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ab4324907782afa676f6d8f7fe7589c99458f64b/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ab4324907782afa676f6d8f7fe7589c99458f64b/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=ab4324907782afa676f6d8f7fe7589c99458f64b",
      "patch": "@@ -912,12 +912,14 @@ class cutu_reader : public die_reader_specs\n {\n public:\n \n-  cutu_reader (struct dwarf2_per_cu_data *this_cu,\n+  cutu_reader (dwarf2_per_cu_data *this_cu,\n+\t       dwarf2_per_objfile *per_objfile,\n \t       struct abbrev_table *abbrev_table,\n \t       int use_existing_cu,\n \t       bool skip_partial);\n \n   explicit cutu_reader (struct dwarf2_per_cu_data *this_cu,\n+\t\t\tdwarf2_per_objfile *per_objfile,\n \t\t\tstruct dwarf2_cu *parent_cu = nullptr,\n \t\t\tstruct dwo_file *dwo_file = nullptr);\n \n@@ -1510,9 +1512,11 @@ static struct type *get_DW_AT_signature_type (struct die_info *,\n \t\t\t\t\t      const struct attribute *,\n \t\t\t\t\t      struct dwarf2_cu *);\n \n-static void load_full_type_unit (struct dwarf2_per_cu_data *per_cu);\n+static void load_full_type_unit (dwarf2_per_cu_data *per_cu,\n+\t\t\t\t dwarf2_per_objfile *per_objfile);\n \n-static void read_signatured_type (struct signatured_type *);\n+static void read_signatured_type (signatured_type *sig_type,\n+\t\t\t\t  dwarf2_per_objfile *per_objfile);\n \n static int attr_to_dynamic_prop (const struct attribute *attr,\n \t\t\t\t struct die_info *die, struct dwarf2_cu *cu,\n@@ -1562,8 +1566,10 @@ static void create_all_comp_units (struct dwarf2_per_objfile *dwarf2_per_objfile\n \n static int create_all_type_units (struct dwarf2_per_objfile *dwarf2_per_objfile);\n \n-static void load_full_comp_unit (struct dwarf2_per_cu_data *, bool,\n-\t\t\t\t enum language);\n+static void load_full_comp_unit (dwarf2_per_cu_data *per_cu,\n+\t\t\t\t dwarf2_per_objfile *per_objfile,\n+\t\t\t\t bool skip_partial,\n+\t\t\t\t enum language pretend_language);\n \n static void process_full_comp_unit (struct dwarf2_per_cu_data *,\n \t\t\t\t    enum language);\n@@ -2323,17 +2329,18 @@ create_quick_file_names_table (unsigned int nr_initial_entries)\n \t\t\t\t     delete_file_name_entry, xcalloc, xfree));\n }\n \n-/* Read in PER_CU->CU.  This function is unrelated to symtabs, symtab would\n-   have to be created afterwards.  You should call age_cached_comp_units after\n-   processing PER_CU->CU.  dw2_setup must have been already called.  */\n+/* Read in CU (dwarf2_cu object) for PER_CU in the context of PER_OBJFILE.  This\n+   function is unrelated to symtabs, symtab would have to be created afterwards.\n+   You should call age_cached_comp_units after processing the CU.  */\n \n static void\n-load_cu (struct dwarf2_per_cu_data *per_cu, bool skip_partial)\n+load_cu (dwarf2_per_cu_data *per_cu, dwarf2_per_objfile *per_objfile,\n+\t bool skip_partial)\n {\n   if (per_cu->is_debug_types)\n-    load_full_type_unit (per_cu);\n+    load_full_type_unit (per_cu, per_objfile);\n   else\n-    load_full_comp_unit (per_cu, skip_partial, language_minimal);\n+    load_full_comp_unit (per_cu, per_objfile, skip_partial, language_minimal);\n \n   if (per_cu->cu == NULL)\n     return;  /* Dummy CU.  */\n@@ -2361,7 +2368,7 @@ dw2_do_instantiate_symtab (dwarf2_per_cu_data *per_cu,\n   if (!dwarf2_per_objfile->symtab_set_p (per_cu))\n     {\n       queue_comp_unit (per_cu, language_minimal);\n-      load_cu (per_cu, skip_partial);\n+      load_cu (per_cu, dwarf2_per_objfile, skip_partial);\n \n       /* If we just loaded a CU from a DWO, and we're working with an index\n \t that may badly handle TUs, load all the TUs in that DWO as well.\n@@ -3212,7 +3219,8 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n    table for THIS_CU.  */\n \n static struct quick_file_names *\n-dw2_get_file_names (struct dwarf2_per_cu_data *this_cu)\n+dw2_get_file_names (dwarf2_per_cu_data *this_cu,\n+\t\t    dwarf2_per_objfile *per_objfile)\n {\n   /* This should never be called for TUs.  */\n   gdb_assert (! this_cu->is_debug_types);\n@@ -3225,7 +3233,7 @@ dw2_get_file_names (struct dwarf2_per_cu_data *this_cu)\n   if (this_cu->v.quick->no_file_data)\n     return NULL;\n \n-  cutu_reader reader (this_cu);\n+  cutu_reader reader (this_cu, per_objfile);\n   if (!reader.dummy_p)\n     dw2_get_file_names_reader (&reader, reader.info_ptr, reader.comp_unit_die);\n \n@@ -3341,7 +3349,8 @@ dw2_map_symtabs_matching_filename\n       if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \tcontinue;\n \n-      quick_file_names *file_data = dw2_get_file_names (per_cu);\n+      quick_file_names *file_data\n+\t= dw2_get_file_names (per_cu, dwarf2_per_objfile);\n       if (file_data == NULL)\n \tcontinue;\n \n@@ -3682,7 +3691,8 @@ dw2_expand_symtabs_with_fullname (struct objfile *objfile,\n       if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \tcontinue;\n \n-      quick_file_names *file_data = dw2_get_file_names (per_cu);\n+      quick_file_names *file_data\n+\t= dw2_get_file_names (per_cu, dwarf2_per_objfile);\n       if (file_data == NULL)\n \tcontinue;\n \n@@ -4671,7 +4681,8 @@ dw_expand_symtabs_matching_file_matcher\n       if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \tcontinue;\n \n-      quick_file_names *file_data = dw2_get_file_names (per_cu);\n+      quick_file_names *file_data\n+\t= dw2_get_file_names (per_cu, dwarf2_per_objfile);\n       if (file_data == NULL)\n \tcontinue;\n \n@@ -4855,7 +4866,8 @@ dw2_map_symbol_filenames (struct objfile *objfile, symbol_filename_ftype *fun,\n \t  if (dwarf2_per_objfile->symtab_set_p (per_cu))\n \t    continue;\n \n-\t  quick_file_names *file_data = dw2_get_file_names (per_cu);\n+\t  quick_file_names *file_data\n+\t    = dw2_get_file_names (per_cu, dwarf2_per_objfile);\n \t  if (file_data == NULL)\n \t    continue;\n \n@@ -6952,14 +6964,14 @@ cutu_reader::init_tu_and_read_dwo_dies (dwarf2_per_cu_data *this_cu,\n    If USE_EXISTING_CU is non-zero, and THIS_CU->cu is non-NULL, then use it.\n    Otherwise, a new CU is allocated with xmalloc.  */\n \n-cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n+cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n+\t\t\t  dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\t  struct abbrev_table *abbrev_table,\n \t\t\t  int use_existing_cu,\n \t\t\t  bool skip_partial)\n   : die_reader_specs {},\n     m_this_cu (this_cu)\n {\n-  struct dwarf2_per_objfile *dwarf2_per_objfile = this_cu->dwarf2_per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_section_info *section = this_cu->section;\n   bfd *abfd = section->get_bfd_owner ();\n@@ -7176,13 +7188,13 @@ cutu_reader::keep ()\n    When parent_cu is passed, it is used to provide a default value for\n    str_offsets_base and addr_base from the parent.  */\n \n-cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n+cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n+\t\t\t  dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\t  struct dwarf2_cu *parent_cu,\n \t\t\t  struct dwo_file *dwo_file)\n   : die_reader_specs {},\n     m_this_cu (this_cu)\n {\n-  struct dwarf2_per_objfile *dwarf2_per_objfile = this_cu->dwarf2_per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_section_info *section = this_cu->section;\n   bfd *abfd = section->get_bfd_owner ();\n@@ -7544,7 +7556,8 @@ process_psymtab_comp_unit_reader (const struct die_reader_specs *reader,\n    Process compilation unit THIS_CU for a psymtab.  */\n \n static void\n-process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,\n+process_psymtab_comp_unit (dwarf2_per_cu_data *this_cu,\n+\t\t\t   dwarf2_per_objfile *per_objfile,\n \t\t\t   bool want_partial_unit,\n \t\t\t   enum language pretend_language)\n {\n@@ -7556,7 +7569,7 @@ process_psymtab_comp_unit (struct dwarf2_per_cu_data *this_cu,\n   if (this_cu->cu != NULL)\n     free_one_cached_comp_unit (this_cu);\n \n-  cutu_reader reader (this_cu, NULL, 0, false);\n+  cutu_reader reader (this_cu, per_objfile, NULL, 0, false);\n \n   switch (reader.comp_unit_die->tag)\n     {\n@@ -7737,8 +7750,8 @@ build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \t  ++tu_stats->nr_uniq_abbrev_tables;\n \t}\n \n-      cutu_reader reader (&tu.sig_type->per_cu, abbrev_table.get (),\n-\t\t\t  0, false);\n+      cutu_reader reader (&tu.sig_type->per_cu, dwarf2_per_objfile,\n+\t\t\t  abbrev_table.get (), 0, false);\n       if (!reader.dummy_p)\n \tbuild_type_psymtabs_reader (&reader, reader.info_ptr,\n \t\t\t\t    reader.comp_unit_die);\n@@ -7843,7 +7856,7 @@ process_skeletonless_type_unit (void **slot, void *info)\n   *slot = entry;\n \n   /* This does the job that build_type_psymtabs_1 would have done.  */\n-  cutu_reader reader (&entry->per_cu, NULL, 0, false);\n+  cutu_reader reader (&entry->per_cu, dwarf2_per_objfile, NULL, 0, false);\n   if (!reader.dummy_p)\n     build_type_psymtabs_reader (&reader, reader.info_ptr,\n \t\t\t\treader.comp_unit_die);\n@@ -7944,7 +7957,8 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n       if (per_cu->v.psymtab != NULL)\n \t/* In case a forward DW_TAG_imported_unit has read the CU already.  */\n \tcontinue;\n-      process_psymtab_comp_unit (per_cu, false, language_minimal);\n+      process_psymtab_comp_unit (per_cu, dwarf2_per_objfile, false,\n+\t\t\t\t language_minimal);\n     }\n \n   /* This has to wait until we read the CUs, we need the list of DWOs.  */\n@@ -7977,9 +7991,10 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n    This is also used when rereading a primary CU with load_all_dies.  */\n \n static void\n-load_partial_comp_unit (struct dwarf2_per_cu_data *this_cu)\n+load_partial_comp_unit (dwarf2_per_cu_data *this_cu,\n+\t\t\tdwarf2_per_objfile *per_objfile)\n {\n-  cutu_reader reader (this_cu, NULL, 1, false);\n+  cutu_reader reader (this_cu, per_objfile, NULL, 1, false);\n \n   if (!reader.dummy_p)\n     {\n@@ -8158,7 +8173,8 @@ scan_partial_symbols (struct partial_die_info *first_die, CORE_ADDR *lowpc,\n \n \t\t/* Go read the partial unit, if needed.  */\n \t\tif (per_cu->v.psymtab == NULL)\n-\t\t  process_psymtab_comp_unit (per_cu, true, cu->language);\n+\t\t  process_psymtab_comp_unit (per_cu, cu->per_objfile, true,\n+\t\t\t\t\t     cu->language);\n \n \t\tcu->per_cu->imported_symtabs_push (per_cu);\n \t      }\n@@ -9089,13 +9105,14 @@ die_eq (const void *item_lhs, const void *item_rhs)\n /* Load the DIEs associated with PER_CU into memory.  */\n \n static void\n-load_full_comp_unit (struct dwarf2_per_cu_data *this_cu,\n+load_full_comp_unit (dwarf2_per_cu_data *this_cu,\n+\t\t     dwarf2_per_objfile *per_objfile,\n \t\t     bool skip_partial,\n \t\t     enum language pretend_language)\n {\n   gdb_assert (! this_cu->is_debug_types);\n \n-  cutu_reader reader (this_cu, NULL, 1, skip_partial);\n+  cutu_reader reader (this_cu, per_objfile, NULL, 1, skip_partial);\n   if (reader.dummy_p)\n     return;\n \n@@ -9899,8 +9916,9 @@ process_imported_unit_die (struct die_info *die, struct dwarf2_cu *cu)\n     {\n       sect_offset sect_off = attr->get_ref_die_offset ();\n       bool is_dwz = (attr->form == DW_FORM_GNU_ref_alt || cu->per_cu->is_dwz);\n+      dwarf2_per_objfile *per_objfile = cu->per_objfile;\n       dwarf2_per_cu_data *per_cu\n-\t= dwarf2_find_containing_comp_unit (sect_off, is_dwz, cu->per_objfile);\n+\t= dwarf2_find_containing_comp_unit (sect_off, is_dwz, per_objfile);\n \n       /* We're importing a C++ compilation unit with tag DW_TAG_compile_unit\n \t into another compilation unit, at root level.  Regard this as a hint,\n@@ -9912,7 +9930,7 @@ process_imported_unit_die (struct die_info *die, struct dwarf2_cu *cu)\n \n       /* If necessary, add it to the queue and load its DIEs.  */\n       if (maybe_queue_comp_unit (cu, per_cu, cu->language))\n-\tload_full_comp_unit (per_cu, false, cu->language);\n+\tload_full_comp_unit (per_cu, per_objfile, false, cu->language);\n \n       cu->per_cu->imported_symtabs_push (per_cu);\n     }\n@@ -11313,7 +11331,7 @@ create_cus_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       per_cu.sect_off = sect_offset (info_ptr - section.buffer);\n       per_cu.section = &section;\n \n-      cutu_reader reader (&per_cu, cu, &dwo_file);\n+      cutu_reader reader (&per_cu, dwarf2_per_objfile, cu, &dwo_file);\n       if (!reader.dummy_p)\n \tcreate_dwo_cu_reader (&reader, reader.info_ptr, reader.comp_unit_die,\n \t\t\t      &dwo_file, &read_unit);\n@@ -12825,7 +12843,7 @@ queue_and_load_dwo_tu (void **slot, void *info)\n \t a real dependency of PER_CU on SIG_TYPE.  That is detected later\n \t while processing PER_CU.  */\n       if (maybe_queue_comp_unit (NULL, sig_cu, per_cu->cu->language))\n-\tload_full_type_unit (sig_cu);\n+\tload_full_type_unit (sig_cu, per_cu->cu->per_objfile);\n       per_cu->imported_symtabs_push (sig_cu);\n     }\n \n@@ -18665,7 +18683,7 @@ find_partial_die (sect_offset sect_off, int offset_in_dwz, struct dwarf2_cu *cu)\n \t\t\t\t\t\t dwarf2_per_objfile);\n \n       if (per_cu->cu == NULL || per_cu->cu->partial_dies == NULL)\n-\tload_partial_comp_unit (per_cu);\n+\tload_partial_comp_unit (per_cu, cu->per_objfile);\n \n       per_cu->cu->last_used = 0;\n       pd = per_cu->cu->find_partial_die (sect_off);\n@@ -18684,7 +18702,7 @@ find_partial_die (sect_offset sect_off, int offset_in_dwz, struct dwarf2_cu *cu)\n \t DIEs alone (which can still be in use, e.g. in scan_partial_symbols),\n \t and clobber THIS_CU->cu->partial_dies with the hash table for the new\n \t set.  */\n-      load_partial_comp_unit (per_cu);\n+      load_partial_comp_unit (per_cu, cu->per_objfile);\n \n       pd = per_cu->cu->find_partial_die (sect_off);\n     }\n@@ -19400,7 +19418,7 @@ dwarf2_read_addr_index (dwarf2_per_cu_data *per_cu, unsigned int addr_index)\n     }\n   else\n     {\n-      cutu_reader reader (per_cu, NULL, 0, false);\n+      cutu_reader reader (per_cu, dwarf2_per_objfile, NULL, 0, false);\n       addr_base = reader.cu->addr_base;\n       addr_size = reader.cu->header.addr_size;\n     }\n@@ -22211,15 +22229,16 @@ follow_die_offset (sect_offset sect_off, int offset_in_dwz,\n \n       /* If necessary, add it to the queue and load its DIEs.  */\n       if (maybe_queue_comp_unit (cu, per_cu, cu->language))\n-\tload_full_comp_unit (per_cu, false, cu->language);\n+\tload_full_comp_unit (per_cu, dwarf2_per_objfile, false, cu->language);\n \n       target_cu = per_cu->cu;\n     }\n   else if (cu->dies == NULL)\n     {\n       /* We're loading full DIEs during partial symbol reading.  */\n       gdb_assert (dwarf2_per_objfile->per_bfd->reading_partial_symbols);\n-      load_full_comp_unit (cu->per_cu, false, language_minimal);\n+      load_full_comp_unit (cu->per_cu, dwarf2_per_objfile, false,\n+\t\t\t   language_minimal);\n     }\n \n   *ref_cu = target_cu;\n@@ -22274,7 +22293,7 @@ dwarf2_fetch_die_loc_sect_off (sect_offset sect_off,\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n \n   if (per_cu->cu == NULL)\n-    load_cu (per_cu, false);\n+    load_cu (per_cu, dwarf2_per_objfile, false);\n   cu = per_cu->cu;\n   if (cu == NULL)\n     {\n@@ -22412,7 +22431,7 @@ dwarf2_fetch_constant_bytes (sect_offset sect_off,\n   struct objfile *objfile = per_cu->dwarf2_per_objfile->objfile;\n \n   if (per_cu->cu == NULL)\n-    load_cu (per_cu, false);\n+    load_cu (per_cu, per_cu->dwarf2_per_objfile, false);\n   cu = per_cu->cu;\n   if (cu == NULL)\n     {\n@@ -22534,7 +22553,7 @@ dwarf2_fetch_die_type_sect_off (sect_offset sect_off,\n   struct die_info *die;\n \n   if (per_cu->cu == NULL)\n-    load_cu (per_cu, false);\n+    load_cu (per_cu, per_cu->dwarf2_per_objfile, false);\n   cu = per_cu->cu;\n   if (!cu)\n     return NULL;\n@@ -22576,7 +22595,7 @@ follow_die_sig_1 (struct die_info *src_die, struct signatured_type *sig_type,\n   /* If necessary, add it to the queue and load its DIEs.  */\n \n   if (maybe_queue_comp_unit (*ref_cu, &sig_type->per_cu, language_minimal))\n-    read_signatured_type (sig_type);\n+    read_signatured_type (sig_type, (*ref_cu)->per_objfile);\n \n   sig_cu = sig_type->per_cu.cu;\n   gdb_assert (sig_cu != NULL);\n@@ -22739,7 +22758,8 @@ get_DW_AT_signature_type (struct die_info *die, const struct attribute *attr,\n /* Load the DIEs associated with type unit PER_CU into memory.  */\n \n static void\n-load_full_type_unit (struct dwarf2_per_cu_data *per_cu)\n+load_full_type_unit (dwarf2_per_cu_data *per_cu,\n+\t\t     dwarf2_per_objfile *per_objfile)\n {\n   struct signatured_type *sig_type;\n \n@@ -22753,7 +22773,7 @@ load_full_type_unit (struct dwarf2_per_cu_data *per_cu)\n \n   gdb_assert (per_cu->cu == NULL);\n \n-  read_signatured_type (sig_type);\n+  read_signatured_type (sig_type, per_objfile);\n \n   gdb_assert (per_cu->cu != NULL);\n }\n@@ -22763,14 +22783,15 @@ load_full_type_unit (struct dwarf2_per_cu_data *per_cu)\n    read in the real type from the DWO file as well.  */\n \n static void\n-read_signatured_type (struct signatured_type *sig_type)\n+read_signatured_type (signatured_type *sig_type,\n+\t\t      dwarf2_per_objfile *per_objfile)\n {\n   struct dwarf2_per_cu_data *per_cu = &sig_type->per_cu;\n \n   gdb_assert (per_cu->is_debug_types);\n   gdb_assert (per_cu->cu == NULL);\n \n-  cutu_reader reader (per_cu, NULL, 0, false);\n+  cutu_reader reader (per_cu, per_objfile, NULL, 0, false);\n \n   if (!reader.dummy_p)\n     {"
    }
  ]
}