{
  "sha": "4114425321d5c380bc8fb5344db8bc8664c170c6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDExNDQyNTMyMWQ1YzM4MGJjOGZiNTM0NGRiOGJjODY2NGMxNzBjNg==",
  "commit": {
    "author": {
      "name": "nitachra",
      "email": "Nitika.Achra@amd.com",
      "date": "2020-04-07T13:05:58Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-07T15:55:35Z"
    },
    "message": "Support for DW_AT_loclists_base and DW_FORM_loclistx.\n\nHi Tom,\n\nThis is the updated series with ChangeLogs edits.\n\nRegards,\nNitika",
    "tree": {
      "sha": "964f145106ceb15fa5c9b8d7d580a7bfd0335a96",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/964f145106ceb15fa5c9b8d7d580a7bfd0335a96"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4114425321d5c380bc8fb5344db8bc8664c170c6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4114425321d5c380bc8fb5344db8bc8664c170c6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4114425321d5c380bc8fb5344db8bc8664c170c6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4114425321d5c380bc8fb5344db8bc8664c170c6/comments",
  "author": null,
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9f4e76a4b3f61d8182a4a7afe0e479ea7e3093a3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9f4e76a4b3f61d8182a4a7afe0e479ea7e3093a3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9f4e76a4b3f61d8182a4a7afe0e479ea7e3093a3"
    }
  ],
  "stats": {
    "total": 152,
    "additions": 151,
    "deletions": 1
  },
  "files": [
    {
      "sha": "a9e955304f6539e09a7451476251316fdc761a2e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4114425321d5c380bc8fb5344db8bc8664c170c6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4114425321d5c380bc8fb5344db8bc8664c170c6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4114425321d5c380bc8fb5344db8bc8664c170c6",
      "patch": "@@ -1,3 +1,18 @@\n+2020-04-07  Nitika Achra  <Nitika.Achra@amd.com>\n+\n+\t* dwarf2/read.c (cu_debug_loc_section): Added the declaration for the function.\n+\t(read_loclist_index): New function definition.\n+\t(lookup_loclist_base): New function definition.\n+\t(read_loclist_header): New function definition.\n+\t(dwarf2_cu): Add loclist_base and loclist_header field.\n+\t(dwarf2_locate_dwo_sections): Handle .debug_loclists.dwo section.\n+\t(read_full_die_1): Read the value of DW_AT_loclists_base.\n+\t(read_attribute_reprocess): Handle DW_FORM_loclistx.\n+\t(read_attribute_value): Handle DW_FORM_loclistx.\n+\t(skip_one_die): Handle DW_FORM_loclistx.\n+\t(loclist_header): New structure declaration.\n+\t* dwarf2/attribute.c (form_is_section_offset): Handle DW_FORM_loclistx.\n+\n 2020-04-07  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* dwarf2/read.h (struct dwarf2_psymtab): Remove two-parameters"
    },
    {
      "sha": "9ceacf0409e7fb5468b14b4861d1e47711faf51a",
      "filename": "gdb/dwarf2/attribute.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4114425321d5c380bc8fb5344db8bc8664c170c6/gdb/dwarf2/attribute.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4114425321d5c380bc8fb5344db8bc8664c170c6/gdb/dwarf2/attribute.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/attribute.c?ref=4114425321d5c380bc8fb5344db8bc8664c170c6",
      "patch": "@@ -78,7 +78,8 @@ attribute::form_is_section_offset () const\n {\n   return (form == DW_FORM_data4\n           || form == DW_FORM_data8\n-\t  || form == DW_FORM_sec_offset);\n+\t  || form == DW_FORM_sec_offset\n+\t  || form == DW_FORM_loclistx);\n }\n \n /* See attribute.h.  */"
    },
    {
      "sha": "f1ddadef8d5c485801715cd5ab6eabd438ab9bc0",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 134,
      "deletions": 0,
      "changes": 134,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4114425321d5c380bc8fb5344db8bc8664c170c6/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4114425321d5c380bc8fb5344db8bc8664c170c6/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=4114425321d5c380bc8fb5344db8bc8664c170c6",
      "patch": "@@ -114,6 +114,12 @@ static int dwarf2_loclist_index;\n static int dwarf2_locexpr_block_index;\n static int dwarf2_loclist_block_index;\n \n+/* Size of .debug_loclists section header for 32-bit DWARF format.  */\n+#define LOCLIST_HEADER_SIZE32 12\n+\n+/* Size of .debug_loclists section header for 64-bit DWARF format.  */\n+#define LOCLIST_HEADER_SIZE64 20\n+\n /* An index into a (C++) symbol name component in a symbol name as\n    recorded in the mapped_index's symbol table.  For each C++ symbol\n    in the symbol table, we record one entry for the start of each\n@@ -346,6 +352,30 @@ dwop_section_names =\n \n /* local data types */\n \n+/* The location list section (.debug_loclists) begins with a header,\n+   which contains the following information.  */\n+struct loclist_header\n+{\n+  /* A 4-byte or 12-byte length containing the length of the\n+     set of entries for this compilation unit, not including the\n+     length field itself.  */\n+  unsigned int length;\n+\n+  /* A 2-byte version identifier.  */\n+  short version;\n+\n+  /* A 1-byte unsigned integer containing the size in bytes of an address on\n+     the target system.  */\n+  unsigned char addr_size;\n+\n+  /* A 1-byte unsigned integer containing the size in bytes of a segment selector\n+     on the target system.  */\n+  unsigned char segment_collector_size;\n+\n+  /* A 4-byte count of the number of offsets that follow the header.  */\n+  unsigned int offset_entry_count;\n+};\n+\n /* Type used for delaying computation of method physnames.\n    See comments for compute_delayed_physnames.  */\n struct delayed_method_info\n@@ -493,6 +523,9 @@ struct dwarf2_cu\n      whether the DW_AT_ranges attribute came from the skeleton or DWO.  */\n   ULONGEST ranges_base = 0;\n \n+  /* The DW_AT_loclists_base attribute if present.  */\n+  ULONGEST loclist_base = 0;\n+\n   /* When reading debug info generated by older versions of rustc, we\n      have to rewrite some union types to be struct types with a\n      variant part.  This rewriting must be done after the CU is fully\n@@ -1303,6 +1336,9 @@ static void read_variable (struct die_info *die, struct dwarf2_cu *cu);\n static int dwarf2_ranges_read (unsigned, CORE_ADDR *, CORE_ADDR *,\n \t\t\t       struct dwarf2_cu *, dwarf2_psymtab *);\n \n+/* Return the .debug_loclists section to use for cu.  */\n+static struct dwarf2_section_info *cu_debug_loc_section (struct dwarf2_cu *cu);\n+\n /* How dwarf2_get_pc_bounds constructed its *LOWPC and *HIGHPC return\n    values.  Keep the items ordered with increasing constraints compliance.  */\n enum pc_bounds_kind\n@@ -8591,6 +8627,7 @@ skip_one_die (const struct die_reader_specs *reader, const gdb_byte *info_ptr,\n \tcase DW_FORM_GNU_addr_index:\n \tcase DW_FORM_GNU_str_index:\n \tcase DW_FORM_rnglistx:\n+\tcase DW_FORM_loclistx:\n \t  info_ptr = safe_skip_leb128 (info_ptr, buffer_end);\n \t  break;\n \tcase DW_FORM_indirect:\n@@ -12056,6 +12093,11 @@ dwarf2_locate_dwo_sections (bfd *abfd, asection *sectp, void *dwo_sections_ptr)\n       dwo_sections->loc.s.section = sectp;\n       dwo_sections->loc.size = bfd_section_size (sectp);\n     }\n+  else if (section_is_p (sectp->name, &names->loclists_dwo))\n+    {\n+      dwo_sections->loclists.s.section = sectp;\n+      dwo_sections->loclists.size = bfd_section_size (sectp);\n+    }\n   else if (section_is_p (sectp->name, &names->macinfo_dwo))\n     {\n       dwo_sections->macinfo.s.section = sectp;\n@@ -17537,6 +17579,10 @@ read_full_die_1 (const struct die_reader_specs *reader,\n   if (attr != nullptr)\n     cu->str_offsets_base = DW_UNSND (attr);\n \n+  attr = die->attr (DW_AT_loclists_base);\n+  if (attr != nullptr)\n+    cu->loclist_base = DW_UNSND (attr);\n+\n   auto maybe_addr_base = die->addr_base ();\n   if (maybe_addr_base.has_value ())\n     cu->addr_base = *maybe_addr_base;\n@@ -18375,6 +18421,84 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n   fixup_called = 1;\n }\n \n+/* Read the .debug_loclists header contents from the given SECTION in the\n+   HEADER.  */\n+static void\n+read_loclist_header (struct loclist_header *header,\n+\t\t      struct dwarf2_section_info *section)\n+{\n+  unsigned int bytes_read;\n+  bfd *abfd = section->get_bfd_owner ();\n+  const gdb_byte *info_ptr = section->buffer;\n+  header->length = read_initial_length (abfd, info_ptr, &bytes_read);\n+  info_ptr += bytes_read;\n+  header->version = read_2_bytes (abfd, info_ptr);\n+  info_ptr += 2;\n+  header->addr_size = read_1_byte (abfd, info_ptr);\n+  info_ptr += 1;\n+  header->segment_collector_size = read_1_byte (abfd, info_ptr);\n+  info_ptr += 1;\n+  header->offset_entry_count = read_4_bytes (abfd, info_ptr);\n+}\n+\n+/* Return the DW_AT_loclists_base value for the CU.  */\n+static ULONGEST\n+lookup_loclist_base (struct dwarf2_cu *cu)\n+{\n+  /* For the .dwo unit, the loclist_base points to the first offset following\n+     the header. The header consists of the following entities-\n+     1. Unit Length (4 bytes for 32 bit DWARF format, and 12 bytes for the 64\n+\t bit format)\n+     2. version (2 bytes)\n+     3. address size (1 byte)\n+     4. segment selector size (1 byte)\n+     5. offset entry count (4 bytes)\n+     These sizes are derived as per the DWARFv5 standard.  */\n+  if (cu->dwo_unit != nullptr)\n+    {\n+      if (cu->header.initial_length_size == 4)\n+\t return LOCLIST_HEADER_SIZE32;\n+      return LOCLIST_HEADER_SIZE64;\n+    }\n+  return cu->loclist_base;\n+}\n+\n+/* Given a DW_FORM_loclistx value LOCLIST_INDEX, fetch the offset from the\n+   array of offsets in the .debug_loclists section.  */\n+static CORE_ADDR\n+read_loclist_index (struct dwarf2_cu *cu, ULONGEST loclist_index)\n+{\n+  struct dwarf2_per_objfile *dwarf2_per_objfile\n+    = cu->per_cu->dwarf2_per_objfile;\n+  struct objfile *objfile = dwarf2_per_objfile->objfile;\n+  bfd *abfd = objfile->obfd;\n+  ULONGEST loclist_base = lookup_loclist_base (cu);\n+  struct dwarf2_section_info *section = cu_debug_loc_section (cu);\n+\n+  section->read (objfile);\n+  if (section->buffer == NULL)\n+    complaint (_(\"DW_FORM_loclistx used without .debug_loclists \"\n+\t        \"section [in module %s]\"), objfile_name (objfile));\n+  struct loclist_header header;\n+  read_loclist_header (&header, section);\n+  if (loclist_index >= header.offset_entry_count)\n+    complaint (_(\"DW_FORM_loclistx pointing outside of \"\n+\t        \".debug_loclists offset array [in module %s]\"),\n+\t        objfile_name (objfile));\n+  if (loclist_base + loclist_index * cu->header.offset_size\n+\t>= section->size)\n+    complaint (_(\"DW_FORM_loclistx pointing outside of \"\n+\t        \".debug_loclists section [in module %s]\"),\n+\t        objfile_name (objfile));\n+  const gdb_byte *info_ptr\n+    = section->buffer + loclist_base + loclist_index * cu->header.offset_size;\n+\n+  if (cu->header.offset_size == 4)\n+    return bfd_get_32 (abfd, info_ptr) + loclist_base;\n+  else\n+    return bfd_get_64 (abfd, info_ptr) + loclist_base;\n+}\n+\n /* Process the attributes that had to be skipped in the first round. These\n    attributes are the ones that need str_offsets_base or addr_base attributes.\n    They could not have been processed in the first round, because at the time\n@@ -18390,6 +18514,9 @@ read_attribute_reprocess (const struct die_reader_specs *reader,\n       case DW_FORM_GNU_addr_index:\n         DW_ADDR (attr) = read_addr_index (cu, DW_UNSND (attr));\n         break;\n+      case DW_FORM_loclistx:\n+\t DW_UNSND (attr) = read_loclist_index (cu, DW_UNSND (attr));\n+\t break;\n       case DW_FORM_strx:\n       case DW_FORM_strx1:\n       case DW_FORM_strx2:\n@@ -18494,6 +18621,13 @@ read_attribute_value (const struct die_reader_specs *reader,\n       DW_UNSND (attr) = cu->header.read_offset (abfd, info_ptr, &bytes_read);\n       info_ptr += bytes_read;\n       break;\n+    case DW_FORM_loclistx:\n+      {\n+\t *need_reprocess = true;\n+\t DW_UNSND (attr) = read_unsigned_leb128 (abfd, info_ptr, &bytes_read);\n+\t info_ptr += bytes_read;\n+      }\n+      break;\n     case DW_FORM_string:\n       DW_STRING (attr) = read_direct_string (abfd, info_ptr, &bytes_read);\n       DW_STRING_IS_CANONICAL (attr) = 0;"
    }
  ]
}