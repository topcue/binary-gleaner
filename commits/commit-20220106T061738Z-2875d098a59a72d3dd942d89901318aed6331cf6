{
  "sha": "2875d098a59a72d3dd942d89901318aed6331cf6",
  "node_id": "C_kwDOANOeidoAKDI4NzVkMDk4YTU5YTcyZDNkZDk0MmQ4OTkwMTMxOGFlZDYzMzFjZjY",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-12-06T07:16:25Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2022-01-06T06:17:38Z"
    },
    "message": "sim: cris: migrate to standard uintXX_t types\n\nMove off the sim-specific unsignedXX types and to the standard uintXX_t\ntypes that C11 provides.",
    "tree": {
      "sha": "8df81d5386280597d2b398a7474330682cbbebf9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8df81d5386280597d2b398a7474330682cbbebf9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2875d098a59a72d3dd942d89901318aed6331cf6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2875d098a59a72d3dd942d89901318aed6331cf6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2875d098a59a72d3dd942d89901318aed6331cf6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2875d098a59a72d3dd942d89901318aed6331cf6/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1e1e987aed7d7454d42a1ea77c60a24f3d718ef0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1e1e987aed7d7454d42a1ea77c60a24f3d718ef0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1e1e987aed7d7454d42a1ea77c60a24f3d718ef0"
    }
  ],
  "stats": {
    "total": 160,
    "additions": 80,
    "deletions": 80
  },
  "files": [
    {
      "sha": "c2801c91c88cdc798e8c9dff24c707518600faeb",
      "filename": "sim/cris/cris-sim.h",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/cris-sim.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/cris-sim.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/cris/cris-sim.h?ref=2875d098a59a72d3dd942d89901318aed6331cf6",
      "patch": "@@ -34,22 +34,22 @@ typedef struct {\n \n   /* Static cycle count for all insns executed so far, including\n      non-context-specific stall cycles, for example when adding to PC.  */\n-  unsigned64 basic_cycle_count;\n+  uint64_t basic_cycle_count;\n \n   /* Stall cycles for unaligned access of memory operands.  FIXME:\n      Should or should not include unaligned [PC+] operands?  */\n-  unsigned64 unaligned_mem_dword_count;\n+  uint64_t unaligned_mem_dword_count;\n \n   /* Context-specific stall cycles.  */\n-  unsigned64 memsrc_stall_count;\n-  unsigned64 memraw_stall_count;\n-  unsigned64 movemsrc_stall_count;\n-  unsigned64 movemaddr_stall_count;\n-  unsigned64 movemdst_stall_count;\n-  unsigned64 mulsrc_stall_count;\n-  unsigned64 jumpsrc_stall_count;\n-  unsigned64 branch_stall_count;\n-  unsigned64 jumptarget_stall_count;\n+  uint64_t memsrc_stall_count;\n+  uint64_t memraw_stall_count;\n+  uint64_t movemsrc_stall_count;\n+  uint64_t movemaddr_stall_count;\n+  uint64_t movemdst_stall_count;\n+  uint64_t mulsrc_stall_count;\n+  uint64_t jumpsrc_stall_count;\n+  uint64_t branch_stall_count;\n+  uint64_t jumptarget_stall_count;\n \n   /* What kind of target-specific trace to perform.  */\n   int flags;"
    },
    {
      "sha": "9f0c06e755e3119621cf0452962d5419260e7143",
      "filename": "sim/cris/cris-tmpl.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/cris-tmpl.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/cris-tmpl.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/cris/cris-tmpl.c?ref=2875d098a59a72d3dd942d89901318aed6331cf6",
      "patch": "@@ -123,7 +123,7 @@ MY (f_model_insn_before) (SIM_CPU *current_cpu, int first_p ATTRIBUTE_UNUSED)\n   {\n     int i;\n     char flags[7];\n-    unsigned64 cycle_count;\n+    uint64_t cycle_count;\n \n     SIM_DESC sd = CPU_STATE (current_cpu);\n "
    },
    {
      "sha": "afb203da3f020171365c77de686438a735a9d0e0",
      "filename": "sim/cris/crisv10f.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/crisv10f.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/crisv10f.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/cris/crisv10f.c?ref=2875d098a59a72d3dd942d89901318aed6331cf6",
      "patch": "@@ -60,7 +60,7 @@ MY (deliver_interrupt) (SIM_CPU *current_cpu,\n   unsigned char entryaddr_le[4];\n   int was_user;\n   SIM_DESC sd = CPU_STATE (current_cpu);\n-  unsigned32 entryaddr;\n+  uint32_t entryaddr;\n \n   /* We haven't implemented other interrupt-types yet.  */\n   if (type != CRIS_INT_INT)"
    },
    {
      "sha": "0022626451781ee8bd8f6cb70ffdb6fd4be27c32",
      "filename": "sim/cris/crisv32f.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/crisv32f.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/crisv32f.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/cris/crisv32f.c?ref=2875d098a59a72d3dd942d89901318aed6331cf6",
      "patch": "@@ -565,11 +565,11 @@ MY (deliver_interrupt) (SIM_CPU *current_cpu,\n \t\t\tenum cris_interrupt_type type,\n \t\t\tunsigned int vec)\n {\n-  unsigned32 old_ccs, shifted_ccs, new_ccs;\n+  uint32_t old_ccs, shifted_ccs, new_ccs;\n   unsigned char entryaddr_le[4];\n   int was_user;\n   SIM_DESC sd = CPU_STATE (current_cpu);\n-  unsigned32 entryaddr;\n+  uint32_t entryaddr;\n \n   /* We haven't implemented other interrupt-types yet.  */\n   if (type != CRIS_INT_INT)\n@@ -585,7 +585,7 @@ MY (deliver_interrupt) (SIM_CPU *current_cpu,\n \n   /* The M bit is handled by code below and the M bit setter function, but\n      we need to preserve the Q bit.  */\n-  new_ccs = shifted_ccs | (old_ccs & (unsigned32) 0x80000000UL);\n+  new_ccs = shifted_ccs | (old_ccs & (uint32_t) 0x80000000UL);\n   was_user = GET_H_UBIT_V32 ();\n \n   /* We need to force kernel mode since the setter method doesn't allow"
    },
    {
      "sha": "11434654c88c7921e20a37db5d2d52009b140ada",
      "filename": "sim/cris/dv-cris.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/dv-cris.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/dv-cris.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/cris/dv-cris.c?ref=2875d098a59a72d3dd942d89901318aed6331cf6",
      "patch": "@@ -88,7 +88,7 @@ static const struct hw_port_descriptor cris_ports[] =\n \n struct cris_vec_tr\n  {\n-   unsigned32 portval, vec;\n+   uint32_t portval, vec;\n  };\n \n enum cris_multiple_ints\n@@ -101,10 +101,10 @@ enum cris_multiple_ints\n struct cris_hw\n  {\n    struct hw_event *pending_handler;\n-   unsigned32 pending_vector;\n+   uint32_t pending_vector;\n    struct cris_vec_tr *int_to_vec;\n    enum cris_multiple_ints multi_int_action;\n-   unsigned32 multiple_int_vector;\n+   uint32_t multiple_int_vector;\n  };\n \n /* An event function, calling the actual CPU-model-specific\n@@ -136,9 +136,9 @@ deliver_cris_interrupt (struct hw *me, void *data)\n       time we get here, until a new time is seen (supposedly unstuck\n       re-delivery).  (Fixing in SIM/GDB source will hopefully then\n       also be easier, having a tangible test-case.)  */\n-   static signed64 last_events_time = 0;\n-   static signed64 delta = 1;\n-   signed64 this_events_time = hw_event_queue_time (me);\n+   static int64_t last_events_time = 0;\n+   static int64_t delta = 1;\n+   int64_t this_events_time = hw_event_queue_time (me);\n \n    if (this_events_time == last_events_time)\n      delta++;\n@@ -164,7 +164,7 @@ cris_port_event (struct hw *me,\n \t\t int intparam)\n {\n   struct cris_hw *crishw = hw_data (me);\n-  unsigned32 vec;\n+  uint32_t vec;\n \n   /* A few placeholders; only the INT port is implemented.  */\n   switch (my_port)\n@@ -194,7 +194,7 @@ cris_port_event (struct hw *me,\n       vec = crishw->int_to_vec[i].vec;\n     }\n   else\n-    vec = (unsigned32) intparam;\n+    vec = (uint32_t) intparam;\n \n   if (crishw->pending_vector != 0)\n     {\n@@ -245,8 +245,8 @@ cris_finish (struct hw *me)\n   vec_for_int = hw_find_property (me, \"vec-for-int\");\n   if (vec_for_int != NULL)\n     {\n-      unsigned32 vecsize;\n-      unsigned32 i;\n+      uint32_t vecsize;\n+      uint32_t i;\n \n       if (hw_property_type (vec_for_int) != array_property)\n \thw_abort (me, \"property \\\"vec-for-int\\\" has the wrong type\");\n@@ -272,8 +272,8 @@ cris_finish (struct hw *me)\n \t      || vec_sc < 0)\n \t    hw_abort (me, \"no valid vector translation pair %u\", i);\n \n-\t  crishw->int_to_vec[i].portval = (unsigned32) portval_sc;\n-\t  crishw->int_to_vec[i].vec = (unsigned32) vec_sc;\n+\t  crishw->int_to_vec[i].portval = (uint32_t) portval_sc;\n+\t  crishw->int_to_vec[i].vec = (uint32_t) vec_sc;\n \t}\n \n       crishw->int_to_vec[i].portval = 0;"
    },
    {
      "sha": "42ef9b169fa9c044cd3a5256f2ee1e084eb5b397",
      "filename": "sim/cris/dv-rv.c",
      "status": "modified",
      "additions": 51,
      "deletions": 51,
      "changes": 102,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/dv-rv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/dv-rv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/cris/dv-rv.c?ref=2875d098a59a72d3dd942d89901318aed6331cf6",
      "patch": "@@ -293,43 +293,43 @@ enum rv_command {\n typedef struct _hw_rv_device\n {\n   /* Mapping of remote interrupt bit-numbers to local ones.  */\n-  unsigned32 remote_to_local_int[32];\n+  uint32_t remote_to_local_int[32];\n \n   /* When multiple bits are set, a non-zero value here indicates that\n      this value should be used instead.  */\n-  unsigned32 intmultiple;\n+  uint32_t intmultiple;\n \n   /* Local address of registers.  */\n-  unsigned32 reg_address;\n+  uint32_t reg_address;\n \n   /* Size of register bank in bytes.  */\n-  unsigned32 reg_size;\n+  uint32_t reg_size;\n \n   /* Remote address of registers.  */\n-  unsigned32 remote_reg_address;\n+  uint32_t remote_reg_address;\n \n   /* Local address of DMA:able memory.  */\n-  unsigned32 mem_address;\n+  uint32_t mem_address;\n \n   /* Size of DMA:able memory in bytes.  */\n-  unsigned32 mem_size;\n+  uint32_t mem_size;\n \n   /* Bitmask for valid DMA request size.  */\n-  unsigned32 mem_burst_mask;\n+  uint32_t mem_burst_mask;\n \n   /* Remote address of DMA:able memory.  */\n-  unsigned32 remote_mem_address;\n+  uint32_t remote_mem_address;\n \n   /* (Local) address of mbox; where to put a pointer to the mbox to be\n      sent.  */\n-  unsigned32 mbox_address;\n+  uint32_t mbox_address;\n \n   /* Probably not 127.0.0.1:10000.  */\n   const char *host;\n   int port;\n \n   /* If non-NULL, points to memory to use instead of connection.  */\n-  unsigned8 *dummy;\n+  uint8_t *dummy;\n \n   /* File descriptor for the socket.  Set to -1 when error.  Only one\n      of dummy and this is active.  */\n@@ -341,18 +341,18 @@ typedef struct _hw_rv_device\n   /* This, plus latency because the CPU might not be checking until a\n      CTI insn (usually a branch or a jump) is the interval in cycles\n      between the rv is polled for e.g. DMA requests.  */\n-  unsigned32 max_tick_poll_interval;\n+  uint32_t max_tick_poll_interval;\n \n   /* Running counter for exponential backoff up to\n      max_tick_poll_interval to avoid polling the connection\n      unnecessarily often.  Set to 1 when rv activity (read/write\n      register, DMA request) is detected.  */\n-  unsigned32 next_period;\n+  uint32_t next_period;\n \n   /* This is the interval in wall-clock seconds between watchdog\n      packets are sent to the remote side.  Zero means no watchdog\n      packets. */\n-  unsigned32 watchdog_interval;\n+  uint32_t watchdog_interval;\n \n   /* Last time we sent a watchdog packet.  */\n   struct timeval last_wdog_time;\n@@ -384,7 +384,7 @@ hw_rv_write (struct hw *me,\n \t     unsigned int len)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n-  unsigned8 *bufp = buf;\n+  uint8_t *bufp = buf;\n \n   /* If we don't have a valid fd here, it's because we got an error\n      initially, and we suppressed that error.  */\n@@ -414,7 +414,7 @@ hw_rv_read (struct hw *me,\n \t    unsigned int len)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n-  unsigned8 *bufp = buf;\n+  uint8_t *bufp = buf;\n \n   while (len > 0)\n     {\n@@ -446,8 +446,8 @@ hw_rv_send (struct hw *me,\n \t    unsigned int len_noheader)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n-  unsigned8 buf[32+3];\n-  unsigned8 *bufp;\n+  uint8_t buf[32+3];\n+  uint8_t *bufp;\n   unsigned int len = len_noheader + 3;\n   int ret;\n \n@@ -478,12 +478,12 @@ hw_rv_read_mem (struct hw *me, unsigned int len)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n   /* If you change this size, please adjust the mem2 testcase.  */\n-  unsigned8 buf[32+8];\n-  unsigned8 *bufp = buf;\n-  unsigned32 leaddr;\n-  unsigned32 addr;\n-  unsigned32 lelen;\n-  unsigned32 i;\n+  uint8_t buf[32+8];\n+  uint8_t *bufp = buf;\n+  uint32_t leaddr;\n+  uint32_t addr;\n+  uint32_t lelen;\n+  uint32_t i;\n \n   if (len != 8)\n     hw_abort (me, \"expected DMA read request len 8+3, got %d+3\", len);\n@@ -532,13 +532,13 @@ hw_rv_write_mem (struct hw *me, unsigned int plen)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n   /* If you change this size, please adjust the mem2 testcase.  */\n-  unsigned8 buf[32+8];\n-  unsigned8 *bufp = buf;\n-  unsigned32 leaddr;\n-  unsigned32 addr;\n-  unsigned32 lelen;\n-  unsigned32 len;\n-  unsigned32 i;\n+  uint8_t buf[32+8];\n+  uint8_t *bufp = buf;\n+  uint32_t leaddr;\n+  uint32_t addr;\n+  uint32_t lelen;\n+  uint32_t len;\n+  uint32_t i;\n \n   hw_rv_read (me, &leaddr, 4);\n   hw_rv_read (me, &lelen, 4);\n@@ -582,9 +582,9 @@ static void\n hw_rv_irq (struct hw *me, unsigned int len)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n-  unsigned32 intbitsle;\n-  unsigned32 intbits_ext;\n-  unsigned32 intval = 0;\n+  uint32_t intbitsle;\n+  uint32_t intbits_ext;\n+  uint32_t intval = 0;\n   int i;\n \n   if (len != 4)\n@@ -609,11 +609,11 @@ hw_rv_irq (struct hw *me, unsigned int len)\n static void\n hw_rv_handle_incoming (struct hw *me,\n \t\t       int expected_type,\n-\t\t       unsigned8 *buf,\n+\t\t       uint8_t *buf,\n \t\t       unsigned int *return_len)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n-  unsigned8 cbuf[32];\n+  uint8_t cbuf[32];\n   unsigned int len;\n   unsigned int cmd;\n \n@@ -765,7 +765,7 @@ static void\n do_poll_event (struct hw *me, void *data)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n-  unsigned32 new_period;\n+  uint32_t new_period;\n \n   if (rv->dummy != NULL)\n     return;\n@@ -900,8 +900,8 @@ hw_rv_reg_read (struct hw *me,\n \t\tunsigned int nr_bytes)\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n-  unsigned8 addr_data[8] = \"\";\n-  unsigned32 a_l = H2LE_4 (addr - rv->reg_address + rv->remote_reg_address);\n+  uint8_t addr_data[8] = \"\";\n+  uint32_t a_l = H2LE_4 (addr - rv->reg_address + rv->remote_reg_address);\n   unsigned int len = 8;\n \n   if (nr_bytes != 4)\n@@ -937,10 +937,10 @@ hw_rv_reg_read (struct hw *me,\n static void\n hw_rv_mbox (struct hw *me, unsigned_word address)\n {\n-  unsigned8 buf[256+3];\n+  uint8_t buf[256+3];\n   unsigned int cmd;\n   unsigned int rlen;\n-  unsigned32 i;\n+  uint32_t i;\n   unsigned int len\n     = hw_dma_read_buffer (me, buf, 0, address, 3);\n \n@@ -1002,8 +1002,8 @@ hw_rv_reg_write (struct hw *me,\n {\n   hw_rv_device *rv = (hw_rv_device *) hw_data (me);\n \n-  unsigned8 addr_data[8] = \"\";\n-  unsigned32 a_l = H2LE_4 (addr - rv->reg_address + rv->remote_reg_address);\n+  uint8_t addr_data[8] = \"\";\n+  uint32_t a_l = H2LE_4 (addr - rv->reg_address + rv->remote_reg_address);\n   unsigned int len = 8;\n \n   if (nr_bytes != 4)\n@@ -1014,7 +1014,7 @@ hw_rv_reg_write (struct hw *me,\n \n   if (addr == rv->mbox_address)\n     {\n-      unsigned32 mbox_addr_le;\n+      uint32_t mbox_addr_le;\n       if (rv->dummy != NULL)\n \thw_abort (me, \"mbox not supported for a dummy instance\");\n       memcpy (&mbox_addr_le, source, 4);\n@@ -1123,15 +1123,15 @@ hw_rv_finish (struct hw *me)\n \n       if (hw_property_type (dummy_prop) == integer_property)\n \t{\n-\t  unsigned32 dummyfill = hw_find_integer_property (me, \"dummy\");\n-\t  unsigned8 *dummymem = hw_malloc (me, rv->reg_size);\n+\t  uint32_t dummyfill = hw_find_integer_property (me, \"dummy\");\n+\t  uint8_t *dummymem = hw_malloc (me, rv->reg_size);\n \t  memset (dummymem, dummyfill, rv->reg_size);\n \t  rv->dummy = dummymem;\n \t}\n       else\n \t{\n \t  const char *dummyarg = hw_find_string_property (me, \"dummy\");\n-\t  unsigned8 *dummymem = hw_malloc (me, rv->reg_size);\n+\t  uint8_t *dummymem = hw_malloc (me, rv->reg_size);\n \t  FILE *f = fopen (dummyarg, \"rb\");\n \n \t  if (f == NULL)\n@@ -1153,10 +1153,10 @@ hw_rv_finish (struct hw *me)\n \t  signed_cell attach_address_sc\n \t    = hw_find_integer_property (me, \"mbox\");\n \n-\t  rv->mbox_address = (unsigned32) attach_address_sc;\n+\t  rv->mbox_address = (uint32_t) attach_address_sc;\n \t  hw_attach_address (hw_parent (me),\n \t\t\t     0,\n-\t\t\t     0, (unsigned32) attach_address_sc, 4, me);\n+\t\t\t     0, (uint32_t) attach_address_sc, 4, me);\n \t}\n       else\n \thw_abort (me, \"property \\\"mbox\\\" has the wrong type\");\n@@ -1176,8 +1176,8 @@ hw_rv_finish (struct hw *me)\n \t  && hw_find_integer_array_property (me, \"mem\", 1, &attach_size_sc))\n \t{\n \t  /* Unfortunate choice of types forces us to dance around a bit.  */\n-\t  rv->mem_address = (unsigned32) attach_address_sc;\n-\t  rv->mem_size = (unsigned32) attach_size_sc;\n+\t  rv->mem_address = (uint32_t) attach_address_sc;\n+\t  rv->mem_size = (uint32_t) attach_size_sc;\n \t  if ((attach_address_sc & 3) != 0)\n \t    hw_abort (me, \"memory block must be 4 byte aligned\");\n \t}"
    },
    {
      "sha": "e92fa1aae2545517f99f5a5620c34b03b5c6b2e6",
      "filename": "sim/cris/traps.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/traps.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2875d098a59a72d3dd942d89901318aed6331cf6/sim/cris/traps.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/cris/traps.c?ref=2875d098a59a72d3dd942d89901318aed6331cf6",
      "patch": "@@ -803,7 +803,7 @@ dump_statistics (SIM_CPU *current_cpu)\n   SIM_DESC sd = CPU_STATE (current_cpu);\n   CRIS_MISC_PROFILE *profp\n     = CPU_CRIS_MISC_PROFILE (current_cpu);\n-  unsigned64 total = profp->basic_cycle_count;\n+  uint64_t total = profp->basic_cycle_count;\n \n   /* Historically, these messages have gone to stderr, so we'll keep it\n      that way.  It's also easier to then tell it from normal program"
    }
  ]
}