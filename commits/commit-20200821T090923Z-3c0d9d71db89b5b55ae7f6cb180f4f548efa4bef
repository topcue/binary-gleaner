{
  "sha": "3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2MwZDlkNzFkYjg5YjViNTVhZTdmNmNiMTgwZjRmNTQ4ZWZhNGJlZg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-21T03:31:37Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-08-21T09:09:23Z"
    },
    "message": "gas symbol struct field renaming\n\nGet rid of sy_ prefix, and some unused fields.\n\n\t* symbols.c (struct symbol_flags): Rename sy_volatile to volatil,\n\tand remove sy_ from other field names.  Update throughout.\n\t(struct symbol): Remove sy_ from field names.  Delete unused\n\tTARGET_SYMBOL_FIELDS.  Update throughout file.  Move after..\n\t(struct local_symbol): ..here.  Remove lsy_ from field names.\n\tDelete unused TC_LOCAL_SYMFIELD_TYPE.  Update throughout file.\n\t(local_symbol_resolved_p, local_symbol_mark_resolved): Delete.\n\tExpand uses throughout file.\n\t(local_symbol_get_frag, local_symbol_set_frag): Likewise.\n\t(symbol_new): Move symbol_table_frozen test to..\n\t(symbol_append): ..here, and..\n\t(symbol_insert): ..here.\n\t(resolve_symbol_value, symbol_relc_make_expr): White space fixes.\n\t(HANDLE_XADD_OPT1, HANDLE_XADD_OPT2): Likewise.\n\t* config/obj-coff.h (RESOLVE_SYMBOL_REDEFINITION): Update.",
    "tree": {
      "sha": "260d593298eac65b1a7d00d6e564996d03d13fb3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/260d593298eac65b1a7d00d6e564996d03d13fb3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e01e1cee39777b6278ff01502742347247e8dfd7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e01e1cee39777b6278ff01502742347247e8dfd7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e01e1cee39777b6278ff01502742347247e8dfd7"
    }
  ],
  "stats": {
    "total": 723,
    "additions": 364,
    "deletions": 359
  },
  "files": [
    {
      "sha": "4cfcba3f1857bbfeb3e114af5d0be928b5e40e85",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
      "patch": "@@ -1,3 +1,21 @@\n+2020-08-21  Alan Modra  <amodra@gmail.com>\n+\n+\t* symbols.c (struct symbol_flags): Rename sy_volatile to volatil,\n+\tand remove sy_ from other field names.  Update throughout.\n+\t(struct symbol): Remove sy_ from field names.  Delete unused\n+\tTARGET_SYMBOL_FIELDS.  Update throughout file.  Move after..\n+\t(struct local_symbol): ..here.  Remove lsy_ from field names.\n+\tDelete unused TC_LOCAL_SYMFIELD_TYPE.  Update throughout file.\n+\t(local_symbol_resolved_p, local_symbol_mark_resolved): Delete.\n+\tExpand uses throughout file.\n+\t(local_symbol_get_frag, local_symbol_set_frag): Likewise.\n+\t(symbol_new): Move symbol_table_frozen test to..\n+\t(symbol_append): ..here, and..\n+\t(symbol_insert): ..here.\n+\t(resolve_symbol_value, symbol_relc_make_expr): White space fixes.\n+\t(HANDLE_XADD_OPT1, HANDLE_XADD_OPT2): Likewise.\n+\t* config/obj-coff.h (RESOLVE_SYMBOL_REDEFINITION): Update.\n+\n 2020-08-21  Alan Modra  <amodra@gmail.com>\n \n \t* symbols.h (symbol_new, symbol_create, local_symbol_make),"
    },
    {
      "sha": "f8051a1c6db3157aaba2549e61c662ffe3ae5865",
      "filename": "gas/config/obj-coff.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef/gas/config/obj-coff.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef/gas/config/obj-coff.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-coff.h?ref=3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
      "patch": "@@ -280,7 +280,7 @@ extern const pseudo_typeS coff_pseudo_table[];\n    as in start/_start/__start in gcc/libgcc1-test.c.  */\n #define RESOLVE_SYMBOL_REDEFINITION(sym)\t\t\\\n (SF_GET_GET_SEGMENT (sym)\t\t\t\t\\\n- ? (sym->sy_frag = frag_now,\t\t\t\t\\\n+ ? (sym->frag = frag_now,\t\t\t\t\\\n     S_SET_VALUE (sym, frag_now_fix ()),\t\t\t\\\n     S_SET_SEGMENT (sym, now_seg),\t\t\t\\\n     0)\t\t\t\t\t\t\t\\"
    },
    {
      "sha": "90bf255fd45916df181f4a7f598a31cc12850a87",
      "filename": "gas/symbols.c",
      "status": "modified",
      "additions": 345,
      "deletions": 358,
      "changes": 703,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef/gas/symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef/gas/symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/symbols.c?ref=3c0d9d71db89b5b55ae7f6cb180f4f548efa4bef",
      "patch": "@@ -29,90 +29,54 @@\n struct symbol_flags\n {\n   /* Whether the symbol is a local_symbol.  */\n-  unsigned int sy_local_symbol : 1;\n+  unsigned int local_symbol : 1;\n \n   /* Weather symbol has been written.  */\n-  unsigned int sy_written : 1;\n+  unsigned int written : 1;\n \n   /* Whether symbol value has been completely resolved (used during\n      final pass over symbol table).  */\n-  unsigned int sy_resolved : 1;\n+  unsigned int resolved : 1;\n \n   /* Whether the symbol value is currently being resolved (used to\n      detect loops in symbol dependencies).  */\n-  unsigned int sy_resolving : 1;\n+  unsigned int resolving : 1;\n \n   /* Whether the symbol value is used in a reloc.  This is used to\n      ensure that symbols used in relocs are written out, even if they\n      are local and would otherwise not be.  */\n-  unsigned int sy_used_in_reloc : 1;\n+  unsigned int used_in_reloc : 1;\n \n   /* Whether the symbol is used as an operand or in an expression.\n      NOTE:  Not all the backends keep this information accurate;\n      backends which use this bit are responsible for setting it when\n      a symbol is used in backend routines.  */\n-  unsigned int sy_used : 1;\n+  unsigned int used : 1;\n \n   /* Whether the symbol can be re-defined.  */\n-  unsigned int sy_volatile : 1;\n+  unsigned int volatil : 1;\n \n   /* Whether the symbol is a forward reference.  */\n-  unsigned int sy_forward_ref : 1;\n+  unsigned int forward_ref : 1;\n \n   /* This is set if the symbol is defined in an MRI common section.\n      We handle such sections as single common symbols, so symbols\n      defined within them must be treated specially by the relocation\n      routines.  */\n-  unsigned int sy_mri_common : 1;\n+  unsigned int mri_common : 1;\n \n   /* This is set if the symbol is set with a .weakref directive.  */\n-  unsigned int sy_weakrefr : 1;\n+  unsigned int weakrefr : 1;\n \n   /* This is set when the symbol is referenced as part of a .weakref\n      directive, but only if the symbol was not in the symbol table\n      before.  It is cleared as soon as any direct reference to the\n      symbol is present.  */\n-  unsigned int sy_weakrefd : 1;\n-};\n-\n-/* The information we keep for a symbol.  Note that the symbol table\n-   holds pointers both to this and to local_symbol structures.  See\n-   below.  */\n-\n-struct symbol\n-{\n-  /* Symbol flags.  */\n-  struct symbol_flags sy_flags;\n-\n-  /* BFD symbol */\n-  asymbol *bsym;\n-\n-  /* The value of the symbol.  */\n-  expressionS sy_value;\n-\n-  /* Forwards and (optionally) backwards chain pointers.  */\n-  struct symbol *sy_next;\n-  struct symbol *sy_previous;\n-\n-  /* Pointer to the frag this symbol is attached to, if any.\n-     Otherwise, NULL.  */\n-  struct frag *sy_frag;\n-\n-#ifdef OBJ_SYMFIELD_TYPE\n-  OBJ_SYMFIELD_TYPE sy_obj;\n-#endif\n-\n-#ifdef TC_SYMFIELD_TYPE\n-  TC_SYMFIELD_TYPE sy_tc;\n-#endif\n-\n-#ifdef TARGET_SYMBOL_FIELDS\n-  TARGET_SYMBOL_FIELDS\n-#endif\n+  unsigned int weakrefd : 1;\n };\n \n /* A pointer in the symbol may point to either a complete symbol\n-   (struct symbol above) or to a local symbol (struct local_symbol\n+   (struct symbol below) or to a local symbol (struct local_symbol\n    defined here).  The symbol code can detect the case by examining\n    the first field which is present in both structs.\n \n@@ -124,30 +88,57 @@ struct symbol\n \n struct local_symbol\n {\n-  /* Symbol flags.  Only sy_local_symbol and sy_resolved are relevant.  */\n-  struct symbol_flags lsy_flags;\n+  /* Symbol flags.  Only local_symbol and resolved are relevant.  */\n+  struct symbol_flags flags;\n \n   /* The symbol section.  This also serves as a flag.  If this is\n      reg_section, then this symbol has been converted into a regular\n-     symbol, and lsy_sym points to it.  */\n-  segT lsy_section;\n+     symbol, and sym points to it.  */\n+  segT section;\n \n   /* The symbol name.  */\n-  const char *lsy_name;\n+  const char *name;\n \n   /* The symbol frag or the real symbol, depending upon the value in\n-     lsy_section.  */\n+     section.  */\n   union\n   {\n-    fragS *lsy_frag;\n-    symbolS *lsy_sym;\n+    fragS *frag;\n+    symbolS *sym;\n   } u;\n \n   /* The value of the symbol.  */\n-  valueT lsy_value;\n+  valueT value;\n+};\n \n-#ifdef TC_LOCAL_SYMFIELD_TYPE\n-  TC_LOCAL_SYMFIELD_TYPE lsy_tc;\n+/* The information we keep for a symbol.  Note that the symbol table\n+   holds pointers both to this and to local_symbol structures.  */\n+\n+struct symbol\n+{\n+  /* Symbol flags.  */\n+  struct symbol_flags flags;\n+\n+  /* BFD symbol */\n+  asymbol *bsym;\n+\n+  /* The value of the symbol.  */\n+  expressionS value;\n+\n+  /* Forwards and backwards chain pointers.  */\n+  struct symbol *next;\n+  struct symbol *previous;\n+\n+  /* Pointer to the frag this symbol is attached to, if any.\n+     Otherwise, NULL.  */\n+  struct frag *frag;\n+\n+#ifdef OBJ_SYMFIELD_TYPE\n+  OBJ_SYMFIELD_TYPE obj;\n+#endif\n+\n+#ifdef TC_SYMFIELD_TYPE\n+  TC_SYMFIELD_TYPE tc;\n #endif\n };\n \n@@ -202,14 +193,10 @@ symbol_entry_find (htab_t table, const char *symbol_name)\n }\n \n \n-#define local_symbol_converted_p(l) ((l)->lsy_section == reg_section)\n-#define local_symbol_mark_converted(l) ((l)->lsy_section = reg_section)\n-#define local_symbol_resolved_p(l) ((l)->lsy_flags.sy_resolved)\n-#define local_symbol_mark_resolved(l) ((l)->lsy_flags.sy_resolved = 1)\n-#define local_symbol_get_frag(l) ((l)->u.lsy_frag)\n-#define local_symbol_set_frag(l, f) ((l)->u.lsy_frag = (f))\n-#define local_symbol_get_real_symbol(l) ((l)->u.lsy_sym)\n-#define local_symbol_set_real_symbol(l, s) ((l)->u.lsy_sym = (s))\n+#define local_symbol_converted_p(l) ((l)->section == reg_section)\n+#define local_symbol_mark_converted(l) ((l)->section = reg_section)\n+#define local_symbol_get_real_symbol(l) ((l)->u.sym)\n+#define local_symbol_set_real_symbol(l, s) ((l)->u.sym = (s))\n \n /* This is non-zero if symbols are case sensitive, which is the\n    default.  */\n@@ -273,11 +260,6 @@ symbol_new (const char *name, segT segment, fragS *frag, valueT valu)\n   symbolS *symbolP = symbol_create (name, segment, frag, valu);\n \n   /* Link to end of symbol chain.  */\n-  {\n-    extern int symbol_table_frozen;\n-    if (symbol_table_frozen)\n-      abort ();\n-  }\n   symbol_append (symbolP, symbol_lastP, &symbol_rootP, &symbol_lastP);\n \n   return symbolP;\n@@ -336,7 +318,7 @@ symbol_create (const char *name, segT segment, fragS *frag, valueT valu)\n   S_SET_VALUE (symbolP, valu);\n   symbol_clear_list_pointers (symbolP);\n \n-  symbolP->sy_frag = frag;\n+  symbolP->frag = frag;\n \n   obj_symbol_new_hook (symbolP);\n \n@@ -363,7 +345,7 @@ static unsigned long local_symbol_conversion_count;\n    changes its argument to the real symbol.  */\n \n #define LOCAL_SYMBOL_CHECK(s)\t\t\t\t\t\t\\\n-  (s->sy_flags.sy_local_symbol \t\t\t\t\t\t\\\n+  (s->flags.local_symbol\t\t\t\t\t\t\\\n    ? (local_symbol_converted_p ((struct local_symbol *) s)\t\t\\\n       ? (s = local_symbol_get_real_symbol ((struct local_symbol *) s),\t\\\n \t 0)\t\t\t\t\t\t\t\t\\\n@@ -377,18 +359,18 @@ local_symbol_make (const char *name, segT section, fragS *frag, valueT val)\n {\n   const char *name_copy;\n   struct local_symbol *ret;\n-  struct symbol_flags flags = { .sy_local_symbol = 1, .sy_resolved = 0 };\n+  struct symbol_flags flags = { .local_symbol = 1, .resolved = 0 };\n \n   ++local_symbol_count;\n \n   name_copy = save_symbol_name (name);\n \n   ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);\n-  ret->lsy_flags = flags;\n-  ret->lsy_name = name_copy;\n-  ret->lsy_section = section;\n-  local_symbol_set_frag (ret, frag);\n-  ret->lsy_value = val;\n+  ret->flags = flags;\n+  ret->name = name_copy;\n+  ret->section = section;\n+  ret->u.frag = frag;\n+  ret->value = val;\n \n   htab_insert (local_hash, symbol_entry_alloc (name_copy, ret));\n \n@@ -403,20 +385,20 @@ local_symbol_convert (struct local_symbol *locsym)\n {\n   symbolS *ret;\n \n-  gas_assert (locsym->lsy_flags.sy_local_symbol);\n+  gas_assert (locsym->flags.local_symbol);\n   if (local_symbol_converted_p (locsym))\n     return local_symbol_get_real_symbol (locsym);\n \n   ++local_symbol_conversion_count;\n \n-  ret = symbol_new (locsym->lsy_name, locsym->lsy_section,\n-\t\t    local_symbol_get_frag (locsym), locsym->lsy_value);\n+  ret = symbol_new (locsym->name, locsym->section,\n+\t\t    locsym->u.frag, locsym->value);\n \n-  if (local_symbol_resolved_p (locsym))\n-    ret->sy_flags.sy_resolved = 1;\n+  if (locsym->flags.resolved)\n+    ret->flags.resolved = 1;\n \n   /* Local symbols are always either defined or used.  */\n-  ret->sy_flags.sy_used = 1;\n+  ret->flags.used = 1;\n \n #ifdef TC_LOCAL_SYMFIELD_CONVERT\n   TC_LOCAL_SYMFIELD_CONVERT (locsym, ret);\n@@ -427,15 +409,15 @@ local_symbol_convert (struct local_symbol *locsym)\n   local_symbol_mark_converted (locsym);\n   local_symbol_set_real_symbol (locsym, ret);\n \n-  htab_insert (local_hash, symbol_entry_alloc (locsym->lsy_name, NULL));\n+  htab_insert (local_hash, symbol_entry_alloc (locsym->name, NULL));\n \n   return ret;\n }\n \f\n static void\n define_sym_at_dot (symbolS *symbolP)\n {\n-  symbolP->sy_frag = frag_now;\n+  symbolP->frag = frag_now;\n   S_SET_VALUE (symbolP, (valueT) frag_now_fix ());\n   S_SET_SEGMENT (symbolP, now_seg);\n }\n@@ -516,18 +498,18 @@ colon (/* Just seen \"x:\" - rattle symbols & frags.  */\n \t{\n \t  struct local_symbol *locsym = (struct local_symbol *) symbolP;\n \n-\t  if (locsym->lsy_section != undefined_section\n-\t      && (local_symbol_get_frag (locsym) != frag_now\n-\t\t  || locsym->lsy_section != now_seg\n-\t\t  || locsym->lsy_value != frag_now_fix ()))\n+\t  if (locsym->section != undefined_section\n+\t      && (locsym->u.frag != frag_now\n+\t\t  || locsym->section != now_seg\n+\t\t  || locsym->value != frag_now_fix ()))\n \t    {\n \t      as_bad (_(\"symbol `%s' is already defined\"), sym_name);\n \t      return symbolP;\n \t    }\n \n-\t  locsym->lsy_section = now_seg;\n-\t  local_symbol_set_frag (locsym, frag_now);\n-\t  locsym->lsy_value = frag_now_fix ();\n+\t  locsym->section = now_seg;\n+\t  locsym->u.frag = frag_now;\n+\t  locsym->value = frag_now_fix ();\n \t}\n       else if (!(S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))\n \t       || S_IS_COMMON (symbolP)\n@@ -612,7 +594,7 @@ colon (/* Just seen \"x:\" - rattle symbols & frags.  */\n       else\n \t{\n \t  /* Don't blow up if the definition is the same.  */\n-\t  if (!(frag_now == symbolP->sy_frag\n+\t  if (!(frag_now == symbolP->frag\n \t\t&& S_GET_VALUE (symbolP) == frag_now_fix ()\n \t\t&& S_GET_SEGMENT (symbolP) == now_seg))\n \t    {\n@@ -641,12 +623,12 @@ colon (/* Just seen \"x:\" - rattle symbols & frags.  */\n \t section.  This requires special handling.  */\n       if (LOCAL_SYMBOL_CHECK (symbolP))\n \tsymbolP = local_symbol_convert ((struct local_symbol *) symbolP);\n-      symbolP->sy_value.X_op = O_symbol;\n-      symbolP->sy_value.X_add_symbol = mri_common_symbol;\n-      symbolP->sy_value.X_add_number = S_GET_VALUE (mri_common_symbol);\n-      symbolP->sy_frag = &zero_address_frag;\n+      symbolP->value.X_op = O_symbol;\n+      symbolP->value.X_add_symbol = mri_common_symbol;\n+      symbolP->value.X_add_number = S_GET_VALUE (mri_common_symbol);\n+      symbolP->frag = &zero_address_frag;\n       S_SET_SEGMENT (symbolP, expr_section);\n-      symbolP->sy_flags.sy_mri_common = 1;\n+      symbolP->flags.mri_common = 1;\n     }\n \n #ifdef tc_frob_label\n@@ -762,19 +744,19 @@ symbol_clone (symbolS *orgsymP, int replace)\n     {\n       if (symbol_rootP == orgsymP)\n \tsymbol_rootP = newsymP;\n-      else if (orgsymP->sy_previous)\n+      else if (orgsymP->previous)\n \t{\n-\t  orgsymP->sy_previous->sy_next = newsymP;\n-\t  orgsymP->sy_previous = NULL;\n+\t  orgsymP->previous->next = newsymP;\n+\t  orgsymP->previous = NULL;\n \t}\n       if (symbol_lastP == orgsymP)\n \tsymbol_lastP = newsymP;\n-      else if (orgsymP->sy_next)\n-\torgsymP->sy_next->sy_previous = newsymP;\n+      else if (orgsymP->next)\n+\torgsymP->next->previous = newsymP;\n \n       /* Symbols that won't be output can't be external.  */\n       S_CLEAR_EXTERNAL (orgsymP);\n-      orgsymP->sy_previous = orgsymP->sy_next = orgsymP;\n+      orgsymP->previous = orgsymP->next = orgsymP;\n       debug_verify_symchain (symbol_rootP, symbol_lastP);\n \n       symbol_table_insert (newsymP);\n@@ -783,7 +765,7 @@ symbol_clone (symbolS *orgsymP, int replace)\n     {\n       /* Symbols that won't be output can't be external.  */\n       S_CLEAR_EXTERNAL (newsymP);\n-      newsymP->sy_previous = newsymP->sy_next = newsymP;\n+      newsymP->previous = newsymP->next = newsymP;\n     }\n \n   return newsymP;\n@@ -796,7 +778,7 @@ static inline symbolS *\n get_real_sym (symbolS *s)\n {\n   if (s != NULL\n-      && s->sy_flags.sy_local_symbol\n+      && s->flags.local_symbol\n       && local_symbol_converted_p ((struct local_symbol *) s))\n     s = local_symbol_get_real_symbol ((struct local_symbol *) s);\n   return s;\n@@ -812,12 +794,12 @@ symbol_clone_if_forward_ref (symbolS *symbolP, int is_forward)\n {\n   if (symbolP && !LOCAL_SYMBOL_CHECK (symbolP))\n     {\n-      symbolS *orig_add_symbol = get_real_sym (symbolP->sy_value.X_add_symbol);\n-      symbolS *orig_op_symbol = get_real_sym (symbolP->sy_value.X_op_symbol);\n+      symbolS *orig_add_symbol = get_real_sym (symbolP->value.X_add_symbol);\n+      symbolS *orig_op_symbol = get_real_sym (symbolP->value.X_op_symbol);\n       symbolS *add_symbol = orig_add_symbol;\n       symbolS *op_symbol = orig_op_symbol;\n \n-      if (symbolP->sy_flags.sy_forward_ref)\n+      if (symbolP->flags.forward_ref)\n \tis_forward = 1;\n \n       if (is_forward)\n@@ -831,26 +813,26 @@ symbol_clone_if_forward_ref (symbolS *symbolP, int is_forward)\n \t    op_symbol = symbol_find_exact (S_GET_NAME (op_symbol));\n \t}\n \n-      /* Re-using sy_resolving here, as this routine cannot get called from\n+      /* Re-using resolving here, as this routine cannot get called from\n \t symbol resolution code.  */\n       if ((symbolP->bsym->section == expr_section\n-           || symbolP->sy_flags.sy_forward_ref)\n-\t  && !symbolP->sy_flags.sy_resolving)\n+\t   || symbolP->flags.forward_ref)\n+\t  && !symbolP->flags.resolving)\n \t{\n-\t  symbolP->sy_flags.sy_resolving = 1;\n+\t  symbolP->flags.resolving = 1;\n \t  add_symbol = symbol_clone_if_forward_ref (add_symbol, is_forward);\n \t  op_symbol = symbol_clone_if_forward_ref (op_symbol, is_forward);\n-\t  symbolP->sy_flags.sy_resolving = 0;\n+\t  symbolP->flags.resolving = 0;\n \t}\n \n-      if (symbolP->sy_flags.sy_forward_ref\n+      if (symbolP->flags.forward_ref\n \t  || add_symbol != orig_add_symbol\n \t  || op_symbol != orig_op_symbol)\n \t{\n \t  if (symbolP != &dot_symbol)\n \t    {\n \t      symbolP = symbol_clone (symbolP, 0);\n-\t      symbolP->sy_flags.sy_resolving = 0;\n+\t      symbolP->flags.resolving = 0;\n \t    }\n \t  else\n \t    {\n@@ -861,8 +843,8 @@ symbol_clone_if_forward_ref (symbolS *symbolP, int is_forward)\n \t    }\n \t}\n \n-      symbolP->sy_value.X_add_symbol = add_symbol;\n-      symbolP->sy_value.X_op_symbol = op_symbol;\n+      symbolP->value.X_add_symbol = add_symbol;\n+      symbolP->value.X_op_symbol = op_symbol;\n     }\n \n   return symbolP;\n@@ -978,6 +960,9 @@ void\n symbol_append (symbolS *addme, symbolS *target,\n \t       symbolS **rootPP, symbolS **lastPP)\n {\n+  extern int symbol_table_frozen;\n+  if (symbol_table_frozen)\n+    abort ();\n   if (LOCAL_SYMBOL_CHECK (addme))\n     abort ();\n   if (target != NULL && LOCAL_SYMBOL_CHECK (target))\n@@ -987,26 +972,26 @@ symbol_append (symbolS *addme, symbolS *target,\n     {\n       know (*rootPP == NULL);\n       know (*lastPP == NULL);\n-      addme->sy_next = NULL;\n-      addme->sy_previous = NULL;\n+      addme->next = NULL;\n+      addme->previous = NULL;\n       *rootPP = addme;\n       *lastPP = addme;\n       return;\n     }\t\t\t\t/* if the list is empty  */\n \n-  if (target->sy_next != NULL)\n+  if (target->next != NULL)\n     {\n-      target->sy_next->sy_previous = addme;\n+      target->next->previous = addme;\n     }\n   else\n     {\n       know (*lastPP == target);\n       *lastPP = addme;\n     }\t\t\t\t/* if we have a next  */\n \n-  addme->sy_next = target->sy_next;\n-  target->sy_next = addme;\n-  addme->sy_previous = target;\n+  addme->next = target->next;\n+  target->next = addme;\n+  addme->previous = target;\n \n   debug_verify_symchain (symbol_rootP, symbol_lastP);\n }\n@@ -1018,8 +1003,8 @@ symbol_clear_list_pointers (symbolS *symbolP)\n {\n   if (LOCAL_SYMBOL_CHECK (symbolP))\n     abort ();\n-  symbolP->sy_next = NULL;\n-  symbolP->sy_previous = NULL;\n+  symbolP->next = NULL;\n+  symbolP->previous = NULL;\n }\n \n /* Remove SYMBOLP from the list.  */\n@@ -1032,22 +1017,22 @@ symbol_remove (symbolS *symbolP, symbolS **rootPP, symbolS **lastPP)\n \n   if (symbolP == *rootPP)\n     {\n-      *rootPP = symbolP->sy_next;\n+      *rootPP = symbolP->next;\n     }\t\t\t\t/* if it was the root  */\n \n   if (symbolP == *lastPP)\n     {\n-      *lastPP = symbolP->sy_previous;\n+      *lastPP = symbolP->previous;\n     }\t\t\t\t/* if it was the tail  */\n \n-  if (symbolP->sy_next != NULL)\n+  if (symbolP->next != NULL)\n     {\n-      symbolP->sy_next->sy_previous = symbolP->sy_previous;\n+      symbolP->next->previous = symbolP->previous;\n     }\t\t\t\t/* if not last  */\n \n-  if (symbolP->sy_previous != NULL)\n+  if (symbolP->previous != NULL)\n     {\n-      symbolP->sy_previous->sy_next = symbolP->sy_next;\n+      symbolP->previous->next = symbolP->next;\n     }\t\t\t\t/* if not first  */\n \n   debug_verify_symchain (*rootPP, *lastPP);\n@@ -1059,24 +1044,27 @@ void\n symbol_insert (symbolS *addme, symbolS *target,\n \t       symbolS **rootPP, symbolS **lastPP ATTRIBUTE_UNUSED)\n {\n+  extern int symbol_table_frozen;\n+  if (symbol_table_frozen)\n+    abort ();\n   if (LOCAL_SYMBOL_CHECK (addme))\n     abort ();\n   if (LOCAL_SYMBOL_CHECK (target))\n     abort ();\n \n-  if (target->sy_previous != NULL)\n+  if (target->previous != NULL)\n     {\n-      target->sy_previous->sy_next = addme;\n+      target->previous->next = addme;\n     }\n   else\n     {\n       know (*rootPP == target);\n       *rootPP = addme;\n     }\t\t\t\t/* if not first  */\n \n-  addme->sy_previous = target->sy_previous;\n-  target->sy_previous = addme;\n-  addme->sy_next = target;\n+  addme->previous = target->previous;\n+  target->previous = addme;\n+  addme->next = target;\n \n   debug_verify_symchain (*rootPP, *lastPP);\n }\n@@ -1092,8 +1080,8 @@ verify_symbol_chain (symbolS *rootP, symbolS *lastP)\n   for (; symbol_next (symbolP) != NULL; symbolP = symbol_next (symbolP))\n     {\n       gas_assert (symbolP->bsym != NULL);\n-      gas_assert (symbolP->sy_flags.sy_local_symbol == 0);\n-      gas_assert (symbolP->sy_next->sy_previous == symbolP);\n+      gas_assert (symbolP->flags.local_symbol == 0);\n+      gas_assert (symbolP->next->previous == symbolP);\n     }\n \n   gas_assert (lastP == symbolP);\n@@ -1103,13 +1091,13 @@ int\n symbol_on_chain (symbolS *s, symbolS *rootPP, symbolS *lastPP)\n {\n   return (!LOCAL_SYMBOL_CHECK (s)\n-\t  && ((s->sy_next != s\n-\t       && s->sy_next != NULL\n-\t       && s->sy_next->sy_previous == s)\n+\t  && ((s->next != s\n+\t       && s->next != NULL\n+\t       && s->next->previous == s)\n \t      || s == lastPP)\n-\t  && ((s->sy_previous != s\n-\t       && s->sy_previous != NULL\n-\t       && s->sy_previous->sy_next == s)\n+\t  && ((s->previous != s\n+\t       && s->previous != NULL\n+\t       && s->previous->next == s)\n \t      || s == rootPP));\n }\n \n@@ -1118,7 +1106,7 @@ symbol_on_chain (symbolS *s, symbolS *rootPP, symbolS *lastPP)\n static int\n use_complex_relocs_for (symbolS * symp)\n {\n-  switch (symp->sy_value.X_op)\n+  switch (symp->value.X_op)\n     {\n     case O_constant:\n       return 0;\n@@ -1142,20 +1130,20 @@ use_complex_relocs_for (symbolS * symp)\n     case O_gt:\n     case O_logical_and:\n     case O_logical_or:\n-      if ((S_IS_COMMON (symp->sy_value.X_op_symbol)\n-\t   || S_IS_LOCAL (symp->sy_value.X_op_symbol))\n-\t  && S_IS_DEFINED (symp->sy_value.X_op_symbol)\n-\t  && S_GET_SEGMENT (symp->sy_value.X_op_symbol) != expr_section)\n+      if ((S_IS_COMMON (symp->value.X_op_symbol)\n+\t   || S_IS_LOCAL (symp->value.X_op_symbol))\n+\t  && S_IS_DEFINED (symp->value.X_op_symbol)\n+\t  && S_GET_SEGMENT (symp->value.X_op_symbol) != expr_section)\n \t{\n \tcase O_symbol:\n \tcase O_symbol_rva:\n \tcase O_uminus:\n \tcase O_bit_not:\n \tcase O_logical_not:\n-\t  if ((S_IS_COMMON (symp->sy_value.X_add_symbol)\n-\t       || S_IS_LOCAL (symp->sy_value.X_add_symbol))\n-\t      && S_IS_DEFINED (symp->sy_value.X_add_symbol)\n-\t      && S_GET_SEGMENT (symp->sy_value.X_add_symbol) != expr_section)\n+\t  if ((S_IS_COMMON (symp->value.X_add_symbol)\n+\t       || S_IS_LOCAL (symp->value.X_add_symbol))\n+\t      && S_IS_DEFINED (symp->value.X_add_symbol)\n+\t      && S_GET_SEGMENT (symp->value.X_add_symbol) != expr_section)\n \t    return 0;\n \t}\n       break;\n@@ -1245,45 +1233,44 @@ resolve_symbol_value (symbolS *symp)\n     {\n       struct local_symbol *locsym = (struct local_symbol *) symp;\n \n-      final_val = locsym->lsy_value;\n-      if (local_symbol_resolved_p (locsym))\n+      final_val = locsym->value;\n+      if (locsym->flags.resolved)\n \treturn final_val;\n \n       /* Symbols whose section has SEC_ELF_OCTETS set,\n \t resolve to octets instead of target bytes. */\n-      if (locsym->lsy_section->flags & SEC_OCTETS)\n-\tfinal_val += local_symbol_get_frag (locsym)->fr_address;\n+      if (locsym->section->flags & SEC_OCTETS)\n+\tfinal_val += locsym->u.frag->fr_address;\n       else\n-\tfinal_val += (local_symbol_get_frag (locsym)->fr_address\n-\t\t      / OCTETS_PER_BYTE);\n+\tfinal_val += locsym->u.frag->fr_address / OCTETS_PER_BYTE;\n \n       if (finalize_syms)\n \t{\n-\t  locsym->lsy_value = final_val;\n-\t  local_symbol_mark_resolved (locsym);\n+\t  locsym->value = final_val;\n+\t  locsym->flags.resolved = 1;\n \t}\n \n       return final_val;\n     }\n \n-  if (symp->sy_flags.sy_resolved)\n+  if (symp->flags.resolved)\n     {\n       final_val = 0;\n-      while (symp->sy_value.X_op == O_symbol)\n+      while (symp->value.X_op == O_symbol)\n \t{\n-\t  final_val += symp->sy_value.X_add_number;\n-\t  symp = symp->sy_value.X_add_symbol;\n+\t  final_val += symp->value.X_add_number;\n+\t  symp = symp->value.X_add_symbol;\n \t  if (LOCAL_SYMBOL_CHECK (symp))\n \t    {\n \t      struct local_symbol *locsym = (struct local_symbol *) symp;\n-\t      final_val += locsym->lsy_value;\n+\t      final_val += locsym->value;\n \t      return final_val;\n \t    }\n-\t  if (!symp->sy_flags.sy_resolved)\n+\t  if (!symp->flags.resolved)\n \t    return 0;\n \t}\n-      if (symp->sy_value.X_op == O_constant)\n-\tfinal_val += symp->sy_value.X_add_number;\n+      if (symp->value.X_op == O_constant)\n+\tfinal_val += symp->value.X_add_number;\n       else\n \tfinal_val = 0;\n       return final_val;\n@@ -1292,7 +1279,7 @@ resolve_symbol_value (symbolS *symp)\n   resolved = 0;\n   final_seg = S_GET_SEGMENT (symp);\n \n-  if (symp->sy_flags.sy_resolving)\n+  if (symp->flags.resolving)\n     {\n       if (finalize_syms)\n \tas_bad (_(\"symbol definition loop encountered at `%s'\"),\n@@ -1307,11 +1294,11 @@ resolve_symbol_value (symbolS *symp)\n       symbolS * relc_symbol = NULL;\n       char * relc_symbol_name = NULL;\n \n-      relc_symbol_name = symbol_relc_make_expr (& symp->sy_value);\n+      relc_symbol_name = symbol_relc_make_expr (& symp->value);\n \n       /* For debugging, print out conversion input & output.  */\n #ifdef DEBUG_SYMS\n-      print_expr (& symp->sy_value);\n+      print_expr (& symp->value);\n       if (relc_symbol_name)\n \tfprintf (stderr, \"-> relc symbol: %s\\n\", relc_symbol_name);\n #endif\n@@ -1330,16 +1317,16 @@ resolve_symbol_value (symbolS *symp)\n \t{\n \t  symbol_table_insert (relc_symbol);\n \n- \t  /* S_CLEAR_EXTERNAL (relc_symbol); */\n+\t  /* S_CLEAR_EXTERNAL (relc_symbol); */\n \t  if (symp->bsym->flags & BSF_SRELC)\n \t    relc_symbol->bsym->flags |= BSF_SRELC;\n \t  else\n \t    relc_symbol->bsym->flags |= BSF_RELC;\n \t  /* symp->bsym->flags |= BSF_RELC; */\n \t  copy_symbol_attributes (symp, relc_symbol);\n-\t  symp->sy_value.X_op = O_symbol;\n-\t  symp->sy_value.X_add_symbol = relc_symbol;\n-\t  symp->sy_value.X_add_number = 0;\n+\t  symp->value.X_op = O_symbol;\n+\t  symp->value.X_add_symbol = relc_symbol;\n+\t  symp->value.X_add_number = 0;\n \t  resolved = 1;\n \t}\n \n@@ -1356,13 +1343,13 @@ resolve_symbol_value (symbolS *symp)\n       operatorT op;\n       int move_seg_ok;\n \n-      symp->sy_flags.sy_resolving = 1;\n+      symp->flags.resolving = 1;\n \n       /* Help out with CSE.  */\n-      add_symbol = symp->sy_value.X_add_symbol;\n-      op_symbol = symp->sy_value.X_op_symbol;\n-      final_val = symp->sy_value.X_add_number;\n-      op = symp->sy_value.X_op;\n+      add_symbol = symp->value.X_add_symbol;\n+      op_symbol = symp->value.X_op_symbol;\n+      final_val = symp->value.X_add_number;\n+      op = symp->value.X_op;\n \n       switch (op)\n \t{\n@@ -1378,9 +1365,9 @@ resolve_symbol_value (symbolS *symp)\n \t  /* Symbols whose section has SEC_ELF_OCTETS set,\n \t     resolve to octets instead of target bytes. */\n \t  if (symp->bsym->section->flags & SEC_OCTETS)\n-\t    final_val += symp->sy_frag->fr_address;\n+\t    final_val += symp->frag->fr_address;\n \t  else\n-\t    final_val += symp->sy_frag->fr_address / OCTETS_PER_BYTE;\n+\t    final_val += symp->frag->fr_address / OCTETS_PER_BYTE;\n \t  if (final_seg == expr_section)\n \t    final_seg = absolute_section;\n \t  /* Fall through.  */\n@@ -1394,23 +1381,23 @@ resolve_symbol_value (symbolS *symp)\n \t  left = resolve_symbol_value (add_symbol);\n \t  seg_left = S_GET_SEGMENT (add_symbol);\n \t  if (finalize_syms)\n-\t    symp->sy_value.X_op_symbol = NULL;\n+\t    symp->value.X_op_symbol = NULL;\n \n \tdo_symbol:\n \t  if (S_IS_WEAKREFR (symp))\n \t    {\n \t      gas_assert (final_val == 0);\n \t      if (S_IS_WEAKREFR (add_symbol))\n \t\t{\n-\t\t  gas_assert (add_symbol->sy_value.X_op == O_symbol\n-\t\t\t  && add_symbol->sy_value.X_add_number == 0);\n-\t\t  add_symbol = add_symbol->sy_value.X_add_symbol;\n+\t\t  gas_assert (add_symbol->value.X_op == O_symbol\n+\t\t\t  && add_symbol->value.X_add_number == 0);\n+\t\t  add_symbol = add_symbol->value.X_add_symbol;\n \t\t  gas_assert (! S_IS_WEAKREFR (add_symbol));\n-\t\t  symp->sy_value.X_add_symbol = add_symbol;\n+\t\t  symp->value.X_add_symbol = add_symbol;\n \t\t}\n \t    }\n \n-\t  if (symp->sy_flags.sy_mri_common)\n+\t  if (symp->flags.mri_common)\n \t    {\n \t      /* This is a symbol inside an MRI common section.  The\n \t\t relocation routines are going to handle it specially.\n@@ -1422,7 +1409,7 @@ resolve_symbol_value (symbolS *symp)\n \t  /* Don't leave symbol loops.  */\n \t  if (finalize_syms\n \t      && !LOCAL_SYMBOL_CHECK (add_symbol)\n-\t      && add_symbol->sy_flags.sy_resolving)\n+\t      && add_symbol->flags.resolving)\n \t    break;\n \n \t  if (finalize_syms && final_val == 0)\n@@ -1452,29 +1439,29 @@ resolve_symbol_value (symbolS *symp)\n \t    {\n \t      if (finalize_syms)\n \t\t{\n-\t\t  symp->sy_value.X_op = O_symbol;\n-\t\t  symp->sy_value.X_add_symbol = add_symbol;\n-\t\t  symp->sy_value.X_add_number = final_val;\n+\t\t  symp->value.X_op = O_symbol;\n+\t\t  symp->value.X_add_symbol = add_symbol;\n+\t\t  symp->value.X_add_number = final_val;\n \t\t  /* Use X_op_symbol as a flag.  */\n-\t\t  symp->sy_value.X_op_symbol = add_symbol;\n+\t\t  symp->value.X_op_symbol = add_symbol;\n \t\t}\n \t      final_seg = seg_left;\n-\t      final_val += symp->sy_frag->fr_address + left;\n+\t      final_val += symp->frag->fr_address + left;\n \t      resolved = symbol_resolved_p (add_symbol);\n-\t      symp->sy_flags.sy_resolving = 0;\n+\t      symp->flags.resolving = 0;\n \t      goto exit_dont_set_value;\n \t    }\n \t  else\n \t    {\n-\t      final_val += symp->sy_frag->fr_address + left;\n+\t      final_val += symp->frag->fr_address + left;\n \t      if (final_seg == expr_section || final_seg == undefined_section)\n \t\tfinal_seg = seg_left;\n \t    }\n \n \t  resolved = symbol_resolved_p (add_symbol);\n \t  if (S_IS_WEAKREFR (symp))\n \t    {\n-\t      symp->sy_flags.sy_resolving = 0;\n+\t      symp->flags.resolving = 0;\n \t      goto exit_dont_set_value;\n \t    }\n \t  break;\n@@ -1486,9 +1473,9 @@ resolve_symbol_value (symbolS *symp)\n \t  seg_left = S_GET_SEGMENT (add_symbol);\n \n \t  /* By reducing these to the relevant dyadic operator, we get\n-\t     \t!S -> S == 0 \tpermitted on anything,\n-\t\t-S -> 0 - S \tonly permitted on absolute\n-\t\t~S -> S ^ ~0 \tonly permitted on absolute  */\n+\t\t!S -> S == 0\tpermitted on anything,\n+\t\t-S -> 0 - S\tonly permitted on absolute\n+\t\t~S -> S ^ ~0\tonly permitted on absolute  */\n \t  if (op != O_logical_not && seg_left != absolute_section\n \t      && finalize_syms)\n \t    report_op_error (symp, NULL, op, add_symbol);\n@@ -1503,7 +1490,7 @@ resolve_symbol_value (symbolS *symp)\n \t  else\n \t    left = ~left;\n \n-\t  final_val += left + symp->sy_frag->fr_address;\n+\t  final_val += left + symp->frag->fr_address;\n \n \t  resolved = symbol_resolved_p (add_symbol);\n \t  break;\n@@ -1612,7 +1599,7 @@ resolve_symbol_value (symbolS *symp)\n \t      right = 1;\n \t    }\n \n-\t  switch (symp->sy_value.X_op)\n+\t  switch (symp->value.X_op)\n \t    {\n \t    case O_multiply:\t\tleft *= right; break;\n \t    case O_divide:\t\tleft /= right; break;\n@@ -1631,7 +1618,7 @@ resolve_symbol_value (symbolS *symp)\n \t\t      && (seg_left != undefined_section\n \t\t\t  || add_symbol == op_symbol)\n \t\t      ? ~ (offsetT) 0 : 0);\n-\t      if (symp->sy_value.X_op == O_ne)\n+\t      if (symp->value.X_op == O_ne)\n \t\tleft = ~left;\n \t      break;\n \t    case O_lt:\tleft = left <  right ? ~ (offsetT) 0 : 0; break;\n@@ -1652,7 +1639,7 @@ resolve_symbol_value (symbolS *symp)\n \t      abort ();\n \t    }\n \n-\t  final_val += symp->sy_frag->fr_address + left;\n+\t  final_val += symp->frag->fr_address + left;\n \t  if (final_seg == expr_section || final_seg == undefined_section)\n \t    {\n \t      if (seg_left == undefined_section\n@@ -1677,7 +1664,7 @@ resolve_symbol_value (symbolS *symp)\n \t  break;\n \t}\n \n-      symp->sy_flags.sy_resolving = 0;\n+      symp->flags.resolving = 0;\n     }\n \n   if (finalize_syms)\n@@ -1692,12 +1679,12 @@ resolve_symbol_value (symbolS *symp)\n   if (finalize_syms)\n     {\n       if (resolved)\n-\tsymp->sy_flags.sy_resolved = 1;\n+\tsymp->flags.resolved = 1;\n       else if (S_GET_SEGMENT (symp) != expr_section)\n \t{\n \t  as_bad (_(\"can't resolve value for symbol `%s'\"),\n \t\t  S_GET_NAME (symp));\n-\t  symp->sy_flags.sy_resolved = 1;\n+\t  symp->flags.resolved = 1;\n \t}\n     }\n \n@@ -1736,23 +1723,23 @@ snapshot_symbol (symbolS **symbolPP, valueT *valueP, segT *segP, fragS **fragPP)\n     {\n       struct local_symbol *locsym = (struct local_symbol *) symbolP;\n \n-      *valueP = locsym->lsy_value;\n-      *segP = locsym->lsy_section;\n-      *fragPP = local_symbol_get_frag (locsym);\n+      *valueP = locsym->value;\n+      *segP = locsym->section;\n+      *fragPP = locsym->u.frag;\n     }\n   else\n     {\n-      expressionS exp = symbolP->sy_value;\n+      expressionS exp = symbolP->value;\n \n-      if (!symbolP->sy_flags.sy_resolved && exp.X_op != O_illegal)\n+      if (!symbolP->flags.resolved && exp.X_op != O_illegal)\n \t{\n \t  int resolved;\n \n-\t  if (symbolP->sy_flags.sy_resolving)\n+\t  if (symbolP->flags.resolving)\n \t    return 0;\n-\t  symbolP->sy_flags.sy_resolving = 1;\n+\t  symbolP->flags.resolving = 1;\n \t  resolved = resolve_expression (&exp);\n-\t  symbolP->sy_flags.sy_resolving = 0;\n+\t  symbolP->flags.resolving = 0;\n \t  if (!resolved)\n \t    return 0;\n \n@@ -1780,15 +1767,15 @@ snapshot_symbol (symbolS **symbolPP, valueT *valueP, segT *segP, fragS **fragPP)\n \t{\n \t  struct local_symbol *locsym = (struct local_symbol *) symbolP;\n \n-\t  *valueP = locsym->lsy_value;\n-\t  *segP = locsym->lsy_section;\n-\t  *fragPP = local_symbol_get_frag (locsym);\n+\t  *valueP = locsym->value;\n+\t  *segP = locsym->section;\n+\t  *fragPP = locsym->u.frag;\n \t}\n       else\n \t{\n \t  *valueP = exp.X_add_number;\n \t  *segP = symbolP->bsym->section;\n-\t  *fragPP = symbolP->sy_frag;\n+\t  *fragPP = symbolP->frag;\n \t}\n \n       if (*segP == expr_section)\n@@ -2170,24 +2157,24 @@ S_GET_VALUE (symbolS *s)\n   if (LOCAL_SYMBOL_CHECK (s))\n     return resolve_symbol_value (s);\n \n-  if (!s->sy_flags.sy_resolved)\n+  if (!s->flags.resolved)\n     {\n       valueT val = resolve_symbol_value (s);\n       if (!finalize_syms)\n \treturn val;\n     }\n   if (S_IS_WEAKREFR (s))\n-    return S_GET_VALUE (s->sy_value.X_add_symbol);\n+    return S_GET_VALUE (s->value.X_add_symbol);\n \n-  if (s->sy_value.X_op != O_constant)\n+  if (s->value.X_op != O_constant)\n     {\n-      if (! s->sy_flags.sy_resolved\n-\t  || s->sy_value.X_op != O_symbol\n+      if (! s->flags.resolved\n+\t  || s->value.X_op != O_symbol\n \t  || (S_IS_DEFINED (s) && ! S_IS_COMMON (s)))\n \tas_bad (_(\"attempt to get value of unresolved symbol `%s'\"),\n \t\tS_GET_NAME (s));\n     }\n-  return (valueT) s->sy_value.X_add_number;\n+  return (valueT) s->value.X_add_number;\n }\n \n /* Set the value of a symbol.  */\n@@ -2197,13 +2184,13 @@ S_SET_VALUE (symbolS *s, valueT val)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     {\n-      ((struct local_symbol *) s)->lsy_value = val;\n+      ((struct local_symbol *) s)->value = val;\n       return;\n     }\n \n-  s->sy_value.X_op = O_constant;\n-  s->sy_value.X_add_number = (offsetT) val;\n-  s->sy_value.X_unsigned = 0;\n+  s->value.X_op = O_constant;\n+  s->value.X_add_number = (offsetT) val;\n+  s->value.X_unsigned = 0;\n   S_CLEAR_WEAKREFR (s);\n }\n \n@@ -2270,7 +2257,7 @@ S_IS_WEAK (symbolS *s)\n      the referenced symbol has lost its weak status, there's no reason\n      to keep handling the weakrefr as if it was weak.  */\n   if (S_IS_WEAKREFR (s))\n-    return S_IS_WEAK (s->sy_value.X_add_symbol);\n+    return S_IS_WEAK (s->value.X_add_symbol);\n   return (s->bsym->flags & BSF_WEAK) != 0;\n }\n \n@@ -2279,15 +2266,15 @@ S_IS_WEAKREFR (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_flags.sy_weakrefr != 0;\n+  return s->flags.weakrefr != 0;\n }\n \n int\n S_IS_WEAKREFD (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_flags.sy_weakrefd != 0;\n+  return s->flags.weakrefd != 0;\n }\n \n int\n@@ -2302,7 +2289,7 @@ int\n S_IS_DEFINED (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n-    return ((struct local_symbol *) s)->lsy_section != undefined_section;\n+    return ((struct local_symbol *) s)->section != undefined_section;\n   return s->bsym->section != undefined_section;\n }\n \n@@ -2319,7 +2306,7 @@ S_FORCE_RELOC (symbolS *s, int strict)\n {\n   segT sec;\n   if (LOCAL_SYMBOL_CHECK (s))\n-    sec = ((struct local_symbol *) s)->lsy_section;\n+    sec = ((struct local_symbol *) s)->section;\n   else\n     {\n       if ((strict\n@@ -2394,7 +2381,7 @@ int\n S_CAN_BE_REDEFINED (const symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n-    return (local_symbol_get_frag ((struct local_symbol *) s)\n+    return (((struct local_symbol *) s)->u.frag\n \t    == &predefined_address_frag);\n   /* Permit register names to be redefined.  */\n   return s->bsym->section == reg_section;\n@@ -2405,30 +2392,30 @@ S_IS_VOLATILE (const symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_flags.sy_volatile;\n+  return s->flags.volatil;\n }\n \n int\n S_IS_FORWARD_REF (const symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_flags.sy_forward_ref;\n+  return s->flags.forward_ref;\n }\n \n const char *\n S_GET_NAME (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n-    return ((struct local_symbol *) s)->lsy_name;\n+    return ((struct local_symbol *) s)->name;\n   return s->bsym->name;\n }\n \n segT\n S_GET_SEGMENT (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n-    return ((struct local_symbol *) s)->lsy_section;\n+    return ((struct local_symbol *) s)->section;\n   return s->bsym->section;\n }\n \n@@ -2445,7 +2432,7 @@ S_SET_SEGMENT (symbolS *s, segT seg)\n \ts = local_symbol_convert ((struct local_symbol *) s);\n       else\n \t{\n-\t  ((struct local_symbol *) s)->lsy_section = seg;\n+\t  ((struct local_symbol *) s)->section = seg;\n \t  return;\n \t}\n     }\n@@ -2523,31 +2510,31 @@ S_SET_WEAKREFR (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_flags.sy_weakrefr = 1;\n+  s->flags.weakrefr = 1;\n   /* If the alias was already used, make sure we mark the target as\n      used as well, otherwise it might be dropped from the symbol\n      table.  This may have unintended side effects if the alias is\n      later redirected to another symbol, such as keeping the unused\n      previous target in the symbol table.  Since it will be weak, it's\n      not a big deal.  */\n-  if (s->sy_flags.sy_used)\n-    symbol_mark_used (s->sy_value.X_add_symbol);\n+  if (s->flags.used)\n+    symbol_mark_used (s->value.X_add_symbol);\n }\n \n void\n S_CLEAR_WEAKREFR (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return;\n-  s->sy_flags.sy_weakrefr = 0;\n+  s->flags.weakrefr = 0;\n }\n \n void\n S_SET_WEAKREFD (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_flags.sy_weakrefd = 1;\n+  s->flags.weakrefd = 1;\n   S_SET_WEAK (s);\n }\n \n@@ -2556,9 +2543,9 @@ S_CLEAR_WEAKREFD (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return;\n-  if (s->sy_flags.sy_weakrefd)\n+  if (s->flags.weakrefd)\n     {\n-      s->sy_flags.sy_weakrefd = 0;\n+      s->flags.weakrefd = 0;\n       /* If a weakref target symbol is weak, then it was never\n \t referenced directly before, not even in a .global directive,\n \t so decay it to local.  If it remains undefined, it will be\n@@ -2598,7 +2585,7 @@ S_SET_NAME (symbolS *s, const char *name)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     {\n-      ((struct local_symbol *) s)->lsy_name = name;\n+      ((struct local_symbol *) s)->name = name;\n       return;\n     }\n   s->bsym->name = name;\n@@ -2609,22 +2596,22 @@ S_SET_VOLATILE (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_flags.sy_volatile = 1;\n+  s->flags.volatil = 1;\n }\n \n void\n S_CLEAR_VOLATILE (symbolS *s)\n {\n   if (!LOCAL_SYMBOL_CHECK (s))\n-    s->sy_flags.sy_volatile = 0;\n+    s->flags.volatil = 0;\n }\n \n void\n S_SET_FORWARD_REF (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_flags.sy_forward_ref = 1;\n+  s->flags.forward_ref = 1;\n }\n \n /* Return the previous symbol in a chain.  */\n@@ -2634,7 +2621,7 @@ symbol_previous (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     abort ();\n-  return s->sy_previous;\n+  return s->previous;\n }\n \n /* Return the next symbol in a chain.  */\n@@ -2644,7 +2631,7 @@ symbol_next (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     abort ();\n-  return s->sy_next;\n+  return s->next;\n }\n \n /* Return a pointer to the value of a symbol as an expression.  */\n@@ -2654,7 +2641,7 @@ symbol_get_value_expression (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  return &s->sy_value;\n+  return &s->value;\n }\n \n /* Set the value of a symbol to an expression.  */\n@@ -2664,7 +2651,7 @@ symbol_set_value_expression (symbolS *s, const expressionS *exp)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_value = *exp;\n+  s->value = *exp;\n   S_CLEAR_WEAKREFR (s);\n }\n \n@@ -2684,9 +2671,9 @@ offsetT *\n symbol_X_add_number (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n-    return (offsetT *) &((struct local_symbol *) s)->lsy_value;\n+    return (offsetT *) &((struct local_symbol *) s)->value;\n \n-  return &s->sy_value.X_add_number;\n+  return &s->value.X_add_number;\n }\n \n /* Set the value of SYM to the current position in the current segment.  */\n@@ -2706,10 +2693,10 @@ symbol_set_frag (symbolS *s, fragS *f)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     {\n-      local_symbol_set_frag ((struct local_symbol *) s, f);\n+      ((struct local_symbol *) s)->u.frag = f;\n       return;\n     }\n-  s->sy_frag = f;\n+  s->frag = f;\n   S_CLEAR_WEAKREFR (s);\n }\n \n@@ -2719,8 +2706,8 @@ fragS *\n symbol_get_frag (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n-    return local_symbol_get_frag ((struct local_symbol *) s);\n-  return s->sy_frag;\n+    return ((struct local_symbol *) s)->u.frag;\n+  return s->frag;\n }\n \n /* Mark a symbol as having been used.  */\n@@ -2730,9 +2717,9 @@ symbol_mark_used (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return;\n-  s->sy_flags.sy_used = 1;\n+  s->flags.used = 1;\n   if (S_IS_WEAKREFR (s))\n-    symbol_mark_used (s->sy_value.X_add_symbol);\n+    symbol_mark_used (s->value.X_add_symbol);\n }\n \n /* Clear the mark of whether a symbol has been used.  */\n@@ -2742,7 +2729,7 @@ symbol_clear_used (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_flags.sy_used = 0;\n+  s->flags.used = 0;\n }\n \n /* Return whether a symbol has been used.  */\n@@ -2752,7 +2739,7 @@ symbol_used_p (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 1;\n-  return s->sy_flags.sy_used;\n+  return s->flags.used;\n }\n \n /* Mark a symbol as having been used in a reloc.  */\n@@ -2762,7 +2749,7 @@ symbol_mark_used_in_reloc (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_flags.sy_used_in_reloc = 1;\n+  s->flags.used_in_reloc = 1;\n }\n \n /* Clear the mark of whether a symbol has been used in a reloc.  */\n@@ -2772,7 +2759,7 @@ symbol_clear_used_in_reloc (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return;\n-  s->sy_flags.sy_used_in_reloc = 0;\n+  s->flags.used_in_reloc = 0;\n }\n \n /* Return whether a symbol has been used in a reloc.  */\n@@ -2782,7 +2769,7 @@ symbol_used_in_reloc_p (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_flags.sy_used_in_reloc;\n+  return s->flags.used_in_reloc;\n }\n \n /* Mark a symbol as an MRI common symbol.  */\n@@ -2792,7 +2779,7 @@ symbol_mark_mri_common (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_flags.sy_mri_common = 1;\n+  s->flags.mri_common = 1;\n }\n \n /* Clear the mark of whether a symbol is an MRI common symbol.  */\n@@ -2802,7 +2789,7 @@ symbol_clear_mri_common (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return;\n-  s->sy_flags.sy_mri_common = 0;\n+  s->flags.mri_common = 0;\n }\n \n /* Return whether a symbol is an MRI common symbol.  */\n@@ -2812,7 +2799,7 @@ symbol_mri_common_p (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_flags.sy_mri_common;\n+  return s->flags.mri_common;\n }\n \n /* Mark a symbol as having been written.  */\n@@ -2822,7 +2809,7 @@ symbol_mark_written (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return;\n-  s->sy_flags.sy_written = 1;\n+  s->flags.written = 1;\n }\n \n /* Clear the mark of whether a symbol has been written.  */\n@@ -2832,7 +2819,7 @@ symbol_clear_written (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return;\n-  s->sy_flags.sy_written = 0;\n+  s->flags.written = 0;\n }\n \n /* Return whether a symbol has been written.  */\n@@ -2842,7 +2829,7 @@ symbol_written_p (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_flags.sy_written;\n+  return s->flags.written;\n }\n \n /* Mark a symbol has having been resolved.  */\n@@ -2852,10 +2839,10 @@ symbol_mark_resolved (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     {\n-      local_symbol_mark_resolved ((struct local_symbol *) s);\n+      ((struct local_symbol *) s)->flags.resolved = 1;\n       return;\n     }\n-  s->sy_flags.sy_resolved = 1;\n+  s->flags.resolved = 1;\n }\n \n /* Return whether a symbol has been resolved.  */\n@@ -2864,8 +2851,8 @@ int\n symbol_resolved_p (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n-    return local_symbol_resolved_p ((struct local_symbol *) s);\n-  return s->sy_flags.sy_resolved;\n+    return ((struct local_symbol *) s)->flags.resolved;\n+  return s->flags.resolved;\n }\n \n /* Return whether a symbol is a section symbol.  */\n@@ -2885,7 +2872,7 @@ symbol_equated_p (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_value.X_op == O_symbol;\n+  return s->value.X_op == O_symbol;\n }\n \n /* Return whether a symbol is equated to another symbol, and should be\n@@ -2899,11 +2886,11 @@ symbol_equated_reloc_p (symbolS *s)\n   /* X_op_symbol, normally not used for O_symbol, is set by\n      resolve_symbol_value to flag expression syms that have been\n      equated.  */\n-  return (s->sy_value.X_op == O_symbol\n+  return (s->value.X_op == O_symbol\n #if defined (OBJ_COFF) && defined (TE_PE)\n \t  && ! S_IS_WEAK (s)\n #endif\n-\t  && ((s->sy_flags.sy_resolved && s->sy_value.X_op_symbol != NULL)\n+\t  && ((s->flags.resolved && s->value.X_op_symbol != NULL)\n \t      || ! S_IS_DEFINED (s)\n \t      || S_IS_COMMON (s)));\n }\n@@ -2915,7 +2902,7 @@ symbol_constant_p (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 1;\n-  return s->sy_value.X_op == O_constant;\n+  return s->value.X_op == O_constant;\n }\n \n /* Return whether a symbol was cloned and thus removed from the global\n@@ -2926,7 +2913,7 @@ symbol_shadow_p (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     return 0;\n-  return s->sy_next == s;\n+  return s->next == s;\n }\n \n /* If S was created as a struct symbol, return S, otherwise if S is a\n@@ -2979,7 +2966,7 @@ symbol_get_obj (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  return &s->sy_obj;\n+  return &s->obj;\n }\n \n /* Set the object format information for a symbol.  */\n@@ -2989,7 +2976,7 @@ symbol_set_obj (symbolS *s, OBJ_SYMFIELD_TYPE *o)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_obj = *o;\n+  s->obj = *o;\n }\n \n #endif /* OBJ_SYMFIELD_TYPE */\n@@ -3003,7 +2990,7 @@ symbol_get_tc (symbolS *s)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  return &s->sy_tc;\n+  return &s->tc;\n }\n \n /* Set the processor information for a symbol.  */\n@@ -3013,7 +3000,7 @@ symbol_set_tc (symbolS *s, TC_SYMFIELD_TYPE *o)\n {\n   if (LOCAL_SYMBOL_CHECK (s))\n     s = local_symbol_convert ((struct local_symbol *) s);\n-  s->sy_tc = *o;\n+  s->tc = *o;\n }\n \n #endif /* TC_SYMFIELD_TYPE */\n@@ -3032,8 +3019,8 @@ symbol_begin (void)\n #if defined (EMIT_SECTION_SYMBOLS) || !defined (RELOC_REQUIRES_SYMBOL)\n   abs_symbol.bsym = bfd_abs_section_ptr->symbol;\n #endif\n-  abs_symbol.sy_value.X_op = O_constant;\n-  abs_symbol.sy_frag = &zero_address_frag;\n+  abs_symbol.value.X_op = O_constant;\n+  abs_symbol.frag = &zero_address_frag;\n \n   if (LOCAL_LABELS_FB)\n     fb_label_init ();\n@@ -3046,8 +3033,8 @@ dot_symbol_init (void)\n   if (dot_symbol.bsym == NULL)\n     as_fatal (\"bfd_make_empty_symbol: %s\", bfd_errmsg (bfd_get_error ()));\n   dot_symbol.bsym->name = \".\";\n-  dot_symbol.sy_flags.sy_forward_ref = 1;\n-  dot_symbol.sy_value.X_op = O_constant;\n+  dot_symbol.flags.forward_ref = 1;\n+  dot_symbol.value.X_op = O_constant;\n }\n \f\n int indent_level;\n@@ -3070,32 +3057,32 @@ print_symbol_value_1 (FILE *file, symbolS *sym)\n     {\n       struct local_symbol *locsym = (struct local_symbol *) sym;\n \n-      if (local_symbol_get_frag (locsym) != & zero_address_frag\n-\t  && local_symbol_get_frag (locsym) != NULL)\n+      if (locsym->u.frag != & zero_address_frag\n+\t  && locsym->u.frag != NULL)\n \t{\n \t  fprintf (file, \" frag \");\n-\t  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) local_symbol_get_frag (locsym)));\n-        }\n-      if (local_symbol_resolved_p (locsym))\n+\t  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) locsym->u.frag));\n+\t}\n+      if (locsym->flags.resolved)\n \tfprintf (file, \" resolved\");\n       fprintf (file, \" local\");\n     }\n   else\n     {\n-      if (sym->sy_frag != &zero_address_frag)\n+      if (sym->frag != &zero_address_frag)\n \t{\n \t  fprintf (file, \" frag \");\n-\t  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) sym->sy_frag));\n+\t  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) sym->frag));\n \t}\n-      if (sym->sy_flags.sy_written)\n+      if (sym->flags.written)\n \tfprintf (file, \" written\");\n-      if (sym->sy_flags.sy_resolved)\n+      if (sym->flags.resolved)\n \tfprintf (file, \" resolved\");\n-      else if (sym->sy_flags.sy_resolving)\n+      else if (sym->flags.resolving)\n \tfprintf (file, \" resolving\");\n-      if (sym->sy_flags.sy_used_in_reloc)\n+      if (sym->flags.used_in_reloc)\n \tfprintf (file, \" used-in-reloc\");\n-      if (sym->sy_flags.sy_used)\n+      if (sym->flags.used)\n \tfprintf (file, \" used\");\n       if (S_IS_LOCAL (sym))\n \tfprintf (file, \" local\");\n@@ -3128,9 +3115,9 @@ print_symbol_value_1 (FILE *file, symbolS *sym)\n       fprintf (file, \"\\n%*s<\", indent_level * 4, \"\");\n       if (LOCAL_SYMBOL_CHECK (sym))\n \tfprintf (file, \"constant %lx\",\n-\t\t (unsigned long) ((struct local_symbol *) sym)->lsy_value);\n+\t\t (unsigned long) ((struct local_symbol *) sym)->value);\n       else\n-\tprint_expr_1 (file, &sym->sy_value);\n+\tprint_expr_1 (file, &sym->value);\n       fprintf (file, \">\");\n       indent_level--;\n     }\n@@ -3294,7 +3281,7 @@ symbol_print_statistics (FILE *file)\n    nodes (plain symbols) in the expression tree.  The caller owns the\n    returning string, so should free it eventually.  Errors are\n    indicated via as_bad and a NULL return value.  The given symbol\n-   is marked with sy_used_in_reloc.  */\n+   is marked with used_in_reloc.  */\n \n char *\n symbol_relc_make_sym (symbolS * sym)\n@@ -3403,64 +3390,64 @@ symbol_relc_make_expr (expressionS * exp)\n \n       /* Helper macros for nesting nodes.  */\n \n-#define HANDLE_XADD_OPT1(str_) \t\t\t\t\t\t\\\n+#define HANDLE_XADD_OPT1(str_)\t\t\t\t\t\t\\\n       if (exp->X_add_number)\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          arity = 2;\t\t\t\t\t\t\t\\\n-          opstr = \"+:\" str_;\t\t\t\t\t\t\\\n-          operands[0] = symbol_relc_make_sym (exp->X_add_symbol);\t\\\n-          operands[1] = symbol_relc_make_value (exp->X_add_number);\t\\\n-          break;\t\t\t\t\t\t\t\\\n-        }\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  arity = 2;\t\t\t\t\t\t\t\\\n+\t  opstr = \"+:\" str_;\t\t\t\t\t\t\\\n+\t  operands[0] = symbol_relc_make_sym (exp->X_add_symbol);\t\\\n+\t  operands[1] = symbol_relc_make_value (exp->X_add_number);\t\\\n+\t  break;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          arity = 1;\t\t\t\t\t\t\t\\\n-          opstr = str_;\t\t\t\t\t\t\t\\\n-          operands[0] = symbol_relc_make_sym (exp->X_add_symbol);\t\\\n-        }\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  arity = 1;\t\t\t\t\t\t\t\\\n+\t  opstr = str_;\t\t\t\t\t\t\t\\\n+\t  operands[0] = symbol_relc_make_sym (exp->X_add_symbol);\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       break\n \n-#define HANDLE_XADD_OPT2(str_) \t\t\t\t\t\t\\\n+#define HANDLE_XADD_OPT2(str_)\t\t\t\t\t\t\\\n       if (exp->X_add_number)\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          arity = 3;\t\t\t\t\t\t\t\\\n-          opstr = \"+:\" str_;\t\t\t\t\t\t\\\n-          operands[0] = symbol_relc_make_sym (exp->X_add_symbol);\t\\\n-          operands[1] = symbol_relc_make_sym (exp->X_op_symbol);\t\\\n-          operands[2] = symbol_relc_make_value (exp->X_add_number);\t\\\n-        }\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  arity = 3;\t\t\t\t\t\t\t\\\n+\t  opstr = \"+:\" str_;\t\t\t\t\t\t\\\n+\t  operands[0] = symbol_relc_make_sym (exp->X_add_symbol);\t\\\n+\t  operands[1] = symbol_relc_make_sym (exp->X_op_symbol);\t\\\n+\t  operands[2] = symbol_relc_make_value (exp->X_add_number);\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\t\\\n-          arity = 2;\t\t\t\t\t\t\t\\\n-          opstr = str_;\t\t\t\t\t\t\t\\\n-          operands[0] = symbol_relc_make_sym (exp->X_add_symbol);\t\\\n-          operands[1] = symbol_relc_make_sym (exp->X_op_symbol);\t\\\n-        } \t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  arity = 2;\t\t\t\t\t\t\t\\\n+\t  opstr = str_;\t\t\t\t\t\t\t\\\n+\t  operands[0] = symbol_relc_make_sym (exp->X_add_symbol);\t\\\n+\t  operands[1] = symbol_relc_make_sym (exp->X_op_symbol);\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       break\n \n       /* Nesting nodes.  */\n \n-    case O_uminus:       \tHANDLE_XADD_OPT1 (\"0-\");\n-    case O_bit_not:      \tHANDLE_XADD_OPT1 (\"~\");\n-    case O_logical_not:  \tHANDLE_XADD_OPT1 (\"!\");\n-    case O_multiply:     \tHANDLE_XADD_OPT2 (\"*\");\n-    case O_divide:       \tHANDLE_XADD_OPT2 (\"/\");\n-    case O_modulus:      \tHANDLE_XADD_OPT2 (\"%\");\n-    case O_left_shift:   \tHANDLE_XADD_OPT2 (\"<<\");\n-    case O_right_shift:  \tHANDLE_XADD_OPT2 (\">>\");\n+    case O_uminus:\t\tHANDLE_XADD_OPT1 (\"0-\");\n+    case O_bit_not:\t\tHANDLE_XADD_OPT1 (\"~\");\n+    case O_logical_not:\t\tHANDLE_XADD_OPT1 (\"!\");\n+    case O_multiply:\t\tHANDLE_XADD_OPT2 (\"*\");\n+    case O_divide:\t\tHANDLE_XADD_OPT2 (\"/\");\n+    case O_modulus:\t\tHANDLE_XADD_OPT2 (\"%\");\n+    case O_left_shift:\t\tHANDLE_XADD_OPT2 (\"<<\");\n+    case O_right_shift:\t\tHANDLE_XADD_OPT2 (\">>\");\n     case O_bit_inclusive_or:\tHANDLE_XADD_OPT2 (\"|\");\n     case O_bit_exclusive_or:\tHANDLE_XADD_OPT2 (\"^\");\n-    case O_bit_and:      \tHANDLE_XADD_OPT2 (\"&\");\n-    case O_add:          \tHANDLE_XADD_OPT2 (\"+\");\n-    case O_subtract:     \tHANDLE_XADD_OPT2 (\"-\");\n-    case O_eq:           \tHANDLE_XADD_OPT2 (\"==\");\n-    case O_ne:           \tHANDLE_XADD_OPT2 (\"!=\");\n-    case O_lt:           \tHANDLE_XADD_OPT2 (\"<\");\n-    case O_le:           \tHANDLE_XADD_OPT2 (\"<=\");\n-    case O_ge:           \tHANDLE_XADD_OPT2 (\">=\");\n-    case O_gt:           \tHANDLE_XADD_OPT2 (\">\");\n-    case O_logical_and:  \tHANDLE_XADD_OPT2 (\"&&\");\n-    case O_logical_or:   \tHANDLE_XADD_OPT2 (\"||\");\n+    case O_bit_and:\t\tHANDLE_XADD_OPT2 (\"&\");\n+    case O_add:\t\t\tHANDLE_XADD_OPT2 (\"+\");\n+    case O_subtract:\t\tHANDLE_XADD_OPT2 (\"-\");\n+    case O_eq:\t\t\tHANDLE_XADD_OPT2 (\"==\");\n+    case O_ne:\t\t\tHANDLE_XADD_OPT2 (\"!=\");\n+    case O_lt:\t\t\tHANDLE_XADD_OPT2 (\"<\");\n+    case O_le:\t\t\tHANDLE_XADD_OPT2 (\"<=\");\n+    case O_ge:\t\t\tHANDLE_XADD_OPT2 (\">=\");\n+    case O_gt:\t\t\tHANDLE_XADD_OPT2 (\">\");\n+    case O_logical_and:\t\tHANDLE_XADD_OPT2 (\"&&\");\n+    case O_logical_or:\t\tHANDLE_XADD_OPT2 (\"||\");\n     }\n \n   /* Validate & reject early.  */"
    }
  ]
}