{
  "sha": "e0037b4cc727274248aebc11543f2ea3a711dacb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTAwMzdiNGNjNzI3Mjc0MjQ4YWViYzExNTQzZjJlYTNhNzExZGFjYg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-01-13T15:58:52Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-01-13T15:59:09Z"
    },
    "message": "gdb: adjust remote-sim.c to multi-target\n\nThe remote-sim.c file doesn't build since the main multi-target patch\n(5b6d1e4f, \"Multi-target support\"), this patch is an attempt to fix it.\nI have only build-tested it, so I'm not sure it runs fine, but it should\nget us close at least.\n\nI made these functions methods of the gdbsim_target, because they need\nto pass the target down to some GDB core functions, like\nfind_inferior_ptid:\n\n - get_sim_inferior_data_by_ptid (renamed to get_inferior_data_by_ptid)\n - gdbsim_resume_inferior (renamed to resume_one_inferior)\n - gdbsim_close_inferior (renamed to close_one_inferior)\n\nIn the last two, I changed iterate_over_inferiors to a range-based for,\nsince that gives simpler code (no need to pass data through the void\npointer).\n\nThe next_pid variable, INITIAL_PID macro and sim_inferior_data structure\nare simply moved up in the file, above gdbsim_target.\n\ngdb/ChangeLog:\n\n\t* remote-sim.c (next_pid, INITIAL_PID, sim_inferior_data): Move\n\tup.\n\t(gdbsim_target) <get_inferior_data_by_ptid, resume_one_inferior,\n\tclose_one_inferior>: New methods.\n\t(get_sim_inferior_data_by_ptid): Move to gdbsim_target,\n\tpass down target to find_inferior_pid.\n\t(gdbsim_target::fetch_registers, gdbsim_target::store_registers):\n\tPass down target to find_inferior_ptid.\n\t(gdbsim_target::create_inferior): Pass down target to\n\tadd_thread_silent.\n\t(gdbsim_close_inferior): Move to gdbsim_close_inferior, pass\n\ttarget down to find_inferior_ptid and switch_to_thread.\n\t(gdbsim_target::close): Update to call close_one_inferior.\n\t(struct resume_data): Remove.\n\t(gdbsim_resume_inferior): Move to gdbsim_target.  Take arguments\n\tdirectly, rather than through a void pointer.\n\t(gdbsim_target::resume): Update to call resume_one_inferior.",
    "tree": {
      "sha": "55bbe9a5c82253c3e4b0199e9c9940c318a1f8cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/55bbe9a5c82253c3e4b0199e9c9940c318a1f8cd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e0037b4cc727274248aebc11543f2ea3a711dacb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e0037b4cc727274248aebc11543f2ea3a711dacb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e0037b4cc727274248aebc11543f2ea3a711dacb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e0037b4cc727274248aebc11543f2ea3a711dacb/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "82e9597c9ec1c14a402d47f2d9b544235998be1e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/82e9597c9ec1c14a402d47f2d9b544235998be1e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/82e9597c9ec1c14a402d47f2d9b544235998be1e"
    }
  ],
  "stats": {
    "total": 169,
    "additions": 91,
    "deletions": 78
  },
  "files": [
    {
      "sha": "64b64fb242d26aa60e82ff6eec65c57092627ee9",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e0037b4cc727274248aebc11543f2ea3a711dacb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e0037b4cc727274248aebc11543f2ea3a711dacb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=e0037b4cc727274248aebc11543f2ea3a711dacb",
      "patch": "@@ -1,3 +1,23 @@\n+2020-01-13  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* remote-sim.c (next_pid, INITIAL_PID, sim_inferior_data): Move\n+\tup.\n+\t(gdbsim_target) <get_inferior_data_by_ptid, resume_one_inferior,\n+\tclose_one_inferior>: New methods.\n+\t(get_sim_inferior_data_by_ptid): Move to gdbsim_target,\n+\tpass down target to find_inferior_pid.\n+\t(gdbsim_target::fetch_registers, gdbsim_target::store_registers):\n+\tPass down target to find_inferior_ptid.\n+\t(gdbsim_target::create_inferior): Pass down target to\n+\tadd_thread_silent.\n+\t(gdbsim_close_inferior): Move to gdbsim_close_inferior, pass\n+\ttarget down to find_inferior_ptid and switch_to_thread.\n+\t(gdbsim_target::close): Update to call close_one_inferior.\n+\t(struct resume_data): Remove.\n+\t(gdbsim_resume_inferior): Move to gdbsim_target.  Take arguments\n+\tdirectly, rather than through a void pointer.\n+\t(gdbsim_target::resume): Update to call resume_one_inferior.\n+\n 2020-01-12  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* gdbsupport/gdb_wait.c: Include gdb_wait.h."
    },
    {
      "sha": "e491042ce02b2d7c3500623b8935b59629da07f7",
      "filename": "gdb/remote-sim.c",
      "status": "modified",
      "additions": 71,
      "deletions": 78,
      "changes": 149,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e0037b4cc727274248aebc11543f2ea3a711dacb/gdb/remote-sim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e0037b4cc727274248aebc11543f2ea3a711dacb/gdb/remote-sim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-sim.c?ref=e0037b4cc727274248aebc11543f2ea3a711dacb",
      "patch": "@@ -74,6 +74,43 @@ static void gdb_os_error (host_callback *, const char *, ...)\n    sim_* are the interface to the simulator (see remote-sim.h).\n    gdbsim_* are stuff which is internal to gdb.  */\n \n+/* Value of the next pid to allocate for an inferior.  As indicated\n+   elsewhere, its initial value is somewhat arbitrary; it's critical\n+   though that it's not zero or negative.  */\n+static int next_pid;\n+#define INITIAL_PID 42000\n+\n+/* Simulator-specific, per-inferior state.  */\n+struct sim_inferior_data {\n+  explicit sim_inferior_data (SIM_DESC desc)\n+    : gdbsim_desc (desc),\n+      remote_sim_ptid (next_pid, 0, next_pid)\n+  {\n+    ++next_pid;\n+  }\n+\n+  ~sim_inferior_data ();\n+\n+  /* Flag which indicates whether or not the program has been loaded.  */\n+  int program_loaded = 0;\n+\n+  /* Simulator descriptor for this inferior.  */\n+  SIM_DESC gdbsim_desc;\n+\n+  /* This is the ptid we use for this particular simulator instance.  Its\n+     value is somewhat arbitrary, as the simulator target don't have a\n+     notion of tasks or threads, but we need something non-null to place\n+     in inferior_ptid.  For simulators which permit multiple instances,\n+     we also need a unique identifier to use for each inferior.  */\n+  ptid_t remote_sim_ptid;\n+\n+  /* Signal with which to resume.  */\n+  enum gdb_signal resume_siggnal = GDB_SIGNAL_0;\n+\n+  /* Flag which indicates whether resume should step or not.  */\n+  int resume_step = 0;\n+};\n+\n static const target_info gdbsim_target_info = {\n   \"sim\",\n   N_(\"simulator\"),\n@@ -126,47 +163,16 @@ struct gdbsim_target final\n \n   bool has_all_memory ()  override;\n   bool has_memory ()  override;\n+\n+private:\n+  sim_inferior_data *get_inferior_data_by_ptid (ptid_t ptid,\n+\t\t\t\t\t\tint sim_instance_needed);\n+  void resume_one_inferior (inferior *inf, bool step, gdb_signal siggnal);\n+  void close_one_inferior (inferior *inf);\n };\n \n static struct gdbsim_target gdbsim_ops;\n \n-/* Value of the next pid to allocate for an inferior.  As indicated\n-   elsewhere, its initial value is somewhat arbitrary; it's critical\n-   though that it's not zero or negative.  */\n-static int next_pid;\n-#define INITIAL_PID 42000\n-\n-/* Simulator-specific, per-inferior state.  */\n-struct sim_inferior_data {\n-  explicit sim_inferior_data (SIM_DESC desc)\n-    : gdbsim_desc (desc),\n-      remote_sim_ptid (next_pid, 0, next_pid)\n-  {\n-    ++next_pid;\n-  }\n-\n-  ~sim_inferior_data ();\n-\n-  /* Flag which indicates whether or not the program has been loaded.  */\n-  int program_loaded = 0;\n-\n-  /* Simulator descriptor for this inferior.  */\n-  SIM_DESC gdbsim_desc;\n-\n-  /* This is the ptid we use for this particular simulator instance.  Its\n-     value is somewhat arbitrary, as the simulator target don't have a\n-     notion of tasks or threads, but we need something non-null to place\n-     in inferior_ptid.  For simulators which permit multiple instances,\n-     we also need a unique identifier to use for each inferior.  */\n-  ptid_t remote_sim_ptid;\n-\n-  /* Signal with which to resume.  */\n-  enum gdb_signal resume_siggnal = GDB_SIGNAL_0;\n-\n-  /* Flag which indicates whether resume should step or not.  */\n-  int resume_step = 0;\n-};\n-\n static inferior_key<sim_inferior_data> sim_inferior_data_key;\n \n /* Flag indicating the \"open\" status of this module.  It's set to 1\n@@ -262,16 +268,17 @@ get_sim_inferior_data (struct inferior *inf, int sim_instance_needed)\n    inferior in question.  Return NULL when no inferior is found or\n    when ptid has a zero or negative pid component.  */\n \n-static struct sim_inferior_data *\n-get_sim_inferior_data_by_ptid (ptid_t ptid, int sim_instance_needed)\n+sim_inferior_data *\n+gdbsim_target::get_inferior_data_by_ptid (ptid_t ptid,\n+\t\t\t\t\t  int sim_instance_needed)\n {\n   struct inferior *inf;\n   int pid = ptid.pid ();\n \n   if (pid <= 0)\n     return NULL;\n \n-  inf = find_inferior_pid (pid);\n+  inf = find_inferior_pid (this, pid);\n \n   if (inf)\n     return get_sim_inferior_data (inf, sim_instance_needed);\n@@ -441,7 +448,7 @@ void\n gdbsim_target::fetch_registers (struct regcache *regcache, int regno)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct inferior *inf = find_inferior_ptid (regcache->ptid ());\n+  struct inferior *inf = find_inferior_ptid (this, regcache->ptid ());\n   struct sim_inferior_data *sim_data\n     = get_sim_inferior_data (inf, SIM_INSTANCE_NEEDED);\n \n@@ -510,7 +517,7 @@ void\n gdbsim_target::store_registers (struct regcache *regcache, int regno)\n {\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct inferior *inf = find_inferior_ptid (regcache->ptid ());\n+  struct inferior *inf = find_inferior_ptid (this, regcache->ptid ());\n   struct sim_inferior_data *sim_data\n     = get_sim_inferior_data (inf, SIM_INSTANCE_NEEDED);\n \n@@ -656,7 +663,7 @@ gdbsim_target::create_inferior (const char *exec_file,\n \n   inferior_ptid = sim_data->remote_sim_ptid;\n   inferior_appeared (current_inferior (), inferior_ptid.pid ());\n-  add_thread_silent (inferior_ptid);\n+  add_thread_silent (this, inferior_ptid);\n \n   insert_breakpoints ();\t/* Needed to get correct instruction\n \t\t\t\t   in cache.  */\n@@ -767,11 +774,10 @@ gdbsim_target_open (const char *args, int from_tty)\n   gdbsim_is_open = 1;\n }\n \n-/* Callback for iterate_over_inferiors.  Called (indirectly) by\n-   gdbsim_close().  */\n+/* Helper for gdbsim_target::close.  */\n \n-static int\n-gdbsim_close_inferior (struct inferior *inf, void *arg)\n+void\n+gdbsim_target::close_one_inferior (inferior *inf)\n {\n   struct sim_inferior_data *sim_data = sim_inferior_data_key.get (inf);\n   if (sim_data != NULL)\n@@ -785,14 +791,12 @@ gdbsim_close_inferior (struct inferior *inf, void *arg)\n \t Thus we need to verify the existence of an inferior using the\n \t pid in question before setting inferior_ptid via\n \t switch_to_thread() or mourning the inferior.  */\n-      if (find_inferior_ptid (ptid) != NULL)\n+      if (find_inferior_ptid (this, ptid) != NULL)\n \t{\n-\t  switch_to_thread (ptid);\n+\t  switch_to_thread (this, ptid);\n \t  generic_mourn_inferior ();\n \t}\n     }\n-\n-  return 0;\n }\n \n /* Close out all files and local state before this target loses control.  */\n@@ -803,7 +807,8 @@ gdbsim_target::close ()\n   if (remote_debug)\n     fprintf_unfiltered (gdb_stdlog, \"gdbsim_close\\n\");\n \n-  iterate_over_inferiors (gdbsim_close_inferior, NULL);\n+  for (inferior *inf : all_inferiors (this))\n+    close_one_inferior (inf);\n \n   if (sim_argv != NULL)\n     {\n@@ -839,45 +844,30 @@ gdbsim_target::detach (inferior *inf, int from_tty)\n    or to run free; SIGGNAL is the signal value (e.g. SIGINT) to be given\n    to the target, or zero for no signal.  */\n \n-struct resume_data\n-{\n-  enum gdb_signal siggnal;\n-  int step;\n-};\n-\n-static int\n-gdbsim_resume_inferior (struct inferior *inf, void *arg)\n+void\n+gdbsim_target::resume_one_inferior (inferior *inf, bool step,\n+\t\t\t\t    gdb_signal siggnal)\n {\n   struct sim_inferior_data *sim_data\n     = get_sim_inferior_data (inf, SIM_INSTANCE_NOT_NEEDED);\n-  struct resume_data *rd = (struct resume_data *) arg;\n \n   if (sim_data)\n     {\n-      sim_data->resume_siggnal = rd->siggnal;\n-      sim_data->resume_step = rd->step;\n+      sim_data->resume_siggnal = siggnal;\n+      sim_data->resume_step = step;\n \n       if (remote_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    _(\"gdbsim_resume: pid %d, step %d, signal %d\\n\"),\n-\t\t\t    inf->pid, rd->step, rd->siggnal);\n+\t\t\t    inf->pid, step, siggnal);\n     }\n-\n-  /* When called from iterate_over_inferiors, a zero return causes the\n-     iteration process to proceed until there are no more inferiors to\n-     consider.  */\n-  return 0;\n }\n \n void\n gdbsim_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n {\n-  struct resume_data rd;\n   struct sim_inferior_data *sim_data\n-    = get_sim_inferior_data_by_ptid (ptid, SIM_INSTANCE_NOT_NEEDED);\n-\n-  rd.siggnal = siggnal;\n-  rd.step = step;\n+    = get_inferior_data_by_ptid (ptid, SIM_INSTANCE_NOT_NEEDED);\n \n   /* We don't access any sim_data members within this function.\n      What's of interest is whether or not the call to\n@@ -887,9 +877,12 @@ gdbsim_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n      either have multiple inferiors to resume or an error condition.  */\n \n   if (sim_data)\n-    gdbsim_resume_inferior (find_inferior_ptid (ptid), &rd);\n+    resume_one_inferior (find_inferior_ptid (this, ptid), step, siggnal);\n   else if (ptid == minus_one_ptid)\n-    iterate_over_inferiors (gdbsim_resume_inferior, &rd);\n+    {\n+      for (inferior *inf : all_inferiors (this))\n+\tresume_one_inferior (inf, step, siggnal);\n+    }\n   else\n     error (_(\"The program is not being run.\"));\n }\n@@ -969,7 +962,7 @@ gdbsim_target::wait (ptid_t ptid, struct target_waitstatus *status, int options)\n \t\t\t\t      SIM_INSTANCE_NEEDED);\n   else\n     {\n-      sim_data = get_sim_inferior_data_by_ptid (ptid, SIM_INSTANCE_NEEDED);\n+      sim_data = get_inferior_data_by_ptid (ptid, SIM_INSTANCE_NEEDED);\n       if (sim_data == NULL)\n \terror (_(\"Unable to wait for pid %d.  Inferior not found.\"),\n \t       ptid.pid ());\n@@ -1248,7 +1241,7 @@ bool\n gdbsim_target::thread_alive (ptid_t ptid)\n {\n   struct sim_inferior_data *sim_data\n-    = get_sim_inferior_data_by_ptid (ptid, SIM_INSTANCE_NOT_NEEDED);\n+    = get_inferior_data_by_ptid (ptid, SIM_INSTANCE_NOT_NEEDED);\n \n   if (sim_data == NULL)\n     return false;"
    }
  ]
}