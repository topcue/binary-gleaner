{
  "sha": "1f704f761b34e145f5eabdc222301ce6e9ec9102",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWY3MDRmNzYxYjM0ZTE0NWY1ZWFiZGMyMjIzMDFjZTZlOWVjOTEwMg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-22T20:55:15Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-22T20:55:15Z"
    },
    "message": "gdb: remove TYPE_NFIELDS macro\n\nRemove `TYPE_NFIELDS`, changing all the call sites to use\n`type::num_fields` directly.  This is quite a big diff, but this was\nmostly done using sed and coccinelle.  A few call sites were done by\nhand.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (TYPE_NFIELDS): Remove.  Change all cal sites to use\n\ttype::num_fields instead.\n\nChange-Id: Ib73be4c36f9e770e0f729bac3b5257d7cb2f9591",
    "tree": {
      "sha": "89c8b6dbf40b606ef045929b718d9271093057a3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/89c8b6dbf40b606ef045929b718d9271093057a3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1f704f761b34e145f5eabdc222301ce6e9ec9102",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f704f761b34e145f5eabdc222301ce6e9ec9102",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1f704f761b34e145f5eabdc222301ce6e9ec9102",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f704f761b34e145f5eabdc222301ce6e9ec9102/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5e33d5f4e1a5f2c3556ee31715ddc030d039b597",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5e33d5f4e1a5f2c3556ee31715ddc030d039b597",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5e33d5f4e1a5f2c3556ee31715ddc030d039b597"
    }
  ],
  "stats": {
    "total": 640,
    "additions": 322,
    "deletions": 318
  },
  "files": [
    {
      "sha": "44e7b1f9b50035e423f8c80ff77b6b049465aa4f",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1,3 +1,8 @@\n+2020-05-22  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (TYPE_NFIELDS): Remove.  Change all cal sites to use\n+\ttype::num_fields instead.\n+\n 2020-05-22  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (struct type) <num_fields, set_num_fields>: New"
    },
    {
      "sha": "2872d2d2bf7f23b36057229cf869bc600fe44c39",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1346,7 +1346,7 @@ aapcs_is_vfp_call_or_return_candidate_1 (struct type *type,\n       {\n \tint count = 0;\n \n-\tfor (int i = 0; i < TYPE_NFIELDS (type); i++)\n+\tfor (int i = 0; i < type->num_fields (); i++)\n \t  {\n \t    /* Ignore any static fields.  */\n \t    if (field_is_static (&TYPE_FIELD (type, i)))\n@@ -1628,7 +1628,7 @@ pass_in_v_vfp_candidate (struct gdbarch *gdbarch, struct regcache *regcache,\n \n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n-      for (int i = 0; i < TYPE_NFIELDS (arg_type); i++)\n+      for (int i = 0; i < arg_type->num_fields (); i++)\n \t{\n \t  /* Don't include static fields.  */\n \t  if (field_is_static (&TYPE_FIELD (arg_type, i)))"
    },
    {
      "sha": "2ae9830dbbb865e0cfa02dca3ccec7c3483219e4",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1394,7 +1394,7 @@ convert_char_literal (struct type *type, LONGEST val)\n   else\n     xsnprintf (name, sizeof (name), \"QU%02x\", (int) val);\n   size_t len = strlen (name);\n-  for (f = 0; f < TYPE_NFIELDS (type); f += 1)\n+  for (f = 0; f < type->num_fields (); f += 1)\n     {\n       /* Check the suffix because an enum constant in a package will\n \t have a name like \"pkg__QUxx\".  This is safe enough because we"
    },
    {
      "sha": "a4804e62ef54acd4c7ecb17e1fe28ffe0dcb9545",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 35,
      "deletions": 35,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -571,7 +571,7 @@ ada_get_field_index (const struct type *type, const char *field_name,\n   int fieldno;\n   struct type *struct_type = check_typedef ((struct type *) type);\n \n-  for (fieldno = 0; fieldno < TYPE_NFIELDS (struct_type); fieldno++)\n+  for (fieldno = 0; fieldno < struct_type->num_fields (); fieldno++)\n     if (field_name_match (TYPE_FIELD_NAME (struct_type, fieldno), field_name))\n       return fieldno;\n \n@@ -755,7 +755,7 @@ ada_discrete_type_high_bound (struct type *type)\n     case TYPE_CODE_RANGE:\n       return TYPE_HIGH_BOUND (type);\n     case TYPE_CODE_ENUM:\n-      return TYPE_FIELD_ENUMVAL (type, TYPE_NFIELDS (type) - 1);\n+      return TYPE_FIELD_ENUMVAL (type, type->num_fields () - 1);\n     case TYPE_CODE_BOOL:\n       return 1;\n     case TYPE_CODE_CHAR:\n@@ -1461,7 +1461,7 @@ ada_fixup_array_indexes_type (struct type *index_desc_type)\n \n   if (index_desc_type == NULL)\n     return;\n-  gdb_assert (TYPE_NFIELDS (index_desc_type) > 0);\n+  gdb_assert (index_desc_type->num_fields () > 0);\n \n   /* Check if INDEX_DESC_TYPE follows the older encoding (it is sufficient\n      to check one field only, no need to check them all).  If not, return\n@@ -1476,7 +1476,7 @@ ada_fixup_array_indexes_type (struct type *index_desc_type)\n     return;\n \n   /* Fixup each field of INDEX_DESC_TYPE.  */\n-  for (i = 0; i < TYPE_NFIELDS (index_desc_type); i++)\n+  for (i = 0; i < index_desc_type->num_fields (); i++)\n    {\n      const char *name = TYPE_FIELD_NAME (index_desc_type, i);\n      struct type *raw_type = ada_check_typedef (ada_find_any_type (name));\n@@ -1807,7 +1807,7 @@ desc_arity (struct type *type)\n   type = desc_base_type (type);\n \n   if (type != NULL)\n-    return TYPE_NFIELDS (type) / 2;\n+    return type->num_fields () / 2;\n   return 0;\n }\n \n@@ -3206,12 +3206,12 @@ ada_print_symbol_signature (struct ui_file *stream, struct symbol *sym,\n       || type->code () != TYPE_CODE_FUNC)\n     return;\n \n-  if (TYPE_NFIELDS (type) > 0)\n+  if (type->num_fields () > 0)\n     {\n       int i;\n \n       fprintf_filtered (stream, \" (\");\n-      for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+      for (i = 0; i < type->num_fields (); ++i)\n \t{\n \t  if (i > 0)\n \t    fprintf_filtered (stream, \"; \");\n@@ -3897,7 +3897,7 @@ ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)\n   else if (func_type == NULL || func_type->code () != TYPE_CODE_FUNC)\n     return 0;\n \n-  if (TYPE_NFIELDS (func_type) != n_actuals)\n+  if (func_type->num_fields () != n_actuals)\n     return 0;\n \n   for (i = 0; i < n_actuals; i += 1)\n@@ -4958,7 +4958,7 @@ is_nondebugging_type (struct type *type)\n \n    This function assumes that TYPE1 and TYPE2 are both TYPE_CODE_ENUM\n    types and that their number of enumerals is identical (in other\n-   words, TYPE_NFIELDS (type1) == TYPE_NFIELDS (type2)).  */\n+   words, type1->num_fields () == type2->num_fields ()).  */\n \n static int\n ada_identical_enum_types_p (struct type *type1, struct type *type2)\n@@ -4971,13 +4971,13 @@ ada_identical_enum_types_p (struct type *type1, struct type *type2)\n      underlying value and name.  */\n \n   /* All enums in the type should have an identical underlying value.  */\n-  for (i = 0; i < TYPE_NFIELDS (type1); i++)\n+  for (i = 0; i < type1->num_fields (); i++)\n     if (TYPE_FIELD_ENUMVAL (type1, i) != TYPE_FIELD_ENUMVAL (type2, i))\n       return 0;\n \n   /* All enumerals should also have the same name (modulo any numerical\n      suffix).  */\n-  for (i = 0; i < TYPE_NFIELDS (type1); i++)\n+  for (i = 0; i < type1->num_fields (); i++)\n     {\n       const char *name_1 = TYPE_FIELD_NAME (type1, i);\n       const char *name_2 = TYPE_FIELD_NAME (type2, i);\n@@ -5040,8 +5040,8 @@ symbols_are_identical_enums (const std::vector<struct block_symbol> &syms)\n \n   /* Quick check: They should all have the same number of enumerals.  */\n   for (i = 1; i < syms.size (); i++)\n-    if (TYPE_NFIELDS (SYMBOL_TYPE (syms[i].symbol))\n-        != TYPE_NFIELDS (SYMBOL_TYPE (syms[0].symbol)))\n+    if (SYMBOL_TYPE (syms[i].symbol)->num_fields ()\n+        != SYMBOL_TYPE (syms[0].symbol)->num_fields ())\n       return 0;\n \n   /* All the sanity checks passed, so we might have a set of\n@@ -6527,7 +6527,7 @@ ada_is_interface_tag (struct type *type)\n int\n ada_is_ignored_field (struct type *type, int field_num)\n {\n-  if (field_num < 0 || field_num > TYPE_NFIELDS (type))\n+  if (field_num < 0 || field_num > type->num_fields ())\n     return 1;\n \n   /* Check the name of that field.  */\n@@ -6863,7 +6863,7 @@ ada_parent_type (struct type *type)\n   if (type == NULL || type->code () != TYPE_CODE_STRUCT)\n     return NULL;\n \n-  for (i = 0; i < TYPE_NFIELDS (type); i += 1)\n+  for (i = 0; i < type->num_fields (); i += 1)\n     if (ada_is_parent_field (type, i))\n       {\n         struct type *parent_type = TYPE_FIELD_TYPE (type, i);\n@@ -7226,7 +7226,7 @@ find_struct_field (const char *name, struct type *type, int offset,\n   if (bit_size_p != NULL)\n     *bit_size_p = 0;\n \n-  for (i = 0; i < TYPE_NFIELDS (type); i += 1)\n+  for (i = 0; i < type->num_fields (); i += 1)\n     {\n       int bit_pos = TYPE_FIELD_BITPOS (type, i);\n       int fld_offset = offset + bit_pos / 8;\n@@ -7278,7 +7278,7 @@ find_struct_field (const char *name, struct type *type, int offset,\n           struct type *field_type\n \t    = ada_check_typedef (TYPE_FIELD_TYPE (type, i));\n \n-          for (j = 0; j < TYPE_NFIELDS (field_type); j += 1)\n+          for (j = 0; j < field_type->num_fields (); j += 1)\n             {\n               if (find_struct_field (name, TYPE_FIELD_TYPE (field_type, j),\n                                      fld_offset\n@@ -7338,7 +7338,7 @@ ada_search_struct_field (const char *name, struct value *arg, int offset,\n   int parent_offset = -1;\n \n   type = ada_check_typedef (type);\n-  for (i = 0; i < TYPE_NFIELDS (type); i += 1)\n+  for (i = 0; i < type->num_fields (); i += 1)\n     {\n       const char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -7381,7 +7381,7 @@ ada_search_struct_field (const char *name, struct value *arg, int offset,\n \t\t\t\t\t\t\t\t\ti));\n           int var_offset = offset + TYPE_FIELD_BITPOS (type, i) / 8;\n \n-          for (j = 0; j < TYPE_NFIELDS (field_type); j += 1)\n+          for (j = 0; j < field_type->num_fields (); j += 1)\n             {\n               struct value *v = ada_search_struct_field /* Force line\n \t\t\t\t\t\t\t   break.  */\n@@ -7439,7 +7439,7 @@ ada_index_struct_field_1 (int *index_p, struct value *arg, int offset,\n   int i;\n   type = ada_check_typedef (type);\n \n-  for (i = 0; i < TYPE_NFIELDS (type); i += 1)\n+  for (i = 0; i < type->num_fields (); i += 1)\n     {\n       if (TYPE_FIELD_NAME (type, i) == NULL)\n         continue;\n@@ -7532,7 +7532,7 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n \n   type = to_static_fixed_type (type);\n \n-  for (i = 0; i < TYPE_NFIELDS (type); i += 1)\n+  for (i = 0; i < type->num_fields (); i += 1)\n     {\n       const char *t_field_name = TYPE_FIELD_NAME (type, i);\n       struct type *t;\n@@ -7571,7 +7571,7 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n           struct type *field_type = ada_check_typedef (TYPE_FIELD_TYPE (type,\n \t\t\t\t\t\t\t\t\ti));\n \n-          for (j = TYPE_NFIELDS (field_type) - 1; j >= 0; j -= 1)\n+          for (j = field_type->num_fields () - 1; j >= 0; j -= 1)\n             {\n \t      /* FIXME pnh 2008/01/26: We check for a field that is\n \t         NOT wrapped in a struct, since the compiler sometimes\n@@ -7655,7 +7655,7 @@ ada_which_variant_applies (struct type *var_type, struct value *outer)\n   discrim_val = value_as_long (discrim);\n \n   others_clause = -1;\n-  for (i = 0; i < TYPE_NFIELDS (var_type); i += 1)\n+  for (i = 0; i < var_type->num_fields (); i += 1)\n     {\n       if (ada_is_others_clause (var_type, i))\n         others_clause = i;\n@@ -8005,7 +8005,7 @@ variant_field_index (struct type *type)\n   if (type == NULL || type->code () != TYPE_CODE_STRUCT)\n     return -1;\n \n-  for (f = 0; f < TYPE_NFIELDS (type); f += 1)\n+  for (f = 0; f < type->num_fields (); f += 1)\n     {\n       if (ada_is_variant_part (type, f))\n         return f;\n@@ -8064,11 +8064,11 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n      to be processed: unless keep_dynamic_fields, this includes only\n      fields whose position and length are static will be processed.  */\n   if (keep_dynamic_fields)\n-    nfields = TYPE_NFIELDS (type);\n+    nfields = type->num_fields ();\n   else\n     {\n       nfields = 0;\n-      while (nfields < TYPE_NFIELDS (type)\n+      while (nfields < type->num_fields ()\n              && !ada_is_variant_part (type, nfields)\n              && !is_dynamic_field (type, nfields))\n         nfields++;\n@@ -8243,7 +8243,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n          cond_offset_target (address, off / TARGET_CHAR_BIT), dval);\n       if (branch_type == NULL)\n         {\n-          for (f = variant_field + 1; f < TYPE_NFIELDS (rtype); f += 1)\n+          for (f = variant_field + 1; f < rtype->num_fields (); f += 1)\n             TYPE_FIELDS (rtype)[f - 1] = TYPE_FIELDS (rtype)[f];\n \t  rtype->set_num_fields (rtype->num_fields () - 1);\n         }\n@@ -8325,7 +8325,7 @@ template_to_static_fixed_type (struct type *type0)\n \n   /* Don't clone TYPE0 until we are sure we are going to need a copy.  */\n   type = type0;\n-  nfields = TYPE_NFIELDS (type0);\n+  nfields = type0->num_fields ();\n \n   /* Whether or not we cloned TYPE0, cache the result so that we don't do\n      recompute all over next time.  */\n@@ -8384,7 +8384,7 @@ to_record_with_fixed_variant_part (struct type *type, const gdb_byte *valaddr,\n   struct value *dval;\n   struct type *rtype;\n   struct type *branch_type;\n-  int nfields = TYPE_NFIELDS (type);\n+  int nfields = type->num_fields ();\n   int variant_field = variant_field_index (type);\n \n   if (variant_field == -1)\n@@ -8590,7 +8590,7 @@ ada_is_redundant_index_type_desc (struct type *array_type,\n   struct type *this_layer = check_typedef (array_type);\n   int i;\n \n-  for (i = 0; i < TYPE_NFIELDS (desc_type); i++)\n+  for (i = 0; i < desc_type->num_fields (); i++)\n     {\n       if (!ada_is_redundant_range_encoding (TYPE_INDEX_TYPE (this_layer),\n \t\t\t\t\t    TYPE_FIELD_TYPE (desc_type, i)))\n@@ -8694,7 +8694,7 @@ to_fixed_array_type (struct type *type0, struct value *dval,\n       struct type *elt_type0;\n \n       elt_type0 = type0;\n-      for (i = TYPE_NFIELDS (index_type_desc); i > 0; i -= 1)\n+      for (i = index_type_desc->num_fields (); i > 0; i -= 1)\n         elt_type0 = TYPE_TARGET_TYPE (elt_type0);\n \n       /* NOTE: result---the fixed version of elt_type0---should never\n@@ -8712,7 +8712,7 @@ to_fixed_array_type (struct type *type0, struct value *dval,\n         ada_to_fixed_type (ada_check_typedef (elt_type0), 0, 0, dval, 1);\n \n       elt_type0 = type0;\n-      for (i = TYPE_NFIELDS (index_type_desc) - 1; i >= 0; i -= 1)\n+      for (i = index_type_desc->num_fields () - 1; i >= 0; i -= 1)\n         {\n           struct type *range_type =\n             to_fixed_range_type (TYPE_FIELD_TYPE (index_type_desc, i), dval);\n@@ -9148,7 +9148,7 @@ value_val_atr (struct type *type, struct value *arg)\n     {\n       long pos = value_as_long (arg);\n \n-      if (pos < 0 || pos >= TYPE_NFIELDS (type))\n+      if (pos < 0 || pos >= type->num_fields ())\n         error (_(\"argument to 'VAL out of range\"));\n       return value_from_longest (type, TYPE_FIELD_ENUMVAL (type, pos));\n     }\n@@ -9229,7 +9229,7 @@ ada_is_aligner_type (struct type *type)\n     return 0;\n \n   return (type->code () == TYPE_CODE_STRUCT\n-          && TYPE_NFIELDS (type) == 1\n+          && type->num_fields () == 1\n           && strcmp (TYPE_FIELD_NAME (type, 0), \"F\") == 0);\n }\n \n@@ -9263,7 +9263,7 @@ ada_get_base_type (struct type *raw_type)\n   real_type_namer = ada_find_parallel_type (raw_type, \"___XVS\");\n   if (real_type_namer == NULL\n       || real_type_namer->code () != TYPE_CODE_STRUCT\n-      || TYPE_NFIELDS (real_type_namer) != 1)\n+      || real_type_namer->num_fields () != 1)\n     return raw_type;\n \n   if (TYPE_FIELD_TYPE (real_type_namer, 0)->code () != TYPE_CODE_REF)"
    },
    {
      "sha": "2021edf011182e2b587126ac305105d81d66ed86",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -312,7 +312,7 @@ print_range_type (struct type *raw_type, struct ui_file *stream,\n static void\n print_enum_type (struct type *type, struct ui_file *stream)\n {\n-  int len = TYPE_NFIELDS (type);\n+  int len = type->num_fields ();\n   int i;\n   LONGEST lastval;\n \n@@ -417,7 +417,7 @@ print_array_type (struct type *type, struct ui_file *stream, int show,\n \t{\n \t  int k;\n \n-\t  n_indices = TYPE_NFIELDS (range_desc_type);\n+\t  n_indices = range_desc_type->num_fields ();\n \t  for (k = 0, arr_type = type;\n \t       k < n_indices;\n \t       k += 1, arr_type = TYPE_TARGET_TYPE (arr_type))\n@@ -563,7 +563,7 @@ print_variant_clauses (struct type *type, int field_num,\n   if (par_type != NULL)\n     var_type = par_type;\n \n-  for (i = 0; i < TYPE_NFIELDS (var_type); i += 1)\n+  for (i = 0; i < var_type->num_fields (); i += 1)\n     {\n       fprintf_filtered (stream, \"\\n%*swhen \", level + 4, \"\");\n       if (print_choices (var_type, i, stream, discr_type))\n@@ -786,13 +786,13 @@ print_record_field_types (struct type *type, struct type *outer_type,\n \t}\n       gdb_assert (prop->kind == PROP_VARIANT_PARTS);\n       print_record_field_types_dynamic (*prop->data.variant_parts,\n-\t\t\t\t\t0, TYPE_NFIELDS (type),\n+\t\t\t\t\t0, type->num_fields (),\n \t\t\t\t\ttype, stream, show, level, flags);\n-      return TYPE_NFIELDS (type);\n+      return type->num_fields ();\n     }\n \n   return print_selected_record_field_types (type, outer_type,\n-\t\t\t\t\t    0, TYPE_NFIELDS (type) - 1,\n+\t\t\t\t\t    0, type->num_fields () - 1,\n \t\t\t\t\t    stream, show, level, flags);\n }\n    \n@@ -863,15 +863,15 @@ print_unchecked_union_type (struct type *type, struct ui_file *stream,\n {\n   if (show < 0)\n     fprintf_filtered (stream, \"record (?) is ... end record\");\n-  else if (TYPE_NFIELDS (type) == 0)\n+  else if (type->num_fields () == 0)\n     fprintf_filtered (stream, \"record (?) is null; end record\");\n   else\n     {\n       int i;\n \n       fprintf_filtered (stream, \"record (?) is\\n%*scase ? is\", level + 4, \"\");\n \n-      for (i = 0; i < TYPE_NFIELDS (type); i += 1)\n+      for (i = 0; i < type->num_fields (); i += 1)\n \t{\n \t  fprintf_filtered (stream, \"\\n%*swhen ? =>\\n%*s\", level + 8, \"\",\n \t\t\t    level + 12, \"\");\n@@ -895,7 +895,7 @@ static void\n print_func_type (struct type *type, struct ui_file *stream, const char *name,\n \t\t const struct type_print_options *flags)\n {\n-  int i, len = TYPE_NFIELDS (type);\n+  int i, len = type->num_fields ();\n \n   if (TYPE_TARGET_TYPE (type) != NULL\n       && TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_VOID)"
    },
    {
      "sha": "f0e7bfc296bdbeec19303b77c0a7d5618e465ff8",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -400,7 +400,7 @@ ada_print_scalar (struct type *type, LONGEST val, struct ui_file *stream)\n     {\n \n     case TYPE_CODE_ENUM:\n-      len = TYPE_NFIELDS (type);\n+      len = type->num_fields ();\n       for (i = 0; i < len; i++)\n \t{\n \t  if (TYPE_FIELD_ENUMVAL (type, i) == val)\n@@ -600,7 +600,7 @@ print_field_values (struct value *value, struct value *outer_value,\n   int i, len;\n \n   struct type *type = value_type (value);\n-  len = TYPE_NFIELDS (type);\n+  len = type->num_fields ();\n \n   for (i = 0; i < len; i += 1)\n     {\n@@ -886,7 +886,7 @@ ada_val_print_enum (struct value *value, struct ui_file *stream, int recurse,\n   const gdb_byte *valaddr = value_contents_for_printing (value);\n   int offset_aligned = ada_aligned_value_addr (type, valaddr) - valaddr;\n \n-  len = TYPE_NFIELDS (type);\n+  len = type->num_fields ();\n   val = unpack_long (type, valaddr + offset_aligned);\n   for (i = 0; i < len; i++)\n     {"
    },
    {
      "sha": "485eae29b92573ce0d6bfc5adcf58be6bb793b76",
      "filename": "gdb/ada-varobj.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ada-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-varobj.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -273,7 +273,7 @@ ada_varobj_get_struct_number_of_children (struct value *parent_value,\n   gdb_assert (parent_type->code () == TYPE_CODE_STRUCT\n \t      || parent_type->code () == TYPE_CODE_UNION);\n \n-  for (i = 0; i < TYPE_NFIELDS (parent_type); i++)\n+  for (i = 0; i < parent_type->num_fields (); i++)\n     {\n       if (ada_is_ignored_field (parent_type, i))\n \tcontinue;\n@@ -421,7 +421,7 @@ ada_varobj_describe_struct_child (struct value *parent_value,\n   gdb_assert (parent_type->code () == TYPE_CODE_STRUCT\n \t      || parent_type->code () == TYPE_CODE_UNION);\n \n-  for (fieldno = 0; fieldno < TYPE_NFIELDS (parent_type); fieldno++)\n+  for (fieldno = 0; fieldno < parent_type->num_fields (); fieldno++)\n     {\n       if (ada_is_ignored_field (parent_type, fieldno))\n \tcontinue;"
    },
    {
      "sha": "24f0614b235b55110d1616179d22f0779cb877e4",
      "filename": "gdb/amd64-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/amd64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/amd64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -549,7 +549,7 @@ amd64_has_unaligned_fields (struct type *type)\n   if (type->code () == TYPE_CODE_STRUCT\n       || type->code () == TYPE_CODE_UNION)\n     {\n-      for (int i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (int i = 0; i < type->num_fields (); i++)\n \t{\n \t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n \t  int bitpos = TYPE_FIELD_BITPOS (type, i);\n@@ -608,7 +608,7 @@ amd64_classify_aggregate_field (struct type *type, int i,\n     {\n       /* Each field of an object is classified recursively.  */\n       int j;\n-      for (j = 0; j < TYPE_NFIELDS (subtype); j++)\n+      for (j = 0; j < subtype->num_fields (); j++)\n \tamd64_classify_aggregate_field (subtype, j, theclass, bitpos);\n       return;\n     }\n@@ -684,7 +684,7 @@ amd64_classify_aggregate (struct type *type, enum amd64_reg_class theclass[2])\n       gdb_assert (type->code () == TYPE_CODE_STRUCT\n \t\t  || type->code () == TYPE_CODE_UNION);\n \n-      for (i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (i = 0; i < type->num_fields (); i++)\n \tamd64_classify_aggregate_field (type, i, theclass, 0);\n     }\n "
    },
    {
      "sha": "e96819252118ea6288ace37a2dd25223ec82a952",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -3497,7 +3497,7 @@ arm_vfp_cprc_sub_candidate (struct type *t,\n \tint count = 0;\n \tunsigned unitlen;\n \tint i;\n-\tfor (i = 0; i < TYPE_NFIELDS (t); i++)\n+\tfor (i = 0; i < t->num_fields (); i++)\n \t  {\n \t    int sub_count = 0;\n \n@@ -3526,7 +3526,7 @@ arm_vfp_cprc_sub_candidate (struct type *t,\n \tint count = 0;\n \tunsigned unitlen;\n \tint i;\n-\tfor (i = 0; i < TYPE_NFIELDS (t); i++)\n+\tfor (i = 0; i < t->num_fields (); i++)\n \t  {\n \t    int sub_count = arm_vfp_cprc_sub_candidate (TYPE_FIELD_TYPE (t, i),\n \t\t\t\t\t\t\tbase_type);\n@@ -7970,7 +7970,7 @@ arm_return_in_memory (struct gdbarch *gdbarch, struct type *type)\n \t     --> yes, nRc = 1\n \t  */\n \n-\t  for (i = 0; i < TYPE_NFIELDS (type); i++)\n+\t  for (i = 0; i < type->num_fields (); i++)\n \t    {\n \t      enum type_code field_type_code;\n "
    },
    {
      "sha": "4dcdc3b411f1470ff0d5772f6a8abf9fd9896a5b",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -316,7 +316,7 @@ gen_trace_static_fields (struct agent_expr *ax,\n \n   type = check_typedef (type);\n \n-  for (i = TYPE_NFIELDS (type) - 1; i >= nbases; i--)\n+  for (i = type->num_fields () - 1; i >= nbases; i--)\n     {\n       if (field_is_static (&TYPE_FIELD (type, i)))\n \t{\n@@ -1444,7 +1444,7 @@ gen_struct_ref_recursive (struct agent_expr *ax, struct axs_value *value,\n \n   type = check_typedef (type);\n \n-  for (i = TYPE_NFIELDS (type) - 1; i >= nbases; i--)\n+  for (i = type->num_fields () - 1; i >= nbases; i--)\n     {\n       const char *this_name = TYPE_FIELD_NAME (type, i);\n \n@@ -1588,7 +1588,7 @@ gen_struct_elt_for_reference (struct agent_expr *ax, struct axs_value *value,\n     internal_error (__FILE__, __LINE__,\n \t\t    _(\"non-aggregate type to gen_struct_elt_for_reference\"));\n \n-  for (i = TYPE_NFIELDS (t) - 1; i >= TYPE_N_BASECLASSES (t); i--)\n+  for (i = t->num_fields () - 1; i >= TYPE_N_BASECLASSES (t); i--)\n     {\n       const char *t_field_name = TYPE_FIELD_NAME (t, i);\n "
    },
    {
      "sha": "b25d09b5c0c91ca5c53fc526ec452f5105a0b21f",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -254,7 +254,7 @@ buildsym_compunit::finish_block_internal\n       SYMBOL_BLOCK_VALUE (symbol) = block;\n       BLOCK_FUNCTION (block) = symbol;\n \n-      if (TYPE_NFIELDS (ftype) <= 0)\n+      if (ftype->num_fields () <= 0)\n \t{\n \t  /* No parameter type information is recorded with the\n \t     function's type.  Set that from the type of the"
    },
    {
      "sha": "e549c5cb6571737af424f19a20077d2eb3a95a1b",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -254,7 +254,7 @@ c_get_string (struct value *value, gdb::unique_xmalloc_ptr<gdb_byte> *buffer,\n     {\n       /* If we know the size of the array, we can use it as a limit on\n \t the number of characters to be fetched.  */\n-      if (TYPE_NFIELDS (type) == 1\n+      if (type->num_fields () == 1\n \t  && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_RANGE)\n \t{\n \t  LONGEST low_bound, high_bound;"
    },
    {
      "sha": "955cfd6045124bccb703ddbfe936f2b9e4a97646",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -278,7 +278,7 @@ cp_type_print_method_args (struct type *mtype, const char *prefix,\n \t\t\t   const struct type_print_options *flags)\n {\n   struct field *args = TYPE_FIELDS (mtype);\n-  int nargs = TYPE_NFIELDS (mtype);\n+  int nargs = mtype->num_fields ();\n   int varargs = TYPE_VARARGS (mtype);\n   int i;\n \n@@ -560,7 +560,7 @@ c_type_print_args (struct type *type, struct ui_file *stream,\n \n   fprintf_filtered (stream, \"(\");\n \n-  for (i = 0; i < TYPE_NFIELDS (type); i++)\n+  for (i = 0; i < type->num_fields (); i++)\n     {\n       struct type *param_type;\n \n@@ -965,7 +965,7 @@ need_access_label_p (struct type *type)\n   if (TYPE_DECLARED_CLASS (type))\n     {\n       QUIT;\n-      for (int i = TYPE_N_BASECLASSES (type); i < TYPE_NFIELDS (type); i++)\n+      for (int i = TYPE_N_BASECLASSES (type); i < type->num_fields (); i++)\n \tif (!TYPE_FIELD_PRIVATE (type, i))\n \t  return true;\n       QUIT;\n@@ -982,7 +982,7 @@ need_access_label_p (struct type *type)\n   else\n     {\n       QUIT;\n-      for (int i = TYPE_N_BASECLASSES (type); i < TYPE_NFIELDS (type); i++)\n+      for (int i = TYPE_N_BASECLASSES (type); i < type->num_fields (); i++)\n \tif (TYPE_FIELD_PRIVATE (type, i) || TYPE_FIELD_PROTECTED (type, i))\n \t  return true;\n       QUIT;\n@@ -1115,7 +1115,7 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \n       fprintf_filtered (stream, \"{\\n\");\n \n-      if (TYPE_NFIELDS (type) == 0 && TYPE_NFN_FIELDS (type) == 0\n+      if (type->num_fields () == 0 && TYPE_NFN_FIELDS (type) == 0\n \t  && TYPE_TYPEDEF_FIELD_COUNT (type) == 0)\n \t{\n \t  if (TYPE_STUB (type))\n@@ -1143,7 +1143,7 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n       /* If there is a base class for this type,\n \t do not print the field that it occupies.  */\n \n-      int len = TYPE_NFIELDS (type);\n+      int len = type->num_fields ();\n       vptr_fieldno = get_vptr_fieldno (type, &basetype);\n \n       struct print_offset_data local_podata;\n@@ -1374,7 +1374,7 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \t  if (semi_local_flags.print_nested_type_limit > 0)\n \t    --semi_local_flags.print_nested_type_limit;\n \n-\t  if (TYPE_NFIELDS (type) != 0 || TYPE_NFN_FIELDS (type) != 0)\n+\t  if (type->num_fields () != 0 || TYPE_NFN_FIELDS (type) != 0)\n \t    fprintf_filtered (stream, \"\\n\");\n \n \t  for (int i = 0; i < TYPE_NESTED_TYPES_COUNT (type); ++i)\n@@ -1392,7 +1392,7 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \n       if (TYPE_TYPEDEF_FIELD_COUNT (type) != 0 && flags->print_typedefs)\n \t{\n-\t  if (TYPE_NFIELDS (type) != 0 || TYPE_NFN_FIELDS (type) != 0\n+\t  if (type->num_fields () != 0 || TYPE_NFN_FIELDS (type) != 0\n \t      || TYPE_NESTED_TYPES_COUNT (type) != 0)\n \t    fprintf_filtered (stream, \"\\n\");\n \n@@ -1593,7 +1593,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t    }\n \n \t  fprintf_filtered (stream, \"{\");\n-\t  len = TYPE_NFIELDS (type);\n+\t  len = type->num_fields ();\n \t  for (i = 0; i < len; i++)\n \t    {\n \t      QUIT;\n@@ -1627,7 +1627,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t  {\n \t    fputs_filtered (\" \", stream);\n \t    fprintf_filtered (stream, \"{\\n\");\n-\t    if (TYPE_NFIELDS (type) == 0)\n+\t    if (type->num_fields () == 0)\n \t      {\n \t\tif (TYPE_STUB (type))\n \t\t  fprintfi_filtered (level + 4, stream,\n@@ -1638,7 +1638,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t\t\t\t     _(\"%p[<no data fields>%p]\\n\"),\n \t\t\t\t     metadata_style.style ().ptr (), nullptr);\n \t      }\n-\t    len = TYPE_NFIELDS (type);\n+\t    len = type->num_fields ();\n \t    for (i = 0; i < len; i++)\n \t      {\n \t\tQUIT;"
    },
    {
      "sha": "6cb260ddc91a86388569645899d5edffc7e8c548",
      "filename": "gdb/c-varobj.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/c-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/c-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-varobj.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -164,7 +164,7 @@ c_is_path_expr_parent (const struct varobj *var)\n \t    {\n \t      const char *field_name;\n \n-\t      gdb_assert (var->index < TYPE_NFIELDS (parent_type));\n+\t      gdb_assert (var->index < parent_type->num_fields ());\n \t      field_name = TYPE_FIELD_NAME (parent_type, var->index);\n \t      return !(field_name == NULL || *field_name == '\\0');\n \t    }\n@@ -202,7 +202,7 @@ c_number_of_children (const struct varobj *var)\n \n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n-      children = TYPE_NFIELDS (type);\n+      children = type->num_fields ();\n       break;\n \n     case TYPE_CODE_PTR:\n@@ -649,7 +649,7 @@ cplus_class_num_children (struct type *type, int children[3])\n   children[v_protected] = 0;\n \n   vptr_fieldno = get_vptr_fieldno (type, &basetype);\n-  for (i = TYPE_N_BASECLASSES (type); i < TYPE_NFIELDS (type); i++)\n+  for (i = TYPE_N_BASECLASSES (type); i < type->num_fields (); i++)\n     {\n       /* If we have a virtual table pointer, omit it.  Even if virtual\n \t table pointers are not specifically marked in the debug info,"
    },
    {
      "sha": "6bf3abd646f5c3b5621a6533fc553b529a5ae0ff",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1452,10 +1452,10 @@ patch_type (struct type *type, struct type *real_type)\n {\n   struct type *target = TYPE_TARGET_TYPE (type);\n   struct type *real_target = TYPE_TARGET_TYPE (real_type);\n-  int field_size = TYPE_NFIELDS (real_target) * sizeof (struct field);\n+  int field_size = real_target->num_fields () * sizeof (struct field);\n \n   TYPE_LENGTH (target) = TYPE_LENGTH (real_target);\n-  target->set_num_fields (TYPE_NFIELDS (real_target));\n+  target->set_num_fields (real_target->num_fields ());\n   TYPE_FIELDS (target) = (struct field *) TYPE_ALLOC (target,\n \t\t\t\t\t\t      field_size);\n "
    },
    {
      "sha": "8b3cd370aa49ba286d1dbe13efa70a23c3f9cad7",
      "filename": "gdb/compile/compile-c-symbols.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-c-symbols.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-c-symbols.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-symbols.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -526,7 +526,7 @@ generate_vla_size (compile_instance *compiler,\n       {\n \tint i;\n \n-\tfor (i = 0; i < TYPE_NFIELDS (type); ++i)\n+\tfor (i = 0; i < type->num_fields (); ++i)\n \t  if (!field_is_static (&TYPE_FIELD (type, i)))\n \t    generate_vla_size (compiler, stream, gdbarch, registers_used, pc,\n \t\t\t       TYPE_FIELD_TYPE (type, i), sym);"
    },
    {
      "sha": "c4f5811678eb5dddf0b4b49a6907cf05d830f976",
      "filename": "gdb/compile/compile-c-types.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-c-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-c-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-types.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -103,7 +103,7 @@ convert_struct_or_union (compile_c_instance *context, struct type *type)\n     }\n   context->insert_type (type, result);\n \n-  for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (i = 0; i < type->num_fields (); ++i)\n     {\n       gcc_type field_type;\n       unsigned long bitsize = TYPE_FIELD_BITSIZE (type, i);\n@@ -134,7 +134,7 @@ convert_enum (compile_c_instance *context, struct type *type)\n \t\t\t\t\t     TYPE_LENGTH (type));\n \n   result = context->plugin ().build_enum_type (int_type);\n-  for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (i = 0; i < type->num_fields (); ++i)\n     {\n       context->plugin ().build_add_enum_constant\n \t(result, TYPE_FIELD_NAME (type, i), TYPE_FIELD_ENUMVAL (type, i));\n@@ -175,9 +175,9 @@ convert_func (compile_c_instance *context, struct type *type)\n      types.  Those are impossible in C, though.  */\n   return_type = context->convert_type (target_type);\n \n-  array.n_elements = TYPE_NFIELDS (type);\n-  array.elements = XNEWVEC (gcc_type, TYPE_NFIELDS (type));\n-  for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+  array.n_elements = type->num_fields ();\n+  array.elements = XNEWVEC (gcc_type, type->num_fields ());\n+  for (i = 0; i < type->num_fields (); ++i)\n     array.elements[i] = context->convert_type (TYPE_FIELD_TYPE (type, i));\n \n   result = context->plugin ().build_function_type (return_type,"
    },
    {
      "sha": "b2a4544c041e4c848acc5a7a843138963b3fce72",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -580,7 +580,7 @@ static void\n compile_cplus_convert_struct_or_union_members\n   (compile_cplus_instance *instance, struct type *type, gcc_type comp_type)\n {\n-  for (int i = TYPE_N_BASECLASSES (type); i < TYPE_NFIELDS (type); ++i)\n+  for (int i = TYPE_N_BASECLASSES (type); i < type->num_fields (); ++i)\n     {\n       const char *field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -938,7 +938,7 @@ compile_cplus_convert_enum (compile_cplus_instance *instance, struct type *type,\n \t\t\t\t\t      ? GCC_CP_FLAG_ENUM_SCOPED\n \t\t\t\t\t      : GCC_CP_FLAG_ENUM_NOFLAG),\n \t\t\t\t\t   nullptr, 0);\n-  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (int i = 0; i < type->num_fields (); ++i)\n     {\n       gdb::unique_xmalloc_ptr<char> fname\n \t= compile_cplus_instance::decl_name (TYPE_FIELD_NAME (type, i));\n@@ -986,9 +986,9 @@ compile_cplus_convert_func (compile_cplus_instance *instance,\n   gcc_type return_type = instance->convert_type (target_type);\n \n   struct gcc_type_array array =\n-    { TYPE_NFIELDS (type), XNEWVEC (gcc_type, TYPE_NFIELDS (type)) };\n+    { type->num_fields (), XNEWVEC (gcc_type, type->num_fields ()) };\n   int artificials = 0;\n-  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (int i = 0; i < type->num_fields (); ++i)\n     {\n       if (strip_artificial && TYPE_FIELD_ARTIFICIAL (type, i))\n \t{"
    },
    {
      "sha": "7f5f5931f210381c26cbcf9860789d90736689c5",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -505,7 +505,7 @@ get_regs_type (struct symbol *func_sym, struct objfile *objfile)\n   struct type *regsp_type, *regs_type;\n \n   /* No register parameter present.  */\n-  if (TYPE_NFIELDS (func_type) == 0)\n+  if (func_type->num_fields () == 0)\n     return NULL;\n \n   regsp_type = check_typedef (TYPE_FIELD_TYPE (func_type, 0));\n@@ -534,7 +534,7 @@ store_regs (struct type *regs_type, CORE_ADDR regs_base)\n   struct gdbarch *gdbarch = target_gdbarch ();\n   int fieldno;\n \n-  for (fieldno = 0; fieldno < TYPE_NFIELDS (regs_type); fieldno++)\n+  for (fieldno = 0; fieldno < regs_type->num_fields (); fieldno++)\n     {\n       const char *reg_name = TYPE_FIELD_NAME (regs_type, fieldno);\n       ULONGEST reg_bitpos = TYPE_FIELD_BITPOS (regs_type, fieldno);\n@@ -670,10 +670,10 @@ compile_object_load (const compile_file_names &file_names,\n     default:\n       internal_error (__FILE__, __LINE__, _(\"invalid scope %d\"), scope);\n     }\n-  if (TYPE_NFIELDS (func_type) != expect_parameters)\n+  if (func_type->num_fields () != expect_parameters)\n     error (_(\"Invalid %d parameters of function \\\"%s\\\" in compiled \"\n \t     \"module \\\"%s\\\".\"),\n-\t   TYPE_NFIELDS (func_type), GCC_FE_WRAPPER_FUNCTION,\n+\t   func_type->num_fields (), GCC_FE_WRAPPER_FUNCTION,\n \t   objfile_name (objfile));\n   if (!types_deeply_equal (expect_return_type, TYPE_TARGET_TYPE (func_type)))\n     error (_(\"Invalid return type of function \\\"%s\\\" in compiled \""
    },
    {
      "sha": "d8e285325663767576ab737739380fff44a33d46",
      "filename": "gdb/compile/compile-object-run.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-object-run.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/compile/compile-object-run.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-run.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -153,23 +153,23 @@ compile_object_run (struct compile_module *module)\n       func_val = value_from_pointer (lookup_pointer_type (func_type),\n \t\t\t\t   BLOCK_ENTRY_PC (SYMBOL_BLOCK_VALUE (func_sym)));\n \n-      vargs = XALLOCAVEC (struct value *, TYPE_NFIELDS (func_type));\n-      if (TYPE_NFIELDS (func_type) >= 1)\n+      vargs = XALLOCAVEC (struct value *, func_type->num_fields ());\n+      if (func_type->num_fields () >= 1)\n \t{\n \t  gdb_assert (regs_addr != 0);\n \t  vargs[current_arg] = value_from_pointer\n \t\t\t  (TYPE_FIELD_TYPE (func_type, current_arg), regs_addr);\n \t  ++current_arg;\n \t}\n-      if (TYPE_NFIELDS (func_type) >= 2)\n+      if (func_type->num_fields () >= 2)\n \t{\n \t  gdb_assert (data->out_value_addr != 0);\n \t  vargs[current_arg] = value_from_pointer\n \t       (TYPE_FIELD_TYPE (func_type, current_arg), data->out_value_addr);\n \t  ++current_arg;\n \t}\n-      gdb_assert (current_arg == TYPE_NFIELDS (func_type));\n-      auto args = gdb::make_array_view (vargs, TYPE_NFIELDS (func_type));\n+      gdb_assert (current_arg == func_type->num_fields ());\n+      auto args = gdb::make_array_view (vargs, func_type->num_fields ());\n       call_function_by_hand_dummy (func_val, NULL, args,\n \t\t\t\t   do_module_cleanup, data);\n     }"
    },
    {
      "sha": "ad33b98c696812ca553053006603e601bf5d977b",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1090,7 +1090,7 @@ add_struct_fields (struct type *type, completion_list &output,\n   const char *type_name = NULL;\n \n   type = check_typedef (type);\n-  for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (i = 0; i < type->num_fields (); ++i)\n     {\n       if (i < TYPE_N_BASECLASSES (type))\n \tadd_struct_fields (TYPE_BASECLASS (type, i),"
    },
    {
      "sha": "a59afec4958d5fc113906c0b16e644d25c421763",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -149,7 +149,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n     }\n \n   fprintf_filtered (stream, \"{\");\n-  len = TYPE_NFIELDS (type);\n+  len = type->num_fields ();\n   n_baseclasses = TYPE_N_BASECLASSES (type);\n \n   /* First, print out baseclasses such that we don't print\n@@ -638,7 +638,7 @@ cp_find_class_member (struct type **self_p, int *fieldno,\n \n   *self_p = check_typedef (*self_p);\n   self = *self_p;\n-  len = TYPE_NFIELDS (self);\n+  len = self->num_fields ();\n \n   for (i = TYPE_N_BASECLASSES (self); i < len; i++)\n     {"
    },
    {
      "sha": "34f8b05a62b438d108b4f3b8d8b35d1fe3cd6d84",
      "filename": "gdb/d-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/d-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/d-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-valprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -34,7 +34,7 @@ dynamic_array_type (struct type *type,\n \t\t    struct value *val,\n \t\t    const struct value_print_options *options)\n {\n-  if (TYPE_NFIELDS (type) == 2\n+  if (type->num_fields () == 2\n       && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_INT\n       && strcmp (TYPE_FIELD_NAME (type, 0), \"length\") == 0\n       && strcmp (TYPE_FIELD_NAME (type, 1), \"ptr\") == 0"
    },
    {
      "sha": "0581b8e20855fad7103ddfd0637f085896eca819",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -9249,17 +9249,17 @@ alloc_rust_variant (struct obstack *obstack, struct type *type,\n   /* When DISCRIMINANT_INDEX == -1, we have a univariant enum.  Those\n      must be handled by the caller.  */\n   gdb_assert (discriminant_index >= 0\n-\t      && discriminant_index < TYPE_NFIELDS (type));\n+\t      && discriminant_index < type->num_fields ());\n   gdb_assert (default_index == -1\n-\t      || (default_index >= 0 && default_index < TYPE_NFIELDS (type)));\n+\t      || (default_index >= 0 && default_index < type->num_fields ()));\n \n   /* We have one variant for each non-discriminant field.  */\n-  int n_variants = TYPE_NFIELDS (type) - 1;\n+  int n_variants = type->num_fields () - 1;\n \n   variant *variants = new (obstack) variant[n_variants];\n   int var_idx = 0;\n   int range_idx = 0;\n-  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (int i = 0; i < type->num_fields (); ++i)\n     {\n       if (i == discriminant_index)\n \tcontinue;\n@@ -9324,11 +9324,11 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n   gdb_assert (type->code () == TYPE_CODE_UNION);\n \n   /* We don't need to deal with empty enums.  */\n-  if (TYPE_NFIELDS (type) == 0)\n+  if (type->num_fields () == 0)\n     return;\n \n #define RUST_ENUM_PREFIX \"RUST$ENCODED$ENUM$\"\n-  if (TYPE_NFIELDS (type) == 1\n+  if (type->num_fields () == 1\n       && startswith (TYPE_FIELD_NAME (type, 0), RUST_ENUM_PREFIX))\n     {\n       const char *name = TYPE_FIELD_NAME (type, 0) + strlen (RUST_ENUM_PREFIX);\n@@ -9343,7 +9343,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t  unsigned long index = strtoul (name, &tail, 10);\n \t  name = tail;\n \t  if (*name != '$'\n-\t      || index >= TYPE_NFIELDS (field_type)\n+\t      || index >= field_type->num_fields ()\n \t      || (TYPE_FIELD_LOC_KIND (field_type, index)\n \t\t  != FIELD_LOC_KIND_BITPOS))\n \t    {\n@@ -9400,7 +9400,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n     }\n   /* A union with a single anonymous field is probably an old-style\n      univariant enum.  */\n-  else if (TYPE_NFIELDS (type) == 1 && streq (TYPE_FIELD_NAME (type, 0), \"\"))\n+  else if (type->num_fields () == 1 && streq (TYPE_FIELD_NAME (type, 0), \"\"))\n     {\n       /* Smash this type to be a structure type.  We have to do this\n \t because the type has already been recorded.  */\n@@ -9417,7 +9417,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n   else\n     {\n       struct type *disr_type = nullptr;\n-      for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+      for (int i = 0; i < type->num_fields (); ++i)\n \t{\n \t  disr_type = TYPE_FIELD_TYPE (type, i);\n \n@@ -9426,7 +9426,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t      /* All fields of a true enum will be structs.  */\n \t      return;\n \t    }\n-\t  else if (TYPE_NFIELDS (disr_type) == 0)\n+\t  else if (disr_type->num_fields () == 0)\n \t    {\n \t      /* Could be data-less variant, so keep going.  */\n \t      disr_type = nullptr;\n@@ -9456,12 +9456,12 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n       /* Make space for the discriminant field.  */\n       struct field *disr_field = &TYPE_FIELD (disr_type, 0);\n       field *new_fields\n-\t= (struct field *) TYPE_ZALLOC (type, ((TYPE_NFIELDS (type) + 1)\n+\t= (struct field *) TYPE_ZALLOC (type, ((type->num_fields () + 1)\n \t\t\t\t\t       * sizeof (struct field)));\n       memcpy (new_fields + 1, TYPE_FIELDS (type),\n-\t      TYPE_NFIELDS (type) * sizeof (struct field));\n+\t      type->num_fields () * sizeof (struct field));\n       TYPE_FIELDS (type) = new_fields;\n-      type->set_num_fields (TYPE_NFIELDS (type) + 1);\n+      type->set_num_fields (type->num_fields () + 1);\n \n       /* Install the discriminant at index 0 in the union.  */\n       TYPE_FIELD (type, 0) = *disr_field;\n@@ -9472,7 +9472,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t variant name.  For convenience we build a map here.  */\n       struct type *enum_type = FIELD_TYPE (*disr_field);\n       std::unordered_map<std::string, ULONGEST> discriminant_map;\n-      for (int i = 0; i < TYPE_NFIELDS (enum_type); ++i)\n+      for (int i = 0; i < enum_type->num_fields (); ++i)\n \t{\n \t  if (TYPE_FIELD_LOC_KIND (enum_type, i) == FIELD_LOC_KIND_ENUMVAL)\n \t    {\n@@ -9482,7 +9482,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t    }\n \t}\n \n-      int n_fields = TYPE_NFIELDS (type);\n+      int n_fields = type->num_fields ();\n       /* We don't need a range entry for the discriminant, but we do\n \t need one for every other field, as there is no default\n \t variant.  */\n@@ -9507,7 +9507,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \n \t  /* Remove the discriminant field, if it exists.  */\n \t  struct type *sub_type = TYPE_FIELD_TYPE (type, i);\n-\t  if (TYPE_NFIELDS (sub_type) > 0)\n+\t  if (sub_type->num_fields () > 0)\n \t    {\n \t      sub_type->set_num_fields (sub_type->num_fields () - 1);\n \t      ++TYPE_FIELDS (sub_type);\n@@ -10333,7 +10333,7 @@ dwarf2_compute_name (const char *name,\n \t\t     marks unnamed (and thus unused) parameters as\n \t\t     artificial; there is no way to differentiate\n \t\t     the two cases.  */\n-\t\t  if (TYPE_NFIELDS (type) > 0\n+\t\t  if (type->num_fields () > 0\n \t\t      && TYPE_FIELD_ARTIFICIAL (type, 0)\n \t\t      && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_PTR\n \t\t      && TYPE_CONST (TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (type,\n@@ -14996,14 +14996,14 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n   this_type = read_type_die (die, cu);\n   if (this_type && this_type->code () == TYPE_CODE_FUNC)\n     {\n-      int nparams = TYPE_NFIELDS (this_type);\n+      int nparams = this_type->num_fields ();\n \n       /* TYPE is the domain of this method, and THIS_TYPE is the type\n \t   of the method itself (TYPE_CODE_METHOD).  */\n       smash_to_method_type (fnp->type, type,\n \t\t\t    TYPE_TARGET_TYPE (this_type),\n \t\t\t    TYPE_FIELDS (this_type),\n-\t\t\t    TYPE_NFIELDS (this_type),\n+\t\t\t    this_type->num_fields (),\n \t\t\t    TYPE_VARARGS (this_type));\n \n       /* Handle static member functions.\n@@ -15095,7 +15095,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n \t      /* If there is no `this' field and no DW_AT_containing_type,\n \t\t we cannot actually find a base class context for the\n \t\t vtable!  */\n-\t      if (TYPE_NFIELDS (this_type) == 0\n+\t      if (this_type->num_fields () == 0\n \t\t  || !TYPE_FIELD_ARTIFICIAL (this_type, 0))\n \t\t{\n \t\t  complaint (_(\"cannot determine context for virtual member \"\n@@ -15192,7 +15192,7 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n   struct type *pfn_type, *self_type, *new_type;\n \n   /* Check for a structure with no name and two children.  */\n-  if (type->code () != TYPE_CODE_STRUCT || TYPE_NFIELDS (type) != 2)\n+  if (type->code () != TYPE_CODE_STRUCT || type->num_fields () != 2)\n     return;\n \n   /* Check for __pfn and __delta members.  */\n@@ -15211,15 +15211,15 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n \n   /* Look for the \"this\" argument.  */\n   pfn_type = TYPE_TARGET_TYPE (pfn_type);\n-  if (TYPE_NFIELDS (pfn_type) == 0\n+  if (pfn_type->num_fields () == 0\n       /* || TYPE_FIELD_TYPE (pfn_type, 0) == NULL */\n       || TYPE_FIELD_TYPE (pfn_type, 0)->code () != TYPE_CODE_PTR)\n     return;\n \n   self_type = TYPE_TARGET_TYPE (TYPE_FIELD_TYPE (pfn_type, 0));\n   new_type = alloc_type (objfile);\n   smash_to_method_type (new_type, self_type, TYPE_TARGET_TYPE (pfn_type),\n-\t\t\tTYPE_FIELDS (pfn_type), TYPE_NFIELDS (pfn_type),\n+\t\t\tTYPE_FIELDS (pfn_type), pfn_type->num_fields (),\n \t\t\tTYPE_VARARGS (pfn_type));\n   smash_to_methodptr_type (type, new_type);\n }\n@@ -15722,7 +15722,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t  int i;\n \n \t\t  /* Our own class provides vtbl ptr.  */\n-\t\t  for (i = TYPE_NFIELDS (t) - 1;\n+\t\t  for (i = t->num_fields () - 1;\n \t\t       i >= TYPE_N_BASECLASSES (t);\n \t\t       --i)\n \t\t    {\n@@ -15755,7 +15755,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \n \t      int i;\n \n-\t      for (i = TYPE_NFIELDS (type) - 1;\n+\t      for (i = type->num_fields () - 1;\n \t\t   i >= TYPE_N_BASECLASSES (type);\n \t\t   --i)\n \t\t{\n@@ -16722,7 +16722,7 @@ read_tag_ptr_to_member_type (struct die_info *die, struct dwarf2_cu *cu)\n \t= alloc_type (cu->per_cu->dwarf2_per_objfile->objfile);\n \n       smash_to_method_type (new_type, domain, TYPE_TARGET_TYPE (to_type),\n-\t\t\t    TYPE_FIELDS (to_type), TYPE_NFIELDS (to_type),\n+\t\t\t    TYPE_FIELDS (to_type), to_type->num_fields (),\n \t\t\t    TYPE_VARARGS (to_type));\n       type = lookup_methodptr_type (new_type);\n     }"
    },
    {
      "sha": "8104c956b4234fca33d2fb3a5f5b4812db79215d",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -295,11 +295,11 @@ evaluate_struct_tuple (struct value *struct_val,\n \n       fieldno++;\n       /* Skip static fields.  */\n-      while (fieldno < TYPE_NFIELDS (struct_type)\n+      while (fieldno < struct_type->num_fields ()\n \t     && field_is_static (&TYPE_FIELD (struct_type,\n \t\t\t\t\t      fieldno)))\n \tfieldno++;\n-      if (fieldno >= TYPE_NFIELDS (struct_type))\n+      if (fieldno >= struct_type->num_fields ())\n \terror (_(\"too many initializers\"));\n       field_type = TYPE_FIELD_TYPE (struct_type, fieldno);\n       if (field_type->code () == TYPE_CODE_UNION\n@@ -1058,7 +1058,7 @@ evaluate_funcall (type *expect_type, expression *exp, int *pos,\n \t    type = TYPE_TARGET_TYPE (type);\n \t  if (type && type->code () == TYPE_CODE_FUNC)\n \t    {\n-\t      for (; tem <= nargs && tem <= TYPE_NFIELDS (type); tem++)\n+\t      for (; tem <= nargs && tem <= type->num_fields (); tem++)\n \t\t{\n \t\t  argvec[tem] = evaluate_subexp (TYPE_FIELD_TYPE (type,\n \t\t\t\t\t\t\t\t  tem - 1),"
    },
    {
      "sha": "7057a06ef40417fbe5db940855c1f14f09e36e30",
      "filename": "gdb/f-typeprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/f-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/f-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-typeprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -254,7 +254,7 @@ f_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n \n     case TYPE_CODE_FUNC:\n       {\n-\tint i, nfields = TYPE_NFIELDS (type);\n+\tint i, nfields = type->num_fields ();\n \n \tf_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0,\n \t\t\t\t     passed_a_ptr, 0,\n@@ -430,7 +430,7 @@ f_type_print_base (struct type *type, struct ui_file *stream, int show,\n       if (show > 0)\n \t{\n \t  fputs_filtered (\"\\n\", stream);\n-\t  for (index = 0; index < TYPE_NFIELDS (type); index++)\n+\t  for (index = 0; index < type->num_fields (); index++)\n \t    {\n \t      f_type_print_base (TYPE_FIELD_TYPE (type, index), stream,\n \t\t\t\t show - 1, level + 4);"
    },
    {
      "sha": "bd16a4348d34269819f8d7f3bcf1afcdfda322e0",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -313,7 +313,7 @@ f_value_print_innner (struct value *val, struct ui_file *stream, int recurse,\n       /* Starting from the Fortran 90 standard, Fortran supports derived\n          types.  */\n       fprintf_filtered (stream, \"( \");\n-      for (index = 0; index < TYPE_NFIELDS (type); index++)\n+      for (index = 0; index < type->num_fields (); index++)\n         {\n \t  struct value *field = value_field (val, index);\n "
    },
    {
      "sha": "01d8530d0f5c5d15ff395cf0eef7e76e2a7f8dc4",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 41,
      "deletions": 41,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1040,14 +1040,14 @@ get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n       *highp = TYPE_HIGH_BOUND (type);\n       return 1;\n     case TYPE_CODE_ENUM:\n-      if (TYPE_NFIELDS (type) > 0)\n+      if (type->num_fields () > 0)\n \t{\n \t  /* The enums may not be sorted by value, so search all\n \t     entries.  */\n \t  int i;\n \n \t  *lowp = *highp = TYPE_FIELD_ENUMVAL (type, 0);\n-\t  for (i = 0; i < TYPE_NFIELDS (type); i++)\n+\t  for (i = 0; i < type->num_fields (); i++)\n \t    {\n \t      if (TYPE_FIELD_ENUMVAL (type, i) < *lowp)\n \t\t*lowp = TYPE_FIELD_ENUMVAL (type, i);\n@@ -1159,7 +1159,7 @@ discrete_position (struct type *type, LONGEST val, LONGEST *pos)\n     {\n       int i;\n \n-      for (i = 0; i < TYPE_NFIELDS (type); i += 1)\n+      for (i = 0; i < type->num_fields (); i += 1)\n         {\n           if (val == TYPE_FIELD_ENUMVAL (type, i))\n \t    {\n@@ -1751,7 +1751,7 @@ lookup_struct_elt (struct type *type, const char *name, int noerr)\n \t     type_name.c_str ());\n     }\n \n-  for (i = TYPE_NFIELDS (type) - 1; i >= TYPE_N_BASECLASSES (type); i--)\n+  for (i = type->num_fields () - 1; i >= TYPE_N_BASECLASSES (type); i--)\n     {\n       const char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -2015,7 +2015,7 @@ is_dynamic_type_internal (struct type *type, int top_level)\n \t treated as one here.  */\n     case TYPE_CODE_ARRAY:\n       {\n-\tgdb_assert (TYPE_NFIELDS (type) == 1);\n+\tgdb_assert (type->num_fields () == 1);\n \n \t/* The array is dynamic if either the bounds are dynamic...  */\n \tif (is_dynamic_type_internal (TYPE_INDEX_TYPE (type), 0))\n@@ -2036,7 +2036,7 @@ is_dynamic_type_internal (struct type *type, int top_level)\n \n \tbool is_cplus = HAVE_CPLUS_STRUCT (type);\n \n-\tfor (i = 0; i < TYPE_NFIELDS (type); ++i)\n+\tfor (i = 0; i < type->num_fields (); ++i)\n \t  {\n \t    /* Static fields can be ignored here.  */\n \t    if (field_is_static (&TYPE_FIELD (type, i)))\n@@ -2240,12 +2240,12 @@ resolve_dynamic_union (struct type *type,\n   resolved_type = copy_type (type);\n   TYPE_FIELDS (resolved_type)\n     = (struct field *) TYPE_ALLOC (resolved_type,\n-\t\t\t\t   TYPE_NFIELDS (resolved_type)\n+\t\t\t\t   resolved_type->num_fields ()\n \t\t\t\t   * sizeof (struct field));\n   memcpy (TYPE_FIELDS (resolved_type),\n \t  TYPE_FIELDS (type),\n-\t  TYPE_NFIELDS (resolved_type) * sizeof (struct field));\n-  for (i = 0; i < TYPE_NFIELDS (resolved_type); ++i)\n+\t  resolved_type->num_fields () * sizeof (struct field));\n+  for (i = 0; i < resolved_type->num_fields (); ++i)\n     {\n       struct type *t;\n \n@@ -2396,7 +2396,7 @@ compute_variant_fields (struct type *type,\n \t\t\tconst gdb::array_view<variant_part> &parts)\n {\n   /* Assume all fields are included by default.  */\n-  std::vector<bool> flags (TYPE_NFIELDS (resolved_type), true);\n+  std::vector<bool> flags (resolved_type->num_fields (), true);\n \n   /* Now disable fields based on the variants that control them.  */\n   for (const auto &part : parts)\n@@ -2406,10 +2406,10 @@ compute_variant_fields (struct type *type,\n     (std::count (flags.begin (), flags.end (), true));\n   TYPE_FIELDS (resolved_type)\n     = (struct field *) TYPE_ALLOC (resolved_type,\n-\t\t\t\t   TYPE_NFIELDS (resolved_type)\n+\t\t\t\t   resolved_type->num_fields ()\n \t\t\t\t   * sizeof (struct field));\n   int out = 0;\n-  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (int i = 0; i < type->num_fields (); ++i)\n     {\n       if (!flags[i])\n \tcontinue;\n@@ -2432,7 +2432,7 @@ resolve_dynamic_struct (struct type *type,\n   unsigned resolved_type_bit_length = 0;\n \n   gdb_assert (type->code () == TYPE_CODE_STRUCT);\n-  gdb_assert (TYPE_NFIELDS (type) > 0);\n+  gdb_assert (type->num_fields () > 0);\n \n   resolved_type = copy_type (type);\n \n@@ -2450,14 +2450,14 @@ resolve_dynamic_struct (struct type *type,\n     {\n       TYPE_FIELDS (resolved_type)\n \t= (struct field *) TYPE_ALLOC (resolved_type,\n-\t\t\t\t       TYPE_NFIELDS (resolved_type)\n+\t\t\t\t       resolved_type->num_fields ()\n \t\t\t\t       * sizeof (struct field));\n       memcpy (TYPE_FIELDS (resolved_type),\n \t      TYPE_FIELDS (type),\n-\t      TYPE_NFIELDS (resolved_type) * sizeof (struct field));\n+\t      resolved_type->num_fields () * sizeof (struct field));\n     }\n \n-  for (i = 0; i < TYPE_NFIELDS (resolved_type); ++i)\n+  for (i = 0; i < resolved_type->num_fields (); ++i)\n     {\n       unsigned new_bit_length;\n       struct property_addr_info pinfo;\n@@ -3388,7 +3388,7 @@ type_align (struct type *type)\n     case TYPE_CODE_UNION:\n       {\n \tint number_of_non_static_fields = 0;\n-\tfor (unsigned i = 0; i < TYPE_NFIELDS (type); ++i)\n+\tfor (unsigned i = 0; i < type->num_fields (); ++i)\n \t  {\n \t    if (!field_is_static (&TYPE_FIELD (type, i)))\n \t      {\n@@ -3530,7 +3530,7 @@ is_scalar_type_recursive (struct type *t)\n     return 1;\n   /* Are we dealing with an array or string of known dimensions?  */\n   else if ((t->code () == TYPE_CODE_ARRAY\n-\t    || t->code () == TYPE_CODE_STRING) && TYPE_NFIELDS (t) == 1\n+\t    || t->code () == TYPE_CODE_STRING) && t->num_fields () == 1\n \t   && TYPE_INDEX_TYPE(t)->code () == TYPE_CODE_RANGE)\n     {\n       LONGEST low_bound, high_bound;\n@@ -3541,11 +3541,11 @@ is_scalar_type_recursive (struct type *t)\n       return high_bound == low_bound && is_scalar_type_recursive (elt_type);\n     }\n   /* Are we dealing with a struct with one element?  */\n-  else if (t->code () == TYPE_CODE_STRUCT && TYPE_NFIELDS (t) == 1)\n+  else if (t->code () == TYPE_CODE_STRUCT && t->num_fields () == 1)\n     return is_scalar_type_recursive (TYPE_FIELD_TYPE (t, 0));\n   else if (t->code () == TYPE_CODE_UNION)\n     {\n-      int i, n = TYPE_NFIELDS (t);\n+      int i, n = t->num_fields ();\n \n       /* If all elements of the union are scalar, then the union is scalar.  */\n       for (i = 0; i < n; i++)\n@@ -3943,13 +3943,13 @@ types_equal (struct type *a, struct type *b)\n     {\n       int i;\n \n-      if (TYPE_NFIELDS (a) != TYPE_NFIELDS (b))\n+      if (a->num_fields () != b->num_fields ())\n \treturn false;\n       \n       if (!types_equal (TYPE_TARGET_TYPE (a), TYPE_TARGET_TYPE (b)))\n \treturn false;\n \n-      for (i = 0; i < TYPE_NFIELDS (a); ++i)\n+      for (i = 0; i < a->num_fields (); ++i)\n \tif (!types_equal (TYPE_FIELD_TYPE (a, i), TYPE_FIELD_TYPE (b, i)))\n \t  return false;\n \n@@ -4008,7 +4008,7 @@ check_types_equal (struct type *type1, struct type *type2,\n       || TYPE_VECTOR (type1) != TYPE_VECTOR (type2)\n       || TYPE_NOTTEXT (type1) != TYPE_NOTTEXT (type2)\n       || TYPE_INSTANCE_FLAGS (type1) != TYPE_INSTANCE_FLAGS (type2)\n-      || TYPE_NFIELDS (type1) != TYPE_NFIELDS (type2))\n+      || type1->num_fields () != type2->num_fields ())\n     return false;\n \n   if (!compare_maybe_null_strings (type1->name (), type2->name ()))\n@@ -4025,7 +4025,7 @@ check_types_equal (struct type *type1, struct type *type2,\n     {\n       int i;\n \n-      for (i = 0; i < TYPE_NFIELDS (type1); ++i)\n+      for (i = 0; i < type1->num_fields (); ++i)\n \t{\n \t  const struct field *field1 = &TYPE_FIELD (type1, i);\n \t  const struct field *field2 = &TYPE_FIELD (type2, i);\n@@ -4762,7 +4762,7 @@ dump_fn_fieldlists (struct type *type, int spaces)\n \t\t\t\t  gdb_stdout);\n \t  printf_filtered (\"\\n\");\n \t  print_args (TYPE_FN_FIELD_ARGS (f, overload_idx),\n-\t\t      TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (f, overload_idx)),\n+\t\t      TYPE_FN_FIELD_TYPE (f, overload_idx)->num_fields (),\n \t\t      spaces + 8 + 2);\n \t  printfi_filtered (spaces + 8, \"fcontext \");\n \t  gdb_print_host_address (TYPE_FN_FIELD_FCONTEXT (f, overload_idx),\n@@ -4815,30 +4815,30 @@ print_cplus_stuff (struct type *type, int spaces)\n \t\t\tTYPE_N_BASECLASSES (type));\n       puts_filtered (\"\\n\");\n     }\n-  if (TYPE_NFIELDS (type) > 0)\n+  if (type->num_fields () > 0)\n     {\n       if (TYPE_FIELD_PRIVATE_BITS (type) != NULL)\n \t{\n \t  printfi_filtered (spaces, \n \t\t\t    \"private_field_bits (%d bits at *\",\n-\t\t\t    TYPE_NFIELDS (type));\n+\t\t\t    type->num_fields ());\n \t  gdb_print_host_address (TYPE_FIELD_PRIVATE_BITS (type), \n \t\t\t\t  gdb_stdout);\n \t  printf_filtered (\")\");\n \t  print_bit_vector (TYPE_FIELD_PRIVATE_BITS (type),\n-\t\t\t    TYPE_NFIELDS (type));\n+\t\t\t    type->num_fields ());\n \t  puts_filtered (\"\\n\");\n \t}\n       if (TYPE_FIELD_PROTECTED_BITS (type) != NULL)\n \t{\n \t  printfi_filtered (spaces, \n \t\t\t    \"protected_field_bits (%d bits at *\",\n-\t\t\t    TYPE_NFIELDS (type));\n+\t\t\t    type->num_fields ());\n \t  gdb_print_host_address (TYPE_FIELD_PROTECTED_BITS (type), \n \t\t\t\t  gdb_stdout);\n \t  printf_filtered (\")\");\n \t  print_bit_vector (TYPE_FIELD_PROTECTED_BITS (type),\n-\t\t\t    TYPE_NFIELDS (type));\n+\t\t\t    type->num_fields ());\n \t  puts_filtered (\"\\n\");\n \t}\n     }\n@@ -4878,7 +4878,7 @@ recursive_dump_type (struct type *type, int spaces)\n   if (spaces == 0)\n     obstack_begin (&dont_print_type_obstack, 0);\n \n-  if (TYPE_NFIELDS (type) > 0\n+  if (type->num_fields () > 0\n       || (HAVE_CPLUS_STRUCT (type) && TYPE_NFN_FIELDS (type) > 0))\n     {\n       struct type **first_dont_print\n@@ -5101,10 +5101,10 @@ recursive_dump_type (struct type *type, int spaces)\n       puts_filtered (\" TYPE_NOTTEXT\");\n     }\n   puts_filtered (\"\\n\");\n-  printfi_filtered (spaces, \"nfields %d \", TYPE_NFIELDS (type));\n+  printfi_filtered (spaces, \"nfields %d \", type->num_fields ());\n   gdb_print_host_address (TYPE_FIELDS (type), gdb_stdout);\n   puts_filtered (\"\\n\");\n-  for (idx = 0; idx < TYPE_NFIELDS (type); idx++)\n+  for (idx = 0; idx < type->num_fields (); idx++)\n     {\n       if (type->code () == TYPE_CODE_ENUM)\n \tprintfi_filtered (spaces + 2,\n@@ -5296,11 +5296,11 @@ copy_type_recursive (struct objfile *objfile,\n   TYPE_LENGTH (new_type) = TYPE_LENGTH (type);\n \n   /* Copy the fields.  */\n-  if (TYPE_NFIELDS (type))\n+  if (type->num_fields ())\n     {\n       int i, nfields;\n \n-      nfields = TYPE_NFIELDS (type);\n+      nfields = type->num_fields ();\n       TYPE_FIELDS (new_type) = (struct field *)\n         TYPE_ZALLOC (new_type, nfields * sizeof (struct field));\n       for (i = 0; i < nfields; i++)\n@@ -5575,10 +5575,10 @@ append_flags_type_field (struct type *type, int start_bitpos, int nr_bits,\n \t\t\t struct type *field_type, const char *name)\n {\n   int type_bitsize = TYPE_LENGTH (type) * TARGET_CHAR_BIT;\n-  int field_nr = TYPE_NFIELDS (type);\n+  int field_nr = type->num_fields ();\n \n   gdb_assert (type->code () == TYPE_CODE_FLAGS);\n-  gdb_assert (TYPE_NFIELDS (type) + 1 <= type_bitsize);\n+  gdb_assert (type->num_fields () + 1 <= type_bitsize);\n   gdb_assert (start_bitpos >= 0 && start_bitpos < type_bitsize);\n   gdb_assert (nr_bits >= 1 && nr_bits <= type_bitsize);\n   gdb_assert (name != NULL);\n@@ -5630,10 +5630,10 @@ append_composite_type_field_raw (struct type *t, const char *name,\n {\n   struct field *f;\n \n-  t->set_num_fields (TYPE_NFIELDS (t) + 1);\n+  t->set_num_fields (t->num_fields () + 1);\n   TYPE_FIELDS (t) = XRESIZEVEC (struct field, TYPE_FIELDS (t),\n-\t\t\t\tTYPE_NFIELDS (t));\n-  f = &(TYPE_FIELDS (t)[TYPE_NFIELDS (t) - 1]);\n+\t\t\t\tt->num_fields ());\n+  f = &(TYPE_FIELDS (t)[t->num_fields () - 1]);\n   memset (f, 0, sizeof f[0]);\n   FIELD_TYPE (f[0]) = field;\n   FIELD_NAME (f[0]) = name;\n@@ -5657,7 +5657,7 @@ append_composite_type_field_aligned (struct type *t, const char *name,\n   else if (t->code () == TYPE_CODE_STRUCT)\n     {\n       TYPE_LENGTH (t) = TYPE_LENGTH (t) + TYPE_LENGTH (field);\n-      if (TYPE_NFIELDS (t) > 1)\n+      if (t->num_fields () > 1)\n \t{\n \t  SET_FIELD_BITPOS (f[0],\n \t\t\t    (FIELD_BITPOS (f[-1])"
    },
    {
      "sha": "e5f46dca0d296fac2f6df5b2dc01f3ff3b2d73c1",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1458,7 +1458,6 @@ extern unsigned type_align (struct type *);\n    space in struct type.  */\n extern bool set_type_align (struct type *, ULONGEST);\n \n-#define TYPE_NFIELDS(thistype) ((thistype)->num_fields ())\n #define TYPE_FIELDS(thistype) TYPE_MAIN_TYPE(thistype)->flds_bnds.fields\n \n #define TYPE_INDEX_TYPE(type) TYPE_FIELD_TYPE (type, 0)\n@@ -1705,7 +1704,7 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n #define TYPE_IS_OPAQUE(thistype) \\\n   ((((thistype)->code () == TYPE_CODE_STRUCT) \\\n     || ((thistype)->code () == TYPE_CODE_UNION)) \\\n-   && (TYPE_NFIELDS (thistype) == 0) \\\n+   && ((thistype)->num_fields () == 0) \\\n    && (!HAVE_CPLUS_STRUCT (thistype) \\\n        || TYPE_NFN_FIELDS (thistype) == 0) \\\n    && (TYPE_STUB (thistype) || !TYPE_STUB_SUPPORTED (thistype)))"
    },
    {
      "sha": "9238f10986d9eb9f69a86bdc99250a60a60ece5f",
      "filename": "gdb/gnu-v2-abi.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/gnu-v2-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/gnu-v2-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v2-abi.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -348,7 +348,7 @@ gnuv2_baseclass_offset (struct type *type, int index,\n   if (BASETYPE_VIA_VIRTUAL (type, index))\n     {\n       /* Must hunt for the pointer to this virtual baseclass.  */\n-      int i, len = TYPE_NFIELDS (type);\n+      int i, len = type->num_fields ();\n       int n_baseclasses = TYPE_N_BASECLASSES (type);\n \n       /* First look for the virtual baseclass pointer"
    },
    {
      "sha": "c1967e62bb793b28b120496c5ca131677d2d8b20",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1326,7 +1326,7 @@ is_copy_or_move_constructor_type (struct type *class_type,\n \t\t\t\t  type_code expected)\n {\n   /* The method should take at least two arguments...  */\n-  if (TYPE_NFIELDS (method_type) < 2)\n+  if (method_type->num_fields () < 2)\n     return false;\n \n   /* ...and the second argument should be the same as the class\n@@ -1343,7 +1343,7 @@ is_copy_or_move_constructor_type (struct type *class_type,\n   /* ...and if any of the remaining arguments don't have a default value\n      then this is not a copy or move constructor, but just a\n      constructor.  */\n-  for (int i = 2; i < TYPE_NFIELDS (method_type); i++)\n+  for (int i = 2; i < method_type->num_fields (); i++)\n     {\n       arg_type = TYPE_FIELD_TYPE (method_type, i);\n       /* FIXME aktemur/2019-10-31: As of this date, neither\n@@ -1527,7 +1527,7 @@ gnuv3_pass_by_reference (struct type *type)\n      are constructed whenever this class is.  We do not need to worry\n      about recursive loops here, since we are only looking at members\n      of complete class type.  Also ignore any static members.  */\n-  for (fieldnum = 0; fieldnum < TYPE_NFIELDS (type); fieldnum++)\n+  for (fieldnum = 0; fieldnum < type->num_fields (); fieldnum++)\n     if (!field_is_static (&TYPE_FIELD (type, fieldnum)))\n       {\n \tstruct type *field_type = TYPE_FIELD_TYPE (type, fieldnum);"
    },
    {
      "sha": "c97db1b9db7fcb565e97bcb67825f5c218314820",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -73,7 +73,7 @@ gccgo_string_p (struct type *type)\n {\n   /* gccgo strings don't necessarily have a name we can use.  */\n \n-  if (TYPE_NFIELDS (type) == 2)\n+  if (type->num_fields () == 2)\n     {\n       struct type *type0 = TYPE_FIELD_TYPE (type, 0);\n       struct type *type1 = TYPE_FIELD_TYPE (type, 1);\n@@ -106,7 +106,7 @@ gccgo_string_p (struct type *type)\n static int\n sixg_string_p (struct type *type)\n {\n-  if (TYPE_NFIELDS (type) == 2\n+  if (type->num_fields () == 2\n       && type->name () != NULL\n       && strcmp (type->name (), \"string\") == 0)\n     return 1;"
    },
    {
      "sha": "b216087e7789b2d0c4778e08c096fdf0bfebb85e",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -560,7 +560,7 @@ gdbscm_type_fields (SCM self)\n     containing_type_scm = tyscm_scm_from_type (containing_type);\n \n   result = SCM_EOL;\n-  for (i = 0; i < TYPE_NFIELDS (containing_type); ++i)\n+  for (i = 0; i < containing_type->num_fields (); ++i)\n     result = scm_cons (tyscm_make_field_smob (containing_type_scm, i), result);\n \n   return scm_reverse_x (result, SCM_EOL);\n@@ -969,7 +969,7 @@ gdbscm_type_num_fields (SCM self)\n     gdbscm_out_of_range_error (FUNC_NAME, SCM_ARG1, self,\n \t\t\t       _(not_composite_error));\n \n-  return scm_from_long (TYPE_NFIELDS (type));\n+  return scm_from_long (type->num_fields ());\n }\n \n /* (type-field <gdb:type> string) -> <gdb:field>\n@@ -997,7 +997,7 @@ gdbscm_type_field (SCM self, SCM field_scm)\n   {\n     gdb::unique_xmalloc_ptr<char> field = gdbscm_scm_to_c_string (field_scm);\n \n-    for (int i = 0; i < TYPE_NFIELDS (type); i++)\n+    for (int i = 0; i < type->num_fields (); i++)\n       {\n \tconst char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -1039,7 +1039,7 @@ gdbscm_type_has_field_p (SCM self, SCM field_scm)\n     gdb::unique_xmalloc_ptr<char> field\n       = gdbscm_scm_to_c_string (field_scm);\n \n-    for (int i = 0; i < TYPE_NFIELDS (type); i++)\n+    for (int i = 0; i < type->num_fields (); i++)\n       {\n \tconst char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -1105,11 +1105,11 @@ gdbscm_type_next_field_x (SCM self)\n   type = t_smob->type;\n \n   SCM_ASSERT_TYPE (scm_is_signed_integer (progress,\n-\t\t\t\t\t  0, TYPE_NFIELDS (type)),\n+\t\t\t\t\t  0, type->num_fields ()),\n \t\t   progress, SCM_ARG1, FUNC_NAME, _(\"integer\"));\n   field = scm_to_int (progress);\n \n-  if (field < TYPE_NFIELDS (type))\n+  if (field < type->num_fields ())\n     {\n       result = tyscm_make_field_smob (object, field);\n       itscm_set_iterator_smob_progress_x (i_smob, scm_from_int (field + 1));"
    },
    {
      "sha": "8f9fc2dcb2e718fb10fccc280ebefafc2145c8bb",
      "filename": "gdb/i386-darwin-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/i386-darwin-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/i386-darwin-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-darwin-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -136,7 +136,7 @@ i386_darwin_arg_type_alignment (struct type *type)\n     {\n       int i;\n       int res = 4;\n-      for (i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (i = 0; i < type->num_fields (); i++)\n \t{\n \t  int align\n \t    = i386_darwin_arg_type_alignment (TYPE_FIELD_TYPE (type, i));"
    },
    {
      "sha": "e87d7f363564a42466a6cb747b70b50e9e52d6c3",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -2643,7 +2643,7 @@ i386_16_byte_align_p (struct type *type)\n       || type->code () == TYPE_CODE_UNION)\n     {\n       int i;\n-      for (i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (i = 0; i < type->num_fields (); i++)\n \t{\n \t  if (i386_16_byte_align_p (TYPE_FIELD_TYPE (type, i)))\n \t    return 1;\n@@ -2952,7 +2952,7 @@ i386_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n \n   /* Structures consisting of a single `float', `double' or 'long\n      double' member are returned in %st(0).  */\n-  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)\n+  if (code == TYPE_CODE_STRUCT && type->num_fields () == 1)\n     {\n       type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n       if (type->code () == TYPE_CODE_FLT)\n@@ -3020,7 +3020,7 @@ i386_return_value (struct gdbarch *gdbarch, struct value *function,\n      the structure.  Since that should work for all structures that\n      have only one member, we don't bother to check the member's type\n      here.  */\n-  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)\n+  if (code == TYPE_CODE_STRUCT && type->num_fields () == 1)\n     {\n       type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n       return i386_return_value (gdbarch, function, type, regcache,"
    },
    {
      "sha": "b2db9bc8310822322e00a8fe02e173beaf4dec54",
      "filename": "gdb/i386-windows-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/i386-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/i386-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-windows-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -219,7 +219,7 @@ i386_windows_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   /* read_subroutine_type sets for non-static member functions the\n      artificial flag of the first parameter ('this' pointer).  */\n   if (type->code () == TYPE_CODE_METHOD\n-      && TYPE_NFIELDS (type) > 0\n+      && type->num_fields () > 0\n       && TYPE_FIELD_ARTIFICIAL (type, 0)\n       && TYPE_FIELD_TYPE (type, 0)->code () == TYPE_CODE_PTR)\n     thiscall = 1;"
    },
    {
      "sha": "1d1fd2e5f0ee479edfccd2da05442e06d43a03a5",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -3340,7 +3340,7 @@ is_float_or_hfa_type_recurse (struct type *t, struct type **etp)\n       {\n \tint i;\n \n-\tfor (i = 0; i < TYPE_NFIELDS (t); i++)\n+\tfor (i = 0; i < t->num_fields (); i++)\n \t  if (!is_float_or_hfa_type_recurse\n \t      (check_typedef (TYPE_FIELD_TYPE (t, i)), etp))\n \t    return 0;\n@@ -3389,7 +3389,7 @@ slot_alignment_is_next_even (struct type *t)\n       {\n \tint i;\n \n-\tfor (i = 0; i < TYPE_NFIELDS (t); i++)\n+\tfor (i = 0; i < t->num_fields (); i++)\n \t  if (slot_alignment_is_next_even\n \t      (check_typedef (TYPE_FIELD_TYPE (t, i))))\n \t    return 1;"
    },
    {
      "sha": "d211ad88df81ad9e6cd4d3eb4596e84bc8f62a45",
      "filename": "gdb/infcall.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/infcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/infcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcall.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -827,7 +827,7 @@ call_function_by_hand_dummy (struct value *function,\n \n   values_type = check_typedef (values_type);\n \n-  if (args.size () < TYPE_NFIELDS (ftype))\n+  if (args.size () < ftype->num_fields ())\n     error (_(\"Too few arguments in function call.\"));\n \n   /* A holder for the inferior status.\n@@ -1027,7 +1027,7 @@ call_function_by_hand_dummy (struct value *function,\n \t prototyped.  Can we respect TYPE_VARARGS?  Probably not.  */\n       if (ftype->code () == TYPE_CODE_METHOD)\n \tprototyped = 1;\n-      if (TYPE_TARGET_TYPE (ftype) == NULL && TYPE_NFIELDS (ftype) == 0\n+      if (TYPE_TARGET_TYPE (ftype) == NULL && ftype->num_fields () == 0\n \t  && default_return_type != NULL)\n \t{\n \t  /* Calling a no-debug function with the return type\n@@ -1042,12 +1042,12 @@ call_function_by_hand_dummy (struct value *function,\n \t  */\n \t  prototyped = 1;\n \t}\n-      else if (i < TYPE_NFIELDS (ftype))\n+      else if (i < ftype->num_fields ())\n \tprototyped = TYPE_PROTOTYPED (ftype);\n       else\n \tprototyped = 0;\n \n-      if (i < TYPE_NFIELDS (ftype))\n+      if (i < ftype->num_fields ())\n \tparam_type = TYPE_FIELD_TYPE (ftype, i);\n       else\n \tparam_type = NULL;"
    },
    {
      "sha": "18d207535b41387a59521c23c77950c6e5b08c7b",
      "filename": "gdb/iq2000-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/iq2000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/iq2000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/iq2000-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -604,7 +604,7 @@ iq2000_pass_8bytetype_by_address (struct type *type)\n       && type->code () != TYPE_CODE_UNION)\n     return 0;\n   /* Structs with more than 1 field are always passed by address.  */\n-  if (TYPE_NFIELDS (type) != 1)\n+  if (type->num_fields () != 1)\n     return 1;\n   /* Get field type.  */\n   ftype = (TYPE_FIELDS (type))[0].type;"
    },
    {
      "sha": "d2596b256d239390d14c1b9c3de50eede1b93a60",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -284,7 +284,7 @@ m2_procedure (struct type *type, struct ui_file *stream,\n   if (TYPE_TARGET_TYPE (type) == NULL\n       || TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n     {\n-      int i, len = TYPE_NFIELDS (type);\n+      int i, len = type->num_fields ();\n \n       fprintf_filtered (stream, \" (\");\n       for (i = 0; i < len; i++)\n@@ -311,7 +311,7 @@ m2_print_bounds (struct type *type,\n {\n   struct type *target = TYPE_TARGET_TYPE (type);\n \n-  if (TYPE_NFIELDS(type) == 0)\n+  if (type->num_fields () == 0)\n     return;\n \n   if (print_high)\n@@ -346,7 +346,7 @@ m2_is_long_set (struct type *type)\n \n       /* check if all fields of the RECORD are consecutive sets.  */\n \n-      len = TYPE_NFIELDS (type);\n+      len = type->num_fields ();\n       for (i = TYPE_N_BASECLASSES (type); i < len; i++)\n \t{\n \t  if (TYPE_FIELD_TYPE (type, i) == NULL)\n@@ -409,7 +409,7 @@ m2_is_long_set_of_type (struct type *type, struct type **of_type)\n \n   if (type->code () == TYPE_CODE_STRUCT)\n     {\n-      len = TYPE_NFIELDS (type);\n+      len = type->num_fields ();\n       i = TYPE_N_BASECLASSES (type);\n       if (len == 0)\n \treturn 0;\n@@ -434,7 +434,7 @@ m2_long_set (struct type *type, struct ui_file *stream, int show, int level,\n {\n   struct type *of_type;\n   int i;\n-  int len = TYPE_NFIELDS (type);\n+  int len = type->num_fields ();\n   LONGEST low;\n   LONGEST high;\n \n@@ -490,7 +490,7 @@ m2_is_unbounded_array (struct type *type)\n        *  type of _m2_contents is a pointer.  The TYPE_TARGET_TYPE\n        *  of the pointer determines the unbounded ARRAY OF type.\n        */\n-      if (TYPE_NFIELDS (type) != 2)\n+      if (type->num_fields () != 2)\n \treturn 0;\n       if (strcmp (TYPE_FIELD_NAME (type, 0), \"_m2_contents\") != 0)\n \treturn 0;\n@@ -550,7 +550,7 @@ m2_record_fields (struct type *type, struct ui_file *stream, int show,\n   else if (show > 0)\n     {\n       int i;\n-      int len = TYPE_NFIELDS (type);\n+      int len = type->num_fields ();\n \n       if (type->code () == TYPE_CODE_STRUCT)\n \tfprintf_filtered (stream, \"RECORD\\n\");\n@@ -601,7 +601,7 @@ m2_enum (struct type *type, struct ui_file *stream, int show, int level)\n   else if (show > 0 || type->name () == NULL)\n     {\n       fprintf_filtered (stream, \"(\");\n-      len = TYPE_NFIELDS (type);\n+      len = type->num_fields ();\n       lastval = 0;\n       for (i = 0; i < len; i++)\n \t{"
    },
    {
      "sha": "f9cb626fd6872ba348d77344e51dabb8f3b72fd3",
      "filename": "gdb/m2-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/m2-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/m2-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-valprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -51,7 +51,7 @@ get_long_set_bounds (struct type *type, LONGEST *low, LONGEST *high)\n \n   if (type->code () == TYPE_CODE_STRUCT)\n     {\n-      len = TYPE_NFIELDS (type);\n+      len = type->num_fields ();\n       i = TYPE_N_BASECLASSES (type);\n       if (len == 0)\n \treturn 0;\n@@ -83,7 +83,7 @@ m2_print_long_set (struct type *type, const gdb_byte *valaddr,\n   type = check_typedef (type);\n \n   fprintf_filtered (stream, \"{\");\n-  len = TYPE_NFIELDS (type);\n+  len = type->num_fields ();\n   if (get_long_set_bounds (type, &low_bound, &high_bound))\n     {\n       field = TYPE_N_BASECLASSES (type);"
    },
    {
      "sha": "d579616b06aa4a14b99362e78e50aa962fa09167",
      "filename": "gdb/m32c-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/m32c-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/m32c-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m32c-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -2033,7 +2033,7 @@ m32c_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n        separately, but the code in GCC doesn't actually do so.  */\n     if (TYPE_PROTOTYPED (func_type))\n #endif\n-      num_prototyped_args = TYPE_NFIELDS (func_type);\n+      num_prototyped_args = func_type->num_fields ();\n   }\n \n   /* First, if the function returns an aggregate by value, push a"
    },
    {
      "sha": "578cfdbf19ac3ff131803f12c49d74f23ce9701b",
      "filename": "gdb/m68k-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/m68k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/m68k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -463,7 +463,7 @@ m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,\n      changing TYPE into the type of the first member of the structure.\n      Since that should work for all structures that have only one\n      member, we don't bother to check the member's type here.  */\n-  if (code == TYPE_CODE_STRUCT && TYPE_NFIELDS (type) == 1)\n+  if (code == TYPE_CODE_STRUCT && type->num_fields () == 1)\n     {\n       type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n       return m68k_svr4_return_value (gdbarch, function, type, regcache,"
    },
    {
      "sha": "f634dbb08f18060ab4d55072b6e1012a79f71f3d",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1036,7 +1036,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t       are hopefully rare enough.\n \t       Alpha cc -migrate has a sh.value field of zero, we adjust\n \t       that too.  */\n-\t    if (TYPE_LENGTH (t) == TYPE_NFIELDS (t)\n+\t    if (TYPE_LENGTH (t) == t->num_fields ()\n \t\t|| TYPE_LENGTH (t) == 0)\n \t      TYPE_LENGTH (t) = gdbarch_int_bit (gdbarch) / HOST_CHAR_BIT;\n \t    for (ext_tsym = ext_sh + external_sym_size;\n@@ -1085,7 +1085,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \n \t/* gcc puts out an empty struct for an opaque struct definitions,\n \t   do not create a symbol for it either.  */\n-\tif (TYPE_NFIELDS (t) == 0)\n+\tif (t->num_fields () == 0)\n \t  {\n \t    TYPE_STUB (t) = 1;\n \t    break;\n@@ -1174,7 +1174,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t\t}\n \t    }\n \n-\t  if (TYPE_NFIELDS (ftype) <= 0)\n+\t  if (ftype->num_fields () <= 0)\n \t    {\n \t      /* No parameter type information is recorded with the function's\n \t         type.  Set that from the type of the parameter symbols.  */\n@@ -1297,7 +1297,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \n       /* Incomplete definitions of structs should not get a name.  */\n       if (SYMBOL_TYPE (s)->name () == NULL\n-\t  && (TYPE_NFIELDS (SYMBOL_TYPE (s)) != 0\n+\t  && (SYMBOL_TYPE (s)->num_fields () != 0\n \t      || (SYMBOL_TYPE (s)->code () != TYPE_CODE_STRUCT\n \t\t  && SYMBOL_TYPE (s)->code () != TYPE_CODE_UNION)))\n \t{"
    },
    {
      "sha": "a3ab8c80e37589ca1e19e603d3da2ba5ba7dca1a",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -4407,7 +4407,7 @@ fp_register_arg_p (struct gdbarch *gdbarch, enum type_code typecode,\n \t   || (MIPS_EABI (gdbarch)\n \t       && (typecode == TYPE_CODE_STRUCT\n \t\t   || typecode == TYPE_CODE_UNION)\n-\t       && TYPE_NFIELDS (arg_type) == 1\n+\t       && arg_type->num_fields () == 1\n \t       && check_typedef (TYPE_FIELD_TYPE (arg_type, 0))->code ()\n \t       == TYPE_CODE_FLT))\n \t  && MIPS_FPU_TYPE(gdbarch) != MIPS_FPU_NONE);\n@@ -4425,15 +4425,15 @@ mips_type_needs_double_align (struct type *type)\n     return 1;\n   else if (typecode == TYPE_CODE_STRUCT)\n     {\n-      if (TYPE_NFIELDS (type) < 1)\n+      if (type->num_fields () < 1)\n \treturn 0;\n       return mips_type_needs_double_align (TYPE_FIELD_TYPE (type, 0));\n     }\n   else if (typecode == TYPE_CODE_UNION)\n     {\n       int i, n;\n \n-      n = TYPE_NFIELDS (type);\n+      n = type->num_fields ();\n       for (i = 0; i < n; i++)\n \tif (mips_type_needs_double_align (TYPE_FIELD_TYPE (type, i)))\n \t  return 1;\n@@ -4788,7 +4788,7 @@ mips_eabi_return_value (struct gdbarch *gdbarch, struct value *function,\n \t are returned in a floating point register.  */\n       if ((type->code () == TYPE_CODE_STRUCT\n \t   || type->code () == TYPE_CODE_UNION)\n-\t  && TYPE_NFIELDS (type) == 1)\n+\t  && type->num_fields () == 1)\n \t{\n \t  struct type *fieldtype = TYPE_FIELD_TYPE (type, 0);\n \n@@ -4850,7 +4850,7 @@ mips_n32n64_fp_arg_chunk_p (struct gdbarch *gdbarch, struct type *arg_type,\n   if (TYPE_LENGTH (arg_type) < offset + MIPS64_REGSIZE)\n     return 0;\n \n-  for (i = 0; i < TYPE_NFIELDS (arg_type); i++)\n+  for (i = 0; i < arg_type->num_fields (); i++)\n     {\n       int pos;\n       struct type *field_type;\n@@ -5226,12 +5226,12 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n       return RETURN_VALUE_REGISTER_CONVENTION;\n     }\n   else if (type->code () == TYPE_CODE_STRUCT\n-\t   && TYPE_NFIELDS (type) <= 2\n-\t   && TYPE_NFIELDS (type) >= 1\n-\t   && ((TYPE_NFIELDS (type) == 1\n+\t   && type->num_fields () <= 2\n+\t   && type->num_fields () >= 1\n+\t   && ((type->num_fields () == 1\n \t\t&& (check_typedef (TYPE_FIELD_TYPE (type, 0))->code ()\n \t\t    == TYPE_CODE_FLT))\n-\t       || (TYPE_NFIELDS (type) == 2\n+\t       || (type->num_fields () == 2\n \t\t   && (check_typedef (TYPE_FIELD_TYPE (type, 0))->code ()\n \t\t       == TYPE_CODE_FLT)\n \t\t   && (check_typedef (TYPE_FIELD_TYPE (type, 1))->code ()\n@@ -5245,7 +5245,7 @@ mips_n32n64_return_value (struct gdbarch *gdbarch, struct value *function,\n       for (field = 0, regnum = (tdep->mips_fpu_type != MIPS_FPU_NONE\n \t\t\t\t? mips_regnum (gdbarch)->fp0\n \t\t\t\t: MIPS_V0_REGNUM);\n-\t   field < TYPE_NFIELDS (type); field++, regnum += 2)\n+\t   field < type->num_fields (); field++, regnum += 2)\n \t{\n \t  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])\n \t\t\t/ TARGET_CHAR_BIT);\n@@ -5779,12 +5779,12 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n     }\n #if 0\n   else if (type->code () == TYPE_CODE_STRUCT\n-\t   && TYPE_NFIELDS (type) <= 2\n-\t   && TYPE_NFIELDS (type) >= 1\n-\t   && ((TYPE_NFIELDS (type) == 1\n+\t   && type->num_fields () <= 2\n+\t   && type->num_fields () >= 1\n+\t   && ((type->num_fields () == 1\n \t\t&& (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))\n \t\t    == TYPE_CODE_FLT))\n-\t       || (TYPE_NFIELDS (type) == 2\n+\t       || (type->num_fields () == 2\n \t\t   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 0))\n \t\t       == TYPE_CODE_FLT)\n \t\t   && (TYPE_CODE (TYPE_FIELD_TYPE (type, 1))\n@@ -5797,7 +5797,7 @@ mips_o32_return_value (struct gdbarch *gdbarch, struct value *function,\n       int regnum;\n       int field;\n       for (field = 0, regnum = mips_regnum (gdbarch)->fp0;\n-\t   field < TYPE_NFIELDS (type); field++, regnum += 2)\n+\t   field < type->num_fields (); field++, regnum += 2)\n \t{\n \t  int offset = (FIELD_BITPOS (TYPE_FIELDS (type)[field])\n \t\t\t/ TARGET_CHAR_BIT);"
    },
    {
      "sha": "7f81c5985fff53637f9c1095644f498d335bce93",
      "filename": "gdb/mn10300-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/mn10300-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/mn10300-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mn10300-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -107,7 +107,7 @@ mn10300_type_align (struct type *type)\n \n     case TYPE_CODE_STRUCT:\n     case TYPE_CODE_UNION:\n-      for (i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (i = 0; i < type->num_fields (); i++)\n \t{\n \t  int falign = mn10300_type_align (TYPE_FIELD_TYPE (type, i));\n \t  while (align < falign)\n@@ -143,7 +143,7 @@ mn10300_use_struct_convention (struct type *type)\n     case TYPE_CODE_UNION:\n       /* Structures with a single field are handled as the field\n \t itself.  */\n-      if (TYPE_NFIELDS (type) == 1)\n+      if (type->num_fields () == 1)\n \treturn mn10300_use_struct_convention (TYPE_FIELD_TYPE (type, 0));\n \n       /* Structures with word or double-word size are passed in memory, as"
    },
    {
      "sha": "d403b71f10b0e9c4ff17f9dfbc2df0ce7485995f",
      "filename": "gdb/nds32-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/nds32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/nds32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nds32-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1405,7 +1405,7 @@ nds32_check_calling_use_fpr (struct type *type)\n       typecode = t->code ();\n       if (typecode != TYPE_CODE_STRUCT)\n \tbreak;\n-      else if (TYPE_NFIELDS (t) != 1)\n+      else if (t->num_fields () != 1)\n \treturn 0;\n       else\n \tt = TYPE_FIELD_TYPE (t, 0);\n@@ -1496,7 +1496,7 @@ nds32_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t and pushes all unnamed arguments in stack.  */\n \n       if (abi_use_fpr && TYPE_VARARGS (func_type)\n-\t  && i >= TYPE_NFIELDS (func_type))\n+\t  && i >= func_type->num_fields ())\n \tgoto use_stack;\n \n       /* Try to use FPRs to pass arguments only when"
    },
    {
      "sha": "75df206a2bd409eeebef9074cbbac842d08b80be",
      "filename": "gdb/or1k-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/or1k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/or1k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/or1k-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -635,7 +635,7 @@ or1k_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n       int len = TYPE_LENGTH (arg_type);\n       enum type_code typecode = arg_type->code ();\n \n-      if (TYPE_VARARGS (func_type) && argnum >= TYPE_NFIELDS (func_type))\n+      if (TYPE_VARARGS (func_type) && argnum >= func_type->num_fields ())\n \tbreak; /* end or regular args, varargs go to stack.  */\n \n       /* Extract the value, either a reference or the data.  */"
    },
    {
      "sha": "aa483336d2c2a57bac33a8a0b15f0b6ac0bc53b7",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -104,7 +104,7 @@ is_pascal_string_type (struct type *type,int *length_pos,\n     {\n       /* Old Borland type pascal strings from Free Pascal Compiler.  */\n       /* Two fields: length and st.  */\n-      if (TYPE_NFIELDS (type) == 2\n+      if (type->num_fields () == 2\n \t  && TYPE_FIELD_NAME (type, 0)\n \t  && strcmp (TYPE_FIELD_NAME (type, 0), \"length\") == 0\n \t  && TYPE_FIELD_NAME (type, 1)\n@@ -124,7 +124,7 @@ is_pascal_string_type (struct type *type,int *length_pos,\n         };\n       /* GNU pascal strings.  */\n       /* Three fields: Capacity, length and schema$ or _p_schema.  */\n-      if (TYPE_NFIELDS (type) == 3\n+      if (type->num_fields () == 3\n \t  && TYPE_FIELD_NAME (type, 0)\n \t  && strcmp (TYPE_FIELD_NAME (type, 0), \"Capacity\") == 0\n \t  && TYPE_FIELD_NAME (type, 1)"
    },
    {
      "sha": "3246d4e82a51cee5fc3a5d7f08783af3f0284693",
      "filename": "gdb/p-typeprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/p-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/p-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-typeprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -309,7 +309,7 @@ static void\n pascal_print_func_args (struct type *type, struct ui_file *stream,\n \t\t\tconst struct type_print_options *flags)\n {\n-  int i, len = TYPE_NFIELDS (type);\n+  int i, len = type->num_fields ();\n \n   if (len)\n     {\n@@ -559,7 +559,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t  pascal_type_print_derivation_info (stream, type);\n \n \t  fprintf_filtered (stream, \"\\n\");\n-\t  if ((TYPE_NFIELDS (type) == 0) && (TYPE_NFN_FIELDS (type) == 0))\n+\t  if ((type->num_fields () == 0) && (TYPE_NFN_FIELDS (type) == 0))\n \t    {\n \t      if (TYPE_STUB (type))\n \t\tfprintfi_filtered (level + 4, stream, \"<incomplete type>\\n\");\n@@ -576,7 +576,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t  /* If there is a base class for this type,\n \t     do not print the field that it occupies.  */\n \n-\t  len = TYPE_NFIELDS (type);\n+\t  len = type->num_fields ();\n \t  for (i = TYPE_N_BASECLASSES (type); i < len; i++)\n \t    {\n \t      QUIT;\n@@ -758,7 +758,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n       else if (show > 0 || type->name () == NULL)\n \t{\n \t  fprintf_filtered (stream, \"(\");\n-\t  len = TYPE_NFIELDS (type);\n+\t  len = type->num_fields ();\n \t  lastval = 0;\n \t  for (i = 0; i < len; i++)\n \t    {"
    },
    {
      "sha": "284dc85bf8c816434c241f44d2d259c164bd6b4b",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -524,7 +524,7 @@ pascal_object_print_value_fields (struct value *val, struct ui_file *stream,\n   struct type *type = check_typedef (value_type (val));\n \n   fprintf_filtered (stream, \"{\");\n-  len = TYPE_NFIELDS (type);\n+  len = type->num_fields ();\n   n_baseclasses = TYPE_N_BASECLASSES (type);\n \n   /* Print out baseclasses such that we don't print"
    },
    {
      "sha": "c0e6a929263c3c27f7ea147fcc922ed291d094e2",
      "filename": "gdb/ppc-sysv-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ppc-sysv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/ppc-sysv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-sysv-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1138,7 +1138,7 @@ ppc64_aggregate_candidate (struct type *type,\n \t  LONGEST count = 0;\n \t  int i;\n \n-\t  for (i = 0; i < TYPE_NFIELDS (type); i++)\n+\t  for (i = 0; i < type->num_fields (); i++)\n \t    {\n \t      LONGEST sub_count;\n \n@@ -1494,10 +1494,10 @@ ppc64_sysv_abi_push_param (struct gdbarch *gdbarch,\n \t single floating-point value, at any level of nesting of\n \t single-member structs, are passed in floating-point registers.  */\n       if (type->code () == TYPE_CODE_STRUCT\n-\t  && TYPE_NFIELDS (type) == 1)\n+\t  && type->num_fields () == 1)\n \t{\n \t  while (type->code () == TYPE_CODE_STRUCT\n-\t\t && TYPE_NFIELDS (type) == 1)\n+\t\t && type->num_fields () == 1)\n \t    type = check_typedef (TYPE_FIELD_TYPE (type, 0));\n \n \t  if (type->code () == TYPE_CODE_FLT)"
    },
    {
      "sha": "dbe25ad8f6cd53330eb48b91bb2885ec7321605a",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1150,7 +1150,7 @@ typy_length (PyObject *self)\n   if (type == NULL)\n     return -1;\n \n-  return TYPE_NFIELDS (type);\n+  return type->num_fields ();\n }\n \n /* Implements boolean evaluation of gdb.Type.  Handle this like other\n@@ -1193,7 +1193,7 @@ typy_getitem (PyObject *self, PyObject *key)\n   if (type == NULL)\n     return NULL;\n \n-  for (i = 0; i < TYPE_NFIELDS (type); i++)\n+  for (i = 0; i < type->num_fields (); i++)\n     {\n       const char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -1251,7 +1251,7 @@ typy_has_key (PyObject *self, PyObject *args)\n   if (type == NULL)\n     return NULL;\n \n-  for (i = 0; i < TYPE_NFIELDS (type); i++)\n+  for (i = 0; i < type->num_fields (); i++)\n     {\n       const char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -1336,7 +1336,7 @@ typy_iterator_iternext (PyObject *self)\n   typy_iterator_object *iter_obj = (typy_iterator_object *) self;\n   struct type *type = iter_obj->source->type;\n \n-  if (iter_obj->field < TYPE_NFIELDS (type))\n+  if (iter_obj->field < type->num_fields ())\n     {\n       gdbpy_ref<> result = make_fielditem (type, iter_obj->field,\n \t\t\t\t\t   iter_obj->kind);"
    },
    {
      "sha": "0842dcbcb239abdf82c01c3585c542bdd7d51c18",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -642,11 +642,11 @@ riscv_print_one_register_info (struct gdbarch *gdbarch,\n \n   if (regtype->code () == TYPE_CODE_FLT\n       || (regtype->code () == TYPE_CODE_UNION\n-\t  && TYPE_NFIELDS (regtype) == 2\n+\t  && regtype->num_fields () == 2\n \t  && TYPE_FIELD_TYPE (regtype, 0)->code () == TYPE_CODE_FLT\n \t  && TYPE_FIELD_TYPE (regtype, 1)->code () == TYPE_CODE_FLT)\n       || (regtype->code () == TYPE_CODE_UNION\n-\t  && TYPE_NFIELDS (regtype) == 3\n+\t  && regtype->num_fields () == 3\n \t  && TYPE_FIELD_TYPE (regtype, 0)->code () == TYPE_CODE_FLT\n \t  && TYPE_FIELD_TYPE (regtype, 1)->code () == TYPE_CODE_FLT\n \t  && TYPE_FIELD_TYPE (regtype, 2)->code () == TYPE_CODE_FLT))\n@@ -2044,7 +2044,7 @@ class riscv_struct_info\n void\n riscv_struct_info::analyse_inner (struct type *type, int offset)\n {\n-  unsigned int count = TYPE_NFIELDS (type);\n+  unsigned int count = type->num_fields ();\n   unsigned int i;\n \n   for (i = 0; i < count; ++i)\n@@ -2445,7 +2445,7 @@ riscv_push_dummy_call (struct gdbarch *gdbarch,\n       arg_type = check_typedef (value_type (arg_value));\n \n       riscv_arg_location (gdbarch, info, &call_info, arg_type,\n-\t\t\t  TYPE_VARARGS (ftype) && i >= TYPE_NFIELDS (ftype));\n+\t\t\t  TYPE_VARARGS (ftype) && i >= ftype->num_fields ());\n \n       if (info->type != arg_type)\n \targ_value = value_cast (info->type, arg_value);"
    },
    {
      "sha": "47aa799754d7661b0c5e5b52e27fbc01ea9d8fa7",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -2414,7 +2414,7 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n \n \t    if (!want_type\n \t\t&& type->code () == TYPE_CODE_STRUCT\n-\t\t&& TYPE_NFIELDS (type) == 0)\n+\t\t&& type->num_fields () == 0)\n \t      {\n \t\t/* A unit-like struct.  */\n \t\twrite_exp_elt_opcode (pstate, OP_AGGREGATE);"
    },
    {
      "sha": "f8696628474d4b3dfa568ddc2d565c4e621c37b8",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 23,
      "deletions": 23,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -81,7 +81,7 @@ rust_enum_p (struct type *type)\n static bool\n rust_empty_enum_p (const struct type *type)\n {\n-  return TYPE_NFIELDS (type) == 0;\n+  return type->num_fields () == 0;\n }\n \n /* Given an already-resolved enum type and contents, find which\n@@ -91,7 +91,7 @@ static int\n rust_enum_variant (struct type *type)\n {\n   /* The active variant is simply the first non-artificial field.  */\n-  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (int i = 0; i < type->num_fields (); ++i)\n     if (!TYPE_FIELD_ARTIFICIAL (type, i))\n       return i;\n \n@@ -126,7 +126,7 @@ rust_underscore_fields (struct type *type)\n \n   if (type->code () != TYPE_CODE_STRUCT)\n     return false;\n-  for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (i = 0; i < type->num_fields (); ++i)\n     {\n       if (!field_is_static (&TYPE_FIELD (type, i)))\n \t{\n@@ -149,7 +149,7 @@ rust_tuple_struct_type_p (struct type *type)\n   /* This is just an approximation until DWARF can represent Rust more\n      precisely.  We exclude zero-length structs because they may not\n      be tuple structs, and there's no way to tell.  */\n-  return TYPE_NFIELDS (type) > 0 && rust_underscore_fields (type);\n+  return type->num_fields () > 0 && rust_underscore_fields (type);\n }\n \n /* Return true if TYPE is a slice type, otherwise false.  */\n@@ -171,22 +171,22 @@ rust_range_type_p (struct type *type)\n   int i;\n \n   if (type->code () != TYPE_CODE_STRUCT\n-      || TYPE_NFIELDS (type) > 2\n+      || type->num_fields () > 2\n       || type->name () == NULL\n       || strstr (type->name (), \"::Range\") == NULL)\n     return false;\n \n-  if (TYPE_NFIELDS (type) == 0)\n+  if (type->num_fields () == 0)\n     return true;\n \n   i = 0;\n   if (strcmp (TYPE_FIELD_NAME (type, 0), \"start\") == 0)\n     {\n-      if (TYPE_NFIELDS (type) == 1)\n+      if (type->num_fields () == 1)\n \treturn true;\n       i = 1;\n     }\n-  else if (TYPE_NFIELDS (type) == 2)\n+  else if (type->num_fields () == 2)\n     {\n       /* First field had to be \"start\".  */\n       return false;\n@@ -255,7 +255,7 @@ rust_get_trait_object_pointer (struct value *value)\n {\n   struct type *type = check_typedef (value_type (value));\n \n-  if (type->code () != TYPE_CODE_STRUCT || TYPE_NFIELDS (type) != 2)\n+  if (type->code () != TYPE_CODE_STRUCT || type->num_fields () != 2)\n     return NULL;\n \n   /* Try to be a bit resilient if the ABI changes.  */\n@@ -402,7 +402,7 @@ val_print_struct (struct value *val, struct ui_file *stream, int recurse,\n       if (type->name () != NULL)\n         fprintf_filtered (stream, \"%s\", type->name ());\n \n-      if (TYPE_NFIELDS (type) == 0)\n+      if (type->num_fields () == 0)\n         return;\n \n       if (type->name () != NULL)\n@@ -418,7 +418,7 @@ val_print_struct (struct value *val, struct ui_file *stream, int recurse,\n   opts.deref_ref = 0;\n \n   first_field = 1;\n-  for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (i = 0; i < type->num_fields (); ++i)\n     {\n       if (field_is_static (&TYPE_FIELD (type, i)))\n         continue;\n@@ -488,7 +488,7 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n   val = value_field (val, variant_fieldno);\n   struct type *variant_type = TYPE_FIELD_TYPE (type, variant_fieldno);\n \n-  int nfields = TYPE_NFIELDS (variant_type);\n+  int nfields = variant_type->num_fields ();\n \n   bool is_tuple = rust_tuple_struct_type_p (variant_type);\n \n@@ -510,7 +510,7 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n     }\n \n   bool first_field = true;\n-  for (int j = 0; j < TYPE_NFIELDS (variant_type); j++)\n+  for (int j = 0; j < variant_type->num_fields (); j++)\n     {\n       if (!first_field)\n \tfputs_filtered (\", \", stream);\n@@ -721,7 +721,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n \tfputs_filtered (tagname, stream);\n     }\n \n-  if (TYPE_NFIELDS (type) == 0 && !is_tuple)\n+  if (type->num_fields () == 0 && !is_tuple)\n     return;\n   if (for_rust_enum && !flags->print_offsets)\n     fputs_filtered (is_tuple_struct ? \"(\" : \"{\", stream);\n@@ -733,7 +733,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n      field indices here because it simplifies calls to\n      print_offset_data::update below.  */\n   std::vector<int> fields;\n-  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+  for (int i = 0; i < type->num_fields (); ++i)\n     {\n       if (field_is_static (&TYPE_FIELD (type, i)))\n \tcontinue;\n@@ -783,7 +783,7 @@ rust_print_struct_def (struct type *type, const char *varstring,\n       /* Note that this check of \"I\" is ok because we only sorted the\n \t fields by offset when print_offsets was set, so we won't take\n \t this branch in that case.  */\n-      else if (i + 1 < TYPE_NFIELDS (type))\n+      else if (i + 1 < type->num_fields ())\n \tfputs_filtered (\", \", stream);\n     }\n \n@@ -855,7 +855,7 @@ rust_internal_print_type (struct type *type, const char *varstring,\n       if (varstring != NULL)\n \tfputs_filtered (varstring, stream);\n       fputs_filtered (\"(\", stream);\n-      for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+      for (int i = 0; i < type->num_fields (); ++i)\n \t{\n \t  QUIT;\n \t  if (i > 0)\n@@ -911,7 +911,7 @@ rust_internal_print_type (struct type *type, const char *varstring,\n \t  }\n \tfputs_filtered (\"{\\n\", stream);\n \n-\tfor (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+\tfor (int i = 0; i < type->num_fields (); ++i)\n \t  {\n \t    const char *name = TYPE_FIELD_NAME (type, i);\n \n@@ -1171,7 +1171,7 @@ rust_evaluate_funcall (struct expression *exp, int *pos, enum noside noside)\n     error (_(\"Could not find function named '%s'\"), name.c_str ());\n \n   fn_type = SYMBOL_TYPE (sym.symbol);\n-  if (TYPE_NFIELDS (fn_type) == 0)\n+  if (fn_type->num_fields () == 0)\n     error (_(\"Function '%s' takes no arguments\"), name.c_str ());\n \n   if (TYPE_FIELD_TYPE (fn_type, 0)->code () == TYPE_CODE_PTR)\n@@ -1303,7 +1303,7 @@ rust_compute_range (struct type *type, struct value *range,\n   *high = 0;\n   *kind = BOTH_BOUND_DEFAULT;\n \n-  if (TYPE_NFIELDS (type) == 0)\n+  if (type->num_fields () == 0)\n     return;\n \n   i = 0;\n@@ -1313,7 +1313,7 @@ rust_compute_range (struct type *type, struct value *range,\n       *low = value_as_long (value_field (range, 0));\n       ++i;\n     }\n-  if (TYPE_NFIELDS (type) > i\n+  if (type->num_fields () > i\n       && strcmp (TYPE_FIELD_NAME (type, i), \"end\") == 0)\n     {\n       *kind = (*kind == BOTH_BOUND_DEFAULT\n@@ -1365,7 +1365,7 @@ rust_subscript (struct expression *exp, int *pos, enum noside noside,\n \tbase_type = TYPE_TARGET_TYPE (type);\n       else if (rust_slice_type_p (type))\n \t{\n-\t  for (int i = 0; i < TYPE_NFIELDS (type); ++i)\n+\t  for (int i = 0; i < type->num_fields (); ++i)\n \t    {\n \t      if (strcmp (TYPE_FIELD_NAME (type, i), \"data_ptr\") == 0)\n \t\t{\n@@ -1676,7 +1676,7 @@ rust_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t      }\n \n \t    /* Tuples and tuple structs */\n-\t    nfields = TYPE_NFIELDS (type);\n+\t    nfields = type->num_fields ();\n \n \t    if (field_number >= nfields || field_number < 0)\n \t      {"
    },
    {
      "sha": "0a9b1e8e47a19620fd54ea9afdefb414ccad3d83",
      "filename": "gdb/rx-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/rx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/rx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rx-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -687,7 +687,7 @@ rx_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n      of the ``arg_reg'' variable to get these other details correct.  */\n \n   if (TYPE_VARARGS (func_type))\n-    num_register_candidate_args = TYPE_NFIELDS (func_type) - 1;\n+    num_register_candidate_args = func_type->num_fields () - 1;\n   else\n     num_register_candidate_args = 4;\n \n@@ -796,7 +796,7 @@ rx_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t      int p_arg_size = 4;\n \n \t\t      if (TYPE_PROTOTYPED (func_type)\n-\t\t\t  && i < TYPE_NFIELDS (func_type))\n+\t\t\t  && i < func_type->num_fields ())\n \t\t\t{\n \t\t\t  struct type *p_arg_type =\n \t\t\t    TYPE_FIELD_TYPE (func_type, i);"
    },
    {
      "sha": "d6f176a4867eb8cd936e521e1323dc91ebd40b70",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1644,7 +1644,7 @@ s390_effective_inner_type (struct type *type, unsigned int min_size)\n \n       /* Find a non-static field, if any.  Unless there's exactly one,\n \t abort the unwrapping.  */\n-      for (int i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (int i = 0; i < type->num_fields (); i++)\n \t{\n \t  struct field f = TYPE_FIELD (type, i);\n \n@@ -1938,7 +1938,7 @@ s390_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n      and arg_state.argp with the size of the parameter area.  */\n   for (i = 0; i < nargs; i++)\n     s390_handle_arg (&arg_state, args[i], tdep, word_size, byte_order,\n-\t\t     TYPE_VARARGS (ftype) && i >= TYPE_NFIELDS (ftype));\n+\t\t     TYPE_VARARGS (ftype) && i >= ftype->num_fields ());\n \n   param_area_start = align_down (arg_state.copy - arg_state.argp, 8);\n \n@@ -1965,7 +1965,7 @@ s390_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   /* Write all parameters.  */\n   for (i = 0; i < nargs; i++)\n     s390_handle_arg (&arg_state, args[i], tdep, word_size, byte_order,\n-\t\t     TYPE_VARARGS (ftype) && i >= TYPE_NFIELDS (ftype));\n+\t\t     TYPE_VARARGS (ftype) && i >= ftype->num_fields ());\n \n   /* Store return PSWA.  In 31-bit mode, keep addressing mode bit.  */\n   if (word_size == 4)"
    },
    {
      "sha": "b4f00e46ad4a81ebdfaeee8572dff9cf57648946",
      "filename": "gdb/score-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/score-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/score-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/score-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -478,7 +478,7 @@ score_type_needs_double_align (struct type *type)\n     {\n       int i, n;\n \n-      n = TYPE_NFIELDS (type);\n+      n = type->num_fields ();\n       for (i = 0; i < n; i++)\n         if (score_type_needs_double_align (TYPE_FIELD_TYPE (type, i)))\n           return 1;"
    },
    {
      "sha": "f134cf1c917c73b9fd272500e5c61eacceb91935",
      "filename": "gdb/sh-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/sh-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/sh-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sh-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -813,7 +813,7 @@ static int\n sh_use_struct_convention (int renesas_abi, struct type *type)\n {\n   int len = TYPE_LENGTH (type);\n-  int nelem = TYPE_NFIELDS (type);\n+  int nelem = type->num_fields ();\n \n   /* The Renesas ABI returns aggregate types always on stack.  */\n   if (renesas_abi && (type->code () == TYPE_CODE_STRUCT\n@@ -849,7 +849,7 @@ static int\n sh_use_struct_convention_nofpu (int renesas_abi, struct type *type)\n {\n   /* The Renesas ABI returns long longs/doubles etc. always on stack.  */\n-  if (renesas_abi && TYPE_NFIELDS (type) == 0 && TYPE_LENGTH (type) >= 8)\n+  if (renesas_abi && type->num_fields () == 0 && TYPE_LENGTH (type) >= 8)\n     return 1;\n   return sh_use_struct_convention (renesas_abi, type);\n }\n@@ -1046,7 +1046,7 @@ sh_treat_as_flt_p (struct type *type)\n   if (type->code () != TYPE_CODE_STRUCT)\n     return 0;\n   /* Otherwise structs with more than one member are not treated as float.  */\n-  if (TYPE_NFIELDS (type) != 1)\n+  if (type->num_fields () != 1)\n     return 0;\n   /* Otherwise if the type of that member is float, the whole type is\n      treated as float.  */\n@@ -1084,7 +1084,7 @@ sh_push_dummy_call_fpu (struct gdbarch *gdbarch,\n      registers have been used so far.  */\n   if (sh_is_renesas_calling_convention (func_type)\n       && TYPE_VARARGS (func_type))\n-    last_reg_arg = TYPE_NFIELDS (func_type) - 2;\n+    last_reg_arg = func_type->num_fields () - 2;\n \n   /* First force sp to a 4-byte alignment.  */\n   sp = sh_frame_align (gdbarch, sp);\n@@ -1225,7 +1225,7 @@ sh_push_dummy_call_nofpu (struct gdbarch *gdbarch,\n      registers have been used so far.  */\n   if (sh_is_renesas_calling_convention (func_type)\n       && TYPE_VARARGS (func_type))\n-    last_reg_arg = TYPE_NFIELDS (func_type) - 2;\n+    last_reg_arg = func_type->num_fields () - 2;\n \n   /* First force sp to a 4-byte alignment.  */\n   sp = sh_frame_align (gdbarch, sp);"
    },
    {
      "sha": "5d6ef071099fe5ef97c35c22ca2d8e16919d521f",
      "filename": "gdb/sparc64-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/sparc64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/sparc64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc64-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1179,7 +1179,7 @@ sparc64_16_byte_align_p (struct type *type)\n     {\n       int i;\n \n-      for (i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (i = 0; i < type->num_fields (); i++)\n \t{\n \t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n \n@@ -1256,7 +1256,7 @@ sparc64_store_floating_fields (struct regcache *regcache, struct type *type,\n     {\n       int i;\n \n-      for (i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (i = 0; i < type->num_fields (); i++)\n \t{\n \t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n \t  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);\n@@ -1274,7 +1274,7 @@ sparc64_store_floating_fields (struct regcache *regcache, struct type *type,\n          probably in older releases to.  To appease GCC, if a\n          structure has only a single `float' member, we store its\n          value in %f1 too (we already have stored in %f0).  */\n-      if (TYPE_NFIELDS (type) == 1)\n+      if (type->num_fields () == 1)\n \t{\n \t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, 0));\n \n@@ -1344,7 +1344,7 @@ sparc64_extract_floating_fields (struct regcache *regcache, struct type *type,\n     {\n       int i;\n \n-      for (i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (i = 0; i < type->num_fields (); i++)\n \t{\n \t  struct type *subtype = check_typedef (TYPE_FIELD_TYPE (type, i));\n \t  int subpos = bitpos + TYPE_FIELD_BITPOS (type, i);"
    },
    {
      "sha": "daf88c851c72a9110c3b00a7590987b01268fabf",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -3232,7 +3232,7 @@ read_tilde_fields (struct stab_field_info *fip, const char **pp,\n \t  set_type_vptr_basetype (type, t);\n \t  if (type == t)\t/* Our own class provides vtbl ptr.  */\n \t    {\n-\t      for (i = TYPE_NFIELDS (t) - 1;\n+\t      for (i = t->num_fields () - 1;\n \t\t   i >= TYPE_N_BASECLASSES (t);\n \t\t   --i)\n \t\t{"
    },
    {
      "sha": "42f1b1ee690a49c6ceb367a7cf5a3bc176a062d0",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1966,7 +1966,7 @@ check_field (struct type *type, const char *name,\n   /* The type may be a stub.  */\n   type = check_typedef (type);\n \n-  for (i = TYPE_NFIELDS (type) - 1; i >= TYPE_N_BASECLASSES (type); i--)\n+  for (i = type->num_fields () - 1; i >= TYPE_N_BASECLASSES (type); i--)\n     {\n       const char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -5472,7 +5472,7 @@ completion_list_add_fields (completion_tracker &tracker,\n       int j;\n \n       if (c == TYPE_CODE_UNION || c == TYPE_CODE_STRUCT)\n-\tfor (j = TYPE_N_BASECLASSES (t); j < TYPE_NFIELDS (t); j++)\n+\tfor (j = TYPE_N_BASECLASSES (t); j < t->num_fields (); j++)\n \t  if (TYPE_FIELD_NAME (t, j))\n \t    completion_list_add_name (tracker, sym->language (),\n \t\t\t\t      TYPE_FIELD_NAME (t, j),"
    },
    {
      "sha": "57945d21db711f17fad49b0e4c35c44247f9bce9",
      "filename": "gdb/tic6x-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/tic6x-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/tic6x-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tic6x-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -890,7 +890,7 @@ tic6x_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n   /* For a variadic C function, the last explicitly declared argument and all\n      remaining arguments are passed on the stack.  */\n   if (TYPE_VARARGS (func_type))\n-    first_arg_on_stack = TYPE_NFIELDS (func_type) - 1;\n+    first_arg_on_stack = func_type->num_fields () - 1;\n \n   /* Now make space on the stack for the args.  */\n   for (argnum = 0; argnum < nargs; argnum++)"
    },
    {
      "sha": "a46f6a564c059956b1916e32bfa78d8f4b410046",
      "filename": "gdb/typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/typeprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -619,7 +619,7 @@ print_type_scalar (struct type *type, LONGEST val, struct ui_file *stream)\n     {\n \n     case TYPE_CODE_ENUM:\n-      len = TYPE_NFIELDS (type);\n+      len = type->num_fields ();\n       for (i = 0; i < len; i++)\n \t{\n \t  if (TYPE_FIELD_ENUMVAL (type, i) == val)"
    },
    {
      "sha": "298613e42c31d35cb179e2e94f6ac75411d0a016",
      "filename": "gdb/v850-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/v850-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/v850-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/v850-tdep.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -532,7 +532,7 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n      type whose size is greater than or equal to 4 -> returned in register.  */\n   if ((type->code () == TYPE_CODE_STRUCT\n        || type->code () == TYPE_CODE_UNION)\n-       && TYPE_NFIELDS (type) == 1)\n+       && type->num_fields () == 1)\n     {\n       fld_type = TYPE_FIELD_TYPE (type, 0);\n       if (v850_type_is_scalar (fld_type) && TYPE_LENGTH (fld_type) >= 4)\n@@ -553,7 +553,7 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n       && v850_type_is_scalar (TYPE_FIELD_TYPE (type, 0))\n       && TYPE_LENGTH (TYPE_FIELD_TYPE (type, 0)) == 4)\n     {\n-      for (i = 1; i < TYPE_NFIELDS (type); ++i)\n+      for (i = 1; i < type->num_fields (); ++i)\n         {\n \t  fld_type = TYPE_FIELD_TYPE (type, 0);\n \t  if (fld_type->code () == TYPE_CODE_ARRAY)\n@@ -572,7 +572,7 @@ v850_use_struct_convention (struct gdbarch *gdbarch, struct type *type)\n      returned in register.  */\n   if (type->code () == TYPE_CODE_UNION)\n     {\n-      for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+      for (i = 0; i < type->num_fields (); ++i)\n         {\n \t  fld_type = TYPE_FIELD_TYPE (type, 0);\n \t  if (!v850_use_struct_convention (gdbarch, fld_type))\n@@ -981,7 +981,7 @@ v850_eight_byte_align_p (struct type *type)\n     {\n       int i;\n \n-      for (i = 0; i < TYPE_NFIELDS (type); i++)\n+      for (i = 0; i < type->num_fields (); i++)\n \t{\n \t  if (v850_eight_byte_align_p (TYPE_FIELD_TYPE (type, i)))\n \t    return 1;"
    },
    {
      "sha": "8cbc3b92ec8c66d14668f53ba0f902d09f56a84a",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -1805,7 +1805,7 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n   nbases = TYPE_N_BASECLASSES (type);\n \n   if (!looking_for_baseclass)\n-    for (i = TYPE_NFIELDS (type) - 1; i >= nbases; i--)\n+    for (i = type->num_fields () - 1; i >= nbases; i--)\n       {\n \tconst char *t_field_name = TYPE_FIELD_NAME (type, i);\n \n@@ -1851,7 +1851,7 @@ do_search_struct_field (const char *name, struct value *arg1, LONGEST offset,\n \t\t   bitpos is zero in an anonymous union field, so we\n \t\t   have to add the offset of the union here.  */\n \t\tif (field_type->code () == TYPE_CODE_STRUCT\n-\t\t    || (TYPE_NFIELDS (field_type) > 0\n+\t\t    || (field_type->num_fields () > 0\n \t\t\t&& TYPE_FIELD_BITPOS (field_type, 0) == 0))\n \t\t  new_offset += TYPE_FIELD_BITPOS (type, i) / 8;\n \n@@ -2007,7 +2007,7 @@ search_struct_method (const char *name, struct value **arg1p,\n \t      {\n \t\tif (!typecmp (TYPE_FN_FIELD_STATIC_P (f, j),\n \t\t\t      TYPE_VARARGS (TYPE_FN_FIELD_TYPE (f, j)),\n-\t\t\t      TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (f, j)),\n+\t\t\t      TYPE_FN_FIELD_TYPE (f, j)->num_fields (),\n \t\t\t      TYPE_FN_FIELD_ARGS (f, j), args))\n \t\t  {\n \t\t    if (TYPE_FN_FIELD_VIRTUAL_P (f, j))\n@@ -2219,7 +2219,7 @@ value_struct_elt_bitpos (struct value **argp, int bitpos, struct type *ftype,\n     error (_(\"Attempt to extract a component of a value that is not a %s.\"),\n \t   err);\n \n-  for (i = TYPE_N_BASECLASSES (t); i < TYPE_NFIELDS (t); i++)\n+  for (i = TYPE_N_BASECLASSES (t); i < t->num_fields (); i++)\n     {\n       if (!field_is_static (&TYPE_FIELD (t, i))\n \t  && bitpos == TYPE_FIELD_BITPOS (t, i)\n@@ -2957,11 +2957,11 @@ find_oload_champ (gdb::array_view<value *> args,\n \n \t  if (methods != NULL)\n \t    {\n-\t      nparms = TYPE_NFIELDS (TYPE_FN_FIELD_TYPE (methods, ix));\n+\t      nparms = TYPE_FN_FIELD_TYPE (methods, ix)->num_fields ();\n \t      static_offset = oload_method_static_p (methods, ix);\n \t    }\n \t  else\n-\t    nparms = TYPE_NFIELDS (SYMBOL_TYPE (functions[ix]));\n+\t    nparms = SYMBOL_TYPE (functions[ix])->num_fields ();\n \n \t  parm_types.reserve (nparms);\n \t  for (jj = 0; jj < nparms; jj++)\n@@ -3121,7 +3121,7 @@ enum_constant_from_type (struct type *type, const char *name)\n   gdb_assert (type->code () == TYPE_CODE_ENUM\n \t      && TYPE_DECLARED_CLASS (type));\n \n-  for (i = TYPE_N_BASECLASSES (type); i < TYPE_NFIELDS (type); ++i)\n+  for (i = TYPE_N_BASECLASSES (type); i < type->num_fields (); ++i)\n     {\n       const char *fname = TYPE_FIELD_NAME (type, i);\n       int len;\n@@ -3189,14 +3189,14 @@ compare_parameters (struct type *t1, struct type *t2, int skip_artificial)\n {\n   int start = 0;\n \n-  if (TYPE_NFIELDS (t1) > 0 && TYPE_FIELD_ARTIFICIAL (t1, 0))\n+  if (t1->num_fields () > 0 && TYPE_FIELD_ARTIFICIAL (t1, 0))\n     ++start;\n \n   /* If skipping artificial fields, find the first real field\n      in T1.  */\n   if (skip_artificial)\n     {\n-      while (start < TYPE_NFIELDS (t1)\n+      while (start < t1->num_fields ()\n \t     && TYPE_FIELD_ARTIFICIAL (t1, start))\n \t++start;\n     }\n@@ -3205,15 +3205,15 @@ compare_parameters (struct type *t1, struct type *t2, int skip_artificial)\n \n   /* Special case: a method taking void.  T1 will contain no\n      non-artificial fields, and T2 will contain TYPE_CODE_VOID.  */\n-  if ((TYPE_NFIELDS (t1) - start) == 0 && TYPE_NFIELDS (t2) == 1\n+  if ((t1->num_fields () - start) == 0 && t2->num_fields () == 1\n       && TYPE_FIELD_TYPE (t2, 0)->code () == TYPE_CODE_VOID)\n     return 1;\n \n-  if ((TYPE_NFIELDS (t1) - start) == TYPE_NFIELDS (t2))\n+  if ((t1->num_fields () - start) == t2->num_fields ())\n     {\n       int i;\n \n-      for (i = 0; i < TYPE_NFIELDS (t2); ++i)\n+      for (i = 0; i < t2->num_fields (); ++i)\n \t{\n \t  if (compare_ranks (rank_one_type (TYPE_FIELD_TYPE (t1, start + i),\n \t\t\t\t\t    TYPE_FIELD_TYPE (t2, i), NULL),\n@@ -3293,7 +3293,7 @@ value_struct_elt_for_reference (struct type *domain, int offset,\n     error (_(\"Internal error: non-aggregate type \"\n \t     \"to value_struct_elt_for_reference\"));\n \n-  for (i = TYPE_NFIELDS (t) - 1; i >= TYPE_N_BASECLASSES (t); i--)\n+  for (i = t->num_fields () - 1; i >= TYPE_N_BASECLASSES (t); i--)\n     {\n       const char *t_field_name = TYPE_FIELD_NAME (t, i);\n "
    },
    {
      "sha": "17d091d613117857afa36923eedc2d73854e92f2",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f704f761b34e145f5eabdc222301ce6e9ec9102/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=1f704f761b34e145f5eabdc222301ce6e9ec9102",
      "patch": "@@ -587,7 +587,7 @@ generic_val_print_enum_1 (struct type *type, LONGEST val,\n   unsigned int i;\n   unsigned int len;\n \n-  len = TYPE_NFIELDS (type);\n+  len = type->num_fields ();\n   for (i = 0; i < len; i++)\n     {\n       QUIT;\n@@ -1135,7 +1135,7 @@ val_print_type_code_flags (struct type *type, struct value *original_value,\n   const gdb_byte *valaddr = (value_contents_for_printing (original_value)\n \t\t\t     + embedded_offset);\n   ULONGEST val = unpack_long (type, valaddr);\n-  int field, nfields = TYPE_NFIELDS (type);\n+  int field, nfields = type->num_fields ();\n   struct gdbarch *gdbarch = get_type_arch (type);\n   struct type *bool_type = builtin_type (gdbarch)->builtin_bool;\n "
    }
  ]
}