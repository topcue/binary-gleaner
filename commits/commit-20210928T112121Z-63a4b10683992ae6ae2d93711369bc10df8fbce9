{
  "sha": "63a4b10683992ae6ae2d93711369bc10df8fbce9",
  "node_id": "C_kwDOANOeidoAKDYzYTRiMTA2ODM5OTJhZTZhZTJkOTM3MTEzNjliYzEwZGY4ZmJjZTk",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-08-12T09:14:50Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-09-28T11:21:21Z"
    },
    "message": "Copy in libbacktrace from gcc\n\nThis copies in libbacktrace from the gcc repository as it was in the\ncommit 62e420293a293608f383d9b9c7f2debd666e9fc9.  GDB is going to\nstart using this library soon.\n\nA dependency between GDB and libbacktrace has already been added to\nthe top level Makefile, so, after this commit, when building GDB,\nlibbacktrace will be built first.  However, libbacktrace is not yet\nlinked into GDB, or used by GDB in any way.\n\nIt is possible to stop libbacktrace being built by configuring the\ntree with --disable-libbacktrace.\n\nThis commit does NOT update src-release.sh, that will be done in the\nnext commit, this commit ONLY imports libbacktrace from gcc.  This\nmeans that if you try to make a release of GDB from exactly this\ncommit then the release tar file will not include libbacktrace.\nHowever, as libbacktrace is an optional dependency this is fine.",
    "tree": {
      "sha": "20dc03cda5cf230928b0e53766f7245baf3ae0e6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/20dc03cda5cf230928b0e53766f7245baf3ae0e6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/63a4b10683992ae6ae2d93711369bc10df8fbce9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/63a4b10683992ae6ae2d93711369bc10df8fbce9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/63a4b10683992ae6ae2d93711369bc10df8fbce9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/63a4b10683992ae6ae2d93711369bc10df8fbce9/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fbe3443dcfbc9fc47394a171ec7bd5a9f7a7231c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fbe3443dcfbc9fc47394a171ec7bd5a9f7a7231c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fbe3443dcfbc9fc47394a171ec7bd5a9f7a7231c"
    }
  ],
  "stats": {
    "total": 42239,
    "additions": 42239,
    "deletions": 0
  },
  "files": [
    {
      "sha": "dc986b9370efc6063495463ee493bbaa0cb6bb28",
      "filename": "libbacktrace/ChangeLog",
      "status": "added",
      "additions": 1774,
      "deletions": 0,
      "changes": 1774,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/ChangeLog?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,1774 @@\n+2021-08-13  Sergei Trofimovich  <siarheit@google.com>\n+\n+\t* install-debuginfo-for-buildid.sh.in: Force non-localized readelf\n+\toutput with LANG=C.\n+\n+2021-06-28  Cl\u00e9ment Chigot  <clement.chigot@atos.net>\n+\n+\t* xcoff.c (SSUBTYP_DWRNGES): New define.\n+\t(xcoff_add): Use correct XCOFF DWARF section subtype\n+\tfor DEBUG_RANGES. Remove lineoff workaround.\n+\tAdjust base_address.\n+\t(xcoff_initialize_syminfo): Adapt to new base_address.\n+\t(xcoff_lookup_pc): Likewise.\n+\t(xcoff_initialize_fileline): Likewise.\n+\n+2021-05-03  H.J. Lu  <hjl.tools@gmail.com>\n+\n+\tPR bootstrap/99703\n+\t* configure: Regenerated.\n+\n+2021-03-03  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* dwarf.c (read_line_program): Don't special case file 0.\n+\t(read_function_entry): Likewise.\n+\n+2021-03-02  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/98818\n+\t* dwarf.c (dwarf_buf_error): Add errnum parameter.  Change all\n+\tcallers.\n+\t* backtrace.h: Update backtrace_error_callback comment.\n+\n+2021-02-12  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* configure.ac: Check for objcopy --add-gnu-debuglink by using\n+\tobjcopy --help.\n+\t* configure: Regenerate\n+\n+2021-01-18  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (%_dwz): If dwz fails, use uncompressed debug info.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n+\n+2021-01-18  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR debug/98716\n+\t* dwarf.c (read_v2_paths): Allocate zero entry for dirs and\n+\tfilenames.\n+\t(read_line_program): Remove parameter u, change caller.  Don't\n+\tsubtract one from dirs and filenames index.\n+\t(read_function_entry): Don't subtract one from filenames index.\n+\n+2021-01-05  Samuel Thibault  <samuel.thibault@ens-lyon.org>\n+\n+\t* configure: Re-generate.\n+\n+2020-12-05  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR target/97865\n+\t* configure: Regenerate.\n+\n+2020-12-02  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* dwarf.c (resolve_string): Use > rather than >= to check whether\n+\tstring index extends past buffer.\n+\t(resolve_addr_index): Similarly for address index.\n+\n+2020-11-29  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* configure: Regenerate.\n+\n+2020-10-20  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* internal.h (ATTRIBUTE_FALLTHROUGH): Define.\n+\t* elf.c (elf_zlib_inflate): Use ATTRIBUTE_FALLTHROUGH.\n+\n+2020-09-28  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/97082\n+\t* Makefile.am (check_DATA): Add mtest.dSYM if USE_DSYMUTIL.\n+\t* Makefile.in: Regenerate.\n+\n+2020-09-28  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/97227\n+\t* configure.ac (USE_DSYMUTIL): Define instead of HAVE_DSYMUTIL.\n+\t* Makefile.am: Change all uses of HAVE_DSYMUTIL to USE_DSYMUTIL.\n+\t* configure: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\n+2020-09-23  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* dwarf.c (report_inlined_functions): Handle PC == -1 and PC ==\n+\tp->low.\n+\t(dwarf_lookup_pc): Likewise.\n+\n+2020-09-17  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/97080\n+\t* fileline.c (backtrace_syminfo_to_full_callback): New function.\n+\t(backtrace_syminfo_to_full_error_callback): New function.\n+\t* elf.c (elf_nodebug): Call syminfo_fn if possible.\n+\t* internal.h (struct backtrace_call_full): Define.\n+\t(backtrace_syminfo_to_full_callback): Declare.\n+\t(backtrace_syminfo_to_full_error_callback): Declare.\n+\t* mtest.c (f3): Only check all[i] if data.index permits.\n+\n+2020-09-16  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\t* macho.c (MACH_O_CPU_TYPE_PPC): New.\n+\t(MACH_O_CPU_TYPE_PPC64): New.\n+\tAdd compile-tests for powerpc to the Mach-O variants.\n+\n+2020-09-14  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/93608\n+\tAdd support for MiniDebugInfo.\n+\t* elf.c (struct elf_view): Define.  Replace most uses of\n+\tbacktrace_view with elf_view.\n+\t(elf_get_view): New static functions.  Replace most calls of\n+\tbacktrace_get_view with elf_get_view.\n+\t(elf_release_view): New static functions.  Replace most calls of\n+\tbacktrace_release_view with elf_release_view.\n+\t(elf_uncompress_failed): Rename from elf_zlib_failed.  Change all\n+\tcallers.\n+\t(LZMA_STATES, LZMA_POS_STATES, LZMA_DIST_STATES): Define.\n+\t(LZMA_DIST_SLOTS, LZMA_DIST_MODEL_START): Define.\n+\t(LZMA_DIST_MODEL_END, LZMA_FULL_DISTANCES): Define.\n+\t(LZMA_ALIGN_SIZE, LZMA_LEN_LOW_SYMBOLS): Define.\n+\t(LZMA_LEN_MID_SYMBOLS, LZMA_LEN_HIGH_SYMBOLS): Define.\n+\t(LZMA_LITERAL_CODERS_MAX, LZMA_LITERAL_CODER_SIZE): Define.\n+\t(LZMA_PROB_IS_MATCH_LEN, LZMA_PROB_IS_REP_LEN): Define.\n+\t(LZMA_PROB_IS_REP0_LEN, LZMA_PROB_IS_REP1_LEN): Define.\n+\t(LZMA_PROB_IS_REP2_LEN, LZMA_PROB_IS_REP0_LONG_LEN): Define.\n+\t(LZMA_PROB_DIST_SLOT_LEN, LZMA_PROB_DIST_SPECIAL_LEN): Define.\n+\t(LZMA_PROB_DIST_ALIGN_LEN): Define.\n+\t(LZMA_PROB_MATCH_LEN_CHOICE_LEN): Define.\n+\t(LZMA_PROB_MATCH_LEN_CHOICE2_LEN): Define.\n+\t(LZMA_PROB_MATCH_LEN_LOW_LEN): Define.\n+\t(LZMA_PROB_MATCH_LEN_MID_LEN): Define.\n+\t(LZMA_PROB_MATCH_LEN_HIGH_LEN): Define.\n+\t(LZMA_PROB_REP_LEN_CHOICE_LEN): Define.\n+\t(LZMA_PROB_REP_LEN_CHOICE2_LEN): Define.\n+\t(LZMA_PROB_REP_LEN_LOW_LEN): Define.\n+\t(LZMA_PROB_REP_LEN_MID_LEN): Define.\n+\t(LZMA_PROB_REP_LEN_HIGH_LEN): Define.\n+\t(LZMA_PROB_LITERAL_LEN): Define.\n+\t(LZMA_PROB_IS_MATCH_OFFSET, LZMA_PROB_IS_REP_OFFSET): Define.\n+\t(LZMA_PROB_IS_REP0_OFFSET, LZMA_PROB_IS_REP1_OFFSET): Define.\n+\t(LZMA_PROB_IS_REP2_OFFSET): Define.\n+\t(LZMA_PROB_IS_REP0_LONG_OFFSET): Define.\n+\t(LZMA_PROB_DIST_SLOT_OFFSET): Define.\n+\t(LZMA_PROB_DIST_SPECIAL_OFFSET): Define.\n+\t(LZMA_PROB_DIST_ALIGN_OFFSET): Define.\n+\t(LZMA_PROB_MATCH_LEN_CHOICE_OFFSET): Define.\n+\t(LZMA_PROB_MATCH_LEN_CHOICE2_OFFSET): Define.\n+\t(LZMA_PROB_MATCH_LEN_LOW_OFFSET): Define.\n+\t(LZMA_PROB_MATCH_LEN_MID_OFFSET): Define.\n+\t(LZMA_PROB_MATCH_LEN_HIGH_OFFSET): Define.\n+\t(LZMA_PROB_REP_LEN_CHOICE_OFFSET): Define.\n+\t(LZMA_PROB_REP_LEN_CHOICE2_OFFSET): Define.\n+\t(LZMA_PROB_REP_LEN_LOW_OFFSET): Define.\n+\t(LZMA_PROB_REP_LEN_MID_OFFSET): Define.\n+\t(LZMA_PROB_REP_LEN_HIGH_OFFSET): Define.\n+\t(LZMA_PROB_LITERAL_OFFSET): Define.\n+\t(LZMA_PROB_TOTAL_COUNT): Define.\n+\t(LZMA_IS_MATCH, LZMA_IS_REP, LZMA_IS_REP0): Define.\n+\t(LZMA_IS_REP1, LZMA_IS_REP2, LZMA_IS_REP0_LONG): Define.\n+\t(LZMA_DIST_SLOT, LZMA_DIST_SPECIAL, LZMA_DIST_ALIGN): Define.\n+\t(LZMA_MATCH_LEN_CHOICE, LZMA_MATCH_LEN_CHOICE2): Define.\n+\t(LZMA_MATCH_LEN_LOW, LZMA_MATCH_LEN_MID): Define.\n+\t(LZMA_MATCH_LEN_HIGH, LZMA_REP_LEN_CHOICE): Define.\n+\t(LZMA_REP_LEN_CHOICE2, LZMA_REP_LEN_LOW): Define.\n+\t(LZMA_REP_LEN_MID, LZMA_REP_LEN_HIGH, LZMA_LITERAL): Define.\n+\t(elf_lzma_varint): New static function.\n+\t(elf_lzma_range_normalize): New static function.\n+\t(elf_lzma_bit, elf_lzma_integer): New static functions.\n+\t(elf_lzma_reverse_integer): New static function.\n+\t(elf_lzma_len, elf_uncompress_lzma_block): New static functions.\n+\t(elf_uncompress_lzma): New static function.\n+\t(backtrace_uncompress_lzma): New function.\n+\t(elf_add): Add memory and memory_size parameters.  Change all\n+\tcallers.  Look for .gnu_debugdata section, and, if found,\n+\tdecompress it and use it for symbols and debug info.  Permit the\n+\tdescriptor parameter to be -1.\n+\t* internal.h (backtrace_uncompress_lzma): Declare.\n+\t* mtest.c: New file.\n+\t* xztest.c: New file.\n+\t* configure.ac: Check for nm, xz, and comm programs.  Check for\n+\tliblzma library.\n+\t(HAVE_MINIDEBUG): Define.\n+\t* Makefile.am (mtest_SOURCES): Define.\n+\t(mtest_CFLAGS, mtest_LDADD): Define.\n+\t(TESTS): Add mtest_minidebug if HAVE_MINIDEBUG.\n+\t(%_minidebug): New pattern rule, if HAVE_MINIDEBUG.\n+\t(xztest_SOURCES, xztest_CFLAGS, xztest_LDADD): Define.\n+\t(xztest_alloc_SOURCES, xztest_alloc_CFLAGS): Define\n+\t(xztest_alloc_LDADD): Define.\n+\t(BUILDTESTS): Add mtest, xztest, xztest_alloc.\n+\t(CLEANFILES): Add files created by minidebug pattern.\n+\t(btest.lo): Correct INCDIR reference.\n+\t(mtest.lo, xztest.lo, ztest.lo): New targets.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\n+2020-09-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* pecoff.c (coff_initialize_syminfo): Add is_64 parameter.\n+\t(coff_add): Determine and pass is_64.\n+\n+2020-09-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/96973\n+\t* fileline.c (macho_get_executable_path): New static function.\n+\t(fileline_initialize): Call macho_get_executable_path.\n+\n+2020-09-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* dwarf.c (function_addrs_search): Compare against the next entry\n+\tlow address, not the high address.\n+\t(unit_addrs_search): Likewise.\n+\t(build_address_map): Add a trailing unit_addrs.\n+\t(read_function_entry): Add a trailing function_addrs.\n+\t(read_function_info): Likewise.\n+\t(report_inlined_functions): Search backward for function_addrs\n+\tmatch.\n+\t(dwarf_lookup_pc): Search backward for unit_addrs and\n+\tfunction_addrs matches.\n+\n+2020-09-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* simple.c (simple_unwind): Correct comment spelling.\n+\n+2020-09-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* macho.c (macho_add_dsym): Make space for '/' in dsym.  Use\n+\tcorrect length when freeing diralc.\n+\n+2020-09-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/96973\n+\t* macho.c (macho_add_fat): Correctly swap 32-bit file offset.\n+\n+2020-09-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/96971\n+\t* filetype.awk: Only match magic number at start of line.\n+\n+2020-08-24  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* macho.c (MACH_O_MH_MAGIC_FAT_64): Define.\n+\t(MACH_O_MH_CIGAM_FAT_64): Define.\n+\t(struct macho_fat_arch_64): Define.\n+\t(macho_add_fat): Add and use is_64 parameter.\n+\t(macho_add): Recognize 64-bit fat files.\n+\n+2020-07-30  H.J. Lu  <hjl.tools@gmail.com>\n+\n+\tPR bootstrap/96202\n+\t* configure: Regenerated.\n+\n+2020-07-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* configure.ac: Test linker support for DWARF5\n+\t* configure: Regenerate\n+\n+2020-05-29  H.J. Lu  <hjl.tools@gmail.com>\n+\n+\tPR bootstrap/95413\n+\t* configure: Regenerated.\n+\n+2020-05-15  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR bootstrap/95147\n+\t* configure: Regenerated.\n+\n+2020-05-14  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* configure: Regenerated.\n+\n+2020-05-13  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* ztest.c (test_large): Mark state ATTRIBUTE_UNUSED.\n+\n+2020-05-13  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR go/95061\n+\t* posix.c (backtrace_open): Treat EACCESS like ENOENT.\n+\n+2020-05-12  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* Makefile.am (AM_CFLAGS): Add $(CET_HOST_FLAGS).\n+\t* configure.ac: Add GCC_CET_HOST_FLAGS(CET_HOST_FLAGS) and\n+\tAC_SUBST(CET_HOST_FLAGS).  Clear CET_HOST_FLAGS if jit isn't\n+\tenabled.\n+\t* Makefile.in: Regenerated.\n+\t* configure: Likewise.\n+\n+2020-05-11  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/95012\n+\t* configure.ac: Check for getpagesize declaration.\n+\t* mmap.c: Declare getpagesize if necessary.\n+\t* mmapio.c: Likewise.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\n+2020-05-09  Roland McGrath  <mcgrathr@google.com>\n+\n+\t* elf.c (elf_add): Bail early if there are no section headers at all.\n+\n+2020-05-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* elf.c (elf_add): Don't free strtab if an error occurs after\n+\trecording symbol information.\n+\n+2020-05-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/88745\n+\t* macho.c: New file.\n+\t* filetype.awk: Recognize Mach-O files.\n+\t* Makefile.am (FORMAT_FILES): Add macho.c.\n+\t(check_DATA): New variable.  Set to .dSYM if HAVE_DSYMUTIL.\n+\t(%.dSYM): New pattern target.\n+\t(test_macho_SOURCES, test_macho_CFLAGS): New targets.\n+\t(test_macho_LDADD): New target.\n+\t(BUILDTESTS): Add test_macho.\n+\t(macho.lo): Add dependencies.\n+\t* configure.ac: Recognize macho file type.  Check for\n+\tmach-o/dyld.h.  Don't try to run objcopy if we don't find it.\n+\tLook for dsymutil and define a HAVE_DSYMUTIL conditional.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\n+2020-05-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* read.c (backtrace_get_view): Support short read.\n+\n+2020-05-09  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* elf.c (elf_add): If debug sections are very large or far apart,\n+\tread them individually rather than as a single view.\n+\n+2020-05-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* fileline.c (sysctl_exec_name): New static function.\n+\t(sysctl_exec_name1): New macro or static function.\n+\t(sysctl_exec_name2): Likewise.\n+\t(fileline_initialize): Try sysctl_exec_name[12].\n+\t* configure.ac: Check for sysctl args to fetch executable name.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\n+2020-02-15  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* ztest.c (test_large): Update file to current libgo test file.\n+\n+2020-02-03  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (libbacktrace_TEST_CFLAGS): Define.\n+\t(test_elf32_CFLAGS): Use $(libbacktrace_test_CFLAGS).\n+\t(test_elf_64_CFLAGS, test_xcoff_32_CFLAGS): Likewise.\n+\t(test_xcoff_64_CFLAGS, test_pecoff_CFLAGS): Likewise.\n+\t(test_unknown_CFLAGS, unittest_CFLAGS): Likewise.\n+\t(unittest_alloc_CFLAGS, allocfail_CFLAGS): Likewise.\n+\t(b2test_CFLAGS, b3test_CFLAGS, btest_CFLAGS): Likewise.\n+\t(btest_lto_CFLAGS, btest_alloc_CFLAGS, stest_CFLAGS): Likewise.\n+\t(stest_alloc_CFLAGS): Likewise.\n+\t* Makefile.in: Regenerate.\n+\t* ztest.c (error_callback_compress): Mark vdata unused.\n+\t(test_large): Add casts to avoid warnings.\n+\n+2020-01-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tUpdate copyright years.\n+\n+2019-12-13  Ian Lance Taylor  <iant@golang.org>\n+\n+\tAdd DWARF 5 support.\n+\t* dwarf.c (struct attr): Add val field.\n+\t(enum attr_val_encoding): Add ATTR_VAL_ADDDRESS_INDEX,\n+\tATTR_VAL_STRING_INDEX, ATTR_VAL_RNGLISTS_INDEX.\n+\t(struct line_header): Add addrsize field.\n+\t(struct line_header_format): Define.\n+\t(struct unit): Add str_offsets_base, addr_base, and rnglists_base\n+\tfields.\n+\t(read_uint24): New static function.\n+\t(read_attribute): Add implicit_val parameter.  Replace dwarf_str\n+\tand dwarf_str_size parameters with dwarf_sections parameter.  Add\n+\tsupport for new DWARF 5 forms.  Change all callers.\n+\t(resolve_string): New static function.\n+\t(resolve_addr_index): Likewise.\n+\t(read_abbrevs): Support DW_FORM_implicit_const.\n+\t(struct pcrange): Add lowpc_is_addr_index, highpc_is_addr_Index,\n+\tand ranges_is_index fields.\n+\t(update_pcrange): Support DWARF 5 encodings.\n+\t(add_high_low_range): New static function, split out of\n+\tadd_ranges.\n+\t(add_ranges_from_ranges): Likewise.\n+\t(add_ranges_from_rnglists): New static function.\n+\t(add_ranges): Just call new helper functions.\n+\t(find_address_ranges): Use resolve_string for strings, after\n+\treading all attributes.  Handle new DWARF 5 attributes.\n+\t(build_address_map): Support DWARF 5 compilation units.\n+\t(read_v2_paths): New static function, split out of\n+\tread_line_header.\n+\t(read_lnct): New static\tfunction.\n+\t(read_line_header_format_entries): Likewise.\n+\t(read_line_header): Add ddata parameter.  Support DWARF 5 line\n+\theaders.  Call new helper functions.  Change all callers.\n+\t(read_line_program): Use addrsize from line program header.  Don't\n+\tspecial case directory index 0 for DWARF 5.\n+\t(read_referenced_name): Use resolve_string.\n+\t(read_function_entry): Handle DWARF 5 encodings.  Use\n+\tresolve_string.\n+\t* internal.h (enum dwarf_section): Add DEBUG_ADDR,\n+\tDEBUG_STR_OFFSETS, DEBUG_LINE_STR, DEBUG_RNGLISTS.\n+\t* elf.c (dwarf_section_names): Add new section names.\n+\t* pecoff.c (dwarf_section_names): Likewise.\n+\t* xcoff.c (xcoff_add): Clear dwarf_sections before setting\n+\tfields.\n+\t* configure.ac: Define HAVE_DWARF5 automake conditional.\n+\t* Makefile.am (dwarf5_SOURCES): New variable if HAVE_DWARF5.\n+\t(dwarf5_CFLAGS, dwarf5_LDADD): Likewise.\n+\t(dwarf5_alloc_SOURCES, dwarf5_alloc_CFLAGS): Likewise.\n+\t(dwarf5_alloc_LDADD): Likewise.\n+\t(BUILDTESTS): Add dwarf5 tests if HAVE_DWARF5.\n+\t(CLEANFILES, clean-local): Define.\n+\n+2019-12-08  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* dwarf.c (struct pcrange): Define.\n+\t(update_pcrange, add_ranges): New static functions.\n+\t(add_unit_addr): Change signature to work with add_ranges.  Don't\n+\tadd base_address here.\n+\t(add_unit_ranges): Remove.\n+\t(find_address_ranges): Replace str/ranges parameters with\n+\tdwarf_sections.  Use update_pcrange and add_ranges.  Change all\n+\tcallers.\n+\t(add_function_range): Change signature to work with add_ranges.\n+\tDon't add base_address here.\n+\t(add_function_ranges): Remove.\n+\t(read_function_entry): Use update_pcrange and add_ranges.\n+\n+2019-12-04  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* edtest.c (test1): Add noclone attribute.\n+\n+2019-12-04  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* internal.h (enum dwarf_section): Define.\n+\t(struct dwarf_sections): Define.\n+\t(backtrace_dwarf_add): Update declaration to replace specific\n+\tsection parameters with dwarf_sections parameter.\n+\t* dwarf.c (struct dwarf_data): Replace specific section fields\n+\twith dwarf_sections field.\n+\t(read_attribute): Use dwarf_sections with altlink.\n+\t(build_address_map): Replace specific section parameters with\n+\tdwarf_sections parameter.  Change all callers.\n+\t(read_line_info): Use dwarf_sections with ddata.\n+\t(read_referenced_name): Likewise.\n+\t(add_function_ranges): Likewise.\n+\t(read_function_entry): Likewise.\n+\t(read_function_info): Likewise.\n+\t(build_dwarf_data): Replace specific section parameters with\n+\tdwarf_sections parameter.  Change all callers.\n+\t(backtrace_dwarf_add): Likewise.\n+\t* elf.c (enum debug_section): Remove.\n+\t(dwarf_section_names): Remove .zdebug names.\n+\t(elf_add): Track zsections separately.  Build dwarf_sections.\n+\t* pecoff.c (enum debug_section): Remove.\n+\t(struct debug_section_info): Remove data field.\n+\t(coff_add): Build dwarf_sections.\n+\t* xcoff.c (enum dwarf_section): Remove.  Replace DWSECT_xxx\n+\treferences with DEBUG_xxx references.\n+\t(xcoff_add): Build dwarf_sections.\n+\n+2019-09-27  Maciej W. Rozycki  <macro@wdc.com>\n+\n+\t* configure: Regenerate.\n+\n+2019-09-26  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/91908\n+\t* pecoff.c (backtrace_initialize): Explicitly cast unchecked\n+\t__sync_bool_compare_and_swap to void.\n+\t* xcoff.c (backtrace_initialize): Likewise.\n+\n+2019-09-03  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* configure.ac: Remove references to spu.\n+\t* configure: Regenerate.\n+\n+2019-05-24  Clement Chigot  <clement.chigot@atos.net>\n+\n+\t* Makefile.am (BUILDTESTS): Remove test_elf, add test_elf_32 and\n+\ttest_elf_64.\n+\t* Makefile.in: Regenerate.\n+\n+2019-05-14  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* configure.ac (have_dl_iterate_phdr): Remove *-*-solaris2.10*\n+\thandling.\n+\t* configure: Regenerate.\n+\n+2019-03-11  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/89669\n+\t* Makefile.am (BUILDTESTS): Only add ztest and ztest_alloc if\n+\tHAVE_ELF.\n+\t* Makefile.in: Regenerate.\n+\n+2019-02-26  Tom de Vries  <tdevries@suse.de>\n+\n+\t* btest.c (test5): Allow global.* as minimal symbol name for global.\n+\n+2019-02-26  Tom de Vries  <tdevries@suse.de>\n+\n+\t* Makefile.am (TESTS): Only add b3test_dwz_buildid if HAVE_DWZ.\n+\t* Makefile.in: Regenerate.\n+\n+2019-02-12  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR libbacktrace/81983\n+\t* dwarf.c (dwarf_lookup_pc): Don't call bsearch if nmemb == 0.\n+\n+2019-02-10  Tom de Vries  <tdevries@suse.de>\n+\n+\t* Makefile.am (BUILDTESTS): Add btest_lto.\n+\t* Makefile.in: Regenerate.\n+\t* btest.c (test1, f2, f3, test3, f22, f23): Declare with\n+\t__attribute__((noclone)).\n+\n+2019-02-08  Tom de Vries  <tdevries@suse.de>\n+\n+\t* backtrace.c (backtrace_full): Declare with __attribute__((noinline)).\n+\t* print.c (backtrace_print): Same.\n+\t* simple.c (backtrace_simple): Same.\n+\n+2019-02-08  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR libbacktrace/78063\n+\t* dwarf.c (build_address_map): Keep all parsed units.\n+\t(read_referenced_name_from_attr): Handle DW_FORM_ref_addr.\n+\n+2019-01-31  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR libbacktrace/89136\n+\t* elf.c (elf_add): Read build-id if with_buildid_data.  Fix\n+\t'debugaltlink_name_len =+ 1'.\n+\n+2019-01-29  Tom de Vries  <tdevries@suse.de>\n+\n+\t* install-debuginfo-for-buildid.sh.in: New script.\n+\t* Makefile.am (check_PROGRAMS): Add b2test and b3test.\n+\t(TESTS): Add b2test_buildid and b3test_dwz_buildid.\n+\t* Makefile.in: Regenerate.\n+\t* configure.ac (HAVE_ELF): Set with AM_CONDITIONAL.\n+\t(READELF): Set with AC_CHECK_PROG.\n+\t(install-debuginfo-for-buildid.sh): Generate with AC_CONFIG_FILES.\n+\t* configure: Regenerate.\n+\t* elf.c (SYSTEM_BUILD_ID_DIR): Factor out of ...\n+\t(elf_open_debugfile_by_buildid): ... here.\n+\n+2019-01-29  Tom de Vries  <tdevries@suse.de>\n+\n+\t* Makefile.am: Replace check_PROGRAMS with BUILDTESTS, except for\n+\tallocfail.\n+\t(TESTS): Don't add check_PROGRAMS. Add BUILDTESTS.\n+\t(check_PROGRAMS): Add BUILDTESTS.\n+\t* Makefile.in: Regenerate.\n+\n+2019-01-28  Tom de Vries  <tdevries@suse.de>\n+\n+\t* Makefile.am (xcoff_%.c): Generate sed result into temporary file.\n+\tUse $< to access prerequisite.\n+\t* Makefile.in: Regenerate.\n+\n+2019-01-25  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* elf.c (elf_add): Pass \"\" filename to recursive call with\n+\tseparated debug.\n+\n+2019-01-25  Tom de Vries  <tdevries@suse.de>\n+\n+\t* elf.c (elf_add): When handling .gnu_debugaltlink, call elf_add with\n+\tfilename == \"\".\n+\t* Makefile.am (TESTS): Add btest_dwz_gnudebuglink.\n+\t* Makefile.in: Regenerate.\n+\n+2019-01-25  Tom de Vries  <tdevries@suse.de>\n+\n+\t* Makefile.am: Rewrite dtest rule into \"%_gnudebuglink\" pattern rule.\n+\t(TESTS): Rename dtest to btest_gnudebuglink.\n+\t* Makefile.in: Regenerate.\n+\n+2019-01-23  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (struct unit): Use size_t for low_offset/high_offset fields.\n+\t(units_search, find_unit): Use size_t for offset.\n+\t(build_address_map): Use size_t for unit_offset.\n+\n+2019-01-20  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* allocfail.c (main): Increase portability of printf statement.\n+\n+2019-01-18  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/88890\n+\t* mmapio.c (backtrace_get_view): Change size parameter to\n+\tuint64_t.  Check that value fits in size_t.\n+\t* read.c (backtrace_get_view): Likewise.\n+\t* internal.h (backtrace_get_view): Update declaration.\n+\t* elf.c (elf_add): Pass shstrhdr->sh_size to backtrace_get_view.\n+\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR libbacktrace/82857\n+\t* configure.ac (DWZ): Set with AC_CHECK_PROG.\n+\t(HAVE_DWZ): Set with AM_CONDITIONAL.\n+\t* configure: Regenerate.\n+\t* Makefile.am (TESTS): Add btest_dwz.\n+\t* Makefile.in: Regenerate.\n+\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR libbacktrace/82857\n+\t* dwarf.c (enum attr_val_encoding): Add ATTR_VAL_REF_ALT_INFO.\n+\t(read_attribute): Handle DW_FORM_GNU_ref_alt using\n+\tATTR_VAL_REF_ALT_INFO.\n+\t(read_referenced_name_from_attr): Handle DW_FORM_GNU_ref_alt.\n+\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (struct unit): Add low_offset and high_offset fields.\n+\t(struct unit_vector): New type.\n+\t(struct dwarf_data): Add units and units_counts fields.\n+\t(find_unit): New function.\n+\t(find_address_ranges): Add and handle unit_tag parameter.\n+\t(build_address_map): Add and handle units_vec parameter.\n+\t(build_dwarf_data): Pass units_vec to build_address_map.  Store resulting\n+\tunits vector.\n+\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR libbacktrace/82857\n+\t* dwarf.c (read_attribute): Handle DW_FORM_GNU_strp_alt\n+\tusing altlink.\n+\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (enum attr_val_encoding): Add ATTR_VAL_NONE.\n+\t(read_attribute): Add altlink parameter.  Handle missing altlink for\n+\tDW_FORM_GNU_strp_alt and DW_FORM_GNU_ref_alt.\n+\t(find_address_ranges, build_address_map, build_dwarf_data): Add and\n+\thandle altlink parameter.\n+\t(read_referenced_name, read_function_entry): Add argument to\n+\tread_attribute call.\n+\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (struct dwarf_data): Add altlink field.\n+\t(backtrace_dwarf_add): Add and handle fileline_altlink parameter.\n+\t* elf.c\t(elf_add): Add argument to backtrace_dwarf_add call.\n+\t(phdr_callback, backtrace_initialize): Add argument to elf_add calls.\n+\t* internal.h (backtrace_dwarf_add): Add fileline_altlink parameter.\n+\t* pecoff.c (coff_add): Add argument to backtrace_dwarf_add call.\n+\t* xcoff.c (xcoff_add): Same.\n+\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\t* internal.h (backtrace_dwarf_add): Add fileline_entry parameter.\n+\t* dwarf.c (backtrace_dwarf_add): Add and handle fileline_entry parameter.\n+\t* elf.c\t(elf_add): Add and handle fileline_entry parameter.  Add\n+\targument to backtrace_dwarf_add call.\n+\t(phdr_callback, backtrace_initialize): Add argument to elf_add calls.\n+\t* pecoff.c (coff_add): Add argument to backtrace_dwarf_add call.\n+\t* xcoff.c (xcoff_add): Same.\n+\n+2019-01-17  Tom de Vries  <tdevries@suse.de>\n+\n+\t* elf.c (elf_add): Add and handle with_buildid_data and\n+\twith_buildid_size parameters.  Handle .gnu_debugaltlink section.\n+\t(phdr_callback, backtrace_initialize): Add arguments to elf_add calls.\n+\n+2019-01-16  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (read_referenced_name_from_attr): New function.  Factor out\n+\tof ...\n+ \t(read_referenced_name): ... here, and ...\n+\t(read_function_entry): ... here.\n+\n+2019-01-16  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (read_referenced_name): Don't allow DW_AT_name to override any\n+\tname.\n+\t(read_function_entry): Same.  Don't allow name found via\n+\tDW_AT_abstract_origin or case DW_AT_specification to override linkage\n+\tname.\n+\n+2019-01-09  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\tPR other/16615\n+\n+\t* backtrace.h: Mechanically replace \"can not\" with \"cannot\".\n+\n+2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tUpdate copyright years.\n+\n+2018-12-29  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* Makefile.am (xcoff_%.c): Use an actual newline instead of \\n\n+\tin sed pattern.\n+\t* Makefile.in: Regenerate.\n+\n+2018-12-28  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (build_address_map): Reuse unused units.\n+\n+2018-12-28  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (build_address_map): Simplify by removing local variable\n+\tabbrevs.\n+\n+2018-12-28  Ian Lance Taylor  <iant@golang.org>\n+\t    Tom de Vries  <tdevries@suse.de>\n+\n+\tPR libbacktrace/88063\n+\t* dwarf.c (free_unit_addrs_vector): Remove.\n+\t(build_address_map): Keep track of allocated units in vector.  Free\n+\tallocated units and corresponding abbrevs upon failure.  Remove now\n+\tredundant call to free_unit_addrs_vector.  Free addrs vector upon\n+\tfailure.  Free allocated unit vector.\n+\n+2018-12-28  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (build_address_map): Free addrs vector upon failure.\n+\n+2018-12-14  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR testsuite/88491\n+\t* allocfail.sh: Remove \"set -o pipefail\".\n+\n+2018-12-12  Tom de Vries  <tdevries@suse.de>\n+\n+\t* Makefile.am (TESTS): Add allocfail.sh.\n+\t(check_PROGRAMS): Add allocfail.\n+\t* Makefile.in: Regenerate.\n+\t* instrumented_alloc.c: New file.  Redefine malloc and realloc.\n+\tInclude alloc.c.\n+\t* allocfail.c: New file.\n+\t* allocfail.sh: New file.\n+\n+2018-11-30  Tom de Vries  <tdevries@suse.de>\n+\n+\t* Makefile.am (check_PROGRAMS): Add test_elf, test_xcoff_32,\n+\ttest_xcoff_64, test_pecoff and test_unknown.\n+\t* Makefile.in: Regenerate.\n+\t* test_format.c: New file.\n+\n+2018-11-30  Tom de Vries  <tdevries@suse.de>\n+\n+\t* Makefile.am : Add _with_alloc version for each test in\n+\tcheck_PROGRAMS.\n+\t* Makefile.in: Regenerate.\n+\n+2018-11-30  Tom de Vries  <tdevries@suse.de>\n+\n+\t* internal.h (backtrace_vector_free): New static inline fuction,\n+\tfactored out of ...\n+\t* dwarf.c (read_line_info): ... here.\n+\n+2018-11-28  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (read_abbrevs): Fix handling of abbrevs->abbrevs allocation\n+\tfailure.\n+\n+2018-11-27  Tom de Vries  <tdevries@suse.de>\n+\n+\t* mmap.c (backtrace_vector_release): Same.\n+\t* unittest.c (test1): Add check.\n+\n+2018-11-27  Tom de Vries  <tdevries@suse.de>\n+\n+\t* alloc.c (backtrace_vector_release): Handle vec->size == 0 using free\n+\tinstead of realloc.\n+\t* Makefile.am (check_PROGRAMS): Add unittest.\n+\t* Makefile.in: Regenerate.\n+\t* unittest.c: New file.\n+\n+2018-11-22  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (read_initial_length): Factor out of ...\n+\t(build_address_map, read_line_info): ... here.\n+\n+2018-11-21  Tom de Vries  <tdevries@suse.de>\n+\n+\t* dwarf.c (read_string): Factor out of ...\n+\t(read_attribute, read_line_header, read_line_program): ... here.\n+\n+2018-10-31  Joseph Myers  <joseph@codesourcery.com>\n+\n+\tPR bootstrap/82856\n+\t* Makefile.am: Include multilib.am.\n+\t* configure.ac: Remove AC_PREREQ.  Use AC_LANG_SOURCE.\n+\t* Makefile.in, aclocal.m4, config.h.in, configure: Regenerate.\n+\n+2018-10-05  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR libbacktrace/87529\n+\t* backtrace.h: Document that backtrace_create_state should be\n+\tcalled only once.\n+\n+2018-08-05 Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* configure.ac: Move define of HAVE_ZLIB into check for -lz.\n+\t* Makefile.in: Regenerate.\n+\t* config.h.in: Likewise.\n+\t* configure: Likewise.\n+\n+2018-08-01  Tony Reix  <tony.reix@atos.net>\n+\n+\t* xcoff.c (struct xcoff_line, struct xcoff_line_vector): Remove.\n+\t(struct xcoff_func, struct xcoff_func_vector): New structs.\n+\t(xcoff_syminfo): Drop leading dot from symbol name.\n+\t(xcoff_line_compare, xcoff_line_search): Remove.\n+\t(xcoff_func_compare, xcoff_func_search): New static functions.\n+\t(xcoff_lookup_pc): Search function table.\n+\t(xcoff_add_line, xcoff_process_linenos): Remove.\n+\t(xcoff_initialize_fileline): Build function table.\n+\n+2018-06-21 Denis Khalikov <d.khalikov@partner.samsung.com>\n+\n+\tPR other/86198\n+\t* elf.c (elf_add): Increase \".note.gnu.build-id\" section size\n+\tchecking up to 36 bytes.\n+\n+2018-04-24  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* configure: Regenerated.\n+\n+2018-04-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* configure: Regenerated.\n+\n+2018-04-17  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* backtrace.c: Revert last two changes.  Don't call mmap\n+\tdirectly.\n+\n+2018-04-17  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* backtrace.c: Include backtrace-supported.h before checking\n+\tBACKTRACE_USES_MALLOC.\n+\n+2018-04-17  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* backtrace.c (backtrace_full): When testing whether we can\n+\tallocate memory, call mmap directly, and munmap the memory.\n+\n+2018-04-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/85161\n+\t* elf.c (elf_zlib_fetch): Fix up predefined macro names in test for\n+\tbig endian, only use 32-bit loads if endianity macros are predefined\n+\tand indicate big or little endian.\n+\n+2018-02-14  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n+\n+\tPR target/84148\n+\t* configure: Regenerate.\n+\n+2018-02-15  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/82368\n+\t* elf.c (SHT_PROGBITS): Undefine and define.\n+\n+2018-02-14  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/82368\n+\t* elf.c (EM_PPC64, EF_PPC64_ABI): Undefine and define.\n+\t(struct elf_ppc64_opd_data): New type.\n+\t(elf_initialize_syminfo): Add opd argument, handle symbols\n+\tpointing into the PowerPC64 ELFv1 .opd section.\n+\t(elf_add): Read .opd section on PowerPC64 ELFv1, pass pointer\n+\tto structure with .opd data to elf_initialize_syminfo.\n+\n+2018-01-31  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* elf.c (elf_add): Close descriptor if we use a debugfile.\n+\t* btest.c (check_open_files): New static function.\n+\t(main): Call check_open_files.\n+\n+2018-01-25  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* elf.c (elf_open_debugfile_by_debuglink): Don't check CRC if the\n+\tdesired CRC is zero.\n+\t(elf_add): Don't clear *found_sym and *found_dwarf if debuginfo.\n+\n+2018-01-25  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* pecoff.c (coff_add): Only release syms_view if it is valid.\n+\n+2018-01-25  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* pecoff.c (coff_add): Another memcpy -> coff_read4 fix.\n+\n+2018-01-24  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* pecoff.c (coff_add): Use coff_read4, not memcpy.\n+\n+2018-01-24  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR other/68239\n+\t* mmap.c (backtrace_free_locked): Don't put more than 16 entries\n+\ton the free list.\n+\n+2018-01-19  Tony Reix  <tony.reix@atos.net>\n+\n+\t* xcoff.c (xcoff_incl_compare): New function.\n+\t(xcoff_incl_search): New function.\n+\t(xcoff_process_linenos): Use bsearch to find include file.\n+\t(xcoff_initialize_fileline): Sort include file information.\n+\n+2018-01-16  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* elf.c (codes) [GENERATE_FIXED_HUFFMAN_TABLE]: Fix size to be\n+\t288.\n+\t(main) [GENERATE_FIXED_HUFFMAN_TABLE]: Pass 288 to\n+\telf_zlib_inflate_table.  Generate elf_zlib_default_dist_table.\n+\t(elf_zlib_default_table): Update.\n+\t(elf_zlib_default_dist_table): New static array.\n+\t(elf_zlib_inflate): Use elf_zlib_default_dist_table for dist table\n+\tfor block type 1.\n+\t* ztest.c (struct zlib_test): Add uncompressed_len.\n+\t(tests): Initialize uncompressed_len field.  Add new test case.\n+\t(test_samples): Use uncompressed_len field.\n+\n+2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tUpdate copyright years.\n+\n+2017-11-17  Igor Tsimbalist  <igor.v.tsimbalist@intel.com>\n+\n+\t* configure.ac: Add CET_FLAGS to EXTRA_FLAGS.\n+\t* aclocal.m4: Regenerate.\n+\t* Makefile.in: Likewise.\n+\t* configure: Likewise.\n+\n+2017-10-06  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* ztest.c (test_large): Pass unsigned long *, not size_t *, to\n+\tzlib uncompress function.\n+\n+2017-10-05  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* elf.c (elf_zlib_fetch): Change pval argument to uint64_t *.\n+\tRead a four byte integer.\n+\t(elf_zlib_inflate): Change val to uint64_t.  Align pin to a 32-bit\n+\tboundary before ever calling elf_zlib_fetch.\n+\t* ztest.c (test_large): Simplify print statements a bit.\n+\n+2017-10-02  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* ztest.c: #include <errno.h>.\n+\t(TEST_TIMING): Don't define, don't test.\n+\t(xclock_gettime, xclockid_t): Define if !HAVE_CLOCK_GETTIME.\n+\t(clockid_t, clock_gettime, CLOCK_REALTIME): Likewise.\n+\t(ZLIB_CLOCK_GETTIME_ARG): Define.\n+\t* configure.ac: Change clock_gettime_link to CLOCK_GETTIME_LINK.\n+\t* Makefile.am: Likewise.\n+\t* configure, Makefile.in: Rebuild.\n+\n+2017-10-02  Thomas Schwinge  <thomas@codesourcery.com>\n+\n+\tPR other/67165\n+\t* Makefile.am: Append the content of clock_gettime_link to\n+\tztest_LDADD.\n+\t* configure.ac: Test for the case that clock_gettime is in librt.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Likewise.\n+\n+\tPR other/67165\n+\t* configure.ac: Check for clock_gettime.\n+\t* config.h.in: Regenerate.\n+\t* configure: Likewise.\n+\t* ztest.c (average_time, test_large): Conditionalize test timing\n+\ton clock_gettime availability.\n+\n+2017-09-29  Tony Reix  <tony.reix@atos.net>\n+\n+\t* xcoff.c: Initial support for DWARF debug sections in XCOFF.\n+\t(STYP_DWARF, SSUBTYP_DW*): Define.\n+\t(enum dwarf_section): Define.\n+\t(struct dwsect_info): Define.\n+\t(xcoff_add): Look for DWARF sections, pass them to\n+\tbacktrace_dwarf_add.\n+\n+2017-09-28  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR other/67165\n+\t* elf.c (__builtin_prefetch): Define if not __GNUC__.\n+\t(unlikely): Define.\n+\t(SHF_UNCOMPRESSED, ELFCOMPRESS_ZLIB): Define.\n+\t(b_elf_chdr): Define type.\n+\t(enum debug_section): Add ZDEBUG_xxx values.\n+\t(debug_section_names): Add names for new sections.\n+\t(struct debug_section_info): Add compressed field.\n+\t(elf_zlib_failed, elf_zlib_fetch): New static functions.\n+\t(HUFFMAN_TABLE_SIZE, HUFFMAN_VALUE_MASK): Define.\n+\t(HUFFMAN_BITS_SHIFT, HUFFMAN_BITS_MASK): Define.\n+\t(HUFFMAN_SECONDARY_SHIFT): Define.\n+\t(ZDEBUG_TABLE_SIZE): Define.\n+\t(ZDEBUG_TABLE_CODELEN_OFFSET, ZDEBUG_TABLE_WORK_OFFSET): Define.\n+\t(final_next_secondary): New static variable if\n+\tBACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE.\n+\t(elf_zlib_inflate_table): New static function.\n+\t(BACKTRACE_GENERATE_FIXED_HUFFMAN_TABLE): If define, define main\n+\tfunction to produce fixed Huffman table.\n+\t(elf_zlib_default_table): New static variable.\n+\t(elf_zlib_inflate): New static function.\n+\t(elf_zlib_verify_checksum): Likewise.\n+\t(elf_zlib_inflate_and_verify): Likewise.\n+\t(elf_uncompress_zdebug): Likewise.\n+\t(elf_uncompress_chdr): Likewise.\n+\t(backtrace_uncompress_zdebug): New extern function.\n+\t(elf_add): Look for .zdebug sections and SHF_COMPRESSED debug\n+\tsections, and uncompress them.\n+\t* internal.h (backtrace_compress_zdebug): Declare.\n+\t* ztest.c: New file.\n+\t* configure.ac: Check for -lz and check whether the linker\n+\tsupports --compress-debug-sections.\n+\t* Makefile.am (ztest_SOURCES): New variable.\n+\t(ztest_CFLAGS, ztest_LDADD): New variables.\n+\t(check_PROGRAMS): Add ztest.\n+\t(ctestg_SOURCES): New variable.\n+\t(ctestg_CFLAGS, ctestg_LDFLAGS, ctestg_LDADD): New variables.\n+\t(ctesta_SOURCES): New variable.\n+\t(ctesta_CFLAGS, ctesta_LDFLAGS, ctesta_LDADD): New variables.\n+\t(check_PROGRAMS): Add ctestg and ctesta.\n+\t* configure, config.h.in, Makefile.in: Rebuild.\n+\n+2017-09-22  Ian Lance Taylor  <iant@golang.org>\n+\n+\tPR sanitizer/77631\n+\t* configure.ac: Check for lstat and readlink.\n+\t* elf.c (lstat, readlink): Provide dummy versions if real versions\n+\tare not available.\n+\t* configure, config.h.in: Rebuild.\n+\n+2017-09-21  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR go/82284\n+\t* elf.c (backtrace_initialize): Set pd.exe_filename.\n+\n+2017-09-20  Ian Lance Taylor  <iant@golang.org>\n+\t    Denis Khalikov  <d.khalikov@partner.samsung.com>\n+\n+\tPR sanitizer/77631\n+\tSupport for external debug info.\n+\t* elf.c: Include <errno.h>, <sys/stat.h>, <unistd.h>.\n+\t(S_ISLNK): Define if not defined.\n+\t(xstrnlen): Define if strnlen is not available.\n+\t(b_elf_note): Define type.\n+\t(NT_GNU_BUILD_ID): Define macro.\n+\t(elf_crc32, elf_crc32_file): New static functions.\n+\t(elf_is_symlink, elf_readlink): New static functions.\n+\t(elf_open_debugfile_by_buildid): New static function.\n+\t(elf_try_debugfile): New static function.\n+\t(elf_find_debugfile_by_debuglink): New static function.\n+\t(elf_open_debugfile_by_debuglink): New static function.\n+\t(elf_add): Add filename and debuginfo parameters.  Adjust all\n+\tcallers.  Look for external debug info notes, and try to fetch\n+\tdebug info from external file.\n+\t(struct phdr_data): Add exe_filename field.\n+\t(phdr_callback): Pass filename to elf_add.\n+\t(backtrace_initialize): Add filename parameter.\n+\t* internal.h (backtrace_initialize): Add filename parameter.\n+\t* fileline.c (fileline_initialize): Pass filename to\n+\tbacktrace_initialize.\n+\t* pecoff.c (fileline_initialize): Add unused filename parameter.\n+\t* unknown.c (fileline_initialize): Likewise.\n+\t* xcoff.c (fileline_initialize): Likewise.\n+\t* configure.ac: Check for objcopy --add-gnu-debuglink.\n+\t* Makefile.am (dtest): New test target.\n+\t* configure, Makefile.in: Rebuild.\n+\n+2017-09-12  Steve Ellcey  <sellcey@cavium.com>\n+\n+\tPR other/81096\n+\t* Makefile.am (ttest_CFLAGS): Add $(AM_CFLAGS)\n+\t* Makefile.in: Regenerate.\n+\n+2017-09-12  Steve Ellcey  <sellcey@cavium.com>\n+\n+\tPR other/81096\n+\t* libbacktrace/Makefile.in\n+\t(HAVE_PTHREAD_TRUE@@NATIVE_TRUE@ttest_CFLAGS): Add $(AM_CFLAGS)\n+\n+2017-08-02  David Edelsohn  <dje.gcc@gmail.com>\n+\n+\tPR bootstrap/81638\n+\t* xcoff.c (xcoff_process_linenos): Initialize incl to NULL.\n+\n+2017-07-28  Tony Reix  <tony.reix@atos.net>\n+\n+\t* xcoff.c: Don't leak a file descriptor if an archive is malformed.\n+\n+2017-07-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* fileline.c (fileline_initialize): Print pid_t as long.\n+\n+2017-07-26  Tony Reix  <tony.reix@atos.net>\n+\n+\t* configure.ac: Check for XCOFF32/XCOFF64.  Check for loadquery.\n+\t* filetype.awk: Separate AIX XCOFF32 and XCOFF64.\n+\t* xcoff.c: Add support for AIX XCOFF32 and XCOFF64 formats.\n+\t* configure, config.h.in: Regenerate.\n+\n+2017-07-21  Tony Reix  <tony.reix@atos.net>\n+\n+\t* filetype.awk: Add AIX XCOFF type detection.\n+\t* configure.ac: Recognize xcoff format.\n+\t* Makefile.am (FORMAT_FILES): Add xcoff.c.\n+\t* fileline.c: Include <unistd.h>.\n+\t(fileline_initialize): Add case for AIX procfs.\n+\t* xcoff.c: New file.\n+\t* configure, Makefile.in: Rebuild.\n+\n+2017-06-21  Richard Biener  <rguenther@suse.de>\n+\n+\t* configure.ac: Add AC_SYS_LARGEFILE.\n+\t* config.h.in: Regenerate.\n+\t* configure: Likewise.\n+\n+2017-06-11  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* elf.c (backtrace_initialize): Always set *fileline_fn.\n+\t* ttest.c: New file.\n+\t* btest.c: Move support functions into testlib.c.  Change calls to\n+\tcheck to pass file name.\n+\t* testlib.c: New file, copied from (part of) btest.c.\n+\t* testlib.h: New file, declarations for testlib.c.\n+\t* edtest.c: Use testlib.h and testlib.c.\n+\t* configure.ac: Test for -pthread, set HAVE_PTHREAD conditional.\n+\t* Makefile.am (btest_SOURCES): Add testlib.c.\n+\t(edtest_SOURCES): Likewise.\n+\t(CHECK_PROGRAMS): Add ttest if HAVE_PTHREAD.\n+\t(ttest_SOURCES, ttest_CFLAGS, ttest_LDADD): Define.\n+\t* configure, Makefile.in: Rebuild.\n+\n+2017-05-19  Than McIntosh  <thanm@google.com>\n+\n+\t* dwarf.c (free_line_header): Don't free dirs if dirs_count == 0.\n+\t(read_line_header): Don't allocate dirs if dirs_count == 0.\n+\t* edtest.c: New file.\n+\t* edtest2.c: New file.\n+\t* Makefile.am (edtest_SOURCES, edtest_LDADD): Define.\n+\t(check_PROGRAMS): Add edtest.\n+\t(edtest2_build.c, gen_edtest2_build): New targets.\n+\t* Makefile.in: Rebuild.\n+\n+2017-03-08  Sam Thursfield  <sam.thursfield@codethink.co.uk>\n+\n+\t* btest.c (test5): Replace #ifdef guard with 'unused' attribute\n+\tto fix compile warning when BACKTRACE_SUPPORTED isn't defined.\n+\n+2017-01-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tUpdate copyright years.\n+\n+2016-11-15  Matthias Klose  <doko@ubuntu.com>\n+\n+\t* configure: Regenerate.\n+\n+2016-09-11  Carlos Liam  <carlos@aarzee.me>\n+\n+\t* all: Remove meaningless trailing whitespace.\n+\n+2016-05-18  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR target/71161\n+\t* elf.c (phdr_callback) [__i386__]: Add\n+\t__attribute__((__force_align_arg_pointer__)).\n+\n+2016-03-02  Maxim Ostapenko  <m.ostapenko@partner.samsung.com>\n+\n+\t* elf.c (backtrace_initialize): Properly initialize elf_fileline_fn to\n+\tavoid possible crash.\n+\t(elf_add): Don't set *fileline_fn to elf_nodebug value in case of\n+\tmissing debug info anymore.\n+\n+2016-02-06  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* mmap.c (MAP_FAILED): Define if not defined.\n+\n+2016-01-04  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tUpdate copyright years.\n+\n+2015-12-18  Andris Pavenis  <andris.pavenis@iki.fi>\n+\n+\t* configure.ac: Specify that DJGPP do not have mmap\n+\teven when sys/mman.h exists.\n+\t* configure: Regenerate\n+\n+2015-12-09  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\tPR libgfortran/68115\n+\t* configure.ac: Set libbacktrace_cv_sys_sync to no on hppa*-*-hpux*.\n+\t* configure: Regenerate.\n+\t* elf.c (backtrace_initialize): Cast __sync_bool_compare_and_swap call\n+\tto void.\n+\n+2015-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* posix.c (backtrace_open): Cast second argument of open() to int.\n+\n+2015-09-11  Ian Lance Taylor  <iant@google.com>\n+\n+\t* Makefile.am (backtrace.lo): Depend on internal.h.\n+\t(sort.lo, stest.lo): Add explicit dependencies.\n+\t* Makefile.in: Rebuild.\n+\n+2015-09-09  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* backtrace.c: #include <sys/types.h>.\n+\n+2015-09-08  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/67457\n+\t* backtrace.c: #include \"internal.h\".\n+\t(struct backtrace_data): Add can_alloc field.\n+\t(unwind): If can_alloc is false, don't try to get file/line\n+\tinformation.\n+\t(backtrace_full): Set can_alloc field in bdata.\n+\t* alloc.c (backtrace_alloc): Don't call error_callback if it is\n+\tNULL.\n+\t* mmap.c (backtrace_alloc): Likewise.\n+\t* internal.h: Update comments for backtrace_alloc and\n+\tbacktrace_free.\n+\n+2015-09-08  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/67457\n+\t* mmap.c (backtrace_alloc): Correct test for mmap failure.\n+\n+2015-08-31  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* configure.ac: For spu-*-* targets, set have_fcntl to no.\n+\t* configure: Regenerate.\n+\n+2015-08-27  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* configure.ac: Remove [disable-shared] argument to LT_INIT.\n+\tRemove setting PIC_FLAG when building as target library.\n+\t* configure: Regenerate.\n+\n+2015-08-26  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* configure.ac: Only compile with -fPIC if the target\n+\tsupports it.\n+\t* configure: Regenerate.\n+\n+2015-08-24  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>\n+\n+\t* configure.ac: Set have_mmap to no on spu-*-* targets.\n+\t* configure: Regenerate.\n+\n+2015-08-13  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_function_entry): Add vec_inlined parameter.\n+\tChange all callers.\n+\n+2015-06-11  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR sanitizer/65479\n+\t* dwarf.c (struct line): Add new field idx.\n+\t(line_compare): Use it.\n+\t(add_line): Set it.\n+\t(read_line_info): Reset it.\n+\n+2015-05-29  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* pecoff.c: New file.\n+\t* Makefile.am (FORMAT_FILES): Add pecoff.c and dependencies.\n+\t* Makefile.in: Regenerate.\n+\t* filetype.awk: Detect pecoff.\n+\t* configure.ac: Define BACKTRACE_SUPPORTS_DATA on elf platforms.\n+\tAdd pecoff.\n+\t* btest.c (test5): Test enabled only if BACKTRACE_SUPPORTS_DATA is\n+\ttrue.\n+\t* backtrace-supported.h.in (BACKTRACE_SUPPORTS_DATA): Define.\n+\t* configure: Regenerate.\n+\t* pecoff.c: New file.\n+\n+2015-05-13  Michael Haubenwallner  <michael.haubenwallner@ssi-schaefer.com>\n+\n+\t* Makefile.in: Regenerated with automake-1.11.6.\n+\t* aclocal.m4: Likewise.\n+\t* configure: Likewise.\n+\n+2015-01-24  Matthias Klose  <doko@ubuntu.com>\n+\n+\t* configure.ac: Move AM_ENABLE_MULTILIB before AC_PROG_CC.\n+\t* configure: Regenerate.\n+\n+2015-01-05  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tUpdate copyright years.\n+\n+2014-11-21  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR bootstrap/63784\n+\t* configure: Regenerated.\n+\n+2014-11-11  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: New.\n+\n+2014-11-11  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR target/63610\n+\t* configure: Regenerate.\n+\n+2014-10-23  Ian Lance Taylor  <iant@google.com>\n+\n+\t* internal.h (backtrace_atomic_load_pointer) [no atomic or sync]:\n+\tFix to return void *.\n+\n+2014-05-08  Ian Lance Taylor  <iant@google.com>\n+\n+\t* mmap.c (backtrace_free): If freeing a large aligned block of\n+\tmemory, call munmap rather than holding onto it.\n+\t(backtrace_vector_grow): When growing a vector, double the number\n+\tof pages requested.  When releasing the old version of a grown\n+\tvector, pass the correct size to backtrace_free.\n+\n+2014-03-07  Ian Lance Taylor  <iant@google.com>\n+\n+\t* sort.c (backtrace_qsort): Use middle element as pivot.\n+\n+2014-03-06  Ian Lance Taylor  <iant@google.com>\n+\n+\t* sort.c: New file.\n+\t* stest.c: New file.\n+\t* internal.h (backtrace_qsort): Declare.\n+\t* dwarf.c (read_abbrevs): Call backtrace_qsort instead of qsort.\n+\t(read_line_info, read_function_entry): Likewise.\n+\t(read_function_info, build_dwarf_data): Likewise.\n+\t* elf.c (elf_initialize_syminfo): Likewise.\n+\t* Makefile.am (libbacktrace_la_SOURCES): Add sort.c.\n+\t(stest_SOURCES, stest_LDADD): Define.\n+\t(check_PROGRAMS): Add stest.\n+\n+2014-02-07  Misty De Meo  <misty@brew.sh>\n+\n+\tPR target/58710\n+\t* configure.ac: Use AC_LINK_IFELSE in check for\n+\t_Unwind_GetIPInfo.\n+\t* configure: Regenerate.\n+\n+2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tUpdate copyright years\n+\n+2013-12-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* elf.c (ET_DYN): Undefine and define again.\n+\t(elf_add): Add exe argument, if true and ehdr.e_type is ET_DYN,\n+\treturn early -1 without closing the descriptor.\n+\t(struct phdr_data): Add exe_descriptor.\n+\t(phdr_callback): If pd->exe_descriptor is not -1, for very first\n+\tcall if dlpi_name is NULL just call elf_add with the exe_descriptor,\n+\totherwise backtrace_close the exe_descriptor if not -1.  Adjust\n+\tcall to elf_add.\n+\t(backtrace_initialize): Adjust call to elf_add.  If it returns\n+\t-1, set pd.exe_descriptor to descriptor, otherwise set it to -1.\n+\n+2013-12-05  Ian Lance Taylor  <iant@google.com>\n+\n+\t* alloc.c (backtrace_vector_finish): Add error_callback and data\n+\tparameters.  Call backtrace_vector_release.  Return address base.\n+\t* mmap.c (backtrace_vector_finish): Add error_callback and data\n+\tparameters.  Return address base.\n+\t* dwarf.c (read_function_info): Get new address base from\n+\tbacktrace_vector_finish.\n+\t* internal.h (backtrace_vector_finish): Update declaration.\n+\n+2013-11-27  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (find_address_ranges): New static function, broken out\n+\tof build_address_map.\n+\t(build_address_map): Call it.\n+\t* btest.c (check): Check for missing filename or function, rather\n+\tthan crashing.\n+\t(f3): Check that enough frames were returned.\n+\n+2013-11-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* backtrace.h (backtrace_syminfo_callback): Add symsize argument.\n+\t* elf.c (elf_syminfo): Pass 0 or sym->size to the callback as\n+\tlast argument.\n+\t* btest.c (struct symdata): Add size field.\n+\t(callback_three): Add symsize argument.  Copy it to the data->size\n+\tfield.\n+\t(f23): Set symdata.size to 0.\n+\t(test5): Likewise.  If sizeof (int) > 1, lookup address of\n+\t((uintptr_t) &global) + 1.  Verify symdata.val and symdata.size\n+\tvalues.\n+\n+\t* atomic.c: Include sys/types.h.\n+\n+2013-11-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Check for support of __atomic extensions.\n+\t* internal.h: Declare or #define atomic functions for use in\n+\tbacktrace code.\n+\t* atomic.c: New file.\n+\t* dwarf.c (dwarf_lookup_pc): Use atomic functions.\n+\t(dwarf_fileline, backtrace_dwarf_add): Likewise.\n+\t* elf.c (elf_add_syminfo_data, elf_syminfo): Likewise.\n+\t(backtrace_initialize): Likewise.\n+\t* fileline.c (fileline_initialize): Likewise.\n+\t* Makefile.am (libbacktrace_la_SOURCES): Add atomic.c.\n+\t* configure, config.h.in, Makefile.in: Rebuild.\n+\n+2013-11-18  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* elf.c (SHN_UNDEF): Define.\n+\t(elf_initialize_syminfo): Add base_address argument.  Ignore symbols\n+\twith st_shndx == SHN_UNDEF.  Add base_address to address fields.\n+\t(elf_add): Adjust caller.\n+\n+\t* elf.c (phdr_callback): Process info->dlpi_addr == 0 normally.\n+\n+2013-11-16  Ian Lance Taylor  <iant@google.com>\n+\n+\t* backtrace.h (backtrace_create_state): Correct comment about\n+\tthreading.\n+\n+2013-11-15  Ian Lance Taylor  <iant@google.com>\n+\n+\t* backtrace.h (backtrace_syminfo): Update comment and parameter\n+\tname to take any address, not just a PC value.\n+\t* elf.c (STT_OBJECT): Define.\n+\t(elf_nosyms): Rename parameter pc to addr.\n+\t(elf_symbol_search): Rename local variable pc to addr.\n+\t(elf_initialize_syminfo): Add STT_OBJECT symbols to elf_symbols.\n+\t(elf_syminfo): Rename parameter pc to addr.\n+\t* btest.c (global): New global variable.\n+\t(test5): New test.\n+\t(main): Call test5.\n+\n+2013-10-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* elf.c (elf_add): Don't get the wrong offsets if a debug section\n+\tis missing.\n+\n+2013-10-15  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* configure.ac: Add --enable-host-shared, setting up\n+\tpre-existing PIC_FLAG variable within Makefile.am et al.\n+\t* configure: Regenerate.\n+\n+2013-09-20  Alan Modra  <amodra@gmail.com>\n+\n+\t* configure: Regenerate.\n+\n+2013-07-23  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* elf.c (elf_syminfo): Loop over the elf_syminfo_data chain.\n+\n+2013-07-23  Alexander Monakov  <amonakov@ispras.ru>\n+\n+\t* elf.c (backtrace_initialize): Pass elf_fileline_fn to\n+\tdl_iterate_phdr callbacks.\n+\n+2013-03-25  Ian Lance Taylor  <iant@google.com>\n+\n+\t* alloc.c: #include <sys/types.h>.\n+\t* mmap.c: Likewise.\n+\n+2013-01-31  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_function_info): Permit fvec parameter to be NULL.\n+\t(dwarf_lookup_pc): Don't use ddata->fvec if threaded.\n+\n+2013-01-25  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/56076\n+\t* dwarf.c (read_line_header): Don't crash if DW_AT_comp_dir\n+\tattribute was not seen.\n+\n+2013-01-16  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (struct unit): Add filename and abs_filename fields.\n+\t(build_address_map): Set new fields when reading unit.\n+\t(dwarf_lookup_pc): If we don't find an entry in the line table,\n+\tjust return the main file name.\n+\n+2013-01-14  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\tUpdate copyright years.\n+\n+2013-01-01  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54834\n+\t* Makefile.am (AM_CPPFLAGS): Remove -I ../gcc/include and -I\n+\t$(MULTIBUILDTOP)/../../gcc/include.\n+\t* Makefile.in: Rebuild.\n+\n+2013-01-01  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/55536\n+\t* mmap.c (backtrace_alloc): Don't call sync functions if not\n+\tthreaded.\n+\t(backtrace_free): Likewise.\n+\n+2012-12-12  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* mmapio.c: Define MAP_FAILED if not defined.\n+\n+2012-12-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/54926\n+\t* Makefile.am (AM_CFLAGS): Remove -frandom-seed=$@.\n+\t* configure.ac: If --with-target-subdir, add -frandom-seed=$@\n+\tto EXTRA_FLAGS unconditionally, otherwise check whether the compiler\n+\taccepts it.\n+\t* Makefile.in: Regenerated.\n+\t* configure: Regenerated.\n+\n+2012-12-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR bootstrap/54926\n+\t* Makefile.am (AM_CFLAGS): Add -frandom-seed=$@.\n+\t* Makefile.in: Regenerated.\n+\n+2012-11-20  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_attribute): Always clear val.\n+\n+2012-11-13  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/55312\n+\t* configure.ac: Only add -Werror if building a target library.\n+\t* configure: Rebuild.\n+\n+2012-11-12  Ian Lance Taylor  <iant@google.com>\n+\t    Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\t    Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* configure.ac: Check for getexecname.\n+\t* fileline.c: #include <errno.h>.  Define getexecname if not\n+\tavailable.\n+\t(fileline_initialize): Try to find the executable in a few\n+\tdifferent ways.\n+\t* print.c (error_callback): Only print the filename if it came\n+\tfrom the backtrace state.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-10-29  Ian Lance Taylor  <iant@google.com>\n+\n+\t* mmap.c (backtrace_vector_release): Correct last patch: add\n+\taligned, not size.\n+\n+2012-10-29  Ian Lance Taylor  <iant@google.com>\n+\n+\t* mmap.c (backtrace_vector_release): Make sure freed block is\n+\taligned on 8-byte boundary.\n+\n+2012-10-26  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/55087\n+\t* posix.c (backtrace_open): Add does_not_exist parameter.\n+\t* elf.c (phdr_callback): Do not warn if shared library could not\n+\tbe opened.\n+\t* fileline.c (fileline_initialize): Update calls to\n+\tbacktrace_open.\n+\t* internal.h (backtrace_open): Update declaration.\n+\n+2012-10-26  Jack Howarth  <howarth@bromo.med.uc.edu>\n+\n+\tPR target/55061\n+\t* configure.ac: Check for _Unwind_GetIPInfo function declaration.\n+\t* configure: Regenerate.\n+\n+2012-10-24  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR target/55061\n+\t* configure.ac: Check whether -funwind-tables option works.\n+\t* configure: Rebuild.\n+\n+2012-10-11  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Do not use dl_iterate_phdr on Solaris 10.\n+\t* configure: Rebuild.\n+\n+2012-10-10  Ian Lance Taylor  <iant@google.com>\n+\n+\t* elf.c: Rename all Elf typedefs to start with b_elf, and be all\n+\tlower case.\n+\n+2012-10-10  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* elf.c (elf_add_syminfo_data): Add casts to avoid warning.\n+\n+2012-10-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (dwarf_fileline): Add cast to avoid warning.\n+\t(backtrace_dwarf_add): Likewise.\n+\n+2012-10-09  Ian Lance Taylor  <iant@google.com>\n+\n+\tAdd support for tracing through shared libraries.\n+\t* configure.ac: Check for link.h and dl_iterate_phdr.\n+\t* elf.c: #include <link.h> if system has dl_iterate_phdr.  #undef\n+\tELF macros before #defining them.\n+\t(dl_phdr_info, dl_iterate_phdr): Define if system does not have\n+\tdl_iterate_phdr.\n+\t(struct elf_syminfo_data): Add next field.\n+\t(elf_initialize_syminfo): Initialize next field.\n+\t(elf_add_syminfo_data): New static function.\n+\t(elf_add): New static function, broken out of\n+\tbacktrace_initialize.  Call backtrace_dwarf_add instead of\n+\tbacktrace_dwarf_initialize.\n+\t(struct phdr_data): Define.\n+\t(phdr_callback): New static function.\n+\t(backtrace_initialize): Call elf_add.\n+\t* dwarf.c (struct dwarf_data): Add next and base_address fields.\n+\t(add_unit_addr): Add base_address parameter.  Change all callers.\n+\t(add_unit_ranges, build_address_map): Likewise.\n+\t(add_line): Add ddata parameter.  Change all callers.\n+\t(read_line_program, add_function_range): Likewise.\n+\t(dwarf_lookup_pc): New static function, broken out of\n+\tdwarf_fileline.\n+\t(dwarf_fileline): Call dwarf_lookup_pc.\n+\t(build_dwarf_data): New static function.\n+\t(backtrace_dwarf_add): New function.\n+\t(backtrace_dwarf_initialize): Remove.\n+\t* internal.h (backtrace_dwarf_initialize): Don't declare.\n+\t(backtrace_dwarf_add): Declare.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-10-04  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\t* btest.c (f23): Avoid uninitialized variable warning.\n+\n+2012-10-04  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c: If the system header files do not declare strnlen,\n+\tprovide our own version.\n+\n+2012-10-03  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c (read_uleb128): Fix overflow test.\n+\t(read_sleb128): Likewise.\n+\t(build_address_map): Don't change unit_buf.start.\n+\n+2012-10-02  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\tPR other/54761\n+\t* configure.ac (EXTRA_FLAGS): New.\n+\t* Makefile.am (AM_FLAGS): Add $(EXTRA_FLAGS).\n+\t* configure, Makefile.in: Regenerate.\n+\n+2012-09-29  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/54749\n+\t* fileline.c (fileline_initialize): Pass errnum as -1 when\n+\treporting that we could not read executable information after a\n+\tprevious failure.\n+\n+2012-09-27  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54732\n+\t* configure.ac: Add no-dependencies to AM_INIT_AUTOMAKE.\n+\t* Makefile.am: Add dependencies for all objects.\n+\t* configure, aclocal.m4, Makefile.in: Rebuild.\n+\n+2012-09-27  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR other/54726\n+\t* elf.c (backtrace_initialize): Set *fileln_fn, not\n+\tstate->fileln_fn.\n+\n+2012-09-19  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Only use GCC_CHECK_UNWIND_GETIPINFO when compiled\n+\tas a target library.\n+\t* configure: Rebuild.\n+\n+2012-09-19  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\t    Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac (GCC_HEADER_STDINT): Invoke.\n+\t* backtrace.h: If we can't find <stdint.h>, use \"gstdint.h\".\n+\t* btest.c: Don't include <stdint.h>.\n+\t* dwarf.c: Likewise.\n+\t* configure, aclocal.m4, Makefile.in, config.h.in: Rebuild.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54623\n+\t* Makefile.am (AM_CPPFLAGS): Define.\n+\t(AM_CFLAGS): Remove -I options.\n+\t* Makefile.in: Rebuild.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* posix.c (O_BINARY): Define if not defined.\n+\t(backtrace_open): Pass O_BINARY to open.  Only call fcntl if\n+\tHAVE_FCNTL is defined.\n+\t* configure.ac: Test for the fcntl function.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* btest.c (test1, test2, test3, test4): Add the unused attribute.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* dwarf.c: Correct test of HAVE_DECL_STRNLEN.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Add AC_USE_SYSTEM_EXTENSIONS.\n+\t* mmapio.c: Don't define _GNU_SOURCE.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-09-18  Ian Lance Taylor  <iant@google.com>\n+\n+\t* configure.ac: Check whether strnlen is declared.\n+\t* dwarf.c: Declare strnlen if not declared.\n+\t* configure, config.h.in: Rebuild.\n+\n+2012-09-18  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* fileline.c: Include <stdlib.h>.\n+\t* mmap.c: Likewise.\n+\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54611\n+\t* nounwind.c (backtrace_full): Rename from backtrace.  Add state\n+\tparameter.\n+\n+2012-09-17  Gerald Pfeifer  <gerald@pfeifer.com>\n+\n+\tPR bootstrap/54611\n+\t* nounwind.c (backtrace_simple): Add state parameter.\n+\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\tPR bootstrap/54609\n+\t* unknown.c (unknown_fileline): Add state parameter, remove\n+\tfileline_data parameter, name error_callback parameter.\n+\t(backtrace_initialize): Add state parameter.\n+\n+2012-09-17  Ian Lance Taylor  <iant@google.com>\n+\n+\t* Initial implementation.\n+\f\n+Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."
    },
    {
      "sha": "6b60e3b3b07382a48c7ffbaf992876426234bdee",
      "filename": "libbacktrace/ChangeLog.jit",
      "status": "added",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/ChangeLog.jit",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/ChangeLog.jit",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/ChangeLog.jit?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,14 @@\n+2014-09-24  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* ChangeLog.jit: Add copyright footer.\n+\n+2013-10-03  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* configure.ac: Add --enable-host-shared.\n+\t* configure: Regenerate.\n+\f\n+Copyright (C) 2013-2014 Free Software Foundation, Inc.\n+\n+Copying and distribution of this file, with or without modification,\n+are permitted in any medium without royalty provided the copyright\n+notice and this notice are preserved."
    },
    {
      "sha": "8874f41338a7d0fdeafc022c73557a9485e96f0c",
      "filename": "libbacktrace/Makefile.am",
      "status": "added",
      "additions": 586,
      "deletions": 0,
      "changes": 586,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/Makefile.am?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,586 @@\n+# Makefile.am -- Backtrace Makefile.\n+# Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.\n+\n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+ACLOCAL_AMFLAGS = -I .. -I ../config\n+\n+AM_CPPFLAGS = -I $(top_srcdir)/../include -I $(top_srcdir)/../libgcc \\\n+\t-I ../libgcc\n+\n+AM_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) $(PIC_FLAG) $(CET_HOST_FLAGS)\n+\n+noinst_LTLIBRARIES = libbacktrace.la\n+\n+libbacktrace_la_SOURCES = \\\n+\tbacktrace.h \\\n+\tatomic.c \\\n+\tdwarf.c \\\n+\tfileline.c \\\n+\tinternal.h \\\n+\tposix.c \\\n+\tprint.c \\\n+\tsort.c \\\n+\tstate.c\n+\n+BACKTRACE_FILES = \\\n+\tbacktrace.c \\\n+\tsimple.c \\\n+\tnounwind.c\n+\n+FORMAT_FILES = \\\n+\telf.c \\\n+\tmacho.c \\\n+\tpecoff.c \\\n+\tunknown.c \\\n+\txcoff.c\n+\n+VIEW_FILES = \\\n+\tread.c \\\n+\tmmapio.c\n+\n+ALLOC_FILES = \\\n+\talloc.c \\\n+\tmmap.c\n+\n+EXTRA_libbacktrace_la_SOURCES = \\\n+\t$(BACKTRACE_FILES) \\\n+\t$(FORMAT_FILES) \\\n+\t$(VIEW_FILES) \\\n+\t$(ALLOC_FILES)\n+\n+libbacktrace_la_LIBADD = \\\n+\t$(BACKTRACE_FILE) \\\n+\t$(FORMAT_FILE) \\\n+\t$(VIEW_FILE) \\\n+\t$(ALLOC_FILE)\n+\n+libbacktrace_la_DEPENDENCIES = $(libbacktrace_la_LIBADD)\n+\n+# Testsuite.\n+\n+# Add a test to this variable if you want it to be built.\n+check_PROGRAMS =\n+\n+# Add a test to this variable if you want it to be run.\n+TESTS =\n+\n+# Add a test to this variable if you want it to be built and run.\n+BUILDTESTS =\n+\n+# Add a file to this variable if you want it to be built for testing.\n+check_DATA =\n+\n+# Flags to use when compiling test programs.\n+libbacktrace_TEST_CFLAGS = $(EXTRA_FLAGS) $(WARN_FLAGS) -g\n+\n+if USE_DSYMUTIL\n+\n+%.dSYM: %\n+\t$(DSYMUTIL) $<\n+\n+endif USE_DSYMUTIL\n+\n+if NATIVE\n+check_LTLIBRARIES = libbacktrace_alloc.la\n+\n+libbacktrace_alloc_la_SOURCES = $(libbacktrace_la_SOURCES)\n+libbacktrace_alloc_la_LIBADD = $(BACKTRACE_FILE) $(FORMAT_FILE) read.lo alloc.lo\n+\n+libbacktrace_alloc_la_DEPENDENCIES = $(libbacktrace_alloc_la_LIBADD)\n+\n+check_LTLIBRARIES += libbacktrace_noformat.la\n+\n+libbacktrace_noformat_la_SOURCES = $(libbacktrace_la_SOURCES)\n+libbacktrace_noformat_la_LIBADD = $(BACKTRACE_FILE) $(VIEW_FILE) $(ALLOC_FILE)\n+\n+libbacktrace_noformat_la_DEPENDENCIES = $(libbacktrace_noformat_la_LIBADD)\n+\n+if HAVE_ELF\n+if HAVE_OBJCOPY_DEBUGLINK\n+\n+TEST_BUILD_ID_DIR=$(abs_builddir)/usr/lib/debug/.build-id/\n+\n+check_LTLIBRARIES += libbacktrace_elf_for_test.la\n+\n+libbacktrace_elf_for_test_la_SOURCES = $(libbacktrace_la_SOURCES)\n+libbacktrace_elf_for_test_la_LIBADD = $(BACKTRACE_FILE) elf_for_test.lo \\\n+\t$(VIEW_FILE) $(ALLOC_FILE)\n+\n+elf_for_test.c: elf.c\n+\tSEARCH='^#define SYSTEM_BUILD_ID_DIR.*$$'; \\\n+\tREPLACE=\"#define SYSTEM_BUILD_ID_DIR \\\"$(TEST_BUILD_ID_DIR)\\\"\"; \\\n+\t$(SED) \"s%$$SEARCH%$$REPLACE%\" \\\n+\t\t$< \\\n+\t\t> $@.tmp\n+\tmv $@.tmp $@\n+\n+endif HAVE_OBJCOPY_DEBUGLINK\n+endif HAVE_ELF\n+\n+elf_%.c: elf.c\n+\tSEARCH='#error \"Unknown BACKTRACE_ELF_SIZE\"'; \\\n+\tREPLACE='#undef BACKTRACE_ELF_SIZE\\\n+\t#define BACKTRACE_ELF_SIZE'; \\\n+\t$(SED) \"s/^$$SEARCH\\$$/$$REPLACE $*/\" \\\n+\t\t$< \\\n+\t\t> $@.tmp\n+\tmv $@.tmp $@\n+\n+xcoff_%.c: xcoff.c\n+\tSEARCH='#error \"Unknown BACKTRACE_XCOFF_SIZE\"'; \\\n+\tREPLACE='#undef BACKTRACE_XCOFF_SIZE\\\n+\t#define BACKTRACE_XCOFF_SIZE'; \\\n+\t$(SED) \"s/^$$SEARCH\\$$/$$REPLACE $*/\" \\\n+\t\t$< \\\n+\t\t> $@.tmp\n+\tmv $@.tmp $@\n+\n+test_elf_32_SOURCES = test_format.c testlib.c\n+test_elf_32_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+test_elf_32_LDADD = libbacktrace_noformat.la elf_32.lo\n+\n+BUILDTESTS += test_elf_32\n+\n+test_elf_64_SOURCES = test_format.c testlib.c\n+test_elf_64_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+test_elf_64_LDADD = libbacktrace_noformat.la elf_64.lo\n+\n+BUILDTESTS += test_elf_64\n+\n+test_macho_SOURCES = test_format.c testlib.c\n+test_macho_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+test_macho_LDADD = libbacktrace_noformat.la macho.lo\n+\n+BUILDTESTS += test_macho\n+\n+test_xcoff_32_SOURCES = test_format.c testlib.c\n+test_xcoff_32_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+test_xcoff_32_LDADD = libbacktrace_noformat.la xcoff_32.lo\n+\n+BUILDTESTS += test_xcoff_32\n+\n+test_xcoff_64_SOURCES = test_format.c testlib.c\n+test_xcoff_64_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+test_xcoff_64_LDADD = libbacktrace_noformat.la xcoff_64.lo\n+\n+BUILDTESTS += test_xcoff_64\n+\n+test_pecoff_SOURCES = test_format.c testlib.c\n+test_pecoff_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+test_pecoff_LDADD = libbacktrace_noformat.la pecoff.lo\n+\n+BUILDTESTS += test_pecoff\n+\n+test_unknown_SOURCES = test_format.c testlib.c\n+test_unknown_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+test_unknown_LDADD = libbacktrace_noformat.la unknown.lo\n+\n+BUILDTESTS += test_unknown\n+\n+unittest_SOURCES = unittest.c testlib.c\n+unittest_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+unittest_LDADD = libbacktrace.la\n+\n+BUILDTESTS += unittest\n+\n+unittest_alloc_SOURCES = $(unittest_SOURCES)\n+unittest_alloc_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+unittest_alloc_LDADD = libbacktrace_alloc.la\n+\n+BUILDTESTS += unittest_alloc\n+\n+check_LTLIBRARIES += libbacktrace_instrumented_alloc.la\n+\n+libbacktrace_instrumented_alloc_la_SOURCES = $(libbacktrace_la_SOURCES)\n+libbacktrace_instrumented_alloc_la_LIBADD = $(BACKTRACE_FILE) $(FORMAT_FILE) \\\n+\tread.lo instrumented_alloc.lo\n+\n+libbacktrace_instrumented_alloc_la_DEPENDENCIES = \\\n+\t$(libbacktrace_instrumented_alloc_la_LIBADD)\n+\n+instrumented_alloc.lo: alloc.c\n+\n+allocfail_SOURCES = allocfail.c testlib.c\n+allocfail_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+allocfail_LDADD = libbacktrace_instrumented_alloc.la\n+\n+check_PROGRAMS += allocfail\n+\n+allocfail.sh: allocfail\n+\n+TESTS += allocfail.sh\n+\n+if USE_DSYMUTIL\n+check_DATA += allocfail.dSYM\n+endif USE_DSYMUTIL\n+\n+if HAVE_ELF\n+if HAVE_OBJCOPY_DEBUGLINK\n+\n+b2test_SOURCES = $(btest_SOURCES)\n+b2test_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+b2test_LDFLAGS = -Wl,--build-id\n+b2test_LDADD = libbacktrace_elf_for_test.la\n+\n+check_PROGRAMS += b2test\n+TESTS += b2test_buildid\n+\n+if HAVE_DWZ\n+\n+b3test_SOURCES = $(btest_SOURCES)\n+b3test_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+b3test_LDFLAGS = -Wl,--build-id\n+b3test_LDADD = libbacktrace_elf_for_test.la\n+\n+check_PROGRAMS += b3test\n+TESTS += b3test_dwz_buildid\n+\n+endif HAVE_DWZ\n+\n+endif HAVE_OBJCOPY_DEBUGLINK\n+endif HAVE_ELF\n+\n+btest_SOURCES = btest.c testlib.c\n+btest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -O\n+btest_LDADD = libbacktrace.la\n+\n+BUILDTESTS += btest\n+\n+if USE_DSYMUTIL\n+check_DATA += btest.dSYM\n+endif USE_DSYMUTIL\n+\n+if HAVE_ELF\n+\n+btest_lto_SOURCES = btest.c testlib.c\n+btest_lto_CFLAGS = $(libbacktrace_TEST_CFLAGS) -O -flto\n+btest_lto_LDADD = libbacktrace.la\n+\n+BUILDTESTS += btest_lto\n+\n+endif HAVE_ELF\n+\n+btest_alloc_SOURCES = $(btest_SOURCES)\n+btest_alloc_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+btest_alloc_LDADD = libbacktrace_alloc.la\n+\n+BUILDTESTS += btest_alloc\n+\n+if USE_DSYMUTIL\n+check_DATA += btest_alloc.dSYM\n+endif USE_DSYMUTIL\n+\n+if HAVE_DWZ\n+\n+%_dwz: %\n+\trm -f $@ $@_common.debug\n+\tcp $< $@_1\n+\tcp $< $@_2\n+\tif $(DWZ) -m $@_common.debug $@_1 $@_2; then \\\n+\t  rm -f $@_2; \\\n+\t  mv $@_1 $@; \\\n+\telse \\\n+\t  echo \"Ignoring dwz errors, assuming that test passes\"; \\\n+\t  cp $< $@; \\\n+\tfi\n+\n+TESTS += btest_dwz\n+\n+if HAVE_OBJCOPY_DEBUGLINK\n+\n+TESTS += btest_dwz_gnudebuglink\n+\n+endif HAVE_OBJCOPY_DEBUGLINK\n+\n+endif HAVE_DWZ\n+\n+stest_SOURCES = stest.c\n+stest_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+stest_LDADD = libbacktrace.la\n+\n+BUILDTESTS += stest\n+\n+if USE_DSYMUTIL\n+check_DATA += stest.dSYM\n+endif USE_DSYMUTIL\n+\n+stest_alloc_SOURCES = $(stest_SOURCES)\n+stest_alloc_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+stest_alloc_LDADD = libbacktrace_alloc.la\n+\n+BUILDTESTS += stest_alloc\n+\n+if USE_DSYMUTIL\n+check_DATA += stest_alloc.dSYM\n+endif USE_DSYMUTIL\n+\n+if HAVE_ELF\n+\n+ztest_SOURCES = ztest.c testlib.c\n+ztest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -DSRCDIR=\\\"$(srcdir)\\\"\n+ztest_LDADD = libbacktrace.la\n+ztest_alloc_LDADD = libbacktrace_alloc.la\n+\n+if HAVE_ZLIB\n+ztest_LDADD += -lz\n+ztest_alloc_LDADD += -lz\n+endif\n+ztest_LDADD += $(CLOCK_GETTIME_LINK)\n+ztest_alloc_LDADD += $(CLOCK_GETTIME_LINK)\n+\n+BUILDTESTS += ztest\n+\n+ztest_alloc_SOURCES = $(ztest_SOURCES)\n+ztest_alloc_CFLAGS = $(ztest_CFLAGS)\n+\n+BUILDTESTS += ztest_alloc\n+\n+endif HAVE_ELF\n+\n+edtest_SOURCES = edtest.c edtest2_build.c testlib.c\n+edtest_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+edtest_LDADD = libbacktrace.la\n+\n+BUILDTESTS += edtest\n+\n+if USE_DSYMUTIL\n+check_DATA += edtest.dSYM\n+endif USE_DSYMUTIL\n+\n+edtest_alloc_SOURCES = $(edtest_SOURCES)\n+edtest_alloc_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+edtest_alloc_LDADD = libbacktrace_alloc.la\n+\n+if USE_DSYMUTIL\n+check_DATA += edtest_alloc.dSYM\n+endif USE_DSYMUTIL\n+\n+BUILDTESTS += edtest_alloc\n+\n+edtest2_build.c: gen_edtest2_build; @true\n+gen_edtest2_build: $(srcdir)/edtest2.c\n+\tcat $(srcdir)/edtest2.c > tmp-edtest2_build.c\n+\t$(SHELL) $(srcdir)/../move-if-change tmp-edtest2_build.c edtest2_build.c\n+\techo timestamp > $@\n+\n+if HAVE_PTHREAD\n+\n+BUILDTESTS += ttest\n+\n+ttest_SOURCES = ttest.c testlib.c\n+ttest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -pthread\n+ttest_LDADD = libbacktrace.la\n+\n+if USE_DSYMUTIL\n+check_DATA += ttest.dSYM\n+endif USE_DSYMUTIL\n+\n+BUILDTESTS += ttest_alloc\n+\n+ttest_alloc_SOURCES = $(ttest_SOURCES)\n+ttest_alloc_CFLAGS = $(ttest_CFLAGS)\n+ttest_alloc_LDADD = libbacktrace_alloc.la\n+\n+if USE_DSYMUTIL\n+check_DATA += ttest_alloc.dSYM\n+endif USE_DSYMUTIL\n+\n+endif HAVE_PTHREAD\n+\n+if HAVE_OBJCOPY_DEBUGLINK\n+\n+TESTS += btest_gnudebuglink\n+\n+%_gnudebuglink: %\n+\t$(OBJCOPY) --only-keep-debug $< $@.debug\n+\t$(OBJCOPY) --strip-debug --add-gnu-debuglink=$@.debug $< $@\n+\n+endif HAVE_OBJCOPY_DEBUGLINK\n+\n+%_buildid: %\n+\t./install-debuginfo-for-buildid.sh \\\n+\t  \"$(TEST_BUILD_ID_DIR)\" \\\n+\t  $<\n+\t$(OBJCOPY) --strip-debug $< $@\n+\n+if HAVE_COMPRESSED_DEBUG\n+\n+ctestg_SOURCES = btest.c testlib.c\n+ctestg_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+ctestg_LDFLAGS = -Wl,--compress-debug-sections=zlib-gnu\n+ctestg_LDADD = libbacktrace.la\n+\n+ctesta_SOURCES = btest.c testlib.c\n+ctesta_CFLAGS = $(libbacktrace_TEST_CFLAGS)\n+ctesta_LDFLAGS = -Wl,--compress-debug-sections=zlib-gabi\n+ctesta_LDADD = libbacktrace.la\n+\n+BUILDTESTS += ctestg ctesta\n+\n+ctestg_alloc_SOURCES = $(ctestg_SOURCES)\n+ctestg_alloc_CFLAGS = $(ctestg_CFLAGS)\n+ctestg_alloc_LDFLAGS = $(ctestg_LDFLAGS)\n+ctestg_alloc_LDADD = libbacktrace_alloc.la\n+\n+ctesta_alloc_SOURCES = $(ctesta_SOURCES)\n+ctesta_alloc_CFLAGS = $(ctesta_CFLAGS)\n+ctesta_alloc_LDFLAGS = $(ctesta_LDFLAGS)\n+ctesta_alloc_LDADD = libbacktrace_alloc.la\n+\n+BUILDTESTS += ctestg_alloc ctesta_alloc\n+\n+endif\n+\n+if HAVE_DWARF5\n+\n+dwarf5_SOURCES = btest.c testlib.c\n+dwarf5_CFLAGS = $(libbacktrace_TEST_CFLAGS) -gdwarf-5\n+dwarf5_LDADD = libbacktrace.la\n+\n+BUILDTESTS += dwarf5\n+\n+if USE_DSYMUTIL\n+check_DATA += dwarf5.dSYM\n+endif USE_DSYMUTIL\n+\n+dwarf5_alloc_SOURCES = $(dwarf5_SOURCES)\n+dwarf5_alloc_CFLAGS = $(dwarf5_CFLAGS)\n+dwarf5_alloc_LDADD = libbacktrace_alloc.la\n+\n+BUILDTESTS += dwarf5_alloc\n+\n+if USE_DSYMUTIL\n+check_DATA += dwarf5_alloc.dSYM\n+endif USE_DSYMUTIL\n+\n+endif\n+\n+mtest_SOURCES = mtest.c testlib.c\n+mtest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -O\n+mtest_LDADD = libbacktrace.la\n+\n+BUILDTESTS += mtest\n+\n+if USE_DSYMUTIL\n+check_DATA += mtest.dSYM\n+endif USE_DSYMUTIL\n+\n+if HAVE_MINIDEBUG\n+\n+TESTS += mtest_minidebug\n+\n+%_minidebug: %\n+\t$(NM) -D $< -P --defined-only | $(AWK) '{ print $$1 }' | sort > $<.dsyms\n+\t$(NM) $< -P --defined-only | $(AWK) '{ if ($$2 == \"T\" || $$2 == \"t\" || $$2 == \"D\") print $$1 }' | sort > $<.fsyms\n+\t$(COMM) -13 $<.dsyms $<.fsyms > $<.keepsyms\n+\t$(OBJCOPY) --only-keep-debug $< $<.dbg\n+\t$(OBJCOPY) -S --remove-section .gdb_index --remove-section .comment --keep-symbols=$<.keepsyms $<.dbg $<.mdbg\n+\t$(OBJCOPY) --strip-all --remove-section ..comment $< $<.strip\n+\trm -f $<.mdbg.xz\n+\t$(XZ) $<.mdbg\n+\t$(OBJCOPY) --add-section .gnu_debugdata=$<.mdbg.xz $<.strip\n+\tmv $<.strip $@\n+\n+endif HAVE_MINIDEBUG\n+\n+endif NATIVE\n+\n+if HAVE_ELF\n+\n+xztest_SOURCES = xztest.c testlib.c\n+xztest_CFLAGS = $(libbacktrace_TEST_CFLAGS) -DSRCDIR=\\\"$(srcdir)\\\"\n+xztest_LDADD = libbacktrace.la\n+\n+xztest_alloc_SOURCES = $(xztest_SOURCES)\n+xztest_alloc_CFLAGS = $(xztest_CFLAGS)\n+xztest_alloc_LDADD = libbacktrace_alloc.la\n+\n+if HAVE_LIBLZMA\n+xztest_LDADD += -llzma\n+xztest_alloc_LDADD += -llzma\n+endif\n+\n+xztest_LDADD += $(CLOCK_GETTIME_LINK)\n+xztest_alloc_LDADD += $(CLOCK_GETTIME_LINK)\n+\n+BUILDTESTS += xztest xztest_alloc\n+\n+endif HAVE_ELF\n+\n+check_PROGRAMS += $(BUILDTESTS)\n+\n+TESTS += $(BUILDTESTS)\n+\n+CLEANFILES = \\\n+\t$(TESTS) *.debug elf_for_test.c edtest2_build.c gen_edtest2_build \\\n+\t*.dsyms *.fsyms *.keepsyms *.dbg *.mdbg *.mdbg.xz *.strip\n+\n+clean-local:\n+\t-rm -rf usr\n+\n+# We can't use automake's automatic dependency tracking, because it\n+# breaks when using bootstrap-lean.  Automatic dependency tracking\n+# with GCC bootstrap will cause some of the objects to depend on\n+# header files in prev-gcc/include, e.g., stddef.h and stdarg.h.  When\n+# using bootstrap-lean, prev-gcc is removed after each stage.  When\n+# running \"make install\", those header files will be gone, causing the\n+# library to be rebuilt at install time.  That may not succeed.\n+\n+# These manual dependencies do not include dependencies on unwind.h,\n+# even though that is part of GCC, because where to find it depends on\n+# whether we are being built as a host library or a target library.\n+\n+INCDIR = $(top_srcdir)/../include\n+alloc.lo: config.h backtrace.h internal.h\n+backtrace.lo: config.h backtrace.h internal.h\n+btest.lo: $(INCDIR)/filenames.h backtrace.h backtrace-supported.h\n+dwarf.lo: config.h $(INCDIR)/dwarf2.h $(INCDIR)/dwarf2.def \\\n+\t$(INCDIR)/filenames.h backtrace.h internal.h\n+elf.lo: config.h backtrace.h internal.h\n+fileline.lo: config.h backtrace.h internal.h\n+macho.lo: config.h backtrace.h internal.h\n+mmap.lo: config.h backtrace.h internal.h\n+mmapio.lo: config.h backtrace.h internal.h\n+mtest.lo: backtrace.h backtrace-supported.h\n+nounwind.lo: config.h internal.h\n+pecoff.lo: config.h backtrace.h internal.h\n+posix.lo: config.h backtrace.h internal.h\n+print.lo: config.h backtrace.h internal.h\n+read.lo: config.h backtrace.h internal.h\n+simple.lo: config.h backtrace.h internal.h\n+sort.lo: config.h backtrace.h internal.h\n+stest.lo: config.h backtrace.h internal.h\n+state.lo: config.h backtrace.h backtrace-supported.h internal.h\n+unknown.lo: config.h backtrace.h internal.h\n+xcoff.lo: config.h backtrace.h internal.h\n+xztest.lo: config.h backtrace.h backtrace-supported.h internal.h testlib.h\n+ztest.lo: config.h backtrace.h backtrace-supported.h internal.h testlib.h\n+\n+include $(top_srcdir)/../multilib.am"
    },
    {
      "sha": "2ba8dfa84289a486c1ff00a8563045c1b146ac54",
      "filename": "libbacktrace/Makefile.in",
      "status": "added",
      "additions": 2528,
      "deletions": 0,
      "changes": 2528,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/Makefile.in?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9"
    },
    {
      "sha": "e8b225745c9c639e67ea4f6fa0f97041ba978276",
      "filename": "libbacktrace/README",
      "status": "added",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/README",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/README",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/README?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,23 @@\n+The libbacktrace library\n+Initially written by Ian Lance Taylor <iant@google.com>\n+\n+The libbacktrace library may be linked into a program or library and\n+used to produce symbolic backtraces.  Sample uses would be to print a\n+detailed backtrace when an error occurs or to gather detailed\n+profiling information.\n+\n+The libbacktrace library is provided under a BSD license.  See the\n+source files for the exact license text.\n+\n+The public functions are declared and documented in the header file\n+backtrace.h, which should be #include'd by a user of the library.\n+\n+Building libbacktrace will generate a file backtrace-supported.h,\n+which a user of the library may use to determine whether backtraces\n+will work.  See the source file backtrace-supported.h.in for the\n+macros that it defines.\n+\n+As of September 2012, libbacktrace only supports ELF executables with\n+DWARF debugging information.  The library is written to make it\n+straightforward to add support for other object file and debugging\n+formats."
    },
    {
      "sha": "528e61739304d73b62e8734ab806e2dd0bb6e65c",
      "filename": "libbacktrace/aclocal.m4",
      "status": "added",
      "additions": 867,
      "deletions": 0,
      "changes": 867,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/aclocal.m4",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/aclocal.m4",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/aclocal.m4?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,867 @@\n+# generated automatically by aclocal 1.15.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.69],,\n+[m4_warning([this file was generated for autoconf 2.69.\n+You have another version of autoconf.  It may work, but is not guaranteed to.\n+If you have problems, you may need to regenerate the build system entirely.\n+To do so, use the procedure documented by the package, typically 'autoreconf'.])])\n+\n+# Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_AUTOMAKE_VERSION(VERSION)\n+# ----------------------------\n+# Automake X.Y traces this macro to ensure aclocal.m4 has been\n+# generated from the m4 files accompanying Automake X.Y.\n+# (This private macro should not be called outside this file.)\n+AC_DEFUN([AM_AUTOMAKE_VERSION],\n+[am__api_version='1.15'\n+dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to\n+dnl require some minimum version.  Point them to the right macro.\n+m4_if([$1], [1.15.1], [],\n+      [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl\n+])\n+\n+# _AM_AUTOCONF_VERSION(VERSION)\n+# -----------------------------\n+# aclocal traces this macro to find the Autoconf version.\n+# This is a private macro too.  Using m4_define simplifies\n+# the logic in aclocal, which can simply ignore this definition.\n+m4_define([_AM_AUTOCONF_VERSION], [])\n+\n+# AM_SET_CURRENT_AUTOMAKE_VERSION\n+# -------------------------------\n+# Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.\n+# This function is AC_REQUIREd by AM_INIT_AUTOMAKE.\n+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],\n+[AM_AUTOMAKE_VERSION([1.15.1])dnl\n+m4_ifndef([AC_AUTOCONF_VERSION],\n+  [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl\n+_AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])\n+\n+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-\n+\n+# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets\n+# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to\n+# '$srcdir', '$srcdir/..', or '$srcdir/../..'.\n+#\n+# Of course, Automake must honor this variable whenever it calls a\n+# tool from the auxiliary directory.  The problem is that $srcdir (and\n+# therefore $ac_aux_dir as well) can be either absolute or relative,\n+# depending on how configure is run.  This is pretty annoying, since\n+# it makes $ac_aux_dir quite unusable in subdirectories: in the top\n+# source directory, any form will work fine, but in subdirectories a\n+# relative path needs to be adjusted first.\n+#\n+# $ac_aux_dir/missing\n+#    fails when called from a subdirectory if $ac_aux_dir is relative\n+# $top_srcdir/$ac_aux_dir/missing\n+#    fails if $ac_aux_dir is absolute,\n+#    fails when called from a subdirectory in a VPATH build with\n+#          a relative $ac_aux_dir\n+#\n+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir\n+# are both prefixed by $srcdir.  In an in-source build this is usually\n+# harmless because $srcdir is '.', but things will broke when you\n+# start a VPATH build or use an absolute $srcdir.\n+#\n+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,\n+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:\n+#   am_aux_dir='\\$(top_srcdir)/'`expr \"$ac_aux_dir\" : \"$srcdir//*\\(.*\\)\"`\n+# and then we would define $MISSING as\n+#   MISSING=\"\\${SHELL} $am_aux_dir/missing\"\n+# This will work as long as MISSING is not called from configure, because\n+# unfortunately $(top_srcdir) has no meaning in configure.\n+# However there are other variables, like CC, which are often used in\n+# configure, and could therefore not use this \"fixed\" $ac_aux_dir.\n+#\n+# Another solution, used here, is to always expand $ac_aux_dir to an\n+# absolute PATH.  The drawback is that using absolute paths prevent a\n+# configured tree to be moved without reconfiguration.\n+\n+AC_DEFUN([AM_AUX_DIR_EXPAND],\n+[AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT])dnl\n+# Expand $ac_aux_dir to an absolute path.\n+am_aux_dir=`cd \"$ac_aux_dir\" && pwd`\n+])\n+\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ([2.52])dnl\n+ m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Do all the work for Automake.                             -*- Autoconf -*-\n+\n+# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This macro actually does too much.  Some checks are only needed if\n+# your package does certain things.  But this isn't really a big deal.\n+\n+dnl Redefine AC_PROG_CC to automatically invoke _AM_PROG_CC_C_O.\n+m4_define([AC_PROG_CC],\n+m4_defn([AC_PROG_CC])\n+[_AM_PROG_CC_C_O\n+])\n+\n+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])\n+# AM_INIT_AUTOMAKE([OPTIONS])\n+# -----------------------------------------------\n+# The call with PACKAGE and VERSION arguments is the old style\n+# call (pre autoconf-2.50), which is being phased out.  PACKAGE\n+# and VERSION should now be passed to AC_INIT and removed from\n+# the call to AM_INIT_AUTOMAKE.\n+# We support both call styles for the transition.  After\n+# the next Automake release, Autoconf can make the AC_INIT\n+# arguments mandatory, and then we can depend on a new Autoconf\n+# release and drop the old call support.\n+AC_DEFUN([AM_INIT_AUTOMAKE],\n+[AC_PREREQ([2.65])dnl\n+dnl Autoconf wants to disallow AM_ names.  We explicitly allow\n+dnl the ones we care about.\n+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl\n+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl\n+AC_REQUIRE([AC_PROG_INSTALL])dnl\n+if test \"`cd $srcdir && pwd`\" != \"`pwd`\"; then\n+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output\n+  # is not polluted with repeated \"-I.\"\n+  AC_SUBST([am__isrc], [' -I$(srcdir)'])_AM_SUBST_NOTMAKE([am__isrc])dnl\n+  # test to see if srcdir already configured\n+  if test -f $srcdir/config.status; then\n+    AC_MSG_ERROR([source directory already configured; run \"make distclean\" there first])\n+  fi\n+fi\n+\n+# test whether we have cygpath\n+if test -z \"$CYGPATH_W\"; then\n+  if (cygpath --version) >/dev/null 2>/dev/null; then\n+    CYGPATH_W='cygpath -w'\n+  else\n+    CYGPATH_W=echo\n+  fi\n+fi\n+AC_SUBST([CYGPATH_W])\n+\n+# Define the identity of the package.\n+dnl Distinguish between old-style and new-style calls.\n+m4_ifval([$2],\n+[AC_DIAGNOSE([obsolete],\n+             [$0: two- and three-arguments forms are deprecated.])\n+m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl\n+ AC_SUBST([PACKAGE], [$1])dnl\n+ AC_SUBST([VERSION], [$2])],\n+[_AM_SET_OPTIONS([$1])dnl\n+dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.\n+m4_if(\n+  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),\n+  [ok:ok],,\n+  [m4_fatal([AC_INIT should be called with package and version arguments])])dnl\n+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl\n+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl\n+\n+_AM_IF_OPTION([no-define],,\n+[AC_DEFINE_UNQUOTED([PACKAGE], [\"$PACKAGE\"], [Name of package])\n+ AC_DEFINE_UNQUOTED([VERSION], [\"$VERSION\"], [Version number of package])])dnl\n+\n+# Some tools Automake needs.\n+AC_REQUIRE([AM_SANITY_CHECK])dnl\n+AC_REQUIRE([AC_ARG_PROGRAM])dnl\n+AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])\n+AM_MISSING_PROG([AUTOCONF], [autoconf])\n+AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])\n+AM_MISSING_PROG([AUTOHEADER], [autoheader])\n+AM_MISSING_PROG([MAKEINFO], [makeinfo])\n+AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl\n+AC_REQUIRE([AC_PROG_MKDIR_P])dnl\n+# For better backward compatibility.  To be removed once Automake 1.9.x\n+# dies out for good.  For more background, see:\n+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00001.html>\n+# <http://lists.gnu.org/archive/html/automake/2012-07/msg00014.html>\n+AC_SUBST([mkdir_p], ['$(MKDIR_P)'])\n+# We need awk for the \"check\" target (and possibly the TAP driver).  The\n+# system \"awk\" is bad on some platforms.\n+AC_REQUIRE([AC_PROG_AWK])dnl\n+AC_REQUIRE([AC_PROG_MAKE_SET])dnl\n+AC_REQUIRE([AM_SET_LEADING_DOT])dnl\n+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],\n+\t      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],\n+\t\t\t     [_AM_PROG_TAR([v7])])])\n+_AM_IF_OPTION([no-dependencies],,\n+[AC_PROVIDE_IFELSE([AC_PROG_CC],\n+\t\t  [_AM_DEPENDENCIES([CC])],\n+\t\t  [m4_define([AC_PROG_CC],\n+\t\t\t     m4_defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_CXX],\n+\t\t  [_AM_DEPENDENCIES([CXX])],\n+\t\t  [m4_define([AC_PROG_CXX],\n+\t\t\t     m4_defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJC],\n+\t\t  [_AM_DEPENDENCIES([OBJC])],\n+\t\t  [m4_define([AC_PROG_OBJC],\n+\t\t\t     m4_defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl\n+AC_PROVIDE_IFELSE([AC_PROG_OBJCXX],\n+\t\t  [_AM_DEPENDENCIES([OBJCXX])],\n+\t\t  [m4_define([AC_PROG_OBJCXX],\n+\t\t\t     m4_defn([AC_PROG_OBJCXX])[_AM_DEPENDENCIES([OBJCXX])])])dnl\n+])\n+AC_REQUIRE([AM_SILENT_RULES])dnl\n+dnl The testsuite driver may need to know about EXEEXT, so add the\n+dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This\n+dnl macro is hooked onto _AC_COMPILER_EXEEXT early, see below.\n+AC_CONFIG_COMMANDS_PRE(dnl\n+[m4_provide_if([_AM_COMPILER_EXEEXT],\n+  [AM_CONDITIONAL([am__EXEEXT], [test -n \"$EXEEXT\"])])])dnl\n+\n+# POSIX will say in a future version that running \"rm -f\" with no argument\n+# is OK; and we want to be able to make that assumption in our Makefile\n+# recipes.  So use an aggressive probe to check that the usage we want is\n+# actually supported \"in the wild\" to an acceptable degree.\n+# See automake bug#10828.\n+# To make any issue more visible, cause the running configure to be aborted\n+# by default if the 'rm' program in use doesn't match our expectations; the\n+# user can still override this though.\n+if rm -f && rm -fr && rm -rf; then : OK; else\n+  cat >&2 <<'END'\n+Oops!\n+\n+Your 'rm' program seems unable to run without file operands specified\n+on the command line, even when the '-f' option is present.  This is contrary\n+to the behaviour of most rm programs out there, and not conforming with\n+the upcoming POSIX standard: <http://austingroupbugs.net/view.php?id=542>\n+\n+Please tell bug-automake@gnu.org about your system, including the value\n+of your $PATH and any error possibly output before this message.  This\n+can help us improve future automake versions.\n+\n+END\n+  if test x\"$ACCEPT_INFERIOR_RM_PROGRAM\" = x\"yes\"; then\n+    echo 'Configuration will proceed anyway, since you have set the' >&2\n+    echo 'ACCEPT_INFERIOR_RM_PROGRAM variable to \"yes\"' >&2\n+    echo >&2\n+  else\n+    cat >&2 <<'END'\n+Aborting the configuration process, to ensure you take notice of the issue.\n+\n+You can download and install GNU coreutils to get an 'rm' implementation\n+that behaves properly: <http://www.gnu.org/software/coreutils/>.\n+\n+If you want to complete the configuration process using your problematic\n+'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM\n+to \"yes\", and re-run configure.\n+\n+END\n+    AC_MSG_ERROR([Your 'rm' program is bad, sorry.])\n+  fi\n+fi\n+dnl The trailing newline in this macro's definition is deliberate, for\n+dnl backward compatibility and to allow trailing 'dnl'-style comments\n+dnl after the AM_INIT_AUTOMAKE invocation. See automake bug#16841.\n+])\n+\n+dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not\n+dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further\n+dnl mangled by Autoconf and run in a shell conditional statement.\n+m4_define([_AC_COMPILER_EXEEXT],\n+m4_defn([_AC_COMPILER_EXEEXT])[m4_provide([_AM_COMPILER_EXEEXT])])\n+\n+# When config.status generates a header, we must update the stamp-h file.\n+# This file resides in the same directory as the config header\n+# that is generated.  The stamp files are numbered to have different names.\n+\n+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the\n+# loop where config.status creates the headers, so we can generate\n+# our stamp files there.\n+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],\n+[# Compute $1's index in $config_headers.\n+_am_arg=$1\n+_am_stamp_count=1\n+for _am_header in $config_headers :; do\n+  case $_am_header in\n+    $_am_arg | $_am_arg:* )\n+      break ;;\n+    * )\n+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;\n+  esac\n+done\n+echo \"timestamp for $_am_arg\" >`AS_DIRNAME([\"$_am_arg\"])`/stamp-h[]$_am_stamp_count])\n+\n+# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_SH\n+# ------------------\n+# Define $install_sh.\n+AC_DEFUN([AM_PROG_INSTALL_SH],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+if test x\"${install_sh+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    install_sh=\"\\${SHELL} '$am_aux_dir/install-sh'\" ;;\n+  *)\n+    install_sh=\"\\${SHELL} $am_aux_dir/install-sh\"\n+  esac\n+fi\n+AC_SUBST([install_sh])])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless 'enable' is passed literally.\n+# For symmetry, 'disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],\n+      am_maintainer_other[ make rules and dependencies not useful\n+      (and sometimes confusing) to the casual installer])],\n+    [USE_MAINTAINER_MODE=$enableval],\n+    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-\n+\n+# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_MISSING_PROG(NAME, PROGRAM)\n+# ------------------------------\n+AC_DEFUN([AM_MISSING_PROG],\n+[AC_REQUIRE([AM_MISSING_HAS_RUN])\n+$1=${$1-\"${am_missing_run}$2\"}\n+AC_SUBST($1)])\n+\n+# AM_MISSING_HAS_RUN\n+# ------------------\n+# Define MISSING if not defined so far and test if it is modern enough.\n+# If it is, set am_missing_run to use it, otherwise, to nothing.\n+AC_DEFUN([AM_MISSING_HAS_RUN],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([missing])dnl\n+if test x\"${MISSING+set}\" != xset; then\n+  case $am_aux_dir in\n+  *\\ * | *\\\t*)\n+    MISSING=\"\\${SHELL} \\\"$am_aux_dir/missing\\\"\" ;;\n+  *)\n+    MISSING=\"\\${SHELL} $am_aux_dir/missing\" ;;\n+  esac\n+fi\n+# Use eval to expand $SHELL\n+if eval \"$MISSING --is-lightweight\"; then\n+  am_missing_run=\"$MISSING \"\n+else\n+  am_missing_run=\n+  AC_MSG_WARN(['missing' script is too old or missing])\n+fi\n+])\n+\n+# Helper functions for option handling.                     -*- Autoconf -*-\n+\n+# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# _AM_MANGLE_OPTION(NAME)\n+# -----------------------\n+AC_DEFUN([_AM_MANGLE_OPTION],\n+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])\n+\n+# _AM_SET_OPTION(NAME)\n+# --------------------\n+# Set option NAME.  Presently that only means defining a flag for this option.\n+AC_DEFUN([_AM_SET_OPTION],\n+[m4_define(_AM_MANGLE_OPTION([$1]), [1])])\n+\n+# _AM_SET_OPTIONS(OPTIONS)\n+# ------------------------\n+# OPTIONS is a space-separated list of Automake options.\n+AC_DEFUN([_AM_SET_OPTIONS],\n+[m4_foreach_w([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])\n+\n+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])\n+# -------------------------------------------\n+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.\n+AC_DEFUN([_AM_IF_OPTION],\n+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])\n+\n+# Copyright (C) 1999-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# _AM_PROG_CC_C_O\n+# ---------------\n+# Like AC_PROG_CC_C_O, but changed for automake.  We rewrite AC_PROG_CC\n+# to automatically call this.\n+AC_DEFUN([_AM_PROG_CC_C_O],\n+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl\n+AC_REQUIRE_AUX_FILE([compile])dnl\n+AC_LANG_PUSH([C])dnl\n+AC_CACHE_CHECK(\n+  [whether $CC understands -c and -o together],\n+  [am_cv_prog_cc_c_o],\n+  [AC_LANG_CONFTEST([AC_LANG_PROGRAM([])])\n+  # Make sure it works both with $CC and with simple cc.\n+  # Following AC_PROG_CC_C_O, we do the test twice because some\n+  # compilers refuse to overwrite an existing .o file with -o,\n+  # though they will create one.\n+  am_cv_prog_cc_c_o=yes\n+  for am_i in 1 2; do\n+    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \\\n+         && test -f conftest2.$ac_objext; then\n+      : OK\n+    else\n+      am_cv_prog_cc_c_o=no\n+      break\n+    fi\n+  done\n+  rm -f core conftest*\n+  unset am_i])\n+if test \"$am_cv_prog_cc_c_o\" != yes; then\n+   # Losing compiler, so override with the script.\n+   # FIXME: It is wrong to rewrite CC.\n+   # But if we don't then we get into trouble of one sort or another.\n+   # A longer-term fix would be to have automake use am__CC in this case,\n+   # and then we could set am__CC=\"\\$(top_srcdir)/compile \\$(CC)\"\n+   CC=\"$am_aux_dir/compile $CC\"\n+fi\n+AC_LANG_POP([C])])\n+\n+# For backward compatibility.\n+AC_DEFUN_ONCE([AM_PROG_CC_C_O], [AC_REQUIRE([AC_PROG_CC])])\n+\n+# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_RUN_LOG(COMMAND)\n+# -------------------\n+# Run COMMAND, save the exit status in ac_status, and log it.\n+# (This has been adapted from Autoconf's _AC_RUN_LOG macro.)\n+AC_DEFUN([AM_RUN_LOG],\n+[{ echo \"$as_me:$LINENO: $1\" >&AS_MESSAGE_LOG_FD\n+   ($1) >&AS_MESSAGE_LOG_FD 2>&AS_MESSAGE_LOG_FD\n+   ac_status=$?\n+   echo \"$as_me:$LINENO: \\$? = $ac_status\" >&AS_MESSAGE_LOG_FD\n+   (exit $ac_status); }])\n+\n+# Check to make sure that the build environment is sane.    -*- Autoconf -*-\n+\n+# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_SANITY_CHECK\n+# ---------------\n+AC_DEFUN([AM_SANITY_CHECK],\n+[AC_MSG_CHECKING([whether build environment is sane])\n+# Reject unsafe characters in $srcdir or the absolute working directory\n+# name.  Accept space and tab only in the latter.\n+am_lf='\n+'\n+case `pwd` in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf]]*)\n+    AC_MSG_ERROR([unsafe absolute working directory name]);;\n+esac\n+case $srcdir in\n+  *[[\\\\\\\"\\#\\$\\&\\'\\`$am_lf\\ \\\t]]*)\n+    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;\n+esac\n+\n+# Do 'set' in a subshell so we don't clobber the current shell's\n+# arguments.  Must try -L first in case configure is actually a\n+# symlink; some systems play weird games with the mod time of symlinks\n+# (eg FreeBSD returns the mod time of the symlink's containing\n+# directory).\n+if (\n+   am_has_slept=no\n+   for am_try in 1 2; do\n+     echo \"timestamp, slept: $am_has_slept\" > conftest.file\n+     set X `ls -Lt \"$srcdir/configure\" conftest.file 2> /dev/null`\n+     if test \"$[*]\" = \"X\"; then\n+\t# -L didn't work.\n+\tset X `ls -t \"$srcdir/configure\" conftest.file`\n+     fi\n+     if test \"$[*]\" != \"X $srcdir/configure conftest.file\" \\\n+\t&& test \"$[*]\" != \"X conftest.file $srcdir/configure\"; then\n+\n+\t# If neither matched, then we have a broken ls.  This can happen\n+\t# if, for instance, CONFIG_SHELL is bash and it inherits a\n+\t# broken ls alias from the environment.  This has actually\n+\t# happened.  Such a system could not be considered \"sane\".\n+\tAC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken\n+  alias in your environment])\n+     fi\n+     if test \"$[2]\" = conftest.file || test $am_try -eq 2; then\n+       break\n+     fi\n+     # Just in case.\n+     sleep 1\n+     am_has_slept=yes\n+   done\n+   test \"$[2]\" = conftest.file\n+   )\n+then\n+   # Ok.\n+   :\n+else\n+   AC_MSG_ERROR([newly created file is older than distributed files!\n+Check your system clock])\n+fi\n+AC_MSG_RESULT([yes])\n+# If we didn't sleep, we still need to ensure time stamps of config.status and\n+# generated files are strictly newer.\n+am_sleep_pid=\n+if grep 'slept: no' conftest.file >/dev/null 2>&1; then\n+  ( sleep 1 ) &\n+  am_sleep_pid=$!\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+  [AC_MSG_CHECKING([that generated files are newer than configure])\n+   if test -n \"$am_sleep_pid\"; then\n+     # Hide warnings about reused PIDs.\n+     wait $am_sleep_pid 2>/dev/null\n+   fi\n+   AC_MSG_RESULT([done])])\n+rm -f conftest.file\n+])\n+\n+# Copyright (C) 2009-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_SILENT_RULES([DEFAULT])\n+# --------------------------\n+# Enable less verbose build rules; with the default set to DEFAULT\n+# (\"yes\" being less verbose, \"no\" or empty being verbose).\n+AC_DEFUN([AM_SILENT_RULES],\n+[AC_ARG_ENABLE([silent-rules], [dnl\n+AS_HELP_STRING(\n+  [--enable-silent-rules],\n+  [less verbose build output (undo: \"make V=1\")])\n+AS_HELP_STRING(\n+  [--disable-silent-rules],\n+  [verbose build output (undo: \"make V=0\")])dnl\n+])\n+case $enable_silent_rules in @%:@ (((\n+  yes) AM_DEFAULT_VERBOSITY=0;;\n+   no) AM_DEFAULT_VERBOSITY=1;;\n+    *) AM_DEFAULT_VERBOSITY=m4_if([$1], [yes], [0], [1]);;\n+esac\n+dnl\n+dnl A few 'make' implementations (e.g., NonStop OS and NextStep)\n+dnl do not support nested variable expansions.\n+dnl See automake bug#9928 and bug#10237.\n+am_make=${MAKE-make}\n+AC_CACHE_CHECK([whether $am_make supports nested variables],\n+   [am_cv_make_support_nested_variables],\n+   [if AS_ECHO([['TRUE=$(BAR$(V))\n+BAR0=false\n+BAR1=true\n+V=1\n+am__doit:\n+\t@$(TRUE)\n+.PHONY: am__doit']]) | $am_make -f - >/dev/null 2>&1; then\n+  am_cv_make_support_nested_variables=yes\n+else\n+  am_cv_make_support_nested_variables=no\n+fi])\n+if test $am_cv_make_support_nested_variables = yes; then\n+  dnl Using '$V' instead of '$(V)' breaks IRIX make.\n+  AM_V='$(V)'\n+  AM_DEFAULT_V='$(AM_DEFAULT_VERBOSITY)'\n+else\n+  AM_V=$AM_DEFAULT_VERBOSITY\n+  AM_DEFAULT_V=$AM_DEFAULT_VERBOSITY\n+fi\n+AC_SUBST([AM_V])dnl\n+AM_SUBST_NOTMAKE([AM_V])dnl\n+AC_SUBST([AM_DEFAULT_V])dnl\n+AM_SUBST_NOTMAKE([AM_DEFAULT_V])dnl\n+AC_SUBST([AM_DEFAULT_VERBOSITY])dnl\n+AM_BACKSLASH='\\'\n+AC_SUBST([AM_BACKSLASH])dnl\n+_AM_SUBST_NOTMAKE([AM_BACKSLASH])dnl\n+])\n+\n+# Copyright (C) 2001-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_PROG_INSTALL_STRIP\n+# ---------------------\n+# One issue with vendor 'install' (even GNU) is that you can't\n+# specify the program used to strip binaries.  This is especially\n+# annoying in cross-compiling environments, where the build's strip\n+# is unlikely to handle the host's binaries.\n+# Fortunately install-sh will honor a STRIPPROG variable, so we\n+# always use install-sh in \"make install-strip\", and initialize\n+# STRIPPROG with the value of the STRIP variable (set by the user).\n+AC_DEFUN([AM_PROG_INSTALL_STRIP],\n+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl\n+# Installed binaries are usually stripped using 'strip' when the user\n+# run \"make install-strip\".  However 'strip' might not be the right\n+# tool to use in cross-compilation environments, therefore Automake\n+# will honor the 'STRIP' environment variable to overrule this program.\n+dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.\n+if test \"$cross_compiling\" != no; then\n+  AC_CHECK_TOOL([STRIP], [strip], :)\n+fi\n+INSTALL_STRIP_PROGRAM=\"\\$(install_sh) -c -s\"\n+AC_SUBST([INSTALL_STRIP_PROGRAM])])\n+\n+# Copyright (C) 2006-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# --------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+\n+# Check how to create a tarball.                            -*- Autoconf -*-\n+\n+# Copyright (C) 2004-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# _AM_PROG_TAR(FORMAT)\n+# --------------------\n+# Check how to create a tarball in format FORMAT.\n+# FORMAT should be one of 'v7', 'ustar', or 'pax'.\n+#\n+# Substitute a variable $(am__tar) that is a command\n+# writing to stdout a FORMAT-tarball containing the directory\n+# $tardir.\n+#     tardir=directory && $(am__tar) > result.tar\n+#\n+# Substitute a variable $(am__untar) that extract such\n+# a tarball read from stdin.\n+#     $(am__untar) < result.tar\n+#\n+AC_DEFUN([_AM_PROG_TAR],\n+[# Always define AMTAR for backward compatibility.  Yes, it's still used\n+# in the wild :-(  We should find a proper way to deprecate it ...\n+AC_SUBST([AMTAR], ['$${TAR-tar}'])\n+\n+# We'll loop over all known methods to create a tar archive until one works.\n+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'\n+\n+m4_if([$1], [v7],\n+  [am__tar='$${TAR-tar} chof - \"$$tardir\"' am__untar='$${TAR-tar} xf -'],\n+\n+  [m4_case([$1],\n+    [ustar],\n+     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.\n+      # There is notably a 21 bits limit for the UID and the GID.  In fact,\n+      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343\n+      # and bug#13588).\n+      am_max_uid=2097151 # 2^21 - 1\n+      am_max_gid=$am_max_uid\n+      # The $UID and $GID variables are not portable, so we need to resort\n+      # to the POSIX-mandated id(1) utility.  Errors in the 'id' calls\n+      # below are definitely unexpected, so allow the users to see them\n+      # (that is, avoid stderr redirection).\n+      am_uid=`id -u || echo unknown`\n+      am_gid=`id -g || echo unknown`\n+      AC_MSG_CHECKING([whether UID '$am_uid' is supported by ustar format])\n+      if test $am_uid -le $am_max_uid; then\n+         AC_MSG_RESULT([yes])\n+      else\n+         AC_MSG_RESULT([no])\n+         _am_tools=none\n+      fi\n+      AC_MSG_CHECKING([whether GID '$am_gid' is supported by ustar format])\n+      if test $am_gid -le $am_max_gid; then\n+         AC_MSG_RESULT([yes])\n+      else\n+        AC_MSG_RESULT([no])\n+        _am_tools=none\n+      fi],\n+\n+  [pax],\n+    [],\n+\n+  [m4_fatal([Unknown tar format])])\n+\n+  AC_MSG_CHECKING([how to create a $1 tar archive])\n+\n+  # Go ahead even if we have the value already cached.  We do so because we\n+  # need to set the values for the 'am__tar' and 'am__untar' variables.\n+  _am_tools=${am_cv_prog_tar_$1-$_am_tools}\n+\n+  for _am_tool in $_am_tools; do\n+    case $_am_tool in\n+    gnutar)\n+      for _am_tar in tar gnutar gtar; do\n+        AM_RUN_LOG([$_am_tar --version]) && break\n+      done\n+      am__tar=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$$tardir\"'\n+      am__tar_=\"$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - \"'\"$tardir\"'\n+      am__untar=\"$_am_tar -xf -\"\n+      ;;\n+    plaintar)\n+      # Must skip GNU tar: if it does not support --format= it doesn't create\n+      # ustar tarball either.\n+      (tar --version) >/dev/null 2>&1 && continue\n+      am__tar='tar chf - \"$$tardir\"'\n+      am__tar_='tar chf - \"$tardir\"'\n+      am__untar='tar xf -'\n+      ;;\n+    pax)\n+      am__tar='pax -L -x $1 -w \"$$tardir\"'\n+      am__tar_='pax -L -x $1 -w \"$tardir\"'\n+      am__untar='pax -r'\n+      ;;\n+    cpio)\n+      am__tar='find \"$$tardir\" -print | cpio -o -H $1 -L'\n+      am__tar_='find \"$tardir\" -print | cpio -o -H $1 -L'\n+      am__untar='cpio -i -H $1 -d'\n+      ;;\n+    none)\n+      am__tar=false\n+      am__tar_=false\n+      am__untar=false\n+      ;;\n+    esac\n+\n+    # If the value was cached, stop now.  We just wanted to have am__tar\n+    # and am__untar set.\n+    test -n \"${am_cv_prog_tar_$1}\" && break\n+\n+    # tar/untar a dummy directory, and stop if the command works.\n+    rm -rf conftest.dir\n+    mkdir conftest.dir\n+    echo GrepMe > conftest.dir/file\n+    AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])\n+    rm -rf conftest.dir\n+    if test -s conftest.tar; then\n+      AM_RUN_LOG([$am__untar <conftest.tar])\n+      AM_RUN_LOG([cat conftest.dir/file])\n+      grep GrepMe conftest.dir/file >/dev/null 2>&1 && break\n+    fi\n+  done\n+  rm -rf conftest.dir\n+\n+  AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])\n+  AC_MSG_RESULT([$am_cv_prog_tar_$1])])\n+\n+AC_SUBST([am__tar])\n+AC_SUBST([am__untar])\n+]) # _AM_PROG_TAR\n+\n+m4_include([../config/cet.m4])\n+m4_include([../config/enable.m4])\n+m4_include([../config/lead-dot.m4])\n+m4_include([../config/multi.m4])\n+m4_include([../config/override.m4])\n+m4_include([../config/stdint.m4])\n+m4_include([../config/unwind_ipinfo.m4])\n+m4_include([../config/warnings.m4])\n+m4_include([../libtool.m4])\n+m4_include([../ltoptions.m4])\n+m4_include([../ltsugar.m4])\n+m4_include([../ltversion.m4])\n+m4_include([../lt~obsolete.m4])"
    },
    {
      "sha": "ff2c8677c0685bb551c70fd36eb6c7888d7b9f76",
      "filename": "libbacktrace/alloc.c",
      "status": "added",
      "additions": 167,
      "deletions": 0,
      "changes": 167,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/alloc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/alloc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/alloc.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,167 @@\n+/* alloc.c -- Memory allocation without mmap.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Allocation routines to use on systems that do not support anonymous\n+   mmap.  This implementation just uses malloc, which means that the\n+   backtrace functions may not be safely invoked from a signal\n+   handler.  */\n+\n+/* Allocate memory like malloc.  If ERROR_CALLBACK is NULL, don't\n+   report an error.  */\n+\n+void *\n+backtrace_alloc (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t size_t size, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  void *ret;\n+\n+  ret = malloc (size);\n+  if (ret == NULL)\n+    {\n+      if (error_callback)\n+\terror_callback (data, \"malloc\", errno);\n+    }\n+  return ret;\n+}\n+\n+/* Free memory.  */\n+\n+void\n+backtrace_free (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\tvoid *p, size_t size ATTRIBUTE_UNUSED,\n+\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  free (p);\n+}\n+\n+/* Grow VEC by SIZE bytes.  */\n+\n+void *\n+backtrace_vector_grow (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t       size_t size, backtrace_error_callback error_callback,\n+\t\t       void *data, struct backtrace_vector *vec)\n+{\n+  void *ret;\n+\n+  if (size > vec->alc)\n+    {\n+      size_t alc;\n+      void *base;\n+\n+      if (vec->size == 0)\n+\talc = 32 * size;\n+      else if (vec->size >= 4096)\n+\talc = vec->size + 4096;\n+      else\n+\talc = 2 * vec->size;\n+\n+      if (alc < vec->size + size)\n+\talc = vec->size + size;\n+\n+      base = realloc (vec->base, alc);\n+      if (base == NULL)\n+\t{\n+\t  error_callback (data, \"realloc\", errno);\n+\t  return NULL;\n+\t}\n+\n+      vec->base = base;\n+      vec->alc = alc - vec->size;\n+    }\n+\n+  ret = (char *) vec->base + vec->size;\n+  vec->size += size;\n+  vec->alc -= size;\n+  return ret;\n+}\n+\n+/* Finish the current allocation on VEC.  */\n+\n+void *\n+backtrace_vector_finish (struct backtrace_state *state,\n+\t\t\t struct backtrace_vector *vec,\n+\t\t\t backtrace_error_callback error_callback,\n+\t\t\t void *data)\n+{\n+  void *ret;\n+\n+  /* With this allocator we call realloc in backtrace_vector_grow,\n+     which means we can't easily reuse the memory here.  So just\n+     release it.  */\n+  if (!backtrace_vector_release (state, vec, error_callback, data))\n+    return NULL;\n+  ret = vec->base;\n+  vec->base = NULL;\n+  vec->size = 0;\n+  vec->alc = 0;\n+  return ret;\n+}\n+\n+/* Release any extra space allocated for VEC.  */\n+\n+int\n+backtrace_vector_release (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t\t  struct backtrace_vector *vec,\n+\t\t\t  backtrace_error_callback error_callback,\n+\t\t\t  void *data)\n+{\n+  vec->alc = 0;\n+\n+  if (vec->size == 0)\n+    {\n+      /* As of C17, realloc with size 0 is marked as an obsolescent feature, use\n+\t free instead.  */\n+      free (vec->base);\n+      vec->base = NULL;\n+      return 1;\n+    }\n+\n+  vec->base = realloc (vec->base, vec->size);\n+  if (vec->base == NULL)\n+    {\n+      error_callback (data, \"realloc\", errno);\n+      return 0;\n+    }\n+\n+  return 1;\n+}"
    },
    {
      "sha": "bd0fbb658a9878f74876efce01d77e87438c9ded",
      "filename": "libbacktrace/allocfail.c",
      "status": "added",
      "additions": 136,
      "deletions": 0,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/allocfail.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/allocfail.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/allocfail.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,136 @@\n+/* allocfail.c -- Test for libbacktrace library\n+   Copyright (C) 2018-2021 Free Software Foundation, Inc.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"testlib.h\"\n+\n+extern uint64_t get_nr_allocs (void);\n+extern void set_fail_at_alloc (uint64_t);\n+extern int at_fail_alloc_p (void);\n+\n+static int test1 (void) __attribute__ ((noinline, unused));\n+static int f2 (int) __attribute__ ((noinline));\n+static int f3 (int, int) __attribute__ ((noinline));\n+\n+static unsigned callback_errors = 0;\n+\n+static void\n+error_callback_full (void *vdata ATTRIBUTE_UNUSED,\n+\t\t     const char *msg ATTRIBUTE_UNUSED,\n+\t\t     int errnum ATTRIBUTE_UNUSED)\n+{\n+  if (at_fail_alloc_p ())\n+    {\n+      set_fail_at_alloc (0);\n+      return;\n+    }\n+\n+  callback_errors++;\n+}\n+\n+static int\n+callback_full (void *vdata ATTRIBUTE_UNUSED, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t      const char *filename ATTRIBUTE_UNUSED,\n+\t      int lineno ATTRIBUTE_UNUSED,\n+\t      const char *function ATTRIBUTE_UNUSED)\n+{\n+\n+  return 0;\n+}\n+\n+static int\n+test1 (void)\n+{\n+  return f2 (__LINE__) + 1;\n+}\n+\n+static int\n+f2 (int f1line)\n+{\n+  return f3 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f3 (int f1line ATTRIBUTE_UNUSED, int f2line ATTRIBUTE_UNUSED)\n+{\n+  int i;\n+\n+  i = backtrace_full (state, 0, callback_full, error_callback_full, NULL);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      ++failures;\n+    }\n+\n+  if (callback_errors)\n+      ++failures;\n+\n+  return failures;\n+}\n+\n+/* Run all the tests.  */\n+\n+int\n+main (int argc, char **argv)\n+{\n+  uint64_t fail_at = 0;\n+\n+  if (argc == 2)\n+    {\n+      fail_at = atoi (argv[1]);\n+      set_fail_at_alloc (fail_at);\n+    }\n+\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_full, NULL);\n+  if (state == NULL)\n+    exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+\n+#if BACKTRACE_SUPPORTED\n+  test1 ();\n+#endif\n+\n+  if (argc == 1)\n+    fprintf (stderr, \"%llu\\n\", (long long unsigned) get_nr_allocs ());\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "1f9894fd2e8a084be4488d8095c4b01c13bd95a0",
      "filename": "libbacktrace/allocfail.sh",
      "status": "added",
      "additions": 104,
      "deletions": 0,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/allocfail.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/allocfail.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/allocfail.sh?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,104 @@\n+#!/bin/sh\n+\n+# allocfail.sh -- Test for libbacktrace library.\n+# Copyright (C) 2018-2021 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.\n+\n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+set -e\n+\n+if [ ! -f ./allocfail ]; then\n+    # Hard failure.\n+    exit 99\n+fi\n+\n+allocs=$(./allocfail 2>&1)\n+if [ \"$allocs\" = \"\" ]; then\n+    # Hard failure.\n+    exit 99\n+fi\n+\n+# This generates the following output:\n+# ...\n+# $ allocfail.sh\n+# allocs: 80495\n+# Status changed to 0 at 1\n+# Status changed to 1 at 3\n+# Status changed to 0 at 11\n+# Status changed to 1 at 12\n+# Status changed to 0 at 845\n+# ...\n+#\n+# We have status 0 for an allocation failure at:\n+# - 1 because backtrace_create_state handles failure robustly\n+# - 2 because the fail switches backtrace_full to !can_alloc mode.\n+# - 11 because failure of elf_open_debugfile_by_buildid does not generate an\n+#   error callback beyond the one for the allocation failure itself.\n+\n+echo \"allocs: $allocs\"\n+\n+step=1\n+i=1\n+passes=0\n+prev_status=-1\n+while [ $i -le $allocs ]; do\n+    if ./allocfail $i >/dev/null 2>&1; status=$?; then\n+\ttrue\n+    fi\n+    if [ $status -gt 1 ]; then\n+\techo \"Unallowed fail found: $i\"\n+\t# Failure.\n+\texit 1\n+    fi\n+\n+    # The test-case would run too long if we would excercise all allocs.\n+    # So, run with step 1 initially, and increase the step once we have 10\n+    # subsequent passes, and drop back to step 1 once we encounter another\n+    # failure.  This takes ~2.6 seconds on an i7-6600U CPU @ 2.60GHz.\n+    if [ $status -eq 0 ]; then\n+\tpasses=$(($passes + 1))\n+\tif [ $passes -ge 10 ]; then\n+\t    step=$((step * 10))\n+\t    passes=0\n+\tfi\n+    elif [ $status -eq 1 ]; then\n+\tpasses=0\n+\tstep=1\n+    fi\n+\n+    if [ $status -ne $prev_status ]; then\n+\techo \"Status changed to $status at $i\"\n+    fi\n+    prev_status=$status\n+\n+    i=$(($i + $step))\n+done\n+\n+# Success.\n+exit 0"
    },
    {
      "sha": "fcac485b237c2c2f8c1cd239b4e1b2bdb5aea2c0",
      "filename": "libbacktrace/atomic.c",
      "status": "added",
      "additions": 113,
      "deletions": 0,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/atomic.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/atomic.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/atomic.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,113 @@\n+/* atomic.c -- Support for atomic functions if not present.\n+   Copyright (C) 2013-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+#include \"internal.h\"\n+\n+/* This file holds implementations of the atomic functions that are\n+   used if the host compiler has the sync functions but not the atomic\n+   functions, as is true of versions of GCC before 4.7.  */\n+\n+#if !defined (HAVE_ATOMIC_FUNCTIONS) && defined (HAVE_SYNC_FUNCTIONS)\n+\n+/* Do an atomic load of a pointer.  */\n+\n+void *\n+backtrace_atomic_load_pointer (void *arg)\n+{\n+  void **pp;\n+  void *p;\n+\n+  pp = (void **) arg;\n+  p = *pp;\n+  while (!__sync_bool_compare_and_swap (pp, p, p))\n+    p = *pp;\n+  return p;\n+}\n+\n+/* Do an atomic load of an int.  */\n+\n+int\n+backtrace_atomic_load_int (int *p)\n+{\n+  int i;\n+\n+  i = *p;\n+  while (!__sync_bool_compare_and_swap (p, i, i))\n+    i = *p;\n+  return i;\n+}\n+\n+/* Do an atomic store of a pointer.  */\n+\n+void\n+backtrace_atomic_store_pointer (void *arg, void *p)\n+{\n+  void **pp;\n+  void *old;\n+\n+  pp = (void **) arg;\n+  old = *pp;\n+  while (!__sync_bool_compare_and_swap (pp, old, p))\n+    old = *pp;\n+}\n+\n+/* Do an atomic store of a size_t value.  */\n+\n+void\n+backtrace_atomic_store_size_t (size_t *p, size_t v)\n+{\n+  size_t old;\n+\n+  old = *p;\n+  while (!__sync_bool_compare_and_swap (p, old, v))\n+    old = *p;\n+}\n+\n+/* Do an atomic store of a int value.  */\n+\n+void\n+backtrace_atomic_store_int (int *p, int v)\n+{\n+  size_t old;\n+\n+  old = *p;\n+  while (!__sync_bool_compare_and_swap (p, old, v))\n+    old = *p;\n+}\n+\n+#endif"
    },
    {
      "sha": "2035c853a62f11f2d8466ddcd31f5287a86276ba",
      "filename": "libbacktrace/backtrace-supported.h.in",
      "status": "added",
      "additions": 66,
      "deletions": 0,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/backtrace-supported.h.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/backtrace-supported.h.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/backtrace-supported.h.in?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,66 @@\n+/* backtrace-supported.h.in -- Whether stack backtrace is supported.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* The file backtrace-supported.h.in is used by configure to generate\n+   the file backtrace-supported.h.  The file backtrace-supported.h may\n+   be #include'd to see whether the backtrace library will be able to\n+   get a backtrace and produce symbolic information.  */\n+\n+\n+/* BACKTRACE_SUPPORTED will be #define'd as 1 if the backtrace library\n+   should work, 0 if it will not.  Libraries may #include this to make\n+   other arrangements.  */\n+\n+#define BACKTRACE_SUPPORTED @BACKTRACE_SUPPORTED@\n+\n+/* BACKTRACE_USES_MALLOC will be #define'd as 1 if the backtrace\n+   library will call malloc as it works, 0 if it will call mmap\n+   instead.  This may be used to determine whether it is safe to call\n+   the backtrace functions from a signal handler.  In general this\n+   only applies to calls like backtrace and backtrace_pcinfo.  It does\n+   not apply to backtrace_simple, which never calls malloc.  It does\n+   not apply to backtrace_print, which always calls fprintf and\n+   therefore malloc.  */\n+\n+#define BACKTRACE_USES_MALLOC @BACKTRACE_USES_MALLOC@\n+\n+/* BACKTRACE_SUPPORTS_THREADS will be #define'd as 1 if the backtrace\n+   library is configured with threading support, 0 if not.  If this is\n+   0, the threaded parameter to backtrace_create_state must be passed\n+   as 0.  */\n+\n+#define BACKTRACE_SUPPORTS_THREADS @BACKTRACE_SUPPORTS_THREADS@\n+\n+/* BACKTRACE_SUPPORTS_DATA will be #defined'd as 1 if the backtrace_syminfo\n+   will work for variables.  It will always work for functions.  */\n+\n+#define BACKTRACE_SUPPORTS_DATA @BACKTRACE_SUPPORTS_DATA@"
    },
    {
      "sha": "7b629008525e594539b076ac00a65cfc1a1c4996",
      "filename": "libbacktrace/backtrace.c",
      "status": "added",
      "additions": 129,
      "deletions": 0,
      "changes": 129,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/backtrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/backtrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/backtrace.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,129 @@\n+/* backtrace.c -- Entry point for stack backtrace library.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"unwind.h\"\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* The main backtrace_full routine.  */\n+\n+/* Data passed through _Unwind_Backtrace.  */\n+\n+struct backtrace_data\n+{\n+  /* Number of frames to skip.  */\n+  int skip;\n+  /* Library state.  */\n+  struct backtrace_state *state;\n+  /* Callback routine.  */\n+  backtrace_full_callback callback;\n+  /* Error callback routine.  */\n+  backtrace_error_callback error_callback;\n+  /* Data to pass to callback routines.  */\n+  void *data;\n+  /* Value to return from backtrace_full.  */\n+  int ret;\n+  /* Whether there is any memory available.  */\n+  int can_alloc;\n+};\n+\n+/* Unwind library callback routine.  This is passed to\n+   _Unwind_Backtrace.  */\n+\n+static _Unwind_Reason_Code\n+unwind (struct _Unwind_Context *context, void *vdata)\n+{\n+  struct backtrace_data *bdata = (struct backtrace_data *) vdata;\n+  uintptr_t pc;\n+  int ip_before_insn = 0;\n+\n+#ifdef HAVE_GETIPINFO\n+  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  pc = _Unwind_GetIP (context);\n+#endif\n+\n+  if (bdata->skip > 0)\n+    {\n+      --bdata->skip;\n+      return _URC_NO_REASON;\n+    }\n+\n+  if (!ip_before_insn)\n+    --pc;\n+\n+  if (!bdata->can_alloc)\n+    bdata->ret = bdata->callback (bdata->data, pc, NULL, 0, NULL);\n+  else\n+    bdata->ret = backtrace_pcinfo (bdata->state, pc, bdata->callback,\n+\t\t\t\t   bdata->error_callback, bdata->data);\n+  if (bdata->ret != 0)\n+    return _URC_END_OF_STACK;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+/* Get a stack backtrace.  */\n+\n+int __attribute__((noinline))\n+backtrace_full (struct backtrace_state *state, int skip,\n+\t\tbacktrace_full_callback callback,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  struct backtrace_data bdata;\n+  void *p;\n+\n+  bdata.skip = skip + 1;\n+  bdata.state = state;\n+  bdata.callback = callback;\n+  bdata.error_callback = error_callback;\n+  bdata.data = data;\n+  bdata.ret = 0;\n+\n+  /* If we can't allocate any memory at all, don't try to produce\n+     file/line information.  */\n+  p = backtrace_alloc (state, 4096, NULL, NULL);\n+  if (p == NULL)\n+    bdata.can_alloc = 0;\n+  else\n+    {\n+      backtrace_free (state, p, 4096, NULL, NULL);\n+      bdata.can_alloc = 1;\n+    }\n+\n+  _Unwind_Backtrace (unwind, &bdata);\n+  return bdata.ret;\n+}"
    },
    {
      "sha": "caaa66d368659d304e70e1ab93c49bc0c28383a1",
      "filename": "libbacktrace/backtrace.h",
      "status": "added",
      "additions": 206,
      "deletions": 0,
      "changes": 206,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/backtrace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/backtrace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/backtrace.h?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,206 @@\n+/* backtrace.h -- Public header file for stack backtrace library.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#ifndef BACKTRACE_H\n+#define BACKTRACE_H\n+\n+#include <stddef.h>\n+#include <stdio.h>\n+\n+/* We want to get a definition for uintptr_t, but we still care about\n+   systems that don't have <stdint.h>.  */\n+#if defined(__GLIBC__) && __GLIBC__ >= 2\n+\n+#include <stdint.h>\n+\n+#elif defined(HAVE_STDINT_H)\n+\n+#include <stdint.h>\n+\n+#else\n+\n+/* Systems that don't have <stdint.h> must provide gstdint.h, e.g.,\n+   from GCC_HEADER_STDINT in configure.ac.  */\n+#include \"gstdint.h\"\n+\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* The backtrace state.  This struct is intentionally not defined in\n+   the public interface.  */\n+\n+struct backtrace_state;\n+\n+/* The type of the error callback argument to backtrace functions.\n+   This function, if not NULL, will be called for certain error cases.\n+   The DATA argument is passed to the function that calls this one.\n+   The MSG argument is an error message.  The ERRNUM argument, if\n+   greater than 0, holds an errno value.  The MSG buffer may become\n+   invalid after this function returns.\n+\n+   As a special case, the ERRNUM argument will be passed as -1 if no\n+   debug info can be found for the executable, or if the debug info\n+   exists but has an unsupported version, but the function requires\n+   debug info (e.g., backtrace_full, backtrace_pcinfo).  The MSG in\n+   this case will be something along the lines of \"no debug info\".\n+   Similarly, ERRNUM will be passed as -1 if there is no symbol table,\n+   but the function requires a symbol table (e.g., backtrace_syminfo).\n+   This may be used as a signal that some other approach should be\n+   tried.  */\n+\n+typedef void (*backtrace_error_callback) (void *data, const char *msg,\n+\t\t\t\t\t  int errnum);\n+\n+/* Create state information for the backtrace routines.  This must be\n+   called before any of the other routines, and its return value must\n+   be passed to all of the other routines.  FILENAME is the path name\n+   of the executable file; if it is NULL the library will try\n+   system-specific path names.  If not NULL, FILENAME must point to a\n+   permanent buffer.  If THREADED is non-zero the state may be\n+   accessed by multiple threads simultaneously, and the library will\n+   use appropriate atomic operations.  If THREADED is zero the state\n+   may only be accessed by one thread at a time.  This returns a state\n+   pointer on success, NULL on error.  If an error occurs, this will\n+   call the ERROR_CALLBACK routine.\n+\n+   Calling this function allocates resources that cannot be freed.\n+   There is no backtrace_free_state function.  The state is used to\n+   cache information that is expensive to recompute.  Programs are\n+   expected to call this function at most once and to save the return\n+   value for all later calls to backtrace functions.  */\n+\n+extern struct backtrace_state *backtrace_create_state (\n+    const char *filename, int threaded,\n+    backtrace_error_callback error_callback, void *data);\n+\n+/* The type of the callback argument to the backtrace_full function.\n+   DATA is the argument passed to backtrace_full.  PC is the program\n+   counter.  FILENAME is the name of the file containing PC, or NULL\n+   if not available.  LINENO is the line number in FILENAME containing\n+   PC, or 0 if not available.  FUNCTION is the name of the function\n+   containing PC, or NULL if not available.  This should return 0 to\n+   continuing tracing.  The FILENAME and FUNCTION buffers may become\n+   invalid after this function returns.  */\n+\n+typedef int (*backtrace_full_callback) (void *data, uintptr_t pc,\n+\t\t\t\t\tconst char *filename, int lineno,\n+\t\t\t\t\tconst char *function);\n+\n+/* Get a full stack backtrace.  SKIP is the number of frames to skip;\n+   passing 0 will start the trace with the function calling\n+   backtrace_full.  DATA is passed to the callback routine.  If any\n+   call to CALLBACK returns a non-zero value, the stack backtrace\n+   stops, and backtrace returns that value; this may be used to limit\n+   the number of stack frames desired.  If all calls to CALLBACK\n+   return 0, backtrace returns 0.  The backtrace_full function will\n+   make at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   function requires debug info for the executable.  */\n+\n+extern int backtrace_full (struct backtrace_state *state, int skip,\n+\t\t\t   backtrace_full_callback callback,\n+\t\t\t   backtrace_error_callback error_callback,\n+\t\t\t   void *data);\n+\n+/* The type of the callback argument to the backtrace_simple function.\n+   DATA is the argument passed to simple_backtrace.  PC is the program\n+   counter.  This should return 0 to continue tracing.  */\n+\n+typedef int (*backtrace_simple_callback) (void *data, uintptr_t pc);\n+\n+/* Get a simple backtrace.  SKIP is the number of frames to skip, as\n+   in backtrace.  DATA is passed to the callback routine.  If any call\n+   to CALLBACK returns a non-zero value, the stack backtrace stops,\n+   and backtrace_simple returns that value.  Otherwise\n+   backtrace_simple returns 0.  The backtrace_simple function will\n+   make at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   function does not require any debug info for the executable.  */\n+\n+extern int backtrace_simple (struct backtrace_state *state, int skip,\n+\t\t\t     backtrace_simple_callback callback,\n+\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t     void *data);\n+\n+/* Print the current backtrace in a user readable format to a FILE.\n+   SKIP is the number of frames to skip, as in backtrace_full.  Any\n+   error messages are printed to stderr.  This function requires debug\n+   info for the executable.  */\n+\n+extern void backtrace_print (struct backtrace_state *state, int skip, FILE *);\n+\n+/* Given PC, a program counter in the current program, call the\n+   callback function with filename, line number, and function name\n+   information.  This will normally call the callback function exactly\n+   once.  However, if the PC happens to describe an inlined call, and\n+   the debugging information contains the necessary information, then\n+   this may call the callback function multiple times.  This will make\n+   at least one call to either CALLBACK or ERROR_CALLBACK.  This\n+   returns the first non-zero value returned by CALLBACK, or 0.  */\n+\n+extern int backtrace_pcinfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t     backtrace_full_callback callback,\n+\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t     void *data);\n+\n+/* The type of the callback argument to backtrace_syminfo.  DATA and\n+   PC are the arguments passed to backtrace_syminfo.  SYMNAME is the\n+   name of the symbol for the corresponding code.  SYMVAL is the\n+   value and SYMSIZE is the size of the symbol.  SYMNAME will be NULL\n+   if no error occurred but the symbol could not be found.  */\n+\n+typedef void (*backtrace_syminfo_callback) (void *data, uintptr_t pc,\n+\t\t\t\t\t    const char *symname,\n+\t\t\t\t\t    uintptr_t symval,\n+\t\t\t\t\t    uintptr_t symsize);\n+\n+/* Given ADDR, an address or program counter in the current program,\n+   call the callback information with the symbol name and value\n+   describing the function or variable in which ADDR may be found.\n+   This will call either CALLBACK or ERROR_CALLBACK exactly once.\n+   This returns 1 on success, 0 on failure.  This function requires\n+   the symbol table but does not require the debug info.  Note that if\n+   the symbol table is present but ADDR could not be found in the\n+   table, CALLBACK will be called with a NULL SYMNAME argument.\n+   Returns 1 on success, 0 on error.  */\n+\n+extern int backtrace_syminfo (struct backtrace_state *state, uintptr_t addr,\n+\t\t\t      backtrace_syminfo_callback callback,\n+\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t      void *data);\n+\n+#ifdef __cplusplus\n+} /* End extern \"C\".  */\n+#endif\n+\n+#endif"
    },
    {
      "sha": "9f9c03babf30ae8b9cb95fe922bba5788de5bd03",
      "filename": "libbacktrace/btest.c",
      "status": "added",
      "additions": 501,
      "deletions": 0,
      "changes": 501,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/btest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/btest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/btest.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,501 @@\n+/* btest.c -- Test for libbacktrace library\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* This program tests the externally visible interfaces of the\n+   libbacktrace library.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"testlib.h\"\n+\n+/* Test the backtrace function with non-inlined functions.  */\n+\n+static int test1 (void) __attribute__ ((noinline, noclone, unused));\n+static int f2 (int) __attribute__ ((noinline, noclone));\n+static int f3 (int, int) __attribute__ ((noinline, noclone));\n+\n+static int\n+test1 (void)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return f2 (__LINE__) + 1;\n+}\n+\n+static int\n+f2 (int f1line)\n+{\n+  return f3 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f3 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (data.index < 3)\n+    {\n+      fprintf (stderr,\n+\t       \"test1: not enough frames; got %zu, expected at least 3\\n\",\n+\t       data.index);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test1\", 0, all, f3line, \"f3\", \"btest.c\", &data.failed);\n+  check (\"test1\", 1, all, f2line, \"f2\", \"btest.c\", &data.failed);\n+  check (\"test1\", 2, all, f1line, \"test1\", \"btest.c\", &data.failed);\n+\n+  printf (\"%s: backtrace_full noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace function with inlined functions.  */\n+\n+static inline int test2 (void) __attribute__ ((always_inline, unused));\n+static inline int f12 (int) __attribute__ ((always_inline));\n+static inline int f13 (int, int) __attribute__ ((always_inline));\n+\n+static inline int\n+test2 (void)\n+{\n+  return f12 (__LINE__) + 1;\n+}\n+\n+static inline int\n+f12 (int f1line)\n+{\n+  return f13 (f1line, __LINE__) + 2;\n+}\n+\n+static inline int\n+f13 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test2: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test2\", 0, all, f3line, \"f13\", \"btest.c\", &data.failed);\n+  check (\"test2\", 1, all, f2line, \"f12\", \"btest.c\", &data.failed);\n+  check (\"test2\", 2, all, f1line, \"test2\", \"btest.c\", &data.failed);\n+\n+  printf (\"%s: backtrace_full inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace_simple function with non-inlined functions.  */\n+\n+static int test3 (void) __attribute__ ((noinline, noclone, unused));\n+static int f22 (int) __attribute__ ((noinline, noclone));\n+static int f23 (int, int) __attribute__ ((noinline, noclone));\n+\n+static int\n+test3 (void)\n+{\n+  return f22 (__LINE__) + 1;\n+}\n+\n+static int\n+f22 (int f1line)\n+{\n+  return f23 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f23 (int f1line, int f2line)\n+{\n+  uintptr_t addrs[20];\n+  struct sdata data;\n+  int f3line;\n+  int i;\n+\n+  data.addrs = &addrs[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (!data.failed)\n+    {\n+      struct info all[20];\n+      struct bdata bdata;\n+      int j;\n+\n+      bdata.all = &all[0];\n+      bdata.index = 0;\n+      bdata.max = 20;\n+      bdata.failed = 0;\n+\n+      for (j = 0; j < 3; ++j)\n+\t{\n+\t  i = backtrace_pcinfo (state, addrs[j], callback_one,\n+\t\t\t\terror_callback_one, &bdata);\n+\t  if (i != 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test3: unexpected return value \"\n+\t\t\t\"from backtrace_pcinfo %d\\n\"),\n+\t\t       i);\n+\t      bdata.failed = 1;\n+\t    }\n+\t  if (!bdata.failed && bdata.index != (size_t) (j + 1))\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"wrong number of calls from backtrace_pcinfo \"\n+\t\t\t\"got %u expected %d\\n\"),\n+\t\t       (unsigned int) bdata.index, j + 1);\n+\t      bdata.failed = 1;\n+\t    }\n+\t}\n+\n+      check (\"test3\", 0, all, f3line, \"f23\", \"btest.c\", &bdata.failed);\n+      check (\"test3\", 1, all, f2line, \"f22\", \"btest.c\", &bdata.failed);\n+      check (\"test3\", 2, all, f1line, \"test3\", \"btest.c\", &bdata.failed);\n+\n+      if (bdata.failed)\n+\tdata.failed = 1;\n+\n+      for (j = 0; j < 3; ++j)\n+\t{\n+\t  struct symdata symdata;\n+\n+\t  symdata.name = NULL;\n+\t  symdata.val = 0;\n+\t  symdata.size = 0;\n+\t  symdata.failed = 0;\n+\n+\t  i = backtrace_syminfo (state, addrs[j], callback_three,\n+\t\t\t\t error_callback_three, &symdata);\n+\t  if (i == 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test3: [%d]: unexpected return value \"\n+\t\t\t\"from backtrace_syminfo %d\\n\"),\n+\t\t       j, i);\n+\t      symdata.failed = 1;\n+\t    }\n+\n+\t  if (!symdata.failed)\n+\t    {\n+\t      const char *expected;\n+\n+\t      switch (j)\n+\t\t{\n+\t\tcase 0:\n+\t\t  expected = \"f23\";\n+\t\t  break;\n+\t\tcase 1:\n+\t\t  expected = \"f22\";\n+\t\t  break;\n+\t\tcase 2:\n+\t\t  expected = \"test3\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  assert (0);\n+\t\t}\n+\n+\t      if (symdata.name == NULL)\n+\t\t{\n+\t\t  fprintf (stderr, \"test3: [%d]: NULL syminfo name\\n\", j);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t      /* Use strncmp, not strcmp, because GCC might create a\n+\t\t clone.  */\n+\t      else if (strncmp (symdata.name, expected, strlen (expected))\n+\t\t       != 0)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   (\"test3: [%d]: unexpected syminfo name \"\n+\t\t\t    \"got %s expected %s\\n\"),\n+\t\t\t   j, symdata.name, expected);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t    }\n+\n+\t  if (symdata.failed)\n+\t    data.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_simple noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace_simple function with inlined functions.  */\n+\n+static inline int test4 (void) __attribute__ ((always_inline, unused));\n+static inline int f32 (int) __attribute__ ((always_inline));\n+static inline int f33 (int, int) __attribute__ ((always_inline));\n+\n+static inline int\n+test4 (void)\n+{\n+  return f32 (__LINE__) + 1;\n+}\n+\n+static inline int\n+f32 (int f1line)\n+{\n+  return f33 (f1line, __LINE__) + 2;\n+}\n+\n+static inline int\n+f33 (int f1line, int f2line)\n+{\n+  uintptr_t addrs[20];\n+  struct sdata data;\n+  int f3line;\n+  int i;\n+\n+  data.addrs = &addrs[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (!data.failed)\n+    {\n+      struct info all[20];\n+      struct bdata bdata;\n+\n+      bdata.all = &all[0];\n+      bdata.index = 0;\n+      bdata.max = 20;\n+      bdata.failed = 0;\n+\n+      i = backtrace_pcinfo (state, addrs[0], callback_one, error_callback_one,\n+\t\t\t    &bdata);\n+      if (i != 0)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   (\"test4: unexpected return value \"\n+\t\t    \"from backtrace_pcinfo %d\\n\"),\n+\t\t   i);\n+\t  bdata.failed = 1;\n+\t}\n+\n+      check (\"test4\", 0, all, f3line, \"f33\", \"btest.c\", &bdata.failed);\n+      check (\"test4\", 1, all, f2line, \"f32\", \"btest.c\", &bdata.failed);\n+      check (\"test4\", 2, all, f1line, \"test4\", \"btest.c\", &bdata.failed);\n+\n+      if (bdata.failed)\n+\tdata.failed = 1;\n+    }\n+\n+  printf (\"%s: backtrace_simple inline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+static int test5 (void) __attribute__ ((unused));\n+\n+int global = 1;\n+\n+static int\n+test5 (void)\n+{\n+  struct symdata symdata;\n+  int i;\n+  uintptr_t addr = (uintptr_t) &global;\n+\n+  if (sizeof (global) > 1)\n+    addr += 1;\n+\n+  symdata.name = NULL;\n+  symdata.val = 0;\n+  symdata.size = 0;\n+  symdata.failed = 0;\n+\n+  i = backtrace_syminfo (state, addr, callback_three,\n+\t\t\t error_callback_three, &symdata);\n+  if (i == 0)\n+    {\n+      fprintf (stderr,\n+\t       \"test5: unexpected return value from backtrace_syminfo %d\\n\",\n+\t       i);\n+      symdata.failed = 1;\n+    }\n+\n+  if (!symdata.failed)\n+    {\n+      if (symdata.name == NULL)\n+\t{\n+\t  fprintf (stderr, \"test5: NULL syminfo name\\n\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (!(strncmp (symdata.name, \"global\", 6) == 0\n+\t\t && (symdata.name[6] == '\\0'|| symdata.name[6] == '.')))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo name got %s expected %s\\n\",\n+\t\t   symdata.name, \"global\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (symdata.val != (uintptr_t) &global)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo value got %lx expected %lx\\n\",\n+\t\t   (unsigned long) symdata.val,\n+\t\t   (unsigned long) (uintptr_t) &global);\n+\t  symdata.failed = 1;\n+\t}\n+      else if (symdata.size != sizeof (global))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo size got %lx expected %lx\\n\",\n+\t\t   (unsigned long) symdata.size,\n+\t\t   (unsigned long) sizeof (global));\n+\t  symdata.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_syminfo variable\\n\",\n+\t  symdata.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (symdata.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Check that are no files left open.  */\n+\n+static void\n+check_open_files (void)\n+{\n+  int i;\n+\n+  for (i = 3; i < 10; i++)\n+    {\n+      if (close (i) == 0)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"ERROR: descriptor %d still open after tests complete\\n\",\n+\t\t   i);\n+\t  ++failures;\n+\t}\n+    }\n+}\n+\n+/* Run all the tests.  */\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+#if BACKTRACE_SUPPORTED\n+  test1 ();\n+  test2 ();\n+  test3 ();\n+  test4 ();\n+#if BACKTRACE_SUPPORTS_DATA\n+  test5 ();\n+#endif\n+#endif\n+\n+  check_open_files ();\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "cdb416e6406129911d2a149d2f4339dd86ebc3dc",
      "filename": "libbacktrace/config.h.in",
      "status": "added",
      "additions": 184,
      "deletions": 0,
      "changes": 184,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/config.h.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/config.h.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/config.h.in?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,184 @@\n+/* config.h.in.  Generated from configure.ac by autoheader.  */\n+\n+/* ELF size: 32 or 64 */\n+#undef BACKTRACE_ELF_SIZE\n+\n+/* XCOFF size: 32 or 64 */\n+#undef BACKTRACE_XCOFF_SIZE\n+\n+/* Define to 1 if you have the __atomic functions */\n+#undef HAVE_ATOMIC_FUNCTIONS\n+\n+/* Define to 1 if you have the `clock_gettime' function. */\n+#undef HAVE_CLOCK_GETTIME\n+\n+/* Define to 1 if you have the declaration of `getpagesize', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_GETPAGESIZE\n+\n+/* Define to 1 if you have the declaration of `strnlen', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_STRNLEN\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define if dl_iterate_phdr is available. */\n+#undef HAVE_DL_ITERATE_PHDR\n+\n+/* Define to 1 if you have the fcntl function */\n+#undef HAVE_FCNTL\n+\n+/* Define if getexecname is available. */\n+#undef HAVE_GETEXECNAME\n+\n+/* Define if _Unwind_GetIPInfo is available. */\n+#undef HAVE_GETIPINFO\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have KERN_PROC and KERN_PROC_PATHNAME in <sys/sysctl.h>.\n+   */\n+#undef HAVE_KERN_PROC\n+\n+/* Define to 1 if you have KERN_PROCARGS and KERN_PROC_PATHNAME in\n+   <sys/sysctl.h>. */\n+#undef HAVE_KERN_PROC_ARGS\n+\n+/* Define if -llzma is available. */\n+#undef HAVE_LIBLZMA\n+\n+/* Define to 1 if you have the <link.h> header file. */\n+#undef HAVE_LINK_H\n+\n+/* Define if AIX loadquery is available. */\n+#undef HAVE_LOADQUERY\n+\n+/* Define to 1 if you have the `lstat' function. */\n+#undef HAVE_LSTAT\n+\n+/* Define to 1 if you have the <mach-o/dyld.h> header file. */\n+#undef HAVE_MACH_O_DYLD_H\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the `readlink' function. */\n+#undef HAVE_READLINK\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if you have the __sync functions */\n+#undef HAVE_SYNC_FUNCTIONS\n+\n+/* Define to 1 if you have the <sys/ldr.h> header file. */\n+#undef HAVE_SYS_LDR_H\n+\n+/* Define to 1 if you have the <sys/mman.h> header file. */\n+#undef HAVE_SYS_MMAN_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define if -lz is available. */\n+#undef HAVE_ZLIB\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* The size of `char', as computed by sizeof. */\n+#undef SIZEOF_CHAR\n+\n+/* The size of `int', as computed by sizeof. */\n+#undef SIZEOF_INT\n+\n+/* The size of `long', as computed by sizeof. */\n+#undef SIZEOF_LONG\n+\n+/* The size of `short', as computed by sizeof. */\n+#undef SIZEOF_SHORT\n+\n+/* The size of `void *', as computed by sizeof. */\n+#undef SIZEOF_VOID_P\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Enable extensions on AIX 3, Interix.  */\n+#ifndef _ALL_SOURCE\n+# undef _ALL_SOURCE\n+#endif\n+/* Enable GNU extensions on systems that have them.  */\n+#ifndef _GNU_SOURCE\n+# undef _GNU_SOURCE\n+#endif\n+/* Enable threading extensions on Solaris.  */\n+#ifndef _POSIX_PTHREAD_SEMANTICS\n+# undef _POSIX_PTHREAD_SEMANTICS\n+#endif\n+/* Enable extensions on HP NonStop.  */\n+#ifndef _TANDEM_SOURCE\n+# undef _TANDEM_SOURCE\n+#endif\n+/* Enable general extensions on Solaris.  */\n+#ifndef __EXTENSIONS__\n+# undef __EXTENSIONS__\n+#endif\n+\n+\n+/* Enable large inode numbers on Mac OS X 10.5.  */\n+#ifndef _DARWIN_USE_64_BIT_INODE\n+# define _DARWIN_USE_64_BIT_INODE 1\n+#endif\n+\n+/* Number of bits in a file offset, on hosts where this is settable. */\n+#undef _FILE_OFFSET_BITS\n+\n+/* Define for large files, on AIX-style hosts. */\n+#undef _LARGE_FILES\n+\n+/* Define to 1 if on MINIX. */\n+#undef _MINIX\n+\n+/* Define to 2 if the system does not provide POSIX.1 features except with\n+   this defined. */\n+#undef _POSIX_1_SOURCE\n+\n+/* Define to 1 if you need to in order for `stat' and other things to work. */\n+#undef _POSIX_SOURCE"
    },
    {
      "sha": "a2f33c0f35db474d91ddd8e219a6af3f15024b68",
      "filename": "libbacktrace/configure",
      "status": "added",
      "additions": 16893,
      "deletions": 0,
      "changes": 16893,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/configure?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9"
    },
    {
      "sha": "43a33a66b8229dab6780e63e29b655671a90ab9d",
      "filename": "libbacktrace/configure.ac",
      "status": "added",
      "additions": 581,
      "deletions": 0,
      "changes": 581,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/configure.ac?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,581 @@\n+# configure.ac -- Backtrace configure script.\n+# Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.\n+\n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+AC_INIT(package-unused, version-unused,, libbacktrace)\n+AC_CONFIG_SRCDIR(backtrace.h)\n+AC_CONFIG_HEADER(config.h)\n+\n+if test -n \"${with_target_subdir}\"; then\n+  AM_ENABLE_MULTILIB(, ..)\n+fi\n+\n+AC_CANONICAL_SYSTEM\n+target_alias=${target_alias-$host_alias}\n+\n+AC_USE_SYSTEM_EXTENSIONS\n+\n+libtool_VERSION=1:0:0\n+AC_SUBST(libtool_VERSION)\n+\n+# 1.11.1: Require that version of automake.\n+# foreign: Don't require README, INSTALL, NEWS, etc.\n+# no-define: Don't define PACKAGE and VERSION.\n+# no-dependencies: Don't generate automatic dependencies.\n+#    (because it breaks when using bootstrap-lean, since some of the\n+#    headers are gone at \"make install\" time).\n+# -Wall: Issue all automake warnings.\n+# -Wno-portability: Don't warn about constructs supported by GNU make.\n+#    (because GCC requires GNU make anyhow).\n+AM_INIT_AUTOMAKE([1.11.1 foreign no-dist no-define no-dependencies -Wall -Wno-portability])\n+\n+AM_MAINTAINER_MODE\n+\n+AC_ARG_WITH(target-subdir,\n+[  --with-target-subdir=SUBDIR      Configuring in a subdirectory for target])\n+\n+# We must force CC to /not/ be precious variables; otherwise\n+# the wrong, non-multilib-adjusted value will be used in multilibs.\n+# As a side effect, we have to subst CFLAGS ourselves.\n+m4_rename([_AC_ARG_VAR_PRECIOUS],[backtrace_PRECIOUS])\n+m4_define([_AC_ARG_VAR_PRECIOUS],[])\n+AC_PROG_CC\n+m4_rename_force([backtrace_PRECIOUS],[_AC_ARG_VAR_PRECIOUS])\n+\n+AC_SUBST(CFLAGS)\n+\n+AC_PROG_RANLIB\n+\n+AC_PROG_AWK\n+case \"$AWK\" in\n+\"\") AC_MSG_ERROR([can't build without awk]) ;;\n+esac\n+\n+AC_CHECK_PROG(DWZ, dwz, dwz)\n+AM_CONDITIONAL(HAVE_DWZ, test \"$DWZ\" != \"\")\n+\n+LT_INIT\n+AM_PROG_LIBTOOL\n+\n+AC_SYS_LARGEFILE\n+\n+backtrace_supported=yes\n+\n+if test -n \"${with_target_subdir}\"; then\n+  # We are compiling a GCC library.  We can assume that the unwind\n+  # library exists.\n+  BACKTRACE_FILE=\"backtrace.lo simple.lo\"\n+else\n+  AC_CHECK_HEADER([unwind.h],\n+    [AC_CHECK_FUNC([_Unwind_Backtrace],\n+\t           [BACKTRACE_FILE=\"backtrace.lo simple.lo\"],\n+\t\t   [BACKTRACE_FILE=\"nounwind.lo\"\n+                    backtrace_supported=no])],\n+    [BACKTRACE_FILE=\"nounwind.lo\"\n+     backtrace_supported=no])\n+fi\n+AC_SUBST(BACKTRACE_FILE)\n+\n+EXTRA_FLAGS=\n+if test -n \"${with_target_subdir}\"; then\n+  EXTRA_FLAGS=\"-funwind-tables -frandom-seed=\\$@\"\n+else\n+  AC_CACHE_CHECK([for -funwind-tables option],\n+    [libbacktrace_cv_c_unwind_tables],\n+    [CFLAGS_hold=\"$CFLAGS\"\n+     CFLAGS=\"$CFLAGS -funwind-tables\"\n+     AC_COMPILE_IFELSE(\n+       [AC_LANG_PROGRAM([static int f() { return 0; }], [return f();])],\n+       [libbacktrace_cv_c_unwind_tables=yes],\n+       [libbacktrace_cv_c_unwind_tables=no])\n+     CFLAGS=\"$CFLAGS_hold\"])\n+  if test \"$libbacktrace_cv_c_unwind_tables\" = \"yes\"; then\n+    EXTRA_FLAGS=-funwind-tables\n+  fi\n+  AC_CACHE_CHECK([for -frandom-seed=string option],\n+    [libbacktrace_cv_c_random_seed_string],\n+    [CFLAGS_hold=\"$CFLAGS\"\n+     CFLAGS=\"$CFLAGS -frandom-seed=conftest.lo\"\n+     AC_COMPILE_IFELSE(\n+       [AC_LANG_PROGRAM([], [return 0;])],\n+       [libbacktrace_cv_c_random_seed_string=yes],\n+       [libbacktrace_cv_c_random_seed_string=no])\n+     CFLAGS=\"$CFLAGS_hold\"])\n+  if test \"$libbacktrace_cv_c_random_seed_string\" = \"yes\"; then\n+    EXTRA_FLAGS=\"$EXTRA_FLAGS -frandom-seed=\\$@\"\n+  fi\n+fi\n+\n+if test -n \"${with_target_subdir}\"; then\n+  # Add CET specific flags is Intel CET is enabled.\n+  GCC_CET_FLAGS(CET_FLAGS)\n+  EXTRA_FLAGS=\"$EXTRA_FLAGS $CET_FLAGS\"\n+fi\n+AC_SUBST(EXTRA_FLAGS)\n+\n+ACX_PROG_CC_WARNING_OPTS([-W -Wall -Wwrite-strings -Wstrict-prototypes \\\n+\t\t\t  -Wmissing-prototypes -Wold-style-definition \\\n+\t\t\t  -Wmissing-format-attribute -Wcast-qual],\n+\t\t\t  [WARN_FLAGS])\n+\n+if test -n \"${with_target_subdir}\"; then\n+  WARN_FLAGS=\"$WARN_FLAGS -Werror\"\n+fi\n+\n+AC_SUBST(WARN_FLAGS)\n+\n+if test -n \"${with_target_subdir}\"; then\n+  GCC_CHECK_UNWIND_GETIPINFO\n+else\n+  ac_save_CFFLAGS=\"$CFLAGS\"\n+  CFLAGS=\"$CFLAGS -Werror-implicit-function-declaration\"\n+  AC_MSG_CHECKING([for _Unwind_GetIPInfo])\n+  AC_LINK_IFELSE(\n+    [AC_LANG_PROGRAM(\n+       [#include \"unwind.h\"\n+\tstruct _Unwind_Context *context;\n+\tint ip_before_insn = 0;],\n+\t[return _Unwind_GetIPInfo (context, &ip_before_insn);])],\n+\t[have_unwind_getipinfo=yes], [have_unwind_getipinfo=no])\n+  CFLAGS=\"$ac_save_CFLAGS\"\n+  AC_MSG_RESULT([$have_unwind_getipinfo])\n+  if test \"$have_unwind_getipinfo\" = \"yes\"; then\n+    AC_DEFINE(HAVE_GETIPINFO, 1, [Define if _Unwind_GetIPInfo is available.])\n+  fi\n+fi\n+\n+# Enable --enable-host-shared.\n+AC_ARG_ENABLE(host-shared,\n+[AS_HELP_STRING([--enable-host-shared],\n+\t\t[build host code as shared libraries])],\n+[PIC_FLAG=-fPIC], [PIC_FLAG=])\n+AC_SUBST(PIC_FLAG)\n+\n+# Enable Intel CET on Intel CET enabled host if jit is enabled.\n+GCC_CET_HOST_FLAGS(CET_HOST_FLAGS)\n+case x$enable_languages in\n+*jit*)\n+  ;;\n+*)\n+  CET_HOST_FLAGS=\n+  ;;\n+esac\n+AC_SUBST(CET_HOST_FLAGS)\n+\n+# Test for __sync support.\n+AC_CACHE_CHECK([__sync extensions],\n+[libbacktrace_cv_sys_sync],\n+[if test -n \"${with_target_subdir}\"; then\n+   case \"${host}\" in\n+   hppa*-*-hpux*) libbacktrace_cv_sys_sync=no ;;\n+   *) libbacktrace_cv_sys_sync=yes ;;\n+   esac\n+ else\n+   AC_LINK_IFELSE(\n+     [AC_LANG_PROGRAM([int i;],\n+                      [__sync_bool_compare_and_swap (&i, i, i);\n+                       __sync_lock_test_and_set (&i, 1);\n+                       __sync_lock_release (&i);])],\n+     [libbacktrace_cv_sys_sync=yes],\n+     [libbacktrace_cv_sys_sync=no])\n+ fi])\n+BACKTRACE_SUPPORTS_THREADS=0\n+if test \"$libbacktrace_cv_sys_sync\" = \"yes\"; then\n+  BACKTRACE_SUPPORTS_THREADS=1\n+  AC_DEFINE([HAVE_SYNC_FUNCTIONS], 1,\n+\t    [Define to 1 if you have the __sync functions])\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTS_THREADS)\n+\n+# Test for __atomic support.\n+AC_CACHE_CHECK([__atomic extensions],\n+[libbacktrace_cv_sys_atomic],\n+[if test -n \"${with_target_subdir}\"; then\n+   libbacktrace_cv_sys_atomic=yes\n+ else\n+   AC_LINK_IFELSE(\n+     [AC_LANG_PROGRAM([int i;],\n+     \t\t      [__atomic_load_n (&i, __ATOMIC_ACQUIRE);\n+\t\t       __atomic_store_n (&i, 1, __ATOMIC_RELEASE);])],\n+     [libbacktrace_cv_sys_atomic=yes],\n+     [libbacktrace_cv_sys_atomic=no])\n+ fi])\n+if test \"$libbacktrace_cv_sys_atomic\" = \"yes\"; then\n+  AC_DEFINE([HAVE_ATOMIC_FUNCTIONS], 1,\n+\t    [Define to 1 if you have the __atomic functions])\n+fi\n+\n+# The library needs to be able to read the executable itself.  Compile\n+# a file to determine the executable format.  The awk script\n+# filetype.awk prints out the file type.\n+AC_CACHE_CHECK([output filetype],\n+[libbacktrace_cv_sys_filetype],\n+[filetype=\n+AC_COMPILE_IFELSE(\n+  [AC_LANG_PROGRAM([int i;], [int j;])],\n+  [filetype=`${AWK} -f $srcdir/filetype.awk conftest.$ac_objext`],\n+  [AC_MSG_FAILURE([compiler failed])])\n+libbacktrace_cv_sys_filetype=$filetype])\n+\n+# Match the file type to decide what files to compile.\n+FORMAT_FILE=\n+backtrace_supports_data=yes\n+case \"$libbacktrace_cv_sys_filetype\" in\n+elf*) FORMAT_FILE=\"elf.lo\" ;;\n+macho) FORMAT_FILE=\"macho.lo\" ;;\n+pecoff) FORMAT_FILE=\"pecoff.lo\"\n+        backtrace_supports_data=no\n+\t;;\n+xcoff*) FORMAT_FILE=\"xcoff.lo\"\n+        backtrace_supports_data=no\n+        ;;\n+*) AC_MSG_WARN([could not determine output file type])\n+   FORMAT_FILE=\"unknown.lo\"\n+   backtrace_supported=no\n+   ;;\n+esac\n+AC_SUBST(FORMAT_FILE)\n+\n+# ELF defines.\n+elfsize=\n+case \"$libbacktrace_cv_sys_filetype\" in\n+elf32) elfsize=32 ;;\n+elf64) elfsize=64 ;;\n+*)     elfsize=unused\n+esac\n+AC_DEFINE_UNQUOTED([BACKTRACE_ELF_SIZE], [$elfsize], [ELF size: 32 or 64])\n+AM_CONDITIONAL(HAVE_ELF, test \"$FORMAT_FILE\" = \"elf.lo\")\n+\n+# XCOFF defines.\n+xcoffsize=\n+case \"$libbacktrace_cv_sys_filetype\" in\n+xcoff32) xcoffsize=32 ;;\n+xcoff64) xcoffsize=64 ;;\n+*)       xcoffsize=unused\n+esac\n+AC_DEFINE_UNQUOTED([BACKTRACE_XCOFF_SIZE], [$xcoffsize], [XCOFF size: 32 or 64])\n+\n+BACKTRACE_SUPPORTED=0\n+if test \"$backtrace_supported\" = \"yes\"; then\n+  BACKTRACE_SUPPORTED=1\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTED)\n+\n+BACKTRACE_SUPPORTS_DATA=0\n+if test \"$backtrace_supports_data\" = \"yes\"; then\n+  BACKTRACE_SUPPORTS_DATA=1\n+fi\n+AC_SUBST(BACKTRACE_SUPPORTS_DATA)\n+\n+GCC_HEADER_STDINT(gstdint.h)\n+\n+AC_CHECK_HEADERS(sys/mman.h)\n+if test \"$ac_cv_header_sys_mman_h\" = \"no\"; then\n+  have_mmap=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.  We\n+    # simply assume that if we have mman.h, we have mmap.\n+    have_mmap=yes\n+    case \"${host}\" in\n+    *-*-msdosdjgpp)\n+        # DJGPP has sys/man.h, but no mmap\n+\thave_mmap=no ;;\n+    esac\n+  else\n+    AC_CHECK_FUNC(mmap, [have_mmap=yes], [have_mmap=no])\n+  fi\n+fi\n+if test \"$have_mmap\" = \"no\"; then\n+  VIEW_FILE=read.lo\n+  ALLOC_FILE=alloc.lo\n+else\n+  VIEW_FILE=mmapio.lo\n+  AC_PREPROC_IFELSE([AC_LANG_SOURCE([\n+#include <sys/mman.h>\n+#if !defined(MAP_ANONYMOUS) && !defined(MAP_ANON)\n+  #error no MAP_ANONYMOUS\n+#endif\n+])], [ALLOC_FILE=mmap.lo], [ALLOC_FILE=alloc.lo])\n+fi\n+AC_SUBST(VIEW_FILE)\n+AC_SUBST(ALLOC_FILE)\n+\n+BACKTRACE_USES_MALLOC=0\n+if test \"$ALLOC_FILE\" = \"alloc.lo\"; then\n+  BACKTRACE_USES_MALLOC=1\n+fi\n+AC_SUBST(BACKTRACE_USES_MALLOC)\n+\n+# Check for dl_iterate_phdr.\n+AC_CHECK_HEADERS(link.h)\n+if test \"$ac_cv_header_link_h\" = \"no\"; then\n+  have_dl_iterate_phdr=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.\n+    AC_EGREP_HEADER([dl_iterate_phdr], [link.h], [have_dl_iterate_phdr=yes],\n+\t\t    [have_dl_iterate_phdr=no])\n+  else\n+    AC_CHECK_FUNC([dl_iterate_phdr], [have_dl_iterate_phdr=yes],\n+\t\t  [have_dl_iterate_phdr=no])\n+  fi\n+fi\n+if test \"$have_dl_iterate_phdr\" = \"yes\"; then\n+  AC_DEFINE(HAVE_DL_ITERATE_PHDR, 1, [Define if dl_iterate_phdr is available.])\n+fi\n+\n+# Check for header file for Mach-O image functions.\n+AC_CHECK_HEADERS(mach-o/dyld.h)\n+\n+# Check for loadquery.\n+AC_CHECK_HEADERS(sys/ldr.h)\n+if test \"$ac_cv_header_sys_ldr_h\" = \"no\"; then\n+  have_loadquery=no\n+else\n+  if test -n \"${with_target_subdir}\"; then\n+    # When built as a GCC target library, we can't do a link test.\n+    AC_EGREP_HEADER([loadquery], [sys/ldr.h], [have_loadquery=yes],\n+\t\t    [have_loadquery=no])\n+  else\n+    AC_CHECK_FUNC([loadquery], [have_loadquery=yes],\n+\t\t  [have_loadquery=no])\n+  fi\n+fi\n+if test \"$have_loadquery\" = \"yes\"; then\n+  AC_DEFINE(HAVE_LOADQUERY, 1, [Define if AIX loadquery is available.])\n+fi\n+\n+# Check for the fcntl function.\n+if test -n \"${with_target_subdir}\"; then\n+   case \"${host}\" in\n+   *-*-mingw*) have_fcntl=no ;;\n+   *) have_fcntl=yes ;;\n+   esac\n+else\n+  AC_CHECK_FUNC(fcntl, [have_fcntl=yes], [have_fcntl=no])\n+fi\n+if test \"$have_fcntl\" = \"yes\"; then\n+  AC_DEFINE([HAVE_FCNTL], 1,\n+\t    [Define to 1 if you have the fcntl function])\n+fi\n+\n+AC_CHECK_DECLS([strnlen, getpagesize])\n+AC_CHECK_FUNCS(lstat readlink)\n+\n+# Check for getexecname function.\n+if test -n \"${with_target_subdir}\"; then\n+   case \"${host}\" in\n+   *-*-solaris2*) have_getexecname=yes ;;\n+   *) have_getexecname=no ;;\n+   esac\n+else\n+  AC_CHECK_FUNC(getexecname, [have_getexecname=yes], [have_getexecname=no])\n+fi\n+if test \"$have_getexecname\" = \"yes\"; then\n+  AC_DEFINE(HAVE_GETEXECNAME, 1, [Define if getexecname is available.])\n+fi\n+\n+# Check for sysctl definitions.\n+\n+AC_CACHE_CHECK([for KERN_PROC],\n+[libbacktrace_cv_proc],\n+[AC_COMPILE_IFELSE(\n+  [AC_LANG_PROGRAM([\n+#include <sys/types.h>\n+#include <sys/sysctl.h>\n+], [int mib0 = CTL_KERN; int mib1 = KERN_PROC; int mib2 = KERN_PROC_PATHNAME;])],\n+  [libbacktrace_cv_proc=yes],\n+  [libbacktrace_cv_proc=no])])\n+if test \"$libbacktrace_cv_proc\" = \"yes\"; then\n+  AC_DEFINE([HAVE_KERN_PROC], 1,\n+            [Define to 1 if you have KERN_PROC and KERN_PROC_PATHNAME in <sys/sysctl.h>.])\n+fi\n+\n+AC_CACHE_CHECK([for KERN_PROG_ARGS],\n+[libbacktrace_cv_procargs],\n+[AC_COMPILE_IFELSE(\n+  [AC_LANG_PROGRAM([\n+#include <sys/types.h>\n+#include <sys/sysctl.h>\n+], [int mib0 = CTL_KERN; int mib1 = KERN_PROC_ARGS; int mib2 = KERN_PROC_PATHNAME;])],\n+  [libbacktrace_cv_procargs=yes],\n+  [libbacktrace_cv_procargs=no])])\n+if test \"$libbacktrace_cv_procargs\" = \"yes\"; then\n+  AC_DEFINE([HAVE_KERN_PROC_ARGS], 1,\n+            [Define to 1 if you have KERN_PROCARGS and KERN_PROC_PATHNAME in <sys/sysctl.h>.])\n+fi\n+\n+# Check for the clock_gettime function.\n+AC_CHECK_FUNCS(clock_gettime)\n+clock_gettime_link=\n+# At least for glibc, clock_gettime is in librt.  But don't\n+# pull that in if it still doesn't give us the function we want.  This\n+# test is copied from libgomp, and modified to not link in -lrt as\n+# we're using this for test timing only.\n+if test \"$ac_cv_func_clock_gettime\" = no; then\n+  AC_CHECK_LIB(rt, clock_gettime,\n+    [CLOCK_GETTIME_LINK=-lrt\n+     AC_DEFINE(HAVE_CLOCK_GETTIME, 1,\n+\t       [Define to 1 if you have the `clock_gettime' function.])])\n+fi\n+AC_SUBST(CLOCK_GETTIME_LINK)\n+\n+dnl Test whether the compiler supports the -pthread option.\n+AC_CACHE_CHECK([whether -pthread is supported],\n+[libgo_cv_lib_pthread],\n+[CFLAGS_hold=$CFLAGS\n+CFLAGS=\"$CFLAGS -pthread\"\n+AC_COMPILE_IFELSE([AC_LANG_SOURCE([int i;])],\n+[libgo_cv_lib_pthread=yes],\n+[libgo_cv_lib_pthread=no])\n+CFLAGS=$CFLAGS_hold])\n+PTHREAD_CFLAGS=\n+if test \"$libgo_cv_lib_pthread\" = yes; then\n+  PTHREAD_CFLAGS=-pthread\n+fi\n+AC_SUBST(PTHREAD_CFLAGS)\n+\n+AM_CONDITIONAL(HAVE_PTHREAD, test \"$libgo_cv_lib_pthread\" = yes)\n+\n+dnl Test whether the compiler and the linker support the -gdwarf-5 option.\n+AC_CACHE_CHECK([whether -gdwarf-5 is supported],\n+[libbacktrace_cv_lib_dwarf5],\n+[CFLAGS_hold=$CFLAGS\n+CFLAGS=\"$CFLAGS -gdwarf-5\"\n+AC_LINK_IFELSE([AC_LANG_PROGRAM([int i;], [return 0;])],\n+[libbacktrace_cv_lib_dwarf5=yes],\n+[libbacktrace_cv_lib_dwarf5=no])\n+CFLAGS=$CFLAGS_hold])\n+AM_CONDITIONAL(HAVE_DWARF5, test \"$libbacktrace_cv_lib_dwarf5\" = yes)\n+\n+AC_CHECK_LIB([z], [compress],\n+    [AC_DEFINE(HAVE_ZLIB, 1, [Define if -lz is available.])])\n+AM_CONDITIONAL(HAVE_ZLIB, test \"$ac_cv_lib_z_compress\" = yes)\n+\n+dnl Test whether the linker supports the --compress_debug_sections option.\n+AC_CACHE_CHECK([whether --compress-debug-sections is supported],\n+[libgo_cv_ld_compress],\n+[LDFLAGS_hold=$LDFLAGS\n+LDFLAGS=\"$LDFLAGS -Wl,--compress-debug-sections=zlib-gnu\"\n+AC_LINK_IFELSE([AC_LANG_PROGRAM(,)],\n+[libgo_cv_ld_compress=yes],\n+[libgo_cv_ld_compress=no])\n+LDFLAGS=$LDFLAGS_hold])\n+AM_CONDITIONAL(HAVE_COMPRESSED_DEBUG, test \"$libgo_cv_ld_compress\" = yes)\n+\n+AC_ARG_VAR(OBJCOPY, [location of objcopy])\n+AC_CHECK_PROG(OBJCOPY, objcopy, objcopy,)\n+AC_CHECK_PROG(READELF, readelf, readelf)\n+AC_CACHE_CHECK([whether objcopy supports debuglink],\n+[libbacktrace_cv_objcopy_debuglink],\n+[if test -n \"${with_target_subdir}\"; then\n+  libbacktrace_cv_objcopy_debuglink=no\n+elif ! test -n \"${OBJCOPY}\"; then\n+  libbacktrace_cv_objcopy_debuglink=no\n+elif ${OBJCOPY} --help | fgrep add-gnu-debuglink >/dev/null 2>&1; then\n+  libbacktrace_cv_objcopy_debuglink=yes\n+else\n+  libbacktrace_cv_objcopy_debuglink=no\n+fi])\n+AM_CONDITIONAL(HAVE_OBJCOPY_DEBUGLINK, test \"$libbacktrace_cv_objcopy_debuglink\" = yes)\n+\n+AC_ARG_VAR(DSYMUTIL, [location of dsymutil])\n+AC_CHECK_PROG(DSYMUTIL, dsymutil, dsymutil)\n+AM_CONDITIONAL(USE_DSYMUTIL, test -n \"${DSYMUTIL}\" -a \"$FORMAT_FILE\" = \"macho.lo\")\n+\n+AC_ARG_VAR(NM, [location of nm])\n+AC_CHECK_PROG(NM, nm, nm)\n+\n+AC_CHECK_PROG(XZ, xz, xz)\n+AM_CONDITIONAL(HAVE_XZ, test \"$XZ\" != \"\")\n+AC_CHECK_PROG(COMM, comm, comm)\n+AM_CONDITIONAL(HAVE_COMM, test \"$COMM\" != \"\")\n+\n+AM_CONDITIONAL(HAVE_MINIDEBUG,\n+  test \"${with_target_subdir}\" = \"\" -a \"$FORMAT_FILE\" = \"elf.lo\" -a \"${OBJCOPY}\" != \"\" -a \"${NM}\" != \"\" -a \"${XZ}\" != \"\" -a \"${COMM}\" != \"\")\n+\n+AC_CHECK_LIB([lzma], [lzma_auto_decoder],\n+    [AC_DEFINE(HAVE_LIBLZMA, 1, [Define if -llzma is available.])])\n+AM_CONDITIONAL(HAVE_LIBLZMA, test \"$ac_cv_lib_lzma_lzma_auto_decoder\" = yes)\n+\n+AC_CACHE_CHECK([whether tests can run],\n+  [libbacktrace_cv_sys_native],\n+  [AC_RUN_IFELSE([AC_LANG_PROGRAM([], [return 0;])],\n+     [libbacktrace_cv_sys_native=yes],\n+     [libbacktrace_cv_sys_native=no],\n+     [libbacktrace_cv_sys_native=no])])\n+AM_CONDITIONAL(NATIVE, test \"$libbacktrace_cv_sys_native\" = \"yes\")\n+\n+if test \"${multilib}\" = \"yes\"; then\n+  multilib_arg=\"--enable-multilib\"\n+else\n+  multilib_arg=\n+fi\n+\n+AC_CONFIG_FILES(Makefile backtrace-supported.h)\n+AC_CONFIG_FILES(install-debuginfo-for-buildid.sh, chmod +x install-debuginfo-for-buildid.sh)\n+\n+# We need multilib support, but only if configuring for the target.\n+AC_CONFIG_COMMANDS([default],\n+[if test -n \"$CONFIG_FILES\"; then\n+   if test -n \"${with_target_subdir}\"; then\n+     # Multilibs need MULTISUBDIR defined correctly in certain makefiles so\n+     # that multilib installs will end up installed in the correct place.\n+     # The testsuite needs it for multilib-aware ABI baseline files.\n+     # To work around this not being passed down from config-ml.in ->\n+     # srcdir/Makefile.am -> srcdir/{src,libsupc++,...}/Makefile.am, manually\n+     # append it here.  Only modify Makefiles that have just been created.\n+     #\n+     # Also, get rid of this simulated-VPATH thing that automake does.\n+     cat > vpsed << \\_EOF\n+  s!`test -f '$<' || echo '$(srcdir)/'`!!\n+_EOF\n+     for i in $SUBDIRS; do\n+      case $CONFIG_FILES in\n+       *${i}/Makefile*)\n+\t #echo \"Adding MULTISUBDIR to $i/Makefile\"\n+\t sed -f vpsed $i/Makefile > tmp\n+\t grep '^MULTISUBDIR =' Makefile >> tmp\n+\t mv tmp $i/Makefile\n+\t ;;\n+      esac\n+     done\n+     rm vpsed\n+   fi\n+ fi\n+],\n+[\n+# Variables needed in config.status (file generation) which aren't already\n+# passed by autoconf.\n+SUBDIRS=\"$SUBDIRS\"\n+])\n+\n+AC_OUTPUT"
    },
    {
      "sha": "e6b1f238cd3db2f2d369911a3efe23a77a3f1326",
      "filename": "libbacktrace/dwarf.c",
      "status": "added",
      "additions": 4056,
      "deletions": 0,
      "changes": 4056,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/dwarf.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9"
    },
    {
      "sha": "c5ced130c3201cd865bfb1d9a4fedcc0fa48a954",
      "filename": "libbacktrace/edtest.c",
      "status": "added",
      "additions": 120,
      "deletions": 0,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/edtest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/edtest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/edtest.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,120 @@\n+/* edtest.c -- Test for libbacktrace storage allocation stress handling\n+   Copyright (C) 2017-2021 Free Software Foundation, Inc.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+#include \"internal.h\"\n+\n+#include \"testlib.h\"\n+\n+static int test1 (void) __attribute__ ((noinline, noclone, unused));\n+extern int f2 (int);\n+extern int f3 (int, int);\n+\n+static int\n+test1 (void)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return f2 (__LINE__) + 1;\n+}\n+\n+int\n+f3 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (data.index < 3)\n+    {\n+      fprintf (stderr,\n+               \"test1: not enough frames; got %zu, expected at least 3\\n\",\n+               data.index);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test1\", 0, all, f3line, \"f3\", \"edtest.c\", &data.failed);\n+  check (\"test1\", 1, all, f2line, \"f2\", \"edtest2_build.c\", &data.failed);\n+  check (\"test1\", 2, all, f1line, \"test1\", \"edtest.c\", &data.failed);\n+\n+  printf (\"%s: backtrace_full alloc stress\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+                                  error_callback_create, NULL);\n+\n+  // Grab the storage allocation lock prior to doing anything interesting.\n+  // The intent here is to insure that the backtrace_alloc code is forced\n+  // to always call mmap() for new memory as opposed to reusing previously\n+  // allocated memory from the free list. Doing things this way helps\n+  // simulate what you might see in a multithreaded program in which there\n+  // are racing calls to the allocator.\n+  struct backtrace_state *state_internal =\n+      (struct backtrace_state *) state;\n+  state_internal->lock_alloc = 1;\n+\n+  // Kick off the test\n+  test1();\n+\n+  exit (failures > 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "cffb4fdb6d9d1fe09a453090ba6a6d655acf3786",
      "filename": "libbacktrace/edtest2.c",
      "status": "added",
      "additions": 43,
      "deletions": 0,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/edtest2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/edtest2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/edtest2.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,43 @@\n+/* edtest2.c -- Test for libbacktrace storage allocation stress handling (p2)\n+   Copyright (C) 2017-2021 Free Software Foundation, Inc.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* This file intentionally written without any #include's\n+ */\n+\n+extern int f3(int, int);\n+extern int f2(int);\n+\n+int f2(int x)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return f3(x, __LINE__) + 3;\n+}"
    },
    {
      "sha": "79d56146fc67206d6f7f883a55b27eda7d168e23",
      "filename": "libbacktrace/elf.c",
      "status": "added",
      "additions": 4919,
      "deletions": 0,
      "changes": 4919,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/elf.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9"
    },
    {
      "sha": "0472f4721ab6c358187390f08699a728ec732141",
      "filename": "libbacktrace/fileline.c",
      "status": "added",
      "additions": 346,
      "deletions": 0,
      "changes": 346,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/fileline.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/fileline.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/fileline.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,346 @@\n+/* fileline.c -- Get file and line number information in a backtrace.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <errno.h>\n+#include <fcntl.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+#if defined (HAVE_KERN_PROC_ARGS) || defined (HAVE_KERN_PROC)\n+#include <sys/sysctl.h>\n+#endif\n+\n+#ifdef HAVE_MACH_O_DYLD_H\n+#include <mach-o/dyld.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef HAVE_GETEXECNAME\n+#define getexecname() NULL\n+#endif\n+\n+#if !defined (HAVE_KERN_PROC_ARGS) && !defined (HAVE_KERN_PROC)\n+\n+#define sysctl_exec_name1(state, error_callback, data) NULL\n+#define sysctl_exec_name2(state, error_callback, data) NULL\n+\n+#else /* defined (HAVE_KERN_PROC_ARGS) || |defined (HAVE_KERN_PROC) */\n+\n+static char *\n+sysctl_exec_name (struct backtrace_state *state,\n+\t\t  int mib0, int mib1, int mib2, int mib3,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  int mib[4];\n+  size_t len;\n+  char *name;\n+  size_t rlen;\n+\n+  mib[0] = mib0;\n+  mib[1] = mib1;\n+  mib[2] = mib2;\n+  mib[3] = mib3;\n+\n+  if (sysctl (mib, 4, NULL, &len, NULL, 0) < 0)\n+    return NULL;\n+  name = (char *) backtrace_alloc (state, len, error_callback, data);\n+  if (name == NULL)\n+    return NULL;\n+  rlen = len;\n+  if (sysctl (mib, 4, name, &rlen, NULL, 0) < 0)\n+    {\n+      backtrace_free (state, name, len, error_callback, data);\n+      return NULL;\n+    }\n+  return name;\n+}\n+\n+#ifdef HAVE_KERN_PROC_ARGS\n+\n+static char *\n+sysctl_exec_name1 (struct backtrace_state *state,\n+\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  /* This variant is used on NetBSD.  */\n+  return sysctl_exec_name (state, CTL_KERN, KERN_PROC_ARGS, -1,\n+\t\t\t   KERN_PROC_PATHNAME, error_callback, data);\n+}\n+\n+#else\n+\n+#define sysctl_exec_name1(state, error_callback, data) NULL\n+\n+#endif\n+\n+#ifdef HAVE_KERN_PROC\n+\n+static char *\n+sysctl_exec_name2 (struct backtrace_state *state,\n+\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  /* This variant is used on FreeBSD.  */\n+  return sysctl_exec_name (state, CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1,\n+\t\t\t   error_callback, data);\n+}\n+\n+#else\n+\n+#define sysctl_exec_name2(state, error_callback, data) NULL\n+\n+#endif\n+\n+#endif /* defined (HAVE_KERN_PROC_ARGS) || |defined (HAVE_KERN_PROC) */\n+\n+#ifdef HAVE_MACH_O_DYLD_H\n+\n+static char *\n+macho_get_executable_path (struct backtrace_state *state,\n+\t\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  uint32_t len;\n+  char *name;\n+\n+  len = 0;\n+  if (_NSGetExecutablePath (NULL, &len) == 0)\n+    return NULL;\n+  name = (char *) backtrace_alloc (state, len, error_callback, data);\n+  if (name == NULL)\n+    return NULL;\n+  if (_NSGetExecutablePath (name, &len) != 0)\n+    {\n+      backtrace_free (state, name, len, error_callback, data);\n+      return NULL;\n+    }\n+  return name;\n+}\n+\n+#else /* !defined (HAVE_MACH_O_DYLD_H) */\n+\n+#define macho_get_executable_path(state, error_callback, data) NULL\n+\n+#endif /* !defined (HAVE_MACH_O_DYLD_H) */\n+\n+/* Initialize the fileline information from the executable.  Returns 1\n+   on success, 0 on failure.  */\n+\n+static int\n+fileline_initialize (struct backtrace_state *state,\n+\t\t     backtrace_error_callback error_callback, void *data)\n+{\n+  int failed;\n+  fileline fileline_fn;\n+  int pass;\n+  int called_error_callback;\n+  int descriptor;\n+  const char *filename;\n+  char buf[64];\n+\n+  if (!state->threaded)\n+    failed = state->fileline_initialization_failed;\n+  else\n+    failed = backtrace_atomic_load_int (&state->fileline_initialization_failed);\n+\n+  if (failed)\n+    {\n+      error_callback (data, \"failed to read executable information\", -1);\n+      return 0;\n+    }\n+\n+  if (!state->threaded)\n+    fileline_fn = state->fileline_fn;\n+  else\n+    fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+  if (fileline_fn != NULL)\n+    return 1;\n+\n+  /* We have not initialized the information.  Do it now.  */\n+\n+  descriptor = -1;\n+  called_error_callback = 0;\n+  for (pass = 0; pass < 8; ++pass)\n+    {\n+      int does_not_exist;\n+\n+      switch (pass)\n+\t{\n+\tcase 0:\n+\t  filename = state->filename;\n+\t  break;\n+\tcase 1:\n+\t  filename = getexecname ();\n+\t  break;\n+\tcase 2:\n+\t  filename = \"/proc/self/exe\";\n+\t  break;\n+\tcase 3:\n+\t  filename = \"/proc/curproc/file\";\n+\t  break;\n+\tcase 4:\n+\t  snprintf (buf, sizeof (buf), \"/proc/%ld/object/a.out\",\n+\t\t    (long) getpid ());\n+\t  filename = buf;\n+\t  break;\n+\tcase 5:\n+\t  filename = sysctl_exec_name1 (state, error_callback, data);\n+\t  break;\n+\tcase 6:\n+\t  filename = sysctl_exec_name2 (state, error_callback, data);\n+\t  break;\n+\tcase 7:\n+\t  filename = macho_get_executable_path (state, error_callback, data);\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      if (filename == NULL)\n+\tcontinue;\n+\n+      descriptor = backtrace_open (filename, error_callback, data,\n+\t\t\t\t   &does_not_exist);\n+      if (descriptor < 0 && !does_not_exist)\n+\t{\n+\t  called_error_callback = 1;\n+\t  break;\n+\t}\n+      if (descriptor >= 0)\n+\tbreak;\n+    }\n+\n+  if (descriptor < 0)\n+    {\n+      if (!called_error_callback)\n+\t{\n+\t  if (state->filename != NULL)\n+\t    error_callback (data, state->filename, ENOENT);\n+\t  else\n+\t    error_callback (data,\n+\t\t\t    \"libbacktrace could not find executable to open\",\n+\t\t\t    0);\n+\t}\n+      failed = 1;\n+    }\n+\n+  if (!failed)\n+    {\n+      if (!backtrace_initialize (state, filename, descriptor, error_callback,\n+\t\t\t\t data, &fileline_fn))\n+\tfailed = 1;\n+    }\n+\n+  if (failed)\n+    {\n+      if (!state->threaded)\n+\tstate->fileline_initialization_failed = 1;\n+      else\n+\tbacktrace_atomic_store_int (&state->fileline_initialization_failed, 1);\n+      return 0;\n+    }\n+\n+  if (!state->threaded)\n+    state->fileline_fn = fileline_fn;\n+  else\n+    {\n+      backtrace_atomic_store_pointer (&state->fileline_fn, fileline_fn);\n+\n+      /* Note that if two threads initialize at once, one of the data\n+\t sets may be leaked.  */\n+    }\n+\n+  return 1;\n+}\n+\n+/* Given a PC, find the file name, line number, and function name.  */\n+\n+int\n+backtrace_pcinfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t  backtrace_full_callback callback,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  if (!fileline_initialize (state, error_callback, data))\n+    return 0;\n+\n+  if (state->fileline_initialization_failed)\n+    return 0;\n+\n+  return state->fileline_fn (state, pc, callback, error_callback, data);\n+}\n+\n+/* Given a PC, find the symbol for it, and its value.  */\n+\n+int\n+backtrace_syminfo (struct backtrace_state *state, uintptr_t pc,\n+\t\t   backtrace_syminfo_callback callback,\n+\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  if (!fileline_initialize (state, error_callback, data))\n+    return 0;\n+\n+  if (state->fileline_initialization_failed)\n+    return 0;\n+\n+  state->syminfo_fn (state, pc, callback, error_callback, data);\n+  return 1;\n+}\n+\n+/* A backtrace_syminfo_callback that can call into a\n+   backtrace_full_callback, used when we have a symbol table but no\n+   debug info.  */\n+\n+void\n+backtrace_syminfo_to_full_callback (void *data, uintptr_t pc,\n+\t\t\t\t    const char *symname,\n+\t\t\t\t    uintptr_t symval ATTRIBUTE_UNUSED,\n+\t\t\t\t    uintptr_t symsize ATTRIBUTE_UNUSED)\n+{\n+  struct backtrace_call_full *bdata = (struct backtrace_call_full *) data;\n+\n+  bdata->ret = bdata->full_callback (bdata->full_data, pc, NULL, 0, symname);\n+}\n+\n+/* An error callback that corresponds to\n+   backtrace_syminfo_to_full_callback.  */\n+\n+void\n+backtrace_syminfo_to_full_error_callback (void *data, const char *msg,\n+\t\t\t\t\t  int errnum)\n+{\n+  struct backtrace_call_full *bdata = (struct backtrace_call_full *) data;\n+\n+  bdata->full_error_callback (bdata->full_data, msg, errnum);\n+}"
    },
    {
      "sha": "1eefa7e72f0ec32a9ce68af7a6bdbee6d39d4b34",
      "filename": "libbacktrace/filetype.awk",
      "status": "added",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/filetype.awk",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/filetype.awk",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/filetype.awk?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,13 @@\n+# An awk script to determine the type of a file.\n+/^\\177ELF\\001/      { if (NR == 1) { print \"elf32\"; exit } }\n+/^\\177ELF\\002/      { if (NR == 1) { print \"elf64\"; exit } }\n+/^\\114\\001/         { if (NR == 1) { print \"pecoff\"; exit } }\n+/^\\144\\206/         { if (NR == 1) { print \"pecoff\"; exit } }\n+/^\\001\\337/         { if (NR == 1) { print \"xcoff32\"; exit } }\n+/^\\001\\367/         { if (NR == 1) { print \"xcoff64\"; exit } }\n+/^\\376\\355\\372\\316/ { if (NR == 1) { print \"macho\"; exit } }\n+/^\\316\\372\\355\\376/ { if (NR == 1) { print \"macho\"; exit } }\n+/^\\376\\355\\372\\317/ { if (NR == 1) { print \"macho\"; exit } }\n+/^\\317\\372\\355\\376/ { if (NR == 1) { print \"macho\"; exit } }\n+/^\\312\\376\\272\\276/ { if (NR == 1) { print \"macho\"; exit } }\n+/^\\276\\272\\376\\312/ { if (NR == 1) { print \"macho\"; exit } }"
    },
    {
      "sha": "91dfdfe89a4405e13771f4550be0d121caad94b9",
      "filename": "libbacktrace/install-debuginfo-for-buildid.sh.in",
      "status": "added",
      "additions": 65,
      "deletions": 0,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/install-debuginfo-for-buildid.sh.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/install-debuginfo-for-buildid.sh.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/install-debuginfo-for-buildid.sh.in?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,65 @@\n+#!/bin/sh\n+\n+# install-debug-info-for-buildid.sh -- Helper script for libbacktrace library\n+# testing.\n+# Copyright (C) 2019-2021 Free Software Foundation, Inc.\n+\n+# Redistribution and use in source and binary forms, with or without\n+# modification, are permitted provided that the following conditions are\n+# met:\n+\n+#     (1) Redistributions of source code must retain the above copyright\n+#     notice, this list of conditions and the following disclaimer.\n+\n+#     (2) Redistributions in binary form must reproduce the above copyright\n+#     notice, this list of conditions and the following disclaimer in\n+#     the documentation and/or other materials provided with the\n+#     distribution.\n+\n+#     (3) The name of the author may not be used to\n+#     endorse or promote products derived from this software without\n+#     specific prior written permission.\n+\n+# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+# POSSIBILITY OF SUCH DAMAGE.\n+\n+# Extract build-id from src, and copy debug info of src to\n+# $build_id_dir/aa/bb...zz.debug.\n+\n+set -e\n+\n+sed=@SED@\n+awk=@AWK@\n+grep=@GREP@\n+objcopy=@OBJCOPY@\n+readelf=@READELF@\n+mkdir_p=\"@MKDIR_P@\"\n+\n+build_id_dir=\"$1\"\n+src=\"$2\"\n+\n+buildid=$(LANG=C $readelf -n $src \\\n+\t      | $grep \"Build ID\" \\\n+\t      | $awk '{print $3}')\n+\n+prefix=$(echo $buildid \\\n+\t     | $sed 's/^\\(.\\{2\\}\\).*/\\1/')\n+\n+remainder=$(echo $buildid \\\n+\t\t| $sed 's/^.\\{2\\}//')\n+\n+dir=$build_id_dir/$prefix\n+dst=$dir/$remainder.debug\n+\n+$mkdir_p $dir\n+\n+$objcopy --only-keep-debug $src $dst"
    },
    {
      "sha": "13af81a6dcb1cbd3d31a1ca90c50651fc7bbf8e9",
      "filename": "libbacktrace/instrumented_alloc.c",
      "status": "added",
      "additions": 114,
      "deletions": 0,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/instrumented_alloc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/instrumented_alloc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/instrumented_alloc.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,114 @@\n+/* instrumented_alloc.c -- Memory allocation instrumented to fail when\n+   requested, for testing purposes.\n+   Copyright (C) 2018-2021 Free Software Foundation, Inc.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* Include all the header files of alloc here, to make sure they're not\n+   processed when including alloc.c below, such that the redefinitions of malloc\n+   and realloc are only effective in alloc.c itself.  This does not work for\n+   config.h, because it's not wrapped in \"#ifndef CONFIG_H\\n#define CONFIG_H\"\n+   and \"#endif\" but that does not seem to be harmful.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <inttypes.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+extern void *instrumented_malloc (size_t size);\n+extern void *instrumented_realloc (void *ptr, size_t size);\n+\n+#define malloc instrumented_malloc\n+#define realloc instrumented_realloc\n+#include \"alloc.c\"\n+#undef malloc\n+#undef realloc\n+\n+static uint64_t nr_allocs = 0;\n+static uint64_t fail_at_alloc = 0;\n+\n+extern int at_fail_alloc_p (void);\n+extern uint64_t get_nr_allocs (void);\n+extern void set_fail_at_alloc (uint64_t);\n+\n+void *\n+instrumented_malloc (size_t size)\n+{\n+  void *res;\n+\n+  if (at_fail_alloc_p ())\n+    return NULL;\n+\n+  res = malloc (size);\n+  if (res != NULL)\n+    nr_allocs++;\n+\n+  return res;\n+}\n+\n+void *\n+instrumented_realloc (void *ptr, size_t size)\n+{\n+  void *res;\n+\n+  if (size != 0)\n+    {\n+      if (at_fail_alloc_p ())\n+\treturn NULL;\n+    }\n+\n+  res = realloc (ptr, size);\n+  if (res != NULL)\n+    nr_allocs++;\n+\n+  return res;\n+}\n+\n+int\n+at_fail_alloc_p (void)\n+{\n+  return fail_at_alloc == nr_allocs + 1;\n+}\n+\n+uint64_t\n+get_nr_allocs (void)\n+{\n+  return nr_allocs;\n+}\n+\n+void\n+set_fail_at_alloc (uint64_t nr)\n+{\n+  fail_at_alloc = nr;\n+}"
    },
    {
      "sha": "bb481f373bf7bc6d6f83fcf65c433858e8912ce5",
      "filename": "libbacktrace/internal.h",
      "status": "added",
      "additions": 380,
      "deletions": 0,
      "changes": 380,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/internal.h?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,380 @@\n+/* internal.h -- Internal header file for stack backtrace library.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#ifndef BACKTRACE_INTERNAL_H\n+#define BACKTRACE_INTERNAL_H\n+\n+/* We assume that <sys/types.h> and \"backtrace.h\" have already been\n+   included.  */\n+\n+#ifndef GCC_VERSION\n+# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif\n+\n+#if (GCC_VERSION < 2007)\n+# define __attribute__(x)\n+#endif\n+\n+#ifndef ATTRIBUTE_UNUSED\n+# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n+#endif\n+\n+#ifndef ATTRIBUTE_MALLOC\n+# if (GCC_VERSION >= 2096)\n+#  define ATTRIBUTE_MALLOC __attribute__ ((__malloc__))\n+# else\n+#  define ATTRIBUTE_MALLOC\n+# endif\n+#endif\n+\n+#ifndef ATTRIBUTE_FALLTHROUGH\n+# if (GCC_VERSION >= 7000)\n+#  define ATTRIBUTE_FALLTHROUGH __attribute__ ((__fallthrough__))\n+# else\n+#  define ATTRIBUTE_FALLTHROUGH\n+# endif\n+#endif\n+\n+#ifndef HAVE_SYNC_FUNCTIONS\n+\n+/* Define out the sync functions.  These should never be called if\n+   they are not available.  */\n+\n+#define __sync_bool_compare_and_swap(A, B, C) (abort(), 1)\n+#define __sync_lock_test_and_set(A, B) (abort(), 0)\n+#define __sync_lock_release(A) abort()\n+\n+#endif /* !defined (HAVE_SYNC_FUNCTIONS) */\n+\n+#ifdef HAVE_ATOMIC_FUNCTIONS\n+\n+/* We have the atomic builtin functions.  */\n+\n+#define backtrace_atomic_load_pointer(p) \\\n+    __atomic_load_n ((p), __ATOMIC_ACQUIRE)\n+#define backtrace_atomic_load_int(p) \\\n+    __atomic_load_n ((p), __ATOMIC_ACQUIRE)\n+#define backtrace_atomic_store_pointer(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+#define backtrace_atomic_store_size_t(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+#define backtrace_atomic_store_int(p, v) \\\n+    __atomic_store_n ((p), (v), __ATOMIC_RELEASE)\n+\n+#else /* !defined (HAVE_ATOMIC_FUNCTIONS) */\n+#ifdef HAVE_SYNC_FUNCTIONS\n+\n+/* We have the sync functions but not the atomic functions.  Define\n+   the atomic ones in terms of the sync ones.  */\n+\n+extern void *backtrace_atomic_load_pointer (void *);\n+extern int backtrace_atomic_load_int (int *);\n+extern void backtrace_atomic_store_pointer (void *, void *);\n+extern void backtrace_atomic_store_size_t (size_t *, size_t);\n+extern void backtrace_atomic_store_int (int *, int);\n+\n+#else /* !defined (HAVE_SYNC_FUNCTIONS) */\n+\n+/* We have neither the sync nor the atomic functions.  These will\n+   never be called.  */\n+\n+#define backtrace_atomic_load_pointer(p) (abort(), (void *) NULL)\n+#define backtrace_atomic_load_int(p) (abort(), 0)\n+#define backtrace_atomic_store_pointer(p, v) abort()\n+#define backtrace_atomic_store_size_t(p, v) abort()\n+#define backtrace_atomic_store_int(p, v) abort()\n+\n+#endif /* !defined (HAVE_SYNC_FUNCTIONS) */\n+#endif /* !defined (HAVE_ATOMIC_FUNCTIONS) */\n+\n+/* The type of the function that collects file/line information.  This\n+   is like backtrace_pcinfo.  */\n+\n+typedef int (*fileline) (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t backtrace_full_callback callback,\n+\t\t\t backtrace_error_callback error_callback, void *data);\n+\n+/* The type of the function that collects symbol information.  This is\n+   like backtrace_syminfo.  */\n+\n+typedef void (*syminfo) (struct backtrace_state *state, uintptr_t pc,\n+\t\t\t backtrace_syminfo_callback callback,\n+\t\t\t backtrace_error_callback error_callback, void *data);\n+\n+/* What the backtrace state pointer points to.  */\n+\n+struct backtrace_state\n+{\n+  /* The name of the executable.  */\n+  const char *filename;\n+  /* Non-zero if threaded.  */\n+  int threaded;\n+  /* The master lock for fileline_fn, fileline_data, syminfo_fn,\n+     syminfo_data, fileline_initialization_failed and everything the\n+     data pointers point to.  */\n+  void *lock;\n+  /* The function that returns file/line information.  */\n+  fileline fileline_fn;\n+  /* The data to pass to FILELINE_FN.  */\n+  void *fileline_data;\n+  /* The function that returns symbol information.  */\n+  syminfo syminfo_fn;\n+  /* The data to pass to SYMINFO_FN.  */\n+  void *syminfo_data;\n+  /* Whether initializing the file/line information failed.  */\n+  int fileline_initialization_failed;\n+  /* The lock for the freelist.  */\n+  int lock_alloc;\n+  /* The freelist when using mmap.  */\n+  struct backtrace_freelist_struct *freelist;\n+};\n+\n+/* Open a file for reading.  Returns -1 on error.  If DOES_NOT_EXIST\n+   is not NULL, *DOES_NOT_EXIST will be set to 0 normally and set to 1\n+   if the file does not exist.  If the file does not exist and\n+   DOES_NOT_EXIST is not NULL, the function will return -1 and will\n+   not call ERROR_CALLBACK.  On other errors, or if DOES_NOT_EXIST is\n+   NULL, the function will call ERROR_CALLBACK before returning.  */\n+extern int backtrace_open (const char *filename,\n+\t\t\t   backtrace_error_callback error_callback,\n+\t\t\t   void *data,\n+\t\t\t   int *does_not_exist);\n+\n+/* A view of the contents of a file.  This supports mmap when\n+   available.  A view will remain in memory even after backtrace_close\n+   is called on the file descriptor from which the view was\n+   obtained.  */\n+\n+struct backtrace_view\n+{\n+  /* The data that the caller requested.  */\n+  const void *data;\n+  /* The base of the view.  */\n+  void *base;\n+  /* The total length of the view.  */\n+  size_t len;\n+};\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  Store the\n+   result in *VIEW.  Returns 1 on success, 0 on error.  */\n+extern int backtrace_get_view (struct backtrace_state *state, int descriptor,\n+\t\t\t       off_t offset, uint64_t size,\n+\t\t\t       backtrace_error_callback error_callback,\n+\t\t\t       void *data, struct backtrace_view *view);\n+\n+/* Release a view created by backtrace_get_view.  */\n+extern void backtrace_release_view (struct backtrace_state *state,\n+\t\t\t\t    struct backtrace_view *view,\n+\t\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t\t    void *data);\n+\n+/* Close a file opened by backtrace_open.  Returns 1 on success, 0 on\n+   error.  */\n+\n+extern int backtrace_close (int descriptor,\n+\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t    void *data);\n+\n+/* Sort without using memory.  */\n+\n+extern void backtrace_qsort (void *base, size_t count, size_t size,\n+\t\t\t     int (*compar) (const void *, const void *));\n+\n+/* Allocate memory.  This is like malloc.  If ERROR_CALLBACK is NULL,\n+   this does not report an error, it just returns NULL.  */\n+\n+extern void *backtrace_alloc (struct backtrace_state *state, size_t size,\n+\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t      void *data) ATTRIBUTE_MALLOC;\n+\n+/* Free memory allocated by backtrace_alloc.  If ERROR_CALLBACK is\n+   NULL, this does not report an error.  */\n+\n+extern void backtrace_free (struct backtrace_state *state, void *mem,\n+\t\t\t    size_t size,\n+\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t    void *data);\n+\n+/* A growable vector of some struct.  This is used for more efficient\n+   allocation when we don't know the final size of some group of data\n+   that we want to represent as an array.  */\n+\n+struct backtrace_vector\n+{\n+  /* The base of the vector.  */\n+  void *base;\n+  /* The number of bytes in the vector.  */\n+  size_t size;\n+  /* The number of bytes available at the current allocation.  */\n+  size_t alc;\n+};\n+\n+/* Grow VEC by SIZE bytes.  Return a pointer to the newly allocated\n+   bytes.  Note that this may move the entire vector to a new memory\n+   location.  Returns NULL on failure.  */\n+\n+extern void *backtrace_vector_grow (struct backtrace_state *state, size_t size,\n+\t\t\t\t    backtrace_error_callback error_callback,\n+\t\t\t\t    void *data,\n+\t\t\t\t    struct backtrace_vector *vec);\n+\n+/* Finish the current allocation on VEC.  Prepare to start a new\n+   allocation.  The finished allocation will never be freed.  Returns\n+   a pointer to the base of the finished entries, or NULL on\n+   failure.  */\n+\n+extern void* backtrace_vector_finish (struct backtrace_state *state,\n+\t\t\t\t      struct backtrace_vector *vec,\n+\t\t\t\t      backtrace_error_callback error_callback,\n+\t\t\t\t      void *data);\n+\n+/* Release any extra space allocated for VEC.  This may change\n+   VEC->base.  Returns 1 on success, 0 on failure.  */\n+\n+extern int backtrace_vector_release (struct backtrace_state *state,\n+\t\t\t\t     struct backtrace_vector *vec,\n+\t\t\t\t     backtrace_error_callback error_callback,\n+\t\t\t\t     void *data);\n+\n+/* Free the space managed by VEC.  This will reset VEC.  */\n+\n+static inline void\n+backtrace_vector_free (struct backtrace_state *state,\n+\t\t       struct backtrace_vector *vec,\n+\t\t       backtrace_error_callback error_callback, void *data)\n+{\n+  vec->alc += vec->size;\n+  vec->size = 0;\n+  backtrace_vector_release (state, vec, error_callback, data);\n+}\n+\n+/* Read initial debug data from a descriptor, and set the\n+   fileline_data, syminfo_fn, and syminfo_data fields of STATE.\n+   Return the fileln_fn field in *FILELN_FN--this is done this way so\n+   that the synchronization code is only implemented once.  This is\n+   called after the descriptor has first been opened.  It will close\n+   the descriptor if it is no longer needed.  Returns 1 on success, 0\n+   on error.  There will be multiple implementations of this function,\n+   for different file formats.  Each system will compile the\n+   appropriate one.  */\n+\n+extern int backtrace_initialize (struct backtrace_state *state,\n+\t\t\t\t const char *filename,\n+\t\t\t\t int descriptor,\n+\t\t\t\t backtrace_error_callback error_callback,\n+\t\t\t\t void *data,\n+\t\t\t\t fileline *fileline_fn);\n+\n+/* An enum for the DWARF sections we care about.  */\n+\n+enum dwarf_section\n+{\n+  DEBUG_INFO,\n+  DEBUG_LINE,\n+  DEBUG_ABBREV,\n+  DEBUG_RANGES,\n+  DEBUG_STR,\n+  DEBUG_ADDR,\n+  DEBUG_STR_OFFSETS,\n+  DEBUG_LINE_STR,\n+  DEBUG_RNGLISTS,\n+\n+  DEBUG_MAX\n+};\n+\n+/* Data for the DWARF sections we care about.  */\n+\n+struct dwarf_sections\n+{\n+  const unsigned char *data[DEBUG_MAX];\n+  size_t size[DEBUG_MAX];\n+};\n+\n+/* DWARF data read from a file, used for .gnu_debugaltlink.  */\n+\n+struct dwarf_data;\n+\n+/* Add file/line information for a DWARF module.  */\n+\n+extern int backtrace_dwarf_add (struct backtrace_state *state,\n+\t\t\t\tuintptr_t base_address,\n+\t\t\t\tconst struct dwarf_sections *dwarf_sections,\n+\t\t\t\tint is_bigendian,\n+\t\t\t\tstruct dwarf_data *fileline_altlink,\n+\t\t\t\tbacktrace_error_callback error_callback,\n+\t\t\t\tvoid *data, fileline *fileline_fn,\n+\t\t\t\tstruct dwarf_data **fileline_entry);\n+\n+/* A data structure to pass to backtrace_syminfo_to_full.  */\n+\n+struct backtrace_call_full\n+{\n+  backtrace_full_callback full_callback;\n+  backtrace_error_callback full_error_callback;\n+  void *full_data;\n+  int ret;\n+};\n+\n+/* A backtrace_syminfo_callback that can call into a\n+   backtrace_full_callback, used when we have a symbol table but no\n+   debug info.  */\n+\n+extern void backtrace_syminfo_to_full_callback (void *data, uintptr_t pc,\n+\t\t\t\t\t\tconst char *symname,\n+\t\t\t\t\t\tuintptr_t symval,\n+\t\t\t\t\t\tuintptr_t symsize);\n+\n+/* An error callback that corresponds to\n+   backtrace_syminfo_to_full_callback.  */\n+\n+extern void backtrace_syminfo_to_full_error_callback (void *, const char *,\n+\t\t\t\t\t\t      int);\n+\n+/* A test-only hook for elf_uncompress_zdebug.  */\n+\n+extern int backtrace_uncompress_zdebug (struct backtrace_state *,\n+\t\t\t\t\tconst unsigned char *compressed,\n+\t\t\t\t\tsize_t compressed_size,\n+\t\t\t\t\tbacktrace_error_callback, void *data,\n+\t\t\t\t\tunsigned char **uncompressed,\n+\t\t\t\t\tsize_t *uncompressed_size);\n+\n+/* A test-only hook for elf_uncompress_lzma.  */\n+\n+extern int backtrace_uncompress_lzma (struct backtrace_state *,\n+\t\t\t\t      const unsigned char *compressed,\n+\t\t\t\t      size_t compressed_size,\n+\t\t\t\t      backtrace_error_callback, void *data,\n+\t\t\t\t      unsigned char **uncompressed,\n+\t\t\t\t      size_t *uncompressed_size);\n+\n+#endif"
    },
    {
      "sha": "66e101e0a4ba084dc1e77e3dddc0772f155f3546",
      "filename": "libbacktrace/macho.c",
      "status": "added",
      "additions": 1355,
      "deletions": 0,
      "changes": 1355,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/macho.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/macho.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/macho.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,1355 @@\n+/* elf.c -- Get debug data from a Mach-O file for backtraces.\n+   Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+#include <dirent.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#ifdef HAVE_MACH_O_DYLD_H\n+#include <mach-o/dyld.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Mach-O file header for a 32-bit executable.  */\n+\n+struct macho_header_32\n+{\n+  uint32_t magic;\t/* Magic number (MACH_O_MAGIC_32) */\n+  uint32_t cputype;\t/* CPU type */\n+  uint32_t cpusubtype;\t/* CPU subtype */\n+  uint32_t filetype;\t/* Type of file (object, executable) */\n+  uint32_t ncmds;\t/* Number of load commands */\n+  uint32_t sizeofcmds;\t/* Total size of load commands */\n+  uint32_t flags;\t/* Flags for special features */\n+};\n+\n+/* Mach-O file header for a 64-bit executable.  */\n+\n+struct macho_header_64\n+{\n+  uint32_t magic;\t/* Magic number (MACH_O_MAGIC_64) */\n+  uint32_t cputype;\t/* CPU type */\n+  uint32_t cpusubtype;\t/* CPU subtype */\n+  uint32_t filetype;\t/* Type of file (object, executable) */\n+  uint32_t ncmds;\t/* Number of load commands */\n+  uint32_t sizeofcmds;\t/* Total size of load commands */\n+  uint32_t flags;\t/* Flags for special features */\n+  uint32_t reserved;\t/* Reserved */\n+};\n+\n+/* Mach-O file header for a fat executable.  */\n+\n+struct macho_header_fat\n+{\n+  uint32_t magic;\t/* Magic number (MACH_O_MH_(MAGIC|CIGAM)_FAT(_64)?) */\n+  uint32_t nfat_arch;   /* Number of components */\n+};\n+\n+/* Values for the header magic field.  */\n+\n+#define MACH_O_MH_MAGIC_32\t0xfeedface\n+#define MACH_O_MH_MAGIC_64\t0xfeedfacf\n+#define MACH_O_MH_MAGIC_FAT\t0xcafebabe\n+#define MACH_O_MH_CIGAM_FAT\t0xbebafeca\n+#define MACH_O_MH_MAGIC_FAT_64\t0xcafebabf\n+#define MACH_O_MH_CIGAM_FAT_64\t0xbfbafeca\n+\n+/* Value for the header filetype field.  */\n+\n+#define MACH_O_MH_EXECUTE\t0x02\n+#define MACH_O_MH_DYLIB\t\t0x06\n+#define MACH_O_MH_DSYM\t\t0x0a\n+\n+/* A component of a fat file.  A fat file starts with a\n+   macho_header_fat followed by nfat_arch instances of this\n+   struct.  */\n+\n+struct macho_fat_arch\n+{\n+  uint32_t cputype;\t/* CPU type */\n+  uint32_t cpusubtype;\t/* CPU subtype */\n+  uint32_t offset;\t/* File offset of this entry */\n+  uint32_t size;\t/* Size of this entry */\n+  uint32_t align;\t/* Alignment of this entry */\n+};\n+\n+/* A component of a 64-bit fat file.  This is used if the magic field\n+   is MAGIC_FAT_64.  This is only used when some file size or file\n+   offset is too large to represent in the 32-bit format.  */\n+\n+struct macho_fat_arch_64\n+{\n+  uint32_t cputype;\t/* CPU type */\n+  uint32_t cpusubtype;\t/* CPU subtype */\n+  uint64_t offset;\t/* File offset of this entry */\n+  uint64_t size;\t/* Size of this entry */\n+  uint32_t align;\t/* Alignment of this entry */\n+  uint32_t reserved;\t/* Reserved */\n+};\n+\n+/* Values for the fat_arch cputype field (and the header cputype\n+   field).  */\n+\n+#define MACH_O_CPU_ARCH_ABI64 0x01000000\n+\n+#define MACH_O_CPU_TYPE_X86 7\n+#define MACH_O_CPU_TYPE_ARM 12\n+#define MACH_O_CPU_TYPE_PPC 18\n+\n+#define MACH_O_CPU_TYPE_X86_64 (MACH_O_CPU_TYPE_X86 | MACH_O_CPU_ARCH_ABI64)\n+#define MACH_O_CPU_TYPE_ARM64  (MACH_O_CPU_TYPE_ARM | MACH_O_CPU_ARCH_ABI64)\n+#define MACH_O_CPU_TYPE_PPC64  (MACH_O_CPU_TYPE_PPC | MACH_O_CPU_ARCH_ABI64)\n+\n+/* The header of a load command.  */\n+\n+struct macho_load_command\n+{\n+  uint32_t cmd;\t\t/* The type of load command */\n+  uint32_t cmdsize;\t/* Size in bytes of the entire command */\n+};\n+\n+/* Values for the load_command cmd field.  */\n+\n+#define MACH_O_LC_SEGMENT\t0x01\n+#define MACH_O_LC_SYMTAB\t0x02\n+#define MACH_O_LC_SEGMENT_64\t0x19\n+#define MACH_O_LC_UUID\t\t0x1b\n+\n+/* The length of a section of segment name.  */\n+\n+#define MACH_O_NAMELEN (16)\n+\n+/* LC_SEGMENT load command.  */\n+\n+struct macho_segment_command\n+{\n+  uint32_t cmd;\t\t\t/* The type of load command (LC_SEGMENT) */\n+  uint32_t cmdsize;\t\t/* Size in bytes of the entire command */\n+  char segname[MACH_O_NAMELEN];\t/* Segment name */\n+  uint32_t vmaddr;\t\t/* Virtual memory address */\n+  uint32_t vmsize;\t\t/* Virtual memory size */\n+  uint32_t fileoff;\t\t/* Offset of data to be mapped */\n+  uint32_t filesize;\t\t/* Size of data in file */\n+  uint32_t maxprot;\t\t/* Maximum permitted virtual protection */\n+  uint32_t initprot;\t\t/* Initial virtual memory protection */\n+  uint32_t nsects;\t\t/* Number of sections in this segment */\n+  uint32_t flags;\t\t/* Flags */\n+};\n+\n+/* LC_SEGMENT_64 load command.  */\n+\n+struct macho_segment_64_command\n+{\n+  uint32_t cmd;\t\t\t/* The type of load command (LC_SEGMENT) */\n+  uint32_t cmdsize;\t\t/* Size in bytes of the entire command */\n+  char segname[MACH_O_NAMELEN];\t/* Segment name */\n+  uint64_t vmaddr;\t\t/* Virtual memory address */\n+  uint64_t vmsize;\t\t/* Virtual memory size */\n+  uint64_t fileoff;\t\t/* Offset of data to be mapped */\n+  uint64_t filesize;\t\t/* Size of data in file */\n+  uint32_t maxprot;\t\t/* Maximum permitted virtual protection */\n+  uint32_t initprot;\t\t/* Initial virtual memory protection */\n+  uint32_t nsects;\t\t/* Number of sections in this segment */\n+  uint32_t flags;\t\t/* Flags */\n+};\n+\n+/* LC_SYMTAB load command.  */\n+\n+struct macho_symtab_command\n+{\n+  uint32_t cmd;\t\t/* The type of load command (LC_SEGMENT) */\n+  uint32_t cmdsize;\t/* Size in bytes of the entire command */\n+  uint32_t symoff;\t/* File offset of symbol table */\n+  uint32_t nsyms;\t/* Number of symbols */\n+  uint32_t stroff;\t/* File offset of string table */\n+  uint32_t strsize;\t/* String table size */\n+};\n+\n+/* The length of a Mach-O uuid.  */\n+\n+#define MACH_O_UUID_LEN (16)\n+\n+/* LC_UUID load command.  */\n+\n+struct macho_uuid_command\n+{\n+  uint32_t cmd;\t\t\t\t/* Type of load command (LC_UUID) */\n+  uint32_t cmdsize;\t\t\t/* Size in bytes of command */\n+  unsigned char uuid[MACH_O_UUID_LEN];\t/* UUID */\n+};\n+\n+/* 32-bit section header within a LC_SEGMENT segment.  */\n+\n+struct macho_section\n+{\n+  char sectname[MACH_O_NAMELEN];\t/* Section name */\n+  char segment[MACH_O_NAMELEN];\t\t/* Segment of this section */\n+  uint32_t addr;\t\t\t/* Address in memory */\n+  uint32_t size;\t\t\t/* Section size */\n+  uint32_t offset;\t\t\t/* File offset */\n+  uint32_t align;\t\t\t/* Log2 of section alignment */\n+  uint32_t reloff;\t\t\t/* File offset of relocations */\n+  uint32_t nreloc;\t\t\t/* Number of relocs for this section */\n+  uint32_t flags;\t\t\t/* Flags */\n+  uint32_t reserved1;\n+  uint32_t reserved2;\n+};\n+\n+/* 64-bit section header within a LC_SEGMENT_64 segment.   */\n+\n+struct macho_section_64\n+{\n+  char sectname[MACH_O_NAMELEN];\t/* Section name */\n+  char segment[MACH_O_NAMELEN];\t\t/* Segment of this section */\n+  uint64_t addr;\t\t\t/* Address in memory */\n+  uint64_t size;\t\t\t/* Section size */\n+  uint32_t offset;\t\t\t/* File offset */\n+  uint32_t align;\t\t\t/* Log2 of section alignment */\n+  uint32_t reloff;\t\t\t/* File offset of section relocations */\n+  uint32_t nreloc;\t\t\t/* Number of relocs for this section */\n+  uint32_t flags;\t\t\t/* Flags */\n+  uint32_t reserved1;\n+  uint32_t reserved2;\n+  uint32_t reserved3;\n+};\n+\n+/* 32-bit symbol data.  */\n+\n+struct macho_nlist\n+{\n+  uint32_t n_strx;\t/* Index of name in string table */\n+  uint8_t n_type;\t/* Type flag */\n+  uint8_t n_sect;\t/* Section number */\n+  uint16_t n_desc;\t/* Stabs description field */\n+  uint32_t n_value;\t/* Value */\n+};\n+\n+/* 64-bit symbol data.  */\n+\n+struct macho_nlist_64\n+{\n+  uint32_t n_strx;\t/* Index of name in string table */\n+  uint8_t n_type;\t/* Type flag */\n+  uint8_t n_sect;\t/* Section number */\n+  uint16_t n_desc;\t/* Stabs description field */\n+  uint64_t n_value;\t/* Value */\n+};\n+\n+/* Value found in nlist n_type field.  */\n+\n+#define MACH_O_N_EXT\t0x01\t/* Extern symbol */\n+#define MACH_O_N_ABS\t0x02\t/* Absolute symbol */\n+#define MACH_O_N_SECT\t0x0e\t/* Defined in section */\n+\n+#define MACH_O_N_TYPE\t0x0e\t/* Mask for type bits */\n+#define MACH_O_N_STAB\t0xe0\t/* Stabs debugging symbol */\n+\n+/* Information we keep for a Mach-O symbol.  */\n+\n+struct macho_symbol\n+{\n+  const char *name;\t/* Symbol name */\n+  uintptr_t address;\t/* Symbol address */\n+};\n+\n+/* Information to pass to macho_syminfo.  */\n+\n+struct macho_syminfo_data\n+{\n+  struct macho_syminfo_data *next;\t/* Next module */\n+  struct macho_symbol *symbols;\t\t/* Symbols sorted by address */\n+  size_t count;\t\t\t\t/* Number of symbols */\n+};\n+\n+/* Names of sections, indexed by enum dwarf_section in internal.h.  */\n+\n+static const char * const dwarf_section_names[DEBUG_MAX] =\n+{\n+  \"__debug_info\",\n+  \"__debug_line\",\n+  \"__debug_abbrev\",\n+  \"__debug_ranges\",\n+  \"__debug_str\",\n+  \"\", /* DEBUG_ADDR */\n+  \"__debug_str_offs\",\n+  \"\", /* DEBUG_LINE_STR */\n+  \"__debug_rnglists\"\n+};\n+\n+/* Forward declaration.  */\n+\n+static int macho_add (struct backtrace_state *, const char *, int, off_t,\n+\t\t      const unsigned char *, uintptr_t, int,\n+\t\t      backtrace_error_callback, void *, fileline *, int *);\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n+\n+static int\n+macho_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t       uintptr_t pc ATTRIBUTE_UNUSED,\n+\t       backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t       backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in Mach-O executable\", -1);\n+  return 0;\n+}\n+\n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+macho_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t      uintptr_t addr ATTRIBUTE_UNUSED,\n+\t      backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t      backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in Mach-O executable\", -1);\n+}\n+\n+/* Add a single DWARF section to DWARF_SECTIONS, if we need the\n+   section.  Returns 1 on success, 0 on failure.  */\n+\n+static int\n+macho_add_dwarf_section (struct backtrace_state *state, int descriptor,\n+\t\t\t const char *sectname, uint32_t offset, uint64_t size,\n+\t\t\t backtrace_error_callback error_callback, void *data,\n+\t\t\t struct dwarf_sections *dwarf_sections)\n+{\n+  int i;\n+\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      if (dwarf_section_names[i][0] != '\\0'\n+\t  && strncmp (sectname, dwarf_section_names[i], MACH_O_NAMELEN) == 0)\n+\t{\n+\t  struct backtrace_view section_view;\n+\n+\t  /* FIXME: Perhaps it would be better to try to use a single\n+\t     view to read all the DWARF data, as we try to do for\n+\t     ELF.  */\n+\n+\t  if (!backtrace_get_view (state, descriptor, offset, size,\n+\t\t\t\t   error_callback, data, &section_view))\n+\t    return 0;\n+\t  dwarf_sections->data[i] = (const unsigned char *) section_view.data;\n+\t  dwarf_sections->size[i] = size;\n+\t  break;\n+\t}\n+    }\n+  return 1;\n+}\n+\n+/* Collect DWARF sections from a DWARF segment.  Returns 1 on success,\n+   0 on failure.  */\n+\n+static int\n+macho_add_dwarf_segment (struct backtrace_state *state, int descriptor,\n+\t\t\t off_t offset, unsigned int cmd, const char *psecs,\n+\t\t\t size_t sizesecs, unsigned int nsects,\n+\t\t\t backtrace_error_callback error_callback, void *data,\n+\t\t\t struct dwarf_sections *dwarf_sections)\n+{\n+  size_t sec_header_size;\n+  size_t secoffset;\n+  unsigned int i;\n+\n+  switch (cmd)\n+    {\n+    case MACH_O_LC_SEGMENT:\n+      sec_header_size = sizeof (struct macho_section);\n+      break;\n+    case MACH_O_LC_SEGMENT_64:\n+      sec_header_size = sizeof (struct macho_section_64);\n+      break;\n+    default:\n+      abort ();\n+    }\n+\n+  secoffset = 0;\n+  for (i = 0; i < nsects; ++i)\n+    {\n+      if (secoffset + sec_header_size > sizesecs)\n+\t{\n+\t  error_callback (data, \"section overflow withing segment\", 0);\n+\t  return 0;\n+\t}\n+\n+      switch (cmd)\n+\t{\n+\tcase MACH_O_LC_SEGMENT:\n+\t  {\n+\t    struct macho_section section;\n+\n+\t    memcpy (&section, psecs + secoffset, sizeof section);\n+\t    macho_add_dwarf_section (state, descriptor, section.sectname,\n+\t\t\t\t     offset + section.offset, section.size,\n+\t\t\t\t     error_callback, data, dwarf_sections);\n+\t  }\n+\t  break;\n+\n+\tcase MACH_O_LC_SEGMENT_64:\n+\t  {\n+\t    struct macho_section_64 section;\n+\n+\t    memcpy (&section, psecs + secoffset, sizeof section);\n+\t    macho_add_dwarf_section (state, descriptor, section.sectname,\n+\t\t\t\t     offset + section.offset, section.size,\n+\t\t\t\t     error_callback, data, dwarf_sections);\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      secoffset += sec_header_size;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Compare struct macho_symbol for qsort.  */\n+\n+static int\n+macho_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct macho_symbol *m1 = (const struct macho_symbol *) v1;\n+  const struct macho_symbol *m2 = (const struct macho_symbol *) v2;\n+\n+  if (m1->address < m2->address)\n+    return -1;\n+  else if (m1->address > m2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Compare an address against a macho_symbol for bsearch.  We allocate\n+   one extra entry in the array so that this can safely look at the\n+   next entry.  */\n+\n+static int\n+macho_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct macho_symbol *entry = (const struct macho_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->address)\n+    return -1;\n+  else if (entry->name[0] == '\\0'\n+\t   && entry->address == ~(uintptr_t) 0)\n+    return -1;\n+  else if ((entry + 1)->name[0] == '\\0'\n+\t   && (entry + 1)->address == ~(uintptr_t) 0)\n+    return -1;\n+  else if (addr >= (entry + 1)->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Return whether the symbol type field indicates a symbol table entry\n+   that we care about: a function or data symbol.  */\n+\n+static int\n+macho_defined_symbol (uint8_t type)\n+{\n+  if ((type & MACH_O_N_STAB) != 0)\n+    return 0;\n+  if ((type & MACH_O_N_EXT) != 0)\n+    return 0;\n+  switch (type & MACH_O_N_TYPE)\n+    {\n+    case MACH_O_N_ABS:\n+      return 1;\n+    case MACH_O_N_SECT:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Add symbol table information for a Mach-O file.  */\n+\n+static int\n+macho_add_symtab (struct backtrace_state *state, int descriptor,\n+\t\t  uintptr_t base_address, int is_64,\n+\t\t  off_t symoff, unsigned int nsyms, off_t stroff,\n+\t\t  unsigned int strsize,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  size_t symsize;\n+  struct backtrace_view sym_view;\n+  int sym_view_valid;\n+  struct backtrace_view str_view;\n+  int str_view_valid;\n+  size_t ndefs;\n+  size_t symtaboff;\n+  unsigned int i;\n+  size_t macho_symbol_size;\n+  struct macho_symbol *macho_symbols;\n+  unsigned int j;\n+  struct macho_syminfo_data *sdata;\n+\n+  sym_view_valid = 0;\n+  str_view_valid = 0;\n+  macho_symbol_size = 0;\n+  macho_symbols = NULL;\n+\n+  if (is_64)\n+    symsize = sizeof (struct macho_nlist_64);\n+  else\n+    symsize = sizeof (struct macho_nlist);\n+\n+  if (!backtrace_get_view (state, descriptor, symoff, nsyms * symsize,\n+\t\t\t   error_callback, data, &sym_view))\n+    goto fail;\n+  sym_view_valid = 1;\n+\n+  if (!backtrace_get_view (state, descriptor, stroff, strsize,\n+\t\t\t   error_callback, data, &str_view))\n+    return 0;\n+  str_view_valid = 1;\n+\n+  ndefs = 0;\n+  symtaboff = 0;\n+  for (i = 0; i < nsyms; ++i, symtaboff += symsize)\n+    {\n+      if (is_64)\n+\t{\n+\t  struct macho_nlist_64 nlist;\n+\n+\t  memcpy (&nlist, (const char *) sym_view.data + symtaboff,\n+\t\t  sizeof nlist);\n+\t  if (macho_defined_symbol (nlist.n_type))\n+\t    ++ndefs;\n+\t}\n+      else\n+\t{\n+\t  struct macho_nlist nlist;\n+\n+\t  memcpy (&nlist, (const char *) sym_view.data + symtaboff,\n+\t\t  sizeof nlist);\n+\t  if (macho_defined_symbol (nlist.n_type))\n+\t    ++ndefs;\n+\t}\n+    }\n+\n+  /* Add 1 to ndefs to make room for a sentinel.  */\n+  macho_symbol_size = (ndefs + 1) * sizeof (struct macho_symbol);\n+  macho_symbols = ((struct macho_symbol *)\n+\t\t   backtrace_alloc (state, macho_symbol_size, error_callback,\n+\t\t\t\t    data));\n+  if (macho_symbols == NULL)\n+    goto fail;\n+\n+  j = 0;\n+  symtaboff = 0;\n+  for (i = 0; i < nsyms; ++i, symtaboff += symsize)\n+    {\n+      uint32_t strx;\n+      uint64_t value;\n+      const char *name;\n+\n+      strx = 0;\n+      value = 0;\n+      if (is_64)\n+\t{\n+\t  struct macho_nlist_64 nlist;\n+\n+\t  memcpy (&nlist, (const char *) sym_view.data + symtaboff,\n+\t\t  sizeof nlist);\n+\t  if (!macho_defined_symbol (nlist.n_type))\n+\t    continue;\n+\n+\t  strx = nlist.n_strx;\n+\t  value = nlist.n_value;\n+\t}\n+      else\n+\t{\n+\t  struct macho_nlist nlist;\n+\n+\t  memcpy (&nlist, (const char *) sym_view.data + symtaboff,\n+\t\t  sizeof nlist);\n+\t  if (!macho_defined_symbol (nlist.n_type))\n+\t    continue;\n+\n+\t  strx = nlist.n_strx;\n+\t  value = nlist.n_value;\n+\t}\n+\n+      if (strx >= strsize)\n+\t{\n+\t  error_callback (data, \"symbol string index out of range\", 0);\n+\t  goto fail;\n+\t}\n+\n+      name = (const char *) str_view.data + strx;\n+      if (name[0] == '_')\n+\t++name;\n+      macho_symbols[j].name = name;\n+      macho_symbols[j].address = value + base_address;\n+      ++j;\n+    }\n+\n+  sdata = ((struct macho_syminfo_data *)\n+\t   backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+  if (sdata == NULL)\n+    goto fail;\n+\n+  /* We need to keep the string table since it holds the names, but we\n+     can release the symbol table.  */\n+\n+  backtrace_release_view (state, &sym_view, error_callback, data);\n+  sym_view_valid = 0;\n+  str_view_valid = 0;\n+\n+  /* Add a trailing sentinel symbol.  */\n+  macho_symbols[j].name = \"\";\n+  macho_symbols[j].address = ~(uintptr_t) 0;\n+\n+  backtrace_qsort (macho_symbols, ndefs + 1, sizeof (struct macho_symbol),\n+\t\t   macho_symbol_compare);\n+\n+  sdata->next = NULL;\n+  sdata->symbols = macho_symbols;\n+  sdata->count = ndefs;\n+\n+  if (!state->threaded)\n+    {\n+      struct macho_syminfo_data **pp;\n+\n+      for (pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = sdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct macho_syminfo_data **pp;\n+\n+\t  pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct macho_syminfo_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\t      \n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, sdata))\n+\t    break;\n+\t}\n+    }\n+\n+  return 1;\n+\n+ fail:\n+  if (macho_symbols != NULL)\n+    backtrace_free (state, macho_symbols, macho_symbol_size,\n+\t\t    error_callback, data);\n+  if (sym_view_valid)\n+    backtrace_release_view (state, &sym_view, error_callback, data);\n+  if (str_view_valid)\n+    backtrace_release_view (state, &str_view, error_callback, data);\n+  return 0;\n+}\n+\n+/* Return the symbol name and value for an ADDR.  */\n+\n+static void\n+macho_syminfo (struct backtrace_state *state, uintptr_t addr,\n+\t       backtrace_syminfo_callback callback,\n+\t       backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t       void *data)\n+{\n+  struct macho_syminfo_data *sdata;\n+  struct macho_symbol *sym;\n+\n+  sym = NULL;\n+  if (!state->threaded)\n+    {\n+      for (sdata = (struct macho_syminfo_data *) state->syminfo_data;\n+\t   sdata != NULL;\n+\t   sdata = sdata->next)\n+\t{\n+\t  sym = ((struct macho_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct macho_symbol), macho_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      struct macho_syminfo_data **pp;\n+\n+      pp = (struct macho_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+\t{\n+\t  sdata = backtrace_atomic_load_pointer (pp);\n+\t  if (sdata == NULL)\n+\t    break;\n+\n+\t  sym = ((struct macho_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct macho_symbol), macho_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\n+\t  pp = &sdata->next;\n+\t}\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->address, 0);\n+}\n+\n+/* Look through a fat file to find the relevant executable.  Returns 1\n+   on success, 0 on failure (in both cases descriptor is closed).  */\n+\n+static int\n+macho_add_fat (struct backtrace_state *state, const char *filename,\n+\t       int descriptor, int swapped, off_t offset,\n+\t       const unsigned char *match_uuid, uintptr_t base_address,\n+\t       int skip_symtab, uint32_t nfat_arch, int is_64,\n+\t       backtrace_error_callback error_callback, void *data,\n+\t       fileline *fileline_fn, int *found_sym)\n+{\n+  int arch_view_valid;\n+  unsigned int cputype;\n+  size_t arch_size;\n+  struct backtrace_view arch_view;\n+  unsigned int i;\n+\n+  arch_view_valid = 0;\n+\n+#if defined (__x86_64__)\n+  cputype = MACH_O_CPU_TYPE_X86_64;\n+#elif defined (__i386__)\n+  cputype = MACH_O_CPU_TYPE_X86;\n+#elif defined (__aarch64__)\n+  cputype = MACH_O_CPU_TYPE_ARM64;\n+#elif defined (__arm__)\n+  cputype = MACH_O_CPU_TYPE_ARM;\n+#elif defined (__ppc__)\n+  cputype = MACH_O_CPU_TYPE_PPC;\n+#elif defined (__ppc64__)\n+  cputype = MACH_O_CPU_TYPE_PPC64;\n+#else\n+  error_callback (data, \"unknown Mach-O architecture\", 0);\n+  goto fail;\n+#endif\n+\n+  if (is_64)\n+    arch_size = sizeof (struct macho_fat_arch_64);\n+  else\n+    arch_size = sizeof (struct macho_fat_arch);\n+\n+  if (!backtrace_get_view (state, descriptor, offset,\n+\t\t\t   nfat_arch * arch_size,\n+\t\t\t   error_callback, data, &arch_view))\n+    goto fail;\n+\n+  for (i = 0; i < nfat_arch; ++i)\n+    {\n+      uint32_t fcputype;\n+      uint64_t foffset;\n+\n+      if (is_64)\n+\t{\n+\t  struct macho_fat_arch_64 fat_arch_64;\n+\n+\t  memcpy (&fat_arch_64,\n+\t\t  (const char *) arch_view.data + i * arch_size,\n+\t\t  arch_size);\n+\t  fcputype = fat_arch_64.cputype;\n+\t  foffset = fat_arch_64.offset;\n+\t  if (swapped)\n+\t    {\n+\t      fcputype = __builtin_bswap32 (fcputype);\n+\t      foffset = __builtin_bswap64 (foffset);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  struct macho_fat_arch fat_arch_32;\n+\n+\t  memcpy (&fat_arch_32,\n+\t\t  (const char *) arch_view.data + i * arch_size,\n+\t\t  arch_size);\n+\t  fcputype = fat_arch_32.cputype;\n+\t  foffset = (uint64_t) fat_arch_32.offset;\n+\t  if (swapped)\n+\t    {\n+\t      fcputype = __builtin_bswap32 (fcputype);\n+\t      foffset = (uint64_t) __builtin_bswap32 ((uint32_t) foffset);\n+\t    }\n+\t}\n+\n+      if (fcputype == cputype)\n+\t{\n+\t  /* FIXME: What about cpusubtype?  */\n+\t  backtrace_release_view (state, &arch_view, error_callback, data);\n+\t  return macho_add (state, filename, descriptor, foffset, match_uuid,\n+\t\t\t    base_address, skip_symtab, error_callback, data,\n+\t\t\t    fileline_fn, found_sym);\n+\t}\n+    }\n+\n+  error_callback (data, \"could not find executable in fat file\", 0);\n+\n+ fail:\n+  if (arch_view_valid)\n+    backtrace_release_view (state, &arch_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+/* Look for the dsym file for FILENAME.  This is called if FILENAME\n+   does not have debug info or a symbol table.  Returns 1 on success,\n+   0 on failure.  */\n+\n+static int\n+macho_add_dsym (struct backtrace_state *state, const char *filename,\n+\t\tuintptr_t base_address, const unsigned char *uuid,\n+\t\tbacktrace_error_callback error_callback, void *data,\n+\t\tfileline* fileline_fn)\n+{\n+  const char *p;\n+  const char *dirname;\n+  char *diralc;\n+  size_t dirnamelen;\n+  const char *basename;\n+  size_t basenamelen;\n+  const char *dsymsuffixdir;\n+  size_t dsymsuffixdirlen;\n+  size_t dsymlen;\n+  char *dsym;\n+  char *ps;\n+  int d;\n+  int does_not_exist;\n+  int dummy_found_sym;\n+\n+  diralc = NULL;\n+  dirnamelen = 0;\n+  dsym = NULL;\n+  dsymlen = 0;\n+\n+  p = strrchr (filename, '/');\n+  if (p == NULL)\n+    {\n+      dirname = \".\";\n+      dirnamelen = 1;\n+      basename = filename;\n+      basenamelen = strlen (basename);\n+      diralc = NULL;\n+    }\n+  else\n+    {\n+      dirnamelen = p - filename;\n+      diralc = backtrace_alloc (state, dirnamelen + 1, error_callback, data);\n+      if (diralc == NULL)\n+\tgoto fail;\n+      memcpy (diralc, filename, dirnamelen);\n+      diralc[dirnamelen] = '\\0';\n+      dirname = diralc;\n+      basename = p + 1;\n+      basenamelen = strlen (basename);\n+    }\n+\n+  dsymsuffixdir = \".dSYM/Contents/Resources/DWARF/\";\n+  dsymsuffixdirlen = strlen (dsymsuffixdir);\n+\n+  dsymlen = (dirnamelen\n+\t     + 1\n+\t     + basenamelen\n+\t     + dsymsuffixdirlen\n+\t     + basenamelen\n+\t     + 1);\n+  dsym = backtrace_alloc (state, dsymlen, error_callback, data);\n+  if (dsym == NULL)\n+    goto fail;\n+\n+  ps = dsym;\n+  memcpy (ps, dirname, dirnamelen);\n+  ps += dirnamelen;\n+  *ps++ = '/';\n+  memcpy (ps, basename, basenamelen);\n+  ps += basenamelen;\n+  memcpy (ps, dsymsuffixdir, dsymsuffixdirlen);\n+  ps += dsymsuffixdirlen;\n+  memcpy (ps, basename, basenamelen);\n+  ps += basenamelen;\n+  *ps = '\\0';\n+\n+  if (diralc != NULL)\n+    {\n+      backtrace_free (state, diralc, dirnamelen + 1, error_callback, data);\n+      diralc = NULL;\n+    }\n+\n+  d = backtrace_open (dsym, error_callback, data, &does_not_exist);\n+  if (d < 0)\n+    {\n+      /* The file does not exist, so we can't read the debug info.\n+\t Just return success.  */\n+      backtrace_free (state, dsym, dsymlen, error_callback, data);\n+      return 1;\n+    }\n+\n+  if (!macho_add (state, dsym, d, 0, uuid, base_address, 1,\n+\t\t  error_callback, data, fileline_fn, &dummy_found_sym))\n+    goto fail;\n+\n+  backtrace_free (state, dsym, dsymlen, error_callback, data);\n+\n+  return 1;\n+\n+ fail:\n+  if (dsym != NULL)\n+    backtrace_free (state, dsym, dsymlen, error_callback, data);\n+  if (diralc != NULL)\n+    backtrace_free (state, diralc, dirnamelen, error_callback, data);\n+  return 0;\n+}\n+\n+/* Add the backtrace data for a Macho-O file.  Returns 1 on success, 0\n+   on failure (in both cases descriptor is closed).\n+\n+   FILENAME: the name of the executable.\n+   DESCRIPTOR: an open descriptor for the executable, closed here.\n+   OFFSET: the offset within the file of this executable, for fat files.\n+   MATCH_UUID: if not NULL, UUID that must match.\n+   BASE_ADDRESS: the load address of the executable.\n+   SKIP_SYMTAB: if non-zero, ignore the symbol table; used for dSYM files.\n+   FILELINE_FN: set to the fileline function, by backtrace_dwarf_add.\n+   FOUND_SYM: set to non-zero if we found the symbol table.\n+*/\n+\n+static int\n+macho_add (struct backtrace_state *state, const char *filename, int descriptor,\n+\t   off_t offset, const unsigned char *match_uuid,\n+\t   uintptr_t base_address, int skip_symtab,\n+\t   backtrace_error_callback error_callback, void *data,\n+\t   fileline *fileline_fn, int *found_sym)\n+{\n+  struct backtrace_view header_view;\n+  struct macho_header_32 header;\n+  off_t hdroffset;\n+  int is_64;\n+  struct backtrace_view cmds_view;\n+  int cmds_view_valid;\n+  struct dwarf_sections dwarf_sections;\n+  int have_dwarf;\n+  unsigned char uuid[MACH_O_UUID_LEN];\n+  int have_uuid;\n+  size_t cmdoffset;\n+  unsigned int i;\n+\n+  *found_sym = 0;\n+\n+  cmds_view_valid = 0;\n+\n+  /* The 32-bit and 64-bit file headers start out the same, so we can\n+     just always read the 32-bit version.  A fat header is shorter but\n+     it will always be followed by data, so it's OK to read extra.  */\n+\n+  if (!backtrace_get_view (state, descriptor, offset,\n+\t\t\t   sizeof (struct macho_header_32),\n+\t\t\t   error_callback, data, &header_view))\n+    goto fail;\n+\n+  memcpy (&header, header_view.data, sizeof header);\n+\n+  backtrace_release_view (state, &header_view, error_callback, data);\n+\n+  switch (header.magic)\n+    {\n+    case MACH_O_MH_MAGIC_32:\n+      is_64 = 0;\n+      hdroffset = offset + sizeof (struct macho_header_32);\n+      break;\n+    case MACH_O_MH_MAGIC_64:\n+      is_64 = 1;\n+      hdroffset = offset + sizeof (struct macho_header_64);\n+      break;\n+    case MACH_O_MH_MAGIC_FAT:\n+    case MACH_O_MH_MAGIC_FAT_64:\n+      {\n+\tstruct macho_header_fat fat_header;\n+\n+\thdroffset = offset + sizeof (struct macho_header_fat);\n+\tmemcpy (&fat_header, &header, sizeof fat_header);\n+\treturn macho_add_fat (state, filename, descriptor, 0, hdroffset,\n+\t\t\t      match_uuid, base_address, skip_symtab,\n+\t\t\t      fat_header.nfat_arch,\n+\t\t\t      header.magic == MACH_O_MH_MAGIC_FAT_64,\n+\t\t\t      error_callback, data, fileline_fn, found_sym);\n+      }\n+    case MACH_O_MH_CIGAM_FAT:\n+    case MACH_O_MH_CIGAM_FAT_64:\n+      {\n+\tstruct macho_header_fat fat_header;\n+\tuint32_t nfat_arch;\n+\n+\thdroffset = offset + sizeof (struct macho_header_fat);\n+\tmemcpy (&fat_header, &header, sizeof fat_header);\n+\tnfat_arch = __builtin_bswap32 (fat_header.nfat_arch);\n+\treturn macho_add_fat (state, filename, descriptor, 1, hdroffset,\n+\t\t\t      match_uuid, base_address, skip_symtab,\n+\t\t\t      nfat_arch,\n+\t\t\t      header.magic == MACH_O_MH_CIGAM_FAT_64,\n+\t\t\t      error_callback, data, fileline_fn, found_sym);\n+      }\n+    default:\n+      error_callback (data, \"executable file is not in Mach-O format\", 0);\n+      goto fail;\n+    }\n+\n+  switch (header.filetype)\n+    {\n+    case MACH_O_MH_EXECUTE:\n+    case MACH_O_MH_DYLIB:\n+    case MACH_O_MH_DSYM:\n+      break;\n+    default:\n+      error_callback (data, \"executable file is not an executable\", 0);\n+      goto fail;\n+    }\n+\n+  if (!backtrace_get_view (state, descriptor, hdroffset, header.sizeofcmds,\n+\t\t\t   error_callback, data, &cmds_view))\n+    goto fail;\n+  cmds_view_valid = 1;\n+\n+  memset (&dwarf_sections, 0, sizeof dwarf_sections);\n+  have_dwarf = 0;\n+  memset (&uuid, 0, sizeof uuid);\n+  have_uuid = 0;\n+\n+  cmdoffset = 0;\n+  for (i = 0; i < header.ncmds; ++i)\n+    {\n+      const char *pcmd;\n+      struct macho_load_command load_command;\n+\n+      if (cmdoffset + sizeof load_command > header.sizeofcmds)\n+\tbreak;\n+\n+      pcmd = (const char *) cmds_view.data + cmdoffset;\n+      memcpy (&load_command, pcmd, sizeof load_command);\n+\n+      switch (load_command.cmd)\n+\t{\n+\tcase MACH_O_LC_SEGMENT:\n+\t  {\n+\t    struct macho_segment_command segcmd;\n+\n+\t    memcpy (&segcmd, pcmd, sizeof segcmd);\n+\t    if (memcmp (segcmd.segname,\n+\t\t\t\"__DWARF\\0\\0\\0\\0\\0\\0\\0\\0\\0\",\n+\t\t\tMACH_O_NAMELEN) == 0)\n+\t      {\n+\t\tif (!macho_add_dwarf_segment (state, descriptor, offset,\n+\t\t\t\t\t      load_command.cmd,\n+\t\t\t\t\t      pcmd + sizeof segcmd,\n+\t\t\t\t\t      (load_command.cmdsize\n+\t\t\t\t\t       - sizeof segcmd),\n+\t\t\t\t\t      segcmd.nsects, error_callback,\n+\t\t\t\t\t      data, &dwarf_sections))\n+\t\t  goto fail;\n+\t\thave_dwarf = 1;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase MACH_O_LC_SEGMENT_64:\n+\t  {\n+\t    struct macho_segment_64_command segcmd;\n+\n+\t    memcpy (&segcmd, pcmd, sizeof segcmd);\n+\t    if (memcmp (segcmd.segname,\n+\t\t\t\"__DWARF\\0\\0\\0\\0\\0\\0\\0\\0\\0\",\n+\t\t\tMACH_O_NAMELEN) == 0)\n+\t      {\n+\t\tif (!macho_add_dwarf_segment (state, descriptor, offset,\n+\t\t\t\t\t      load_command.cmd,\n+\t\t\t\t\t      pcmd + sizeof segcmd,\n+\t\t\t\t\t      (load_command.cmdsize\n+\t\t\t\t\t       - sizeof segcmd),\n+\t\t\t\t\t      segcmd.nsects, error_callback,\n+\t\t\t\t\t      data, &dwarf_sections))\n+\t\t  goto fail;\n+\t\thave_dwarf = 1;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase MACH_O_LC_SYMTAB:\n+\t  if (!skip_symtab)\n+\t    {\n+\t      struct macho_symtab_command symcmd;\n+\n+\t      memcpy (&symcmd, pcmd, sizeof symcmd);\n+\t      if (!macho_add_symtab (state, descriptor, base_address, is_64,\n+\t\t\t\t     offset + symcmd.symoff, symcmd.nsyms,\n+\t\t\t\t     offset + symcmd.stroff, symcmd.strsize,\n+\t\t\t\t     error_callback, data))\n+\t\tgoto fail;\n+\n+\t      *found_sym = 1;\n+\t    }\n+\t  break;\n+\n+\tcase MACH_O_LC_UUID:\n+\t  {\n+\t    struct macho_uuid_command uuidcmd;\n+\n+\t    memcpy (&uuidcmd, pcmd, sizeof uuidcmd);\n+\t    memcpy (&uuid[0], &uuidcmd.uuid[0], MACH_O_UUID_LEN);\n+\t    have_uuid = 1;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+\n+      cmdoffset += load_command.cmdsize;\n+    }\n+\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  backtrace_release_view (state, &cmds_view, error_callback, data);\n+  cmds_view_valid = 0;\n+\n+  if (match_uuid != NULL)\n+    {\n+      /* If we don't have a UUID, or it doesn't match, just ignore\n+\t this file.  */\n+      if (!have_uuid\n+\t  || memcmp (match_uuid, &uuid[0], MACH_O_UUID_LEN) != 0)\n+\treturn 1;\n+    }\n+\n+  if (have_dwarf)\n+    {\n+      int is_big_endian;\n+\n+      is_big_endian = 0;\n+#if defined(__BYTE_ORDER__) && defined(__ORDER_BIG_ENDIAN__)\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+      is_big_endian = 1;\n+#endif\n+#endif\n+\n+      if (!backtrace_dwarf_add (state, base_address, &dwarf_sections,\n+\t\t\t\tis_big_endian, NULL, error_callback, data,\n+\t\t\t\tfileline_fn, NULL))\n+\tgoto fail;\n+    }\n+\n+  if (!have_dwarf && have_uuid)\n+    {\n+      if (!macho_add_dsym (state, filename, base_address, &uuid[0],\n+\t\t\t   error_callback, data, fileline_fn))\n+\tgoto fail;\n+    }\n+\n+  return 1;\n+\n+ fail:\n+  if (cmds_view_valid)\n+    backtrace_release_view (state, &cmds_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+#ifdef HAVE_MACH_O_DYLD_H\n+\n+/* Initialize the backtrace data we need from a Mach-O executable\n+   using the dyld support functions.  This closes descriptor.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, const char *filename,\n+\t\t      int descriptor, backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  uint32_t c;\n+  uint32_t i;\n+  int closed_descriptor;\n+  int found_sym;\n+  fileline macho_fileline_fn;\n+\n+  closed_descriptor = 0;\n+  found_sym = 0;\n+  macho_fileline_fn = macho_nodebug;\n+\n+  c = _dyld_image_count ();\n+  for (i = 0; i < c; ++i)\n+    {\n+      uintptr_t base_address;\n+      const char *name;\n+      int d;\n+      fileline mff;\n+      int mfs;\n+\n+      name = _dyld_get_image_name (i);\n+      if (name == NULL)\n+\tcontinue;\n+\n+      if (strcmp (name, filename) == 0 && !closed_descriptor)\n+\t{\n+\t  d = descriptor;\n+\t  closed_descriptor = 1;\n+\t}\n+      else\n+\t{\n+\t  int does_not_exist;\n+\n+\t  d = backtrace_open (name, error_callback, data, &does_not_exist);\n+\t  if (d < 0)\n+\t    continue;\n+\t}\n+\n+      base_address = _dyld_get_image_vmaddr_slide (i);\n+\n+      mff = macho_nodebug;\n+      if (!macho_add (state, name, d, 0, NULL, base_address, 0,\n+\t\t      error_callback, data, &mff, &mfs))\n+\treturn 0;\n+\n+      if (mff != macho_nodebug)\n+\tmacho_fileline_fn = mff;\n+      if (mfs)\n+\tfound_sym = 1;\n+    }\n+\n+  if (!closed_descriptor)\n+    backtrace_close (descriptor, error_callback, data);\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = macho_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = macho_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, macho_syminfo);\n+      else\n+\t(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n+\t\t\t\t\t     macho_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    *fileline_fn = state->fileline_fn;\n+  else\n+    *fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+\n+  if (*fileline_fn == NULL || *fileline_fn == macho_nodebug)\n+    *fileline_fn = macho_fileline_fn;\n+\n+  return 1;\n+}\n+\n+#else /* !defined (HAVE_MACH_O_DYLD_H) */\n+\n+/* Initialize the backtrace data we need from a Mach-O executable\n+   without using the dyld support functions.  This closes\n+   descriptor.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state, const char *filename,\n+\t\t      int descriptor, backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  fileline macho_fileline_fn;\n+  int found_sym;\n+\n+  macho_fileline_fn = macho_nodebug;\n+  if (!macho_add (state, filename, descriptor, 0, NULL, 0, 0,\n+\t\t  error_callback, data, &macho_fileline_fn, &found_sym))\n+    return 0;\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = macho_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = macho_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, macho_syminfo);\n+      else\n+\t(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n+\t\t\t\t\t     macho_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    *fileline_fn = state->fileline_fn;\n+  else\n+    *fileline_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+\n+  if (*fileline_fn == NULL || *fileline_fn == macho_nodebug)\n+    *fileline_fn = macho_fileline_fn;\n+\n+  return 1;\n+}\n+\n+#endif /* !defined (HAVE_MACH_O_DYLD_H) */"
    },
    {
      "sha": "d7313be73f7d14bf207fb8328da3579ae72ea477",
      "filename": "libbacktrace/mmap.c",
      "status": "added",
      "additions": 331,
      "deletions": 0,
      "changes": 331,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/mmap.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/mmap.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/mmap.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,331 @@\n+/* mmap.c -- Memory allocation with mmap.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <sys/types.h>\n+#include <sys/mman.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef HAVE_DECL_GETPAGESIZE\n+extern int getpagesize (void);\n+#endif\n+\n+/* Memory allocation on systems that provide anonymous mmap.  This\n+   permits the backtrace functions to be invoked from a signal\n+   handler, assuming that mmap is async-signal safe.  */\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+\n+#ifndef MAP_FAILED\n+#define MAP_FAILED ((void *)-1)\n+#endif\n+\n+/* A list of free memory blocks.  */\n+\n+struct backtrace_freelist_struct\n+{\n+  /* Next on list.  */\n+  struct backtrace_freelist_struct *next;\n+  /* Size of this block, including this structure.  */\n+  size_t size;\n+};\n+\n+/* Free memory allocated by backtrace_alloc.  */\n+\n+static void\n+backtrace_free_locked (struct backtrace_state *state, void *addr, size_t size)\n+{\n+  /* Just leak small blocks.  We don't have to be perfect.  Don't put\n+     more than 16 entries on the free list, to avoid wasting time\n+     searching when allocating a block.  If we have more than 16\n+     entries, leak the smallest entry.  */\n+\n+  if (size >= sizeof (struct backtrace_freelist_struct))\n+    {\n+      size_t c;\n+      struct backtrace_freelist_struct **ppsmall;\n+      struct backtrace_freelist_struct **pp;\n+      struct backtrace_freelist_struct *p;\n+\n+      c = 0;\n+      ppsmall = NULL;\n+      for (pp = &state->freelist; *pp != NULL; pp = &(*pp)->next)\n+\t{\n+\t  if (ppsmall == NULL || (*pp)->size < (*ppsmall)->size)\n+\t    ppsmall = pp;\n+\t  ++c;\n+\t}\n+      if (c >= 16)\n+\t{\n+\t  if (size <= (*ppsmall)->size)\n+\t    return;\n+\t  *ppsmall = (*ppsmall)->next;\n+\t}\n+\n+      p = (struct backtrace_freelist_struct *) addr;\n+      p->next = state->freelist;\n+      p->size = size;\n+      state->freelist = p;\n+    }\n+}\n+\n+/* Allocate memory like malloc.  If ERROR_CALLBACK is NULL, don't\n+   report an error.  */\n+\n+void *\n+backtrace_alloc (struct backtrace_state *state,\n+\t\t size_t size, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  void *ret;\n+  int locked;\n+  struct backtrace_freelist_struct **pp;\n+  size_t pagesize;\n+  size_t asksize;\n+  void *page;\n+\n+  ret = NULL;\n+\n+  /* If we can acquire the lock, then see if there is space on the\n+     free list.  If we can't acquire the lock, drop straight into\n+     using mmap.  __sync_lock_test_and_set returns the old state of\n+     the lock, so we have acquired it if it returns 0.  */\n+\n+  if (!state->threaded)\n+    locked = 1;\n+  else\n+    locked = __sync_lock_test_and_set (&state->lock_alloc, 1) == 0;\n+\n+  if (locked)\n+    {\n+      for (pp = &state->freelist; *pp != NULL; pp = &(*pp)->next)\n+\t{\n+\t  if ((*pp)->size >= size)\n+\t    {\n+\t      struct backtrace_freelist_struct *p;\n+\n+\t      p = *pp;\n+\t      *pp = p->next;\n+\n+\t      /* Round for alignment; we assume that no type we care about\n+\t\t is more than 8 bytes.  */\n+\t      size = (size + 7) & ~ (size_t) 7;\n+\t      if (size < p->size)\n+\t\tbacktrace_free_locked (state, (char *) p + size,\n+\t\t\t\t       p->size - size);\n+\n+\t      ret = (void *) p;\n+\n+\t      break;\n+\t    }\n+\t}\n+\n+      if (state->threaded)\n+\t__sync_lock_release (&state->lock_alloc);\n+    }\n+\n+  if (ret == NULL)\n+    {\n+      /* Allocate a new page.  */\n+\n+      pagesize = getpagesize ();\n+      asksize = (size + pagesize - 1) & ~ (pagesize - 1);\n+      page = mmap (NULL, asksize, PROT_READ | PROT_WRITE,\n+\t\t   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+      if (page == MAP_FAILED)\n+\t{\n+\t  if (error_callback)\n+\t    error_callback (data, \"mmap\", errno);\n+\t}\n+      else\n+\t{\n+\t  size = (size + 7) & ~ (size_t) 7;\n+\t  if (size < asksize)\n+\t    backtrace_free (state, (char *) page + size, asksize - size,\n+\t\t\t    error_callback, data);\n+\n+\t  ret = page;\n+\t}\n+    }\n+\n+  return ret;\n+}\n+\n+/* Free memory allocated by backtrace_alloc.  */\n+\n+void\n+backtrace_free (struct backtrace_state *state, void *addr, size_t size,\n+\t\tbacktrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\tvoid *data ATTRIBUTE_UNUSED)\n+{\n+  int locked;\n+\n+  /* If we are freeing a large aligned block, just release it back to\n+     the system.  This case arises when growing a vector for a large\n+     binary with lots of debug info.  Calling munmap here may cause us\n+     to call mmap again if there is also a large shared library; we\n+     just live with that.  */\n+  if (size >= 16 * 4096)\n+    {\n+      size_t pagesize;\n+\n+      pagesize = getpagesize ();\n+      if (((uintptr_t) addr & (pagesize - 1)) == 0\n+\t  && (size & (pagesize - 1)) == 0)\n+\t{\n+\t  /* If munmap fails for some reason, just add the block to\n+\t     the freelist.  */\n+\t  if (munmap (addr, size) == 0)\n+\t    return;\n+\t}\n+    }\n+\n+  /* If we can acquire the lock, add the new space to the free list.\n+     If we can't acquire the lock, just leak the memory.\n+     __sync_lock_test_and_set returns the old state of the lock, so we\n+     have acquired it if it returns 0.  */\n+\n+  if (!state->threaded)\n+    locked = 1;\n+  else\n+    locked = __sync_lock_test_and_set (&state->lock_alloc, 1) == 0;\n+\n+  if (locked)\n+    {\n+      backtrace_free_locked (state, addr, size);\n+\n+      if (state->threaded)\n+\t__sync_lock_release (&state->lock_alloc);\n+    }\n+}\n+\n+/* Grow VEC by SIZE bytes.  */\n+\n+void *\n+backtrace_vector_grow (struct backtrace_state *state,size_t size,\n+\t\t       backtrace_error_callback error_callback,\n+\t\t       void *data, struct backtrace_vector *vec)\n+{\n+  void *ret;\n+\n+  if (size > vec->alc)\n+    {\n+      size_t pagesize;\n+      size_t alc;\n+      void *base;\n+\n+      pagesize = getpagesize ();\n+      alc = vec->size + size;\n+      if (vec->size == 0)\n+\talc = 16 * size;\n+      else if (alc < pagesize)\n+\t{\n+\t  alc *= 2;\n+\t  if (alc > pagesize)\n+\t    alc = pagesize;\n+\t}\n+      else\n+\t{\n+\t  alc *= 2;\n+\t  alc = (alc + pagesize - 1) & ~ (pagesize - 1);\n+\t}\n+      base = backtrace_alloc (state, alc, error_callback, data);\n+      if (base == NULL)\n+\treturn NULL;\n+      if (vec->base != NULL)\n+\t{\n+\t  memcpy (base, vec->base, vec->size);\n+\t  backtrace_free (state, vec->base, vec->size + vec->alc,\n+\t\t\t  error_callback, data);\n+\t}\n+      vec->base = base;\n+      vec->alc = alc - vec->size;\n+    }\n+\n+  ret = (char *) vec->base + vec->size;\n+  vec->size += size;\n+  vec->alc -= size;\n+  return ret;\n+}\n+\n+/* Finish the current allocation on VEC.  */\n+\n+void *\n+backtrace_vector_finish (\n+  struct backtrace_state *state ATTRIBUTE_UNUSED,\n+  struct backtrace_vector *vec,\n+  backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+  void *data ATTRIBUTE_UNUSED)\n+{\n+  void *ret;\n+\n+  ret = vec->base;\n+  vec->base = (char *) vec->base + vec->size;\n+  vec->size = 0;\n+  return ret;\n+}\n+\n+/* Release any extra space allocated for VEC.  */\n+\n+int\n+backtrace_vector_release (struct backtrace_state *state,\n+\t\t\t  struct backtrace_vector *vec,\n+\t\t\t  backtrace_error_callback error_callback,\n+\t\t\t  void *data)\n+{\n+  size_t size;\n+  size_t alc;\n+  size_t aligned;\n+\n+  /* Make sure that the block that we free is aligned on an 8-byte\n+     boundary.  */\n+  size = vec->size;\n+  alc = vec->alc;\n+  aligned = (size + 7) & ~ (size_t) 7;\n+  alc -= aligned - size;\n+\n+  backtrace_free (state, (char *) vec->base + aligned, alc,\n+\t\t  error_callback, data);\n+  vec->alc = 0;\n+  if (vec->size == 0)\n+    vec->base = NULL;\n+  return 1;\n+}"
    },
    {
      "sha": "7f6fa8d274868b67efb2c57d22842bcc83eedf39",
      "filename": "libbacktrace/mmapio.c",
      "status": "added",
      "additions": 110,
      "deletions": 0,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/mmapio.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/mmapio.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/mmapio.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,110 @@\n+/* mmapio.c -- File views using mmap.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <sys/types.h>\n+#include <sys/mman.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef HAVE_DECL_GETPAGESIZE\n+extern int getpagesize (void);\n+#endif\n+\n+#ifndef MAP_FAILED\n+#define MAP_FAILED ((void *)-1)\n+#endif\n+\n+/* This file implements file views and memory allocation when mmap is\n+   available.  */\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */\n+\n+int\n+backtrace_get_view (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t    int descriptor, off_t offset, uint64_t size,\n+\t\t    backtrace_error_callback error_callback,\n+\t\t    void *data, struct backtrace_view *view)\n+{\n+  size_t pagesize;\n+  unsigned int inpage;\n+  off_t pageoff;\n+  void *map;\n+\n+  if ((uint64_t) (size_t) size != size)\n+    {\n+      error_callback (data, \"file size too large\", 0);\n+      return 0;\n+    }\n+\n+  pagesize = getpagesize ();\n+  inpage = offset % pagesize;\n+  pageoff = offset - inpage;\n+\n+  size += inpage;\n+  size = (size + (pagesize - 1)) & ~ (pagesize - 1);\n+\n+  map = mmap (NULL, size, PROT_READ, MAP_PRIVATE, descriptor, pageoff);\n+  if (map == MAP_FAILED)\n+    {\n+      error_callback (data, \"mmap\", errno);\n+      return 0;\n+    }\n+\n+  view->data = (char *) map + inpage;\n+  view->base = map;\n+  view->len = size;\n+\n+  return 1;\n+}\n+\n+/* Release a view read by backtrace_get_view.  */\n+\n+void\n+backtrace_release_view (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t\tstruct backtrace_view *view,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  union {\n+    const void *cv;\n+    void *v;\n+  } const_cast;\n+\n+  const_cast.cv = view->base;\n+  if (munmap (const_cast.v, view->len) < 0)\n+    error_callback (data, \"munmap\", errno);\n+}"
    },
    {
      "sha": "7e0189a289993b6635815be19e0dd7f76d91ddc9",
      "filename": "libbacktrace/mtest.c",
      "status": "added",
      "additions": 410,
      "deletions": 0,
      "changes": 410,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/mtest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/mtest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/mtest.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,410 @@\n+/* mtest.c -- Minidebug test for libbacktrace library\n+   Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* This program tests using libbacktrace with a program that uses the\n+   minidebuginfo format in a .gnu_debugdata section.  See\n+   https://sourceware.org/gdb/current/onlinedocs/gdb/MiniDebugInfo.html\n+   for a bit more information about minidebuginfo.  What is relevant\n+   for libbacktrace is that we have just a symbol table, with no debug\n+   info, so we should be able to do a function backtrace, but we can't\n+   do a file/line backtrace.  */\n+\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"testlib.h\"\n+\n+static int test1 (void) __attribute__ ((noinline, noclone, unused));\n+static int f2 (int) __attribute__ ((noinline, noclone));\n+static int f3 (int, int) __attribute__ ((noinline, noclone));\n+\n+/* Collected PC values.  */\n+\n+static uintptr_t addrs[20];\n+\n+/* The backtrace callback function.  This is like callback_one in\n+   testlib.c, but it saves the PC also.  */\n+\n+static int\n+callback_mtest (void *vdata, uintptr_t pc, const char *filename, int lineno,\n+\t\tconst char *function)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+\n+  if (data->index >= sizeof addrs / sizeof addrs[0])\n+    {\n+      fprintf (stderr, \"callback_mtest: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  addrs[data->index] = pc;\n+\n+  return callback_one (vdata, pc, filename, lineno, function);\n+}\n+\n+/* Test the backtrace function with non-inlined functions.  (We don't\n+   test with inlined functions because they won't work with minidebug\n+   anyhow.)  */\n+\n+static int\n+test1 (void)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return f2 (__LINE__) + 1;\n+}\n+\n+static int\n+f2 (int f1line)\n+{\n+  return f3 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f3 (int f1line __attribute__ ((unused)), int f2line __attribute__ ((unused)))\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int i;\n+  size_t j;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  i = backtrace_full (state, 0, callback_mtest, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (data.index < 3)\n+    {\n+      fprintf (stderr,\n+\t       \"test1: not enough frames; got %zu, expected at least 3\\n\",\n+\t       data.index);\n+      data.failed = 1;\n+    }\n+\n+  /* When using minidebug we don't expect the function name here.  */\n+\n+  for (j = 0; j < 3 && j < data.index; j++)\n+    {\n+      if (all[j].function == NULL)\n+\t{\n+\t  struct symdata symdata;\n+\n+\t  symdata.name = NULL;\n+\t  symdata.val = 0;\n+\t  symdata.size = 0;\n+\t  symdata.failed = 0;\n+\n+\t  i = backtrace_syminfo (state, addrs[j], callback_three,\n+\t\t\t\t error_callback_three, &symdata);\n+\t  if (i == 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test1: [%zu], unexpected return value from \"\n+\t\t\t\"backtrace_syminfo %d\\n\"),\n+\t\t       j, i);\n+\t      data.failed = 1;\n+\t    }\n+\t  else if (symdata.name == NULL)\n+\t    {\n+\t      fprintf (stderr, \"test1: [%zu]: syminfo did not find name\\n\", j);\n+\t      data.failed = 1;\n+\t    }\n+\t  else\n+\t    all[j].function = strdup (symdata.name);\n+\t}\n+    }\n+\n+  if (data.index > 0)\n+    {\n+      if (all[0].function == NULL)\n+\t{\n+\t  fprintf (stderr, \"test1: [0]: missing function name\\n\");\n+\t  data.failed = 1;\n+\t}\n+      else if (strcmp (all[0].function, \"f3\") != 0)\n+\t{\n+\t  fprintf (stderr, \"test1: [0]: got %s expected %s\\n\",\n+\t\t   all[0].function, \"f3\");\n+\t  data.failed = 1;\n+\t}\n+    }\n+\n+  if (data.index > 1)\n+    {\n+      if (all[1].function == NULL)\n+\t{\n+\t  fprintf (stderr, \"test1: [1]: missing function name\\n\");\n+\t  data.failed = 1;\n+\t}\n+      else if (strcmp (all[1].function, \"f2\") != 0)\n+\t{\n+\t  fprintf (stderr, \"test1: [1]: got %s expected %s\\n\",\n+\t\t   all[0].function, \"f2\");\n+\t  data.failed = 1;\n+\t}\n+    }\n+\n+  if (data.index > 2)\n+    {\n+      if (all[2].function == NULL)\n+\t{\n+\t  fprintf (stderr, \"test1: [2]: missing function name\\n\");\n+\t  data.failed = 1;\n+\t}\n+      else if (strcmp (all[2].function, \"test1\") != 0)\n+\t{\n+\t  fprintf (stderr, \"test1: [2]: got %s expected %s\\n\",\n+\t\t   all[0].function, \"test1\");\n+\t  data.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_full noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+/* Test the backtrace_simple function with non-inlined functions.  */\n+\n+static int test3 (void) __attribute__ ((noinline, noclone, unused));\n+static int f22 (int) __attribute__ ((noinline, noclone));\n+static int f23 (int, int) __attribute__ ((noinline, noclone));\n+\n+static int\n+test3 (void)\n+{\n+  return f22 (__LINE__) + 1;\n+}\n+\n+static int\n+f22 (int f1line)\n+{\n+  return f23 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f23 (int f1line __attribute__ ((unused)), int f2line __attribute__ ((unused)))\n+{\n+  uintptr_t addrs[20];\n+  struct sdata data;\n+  int i;\n+\n+  data.addrs = &addrs[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  i = backtrace_simple (state, 0, callback_two, error_callback_two, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test3: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (!data.failed)\n+    {\n+      int j;\n+\n+      for (j = 0; j < 3; ++j)\n+\t{\n+\t  struct symdata symdata;\n+\n+\t  symdata.name = NULL;\n+\t  symdata.val = 0;\n+\t  symdata.size = 0;\n+\t  symdata.failed = 0;\n+\n+\t  i = backtrace_syminfo (state, addrs[j], callback_three,\n+\t\t\t\t error_callback_three, &symdata);\n+\t  if (i == 0)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       (\"test3: [%d]: unexpected return value \"\n+\t\t\t\"from backtrace_syminfo %d\\n\"),\n+\t\t       j, i);\n+\t      symdata.failed = 1;\n+\t    }\n+\n+\t  if (!symdata.failed)\n+\t    {\n+\t      const char *expected;\n+\n+\t      switch (j)\n+\t\t{\n+\t\tcase 0:\n+\t\t  expected = \"f23\";\n+\t\t  break;\n+\t\tcase 1:\n+\t\t  expected = \"f22\";\n+\t\t  break;\n+\t\tcase 2:\n+\t\t  expected = \"test3\";\n+\t\t  break;\n+\t\tdefault:\n+\t\t  assert (0);\n+\t\t}\n+\n+\t      if (symdata.name == NULL)\n+\t\t{\n+\t\t  fprintf (stderr, \"test3: [%d]: NULL syminfo name\\n\", j);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t      /* Use strncmp, not strcmp, because GCC might create a\n+\t\t clone.  */\n+\t      else if (strncmp (symdata.name, expected, strlen (expected))\n+\t\t       != 0)\n+\t\t{\n+\t\t  fprintf (stderr,\n+\t\t\t   (\"test3: [%d]: unexpected syminfo name \"\n+\t\t\t    \"got %s expected %s\\n\"),\n+\t\t\t   j, symdata.name, expected);\n+\t\t  symdata.failed = 1;\n+\t\t}\n+\t    }\n+\n+\t  if (symdata.failed)\n+\t    data.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_simple noinline\\n\", data.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (data.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+int test5 (void) __attribute__ ((unused));\n+\n+int global = 1;\n+\n+int\n+test5 (void)\n+{\n+  struct symdata symdata;\n+  int i;\n+  uintptr_t addr = (uintptr_t) &global;\n+\n+  if (sizeof (global) > 1)\n+    addr += 1;\n+\n+  symdata.name = NULL;\n+  symdata.val = 0;\n+  symdata.size = 0;\n+  symdata.failed = 0;\n+\n+  i = backtrace_syminfo (state, addr, callback_three,\n+\t\t\t error_callback_three, &symdata);\n+  if (i == 0)\n+    {\n+      fprintf (stderr,\n+\t       \"test5: unexpected return value from backtrace_syminfo %d\\n\",\n+\t       i);\n+      symdata.failed = 1;\n+    }\n+\n+  if (!symdata.failed)\n+    {\n+      if (symdata.name == NULL)\n+\t{\n+\t  fprintf (stderr, \"test5: NULL syminfo name\\n\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (!(strncmp (symdata.name, \"global\", 6) == 0\n+\t\t && (symdata.name[6] == '\\0'|| symdata.name[6] == '.')))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo name got %s expected %s\\n\",\n+\t\t   symdata.name, \"global\");\n+\t  symdata.failed = 1;\n+\t}\n+      else if (symdata.val != (uintptr_t) &global)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo value got %lx expected %lx\\n\",\n+\t\t   (unsigned long) symdata.val,\n+\t\t   (unsigned long) (uintptr_t) &global);\n+\t  symdata.failed = 1;\n+\t}\n+      else if (symdata.size != sizeof (global))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"test5: unexpected syminfo size got %lx expected %lx\\n\",\n+\t\t   (unsigned long) symdata.size,\n+\t\t   (unsigned long) sizeof (global));\n+\t  symdata.failed = 1;\n+\t}\n+    }\n+\n+  printf (\"%s: backtrace_syminfo variable\\n\",\n+\t  symdata.failed ? \"FAIL\" : \"PASS\");\n+\n+  if (symdata.failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+#if BACKTRACE_SUPPORTED\n+  test1 ();\n+  test3 ();\n+#if BACKTRACE_SUPPORTS_DATA\n+  test5 ();\n+#endif\n+#endif\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "0eea7139b69d53f1f7d4c5b39ef5da3eb36a65c1",
      "filename": "libbacktrace/nounwind.c",
      "status": "added",
      "additions": 66,
      "deletions": 0,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/nounwind.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/nounwind.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/nounwind.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,66 @@\n+/* backtrace.c -- Entry point for stack backtrace library.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+\n+#include \"internal.h\"\n+\n+/* This source file is compiled if the unwind library is not\n+   available.  */\n+\n+int\n+backtrace_full (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\tint skip ATTRIBUTE_UNUSED,\n+\t\tbacktrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data,\n+\t\t  \"no stack trace because unwind library not available\",\n+\t\t  0);\n+  return 0;\n+}\n+\n+int\n+backtrace_simple (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t  int skip ATTRIBUTE_UNUSED,\n+\t\t  backtrace_simple_callback callback ATTRIBUTE_UNUSED,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data,\n+\t\t  \"no stack trace because unwind library not available\",\n+\t\t  0);\n+  return 0;\n+}"
    },
    {
      "sha": "720251900b4aca2acfe49f04dd7fe4ba4d4daf9e",
      "filename": "libbacktrace/pecoff.c",
      "status": "added",
      "additions": 935,
      "deletions": 0,
      "changes": 935,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/pecoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/pecoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/pecoff.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,935 @@\n+/* pecoff.c -- Get debug data from a PE/COFFF file for backtraces.\n+   Copyright (C) 2015-2021 Free Software Foundation, Inc.\n+   Adapted from elf.c by Tristan Gingold, AdaCore.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Coff file header.  */\n+\n+typedef struct {\n+  uint16_t machine;\n+  uint16_t number_of_sections;\n+  uint32_t time_date_stamp;\n+  uint32_t pointer_to_symbol_table;\n+  uint32_t number_of_symbols;\n+  uint16_t size_of_optional_header;\n+  uint16_t characteristics;\n+} b_coff_file_header;\n+\n+/* Coff optional header.  */\n+\n+typedef struct {\n+  uint16_t magic;\n+  uint8_t  major_linker_version;\n+  uint8_t  minor_linker_version;\n+  uint32_t size_of_code;\n+  uint32_t size_of_initialized_data;\n+  uint32_t size_of_uninitialized_data;\n+  uint32_t address_of_entry_point;\n+  uint32_t base_of_code;\n+  union {\n+    struct {\n+      uint32_t base_of_data;\n+      uint32_t image_base;\n+    } pe;\n+    struct {\n+      uint64_t image_base;\n+    } pep;\n+  } u;\n+} b_coff_optional_header;\n+\n+/* Values of magic in optional header.  */\n+\n+#define PE_MAGIC 0x10b\t\t/* PE32 executable.  */\n+#define PEP_MAGIC 0x20b\t\t/* PE32+ executable (for 64bit targets).  */\n+\n+/* Coff section header.  */\n+\n+typedef struct {\n+  char name[8];\n+  uint32_t virtual_size;\n+  uint32_t virtual_address;\n+  uint32_t size_of_raw_data;\n+  uint32_t pointer_to_raw_data;\n+  uint32_t pointer_to_relocations;\n+  uint32_t pointer_to_line_numbers;\n+  uint16_t number_of_relocations;\n+  uint16_t number_of_line_numbers;\n+  uint32_t characteristics;\n+} b_coff_section_header;\n+\n+/* Coff symbol name.  */\n+\n+typedef union {\n+  char short_name[8];\n+  struct {\n+    unsigned char zeroes[4];\n+    unsigned char off[4];\n+  } long_name;\n+} b_coff_name;\n+\n+/* Coff symbol (external representation which is unaligned).  */\n+\n+typedef struct {\n+  b_coff_name name;\n+  unsigned char value[4];\n+  unsigned char section_number[2];\n+  unsigned char type[2];\n+  unsigned char storage_class;\n+  unsigned char number_of_aux_symbols;\n+} b_coff_external_symbol;\n+\n+/* Symbol types.  */\n+\n+#define N_TBSHFT 4\t\t\t/* Shift for the derived type.  */\n+#define IMAGE_SYM_DTYPE_FUNCTION 2\t/* Function derived type.  */\n+\n+/* Size of a coff symbol.  */\n+\n+#define SYM_SZ 18\n+\n+/* Coff symbol, internal representation (aligned).  */\n+\n+typedef struct {\n+  const char *name;\n+  uint32_t value;\n+  int16_t sec;\n+  uint16_t type;\n+  uint16_t sc;\n+} b_coff_internal_symbol;\n+\n+/* Names of sections, indexed by enum dwarf_section in internal.h.  */\n+\n+static const char * const debug_section_names[DEBUG_MAX] =\n+{\n+  \".debug_info\",\n+  \".debug_line\",\n+  \".debug_abbrev\",\n+  \".debug_ranges\",\n+  \".debug_str\",\n+  \".debug_addr\",\n+  \".debug_str_offsets\",\n+  \".debug_line_str\",\n+  \".debug_rnglists\"\n+};\n+\n+/* Information we gather for the sections we care about.  */\n+\n+struct debug_section_info\n+{\n+  /* Section file offset.  */\n+  off_t offset;\n+  /* Section size.  */\n+  size_t size;\n+};\n+\n+/* Information we keep for an coff symbol.  */\n+\n+struct coff_symbol\n+{\n+  /* The name of the symbol.  */\n+  const char *name;\n+  /* The address of the symbol.  */\n+  uintptr_t address;\n+};\n+\n+/* Information to pass to coff_syminfo.  */\n+\n+struct coff_syminfo_data\n+{\n+  /* Symbols for the next module.  */\n+  struct coff_syminfo_data *next;\n+  /* The COFF symbols, sorted by address.  */\n+  struct coff_symbol *symbols;\n+  /* The number of symbols.  */\n+  size_t count;\n+};\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n+\n+static int\n+coff_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t      uintptr_t pc ATTRIBUTE_UNUSED,\n+\t      backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t      backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in PE/COFF executable\", -1);\n+  return 0;\n+}\n+\n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+coff_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t     uintptr_t addr ATTRIBUTE_UNUSED,\n+\t     backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t     backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in PE/COFF executable\", -1);\n+}\n+\n+/* Read a potentially unaligned 4 byte word at P, using native endianness.  */\n+\n+static uint32_t\n+coff_read4 (const unsigned char *p)\n+{\n+  uint32_t res;\n+\n+  memcpy (&res, p, 4);\n+  return res;\n+}\n+\n+/* Read a potentially unaligned 2 byte word at P, using native endianness.\n+   All 2 byte word in symbols are always aligned, but for coherency all\n+   fields are declared as char arrays.  */\n+\n+static uint16_t\n+coff_read2 (const unsigned char *p)\n+{\n+  uint16_t res;\n+\n+  memcpy (&res, p, sizeof (res));\n+  return res;\n+}\n+\n+/* Return the length (without the trailing 0) of a COFF short name.  */\n+\n+static size_t\n+coff_short_name_len (const char *name)\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    if (name[i] == 0)\n+      return i;\n+  return 8;\n+}\n+\n+/* Return true iff COFF short name CNAME is the same as NAME (a NUL-terminated\n+   string).  */\n+\n+static int\n+coff_short_name_eq (const char *name, const char *cname)\n+{\n+  int i;\n+\n+  for (i = 0; i < 8; i++)\n+    {\n+      if (name[i] != cname[i])\n+\treturn 0;\n+      if (name[i] == 0)\n+\treturn 1;\n+    }\n+  return name[8] == 0;\n+}\n+\n+/* Return true iff NAME is the same as string at offset OFF.  */\n+\n+static int\n+coff_long_name_eq (const char *name, unsigned int off,\n+\t\t   struct backtrace_view *str_view)\n+{\n+  if (off >= str_view->len)\n+    return 0;\n+  return strcmp (name, (const char *)str_view->data + off) == 0;\n+}\n+\n+/* Compare struct coff_symbol for qsort.  */\n+\n+static int\n+coff_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct coff_symbol *e1 = (const struct coff_symbol *) v1;\n+  const struct coff_symbol *e2 = (const struct coff_symbol *) v2;\n+\n+  if (e1->address < e2->address)\n+    return -1;\n+  else if (e1->address > e2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Convert SYM to internal (and aligned) format ISYM, using string table\n+   from STRTAB and STRTAB_SIZE, and number of sections SECTS_NUM.\n+   Return -1 in case of error (invalid section number or string index).  */\n+\n+static int\n+coff_expand_symbol (b_coff_internal_symbol *isym,\n+\t\t    const b_coff_external_symbol *sym,\n+\t\t    uint16_t sects_num,\n+\t\t    const unsigned char *strtab, size_t strtab_size)\n+{\n+  isym->type = coff_read2 (sym->type);\n+  isym->sec = coff_read2 (sym->section_number);\n+  isym->sc = sym->storage_class;\n+\n+  if (isym->sec > 0 && (uint16_t) isym->sec > sects_num)\n+    return -1;\n+  if (sym->name.short_name[0] != 0)\n+    isym->name = sym->name.short_name;\n+  else\n+    {\n+      uint32_t off = coff_read4 (sym->name.long_name.off);\n+\n+      if (off >= strtab_size)\n+\treturn -1;\n+      isym->name = (const char *) strtab + off;\n+    }\n+  return 0;\n+}\n+\n+/* Return true iff SYM is a defined symbol for a function.  Data symbols\n+   aren't considered because they aren't easily identified (same type as\n+   section names, presence of symbols defined by the linker script).  */\n+\n+static int\n+coff_is_function_symbol (const b_coff_internal_symbol *isym)\n+{\n+  return (isym->type >> N_TBSHFT) == IMAGE_SYM_DTYPE_FUNCTION\n+    && isym->sec > 0;\n+}\n+\n+/* Initialize the symbol table info for coff_syminfo.  */\n+\n+static int\n+coff_initialize_syminfo (struct backtrace_state *state,\n+\t\t\t uintptr_t base_address, int is_64,\n+\t\t\t const b_coff_section_header *sects, size_t sects_num,\n+\t\t\t const b_coff_external_symbol *syms, size_t syms_size,\n+\t\t\t const unsigned char *strtab, size_t strtab_size,\n+\t\t\t backtrace_error_callback error_callback,\n+\t\t\t void *data, struct coff_syminfo_data *sdata)\n+{\n+  size_t syms_count;\n+  char *coff_symstr;\n+  size_t coff_symstr_len;\n+  size_t coff_symbol_count;\n+  size_t coff_symbol_size;\n+  struct coff_symbol *coff_symbols;\n+  struct coff_symbol *coff_sym;\n+  char *coff_str;\n+  size_t i;\n+\n+  syms_count = syms_size / SYM_SZ;\n+\n+  /* We only care about function symbols.  Count them.  Also count size of\n+     strings for in-symbol names.  */\n+  coff_symbol_count = 0;\n+  coff_symstr_len = 0;\n+  for (i = 0; i < syms_count; ++i)\n+    {\n+      const b_coff_external_symbol *asym = &syms[i];\n+      b_coff_internal_symbol isym;\n+\n+      if (coff_expand_symbol (&isym, asym, sects_num, strtab, strtab_size) < 0)\n+\t{\n+\t  error_callback (data, \"invalid section or offset in coff symbol\", 0);\n+\t  return 0;\n+\t}\n+      if (coff_is_function_symbol (&isym))\n+\t{\n+\t  ++coff_symbol_count;\n+\t  if (asym->name.short_name[0] != 0)\n+\t    coff_symstr_len += coff_short_name_len (asym->name.short_name) + 1;\n+\t}\n+\n+      i += asym->number_of_aux_symbols;\n+    }\n+\n+  coff_symbol_size = (coff_symbol_count + 1) * sizeof (struct coff_symbol);\n+  coff_symbols = ((struct coff_symbol *)\n+\t\t  backtrace_alloc (state, coff_symbol_size, error_callback,\n+\t\t\t\t   data));\n+  if (coff_symbols == NULL)\n+    return 0;\n+\n+  /* Allocate memory for symbols strings.  */\n+  if (coff_symstr_len > 0)\n+    {\n+      coff_symstr = ((char *)\n+\t\t     backtrace_alloc (state, coff_symstr_len, error_callback,\n+\t\t\t\t      data));\n+      if (coff_symstr == NULL)\n+\t{\n+\t  backtrace_free (state, coff_symbols, coff_symbol_size,\n+\t\t\t  error_callback, data);\n+\t  return 0;\n+\t}\n+    }\n+  else\n+    coff_symstr = NULL;\n+\n+  /* Copy symbols.  */\n+  coff_sym = coff_symbols;\n+  coff_str = coff_symstr;\n+  for (i = 0; i < syms_count; ++i)\n+    {\n+      const b_coff_external_symbol *asym = &syms[i];\n+      b_coff_internal_symbol isym;\n+\n+      if (coff_expand_symbol (&isym, asym, sects_num, strtab, strtab_size))\n+\t{\n+\t  /* Should not fail, as it was already tested in the previous\n+\t     loop.  */\n+\t  abort ();\n+\t}\n+      if (coff_is_function_symbol (&isym))\n+\t{\n+\t  const char *name;\n+\t  int16_t secnum;\n+\n+\t  if (asym->name.short_name[0] != 0)\n+\t    {\n+\t      size_t len = coff_short_name_len (isym.name);\n+\t      name = coff_str;\n+\t      memcpy (coff_str, isym.name, len);\n+\t      coff_str[len] = 0;\n+\t      coff_str += len + 1;\n+\t    }\n+\t  else\n+\t    name = isym.name;\n+\n+\t  if (!is_64)\n+\t    {\n+\t      /* Strip leading '_'.  */\n+\t      if (name[0] == '_')\n+\t\tname++;\n+\t    }\n+\n+\t  /* Symbol value is section relative, so we need to read the address\n+\t     of its section.  */\n+\t  secnum = coff_read2 (asym->section_number);\n+\n+\t  coff_sym->name = name;\n+\t  coff_sym->address = (coff_read4 (asym->value)\n+\t\t\t       + sects[secnum - 1].virtual_address\n+\t\t\t       + base_address);\n+\t  coff_sym++;\n+\t}\n+\n+      i += asym->number_of_aux_symbols;\n+    }\n+\n+  /* End of symbols marker.  */\n+  coff_sym->name = NULL;\n+  coff_sym->address = -1;\n+\n+  backtrace_qsort (coff_symbols, coff_symbol_count,\n+\t\t   sizeof (struct coff_symbol), coff_symbol_compare);\n+\n+  sdata->next = NULL;\n+  sdata->symbols = coff_symbols;\n+  sdata->count = coff_symbol_count;\n+\n+  return 1;\n+}\n+\n+/* Add EDATA to the list in STATE.  */\n+\n+static void\n+coff_add_syminfo_data (struct backtrace_state *state,\n+\t\t       struct coff_syminfo_data *sdata)\n+{\n+  if (!state->threaded)\n+    {\n+      struct coff_syminfo_data **pp;\n+\n+      for (pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = sdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct coff_syminfo_data **pp;\n+\n+\t  pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct coff_syminfo_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, sdata))\n+\t    break;\n+\t}\n+    }\n+}\n+\n+/* Compare an ADDR against an elf_symbol for bsearch.  We allocate one\n+   extra entry in the array so that this can look safely at the next\n+   entry.  */\n+\n+static int\n+coff_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct coff_symbol *entry = (const struct coff_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->address)\n+    return -1;\n+  else if (addr >= entry[1].address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Return the symbol name and value for an ADDR.  */\n+\n+static void\n+coff_syminfo (struct backtrace_state *state, uintptr_t addr,\n+\t      backtrace_syminfo_callback callback,\n+\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t      void *data)\n+{\n+  struct coff_syminfo_data *sdata;\n+  struct coff_symbol *sym = NULL;\n+\n+  if (!state->threaded)\n+    {\n+      for (sdata = (struct coff_syminfo_data *) state->syminfo_data;\n+\t   sdata != NULL;\n+\t   sdata = sdata->next)\n+\t{\n+\t  sym = ((struct coff_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct coff_symbol), coff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      struct coff_syminfo_data **pp;\n+\n+      pp = (struct coff_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+\t{\n+\t  sdata = backtrace_atomic_load_pointer (pp);\n+\t  if (sdata == NULL)\n+\t    break;\n+\n+\t  sym = ((struct coff_symbol *)\n+\t\t bsearch (&addr, sdata->symbols, sdata->count,\n+\t\t\t  sizeof (struct coff_symbol), coff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\n+\t  pp = &sdata->next;\n+\t}\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    callback (data, addr, sym->name, sym->address, 0);\n+}\n+\n+/* Add the backtrace data for one PE/COFF file.  Returns 1 on success,\n+   0 on failure (in both cases descriptor is closed).  */\n+\n+static int\n+coff_add (struct backtrace_state *state, int descriptor,\n+\t  backtrace_error_callback error_callback, void *data,\n+\t  fileline *fileline_fn, int *found_sym, int *found_dwarf)\n+{\n+  struct backtrace_view fhdr_view;\n+  off_t fhdr_off;\n+  int magic_ok;\n+  b_coff_file_header fhdr;\n+  off_t opt_sects_off;\n+  size_t opt_sects_size;\n+  unsigned int sects_num;\n+  struct backtrace_view sects_view;\n+  int sects_view_valid;\n+  const b_coff_optional_header *opt_hdr;\n+  const b_coff_section_header *sects;\n+  struct backtrace_view str_view;\n+  int str_view_valid;\n+  size_t str_size;\n+  off_t str_off;\n+  struct backtrace_view syms_view;\n+  off_t syms_off;\n+  size_t syms_size;\n+  int syms_view_valid;\n+  unsigned int syms_num;\n+  unsigned int i;\n+  struct debug_section_info sections[DEBUG_MAX];\n+  off_t min_offset;\n+  off_t max_offset;\n+  struct backtrace_view debug_view;\n+  int debug_view_valid;\n+  int is_64;\n+  uintptr_t image_base;\n+  struct dwarf_sections dwarf_sections;\n+\n+  *found_sym = 0;\n+  *found_dwarf = 0;\n+\n+  sects_view_valid = 0;\n+  syms_view_valid = 0;\n+  str_view_valid = 0;\n+  debug_view_valid = 0;\n+\n+  /* Map the MS-DOS stub (if any) and extract file header offset.  */\n+  if (!backtrace_get_view (state, descriptor, 0, 0x40, error_callback,\n+\t\t\t   data, &fhdr_view))\n+    goto fail;\n+\n+  {\n+    const unsigned char *vptr = fhdr_view.data;\n+\n+    if (vptr[0] == 'M' && vptr[1] == 'Z')\n+      fhdr_off = coff_read4 (vptr + 0x3c);\n+    else\n+      fhdr_off = 0;\n+  }\n+\n+  backtrace_release_view (state, &fhdr_view, error_callback, data);\n+\n+  /* Map the coff file header.  */\n+  if (!backtrace_get_view (state, descriptor, fhdr_off,\n+\t\t\t   sizeof (b_coff_file_header) + 4,\n+\t\t\t   error_callback, data, &fhdr_view))\n+    goto fail;\n+\n+  if (fhdr_off != 0)\n+    {\n+      const char *magic = (const char *) fhdr_view.data;\n+      magic_ok = memcmp (magic, \"PE\\0\", 4) == 0;\n+      fhdr_off += 4;\n+\n+      memcpy (&fhdr, fhdr_view.data + 4, sizeof fhdr);\n+    }\n+  else\n+    {\n+      memcpy (&fhdr, fhdr_view.data, sizeof fhdr);\n+      /* TODO: test fhdr.machine for coff but non-PE platforms.  */\n+      magic_ok = 0;\n+    }\n+  backtrace_release_view (state, &fhdr_view, error_callback, data);\n+\n+  if (!magic_ok)\n+    {\n+      error_callback (data, \"executable file is not COFF\", 0);\n+      goto fail;\n+    }\n+\n+  sects_num = fhdr.number_of_sections;\n+  syms_num = fhdr.number_of_symbols;\n+\n+  opt_sects_off = fhdr_off + sizeof (fhdr);\n+  opt_sects_size = (fhdr.size_of_optional_header\n+\t\t    + sects_num * sizeof (b_coff_section_header));\n+\n+  /* To translate PC to file/line when using DWARF, we need to find\n+     the .debug_info and .debug_line sections.  */\n+\n+  /* Read the optional header and the section headers.  */\n+\n+  if (!backtrace_get_view (state, descriptor, opt_sects_off, opt_sects_size,\n+\t\t\t   error_callback, data, &sects_view))\n+    goto fail;\n+  sects_view_valid = 1;\n+  opt_hdr = (const b_coff_optional_header *) sects_view.data;\n+  sects = (const b_coff_section_header *)\n+    (sects_view.data + fhdr.size_of_optional_header);\n+\n+  is_64 = 0;\n+  if (fhdr.size_of_optional_header > sizeof (*opt_hdr))\n+    {\n+      if (opt_hdr->magic == PE_MAGIC)\n+\timage_base = opt_hdr->u.pe.image_base;\n+      else if (opt_hdr->magic == PEP_MAGIC)\n+\t{\n+\t  image_base = opt_hdr->u.pep.image_base;\n+\t  is_64 = 1;\n+\t}\n+      else\n+\t{\n+\t  error_callback (data, \"bad magic in PE optional header\", 0);\n+\t  goto fail;\n+\t}\n+    }\n+  else\n+    image_base = 0;\n+\n+  /* Read the symbol table and the string table.  */\n+\n+  if (fhdr.pointer_to_symbol_table == 0)\n+    {\n+      /* No symbol table, no string table.  */\n+      str_off = 0;\n+      str_size = 0;\n+      syms_num = 0;\n+      syms_size = 0;\n+    }\n+  else\n+    {\n+      /* Symbol table is followed by the string table.  The string table\n+\t starts with its length (on 4 bytes).\n+\t Map the symbol table and the length of the string table.  */\n+      syms_off = fhdr.pointer_to_symbol_table;\n+      syms_size = syms_num * SYM_SZ;\n+\n+      if (!backtrace_get_view (state, descriptor, syms_off, syms_size + 4,\n+\t\t\t       error_callback, data, &syms_view))\n+\tgoto fail;\n+      syms_view_valid = 1;\n+\n+      str_size = coff_read4 (syms_view.data + syms_size);\n+\n+      str_off = syms_off + syms_size;\n+\n+      if (str_size > 4)\n+\t{\n+\t  /* Map string table (including the length word).  */\n+\n+\t  if (!backtrace_get_view (state, descriptor, str_off, str_size,\n+\t\t\t\t   error_callback, data, &str_view))\n+\t    goto fail;\n+\t  str_view_valid = 1;\n+\t}\n+    }\n+\n+  memset (sections, 0, sizeof sections);\n+\n+  /* Look for the symbol table.  */\n+  for (i = 0; i < sects_num; ++i)\n+    {\n+      const b_coff_section_header *s = sects + i;\n+      unsigned int str_off;\n+      int j;\n+\n+      if (s->name[0] == '/')\n+\t{\n+\t  /* Extended section name.  */\n+\t  str_off = atoi (s->name + 1);\n+\t}\n+      else\n+\tstr_off = 0;\n+\n+      for (j = 0; j < (int) DEBUG_MAX; ++j)\n+\t{\n+\t  const char *dbg_name = debug_section_names[j];\n+\t  int match;\n+\n+\t  if (str_off != 0)\n+\t    match = coff_long_name_eq (dbg_name, str_off, &str_view);\n+\t  else\n+\t    match = coff_short_name_eq (dbg_name, s->name);\n+\t  if (match)\n+\t    {\n+\t      sections[j].offset = s->pointer_to_raw_data;\n+\t      sections[j].size = s->virtual_size <= s->size_of_raw_data ?\n+\t\ts->virtual_size : s->size_of_raw_data;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (syms_num != 0)\n+    {\n+      struct coff_syminfo_data *sdata;\n+\n+      sdata = ((struct coff_syminfo_data *)\n+\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+      if (sdata == NULL)\n+\tgoto fail;\n+\n+      if (!coff_initialize_syminfo (state, image_base, is_64,\n+\t\t\t\t    sects, sects_num,\n+\t\t\t\t    syms_view.data, syms_size,\n+\t\t\t\t    str_view.data, str_size,\n+\t\t\t\t    error_callback, data, sdata))\n+\t{\n+\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n+\t  goto fail;\n+\t}\n+\n+      *found_sym = 1;\n+\n+      coff_add_syminfo_data (state, sdata);\n+    }\n+\n+  backtrace_release_view (state, &sects_view, error_callback, data);\n+  sects_view_valid = 0;\n+  if (syms_view_valid)\n+    {\n+      backtrace_release_view (state, &syms_view, error_callback, data);\n+      syms_view_valid = 0;\n+    }\n+\n+  /* Read all the debug sections in a single view, since they are\n+     probably adjacent in the file.  We never release this view.  */\n+\n+  min_offset = 0;\n+  max_offset = 0;\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      off_t end;\n+\n+      if (sections[i].size == 0)\n+\tcontinue;\n+      if (min_offset == 0 || sections[i].offset < min_offset)\n+\tmin_offset = sections[i].offset;\n+      end = sections[i].offset + sections[i].size;\n+      if (end > max_offset)\n+\tmax_offset = end;\n+    }\n+  if (min_offset == 0 || max_offset == 0)\n+    {\n+      if (!backtrace_close (descriptor, error_callback, data))\n+\tgoto fail;\n+      *fileline_fn = coff_nodebug;\n+      return 1;\n+    }\n+\n+  if (!backtrace_get_view (state, descriptor, min_offset,\n+\t\t\t   max_offset - min_offset,\n+\t\t\t   error_callback, data, &debug_view))\n+    goto fail;\n+  debug_view_valid = 1;\n+\n+  /* We've read all we need from the executable.  */\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  for (i = 0; i < (int) DEBUG_MAX; ++i)\n+    {\n+      size_t size = sections[i].size;\n+      dwarf_sections.size[i] = size;\n+      if (size == 0)\n+\tdwarf_sections.data[i] = NULL;\n+      else\n+\tdwarf_sections.data[i] = ((const unsigned char *) debug_view.data\n+\t\t\t\t  + (sections[i].offset - min_offset));\n+    }\n+\n+  if (!backtrace_dwarf_add (state, /* base_address */ 0, &dwarf_sections,\n+\t\t\t    0, /* FIXME: is_bigendian */\n+\t\t\t    NULL, /* altlink */\n+\t\t\t    error_callback, data, fileline_fn,\n+\t\t\t    NULL /* returned fileline_entry */))\n+    goto fail;\n+\n+  *found_dwarf = 1;\n+\n+  return 1;\n+\n+ fail:\n+  if (sects_view_valid)\n+    backtrace_release_view (state, &sects_view, error_callback, data);\n+  if (str_view_valid)\n+    backtrace_release_view (state, &str_view, error_callback, data);\n+  if (syms_view_valid)\n+    backtrace_release_view (state, &syms_view, error_callback, data);\n+  if (debug_view_valid)\n+    backtrace_release_view (state, &debug_view, error_callback, data);\n+  if (descriptor != -1)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+/* Initialize the backtrace data we need from an ELF executable.  At\n+   the ELF level, all we need to do is find the debug info\n+   sections.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state,\n+\t\t      const char *filename ATTRIBUTE_UNUSED, int descriptor,\n+\t\t      backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  int ret;\n+  int found_sym;\n+  int found_dwarf;\n+  fileline coff_fileline_fn;\n+\n+  ret = coff_add (state, descriptor, error_callback, data,\n+\t\t  &coff_fileline_fn, &found_sym, &found_dwarf);\n+  if (!ret)\n+    return 0;\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = coff_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = coff_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, coff_syminfo);\n+      else\n+\t(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n+\t\t\t\t\t     coff_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == coff_nodebug)\n+\t*fileline_fn = coff_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+      if (current_fn == NULL || current_fn == coff_nodebug)\n+\t*fileline_fn = coff_fileline_fn;\n+    }\n+\n+  return 1;\n+}"
    },
    {
      "sha": "924631d2e61d5c39329e8e2fc76979bb07808af5",
      "filename": "libbacktrace/posix.c",
      "status": "added",
      "additions": 104,
      "deletions": 0,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/posix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/posix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/posix.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,104 @@\n+/* posix.c -- POSIX file I/O routines for the backtrace library.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+#ifndef O_BINARY\n+#define O_BINARY 0\n+#endif\n+\n+#ifndef O_CLOEXEC\n+#define O_CLOEXEC 0\n+#endif\n+\n+#ifndef FD_CLOEXEC\n+#define FD_CLOEXEC 1\n+#endif\n+\n+/* Open a file for reading.  */\n+\n+int\n+backtrace_open (const char *filename, backtrace_error_callback error_callback,\n+\t\tvoid *data, int *does_not_exist)\n+{\n+  int descriptor;\n+\n+  if (does_not_exist != NULL)\n+    *does_not_exist = 0;\n+\n+  descriptor = open (filename, (int) (O_RDONLY | O_BINARY | O_CLOEXEC));\n+  if (descriptor < 0)\n+    {\n+      /* If DOES_NOT_EXIST is not NULL, then don't call ERROR_CALLBACK\n+\t if the file does not exist.  We treat lacking permission to\n+\t open the file as the file not existing; this case arises when\n+\t running the libgo syscall package tests as root.  */\n+      if (does_not_exist != NULL && (errno == ENOENT || errno == EACCES))\n+\t*does_not_exist = 1;\n+      else\n+\terror_callback (data, filename, errno);\n+      return -1;\n+    }\n+\n+#ifdef HAVE_FCNTL\n+  /* Set FD_CLOEXEC just in case the kernel does not support\n+     O_CLOEXEC. It doesn't matter if this fails for some reason.\n+     FIXME: At some point it should be safe to only do this if\n+     O_CLOEXEC == 0.  */\n+  fcntl (descriptor, F_SETFD, FD_CLOEXEC);\n+#endif\n+\n+  return descriptor;\n+}\n+\n+/* Close DESCRIPTOR.  */\n+\n+int\n+backtrace_close (int descriptor, backtrace_error_callback error_callback,\n+\t\t void *data)\n+{\n+  if (close (descriptor) < 0)\n+    {\n+      error_callback (data, \"close\", errno);\n+      return 0;\n+    }\n+  return 1;\n+}"
    },
    {
      "sha": "93d0d3abb4937bc575a0816a9b9641e4e04b9424",
      "filename": "libbacktrace/print.c",
      "status": "added",
      "additions": 92,
      "deletions": 0,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/print.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/print.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/print.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,92 @@\n+/* print.c -- Print the current backtrace.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Passed to callbacks.  */\n+\n+struct print_data\n+{\n+  struct backtrace_state *state;\n+  FILE *f;\n+};\n+\n+/* Print one level of a backtrace.  */\n+\n+static int\n+print_callback (void *data, uintptr_t pc, const char *filename, int lineno,\n+\t\tconst char *function)\n+{\n+  struct print_data *pdata = (struct print_data *) data;\n+\n+  fprintf (pdata->f, \"0x%lx %s\\n\\t%s:%d\\n\",\n+\t   (unsigned long) pc,\n+\t   function == NULL ? \"???\" : function,\n+\t   filename == NULL ? \"???\" : filename,\n+\t   lineno);\n+  return 0;\n+}\n+\n+/* Print errors to stderr.  */\n+\n+static void\n+error_callback (void *data, const char *msg, int errnum)\n+{\n+  struct print_data *pdata = (struct print_data *) data;\n+\n+  if (pdata->state->filename != NULL)\n+    fprintf (stderr, \"%s: \", pdata->state->filename);\n+  fprintf (stderr, \"libbacktrace: %s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fputc ('\\n', stderr);\n+}\n+\n+/* Print a backtrace.  */\n+\n+void __attribute__((noinline))\n+backtrace_print (struct backtrace_state *state, int skip, FILE *f)\n+{\n+  struct print_data data;\n+\n+  data.state = state;\n+  data.f = f;\n+  backtrace_full (state, skip + 1, print_callback, error_callback,\n+\t\t  (void *) &data);\n+}"
    },
    {
      "sha": "1811c8d2e08636e5a8b6ba4908488705f3faac7d",
      "filename": "libbacktrace/read.c",
      "status": "added",
      "additions": 110,
      "deletions": 0,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/read.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,110 @@\n+/* read.c -- File views without mmap.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* This file implements file views when mmap is not available.  */\n+\n+/* Create a view of SIZE bytes from DESCRIPTOR at OFFSET.  */\n+\n+int\n+backtrace_get_view (struct backtrace_state *state, int descriptor,\n+\t\t    off_t offset, uint64_t size,\n+\t\t    backtrace_error_callback error_callback,\n+\t\t    void *data, struct backtrace_view *view)\n+{\n+  uint64_t got;\n+  ssize_t r;\n+\n+  if ((uint64_t) (size_t) size != size)\n+    {\n+      error_callback (data, \"file size too large\", 0);\n+      return 0;\n+    }\n+\n+  if (lseek (descriptor, offset, SEEK_SET) < 0)\n+    {\n+      error_callback (data, \"lseek\", errno);\n+      return 0;\n+    }\n+\n+  view->base = backtrace_alloc (state, size, error_callback, data);\n+  if (view->base == NULL)\n+    return 0;\n+  view->data = view->base;\n+  view->len = size;\n+\n+  got = 0;\n+  while (got < size)\n+    {\n+      r = read (descriptor, view->base, size - got);\n+      if (r < 0)\n+\t{\n+\t  error_callback (data, \"read\", errno);\n+\t  free (view->base);\n+\t  return 0;\n+\t}\n+      if (r == 0)\n+\tbreak;\n+      got += (uint64_t) r;\n+    }\n+\n+  if (got < size)\n+    {\n+      error_callback (data, \"file too short\", 0);\n+      free (view->base);\n+      return 0;\n+    }\n+\n+  return 1;\n+}\n+\n+/* Release a view read by backtrace_get_view.  */\n+\n+void\n+backtrace_release_view (struct backtrace_state *state,\n+\t\t\tstruct backtrace_view *view,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  backtrace_free (state, view->base, view->len, error_callback, data);\n+  view->data = NULL;\n+  view->base = NULL;\n+}"
    },
    {
      "sha": "785e726e6be39f439544fd3f493a66f9b75fc599",
      "filename": "libbacktrace/simple.c",
      "status": "added",
      "additions": 108,
      "deletions": 0,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/simple.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/simple.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/simple.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,108 @@\n+/* simple.c -- The backtrace_simple function.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include \"unwind.h\"\n+#include \"backtrace.h\"\n+\n+/* The simple_backtrace routine.  */\n+\n+/* Data passed through _Unwind_Backtrace.  */\n+\n+struct backtrace_simple_data\n+{\n+  /* Number of frames to skip.  */\n+  int skip;\n+  /* Library state.  */\n+  struct backtrace_state *state;\n+  /* Callback routine.  */\n+  backtrace_simple_callback callback;\n+  /* Error callback routine.  */\n+  backtrace_error_callback error_callback;\n+  /* Data to pass to callback routine.  */\n+  void *data;\n+  /* Value to return from backtrace.  */\n+  int ret;\n+};\n+\n+/* Unwind library callback routine.  This is passed to\n+   _Unwind_Backtrace.  */\n+\n+static _Unwind_Reason_Code\n+simple_unwind (struct _Unwind_Context *context, void *vdata)\n+{\n+  struct backtrace_simple_data *bdata = (struct backtrace_simple_data *) vdata;\n+  uintptr_t pc;\n+  int ip_before_insn = 0;\n+\n+#ifdef HAVE_GETIPINFO\n+  pc = _Unwind_GetIPInfo (context, &ip_before_insn);\n+#else\n+  pc = _Unwind_GetIP (context);\n+#endif\n+\n+  if (bdata->skip > 0)\n+    {\n+      --bdata->skip;\n+      return _URC_NO_REASON;\n+    }\n+\n+  if (!ip_before_insn)\n+    --pc;\n+\n+  bdata->ret = bdata->callback (bdata->data, pc);\n+\n+  if (bdata->ret != 0)\n+    return _URC_END_OF_STACK;\n+\n+  return _URC_NO_REASON;\n+}\n+\n+/* Get a simple stack backtrace.  */\n+\n+int __attribute__((noinline))\n+backtrace_simple (struct backtrace_state *state, int skip,\n+\t\t  backtrace_simple_callback callback,\n+\t\t  backtrace_error_callback error_callback, void *data)\n+{\n+  struct backtrace_simple_data bdata;\n+\n+  bdata.skip = skip + 1;\n+  bdata.state = state;\n+  bdata.callback = callback;\n+  bdata.error_callback = error_callback;\n+  bdata.data = data;\n+  bdata.ret = 0;\n+  _Unwind_Backtrace (simple_unwind, &bdata);\n+  return bdata.ret;\n+}"
    },
    {
      "sha": "a60a980e65ed6caa5c05082f7fc807c3743c663d",
      "filename": "libbacktrace/sort.c",
      "status": "added",
      "additions": 108,
      "deletions": 0,
      "changes": 108,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/sort.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/sort.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/sort.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,108 @@\n+/* sort.c -- Sort without allocating memory\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stddef.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* The GNU glibc version of qsort allocates memory, which we must not\n+   do if we are invoked by a signal handler.  So provide our own\n+   sort.  */\n+\n+static void\n+swap (char *a, char *b, size_t size)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < size; i++, a++, b++)\n+    {\n+      char t;\n+\n+      t = *a;\n+      *a = *b;\n+      *b = t;\n+    }\n+}\n+\n+void\n+backtrace_qsort (void *basearg, size_t count, size_t size,\n+\t\t int (*compar) (const void *, const void *))\n+{\n+  char *base = (char *) basearg;\n+  size_t i;\n+  size_t mid;\n+\n+ tail_recurse:\n+  if (count < 2)\n+    return;\n+\n+  /* The symbol table and DWARF tables, which is all we use this\n+     routine for, tend to be roughly sorted.  Pick the middle element\n+     in the array as our pivot point, so that we are more likely to\n+     cut the array in half for each recursion step.  */\n+  swap (base, base + (count / 2) * size, size);\n+\n+  mid = 0;\n+  for (i = 1; i < count; i++)\n+    {\n+      if ((*compar) (base, base + i * size) > 0)\n+\t{\n+\t  ++mid;\n+\t  if (i != mid)\n+\t    swap (base + mid * size, base + i * size, size);\n+\t}\n+    }\n+\n+  if (mid > 0)\n+    swap (base, base + mid * size, size);\n+\n+  /* Recurse with the smaller array, loop with the larger one.  That\n+     ensures that our maximum stack depth is log count.  */\n+  if (2 * mid < count)\n+    {\n+      backtrace_qsort (base, mid, size, compar);\n+      base += (mid + 1) * size;\n+      count -= mid + 1;\n+      goto tail_recurse;\n+    }\n+  else\n+    {\n+      backtrace_qsort (base + (mid + 1) * size, count - (mid + 1),\n+\t\t       size, compar);\n+      count = mid;\n+      goto tail_recurse;\n+    }\n+}"
    },
    {
      "sha": "0f368a23907429a5e62a3e58b977aac33a919f8b",
      "filename": "libbacktrace/state.c",
      "status": "added",
      "additions": 72,
      "deletions": 0,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/state.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/state.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/state.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,72 @@\n+/* state.c -- Create the backtrace state.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+#include \"internal.h\"\n+\n+/* Create the backtrace state.  This will then be passed to all the\n+   other routines.  */\n+\n+struct backtrace_state *\n+backtrace_create_state (const char *filename, int threaded,\n+\t\t\tbacktrace_error_callback error_callback,\n+\t\t\tvoid *data)\n+{\n+  struct backtrace_state init_state;\n+  struct backtrace_state *state;\n+\n+#ifndef HAVE_SYNC_FUNCTIONS\n+  if (threaded)\n+    {\n+      error_callback (data, \"backtrace library does not support threads\", 0);\n+      return NULL;\n+    }\n+#endif\n+\n+  memset (&init_state, 0, sizeof init_state);\n+  init_state.filename = filename;\n+  init_state.threaded = threaded;\n+\n+  state = ((struct backtrace_state *)\n+\t   backtrace_alloc (&init_state, sizeof *state, error_callback, data));\n+  if (state == NULL)\n+    return NULL;\n+  *state = init_state;\n+\n+  return state;\n+}"
    },
    {
      "sha": "19a204de1953f4cf608e74987ab2a6c18ee5ff71",
      "filename": "libbacktrace/stest.c",
      "status": "added",
      "additions": 137,
      "deletions": 0,
      "changes": 137,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/stest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/stest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/stest.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,137 @@\n+/* stest.c -- Test for libbacktrace internal sort function\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* Test the local qsort implementation.  */\n+\n+#define MAX 10\n+\n+struct test\n+{\n+  size_t count;\n+  int input[MAX];\n+  int output[MAX];\n+};\n+\n+static struct test tests[] =\n+  {\n+    {\n+      10,\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }\n+    },\n+    {\n+      9,\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9 }\n+    },\n+    {\n+      10,\n+      { 10, 9, 8, 7, 6, 5, 4, 3, 2, 1 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n+    },\n+    {\n+      9,\n+      { 9, 8, 7, 6, 5, 4, 3, 2, 1 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9 },\n+    },\n+    {\n+      10,\n+      { 2, 4, 6, 8, 10, 1, 3, 5, 7, 9 },\n+      { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 },\n+    },\n+    {\n+      5,\n+      { 4, 5, 3, 1, 2 },\n+      { 1, 2, 3, 4, 5 },\n+    },\n+    {\n+      5,\n+      { 1, 1, 1, 1, 1 },\n+      { 1, 1, 1, 1, 1 },\n+    },\n+    {\n+      5,\n+      { 1, 1, 2, 1, 1 },\n+      { 1, 1, 1, 1, 2 },\n+    },\n+    {\n+      5,\n+      { 2, 1, 1, 1, 1 },\n+      { 1, 1, 1, 1, 2 },\n+    },\n+  };\n+\n+static int\n+compare (const void *a, const void *b)\n+{\n+  const int *ai = (const int *) a;\n+  const int *bi = (const int *) b;\n+\n+  return *ai - *bi;\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)\n+{\n+  int failures;\n+  size_t i;\n+  int a[MAX];\n+\n+  failures = 0;\n+  for (i = 0; i < sizeof tests / sizeof tests[0]; i++)\n+    {\n+      memcpy (a, tests[i].input, tests[i].count * sizeof (int));\n+      backtrace_qsort (a, tests[i].count, sizeof (int), compare);\n+      if (memcmp (a, tests[i].output, tests[i].count * sizeof (int)) != 0)\n+\t{\n+\t  size_t j;\n+\n+\t  fprintf (stderr, \"test %d failed:\", (int) i);\n+\t  for (j = 0; j < tests[i].count; j++)\n+\t    fprintf (stderr, \" %d\", a[j]);\n+\t  fprintf (stderr, \"\\n\");\n+\t  ++failures;\n+\t}\n+    }\n+\n+  exit (failures > 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "9deb6f5b2a7c102e239115009a1b3494efb61d50",
      "filename": "libbacktrace/test_format.c",
      "status": "added",
      "additions": 55,
      "deletions": 0,
      "changes": 55,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/test_format.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/test_format.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/test_format.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,55 @@\n+/* test_format.c -- Test for libbacktrace library\n+   Copyright (C) 2018-2021 Free Software Foundation, Inc.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* This program tests the externally visible interfaces of the\n+   libbacktrace library.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"testlib.h\"\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "3d24c19e702809bb94da1e3ae71edbca78fdb94d",
      "filename": "libbacktrace/testlib.c",
      "status": "added",
      "additions": 234,
      "deletions": 0,
      "changes": 234,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/testlib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/testlib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/testlib.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,234 @@\n+/* testlib.c -- test functions for libbacktrace library\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+\n+#include \"testlib.h\"\n+\n+/* The backtrace state.  */\n+\n+void *state;\n+\n+/* The number of failures.  */\n+\n+int failures;\n+\n+/* Return the base name in a path.  */\n+\n+const char *\n+base (const char *p)\n+{\n+  const char *last;\n+  const char *s;\n+\n+  last = NULL;\n+  for (s = p; *s != '\\0'; ++s)\n+    {\n+      if (IS_DIR_SEPARATOR (*s))\n+\tlast = s + 1;\n+    }\n+  return last != NULL ? last : p;\n+}\n+\n+/* Check an entry in a struct info array.  */\n+\n+void\n+check (const char *name, int index, const struct info *all, int want_lineno,\n+       const char *want_function, const char *want_file, int *failed)\n+{\n+  if (*failed)\n+    return;\n+  if (all[index].filename == NULL || all[index].function == NULL)\n+    {\n+      fprintf (stderr, \"%s: [%d]: missing file name or function name\\n\",\n+\t       name, index);\n+      *failed = 1;\n+      return;\n+    }\n+  if (strcmp (base (all[index].filename), want_file) != 0)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n+\t       all[index].filename, want_file);\n+      *failed = 1;\n+    }\n+  if (all[index].lineno != want_lineno)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %d expected %d\\n\", name, index,\n+\t       all[index].lineno, want_lineno);\n+      *failed = 1;\n+    }\n+  if (strcmp (all[index].function, want_function) != 0)\n+    {\n+      fprintf (stderr, \"%s: [%d]: got %s expected %s\\n\", name, index,\n+\t       all[index].function, want_function);\n+      *failed = 1;\n+    }\n+}\n+\n+/* The backtrace callback function.  */\n+\n+int\n+callback_one (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t      const char *filename, int lineno, const char *function)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+  struct info *p;\n+\n+  if (data->index >= data->max)\n+    {\n+      fprintf (stderr, \"callback_one: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  p = &data->all[data->index];\n+  if (filename == NULL)\n+    p->filename = NULL;\n+  else\n+    {\n+      p->filename = strdup (filename);\n+      assert (p->filename != NULL);\n+    }\n+  p->lineno = lineno;\n+  if (function == NULL)\n+    p->function = NULL;\n+  else\n+    {\n+      p->function = strdup (function);\n+      assert (p->function != NULL);\n+    }\n+  ++data->index;\n+\n+  return 0;\n+}\n+\n+/* An error callback passed to backtrace.  */\n+\n+void\n+error_callback_one (void *vdata, const char *msg, int errnum)\n+{\n+  struct bdata *data = (struct bdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_simple callback function.  */\n+\n+int\n+callback_two (void *vdata, uintptr_t pc)\n+{\n+  struct sdata *data = (struct sdata *) vdata;\n+\n+  if (data->index >= data->max)\n+    {\n+      fprintf (stderr, \"callback_two: callback called too many times\\n\");\n+      data->failed = 1;\n+      return 1;\n+    }\n+\n+  data->addrs[data->index] = pc;\n+  ++data->index;\n+\n+  return 0;\n+}\n+\n+/* An error callback passed to backtrace_simple.  */\n+\n+void\n+error_callback_two (void *vdata, const char *msg, int errnum)\n+{\n+  struct sdata *data = (struct sdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_syminfo callback function.  */\n+\n+void\n+callback_three (void *vdata, uintptr_t pc ATTRIBUTE_UNUSED,\n+\t\tconst char *symname, uintptr_t symval,\n+\t\tuintptr_t symsize)\n+{\n+  struct symdata *data = (struct symdata *) vdata;\n+\n+  if (symname == NULL)\n+    data->name = NULL;\n+  else\n+    {\n+      data->name = strdup (symname);\n+      assert (data->name != NULL);\n+    }\n+  data->val = symval;\n+  data->size = symsize;\n+}\n+\n+/* The backtrace_syminfo error callback function.  */\n+\n+void\n+error_callback_three (void *vdata, const char *msg, int errnum)\n+{\n+  struct symdata *data = (struct symdata *) vdata;\n+\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  data->failed = 1;\n+}\n+\n+/* The backtrace_create_state error callback function.  */\n+\n+void\n+error_callback_create (void *data ATTRIBUTE_UNUSED, const char *msg,\n+                       int errnum)\n+{\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}"
    },
    {
      "sha": "29542a5886ddecc910210d9eaaca7c9a9659b7aa",
      "filename": "libbacktrace/testlib.h",
      "status": "added",
      "additions": 110,
      "deletions": 0,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/testlib.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/testlib.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/testlib.h?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,110 @@\n+/* testlib.h -- Header for test functions for libbacktrace library\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#ifndef LIBBACKTRACE_TESTLIB_H\n+#define LIBBACKTRACE_TESTLIB_H\n+\n+/* Portable attribute syntax.  Actually some of these tests probably\n+   won't work if the attributes are not recognized.  */\n+\n+#ifndef GCC_VERSION\n+# define GCC_VERSION (__GNUC__ * 1000 + __GNUC_MINOR__)\n+#endif\n+\n+#if (GCC_VERSION < 2007)\n+# define __attribute__(x)\n+#endif\n+\n+#ifndef ATTRIBUTE_UNUSED\n+# define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n+#endif\n+\n+/* Used to collect backtrace info.  */\n+\n+struct info\n+{\n+  char *filename;\n+  int lineno;\n+  char *function;\n+};\n+\n+/* Passed to backtrace callback function.  */\n+\n+struct bdata\n+{\n+  struct info *all;\n+  size_t index;\n+  size_t max;\n+  int failed;\n+};\n+\n+/* Passed to backtrace_simple callback function.  */\n+\n+struct sdata\n+{\n+  uintptr_t *addrs;\n+  size_t index;\n+  size_t max;\n+  int failed;\n+};\n+\n+/* Passed to backtrace_syminfo callback function.  */\n+\n+struct symdata\n+{\n+  const char *name;\n+  uintptr_t val, size;\n+  int failed;\n+};\n+\n+/* The backtrace state.  */\n+\n+extern void *state;\n+\n+/* The number of failures.  */\n+\n+extern int failures;\n+\n+extern const char *base (const char *p);\n+extern void check (const char *name, int index, const struct info *all,\n+\t\t   int want_lineno, const char *want_function,\n+\t\t   const char *want_file, int *failed);\n+extern int callback_one (void *, uintptr_t, const char *, int, const char *);\n+extern void error_callback_one (void *, const char *, int);\n+extern int callback_two (void *, uintptr_t);\n+extern void error_callback_two (void *, const char *, int);\n+extern void callback_three (void *, uintptr_t, const char *, uintptr_t,\n+\t\t\t    uintptr_t);\n+extern void error_callback_three (void *, const char *, int);\n+extern void error_callback_create (void *, const char *, int);\n+\n+#endif /* !defined(LIBBACKTRACE_TESTLIB_H) */"
    },
    {
      "sha": "3758b33f0250b05b281fc39b32f0683dffdc7726",
      "filename": "libbacktrace/ttest.c",
      "status": "added",
      "additions": 161,
      "deletions": 0,
      "changes": 161,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/ttest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/ttest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/ttest.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,161 @@\n+/* ttest.c -- Test for libbacktrace library\n+   Copyright (C) 2017-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+/* Test using the libbacktrace library from multiple threads.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include <pthread.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"testlib.h\"\n+\n+static int f2 (int) __attribute__ ((noinline));\n+static int f3 (int, int) __attribute__ ((noinline));\n+\n+/* Test that a simple backtrace works.  This is called via\n+   pthread_create.  It returns the number of failures, as void *.  */\n+\n+static void *\n+test1_thread (void *arg ATTRIBUTE_UNUSED)\n+{\n+  /* Returning a value here and elsewhere avoids a tailcall which\n+     would mess up the backtrace.  */\n+  return (void *) (uintptr_t) (f2 (__LINE__) - 2);\n+}\n+\n+static int\n+f2 (int f1line)\n+{\n+  return f3 (f1line, __LINE__) + 2;\n+}\n+\n+static int\n+f3 (int f1line, int f2line)\n+{\n+  struct info all[20];\n+  struct bdata data;\n+  int f3line;\n+  int i;\n+\n+  data.all = &all[0];\n+  data.index = 0;\n+  data.max = 20;\n+  data.failed = 0;\n+\n+  f3line = __LINE__ + 1;\n+  i = backtrace_full (state, 0, callback_one, error_callback_one, &data);\n+\n+  if (i != 0)\n+    {\n+      fprintf (stderr, \"test1: unexpected return value %d\\n\", i);\n+      data.failed = 1;\n+    }\n+\n+  if (data.index < 3)\n+    {\n+      fprintf (stderr,\n+\t       \"test1: not enough frames; got %zu, expected at least 3\\n\",\n+\t       data.index);\n+      data.failed = 1;\n+    }\n+\n+  check (\"test1\", 0, all, f3line, \"f3\", \"ttest.c\", &data.failed);\n+  check (\"test1\", 1, all, f2line, \"f2\", \"ttest.c\", &data.failed);\n+  check (\"test1\", 2, all, f1line, \"test1_thread\", \"ttest.c\", &data.failed);\n+\n+  return data.failed;\n+}\n+\n+/* Run the test with 10 threads simultaneously.  */\n+\n+#define THREAD_COUNT 10\n+\n+static void test1 (void) __attribute__ ((unused));\n+\n+static void\n+test1 (void)\n+{\n+  pthread_t atid[THREAD_COUNT];\n+  int i;\n+  int errnum;\n+  int this_fail;\n+  void *ret;\n+\n+  for (i = 0; i < THREAD_COUNT; i++)\n+    {\n+      errnum = pthread_create (&atid[i], NULL, test1_thread, NULL);\n+      if (errnum != 0)\n+\t{\n+\t  fprintf (stderr, \"pthread_create %d: %s\\n\", i, strerror (errnum));\n+\t  exit (EXIT_FAILURE);\n+\t}\n+    }\n+\n+  this_fail = 0;\n+  for (i = 0; i < THREAD_COUNT; i++)\n+    {\n+      errnum = pthread_join (atid[i], &ret);\n+      if (errnum != 0)\n+\t{\n+\t  fprintf (stderr, \"pthread_join %d: %s\\n\", i, strerror (errnum));\n+\t  exit (EXIT_FAILURE);\n+\t}\n+      this_fail += (int) (uintptr_t) ret;\n+    }\n+\n+  printf (\"%s: threaded backtrace_full noinline\\n\", this_fail > 0 ? \"FAIL\" : \"PASS\");\n+\n+  failures += this_fail;\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+#if BACKTRACE_SUPPORTED\n+#if BACKTRACE_SUPPORTS_THREADS\n+  test1 ();\n+#endif\n+#endif\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "3c85623048aca5cfea9724a55292226e71ea43d0",
      "filename": "libbacktrace/unittest.c",
      "status": "added",
      "additions": 92,
      "deletions": 0,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/unittest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/unittest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/unittest.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,92 @@\n+/* unittest.c -- Test for libbacktrace library\n+   Copyright (C) 2018-2021 Free Software Foundation, Inc.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include <assert.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <unistd.h>\n+\n+#include \"filenames.h\"\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"testlib.h\"\n+\n+#include \"internal.h\"\n+\n+static unsigned count;\n+\n+static void\n+error_callback (void *vdata ATTRIBUTE_UNUSED, const char *msg ATTRIBUTE_UNUSED,\n+\t\tint errnum ATTRIBUTE_UNUSED)\n+{\n+  ++count;\n+}\n+\n+static int\n+test1 (void)\n+{\n+  int res;\n+  int failed;\n+\n+  struct backtrace_vector vec;\n+\n+  memset (&vec, 0, sizeof vec);\n+\n+  backtrace_vector_grow (state, 100, error_callback, NULL, &vec);\n+  vec.alc += vec.size;\n+  vec.size = 0;\n+\n+  count = 0;\n+  res = backtrace_vector_release (state, &vec, error_callback, NULL);\n+  failed = res != 1 || count != 0 || vec.base != NULL;\n+\n+  printf (\"%s: unittest backtrace_vector_release size == 0\\n\",\n+\t  failed ? \"FAIL\": \"PASS\");\n+\n+  if (failed)\n+    ++failures;\n+\n+  return failures;\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+  test1 ();\n+\n+  exit (failures ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "a62cbf11eb398225501ce44ddb38b68b24dbcb8e",
      "filename": "libbacktrace/unknown.c",
      "status": "added",
      "additions": 65,
      "deletions": 0,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/unknown.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/unknown.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/unknown.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,65 @@\n+/* unknown.c -- used when backtrace configury does not know file format.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <sys/types.h>\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* A trivial routine that always fails to find fileline data.  */\n+\n+static int\n+unknown_fileline (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t  uintptr_t pc, backtrace_full_callback callback,\n+\t\t  backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\t  void *data)\n+\n+{\n+  return callback (data, pc, NULL, 0, NULL);\n+}\n+\n+/* Initialize the backtrace data when we don't know how to read the\n+   debug info.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t      const char *filename ATTRIBUTE_UNUSED,\n+\t\t      int descriptor ATTRIBUTE_UNUSED,\n+\t\t      backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\t      void *data ATTRIBUTE_UNUSED, fileline *fileline_fn)\n+{\n+  state->fileline_data = NULL;\n+  *fileline_fn = unknown_fileline;\n+  return 1;\n+}"
    },
    {
      "sha": "2ded8f0024f56151bf84b7f01fb9c25d6b25389b",
      "filename": "libbacktrace/xcoff.c",
      "status": "added",
      "additions": 1607,
      "deletions": 0,
      "changes": 1607,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/xcoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/xcoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/xcoff.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,1607 @@\n+/* xcoff.c -- Get debug data from an XCOFF file for backtraces.\n+   Copyright (C) 2012-2021 Free Software Foundation, Inc.\n+   Adapted from elf.c.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <sys/types.h>\n+\n+#ifdef HAVE_LOADQUERY\n+#include <sys/ldr.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"internal.h\"\n+\n+/* The configure script must tell us whether we are 32-bit or 64-bit\n+   XCOFF.  We could make this code test and support either possibility,\n+   but there is no point.  This code only works for the currently\n+   running executable, which means that we know the XCOFF mode at\n+   configure time.  */\n+\n+#if BACKTRACE_XCOFF_SIZE != 32 && BACKTRACE_XCOFF_SIZE != 64\n+#error \"Unknown BACKTRACE_XCOFF_SIZE\"\n+#endif\n+\n+/* XCOFF file header.  */\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\n+typedef struct {\n+  uint16_t f_magic;\n+  uint16_t f_nscns;\n+  uint32_t f_timdat;\n+  uint32_t f_symptr;\n+  uint32_t f_nsyms;\n+  uint16_t f_opthdr;\n+  uint16_t f_flags;\n+} b_xcoff_filhdr;\n+\n+#define XCOFF_MAGIC\t0737\n+\n+#else /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+typedef struct {\n+  uint16_t f_magic;\n+  uint16_t f_nscns;\n+  uint32_t f_timdat;\n+  uint64_t f_symptr;\n+  uint16_t f_opthdr;\n+  uint16_t f_flags;\n+  uint32_t f_nsyms;\n+} b_xcoff_filhdr;\n+\n+#define XCOFF_MAGIC\t0767\n+\n+#endif /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+#define F_SHROBJ\t0x2000\t/* File is a shared object.  */\n+\n+/* XCOFF section header.  */\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\n+typedef struct {\n+  char s_name[8];\n+  uint32_t s_paddr;\n+  uint32_t s_vaddr;\n+  uint32_t s_size;\n+  uint32_t s_scnptr;\n+  uint32_t s_relptr;\n+  uint32_t s_lnnoptr;\n+  uint16_t s_nreloc;\n+  uint16_t s_nlnno;\n+  uint32_t s_flags;\n+} b_xcoff_scnhdr;\n+\n+#define _OVERFLOW_MARKER\t65535\n+\n+#else /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+typedef struct {\n+  char name[8];\n+  uint64_t s_paddr;\n+  uint64_t s_vaddr;\n+  uint64_t s_size;\n+  uint64_t s_scnptr;\n+  uint64_t s_relptr;\n+  uint64_t s_lnnoptr;\n+  uint32_t s_nreloc;\n+  uint32_t s_nlnno;\n+  uint32_t s_flags;\n+} b_xcoff_scnhdr;\n+\n+#endif /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+#define STYP_DWARF\t0x10\t/* DWARF debugging section.  */\n+#define STYP_TEXT\t0x20\t/* Executable text (code) section.  */\n+#define STYP_OVRFLO\t0x8000\t/* Line-number field overflow section.  */\n+\n+#define SSUBTYP_DWINFO\t0x10000\t/* DWARF info section.  */\n+#define SSUBTYP_DWLINE\t0x20000\t/* DWARF line-number section.  */\n+#define SSUBTYP_DWARNGE\t0x50000\t/* DWARF aranges section.  */\n+#define SSUBTYP_DWABREV\t0x60000\t/* DWARF abbreviation section.  */\n+#define SSUBTYP_DWSTR\t0x70000\t/* DWARF strings section.  */\n+#define SSUBTYP_DWRNGES\t0x80000\t/* DWARF ranges section.  */\n+\n+/* XCOFF symbol.  */\n+\n+#define SYMNMLEN\t8\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\n+typedef struct {\n+  union {\n+    char _name[SYMNMLEN];\n+    struct {\n+      uint32_t _zeroes;\n+      uint32_t _offset;\n+    } _s;\n+  } _u;\n+#define n_name\t\t_u._name\n+#define n_zeroes\t_u._s._zeroes\n+#define n_offset_\t_u._s._offset\n+\n+  uint32_t n_value;\n+  int16_t  n_scnum;\n+  uint16_t n_type;\n+  uint8_t  n_sclass;\n+  uint8_t  n_numaux;\n+} __attribute__ ((packed)) b_xcoff_syment;\n+\n+#else /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+typedef struct {\n+  uint64_t n_value;\n+  uint32_t n_offset_;\n+  int16_t  n_scnum;\n+  uint16_t n_type;\n+  uint8_t  n_sclass;\n+  uint8_t  n_numaux;\n+} __attribute__ ((packed)) b_xcoff_syment;\n+\n+#endif /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+#define SYMESZ\t18\n+\n+#define C_EXT\t\t2\t/* External symbol.  */\n+#define C_FCN\t\t101\t/* Beginning or end of function.  */\n+#define C_FILE\t\t103\t/* Source file name.  */\n+#define C_HIDEXT\t107\t/* Unnamed external symbol.  */\n+#define C_BINCL\t\t108\t/* Beginning of include file.  */\n+#define C_EINCL\t\t109\t/* End of include file.  */\n+#define C_WEAKEXT\t111\t/* Weak external symbol.  */\n+\n+#define ISFCN(x)\t((x) & 0x0020)\n+\n+/* XCOFF AUX entry.  */\n+\n+#define AUXESZ\t\t18\n+#define FILNMLEN\t14\n+\n+typedef union {\n+#if BACKTRACE_XCOFF_SIZE == 32\n+  struct {\n+    uint16_t pad;\n+    uint16_t x_lnnohi;\n+    uint16_t x_lnno;\n+  } x_block;\n+#else\n+  struct {\n+    uint32_t x_lnno;\n+  } x_block;\n+#endif\n+  union {\n+    char x_fname[FILNMLEN];\n+    struct {\n+      uint32_t x_zeroes;\n+      uint32_t x_offset;\n+      char     pad[FILNMLEN-8];\n+      uint8_t  x_ftype;\n+    } _x;\n+  } x_file;\n+#if BACKTRACE_XCOFF_SIZE == 32\n+  struct {\n+    uint32_t x_exptr;\n+    uint32_t x_fsize;\n+    uint32_t x_lnnoptr;\n+    uint32_t x_endndx;\n+  } x_fcn;\n+#else\n+  struct {\n+    uint64_t x_lnnoptr;\n+    uint32_t x_fsize;\n+    uint32_t x_endndx;\n+  } x_fcn;\n+#endif\n+  struct {\n+    uint8_t pad[AUXESZ-1];\n+    uint8_t x_auxtype;\n+  } x_auxtype;\n+} __attribute__ ((packed)) b_xcoff_auxent;\n+\n+/* XCOFF line number entry.  */\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\n+typedef struct {\n+  union {\n+    uint32_t l_symndx;\n+    uint32_t l_paddr;\n+  } l_addr;\n+  uint16_t l_lnno;\n+} b_xcoff_lineno;\n+\n+#define LINESZ\t6\n+\n+#else /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+typedef struct {\n+  union {\n+    uint32_t l_symndx;\n+    uint64_t l_paddr;\n+  } l_addr;\n+  uint32_t l_lnno;\n+} b_xcoff_lineno;\n+\n+#define LINESZ\t12\n+\n+#endif /* BACKTRACE_XCOFF_SIZE != 32 */\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+#define XCOFF_AIX_TEXTBASE\t0x10000000u\n+#else\n+#define XCOFF_AIX_TEXTBASE\t0x100000000ul\n+#endif\n+\n+/* AIX big archive fixed-length header.  */\n+\n+#define AIAMAGBIG\t\"<bigaf>\\n\"\n+\n+typedef struct {\n+  char fl_magic[8];\t/* Archive magic string.  */\n+  char fl_memoff[20];\t/* Offset to member table.  */\n+  char fl_gstoff[20];\t/* Offset to global symbol table.  */\n+  char fl_gst64off[20];\t/* Offset to global symbol table for 64-bit objects.  */\n+  char fl_fstmoff[20];\t/* Offset to first archive member.  */\n+  char fl_freeoff[20];\t/* Offset to first member on free list.  */\n+} b_ar_fl_hdr;\n+\n+/* AIX big archive file member header.  */\n+\n+typedef struct {\n+  char ar_size[20];\t/* File member size - decimal.  */\n+  char ar_nxtmem[20];\t/* Next member offset - decimal.  */\n+  char ar_prvmem[20];\t/* Previous member offset - decimal.  */\n+  char ar_date[12];\t/* File member date - decimal.  */\n+  char ar_uid[12];\t/* File member userid - decimal.  */\n+  char ar_gid[12];\t/* File member group id - decimal.  */\n+  char ar_mode[12];\t/* File member mode - octal.  */\n+  char ar_namlen[4];\t/* File member name length - decimal.  */\n+  char ar_name[2];\t/* Start of member name.  */\n+} b_ar_hdr;\n+\n+\n+/* Information we keep for an XCOFF symbol.  */\n+\n+struct xcoff_symbol\n+{\n+  /* The name of the symbol.  */\n+  const char *name;\n+  /* The address of the symbol.  */\n+  uintptr_t address;\n+  /* The size of the symbol.  */\n+  size_t size;\n+};\n+\n+/* Information to pass to xcoff_syminfo.  */\n+\n+struct xcoff_syminfo_data\n+{\n+  /* Symbols for the next module.  */\n+  struct xcoff_syminfo_data *next;\n+  /* The XCOFF symbols, sorted by address.  */\n+  struct xcoff_symbol *symbols;\n+  /* The number of symbols.  */\n+  size_t count;\n+};\n+\n+/* Information about an include file.  */\n+\n+struct xcoff_incl\n+{\n+  /* File name.  */\n+  const char *filename;\n+  /* Offset to first line number from the include file.  */\n+  uintptr_t begin;\n+  /* Offset to last line number from the include file.  */\n+  uintptr_t end;\n+};\n+\n+/* A growable vector of include files information.  */\n+\n+struct xcoff_incl_vector\n+{\n+  /* Memory.  This is an array of struct xcoff_incl.  */\n+  struct backtrace_vector vec;\n+  /* Number of include files.  */\n+  size_t count;\n+};\n+\n+/* A growable vector of functions information.  */\n+\n+struct xcoff_func\n+{\n+  /* PC.  */\n+  uintptr_t pc;\n+  /* The size of the function.  */\n+  size_t size;\n+  /* Function name.  */\n+  const char *name;\n+  /* File name.  */\n+  const char *filename;\n+  /* Pointer to first lnno entry.  */\n+  uintptr_t lnnoptr;\n+  /* Base address of containing section.  */\n+  uintptr_t sect_base;\n+  /* Starting source line number.  */\n+  int lnno;\n+};\n+\n+/* A growable vector of function information.  This is used while\n+   reading the function symbols.  */\n+\n+struct xcoff_func_vector\n+{\n+  /* Memory.  This is an array of struct xcoff_func.  */\n+  struct backtrace_vector vec;\n+  /* Number of valid mappings.  */\n+  size_t count;\n+};\n+\n+/* The information we need to map a PC to a file and line.  */\n+\n+struct xcoff_fileline_data\n+{\n+  /* The data for the next file we know about.  */\n+  struct xcoff_fileline_data *next;\n+  /* Functions information.  */\n+  struct xcoff_func_vector func_vec;\n+  /* Include files information.  */\n+  struct xcoff_incl_vector incl_vec;\n+  /* Line numbers information.  */\n+  const unsigned char *linenos;\n+  size_t linenos_size;\n+  uint64_t lnnoptr0;\n+  /* Loader address.  */\n+  uintptr_t base_address;\n+};\n+\n+/* Information we gather for the DWARF sections we care about.  */\n+\n+struct dwsect_info\n+{\n+  /* Section file offset.  */\n+  off_t offset;\n+  /* Section size.  */\n+  size_t size;\n+  /* Section contents, after read from file.  */\n+  const unsigned char *data;\n+};\n+\n+/* A dummy callback function used when we can't find any debug info.  */\n+\n+static int\n+xcoff_nodebug (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t       uintptr_t pc ATTRIBUTE_UNUSED,\n+\t       backtrace_full_callback callback ATTRIBUTE_UNUSED,\n+\t       backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no debug info in XCOFF executable\", -1);\n+  return 0;\n+}\n+\n+/* A dummy callback function used when we can't find a symbol\n+   table.  */\n+\n+static void\n+xcoff_nosyms (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t      uintptr_t addr ATTRIBUTE_UNUSED,\n+\t      backtrace_syminfo_callback callback ATTRIBUTE_UNUSED,\n+\t      backtrace_error_callback error_callback, void *data)\n+{\n+  error_callback (data, \"no symbol table in XCOFF executable\", -1);\n+}\n+\n+/* Compare struct xcoff_symbol for qsort.  */\n+\n+static int\n+xcoff_symbol_compare (const void *v1, const void *v2)\n+{\n+  const struct xcoff_symbol *e1 = (const struct xcoff_symbol *) v1;\n+  const struct xcoff_symbol *e2 = (const struct xcoff_symbol *) v2;\n+\n+  if (e1->address < e2->address)\n+    return -1;\n+  else if (e1->address > e2->address)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Compare an ADDR against an xcoff_symbol for bsearch.  */\n+\n+static int\n+xcoff_symbol_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct xcoff_symbol *entry = (const struct xcoff_symbol *) ventry;\n+  uintptr_t addr;\n+\n+  addr = *key;\n+  if (addr < entry->address)\n+    return -1;\n+  else if ((entry->size == 0 && addr > entry->address)\n+\t   || (entry->size > 0 && addr >= entry->address + entry->size))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Add XDATA to the list in STATE.  */\n+\n+static void\n+xcoff_add_syminfo_data (struct backtrace_state *state,\n+\t\t\tstruct xcoff_syminfo_data *xdata)\n+{\n+  if (!state->threaded)\n+    {\n+      struct xcoff_syminfo_data **pp;\n+\n+      for (pp = (struct xcoff_syminfo_data **) (void *) &state->syminfo_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = xdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct xcoff_syminfo_data **pp;\n+\n+\t  pp = (struct xcoff_syminfo_data **) (void *) &state->syminfo_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct xcoff_syminfo_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, xdata))\n+\t    break;\n+\t}\n+    }\n+}\n+\n+/* Return the symbol name and value for an ADDR.  */\n+\n+static void\n+xcoff_syminfo (struct backtrace_state *state ATTRIBUTE_UNUSED, uintptr_t addr,\n+\t       backtrace_syminfo_callback callback,\n+\t       backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t       void *data)\n+{\n+  struct xcoff_syminfo_data *edata;\n+  struct xcoff_symbol *sym = NULL;\n+  const char *name;\n+\n+  if (!state->threaded)\n+    {\n+      for (edata = (struct xcoff_syminfo_data *) state->syminfo_data;\n+\t   edata != NULL;\n+\t   edata = edata->next)\n+\t{\n+\t  sym = ((struct xcoff_symbol *)\n+\t\t bsearch (&addr, edata->symbols, edata->count,\n+\t\t\t  sizeof (struct xcoff_symbol), xcoff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\t}\n+    }\n+  else\n+    {\n+      struct xcoff_syminfo_data **pp;\n+\n+      pp = (struct xcoff_syminfo_data **) (void *) &state->syminfo_data;\n+      while (1)\n+\t{\n+\t  edata = backtrace_atomic_load_pointer (pp);\n+\t  if (edata == NULL)\n+\t    break;\n+\n+\t  sym = ((struct xcoff_symbol *)\n+\t\t bsearch (&addr, edata->symbols, edata->count,\n+\t\t\t  sizeof (struct xcoff_symbol), xcoff_symbol_search));\n+\t  if (sym != NULL)\n+\t    break;\n+\n+\t  pp = &edata->next;\n+\t}\n+    }\n+\n+  if (sym == NULL)\n+    callback (data, addr, NULL, 0, 0);\n+  else\n+    {\n+      name = sym->name;\n+      /* AIX prepends a '.' to function entry points, remove it.  */\n+      if (name && *name == '.')\n+\t++name;\n+      callback (data, addr, name, sym->address, sym->size);\n+    }\n+}\n+\n+/* Return the name of an XCOFF symbol.  */\n+\n+static const char *\n+xcoff_symname (const b_xcoff_syment *asym,\n+\t       const unsigned char *strtab, size_t strtab_size)\n+{\n+#if BACKTRACE_XCOFF_SIZE == 32\n+  if (asym->n_zeroes != 0)\n+    {\n+      /* Make a copy as we will release the symtab view.  */\n+      char name[SYMNMLEN+1];\n+      strncpy (name, asym->n_name, SYMNMLEN);\n+      name[SYMNMLEN] = '\\0';\n+      return strdup (name);\n+    }\n+#endif\n+  if (asym->n_sclass & 0x80)\n+    return NULL; /* .debug */\n+  if (asym->n_offset_ >= strtab_size)\n+    return NULL;\n+  return (const char *) strtab + asym->n_offset_;\n+}\n+\n+/* Initialize the symbol table info for xcoff_syminfo.  */\n+\n+static int\n+xcoff_initialize_syminfo (struct backtrace_state *state,\n+\t\t\t  uintptr_t base_address,\n+\t\t\t  const b_xcoff_syment *syms, size_t nsyms,\n+\t\t\t  const unsigned char *strtab, size_t strtab_size,\n+\t\t\t  backtrace_error_callback error_callback, void *data,\n+\t\t\t  struct xcoff_syminfo_data *sdata)\n+{\n+  size_t xcoff_symbol_count;\n+  size_t xcoff_symbol_size;\n+  struct xcoff_symbol *xcoff_symbols;\n+  size_t i;\n+  unsigned int j;\n+\n+  /* We only care about function symbols.  Count them.  */\n+  xcoff_symbol_count = 0;\n+  for (i = 0; i < nsyms; ++i)\n+    {\n+      const b_xcoff_syment *asym = &syms[i];\n+      if ((asym->n_sclass == C_EXT || asym->n_sclass == C_HIDEXT\n+\t    || asym->n_sclass == C_WEAKEXT)\n+\t  && ISFCN (asym->n_type) && asym->n_numaux > 0 && asym->n_scnum > 0)\n+\t++xcoff_symbol_count;\n+\n+      i += asym->n_numaux;\n+    }\n+\n+  xcoff_symbol_size = xcoff_symbol_count * sizeof (struct xcoff_symbol);\n+  xcoff_symbols = ((struct xcoff_symbol *)\n+\t\t   backtrace_alloc (state, xcoff_symbol_size, error_callback,\n+\t\t\t\t    data));\n+  if (xcoff_symbols == NULL)\n+    return 0;\n+\n+  j = 0;\n+  for (i = 0; i < nsyms; ++i)\n+    {\n+      const b_xcoff_syment *asym = &syms[i];\n+      if ((asym->n_sclass == C_EXT || asym->n_sclass == C_HIDEXT\n+\t    || asym->n_sclass == C_WEAKEXT)\n+\t  && ISFCN (asym->n_type) && asym->n_numaux > 0 && asym->n_scnum > 0)\n+\t{\n+\t  const b_xcoff_auxent *aux = (const b_xcoff_auxent *) (asym + 1);\n+\t  xcoff_symbols[j].name = xcoff_symname (asym, strtab, strtab_size);\n+\t  xcoff_symbols[j].address = base_address + asym->n_value;\n+\t  /* x_fsize will be 0 if there is no debug information.  */\n+\t  xcoff_symbols[j].size = aux->x_fcn.x_fsize;\n+\t  ++j;\n+\t}\n+\n+      i += asym->n_numaux;\n+    }\n+\n+  backtrace_qsort (xcoff_symbols, xcoff_symbol_count,\n+\t\t   sizeof (struct xcoff_symbol), xcoff_symbol_compare);\n+\n+  sdata->next = NULL;\n+  sdata->symbols = xcoff_symbols;\n+  sdata->count = xcoff_symbol_count;\n+\n+  return 1;\n+}\n+\n+/* Compare struct xcoff_func for qsort.  */\n+\n+static int\n+xcoff_func_compare (const void *v1, const void *v2)\n+{\n+  const struct xcoff_func *fn1 = (const struct xcoff_func *) v1;\n+  const struct xcoff_func *fn2 = (const struct xcoff_func *) v2;\n+\n+  if (fn1->pc < fn2->pc)\n+    return -1;\n+  else if (fn1->pc > fn2->pc)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Compare a PC against an xcoff_func for bsearch.  */\n+\n+static int\n+xcoff_func_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct xcoff_func *entry = (const struct xcoff_func *) ventry;\n+  uintptr_t pc;\n+\n+  pc = *key;\n+  if (pc < entry->pc)\n+    return -1;\n+  else if ((entry->size == 0 && pc > entry->pc)\n+\t   || (entry->size > 0 && pc >= entry->pc + entry->size))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Compare struct xcoff_incl for qsort.  */\n+\n+static int\n+xcoff_incl_compare (const void *v1, const void *v2)\n+{\n+  const struct xcoff_incl *in1 = (const struct xcoff_incl *) v1;\n+  const struct xcoff_incl *in2 = (const struct xcoff_incl *) v2;\n+\n+  if (in1->begin < in2->begin)\n+    return -1;\n+  else if (in1->begin > in2->begin)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Find a lnnoptr in an include file.  */\n+\n+static int\n+xcoff_incl_search (const void *vkey, const void *ventry)\n+{\n+  const uintptr_t *key = (const uintptr_t *) vkey;\n+  const struct xcoff_incl *entry = (const struct xcoff_incl *) ventry;\n+  uintptr_t lnno;\n+\n+  lnno = *key;\n+  if (lnno < entry->begin)\n+    return -1;\n+  else if (lnno > entry->end)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+/* Look for a PC in the function vector for one module.  On success,\n+   call CALLBACK and return whatever it returns.  On error, call\n+   ERROR_CALLBACK and return 0.  Sets *FOUND to 1 if the PC is found,\n+   0 if not.  */\n+\n+static int\n+xcoff_lookup_pc (struct backtrace_state *state ATTRIBUTE_UNUSED,\n+\t\t struct xcoff_fileline_data *fdata, uintptr_t pc,\n+\t\t backtrace_full_callback callback,\n+\t\t backtrace_error_callback error_callback ATTRIBUTE_UNUSED,\n+\t\t void *data, int *found)\n+{\n+  const struct xcoff_incl *incl, *bincl;\n+  const struct xcoff_func *fn;\n+  const b_xcoff_lineno *lineno;\n+  const unsigned char *lineptr;\n+  const char *function;\n+  const char *filename;\n+  uintptr_t lnnoptr, match;\n+  uint32_t lnno = 0;\n+\n+  *found = 1;\n+\n+  if ((pc & 3) != 0)\n+    ++pc;\n+\n+  /* Find the function first.  */\n+  fn = ((struct xcoff_func *)\n+\tbsearch (&pc, fdata->func_vec.vec.base, fdata->func_vec.count,\n+\t\t sizeof (struct xcoff_func), xcoff_func_search));\n+  if (fn == NULL)\n+    {\n+      *found = 0;\n+      return 0;\n+    }\n+\n+  filename = fn->filename;\n+\n+  /* Find the line number next.  */\n+\n+  /* Skip first entry that points to symtab.  */\n+  lnnoptr = fn->lnnoptr + LINESZ;\n+  match = lnnoptr;\n+\n+  lineptr = fdata->linenos + (lnnoptr - fdata->lnnoptr0);\n+  while (lineptr + LINESZ <= fdata->linenos + fdata->linenos_size)\n+    {\n+      lineno = (const b_xcoff_lineno *) lineptr;\n+      if (lineno->l_lnno == 0)\n+\tbreak;\n+      if (pc <= fdata->base_address + lineno->l_addr.l_paddr)\n+\tbreak;\n+      match = lnnoptr;\n+      lnno = lineno->l_lnno;\n+\n+      lnnoptr += LINESZ;\n+      lineptr += LINESZ;\n+    }\n+\n+  /* If part of a function other than the beginning comes from an\n+     include file, the line numbers are absolute, rather than\n+     relative to the beginning of the function.  */\n+  incl = ((struct xcoff_incl *)\n+\t  bsearch (&match, fdata->incl_vec.vec.base,\n+\t\t   fdata->incl_vec.count, sizeof (struct xcoff_incl),\n+\t\t   xcoff_incl_search));\n+  if (incl != NULL)\n+    {\n+      bincl = ((struct xcoff_incl *)\n+\t       bsearch (&fn->lnnoptr, fdata->incl_vec.vec.base,\n+\t\t\tfdata->incl_vec.count, sizeof (struct xcoff_incl),\n+\t\t\txcoff_incl_search));\n+      if (bincl != NULL && strcmp (incl->filename, bincl->filename) == 0)\n+\t{\n+\t  lnno += fn->lnno - 1;\n+\t}\n+      filename = incl->filename;\n+    }\n+  else\n+    {\n+      lnno += fn->lnno - 1;\n+    }\n+\n+  function = fn->name;\n+  /* AIX prepends a '.' to function entry points, remove it.  */\n+  if (function != NULL && *function == '.')\n+    ++function;\n+  return callback (data, pc, filename, lnno, function);\n+}\n+\n+/* Return the file/line information for a PC using the XCOFF lineno\n+   mapping we built earlier.  */\n+\n+static int\n+xcoff_fileline (struct backtrace_state *state, uintptr_t pc,\n+\t\tbacktrace_full_callback callback,\n+\t\tbacktrace_error_callback error_callback, void *data)\n+\n+{\n+  struct xcoff_fileline_data *fdata;\n+  int found;\n+  int ret;\n+\n+  if (!state->threaded)\n+    {\n+      for (fdata = (struct xcoff_fileline_data *) state->fileline_data;\n+\t   fdata != NULL;\n+\t   fdata = fdata->next)\n+\t{\n+\t  ret = xcoff_lookup_pc (state, fdata, pc, callback, error_callback,\n+\t\t\t\t data, &found);\n+\t  if (ret != 0 || found)\n+\t    return ret;\n+\t}\n+    }\n+  else\n+    {\n+      struct xcoff_fileline_data **pp;\n+\n+      pp = (struct xcoff_fileline_data **) (void *) &state->fileline_data;\n+      while (1)\n+\t{\n+\t  fdata = backtrace_atomic_load_pointer (pp);\n+\t  if (fdata == NULL)\n+\t    break;\n+\n+\t  ret = xcoff_lookup_pc (state, fdata, pc, callback, error_callback,\n+\t\t\t\t data, &found);\n+\t  if (ret != 0 || found)\n+\t    return ret;\n+\n+\t  pp = &fdata->next;\n+\t}\n+    }\n+\n+  /* FIXME: See if any libraries have been dlopen'ed.  */\n+\n+  return callback (data, pc, NULL, 0, NULL);\n+}\n+\n+/* Initialize the function vector info for xcoff_fileline.  */\n+\n+static int\n+xcoff_initialize_fileline (struct backtrace_state *state,\n+\t\t\t   uintptr_t base_address,\n+\t\t\t   const b_xcoff_scnhdr *sects,\n+\t\t\t   const b_xcoff_syment *syms, size_t nsyms,\n+\t\t\t   const unsigned char *strtab, size_t strtab_size,\n+\t\t\t   const unsigned char *linenos, size_t linenos_size,\n+\t\t\t   uint64_t lnnoptr0,\n+\t\t\t   backtrace_error_callback error_callback, void *data)\n+{\n+  struct xcoff_fileline_data *fdata;\n+  struct xcoff_func *fn;\n+  const b_xcoff_syment *fsym;\n+  const b_xcoff_auxent *aux;\n+  const char *filename;\n+  const char *name;\n+  struct xcoff_incl *incl;\n+  uintptr_t begin, end;\n+  uintptr_t lnno, lnnoptr;\n+  uint32_t fsize;\n+  size_t i;\n+\n+  fdata = ((struct xcoff_fileline_data *)\n+\t   backtrace_alloc (state, sizeof (struct xcoff_fileline_data),\n+\t\t\t    error_callback, data));\n+  if (fdata == NULL)\n+    return 0;\n+  memset (fdata, 0, sizeof *fdata);\n+  fdata->base_address = base_address;\n+  fdata->linenos = linenos;\n+  fdata->linenos_size = linenos_size;\n+  fdata->lnnoptr0 = lnnoptr0;\n+\n+  begin = 0;\n+  filename = NULL;\n+  fsym = NULL;\n+  lnnoptr = 0;\n+  fsize = 0;\n+  for (i = 0; i < nsyms; ++i)\n+    {\n+      const b_xcoff_syment *asym = &syms[i];\n+\n+      switch (asym->n_sclass)\n+\t{\n+\t  case C_BINCL:\n+\t    begin = asym->n_value;\n+\t    break;\n+\n+\t  case C_EINCL:\n+\t    if (begin == 0)\n+\t      break;\n+\t    end = asym->n_value;\n+\t    incl = ((struct xcoff_incl *)\n+\t\t    backtrace_vector_grow (state, sizeof (struct xcoff_incl),\n+\t\t\t\t\t   error_callback, data,\n+\t\t\t\t\t   &fdata->incl_vec.vec));\n+\t    if (incl != NULL)\n+\t      {\n+\t\tincl->filename = xcoff_symname (asym, strtab, strtab_size);\n+\t\tincl->begin = begin;\n+\t\tincl->end = end;\n+\t\t++fdata->incl_vec.count;\n+\t      }\n+\t    begin = 0;\n+\t    break;\n+\n+\t  case C_FILE:\n+\t    filename = xcoff_symname (asym, strtab, strtab_size);\n+\t    if (filename == NULL)\n+\t      break;\n+\n+\t    /* If the file auxiliary entry is not used, the symbol name is\n+\t       the name of the source file. If the file auxiliary entry is\n+\t       used, then the symbol name should be .file, and the first\n+\t       file auxiliary entry (by convention) contains the source\n+\t       file name.  */\n+\n+\t    if (asym->n_numaux > 0 && strcmp (filename, \".file\") == 0)\n+\t      {\n+\t\taux = (const b_xcoff_auxent *) (asym + 1);\n+\t\tif (aux->x_file._x.x_zeroes != 0)\n+\t\t  {\n+\t\t    /* Make a copy as we will release the symtab view.  */\n+\t\t    char name[FILNMLEN+1];\n+\t\t    strncpy (name, aux->x_file.x_fname, FILNMLEN);\n+\t\t    name[FILNMLEN] = '\\0';\n+\t\t    filename = strdup (name);\n+\t\t  }\n+\t\telse if (aux->x_file._x.x_offset < strtab_size)\n+\t\t  filename = (const char *) strtab + aux->x_file._x.x_offset;\n+\t\telse\n+\t\t  filename = NULL;\n+\t      }\n+\t    break;\n+\n+\t  case C_EXT:\n+\t  case C_HIDEXT:\n+\t  case C_WEAKEXT:\n+\t    fsym = NULL;\n+\t    lnnoptr = 0;\n+\t    fsize = 0;\n+\t    if (!ISFCN (asym->n_type) || asym->n_numaux == 0\n+\t\t|| asym->n_scnum <= 0)\n+\t      break;\n+\t    if (filename == NULL)\n+\t      break;\n+\t    aux = (const b_xcoff_auxent *) (asym + 1);\n+\t    lnnoptr = aux->x_fcn.x_lnnoptr;\n+\t    if (lnnoptr < lnnoptr0\n+\t\t|| lnnoptr + LINESZ > lnnoptr0 + linenos_size)\n+\t      break;\n+\t    /* x_fsize will be 0 if there is no debug information.  */\n+\t    fsize = aux->x_fcn.x_fsize;\n+\t    fsym = asym;\n+\t    break;\n+\n+\t  case C_FCN:\n+\t    if (asym->n_numaux == 0)\n+\t      break;\n+\t    if (fsym == NULL)\n+\t      break;\n+\t    name = xcoff_symname (asym, strtab, strtab_size);\n+\t    if (name == NULL || strcmp (name, \".bf\") != 0)\n+\t      {\n+\t\tfsym = NULL;\n+\t\tbreak;\n+\t      }\n+\t    aux = (const b_xcoff_auxent *) (asym + 1);\n+#if BACKTRACE_XCOFF_SIZE == 32\n+\t    lnno = (uint32_t) aux->x_block.x_lnnohi << 16\n+\t\t | aux->x_block.x_lnno;\n+#else\n+\t    lnno = aux->x_block.x_lnno;\n+#endif\n+\t    fn = ((struct xcoff_func *)\n+\t\t  backtrace_vector_grow (state, sizeof (struct xcoff_func),\n+\t\t\t\t\t error_callback, data,\n+\t\t\t\t\t &fdata->func_vec.vec));\n+\t    if (fn == NULL)\n+\t      break;\n+\t    fn->name = xcoff_symname (fsym, strtab, strtab_size);\n+\t    fn->filename = filename;\n+\t    fn->sect_base = sects[fsym->n_scnum - 1].s_paddr;\n+\t    fn->pc = base_address + fsym->n_value;\n+\t    fn->size = fsize;\n+\t    fn->lnno = lnno;\n+\t    fn->lnnoptr = lnnoptr;\n+\t    ++fdata->func_vec.count;\n+\t    break;\n+\t}\n+\n+      i += asym->n_numaux;\n+    }\n+\n+  if (!backtrace_vector_release (state, &fdata->func_vec.vec, error_callback,\n+\t\t\t\t data))\n+    goto fail;\n+  backtrace_qsort (fdata->func_vec.vec.base, fdata->func_vec.count,\n+\t\t   sizeof (struct xcoff_func), xcoff_func_compare);\n+\n+  if (!backtrace_vector_release (state, &fdata->incl_vec.vec, error_callback,\n+\t\t\t\t data))\n+    goto fail;\n+  backtrace_qsort (fdata->incl_vec.vec.base, fdata->incl_vec.count,\n+\t\t   sizeof (struct xcoff_incl), xcoff_incl_compare);\n+\n+  if (!state->threaded)\n+    {\n+      struct xcoff_fileline_data **pp;\n+\n+      for (pp = (struct xcoff_fileline_data **) (void *) &state->fileline_data;\n+\t   *pp != NULL;\n+\t   pp = &(*pp)->next)\n+\t;\n+      *pp = fdata;\n+    }\n+  else\n+    {\n+      while (1)\n+\t{\n+\t  struct xcoff_fileline_data **pp;\n+\n+\t  pp = (struct xcoff_fileline_data **) (void *) &state->fileline_data;\n+\n+\t  while (1)\n+\t    {\n+\t      struct xcoff_fileline_data *p;\n+\n+\t      p = backtrace_atomic_load_pointer (pp);\n+\n+\t      if (p == NULL)\n+\t\tbreak;\n+\n+\t      pp = &p->next;\n+\t    }\n+\n+\t  if (__sync_bool_compare_and_swap (pp, NULL, fdata))\n+\t    break;\n+\t}\n+    }\n+\n+  return 1;\n+\n+fail:\n+  return 0;\n+}\n+\n+/* Add the backtrace data for one XCOFF file.  Returns 1 on success,\n+   0 on failure (in both cases descriptor is closed).  */\n+\n+static int\n+xcoff_add (struct backtrace_state *state, int descriptor, off_t offset,\n+\t   uintptr_t base_address, backtrace_error_callback error_callback,\n+\t   void *data, fileline *fileline_fn, int *found_sym, int exe)\n+{\n+  struct backtrace_view fhdr_view;\n+  struct backtrace_view sects_view;\n+  struct backtrace_view linenos_view;\n+  struct backtrace_view syms_view;\n+  struct backtrace_view str_view;\n+  struct backtrace_view dwarf_view;\n+  b_xcoff_filhdr fhdr;\n+  const b_xcoff_scnhdr *sects;\n+  const b_xcoff_scnhdr *stext;\n+  uint64_t lnnoptr;\n+  uint32_t nlnno;\n+  off_t str_off;\n+  off_t min_offset;\n+  off_t max_offset;\n+  struct dwsect_info dwsect[DEBUG_MAX];\n+  size_t sects_size;\n+  size_t syms_size;\n+  int32_t str_size;\n+  int sects_view_valid;\n+  int linenos_view_valid;\n+  int syms_view_valid;\n+  int str_view_valid;\n+  int dwarf_view_valid;\n+  int magic_ok;\n+  int i;\n+  struct dwarf_sections dwarf_sections;\n+\n+  *found_sym = 0;\n+\n+  sects_view_valid = 0;\n+  linenos_view_valid = 0;\n+  syms_view_valid = 0;\n+  str_view_valid = 0;\n+  dwarf_view_valid = 0;\n+\n+  str_size = 0;\n+\n+  /* Map the XCOFF file header.  */\n+  if (!backtrace_get_view (state, descriptor, offset, sizeof (b_xcoff_filhdr),\n+\t\t\t   error_callback, data, &fhdr_view))\n+    goto fail;\n+\n+  memcpy (&fhdr, fhdr_view.data, sizeof fhdr);\n+  magic_ok = (fhdr.f_magic == XCOFF_MAGIC);\n+\n+  backtrace_release_view (state, &fhdr_view, error_callback, data);\n+\n+  if (!magic_ok)\n+    {\n+      if (exe)\n+\terror_callback (data, \"executable file is not XCOFF\", 0);\n+      goto fail;\n+    }\n+\n+  /* Verify object is of expected type.  */\n+  if ((exe && (fhdr.f_flags & F_SHROBJ))\n+      || (!exe && !(fhdr.f_flags & F_SHROBJ)))\n+    goto fail;\n+\n+  /* Read the section headers.  */\n+\n+  sects_size = fhdr.f_nscns * sizeof (b_xcoff_scnhdr);\n+\n+  if (!backtrace_get_view (state, descriptor,\n+\t\t\t   offset + sizeof (fhdr) + fhdr.f_opthdr,\n+\t\t\t   sects_size, error_callback, data, &sects_view))\n+    goto fail;\n+  sects_view_valid = 1;\n+  sects = (const b_xcoff_scnhdr *) sects_view.data;\n+\n+  /* FIXME: assumes only one .text section.  */\n+  for (i = 0; i < fhdr.f_nscns; ++i)\n+    if ((sects[i].s_flags & 0xffff) == STYP_TEXT)\n+      break;\n+  if (i == fhdr.f_nscns)\n+    goto fail;\n+\n+  stext = &sects[i];\n+\n+  /* base_address represents the difference between the\n+     virtual memory address of the shared object or a loaded\n+     executable and the offset of that object in the file\n+     from which it was loaded.\n+     On AIX, virtual address is either fixed for executable\n+     or given by ldinfo.  This address will include the XCOFF\n+     headers.  */\n+  base_address = ((exe ? XCOFF_AIX_TEXTBASE : base_address)\n+\t\t  + stext->s_scnptr\n+\t\t  - stext->s_paddr);\n+\n+  lnnoptr = stext->s_lnnoptr;\n+  nlnno = stext->s_nlnno;\n+\n+#if BACKTRACE_XCOFF_SIZE == 32\n+  if (nlnno == _OVERFLOW_MARKER)\n+    {\n+      int sntext = i + 1;\n+      /* Find the matching .ovrflo section.  */\n+      for (i = 0; i < fhdr.f_nscns; ++i)\n+\t{\n+\t  if (((sects[i].s_flags & 0xffff) == STYP_OVRFLO)\n+\t      && sects[i].s_nlnno == sntext)\n+\t    {\n+\t      nlnno = sects[i].s_vaddr;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+#endif\n+\n+  /* Read the symbol table and the string table.  */\n+\n+  if (fhdr.f_symptr != 0)\n+    {\n+      struct xcoff_syminfo_data *sdata;\n+\n+      /* Symbol table is followed by the string table.  The string table\n+\t starts with its length (on 4 bytes).\n+\t Map the symbol table and the length of the string table.  */\n+      syms_size = fhdr.f_nsyms * sizeof (b_xcoff_syment);\n+\n+      if (!backtrace_get_view (state, descriptor, offset + fhdr.f_symptr,\n+\t\t\t       syms_size + 4, error_callback, data,\n+\t\t\t       &syms_view))\n+\tgoto fail;\n+      syms_view_valid = 1;\n+\n+      memcpy (&str_size, syms_view.data + syms_size, 4);\n+\n+      str_off = fhdr.f_symptr + syms_size;\n+\n+      if (str_size > 4)\n+\t{\n+\t  /* Map string table (including the length word).  */\n+\n+\t  if (!backtrace_get_view (state, descriptor, offset + str_off,\n+\t\t\t\t   str_size, error_callback, data, &str_view))\n+\t    goto fail;\n+\t  str_view_valid = 1;\n+\t}\n+\n+      sdata = ((struct xcoff_syminfo_data *)\n+\t       backtrace_alloc (state, sizeof *sdata, error_callback, data));\n+      if (sdata == NULL)\n+\tgoto fail;\n+\n+      if (!xcoff_initialize_syminfo (state, base_address,\n+\t\t\t\t     syms_view.data, fhdr.f_nsyms,\n+\t\t\t\t     str_view.data, str_size,\n+\t\t\t\t     error_callback, data, sdata))\n+\t{\n+\t  backtrace_free (state, sdata, sizeof *sdata, error_callback, data);\n+\t  goto fail;\n+\t}\n+\n+      *found_sym = 1;\n+\n+      xcoff_add_syminfo_data (state, sdata);\n+    }\n+\n+  /* Read all the DWARF sections in a single view, since they are\n+     probably adjacent in the file.  We never release this view.  */\n+\n+  min_offset = 0;\n+  max_offset = 0;\n+  memset (dwsect, 0, sizeof dwsect);\n+  for (i = 0; i < fhdr.f_nscns; ++i)\n+    {\n+      off_t end;\n+      int idx;\n+\n+      if ((sects[i].s_flags & 0xffff) != STYP_DWARF\n+\t  || sects[i].s_size == 0)\n+\tcontinue;\n+      /* Map DWARF section to array index.  */\n+      switch (sects[i].s_flags & 0xffff0000)\n+\t{\n+\t  case SSUBTYP_DWINFO:\n+\t    idx = DEBUG_INFO;\n+\t    break;\n+\t  case SSUBTYP_DWLINE:\n+\t    idx = DEBUG_LINE;\n+\t    break;\n+\t  case SSUBTYP_DWABREV:\n+\t    idx = DEBUG_ABBREV;\n+\t    break;\n+\t  case SSUBTYP_DWRNGES:\n+\t    idx = DEBUG_RANGES;\n+\t    break;\n+\t  case SSUBTYP_DWSTR:\n+\t    idx = DEBUG_STR;\n+\t    break;\n+\t  default:\n+\t    continue;\n+\t}\n+      if (min_offset == 0 || (off_t) sects[i].s_scnptr < min_offset)\n+\tmin_offset = sects[i].s_scnptr;\n+      end = sects[i].s_scnptr + sects[i].s_size;\n+      if (end > max_offset)\n+\tmax_offset = end;\n+      dwsect[idx].offset = sects[i].s_scnptr;\n+      dwsect[idx].size = sects[i].s_size;\n+    }\n+  if (min_offset != 0 && max_offset != 0)\n+    {\n+      if (!backtrace_get_view (state, descriptor, offset + min_offset,\n+\t\t\t       max_offset - min_offset,\n+\t\t\t       error_callback, data, &dwarf_view))\n+\tgoto fail;\n+      dwarf_view_valid = 1;\n+\n+      for (i = 0; i < (int) DEBUG_MAX; ++i)\n+\t{\n+\t  if (dwsect[i].offset == 0)\n+\t    dwsect[i].data = NULL;\n+\t  else\n+\t    dwsect[i].data = ((const unsigned char *) dwarf_view.data\n+\t\t\t      + (dwsect[i].offset - min_offset));\n+\t}\n+\n+      memset (&dwarf_sections, 0, sizeof dwarf_sections);\n+\n+      dwarf_sections.data[DEBUG_INFO] = dwsect[DEBUG_INFO].data;\n+      dwarf_sections.size[DEBUG_INFO] = dwsect[DEBUG_INFO].size;\n+      dwarf_sections.data[DEBUG_LINE] = dwsect[DEBUG_LINE].data;\n+      dwarf_sections.size[DEBUG_LINE] = dwsect[DEBUG_LINE].size;\n+      dwarf_sections.data[DEBUG_ABBREV] = dwsect[DEBUG_ABBREV].data;\n+      dwarf_sections.size[DEBUG_ABBREV] = dwsect[DEBUG_ABBREV].size;\n+      dwarf_sections.data[DEBUG_RANGES] = dwsect[DEBUG_RANGES].data;\n+      dwarf_sections.size[DEBUG_RANGES] = dwsect[DEBUG_RANGES].size;\n+      dwarf_sections.data[DEBUG_STR] = dwsect[DEBUG_STR].data;\n+      dwarf_sections.size[DEBUG_STR] = dwsect[DEBUG_STR].size;\n+\n+      if (!backtrace_dwarf_add (state, base_address, &dwarf_sections,\n+\t\t\t\t1, /* big endian */\n+\t\t\t\tNULL, /* altlink */\n+\t\t\t\terror_callback, data, fileline_fn,\n+\t\t\t\tNULL /* returned fileline_entry */))\n+\tgoto fail;\n+    }\n+\n+  /* Read the XCOFF line number entries if DWARF sections not found.  */\n+\n+  if (!dwarf_view_valid && fhdr.f_symptr != 0 && lnnoptr != 0)\n+    {\n+      size_t linenos_size = (size_t) nlnno * LINESZ;\n+\n+      /* We never release this view.  */\n+      if (!backtrace_get_view (state, descriptor, offset + lnnoptr,\n+\t\t\t       linenos_size,\n+\t\t\t       error_callback, data, &linenos_view))\n+\tgoto fail;\n+      linenos_view_valid = 1;\n+\n+      if (xcoff_initialize_fileline (state, base_address, sects,\n+\t\t\t\t     syms_view.data, fhdr.f_nsyms,\n+\t\t\t\t     str_view.data, str_size,\n+\t\t\t\t     linenos_view.data, linenos_size,\n+\t\t\t\t     lnnoptr, error_callback, data))\n+\t*fileline_fn = xcoff_fileline;\n+    }\n+\n+  backtrace_release_view (state, &sects_view, error_callback, data);\n+  sects_view_valid = 0;\n+  if (syms_view_valid)\n+    backtrace_release_view (state, &syms_view, error_callback, data);\n+  syms_view_valid = 0;\n+\n+  /* We've read all we need from the executable.  */\n+  if (!backtrace_close (descriptor, error_callback, data))\n+    goto fail;\n+  descriptor = -1;\n+\n+  return 1;\n+\n+ fail:\n+  if (sects_view_valid)\n+    backtrace_release_view (state, &sects_view, error_callback, data);\n+  if (str_view_valid)\n+    backtrace_release_view (state, &str_view, error_callback, data);\n+  if (syms_view_valid)\n+    backtrace_release_view (state, &syms_view, error_callback, data);\n+  if (linenos_view_valid)\n+    backtrace_release_view (state, &linenos_view, error_callback, data);\n+  if (dwarf_view_valid)\n+    backtrace_release_view (state, &dwarf_view, error_callback, data);\n+  if (descriptor != -1 && offset == 0)\n+    backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+#ifdef HAVE_LOADQUERY\n+\n+/* Read an integer value in human-readable format from an AIX\n+   big archive fixed-length or member header.  */\n+\n+static int\n+xcoff_parse_decimal (const char *buf, size_t size, off_t *off)\n+{\n+  char str[32];\n+  char *end;\n+\n+  if (size >= sizeof str)\n+    return 0;\n+  memcpy (str, buf, size);\n+  str[size] = '\\0';\n+  *off = strtol (str, &end, 10);\n+  if (*end != '\\0' && *end != ' ')\n+    return 0;\n+\n+  return 1;\n+}\n+\n+/* Add the backtrace data for a member of an AIX big archive.\n+   Returns 1 on success, 0 on failure.  */\n+\n+static int\n+xcoff_armem_add (struct backtrace_state *state, int descriptor,\n+\t\t uintptr_t base_address, const char *member,\n+\t\t backtrace_error_callback error_callback, void *data,\n+\t\t fileline *fileline_fn, int *found_sym)\n+{\n+  struct backtrace_view view;\n+  b_ar_fl_hdr fl_hdr;\n+  const b_ar_hdr *ar_hdr;\n+  off_t off;\n+  off_t len;\n+  int memlen;\n+\n+  *found_sym = 0;\n+\n+  /* Map archive fixed-length header.  */\n+\n+  if (!backtrace_get_view (state, descriptor, 0, sizeof (b_ar_fl_hdr),\n+\t\t\t   error_callback, data, &view))\n+    goto fail;\n+\n+  memcpy (&fl_hdr, view.data, sizeof (b_ar_fl_hdr));\n+\n+  backtrace_release_view (state, &view, error_callback, data);\n+\n+  if (memcmp (fl_hdr.fl_magic, AIAMAGBIG, 8) != 0)\n+    goto fail;\n+\n+  memlen = strlen (member);\n+\n+  /* Read offset of first archive member.  */\n+  if (!xcoff_parse_decimal (fl_hdr.fl_fstmoff, sizeof fl_hdr.fl_fstmoff, &off))\n+    goto fail;\n+  while (off != 0)\n+    {\n+      /* Map archive member header and member name.  */\n+\n+      if (!backtrace_get_view (state, descriptor, off,\n+\t\t\t       sizeof (b_ar_hdr) + memlen,\n+\t\t\t       error_callback, data, &view))\n+\tbreak;\n+\n+      ar_hdr = (const b_ar_hdr *) view.data;\n+\n+      /* Read archive member name length.  */\n+      if (!xcoff_parse_decimal (ar_hdr->ar_namlen, sizeof ar_hdr->ar_namlen,\n+\t\t\t\t&len))\n+\t{\n+\t  backtrace_release_view (state, &view, error_callback, data);\n+\t  break;\n+\t}\n+      if (len == memlen && !memcmp (ar_hdr->ar_name, member, memlen))\n+\t{\n+\t  off = (off + sizeof (b_ar_hdr) + memlen + 1) & ~1;\n+\n+\t  /* The archive can contain several members with the same name\n+\t     (e.g. 32-bit and 64-bit), so continue if not ok.  */\n+\n+\t  if (xcoff_add (state, descriptor, off, base_address, error_callback,\n+\t\t\t data, fileline_fn, found_sym, 0))\n+\t    {\n+\t      backtrace_release_view (state, &view, error_callback, data);\n+\t      return 1;\n+\t    }\n+\t}\n+\n+      /* Read offset of next archive member.  */\n+      if (!xcoff_parse_decimal (ar_hdr->ar_nxtmem, sizeof ar_hdr->ar_nxtmem,\n+\t\t\t\t&off))\n+\t{\n+\t  backtrace_release_view (state, &view, error_callback, data);\n+\t  break;\n+\t}\n+      backtrace_release_view (state, &view, error_callback, data);\n+    }\n+\n+ fail:\n+  /* No matching member found.  */\n+  backtrace_close (descriptor, error_callback, data);\n+  return 0;\n+}\n+\n+/* Add the backtrace data for dynamically loaded libraries.  */\n+\n+static void\n+xcoff_add_shared_libs (struct backtrace_state *state,\n+\t\t       backtrace_error_callback error_callback,\n+\t\t       void *data, fileline *fileline_fn, int *found_sym)\n+{\n+  const struct ld_info *ldinfo;\n+  void *buf;\n+  unsigned int buflen;\n+  const char *member;\n+  int descriptor;\n+  int does_not_exist;\n+  int lib_found_sym;\n+  int ret;\n+\n+  /* Retrieve the list of loaded libraries.  */\n+\n+  buf = NULL;\n+  buflen = 512;\n+  do\n+    {\n+      buf = realloc (buf, buflen);\n+      if (buf == NULL)\n+\t{\n+\t  ret = -1;\n+\t  break;\n+\t}\n+      ret = loadquery (L_GETINFO, buf, buflen);\n+      if (ret == 0)\n+\tbreak;\n+      buflen *= 2;\n+    }\n+  while (ret == -1 && errno == ENOMEM);\n+  if (ret != 0)\n+    {\n+      free (buf);\n+      return;\n+    }\n+\n+  ldinfo = (const struct ld_info *) buf;\n+  while ((const char *) ldinfo < (const char *) buf + buflen)\n+    {\n+      if (*ldinfo->ldinfo_filename != '/')\n+\tgoto next;\n+\n+      descriptor = backtrace_open (ldinfo->ldinfo_filename, error_callback,\n+\t\t\t\t   data, &does_not_exist);\n+      if (descriptor < 0)\n+\tgoto next;\n+\n+      /* Check if it is an archive (member name not empty).  */\n+\n+      member = ldinfo->ldinfo_filename + strlen (ldinfo->ldinfo_filename) + 1;\n+      if (*member)\n+\t{\n+\t  xcoff_armem_add (state, descriptor,\n+\t\t\t   (uintptr_t) ldinfo->ldinfo_textorg, member,\n+\t\t\t   error_callback, data, fileline_fn, &lib_found_sym);\n+\t}\n+      else\n+\t{\n+\t  xcoff_add (state, descriptor, 0, (uintptr_t) ldinfo->ldinfo_textorg,\n+\t\t     error_callback, data, fileline_fn, &lib_found_sym, 0);\n+\t}\n+      if (lib_found_sym)\n+\t*found_sym = 1;\n+\n+ next:\n+      if (ldinfo->ldinfo_next == 0)\n+\tbreak;\n+      ldinfo = (const struct ld_info *) ((const char *) ldinfo\n+\t\t\t\t\t + ldinfo->ldinfo_next);\n+    }\n+\n+    free (buf);\n+}\n+#endif /* HAVE_LOADQUERY */\n+\n+/* Initialize the backtrace data we need from an XCOFF executable.\n+   Returns 1 on success, 0 on failure.  */\n+\n+int\n+backtrace_initialize (struct backtrace_state *state,\n+\t\t      const char *filename ATTRIBUTE_UNUSED, int descriptor,\n+\t\t      backtrace_error_callback error_callback,\n+\t\t      void *data, fileline *fileline_fn)\n+{\n+  int ret;\n+  int found_sym;\n+  fileline xcoff_fileline_fn = xcoff_nodebug;\n+\n+  ret = xcoff_add (state, descriptor, 0, 0, error_callback, data,\n+\t\t   &xcoff_fileline_fn, &found_sym, 1);\n+  if (!ret)\n+    return 0;\n+\n+#ifdef HAVE_LOADQUERY\n+  xcoff_add_shared_libs (state, error_callback, data, &xcoff_fileline_fn,\n+\t\t\t &found_sym);\n+#endif\n+\n+  if (!state->threaded)\n+    {\n+      if (found_sym)\n+\tstate->syminfo_fn = xcoff_syminfo;\n+      else if (state->syminfo_fn == NULL)\n+\tstate->syminfo_fn = xcoff_nosyms;\n+    }\n+  else\n+    {\n+      if (found_sym)\n+\tbacktrace_atomic_store_pointer (&state->syminfo_fn, xcoff_syminfo);\n+      else\n+\t(void) __sync_bool_compare_and_swap (&state->syminfo_fn, NULL,\n+\t\t\t\t\t     xcoff_nosyms);\n+    }\n+\n+  if (!state->threaded)\n+    {\n+      if (state->fileline_fn == NULL || state->fileline_fn == xcoff_nodebug)\n+\t*fileline_fn = xcoff_fileline_fn;\n+    }\n+  else\n+    {\n+      fileline current_fn;\n+\n+      current_fn = backtrace_atomic_load_pointer (&state->fileline_fn);\n+      if (current_fn == NULL || current_fn == xcoff_nodebug)\n+\t*fileline_fn = xcoff_fileline_fn;\n+    }\n+\n+  return 1;\n+}"
    },
    {
      "sha": "b2533cb180457aa73eb533c49c6b8e35dbf7a46a",
      "filename": "libbacktrace/xztest.c",
      "status": "added",
      "additions": 508,
      "deletions": 0,
      "changes": 508,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/xztest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/xztest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/xztest.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,508 @@\n+/* xztest.c -- Test for libbacktrace LZMA decoder.\n+   Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <limits.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#ifdef HAVE_LIBLZMA\n+#include <lzma.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"internal.h\"\n+#include \"testlib.h\"\n+\n+#ifndef HAVE_CLOCK_GETTIME\n+\n+typedef int xclockid_t;\n+\n+static int\n+xclock_gettime (xclockid_t id ATTRIBUTE_UNUSED,\n+\t\tstruct timespec *ts ATTRIBUTE_UNUSED)\n+{\n+  errno = EINVAL;\n+  return -1;\n+}\n+\n+#define clockid_t xclockid_t\n+#define clock_gettime xclock_gettime\n+#undef CLOCK_REALTIME\n+#define CLOCK_REALTIME 0\n+\n+#endif /* !defined(HAVE_CLOCK_GETTIME) */\n+\n+#ifdef CLOCK_PROCESS_CPUTIME_ID\n+#define LIBLZMA_CLOCK_GETTIME_ARG CLOCK_PROCESS_CPUTIME_ID\n+#else\n+#define LIBLZMA_CLOCK_GETTIME_ARG CLOCK_REALTIME\n+#endif\n+\n+/* Some tests for the local lzma inflation code.  */\n+\n+struct lzma_test\n+{\n+  const char *name;\n+  const char *uncompressed;\n+  size_t uncompressed_len;\n+  const char *compressed;\n+  size_t compressed_len;\n+};\n+\n+/* Error callback.  */\n+\n+static void\n+error_callback_compress (void *vdata ATTRIBUTE_UNUSED, const char *msg,\n+\t\t\t int errnum)\n+{\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}\n+\n+static const struct lzma_test tests[] =\n+{\n+  {\n+    \"empty\",\n+    \"\",\n+    0,\n+    (\"\\xfd\\x37\\x7a\\x58\\x5a\\x00\\x00\\x04\\xe6\\xd6\\xb4\\x46\\x00\\x00\\x00\\x00\"\n+     \"\\x1c\\xdf\\x44\\x21\\x1f\\xb6\\xf3\\x7d\\x01\\x00\\x00\\x00\\x00\\x04\\x59\\x5a\"),\n+    32,\n+  },\n+  {\n+    \"hello\",\n+    \"hello, world\\n\",\n+    0,\n+    (\"\\xfd\\x37\\x7a\\x58\\x5a\\x00\\x00\\x04\\xe6\\xd6\\xb4\\x46\\x02\\x00\\x21\\x01\"\n+     \"\\x16\\x00\\x00\\x00\\x74\\x2f\\xe5\\xa3\\x01\\x00\\x0c\\x68\\x65\\x6c\\x6c\\x6f\"\n+     \"\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x0a\\x00\\x00\\x00\\x00\\x7b\\x46\\x5a\\x81\"\n+     \"\\xc9\\x12\\xb8\\xea\\x00\\x01\\x25\\x0d\\x71\\x19\\xc4\\xb6\\x1f\\xb6\\xf3\\x7d\"\n+     \"\\x01\\x00\\x00\\x00\\x00\\x04\\x59\\x5a\"),\n+    72,\n+  },\n+  {\n+    \"goodbye\",\n+    \"goodbye, world\",\n+    0,\n+    (\"\\xfd\\x37\\x7a\\x58\\x5a\\x00\\x00\\x04\\xe6\\xd6\\xb4\\x46\\x02\\x00\\x21\\x01\"\n+     \"\\x16\\x00\\x00\\x00\\x74\\x2f\\xe5\\xa3\\x01\\x00\\x0d\\x67\\x6f\\x6f\\x64\\x62\"\n+     \"\\x79\\x65\\x2c\\x20\\x77\\x6f\\x72\\x6c\\x64\\x00\\x00\\x00\\xf6\\xf8\\xa3\\x33\"\n+     \"\\x8c\\x4e\\xc9\\x68\\x00\\x01\\x26\\x0e\\x08\\x1b\\xe0\\x04\\x1f\\xb6\\xf3\\x7d\"\n+     \"\\x01\\x00\\x00\\x00\\x00\\x04\\x59\\x5a\"),\n+    72,\n+  },\n+};\n+\n+/* Test the hand coded samples.  */\n+\n+static void\n+test_samples (struct backtrace_state *state)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof tests / sizeof tests[0]; ++i)\n+    {\n+      unsigned char *uncompressed;\n+      size_t uncompressed_len;\n+\n+      uncompressed = NULL;\n+      uncompressed_len = 0;\n+      if (!backtrace_uncompress_lzma (state,\n+\t\t\t\t      ((const unsigned char *)\n+\t\t\t\t       tests[i].compressed),\n+\t\t\t\t      tests[i].compressed_len,\n+\t\t\t\t      error_callback_compress, NULL,\n+\t\t\t\t      &uncompressed, &uncompressed_len))\n+\t{\n+\t  fprintf (stderr, \"test %s: uncompress failed\\n\", tests[i].name);\n+\t  ++failures;\n+\t}\n+      else\n+\t{\n+\t  size_t v;\n+\n+\t  v = tests[i].uncompressed_len;\n+\t  if (v == 0)\n+\t    v = strlen (tests[i].uncompressed);\n+\t  if (uncompressed_len != v)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       \"test %s: got uncompressed length %zu, want %zu\\n\",\n+\t\t       tests[i].name, uncompressed_len, v);\n+\t      ++failures;\n+\t    }\n+\t  else if (memcmp (tests[i].uncompressed, uncompressed, v) != 0)\n+\t    {\n+\t      size_t j;\n+\n+\t      fprintf (stderr, \"test %s: uncompressed data mismatch\\n\",\n+\t\t       tests[i].name);\n+\t      for (j = 0; j < v; ++j)\n+\t\tif (tests[i].uncompressed[j] != uncompressed[j])\n+\t\t  fprintf (stderr, \"  %zu: got %#x want %#x\\n\", j,\n+\t\t\t   uncompressed[j], tests[i].uncompressed[j]);\n+\t      ++failures;\n+\t    }\n+\t  else\n+\t    printf (\"PASS: lzma %s\\n\", tests[i].name);\n+\n+\t  backtrace_free (state, uncompressed, uncompressed_len,\n+\t\t\t  error_callback_compress, NULL);\n+\t}\n+    }\n+}\n+\n+#if HAVE_LIBLZMA\n+\n+/* Given a set of TRIALS timings, discard the lowest and highest\n+   values and return the mean average of the rest.  */\n+\n+static size_t\n+average_time (const size_t *times, size_t trials)\n+{\n+  size_t imax;\n+  size_t max;\n+  size_t imin;\n+  size_t min;\n+  size_t i;\n+  size_t sum;\n+\n+  imin = 0;\n+  imax = 0;\n+  min = times[0];\n+  max = times[0];\n+  for (i = 1; i < trials; ++i)\n+    {\n+      if (times[i] < min)\n+\t{\n+\t  imin = i;\n+\t  min = times[i];\n+\t}\n+      if (times[i] > max)\n+\t{\n+\t  imax = i;\n+\t  max = times[i];\n+\t}\n+    }\n+\n+  sum = 0;\n+  for (i = 0; i < trials; ++i)\n+    {\n+      if (i != imax && i != imin)\n+\tsum += times[i];\n+    }\n+  return sum / (trials - 2);\n+}\n+\n+#endif\n+\n+/* Test a larger text, if available.  */\n+\n+static void\n+test_large (struct backtrace_state *state ATTRIBUTE_UNUSED)\n+{\n+#if HAVE_LIBLZMA\n+  unsigned char *orig_buf;\n+  size_t orig_bufsize;\n+  size_t i;\n+  lzma_stream initial_stream = LZMA_STREAM_INIT;\n+  lzma_stream stream;\n+  unsigned char *compressed_buf;\n+  size_t compressed_bufsize;\n+  unsigned char *uncompressed_buf;\n+  size_t uncompressed_bufsize;\n+  unsigned char *spare_buf;\n+  int r;\n+  clockid_t cid;\n+  struct timespec ts1;\n+  struct timespec ts2;\n+  size_t ctime;\n+  size_t ztime;\n+  const size_t trials = 16;\n+  size_t ctimes[16];\n+  size_t ztimes[16];\n+  static const char * const names[] = {\n+    \"Isaac.Newton-Opticks.txt\",\n+    \"../libgo/go/testdata/Isaac.Newton-Opticks.txt\",\n+  };\n+\n+  orig_buf = NULL;\n+  orig_bufsize = 0;\n+  uncompressed_buf = NULL;\n+  compressed_buf = NULL;\n+\n+  for (i = 0; i < sizeof names / sizeof names[0]; ++i)\n+    {\n+      size_t len;\n+      char *namebuf;\n+      FILE *e;\n+      struct stat st;\n+      char *rbuf;\n+      size_t got;\n+\n+      len = strlen (SRCDIR) + strlen (names[i]) + 2;\n+      namebuf = malloc (len);\n+      if (namebuf == NULL)\n+\t{\n+\t  perror (\"malloc\");\n+\t  goto fail;\n+\t}\n+      snprintf (namebuf, len, \"%s/%s\", SRCDIR, names[i]);\n+      e = fopen (namebuf, \"r\");\n+      free (namebuf);\n+      if (e == NULL)\n+\tcontinue;\n+      if (fstat (fileno (e), &st) < 0)\n+\t{\n+\t  perror (\"fstat\");\n+\t  fclose (e);\n+\t  continue;\n+\t}\n+      rbuf = malloc (st.st_size);\n+      if (rbuf == NULL)\n+\t{\n+\t  perror (\"malloc\");\n+\t  goto fail;\n+\t}\n+      got = fread (rbuf, 1, st.st_size, e);\n+      fclose (e);\n+      if (got > 0)\n+\t{\n+\t  orig_buf = (unsigned char *) rbuf;\n+\t  orig_bufsize = got;\n+\t  break;\n+\t}\n+      free (rbuf);\n+    }\n+\n+  if (orig_buf == NULL)\n+    {\n+      /* We couldn't find an input file.  */\n+      printf (\"UNSUPPORTED: lzma large\\n\");\n+      return;\n+    }\n+\n+  stream = initial_stream;\n+  r =  lzma_easy_encoder (&stream, 6, LZMA_CHECK_CRC32);\n+  if (r != LZMA_OK)\n+    {\n+      fprintf (stderr, \"lzma_easy_encoder failed: %d\\n\", r);\n+      goto fail;\n+    }\n+\n+  compressed_bufsize = orig_bufsize + 100;\n+  compressed_buf = malloc (compressed_bufsize);\n+  if (compressed_buf == NULL)\n+    {\n+      perror (\"malloc\");\n+      goto fail;\n+    }\n+\n+  stream.next_in = orig_buf;\n+  stream.avail_in = orig_bufsize;\n+  stream.next_out = compressed_buf;\n+  stream.avail_out = compressed_bufsize;\n+\n+  do\n+    {\n+      r = lzma_code (&stream, LZMA_FINISH);\n+      if (r != LZMA_OK && r != LZMA_STREAM_END)\n+\t{\n+\t  fprintf (stderr, \"lzma_code failed: %d\\n\", r);\n+\t  goto fail;\n+\t}\n+    }\n+  while (r != LZMA_STREAM_END);\n+\n+  compressed_bufsize = stream.total_out;\n+\n+  if (!backtrace_uncompress_lzma (state, (unsigned char *) compressed_buf,\n+\t\t\t\t  compressed_bufsize,\n+\t\t\t\t  error_callback_compress, NULL,\n+\t\t\t\t  &uncompressed_buf, &uncompressed_bufsize))\n+    {\n+      fprintf (stderr, \"lzma large: backtrace_uncompress_lzma failed\\n\");\n+      goto fail;\n+    }\n+\n+  if (uncompressed_bufsize != orig_bufsize)\n+    {\n+      fprintf (stderr,\n+\t       \"lzma large: got uncompressed length %zu, want %zu\\n\",\n+\t       uncompressed_bufsize, orig_bufsize);\n+      goto fail;\n+    }\n+\n+  if (memcmp (uncompressed_buf, orig_buf, uncompressed_bufsize) != 0)\n+    {\n+      fprintf (stderr, \"lzma large: uncompressed data mismatch\\n\");\n+      goto fail;\n+    }\n+\n+  printf (\"PASS: lzma large\\n\");\n+\n+  spare_buf = malloc (orig_bufsize);\n+  if (spare_buf == NULL)\n+    {\n+      perror (\"malloc\");\n+      goto fail;\n+    }\n+\n+  for (i = 0; i < trials; ++i)\n+    {\n+      cid = LIBLZMA_CLOCK_GETTIME_ARG;\n+      if (clock_gettime (cid, &ts1) < 0)\n+\t{\n+\t  if (errno == EINVAL)\n+\t    return;\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      if (!backtrace_uncompress_lzma (state,\n+\t\t\t\t      (unsigned char *) compressed_buf,\n+\t\t\t\t      compressed_bufsize,\n+\t\t\t\t      error_callback_compress, NULL,\n+\t\t\t\t      &uncompressed_buf,\n+\t\t\t\t      &uncompressed_bufsize))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   (\"lzma large: \"\n+\t\t    \"benchmark backtrace_uncompress_lzma failed\\n\"));\n+\t  return;\n+\t}\n+\n+      if (clock_gettime (cid, &ts2) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      ctime = (ts2.tv_sec - ts1.tv_sec) * 1000000000;\n+      ctime += ts2.tv_nsec - ts1.tv_nsec;\n+      ctimes[i] = ctime;\n+\n+      stream = initial_stream;\n+\n+      r = lzma_auto_decoder (&stream, UINT64_MAX, 0);\n+      if (r != LZMA_OK)\n+\t{\n+\t  fprintf (stderr, \"lzma_stream_decoder failed: %d\\n\", r);\n+\t  goto fail;\n+\t}\n+\n+      stream.next_in = compressed_buf;\n+      stream.avail_in = compressed_bufsize;\n+      stream.next_out = spare_buf;\n+      stream.avail_out = orig_bufsize;\n+\n+      if (clock_gettime (cid, &ts1) < 0)\n+\t{\n+\t  perror(\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      do\n+\t{\n+\t  r = lzma_code (&stream, LZMA_FINISH);\n+\t  if (r != LZMA_OK && r != LZMA_STREAM_END)\n+\t    {\n+\t      fprintf (stderr, \"lzma_code failed: %d\\n\", r);\n+\t      goto fail;\n+\t    }\n+\t}\n+      while (r != LZMA_STREAM_END);\n+\n+      if (clock_gettime (cid, &ts2) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      ztime = (ts2.tv_sec - ts1.tv_sec) * 1000000000;\n+      ztime += ts2.tv_nsec - ts1.tv_nsec;\n+      ztimes[i] = ztime;\n+    }\n+\n+  /* Toss the highest and lowest times and average the rest.  */\n+  ctime = average_time (ctimes, trials);\n+  ztime = average_time (ztimes, trials);\n+\n+  printf (\"backtrace: %zu ns\\n\", ctime);\n+  printf (\"liblzma  : %zu ns\\n\", ztime);\n+  printf (\"ratio    : %g\\n\", (double) ztime / (double) ctime);\n+\n+  return;\n+\n+ fail:\n+  printf (\"FAIL: lzma large\\n\");\n+  ++failures;\n+\n+  if (orig_buf != NULL)\n+    free (orig_buf);\n+  if (compressed_buf != NULL)\n+    free (compressed_buf);\n+  if (uncompressed_buf != NULL)\n+    free (uncompressed_buf);\n+\n+#else /* !HAVE_LIBLZMA */\n+\n+ printf (\"UNSUPPORTED: lzma large\\n\");\n+\n+#endif /* !HAVE_LIBLZMA */\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  struct backtrace_state *state;\n+\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+  test_samples (state);\n+  test_large (state);\n+\n+  exit (failures != 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    },
    {
      "sha": "4e79c09517d2a14f81a76bb53f265dcd2f431580",
      "filename": "libbacktrace/ztest.c",
      "status": "added",
      "additions": 541,
      "deletions": 0,
      "changes": 541,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/ztest.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63a4b10683992ae6ae2d93711369bc10df8fbce9/libbacktrace/ztest.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libbacktrace/ztest.c?ref=63a4b10683992ae6ae2d93711369bc10df8fbce9",
      "patch": "@@ -0,0 +1,541 @@\n+/* ztest.c -- Test for libbacktrace inflate code.\n+   Copyright (C) 2017-2021 Free Software Foundation, Inc.\n+   Written by Ian Lance Taylor, Google.\n+\n+Redistribution and use in source and binary forms, with or without\n+modification, are permitted provided that the following conditions are\n+met:\n+\n+    (1) Redistributions of source code must retain the above copyright\n+    notice, this list of conditions and the following disclaimer.\n+\n+    (2) Redistributions in binary form must reproduce the above copyright\n+    notice, this list of conditions and the following disclaimer in\n+    the documentation and/or other materials provided with the\n+    distribution.\n+\n+    (3) The name of the author may not be used to\n+    endorse or promote products derived from this software without\n+    specific prior written permission.\n+\n+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n+INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n+STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n+IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+POSSIBILITY OF SUCH DAMAGE.  */\n+\n+#include \"config.h\"\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <time.h>\n+#include <sys/types.h>\n+#include <sys/stat.h>\n+\n+#ifdef HAVE_ZLIB\n+#include <zlib.h>\n+#endif\n+\n+#include \"backtrace.h\"\n+#include \"backtrace-supported.h\"\n+\n+#include \"internal.h\"\n+#include \"testlib.h\"\n+\n+#ifndef HAVE_CLOCK_GETTIME\n+\n+typedef int xclockid_t;\n+\n+static int\n+xclock_gettime (xclockid_t id ATTRIBUTE_UNUSED,\n+\t\tstruct timespec *ts ATTRIBUTE_UNUSED)\n+{\n+  errno = EINVAL;\n+  return -1;\n+}\n+\n+#define clockid_t xclockid_t\n+#define clock_gettime xclock_gettime\n+#undef CLOCK_REALTIME\n+#define CLOCK_REALTIME 0\n+\n+#endif /* !defined(HAVE_CLOCK_GETTIME) */\n+\n+#ifdef CLOCK_PROCESS_CPUTIME_ID\n+#define ZLIB_CLOCK_GETTIME_ARG CLOCK_PROCESS_CPUTIME_ID\n+#else\n+#define ZLIB_CLOCK_GETTIME_ARG CLOCK_REALTIME\n+#endif\n+\n+/* Some tests for the local zlib inflation code.  */\n+\n+struct zlib_test\n+{\n+  const char *name;\n+  const char *uncompressed;\n+  size_t uncompressed_len;\n+  const char *compressed;\n+  size_t compressed_len;\n+};\n+\n+/* Error callback.  */\n+\n+static void\n+error_callback_compress (void *vdata ATTRIBUTE_UNUSED, const char *msg,\n+\t\t\t int errnum)\n+{\n+  fprintf (stderr, \"%s\", msg);\n+  if (errnum > 0)\n+    fprintf (stderr, \": %s\", strerror (errnum));\n+  fprintf (stderr, \"\\n\");\n+  exit (EXIT_FAILURE);\n+}\n+\n+static const struct zlib_test tests[] =\n+{\n+  {\n+    \"empty\",\n+    \"\",\n+    0,\n+    \"\\x78\\x9c\\x03\\x00\\x00\\x00\\x00\\x01\",\n+    8,\n+  },\n+  {\n+    \"hello\",\n+    \"hello, world\\n\",\n+    0,\n+    (\"\\x78\\x9c\\xca\\x48\\xcd\\xc9\\xc9\\xd7\\x51\\x28\\xcf\"\n+     \"\\x2f\\xca\\x49\\xe1\\x02\\x04\\x00\\x00\\xff\\xff\\x21\\xe7\\x04\\x93\"),\n+    25,\n+  },\n+  {\n+    \"goodbye\",\n+    \"goodbye, world\",\n+    0,\n+    (\"\\x78\\x9c\\x4b\\xcf\\xcf\\x4f\\x49\\xaa\"\n+     \"\\x4c\\xd5\\x51\\x28\\xcf\\x2f\\xca\\x49\"\n+     \"\\x01\\x00\\x28\\xa5\\x05\\x5e\"),\n+    22,\n+  },\n+  {\n+    \"ranges\",\n+    (\"\\xcc\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\xd5\\x13\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x1c\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x72\\x14\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x9d\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\xd5\\x14\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xfb\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x13\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x0c\\x13\\x00\\x00\\x00\\x00\\x00\\x00\\xcb\\x13\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x29\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\x4e\\x14\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x9d\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\xd5\\x14\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xfb\\x12\\x00\\x00\\x00\\x00\\x00\\x00\\x09\\x13\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x67\\x13\\x00\\x00\\x00\\x00\\x00\\x00\\xcb\\x13\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x9d\\x14\\x00\\x00\\x00\\x00\\x00\\x00\\xd5\\x14\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x5f\\x0b\\x00\\x00\\x00\\x00\\x00\\x00\\x6c\\x0b\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x7d\\x0b\\x00\\x00\\x00\\x00\\x00\\x00\\x7e\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x38\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x5c\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x83\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\xfa\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xfd\\x0d\\x00\\x00\\x00\\x00\\x00\\x00\\xef\\x0e\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x14\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x38\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x9f\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xdb\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xfd\\x0d\\x00\\x00\\x00\\x00\\x00\\x00\\xd8\\x0e\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x9f\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\xac\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xdb\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xfa\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\xea\\x0d\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xef\\x0e\\x00\\x00\\x00\\x00\\x00\\x00\\x14\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x5c\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x9f\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xac\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\xdb\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\xff\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x2c\\x10\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x60\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\xd1\\x16\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x40\\x0b\\x00\\x00\\x00\\x00\\x00\\x00\\x2c\\x10\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x7a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xb6\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x9f\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\xa7\\x01\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x7a\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x9f\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\xa7\\x01\\x00\\x00\\x00\\x00\\x00\\x00\"\n+     \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"),\n+    672,\n+    (\"\\x78\\x9c\\x3b\\x23\\xc8\\x00\\x06\\x57\\x85\\x21\\xb4\\x8c\\x08\\x84\\x2e\\x82\"\n+     \"\\xd2\\x73\\xa1\\xf4\\x55\\x28\\x8d\\x0e\\x7e\\x0b\\x41\\x68\\x4e\\xa8\\x7e\\x1e\"\n+     \"\\x28\\x7d\\x1a\\x4a\\x6b\\x42\\xf5\\xf9\\x91\\x69\\x5e\\x3a\\x9a\\x79\\x84\\xf4\"\n+     \"\\xc7\\x73\\x43\\xe8\\x1c\\x28\\x5d\\x0b\\xa5\\xeb\\x78\\x20\\xb4\\x05\\x3f\\x84\"\n+     \"\\x8e\\xe1\\xc7\\xae\\xbf\\x19\\xaa\\xee\\x17\\x94\\xfe\\xcb\\x0b\\xa1\\xdf\\xf3\"\n+     \"\\x41\\x68\\x11\\x7e\\x54\\x73\\xe6\\x43\\xe9\\x35\\x50\\xfa\\x36\\x94\\xfe\\x8f\"\n+     \"\\xc3\\x7c\\x98\\x79\\x37\\xf8\\xc8\\xd3\\x0f\\x73\\xd7\\x2b\\x1c\\xee\\x8a\\x21\"\n+     \"\\xd2\\x5d\\x3a\\x02\\xd8\\xcd\\x4f\\x80\\xa6\\x87\\x8b\\x62\\x10\\xda\\x81\\x1b\"\n+     \"\\xbf\\xfa\\x2a\\x28\\xbd\\x0d\\x4a\\xcf\\x67\\x84\\xd0\\xcb\\x19\\xf1\\xab\\x5f\"\n+     \"\\x49\\xa4\\x7a\\x00\\x48\\x97\\x29\\xd4\"),\n+    152,\n+  }\n+};\n+\n+/* Test the hand coded samples.  */\n+\n+static void\n+test_samples (struct backtrace_state *state)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < sizeof tests / sizeof tests[0]; ++i)\n+    {\n+      char *p;\n+      size_t v;\n+      size_t j;\n+      unsigned char *uncompressed;\n+      size_t uncompressed_len;\n+\n+      p = malloc (12 + tests[i].compressed_len);\n+      memcpy (p, \"ZLIB\", 4);\n+      v = tests[i].uncompressed_len;\n+      if (v == 0)\n+\tv = strlen (tests[i].uncompressed);\n+      for (j = 0; j < 8; ++j)\n+\tp[j + 4] = (v >> ((7 - j) * 8)) & 0xff;\n+      memcpy (p + 12, tests[i].compressed, tests[i].compressed_len);\n+      uncompressed = NULL;\n+      uncompressed_len = 0;\n+      if (!backtrace_uncompress_zdebug (state, (unsigned char *) p,\n+\t\t\t\t\ttests[i].compressed_len + 12,\n+\t\t\t\t\terror_callback_compress, NULL,\n+\t\t\t\t\t&uncompressed, &uncompressed_len))\n+\t{\n+\t  fprintf (stderr, \"test %s: uncompress failed\\n\", tests[i].name);\n+\t  ++failures;\n+\t}\n+      else\n+\t{\n+\t  if (uncompressed_len != v)\n+\t    {\n+\t      fprintf (stderr,\n+\t\t       \"test %s: got uncompressed length %zu, want %zu\\n\",\n+\t\t       tests[i].name, uncompressed_len, v);\n+\t      ++failures;\n+\t    }\n+\t  else if (memcmp (tests[i].uncompressed, uncompressed, v) != 0)\n+\t    {\n+\t      size_t j;\n+\n+\t      fprintf (stderr, \"test %s: uncompressed data mismatch\\n\",\n+\t\t       tests[i].name);\n+\t      for (j = 0; j < v; ++j)\n+\t\tif (tests[i].uncompressed[j] != uncompressed[j])\n+\t\t  fprintf (stderr, \"  %zu: got %#x want %#x\\n\", j,\n+\t\t\t   uncompressed[j], tests[i].uncompressed[j]);\n+\t      ++failures;\n+\t    }\n+\t  else\n+\t    printf (\"PASS: inflate %s\\n\", tests[i].name);\n+\n+\t  backtrace_free (state, uncompressed, uncompressed_len,\n+\t\t\t  error_callback_compress, NULL);\n+\t}\n+    }\n+}\n+\n+#ifdef HAVE_ZLIB\n+\n+/* Given a set of TRIALS timings, discard the lowest and highest\n+   values and return the mean average of the rest.  */\n+\n+static size_t\n+average_time (const size_t *times, size_t trials)\n+{\n+  size_t imax;\n+  size_t max;\n+  size_t imin;\n+  size_t min;\n+  size_t i;\n+  size_t sum;\n+\n+  imin = 0;\n+  imax = 0;\n+  min = times[0];\n+  max = times[0];\n+  for (i = 1; i < trials; ++i)\n+    {\n+      if (times[i] < min)\n+\t{\n+\t  imin = i;\n+\t  min = times[i];\n+\t}\n+      if (times[i] > max)\n+\t{\n+\t  imax = i;\n+\t  max = times[i];\n+\t}\n+    }\n+\n+  sum = 0;\n+  for (i = 0; i < trials; ++i)\n+    {\n+      if (i != imax && i != imin)\n+\tsum += times[i];\n+    }\n+  return sum / (trials - 2);\n+}\n+\n+#endif\n+\n+/* Test a larger text, if available.  */\n+\n+static void\n+test_large (struct backtrace_state *state ATTRIBUTE_UNUSED)\n+{\n+#ifdef HAVE_ZLIB\n+  unsigned char *orig_buf;\n+  size_t orig_bufsize;\n+  size_t i;\n+  char *compressed_buf;\n+  size_t compressed_bufsize;\n+  unsigned long compress_sizearg;\n+  unsigned char *uncompressed_buf;\n+  size_t uncompressed_bufsize;\n+  int r;\n+  clockid_t cid;\n+  struct timespec ts1;\n+  struct timespec ts2;\n+  size_t ctime;\n+  size_t ztime;\n+  const size_t trials = 16;\n+  size_t ctimes[16];\n+  size_t ztimes[16];\n+  static const char * const names[] = {\n+    \"Isaac.Newton-Opticks.txt\",\n+    \"../libgo/go/testdata/Isaac.Newton-Opticks.txt\",\n+  };\n+\n+  orig_buf = NULL;\n+  orig_bufsize = 0;\n+  uncompressed_buf = NULL;\n+  compressed_buf = NULL;\n+\n+  for (i = 0; i < sizeof names / sizeof names[0]; ++i)\n+    {\n+      size_t len;\n+      char *namebuf;\n+      FILE *e;\n+      struct stat st;\n+      char *rbuf;\n+      size_t got;\n+\n+      len = strlen (SRCDIR) + strlen (names[i]) + 2;\n+      namebuf = malloc (len);\n+      if (namebuf == NULL)\n+\t{\n+\t  perror (\"malloc\");\n+\t  goto fail;\n+\t}\n+      snprintf (namebuf, len, \"%s/%s\", SRCDIR, names[i]);\n+      e = fopen (namebuf, \"r\");\n+      free (namebuf);\n+      if (e == NULL)\n+\tcontinue;\n+      if (fstat (fileno (e), &st) < 0)\n+\t{\n+\t  perror (\"fstat\");\n+\t  fclose (e);\n+\t  continue;\n+\t}\n+      rbuf = malloc (st.st_size);\n+      if (rbuf == NULL)\n+\t{\n+\t  perror (\"malloc\");\n+\t  goto fail;\n+\t}\n+      got = fread (rbuf, 1, st.st_size, e);\n+      fclose (e);\n+      if (got > 0)\n+\t{\n+\t  orig_buf = (unsigned char *) rbuf;\n+\t  orig_bufsize = got;\n+\t  break;\n+\t}\n+      free (rbuf);\n+    }\n+\n+  if (orig_buf == NULL)\n+    {\n+      /* We couldn't find an input file.  */\n+      printf (\"UNSUPPORTED: inflate large\\n\");\n+      return;\n+    }\n+\n+  compressed_bufsize = compressBound (orig_bufsize) + 12;\n+  compressed_buf = malloc (compressed_bufsize);\n+  if (compressed_buf == NULL)\n+    {\n+      perror (\"malloc\");\n+      goto fail;\n+    }\n+\n+  compress_sizearg = compressed_bufsize - 12;\n+  r = compress ((unsigned char *) compressed_buf + 12, &compress_sizearg,\n+\t\torig_buf, orig_bufsize);\n+  if (r != Z_OK)\n+    {\n+      fprintf (stderr, \"zlib compress failed: %d\\n\", r);\n+      goto fail;\n+    }\n+\n+  compressed_bufsize = compress_sizearg + 12;\n+\n+  /* Prepare the header that our library expects.  */\n+  memcpy (compressed_buf, \"ZLIB\", 4);\n+  for (i = 0; i < 8; ++i)\n+    compressed_buf[i + 4] = (orig_bufsize >> ((7 - i) * 8)) & 0xff;\n+\n+  uncompressed_buf = malloc (orig_bufsize);\n+  if (uncompressed_buf == NULL)\n+    {\n+      perror (\"malloc\");\n+      goto fail;\n+    }\n+  uncompressed_bufsize = orig_bufsize;\n+\n+  if (!backtrace_uncompress_zdebug (state, (unsigned char *) compressed_buf,\n+\t\t\t\t    compressed_bufsize,\n+\t\t\t\t    error_callback_compress, NULL,\n+\t\t\t\t    &uncompressed_buf, &uncompressed_bufsize))\n+    {\n+      fprintf (stderr, \"inflate large: backtrace_uncompress_zdebug failed\\n\");\n+      goto fail;\n+    }\n+\n+  if (uncompressed_bufsize != orig_bufsize)\n+    {\n+      fprintf (stderr,\n+\t       \"inflate large: got uncompressed length %zu, want %zu\\n\",\n+\t       uncompressed_bufsize, orig_bufsize);\n+      goto fail;\n+    }\n+\n+  if (memcmp (uncompressed_buf, orig_buf, uncompressed_bufsize) != 0)\n+    {\n+      fprintf (stderr, \"inflate large: uncompressed data mismatch\\n\");\n+      goto fail;\n+    }\n+\n+  printf (\"PASS: inflate large\\n\");\n+\n+  for (i = 0; i < trials; ++i)\n+    {\n+      unsigned long uncompress_sizearg;\n+\n+      cid = ZLIB_CLOCK_GETTIME_ARG;\n+      if (clock_gettime (cid, &ts1) < 0)\n+\t{\n+\t  if (errno == EINVAL)\n+\t    return;\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      if (!backtrace_uncompress_zdebug (state,\n+\t\t\t\t\t(unsigned char *) compressed_buf,\n+\t\t\t\t\tcompressed_bufsize,\n+\t\t\t\t\terror_callback_compress, NULL,\n+\t\t\t\t\t&uncompressed_buf,\n+\t\t\t\t\t&uncompressed_bufsize))\n+\t{\n+\t  fprintf (stderr,\n+\t\t   (\"inflate large: \"\n+\t\t    \"benchmark backtrace_uncompress_zdebug failed\\n\"));\n+\t  return;\n+\t}\n+\n+      if (clock_gettime (cid, &ts2) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      ctime = (ts2.tv_sec - ts1.tv_sec) * 1000000000;\n+      ctime += ts2.tv_nsec - ts1.tv_nsec;\n+      ctimes[i] = ctime;\n+\n+      if (clock_gettime (cid, &ts1) < 0)\n+\t{\n+\t  perror(\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      uncompress_sizearg = uncompressed_bufsize;\n+      r = uncompress ((unsigned char *) uncompressed_buf, &uncompress_sizearg,\n+\t\t      (unsigned char *) compressed_buf + 12,\n+\t\t      compressed_bufsize - 12);\n+\n+      if (clock_gettime (cid, &ts2) < 0)\n+\t{\n+\t  perror (\"clock_gettime\");\n+\t  return;\n+\t}\n+\n+      if (r != Z_OK)\n+\t{\n+\t  fprintf (stderr,\n+\t\t   \"inflate large: benchmark zlib uncompress failed: %d\\n\",\n+\t\t   r);\n+\t  return;\n+\t}\n+\n+      ztime = (ts2.tv_sec - ts1.tv_sec) * 1000000000;\n+      ztime += ts2.tv_nsec - ts1.tv_nsec;\n+      ztimes[i] = ztime;\n+    }\n+\n+  /* Toss the highest and lowest times and average the rest.  */\n+  ctime = average_time (ctimes, trials);\n+  ztime = average_time (ztimes, trials);\n+\n+  printf (\"backtrace: %zu ns\\n\", ctime);\n+  printf (\"zlib     : %zu ns\\n\", ztime);\n+  printf (\"ratio    : %g\\n\", (double) ztime / (double) ctime);\n+\n+  return;\n+\n+ fail:\n+  printf (\"FAIL: inflate large\\n\");\n+  ++failures;\n+\n+  if (orig_buf != NULL)\n+    free (orig_buf);\n+  if (compressed_buf != NULL)\n+    free (compressed_buf);\n+  if (uncompressed_buf != NULL)\n+    free (uncompressed_buf);\n+\n+#else /* !HAVE_ZLIB */\n+\n+ printf (\"UNSUPPORTED: inflate large\\n\");\n+\n+#endif /* !HAVE_ZLIB */\n+}\n+\n+int\n+main (int argc ATTRIBUTE_UNUSED, char **argv)\n+{\n+  struct backtrace_state *state;\n+\n+  state = backtrace_create_state (argv[0], BACKTRACE_SUPPORTS_THREADS,\n+\t\t\t\t  error_callback_create, NULL);\n+\n+  test_samples (state);\n+  test_large (state);\n+\n+  exit (failures != 0 ? EXIT_FAILURE : EXIT_SUCCESS);\n+}"
    }
  ]
}