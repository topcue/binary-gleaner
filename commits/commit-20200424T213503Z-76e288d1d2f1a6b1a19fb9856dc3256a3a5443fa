{
  "sha": "76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzZlMjg4ZDFkMmYxYTZiMWExOWZiOTg1NmRjMzI1NmEzYTU0NDNmYQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-04-24T21:35:01Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-24T21:35:03Z"
    },
    "message": "Use the new add_psymbol_to_list overload\n\nThis changes the DWARF reader to use the new add_psymbol_to_list\noverload.  There should be no visible changes due to this patch.\n\ngdb/ChangeLog\n2020-04-24  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.c (add_partial_symbol): Use new add_psymbol_to_list\n\toverload.",
    "tree": {
      "sha": "8f5638aae95f881bea0a282ad12146bf593e9f03",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8f5638aae95f881bea0a282ad12146bf593e9f03"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2467f4f6a533a28047e0b45ce716b9b1f9f72a09",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2467f4f6a533a28047e0b45ce716b9b1f9f72a09",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2467f4f6a533a28047e0b45ce716b9b1f9f72a09"
    }
  ],
  "stats": {
    "total": 132,
    "additions": 68,
    "deletions": 64
  },
  "files": [
    {
      "sha": "bf96cfec4e397e407a5864abfcc74f5c67df6b7d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa",
      "patch": "@@ -1,3 +1,8 @@\n+2020-04-24  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.c (add_partial_symbol): Use new add_psymbol_to_list\n+\toverload.\n+\n 2020-04-24  Tom Tromey  <tom@tromey.com>\n \n \t* psymtab.c (add_psymbol_to_bcache): Simplify calling convention."
    },
    {
      "sha": "ddf4b5b1e2842d612c49480a39104e8242194c52",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 63,
      "deletions": 64,
      "changes": 127,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=76e288d1d2f1a6b1a19fb9856dc3256a3a5443fa",
      "patch": "@@ -8219,6 +8219,15 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n   if (actual_name == NULL)\n     actual_name = pdi->name;\n \n+  partial_symbol psymbol;\n+  memset (&psymbol, 0, sizeof (psymbol));\n+  psymbol.ginfo.set_language (cu->language, &objfile->objfile_obstack);\n+  psymbol.ginfo.section = -1;\n+\n+  /* The code below indicates that the psymbol should be installed by\n+     setting this.  */\n+  gdb::optional<psymbol_placement> where;\n+\n   switch (pdi->tag)\n     {\n     case DW_TAG_inlined_subroutine:\n@@ -8235,34 +8244,25 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n              But in Ada and Fortran, we want to be able to access nested\n              procedures globally.  So all Ada and Fortran subprograms are\n              stored in the global scope.  */\n-\t  add_psymbol_to_list (actual_name,\n-\t\t\t       built_actual_name != NULL,\n-\t\t\t       VAR_DOMAIN, LOC_BLOCK,\n-\t\t\t       SECT_OFF_TEXT (objfile),\n-\t\t\t       psymbol_placement::GLOBAL,\n-\t\t\t       addr,\n-\t\t\t       cu->language, objfile);\n+\t  where = psymbol_placement::GLOBAL;\n \t}\n       else\n-\t{\n-\t  add_psymbol_to_list (actual_name,\n-\t\t\t       built_actual_name != NULL,\n-\t\t\t       VAR_DOMAIN, LOC_BLOCK,\n-\t\t\t       SECT_OFF_TEXT (objfile),\n-\t\t\t       psymbol_placement::STATIC,\n-\t\t\t       addr, cu->language, objfile);\n-\t}\n+\twhere = psymbol_placement::STATIC;\n+\n+      psymbol.domain = VAR_DOMAIN;\n+      psymbol.aclass = LOC_BLOCK;\n+      psymbol.ginfo.section = SECT_OFF_TEXT (objfile);\n+      psymbol.ginfo.value.address = addr;\n \n       if (pdi->main_subprogram && actual_name != NULL)\n \tset_objfile_main_name (objfile, actual_name, cu->language);\n       break;\n     case DW_TAG_constant:\n-      add_psymbol_to_list (actual_name,\n-\t\t\t   built_actual_name != NULL, VAR_DOMAIN, LOC_STATIC,\n-\t\t\t   -1, (pdi->is_external\n-\t\t\t\t? psymbol_placement::GLOBAL\n-\t\t\t\t: psymbol_placement::STATIC),\n-\t\t\t   0, cu->language, objfile);\n+      psymbol.domain = VAR_DOMAIN;\n+      psymbol.aclass = LOC_STATIC;\n+      where = (pdi->is_external\n+\t       ? psymbol_placement::GLOBAL\n+\t       : psymbol_placement::STATIC);\n       break;\n     case DW_TAG_variable:\n       if (pdi->d.locdesc)\n@@ -8293,12 +8293,13 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n \t     table building.  */\n \n \t  if (pdi->d.locdesc || pdi->has_type)\n-\t    add_psymbol_to_list (actual_name,\n-\t\t\t\t built_actual_name != NULL,\n-\t\t\t\t VAR_DOMAIN, LOC_STATIC,\n-\t\t\t\t SECT_OFF_TEXT (objfile),\n-\t\t\t\t psymbol_placement::GLOBAL,\n-\t\t\t\t addr, cu->language, objfile);\n+\t    {\n+\t      psymbol.domain = VAR_DOMAIN;\n+\t      psymbol.aclass = LOC_STATIC;\n+\t      psymbol.ginfo.section = SECT_OFF_TEXT (objfile);\n+\t      psymbol.ginfo.value.address = addr;\n+\t      where = psymbol_placement::GLOBAL;\n+\t    }\n \t}\n       else\n \t{\n@@ -8309,42 +8310,37 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n \t  if (!has_loc && !pdi->has_const_value)\n \t    return;\n \n-\t  add_psymbol_to_list (actual_name,\n-\t\t\t       built_actual_name != NULL,\n-\t\t\t       VAR_DOMAIN, LOC_STATIC,\n-\t\t\t       SECT_OFF_TEXT (objfile),\n-\t\t\t       psymbol_placement::STATIC,\n-\t\t\t       has_loc ? addr : 0,\n-\t\t\t       cu->language, objfile);\n+\t  psymbol.domain = VAR_DOMAIN;\n+\t  psymbol.aclass = LOC_STATIC;\n+\t  psymbol.ginfo.section = SECT_OFF_TEXT (objfile);\n+\t  if (has_loc)\n+\t    psymbol.ginfo.value.address = addr;\n+\t  where = psymbol_placement::STATIC;\n \t}\n       break;\n     case DW_TAG_typedef:\n     case DW_TAG_base_type:\n     case DW_TAG_subrange_type:\n-      add_psymbol_to_list (actual_name,\n-\t\t\t   built_actual_name != NULL,\n-\t\t\t   VAR_DOMAIN, LOC_TYPEDEF, -1,\n-\t\t\t   psymbol_placement::STATIC,\n-\t\t\t   0, cu->language, objfile);\n+      psymbol.domain = VAR_DOMAIN;\n+      psymbol.aclass = LOC_TYPEDEF;\n+      where = psymbol_placement::STATIC;\n       break;\n     case DW_TAG_imported_declaration:\n     case DW_TAG_namespace:\n-      add_psymbol_to_list (actual_name,\n-\t\t\t   built_actual_name != NULL,\n-\t\t\t   VAR_DOMAIN, LOC_TYPEDEF, -1,\n-\t\t\t   psymbol_placement::GLOBAL,\n-\t\t\t   0, cu->language, objfile);\n+      psymbol.domain = VAR_DOMAIN;\n+      psymbol.aclass = LOC_TYPEDEF;\n+      where = psymbol_placement::GLOBAL;\n       break;\n     case DW_TAG_module:\n       /* With Fortran 77 there might be a \"BLOCK DATA\" module\n          available without any name.  If so, we skip the module as it\n          doesn't bring any value.  */\n       if (actual_name != nullptr)\n-\tadd_psymbol_to_list (actual_name,\n-\t\t\t     built_actual_name != NULL,\n-\t\t\t     MODULE_DOMAIN, LOC_TYPEDEF, -1,\n-\t\t\t     psymbol_placement::GLOBAL,\n-\t\t\t     0, cu->language, objfile);\n+\t{\n+\t  psymbol.domain = MODULE_DOMAIN;\n+\t  psymbol.aclass = LOC_TYPEDEF;\n+\t  where = psymbol_placement::GLOBAL;\n+\t}\n       break;\n     case DW_TAG_class_type:\n     case DW_TAG_interface_type:\n@@ -8361,27 +8357,30 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n \n       /* NOTE: carlton/2003-10-07: See comment in new_symbol about\n \t static vs. global.  */\n-      add_psymbol_to_list (actual_name,\n-\t\t\t   built_actual_name != NULL,\n-\t\t\t   STRUCT_DOMAIN, LOC_TYPEDEF, -1,\n-\t\t\t   cu->language == language_cplus\n-\t\t\t   ? psymbol_placement::GLOBAL\n-\t\t\t   : psymbol_placement::STATIC,\n-\t\t\t   0, cu->language, objfile);\n-\n+      psymbol.domain = STRUCT_DOMAIN;\n+      psymbol.aclass = LOC_TYPEDEF;\n+      where = (cu->language == language_cplus\n+\t       ? psymbol_placement::GLOBAL\n+\t       : psymbol_placement::STATIC);\n       break;\n     case DW_TAG_enumerator:\n-      add_psymbol_to_list (actual_name,\n-\t\t\t   built_actual_name != NULL,\n-\t\t\t   VAR_DOMAIN, LOC_CONST, -1,\n-\t\t\t   cu->language == language_cplus\n-\t\t\t   ? psymbol_placement::GLOBAL\n-\t\t\t   : psymbol_placement::STATIC,\n-\t\t\t   0, cu->language, objfile);\n+      psymbol.domain = VAR_DOMAIN;\n+      psymbol.aclass = LOC_CONST;\n+      where = (cu->language == language_cplus\n+\t       ? psymbol_placement::GLOBAL\n+\t       : psymbol_placement::STATIC);\n       break;\n     default:\n       break;\n     }\n+\n+  if (where.has_value ())\n+    {\n+      psymbol.ginfo.compute_and_set_names (actual_name,\n+\t\t\t\t\t   built_actual_name != nullptr,\n+\t\t\t\t\t   objfile->per_bfd);\n+      add_psymbol_to_list (psymbol, *where, objfile);\n+    }\n }\n \n /* Read a partial die corresponding to a namespace; also, add a symbol"
    }
  ]
}