{
  "sha": "8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGFlNzhhNDQwZTRlMmVhN2VjZGE5YjMzYTZiM2VjNjNiYmNkM2M2NQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-05-17T20:16:06Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-05-17T20:16:06Z"
    },
    "message": "Move dwarf2_cu to new header file\n\nThis moves dwarf2_cu and one supporting data structure to a new header\nfile.  The main goal, as always with this kind of change, is to make\nthe DWARF reader a bit more understandable.\n\ngdb/ChangeLog\n2021-05-17  Tom Tromey  <tom@tromey.com>\n\n\t* Makefile.in (HFILES_NO_SRCDIR): Add dwarf2/cu.h.\n\t* dwarf2/read.c (struct delayed_method_info, struct dwarf2_cu):\n\tMove to cu.h.\n\t* dwarf2/cu.h: New file.",
    "tree": {
      "sha": "a3e6f97b5ac11a1aef94a6177d67338e9a9bc945",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a3e6f97b5ac11a1aef94a6177d67338e9a9bc945"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c1c0a7e1f39fda9f95bb94ecc5f39b189d69a76c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c1c0a7e1f39fda9f95bb94ecc5f39b189d69a76c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c1c0a7e1f39fda9f95bb94ecc5f39b189d69a76c"
    }
  ],
  "stats": {
    "total": 523,
    "additions": 279,
    "deletions": 244
  },
  "files": [
    {
      "sha": "3f44f2150f2ae58ed7bad27dffe3ab3f4ca1a717",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65",
      "patch": "@@ -1,3 +1,10 @@\n+2021-05-17  Tom Tromey  <tom@tromey.com>\n+\n+\t* Makefile.in (HFILES_NO_SRCDIR): Add dwarf2/cu.h.\n+\t* dwarf2/read.c (struct delayed_method_info, struct dwarf2_cu):\n+\tMove to cu.h.\n+\t* dwarf2/cu.h: New file.\n+\n 2021-05-17  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* .dir-locals.el: Set sentence-end-double-space for all modes, and"
    },
    {
      "sha": "4737cc9eecfc9d9e0050c3f51e82a485e60ca04c",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65",
      "patch": "@@ -1272,6 +1272,7 @@ HFILES_NO_SRCDIR = \\\n \tdictionary.h \\\n \tdisasm.h \\\n \tdummy-frame.h \\\n+\tdwarf2/cu.h \\\n \tdwarf2/frame-tailcall.h \\\n \tdwarf2/frame.h \\\n \tdwarf2/expr.h \\"
    },
    {
      "sha": "9fb2d61163a660ace3b4122206ba7a108a3ed47d",
      "filename": "gdb/dwarf2/cu.h",
      "status": "added",
      "additions": 270,
      "deletions": 0,
      "changes": 270,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/gdb/dwarf2/cu.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/gdb/dwarf2/cu.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/cu.h?ref=8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65",
      "patch": "@@ -0,0 +1,270 @@\n+/* DWARF CU data structure\n+\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDB_DWARF2_CU_H\n+#define GDB_DWARF2_CU_H\n+\n+#include \"buildsym.h\"\n+#include \"dwarf2/comp-unit.h\"\n+#include \"gdbsupport/gdb_optional.h\"\n+\n+/* Type used for delaying computation of method physnames.\n+   See comments for compute_delayed_physnames.  */\n+struct delayed_method_info\n+{\n+  /* The type to which the method is attached, i.e., its parent class.  */\n+  struct type *type;\n+\n+  /* The index of the method in the type's function fieldlists.  */\n+  int fnfield_index;\n+\n+  /* The index of the method in the fieldlist.  */\n+  int index;\n+\n+  /* The name of the DIE.  */\n+  const char *name;\n+\n+  /*  The DIE associated with this method.  */\n+  struct die_info *die;\n+};\n+\n+/* Internal state when decoding a particular compilation unit.  */\n+struct dwarf2_cu\n+{\n+  explicit dwarf2_cu (dwarf2_per_cu_data *per_cu,\n+\t\t      dwarf2_per_objfile *per_objfile);\n+\n+  DISABLE_COPY_AND_ASSIGN (dwarf2_cu);\n+\n+  /* TU version of handle_DW_AT_stmt_list for read_type_unit_scope.\n+     Create the set of symtabs used by this TU, or if this TU is sharing\n+     symtabs with another TU and the symtabs have already been created\n+     then restore those symtabs in the line header.\n+     We don't need the pc/line-number mapping for type units.  */\n+  void setup_type_unit_groups (struct die_info *die);\n+\n+  /* Start a symtab for DWARF.  NAME, COMP_DIR, LOW_PC are passed to the\n+     buildsym_compunit constructor.  */\n+  struct compunit_symtab *start_symtab (const char *name,\n+\t\t\t\t\tconst char *comp_dir,\n+\t\t\t\t\tCORE_ADDR low_pc);\n+\n+  /* Reset the builder.  */\n+  void reset_builder () { m_builder.reset (); }\n+\n+  /* Return a type that is a generic pointer type, the size of which\n+     matches the address size given in the compilation unit header for\n+     this CU.  */\n+  struct type *addr_type () const;\n+\n+  /* Find an integer type the same size as the address size given in\n+     the compilation unit header for this CU.  UNSIGNED_P controls if\n+     the integer is unsigned or not.  */\n+  struct type *addr_sized_int_type (bool unsigned_p) const;\n+\n+  /* The header of the compilation unit.  */\n+  struct comp_unit_head header {};\n+\n+  /* Base address of this compilation unit.  */\n+  gdb::optional<CORE_ADDR> base_address;\n+\n+  /* The language we are debugging.  */\n+  enum language language = language_unknown;\n+  const struct language_defn *language_defn = nullptr;\n+\n+  const char *producer = nullptr;\n+\n+private:\n+  /* The symtab builder for this CU.  This is only non-NULL when full\n+     symbols are being read.  */\n+  std::unique_ptr<buildsym_compunit> m_builder;\n+\n+public:\n+  /* The generic symbol table building routines have separate lists for\n+     file scope symbols and all all other scopes (local scopes).  So\n+     we need to select the right one to pass to add_symbol_to_list().\n+     We do it by keeping a pointer to the correct list in list_in_scope.\n+\n+     FIXME: The original dwarf code just treated the file scope as the\n+     first local scope, and all other local scopes as nested local\n+     scopes, and worked fine.  Check to see if we really need to\n+     distinguish these in buildsym.c.  */\n+  struct pending **list_in_scope = nullptr;\n+\n+  /* Hash table holding all the loaded partial DIEs\n+     with partial_die->offset.SECT_OFF as hash.  */\n+  htab_t partial_dies = nullptr;\n+\n+  /* Storage for things with the same lifetime as this read-in compilation\n+     unit, including partial DIEs.  */\n+  auto_obstack comp_unit_obstack;\n+\n+  /* Backlink to our per_cu entry.  */\n+  struct dwarf2_per_cu_data *per_cu;\n+\n+  /* The dwarf2_per_objfile that owns this.  */\n+  dwarf2_per_objfile *per_objfile;\n+\n+  /* How many compilation units ago was this CU last referenced?  */\n+  int last_used = 0;\n+\n+  /* A hash table of DIE cu_offset for following references with\n+     die_info->offset.sect_off as hash.  */\n+  htab_t die_hash = nullptr;\n+\n+  /* Full DIEs if read in.  */\n+  struct die_info *dies = nullptr;\n+\n+  /* A set of pointers to dwarf2_per_cu_data objects for compilation\n+     units referenced by this one.  Only set during full symbol processing;\n+     partial symbol tables do not have dependencies.  */\n+  htab_t dependencies = nullptr;\n+\n+  /* Header data from the line table, during full symbol processing.  */\n+  struct line_header *line_header = nullptr;\n+  /* Non-NULL if LINE_HEADER is owned by this DWARF_CU.  Otherwise,\n+     it's owned by dwarf2_per_bfd::line_header_hash.  If non-NULL,\n+     this is the DW_TAG_compile_unit die for this CU.  We'll hold on\n+     to the line header as long as this DIE is being processed.  See\n+     process_die_scope.  */\n+  die_info *line_header_die_owner = nullptr;\n+\n+  /* A list of methods which need to have physnames computed\n+     after all type information has been read.  */\n+  std::vector<delayed_method_info> method_list;\n+\n+  /* To be copied to symtab->call_site_htab.  */\n+  htab_t call_site_htab = nullptr;\n+\n+  /* Non-NULL if this CU came from a DWO file.\n+     There is an invariant here that is important to remember:\n+     Except for attributes copied from the top level DIE in the \"main\"\n+     (or \"stub\") file in preparation for reading the DWO file\n+     (e.g., DW_AT_addr_base), we KISS: there is only *one* CU.\n+     Either there isn't a DWO file (in which case this is NULL and the point\n+     is moot), or there is and either we're not going to read it (in which\n+     case this is NULL) or there is and we are reading it (in which case this\n+     is non-NULL).  */\n+  struct dwo_unit *dwo_unit = nullptr;\n+\n+  /* The DW_AT_addr_base (DW_AT_GNU_addr_base) attribute if present.\n+     Note this value comes from the Fission stub CU/TU's DIE.  */\n+  gdb::optional<ULONGEST> addr_base;\n+\n+  /* The DW_AT_GNU_ranges_base attribute, if present.\n+\n+     This is only relevant in the context of pre-DWARF 5 split units.  In this\n+     context, there is a .debug_ranges section in the linked executable,\n+     containing all the ranges data for all the compilation units.  Each\n+     skeleton/stub unit has (if needed) a DW_AT_GNU_ranges_base attribute that\n+     indicates the base of its contribution to that section.  The DW_AT_ranges\n+     attributes in the split-unit are of the form DW_FORM_sec_offset and point\n+     into the .debug_ranges section of the linked file.  However, they are not\n+     \"true\" DW_FORM_sec_offset, because they are relative to the base of their\n+     compilation unit's contribution, rather than relative to the beginning of\n+     the section.  The DW_AT_GNU_ranges_base value must be added to it to make\n+     it relative to the beginning of the section.\n+\n+     Note that the value is zero when we are not in a pre-DWARF 5 split-unit\n+     case, so this value can be added without needing to know whether we are in\n+     this case or not.\n+\n+     N.B. If a DW_AT_ranges attribute is found on the DW_TAG_compile_unit in the\n+     skeleton/stub, it must not have the base added, as it already points to the\n+     right place.  And since the DW_TAG_compile_unit DIE in the split-unit can't\n+     have a DW_AT_ranges attribute, we can use the\n+\n+       die->tag != DW_AT_compile_unit\n+\n+     to determine whether the base should be added or not.  */\n+  ULONGEST gnu_ranges_base = 0;\n+\n+  /* The DW_AT_rnglists_base attribute, if present.\n+\n+     This is used when processing attributes of form DW_FORM_rnglistx in\n+     non-split units.  Attributes of this form found in a split unit don't\n+     use it, as split-unit files have their own non-shared .debug_rnglists.dwo\n+     section.  */\n+  ULONGEST rnglists_base = 0;\n+\n+  /* The DW_AT_loclists_base attribute if present.  */\n+  ULONGEST loclist_base = 0;\n+\n+  /* When reading debug info generated by older versions of rustc, we\n+     have to rewrite some union types to be struct types with a\n+     variant part.  This rewriting must be done after the CU is fully\n+     read in, because otherwise at the point of rewriting some struct\n+     type might not have been fully processed.  So, we keep a list of\n+     all such types here and process them after expansion.  */\n+  std::vector<struct type *> rust_unions;\n+\n+  /* The DW_AT_str_offsets_base attribute if present.  For DWARF 4 version DWO\n+     files, the value is implicitly zero.  For DWARF 5 version DWO files, the\n+     value is often implicit and is the size of the header of\n+     .debug_str_offsets section (8 or 4, depending on the address size).  */\n+  gdb::optional<ULONGEST> str_offsets_base;\n+\n+  /* Mark used when releasing cached dies.  */\n+  bool mark : 1;\n+\n+  /* This CU references .debug_loc.  See the symtab->locations_valid field.\n+     This test is imperfect as there may exist optimized debug code not using\n+     any location list and still facing inlining issues if handled as\n+     unoptimized code.  For a future better test see GCC PR other/32998.  */\n+  bool has_loclist : 1;\n+\n+  /* These cache the results for producer_is_* fields.  CHECKED_PRODUCER is true\n+     if all the producer_is_* fields are valid.  This information is cached\n+     because profiling CU expansion showed excessive time spent in\n+     producer_is_gxx_lt_4_6.  */\n+  bool checked_producer : 1;\n+  bool producer_is_gxx_lt_4_6 : 1;\n+  bool producer_is_gcc_lt_4_3 : 1;\n+  bool producer_is_icc : 1;\n+  bool producer_is_icc_lt_14 : 1;\n+  bool producer_is_codewarrior : 1;\n+\n+  /* When true, the file that we're processing is known to have\n+     debugging info for C++ namespaces.  GCC 3.3.x did not produce\n+     this information, but later versions do.  */\n+\n+  bool processing_has_namespace_info : 1;\n+\n+  struct partial_die_info *find_partial_die (sect_offset sect_off);\n+\n+  /* If this CU was inherited by another CU (via specification,\n+     abstract_origin, etc), this is the ancestor CU.  */\n+  dwarf2_cu *ancestor;\n+\n+  /* Get the buildsym_compunit for this CU.  */\n+  buildsym_compunit *get_builder ()\n+  {\n+    /* If this CU has a builder associated with it, use that.  */\n+    if (m_builder != nullptr)\n+      return m_builder.get ();\n+\n+    /* Otherwise, search ancestors for a valid builder.  */\n+    if (ancestor != nullptr)\n+      return ancestor->get_builder ();\n+\n+    return nullptr;\n+  }\n+};\n+\n+#endif /* GDB_DWARF2_CU_H */"
    },
    {
      "sha": "d0c6bc3f3558424a77edbbfa0eb224d90ef62d2f",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 1,
      "deletions": 244,
      "changes": 245,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=8ae78a440e4e2ea7ecda9b33a6b3ec63bbcd3c65",
      "patch": "@@ -33,6 +33,7 @@\n #include \"dwarf2/abbrev.h\"\n #include \"dwarf2/attribute.h\"\n #include \"dwarf2/comp-unit.h\"\n+#include \"dwarf2/cu.h\"\n #include \"dwarf2/index-cache.h\"\n #include \"dwarf2/index-common.h\"\n #include \"dwarf2/leb.h\"\n@@ -49,7 +50,6 @@\n #include \"gdbtypes.h\"\n #include \"objfiles.h\"\n #include \"dwarf2.h\"\n-#include \"buildsym.h\"\n #include \"demangle.h\"\n #include \"gdb-demangle.h\"\n #include \"filenames.h\"\t/* for DOSish file names */\n@@ -460,249 +460,6 @@ struct loclists_rnglists_header\n   unsigned int offset_entry_count;\n };\n \n-/* Type used for delaying computation of method physnames.\n-   See comments for compute_delayed_physnames.  */\n-struct delayed_method_info\n-{\n-  /* The type to which the method is attached, i.e., its parent class.  */\n-  struct type *type;\n-\n-  /* The index of the method in the type's function fieldlists.  */\n-  int fnfield_index;\n-\n-  /* The index of the method in the fieldlist.  */\n-  int index;\n-\n-  /* The name of the DIE.  */\n-  const char *name;\n-\n-  /*  The DIE associated with this method.  */\n-  struct die_info *die;\n-};\n-\n-/* Internal state when decoding a particular compilation unit.  */\n-struct dwarf2_cu\n-{\n-  explicit dwarf2_cu (dwarf2_per_cu_data *per_cu,\n-\t\t      dwarf2_per_objfile *per_objfile);\n-\n-  DISABLE_COPY_AND_ASSIGN (dwarf2_cu);\n-\n-  /* TU version of handle_DW_AT_stmt_list for read_type_unit_scope.\n-     Create the set of symtabs used by this TU, or if this TU is sharing\n-     symtabs with another TU and the symtabs have already been created\n-     then restore those symtabs in the line header.\n-     We don't need the pc/line-number mapping for type units.  */\n-  void setup_type_unit_groups (struct die_info *die);\n-\n-  /* Start a symtab for DWARF.  NAME, COMP_DIR, LOW_PC are passed to the\n-     buildsym_compunit constructor.  */\n-  struct compunit_symtab *start_symtab (const char *name,\n-\t\t\t\t\tconst char *comp_dir,\n-\t\t\t\t\tCORE_ADDR low_pc);\n-\n-  /* Reset the builder.  */\n-  void reset_builder () { m_builder.reset (); }\n-\n-  /* Return a type that is a generic pointer type, the size of which\n-     matches the address size given in the compilation unit header for\n-     this CU.  */\n-  struct type *addr_type () const;\n-\n-  /* Find an integer type the same size as the address size given in\n-     the compilation unit header for this CU.  UNSIGNED_P controls if\n-     the integer is unsigned or not.  */\n-  struct type *addr_sized_int_type (bool unsigned_p) const;\n-\n-  /* The header of the compilation unit.  */\n-  struct comp_unit_head header {};\n-\n-  /* Base address of this compilation unit.  */\n-  gdb::optional<CORE_ADDR> base_address;\n-\n-  /* The language we are debugging.  */\n-  enum language language = language_unknown;\n-  const struct language_defn *language_defn = nullptr;\n-\n-  const char *producer = nullptr;\n-\n-private:\n-  /* The symtab builder for this CU.  This is only non-NULL when full\n-     symbols are being read.  */\n-  std::unique_ptr<buildsym_compunit> m_builder;\n-\n-public:\n-  /* The generic symbol table building routines have separate lists for\n-     file scope symbols and all all other scopes (local scopes).  So\n-     we need to select the right one to pass to add_symbol_to_list().\n-     We do it by keeping a pointer to the correct list in list_in_scope.\n-\n-     FIXME: The original dwarf code just treated the file scope as the\n-     first local scope, and all other local scopes as nested local\n-     scopes, and worked fine.  Check to see if we really need to\n-     distinguish these in buildsym.c.  */\n-  struct pending **list_in_scope = nullptr;\n-\n-  /* Hash table holding all the loaded partial DIEs\n-     with partial_die->offset.SECT_OFF as hash.  */\n-  htab_t partial_dies = nullptr;\n-\n-  /* Storage for things with the same lifetime as this read-in compilation\n-     unit, including partial DIEs.  */\n-  auto_obstack comp_unit_obstack;\n-\n-  /* Backlink to our per_cu entry.  */\n-  struct dwarf2_per_cu_data *per_cu;\n-\n-  /* The dwarf2_per_objfile that owns this.  */\n-  dwarf2_per_objfile *per_objfile;\n-\n-  /* How many compilation units ago was this CU last referenced?  */\n-  int last_used = 0;\n-\n-  /* A hash table of DIE cu_offset for following references with\n-     die_info->offset.sect_off as hash.  */\n-  htab_t die_hash = nullptr;\n-\n-  /* Full DIEs if read in.  */\n-  struct die_info *dies = nullptr;\n-\n-  /* A set of pointers to dwarf2_per_cu_data objects for compilation\n-     units referenced by this one.  Only set during full symbol processing;\n-     partial symbol tables do not have dependencies.  */\n-  htab_t dependencies = nullptr;\n-\n-  /* Header data from the line table, during full symbol processing.  */\n-  struct line_header *line_header = nullptr;\n-  /* Non-NULL if LINE_HEADER is owned by this DWARF_CU.  Otherwise,\n-     it's owned by dwarf2_per_bfd::line_header_hash.  If non-NULL,\n-     this is the DW_TAG_compile_unit die for this CU.  We'll hold on\n-     to the line header as long as this DIE is being processed.  See\n-     process_die_scope.  */\n-  die_info *line_header_die_owner = nullptr;\n-\n-  /* A list of methods which need to have physnames computed\n-     after all type information has been read.  */\n-  std::vector<delayed_method_info> method_list;\n-\n-  /* To be copied to symtab->call_site_htab.  */\n-  htab_t call_site_htab = nullptr;\n-\n-  /* Non-NULL if this CU came from a DWO file.\n-     There is an invariant here that is important to remember:\n-     Except for attributes copied from the top level DIE in the \"main\"\n-     (or \"stub\") file in preparation for reading the DWO file\n-     (e.g., DW_AT_addr_base), we KISS: there is only *one* CU.\n-     Either there isn't a DWO file (in which case this is NULL and the point\n-     is moot), or there is and either we're not going to read it (in which\n-     case this is NULL) or there is and we are reading it (in which case this\n-     is non-NULL).  */\n-  struct dwo_unit *dwo_unit = nullptr;\n-\n-  /* The DW_AT_addr_base (DW_AT_GNU_addr_base) attribute if present.\n-     Note this value comes from the Fission stub CU/TU's DIE.  */\n-  gdb::optional<ULONGEST> addr_base;\n-\n-  /* The DW_AT_GNU_ranges_base attribute, if present.\n-\n-     This is only relevant in the context of pre-DWARF 5 split units.  In this\n-     context, there is a .debug_ranges section in the linked executable,\n-     containing all the ranges data for all the compilation units.  Each\n-     skeleton/stub unit has (if needed) a DW_AT_GNU_ranges_base attribute that\n-     indicates the base of its contribution to that section.  The DW_AT_ranges\n-     attributes in the split-unit are of the form DW_FORM_sec_offset and point\n-     into the .debug_ranges section of the linked file.  However, they are not\n-     \"true\" DW_FORM_sec_offset, because they are relative to the base of their\n-     compilation unit's contribution, rather than relative to the beginning of\n-     the section.  The DW_AT_GNU_ranges_base value must be added to it to make\n-     it relative to the beginning of the section.\n-\n-     Note that the value is zero when we are not in a pre-DWARF 5 split-unit\n-     case, so this value can be added without needing to know whether we are in\n-     this case or not.\n-\n-     N.B. If a DW_AT_ranges attribute is found on the DW_TAG_compile_unit in the\n-     skeleton/stub, it must not have the base added, as it already points to the\n-     right place.  And since the DW_TAG_compile_unit DIE in the split-unit can't\n-     have a DW_AT_ranges attribute, we can use the\n-\n-       die->tag != DW_AT_compile_unit\n-\n-     to determine whether the base should be added or not.  */\n-  ULONGEST gnu_ranges_base = 0;\n-\n-  /* The DW_AT_rnglists_base attribute, if present.\n-\n-     This is used when processing attributes of form DW_FORM_rnglistx in\n-     non-split units.  Attributes of this form found in a split unit don't\n-     use it, as split-unit files have their own non-shared .debug_rnglists.dwo\n-     section.  */\n-  ULONGEST rnglists_base = 0;\n-\n-  /* The DW_AT_loclists_base attribute if present.  */\n-  ULONGEST loclist_base = 0;\n-\n-  /* When reading debug info generated by older versions of rustc, we\n-     have to rewrite some union types to be struct types with a\n-     variant part.  This rewriting must be done after the CU is fully\n-     read in, because otherwise at the point of rewriting some struct\n-     type might not have been fully processed.  So, we keep a list of\n-     all such types here and process them after expansion.  */\n-  std::vector<struct type *> rust_unions;\n-\n-  /* The DW_AT_str_offsets_base attribute if present.  For DWARF 4 version DWO\n-     files, the value is implicitly zero.  For DWARF 5 version DWO files, the\n-     value is often implicit and is the size of the header of\n-     .debug_str_offsets section (8 or 4, depending on the address size).  */\n-  gdb::optional<ULONGEST> str_offsets_base;\n-\n-  /* Mark used when releasing cached dies.  */\n-  bool mark : 1;\n-\n-  /* This CU references .debug_loc.  See the symtab->locations_valid field.\n-     This test is imperfect as there may exist optimized debug code not using\n-     any location list and still facing inlining issues if handled as\n-     unoptimized code.  For a future better test see GCC PR other/32998.  */\n-  bool has_loclist : 1;\n-\n-  /* These cache the results for producer_is_* fields.  CHECKED_PRODUCER is true\n-     if all the producer_is_* fields are valid.  This information is cached\n-     because profiling CU expansion showed excessive time spent in\n-     producer_is_gxx_lt_4_6.  */\n-  bool checked_producer : 1;\n-  bool producer_is_gxx_lt_4_6 : 1;\n-  bool producer_is_gcc_lt_4_3 : 1;\n-  bool producer_is_icc : 1;\n-  bool producer_is_icc_lt_14 : 1;\n-  bool producer_is_codewarrior : 1;\n-\n-  /* When true, the file that we're processing is known to have\n-     debugging info for C++ namespaces.  GCC 3.3.x did not produce\n-     this information, but later versions do.  */\n-\n-  bool processing_has_namespace_info : 1;\n-\n-  struct partial_die_info *find_partial_die (sect_offset sect_off);\n-\n-  /* If this CU was inherited by another CU (via specification,\n-     abstract_origin, etc), this is the ancestor CU.  */\n-  dwarf2_cu *ancestor;\n-\n-  /* Get the buildsym_compunit for this CU.  */\n-  buildsym_compunit *get_builder ()\n-  {\n-    /* If this CU has a builder associated with it, use that.  */\n-    if (m_builder != nullptr)\n-      return m_builder.get ();\n-\n-    /* Otherwise, search ancestors for a valid builder.  */\n-    if (ancestor != nullptr)\n-      return ancestor->get_builder ();\n-\n-    return nullptr;\n-  }\n-};\n-\n /* A struct that can be used as a hash key for tables based on DW_AT_stmt_list.\n    This includes type_unit_group and quick_file_names.  */\n "
    }
  ]
}