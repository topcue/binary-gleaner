{
  "sha": "fd3c53675c01472caaa4eb976781b9d6d2d3c53d",
  "node_id": "C_kwDOANOeidoAKGZkM2M1MzY3NWMwMTQ3MmNhYWE0ZWI5NzY3ODFiOWQ2ZDJkM2M1M2Q",
  "commit": {
    "author": {
      "name": "Andi Kleen",
      "email": "andi@firstfloor.org",
      "date": "2021-12-23T17:55:07Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2022-02-04T02:41:56Z"
    },
    "message": "Support symbol+offset lookup in addr2line\n\nThe Linux kernel usually ouputs symbol+offset instead of plain code\naddresses these days, to avoid leaking ASLR secrets and to handle\ndynamically loaded modules.\n\nConverting those with addr2line is somewhat involved: it requires\nlooking up the symbol first using nm and then manually compute the\noffset, and then pass it to addr2line.\n\nThis patch implements the necessary steps directly in addr2line,\nby looking up the symbol (with demangling if needed) and computing\nthe offset.\n\nIt's possible that a symbol is ambigious with a hex number. In this\ncase it uses the symbol lookup if the string contains a +. When it isn't\nambigious the + is optional.",
    "tree": {
      "sha": "fbdc0290490829e5835d8da542470167b08cfdaf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fbdc0290490829e5835d8da542470167b08cfdaf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fd3c53675c01472caaa4eb976781b9d6d2d3c53d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd3c53675c01472caaa4eb976781b9d6d2d3c53d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fd3c53675c01472caaa4eb976781b9d6d2d3c53d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fd3c53675c01472caaa4eb976781b9d6d2d3c53d/comments",
  "author": null,
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "78110c3f7743e8177859fb03db1aeaf327a51459",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78110c3f7743e8177859fb03db1aeaf327a51459",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/78110c3f7743e8177859fb03db1aeaf327a51459"
    }
  ],
  "stats": {
    "total": 93,
    "additions": 80,
    "deletions": 13
  },
  "files": [
    {
      "sha": "fd2ac80dacd2fd14b353a7acf55aeb6f8d826288",
      "filename": "binutils/addr2line.c",
      "status": "modified",
      "additions": 69,
      "deletions": 6,
      "changes": 75,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3c53675c01472caaa4eb976781b9d6d2d3c53d/binutils/addr2line.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3c53675c01472caaa4eb976781b9d6d2d3c53d/binutils/addr2line.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/addr2line.c?ref=fd3c53675c01472caaa4eb976781b9d6d2d3c53d",
      "patch": "@@ -37,6 +37,7 @@\n #include \"demangle.h\"\n #include \"bucomm.h\"\n #include \"elf-bfd.h\"\n+#include \"safe-ctype.h\"\n \n static bool unwind_inlines;\t/* -i, unwind inlined functions. */\n static bool with_addresses;\t/* -a, show addresses.  */\n@@ -51,6 +52,7 @@ static int demangle_flags = DMGL_PARAMS | DMGL_ANSI;\n static int naddr;\t\t/* Number of addresses to process.  */\n static char **addr;\t\t/* Hex addresses to process.  */\n \n+static long symcount;\n static asymbol **syms;\t\t/* Symbol table.  */\n \n static struct option long_options[] =\n@@ -116,7 +118,6 @@ static void\n slurp_symtab (bfd *abfd)\n {\n   long storage;\n-  long symcount;\n   bool dynamic = false;\n \n   if ((bfd_get_file_flags (abfd) & HAS_SYMS) == 0)\n@@ -220,32 +221,94 @@ find_offset_in_section (bfd *abfd, asection *section)\n                                                &line, &discriminator);\n }\n \n-/* Read hexadecimal addresses from stdin, translate into\n+/* Lookup a symbol with offset in symbol table.  */\n+\n+static bfd_vma\n+lookup_symbol (bfd *abfd, char *sym, size_t offset)\n+{\n+  long i;\n+\n+  for (i = 0; i < symcount; i++)\n+    {\n+      if (!strcmp (syms[i]->name, sym))\n+\treturn syms[i]->value + offset + bfd_asymbol_section (syms[i])->vma;\n+    }\n+  /* Try again mangled */\n+  for (i = 0; i < symcount; i++)\n+    {\n+      char *d = bfd_demangle (abfd, syms[i]->name, demangle_flags);\n+      bool match = d && !strcmp (d, sym);\n+      free (d);\n+\n+      if (match)\n+\treturn syms[i]->value + offset + bfd_asymbol_section (syms[i])->vma;\n+    }\n+  return 0;\n+}\n+\n+/* Split an symbol+offset expression. adr is modified.  */\n+\n+static bool\n+is_symbol (char *adr, char **symp, size_t *offset)\n+{\n+  char *end;\n+\n+  while (ISSPACE (*adr))\n+    adr++;\n+  if (ISDIGIT (*adr) || *adr == 0)\n+    return false;\n+  /* Could be either symbol or hex number. Check if it has +.  */\n+  if (TOUPPER(*adr) >= 'A' && TOUPPER(*adr) <= 'F' && !strchr (adr, '+'))\n+    return false;\n+\n+  *symp = adr;\n+  while (*adr && !ISSPACE (*adr) && *adr != '+')\n+    adr++;\n+  end = adr;\n+  while (ISSPACE (*adr))\n+    adr++;\n+  *offset = 0;\n+  if (*adr == '+')\n+    {\n+      adr++;\n+      *offset = strtoul(adr, NULL, 0);\n+    }\n+  *end = 0;\n+  return true;\n+}\n+\n+/* Read hexadecimal or symbolic with offset addresses from stdin, translate into\n    file_name:line_number and optionally function name.  */\n \n static void\n translate_addresses (bfd *abfd, asection *section)\n {\n   int read_stdin = (naddr == 0);\n+  char *adr;\n+  char addr_hex[100];\n+  char *symp;\n+  size_t offset;\n \n   for (;;)\n     {\n       if (read_stdin)\n \t{\n-\t  char addr_hex[100];\n-\n \t  if (fgets (addr_hex, sizeof addr_hex, stdin) == NULL)\n \t    break;\n-\t  pc = bfd_scan_vma (addr_hex, NULL, 16);\n+\t  adr = addr_hex;\n \t}\n       else\n \t{\n \t  if (naddr <= 0)\n \t    break;\n \t  --naddr;\n-\t  pc = bfd_scan_vma (*addr++, NULL, 16);\n+\t  adr = *addr++;\n \t}\n \n+      if (is_symbol (adr, &symp, &offset))\n+        pc = lookup_symbol (abfd, symp, offset);\n+      else\n+        pc = bfd_scan_vma (adr, NULL, 16);\n       if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n \t{\n \t  const struct elf_backend_data *bed = get_elf_backend_data (abfd);"
    },
    {
      "sha": "288974be3868e61ab9696b8e8940f956e82fbbf0",
      "filename": "binutils/doc/binutils.texi",
      "status": "modified",
      "additions": 11,
      "deletions": 7,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fd3c53675c01472caaa4eb976781b9d6d2d3c53d/binutils/doc/binutils.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fd3c53675c01472caaa4eb976781b9d6d2d3c53d/binutils/doc/binutils.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/doc/binutils.texi?ref=fd3c53675c01472caaa4eb976781b9d6d2d3c53d",
      "patch": "@@ -118,7 +118,7 @@ Demangle encoded C++ symbols (on MS-DOS, this program is named\n @code{cxxfilt})\n \n @item addr2line\n-Convert addresses into file names and line numbers\n+Convert addresses or symbol+offset into file names and line numbers\n \n @item windres\n Manipulate Windows resources\n@@ -146,7 +146,7 @@ in the section entitled ``GNU Free Documentation License''.\n * strip::                       Discard symbols\n * c++filt::\t\t\tFilter to demangle encoded C++ symbols\n * cxxfilt: c++filt.             MS-DOS name for c++filt\n-* addr2line::\t\t\tConvert addresses to file and line\n+* addr2line::\t\t\tConvert addresses or symbol+offset to file and line\n * windmc::\t\t\tGenerator for Windows message resources\n * windres::\t\t\tManipulate Windows resources\n * dlltool::\t\t\tCreate files needed to build and use DLLs\n@@ -3902,7 +3902,7 @@ c++filt @var{option} @var{symbol}\n @kindex addr2line\n @cindex address to file name and line number\n \n-@c man title addr2line convert addresses into file names and line numbers\n+@c man title addr2line convert addresses or symbol+offset into file names and line numbers\n \n @smallexample\n @c man begin SYNOPSIS addr2line\n@@ -3923,8 +3923,8 @@ addr2line [@option{-a}|@option{--addresses}]\n \n @c man begin DESCRIPTION addr2line\n \n-@command{addr2line} translates addresses into file names and line numbers.\n-Given an address in an executable or an offset in a section of a relocatable\n+@command{addr2line} translates addresses or symbol+offset into file names and line numbers.\n+Given an address or symbol+offset in an executable or an offset in a section of a relocatable\n object, it uses the debugging information to figure out which file name and\n line number are associated with it.\n \n@@ -3934,11 +3934,11 @@ object to use is specified with the @option{-j} option.\n \n @command{addr2line} has two modes of operation.\n \n-In the first, hexadecimal addresses are specified on the command line,\n+In the first, hexadecimal addresses or symbol+offset are specified on the command line,\n and @command{addr2line} displays the file name and line number for each\n address.\n \n-In the second, @command{addr2line} reads hexadecimal addresses from\n+In the second, @command{addr2line} reads hexadecimal addresses or symbol+offset from\n standard input, and prints the file name and line number for each\n address on standard output.  In this mode, @command{addr2line} may be used\n in a pipe to convert dynamically chosen addresses.\n@@ -3975,6 +3975,10 @@ If the file name or function name can not be determined,\n @command{addr2line} will print two question marks in their place.  If the\n line number can not be determined, @command{addr2line} will print 0.\n \n+When symbol+offset is used, +offset is optional, except when the symbol\n+is ambigious with a hex number. The resolved symbols can be mangled\n+or unmangled, except unmangled symbols with + are not allowed.\n+\n @c man end\n \n @c man begin OPTIONS addr2line"
    }
  ]
}