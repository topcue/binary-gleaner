{
  "sha": "3aa31ce7884f979c68d440a4352c8d69a3283f6c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2FhMzFjZTc4ODRmOTc5YzY4ZDQ0MGE0MzUyYzhkNjlhMzI4M2Y2Yw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-20T23:23:40Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-20T23:23:45Z"
    },
    "message": "Remove last objfile partial_symtab references from psymtab.c\n\nThis removes the last references to the partial_symtab via the objfile\nfrom psymtab.c.  require_partial_symbols is now a method on\npsymbol_functions, and maintenance_print_psymbols is changed to use\ndynamic_cast to verify that it is examining partial symbols.\n\ngdb/ChangeLog\n2021-03-20  Tom Tromey  <tom@tromey.com>\n\n\t* psymtab.c (psymbol_functions::require_partial_symbols): Rename.\n\t(psymbol_functions::find_pc_sect_psymtab): Rename.\n\t(psymbol_functions::find_pc_sect_compunit_symtab)\n\t(maintenance_print_psymbols, maintenance_check_psymtabs): Update.\n\t* psympriv.h (struct psymbol_functions) <require_partial_symbols>:\n\tDeclare new method.\n\t<get_partial_symtabs, find_pc_sect_psymtab>: Likewise.",
    "tree": {
      "sha": "cd8cca0a29dab51523341631f0a229c3ec5a4c09",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cd8cca0a29dab51523341631f0a229c3ec5a4c09"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3aa31ce7884f979c68d440a4352c8d69a3283f6c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3aa31ce7884f979c68d440a4352c8d69a3283f6c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3aa31ce7884f979c68d440a4352c8d69a3283f6c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3aa31ce7884f979c68d440a4352c8d69a3283f6c/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7b249e470a82063605c3789f4b2d0378400423de",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7b249e470a82063605c3789f4b2d0378400423de",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7b249e470a82063605c3789f4b2d0378400423de"
    }
  ],
  "stats": {
    "total": 243,
    "additions": 143,
    "deletions": 100
  },
  "files": [
    {
      "sha": "3abf801bea038188880f552401b28f666de7a43a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3aa31ce7884f979c68d440a4352c8d69a3283f6c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3aa31ce7884f979c68d440a4352c8d69a3283f6c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3aa31ce7884f979c68d440a4352c8d69a3283f6c",
      "patch": "@@ -1,3 +1,13 @@\n+2021-03-20  Tom Tromey  <tom@tromey.com>\n+\n+\t* psymtab.c (psymbol_functions::require_partial_symbols): Rename.\n+\t(psymbol_functions::find_pc_sect_psymtab): Rename.\n+\t(psymbol_functions::find_pc_sect_compunit_symtab)\n+\t(maintenance_print_psymbols, maintenance_check_psymtabs): Update.\n+\t* psympriv.h (struct psymbol_functions) <require_partial_symbols>:\n+\tDeclare new method.\n+\t<get_partial_symtabs, find_pc_sect_psymtab>: Likewise.\n+\n 2021-03-20  Tom Tromey  <tom@tromey.com>\n \n \t* xcoffread.c (xcoff_start_psymtab): Add partial_symtabs parameter."
    },
    {
      "sha": "85651f522d22dc4dd518364be4015e768339a1d7",
      "filename": "gdb/psympriv.h",
      "status": "modified",
      "additions": 23,
      "deletions": 0,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3aa31ce7884f979c68d440a4352c8d69a3283f6c/gdb/psympriv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3aa31ce7884f979c68d440a4352c8d69a3283f6c/gdb/psympriv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psympriv.h?ref=3aa31ce7884f979c68d440a4352c8d69a3283f6c",
      "patch": "@@ -559,13 +559,36 @@ struct psymbol_functions : public quick_symbol_functions\n     m_psymbol_map.clear ();\n   }\n \n+  /* Ensure the partial symbols for OBJFILE have been loaded.  Return\n+     a range adapter for the psymtabs.  */\n+  psymtab_storage::partial_symtab_range require_partial_symbols\n+       (struct objfile *objfile);\n+\n+  /* Return the partial symbol storage associated with this\n+     object.  */\n+  const std::shared_ptr<psymtab_storage> &get_partial_symtabs () const\n+  {\n+    return m_partial_symtabs;\n+  }\n+\n   /* Replace the partial symbol table storage in this object with\n      SYMS.  */\n   void set_partial_symtabs (const std::shared_ptr<psymtab_storage> &syms)\n   {\n     m_partial_symtabs = syms;\n   }\n \n+  /* Find which partial symtab contains PC and SECTION.  Return NULL if\n+     none.  We return the psymtab that contains a symbol whose address\n+     exactly matches PC, or, if we cannot find an exact match, the\n+     psymtab that contains a symbol whose address is closest to PC.  */\n+\n+  struct partial_symtab *find_pc_sect_psymtab\n+       (struct objfile *objfile,\n+\tCORE_ADDR pc,\n+\tstruct obj_section *section,\n+\tstruct bound_minimal_symbol msymbol);\n+\n private:\n \n   void fill_psymbol_map (struct objfile *objfile,"
    },
    {
      "sha": "b2f929912ea00aec0e18674f4689f7827a3a3330",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 110,
      "deletions": 100,
      "changes": 210,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3aa31ce7884f979c68d440a4352c8d69a3283f6c/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3aa31ce7884f979c68d440a4352c8d69a3283f6c/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=3aa31ce7884f979c68d440a4352c8d69a3283f6c",
      "patch": "@@ -80,11 +80,11 @@ psymtab_storage::install_psymtab (partial_symtab *pst)\n    returns a range adapter suitable for iterating over the psymtabs of\n    OBJFILE.  */\n \n-static psymtab_storage::partial_symtab_range\n-require_partial_symbols (struct objfile *objfile)\n+psymtab_storage::partial_symtab_range\n+psymbol_functions::require_partial_symbols (struct objfile *objfile)\n {\n   objfile->require_partial_symbols (true);\n-  return objfile->psymtabs ();\n+  return m_partial_symtabs->range ();\n }\n \n /* Helper function for psym_map_symtabs_matching_filename that\n@@ -255,17 +255,13 @@ find_pc_sect_psymtab_closer (struct objfile *objfile,\n   return best_pst;\n }\n \n-/* Find which partial symtab contains PC and SECTION.  Return NULL if\n-   none.  We return the psymtab that contains a symbol whose address\n-   exactly matches PC, or, if we cannot find an exact match, the\n-   psymtab that contains a symbol whose address is closest to PC.  */\n+/* See psympriv.h.  */\n \n-static struct partial_symtab *\n-find_pc_sect_psymtab (struct objfile *objfile,\n-\t\t      psymtab_storage *partial_symtabs,\n-\t\t      CORE_ADDR pc,\n-\t\t      struct obj_section *section,\n-\t\t      struct bound_minimal_symbol msymbol)\n+struct partial_symtab *\n+psymbol_functions::find_pc_sect_psymtab (struct objfile *objfile,\n+\t\t\t\t\t CORE_ADDR pc,\n+\t\t\t\t\t struct obj_section *section,\n+\t\t\t\t\t struct bound_minimal_symbol msymbol)\n {\n   /* Try just the PSYMTABS_ADDRMAP mapping first as it has better\n      granularity than the later used TEXTLOW/TEXTHIGH one.  However, we need\n@@ -279,14 +275,14 @@ find_pc_sect_psymtab (struct objfile *objfile,\n      partial symtabs then we will end up returning a pointer to an object\n      that is not a partial_symtab, which doesn't end well.  */\n \n-  if (partial_symtabs->psymtabs != NULL\n-      && partial_symtabs->psymtabs_addrmap != NULL)\n+  if (m_partial_symtabs->psymtabs != NULL\n+      && m_partial_symtabs->psymtabs_addrmap != NULL)\n     {\n       CORE_ADDR baseaddr = objfile->text_section_offset ();\n \n       struct partial_symtab *pst\n \t= ((struct partial_symtab *)\n-\t   addrmap_find (partial_symtabs->psymtabs_addrmap,\n+\t   addrmap_find (m_partial_symtabs->psymtabs_addrmap,\n \t\t\t pc - baseaddr));\n       if (pst != NULL)\n \t{\n@@ -356,7 +352,6 @@ psymbol_functions::find_pc_sect_compunit_symtab\n       int warn_if_readin)\n {\n   struct partial_symtab *ps = find_pc_sect_psymtab (objfile,\n-\t\t\t\t\t\t    m_partial_symtabs.get (),\n \t\t\t\t\t\t    pc, section,\n \t\t\t\t\t\t    msymbol);\n   if (ps != NULL)\n@@ -1815,7 +1810,12 @@ maintenance_print_psymbols (const char *args, int from_tty)\n       if (!print_for_objfile)\n \tcontinue;\n \n-      psymtab_storage *partial_symtabs = objfile->partial_symtabs.get ();\n+      psymbol_functions *psf\n+\t= dynamic_cast<psymbol_functions *> (objfile->qf.get ());\n+      if (psf == nullptr)\n+\tcontinue;\n+\n+      psymtab_storage *partial_symtabs = psf->get_partial_symtabs ().get ();\n \n       if (address_arg != NULL)\n \t{\n@@ -1824,8 +1824,7 @@ maintenance_print_psymbols (const char *args, int from_tty)\n \t  /* We don't assume each pc has a unique objfile (this is for\n \t     debugging).  */\n \t  struct partial_symtab *ps\n-\t    = find_pc_sect_psymtab (objfile, partial_symtabs, pc,\n-\t\t\t\t    section, msymbol);\n+\t    = psf->find_pc_sect_psymtab (objfile, pc, section, msymbol);\n \t  if (ps != NULL)\n \t    {\n \t      if (!printed_objfile_header)\n@@ -1841,7 +1840,7 @@ maintenance_print_psymbols (const char *args, int from_tty)\n \t}\n       else\n \t{\n-\t  for (partial_symtab *ps : require_partial_symbols (objfile))\n+\t  for (partial_symtab *ps : psf->require_partial_symbols (objfile))\n \t    {\n \t      int print_for_source = 0;\n \n@@ -1905,7 +1904,11 @@ maintenance_info_psymtabs (const char *regexp, int from_tty)\n \t   actually find a symtab whose name matches.  */\n \tint printed_objfile_start = 0;\n \n-\tfor (partial_symtab *psymtab : require_partial_symbols (objfile))\n+\tpsymbol_functions *psf\n+\t  = dynamic_cast<psymbol_functions *> (objfile->qf.get ());\n+\tif (psf == nullptr)\n+\t  continue;\n+\tfor (partial_symtab *psymtab : psf->require_partial_symbols (objfile))\n \t  {\n \t    QUIT;\n \n@@ -2005,89 +2008,96 @@ maintenance_check_psymtabs (const char *ignore, int from_tty)\n   const struct block *b;\n \n   for (objfile *objfile : current_program_space->objfiles ())\n-    for (partial_symtab *ps : require_partial_symbols (objfile))\n-      {\n-\tstruct gdbarch *gdbarch = objfile->arch ();\n+    {\n+      psymbol_functions *psf\n+\t= dynamic_cast<psymbol_functions *> (objfile->qf.get ());\n+      if (psf == nullptr)\n+\tcontinue;\n \n-\t/* We don't call psymtab_to_symtab here because that may cause symtab\n-\t   expansion.  When debugging a problem it helps if checkers leave\n-\t   things unchanged.  */\n-\tcust = ps->get_compunit_symtab (objfile);\n+      for (partial_symtab *ps : psf->require_partial_symbols (objfile))\n+\t{\n+\t  struct gdbarch *gdbarch = objfile->arch ();\n \n-\t/* First do some checks that don't require the associated symtab.  */\n-\tif (ps->text_high (objfile) < ps->text_low (objfile))\n-\t  {\n-\t    printf_filtered (\"Psymtab \");\n-\t    puts_filtered (ps->filename);\n-\t    printf_filtered (\" covers bad range \");\n-\t    fputs_filtered (paddress (gdbarch, ps->text_low (objfile)),\n-\t\t\t    gdb_stdout);\n-\t    printf_filtered (\" - \");\n-\t    fputs_filtered (paddress (gdbarch, ps->text_high (objfile)),\n-\t\t\t    gdb_stdout);\n-\t    printf_filtered (\"\\n\");\n-\t    continue;\n-\t  }\n+\t  /* We don't call psymtab_to_symtab here because that may cause symtab\n+\t     expansion.  When debugging a problem it helps if checkers leave\n+\t     things unchanged.  */\n+\t  cust = ps->get_compunit_symtab (objfile);\n \n-\t/* Now do checks requiring the associated symtab.  */\n-\tif (cust == NULL)\n-\t  continue;\n-\tbv = COMPUNIT_BLOCKVECTOR (cust);\n-\tb = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);\n-\tfor (partial_symbol *psym : ps->static_psymbols)\n-\t  {\n-\t    /* Skip symbols for inlined functions without address.  These may\n-\t       or may not have a match in the full symtab.  */\n-\t    if (psym->aclass == LOC_BLOCK\n-\t\t&& psym->ginfo.value.address == 0)\n+\t  /* First do some checks that don't require the associated symtab.  */\n+\t  if (ps->text_high (objfile) < ps->text_low (objfile))\n+\t    {\n+\t      printf_filtered (\"Psymtab \");\n+\t      puts_filtered (ps->filename);\n+\t      printf_filtered (\" covers bad range \");\n+\t      fputs_filtered (paddress (gdbarch, ps->text_low (objfile)),\n+\t\t\t      gdb_stdout);\n+\t      printf_filtered (\" - \");\n+\t      fputs_filtered (paddress (gdbarch, ps->text_high (objfile)),\n+\t\t\t      gdb_stdout);\n+\t      printf_filtered (\"\\n\");\n \t      continue;\n+\t    }\n \n-\t    sym = block_lookup_symbol (b, psym->ginfo.search_name (),\n-\t\t\t\t       symbol_name_match_type::SEARCH_NAME,\n-\t\t\t\t       psym->domain);\n-\t    if (!sym)\n-\t      {\n-\t\tprintf_filtered (\"Static symbol `\");\n-\t\tputs_filtered (psym->ginfo.linkage_name ());\n-\t\tprintf_filtered (\"' only found in \");\n-\t\tputs_filtered (ps->filename);\n-\t\tprintf_filtered (\" psymtab\\n\");\n-\t      }\n-\t  }\n-\tb = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);\n-\tfor (partial_symbol *psym : ps->global_psymbols)\n-\t  {\n-\t    sym = block_lookup_symbol (b, psym->ginfo.search_name (),\n-\t\t\t\t       symbol_name_match_type::SEARCH_NAME,\n-\t\t\t\t       psym->domain);\n-\t    if (!sym)\n-\t      {\n-\t\tprintf_filtered (\"Global symbol `\");\n-\t\tputs_filtered (psym->ginfo.linkage_name ());\n-\t\tprintf_filtered (\"' only found in \");\n-\t\tputs_filtered (ps->filename);\n-\t\tprintf_filtered (\" psymtab\\n\");\n-\t      }\n-\t  }\n-\tif (ps->raw_text_high () != 0\n-\t    && (ps->text_low (objfile) < BLOCK_START (b)\n-\t\t|| ps->text_high (objfile) > BLOCK_END (b)))\n-\t  {\n-\t    printf_filtered (\"Psymtab \");\n-\t    puts_filtered (ps->filename);\n-\t    printf_filtered (\" covers \");\n-\t    fputs_filtered (paddress (gdbarch, ps->text_low (objfile)),\n-\t\t\t    gdb_stdout);\n-\t    printf_filtered (\" - \");\n-\t    fputs_filtered (paddress (gdbarch, ps->text_high (objfile)),\n-\t\t\t    gdb_stdout);\n-\t    printf_filtered (\" but symtab covers only \");\n-\t    fputs_filtered (paddress (gdbarch, BLOCK_START (b)), gdb_stdout);\n-\t    printf_filtered (\" - \");\n-\t    fputs_filtered (paddress (gdbarch, BLOCK_END (b)), gdb_stdout);\n-\t    printf_filtered (\"\\n\");\n-\t  }\n-      }\n+\t  /* Now do checks requiring the associated symtab.  */\n+\t  if (cust == NULL)\n+\t    continue;\n+\t  bv = COMPUNIT_BLOCKVECTOR (cust);\n+\t  b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);\n+\t  for (partial_symbol *psym : ps->static_psymbols)\n+\t    {\n+\t      /* Skip symbols for inlined functions without address.  These may\n+\t\t or may not have a match in the full symtab.  */\n+\t      if (psym->aclass == LOC_BLOCK\n+\t\t  && psym->ginfo.value.address == 0)\n+\t\tcontinue;\n+\n+\t      sym = block_lookup_symbol (b, psym->ginfo.search_name (),\n+\t\t\t\t\t symbol_name_match_type::SEARCH_NAME,\n+\t\t\t\t\t psym->domain);\n+\t      if (!sym)\n+\t\t{\n+\t\t  printf_filtered (\"Static symbol `\");\n+\t\t  puts_filtered (psym->ginfo.linkage_name ());\n+\t\t  printf_filtered (\"' only found in \");\n+\t\t  puts_filtered (ps->filename);\n+\t\t  printf_filtered (\" psymtab\\n\");\n+\t\t}\n+\t    }\n+\t  b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);\n+\t  for (partial_symbol *psym : ps->global_psymbols)\n+\t    {\n+\t      sym = block_lookup_symbol (b, psym->ginfo.search_name (),\n+\t\t\t\t\t symbol_name_match_type::SEARCH_NAME,\n+\t\t\t\t\t psym->domain);\n+\t      if (!sym)\n+\t\t{\n+\t\t  printf_filtered (\"Global symbol `\");\n+\t\t  puts_filtered (psym->ginfo.linkage_name ());\n+\t\t  printf_filtered (\"' only found in \");\n+\t\t  puts_filtered (ps->filename);\n+\t\t  printf_filtered (\" psymtab\\n\");\n+\t\t}\n+\t    }\n+\t  if (ps->raw_text_high () != 0\n+\t      && (ps->text_low (objfile) < BLOCK_START (b)\n+\t\t  || ps->text_high (objfile) > BLOCK_END (b)))\n+\t    {\n+\t      printf_filtered (\"Psymtab \");\n+\t      puts_filtered (ps->filename);\n+\t      printf_filtered (\" covers \");\n+\t      fputs_filtered (paddress (gdbarch, ps->text_low (objfile)),\n+\t\t\t      gdb_stdout);\n+\t      printf_filtered (\" - \");\n+\t      fputs_filtered (paddress (gdbarch, ps->text_high (objfile)),\n+\t\t\t      gdb_stdout);\n+\t      printf_filtered (\" but symtab covers only \");\n+\t      fputs_filtered (paddress (gdbarch, BLOCK_START (b)), gdb_stdout);\n+\t      printf_filtered (\" - \");\n+\t      fputs_filtered (paddress (gdbarch, BLOCK_END (b)), gdb_stdout);\n+\t      printf_filtered (\"\\n\");\n+\t    }\n+\t}\n+    }\n }\n \n void _initialize_psymtab ();"
    }
  ]
}