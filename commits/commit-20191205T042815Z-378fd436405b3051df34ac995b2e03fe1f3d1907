{
  "sha": "378fd436405b3051df34ac995b2e03fe1f3d1907",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Mzc4ZmQ0MzY0MDViMzA1MWRmMzRhYzk5NWIyZTAzZmUxZjNkMTkwNw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-05T04:12:44Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-05T04:28:15Z"
    },
    "message": "PR25249, Memory leak in microblaze-dis.c\n\n\tPR 25249\n\t* microblaze-dis.c (NUM_STRBUFS, STRBUF_SIZE): Define.\n\t(struct string_buf): New.\n\t(strbuf): New function.\n\t(get_field): Use strbuf rather than strdup of local temp.\n\t(get_field_imm, get_field_imm5, get_field_imm5_mbar): Likewise.\n\t(get_field_rfsl, get_field_imm15): Likewise.\n\t(get_field_rd, get_field_r1, get_field_r2): Update macros.\n\t(get_field_special): Likewise.  Don't strcpy spr.  Formatting.\n\t(print_insn_microblaze): Formatting.  Init and pass string_buf to\n\tget_field functions.",
    "tree": {
      "sha": "b0afdf8a20ce1c11686cb0abe281e4193c10265a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b0afdf8a20ce1c11686cb0abe281e4193c10265a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/378fd436405b3051df34ac995b2e03fe1f3d1907",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/378fd436405b3051df34ac995b2e03fe1f3d1907",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/378fd436405b3051df34ac995b2e03fe1f3d1907",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/378fd436405b3051df34ac995b2e03fe1f3d1907/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c72a8174b3b45aab8fdda2b0b5232f00fb8287c4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c72a8174b3b45aab8fdda2b0b5232f00fb8287c4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c72a8174b3b45aab8fdda2b0b5232f00fb8287c4"
    }
  ],
  "stats": {
    "total": 320,
    "additions": 182,
    "deletions": 138
  },
  "files": [
    {
      "sha": "e8e24b18ffda3c8d1a75032d8060cd94dd12bcc7",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/378fd436405b3051df34ac995b2e03fe1f3d1907/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/378fd436405b3051df34ac995b2e03fe1f3d1907/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=378fd436405b3051df34ac995b2e03fe1f3d1907",
      "patch": "@@ -1,3 +1,17 @@\n+2019-12-05  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25249\n+\t* microblaze-dis.c (NUM_STRBUFS, STRBUF_SIZE): Define.\n+\t(struct string_buf): New.\n+\t(strbuf): New function.\n+\t(get_field): Use strbuf rather than strdup of local temp.\n+\t(get_field_imm, get_field_imm5, get_field_imm5_mbar): Likewise.\n+\t(get_field_rfsl, get_field_imm15): Likewise.\n+\t(get_field_rd, get_field_r1, get_field_r2): Update macros.\n+\t(get_field_special): Likewise.  Don't strcpy spr.  Formatting.\n+\t(print_insn_microblaze): Formatting.  Init and pass string_buf to\n+\tget_field functions.\n+\n 2019-12-04  Jan Beulich  <jbeulich@suse.com>\n \n \t* i386-opc.tbl (lfs, lgs, lss): Drop No_qSuf."
    },
    {
      "sha": "2b3aa8e078601d0853852d01be196bfa2bb71527",
      "filename": "opcodes/microblaze-dis.c",
      "status": "modified",
      "additions": 168,
      "deletions": 138,
      "changes": 306,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/378fd436405b3051df34ac995b2e03fe1f3d1907/opcodes/microblaze-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/378fd436405b3051df34ac995b2e03fe1f3d1907/opcodes/microblaze-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/microblaze-dis.c?ref=378fd436405b3051df34ac995b2e03fe1f3d1907",
      "patch": "@@ -29,138 +29,156 @@\n #include \"microblaze-opc.h\"\n #include \"microblaze-dis.h\"\n \n-#define get_field_rd(instr)        get_field (instr, RD_MASK, RD_LOW)\n-#define get_field_r1(instr)        get_field (instr, RA_MASK, RA_LOW)\n-#define get_field_r2(instr)        get_field (instr, RB_MASK, RB_LOW)\n+#define get_field_rd(buf, instr)   get_field (buf, instr, RD_MASK, RD_LOW)\n+#define get_field_r1(buf, instr)   get_field (buf, instr, RA_MASK, RA_LOW)\n+#define get_field_r2(buf, instr)   get_field (buf, instr, RB_MASK, RB_LOW)\n #define get_int_field_imm(instr)   ((instr & IMM_MASK) >> IMM_LOW)\n #define get_int_field_r1(instr)    ((instr & RA_MASK) >> RA_LOW)\n \n+#define NUM_STRBUFS 3\n+#define STRBUF_SIZE 25\n \n+struct string_buf\n+{\n+  unsigned int which;\n+  char str[NUM_STRBUFS][STRBUF_SIZE];\n+};\n+\n+static inline char *\n+strbuf (struct string_buf *buf)\n+{\n+#ifdef ENABLE_CHECKING\n+  if (buf->which >= NUM_STRBUFS)\n+    abort ();\n+#endif\n+  return buf->str[buf->which++];\n+}\n \n static char *\n-get_field (long instr, long mask, unsigned short low)\n+get_field (struct string_buf *buf, long instr, long mask, unsigned short low)\n {\n-  char tmpstr[25];\n+  char *p = strbuf (buf);\n \n-  sprintf (tmpstr, \"%s%d\", register_prefix, (int)((instr & mask) >> low));\n-  return (strdup (tmpstr));\n+  sprintf (p, \"%s%d\", register_prefix, (int)((instr & mask) >> low));\n+  return p;\n }\n \n static char *\n-get_field_imm (long instr)\n+get_field_imm (struct string_buf *buf, long instr)\n {\n-  char tmpstr[25];\n+  char *p = strbuf (buf);\n \n-  sprintf (tmpstr, \"%d\", (short)((instr & IMM_MASK) >> IMM_LOW));\n-  return (strdup (tmpstr));\n+  sprintf (p, \"%d\", (short)((instr & IMM_MASK) >> IMM_LOW));\n+  return p;\n }\n \n static char *\n-get_field_imm5 (long instr)\n+get_field_imm5 (struct string_buf *buf, long instr)\n {\n-  char tmpstr[25];\n+  char *p = strbuf (buf);\n \n-  sprintf (tmpstr, \"%d\", (short)((instr & IMM5_MASK) >> IMM_LOW));\n-  return (strdup (tmpstr));\n+  sprintf (p, \"%d\", (short)((instr & IMM5_MASK) >> IMM_LOW));\n+  return p;\n }\n \n static char *\n-get_field_imm5_mbar (long instr)\n+get_field_imm5_mbar (struct string_buf *buf, long instr)\n {\n-  char tmpstr[25];\n+  char *p = strbuf (buf);\n \n-  sprintf(tmpstr, \"%d\", (short)((instr & IMM5_MBAR_MASK) >> IMM_MBAR));\n-  return(strdup(tmpstr));\n+  sprintf (p, \"%d\", (short)((instr & IMM5_MBAR_MASK) >> IMM_MBAR));\n+  return p;\n }\n \n static char *\n-get_field_rfsl (long instr)\n+get_field_rfsl (struct string_buf *buf, long instr)\n {\n-  char tmpstr[25];\n+  char *p = strbuf (buf);\n \n-  sprintf (tmpstr, \"%s%d\", fsl_register_prefix,\n+  sprintf (p, \"%s%d\", fsl_register_prefix,\n \t   (short)((instr & RFSL_MASK) >> IMM_LOW));\n-  return (strdup (tmpstr));\n+  return p;\n }\n \n static char *\n-get_field_imm15 (long instr)\n+get_field_imm15 (struct string_buf *buf, long instr)\n {\n-  char tmpstr[25];\n+  char *p = strbuf (buf);\n \n-  sprintf (tmpstr, \"%d\", (short)((instr & IMM15_MASK) >> IMM_LOW));\n-  return (strdup (tmpstr));\n+  sprintf (p, \"%d\", (short)((instr & IMM15_MASK) >> IMM_LOW));\n+  return p;\n }\n \n static char *\n-get_field_special (long instr, struct op_code_struct * op)\n+get_field_special (struct string_buf *buf, long instr,\n+\t\t   struct op_code_struct *op)\n {\n-  char tmpstr[25];\n-  char spr[6];\n+  char *p = strbuf (buf);\n+  char *spr;\n \n   switch ((((instr & IMM_MASK) >> IMM_LOW) ^ op->immval_mask))\n     {\n     case REG_MSR_MASK :\n-      strcpy (spr, \"msr\");\n+      spr = \"msr\";\n       break;\n     case REG_PC_MASK :\n-      strcpy (spr, \"pc\");\n+      spr = \"pc\";\n       break;\n     case REG_EAR_MASK :\n-      strcpy (spr, \"ear\");\n+      spr = \"ear\";\n       break;\n     case REG_ESR_MASK :\n-      strcpy (spr, \"esr\");\n+      spr = \"esr\";\n       break;\n     case REG_FSR_MASK :\n-      strcpy (spr, \"fsr\");\n+      spr = \"fsr\";\n       break;\n     case REG_BTR_MASK :\n-      strcpy (spr, \"btr\");\n+      spr = \"btr\";\n       break;\n     case REG_EDR_MASK :\n-      strcpy (spr, \"edr\");\n+      spr = \"edr\";\n       break;\n     case REG_PID_MASK :\n-      strcpy (spr, \"pid\");\n+      spr = \"pid\";\n       break;\n     case REG_ZPR_MASK :\n-      strcpy (spr, \"zpr\");\n+      spr = \"zpr\";\n       break;\n     case REG_TLBX_MASK :\n-      strcpy (spr, \"tlbx\");\n+      spr = \"tlbx\";\n       break;\n     case REG_TLBLO_MASK :\n-      strcpy (spr, \"tlblo\");\n+      spr = \"tlblo\";\n       break;\n     case REG_TLBHI_MASK :\n-      strcpy (spr, \"tlbhi\");\n+      spr = \"tlbhi\";\n       break;\n     case REG_TLBSX_MASK :\n-      strcpy (spr, \"tlbsx\");\n+      spr = \"tlbsx\";\n       break;\n     case REG_SHR_MASK :\n-      strcpy (spr, \"shr\");\n+      spr = \"shr\";\n       break;\n     case REG_SLR_MASK :\n-      strcpy (spr, \"slr\");\n+      spr = \"slr\";\n       break;\n     default :\n       if (((((instr & IMM_MASK) >> IMM_LOW) ^ op->immval_mask) & 0xE000)\n-          == REG_PVR_MASK)\n-        {\n-\t  sprintf (tmpstr, \"%spvr%d\", register_prefix,\n+\t  == REG_PVR_MASK)\n+\t{\n+\t  sprintf (p, \"%spvr%d\", register_prefix,\n \t\t   (unsigned short)(((instr & IMM_MASK) >> IMM_LOW)\n-                                    ^ op->immval_mask) ^ REG_PVR_MASK);\n-\t  return (strdup (tmpstr));\n-        }\n+\t\t\t\t    ^ op->immval_mask) ^ REG_PVR_MASK);\n+\t  return p;\n+\t}\n       else\n-        strcpy (spr, \"pc\");\n+\tspr = \"pc\";\n       break;\n     }\n \n-   sprintf (tmpstr, \"%s%s\", register_prefix, spr);\n-   return (strdup (tmpstr));\n+   sprintf (p, \"%s%s\", register_prefix, spr);\n+   return p;\n }\n \n static unsigned long\n@@ -210,7 +228,9 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n   static bfd_vma      prev_insn_addr = -1; /* Init the prev insn addr.  */\n   static int          prev_insn_vma = -1;  /* Init the prev insn vma.  */\n   int                 curr_insn_vma = info->buffer_vma;\n+  struct string_buf   buf;\n \n+  buf.which = 0;\n   info->bytes_per_chunk = 4;\n \n   inst = read_insn_microblaze (memaddr, info, &op);\n@@ -220,8 +240,8 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n   if (prev_insn_vma == curr_insn_vma)\n     {\n       if (memaddr-(info->bytes_per_chunk) == prev_insn_addr)\n-        {\n-          prev_inst = read_insn_microblaze (prev_insn_addr, info, &pop);\n+\t{\n+\t  prev_inst = read_insn_microblaze (prev_insn_addr, info, &pop);\n \t  if (prev_inst == 0)\n \t    return -1;\n \t  if (pop->instr == imm)\n@@ -249,163 +269,173 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n \n       switch (op->inst_type)\n \t{\n-        case INST_TYPE_RD_R1_R2:\n-          print_func (stream, \"\\t%s, %s, %s\", get_field_rd (inst),\n-\t\t   get_field_r1(inst), get_field_r2 (inst));\n-          break;\n-        case INST_TYPE_RD_R1_IMM:\n-\t  print_func (stream, \"\\t%s, %s, %s\", get_field_rd (inst),\n-\t\t   get_field_r1(inst), get_field_imm (inst));\n+\tcase INST_TYPE_RD_R1_R2:\n+\t  print_func (stream, \"\\t%s, %s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_r1 (&buf, inst), get_field_r2 (&buf, inst));\n+\t  break;\n+\tcase INST_TYPE_RD_R1_IMM:\n+\t  print_func (stream, \"\\t%s, %s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_r1 (&buf, inst), get_field_imm (&buf, inst));\n \t  if (info->print_address_func && get_int_field_r1 (inst) == 0\n \t      && info->symbol_at_address_func)\n \t    {\n \t      if (immfound)\n-\t        immval |= (get_int_field_imm (inst) & 0x0000ffff);\n+\t\timmval |= (get_int_field_imm (inst) & 0x0000ffff);\n \t      else\n \t\t{\n-\t          immval = get_int_field_imm (inst);\n-\t          if (immval & 0x8000)\n+\t\t  immval = get_int_field_imm (inst);\n+\t\t  if (immval & 0x8000)\n \t\t    immval |= 0xFFFF0000;\n-\t        }\n+\t\t}\n \t      if (immval > 0 && info->symbol_at_address_func (immval, info))\n \t\t{\n-\t          print_func (stream, \"\\t// \");\n-\t          info->print_address_func (immval, info);\n-\t        }\n+\t\t  print_func (stream, \"\\t// \");\n+\t\t  info->print_address_func (immval, info);\n+\t\t}\n \t    }\n \t  break;\n \tcase INST_TYPE_RD_R1_IMM5:\n-\t  print_func (stream, \"\\t%s, %s, %s\", get_field_rd (inst),\n-\t           get_field_r1(inst), get_field_imm5 (inst));\n+\t  print_func (stream, \"\\t%s, %s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_r1 (&buf, inst), get_field_imm5 (&buf, inst));\n \t  break;\n \tcase INST_TYPE_RD_RFSL:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_rd (inst), get_field_rfsl (inst));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_rfsl (&buf, inst));\n \t  break;\n \tcase INST_TYPE_R1_RFSL:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_r1 (inst), get_field_rfsl (inst));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_r1 (&buf, inst),\n+\t\t      get_field_rfsl (&buf, inst));\n \t  break;\n \tcase INST_TYPE_RD_SPECIAL:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_rd (inst),\n-\t\t   get_field_special (inst, op));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_special (&buf, inst, op));\n \t  break;\n \tcase INST_TYPE_SPECIAL_R1:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_special (inst, op),\n-\t\t   get_field_r1(inst));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_special (&buf, inst, op),\n+\t\t      get_field_r1 (&buf, inst));\n \t  break;\n \tcase INST_TYPE_RD_R1:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_rd (inst), get_field_r1 (inst));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_r1 (&buf, inst));\n \t  break;\n \tcase INST_TYPE_R1_R2:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_r1 (inst), get_field_r2 (inst));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_r1 (&buf, inst),\n+\t\t      get_field_r2 (&buf, inst));\n \t  break;\n \tcase INST_TYPE_R1_IMM:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_r1 (inst), get_field_imm (inst));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_r1 (&buf, inst),\n+\t\t      get_field_imm (&buf, inst));\n \t  /* The non-pc relative instructions are returns, which shouldn't\n \t     have a label printed.  */\n \t  if (info->print_address_func && op->inst_offset_type == INST_PC_OFFSET\n \t      && info->symbol_at_address_func)\n \t    {\n \t      if (immfound)\n-\t        immval |= (get_int_field_imm (inst) & 0x0000ffff);\n+\t\timmval |= (get_int_field_imm (inst) & 0x0000ffff);\n \t      else\n \t\t{\n-\t          immval = get_int_field_imm (inst);\n-\t          if (immval & 0x8000)\n+\t\t  immval = get_int_field_imm (inst);\n+\t\t  if (immval & 0x8000)\n \t\t    immval |= 0xFFFF0000;\n-\t        }\n+\t\t}\n \t      immval += memaddr;\n \t      if (immval > 0 && info->symbol_at_address_func (immval, info))\n \t\t{\n-\t          print_func (stream, \"\\t// \");\n-\t          info->print_address_func (immval, info);\n-\t        }\n+\t\t  print_func (stream, \"\\t// \");\n+\t\t  info->print_address_func (immval, info);\n+\t\t}\n \t      else\n \t\t{\n-\t          print_func (stream, \"\\t\\t// \");\n-\t          print_func (stream, \"%x\", immval);\n-\t        }\n+\t\t  print_func (stream, \"\\t\\t// \");\n+\t\t  print_func (stream, \"%x\", immval);\n+\t\t}\n \t    }\n \t  break;\n-        case INST_TYPE_RD_IMM:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_rd (inst), get_field_imm (inst));\n+\tcase INST_TYPE_RD_IMM:\n+\t  print_func (stream, \"\\t%s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_imm (&buf, inst));\n \t  if (info->print_address_func && info->symbol_at_address_func)\n \t    {\n-\t    if (immfound)\n-\t      immval |= (get_int_field_imm (inst) & 0x0000ffff);\n-\t    else\n-\t      {\n-\t        immval = get_int_field_imm (inst);\n-\t        if (immval & 0x8000)\n-\t\t  immval |= 0xFFFF0000;\n-\t      }\n-\t    if (op->inst_offset_type == INST_PC_OFFSET)\n-\t      immval += (int) memaddr;\n-\t    if (info->symbol_at_address_func (immval, info))\n-\t      {\n-\t        print_func (stream, \"\\t// \");\n-\t        info->print_address_func (immval, info);\n-\t      }\n+\t      if (immfound)\n+\t\timmval |= (get_int_field_imm (inst) & 0x0000ffff);\n+\t      else\n+\t\t{\n+\t\t  immval = get_int_field_imm (inst);\n+\t\t  if (immval & 0x8000)\n+\t\t    immval |= 0xFFFF0000;\n+\t\t}\n+\t      if (op->inst_offset_type == INST_PC_OFFSET)\n+\t\timmval += (int) memaddr;\n+\t      if (info->symbol_at_address_func (immval, info))\n+\t\t{\n+\t\t  print_func (stream, \"\\t// \");\n+\t\t  info->print_address_func (immval, info);\n+\t\t}\n \t    }\n \t  break;\n-        case INST_TYPE_IMM:\n-\t  print_func (stream, \"\\t%s\", get_field_imm (inst));\n+\tcase INST_TYPE_IMM:\n+\t  print_func (stream, \"\\t%s\", get_field_imm (&buf, inst));\n \t  if (info->print_address_func && info->symbol_at_address_func\n \t      && op->instr != imm)\n \t    {\n \t      if (immfound)\n-\t        immval |= (get_int_field_imm (inst) & 0x0000ffff);\n+\t\timmval |= (get_int_field_imm (inst) & 0x0000ffff);\n \t      else\n \t\t{\n-\t          immval = get_int_field_imm (inst);\n-\t          if (immval & 0x8000)\n+\t\t  immval = get_int_field_imm (inst);\n+\t\t  if (immval & 0x8000)\n \t\t    immval |= 0xFFFF0000;\n-\t        }\n+\t\t}\n \t      if (op->inst_offset_type == INST_PC_OFFSET)\n-\t        immval += (int) memaddr;\n+\t\timmval += (int) memaddr;\n \t      if (immval > 0 && info->symbol_at_address_func (immval, info))\n \t\t{\n-\t          print_func (stream, \"\\t// \");\n-\t          info->print_address_func (immval, info);\n-\t        }\n+\t\t  print_func (stream, \"\\t// \");\n+\t\t  info->print_address_func (immval, info);\n+\t\t}\n \t      else if (op->inst_offset_type == INST_PC_OFFSET)\n \t\t{\n-\t          print_func (stream, \"\\t\\t// \");\n-\t          print_func (stream, \"%x\", immval);\n-\t        }\n+\t\t  print_func (stream, \"\\t\\t// \");\n+\t\t  print_func (stream, \"%x\", immval);\n+\t\t}\n \t    }\n \t  break;\n-        case INST_TYPE_RD_R2:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_rd (inst), get_field_r2 (inst));\n+\tcase INST_TYPE_RD_R2:\n+\t  print_func (stream, \"\\t%s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_r2 (&buf, inst));\n \t  break;\n \tcase INST_TYPE_R2:\n-\t  print_func (stream, \"\\t%s\", get_field_r2 (inst));\n+\t  print_func (stream, \"\\t%s\", get_field_r2 (&buf, inst));\n \t  break;\n \tcase INST_TYPE_R1:\n-\t  print_func (stream, \"\\t%s\", get_field_r1 (inst));\n+\t  print_func (stream, \"\\t%s\", get_field_r1 (&buf, inst));\n \t  break;\n \tcase INST_TYPE_R1_R2_SPECIAL:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_r1 (inst), get_field_r2 (inst));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_r1 (&buf, inst),\n+\t\t      get_field_r2 (&buf, inst));\n \t  break;\n \tcase INST_TYPE_RD_IMM15:\n-\t  print_func (stream, \"\\t%s, %s\", get_field_rd (inst), get_field_imm15 (inst));\n+\t  print_func (stream, \"\\t%s, %s\", get_field_rd (&buf, inst),\n+\t\t      get_field_imm15 (&buf, inst));\n \t  break;\n-        /* For mbar insn.  */\n-        case INST_TYPE_IMM5:\n-          print_func (stream, \"\\t%s\", get_field_imm5_mbar (inst));\n-          break;\n-        /* For mbar 16 or sleep insn.  */\n-        case INST_TYPE_NONE:\n-          break;\n-\t/* For tuqula instruction */\n+\t  /* For mbar insn.  */\n+\tcase INST_TYPE_IMM5:\n+\t  print_func (stream, \"\\t%s\", get_field_imm5_mbar (&buf, inst));\n+\t  break;\n+\t  /* For mbar 16 or sleep insn.  */\n+\tcase INST_TYPE_NONE:\n+\t  break;\n+\t  /* For tuqula instruction */\n \tcase INST_TYPE_RD:\n-\t  print_func (stream, \"\\t%s\", get_field_rd (inst));\n+\t  print_func (stream, \"\\t%s\", get_field_rd (&buf, inst));\n \t  break;\n \tcase INST_TYPE_RFSL:\n-\t  print_func (stream, \"\\t%s\", get_field_rfsl (inst));\n+\t  print_func (stream, \"\\t%s\", get_field_rfsl (&buf, inst));\n \t  break;\n \tdefault:\n \t  /* If the disassembler lags the instruction set.  */\n-\t  print_func (stream, \"\\tundecoded operands, inst is 0x%04x\", (unsigned int) inst);\n+\t  print_func (stream, \"\\tundecoded operands, inst is 0x%04x\",\n+\t\t      (unsigned int) inst);\n \t  break;\n \t}\n     }"
    }
  ]
}