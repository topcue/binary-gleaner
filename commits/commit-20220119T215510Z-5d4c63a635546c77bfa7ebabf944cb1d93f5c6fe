{
  "sha": "5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
  "node_id": "C_kwDOANOeidoAKDVkNGM2M2E2MzU1NDZjNzdiZmE3ZWJhYmY5NDRjYjFkOTNmNWM2ZmU",
  "commit": {
    "author": {
      "name": "Maciej W. Rozycki",
      "email": "macro@embecosm.com",
      "date": "2022-01-19T21:55:10Z"
    },
    "committer": {
      "name": "Maciej W. Rozycki",
      "email": "macro@embecosm.com",
      "date": "2022-01-19T21:55:10Z"
    },
    "message": "Respect `set print array-indexes' with Fortran arrays\n\nAdd `set print array-indexes' handling for Fortran arrays.  Currently\nthe setting is ignored and indices are never shown.\n\nKeep track of the most recent index handled so that any outstanding\nrepeated elements printed when the limit set by `set print elements' is\nhit have the correct index shown.\n\nOutput now looks like:\n\n(gdb) set print array-indexes on\n(gdb) print array_1d\n$1 = ((-2) = 1, (-1) = 1, (0) = 1, (1) = 1, (2) = 1)\n(gdb) set print repeats 4\n(gdb) set print elements 12\n(gdb) print array_2d\n$2 = ((-2) = ((-2) = 2, <repeats 5 times>) (-1) = ((-2) = 2, <repeats 5 times>) (0) = ((-2) = 2, (-1) = 2, ...) ...)\n(gdb)\n\nfor a 5-element vector and a 5 by 5 array filled with the value of 2.",
    "tree": {
      "sha": "24578c89a2818792cb8ded824abc1118d26edfc7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/24578c89a2818792cb8ded824abc1118d26edfc7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "6b4338c868e96a549af44fdf17141f4eac77e225",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6b4338c868e96a549af44fdf17141f4eac77e225",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6b4338c868e96a549af44fdf17141f4eac77e225"
    }
  ],
  "stats": {
    "total": 306,
    "additions": 279,
    "deletions": 27
  },
  "files": [
    {
      "sha": "ad97dd51cd34bb9d53c64ccb2300cae8ac717dfa",
      "filename": "gdb/f-array-walker.h",
      "status": "modified",
      "additions": 23,
      "deletions": 16,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/f-array-walker.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/f-array-walker.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-array-walker.h?ref=5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
      "patch": "@@ -115,12 +115,13 @@ struct fortran_array_walker_base_impl\n   { return should_continue; }\n \n   /* Called when GDB starts iterating over a dimension of the array.  The\n-     argument NELTS holds the number of the elements in the dimension and\n+     argument INDEX_TYPE is the type of the index used to address elements\n+     in the dimension, NELTS holds the number of the elements there, and\n      INNER_P is true for the inner most dimension (the dimension containing\n      the actual elements of the array), and false for more outer dimensions.\n      For a concrete example of how this function is called see the comment\n      on process_element below.  */\n-  void start_dimension (LONGEST nelts, bool inner_p)\n+  void start_dimension (struct type *index_type, LONGEST nelts, bool inner_p)\n   { /* Nothing.  */ }\n \n   /* Called when GDB finishes iterating over a dimension of the array.  The\n@@ -135,40 +136,44 @@ struct fortran_array_walker_base_impl\n   /* Called when processing dimensions of the array other than the\n      innermost one.  WALK_1 is the walker to normally call, ELT_TYPE is\n      the type of the element being extracted, and ELT_OFF is the offset\n-     of the element from the start of array being walked, and LAST_P is\n-     true only when this is the last element that will be processed in\n-     this dimension.  */\n+     of the element from the start of array being walked.  INDEX is the\n+     value of the index the current element is at in the upper dimension.\n+     Finally LAST_P is true only when this is the last element that will\n+     be processed in this dimension.  */\n   void process_dimension (gdb::function_view<void (struct type *,\n \t\t\t\t\t\t   int, bool)> walk_1,\n-\t\t\t  struct type *elt_type, LONGEST elt_off, bool last_p)\n+\t\t\t  struct type *elt_type, LONGEST elt_off,\n+\t\t\t  LONGEST index, bool last_p)\n   {\n     walk_1 (elt_type, elt_off, last_p);\n   }\n \n   /* Called when processing the inner most dimension of the array, for\n      every element in the array.  ELT_TYPE is the type of the element being\n      extracted, and ELT_OFF is the offset of the element from the start of\n-     array being walked, and LAST_P is true only when this is the last\n-     element that will be processed in this dimension.\n+     array being walked.  INDEX is the value of the index the current\n+     element is at in the upper dimension.  Finally LAST_P is true only\n+     when this is the last element that will be processed in this dimension.\n \n      Given this two dimensional array ((1, 2) (3, 4) (5, 6)), the calls to\n      start_dimension, process_element, and finish_dimension look like this:\n \n-     start_dimension (3, false);\n-       start_dimension (2, true);\n+     start_dimension (INDEX_TYPE, 3, false);\n+       start_dimension (INDEX_TYPE, 2, true);\n          process_element (TYPE, OFFSET, false);\n          process_element (TYPE, OFFSET, true);\n        finish_dimension (true, false);\n-       start_dimension (2, true);\n+       start_dimension (INDEX_TYPE, 2, true);\n          process_element (TYPE, OFFSET, false);\n          process_element (TYPE, OFFSET, true);\n        finish_dimension (true, true);\n-       start_dimension (2, true);\n+       start_dimension (INDEX_TYPE, 2, true);\n          process_element (TYPE, OFFSET, false);\n          process_element (TYPE, OFFSET, true);\n        finish_dimension (true, true);\n      finish_dimension (false, true);  */\n-  void process_element (struct type *elt_type, LONGEST elt_off, bool last_p)\n+  void process_element (struct type *elt_type, LONGEST elt_off,\n+\t\t\tLONGEST index, bool last_p)\n   { /* Nothing.  */ }\n };\n \n@@ -224,7 +229,9 @@ class fortran_array_walker\n     fortran_array_offset_calculator calc (type);\n \n     m_nss++;\n-    m_impl.start_dimension (upperbound - lowerbound + 1,\n+    gdb_assert (range_type->code () == TYPE_CODE_RANGE);\n+    m_impl.start_dimension (TYPE_TARGET_TYPE (range_type),\n+\t\t\t    upperbound - lowerbound + 1,\n \t\t\t    m_nss == m_ndimensions);\n \n     if (m_nss != m_ndimensions)\n@@ -246,7 +253,7 @@ class fortran_array_walker\n \t\t{\n \t\t  this->walk_1 (w_type, w_offset, w_last_p);\n \t\t},\n-\t       subarray_type, new_offset, i == upperbound);\n+\t       subarray_type, new_offset, i, i == upperbound);\n \t  }\n       }\n     else\n@@ -267,7 +274,7 @@ class fortran_array_walker\n \t\telt_type = resolve_dynamic_type (elt_type, {}, e_address);\n \t      }\n \n-\t    m_impl.process_element (elt_type, elt_off, (i == upperbound));\n+\t    m_impl.process_element (elt_type, elt_off, i, i == upperbound);\n \t  }\n       }\n "
    },
    {
      "sha": "eaeda884aef2553b17909087b6deabfca2cfea6b",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 19,
      "deletions": 3,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
      "patch": "@@ -263,7 +263,7 @@ class fortran_array_repacker_base_impl\n      will be creating values for each element as we load them and then copy\n      them into the M_DEST value.  Set a value mark so we can free these\n      temporary values.  */\n-  void start_dimension (LONGEST nelts, bool inner_p)\n+  void start_dimension (struct type *index_type, LONGEST nelts, bool inner_p)\n   {\n     if (inner_p)\n       {\n@@ -330,7 +330,8 @@ class fortran_lazy_array_repacker_impl\n   /* Create a lazy value in target memory representing a single element,\n      then load the element into GDB's memory and copy the contents into the\n      destination value.  */\n-  void process_element (struct type *elt_type, LONGEST elt_off, bool last_p)\n+  void process_element (struct type *elt_type, LONGEST elt_off,\n+\t\t\tLONGEST index, bool last_p)\n   {\n     copy_element_to_dest (value_at_lazy (elt_type, m_addr + elt_off));\n   }\n@@ -368,7 +369,8 @@ class fortran_array_repacker_impl\n   /* Extract an element of ELT_TYPE at offset (M_BASE_OFFSET + ELT_OFF)\n      from the content buffer of M_VAL then copy this extracted value into\n      the repacked destination value.  */\n-  void process_element (struct type *elt_type, LONGEST elt_off, bool last_p)\n+  void process_element (struct type *elt_type, LONGEST elt_off,\n+\t\t\tLONGEST index, bool last_p)\n   {\n     struct value *elt\n       = value_from_component (m_val, elt_type, (elt_off + m_base_offset));\n@@ -1532,6 +1534,20 @@ fortran_structop_operation::evaluate (struct type *expect_type,\n \n /* See language.h.  */\n \n+void\n+f_language::print_array_index (struct type *index_type, LONGEST index,\n+\t\t\t       struct ui_file *stream,\n+\t\t\t       const value_print_options *options) const\n+{\n+  struct value *index_value = value_from_longest (index_type, index);\n+\n+  fprintf_filtered (stream, \"(\");\n+  value_print (index_value, stream, options);\n+  fprintf_filtered (stream, \") = \");\n+}\n+\n+/* See language.h.  */\n+\n void\n f_language::language_arch_info (struct gdbarch *gdbarch,\n \t\t\t\tstruct language_arch_info *lai) const"
    },
    {
      "sha": "11debd5569fce14349a50f1d4eb5542c34eb44fe",
      "filename": "gdb/f-lang.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/f-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/f-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.h?ref=5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
      "patch": "@@ -58,6 +58,12 @@ class f_language : public language_defn\n     return extensions;\n   }\n \n+  /* See language.h.  */\n+  void print_array_index (struct type *index_type,\n+\t\t\t  LONGEST index,\n+\t\t\t  struct ui_file *stream,\n+\t\t\t  const value_print_options *options) const override;\n+\n   /* See language.h.  */\n   void language_arch_info (struct gdbarch *gdbarch,\n \t\t\t   struct language_arch_info *lai) const override;"
    },
    {
      "sha": "3d13eb11fb0f9fc0d8a9759d5a4d86c9a86b31df",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 31,
      "deletions": 8,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
      "patch": "@@ -101,6 +101,9 @@ f77_get_dynamic_length_of_aggregate (struct type *type)\n \n struct dimension_stats\n {\n+  /* The type of the index used to address elements in the dimension.  */\n+  struct type *index_type;\n+\n   /* Total number of elements in the dimension, counted as we go.  */\n   int nelts;\n };\n@@ -147,14 +150,15 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n \n   /* Called when we start iterating over a dimension.  If it's not the\n      inner most dimension then print an opening '(' character.  */\n-  void start_dimension (LONGEST nelts, bool inner_p)\n+  void start_dimension (struct type *index_type, LONGEST nelts, bool inner_p)\n   {\n     size_t dim_indx = m_dimension++;\n \n     m_elt_type_prev = nullptr;\n     if (m_stats.size () < m_dimension)\n       {\n \tm_stats.resize (m_dimension);\n+\tm_stats[dim_indx].index_type = index_type;\n \tm_stats[dim_indx].nelts = nelts;\n       }\n \n@@ -177,12 +181,15 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n   /* Called when processing dimensions of the array other than the\n      innermost one.  WALK_1 is the walker to normally call, ELT_TYPE is\n      the type of the element being extracted, and ELT_OFF is the offset\n-     of the element from the start of array being walked, and LAST_P is\n-     true only when this is the last element that will be processed in\n-     this dimension.  */\n+     of the element from the start of array being walked, INDEX_TYPE\n+     and INDEX is the type and the value respectively of the element's\n+     index in the dimension currently being walked and LAST_P is true\n+     only when this is the last element that will be processed in this\n+     dimension.  */\n   void process_dimension (gdb::function_view<void (struct type *,\n \t\t\t\t\t\t   int, bool)> walk_1,\n-\t\t\t  struct type *elt_type, LONGEST elt_off, bool last_p)\n+\t\t\t  struct type *elt_type, LONGEST elt_off,\n+\t\t\t  LONGEST index, bool last_p)\n   {\n     size_t dim_indx = m_dimension - 1;\n     struct type *elt_type_prev = m_elt_type_prev;\n@@ -216,7 +223,12 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n \t  }\n \telse\n \t  for (LONGEST i = nrepeats; i > 0; i--)\n-\t    walk_1 (elt_type_prev, elt_off_prev, repeated && i == 1);\n+\t    {\n+\t      maybe_print_array_index (m_stats[dim_indx].index_type,\n+\t\t\t\t       index - nrepeats + repeated,\n+\t\t\t\t       m_stream, m_options);\n+\t      walk_1 (elt_type_prev, elt_off_prev, repeated && i == 1);\n+\t    }\n \n \tif (!repeated)\n \t  {\n@@ -227,6 +239,8 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n \t       to `continue_walking' from our caller won't do that.  */\n \t    if (m_elts < m_options->print_max)\n \t      {\n+\t\tmaybe_print_array_index (m_stats[dim_indx].index_type, index,\n+\t\t\t\t\t m_stream, m_options);\n \t\twalk_1 (elt_type, elt_off, last_p);\n \t\tnrepeats++;\n \t      }\n@@ -240,9 +254,13 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n   }\n \n   /* Called to process an element of ELT_TYPE at offset ELT_OFF from the\n-     start of the parent object.  */\n-  void process_element (struct type *elt_type, LONGEST elt_off, bool last_p)\n+     start of the parent object, where INDEX is the value of the element's\n+     index in the dimension currently being walked and LAST_P is true only\n+     when this is the last element to be processed in this dimension.  */\n+  void process_element (struct type *elt_type, LONGEST elt_off,\n+\t\t\tLONGEST index, bool last_p)\n   {\n+    size_t dim_indx = m_dimension - 1;\n     struct type *elt_type_prev = m_elt_type_prev;\n     LONGEST elt_off_prev = m_elt_off_prev;\n     bool repeated = (m_options->repeat_count_threshold < UINT_MAX\n@@ -277,6 +295,9 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n \n \t\tfor (LONGEST i = nrepeats; i > 0; i--)\n \t\t  {\n+\t\t    maybe_print_array_index (m_stats[dim_indx].index_type,\n+\t\t\t\t\t     index - i + 1,\n+\t\t\t\t\t     m_stream, m_options);\n \t\t    common_val_print (e_val, m_stream, m_recurse, m_options,\n \t\t\t\t      current_language);\n \t\t    if (i > 1)\n@@ -294,6 +315,8 @@ class fortran_array_printer_impl : public fortran_array_walker_base_impl\n \n \t    if (printed)\n \t      fputs_filtered (\", \", m_stream);\n+\t    maybe_print_array_index (m_stats[dim_indx].index_type, index,\n+\t\t\t\t     m_stream, m_options);\n \t    common_val_print (e_val, m_stream, m_recurse, m_options,\n \t\t\t      current_language);\n \t  }"
    },
    {
      "sha": "2740b81e0383a129c73c613dc0f4527b251a0993",
      "filename": "gdb/testsuite/gdb.fortran/array-indices.exp",
      "status": "added",
      "additions": 200,
      "deletions": 0,
      "changes": 200,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/testsuite/gdb.fortran/array-indices.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe/gdb/testsuite/gdb.fortran/array-indices.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/array-indices.exp?ref=5d4c63a635546c77bfa7ebabf944cb1d93f5c6fe",
      "patch": "@@ -0,0 +1,200 @@\n+# Copyright 2022 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test the printing of element indices in Fortran arrays.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+\n+load_lib fortran.exp\n+\n+# Build up the expected output for each array.\n+set n0    {(-2)}\n+set n1    {(-1)}\n+set n2    {(0)}\n+set n3    {(1)}\n+set n4    {(2)}\n+set n5    {(3)}\n+set a9p9o \"($n0 = 9, $n1 = 9, $n2 = 9, $n3 = 9, $n4 = 9, $n5 = 9)\"\n+set a1p   \"($n0 = 1, $n1 = 1, $n2 = 1, $n3 = 1, $n4 = 1)\"\n+set a1p9  \"($n0 = 1, $n1 = 1, $n2 = 1, $n3 = 1, $n4 = 1, $n5 = 9)\"\n+set a2po  \"($n0 = 2, $n1 = 2, $n2 = 2, $n3 = 2, $n4 = 2)\"\n+set a2p   \"($n0 = ${a2po} $n1 = ${a2po} $n2 = ${a2po} $n3 = ${a2po}\\\n+\t    $n4 = ${a2po})\"\n+set a2p9o \"($n0 = 2, $n1 = 2, $n2 = 2, $n3 = 2, $n4 = 2, $n5 = 9)\"\n+set a2p9  \"($n0 = ${a2p9o} $n1 = ${a2p9o} $n2 = ${a2p9o} $n3 = ${a2p9o}\\\n+\t    $n4 = ${a2p9o} $n5 = ${a9p9o})\"\n+set a3po  \"($n0 = 3, $n1 = 3, $n2 = 3, $n3 = 3, $n4 = 3)\"\n+set a3p   \"($n0 = ${a3po} $n1 = ${a3po} $n2 = ${a3po} $n3 = ${a3po}\\\n+\t    $n4 = ${a3po})\"\n+set a3p   \"($n0 = ${a3p} $n1 = ${a3p} $n2 = ${a3p} $n3 = ${a3p} $n4 = ${a3p})\"\n+set a3p9o \"($n0 = 3, $n1 = 3, $n2 = 3, $n3 = 3, $n4 = 3, $n5 = 9)\"\n+set a3p9  \"($n0 = ${a3p9o} $n1 = ${a3p9o} $n2 = ${a3p9o} $n3 = ${a3p9o}\\\n+\t    $n4 = ${a3p9o} $n5 = ${a9p9o})\"\n+set a9p9  \"($n0 = ${a9p9o} $n1 = ${a9p9o} $n2 = ${a9p9o} $n3 = ${a9p9o}\\\n+\t    $n4 = ${a9p9o} $n5 = ${a9p9o})\"\n+set a3p9  \"($n0 = ${a3p9} $n1 = ${a3p9} $n2 = ${a3p9} $n3 = ${a3p9}\\\n+\t    $n4 = ${a3p9} $n5 = ${a9p9})\"\n+\n+# Convert the output into a regexp.\n+set r1p   [string_to_regexp $a1p]\n+set r1p9  [string_to_regexp $a1p9]\n+set r2po  [string_to_regexp $a2po]\n+set r2p9o [string_to_regexp $a2p9o]\n+set r2p   [string_to_regexp $a2p]\n+set r2p9  [string_to_regexp $a2p9]\n+set r3po  [string_to_regexp $a3po]\n+set r3p9o [string_to_regexp $a3p9o]\n+set r3p   [string_to_regexp $a3p]\n+set r3p9  [string_to_regexp $a3p9]\n+\n+set rep5  \"<repeats 5 times>\"\n+set rep6  \"<repeats 6 times>\"\n+\n+proc array_repeat { variant } {\n+    global testfile srcfile\n+    upvar n0 n0 n1 n1 n2 n2 n5 n5\n+    upvar r1p r1p r1p9 r1p9 r2po r2po r2p9o r2p9o r2p r2p r2p9 r2p9\n+    upvar r3po r3po r3p9o r3p9o r3p r3p r3p9 r3p9\n+    upvar a2po a2po a2p9o a2p9o a3po a3po a3p9o a3p9o\n+    upvar rep5 rep5 rep6 rep6\n+\n+    standard_testfile \"${variant}.f90\"\n+\n+    if {[prepare_for_testing ${testfile}.exp ${variant} ${srcfile} \\\n+\t    {debug f90}]} {\n+\treturn -1\n+    }\n+\n+    with_test_prefix \"${variant}\" {\n+\tgdb_test_no_output \"set print array-indexes on\"\n+    }\n+\n+    if {![fortran_runto_main]} {\n+\tperror \"Could not run to main.\"\n+\tcontinue\n+    }\n+\n+    gdb_breakpoint [gdb_get_line_number \"Break here\"]\n+    gdb_continue_to_breakpoint \"${variant}\"\n+\n+    with_test_prefix \"${variant}: repeats=unlimited, elements=unlimited\" {\n+\t# Check the arrays print as expected.\n+\tgdb_test_no_output \"set print repeats unlimited\"\n+\tgdb_test_no_output \"set print elements unlimited\"\n+\n+\tgdb_test \"print array_1d\"  \"${r1p}\"\n+\tgdb_test \"print array_1d9\" \"${r1p9}\"\n+\tgdb_test \"print array_2d\"  \"${r2p}\"\n+\tgdb_test \"print array_2d9\" \"${r2p9}\"\n+\tgdb_test \"print array_3d\"  \"${r3p}\"\n+\tgdb_test \"print array_3d9\" \"${r3p9}\"\n+    }\n+\n+    with_test_prefix \"${variant}: repeats=4, elements=unlimited\" {\n+\t# Now set the repeat limit.\n+\tgdb_test_no_output \"set print repeats 4\"\n+\tgdb_test_no_output \"set print elements unlimited\"\n+\n+\tgdb_test \"print array_1d\" \\\n+\t    [string_to_regexp \"($n0 = 1, ${rep5})\"]\n+\tgdb_test \"print array_1d9\" \\\n+\t    [string_to_regexp \"($n0 = 1, ${rep5}, $n5 = 9)\"]\n+\tgdb_test \"print array_2d\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = 2, ${rep5}) ${rep5})\"]\n+\tgdb_test \"print array_2d9\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = 2, ${rep5}, $n5 = 9) ${rep5}\\\n+\t\t\t\t$n5 = ($n0 = 9, ${rep6}))\"]\n+\tgdb_test \"print array_3d\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = ($n0 = 3, ${rep5}) ${rep5})\\\n+\t\t\t\t${rep5})\"]\n+\tgdb_test \"print array_3d9\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = ($n0 = 3, ${rep5}, $n5 = 9)\\\n+\t\t\t\t       ${rep5} $n5 = ($n0 = 9, ${rep6}))\\\n+\t\t\t\t${rep5}\\\n+\t\t\t\t$n5 = ($n0 = ($n0 = 9, ${rep6}) ${rep6}))\"]\n+    }\n+\n+    with_test_prefix \"${variant}: repeats=unlimited, elements=12\" {\n+\t# Now set the element limit.\n+\tgdb_test_no_output \"set print repeats unlimited\"\n+\tgdb_test_no_output \"set print elements 12\"\n+\n+\tgdb_test \"print array_1d\"  \"${r1p}\"\n+\tgdb_test \"print array_1d9\" \"${r1p9}\"\n+\tgdb_test \"print array_2d\" \\\n+\t    [string_to_regexp \"($n0 = ${a2po} $n1 = ${a2po}\\\n+\t\t\t\t$n2 = ($n0 = 2, $n1 = 2, ...) ...)\"]\n+\tgdb_test \"print array_2d9\" \\\n+\t    [string_to_regexp \"($n0 = ${a2p9o} $n1 = ${a2p9o} ...)\"]\n+\tgdb_test \"print array_3d\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = ${a3po} $n1 = ${a3po}\\\n+\t\t\t\t       $n2 = ($n0 = 3, $n1 = 3, ...)\\\n+\t\t\t\t       ...) ...)\"]\n+\tgdb_test \"print array_3d9\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = ${a3p9o} $n1 = ${a3p9o} ...)\\\n+\t\t\t\t...)\"]\n+    }\n+\n+    with_test_prefix \"${variant}: repeats=4, elements=12\" {\n+\t# Now set both limits.\n+\tgdb_test_no_output \"set print repeats 4\"\n+\tgdb_test_no_output \"set print elements 12\"\n+\n+\tgdb_test \"print array_1d\" \\\n+\t    [string_to_regexp \"($n0 = 1, ${rep5})\"]\n+\tgdb_test \"print array_1d9\" \\\n+\t    [string_to_regexp \"($n0 = 1, ${rep5}, $n5 = 9)\"]\n+\tgdb_test \"print array_2d\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = 2, ${rep5})\\\n+\t\t\t\t$n1 = ($n0 = 2, ${rep5})\\\n+\t\t\t\t$n2 = ($n0 = 2, $n1 = 2, ...) ...)\"]\n+\tgdb_test \"print array_2d9\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = 2, ${rep5}, $n5 = 9)\\\n+\t\t\t\t$n1 = ($n0 = 2, ${rep5}, $n5 = 9) ...)\"]\n+\tgdb_test \"print array_3d\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = ($n0 = 3, ${rep5})\\\n+\t\t\t\t       $n1 = ($n0 = 3, ${rep5})\\\n+\t\t\t\t       $n2 = ($n0 = 3, $n1 = 3, ...) ...) ...)\"]\n+\tgdb_test \"print array_3d9\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = ($n0 = 3, ${rep5}, $n5 = 9)\\\n+\t\t\t\t       $n1 = ($n0 = 3, ${rep5}, $n5 = 9)\\\n+\t\t\t\t       ...) ...)\"]\n+    }\n+\n+    with_test_prefix \"${variant}: repeats=4, elements=30\" {\n+\t# Now set both limits.\n+\tgdb_test_no_output \"set print repeats 4\"\n+\tgdb_test_no_output \"set print elements 30\"\n+\n+\tgdb_test \"print array_1d\" \\\n+\t    [string_to_regexp \"($n0 = 1, ${rep5})\"]\n+\tgdb_test \"print array_1d9\" \\\n+\t    [string_to_regexp \"($n0 = 1, ${rep5}, $n5 = 9)\"]\n+\tgdb_test \"print array_2d\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = 2, ${rep5}) ${rep5})\"]\n+\tgdb_test \"print array_2d9\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = 2, ${rep5}, $n5 = 9) ${rep5}\\\n+\t\t\t\t...)\"]\n+\tgdb_test \"print array_3d\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = ($n0 = 3, ${rep5}) ${rep5})\\\n+\t\t\t\t$n1 = ($n0 = ($n0 = 3, ${rep5}) ...) ...)\"]\n+\tgdb_test \"print array_3d9\" \\\n+\t    [string_to_regexp \"($n0 = ($n0 = ($n0 = 3, ${rep5}, $n5 = 9)\\\n+\t\t\t\t       ${rep5} ...) ...)\"]\n+    }\n+}\n+\n+array_repeat \"array-repeat\"\n+array_repeat \"array-slices-repeat\""
    }
  ]
}