{
  "sha": "a19da04b3c3a01699aaf7a59b03f5f008355b23d",
  "node_id": "C_kwDOANOeidoAKGExOWRhMDRiM2MzYTAxNjk5YWFmN2E1OWIwM2Y1ZjAwODM1NWIyM2Q",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-10-12T09:15:13Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-10-14T02:38:46Z"
    },
    "message": "[GOLD] PowerPC64: Don't pretend to support multi-toc\n\nCode in powerpc.cc is pretending to support a per-object toc pointer\nvalue, but powerpc gold has no real support for multi-toc.  This patch\nremoves the pretense, tidying quite a lot in preparation for a\nfollowup patch.  If multi-toc is ever to be supported, don't revert\nthis patch but start by adding object parameter to toc_pointer() and\nan object to Branch_stub_key.\n\n\t* powerpc.cc (Powerpc_relobj::toc_base_offset): Delete.\n\t(Target_powerpc::toc_pointer): New function.  Use throughout.\n\t(Target_powerpc::got_base_offset): New function.  Use throughout..\n\t(Output_data_got_powerpc::got_base_offset): ..in place of\n\tthis.  Delete.\n\t(Output_data_got_powerpc::Output_data_got_powerpc): Init\n\theader_index_ to -1u for 64-bit, and make header here.\n\t(Output_data_got_powerpc::set_final_data_size, reserve_ent): Don't\n\tmake 64-bit header here.\n\t(Output_data_got_powerpc::g_o_t): Return toc pointer offset in\n\tsection for 64-bit.  Use throughout.\n\t(Stub_table): Remove toc_base_off_ from Branch_stub_key, and\n\tobject param on add_long_branch_entry and find_long_branch_entry.\n\tAdjust all uses.",
    "tree": {
      "sha": "cd57c5639e53115156a2a295b23aa77c98a212e3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cd57c5639e53115156a2a295b23aa77c98a212e3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a19da04b3c3a01699aaf7a59b03f5f008355b23d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a19da04b3c3a01699aaf7a59b03f5f008355b23d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a19da04b3c3a01699aaf7a59b03f5f008355b23d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a19da04b3c3a01699aaf7a59b03f5f008355b23d/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cbb35b4ac6d9eb368711f40c127ffeff1921289d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cbb35b4ac6d9eb368711f40c127ffeff1921289d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cbb35b4ac6d9eb368711f40c127ffeff1921289d"
    }
  ],
  "stats": {
    "total": 181,
    "additions": 67,
    "deletions": 114
  },
  "files": [
    {
      "sha": "2d6d34e21e4dbf05f199abb9da435987592fddf0",
      "filename": "gold/powerpc.cc",
      "status": "modified",
      "additions": 67,
      "deletions": 114,
      "changes": 181,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a19da04b3c3a01699aaf7a59b03f5f008355b23d/gold/powerpc.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a19da04b3c3a01699aaf7a59b03f5f008355b23d/gold/powerpc.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gold/powerpc.cc?ref=a19da04b3c3a01699aaf7a59b03f5f008355b23d",
      "patch": "@@ -341,12 +341,6 @@ class Powerpc_relobj : public Sized_relobj_file<size, big_endian>\n \t}\n   }\n \n-  // Return offset in output GOT section that this object will use\n-  // as a TOC pointer.  Won't be just a constant with multi-toc support.\n-  Address\n-  toc_base_offset() const\n-  { return 0x8000; }\n-\n   void\n   set_has_small_toc_reloc()\n   { has_small_toc_reloc_ = true; }\n@@ -1002,6 +996,20 @@ class Target_powerpc : public Sized_target<size, big_endian>\n   Output_data_got_powerpc<size, big_endian>*\n   got_section(Symbol_table*, Layout*);\n \n+  // The toc/got pointer reg will be set to this value.\n+  Address\n+  toc_pointer() const\n+  {\n+    return this->got_->address() + this->got_->g_o_t();\n+  }\n+\n+  // Offset of base used to access the GOT/TOC relative to the GOT section.\n+  Address\n+  got_base_offset() const\n+  {\n+    return this->got_->g_o_t();\n+  }\n+\n   Object*\n   do_make_elf_object(const std::string&, Input_file*, off_t,\n \t\t     const elfcpp::Ehdr<size, big_endian>&);\n@@ -2444,15 +2452,15 @@ Powerpc_relobj<size, big_endian>::make_toc_relative(\n   // With -mcmodel=medium code it is quite possible to have\n   // toc-relative relocs referring to objects outside the TOC.\n   // Don't try to look at a non-existent TOC.\n-  if (this->toc_shndx() == 0)\n+  if (this->toc_shndx() == 0\n+      || this->output_section(this->toc_shndx()) == 0)\n     return false;\n \n   // Convert VALUE back to an address by adding got_base (see below),\n   // then to an offset in the TOC by subtracting the TOC output\n-  // section address and the TOC output offset.  Since this TOC output\n-  // section and the got output section are one and the same, we can\n-  // omit adding and subtracting the output section address.\n-  Address off = (*value + this->toc_base_offset()\n+  // section address and the TOC output offset.\n+  Address off = (*value + target->toc_pointer()\n+\t\t - this->output_section(this->toc_shndx())->address()\n \t\t - this->output_section_offset(this->toc_shndx()));\n   // Is this offset in the TOC?  -mcmodel=medium code may be using\n   // TOC relative access to variables outside the TOC.  Those of\n@@ -2468,8 +2476,7 @@ Powerpc_relobj<size, big_endian>::make_toc_relative(\n   unsigned char* view = this->get_output_view(this->toc_shndx(), &vlen);\n   Address addr = elfcpp::Swap<size, big_endian>::readval(view + off);\n   // The TOC pointer\n-  Address got_base = (target->got_section()->output_section()->address()\n-\t\t      + this->toc_base_offset());\n+  Address got_base = target->toc_pointer();\n   addr -= got_base;\n   if (addr + (uint64_t) 0x80008000 >= (uint64_t) 1 << 32)\n     return false;\n@@ -2487,8 +2494,7 @@ Powerpc_relobj<size, big_endian>::make_got_relative(\n     Address* value)\n {\n   Address addr = psymval->value(this, addend);\n-  Address got_base = (target->got_section()->output_section()->address()\n-\t\t      + this->toc_base_offset());\n+  Address got_base = target->toc_pointer();\n   addr -= got_base;\n   if (addr + 0x80008000 > 0xffffffff)\n     return false;\n@@ -2961,10 +2967,12 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n     : Output_data_got<size, big_endian>(),\n       symtab_(symtab), layout_(layout),\n       header_ent_cnt_(size == 32 ? 3 : 1),\n-      header_index_(size == 32 ? 0x2000 : 0)\n+      header_index_(size == 32 ? 0x2000 : -1u)\n   {\n     if (size == 64)\n       this->set_addralign(256);\n+    if (size == 64)\n+      this->make_header();\n   }\n \n   // Override all the Output_data_got methods we use so as to first call\n@@ -3065,31 +3073,21 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n     return Output_data_got<size, big_endian>::add_constant_pair(c1, c2);\n   }\n \n-  // Offset of _GLOBAL_OFFSET_TABLE_.\n+  // Offset of _GLOBAL_OFFSET_TABLE_ and .TOC. in this section.\n   unsigned int\n   g_o_t() const\n-  {\n-    return this->got_offset(this->header_index_);\n-  }\n-\n-  // Offset of base used to access the GOT/TOC.\n-  // The got/toc pointer reg will be set to this value.\n-  Valtype\n-  got_base_offset(const Powerpc_relobj<size, big_endian>* object) const\n   {\n     if (size == 32)\n-      return this->g_o_t();\n+      return this->got_offset(this->header_index_);\n     else\n-      return (this->output_section()->address()\n-\t      + object->toc_base_offset()\n-\t      - this->address());\n+      return this->got_offset(this->header_index_) + 0x8000;\n   }\n \n   // Ensure our GOT has a header.\n   void\n   set_final_data_size()\n   {\n-    if (this->header_ent_cnt_ != 0)\n+    if (size == 32 && this->header_ent_cnt_ != 0)\n       this->make_header();\n     Output_data_got<size, big_endian>::set_final_data_size();\n   }\n@@ -3104,7 +3102,7 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n     if (size == 32 && this->layout_->dynamic_data() != NULL)\n       val = this->layout_->dynamic_section()->address();\n     if (size == 64)\n-      val = this->output_section()->address() + 0x8000;\n+      val = this->address() + this->g_o_t();\n     this->replace_constant(this->header_index_, val);\n     Output_data_got<size, big_endian>::do_write(of);\n   }\n@@ -3113,7 +3111,7 @@ class Output_data_got_powerpc : public Output_data_got<size, big_endian>\n   void\n   reserve_ent(unsigned int cnt = 1)\n   {\n-    if (this->header_ent_cnt_ == 0)\n+    if (size != 32 || this->header_ent_cnt_ == 0)\n       return;\n     if (this->num_entries() + cnt > this->header_index_)\n       this->make_header();\n@@ -3668,8 +3666,7 @@ Target_powerpc<size, big_endian>::Branch_info::make_stub(\n \t\t\t   && gsym != NULL\n \t\t\t   && gsym->source() == Symbol::IN_OUTPUT_DATA\n \t\t\t   && gsym->output_data() == target->savres_section());\n-\t  ok = stub_table->add_long_branch_entry(this->object_,\n-\t\t\t\t\t\t this->r_type_,\n+\t  ok = stub_table->add_long_branch_entry(this->r_type_,\n \t\t\t\t\t\t from, to, other, save_res);\n \t}\n     }\n@@ -4811,12 +4808,10 @@ class Stub_table : public Output_relaxed_input_section\n \n   // Add a long branch stub.\n   bool\n-  add_long_branch_entry(const Powerpc_relobj<size, big_endian>*,\n-\t\t\tunsigned int, Address, Address, unsigned int, bool);\n+  add_long_branch_entry(unsigned int, Address, Address, unsigned int, bool);\n \n   const Branch_stub_ent*\n-  find_long_branch_entry(const Powerpc_relobj<size, big_endian>*,\n-\t\t\t Address) const;\n+  find_long_branch_entry(Address) const;\n \n   bool\n   can_reach_stub(Address from, unsigned int off, unsigned int r_type)\n@@ -5096,29 +5091,23 @@ class Stub_table : public Output_relaxed_input_section\n   class Branch_stub_key\n   {\n   public:\n-    Branch_stub_key(const Powerpc_relobj<size, big_endian>* obj, Address to)\n-      : dest_(to), toc_base_off_(0)\n-    {\n-      if (size == 64)\n-\ttoc_base_off_ = obj->toc_base_offset();\n-    }\n+    Branch_stub_key(Address to)\n+      : dest_(to)\n+    { }\n \n     bool operator==(const Branch_stub_key& that) const\n     {\n-      return (this->dest_ == that.dest_\n-\t      && (size == 32\n-\t\t  || this->toc_base_off_ == that.toc_base_off_));\n+      return this->dest_ == that.dest_;\n     }\n \n     Address dest_;\n-    unsigned int toc_base_off_;\n   };\n \n   class Branch_stub_key_hash\n   {\n   public:\n     size_t operator()(const Branch_stub_key& key) const\n-    { return key.dest_ ^ key.toc_base_off_; }\n+    { return key.dest_; }\n   };\n \n   // In a sane world this would be a global.\n@@ -5328,14 +5317,13 @@ Stub_table<size, big_endian>::find_plt_call_entry(\n template<int size, bool big_endian>\n bool\n Stub_table<size, big_endian>::add_long_branch_entry(\n-    const Powerpc_relobj<size, big_endian>* object,\n     unsigned int r_type,\n     Address from,\n     Address to,\n     unsigned int other,\n     bool save_res)\n {\n-  Branch_stub_key key(object, to);\n+  Branch_stub_key key(to);\n   bool notoc = (size == 64 && r_type == elfcpp::R_PPC64_REL24_NOTOC);\n   Branch_stub_ent ent(this->branch_size_, notoc, save_res);\n   std::pair<typename Branch_stub_entries::iterator, bool> p\n@@ -5380,11 +5368,9 @@ Stub_table<size, big_endian>::add_long_branch_entry(\n \n template<int size, bool big_endian>\n const typename Stub_table<size, big_endian>::Branch_stub_ent*\n-Stub_table<size, big_endian>::find_long_branch_entry(\n-    const Powerpc_relobj<size, big_endian>* object,\n-    Address to) const\n+Stub_table<size, big_endian>::find_long_branch_entry(Address to) const\n {\n-  Branch_stub_key key(object, to);\n+  Branch_stub_key key(to);\n   typename Branch_stub_entries::const_iterator p\n     = this->long_branch_stubs_.find(key);\n   if (p == this->long_branch_stubs_.end())\n@@ -6104,11 +6090,7 @@ Stub_table<size, big_endian>::plt_call_size(\n \t    }\n \t  if (p->second.r2save_)\n \t    bytes += 4;\n-\t  uint64_t got_addr\n-\t    = this->targ_->got_section()->output_section()->address();\n-\t  const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n-\t    <const Powerpc_relobj<size, big_endian>*>(p->first.object_);\n-\t  got_addr += ppcobj->toc_base_offset();\n+\t  uint64_t got_addr = this->targ_->toc_pointer();\n \t  uint64_t off = plt_addr - got_addr;\n \t  bytes += 3 * 4 + 4 * (ha(off) != 0);\n \t}\n@@ -6169,10 +6151,7 @@ Stub_table<size, big_endian>::plt_call_size(\n \t  return bytes + tail;\n \t}\n \n-      uint64_t got_addr = this->targ_->got_section()->output_section()->address();\n-      const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n-\t<const Powerpc_relobj<size, big_endian>*>(p->first.object_);\n-      got_addr += ppcobj->toc_base_offset();\n+      uint64_t got_addr = this->targ_->toc_pointer();\n       uint64_t off = plt_addr - got_addr;\n       bytes += 3 * 4 + 4 * (ha(off) != 0);\n       if (this->targ_->abiversion() < 2)\n@@ -6293,10 +6272,6 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n   if (size == 64\n       && this->targ_->power10_stubs())\n     {\n-      const Output_data_got_powerpc<size, big_endian>* got\n-\t= this->targ_->got_section();\n-      Address got_os_addr = got->output_section()->address();\n-\n       if (!this->plt_call_stubs_.empty())\n \t{\n \t  // Write out plt call stubs.\n@@ -6333,10 +6308,7 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t\t    = cs->second.r2save_ && !cs->second.localentry0_;\n \t\t\t  this->build_tls_opt_head(&p, save_lr);\n \t\t\t}\n-\t\t      const Powerpc_relobj<size, big_endian>* ppcobj\n-\t\t\t= static_cast<const Powerpc_relobj<size, big_endian>*>(\n-\t\t\t    cs->first.object_);\n-\t\t      Address got_addr = got_os_addr + ppcobj->toc_base_offset();\n+\t\t      Address got_addr = this->targ_->toc_pointer();\n \t\t      Address off = plt_addr - got_addr;\n \n \t\t      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)\n@@ -6438,7 +6410,7 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t\t= this->targ_->find_branch_lookup_table(bs->first.dest_);\n \t\t      gold_assert(brlt_addr != invalid_address);\n \t\t      brlt_addr += this->targ_->brlt_section()->address();\n-\t\t      Address got_addr = got_os_addr + bs->first.toc_base_off_;\n+\t\t      Address got_addr = this->targ_->toc_pointer();\n \t\t      Address brltoff = brlt_addr - got_addr;\n \t\t      if (ha(brltoff) == 0)\n \t\t\t{\n@@ -6487,9 +6459,6 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n     }\n   else if (size == 64)\n     {\n-      const Output_data_got_powerpc<size, big_endian>* got\n-\t= this->targ_->got_section();\n-      Address got_os_addr = got->output_section()->address();\n \n       if (!this->plt_call_stubs_.empty()\n \t  && this->targ_->abiversion() >= 2)\n@@ -6523,9 +6492,7 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t}\n \t      else\n \t\t{\n-\t\t  const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n-\t\t    <const Powerpc_relobj<size, big_endian>*>(cs->first.object_);\n-\t\t  Address got_addr = got_os_addr + ppcobj->toc_base_offset();\n+\t\t  Address got_addr = this->targ_->toc_pointer();\n \t\t  Address off = plt_addr - got_addr;\n \n \t\t  if (off + 0x80008000 > 0xffffffff || (off & 7) != 0)\n@@ -6565,9 +6532,7 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t      const Output_data_plt_powerpc<size, big_endian>* plt;\n \t      Address pltoff = this->plt_off(cs, &plt);\n \t      Address plt_addr = pltoff + plt->address();\n-\t      const Powerpc_relobj<size, big_endian>* ppcobj = static_cast\n-\t\t<const Powerpc_relobj<size, big_endian>*>(cs->first.object_);\n-\t      Address got_addr = got_os_addr + ppcobj->toc_base_offset();\n+\t      Address got_addr = this->targ_->toc_pointer();\n \t      Address off = plt_addr - got_addr;\n \n \t      if (off + 0x80008000 > 0xffffffff || (off & 7) != 0\n@@ -6711,7 +6676,7 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t= this->targ_->find_branch_lookup_table(bs->first.dest_);\n \t      gold_assert(brlt_addr != invalid_address);\n \t      brlt_addr += this->targ_->brlt_section()->address();\n-\t      Address got_addr = got_os_addr + bs->first.toc_base_off_;\n+\t      Address got_addr = this->targ_->toc_pointer();\n \t      Address brltoff = brlt_addr - got_addr;\n \t      if (ha(brltoff) == 0)\n \t\t{\n@@ -6773,11 +6738,7 @@ Stub_table<size, big_endian>::do_write(Output_file* of)\n \t\t  else\n \t\t    {\n \t\t      if (g_o_t == invalid_address)\n-\t\t\t{\n-\t\t\t  const Output_data_got_powerpc<size, big_endian>* got\n-\t\t\t    = this->targ_->got_section();\n-\t\t\t  g_o_t = got->address() + got->g_o_t();\n-\t\t\t}\n+\t\t\tg_o_t = this->targ_->toc_pointer();\n \t\t      got_addr = g_o_t;\n \t\t    }\n \n@@ -6979,10 +6940,8 @@ Output_data_glink<size, big_endian>::do_write(Output_file* of)\n     }\n   else\n     {\n-      const Output_data_got_powerpc<size, big_endian>* got\n-\t= this->targ_->got_section();\n       // The address of _GLOBAL_OFFSET_TABLE_.\n-      Address g_o_t = got->address() + got->g_o_t();\n+      Address g_o_t = this->targ_->toc_pointer();\n \n       // Write out pltresolve branch table.\n       p = oview;\n@@ -8016,12 +7975,13 @@ Target_powerpc<size, big_endian>::Scan::local(\n \t      break;\n \n \t    Reloc_section* rela_dyn = target->rela_dyn_section(layout);\n-\t    Powerpc_relobj<size, big_endian>* symobj = ppc_object;\n+\t    Address got_off = (target->toc_pointer()\n+\t\t\t       - got->output_section()->address());\n \t    rela_dyn->add_output_section_relative(got->output_section(),\n \t\t\t\t\t\t  elfcpp::R_POWERPC_RELATIVE,\n \t\t\t\t\t\t  output_section,\n \t\t\t\t\t\t  object, data_shndx, off,\n-\t\t\t\t\t\t  symobj->toc_base_offset());\n+\t\t\t\t\t\t  got_off);\n \t  }\n       }\n       break;\n@@ -8729,15 +8689,13 @@ Target_powerpc<size, big_endian>::Scan::global(\n \t      break;\n \n \t    Reloc_section* rela_dyn = target->rela_dyn_section(layout);\n-\t    Powerpc_relobj<size, big_endian>* symobj = ppc_object;\n-\t    if (data_shndx != ppc_object->opd_shndx())\n-\t      symobj = static_cast\n-\t\t<Powerpc_relobj<size, big_endian>*>(gsym->object());\n+\t    Address got_off = (target->toc_pointer()\n+\t\t\t       - got->output_section()->address());\n \t    rela_dyn->add_output_section_relative(got->output_section(),\n \t\t\t\t\t\t  elfcpp::R_POWERPC_RELATIVE,\n \t\t\t\t\t\t  output_section,\n \t\t\t\t\t\t  object, data_shndx, off,\n-\t\t\t\t\t\t  symobj->toc_base_offset());\n+\t\t\t\t\t\t  got_off);\n \t  }\n       }\n       break;\n@@ -10638,8 +10596,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t{\n \t  if (r_type != elfcpp::R_PPC64_PLT_PCREL34\n \t      && r_type != elfcpp::R_PPC64_PLT_PCREL34_NOTOC)\n-\t    value -= (target->got_section()->output_section()->address()\n-\t\t      + object->toc_base_offset());\n+\t    value -= target->toc_pointer();\n \t}\n       else if (parameters->options().output_is_position_independent())\n \t{\n@@ -10651,8 +10608,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t\t\t+ rela.get_r_addend());\n \t    }\n \t  else\n-\t    value -= (target->got_section()->address()\n-\t\t      + target->got_section()->g_o_t());\n+\t    value -= target->toc_pointer();\n \t}\n     }\n   else if (!has_plt_offset\n@@ -10683,12 +10639,11 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       if (r_type == elfcpp::R_PPC64_GOT_PCREL34)\n \tvalue += target->got_section()->address();\n       else\n-\tvalue -= target->got_section()->got_base_offset(object);\n+\tvalue -= target->got_base_offset();\n     }\n   else if (r_type == elfcpp::R_PPC64_TOC)\n     {\n-      value = (target->got_section()->output_section()->address()\n-\t       + object->toc_base_offset());\n+      value = target->toc_pointer();\n     }\n   else if (gsym != NULL\n \t   && (r_type == elfcpp::R_POWERPC_REL24\n@@ -10787,7 +10742,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t  if (r_type == elfcpp::R_PPC64_GOT_TLSGD_PCREL34)\n \t    value += target->got_section()->address();\n \t  else\n-\t    value -= target->got_section()->got_base_offset(object);\n+\t    value -= target->got_base_offset();\n \t}\n       if (tls_type == tls::TLSOPT_TO_IE)\n \t{\n@@ -10880,7 +10835,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t  if (r_type == elfcpp::R_PPC64_GOT_TLSLD_PCREL34)\n \t    value += target->got_section()->address();\n \t  else\n-\t    value -= target->got_section()->got_base_offset(object);\n+\t    value -= target->got_base_offset();\n \t}\n       else\n \t{\n@@ -10938,7 +10893,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n       if (r_type == elfcpp::R_PPC64_GOT_DTPREL_PCREL34)\n \tvalue += target->got_section()->address();\n       else\n-\tvalue -= target->got_section()->got_base_offset(object);\n+\tvalue -= target->got_base_offset();\n     }\n   else if (r_type == elfcpp::R_POWERPC_GOT_TPREL16\n \t   || r_type == elfcpp::R_POWERPC_GOT_TPREL16_LO\n@@ -10959,7 +10914,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t  if (r_type == elfcpp::R_PPC64_GOT_TPREL_PCREL34)\n \t    value += target->got_section()->address();\n \t  else\n-\t    value -= target->got_section()->got_base_offset(object);\n+\t    value -= target->got_base_offset();\n \t}\n       else\n \t{\n@@ -11198,7 +11153,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \t  if (stub_table != NULL)\n \t    {\n \t      const typename Stub_table<size, big_endian>::Branch_stub_ent* ent\n-\t\t= stub_table->find_long_branch_entry(object, value);\n+\t\t= stub_table->find_long_branch_entry(value);\n \t      if (ent != NULL)\n \t\t{\n \t\t  if (ent->save_res_)\n@@ -11271,8 +11226,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n     case elfcpp::R_PPC64_TOC16_DS:\n     case elfcpp::R_PPC64_TOC16_LO_DS:\n       // Subtract the TOC base address.\n-      value -= (target->got_section()->output_section()->address()\n-\t\t+ object->toc_base_offset());\n+      value -= target->toc_pointer();\n       break;\n \n     case elfcpp::R_POWERPC_SECTOFF:\n@@ -11595,8 +11549,7 @@ Target_powerpc<size, big_endian>::Relocate::relocate(\n \tcase elfcpp::R_PPC64_ENTRY:\n \t  if (size == 64)\n \t    {\n-\t      value = (target->got_section()->output_section()->address()\n-\t\t       + object->toc_base_offset());\n+\t      value = target->toc_pointer();\n \t      if (value + 0x80008000 <= 0xffffffff\n \t\t  && !parameters->options().output_is_position_independent())\n \t\t{"
    }
  ]
}