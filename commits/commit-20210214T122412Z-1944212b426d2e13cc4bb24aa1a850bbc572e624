{
  "sha": "1944212b426d2e13cc4bb24aa1a850bbc572e624",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTk0NDIxMmI0MjZkMmUxM2NjNGJiMjRhYTFhODUwYmJjNTcyZTYyNA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-02-14T06:10:01Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-02-14T12:24:12Z"
    },
    "message": "objdump: don't add an extra entry to syms array\n\nSpace for a NULL is there in every backend bfd_get_symtab_upper_bound\nor bfd_get_dynamic_symtab_upper_bound when the symbol count is non-zero,\nand placed as a terminator by bfd_canonicalize_symtab.  Many backends\neven return a single NULL entry array for zero symbol count, and while\nthere are a few that return a NULL array for no symbols, that case is\nhandled fine in objdump.  So don't have objdump add yet another NULL\nentry.\n\n\t* objdump.c (slurp_symtab): Don't add an extra entry for NULL\n\tto the symbol array.\n\t(slurp_dynamic_symtab): Likewise.\n\t(dump_bfd): Formatting.  Copy terminating NULL from extra_syms.",
    "tree": {
      "sha": "2eeb87749918f031c33dc4a8a64c2a3f5e077e6e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2eeb87749918f031c33dc4a8a64c2a3f5e077e6e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1944212b426d2e13cc4bb24aa1a850bbc572e624",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1944212b426d2e13cc4bb24aa1a850bbc572e624",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1944212b426d2e13cc4bb24aa1a850bbc572e624",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1944212b426d2e13cc4bb24aa1a850bbc572e624/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0d0a0d86c841a95226d9cc7c247c770c38fdc81b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0d0a0d86c841a95226d9cc7c247c770c38fdc81b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0d0a0d86c841a95226d9cc7c247c770c38fdc81b"
    }
  ],
  "stats": {
    "total": 60,
    "additions": 32,
    "deletions": 28
  },
  "files": [
    {
      "sha": "12ff93dc53abe3060dbc70289b414e1de4bbb36c",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1944212b426d2e13cc4bb24aa1a850bbc572e624/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1944212b426d2e13cc4bb24aa1a850bbc572e624/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=1944212b426d2e13cc4bb24aa1a850bbc572e624",
      "patch": "@@ -1,3 +1,10 @@\n+2021-02-14  Alan Modra  <amodra@gmail.com>\n+\n+\t* objdump.c (slurp_symtab): Don't add an extra entry for NULL\n+\tto the symbol array.\n+\t(slurp_dynamic_symtab): Likewise.\n+\t(dump_bfd): Formatting.  Copy terminating NULL from extra_syms.\n+\n 2021-02-14  Alan Modra  <amodra@gmail.com>\n \n \t* Makefile.in: Regenerate."
    },
    {
      "sha": "304785009bfab54efd409c57cfd0e9374688465d",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 25,
      "deletions": 28,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1944212b426d2e13cc4bb24aa1a850bbc572e624/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1944212b426d2e13cc4bb24aa1a850bbc572e624/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=1944212b426d2e13cc4bb24aa1a850bbc572e624",
      "patch": "@@ -748,32 +748,33 @@ slurp_symtab (bfd *abfd)\n       non_fatal (_(\"failed to read symbol table from: %s\"), bfd_get_filename (abfd));\n       bfd_fatal (_(\"error message was\"));\n     }\n-  /* Add an extra entry (at the end) with a NULL pointer.  */\n-  storage += sizeof (asymbol *);\n \n-  off_t filesize = bfd_get_file_size (abfd);\n-\n-  /* qv PR 24707.  */\n-  if (filesize > 0\n-      && filesize < storage\n-      /* The MMO file format supports its own special compression\n-\t technique, so its sections can be larger than the file size.  */\n-      && bfd_get_flavour (abfd) != bfd_target_mmo_flavour)\t  \n+  if (storage)\n     {\n-      bfd_nonfatal_message (bfd_get_filename (abfd), abfd, NULL,\n-\t\t\t    _(\"error: symbol table size (%#lx) is larger than filesize (%#lx)\"),\n-\t\t\t    storage, (long) filesize);\n-      exit_status = 1;\n-      symcount = 0;\n-      return NULL;\n+      off_t filesize = bfd_get_file_size (abfd);\n+\n+      /* qv PR 24707.  */\n+      if (filesize > 0\n+\t  && filesize < storage\n+\t  /* The MMO file format supports its own special compression\n+\t     technique, so its sections can be larger than the file size.  */\n+\t  && bfd_get_flavour (abfd) != bfd_target_mmo_flavour)\n+\t{\n+\t  bfd_nonfatal_message (bfd_get_filename (abfd), abfd, NULL,\n+\t\t\t\t_(\"error: symbol table size (%#lx) \"\n+\t\t\t\t  \"is larger than filesize (%#lx)\"),\n+\t\t\t\tstorage, (long) filesize);\n+\t  exit_status = 1;\n+\t  symcount = 0;\n+\t  return NULL;\n+\t}\n+\n+      sy = (asymbol **) xmalloc (storage);\n     }\n \n-  sy = (asymbol **) xmalloc (storage);\n   symcount = bfd_canonicalize_symtab (abfd, sy);\n   if (symcount < 0)\n     bfd_fatal (bfd_get_filename (abfd));\n-  /* assert (symcount < (storage / sizeof (asymbol *))) */\n-  sy[symcount] = NULL;\n   return sy;\n }\n \n@@ -786,7 +787,6 @@ slurp_dynamic_symtab (bfd *abfd)\n   long storage;\n \n   storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n-  /* Add an extra entry (at the end) with a NULL pointer.  */\n   if (storage < 0)\n     {\n       if (!(bfd_get_file_flags (abfd) & DYNAMIC))\n@@ -800,14 +800,12 @@ slurp_dynamic_symtab (bfd *abfd)\n       bfd_fatal (bfd_get_filename (abfd));\n     }\n \n-  storage += sizeof (asymbol *);\n-  sy = (asymbol **) xmalloc (storage);\n+  if (storage)\n+    sy = (asymbol **) xmalloc (storage);\n \n   dynsymcount = bfd_canonicalize_dynamic_symtab (abfd, sy);\n   if (dynsymcount < 0)\n     bfd_fatal (bfd_get_filename (abfd));\n-  /* assert (symcount < (storage / sizeof (asymbol *))) */\n-  sy[dynsymcount] = NULL;\n   return sy;\n }\n \n@@ -4915,12 +4913,11 @@ dump_bfd (bfd *abfd, bfd_boolean is_mainfile)\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      syms = xrealloc (syms, (symcount + old_symcount + 1) * sizeof (asymbol *));\n+\t\t      syms = xrealloc (syms, ((symcount + old_symcount + 1)\n+\t\t\t\t\t      * sizeof (asymbol *)));\n \t\t      memcpy (syms + old_symcount,\n \t\t\t      extra_syms,\n-\t\t\t      symcount * sizeof (asymbol *));\n-\t\t      /* Preserve the NULL entry at the end of the symbol table.  */\n-\t\t      syms[symcount + old_symcount] = NULL;\n+\t\t\t      (symcount + 1) * sizeof (asymbol *));\n \t\t    }\n \t\t}\n "
    }
  ]
}