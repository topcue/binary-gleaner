{
  "sha": "7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb",
  "node_id": "C_kwDOANOeidoAKDdjOGJiMmVkMWMyMjBlMGE4ZDdhZThkYmI1MTRlNDg0YzA1NzNhY2I",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-15T20:17:44Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-17T22:07:09Z"
    },
    "message": "Add new gdbarch generator\n\nThe new gdbarch generator is a Python program.  It reads the\n\"components.py\" that was created in the previous patch, and generates\ngdbarch.c and gdbarch-gen.h.\n\nThis is a relatively straightforward translation of the existing .sh\ncode.  It doesn't try very hard to be idiomatic Python or to be\nespecially smart.\n\nIt is, however, incredibly faster:\n\n    $ time ./gdbarch.sh\n\n    real\t0m8.197s\n    user\t0m5.779s\n    sys\t0m3.384s\n\n    $ time ./gdbarch.py\n\n    real\t0m0.065s\n    user\t0m0.053s\n    sys\t0m0.011s\n\nCo-Authored-By: Tom Tromey <tom@tromey.com>",
    "tree": {
      "sha": "5cf5cda9624f74a4eef85ac87e4b891bb7933dec",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5cf5cda9624f74a4eef85ac87e4b891bb7933dec"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "65b1aa7501ace4c58fb5062479c710d0bdff6f34",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/65b1aa7501ace4c58fb5062479c710d0bdff6f34",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/65b1aa7501ace4c58fb5062479c710d0bdff6f34"
    }
  ],
  "stats": {
    "total": 526,
    "additions": 526,
    "deletions": 0
  },
  "files": [
    {
      "sha": "2f72f8befa4f08f312340918dca6823bce605414",
      "filename": "gdb/gdbarch.py",
      "status": "added",
      "additions": 526,
      "deletions": 0,
      "changes": 526,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb/gdb/gdbarch.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb/gdb/gdbarch.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.py?ref=7c8bb2ed1c220e0a8d7ae8dbb514e484c0573acb",
      "patch": "@@ -0,0 +1,526 @@\n+#!/usr/bin/env python3\n+\n+# Architecture commands for GDB, the GNU debugger.\n+#\n+# Copyright (C) 1998-2021 Free Software Foundation, Inc.\n+#\n+# This file is part of GDB.\n+#\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+import textwrap\n+\n+# All the components created in gdbarch-components.py.\n+components = []\n+\n+\n+def join_type_and_name(t, n):\n+    \"Combine the type T and the name N into a C declaration.\"\n+    if t.endswith(\"*\") or t.endswith(\"&\"):\n+        return t + n\n+    else:\n+        return t + \" \" + n\n+\n+\n+def join_params(params):\n+    \"\"\"Given a sequence of (TYPE, NAME) pairs, generate a comma-separated\n+    list of declarations.\"\"\"\n+    params = [join_type_and_name(p[0], p[1]) for p in params]\n+    return \", \".join(params)\n+\n+\n+class _Component:\n+    \"Base class for all components.\"\n+\n+    def __init__(self, **kwargs):\n+        for key in kwargs:\n+            setattr(self, key, kwargs[key])\n+        components.append(self)\n+\n+    def get_predicate(self):\n+        \"Return the expression used for validity checking.\"\n+        assert self.predicate and not isinstance(self.invalid, str)\n+        if self.predefault:\n+            predicate = f\"gdbarch->{self.name} != {self.predefault}\"\n+        elif isinstance(c, Value):\n+            predicate = f\"gdbarch->{self.name} != 0\"\n+        else:\n+            predicate = f\"gdbarch->{self.name} != NULL\"\n+        return predicate\n+\n+\n+class Info(_Component):\n+    \"An Info component is copied from the gdbarch_info.\"\n+\n+    def __init__(self, *, name, type, printer=None):\n+        super().__init__(name=name, type=type, printer=printer)\n+        # This little hack makes the generator a bit simpler.\n+        self.predicate = None\n+\n+\n+class Value(_Component):\n+    \"A Value component is just a data member.\"\n+\n+    def __init__(\n+        self,\n+        *,\n+        name,\n+        type,\n+        comment=None,\n+        predicate=None,\n+        predefault=None,\n+        postdefault=None,\n+        invalid=None,\n+        printer=None,\n+    ):\n+        super().__init__(\n+            comment=comment,\n+            name=name,\n+            type=type,\n+            predicate=predicate,\n+            predefault=predefault,\n+            postdefault=postdefault,\n+            invalid=invalid,\n+            printer=printer,\n+        )\n+\n+\n+class Function(_Component):\n+    \"A Function component is a function pointer member.\"\n+\n+    def __init__(\n+        self,\n+        *,\n+        name,\n+        type,\n+        params,\n+        comment=None,\n+        predicate=None,\n+        predefault=None,\n+        postdefault=None,\n+        invalid=None,\n+        printer=None,\n+    ):\n+        super().__init__(\n+            comment=comment,\n+            name=name,\n+            type=type,\n+            predicate=predicate,\n+            predefault=predefault,\n+            postdefault=postdefault,\n+            invalid=invalid,\n+            printer=printer,\n+            params=params,\n+        )\n+\n+    def ftype(self):\n+        \"Return the name of the function typedef to use.\"\n+        return f\"gdbarch_{self.name}_ftype\"\n+\n+    def param_list(self):\n+        \"Return the formal parameter list as a string.\"\n+        return join_params(self.params)\n+\n+    def set_list(self):\n+        \"\"\"Return the formal parameter list of the caller function,\n+        as a string.  This list includes the gdbarch.\"\"\"\n+        arch_arg = (\"struct gdbarch *\", \"gdbarch\")\n+        arch_tuple = [arch_arg]\n+        return join_params(arch_tuple + list(self.params))\n+\n+    def actuals(self):\n+        \"Return the actual parameters to forward, as a string.\"\n+        return \", \".join([p[1] for p in self.params])\n+\n+\n+class Method(Function):\n+    \"A Method is like a Function but passes the gdbarch through.\"\n+\n+    def param_list(self):\n+        \"See superclass.\"\n+        return self.set_list()\n+\n+    def actuals(self):\n+        \"See superclass.\"\n+        result = [\"gdbarch\"] + [p[1] for p in self.params]\n+        return \", \".join(result)\n+\n+\n+# Read the components.\n+with open(\"gdbarch-components.py\") as fd:\n+    exec(fd.read())\n+\n+copyright = \"\"\"/* *INDENT-OFF* */ /* THIS FILE IS GENERATED -*- buffer-read-only: t -*- */\n+/* vi:set ro: */\n+\n+/* Dynamic architecture support for GDB, the GNU debugger.\n+\n+   Copyright (C) 1998-2021 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* This file was created with the aid of ``gdbarch.py''.  */\n+\"\"\"\n+\n+\n+def info(c):\n+    \"Filter function to only allow Info components.\"\n+    return type(c) is Info\n+\n+\n+def not_info(c):\n+    \"Filter function to omit Info components.\"\n+    return type(c) is not Info\n+\n+\n+with open(\"gdbarch-gen.h\", \"w\") as f:\n+    print(copyright, file=f)\n+    print(file=f)\n+    print(file=f)\n+    print(\"/* The following are pre-initialized by GDBARCH.  */\", file=f)\n+\n+    # Do Info components first.\n+    for c in filter(info, components):\n+        print(file=f)\n+        print(\n+            f\"\"\"extern {c.type} gdbarch_{c.name} (struct gdbarch *gdbarch);\n+/* set_gdbarch_{c.name}() - not applicable - pre-initialized.  */\"\"\",\n+            file=f,\n+        )\n+\n+    print(file=f)\n+    print(file=f)\n+    print(\"/* The following are initialized by the target dependent code.  */\", file=f)\n+\n+    # Generate decls for accessors, setters, and predicates for all\n+    # non-Info components.\n+    for c in filter(not_info, components):\n+        if c.comment:\n+            print(file=f)\n+            comment = c.comment.split(\"\\n\")\n+            if comment[0] == \"\":\n+                comment = comment[1:]\n+            if comment[-1] == \"\":\n+                comment = comment[:-1]\n+            print(\"/* \", file=f, end=\"\")\n+            print(comment[0], file=f, end=\"\")\n+            if len(comment) > 1:\n+                print(file=f)\n+                print(\n+                    textwrap.indent(\"\\n\".join(comment[1:]), prefix=\"   \"),\n+                    end=\"\",\n+                    file=f,\n+                )\n+            print(\" */\", file=f)\n+\n+        if c.predicate:\n+            print(file=f)\n+            print(f\"extern bool gdbarch_{c.name}_p (struct gdbarch *gdbarch);\", file=f)\n+\n+        print(file=f)\n+        if isinstance(c, Value):\n+            print(\n+                f\"extern {c.type} gdbarch_{c.name} (struct gdbarch *gdbarch);\",\n+                file=f,\n+            )\n+            print(\n+                f\"extern void set_gdbarch_{c.name} (struct gdbarch *gdbarch, {c.type} {c.name});\",\n+                file=f,\n+            )\n+        else:\n+            assert isinstance(c, Function)\n+            print(\n+                f\"typedef {c.type} ({c.ftype()}) ({c.param_list()});\",\n+                file=f,\n+            )\n+            print(\n+                f\"extern {c.type} gdbarch_{c.name} ({c.set_list()});\",\n+                file=f,\n+            )\n+            print(\n+                f\"extern void set_gdbarch_{c.name} (struct gdbarch *gdbarch, {c.ftype()} *{c.name});\",\n+                file=f,\n+            )\n+\n+with open(\"gdbarch.c\", \"w\") as f:\n+    print(copyright, file=f)\n+    print(file=f)\n+    print(\"/* Maintain the struct gdbarch object.  */\", file=f)\n+    print(file=f)\n+    #\n+    # The struct definition body.\n+    #\n+    print(\"struct gdbarch\", file=f)\n+    print(\"{\", file=f)\n+    print(\"  /* Has this architecture been fully initialized?  */\", file=f)\n+    print(\"  int initialized_p;\", file=f)\n+    print(file=f)\n+    print(\"  /* An obstack bound to the lifetime of the architecture.  */\", file=f)\n+    print(\"  struct obstack *obstack;\", file=f)\n+    print(file=f)\n+    print(\"  /* basic architectural information.  */\", file=f)\n+    for c in filter(info, components):\n+        print(f\"  {c.type} {c.name};\", file=f)\n+    print(file=f)\n+    print(\"  /* target specific vector.  */\", file=f)\n+    print(\"  struct gdbarch_tdep *tdep;\", file=f)\n+    print(\"  gdbarch_dump_tdep_ftype *dump_tdep;\", file=f)\n+    print(file=f)\n+    print(\"  /* per-architecture data-pointers.  */\", file=f)\n+    print(\"  unsigned nr_data;\", file=f)\n+    print(\"  void **data;\", file=f)\n+    print(file=f)\n+    for c in filter(not_info, components):\n+        if isinstance(c, Value):\n+            print(f\"  {c.type} {c.name};\", file=f)\n+        else:\n+            assert isinstance(c, Function)\n+            print(f\"  gdbarch_{c.name}_ftype *{c.name};\", file=f)\n+    print(\"};\", file=f)\n+    print(file=f)\n+    #\n+    # Initialization.\n+    #\n+    print(\"/* Create a new ``struct gdbarch'' based on information provided by\", file=f)\n+    print(\"   ``struct gdbarch_info''.  */\", file=f)\n+    print(file=f)\n+    print(\"struct gdbarch *\", file=f)\n+    print(\"gdbarch_alloc (const struct gdbarch_info *info,\", file=f)\n+    print(\"\t       struct gdbarch_tdep *tdep)\", file=f)\n+    print(\"{\", file=f)\n+    print(\"  struct gdbarch *gdbarch;\", file=f)\n+    print(\"\", file=f)\n+    print(\n+        \"  /* Create an obstack for allocating all the per-architecture memory,\", file=f\n+    )\n+    print(\"     then use that to allocate the architecture vector.  */\", file=f)\n+    print(\"  struct obstack *obstack = XNEW (struct obstack);\", file=f)\n+    print(\"  obstack_init (obstack);\", file=f)\n+    print(\"  gdbarch = XOBNEW (obstack, struct gdbarch);\", file=f)\n+    print(\"  memset (gdbarch, 0, sizeof (*gdbarch));\", file=f)\n+    print(\"  gdbarch->obstack = obstack;\", file=f)\n+    print(file=f)\n+    print(\"  alloc_gdbarch_data (gdbarch);\", file=f)\n+    print(file=f)\n+    print(\"  gdbarch->tdep = tdep;\", file=f)\n+    print(file=f)\n+    for c in filter(info, components):\n+        print(f\"  gdbarch->{c.name} = info->{c.name};\", file=f)\n+    print(file=f)\n+    print(\"  /* Force the explicit initialization of these.  */\", file=f)\n+    for c in filter(not_info, components):\n+        if c.predefault and c.predefault != \"0\":\n+            print(f\"  gdbarch->{c.name} = {c.predefault};\", file=f)\n+    print(\"  /* gdbarch_alloc() */\", file=f)\n+    print(file=f)\n+    print(\"  return gdbarch;\", file=f)\n+    print(\"}\", file=f)\n+    print(file=f)\n+    print(file=f)\n+    print(file=f)\n+    #\n+    # Post-initialization validation and updating\n+    #\n+    print(\"/* Ensure that all values in a GDBARCH are reasonable.  */\", file=f)\n+    print(file=f)\n+    print(\"static void\", file=f)\n+    print(\"verify_gdbarch (struct gdbarch *gdbarch)\", file=f)\n+    print(\"{\", file=f)\n+    print(\"  string_file log;\", file=f)\n+    print(file=f)\n+    print(\"  /* fundamental */\", file=f)\n+    print(\"  if (gdbarch->byte_order == BFD_ENDIAN_UNKNOWN)\", file=f)\n+    print(\"\"\"    log.puts (\"\\\\n\\\\tbyte-order\");\"\"\", file=f)\n+    print(\"  if (gdbarch->bfd_arch_info == NULL)\", file=f)\n+    print(\"\"\"    log.puts (\"\\\\n\\\\tbfd_arch_info\");\"\"\", file=f)\n+    print(\n+        \"  /* Check those that need to be defined for the given multi-arch level.  */\",\n+        file=f,\n+    )\n+    for c in filter(not_info, components):\n+        if c.invalid is False:\n+            print(f\"  /* Skip verify of {c.name}, invalid_p == 0 */\", file=f)\n+        elif c.predicate:\n+            print(f\"  /* Skip verify of {c.name}, has predicate.  */\", file=f)\n+        elif isinstance(c.invalid, str) and c.postdefault is not None:\n+            print(f\"  if ({c.invalid})\", file=f)\n+            print(f\"    gdbarch->{c.name} = {c.postdefault};\", file=f)\n+        elif c.predefault is not None and c.postdefault is not None:\n+            print(f\"  if (gdbarch->{c.name} == {c.predefault})\", file=f)\n+            print(f\"    gdbarch->{c.name} = {c.postdefault};\", file=f)\n+        elif c.postdefault is not None:\n+            print(f\"  if (gdbarch->{c.name} == 0)\", file=f)\n+            print(f\"    gdbarch->{c.name} = {c.postdefault};\", file=f)\n+        elif isinstance(c.invalid, str):\n+            print(f\"  if ({c.invalid})\", file=f)\n+            print(f\"\"\"    log.puts (\"\\\\n\\\\t{c.name}\");\"\"\", file=f)\n+        elif c.predefault is not None:\n+            print(f\"  if (gdbarch->{c.name} == {c.predefault})\", file=f)\n+            print(f\"\"\"    log.puts (\"\\\\n\\\\t{c.name}\");\"\"\", file=f)\n+    print(\"  if (!log.empty ())\", file=f)\n+    print(\"    internal_error (__FILE__, __LINE__,\", file=f)\n+    print(\"\"\"\t\t    _(\"verify_gdbarch: the following are invalid ...%s\"),\"\"\", file=f)\n+    print(\"\t\t    log.c_str ());\", file=f)\n+    print(\"}\", file=f)\n+    print(file=f)\n+    print(file=f)\n+    #\n+    # Dumping.\n+    #\n+    print(\"/* Print out the details of the current architecture.  */\", file=f)\n+    print(file=f)\n+    print(\"void\", file=f)\n+    print(\"gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\", file=f)\n+    print(\"{\", file=f)\n+    print(\"\"\"  const char *gdb_nm_file = \"<not-defined>\";\"\"\", file=f)\n+    print(file=f)\n+    print(\"#if defined (GDB_NM_FILE)\", file=f)\n+    print(\"  gdb_nm_file = GDB_NM_FILE;\", file=f)\n+    print(\"#endif\", file=f)\n+    print(\"  fprintf_unfiltered (file,\", file=f)\n+    print(\"\"\"\t\t      \"gdbarch_dump: GDB_NM_FILE = %s\\\\n\",\"\"\", file=f)\n+    print(\"\t\t      gdb_nm_file);\", file=f)\n+    for c in components:\n+        if c.predicate:\n+            print(\"  fprintf_unfiltered (file,\", file=f)\n+            print(\n+                f\"\"\"                      \"gdbarch_dump: gdbarch_{c.name}_p() = %d\\\\n\",\"\"\",\n+                file=f,\n+            )\n+            print(f\"                      gdbarch_{c.name}_p (gdbarch));\", file=f)\n+        if isinstance(c, Function):\n+            print(\"  fprintf_unfiltered (file,\", file=f)\n+            print(\n+                f\"\"\"                      \"gdbarch_dump: {c.name} = <%s>\\\\n\",\"\"\", file=f\n+            )\n+            print(\n+                f\"                      host_address_to_string (gdbarch->{c.name}));\",\n+                file=f,\n+            )\n+        else:\n+            if c.printer:\n+                printer = c.printer\n+            elif c.type == \"CORE_ADDR\":\n+                printer = f\"core_addr_to_string_nz (gdbarch->{c.name})\"\n+            else:\n+                printer = f\"plongest (gdbarch->{c.name})\"\n+            print(\"  fprintf_unfiltered (file,\", file=f)\n+            print(\n+                f\"\"\"                      \"gdbarch_dump: {c.name} = %s\\\\n\",\"\"\", file=f\n+            )\n+            print(f\"                      {printer});\", file=f)\n+    print(\"  if (gdbarch->dump_tdep != NULL)\", file=f)\n+    print(\"    gdbarch->dump_tdep (gdbarch, file);\", file=f)\n+    print(\"}\", file=f)\n+    print(file=f)\n+    #\n+    # Bodies of setter, accessor, and predicate functions.\n+    #\n+    for c in components:\n+        if c.predicate:\n+            print(file=f)\n+            print(\"bool\", file=f)\n+            print(f\"gdbarch_{c.name}_p (struct gdbarch *gdbarch)\", file=f)\n+            print(\"{\", file=f)\n+            print(\"  gdb_assert (gdbarch != NULL);\", file=f)\n+            print(f\"  return {c.get_predicate()};\", file=f)\n+            print(\"}\", file=f)\n+        if isinstance(c, Function):\n+            print(file=f)\n+            print(f\"{c.type}\", file=f)\n+            print(f\"gdbarch_{c.name} ({c.set_list()})\", file=f)\n+            print(\"{\", file=f)\n+            print(\"  gdb_assert (gdbarch != NULL);\", file=f)\n+            print(f\"  gdb_assert (gdbarch->{c.name} != NULL);\", file=f)\n+            if c.predicate and c.predefault:\n+                # Allow a call to a function with a predicate.\n+                print(\n+                    f\"  /* Do not check predicate: {c.get_predicate()}, allow call.  */\",\n+                    file=f,\n+                )\n+            print(\"  if (gdbarch_debug >= 2)\", file=f)\n+            print(\n+                f\"\"\"    fprintf_unfiltered (gdb_stdlog, \"gdbarch_{c.name} called\\\\n\");\"\"\",\n+                file=f,\n+            )\n+            print(\"  \", file=f, end=\"\")\n+            if c.type != \"void\":\n+                print(\"return \", file=f, end=\"\")\n+            print(f\"gdbarch->{c.name} ({c.actuals()});\", file=f)\n+            print(\"}\", file=f)\n+            print(file=f)\n+            print(\"void\", file=f)\n+            print(f\"set_gdbarch_{c.name} (struct gdbarch *gdbarch,\", file=f)\n+            print(\n+                f\"            {' ' * len(c.name)}  gdbarch_{c.name}_ftype {c.name})\",\n+                file=f,\n+            )\n+            print(\"{\", file=f)\n+            print(f\"  gdbarch->{c.name} = {c.name};\", file=f)\n+            print(\"}\", file=f)\n+        elif isinstance(c, Value):\n+            print(file=f)\n+            print(f\"{c.type}\", file=f)\n+            print(f\"gdbarch_{c.name} (struct gdbarch *gdbarch)\", file=f)\n+            print(\"{\", file=f)\n+            print(\"  gdb_assert (gdbarch != NULL);\", file=f)\n+            if c.invalid is False:\n+                print(f\"  /* Skip verify of {c.name}, invalid_p == 0 */\", file=f)\n+            elif isinstance(c.invalid, str):\n+                print(\"  /* Check variable is valid.  */\", file=f)\n+                print(f\"  gdb_assert (!({c.invalid}));\", file=f)\n+            elif c.predefault:\n+                print(\"  /* Check variable changed from pre-default.  */\", file=f)\n+                print(f\"  gdb_assert (gdbarch->{c.name} != {c.predefault});\", file=f)\n+            print(\"  if (gdbarch_debug >= 2)\", file=f)\n+            print(\n+                f\"\"\"    fprintf_unfiltered (gdb_stdlog, \"gdbarch_{c.name} called\\\\n\");\"\"\",\n+                file=f,\n+            )\n+            print(f\"  return gdbarch->{c.name};\", file=f)\n+            print(\"}\", file=f)\n+            print(file=f)\n+            print(\"void\", file=f)\n+            print(f\"set_gdbarch_{c.name} (struct gdbarch *gdbarch,\", file=f)\n+            print(f\"            {' ' * len(c.name)}  {c.type} {c.name})\", file=f)\n+            print(\"{\", file=f)\n+            print(f\"  gdbarch->{c.name} = {c.name};\", file=f)\n+            print(\"}\", file=f)\n+        else:\n+            assert isinstance(c, Info)\n+            print(file=f)\n+            print(f\"{c.type}\", file=f)\n+            print(f\"gdbarch_{c.name} (struct gdbarch *gdbarch)\", file=f)\n+            print(\"{\", file=f)\n+            print(\"  gdb_assert (gdbarch != NULL);\", file=f)\n+            print(\"  if (gdbarch_debug >= 2)\", file=f)\n+            print(\n+                f\"\"\"    fprintf_unfiltered (gdb_stdlog, \"gdbarch_{c.name} called\\\\n\");\"\"\",\n+                file=f,\n+            )\n+            print(f\"  return gdbarch->{c.name};\", file=f)\n+            print(\"}\", file=f)"
    }
  ]
}