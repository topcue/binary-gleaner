{
  "sha": "435d3d88360d1ad9aac798f6bff7d7b5363efe3e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDM1ZDNkODgzNjBkMWFkOWFhYzc5OGY2YmZmN2Q3YjUzNjNlZmUzZQ==",
  "commit": {
    "author": {
      "name": "Ali Tamur",
      "email": "tamur@google.com",
      "date": "2019-11-19T03:22:05Z"
    },
    "committer": {
      "name": "Ali Tamur",
      "email": "tamur@google.com",
      "date": "2019-11-19T19:37:53Z"
    },
    "message": "Replace \"if (attr)\" with \"if (attr != nullptr)\".\n\nThis is a cleanup patch in response to a reviewer comment on \"Dwarf 5: Handle\ndebug_str_offsets\" patch.",
    "tree": {
      "sha": "fe7cb10388d8dd621bbf62deb478f29f0827c0b5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fe7cb10388d8dd621bbf62deb478f29f0827c0b5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/435d3d88360d1ad9aac798f6bff7d7b5363efe3e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/435d3d88360d1ad9aac798f6bff7d7b5363efe3e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/435d3d88360d1ad9aac798f6bff7d7b5363efe3e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/435d3d88360d1ad9aac798f6bff7d7b5363efe3e/comments",
  "author": {
    "login": "alitamur",
    "id": 59383390,
    "node_id": "MDQ6VXNlcjU5MzgzMzkw",
    "avatar_url": "https://avatars.githubusercontent.com/u/59383390?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alitamur",
    "html_url": "https://github.com/alitamur",
    "followers_url": "https://api.github.com/users/alitamur/followers",
    "following_url": "https://api.github.com/users/alitamur/following{/other_user}",
    "gists_url": "https://api.github.com/users/alitamur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alitamur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alitamur/subscriptions",
    "organizations_url": "https://api.github.com/users/alitamur/orgs",
    "repos_url": "https://api.github.com/users/alitamur/repos",
    "events_url": "https://api.github.com/users/alitamur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alitamur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "alitamur",
    "id": 59383390,
    "node_id": "MDQ6VXNlcjU5MzgzMzkw",
    "avatar_url": "https://avatars.githubusercontent.com/u/59383390?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alitamur",
    "html_url": "https://github.com/alitamur",
    "followers_url": "https://api.github.com/users/alitamur/followers",
    "following_url": "https://api.github.com/users/alitamur/following{/other_user}",
    "gists_url": "https://api.github.com/users/alitamur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alitamur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alitamur/subscriptions",
    "organizations_url": "https://api.github.com/users/alitamur/orgs",
    "repos_url": "https://api.github.com/users/alitamur/repos",
    "events_url": "https://api.github.com/users/alitamur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alitamur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c9739b6a06730b65df135766dec4c4d14d78bd38",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c9739b6a06730b65df135766dec4c4d14d78bd38",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c9739b6a06730b65df135766dec4c4d14d78bd38"
    }
  ],
  "stats": {
    "total": 123,
    "additions": 75,
    "deletions": 48
  },
  "files": [
    {
      "sha": "11ec2e3d85c621e8f113df2f5aa6273db5f02a88",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/435d3d88360d1ad9aac798f6bff7d7b5363efe3e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/435d3d88360d1ad9aac798f6bff7d7b5363efe3e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=435d3d88360d1ad9aac798f6bff7d7b5363efe3e",
      "patch": "@@ -1,3 +1,30 @@\n+2019-11-19  Ali Tamur <tamur@google.com>\n+\n+\t* dwarf2read.c (dw2_get_file_names_reader): Replace \"if (attr)\" with\n+\t\"if (attr != nullptr)\".\n+\t(dwarf2_find_base_address): Likewise.\n+\t(dwarf2_build_include_psymtabs): Likewise.\n+\t(read_cutu_die_from_dwo): Likewise.\n+\t(read_func_scope): Likewise.\n+\t(read_call_site_scope): Likewise.\n+\t(dwarf2_get_pc_bounds): Likewise.\n+\t(dwarf2_record_block_ranges): Likewise.\n+\t(dwarf2_add_field): Likewise.\n+\t(dwarf2_add_member_fn): Likewise.\n+\t(read_structure_type): Likewise.\n+\t(read_enumeration_type): Likewise.\n+\t(read_array_type): Likewise.\n+\t(read_array_order): Likewise.\n+\t(read_set_type): Likewise.\n+\t(read_common_block): Likewise.\n+\t(read_tag_reference_type): Likewise.\n+\t(read_tag_string_type): Likewise.\n+\t(read_subroutine_type): Likewise.\n+\t(read_base_type): Likewise.\n+\t(read_subrange_type): Likewise.\n+\t(new_symbol): Likewise.\n+\t(prepare_one_comp_unit): Likewise.\n+\n 2019-11-19  Tom Tromey  <tromey@adacore.com>\n \n \t* windows-nat.c (windows_nat_target::attach): Include GetLastError"
    },
    {
      "sha": "9178e0eb940c932828fe69ae03c7c679d503d0b9",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 48,
      "deletions": 48,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/435d3d88360d1ad9aac798f6bff7d7b5363efe3e/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/435d3d88360d1ad9aac798f6bff7d7b5363efe3e/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=435d3d88360d1ad9aac798f6bff7d7b5363efe3e",
      "patch": "@@ -3682,7 +3682,7 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n   sect_offset line_offset {};\n \n   attr = dwarf2_attr (comp_unit_die, DW_AT_stmt_list, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       struct quick_file_names find_entry;\n \n@@ -6419,15 +6419,15 @@ dwarf2_find_base_address (struct die_info *die, struct dwarf2_cu *cu)\n   cu->base_address = 0;\n \n   attr = dwarf2_attr (die, DW_AT_entry_pc, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       cu->base_address = attr_value_as_address (attr);\n       cu->base_known = 1;\n     }\n   else\n     {\n       attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n-      if (attr)\n+      if (attr != nullptr)\n \t{\n \t  cu->base_address = attr_value_as_address (attr);\n \t  cu->base_known = 1;\n@@ -6691,7 +6691,7 @@ dwarf2_build_include_psymtabs (struct dwarf2_cu *cu,\n   struct attribute *attr;\n \n   attr = dwarf2_attr (die, DW_AT_stmt_list, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     lh = dwarf_decode_line_header ((sect_offset) DW_UNSND (attr), cu);\n   if (lh == NULL)\n     return;  /* No linetable, so no includes.  */\n@@ -7276,14 +7276,14 @@ read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,\n          or DW_FORM_addrx.  */\n       cu->addr_base = 0;\n       attr = dwarf2_attr (stub_comp_unit_die, DW_AT_GNU_addr_base, cu);\n-      if (attr)\n+      if (attr != nullptr)\n \tcu->addr_base = DW_UNSND (attr);\n \n       /* There should be a DW_AT_ranges_base attribute here (if needed).\n \t We need the value before we can process DW_AT_ranges.  */\n       cu->ranges_base = 0;\n       attr = dwarf2_attr (stub_comp_unit_die, DW_AT_GNU_ranges_base, cu);\n-      if (attr)\n+      if (attr != nullptr)\n \tcu->ranges_base = DW_UNSND (attr);\n     }\n   else if (stub_comp_dir != NULL)\n@@ -13782,13 +13782,13 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n   /* If there is a location expression for DW_AT_frame_base, record\n      it.  */\n   attr = dwarf2_attr (die, DW_AT_frame_base, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     dwarf2_symbol_mark_computed (attr, newobj->name, cu, 1);\n \n   /* If there is a location for the static link, record it.  */\n   newobj->static_link = NULL;\n   attr = dwarf2_attr (die, DW_AT_static_link, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       newobj->static_link\n \t= XOBNEW (&objfile->objfile_obstack, struct dynamic_prop);\n@@ -14264,7 +14264,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n       attr = dwarf2_attr (child_die, DW_AT_call_data_value, cu);\n       if (attr == NULL)\n \tattr = dwarf2_attr (child_die, DW_AT_GNU_call_site_data_value, cu);\n-      if (attr)\n+      if (attr != nullptr)\n \t{\n \t  if (!attr_form_is_block (attr))\n \t    complaint (_(\"No DW_FORM_block* DW_AT_call_data_value for \"\n@@ -14705,7 +14705,7 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n   if (attr_high)\n     {\n       attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n-      if (attr)\n+      if (attr != nullptr)\n         {\n \t  low = attr_value_as_address (attr);\n \t  high = attr_value_as_address (attr_high);\n@@ -14878,7 +14878,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n   if (attr_high)\n     {\n       attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n-      if (attr)\n+      if (attr != nullptr)\n         {\n           CORE_ADDR low = attr_value_as_address (attr);\n \t  CORE_ADDR high = attr_value_as_address (attr_high);\n@@ -14893,7 +14893,7 @@ dwarf2_record_block_ranges (struct die_info *die, struct block *block,\n     }\n \n   attr = dwarf2_attr (die, DW_AT_ranges, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       /* DW_AT_ranges_base does not apply to DIEs from the DWO skeleton.\n \t We take advantage of the fact that DW_AT_ranges does not appear\n@@ -15078,15 +15078,15 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n   fip->nfields++;\n \n   attr = dwarf2_attr (die, DW_AT_accessibility, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     new_field->accessibility = DW_UNSND (attr);\n   else\n     new_field->accessibility = dwarf2_default_access_attribute (die, cu);\n   if (new_field->accessibility != DW_ACCESS_public)\n     fip->non_public_fields = 1;\n \n   attr = dwarf2_attr (die, DW_AT_virtuality, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     new_field->virtuality = DW_UNSND (attr);\n   else\n     new_field->virtuality = DW_VIRTUALITY_none;\n@@ -15106,7 +15106,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \n       /* Get bit size of field (zero if none).  */\n       attr = dwarf2_attr (die, DW_AT_bit_size, cu);\n-      if (attr)\n+      if (attr != nullptr)\n \t{\n \t  FIELD_BITSIZE (*fp) = DW_UNSND (attr);\n \t}\n@@ -15119,7 +15119,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n       if (handle_data_member_location (die, cu, &offset))\n \tSET_FIELD_BITPOS (*fp, offset * bits_per_byte);\n       attr = dwarf2_attr (die, DW_AT_bit_offset, cu);\n-      if (attr)\n+      if (attr != nullptr)\n \t{\n \t  if (gdbarch_bits_big_endian (gdbarch))\n \t    {\n@@ -15142,7 +15142,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \t      int bit_offset = DW_UNSND (attr);\n \n \t      attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-\t      if (attr)\n+\t      if (attr != nullptr)\n \t\t{\n \t\t  /* The size of the anonymous object containing\n \t\t     the bit field is explicit, so use the\n@@ -15554,7 +15554,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n \n   /* Get accessibility.  */\n   attr = dwarf2_attr (die, DW_AT_accessibility, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     accessibility = (enum dwarf_access_attribute) DW_UNSND (attr);\n   else\n     accessibility = dwarf2_default_access_attribute (die, cu);\n@@ -15582,7 +15582,7 @@ dwarf2_add_member_fn (struct field_info *fip, struct die_info *die,\n      to the object address.  */\n \n   attr = dwarf2_attr (die, DW_AT_vtable_elem_location, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       if (attr_form_is_block (attr) && DW_BLOCK (attr)->size > 0)\n         {\n@@ -15836,7 +15836,7 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n      Don't follow DW_AT_specification though, that will take us back up\n      the chain and we want to go down.  */\n   attr = dwarf2_attr_no_follow (die, DW_AT_signature);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       type = get_DW_AT_signature_type (die, attr, cu);\n \n@@ -15894,7 +15894,7 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n     TYPE_DECLARED_CLASS (type) = 1;\n \n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       if (attr_form_is_constant (attr))\n         TYPE_LENGTH (type) = DW_UNSND (attr);\n@@ -16360,7 +16360,7 @@ read_enumeration_type (struct die_info *die, struct dwarf2_cu *cu)\n      Don't follow DW_AT_specification though, that will take us back up\n      the chain and we want to go down.  */\n   attr = dwarf2_attr_no_follow (die, DW_AT_signature);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       type = get_DW_AT_signature_type (die, attr, cu);\n \n@@ -16385,7 +16385,7 @@ read_enumeration_type (struct die_info *die, struct dwarf2_cu *cu)\n     }\n \n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       TYPE_LENGTH (type) = DW_UNSND (attr);\n     }\n@@ -16629,14 +16629,14 @@ read_array_type (struct die_info *die, struct dwarf2_cu *cu)\n      array and the vector variant is that vectors are passed by value\n      to functions.  */\n   attr = dwarf2_attr (die, DW_AT_GNU_vector, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     make_vector_type (type);\n \n   /* The DIE may have DW_AT_byte_size set.  For example an OpenCL\n      implementation may choose to implement triple vectors using this\n      attribute.  */\n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       if (DW_UNSND (attr) >= TYPE_LENGTH (type))\n \tTYPE_LENGTH (type) = DW_UNSND (attr);\n@@ -16667,7 +16667,7 @@ read_array_order (struct die_info *die, struct dwarf2_cu *cu)\n \n   attr = dwarf2_attr (die, DW_AT_ordering, cu);\n \n-  if (attr)\n+  if (attr != nullptr)\n     return (enum dwarf_array_dim_ordering) DW_SND (attr);\n \n   /* GNU F77 is a special case, as at 08/2004 array type info is the\n@@ -16712,7 +16712,7 @@ read_set_type (struct die_info *die, struct dwarf2_cu *cu)\n   set_type = create_set_type (NULL, domain_type);\n \n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     TYPE_LENGTH (set_type) = DW_UNSND (attr);\n \n   maybe_set_alignment (cu, die, set_type);\n@@ -16805,7 +16805,7 @@ read_common_block (struct die_info *die, struct dwarf2_cu *cu)\n   struct attribute *attr;\n \n   attr = dwarf2_attr (die, DW_AT_location, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       /* Support the .debug_loc offsets.  */\n       if (attr_form_is_block (attr))\n@@ -16878,7 +16878,7 @@ read_common_block (struct die_info *die, struct dwarf2_cu *cu)\n \t\t  else if (attr_form_is_constant (member_loc)\n \t\t\t   || attr_form_is_block (member_loc))\n \t\t    {\n-\t\t      if (attr)\n+\t\t      if (attr != nullptr)\n \t\t\tmark_common_block_symbol_computed (sym, die, attr,\n \t\t\t\t\t\t\t   member_loc, cu);\n \t\t    }\n@@ -17179,7 +17179,7 @@ read_tag_reference_type (struct die_info *die, struct dwarf2_cu *cu,\n \n   type = lookup_reference_type (target_type, refcode);\n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       TYPE_LENGTH (type) = DW_UNSND (attr);\n     }\n@@ -17315,15 +17315,15 @@ read_tag_string_type (struct die_info *die, struct dwarf2_cu *cu)\n   unsigned int length;\n \n   attr = dwarf2_attr (die, DW_AT_string_length, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       length = DW_UNSND (attr);\n     }\n   else\n     {\n       /* Check for the DW_AT_byte_size attribute.  */\n       attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-      if (attr)\n+      if (attr != nullptr)\n         {\n           length = DW_UNSND (attr);\n         }\n@@ -17407,7 +17407,7 @@ read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)\n      the subroutine die.  Otherwise set the calling convention to\n      the default value DW_CC_normal.  */\n   attr = dwarf2_attr (die, DW_AT_calling_convention, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     TYPE_CALLING_CONVENTION (ftype) = DW_UNSND (attr);\n   else if (cu->producer && strstr (cu->producer, \"IBM XL C for OpenCL\"))\n     TYPE_CALLING_CONVENTION (ftype) = DW_CC_GDB_IBM_OpenCL;\n@@ -17473,7 +17473,7 @@ read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)\n \t\t DWARF version 3 added DW_AT_object_pointer, which GCC\n \t\t 4.5 does not yet generate.  */\n \t      attr = dwarf2_attr (child_die, DW_AT_artificial, cu);\n-\t      if (attr)\n+\t      if (attr != nullptr)\n \t\tTYPE_FIELD_ARTIFICIAL (ftype, iparams) = DW_UNSND (attr);\n \t      else\n \t\tTYPE_FIELD_ARTIFICIAL (ftype, iparams) = 0;\n@@ -17490,7 +17490,7 @@ read_subroutine_type (struct die_info *die, struct dwarf2_cu *cu)\n \t\t  const char *name = dwarf2_name (child_die, cu);\n \n \t\t  attr = dwarf2_attr (die, DW_AT_object_pointer, cu);\n-\t\t  if (attr)\n+\t\t  if (attr != nullptr)\n \t\t    {\n \t\t      /* If the compiler emits this, use it.  */\n \t\t      if (follow_die_ref (die, attr, &arg_cu) == child_die)\n@@ -17664,12 +17664,12 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n   const char *name;\n \n   attr = dwarf2_attr (die, DW_AT_encoding, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       encoding = DW_UNSND (attr);\n     }\n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     {\n       bits = DW_UNSND (attr) * TARGET_CHAR_BIT;\n     }\n@@ -17990,7 +17990,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n     }\n \n   attr = dwarf2_attr (die, DW_AT_lower_bound, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     attr_to_dynamic_prop (attr, die, cu, &low, base_type);\n   else if (!low_default_is_valid)\n     complaint (_(\"Missing DW_AT_lower_bound \"\n@@ -18061,7 +18061,7 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n     TYPE_NAME (range_type) = name;\n \n   attr = dwarf2_attr (die, DW_AT_byte_size, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     TYPE_LENGTH (range_type) = DW_UNSND (attr);\n \n   maybe_set_alignment (cu, die, range_type);\n@@ -21651,15 +21651,15 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n       attr = dwarf2_attr (die,\n \t\t\t  inlined_func ? DW_AT_call_line : DW_AT_decl_line,\n \t\t\t  cu);\n-      if (attr)\n+      if (attr != nullptr)\n \t{\n \t  SYMBOL_LINE (sym) = DW_UNSND (attr);\n \t}\n \n       attr = dwarf2_attr (die,\n \t\t\t  inlined_func ? DW_AT_call_file : DW_AT_decl_file,\n \t\t\t  cu);\n-      if (attr)\n+      if (attr != nullptr)\n \t{\n \t  file_name_index file_index = (file_name_index) DW_UNSND (attr);\n \t  struct file_entry *fe;\n@@ -21679,7 +21679,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t{\n \tcase DW_TAG_label:\n \t  attr = dwarf2_attr (die, DW_AT_low_pc, cu);\n-\t  if (attr)\n+\t  if (attr != nullptr)\n \t    {\n \t      CORE_ADDR addr;\n \n@@ -21743,7 +21743,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t      gdb_assert (die_is_declaration (die, cu));\n \t      gdb_assert (attr);\n \t    }\n-\t  if (attr)\n+\t  if (attr != nullptr)\n \t    {\n \t      dwarf2_const_value (attr, sym, cu);\n \t      attr2 = dwarf2_attr (die, DW_AT_external, cu);\n@@ -21757,7 +21757,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t      break;\n \t    }\n \t  attr = dwarf2_attr (die, DW_AT_location, cu);\n-\t  if (attr)\n+\t  if (attr != nullptr)\n \t    {\n \t      var_decode_location (attr, sym, cu);\n \t      attr2 = dwarf2_attr (die, DW_AT_external, cu);\n@@ -21860,12 +21860,12 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t    if (curr != nullptr && curr->name != nullptr)\n \t      SYMBOL_IS_ARGUMENT (sym) = 1;\n \t    attr = dwarf2_attr (die, DW_AT_location, cu);\n-\t    if (attr)\n+\t    if (attr != nullptr)\n \t      {\n \t\tvar_decode_location (attr, sym, cu);\n \t      }\n \t    attr = dwarf2_attr (die, DW_AT_const_value, cu);\n-\t    if (attr)\n+\t    if (attr != nullptr)\n \t      {\n \t\tdwarf2_const_value (attr, sym, cu);\n \t      }\n@@ -21937,7 +21937,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  break;\n \tcase DW_TAG_enumerator:\n \t  attr = dwarf2_attr (die, DW_AT_const_value, cu);\n-\t  if (attr)\n+\t  if (attr != nullptr)\n \t    {\n \t      dwarf2_const_value (attr, sym, cu);\n \t    }\n@@ -25549,7 +25549,7 @@ prepare_one_comp_unit (struct dwarf2_cu *cu, struct die_info *comp_unit_die,\n \n   /* Set the language we're debugging.  */\n   attr = dwarf2_attr (comp_unit_die, DW_AT_language, cu);\n-  if (attr)\n+  if (attr != nullptr)\n     set_cu_language (DW_UNSND (attr), cu);\n   else\n     {"
    }
  ]
}