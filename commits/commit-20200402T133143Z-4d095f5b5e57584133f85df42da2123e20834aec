{
  "sha": "4d095f5b5e57584133f85df42da2123e20834aec",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NGQwOTVmNWI1ZTU3NTg0MTMzZjg1ZGY0MmRhMjEyM2UyMDgzNGFlYw==",
  "commit": {
    "author": {
      "name": "Jan W. Jagersma",
      "email": "jwjagersma@gmail.com",
      "date": "2020-04-02T13:31:43Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-04-02T13:31:43Z"
    },
    "message": "coff-go32-exe: support variable-length stubs\n\nThe stub size in GO32 executables has historically been fixed at 2048\nbytes, due to hardcoded limitations in bfd.  Recent patches to djgpp by\nStas Sergeev (CC'd) have pushed the stub right up to this limit, so if\nany further expansion is desired, this must first be patched in bfd.\n\nThis series includes three patches:  The first changes the meaning of\nthe bfd->origin field slightly, so that target code can use this to\nspecify an offset into the file where the actual bfd is located.\nThe second patch then uses this to enable support for variable-sized\nstubs in the coff-go32-exe format.\nThe final patch is only a cleanup, it normalizes function and variable\nnames in coff-stgo32.c so that they all begin with the same prefix.\n\nbfd\t* bfdio.c (bfd_bread, bfd_tell, bfd_seek, bfd_mmap): Always add\n\tbfd->origin to file offset.\n\t* bfdwin.c (bfd_get_file_window): Likewise.\n\t* bfd.c: Clarify the use of the bfd->origin field.\n\t* bfd-in2.h: Regenerate.\n\t* coff-i386.c: Don't include go32exe.h. Allow overriding\n\tcoff_write_object_contents via COFF_WRITE_CONTENTS.\n\t* coff-stgo32.c (go32exe_cleanup, go32exe_mkobject)\n\t(go32exe_write_object_contents): New functions.\n\t(go32exe_temp_stub, go32exe_temp_stub_size): New static globals.\n\t(COFF_WRITE_CONTENTS, GO32EXE_DEFAULT_STUB_SIZE): Define.\n\t(create_go32_stub): Remove check for 2k size limit.  Read stub\n\tfrom go32exe_temp_stub if present.\n\t(go32_stubbed_coff_bfd_copy_private_bfd_data): Allocate and\n\tcopy variable-length stub.\n\t(go32_check_format): Read stub to go32exe_temp_stub, set\n\torigin, return go32exe_cleanup.\n\t(adjust_filehdr_in_post, adjust_filehdr_out_pre)\n\t(adjust_filehdr_out_post, adjust_scnhdr_in_post)\n\t(adjust_scnhdr_out_pre, adjust_scnhdr_out_post)\n\t(adjust_aux_in_post, adjust_aux_out_pre, adjust_aux_out_post):\n\tRemove functions and their associated #defines.\n\t* coffcode.h (coff_mkobject_hook): Remove stub copying code.\n\t* libcoff-in.h: (struct coff_tdata): New field stub_size.\n\tRename field go32stub to stub.\n\t* libcoff.h: Regenerate.\n\t* coff-stgo32.c (go32_check_format): Rename to...\n\t(go32exe_check_format): ...this.\n\t(go32_stubbed_coff_bfd_copy_private_bfd_data): Rename to...\n\t(go32exe_copy_private_bfd_data): ...this.\n\t(stub_bytes): Rename to...\n\t(go32exe_default_stub): ...this.\n\t(create_go32_stub): Rename to...\n\t(go32exe_create_stub): ...this.\n\t* coff-stgo32.c (go32exe_copy_private_bfd_data): Avoid realloc\n\twhen possible.\n\ninclude\t* coff/go32exe.h: Remove file.\n\t* coff/internal.h (struct internal_filehdr): Remove field\n\tgo32stub.  Remove flag F_GO32STUB.",
    "tree": {
      "sha": "d7368d31a7417cb1295596aa0e89567c15a0af63",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d7368d31a7417cb1295596aa0e89567c15a0af63"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4d095f5b5e57584133f85df42da2123e20834aec",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d095f5b5e57584133f85df42da2123e20834aec",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4d095f5b5e57584133f85df42da2123e20834aec",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4d095f5b5e57584133f85df42da2123e20834aec/comments",
  "author": {
    "login": "jwt27",
    "id": 5897442,
    "node_id": "MDQ6VXNlcjU4OTc0NDI=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5897442?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jwt27",
    "html_url": "https://github.com/jwt27",
    "followers_url": "https://api.github.com/users/jwt27/followers",
    "following_url": "https://api.github.com/users/jwt27/following{/other_user}",
    "gists_url": "https://api.github.com/users/jwt27/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jwt27/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jwt27/subscriptions",
    "organizations_url": "https://api.github.com/users/jwt27/orgs",
    "repos_url": "https://api.github.com/users/jwt27/repos",
    "events_url": "https://api.github.com/users/jwt27/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jwt27/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0dd7b52ede3de7c5e43cc7c0a52a4e2f2b4297b7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0dd7b52ede3de7c5e43cc7c0a52a4e2f2b4297b7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0dd7b52ede3de7c5e43cc7c0a52a4e2f2b4297b7"
    }
  ],
  "stats": {
    "total": 605,
    "additions": 277,
    "deletions": 328
  },
  "files": [
    {
      "sha": "64c3dde475424dda681c0ac5e2992711976ba8c2",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 39,
      "deletions": 0,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -1,3 +1,42 @@\n+2020-04-02  Jan W. Jagersma  <jwjagersma@gmail.com>\n+\n+\t* bfdio.c (bfd_bread, bfd_tell, bfd_seek, bfd_mmap): Always add\n+\tbfd->origin to file offset.\n+\t* bfdwin.c (bfd_get_file_window): Likewise.\n+\t* bfd.c: Clarify the use of the bfd->origin field.\n+\t* bfd-in2.h: Regenerate.\n+\t* coff-i386.c: Don't include go32exe.h. Allow overriding\n+\tcoff_write_object_contents via COFF_WRITE_CONTENTS.\n+\t* coff-stgo32.c (go32exe_cleanup, go32exe_mkobject)\n+\t(go32exe_write_object_contents): New functions.\n+\t(go32exe_temp_stub, go32exe_temp_stub_size): New static globals.\n+\t(COFF_WRITE_CONTENTS, GO32EXE_DEFAULT_STUB_SIZE): Define.\n+\t(create_go32_stub): Remove check for 2k size limit.  Read stub\n+\tfrom go32exe_temp_stub if present.\n+\t(go32_stubbed_coff_bfd_copy_private_bfd_data): Allocate and\n+\tcopy variable-length stub.\n+\t(go32_check_format): Read stub to go32exe_temp_stub, set\n+\torigin, return go32exe_cleanup.\n+\t(adjust_filehdr_in_post, adjust_filehdr_out_pre)\n+\t(adjust_filehdr_out_post, adjust_scnhdr_in_post)\n+\t(adjust_scnhdr_out_pre, adjust_scnhdr_out_post)\n+\t(adjust_aux_in_post, adjust_aux_out_pre, adjust_aux_out_post):\n+\tRemove functions and their associated #defines.\n+\t* coffcode.h (coff_mkobject_hook): Remove stub copying code.\n+\t* libcoff-in.h: (struct coff_tdata): New field stub_size.\n+\tRename field go32stub to stub.\n+\t* libcoff.h: Regenerate.\n+\t* coff-stgo32.c (go32_check_format): Rename to...\n+\t(go32exe_check_format): ...this.\n+\t(go32_stubbed_coff_bfd_copy_private_bfd_data): Rename to...\n+\t(go32exe_copy_private_bfd_data): ...this.\n+\t(stub_bytes): Rename to...\n+\t(go32exe_default_stub): ...this.\n+\t(create_go32_stub): Rename to...\n+\t(go32exe_create_stub): ...this.\n+\t* coff-stgo32.c (go32exe_copy_private_bfd_data): Avoid realloc\n+\twhen possible.\n+\n 2020-04-01  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR ld/25749"
    },
    {
      "sha": "7aa64556b84508cbd3701e080b0b86f8c0aac460",
      "filename": "bfd/bfd-in2.h",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/bfd-in2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/bfd-in2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in2.h?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -6666,9 +6666,8 @@ struct bfd\n      library.  */\n   bfd *plugin_dummy_bfd;\n \n-  /* Currently my_archive is tested before adding origin to\n-     anything. I believe that this can become always an add of\n-     origin, with origin set to 0 for non archive files.  */\n+  /* The offset of this bfd in the file, typically 0 if it is not\n+     contained in an archive.  */\n   ufile_ptr origin;\n \n   /* The origin in the archive of the proxy entry.  This will"
    },
    {
      "sha": "3aed9be2373ac2ac2abd04544c72b14a7a10b7f3",
      "filename": "bfd/bfd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd.c?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -249,9 +249,8 @@ CODE_FRAGMENT\n .     library.  *}\n .  bfd *plugin_dummy_bfd;\n .\n-.  {* Currently my_archive is tested before adding origin to\n-.     anything. I believe that this can become always an add of\n-.     origin, with origin set to 0 for non archive files.  *}\n+.  {* The offset of this bfd in the file, typically 0 if it is not\n+.     contained in an archive.  *}\n .  ufile_ptr origin;\n .\n .  {* The origin in the archive of the proxy entry.  This will"
    },
    {
      "sha": "29834d9c6b69e017225c533b2c29f64f99b949a2",
      "filename": "bfd/bfdio.c",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/bfdio.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/bfdio.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfdio.c?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -201,6 +201,7 @@ bfd_bread (void *ptr, bfd_size_type size, bfd *abfd)\n       offset += abfd->origin;\n       abfd = abfd->my_archive;\n     }\n+  offset += abfd->origin;\n \n   /* If this is an archive element, don't read past the end of\n      this element.  */\n@@ -270,6 +271,7 @@ bfd_tell (bfd *abfd)\n       offset += abfd->origin;\n       abfd = abfd->my_archive;\n     }\n+  offset += abfd->origin;\n \n   if (abfd->iovec == NULL)\n     return 0;\n@@ -330,6 +332,7 @@ bfd_seek (bfd *abfd, file_ptr position, int direction)\n       offset += abfd->origin;\n       abfd = abfd->my_archive;\n     }\n+  offset += abfd->origin;\n \n   if (abfd->iovec == NULL)\n     {\n@@ -522,6 +525,7 @@ bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,\n       offset += abfd->origin;\n       abfd = abfd->my_archive;\n     }\n+  offset += abfd->origin;\n \n   if (abfd->iovec == NULL)\n     {"
    },
    {
      "sha": "51b4faca76c09027b07edf329bd40199c16c9e9a",
      "filename": "bfd/bfdwin.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/bfdwin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/bfdwin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfdwin.c?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -150,6 +150,7 @@ bfd_get_file_window (bfd *abfd,\n \t  offset += abfd->origin;\n \t  abfd = abfd->my_archive;\n \t}\n+      offset += abfd->origin;\n \n       /* Seek into the file, to ensure it is open if cacheable.  */\n       if (abfd->iostream == NULL"
    },
    {
      "sha": "d3075f5a63821313e6100d4bdb5158e7097e9e2f",
      "filename": "bfd/coff-i386.c",
      "status": "modified",
      "additions": 8,
      "deletions": 14,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/coff-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/coff-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-i386.c?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -31,10 +31,6 @@\n #include \"coff/pe.h\"\n #endif\n \n-#ifdef COFF_GO32_EXE\n-#include \"coff/go32exe.h\"\n-#endif\n-\n #ifndef bfd_pe_print_pdata\n #define bfd_pe_print_pdata\tNULL\n #endif\n@@ -663,23 +659,21 @@ const bfd_target\n      bfd_getl32, bfd_getl_signed_32, bfd_putl32,\n      bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */\n \n+#ifndef COFF_CHECK_FORMAT\n+#define COFF_CHECK_FORMAT coff_object_p\n+#endif\n+#ifndef COFF_WRITE_CONTENTS\n+#define COFF_WRITE_CONTENTS coff_write_object_contents\n+#endif\n+\n /* Note that we allow an object file to be treated as a core file as well.  */\n \n-#ifdef COFF_CHECK_FORMAT\n   {\t\t\t\t/* bfd_check_format */\n     _bfd_dummy_target,\n     COFF_CHECK_FORMAT,\n     bfd_generic_archive_p,\n     COFF_CHECK_FORMAT\n   },\n-#else\n-  {\n-    _bfd_dummy_target,\n-    coff_object_p,\n-    bfd_generic_archive_p,\n-    coff_object_p\n-  },\n-#endif\n   {\t\t\t\t/* bfd_set_format */\n     _bfd_bool_bfd_false_error,\n     coff_mkobject,\n@@ -688,7 +682,7 @@ const bfd_target\n   },\n   {\t\t\t\t/* bfd_write_contents */\n     _bfd_bool_bfd_false_error,\n-    coff_write_object_contents,\n+    COFF_WRITE_CONTENTS,\n     _bfd_write_archive_contents,\n     _bfd_bool_bfd_false_error\n   },"
    },
    {
      "sha": "d1be578c6aa3d1edbb5f71e29748ec402cb396ae",
      "filename": "bfd/coff-stgo32.c",
      "status": "modified",
      "additions": 204,
      "deletions": 245,
      "changes": 449,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/coff-stgo32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/coff-stgo32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-stgo32.c?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -23,17 +23,10 @@\n    DOS executable program before the coff image to load it in memory\n    and execute it. This is needed, because DOS cannot run coff files.\n \n-   All the functions below are called by the corresponding functions\n-   from coffswap.h.\n-   The only thing what they do is to adjust the information stored in\n-   the COFF file which are offset into the file.\n-   This is needed, because DJGPP uses a very special way to load and run\n-   the coff image. It loads the image in memory and assumes then, that the\n-   image had no stub by using the filepointers as pointers in the coff\n-   image and NOT in the file.\n-\n-   To be compatible with any existing executables I have fixed this\n-   here and NOT in the DJGPP startup code.  */\n+   The COFF image is loaded in memory without the stub attached, so\n+   all offsets are relative to the beginning of the image, not the\n+   actual file.  We handle this in bfd by setting bfd->origin to where\n+   the COFF image starts.  */\n \n #define TARGET_SYM\t\ti386_coff_go32stubbed_vec\n #define TARGET_NAME\t\t\"coff-go32-exe\"\n@@ -55,52 +48,17 @@\n \n #include \"sysdep.h\"\n #include \"bfd.h\"\n+#include \"coff/msdos.h\"\n \n-/* All that ..._PRE and ...POST functions are called from the corresponding\n-   coff_swap... functions. The ...PRE functions are called at the beginning\n-   of the function and the ...POST functions at the end of the swap routines.  */\n+static bfd_cleanup go32exe_check_format (bfd *);\n+static bfd_boolean go32exe_write_object_contents (bfd *);\n+static bfd_boolean go32exe_mkobject (bfd *);\n+static bfd_boolean go32exe_copy_private_bfd_data (bfd *, bfd *);\n \n-static void\n-adjust_filehdr_in_post  (bfd *, void *, void *);\n-static void\n-adjust_filehdr_out_pre  (bfd *, void *, void *);\n-static void\n-adjust_filehdr_out_post  (bfd *, void *, void *);\n-static void\n-adjust_scnhdr_in_post  (bfd *, void *, void *);\n-static void\n-adjust_scnhdr_out_pre  (bfd *, void *, void *);\n-static void\n-adjust_scnhdr_out_post (bfd *, void *, void *);\n-static void\n-adjust_aux_in_post (bfd *, void *, int, int, int, int, void *);\n-static void\n-adjust_aux_out_pre (bfd *, void *, int, int, int, int, void *);\n-static void\n-adjust_aux_out_post (bfd *, void *, int, int, int, int, void *);\n-static void\n-create_go32_stub (bfd *);\n-\n-#define COFF_ADJUST_FILEHDR_IN_POST adjust_filehdr_in_post\n-#define COFF_ADJUST_FILEHDR_OUT_PRE adjust_filehdr_out_pre\n-#define COFF_ADJUST_FILEHDR_OUT_POST adjust_filehdr_out_post\n-\n-#define COFF_ADJUST_SCNHDR_IN_POST adjust_scnhdr_in_post\n-#define COFF_ADJUST_SCNHDR_OUT_PRE adjust_scnhdr_out_pre\n-#define COFF_ADJUST_SCNHDR_OUT_POST adjust_scnhdr_out_post\n-\n-#define COFF_ADJUST_AUX_IN_POST adjust_aux_in_post\n-#define COFF_ADJUST_AUX_OUT_PRE adjust_aux_out_pre\n-#define COFF_ADJUST_AUX_OUT_POST adjust_aux_out_post\n-\n-static bfd_cleanup go32_check_format (bfd *);\n-\n-#define COFF_CHECK_FORMAT go32_check_format\n-\n-static bfd_boolean\n-  go32_stubbed_coff_bfd_copy_private_bfd_data (bfd *, bfd *);\n-\n-#define coff_bfd_copy_private_bfd_data go32_stubbed_coff_bfd_copy_private_bfd_data\n+#define COFF_CHECK_FORMAT go32exe_check_format\n+#define COFF_WRITE_CONTENTS go32exe_write_object_contents\n+#define coff_mkobject go32exe_mkobject\n+#define coff_bfd_copy_private_bfd_data go32exe_copy_private_bfd_data\n \n #include \"coff-i386.c\"\n \n@@ -110,160 +68,15 @@ static bfd_boolean\n \n /* These bytes are a 2048-byte DOS executable, which loads the COFF\n    image into memory and then runs it. It is called 'stub'.  */\n-\n-static const unsigned char stub_bytes[GO32_STUBSIZE] =\n+#define GO32EXE_DEFAULT_STUB_SIZE 2048\n+static const unsigned char go32exe_default_stub[GO32EXE_DEFAULT_STUB_SIZE] =\n {\n #include \"go32stub.h\"\n };\n \n-/*\n-   I have not commented each swap function below, because the\n-   technique is in any function the same. For the ...in function,\n-   all the pointers are adjusted by adding GO32_STUBSIZE and for the\n-   ...out function, it is subtracted first and after calling the\n-   standard swap function it is reset to the old value.  */\n-\n-/* This macro is used for adjusting the filepointers, which\n-   is done only, if the pointer is nonzero.  */\n-\n-#define ADJUST_VAL(val,diff) \\\n-  if (val != 0) val += diff\n-\n-static void\n-adjust_filehdr_in_post  (bfd *  abfd ATTRIBUTE_UNUSED,\n-\t\t\t void * src,\n-\t\t\t void * dst)\n-{\n-  FILHDR *filehdr_src = (FILHDR *) src;\n-  struct internal_filehdr *filehdr_dst = (struct internal_filehdr *) dst;\n-\n-  ADJUST_VAL (filehdr_dst->f_symptr, GO32_STUBSIZE);\n-\n-  /* Save now the stub to be used later.  Put the stub data to FILEHDR_DST\n-     first as coff_data (abfd) still does not exist.  It may not even be ever\n-     created as we are just checking the file format of ABFD.  */\n-  memcpy (filehdr_dst->go32stub, filehdr_src->stub, GO32_STUBSIZE);\n-  filehdr_dst->f_flags |= F_GO32STUB;\n-}\n-\n-static void\n-adjust_filehdr_out_pre  (bfd * abfd, void * in, void * out)\n-{\n-  struct internal_filehdr *filehdr_in = (struct internal_filehdr *) in;\n-  FILHDR *filehdr_out = (FILHDR *) out;\n-\n-  /* Generate the stub.  */\n-  create_go32_stub (abfd);\n-\n-  /* Copy the stub to the file header.  */\n-  if (coff_data (abfd)->go32stub != NULL)\n-    memcpy (filehdr_out->stub, coff_data (abfd)->go32stub, GO32_STUBSIZE);\n-  else\n-    /* Use the default.  */\n-    memcpy (filehdr_out->stub, stub_bytes, GO32_STUBSIZE);\n-\n-  ADJUST_VAL (filehdr_in->f_symptr, -GO32_STUBSIZE);\n-}\n-\n-static void\n-adjust_filehdr_out_post  (bfd *  abfd ATTRIBUTE_UNUSED,\n-\t\t\t  void * in,\n-\t\t\t  void * out ATTRIBUTE_UNUSED)\n-{\n-  struct internal_filehdr *filehdr_in = (struct internal_filehdr *) in;\n-  /* Undo the above change.  */\n-  ADJUST_VAL (filehdr_in->f_symptr, GO32_STUBSIZE);\n-}\n-\n-static void\n-adjust_scnhdr_in_post  (bfd *  abfd ATTRIBUTE_UNUSED,\n-\t\t\tvoid * ext ATTRIBUTE_UNUSED,\n-\t\t\tvoid * in)\n-{\n-  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;\n-\n-  ADJUST_VAL (scnhdr_int->s_scnptr, GO32_STUBSIZE);\n-  ADJUST_VAL (scnhdr_int->s_relptr, GO32_STUBSIZE);\n-  ADJUST_VAL (scnhdr_int->s_lnnoptr, GO32_STUBSIZE);\n-}\n-\n-static void\n-adjust_scnhdr_out_pre  (bfd *  abfd ATTRIBUTE_UNUSED,\n-\t\t\tvoid * in,\n-\t\t\tvoid * out ATTRIBUTE_UNUSED)\n-{\n-  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;\n-\n-  ADJUST_VAL (scnhdr_int->s_scnptr, -GO32_STUBSIZE);\n-  ADJUST_VAL (scnhdr_int->s_relptr, -GO32_STUBSIZE);\n-  ADJUST_VAL (scnhdr_int->s_lnnoptr, -GO32_STUBSIZE);\n-}\n-\n-static void\n-adjust_scnhdr_out_post (bfd *  abfd ATTRIBUTE_UNUSED,\n-\t\t\tvoid * in,\n-\t\t\tvoid * out ATTRIBUTE_UNUSED)\n-{\n-  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;\n-\n-  ADJUST_VAL (scnhdr_int->s_scnptr, GO32_STUBSIZE);\n-  ADJUST_VAL (scnhdr_int->s_relptr, GO32_STUBSIZE);\n-  ADJUST_VAL (scnhdr_int->s_lnnoptr, GO32_STUBSIZE);\n-}\n-\n-static void\n-adjust_aux_in_post (bfd * abfd ATTRIBUTE_UNUSED,\n-\t\t    void * ext1 ATTRIBUTE_UNUSED,\n-\t\t    int type,\n-\t\t    int in_class,\n-\t\t    int indx ATTRIBUTE_UNUSED,\n-\t\t    int numaux ATTRIBUTE_UNUSED,\n-\t\t    void * in1)\n-{\n-  union internal_auxent *in = (union internal_auxent *) in1;\n-\n-  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)\n-      || ISTAG (in_class))\n-    {\n-      ADJUST_VAL (in->x_sym.x_fcnary.x_fcn.x_lnnoptr, GO32_STUBSIZE);\n-    }\n-}\n-\n-static void\n-adjust_aux_out_pre (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t    void * inp,\n-\t\t    int type,\n-\t\t    int in_class,\n-\t\t    int indx ATTRIBUTE_UNUSED,\n-\t\t    int numaux ATTRIBUTE_UNUSED,\n-\t\t    void * extp ATTRIBUTE_UNUSED)\n-{\n-  union internal_auxent *in = (union internal_auxent *) inp;\n-\n-  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)\n-      || ISTAG (in_class))\n-    {\n-      ADJUST_VAL (in->x_sym.x_fcnary.x_fcn.x_lnnoptr, -GO32_STUBSIZE);\n-    }\n-}\n-\n-static void\n-adjust_aux_out_post (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t     void * inp,\n-\t\t     int type,\n-\t\t     int in_class,\n-\t\t     int indx ATTRIBUTE_UNUSED,\n-\t\t     int numaux ATTRIBUTE_UNUSED,\n-\t\t     void * extp ATTRIBUTE_UNUSED)\n-{\n-  union internal_auxent *in = (union internal_auxent *) inp;\n-\n-  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)\n-      || ISTAG (in_class))\n-    {\n-      ADJUST_VAL (in->x_sym.x_fcnary.x_fcn.x_lnnoptr, GO32_STUBSIZE);\n-    }\n-}\n+/* Temporary location for stub read from input file.  */\n+static char * go32exe_temp_stub = NULL;\n+static bfd_size_type go32exe_temp_stub_size = 0;\n \n /* That's the function, which creates the stub. There are\n    different cases from where the stub is taken.\n@@ -275,13 +88,16 @@ adjust_aux_out_post (bfd *abfd ATTRIBUTE_UNUSED,\n    file.\n \n    If there was any error, the standard stub (compiled in this file)\n-   is taken.  */\n+   is taken.\n+\n+   Ideally this function should exec '$(TARGET)-stubify' to generate\n+   a stub, like gcc does.  */\n \n static void\n-create_go32_stub (bfd *abfd)\n+go32exe_create_stub (bfd *abfd)\n {\n   /* Do it only once.  */\n-  if (coff_data (abfd)->go32stub == NULL)\n+  if (coff_data (abfd)->stub == NULL)\n     {\n       char *stub;\n       struct stat st;\n@@ -291,6 +107,22 @@ create_go32_stub (bfd *abfd)\n       unsigned long coff_start;\n       long exe_start;\n \n+      /* If we read a stub from an input file, use that one.  */\n+      if (go32exe_temp_stub != NULL)\n+\t{\n+\t  coff_data (abfd)->stub = bfd_alloc (abfd,\n+\t\t\t\t\t\t  go32exe_temp_stub_size);\n+\t  if (coff_data (abfd)->stub == NULL)\n+\t    return;\n+\t  memcpy (coff_data (abfd)->stub, go32exe_temp_stub,\n+\t\t  go32exe_temp_stub_size);\n+\t  coff_data (abfd)->stub_size = go32exe_temp_stub_size;\n+\t  free (go32exe_temp_stub);\n+\t  go32exe_temp_stub = NULL;\n+\t  go32exe_temp_stub_size = 0;\n+\t  return;\n+\t}\n+\n       /* Check at first the environment variable $(GO32STUB).  */\n       stub = getenv (\"GO32STUB\");\n       /* Now check the environment variable $(STUB).  */\n@@ -323,13 +155,6 @@ create_go32_stub (bfd *abfd)\n       if (_H (1))\n \tcoff_start += (long) _H (1) - 512L;\n \n-      /* Currently there is only a fixed stub size of 2048 bytes\n-\t supported.  */\n-      if (coff_start != 2048)\n-\t{\n-\t  close (f);\n-\t  goto stub_end;\n-\t}\n       exe_start = _H (4) * 16;\n       if ((long) lseek (f, exe_start, SEEK_SET) != exe_start)\n \t{\n@@ -347,78 +172,212 @@ create_go32_stub (bfd *abfd)\n \t  goto stub_end;\n \t}\n       /* Now we found a correct stub (hopefully).  */\n-      coff_data (abfd)->go32stub = bfd_alloc (abfd, (bfd_size_type) coff_start);\n-      if (coff_data (abfd)->go32stub == NULL)\n+      coff_data (abfd)->stub = bfd_alloc (abfd, (bfd_size_type) coff_start);\n+      if (coff_data (abfd)->stub == NULL)\n \t{\n \t  close (f);\n \t  return;\n \t}\n       lseek (f, 0L, SEEK_SET);\n-      if ((unsigned long) read (f, coff_data (abfd)->go32stub, coff_start)\n+      if ((unsigned long) read (f, coff_data (abfd)->stub, coff_start)\n \t  != coff_start)\n \t{\n-\t  bfd_release (abfd, coff_data (abfd)->go32stub);\n-\t  coff_data (abfd)->go32stub = NULL;\n+\t  bfd_release (abfd, coff_data (abfd)->stub);\n+\t  coff_data (abfd)->stub = NULL;\n \t}\n+      else\n+\tcoff_data (abfd)->stub_size = coff_start;\n       close (f);\n     }\n  stub_end:\n   /* There was something wrong above, so use now the standard builtin\n      stub.  */\n-  if (coff_data (abfd)->go32stub == NULL)\n+  if (coff_data (abfd)->stub == NULL)\n     {\n-      coff_data (abfd)->go32stub\n-\t= bfd_alloc (abfd, (bfd_size_type) GO32_STUBSIZE);\n-      if (coff_data (abfd)->go32stub == NULL)\n+      coff_data (abfd)->stub\n+\t= bfd_alloc (abfd, (bfd_size_type) GO32EXE_DEFAULT_STUB_SIZE);\n+      if (coff_data (abfd)->stub == NULL)\n \treturn;\n-      memcpy (coff_data (abfd)->go32stub, stub_bytes, GO32_STUBSIZE);\n+      memcpy (coff_data (abfd)->stub, go32exe_default_stub,\n+\t      GO32EXE_DEFAULT_STUB_SIZE);\n+      coff_data (abfd)->stub_size = GO32EXE_DEFAULT_STUB_SIZE;\n     }\n }\n \n /* If ibfd was a stubbed coff image, copy the stub from that bfd\n    to the new obfd.  */\n \n static bfd_boolean\n-go32_stubbed_coff_bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd)\n+go32exe_copy_private_bfd_data (bfd *ibfd, bfd *obfd)\n {\n   /* Check if both are the same targets.  */\n   if (ibfd->xvec != obfd->xvec)\n     return TRUE;\n \n-  /* Check if we have a source stub.  */\n-  if (coff_data (ibfd)->go32stub == NULL)\n-    return TRUE;\n+  /* Make sure we have a source stub.  */\n+  BFD_ASSERT (coff_data (ibfd)->stub != NULL);\n \n-  /* As adjust_filehdr_out_pre may get called only after this function,\n-     optionally allocate the output stub.  */\n-  if (coff_data (obfd)->go32stub == NULL)\n-    coff_data (obfd)->go32stub = bfd_alloc (obfd,\n-\t\t\t\t\t  (bfd_size_type) GO32_STUBSIZE);\n+  /* Reallocate the output stub if necessary.  */\n+  if (coff_data (ibfd)->stub_size > coff_data (obfd)->stub_size)\n+    coff_data (obfd)->stub = bfd_alloc (obfd, coff_data (ibfd)->stub_size);\n+  if (coff_data (obfd)->stub == NULL)\n+    return FALSE;\n \n   /* Now copy the stub.  */\n-  if (coff_data (obfd)->go32stub != NULL)\n-    memcpy (coff_data (obfd)->go32stub, coff_data (ibfd)->go32stub,\n-\t    GO32_STUBSIZE);\n+  memcpy (coff_data (obfd)->stub, coff_data (ibfd)->stub,\n+\t  coff_data (ibfd)->stub_size);\n+  coff_data (obfd)->stub_size = coff_data (ibfd)->stub_size;\n+  obfd->origin = coff_data (obfd)->stub_size;\n \n   return TRUE;\n }\n \n-/* coff_object_p only checks 2 bytes F_MAGIC at GO32_STUBSIZE inside the file\n-   which is too fragile.  */\n+/* Cleanup function, returned from check_format hook.  */\n \n-static bfd_cleanup\n-go32_check_format (bfd *abfd)\n+static void\n+go32exe_cleanup (bfd *abfd)\n {\n-  char mz[2];\n+  abfd->origin = 0;\n+\n+  if (go32exe_temp_stub != NULL)\n+    free (go32exe_temp_stub);\n+  go32exe_temp_stub = NULL;\n+  go32exe_temp_stub_size = 0;\n+}\n \n-  if (bfd_bread (mz, 2, abfd) != 2 || mz[0] != 'M' || mz[1] != 'Z')\n+/* Check that there is a GO32 stub and read it to go32exe_temp_stub.\n+   Then set abfd->origin so that the COFF image is read at the correct\n+   file offset.  */\n+\n+static bfd_cleanup\n+go32exe_check_format (bfd *abfd)\n+{\n+  struct external_DOS_hdr filehdr_dos;\n+  uint16_t num_pages;\n+  uint16_t last_page_size;\n+  uint32_t header_end;\n+  bfd_size_type stubsize;\n+\n+  /* This format can not appear in an archive.  */\n+  if (abfd->origin != 0)\n     {\n       bfd_set_error (bfd_error_wrong_format);\n       return NULL;\n     }\n \n+  bfd_set_error (bfd_error_system_call);\n+\n+  /* Read in the stub file header, which is a DOS MZ executable.  */\n+  if (bfd_bread (&filehdr_dos, DOS_HDR_SIZE, abfd) != DOS_HDR_SIZE)\n+    goto fail;\n+\n+  /* Make sure that this is an MZ executable.  */\n+  if (H_GET_16 (abfd, filehdr_dos.e_magic) != IMAGE_DOS_SIGNATURE)\n+    goto fail_format;\n+\n+  /* Determine the size of the stub  */\n+  num_pages = H_GET_16 (abfd, filehdr_dos.e_cp);\n+  last_page_size = H_GET_16 (abfd, filehdr_dos.e_cblp);\n+  stubsize = num_pages * 512;\n+  if (last_page_size != 0)\n+    stubsize += last_page_size - 512;\n+\n+  /* Save now the stub to be used later.  Put the stub data to a temporary\n+     location first as tdata still does not exist.  It may not even\n+     be ever created if we are just checking the file format of ABFD.  */\n+  bfd_seek (abfd, 0, SEEK_SET);\n+  go32exe_temp_stub = bfd_malloc (stubsize);\n+  if (go32exe_temp_stub == NULL)\n+    goto fail;\n+  if (bfd_bread (go32exe_temp_stub, stubsize, abfd) != stubsize)\n+    goto fail;\n+  go32exe_temp_stub_size = stubsize;\n+\n+  /* Confirm that this is a go32stub.  */\n+  header_end = H_GET_16 (abfd, filehdr_dos.e_cparhdr) * 16UL;\n+  if (! CONST_STRNEQ (go32exe_temp_stub + header_end, \"go32stub\"))\n+    goto fail_format;\n+\n+  /* Set origin to where the COFF header starts and seek there.  */\n+  abfd->origin = stubsize;\n   if (bfd_seek (abfd, 0, SEEK_SET) != 0)\n-    return NULL;\n+    goto fail;\n+\n+  /* Call coff_object_p to read the COFF image.  If this fails then the file\n+     must be just a stub with no COFF data attached.  */\n+  bfd_cleanup cleanup = coff_object_p (abfd);\n+  if (cleanup == NULL)\n+    goto fail;\n+  BFD_ASSERT (cleanup == _bfd_no_cleanup);\n+\n+  return go32exe_cleanup;\n+\n+ fail_format:\n+  bfd_set_error (bfd_error_wrong_format);\n+ fail:\n+  go32exe_cleanup (abfd);\n+  return NULL;\n+}\n+\n+/* Write the stub to the output file, then call coff_write_object_contents.  */\n+\n+static bfd_boolean\n+go32exe_write_object_contents (bfd *abfd)\n+{\n+  const bfd_size_type pos = bfd_tell (abfd);\n+  const bfd_size_type stubsize = coff_data (abfd)->stub_size;\n+\n+  BFD_ASSERT (stubsize != 0);\n+\n+  bfd_set_error (bfd_error_system_call);\n \n-  return coff_object_p (abfd);\n+  /* Write the stub.  */\n+  abfd->origin = 0;\n+  if (bfd_seek (abfd, 0, SEEK_SET) != 0)\n+    return FALSE;\n+  if (bfd_bwrite (coff_data (abfd)->stub, stubsize, abfd) != stubsize)\n+    return FALSE;\n+\n+  /* Seek back to where we were.  */\n+  abfd->origin = stubsize;\n+  if (bfd_seek (abfd, pos, SEEK_SET) != 0)\n+    return FALSE;\n+\n+  return coff_write_object_contents (abfd);\n+}\n+\n+/* mkobject hook.  Called directly through bfd_set_format or via\n+   coff_mkobject_hook etc from bfd_check_format.  */\n+\n+static bfd_boolean\n+go32exe_mkobject (bfd *abfd)\n+{\n+  coff_data_type *coff = NULL;\n+  const bfd_size_type amt = sizeof (coff_data_type);\n+\n+  /* Don't output to an archive.  */\n+  if (abfd->my_archive != NULL)\n+    return FALSE;\n+\n+  abfd->tdata.coff_obj_data = bfd_zalloc (abfd, amt);\n+  if (abfd->tdata.coff_obj_data == NULL)\n+    return FALSE;\n+  coff = coff_data (abfd);\n+  coff->symbols = NULL;\n+  coff->conversion_table = NULL;\n+  coff->raw_syments = NULL;\n+  coff->relocbase = 0;\n+  coff->local_toc_sym_map = 0;\n+\n+  go32exe_create_stub (abfd);\n+  if (coff->stub == NULL)\n+    {\n+      bfd_release (abfd, coff);\n+      return FALSE;\n+    }\n+  abfd->origin = coff->stub_size;\n+\n+/*  make_abs_section(abfd);*/ /* ??? */\n+\n+  return TRUE;\n }"
    },
    {
      "sha": "3bee5d2f9d5b6098f190a0096880889f9faa6ab2",
      "filename": "bfd/coffcode.h",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/coffcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/coffcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffcode.h?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -2076,15 +2076,6 @@ coff_mkobject_hook (bfd * abfd,\n     abfd->flags |= HAS_DEBUG;\n #endif\n \n-  if ((internal_f->f_flags & F_GO32STUB) != 0)\n-    {\n-      coff->go32stub = (char *) bfd_alloc (abfd, (bfd_size_type) GO32_STUBSIZE);\n-      if (coff->go32stub == NULL)\n-\treturn NULL;\n-    }\n-  if (coff->go32stub != NULL)\n-    memcpy (coff->go32stub, internal_f->go32stub, GO32_STUBSIZE);\n-\n   return coff;\n }\n #endif"
    },
    {
      "sha": "e4155d286f4140b498712aad16d295f83aba8a5e",
      "filename": "bfd/libcoff-in.h",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/libcoff-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/libcoff-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libcoff-in.h?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -114,9 +114,11 @@ typedef struct coff_tdata\n      used by ARM code.  */\n   flagword flags;\n \n-  /* coff-stgo32 EXE stub header after BFD tdata has been allocated.  Its data\n-     is kept in internal_filehdr.go32stub beforehand.  */\n-  char *go32stub;\n+  /* A stub (extra data prepended before the COFF image) and its size.\n+     Used by coff-go32-exe, it contains executable data that loads the\n+     COFF object into memory.  */\n+  char * stub;\n+  bfd_size_type stub_size;\n } coff_data_type;\n \n /* Tdata for pe image files.  */"
    },
    {
      "sha": "44c85d96c151c66fe2af36a2953c8d6506ab7b7e",
      "filename": "bfd/libcoff.h",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/bfd/libcoff.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/bfd/libcoff.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libcoff.h?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -118,9 +118,11 @@ typedef struct coff_tdata\n      used by ARM code.  */\n   flagword flags;\n \n-  /* coff-stgo32 EXE stub header after BFD tdata has been allocated.  Its data\n-     is kept in internal_filehdr.go32stub beforehand.  */\n-  char *go32stub;\n+  /* A stub (extra data prepended before the COFF image) and its size.\n+     Used by coff-go32-exe, it contains executable data that loads the\n+     COFF object into memory.  */\n+  char * stub;\n+  bfd_size_type stub_size;\n } coff_data_type;\n \n /* Tdata for pe image files.  */"
    },
    {
      "sha": "7964db299b98c44d4e0165a401066dd6b98a477b",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -1,3 +1,9 @@\n+2020-04-02  Jan W. Jagersma  <jwjagersma@gmail.com>\n+\n+\t* coff/go32exe.h: Remove file.\n+\t* coff/internal.h (struct internal_filehdr): Remove field\n+\tgo32stub.  Remove flag F_GO32STUB.\n+\n 2020-04-01  Martin Liska  <mliska@suse.cz>\n \t    Maciej W. Rozycki <macro@linux-mips.org>\n "
    },
    {
      "sha": "af6de2c759b553f8e02f6df85a76cbec7bd9ada3",
      "filename": "include/coff/go32exe.h",
      "status": "removed",
      "additions": 0,
      "deletions": 36,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dd7b52ede3de7c5e43cc7c0a52a4e2f2b4297b7/include/coff/go32exe.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dd7b52ede3de7c5e43cc7c0a52a4e2f2b4297b7/include/coff/go32exe.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/coff/go32exe.h?ref=0dd7b52ede3de7c5e43cc7c0a52a4e2f2b4297b7",
      "patch": "@@ -1,36 +0,0 @@\n-/* COFF information for PC running go32.\n-\n-   Copyright (C) 2001-2020 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-   \n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-   \n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n-   MA 02110-1301, USA.  */\n-\n-struct external_filehdr_go32_exe\n-  {\n-    char stub[GO32_STUBSIZE]; /* the stub to load the image */\n-\t\t\t/* the standard COFF header     */\n-    char f_magic[2];\t/* magic number\t\t\t*/\n-    char f_nscns[2];\t/* number of sections\t\t*/\n-    char f_timdat[4];\t/* time & date stamp\t\t*/\n-    char f_symptr[4];\t/* file pointer to symtab\t*/\n-    char f_nsyms[4];\t/* number of symtab entries\t*/\n-    char f_opthdr[2];\t/* sizeof(optional hdr)\t\t*/\n-    char f_flags[2];\t/* flags\t\t\t*/\n-  };\n-\n-#undef FILHDR\n-#define\tFILHDR\tstruct external_filehdr_go32_exe\n-#undef FILHSZ\n-#define\tFILHSZ\tGO32_STUBSIZE+20"
    },
    {
      "sha": "2b6c08cb508b89e7c735bdaa21551dabd0d3cf2c",
      "filename": "include/coff/internal.h",
      "status": "modified",
      "additions": 1,
      "deletions": 12,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4d095f5b5e57584133f85df42da2123e20834aec/include/coff/internal.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4d095f5b5e57584133f85df42da2123e20834aec/include/coff/internal.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/coff/internal.h?ref=4d095f5b5e57584133f85df42da2123e20834aec",
      "patch": "@@ -58,19 +58,10 @@ struct internal_extra_pe_filehdr\n   bfd_vma  nt_signature;   \t/* required NT signature, 0x4550 */\n };\n \n-#define GO32_STUBSIZE 2048\n-\n struct internal_filehdr\n {\n   struct internal_extra_pe_filehdr pe;\n \n-  /* coff-stgo32 EXE stub header before BFD tdata has been allocated.\n-     Its data is kept in INTERNAL_FILEHDR.GO32STUB afterwards.\n-\n-     F_GO32STUB is set iff go32stub contains a valid data.  Artifical headers\n-     created in BFD have no pre-set go32stub.  */\n-  char go32stub[GO32_STUBSIZE];\n-\n   /* Standard coff internal info.  */\n   unsigned short f_magic;\t/* magic number\t\t\t*/\n   unsigned int   f_nscns;\t/* number of sections\t\t*/\n@@ -93,8 +84,7 @@ struct internal_filehdr\n  \tF_AR32W\t\tfile is 32-bit big-endian\n  \tF_DYNLOAD\trs/6000 aix: dynamically loadable w/imports & exports\n  \tF_SHROBJ\trs/6000 aix: file is a shared object\n-\tF_DLL           PE format DLL\n-\tF_GO32STUB      Field go32stub contains valid data.  */\n+\tF_DLL           PE format DLL  */\n \n #define\tF_RELFLG\t(0x0001)\n #define\tF_EXEC\t\t(0x0002)\n@@ -106,7 +96,6 @@ struct internal_filehdr\n #define\tF_DYNLOAD\t(0x1000)\n #define\tF_SHROBJ\t(0x2000)\n #define F_DLL           (0x2000)\n-#define F_GO32STUB      (0x4000)\n \n /* Extra structure which is used in the optional header.  */\n typedef struct _IMAGE_DATA_DIRECTORY"
    }
  ]
}