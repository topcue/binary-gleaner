{
  "sha": "d19c3068ab17598662fe562e96bc1943b2b49736",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDE5YzMwNjhhYjE3NTk4NjYyZmU1NjJlOTZiYzE5NDNiMmI0OTczNg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-08-22T15:14:46Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-22T15:14:46Z"
    },
    "message": "gdb: assert that we don't try to get a frame's id while it is computed\n\nI'm dealing these days with a class of bugs that involve trying to get a\ncertain frame's id while we are in the process of computing it.  In other\nwords, compute_frame_id being called for a frame, eventually calling\nget_frame_id for that same frame.  I don't think this is ever supposed to\nhappen, as that creates a cyclic dependency.\n\nUsually, these problems cause some failure down the line.  I'm proposing with\nthis patch to catch them as early as possible, as soon as the situation\ndescribed above happens.  I think that helps because the failed assertion will\nbe closer to the root of the problem.\n\nTo do so, the patch changes the frame_info::this_id::p flag from a boolean (is\nthe frame id computed or not) to a tri-state:\n\n- the frame id is not computed\n- the frame id is being computed\n- the frame id is computed\n\nThen, we can properly assert that get_frame_id doesn't get called for a frame\nwhose id is being computed.\n\nTo illustrate how that can help, let's imagine we apply the following change to\nframe_unwind_got_optimized:\n\n    --- a/gdb/frame-unwind.c\n    +++ b/gdb/frame-unwind.c\n    @@ -260,8 +260,7 @@ frame_unwind_got_optimized (struct frame_info *frame, int regnum)\n       mark_value_bytes_optimized_out (val, 0, TYPE_LENGTH (type));\n       VALUE_LVAL (val) = lval_register;\n       VALUE_REGNUM (val) = regnum;\n    -  VALUE_NEXT_FRAME_ID (val)\n    -    = get_frame_id (get_next_frame_sentinel_okay (frame));\n    +  VALUE_NEXT_FRAME_ID (val) = get_frame_id (frame);\n       return val;\n     }\n\n... and run the following command, which leads to a failed assertion (you need\nto run the corresponding test to generate the binary first):\n\n    $ ./gdb -q -nx testsuite/outputs/gdb.dwarf2/dw2-undefined-ret-addr/dw2-undefined-ret-addr -ex \"b stop_frame\" -ex r\n\nWithout this patch applied, we catch the issue indirectly, when the top-level\nget_frame_id tries to stash the frame:\n\n    /home/smarchi/src/binutils-gdb/gdb/frame.c:593: internal-error: frame_id get_frame_id(frame_info*): Assertion `stashed' failed.\n\n    ...\n    #9  0x0000000001af1c3a in internal_error (file=0x1cea060 \"/home/smarchi/src/binutils-gdb/gdb/frame.c\", line=593, fmt=0x1ce9f80 \"%s: Assertion `%s' failed.\") at /home/smarchi/src/binutils-gdb/gdbsupport/errors.cc:55\n    #10 0x0000000000e9b413 in get_frame_id (fi=0x6210005105e0) at /home/smarchi/src/binutils-gdb/gdb/frame.c:593\n    #11 0x0000000000e99e35 in scoped_restore_selected_frame::scoped_restore_selected_frame (this=0x7fff1d8b9760) at /home/smarchi/src/binutils-gdb/gdb/frame.c:308\n    #12 0x000000000149a261 in print_frame_args (fp_opts=..., func=0x6210000dd7d0, frame=0x6210005105e0, num=-1, stream=0x60300008a580) at /home/smarchi/src/binutils-gdb/gdb/stack.c:750\n    #13 0x000000000149d938 in print_frame (fp_opts=..., frame=0x6210005105e0, print_level=0, print_what=SRC_AND_LOC, print_args=1, sal=...) at /home/smarchi/src/binutils-gdb/gdb/stack.c:1394\n    #14 0x000000000149c0c8 in print_frame_info (fp_opts=..., frame=0x6210005105e0, print_level=0, print_what=SRC_AND_LOC, print_args=1, set_current_sal=1) at /home/smarchi/src/binutils-gdb/gdb/stack.c:1119\n    #15 0x0000000001498100 in print_stack_frame (frame=0x6210005105e0, print_level=0, print_what=SRC_AND_LOC, set_current_sal=1) at /home/smarchi/src/binutils-gdb/gdb/stack.c:366\n    #16 0x00000000010234b7 in print_stop_location (ws=0x7fff1d8ba1f0) at /home/smarchi/src/binutils-gdb/gdb/infrun.c:8366\n    #17 0x000000000102362d in print_stop_event (uiout=0x607000018660, displays=true) at /home/smarchi/src/binutils-gdb/gdb/infrun.c:8382\n    ...\n\nIt freaks out because the frame is already in the stash: it was added by an\ninner call to get_frame_id, called indirectly by compute_frame_id.  Debugging\nthis failure is difficult because we have to backtrack to where this happened.\n\nWith the patch applied, we catch the issue earlier, here:\n\n    /home/smarchi/src/binutils-gdb/gdb/frame.c:601: internal-error: frame_id get_frame_id(frame_info*): Assertion `fi->this_id.p != frame_id_status::COMPUTING' failed\n\n    ...\n    #9  0x0000000001af22bc in internal_error (file=0x1cea6e0 \"/home/smarchi/src/binutils-gdb/gdb/frame.c\", line=601, fmt=0x1cea600 \"%s: Assertion `%s' failed.\") at /home/smarchi/src/binutils-gdb/gdbsupport/errors.cc:55\n    #10 0x0000000000e9b7e3 in get_frame_id (fi=0x62100050dde0) at /home/smarchi/src/binutils-gdb/gdb/frame.c:601\n    #11 0x0000000000e989b3 in frame_unwind_got_optimized (frame=0x62100050dde0, regnum=16) at /home/smarchi/src/binutils-gdb/gdb/frame-unwind.c:264\n    #12 0x0000000000cbe386 in dwarf2_frame_prev_register (this_frame=0x62100050dde0, this_cache=0x62100050ddf8, regnum=16) at /home/smarchi/src/binutils-gdb/gdb/dwarf2/frame.c:1267\n    #13 0x0000000000e9f569 in frame_unwind_register_value (next_frame=0x62100050dde0, regnum=16) at /home/smarchi/src/binutils-gdb/gdb/frame.c:1266\n    #14 0x0000000000e9eaab in frame_register_unwind (next_frame=0x62100050dde0, regnum=16, optimizedp=0x7ffca814ade0, unavailablep=0x7ffca814adf0, lvalp=0x7ffca814ae10, addrp=0x7ffca814ae20, realnump=0x7ffca814ae00, bufferp=0x7ffca814aec0 \"\") at /home/smarchi/src/binutils-gdb/gdb/frame.c:1169\n    #15 0x0000000000e9f233 in frame_unwind_register (next_frame=0x62100050dde0, regnum=16, buf=0x7ffca814aec0 \"\") at /home/smarchi/src/binutils-gdb/gdb/frame.c:1225\n    #16 0x0000000000f84262 in i386_unwind_pc (gdbarch=0x6210000eed10, next_frame=0x62100050dde0) at /home/smarchi/src/binutils-gdb/gdb/i386-tdep.c:1969\n    #17 0x0000000000ec95dd in gdbarch_unwind_pc (gdbarch=0x6210000eed10, next_frame=0x62100050dde0) at /home/smarchi/src/binutils-gdb/gdb/gdbarch.c:3062\n    #18 0x0000000000cb5e9d in dwarf2_tailcall_sniffer_first (this_frame=0x62100050dde0, tailcall_cachep=0x62100050dee0, entry_cfa_sp_offsetp=0x7ffca814b160) at /home/smarchi/src/binutils-gdb/gdb/dwarf2/frame-tailcall.c:387\n    #19 0x0000000000cbdd38 in dwarf2_frame_cache (this_frame=0x62100050dde0, this_cache=0x62100050ddf8) at /home/smarchi/src/binutils-gdb/gdb/dwarf2/frame.c:1198\n    #20 0x0000000000cbe026 in dwarf2_frame_this_id (this_frame=0x62100050dde0, this_cache=0x62100050ddf8, this_id=0x62100050de40) at /home/smarchi/src/binutils-gdb/gdb/dwarf2/frame.c:1226\n    #21 0x0000000000e9b447 in compute_frame_id (fi=0x62100050dde0) at /home/smarchi/src/binutils-gdb/gdb/frame.c:580\n    #22 0x0000000000e9b89e in get_frame_id (fi=0x62100050dde0) at /home/smarchi/src/binutils-gdb/gdb/frame.c:613\n    #23 0x0000000000e99e35 in scoped_restore_selected_frame::scoped_restore_selected_frame (this=0x7ffca814b610) at /home/smarchi/src/binutils-gdb/gdb/frame.c:315\n    #24 0x000000000149a8e3 in print_frame_args (fp_opts=..., func=0x6210000dd7d0, frame=0x62100050dde0, num=-1, stream=0x60300008a520) at /home/smarchi/src/binutils-gdb/gdb/stack.c:750\n    #25 0x000000000149dfba in print_frame (fp_opts=..., frame=0x62100050dde0, print_level=0, print_what=SRC_AND_LOC, print_args=1, sal=...) at /home/smarchi/src/binutils-gdb/gdb/stack.c:1394\n    #26 0x000000000149c74a in print_frame_info (fp_opts=..., frame=0x62100050dde0, print_level=0, print_what=SRC_AND_LOC, print_args=1, set_current_sal=1) at /home/smarchi/src/binutils-gdb/gdb/stack.c:1119\n    #27 0x0000000001498782 in print_stack_frame (frame=0x62100050dde0, print_level=0, print_what=SRC_AND_LOC, set_current_sal=1) at /home/smarchi/src/binutils-gdb/gdb/stack.c:366\n    #28 0x0000000001023b39 in print_stop_location (ws=0x7ffca814c0a0) at /home/smarchi/src/binutils-gdb/gdb/infrun.c:8366\n    #29 0x0000000001023caf in print_stop_event (uiout=0x607000018660, displays=true) at /home/smarchi/src/binutils-gdb/gdb/infrun.c:8382\n    ...\n\nNow, we can clearly see that get_frame_id for frame `fi=0x62100050dde0` gets\ncalled while compute_frame_id is active for that frame.  The backtrace is more\nhelpful to identify the root of the problem.\n\ngdb/ChangeLog:\n\n\t* frame.c (enum class frame_id_status): New.\n\t(struct frame_info) <this_id::p>: Change type to frame_id_status.\n\t(fprintf_frame): Update.\n\t(compute_frame_id): Set frame id status to \"computing\" on entry.\n\tSet it back to \"not_computed\" on failure and to \"computed\" on\n\tsuccess.\n\t(get_frame_id): Assert the frame id is not being computed.\n\t(create_sentinel_frame): Use frame_id_status::COMPUTED.\n\t(create_new_frame): Likewise.\n\t(frame_cleanup_after_sniffer): Update assert.\n\nChange-Id: I5f1a25fafe045f756bd75f358892720b30ed20c9",
    "tree": {
      "sha": "b3e2ed983a74b7a91b3624c7ce4eb70a86621439",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b3e2ed983a74b7a91b3624c7ce4eb70a86621439"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d19c3068ab17598662fe562e96bc1943b2b49736",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d19c3068ab17598662fe562e96bc1943b2b49736",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d19c3068ab17598662fe562e96bc1943b2b49736",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d19c3068ab17598662fe562e96bc1943b2b49736/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1d4ef7201ffa3174931f36befbe032e0a41836f6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1d4ef7201ffa3174931f36befbe032e0a41836f6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1d4ef7201ffa3174931f36befbe032e0a41836f6"
    }
  ],
  "stats": {
    "total": 110,
    "additions": 85,
    "deletions": 25
  },
  "files": [
    {
      "sha": "2e0534e2a609afbe4a099c709171fbddaeee18e8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d19c3068ab17598662fe562e96bc1943b2b49736/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d19c3068ab17598662fe562e96bc1943b2b49736/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d19c3068ab17598662fe562e96bc1943b2b49736",
      "patch": "@@ -1,3 +1,16 @@\n+2020-08-22  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* frame.c (enum class frame_id_status): New.\n+\t(struct frame_info) <this_id::p>: Change type to frame_id_status.\n+\t(fprintf_frame): Update.\n+\t(compute_frame_id): Set frame id status to \"computing\" on entry.\n+\tSet it back to \"not_computed\" on failure and to \"computed\" on\n+\tsuccess.\n+\t(get_frame_id): Assert the frame id is not being computed.\n+\t(create_sentinel_frame): Use frame_id_status::COMPUTED.\n+\t(create_new_frame): Likewise.\n+\t(frame_cleanup_after_sniffer): Update assert.\n+\n 2020-08-20  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* regcache.c (pid_ptid_regcache_map): New type."
    },
    {
      "sha": "7ab3cdcdad41ada2ccda9dc424666ce2149a0c4c",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 72,
      "deletions": 25,
      "changes": 97,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d19c3068ab17598662fe562e96bc1943b2b49736/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d19c3068ab17598662fe562e96bc1943b2b49736/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=d19c3068ab17598662fe562e96bc1943b2b49736",
      "patch": "@@ -87,6 +87,18 @@ enum cached_copy_status\n   CC_UNAVAILABLE\n };\n \n+enum class frame_id_status\n+{\n+  /* Frame id is not computed.  */\n+  NOT_COMPUTED = 0,\n+\n+  /* Frame id is being computed (compute_frame_id is active).  */\n+  COMPUTING,\n+\n+  /* Frame id has been computed.  */\n+  COMPUTED,\n+};\n+\n /* We keep a cache of stack frames, each of which is a \"struct\n    frame_info\".  The innermost one gets allocated (in\n    wait_for_inferior) each time the inferior stops; sentinel_frame\n@@ -149,7 +161,7 @@ struct frame_info\n   /* This frame's ID.  */\n   struct\n   {\n-    bool p;\n+    frame_id_status p;\n     struct frame_id value;\n   } this_id;\n \n@@ -439,21 +451,25 @@ fprint_frame (struct ui_file *file, struct frame_info *fi)\n       fprintf_unfiltered (file, \"<NULL frame>\");\n       return;\n     }\n+\n   fprintf_unfiltered (file, \"{\");\n   fprintf_unfiltered (file, \"level=%d\", fi->level);\n   fprintf_unfiltered (file, \",\");\n+\n   fprintf_unfiltered (file, \"type=\");\n   if (fi->unwind != NULL)\n     fprint_frame_type (file, fi->unwind->type);\n   else\n     fprintf_unfiltered (file, \"<unknown>\");\n   fprintf_unfiltered (file, \",\");\n+\n   fprintf_unfiltered (file, \"unwind=\");\n   if (fi->unwind != NULL)\n     gdb_print_host_address (fi->unwind, file);\n   else\n     fprintf_unfiltered (file, \"<unknown>\");\n   fprintf_unfiltered (file, \",\");\n+\n   fprintf_unfiltered (file, \"pc=\");\n   if (fi->next == NULL || fi->next->prev_pc.status == CC_UNKNOWN)\n     fprintf_unfiltered (file, \"<unknown>\");\n@@ -468,12 +484,16 @@ fprint_frame (struct ui_file *file, struct frame_info *fi)\n   else if (fi->next->prev_pc.status == CC_UNAVAILABLE)\n     val_print_unavailable (file);\n   fprintf_unfiltered (file, \",\");\n+\n   fprintf_unfiltered (file, \"id=\");\n-  if (fi->this_id.p)\n-    fprint_frame_id (file, fi->this_id.value);\n+  if (fi->this_id.p == frame_id_status::NOT_COMPUTED)\n+    fprintf_unfiltered (file, \"<not computed>\");\n+  else if (fi->this_id.p == frame_id_status::COMPUTING)\n+    fprintf_unfiltered (file, \"<computing>\");\n   else\n-    fprintf_unfiltered (file, \"<unknown>\");\n+    fprint_frame_id (file, fi->this_id.value);\n   fprintf_unfiltered (file, \",\");\n+\n   fprintf_unfiltered (file, \"func=\");\n   if (fi->next != NULL && fi->next->prev_func.status == CC_VALUE)\n     fprintf_unfiltered (file, \"%s\", hex_string (fi->next->prev_func.addr));\n@@ -544,25 +564,48 @@ skip_tailcall_frames (struct frame_info *frame)\n static void\n compute_frame_id (struct frame_info *fi)\n {\n-  gdb_assert (!fi->this_id.p);\n+  gdb_assert (fi->this_id.p == frame_id_status::NOT_COMPUTED);\n \n-  if (frame_debug)\n-    fprintf_unfiltered (gdb_stdlog, \"{ compute_frame_id (fi=%d) \",\n-\t\t\tfi->level);\n-  /* Find the unwinder.  */\n-  if (fi->unwind == NULL)\n-    frame_unwind_find_by_frame (fi, &fi->prologue_cache);\n-  /* Find THIS frame's ID.  */\n-  /* Default to outermost if no ID is found.  */\n-  fi->this_id.value = outer_frame_id;\n-  fi->unwind->this_id (fi, &fi->prologue_cache, &fi->this_id.value);\n-  gdb_assert (frame_id_p (fi->this_id.value));\n-  fi->this_id.p = true;\n-  if (frame_debug)\n+  unsigned int entry_generation = get_frame_cache_generation ();\n+\n+  try\n     {\n-      fprintf_unfiltered (gdb_stdlog, \"-> \");\n-      fprint_frame_id (gdb_stdlog, fi->this_id.value);\n-      fprintf_unfiltered (gdb_stdlog, \" }\\n\");\n+      /* Mark this frame's id as \"being computed.  */\n+      fi->this_id.p = frame_id_status::COMPUTING;\n+\n+      if (frame_debug)\n+\tfprintf_unfiltered (gdb_stdlog, \"{ compute_frame_id (fi=%d) \",\n+\t\t\t    fi->level);\n+\n+      /* Find the unwinder.  */\n+      if (fi->unwind == NULL)\n+\tframe_unwind_find_by_frame (fi, &fi->prologue_cache);\n+\n+      /* Find THIS frame's ID.  */\n+      /* Default to outermost if no ID is found.  */\n+      fi->this_id.value = outer_frame_id;\n+      fi->unwind->this_id (fi, &fi->prologue_cache, &fi->this_id.value);\n+      gdb_assert (frame_id_p (fi->this_id.value));\n+\n+      /* Mark this frame's id as \"computed\".  */\n+      fi->this_id.p = frame_id_status::COMPUTED;\n+\n+      if (frame_debug)\n+\t{\n+\t  fprintf_unfiltered (gdb_stdlog, \"-> \");\n+\t  fprint_frame_id (gdb_stdlog, fi->this_id.value);\n+\t  fprintf_unfiltered (gdb_stdlog, \" }\\n\");\n+\t}\n+    }\n+  catch (const gdb_exception &ex)\n+    {\n+      /* On error, revert the frame id status to not computed.  If the frame\n+         cache generation changed, the frame object doesn't exist anymore, so\n+\t don't touch it.  */\n+      if (get_frame_cache_generation () == entry_generation)\n+\tfi->this_id.p = frame_id_status::NOT_COMPUTED;\n+\n+      throw;\n     }\n }\n \n@@ -575,7 +618,11 @@ get_frame_id (struct frame_info *fi)\n   if (fi == NULL)\n     return null_frame_id;\n \n-  if (!fi->this_id.p)\n+  /* It's always invalid to try to get a frame's id while it is being\n+     computed.  */\n+  gdb_assert (fi->this_id.p != frame_id_status::COMPUTING);\n+\n+  if (fi->this_id.p == frame_id_status::NOT_COMPUTED)\n     {\n       /* If we haven't computed the frame id yet, then it must be that\n \t this is the current frame.  Compute it now, and stash the\n@@ -1577,7 +1624,7 @@ create_sentinel_frame (struct program_space *pspace, struct regcache *regcache)\n      (the unwound PC is the same as the pc), so make it so.  */\n   frame->next = frame;\n   /* The sentinel frame has a special ID.  */\n-  frame->this_id.p = true;\n+  frame->this_id.p = frame_id_status::COMPUTED;\n   frame->this_id.value = sentinel_frame_id;\n   if (frame_debug)\n     {\n@@ -1797,7 +1844,7 @@ create_new_frame (CORE_ADDR addr, CORE_ADDR pc)\n      based on the PC.  */\n   frame_unwind_find_by_frame (fi, &fi->prologue_cache);\n \n-  fi->this_id.p = true;\n+  fi->this_id.p = frame_id_status::COMPUTED;\n   fi->this_id.value = frame_id_build (addr, pc);\n \n   if (frame_debug)\n@@ -2908,7 +2955,7 @@ frame_cleanup_after_sniffer (struct frame_info *frame)\n   gdb_assert (!frame->prev_p);\n \n   /* The sniffer should not check the frame's ID; that's circular.  */\n-  gdb_assert (!frame->this_id.p);\n+  gdb_assert (frame->this_id.p != frame_id_status::COMPUTED);\n \n   /* Clear cached fields dependent on the unwinder.\n "
    }
  ]
}