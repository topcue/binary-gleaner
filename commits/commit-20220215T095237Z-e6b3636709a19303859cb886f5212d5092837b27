{
  "sha": "e6b3636709a19303859cb886f5212d5092837b27",
  "node_id": "C_kwDOANOeidoAKGU2YjM2MzY3MDlhMTkzMDM4NTljYjg4NmY1MjEyZDUwOTI4MzdiMjc",
  "commit": {
    "author": {
      "name": "Lancelot SIX",
      "email": "lancelot.six@amd.com",
      "date": "2022-02-02T11:34:12Z"
    },
    "committer": {
      "name": "Lancelot SIX",
      "email": "lancelot.six@amd.com",
      "date": "2022-02-15T09:52:37Z"
    },
    "message": "gdb: add a symbol* argument to get_return_value\n\nAdd an argument to the get_return_value function to indicate the symbol\nof the function the debuggee is returning from.  This will be used by\nthe following patch.\n\nSince the function return type can be deduced from the symbol remove the\nvalue_type argument which becomes redundant.\n\nNo user visible change after this patch.\n\nTested on x86_64-linux.\n\nChange-Id: Idf1279f1f7199f5022738a6679e0fa63fbd22edc\nCo-authored-by: Simon Marchi <simon.marchi@polymtl.ca>",
    "tree": {
      "sha": "b6e2d274a841110224a7c0753180185f635b0419",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b6e2d274a841110224a7c0753180185f635b0419"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e6b3636709a19303859cb886f5212d5092837b27",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e6b3636709a19303859cb886f5212d5092837b27",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e6b3636709a19303859cb886f5212d5092837b27",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e6b3636709a19303859cb886f5212d5092837b27/comments",
  "author": {
    "login": "lancesix",
    "id": 98881381,
    "node_id": "U_kgDOBeTPZQ",
    "avatar_url": "https://avatars.githubusercontent.com/u/98881381?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lancesix",
    "html_url": "https://github.com/lancesix",
    "followers_url": "https://api.github.com/users/lancesix/followers",
    "following_url": "https://api.github.com/users/lancesix/following{/other_user}",
    "gists_url": "https://api.github.com/users/lancesix/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lancesix/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lancesix/subscriptions",
    "organizations_url": "https://api.github.com/users/lancesix/orgs",
    "repos_url": "https://api.github.com/users/lancesix/repos",
    "events_url": "https://api.github.com/users/lancesix/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lancesix/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "lancesix",
    "id": 98881381,
    "node_id": "U_kgDOBeTPZQ",
    "avatar_url": "https://avatars.githubusercontent.com/u/98881381?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lancesix",
    "html_url": "https://github.com/lancesix",
    "followers_url": "https://api.github.com/users/lancesix/followers",
    "following_url": "https://api.github.com/users/lancesix/following{/other_user}",
    "gists_url": "https://api.github.com/users/lancesix/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lancesix/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lancesix/subscriptions",
    "organizations_url": "https://api.github.com/users/lancesix/orgs",
    "repos_url": "https://api.github.com/users/lancesix/repos",
    "events_url": "https://api.github.com/users/lancesix/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lancesix/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3c4c0a18c8f0af039e65458da5f53811e9e43754",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3c4c0a18c8f0af039e65458da5f53811e9e43754",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3c4c0a18c8f0af039e65458da5f53811e9e43754"
    }
  ],
  "stats": {
    "total": 78,
    "additions": 44,
    "deletions": 34
  },
  "files": [
    {
      "sha": "1dc4e3638b3efdd37c2a5cbca9b881239c6b8c4c",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e6b3636709a19303859cb886f5212d5092837b27/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e6b3636709a19303859cb886f5212d5092837b27/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=e6b3636709a19303859cb886f5212d5092837b27",
      "patch": "@@ -1444,18 +1444,17 @@ advance_command (const char *arg, int from_tty)\n   until_break_command (arg, from_tty, 1);\n }\n \f\n-/* Return the value of the result of a function at the end of a 'finish'\n-   command/BP.  DTOR_DATA (if not NULL) can represent inferior registers\n-   right after an inferior call has finished.  */\n+/* See inferior.h.  */\n \n struct value *\n-get_return_value (struct value *function, struct type *value_type)\n+get_return_value (struct symbol *func_symbol, struct value *function)\n {\n   regcache *stop_regs = get_current_regcache ();\n   struct gdbarch *gdbarch = stop_regs->arch ();\n   struct value *value;\n \n-  value_type = check_typedef (value_type);\n+  struct type *value_type\n+    = check_typedef (TYPE_TARGET_TYPE (func_symbol->type ()));\n   gdb_assert (value_type->code () != TYPE_CODE_VOID);\n \n   /* FIXME: 2003-09-27: When returning from a nested inferior function\n@@ -1616,7 +1615,7 @@ finish_command_fsm::should_stop (struct thread_info *tp)\n \t  struct value *func;\n \n \t  func = read_var_value (function, NULL, get_current_frame ());\n-\t  rv->value = get_return_value (func, rv->type);\n+\t  rv->value = get_return_value (function, func);\n \t  if (rv->value != NULL)\n \t    rv->value_history_index = record_latest_value (rv->value);\n \t}"
    },
    {
      "sha": "45de3c2d9c8b1bd6421b3f152433d2bcbfb92161",
      "filename": "gdb/inferior.h",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e6b3636709a19303859cb886f5212d5092837b27/gdb/inferior.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e6b3636709a19303859cb886f5212d5092837b27/gdb/inferior.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.h?ref=e6b3636709a19303859cb886f5212d5092837b27",
      "patch": "@@ -219,8 +219,14 @@ extern void detach_command (const char *, int);\n \n extern void notice_new_inferior (struct thread_info *, bool, int);\n \n-extern struct value *get_return_value (struct value *function,\n-\t\t\t\t       struct type *value_type);\n+/* Return the value of the result of a function at the end of a 'finish'\n+   command/BP.  If the result's value cannot be retrieved, return NULL.\n+\n+   FUNC_SYMBOL is the symbol of the function being returned from.  FUNCTION is\n+   a value containing the address of the function.  */\n+\n+extern struct value *get_return_value (struct symbol *func_symbol,\n+\t\t\t\t       struct value *function);\n \n /* Prepare for execution command.  TARGET is the target that will run\n    the command.  BACKGROUND determines whether this is a foreground"
    },
    {
      "sha": "083694fbcce6a7fc16fc4454785b0b614a8e3677",
      "filename": "gdb/python/py-finishbreakpoint.c",
      "status": "modified",
      "additions": 31,
      "deletions": 26,
      "changes": 57,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e6b3636709a19303859cb886f5212d5092837b27/gdb/python/py-finishbreakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e6b3636709a19303859cb886f5212d5092837b27/gdb/python/py-finishbreakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-finishbreakpoint.c?ref=e6b3636709a19303859cb886f5212d5092837b27",
      "patch": "@@ -40,13 +40,17 @@ struct finish_breakpoint_object\n {\n   /* gdb.Breakpoint base class.  */\n   gdbpy_breakpoint_object py_bp;\n-  /* gdb.Type object of the value return by the breakpointed function.\n-     May be NULL if no debug information was available or return type\n-     was VOID.  */\n-  PyObject *return_type;\n-  /* gdb.Value object of the function finished by this breakpoint.  Will be\n-     NULL if return_type is NULL.  */\n+\n+  /* gdb.Symbol object of the function finished by this breakpoint.\n+\n+     nullptr if no debug information was available or return type was VOID.  */\n+  PyObject *func_symbol;\n+\n+  /* gdb.Value object of the function finished by this breakpoint.\n+\n+     nullptr if no debug information was available or return type was VOID.  */\n   PyObject *function_value;\n+\n   /* When stopped at this FinishBreakpoint, gdb.Value object returned by\n      the function; Py_None if the value is not computable; NULL if GDB is\n      not stopped at a FinishBreakpoint.  */\n@@ -80,8 +84,8 @@ bpfinishpy_dealloc (PyObject *self)\n   struct finish_breakpoint_object *self_bpfinish =\n \t(struct finish_breakpoint_object *) self;\n \n+  Py_XDECREF (self_bpfinish->func_symbol);\n   Py_XDECREF (self_bpfinish->function_value);\n-  Py_XDECREF (self_bpfinish->return_type);\n   Py_XDECREF (self_bpfinish->return_value);\n   Py_TYPE (self)->tp_free (self);\n }\n@@ -99,16 +103,17 @@ bpfinishpy_pre_stop_hook (struct gdbpy_breakpoint_object *bp_obj)\n   /* Can compute return_value only once.  */\n   gdb_assert (!self_finishbp->return_value);\n \n-  if (!self_finishbp->return_type)\n+  if (self_finishbp->func_symbol == nullptr)\n     return;\n \n   try\n     {\n+      struct symbol *func_symbol =\n+\tsymbol_object_to_symbol (self_finishbp->func_symbol);\n       struct value *function =\n \tvalue_object_to_value (self_finishbp->function_value);\n-      struct type *value_type =\n-\ttype_object_to_type (self_finishbp->return_type);\n-      struct value *ret = get_return_value (function, value_type);\n+      struct value *ret =\n+\tget_return_value (func_symbol, function);\n \n       if (ret)\n \t{\n@@ -165,7 +170,6 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n   PyObject *internal = NULL;\n   int internal_bp = 0;\n   CORE_ADDR pc;\n-  struct symbol *function;\n \n   if (!gdb_PyArg_ParseTupleAndKeywords (args, kwargs, \"|OO\", keywords,\n \t\t\t\t\t&frame_obj, &internal))\n@@ -239,30 +243,30 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n     }\n \n   /* Find the function we will return from.  */\n-  self_bpfinish->return_type = NULL;\n-  self_bpfinish->function_value = NULL;\n+  self_bpfinish->func_symbol = nullptr;\n+  self_bpfinish->function_value = nullptr;\n \n   try\n     {\n       if (get_frame_pc_if_available (frame, &pc))\n \t{\n-\t  function = find_pc_function (pc);\n-\t  if (function != NULL)\n+\t  struct symbol *function = find_pc_function (pc);\n+\t  if (function != nullptr)\n \t    {\n \t      struct type *ret_type =\n \t\tcheck_typedef (TYPE_TARGET_TYPE (function->type ()));\n \n \t      /* Remember only non-void return types.  */\n \t      if (ret_type->code () != TYPE_CODE_VOID)\n \t\t{\n-\t\t  struct value *func_value;\n-\n \t\t  /* Ignore Python errors at this stage.  */\n-\t\t  self_bpfinish->return_type = type_to_type_object (ret_type);\n+\t\t  value *func_value = read_var_value (function, NULL, frame);\n+\t\t  self_bpfinish->function_value\n+\t\t    = value_to_value_object (func_value);\n \t\t  PyErr_Clear ();\n-\t\t  func_value = read_var_value (function, NULL, frame);\n-\t\t  self_bpfinish->function_value =\n-\t\t      value_to_value_object (func_value);\n+\n+\t\t  self_bpfinish->func_symbol\n+\t\t    = symbol_to_symbol_object (function);\n \t\t  PyErr_Clear ();\n \t\t}\n \t    }\n@@ -274,14 +278,15 @@ bpfinishpy_init (PyObject *self, PyObject *args, PyObject *kwargs)\n \t remain NULL.  */\n     }\n \n-  if (self_bpfinish->return_type == NULL || self_bpfinish->function_value == NULL)\n+  if (self_bpfinish->func_symbol == nullptr\n+      || self_bpfinish->function_value == nullptr)\n     {\n       /* Won't be able to compute return value.  */\n-      Py_XDECREF (self_bpfinish->return_type);\n+      Py_XDECREF (self_bpfinish->func_symbol);\n       Py_XDECREF (self_bpfinish->function_value);\n \n-      self_bpfinish->return_type = NULL;\n-      self_bpfinish->function_value = NULL;\n+      self_bpfinish->func_symbol = nullptr;\n+      self_bpfinish->function_value = nullptr;\n     }\n \n   bppy_pending_object = &self_bpfinish->py_bp;"
    }
  ]
}