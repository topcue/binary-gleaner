{
  "sha": "65365aa856e5a258329dc350b02bbb51f84b4c16",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjUzNjVhYTg1NmU1YTI1ODMyOWRjMzUwYjAyYmJiNTFmODRiNGMxNg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-06-19T11:20:47Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-06-21T12:04:02Z"
    },
    "message": "libctf: drop mmap()-based CTF data allocator\n\nThis allocator has the ostensible benefit that it lets us mprotect() the\nmemory used for CTF storage: but in exchange for this it adds\nconsiderable complexity, since we have to track allocation sizes\nourselves for use at freeing time, note whether the data we are storing\nwas ctf_data_alloc()ed or not so we know if we can safely mprotect()\nit... and while the mprotect()ing has found few bugs, it *has* been the\ncause of more than one due to errors in all this tracking leading to us\nmprotect()ing bits of the heap and stuff like that.\n\nWe are about to start composing CTF buffers from pieces so that we can\ndo usage-based optimizations on the strtab.  This means we need\nrealloc(), which needs nonportable mremap() and *more* tracking of the\n*original* allocation size, and the complexity and bureaucracy of all of\nthis is just too high for its negligible benefits.\n\nDrop the whole thing and just use malloc() like everyone else.  It knows\nbetter than we do when it is safe to use mmap() under the covers,\nanyway.\n\nWhile we're at it, don't leak the entire buffer if ctf_compress_write()\nfails to compress it.\n\nlibctf/\n\t* ctf-subr.c (_PAGESIZE): Remove.\n\t(ctf_data_alloc): Likewise.\n\t(ctf_data_free): Likewise.\n\t(ctf_data_protect): Likewise.\n\t* ctf-impl.h: Remove declarations.\n\t* ctf-create.c (ctf_update): No longer call ctf_data_protect: use\n\tctf_free, not ctf_data_free.\n\t(ctf_compress_write): Use ctf_data_alloc, not ctf_alloc.  Free\n\tthe buffer again on compression error.\n\t* ctf-open.c (ctf_set_base): No longer track the size: call\n\tctf_free, not ctf_data_free.\n\t(upgrade_types): Likewise.  Call ctf_alloc, not ctf_data_alloc.\n\t(ctf_bufopen): Likewise.  No longer call ctf_data_protect.",
    "tree": {
      "sha": "41b87c9af496cfda18bb854e3166f3ca002a080d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/41b87c9af496cfda18bb854e3166f3ca002a080d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/65365aa856e5a258329dc350b02bbb51f84b4c16",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/65365aa856e5a258329dc350b02bbb51f84b4c16",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/65365aa856e5a258329dc350b02bbb51f84b4c16",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/65365aa856e5a258329dc350b02bbb51f84b4c16/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "24865428034f44d9fffe6b2d9a318e1bd507c63a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24865428034f44d9fffe6b2d9a318e1bd507c63a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/24865428034f44d9fffe6b2d9a318e1bd507c63a"
    }
  ],
  "stats": {
    "total": 121,
    "additions": 32,
    "deletions": 89
  },
  "files": [
    {
      "sha": "9fd9e6617a51f0247fd327f2c954f360dd70af03",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=65365aa856e5a258329dc350b02bbb51f84b4c16",
      "patch": "@@ -1,3 +1,19 @@\n+2019-06-19  Nick Alcock <nick.alcock@oracle.com>\n+\n+\t* ctf-subr.c (_PAGESIZE): Remove.\n+\t(ctf_data_alloc): Likewise.\n+\t(ctf_data_free): Likewise.\n+\t(ctf_data_protect): Likewise.\n+\t* ctf-impl.h: Remove declarations.\n+\t* ctf-create.c (ctf_update): No longer call ctf_data_protect: use\n+\tctf_free, not ctf_data_free.\n+\t(ctf_compress_write): Use ctf_data_alloc, not ctf_alloc.  Free\n+\tthe buffer again on compression error.\n+\t* ctf-open.c (ctf_set_base): No longer track the size: call\n+\tctf_free, not ctf_data_free.\n+\t(upgrade_types): Likewise.  Call ctf_alloc, not ctf_data_alloc.\n+\t(ctf_bufopen): Likewise.  No longer call ctf_data_protect.\n+\n 2019-06-19  Nick Alcock <nick.alcock@oracle.com>\n \n \t* ctf-create.c (ctf_dtd_insert): Pass on error returns from"
    },
    {
      "sha": "86695f5abfb8a35e646e3b90991687a7a24136d2",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 7,
      "deletions": 8,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=65365aa856e5a258329dc350b02bbb51f84b4c16",
      "patch": "@@ -310,7 +310,7 @@ ctf_update (ctf_file_t *fp)\n \n   buf_size = sizeof (ctf_header_t) + hdr.cth_stroff + hdr.cth_strlen;\n \n-  if ((buf = ctf_data_alloc (buf_size)) == NULL)\n+  if ((buf = malloc (buf_size)) == NULL)\n     return (ctf_set_errno (fp, EAGAIN));\n \n   memcpy (buf, &hdr, sizeof (ctf_header_t));\n@@ -449,11 +449,9 @@ ctf_update (ctf_file_t *fp)\n   /* Finally, we are ready to ctf_simple_open() the new container.  If this\n      is successful, we then switch nfp and fp and free the old container.  */\n \n-  ctf_data_protect (buf, buf_size);\n-\n   if ((nfp = ctf_simple_open (buf, buf_size, NULL, 0, 0, NULL, 0, &err)) == NULL)\n     {\n-      ctf_data_free (buf, buf_size);\n+      ctf_free (buf);\n       return (ctf_set_errno (fp, err));\n     }\n \n@@ -462,7 +460,7 @@ ctf_update (ctf_file_t *fp)\n \n   nfp->ctf_refcnt = fp->ctf_refcnt;\n   nfp->ctf_flags |= fp->ctf_flags & ~LCTF_DIRTY;\n-  nfp->ctf_data.cts_data = NULL;\t/* Force ctf_data_free() on close.  */\n+  nfp->ctf_data.cts_data = NULL;\t/* Force ctf_free() on close.  */\n   nfp->ctf_dthash = fp->ctf_dthash;\n   nfp->ctf_dtdefs = fp->ctf_dtdefs;\n   nfp->ctf_dtbyname = fp->ctf_dtbyname;\n@@ -1993,16 +1991,17 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n   memcpy (hp, fp->ctf_base, header_len);\n   hp->cth_flags |= CTF_F_COMPRESS;\n \n-  if ((buf = ctf_data_alloc (max_compress_len)) == NULL)\n+  if ((buf = ctf_alloc (max_compress_len)) == NULL)\n     return (ctf_set_errno (fp, ECTF_ZALLOC));\n \n   compress_len = max_compress_len;\n-  if ((rc = compress (buf, (uLongf *) & compress_len,\n+  if ((rc = compress (buf, (uLongf *) &compress_len,\n \t\t      fp->ctf_base + header_len,\n \t\t      fp->ctf_size - header_len)) != Z_OK)\n     {\n       ctf_dprintf (\"zlib deflate err: %s\\n\", zError (rc));\n       err = ctf_set_errno (fp, ECTF_COMPRESS);\n+      ctf_free (buf);\n       goto ret;\n     }\n \n@@ -2030,7 +2029,7 @@ ctf_compress_write (ctf_file_t *fp, int fd)\n     }\n \n ret:\n-  ctf_data_free (buf, max_compress_len);\n+  ctf_free (buf);\n   return err;\n }\n "
    },
    {
      "sha": "44f049316f504f167bf9ea71a4156880c9faad3a",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=65365aa856e5a258329dc350b02bbb51f84b4c16",
      "patch": "@@ -342,11 +342,6 @@ extern void ctf_arc_close_internal (struct ctf_archive *);\n extern void *ctf_set_open_errno (int *, int);\n extern unsigned long ctf_set_errno (ctf_file_t *, int);\n \n-_libctf_malloc_\n-extern void *ctf_data_alloc (size_t);\n-extern void ctf_data_free (void *, size_t);\n-extern void ctf_data_protect (void *, size_t);\n-\n _libctf_malloc_\n extern void *ctf_mmap (size_t length, size_t offset, int fd);\n extern void ctf_munmap (void *, size_t);"
    },
    {
      "sha": "b0d3ef6205577a7f19d345bf6e5b0222a0a7bacf",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 9,
      "deletions": 25,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=65365aa856e5a258329dc350b02bbb51f84b4c16",
      "patch": "@@ -345,24 +345,17 @@ ctf_set_base (ctf_file_t *fp, const ctf_header_t *hp, void *base)\n \n /* Free a ctf_base pointer: the pointer passed, or (if NULL) fp->ctf_base.  */\n static void\n-ctf_free_base (ctf_file_t *fp, unsigned char *ctf_base, size_t ctf_size)\n+ctf_free_base (ctf_file_t *fp, unsigned char *ctf_base)\n {\n   unsigned char *base;\n-  size_t size;\n \n   if (ctf_base)\n-    {\n       base = ctf_base;\n-      size = ctf_size;\n-    }\n   else\n-    {\n       base = (unsigned char *) fp->ctf_base;\n-      size = fp->ctf_size;\n-    }\n \n   if (base != fp->ctf_data.cts_data && base != NULL)\n-    ctf_data_free (base, size);\n+    ctf_free (base);\n }\n \n /* Set the version of the CTF file. */\n@@ -392,7 +385,6 @@ upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n   const ctf_type_v1_t *tbuf;\n   const ctf_type_v1_t *tend;\n   unsigned char *ctf_base, *old_ctf_base = (unsigned char *) fp->ctf_base;\n-  size_t old_ctf_size = fp->ctf_size;\n   ctf_type_t *t2buf;\n \n   ssize_t increase = 0, size, increment, v2increment, vbytes, v2bytes;\n@@ -439,7 +431,7 @@ upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n      version number unchanged, so that LCTF_INFO_* still works on the\n      as-yet-untranslated type info.  */\n \n-  if ((ctf_base = ctf_data_alloc (fp->ctf_size + increase)) == NULL)\n+  if ((ctf_base = ctf_alloc (fp->ctf_size + increase)) == NULL)\n     return ECTF_ZALLOC;\n \n   memcpy (ctf_base, fp->ctf_base, sizeof (ctf_header_t) + cth->cth_typeoff);\n@@ -608,7 +600,7 @@ upgrade_types (ctf_file_t *fp, ctf_header_t *cth)\n   assert ((size_t) t2p - (size_t) fp->ctf_buf == new_cth->cth_stroff);\n \n   ctf_set_version (fp, (ctf_header_t *) ctf_base, CTF_VERSION_1_UPGRADED_3);\n-  ctf_free_base (fp, old_ctf_base, old_ctf_size);\n+  ctf_free_base (fp, old_ctf_base);\n   memcpy (cth, new_cth, sizeof (ctf_header_t));\n \n   return 0;\n@@ -1319,7 +1311,7 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n       const void *src;\n       int rc = Z_OK;\n \n-      if ((base = ctf_data_alloc (size + hdrsz)) == NULL)\n+      if ((base = ctf_alloc (size + hdrsz)) == NULL)\n \treturn (ctf_set_open_errno (errp, ECTF_ZALLOC));\n \n       memcpy (base, ctfsect->cts_data, hdrsz);\n@@ -1333,22 +1325,22 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n       if ((rc = uncompress (buf, &dstlen, src, srclen)) != Z_OK)\n \t{\n \t  ctf_dprintf (\"zlib inflate err: %s\\n\", zError (rc));\n-\t  ctf_data_free (base, size + hdrsz);\n+\t  free (base);\n \t  return (ctf_set_open_errno (errp, ECTF_DECOMPRESS));\n \t}\n \n       if ((size_t) dstlen != size)\n \t{\n \t  ctf_dprintf (\"zlib inflate short -- got %lu of %lu \"\n \t\t       \"bytes\\n\", (unsigned long) dstlen, (unsigned long) size);\n-\t  ctf_data_free (base, size + hdrsz);\n+\t  free (base);\n \t  return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n \t}\n \n     }\n   else if (foreign_endian)\n     {\n-      if ((base = ctf_data_alloc (size + hdrsz)) == NULL)\n+      if ((base = ctf_alloc (size + hdrsz)) == NULL)\n \treturn (ctf_set_open_errno (errp, ECTF_ZALLOC));\n     }\n   else\n@@ -1425,14 +1417,6 @@ ctf_bufopen (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n       goto bad;\n     }\n \n-  /* The ctf region may have been reallocated by init_types(), but now\n-     that is done, it will not move again, so we can protect it, as long\n-     as it didn't come from the ctfsect, which might have been allocated\n-     with malloc().  */\n-\n-  if (fp->ctf_base != (void *) ctfsect->cts_data)\n-    ctf_data_protect ((void *) fp->ctf_base, fp->ctf_size);\n-\n   /* If we have a symbol table section, allocate and initialize\n      the symtab translation table, pointed to by ctf_sxlate.  */\n \n@@ -1551,7 +1535,7 @@ ctf_file_close (ctf_file_t *fp)\n   else if (fp->ctf_data_mmapped)\n     ctf_munmap (fp->ctf_data_mmapped, fp->ctf_data_mmapped_len);\n \n-  ctf_free_base (fp, NULL, 0);\n+  ctf_free_base (fp, NULL);\n \n   if (fp->ctf_sxlate != NULL)\n     ctf_free (fp->ctf_sxlate);"
    },
    {
      "sha": "454716abbd591e72c7e51dcfbd65ca62c762c1a3",
      "filename": "libctf/ctf-subr.c",
      "status": "modified",
      "additions": 0,
      "deletions": 51,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ctf-subr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/65365aa856e5a258329dc350b02bbb51f84b4c16/libctf/ctf-subr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-subr.c?ref=65365aa856e5a258329dc350b02bbb51f84b4c16",
      "patch": "@@ -26,49 +26,9 @@\n #include <string.h>\n #include <unistd.h>\n \n-static size_t _PAGESIZE _libctf_unused_;\n int _libctf_version = CTF_VERSION;\t      /* Library client version.  */\n int _libctf_debug = 0;\t\t\t      /* Debugging messages enabled.  */\n \n-_libctf_malloc_ void *\n-ctf_data_alloc (size_t size)\n-{\n-  void *ret;\n-\n-#ifdef HAVE_MMAP\n-  if (_PAGESIZE == 0)\n-    _PAGESIZE = sysconf(_SC_PAGESIZE);\n-\n-  if (size > _PAGESIZE)\n-    {\n-      ret = mmap (NULL, size, PROT_READ | PROT_WRITE,\n-\t\t  MAP_PRIVATE | MAP_ANON, -1, 0);\n-      if (ret == MAP_FAILED)\n-\tret = NULL;\n-    }\n-  else\n-    ret = calloc (1, size);\n-#else\n-  ret = calloc (1, size);\n-#endif\n-  return ret;\n-}\n-\n-void\n-ctf_data_free (void *buf, size_t size _libctf_unused_)\n-{\n-#ifdef HAVE_MMAP\n-  /* Must be the same as the check in ctf_data_alloc().  */\n-\n-  if (size > _PAGESIZE)\n-    (void) munmap (buf, size);\n-  else\n-    free (buf);\n-#else\n-  free (buf);\n-#endif\n-}\n-\n /* Private, read-only mmap from a file, with fallback to copying.\n \n    No handling of page-offset issues at all: the caller must allow for that. */\n@@ -105,17 +65,6 @@ ctf_munmap (void *buf, size_t length _libctf_unused_)\n #endif\n }\n \n-void\n-ctf_data_protect (void *buf _libctf_unused_, size_t size _libctf_unused_)\n-{\n-#ifdef HAVE_MMAP\n-  /* Must be the same as the check in ctf_data_alloc().  */\n-\n-  if (size > _PAGESIZE)\n-    (void) mprotect (buf, size, PROT_READ);\n-#endif\n-}\n-\n _libctf_malloc_ void *\n ctf_alloc (size_t size)\n {"
    }
  ]
}