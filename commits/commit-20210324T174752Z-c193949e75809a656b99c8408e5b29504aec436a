{
  "sha": "c193949e75809a656b99c8408e5b29504aec436a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzE5Mzk0OWU3NTgwOWE2NTZiOTljODQwOGU1YjI5NTA0YWVjNDM2YQ==",
  "commit": {
    "author": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2020-06-19T20:36:14Z"
    },
    "committer": {
      "name": "Luis Machado",
      "email": "luis.machado@linaro.org",
      "date": "2021-03-24T17:47:52Z"
    },
    "message": "New gdbarch memory tagging hooks\n\nWe need some new gdbarch hooks to help us manipulate memory tags without having\nto have GDB call the target methods directly.\n\nThis patch adds the following hooks:\n\ngdbarch_memtag_to_string\n--\nReturns a printable string corresponding to the tag.\n\ngdbarch_tagged_address_p\n--\nChecks if a particular address is protected with memory tagging.\n\ngdbarch_memtag_matches_p\n--\nChecks if the logical tag of a pointer and the allocation tag from the address\nthe pointer points to matches.\n\ngdbarch_set_memtags:\n--\nSets either the allocation tag or the logical tag for a particular value.\n\ngdbarch_get_memtag:\n--\nGets either the allocation tag or the logical tag for a particular value.\n\ngdbarch_memtag_granule_size\n--\nSets the memory tag granule size, which represents the number of bytes a\nparticular allocation tag covers. For example, this is 16 bytes for\nAArch64's MTE.\n\nI've used struct value as opposed to straight CORE_ADDR so other architectures\ncan use the infrastructure without having to rely on a particular type for\naddresses/pointers.  Some architecture may use pointers of 16 bytes that don't\nfit in a CORE_ADDR, for example.\n\ngdb/ChangeLog:\n\n2021-03-24  Luis Machado  <luis.machado@linaro.org>\n\n\t* arch-utils.c (default_memtag_to_string, default_tagged_address_p)\n\t(default_memtag_matches_p, default_set_memtags)\n\t(default_get_memtag): New functions.\n\t* arch-utils.h (default_memtag_to_string, default_tagged_address_p)\n\t(default_memtag_matches_p, default_set_memtags)\n\t(default_get_memtag): New prototypes.\n\t* gdbarch.c: Regenerate.\n\t* gdbarch.h: Regenerate.\n\t* gdbarch.sh (memtag_to_string, tagged_address_p, memtag_matches_p)\n\t(set_memtags, get_memtag, memtag_granule_size): New gdbarch hooks.\n\t(enum memtag_type): New enum.",
    "tree": {
      "sha": "e8adec412217398f1684fe69a4a26d63f3be7046",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e8adec412217398f1684fe69a4a26d63f3be7046"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c193949e75809a656b99c8408e5b29504aec436a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c193949e75809a656b99c8408e5b29504aec436a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c193949e75809a656b99c8408e5b29504aec436a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c193949e75809a656b99c8408e5b29504aec436a/comments",
  "author": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "luislinaro",
    "id": 53092780,
    "node_id": "MDQ6VXNlcjUzMDkyNzgw",
    "avatar_url": "https://avatars.githubusercontent.com/u/53092780?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/luislinaro",
    "html_url": "https://github.com/luislinaro",
    "followers_url": "https://api.github.com/users/luislinaro/followers",
    "following_url": "https://api.github.com/users/luislinaro/following{/other_user}",
    "gists_url": "https://api.github.com/users/luislinaro/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/luislinaro/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/luislinaro/subscriptions",
    "organizations_url": "https://api.github.com/users/luislinaro/orgs",
    "repos_url": "https://api.github.com/users/luislinaro/repos",
    "events_url": "https://api.github.com/users/luislinaro/events{/privacy}",
    "received_events_url": "https://api.github.com/users/luislinaro/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "dbe692af2d1814100748b18a5dd70214e8611107",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dbe692af2d1814100748b18a5dd70214e8611107",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/dbe692af2d1814100748b18a5dd70214e8611107"
    }
  ],
  "stats": {
    "total": 315,
    "additions": 314,
    "deletions": 1
  },
  "files": [
    {
      "sha": "37dc83da67f8d9f90e9e4f94030f3cfa3aa1caa3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c193949e75809a656b99c8408e5b29504aec436a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c193949e75809a656b99c8408e5b29504aec436a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c193949e75809a656b99c8408e5b29504aec436a",
      "patch": "@@ -1,3 +1,17 @@\n+2021-03-24  Luis Machado  <luis.machado@linaro.org>\n+\n+\t* arch-utils.c (default_memtag_to_string, default_tagged_address_p)\n+\t(default_memtag_matches_p, default_set_memtags)\n+\t(default_get_memtag): New functions.\n+\t* arch-utils.h (default_memtag_to_string, default_tagged_address_p)\n+\t(default_memtag_matches_p, default_set_memtags)\n+\t(default_get_memtag): New prototypes.\n+\t* gdbarch.c: Regenerate.\n+\t* gdbarch.h: Regenerate.\n+\t* gdbarch.sh (memtag_to_string, tagged_address_p, memtag_matches_p)\n+\t(set_memtags, get_memtag, memtag_granule_size): New gdbarch hooks.\n+\t(enum memtag_type): New enum.\n+\n 2021-03-24  Luis Machado  <luis.machado@linaro.org>\n \n \t* remote.c (remote_target) <supports_memory_tagging>: New method"
    },
    {
      "sha": "0017e706ef1ae14f80a9b4fe32fbb850751899d5",
      "filename": "gdb/arch-utils.c",
      "status": "modified",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c193949e75809a656b99c8408e5b29504aec436a/gdb/arch-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c193949e75809a656b99c8408e5b29504aec436a/gdb/arch-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.c?ref=c193949e75809a656b99c8408e5b29504aec436a",
      "patch": "@@ -77,6 +77,55 @@ legacy_register_sim_regno (struct gdbarch *gdbarch, int regnum)\n     return LEGACY_SIM_REGNO_IGNORE;\n }\n \n+\n+/* See arch-utils.h */\n+\n+std::string\n+default_memtag_to_string (struct gdbarch *gdbarch, struct value *tag)\n+{\n+  error (_(\"This architecture has no method to convert a memory tag to\"\n+\t   \" a string.\"));\n+}\n+\n+/* See arch-utils.h */\n+\n+bool\n+default_tagged_address_p (struct gdbarch *gdbarch, struct value *address)\n+{\n+  /* By default, assume the address is untagged.  */\n+  return false;\n+}\n+\n+/* See arch-utils.h */\n+\n+bool\n+default_memtag_matches_p (struct gdbarch *gdbarch, struct value *address)\n+{\n+  /* By default, assume the tags match.  */\n+  return true;\n+}\n+\n+/* See arch-utils.h */\n+\n+bool\n+default_set_memtags (struct gdbarch *gdbarch, struct value *address,\n+\t\t     size_t length, const gdb::byte_vector &tags,\n+\t\t     memtag_type tag_type)\n+{\n+  /* By default, return true (successful);  */\n+  return true;\n+}\n+\n+/* See arch-utils.h */\n+\n+struct value *\n+default_get_memtag (struct gdbarch *gdbarch, struct value *address,\n+\t\t    memtag_type tag_type)\n+{\n+  /* By default, return no tag.  */\n+  return nullptr;\n+}\n+\n CORE_ADDR\n generic_skip_trampoline_code (struct frame_info *frame, CORE_ADDR pc)\n {"
    },
    {
      "sha": "a5b40ad8ff1bdbc0a4760482c3d527fd8314bbc5",
      "filename": "gdb/arch-utils.h",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c193949e75809a656b99c8408e5b29504aec436a/gdb/arch-utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c193949e75809a656b99c8408e5b29504aec436a/gdb/arch-utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.h?ref=c193949e75809a656b99c8408e5b29504aec436a",
      "patch": "@@ -132,6 +132,28 @@ extern const struct floatformat **\n   default_floatformat_for_type (struct gdbarch *gdbarch,\n \t\t\t\tconst char *name, int len);\n \n+/* Default implementation of gdbarch_memtag_to_string.  */\n+extern std::string default_memtag_to_string (struct gdbarch *gdbarch,\n+\t\t\t\t\t     struct value *tag);\n+\n+/* Default implementation of gdbarch_tagged_address_p.  */\n+bool default_tagged_address_p (struct gdbarch *gdbarch, struct value *address);\n+\n+/* Default implementation of gdbarch_memtag_matches_p.  */\n+extern bool default_memtag_matches_p (struct gdbarch *gdbarch,\n+\t\t\t\t       struct value *address);\n+\n+/* Default implementation of gdbarch_set_memtags.  */\n+bool default_set_memtags (struct gdbarch *gdbarch,\n+\t\t\t  struct value *address, size_t length,\n+\t\t\t  const gdb::byte_vector &tags,\n+\t\t\t  memtag_type tag_type);\n+\n+/* Default implementation of gdbarch_get_memtag.  */\n+struct value *default_get_memtag (struct gdbarch *gdbarch,\n+\t\t\t\t  struct value *address,\n+\t\t\t\t  memtag_type tag_type);\n+\n extern CORE_ADDR generic_skip_trampoline_code (struct frame_info *frame,\n \t\t\t\t\t       CORE_ADDR pc);\n "
    },
    {
      "sha": "23509ba0a9869a275459a5bc3b63f7bf4deade09",
      "filename": "gdb/gdbarch.c",
      "status": "modified",
      "additions": 138,
      "deletions": 1,
      "changes": 139,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c193949e75809a656b99c8408e5b29504aec436a/gdb/gdbarch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c193949e75809a656b99c8408e5b29504aec436a/gdb/gdbarch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.c?ref=c193949e75809a656b99c8408e5b29504aec436a",
      "patch": "@@ -253,6 +253,12 @@ struct gdbarch\n   gdbarch_convert_from_func_ptr_addr_ftype *convert_from_func_ptr_addr;\n   gdbarch_addr_bits_remove_ftype *addr_bits_remove;\n   int significant_addr_bit;\n+  gdbarch_memtag_to_string_ftype *memtag_to_string;\n+  gdbarch_tagged_address_p_ftype *tagged_address_p;\n+  gdbarch_memtag_matches_p_ftype *memtag_matches_p;\n+  gdbarch_set_memtags_ftype *set_memtags;\n+  gdbarch_get_memtag_ftype *get_memtag;\n+  CORE_ADDR memtag_granule_size;\n   gdbarch_software_single_step_ftype *software_single_step;\n   gdbarch_single_step_through_delay_ftype *single_step_through_delay;\n   gdbarch_print_insn_ftype *print_insn;\n@@ -433,6 +439,11 @@ gdbarch_alloc (const struct gdbarch_info *info,\n   gdbarch->stabs_argument_has_addr = default_stabs_argument_has_addr;\n   gdbarch->convert_from_func_ptr_addr = convert_from_func_ptr_addr_identity;\n   gdbarch->addr_bits_remove = core_addr_identity;\n+  gdbarch->memtag_to_string = default_memtag_to_string;\n+  gdbarch->tagged_address_p = default_tagged_address_p;\n+  gdbarch->memtag_matches_p = default_memtag_matches_p;\n+  gdbarch->set_memtags = default_set_memtags;\n+  gdbarch->get_memtag = default_get_memtag;\n   gdbarch->print_insn = default_print_insn;\n   gdbarch->skip_trampoline_code = generic_skip_trampoline_code;\n   gdbarch->skip_solib_resolver = generic_skip_solib_resolver;\n@@ -626,6 +637,12 @@ verify_gdbarch (struct gdbarch *gdbarch)\n   /* Skip verify of convert_from_func_ptr_addr, invalid_p == 0 */\n   /* Skip verify of addr_bits_remove, invalid_p == 0 */\n   /* Skip verify of significant_addr_bit, invalid_p == 0 */\n+  /* Skip verify of memtag_to_string, invalid_p == 0 */\n+  /* Skip verify of tagged_address_p, invalid_p == 0 */\n+  /* Skip verify of memtag_matches_p, invalid_p == 0 */\n+  /* Skip verify of set_memtags, invalid_p == 0 */\n+  /* Skip verify of get_memtag, invalid_p == 0 */\n+  /* Skip verify of memtag_granule_size, invalid_p == 0 */\n   /* Skip verify of software_single_step, has predicate.  */\n   /* Skip verify of single_step_through_delay, has predicate.  */\n   /* Skip verify of print_insn, invalid_p == 0 */\n@@ -1088,6 +1105,9 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: get_longjmp_target = <%s>\\n\",\n                       host_address_to_string (gdbarch->get_longjmp_target));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: get_memtag = <%s>\\n\",\n+                      host_address_to_string (gdbarch->get_memtag));\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: get_pc_address_flags = <%s>\\n\",\n                       host_address_to_string (gdbarch->get_pc_address_flags));\n@@ -1217,6 +1237,15 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: memory_remove_breakpoint = <%s>\\n\",\n                       host_address_to_string (gdbarch->memory_remove_breakpoint));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: memtag_granule_size = %s\\n\",\n+                      core_addr_to_string_nz (gdbarch->memtag_granule_size));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: memtag_matches_p = <%s>\\n\",\n+                      host_address_to_string (gdbarch->memtag_matches_p));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: memtag_to_string = <%s>\\n\",\n+                      host_address_to_string (gdbarch->memtag_to_string));\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: num_pseudo_regs = %s\\n\",\n                       plongest (gdbarch->num_pseudo_regs));\n@@ -1370,6 +1399,9 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: sdb_reg_to_regnum = <%s>\\n\",\n                       host_address_to_string (gdbarch->sdb_reg_to_regnum));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: set_memtags = <%s>\\n\",\n+                      host_address_to_string (gdbarch->set_memtags));\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: short_bit = %s\\n\",\n                       plongest (gdbarch->short_bit));\n@@ -1478,6 +1510,9 @@ gdbarch_dump (struct gdbarch *gdbarch, struct ui_file *file)\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: syscalls_info = %s\\n\",\n                       host_address_to_string (gdbarch->syscalls_info));\n+  fprintf_unfiltered (file,\n+                      \"gdbarch_dump: tagged_address_p = <%s>\\n\",\n+                      host_address_to_string (gdbarch->tagged_address_p));\n   fprintf_unfiltered (file,\n                       \"gdbarch_dump: target_desc = %s\\n\",\n                       host_address_to_string (gdbarch->target_desc));\n@@ -3283,6 +3318,108 @@ set_gdbarch_significant_addr_bit (struct gdbarch *gdbarch,\n   gdbarch->significant_addr_bit = significant_addr_bit;\n }\n \n+std::string\n+gdbarch_memtag_to_string (struct gdbarch *gdbarch, struct value *tag)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->memtag_to_string != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_memtag_to_string called\\n\");\n+  return gdbarch->memtag_to_string (gdbarch, tag);\n+}\n+\n+void\n+set_gdbarch_memtag_to_string (struct gdbarch *gdbarch,\n+                              gdbarch_memtag_to_string_ftype memtag_to_string)\n+{\n+  gdbarch->memtag_to_string = memtag_to_string;\n+}\n+\n+bool\n+gdbarch_tagged_address_p (struct gdbarch *gdbarch, struct value *address)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->tagged_address_p != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_tagged_address_p called\\n\");\n+  return gdbarch->tagged_address_p (gdbarch, address);\n+}\n+\n+void\n+set_gdbarch_tagged_address_p (struct gdbarch *gdbarch,\n+                              gdbarch_tagged_address_p_ftype tagged_address_p)\n+{\n+  gdbarch->tagged_address_p = tagged_address_p;\n+}\n+\n+bool\n+gdbarch_memtag_matches_p (struct gdbarch *gdbarch, struct value *address)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->memtag_matches_p != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_memtag_matches_p called\\n\");\n+  return gdbarch->memtag_matches_p (gdbarch, address);\n+}\n+\n+void\n+set_gdbarch_memtag_matches_p (struct gdbarch *gdbarch,\n+                              gdbarch_memtag_matches_p_ftype memtag_matches_p)\n+{\n+  gdbarch->memtag_matches_p = memtag_matches_p;\n+}\n+\n+bool\n+gdbarch_set_memtags (struct gdbarch *gdbarch, struct value *address, size_t length, const gdb::byte_vector &tags, memtag_type tag_type)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->set_memtags != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_set_memtags called\\n\");\n+  return gdbarch->set_memtags (gdbarch, address, length, tags, tag_type);\n+}\n+\n+void\n+set_gdbarch_set_memtags (struct gdbarch *gdbarch,\n+                         gdbarch_set_memtags_ftype set_memtags)\n+{\n+  gdbarch->set_memtags = set_memtags;\n+}\n+\n+struct value *\n+gdbarch_get_memtag (struct gdbarch *gdbarch, struct value *address, memtag_type tag_type)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  gdb_assert (gdbarch->get_memtag != NULL);\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_get_memtag called\\n\");\n+  return gdbarch->get_memtag (gdbarch, address, tag_type);\n+}\n+\n+void\n+set_gdbarch_get_memtag (struct gdbarch *gdbarch,\n+                        gdbarch_get_memtag_ftype get_memtag)\n+{\n+  gdbarch->get_memtag = get_memtag;\n+}\n+\n+CORE_ADDR\n+gdbarch_memtag_granule_size (struct gdbarch *gdbarch)\n+{\n+  gdb_assert (gdbarch != NULL);\n+  /* Skip verify of memtag_granule_size, invalid_p == 0 */\n+  if (gdbarch_debug >= 2)\n+    fprintf_unfiltered (gdb_stdlog, \"gdbarch_memtag_granule_size called\\n\");\n+  return gdbarch->memtag_granule_size;\n+}\n+\n+void\n+set_gdbarch_memtag_granule_size (struct gdbarch *gdbarch,\n+                                 CORE_ADDR memtag_granule_size)\n+{\n+  gdbarch->memtag_granule_size = memtag_granule_size;\n+}\n+\n bool\n gdbarch_software_single_step_p (struct gdbarch *gdbarch)\n {\n@@ -5314,7 +5451,7 @@ struct gdbarch_data_registry\n   struct gdbarch_data_registration *registrations;\n };\n \n-static struct gdbarch_data_registry gdbarch_data_registry =\n+struct gdbarch_data_registry gdbarch_data_registry =\n {\n   0, NULL,\n };"
    },
    {
      "sha": "7157e5596fd36d0ad19400d3462592481d28eaa7",
      "filename": "gdb/gdbarch.h",
      "status": "modified",
      "additions": 54,
      "deletions": 0,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c193949e75809a656b99c8408e5b29504aec436a/gdb/gdbarch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c193949e75809a656b99c8408e5b29504aec436a/gdb/gdbarch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.h?ref=c193949e75809a656b99c8408e5b29504aec436a",
      "patch": "@@ -117,6 +117,18 @@ enum function_call_return_method\n   return_method_struct,\n };\n \n+enum class memtag_type\n+{\n+  /* Logical tag, the tag that is stored in unused bits of a pointer to a\n+     virtual address.  */\n+  logical = 0,\n+\n+  /* Allocation tag, the tag that is associated with every granule of memory in\n+     the physical address space.  Allocation tags are used to validate memory\n+     accesses via pointers containing logical tags.  */\n+  allocation,\n+};\n+\n \n \n /* The following are pre-initialized by GDBARCH.  */\n@@ -712,6 +724,48 @@ extern void set_gdbarch_addr_bits_remove (struct gdbarch *gdbarch, gdbarch_addr_\n extern int gdbarch_significant_addr_bit (struct gdbarch *gdbarch);\n extern void set_gdbarch_significant_addr_bit (struct gdbarch *gdbarch, int significant_addr_bit);\n \n+/* Return a string representation of the memory tag TAG. */\n+\n+typedef std::string (gdbarch_memtag_to_string_ftype) (struct gdbarch *gdbarch, struct value *tag);\n+extern std::string gdbarch_memtag_to_string (struct gdbarch *gdbarch, struct value *tag);\n+extern void set_gdbarch_memtag_to_string (struct gdbarch *gdbarch, gdbarch_memtag_to_string_ftype *memtag_to_string);\n+\n+/* Return true if ADDRESS contains a tag and false otherwise. */\n+\n+typedef bool (gdbarch_tagged_address_p_ftype) (struct gdbarch *gdbarch, struct value *address);\n+extern bool gdbarch_tagged_address_p (struct gdbarch *gdbarch, struct value *address);\n+extern void set_gdbarch_tagged_address_p (struct gdbarch *gdbarch, gdbarch_tagged_address_p_ftype *tagged_address_p);\n+\n+/* Return true if the tag from ADDRESS matches the memory tag for that\n+   particular address.  Return false otherwise. */\n+\n+typedef bool (gdbarch_memtag_matches_p_ftype) (struct gdbarch *gdbarch, struct value *address);\n+extern bool gdbarch_memtag_matches_p (struct gdbarch *gdbarch, struct value *address);\n+extern void set_gdbarch_memtag_matches_p (struct gdbarch *gdbarch, gdbarch_memtag_matches_p_ftype *memtag_matches_p);\n+\n+/* Set the tags of type TAG_TYPE, for the memory address range\n+   [ADDRESS, ADDRESS + LENGTH) to TAGS.\n+   Return true if successful and false otherwise. */\n+\n+typedef bool (gdbarch_set_memtags_ftype) (struct gdbarch *gdbarch, struct value *address, size_t length, const gdb::byte_vector &tags, memtag_type tag_type);\n+extern bool gdbarch_set_memtags (struct gdbarch *gdbarch, struct value *address, size_t length, const gdb::byte_vector &tags, memtag_type tag_type);\n+extern void set_gdbarch_set_memtags (struct gdbarch *gdbarch, gdbarch_set_memtags_ftype *set_memtags);\n+\n+/* Return the tag of type TAG_TYPE associated with the memory address ADDRESS,\n+   assuming ADDRESS is tagged. */\n+\n+typedef struct value * (gdbarch_get_memtag_ftype) (struct gdbarch *gdbarch, struct value *address, memtag_type tag_type);\n+extern struct value * gdbarch_get_memtag (struct gdbarch *gdbarch, struct value *address, memtag_type tag_type);\n+extern void set_gdbarch_get_memtag (struct gdbarch *gdbarch, gdbarch_get_memtag_ftype *get_memtag);\n+\n+/* memtag_granule_size is the size of the allocation tag granule, for\n+   architectures that support memory tagging.\n+   This is 0 for architectures that do not support memory tagging.\n+   For a non-zero value, this represents the number of bytes of memory per tag. */\n+\n+extern CORE_ADDR gdbarch_memtag_granule_size (struct gdbarch *gdbarch);\n+extern void set_gdbarch_memtag_granule_size (struct gdbarch *gdbarch, CORE_ADDR memtag_granule_size);\n+\n /* FIXME/cagney/2001-01-18: This should be split in two.  A target method that\n    indicates if the target needs software single step.  An ISA method to\n    implement it."
    },
    {
      "sha": "6c361307428de5bbb7a2c7e21e5e1c56b74ed631",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c193949e75809a656b99c8408e5b29504aec436a/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c193949e75809a656b99c8408e5b29504aec436a/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=c193949e75809a656b99c8408e5b29504aec436a",
      "patch": "@@ -605,6 +605,31 @@ m;CORE_ADDR;addr_bits_remove;CORE_ADDR addr;addr;;core_addr_identity;;0\n # additional data associated with the address.\n v;int;significant_addr_bit;;;;;;0\n \n+# Return a string representation of the memory tag TAG.\n+m;std::string;memtag_to_string;struct value *tag;tag;;default_memtag_to_string;;0\n+\n+# Return true if ADDRESS contains a tag and false otherwise.\n+m;bool;tagged_address_p;struct value *address;address;;default_tagged_address_p;;0\n+\n+# Return true if the tag from ADDRESS matches the memory tag for that\n+# particular address.  Return false otherwise.\n+m;bool;memtag_matches_p;struct value *address;address;;default_memtag_matches_p;;0\n+\n+# Set the tags of type TAG_TYPE, for the memory address range\n+# [ADDRESS, ADDRESS + LENGTH) to TAGS.\n+# Return true if successful and false otherwise.\n+m;bool;set_memtags;struct value *address, size_t length, const gdb::byte_vector \\&tags, memtag_type tag_type;address, length, tags, tag_type;;default_set_memtags;;0\n+\n+# Return the tag of type TAG_TYPE associated with the memory address ADDRESS,\n+# assuming ADDRESS is tagged.\n+m;struct value *;get_memtag;struct value *address, memtag_type tag_type;address, tag_type;;default_get_memtag;;0\n+\n+# memtag_granule_size is the size of the allocation tag granule, for\n+# architectures that support memory tagging.\n+# This is 0 for architectures that do not support memory tagging.\n+# For a non-zero value, this represents the number of bytes of memory per tag.\n+v;CORE_ADDR;memtag_granule_size;;;;;;0\n+\n # FIXME/cagney/2001-01-18: This should be split in two.  A target method that\n # indicates if the target needs software single step.  An ISA method to\n # implement it.\n@@ -1362,6 +1387,18 @@ enum function_call_return_method\n   return_method_struct,\n };\n \n+enum class memtag_type\n+{\n+  /* Logical tag, the tag that is stored in unused bits of a pointer to a\n+     virtual address.  */\n+  logical = 0,\n+\n+  /* Allocation tag, the tag that is associated with every granule of memory in\n+     the physical address space.  Allocation tags are used to validate memory\n+     accesses via pointers containing logical tags.  */\n+  allocation,\n+};\n+\n EOF\n \n # function typedef's"
    }
  ]
}