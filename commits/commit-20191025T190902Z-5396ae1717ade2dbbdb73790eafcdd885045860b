{
  "sha": "5396ae1717ade2dbbdb73790eafcdd885045860b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTM5NmFlMTcxN2FkZTJkYmJkYjczNzkwZWFmY2RkODg1MDQ1ODYwYg==",
  "commit": {
    "author": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-10-13T11:56:58Z"
    },
    "committer": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-10-25T19:09:02Z"
    },
    "message": "Don't make an extra copy + allocation of the demangled name\n\nWe can just keep around the malloc()-ed name we got from bfd and free\nit later.\n\ngdb/ChangeLog:\n\n2019-10-25  Christian Biesinger  <cbiesinger@google.com>\n\n\t* symtab.c (struct demangled_name_entry): Change demangled name\n\tto a unique_xmalloc_ptr<char>, now that we don't allocate it as\n\tpart of the struct anymore.\n\t(symbol_set_names): No longer obstack allocate + copy the demangled\n\tname, just store the allocated name from bfd.\n\nChange-Id: Ie6ad50e1e1e73509f55d756f0a437897bb93e3b0",
    "tree": {
      "sha": "7e65db82ae94b112929a615f4a3d772a99e7e47d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7e65db82ae94b112929a615f4a3d772a99e7e47d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5396ae1717ade2dbbdb73790eafcdd885045860b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5396ae1717ade2dbbdb73790eafcdd885045860b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5396ae1717ade2dbbdb73790eafcdd885045860b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5396ae1717ade2dbbdb73790eafcdd885045860b/comments",
  "author": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5c49f2cd78c69d50bc7c7119596a226f05939d06",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5c49f2cd78c69d50bc7c7119596a226f05939d06",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5c49f2cd78c69d50bc7c7119596a226f05939d06"
    }
  ],
  "stats": {
    "total": 46,
    "additions": 21,
    "deletions": 25
  },
  "files": [
    {
      "sha": "55c46473ab3c3cf53d7504bd99db022a93bc5bcc",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5396ae1717ade2dbbdb73790eafcdd885045860b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5396ae1717ade2dbbdb73790eafcdd885045860b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5396ae1717ade2dbbdb73790eafcdd885045860b",
      "patch": "@@ -1,3 +1,11 @@\n+2019-10-25  Christian Biesinger  <cbiesinger@google.com>\n+\n+\t* symtab.c (struct demangled_name_entry): Change demangled name\n+\tto a unique_xmalloc_ptr<char>, now that we don't allocate it as\n+\tpart of the struct anymore.\n+\t(symbol_set_names): No longer obstack allocate + copy the demangled\n+\tname, just store the allocated name from bfd.\n+\n 2019-10-25  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf2-frame.c (dwarf2_cie_table): Now a typedef."
    },
    {
      "sha": "adf9e08067403d0188a01455921694d698b69dd7",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 13,
      "deletions": 25,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5396ae1717ade2dbbdb73790eafcdd885045860b/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5396ae1717ade2dbbdb73790eafcdd885045860b/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=5396ae1717ade2dbbdb73790eafcdd885045860b",
      "patch": "@@ -723,7 +723,7 @@ struct demangled_name_entry\n \n   gdb::string_view mangled;\n   enum language language;\n-  char demangled[1];\n+  gdb::unique_xmalloc_ptr<char> demangled;\n };\n \n /* Hash function for the demangled name hash.  */\n@@ -839,7 +839,7 @@ symbol_set_names (struct general_symbol_info *gsymbol,\n     {\n       /* In Ada, we do the symbol lookups using the mangled name, so\n          we can save some space by not storing the demangled name.  */\n-      if (!copy_name)\n+      if (!copy_name && linkage_name_copy == linkage_name)\n \tgsymbol->name = linkage_name;\n       else\n \t{\n@@ -880,20 +880,17 @@ symbol_set_names (struct general_symbol_info *gsymbol,\n   if (*slot == NULL\n       /* A C version of the symbol may have already snuck into the table.\n \t This happens to, e.g., main.init (__go_init_main).  Cope.  */\n-      || (gsymbol->language == language_go\n-\t  && (*slot)->demangled[0] == '\\0'))\n+      || (gsymbol->language == language_go && (*slot)->demangled == nullptr))\n     {\n-      char *demangled_name_ptr\n-\t= symbol_find_demangled_name (gsymbol, linkage_name_copy);\n-      gdb::unique_xmalloc_ptr<char> demangled_name (demangled_name_ptr);\n-      int demangled_len = demangled_name ? strlen (demangled_name.get ()) : 0;\n+      gdb::unique_xmalloc_ptr<char> demangled_name_ptr\n+\t(symbol_find_demangled_name (gsymbol, linkage_name_copy));\n \n       /* Suppose we have demangled_name==NULL, copy_name==0, and\n \t linkage_name_copy==linkage_name.  In this case, we already have the\n \t mangled name saved, and we don't have a demangled name.  So,\n \t you might think we could save a little space by not recording\n \t this in the hash table at all.\n-\t \n+\n \t It turns out that it is actually important to still save such\n \t an entry in the hash table, because storing this name gives\n \t us better bcache hit rates for partial symbols.  */\n@@ -902,42 +899,33 @@ symbol_set_names (struct general_symbol_info *gsymbol,\n \t  *slot\n \t    = ((struct demangled_name_entry *)\n \t       obstack_alloc (&per_bfd->storage_obstack,\n-\t\t\t      offsetof (struct demangled_name_entry, demangled)\n-\t\t\t      + demangled_len + 1));\n+\t\t\t      sizeof (demangled_name_entry)));\n \t  new (*slot) demangled_name_entry\n \t    (gdb::string_view (linkage_name, len));\n \t}\n       else\n \t{\n-\t  char *mangled_ptr;\n-\n \t  /* If we must copy the mangled name, put it directly after\n-\t     the demangled name so we can have a single\n-\t     allocation.  */\n+\t     the struct so we can have a single allocation.  */\n \t  *slot\n \t    = ((struct demangled_name_entry *)\n \t       obstack_alloc (&per_bfd->storage_obstack,\n-\t\t\t      offsetof (struct demangled_name_entry, demangled)\n-\t\t\t      + len + demangled_len + 2));\n-\t  mangled_ptr = &((*slot)->demangled[demangled_len + 1]);\n+\t\t\t      sizeof (demangled_name_entry) + len + 1));\n+\t  char *mangled_ptr = reinterpret_cast<char *> (*slot + 1);\n \t  strcpy (mangled_ptr, linkage_name_copy);\n \t  new (*slot) demangled_name_entry\n \t    (gdb::string_view (mangled_ptr, len));\n \t}\n+      (*slot)->demangled = std::move (demangled_name_ptr);\n       (*slot)->language = gsymbol->language;\n-\n-      if (demangled_name != NULL)\n-\tstrcpy ((*slot)->demangled, demangled_name.get ());\n-      else\n-\t(*slot)->demangled[0] = '\\0';\n     }\n   else if (gsymbol->language == language_unknown\n \t   || gsymbol->language == language_auto)\n     gsymbol->language = (*slot)->language;\n \n   gsymbol->name = (*slot)->mangled.data ();\n-  if ((*slot)->demangled[0] != '\\0')\n-    symbol_set_demangled_name (gsymbol, (*slot)->demangled,\n+  if ((*slot)->demangled != nullptr)\n+    symbol_set_demangled_name (gsymbol, (*slot)->demangled.get (),\n \t\t\t       &per_bfd->storage_obstack);\n   else\n     symbol_set_demangled_name (gsymbol, NULL, &per_bfd->storage_obstack);"
    }
  ]
}