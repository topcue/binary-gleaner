{
  "sha": "8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138",
  "node_id": "C_kwDOANOeidoAKDhhODlkZGJkYTJlY2I0MWJlMGYxMjE0MmU1ZDRiOTVjN2JkNWExMzg",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-09-14T18:01:37Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-11-05T17:24:21Z"
    },
    "message": "Avoid /proc/pid/mem races (PR 28065)\n\nPR 28065 (gdb.threads/access-mem-running-thread-exit.exp intermittent\nfailure) shows that GDB can hit an unexpected scenario -- it can\nhappen that the kernel manages to open a /proc/PID/task/LWP/mem file,\nbut then reading from the file returns 0/EOF, even though the process\nhasn't exited or execed.\n\n\"0\" out of read/write is normally what you get when the address space\nof the process the file was open for is gone, because the process\nexeced or exited.  So when GDB gets the 0, it returns memory access\nfailure.  In the bad case in question, the process hasn't execed or\nexited, so GDB fails a memory access when the access should have\nworked.\n\nGDB has code in place to gracefully handle the case of opening the\n/proc/PID/task/LWP/mem just while the LWP is exiting -- most often the\nopen fails with EACCES or ENOENT.  When it happens, GDB just tries\nopening the file for a different thread of the process.  The testcase\nis written such that it stresses GDB's logic of closing/reopening the\n/proc/PID/task/LWP/mem file, by constantly spawning short lived\nthreads.\n\nHowever, there's a window where the kernel manages to find the thread,\nbut the thread exits just after and clears its address space pointer.\nIn this case, the kernel creates a file successfully, but the file\nends up with no address space associated, so a subsequent read/write\nreturns 0/EOF too, just like if the whole process had execed or\nexited.  This is the case in question that GDB does not handle.\n\nOleg Nesterov gave this suggestion as workaround for that race:\n\n    gdb can open(/proc/pid/mem) and then read (say) /proc/pid/statm.\n    If statm reports something non-zero, then open() was \"successfull\".\n\nI think that might work.  However, I didn't try it, because I realized\nwe have another nasty race that that wouldn't fix.\n\nThe other race I realized is that because we close/reopen the\n/proc/PID/task/LWP/mem file when GDB switches to a different inferior,\nthen it can happen that GDB reopens /proc/PID/task/LWP/mem just after\na thread execs, and before GDB has seen the corresponding exec event.\nI.e., we can open a /proc/PID/task/LWP/mem file accessing the\npost-exec address space thinking we're accessing the pre-exec address\nspace.\n\nA few months back, Simon, Oleg and I discussed a similar race:\n\n  [Bug gdb/26754] Race condition when resuming threads and one does an exec\n  https://sourceware.org/bugzilla/show_bug.cgi?id=26754\n\nThe solution back then was to make the kernel fail any ptrace\noperation until the exec event is consumed, with this kernel commit:\n\n commit dbb5afad100a828c97e012c6106566d99f041db6\n Author:     Oleg Nesterov <oleg@redhat.com>\n AuthorDate: Wed May 12 15:33:08 2021 +0200\n Commit:     Linus Torvalds <torvalds@linux-foundation.org>\n CommitDate: Wed May 12 10:45:22 2021 -0700\n\n     ptrace: make ptrace() fail if the tracee changed its pid unexpectedly\n\nThis however, only applies to ptrace, not to the /proc/pid/mem file\nopening case.  Also, even if it did apply to the file open case, we\nwould want to support current kernels until such a fix is more wide\nspread anyhow.\n\nSo all in all, this commit gives up on the idea of only ever keeping\none /proc/pid/mem file descriptor open.  Instead, make GDB open a\n/proc/pid/mem per inferior, and keep it open until the inferior exits,\nis detached or execs.  Make GDB open the file right after the inferior\nis created or is attached to or forks, at which point we know the\ninferior is stable and stopped and isn't thus going to exec, or have a\nthread exit, and so the file open won't fail (unless the whole process\nis SIGKILLed from outside GDB, at which point it doesn't matter\nwhether we open the file).\n\nThis way, we avoid both races described above, at the expense of using\nmore file descriptors (one per inferior).\n\nBug: https://sourceware.org/bugzilla/show_bug.cgi?id=28065\nChange-Id: Iff943b95126d0f98a7973a07e989e4f020c29419",
    "tree": {
      "sha": "6b9b95c6b028265c02d63f884067b51068a15988",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6b9b95c6b028265c02d63f884067b51068a15988"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "707ed39ac5cb255f656b2947b50c8273c8ad1d80",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/707ed39ac5cb255f656b2947b50c8273c8ad1d80",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/707ed39ac5cb255f656b2947b50c8273c8ad1d80"
    }
  ],
  "stats": {
    "total": 338,
    "additions": 147,
    "deletions": 191
  },
  "files": [
    {
      "sha": "f8f728481ea76c77351d14eb39a1a40dfca8281b",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 139,
      "deletions": 185,
      "changes": 324,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138",
      "patch": "@@ -69,6 +69,7 @@\n #include \"gdbsupport/scope-exit.h\"\n #include \"gdbsupport/gdb-sigmask.h\"\n #include \"gdbsupport/common-debug.h\"\n+#include <unordered_map>\n \n /* This comment documents high-level logic of this file.\n \n@@ -280,7 +281,8 @@ static int lwp_status_pending_p (struct lwp_info *lp);\n \n static void save_stop_reason (struct lwp_info *lp);\n \n-static void maybe_close_proc_mem_file (pid_t pid);\n+static void close_proc_mem_file (pid_t pid);\n+static void open_proc_mem_file (ptid_t ptid);\n \n \f\n /* LWP accessors.  */\n@@ -514,6 +516,8 @@ linux_nat_target::follow_fork (inferior *child_inf, ptid_t child_ptid,\n \t\t  && !signal_pass_state (gdb_signal_from_host (signo)))\n \t\tsigno = 0;\n \t      ptrace (PTRACE_DETACH, child_pid, 0, signo);\n+\n+\t      close_proc_mem_file (child_pid);\n \t    }\n \t}\n \n@@ -1059,6 +1063,8 @@ linux_nat_target::create_inferior (const char *exec_file,\n   pass_signals ({});\n \n   inf_ptrace_target::create_inferior (exec_file, allargs, env, from_tty);\n+\n+  open_proc_mem_file (inferior_ptid);\n }\n \n /* Callback for linux_proc_attach_tgid_threads.  Attach to PTID if not\n@@ -1204,6 +1210,8 @@ linux_nat_target::attach (const char *args, int from_tty)\n \n   lp->stopped = 1;\n \n+  open_proc_mem_file (lp->ptid);\n+\n   /* Save the wait status to report later.  */\n   lp->resumed = 1;\n   linux_nat_debug_printf (\"waitpid %ld, saving status %s\",\n@@ -1455,7 +1463,7 @@ linux_nat_target::detach (inferior *inf, int from_tty)\n       detach_success (inf);\n     }\n \n-  maybe_close_proc_mem_file (pid);\n+  close_proc_mem_file (pid);\n }\n \n /* Resume execution of the inferior process.  If STEP is nonzero,\n@@ -1894,6 +1902,8 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \n       if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK)\n \t{\n+\t  open_proc_mem_file (child_ptid);\n+\n \t  /* The arch-specific native code may need to know about new\n \t     forks even if those end up never mapped to an\n \t     inferior.  */\n@@ -1999,9 +2009,13 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n     {\n       linux_nat_debug_printf (\"Got exec event from LWP %ld\", lp->ptid.lwp ());\n \n-      /* Close the /proc/<pid>/mem file if it was open for this\n-\t inferior.  */\n-      maybe_close_proc_mem_file (lp->ptid.pid ());\n+      /* Close the previous /proc/PID/mem file for this inferior,\n+\t which was using the address space which is now gone.\n+\t Reading/writing from this file would return 0/EOF.  */\n+      close_proc_mem_file (lp->ptid.pid ());\n+\n+      /* Open a new file for the new address space.  */\n+      open_proc_mem_file (lp->ptid);\n \n       ourstatus->set_execd\n \t(make_unique_xstrdup (linux_proc_pid_to_exec_file (pid)));\n@@ -3566,9 +3580,7 @@ linux_nat_target::mourn_inferior ()\n \n   purge_lwp_list (pid);\n \n-  /* Close the /proc/<pid>/mem file if it was open for this\n-     inferior.  */\n-  maybe_close_proc_mem_file (pid);\n+  close_proc_mem_file (pid);\n \n   if (! forks_exist_p ())\n     /* Normal case, no other forks available.  */\n@@ -3765,91 +3777,134 @@ linux_nat_target::pid_to_exec_file (int pid)\n   return linux_proc_pid_to_exec_file (pid);\n }\n \n-/* Keep the /proc/<pid>/mem file open between memory accesses, as a\n-   cache to avoid constantly closing/opening the file in the common\n-   case of multiple memory reads/writes from/to the same inferior.\n-   Note we don't keep a file open per inferior to avoid keeping too\n-   many file descriptors open, which can run into resource limits.  */\n-static struct\n-{\n-  /* The LWP this open file is for.  Note that after opening the file,\n-     even if the thread subsequently exits, the open file is still\n-     usable for accessing memory.  It's only when the whole process\n-     exits or execs that the file becomes invalid (at which point\n-     reads/writes return EOF).  */\n-  ptid_t ptid;\n-\n-  /* The file descriptor.  -1 if file is not open.  */\n-  int fd = -1;\n+/* Object representing an /proc/PID/mem open file.  We keep one such\n+   file open per inferior.\n+\n+   It might be tempting to think about only ever opening one file at\n+   most for all inferiors, closing/reopening the file as we access\n+   memory of different inferiors, to minimize number of file\n+   descriptors open, which can otherwise run into resource limits.\n+   However, that does not work correctly -- if the inferior execs and\n+   we haven't processed the exec event yet, and, we opened a\n+   /proc/PID/mem file, we will get a mem file accessing the post-exec\n+   address space, thinking we're opening it for the pre-exec address\n+   space.  That is dangerous as we can poke memory (e.g. clearing\n+   breakpoints) in the post-exec memory by mistake, corrupting the\n+   inferior.  For that reason, we open the mem file as early as\n+   possible, right after spawning, forking or attaching to the\n+   inferior, when the inferior is stopped and thus before it has a\n+   chance of execing.\n+\n+   Note that after opening the file, even if the thread we opened it\n+   for subsequently exits, the open file is still usable for accessing\n+   memory.  It's only when the whole process exits or execs that the\n+   file becomes invalid, at which point reads/writes return EOF.  */\n+\n+class proc_mem_file\n+{\n+public:\n+  proc_mem_file (ptid_t ptid, int fd)\n+    : m_ptid (ptid), m_fd (fd)\n+  {\n+    gdb_assert (m_fd != -1);\n+  }\n \n-  /* Close FD and clear it to -1.  */\n-  void close ()\n+  ~proc_mem_file ()\n   {\n     linux_nat_debug_printf (\"closing fd %d for /proc/%d/task/%ld/mem\",\n-\t\t\t    fd, ptid.pid (), ptid.lwp ());\n-    ::close (fd);\n-    fd = -1;\n+\t\t\t    m_fd, m_ptid.pid (), m_ptid.lwp ());\n+    close (m_fd);\n   }\n-} last_proc_mem_file;\n \n-/* Close the /proc/<pid>/mem file if its LWP matches PTID.  */\n+  DISABLE_COPY_AND_ASSIGN (proc_mem_file);\n+\n+  int fd ()\n+  {\n+    return m_fd;\n+  }\n+\n+private:\n+  /* The LWP this file was opened for.  Just for debugging\n+     purposes.  */\n+  ptid_t m_ptid;\n+\n+  /* The file descriptor.  */\n+  int m_fd = -1;\n+};\n+\n+/* The map between an inferior process id, and the open /proc/PID/mem\n+   file.  This is stored in a map instead of in a per-inferior\n+   structure because we need to be able to access memory of processes\n+   which don't have a corresponding struct inferior object.  E.g.,\n+   with \"detach-on-fork on\" (the default), and \"follow-fork parent\"\n+   (also default), we don't create an inferior for the fork child, but\n+   we still need to remove breakpoints from the fork child's\n+   memory.  */\n+static std::unordered_map<int, proc_mem_file> proc_mem_file_map;\n+\n+/* Close the /proc/PID/mem file for PID.  */\n \n static void\n-maybe_close_proc_mem_file (pid_t pid)\n+close_proc_mem_file (pid_t pid)\n {\n-  if (last_proc_mem_file.ptid.pid () == pid)\n-    last_proc_mem_file.close ();\n+  proc_mem_file_map.erase (pid);\n }\n \n-/* Helper for linux_proc_xfer_memory_partial.  Accesses /proc via\n-   PTID.  Returns -1 on error, with errno set.  Returns number of\n-   read/written bytes otherwise.  Returns 0 on EOF, which indicates\n-   the address space is gone (because the process exited or\n-   execed).  */\n+/* Open the /proc/PID/mem file for the process (thread group) of PTID.\n+   We actually open /proc/PID/task/LWP/mem, as that's the LWP we know\n+   exists and is stopped right now.  We prefer the\n+   /proc/PID/task/LWP/mem form over /proc/LWP/mem to avoid tid-reuse\n+   races, just in case this is ever called on an already-waited\n+   LWP.  */\n \n-static ssize_t\n-linux_proc_xfer_memory_partial_pid (ptid_t ptid,\n-\t\t\t\t    gdb_byte *readbuf, const gdb_byte *writebuf,\n-\t\t\t\t    ULONGEST offset, LONGEST len)\n+static void\n+open_proc_mem_file (ptid_t ptid)\n {\n-  ssize_t ret;\n+  auto iter = proc_mem_file_map.find (ptid.pid ());\n+  gdb_assert (iter == proc_mem_file_map.end ());\n \n-  /* As long as we're hitting the same inferior, the previously open\n-     file is good, even if the thread it was open for exits.  */\n-  if (last_proc_mem_file.fd != -1\n-      && last_proc_mem_file.ptid.pid () != ptid.pid ())\n-    last_proc_mem_file.close ();\n+  char filename[64];\n+  xsnprintf (filename, sizeof filename,\n+\t     \"/proc/%d/task/%ld/mem\", ptid.pid (), ptid.lwp ());\n \n-  if (last_proc_mem_file.fd == -1)\n-    {\n-      /* Actually use /proc/<pid>/task/<lwp>/mem instead of\n-\t /proc/<lwp>/mem to avoid PID-reuse races, as we may be trying\n-\t to read memory via a thread which we've already reaped.\n-\t /proc/<lwp>/mem could open a file for the wrong process.  If\n-\t the LWPID is reused for the same process it's OK, we can read\n-\t memory through it just fine.  If the LWPID is reused for a\n-\t different process, then the open will fail because the path\n-\t won't exist.  */\n-      char filename[64];\n-      xsnprintf (filename, sizeof filename,\n-\t\t \"/proc/%d/task/%ld/mem\", ptid.pid (), ptid.lwp ());\n-\n-      last_proc_mem_file.fd\n-\t= gdb_open_cloexec (filename, O_RDWR | O_LARGEFILE, 0).release ();\n-\n-      if (last_proc_mem_file.fd == -1)\n-\t{\n-\t  linux_nat_debug_printf (\"opening %s failed: %s (%d)\\n\",\n-\t\t\t\t  filename, safe_strerror (errno), errno);\n-\t  return -1;\n-\t}\n-      last_proc_mem_file.ptid = ptid;\n+  int fd = gdb_open_cloexec (filename, O_RDWR | O_LARGEFILE, 0).release ();\n \n-      linux_nat_debug_printf (\"opened fd %d for %s\",\n-\t\t\t      last_proc_mem_file.fd, filename);\n+  if (fd == -1)\n+    {\n+      warning (_(\"opening /proc/PID/mem file for lwp %d.%ld failed: %s (%d)\"),\n+\t       ptid.pid (), ptid.lwp (),\n+\t       safe_strerror (errno), errno);\n+      return;\n     }\n \n-  int fd = last_proc_mem_file.fd;\n+  proc_mem_file_map.emplace (std::piecewise_construct,\n+\t\t\t     std::forward_as_tuple (ptid.pid ()),\n+\t\t\t     std::forward_as_tuple (ptid, fd));\n+\n+  linux_nat_debug_printf (\"opened fd %d for lwp %d.%ld\\n\",\n+\t\t\t  fd, ptid.pid (), ptid.lwp ());\n+}\n+\n+/* Implement the to_xfer_partial target method using /proc/PID/mem.\n+   Because we can use a single read/write call, this can be much more\n+   efficient than banging away at PTRACE_PEEKTEXT.  Also, unlike\n+   PTRACE_PEEKTEXT/PTRACE_POKETEXT, this works with running\n+   threads.  */\n+\n+static enum target_xfer_status\n+linux_proc_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n+\t\t\t\tULONGEST offset, LONGEST len,\n+\t\t\t\tULONGEST *xfered_len)\n+{\n+  ssize_t ret;\n+\n+  auto iter = proc_mem_file_map.find (inferior_ptid.pid ());\n+  if (iter == proc_mem_file_map.end ())\n+    return TARGET_XFER_EOF;\n+\n+  int fd = iter->second.fd ();\n+\n+  gdb_assert (fd != -1);\n \n   /* Use pread64/pwrite64 if available, since they save a syscall and can\n      handle 64-bit offsets even on 32-bit platforms (for instance, SPARC\n@@ -3866,125 +3921,24 @@ linux_proc_xfer_memory_partial_pid (ptid_t ptid,\n \n   if (ret == -1)\n     {\n-      linux_nat_debug_printf (\"accessing fd %d for pid %ld failed: %s (%d)\\n\",\n-\t\t\t      fd, ptid.lwp (),\n+      linux_nat_debug_printf (\"accessing fd %d for pid %d failed: %s (%d)\\n\",\n+\t\t\t      fd, inferior_ptid.pid (),\n \t\t\t      safe_strerror (errno), errno);\n+      return TARGET_XFER_EOF;\n     }\n   else if (ret == 0)\n     {\n-      linux_nat_debug_printf (\"accessing fd %d for pid %ld got EOF\\n\",\n-\t\t\t      fd, ptid.lwp ());\n-    }\n-\n-  return ret;\n-}\n-\n-/* Implement the to_xfer_partial target method using /proc/<pid>/mem.\n-   Because we can use a single read/write call, this can be much more\n-   efficient than banging away at PTRACE_PEEKTEXT.  Also, unlike\n-   PTRACE_PEEKTEXT/PTRACE_POKETEXT, this works with running\n-   threads.  */\n-\n-static enum target_xfer_status\n-linux_proc_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n-\t\t\t\tULONGEST offset, LONGEST len,\n-\t\t\t\tULONGEST *xfered_len)\n-{\n-  /* Unlike PTRACE_PEEKTEXT/PTRACE_POKETEXT, reading/writing from/to\n-     /proc/<pid>/mem works with running threads, and even exited\n-     threads if the file was already open.  If we need to open or\n-     reopen the /proc file though, we may get an EACCES error\n-     (\"Permission denied\"), meaning the thread is gone but its exit\n-     status isn't reaped yet, or ENOENT if the thread is gone and\n-     already reaped.  In that case, just try opening the file for\n-     another thread in the process.  If all threads fail, then it must\n-     mean the whole process exited, in which case there's nothing else\n-     to do and we just fail the memory access.\n-\n-     Note we don't simply always access via the leader thread because\n-     the leader may exit without exiting the whole process.  See\n-     gdb.threads/leader-exit.exp, for example.  */\n-\n-  /* It's frequently the case that the selected thread is stopped, and\n-     is thus not likely to exit (unless something kills the process\n-     outside our control, with e.g., SIGKILL).  Give that one a try\n-     first.\n-\n-     Also, inferior_ptid may actually point at an LWP not in lwp_list.\n-     This happens when we're detaching from a fork child that we don't\n-     want to debug (\"set detach-on-fork on\"), and the breakpoints\n-     module uninstalls breakpoints from the fork child.  Which process\n-     to access is given by inferior_ptid.  */\n-  int res = linux_proc_xfer_memory_partial_pid (inferior_ptid,\n-\t\t\t\t\t\treadbuf, writebuf,\n-\t\t\t\t\t\toffset, len);\n-  if (res == 0)\n-    {\n-      /* EOF means the address space is gone, the whole\n-\t process exited or execed.  */\n+      /* EOF means the address space is gone, the whole process exited\n+\t or execed.  */\n+      linux_nat_debug_printf (\"accessing fd %d for pid %d got EOF\\n\",\n+\t\t\t      fd, inferior_ptid.pid ());\n       return TARGET_XFER_EOF;\n     }\n-  else if (res != -1)\n-    {\n-      *xfered_len = res;\n-      return TARGET_XFER_OK;\n-    }\n   else\n     {\n-      /* If we simply raced with the thread exiting (EACCES), or the\n-\t current thread is THREAD_EXITED (ENOENT), try some other\n-\t thread.  It's easier to handle an ENOENT failure than check\n-\t for THREAD_EXIT upfront because this function is called\n-\t before a thread for inferior_ptid is added to the thread\n-\t list.  */\n-      if (errno != EACCES && errno != ENOENT)\n-\treturn TARGET_XFER_EOF;\n-    }\n-\n-  int cur_pid = current_inferior ()->pid;\n-\n-  if (inferior_ptid.pid () != cur_pid)\n-    {\n-      /* We're accessing a fork child, and the access above failed.\n-\t Don't bother iterating the LWP list, since there's no other\n-\t LWP for this process.  */\n-      return TARGET_XFER_EOF;\n-    }\n-\n-  /* Iterate over LWPs of the current inferior, trying to access\n-     memory through one of them.  */\n-  for (lwp_info *lp : all_lwps ())\n-    {\n-      if (lp->ptid.pid () != cur_pid)\n-\tcontinue;\n-\n-      res = linux_proc_xfer_memory_partial_pid (lp->ptid,\n-\t\t\t\t\t\treadbuf, writebuf,\n-\t\t\t\t\t\toffset, len);\n-\n-      if (res == 0)\n-\t{\n-\t  /* EOF means the address space is gone, the whole process\n-\t     exited or execed.  */\n-\t  return TARGET_XFER_EOF;\n-\t}\n-      else if (res == -1)\n-\t{\n-\t  if (errno == EACCES)\n-\t    {\n-\t      /* This LWP is gone, try another one.  */\n-\t      continue;\n-\t    }\n-\n-\t  return TARGET_XFER_EOF;\n-\t}\n-\n-      *xfered_len = res;\n+      *xfered_len = ret;\n       return TARGET_XFER_OK;\n     }\n-\n-  /* No luck.  */\n-  return TARGET_XFER_EOF;\n }\n \n /* Parse LINE as a signal set and add its set bits to SIGS.  */"
    },
    {
      "sha": "7c2ea5d40f7737cdb520a4972b4e10f95b14b2f5",
      "filename": "gdb/testsuite/gdb.threads/access-mem-running-thread-exit.exp",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.exp?ref=8a89ddbda2ecb41be0f12142e5d4b95c7bd5a138",
      "patch": "@@ -26,12 +26,14 @@\n # memory through exits.\n #\n # The test spawns two processes and alternates memory accesses between\n-# them to force flushing per-process caches.  At the time of writing,\n-# the Linux backend accesses inferior memory via /proc/<pid>/mem, and\n-# keeps one such file open, as a cache.  Alternating inferiors forces\n-# opening such file for a different process, which fails if GDB tries\n-# to open the file for a thread that exited.  The test does ensures\n-# those reopen/fail code paths are exercised.\n+# them to force flushing per-process caches.  When the testcase was\n+# originally written, the Linux backend would access inferior memory\n+# via /proc/PID/mem, and kept one such file open, as a cache.\n+# Alternating inferiors would force re-opening such file for a\n+# different process, which would fail if GDB tried to open the file\n+# for a thread that exited.  The test thus ensured those reopen/fail\n+# code paths were exercised.  Nowadays, GDB keeps one /proc/PID/mem\n+# file open per inferior.\n \n standard_testfile\n "
    }
  ]
}