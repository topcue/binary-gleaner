{
  "sha": "ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWUxYjhiOTQ3N2I3ZTQ5ZWNjMGJmNDBiZTBmNjA3MjY4MTVlYjRjYQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-09-25T14:24:29Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-09-25T14:24:44Z"
    },
    "message": "Import mklog.py from gcc repo\n\nI've been using the mklog utility from the gcc repo for a while to\ngenerate skeleton of ChangeLog entries.  It recently got a rewrite as a\nPython script.  Unfortunately, to find the repository root, and\neventually to find in which ChangeLog file each entry goes, the new\nscript assumes it is located in the same git repository that it\ngenerates ChangeLog entries for.\n\nThis means that if you make a change in the gcc source tree and run\nmklog.py from that same source tree, it works.  But if you make changes\nin your ~/src/binutils-gdb tree and run ~/src/gcc/contrib/mklog.py, it\nwon't work.\n\nIIRC, the old script required that you ran it with the project's root\ndirectory as the CWD.\n\nThe simplest way to fix this is to import the script in binutils-gdb and\nuse it from there.  It's also nice because we can use it without having\na clone of the gcc repo.\n\nI also thought of adding a \"--root\" switch to the script to override the\nproject's base directory.  However:\n\n1) It is more work.\n2) If the script still lives in the gcc repo, it's less convenient than\n   having it in binutils-gdb.\n\nThis patch imports contrib/mklog.py from the gcc repo, revision\nc560591408440f441b8b327f5b41f9328d20b67b.\n\ncontrib/ChangeLog:\n\n\t* mklog.py: New file, imported from gcc.\n\nNote: the ChangeLog entry above was generated using\n`git show | ./mklog.py`!\n\nChange-Id: I955592ce6397681986dc82a09593c32d8b8de54f",
    "tree": {
      "sha": "b70fc7ab14b6ca5f996e7541f268270d80ce456f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b70fc7ab14b6ca5f996e7541f268270d80ce456f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e851246a2a04b814632ab7b205faa84655c2acdc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e851246a2a04b814632ab7b205faa84655c2acdc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e851246a2a04b814632ab7b205faa84655c2acdc"
    }
  ],
  "stats": {
    "total": 265,
    "additions": 265,
    "deletions": 0
  },
  "files": [
    {
      "sha": "87526afc7872fbdc3557086e8270c42565b4fcf0",
      "filename": "contrib/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca/contrib/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca/contrib/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/contrib/ChangeLog?ref=ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca",
      "patch": "@@ -1,3 +1,7 @@\n+2020-09-25  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* mklog.py: New file, imported from gcc.\n+\n 2020-05-15  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* dg-extract-results.py: Update from gcc repo."
    },
    {
      "sha": "243edbb15c522169709902b27a8558c6e0755107",
      "filename": "contrib/mklog.py",
      "status": "added",
      "additions": 261,
      "deletions": 0,
      "changes": 261,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca/contrib/mklog.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca/contrib/mklog.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/contrib/mklog.py?ref=ee1b8b9477b7e49ecc0bf40be0f60726815eb4ca",
      "patch": "@@ -0,0 +1,261 @@\n+#!/usr/bin/env python3\n+\n+# Copyright (C) 2020 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+# Boston, MA 02110-1301, USA.\n+\n+# This script parses a .diff file generated with 'diff -up' or 'diff -cp'\n+# and adds a skeleton ChangeLog file to the file. It does not try to be\n+# too smart when parsing function names, but it produces a reasonable\n+# approximation.\n+#\n+# Author: Martin Liska <mliska@suse.cz>\n+\n+import argparse\n+import os\n+import re\n+import sys\n+from itertools import takewhile\n+\n+import requests\n+\n+from unidiff import PatchSet\n+\n+pr_regex = re.compile(r'(\\/(\\/|\\*)|[Cc*!])\\s+(?P<pr>PR [a-z+-]+\\/[0-9]+)')\n+dr_regex = re.compile(r'(\\/(\\/|\\*)|[Cc*!])\\s+(?P<dr>DR [0-9]+)')\n+identifier_regex = re.compile(r'^([a-zA-Z0-9_#].*)')\n+comment_regex = re.compile(r'^\\/\\*')\n+struct_regex = re.compile(r'^(class|struct|union|enum)\\s+'\n+                          r'(GTY\\(.*\\)\\s+)?([a-zA-Z0-9_]+)')\n+macro_regex = re.compile(r'#\\s*(define|undef)\\s+([a-zA-Z0-9_]+)')\n+super_macro_regex = re.compile(r'^DEF[A-Z0-9_]+\\s*\\(([a-zA-Z0-9_]+)')\n+fn_regex = re.compile(r'([a-zA-Z_][^()\\s]*)\\s*\\([^*]')\n+template_and_param_regex = re.compile(r'<[^<>]*>')\n+bugzilla_url = 'https://gcc.gnu.org/bugzilla/rest.cgi/bug?id=%s&' \\\n+               'include_fields=summary'\n+\n+function_extensions = set(['.c', '.cpp', '.C', '.cc', '.h', '.inc', '.def'])\n+\n+help_message = \"\"\"\\\n+Generate ChangeLog template for PATCH.\n+PATCH must be generated using diff(1)'s -up or -cp options\n+(or their equivalent in git).\n+\"\"\"\n+\n+script_folder = os.path.realpath(__file__)\n+gcc_root = os.path.dirname(os.path.dirname(script_folder))\n+\n+\n+def find_changelog(path):\n+    folder = os.path.split(path)[0]\n+    while True:\n+        if os.path.exists(os.path.join(gcc_root, folder, 'ChangeLog')):\n+            return folder\n+        folder = os.path.dirname(folder)\n+        if folder == '':\n+            return folder\n+    raise AssertionError()\n+\n+\n+def extract_function_name(line):\n+    if comment_regex.match(line):\n+        return None\n+    m = struct_regex.search(line)\n+    if m:\n+        # Struct declaration\n+        return m.group(1) + ' ' + m.group(3)\n+    m = macro_regex.search(line)\n+    if m:\n+        # Macro definition\n+        return m.group(2)\n+    m = super_macro_regex.search(line)\n+    if m:\n+        # Supermacro\n+        return m.group(1)\n+    m = fn_regex.search(line)\n+    if m:\n+        # Discard template and function parameters.\n+        fn = m.group(1)\n+        fn = re.sub(template_and_param_regex, '', fn)\n+        return fn.rstrip()\n+    return None\n+\n+\n+def try_add_function(functions, line):\n+    fn = extract_function_name(line)\n+    if fn and fn not in functions:\n+        functions.append(fn)\n+    return bool(fn)\n+\n+\n+def sort_changelog_files(changed_file):\n+    return (changed_file.is_added_file, changed_file.is_removed_file)\n+\n+\n+def get_pr_titles(prs):\n+    output = ''\n+    for pr in prs:\n+        id = pr.split('/')[-1]\n+        r = requests.get(bugzilla_url % id)\n+        bugs = r.json()['bugs']\n+        if len(bugs) == 1:\n+            output += '%s - %s\\n' % (pr, bugs[0]['summary'])\n+            print(output)\n+    if output:\n+        output += '\\n'\n+    return output\n+\n+\n+def generate_changelog(data, no_functions=False, fill_pr_titles=False):\n+    changelogs = {}\n+    changelog_list = []\n+    prs = []\n+    out = ''\n+    diff = PatchSet(data)\n+\n+    for file in diff:\n+        changelog = find_changelog(file.path)\n+        if changelog not in changelogs:\n+            changelogs[changelog] = []\n+            changelog_list.append(changelog)\n+        changelogs[changelog].append(file)\n+\n+        # Extract PR entries from newly added tests\n+        if 'testsuite' in file.path and file.is_added_file:\n+            for line in list(file)[0]:\n+                m = pr_regex.search(line.value)\n+                if m:\n+                    pr = m.group('pr')\n+                    if pr not in prs:\n+                        prs.append(pr)\n+                else:\n+                    m = dr_regex.search(line.value)\n+                    if m:\n+                        dr = m.group('dr')\n+                        if dr not in prs:\n+                            prs.append(dr)\n+                    else:\n+                        break\n+\n+    if fill_pr_titles:\n+        out += get_pr_titles(prs)\n+\n+    # sort ChangeLog so that 'testsuite' is at the end\n+    for changelog in sorted(changelog_list, key=lambda x: 'testsuite' in x):\n+        files = changelogs[changelog]\n+        out += '%s:\\n' % os.path.join(changelog, 'ChangeLog')\n+        out += '\\n'\n+        for pr in prs:\n+            out += '\\t%s\\n' % pr\n+        # new and deleted files should be at the end\n+        for file in sorted(files, key=sort_changelog_files):\n+            assert file.path.startswith(changelog)\n+            in_tests = 'testsuite' in changelog or 'testsuite' in file.path\n+            relative_path = file.path[len(changelog):].lstrip('/')\n+            functions = []\n+            if file.is_added_file:\n+                msg = 'New test' if in_tests else 'New file'\n+                out += '\\t* %s: %s.\\n' % (relative_path, msg)\n+            elif file.is_removed_file:\n+                out += '\\t* %s: Removed.\\n' % (relative_path)\n+            elif hasattr(file, 'is_rename') and file.is_rename:\n+                out += '\\t* %s: Moved to...\\n' % (relative_path)\n+                new_path = file.target_file[2:]\n+                # A file can be theoretically moved to a location that\n+                # belongs to a different ChangeLog.  Let user fix it.\n+                if new_path.startswith(changelog):\n+                    new_path = new_path[len(changelog):].lstrip('/')\n+                out += '\\t* %s: ...here.\\n' % (new_path)\n+            else:\n+                if not no_functions:\n+                    for hunk in file:\n+                        # Do not add function names for testsuite files\n+                        extension = os.path.splitext(relative_path)[1]\n+                        if not in_tests and extension in function_extensions:\n+                            last_fn = None\n+                            modified_visited = False\n+                            success = False\n+                            for line in hunk:\n+                                m = identifier_regex.match(line.value)\n+                                if line.is_added or line.is_removed:\n+                                    if not line.value.strip():\n+                                        continue\n+                                    modified_visited = True\n+                                    if m and try_add_function(functions,\n+                                                              m.group(1)):\n+                                        last_fn = None\n+                                        success = True\n+                                elif line.is_context:\n+                                    if last_fn and modified_visited:\n+                                        try_add_function(functions, last_fn)\n+                                        last_fn = None\n+                                        modified_visited = False\n+                                        success = True\n+                                    elif m:\n+                                        last_fn = m.group(1)\n+                                        modified_visited = False\n+                            if not success:\n+                                try_add_function(functions,\n+                                                 hunk.section_header)\n+                if functions:\n+                    out += '\\t* %s (%s):\\n' % (relative_path, functions[0])\n+                    for fn in functions[1:]:\n+                        out += '\\t(%s):\\n' % fn\n+                else:\n+                    out += '\\t* %s:\\n' % relative_path\n+        out += '\\n'\n+    return out\n+\n+\n+if __name__ == '__main__':\n+    parser = argparse.ArgumentParser(description=help_message)\n+    parser.add_argument('input', nargs='?',\n+                        help='Patch file (or missing, read standard input)')\n+    parser.add_argument('-s', '--no-functions', action='store_true',\n+                        help='Do not generate function names in ChangeLogs')\n+    parser.add_argument('-p', '--fill-up-bug-titles', action='store_true',\n+                        help='Download title of mentioned PRs')\n+    parser.add_argument('-c', '--changelog',\n+                        help='Append the ChangeLog to a git commit message '\n+                             'file')\n+    args = parser.parse_args()\n+    if args.input == '-':\n+        args.input = None\n+\n+    input = open(args.input) if args.input else sys.stdin\n+    data = input.read()\n+    output = generate_changelog(data, args.no_functions,\n+                                args.fill_up_bug_titles)\n+    if args.changelog:\n+        lines = open(args.changelog).read().split('\\n')\n+        start = list(takewhile(lambda l: not l.startswith('#'), lines))\n+        end = lines[len(start):]\n+        with open(args.changelog, 'w') as f:\n+            if start:\n+                # appent empty line\n+                if start[-1] != '':\n+                    start.append('')\n+            else:\n+                # append 2 empty lines\n+                start = 2 * ['']\n+            f.write('\\n'.join(start))\n+            f.write('\\n')\n+            f.write(output)\n+            f.write('\\n'.join(end))\n+    else:\n+        print(output, end='')"
    }
  ]
}