{
  "sha": "a519e8ffe2b0f008deaef1517562090d9eaadccc",
  "node_id": "C_kwDOANOeidoAKGE1MTllOGZmZTJiMGYwMDhkZWFlZjE1MTc1NjIwOTBkOWVhYWRjY2M",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-09-10T18:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-10-05T18:34:55Z"
    },
    "message": "Add lval_funcs::is_optimized_out\n\nThis adds an is_optimized_out function pointer to lval_funcs, and\nchanges value_optimized_out to call it.  This new function lets gdb\ndetermine if a value is optimized out without necessarily fetching the\nvalue.  This is needed for a subsequent patch, where an attempt to\naccess a lazy value would fail due to the value size limit -- however,\nthe access was only needed to determine the optimized-out state.",
    "tree": {
      "sha": "71b6a30706c0849c861c8d38cc25df4954be16fc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/71b6a30706c0849c861c8d38cc25df4954be16fc"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a519e8ffe2b0f008deaef1517562090d9eaadccc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a519e8ffe2b0f008deaef1517562090d9eaadccc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a519e8ffe2b0f008deaef1517562090d9eaadccc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a519e8ffe2b0f008deaef1517562090d9eaadccc/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "25b0a5714c9ef139bb50adf392154f528d6a4c8d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/25b0a5714c9ef139bb50adf392154f528d6a4c8d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/25b0a5714c9ef139bb50adf392154f528d6a4c8d"
    }
  ],
  "stats": {
    "total": 81,
    "additions": 66,
    "deletions": 15
  },
  "files": [
    {
      "sha": "0f05f889e2ad0f50f076b80f1948c16934eff735",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 44,
      "deletions": 12,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=a519e8ffe2b0f008deaef1517562090d9eaadccc",
      "patch": "@@ -149,10 +149,13 @@ allocate_piece_closure (dwarf2_per_cu_data *per_cu,\n /* Read or write a pieced value V.  If FROM != NULL, operate in \"write\n    mode\": copy FROM into the pieces comprising V.  If FROM == NULL,\n    operate in \"read mode\": fetch the contents of the (lazy) value V by\n-   composing it from its pieces.  */\n+   composing it from its pieces.  If CHECK_OPTIMIZED is true, then no\n+   reading or writing is done; instead the return value of this\n+   function is true if any piece is optimized out.  When\n+   CHECK_OPTIMIZED is true, FROM must be nullptr.  */\n \n-static void\n-rw_pieced_value (value *v, value *from)\n+static bool\n+rw_pieced_value (value *v, value *from, bool check_optimized)\n {\n   int i;\n   LONGEST offset = 0, max_offset;\n@@ -163,6 +166,7 @@ rw_pieced_value (value *v, value *from)\n   gdb::byte_vector buffer;\n   bool bits_big_endian = type_byte_order (value_type (v)) == BFD_ENDIAN_BIG;\n \n+  gdb_assert (!check_optimized || from == nullptr);\n   if (from != nullptr)\n     {\n       from_contents = value_contents (from);\n@@ -174,7 +178,10 @@ rw_pieced_value (value *v, value *from)\n \tinternal_error (__FILE__, __LINE__,\n \t\t\t_(\"Should not be able to create a lazy value with \"\n \t\t\t  \"an enclosing type\"));\n-      v_contents = value_contents_raw (v);\n+      if (check_optimized)\n+\tv_contents = nullptr;\n+      else\n+\tv_contents = value_contents_raw (v);\n       from_contents = nullptr;\n     }\n \n@@ -240,17 +247,22 @@ rw_pieced_value (value *v, value *from)\n \t\t\t\t\t       buffer, &optim, &unavail))\n \t\t  {\n \t\t    if (optim)\n-\t\t      mark_value_bits_optimized_out (v, offset,\n-\t\t\t\t\t\t     this_size_bits);\n-\t\t    if (unavail)\n+\t\t      {\n+\t\t\tif (check_optimized)\n+\t\t\t  return true;\n+\t\t\tmark_value_bits_optimized_out (v, offset,\n+\t\t\t\t\t\t       this_size_bits);\n+\t\t      }\n+\t\t    if (unavail && !check_optimized)\n \t\t      mark_value_bits_unavailable (v, offset,\n \t\t\t\t\t\t   this_size_bits);\n \t\t    break;\n \t\t  }\n \n-\t\tcopy_bitwise (v_contents, offset,\n-\t\t\t      buffer.data (), bits_to_skip % 8,\n-\t\t\t      this_size_bits, bits_big_endian);\n+\t\tif (!check_optimized)\n+\t\t  copy_bitwise (v_contents, offset,\n+\t\t\t\tbuffer.data (), bits_to_skip % 8,\n+\t\t\t\tthis_size_bits, bits_big_endian);\n \t      }\n \t    else\n \t      {\n@@ -286,6 +298,9 @@ rw_pieced_value (value *v, value *from)\n \n \tcase DWARF_VALUE_MEMORY:\n \t  {\n+\t    if (check_optimized)\n+\t      break;\n+\n \t    bits_to_skip += p->offset;\n \n \t    CORE_ADDR start_addr = p->v.mem.addr + bits_to_skip / 8;\n@@ -355,6 +370,9 @@ rw_pieced_value (value *v, value *from)\n \n \tcase DWARF_VALUE_STACK:\n \t  {\n+\t    if (check_optimized)\n+\t      break;\n+\n \t    if (from != nullptr)\n \t      {\n \t\tmark_value_bits_optimized_out (v, offset, this_size_bits);\n@@ -384,6 +402,9 @@ rw_pieced_value (value *v, value *from)\n \n \tcase DWARF_VALUE_LITERAL:\n \t  {\n+\t    if (check_optimized)\n+\t      break;\n+\n \t    if (from != nullptr)\n \t      {\n \t\tmark_value_bits_optimized_out (v, offset, this_size_bits);\n@@ -418,6 +439,8 @@ rw_pieced_value (value *v, value *from)\n \t  break;\n \n \tcase DWARF_VALUE_OPTIMIZED_OUT:\n+\t  if (check_optimized)\n+\t    return true;\n \t  mark_value_bits_optimized_out (v, offset, this_size_bits);\n \t  break;\n \n@@ -428,18 +451,26 @@ rw_pieced_value (value *v, value *from)\n       offset += this_size_bits;\n       bits_to_skip = 0;\n     }\n+\n+  return false;\n }\n \n static void\n read_pieced_value (value *v)\n {\n-  rw_pieced_value (v, nullptr);\n+  rw_pieced_value (v, nullptr, false);\n }\n \n static void\n write_pieced_value (value *to, value *from)\n {\n-  rw_pieced_value (to, from);\n+  rw_pieced_value (to, from, false);\n+}\n+\n+static bool\n+is_optimized_out_pieced_value (value *v)\n+{\n+  return rw_pieced_value (v, nullptr, true);\n }\n \n /* An implementation of an lval_funcs method to see whether a value is\n@@ -617,6 +648,7 @@ free_pieced_value_closure (value *v)\n static const struct lval_funcs pieced_value_funcs = {\n   read_pieced_value,\n   write_pieced_value,\n+  is_optimized_out_pieced_value,\n   indirect_pieced_value,\n   coerce_pieced_ref,\n   check_pieced_synthetic_pointer,"
    },
    {
      "sha": "0e5599353c4bd668cc07d149c92e30b11d0d3928",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=a519e8ffe2b0f008deaef1517562090d9eaadccc",
      "patch": "@@ -1282,6 +1282,7 @@ static const struct lval_funcs entry_data_value_funcs =\n {\n   NULL,\t/* read */\n   NULL,\t/* write */\n+  nullptr,\n   NULL,\t/* indirect */\n   entry_data_value_coerce_ref,\n   NULL,\t/* check_synthetic_pointer */"
    },
    {
      "sha": "b279674da983b4b18f5d0a711b65f434d5807ca1",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=a519e8ffe2b0f008deaef1517562090d9eaadccc",
      "patch": "@@ -254,6 +254,7 @@ static const struct lval_funcs opencl_value_funcs =\n   {\n     lval_func_read,\n     lval_func_write,\n+    nullptr,\n     NULL,\t/* indirect */\n     NULL,\t/* coerce_ref */\n     lval_func_check_synthetic_pointer,"
    },
    {
      "sha": "3aa5fac23069d45ae3b73e9847302c6ecc4bf4f9",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 14,
      "deletions": 3,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=a519e8ffe2b0f008deaef1517562090d9eaadccc",
      "patch": "@@ -1407,10 +1407,21 @@ value_contents_writeable (struct value *value)\n int\n value_optimized_out (struct value *value)\n {\n-  /* We can only know if a value is optimized out once we have tried to\n-     fetch it.  */\n-  if (value->optimized_out.empty () && value->lazy)\n+  if (value->lazy)\n     {\n+      /* See if we can compute the result without fetching the\n+\t value.  */\n+      if (VALUE_LVAL (value) == lval_memory)\n+\treturn false;\n+      else if (VALUE_LVAL (value) == lval_computed)\n+\t{\n+\t  const struct lval_funcs *funcs = value->location.computed.funcs;\n+\n+\t  if (funcs->is_optimized_out != nullptr)\n+\t    return funcs->is_optimized_out (value);\n+\t}\n+\n+      /* Fall back to fetching.  */\n       try\n \t{\n \t  value_fetch_lazy (value);"
    },
    {
      "sha": "45012372dbf522bad10d75cc50f259193ba7d0b9",
      "filename": "gdb/value.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/value.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a519e8ffe2b0f008deaef1517562090d9eaadccc/gdb/value.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.h?ref=a519e8ffe2b0f008deaef1517562090d9eaadccc",
      "patch": "@@ -264,6 +264,12 @@ struct lval_funcs\n      TOVAL is not considered as an lvalue.  */\n   void (*write) (struct value *toval, struct value *fromval);\n \n+  /* Return true if any part of V is optimized out, false otherwise.\n+     This will only be called for lazy values -- if the value has been\n+     fetched, then the value's optimized-out bits are consulted\n+     instead.  */\n+  bool (*is_optimized_out) (struct value *v);\n+\n   /* If non-NULL, this is used to implement pointer indirection for\n      this value.  This method may return NULL, in which case value_ind\n      will fall back to ordinary indirection.  */"
    }
  ]
}