{
  "sha": "7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzE4OGVkMDJkMmE3ZTNmY2UwMGEwMjE0ZTcwNDU3YzVlZjU2ZGY2Yg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:14:11Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:19:40Z"
    },
    "message": "Replace dwarf2_per_cu_data::cu backlink with per-objfile map\n\nThe dwarf2_per_cu_data type is going to become objfile-independent,\nwhile the dwarf2_cu type will stay object-dependent.  This patch removes\nthe backlink from dwarf2_per_cu_data to dwarf2_cu, in favor of the\ndwarf2_per_objfile::m_dwarf2_cus map.  It maps dwarf2_per_cu_data\nobjects to the corresponding dwarf2_cu objects for this objfile.  If a\nCU has been read in in the context of this objfile, then an entry will\nbe present in the map.\n\nThe dwarf2_cu objects that are read in are currently kept in a linked\nlist rooted in the dwarf2_per_bfd.  Except that the dwarf2_cu objects\nare not simply linked together, they are interleaved with their\ncorresponding dwarf2_per_cu_data objects.  So if we have CUs A and B\nread in, the dwarf2_per_bfd::read_in_chain will point to a chain like\nthis (DPCD == dwarf2_per_cu_data, DC == dwarf2_cu):\n\n DPCD A -> DC A -> DPCD B -> DC B\n\nObviously, this can't stay as is, since a same CU can be read in for an\nobjfile but not read in for another objfile sharing the same BFD, and\nthe dwarf2_per_cu_data::cu link is removed.   This is all replaced by\nthe dwarf2_per_objfile::m_dwarf2_cus map.\n\ngdb/ChangeLog:\n\n\t* dwarf2/read.h (struct dwarf2_cu): Forward-declare.\n\t(struct dwarf2_per_bfd) <free_cached_comp_units>: Remove,\n\tmove to dwarf2_per_objfile.\n\t<read_in_chain>: Remove.\n\t(struct dwarf2_per_objfile) <get_cu, set_cu, remove_cu,\n\tremove_all_cus, age_comp_units>: New methods.\n\t<m_dwarf2_cus>: New member.\n\t(struct dwarf2_per_cu_data) <cu>: Remove.\n\t* dwarf2/read.c (struct dwarf2_cu) <read_in_chain>: Remove.\n\t(age_cached_comp_units, free_one_cached_comp_unit): Remove,\n\tmoved to methods of dwarf2_per_objfile.\n\t(dwarf2_clear_marks): Remove.\n\t(dwarf2_queue_item::~dwarf2_queue_item): Update.\n\t(dwarf2_per_bfd::~dwarf2_per_bfd): Don't free dwarf2_cus.\n\t(dwarf2_per_bfd::free_cached_comp_units): Remove.\n\t(dwarf2_per_objfile::remove_all_cus): New.\n\t(class free_cached_comp_units) <~free_cached_comp_units>:\n\tUpdate.\n\t(load_cu): Update.\n\t(dw2_do_instantiate_symtab): Adjust.\n\t(fill_in_sig_entry_from_dwo_entry): Adjust.\n\t(cutu_reader::init_tu_and_read_dwo_dies): Update.\n\t(cutu_reader::cutu_reader): Likewise.\n\t(cutu_reader::keep): Use dwarf2_per_objfile::set_cu.\n\t(cutu_reader::cutu_reader): Use dwarf2_per_objfile::get_cu.\n\t(process_psymtab_comp_unit): Use dwarf2_per_objfile::remove_cu\n\tand dwarf2_per_objfile::age_comp_units.\n\t(load_partial_comp_unit): Update.\n\t(maybe_queue_comp_unit): Use dwarf2_per_objfile::get_cu.\n\t(process_queue): Likewise.\n\t(find_partial_die): Use dwarf2_per_objfile::get_cu instead of cu\n\tbacklink.\n\t(dwarf2_read_addr_index): Likewise.\n\t(follow_die_offset): Likewise.\n\t(dwarf2_fetch_die_loc_sect_off): Likewise.\n\t(dwarf2_fetch_constant_bytes): Likewise.\n\t(dwarf2_fetch_die_type_sect_off): Likewise.\n\t(follow_die_sig_1): Likewise.\n\t(load_full_type_unit): Likewise.\n\t(read_signatured_type): Likewise.\n\t(dwarf2_cu::dwarf2_cu): Don't set cu field.\n\t(dwarf2_cu::~dwarf2_cu): Remove.\n\t(dwarf2_per_objfile::get_cu): New.\n\t(dwarf2_per_objfile::set_cu): New.\n\t(age_cached_comp_units): Rename to...\n\t(dwarf2_per_objfile::age_comp_units): ... this.  Adjust\n\tto std::unordered_map.\n\t(free_one_cached_comp_unit): Rename to...\n\t(dwarf2_per_objfile::remove_cu): ... this.  Adjust\n\tto std::unordered_map.\n\t(dwarf2_per_objfile::~dwarf2_per_objfile): New.\n\t(dwarf2_mark_helper): Use dwarf2_per_objfile::get_cu, expect\n\ta dwarf2_per_objfile in data.\n\t(dwarf2_mark): Pass dwarf2_per_objfile in data to htab_traverse.\n\t(dwarf2_clear_marks): Remove.\n\nChange-Id: Ia33ac71c79b2de4710569008e22a6563a1505cde",
    "tree": {
      "sha": "d64be5c681d6df6995b6abef81918787da9d3373",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d64be5c681d6df6995b6abef81918787da9d3373"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7188ed02d2a7e3fce00a0214e70457c5ef56df6b/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2e6711003b8c69abe25100a7b2630409a4aafb8d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2e6711003b8c69abe25100a7b2630409a4aafb8d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2e6711003b8c69abe25100a7b2630409a4aafb8d"
    }
  ],
  "stats": {
    "total": 448,
    "additions": 247,
    "deletions": 201
  },
  "files": [
    {
      "sha": "990844b3959ac8e12ff88f5c04cfce1efbee040d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 58,
      "deletions": 0,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7188ed02d2a7e3fce00a0214e70457c5ef56df6b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7188ed02d2a7e3fce00a0214e70457c5ef56df6b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
      "patch": "@@ -1,3 +1,61 @@\n+2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* dwarf2/read.h (struct dwarf2_cu): Forward-declare.\n+\t(struct dwarf2_per_bfd) <free_cached_comp_units>: Remove,\n+\tmove to dwarf2_per_objfile.\n+\t<read_in_chain>: Remove.\n+\t(struct dwarf2_per_objfile) <get_cu, set_cu, remove_cu,\n+\tremove_all_cus, age_comp_units>: New methods.\n+\t<m_dwarf2_cus>: New member.\n+\t(struct dwarf2_per_cu_data) <cu>: Remove.\n+\t* dwarf2/read.c (struct dwarf2_cu) <read_in_chain>: Remove.\n+\t(age_cached_comp_units, free_one_cached_comp_unit): Remove,\n+\tmoved to methods of dwarf2_per_objfile.\n+\t(dwarf2_clear_marks): Remove.\n+\t(dwarf2_queue_item::~dwarf2_queue_item): Update.\n+\t(dwarf2_per_bfd::~dwarf2_per_bfd): Don't free dwarf2_cus.\n+\t(dwarf2_per_bfd::free_cached_comp_units): Remove.\n+\t(dwarf2_per_objfile::remove_all_cus): New.\n+\t(class free_cached_comp_units) <~free_cached_comp_units>:\n+\tUpdate.\n+\t(load_cu): Update.\n+\t(dw2_do_instantiate_symtab): Adjust.\n+\t(fill_in_sig_entry_from_dwo_entry): Adjust.\n+\t(cutu_reader::init_tu_and_read_dwo_dies): Update.\n+\t(cutu_reader::cutu_reader): Likewise.\n+\t(cutu_reader::keep): Use dwarf2_per_objfile::set_cu.\n+\t(cutu_reader::cutu_reader): Use dwarf2_per_objfile::get_cu.\n+\t(process_psymtab_comp_unit): Use dwarf2_per_objfile::remove_cu\n+\tand dwarf2_per_objfile::age_comp_units.\n+\t(load_partial_comp_unit): Update.\n+\t(maybe_queue_comp_unit): Use dwarf2_per_objfile::get_cu.\n+\t(process_queue): Likewise.\n+\t(find_partial_die): Use dwarf2_per_objfile::get_cu instead of cu\n+\tbacklink.\n+\t(dwarf2_read_addr_index): Likewise.\n+\t(follow_die_offset): Likewise.\n+\t(dwarf2_fetch_die_loc_sect_off): Likewise.\n+\t(dwarf2_fetch_constant_bytes): Likewise.\n+\t(dwarf2_fetch_die_type_sect_off): Likewise.\n+\t(follow_die_sig_1): Likewise.\n+\t(load_full_type_unit): Likewise.\n+\t(read_signatured_type): Likewise.\n+\t(dwarf2_cu::dwarf2_cu): Don't set cu field.\n+\t(dwarf2_cu::~dwarf2_cu): Remove.\n+\t(dwarf2_per_objfile::get_cu): New.\n+\t(dwarf2_per_objfile::set_cu): New.\n+\t(age_cached_comp_units): Rename to...\n+\t(dwarf2_per_objfile::age_comp_units): ... this.  Adjust\n+\tto std::unordered_map.\n+\t(free_one_cached_comp_unit): Rename to...\n+\t(dwarf2_per_objfile::remove_cu): ... this.  Adjust\n+\tto std::unordered_map.\n+\t(dwarf2_per_objfile::~dwarf2_per_objfile): New.\n+\t(dwarf2_mark_helper): Use dwarf2_per_objfile::get_cu, expect\n+\ta dwarf2_per_objfile in data.\n+\t(dwarf2_mark): Pass dwarf2_per_objfile in data to htab_traverse.\n+\t(dwarf2_clear_marks): Remove.\n+\n 2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* dwarf2/read.c (class cutu_reader) <cutu_reader>: Replace"
    },
    {
      "sha": "6319d4b2859c79b67449681f65a6c7f4e3c3b173",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 166,
      "deletions": 189,
      "changes": 355,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7188ed02d2a7e3fce00a0214e70457c5ef56df6b/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7188ed02d2a7e3fce00a0214e70457c5ef56df6b/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
      "patch": "@@ -401,7 +401,6 @@ struct dwarf2_cu\n {\n   explicit dwarf2_cu (dwarf2_per_cu_data *per_cu,\n \t\t      dwarf2_per_objfile *per_objfile);\n-  ~dwarf2_cu ();\n \n   DISABLE_COPY_AND_ASSIGN (dwarf2_cu);\n \n@@ -468,12 +467,6 @@ struct dwarf2_cu\n      unit, including partial DIEs.  */\n   auto_obstack comp_unit_obstack;\n \n-  /* When multiple dwarf2_cu structures are living in memory, this field\n-     chains them all together, so that they can be released efficiently.\n-     We will probably also want a generation counter so that most-recently-used\n-     compilation units are cached...  */\n-  struct dwarf2_per_cu_data *read_in_chain = nullptr;\n-\n   /* Backlink to our per_cu entry.  */\n   struct dwarf2_per_cu_data *per_cu;\n \n@@ -1553,11 +1546,6 @@ static void prepare_one_comp_unit (struct dwarf2_cu *cu,\n \t\t\t\t   struct die_info *comp_unit_die,\n \t\t\t\t   enum language pretend_language);\n \n-static void age_cached_comp_units (struct dwarf2_per_objfile *dwarf2_per_objfile);\n-\n-static void free_one_cached_comp_unit (dwarf2_per_cu_data *target_per_cu,\n-\t\t\t\t       dwarf2_per_objfile *per_objfile);\n-\n static struct type *set_die_type (struct die_info *, struct type *,\n \t\t\t\t  struct dwarf2_cu *);\n \n@@ -1581,8 +1569,6 @@ static void dwarf2_add_dependence (struct dwarf2_cu *,\n \n static void dwarf2_mark (struct dwarf2_cu *);\n \n-static void dwarf2_clear_marks (struct dwarf2_per_cu_data *);\n-\n static struct type *get_die_type_at_offset (sect_offset,\n \t\t\t\t\t    dwarf2_per_cu_data *per_cu,\n \t\t\t\t\t    dwarf2_per_objfile *per_objfile);\n@@ -1629,8 +1615,7 @@ dwarf2_queue_item::~dwarf2_queue_item ()\n      inconsistent state, so discard it.  */\n   if (per_cu->queued)\n     {\n-      if (per_cu->cu != NULL)\n-\tfree_one_cached_comp_unit (per_cu, per_objfile);\n+      per_objfile->remove_cu (per_cu);\n       per_cu->queued = 0;\n     }\n }\n@@ -1772,9 +1757,6 @@ dwarf2_per_bfd::dwarf2_per_bfd (bfd *obfd, const dwarf2_debug_sections *names,\n \n dwarf2_per_bfd::~dwarf2_per_bfd ()\n {\n-  /* Cached DIE trees use xmalloc and the comp_unit_obstack.  */\n-  free_cached_comp_units ();\n-\n   for (dwarf2_per_cu_data *per_cu : all_comp_units)\n     per_cu->imported_symtabs_free ();\n \n@@ -1784,21 +1766,15 @@ dwarf2_per_bfd::~dwarf2_per_bfd ()\n   /* Everything else should be on this->obstack.  */\n }\n \n-/* See declaration.  */\n+/* See read.h.  */\n \n void\n-dwarf2_per_bfd::free_cached_comp_units ()\n+dwarf2_per_objfile::remove_all_cus ()\n {\n-  dwarf2_per_cu_data *per_cu = read_in_chain;\n-  dwarf2_per_cu_data **last_chain = &read_in_chain;\n-  while (per_cu != NULL)\n-    {\n-      dwarf2_per_cu_data *next_cu = per_cu->cu->read_in_chain;\n+  for (auto pair : m_dwarf2_cus)\n+    delete pair.second;\n \n-      delete per_cu->cu;\n-      *last_chain = next_cu;\n-      per_cu = next_cu;\n-    }\n+  m_dwarf2_cus.clear ();\n }\n \n /* A helper class that calls free_cached_comp_units on\n@@ -1815,7 +1791,7 @@ class free_cached_comp_units\n \n   ~free_cached_comp_units ()\n   {\n-    m_per_objfile->per_bfd->free_cached_comp_units ();\n+    m_per_objfile->remove_all_cus ();\n   }\n \n   DISABLE_COPY_AND_ASSIGN (free_cached_comp_units);\n@@ -2344,12 +2320,13 @@ load_cu (dwarf2_per_cu_data *per_cu, dwarf2_per_objfile *per_objfile,\n   else\n     load_full_comp_unit (per_cu, per_objfile, skip_partial, language_minimal);\n \n-  if (per_cu->cu == nullptr)\n+  dwarf2_cu *cu = per_objfile->get_cu (per_cu);\n+  if (cu == nullptr)\n     return nullptr;  /* Dummy CU.  */\n \n-  dwarf2_find_base_address (per_cu->cu->dies, per_cu->cu);\n+  dwarf2_find_base_address (cu->dies, cu);\n \n-  return per_cu->cu;\n+  return cu;\n }\n \n /* Read in the symbols for PER_CU in the context of DWARF\"_PER_OBJFILE.  */\n@@ -2391,7 +2368,7 @@ dw2_do_instantiate_symtab (dwarf2_per_cu_data *per_cu,\n \n   /* Age the cache, releasing compilation units that have not\n      been used recently.  */\n-  age_cached_comp_units (dwarf2_per_objfile);\n+  dwarf2_per_objfile->age_comp_units ();\n }\n \n /* Ensure that the symbols for PER_CU have been read in.  DWARF2_PER_OBJFILE is\n@@ -6465,7 +6442,7 @@ fill_in_sig_entry_from_dwo_entry (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   /* Make sure we're not clobbering something we don't expect to.  */\n   gdb_assert (! sig_entry->per_cu.queued);\n-  gdb_assert (sig_entry->per_cu.cu == NULL);\n+  gdb_assert (dwarf2_per_objfile->get_cu (&sig_entry->per_cu) == NULL);\n   if (per_bfd->using_index)\n     {\n       gdb_assert (sig_entry->per_cu.v.quick != NULL);\n@@ -6923,8 +6900,9 @@ cutu_reader::init_tu_and_read_dwo_dies (dwarf2_per_cu_data *this_cu,\n     }\n   else\n     {\n-      /* If an existing_cu is provided, this_cu->cu must be NULL.  */\n-      gdb_assert (this_cu->cu == NULL);\n+      /* If an existing_cu is provided, a dwarf2_cu must not exist for this_cu\n+         in per_objfile yet.  */\n+      gdb_assert (per_objfile->get_cu (this_cu) == nullptr);\n       m_new_cu.reset (new dwarf2_cu (this_cu, per_objfile));\n       cu = m_new_cu.get ();\n     }\n@@ -7013,8 +6991,9 @@ cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n     }\n   else\n     {\n-      /* If an existing_cu is provided, this_cu->cu must be NULL.  */\n-      gdb_assert (this_cu->cu == NULL);\n+      /* If an existing_cu is provided, a dwarf2_cu must not exist for this_cu\n+         in per_objfile yet.  */\n+      gdb_assert (dwarf2_per_objfile->get_cu (this_cu) == nullptr);\n       m_new_cu.reset (new dwarf2_cu (this_cu, dwarf2_per_objfile));\n       cu = m_new_cu.get ();\n     }\n@@ -7154,16 +7133,10 @@ cutu_reader::keep ()\n   gdb_assert (!dummy_p);\n   if (m_new_cu != NULL)\n     {\n-      /* We know that m_this_cu->cu is set, since we are in the process of\n-         parsing the CU.  */\n-      gdb_assert (m_this_cu->cu != nullptr);\n-      dwarf2_per_objfile *dwarf2_per_objfile = m_this_cu->cu->per_objfile;\n-\n-      /* Link this CU into read_in_chain.  */\n-      m_this_cu->cu->read_in_chain = dwarf2_per_objfile->per_bfd->read_in_chain;\n-      dwarf2_per_objfile->per_bfd->read_in_chain = m_this_cu;\n-      /* The chain owns it now.  */\n-      m_new_cu.release ();\n+      /* Save this dwarf2_cu in the per_objfile.  The per_objfile owns it\n+         now.  */\n+      dwarf2_per_objfile *per_objfile = m_new_cu->per_objfile;\n+      per_objfile->set_cu (m_this_cu, m_new_cu.release ());\n     }\n }\n \n@@ -7201,7 +7174,7 @@ cutu_reader::cutu_reader (dwarf2_per_cu_data *this_cu,\n \t\t\tthis_cu->is_debug_types ? \"type\" : \"comp\",\n \t\t\tsect_offset_str (this_cu->sect_off));\n \n-  gdb_assert (this_cu->cu == NULL);\n+  gdb_assert (dwarf2_per_objfile->get_cu (this_cu) == nullptr);\n \n   abbrev_section = (dwo_file != NULL\n \t\t    ? &dwo_file->sections.abbrev\n@@ -7563,8 +7536,7 @@ process_psymtab_comp_unit (dwarf2_per_cu_data *this_cu,\n      necessary because we skipped some symbols when we first\n      read in the compilation unit (see load_partial_dies).\n      This problem could be avoided, but the benefit is unclear.  */\n-  if (this_cu->cu != NULL)\n-    free_one_cached_comp_unit (this_cu, per_objfile);\n+  per_objfile->remove_cu (this_cu);\n \n   cutu_reader reader (this_cu, per_objfile, nullptr, nullptr, false);\n \n@@ -7593,10 +7565,10 @@ process_psymtab_comp_unit (dwarf2_per_cu_data *this_cu,\n \t\t\t\t      reader.comp_unit_die,\n \t\t\t\t      pretend_language);\n \n-  this_cu->lang = this_cu->cu->language;\n+  this_cu->lang = reader.cu->language;\n \n   /* Age out any secondary CUs.  */\n-  age_cached_comp_units (per_objfile);\n+  per_objfile->age_comp_units ();\n }\n \n /* Reader function for build_type_psymtabs.  */\n@@ -8951,7 +8923,9 @@ maybe_queue_comp_unit (struct dwarf2_cu *dependent_cu,\n      not queue PER_CU, just tell our caller to load its DIEs.  */\n   if (per_cu->per_bfd->reading_partial_symbols)\n     {\n-      if (per_cu->cu == NULL || per_cu->cu->dies == NULL)\n+      dwarf2_cu *cu = per_objfile->get_cu (per_cu);\n+\n+      if (cu == NULL || cu->dies == NULL)\n \treturn 1;\n       return 0;\n     }\n@@ -8967,9 +8941,10 @@ maybe_queue_comp_unit (struct dwarf2_cu *dependent_cu,\n \n   /* If the compilation unit is already loaded, just mark it as\n      used.  */\n-  if (per_cu->cu != NULL)\n+  dwarf2_cu *cu = per_objfile->get_cu (per_cu);\n+  if (cu != nullptr)\n     {\n-      per_cu->cu->last_used = 0;\n+      cu->last_used = 0;\n       return 0;\n     }\n \n@@ -8996,47 +8971,51 @@ process_queue (struct dwarf2_per_objfile *dwarf2_per_objfile)\n   while (!dwarf2_per_objfile->per_bfd->queue.empty ())\n     {\n       dwarf2_queue_item &item = dwarf2_per_objfile->per_bfd->queue.front ();\n+      dwarf2_per_cu_data *per_cu = item.per_cu;\n \n-      if (!dwarf2_per_objfile->symtab_set_p (item.per_cu)\n-\t  /* Skip dummy CUs.  */\n-\t  && item.per_cu->cu != NULL)\n+      if (!dwarf2_per_objfile->symtab_set_p (per_cu))\n \t{\n-\t  struct dwarf2_per_cu_data *per_cu = item.per_cu;\n-\t  unsigned int debug_print_threshold;\n-\t  char buf[100];\n+\t  dwarf2_cu *cu = dwarf2_per_objfile->get_cu (per_cu);\n \n-\t  if (per_cu->is_debug_types)\n-\t    {\n-\t      struct signatured_type *sig_type =\n-\t\t(struct signatured_type *) per_cu;\n-\n-\t      sprintf (buf, \"TU %s at offset %s\",\n-\t\t       hex_string (sig_type->signature),\n-\t\t       sect_offset_str (per_cu->sect_off));\n-\t      /* There can be 100s of TUs.\n-\t\t Only print them in verbose mode.  */\n-\t      debug_print_threshold = 2;\n-\t    }\n-\t  else\n+\t  /* Skip dummy CUs.  */\n+\t  if (cu != nullptr)\n \t    {\n-\t      sprintf (buf, \"CU at offset %s\",\n-\t\t       sect_offset_str (per_cu->sect_off));\n-\t      debug_print_threshold = 1;\n-\t    }\n+\t      unsigned int debug_print_threshold;\n+\t      char buf[100];\n+\n+\t      if (per_cu->is_debug_types)\n+\t\t{\n+\t\t  struct signatured_type *sig_type =\n+\t\t    (struct signatured_type *) per_cu;\n+\n+\t\t  sprintf (buf, \"TU %s at offset %s\",\n+\t\t\t   hex_string (sig_type->signature),\n+\t\t\t   sect_offset_str (per_cu->sect_off));\n+\t\t  /* There can be 100s of TUs.\n+\t\t     Only print them in verbose mode.  */\n+\t\t  debug_print_threshold = 2;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  sprintf (buf, \"CU at offset %s\",\n+\t\t\t   sect_offset_str (per_cu->sect_off));\n+\t\t  debug_print_threshold = 1;\n+\t\t}\n \n-\t  if (dwarf_read_debug >= debug_print_threshold)\n-\t    fprintf_unfiltered (gdb_stdlog, \"Expanding symtab of %s\\n\", buf);\n+\t      if (dwarf_read_debug >= debug_print_threshold)\n+\t\tfprintf_unfiltered (gdb_stdlog, \"Expanding symtab of %s\\n\", buf);\n \n-\t  if (per_cu->is_debug_types)\n-\t    process_full_type_unit (per_cu->cu, item.pretend_language);\n-\t  else\n-\t    process_full_comp_unit (per_cu->cu, item.pretend_language);\n+\t      if (per_cu->is_debug_types)\n+\t\tprocess_full_type_unit (cu, item.pretend_language);\n+\t      else\n+\t\tprocess_full_comp_unit (cu, item.pretend_language);\n \n-\t  if (dwarf_read_debug >= debug_print_threshold)\n-\t    fprintf_unfiltered (gdb_stdlog, \"Done expanding %s\\n\", buf);\n+\t      if (dwarf_read_debug >= debug_print_threshold)\n+\t\tfprintf_unfiltered (gdb_stdlog, \"Done expanding %s\\n\", buf);\n+\t    }\n \t}\n \n-      item.per_cu->queued = 0;\n+      per_cu->queued = 0;\n       dwarf2_per_objfile->per_bfd->queue.pop ();\n     }\n \n@@ -9112,7 +9091,8 @@ load_full_comp_unit (dwarf2_per_cu_data *this_cu,\n {\n   gdb_assert (! this_cu->is_debug_types);\n \n-  cutu_reader reader (this_cu, per_objfile, NULL, this_cu->cu, skip_partial);\n+  dwarf2_cu *existing_cu = per_objfile->get_cu (this_cu);\n+  cutu_reader reader (this_cu, per_objfile, NULL, existing_cu, skip_partial);\n   if (reader.dummy_p)\n     return;\n \n@@ -18693,7 +18673,6 @@ find_partial_die (sect_offset sect_off, int offset_in_dwz, struct dwarf2_cu *cu)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile = cu->per_objfile;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n-  struct dwarf2_per_cu_data *per_cu = NULL;\n   struct partial_die_info *pd = NULL;\n \n   if (offset_in_dwz == cu->per_cu->is_dwz\n@@ -18704,7 +18683,6 @@ find_partial_die (sect_offset sect_off, int offset_in_dwz, struct dwarf2_cu *cu)\n \treturn { cu, pd };\n       /* We missed recording what we needed.\n \t Load all dies and try again.  */\n-      per_cu = cu->per_cu;\n     }\n   else\n     {\n@@ -18716,40 +18694,44 @@ find_partial_die (sect_offset sect_off, int offset_in_dwz, struct dwarf2_cu *cu)\n \t\t sect_offset_str (cu->header.sect_off), sect_offset_str (sect_off),\n \t\t bfd_get_filename (objfile->obfd));\n \t}\n-      per_cu = dwarf2_find_containing_comp_unit (sect_off, offset_in_dwz,\n-\t\t\t\t\t\t dwarf2_per_objfile);\n+      dwarf2_per_cu_data *per_cu\n+\t= dwarf2_find_containing_comp_unit (sect_off, offset_in_dwz,\n+\t\t\t\t\t    dwarf2_per_objfile);\n \n-      if (per_cu->cu == NULL || per_cu->cu->partial_dies == NULL)\n-\tload_partial_comp_unit (per_cu, cu->per_objfile, nullptr);\n+      cu = dwarf2_per_objfile->get_cu (per_cu);\n+      if (cu == NULL || cu->partial_dies == NULL)\n+\tload_partial_comp_unit (per_cu, dwarf2_per_objfile, nullptr);\n \n-      per_cu->cu->last_used = 0;\n-      pd = per_cu->cu->find_partial_die (sect_off);\n+      cu = dwarf2_per_objfile->get_cu (per_cu);\n+\n+      cu->last_used = 0;\n+      pd = cu->find_partial_die (sect_off);\n     }\n \n   /* If we didn't find it, and not all dies have been loaded,\n      load them all and try again.  */\n \n-  if (pd == NULL && per_cu->load_all_dies == 0)\n+  if (pd == NULL && cu->per_cu->load_all_dies == 0)\n     {\n-      per_cu->load_all_dies = 1;\n+      cu->per_cu->load_all_dies = 1;\n \n       /* This is nasty.  When we reread the DIEs, somewhere up the call chain\n \t THIS_CU->cu may already be in use.  So we can't just free it and\n \t replace its DIEs with the ones we read in.  Instead, we leave those\n \t DIEs alone (which can still be in use, e.g. in scan_partial_symbols),\n \t and clobber THIS_CU->cu->partial_dies with the hash table for the new\n \t set.  */\n-      load_partial_comp_unit (per_cu, cu->per_objfile, cu);\n+      load_partial_comp_unit (cu->per_cu, dwarf2_per_objfile, cu);\n \n-      pd = per_cu->cu->find_partial_die (sect_off);\n+      pd = cu->find_partial_die (sect_off);\n     }\n \n   if (pd == NULL)\n     internal_error (__FILE__, __LINE__,\n \t\t    _(\"could not find partial DIE %s \"\n \t\t      \"in cache [from module %s]\\n\"),\n \t\t    sect_offset_str (sect_off), bfd_get_filename (objfile->obfd));\n-  return { per_cu->cu, pd };\n+  return { cu, pd };\n }\n \n /* See if we can figure out if the class lives in a namespace.  We do\n@@ -19429,7 +19411,7 @@ dwarf2_read_addr_index (dwarf2_per_cu_data *per_cu,\n \t\t\tdwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\tunsigned int addr_index)\n {\n-  struct dwarf2_cu *cu = per_cu->cu;\n+  struct dwarf2_cu *cu = dwarf2_per_objfile->get_cu (per_cu);\n   gdb::optional<ULONGEST> addr_base;\n   int addr_size;\n \n@@ -22270,7 +22252,7 @@ follow_die_offset (sect_offset sect_off, int offset_in_dwz,\n       if (maybe_queue_comp_unit (cu, per_cu, dwarf2_per_objfile, cu->language))\n \tload_full_comp_unit (per_cu, dwarf2_per_objfile, false, cu->language);\n \n-      target_cu = per_cu->cu;\n+      target_cu = dwarf2_per_objfile->get_cu (per_cu);\n     }\n   else if (cu->dies == NULL)\n     {\n@@ -22330,7 +22312,7 @@ dwarf2_fetch_die_loc_sect_off (sect_offset sect_off,\n   struct dwarf2_locexpr_baton retval;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n \n-  dwarf2_cu *cu = per_cu->cu;\n+  dwarf2_cu *cu = dwarf2_per_objfile->get_cu (per_cu);\n   if (cu == nullptr)\n     cu = load_cu (per_cu, dwarf2_per_objfile, false);\n \n@@ -22415,7 +22397,7 @@ dwarf2_fetch_die_loc_sect_off (sect_offset sect_off,\n   retval.per_objfile = dwarf2_per_objfile;\n   retval.per_cu = cu->per_cu;\n \n-  age_cached_comp_units (dwarf2_per_objfile);\n+  dwarf2_per_objfile->age_comp_units ();\n \n   return retval;\n }\n@@ -22471,7 +22453,7 @@ dwarf2_fetch_constant_bytes (sect_offset sect_off,\n   enum bfd_endian byte_order;\n   struct objfile *objfile = per_objfile->objfile;\n \n-  dwarf2_cu *cu = per_cu->cu;\n+  dwarf2_cu *cu = per_objfile->get_cu (per_cu);\n   if (cu == nullptr)\n     cu = load_cu (per_cu, per_objfile, false);\n \n@@ -22594,7 +22576,7 @@ dwarf2_fetch_die_type_sect_off (sect_offset sect_off,\n {\n   struct die_info *die;\n \n-  dwarf2_cu *cu = per_cu->cu;\n+  dwarf2_cu *cu = per_objfile->get_cu (per_cu);\n   if (cu == nullptr)\n     cu = load_cu (per_cu, per_objfile, false);\n \n@@ -22644,7 +22626,7 @@ follow_die_sig_1 (struct die_info *src_die, struct signatured_type *sig_type,\n \t\t\t     language_minimal))\n     read_signatured_type (sig_type, dwarf2_per_objfile);\n \n-  sig_cu = sig_type->per_cu.cu;\n+  sig_cu = dwarf2_per_objfile->get_cu (&sig_type->per_cu);\n   gdb_assert (sig_cu != NULL);\n   gdb_assert (to_underlying (sig_type->type_offset_in_section) != 0);\n   temp_die.sect_off = sig_type->type_offset_in_section;\n@@ -22818,11 +22800,11 @@ load_full_type_unit (dwarf2_per_cu_data *per_cu,\n   gdb_assert (per_cu->is_debug_types);\n   sig_type = (struct signatured_type *) per_cu;\n \n-  gdb_assert (per_cu->cu == NULL);\n+  gdb_assert (per_objfile->get_cu (per_cu) == nullptr);\n \n   read_signatured_type (sig_type, per_objfile);\n \n-  gdb_assert (per_cu->cu != NULL);\n+  gdb_assert (per_objfile->get_cu (per_cu) != nullptr);\n }\n \n /* Read in a signatured type and build its CU and DIEs.\n@@ -22836,7 +22818,7 @@ read_signatured_type (signatured_type *sig_type,\n   struct dwarf2_per_cu_data *per_cu = &sig_type->per_cu;\n \n   gdb_assert (per_cu->is_debug_types);\n-  gdb_assert (per_cu->cu == NULL);\n+  gdb_assert (per_objfile->get_cu (per_cu) == nullptr);\n \n   cutu_reader reader (per_cu, per_objfile, nullptr, nullptr, false);\n \n@@ -23543,14 +23525,6 @@ dwarf2_cu::dwarf2_cu (dwarf2_per_cu_data *per_cu,\n     producer_is_codewarrior (false),\n     processing_has_namespace_info (false)\n {\n-  per_cu->cu = this;\n-}\n-\n-/* Destroy a dwarf2_cu.  */\n-\n-dwarf2_cu::~dwarf2_cu ()\n-{\n-  per_cu->cu = NULL;\n }\n \n /* Initialize basic fields of dwarf_cu CU according to DIE COMP_UNIT_DIE.  */\n@@ -23574,72 +23548,80 @@ prepare_one_comp_unit (struct dwarf2_cu *cu, struct die_info *comp_unit_die,\n   cu->producer = dwarf2_string_attr (comp_unit_die, DW_AT_producer, cu);\n }\n \n-/* Increase the age counter on each cached compilation unit, and free\n-   any that are too old.  */\n+/* See read.h.  */\n \n-static void\n-age_cached_comp_units (struct dwarf2_per_objfile *dwarf2_per_objfile)\n+dwarf2_cu *\n+dwarf2_per_objfile::get_cu (dwarf2_per_cu_data *per_cu)\n {\n-  struct dwarf2_per_cu_data *per_cu, **last_chain;\n+  auto it = m_dwarf2_cus.find (per_cu);\n+  if (it == m_dwarf2_cus.end ())\n+    return nullptr;\n \n-  dwarf2_clear_marks (dwarf2_per_objfile->per_bfd->read_in_chain);\n-  per_cu = dwarf2_per_objfile->per_bfd->read_in_chain;\n-  while (per_cu != NULL)\n+  return it->second;\n+}\n+\n+/* See read.h.  */\n+\n+void\n+dwarf2_per_objfile::set_cu (dwarf2_per_cu_data *per_cu, dwarf2_cu *cu)\n+{\n+  gdb_assert (this->get_cu (per_cu) == nullptr);\n+\n+  m_dwarf2_cus[per_cu] = cu;\n+}\n+\n+/* See read.h.  */\n+\n+void\n+dwarf2_per_objfile::age_comp_units ()\n+{\n+  /* Start by clearing all marks.  */\n+  for (auto pair : m_dwarf2_cus)\n+    pair.second->mark = false;\n+\n+  /* Traverse all CUs, mark them and their dependencies if used recently\n+     enough.  */\n+  for (auto pair : m_dwarf2_cus)\n     {\n-      per_cu->cu->last_used ++;\n-      if (per_cu->cu->last_used <= dwarf_max_cache_age)\n-\tdwarf2_mark (per_cu->cu);\n-      per_cu = per_cu->cu->read_in_chain;\n+      dwarf2_cu *cu = pair.second;\n+\n+      cu->last_used++;\n+      if (cu->last_used <= dwarf_max_cache_age)\n+\tdwarf2_mark (cu);\n     }\n \n-  per_cu = dwarf2_per_objfile->per_bfd->read_in_chain;\n-  last_chain = &dwarf2_per_objfile->per_bfd->read_in_chain;\n-  while (per_cu != NULL)\n+  /* Delete all CUs still not marked.  */\n+  for (auto it = m_dwarf2_cus.begin (); it != m_dwarf2_cus.end ();)\n     {\n-      struct dwarf2_per_cu_data *next_cu;\n+      dwarf2_cu *cu = it->second;\n \n-      next_cu = per_cu->cu->read_in_chain;\n-\n-      if (!per_cu->cu->mark)\n+      if (!cu->mark)\n \t{\n-\t  delete per_cu->cu;\n-\t  *last_chain = next_cu;\n+\t  delete cu;\n+\t  it = m_dwarf2_cus.erase (it);\n \t}\n       else\n-\tlast_chain = &per_cu->cu->read_in_chain;\n-\n-      per_cu = next_cu;\n+\tit++;\n     }\n }\n \n-/* Remove a single compilation unit from the cache.  */\n+/* See read.h.  */\n \n-static void\n-free_one_cached_comp_unit (dwarf2_per_cu_data *target_per_cu,\n-\t\t\t   dwarf2_per_objfile *dwarf2_per_objfile)\n+void\n+dwarf2_per_objfile::remove_cu (dwarf2_per_cu_data *per_cu)\n {\n-  struct dwarf2_per_cu_data *per_cu, **last_chain;\n-\n-  per_cu = dwarf2_per_objfile->per_bfd->read_in_chain;\n-  last_chain = &dwarf2_per_objfile->per_bfd->read_in_chain;\n-  while (per_cu != NULL)\n-    {\n-      struct dwarf2_per_cu_data *next_cu;\n+  auto it = m_dwarf2_cus.find (per_cu);\n+  if (it == m_dwarf2_cus.end ())\n+    return;\n \n-      next_cu = per_cu->cu->read_in_chain;\n+  delete it->second;\n \n-      if (per_cu == target_per_cu)\n-\t{\n-\t  delete per_cu->cu;\n-\t  per_cu->cu = NULL;\n-\t  *last_chain = next_cu;\n-\t  break;\n-\t}\n-      else\n-\tlast_chain = &per_cu->cu->read_in_chain;\n+  m_dwarf2_cus.erase (it);\n+}\n \n-      per_cu = next_cu;\n-    }\n+dwarf2_per_objfile::~dwarf2_per_objfile ()\n+{\n+  remove_all_cus ();\n }\n \n /* A set of CU \"per_cu\" pointer, DIE offset, and GDB type pointer.\n@@ -23841,27 +23823,30 @@ dwarf2_add_dependence (struct dwarf2_cu *cu,\n \n /* Subroutine of dwarf2_mark to pass to htab_traverse.\n    Set the mark field in every compilation unit in the\n-   cache that we must keep because we are keeping CU.  */\n+   cache that we must keep because we are keeping CU.\n+\n+   DATA is the dwarf2_per_objfile object in which to look up CUs.  */\n \n static int\n dwarf2_mark_helper (void **slot, void *data)\n {\n-  struct dwarf2_per_cu_data *per_cu;\n-\n-  per_cu = (struct dwarf2_per_cu_data *) *slot;\n+  dwarf2_per_cu_data *per_cu = (dwarf2_per_cu_data *) *slot;\n+  dwarf2_per_objfile *per_objfile = (dwarf2_per_objfile *) data;\n+  dwarf2_cu *cu = per_objfile->get_cu (per_cu);\n \n   /* cu->dependencies references may not yet have been ever read if QUIT aborts\n      reading of the chain.  As such dependencies remain valid it is not much\n      useful to track and undo them during QUIT cleanups.  */\n-  if (per_cu->cu == NULL)\n+  if (cu == nullptr)\n     return 1;\n \n-  if (per_cu->cu->mark)\n+  if (cu->mark)\n     return 1;\n-  per_cu->cu->mark = true;\n \n-  if (per_cu->cu->dependencies != NULL)\n-    htab_traverse (per_cu->cu->dependencies, dwarf2_mark_helper, NULL);\n+  cu->mark = true;\n+\n+  if (cu->dependencies != nullptr)\n+    htab_traverse (cu->dependencies, dwarf2_mark_helper, per_objfile);\n \n   return 1;\n }\n@@ -23874,19 +23859,11 @@ dwarf2_mark (struct dwarf2_cu *cu)\n {\n   if (cu->mark)\n     return;\n+\n   cu->mark = true;\n-  if (cu->dependencies != NULL)\n-    htab_traverse (cu->dependencies, dwarf2_mark_helper, NULL);\n-}\n \n-static void\n-dwarf2_clear_marks (struct dwarf2_per_cu_data *per_cu)\n-{\n-  while (per_cu)\n-    {\n-      per_cu->cu->mark = false;\n-      per_cu = per_cu->cu->read_in_chain;\n-    }\n+  if (cu->dependencies != nullptr)\n+    htab_traverse (cu->dependencies, dwarf2_mark_helper, cu->per_objfile);\n }\n \n /* Trivial hash function for partial_die_info: the hash value of a DIE"
    },
    {
      "sha": "996cf55af22b2f56f6000f833544bb337beefd5e",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 23,
      "deletions": 12,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7188ed02d2a7e3fce00a0214e70457c5ef56df6b/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7188ed02d2a7e3fce00a0214e70457c5ef56df6b/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
      "patch": "@@ -43,6 +43,7 @@ struct tu_stats\n   int nr_all_type_units_reallocs;\n };\n \n+struct dwarf2_cu;\n struct dwarf2_debug_sections;\n struct dwarf2_per_cu_data;\n struct mapped_index;\n@@ -115,9 +116,6 @@ struct dwarf2_per_bfd\n      TU.  */\n   signatured_type *get_tu (int index);\n \n-  /* Free all cached compilation units.  */\n-  void free_cached_comp_units ();\n-\n   /* A convenience function to allocate a dwarf2_per_cu_data.  The\n      returned object has its \"index\" field set properly.  The object\n      is allocated on the dwarf2_per_bfd obstack.  */\n@@ -189,10 +187,6 @@ struct dwarf2_per_bfd\n      are doing.  */\n   struct tu_stats tu_stats {};\n \n-  /* A chain of compilation units that are currently read in, so that\n-     they can be freed later.  */\n-  dwarf2_per_cu_data *read_in_chain = NULL;\n-\n   /* A table mapping DW_AT_dwo_name values to struct dwo_file objects.\n      This is NULL if the table hasn't been allocated yet.  */\n   htab_up dwo_files;\n@@ -303,6 +297,8 @@ struct dwarf2_per_objfile\n     : objfile (objfile), per_bfd (per_bfd)\n   {}\n \n+  ~dwarf2_per_objfile ();\n+\n   /* Return pointer to string at .debug_line_str offset as read from BUF.\n      BUF is assumed to be in a compilation unit described by CU_HEADER.\n      Return *BYTES_READ_PTR count of bytes read from BUF.  */\n@@ -344,6 +340,22 @@ struct dwarf2_per_objfile\n      UNSIGNED_P controls if the integer is unsigned or not.  */\n   struct type *int_type (int size_in_bytes, bool unsigned_p) const;\n \n+  /* Get the dwarf2_cu matching PER_CU for this objfile.  */\n+  dwarf2_cu *get_cu (dwarf2_per_cu_data *per_cu);\n+\n+  /* Set the dwarf2_cu matching PER_CU for this objfile.  */\n+  void set_cu (dwarf2_per_cu_data *per_cu, dwarf2_cu *cu);\n+\n+  /* Remove/free the dwarf2_cu matching PER_CU for this objfile.  */\n+  void remove_cu (dwarf2_per_cu_data *per_cu);\n+\n+  /* Free all cached compilation units.  */\n+  void remove_all_cus ();\n+\n+  /* Increase the age counter on each CU compilation unit and free\n+     any that are too old.  */\n+  void age_comp_units ();\n+\n   /* Back link.  */\n   struct objfile *objfile;\n \n@@ -372,6 +384,10 @@ struct dwarf2_per_objfile\n \n   /* Map from signatured types to the corresponding struct type.  */\n   std::unordered_map<signatured_type *, struct type *> m_type_map;\n+\n+  /* Map from the objfile-independent dwarf2_per_cu_data instances to the\n+     corresponding objfile-dependent dwarf2_cu instances.  */\n+  std::unordered_map<dwarf2_per_cu_data *, dwarf2_cu *> m_dwarf2_cus;\n };\n \n /* Get the dwarf2_per_objfile associated to OBJFILE.  */\n@@ -455,11 +471,6 @@ struct dwarf2_per_cu_data\n      not the DWO file.  */\n   struct dwarf2_section_info *section;\n \n-  /* Set to non-NULL iff this CU is currently loaded.  When it gets freed out\n-     of the CU cache it gets reset to NULL again.  This is left as NULL for\n-     dummy CUs (a CU header, but nothing else).  */\n-  struct dwarf2_cu *cu;\n-\n   /* The unit type of this CU.  */\n   enum dwarf_unit_type unit_type;\n "
    }
  ]
}