{
  "sha": "43892fdfa1aecb67d4830c47c9a40b0d74ed4c47",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDM4OTJmZGZhMWFlY2I2N2Q0ODMwYzQ3YzlhNDBiMGQ3NGVkNGM0Nw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:36Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T18:58:36Z"
    },
    "message": "gdb: add all_breakpoints function\n\nIntroduce the all_breakpoints function, which returns a range that can\nbe used to iterate on breakpoints.  Replace all uses of the\nALL_BREAKPOINTS macro with this.\n\nIn one instance, I could replace the breakpoint iteration with a call to\nget_breakpoint.\n\ngdb/ChangeLog:\n\n\t* breakpoint.c (ALL_BREAKPOINTS): Remove, replace all uses with\n\tall_breakpoints.\n\t(breakpoint_iterator): New.\n\t(breakpoint_range): New.\n\t(all_breakpoints): New.\n\nChange-Id: I229595bddad7c9100b179a9dd56b04b8c206e86c",
    "tree": {
      "sha": "b16c8c8ff8427ddc817d539da3c43b0e463eafd9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b16c8c8ff8427ddc817d539da3c43b0e463eafd9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bdef5723041368f3e264ac641360950c936b7ce4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bdef5723041368f3e264ac641360950c936b7ce4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bdef5723041368f3e264ac641360950c936b7ce4"
    }
  ],
  "stats": {
    "total": 197,
    "additions": 78,
    "deletions": 119
  },
  "files": [
    {
      "sha": "f80c8f4f36398d152156da5e95de448ac682ee7b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=43892fdfa1aecb67d4830c47c9a40b0d74ed4c47",
      "patch": "@@ -1,3 +1,11 @@\n+2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* breakpoint.c (ALL_BREAKPOINTS): Remove, replace all uses with\n+\tall_breakpoints.\n+\t(breakpoint_iterator): New.\n+\t(breakpoint_range): New.\n+\t(all_breakpoints): New.\n+\n 2021-05-27  Hannes Domani  <ssbssa@yahoo.de>\n \n \t* python/py-tui.c (tui_py_window::output): Add full_window"
    },
    {
      "sha": "d9fada1612bf01e8daa28f967ed285b3b682ba0b",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 70,
      "deletions": 119,
      "changes": 189,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/43892fdfa1aecb67d4830c47c9a40b0d74ed4c47/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=43892fdfa1aecb67d4830c47c9a40b0d74ed4c47",
      "patch": "@@ -486,8 +486,6 @@ bool target_exact_watchpoints = false;\n    ALL_BREAKPOINTS_SAFE does so even if the statement deletes the\n    current breakpoint.  */\n \n-#define ALL_BREAKPOINTS(B)  for (B = breakpoint_chain; B; B = B->next)\n-\n #define ALL_BREAKPOINTS_SAFE(B,TMP)\t\\\n \tfor (B = breakpoint_chain;\t\\\n \t     B ? (TMP=B->next, 1): 0;\t\\\n@@ -526,6 +524,22 @@ bool target_exact_watchpoints = false;\n \n static struct breakpoint *breakpoint_chain;\n \n+/* Breakpoint linked list iterator.  */\n+\n+using breakpoint_iterator = next_iterator<breakpoint>;\n+\n+/* Breakpoint linked list range.  */\n+\n+using breakpoint_range = next_adapter<breakpoint, breakpoint_iterator>;\n+\n+/* Return a range to iterate over all breakpoints.  */\n+\n+static breakpoint_range\n+all_breakpoints ()\n+{\n+  return breakpoint_range (breakpoint_chain);\n+}\n+\n /* Array is sorted by bp_location_is_less_than - primarily by the ADDRESS.  */\n \n static struct bp_location **bp_locations;\n@@ -579,15 +593,11 @@ struct breakpoint *\n breakpoint_find_if (int (*func) (struct breakpoint *b, void *d),\n \t\t    void *user_data)\n {\n-  struct breakpoint *b = NULL;\n-\n-  ALL_BREAKPOINTS (b)\n-    {\n-      if (func (b, user_data) != 0)\n-\tbreak;\n-    }\n+  for (breakpoint *b : all_breakpoints ())\n+    if (func (b, user_data) != 0)\n+      return b;\n \n-  return b;\n+  return nullptr;\n }\n \n /* Return whether a breakpoint is an active enabled breakpoint.  */\n@@ -632,9 +642,7 @@ scoped_rbreak_breakpoints::~scoped_rbreak_breakpoints ()\n void\n clear_breakpoint_hit_counts (void)\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     b->hit_count = 0;\n }\n \n@@ -645,13 +653,11 @@ clear_breakpoint_hit_counts (void)\n struct breakpoint *\n get_breakpoint (int num)\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->number == num)\n       return b;\n   \n-  return NULL;\n+  return nullptr;\n }\n \n \f\n@@ -979,8 +985,7 @@ void\n set_breakpoint_condition (int bpnum, const char *exp, int from_tty,\n \t\t\t  bool force)\n {\n-  struct breakpoint *b;\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->number == bpnum)\n       {\n \t/* Check if this breakpoint has a \"stop\" method implemented in an\n@@ -1052,7 +1057,6 @@ condition_completer (struct cmd_list_element *cmd,\n   if (*space == '\\0')\n     {\n       int len;\n-      struct breakpoint *b;\n \n       if (text[0] == '$')\n \t{\n@@ -1073,7 +1077,7 @@ condition_completer (struct cmd_list_element *cmd,\n       /* We're completing the breakpoint number.  */\n       len = strlen (text);\n \n-      ALL_BREAKPOINTS (b)\n+      for (breakpoint *b : all_breakpoints ())\n \t{\n \t  char number[50];\n \n@@ -1270,11 +1274,10 @@ validate_commands_for_breakpoint (struct breakpoint *b,\n std::vector<breakpoint *>\n static_tracepoints_here (CORE_ADDR addr)\n {\n-  struct breakpoint *b;\n   std::vector<breakpoint *> found;\n   struct bp_location *loc;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->type == bp_static_tracepoint)\n       {\n \tfor (loc = b->loc; loc; loc = loc->next)\n@@ -2929,9 +2932,7 @@ breakpoint_program_space_exit (struct program_space *pspace)\n void\n insert_breakpoints (void)\n {\n-  struct breakpoint *bpt;\n-\n-  ALL_BREAKPOINTS (bpt)\n+  for (breakpoint *bpt : all_breakpoints ())\n     if (is_hardware_watchpoint (bpt))\n       {\n \tstruct watchpoint *w = (struct watchpoint *) bpt;\n@@ -3025,7 +3026,6 @@ update_inserted_breakpoint_locations (void)\n static void\n insert_breakpoint_locations (void)\n {\n-  struct breakpoint *bpt;\n   struct bp_location *bl, **blp_tmp;\n   int error_flag = 0;\n   int val = 0;\n@@ -3071,7 +3071,7 @@ insert_breakpoint_locations (void)\n \n   /* If we failed to insert all locations of a watchpoint, remove\n      them, as half-inserted watchpoint is of limited use.  */\n-  ALL_BREAKPOINTS (bpt)  \n+  for (breakpoint *bpt : all_breakpoints ())\n     {\n       int some_failed = 0;\n       struct bp_location *loc;\n@@ -4280,9 +4280,7 @@ int\n hardware_watchpoint_inserted_in_range (const address_space *aspace,\n \t\t\t\t       CORE_ADDR addr, ULONGEST len)\n {\n-  struct breakpoint *bpt;\n-\n-  ALL_BREAKPOINTS (bpt)\n+  for (breakpoint *bpt : all_breakpoints ())\n     {\n       struct bp_location *loc;\n \n@@ -4861,13 +4859,12 @@ watchpoints_triggered (struct target_waitstatus *ws)\n {\n   bool stopped_by_watchpoint = target_stopped_by_watchpoint ();\n   CORE_ADDR addr;\n-  struct breakpoint *b;\n \n   if (!stopped_by_watchpoint)\n     {\n       /* We were not stopped by a watchpoint.  Mark all watchpoints\n \t as not triggered.  */\n-      ALL_BREAKPOINTS (b)\n+      for (breakpoint *b : all_breakpoints ())\n \tif (is_hardware_watchpoint (b))\n \t  {\n \t    struct watchpoint *w = (struct watchpoint *) b;\n@@ -4882,7 +4879,7 @@ watchpoints_triggered (struct target_waitstatus *ws)\n     {\n       /* We were stopped by a watchpoint, but we don't know where.\n \t Mark all watchpoints as unknown.  */\n-      ALL_BREAKPOINTS (b)\n+      for (breakpoint *b : all_breakpoints ())\n \tif (is_hardware_watchpoint (b))\n \t  {\n \t    struct watchpoint *w = (struct watchpoint *) b;\n@@ -4897,7 +4894,7 @@ watchpoints_triggered (struct target_waitstatus *ws)\n      affected by this data address as triggered, and all others as not\n      triggered.  */\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (is_hardware_watchpoint (b))\n       {\n \tstruct watchpoint *w = (struct watchpoint *) b;\n@@ -5223,9 +5220,7 @@ bpstat_check_watchpoint (bpstat bs)\n \n \t\t  if (bl->watchpoint_type == hw_read)\n \t\t    {\n-\t\t      struct breakpoint *other_b;\n-\n-\t\t      ALL_BREAKPOINTS (other_b)\n+\t\t      for (breakpoint *other_b : all_breakpoints ())\n \t\t\tif (other_b->type == bp_hardware_watchpoint\n \t\t\t    || other_b->type == bp_access_watchpoint)\n \t\t\t  {\n@@ -5441,10 +5436,9 @@ bpstat\n build_bpstat_chain (const address_space *aspace, CORE_ADDR bp_addr,\n \t\t    const struct target_waitstatus *ws)\n {\n-  struct breakpoint *b;\n   bpstat bs_head = NULL, *bs_link = &bs_head;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     {\n       if (!breakpoint_enabled (b))\n \tcontinue;\n@@ -5858,11 +5852,10 @@ bpstat_run_callbacks (bpstat bs_head)\n bool\n bpstat_should_step ()\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (breakpoint_enabled (b) && b->type == bp_watchpoint && b->loc != NULL)\n       return true;\n+\n   return false;\n }\n \n@@ -6594,7 +6587,6 @@ static int\n breakpoint_1 (const char *bp_num_list, bool show_internal,\n \t      bool (*filter) (const struct breakpoint *))\n {\n-  struct breakpoint *b;\n   struct bp_location *last_loc = NULL;\n   int nr_printable_breakpoints;\n   struct value_print_options opts;\n@@ -6608,7 +6600,7 @@ breakpoint_1 (const char *bp_num_list, bool show_internal,\n   /* Compute the number of rows in the table, as well as the size\n      required for address fields.  */\n   nr_printable_breakpoints = 0;\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     {\n       /* If we have a filter, only list the breakpoints it accepts.  */\n       if (filter && !filter (b))\n@@ -6676,7 +6668,7 @@ breakpoint_1 (const char *bp_num_list, bool show_internal,\n     if (nr_printable_breakpoints > 0)\n       annotate_breakpoints_table ();\n \n-    ALL_BREAKPOINTS (b)\n+    for (breakpoint *b : all_breakpoints ())\n       {\n \tQUIT;\n \t/* If we have a filter, only list the breakpoints it accepts.  */\n@@ -6820,18 +6812,18 @@ describe_other_breakpoints (struct gdbarch *gdbarch,\n \t\t\t    struct obj_section *section, int thread)\n {\n   int others = 0;\n-  struct breakpoint *b;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     others += (user_breakpoint_p (b)\n \t       && breakpoint_has_pc (b, pspace, pc, section));\n+\n   if (others > 0)\n     {\n       if (others == 1)\n \tprintf_filtered (_(\"Note: breakpoint \"));\n       else /* if (others == ???) */\n \tprintf_filtered (_(\"Note: breakpoints \"));\n-      ALL_BREAKPOINTS (b)\n+      for (breakpoint *b : all_breakpoints ())\n \tif (user_breakpoint_p (b) && breakpoint_has_pc (b, pspace, pc, section))\n \t  {\n \t    others--;\n@@ -7422,9 +7414,9 @@ delete_longjmp_breakpoint_at_next_stop (int thread)\n struct breakpoint *\n set_longjmp_breakpoint_for_call_dummy (void)\n {\n-  struct breakpoint *b, *retval = NULL;\n+  breakpoint *retval = nullptr;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->pspace == current_program_space && b->type == bp_longjmp_master)\n       {\n \tstruct breakpoint *new_b;\n@@ -7487,9 +7479,7 @@ check_longjmp_breakpoint_for_call_dummy (struct thread_info *tp)\n void\n enable_overlay_breakpoints (void)\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->type == bp_overlay_event)\n     {\n       b->enable_state = bp_enabled;\n@@ -7501,9 +7491,7 @@ enable_overlay_breakpoints (void)\n void\n disable_overlay_breakpoints (void)\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->type == bp_overlay_event)\n     {\n       b->enable_state = bp_disabled;\n@@ -7733,8 +7721,6 @@ disable_breakpoints_in_unloaded_shlib (struct so_list *solib)\n static void\n disable_breakpoints_in_freed_objfile (struct objfile *objfile)\n {\n-  struct breakpoint *b;\n-\n   if (objfile == NULL)\n     return;\n \n@@ -7753,7 +7739,7 @@ disable_breakpoints_in_freed_objfile (struct objfile *objfile)\n       || (objfile->flags & OBJF_USERLOADED) == 0)\n     return;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     {\n       struct bp_location *loc;\n       int bp_modified = 0;\n@@ -8085,12 +8071,11 @@ breakpoint_hit_catch_solib (const struct bp_location *bl,\n \t\t\t    const struct target_waitstatus *ws)\n {\n   struct solib_catchpoint *self = (struct solib_catchpoint *) bl->owner;\n-  struct breakpoint *other;\n \n   if (ws->kind == TARGET_WAITKIND_LOADED)\n     return 1;\n \n-  ALL_BREAKPOINTS (other)\n+  for (breakpoint *other : all_breakpoints ())\n   {\n     struct bp_location *other_bl;\n \n@@ -8451,19 +8436,16 @@ static int\n hw_breakpoint_used_count (void)\n {\n   int i = 0;\n-  struct breakpoint *b;\n   struct bp_location *bl;\n \n-  ALL_BREAKPOINTS (b)\n-  {\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->type == bp_hardware_breakpoint && breakpoint_enabled (b))\n       for (bl = b->loc; bl; bl = bl->next)\n \t{\n \t  /* Special types of hardware breakpoints may use more than\n \t     one register.  */\n \t  i += b->ops->resources_needed (bl);\n \t}\n-  }\n \n   return i;\n }\n@@ -8500,10 +8482,9 @@ hw_watchpoint_used_count_others (struct breakpoint *except,\n \t\t\t\t enum bptype type, int *other_type_used)\n {\n   int i = 0;\n-  struct breakpoint *b;\n \n   *other_type_used = 0;\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     {\n       if (b == except)\n \tcontinue;\n@@ -8522,31 +8503,23 @@ hw_watchpoint_used_count_others (struct breakpoint *except,\n void\n disable_watchpoints_before_interactive_call_start (void)\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n-  {\n+  for (breakpoint *b : all_breakpoints ())\n     if (is_watchpoint (b) && breakpoint_enabled (b))\n       {\n \tb->enable_state = bp_call_disabled;\n \tupdate_global_location_list (UGLL_DONT_INSERT);\n       }\n-  }\n }\n \n void\n enable_watchpoints_after_interactive_call_stop (void)\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n-  {\n+  for (breakpoint *b : all_breakpoints ())\n     if (is_watchpoint (b) && b->enable_state == bp_call_disabled)\n       {\n \tb->enable_state = bp_enabled;\n \tupdate_global_location_list (UGLL_MAY_INSERT);\n       }\n-  }\n }\n \n void\n@@ -8896,13 +8869,9 @@ static void\n update_dprintf_commands (const char *args, int from_tty,\n \t\t\t struct cmd_list_element *c)\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n-    {\n-      if (b->type == bp_dprintf)\n+  for (breakpoint *b : all_breakpoints ())\n+    if (b->type == bp_dprintf)\n \tupdate_dprintf_command_list (b);\n-    }\n }\n \n /* Create a breakpoint with SAL as location.  Use LOCATION\n@@ -11496,7 +11465,6 @@ compare_breakpoints (const breakpoint *a, const breakpoint *b)\n static void\n clear_command (const char *arg, int from_tty)\n {\n-  struct breakpoint *b;\n   int default_match;\n \n   std::vector<symtab_and_line> decoded_sals;\n@@ -11567,7 +11535,7 @@ clear_command (const char *arg, int from_tty)\n \t\t      ? NULL : symtab_to_fullname (sal.symtab));\n \n       /* Find all matching breakpoints and add them to 'found'.  */\n-      ALL_BREAKPOINTS (b)\n+      for (breakpoint *b : all_breakpoints ())\n \t{\n \t  int match = 0;\n \t  /* Are we going to delete b?  */\n@@ -11893,7 +11861,6 @@ force_breakpoint_reinsertion (struct bp_location *bl)\n static void\n update_global_location_list (enum ugll_insert_mode insert_mode)\n {\n-  struct breakpoint *b;\n   struct bp_location **locp, *loc;\n   /* Last breakpoint location address that was marked for update.  */\n   CORE_ADDR last_addr = 0;\n@@ -11921,13 +11888,13 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n   bp_locations = NULL;\n   bp_locations_count = 0;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     for (loc = b->loc; loc; loc = loc->next)\n       bp_locations_count++;\n \n   bp_locations = XNEWVEC (struct bp_location *, bp_locations_count);\n   locp = bp_locations;\n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     for (loc = b->loc; loc; loc = loc->next)\n       *locp++ = loc;\n \n@@ -12188,7 +12155,7 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n       /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always\n \t non-NULL.  */\n       struct bp_location **loc_first_p;\n-      b = loc->owner;\n+      breakpoint *b = loc->owner;\n \n       if (!unduplicated_should_be_inserted (loc)\n \t  || !bl_address_is_meaningful (loc)\n@@ -13283,8 +13250,6 @@ strace_marker_p (struct breakpoint *b)\n void\n delete_breakpoint (struct breakpoint *bpt)\n {\n-  struct breakpoint *b;\n-\n   gdb_assert (bpt != NULL);\n \n   /* Has this bp already been deleted?  This can happen because\n@@ -13339,7 +13304,7 @@ delete_breakpoint (struct breakpoint *bpt)\n   if (breakpoint_chain == bpt)\n     breakpoint_chain = bpt->next;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->next == bpt)\n     {\n       b->next = bpt->next;\n@@ -13410,7 +13375,7 @@ iterate_over_related_breakpoints (struct breakpoint *b,\n static void\n delete_command (const char *arg, int from_tty)\n {\n-  struct breakpoint *b, *b_tmp;\n+  breakpoint *b_tmp;\n \n   dont_repeat ();\n \n@@ -13421,7 +13386,7 @@ delete_command (const char *arg, int from_tty)\n       /* Delete all breakpoints if no argument.  Do not delete\n \t internal breakpoints, these have to be deleted with an\n \t explicit breakpoint number argument.  */\n-      ALL_BREAKPOINTS (b)\n+      for (breakpoint *b : all_breakpoints ())\n \tif (user_breakpoint_p (b))\n \t  {\n \t    breaks_to_delete = 1;\n@@ -13432,6 +13397,8 @@ delete_command (const char *arg, int from_tty)\n       if (!from_tty\n \t  || (breaks_to_delete && query (_(\"Delete all breakpoints? \"))))\n \t{\n+\t  breakpoint *b;\n+\n \t  ALL_BREAKPOINTS_SAFE (b, b_tmp)\n \t    if (user_breakpoint_p (b))\n \t      delete_breakpoint (b);\n@@ -14084,12 +14051,10 @@ breakpoint_re_set_thread (struct breakpoint *b)\n void\n set_ignore_count (int bptnum, int count, int from_tty)\n {\n-  struct breakpoint *b;\n-\n   if (count < 0)\n     count = 0;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     if (b->number == bptnum)\n     {\n       if (is_tracepoint (b))\n@@ -14205,13 +14170,7 @@ map_breakpoint_numbers (const char *args,\n static struct bp_location *\n find_location_by_number (int bp_num, int loc_num)\n {\n-  struct breakpoint *b;\n-\n-  ALL_BREAKPOINTS (b)\n-    if (b->number == bp_num)\n-      {\n-\tbreak;\n-      }\n+  breakpoint *b = get_breakpoint (bp_num);\n \n   if (!b || b->number != bp_num)\n     error (_(\"Bad breakpoint number '%d'\"), bp_num);\n@@ -14437,9 +14396,7 @@ enable_disable_command (const char *args, int from_tty, bool enable)\n {\n   if (args == 0)\n     {\n-      struct breakpoint *bpt;\n-\n-      ALL_BREAKPOINTS (bpt)\n+      for (breakpoint *bpt : all_breakpoints ())\n \tif (user_breakpoint_p (bpt))\n \t  {\n \t    if (enable)\n@@ -14628,9 +14585,7 @@ invalidate_bp_value_on_memory_change (struct inferior *inferior,\n \t\t\t\t      CORE_ADDR addr, ssize_t len,\n \t\t\t\t      const bfd_byte *data)\n {\n-  struct breakpoint *bp;\n-\n-  ALL_BREAKPOINTS (bp)\n+  for (breakpoint *bp : all_breakpoints ())\n     if (bp->enable_state == bp_enabled\n \t&& bp->type == bp_hardware_watchpoint)\n       {\n@@ -14726,9 +14681,7 @@ int\n single_step_breakpoint_inserted_here_p (const address_space *aspace,\n \t\t\t\t\tCORE_ADDR pc)\n {\n-  struct breakpoint *bpt;\n-\n-  ALL_BREAKPOINTS (bpt)\n+  for (breakpoint *bpt : all_breakpoints ())\n     {\n       if (bpt->type == bp_single_step\n \t  && breakpoint_has_location_inserted_here (bpt, aspace, pc))\n@@ -15169,15 +15122,14 @@ static void\n save_breakpoints (const char *filename, int from_tty,\n \t\t  bool (*filter) (const struct breakpoint *))\n {\n-  struct breakpoint *tp;\n   int any = 0;\n   int extra_trace_bits = 0;\n \n   if (filename == 0 || *filename == 0)\n     error (_(\"Argument required (file name in which to save)\"));\n \n   /* See if we have anything to save.  */\n-  ALL_BREAKPOINTS (tp)\n+  for (breakpoint *tp : all_breakpoints ())\n   {\n     /* Skip internal and momentary breakpoints.  */\n     if (!user_breakpoint_p (tp))\n@@ -15215,7 +15167,7 @@ save_breakpoints (const char *filename, int from_tty,\n   if (extra_trace_bits)\n     save_trace_state_variables (&fp);\n \n-  ALL_BREAKPOINTS (tp)\n+  for (breakpoint *tp : all_breakpoints ())\n   {\n     /* Skip internal and momentary breakpoints.  */\n     if (!user_breakpoint_p (tp))\n@@ -15432,10 +15384,9 @@ int\n pc_at_non_inline_function (const address_space *aspace, CORE_ADDR pc,\n \t\t\t   const struct target_waitstatus *ws)\n {\n-  struct breakpoint *b;\n   struct bp_location *bl;\n \n-  ALL_BREAKPOINTS (b)\n+  for (breakpoint *b : all_breakpoints ())\n     {\n       if (!is_non_inline_function (b))\n \tcontinue;"
    }
  ]
}