{
  "sha": "d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
  "node_id": "C_kwDOANOeidoAKGQzZmQxMmRmYzUyY2Y0Y2JiOTEwODMwZTNmZjYwZGNhMTExZjc0Njg",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-08-30T15:49:48Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-10-01T02:05:46Z"
    },
    "message": "gdb: add field::name / field::set_name\n\nAdd the `name` and `set_name` methods on `struct field`, in order to\nremove `FIELD_NAME` and `TYPE_FIELD_NAME` macros.  In this patch, the\nmacros are changed to use `field::name`, so all the call sites that are\nused to set the field's name are changed to use `field::set_name`.\nThe next patch will remove the macros completely.\n\nNote that because of the name clash between the existing field named\n`name` and the new method, I renamed the field `m_name`.  It is not\nprivate per-se, because we can't make `struct field` a non-POD yet, but\nit should be considered private anyway (not accessed outside `struct\nfield`).\n\nChange-Id: If16ddbca4e0c39d0ff9da420bb5cdebe5b9b0896",
    "tree": {
      "sha": "14cff3a0dfb01d130942e5e2999ca541cef6c280",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/14cff3a0dfb01d130942e5e2999ca541cef6c280"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cdfbeec4139a3dc53ce7a061604dea8d8c76f974",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cdfbeec4139a3dc53ce7a061604dea8d8c76f974",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cdfbeec4139a3dc53ce7a061604dea8d8c76f974"
    }
  ],
  "stats": {
    "total": 130,
    "additions": 71,
    "deletions": 59
  },
  "files": [
    {
      "sha": "cb011a5a651750cfae80e7994dded3df642389f6",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -7601,7 +7601,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t  ada_ensure_varsize_limit (field_type);\n \n \t  rtype->field (f).set_type (field_type);\n-\t  TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);\n+\t  rtype->field (f).set_name (TYPE_FIELD_NAME (type, f));\n \t  /* The multiplication can potentially overflow.  But because\n \t     the field length has been size-checked just above, and\n \t     assuming that the maximum size is a reasonable value,\n@@ -7624,7 +7624,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t     to distinguish between the two options.  Stripping it\n \t     would prevent us from printing this field appropriately.  */\n \t  rtype->field (f).set_type (type->field (f).type ());\n-\t  TYPE_FIELD_NAME (rtype, f) = TYPE_FIELD_NAME (type, f);\n+\t  rtype->field (f).set_name (TYPE_FIELD_NAME (type, f));\n \t  if (TYPE_FIELD_BITSIZE (type, f) > 0)\n \t    fld_bit_len =\n \t      TYPE_FIELD_BITSIZE (rtype, f) = TYPE_FIELD_BITSIZE (type, f);\n@@ -7686,7 +7686,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n       else\n \t{\n \t  rtype->field (variant_field).set_type (branch_type);\n-\t  TYPE_FIELD_NAME (rtype, variant_field) = \"S\";\n+\t  rtype->field (variant_field).set_name (\"S\");\n \t  fld_bit_len =\n \t    TYPE_LENGTH (rtype->field (variant_field).type ()) *\n \t    TARGET_CHAR_BIT;\n@@ -7802,7 +7802,7 @@ template_to_static_fixed_type (struct type *type0)\n \t      TYPE_LENGTH (type) = 0;\n \t    }\n \t  type->field (f).set_type (new_type);\n-\t  TYPE_FIELD_NAME (type, f) = TYPE_FIELD_NAME (type0, f);\n+\t  type->field (f).set_name (TYPE_FIELD_NAME (type0, f));\n \t}\n     }\n \n@@ -7871,7 +7871,7 @@ to_record_with_fixed_variant_part (struct type *type, const gdb_byte *valaddr,\n   else\n     {\n       rtype->field (variant_field).set_type (branch_type);\n-      TYPE_FIELD_NAME (rtype, variant_field) = \"S\";\n+      rtype->field (variant_field).set_name (\"S\");\n       TYPE_FIELD_BITSIZE (rtype, variant_field) = 0;\n       TYPE_LENGTH (rtype) += TYPE_LENGTH (branch_type);\n     }"
    },
    {
      "sha": "30cf81988c5dfd2ac57c852c87004437b16b451f",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -2008,7 +2008,8 @@ coff_read_struct_type (int index, int length, int lastsym,\n \t  list = newobj;\n \n \t  /* Save the data.  */\n-\t  list->field.name = obstack_strdup (&objfile->objfile_obstack, name);\n+\t  list->field.set_name (obstack_strdup (&objfile->objfile_obstack,\n+\t\t\t\t\t\tname));\n \t  list->field.set_type (decode_type (ms, ms->c_type, &sub_aux,\n \t\t\t\t\t     objfile));\n \t  SET_FIELD_BITPOS (list->field, 8 * ms->c_value);\n@@ -2024,7 +2025,8 @@ coff_read_struct_type (int index, int length, int lastsym,\n \t  list = newobj;\n \n \t  /* Save the data.  */\n-\t  list->field.name = obstack_strdup (&objfile->objfile_obstack, name);\n+\t  list->field.set_name (obstack_strdup (&objfile->objfile_obstack,\n+\t\t\t\t\t\tname));\n \t  list->field.set_type (decode_type (ms, ms->c_type, &sub_aux,\n \t\t\t\t\t     objfile));\n \t  SET_FIELD_BITPOS (list->field, ms->c_value);\n@@ -2142,7 +2144,7 @@ coff_read_enum_type (int index, int length, int lastsym,\n \t  struct symbol *xsym = syms->symbol[j];\n \n \t  SYMBOL_TYPE (xsym) = type;\n-\t  TYPE_FIELD_NAME (type, n) = xsym->linkage_name ();\n+\t  type->field (n).set_name (xsym->linkage_name ());\n \t  SET_FIELD_ENUMVAL (type->field (n), SYMBOL_VALUE (xsym));\n \t  if (SYMBOL_VALUE (xsym) < 0)\n \t    unsigned_enum = 0;"
    },
    {
      "sha": "3d2cb11a06b49022fc53f1d306998443630ca0f0",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -399,7 +399,7 @@ ctf_add_member_cb (const char *name,\n   uint32_t kind;\n \n   fp = &new_field.field;\n-  FIELD_NAME (*fp) = name;\n+  fp->set_name (name);\n \n   kind = ctf_type_kind (ccp->fp, tid);\n   t = fetch_tid_type (ccp, tid);\n@@ -438,7 +438,7 @@ ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n   struct ctf_context *ccp = fip->cur_context;\n \n   fp = &new_field.field;\n-  FIELD_NAME (*fp) = name;\n+  fp->set_name (name);\n   fp->set_type (nullptr);\n   SET_FIELD_ENUMVAL (*fp, enum_value);\n   FIELD_BITSIZE (*fp) = 0;"
    },
    {
      "sha": "2149075de183bade965ce8d4f0dfd3201e37afdf",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -9092,14 +9092,14 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n       /* Put the discriminant at index 0.  */\n       type->field (0).set_type (field_type);\n       TYPE_FIELD_ARTIFICIAL (type, 0) = 1;\n-      TYPE_FIELD_NAME (type, 0) = \"<<discriminant>>\";\n+      type->field (0).set_name (\"<<discriminant>>\");\n       SET_FIELD_BITPOS (type->field (0), bit_offset);\n \n       /* The order of fields doesn't really matter, so put the real\n \t field at index 1 and the data-less field at index 2.  */\n       type->field (1) = saved_field;\n-      TYPE_FIELD_NAME (type, 1)\n-\t= rust_last_path_segment (type->field (1).type ()->name ());\n+      type->field (1).set_name\n+\t(rust_last_path_segment (type->field (1).type ()->name ()));\n       type->field (1).type ()->set_name\n \t(rust_fully_qualify (&objfile->objfile_obstack, type->name (),\n \t\t\t     TYPE_FIELD_NAME (type, 1)));\n@@ -9112,7 +9112,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n       type->field (2).set_type (dataless_type);\n       /* NAME points into the original discriminant name, which\n \t already has the correct lifetime.  */\n-      TYPE_FIELD_NAME (type, 2) = name;\n+      type->field (2).set_name (name);\n       SET_FIELD_BITPOS (type->field (2), 0);\n \n       /* Indicate that this is a variant type.  */\n@@ -9130,7 +9130,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n       struct type *field_type = type->field (0).type ();\n       const char *variant_name\n \t= rust_last_path_segment (field_type->name ());\n-      TYPE_FIELD_NAME (type, 0) = variant_name;\n+      type->field (0).set_name (variant_name);\n       field_type->set_name\n \t(rust_fully_qualify (&objfile->objfile_obstack,\n \t\t\t     type->name (), variant_name));\n@@ -9189,7 +9189,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n       /* Install the discriminant at index 0 in the union.  */\n       type->field (0) = *disr_field;\n       TYPE_FIELD_ARTIFICIAL (type, 0) = 1;\n-      TYPE_FIELD_NAME (type, 0) = \"<<discriminant>>\";\n+      type->field (0).set_name (\"<<discriminant>>\");\n \n       /* We need a way to find the correct discriminant given a\n \t variant name.  For convenience we build a map here.  */\n@@ -9239,7 +9239,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t      sub_type->set_num_fields (sub_type->num_fields () - 1);\n \t      sub_type->set_fields (sub_type->fields () + 1);\n \t    }\n-\t  TYPE_FIELD_NAME (type, i) = variant_name;\n+\t  type->field (i).set_name (variant_name);\n \t  sub_type->set_name\n \t    (rust_fully_qualify (&objfile->objfile_obstack,\n \t\t\t\t type->name (), variant_name));\n@@ -14637,7 +14637,7 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \n       /* The name is already allocated along with this objfile, so we don't\n \t need to duplicate it for the type.  */\n-      fp->name = fieldname;\n+      fp->set_name (fieldname);\n \n       /* Change accessibility for artificial fields (e.g. virtual table\n \t pointer or virtual base class pointer) to private.  */\n@@ -14684,15 +14684,15 @@ dwarf2_add_field (struct field_info *fip, struct die_info *die,\n \t need to duplicate it for the type.  */\n       SET_FIELD_PHYSNAME (*fp, physname ? physname : \"\");\n       fp->set_type (die_type (die, cu));\n-      FIELD_NAME (*fp) = fieldname;\n+      fp->set_name (fieldname);\n     }\n   else if (die->tag == DW_TAG_inheritance)\n     {\n       /* C++ base class field.  */\n       handle_member_location (die, cu, fp);\n       FIELD_BITSIZE (*fp) = 0;\n       fp->set_type (die_type (die, cu));\n-      FIELD_NAME (*fp) = fp->type ()->name ();\n+      fp->set_name (fp->type ()->name ());\n     }\n   else\n     gdb_assert_not_reached (\"missing case in dwarf2_add_field\");\n@@ -16141,7 +16141,7 @@ update_enumeration_type_from_children (struct die_info *die,\n \n       fields.emplace_back ();\n       struct field &field = fields.back ();\n-      FIELD_NAME (field) = dwarf2_physname (name, child_die, cu);\n+      field.set_name (dwarf2_physname (name, child_die, cu));\n       SET_FIELD_ENUMVAL (field, value);\n     }\n \n@@ -16515,9 +16515,9 @@ quirk_ada_thick_pointer (struct die_info *die, struct dwarf2_cu *cu,\n \n       /* Set the name of each field in the bounds.  */\n       xsnprintf (name, sizeof (name), \"LB%d\", i / 2);\n-      FIELD_NAME (range_fields[i]) = objfile->intern (name);\n+      range_fields[i].set_name (objfile->intern (name));\n       xsnprintf (name, sizeof (name), \"UB%d\", i / 2);\n-      FIELD_NAME (range_fields[i + 1]) = objfile->intern (name);\n+      range_fields[i + 1].set_name (objfile->intern (name));\n     }\n \n   struct type *bounds = alloc_type (objfile);\n@@ -16559,10 +16559,10 @@ quirk_ada_thick_pointer (struct die_info *die, struct dwarf2_cu *cu,\n   /* The names are chosen to coincide with what the compiler does with\n      -fgnat-encodings=all, which the Ada code in gdb already\n      understands.  */\n-  TYPE_FIELD_NAME (result, 0) = \"P_ARRAY\";\n+  result->field (0).set_name (\"P_ARRAY\");\n   result->field (0).set_type (lookup_pointer_type (type));\n \n-  TYPE_FIELD_NAME (result, 1) = \"P_BOUNDS\";\n+  result->field (1).set_name (\"P_BOUNDS\");\n   result->field (1).set_type (lookup_pointer_type (bounds));\n   SET_FIELD_BITPOS (result->field (1), 8 * bounds_offset);\n "
    },
    {
      "sha": "b0e7b87c606e4c4e6f2316c5fe0e0ab3ad248626",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -4876,8 +4876,9 @@ print_args (struct field *args, int nargs, int spaces)\n \n       for (i = 0; i < nargs; i++)\n \t{\n-\t  printf_filtered (\"%*s[%d] name '%s'\\n\", spaces, \"\", i,\n-\t\t\t   args[i].name != NULL ? args[i].name : \"<NULL>\");\n+\t  printf_filtered\n+\t    (\"%*s[%d] name '%s'\\n\", spaces, \"\", i,\n+\t     args[i].name () != NULL ? args[i].name () : \"<NULL>\");\n \t  recursive_dump_type (args[i].type (), spaces + 2);\n \t}\n     }\n@@ -5558,8 +5559,7 @@ copy_type_recursive (struct objfile *objfile,\n \t      (copy_type_recursive (objfile, type->field (i).type (),\n \t\t\t\t    copied_types));\n \t  if (TYPE_FIELD_NAME (type, i))\n-\t    TYPE_FIELD_NAME (new_type, i) = \n-\t      xstrdup (TYPE_FIELD_NAME (type, i));\n+\t    new_type->field (i).set_name (xstrdup (TYPE_FIELD_NAME (type, i)));\n \t  switch (TYPE_FIELD_LOC_KIND (type, i))\n \t    {\n \t    case FIELD_LOC_KIND_BITPOS:\n@@ -5846,7 +5846,7 @@ append_flags_type_field (struct type *type, int start_bitpos, int nr_bits,\n   gdb_assert (nr_bits >= 1 && (start_bitpos + nr_bits) <= type_bitsize);\n   gdb_assert (name != NULL);\n \n-  TYPE_FIELD_NAME (type, field_nr) = xstrdup (name);\n+  type->field (field_nr).set_name (xstrdup (name));\n   type->field (field_nr).set_type (field_type);\n   SET_FIELD_BITPOS (type->field (field_nr), start_bitpos);\n   TYPE_FIELD_BITSIZE (type, field_nr) = nr_bits;\n@@ -5897,7 +5897,7 @@ append_composite_type_field_raw (struct type *t, const char *name,\n   f = &t->field (t->num_fields () - 1);\n   memset (f, 0, sizeof f[0]);\n   f[0].set_type (field);\n-  FIELD_NAME (f[0]) = name;\n+  f[0].set_name (name);\n   return f;\n }\n "
    },
    {
      "sha": "46a5e5b0d6f60ec232bee1ff82ffa3e5467173e6",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 13,
      "deletions": 3,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -654,6 +654,16 @@ struct field\n     this->m_type = type;\n   }\n \n+  const char *name () const\n+  {\n+    return m_name;\n+  }\n+\n+  void set_name (const char *name)\n+  {\n+    m_name = name;\n+  }\n+\n   union field_location loc;\n \n   /* * For a function or member type, this is 1 if the argument is\n@@ -685,7 +695,7 @@ struct field\n      NULL for range bounds, array domains, and member function\n      arguments.  */\n \n-  const char *name;\n+  const char *m_name;\n };\n \n struct range_bounds\n@@ -1974,7 +1984,7 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n   (TYPE_CPLUS_SPECIFIC(thistype)->virtual_field_bits == NULL ? 0 \\\n     : B_TST(TYPE_CPLUS_SPECIFIC(thistype)->virtual_field_bits, (index)))\n \n-#define FIELD_NAME(thisfld) ((thisfld).name)\n+#define FIELD_NAME(thisfld) ((thisfld).name ())\n #define FIELD_LOC_KIND(thisfld) ((thisfld).loc_kind)\n #define FIELD_BITPOS_LVAL(thisfld) ((thisfld).loc.bitpos)\n #define FIELD_BITPOS(thisfld) (FIELD_BITPOS_LVAL (thisfld) + 0)\n@@ -2001,7 +2011,7 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n #define FIELD_ARTIFICIAL(thisfld) ((thisfld).artificial)\n #define FIELD_BITSIZE(thisfld) ((thisfld).bitsize)\n \n-#define TYPE_FIELD_NAME(thistype, n) FIELD_NAME((thistype)->field (n))\n+#define TYPE_FIELD_NAME(thistype, n) ((thistype)->field (n).name ())\n #define TYPE_FIELD_LOC_KIND(thistype, n) FIELD_LOC_KIND ((thistype)->field (n))\n #define TYPE_FIELD_BITPOS(thistype, n) FIELD_BITPOS ((thistype)->field (n))\n #define TYPE_FIELD_ENUMVAL(thistype, n) FIELD_ENUMVAL ((thistype)->field (n))"
    },
    {
      "sha": "c928afe6c34951253a3b35cc893c3835dbd22186",
      "filename": "gdb/gnu-v3-abi.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/gnu-v3-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/gnu-v3-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v3-abi.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -135,28 +135,28 @@ build_gdb_vtable_type (struct gdbarch *arch)\n   offset = 0;\n \n   /* ptrdiff_t vcall_and_vbase_offsets[0]; */\n-  FIELD_NAME (*field) = \"vcall_and_vbase_offsets\";\n+  field->set_name (\"vcall_and_vbase_offsets\");\n   field->set_type (lookup_array_range_type (ptrdiff_type, 0, -1));\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (field->type ());\n   field++;\n \n   /* ptrdiff_t offset_to_top; */\n-  FIELD_NAME (*field) = \"offset_to_top\";\n+  field->set_name (\"offset_to_top\");\n   field->set_type (ptrdiff_type);\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (field->type ());\n   field++;\n \n   /* void *type_info; */\n-  FIELD_NAME (*field) = \"type_info\";\n+  field->set_name (\"type_info\");\n   field->set_type (void_ptr_type);\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (field->type ());\n   field++;\n \n   /* void (*virtual_functions[0]) (); */\n-  FIELD_NAME (*field) = \"virtual_functions\";\n+  field->set_name (\"virtual_functions\");\n   field->set_type (lookup_array_range_type (ptr_to_void_fn_type, 0, -1));\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (field->type ());\n@@ -1036,14 +1036,14 @@ build_std_type_info_type (struct gdbarch *arch)\n   offset = 0;\n \n   /* The vtable.  */\n-  FIELD_NAME (*field) = \"_vptr.type_info\";\n+  field->set_name (\"_vptr.type_info\");\n   field->set_type (void_ptr_type);\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (field->type ());\n   field++;\n \n   /* The name.  */\n-  FIELD_NAME (*field) = \"__name\";\n+  field->set_name (\"__name\");\n   field->set_type (char_ptr_type);\n   SET_FIELD_BITPOS (*field, offset * TARGET_CHAR_BIT);\n   offset += TYPE_LENGTH (field->type ());"
    },
    {
      "sha": "3e560ae53e2e8033827c542d87f2cb95a2124d3b",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -1058,13 +1058,13 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \n \t\tSET_FIELD_ENUMVAL (*f, tsym.value);\n \t\tf->set_type (t);\n-\t\tFIELD_NAME (*f) = debug_info->ss + cur_fdr->issBase + tsym.iss;\n+\t\tf->set_name (debug_info->ss + cur_fdr->issBase + tsym.iss);\n \t\tFIELD_BITSIZE (*f) = 0;\n \n \t\tenum_sym = new (&mdebugread_objfile->objfile_obstack) symbol;\n \t\tenum_sym->set_linkage_name\n \t\t  (obstack_strdup (&mdebugread_objfile->objfile_obstack,\n-\t\t\t\t   f->name));\n+\t\t\t\t   f->name ()));\n \t\tSYMBOL_ACLASS_INDEX (enum_sym) = LOC_CONST;\n \t\tSYMBOL_TYPE (enum_sym) = t;\n \t\tSYMBOL_DOMAIN (enum_sym) = VAR_DOMAIN;\n@@ -1241,7 +1241,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n       {\n \tstruct field *f = &top_stack->cur_type->field (top_stack->cur_field);\n \ttop_stack->cur_field++;\n-\tFIELD_NAME (*f) = name;\n+\tf->set_name (name);\n \tSET_FIELD_BITPOS (*f, sh->value);\n \tbitsize = 0;\n \tf->set_type (parse_type (cur_fd, ax, sh->index, &bitsize, bigend,"
    },
    {
      "sha": "f3e346e4db5ed86e58835e6ae326745b53a84e24",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -915,7 +915,7 @@ rust_composite_type (struct type *original,\n       SET_FIELD_BITPOS (*field, bitpos);\n       bitpos += TYPE_LENGTH (type1) * TARGET_CHAR_BIT;\n \n-      FIELD_NAME (*field) = field1;\n+      field->set_name (field1);\n       field->set_type (type1);\n       ++i;\n     }\n@@ -935,7 +935,7 @@ rust_composite_type (struct type *original,\n \t}\n       SET_FIELD_BITPOS (*field, bitpos);\n \n-      FIELD_NAME (*field) = field2;\n+      field->set_name (field2);\n       field->set_type (type2);\n       ++i;\n     }"
    },
    {
      "sha": "765fec4b23abad21a337fc9613ab26b92559a299",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -1225,8 +1225,8 @@ define_symbol (CORE_ADDR valu, const char *string, int desc, int type,\n \n \t    for (j = TYPE_N_BASECLASSES (SYMBOL_TYPE (sym)) - 1; j >= 0; j--)\n \t      if (TYPE_BASECLASS_NAME (SYMBOL_TYPE (sym), j) == 0)\n-\t\tTYPE_BASECLASS_NAME (SYMBOL_TYPE (sym), j) =\n-\t\t  TYPE_BASECLASS (SYMBOL_TYPE (sym), j)->name ();\n+\t\tSYMBOL_TYPE (sym)->field (j).set_name\n+\t\t  (TYPE_BASECLASS (SYMBOL_TYPE (sym), j)->name ());\n \t  }\n \n       if (SYMBOL_TYPE (sym)->name () == NULL)\n@@ -2712,8 +2712,8 @@ read_cpp_abbrev (struct stab_field_info *fip, const char **pp,\n \t    {\n \t      name = \"\";\n \t    }\n-\t  fip->list->field.name = obconcat (&objfile->objfile_obstack,\n-\t\t\t\t\t    vptr_name, name, (char *) NULL);\n+\t  fip->list->field.set_name (obconcat (&objfile->objfile_obstack,\n+\t\t\t\t\t       vptr_name, name, (char *) NULL));\n \t  break;\n \n \tcase 'b':\t\t/* $vb -- a virtual bsomethingorother */\n@@ -2725,15 +2725,15 @@ read_cpp_abbrev (struct stab_field_info *fip, const char **pp,\n \t\t\t symnum);\n \t      name = \"FOO\";\n \t    }\n-\t  fip->list->field.name = obconcat (&objfile->objfile_obstack, vb_name,\n-\t\t\t\t\t    name, (char *) NULL);\n+\t  fip->list->field.set_name (obconcat (&objfile->objfile_obstack,\n+\t\t\t\t\t       vb_name, name, (char *) NULL));\n \t  break;\n \n \tdefault:\n \t  invalid_cpp_abbrev_complaint (*pp);\n-\t  fip->list->field.name = obconcat (&objfile->objfile_obstack,\n-\t\t\t\t\t    \"INVALID_CPLUSPLUS_ABBREV\",\n-\t\t\t\t\t    (char *) NULL);\n+\t  fip->list->field.set_name (obconcat (&objfile->objfile_obstack,\n+\t\t\t\t\t       \"INVALID_CPLUSPLUS_ABBREV\",\n+\t\t\t\t\t       (char *) NULL));\n \t  break;\n \t}\n \n@@ -2782,8 +2782,8 @@ read_one_struct_field (struct stab_field_info *fip, const char **pp,\n {\n   struct gdbarch *gdbarch = objfile->arch ();\n \n-  fip->list->field.name\n-    = obstack_strndup (&objfile->objfile_obstack, *pp, p - *pp);\n+  fip->list->field.set_name\n+    (obstack_strndup (&objfile->objfile_obstack, *pp, p - *pp));\n   *pp = p + 1;\n \n   /* This means we have a visibility for a field coming.  */\n@@ -3120,7 +3120,7 @@ read_baseclasses (struct stab_field_info *fip, const char **pp,\n \t field's name.  */\n \n       newobj->field.set_type (read_type (pp, objfile));\n-      newobj->field.name = newobj->field.type ()->name ();\n+      newobj->field.set_name (newobj->field.type ()->name ());\n \n       /* Skip trailing ';' and bump count of number of fields seen.  */\n       if (**pp == ';')\n@@ -3638,7 +3638,7 @@ read_enum_type (const char **pp, struct type *type,\n \t  struct symbol *xsym = syms->symbol[j];\n \n \t  SYMBOL_TYPE (xsym) = type;\n-\t  TYPE_FIELD_NAME (type, n) = xsym->linkage_name ();\n+\t  type->field (n).set_name (xsym->linkage_name ());\n \t  SET_FIELD_ENUMVAL (type->field (n), SYMBOL_VALUE (xsym));\n \t  TYPE_FIELD_BITSIZE (type, n) = 0;\n \t}"
    },
    {
      "sha": "c79d5e250609c95d0c5f6d236bb35b389f2563c6",
      "filename": "gdb/windows-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3fd12dfc52cf4cbb910830e3ff60dca111f7468/gdb/windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-tdep.c?ref=d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "patch": "@@ -761,7 +761,7 @@ create_enum (struct gdbarch *gdbarch, int bit, const char *name,\n \n   for (i = 0; i < count; i++)\n     {\n-      TYPE_FIELD_NAME (type, i) = values[i].name;\n+      type->field (i).set_name (values[i].name);\n       SET_FIELD_ENUMVAL (type->field (i), values[i].value);\n     }\n "
    }
  ]
}