{
  "sha": "ec73ddcd43b588924c95f1a997351314ddf84e39",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWM3M2RkY2Q0M2I1ODg5MjRjOTVmMWE5OTczNTEzMTRkZGY4NGUzOQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-23T06:36:22Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-23T14:19:25Z"
    },
    "message": "PowerPC64 dynamic symbol tweaks\n\nIn check_relocs, bfd_link_pic true means ld is producing a shared\nlibrary or a position independent executable.  !bfd_link_pic means a\nfixed position (ie. static) executable since the relocatable linking\ncase is excluded.  So it is appropriate to continue using bfd_link_pic\nwhen testing whether non-pcrelative relocations should be dynamic, and\n!bfd_link_pic for the special case of ifunc in static executables.\nHowever, -Bsymbolic shouldn't affect PIEs (they are executables so\nnone of their symbols should be overridden) and PIEs can support copy\nrelocations, thus bfd_link_executable should be used in those cases\nrather than bfd_link_pic.\n\nI've also removed the test of ELIMINATE_COPY_RELOCS in check_relocs.\nWe can sort out what to do regarding copy relocs later, which allows\nthe code in check_relocs to be simplified.\n\n\t* elf64-ppc.c (ppc64_elf_check_relocs): Use bfd_link_executable\n\tin choosing between different actions for shared library and\n\tnon-shared library cases.  Delete ELIMINATE_COPY_RELOCS test.\n\t(dec_dynrel_count): Likewise.  Account for ifunc special case.\n\t(ppc64_elf_adjust_dynamic_symbol): Copy relocs are for executables,\n\tnot non-pic.\n\t(allocate_dynrelocs): Comment fixes.  Delete ELIMINATE_COPY_RELOCS\n\ttest.",
    "tree": {
      "sha": "890a18f8399d1e10e473bd99bb1b6cf11d1fb804",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/890a18f8399d1e10e473bd99bb1b6cf11d1fb804"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ec73ddcd43b588924c95f1a997351314ddf84e39",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ec73ddcd43b588924c95f1a997351314ddf84e39",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ec73ddcd43b588924c95f1a997351314ddf84e39",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ec73ddcd43b588924c95f1a997351314ddf84e39/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6831670dd3c0a64e332b316c95873c57ab19887a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6831670dd3c0a64e332b316c95873c57ab19887a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6831670dd3c0a64e332b316c95873c57ab19887a"
    }
  ],
  "stats": {
    "total": 78,
    "additions": 45,
    "deletions": 33
  },
  "files": [
    {
      "sha": "ac0296482b3247b705443fc6fb399ad563f86a0c",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ec73ddcd43b588924c95f1a997351314ddf84e39/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ec73ddcd43b588924c95f1a997351314ddf84e39/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=ec73ddcd43b588924c95f1a997351314ddf84e39",
      "patch": "@@ -1,3 +1,14 @@\n+2019-09-23  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf64-ppc.c (ppc64_elf_check_relocs): Use bfd_link_executable\n+\tin choosing between different actions for shared library and\n+\tnon-shared library cases.  Delete ELIMINATE_COPY_RELOCS test.\n+\t(dec_dynrel_count): Likewise.  Account for ifunc special case.\n+\t(ppc64_elf_adjust_dynamic_symbol): Copy relocs are for executables,\n+\tnot non-pic.\n+\t(allocate_dynrelocs): Comment fixes.  Delete ELIMINATE_COPY_RELOCS\n+\ttest.\n+\n 2019-09-23  Alan Modra  <amodra@gmail.com>\n \n \t* Makefile.am (SOURCE_HFILES): Add many missing .h files."
    },
    {
      "sha": "d5a46dbf21f55f1f7d3ae3a1efcd32ec19f99c4c",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 34,
      "deletions": 33,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ec73ddcd43b588924c95f1a997351314ddf84e39/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ec73ddcd43b588924c95f1a997351314ddf84e39/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=ec73ddcd43b588924c95f1a997351314ddf84e39",
      "patch": "@@ -4836,7 +4836,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \tcase R_PPC64_TOC16_HA:\n \tcase R_PPC64_TOC16_LO_DS:\n \t  sec->has_toc_reloc = 1;\n-\t  if (h != NULL && !bfd_link_pic (info))\n+\t  if (h != NULL && bfd_link_executable (info))\n \t    {\n \t      /* We may need a copy reloc.  */\n \t      h->non_got_ref = 1;\n@@ -5076,7 +5076,7 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \tcase R_PPC64_UADDR32:\n \tcase R_PPC64_UADDR64:\n \tcase R_PPC64_TOC:\n-\t  if (h != NULL && !bfd_link_pic (info))\n+\t  if (h != NULL && bfd_link_executable (info))\n \t    /* We may need a copy reloc.  */\n \t    h->non_got_ref = 1;\n \n@@ -5106,17 +5106,14 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t     dynamic library if we manage to avoid copy relocs for the\n \t     symbol.  */\n \tdodyn:\n-\t  if ((bfd_link_pic (info)\n-\t       && (must_be_dyn_reloc (info, r_type)\n-\t\t   || (h != NULL\n-\t\t       && (!SYMBOLIC_BIND (info, h)\n-\t\t\t   || h->root.type == bfd_link_hash_defweak\n-\t\t\t   || !h->def_regular))))\n-\t      || (ELIMINATE_COPY_RELOCS\n-\t\t  && !bfd_link_pic (info)\n-\t\t  && h != NULL\n-\t\t  && (h->root.type == bfd_link_hash_defweak\n-\t\t      || !h->def_regular))\n+\t  if ((h != NULL\n+\t       && (h->root.type == bfd_link_hash_defweak\n+\t\t   || !h->def_regular))\n+\t      || (h != NULL\n+\t\t  && !bfd_link_executable (info)\n+\t\t  && !SYMBOLIC_BIND (info, h))\n+\t      || (bfd_link_pic (info)\n+\t\t  && must_be_dyn_reloc (info, r_type))\n \t      || (!bfd_link_pic (info)\n \t\t  && ifunc != NULL))\n \t    {\n@@ -6425,7 +6422,7 @@ ppc64_elf_adjust_dynamic_symbol (struct bfd_link_info *info,\n      only references to the symbol are via the global offset table.\n      For such cases we need not do anything here; the relocations will\n      be handled correctly by relocate_section.  */\n-  if (bfd_link_pic (info))\n+  if (!bfd_link_executable (info))\n     return TRUE;\n \n   /* If there are no references to this symbol that do not use the\n@@ -6904,17 +6901,18 @@ dec_dynrel_count (bfd_vma r_info,\n \treturn FALSE;\n     }\n \n-  if ((bfd_link_pic (info)\n-       && (must_be_dyn_reloc (info, r_type)\n-\t   || (h != NULL\n-\t       && (!SYMBOLIC_BIND (info, h)\n-\t\t   || h->root.type == bfd_link_hash_defweak\n-\t\t   || !h->def_regular))))\n-      || (ELIMINATE_COPY_RELOCS\n-\t  && !bfd_link_pic (info)\n-\t  && h != NULL\n-\t  && (h->root.type == bfd_link_hash_defweak\n-\t      || !h->def_regular)))\n+  if ((h != NULL\n+       && (h->root.type == bfd_link_hash_defweak\n+\t   || !h->def_regular))\n+      || (h != NULL\n+\t  && !bfd_link_executable (info)\n+\t  && !SYMBOLIC_BIND (info, h))\n+      || (bfd_link_pic (info)\n+\t  && must_be_dyn_reloc (info, r_type))\n+      || (!bfd_link_pic (info)\n+\t  && (h != NULL\n+\t      ? h->type == STT_GNU_IFUNC\n+\t      : ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)))\n     ;\n   else\n     return TRUE;\n@@ -9403,7 +9401,8 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   for (gent = h->got.glist; gent != NULL; gent = gent->next)\n     if (!gent->is_indirect)\n       {\n-\t/* Make sure this symbol is output as a dynamic symbol.  */\n+\t/* Ensure we catch all the cases where this symbol should\n+\t   be made dynamic.  */\n \tif (!ensure_undef_dynamic (info, h))\n \t  return FALSE;\n \n@@ -9438,7 +9437,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \t be defined in regular objects.  For the normal shared case,\n \t discard space for relocs that have become local due to symbol\n \t visibility changes.  */\n-\n       if (bfd_link_pic (info))\n \t{\n \t  /* Relocs that use pc_count are those that appear on a call\n@@ -9463,24 +9461,27 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n \n \t  if (eh->dyn_relocs != NULL)\n \t    {\n-\t      /* Make sure this symbol is output as a dynamic symbol.  */\n+\t      /* Ensure we catch all the cases where this symbol\n+\t\t should be made dynamic.  */\n \t      if (!ensure_undef_dynamic (info, h))\n \t\treturn FALSE;\n \t    }\n \t}\n-      else if (ELIMINATE_COPY_RELOCS && h->type != STT_GNU_IFUNC)\n+\n+      /* For a fixed position executable, discard space for\n+\t relocs against symbols which are not dynamic.  */\n+      else if (h->type != STT_GNU_IFUNC)\n \t{\n-\t  /* For the non-pic case, discard space for relocs against\n-\t     symbols which turn out to need copy relocs or are not\n-\t     dynamic.  */\n \t  if (h->dynamic_adjusted\n \t      && !h->def_regular\n \t      && !ELF_COMMON_DEF_P (h))\n \t    {\n-\t      /* Make sure this symbol is output as a dynamic symbol.  */\n+\t      /* Ensure we catch all the cases where this symbol\n+\t\t should be made dynamic.  */\n \t      if (!ensure_undef_dynamic (info, h))\n \t\treturn FALSE;\n \n+\t      /* But if that didn't work out, discard dynamic relocs.  */\n \t      if (h->dynindx == -1)\n \t\teh->dyn_relocs = NULL;\n \t    }"
    }
  ]
}