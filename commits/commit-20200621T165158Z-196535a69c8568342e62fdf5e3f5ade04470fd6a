{
  "sha": "196535a69c8568342e62fdf5e3f5ade04470fd6a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTk2NTM1YTY5Yzg1NjgzNDJlNjJmZGY1ZTNmNWFkZTA0NDcwZmQ2YQ==",
  "commit": {
    "author": {
      "name": "Rainer Orth",
      "email": "ro@CeBiTec.Uni-Bielefeld.DE",
      "date": "2020-06-21T16:51:58Z"
    },
    "committer": {
      "name": "Rainer Orth",
      "email": "ro@CeBiTec.Uni-Bielefeld.DE",
      "date": "2020-06-21T16:51:58Z"
    },
    "message": "Various procfs.c cleanups\n\nWhile reading through procfs.c, I noticed a couple of cleanup\nopportunities:\n\n* Some comments and code allowed for portability across different\n  targets.  Since procfs.c is Solaris-only for some time now, those can\n  go.\n\n* Likewise, there were some references to the old ioctl-based /proc left.\n\n* The code still allowed for SYS_exec.  However, it is no longer present\n  in either Solaris 11.3, 11.4, or Illumos.  Checking the OpenSolaris\n  sources, I found that it had already been removed in 2010 well before\n  the Solaris 11 release.\n\n* Some blocks of #if 0 code can go:\n\n** References to struct procinfo.{g,fp}regs_dirty which are no longer\n   defined.\n\n** Code handling the PR_ASLWP flag where <sys/procfs.h> has\n\n#define\tPR_ASLWP   0x00000040\t/* obsolete flag; never set */\n\nTested on amd64-pc-solaris2.11.\n\n\t* procfs.c: Cleanup many comments.\n\n\t(READ_WATCHFLAG, WRITE_WATCHFLAG, EXEC_WATCHFLAG)\n\t(AFTER_WATCHFLAG): Replace by value.\n\n\t(MAIN_PROC_NAME_FORMAT): Inline ...\n\t(create_procinfo): ... here.\n\n\t(procfs_debug_inferior): Remove SYS_exec handling.\n\t(syscall_is_exec): Likewise.\n\t(procfs_set_exec_trap): Likewise.\n\n\t(syscall_is_lwp_exit): Inline in callers.\n\t(syscall_is_exit): Likewise.\n\t(syscall_is_exec): Likewise.\n\t(syscall_is_lwp_create): Likewise.\n\n\t(invalidate_cache): Remove #if 0 code.\n\n\t(make_signal_thread_runnable):  Remove.\n\t(procfs_target::resume): Remove #if 0 code.",
    "tree": {
      "sha": "6eeace8b5bccc8a58ea632f6f38562155098867c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6eeace8b5bccc8a58ea632f6f38562155098867c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/196535a69c8568342e62fdf5e3f5ade04470fd6a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/196535a69c8568342e62fdf5e3f5ade04470fd6a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/196535a69c8568342e62fdf5e3f5ade04470fd6a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/196535a69c8568342e62fdf5e3f5ade04470fd6a/comments",
  "author": {
    "login": "rorth",
    "id": 3930951,
    "node_id": "MDQ6VXNlcjM5MzA5NTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rorth",
    "html_url": "https://github.com/rorth",
    "followers_url": "https://api.github.com/users/rorth/followers",
    "following_url": "https://api.github.com/users/rorth/following{/other_user}",
    "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rorth/subscriptions",
    "organizations_url": "https://api.github.com/users/rorth/orgs",
    "repos_url": "https://api.github.com/users/rorth/repos",
    "events_url": "https://api.github.com/users/rorth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rorth/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "rorth",
    "id": 3930951,
    "node_id": "MDQ6VXNlcjM5MzA5NTE=",
    "avatar_url": "https://avatars.githubusercontent.com/u/3930951?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/rorth",
    "html_url": "https://github.com/rorth",
    "followers_url": "https://api.github.com/users/rorth/followers",
    "following_url": "https://api.github.com/users/rorth/following{/other_user}",
    "gists_url": "https://api.github.com/users/rorth/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/rorth/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/rorth/subscriptions",
    "organizations_url": "https://api.github.com/users/rorth/orgs",
    "repos_url": "https://api.github.com/users/rorth/repos",
    "events_url": "https://api.github.com/users/rorth/events{/privacy}",
    "received_events_url": "https://api.github.com/users/rorth/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cf6f3e86ded2cd950f59a0f2c164f2c953ef534b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cf6f3e86ded2cd950f59a0f2c164f2c953ef534b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cf6f3e86ded2cd950f59a0f2c164f2c953ef534b"
    }
  ],
  "stats": {
    "total": 227,
    "additions": 52,
    "deletions": 175
  },
  "files": [
    {
      "sha": "565a71a78d8a8096325b9399aeaf11259a98a0b8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/196535a69c8568342e62fdf5e3f5ade04470fd6a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/196535a69c8568342e62fdf5e3f5ade04470fd6a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=196535a69c8568342e62fdf5e3f5ade04470fd6a",
      "patch": "@@ -1,3 +1,27 @@\n+2020-06-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\t* procfs.c: Cleanup many comments.\n+\n+\t(READ_WATCHFLAG, WRITE_WATCHFLAG, EXEC_WATCHFLAG)\n+\t(AFTER_WATCHFLAG): Replace by value.\n+\n+\t(MAIN_PROC_NAME_FORMAT): Inline ...\n+\t(create_procinfo): ... here.\n+\n+\t(procfs_debug_inferior): Remove SYS_exec handling.\n+\t(syscall_is_exec): Likewise.\n+\t(procfs_set_exec_trap): Likewise.\n+\n+\t(syscall_is_lwp_exit): Inline in callers.\n+\t(syscall_is_exit): Likewise.\n+\t(syscall_is_exec): Likewise.\n+\t(syscall_is_lwp_create): Likewise.\n+\n+\t(invalidate_cache): Remove #if 0 code.\n+\n+\t(make_signal_thread_runnable):  Remove.\n+\t(procfs_target::resume): Remove #if 0 code.\n+\n 2020-06-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR gdb/25939"
    },
    {
      "sha": "6360436ce5b573934e2945df48a63aadfd9f0a1a",
      "filename": "gdb/procfs.c",
      "status": "modified",
      "additions": 28,
      "deletions": 175,
      "changes": 203,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/196535a69c8568342e62fdf5e3f5ade04470fd6a/gdb/procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/196535a69c8568342e62fdf5e3f5ade04470fd6a/gdb/procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/procfs.c?ref=196535a69c8568342e62fdf5e3f5ade04470fd6a",
      "patch": "@@ -197,18 +197,6 @@ procfs_target::auxv_parse (gdb_byte **readptr,\n \n /* =================== END, TARGET_OPS \"MODULE\" =================== */\n \n-/* World Unification:\n-\n-   Put any typedefs, defines etc. here that are required for the\n-   unification of code that handles different versions of /proc.  */\n-\n-enum { READ_WATCHFLAG  = WA_READ,\n-       WRITE_WATCHFLAG = WA_WRITE,\n-       EXEC_WATCHFLAG  = WA_EXEC,\n-       AFTER_WATCHFLAG = WA_TRAPAFTER\n-};\n-\n-\n /* =================== STRUCT PROCINFO \"MODULE\" =================== */\n \n      /* FIXME: this comment will soon be out of date W.R.T. threads.  */\n@@ -231,7 +219,6 @@ enum { READ_WATCHFLAG  = WA_READ,\n    inferior's procinfo information.  */\n \n /* format strings for /proc paths */\n-#define MAIN_PROC_NAME_FMT   \"/proc/%d\"\n #define CTL_PROC_NAME_FMT    \"/proc/%d/ctl\"\n #define AS_PROC_NAME_FMT     \"/proc/%d/as\"\n #define MAP_PROC_NAME_FMT    \"/proc/%d/map\"\n@@ -387,14 +374,14 @@ open_procinfo_files (procinfo *pi, int which)\n      several.  Here is some rationale:\n \n      There are several file descriptors that may need to be open\n-       for any given process or LWP.  The ones we're interested in are:\n+     for any given process or LWP.  The ones we're interested in are:\n \t - control\t (ctl)\t  write-only\tchange the state\n \t - status\t (status) read-only\tquery the state\n \t - address space (as)\t  read/write\taccess memory\n \t - map\t\t (map)\t  read-only\tvirtual addr map\n-       Most of these are opened lazily as they are needed.\n-       The pathnames for the 'files' for an LWP look slightly\n-       different from those of a first-class process:\n+     Most of these are opened lazily as they are needed.\n+     The pathnames for the 'files' for an LWP look slightly\n+     different from those of a first-class process:\n \t Pathnames for a process (<proc-id>):\n \t   /proc/<proc-id>/ctl\n \t   /proc/<proc-id>/status\n@@ -403,8 +390,8 @@ open_procinfo_files (procinfo *pi, int which)\n \t Pathnames for an LWP (lwp-id):\n \t   /proc/<proc-id>/lwp/<lwp-id>/lwpctl\n \t   /proc/<proc-id>/lwp/<lwp-id>/lwpstatus\n-       An LWP has no map or address space file descriptor, since\n-       the memory map and address space are shared by all LWPs.  */\n+     An LWP has no map or address space file descriptor, since\n+     the memory map and address space are shared by all LWPs.  */\n \n   /* In this case, there are several different file descriptors that\n      we might be asked to open.  The control file descriptor will be\n@@ -479,7 +466,7 @@ create_procinfo (int pid, int tid)\n   /* Chain into list.  */\n   if (tid == 0)\n     {\n-      xsnprintf (pi->pathname, sizeof (pi->pathname), MAIN_PROC_NAME_FMT, pid);\n+      xsnprintf (pi->pathname, sizeof (pi->pathname), \"/proc/%d\", pid);\n       pi->next = procinfo_list;\n       procinfo_list = pi;\n     }\n@@ -592,17 +579,15 @@ dead_procinfo (procinfo *pi, const char *msg, int kill_p)\n \n /* =================== END, STRUCT PROCINFO \"MODULE\" =================== */\n \n-/* ===================  /proc  \"MODULE\" =================== */\n+/* ===================  /proc \"MODULE\" =================== */\n \n /* This \"module\" is the interface layer between the /proc system API\n    and the gdb target vector functions.  This layer consists of access\n    functions that encapsulate each of the basic operations that we\n    need to use from the /proc API.\n \n    The main motivation for this layer is to hide the fact that there\n-   are two very different implementations of the /proc API.  Rather\n-   than have a bunch of #ifdefs all thru the gdb target vector\n-   functions, we do our best to hide them all in here.  */\n+   were two very different implementations of the /proc API.  */\n \n static long proc_flags (procinfo *pi);\n static int proc_why (procinfo *pi);\n@@ -931,10 +916,6 @@ proc_wait_for_stop (procinfo *pi)\n      - clear current signal\n      - abort the current system call\n      - stop as soon as finished with system call\n-     - (ioctl): set traced signal set\n-     - (ioctl): set held   signal set\n-     - (ioctl): set traced fault  set\n-     - (ioctl): set start pc (vaddr)\n \n    Always clears the current fault.  PI is the process or LWP to\n    operate on.  If STEP is true, set the process or LWP to trap after\n@@ -1573,9 +1554,6 @@ proc_set_watchpoint (procinfo *pi, CORE_ADDR addr, int len, int wflags)\n \n /* =================== Thread \"MODULE\" =================== */\n \n-/* NOTE: you'll see more ifdefs and duplication of functions here,\n-   since there is a different way to do threads on every OS.  */\n-\n /* Returns the number of threads for the process.  */\n \n static int\n@@ -1592,9 +1570,7 @@ proc_get_nthreads (procinfo *pi)\n   return pi->prstatus.pr_nlwp;\n }\n \n-/* LWP version.\n-\n-   Return the ID of the thread that had an event of interest.\n+/* Return the ID of the thread that had an event of interest.\n    (ie. the one that hit a breakpoint or other traced event).  All\n    other things being equal, this should be the ID of a thread that is\n    currently executing.  */\n@@ -1618,8 +1594,7 @@ proc_get_current_thread (procinfo *pi)\n }\n \n /* Discover the IDs of all the threads within the process, and create\n-   a procinfo for each of them (chained to the parent).  This\n-   unfortunately requires a different method on every OS.  Returns\n+   a procinfo for each of them (chained to the parent).  Returns\n    non-zero for success, zero for failure.  */\n \n static int\n@@ -1770,16 +1745,8 @@ procfs_debug_inferior (procinfo *pi)\n     return __LINE__;\n \n   /* Method for tracing exec syscalls.  */\n-  /* GW: Rationale...\n-     Not all systems with /proc have all the exec* syscalls with the same\n-     names.  On the SGI, for example, there is no SYS_exec, but there\n-     *is* a SYS_execv.  So, we try to account for that.  */\n-\n   traced_syscall_exits = XNEW (sysset_t);\n   premptyset (traced_syscall_exits);\n-#ifdef SYS_exec\n-  praddset (traced_syscall_exits, SYS_exec);\n-#endif\n   praddset (traced_syscall_exits, SYS_execve);\n   praddset (traced_syscall_exits, SYS_lwp_create);\n   praddset (traced_syscall_exits, SYS_lwp_exit);\n@@ -1961,10 +1928,6 @@ do_detach ()\n /* Fetch register REGNUM from the inferior.  If REGNUM is -1, do this\n    for all registers.\n \n-   ??? Is the following note still relevant?  We can't get individual\n-   registers with the PT_GETREGS ptrace(2) request either, yet we\n-   don't bother with caching at all in that case.\n-\n    NOTE: Since the /proc interface cannot give us individual\n    registers, we pay no attention to REGNUM, and just fetch them all.\n    This results in the possibility that we will do unnecessarily many\n@@ -2064,42 +2027,6 @@ procfs_target::store_registers (struct regcache *regcache, int regnum)\n     }\n }\n \n-static int\n-syscall_is_lwp_exit (procinfo *pi, int scall)\n-{\n-  if (scall == SYS_lwp_exit)\n-    return 1;\n-  return 0;\n-}\n-\n-static int\n-syscall_is_exit (procinfo *pi, int scall)\n-{\n-  if (scall == SYS_exit)\n-    return 1;\n-  return 0;\n-}\n-\n-static int\n-syscall_is_exec (procinfo *pi, int scall)\n-{\n-#ifdef SYS_exec\n-  if (scall == SYS_exec)\n-    return 1;\n-#endif\n-  if (scall == SYS_execve)\n-    return 1;\n-  return 0;\n-}\n-\n-static int\n-syscall_is_lwp_create (procinfo *pi, int scall)\n-{\n-  if (scall == SYS_lwp_create)\n-    return 1;\n-  return 0;\n-}\n-\n /* Retrieve the next stop event from the child process.  If child has\n    not stopped yet, wait for it to stop.  Translate /proc eventcodes\n    (or possibly wait eventcodes) into gdb internal event codes.\n@@ -2204,7 +2131,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\twstat = (what << 8) | 0177;\n \t\tbreak;\n \t      case PR_SYSENTRY:\n-\t\tif (syscall_is_lwp_exit (pi, what))\n+\t\tif (what == SYS_lwp_exit)\n \t\t  {\n \t\t    if (print_thread_events)\n \t\t      printf_unfiltered (_(\"[%s exited]\\n\"),\n@@ -2213,7 +2140,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n \t\t    return retval;\n \t\t  }\n-\t\telse if (syscall_is_exit (pi, what))\n+\t\telse if (what == SYS_exit)\n \t\t  {\n \t\t    struct inferior *inf;\n \n@@ -2293,15 +2220,15 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t  }\n \t\tbreak;\n \t      case PR_SYSEXIT:\n-\t\tif (syscall_is_exec (pi, what))\n+\t\tif (what == SYS_execve)\n \t\t  {\n \t\t    /* Hopefully this is our own \"fork-child\" execing\n \t\t       the real child.  Hoax this event into a trap, and\n \t\t       GDB will see the child about to execute its start\n \t\t       address.  */\n \t\t    wstat = (SIGTRAP << 8) | 0177;\n \t\t  }\n-\t\telse if (syscall_is_lwp_create (pi, what))\n+\t\telse if (what == SYS_lwp_create)\n \t\t  {\n \t\t    /* This syscall is somewhat like fork/exec.  We\n \t\t       will get the event twice: once for the parent\n@@ -2325,7 +2252,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n \t\t    return inferior_ptid;\n \t\t  }\n-\t\telse if (syscall_is_lwp_exit (pi, what))\n+\t\telse if (what == SYS_lwp_exit)\n \t\t  {\n \t\t    if (print_thread_events)\n \t\t      printf_unfiltered (_(\"[%s exited]\\n\"),\n@@ -2334,15 +2261,6 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n \t\t    return retval;\n \t\t  }\n-\t\telse if (0)\n-\t\t  {\n-\t\t    /* FIXME:  Do we need to handle SYS_sproc,\n-\t\t       SYS_fork, or SYS_vfork here?  The old procfs\n-\t\t       seemed to use this event to handle threads on\n-\t\t       older (non-LWP) systems, where I'm assuming\n-\t\t       that threads were actually separate processes.\n-\t\t       Irix, maybe?  Anyway, low priority for now.  */\n-\t\t  }\n \t\telse\n \t\t  {\n \t\t    printf_filtered (_(\"procfs: trapped on exit from \"));\n@@ -2528,20 +2446,6 @@ invalidate_cache (procinfo *parent, procinfo *pi, void *ptr)\n   /* About to run the child; invalidate caches and do any other\n      cleanup.  */\n \n-#if 0\n-  if (pi->gregs_dirty)\n-    if (parent == NULL || proc_get_current_thread (parent) != pi->tid)\n-      if (!proc_set_gregs (pi))\t/* flush gregs cache */\n-\tproc_warn (pi, \"target_resume, set_gregs\",\n-\t\t   __LINE__);\n-  if (gdbarch_fp0_regnum (target_gdbarch ()) >= 0)\n-    if (pi->fpregs_dirty)\n-      if (parent == NULL || proc_get_current_thread (parent) != pi->tid)\n-\tif (!proc_set_fpregs (pi))\t/* flush fpregs cache */\n-\t  proc_warn (pi, \"target_resume, set_fpregs\",\n-\t\t     __LINE__);\n-#endif\n-\n   if (parent != NULL)\n     {\n       /* The presence of a parent indicates that this is an LWP.\n@@ -2552,36 +2456,12 @@ invalidate_cache (procinfo *parent, procinfo *pi, void *ptr)\n     }\n   pi->gregs_valid   = 0;\n   pi->fpregs_valid  = 0;\n-#if 0\n-  pi->gregs_dirty   = 0;\n-  pi->fpregs_dirty  = 0;\n-#endif\n   pi->status_valid  = 0;\n   pi->threads_valid = 0;\n \n   return 0;\n }\n \n-#if 0\n-/* A callback function for iterate_over_threads.  Find the\n-   asynchronous signal thread, and make it runnable.  See if that\n-   helps matters any.  */\n-\n-static int\n-make_signal_thread_runnable (procinfo *process, procinfo *pi, void *ptr)\n-{\n-#ifdef PR_ASLWP\n-  if (proc_flags (pi) & PR_ASLWP)\n-    {\n-      if (!proc_run_process (pi, 0, -1))\n-\tproc_error (pi, \"make_signal_thread_runnable\", __LINE__);\n-      return 1;\n-    }\n-#endif\n-  return 0;\n-}\n-#endif\n-\n /* Make the child process runnable.  Normally we will then call\n    procfs_wait and wait for it to stop again (unless gdb is async).\n \n@@ -2598,21 +2478,14 @@ procfs_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n   procinfo *pi, *thread;\n   int native_signo;\n \n-  /* 2.1:\n-     prrun.prflags |= PRSVADDR;\n-     prrun.pr_vaddr = $PC;\t   set resume address\n-     prrun.prflags |= PRSTRACE;    trace signals in pr_trace (all)\n-     prrun.prflags |= PRSFAULT;    trace faults in pr_fault (all but PAGE)\n-     prrun.prflags |= PRCFAULT;    clear current fault.\n-\n-     PRSTRACE and PRSFAULT can be done by other means\n-\t(proc_trace_signals, proc_trace_faults)\n-     PRSVADDR is unnecessary.\n-     PRCFAULT may be replaced by a PIOCCFAULT call (proc_clear_current_fault)\n+  /* FIXME: Check/reword.  */\n+\n+  /* prrun.prflags |= PRCFAULT;    clear current fault.\n+     PRCFAULT may be replaced by a PCCFAULT call (proc_clear_current_fault)\n      This basically leaves PRSTEP and PRCSIG.\n-     PRCSIG is like PIOCSSIG (proc_clear_current_signal).\n+     PRCSIG is like PCSSIG (proc_clear_current_signal).\n      So basically PR_STEP is the sole argument that must be passed\n-     to proc_run_process (for use in the prrun struct by ioctl).  */\n+     to proc_run_process.  */\n \n   /* Find procinfo for main process.  */\n   pi = find_procinfo_or_die (inferior_ptid.pid (), 0);\n@@ -2647,11 +2520,6 @@ procfs_target::resume (ptid_t ptid, int step, enum gdb_signal signo)\n \t\t others.  Set the child process's PR_ASYNC flag.  */\n \t      if (!proc_set_async (pi))\n \t\tproc_error (pi, \"target_resume, set_async\", __LINE__);\n-#if 0\n-\t      proc_iterate_over_threads (pi,\n-\t\t\t\t\t make_signal_thread_runnable,\n-\t\t\t\t\t NULL);\n-#endif\n \t      pi = thread;\t/* Substitute the thread's procinfo\n \t\t\t\t   for run.  */\n \t    }\n@@ -2796,8 +2664,6 @@ procfs_target::procfs_init_inferior (int pid)\n     procfs_notice_signals\n     prfillset (fault)\n     prdelset (FLTPAGE)\n-    PIOCWSTOP\n-    PIOCSFAULT\n     */\n \n   /* If not stopped yet, wait for it to stop.  */\n@@ -2876,17 +2742,8 @@ procfs_set_exec_trap (void)\n       _exit (127);\n     }\n \n-  /* Method for tracing exec syscalls.  */\n-  /* GW: Rationale...\n-     Not all systems with /proc have all the exec* syscalls with the same\n-     names.  On the SGI, for example, there is no SYS_exec, but there\n-     *is* a SYS_execv.  So, we try to account for that.  */\n-\n   exitset = XNEW (sysset_t);\n   premptyset (exitset);\n-#ifdef SYS_exec\n-  praddset (exitset, SYS_exec);\n-#endif\n   praddset (exitset, SYS_execve);\n \n   if (!proc_set_traced_sysexit (pi, exitset))\n@@ -3140,22 +2997,22 @@ procfs_set_watchpoint (ptid_t ptid, CORE_ADDR addr, int len, int rwflag,\n     {\n       switch (rwflag) {\t\t/* FIXME: need an enum!  */\n       case hw_write:\t\t/* default watchpoint (write) */\n-\tpflags = WRITE_WATCHFLAG;\n+\tpflags = WA_WRITE;\n \tbreak;\n       case hw_read:\t\t/* read watchpoint */\n-\tpflags = READ_WATCHFLAG;\n+\tpflags = WA_READ;\n \tbreak;\n       case hw_access:\t\t/* access watchpoint */\n-\tpflags = READ_WATCHFLAG | WRITE_WATCHFLAG;\n+\tpflags = WA_READ | WA_WRITE;\n \tbreak;\n       case hw_execute:\t\t/* execution HW breakpoint */\n-\tpflags = EXEC_WATCHFLAG;\n+\tpflags = WA_EXEC;\n \tbreak;\n       default:\t\t\t/* Something weird.  Return error.  */\n \treturn -1;\n       }\n       if (after)\t\t/* Stop after r/w access is completed.  */\n-\tpflags |= AFTER_WATCHFLAG;\n+\tpflags |= WA_TRAPAFTER;\n     }\n \n   if (!proc_set_watchpoint (pi, addr, len, pflags))\n@@ -3174,11 +3031,7 @@ procfs_set_watchpoint (ptid_t ptid, CORE_ADDR addr, int len, int rwflag,\n /* Return non-zero if we can set a hardware watchpoint of type TYPE.  TYPE\n    is one of bp_hardware_watchpoint, bp_read_watchpoint, bp_write_watchpoint,\n    or bp_hardware_watchpoint.  CNT is the number of watchpoints used so\n-   far.\n-\n-   Note:  procfs_can_use_hw_breakpoint() is not yet used by all\n-   procfs.c targets due to the fact that some of them still define\n-   target_can_use_hardware_watchpoint.  */\n+   far.  */\n \n int\n procfs_target::can_use_hw_breakpoint (enum bptype type, int cnt, int othertype)"
    }
  ]
}