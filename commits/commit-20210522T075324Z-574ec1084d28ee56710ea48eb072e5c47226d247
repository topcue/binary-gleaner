{
  "sha": "574ec1084d28ee56710ea48eb072e5c47226d247",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTc0ZWMxMDg0ZDI4ZWU1NjcxMGVhNDhlYjA3MmU1YzQ3MjI2ZDI0Nw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-21T13:04:34Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-22T07:53:24Z"
    },
    "message": "bfd dwarf2 sanity checking\n\nThis patch is aimed at the many places in dwarf2.c that blindly\nincrement a data pointer after calling functions that are meant to\nread a fixed number of bytes.  The problem with that is with damaged\ndwarf we might increment a data pointer past the end of data, which is\nUB and complicates (ie. bugs likely) any further use of that data\npointer.  To fix those problems, I've moved incrementing of the data\npointer into the functions that do the reads.  _bfd_safe_read_leb128\ngets the same treatment for consistency.\n\n\t* libbfd.c (_bfd_safe_read_leb128): Remove length_return parameter.\n\tReplace data pointer with pointer to pointer.  Increment pointer\n\tover bytes read.\n\t* libbfd-in.h (_bfd_safe_read_leb128): Update prototype.\n\t* elf-attrs.c (_bfd_elf_parse_attributes): Adjust to suit.  Be\n\tcareful not to increment data pointer past end.  Remove now\n\tredundant pr17512 check.\n\t* wasm-module.c (READ_LEB128): Adjust to suit changes to\n\t_bfd_safe_read_leb128.\n\t* dwarf2.c (read_n_bytes): New inline function, old one renamed to..\n\t(read_blk): ..this.  Allocate and return block.  Increment bfd_byte**\n\targ.\n\t(read_3_bytes): New function.\n\t(read_1_byte, read_1_signed_byte, read_2_bytes, read_4_bytes),\n\t(read_8_bytes, read_string, read_indirect_string),\n\t(read_indirect_line_string, read_alt_indirect_string): Take a\n\tbyte_byte** arg which is incremented over bytes read.  Remove any\n\tbytes_read return.  Rewrite limit checks to compare lengths\n\trather than pointers.\n\t(read_abbrevs, read_attribute_value, read_formatted_entries),\n\t(decode_line_info, find_abstract_instance, read_ranges),\n\t(read_rnglists, scan_unit_for_symbols, parse_comp_unit),\n\t(stash_comp_unit): Adjust to suit.  Rewrite limit checks to\n\tcompare lengths rather than pointers.\n\t* libbfd.h: Regenerate.",
    "tree": {
      "sha": "896e94db8291202128699acf9feec022f8a25db7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/896e94db8291202128699acf9feec022f8a25db7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/574ec1084d28ee56710ea48eb072e5c47226d247",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/574ec1084d28ee56710ea48eb072e5c47226d247",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/574ec1084d28ee56710ea48eb072e5c47226d247",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/574ec1084d28ee56710ea48eb072e5c47226d247/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1f1fb219fdc4f96fd967e6173e9090c4c4917e96",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f1fb219fdc4f96fd967e6173e9090c4c4917e96",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1f1fb219fdc4f96fd967e6173e9090c4c4917e96"
    }
  ],
  "stats": {
    "total": 701,
    "additions": 289,
    "deletions": 412
  },
  "files": [
    {
      "sha": "a240941eb003410b2ef7e607085ea179b29eaa2a",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=574ec1084d28ee56710ea48eb072e5c47226d247",
      "patch": "@@ -1,3 +1,31 @@\n+2021-05-22  Alan Modra  <amodra@gmail.com>\n+\n+\t* libbfd.c (_bfd_safe_read_leb128): Remove length_return parameter.\n+\tReplace data pointer with pointer to pointer.  Increment pointer\n+\tover bytes read.\n+\t* libbfd-in.h (_bfd_safe_read_leb128): Update prototype.\n+\t* elf-attrs.c (_bfd_elf_parse_attributes): Adjust to suit.  Be\n+\tcareful not to increment data pointer past end.  Remove now\n+\tredundant pr17512 check.\n+\t* wasm-module.c (READ_LEB128): Adjust to suit changes to\n+\t_bfd_safe_read_leb128.\n+\t* dwarf2.c (read_n_bytes): New inline function, old one renamed to..\n+\t(read_blk): ..this.  Allocate and return block.  Increment bfd_byte**\n+\targ.\n+\t(read_3_bytes): New function.\n+\t(read_1_byte, read_1_signed_byte, read_2_bytes, read_4_bytes),\n+\t(read_8_bytes, read_string, read_indirect_string),\n+\t(read_indirect_line_string, read_alt_indirect_string): Take a\n+\tbyte_byte** arg which is incremented over bytes read.  Remove any\n+\tbytes_read return.  Rewrite limit checks to compare lengths\n+\trather than pointers.\n+\t(read_abbrevs, read_attribute_value, read_formatted_entries),\n+\t(decode_line_info, find_abstract_instance, read_ranges),\n+\t(read_rnglists, scan_unit_for_symbols, parse_comp_unit),\n+\t(stash_comp_unit): Adjust to suit.  Rewrite limit checks to\n+\tcompare lengths rather than pointers.\n+\t* libbfd.h: Regenerate.\n+\n 2021-05-21  Luis Machado  <luis.machado@linaro.org>\n \n \t* elf.c (elfcore_make_memtag_note_section): New function."
    },
    {
      "sha": "4b169fca4629bbd1b120b4db131c1d0385d4ffd8",
      "filename": "bfd/dwarf2.c",
      "status": "modified",
      "additions": 233,
      "deletions": 373,
      "changes": 606,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/dwarf2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/dwarf2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf2.c?ref=574ec1084d28ee56710ea48eb072e5c47226d247",
      "patch": "@@ -608,135 +608,149 @@ read_section (bfd *\t      abfd,\n \n /* Read dwarf information from a buffer.  */\n \n+static inline uint64_t\n+read_n_bytes (bfd *abfd, bfd_byte **ptr, bfd_byte *end, int n)\n+{\n+  bfd_byte *buf = *ptr;\n+  if (end - buf < n)\n+    {\n+      *ptr = end;\n+      return 0;\n+    }\n+  *ptr = buf + n;\n+  return bfd_get (n * 8, abfd, buf);\n+}\n+\n static unsigned int\n-read_1_byte (bfd *abfd ATTRIBUTE_UNUSED, bfd_byte *buf, bfd_byte *end)\n+read_1_byte (bfd *abfd, bfd_byte **ptr, bfd_byte *end)\n {\n-  if (buf + 1 > end)\n-    return 0;\n-  return bfd_get_8 (abfd, buf);\n+  return read_n_bytes (abfd, ptr, end, 1);\n }\n \n static int\n-read_1_signed_byte (bfd *abfd ATTRIBUTE_UNUSED, bfd_byte *buf, bfd_byte *end)\n+read_1_signed_byte (bfd *abfd ATTRIBUTE_UNUSED, bfd_byte **ptr, bfd_byte *end)\n {\n-  if (buf + 1 > end)\n-    return 0;\n+  bfd_byte *buf = *ptr;\n+  if (end - buf < 1)\n+    {\n+      *ptr = end;\n+      return 0;\n+    }\n+  *ptr = buf + 1;\n   return bfd_get_signed_8 (abfd, buf);\n }\n \n static unsigned int\n-read_2_bytes (bfd *abfd, bfd_byte *buf, bfd_byte *end)\n+read_2_bytes (bfd *abfd, bfd_byte **ptr, bfd_byte *end)\n {\n-  if (buf + 2 > end)\n-    return 0;\n-  return bfd_get_16 (abfd, buf);\n+  return read_n_bytes (abfd, ptr, end, 2);\n }\n \n static unsigned int\n-read_4_bytes (bfd *abfd, bfd_byte *buf, bfd_byte *end)\n+read_3_bytes (bfd *abfd, bfd_byte **ptr, bfd_byte *end)\n {\n-  if (buf + 4 > end)\n-    return 0;\n-  return bfd_get_32 (abfd, buf);\n+  unsigned int val = read_1_byte (abfd, ptr, end);\n+  val <<= 8;\n+  val |= read_1_byte (abfd, ptr, end);\n+  val <<= 8;\n+  val |= read_1_byte (abfd, ptr, end);\n+  if (bfd_little_endian (abfd))\n+    val = (((val >> 16) & 0xff)\n+\t   | (val & 0xff00)\n+\t   | ((val & 0xff) << 16));\n+  return val;\n }\n \n-static bfd_uint64_t\n-read_8_bytes (bfd *abfd, bfd_byte *buf, bfd_byte *end)\n+static unsigned int\n+read_4_bytes (bfd *abfd, bfd_byte **ptr, bfd_byte *end)\n {\n-  if (buf + 8 > end)\n-    return 0;\n-  return bfd_get_64 (abfd, buf);\n+  return read_n_bytes (abfd, ptr, end, 4);\n }\n \n-static bfd_byte *\n-read_n_bytes (bfd_byte *           buf,\n-\t      bfd_byte *           end,\n-\t      struct dwarf_block * block)\n+static uint64_t\n+read_8_bytes (bfd *abfd, bfd_byte **ptr, bfd_byte *end)\n+{\n+  return read_n_bytes (abfd, ptr, end, 8);\n+}\n+\n+static struct dwarf_block *\n+read_blk (bfd *abfd, bfd_byte **ptr, bfd_byte *end, size_t size)\n {\n-  unsigned int  size = block->size;\n-  bfd_byte *    block_end = buf + size;\n+  bfd_byte *buf = *ptr;\n+  struct dwarf_block *block;\n \n-  if (block_end > end || block_end < buf)\n+  block = (struct dwarf_block *) bfd_alloc (abfd, sizeof (*block));\n+  if (block == NULL)\n+    return NULL;\n+\n+  if (size > (size_t) (end - buf))\n     {\n+      *ptr = end;\n       block->data = NULL;\n       block->size = 0;\n-      return end;\n     }\n   else\n     {\n+      *ptr = buf + size;\n       block->data = buf;\n-      return block_end;\n+      block->size = size;\n     }\n+  return block;\n }\n \n-/* Scans a NUL terminated string starting at BUF, returning a pointer to it.\n-   Returns the number of characters in the string, *including* the NUL byte,\n-   in BYTES_READ_PTR.  This value is set even if the function fails.  Bytes\n-   at or beyond BUF_END will not be read.  Returns NULL if there was a\n-   problem, or if the string is empty.  */\n+/* Scans a NUL terminated string starting at *PTR, returning a pointer to it.\n+   Bytes at or beyond BUF_END will not be read.  Returns NULL if the\n+   terminator is not found or if the string is empty.  *PTR is\n+   incremented over the bytes scanned, including the terminator.  */\n \n static char *\n-read_string (bfd *\t    abfd ATTRIBUTE_UNUSED,\n-\t     bfd_byte *\t    buf,\n-\t     bfd_byte *\t    buf_end,\n-\t     unsigned int * bytes_read_ptr)\n+read_string (bfd_byte **ptr,\n+\t     bfd_byte *buf_end)\n {\n+  bfd_byte *buf = *ptr;\n   bfd_byte *str = buf;\n \n-  if (buf >= buf_end)\n-    {\n-      * bytes_read_ptr = 0;\n-      return NULL;\n-    }\n-\n-  if (*str == '\\0')\n-    {\n-      * bytes_read_ptr = 1;\n-      return NULL;\n-    }\n-\n   while (buf < buf_end)\n-    if (* buf ++ == 0)\n+    if (*buf++ == 0)\n       {\n-\t* bytes_read_ptr = buf - str;\n+\tif (str == buf - 1)\n+\t  break;\n+\t*ptr = buf;\n \treturn (char *) str;\n       }\n \n-  * bytes_read_ptr = buf - str;\n+  *ptr = buf;\n   return NULL;\n }\n \n-/* Reads an offset from BUF and then locates the string at this offset\n+/* Reads an offset from *PTR and then locates the string at this offset\n    inside the debug string section.  Returns a pointer to the string.\n-   Returns the number of bytes read from BUF, *not* the length of the string,\n-   in BYTES_READ_PTR.  This value is set even if the function fails.  Bytes\n-   at or beyond BUF_END will not be read from BUF.  Returns NULL if there was\n-   a problem, or if the string is empty.  Does not check for NUL termination\n-   of the string.  */\n+   Increments *PTR by the number of bytes read for the offset.  This\n+   value is set even if the function fails.  Bytes at or beyond\n+   BUF_END will not be read.  Returns NULL if there was a problem, or\n+   if the string is empty.  Does not check for NUL termination of the\n+   string.  */\n \n static char *\n-read_indirect_string (struct comp_unit * unit,\n-\t\t      bfd_byte *\t buf,\n-\t\t      bfd_byte *\t buf_end,\n-\t\t      unsigned int *\t bytes_read_ptr)\n+read_indirect_string (struct comp_unit *unit,\n+\t\t      bfd_byte **ptr,\n+\t\t      bfd_byte *buf_end)\n {\n   bfd_uint64_t offset;\n   struct dwarf2_debug *stash = unit->stash;\n   struct dwarf2_debug_file *file = unit->file;\n   char *str;\n \n-  if (buf + unit->offset_size > buf_end)\n+  if (unit->offset_size > (size_t) (buf_end - *ptr))\n     {\n-      * bytes_read_ptr = 0;\n+      *ptr = buf_end;\n       return NULL;\n     }\n \n   if (unit->offset_size == 4)\n-    offset = read_4_bytes (unit->abfd, buf, buf_end);\n+    offset = read_4_bytes (unit->abfd, ptr, buf_end);\n   else\n-    offset = read_8_bytes (unit->abfd, buf, buf_end);\n-\n-  *bytes_read_ptr = unit->offset_size;\n+    offset = read_8_bytes (unit->abfd, ptr, buf_end);\n \n   if (! read_section (unit->abfd, &stash->debug_sections[debug_str],\n \t\t      file->syms, offset,\n@@ -752,28 +766,25 @@ read_indirect_string (struct comp_unit * unit,\n /* Like read_indirect_string but from .debug_line_str section.  */\n \n static char *\n-read_indirect_line_string (struct comp_unit * unit,\n-\t\t\t   bfd_byte *\t      buf,\n-\t\t\t   bfd_byte *\t      buf_end,\n-\t\t\t   unsigned int *     bytes_read_ptr)\n+read_indirect_line_string (struct comp_unit *unit,\n+\t\t\t   bfd_byte **ptr,\n+\t\t\t   bfd_byte *buf_end)\n {\n   bfd_uint64_t offset;\n   struct dwarf2_debug *stash = unit->stash;\n   struct dwarf2_debug_file *file = unit->file;\n   char *str;\n \n-  if (buf + unit->offset_size > buf_end)\n+  if (unit->offset_size > (size_t) (buf_end - *ptr))\n     {\n-      * bytes_read_ptr = 0;\n+      *ptr = buf_end;\n       return NULL;\n     }\n \n   if (unit->offset_size == 4)\n-    offset = read_4_bytes (unit->abfd, buf, buf_end);\n+    offset = read_4_bytes (unit->abfd, ptr, buf_end);\n   else\n-    offset = read_8_bytes (unit->abfd, buf, buf_end);\n-\n-  *bytes_read_ptr = unit->offset_size;\n+    offset = read_8_bytes (unit->abfd, ptr, buf_end);\n \n   if (! read_section (unit->abfd, &stash->debug_sections[debug_line_str],\n \t\t      file->syms, offset,\n@@ -792,27 +803,24 @@ read_indirect_line_string (struct comp_unit * unit,\n    Used to impement DW_FORM_GNU_strp_alt.  */\n \n static char *\n-read_alt_indirect_string (struct comp_unit * unit,\n-\t\t\t  bfd_byte *\t     buf,\n-\t\t\t  bfd_byte *\t     buf_end,\n-\t\t\t  unsigned int *     bytes_read_ptr)\n+read_alt_indirect_string (struct comp_unit *unit,\n+\t\t\t  bfd_byte **ptr,\n+\t\t\t  bfd_byte *buf_end)\n {\n   bfd_uint64_t offset;\n   struct dwarf2_debug *stash = unit->stash;\n   char *str;\n \n-  if (buf + unit->offset_size > buf_end)\n+  if (unit->offset_size > (size_t) (buf_end - *ptr))\n     {\n-      * bytes_read_ptr = 0;\n+      *ptr = buf_end;\n       return NULL;\n     }\n \n   if (unit->offset_size == 4)\n-    offset = read_4_bytes (unit->abfd, buf, buf_end);\n+    offset = read_4_bytes (unit->abfd, ptr, buf_end);\n   else\n-    offset = read_8_bytes (unit->abfd, buf, buf_end);\n-\n-  *bytes_read_ptr = unit->offset_size;\n+    offset = read_8_bytes (unit->abfd, ptr, buf_end);\n \n   if (stash->alt.bfd_ptr == NULL)\n     {\n@@ -893,16 +901,21 @@ read_alt_indirect_ref (struct comp_unit * unit,\n }\n \n static bfd_uint64_t\n-read_address (struct comp_unit *unit, bfd_byte *buf, bfd_byte * buf_end)\n+read_address (struct comp_unit *unit, bfd_byte **ptr, bfd_byte *buf_end)\n {\n+  bfd_byte *buf = *ptr;\n   int signed_vma = 0;\n \n   if (bfd_get_flavour (unit->abfd) == bfd_target_elf_flavour)\n     signed_vma = get_elf_backend_data (unit->abfd)->sign_extend_vma;\n \n-  if (buf + unit->addr_size > buf_end)\n-    return 0;\n+  if (unit->addr_size > (size_t) (buf_end - buf))\n+    {\n+      *ptr = buf_end;\n+      return 0;\n+    }\n \n+  *ptr = buf + unit->addr_size;\n   if (signed_vma)\n     {\n       switch (unit->addr_size)\n@@ -1013,7 +1026,7 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,\n   bfd_byte *abbrev_ptr;\n   bfd_byte *abbrev_end;\n   struct abbrev_info *cur_abbrev;\n-  unsigned int abbrev_number, bytes_read, abbrev_name;\n+  unsigned int abbrev_number, abbrev_name;\n   unsigned int abbrev_form, hash_number;\n   size_t amt;\n   void **slot;\n@@ -1041,9 +1054,8 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,\n \n   abbrev_ptr = file->dwarf_abbrev_buffer + offset;\n   abbrev_end = file->dwarf_abbrev_buffer + file->dwarf_abbrev_size;\n-  abbrev_number = _bfd_safe_read_leb128 (abfd, abbrev_ptr, &bytes_read,\n+  abbrev_number = _bfd_safe_read_leb128 (abfd, &abbrev_ptr,\n \t\t\t\t\t false, abbrev_end);\n-  abbrev_ptr += bytes_read;\n \n   /* Loop until we reach an abbrev number of 0.  */\n   while (abbrev_number)\n@@ -1056,32 +1068,23 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,\n       /* Read in abbrev header.  */\n       cur_abbrev->number = abbrev_number;\n       cur_abbrev->tag = (enum dwarf_tag)\n-\t_bfd_safe_read_leb128 (abfd, abbrev_ptr, &bytes_read,\n+\t_bfd_safe_read_leb128 (abfd, &abbrev_ptr,\n \t\t\t       false, abbrev_end);\n-      abbrev_ptr += bytes_read;\n-      cur_abbrev->has_children = read_1_byte (abfd, abbrev_ptr, abbrev_end);\n-      abbrev_ptr += 1;\n+      cur_abbrev->has_children = read_1_byte (abfd, &abbrev_ptr, abbrev_end);\n \n       /* Now read in declarations.  */\n       for (;;)\n \t{\n \t  /* Initialize it just to avoid a GCC false warning.  */\n \t  bfd_vma implicit_const = -1;\n \n-\t  abbrev_name = _bfd_safe_read_leb128 (abfd, abbrev_ptr, &bytes_read,\n+\t  abbrev_name = _bfd_safe_read_leb128 (abfd, &abbrev_ptr,\n \t\t\t\t\t       false, abbrev_end);\n-\t  abbrev_ptr += bytes_read;\n-\t  abbrev_form = _bfd_safe_read_leb128 (abfd, abbrev_ptr, &bytes_read,\n+\t  abbrev_form = _bfd_safe_read_leb128 (abfd, &abbrev_ptr,\n \t\t\t\t\t       false, abbrev_end);\n-\t  abbrev_ptr += bytes_read;\n \t  if (abbrev_form == DW_FORM_implicit_const)\n-\t    {\n-\t      implicit_const = _bfd_safe_read_leb128 (abfd, abbrev_ptr,\n-\t\t\t\t\t\t      &bytes_read, true,\n-\t\t\t\t\t\t      abbrev_end);\n-\t      abbrev_ptr += bytes_read;\n-\t    }\n-\n+\t    implicit_const = _bfd_safe_read_leb128 (abfd, &abbrev_ptr,\n+\t\t\t\t\t\t    true, abbrev_end);\n \t  if (abbrev_name == 0)\n \t    break;\n \n@@ -1120,9 +1123,8 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,\n       if ((size_t) (abbrev_ptr - file->dwarf_abbrev_buffer)\n \t  >= file->dwarf_abbrev_size)\n \tbreak;\n-      abbrev_number = _bfd_safe_read_leb128 (abfd, abbrev_ptr,\n-\t\t\t\t\t     &bytes_read, false, abbrev_end);\n-      abbrev_ptr += bytes_read;\n+      abbrev_number = _bfd_safe_read_leb128 (abfd, &abbrev_ptr,\n+\t\t\t\t\t     false, abbrev_end);\n       if (lookup_abbrev (abbrev_number, abbrevs) != NULL)\n \tbreak;\n     }\n@@ -1191,8 +1193,6 @@ read_attribute_value (struct attribute *  attr,\n \t\t      bfd_byte *\t  info_ptr_end)\n {\n   bfd *abfd = unit->abfd;\n-  unsigned int bytes_read;\n-  struct dwarf_block *blk;\n   size_t amt;\n \n   if (info_ptr >= info_ptr_end && form != DW_FORM_flag_present)\n@@ -1215,161 +1215,120 @@ read_attribute_value (struct attribute *  attr,\n       if (unit->version >= 3)\n \t{\n \t  if (unit->offset_size == 4)\n-\t    attr->u.val = read_4_bytes (unit->abfd, info_ptr, info_ptr_end);\n+\t    attr->u.val = read_4_bytes (unit->abfd, &info_ptr, info_ptr_end);\n \t  else\n-\t    attr->u.val = read_8_bytes (unit->abfd, info_ptr, info_ptr_end);\n-\t  info_ptr += unit->offset_size;\n+\t    attr->u.val = read_8_bytes (unit->abfd, &info_ptr, info_ptr_end);\n \t  break;\n \t}\n       /* FALLTHROUGH */\n     case DW_FORM_addr:\n-      attr->u.val = read_address (unit, info_ptr, info_ptr_end);\n-      info_ptr += unit->addr_size;\n+      attr->u.val = read_address (unit, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_GNU_ref_alt:\n     case DW_FORM_sec_offset:\n       if (unit->offset_size == 4)\n-\tattr->u.val = read_4_bytes (unit->abfd, info_ptr, info_ptr_end);\n+\tattr->u.val = read_4_bytes (unit->abfd, &info_ptr, info_ptr_end);\n       else\n-\tattr->u.val = read_8_bytes (unit->abfd, info_ptr, info_ptr_end);\n-      info_ptr += unit->offset_size;\n+\tattr->u.val = read_8_bytes (unit->abfd, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_block2:\n-      amt = sizeof (struct dwarf_block);\n-      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);\n-      if (blk == NULL)\n+      amt = read_2_bytes (abfd, &info_ptr, info_ptr_end);\n+      attr->u.blk = read_blk (abfd, &info_ptr, info_ptr_end, amt);\n+      if (attr->u.blk == NULL)\n \treturn NULL;\n-      blk->size = read_2_bytes (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 2;\n-      info_ptr = read_n_bytes (info_ptr, info_ptr_end, blk);\n-      attr->u.blk = blk;\n       break;\n     case DW_FORM_block4:\n-      amt = sizeof (struct dwarf_block);\n-      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);\n-      if (blk == NULL)\n+      amt = read_4_bytes (abfd, &info_ptr, info_ptr_end);\n+      attr->u.blk = read_blk (abfd, &info_ptr, info_ptr_end, amt);\n+      if (attr->u.blk == NULL)\n \treturn NULL;\n-      blk->size = read_4_bytes (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 4;\n-      info_ptr = read_n_bytes (info_ptr, info_ptr_end, blk);\n-      attr->u.blk = blk;\n       break;\n     case DW_FORM_ref1:\n     case DW_FORM_flag:\n     case DW_FORM_data1:\n     case DW_FORM_addrx1:\n-      attr->u.val = read_1_byte (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 1;\n+      attr->u.val = read_1_byte (abfd, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_data2:\n     case DW_FORM_ref2:\n-      attr->u.val = read_2_bytes (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 2;\n+      attr->u.val = read_2_bytes (abfd, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_addrx3:\n-      attr->u.val = read_4_bytes (abfd, info_ptr, info_ptr_end);\n-      attr->u.val &= 0xffffff;\n-      info_ptr += 3;\n+      attr->u.val = read_3_bytes (abfd, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_ref4:\n     case DW_FORM_data4:\n     case DW_FORM_addrx4:\n-      attr->u.val = read_4_bytes (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 4;\n+      attr->u.val = read_4_bytes (abfd, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_data8:\n     case DW_FORM_ref8:\n     case DW_FORM_ref_sig8:\n-      attr->u.val = read_8_bytes (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 8;\n+      attr->u.val = read_8_bytes (abfd, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_string:\n-      attr->u.str = read_string (abfd, info_ptr, info_ptr_end, &bytes_read);\n-      info_ptr += bytes_read;\n+      attr->u.str = read_string (&info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_strp:\n-      attr->u.str = read_indirect_string (unit, info_ptr, info_ptr_end, &bytes_read);\n-      info_ptr += bytes_read;\n+      attr->u.str = read_indirect_string (unit, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_line_strp:\n-      attr->u.str = read_indirect_line_string (unit, info_ptr, info_ptr_end, &bytes_read);\n-      info_ptr += bytes_read;\n+      attr->u.str = read_indirect_line_string (unit, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_GNU_strp_alt:\n-      attr->u.str = read_alt_indirect_string (unit, info_ptr, info_ptr_end, &bytes_read);\n-      info_ptr += bytes_read;\n+      attr->u.str = read_alt_indirect_string (unit, &info_ptr, info_ptr_end);\n       break;\n     case DW_FORM_strx1:\n-      attr->u.val = read_1_byte (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 1;\n+      attr->u.val = read_1_byte (abfd, &info_ptr, info_ptr_end);\n       attr->u.str = (char *) read_indexed_string (attr->u.val, unit);\n       break;\n     case DW_FORM_strx2:\n-      attr->u.val = read_2_bytes (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 2;\n+      attr->u.val = read_2_bytes (abfd, &info_ptr, info_ptr_end);\n       attr->u.str = (char *) read_indexed_string (attr->u.val, unit);\n       break;\n     case DW_FORM_strx3:\n-      attr->u.val = read_4_bytes (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 3;\n-      attr->u.val &= 0xffffff;\n+      attr->u.val = read_3_bytes (abfd, &info_ptr, info_ptr_end);\n       attr->u.str = (char *) read_indexed_string (attr->u.val, unit);\n       break;\n     case DW_FORM_strx4:\n-      attr->u.val = read_4_bytes (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 4;\n+      attr->u.val = read_4_bytes (abfd, &info_ptr, info_ptr_end);\n       attr->u.str = (char *) read_indexed_string (attr->u.val, unit);\n       break;\n     case DW_FORM_strx:\n-      attr->u.val = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n-\t\t\t\t\t false, info_ptr_end);\n-      info_ptr += bytes_read;\n+      attr->u.val = _bfd_safe_read_leb128 (abfd, &info_ptr,\n+\t\t\t\t\t   false, info_ptr_end);\n       attr->u.str = (char *) read_indexed_string (attr->u.val, unit);\n       break;\n     case DW_FORM_exprloc:\n     case DW_FORM_block:\n-      amt = sizeof (struct dwarf_block);\n-      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);\n-      if (blk == NULL)\n+      amt = _bfd_safe_read_leb128 (abfd, &info_ptr,\n+\t\t\t\t   false, info_ptr_end);\n+      attr->u.blk = read_blk (abfd, &info_ptr, info_ptr_end, amt);\n+      if (attr->u.blk == NULL)\n \treturn NULL;\n-      blk->size = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n-\t\t\t\t\t false, info_ptr_end);\n-      info_ptr += bytes_read;\n-      info_ptr = read_n_bytes (info_ptr, info_ptr_end, blk);\n-      attr->u.blk = blk;\n       break;\n     case DW_FORM_block1:\n-      amt = sizeof (struct dwarf_block);\n-      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);\n-      if (blk == NULL)\n+      amt = read_1_byte (abfd, &info_ptr, info_ptr_end);\n+      attr->u.blk = read_blk (abfd, &info_ptr, info_ptr_end, amt);\n+      if (attr->u.blk == NULL)\n \treturn NULL;\n-      blk->size = read_1_byte (abfd, info_ptr, info_ptr_end);\n-      info_ptr += 1;\n-      info_ptr = read_n_bytes (info_ptr, info_ptr_end, blk);\n-      attr->u.blk = blk;\n       break;\n     case DW_FORM_sdata:\n-      attr->u.sval = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n+      attr->u.sval = _bfd_safe_read_leb128 (abfd, &info_ptr,\n \t\t\t\t\t    true, info_ptr_end);\n-      info_ptr += bytes_read;\n       break;\n     case DW_FORM_ref_udata:\n     case DW_FORM_udata:\n     case DW_FORM_addrx:\n-      attr->u.val = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n+      attr->u.val = _bfd_safe_read_leb128 (abfd, &info_ptr,\n \t\t\t\t\t   false, info_ptr_end);\n-      info_ptr += bytes_read;\n       break;\n     case DW_FORM_indirect:\n-      form = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n+      form = _bfd_safe_read_leb128 (abfd, &info_ptr,\n \t\t\t\t    false, info_ptr_end);\n-      info_ptr += bytes_read;\n       if (form == DW_FORM_implicit_const)\n-\t{\n-\t  implicit_const = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n-\t\t\t\t\t\t  true, info_ptr_end);\n-\t  info_ptr += bytes_read;\n-\t}\n+\timplicit_const = _bfd_safe_read_leb128 (abfd, &info_ptr,\n+\t\t\t\t\t\ttrue, info_ptr_end);\n       info_ptr = read_attribute_value (attr, form, implicit_const, unit,\n \t\t\t\t       info_ptr, info_ptr_end);\n       break;\n@@ -1380,13 +1339,9 @@ read_attribute_value (struct attribute *  attr,\n     case DW_FORM_data16:\n       /* This is really a \"constant\", but there is no way to store that\n          so pretend it is a 16 byte block instead.  */\n-      amt = sizeof (struct dwarf_block);\n-      blk = (struct dwarf_block *) bfd_alloc (abfd, amt);\n-      if (blk == NULL)\n+      attr->u.blk = read_blk (abfd, &info_ptr, info_ptr_end, 16);\n+      if (attr->u.blk == NULL)\n \treturn NULL;\n-      blk->size = 16;\n-      info_ptr = read_n_bytes (info_ptr, info_ptr_end, blk);\n-      attr->u.blk = blk;\n       break;\n \n     default:\n@@ -2036,21 +1991,16 @@ read_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,\n   bfd_vma data_count, datai;\n   bfd_byte *buf = *bufp;\n   bfd_byte *format_header_data;\n-  unsigned int bytes_read;\n \n-  format_count = read_1_byte (abfd, buf, buf_end);\n-  buf += 1;\n+  format_count = read_1_byte (abfd, &buf, buf_end);\n   format_header_data = buf;\n   for (formati = 0; formati < format_count; formati++)\n     {\n-      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, false, buf_end);\n-      buf += bytes_read;\n-      _bfd_safe_read_leb128 (abfd, buf, &bytes_read, false, buf_end);\n-      buf += bytes_read;\n+      _bfd_safe_read_leb128 (abfd, &buf, false, buf_end);\n+      _bfd_safe_read_leb128 (abfd, &buf, false, buf_end);\n     }\n \n-  data_count = _bfd_safe_read_leb128 (abfd, buf, &bytes_read, false, buf_end);\n-  buf += bytes_read;\n+  data_count = _bfd_safe_read_leb128 (abfd, &buf, false, buf_end);\n   if (format_count == 0 && data_count != 0)\n     {\n       _bfd_error_handler (_(\"DWARF error: zero format count\"));\n@@ -2083,9 +2033,7 @@ read_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,\n \t  unsigned int uint_trash, *uintp = &uint_trash;\n \t  struct attribute attr;\n \n-\t  content_type = _bfd_safe_read_leb128 (abfd, format, &bytes_read,\n-\t\t\t\t\t\tfalse, buf_end);\n-\t  format += bytes_read;\n+\t  content_type = _bfd_safe_read_leb128 (abfd, &format, false, buf_end);\n \t  switch (content_type)\n \t    {\n \t    case DW_LNCT_path:\n@@ -2110,10 +2058,7 @@ read_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,\n \t      return false;\n \t    }\n \n-\t  form = _bfd_safe_read_leb128 (abfd, format, &bytes_read, false,\n-\t\t\t\t\tbuf_end);\n-\t  format += bytes_read;\n-\n+\t  form = _bfd_safe_read_leb128 (abfd, &format, false, buf_end);\n \t  buf = read_attribute_value (&attr, form, 0, unit, buf, buf_end);\n \t  if (buf == NULL)\n \t    return false;\n@@ -2160,7 +2105,7 @@ decode_line_info (struct comp_unit *unit)\n   bfd_byte *line_ptr;\n   bfd_byte *line_end;\n   struct line_head lh;\n-  unsigned int i, bytes_read, offset_size;\n+  unsigned int i, offset_size;\n   char *cur_file, *cur_dir;\n   unsigned char op_code, extended_op, adj_opcode;\n   unsigned int exop_len;\n@@ -2186,20 +2131,17 @@ decode_line_info (struct comp_unit *unit)\n   line_end = file->dwarf_line_buffer + file->dwarf_line_size;\n \n   /* Read in the prologue.  */\n-  lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n-  line_ptr += 4;\n+  lh.total_length = read_4_bytes (abfd, &line_ptr, line_end);\n   offset_size = 4;\n   if (lh.total_length == 0xffffffff)\n     {\n-      lh.total_length = read_8_bytes (abfd, line_ptr, line_end);\n-      line_ptr += 8;\n+      lh.total_length = read_8_bytes (abfd, &line_ptr, line_end);\n       offset_size = 8;\n     }\n   else if (lh.total_length == 0 && unit->addr_size == 8)\n     {\n       /* Handle (non-standard) 64-bit DWARF2 formats.  */\n-      lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n-      line_ptr += 4;\n+      lh.total_length = read_4_bytes (abfd, &line_ptr, line_end);\n       offset_size = 8;\n     }\n \n@@ -2216,15 +2158,14 @@ decode_line_info (struct comp_unit *unit)\n \n   line_end = line_ptr + lh.total_length;\n \n-  lh.version = read_2_bytes (abfd, line_ptr, line_end);\n+  lh.version = read_2_bytes (abfd, &line_ptr, line_end);\n   if (lh.version < 2 || lh.version > 5)\n     {\n       _bfd_error_handler\n \t(_(\"DWARF error: unhandled .debug_line version %d\"), lh.version);\n       bfd_set_error (bfd_error_bad_value);\n       return NULL;\n     }\n-  line_ptr += 2;\n \n   if (line_ptr + offset_size + (lh.version >= 5 ? 8 : (lh.version >= 4 ? 6 : 5))\n       >= line_end)\n@@ -2240,11 +2181,9 @@ decode_line_info (struct comp_unit *unit)\n       unsigned int segment_selector_size;\n \n       /* Skip address size.  */\n-      read_1_byte (abfd, line_ptr, line_end);\n-      line_ptr += 1;\n+      read_1_byte (abfd, &line_ptr, line_end);\n \n-      segment_selector_size = read_1_byte (abfd, line_ptr, line_end);\n-      line_ptr += 1;\n+      segment_selector_size = read_1_byte (abfd, &line_ptr, line_end);\n       if (segment_selector_size != 0)\n \t{\n \t  _bfd_error_handler\n@@ -2256,19 +2195,14 @@ decode_line_info (struct comp_unit *unit)\n     }\n \n   if (offset_size == 4)\n-    lh.prologue_length = read_4_bytes (abfd, line_ptr, line_end);\n+    lh.prologue_length = read_4_bytes (abfd, &line_ptr, line_end);\n   else\n-    lh.prologue_length = read_8_bytes (abfd, line_ptr, line_end);\n-  line_ptr += offset_size;\n+    lh.prologue_length = read_8_bytes (abfd, &line_ptr, line_end);\n \n-  lh.minimum_instruction_length = read_1_byte (abfd, line_ptr, line_end);\n-  line_ptr += 1;\n+  lh.minimum_instruction_length = read_1_byte (abfd, &line_ptr, line_end);\n \n   if (lh.version >= 4)\n-    {\n-      lh.maximum_ops_per_insn = read_1_byte (abfd, line_ptr, line_end);\n-      line_ptr += 1;\n-    }\n+    lh.maximum_ops_per_insn = read_1_byte (abfd, &line_ptr, line_end);\n   else\n     lh.maximum_ops_per_insn = 1;\n \n@@ -2280,17 +2214,10 @@ decode_line_info (struct comp_unit *unit)\n       return NULL;\n     }\n \n-  lh.default_is_stmt = read_1_byte (abfd, line_ptr, line_end);\n-  line_ptr += 1;\n-\n-  lh.line_base = read_1_signed_byte (abfd, line_ptr, line_end);\n-  line_ptr += 1;\n-\n-  lh.line_range = read_1_byte (abfd, line_ptr, line_end);\n-  line_ptr += 1;\n-\n-  lh.opcode_base = read_1_byte (abfd, line_ptr, line_end);\n-  line_ptr += 1;\n+  lh.default_is_stmt = read_1_byte (abfd, &line_ptr, line_end);\n+  lh.line_base = read_1_signed_byte (abfd, &line_ptr, line_end);\n+  lh.line_range = read_1_byte (abfd, &line_ptr, line_end);\n+  lh.opcode_base = read_1_byte (abfd, &line_ptr, line_end);\n \n   if (line_ptr + (lh.opcode_base - 1) >= line_end)\n     {\n@@ -2305,10 +2232,7 @@ decode_line_info (struct comp_unit *unit)\n   lh.standard_opcode_lengths[0] = 1;\n \n   for (i = 1; i < lh.opcode_base; ++i)\n-    {\n-      lh.standard_opcode_lengths[i] = read_1_byte (abfd, line_ptr, line_end);\n-      line_ptr += 1;\n-    }\n+    lh.standard_opcode_lengths[i] = read_1_byte (abfd, &line_ptr, line_end);\n \n   amt = sizeof (struct line_info_table);\n   table = (struct line_info_table *) bfd_alloc (abfd, amt);\n@@ -2343,35 +2267,24 @@ decode_line_info (struct comp_unit *unit)\n   else\n     {\n       /* Read directory table.  */\n-      while ((cur_dir = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n+      while ((cur_dir = read_string (&line_ptr, line_end)) != NULL)\n \t{\n-\t  line_ptr += bytes_read;\n-\n \t  if (!line_info_add_include_dir (table, cur_dir))\n \t    goto fail;\n \t}\n \n-      line_ptr += bytes_read;\n-\n       /* Read file name table.  */\n-      while ((cur_file = read_string (abfd, line_ptr, line_end, &bytes_read)) != NULL)\n+      while ((cur_file = read_string (&line_ptr, line_end)) != NULL)\n \t{\n \t  unsigned int dir, xtime, size;\n \n-\t  line_ptr += bytes_read;\n-\n-\t  dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, false, line_end);\n-\t  line_ptr += bytes_read;\n-\t  xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, false, line_end);\n-\t  line_ptr += bytes_read;\n-\t  size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read, false, line_end);\n-\t  line_ptr += bytes_read;\n+\t  dir = _bfd_safe_read_leb128 (abfd, &line_ptr, false, line_end);\n+\t  xtime = _bfd_safe_read_leb128 (abfd, &line_ptr, false, line_end);\n+\t  size = _bfd_safe_read_leb128 (abfd, &line_ptr, false, line_end);\n \n \t  if (!line_info_add_file_name (table, cur_file, dir, xtime, size))\n \t    goto fail;\n \t}\n-\n-      line_ptr += bytes_read;\n     }\n \n   /* Read the statement sequences until there's nothing left.  */\n@@ -2398,8 +2311,7 @@ decode_line_info (struct comp_unit *unit)\n       /* Decode the table.  */\n       while (!end_sequence && line_ptr < line_end)\n \t{\n-\t  op_code = read_1_byte (abfd, line_ptr, line_end);\n-\t  line_ptr += 1;\n+\t  op_code = read_1_byte (abfd, &line_ptr, line_end);\n \n \t  if (op_code >= lh.opcode_base)\n \t    {\n@@ -2432,11 +2344,9 @@ decode_line_info (struct comp_unit *unit)\n \t  else switch (op_code)\n \t    {\n \t    case DW_LNS_extended_op:\n-\t      exop_len = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t      exop_len = _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t\tfalse, line_end);\n-\t      line_ptr += bytes_read;\n-\t      extended_op = read_1_byte (abfd, line_ptr, line_end);\n-\t      line_ptr += 1;\n+\t      extended_op = read_1_byte (abfd, &line_ptr, line_end);\n \n \t      switch (extended_op)\n \t\t{\n@@ -2454,31 +2364,25 @@ decode_line_info (struct comp_unit *unit)\n \t\t    goto line_fail;\n \t\t  break;\n \t\tcase DW_LNE_set_address:\n-\t\t  address = read_address (unit, line_ptr, line_end);\n+\t\t  address = read_address (unit, &line_ptr, line_end);\n \t\t  op_index = 0;\n-\t\t  line_ptr += unit->addr_size;\n \t\t  break;\n \t\tcase DW_LNE_define_file:\n-\t\t  cur_file = read_string (abfd, line_ptr, line_end, &bytes_read);\n-\t\t  line_ptr += bytes_read;\n-\t\t  dir = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t\t  cur_file = read_string (&line_ptr, line_end);\n+\t\t  dir = _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t       false, line_end);\n-\t\t  line_ptr += bytes_read;\n-\t\t  xtime = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t\t  xtime = _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t\t false, line_end);\n-\t\t  line_ptr += bytes_read;\n-\t\t  size = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t\t  size = _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t\tfalse, line_end);\n-\t\t  line_ptr += bytes_read;\n \t\t  if (!line_info_add_file_name (table, cur_file, dir,\n \t\t\t\t\t\txtime, size))\n \t\t    goto line_fail;\n \t\t  break;\n \t\tcase DW_LNE_set_discriminator:\n \t\t  discriminator =\n-\t\t    _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t\t    _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t   false, line_end);\n-\t\t  line_ptr += bytes_read;\n \t\t  break;\n \t\tcase DW_LNE_HP_source_file_correlation:\n \t\t  line_ptr += exop_len - 1;\n@@ -2505,42 +2409,36 @@ decode_line_info (struct comp_unit *unit)\n \t    case DW_LNS_advance_pc:\n \t      if (lh.maximum_ops_per_insn == 1)\n \t\taddress += (lh.minimum_instruction_length\n-\t\t\t    * _bfd_safe_read_leb128 (abfd, line_ptr,\n-\t\t\t\t\t\t     &bytes_read,\n+\t\t\t    * _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t\t     false, line_end));\n \t      else\n \t\t{\n-\t\t  bfd_vma adjust = _bfd_safe_read_leb128 (abfd, line_ptr,\n-\t\t\t\t\t\t\t  &bytes_read,\n+\t\t  bfd_vma adjust = _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t\t\t  false, line_end);\n \t\t  address = ((op_index + adjust) / lh.maximum_ops_per_insn\n \t\t\t     * lh.minimum_instruction_length);\n \t\t  op_index = (op_index + adjust) % lh.maximum_ops_per_insn;\n \t\t}\n-\t      line_ptr += bytes_read;\n \t      break;\n \t    case DW_LNS_advance_line:\n-\t      line += _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t      line += _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t     true, line_end);\n-\t      line_ptr += bytes_read;\n \t      break;\n \t    case DW_LNS_set_file:\n \t      {\n \t\tunsigned int filenum;\n \n \t\t/* The file and directory tables are 0\n \t\t   based, the references are 1 based.  */\n-\t\tfilenum = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t\tfilenum = _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t\t false, line_end);\n-\t\tline_ptr += bytes_read;\n \t\tfree (filename);\n \t\tfilename = concat_filename (table, filenum);\n \t\tbreak;\n \t      }\n \t    case DW_LNS_set_column:\n-\t      column = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t      column = _bfd_safe_read_leb128 (abfd, &line_ptr,\n \t\t\t\t\t      false, line_end);\n-\t      line_ptr += bytes_read;\n \t      break;\n \t    case DW_LNS_negate_stmt:\n \t      is_stmt = (!is_stmt);\n@@ -2563,18 +2461,14 @@ decode_line_info (struct comp_unit *unit)\n \t\t}\n \t      break;\n \t    case DW_LNS_fixed_advance_pc:\n-\t      address += read_2_bytes (abfd, line_ptr, line_end);\n+\t      address += read_2_bytes (abfd, &line_ptr, line_end);\n \t      op_index = 0;\n-\t      line_ptr += 2;\n \t      break;\n \t    default:\n \t      /* Unknown standard opcode, ignore it.  */\n \t      for (i = 0; i < lh.standard_opcode_lengths[op_code]; i++)\n-\t\t{\n-\t\t  (void) _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n-\t\t\t\t\t\tfalse, line_end);\n-\t\t  line_ptr += bytes_read;\n-\t\t}\n+\t\t(void) _bfd_safe_read_leb128 (abfd, &line_ptr,\n+\t\t\t\t\t      false, line_end);\n \t      break;\n \t    }\n \t}\n@@ -2974,7 +2868,7 @@ find_abstract_instance (struct comp_unit *unit,\n   bfd *abfd = unit->abfd;\n   bfd_byte *info_ptr = NULL;\n   bfd_byte *info_ptr_end;\n-  unsigned int abbrev_number, bytes_read, i;\n+  unsigned int abbrev_number, i;\n   struct abbrev_info *abbrev;\n   bfd_uint64_t die_ref = attr_ptr->u.val;\n   struct attribute attr;\n@@ -3118,10 +3012,8 @@ find_abstract_instance (struct comp_unit *unit,\n       info_ptr += die_ref;\n     }\n \n-  abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n+  abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n \t\t\t\t\t false, info_ptr_end);\n-  info_ptr += bytes_read;\n-\n   if (abbrev_number)\n     {\n       abbrev = lookup_abbrev (abbrev_number, unit->abbrevs);\n@@ -3212,13 +3104,11 @@ read_ranges (struct comp_unit *unit, struct arange *arange,\n       bfd_vma high_pc;\n \n       /* PR 17512: file: 62cada7d.  */\n-      if (ranges_ptr + 2 * unit->addr_size > ranges_end)\n+      if (2 * unit->addr_size > (size_t) (ranges_end - ranges_ptr))\n \treturn false;\n \n-      low_pc = read_address (unit, ranges_ptr, ranges_end);\n-      ranges_ptr += unit->addr_size;\n-      high_pc = read_address (unit, ranges_ptr, ranges_end);\n-      ranges_ptr += unit->addr_size;\n+      low_pc = read_address (unit, &ranges_ptr, ranges_end);\n+      high_pc = read_address (unit, &ranges_ptr, ranges_end);\n \n       if (low_pc == 0 && high_pc == 0)\n \tbreak;\n@@ -3260,55 +3150,46 @@ read_rnglists (struct comp_unit *unit, struct arange *arange,\n   for (;;)\n     {\n       enum dwarf_range_list_entry rlet;\n-      unsigned int bytes_read;\n \n-      if (rngs_ptr + 1 > rngs_end)\n+      if (rngs_ptr >= rngs_end)\n \treturn false;\n \n-      rlet = read_1_byte (abfd, rngs_ptr, rngs_end);\n-      rngs_ptr++;\n+      rlet = read_1_byte (abfd, &rngs_ptr, rngs_end);\n \n       switch (rlet)\n \t{\n \tcase DW_RLE_end_of_list:\n \t  return true;\n \n \tcase DW_RLE_base_address:\n-\t  if (rngs_ptr + unit->addr_size > rngs_end)\n+\t  if (unit->addr_size > (size_t) (rngs_end - rngs_ptr))\n \t    return false;\n-\t  base_address = read_address (unit, rngs_ptr, rngs_end);\n-\t  rngs_ptr += unit->addr_size;\n+\t  base_address = read_address (unit, &rngs_ptr, rngs_end);\n \t  continue;\n \n \tcase DW_RLE_start_length:\n-\t  if (rngs_ptr + unit->addr_size > rngs_end)\n+\t  if (unit->addr_size > (size_t) (rngs_end - rngs_ptr))\n \t    return false;\n-\t  low_pc = read_address (unit, rngs_ptr, rngs_end);\n-\t  rngs_ptr += unit->addr_size;\n+\t  low_pc = read_address (unit, &rngs_ptr, rngs_end);\n \t  high_pc = low_pc;\n-\t  high_pc += _bfd_safe_read_leb128 (abfd, rngs_ptr, &bytes_read,\n+\t  high_pc += _bfd_safe_read_leb128 (abfd, &rngs_ptr,\n \t\t\t\t\t    false, rngs_end);\n-\t  rngs_ptr += bytes_read;\n \t  break;\n \n \tcase DW_RLE_offset_pair:\n \t  low_pc = base_address;\n-\t  low_pc += _bfd_safe_read_leb128 (abfd, rngs_ptr, &bytes_read,\n+\t  low_pc += _bfd_safe_read_leb128 (abfd, &rngs_ptr,\n \t\t\t\t\t   false, rngs_end);\n-\t  rngs_ptr += bytes_read;\n \t  high_pc = base_address;\n-\t  high_pc += _bfd_safe_read_leb128 (abfd, rngs_ptr, &bytes_read,\n+\t  high_pc += _bfd_safe_read_leb128 (abfd, &rngs_ptr,\n \t\t\t\t\t    false, rngs_end);\n-\t  rngs_ptr += bytes_read;\n \t  break;\n \n \tcase DW_RLE_start_end:\n-\t  if (rngs_ptr + 2 * unit->addr_size > rngs_end)\n+\t  if (2 * unit->addr_size > (size_t) (rngs_end - rngs_ptr))\n \t    return false;\n-\t  low_pc = read_address (unit, rngs_ptr, rngs_end);\n-\t  rngs_ptr += unit->addr_size;\n-\t  high_pc = read_address (unit, rngs_ptr, rngs_end);\n-\t  rngs_ptr += unit->addr_size;\n+\t  low_pc = read_address (unit, &rngs_ptr, rngs_end);\n+\t  high_pc = read_address (unit, &rngs_ptr, rngs_end);\n \t  break;\n \n \t/* TODO x-variants need .debug_addr support used for split-dwarf.  */\n@@ -3390,7 +3271,7 @@ scan_unit_for_symbols (struct comp_unit *unit)\n      functions/variables and augment the table entries.  */\n   while (nesting_level >= 0)\n     {\n-      unsigned int abbrev_number, bytes_read, i;\n+      unsigned int abbrev_number, i;\n       struct abbrev_info *abbrev;\n       struct funcinfo *func;\n       struct varinfo *var;\n@@ -3401,10 +3282,8 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \tgoto fail;\n \n       current_offset = info_ptr - unit->info_ptr_unit;\n-      abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n+      abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n \t\t\t\t\t     false, info_ptr_end);\n-      info_ptr += bytes_read;\n-\n       if (abbrev_number == 0)\n \t{\n \t  nesting_level--;\n@@ -3516,7 +3395,7 @@ scan_unit_for_symbols (struct comp_unit *unit)\n   \n   while (nesting_level >= 0)\n     {\n-      unsigned int abbrev_number, bytes_read, i;\n+      unsigned int abbrev_number, i;\n       struct abbrev_info *abbrev;\n       struct attribute attr;\n       struct funcinfo *func;\n@@ -3531,10 +3410,8 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \tgoto fail;\n \n       current_offset = info_ptr - unit->info_ptr_unit;\n-      abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n+      abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n \t\t\t\t\t     false, info_ptr_end);\n-      info_ptr += bytes_read;\n-\n       if (! abbrev_number)\n \t{\n \t  nesting_level--;\n@@ -3773,7 +3650,7 @@ parse_comp_unit (struct dwarf2_debug *stash,\n   /* Initialize it just to avoid a GCC false warning.  */\n   unsigned int addr_size = -1;\n   struct abbrev_info** abbrevs;\n-  unsigned int abbrev_number, bytes_read, i;\n+  unsigned int abbrev_number, i;\n   struct abbrev_info *abbrev;\n   struct attribute attr;\n   bfd_byte *end_ptr = info_ptr + unit_length;\n@@ -3784,8 +3661,7 @@ parse_comp_unit (struct dwarf2_debug *stash,\n   bool high_pc_relative = false;\n   enum dwarf_unit_type unit_type;\n \n-  version = read_2_bytes (abfd, info_ptr, end_ptr);\n-  info_ptr += 2;\n+  version = read_2_bytes (abfd, &info_ptr, end_ptr);\n   if (version < 2 || version > 5)\n     {\n       /* PR 19872: A version number of 0 probably means that there is padding\n@@ -3806,25 +3682,18 @@ parse_comp_unit (struct dwarf2_debug *stash,\n     unit_type = DW_UT_compile;\n   else\n     {\n-      unit_type = read_1_byte (abfd, info_ptr, end_ptr);\n-      info_ptr += 1;\n-\n-      addr_size = read_1_byte (abfd, info_ptr, end_ptr);\n-      info_ptr += 1;\n+      unit_type = read_1_byte (abfd, &info_ptr, end_ptr);\n+      addr_size = read_1_byte (abfd, &info_ptr, end_ptr);\n     }\n \n   BFD_ASSERT (offset_size == 4 || offset_size == 8);\n   if (offset_size == 4)\n-    abbrev_offset = read_4_bytes (abfd, info_ptr, end_ptr);\n+    abbrev_offset = read_4_bytes (abfd, &info_ptr, end_ptr);\n   else\n-    abbrev_offset = read_8_bytes (abfd, info_ptr, end_ptr);\n-  info_ptr += offset_size;\n+    abbrev_offset = read_8_bytes (abfd, &info_ptr, end_ptr);\n \n   if (version < 5)\n-    {\n-      addr_size = read_1_byte (abfd, info_ptr, end_ptr);\n-      info_ptr += 1;\n-    }\n+    addr_size = read_1_byte (abfd, &info_ptr, end_ptr);\n \n   if (unit_type == DW_UT_type)\n     {\n@@ -3861,9 +3730,8 @@ parse_comp_unit (struct dwarf2_debug *stash,\n   if (! abbrevs)\n     return NULL;\n \n-  abbrev_number = _bfd_safe_read_leb128 (abfd, info_ptr, &bytes_read,\n+  abbrev_number = _bfd_safe_read_leb128 (abfd, &info_ptr,\n \t\t\t\t\t false, end_ptr);\n-  info_ptr += bytes_read;\n   if (! abbrev_number)\n     {\n       /* PR 19872: An abbrev number of 0 probably means that there is padding\n@@ -4930,25 +4798,21 @@ stash_comp_unit (struct dwarf2_debug *stash, struct dwarf2_debug_file *file)\n   if (file->info_ptr >= info_ptr_end)\n     return NULL;\n \n-  length = read_4_bytes (file->bfd_ptr, file->info_ptr, info_ptr_end);\n+  length = read_4_bytes (file->bfd_ptr, &file->info_ptr, info_ptr_end);\n   /* A 0xffffff length is the DWARF3 way of indicating\n      we use 64-bit offsets, instead of 32-bit offsets.  */\n   if (length == 0xffffffff)\n     {\n       offset_size = 8;\n-      length = read_8_bytes (file->bfd_ptr, file->info_ptr + 4,\n-\t\t\t     info_ptr_end);\n-      file->info_ptr += 12;\n+      length = read_8_bytes (file->bfd_ptr, &file->info_ptr, info_ptr_end);\n     }\n   /* A zero length is the IRIX way of indicating 64-bit offsets,\n      mostly because the 64-bit length will generally fit in 32\n      bits, and the endianness helps.  */\n   else if (length == 0)\n     {\n       offset_size = 8;\n-      length = read_4_bytes (file->bfd_ptr, file->info_ptr + 4,\n-\t\t\t     info_ptr_end);\n-      file->info_ptr += 8;\n+      length = read_4_bytes (file->bfd_ptr, &file->info_ptr, info_ptr_end);\n     }\n   /* In the absence of the hints above, we assume 32-bit DWARF2\n      offsets even for targets with 64-bit addresses, because:\n@@ -4960,14 +4824,10 @@ stash_comp_unit (struct dwarf2_debug *stash, struct dwarf2_debug_file *file)\n      the size hints that are tested for above then they are\n      not conforming to the DWARF3 standard anyway.  */\n   else\n-    {\n-      offset_size = 4;\n-      file->info_ptr += 4;\n-    }\n+    offset_size = 4;\n \n   if (length != 0\n-      && file->info_ptr + length <= info_ptr_end\n-      && file->info_ptr + length > file->info_ptr)\n+      && length <= (size_t) (info_ptr_end - file->info_ptr))\n     {\n       struct comp_unit *each = parse_comp_unit (stash, file,\n \t\t\t\t\t\tfile->info_ptr, length,"
    },
    {
      "sha": "e77b73a2a9702fc54e73e92c621b5c4edbf4b1c3",
      "filename": "bfd/elf-attrs.c",
      "status": "modified",
      "additions": 19,
      "deletions": 22,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/elf-attrs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/elf-attrs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-attrs.c?ref=574ec1084d28ee56710ea48eb072e5c47226d247",
      "patch": "@@ -471,7 +471,7 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n     {\n       len = hdr->sh_size - 1;\n \n-      while (len > 0 && p < p_end - 4)\n+      while (len > 0 && p_end - p >= 4)\n \t{\n \t  unsigned namelen;\n \t  bfd_vma section_len;\n@@ -511,43 +511,41 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n \t  while (section_len > 0 && p < p_end)\n \t    {\n \t      unsigned int tag;\n-\t      unsigned int n;\n \t      unsigned int val;\n \t      bfd_vma subsection_len;\n-\t      bfd_byte *end;\n+\t      bfd_byte *end, *orig_p;\n \n-\t      tag = _bfd_safe_read_leb128 (abfd, p, &n, false, p_end);\n-\t      p += n;\n-\t      if (p < p_end - 4)\n-\t\tsubsection_len = bfd_get_32 (abfd, p);\n+\t      orig_p = p;\n+\t      tag = _bfd_safe_read_leb128 (abfd, &p, false, p_end);\n+\t      if (p_end - p >= 4)\n+\t\t{\n+\t\t  subsection_len = bfd_get_32 (abfd, p);\n+\t\t  p += 4;\n+\t\t}\n \t      else\n-\t\tsubsection_len = 0;\n-\t      p += 4;\n+\t\t{\n+\t\t  subsection_len = 0;\n+\t\t  p = p_end;\n+\t\t}\n \t      if (subsection_len == 0)\n \t\tbreak;\n \t      if (subsection_len > section_len)\n \t\tsubsection_len = section_len;\n \t      section_len -= subsection_len;\n-\t      subsection_len -= n + 4;\n-\t      end = p + subsection_len;\n-\t      /* PR 17512: file: 0e8c0c90.  */\n-\t      if (end > p_end)\n-\t\tend = p_end;\n+\t      end = orig_p + subsection_len;\n \t      switch (tag)\n \t\t{\n \t\tcase Tag_File:\n \t\t  while (p < end)\n \t\t    {\n \t\t      int type;\n \n-\t\t      tag = _bfd_safe_read_leb128 (abfd, p, &n, false, end);\n-\t\t      p += n;\n+\t\t      tag = _bfd_safe_read_leb128 (abfd, &p, false, end);\n \t\t      type = _bfd_elf_obj_attrs_arg_type (abfd, vendor, tag);\n \t\t      switch (type & (ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL))\n \t\t\t{\n \t\t\tcase ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL:\n-\t\t\t  val = _bfd_safe_read_leb128 (abfd, p, &n, false, end);\n-\t\t\t  p += n;\n+\t\t\t  val = _bfd_safe_read_leb128 (abfd, &p, false, end);\n \t\t\t  bfd_elf_add_obj_attr_int_string (abfd, vendor, tag,\n \t\t\t\t\t\t\t   val, (char *) p);\n \t\t\t  p += strlen ((char *)p) + 1;\n@@ -558,8 +556,7 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n \t\t\t  p += strlen ((char *)p) + 1;\n \t\t\t  break;\n \t\t\tcase ATTR_TYPE_FLAG_INT_VAL:\n-\t\t\t  val = _bfd_safe_read_leb128 (abfd, p, &n, false, end);\n-\t\t\t  p += n;\n+\t\t\t  val = _bfd_safe_read_leb128 (abfd, &p, false, end);\n \t\t\t  bfd_elf_add_obj_attr_int (abfd, vendor, tag, val);\n \t\t\t  break;\n \t\t\tdefault:\n@@ -572,8 +569,8 @@ _bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)\n \t\t  /* Don't have anywhere convenient to attach these.\n \t\t     Fall through for now.  */\n \t\tdefault:\n-\t\t  /* Ignore things we don't kow about.  */\n-\t\t  p += subsection_len;\n+\t\t  /* Ignore things we don't know about.  */\n+\t\t  p = end;\n \t\t  subsection_len = 0;\n \t\t  break;\n \t\t}"
    },
    {
      "sha": "1f7e22186ec1e40a92c34943668403b39386c6ab",
      "filename": "bfd/libbfd-in.h",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/libbfd-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/libbfd-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd-in.h?ref=574ec1084d28ee56710ea48eb072e5c47226d247",
      "patch": "@@ -888,8 +888,7 @@ extern bfd_vma _bfd_read_unsigned_leb128\n extern bfd_signed_vma _bfd_read_signed_leb128\n   (bfd *, bfd_byte *, unsigned int *) ATTRIBUTE_HIDDEN;\n extern bfd_vma _bfd_safe_read_leb128\n-  (bfd *, bfd_byte *, unsigned int *, bool, const bfd_byte * const)\n-  ATTRIBUTE_HIDDEN;\n+  (bfd *, bfd_byte **, bool, const bfd_byte * const) ATTRIBUTE_HIDDEN;\n extern bfd_byte * _bfd_write_unsigned_leb128\n   (bfd_byte *, bfd_byte *, bfd_vma) ATTRIBUTE_HIDDEN;\n "
    },
    {
      "sha": "dd98e1bd06cc5d15d5233b861e0e9a8a80da2e8a",
      "filename": "bfd/libbfd.c",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/libbfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/libbfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd.c?ref=574ec1084d28ee56710ea48eb072e5c47226d247",
      "patch": "@@ -1170,28 +1170,26 @@ _bfd_read_unsigned_leb128 (bfd *abfd ATTRIBUTE_UNUSED,\n   return result;\n }\n \n-/* Read in a LEB128 encoded value from ABFD starting at DATA.\n+/* Read in a LEB128 encoded value from ABFD starting at *PTR.\n    If SIGN is true, return a signed LEB128 value.\n-   If LENGTH_RETURN is not NULL, return in it the number of bytes read.\n+   *PTR is incremented by the number of bytes read.\n    No bytes will be read at address END or beyond.  */\n \n bfd_vma\n _bfd_safe_read_leb128 (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t       bfd_byte *data,\n-\t\t       unsigned int *length_return,\n+\t\t       bfd_byte **ptr,\n \t\t       bool sign,\n \t\t       const bfd_byte * const end)\n {\n   bfd_vma result = 0;\n-  unsigned int num_read = 0;\n   unsigned int shift = 0;\n   unsigned char byte = 0;\n+  bfd_byte *data = *ptr;\n \n   while (data < end)\n     {\n       byte = bfd_get_8 (abfd, data);\n       data++;\n-      num_read++;\n       if (shift < 8 * sizeof (result))\n \t{\n \t  result |= ((bfd_vma) (byte & 0x7f)) << shift;\n@@ -1201,8 +1199,7 @@ _bfd_safe_read_leb128 (bfd *abfd ATTRIBUTE_UNUSED,\n \tbreak;\n     }\n \n-  if (length_return != NULL)\n-    *length_return = num_read;\n+  *ptr = data;\n \n   if (sign && (shift < 8 * sizeof (result)) && (byte & 0x40))\n     result |= -((bfd_vma) 1 << shift);"
    },
    {
      "sha": "c37ddc03cfdd8529245b25d54eb91c43aaa85bdb",
      "filename": "bfd/libbfd.h",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/libbfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/libbfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd.h?ref=574ec1084d28ee56710ea48eb072e5c47226d247",
      "patch": "@@ -893,8 +893,7 @@ extern bfd_vma _bfd_read_unsigned_leb128\n extern bfd_signed_vma _bfd_read_signed_leb128\n   (bfd *, bfd_byte *, unsigned int *) ATTRIBUTE_HIDDEN;\n extern bfd_vma _bfd_safe_read_leb128\n-  (bfd *, bfd_byte *, unsigned int *, bool, const bfd_byte * const)\n-  ATTRIBUTE_HIDDEN;\n+  (bfd *, bfd_byte **, bool, const bfd_byte * const) ATTRIBUTE_HIDDEN;\n extern bfd_byte * _bfd_write_unsigned_leb128\n   (bfd_byte *, bfd_byte *, bfd_vma) ATTRIBUTE_HIDDEN;\n "
    },
    {
      "sha": "9735ebeabca8be02e5ad10ee8aafbc815f46dbba",
      "filename": "bfd/wasm-module.c",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/wasm-module.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/574ec1084d28ee56710ea48eb072e5c47226d247/bfd/wasm-module.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/wasm-module.c?ref=574ec1084d28ee56710ea48eb072e5c47226d247",
      "patch": "@@ -182,12 +182,9 @@ wasm_write_uleb128 (bfd *abfd, bfd_vma v)\n #define READ_LEB128(x, p, end)\t\t\t\t\t\t\\\n   do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n-      unsigned int length_read;\t\t\t\t\t\t\\\n-      (x) = _bfd_safe_read_leb128 (abfd, (p), &length_read,\t\t\\\n-\t\t\t\t   false, (end));\t\t\t\\\n-      (p) += length_read;\t\t\t\t\t\t\\\n-      if (length_read == 0)\t\t\t\t\t\t\\\n+      if ((p) >= (end))\t\t\t\t\t\t\t\\\n \tgoto error_return;\t\t\t\t\t\t\\\n+      (x) = _bfd_safe_read_leb128 (abfd, &(p), false, (end));\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   while (0)\n "
    }
  ]
}