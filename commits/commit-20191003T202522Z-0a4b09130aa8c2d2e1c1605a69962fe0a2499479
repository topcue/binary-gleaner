{
  "sha": "0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGE0YjA5MTMwYWE4YzJkMmUxYzE2MDVhNjk5NjJmZTBhMjQ5OTQ3OQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-08-15T13:57:13Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-10-03T20:25:22Z"
    },
    "message": "gdb/fortran: Nested subroutine support\n\nThis patch is a rebase and update of the following three patches:\n\n   https://sourceware.org/ml/gdb-patches/2018-11/msg00298.html\n   https://sourceware.org/ml/gdb-patches/2018-11/msg00302.html\n   https://sourceware.org/ml/gdb-patches/2018-11/msg00301.html\n\nI have merged these together into a single commit as the second patch,\nadding scope support to nested subroutines, means that some of the\nchanges in the first patch are now no longer useful and would have to\nbe backed out.  The third patch is tightly coupled to the changes in\nthe second of these patches and I think deserves to live together with\nit.\n\nThere is an extra change in cp-namespace.c that is new, this resolves\nan issue with symbol lookup when placing breakpoints from within\nnested subroutines.\n\nThere is also an extra test added to this commit 'nested-funcs-2.exp'\nthat was written by Richard Bunt from ARM, this offers some additional\ntesting of breakpoints on nested functions.\n\nAfter this commit it is possible to place breakpoints on nested\nFortran subroutines and functions by using a fully scoped name, for\nexample, given this simple Fortran program:\n\n    program greeting\n      call message\n    contains\n      subroutine message\n        print *, \"Hello World\"\n      end subroutine message\n    end program greeting\n\nIt is possible to place a breakpoint in 'message' with:\n\n    (gdb) break greeting::message\n    Breakpoint 1 at 0x4006c9: file basic.f90, line 5.\n\nWhat doesn't work with this commit is placing a breakpoint like this:\n\n    (gdb) break message\n    Function \"message\" not defined.\n\nMaking this work will come in a later commit.\n\ngdb/ChangeLog:\n\n\t* cp-namespace.c (cp_search_static_and_baseclasses): Only search\n\tfor nested static variables when searchin VAR_DOMAIN.\n\t* dwarf2read.c (add_partial_symbol): Add nested subroutines to the\n\tglobal scope, update comment.\n\t(add_partial_subprogram): Call add_partial_subprogram recursively\n\tfor nested subroutines when processinng Fortran.\n\t(load_partial_dies): Process the child entities of a subprogram\n\twhen processing Fortran.\n\t(partial_die_parent_scope): Handle building scope\n\tfor Fortran nested functions.\n\t(process_die): Record that nested functions have a scope.\n\t(new_symbol): Always record Fortran subprograms on the global\n\tsymbol list.\n\t(determine_prefix): How to build the prefix for Fortran\n\tsubprograms.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.fortran/nested-funcs.exp: Tests for placing breakpoints on\n\tnested functions.\n\t* gdb.fortran/nested-funcs.f90: Update expected results.\n\t* gdb.fortran/nested-funcs-2.exp: New file.\n\t* gdb.fortran/nested-funcs-2.f90: New file.\n\ngdb/doc/ChangeLog:\n\n\t* doc/gdb.texinfo (Fortran Operators): Describe scope operator.",
    "tree": {
      "sha": "771e8e48d59652033a80612cc3d35bd4cc74dec8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/771e8e48d59652033a80612cc3d35bd4cc74dec8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "082cce059d78bdb4a9fadbbacc2cd1dc3668f084",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/082cce059d78bdb4a9fadbbacc2cd1dc3668f084",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/082cce059d78bdb4a9fadbbacc2cd1dc3668f084"
    }
  ],
  "stats": {
    "total": 418,
    "additions": 394,
    "deletions": 24
  },
  "files": [
    {
      "sha": "afda7532d210fac97c0e40784b49f9c67259744d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -1,3 +1,22 @@\n+2019-10-03  Bernhard Heckel  <bernhard.heckel@intel.com>\n+\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* cp-namespace.c (cp_search_static_and_baseclasses): Only search\n+\tfor nested static variables when searchin VAR_DOMAIN.\n+\t* dwarf2read.c (add_partial_symbol): Add nested subroutines to the\n+\tglobal scope, update comment.\n+\t(add_partial_subprogram): Call add_partial_subprogram recursively\n+\tfor nested subroutines when processinng Fortran.\n+\t(load_partial_dies): Process the child entities of a subprogram\n+\twhen processing Fortran.\n+\t(partial_die_parent_scope): Handle building scope\n+\tfor Fortran nested functions.\n+\t(process_die): Record that nested functions have a scope.\n+\t(new_symbol): Always record Fortran subprograms on the global\n+\tsymbol list.\n+\t(determine_prefix): How to build the prefix for Fortran\n+\tsubprograms.\n+\n 2019-10-03  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* linux-nat.c (linux_nat_filter_event): Don't ignore SIGSTOP if we"
    },
    {
      "sha": "e15b77e701ddd832ad12b33a4ee6ef2203423a55",
      "filename": "gdb/cp-namespace.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/cp-namespace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/cp-namespace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-namespace.c?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -278,8 +278,9 @@ cp_search_static_and_baseclasses (const char *name,\n \n   /* If the scope is a function/method, then look up NESTED as a local\n      static variable.  E.g., \"print 'function()::static_var'\".  */\n-  if (TYPE_CODE (scope_type) == TYPE_CODE_FUNC\n-      || TYPE_CODE (scope_type) == TYPE_CODE_METHOD)\n+  if ((TYPE_CODE (scope_type) == TYPE_CODE_FUNC\n+       || TYPE_CODE (scope_type) == TYPE_CODE_METHOD)\n+      && domain == VAR_DOMAIN)\n     return lookup_symbol (nested, SYMBOL_BLOCK_VALUE (scope_sym.symbol),\n \t\t\t  VAR_DOMAIN, NULL);\n "
    },
    {
      "sha": "51ef38cbbc1aec6252474fac75f9f7cad63dc9b0",
      "filename": "gdb/doc/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/doc/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/doc/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/ChangeLog?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -1,3 +1,7 @@\n+2019-10-03  Bernhard Heckel  <bernhard.heckel@intel.com>\n+\n+\t* doc/gdb.texinfo (Fortran Operators): Describe scope operator.\n+\n 2019-10-02  Tom Tromey  <tromey@adacore.com>\n \n \t* gdb.texinfo (Set Catchpoints, Convenience Vars): Document"
    },
    {
      "sha": "8699dd27d7b2b7c58eb436c6cd9518ea683dd6ef",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -16570,6 +16570,10 @@ The access component operator.  Normally used to access elements in derived\n types.  Also suitable for unions.  As unions aren't part of regular Fortran,\n this can only happen when accessing a register that uses a gdbarch-defined\n union type.\n+@item ::\n+The scope operator.  Normally used to access variables in modules or\n+to set breakpoints on subroutines nested in modules or in other\n+subroutines (internal subroutines).\n @end table\n \n @node Fortran Defaults"
    },
    {
      "sha": "c0dd199a79792b342211cf43e6a5f07542d21841",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 45,
      "deletions": 19,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -8823,6 +8823,7 @@ partial_die_parent_scope (struct partial_die_info *pdi,\n       return NULL;\n     }\n \n+  /* Nested subroutines in Fortran get a prefix.  */\n   if (pdi->tag == DW_TAG_enumerator)\n     /* Enumerators should not get the name of the enumeration as a prefix.  */\n     parent->scope = grandparent_scope;\n@@ -8832,7 +8833,10 @@ partial_die_parent_scope (struct partial_die_info *pdi,\n       || parent->tag == DW_TAG_class_type\n       || parent->tag == DW_TAG_interface_type\n       || parent->tag == DW_TAG_union_type\n-      || parent->tag == DW_TAG_enumeration_type)\n+      || parent->tag == DW_TAG_enumeration_type\n+      || (cu->language == language_fortran\n+\t  && parent->tag == DW_TAG_subprogram\n+\t  && pdi->tag == DW_TAG_subprogram))\n     {\n       if (grandparent_scope == NULL)\n \tparent->scope = parent->name;\n@@ -8923,12 +8927,16 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n     case DW_TAG_subprogram:\n       addr = (gdbarch_adjust_dwarf2_addr (gdbarch, pdi->lowpc + baseaddr)\n \t      - baseaddr);\n-      if (pdi->is_external || cu->language == language_ada)\n-\t{\n-          /* brobecker/2007-12-26: Normally, only \"external\" DIEs are part\n-             of the global scope.  But in Ada, we want to be able to access\n-             nested procedures globally.  So all Ada subprograms are stored\n-             in the global scope.  */\n+      if (pdi->is_external\n+\t  || cu->language == language_ada\n+\t  || (cu->language == language_fortran\n+\t      && pdi->die_parent != NULL\n+\t      && pdi->die_parent->tag == DW_TAG_subprogram))\n+\t{\n+          /* Normally, only \"external\" DIEs are part of the global scope.\n+             But in Ada and Fortran, we want to be able to access nested\n+             procedures globally.  So all Ada and Fortran subprograms are\n+             stored in the global scope.  */\n \t  add_psymbol_to_list (actual_name, strlen (actual_name),\n \t\t\t       built_actual_name != NULL,\n \t\t\t       VAR_DOMAIN, LOC_BLOCK,\n@@ -9184,7 +9192,7 @@ add_partial_subprogram (struct partial_die_info *pdi,\n   if (! pdi->has_children)\n     return;\n \n-  if (cu->language == language_ada)\n+  if (cu->language == language_ada || cu->language == language_fortran)\n     {\n       pdi = pdi->die_child;\n       while (pdi != NULL)\n@@ -10626,6 +10634,12 @@ process_die (struct die_info *die, struct dwarf2_cu *cu)\n       read_type_unit_scope (die, cu);\n       break;\n     case DW_TAG_subprogram:\n+      /* Nested subprograms in Fortran get a prefix.  */\n+      if (cu->language == language_fortran\n+\t  && die->parent != NULL\n+\t  && die->parent->tag == DW_TAG_subprogram)\n+\tcu->processing_has_namespace_info = true;\n+      /* Fall through.  */\n     case DW_TAG_inlined_subroutine:\n       read_func_scope (die, cu);\n       break;\n@@ -18653,10 +18667,10 @@ load_partial_dies (const struct die_reader_specs *reader,\n \t inside functions to find template arguments (if the name of the\n \t function does not already contain the template arguments).\n \n-\t For Ada, we need to scan the children of subprograms and lexical\n-\t blocks as well because Ada allows the definition of nested\n-\t entities that could be interesting for the debugger, such as\n-\t nested subprograms for instance.  */\n+\t For Ada and Fortran, we need to scan the children of subprograms\n+\t and lexical blocks as well because these languages allow the\n+\t definition of nested entities that could be interesting for the\n+\t debugger, such as nested subprograms for instance.  */\n       if (last_die->has_children\n \t  && (load_all\n \t      || last_die->tag == DW_TAG_namespace\n@@ -18671,7 +18685,8 @@ load_partial_dies (const struct die_reader_specs *reader,\n \t\t      || last_die->tag == DW_TAG_interface_type\n \t\t      || last_die->tag == DW_TAG_structure_type\n \t\t      || last_die->tag == DW_TAG_union_type))\n-\t      || (cu->language == language_ada\n+\t      || ((cu->language == language_ada\n+\t\t   || cu->language == language_fortran)\n \t\t  && (last_die->tag == DW_TAG_subprogram\n \t\t      || last_die->tag == DW_TAG_lexical_block))))\n \t{\n@@ -21641,14 +21656,15 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t  SYMBOL_ACLASS_INDEX (sym) = LOC_BLOCK;\n \t  attr2 = dwarf2_attr (die, DW_AT_external, cu);\n \t  if ((attr2 && (DW_UNSND (attr2) != 0))\n-              || cu->language == language_ada)\n+\t      || cu->language == language_ada\n+\t      || cu->language == language_fortran)\n \t    {\n               /* Subprograms marked external are stored as a global symbol.\n-                 Ada subprograms, whether marked external or not, are always\n-                 stored as a global symbol, because we want to be able to\n-                 access them globally.  For instance, we want to be able\n-                 to break on a nested subprogram without having to\n-                 specify the context.  */\n+                 Ada and Fortran subprograms, whether marked external or\n+                 not, are always stored as a global symbol, because we want\n+                 to be able to access them globally.  For instance, we want\n+                 to be able to break on a nested subprogram without having\n+                 to specify the context.  */\n \t      list_to_add = cu->get_builder ()->get_global_symbols ();\n \t    }\n \t  else\n@@ -22645,6 +22661,16 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n \t      return name;\n \t  }\n \treturn \"\";\n+      case DW_TAG_subprogram:\n+\t/* Nested subroutines in Fortran get a prefix with the name\n+\t   of the parent's subroutine.  */\n+\tif (cu->language == language_fortran)\n+\t  {\n+\t    if ((die->tag ==  DW_TAG_subprogram)\n+\t\t&& (dwarf2_name (parent, cu) != NULL))\n+\t      return dwarf2_name (parent, cu);\n+\t  }\n+\treturn determine_prefix (parent, cu);\n       case DW_TAG_enumeration_type:\n \tparent_type = read_type_die (parent, cu);\n \tif (TYPE_DECLARED_CLASS (parent_type))"
    },
    {
      "sha": "6441c1bc09a38f78a7df9d4b2446b2ed8ebf5fb7",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -1,3 +1,13 @@\n+2019-10-03  Bernhard Heckel  <bernhard.heckel@intel.com>\n+\t    Richard Bunt  <richard.bunt@arm.com>\n+\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.fortran/nested-funcs.exp: Tests for placing breakpoints on\n+\tnested functions.\n+\t* gdb.fortran/nested-funcs.f90: Update expected results.\n+\t* gdb.fortran/nested-funcs-2.exp: New file.\n+\t* gdb.fortran/nested-funcs-2.f90: New file.\n+\n 2019-10-03  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.python/py-parameter.exp: Make test names unique."
    },
    {
      "sha": "4e121cd9da5dfbb3715e0756a7080fc358ff7445",
      "filename": "gdb/testsuite/gdb.fortran/nested-funcs-2.exp",
      "status": "added",
      "additions": 159,
      "deletions": 0,
      "changes": 159,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/gdb.fortran/nested-funcs-2.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/gdb.fortran/nested-funcs-2.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/nested-funcs-2.exp?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -0,0 +1,159 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/> .\n+\n+# Further testing of placing breakpoints in nested subroutines.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+load_lib \"fortran.exp\"\n+\n+standard_testfile \".f90\"\n+\n+if {[prepare_for_testing ${testfile}.exp ${testfile} \\\n+\t ${srcfile} {debug f90}]} {\n+    return -1\n+}\n+\n+set int4 [fortran_int4]\n+\n+# When WITH_SRC_PREFIX_P is true then some symbol references will be\n+# prefixed with the filename.  When WITH_NEST_PREFIX_P is true then\n+# nested subroutine symbols will be prefixed with their parent\n+# subroutine scope.\n+proc do_bp_tests {with_src_prefix_p with_nest_prefix_p} {\n+    global testfile srcfile\n+    global int4\n+    global hex\n+\n+    clean_restart ${testfile}\n+\n+    if { $with_src_prefix_p } {\n+\tset src_prefix \"${srcfile}:\"\n+    } else {\n+\tset src_prefix \"\"\n+    }\n+\n+    if { $with_nest_prefix_p } {\n+\tset nest_prefix \"contains_keyword::\"\n+    } else {\n+\tset nest_prefix \"\"\n+    }\n+\n+    # Test setting up breakpoints and otherwise examining nested\n+    # functions before the program starts.\n+    with_test_prefix \"before start\" {\n+\tforeach entry \\\n+\t    [list \\\n+\t\t [list \"increment\" \"${int4} \\\\\\(${int4}\\\\\\)\"] \\\n+\t\t [list \"increment_program_global\" \"${int4} \\\\\\(void\\\\\\)\"] \\\n+\t\t [list \"hidden_variable\" \"void \\\\\\(void\\\\\\)\"]] {\n+\t\t     set function [lindex $entry 0]\n+\t\t     set type [lindex $entry 1]\n+\n+\t\t     # Currently referencing symbols using 'info',\n+\t\t     # 'whatis' and 'ptype' before the program is\n+\t\t     # started doesn't work.  This is the same\n+\t\t     # behaviour we see in C++ so I don't think this\n+\t\t     # is a failure, just a limitation in current GDB.\n+\t\t     if { ${with_nest_prefix_p} } {\n+\t\t\t gdb_test \"info symbol ${nest_prefix}${function}\" \\\n+\t\t\t     \"${function} in section .*\"\n+\t\t\t gdb_test \"whatis ${nest_prefix}${function}\" \\\n+\t\t\t     \"type = ${type}\"\n+\t\t\t gdb_test \"ptype ${nest_prefix}${function}\" \\\n+\t\t\t     \"type = ${type}\"\n+\t\t\t gdb_test \"print ${nest_prefix}${function}\" \\\n+\t\t\t     \"{${type}} $hex <contains_keyword::${function}>\"\n+\t\t     }\n+\n+\t\t     gdb_breakpoint \"${src_prefix}${nest_prefix}${function}\"\n+\t\t }\n+    }\n+\n+    # Break on a contained function and run to it.\n+    if {![runto ${src_prefix}[gdb_get_line_number \"pre_init\"]]} then {\n+\tperror \"couldn't run to breakpoint pre_init\"\n+\tcontinue\n+    }\n+\n+    # Call a contained function.\n+    if { ${with_nest_prefix_p} } {\n+\tgdb_test \"call ${nest_prefix}subroutine_to_call()\" \" called\"\n+    }\n+\n+    # Break on another contained function and run to it.\n+    gdb_breakpoint \"${src_prefix}${nest_prefix}increment\"\n+    gdb_continue_to_breakpoint \"increment\" \".*increment = i \\\\\\+ 1\"\n+    gdb_breakpoint ${src_prefix}[gdb_get_line_number \"post_increment\"]\n+    gdb_continue_to_breakpoint \"post_increment\"\n+\n+    # Check arguments and locals report the correct values. 12 is\n+    # passed in and 13 is the result after adding 1.\n+    gdb_test \"info args\" \"i = 12\"\n+    gdb_test \"info locals\" \" = 13\"\n+\n+    # Check we can see variables from an outer program scope.\n+    gdb_breakpoint ${src_prefix}[gdb_get_line_number \"post_increment_global\"]\n+    gdb_continue_to_breakpoint \"post_increment_global\" \\\n+\t\".*print \\\\\\*, program_i ! post_increment_global\"\n+    gdb_test \"info args\" \"No arguments.\" \\\n+\t\"no argument subroutine has no arguments\"\n+    gdb_test \"p program_i\" \" = 7\" \"printing outer scoped variable\"\n+\n+    # Stepping into a contained subroutine.\n+    gdb_breakpoint ${src_prefix}[gdb_get_line_number \"pre_step\"]\n+    gdb_continue_to_breakpoint \"pre_step\" \".*call step\\\\\\(\\\\\\) ! pre_step\"\n+    gdb_test \"step\" \\\n+\t\".*print '\\\\\\(A\\\\\\)', \\\\\\\"step\\\\\\\" ! post_step\" \\\n+\t\"step into the correct place\"\n+\n+    # Local hides program global.\n+    gdb_breakpoint ${src_prefix}[gdb_get_line_number \"post_hidden\"]\n+    gdb_continue_to_breakpoint \"post_hidden\" \\\n+\t\".*print \\\\\\*, program_i ! post_hidden\"\n+    gdb_test \"p program_i\" \" = 30\" \"printing hidden global\"\n+\n+    # Check that the methods in the container module still require the\n+    # module name as context.\n+    gdb_test_no_output \"set confirm off\"\n+    gdb_test \"break print_from_module\" \\\n+        \"Function \\\\\\\"print_from_module\\\\\\\" not defined.\"\n+\n+    # Check info symbol, whatis and ptype can find information on\n+    # these nested functions.\n+    foreach entry \\\n+\t[list \\\n+\t     [list \"increment\" \"${int4} \\\\\\(${int4}\\\\\\)\"] \\\n+\t     [list \"increment_program_global\" \"${int4} \\\\\\(void\\\\\\)\"]] {\n+\t\t set function [lindex $entry 0]\n+\t\t set type [lindex $entry 1]\n+\t\t with_test_prefix $function {\n+\t\t     gdb_test \"info symbol ${nest_prefix}$function\" \\\n+\t\t\t \"$function in section .*\"\n+\t\t     gdb_test \"whatis ${nest_prefix}$function\" \\\n+\t\t\t \"type = ${type}\"\n+\t\t     gdb_test \"ptype ${nest_prefix}$function\" \\\n+\t\t\t \"type = ${type}\"\n+\t\t }\n+\t     }\n+}\n+\n+foreach_with_prefix src_prefix { 0 1 } {\n+    # For now this loop is only run with a value of '1'.  A later\n+    # patch will extend this with the value '0', at which point this\n+    # comment will be removed.\n+    foreach_with_prefix nest_prefix { 1 } {\n+\tdo_bp_tests ${src_prefix} ${nest_prefix}\n+    }\n+}"
    },
    {
      "sha": "c3b4e2ba05f5ce98e1e2c42121553739ea599787",
      "filename": "gdb/testsuite/gdb.fortran/nested-funcs-2.f90",
      "status": "added",
      "additions": 62,
      "deletions": 0,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/gdb.fortran/nested-funcs-2.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/gdb.fortran/nested-funcs-2.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/nested-funcs-2.f90?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -0,0 +1,62 @@\n+! Copyright 2019 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/> .\n+\n+module container\n+    implicit none\n+    integer :: a\n+    contains\n+    subroutine print_from_module()\n+       print *, \"hello.\"\n+    end subroutine\n+end module\n+\n+program contains_keyword\n+    use container\n+    implicit none\n+    integer :: program_i, program_j\n+    program_j = 12 ! pre_init\n+    program_i = 7\n+    program_j = increment(program_j) ! pre_increment\n+    program_i = increment_program_global() ! pre_increment_program_global\n+    call subroutine_to_call()\n+    call step() ! pre_step\n+    call hidden_variable()\n+    call print_from_module()\n+    print '(I2)', program_j, program_i ! post_init\n+\n+contains\n+    subroutine subroutine_to_call()\n+       print *, \"called\"\n+    end subroutine\n+    integer function increment(i)\n+       integer :: i\n+       increment = i + 1\n+       print *, i ! post_increment\n+    end function\n+    integer function increment_program_global()\n+       increment_program_global = program_i + 1\n+       ! Need to put in a dummy print here to break on as on some systems the\n+       ! variables leave scope at \"end function\", but on others they do not.\n+       print *, program_i ! post_increment_global\n+    end function\n+    subroutine step()\n+       print '(A)', \"step\" ! post_step\n+    end subroutine\n+    subroutine hidden_variable()\n+       integer :: program_i\n+       program_i = 30\n+       print *, program_i ! post_hidden\n+    end subroutine\n+end program contains_keyword"
    },
    {
      "sha": "abc2423f8cfd5de4560309b4548d8523c37964a1",
      "filename": "gdb/testsuite/gdb.fortran/nested-funcs.exp",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/gdb.fortran/nested-funcs.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/gdb.fortran/nested-funcs.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/nested-funcs.exp?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -30,6 +30,11 @@ if ![runto MAIN__] then {\n     continue\r\n }\r\n \r\n+# Test if we can set a breakpoint in a nested function\r\n+gdb_breakpoint \"testnestedfuncs::sub_nested_outer\"\r\n+gdb_continue_to_breakpoint \"testnestedfuncs::sub_nested_outer\" \\\r\n+    \".*local_int = 19\"\r\n+\r\n # Test if we can access local and\r\n # non-local variables defined one level up.\r\n gdb_breakpoint [gdb_get_line_number \"! BP_outer\"]\r\n@@ -43,6 +48,11 @@ gdb_test \"print local_int\" \"= 19\" \"print local_int in outer function\"\n gdb_test \"up\"\r\n gdb_test \"print index\" \"= 42\" \"print index at BP1, one frame up\"\r\n \r\n+# Test if we can set a breakpoint in a nested function\r\n+gdb_breakpoint \"testnestedfuncs::sub_nested_inner\"\r\n+gdb_continue_to_breakpoint \"testnestedfuncs::sub_nested_inner\" \\\r\n+    \".*local_int = 17\"\r\n+\r\n # Test if we can access local and\r\n # non-local variables defined two level up.\r\n gdb_breakpoint [gdb_get_line_number \"! BP_inner\"]\r\n@@ -57,6 +67,24 @@ gdb_continue_to_breakpoint \"! BP_outer_2\" \".*! BP_outer_2\"\n gdb_test \"print local_int\" \"= 19\" \\\r\n   \"print local_int in outer function, after sub_nested_inner\"\r\n \r\n+# Test if we can set a breakpoint in public routine with the same name\r\n+# as the internal\r\n+gdb_breakpoint \"sub_nested_outer\"\r\n+gdb_continue_to_breakpoint \"sub_nested_outer\" \\\r\n+    \".*name = 'sub_nested_outer external'\"\r\n+\r\n+# Test if we can set a breakpoint in public routine with the same name\r\n+# as the internal\r\n+gdb_breakpoint \"sub_with_sub_nested_outer::sub_nested_outer\"\r\n+gdb_continue_to_breakpoint \\\r\n+    \"sub_with_sub_nested_outer::sub_nested_outer\" \".*local_int = 11\"\r\n+\r\n+# Test if we can set a breakpoint in public routine with the same name\r\n+# as the internal\r\n+gdb_breakpoint \"mod1::sub_nested_outer\"\r\n+gdb_continue_to_breakpoint \"mod1::sub_nested_outer\" \\\r\n+    \".*name = 'sub_nested_outer_mod1'\"\r\n+\r\n # Sanity check in main.\r\n gdb_breakpoint [gdb_get_line_number \"! BP_main\"]\r\n gdb_continue_to_breakpoint \"! BP_main\" \".*! BP_main\"\r"
    },
    {
      "sha": "ce2f269e484023393cc65b5475066c5ae641f20c",
      "filename": "gdb/testsuite/gdb.fortran/nested-funcs.f90",
      "status": "modified",
      "additions": 60,
      "deletions": 3,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/gdb.fortran/nested-funcs.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a4b09130aa8c2d2e1c1605a69962fe0a2499479/gdb/testsuite/gdb.fortran/nested-funcs.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/nested-funcs.f90?ref=0a4b09130aa8c2d2e1c1605a69962fe0a2499479",
      "patch": "@@ -13,19 +13,76 @@\n ! You should have received a copy of the GNU General Public License\r\n ! along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n \r\n-program TestNestedFuncs\r\n+module mod1\r\n+  integer :: var_i = 1\r\n+  integer :: var_const\r\n+  parameter (var_const = 20)\r\n+\r\n+CONTAINS\r\n+\r\n+  SUBROUTINE sub_nested_outer\r\n+    integer :: local_int\r\n+    character (len=20) :: name\r\n+\r\n+    name = 'sub_nested_outer_mod1'\r\n+    local_int = 11\r\n+\r\n+  END SUBROUTINE sub_nested_outer\r\n+end module mod1\r\n+\r\n+! Public sub_nested_outer\r\n+SUBROUTINE sub_nested_outer\r\n+  integer :: local_int\r\n+  character (len=16) :: name\r\n+\r\n+  name = 'sub_nested_outer external'\r\n+  local_int = 11\r\n+END SUBROUTINE sub_nested_outer\r\n+\r\n+! Needed indirection to call public sub_nested_outer from main\r\n+SUBROUTINE sub_nested_outer_ind\r\n+  character (len=20) :: name\r\n+\r\n+  name = 'sub_nested_outer_ind'\r\n+  CALL sub_nested_outer\r\n+END SUBROUTINE sub_nested_outer_ind\r\n+\r\n+! public routine with internal subroutine\r\n+SUBROUTINE sub_with_sub_nested_outer()\r\n+  integer :: local_int\r\n+  character (len=16) :: name\r\n+\r\n+  name = 'subroutine_with_int_sub'\r\n+  local_int = 1\r\n+\r\n+  CALL sub_nested_outer  ! Should call the internal fct\r\n+\r\n+CONTAINS\r\n \r\n+  SUBROUTINE sub_nested_outer\r\n+    integer :: local_int\r\n+    local_int = 11\r\n+  END SUBROUTINE sub_nested_outer\r\n+\r\n+END SUBROUTINE sub_with_sub_nested_outer\r\n+\r\n+! Main\r\n+program TestNestedFuncs\r\n+  USE mod1, sub_nested_outer_use_mod1 => sub_nested_outer\r\n   IMPLICIT NONE\r\n \r\n   TYPE :: t_State\r\n     integer :: code\r\n   END TYPE t_State\r\n \r\n   TYPE (t_State) :: v_state\r\n-  integer index\r\n+  integer index, local_int\r\n \r\n   index = 13\r\n-  CALL sub_nested_outer\r\n+  CALL sub_nested_outer            ! Call internal sub_nested_outer\r\n+  CALL sub_nested_outer_ind        ! Call external sub_nested_outer via sub_nested_outer_ind\r\n+  CALL sub_with_sub_nested_outer   ! Call external routine with nested sub_nested_outer\r\n+  CALL sub_nested_outer_use_mod1   ! Call sub_nested_outer imported via module\r\n   index = 11              ! BP_main\r\n   v_state%code = 27\r\n \r"
    }
  ]
}