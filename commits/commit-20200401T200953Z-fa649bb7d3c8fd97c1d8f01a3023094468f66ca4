{
  "sha": "fa649bb7d3c8fd97c1d8f01a3023094468f66ca4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmE2NDliYjdkM2M4ZmQ5N2MxZDhmMDFhMzAyMzA5NDQ2OGY2NmNhNA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-04-01T20:09:52Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-01T20:09:53Z"
    },
    "message": "Change the C parser to allow complex constants\n\nThis changes the C parser to allow complex constants.  Now something\nlike \"print 23i\" will work.\n\nThere are no tests in this patch; they come later.\n\ngdb/ChangeLog\n2020-04-01  Tom Tromey  <tom@tromey.com>\n\n\t* c-exp.y (COMPLEX_INT, COMPLEX_FLOAT): New tokens.\n\t(exp) <COMPLEX_INT, COMPLEX_FLOAT>: New rules.\n\t(parse_number): Handle complex numbers.",
    "tree": {
      "sha": "3c98b9f09421c287261c998a4fe9938f464d0e8e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3c98b9f09421c287261c998a4fe9938f464d0e8e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fa649bb7d3c8fd97c1d8f01a3023094468f66ca4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fa649bb7d3c8fd97c1d8f01a3023094468f66ca4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fa649bb7d3c8fd97c1d8f01a3023094468f66ca4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fa649bb7d3c8fd97c1d8f01a3023094468f66ca4/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "981c08ce72f5b8729381ddebf2f3fe5f1e000638",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/981c08ce72f5b8729381ddebf2f3fe5f1e000638",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/981c08ce72f5b8729381ddebf2f3fe5f1e000638"
    }
  ],
  "stats": {
    "total": 83,
    "additions": 75,
    "deletions": 8
  },
  "files": [
    {
      "sha": "ff3d83aadf2429c62c7671a31412278416d43c83",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fa649bb7d3c8fd97c1d8f01a3023094468f66ca4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fa649bb7d3c8fd97c1d8f01a3023094468f66ca4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=fa649bb7d3c8fd97c1d8f01a3023094468f66ca4",
      "patch": "@@ -1,3 +1,9 @@\n+2020-04-01  Tom Tromey  <tom@tromey.com>\n+\n+\t* c-exp.y (COMPLEX_INT, COMPLEX_FLOAT): New tokens.\n+\t(exp) <COMPLEX_INT, COMPLEX_FLOAT>: New rules.\n+\t(parse_number): Handle complex numbers.\n+\n 2020-04-01  Tom Tromey  <tom@tromey.com>\n \n \t* c-valprint.c (c_decorations): Change complex suffix to \"i\"."
    },
    {
      "sha": "c2531b9bffc47f9576751867f81ea15af0ccdb95",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 69,
      "deletions": 8,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fa649bb7d3c8fd97c1d8f01a3023094468f66ca4/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fa649bb7d3c8fd97c1d8f01a3023094468f66ca4/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=fa649bb7d3c8fd97c1d8f01a3023094468f66ca4",
      "patch": "@@ -54,6 +54,7 @@\n #include \"typeprint.h\"\n #include \"cp-abi.h\"\n #include \"type-stack.h\"\n+#include \"target-float.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n \n@@ -185,8 +186,8 @@ static void c_print_token (FILE *file, int type, YYSTYPE value);\n \n %type <type_stack> ptr_operator_ts abs_decl direct_abs_decl\n \n-%token <typed_val_int> INT\n-%token <typed_val_float> FLOAT\n+%token <typed_val_int> INT COMPLEX_INT\n+%token <typed_val_float> FLOAT COMPLEX_FLOAT\n \n /* Both NAME and TYPENAME tokens represent symbols in the input,\n    and both convey their data as strings.\n@@ -775,6 +776,22 @@ exp\t:\tINT\n \t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n \t;\n \n+exp\t:\tCOMPLEX_INT\n+\t\t\t{\n+\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  write_exp_elt_type (pstate, TYPE_TARGET_TYPE ($1.type));\n+\t\t\t  write_exp_elt_longcst (pstate, 0);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  write_exp_elt_type (pstate, TYPE_TARGET_TYPE ($1.type));\n+\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) ($1.val));\n+\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX);\n+\t\t\t  write_exp_elt_type (pstate, $1.type);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX);\n+\t\t\t}\n+\t;\n+\n exp\t:\tCHAR\n \t\t\t{\n \t\t\t  struct stoken_vector vec;\n@@ -804,6 +821,27 @@ exp\t:\tFLOAT\n \t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT); }\n \t;\n \n+exp\t:\tCOMPLEX_FLOAT\n+\t\t\t{\n+\t\t\t  struct type *underlying\n+\t\t\t    = TYPE_TARGET_TYPE ($1.type);\n+\n+\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n+\t\t\t  write_exp_elt_type (pstate, underlying);\n+\t\t\t  gdb_byte val[16];\n+\t\t\t  target_float_from_host_double (val, underlying, 0);\n+\t\t\t  write_exp_elt_floatcst (pstate, val);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n+\t\t\t  write_exp_elt_type (pstate, underlying);\n+\t\t\t  write_exp_elt_floatcst (pstate, $1.val);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX);\n+\t\t\t  write_exp_elt_type (pstate, $1.type);\n+\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX);\n+\t\t\t}\n+\t;\n+\n exp\t:\tvariable\n \t;\n \n@@ -1853,7 +1891,10 @@ parse_number (struct parser_state *par_state,\n   /* Number of \"L\" suffixes encountered.  */\n   int long_p = 0;\n \n-  /* We have found a \"L\" or \"U\" suffix.  */\n+  /* Imaginary number.  */\n+  bool imaginary_p = false;\n+\n+  /* We have found a \"L\" or \"U\" (or \"i\") suffix.  */\n   int found_suffix = 0;\n \n   ULONGEST high_bit;\n@@ -1866,6 +1907,12 @@ parse_number (struct parser_state *par_state,\n \n   if (parsed_float)\n     {\n+      if (len >= 1 && p[len - 1] == 'i')\n+\t{\n+\t  imaginary_p = true;\n+\t  --len;\n+\t}\n+\n       /* Handle suffixes for decimal floating-point: \"df\", \"dd\" or \"dl\".  */\n       if (len >= 2 && p[len - 2] == 'd' && p[len - 1] == 'f')\n \t{\n@@ -1909,7 +1956,12 @@ parse_number (struct parser_state *par_state,\n \t\t\tputithere->typed_val_float.type,\n \t\t\tputithere->typed_val_float.val))\n         return ERROR;\n-      return FLOAT;\n+\n+      if (imaginary_p)\n+\tputithere->typed_val_float.type\n+\t  = init_complex_type (nullptr, putithere->typed_val_float.type);\n+\n+      return imaginary_p ? COMPLEX_FLOAT : FLOAT;\n     }\n \n   /* Handle base-switching prefixes 0x, 0t, 0d, 0 */\n@@ -1958,7 +2010,7 @@ parse_number (struct parser_state *par_state,\n       c = *p++;\n       if (c >= 'A' && c <= 'Z')\n \tc += 'a' - 'A';\n-      if (c != 'l' && c != 'u')\n+      if (c != 'l' && c != 'u' && c != 'i')\n \tn *= base;\n       if (c >= '0' && c <= '9')\n \t{\n@@ -1984,6 +2036,11 @@ parse_number (struct parser_state *par_state,\n \t      unsigned_p = 1;\n \t      found_suffix = 1;\n \t    }\n+\t  else if (c == 'i')\n+\t    {\n+\t      imaginary_p = true;\n+\t      found_suffix = 1;\n+\t    }\n \t  else\n \t    return ERROR;\t/* Char not a digit */\n \t}\n@@ -1993,13 +2050,13 @@ parse_number (struct parser_state *par_state,\n       /* Portably test for overflow (only works for nonzero values, so make\n \t a second check for zero).  FIXME: Can't we just make n and prevn\n \t unsigned and avoid this?  */\n-      if (c != 'l' && c != 'u' && (prevn >= n) && n != 0)\n+      if (c != 'l' && c != 'u' && c != 'i' && (prevn >= n) && n != 0)\n \tunsigned_p = 1;\t\t/* Try something unsigned */\n \n       /* Portably test for unsigned overflow.\n \t FIXME: This check is wrong; for example it doesn't find overflow\n \t on 0x123456789 when LONGEST is 32 bits.  */\n-      if (c != 'l' && c != 'u' && n != 0)\n+      if (c != 'l' && c != 'u' && c != 'i' && n != 0)\n \t{\t\n \t  if (unsigned_p && prevn >= n)\n \t    error (_(\"Numeric constant too large.\"));\n@@ -2071,7 +2128,11 @@ parse_number (struct parser_state *par_state,\n        putithere->typed_val_int.type = signed_type;\n      }\n \n-   return INT;\n+   if (imaginary_p)\n+     putithere->typed_val_int.type\n+       = init_complex_type (nullptr, putithere->typed_val_int.type);\n+\n+   return imaginary_p ? COMPLEX_INT : INT;\n }\n \n /* Temporary obstack used for holding strings.  */"
    }
  ]
}