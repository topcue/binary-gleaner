{
  "sha": "ea11a98dbdb311631a9d214617f2ce054369bc5d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWExMWE5OGRiZGIzMTE2MzFhOWQyMTQ2MTdmMmNlMDU0MzY5YmM1ZA==",
  "commit": {
    "author": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2021-05-16T22:24:14Z"
    },
    "committer": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2021-05-16T22:24:14Z"
    },
    "message": "CTF: handle forward reference type\n\nThe problems can be illustrated, with any program, below:\n\n(gdb) print main\n$1 = {main} 0x0\n\nThe return type was incorrectly set in read_func_kind_type, with\nthe name of the function, which leads c_type_print_base_1 to print\nit. In addition, the address of a new function needs to be set with\nthat info in its minimal symtab entry, when the new function is added.\n\nAfter the fix:\n\n(gdb) print main\n$1 = {int ()} 0x4004b7 <main>\n\nA new test, gdb.ctf/funcreturn.exp, is added to the testsuite.\n\ngdb/ChangeLog:\n        * ctfread.c (new_symbol): Set function address.\n        (read_func_kind_type): Remove incorrect type name setting.\n        Don't copy name returned from ctf_type_ame_raw throughout file.\n\ngdb/testsuite/ChangeLog:\n        * gdb.ctf/funcreturn.exp: New file.\n        * gdb.ctf/whatis.c: Copy from gdb.base.",
    "tree": {
      "sha": "ff468f9b77f652b79bc6a7f0334f8849747c7e23",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ff468f9b77f652b79bc6a7f0334f8849747c7e23"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ea11a98dbdb311631a9d214617f2ce054369bc5d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea11a98dbdb311631a9d214617f2ce054369bc5d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ea11a98dbdb311631a9d214617f2ce054369bc5d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea11a98dbdb311631a9d214617f2ce054369bc5d/comments",
  "author": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "79633c125eb260a9ac9ed49e314b916f353c4373",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/79633c125eb260a9ac9ed49e314b916f353c4373",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/79633c125eb260a9ac9ed49e314b916f353c4373"
    }
  ],
  "stats": {
    "total": 589,
    "additions": 562,
    "deletions": 27
  },
  "files": [
    {
      "sha": "81e9dd5a29cd65acb149cd26fba23ff2b6de1138",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=ea11a98dbdb311631a9d214617f2ce054369bc5d",
      "patch": "@@ -1,3 +1,9 @@\n+2021-05-16  Weimin Pan  <weimin.pan@oracle.com>\n+\n+\t* ctfread.c (new_symbol): Set function address.\n+\t(read_func_kind_type): Remove incorrect type name setting.\n+\tDon't copy name returned from ctf_type_ame_raw throughout file.\n+\n 2021-05-14  Tom Tromey  <tom@tromey.com>\n \n \t* rust-lang.c (rust_language::val_print_struct)"
    },
    {
      "sha": "23e859a3b1ce92e9dff6d2b7c26a6cd289420d8b",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 22,
      "deletions": 27,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=ea11a98dbdb311631a9d214617f2ce054369bc5d",
      "patch": "@@ -462,14 +462,14 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n   ctf_dict_t *fp = ccp->fp;\n   struct symbol *sym = nullptr;\n \n-  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n+  const char *name = ctf_type_name_raw (fp, tid);\n   if (name != nullptr)\n     {\n       sym = new (&objfile->objfile_obstack) symbol;\n       OBJSTAT (objfile, n_syms++);\n \n       sym->set_language (language_c, &objfile->objfile_obstack);\n-      sym->compute_and_set_names (name.get (), true, objfile->per_bfd);\n+      sym->compute_and_set_names (name, false, objfile->per_bfd);\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n \n@@ -487,6 +487,7 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n \t    break;\n \t  case CTF_K_FUNCTION:\n \t    SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n+\t    set_symbol_address (objfile, sym, sym->linkage_name ());\n \t    break;\n \t  case CTF_K_CONST:\n \t    if (SYMBOL_TYPE (sym)->code () == TYPE_CODE_VOID)\n@@ -525,7 +526,7 @@ read_base_type (struct ctf_context *ccp, ctf_id_t tid)\n   ctf_dict_t *fp = ccp->fp;\n   ctf_encoding_t cet;\n   struct type *type = nullptr;\n-  char *name;\n+  const char *name;\n   uint32_t kind;\n \n   if (ctf_type_encoding (fp, tid, &cet))\n@@ -535,16 +536,14 @@ read_base_type (struct ctf_context *ccp, ctf_id_t tid)\n       return nullptr;\n     }\n \n-  gdb::unique_xmalloc_ptr<char> copied_name (ctf_type_aname_raw (fp, tid));\n-  if (copied_name == nullptr || strlen (copied_name.get ()) == 0)\n+  name = ctf_type_name_raw (fp, tid);\n+  if (name == nullptr || strlen (name) == 0)\n     {\n       name = ctf_type_aname (fp, tid);\n       if (name == nullptr)\n \tcomplaint (_(\"ctf_type_aname read_base_type failed - %s\"),\n \t\t   ctf_errmsg (ctf_errno (fp)));\n     }\n-  else\n-    name = obstack_strdup (&of->objfile_obstack, copied_name.get ());\n \n   kind = ctf_type_kind (fp, tid);\n   if (kind == CTF_K_INTEGER)\n@@ -623,9 +622,9 @@ read_structure_type (struct ctf_context *ccp, ctf_id_t tid)\n \n   type = alloc_type (of);\n \n-  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n-  if (name != nullptr && strlen (name.get ()) != 0)\n-    type->set_name (obstack_strdup (&of->objfile_obstack, name.get ()));\n+  const char *name = ctf_type_name_raw (fp, tid);\n+  if (name != nullptr && strlen (name) != 0)\n+    type->set_name (name);\n \n   kind = ctf_type_kind (fp, tid);\n   if (kind == CTF_K_UNION)\n@@ -682,10 +681,6 @@ read_func_kind_type (struct ctf_context *ccp, ctf_id_t tid)\n \n   type = alloc_type (of);\n \n-  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n-  if (name != nullptr && strlen (name.get ()) != 0)\n-    type->set_name (obstack_strdup (&of->objfile_obstack, name.get ()));\n-\n   type->set_code (TYPE_CODE_FUNC);\n   ctf_func_type_info (fp, tid, &cfi);\n   rettype = fetch_tid_type (ccp, cfi.ctc_return);\n@@ -734,9 +729,9 @@ read_enum_type (struct ctf_context *ccp, ctf_id_t tid)\n \n   type = alloc_type (of);\n \n-  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n-  if (name != nullptr && strlen (name.get ()) != 0)\n-    type->set_name (obstack_strdup (&of->objfile_obstack, name.get ()));\n+  const char *name = ctf_type_name_raw (fp, tid);\n+  if (name != nullptr && strlen (name) != 0)\n+    type->set_name (name);\n \n   type->set_code (TYPE_CODE_ENUM);\n   TYPE_LENGTH (type) = ctf_type_size (fp, tid);\n@@ -972,9 +967,9 @@ read_forward_type (struct ctf_context *ccp, ctf_id_t tid)\n \n   type = alloc_type (of);\n \n-  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n-  if (name != NULL && strlen (name.get()) != 0)\n-    type->set_name (obstack_strdup (&of->objfile_obstack, name.get ()));\n+  const char *name = ctf_type_name_raw (fp, tid);\n+  if (name != nullptr && strlen (name) != 0)\n+    type->set_name (name);\n \n   kind = ctf_type_kind_forwarded (fp, tid);\n   if (kind == CTF_K_UNION)\n@@ -1017,9 +1012,9 @@ read_type_record (struct ctf_context *ccp, ctf_id_t tid)\n \tbreak;\n       case CTF_K_TYPEDEF:\n \t{\n-\t  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n+\t  const char *name = ctf_type_name_raw (fp, tid);\n \t  btid = ctf_type_reference (fp, tid);\n-\t  type = read_typedef_type (ccp, tid, btid, name.get ());\n+\t  type = read_typedef_type (ccp, tid, btid, name);\n \t}\n \tbreak;\n       case CTF_K_VOLATILE:\n@@ -1444,7 +1439,6 @@ ctf_psymtab_type_cb (ctf_id_t tid, void *arg)\n   short section = -1;\n \n   ccp = (struct ctf_context *) arg;\n-  gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (ccp->fp, tid));\n \n   domain_enum domain = UNDEF_DOMAIN;\n   enum address_class aclass = LOC_UNDEF;\n@@ -1486,10 +1480,11 @@ ctf_psymtab_type_cb (ctf_id_t tid, void *arg)\n \treturn 0;\n     }\n \n-  if (name == nullptr || strlen (name.get ()) == 0)\n+  const char *name = ctf_type_name_raw (ccp->fp, tid);\n+  if (name == nullptr || strlen (name) == 0)\n     return 0;\n \n-  ccp->pst->add_psymbol (name.get (), true,\n+  ccp->pst->add_psymbol (name, false,\n \t\t\t domain, aclass, section,\n \t\t\t psymbol_placement::GLOBAL,\n \t\t\t 0, language_c, ccp->partial_symtabs, ccp->of);\n@@ -1545,7 +1540,7 @@ scan_partial_symbols (ctf_dict_t *cfp, psymtab_storage *partial_symtabs,\n \telse\n \t  continue;\n \t}\n-      gdb::unique_xmalloc_ptr<char> tname (ctf_type_aname_raw (cfp, tid));\n+      const char *tname = ctf_type_name_raw (cfp, tid);\n       uint32_t kind = ctf_type_kind (cfp, tid);\n       address_class aclass;\n       domain_enum tdomain;\n@@ -1568,7 +1563,7 @@ scan_partial_symbols (ctf_dict_t *cfp, psymtab_storage *partial_symtabs,\n       else\n \taclass = LOC_TYPEDEF;\n \n-      pst->add_psymbol (tname.get (), true,\n+      pst->add_psymbol (tname, false,\n \t\t\ttdomain, aclass, -1,\n \t\t\tpsymbol_placement::STATIC,\n \t\t\t0, language_c, partial_symtabs, of);"
    },
    {
      "sha": "0a8e5b202b0237bc2c9dbf91ecd1b0a0aa827d10",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=ea11a98dbdb311631a9d214617f2ce054369bc5d",
      "patch": "@@ -1,3 +1,8 @@\n+2021-05-16  Weimin Pan  <weimin.pan@oracle.com>\n+\n+\t* gdb.ctf/funcreturn.exp: New file.\n+\t* gdb.ctf/whatis.c: Copy from gdb.base.\n+\n 2021-05-14  Tom Tromey  <tom@tromey.com>\n \n \t* gdb.rust/pp.exp: New file."
    },
    {
      "sha": "874160e9aaccb0d2e41d984f7f7920de0fcd436d",
      "filename": "gdb/testsuite/gdb.ctf/funcreturn.exp",
      "status": "added",
      "additions": 190,
      "deletions": 0,
      "changes": 190,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/testsuite/gdb.ctf/funcreturn.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/testsuite/gdb.ctf/funcreturn.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ctf/funcreturn.exp?ref=ea11a98dbdb311631a9d214617f2ce054369bc5d",
      "patch": "@@ -0,0 +1,190 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+if [skip_ctf_tests] {\n+    unsupported \"no CTF debug format support, or CTF disabled in GDB\"\n+    return 0\n+}\n+\n+if [target_info exists no_long_long] {\n+    set exec_opts [list debug additional_flags=-DNO_LONG_LONG]\n+} else {\n+    set exec_opts [list debug]\n+}\n+\n+standard_testfile whatis.c\n+\n+# Using `-gt` generates full-fledged CTF debug information.\n+set opts \"additional_flags=-gt -Wl,--export-dynamic\"\n+\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} \\\n+\t  [list $srcfile] [list $opts nowarnings]] } {\n+    return 0\n+}\n+\n+# Create and source the file that provides information about the compiler\n+# used to compile the test case.\n+if [get_compiler_info] {\n+    return -1\n+}\n+\n+# test print command with functions return type\n+set void \"(void|)\"\n+gdb_test \"print v_char_func\" \\\n+    \"$decimal = \\{char \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_char_func>.*\" \\\n+    \"print char function\"\n+\n+gdb_test \"print v_signed_char_func\" \\\n+    \"$decimal = \\{signed char \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_signed_char_func>.*\" \\\n+    \"print signed char function\"\n+\n+gdb_test \"print v_unsigned_char_func\" \\\n+    \"$decimal = \\{unsigned char \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_unsigned_char_func>.*\" \\\n+    \"print unsigned char function\"\n+\n+gdb_test \"print v_short_func\" \\\n+    \"$decimal = \\{short \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_short_func>.*\" \\\n+    \"print short function\"\n+\n+gdb_test \"print v_signed_short_func\" \\\n+    \"$decimal = \\{signed short|short \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_signed_short_func>.*\" \\\n+    \"print signed short function\"\n+\n+gdb_test \"print v_unsigned_short_func\" \\\n+    \"$decimal = \\{unsigned short \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_unsigned_short_func>.*\" \\\n+    \"print unsigned short function\"\n+\n+gdb_test \"print v_int_func\" \\\n+    \"$decimal = \\{int \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_int_func>.*\" \\\n+    \"print int function\"\n+\n+gdb_test \"print v_signed_int_func\" \\\n+    \"$decimal = \\{signed int|int \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_signed_int_func>.*\" \\\n+    \"print signed int function\"\n+\n+gdb_test \"print v_unsigned_int_func\" \\\n+    \"$decimal = \\{unsigned int \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_unsigned_int_func>.*\" \\\n+    \"print unsigned int function\"\n+\n+gdb_test \"print v_long_func\" \\\n+    \"$decimal = \\{long \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_long_func>.*\" \\\n+    \"print long function\"\n+\n+gdb_test \"print v_signed_long_func\" \\\n+    \"$decimal = \\{signed long|long \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_signed_long_func>.*\" \\\n+    \"print signed long function\"\n+\n+gdb_test \"print v_unsigned_long_func\" \\\n+    \"$decimal = \\{unsigned long|long \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_unsigned_long_func>.*\" \\\n+    \"print unsigned long function\"\n+\n+if ![target_info exists no_long_long] {\n+    gdb_test \"print v_long_long_func\" \\\n+\t    \"$decimal = \\{long long \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_long_long_func>.*\" \\\n+\t\t\"print long long function\"\n+\n+    gdb_test \"print v_signed_long_long_func\" \\\n+\t    \"$decimal = \\{long long \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_signed_long_long_func>.*\" \\\n+\t\t\"print signed long long function\"\n+\n+    gdb_test \"print v_unsigned_long_long_func\" \\\n+\t    \"$decimal = \\{unsigned long long \\\\(\\\\)\\} 0x\\[0-9a-z\\]+ <v_unsigned_long_long_func>.*\" \\\n+\t\t\"print unsigned long long function\"\n+}\n+\n+# Sun /bin/cc calls this a function returning double.\n+if {!$gcc_compiled} then {setup_xfail \"*-sun-sunos4*\"}\n+\tgdb_test \"print v_float_func\" \\\n+\t    \"$decimal = \\{float \\\\(\\\\)\\} 0x\\[0-9a-z\\]+.*\" \\\n+\t    \"print float function\"\n+\n+\tgdb_test \"print v_double_func\" \\\n+\t    \"$decimal = \\{double \\\\(\\\\)\\} 0x\\[0-9a-z\\]+.*\" \\\n+\t    \"print double function\" \\\n+}\n+\n+# test whatis command with functions return type\n+gdb_test \"whatis v_char_func\" \\\n+    \"type = (signed |unsigned |)char \\\\($void\\\\)\" \\\n+    \"whatis char function\"\n+\n+gdb_test \"whatis v_signed_char_func\" \\\n+    \"type = (signed |unsigned |)char \\\\($void\\\\)\" \\\n+    \"whatis signed char function\"\n+\n+gdb_test \"whatis v_unsigned_char_func\" \\\n+    \"type = unsigned char \\\\($void\\\\)\"\t\\\n+    \"whatis unsigned char function\"\n+\n+gdb_test \"whatis v_short_func\" \\\n+    \"type = short (int |)\\\\($void\\\\)\" \\\n+    \"whatis short function\"\n+\n+gdb_test \"whatis v_signed_short_func\" \\\n+    \"type = (signed |)short (int |)\\\\($void\\\\)\" \\\n+    \"whatis signed short function\"\n+\n+gdb_test \"whatis v_unsigned_short_func\" \\\n+    \"type = (unsigned short|short unsigned int) \\\\($void\\\\)\" \\\n+    \"whatis unsigned short function\"\n+\n+gdb_test \"whatis v_int_func\" \\\n+    \"type = int \\\\($void\\\\)\" \\\n+    \"whatis int function\"\n+\n+gdb_test \"whatis v_signed_int_func\" \\\n+    \"type = (signed |)int \\\\($void\\\\)\" \\\n+    \"whatis signed int function\"\n+\n+gdb_test \"whatis v_unsigned_int_func\" \\\n+    \"type = unsigned int \\\\($void\\\\)\" \\\n+    \"whatis unsigned int function\"\n+\n+gdb_test \"whatis v_long_func\" \\\n+    \"type = (long|int|long int) \\\\($void\\\\)\" \\\n+    \"whatis long function\"\n+\n+gdb_test \"whatis v_signed_long_func\" \\\n+    \"type = (signed |)(int|long|long int) \\\\($void\\\\)\" \\\n+    \"whatis signed long function\"\n+\n+gdb_test \"whatis v_unsigned_long_func\" \\\n+    \"type = (unsigned (int|long|long int)|long unsigned int) \\\\($void\\\\)\" \\\n+    \"whatis unsigned long function\"\n+\n+if ![target_info exists no_long_long] {\n+    gdb_test \"whatis v_long_long_func\" \\\n+\t\"type = long long(| int) \\\\($void\\\\)\" \\\n+\t\"whatis long long function\"\n+\n+    gdb_test \"whatis v_signed_long_long_func\" \\\n+\t\"type = (signed |)long long(| int) \\\\($void\\\\)\" \\\n+\t\"whatis signed long long function\"\n+\n+    gdb_test \"whatis v_unsigned_long_long_func\" \\\n+\t\"type = (unsigned long long(| int)|long long unsigned int) \\\\($void\\\\)\" \\\n+\t\"whatis unsigned long long function\"\n+}\n+\n+# Sun /bin/cc calls this a function returning double.\n+if {!$gcc_compiled} then {setup_xfail \"*-sun-sunos4*\"}\n+\tgdb_test \"whatis v_float_func\" \\\n+\t    \"type = float \\\\($void\\\\)\" \\\n+\t    \"whatis float function\"\n+\n+\tgdb_test \"whatis v_double_func\" \\\n+\t    \"type = double \\\\($void\\\\)\" \\\n+\t    \"whatis double function\" \\\n+}"
    },
    {
      "sha": "c321fedbe4a81ebb1a6f4d51025a415a0cd67673",
      "filename": "gdb/testsuite/gdb.ctf/whatis.c",
      "status": "added",
      "additions": 339,
      "deletions": 0,
      "changes": 339,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/testsuite/gdb.ctf/whatis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ea11a98dbdb311631a9d214617f2ce054369bc5d/gdb/testsuite/gdb.ctf/whatis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ctf/whatis.c?ref=ea11a98dbdb311631a9d214617f2ce054369bc5d",
      "patch": "@@ -0,0 +1,339 @@\n+/* This test program is part of GDB, the GNU debugger.\n+\n+   Copyright 1992-2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/*\n+ *\tTest file with lots of different types, for testing the\n+ *\t\"whatis\" command.\n+ */\n+\n+/*\n+ *\tFirst the basic C types.\n+ */\n+\n+char\t\tv_char;\n+signed char\tv_signed_char;\n+unsigned char\tv_unsigned_char;\n+\n+short\t\tv_short;\n+signed short\tv_signed_short;\n+unsigned short\tv_unsigned_short;\n+\n+int\t\tv_int;\n+signed int\tv_signed_int;\n+unsigned int\tv_unsigned_int;\n+\n+long\t\tv_long;\n+signed long\tv_signed_long;\n+unsigned long\tv_unsigned_long;\n+\n+#ifndef NO_LONG_LONG\n+long long\t\tv_long_long;\n+signed long long\tv_signed_long_long;\n+unsigned long long\tv_unsigned_long_long;\n+#endif\n+\n+float\t\tv_float;\n+double\t\tv_double;\n+\n+/*\n+ *\tNow some derived types, which are arrays, functions-returning,\n+ *\tpointers, structures, unions, and enumerations.\n+ */\n+\n+/**** arrays *******/\n+\n+char\t\tv_char_array[2];\n+signed char\tv_signed_char_array[2];\n+unsigned char\tv_unsigned_char_array[2];\n+\n+short\t\tv_short_array[2];\n+signed short\tv_signed_short_array[2];\n+unsigned short\tv_unsigned_short_array[2];\n+\n+int\t\tv_int_array[2];\n+signed int\tv_signed_int_array[2];\n+unsigned int\tv_unsigned_int_array[2];\n+\n+long\t\tv_long_array[2];\n+signed long\tv_signed_long_array[2];\n+unsigned long\tv_unsigned_long_array[2];\n+\n+#ifndef NO_LONG_LONG\n+long long\t\tv_long_long_array[2];\n+signed long long\tv_signed_long_long_array[2];\n+unsigned long long\tv_unsigned_long_long_array[2];\n+#endif\n+\n+float\t\tv_float_array[2];\n+double\t\tv_double_array[2];\n+\n+/**** pointers *******/\n+\n+/* Make sure they still print as pointer to foo even there is a typedef\n+   for that type.  Test this not just for char *, which might be\n+   a special case kludge in GDB (Unix system include files like to define\n+   caddr_t), but for a variety of types.  */\n+typedef char *char_addr;\n+char_addr a_char_addr;\n+typedef unsigned short *ushort_addr;\n+ushort_addr a_ushort_addr;\n+typedef signed long *slong_addr;\n+slong_addr a_slong_addr;\n+#ifndef NO_LONG_LONG\n+typedef signed long long *slong_long_addr;\n+slong_long_addr a_slong_long_addr;\n+#endif\n+\n+char\t\t*v_char_pointer;\n+signed char\t*v_signed_char_pointer;\n+unsigned char\t*v_unsigned_char_pointer;\n+\n+short\t\t*v_short_pointer;\n+signed short\t*v_signed_short_pointer;\n+unsigned short\t*v_unsigned_short_pointer;\n+\n+int\t\t*v_int_pointer;\n+signed int\t*v_signed_int_pointer;\n+unsigned int\t*v_unsigned_int_pointer;\n+\n+long\t\t*v_long_pointer;\n+signed long\t*v_signed_long_pointer;\n+unsigned long\t*v_unsigned_long_pointer;\n+\n+#ifndef NO_LONG_LONG\n+long long\t\t*v_long_long_pointer;\n+signed long long\t*v_signed_long_long_pointer;\n+unsigned long long\t*v_unsigned_long_long_pointer;\n+#endif\n+\n+float\t\t*v_float_pointer;\n+double\t\t*v_double_pointer;\n+\n+/**** structs *******/\n+\n+struct t_struct {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+#ifndef NO_LONG_LONG\n+    long long\tv_long_long_member;\n+#endif\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_struct1, *v_struct_ptr1;\n+\n+struct {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+#ifndef NO_LONG_LONG\n+    long long\tv_long_long_member;\n+#endif\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_struct2, *v_struct_ptr2;\n+\n+/**** unions *******/\n+\n+union t_union {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+#ifndef NO_LONG_LONG\n+    long long\tv_long_long_member;\n+#endif\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_union, *v_union_ptr;\n+\n+union {\n+    char\tv_char_member;\n+    short\tv_short_member;\n+    int\t\tv_int_member;\n+    long\tv_long_member;\n+#ifndef NO_LONG_LONG\n+    long long\tv_long_long_member;\n+#endif\n+    float\tv_float_member;\n+    double\tv_double_member;\n+} v_union2, *v_union_ptr2;\n+\n+/*** Functions returning type ********/\n+\n+char\t\tv_char_func () { return(0); }\n+signed char\tv_signed_char_func () { return (0); }\n+unsigned char\tv_unsigned_char_func () { return (0); }\n+\n+short\t\tv_short_func () { return (0); }\n+signed short\tv_signed_short_func () { return (0); }\n+unsigned short\tv_unsigned_short_func () { return (0); }\n+\n+int\t\tv_int_func () { return (0); }\n+signed int\tv_signed_int_func () { return (0); }\n+unsigned int\tv_unsigned_int_func () { return (0); }\n+\n+long\t\tv_long_func () { return (0); }\n+signed long\tv_signed_long_func () { return (0); }\n+unsigned long\tv_unsigned_long_func () { return (0); }\n+\n+#ifndef NO_LONG_LONG\n+long long\t\tv_long_long_func () { return (0); }\n+signed long long\tv_signed_long_long_func () { return (0); }\n+unsigned long long\tv_unsigned_long_long_func () { return (0); }\n+#endif\n+\n+float\t\tv_float_func () { return (0.0); }\n+double\t\tv_double_func () { return (0.0); }\n+\n+/**** Some misc more complicated things *******/\n+\n+struct link {\n+\tstruct link *next;\n+#ifdef __STDC__\n+\tstruct link *(*linkfunc) (struct link *self, int flags);\n+#else\n+\tstruct link *(*linkfunc) ();\n+#endif\n+\tstruct t_struct stuff[1][2][3];\n+} *s_link;\n+\n+union tu_link {\n+\tstruct link *next;\n+#ifdef __STDC__\n+\tstruct link *(*linkfunc) (struct link *self, int flags);\n+#else\n+\tstruct link *(*linkfunc) ();\n+#endif\n+\tstruct t_struct stuff[1][2][3];\n+} u_link;\n+\n+struct outer_struct {\n+\tint outer_int;\n+\tstruct inner_struct {\n+\t\tint inner_int;\n+\t\tlong inner_long;\n+\t}inner_struct_instance;\n+\tunion inner_union {\n+\t\tint inner_union_int;\n+\t\tlong inner_union_long;\n+\t}inner_union_instance;\n+\tlong outer_long;\n+} nested_su;\n+\n+/**** Enumerations *******/\n+\n+enum colors {red, green, blue} color;\n+enum cars {chevy, ford, porsche} clunker;\n+\n+/***********/\n+\n+int main ()\n+{\n+  /* Some linkers (e.g. on AIX) remove unreferenced variables,\n+     so make sure to reference them. */\n+  v_char = 0;\n+  v_signed_char = 1;\n+  v_unsigned_char = 2;\n+\n+  v_short = 3;\n+  v_signed_short = 4;\n+  v_unsigned_short = 5;\n+\n+  v_int = 6;\n+  v_signed_int = 7;\n+  v_unsigned_int = 8;\n+\n+  v_long = 9;\n+  v_signed_long = 10;\n+  v_unsigned_long = 11;\n+\n+#ifndef NO_LONG_LONG\n+  v_long_long = 12;\n+  v_signed_long_long = 13;\n+  v_unsigned_long_long = 14;\n+#endif\n+\n+  v_float = 100.0;\n+  v_double = 200.0;\n+\n+\n+  v_char_array[0] = v_char;\n+  v_signed_char_array[0] = v_signed_char;\n+  v_unsigned_char_array[0] = v_unsigned_char;\n+\n+  v_short_array[0] = v_short;\n+  v_signed_short_array[0] = v_signed_short;\n+  v_unsigned_short_array[0] = v_unsigned_short;\n+\n+  v_int_array[0] = v_int;\n+  v_signed_int_array[0] = v_signed_int;\n+  v_unsigned_int_array[0] = v_unsigned_int;\n+\n+  v_long_array[0] = v_long;\n+  v_signed_long_array[0] = v_signed_long;\n+  v_unsigned_long_array[0] = v_unsigned_long;\n+\n+#ifndef NO_LONG_LONG\n+  v_long_long_array[0] = v_long_long;\n+  v_signed_long_long_array[0] = v_signed_long_long;\n+  v_unsigned_long_long_array[0] = v_unsigned_long_long;\n+#endif\n+\n+  v_float_array[0] = v_float;\n+  v_double_array[0] = v_double;\n+\n+  v_char_pointer = &v_char;\n+  v_signed_char_pointer = &v_signed_char;\n+  v_unsigned_char_pointer = &v_unsigned_char;\n+\n+  v_short_pointer = &v_short;\n+  v_signed_short_pointer = &v_signed_short;\n+  v_unsigned_short_pointer = &v_unsigned_short;\n+\n+  v_int_pointer = &v_int;\n+  v_signed_int_pointer = &v_signed_int;\n+  v_unsigned_int_pointer = &v_unsigned_int;\n+\n+  v_long_pointer = &v_long;\n+  v_signed_long_pointer = &v_signed_long;\n+  v_unsigned_long_pointer = &v_unsigned_long;\n+\n+#ifndef NO_LONG_LONG\n+  v_long_long_pointer = &v_long_long;\n+  v_signed_long_long_pointer = &v_signed_long_long;\n+  v_unsigned_long_long_pointer = &v_unsigned_long_long;\n+#endif\n+\n+  v_float_pointer = &v_float;\n+  v_double_pointer = &v_double;\n+\n+  color = red;\n+  clunker = porsche;\n+\n+  u_link.next = s_link;\n+\n+  v_union2.v_short_member = v_union.v_short_member;\n+\n+  v_struct1.v_char_member = 0;\n+  v_struct2.v_char_member = 0;\n+\n+  nested_su.outer_int = 0;\n+  return 0;\n+}"
    }
  ]
}