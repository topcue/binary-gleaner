{
  "sha": "c1e1314d00fda5625f1a87b915fd83a61c253993",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzFlMTMxNGQwMGZkYTU2MjVmMWE4N2I5MTVmZDgzYTYxYzI1Mzk5Mw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-09-17T20:11:38Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-09-17T20:28:06Z"
    },
    "message": "Change management of tdesc_arch_data\n\nWhile working on something else, I noticed that tdesc_data_cleanup\ntook a void* parameter.  Looking more into this, I found that\ntdesc_use_registers expected a transfer of ownership.\n\nI think it's better to express this sort of thing via the type system,\nwhen possible.  This patch changes tdesc_data_alloc to return a unique\npointer, changes tdesc_use_registers to accept an rvalue reference,\nand then adapts all the users.\n\nNote that a deleter structure is introduced to avoid having to move\ntdesc_arch_data to the header file.\n\n2020-09-17  Tom Tromey  <tromey@adacore.com>\n\n\t* tic6x-tdep.c (tic6x_gdbarch_init): Update.\n\t* target-descriptions.h (struct tdesc_arch_data_deleter): New.\n\t(tdesc_arch_data_up): New typedef.\n\t(tdesc_use_registers, tdesc_data_alloc): Update.\n\t(tdesc_data_cleanup): Don't declare.\n\t* target-descriptions.c (tdesc_data_alloc): Return a\n\ttdesc_arch_data_up.\n\t(tdesc_arch_data_deleter::operator()): Rename from\n\ttdesc_data_cleanup.  Change argument type.\n\t(tdesc_use_registers): Change early_data to an rvalue reference.\n\t(tdesc_use_registers): Don't use delete.\n\t* sparc-tdep.c (sparc32_gdbarch_init): Update.\n\t* s390-tdep.c (s390_gdbarch_init): Update.\n\t* rx-tdep.c (rx_gdbarch_init): Update.\n\t* rs6000-tdep.c (rs6000_gdbarch_init): Update.\n\t* riscv-tdep.c (riscv_gdbarch_init): Update.\n\t* or1k-tdep.c (or1k_gdbarch_init): Update.\n\t* nios2-tdep.c (nios2_gdbarch_init): Update.\n\t* nds32-tdep.c (nds32_gdbarch_init): Update.\n\t* mips-tdep.c (mips_gdbarch_init): Update.\n\t* microblaze-tdep.c (microblaze_gdbarch_init): Update.\n\t* m68k-tdep.c (m68k_gdbarch_init): Update.\n\t* i386-tdep.c (i386_gdbarch_init): Update.\n\t* arm-tdep.c (arm_gdbarch_init): Update.\n\t* arc-tdep.c (arc_tdesc_init): Update.\n\t(arc_gdbarch_init): Update.\n\t* aarch64-tdep.c (aarch64_gdbarch_init): Update.",
    "tree": {
      "sha": "62affcd614124eec0c51db5223b0ea7f797a17d1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/62affcd614124eec0c51db5223b0ea7f797a17d1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c1e1314d00fda5625f1a87b915fd83a61c253993",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c1e1314d00fda5625f1a87b915fd83a61c253993",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c1e1314d00fda5625f1a87b915fd83a61c253993",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c1e1314d00fda5625f1a87b915fd83a61c253993/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0363df3db7d3f5edd3a349ab7720eca83f460545",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0363df3db7d3f5edd3a349ab7720eca83f460545",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0363df3db7d3f5edd3a349ab7720eca83f460545"
    }
  ],
  "stats": {
    "total": 612,
    "additions": 250,
    "deletions": 362
  },
  "files": [
    {
      "sha": "45940b9dc46960bb03b97ac467c65b1744eb26f7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -1,3 +1,33 @@\n+2020-09-17  Tom Tromey  <tromey@adacore.com>\n+\n+\t* tic6x-tdep.c (tic6x_gdbarch_init): Update.\n+\t* target-descriptions.h (struct tdesc_arch_data_deleter): New.\n+\t(tdesc_arch_data_up): New typedef.\n+\t(tdesc_use_registers, tdesc_data_alloc): Update.\n+\t(tdesc_data_cleanup): Don't declare.\n+\t* target-descriptions.c (tdesc_data_alloc): Return a\n+\ttdesc_arch_data_up.\n+\t(tdesc_arch_data_deleter::operator()): Rename from\n+\ttdesc_data_cleanup.  Change argument type.\n+\t(tdesc_use_registers): Change early_data to an rvalue reference.\n+\t(tdesc_use_registers): Don't use delete.\n+\t* sparc-tdep.c (sparc32_gdbarch_init): Update.\n+\t* s390-tdep.c (s390_gdbarch_init): Update.\n+\t* rx-tdep.c (rx_gdbarch_init): Update.\n+\t* rs6000-tdep.c (rs6000_gdbarch_init): Update.\n+\t* riscv-tdep.c (riscv_gdbarch_init): Update.\n+\t* or1k-tdep.c (or1k_gdbarch_init): Update.\n+\t* nios2-tdep.c (nios2_gdbarch_init): Update.\n+\t* nds32-tdep.c (nds32_gdbarch_init): Update.\n+\t* mips-tdep.c (mips_gdbarch_init): Update.\n+\t* microblaze-tdep.c (microblaze_gdbarch_init): Update.\n+\t* m68k-tdep.c (m68k_gdbarch_init): Update.\n+\t* i386-tdep.c (i386_gdbarch_init): Update.\n+\t* arm-tdep.c (arm_gdbarch_init): Update.\n+\t* arc-tdep.c (arc_tdesc_init): Update.\n+\t(arc_gdbarch_init): Update.\n+\t* aarch64-tdep.c (aarch64_gdbarch_init): Update.\n+\n 2020-09-17  Hannes Domani  <ssbssa@yahoo.de>\n \n \t* windows-nat.c (ctrl_c_handler): Use 32bit DbgUiRemoteBreakin"
    },
    {
      "sha": "cbc7038dbba9472a12a3ae927bbb0937b10b2bdd",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 11,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -3403,12 +3403,12 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   if (feature_core == nullptr)\n     return nullptr;\n \n-  struct tdesc_arch_data *tdesc_data = tdesc_data_alloc ();\n+  tdesc_arch_data_up tdesc_data = tdesc_data_alloc ();\n \n   /* Validate the description provides the mandatory core R registers\n      and allocate their numbers.  */\n   for (i = 0; i < ARRAY_SIZE (aarch64_r_register_names); i++)\n-    valid_p &= tdesc_numbered_register (feature_core, tdesc_data,\n+    valid_p &= tdesc_numbered_register (feature_core, tdesc_data.get (),\n \t\t\t\t\tAARCH64_X0_REGNUM + i,\n \t\t\t\t\taarch64_r_register_names[i]);\n \n@@ -3423,7 +3423,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       /* Validate the description provides the mandatory V registers\n \t and allocate their numbers.  */\n       for (i = 0; i < ARRAY_SIZE (aarch64_v_register_names); i++)\n-\tvalid_p &= tdesc_numbered_register (feature_fpu, tdesc_data,\n+\tvalid_p &= tdesc_numbered_register (feature_fpu, tdesc_data.get (),\n \t\t\t\t\t    AARCH64_V0_REGNUM + i,\n \t\t\t\t\t    aarch64_v_register_names[i]);\n \n@@ -3436,7 +3436,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       /* Validate the description provides the mandatory SVE registers\n \t and allocate their numbers.  */\n       for (i = 0; i < ARRAY_SIZE (aarch64_sve_register_names); i++)\n-\tvalid_p &= tdesc_numbered_register (feature_sve, tdesc_data,\n+\tvalid_p &= tdesc_numbered_register (feature_sve, tdesc_data.get (),\n \t\t\t\t\t    AARCH64_SVE_Z0_REGNUM + i,\n \t\t\t\t\t    aarch64_sve_register_names[i]);\n \n@@ -3461,7 +3461,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       /* Validate the descriptor provides the mandatory PAUTH registers and\n \t allocate their numbers.  */\n       for (i = 0; i < ARRAY_SIZE (aarch64_pauth_register_names); i++)\n-\tvalid_p &= tdesc_numbered_register (feature_pauth, tdesc_data,\n+\tvalid_p &= tdesc_numbered_register (feature_pauth, tdesc_data.get (),\n \t\t\t\t\t    first_pauth_regnum + i,\n \t\t\t\t\t    aarch64_pauth_register_names[i]);\n \n@@ -3470,10 +3470,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     }\n \n   if (!valid_p)\n-    {\n-      tdesc_data_cleanup (tdesc_data);\n-      return nullptr;\n-    }\n+    return nullptr;\n \n   /* AArch64 code is always little-endian.  */\n   info.byte_order_for_code = BFD_ENDIAN_LITTLE;\n@@ -3554,7 +3551,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* Hook in the ABI-specific overrides, if they have been registered.  */\n   info.target_desc = tdesc;\n-  info.tdesc_data = tdesc_data;\n+  info.tdesc_data = tdesc_data.get ();\n   gdbarch_init_osabi (info, gdbarch);\n \n   dwarf2_frame_set_init_reg (gdbarch, aarch64_dwarf2_frame_init_reg);\n@@ -3583,7 +3580,7 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   set_gdbarch_get_pc_address_flags (gdbarch, aarch64_get_pc_address_flags);\n \n-  tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   /* Add standard register aliases.  */\n   for (i = 0; i < ARRAY_SIZE (aarch64_register_aliases); i++)"
    },
    {
      "sha": "6878875ee9d59698943316a2d3e93aa93bdbf7be",
      "filename": "gdb/arc-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 9,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/arc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/arc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -2076,7 +2076,7 @@ arc_check_for_hw_loops (const struct target_desc *tdesc,\n \n static bool\n arc_tdesc_init (struct gdbarch_info info, const struct target_desc **tdesc,\n-\t\tstruct tdesc_arch_data **tdesc_data)\n+\t\ttdesc_arch_data_up *tdesc_data)\n {\n   const struct target_desc *tdesc_loc = info.target_desc;\n   if (arc_debug)\n@@ -2125,28 +2125,27 @@ arc_tdesc_init (struct gdbarch_info info, const struct target_desc **tdesc,\n   const arc_register_feature *arc_aux_reg_feature\n     = determine_aux_reg_feature_set ();\n \n-  struct tdesc_arch_data *tdesc_data_loc = tdesc_data_alloc ();\n+  tdesc_arch_data_up tdesc_data_loc = tdesc_data_alloc ();\n \n   arc_update_acc_reg_names (info.byte_order);\n \n-  bool valid_p = arc_check_tdesc_feature (tdesc_data_loc,\n+  bool valid_p = arc_check_tdesc_feature (tdesc_data_loc.get (),\n \t\t\t\t\t  feature_core,\n \t\t\t\t\t  arc_core_reg_feature);\n \n-  valid_p &= arc_check_tdesc_feature (tdesc_data_loc,\n+  valid_p &= arc_check_tdesc_feature (tdesc_data_loc.get (),\n \t\t\t\t      feature_aux,\n \t\t\t\t      arc_aux_reg_feature);\n \n   if (!valid_p)\n     {\n       if (arc_debug)\n         debug_printf (\"arc: Target description is not valid\\n\");\n-      tdesc_data_cleanup (tdesc_data_loc);\n       return false;\n     }\n \n   *tdesc = tdesc_loc;\n-  *tdesc_data = tdesc_data_loc;\n+  *tdesc_data = std::move (tdesc_data_loc);\n \n   return true;\n }\n@@ -2185,7 +2184,7 @@ static struct gdbarch *\n arc_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   const struct target_desc *tdesc;\n-  struct tdesc_arch_data *tdesc_data;\n+  tdesc_arch_data_up tdesc_data;\n \n   if (arc_debug)\n     debug_printf (\"arc: Architecture initialization.\\n\");\n@@ -2198,7 +2197,7 @@ arc_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   gdb::unique_xmalloc_ptr<struct gdbarch_tdep> tdep\n     (XCNEW (struct gdbarch_tdep));\n   tdep->jb_pc = -1; /* No longjmp support by default.  */\n-  tdep->has_hw_loops = arc_check_for_hw_loops (tdesc, tdesc_data);\n+  tdep->has_hw_loops = arc_check_for_hw_loops (tdesc, tdesc_data.get ());\n   struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep.release ());\n \n   /* Data types.  */\n@@ -2338,7 +2337,7 @@ arc_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t}\n     }\n \n-  tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   return gdbarch;\n }"
    },
    {
      "sha": "23da42f934cf1ea446e61c3c63caade3ac2c1990",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 21,
      "deletions": 40,
      "changes": 61,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -8967,7 +8967,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   struct gdbarch_list *best_arch;\n   enum arm_abi_kind arm_abi = arm_abi_global;\n   enum arm_float_model fp_model = arm_fp_model;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   int i;\n   bool is_m = false;\n   int vfp_register_count = 0;\n@@ -9156,43 +9156,37 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n       valid_p = 1;\n       for (i = 0; i < ARM_SP_REGNUM; i++)\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t    arm_register_names[i]);\n-      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data.get (),\n \t\t\t\t\t\t  ARM_SP_REGNUM,\n \t\t\t\t\t\t  arm_sp_names);\n-      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data.get (),\n \t\t\t\t\t\t  ARM_LR_REGNUM,\n \t\t\t\t\t\t  arm_lr_names);\n-      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data.get (),\n \t\t\t\t\t\t  ARM_PC_REGNUM,\n \t\t\t\t\t\t  arm_pc_names);\n       if (is_m)\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t    ARM_PS_REGNUM, \"xpsr\");\n       else\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t    ARM_PS_REGNUM, \"cpsr\");\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n       feature = tdesc_find_feature (tdesc,\n \t\t\t\t    \"org.gnu.gdb.arm.fpa\");\n       if (feature != NULL)\n \t{\n \t  valid_p = 1;\n \t  for (i = ARM_F0_REGNUM; i <= ARM_FPS_REGNUM; i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t\tarm_register_names[i]);\n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t}\n       else\n \thave_fpa_registers = false;\n@@ -9211,25 +9205,22 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  valid_p = 1;\n \t  for (i = ARM_WR0_REGNUM; i <= ARM_WR15_REGNUM; i++)\n \t    valid_p\n-\t      &= tdesc_numbered_register (feature, tdesc_data, i,\n+\t      &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t  iwmmxt_names[i - ARM_WR0_REGNUM]);\n \n \t  /* Check for the control registers, but do not fail if they\n \t     are missing.  */\n \t  for (i = ARM_WC0_REGNUM; i <= ARM_WCASF_REGNUM; i++)\n-\t    tdesc_numbered_register (feature, tdesc_data, i,\n+\t    tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t     iwmmxt_names[i - ARM_WR0_REGNUM]);\n \n \t  for (i = ARM_WCGR0_REGNUM; i <= ARM_WCGR3_REGNUM; i++)\n \t    valid_p\n-\t      &= tdesc_numbered_register (feature, tdesc_data, i,\n+\t      &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t  iwmmxt_names[i - ARM_WR0_REGNUM]);\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \n \t  have_wmmx_registers = true;\n \t}\n@@ -9253,7 +9244,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  valid_p = 1;\n \t  for (i = 0; i < 32; i++)\n \t    {\n-\t      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t  ARM_D0_REGNUM + i,\n \t\t\t\t\t\t  vfp_double_names[i]);\n \t      if (!valid_p)\n@@ -9263,13 +9254,10 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t    valid_p = 1;\n \n \t  /* Also require FPSCR.  */\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      ARM_FPSCR_REGNUM, \"fpscr\");\n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \n \t  if (tdesc_unnumbered_register (feature, \"s0\") == 0)\n \t    have_vfp_pseudos = true;\n@@ -9285,10 +9273,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t    {\n \t      /* NEON requires 32 double-precision registers.  */\n \t      if (i != 32)\n-\t\t{\n-\t\t  tdesc_data_cleanup (tdesc_data);\n-\t\t  return NULL;\n-\t\t}\n+\t\treturn NULL;\n \n \t      /* If there are quad registers defined by the stub, use\n \t\t their type; otherwise (normally) provide them with\n@@ -9328,11 +9313,7 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     }\n \n   if (best_arch != NULL)\n-    {\n-      if (tdesc_data != NULL)\n-\ttdesc_data_cleanup (tdesc_data);\n-      return best_arch->gdbarch;\n-    }\n+    return best_arch->gdbarch;\n \n   tdep = XCNEW (struct gdbarch_tdep);\n   gdbarch = gdbarch_alloc (&info, tdep);\n@@ -9534,11 +9515,11 @@ arm_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       set_gdbarch_pseudo_register_write (gdbarch, arm_pseudo_write);\n     }\n \n-  if (tdesc_data)\n+  if (tdesc_data != nullptr)\n     {\n       set_tdesc_pseudo_register_name (gdbarch, arm_register_name);\n \n-      tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+      tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n       /* Override tdesc_register_type to adjust the types of VFP\n \t registers for NEON.  */"
    },
    {
      "sha": "95cfe5b820eeb092ab11766aa707ce950de0b740",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -8430,7 +8430,6 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n-  struct tdesc_arch_data *tdesc_data;\n   const struct target_desc *tdesc;\n   int mm0_regnum;\n   int ymm0_regnum;\n@@ -8669,7 +8668,7 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* No segment base registers.  */\n   tdep->fsbase_regnum = -1;\n \n-  tdesc_data = tdesc_data_alloc ();\n+  tdesc_arch_data_up tdesc_data = tdesc_data_alloc ();\n \n   set_gdbarch_relocate_instruction (gdbarch, i386_relocate_instruction);\n \n@@ -8682,12 +8681,11 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* Hook in ABI-specific overrides, if they have been registered.\n      Note: If INFO specifies a 64 bit arch, this is where we turn\n      a 32-bit i386 into a 64-bit amd64.  */\n-  info.tdesc_data = tdesc_data;\n+  info.tdesc_data = tdesc_data.get ();\n   gdbarch_init_osabi (info, gdbarch);\n \n-  if (!i386_validate_tdesc_p (tdep, tdesc_data))\n+  if (!i386_validate_tdesc_p (tdep, tdesc_data.get ()))\n     {\n-      tdesc_data_cleanup (tdesc_data);\n       xfree (tdep);\n       gdbarch_free (gdbarch);\n       return NULL;\n@@ -8709,7 +8707,7 @@ i386_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* Target description may be changed.  */\n   tdesc = tdep->tdesc;\n \n-  tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   /* Override gdbarch_register_reggroup_p set in tdesc_use_registers.  */\n   set_gdbarch_register_reggroup_p (gdbarch, tdep->register_reggroup_p);"
    },
    {
      "sha": "193916d38145037c8a92f94bec8f84aa2ef2f8a9",
      "filename": "gdb/m68k-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 18,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/m68k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/m68k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -1130,7 +1130,7 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   struct gdbarch_tdep *tdep = NULL;\n   struct gdbarch *gdbarch;\n   struct gdbarch_list *best_arch;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   int i;\n   enum m68k_flavour flavour = m68k_no_flavour;\n   int has_fp = 1;\n@@ -1168,28 +1168,22 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n       valid_p = 1;\n       for (i = 0; i <= M68K_PC_REGNUM; i++)\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t    m68k_register_names[i]);\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n       feature = tdesc_find_feature (info.target_desc,\n \t\t\t\t    \"org.gnu.gdb.coldfire.fp\");\n       if (feature != NULL)\n \t{\n \t  valid_p = 1;\n \t  for (i = M68K_FP0_REGNUM; i <= M68K_FPI_REGNUM; i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t\tm68k_register_names[i]);\n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t}\n       else\n \thas_fp = 0;\n@@ -1246,11 +1240,7 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     }\n \n   if (best_arch != NULL)\n-    {\n-      if (tdesc_data != NULL)\n-\ttdesc_data_cleanup (tdesc_data);\n-      return best_arch->gdbarch;\n-    }\n+    return best_arch->gdbarch;\n \n   tdep = XCNEW (struct gdbarch_tdep);\n   gdbarch = gdbarch_alloc (&info, tdep);\n@@ -1327,8 +1317,8 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   frame_unwind_append_unwinder (gdbarch, &m68k_frame_unwind);\n \n-  if (tdesc_data)\n-    tdesc_use_registers (gdbarch, info.target_desc, tdesc_data);\n+  if (tdesc_data != nullptr)\n+    tdesc_use_registers (gdbarch, info.target_desc, std::move (tdesc_data));\n \n   return gdbarch;\n }"
    },
    {
      "sha": "b5da32e61b5d30e981f00a5ebc696aca096fbd07",
      "filename": "gdb/microblaze-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 9,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/microblaze-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/microblaze-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/microblaze-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -651,7 +651,7 @@ microblaze_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch_tdep *tdep;\n   struct gdbarch *gdbarch;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n \n   /* If there is already a candidate, use it.  */\n@@ -676,26 +676,23 @@ microblaze_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n       valid_p = 1;\n       for (i = 0; i < MICROBLAZE_NUM_CORE_REGS; i++)\n-        valid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+        valid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n                                             microblaze_register_names[i]);\n       feature = tdesc_find_feature (tdesc,\n                                     \"org.gnu.gdb.microblaze.stack-protect\");\n       if (feature != NULL)\n         {\n           valid_p = 1;\n-          valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+          valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n                                               MICROBLAZE_SLR_REGNUM,\n                                               \"rslr\");\n-          valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+          valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n                                               MICROBLAZE_SHR_REGNUM,\n                                               \"rshr\");\n         }\n \n       if (!valid_p)\n-        {\n-          tdesc_data_cleanup (tdesc_data);\n-          return NULL;\n-        }\n+\treturn NULL;\n     }\n \n   /* Allocate space for the new architecture.  */\n@@ -748,7 +745,7 @@ microblaze_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   frame_unwind_append_unwinder (gdbarch, &microblaze_frame_unwind);\n   frame_base_append_sniffer (gdbarch, dwarf2_frame_base_sniffer);\n   if (tdesc_data != NULL)\n-    tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+    tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   return gdbarch;\n }"
    },
    {
      "sha": "b4ed734c5fbdb8af449f379e6b67de7a11c02b9e",
      "filename": "gdb/mips-tdep.c",
      "status": "modified",
      "additions": 27,
      "deletions": 47,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/mips-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/mips-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mips-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -8047,7 +8047,7 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   enum mips_abi mips_abi, found_abi, wanted_abi;\n   int i, num_regs;\n   enum mips_fpu_type fpu_type;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   int elf_fpu_type = Val_GNU_MIPS_ABI_FP_ANY;\n   const char * const *reg_names;\n   struct mips_regnum mips_regnum, *regnum;\n@@ -8310,73 +8310,58 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n       valid_p = 1;\n       for (i = MIPS_ZERO_REGNUM; i <= MIPS_RA_REGNUM; i++)\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t    mips_gprs[i]);\n \n \n-      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t  mips_regnum.lo, \"lo\");\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t  mips_regnum.hi, \"hi\");\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t  mips_regnum.pc, \"pc\");\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n       feature = tdesc_find_feature (info.target_desc,\n \t\t\t\t    \"org.gnu.gdb.mips.cp0\");\n       if (feature == NULL)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n       valid_p = 1;\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t  mips_regnum.badvaddr, \"badvaddr\");\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t  MIPS_PS_REGNUM, \"status\");\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t  mips_regnum.cause, \"cause\");\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n       /* FIXME drow/2007-05-17: The FPU should be optional.  The MIPS\n \t backend is not prepared for that, though.  */\n       feature = tdesc_find_feature (info.target_desc,\n \t\t\t\t    \"org.gnu.gdb.mips.fpu\");\n       if (feature == NULL)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n       valid_p = 1;\n       for (i = 0; i < 32; i++)\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t    i + mips_regnum.fp0, mips_fprs[i]);\n \n-      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t  mips_regnum.fp_control_status,\n \t\t\t\t\t  \"fcsr\");\n       valid_p\n-\t&= tdesc_numbered_register (feature, tdesc_data,\n+\t&= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t    mips_regnum.fp_implementation_revision,\n \t\t\t\t    \"fir\");\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n       num_regs = mips_regnum.fp_implementation_revision + 1;\n \n@@ -8389,27 +8374,24 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t    {\n \t      i = 0;\n \t      valid_p = 1;\n-\t      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t  dspacc + i++, \"hi1\");\n-\t      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t  dspacc + i++, \"lo1\");\n-\t      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t  dspacc + i++, \"hi2\");\n-\t      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t  dspacc + i++, \"lo2\");\n-\t      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t  dspacc + i++, \"hi3\");\n-\t      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t  dspacc + i++, \"lo3\");\n \n-\t      valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t  dspctl, \"dspctl\");\n \n \t      if (!valid_p)\n-\t\t{\n-\t\t  tdesc_data_cleanup (tdesc_data);\n-\t\t  return NULL;\n-\t\t}\n+\t\treturn NULL;\n \n \t      mips_regnum.dspacc = dspacc;\n \t      mips_regnum.dspctl = dspctl;\n@@ -8445,8 +8427,6 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       if (MIPS_FPU_TYPE (arches->gdbarch) != fpu_type)\n \tcontinue;\n \n-      if (tdesc_data != NULL)\n-\ttdesc_data_cleanup (tdesc_data);\n       return arches->gdbarch;\n     }\n \n@@ -8743,7 +8723,7 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   mips_register_g_packet_guesses (gdbarch);\n \n   /* Hook in OS ABI-specific overrides, if they have been registered.  */\n-  info.tdesc_data = tdesc_data;\n+  info.tdesc_data = tdesc_data.get ();\n   gdbarch_init_osabi (info, gdbarch);\n \n   /* The hook may have adjusted num_regs, fetch the final value and\n@@ -8764,10 +8744,10 @@ mips_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   frame_base_append_sniffer (gdbarch, mips_micro_frame_base_sniffer);\n   frame_base_append_sniffer (gdbarch, mips_insn32_frame_base_sniffer);\n \n-  if (tdesc_data)\n+  if (tdesc_data != nullptr)\n     {\n       set_tdesc_pseudo_register_type (gdbarch, mips_pseudo_register_type);\n-      tdesc_use_registers (gdbarch, info.target_desc, tdesc_data);\n+      tdesc_use_registers (gdbarch, info.target_desc, std::move (tdesc_data));\n \n       /* Override the normal target description methods to handle our\n \t dual real and pseudo registers.  */"
    },
    {
      "sha": "afc7c6124209688f167e70746c2240db6383a0b1",
      "filename": "gdb/nds32-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 8,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/nds32-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/nds32-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nds32-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -1955,7 +1955,7 @@ nds32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   struct gdbarch *gdbarch;\n   struct gdbarch_tdep *tdep;\n   struct gdbarch_list *best_arch;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n   int elf_abi = E_NDS_ABI_AABI;\n   int fpu_freg = -1;\n@@ -1988,11 +1988,9 @@ nds32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   tdesc_data = tdesc_data_alloc ();\n \n-  if (!nds32_validate_tdesc_p (tdesc, tdesc_data, &fpu_freg, &use_pseudo_fsrs))\n-    {\n-      tdesc_data_cleanup (tdesc_data);\n-      return NULL;\n-    }\n+  if (!nds32_validate_tdesc_p (tdesc, tdesc_data.get (), &fpu_freg,\n+\t\t\t       &use_pseudo_fsrs))\n+    return NULL;\n \n   /* Allocate space for the new architecture.  */\n   tdep = XCNEW (struct gdbarch_tdep);\n@@ -2022,7 +2020,7 @@ nds32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n     num_regs = NDS32_NUM_REGS + num_fdr_map[fpu_freg] + num_fsr_map[fpu_freg];\n \n   set_gdbarch_num_regs (gdbarch, num_regs);\n-  tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   /* Cache the register number of fs0.  */\n   if (fpu_freg != -1)\n@@ -2061,7 +2059,7 @@ nds32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   nds32_add_reggroups (gdbarch);\n \n   /* Hook in ABI-specific overrides, if they have been registered.  */\n-  info.tdesc_data = tdesc_data;\n+  info.tdesc_data = tdesc_data.get ();\n   gdbarch_init_osabi (info, gdbarch);\n \n   /* Override tdesc_register callbacks for system registers.  */"
    },
    {
      "sha": "09eb6fcb5dd6b261f861d4dd5fe7378824b344d1",
      "filename": "gdb/nios2-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/nios2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/nios2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -2275,7 +2275,7 @@ nios2_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   struct gdbarch *gdbarch;\n   struct gdbarch_tdep *tdep;\n   int i;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n \n   if (!tdesc_has_registers (tdesc))\n@@ -2297,14 +2297,11 @@ nios2_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       valid_p = 1;\n       \n       for (i = 0; i < NIOS2_NUM_REGS; i++)\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t    nios2_reg_names[i]);\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n     }\n \n   /* Find a candidate among the list of pre-declared architectures.  */\n@@ -2384,8 +2381,8 @@ nios2_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* Enable inferior call support.  */\n   set_gdbarch_push_dummy_call (gdbarch, nios2_push_dummy_call);\n \n-  if (tdesc_data)\n-    tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  if (tdesc_data != nullptr)\n+    tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   return gdbarch;\n }"
    },
    {
      "sha": "7b16cdbba263257af6c92f04432245fa43e69f09",
      "filename": "gdb/or1k-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 7,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/or1k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/or1k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/or1k-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -1113,7 +1113,7 @@ or1k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   struct gdbarch *gdbarch;\n   struct gdbarch_tdep *tdep;\n   const struct bfd_arch_info *binfo;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n \n   /* Find a candidate among the list of pre-declared architectures.  */\n@@ -1221,14 +1221,11 @@ or1k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       valid_p = 1;\n \n       for (i = 0; i < OR1K_NUM_REGS; i++)\n-        valid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+        valid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n                                             or1k_reg_names[i]);\n \n       if (!valid_p)\n-        {\n-          tdesc_data_cleanup (tdesc_data);\n-          return NULL;\n-        }\n+\treturn NULL;\n     }\n \n   if (tdesc_data != NULL)\n@@ -1243,7 +1240,7 @@ or1k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       reggroup_add (gdbarch, save_reggroup);\n       reggroup_add (gdbarch, restore_reggroup);\n \n-      tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+      tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n     }\n \n   /* Hook in ABI-specific overrides, if they have been registered.  */"
    },
    {
      "sha": "2c4eeab720be469d08634527911e3c81161d3162",
      "filename": "gdb/riscv-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 11,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/riscv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/riscv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/riscv-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -3320,10 +3320,10 @@ riscv_gdbarch_init (struct gdbarch_info info,\n   if (feature_cpu == NULL)\n     return NULL;\n \n-  struct tdesc_arch_data *tdesc_data = tdesc_data_alloc ();\n+  tdesc_arch_data_up tdesc_data = tdesc_data_alloc ();\n   std::vector<riscv_pending_register_alias> pending_aliases;\n \n-  bool valid_p = riscv_check_tdesc_feature (tdesc_data,\n+  bool valid_p = riscv_check_tdesc_feature (tdesc_data.get (),\n                                             feature_cpu, feature_csr,\n                                             &riscv_xreg_feature,\n                                             &pending_aliases);\n@@ -3345,7 +3345,7 @@ riscv_gdbarch_init (struct gdbarch_info info,\n \n   if (feature_fpu != NULL)\n     {\n-      valid_p &= riscv_check_tdesc_feature (tdesc_data, feature_fpu,\n+      valid_p &= riscv_check_tdesc_feature (tdesc_data.get (), feature_fpu,\n \t\t\t\t\t    feature_csr,\n                                             &riscv_freg_feature,\n                                             &pending_aliases);\n@@ -3383,20 +3383,19 @@ riscv_gdbarch_init (struct gdbarch_info info,\n     }\n \n   if (feature_virtual)\n-    riscv_check_tdesc_feature (tdesc_data, feature_virtual, feature_csr,\n+    riscv_check_tdesc_feature (tdesc_data.get (), feature_virtual, feature_csr,\n                                &riscv_virtual_feature,\n                                &pending_aliases);\n \n   if (feature_csr)\n-    riscv_check_tdesc_feature (tdesc_data, feature_csr, nullptr,\n+    riscv_check_tdesc_feature (tdesc_data.get (), feature_csr, nullptr,\n                                &riscv_csr_feature,\n                                &pending_aliases);\n \n   if (!valid_p)\n     {\n       if (riscv_debug_gdbarch)\n         fprintf_unfiltered (gdb_stdlog, \"Target description is not valid\\n\");\n-      tdesc_data_cleanup (tdesc_data);\n       return NULL;\n     }\n \n@@ -3442,10 +3441,7 @@ riscv_gdbarch_init (struct gdbarch_info info,\n     }\n \n   if (arches != NULL)\n-    {\n-      tdesc_data_cleanup (tdesc_data);\n-      return arches->gdbarch;\n-    }\n+    return arches->gdbarch;\n \n   /* None found, so create a new architecture from the information provided.  */\n   tdep = new (struct gdbarch_tdep);\n@@ -3511,7 +3507,8 @@ riscv_gdbarch_init (struct gdbarch_info info,\n   set_gdbarch_print_registers_info (gdbarch, riscv_print_registers_info);\n \n   /* Finalise the target description registers.  */\n-  tdesc_use_registers (gdbarch, tdesc, tdesc_data, riscv_tdesc_unknown_reg);\n+  tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data),\n+\t\t       riscv_tdesc_unknown_reg);\n \n   /* Override the register type callback setup by the target description\n      mechanism.  This allows us to provide special type for floating point"
    },
    {
      "sha": "7e65151a046ee8125680367683390875505a47e8",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 62,
      "deletions": 122,
      "changes": 184,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -6138,7 +6138,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   int have_htm_tar = 0;\n   int tdesc_wordsize = -1;\n   const struct target_desc *tdesc = info.target_desc;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   int num_pseudoregs = 0;\n   int cur_reg;\n \n@@ -6235,31 +6235,29 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n       valid_p = 1;\n       for (i = 0; i < ppc_num_gprs; i++)\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data, i, gprs[i]);\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data, PPC_PC_REGNUM,\n-\t\t\t\t\t  \"pc\");\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data, PPC_LR_REGNUM,\n-\t\t\t\t\t  \"lr\");\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data, PPC_XER_REGNUM,\n-\t\t\t\t\t  \"xer\");\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t    i, gprs[i]);\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t  PPC_PC_REGNUM, \"pc\");\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t  PPC_LR_REGNUM, \"lr\");\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t  PPC_XER_REGNUM, \"xer\");\n \n       /* Allow alternate names for these registers, to accomodate GDB's\n \t historic naming.  */\n-      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data.get (),\n \t\t\t\t\t\t  PPC_MSR_REGNUM, msr_names);\n-      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data.get (),\n \t\t\t\t\t\t  PPC_CR_REGNUM, cr_names);\n-      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data,\n+      valid_p &= tdesc_numbered_register_choices (feature, tdesc_data.get (),\n \t\t\t\t\t\t  PPC_CTR_REGNUM, ctr_names);\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n-      have_mq = tdesc_numbered_register (feature, tdesc_data, PPC_MQ_REGNUM,\n-\t\t\t\t\t \"mq\");\n+      have_mq = tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t PPC_MQ_REGNUM, \"mq\");\n \n       tdesc_wordsize = tdesc_register_bitsize (feature, \"pc\") / 8;\n       if (wordsize == -1)\n@@ -6277,16 +6275,13 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  };\n \t  valid_p = 1;\n \t  for (i = 0; i < ppc_num_fprs; i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_F0_REGNUM + i, fprs[i]);\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_FPSCR_REGNUM, \"fpscr\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_fpu = 1;\n \n \t  /* The fpscr register was expanded in isa 2.05 to 64 bits\n@@ -6311,19 +6306,16 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n \t  valid_p = 1;\n \t  for (i = 0; i < ppc_num_gprs; i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_VR0_REGNUM + i,\n \t\t\t\t\t\tvector_regs[i]);\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_VSCR_REGNUM, \"vscr\");\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_VRSAVE_REGNUM, \"vrsave\");\n \n \t  if (have_spe || !valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_altivec = 1;\n \t}\n       else\n@@ -6347,15 +6339,12 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  valid_p = 1;\n \n \t  for (i = 0; i < ppc_num_vshrs; i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_VSR0_UPPER_REGNUM + i,\n \t\t\t\t\t\tvsx_regs[i]);\n \n \t  if (!valid_p || !have_fpu || !have_altivec)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \n \t  have_vsx = 1;\n \t}\n@@ -6392,19 +6381,16 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n \t  valid_p = 1;\n \t  for (i = 0; i < ppc_num_gprs; i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_SPE_UPPER_GP0_REGNUM + i,\n \t\t\t\t\t\tupper_spe[i]);\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_SPE_ACC_REGNUM, \"acc\");\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_SPE_FSCR_REGNUM, \"spefscr\");\n \n \t  if (have_mq || have_fpu || !valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_spe = 1;\n \t}\n       else\n@@ -6416,14 +6402,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       if (feature != NULL)\n \t{\n \t  valid_p = 1;\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_PPR_REGNUM, \"ppr\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_ppr = 1;\n \t}\n       else\n@@ -6435,14 +6418,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       if (feature != NULL)\n \t{\n \t  valid_p = 1;\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_DSCR_REGNUM, \"dscr\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_dscr = 1;\n \t}\n       else\n@@ -6454,14 +6434,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       if (feature != NULL)\n \t{\n \t  valid_p = 1;\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_TAR_REGNUM, \"tar\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_tar = 1;\n \t}\n       else\n@@ -6478,14 +6455,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n \t  valid_p = 1;\n \t  for (i = 0; i < ARRAY_SIZE (ebb_regs); i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_BESCR_REGNUM + i,\n \t\t\t\t\t\tebb_regs[i]);\n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_ebb = 1;\n \t}\n       else\n@@ -6499,27 +6473,24 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t{\n \t  valid_p = 1;\n \n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_MMCR0_REGNUM,\n \t\t\t\t\t      \"mmcr0\");\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_MMCR2_REGNUM,\n \t\t\t\t\t      \"mmcr2\");\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_SIAR_REGNUM,\n \t\t\t\t\t      \"siar\");\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_SDAR_REGNUM,\n \t\t\t\t\t      \"sdar\");\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t      PPC_SIER_REGNUM,\n \t\t\t\t\t      \"sier\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_pmu = 1;\n \t}\n       else\n@@ -6536,14 +6507,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n \t  valid_p = 1;\n \t  for (i = 0; i < ARRAY_SIZE (tm_spr_regs); i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_TFHAR_REGNUM + i,\n \t\t\t\t\t\ttm_spr_regs[i]);\n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \n \t  have_htm_spr = 1;\n \t}\n@@ -6565,14 +6533,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  valid_p = 1;\n \n \t  for (i = 0; i < ARRAY_SIZE (cgprs); i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_CR0_REGNUM + i,\n \t\t\t\t\t\tcgprs[i]);\n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \n \t  have_htm_core = 1;\n \t}\n@@ -6594,15 +6559,12 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  };\n \n \t  for (i = 0; i < ARRAY_SIZE (cfprs); i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_CF0_REGNUM + i,\n \t\t\t\t\t\tcfprs[i]);\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_htm_fpu = 1;\n \t}\n       else\n@@ -6624,15 +6586,12 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  };\n \n \t  for (i = 0; i < ARRAY_SIZE (cvmx); i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\tPPC_CVR0_REGNUM + i,\n \t\t\t\t\t\tcvmx[i]);\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_htm_altivec = 1;\n \t}\n       else\n@@ -6654,16 +6613,13 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  };\n \n \t  for (i = 0; i < ARRAY_SIZE (cvsx); i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data,\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t\t(PPC_CVSR0_UPPER_REGNUM\n \t\t\t\t\t\t + i),\n \t\t\t\t\t\tcvsx[i]);\n \n \t  if (!valid_p || !have_htm_fpu || !have_htm_altivec)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_htm_vsx = 1;\n \t}\n       else\n@@ -6673,14 +6629,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t\t\t\t    \"org.gnu.gdb.power.htm.ppr\");\n       if (feature != NULL)\n \t{\n-\t  valid_p = tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p = tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t     PPC_CPPR_REGNUM, \"cppr\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_htm_ppr = 1;\n \t}\n       else\n@@ -6690,14 +6643,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t\t\t\t    \"org.gnu.gdb.power.htm.dscr\");\n       if (feature != NULL)\n \t{\n-\t  valid_p = tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p = tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t     PPC_CDSCR_REGNUM, \"cdscr\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_htm_dscr = 1;\n \t}\n       else\n@@ -6707,14 +6657,11 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t\t\t\t    \"org.gnu.gdb.power.htm.tar\");\n       if (feature != NULL)\n \t{\n-\t  valid_p = tdesc_numbered_register (feature, tdesc_data,\n+\t  valid_p = tdesc_numbered_register (feature, tdesc_data.get (),\n \t\t\t\t\t     PPC_CTAR_REGNUM, \"ctar\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t  have_htm_tar = 1;\n \t}\n       else\n@@ -6733,10 +6680,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n      supplies a 64-bit description while debugging a 32-bit\n      binary.  */\n   if (tdesc_wordsize != -1 && tdesc_wordsize != wordsize)\n-    {\n-      tdesc_data_cleanup (tdesc_data);\n-      return NULL;\n-    }\n+    return NULL;\n \n #ifdef HAVE_ELF\n   if (from_elf_exec)\n@@ -6872,11 +6816,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       if (tdep && tdep->vector_abi != vector_abi)\n \tcontinue;\n       if (tdep && tdep->wordsize == wordsize)\n-\t{\n-\t  if (tdesc_data != NULL)\n-\t    tdesc_data_cleanup (tdesc_data);\n-\t  return arches->gdbarch;\n-\t}\n+\treturn arches->gdbarch;\n     }\n \n   /* None found, create a new architecture from INFO, whose bfd_arch_info\n@@ -7070,7 +7010,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   /* Hook in ABI-specific overrides, if they have been registered.  */\n   info.target_desc = tdesc;\n-  info.tdesc_data = tdesc_data;\n+  info.tdesc_data = tdesc_data.get ();\n   gdbarch_init_osabi (info, gdbarch);\n \n   switch (info.osabi)\n@@ -7093,7 +7033,7 @@ rs6000_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   set_tdesc_pseudo_register_type (gdbarch, rs6000_pseudo_register_type);\n   set_tdesc_pseudo_register_reggroup_p (gdbarch,\n \t\t\t\t\trs6000_pseudo_register_reggroup_p);\n-  tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   /* Override the normal target description method to make the SPE upper\n      halves anonymous.  */"
    },
    {
      "sha": "46963272f9c842757ed9c213ce3ca7f9f3c66742",
      "filename": "gdb/rx-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 8,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/rx-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/rx-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rx-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -944,7 +944,7 @@ rx_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   struct gdbarch *gdbarch;\n   struct gdbarch_tdep *tdep;\n   int elf_flags;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n \n   /* Extract the elf_flags if available.  */\n@@ -982,15 +982,12 @@ rx_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t{\n \t  tdesc_data = tdesc_data_alloc ();\n \t  for (int i = 0; i < RX_NUM_REGS; i++)\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n-                                            rx_register_names[i]);\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n+\t\t\t\t\t\trx_register_names[i]);\n \t}\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n     }\n \n   gdb_assert(tdesc_data != NULL);\n@@ -1000,7 +997,7 @@ rx_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   tdep->elf_flags = elf_flags;\n \n   set_gdbarch_num_regs (gdbarch, RX_NUM_REGS);\n-  tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   set_gdbarch_num_pseudo_regs (gdbarch, 0);\n   set_gdbarch_pc_regnum (gdbarch, RX_PC_REGNUM);"
    },
    {
      "sha": "4d3644e5a7608f9c238750fb6470a3e8049e35ad",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 6,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -7022,8 +7022,8 @@ s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   struct gdbarch_tdep *tdep = s390_gdbarch_tdep_alloc ();\n   struct gdbarch *gdbarch = gdbarch_alloc (&info, tdep);\n-  struct tdesc_arch_data *tdesc_data = tdesc_data_alloc ();\n-  info.tdesc_data = tdesc_data;\n+  tdesc_arch_data_up tdesc_data = tdesc_data_alloc ();\n+  info.tdesc_data = tdesc_data.get ();\n \n   set_gdbarch_believe_pcc_promotion (gdbarch, 0);\n   set_gdbarch_char_signed (gdbarch, 0);\n@@ -7149,9 +7149,8 @@ s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   tdep->tdesc = tdesc;\n \n   /* Check any target description for validity.  */\n-  if (!s390_tdesc_valid (tdep, tdesc_data))\n+  if (!s390_tdesc_valid (tdep, tdesc_data.get ()))\n     {\n-      tdesc_data_cleanup (tdesc_data);\n       xfree (tdep);\n       gdbarch_free (gdbarch);\n       return NULL;\n@@ -7182,13 +7181,12 @@ s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       if (tmp->vector_abi != tdep->vector_abi)\n \tcontinue;\n \n-      tdesc_data_cleanup (tdesc_data);\n       xfree (tdep);\n       gdbarch_free (gdbarch);\n       return arches->gdbarch;\n     }\n \n-  tdesc_use_registers (gdbarch, tdep->tdesc, tdesc_data);\n+  tdesc_use_registers (gdbarch, tdep->tdesc, std::move (tdesc_data));\n   set_gdbarch_register_name (gdbarch, s390_register_name);\n \n   /* Assign pseudo register numbers.  */"
    },
    {
      "sha": "e9636cd8a74ffb86f5dbfea99816f6b24a42487e",
      "filename": "gdb/sparc-tdep.c",
      "status": "modified",
      "additions": 7,
      "deletions": 10,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/sparc-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/sparc-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sparc-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -1898,35 +1898,32 @@ sparc32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n   if (tdesc_has_registers (tdesc))\n     {\n-      struct tdesc_arch_data *tdesc_data = tdesc_data_alloc ();\n+      tdesc_arch_data_up tdesc_data = tdesc_data_alloc ();\n \n       /* Validate that the descriptor provides the mandatory registers\n          and allocate their numbers. */\n-      valid_p &= validate_tdesc_registers (tdesc, tdesc_data,\n+      valid_p &= validate_tdesc_registers (tdesc, tdesc_data.get (),\n                                            \"org.gnu.gdb.sparc.cpu\",\n                                            sparc_core_register_names,\n                                            ARRAY_SIZE (sparc_core_register_names),\n                                            SPARC_G0_REGNUM);\n-      valid_p &= validate_tdesc_registers (tdesc, tdesc_data,\n+      valid_p &= validate_tdesc_registers (tdesc, tdesc_data.get (),\n                                            \"org.gnu.gdb.sparc.fpu\",\n                                            tdep->fpu_register_names,\n                                            tdep->fpu_registers_num,\n                                            SPARC_F0_REGNUM);\n-      valid_p &= validate_tdesc_registers (tdesc, tdesc_data,\n+      valid_p &= validate_tdesc_registers (tdesc, tdesc_data.get (),\n                                            \"org.gnu.gdb.sparc.cp0\",\n                                            tdep->cp0_register_names,\n                                            tdep->cp0_registers_num,\n                                            SPARC_F0_REGNUM\n                                            + tdep->fpu_registers_num);\n       if (!valid_p)\n-        {\n-          tdesc_data_cleanup (tdesc_data);\n-          return NULL;\n-        }\n+\treturn NULL;\n \n       /* Target description may have changed. */\n-      info.tdesc_data = tdesc_data;\n-      tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+      info.tdesc_data = tdesc_data.get ();\n+      tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n     }\n \n   /* If we have register sets, enable the generic core file support.  */"
    },
    {
      "sha": "19dbcbeac39e2f612edf481e169701154cef78d8",
      "filename": "gdb/target-descriptions.c",
      "status": "modified",
      "additions": 6,
      "deletions": 11,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/target-descriptions.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/target-descriptions.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-descriptions.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -779,21 +779,17 @@ tdesc_data_init (struct obstack *obstack)\n /* Similar, but for the temporary copy used during architecture\n    initialization.  */\n \n-struct tdesc_arch_data *\n+tdesc_arch_data_up\n tdesc_data_alloc (void)\n {\n-  return new tdesc_arch_data ();\n+  return tdesc_arch_data_up (new tdesc_arch_data ());\n }\n \n-/* Free something allocated by tdesc_data_alloc, if it is not going\n-   to be used (for instance if it was unsuitable for the\n-   architecture).  */\n+/* See target-descriptions.h.  */\n \n void\n-tdesc_data_cleanup (void *data_untyped)\n+tdesc_arch_data_deleter::operator() (struct tdesc_arch_data *data) const\n {\n-  struct tdesc_arch_data *data = (struct tdesc_arch_data *) data_untyped;\n-\n   delete data;\n }\n \n@@ -1103,7 +1099,7 @@ set_tdesc_pseudo_register_reggroup_p\n void\n tdesc_use_registers (struct gdbarch *gdbarch,\n \t\t     const struct target_desc *target_desc,\n-\t\t     struct tdesc_arch_data *early_data,\n+\t\t     tdesc_arch_data_up &&early_data,\n \t\t     tdesc_unknown_register_ftype unk_reg_cb)\n {\n   int num_regs = gdbarch_num_regs (gdbarch);\n@@ -1116,8 +1112,7 @@ tdesc_use_registers (struct gdbarch *gdbarch,\n   gdb_assert (tdesc_has_registers (target_desc));\n \n   data = (struct tdesc_arch_data *) gdbarch_data (gdbarch, tdesc_data);\n-  data->arch_regs = early_data->arch_regs;\n-  delete early_data;\n+  data->arch_regs = std::move (early_data->arch_regs);\n \n   /* Build up a set of all registers, so that we can assign register\n      numbers where needed.  The hash table expands as necessary, so"
    },
    {
      "sha": "171ef76379a7d61ee85587fb70b4d70cb584fcb4",
      "filename": "gdb/target-descriptions.h",
      "status": "modified",
      "additions": 14,
      "deletions": 8,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/target-descriptions.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/target-descriptions.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-descriptions.h?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -104,6 +104,18 @@ typedef int (*tdesc_unknown_register_ftype)\n \t(struct gdbarch *gdbarch, tdesc_feature *feature,\n \t const char *reg_name, int possible_regnum);\n \n+/* A deleter adapter for a target arch data.  */\n+\n+struct tdesc_arch_data_deleter\n+{\n+  void operator() (struct tdesc_arch_data *data) const;\n+};\n+\n+/* A unique pointer specialization that holds a target_desc.  */\n+\n+typedef std::unique_ptr<tdesc_arch_data, tdesc_arch_data_deleter>\n+  tdesc_arch_data_up;\n+\n /* Update GDBARCH to use the TARGET_DESC for registers.  TARGET_DESC\n    may be GDBARCH's target description or (if GDBARCH does not have\n    one which describes registers) another target description\n@@ -119,19 +131,13 @@ typedef int (*tdesc_unknown_register_ftype)\n \n void tdesc_use_registers (struct gdbarch *gdbarch,\n \t\t\t  const struct target_desc *target_desc,\n-\t\t\t  struct tdesc_arch_data *early_data,\n+\t\t\t  tdesc_arch_data_up &&early_data,\n \t\t\t  tdesc_unknown_register_ftype unk_reg_cb = NULL);\n \n /* Allocate initial data for validation of a target description during\n    gdbarch initialization.  */\n \n-struct tdesc_arch_data *tdesc_data_alloc (void);\n-\n-/* Clean up data allocated by tdesc_data_alloc.  This should only\n-   be called to discard the data; tdesc_use_registers takes ownership\n-   of its EARLY_DATA argument.  */\n-\n-void tdesc_data_cleanup (void *data_untyped);\n+tdesc_arch_data_up tdesc_data_alloc ();\n \n /* Search FEATURE for a register named NAME.  Record REGNO and the\n    register in DATA; when tdesc_use_registers is called, REGNO will be"
    },
    {
      "sha": "17e6e658cf39168a248fd83f770199b5683d2bd2",
      "filename": "gdb/tic6x-tdep.c",
      "status": "modified",
      "additions": 17,
      "deletions": 23,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/tic6x-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c1e1314d00fda5625f1a87b915fd83a61c253993/gdb/tic6x-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tic6x-tdep.c?ref=c1e1314d00fda5625f1a87b915fd83a61c253993",
      "patch": "@@ -1140,7 +1140,7 @@ tic6x_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n {\n   struct gdbarch *gdbarch;\n   struct gdbarch_tdep *tdep;\n-  struct tdesc_arch_data *tdesc_data = NULL;\n+  tdesc_arch_data_up tdesc_data;\n   const struct target_desc *tdesc = info.target_desc;\n   int has_gp = 0;\n \n@@ -1159,20 +1159,17 @@ tic6x_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \n       valid_p = 1;\n       for (i = 0; i < 32; i++)\t/* A0 - A15, B0 - B15 */\n-\tvalid_p &= tdesc_numbered_register (feature, tdesc_data, i,\n+\tvalid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i,\n \t\t\t\t\t    tic6x_register_names[i]);\n \n       /* CSR */\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data, i++,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i++,\n \t\t\t\t\t  tic6x_register_names[TIC6X_CSR_REGNUM]);\n-      valid_p &= tdesc_numbered_register (feature, tdesc_data, i++,\n+      valid_p &= tdesc_numbered_register (feature, tdesc_data.get (), i++,\n \t\t\t\t\t  tic6x_register_names[TIC6X_PC_REGNUM]);\n \n       if (!valid_p)\n-\t{\n-\t  tdesc_data_cleanup (tdesc_data);\n-\t  return NULL;\n-\t}\n+\treturn NULL;\n \n       feature = tdesc_find_feature (tdesc, \"org.gnu.gdb.tic6x.gp\");\n       if (feature)\n@@ -1189,28 +1186,25 @@ tic6x_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \t  has_gp = 1;\n \t  valid_p = 1;\n \t  for (j = 0; j < 32; j++)\t/* A16 - A31, B16 - B31 */\n-\t    valid_p &= tdesc_numbered_register (feature, tdesc_data, i++,\n-\t\t\t\t\t\tgp[j]);\n+\t    valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t\ti++, gp[j]);\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t}\n \n       feature = tdesc_find_feature (tdesc, \"org.gnu.gdb.tic6x.c6xp\");\n       if (feature)\n \t{\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data, i++, \"TSR\");\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data, i++, \"ILC\");\n-\t  valid_p &= tdesc_numbered_register (feature, tdesc_data, i++, \"RILC\");\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t      i++, \"TSR\");\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t      i++, \"ILC\");\n+\t  valid_p &= tdesc_numbered_register (feature, tdesc_data.get (),\n+\t\t\t\t\t      i++, \"RILC\");\n \n \t  if (!valid_p)\n-\t    {\n-\t      tdesc_data_cleanup (tdesc_data);\n-\t      return NULL;\n-\t    }\n+\t    return NULL;\n \t}\n \n     }\n@@ -1295,8 +1289,8 @@ tic6x_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   /* Hook in ABI-specific overrides, if they have been registered.  */\n   gdbarch_init_osabi (info, gdbarch);\n \n-  if (tdesc_data)\n-    tdesc_use_registers (gdbarch, tdesc, tdesc_data);\n+  if (tdesc_data != nullptr)\n+    tdesc_use_registers (gdbarch, tdesc, std::move (tdesc_data));\n \n   return gdbarch;\n }"
    }
  ]
}