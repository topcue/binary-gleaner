{
  "sha": "8c37706a511209f6a92d887812c14e860c3bd0a0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGMzNzcwNmE1MTEyMDlmNmE5MmQ4ODc4MTJjMTRlODYwYzNiZDBhMA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-05-06T17:53:21Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-09-19T08:42:38Z"
    },
    "message": "gdb/fortran: Clean up array/string expression evaluation\n\nThis commit is a refactor of part of the Fortran array and string\nhandling code.\n\nThe current code is split into two blocks, linked, weirdly, with a\ngoto.  After this commit all the code is moved to its own function,\nand arrays and strings are now handled using the same code; this will\nbe useful later when I want to add array stride support where strings\nwill want to be treated just like arrays, but is a good clean up even\nwithout the array stride work, which is why I'm merging it now.\n\nFor now the new function is added as a static within eval.c, even\nthough the function is Fortran only.  A following commit will remove\nsome of the Fortran specific code from eval.c into one of the Fortran\nspecific files, including this new function.\n\nThere should be no user visible changes after this commit.\n\ngdb/ChangeLog:\n\n\t* eval.c (fortran_value_subarray): New function, content is taken\n\tfrom...\n\t(evaluate_subexp_standard): ...here, in two places.  Now arrays\n\tand strings both call the new function.\n\t(calc_f77_array_dims): Add header comment, handle strings.",
    "tree": {
      "sha": "62b9b1a9f84ef196e179e582f4a53493621dd612",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/62b9b1a9f84ef196e179e582f4a53493621dd612"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8c37706a511209f6a92d887812c14e860c3bd0a0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c37706a511209f6a92d887812c14e860c3bd0a0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8c37706a511209f6a92d887812c14e860c3bd0a0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c37706a511209f6a92d887812c14e860c3bd0a0/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "14f9473ca225290680c8b21240cdca49f8d3b332",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/14f9473ca225290680c8b21240cdca49f8d3b332",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/14f9473ca225290680c8b21240cdca49f8d3b332"
    }
  ],
  "stats": {
    "total": 144,
    "additions": 75,
    "deletions": 69
  },
  "files": [
    {
      "sha": "6330a054c7e09b115a538b8bf4737cf2b91ab917",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c37706a511209f6a92d887812c14e860c3bd0a0/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c37706a511209f6a92d887812c14e860c3bd0a0/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8c37706a511209f6a92d887812c14e860c3bd0a0",
      "patch": "@@ -1,3 +1,11 @@\n+2020-09-19  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* eval.c (fortran_value_subarray): New function, content is taken\n+\tfrom...\n+\t(evaluate_subexp_standard): ...here, in two places.  Now arrays\n+\tand strings both call the new function.\n+\t(calc_f77_array_dims): Add header comment, handle strings.\n+\n 2020-09-18  Victor Collod  <vcollod@nvidia.com>\n \n \tPR gdb/26635"
    },
    {
      "sha": "da4bbb288ffd79eb24a9ade6501f3d9cff51cf3b",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 67,
      "deletions": 69,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c37706a511209f6a92d887812c14e860c3bd0a0/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c37706a511209f6a92d887812c14e860c3bd0a0/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=8c37706a511209f6a92d887812c14e860c3bd0a0",
      "patch": "@@ -1260,6 +1260,67 @@ is_integral_or_integral_reference (struct type *type)\n \t  && is_integral_type (TYPE_TARGET_TYPE (type)));\n }\n \n+/* Called from evaluate_subexp_standard to perform array indexing, and\n+   sub-range extraction, for Fortran.  As well as arrays this function\n+   also handles strings as they can be treated like arrays of characters.\n+   ARRAY is the array or string being accessed.  EXP, POS, and NOSIDE are\n+   as for evaluate_subexp_standard, and NARGS is the number of arguments\n+   in this access (e.g. 'array (1,2,3)' would be NARGS 3).  */\n+\n+static struct value *\n+fortran_value_subarray (struct value *array, struct expression *exp,\n+\t\t\tint *pos, int nargs, enum noside noside)\n+{\n+  if (exp->elts[*pos].opcode == OP_RANGE)\n+    return value_f90_subarray (array, exp, pos, noside);\n+\n+  if (noside == EVAL_SKIP)\n+    {\n+      skip_undetermined_arglist (nargs, exp, pos, noside);\n+      /* Return the dummy value with the correct type.  */\n+      return array;\n+    }\n+\n+  LONGEST subscript_array[MAX_FORTRAN_DIMS];\n+  int ndimensions = 1;\n+  struct type *type = check_typedef (value_type (array));\n+\n+  if (nargs > MAX_FORTRAN_DIMS)\n+    error (_(\"Too many subscripts for F77 (%d Max)\"), MAX_FORTRAN_DIMS);\n+\n+  ndimensions = calc_f77_array_dims (type);\n+\n+  if (nargs != ndimensions)\n+    error (_(\"Wrong number of subscripts\"));\n+\n+  gdb_assert (nargs > 0);\n+\n+  /* Now that we know we have a legal array subscript expression let us\n+     actually find out where this element exists in the array.  */\n+\n+  /* Take array indices left to right.  */\n+  for (int i = 0; i < nargs; i++)\n+    {\n+      /* Evaluate each subscript; it must be a legal integer in F77.  */\n+      value *arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n+\n+      /* Fill in the subscript array.  */\n+      subscript_array[i] = value_as_long (arg2);\n+    }\n+\n+  /* Internal type of array is arranged right to left.  */\n+  for (int i = nargs; i > 0; i--)\n+    {\n+      struct type *array_type = check_typedef (value_type (array));\n+      LONGEST index = subscript_array[i - 1];\n+\n+      array = value_subscripted_rvalue (array, index,\n+\t\t\t\t\tf77_get_lowerbound (array_type));\n+    }\n+\n+  return array;\n+}\n+\n struct value *\n evaluate_subexp_standard (struct type *expect_type,\n \t\t\t  struct expression *exp, int *pos,\n@@ -1953,33 +2014,8 @@ evaluate_subexp_standard (struct type *expect_type,\n       switch (code)\n \t{\n \tcase TYPE_CODE_ARRAY:\n-\t  if (exp->elts[*pos].opcode == OP_RANGE)\n-\t    return value_f90_subarray (arg1, exp, pos, noside);\n-\t  else\n-\t    {\n-\t      if (noside == EVAL_SKIP)\n-\t\t{\n-\t\t  skip_undetermined_arglist (nargs, exp, pos, noside);\n-\t\t  /* Return the dummy value with the correct type.  */\n-\t\t  return arg1;\n-\t\t}\n-\t      goto multi_f77_subscript;\n-\t    }\n-\n \tcase TYPE_CODE_STRING:\n-\t  if (exp->elts[*pos].opcode == OP_RANGE)\n-\t    return value_f90_subarray (arg1, exp, pos, noside);\n-\t  else\n-\t    {\n-\t      if (noside == EVAL_SKIP)\n-\t\t{\n-\t\t  skip_undetermined_arglist (nargs, exp, pos, noside);\n-\t\t  /* Return the dummy value with the correct type.  */\n-\t\t  return arg1;\n-\t\t}\n-\t      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n-\t      return value_subscript (arg1, value_as_long (arg2));\n-\t    }\n+\t  return fortran_value_subarray (arg1, exp, pos, nargs, noside);\n \n \tcase TYPE_CODE_PTR:\n \tcase TYPE_CODE_FUNC:\n@@ -2400,49 +2436,6 @@ evaluate_subexp_standard (struct type *expect_type,\n \t}\n       return (arg1);\n \n-    multi_f77_subscript:\n-      {\n-\tLONGEST subscript_array[MAX_FORTRAN_DIMS];\n-\tint ndimensions = 1, i;\n-\tstruct value *array = arg1;\n-\n-\tif (nargs > MAX_FORTRAN_DIMS)\n-\t  error (_(\"Too many subscripts for F77 (%d Max)\"), MAX_FORTRAN_DIMS);\n-\n-\tndimensions = calc_f77_array_dims (type);\n-\n-\tif (nargs != ndimensions)\n-\t  error (_(\"Wrong number of subscripts\"));\n-\n-\tgdb_assert (nargs > 0);\n-\n-\t/* Now that we know we have a legal array subscript expression \n-\t   let us actually find out where this element exists in the array.  */\n-\n-\t/* Take array indices left to right.  */\n-\tfor (i = 0; i < nargs; i++)\n-\t  {\n-\t    /* Evaluate each subscript; it must be a legal integer in F77.  */\n-\t    arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n-\n-\t    /* Fill in the subscript array.  */\n-\n-\t    subscript_array[i] = value_as_long (arg2);\n-\t  }\n-\n-\t/* Internal type of array is arranged right to left.  */\n-\tfor (i = nargs; i > 0; i--)\n-\t  {\n-\t    struct type *array_type = check_typedef (value_type (array));\n-\t    LONGEST index = subscript_array[i - 1];\n-\n-\t    array = value_subscripted_rvalue (array, index,\n-\t\t\t\t\t      f77_get_lowerbound (array_type));\n-\t  }\n-\n-\treturn array;\n-      }\n-\n     case BINOP_LOGICAL_AND:\n       arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n@@ -3354,12 +3347,17 @@ parse_and_eval_type (char *p, int length)\n   return expr->elts[1].type;\n }\n \n+/* Return the number of dimensions for a Fortran array or string.  */\n+\n int\n calc_f77_array_dims (struct type *array_type)\n {\n   int ndimen = 1;\n   struct type *tmp_type;\n \n+  if ((array_type->code () == TYPE_CODE_STRING))\n+    return 1;\n+\n   if ((array_type->code () != TYPE_CODE_ARRAY))\n     error (_(\"Can't get dimensions for a non-array type\"));\n "
    }
  ]
}