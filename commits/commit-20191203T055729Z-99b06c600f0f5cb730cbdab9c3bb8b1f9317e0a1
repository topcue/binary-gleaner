{
  "sha": "99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTliMDZjNjAwZjBmNWNiNzMwY2JkYWI5YzNiYjhiMWY5MzE3ZTBhMQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-11-30T06:27:55Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-03T05:57:29Z"
    },
    "message": "PR25230, dwarf2.c per file stash\n\nThis is just moving things around, in preparation for parsing alt\nfile debug_info.\n\n\tPR 25230\n\t* dwarf2.c (struct dwarf2_debug_file): New struct.\n\t(struct dwarf2_debug): Delete fields now in dwarf2_debug_file.\n\tAdd f, alt fields.\n\t(struct comp_unit): Add file field.\n\t(read_indirect_string, read_indirect_line_string): Adjust to suit.\n\t(read_alt_indirect_string, read_alt_indirect_ref): Likewise.\n\t(read_debug_ranges, find_abstract_instance, read_rangelist): Likewise.\n\t(_bfd_dwarf2_stash_syms, place_sections): Likewise.\n\t(stash_maybe_update_info_hash_tablse): Likewise.\n\t(stash_verify_info_hash_table): Likewise.\n\t(_bfd_dwarf2_slurp_debug_info): Likewise.\n\t(_bfd_dwarf2_find_symbol_bias): Likewise.\n\t(_bfd_dwarf2_find_nearest_line): Likewise.\n\t(_bfd_dwarf2_cleanup_debug_info): Likewise.\n\t(read_abbrevs): Add file param and adjust.  Update calls.\n\t(stash_comp_unit): Likewise.\n\t(decode_line_info): Delete stash param and adjust.  Update calls.\n\t(comp_unit_find_nearest_line): Likewise.\n\t(comp_unit_maybe_decode_line_info): Likewise.\n\t(comp_unit_find_line): Likewise.\n\t(parse_comp_unit): Add file and info_ptr param and adjust.  Update\n\tcalls.",
    "tree": {
      "sha": "3d5e03311bf14492193b02ec6af986ce9189136f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3d5e03311bf14492193b02ec6af986ce9189136f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "019cc8758a68d016db920f96de3273a2824929d1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/019cc8758a68d016db920f96de3273a2824929d1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/019cc8758a68d016db920f96de3273a2824929d1"
    }
  ],
  "stats": {
    "total": 507,
    "additions": 261,
    "deletions": 246
  },
  "files": [
    {
      "sha": "02b744e91bc9b42e17cbf1568864897b83867d0a",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1",
      "patch": "@@ -1,3 +1,29 @@\n+2019-12-03  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 25230\n+\t* dwarf2.c (struct dwarf2_debug_file): New struct.\n+\t(struct dwarf2_debug): Delete fields now in dwarf2_debug_file.\n+\tAdd f, alt fields.\n+\t(struct comp_unit): Add file field.\n+\t(read_indirect_string, read_indirect_line_string): Adjust to suit.\n+\t(read_alt_indirect_string, read_alt_indirect_ref): Likewise.\n+\t(read_debug_ranges, find_abstract_instance, read_rangelist): Likewise.\n+\t(_bfd_dwarf2_stash_syms, place_sections): Likewise.\n+\t(stash_maybe_update_info_hash_tablse): Likewise.\n+\t(stash_verify_info_hash_table): Likewise.\n+\t(_bfd_dwarf2_slurp_debug_info): Likewise.\n+\t(_bfd_dwarf2_find_symbol_bias): Likewise.\n+\t(_bfd_dwarf2_find_nearest_line): Likewise.\n+\t(_bfd_dwarf2_cleanup_debug_info): Likewise.\n+\t(read_abbrevs): Add file param and adjust.  Update calls.\n+\t(stash_comp_unit): Likewise.\n+\t(decode_line_info): Delete stash param and adjust.  Update calls.\n+\t(comp_unit_find_nearest_line): Likewise.\n+\t(comp_unit_maybe_decode_line_info): Likewise.\n+\t(comp_unit_find_line): Likewise.\n+\t(parse_comp_unit): Add file and info_ptr param and adjust.  Update\n+\tcalls.\n+\n 2019-12-03  Alan Modra  <amodra@gmail.com>\n \n \t* dwarf2.c (read_indirect_string): Don't duplicate offset check"
    },
    {
      "sha": "61c459ea9f853e2515e01bfe55d9389020c087ba",
      "filename": "bfd/dwarf2.c",
      "status": "modified",
      "additions": 235,
      "deletions": 246,
      "changes": 481,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1/bfd/dwarf2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1/bfd/dwarf2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf2.c?ref=99b06c600f0f5cb730cbdab9c3bb8b1f9317e0a1",
      "patch": "@@ -82,50 +82,23 @@ struct adjusted_section\n   bfd_vma adj_vma;\n };\n \n-struct dwarf2_debug\n+struct dwarf2_debug_file\n {\n-  /* A list of all previously read comp_units.  */\n-  struct comp_unit *all_comp_units;\n-\n-  /* Last comp unit in list above.  */\n-  struct comp_unit *last_comp_unit;\n+  /* The actual bfd from which debug info was loaded.  Might be\n+     different to orig_bfd because of gnu_debuglink sections.  */\n+  bfd *bfd_ptr;\n \n-  /* Names of the debug sections.  */\n-  const struct dwarf_debug_section *debug_sections;\n+  /* Pointer to the symbol table.  */\n+  asymbol **syms;\n \n-  /* The next unread compilation unit within the .debug_info section.\n-     Zero indicates that the .debug_info section has not been loaded\n-     into a buffer yet.  */\n+  /* The current info pointer for the .debug_info section being parsed.  */\n   bfd_byte *info_ptr;\n \n-  /* Pointer to the end of the .debug_info section memory buffer.  */\n-  bfd_byte *info_ptr_end;\n-\n-  /* Pointer to the original bfd for which debug was loaded.  This is what\n-     we use to compare and so check that the cached debug data is still\n-     valid - it saves having to possibly dereference the gnu_debuglink each\n-     time.  */\n-  bfd *orig_bfd;\n-\n-  /* Pointer to the bfd.  The bfd might be different than expected\n-     because of gnu_debuglink sections.  */\n-  bfd *bfd_ptr;\n-\n-  /* Support for alternate debug info sections created by the DWZ utility:\n-     This includes a pointer to an alternate bfd which contains *extra*,\n-     possibly duplicate debug sections, and pointers to the loaded\n-     .debug_str and .debug_info sections from this bfd.  */\n-  bfd *\t\t alt_bfd_ptr;\n-  bfd_byte *\t alt_dwarf_str_buffer;\n-  bfd_size_type\t alt_dwarf_str_size;\n-  bfd_byte *\t alt_dwarf_info_buffer;\n-  bfd_size_type\t alt_dwarf_info_size;\n-\n   /* A pointer to the memory block allocated for .debug_info sections.  */\n-  bfd_byte *info_ptr_memory;\n+  bfd_byte *dwarf_info_buffer;\n \n-  /* Pointer to the symbol table.  */\n-  asymbol **syms;\n+  /* Length of the loaded .debug_info sections.  */\n+  bfd_size_type dwarf_info_size;\n \n   /* Pointer to the .debug_abbrev section loaded into memory.  */\n   bfd_byte *dwarf_abbrev_buffer;\n@@ -157,6 +130,27 @@ struct dwarf2_debug\n   /* Length of the loaded .debug_ranges section.  */\n   bfd_size_type dwarf_ranges_size;\n \n+  /* A list of all previously read comp_units.  */\n+  struct comp_unit *all_comp_units;\n+\n+  /* Last comp unit in list above.  */\n+  struct comp_unit *last_comp_unit;\n+};\n+\n+struct dwarf2_debug\n+{\n+  /* Names of the debug sections.  */\n+  const struct dwarf_debug_section *debug_sections;\n+\n+  /* Per-file stuff.  */\n+  struct dwarf2_debug_file f, alt;\n+\n+  /* Pointer to the original bfd for which debug was loaded.  This is what\n+     we use to compare and so check that the cached debug data is still\n+     valid - it saves having to possibly dereference the gnu_debuglink each\n+     time.  */\n+  bfd *orig_bfd;\n+\n   /* If the most recent call to bfd_find_nearest_line was given an\n      address in an inlined function, preserve a pointer into the\n      calling chain for subsequent calls to bfd_find_inliner_info to\n@@ -271,8 +265,9 @@ struct comp_unit\n   /* A list of the variables found in this comp. unit.  */\n   struct varinfo *variable_table;\n \n-  /* Pointer to dwarf2_debug structure.  */\n+  /* Pointers to dwarf2_debug structures.  */\n   struct dwarf2_debug *stash;\n+  struct dwarf2_debug_file *file;\n \n   /* DWARF format version for this unit - from unit header.  */\n   int version;\n@@ -701,6 +696,7 @@ read_indirect_string (struct comp_unit * unit,\n {\n   bfd_uint64_t offset;\n   struct dwarf2_debug *stash = unit->stash;\n+  struct dwarf2_debug_file *file = unit->file;\n   char *str;\n \n   if (buf + unit->offset_size > buf_end)\n@@ -717,11 +713,11 @@ read_indirect_string (struct comp_unit * unit,\n   *bytes_read_ptr = unit->offset_size;\n \n   if (! read_section (unit->abfd, &stash->debug_sections[debug_str],\n-\t\t      stash->syms, offset,\n-\t\t      &stash->dwarf_str_buffer, &stash->dwarf_str_size))\n+\t\t      file->syms, offset,\n+\t\t      &file->dwarf_str_buffer, &file->dwarf_str_size))\n     return NULL;\n \n-  str = (char *) stash->dwarf_str_buffer + offset;\n+  str = (char *) file->dwarf_str_buffer + offset;\n   if (*str == '\\0')\n     return NULL;\n   return str;\n@@ -737,6 +733,7 @@ read_indirect_line_string (struct comp_unit * unit,\n {\n   bfd_uint64_t offset;\n   struct dwarf2_debug *stash = unit->stash;\n+  struct dwarf2_debug_file *file = unit->file;\n   char *str;\n \n   if (buf + unit->offset_size > buf_end)\n@@ -753,12 +750,12 @@ read_indirect_line_string (struct comp_unit * unit,\n   *bytes_read_ptr = unit->offset_size;\n \n   if (! read_section (unit->abfd, &stash->debug_sections[debug_line_str],\n-\t\t      stash->syms, offset,\n-\t\t      &stash->dwarf_line_str_buffer,\n-\t\t      &stash->dwarf_line_str_size))\n+\t\t      file->syms, offset,\n+\t\t      &file->dwarf_line_str_buffer,\n+\t\t      &file->dwarf_line_str_size))\n     return NULL;\n \n-  str = (char *) stash->dwarf_line_str_buffer + offset;\n+  str = (char *) file->dwarf_line_str_buffer + offset;\n   if (*str == '\\0')\n     return NULL;\n   return str;\n@@ -791,7 +788,7 @@ read_alt_indirect_string (struct comp_unit * unit,\n \n   *bytes_read_ptr = unit->offset_size;\n \n-  if (stash->alt_bfd_ptr == NULL)\n+  if (stash->alt.bfd_ptr == NULL)\n     {\n       bfd *debug_bfd;\n       char *debug_filename = bfd_follow_gnu_debugaltlink (unit->abfd, DEBUGDIR);\n@@ -810,18 +807,17 @@ read_alt_indirect_string (struct comp_unit * unit,\n \t  bfd_close (debug_bfd);\n \t  return NULL;\n \t}\n-      stash->alt_bfd_ptr = debug_bfd;\n+      stash->alt.bfd_ptr = debug_bfd;\n     }\n \n-  if (! read_section (unit->stash->alt_bfd_ptr,\n+  if (! read_section (unit->stash->alt.bfd_ptr,\n \t\t      stash->debug_sections + debug_str_alt,\n-\t\t      NULL, /* FIXME: Do we need to load alternate symbols ?  */\n-\t\t      offset,\n-\t\t      &stash->alt_dwarf_str_buffer,\n-\t\t      &stash->alt_dwarf_str_size))\n+\t\t      stash->alt.syms, offset,\n+\t\t      &stash->alt.dwarf_str_buffer,\n+\t\t      &stash->alt.dwarf_str_size))\n     return NULL;\n \n-  str = (char *) stash->alt_dwarf_str_buffer + offset;\n+  str = (char *) stash->alt.dwarf_str_buffer + offset;\n   if (*str == '\\0')\n     return NULL;\n \n@@ -838,7 +834,7 @@ read_alt_indirect_ref (struct comp_unit * unit,\n {\n   struct dwarf2_debug *stash = unit->stash;\n \n-  if (stash->alt_bfd_ptr == NULL)\n+  if (stash->alt.bfd_ptr == NULL)\n     {\n       bfd *debug_bfd;\n       char *debug_filename = bfd_follow_gnu_debugaltlink (unit->abfd, DEBUGDIR);\n@@ -857,18 +853,17 @@ read_alt_indirect_ref (struct comp_unit * unit,\n \t  bfd_close (debug_bfd);\n \t  return NULL;\n \t}\n-      stash->alt_bfd_ptr = debug_bfd;\n+      stash->alt.bfd_ptr = debug_bfd;\n     }\n \n-  if (! read_section (unit->stash->alt_bfd_ptr,\n+  if (! read_section (unit->stash->alt.bfd_ptr,\n \t\t      stash->debug_sections + debug_info_alt,\n-\t\t      NULL, /* FIXME: Do we need to load alternate symbols ?  */\n-\t\t      offset,\n-\t\t      &stash->alt_dwarf_info_buffer,\n-\t\t      &stash->alt_dwarf_info_size))\n+\t\t      stash->alt.syms, offset,\n+\t\t      &stash->alt.dwarf_info_buffer,\n+\t\t      &stash->alt.dwarf_info_size))\n     return NULL;\n \n-  return stash->alt_dwarf_info_buffer + offset;\n+  return stash->alt.dwarf_info_buffer + offset;\n }\n \n static bfd_uint64_t\n@@ -940,7 +935,8 @@ lookup_abbrev (unsigned int number, struct abbrev_info **abbrevs)\n    in a hash table.  */\n \n static struct abbrev_info**\n-read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)\n+read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash,\n+\t      struct dwarf2_debug_file *file)\n {\n   struct abbrev_info **abbrevs;\n   bfd_byte *abbrev_ptr;\n@@ -951,17 +947,18 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)\n   bfd_size_type amt;\n \n   if (! read_section (abfd, &stash->debug_sections[debug_abbrev],\n-\t\t      stash->syms, offset,\n-\t\t      &stash->dwarf_abbrev_buffer, &stash->dwarf_abbrev_size))\n+\t\t      file->syms, offset,\n+\t\t      &file->dwarf_abbrev_buffer,\n+\t\t      &file->dwarf_abbrev_size))\n     return NULL;\n \n   amt = sizeof (struct abbrev_info*) * ABBREV_HASH_SIZE;\n   abbrevs = (struct abbrev_info **) bfd_zalloc (abfd, amt);\n   if (abbrevs == NULL)\n     return NULL;\n \n-  abbrev_ptr = stash->dwarf_abbrev_buffer + offset;\n-  abbrev_end = stash->dwarf_abbrev_buffer + stash->dwarf_abbrev_size;\n+  abbrev_ptr = file->dwarf_abbrev_buffer + offset;\n+  abbrev_end = file->dwarf_abbrev_buffer + file->dwarf_abbrev_size;\n   abbrev_number = _bfd_safe_read_leb128 (abfd, abbrev_ptr, &bytes_read,\n \t\t\t\t\t FALSE, abbrev_end);\n   abbrev_ptr += bytes_read;\n@@ -1038,8 +1035,8 @@ read_abbrevs (bfd *abfd, bfd_uint64_t offset, struct dwarf2_debug *stash)\n \t already read (which means we are about to read the abbreviations\n \t for the next compile unit) or if the end of the abbreviation\n \t table is reached.  */\n-      if ((size_t) (abbrev_ptr - stash->dwarf_abbrev_buffer)\n-\t  >= stash->dwarf_abbrev_size)\n+      if ((size_t) (abbrev_ptr - file->dwarf_abbrev_buffer)\n+\t  >= file->dwarf_abbrev_size)\n \tbreak;\n       abbrev_number = _bfd_safe_read_leb128 (abfd, abbrev_ptr,\n \t\t\t\t\t     &bytes_read, FALSE, abbrev_end);\n@@ -2013,9 +2010,11 @@ read_formatted_entries (struct comp_unit *unit, bfd_byte **bufp,\n /* Decode the line number information for UNIT.  */\n \n static struct line_info_table*\n-decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)\n+decode_line_info (struct comp_unit *unit)\n {\n   bfd *abfd = unit->abfd;\n+  struct dwarf2_debug *stash = unit->stash;\n+  struct dwarf2_debug_file *file = unit->file;\n   struct line_info_table* table;\n   bfd_byte *line_ptr;\n   bfd_byte *line_end;\n@@ -2027,8 +2026,8 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)\n   bfd_size_type amt;\n \n   if (! read_section (abfd, &stash->debug_sections[debug_line],\n-\t\t      stash->syms, unit->line_offset,\n-\t\t      &stash->dwarf_line_buffer, &stash->dwarf_line_size))\n+\t\t      file->syms, unit->line_offset,\n+\t\t      &file->dwarf_line_buffer, &file->dwarf_line_size))\n     return NULL;\n \n   amt = sizeof (struct line_info_table);\n@@ -2049,16 +2048,16 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)\n \n   table->lcl_head = NULL;\n \n-  if (stash->dwarf_line_size < 16)\n+  if (file->dwarf_line_size < 16)\n     {\n       _bfd_error_handler\n \t(_(\"DWARF error: line info section is too small (%\" PRId64 \")\"),\n-\t (int64_t) stash->dwarf_line_size);\n+\t (int64_t) file->dwarf_line_size);\n       bfd_set_error (bfd_error_bad_value);\n       return NULL;\n     }\n-  line_ptr = stash->dwarf_line_buffer + unit->line_offset;\n-  line_end = stash->dwarf_line_buffer + stash->dwarf_line_size;\n+  line_ptr = file->dwarf_line_buffer + unit->line_offset;\n+  line_end = file->dwarf_line_buffer + file->dwarf_line_size;\n \n   /* Read in the prologue.  */\n   lh.total_length = read_4_bytes (abfd, line_ptr, line_end);\n@@ -2384,16 +2383,16 @@ decode_line_info (struct comp_unit *unit, struct dwarf2_debug *stash)\n \t      break;\n \t    case DW_LNS_set_file:\n \t      {\n-\t\tunsigned int file;\n+\t\tunsigned int filenum;\n \n \t\t/* The file and directory tables are 0\n \t\t   based, the references are 1 based.  */\n-\t\tfile = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n-\t\t\t\t\t      FALSE, line_end);\n+\t\tfilenum = _bfd_safe_read_leb128 (abfd, line_ptr, &bytes_read,\n+\t\t\t\t\t\t FALSE, line_end);\n \t\tline_ptr += bytes_read;\n \t\tif (filename)\n \t\t  free (filename);\n-\t\tfilename = concat_filename (table, file);\n+\t\tfilename = concat_filename (table, filenum);\n \t\tbreak;\n \t      }\n \t    case DW_LNS_set_column:\n@@ -2537,12 +2536,12 @@ lookup_address_in_line_info_table (struct line_info_table *table,\n static bfd_boolean\n read_debug_ranges (struct comp_unit * unit)\n {\n-  struct dwarf2_debug * stash = unit->stash;\n+  struct dwarf2_debug *stash = unit->stash;\n+  struct dwarf2_debug_file *file = unit->file;\n \n   return read_section (unit->abfd, &stash->debug_sections[debug_ranges],\n-\t\t       stash->syms, 0,\n-\t\t       &stash->dwarf_ranges_buffer,\n-\t\t       &stash->dwarf_ranges_size);\n+\t\t       file->syms, 0,\n+\t\t       &file->dwarf_ranges_buffer, &file->dwarf_ranges_size);\n }\n \n /* Function table functions.  */\n@@ -2805,9 +2804,9 @@ lookup_symbol_in_variable_table (struct comp_unit *unit,\n   return FALSE;\n }\n \n-static struct comp_unit *stash_comp_unit (struct dwarf2_debug *);\n-static bfd_boolean comp_unit_maybe_decode_line_info (struct comp_unit *,\n-\t\t\t\t\t\t     struct dwarf2_debug *);\n+static struct comp_unit *stash_comp_unit (struct dwarf2_debug *,\n+\t\t\t\t\t  struct dwarf2_debug_file *);\n+static bfd_boolean comp_unit_maybe_decode_line_info (struct comp_unit *);\n \n static bfd_boolean\n find_abstract_instance (struct comp_unit *unit,\n@@ -2852,12 +2851,12 @@ find_abstract_instance (struct comp_unit *unit,\n \t a symbolic reference to a label in any .debug_info section\n \t might be used.  Since we lay out multiple .debug_info\n \t sections at non-zero VMAs (see place_sections), and read\n-\t them contiguously into stash->info_ptr_memory, that means\n-\t the reference is relative to stash->info_ptr_memory.  */\n+\t them contiguously into dwarf_info_buffer, that means the\n+\t reference is relative to dwarf_info_buffer.  */\n       size_t total;\n \n-      info_ptr = unit->stash->info_ptr_memory;\n-      info_ptr_end = unit->stash->info_ptr_end;\n+      info_ptr = unit->file->dwarf_info_buffer;\n+      info_ptr_end = info_ptr + unit->file->dwarf_info_size;\n       total = info_ptr_end - info_ptr;\n       if (!die_ref)\n \treturn TRUE;\n@@ -2889,7 +2888,7 @@ find_abstract_instance (struct comp_unit *unit,\n \n \t  while (u == NULL)\n \t    {\n-\t      u = stash_comp_unit (unit->stash);\n+\t      u = stash_comp_unit (unit->stash, unit->file);\n \t      if (u == NULL)\n \t\tbreak;\n \t      if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n@@ -2920,8 +2919,8 @@ find_abstract_instance (struct comp_unit *unit,\n \t  bfd_set_error (bfd_error_bad_value);\n \t  return FALSE;\n \t}\n-      info_ptr_end = (unit->stash->alt_dwarf_info_buffer\n-\t\t      + unit->stash->alt_dwarf_info_size);\n+      info_ptr_end = (unit->stash->alt.dwarf_info_buffer\n+\t\t      + unit->stash->alt.dwarf_info_size);\n \n       /* FIXME: Do we need to locate the correct CU, in a similar\n \t fashion to the code in the DW_FORM_ref_addr case above ?  */\n@@ -2997,7 +2996,7 @@ find_abstract_instance (struct comp_unit *unit,\n \t\t    }\n \t\t  break;\n \t\tcase DW_AT_decl_file:\n-\t\t  if (!comp_unit_maybe_decode_line_info (unit, unit->stash))\n+\t\t  if (!comp_unit_maybe_decode_line_info (unit))\n \t\t    return FALSE;\n \t\t  *filename_ptr = concat_filename (unit->line_table,\n \t\t\t\t\t\t   attr.u.val);\n@@ -3023,16 +3022,16 @@ read_rangelist (struct comp_unit *unit, struct arange *arange,\n   bfd_byte *ranges_end;\n   bfd_vma base_address = unit->base_address;\n \n-  if (! unit->stash->dwarf_ranges_buffer)\n+  if (! unit->file->dwarf_ranges_buffer)\n     {\n       if (! read_debug_ranges (unit))\n \treturn FALSE;\n     }\n \n-  ranges_ptr = unit->stash->dwarf_ranges_buffer + offset;\n-  if (ranges_ptr < unit->stash->dwarf_ranges_buffer)\n+  ranges_ptr = unit->file->dwarf_ranges_buffer + offset;\n+  if (ranges_ptr < unit->file->dwarf_ranges_buffer)\n     return FALSE;\n-  ranges_end = unit->stash->dwarf_ranges_buffer + unit->stash->dwarf_ranges_size;\n+  ranges_end = unit->file->dwarf_ranges_buffer + unit->file->dwarf_ranges_size;\n \n   for (;;)\n     {\n@@ -3362,6 +3361,8 @@ scan_unit_for_symbols (struct comp_unit *unit)\n \n static struct comp_unit *\n parse_comp_unit (struct dwarf2_debug *stash,\n+\t\t struct dwarf2_debug_file *file,\n+\t\t bfd_byte *info_ptr,\n \t\t bfd_vma unit_length,\n \t\t bfd_byte *info_ptr_unit,\n \t\t unsigned int offset_size)\n@@ -3375,12 +3376,11 @@ parse_comp_unit (struct dwarf2_debug *stash,\n   unsigned int abbrev_number, bytes_read, i;\n   struct abbrev_info *abbrev;\n   struct attribute attr;\n-  bfd_byte *info_ptr = stash->info_ptr;\n   bfd_byte *end_ptr = info_ptr + unit_length;\n   bfd_size_type amt;\n   bfd_vma low_pc = 0;\n   bfd_vma high_pc = 0;\n-  bfd *abfd = stash->bfd_ptr;\n+  bfd *abfd = file->bfd_ptr;\n   bfd_boolean high_pc_relative = FALSE;\n   enum dwarf_unit_type unit_type;\n \n@@ -3457,7 +3457,7 @@ parse_comp_unit (struct dwarf2_debug *stash,\n     }\n \n   /* Read the abbrevs for this compilation unit into a table.  */\n-  abbrevs = read_abbrevs (abfd, abbrev_offset, stash);\n+  abbrevs = read_abbrevs (abfd, abbrev_offset, stash, file);\n   if (! abbrevs)\n     return NULL;\n \n@@ -3493,6 +3493,7 @@ parse_comp_unit (struct dwarf2_debug *stash,\n   unit->abbrevs = abbrevs;\n   unit->end_ptr = end_ptr;\n   unit->stash = stash;\n+  unit->file = file;\n   unit->info_ptr_unit = info_ptr_unit;\n \n   for (i = 0; i < abbrev->num_attrs; ++i)\n@@ -3619,18 +3620,17 @@ comp_unit_find_nearest_line (struct comp_unit *unit,\n \t\t\t     const char **filename_ptr,\n \t\t\t     struct funcinfo **function_ptr,\n \t\t\t     unsigned int *linenumber_ptr,\n-\t\t\t     unsigned int *discriminator_ptr,\n-\t\t\t     struct dwarf2_debug *stash)\n+\t\t\t     unsigned int *discriminator_ptr)\n {\n   bfd_boolean func_p;\n \n-  if (!comp_unit_maybe_decode_line_info (unit, stash))\n+  if (!comp_unit_maybe_decode_line_info (unit))\n     return FALSE;\n \n   *function_ptr = NULL;\n   func_p = lookup_address_in_function_table (unit, addr, function_ptr);\n   if (func_p && (*function_ptr)->tag == DW_TAG_inlined_subroutine)\n-    stash->inliner_chain = *function_ptr;\n+    unit->stash->inliner_chain = *function_ptr;\n \n   return lookup_address_in_line_info_table (unit->line_table, addr,\n \t\t\t\t\t    filename_ptr,\n@@ -3643,8 +3643,7 @@ comp_unit_find_nearest_line (struct comp_unit *unit,\n    FALSE otherwise.  */\n \n static bfd_boolean\n-comp_unit_maybe_decode_line_info (struct comp_unit *unit,\n-\t\t\t\t  struct dwarf2_debug *stash)\n+comp_unit_maybe_decode_line_info (struct comp_unit *unit)\n {\n   if (unit->error)\n     return FALSE;\n@@ -3657,7 +3656,7 @@ comp_unit_maybe_decode_line_info (struct comp_unit *unit,\n \t  return FALSE;\n \t}\n \n-      unit->line_table = decode_line_info (unit, stash);\n+      unit->line_table = decode_line_info (unit);\n \n       if (! unit->line_table)\n \t{\n@@ -3689,10 +3688,9 @@ comp_unit_find_line (struct comp_unit *unit,\n \t\t     asymbol *sym,\n \t\t     bfd_vma addr,\n \t\t     const char **filename_ptr,\n-\t\t     unsigned int *linenumber_ptr,\n-\t\t     struct dwarf2_debug *stash)\n+\t\t     unsigned int *linenumber_ptr)\n {\n-  if (!comp_unit_maybe_decode_line_info (unit, stash))\n+  if (!comp_unit_maybe_decode_line_info (unit))\n     return FALSE;\n \n   if (sym->flags & BSF_FUNCTION)\n@@ -3751,7 +3749,7 @@ comp_unit_hash_info (struct dwarf2_debug *stash,\n \n   BFD_ASSERT (stash->info_hash_status != STASH_INFO_HASH_DISABLED);\n \n-  if (!comp_unit_maybe_decode_line_info (unit, stash))\n+  if (!comp_unit_maybe_decode_line_info (unit))\n     return FALSE;\n \n   BFD_ASSERT (!unit->cached);\n@@ -3890,17 +3888,17 @@ static void\n _bfd_dwarf2_stash_syms (struct dwarf2_debug *stash, bfd *abfd,\n \t\t\tasection **sec, asymbol ***syms)\n {\n-  if (stash->bfd_ptr != abfd)\n+  if (stash->f.bfd_ptr != abfd)\n     {\n       asection *s, *d;\n \n       if (*sec == NULL)\n \t{\n-\t  *syms = stash->syms;\n+\t  *syms = stash->f.syms;\n \t  return;\n \t}\n \n-      for (s = abfd->sections, d = stash->bfd_ptr->sections;\n+      for (s = abfd->sections, d = stash->f.bfd_ptr->sections;\n \t   s != NULL && d != NULL;\n \t   s = s->next, d = d->next)\n \t{\n@@ -3910,7 +3908,7 @@ _bfd_dwarf2_stash_syms (struct dwarf2_debug *stash, bfd *abfd,\n \t      && strcmp (s->name, d->name) == 0)\n \t    {\n \t      *sec = d;\n-\t      *syms = stash->syms;\n+\t      *syms = stash->f.syms;\n \t      break;\n \t    }\n \t}\n@@ -3984,9 +3982,9 @@ place_sections (bfd *orig_bfd, struct dwarf2_debug *stash)\n \n \t  i++;\n \t}\n-      if (abfd == stash->bfd_ptr)\n+      if (abfd == stash->f.bfd_ptr)\n \tbreak;\n-      abfd = stash->bfd_ptr;\n+      abfd = stash->f.bfd_ptr;\n     }\n \n   if (i <= 1)\n@@ -4049,14 +4047,14 @@ place_sections (bfd *orig_bfd, struct dwarf2_debug *stash)\n \t      p->adj_vma = sect->vma;\n \t      p++;\n \t    }\n-\t  if (abfd == stash->bfd_ptr)\n+\t  if (abfd == stash->f.bfd_ptr)\n \t    break;\n-\t  abfd = stash->bfd_ptr;\n+\t  abfd = stash->f.bfd_ptr;\n \t}\n     }\n \n-  if (orig_bfd != stash->bfd_ptr)\n-    set_debug_vma (orig_bfd, stash->bfd_ptr);\n+  if (orig_bfd != stash->f.bfd_ptr)\n+    set_debug_vma (orig_bfd, stash->f.bfd_ptr);\n \n   return TRUE;\n }\n@@ -4160,13 +4158,13 @@ stash_maybe_update_info_hash_tables (struct dwarf2_debug *stash)\n   struct comp_unit *each;\n \n   /* Exit if hash tables are up-to-date.  */\n-  if (stash->all_comp_units == stash->hash_units_head)\n+  if (stash->f.all_comp_units == stash->hash_units_head)\n     return TRUE;\n \n   if (stash->hash_units_head)\n     each = stash->hash_units_head->prev_unit;\n   else\n-    each = stash->last_comp_unit;\n+    each = stash->f.last_comp_unit;\n \n   while (each)\n     {\n@@ -4179,7 +4177,7 @@ stash_maybe_update_info_hash_tables (struct dwarf2_debug *stash)\n       each = each->prev_unit;\n     }\n \n-  stash->hash_units_head = stash->all_comp_units;\n+  stash->hash_units_head = stash->f.all_comp_units;\n   return TRUE;\n }\n \n@@ -4194,7 +4192,7 @@ stash_verify_info_hash_table (struct dwarf2_debug *stash)\n   struct info_list_node *node;\n   bfd_boolean found;\n \n-  for (each_unit = stash->all_comp_units;\n+  for (each_unit = stash->f.all_comp_units;\n        each_unit;\n        each_unit = each_unit->next_unit)\n     {\n@@ -4374,7 +4372,7 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n \t{\n \t  /* Check that we did previously find some debug information\n \t     before attempting to make use of it.  */\n-\t  if (stash->bfd_ptr != NULL)\n+\t  if (stash->f.bfd_ptr != NULL)\n \t    {\n \t      if (do_place && !place_sections (abfd, stash))\n \t\treturn FALSE;\n@@ -4394,7 +4392,7 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n     }\n   stash->orig_bfd = abfd;\n   stash->debug_sections = debug_sections;\n-  stash->syms = symbols;\n+  stash->f.syms = symbols;\n   if (!save_section_vma (abfd, stash))\n     return FALSE;\n \n@@ -4437,10 +4435,10 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n \t}\n \n       symbols = bfd_get_outsymbols (debug_bfd);\n-      stash->syms = symbols;\n+      stash->f.syms = symbols;\n       stash->close_on_cleanup = TRUE;\n     }\n-  stash->bfd_ptr = debug_bfd;\n+  stash->f.bfd_ptr = debug_bfd;\n \n   if (do_place\n       && !place_sections (abfd, stash))\n@@ -4463,7 +4461,7 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n       total_size = msec->size;\n       if (! read_section (debug_bfd, &stash->debug_sections[debug_info],\n \t\t\t  symbols, 0,\n-\t\t\t  &stash->info_ptr_memory, &total_size))\n+\t\t\t  &stash->f.dwarf_info_buffer, &total_size))\n \treturn FALSE;\n     }\n   else\n@@ -4483,8 +4481,8 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n \t  total_size += msec->size;\n \t}\n \n-      stash->info_ptr_memory = (bfd_byte *) bfd_malloc (total_size);\n-      if (stash->info_ptr_memory == NULL)\n+      stash->f.dwarf_info_buffer = (bfd_byte *) bfd_malloc (total_size);\n+      if (stash->f.dwarf_info_buffer == NULL)\n \treturn FALSE;\n \n       total_size = 0;\n@@ -4499,51 +4497,51 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n \t    continue;\n \n \t  if (!(bfd_simple_get_relocated_section_contents\n-\t\t(debug_bfd, msec, stash->info_ptr_memory + total_size,\n+\t\t(debug_bfd, msec, stash->f.dwarf_info_buffer + total_size,\n \t\t symbols)))\n \t    return FALSE;\n \n \t  total_size += size;\n \t}\n     }\n \n-  stash->info_ptr = stash->info_ptr_memory;\n-  stash->info_ptr_end = stash->info_ptr + total_size;\n+  stash->f.info_ptr = stash->f.dwarf_info_buffer;\n+  stash->f.dwarf_info_size = total_size;\n   return TRUE;\n }\n \n-/* Parse the next DWARF2 compilation unit at STASH->INFO_PTR.  */\n+/* Parse the next DWARF2 compilation unit at FILE->INFO_PTR.  */\n \n static struct comp_unit *\n-stash_comp_unit (struct dwarf2_debug *stash)\n+stash_comp_unit (struct dwarf2_debug *stash, struct dwarf2_debug_file *file)\n {\n   bfd_size_type length;\n   unsigned int offset_size;\n-  bfd_byte *info_ptr_unit = stash->info_ptr;\n+  bfd_byte *info_ptr_unit = file->info_ptr;\n+  bfd_byte *info_ptr_end = file->dwarf_info_buffer + file->dwarf_info_size;\n \n-  if (stash->info_ptr >= stash->info_ptr_end)\n+  if (file->info_ptr >= info_ptr_end)\n     return NULL;\n \n-  length = read_4_bytes (stash->bfd_ptr, stash->info_ptr,\n-\t\t\t stash->info_ptr_end);\n+  length = read_4_bytes (file->bfd_ptr, file->info_ptr, info_ptr_end);\n   /* A 0xffffff length is the DWARF3 way of indicating\n      we use 64-bit offsets, instead of 32-bit offsets.  */\n   if (length == 0xffffffff)\n     {\n       offset_size = 8;\n-      length = read_8_bytes (stash->bfd_ptr, stash->info_ptr + 4,\n-\t\t\t     stash->info_ptr_end);\n-      stash->info_ptr += 12;\n+      length = read_8_bytes (file->bfd_ptr, file->info_ptr + 4,\n+\t\t\t     info_ptr_end);\n+      file->info_ptr += 12;\n     }\n   /* A zero length is the IRIX way of indicating 64-bit offsets,\n      mostly because the 64-bit length will generally fit in 32\n      bits, and the endianness helps.  */\n   else if (length == 0)\n     {\n       offset_size = 8;\n-      length = read_4_bytes (stash->bfd_ptr, stash->info_ptr + 4,\n-\t\t\t     stash->info_ptr_end);\n-      stash->info_ptr += 8;\n+      length = read_4_bytes (file->bfd_ptr, file->info_ptr + 4,\n+\t\t\t     info_ptr_end);\n+      file->info_ptr += 8;\n     }\n   /* In the absence of the hints above, we assume 32-bit DWARF2\n      offsets even for targets with 64-bit addresses, because:\n@@ -4557,33 +4555,34 @@ stash_comp_unit (struct dwarf2_debug *stash)\n   else\n     {\n       offset_size = 4;\n-      stash->info_ptr += 4;\n+      file->info_ptr += 4;\n     }\n \n   if (length != 0\n-      && stash->info_ptr + length <= stash->info_ptr_end\n-      && stash->info_ptr + length > stash->info_ptr)\n+      && file->info_ptr + length <= info_ptr_end\n+      && file->info_ptr + length > file->info_ptr)\n     {\n-      struct comp_unit *each = parse_comp_unit (stash, length, info_ptr_unit,\n-\t\t\t\t\t\toffset_size);\n+      struct comp_unit *each = parse_comp_unit (stash, file,\n+\t\t\t\t\t\tfile->info_ptr, length,\n+\t\t\t\t\t\tinfo_ptr_unit, offset_size);\n       if (each)\n \t{\n-\t  if (stash->all_comp_units)\n-\t    stash->all_comp_units->prev_unit = each;\n+\t  if (file->all_comp_units)\n+\t    file->all_comp_units->prev_unit = each;\n \t  else\n-\t    stash->last_comp_unit = each;\n+\t    file->last_comp_unit = each;\n \n-\t  each->next_unit = stash->all_comp_units;\n-\t  stash->all_comp_units = each;\n+\t  each->next_unit = file->all_comp_units;\n+\t  file->all_comp_units = each;\n \n-\t  stash->info_ptr += length;\n+\t  file->info_ptr += length;\n \t  return each;\n \t}\n     }\n \n   /* Don't trust any of the DWARF info after a corrupted length or\n      parse error.  */\n-  stash->info_ptr = stash->info_ptr_end;\n+  file->info_ptr = info_ptr_end;\n   return NULL;\n }\n \n@@ -4638,11 +4637,11 @@ _bfd_dwarf2_find_symbol_bias (asymbol ** symbols, void ** pinfo)\n \t}\n     }\n \n-  for (unit = stash->all_comp_units; unit; unit = unit->next_unit)\n+  for (unit = stash->f.all_comp_units; unit; unit = unit->next_unit)\n     {\n       struct funcinfo * func;\n \n-      comp_unit_maybe_decode_line_info (unit, stash);\n+      comp_unit_maybe_decode_line_info (unit);\n \n       for (func = unit->function_table; func != NULL; func = func->prev_func)\n \tif (func->name && func->arange.low)\n@@ -4775,7 +4774,7 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,\n \n   /* A null info_ptr indicates that there is no dwarf2 info\n      (or that an error occured while setting up the stash).  */\n-  if (! stash->info_ptr)\n+  if (! stash->f.info_ptr)\n     return FALSE;\n \n   stash->inliner_chain = NULL;\n@@ -4804,13 +4803,13 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,\n       else\n \t{\n \t  /* Check the previously read comp. units first.  */\n-\t  for (each = stash->all_comp_units; each; each = each->next_unit)\n+\t  for (each = stash->f.all_comp_units; each; each = each->next_unit)\n \t    if ((symbol->flags & BSF_FUNCTION) == 0\n \t\t|| each->arange.high == 0\n \t\t|| comp_unit_contains_address (each, addr))\n \t      {\n \t\tfound = comp_unit_find_line (each, symbol, addr, filename_ptr,\n-\t\t\t\t\t     linenumber_ptr, stash);\n+\t\t\t\t\t     linenumber_ptr);\n \t\tif (found)\n \t\t  goto done;\n \t      }\n@@ -4824,18 +4823,16 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,\n       unsigned int local_linenumber = 0;\n       unsigned int local_discriminator = 0;\n \n-      for (each = stash->all_comp_units; each; each = each->next_unit)\n+      for (each = stash->f.all_comp_units; each; each = each->next_unit)\n \t{\n \t  bfd_vma range = (bfd_vma) -1;\n \n \t  found = ((each->arange.high == 0\n \t\t    || comp_unit_contains_address (each, addr))\n-\t\t   && (range = comp_unit_find_nearest_line (each, addr,\n-\t\t\t\t\t\t\t    & local_filename,\n-\t\t\t\t\t\t\t    & local_function,\n-\t\t\t\t\t\t\t    & local_linenumber,\n-\t\t\t\t\t\t\t    & local_discriminator,\n-\t\t\t\t\t\t\t    stash)) != 0);\n+\t\t   && (range = (comp_unit_find_nearest_line\n+\t\t\t\t(each, addr, &local_filename,\n+\t\t\t\t &local_function, &local_linenumber,\n+\t\t\t\t &local_discriminator))) != 0);\n \t  if (found)\n \t    {\n \t      /* PRs 15935 15994: Bogus debug information may have provided us\n@@ -4872,7 +4869,7 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,\n     }\n \n   /* Read each remaining comp. units checking each as they are read.  */\n-  while ((each = stash_comp_unit (stash)) != NULL)\n+  while ((each = stash_comp_unit (stash, &stash->f)) != NULL)\n     {\n       /* DW_AT_low_pc and DW_AT_high_pc are optional for\n \t compilation units.  If we don't have them (i.e.,\n@@ -4884,18 +4881,15 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,\n \t\t  || each->arange.high == 0\n \t\t  || comp_unit_contains_address (each, addr))\n \t\t && comp_unit_find_line (each, symbol, addr,\n-\t\t\t\t\t filename_ptr,\n-\t\t\t\t\t linenumber_ptr,\n-\t\t\t\t\t stash));\n+\t\t\t\t\t filename_ptr, linenumber_ptr));\n       else\n \tfound = ((each->arange.high == 0\n \t\t  || comp_unit_contains_address (each, addr))\n \t\t && comp_unit_find_nearest_line (each, addr,\n \t\t\t\t\t\t filename_ptr,\n \t\t\t\t\t\t &function,\n \t\t\t\t\t\t linenumber_ptr,\n-\t\t\t\t\t\t discriminator_ptr,\n-\t\t\t\t\t\t stash) != 0);\n+\t\t\t\t\t\t discriminator_ptr) != 0);\n \n       if (found)\n \tbreak;\n@@ -4974,96 +4968,91 @@ _bfd_dwarf2_cleanup_debug_info (bfd *abfd, void **pinfo)\n {\n   struct dwarf2_debug *stash = (struct dwarf2_debug *) *pinfo;\n   struct comp_unit *each;\n+  struct dwarf2_debug_file *file;\n \n   if (abfd == NULL || stash == NULL)\n     return;\n \n-  for (each = stash->all_comp_units; each; each = each->next_unit)\n-    {\n-      struct abbrev_info **abbrevs = each->abbrevs;\n-      struct funcinfo *function_table = each->function_table;\n-      struct varinfo *variable_table = each->variable_table;\n-      size_t i;\n+  if (stash->varinfo_hash_table)\n+    bfd_hash_table_free (&stash->varinfo_hash_table->base);\n+  if (stash->funcinfo_hash_table)\n+    bfd_hash_table_free (&stash->funcinfo_hash_table->base);\n \n-      for (i = 0; i < ABBREV_HASH_SIZE; i++)\n+  file = &stash->f;\n+  while (1)\n+    {\n+      for (each = file->all_comp_units; each; each = each->next_unit)\n \t{\n-\t  struct abbrev_info *abbrev = abbrevs[i];\n+\t  struct abbrev_info **abbrevs = each->abbrevs;\n+\t  struct funcinfo *function_table = each->function_table;\n+\t  struct varinfo *variable_table = each->variable_table;\n+\t  size_t i;\n \n-\t  while (abbrev)\n+\t  for (i = 0; i < ABBREV_HASH_SIZE; i++)\n \t    {\n-\t      free (abbrev->attrs);\n-\t      abbrev = abbrev->next;\n-\t    }\n-\t}\n+\t      struct abbrev_info *abbrev = abbrevs[i];\n \n-      if (each->line_table)\n-\t{\n-\t  free (each->line_table->dirs);\n-\t  free (each->line_table->files);\n-\t}\n+\t      while (abbrev)\n+\t\t{\n+\t\t  free (abbrev->attrs);\n+\t\t  abbrev = abbrev->next;\n+\t\t}\n+\t    }\n \n-      while (function_table)\n-\t{\n-\t  if (function_table->file)\n+\t  if (each->line_table)\n \t    {\n-\t      free (function_table->file);\n-\t      function_table->file = NULL;\n+\t      free (each->line_table->files);\n+\t      free (each->line_table->dirs);\n \t    }\n \n-\t  if (function_table->caller_file)\n+\t  if (each->lookup_funcinfo_table)\n \t    {\n-\t      free (function_table->caller_file);\n-\t      function_table->caller_file = NULL;\n+\t      free (each->lookup_funcinfo_table);\n+\t      each->lookup_funcinfo_table = NULL;\n \t    }\n-\t  function_table = function_table->prev_func;\n-\t}\n-\n-      if (each->lookup_funcinfo_table)\n-\t{\n-\t  free (each->lookup_funcinfo_table);\n-\t  each->lookup_funcinfo_table = NULL;\n-\t}\n \n-      while (variable_table)\n-\t{\n-\t  if (variable_table->file)\n+\t  while (function_table)\n \t    {\n-\t      free (variable_table->file);\n-\t      variable_table->file = NULL;\n+\t      if (function_table->file)\n+\t\t{\n+\t\t  free (function_table->file);\n+\t\t  function_table->file = NULL;\n+\t\t}\n+\t      if (function_table->caller_file)\n+\t\t{\n+\t\t  free (function_table->caller_file);\n+\t\t  function_table->caller_file = NULL;\n+\t\t}\n+\t      function_table = function_table->prev_func;\n \t    }\n \n-\t  variable_table = variable_table->prev_var;\n+\t  while (variable_table)\n+\t    {\n+\t      if (variable_table->file)\n+\t\t{\n+\t\t  free (variable_table->file);\n+\t\t  variable_table->file = NULL;\n+\t\t}\n+\t      variable_table = variable_table->prev_var;\n+\t    }\n \t}\n-    }\n \n-  if (stash->funcinfo_hash_table)\n-    bfd_hash_table_free (&stash->funcinfo_hash_table->base);\n-  if (stash->varinfo_hash_table)\n-    bfd_hash_table_free (&stash->varinfo_hash_table->base);\n-  if (stash->dwarf_abbrev_buffer)\n-    free (stash->dwarf_abbrev_buffer);\n-  if (stash->dwarf_line_buffer)\n-    free (stash->dwarf_line_buffer);\n-  if (stash->dwarf_str_buffer)\n-    free (stash->dwarf_str_buffer);\n-  if (stash->dwarf_line_str_buffer)\n-    free (stash->dwarf_line_str_buffer);\n-  if (stash->dwarf_ranges_buffer)\n-    free (stash->dwarf_ranges_buffer);\n-  if (stash->info_ptr_memory)\n-    free (stash->info_ptr_memory);\n+      free (file->dwarf_line_str_buffer);\n+      free (file->dwarf_str_buffer);\n+      free (file->dwarf_ranges_buffer);\n+      free (file->dwarf_line_buffer);\n+      free (file->dwarf_abbrev_buffer);\n+      free (file->dwarf_info_buffer);\n+      if (file == &stash->alt)\n+\tbreak;\n+      file = &stash->alt;\n+    }\n+  free (stash->sec_vma);\n+  free (stash->adjusted_sections);\n   if (stash->close_on_cleanup)\n-    bfd_close (stash->bfd_ptr);\n-  if (stash->alt_dwarf_str_buffer)\n-    free (stash->alt_dwarf_str_buffer);\n-  if (stash->alt_dwarf_info_buffer)\n-    free (stash->alt_dwarf_info_buffer);\n-  if (stash->sec_vma)\n-    free (stash->sec_vma);\n-  if (stash->adjusted_sections)\n-    free (stash->adjusted_sections);\n-  if (stash->alt_bfd_ptr)\n-    bfd_close (stash->alt_bfd_ptr);\n+    bfd_close (stash->f.bfd_ptr);\n+  if (stash->alt.bfd_ptr)\n+    bfd_close (stash->alt.bfd_ptr);\n }\n \n /* Find the function to a particular section and offset,"
    }
  ]
}