{
  "sha": "ae531041c7c5956672342f89c486a011c84f027f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWU1MzEwNDFjN2M1OTU2NjcyMzQyZjg5YzQ4NmEwMTFjODRmMDI3Zg==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-03-11T16:46:19Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-03-11T16:46:19Z"
    },
    "message": "i386: Generate lfence with load/indirect branch/ret [CVE-2020-0551]\n\nAdd 3 command-line options to generate lfence for load, indirect near\nbranch and ret to help mitigate:\n\nhttps://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00334.html\nhttp://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-0551\n\n1. -mlfence-after-load=[no|yes]:\n  -mlfence-after-load=yes generates lfence after load instructions.\n2. -mlfence-before-indirect-branch=[none|all|memory|register]:\n  a. -mlfence-before-indirect-branch=all generates lfence before indirect\n  near branches via register and a warning before indirect near branches\n  via memory.\n  b. -mlfence-before-indirect-branch=memory issue a warning before\n  indirect near branches via memory.\n  c. -mlfence-before-indirect-branch=register generates lfence before\n  indirect near branches via register.\nNote that lfence won't be generated before indirect near branches via\nregister with -mlfence-after-load=yes since lfence will be generated\nafter loading branch target register.\n3. -mlfence-before-ret=[none|or|not]\n  a. -mlfence-before-ret=or generates or with lfence before ret.\n  b. -mlfence-before-ret=not generates not with lfence before ret.\n\nA warning will be issued and lfence won't be generated before indirect\nnear branch and ret if the previous item is a prefix or a constant\ndirective, which may be used to hardcode an instruction, since there\nis no clear instruction boundary.\n\n\t* config/tc-i386.c (lfence_after_load): New.\n\t(lfence_before_indirect_branch_kind): New.\n\t(lfence_before_indirect_branch): New.\n\t(lfence_before_ret_kind): New.\n\t(lfence_before_ret): New.\n\t(last_insn): New.\n\t(load_insn_p): New.\n\t(insert_lfence_after): New.\n\t(insert_lfence_before): New.\n\t(md_assemble): Call insert_lfence_before and insert_lfence_after.\n\tSet last_insn.\n\t(OPTION_MLFENCE_AFTER_LOAD): New.\n\t(OPTION_MLFENCE_BEFORE_INDIRECT_BRANCH): New.\n\t(OPTION_MLFENCE_BEFORE_RET): New.\n\t(md_longopts): Add -mlfence-after-load=,\n\t-mlfence-before-indirect-branch= and -mlfence-before-ret=.\n\t(md_parse_option): Handle -mlfence-after-load=,\n\t-mlfence-before-indirect-branch= and -mlfence-before-ret=.\n\t(md_show_usage): Display -mlfence-after-load=,\n\t-mlfence-before-indirect-branch= and -mlfence-before-ret=.\n\t(i386_cons_align): New.\n\t* config/tc-i386.h (i386_cons_align): New.\n\t(md_cons_align): New.\n\t* doc/c-i386.texi: Document -mlfence-after-load=,\n\t-mlfence-before-indirect-branch= and -mlfence-before-ret=.",
    "tree": {
      "sha": "725d546c60204a155b8192591ab3011eb633e1ca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/725d546c60204a155b8192591ab3011eb633e1ca"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ae531041c7c5956672342f89c486a011c84f027f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ae531041c7c5956672342f89c486a011c84f027f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ae531041c7c5956672342f89c486a011c84f027f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ae531041c7c5956672342f89c486a011c84f027f/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5a13315d1c6993ab84075ff94797eb8c6da1f20b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5a13315d1c6993ab84075ff94797eb8c6da1f20b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5a13315d1c6993ab84075ff94797eb8c6da1f20b"
    }
  ],
  "stats": {
    "total": 437,
    "additions": 436,
    "deletions": 1
  },
  "files": [
    {
      "sha": "19f4bc2cd8b8be40bf1130811c5f8fc59058dabf",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ae531041c7c5956672342f89c486a011c84f027f/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ae531041c7c5956672342f89c486a011c84f027f/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=ae531041c7c5956672342f89c486a011c84f027f",
      "patch": "@@ -1,3 +1,31 @@\n+2020-03-11  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* config/tc-i386.c (lfence_after_load): New.\n+\t(lfence_before_indirect_branch_kind): New.\n+\t(lfence_before_indirect_branch): New.\n+\t(lfence_before_ret_kind): New.\n+\t(lfence_before_ret): New.\n+\t(last_insn): New.\n+\t(load_insn_p): New.\n+\t(insert_lfence_after): New.\n+\t(insert_lfence_before): New.\n+\t(md_assemble): Call insert_lfence_before and insert_lfence_after.\n+\tSet last_insn.\n+\t(OPTION_MLFENCE_AFTER_LOAD): New.\n+\t(OPTION_MLFENCE_BEFORE_INDIRECT_BRANCH): New.\n+\t(OPTION_MLFENCE_BEFORE_RET): New.\n+\t(md_longopts): Add -mlfence-after-load=,\n+\t-mlfence-before-indirect-branch= and -mlfence-before-ret=.\n+\t(md_parse_option): Handle -mlfence-after-load=,\n+\t-mlfence-before-indirect-branch= and -mlfence-before-ret=.\n+\t(md_show_usage): Display -mlfence-after-load=,\n+\t-mlfence-before-indirect-branch= and -mlfence-before-ret=.\n+\t(i386_cons_align): New.\n+\t* config/tc-i386.h (i386_cons_align): New.\n+\t(md_cons_align): New.\n+\t* doc/c-i386.texi: Document -mlfence-after-load=,\n+\t-mlfence-before-indirect-branch= and -mlfence-before-ret=.\n+\n 2020-03-11  Nick Clifton  <nickc@redhat.com>\n \n \tPR 25611"
    },
    {
      "sha": "09063f784b73a0d74a77b1de5218e02c3c332cdc",
      "filename": "gas/config/tc-i386.c",
      "status": "modified",
      "additions": 365,
      "deletions": 1,
      "changes": 366,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ae531041c7c5956672342f89c486a011c84f027f/gas/config/tc-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ae531041c7c5956672342f89c486a011c84f027f/gas/config/tc-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-i386.c?ref=ae531041c7c5956672342f89c486a011c84f027f",
      "patch": "@@ -629,7 +629,29 @@ static int omit_lock_prefix = 0;\n    \"lock addl $0, (%{re}sp)\".  */\n static int avoid_fence = 0;\n \n-/* Type of the previous instruction.  */\n+/* 1 if lfence should be inserted after every load.  */\n+static int lfence_after_load = 0;\n+\n+/* Non-zero if lfence should be inserted before indirect branch.  */\n+static enum lfence_before_indirect_branch_kind\n+  {\n+    lfence_branch_none = 0,\n+    lfence_branch_register,\n+    lfence_branch_memory,\n+    lfence_branch_all\n+  }\n+lfence_before_indirect_branch;\n+\n+/* Non-zero if lfence should be inserted before ret.  */\n+static enum lfence_before_ret_kind\n+  {\n+    lfence_before_ret_none = 0,\n+    lfence_before_ret_not,\n+    lfence_before_ret_or\n+  }\n+lfence_before_ret;\n+\n+/* Types of previous instruction is .byte or prefix.  */\n static struct\n   {\n     segT seg;\n@@ -4311,6 +4333,283 @@ optimize_encoding (void)\n     }\n }\n \n+/* Return non-zero for load instruction.  */\n+\n+static int\n+load_insn_p (void)\n+{\n+  unsigned int dest;\n+  int any_vex_p = is_any_vex_encoding (&i.tm);\n+  unsigned int base_opcode = i.tm.base_opcode | 1;\n+\n+  if (!any_vex_p)\n+    {\n+      /* lea  */\n+      if (i.tm.base_opcode == 0x8d)\n+\treturn 0;\n+\n+      /* pop  */\n+      if ((i.tm.base_opcode & ~7) == 0x58\n+\t  || (i.tm.base_opcode == 0x8f && i.tm.extension_opcode == 0))\n+\treturn 1;\n+\n+      /* movs, cmps, lods, scas.  */\n+      if ((i.tm.base_opcode | 0xb) == 0xaf)\n+\treturn 1;\n+\n+      /* outs */\n+      if (base_opcode == 0x6f)\n+\treturn 1;\n+    }\n+\n+  /* No memory operand.  */\n+  if (!i.mem_operands)\n+    return 0;\n+\n+  if (any_vex_p)\n+    {\n+      /* vldmxcsr.  */\n+      if (i.tm.base_opcode == 0xae\n+\t  && i.tm.opcode_modifier.vex\n+\t  && i.tm.opcode_modifier.vexopcode == VEX0F\n+\t  && i.tm.extension_opcode == 2)\n+\treturn 1;\n+    }\n+  else\n+    {\n+      /* test, not, neg, mul, imul, div, idiv.  */\n+      if ((i.tm.base_opcode == 0xf6 || i.tm.base_opcode == 0xf7)\n+\t  && i.tm.extension_opcode != 1)\n+\treturn 1;\n+\n+      /* inc, dec.  */\n+      if (base_opcode == 0xff && i.tm.extension_opcode <= 1)\n+\treturn 1;\n+\n+      /* add, or, adc, sbb, and, sub, xor, cmp.  */\n+      if (i.tm.base_opcode >= 0x80 && i.tm.base_opcode <= 0x83)\n+\treturn 1;\n+\n+      /* bt, bts, btr, btc.  */\n+      if (i.tm.base_opcode == 0xfba\n+\t  && (i.tm.extension_opcode >= 4 && i.tm.extension_opcode <= 7))\n+\treturn 1;\n+\n+      /* rol, ror, rcl, rcr, shl/sal, shr, sar. */\n+      if ((base_opcode == 0xc1\n+\t   || (i.tm.base_opcode >= 0xd0 && i.tm.base_opcode <= 0xd3))\n+\t  && i.tm.extension_opcode != 6)\n+\treturn 1;\n+\n+      /* cmpxchg8b, cmpxchg16b, xrstors.  */\n+      if (i.tm.base_opcode == 0xfc7\n+\t  && (i.tm.extension_opcode == 1 || i.tm.extension_opcode == 3))\n+\treturn 1;\n+\n+      /* fxrstor, ldmxcsr, xrstor.  */\n+      if (i.tm.base_opcode == 0xfae\n+\t  && (i.tm.extension_opcode == 1\n+\t      || i.tm.extension_opcode == 2\n+\t      || i.tm.extension_opcode == 5))\n+\treturn 1;\n+\n+      /* lgdt, lidt, lmsw.  */\n+      if (i.tm.base_opcode == 0xf01\n+\t  && (i.tm.extension_opcode == 2\n+\t      || i.tm.extension_opcode == 3\n+\t      || i.tm.extension_opcode == 6))\n+\treturn 1;\n+\n+      /* vmptrld */\n+      if (i.tm.base_opcode == 0xfc7\n+\t  && i.tm.extension_opcode == 6)\n+\treturn 1;\n+\n+      /* Check for x87 instructions.  */\n+      if (i.tm.base_opcode >= 0xd8 && i.tm.base_opcode <= 0xdf)\n+\t{\n+\t  /* Skip fst, fstp, fstenv, fstcw.  */\n+\t  if (i.tm.base_opcode == 0xd9\n+\t      && (i.tm.extension_opcode == 2\n+\t\t  || i.tm.extension_opcode == 3\n+\t\t  || i.tm.extension_opcode == 6\n+\t\t  || i.tm.extension_opcode == 7))\n+\t    return 0;\n+\n+\t  /* Skip fisttp, fist, fistp, fstp.  */\n+\t  if (i.tm.base_opcode == 0xdb\n+\t      && (i.tm.extension_opcode == 1\n+\t\t  || i.tm.extension_opcode == 2\n+\t\t  || i.tm.extension_opcode == 3\n+\t\t  || i.tm.extension_opcode == 7))\n+\t    return 0;\n+\n+\t  /* Skip fisttp, fst, fstp, fsave, fstsw.  */\n+\t  if (i.tm.base_opcode == 0xdd\n+\t      && (i.tm.extension_opcode == 1\n+\t\t  || i.tm.extension_opcode == 2\n+\t\t  || i.tm.extension_opcode == 3\n+\t\t  || i.tm.extension_opcode == 6\n+\t\t  || i.tm.extension_opcode == 7))\n+\t    return 0;\n+\n+\t  /* Skip fisttp, fist, fistp, fbstp, fistp.  */\n+\t  if (i.tm.base_opcode == 0xdf\n+\t      && (i.tm.extension_opcode == 1\n+\t\t  || i.tm.extension_opcode == 2\n+\t\t  || i.tm.extension_opcode == 3\n+\t\t  || i.tm.extension_opcode == 6\n+\t\t  || i.tm.extension_opcode == 7))\n+\t    return 0;\n+\n+\t  return 1;\n+\t}\n+    }\n+\n+  dest = i.operands - 1;\n+\n+  /* Check fake imm8 operand and 3 source operands.  */\n+  if ((i.tm.opcode_modifier.immext\n+       || i.tm.opcode_modifier.vexsources == VEX3SOURCES)\n+      && i.types[dest].bitfield.imm8)\n+    dest--;\n+\n+  /* add, or, adc, sbb, and, sub, xor, cmp, test, xchg, xadd  */\n+  if (!any_vex_p\n+      && (base_opcode == 0x1\n+\t  || base_opcode == 0x9\n+\t  || base_opcode == 0x11\n+\t  || base_opcode == 0x19\n+\t  || base_opcode == 0x21\n+\t  || base_opcode == 0x29\n+\t  || base_opcode == 0x31\n+\t  || base_opcode == 0x39\n+\t  || (i.tm.base_opcode >= 0x84 && i.tm.base_opcode <= 0x87)\n+\t  || base_opcode == 0xfc1))\n+    return 1;\n+\n+  /* Check for load instruction.  */\n+  return (i.types[dest].bitfield.class != ClassNone\n+\t  || i.types[dest].bitfield.instance == Accum);\n+}\n+\n+/* Output lfence, 0xfaee8, after instruction.  */\n+\n+static void\n+insert_lfence_after (void)\n+{\n+  if (lfence_after_load && load_insn_p ())\n+    {\n+      char *p = frag_more (3);\n+      *p++ = 0xf;\n+      *p++ = 0xae;\n+      *p = 0xe8;\n+    }\n+}\n+\n+/* Output lfence, 0xfaee8, before instruction.  */\n+\n+static void\n+insert_lfence_before (void)\n+{\n+  char *p;\n+\n+  if (is_any_vex_encoding (&i.tm))\n+    return;\n+\n+  if (i.tm.base_opcode == 0xff\n+      && (i.tm.extension_opcode == 2 || i.tm.extension_opcode == 4))\n+    {\n+      /* Insert lfence before indirect branch if needed.  */\n+\n+      if (lfence_before_indirect_branch == lfence_branch_none)\n+\treturn;\n+\n+      if (i.operands != 1)\n+\tabort ();\n+\n+      if (i.reg_operands == 1)\n+\t{\n+\t  /* Indirect branch via register.  Don't insert lfence with\n+\t     -mlfence-after-load=yes.  */\n+\t  if (lfence_after_load\n+\t      || lfence_before_indirect_branch == lfence_branch_memory)\n+\t    return;\n+\t}\n+      else if (i.mem_operands == 1\n+\t       && lfence_before_indirect_branch != lfence_branch_register)\n+\t{\n+\t  as_warn (_(\"indirect `%s` with memory operand should be avoided\"),\n+\t\t   i.tm.name);\n+\t  return;\n+\t}\n+      else\n+\treturn;\n+\n+      if (last_insn.kind != last_insn_other\n+\t  && last_insn.seg == now_seg)\n+\t{\n+\t  as_warn_where (last_insn.file, last_insn.line,\n+\t\t\t _(\"`%s` skips -mlfence-before-indirect-branch on `%s`\"),\n+\t\t\t last_insn.name, i.tm.name);\n+\t  return;\n+\t}\n+\n+      p = frag_more (3);\n+      *p++ = 0xf;\n+      *p++ = 0xae;\n+      *p = 0xe8;\n+      return;\n+    }\n+\n+  /* Output or/not and lfence before ret.  */\n+  if (lfence_before_ret != lfence_before_ret_none\n+      && (i.tm.base_opcode == 0xc2\n+\t  || i.tm.base_opcode == 0xc3\n+\t  || i.tm.base_opcode == 0xca\n+\t  || i.tm.base_opcode == 0xcb))\n+    {\n+      if (last_insn.kind != last_insn_other\n+\t  && last_insn.seg == now_seg)\n+\t{\n+\t  as_warn_where (last_insn.file, last_insn.line,\n+\t\t\t _(\"`%s` skips -mlfence-before-ret on `%s`\"),\n+\t\t\t last_insn.name, i.tm.name);\n+\t  return;\n+\t}\n+      if (lfence_before_ret == lfence_before_ret_or)\n+\t{\n+\t  /* orl: 0x830c2400.  */\n+\t  p = frag_more ((flag_code == CODE_64BIT ? 1 : 0) + 4 + 3);\n+\t  if (flag_code == CODE_64BIT)\n+\t    *p++ = 0x48;\n+\t  *p++ = 0x83;\n+\t  *p++ = 0xc;\n+\t  *p++ = 0x24;\n+\t  *p++ = 0x0;\n+\t}\n+      else\n+\t{\n+\t  p = frag_more ((flag_code == CODE_64BIT ? 2 : 0) + 6 + 3);\n+\t  /* notl: 0xf71424.  */\n+\t  if (flag_code == CODE_64BIT)\n+\t    *p++ = 0x48;\n+\t  *p++ = 0xf7;\n+\t  *p++ = 0x14;\n+\t  *p++ = 0x24;\n+\t  /* notl: 0xf71424.  */\n+\t  if (flag_code == CODE_64BIT)\n+\t    *p++ = 0x48;\n+\t  *p++ = 0xf7;\n+\t  *p++ = 0x14;\n+\t  *p++ = 0x24;\n+\t}\n+      *p++ = 0xf;\n+      *p++ = 0xae;\n+      *p = 0xe8;\n+    }\n+}\n+\n /* This is the guts of the machine-dependent assembler.  LINE points to a\n    machine dependent instruction.  This function is supposed to emit\n    the frags/bytes it assembles to.  */\n@@ -4628,9 +4927,13 @@ md_assemble (char *line)\n   if (i.rex != 0)\n     add_prefix (REX_OPCODE | i.rex);\n \n+  insert_lfence_before ();\n+\n   /* We are ready to output the insn.  */\n   output_insn ();\n \n+  insert_lfence_after ();\n+\n   last_insn.seg = now_seg;\n \n   if (i.tm.opcode_modifier.isprefix)\n@@ -12250,6 +12553,9 @@ const char *md_shortopts = \"qnO::\";\n #define OPTION_MALIGN_BRANCH_PREFIX_SIZE (OPTION_MD_BASE + 28)\n #define OPTION_MALIGN_BRANCH (OPTION_MD_BASE + 29)\n #define OPTION_MBRANCHES_WITH_32B_BOUNDARIES (OPTION_MD_BASE + 30)\n+#define OPTION_MLFENCE_AFTER_LOAD (OPTION_MD_BASE + 31)\n+#define OPTION_MLFENCE_BEFORE_INDIRECT_BRANCH (OPTION_MD_BASE + 32)\n+#define OPTION_MLFENCE_BEFORE_RET (OPTION_MD_BASE + 33)\n \n struct option md_longopts[] =\n {\n@@ -12289,6 +12595,10 @@ struct option md_longopts[] =\n   {\"malign-branch-prefix-size\", required_argument, NULL, OPTION_MALIGN_BRANCH_PREFIX_SIZE},\n   {\"malign-branch\", required_argument, NULL, OPTION_MALIGN_BRANCH},\n   {\"mbranches-within-32B-boundaries\", no_argument, NULL, OPTION_MBRANCHES_WITH_32B_BOUNDARIES},\n+  {\"mlfence-after-load\", required_argument, NULL, OPTION_MLFENCE_AFTER_LOAD},\n+  {\"mlfence-before-indirect-branch\", required_argument, NULL,\n+   OPTION_MLFENCE_BEFORE_INDIRECT_BRANCH},\n+  {\"mlfence-before-ret\", required_argument, NULL, OPTION_MLFENCE_BEFORE_RET},\n   {\"mamd64\", no_argument, NULL, OPTION_MAMD64},\n   {\"mintel64\", no_argument, NULL, OPTION_MINTEL64},\n   {NULL, no_argument, NULL, 0}\n@@ -12668,6 +12978,41 @@ md_parse_option (int c, const char *arg)\n         as_fatal (_(\"invalid -mfence-as-lock-add= option: `%s'\"), arg);\n       break;\n \n+    case OPTION_MLFENCE_AFTER_LOAD:\n+      if (strcasecmp (arg, \"yes\") == 0)\n+\tlfence_after_load = 1;\n+      else if (strcasecmp (arg, \"no\") == 0)\n+\tlfence_after_load = 0;\n+      else\n+        as_fatal (_(\"invalid -mlfence-after-load= option: `%s'\"), arg);\n+      break;\n+\n+    case OPTION_MLFENCE_BEFORE_INDIRECT_BRANCH:\n+      if (strcasecmp (arg, \"all\") == 0)\n+\tlfence_before_indirect_branch = lfence_branch_all;\n+      else if (strcasecmp (arg, \"memory\") == 0)\n+\tlfence_before_indirect_branch = lfence_branch_memory;\n+      else if (strcasecmp (arg, \"register\") == 0)\n+\tlfence_before_indirect_branch = lfence_branch_register;\n+      else if (strcasecmp (arg, \"none\") == 0)\n+\tlfence_before_indirect_branch = lfence_branch_none;\n+      else\n+        as_fatal (_(\"invalid -mlfence-before-indirect-branch= option: `%s'\"),\n+\t\t  arg);\n+      break;\n+\n+    case OPTION_MLFENCE_BEFORE_RET:\n+      if (strcasecmp (arg, \"or\") == 0)\n+\tlfence_before_ret = lfence_before_ret_or;\n+      else if (strcasecmp (arg, \"not\") == 0)\n+\tlfence_before_ret = lfence_before_ret_not;\n+      else if (strcasecmp (arg, \"none\") == 0)\n+\tlfence_before_ret = lfence_before_ret_none;\n+      else\n+        as_fatal (_(\"invalid -mlfence-before-ret= option: `%s'\"),\n+\t\t  arg);\n+      break;\n+\n     case OPTION_MRELAX_RELOCATIONS:\n       if (strcasecmp (arg, \"yes\") == 0)\n         generate_relax_relocations = 1;\n@@ -13025,6 +13370,15 @@ md_show_usage (FILE *stream)\n   -mbranches-within-32B-boundaries\\n\\\n                           align branches within 32 byte boundary\\n\"));\n   fprintf (stream, _(\"\\\n+  -mlfence-after-load=[no|yes] (default: no)\\n\\\n+                          generate lfence after load\\n\"));\n+  fprintf (stream, _(\"\\\n+  -mlfence-before-indirect-branch=[none|all|register|memory] (default: none)\\n\\\n+                          generate lfence before indirect near branch\\n\"));\n+  fprintf (stream, _(\"\\\n+  -mlfence-before-ret=[none|or|not] (default: none)\\n\\\n+                          generate lfence before ret\\n\"));\n+  fprintf (stream, _(\"\\\n   -mamd64                 accept only AMD64 ISA [default]\\n\"));\n   fprintf (stream, _(\"\\\n   -mintel64               accept only Intel64 ISA\\n\"));\n@@ -13254,6 +13608,16 @@ i386_cons_align (int ignore ATTRIBUTE_UNUSED)\n       last_insn.kind = last_insn_directive;\n       last_insn.name = \"constant directive\";\n       last_insn.file = as_where (&last_insn.line);\n+      if (lfence_before_ret != lfence_before_ret_none)\n+\t{\n+\t  if (lfence_before_indirect_branch != lfence_branch_none)\n+\t    as_warn (_(\"constant directive skips -mlfence-before-ret \"\n+\t\t       \"and -mlfence-before-indirect-branch\"));\n+\t  else\n+\t    as_warn (_(\"constant directive skips -mlfence-before-ret\"));\n+\t}\n+      else if (lfence_before_indirect_branch != lfence_branch_none)\n+\tas_warn (_(\"constant directive skips -mlfence-before-indirect-branch\"));\n     }\n }\n "
    },
    {
      "sha": "1dd99f91bb0e97f220c17cacedbe5c4f71cfe8d1",
      "filename": "gas/doc/c-i386.texi",
      "status": "modified",
      "additions": 43,
      "deletions": 0,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ae531041c7c5956672342f89c486a011c84f027f/gas/doc/c-i386.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ae531041c7c5956672342f89c486a011c84f027f/gas/doc/c-i386.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/doc/c-i386.texi?ref=ae531041c7c5956672342f89c486a011c84f027f",
      "patch": "@@ -464,6 +464,49 @@ on an instruction.  It is equivalent to\n @option{-malign-branch-prefix-size=5}.\n The default doesn't align branches.\n \n+@cindex @samp{-mlfence-after-load=} option, i386\n+@cindex @samp{-mlfence-after-load=} option, x86-64\n+@item -mlfence-after-load=@var{no}\n+@itemx -mlfence-after-load=@var{yes}\n+These options control whether the assembler should generate lfence\n+after load instructions.  @option{-mlfence-after-load=@var{yes}} will\n+generate lfence.  @option{-mlfence-after-load=@var{no}} will not generate\n+lfence, which is the default.\n+\n+@cindex @samp{-mlfence-before-indirect-branch=} option, i386\n+@cindex @samp{-mlfence-before-indirect-branch=} option, x86-64\n+@item -mlfence-before-indirect-branch=@var{none}\n+@item -mlfence-before-indirect-branch=@var{all}\n+@item -mlfence-before-indirect-branch=@var{register}\n+@itemx -mlfence-before-indirect-branch=@var{memory}\n+These options control whether the assembler should generate lfence\n+after indirect near branch instructions.\n+@option{-mlfence-before-indirect-branch=@var{all}} will generate lfence\n+after indirect near branch via register and issue a warning before\n+indirect near branch via memory.\n+@option{-mlfence-before-indirect-branch=@var{register}} will generate\n+lfence after indirect near branch via register.\n+@option{-mlfence-before-indirect-branch=@var{memory}} will issue a\n+warning before indirect near branch via memory.\n+@option{-mlfence-before-indirect-branch=@var{none}} will not generate\n+lfence nor issue warning, which is the default.  Note that lfence won't\n+be generated before indirect near branch via register with\n+@option{-mlfence-after-load=@var{yes}} since lfence will be generated\n+after loading branch target register.\n+\n+@cindex @samp{-mlfence-before-ret=} option, i386\n+@cindex @samp{-mlfence-before-ret=} option, x86-64\n+@item -mlfence-before-ret=@var{none}\n+@item -mlfence-before-ret=@var{or}\n+@itemx -mlfence-before-ret=@var{not}\n+These options control whether the assembler should generate lfence\n+before ret.  @option{-mlfence-before-ret=@var{or}} will generate\n+generate or instruction with lfence.\n+@option{-mlfence-before-ret=@var{not}} will generate not instruction\n+with lfence.\n+@option{-mlfence-before-ret=@var{none}} will not generate lfence,\n+which is the default.\n+\n @cindex @samp{-mx86-used-note=} option, i386\n @cindex @samp{-mx86-used-note=} option, x86-64\n @item -mx86-used-note=@var{no}"
    }
  ]
}