{
  "sha": "b3e3a4c11496dca710c62e32db80e27dd7301223",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjNlM2E0YzExNDk2ZGNhNzEwYzYyZTMyZGI4MGUyN2RkNzMwMTIyMw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-07-04T12:33:19Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-07-10T22:52:05Z"
    },
    "message": "Fix GDB busy loop when interrupting non-stop program (PR 26199)\n\nWhen interrupting a program in non-stop, the program gets interrupted\ncorrectly, but GDB busy loops (the event loop is always woken up).\n\nHere is how to reproduce it:\n\n 1. Start GDB: ./gdb -nx --data-directory=data-directory -ex \"set non-stop 1\" --args  /bin/sleep 60\n 2. Run the program with \"run\"\n 3. Interrupt with ^C.\n 4. Look into htop, see GDB taking 100% CPU\n\nDebugging `handle_file_event`, we see that the event source that wakes\nup the event loop is the linux-nat one:\n\n (top-gdb) p file_ptr.proc\n $5 = (handler_func *) 0xb9cccd <handle_target_event(int, gdb_client_data)>\n\t\t\t\t ^^^^^^^^^^^^^^^^^^^\n\t\t\t\t\t |\n\t\t\t\t\t \\-- the linux-nat callback\n\nDebugging fetch_inferior_event and do_target_wait, we see that we\ndon't actually call `wait` on the linux-nat target, because\ninferior_matches returns false:\n\n auto inferior_matches = [&wait_ptid] (inferior *inf)\n   {\n     return (inf->process_target () != NULL\n\t     && (threads_are_executing (inf->process_target ())\n\t\t || threads_are_resumed_pending_p (inf))\n\t     && ptid_t (inf->pid).matches (wait_ptid));\n   };\n\nbecause `threads_are_executing` is false.\n\nWhat happens is:\n\n 1. User types ctrl-c, that writes in the linux-nat pipe, waking up\n    the event source.\n\n 2. linux-nat's wait gets called, the SIGINT event is returned, but\n    before returning, it marks the pipe again, in order for wait to\n    get called again:\n\n    /* If we requested any event, and something came out, assume there\n       may be more.  If we requested a specific lwp or process, also\n       assume there may be more.  */\n    if (target_is_async_p ()\n\t&& ((ourstatus->kind != TARGET_WAITKIND_IGNORE\n\t     && ourstatus->kind != TARGET_WAITKIND_NO_RESUMED)\n\t    || ptid != minus_one_ptid))\n      async_file_mark ();\n\n 3. The SIGINT event is handled, the program is stopped, the stop\n    notification is printed.\n\n 4. The event loop is woken up again because of the `async_file_mark`\n    of step 2.\n\n 5. Because `inferior_matches` returns false, we never call\n    linux-nat's wait, so the pipe stays readable.\n\n 6. Goto 4.\n\nPedro says:\n\nThis commit fixes it by letting do_target_wait call target_wait even\nif threads_are_executing is false.  This will normally result in the\ntarget returning TARGET_WAITKIND_NO_RESUMED, and _not_ marking its\nevent source again.  This results in infrun only calling into the\ntarget only once (i.e., breaking the busy loop).\n\nNote that the busy loop bug didn't trigger in all-stop mode because\nall-stop handles this by unregistering the target from the event loop\nas soon as it was all stopped -- see\ninf-loop.c:inferior_event_handler's INF_EXEC_COMPLETE handling.  If we\nremove that non-stop check from inferior_event_handler, and replace\nthe target_has_execution check for threads_are_executing instead, it\nalso fixes the issue for non-stop.  I considered that as the final\nsolution, but decided that the solution proposed here instead is just\nsimpler and more future-proof design.  With the\nTARGET_WAITKIND_NO_RESUMED handling fixes done in the previous\npatches, I think it should be possible to always keep the target\nregistered in the event loop, meaning we could eliminate the\ntarget_async(0) call from inferior_event_handler as well as most of\nthe target_async(1) calls in the target backends.  That would allow in\nthe future e.g., the remote target reporting asynchronous\nnotifications even if all threads are stopped.  I haven't attempted\nthat, though.\n\ngdb/ChangeLog:\nyyyy-mm-dd  Simon Marchi  <simon.marchi@polymtl.ca>\n\t    Pedro Alves  <pedro@palves.net>\n\n\tPR gdb/26199\n\t* infrun.c (threads_are_resumed_pending_p): Delete.\n\t(do_target_wait): Remove threads_are_executing and\n\tthreads_are_resumed_pending_p checks from the inferior_matches\n\tlambda.  Update comments.",
    "tree": {
      "sha": "6905a55f20e032509476b2158e7193ef99bc2890",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6905a55f20e032509476b2158e7193ef99bc2890"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b3e3a4c11496dca710c62e32db80e27dd7301223",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3e3a4c11496dca710c62e32db80e27dd7301223",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b3e3a4c11496dca710c62e32db80e27dd7301223",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3e3a4c11496dca710c62e32db80e27dd7301223/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4fdba23df6d202b9d428818fc209e527797b576f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4fdba23df6d202b9d428818fc209e527797b576f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4fdba23df6d202b9d428818fc209e527797b576f"
    }
  ],
  "stats": {
    "total": 47,
    "additions": 20,
    "deletions": 27
  },
  "files": [
    {
      "sha": "59db3402186286e6b27d198cda08d9899bb62027",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3e3a4c11496dca710c62e32db80e27dd7301223/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3e3a4c11496dca710c62e32db80e27dd7301223/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b3e3a4c11496dca710c62e32db80e27dd7301223",
      "patch": "@@ -1,3 +1,12 @@\n+2020-07-10  Simon Marchi  <simon.marchi@polymtl.ca>\n+\t    Pedro Alves  <pedro@palves.net>\n+\n+\tPR gdb/26199\n+\t* infrun.c (threads_are_resumed_pending_p): Delete.\n+\t(do_target_wait): Remove threads_are_executing and\n+\tthreads_are_resumed_pending_p checks from the inferior_matches\n+\tlambda.  Update comments.\n+\n 2020-07-10  Pedro Alves  <pedro@palves.net>\n \n \tPR gdb/26199"
    },
    {
      "sha": "31266109a6d33dbbb004c7582bb57752d11fd240",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 11,
      "deletions": 27,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3e3a4c11496dca710c62e32db80e27dd7301223/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3e3a4c11496dca710c62e32db80e27dd7301223/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=b3e3a4c11496dca710c62e32db80e27dd7301223",
      "patch": "@@ -3601,44 +3601,28 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n   return event_ptid;\n }\n \n-/* Returns true if INF has any resumed thread with a status\n-   pending.  */\n-\n-static bool\n-threads_are_resumed_pending_p (inferior *inf)\n-{\n-  for (thread_info *tp : inf->non_exited_threads ())\n-    if (tp->resumed\n-\t&& tp->suspend.waitstatus_pending_p)\n-      return true;\n-\n-  return false;\n-}\n-\n /* Wrapper for target_wait that first checks whether threads have\n    pending statuses to report before actually asking the target for\n-   more events. Polls for events from all inferiors/targets.  */\n+   more events.  Polls for events from all inferiors/targets.  */\n \n static bool\n do_target_wait (ptid_t wait_ptid, execution_control_state *ecs, int options)\n {\n   int num_inferiors = 0;\n   int random_selector;\n \n-  /* For fairness, we pick the first inferior/target to poll at\n-     random, and then continue polling the rest of the inferior list\n-     starting from that one in a circular fashion until the whole list\n-     is polled once.  */\n+  /* For fairness, we pick the first inferior/target to poll at random\n+     out of all inferiors that may report events, and then continue\n+     polling the rest of the inferior list starting from that one in a\n+     circular fashion until the whole list is polled once.  */\n \n   auto inferior_matches = [&wait_ptid] (inferior *inf)\n     {\n       return (inf->process_target () != NULL\n-\t      && (threads_are_executing (inf->process_target ())\n-\t\t  || threads_are_resumed_pending_p (inf))\n \t      && ptid_t (inf->pid).matches (wait_ptid));\n     };\n \n-  /* First see how many resumed inferiors we have.  */\n+  /* First see how many matching inferiors we have.  */\n   for (inferior *inf : all_inferiors ())\n     if (inferior_matches (inf))\n       num_inferiors++;\n@@ -3649,7 +3633,7 @@ do_target_wait (ptid_t wait_ptid, execution_control_state *ecs, int options)\n       return false;\n     }\n \n-  /* Now randomly pick an inferior out of those that were resumed.  */\n+  /* Now randomly pick an inferior out of those that matched.  */\n   random_selector = (int)\n     ((num_inferiors * (double) rand ()) / (RAND_MAX + 1.0));\n \n@@ -3658,7 +3642,7 @@ do_target_wait (ptid_t wait_ptid, execution_control_state *ecs, int options)\n \t\t\t\"infrun: Found %d inferiors, starting at #%d\\n\",\n \t\t\tnum_inferiors, random_selector);\n \n-  /* Select the Nth inferior that was resumed.  */\n+  /* Select the Nth inferior that matched.  */\n \n   inferior *selected = nullptr;\n \n@@ -3670,7 +3654,7 @@ do_target_wait (ptid_t wait_ptid, execution_control_state *ecs, int options)\n \t  break;\n \t}\n \n-  /* Now poll for events out of each of the resumed inferior's\n+  /* Now poll for events out of each of the matching inferior's\n      targets, starting from the selected one.  */\n \n   auto do_wait = [&] (inferior *inf)\n@@ -3680,8 +3664,8 @@ do_target_wait (ptid_t wait_ptid, execution_control_state *ecs, int options)\n     return (ecs->ws.kind != TARGET_WAITKIND_IGNORE);\n   };\n \n-  /* Needed in all-stop+target-non-stop mode, because we end up here\n-     spuriously after the target is all stopped and we've already\n+  /* Needed in 'all-stop + target-non-stop' mode, because we end up\n+     here spuriously after the target is all stopped and we've already\n      reported the stop to the user, polling for events.  */\n   scoped_restore_current_thread restore_thread;\n "
    }
  ]
}