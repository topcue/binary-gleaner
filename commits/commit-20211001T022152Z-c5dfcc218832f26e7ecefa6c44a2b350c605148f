{
  "sha": "c5dfcc218832f26e7ecefa6c44a2b350c605148f",
  "node_id": "C_kwDOANOeidoAKGM1ZGZjYzIxODgzMmYyNmU3ZWNlZmE2YzQ0YTJiMzUwYzYwNTE0OGY",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-08-30T15:20:58Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-10-01T02:21:52Z"
    },
    "message": "gdb/testsuite/dwarf: don't define nested procs for rnglists/loclists\n\nWhen I wrote support for rnglists and loclists in the testsuite's DWARF\nassembler, I made it with nested procs, for example proc \"table\" inside\nproc \"rnglists\".  The intention was that this proc \"table\" could only be\nused by the user while inside proc \"rnglists\"'s body.  I had chosen very\nsimple names, thinking there was no chance of name clashes.  I recently\nlearned that this is not how TCL works.  This ends up defining a proc\n\"table\" in the current namespace (\"Dwarf\" in this case).\n\nThings still work if you generate rnglists and loclists in the same\nfile, as each redefines its own procedures when executing.  But if a\nuser of the assembler happened to define a convenience \"table\" or\n\"start_end\" procedure, for example, it would get overriden.\n\nI'd like to change how this works to reduce the chances of a name clash.\n\n - Move the procs out of each other, so they are not defined in a nested\n   fashion.\n - Prefix them with \"_rnglists_\" or \"_loclists_\".\n - While calling $body in the various procs, temporarily make the procs\n   available under their \"short\" name.  For example, while in rngllists'\n   body, make _rnglists_table available as just \"table\".  This allows\n   existing code to keep working and keeps it not too verbose.\n - Modify with_override to allow the overriden proc to not exist.  In\n   that case, the temporary proc is deleted on exit.\n\nNote the non-conforming indentation when calling with_override in\n_loclists_list.  This is on purpose: as we implement more loclists (and\nrnglists) entry types, the indentation would otherwise get larger and\nlarger without much value for readability.  So I think it's reasonable\nhere to put them on the same level.\n\nChange-Id: I7bb48d26fcb0dba1ae4dada05c0c837212424328",
    "tree": {
      "sha": "33f3415c2b03071d53e5f512dab8ce077ab10b39",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/33f3415c2b03071d53e5f512dab8ce077ab10b39"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c5dfcc218832f26e7ecefa6c44a2b350c605148f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c5dfcc218832f26e7ecefa6c44a2b350c605148f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c5dfcc218832f26e7ecefa6c44a2b350c605148f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c5dfcc218832f26e7ecefa6c44a2b350c605148f/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/33d16dd987d16fe1eb289853e5a444192bb31d9e"
    }
  ],
  "stats": {
    "total": 560,
    "additions": 301,
    "deletions": 259
  },
  "files": [
    {
      "sha": "87c8a13789e1171dcdf4457597cef95d09ec1ebb",
      "filename": "gdb/testsuite/lib/dwarf.exp",
      "status": "modified",
      "additions": 287,
      "deletions": 254,
      "changes": 541,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c5dfcc218832f26e7ecefa6c44a2b350c605148f/gdb/testsuite/lib/dwarf.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c5dfcc218832f26e7ecefa6c44a2b350c605148f/gdb/testsuite/lib/dwarf.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/dwarf.exp?ref=c5dfcc218832f26e7ecefa6c44a2b350c605148f",
      "patch": "@@ -1593,137 +1593,150 @@ namespace eval Dwarf {\n \t    return \".Lrnglists_table_${_debug_rnglists_table_count}_list_${list_idx}\"\n \t}\n \n-\t# Generate one table (header + offset array + range lists).\n-\t#\n-\t# Accepts one positional argument, BODY.  BODY may call the LIST_\n-\t# procedure to generate rnglists.\n-\t#\n-\t# The -post-header-label option can be used to define a label just after\n-\t# the header of the table.  This is the label that a DW_AT_rnglists_base\n-\t# attribute will usually refer to.\n-\t#\n-\t# The `-with-offset-array true|false` option can be used to control\n-\t# whether the headers of the location list tables have an array of\n-\t# offset.  The default is true.\n-\n-\tproc table { args } {\n-\t    variable _debug_rnglists_table_count\n-\t    variable _debug_rnglists_addr_size\n-\t    variable _debug_rnglists_offset_size\n-\t    variable _debug_rnglists_is_64_dwarf\n+\twith_override Dwarf::table Dwarf::_rnglists_table {\n+\t    uplevel $body\n+\t}\n+    }\n \n-\t    parse_args {\n-\t\t{post-header-label \"\"}\n-\t\t{with-offset-array true}\n-\t    }\n+    # Generate one rnglists table (header + offset array + range lists).\n+    #\n+    # This proc is meant to be used within proc rnglists' body.  It is made\n+    # available as `table` while inside proc rnglists' body.\n+    #\n+    # Accepts one positional argument, BODY.  BODY may call the LIST_ procedure\n+    # to generate rnglists.\n+    #\n+    # The -post-header-label option can be used to define a label just after\n+    # the header of the table.  This is the label that a DW_AT_rnglists_base\n+    # attribute will usually refer to.\n+    #\n+    # The `-with-offset-array true|false` option can be used to control whether\n+    # the headers of the location list tables have an array of offset.  The\n+    # default is true.\n \n-\t    if { [llength $args] != 1 } {\n-\t\terror \"table proc expects one positional argument (body)\"\n-\t    }\n+    proc _rnglists_table { args } {\n+\tvariable _debug_rnglists_table_count\n+\tvariable _debug_rnglists_addr_size\n+\tvariable _debug_rnglists_offset_size\n+\tvariable _debug_rnglists_is_64_dwarf\n \n-\t    lassign $args body\n+\tparse_args {\n+\t    {post-header-label \"\"}\n+\t    {with-offset-array true}\n+\t}\n \n-\t    # Generate one range list.\n-\t    #\n-\t    # BODY may call the various procs defined below to generate list entries.\n-\t    # They correspond to the range list entry kinds described in section 2.17.3\n-\t    # of the DWARF 5 spec.\n-\t    #\n-\t    # To define a label pointing to the beginning of the list, use\n-\t    # the conventional way of declaring and defining labels:\n-\t    #\n-\t    #   declare_labels the_list\n-\t    #\n-\t    #   the_list: list_ {\n-\t    #     ...\n-\t    #   }\n+\tif { [llength $args] != 1 } {\n+\t    error \"table proc expects one positional argument (body)\"\n+\t}\n \n-\t    proc list_ { body } {\n-\t\tvariable _debug_rnglists_list_count\n+\tlassign $args body\n \n-\t\t# Define a label for this list.  It is used to build the offset\n-\t\t# array later.\n-\t\tset list_label [_compute_list_label $_debug_rnglists_list_count]\n-\t\tdefine_label $list_label\n+\t# Count of lists in the table.\n+\tvariable _debug_rnglists_list_count 0\n \n-\t\t# Emit a DW_RLE_start_end entry.\n+\t# Generate the lists ops first, because we need to know how many\n+\t# lists there are to generate the header and offset table.\n+\tset lists_ops [_defer_to_string {\n+\t    with_override Dwarf::list_ Dwarf::_rnglists_list {\n+\t\tuplevel $body\n+\t    }\n+\t}]\n \n-\t\tproc start_end { start end } {\n-\t\t    variable _debug_rnglists_addr_size\n+\tset post_unit_len_label \\\n+\t    [_compute_label \"rnglists_table_${_debug_rnglists_table_count}_post_unit_len\"]\n+\tset post_header_label \\\n+\t    [_compute_label \"rnglists_table_${_debug_rnglists_table_count}_post_header\"]\n+\tset table_end_label \\\n+\t    [_compute_label \"rnglists_table_${_debug_rnglists_table_count}_end\"]\n \n-\t\t    _op .byte 0x06 \"DW_RLE_start_end\"\n-\t\t    _op .${_debug_rnglists_addr_size}byte $start \"start\"\n-\t\t    _op .${_debug_rnglists_addr_size}byte $end \"end\"\n-\t\t}\n+\t# Emit the table header.\n+\tif { $_debug_rnglists_is_64_dwarf } {\n+\t    _op .4byte 0xffffffff \"unit length 1/2\"\n+\t    _op .8byte \"$table_end_label - $post_unit_len_label\" \"unit length 2/2\"\n+\t} else {\n+\t    _op .4byte \"$table_end_label - $post_unit_len_label\" \"unit length\"\n+\t}\n \n-\t\tuplevel $body\n+\tdefine_label $post_unit_len_label\n \n-\t\t# Emit end of list.\n-\t\t_op .byte 0x00 \"DW_RLE_end_of_list\"\n+\t_op .2byte 5 \"dwarf version\"\n+\t_op .byte $_debug_rnglists_addr_size \"address size\"\n+\t_op .byte 0 \"segment selector size\"\n \n-\t\tincr _debug_rnglists_list_count\n-\t    }\n+\tif { ${with-offset-array} } {\n+\t  _op .4byte \"$_debug_rnglists_list_count\" \"offset entry count\"\n+\t} else {\n+\t  _op .4byte 0 \"offset entry count\"\n+\t}\n \n-\t    # Count of lists in the table.\n-\t    variable _debug_rnglists_list_count 0\n+\tdefine_label $post_header_label\n \n-\t    # Generate the lists ops first, because we need to know how many\n-\t    # lists there are to generate the header and offset table.\n-\t    set lists_ops [_defer_to_string {\n-\t\tuplevel $body\n-\t    }]\n-\n-\t    set post_unit_len_label \\\n-\t\t[_compute_label \"rnglists_table_${_debug_rnglists_table_count}_post_unit_len\"]\n-\t    set post_header_label \\\n-\t\t[_compute_label \"rnglists_table_${_debug_rnglists_table_count}_post_header\"]\n-\t    set table_end_label \\\n-\t\t[_compute_label \"rnglists_table_${_debug_rnglists_table_count}_end\"]\n-\n-\t    # Emit the table header.\n-\t    if { $_debug_rnglists_is_64_dwarf } {\n-\t\t_op .4byte 0xffffffff \"unit length 1/2\"\n-\t\t_op .8byte \"$table_end_label - $post_unit_len_label\" \"unit length 2/2\"\n-\t    } else {\n-\t\t_op .4byte \"$table_end_label - $post_unit_len_label\" \"unit length\"\n+\t# Define the user post-header label, if provided.\n+\tif { ${post-header-label} != \"\" } {\n+\t    define_label ${post-header-label}\n+\t}\n+\n+\t# Emit the offset array.\n+\tif { ${with-offset-array} } {\n+\t    for {set list_idx 0} {$list_idx < $_debug_rnglists_list_count} {incr list_idx} {\n+\t\tset list_label [_compute_list_label $list_idx]\n+\t\t_op .${_debug_rnglists_offset_size}byte \"$list_label - $post_header_label\" \"offset of list $list_idx\"\n \t    }\n+\t}\n \n-\t    define_label $post_unit_len_label\n+\t# Emit the actual list data.\n+\t_emit \"$lists_ops\"\n \n-\t    _op .2byte 5 \"dwarf version\"\n-\t    _op .byte $_debug_rnglists_addr_size \"address size\"\n-\t    _op .byte 0 \"segment selector size\"\n+\tdefine_label $table_end_label\n \n-\t    if { ${with-offset-array} } {\n-\t      _op .4byte \"$_debug_rnglists_list_count\" \"offset entry count\"\n-\t    } else {\n-\t      _op .4byte 0 \"offset entry count\"\n-\t    }\n+\tincr _debug_rnglists_table_count\n+    }\n \n-\t    define_label $post_header_label\n+    # Generate one rnglists range list.\n+    #\n+    # This proc is meant to be used within proc _rnglists_table's body.  It is\n+    # made available as `list_` while inside proc _rnglists_table's body.\n+    #\n+    # BODY may call the various procs defined below to generate list entries.\n+    # They correspond to the range list entry kinds described in section 2.17.3\n+    # of the DWARF 5 spec.\n+    #\n+    # To define a label pointing to the beginning of the list, use the\n+    # conventional way of declaring and defining labels:\n+    #\n+    #   declare_labels the_list\n+    #\n+    #   the_list: list_ { ...  }\n \n-\t    # Define the user post-header label, if provided.\n-\t    if { ${post-header-label} != \"\" } {\n-\t\tdefine_label ${post-header-label}\n-\t    }\n+    proc _rnglists_list { body } {\n+\tvariable _debug_rnglists_list_count\n \n-\t    # Emit the offset array.\n-\t    if { ${with-offset-array} } {\n-\t\tfor {set list_idx 0} {$list_idx < $_debug_rnglists_list_count} {incr list_idx} {\n-\t\t    set list_label [_compute_list_label $list_idx]\n-\t\t    _op .${_debug_rnglists_offset_size}byte \"$list_label - $post_header_label\" \"offset of list $list_idx\"\n-\t\t}\n-\t    }\n+\t# Define a label for this list.  It is used to build the offset\n+\t# array later.\n+\tset list_label [_compute_list_label $_debug_rnglists_list_count]\n+\tdefine_label $list_label\n \n-\t    # Emit the actual list data.\n-\t    _emit \"$lists_ops\"\n+\twith_override Dwarf::start_end Dwarf::_rnglists_start_end {\n+\t    uplevel $body\n+\t}\n \n-\t    define_label $table_end_label\n+\t# Emit end of list.\n+\t_op .byte 0x00 \"DW_RLE_end_of_list\"\n \n-\t    incr _debug_rnglists_table_count\n-\t}\n+\tincr _debug_rnglists_list_count\n+    }\n \n-\tuplevel $body\n+    # Emit a rnglists DW_RLE_start_end entry.\n+    #\n+    # This proc is meant to be used within proc _rnglists_list's body.  It is\n+    # made available as `start_end` while inside proc _rnglists_list's body.\n+\n+    proc _rnglists_start_end { start end } {\n+\tvariable _debug_rnglists_addr_size\n+\n+\t_op .byte 0x06 \"DW_RLE_start_end\"\n+\t_op .${_debug_rnglists_addr_size}byte $start \"start\"\n+\t_op .${_debug_rnglists_addr_size}byte $end \"end\"\n     }\n \n     # Emit a DWARF .debug_loclists section.\n@@ -1780,192 +1793,212 @@ namespace eval Dwarf {\n \t    return \".Lloclists_table_${_debug_loclists_table_count}_list_${list_idx}\"\n \t}\n \n-\t# Generate one table (header + offset array + location lists).\n-\t#\n-\t# Accepts one position argument, BODY.  BODY may call the LIST_\n-\t# procedure to generate loclists.\n-\t#\n-\t# The -post-header-label option can be used to define a label just after the\n-\t# header of the table.  This is the label that a DW_AT_loclists_base\n-\t# attribute will usually refer to.\n-\t#\n-\t# The `-with-offset-array true|false` option can be used to control\n-\t# whether the headers of the location list tables have an array of\n-\t# offset.  The default is true.\n-\n-\tproc table { args } {\n-\t    variable _debug_loclists_table_count\n-\t    variable _debug_loclists_addr_size\n-\t    variable _debug_loclists_offset_size\n-\t    variable _debug_loclists_is_64_dwarf\n+\twith_override Dwarf::table Dwarf::_loclists_table {\n+\t    uplevel $body\n+\t}\n+    }\n \n-\t    parse_args {\n-\t\t{post-header-label \"\"}\n-\t\t{with-offset-array true}\n-\t    }\n+    # Generate one loclists table (header + offset array + location lists).\n+    #\n+    # This proc is meant to be used within proc loclists' body.  It is made\n+    # available as `table` while inside proc rnglists' body.\n+    #\n+    # Accepts one position argument, BODY.  BODY may call the LIST_\n+    # procedure to generate loclists.\n+    #\n+    # The -post-header-label option can be used to define a label just after the\n+    # header of the table.  This is the label that a DW_AT_loclists_base\n+    # attribute will usually refer to.\n+    #\n+    # The `-with-offset-array true|false` option can be used to control\n+    # whether the headers of the location list tables have an array of\n+    # offset.  The default is true.\n \n-\t    if { [llength $args] != 1 } {\n-\t\terror \"table proc expects one positional argument (body)\"\n-\t    }\n+    proc _loclists_table { args } {\n+\tvariable _debug_loclists_table_count\n+\tvariable _debug_loclists_addr_size\n+\tvariable _debug_loclists_offset_size\n+\tvariable _debug_loclists_is_64_dwarf\n+\n+\tparse_args {\n+\t    {post-header-label \"\"}\n+\t    {with-offset-array true}\n+\t}\n+\n+\tif { [llength $args] != 1 } {\n+\t    error \"table proc expects one positional argument (body)\"\n+\t}\n+\n+\tlassign $args body\n \n-\t    lassign $args body\n \n-\t    # Generate one location list.\n-\t    #\n-\t    # BODY may call the various procs defined below to generate list\n-\t    # entries.  They correspond to the location list entry kinds\n-\t    # described in section 2.6.2 of the DWARF 5 spec.\n-\t    #\n-\t    # To define a label pointing to the beginning of the list, use\n-\t    # the conventional way of declaring and defining labels:\n-\t    #\n-\t    #   declare_labels the_list\n-\t    #\n-\t    #   the_list: list_ {\n-\t    #     ...\n-\t    #   }\n+\t# Count of lists in the table.\n+\tvariable _debug_loclists_list_count 0\n \n-\t    proc list_ { body } {\n-\t\tvariable _debug_loclists_list_count\n+\t# Generate the lists ops first, because we need to know how many\n+\t# lists there are to generate the header and offset table.\n+\tset lists_ops [_defer_to_string {\n+\t    with_override Dwarf::list_ Dwarf::_loclists_list {\n+\t\tuplevel $body\n+\t    }\n+\t}]\n \n-\t\t# Count the location descriptions in this list.\n-\t\tvariable _debug_loclists_locdesc_count 0\n+\tset post_unit_len_label \\\n+\t    [_compute_label \"loclists_table_${_debug_loclists_table_count}_post_unit_len\"]\n+\tset post_header_label \\\n+\t    [_compute_label \"loclists_table_${_debug_loclists_table_count}_post_header\"]\n+\tset table_end_label \\\n+\t    [_compute_label \"loclists_table_${_debug_loclists_table_count}_end\"]\n \n-\t\t# Define a label for this list.  It is used to build the offset\n-\t\t# array later.\n-\t\tset list_label [_compute_list_label $_debug_loclists_list_count]\n-\t\tdefine_label $list_label\n+\t# Emit the table header.\n+\tif { $_debug_loclists_is_64_dwarf } {\n+\t    _op .4byte 0xffffffff \"unit length 1/2\"\n+\t    _op .8byte \"$table_end_label - $post_unit_len_label\" \"unit length 2/2\"\n+\t} else {\n+\t    _op .4byte \"$table_end_label - $post_unit_len_label\" \"unit length\"\n+\t}\n+\n+\tdefine_label $post_unit_len_label\n \n-\t\t# Emit a DW_LLE_start_length entry.\n+\t_op .2byte 5 \"DWARF version\"\n+\t_op .byte $_debug_loclists_addr_size \"address size\"\n+\t_op .byte 0 \"segment selector size\"\n \n-\t\tproc start_length { start length locdesc } {\n-\t\t    variable _debug_loclists_is_64_dwarf\n-\t\t    variable _debug_loclists_addr_size\n-\t\t    variable _debug_loclists_offset_size\n-\t\t    variable _debug_loclists_table_count\n-\t\t    variable _debug_loclists_list_count\n-\t\t    variable _debug_loclists_locdesc_count\n+\tif { ${with-offset-array} } {\n+\t  _op .4byte \"$_debug_loclists_list_count\" \"offset entry count\"\n+\t} else {\n+\t  _op .4byte 0 \"offset entry count\"\n+\t}\n \n-\t\t    set locdesc [uplevel [list subst $locdesc]]\n+\tdefine_label $post_header_label\n \n-\t\t    _op .byte 0x08 \"DW_LLE_start_length\"\n+\t# Define the user post-header label, if provided.\n+\tif { ${post-header-label} != \"\" } {\n+\t    define_label ${post-header-label}\n+\t}\n \n-\t\t    # Start and end of the address range.\n-\t\t    _op .${_debug_loclists_addr_size}byte $start \"start\"\n-\t\t    _op .uleb128 $length \"length\"\n+\t# Emit the offset array.\n+\tif { ${with-offset-array} } {\n+\t    for {set list_idx 0} {$list_idx < $_debug_loclists_list_count} {incr list_idx} {\n+\t\tset list_label [_compute_list_label $list_idx]\n+\t\t_op .${_debug_loclists_offset_size}byte \"$list_label - $post_header_label\" \"offset of list $list_idx\"\n+\t    }\n+\t}\n \n-\t\t    # Length of location description.\n-\t\t    set locdesc_start_label \".Lloclists_table_${_debug_loclists_table_count}_list_${_debug_loclists_list_count}_locdesc_${_debug_loclists_locdesc_count}_start\"\n-\t\t    set locdesc_end_label \".Lloclists_table_${_debug_loclists_table_count}_list_${_debug_loclists_list_count}_locdesc_${_debug_loclists_locdesc_count}_end\"\n-\t\t    _op .uleb128 \"$locdesc_end_label - $locdesc_start_label\" \"locdesc length\"\n+\t# Emit the actual list data.\n+\t_emit \"$lists_ops\"\n \n-\t\t    define_label $locdesc_start_label\n-\t\t    set dwarf_version 5\n-\t\t    _location $locdesc $dwarf_version $_debug_loclists_addr_size $_debug_loclists_offset_size\n-\t\t    define_label $locdesc_end_label\n+\tdefine_label $table_end_label\n \n-\t\t    incr _debug_loclists_locdesc_count\n-\t\t}\n+\tincr _debug_loclists_table_count\n+    }\n \n-\t\t# Emit a DW_LLE_start_end entry.\n+    # Generate one loclists location list.\n+    #\n+    # This proc is meant to be used within proc _loclists_table's body.  It is\n+    # made available as `list_` while inside proc _loclists_table's body.\n+    #\n+    # BODY may call the various procs defined below to generate list\n+    # entries.  They correspond to the location list entry kinds\n+    # described in section 2.6.2 of the DWARF 5 spec.\n+    #\n+    # To define a label pointing to the beginning of the list, use\n+    # the conventional way of declaring and defining labels:\n+    #\n+    #   declare_labels the_list\n+    #\n+    #   the_list: list_ {\n+    #     ...\n+    #   }\n \n-\t\tproc start_end { start end locdesc } {\n-\t\t    variable _debug_loclists_is_64_dwarf\n-\t\t    variable _debug_loclists_addr_size\n-\t\t    variable _debug_loclists_offset_size\n-\t\t    variable _debug_loclists_table_count\n-\t\t    variable _debug_loclists_list_count\n-\t\t    variable _debug_loclists_locdesc_count\n+    proc _loclists_list { body } {\n+\tvariable _debug_loclists_list_count\n \n-\t\t    set locdesc [uplevel [list subst $locdesc]]\n+\t# Count the location descriptions in this list.\n+\tvariable _debug_loclists_locdesc_count 0\n \n-\t\t    _op .byte 0x07 \"DW_LLE_start_end\"\n+\t# Define a label for this list.  It is used to build the offset\n+\t# array later.\n+\tset list_label [_compute_list_label $_debug_loclists_list_count]\n+\tdefine_label $list_label\n \n-\t\t    # Start and end of the address range.\n-\t\t    _op .${_debug_loclists_addr_size}byte $start \"start\"\n-\t\t    _op .${_debug_loclists_addr_size}byte $end \"end\"\n+\twith_override Dwarf::start_length Dwarf::_loclists_start_length {\n+\twith_override Dwarf::start_end Dwarf::_loclists_start_end {\n+\t    uplevel $body\n+\t}}\n \n-\t\t    # Length of location description.\n-\t\t    set locdesc_start_label \".Lloclists_table_${_debug_loclists_table_count}_list_${_debug_loclists_list_count}_locdesc_${_debug_loclists_locdesc_count}_start\"\n-\t\t    set locdesc_end_label \".Lloclists_table_${_debug_loclists_table_count}_list_${_debug_loclists_list_count}_locdesc_${_debug_loclists_locdesc_count}_end\"\n-\t\t    _op .uleb128 \"$locdesc_end_label - $locdesc_start_label\" \"locdesc length\"\n+\t# Emit end of list.\n+\t_op .byte 0x00 \"DW_LLE_end_of_list\"\n \n-\t\t    define_label $locdesc_start_label\n-\t\t    set dwarf_version 5\n-\t\t    _location $locdesc $dwarf_version $_debug_loclists_addr_size $_debug_loclists_offset_size\n-\t\t    define_label $locdesc_end_label\n+\tincr _debug_loclists_list_count\n+    }\n \n-\t\t    incr _debug_loclists_locdesc_count\n-\t\t}\n+    # Emit a DW_LLE_start_length entry.\n+    #\n+    # This proc is meant to be used within proc _loclists_list's body.  It is\n+    # made available as `start_length` while inside proc _loclists_list's body.\n \n-\t\tuplevel $body\n+    proc _loclists_start_length { start length locdesc } {\n+\tvariable _debug_loclists_is_64_dwarf\n+\tvariable _debug_loclists_addr_size\n+\tvariable _debug_loclists_offset_size\n+\tvariable _debug_loclists_table_count\n+\tvariable _debug_loclists_list_count\n+\tvariable _debug_loclists_locdesc_count\n \n-\t\t# Emit end of list.\n-\t\t_op .byte 0x00 \"DW_LLE_end_of_list\"\n+\tset locdesc [uplevel [list subst $locdesc]]\n \n-\t\tincr _debug_loclists_list_count\n-\t    }\n+\t_op .byte 0x08 \"DW_LLE_start_length\"\n \n-\t    # Count of lists in the table.\n-\t    variable _debug_loclists_list_count 0\n+\t# Start and end of the address range.\n+\t_op .${_debug_loclists_addr_size}byte $start \"start\"\n+\t_op .uleb128 $length \"length\"\n \n-\t    # Generate the lists ops first, because we need to know how many\n-\t    # lists there are to generate the header and offset table.\n-\t    set lists_ops [_defer_to_string {\n-\t\tuplevel $body\n-\t    }]\n-\n-\t    set post_unit_len_label \\\n-\t\t[_compute_label \"loclists_table_${_debug_loclists_table_count}_post_unit_len\"]\n-\t    set post_header_label \\\n-\t\t[_compute_label \"loclists_table_${_debug_loclists_table_count}_post_header\"]\n-\t    set table_end_label \\\n-\t\t[_compute_label \"loclists_table_${_debug_loclists_table_count}_end\"]\n-\n-\t    # Emit the table header.\n-\t    if { $_debug_loclists_is_64_dwarf } {\n-\t\t_op .4byte 0xffffffff \"unit length 1/2\"\n-\t\t_op .8byte \"$table_end_label - $post_unit_len_label\" \"unit length 2/2\"\n-\t    } else {\n-\t\t_op .4byte \"$table_end_label - $post_unit_len_label\" \"unit length\"\n-\t    }\n+\t# Length of location description.\n+\tset locdesc_start_label \".Lloclists_table_${_debug_loclists_table_count}_list_${_debug_loclists_list_count}_locdesc_${_debug_loclists_locdesc_count}_start\"\n+\tset locdesc_end_label \".Lloclists_table_${_debug_loclists_table_count}_list_${_debug_loclists_list_count}_locdesc_${_debug_loclists_locdesc_count}_end\"\n+\t_op .uleb128 \"$locdesc_end_label - $locdesc_start_label\" \"locdesc length\"\n \n-\t    define_label $post_unit_len_label\n+\tdefine_label $locdesc_start_label\n+\tset dwarf_version 5\n+\t_location $locdesc $dwarf_version $_debug_loclists_addr_size $_debug_loclists_offset_size\n+\tdefine_label $locdesc_end_label\n \n-\t    _op .2byte 5 \"DWARF version\"\n-\t    _op .byte $_debug_loclists_addr_size \"address size\"\n-\t    _op .byte 0 \"segment selector size\"\n+\tincr _debug_loclists_locdesc_count\n+    }\n \n-\t    if { ${with-offset-array} } {\n-\t      _op .4byte \"$_debug_loclists_list_count\" \"offset entry count\"\n-\t    } else {\n-\t      _op .4byte 0 \"offset entry count\"\n-\t    }\n+    # Emit a DW_LLE_start_end entry.\n+    #\n+    # This proc is meant to be used within proc _loclists_list's body.  It is\n+    # made available as `start_end` while inside proc _loclists_list's body.\n \n-\t    define_label $post_header_label\n+    proc _loclists_start_end { start end locdesc } {\n+\tvariable _debug_loclists_is_64_dwarf\n+\tvariable _debug_loclists_addr_size\n+\tvariable _debug_loclists_offset_size\n+\tvariable _debug_loclists_table_count\n+\tvariable _debug_loclists_list_count\n+\tvariable _debug_loclists_locdesc_count\n \n-\t    # Define the user post-header label, if provided.\n-\t    if { ${post-header-label} != \"\" } {\n-\t\tdefine_label ${post-header-label}\n-\t    }\n+\tset locdesc [uplevel [list subst $locdesc]]\n \n-\t    # Emit the offset array.\n-\t    if { ${with-offset-array} } {\n-\t\tfor {set list_idx 0} {$list_idx < $_debug_loclists_list_count} {incr list_idx} {\n-\t\t    set list_label [_compute_list_label $list_idx]\n-\t\t    _op .${_debug_loclists_offset_size}byte \"$list_label - $post_header_label\" \"offset of list $list_idx\"\n-\t\t}\n-\t    }\n+\t_op .byte 0x07 \"DW_LLE_start_end\"\n \n-\t    # Emit the actual list data.\n-\t    _emit \"$lists_ops\"\n+\t# Start and end of the address range.\n+\t_op .${_debug_loclists_addr_size}byte $start \"start\"\n+\t_op .${_debug_loclists_addr_size}byte $end \"end\"\n \n-\t    define_label $table_end_label\n+\t# Length of location description.\n+\tset locdesc_start_label \".Lloclists_table_${_debug_loclists_table_count}_list_${_debug_loclists_list_count}_locdesc_${_debug_loclists_locdesc_count}_start\"\n+\tset locdesc_end_label \".Lloclists_table_${_debug_loclists_table_count}_list_${_debug_loclists_list_count}_locdesc_${_debug_loclists_locdesc_count}_end\"\n+\t_op .uleb128 \"$locdesc_end_label - $locdesc_start_label\" \"locdesc length\"\n \n-\t    incr _debug_loclists_table_count\n-\t}\n+\tdefine_label $locdesc_start_label\n+\tset dwarf_version 5\n+\t_location $locdesc $dwarf_version $_debug_loclists_addr_size $_debug_loclists_offset_size\n+\tdefine_label $locdesc_end_label\n \n-\tuplevel $body\n+\tincr _debug_loclists_locdesc_count\n     }\n \n     # Emit a DWARF .debug_line unit."
    },
    {
      "sha": "5642db4334dbf6b09661bda5406c659569497a9d",
      "filename": "gdb/testsuite/lib/gdb.exp",
      "status": "modified",
      "additions": 14,
      "deletions": 5,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c5dfcc218832f26e7ecefa6c44a2b350c605148f/gdb/testsuite/lib/gdb.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c5dfcc218832f26e7ecefa6c44a2b350c605148f/gdb/testsuite/lib/gdb.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/lib/gdb.exp?ref=c5dfcc218832f26e7ecefa6c44a2b350c605148f",
      "patch": "@@ -8017,9 +8017,14 @@ proc with_override { name override body } {\n     #   the override\n     # So, we use this more elaborate but cleaner mechanism.\n \n-    # Save the old proc.\n-    set old_args [info args $name]\n-    set old_body [info body $name]\n+    # Save the old proc, if it exists.\n+    if { [info procs $name] != \"\" } {\n+\tset old_args [info args $name]\n+\tset old_body [info body $name]\n+\tset existed true\n+    } else {\n+\tset existed false\n+    }\n \n     # Install the override.\n     set new_args [info args $override]\n@@ -8029,8 +8034,12 @@ proc with_override { name override body } {\n     # Execute body.\n     set code [catch {uplevel 1 $body} result]\n \n-    # Restore old proc.\n-    eval proc $name {$old_args} {$old_body}\n+    # Restore old proc if it existed on entry, else delete it.\n+    if { $existed } {\n+\teval proc $name {$old_args} {$old_body}\n+    } else {\n+\trename $name \"\"\n+    }\n \n     # Return as appropriate.\n     if { $code == 1 } {"
    }
  ]
}