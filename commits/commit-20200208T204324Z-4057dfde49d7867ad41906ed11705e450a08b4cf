{
  "sha": "4057dfde49d7867ad41906ed11705e450a08b4cf",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDA1N2RmZGU0OWQ3ODY3YWQ0MTkwNmVkMTE3MDVlNDUwYTA4YjRjZg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:40:54Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-08T20:43:24Z"
    },
    "message": "Create dwarf2/comp-unit.[ch]\n\nThis creates the new files dwarf2/comp-unit.[ch], moving\ncomp_unit_head and helpers to those files.  A couple of functions are\nturned into methods, because it was convenient to do so now.\n\n2020-02-08  Tom Tromey  <tom@tromey.com>\n\n\t* Makefile.in (COMMON_SFILES): Add dwarf2/comp-unit.c.\n\t* dwarf2/read.c (struct comp_unit_head): Move to\n\tdwarf2/comp-unit.h.\n\t(enum class rcuh_kind): Move to comp-unit.h.\n\t(get_cu_length, offset_in_cu_p): Now methods on comp_unit_head.\n\t(read_comp_unit_head, error_check_comp_unit_head)\n\t(read_and_check_comp_unit_head): Move to comp-unit.c.\n\t(read_offset, dwarf_unit_type_name): Likewise.\n\t(create_debug_type_hash_table, read_cutu_die_from_dwo)\n\t(cutu_reader::cutu_reader, read_call_site_scope)\n\t(find_partial_die, follow_die_offset): Update.\n\t* dwarf2/comp-unit.h: New file, from dwarf2read.c.\n\nChange-Id: Id961b9674c0081ed061083c8152c38b27b27388a",
    "tree": {
      "sha": "dadd9020aab5e5e543faf9873cbaf6bc8bb6ab0c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/dadd9020aab5e5e543faf9873cbaf6bc8bb6ab0c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4057dfde49d7867ad41906ed11705e450a08b4cf",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4057dfde49d7867ad41906ed11705e450a08b4cf",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4057dfde49d7867ad41906ed11705e450a08b4cf",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4057dfde49d7867ad41906ed11705e450a08b4cf/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "24aa364d607c1f5845b1ff200f385d11ebba7e02",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24aa364d607c1f5845b1ff200f385d11ebba7e02",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/24aa364d607c1f5845b1ff200f385d11ebba7e02"
    }
  ],
  "stats": {
    "total": 671,
    "additions": 378,
    "deletions": 293
  },
  "files": [
    {
      "sha": "c38bcae9d399b8a039d5e5b5f53f2dbe0c4a727b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4057dfde49d7867ad41906ed11705e450a08b4cf",
      "patch": "@@ -1,3 +1,18 @@\n+2020-02-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* Makefile.in (COMMON_SFILES): Add dwarf2/comp-unit.c.\n+\t* dwarf2/read.c (struct comp_unit_head): Move to\n+\tdwarf2/comp-unit.h.\n+\t(enum class rcuh_kind): Move to comp-unit.h.\n+\t(get_cu_length, offset_in_cu_p): Now methods on comp_unit_head.\n+\t(read_comp_unit_head, error_check_comp_unit_head)\n+\t(read_and_check_comp_unit_head): Move to comp-unit.c.\n+\t(read_offset, dwarf_unit_type_name): Likewise.\n+\t(create_debug_type_hash_table, read_cutu_die_from_dwo)\n+\t(cutu_reader::cutu_reader, read_call_site_scope)\n+\t(find_partial_die, follow_die_offset): Update.\n+\t* dwarf2/comp-unit.h: New file, from dwarf2read.c.\n+\n 2020-02-08  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (read_offset_1): Move to leb.c."
    },
    {
      "sha": "8870728c6609022b281dbdda68cb139840f33d5b",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=4057dfde49d7867ad41906ed11705e450a08b4cf",
      "patch": "@@ -996,6 +996,7 @@ COMMON_SFILES = \\\n \tdummy-frame.c \\\n \tdwarf2/abbrev.c \\\n \tdwarf2/attribute.c \\\n+\tdwarf2/comp-unit.c \\\n \tdwarf2/expr.c \\\n \tdwarf2/frame-tailcall.c \\\n \tdwarf2/frame.c \\"
    },
    {
      "sha": "03e804b7086b72f705e035edb4c6408905034e65",
      "filename": "gdb/dwarf2/comp-unit.c",
      "status": "added",
      "additions": 237,
      "deletions": 0,
      "changes": 237,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/dwarf2/comp-unit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/dwarf2/comp-unit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/comp-unit.c?ref=4057dfde49d7867ad41906ed11705e450a08b4cf",
      "patch": "@@ -0,0 +1,237 @@\n+/* DWARF 2 debugging format support for GDB.\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"dwarf2/comp-unit.h\"\n+#include \"dwarf2/leb.h\"\n+#include \"dwarf2/read.h\"\n+#include \"dwarf2/section.h\"\n+\n+/* Convert a unit type to corresponding DW_UT name.  */\n+\n+static const char *\n+dwarf_unit_type_name (int unit_type)\n+{\n+  switch (unit_type)\n+    {\n+      case 0x01:\n+\treturn \"DW_UT_compile (0x01)\";\n+      case 0x02:\n+\treturn \"DW_UT_type (0x02)\";\n+      case 0x03:\n+\treturn \"DW_UT_partial (0x03)\";\n+      case 0x04:\n+\treturn \"DW_UT_skeleton (0x04)\";\n+      case 0x05:\n+\treturn \"DW_UT_split_compile (0x05)\";\n+      case 0x06:\n+\treturn \"DW_UT_split_type (0x06)\";\n+      case 0x80:\n+\treturn \"DW_UT_lo_user (0x80)\";\n+      case 0xff:\n+\treturn \"DW_UT_hi_user (0xff)\";\n+      default:\n+\treturn nullptr;\n+    }\n+}\n+\n+/* See comp-unit.h.  */\n+\n+const gdb_byte *\n+read_comp_unit_head (struct comp_unit_head *cu_header,\n+\t\t     const gdb_byte *info_ptr,\n+\t\t     struct dwarf2_section_info *section,\n+\t\t     rcuh_kind section_kind)\n+{\n+  int signed_addr;\n+  unsigned int bytes_read;\n+  const char *filename = section->get_file_name ();\n+  bfd *abfd = section->get_bfd_owner ();\n+\n+  cu_header->length = read_initial_length (abfd, info_ptr, &bytes_read);\n+  cu_header->initial_length_size = bytes_read;\n+  cu_header->offset_size = (bytes_read == 4) ? 4 : 8;\n+  info_ptr += bytes_read;\n+  cu_header->version = read_2_bytes (abfd, info_ptr);\n+  if (cu_header->version < 2 || cu_header->version > 5)\n+    error (_(\"Dwarf Error: wrong version in compilation unit header \"\n+\t   \"(is %d, should be 2, 3, 4 or 5) [in module %s]\"),\n+\t   cu_header->version, filename);\n+  info_ptr += 2;\n+  if (cu_header->version < 5)\n+    switch (section_kind)\n+      {\n+      case rcuh_kind::COMPILE:\n+\tcu_header->unit_type = DW_UT_compile;\n+\tbreak;\n+      case rcuh_kind::TYPE:\n+\tcu_header->unit_type = DW_UT_type;\n+\tbreak;\n+      default:\n+\tinternal_error (__FILE__, __LINE__,\n+\t\t\t_(\"read_comp_unit_head: invalid section_kind\"));\n+      }\n+  else\n+    {\n+      cu_header->unit_type = static_cast<enum dwarf_unit_type>\n+\t\t\t\t\t\t (read_1_byte (abfd, info_ptr));\n+      info_ptr += 1;\n+      switch (cu_header->unit_type)\n+\t{\n+\tcase DW_UT_compile:\n+\tcase DW_UT_partial:\n+\tcase DW_UT_skeleton:\n+\tcase DW_UT_split_compile:\n+\t  if (section_kind != rcuh_kind::COMPILE)\n+\t    error (_(\"Dwarf Error: wrong unit_type in compilation unit header \"\n+\t\t   \"(is %s, should be %s) [in module %s]\"),\n+\t\t   dwarf_unit_type_name (cu_header->unit_type),\n+\t\t   dwarf_unit_type_name (DW_UT_type), filename);\n+\t  break;\n+\tcase DW_UT_type:\n+\tcase DW_UT_split_type:\n+\t  section_kind = rcuh_kind::TYPE;\n+\t  break;\n+\tdefault:\n+\t  error (_(\"Dwarf Error: wrong unit_type in compilation unit header \"\n+\t\t \"(is %#04x, should be one of: %s, %s, %s, %s or %s) \"\n+\t\t \"[in module %s]\"), cu_header->unit_type,\n+\t\t dwarf_unit_type_name (DW_UT_compile),\n+\t\t dwarf_unit_type_name (DW_UT_skeleton),\n+\t\t dwarf_unit_type_name (DW_UT_split_compile),\n+\t\t dwarf_unit_type_name (DW_UT_type),\n+\t\t dwarf_unit_type_name (DW_UT_split_type), filename);\n+\t}\n+\n+      cu_header->addr_size = read_1_byte (abfd, info_ptr);\n+      info_ptr += 1;\n+    }\n+  cu_header->abbrev_sect_off = (sect_offset) read_offset (abfd, info_ptr,\n+\t\t\t\t\t\t\t  cu_header,\n+\t\t\t\t\t\t\t  &bytes_read);\n+  info_ptr += bytes_read;\n+  if (cu_header->version < 5)\n+    {\n+      cu_header->addr_size = read_1_byte (abfd, info_ptr);\n+      info_ptr += 1;\n+    }\n+  signed_addr = bfd_get_sign_extend_vma (abfd);\n+  if (signed_addr < 0)\n+    internal_error (__FILE__, __LINE__,\n+\t\t    _(\"read_comp_unit_head: dwarf from non elf file\"));\n+  cu_header->signed_addr_p = signed_addr;\n+\n+  bool header_has_signature = section_kind == rcuh_kind::TYPE\n+    || cu_header->unit_type == DW_UT_skeleton\n+    || cu_header->unit_type == DW_UT_split_compile;\n+\n+  if (header_has_signature)\n+    {\n+      cu_header->signature = read_8_bytes (abfd, info_ptr);\n+      info_ptr += 8;\n+    }\n+\n+  if (section_kind == rcuh_kind::TYPE)\n+    {\n+      LONGEST type_offset;\n+      type_offset = read_offset (abfd, info_ptr, cu_header, &bytes_read);\n+      info_ptr += bytes_read;\n+      cu_header->type_cu_offset_in_tu = (cu_offset) type_offset;\n+      if (to_underlying (cu_header->type_cu_offset_in_tu) != type_offset)\n+\terror (_(\"Dwarf Error: Too big type_offset in compilation unit \"\n+\t       \"header (is %s) [in module %s]\"), plongest (type_offset),\n+\t       filename);\n+    }\n+\n+  return info_ptr;\n+}\n+\n+/* Subroutine of read_and_check_comp_unit_head and\n+   read_and_check_type_unit_head to simplify them.\n+   Perform various error checking on the header.  */\n+\n+static void\n+error_check_comp_unit_head (struct dwarf2_per_objfile *dwarf2_per_objfile,\n+\t\t\t    struct comp_unit_head *header,\n+\t\t\t    struct dwarf2_section_info *section,\n+\t\t\t    struct dwarf2_section_info *abbrev_section)\n+{\n+  const char *filename = section->get_file_name ();\n+\n+  if (to_underlying (header->abbrev_sect_off)\n+      >= abbrev_section->get_size (dwarf2_per_objfile->objfile))\n+    error (_(\"Dwarf Error: bad offset (%s) in compilation unit header \"\n+\t   \"(offset %s + 6) [in module %s]\"),\n+\t   sect_offset_str (header->abbrev_sect_off),\n+\t   sect_offset_str (header->sect_off),\n+\t   filename);\n+\n+  /* Cast to ULONGEST to use 64-bit arithmetic when possible to\n+     avoid potential 32-bit overflow.  */\n+  if (((ULONGEST) header->sect_off + header->get_length ())\n+      > section->size)\n+    error (_(\"Dwarf Error: bad length (0x%x) in compilation unit header \"\n+\t   \"(offset %s + 0) [in module %s]\"),\n+\t   header->length, sect_offset_str (header->sect_off),\n+\t   filename);\n+}\n+\n+/* See comp-unit.h.  */\n+\n+const gdb_byte *\n+read_and_check_comp_unit_head (struct dwarf2_per_objfile *dwarf2_per_objfile,\n+\t\t\t       struct comp_unit_head *header,\n+\t\t\t       struct dwarf2_section_info *section,\n+\t\t\t       struct dwarf2_section_info *abbrev_section,\n+\t\t\t       const gdb_byte *info_ptr,\n+\t\t\t       rcuh_kind section_kind)\n+{\n+  const gdb_byte *beg_of_comp_unit = info_ptr;\n+\n+  header->sect_off = (sect_offset) (beg_of_comp_unit - section->buffer);\n+\n+  info_ptr = read_comp_unit_head (header, info_ptr, section, section_kind);\n+\n+  header->first_die_cu_offset = (cu_offset) (info_ptr - beg_of_comp_unit);\n+\n+  error_check_comp_unit_head (dwarf2_per_objfile, header, section,\n+\t\t\t      abbrev_section);\n+\n+  return info_ptr;\n+}\n+\n+/* See comp-unit.h.  */\n+\n+LONGEST\n+read_offset (bfd *abfd, const gdb_byte *buf,\n+\t     const struct comp_unit_head *cu_header,\n+             unsigned int *bytes_read)\n+{\n+  LONGEST offset = read_offset (abfd, buf, cu_header->offset_size);\n+\n+  *bytes_read = cu_header->offset_size;\n+  return offset;\n+}"
    },
    {
      "sha": "b4483ac1f7acfd3197b7e97c0857ea6a8b44c396",
      "filename": "gdb/dwarf2/comp-unit.h",
      "status": "added",
      "additions": 114,
      "deletions": 0,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/dwarf2/comp-unit.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/dwarf2/comp-unit.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/comp-unit.h?ref=4057dfde49d7867ad41906ed11705e450a08b4cf",
      "patch": "@@ -0,0 +1,114 @@\n+/* Low-level DWARF 2 reading code\n+\n+   Copyright (C) 1994-2020 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDB_DWARF2_COMP_UNIT_H\n+#define GDB_DWARF2_COMP_UNIT_H\n+\n+#include \"gdbtypes.h\"\n+\n+/* The data in a compilation unit header, after target2host\n+   translation, looks like this.  */\n+struct comp_unit_head\n+{\n+  unsigned int length;\n+  short version;\n+  unsigned char addr_size;\n+  unsigned char signed_addr_p;\n+  sect_offset abbrev_sect_off;\n+\n+  /* Size of file offsets; either 4 or 8.  */\n+  unsigned int offset_size;\n+\n+  /* Size of the length field; either 4 or 12.  */\n+  unsigned int initial_length_size;\n+\n+  enum dwarf_unit_type unit_type;\n+\n+  /* Offset to the first byte of this compilation unit header in the\n+     .debug_info section, for resolving relative reference dies.  */\n+  sect_offset sect_off;\n+\n+  /* Offset to first die in this cu from the start of the cu.\n+     This will be the first byte following the compilation unit header.  */\n+  cu_offset first_die_cu_offset;\n+\n+\n+  /* 64-bit signature of this unit. For type units, it denotes the signature of\n+     the type (DW_UT_type in DWARF 4, additionally DW_UT_split_type in DWARF 5).\n+     Also used in DWARF 5, to denote the dwo id when the unit type is\n+     DW_UT_skeleton or DW_UT_split_compile.  */\n+  ULONGEST signature;\n+\n+  /* For types, offset in the type's DIE of the type defined by this TU.  */\n+  cu_offset type_cu_offset_in_tu;\n+\n+  /* Return the total length of the CU described by this header.  */\n+  unsigned int get_length () const\n+  {\n+    return initial_length_size + length;\n+  }\n+\n+  /* Return TRUE if OFF is within this CU.  */\n+  bool offset_in_cu_p (sect_offset off) const\n+  {\n+    sect_offset bottom = sect_off;\n+    sect_offset top = sect_off + get_length ();\n+    return off >= bottom && off < top;\n+  }\n+};\n+\n+/* Expected enum dwarf_unit_type for read_comp_unit_head.  */\n+enum class rcuh_kind { COMPILE, TYPE };\n+\n+/* Read in the comp unit header information from the debug_info at info_ptr.\n+   Use rcuh_kind::COMPILE as the default type if not known by the caller.\n+   NOTE: This leaves members offset, first_die_offset to be filled in\n+   by the caller.  */\n+extern const gdb_byte *read_comp_unit_head\n+  (struct comp_unit_head *cu_header,\n+   const gdb_byte *info_ptr,\n+   struct dwarf2_section_info *section,\n+   rcuh_kind section_kind);\n+\n+/* Read in a CU/TU header and perform some basic error checking.\n+   The contents of the header are stored in HEADER.\n+   The result is a pointer to the start of the first DIE.  */\n+extern const gdb_byte *read_and_check_comp_unit_head\n+  (struct dwarf2_per_objfile *dwarf2_per_objfile,\n+   struct comp_unit_head *header,\n+   struct dwarf2_section_info *section,\n+   struct dwarf2_section_info *abbrev_section,\n+   const gdb_byte *info_ptr,\n+   rcuh_kind section_kind);\n+\n+/* Read an offset from the data stream.  The size of the offset is\n+   given by cu_header->offset_size.  */\n+\n+extern LONGEST read_offset (bfd *abfd, const gdb_byte *buf,\n+\t\t\t    const struct comp_unit_head *cu_header,\n+\t\t\t    unsigned int *bytes_read);\n+\n+#endif /* GDB_DWARF2_COMP_UNIT_H */"
    },
    {
      "sha": "ef72214347f1e44fa40a44dcde60b98acdcdda8d",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 11,
      "deletions": 293,
      "changes": 304,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4057dfde49d7867ad41906ed11705e450a08b4cf/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=4057dfde49d7867ad41906ed11705e450a08b4cf",
      "patch": "@@ -32,6 +32,7 @@\n #include \"dwarf2/read.h\"\n #include \"dwarf2/abbrev.h\"\n #include \"dwarf2/attribute.h\"\n+#include \"dwarf2/comp-unit.h\"\n #include \"dwarf2/index-cache.h\"\n #include \"dwarf2/index-common.h\"\n #include \"dwarf2/leb.h\"\n@@ -340,43 +341,6 @@ dwop_section_names =\n \n /* local data types */\n \n-/* The data in a compilation unit header, after target2host\n-   translation, looks like this.  */\n-struct comp_unit_head\n-{\n-  unsigned int length;\n-  short version;\n-  unsigned char addr_size;\n-  unsigned char signed_addr_p;\n-  sect_offset abbrev_sect_off;\n-\n-  /* Size of file offsets; either 4 or 8.  */\n-  unsigned int offset_size;\n-\n-  /* Size of the length field; either 4 or 12.  */\n-  unsigned int initial_length_size;\n-\n-  enum dwarf_unit_type unit_type;\n-\n-  /* Offset to the first byte of this compilation unit header in the\n-     .debug_info section, for resolving relative reference dies.  */\n-  sect_offset sect_off;\n-\n-  /* Offset to first die in this cu from the start of the cu.\n-     This will be the first byte following the compilation unit header.  */\n-  cu_offset first_die_cu_offset;\n-\n-\n-  /* 64-bit signature of this unit. For type units, it denotes the signature of\n-     the type (DW_UT_type in DWARF 4, additionally DW_UT_split_type in DWARF 5).\n-     Also used in DWARF 5, to denote the dwo id when the unit type is\n-     DW_UT_skeleton or DW_UT_split_compile.  */\n-  ULONGEST signature;\n-\n-  /* For types, offset in the type's DIE of the type defined by this TU.  */\n-  cu_offset type_cu_offset_in_tu;\n-};\n-\n /* Type used for delaying computation of method physnames.\n    See comments for compute_delayed_physnames.  */\n struct delayed_method_info\n@@ -1281,10 +1245,6 @@ static LONGEST read_checked_initial_length_and_offset\n   (bfd *, const gdb_byte *, const struct comp_unit_head *,\n    unsigned int *, unsigned int *);\n \n-static LONGEST read_offset (bfd *, const gdb_byte *,\n-\t\t\t    const struct comp_unit_head *,\n-\t\t\t    unsigned int *);\n-\n static sect_offset read_abbrev_offset\n   (struct dwarf2_per_objfile *dwarf2_per_objfile,\n    struct dwarf2_section_info *, sect_offset);\n@@ -1512,8 +1472,6 @@ static const char *dwarf_tag_name (unsigned int);\n \n static const char *dwarf_attr_name (unsigned int);\n \n-static const char *dwarf_unit_type_name (int unit_type);\n-\n static const char *dwarf_form_name (unsigned int);\n \n static const char *dwarf_bool_name (unsigned int);\n@@ -1697,16 +1655,6 @@ struct file_and_directory\n static file_and_directory find_file_and_directory (struct die_info *die,\n \t\t\t\t\t\t   struct dwarf2_cu *cu);\n \n-/* Expected enum dwarf_unit_type for read_comp_unit_head.  */\n-enum class rcuh_kind { COMPILE, TYPE };\n-\n-static const gdb_byte *read_and_check_comp_unit_head\n-  (struct dwarf2_per_objfile* dwarf2_per_objfile,\n-   struct comp_unit_head *header,\n-   struct dwarf2_section_info *section,\n-   struct dwarf2_section_info *abbrev_section, const gdb_byte *info_ptr,\n-   rcuh_kind section_kind);\n-\n static htab_up allocate_signatured_type_table (struct objfile *objfile);\n \n static htab_up allocate_dwo_unit_table (struct objfile *objfile);\n@@ -5880,25 +5828,6 @@ dwarf2_build_psymtabs (struct objfile *objfile)\n     }\n }\n \n-/* Return the total length of the CU described by HEADER.  */\n-\n-static unsigned int\n-get_cu_length (const struct comp_unit_head *header)\n-{\n-  return header->initial_length_size + header->length;\n-}\n-\n-/* Return TRUE if SECT_OFF is within CU_HEADER.  */\n-\n-static inline bool\n-offset_in_cu_p (const comp_unit_head *cu_header, sect_offset sect_off)\n-{\n-  sect_offset bottom = cu_header->sect_off;\n-  sect_offset top = cu_header->sect_off + get_cu_length (cu_header);\n-\n-  return sect_off >= bottom && sect_off < top;\n-}\n-\n /* Find the base address of the compilation unit for range lists and\n    location lists.  It will normally be specified by DW_AT_low_pc.\n    In DWARF-3 draft 4, the base address could be overridden by\n@@ -5930,120 +5859,6 @@ dwarf2_find_base_address (struct die_info *die, struct dwarf2_cu *cu)\n     }\n }\n \n-/* Read in the comp unit header information from the debug_info at info_ptr.\n-   Use rcuh_kind::COMPILE as the default type if not known by the caller.\n-   NOTE: This leaves members offset, first_die_offset to be filled in\n-   by the caller.  */\n-\n-static const gdb_byte *\n-read_comp_unit_head (struct comp_unit_head *cu_header,\n-\t\t     const gdb_byte *info_ptr,\n-\t\t     struct dwarf2_section_info *section,\n-\t\t     rcuh_kind section_kind)\n-{\n-  int signed_addr;\n-  unsigned int bytes_read;\n-  const char *filename = section->get_file_name ();\n-  bfd *abfd = section->get_bfd_owner ();\n-\n-  cu_header->length = read_initial_length (abfd, info_ptr, &bytes_read);\n-  cu_header->initial_length_size = bytes_read;\n-  cu_header->offset_size = (bytes_read == 4) ? 4 : 8;\n-  info_ptr += bytes_read;\n-  cu_header->version = read_2_bytes (abfd, info_ptr);\n-  if (cu_header->version < 2 || cu_header->version > 5)\n-    error (_(\"Dwarf Error: wrong version in compilation unit header \"\n-\t   \"(is %d, should be 2, 3, 4 or 5) [in module %s]\"),\n-\t   cu_header->version, filename);\n-  info_ptr += 2;\n-  if (cu_header->version < 5)\n-    switch (section_kind)\n-      {\n-      case rcuh_kind::COMPILE:\n-\tcu_header->unit_type = DW_UT_compile;\n-\tbreak;\n-      case rcuh_kind::TYPE:\n-\tcu_header->unit_type = DW_UT_type;\n-\tbreak;\n-      default:\n-\tinternal_error (__FILE__, __LINE__,\n-\t\t\t_(\"read_comp_unit_head: invalid section_kind\"));\n-      }\n-  else\n-    {\n-      cu_header->unit_type = static_cast<enum dwarf_unit_type>\n-\t\t\t\t\t\t (read_1_byte (abfd, info_ptr));\n-      info_ptr += 1;\n-      switch (cu_header->unit_type)\n-\t{\n-\tcase DW_UT_compile:\n-\tcase DW_UT_partial:\n-\tcase DW_UT_skeleton:\n-\tcase DW_UT_split_compile:\n-\t  if (section_kind != rcuh_kind::COMPILE)\n-\t    error (_(\"Dwarf Error: wrong unit_type in compilation unit header \"\n-\t\t   \"(is %s, should be %s) [in module %s]\"),\n-\t\t   dwarf_unit_type_name (cu_header->unit_type),\n-\t\t   dwarf_unit_type_name (DW_UT_type), filename);\n-\t  break;\n-\tcase DW_UT_type:\n-\tcase DW_UT_split_type:\n-\t  section_kind = rcuh_kind::TYPE;\n-\t  break;\n-\tdefault:\n-\t  error (_(\"Dwarf Error: wrong unit_type in compilation unit header \"\n-\t\t \"(is %#04x, should be one of: %s, %s, %s, %s or %s) \"\n-\t\t \"[in module %s]\"), cu_header->unit_type,\n-\t\t dwarf_unit_type_name (DW_UT_compile),\n-\t\t dwarf_unit_type_name (DW_UT_skeleton),\n-\t\t dwarf_unit_type_name (DW_UT_split_compile),\n-\t\t dwarf_unit_type_name (DW_UT_type),\n-\t\t dwarf_unit_type_name (DW_UT_split_type), filename);\n-\t}\n-\n-      cu_header->addr_size = read_1_byte (abfd, info_ptr);\n-      info_ptr += 1;\n-    }\n-  cu_header->abbrev_sect_off = (sect_offset) read_offset (abfd, info_ptr,\n-\t\t\t\t\t\t\t  cu_header,\n-\t\t\t\t\t\t\t  &bytes_read);\n-  info_ptr += bytes_read;\n-  if (cu_header->version < 5)\n-    {\n-      cu_header->addr_size = read_1_byte (abfd, info_ptr);\n-      info_ptr += 1;\n-    }\n-  signed_addr = bfd_get_sign_extend_vma (abfd);\n-  if (signed_addr < 0)\n-    internal_error (__FILE__, __LINE__,\n-\t\t    _(\"read_comp_unit_head: dwarf from non elf file\"));\n-  cu_header->signed_addr_p = signed_addr;\n-\n-  bool header_has_signature = section_kind == rcuh_kind::TYPE\n-    || cu_header->unit_type == DW_UT_skeleton\n-    || cu_header->unit_type == DW_UT_split_compile;\n-\n-  if (header_has_signature)\n-    {\n-      cu_header->signature = read_8_bytes (abfd, info_ptr);\n-      info_ptr += 8;\n-    }\n-\n-  if (section_kind == rcuh_kind::TYPE)\n-    {\n-      LONGEST type_offset;\n-      type_offset = read_offset (abfd, info_ptr, cu_header, &bytes_read);\n-      info_ptr += bytes_read;\n-      cu_header->type_cu_offset_in_tu = (cu_offset) type_offset;\n-      if (to_underlying (cu_header->type_cu_offset_in_tu) != type_offset)\n-\terror (_(\"Dwarf Error: Too big type_offset in compilation unit \"\n-\t       \"header (is %s) [in module %s]\"), plongest (type_offset),\n-\t       filename);\n-    }\n-\n-  return info_ptr;\n-}\n-\n /* Helper function that returns the proper abbrev section for\n    THIS_CU.  */\n \n@@ -6061,62 +5876,6 @@ get_abbrev_section_for_cu (struct dwarf2_per_cu_data *this_cu)\n   return abbrev;\n }\n \n-/* Subroutine of read_and_check_comp_unit_head and\n-   read_and_check_type_unit_head to simplify them.\n-   Perform various error checking on the header.  */\n-\n-static void\n-error_check_comp_unit_head (struct dwarf2_per_objfile *dwarf2_per_objfile,\n-\t\t\t    struct comp_unit_head *header,\n-\t\t\t    struct dwarf2_section_info *section,\n-\t\t\t    struct dwarf2_section_info *abbrev_section)\n-{\n-  const char *filename = section->get_file_name ();\n-\n-  if (to_underlying (header->abbrev_sect_off)\n-      >= abbrev_section->get_size (dwarf2_per_objfile->objfile))\n-    error (_(\"Dwarf Error: bad offset (%s) in compilation unit header \"\n-\t   \"(offset %s + 6) [in module %s]\"),\n-\t   sect_offset_str (header->abbrev_sect_off),\n-\t   sect_offset_str (header->sect_off),\n-\t   filename);\n-\n-  /* Cast to ULONGEST to use 64-bit arithmetic when possible to\n-     avoid potential 32-bit overflow.  */\n-  if (((ULONGEST) header->sect_off + get_cu_length (header))\n-      > section->size)\n-    error (_(\"Dwarf Error: bad length (0x%x) in compilation unit header \"\n-\t   \"(offset %s + 0) [in module %s]\"),\n-\t   header->length, sect_offset_str (header->sect_off),\n-\t   filename);\n-}\n-\n-/* Read in a CU/TU header and perform some basic error checking.\n-   The contents of the header are stored in HEADER.\n-   The result is a pointer to the start of the first DIE.  */\n-\n-static const gdb_byte *\n-read_and_check_comp_unit_head (struct dwarf2_per_objfile *dwarf2_per_objfile,\n-\t\t\t       struct comp_unit_head *header,\n-\t\t\t       struct dwarf2_section_info *section,\n-\t\t\t       struct dwarf2_section_info *abbrev_section,\n-\t\t\t       const gdb_byte *info_ptr,\n-\t\t\t       rcuh_kind section_kind)\n-{\n-  const gdb_byte *beg_of_comp_unit = info_ptr;\n-\n-  header->sect_off = (sect_offset) (beg_of_comp_unit - section->buffer);\n-\n-  info_ptr = read_comp_unit_head (header, info_ptr, section, section_kind);\n-\n-  header->first_die_cu_offset = (cu_offset) (info_ptr - beg_of_comp_unit);\n-\n-  error_check_comp_unit_head (dwarf2_per_objfile, header, section,\n-\t\t\t      abbrev_section);\n-\n-  return info_ptr;\n-}\n-\n /* Fetch the abbreviation table offset from a comp or type unit header.  */\n \n static sect_offset\n@@ -6300,7 +6059,7 @@ create_debug_type_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       ptr = read_and_check_comp_unit_head (dwarf2_per_objfile, &header, section,\n \t\t\t\t\t   abbrev_section, ptr, section_kind);\n \n-      length = get_cu_length (&header);\n+      length = header.get_length ();\n \n       /* Skip dummy type units.  */\n       if (ptr >= info_ptr + length\n@@ -6836,7 +6595,7 @@ read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,\n       gdb_assert (dwo_unit->sect_off == cu->header.sect_off);\n       /* For DWOs coming from DWP files, we don't know the CU length\n \t nor the type's offset in the TU until now.  */\n-      dwo_unit->length = get_cu_length (&cu->header);\n+      dwo_unit->length = cu->header.get_length ();\n       dwo_unit->type_offset_in_tu = cu->header.type_cu_offset_in_tu;\n \n       /* Establish the type offset that can be used to lookup the type.\n@@ -6853,7 +6612,7 @@ read_cutu_die_from_dwo (struct dwarf2_per_cu_data *this_cu,\n       gdb_assert (dwo_unit->sect_off == cu->header.sect_off);\n       /* For DWOs coming from DWP files, we don't know the CU length\n \t until now.  */\n-      dwo_unit->length = get_cu_length (&cu->header);\n+      dwo_unit->length = cu->header.get_length ();\n     }\n \n   *result_dwo_abbrev_table\n@@ -7117,7 +6876,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n \n \t  /* LENGTH has not been set yet for type units if we're\n \t     using .gdb_index.  */\n-\t  this_cu->length = get_cu_length (&cu->header);\n+\t  this_cu->length = cu->header.get_length ();\n \n \t  /* Establish the type offset that can be used to lookup the type.  */\n \t  sig_type->type_offset_in_section =\n@@ -7134,7 +6893,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n \t\t\t\t\t\t    rcuh_kind::COMPILE);\n \n \t  gdb_assert (this_cu->sect_off == cu->header.sect_off);\n-\t  gdb_assert (this_cu->length == get_cu_length (&cu->header));\n+\t  gdb_assert (this_cu->length == cu->header.get_length ());\n \t  this_cu->dwarf_version = cu->header.version;\n \t}\n     }\n@@ -7290,7 +7049,7 @@ cutu_reader::cutu_reader (struct dwarf2_per_cu_data *this_cu,\n       m_new_cu->str_offsets_base = parent_cu->str_offsets_base;\n       m_new_cu->addr_base = parent_cu->addr_base;\n     }\n-  this_cu->length = get_cu_length (&m_new_cu->header);\n+  this_cu->length = m_new_cu->header.get_length ();\n \n   /* Skip dummy compilation units.  */\n   if (info_ptr >= begin_info_ptr + this_cu->length\n@@ -13548,7 +13307,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n \n \t  sect_offset sect_off\n \t    = (sect_offset) dwarf2_get_ref_die_offset (origin);\n-\t  if (!offset_in_cu_p (&cu->header, sect_off))\n+\t  if (!cu->header.offset_in_cu_p (sect_off))\n \t    {\n \t      /* As DW_OP_GNU_parameter_ref uses CU-relative offset this\n \t\t binding can be done only inside one CU.  Such referenced DIE\n@@ -18434,7 +18193,7 @@ find_partial_die (sect_offset sect_off, int offset_in_dwz, struct dwarf2_cu *cu)\n   struct partial_die_info *pd = NULL;\n \n   if (offset_in_dwz == cu->per_cu->is_dwz\n-      && offset_in_cu_p (&cu->header, sect_off))\n+      && cu->header.offset_in_cu_p (sect_off))\n     {\n       pd = cu->find_partial_die (sect_off);\n       if (pd != NULL)\n@@ -19023,20 +18782,6 @@ read_checked_initial_length_and_offset (bfd *abfd, const gdb_byte *buf,\n   return length;\n }\n \n-/* Read an offset from the data stream.  The size of the offset is\n-   given by cu_header->offset_size.  */\n-\n-static LONGEST\n-read_offset (bfd *abfd, const gdb_byte *buf,\n-\t     const struct comp_unit_head *cu_header,\n-             unsigned int *bytes_read)\n-{\n-  LONGEST offset = read_offset (abfd, buf, cu_header->offset_size);\n-\n-  *bytes_read = cu_header->offset_size;\n-  return offset;\n-}\n-\n static const gdb_byte *\n read_n_bytes (bfd *abfd, const gdb_byte *buf, unsigned int size)\n {\n@@ -22201,33 +21946,6 @@ dwarf_attr_name (unsigned attr)\n   return name;\n }\n \n-/* Convert a unit type to corresponding DW_UT name.  */\n-\n-static const char *\n-dwarf_unit_type_name (int unit_type) {\n-  switch (unit_type)\n-    {\n-      case 0x01:\n-\treturn \"DW_UT_compile (0x01)\";\n-      case 0x02:\n-\treturn \"DW_UT_type (0x02)\";\n-      case 0x03:\n-\treturn \"DW_UT_partial (0x03)\";\n-      case 0x04:\n-\treturn \"DW_UT_skeleton (0x04)\";\n-      case 0x05:\n-\treturn \"DW_UT_split_compile (0x05)\";\n-      case 0x06:\n-\treturn \"DW_UT_split_type (0x06)\";\n-      case 0x80:\n-\treturn \"DW_UT_lo_user (0x80)\";\n-      case 0xff:\n-\treturn \"DW_UT_hi_user (0xff)\";\n-      default:\n-\treturn nullptr;\n-    }\n-}\n-\n /* Convert a DWARF value form code into its string name.  */\n \n static const char *\n@@ -22533,11 +22251,11 @@ follow_die_offset (sect_offset sect_off, int offset_in_dwz,\n       /* .debug_types CUs cannot reference anything outside their CU.\n \t If they need to, they have to reference a signatured type via\n \t DW_FORM_ref_sig8.  */\n-      if (!offset_in_cu_p (&cu->header, sect_off))\n+      if (!cu->header.offset_in_cu_p (sect_off))\n \treturn NULL;\n     }\n   else if (offset_in_dwz != cu->per_cu->is_dwz\n-\t   || !offset_in_cu_p (&cu->header, sect_off))\n+\t   || !cu->header.offset_in_cu_p (sect_off))\n     {\n       struct dwarf2_per_cu_data *per_cu;\n "
    }
  ]
}