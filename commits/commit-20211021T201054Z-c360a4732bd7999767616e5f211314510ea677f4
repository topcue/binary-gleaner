{
  "sha": "c360a4732bd7999767616e5f211314510ea677f4",
  "node_id": "C_kwDOANOeidoAKGMzNjBhNDczMmJkNzk5OTc2NzYxNmU1ZjIxMTMxNDUxMGVhNjc3ZjQ",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-09-28T20:38:43Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-10-21T20:10:54Z"
    },
    "message": "gdbserver: initialize the members of lwp_info in-class\n\nAdd a constructor to initialize the waitstatus members.  Initialize the\nothers in the class directly.\n\nChange-Id: I10f885eb33adfae86e3c97b1e135335b540d7442",
    "tree": {
      "sha": "394581e44bbbadf1ee782b20faf373420a6ea19e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/394581e44bbbadf1ee782b20faf373420a6ea19e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c360a4732bd7999767616e5f211314510ea677f4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c360a4732bd7999767616e5f211314510ea677f4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c360a4732bd7999767616e5f211314510ea677f4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c360a4732bd7999767616e5f211314510ea677f4/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d2f325df0b54b0fed87f74c284f0a067b7233a14",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d2f325df0b54b0fed87f74c284f0a067b7233a14",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d2f325df0b54b0fed87f74c284f0a067b7233a14"
    }
  ],
  "stats": {
    "total": 60,
    "additions": 31,
    "deletions": 29
  },
  "files": [
    {
      "sha": "6ea517e7fbc2b4295a36c7006e48d8a2ea65bc3a",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 1,
      "deletions": 5,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c360a4732bd7999767616e5f211314510ea677f4/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c360a4732bd7999767616e5f211314510ea677f4/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=c360a4732bd7999767616e5f211314510ea677f4",
      "patch": "@@ -897,11 +897,7 @@ linux_process_target::save_stop_reason (lwp_info *lwp)\n lwp_info *\n linux_process_target::add_lwp (ptid_t ptid)\n {\n-  struct lwp_info *lwp;\n-\n-  lwp = new lwp_info {};\n-\n-  lwp->waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+  lwp_info *lwp = new lwp_info;\n \n   lwp->thread = add_thread (ptid, lwp);\n "
    },
    {
      "sha": "c6a17a498f5080a46d6b80c480771f9a603f4757",
      "filename": "gdbserver/linux-low.h",
      "status": "modified",
      "additions": 30,
      "deletions": 24,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c360a4732bd7999767616e5f211314510ea677f4/gdbserver/linux-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c360a4732bd7999767616e5f211314510ea677f4/gdbserver/linux-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.h?ref=c360a4732bd7999767616e5f211314510ea677f4",
      "patch": "@@ -721,34 +721,39 @@ struct pending_signal\n \n struct lwp_info\n {\n+  lwp_info ()\n+  {\n+    this->waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+  }\n+\n   /* Backlink to the parent object.  */\n-  struct thread_info *thread;\n+  struct thread_info *thread = nullptr;\n \n   /* If this flag is set, the next SIGSTOP will be ignored (the\n      process will be immediately resumed).  This means that either we\n      sent the SIGSTOP to it ourselves and got some other pending event\n      (so the SIGSTOP is still pending), or that we stopped the\n      inferior implicitly via PTRACE_ATTACH and have not waited for it\n      yet.  */\n-  int stop_expected;\n+  int stop_expected = 0;\n \n   /* When this is true, we shall not try to resume this thread, even\n      if last_resume_kind isn't resume_stop.  */\n-  int suspended;\n+  int suspended = 0;\n \n   /* If this flag is set, the lwp is known to be stopped right now (stop\n      event already received in a wait()).  */\n-  int stopped;\n+  int stopped = 0;\n \n   /* Signal whether we are in a SYSCALL_ENTRY or\n      in a SYSCALL_RETURN event.\n      Values:\n      - TARGET_WAITKIND_SYSCALL_ENTRY\n      - TARGET_WAITKIND_SYSCALL_RETURN */\n-  enum target_waitkind syscall_state;\n+  enum target_waitkind syscall_state = TARGET_WAITKIND_SYSCALL_ENTRY;\n \n   /* When stopped is set, the last wait status recorded for this lwp.  */\n-  int last_status;\n+  int last_status = 0;\n \n   /* If WAITSTATUS->KIND != TARGET_WAITKIND_IGNORE, the waitstatus for\n      this LWP's last event, to pass to GDB without any further\n@@ -760,58 +765,59 @@ struct lwp_info\n      the parent fork event is not reported to higher layers.  Used to\n      avoid wildcard vCont actions resuming a fork child before GDB is\n      notified about the parent's fork event.  */\n-  struct lwp_info *fork_relative;\n+  struct lwp_info *fork_relative = nullptr;\n \n   /* When stopped is set, this is where the lwp last stopped, with\n      decr_pc_after_break already accounted for.  If the LWP is\n      running, this is the address at which the lwp was resumed.  */\n-  CORE_ADDR stop_pc;\n+  CORE_ADDR stop_pc = 0;\n \n   /* If this flag is set, STATUS_PENDING is a waitstatus that has not yet\n      been reported.  */\n-  int status_pending_p;\n-  int status_pending;\n+  int status_pending_p = 0;\n+  int status_pending = 0;\n \n   /* The reason the LWP last stopped, if we need to track it\n      (breakpoint, watchpoint, etc.)  */\n-  enum target_stop_reason stop_reason;\n+  enum target_stop_reason stop_reason = TARGET_STOPPED_BY_NO_REASON;\n \n   /* On architectures where it is possible to know the data address of\n      a triggered watchpoint, STOPPED_DATA_ADDRESS is non-zero, and\n      contains such data address.  Only valid if STOPPED_BY_WATCHPOINT\n      is true.  */\n-  CORE_ADDR stopped_data_address;\n+  CORE_ADDR stopped_data_address = 0;\n \n   /* If this is non-zero, it is a breakpoint to be reinserted at our next\n      stop (SIGTRAP stops only).  */\n-  CORE_ADDR bp_reinsert;\n+  CORE_ADDR bp_reinsert = 0;\n \n   /* If this flag is set, the last continue operation at the ptrace\n      level on this process was a single-step.  */\n-  int stepping;\n+  int stepping = 0;\n \n   /* Range to single step within.  This is a copy of the step range\n      passed along the last resume request.  See 'struct\n      thread_resume'.  */\n-  CORE_ADDR step_range_start;\t/* Inclusive */\n-  CORE_ADDR step_range_end;\t/* Exclusive */\n+  CORE_ADDR step_range_start = 0; /* Inclusive */\n+  CORE_ADDR step_range_end = 0; /* Exclusive */\n \n   /* If this flag is set, we need to set the event request flags the\n      next time we see this LWP stop.  */\n-  int must_set_ptrace_flags;\n+  int must_set_ptrace_flags = 0;\n \n   /* A chain of signals that need to be delivered to this process.  */\n   std::list<pending_signal> pending_signals;\n \n   /* A link used when resuming.  It is initialized from the resume request,\n      and then processed and cleared in linux_resume_one_lwp.  */\n-  struct thread_resume *resume;\n+  struct thread_resume *resume = nullptr;\n \n   /* Information bout this lwp's fast tracepoint collection status (is it\n      currently stopped in the jump pad, and if so, before or at/after the\n      relocated instruction).  Normally, we won't care about this, but we will\n      if a signal arrives to this lwp while it is collecting.  */\n-  fast_tpoint_collect_result collecting_fast_tracepoint;\n+  fast_tpoint_collect_result collecting_fast_tracepoint\n+    = fast_tpoint_collect_result::not_collecting;\n \n   /* A chain of signals that need to be reported to GDB.  These were\n      deferred because the thread was doing a fast tracepoint collect\n@@ -820,20 +826,20 @@ struct lwp_info\n \n   /* When collecting_fast_tracepoint is first found to be 1, we insert\n      a exit-jump-pad-quickly breakpoint.  This is it.  */\n-  struct breakpoint *exit_jump_pad_bkpt;\n+  struct breakpoint *exit_jump_pad_bkpt = nullptr;\n \n #ifdef USE_THREAD_DB\n-  int thread_known;\n+  int thread_known = 0;\n   /* The thread handle, used for e.g. TLS access.  Only valid if\n      THREAD_KNOWN is set.  */\n-  td_thrhandle_t th;\n+  td_thrhandle_t th {};\n \n   /* The pthread_t handle.  */\n-  thread_t thread_handle;\n+  thread_t thread_handle {};\n #endif\n \n   /* Arch-specific additions.  */\n-  struct arch_lwp_info *arch_private;\n+  struct arch_lwp_info *arch_private = nullptr;\n };\n \n int linux_pid_exe_is_elf_64_file (int pid, unsigned int *machine);"
    }
  ]
}