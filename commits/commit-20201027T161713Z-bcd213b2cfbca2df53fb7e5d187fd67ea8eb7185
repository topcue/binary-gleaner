{
  "sha": "bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmNkMjEzYjJjZmJjYTJkZjUzZmI3ZTVkMTg3ZmQ2N2VhOGViNzE4NQ==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-10-27T16:17:13Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2020-10-27T16:17:13Z"
    },
    "message": "Fix the decoding of DW_FORM_ref_addr DWARF attribute.\n\n\t* dwarf.c (struct abbrev_list): New structure.  Used to collect\n\tlists of abbreviation sets.\n\t(struct abbrev_map): New structure.  Used to map CU offsets to\n\tabbreviation offsets.\n\t(record_abbrev_list): New function.  A new entry to an\n\tabbreviation list.\n\t(free_all_abbrevs): Update to free abbreviation lists.\n\t(new_abbrev_list): New function.  Start a new abbreviation\n\tlist.\n\t(find_abbrev_list_by_abbrev_offset): New function.\n\t(find_abbrev_map_by_offset): New function.\n\t(add_abbrev): Add abbrev_list parameter.\n\t(add_abbrev_attr): Likewise.\n\t(process_abbrev_section): Rename to process_abbrev_set and add\n\tlist parameter.\n\t(get_type_abbrev_from_form): New function.  Attempts to decode the\n\tforms used by DW_AT_type attributes.\n\t(get_type_signedness): Display type names if operating in wide\n\tmode.  Use get_type_abbrev_from_form.\n\t(read_and_display_attr_value): Use get_type_abbrev_from_form.\n\t(process_debug_info): Pre-parse the CU headers to collate all the\n\tabbrevs before starting the main scan.\n\t(process_debug_abbrev): Do not free any loaded abbrevs.\n\t(free_debug_memory): Free the abbrev maps.",
    "tree": {
      "sha": "ebdc8f30b288ada5dcedaf33484ce2fc9272b958",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ebdc8f30b288ada5dcedaf33484ce2fc9272b958"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7f40ce1a9ea16720b9e9199a20173ed29285da9a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7f40ce1a9ea16720b9e9199a20173ed29285da9a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7f40ce1a9ea16720b9e9199a20173ed29285da9a"
    }
  ],
  "stats": {
    "total": 612,
    "additions": 474,
    "deletions": 138
  },
  "files": [
    {
      "sha": "0aa511dacad224a1e5c967e4c9c571e93cdc3c57",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185",
      "patch": "@@ -1,3 +1,30 @@\n+2020-10-27  Nick Clifton  <nickc@redhat.com>\n+\n+\t* dwarf.c (struct abbrev_list): New structure.  Used to collect\n+\tlists of abbreviation sets.\n+\t(struct abbrev_map): New structure.  Used to map CU offsets to\n+\tabbreviation offsets.\n+\t(record_abbrev_list): New function.  A new entry to an\n+\tabbreviation list.\n+\t(free_all_abbrevs): Update to free abbreviation lists.\n+\t(new_abbrev_list): New function.  Start a new abbreviation\n+\tlist.\n+\t(find_abbrev_list_by_abbrev_offset): New function.\n+\t(find_abbrev_map_by_offset): New function.\n+\t(add_abbrev): Add abbrev_list parameter.\n+\t(add_abbrev_attr): Likewise.\n+\t(process_abbrev_section): Rename to process_abbrev_set and add\n+\tlist parameter.\n+\t(get_type_abbrev_from_form): New function.  Attempts to decode the\n+\tforms used by DW_AT_type attributes.\n+\t(get_type_signedness): Display type names if operating in wide\n+\tmode.  Use get_type_abbrev_from_form.\n+\t(read_and_display_attr_value): Use get_type_abbrev_from_form.\n+\t(process_debug_info): Pre-parse the CU headers to collate all the\n+\tabbrevs before starting the main scan.\n+\t(process_debug_abbrev): Do not free any loaded abbrevs.\n+\t(free_debug_memory): Free the abbrev maps.\n+\n 2020-10-22  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* testsuite/binutils-all/objcopy.exp (objcopy_test): Report"
    },
    {
      "sha": "5cfa528594ffc1a4f386df6831ec202c3fea0458",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 447,
      "deletions": 138,
      "changes": 585,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=bcd213b2cfbca2df53fb7e5d187fd67ea8eb7185",
      "patch": "@@ -849,101 +849,204 @@ fetch_indexed_value (dwarf_vma offset, dwarf_vma bytes)\n /* FIXME:  There are better and more efficient ways to handle\n    these structures.  For now though, I just want something that\n    is simple to implement.  */\n+/* Records a single attribute in an abbrev.  */\n typedef struct abbrev_attr\n {\n-  unsigned long attribute;\n-  unsigned long form;\n-  bfd_signed_vma implicit_const;\n-  struct abbrev_attr *next;\n+  unsigned long          attribute;\n+  unsigned long          form;\n+  bfd_signed_vma         implicit_const;\n+  struct abbrev_attr *   next;\n }\n abbrev_attr;\n \n+/* Records a single abbrev.  */\n typedef struct abbrev_entry\n {\n-  unsigned long entry;\n-  unsigned long tag;\n-  int children;\n-  struct abbrev_attr *first_attr;\n-  struct abbrev_attr *last_attr;\n-  struct abbrev_entry *next;\n+  unsigned long          number;\n+  unsigned long          tag;\n+  int                    children;\n+  struct abbrev_attr *   first_attr;\n+  struct abbrev_attr *   last_attr;\n+  struct abbrev_entry *  next;\n }\n abbrev_entry;\n \n-static abbrev_entry *first_abbrev = NULL;\n-static abbrev_entry *last_abbrev = NULL;\n+/* Records a set of abbreviations.  */\n+typedef struct abbrev_list\n+{\n+  abbrev_entry *        first_abbrev;\n+  abbrev_entry *        last_abbrev;\n+  dwarf_vma             abbrev_offset;\n+  struct abbrev_list *  next;\n+  unsigned char *       start_of_next_abbrevs;\n+}\n+abbrev_list;\n+\n+/* Records all the abbrevs found so far.  */\n+static struct abbrev_list * abbrev_lists = NULL;\n+\n+typedef struct abbrev_map\n+{\n+  dwarf_vma      start;\n+  dwarf_vma      end;\n+  abbrev_list *  list;\n+} abbrev_map;\n+\n+/* Maps between CU offsets and abbrev sets.  */\n+static abbrev_map *   cu_abbrev_map = NULL;\n+static unsigned long  num_abbrev_map_entries = 0;\n+static unsigned long  next_free_abbrev_map_entry = 0;\n+\n+#define INITIAL_NUM_ABBREV_MAP_ENTRIES 8\n+#define ABBREV_MAP_ENTRIES_INCREMENT   8\n+\n+static void\n+record_abbrev_list_for_cu (dwarf_vma start, dwarf_vma end, abbrev_list * list)\n+{\n+  if (cu_abbrev_map == NULL)\n+    {\n+      num_abbrev_map_entries = INITIAL_NUM_ABBREV_MAP_ENTRIES;\n+      cu_abbrev_map = xmalloc (num_abbrev_map_entries * sizeof (* cu_abbrev_map));\n+    }\n+  else if (next_free_abbrev_map_entry == num_abbrev_map_entries)\n+    {\n+      num_abbrev_map_entries += ABBREV_MAP_ENTRIES_INCREMENT;\n+      cu_abbrev_map = xrealloc (cu_abbrev_map, num_abbrev_map_entries * sizeof (* cu_abbrev_map));\n+    }\n+\n+  cu_abbrev_map[next_free_abbrev_map_entry].start = start;\n+  cu_abbrev_map[next_free_abbrev_map_entry].end = end;\n+  cu_abbrev_map[next_free_abbrev_map_entry].list = list;\n+  next_free_abbrev_map_entry ++;\n+}\n \n static void\n-free_abbrevs (void)\n+free_all_abbrevs (void)\n {\n-  abbrev_entry *abbrv;\n+  abbrev_list *  list;\n \n-  for (abbrv = first_abbrev; abbrv;)\n+  for (list = abbrev_lists; list != NULL;)\n     {\n-      abbrev_entry *next_abbrev = abbrv->next;\n-      abbrev_attr *attr;\n+      abbrev_list *   next = list->next;\n+      abbrev_entry *  abbrv;\n \n-      for (attr = abbrv->first_attr; attr;)\n+      for (abbrv = list->first_abbrev; abbrv != NULL;)\n \t{\n-\t  abbrev_attr *next_attr = attr->next;\n+\t  abbrev_entry *  next_abbrev = abbrv->next;\n+\t  abbrev_attr *   attr;\n+\n+\t  for (attr = abbrv->first_attr; attr;)\n+\t    {\n+\t      abbrev_attr *next_attr = attr->next;\n \n-\t  free (attr);\n-\t  attr = next_attr;\n+\t      free (attr);\n+\t      attr = next_attr;\n+\t    }\n+\n+\t  free (abbrv);\n+\t  abbrv = next_abbrev;\n \t}\n \n-      free (abbrv);\n-      abbrv = next_abbrev;\n+      free (list);\n+      list = next;\n     }\n \n-  last_abbrev = first_abbrev = NULL;\n+  abbrev_lists = NULL;\n+}\n+\n+static abbrev_list *\n+new_abbrev_list (dwarf_vma abbrev_offset)\n+{\n+  abbrev_list * list = (abbrev_list *) xcalloc (sizeof * list, 1);\n+\n+  list->abbrev_offset = abbrev_offset;\n+\n+  list->next = abbrev_lists;\n+  abbrev_lists = list;\n+\n+  return list;\n+}\n+\n+static abbrev_list *\n+find_abbrev_list_by_abbrev_offset (dwarf_vma abbrev_offset)\n+{\n+  abbrev_list * list;\n+\n+  for (list = abbrev_lists; list != NULL; list = list->next)\n+    if (list->abbrev_offset == abbrev_offset)\n+      return list;\n+\n+  return NULL;\n+}\n+\n+/* Find the abbreviation map for the CU that includes OFFSET.\n+   OFFSET is an absolute offset from the start of the .debug_info section.  */\n+/* FIXME: This function is going to slow down readelf & objdump.\n+   Consider using a better algorithm to mitigate this effect.  */\n+\n+static  abbrev_map *\n+find_abbrev_map_by_offset (dwarf_vma offset)\n+{\n+  unsigned long i;\n+\n+  for (i = 0; i < next_free_abbrev_map_entry; i++)\n+    if (cu_abbrev_map[i].start <= offset\n+\t&& cu_abbrev_map[i].end > offset)\n+      return cu_abbrev_map + i;\n+\n+  return NULL;\t\n }\n \n static void\n-add_abbrev (unsigned long number, unsigned long tag, int children)\n+add_abbrev (unsigned long  number,\n+\t    unsigned long  tag,\n+\t    int            children,\n+\t    abbrev_list *  list)\n {\n-  abbrev_entry *entry;\n+  abbrev_entry *  entry;\n \n-  entry = (abbrev_entry *) malloc (sizeof (*entry));\n-  if (entry == NULL)\n-    /* ugg */\n-    return;\n+  entry = (abbrev_entry *) xmalloc (sizeof (*entry));\n \n-  entry->entry      = number;\n+  entry->number     = number;\n   entry->tag        = tag;\n   entry->children   = children;\n   entry->first_attr = NULL;\n   entry->last_attr  = NULL;\n   entry->next       = NULL;\n \n-  if (first_abbrev == NULL)\n-    first_abbrev = entry;\n+  assert (list != NULL);\n+\n+  if (list->first_abbrev == NULL)\n+    list->first_abbrev = entry;\n   else\n-    last_abbrev->next = entry;\n+    list->last_abbrev->next = entry;\n \n-  last_abbrev = entry;\n+  list->last_abbrev = entry;\n }\n \n static void\n-add_abbrev_attr (unsigned long attribute, unsigned long form,\n-\t\t bfd_signed_vma implicit_const)\n+add_abbrev_attr (unsigned long   attribute,\n+\t\t unsigned long   form,\n+\t\t bfd_signed_vma  implicit_const,\n+\t\t abbrev_list *   list)\n {\n   abbrev_attr *attr;\n \n-  attr = (abbrev_attr *) malloc (sizeof (*attr));\n-  if (attr == NULL)\n-    /* ugg */\n-    return;\n+  attr = (abbrev_attr *) xmalloc (sizeof (*attr));\n \n   attr->attribute = attribute;\n   attr->form      = form;\n   attr->implicit_const = implicit_const;\n   attr->next      = NULL;\n \n-  if (last_abbrev->first_attr == NULL)\n-    last_abbrev->first_attr = attr;\n+  assert (list != NULL && list->last_abbrev != NULL);\n+\n+  if (list->last_abbrev->first_attr == NULL)\n+    list->last_abbrev->first_attr = attr;\n   else\n-    last_abbrev->last_attr->next = attr;\n+    list->last_abbrev->last_attr->next = attr;\n \n-  last_abbrev->last_attr = attr;\n+  list->last_abbrev->last_attr = attr;\n }\n \n /* Processes the (partial) contents of a .debug_abbrev section.\n@@ -952,11 +1055,10 @@ add_abbrev_attr (unsigned long attribute, unsigned long form,\n    an abbreviation set was found.  */\n \n static unsigned char *\n-process_abbrev_section (unsigned char *start, unsigned char *end)\n+process_abbrev_set (unsigned char *        start,\n+\t\t    const unsigned char *  end,\n+\t\t    abbrev_list *          list)\n {\n-  if (first_abbrev != NULL)\n-    return NULL;\n-\n   while (start < end)\n     {\n       unsigned long entry;\n@@ -966,7 +1068,7 @@ process_abbrev_section (unsigned char *start, unsigned char *end)\n \n       READ_ULEB (entry, start, end);\n \n-      /* A single zero is supposed to end the section according\n+      /* A single zero is supposed to end the set according\n \t to the standard.  If there's more, then signal that to\n \t the caller.  */\n       if (start == end)\n@@ -980,7 +1082,7 @@ process_abbrev_section (unsigned char *start, unsigned char *end)\n \n       children = *start++;\n \n-      add_abbrev (entry, tag, children);\n+      add_abbrev (entry, tag, children, list);\n \n       do\n \t{\n@@ -1003,7 +1105,7 @@ process_abbrev_section (unsigned char *start, unsigned char *end)\n \t\tbreak;\n \t    }\n \n-\t  add_abbrev_attr (attribute, form, implicit_const);\n+\t  add_abbrev_attr (attribute, form, implicit_const, list);\n \t}\n       while (attribute != 0);\n     }\n@@ -1969,36 +2071,123 @@ skip_attr_bytes (unsigned long          form,\n   return data;\n }\n \n-/* Return IS_SIGNED set to TRUE if the type at\n-   DATA can be determined to be a signed type.  */\n+/* Given form FORM with value UVALUE, locate and return the abbreviation\n+   associated with it.  */\n+\n+static abbrev_entry *\n+get_type_abbrev_from_form (unsigned long                 form,\n+\t\t\t   unsigned long                 uvalue,\n+\t\t\t   dwarf_vma                     cu_offset,\n+\t\t\t   const struct dwarf_section *  section,\n+\t\t\t   unsigned long *               abbrev_num_return,\n+\t\t\t   unsigned char **              data_return,\n+\t\t\t   unsigned long *               cu_offset_return)\n+{\n+  unsigned long   abbrev_number;\n+  abbrev_map *    map;\n+  abbrev_entry *  entry;\n+  unsigned char * data;\n+\n+  if (abbrev_num_return != NULL)\n+    * abbrev_num_return = 0;\n+  if (data_return != NULL)\n+    * data_return = NULL;\n+\n+  switch (form)\n+    {\n+    case DW_FORM_GNU_ref_alt:\n+      /* FIXME: We are unable to handle this form at the moment.  */\n+      return NULL;\n+\n+    case DW_FORM_ref_addr:\n+      if (uvalue >= section->size)\n+\t{\n+\t  warn (_(\"Unable to resolve ref_addr form: uvalue %lx > section size %lx (%s)\\n\"),\n+\t\tuvalue, (long) section->size, section->name);\n+\t  return NULL;\n+\t}\n+      break;\n+\n+    case DW_FORM_ref1:\n+    case DW_FORM_ref2:\n+    case DW_FORM_ref4:\n+    case DW_FORM_ref_udata:\n+      if (uvalue + cu_offset > section->size)\n+\t{\n+\t  warn (_(\"Unable to resolve ref form: uvalue %lx + cu_offset %lx > section size %lx\\n\"),\n+\t\tuvalue, (long) cu_offset, (long) section->size);\n+\t  return NULL;\n+\t}\n+      uvalue += cu_offset;\n+      break;\n+\n+      /* FIXME: Are there other DW_FORMs that can be used by types ?  */\n+\n+    default:\n+      warn (_(\"Unexpected form %lx encountered whilst finding abbreviation for type\\n\"), form);\n+      return NULL;\n+    }\n+\n+  data = (unsigned char *) section->start + uvalue;\n+  map = find_abbrev_map_by_offset (uvalue);\n+  \n+  if (map == NULL)\n+    {\n+      warn (_(\"Unable to find abbreviations for CU offset %#lx\\n\"), uvalue);\n+      return NULL;\n+    }\n+  if (map->list == NULL)\n+    {\n+      warn (_(\"Empty abbreviation list encountered for CU offset %lx\\n\"), uvalue);\n+      return NULL;\n+    }\n+\n+  if (cu_offset_return != NULL)\n+    {\n+      if (form == DW_FORM_ref_addr)\n+\t* cu_offset_return = map->start;\n+      else\n+\t* cu_offset_return = cu_offset;\n+    }\n+\t\n+  READ_ULEB (abbrev_number, data, section->start + section->size);\n+\n+  for (entry = map->list->first_abbrev; entry != NULL; entry = entry->next)\n+    if (entry->number == abbrev_number)\n+      break;\n+  \n+  if (abbrev_num_return != NULL)\n+    * abbrev_num_return = abbrev_number;\n+\n+  if (data_return != NULL)\n+    * data_return = data;\n+\n+  if (entry == NULL)\n+    warn (_(\"Unable to find entry for abbreviation %lu\\n\"), abbrev_number);\n+\n+  return entry;\n+}\n+\n+/* Return IS_SIGNED set to TRUE if the type using abbreviation ENTRY\n+   can be determined to be a signed type.  The data for ENTRY can be\n+   found starting at DATA.  */\n \n static void\n-get_type_signedness (unsigned char *        start,\n+get_type_signedness (abbrev_entry *         entry,\n+\t\t     const struct dwarf_section * section,\n \t\t     unsigned char *        data,\n \t\t     unsigned const char *  end,\n+\t\t     dwarf_vma              cu_offset,\n \t\t     dwarf_vma              pointer_size,\n \t\t     dwarf_vma              offset_size,\n \t\t     int                    dwarf_version,\n \t\t     bfd_boolean *          is_signed,\n \t\t     unsigned int\t    nesting)\n {\n-  unsigned long   abbrev_number;\n-  abbrev_entry *  entry;\n   abbrev_attr *   attr;\n \n   * is_signed = FALSE;\n \n-  READ_ULEB (abbrev_number, data, end);\n-\n-  for (entry = first_abbrev;\n-       entry != NULL && entry->entry != abbrev_number;\n-       entry = entry->next)\n-    continue;\n-\n-  if (entry == NULL)\n-    /* FIXME: Issue a warning ?  */\n-    return;\n-\n #define MAX_NESTING 20\n   if (nesting > MAX_NESTING)\n     {\n@@ -2011,6 +2200,7 @@ get_type_signedness (unsigned char *        start,\n        attr != NULL && attr->attribute;\n        attr = attr->next)\n     {\n+      unsigned char * orig_data = data;\n       dwarf_vma uvalue = 0;\n \n       data = skip_attr_bytes (attr->form, data, end, pointer_size,\n@@ -2020,21 +2210,38 @@ get_type_signedness (unsigned char *        start,\n \n       switch (attr->attribute)\n \t{\n-#if 0 /* FIXME: It would be nice to print the name of the type,\n-\t but this would mean updating a lot of binutils tests.  */\n+\tcase DW_AT_linkage_name:\n \tcase DW_AT_name:\n-\t  if (attr->form == DW_FORM_strp)\n-\t    printf (\"%s\", fetch_indirect_string (uvalue));\n+\t  if (do_wide)\n+\t    {\n+\t      if (attr->form == DW_FORM_strp)\n+\t\tprintf (\", %s\", fetch_indirect_string (uvalue));\n+\t      else if (attr->form == DW_FORM_string)\n+\t\tprintf (\", %s\", orig_data);\n+\t    }\n \t  break;\n-#endif\n+\n \tcase DW_AT_type:\n \t  /* Recurse.  */\n-\t  if (uvalue >= (size_t) (end - start))\n-\t    return;\n-\t  /* We cannot correctly process DW_FORM_ref_addr at the moment.  */\n-\t  if (attr->form != DW_FORM_ref_addr)\n-\t    get_type_signedness (start, start + uvalue, end, pointer_size,\n-\t\t\t\t offset_size, dwarf_version, is_signed, nesting + 1);\n+\t  {\n+\t    abbrev_entry *  type_abbrev;\n+\t    unsigned char * type_data;\n+\t    unsigned long   type_cu_offset;\n+\n+\t    type_abbrev = get_type_abbrev_from_form (attr->form,\n+\t\t\t\t\t\t     uvalue,\n+\t\t\t\t\t\t     cu_offset,\n+\t\t\t\t\t\t     section,\n+\t\t\t\t\t\t     NULL /* abbrev num return */,\n+\t\t\t\t\t\t     & type_data,\n+\t\t\t\t\t\t     & type_cu_offset);\n+\t    if (type_abbrev == NULL)\n+\t      break;\n+\n+\t    get_type_signedness (type_abbrev, section, type_data, end, type_cu_offset,\n+\t\t\t\t pointer_size, offset_size, dwarf_version,\n+\t\t\t\t is_signed, nesting + 1);\n+\t  }\n \t  break;\n \n \tcase DW_AT_encoding:\n@@ -2276,12 +2483,12 @@ read_and_display_attr_value (unsigned long           attribute,\n     {\n     case DW_FORM_ref_addr:\n       if (!do_loc)\n-\tprintf (\"%c<0x%s>\", delimiter, dwarf_vmatoa (\"x\",uvalue));\n+\tprintf (\"%c<0x%s>\", delimiter, dwarf_vmatoa (\"x\", uvalue));\n       break;\n \n     case DW_FORM_GNU_ref_alt:\n       if (!do_loc)\n-\tprintf (\"%c<alt 0x%s>\", delimiter, dwarf_vmatoa (\"x\",uvalue));\n+\tprintf (\"%c<alt 0x%s>\", delimiter, dwarf_vmatoa (\"x\", uvalue));\n       /* FIXME: Follow the reference...  */\n       break;\n \n@@ -2667,11 +2874,18 @@ read_and_display_attr_value (unsigned long           attribute,\n \t  && uvalue < (size_t) (end - start))\n \t{\n \t  bfd_boolean is_signed = FALSE;\n-\n-\t  /* We cannot correctly process DW_FORM_ref_addr at the moment.  */\n-\t  if (form != DW_FORM_ref_addr)\n-\t    get_type_signedness (start, start + uvalue, end, pointer_size,\n-\t\t\t\t offset_size, dwarf_version, & is_signed, 0);\n+\t  abbrev_entry *  type_abbrev;\n+\t  unsigned char * type_data;\n+\t  unsigned long   type_cu_offset;\n+\t  \n+\t  type_abbrev = get_type_abbrev_from_form (form, uvalue, cu_offset,\n+\t\t\t\t\t\t   section, NULL, & type_data, & type_cu_offset);\n+\t  if (type_abbrev != NULL)\n+\t    {\n+\t      get_type_signedness (type_abbrev, section, type_data, end, type_cu_offset,\n+\t\t\t\t   pointer_size, offset_size, dwarf_version,\n+\t\t\t\t   & is_signed, 0);\n+\t    }\n \t  level_type_signed[level] = is_signed;\n \t}\n       break;\n@@ -2993,40 +3207,22 @@ read_and_display_attr_value (unsigned long           attribute,\n \n     case DW_AT_import:\n       {\n-\tif (form == DW_FORM_ref_sig8\n-\t    || form == DW_FORM_GNU_ref_alt)\n-\t  break;\n+\tunsigned long abbrev_number;\n+\tabbrev_entry *entry;\n \n-\tif (form == DW_FORM_ref1\n-\t    || form == DW_FORM_ref2\n-\t    || form == DW_FORM_ref4\n-\t    || form == DW_FORM_ref_udata)\n-\t  uvalue += cu_offset;\n-\n-\tif (uvalue >= section->size)\n-\t  warn (_(\"Offset %s used as value for DW_AT_import attribute of DIE at offset 0x%lx is too big.\\n\"),\n-\t\tdwarf_vmatoa (\"x\", uvalue),\n-\t\t(unsigned long) (orig_data - section->start));\n+\tentry = get_type_abbrev_from_form (form, uvalue, cu_offset,\n+\t\t\t\t\t   section, & abbrev_number, NULL, NULL);\n+\tif (entry == NULL)\n+\t  {\n+\t    if (form != DW_FORM_GNU_ref_alt)\n+\t      warn (_(\"Offset %s used as value for DW_AT_import attribute of DIE at offset 0x%lx is too big.\\n\"),\n+\t\t    dwarf_vmatoa (\"x\", uvalue),\n+\t\t    (unsigned long) (orig_data - section->start));\n+\t  }\n \telse\n \t  {\n-\t    unsigned long abbrev_number;\n-\t    abbrev_entry *entry;\n-\t    unsigned char *p = section->start + uvalue;\n-\n-\t    READ_ULEB (abbrev_number, p, end);\n-\n \t    printf (_(\"\\t[Abbrev Number: %ld\"), abbrev_number);\n-\t    /* Don't look up abbrev for DW_FORM_ref_addr, as it very often will\n-\t       use different abbrev table, and we don't track .debug_info chunks\n-\t       yet.  */\n-\t    if (form != DW_FORM_ref_addr)\n-\t      {\n-\t\tfor (entry = first_abbrev; entry != NULL; entry = entry->next)\n-\t\t  if (entry->entry == abbrev_number)\n-\t\t    break;\n-\t\tif (entry != NULL)\n-\t\t  printf (\" (%s)\", get_TAG_name (entry->tag));\n-\t      }\n+\t    printf (\" (%s)\", get_TAG_name (entry->tag));\n \t    printf (\"]\");\n \t  }\n       }\n@@ -3245,8 +3441,98 @@ process_debug_info (struct dwarf_section *           section,\n \n   if (!do_loc && dwarf_start_die == 0)\n     introduce (section, FALSE);\n+\n+  free_all_abbrevs ();\n+  free (cu_abbrev_map);\n+  cu_abbrev_map = NULL;\n+  next_free_abbrev_map_entry = 0;\n   \n-  for (section_begin = start, unit = 0; start < end; unit++)\n+  /* In order to be able to resolve DW_FORM_ref_attr forms we need\n+     to load *all* of the abbrevs for all CUs in this .debug_info\n+     section.  This does effectively mean that we (partially) read\n+     every CU header twice.  */\n+  for (section_begin = start; start < end;)\n+    {\n+      DWARF2_Internal_CompUnit  compunit;\n+      unsigned char *           hdrptr;\n+      dwarf_vma                 cu_offset;\n+      unsigned int              offset_size;\n+      unsigned int              initial_length_size;\n+      struct cu_tu_set *        this_set;\n+      abbrev_list *             list;\n+\n+      hdrptr = start;\n+\n+      SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 4, end);\n+\n+      if (compunit.cu_length == 0xffffffff)\n+\t{\n+\t  SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 8, end);\n+\t  offset_size = 8;\n+\t  initial_length_size = 12;\n+\t}\n+      else\n+\t{\n+\t  offset_size = 4;\n+\t  initial_length_size = 4;\n+\t}\n+\n+      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end);\n+\n+      cu_offset = start - section_begin;\n+\n+      this_set = find_cu_tu_set_v2 (cu_offset, do_types);\n+\n+      if (compunit.cu_version < 5)\n+\t{\n+\t  compunit.cu_unit_type = DW_UT_compile;\n+\t  /* Initialize it due to a false compiler warning.  */\n+\t  compunit.cu_pointer_size = -1;\n+\t}\n+      else\n+\t{\n+\t  SAFE_BYTE_GET_AND_INC (compunit.cu_unit_type, hdrptr, 1, end);\n+\t  do_types = (compunit.cu_unit_type == DW_UT_type);\n+\n+\t  SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n+\t}\n+\n+      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);\n+\n+      list = find_abbrev_list_by_abbrev_offset (compunit.cu_abbrev_offset);\n+      if (list == NULL)\n+\t{\n+\t  dwarf_vma        abbrev_base;\n+\t  size_t           abbrev_size;\n+\t  unsigned char *  next;\n+\n+\t  if (this_set == NULL)\n+\t    {\n+\t      abbrev_base = 0;\n+\t      abbrev_size = debug_displays [abbrev_sec].section.size;\n+\t    }\n+\t  else\n+\t    {\n+\t      abbrev_base = this_set->section_offsets [DW_SECT_ABBREV];\n+\t      abbrev_size = this_set->section_sizes [DW_SECT_ABBREV];\n+\t    }\n+\n+\t  list = new_abbrev_list (compunit.cu_abbrev_offset);\n+\t  next = process_abbrev_set\n+\t    (((unsigned char *) debug_displays [abbrev_sec].section.start\n+\t      + abbrev_base + compunit.cu_abbrev_offset),\n+\t     ((unsigned char *) debug_displays [abbrev_sec].section.start\n+\t      + abbrev_base + abbrev_size),\n+\t     list);\n+\t  list->start_of_next_abbrevs = next;\n+\t}\n+\t\t       \n+      start = section_begin + cu_offset + compunit.cu_length\n+\t+ initial_length_size;\n+      record_abbrev_list_for_cu (cu_offset, start - section_begin, list);\n+    }\n+\n+  for (start = section_begin, unit = 0; start < end; unit++)\n     {\n       DWARF2_Internal_CompUnit compunit;\n       unsigned char *hdrptr;\n@@ -3262,6 +3548,7 @@ process_debug_info (struct dwarf_section *           section,\n       struct cu_tu_set *this_set;\n       dwarf_vma abbrev_base;\n       size_t abbrev_size;\n+      abbrev_list * list = NULL;\n \n       hdrptr = start;\n \n@@ -3439,8 +3726,6 @@ process_debug_info (struct dwarf_section *           section,\n \t  continue;\n \t}\n \n-      free_abbrevs ();\n-\n       /* Process the abbrevs used by this compilation unit.  */\n       if (compunit.cu_abbrev_offset >= abbrev_size)\n \twarn (_(\"Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\\n\"),\n@@ -3453,11 +3738,22 @@ process_debug_info (struct dwarf_section *           section,\n \t      (unsigned long) abbrev_base + abbrev_size,\n \t      (unsigned long) debug_displays [abbrev_sec].section.size);\n       else\n-\tprocess_abbrev_section\n-\t  (((unsigned char *) debug_displays [abbrev_sec].section.start\n-\t    + abbrev_base + compunit.cu_abbrev_offset),\n-\t   ((unsigned char *) debug_displays [abbrev_sec].section.start\n-\t    + abbrev_base + abbrev_size));\n+\t{\n+\t  list = find_abbrev_list_by_abbrev_offset (compunit.cu_abbrev_offset);\n+\t  if (list == NULL)\n+\t    {\n+\t      unsigned char * next;\n+\n+\t      list = new_abbrev_list (compunit.cu_abbrev_offset);\n+\t      next = process_abbrev_set\n+\t\t(((unsigned char *) debug_displays [abbrev_sec].section.start\n+\t\t  + abbrev_base + compunit.cu_abbrev_offset),\n+\t\t ((unsigned char *) debug_displays [abbrev_sec].section.start\n+\t\t  + abbrev_base + abbrev_size),\n+\t\t list);\n+\t      list->start_of_next_abbrevs = next;\n+\t    }\n+\t}\n \n       level = 0;\n       last_level = level;\n@@ -3537,11 +3833,13 @@ process_debug_info (struct dwarf_section *           section,\n \n \t  /* Scan through the abbreviation list until we reach the\n \t     correct entry.  */\n-\t  for (entry = first_abbrev;\n-\t       entry && entry->entry != abbrev_number;\n-\t       entry = entry->next)\n+\t  if (list == NULL)\n \t    continue;\n \n+\t  for (entry = list->first_abbrev; entry != NULL; entry = entry->next)\n+\t    if (entry->number == abbrev_number)\n+\t      break;\n+\n \t  if (entry == NULL)\n \t    {\n \t      if (!do_loc && do_printing)\n@@ -5763,30 +6061,37 @@ display_debug_abbrev (struct dwarf_section *section,\n {\n   abbrev_entry *entry;\n   unsigned char *start = section->start;\n-  unsigned char *end = start + section->size;\n+  const unsigned char *end = start + section->size;\n \n   introduce (section, FALSE);\n \n   do\n     {\n-      unsigned char *last;\n+      abbrev_list *    list;\n+      dwarf_vma        offset;\n \n-      free_abbrevs ();\n-\n-      last = start;\n-      start = process_abbrev_section (start, end);\n+      offset = start - section->start;\n+      list = find_abbrev_list_by_abbrev_offset (offset);\n+      if (list == NULL)\n+\t{\n+\t  list = new_abbrev_list (offset);\n+\t  start = process_abbrev_set (start, end, list);\n+\t  list->start_of_next_abbrevs = start;\n+\t}\n+      else\n+\tstart = list->start_of_next_abbrevs;\n \n-      if (first_abbrev == NULL)\n+      if (list->first_abbrev == NULL)\n \tcontinue;\n \n-      printf (_(\"  Number TAG (0x%lx)\\n\"), (long) (last - section->start));\n+      printf (_(\"  Number TAG (0x%lx)\\n\"), (long) offset);\n \n-      for (entry = first_abbrev; entry; entry = entry->next)\n+      for (entry = list->first_abbrev; entry; entry = entry->next)\n \t{\n \t  abbrev_attr *attr;\n \n \t  printf (\"   %ld      %s    [%s]\\n\",\n-\t\t  entry->entry,\n+\t\t  entry->number,\n \t\t  get_TAG_name (entry->tag),\n \t\t  entry->children ? _(\"has children\") : _(\"no children\"));\n \n@@ -10828,8 +11133,12 @@ free_debug_memory (void)\n {\n   unsigned int i;\n \n-  free_abbrevs ();\n+  free_all_abbrevs ();\n \n+  free (cu_abbrev_map);\n+  cu_abbrev_map = NULL;\n+  next_free_abbrev_map_entry = 0;\n+  \n   for (i = 0; i < max; i++)\n     free_debug_section ((enum dwarf_section_display_enum) i);\n "
    }
  ]
}