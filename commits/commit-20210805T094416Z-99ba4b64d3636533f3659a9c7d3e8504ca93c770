{
  "sha": "99ba4b64d3636533f3659a9c7d3e8504ca93c770",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTliYTRiNjRkMzYzNjUzM2YzNjU5YTljN2QzZTg1MDRjYTkzYzc3MA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-06-08T11:49:04Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-08-05T09:44:16Z"
    },
    "message": "gdb/testsuite: update test gdb.base/step-over-syscall.exp\n\nI was looking at PR gdb/19675 and the related test\ngdb.base/step-over-syscall.exp.  This test includes a call to kfail\nwhen we are testing a displaced step over a clone syscall.\n\nWhile looking at the test I removed the call to kfail and ran the\ntest, and was surprised that the test passed.\n\nI ran the test a few times and it does sometimes fail, but mostly it\npassed fine.\n\nPR gdb/19675 describes how, when we displaced step over a clone, the\nnew thread is created with a $pc in the displaced step buffer.  GDB\nthen fails to \"fix\" this $pc (for the new thread), and the thread will\nbe set running with its current $pc value.  This means that the new\nthread will just start executing from whatever happens to be after the\ndisplaced stepping buffer.\n\nIn the original PR gdb/19675 bug report Yao Qi was seeing the new\nthread cause a segfault, the problem is, what actually happens is\ntotally undefined.\n\nOn my machine, I'm seeing the new thread reenter main, it then starts\ntrying to run the test again (in the new thread).  This just happens\nto be safe enough (in this simple test) that most of the time the\ninferior doesn't crash.\n\nIn this commit I try to make the test slightly more likely to fail by\ndoing a couple of things.\n\nFirst, I added a static variable to main, this is set true when the\nfirst thread enters main, if a second thread ever enters main then I\nforce an abort.\n\nSecond, when the test is finishing I want to ensure that the new\nthreads have had a chance to do \"something bad\" if they are going to.\nSo I added a global counter, as each thread starts successfully it\ndecrements the counter.  The main thread does not proceed to the final\nmarker function (where GDB has placed a breakpoint) until all threads\nhave started successfully.  This means that if the newly created\nthread doesn't successfully enter clone_fn then the counter will never\nreach zero and the test will timeout.\n\nWith these two changes my hope is that the test should fail more\nreliably, and so, I have also changed the test to call setup_kfail\nbefore the specific steps that we expect to misbehave instead of just\ncalling kfail and skipping parts of the test completely.  The benefit\nof this is that if/when we fix GDB this test will start to KPASS and\nwe'll know to update this test to remove the setup_kfail call.",
    "tree": {
      "sha": "6f852326d55fe9751528ea1c38cc57e585433f63",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6f852326d55fe9751528ea1c38cc57e585433f63"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/99ba4b64d3636533f3659a9c7d3e8504ca93c770",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/99ba4b64d3636533f3659a9c7d3e8504ca93c770",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/99ba4b64d3636533f3659a9c7d3e8504ca93c770",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/99ba4b64d3636533f3659a9c7d3e8504ca93c770/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "12488b1767ff74e710fb4d8feb1f4704812fb87a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/12488b1767ff74e710fb4d8feb1f4704812fb87a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/12488b1767ff74e710fb4d8feb1f4704812fb87a"
    }
  ],
  "stats": {
    "total": 108,
    "additions": 97,
    "deletions": 11
  },
  "files": [
    {
      "sha": "ef6fd922eb19b0a1b69e7796a7fb0538eaf5aada",
      "filename": "gdb/testsuite/gdb.base/step-over-clone.c",
      "status": "modified",
      "additions": 39,
      "deletions": 0,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/99ba4b64d3636533f3659a9c7d3e8504ca93c770/gdb/testsuite/gdb.base/step-over-clone.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/99ba4b64d3636533f3659a9c7d3e8504ca93c770/gdb/testsuite/gdb.base/step-over-clone.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/step-over-clone.c?ref=99ba4b64d3636533f3659a9c7d3e8504ca93c770",
      "patch": "@@ -19,16 +19,30 @@\n #include <stdlib.h>\n #include <unistd.h>\n #include <sched.h>\n+#include <pthread.h>\n \n static void\n marker ()\n {}\n \n #define STACK_SIZE 0x1000\n \n+/* These are used to signal that the threads have started correctly.  The\n+   GLOBAL_THREAD_COUNT is set to the number of threads in main, then\n+   decremented (under a lock) in each new thread.  */\n+pthread_mutex_t global_lock = PTHREAD_MUTEX_INITIALIZER;\n+int global_thread_count = 0;\n+\n static int\n clone_fn (void *unused)\n {\n+  /* Signal that this thread has started correctly.  */\n+  if (pthread_mutex_lock (&global_lock) != 0)\n+    abort ();\n+  global_thread_count--;\n+  if (pthread_mutex_unlock (&global_lock) != 0)\n+    abort ();\n+\n   return 0;\n }\n \n@@ -38,9 +52,21 @@ main (void)\n   int i, pid;\n   unsigned char *stack[6];\n \n+  /* Due to bug gdb/19675 the cloned thread _might_ try to reenter main\n+     (this depends on where the displaced instruction is placed for\n+     execution).  However, if we do reenter main then lets ensure we fail\n+     hard rather then just silently executing the code below.  */\n+  static int started = 0;\n+  if (!started)\n+    started = 1;\n+  else\n+    abort ();\n+\n   for (i = 0; i < (sizeof (stack) / sizeof (stack[0])); i++)\n     stack[i] = malloc (STACK_SIZE);\n \n+  global_thread_count = (sizeof (stack) / sizeof (stack[0]));\n+\n   for (i = 0; i < (sizeof (stack) / sizeof (stack[0])); i++)\n     {\n       pid = clone (clone_fn, stack[i] + STACK_SIZE, CLONE_FILES | CLONE_VM,\n@@ -50,5 +76,18 @@ main (void)\n   for (i = 0; i < (sizeof (stack) / sizeof (stack[0])); i++)\n     free (stack[i]);\n \n+  /* Set an alarm so we don't end up stuck waiting for threads that might\n+     never start correctly.  */\n+  alarm (120);\n+\n+  /* Now wait for all the threads to start up.  */\n+  while (global_thread_count != 0)\n+    {\n+      /* Force memory barrier so GLOBAL_THREAD_COUNT will be refetched.  */\n+      asm volatile (\"\" ::: \"memory\");\n+      sleep (1);\n+    }\n+\n+  /* Call marker, this is what GDB is waiting for.  */\n   marker ();\n }"
    },
    {
      "sha": "5d4a75f810b5ba02c425aa7e8ccc9a06588f03a2",
      "filename": "gdb/testsuite/gdb.base/step-over-syscall.exp",
      "status": "modified",
      "additions": 58,
      "deletions": 11,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/99ba4b64d3636533f3659a9c7d3e8504ca93c770/gdb/testsuite/gdb.base/step-over-syscall.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/99ba4b64d3636533f3659a9c7d3e8504ca93c770/gdb/testsuite/gdb.base/step-over-syscall.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/step-over-syscall.exp?ref=99ba4b64d3636533f3659a9c7d3e8504ca93c770",
      "patch": "@@ -41,11 +41,50 @@ if { [istarget \"i\\[34567\\]86-*-linux*\"] || [istarget \"x86_64-*-linux*\"] } {\n     return -1\n }\n \n-proc_with_prefix check_pc_after_cross_syscall { syscall syscall_insn_next_addr } {\n+proc_with_prefix check_pc_after_cross_syscall { displaced syscall syscall_insn_next_addr } {\n+    global gdb_prompt\n+\n     set syscall_insn_next_addr_found [get_hexadecimal_valueof \"\\$pc\" \"0\"]\n \n+    # After the 'stepi' we expect thread 1 to still be selected.\n+    # However, when displaced stepping over a clone bug gdb/19675\n+    # means this might not be the case.\n+    #\n+    # Which thread we end up in depends on a race between the original\n+    # thread-1, and the new thread (created by the clone), so we can't\n+    # guarantee which thread we will be in at this point.\n+    #\n+    # For the fork/vfork syscalls, which are correctly handled by\n+    # displaced stepping we will always be in thread-1 or the original\n+    # process at this point.\n+    set curr_thread \"unknown\"\n+    gdb_test_multiple \"info threads\" \"\" {\n+\t-re \"Id\\\\s+Target Id\\\\s+Frame\\\\s*\\r\\n\" {\n+\t    exp_continue\n+\t}\n+\t-re \"^\\\\* (\\\\d+)\\\\s+\\[^\\r\\n\\]+\\r\\n\" {\n+\t    set curr_thread $expect_out(1,string)\n+\t    exp_continue\n+\t}\n+\t-re \"^\\\\s+\\\\d+\\\\s+\\[^\\r\\n\\]+\\r\\n\" {\n+\t    exp_continue\n+\t}\n+\t-re \"$gdb_prompt \" {\n+\t}\n+    }\n+\n+    # If we are displaced stepping over a clone, and we ended up in\n+    # the wrong thread then the following check of the $pc value will\n+    # fail.\n+    if { $displaced == \"on\" && $syscall == \"clone\" && $curr_thread != 1 } {\n+\t# GDB doesn't support stepping over clone syscall with\n+\t# displaced stepping.\n+\tsetup_kfail \"*-*-*\" \"gdb/19675\"\n+    }\n+\n     gdb_assert {$syscall_insn_next_addr != 0 \\\n-      && $syscall_insn_next_addr == $syscall_insn_next_addr_found} \\\n+      && $syscall_insn_next_addr == $syscall_insn_next_addr_found \\\n+      && $curr_thread == 1} \\\n \t\"single step over $syscall final pc\"\n }\n \n@@ -203,7 +242,12 @@ proc step_over_syscall { syscall } {\n \n \tset testfile \"step-over-$syscall\"\n \n-\tif [build_executable ${testfile}.exp ${testfile} ${testfile}.c {debug}] {\n+\tset options [list debug]\n+\tif { $syscall == \"clone\" } {\n+\t    lappend options \"pthreads\"\n+\t}\n+\n+\tif [build_executable ${testfile}.exp ${testfile} ${testfile}.c $options] {\n \t    untested \"failed to compile\"\n \t    return -1\n \t}\n@@ -213,13 +257,6 @@ proc step_over_syscall { syscall } {\n \t\tcontinue\n \t    }\n \n-\t    if { $displaced == \"on\" && $syscall == \"clone\" } {\n-\t\t# GDB doesn't support stepping over clone syscall with\n-\t\t# displaced stepping.\n-\t\tkfail \"gdb/19675\" \"single step over clone\"\n-\t\tcontinue\n-\t    }\n-\n \t    set ret [setup $syscall]\n \n \t    set syscall_insn_addr [lindex $ret 0]\n@@ -256,12 +293,22 @@ proc step_over_syscall { syscall } {\n \t    if {[gdb_test \"stepi\" \"x/i .*=>.*\" \"single step over $syscall\"] != 0} {\n \t\treturn -1\n \t    }\n-\t    check_pc_after_cross_syscall $syscall $syscall_insn_next_addr\n+\t    check_pc_after_cross_syscall $displaced $syscall $syscall_insn_next_addr\n \n \t    # Delete breakpoint syscall insns to avoid interference to other syscalls.\n \t    delete_breakpoints\n \n \t    gdb_test \"break marker\" \"Breakpoint.*at.* file .*${testfile}.c, line.*\"\n+\n+\t    # If we are displaced stepping over a clone syscall then\n+\t    # we expect the following check to fail.  See also the\n+\t    # code in check_pc_after_cross_syscall.\n+\t    if { $displaced == \"on\" && $syscall == \"clone\" } {\n+\t\t# GDB doesn't support stepping over clone syscall with\n+\t\t# displaced stepping.\n+\t\tsetup_kfail \"*-*-*\" \"gdb/19675\"\n+\t    }\n+\n \t    gdb_test \"continue\" \"Continuing\\\\..*Breakpoint \\[0-9\\]+, marker \\\\(\\\\) at.*\" \\\n \t\t\"continue to marker ($syscall)\"\n \t}"
    }
  ]
}