{
  "sha": "63c457b911043aa6ebf3558e2d2050ee53d28a8e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjNjNDU3YjkxMTA0M2FhNmViZjM1NThlMmQyMDUwZWU1M2QyOGE4ZQ==",
  "commit": {
    "author": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2020-12-06T04:56:59Z"
    },
    "committer": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2020-12-06T04:56:59Z"
    },
    "message": "gmp-utils: protect gdb_mpz exports against out-of-range values\n\nThe gdb_mpz class currently provides a couple of methods which\nessentially export an mpz_t value into either a buffer, or an integral\ntype. The export is based on using the mpz_export function which\nwe discovered can be a bit treacherous if used without caution.\n\nIn particular, the initial motivation for this patch was to catch\nsituations where the mpz_t value was so large that it would not fit\nin the destination area. mpz_export does not know the size of\nthe buffer, and therefore can happily write past the end of our buffer.\n\nWhile designing a solution to the above problem, I also discovered\nthat we also needed to be careful when exporting signed numbers.\nIn particular, numbers which are larger than the maximum value\nfor a given signed type size, but no so large as to fit in the\n*unsigned* version with the same size, would end up being exported\nincorrectly. This is related to the fact that mpz_export ignores\nthe sign of the value being exportd, and assumes an unsigned export.\nThus, for such large values, the appears as if mpz_export is able\nto fit our value into our buffer, but in fact, it does not.\n\nAlso, I noticed that gdb_mpz::write wasn't taking its unsigned_p\nparameter, which was a hole.\n\nFor all these reasons, a new low-level private method called\n\"safe_export\" has been added to class gdb_mpz, whose goal is\nto perform all necessary checks and manipulations for a safe\nand correct export. As a bonus, this method allows us to factorize\nthe handling of negative value exports.\n\nThe gdb_mpz::as_integer and gdb_mpz::write methods are then simplified\nto take advantage of this new safe_export method.\n\ngdb/ChangeLog:\n\n        * gmp-utils.h (gdb_mpz::safe_export): New private method.\n        (gdb_mpz::as_integer): Reimplement using gdb_mpz::safe_export.\n        * gmp-utils.c (gdb_mpz::write): Rewrite using gdb_mpz::safe_export.\n        (gdb_mpz::safe_export): New method.\n        * unittests/gmp-utils-selftests .c (gdb_mpz_as_integer):\n        Update function description.\n        (check_as_integer_raises_out_of_range_error): New function.\n        (gdb_mpz_as_integer_out_of_range): New function.\n        (_initialize_gmp_utils_selftests): Register\n        gdb_mpz_as_integer_out_of_range as a selftest.",
    "tree": {
      "sha": "c398cb09dc5e8fa3c217f18bd907cfa08a9cff99",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c398cb09dc5e8fa3c217f18bd907cfa08a9cff99"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/63c457b911043aa6ebf3558e2d2050ee53d28a8e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/63c457b911043aa6ebf3558e2d2050ee53d28a8e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/63c457b911043aa6ebf3558e2d2050ee53d28a8e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/63c457b911043aa6ebf3558e2d2050ee53d28a8e/comments",
  "author": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6b1dce3a3d0c853dc11db2f942038af792cb7b3f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6b1dce3a3d0c853dc11db2f942038af792cb7b3f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6b1dce3a3d0c853dc11db2f942038af792cb7b3f"
    }
  ],
  "stats": {
    "total": 203,
    "additions": 174,
    "deletions": 29
  },
  "files": [
    {
      "sha": "d8b67c6733bd9067cf52b2251872e1ea4d536fc8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63c457b911043aa6ebf3558e2d2050ee53d28a8e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63c457b911043aa6ebf3558e2d2050ee53d28a8e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=63c457b911043aa6ebf3558e2d2050ee53d28a8e",
      "patch": "@@ -1,3 +1,16 @@\n+2020-12-06  Joel Brobecker  <brobecker@adacore.com>\n+\n+\t* gmp-utils.h (gdb_mpz::safe_export): New private method.\n+\t(gdb_mpz::as_integer): Reimplement using gdb_mpz::safe_export.\n+\t* gmp-utils.c (gdb_mpz::write): Rewrite using gdb_mpz::safe_export.\n+\t(gdb_mpz::safe_export): New method.\n+\t* unittests/gmp-utils-selftests .c (gdb_mpz_as_integer):\n+\tUpdate function description.\n+\t(check_as_integer_raises_out_of_range_error): New function.\n+\t(gdb_mpz_as_integer_out_of_range): New function.\n+\t(_initialize_gmp_utils_selftests): Register\n+\tgdb_mpz_as_integer_out_of_range as a selftest.\n+\n 2020-12-05  Joel Brobecker  <brobecker@adacore.com>\n \n \t* gmp-utils.c (gdb_mpz::read): Use HOST_CHAR_BIT instead of"
    },
    {
      "sha": "60c915cb375d7ad57183edac3d12cde3cb6000ed",
      "filename": "gdb/gmp-utils.c",
      "status": "modified",
      "additions": 71,
      "deletions": 8,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63c457b911043aa6ebf3558e2d2050ee53d28a8e/gdb/gmp-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63c457b911043aa6ebf3558e2d2050ee53d28a8e/gdb/gmp-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gmp-utils.c?ref=63c457b911043aa6ebf3558e2d2050ee53d28a8e",
      "patch": "@@ -68,9 +68,61 @@ void\n gdb_mpz::write (gdb::array_view<gdb_byte> buf, enum bfd_endian byte_order,\n \t\tbool unsigned_p) const\n {\n+  this->safe_export\n+    (buf, byte_order == BFD_ENDIAN_BIG ? 1 : -1 /* endian */, unsigned_p);\n+}\n+\n+/* See gmp-utils.h.  */\n+\n+void\n+gdb_mpz::safe_export (gdb::array_view<gdb_byte> buf,\n+\t\t      int endian, bool unsigned_p) const\n+{\n+  gdb_assert (buf.size () > 0);\n+\n+  if (mpz_sgn (val) == 0)\n+    {\n+      /* Our value is zero, so no need to call mpz_export to do the work,\n+\t especially since mpz_export's documentation explicitly says\n+\t that the function is a noop in this case.  Just write zero to\n+\t BUF ourselves.  */\n+      memset (buf.data (), 0, buf.size ());\n+      return;\n+    }\n+\n+  /* Determine the maximum range of values that our buffer can hold,\n+     and verify that VAL is within that range.  */\n+\n+  gdb_mpz lo, hi;\n+  const size_t max_usable_bits = buf.size () * HOST_CHAR_BIT;\n+  if (unsigned_p)\n+    {\n+      lo = 0;\n+\n+      mpz_ui_pow_ui (hi.val, 2, max_usable_bits);\n+      mpz_sub_ui (hi.val, hi.val, 1);\n+    }\n+  else\n+    {\n+      mpz_ui_pow_ui (lo.val, 2, max_usable_bits - 1);\n+      mpz_neg (lo.val, lo.val);\n+\n+      mpz_ui_pow_ui (hi.val, 2, max_usable_bits - 1);\n+      mpz_sub_ui (hi.val, hi.val, 1);\n+    }\n+\n+  if (mpz_cmp (val, lo.val) < 0 || mpz_cmp (val, hi.val) > 0)\n+    error (_(\"Cannot export value %s as %zu-bits %s integer\"\n+\t     \" (must be between %s and %s)\"),\n+\t   this->str ().c_str (),\n+\t   max_usable_bits,\n+\t   unsigned_p ? _(\"unsigned\") : _(\"signed\"),\n+\t   lo.str ().c_str (),\n+\t   hi.str ().c_str ());\n+\n   gdb_mpz exported_val (val);\n \n-  if (mpz_cmp_ui (val, 0) < 0)\n+  if (mpz_cmp_ui (exported_val.val, 0) < 0)\n     {\n       /* mpz_export does not handle signed values, so create a positive\n \t value whose bit representation as an unsigned of the same length\n@@ -81,13 +133,24 @@ gdb_mpz::write (gdb::array_view<gdb_byte> buf, enum bfd_endian byte_order,\n       mpz_add (exported_val.val, exported_val.val, neg_offset.val);\n     }\n \n-  /* Start by clearing the buffer, as mpz_export only writes as many\n-     bytes as it needs (including none, if the value to export is zero.  */\n-  memset (buf.data (), 0, buf.size ());\n-  mpz_export (buf.data (), NULL /* count */, -1 /* order */,\n-\t      buf.size () /* size */,\n-\t      byte_order == BFD_ENDIAN_BIG ? 1 : -1 /* endian */,\n-\t      0 /* nails */, exported_val.val);\n+  /* Do the export into a buffer allocated by GMP itself; that way,\n+     we can detect cases where BUF is not large enough to export\n+     our value, and thus avoid a buffer overlow.  Normally, this should\n+     never happen, since we verified earlier that the buffer is large\n+     enough to accomodate our value, but doing this allows us to be\n+     extra safe with the export.\n+\n+     After verification that the export behaved as expected, we will\n+     copy the data over to BUF.  */\n+\n+  size_t word_countp;\n+  gdb::unique_xmalloc_ptr<void> exported\n+    (mpz_export (NULL, &word_countp, -1 /* order */, buf.size () /* size */,\n+\t\t endian, 0 /* nails */, exported_val.val));\n+\n+  gdb_assert (word_countp == 1);\n+\n+  memcpy (buf.data (), exported.get (), buf.size ());\n }\n \n /* See gmp-utils.h.  */"
    },
    {
      "sha": "dae62cf5ea38f8d0c294d9b655f88d11fe606239",
      "filename": "gdb/gmp-utils.h",
      "status": "modified",
      "additions": 22,
      "deletions": 18,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63c457b911043aa6ebf3558e2d2050ee53d28a8e/gdb/gmp-utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63c457b911043aa6ebf3558e2d2050ee53d28a8e/gdb/gmp-utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gmp-utils.h?ref=63c457b911043aa6ebf3558e2d2050ee53d28a8e",
      "patch": "@@ -121,6 +121,24 @@ struct gdb_mpz\n \n   /* Helper template for constructor and operator=.  */\n   template<typename T> void set (T src);\n+\n+  /* Low-level function to export VAL into BUF as a number whose byte size\n+     is the size of BUF.\n+\n+     If UNSIGNED_P is true, then export VAL into BUF as an unsigned value.\n+     Otherwise, export it as a signed value.\n+\n+     The API is inspired from GMP's mpz_export, hence the naming and types\n+     of the following parameter:\n+       - ENDIAN should be:\n+           . 1 for most significant byte first; or\n+\t   . -1 for least significant byte first; or\n+\t   . 0 for native endianness.\n+\n+    An error is raised if BUF is not large enough to contain the value\n+    being exported.  */\n+  void safe_export (gdb::array_view<gdb_byte> buf,\n+\t\t    int endian, bool unsigned_p) const;\n };\n \n /* A class to make it easier to use GMP's mpq_t values within GDB.  */\n@@ -258,26 +276,12 @@ template<typename T>\n T\n gdb_mpz::as_integer () const\n {\n-  /* Initialize RESULT, because mpz_export only write the minimum\n-     number of bytes, including none if our value is zero!  */\n-  T result = 0;\n-\n-  gdb_mpz exported_val (val);\n-  if (std::is_signed<T>::value && mpz_cmp_ui (val, 0) < 0)\n-    {\n-      /* We want to use mpz_export to set the return value, but\n-\t this function does not handle the sign. So give exported_val\n-\t a value which is at the same time positive, and has the same\n-\t bit representation as our negative value.  */\n-      gdb_mpz neg_offset;\n+  T result;\n \n-      mpz_ui_pow_ui (neg_offset.val, 2, sizeof (T) * HOST_CHAR_BIT);\n-      mpz_add (exported_val.val, exported_val.val, neg_offset.val);\n-    }\n+  this->safe_export ({(gdb_byte *) &result, sizeof (result)},\n+\t\t     0 /* endian (0 = native) */,\n+\t\t     !std::is_signed<T>::value /* unsigned_p */);\n \n-  mpz_export (&result, NULL /* count */, -1 /* order */,\n-\t      sizeof (T) /* size */, 0 /* endian (0 = native) */,\n-\t      0 /* nails */, exported_val.val);\n   return result;\n }\n "
    },
    {
      "sha": "30c190273e7cd4c79ddc77432d112827c1676efc",
      "filename": "gdb/unittests/gmp-utils-selftests.c",
      "status": "modified",
      "additions": 68,
      "deletions": 3,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/63c457b911043aa6ebf3558e2d2050ee53d28a8e/gdb/unittests/gmp-utils-selftests.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/63c457b911043aa6ebf3558e2d2050ee53d28a8e/gdb/unittests/gmp-utils-selftests.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/unittests/gmp-utils-selftests.c?ref=63c457b911043aa6ebf3558e2d2050ee53d28a8e",
      "patch": "@@ -26,9 +26,10 @@ namespace selftests {\n \n /* Perform a series of general tests of gdb_mpz's as_integer method.\n \n-   This function tries to be reasonably exhaustive, by testing the edges,\n-   as well as a resonable set of values including negative ones, zero,\n-   and positive values.  */\n+   This function limits itself to values which are in range (out-of-range\n+   values will be tested separately).  In doing so, it tries to be reasonably\n+   exhaustive, by testing the edges, as well as a resonable set of values\n+   including negative ones, zero, and positive values.  */\n \n static void\n gdb_mpz_as_integer ()\n@@ -80,6 +81,68 @@ gdb_mpz_as_integer ()\n   SELF_CHECK (v.as_integer<ULONGEST> () == ul_expected);\n }\n \n+/* A helper function which calls the given gdb_mpz object's as_integer\n+   method with the given type T, and verifies that this triggers\n+   an error due to VAL's value being out of range for type T.  */\n+\n+template<typename T, typename = gdb::Requires<std::is_integral<T>>>\n+static void\n+check_as_integer_raises_out_of_range_error (const gdb_mpz &val)\n+{\n+  try\n+    {\n+      val.as_integer<T> ();\n+    }\n+  catch (const gdb_exception_error &ex)\n+    {\n+      SELF_CHECK (ex.reason == RETURN_ERROR);\n+      SELF_CHECK (ex.error == GENERIC_ERROR);\n+      SELF_CHECK (strstr (ex.what (), \"Cannot export value\") != nullptr);\n+      return;\n+    }\n+  /* The expected exception did not get raised.  */\n+  SELF_CHECK (false);\n+}\n+\n+/* Perform out-of-range tests of gdb_mpz's as_integer method.\n+\n+   The goal of this function is to verify that gdb_mpz::as_integer\n+   handles out-of-range values correctly.  */\n+\n+static void\n+gdb_mpz_as_integer_out_of_range ()\n+{\n+  gdb_mpz v;\n+\n+  /* Try LONGEST_MIN minus 1.  */\n+  mpz_ui_pow_ui (v.val, 2, sizeof (LONGEST) * 8 - 1);\n+  mpz_neg (v.val, v.val);\n+  mpz_sub_ui (v.val, v.val, 1);\n+\n+  check_as_integer_raises_out_of_range_error<ULONGEST> (v);\n+  check_as_integer_raises_out_of_range_error<LONGEST> (v);\n+\n+  /* Try negative one (-1). */\n+  v = -1;\n+\n+  check_as_integer_raises_out_of_range_error<ULONGEST> (v);\n+  SELF_CHECK (v.as_integer<LONGEST> () == (LONGEST) -1);\n+\n+  /* Try LONGEST_MAX plus 1.  */\n+  v = LONGEST_MAX;\n+  mpz_add_ui (v.val, v.val, 1);\n+\n+  SELF_CHECK (v.as_integer<ULONGEST> () == (ULONGEST) LONGEST_MAX + 1);\n+  check_as_integer_raises_out_of_range_error<LONGEST> (v);\n+\n+  /* Try ULONGEST_MAX plus 1.  */\n+  v = ULONGEST_MAX;\n+  mpz_add_ui (v.val, v.val, 1);\n+\n+  check_as_integer_raises_out_of_range_error<ULONGEST> (v);\n+  check_as_integer_raises_out_of_range_error<LONGEST> (v);\n+}\n+\n /* A helper function to store the given integer value into a buffer,\n    before reading it back into a gdb_mpz.  Sets ACTUAL to the value\n    read back, while at the same time setting EXPECTED as the value\n@@ -445,6 +508,8 @@ _initialize_gmp_utils_selftests ()\n {\n   selftests::register_test (\"gdb_mpz_as_integer\",\n \t\t\t    selftests::gdb_mpz_as_integer);\n+  selftests::register_test (\"gdb_mpz_as_integer_out_of_range\",\n+\t\t\t    selftests::gdb_mpz_as_integer_out_of_range);\n   selftests::register_test (\"gdb_mpz_read_all_from_small\",\n \t\t\t    selftests::gdb_mpz_read_all_from_small);\n   selftests::register_test (\"gdb_mpz_read_min_max\","
    }
  ]
}