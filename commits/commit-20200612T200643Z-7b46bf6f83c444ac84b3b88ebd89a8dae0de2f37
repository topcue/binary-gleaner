{
  "sha": "7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2I0NmJmNmY4M2M0NDRhYzg0YjNiODhlYmQ4OWE4ZGFlMGRlMmYzNw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-12T20:06:43Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-12T20:06:43Z"
    },
    "message": "gdbserver: remove support for CRIS\n\nThis port has been unmaintained for years and the upstream Linux kernel\ndoes not support this architecture anymore, remove it.\n\ngdbserver/ChangeLog:\n\n\t* Makefile.in (SFILES): Remove linux-cris-low.c.\n\t* configure.srv: Remove cris cases.\n\t* linux-cris-low.cc, linux-crisv32-low.cc: Remove.\n\nChange-Id: Ib3ff436b03373548215f15540a47f39cbec5f512",
    "tree": {
      "sha": "c9c50a58978375b4b159613dfe29e0d65963ea75",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c9c50a58978375b4b159613dfe29e0d65963ea75"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1fa29f56baa741dd9a9238cf848927a7a7d83d6d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1fa29f56baa741dd9a9238cf848927a7a7d83d6d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1fa29f56baa741dd9a9238cf848927a7a7d83d6d"
    }
  ],
  "stats": {
    "total": 659,
    "additions": 6,
    "deletions": 653
  },
  "files": [
    {
      "sha": "c857f0014041097b29e6fe27e1fbd893a7a0198a",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37",
      "patch": "@@ -1,3 +1,9 @@\n+2020-06-12  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* Makefile.in (SFILES): Remove linux-cris-low.c.\n+\t* configure.srv: Remove cris cases.\n+\t* linux-cris-low.cc, linux-crisv32-low.cc: Remove.\n+\n 2020-06-12  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* Makefile.in (SFILES): Remove linux-bfin-low.c."
    },
    {
      "sha": "329962938173a34c8baf1af62d1a13f46fc9326f",
      "filename": "gdbserver/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37/gdbserver/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37/gdbserver/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/Makefile.in?ref=7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37",
      "patch": "@@ -180,8 +180,6 @@ SFILES = \\\n \t$(srcdir)/inferiors.cc \\\n \t$(srcdir)/linux-aarch64-low.cc \\\n \t$(srcdir)/linux-arm-low.cc \\\n-\t$(srcdir)/linux-cris-low.cc \\\n-\t$(srcdir)/linux-crisv32-low.cc \\\n \t$(srcdir)/linux-ia64-low.cc \\\n \t$(srcdir)/linux-low.cc \\\n \t$(srcdir)/linux-m32r-low.cc \\"
    },
    {
      "sha": "e362c961703f253165f9f20b36e46a0fe645a99f",
      "filename": "gdbserver/configure.srv",
      "status": "modified",
      "additions": 0,
      "deletions": 10,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37/gdbserver/configure.srv",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37/gdbserver/configure.srv",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure.srv?ref=7b46bf6f83c444ac84b3b88ebd89a8dae0de2f37",
      "patch": "@@ -81,16 +81,6 @@ case \"${gdbserver_host}\" in\n \t\t\tsrv_mingw=yes\n \t\t\tsrv_mingwce=yes\n \t\t\t;;\n-  crisv32-*-linux*)\tsrv_regobj=reg-crisv32.o\n-\t\t\tsrv_tgtobj=\"$srv_linux_obj linux-crisv32-low.o\"\n-\t\t\tsrv_linux_regsets=yes\n-\t\t\tsrv_linux_thread_db=yes\n-\t\t\t;;\n-  cris-*-linux*)\tsrv_regobj=reg-cris.o\n-\t\t\tsrv_tgtobj=\"$srv_linux_obj linux-cris-low.o\"\n-\t\t\tsrv_linux_usrregs=yes\n-\t\t\tsrv_linux_thread_db=yes\n-\t\t\t;;\n   i[34567]86-*-cygwin*)\tsrv_regobj=\"\"\n \t\t\tsrv_tgtobj=\"x86-low.o nat/x86-dregs.o win32-low.o\"\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} win32-i386-low.o\""
    },
    {
      "sha": "555941414e0eed1e16fb7bd39abec98c5bd8104e",
      "filename": "gdbserver/linux-cris-low.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 169,
      "changes": 169,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1fa29f56baa741dd9a9238cf848927a7a7d83d6d/gdbserver/linux-cris-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1fa29f56baa741dd9a9238cf848927a7a7d83d6d/gdbserver/linux-cris-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-cris-low.cc?ref=1fa29f56baa741dd9a9238cf848927a7a7d83d6d",
      "patch": "@@ -1,169 +0,0 @@\n-/* GNU/Linux/CRIS specific low level interface, for the remote server for GDB.\n-   Copyright (C) 1995-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"server.h\"\n-#include \"linux-low.h\"\n-#include \"nat/gdb_ptrace.h\"\n-\n-/* Linux target op definitions for the CRIS architecture.  */\n-\n-class cris_target : public linux_process_target\n-{\n-public:\n-\n-  const regs_info *get_regs_info () override;\n-\n-  const gdb_byte *sw_breakpoint_from_kind (int kind, int *size) override;\n-\n-protected:\n-\n-  void low_arch_setup () override;\n-\n-  bool low_cannot_fetch_register (int regno) override;\n-\n-  bool low_cannot_store_register (int regno) override;\n-\n-  bool low_supports_breakpoints () override;\n-\n-  CORE_ADDR low_get_pc (regcache *regcache) override;\n-\n-  void low_set_pc (regcache *regcache, CORE_ADDR newpc) override;\n-\n-  bool low_breakpoint_at (CORE_ADDR pc) override;\n-};\n-\n-/* The singleton target ops object.  */\n-\n-static cris_target the_cris_target;\n-\n-bool\n-cris_target::low_supports_breakpoints ()\n-{\n-  return true;\n-}\n-\n-CORE_ADDR\n-cris_target::low_get_pc (regcache *regcache)\n-{\n-  return linux_get_pc_32bit (regcache);\n-}\n-\n-void\n-cris_target::low_set_pc (regcache *regcache, CORE_ADDR pc)\n-{\n-  linux_set_pc_32bit (regcache, pc);\n-}\n-\n-/* Defined in auto-generated file reg-cris.c.  */\n-void init_registers_cris (void);\n-extern const struct target_desc *tdesc_cris;\n-\n-/* CRISv10 */\n-#define cris_num_regs 32\n-\n-/* Locations need to match <include/asm/arch/ptrace.h>.  */\n-static int cris_regmap[] = {\n-  15*4, 14*4, 13*4, 12*4,\n-  11*4, 10*4, 9*4, 8*4,\n-  7*4, 6*4, 5*4, 4*4,\n-  3*4, 2*4, 23*4, 19*4,\n-\n-  -1, -1, -1, -1,\n-  -1, 17*4, -1, 16*4,\n-  -1, -1, -1, 18*4,\n-  -1, 17*4, -1, -1\n-\n-};\n-\n-bool\n-cris_target::low_cannot_store_register (int regno)\n-{\n-  if (cris_regmap[regno] == -1)\n-    return true;\n-\n-  return (regno >= cris_num_regs);\n-}\n-\n-bool\n-cris_target::low_cannot_fetch_register (int regno)\n-{\n-  if (cris_regmap[regno] == -1)\n-    return true;\n-\n-  return (regno >= cris_num_regs);\n-}\n-\n-static const unsigned short cris_breakpoint = 0xe938;\n-#define cris_breakpoint_len 2\n-\n-/* Implementation of target ops method \"sw_breakpoint_from_kind\".  */\n-\n-const gdb_byte *\n-cris_target::sw_breakpoint_from_kind (int kind, int *size)\n-{\n-  *size = cris_breakpoint_len;\n-  return (const gdb_byte *) &cris_breakpoint;\n-}\n-\n-bool\n-cris_target::low_breakpoint_at (CORE_ADDR where)\n-{\n-  unsigned short insn;\n-\n-  read_memory (where, (unsigned char *) &insn, cris_breakpoint_len);\n-  if (insn == cris_breakpoint)\n-    return true;\n-\n-  /* If necessary, recognize more trap instructions here.  GDB only uses the\n-     one.  */\n-  return false;\n-}\n-\n-void\n-cris_target::low_arch_setup ()\n-{\n-  current_process ()->tdesc = tdesc_cris;\n-}\n-\n-static struct usrregs_info cris_usrregs_info =\n-  {\n-    cris_num_regs,\n-    cris_regmap,\n-  };\n-\n-static struct regs_info myregs_info =\n-  {\n-    NULL, /* regset_bitmap */\n-    &cris_usrregs_info,\n-  };\n-\n-const regs_info *\n-cris_target::get_regs_info ()\n-{\n-  return &myregs_info;\n-}\n-\n-/* The linux target ops object.  */\n-\n-linux_process_target *the_linux_target = &the_cris_target;\n-\n-void\n-initialize_low_arch (void)\n-{\n-  init_registers_cris ();\n-}"
    },
    {
      "sha": "577039ae2dbc4cf0ec899a873faa4c0db42d746b",
      "filename": "gdbserver/linux-crisv32-low.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 472,
      "changes": 472,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1fa29f56baa741dd9a9238cf848927a7a7d83d6d/gdbserver/linux-crisv32-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1fa29f56baa741dd9a9238cf848927a7a7d83d6d/gdbserver/linux-crisv32-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-crisv32-low.cc?ref=1fa29f56baa741dd9a9238cf848927a7a7d83d6d",
      "patch": "@@ -1,472 +0,0 @@\n-/* GNU/Linux/CRIS specific low level interface, for the remote server for GDB.\n-   Copyright (C) 1995-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"server.h\"\n-#include \"linux-low.h\"\n-#include \"nat/gdb_ptrace.h\"\n-\n-/* Linux target op definitions for the CRIS architecture.  */\n-\n-class crisv32_target : public linux_process_target\n-{\n-public:\n-\n-  const regs_info *get_regs_info () override;\n-\n-  const gdb_byte *sw_breakpoint_from_kind (int kind, int *size) override;\n-\n-  bool supports_z_point_type (char z_type) override;\n-\n-protected:\n-\n-  void low_arch_setup () override;\n-\n-  bool low_cannot_fetch_register (int regno) override;\n-\n-  bool low_cannot_store_register (int regno) override;\n-\n-  bool low_supports_breakpoints () override;\n-\n-  CORE_ADDR low_get_pc (regcache *regcache) override;\n-\n-  void low_set_pc (regcache *regcache, CORE_ADDR newpc) override;\n-\n-  bool low_breakpoint_at (CORE_ADDR pc) override;\n-\n-  int low_insert_point (raw_bkpt_type type, CORE_ADDR addr,\n-\t\t\tint size, raw_breakpoint *bp) override;\n-\n-  int low_remove_point (raw_bkpt_type type, CORE_ADDR addr,\n-\t\t\tint size, raw_breakpoint *bp) override;\n-\n-  bool low_stopped_by_watchpoint () override;\n-\n-  CORE_ADDR low_stopped_data_address () override;\n-};\n-\n-/* The singleton target ops object.  */\n-\n-static crisv32_target the_crisv32_target;\n-\n-bool\n-crisv32_target::low_cannot_fetch_register (int regno)\n-{\n-  gdb_assert_not_reached (\"linux target op low_cannot_fetch_register \"\n-\t\t\t  \"is not implemented by the target\");\n-}\n-\n-bool\n-crisv32_target::low_cannot_store_register (int regno)\n-{\n-  gdb_assert_not_reached (\"linux target op low_cannot_store_register \"\n-\t\t\t  \"is not implemented by the target\");\n-}\n-\n-bool\n-crisv32_target::low_supports_breakpoints ()\n-{\n-  return true;\n-}\n-\n-CORE_ADDR\n-crisv32_target::low_get_pc (regcache *regcache)\n-{\n-  return linux_get_pc_32bit (regcache);\n-}\n-\n-void\n-crisv32_target::low_set_pc (regcache *regcache, CORE_ADDR pc)\n-{\n-  linux_set_pc_32bit (regcache, pc);\n-}\n-\n-/* Defined in auto-generated file reg-crisv32.c.  */\n-void init_registers_crisv32 (void);\n-extern const struct target_desc *tdesc_crisv32;\n-\n-/* CRISv32 */\n-#define cris_num_regs 49\n-\n-#ifndef PTRACE_GET_THREAD_AREA\n-#define PTRACE_GET_THREAD_AREA 25\n-#endif\n-\n-/* Note: Ignoring USP (having the stack pointer in two locations causes trouble\n-   without any significant gain).  */\n-\n-/* Locations need to match <include/asm/arch/ptrace.h>.  */\n-static int cris_regmap[] = {\n-  1*4, 2*4, 3*4, 4*4,\n-  5*4, 6*4, 7*4, 8*4,\n-  9*4, 10*4, 11*4, 12*4,\n-  13*4, 14*4, 24*4, 15*4,\n-\n-  -1, -1, -1, 16*4,\n-  -1, 22*4, 23*4, 17*4,\n-  -1, -1, 21*4, 20*4,\n-  -1, 19*4, -1, 18*4,\n-\n-  25*4,\n-\n-  26*4, -1,   -1,   29*4,\n-  30*4, 31*4, 32*4, 33*4,\n-  34*4, 35*4, 36*4, 37*4,\n-  38*4, 39*4, 40*4, -1\n-\n-};\n-\n-static const unsigned short cris_breakpoint = 0xe938;\n-#define cris_breakpoint_len 2\n-\n-/* Implementation of target ops method \"sw_breakpoint_from_kind\".  */\n-\n-const gdb_byte *\n-crisv32_target::sw_breakpoint_from_kind (int kind, int *size)\n-{\n-  *size = cris_breakpoint_len;\n-  return (const gdb_byte *) &cris_breakpoint;\n-}\n-\n-bool\n-crisv32_target::low_breakpoint_at (CORE_ADDR where)\n-{\n-  unsigned short insn;\n-\n-  read_memory (where, (unsigned char *) &insn, cris_breakpoint_len);\n-  if (insn == cris_breakpoint)\n-    return true;\n-\n-  /* If necessary, recognize more trap instructions here.  GDB only uses the\n-     one.  */\n-  return false;\n-}\n-\n-static void\n-cris_write_data_breakpoint (struct regcache *regcache,\n-\t\t\t    int bp, unsigned long start, unsigned long end)\n-{\n-  switch (bp)\n-    {\n-    case 0:\n-      supply_register_by_name (regcache, \"s3\", &start);\n-      supply_register_by_name (regcache, \"s4\", &end);\n-      break;\n-    case 1:\n-      supply_register_by_name (regcache, \"s5\", &start);\n-      supply_register_by_name (regcache, \"s6\", &end);\n-      break;\n-    case 2:\n-      supply_register_by_name (regcache, \"s7\", &start);\n-      supply_register_by_name (regcache, \"s8\", &end);\n-      break;\n-    case 3:\n-      supply_register_by_name (regcache, \"s9\", &start);\n-      supply_register_by_name (regcache, \"s10\", &end);\n-      break;\n-    case 4:\n-      supply_register_by_name (regcache, \"s11\", &start);\n-      supply_register_by_name (regcache, \"s12\", &end);\n-      break;\n-    case 5:\n-      supply_register_by_name (regcache, \"s13\", &start);\n-      supply_register_by_name (regcache, \"s14\", &end);\n-      break;\n-    }\n-}\n-\n-bool\n-crisv32_target::supports_z_point_type (char z_type)\n-{\n-  switch (z_type)\n-    {\n-    case Z_PACKET_WRITE_WP:\n-    case Z_PACKET_READ_WP:\n-    case Z_PACKET_ACCESS_WP:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-int\n-crisv32_target::low_insert_point (raw_bkpt_type type, CORE_ADDR addr,\n-\t\t\t\t  int len, raw_breakpoint *bp)\n-{\n-  int bp;\n-  unsigned long bp_ctrl;\n-  unsigned long start, end;\n-  unsigned long ccs;\n-  struct regcache *regcache;\n-\n-  regcache = get_thread_regcache (current_thread, 1);\n-\n-  /* Read watchpoints are set as access watchpoints, because of GDB's\n-     inability to deal with pure read watchpoints.  */\n-  if (type == raw_bkpt_type_read_wp)\n-    type = raw_bkpt_type_access_wp;\n-\n-  /* Get the configuration register.  */\n-  collect_register_by_name (regcache, \"s0\", &bp_ctrl);\n-\n-  /* The watchpoint allocation scheme is the simplest possible.\n-     For example, if a region is watched for read and\n-     a write watch is requested, a new watchpoint will\n-     be used.  Also, if a watch for a region that is already\n-     covered by one or more existing watchpoints, a new\n-     watchpoint will be used.  */\n-\n-  /* First, find a free data watchpoint.  */\n-  for (bp = 0; bp < 6; bp++)\n-    {\n-      /* Each data watchpoint's control registers occupy 2 bits\n-\t (hence the 3), starting at bit 2 for D0 (hence the 2)\n-\t with 4 bits between for each watchpoint (yes, the 4).  */\n-      if (!(bp_ctrl & (0x3 << (2 + (bp * 4)))))\n-\tbreak;\n-    }\n-\n-  if (bp > 5)\n-    {\n-      /* We're out of watchpoints.  */\n-      return -1;\n-    }\n-\n-  /* Configure the control register first.  */\n-  if (type == raw_bkpt_type_read_wp || type == raw_bkpt_type_access_wp)\n-    {\n-      /* Trigger on read.  */\n-      bp_ctrl |= (1 << (2 + bp * 4));\n-    }\n-  if (type == raw_bkpt_type_write_wp || type == raw_bkpt_type_access_wp)\n-    {\n-      /* Trigger on write.  */\n-      bp_ctrl |= (2 << (2 + bp * 4));\n-    }\n-\n-  /* Setup the configuration register.  */\n-  supply_register_by_name (regcache, \"s0\", &bp_ctrl);\n-\n-  /* Setup the range.  */\n-  start = addr;\n-  end = addr + len - 1;\n-\n-  /* Configure the watchpoint register.  */\n-  cris_write_data_breakpoint (regcache, bp, start, end);\n-\n-  collect_register_by_name (regcache, \"ccs\", &ccs);\n-  /* Set the S1 flag to enable watchpoints.  */\n-  ccs |= (1 << 19);\n-  supply_register_by_name (regcache, \"ccs\", &ccs);\n-\n-  return 0;\n-}\n-\n-int\n-crisv32_target::low_remove_point (raw_bkpt_type type, CORE_ADDR addr,\n-\t\t\t\t  int len, raw_breakpoint *bp)\n-{\n-  int bp;\n-  unsigned long bp_ctrl;\n-  unsigned long start, end;\n-  struct regcache *regcache;\n-  unsigned long bp_d_regs[12];\n-\n-  regcache = get_thread_regcache (current_thread, 1);\n-\n-  /* Read watchpoints are set as access watchpoints, because of GDB's\n-     inability to deal with pure read watchpoints.  */\n-  if (type == raw_bkpt_type_read_wp)\n-    type = raw_bkpt_type_access_wp;\n-\n-  /* Get the configuration register.  */\n-  collect_register_by_name (regcache, \"s0\", &bp_ctrl);\n-\n-  /* Try to find a watchpoint that is configured for the\n-     specified range, then check that read/write also matches.  */\n-\n-  /* Ugly pointer arithmetic, since I cannot rely on a\n-     single switch (addr) as there may be several watchpoints with\n-     the same start address for example.  */\n-\n-  /* Get all range registers to simplify search.  */\n-  collect_register_by_name (regcache, \"s3\", &bp_d_regs[0]);\n-  collect_register_by_name (regcache, \"s4\", &bp_d_regs[1]);\n-  collect_register_by_name (regcache, \"s5\", &bp_d_regs[2]);\n-  collect_register_by_name (regcache, \"s6\", &bp_d_regs[3]);\n-  collect_register_by_name (regcache, \"s7\", &bp_d_regs[4]);\n-  collect_register_by_name (regcache, \"s8\", &bp_d_regs[5]);\n-  collect_register_by_name (regcache, \"s9\", &bp_d_regs[6]);\n-  collect_register_by_name (regcache, \"s10\", &bp_d_regs[7]);\n-  collect_register_by_name (regcache, \"s11\", &bp_d_regs[8]);\n-  collect_register_by_name (regcache, \"s12\", &bp_d_regs[9]);\n-  collect_register_by_name (regcache, \"s13\", &bp_d_regs[10]);\n-  collect_register_by_name (regcache, \"s14\", &bp_d_regs[11]);\n-\n-  for (bp = 0; bp < 6; bp++)\n-    {\n-      if (bp_d_regs[bp * 2] == addr\n-\t  && bp_d_regs[bp * 2 + 1] == (addr + len - 1)) {\n-\t/* Matching range.  */\n-\tint bitpos = 2 + bp * 4;\n-\tint rw_bits;\n-\n-\t/* Read/write bits for this BP.  */\n-\trw_bits = (bp_ctrl & (0x3 << bitpos)) >> bitpos;\n-\n-\tif ((type == raw_bkpt_type_read_wp && rw_bits == 0x1)\n-\t    || (type == raw_bkpt_type_write_wp && rw_bits == 0x2)\n-\t    || (type == raw_bkpt_type_access_wp && rw_bits == 0x3))\n-\t  {\n-\t    /* Read/write matched.  */\n-\t    break;\n-\t  }\n-      }\n-    }\n-\n-  if (bp > 5)\n-    {\n-      /* No watchpoint matched.  */\n-      return -1;\n-    }\n-\n-  /* Found a matching watchpoint.  Now, deconfigure it by\n-     both disabling read/write in bp_ctrl and zeroing its\n-     start/end addresses.  */\n-  bp_ctrl &= ~(3 << (2 + (bp * 4)));\n-  /* Setup the configuration register.  */\n-  supply_register_by_name (regcache, \"s0\", &bp_ctrl);\n-\n-  start = end = 0;\n-  /* Configure the watchpoint register.  */\n-  cris_write_data_breakpoint (regcache, bp, start, end);\n-\n-  /* Note that we don't clear the S1 flag here.  It's done when continuing.  */\n-  return 0;\n-}\n-\n-bool\n-crisv32_target::low_stopped_by_watchpoint ()\n-{\n-  unsigned long exs;\n-  struct regcache *regcache = get_thread_regcache (current_thread, 1);\n-\n-  collect_register_by_name (regcache, \"exs\", &exs);\n-\n-  return (((exs & 0xff00) >> 8) == 0xc);\n-}\n-\n-CORE_ADDR\n-crisv32_target::low_stopped_data_address ()\n-{\n-  unsigned long eda;\n-  struct regcache *regcache = get_thread_regcache (current_thread, 1);\n-\n-  collect_register_by_name (regcache, \"eda\", &eda);\n-\n-  /* FIXME: Possibly adjust to match watched range.  */\n-  return eda;\n-}\n-\n-ps_err_e\n-ps_get_thread_area (struct ps_prochandle *ph,\n-                    lwpid_t lwpid, int idx, void **base)\n-{\n-  if (ptrace (PTRACE_GET_THREAD_AREA, lwpid, NULL, base) != 0)\n-    return PS_ERR;\n-\n-  /* IDX is the bias from the thread pointer to the beginning of the\n-     thread descriptor.  It has to be subtracted due to implementation\n-     quirks in libthread_db.  */\n-  *base = (void *) ((char *) *base - idx);\n-  return PS_OK;\n-}\n-\n-static void\n-cris_fill_gregset (struct regcache *regcache, void *buf)\n-{\n-  int i;\n-\n-  for (i = 0; i < cris_num_regs; i++)\n-    {\n-      if (cris_regmap[i] != -1)\n-\tcollect_register (regcache, i, ((char *) buf) + cris_regmap[i]);\n-    }\n-}\n-\n-static void\n-cris_store_gregset (struct regcache *regcache, const void *buf)\n-{\n-  int i;\n-\n-  for (i = 0; i < cris_num_regs; i++)\n-    {\n-      if (cris_regmap[i] != -1)\n-\tsupply_register (regcache, i, ((char *) buf) + cris_regmap[i]);\n-    }\n-}\n-\n-void\n-crisv32_target::low_arch_setup ()\n-{\n-  current_process ()->tdesc = tdesc_crisv32;\n-}\n-\n-static struct regset_info cris_regsets[] = {\n-  { PTRACE_GETREGS, PTRACE_SETREGS, 0, cris_num_regs * 4,\n-    GENERAL_REGS, cris_fill_gregset, cris_store_gregset },\n-  NULL_REGSET\n-};\n-\n-\n-static struct regsets_info cris_regsets_info =\n-  {\n-    cris_regsets, /* regsets */\n-    0, /* num_regsets */\n-    NULL, /* disabled_regsets */\n-  };\n-\n-static struct usrregs_info cris_usrregs_info =\n-  {\n-    cris_num_regs,\n-    cris_regmap,\n-  };\n-\n-static struct regs_info myregs_info =\n-  {\n-    NULL, /* regset_bitmap */\n-    &cris_usrregs_info,\n-    &cris_regsets_info\n-  };\n-\n-const regs_info *\n-crisv32_target::get_regs_info ()\n-{\n-  return &myregs_info;\n-}\n-\n-/* The linux target ops object.  */\n-\n-linux_process_target *the_linux_target = &the_crisv32_target;\n-\n-void\n-initialize_low_arch (void)\n-{\n-  init_registers_crisv32 ();\n-\n-  initialize_regsets_info (&cris_regsets_info);\n-}"
    }
  ]
}