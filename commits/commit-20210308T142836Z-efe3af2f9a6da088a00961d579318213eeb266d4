{
  "sha": "efe3af2f9a6da088a00961d579318213eeb266d4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWZlM2FmMmY5YTZkYTA4OGEwMDk2MWQ1NzkzMTgyMTNlZWIyNjZkNA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:36Z"
    },
    "message": "Implement function calls for Ada\n\nThis implements function calls for Ada.  This takes a different\napproach than that used for other languages, primarily because Ada\nrequires special treatment generally.  The \"ordinary\" special case for\njust the callee didn't really apply neatly here; there's only one case\nin Ada needing special callee treatment.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (ada_funcall_operation::evaluate): New method.\n\t* ada-exp.h (class ada_var_msym_value_operation) <get_symbol>: New\n\tmethod.\n\t(class ada_funcall_operation): New.",
    "tree": {
      "sha": "bd276e76dcfc87c9434a821ba166963baed2441b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bd276e76dcfc87c9434a821ba166963baed2441b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/efe3af2f9a6da088a00961d579318213eeb266d4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/efe3af2f9a6da088a00961d579318213eeb266d4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/efe3af2f9a6da088a00961d579318213eeb266d4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/efe3af2f9a6da088a00961d579318213eeb266d4/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ebc06ad8f4365b8881ac40760fbb8cc71b490edd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ebc06ad8f4365b8881ac40760fbb8cc71b490edd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ebc06ad8f4365b8881ac40760fbb8cc71b490edd"
    }
  ],
  "stats": {
    "total": 168,
    "additions": 168,
    "deletions": 0
  },
  "files": [
    {
      "sha": "47383501082f46e1e63d2ff3b96181994b46906b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efe3af2f9a6da088a00961d579318213eeb266d4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efe3af2f9a6da088a00961d579318213eeb266d4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=efe3af2f9a6da088a00961d579318213eeb266d4",
      "patch": "@@ -1,3 +1,10 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (ada_funcall_operation::evaluate): New method.\n+\t* ada-exp.h (class ada_var_msym_value_operation) <get_symbol>: New\n+\tmethod.\n+\t(class ada_funcall_operation): New.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ada-lang.c (ada_structop_operation::evaluate): New method."
    },
    {
      "sha": "287ed5cc62ce1994e41de07eb72383baf57c5ffe",
      "filename": "gdb/ada-exp.h",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efe3af2f9a6da088a00961d579318213eeb266d4/gdb/ada-exp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efe3af2f9a6da088a00961d579318213eeb266d4/gdb/ada-exp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.h?ref=efe3af2f9a6da088a00961d579318213eeb266d4",
      "patch": "@@ -320,6 +320,9 @@ class ada_var_value_operation\n \t\t\t    struct expression *exp,\n \t\t\t    enum noside noside) override;\n \n+  symbol *get_symbol () const\n+  { return std::get<0> (m_storage); }\n+\n protected:\n \n   using operation::do_generate_ax;\n@@ -387,6 +390,22 @@ class ada_structop_operation\n   { return STRUCTOP_STRUCT; }\n };\n \n+/* Function calls for Ada.  */\n+class ada_funcall_operation\n+  : public tuple_holding_operation<operation_up, std::vector<operation_up>>\n+{\n+public:\n+\n+  using tuple_holding_operation::tuple_holding_operation;\n+\n+  value *evaluate (struct type *expect_type,\n+\t\t   struct expression *exp,\n+\t\t   enum noside noside) override;\n+\n+  enum exp_opcode opcode () const override\n+  { return OP_FUNCALL; }\n+};\n+\n } /* namespace expr */\n \n #endif /* ADA_EXP_H */"
    },
    {
      "sha": "2bee8abc94c04c244d633ee8a567c8bf875d7533",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 142,
      "deletions": 0,
      "changes": 142,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/efe3af2f9a6da088a00961d579318213eeb266d4/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/efe3af2f9a6da088a00961d579318213eeb266d4/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=efe3af2f9a6da088a00961d579318213eeb266d4",
      "patch": "@@ -10830,6 +10830,148 @@ ada_structop_operation::evaluate (struct type *expect_type,\n     }\n }\n \n+value *\n+ada_funcall_operation::evaluate (struct type *expect_type,\n+\t\t\t\t struct expression *exp,\n+\t\t\t\t enum noside noside)\n+{\n+  const std::vector<operation_up> &args_up = std::get<1> (m_storage);\n+  int nargs = args_up.size ();\n+  std::vector<value *> argvec (nargs);\n+  operation_up &callee_op = std::get<0> (m_storage);\n+\n+  ada_var_value_operation *avv\n+    = dynamic_cast<ada_var_value_operation *> (callee_op.get ());\n+  if (avv != nullptr\n+      && SYMBOL_DOMAIN (avv->get_symbol ()) == UNDEF_DOMAIN)\n+    error (_(\"Unexpected unresolved symbol, %s, during evaluation\"),\n+\t   avv->get_symbol ()->print_name ());\n+\n+  value *callee = callee_op->evaluate (nullptr, exp, noside);\n+  for (int i = 0; i < args_up.size (); ++i)\n+    argvec[i] = args_up[i]->evaluate (nullptr, exp, noside);\n+\n+  if (ada_is_constrained_packed_array_type\n+      (desc_base_type (value_type (callee))))\n+    callee = ada_coerce_to_simple_array (callee);\n+  else if (value_type (callee)->code () == TYPE_CODE_ARRAY\n+\t   && TYPE_FIELD_BITSIZE (value_type (callee), 0) != 0)\n+    /* This is a packed array that has already been fixed, and\n+       therefore already coerced to a simple array.  Nothing further\n+       to do.  */\n+    ;\n+  else if (value_type (callee)->code () == TYPE_CODE_REF)\n+    {\n+      /* Make sure we dereference references so that all the code below\n+\t feels like it's really handling the referenced value.  Wrapping\n+\t types (for alignment) may be there, so make sure we strip them as\n+\t well.  */\n+      callee = ada_to_fixed_value (coerce_ref (callee));\n+    }\n+  else if (value_type (callee)->code () == TYPE_CODE_ARRAY\n+\t   && VALUE_LVAL (callee) == lval_memory)\n+    callee = value_addr (callee);\n+\n+  struct type *type = ada_check_typedef (value_type (callee));\n+\n+  /* Ada allows us to implicitly dereference arrays when subscripting\n+     them.  So, if this is an array typedef (encoding use for array\n+     access types encoded as fat pointers), strip it now.  */\n+  if (type->code () == TYPE_CODE_TYPEDEF)\n+    type = ada_typedef_target_type (type);\n+\n+  if (type->code () == TYPE_CODE_PTR)\n+    {\n+      switch (ada_check_typedef (TYPE_TARGET_TYPE (type))->code ())\n+\t{\n+\tcase TYPE_CODE_FUNC:\n+\t  type = ada_check_typedef (TYPE_TARGET_TYPE (type));\n+\t  break;\n+\tcase TYPE_CODE_ARRAY:\n+\t  break;\n+\tcase TYPE_CODE_STRUCT:\n+\t  if (noside != EVAL_AVOID_SIDE_EFFECTS)\n+\t    callee = ada_value_ind (callee);\n+\t  type = ada_check_typedef (TYPE_TARGET_TYPE (type));\n+\t  break;\n+\tdefault:\n+\t  error (_(\"cannot subscript or call something of type `%s'\"),\n+\t\t ada_type_name (value_type (callee)));\n+\t  break;\n+\t}\n+    }\n+\n+  switch (type->code ())\n+    {\n+    case TYPE_CODE_FUNC:\n+      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n+\t{\n+\t  if (TYPE_TARGET_TYPE (type) == NULL)\n+\t    error_call_unknown_return_type (NULL);\n+\t  return allocate_value (TYPE_TARGET_TYPE (type));\n+\t}\n+      return call_function_by_hand (callee, NULL, argvec);\n+    case TYPE_CODE_INTERNAL_FUNCTION:\n+      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n+\t/* We don't know anything about what the internal\n+\t   function might return, but we have to return\n+\t   something.  */\n+\treturn value_zero (builtin_type (exp->gdbarch)->builtin_int,\n+\t\t\t   not_lval);\n+      else\n+\treturn call_internal_function (exp->gdbarch, exp->language_defn,\n+\t\t\t\t       callee, nargs,\n+\t\t\t\t       argvec.data ());\n+\n+    case TYPE_CODE_STRUCT:\n+      {\n+\tint arity;\n+\n+\tarity = ada_array_arity (type);\n+\ttype = ada_array_element_type (type, nargs);\n+\tif (type == NULL)\n+\t  error (_(\"cannot subscript or call a record\"));\n+\tif (arity != nargs)\n+\t  error (_(\"wrong number of subscripts; expecting %d\"), arity);\n+\tif (noside == EVAL_AVOID_SIDE_EFFECTS)\n+\t  return value_zero (ada_aligned_type (type), lval_memory);\n+\treturn\n+\t  unwrap_value (ada_value_subscript\n+\t\t\t(callee, nargs, argvec.data ()));\n+      }\n+    case TYPE_CODE_ARRAY:\n+      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n+\t{\n+\t  type = ada_array_element_type (type, nargs);\n+\t  if (type == NULL)\n+\t    error (_(\"element type of array unknown\"));\n+\t  else\n+\t    return value_zero (ada_aligned_type (type), lval_memory);\n+\t}\n+      return\n+\tunwrap_value (ada_value_subscript\n+\t\t      (ada_coerce_to_simple_array (callee),\n+\t\t       nargs, argvec.data ()));\n+    case TYPE_CODE_PTR:     /* Pointer to array */\n+      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n+\t{\n+\t  type = to_fixed_array_type (TYPE_TARGET_TYPE (type), NULL, 1);\n+\t  type = ada_array_element_type (type, nargs);\n+\t  if (type == NULL)\n+\t    error (_(\"element type of array unknown\"));\n+\t  else\n+\t    return value_zero (ada_aligned_type (type), lval_memory);\n+\t}\n+      return\n+\tunwrap_value (ada_value_ptr_subscript (callee, nargs,\n+\t\t\t\t\t       argvec.data ()));\n+\n+    default:\n+      error (_(\"Attempt to index or call something other than an \"\n+\t       \"array or function\"));\n+    }\n+}\n+\n }\n \n /* Implement the evaluate_exp routine in the exp_descriptor structure"
    }
  ]
}