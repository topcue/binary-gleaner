{
  "sha": "1136c379718cb9f6a82e71029f86cd8cf70fa6be",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTEzNmMzNzk3MThjYjlmNmE4MmU3MTAyOWY4NmNkOGNmNzBmYTZiZQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-20T13:34:04Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2020-11-20T13:34:08Z"
    },
    "message": "libctf: symbol type linking support\n\nThis adds facilities to write out the function info and data object\nsections, which efficiently map from entries in the symbol table to\ntypes.  The write-side code is entirely new: the read-side code was\nmerely significantly changed and support for indexed tables added\n(pointed to by the no-longer-unused cth_objtidxoff and cth_funcidxoff\nheader fields).\n\nWith this in place, you can use ctf_lookup_by_symbol to look up the\ntypes of symbols of function and object type (and, as before, you can\nuse ctf_lookup_variable to look up types of file-scope variables not\npresent in the symbol table, as long as you know their name: but\nvariables that are also data objects are now found in the data object\nsection instead.)\n\n(Compatible) file format change:\n\nThe CTF spec has always said that the function info section looks much\nlike the CTF_K_FUNCTIONs in the type section: an info word (including an\nargument count) followed by a return type and N argument types. This\nformat is suboptimal: it means function symbols cannot be deduplicated\nand it causes a lot of ugly code duplication in libctf.  But\nconveniently the compiler has never emitted this!  Because it has always\nemitted a rather different format that libctf has never accepted, we can\nbe sure that there are no instances of this function info section in the\nwild, and can freely change its format without compatibility concerns or\na file format version bump.  (And since it has never been emitted in any\ncode that generated any older file format version, either, we need keep\nno code to read the format as specified at all!)\n\nSo the function info section is now specified as an array of uint32_t,\nexactly like the object data section: each entry is a type ID in the\ntype section which must be of kind CTF_K_FUNCTION, the prototype of\nthis function.\n\nThis allows function types to be deduplicated and also correctly encodes\nthe fact that all functions declared in C really are types available to\nthe program: so they should be stored in the type section like all other\ntypes.  (In format v4, we will be able to represent the types of static\nfunctions as well, but that really does require a file format change.)\n\nWe introduce a new header flag, CTF_F_NEWFUNCINFO, which is set if the\nnew function info format is in use.  A sufficiently new compiler will\nalways set this flag.  New libctf will always set this flag: old libctf\nwill refuse to open any CTF dicts that have this flag set.  If the flag\nis not set on a dict being read in, new libctf will disregard the\nfunction info section.  Format v4 will remove this flag (or, rather, the\nflag has no meaning there and the bit position may be recycled for some\nother purpose).\n\nNew API:\n\nSymbol addition:\n  ctf_add_func_sym: Add a symbol with a given name and type.  The\n                    type must be of kind CTF_K_FUNCTION (a function\n                    pointer).  Internally this adds a name -> type\n                    mapping to the ctf_funchash in the ctf_dict.\n  ctf_add_objt_sym: Add a symbol with a given name and type.  The type\n                    kind can be anything, including function pointers.\n\t\t    This adds to ctf_objthash.\n\nThese both treat symbols as name -> type mappings: the linker associates\nsymbol names with symbol indexes via the ctf_link_shuffle_syms callback,\nwhich sets up the ctf_dynsyms/ctf_dynsymidx/ctf_dynsymmax fields in the\nctf_dict.  Repeated relinks can add more symbols.\n\nVariables that are also exposed as symbols are removed from the variable\nsection at serialization time.\n\nCTF symbol type sections which have enough pads, defined by\nCTF_INDEX_PAD_THRESHOLD (whether because they are in dicts with symbols\nwhere most types are unknown, or in archive where most types are defined\nin some child or parent dict, not in this specific dict) are sorted by\nname rather than symidx and accompanied by an index which associates\neach symbol type entry with a name: the existing ctf_lookup_by_symbol\nwill map symbol indexes to symbol names and look the names up in the\nindex automatically.  (This is currently ELF-symbol-table-dependent, but\nthere is almost nothing specific to ELF in here and we can add support\nfor other symbol table formats easily).\n\nThe compiler also uses index sections to communicate the contents of\nobject file symbol tables without relying on any specific ordering of\nsymbols: it doesn't need to sort them, and libctf will detect an\nunsorted index section via the absence of the new CTF_F_IDXSORTED header\nflag, and sort it if needed.\n\nIteration:\n  ctf_symbol_next: Iterator which returns the types and names of symbols\n                   one by one, either for function or data symbols.\n\nThis does not require any sorting: the ctf_link machinery uses it to\npull in all the compiler-provided symbols cheaply, but it is not\nrestricted to that use.\n\n(Compatible) changes in API:\n  ctf_lookup_by_symbol: can now be called for object and function\n                        symbols: never returns ECTF_NOTDATA (which is\n\t\t\tnow not thrown by anything, but is kept for\n                        compatibility and because it is a plausible\n                        error that we might start throwing again at some\n                        later date).\n\nInternally we also have changes to the ctf-string functionality so that\n\"external\" strings (those where we track a string -> offset mapping, but\nonly write out an offset) can be consulted via the usual means\n(ctf_strptr) before the strtab is written out.  This is important\nbecause ctf_link_add_linker_symbol can now be handed symbols named via\nstrtab offsets, and ctf_link_shuffle_syms must figure out their actual\nnames by looking in the external symtab we have just been fed by the\nctf_link_add_strtab callback, long before that strtab is written out.\n\ninclude/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-api.h (ctf_symbol_next): New.\n\t(ctf_add_objt_sym): Likewise.\n\t(ctf_add_func_sym): Likewise.\n\t* ctf.h: Document new function info section format.\n\t(CTF_F_NEWFUNCINFO): New.\n\t(CTF_F_IDXSORTED): New.\n\t(CTF_F_MAX): Adjust accordingly.\n\nlibctf/ChangeLog\n2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h (CTF_INDEX_PAD_THRESHOLD): New.\n\t(_libctf_nonnull_): Likewise.\n\t(ctf_in_flight_dynsym_t): New.\n\t(ctf_dict_t) <ctf_funcidx_names>: Likewise.\n\t<ctf_objtidx_names>: Likewise.\n\t<ctf_nfuncidx>: Likewise.\n\t<ctf_nobjtidx>: Likewise.\n\t<ctf_funcidx_sxlate>: Likewise.\n\t<ctf_objtidx_sxlate>: Likewise.\n\t<ctf_objthash>: Likewise.\n\t<ctf_funchash>: Likewise.\n\t<ctf_dynsyms>: Likewise.\n\t<ctf_dynsymidx>: Likewise.\n\t<ctf_dynsymmax>: Likewise.\n\t<ctf_in_flight_dynsym>: Likewise.\n\t(struct ctf_next) <u.ctn_next>: Likewise.\n\t(ctf_symtab_skippable): New prototype.\n\t(ctf_add_funcobjt_sym): Likewise.\n\t(ctf_dynhash_sort_by_name): Likewise.\n\t(ctf_sym_to_elf64): Rename to...\n\t(ctf_elf32_to_link_sym): ... this, and...\n\t(ctf_elf64_to_link_sym): ... this.\n\t* ctf-open.c (init_symtab): Check for lack of CTF_F_NEWFUNCINFO\n\tflag, and presence of index sections.  Refactor out\n\tctf_symtab_skippable and ctf_elf*_to_link_sym, and use them.  Use\n\tctf_link_sym_t, not Elf64_Sym.  Skip initializing objt or func\n\tsxlate sections if corresponding index section is present.  Adjust\n\tfor new func info section format.\n\t(ctf_bufopen_internal): Add ctf_err_warn to corrupt-file error\n\thandling.  Report incorrect-length index sections.  Always do an\n\tinit_symtab, even if there is no symtab section (there may be index\n\tsections still).\n\t(flip_objts): Adjust comment: func and objt sections are actually\n\tidentical in structure now, no need to caveat.\n\t(ctf_dict_close):  Free newly-added data structures.\n\t* ctf-create.c (ctf_create): Initialize them.\n\t(ctf_symtab_skippable): New, refactored out of\n\tinit_symtab, with st_nameidx_set check added.\n\t(ctf_add_funcobjt_sym): New, add a function or object symbol to the\n\tctf_objthash or ctf_funchash, by name.\n\t(ctf_add_objt_sym): Call it.\n\t(ctf_add_func_sym): Likewise.\n\t(symtypetab_delete_nonstatic_vars): New, delete vars also present as\n\tdata objects.\n\t(CTF_SYMTYPETAB_EMIT_FUNCTION): New flag to symtypetab emitters:\n\tthis is a function emission, not a data object emission.\n\t(CTF_SYMTYPETAB_EMIT_PAD): New flag to symtypetab emitters: emit\n\tpads for symbols with no type (only set for unindexed sections).\n\t(CTF_SYMTYPETAB_FORCE_INDEXED): New flag to symtypetab emitters:\n\talways emit indexed.\n\t(symtypetab_density): New, figure out section sizes.\n\t(emit_symtypetab): New, emit a symtypetab.\n\t(emit_symtypetab_index): New, emit a symtypetab index.\n\t(ctf_serialize): Call them, emitting suitably sorted symtypetab\n\tsections and indexes.  Set suitable header flags.  Copy over new\n\tfields.\n\t* ctf-hash.c (ctf_dynhash_sort_by_name): New, used to impose an\n\torder on symtypetab index sections.\n\t* ctf-link.c (ctf_add_type_mapping): Delete erroneous comment\n\trelating to code that was never committed.\n\t(ctf_link_one_variable): Improve variable name.\n\t(check_sym): New, symtypetab analogue of check_variable.\n\t(ctf_link_deduplicating_one_symtypetab): New.\n\t(ctf_link_deduplicating_syms): Likewise.\n\t(ctf_link_deduplicating): Call them.\n\t(ctf_link_deduplicating_per_cu): Note that we don't call them in\n\tthis case (yet).\n\t(ctf_link_add_strtab): Set the error on the fp correctly.\n\t(ctf_link_add_linker_symbol): New (no longer a do-nothing stub), add\n\ta linker symbol to the in-flight list.\n\t(ctf_link_shuffle_syms): New (no longer a do-nothing stub), turn the\n\tin-flight list into a mapping we can use, now its names are\n\tresolvable in the external strtab.\n\t* ctf-string.c (ctf_str_rollback_atom): Don't roll back atoms with\n\texternal strtab offsets.\n\t(ctf_str_rollback): Adjust comment.\n\t(ctf_str_write_strtab): Migrate ctf_syn_ext_strtab population from\n\twriteout time...\n\t(ctf_str_add_external): ... to string addition time.\n\t* ctf-lookup.c (ctf_lookup_var_key_t): Rename to...\n\t(ctf_lookup_idx_key_t): ... this, now we use it for syms too.\n\t<clik_names>: New member, a name table.\n\t(ctf_lookup_var): Adjust accordingly.\n\t(ctf_lookup_variable): Likewise.\n\t(ctf_lookup_by_id): Shuffle further up in the file.\n\t(ctf_symidx_sort_arg_cb): New, callback for...\n\t(sort_symidx_by_name): ... this new function to sort a symidx\n\tfound to be unsorted (likely originating from the compiler).\n\t(ctf_symidx_sort): New, sort a symidx.\n\t(ctf_lookup_symbol_name): Support dynamic symbols with indexes\n\tprovided by the linker.  Use ctf_link_sym_t, not Elf64_Sym.\n\tCheck the parent if a child lookup fails.\n\t(ctf_lookup_by_symbol): Likewise.  Work for function symbols too.\n\t(ctf_symbol_next): New, iterate over symbols with types (without\n\tsorting).\n\t(ctf_lookup_idx_name): New, bsearch for symbol names in indexes.\n\t(ctf_try_lookup_indexed): New, attempt an indexed lookup.\n\t(ctf_func_info): Reimplement in terms of ctf_lookup_by_symbol.\n\t(ctf_func_args): Likewise.\n\t(ctf_get_dict): Move...\n\t* ctf-types.c (ctf_get_dict): ... here.\n\t* ctf-util.c (ctf_sym_to_elf64): Re-express as...\n\t(ctf_elf64_to_link_sym): ... this.  Add new st_symidx field, and\n\tst_nameidx_set (always 0, so st_nameidx can be ignored).  Look in\n\tthe ELF strtab for names.\n\t(ctf_elf32_to_link_sym): Likewise, for Elf32_Sym.\n\t(ctf_next_destroy): Destroy ctf_next_t.u.ctn_next if need be.\n\t* libctf.ver: Add ctf_symbol_next, ctf_add_objt_sym and\n\tctf_add_func_sym.",
    "tree": {
      "sha": "cf8b731e9ac18ffe88e28d7aedf87cbd9ea24ce6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/cf8b731e9ac18ffe88e28d7aedf87cbd9ea24ce6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1136c379718cb9f6a82e71029f86cd8cf70fa6be",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1136c379718cb9f6a82e71029f86cd8cf70fa6be",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1136c379718cb9f6a82e71029f86cd8cf70fa6be",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1136c379718cb9f6a82e71029f86cd8cf70fa6be/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3d16b64e28ab2cd7e69c0b31bc3ab1601891c969",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3d16b64e28ab2cd7e69c0b31bc3ab1601891c969",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3d16b64e28ab2cd7e69c0b31bc3ab1601891c969"
    }
  ],
  "stats": {
    "total": 2170,
    "additions": 1898,
    "deletions": 272
  },
  "files": [
    {
      "sha": "ad4c8a69d1bd09f72ec1b357681cce5a19170c8c",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -1,3 +1,13 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_symbol_next): New.\n+\t(ctf_add_objt_sym): Likewise.\n+\t(ctf_add_func_sym): Likewise.\n+\t* ctf.h: Document new function info section format.\n+\t(CTF_F_NEWFUNCINFO): New.\n+\t(CTF_F_IDXSORTED): New.\n+\t(CTF_F_MAX): Adjust accordingly.\n+\n 2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* bfdlink.h (struct elf_sym_strtab): Replace with..."
    },
    {
      "sha": "6dd37b917e117a91fb3b532defa5f1e03b5aadf1",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -361,6 +361,8 @@ extern int ctf_func_type_args (ctf_dict_t *, ctf_id_t, uint32_t, ctf_id_t *);\n \n extern ctf_id_t ctf_lookup_by_name (ctf_dict_t *, const char *);\n extern ctf_id_t ctf_lookup_by_symbol (ctf_dict_t *, unsigned long);\n+extern ctf_id_t ctf_symbol_next (ctf_dict_t *, ctf_next_t **,\n+\t\t\t\t const char **name, int functions);\n extern ctf_id_t ctf_lookup_variable (ctf_dict_t *, const char *);\n \n extern ctf_id_t ctf_type_resolve (ctf_dict_t *, ctf_id_t);\n@@ -468,6 +470,9 @@ extern int ctf_add_member_encoded (ctf_dict_t *, ctf_id_t, const char *,\n \n extern int ctf_add_variable (ctf_dict_t *, const char *, ctf_id_t);\n \n+extern int ctf_add_objt_sym (ctf_dict_t *, const char *, ctf_id_t);\n+extern int ctf_add_func_sym (ctf_dict_t *, const char *, ctf_id_t);\n+\n extern int ctf_set_array (ctf_dict_t *, ctf_id_t, const ctf_arinfo_t *);\n \n extern ctf_dict_t *ctf_create (int *);"
    },
    {
      "sha": "c7a1e4323a0899ab78f60f39b5a2d74d7e67b964",
      "filename": "include/ctf.h",
      "status": "modified",
      "additions": 25,
      "deletions": 15,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/include/ctf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/include/ctf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf.h?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -73,26 +73,29 @@ extern \"C\"\n    the data types section.  Each label is accompanied by a type ID i.  A given\n    label refers to the group of types whose IDs are in the range [0, i].\n \n-   Data object and function records are stored in the same order as they appear\n-   in the corresponding symbol table, except that symbols marked SHN_UNDEF are\n-   not stored and symbols that have no type data are padded out with zeroes.\n-   For each data object, the type ID (a small integer) is recorded.  For each\n-   function, the type ID of the return type and argument types is recorded.\n+   Data object and function records (collectively, \"symtypetabs\") are stored in\n+   the same order as they appear in the corresponding symbol table, except that\n+   symbols marked SHN_UNDEF are not stored and symbols that have no type data\n+   are padded out with zeroes.  For each entry in these tables, the type ID (a\n+   small integer) is recorded.  (Functions get CTF_K_FUNCTION types, just like\n+   data objects that are function pointers.)\n \n    For situations in which the order of the symbols in the symtab is not known,\n-   a pair of optional indexes follow the data object and function info sections:\n-   each of these is an array of strtab indexes, mapped 1:1 to the corresponding\n-   data object / function info section, giving each entry in those sections a\n-   name so that the linker can correlate them with final symtab entries and\n-   reorder them accordingly (dropping the indexes in the process).\n+   or most symbols have no type in this dict and most entries would be\n+   zero-pads, a pair of optional indexes follow the data object and function\n+   info sections: each of these is an array of strtab indexes, mapped 1:1 to the\n+   corresponding data object / function info section, giving each entry in those\n+   sections a name so that the linker can correlate them with final symtab\n+   entries and reorder them accordingly (dropping the indexes in the process).\n \n    Variable records (as distinct from data objects) provide a modicum of support\n    for non-ELF systems, mapping a variable name to a CTF type ID.  The variable\n    names are sorted into ASCIIbetical order, permitting binary searching.  We do\n    not define how the consumer maps these variable names to addresses or\n    anything else, or indeed what these names represent: they might be names\n    looked up at runtime via dlsym() or names extracted at runtime by a debugger\n-   or anything else the consumer likes.\n+   or anything else the consumer likes.  Variable records with identically-\n+   named entries in the data object section are removed.\n \n    The data types section is a list of variable size records that represent each\n    type, in order by their ID.  The types themselves form a directed graph,\n@@ -104,9 +107,9 @@ extern \"C\"\n    Strings are recorded as a string table ID (0 or 1) and a byte offset into the\n    string table.  String table 0 is the internal CTF string table.  String table\n    1 is the external string table, which is the string table associated with the\n-   ELF symbol table for this object.  CTF does not record any strings that are\n-   already in the symbol table, and the CTF string table does not contain any\n-   duplicated strings.\n+   ELF dynamic symbol table for this object.  CTF does not record any strings\n+   that are already in the symbol table, and the CTF string table does not\n+   contain any duplicated strings.\n \n    If the CTF data has been merged with another parent CTF object, some outgoing\n    edges may refer to type nodes that exist in another CTF object.  The debugger\n@@ -199,9 +202,16 @@ typedef struct ctf_header\n #define CTF_VERSION_3 4\n #define CTF_VERSION CTF_VERSION_3 /* Current version.  */\n \n+/* All of these flags bar CTF_F_COMPRESS and CTF_F_IDXSORTED are bug-workaround\n+   flags and are valid only in format v3: in v2 and below they cannot occur and\n+   in v4 and later, they will be recycled for other purposes.  */\n+\n #define CTF_F_COMPRESS\t0x1\t\t/* Data buffer is compressed by libctf.  */\n+#define CTF_F_NEWFUNCINFO 0x2\t\t/* New v3 func info section format.  */\n+#define CTF_F_IDXSORTED 0x4\t\t/* Index sections already sorted.  */\n #define CTF_F_DYNSTR 0x8\t\t/* Strings come from .dynstr.  */\n-#define CTF_F_MAX (CTF_F_COMPRESS | CTF_F_DYNSTR)\n+#define CTF_F_MAX (CTF_F_COMPRESS | CTF_F_NEWFUNCINFO | CTF_F_IDXSORTED\t\\\n+\t\t   | CTF_F_DYNSTR)\n \n typedef struct ctf_lblent\n {"
    },
    {
      "sha": "8f2fb48f55c083d1c59951487a20c972b7c0e24a",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 112,
      "deletions": 0,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -1,3 +1,115 @@\n+2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (CTF_INDEX_PAD_THRESHOLD): New.\n+\t(_libctf_nonnull_): Likewise.\n+\t(ctf_in_flight_dynsym_t): New.\n+\t(ctf_dict_t) <ctf_funcidx_names>: Likewise.\n+\t<ctf_objtidx_names>: Likewise.\n+\t<ctf_nfuncidx>: Likewise.\n+\t<ctf_nobjtidx>: Likewise.\n+\t<ctf_funcidx_sxlate>: Likewise.\n+\t<ctf_objtidx_sxlate>: Likewise.\n+\t<ctf_objthash>: Likewise.\n+\t<ctf_funchash>: Likewise.\n+\t<ctf_dynsyms>: Likewise.\n+\t<ctf_dynsymidx>: Likewise.\n+\t<ctf_dynsymmax>: Likewise.\n+\t<ctf_in_flight_dynsym>: Likewise.\n+\t(struct ctf_next) <u.ctn_next>: Likewise.\n+\t(ctf_symtab_skippable): New prototype.\n+\t(ctf_add_funcobjt_sym): Likewise.\n+\t(ctf_dynhash_sort_by_name): Likewise.\n+\t(ctf_sym_to_elf64): Rename to...\n+\t(ctf_elf32_to_link_sym): ... this, and...\n+\t(ctf_elf64_to_link_sym): ... this.\n+\t* ctf-open.c (init_symtab): Check for lack of CTF_F_NEWFUNCINFO\n+\tflag, and presence of index sections.  Refactor out\n+\tctf_symtab_skippable and ctf_elf*_to_link_sym, and use them.  Use\n+\tctf_link_sym_t, not Elf64_Sym.  Skip initializing objt or func\n+\tsxlate sections if corresponding index section is present.  Adjust\n+\tfor new func info section format.\n+\t(ctf_bufopen_internal): Add ctf_err_warn to corrupt-file error\n+\thandling.  Report incorrect-length index sections.  Always do an\n+\tinit_symtab, even if there is no symtab section (there may be index\n+\tsections still).\n+\t(flip_objts): Adjust comment: func and objt sections are actually\n+\tidentical in structure now, no need to caveat.\n+\t(ctf_dict_close):  Free newly-added data structures.\n+\t* ctf-create.c (ctf_create): Initialize them.\n+\t(ctf_symtab_skippable): New, refactored out of\n+\tinit_symtab, with st_nameidx_set check added.\n+\t(ctf_add_funcobjt_sym): New, add a function or object symbol to the\n+\tctf_objthash or ctf_funchash, by name.\n+\t(ctf_add_objt_sym): Call it.\n+\t(ctf_add_func_sym): Likewise.\n+\t(symtypetab_delete_nonstatic_vars): New, delete vars also present as\n+\tdata objects.\n+\t(CTF_SYMTYPETAB_EMIT_FUNCTION): New flag to symtypetab emitters:\n+\tthis is a function emission, not a data object emission.\n+\t(CTF_SYMTYPETAB_EMIT_PAD): New flag to symtypetab emitters: emit\n+\tpads for symbols with no type (only set for unindexed sections).\n+\t(CTF_SYMTYPETAB_FORCE_INDEXED): New flag to symtypetab emitters:\n+\talways emit indexed.\n+\t(symtypetab_density): New, figure out section sizes.\n+\t(emit_symtypetab): New, emit a symtypetab.\n+\t(emit_symtypetab_index): New, emit a symtypetab index.\n+\t(ctf_serialize): Call them, emitting suitably sorted symtypetab\n+\tsections and indexes.  Set suitable header flags.  Copy over new\n+\tfields.\n+\t* ctf-hash.c (ctf_dynhash_sort_by_name): New, used to impose an\n+\torder on symtypetab index sections.\n+\t* ctf-link.c (ctf_add_type_mapping): Delete erroneous comment\n+\trelating to code that was never committed.\n+\t(ctf_link_one_variable): Improve variable name.\n+\t(check_sym): New, symtypetab analogue of check_variable.\n+\t(ctf_link_deduplicating_one_symtypetab): New.\n+\t(ctf_link_deduplicating_syms): Likewise.\n+\t(ctf_link_deduplicating): Call them.\n+\t(ctf_link_deduplicating_per_cu): Note that we don't call them in\n+\tthis case (yet).\n+\t(ctf_link_add_strtab): Set the error on the fp correctly.\n+\t(ctf_link_add_linker_symbol): New (no longer a do-nothing stub), add\n+\ta linker symbol to the in-flight list.\n+\t(ctf_link_shuffle_syms): New (no longer a do-nothing stub), turn the\n+\tin-flight list into a mapping we can use, now its names are\n+\tresolvable in the external strtab.\n+\t* ctf-string.c (ctf_str_rollback_atom): Don't roll back atoms with\n+\texternal strtab offsets.\n+\t(ctf_str_rollback): Adjust comment.\n+\t(ctf_str_write_strtab): Migrate ctf_syn_ext_strtab population from\n+\twriteout time...\n+\t(ctf_str_add_external): ... to string addition time.\n+\t* ctf-lookup.c (ctf_lookup_var_key_t): Rename to...\n+\t(ctf_lookup_idx_key_t): ... this, now we use it for syms too.\n+\t<clik_names>: New member, a name table.\n+\t(ctf_lookup_var): Adjust accordingly.\n+\t(ctf_lookup_variable): Likewise.\n+\t(ctf_lookup_by_id): Shuffle further up in the file.\n+\t(ctf_symidx_sort_arg_cb): New, callback for...\n+\t(sort_symidx_by_name): ... this new function to sort a symidx\n+\tfound to be unsorted (likely originating from the compiler).\n+\t(ctf_symidx_sort): New, sort a symidx.\n+\t(ctf_lookup_symbol_name): Support dynamic symbols with indexes\n+\tprovided by the linker.  Use ctf_link_sym_t, not Elf64_Sym.\n+\tCheck the parent if a child lookup fails.\n+\t(ctf_lookup_by_symbol): Likewise.  Work for function symbols too.\n+\t(ctf_symbol_next): New, iterate over symbols with types (without\n+\tsorting).\n+\t(ctf_lookup_idx_name): New, bsearch for symbol names in indexes.\n+\t(ctf_try_lookup_indexed): New, attempt an indexed lookup.\n+\t(ctf_func_info): Reimplement in terms of ctf_lookup_by_symbol.\n+\t(ctf_func_args): Likewise.\n+\t(ctf_get_dict): Move...\n+\t* ctf-types.c (ctf_get_dict): ... here.\n+\t* ctf-util.c (ctf_sym_to_elf64): Re-express as...\n+\t(ctf_elf64_to_link_sym): ... this.  Add new st_symidx field, and\n+\tst_nameidx_set (always 0, so st_nameidx can be ignored).  Look in\n+\tthe ELF strtab for names.\n+\t(ctf_elf32_to_link_sym): Likewise, for Elf32_Sym.\n+\t(ctf_next_destroy): Destroy ctf_next_t.u.ctn_next if need be.\n+\t* libctf.ver: Add ctf_symbol_next, ctf_add_objt_sym and\n+\tctf_add_func_sym.\n+\n 2020-11-20  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-link.c (ctf_link_shuffle_syms): Adjust."
    },
    {
      "sha": "5fc50a519e933cdad38f95756823d6a6b312e486",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 687,
      "deletions": 12,
      "changes": 699,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -24,6 +24,9 @@\n #include <unistd.h>\n #include <zlib.h>\n \n+#include <elf.h>\n+#include \"elf-bfd.h\"\n+\n #ifndef EOVERFLOW\n #define EOVERFLOW ERANGE\n #endif\n@@ -79,6 +82,7 @@ ctf_create (int *errp)\n   ctf_dynhash_t *dthash;\n   ctf_dynhash_t *dvhash;\n   ctf_dynhash_t *structs = NULL, *unions = NULL, *enums = NULL, *names = NULL;\n+  ctf_dynhash_t *objthash = NULL, *funchash = NULL;\n   ctf_sect_t cts;\n   ctf_dict_t *fp;\n \n@@ -107,6 +111,10 @@ ctf_create (int *errp)\n \t\t\t      NULL, NULL);\n   names = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n \t\t\t      NULL, NULL);\n+  objthash = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t\t free, NULL);\n+  funchash = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t\t free, NULL);\n   if (!structs || !unions || !enums || !names)\n     {\n       ctf_set_open_errno (errp, EAGAIN);\n@@ -125,6 +133,8 @@ ctf_create (int *errp)\n   fp->ctf_unions.ctn_writable = unions;\n   fp->ctf_enums.ctn_writable = enums;\n   fp->ctf_names.ctn_writable = names;\n+  fp->ctf_objthash = objthash;\n+  fp->ctf_funchash = funchash;\n   fp->ctf_dthash = dthash;\n   fp->ctf_dvhash = dvhash;\n   fp->ctf_dtoldid = 0;\n@@ -148,13 +158,404 @@ ctf_create (int *errp)\n   ctf_dynhash_destroy (unions);\n   ctf_dynhash_destroy (enums);\n   ctf_dynhash_destroy (names);\n+  ctf_dynhash_destroy (objthash);\n+  ctf_dynhash_destroy (funchash);\n   ctf_dynhash_destroy (dvhash);\n  err_dt:\n   ctf_dynhash_destroy (dthash);\n  err:\n   return NULL;\n }\n \n+/* Delete data symbols that have been assigned names from the variable section.\n+   Must be called from within ctf_serialize, because that is the only place\n+   you can safely delete variables without messing up ctf_rollback.  */\n+\n+static int\n+symtypetab_delete_nonstatic_vars (ctf_dict_t *fp)\n+{\n+  ctf_dvdef_t *dvd, *nvd;\n+  ctf_id_t type;\n+\n+  for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL; dvd = nvd)\n+    {\n+      nvd = ctf_list_next (dvd);\n+\n+      if (((type = (ctf_id_t) (uintptr_t)\n+\t    ctf_dynhash_lookup (fp->ctf_objthash, dvd->dvd_name)) > 0)\n+\t  && type == dvd->dvd_type)\n+\tctf_dvd_delete (fp, dvd);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Determine if a symbol is \"skippable\" and should never appear in the\n+   symtypetab sections.  */\n+\n+int\n+ctf_symtab_skippable (ctf_link_sym_t *sym)\n+{\n+  /* Never skip symbols whose name is not yet known.  */\n+  if (sym->st_nameidx_set)\n+    return 0;\n+\n+  return (sym->st_name == NULL || sym->st_name[0] == 0\n+\t  || sym->st_shndx == SHN_UNDEF\n+\t  || strcmp (sym->st_name, \"_START_\") == 0\n+\t  || strcmp (sym->st_name, \"_END_\") == 0\n+\t  || (sym->st_type == STT_OBJECT && sym->st_shndx == SHN_EXTABS\n+\t      && sym->st_value == 0));\n+}\n+\n+/* Symtypetab emission flags.  */\n+\n+#define CTF_SYMTYPETAB_EMIT_FUNCTION 0x1\n+#define CTF_SYMTYPETAB_EMIT_PAD 0x2\n+#define CTF_SYMTYPETAB_FORCE_INDEXED 0x4\n+\n+/* Get the number of symbols in a symbol hash, the count of symbols, the maximum\n+   seen, the eventual size, without any padding elements, of the func/data and\n+   (if generated) index sections, and the size of accumulated padding elements.\n+   The linker-reported set of symbols is found in SYMFP.\n+\n+   Also figure out if any symbols need to be moved to the variable section, and\n+   add them (if not already present).  */\n+\n+_libctf_nonnull_\n+static int\n+symtypetab_density (ctf_dict_t *fp, ctf_dict_t *symfp, ctf_dynhash_t *symhash,\n+\t\t    size_t *count, size_t *max, size_t *unpadsize,\n+\t\t    size_t *padsize, size_t *idxsize, int flags)\n+{\n+  ctf_next_t *i = NULL;\n+  const void *name;\n+  const void *ctf_sym;\n+  ctf_dynhash_t *linker_known = NULL;\n+  int err;\n+  int beyond_max = 0;\n+\n+  *count = 0;\n+  *max = 0;\n+  *unpadsize = 0;\n+  *idxsize = 0;\n+  *padsize = 0;\n+\n+  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+    {\n+      /* Make a dynhash citing only symbols reported by the linker of the\n+\t appropriate type, then traverse all potential-symbols we know the types\n+\t of, removing them from linker_known as we go.  Once this is done, the\n+\t only symbols remaining in linker_known are symbols we don't know the\n+\t types of: we must emit pads for those symbols that are below the\n+\t maximum symbol we will emit (any beyond that are simply skipped).  */\n+\n+      if ((linker_known = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t\t\t      NULL, NULL)) == NULL)\n+\treturn (ctf_set_errno (fp, ENOMEM));\n+\n+      while ((err = ctf_dynhash_cnext (symfp->ctf_dynsyms, &i,\n+\t\t\t\t       &name, &ctf_sym)) == 0)\n+\t{\n+\t  ctf_link_sym_t *sym = (ctf_link_sym_t *) ctf_sym;\n+\n+\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t       && sym->st_type != STT_FUNC)\n+\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t\t  && sym->st_type != STT_OBJECT))\n+\t    continue;\n+\n+\t  if (ctf_symtab_skippable (sym))\n+\t    continue;\n+\n+\t  /* This should only be true briefly before all the names are\n+\t     finalized, long before we get this far.  */\n+\t  if (!ctf_assert (fp, !sym->st_nameidx_set))\n+\t    return -1;\t\t\t\t/* errno is set for us.  */\n+\n+\t  if (ctf_dynhash_cinsert (linker_known, name, ctf_sym) < 0)\n+\t    {\n+\t      ctf_dynhash_destroy (linker_known);\n+\t      return (ctf_set_errno (fp, ENOMEM));\n+\t    }\n+\t}\n+      if (err != ECTF_NEXT_END)\n+\t{\n+\t  ctf_err_warn (fp, 0, err, _(\"iterating over linker-known symbols during \"\n+\t\t\t\t  \"serialization\"));\n+\t  ctf_dynhash_destroy (linker_known);\n+\t  return (ctf_set_errno (fp, err));\n+\t}\n+    }\n+\n+  while ((err = ctf_dynhash_cnext (symhash, &i, &name, NULL)) == 0)\n+    {\n+      ctf_link_sym_t *sym;\n+\n+      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+\t{\n+\t  /* Linker did not report symbol in symtab.  Remove it from the\n+\t     set of known data symbols and continue.  */\n+\t  if ((sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, name)) == NULL)\n+\t    {\n+\t      ctf_dynhash_remove (symhash, name);\n+\t      continue;\n+\t    }\n+\n+\t  /* We don't remove skippable symbols from the symhash because we don't\n+\t     want them to be migrated into variables.  */\n+\t  if (ctf_symtab_skippable (sym))\n+\t    continue;\n+\n+\t  if ((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t      && sym->st_type != STT_FUNC)\n+\t    {\n+\t      ctf_err_warn (fp, 1, 0, _(\"Symbol %x added to CTF as a function \"\n+\t\t\t\t\t\"but is of type %x\\n\"),\n+\t\t\t    sym->st_symidx, sym->st_type);\n+\t      ctf_dynhash_remove (symhash, name);\n+\t      continue;\n+\t    }\n+\t  else if (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t\t   && sym->st_type != STT_OBJECT)\n+\t    {\n+\t      ctf_err_warn (fp, 1, 0, _(\"Symbol %x added to CTF as a data \"\n+\t\t\t\t\t\"object but is of type %x\\n\"),\n+\t\t\t    sym->st_symidx, sym->st_type);\n+\t      ctf_dynhash_remove (symhash, name);\n+\t      continue;\n+\t    }\n+\n+\t  ctf_dynhash_remove (linker_known, name);\n+\t}\n+      *unpadsize += sizeof (uint32_t);\n+      (*count)++;\n+\n+      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+\t{\n+\t  if (*max < sym->st_symidx)\n+\t    *max = sym->st_symidx;\n+\t}\n+      else\n+\t(*max)++;\n+    }\n+  if (err != ECTF_NEXT_END)\n+    {\n+      ctf_err_warn (fp, 0, err, _(\"iterating over CTF symtypetab during \"\n+\t\t\t\t  \"serialization\"));\n+      ctf_dynhash_destroy (linker_known);\n+      return (ctf_set_errno (fp, err));\n+    }\n+\n+  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+    {\n+      while ((err = ctf_dynhash_cnext (linker_known, &i, NULL, &ctf_sym)) == 0)\n+\t{\n+\t  ctf_link_sym_t *sym = (ctf_link_sym_t *) ctf_sym;\n+\n+\t  if (sym->st_symidx > *max)\n+\t    beyond_max++;\n+\t}\n+      if (err != ECTF_NEXT_END)\n+\t{\n+\t  ctf_err_warn (fp, 0, err, _(\"iterating over linker-known symbols \"\n+\t\t\t\t      \"during CTF serialization\"));\n+\t  ctf_dynhash_destroy (linker_known);\n+\t  return (ctf_set_errno (fp, err));\n+\t}\n+    }\n+\n+  *idxsize = *count * sizeof (uint32_t);\n+  if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+    *padsize = (ctf_dynhash_elements (linker_known) - beyond_max) * sizeof (uint32_t);\n+\n+  ctf_dynhash_destroy (linker_known);\n+  return 0;\n+}\n+\n+/* Emit an objt or func symtypetab into DP in a particular order defined by an\n+   array of ctf_link_sym_t or symbol names passed in.  The index has NIDX\n+   elements in it: unindexed output would terminate at symbol OUTMAX and is in\n+   any case no larger than SIZE bytes.  Some index elements are expected to be\n+   skipped: see symtypetab_density.  The linker-reported set of symbols (if any)\n+   is found in SYMFP. */\n+static int\n+emit_symtypetab (ctf_dict_t *fp, ctf_dict_t *symfp, uint32_t *dp,\n+\t\t ctf_link_sym_t **idx, const char **nameidx, uint32_t nidx,\n+\t\t uint32_t outmax, int size, int flags)\n+{\n+  uint32_t i;\n+  uint32_t *dpp = dp;\n+  ctf_dynhash_t *symhash;\n+\n+  ctf_dprintf (\"Emitting table of size %i, outmax %u, %u symtypetab entries, \"\n+\t       \"flags %i\\n\", size, outmax, nidx, flags);\n+\n+  /* Empty table? Nothing to do.  */\n+  if (size == 0)\n+    return 0;\n+\n+  if (flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+    symhash = fp->ctf_funchash;\n+  else\n+    symhash = fp->ctf_objthash;\n+\n+  for (i = 0; i < nidx; i++)\n+    {\n+      const char *sym_name;\n+      void *type;\n+\n+      /* If we have a linker-reported set of symbols, we may be given that set\n+\t to work from, or a set of symbol names.  In both cases we want to look\n+\t at the corresponding linker-reported symbol (if any).  */\n+      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+\t{\n+\t  ctf_link_sym_t *this_link_sym;\n+\n+\t  if (idx)\n+\t    this_link_sym = idx[i];\n+\t  else\n+\t    this_link_sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, nameidx[i]);\n+\n+\t  /* Unreported symbol number.  No pad, no nothing.  */\n+\t  if (!this_link_sym)\n+\t    continue;\n+\n+\t  /* Symbol of the wrong type, or skippable?  This symbol is not in this\n+\t     table.  */\n+\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t       && this_link_sym->st_type != STT_FUNC)\n+\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t\t  && this_link_sym->st_type != STT_OBJECT))\n+\t    continue;\n+\n+\t  if (ctf_symtab_skippable (this_link_sym))\n+\t    continue;\n+\n+\t  sym_name = this_link_sym->st_name;\n+\n+\t  /* Linker reports symbol of a different type to the symbol we actually\n+\t     added?  Skip the symbol.  No pad, since the symbol doesn't actually\n+\t     belong in this table at all.  (Warned about in\n+\t     symtypetab_density.)  */\n+\t  if ((this_link_sym->st_type == STT_FUNC)\n+\t      && (ctf_dynhash_lookup (fp->ctf_objthash, sym_name)))\n+\t    continue;\n+\n+\t  if ((this_link_sym->st_type == STT_OBJECT)\n+\t      && (ctf_dynhash_lookup (fp->ctf_funchash, sym_name)))\n+\t    continue;\n+\t}\n+      else\n+\tsym_name = nameidx[i];\n+\n+      /* Symbol in index but no type set? Silently skip and (optionally)\n+\t pad.  (In force-indexed mode, this is also where we track symbols of\n+\t the wrong type for this round of insertion.)  */\n+      if ((type = ctf_dynhash_lookup (symhash, sym_name)) == NULL)\n+\t{\n+\t  if (flags & CTF_SYMTYPETAB_EMIT_PAD)\n+\t    *dpp++ = 0;\n+\t  continue;\n+\t}\n+\n+      if (!ctf_assert (fp, (((char *) dpp) - (char *) dp) < size))\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+\n+      *dpp++ = (ctf_id_t) (uintptr_t) type;\n+\n+      /* When emitting unindexed output, all later symbols are pads: stop\n+\t early.  */\n+      if ((flags & CTF_SYMTYPETAB_EMIT_PAD) && idx[i]->st_symidx == outmax)\n+\tbreak;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Emit an objt or func symtypetab index into DP in a paticular order defined by\n+   an array of symbol names passed in.  Stop at NIDX.  The linker-reported set\n+   of symbols (if any) is found in SYMFP. */\n+static int\n+emit_symtypetab_index (ctf_dict_t *fp, ctf_dict_t *symfp, uint32_t *dp,\n+\t\t       const char **idx, uint32_t nidx, int size, int flags)\n+{\n+  uint32_t i;\n+  uint32_t *dpp = dp;\n+  ctf_dynhash_t *symhash;\n+\n+  ctf_dprintf (\"Emitting index of size %i, %u entries reported by linker, \"\n+\t       \"flags %i\\n\", size, nidx, flags);\n+\n+  /* Empty table? Nothing to do.  */\n+  if (size == 0)\n+    return 0;\n+\n+  if (flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+    symhash = fp->ctf_funchash;\n+  else\n+    symhash = fp->ctf_objthash;\n+\n+  /* Indexes should always be unpadded.  */\n+  if (!ctf_assert (fp, !(flags & CTF_SYMTYPETAB_EMIT_PAD)))\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  for (i = 0; i < nidx; i++)\n+    {\n+      const char *sym_name;\n+      void *type;\n+\n+      if (!(flags & CTF_SYMTYPETAB_FORCE_INDEXED))\n+\t{\n+\t  ctf_link_sym_t *this_link_sym;\n+\n+\t  this_link_sym = ctf_dynhash_lookup (symfp->ctf_dynsyms, idx[i]);\n+\n+\t  /* This is an index: unreported symbols should never appear in it.  */\n+\t  if (!ctf_assert (fp, this_link_sym != NULL))\n+\t    return -1;\t\t\t\t/* errno is set for us.  */\n+\n+\t  /* Symbol of the wrong type, or skippable?  This symbol is not in this\n+\t     table.  */\n+\t  if (((flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t       && this_link_sym->st_type != STT_FUNC)\n+\t      || (!(flags & CTF_SYMTYPETAB_EMIT_FUNCTION)\n+\t\t  && this_link_sym->st_type != STT_OBJECT))\n+\t    continue;\n+\n+\t  if (ctf_symtab_skippable (this_link_sym))\n+\t    continue;\n+\n+\t  sym_name = this_link_sym->st_name;\n+\n+\t  /* Linker reports symbol of a different type to the symbol we actually\n+\t     added?  Skip the symbol.  */\n+\t  if ((this_link_sym->st_type == STT_FUNC)\n+\t      && (ctf_dynhash_lookup (fp->ctf_objthash, sym_name)))\n+\t    continue;\n+\n+\t  if ((this_link_sym->st_type == STT_OBJECT)\n+\t      && (ctf_dynhash_lookup (fp->ctf_funchash, sym_name)))\n+\t    continue;\n+\t}\n+      else\n+\tsym_name = idx[i];\n+\n+      /* Symbol in index and reported by linker, but no type set? Silently skip\n+\t and (optionally) pad.  (In force-indexed mode, this is also where we\n+\t track symbols of the wrong type for this round of insertion.)  */\n+      if ((type = ctf_dynhash_lookup (symhash, sym_name)) == NULL)\n+\tcontinue;\n+\n+      ctf_str_add_ref (fp, sym_name, dpp++);\n+\n+      if (!ctf_assert (fp, (((char *) dpp) - (char *) dp) <= size))\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+    }\n+\n+  return 0;\n+}\n+\n static unsigned char *\n ctf_copy_smembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n {\n@@ -275,11 +676,18 @@ ctf_serialize (ctf_dict_t *fp)\n   ctf_dvdef_t *dvd;\n   ctf_varent_t *dvarents;\n   ctf_strs_writable_t strtab;\n+  ctf_dict_t *symfp = fp;\n \n   unsigned char *t;\n   unsigned long i;\n-  size_t buf_size, type_size, nvars;\n-  unsigned char *buf, *newbuf;\n+  int symflags = 0;\n+  size_t buf_size, type_size, objt_size, func_size;\n+  size_t objt_unpadsize, func_unpadsize, objt_padsize, func_padsize;\n+  size_t funcidx_size, objtidx_size;\n+  size_t nvars, nfuncs, nobjts, maxobjt, maxfunc;\n+  size_t ndynsyms = 0;\n+  const char **sym_name_order = NULL;\n+  unsigned char *buf = NULL, *newbuf;\n   int err;\n \n   if (!(fp->ctf_flags & LCTF_RDWR))\n@@ -292,13 +700,17 @@ ctf_serialize (ctf_dict_t *fp)\n   /* Fill in an initial CTF header.  We will leave the label, object,\n      and function sections empty and only output a header, type section,\n      and string table.  The type section begins at a 4-byte aligned\n-     boundary past the CTF header itself (at relative offset zero).  */\n+     boundary past the CTF header itself (at relative offset zero).  The flag\n+     indicating a new-style function info section (an array of CTF_K_FUNCTION\n+     type IDs in the types section) is flipped on.  */\n \n   memset (&hdr, 0, sizeof (hdr));\n   hdr.cth_magic = CTF_MAGIC;\n   hdr.cth_version = CTF_VERSION;\n \n-  hdr.cth_flags = CTF_F_DYNSTR;\n+  /* This is a new-format func info section, and the symtab and strtab come out\n+     of the dynsym and dynstr these days.  */\n+  hdr.cth_flags = (CTF_F_NEWFUNCINFO | CTF_F_DYNSTR);\n \n   /* Iterate through the dynamic type definition list and compute the\n      size of the CTF type section we will need to generate.  */\n@@ -342,6 +754,84 @@ ctf_serialize (ctf_dict_t *fp)\n \t}\n     }\n \n+  /* Symbol table stuff is done only if the linker has told this dict about\n+     potential symbols (usually the case for parent dicts only).  The linker\n+     will report symbols to the parent dict in a parent/child link, as usual\n+     with all linker-related matters.  */\n+\n+  if (!fp->ctf_dynsyms && fp->ctf_parent && fp->ctf_parent->ctf_dynsyms)\n+    symfp = fp->ctf_parent;\n+\n+  /* No linker-reported symbols at all: ctf_link_shuffle_syms was never called.\n+     This must be an unsorted, indexed dict.  Otherwise, this is a sorted\n+     dict, and the header flags indicate as much.  */\n+  if (!symfp->ctf_dynsyms)\n+    symflags = CTF_SYMTYPETAB_FORCE_INDEXED;\n+  else\n+    hdr.cth_flags |= CTF_F_IDXSORTED;\n+\n+  /* Work out the sizes of the object and function sections, and work out the\n+     number of pad (unassigned) symbols in each, and the overall size of the\n+     sections.  */\n+\n+  if (symtypetab_density (fp, symfp, fp->ctf_objthash, &nobjts, &maxobjt,\n+\t\t\t  &objt_unpadsize, &objt_padsize, &objtidx_size,\n+\t\t\t  symflags) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  ctf_dprintf (\"Object symtypetab: %i objects, max %i, unpadded size %i, \"\n+\t       \"%i bytes of pads, index size %i\\n\", (int) nobjts, (int) maxobjt,\n+\t       (int) objt_unpadsize, (int) objt_padsize, (int) objtidx_size);\n+\n+  if (symtypetab_density (fp, symfp, fp->ctf_funchash, &nfuncs, &maxfunc,\n+\t\t\t  &func_unpadsize, &func_padsize, &funcidx_size,\n+\t\t\t  symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n+  ctf_dprintf (\"Function symtypetab: %i functions, max %i, unpadded size %i, \"\n+\t       \"%i bytes of pads, index size %i\\n\", (int) nfuncs, (int) maxfunc,\n+\t       (int) func_unpadsize, (int) func_padsize, (int) funcidx_size);\n+\n+  /* If the linker has reported any symbols at all, those symbols that the\n+     linker has not reported are now removed from the ctf_objthash and\n+     ctf_funchash.  Delete entries from the variable section that duplicate\n+     newly-added data symbols.  There's no need to migrate new ones in, because\n+     linker invocations (even ld -r) can only introduce new symbols, not remove\n+     symbols that already exist, and the compiler always emits both a variable\n+     and a data symbol simultaneously.  */\n+\n+  if (symtypetab_delete_nonstatic_vars (fp) < 0)\n+    return -1;\n+\n+  /* It is worth indexing each section if it would save space to do so, due to\n+     reducing the number of pads sufficiently.  A pad is the same size as a\n+     single index entry: but index sections compress relatively poorly compared\n+     to constant pads, so it takes a lot of contiguous padding to equal one\n+     index section entry.  It would be nice to be able to *verify* whether we\n+     would save space after compression rather than guessing, but this seems\n+     difficult, since it would require complete reserialization.  Regardless, if\n+     the linker has not reported any symbols (e.g. if this is not a final link\n+     but just an ld -r), we must emit things in indexed fashion just as the\n+     compiler does.  */\n+\n+  objt_size = objt_unpadsize;\n+  if (!(symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n+      && ((objt_padsize + objt_unpadsize) * CTF_INDEX_PAD_THRESHOLD\n+\t  > objt_padsize))\n+    {\n+      objt_size += objt_padsize;\n+      objtidx_size = 0;\n+    }\n+\n+  func_size = func_unpadsize;\n+  if (!(symflags & CTF_SYMTYPETAB_FORCE_INDEXED)\n+      && ((func_padsize + func_unpadsize) * CTF_INDEX_PAD_THRESHOLD\n+\t  > func_padsize))\n+    {\n+      func_size += func_padsize;\n+      funcidx_size = 0;\n+    }\n+\n   /* Computing the number of entries in the CTF variable section is much\n      simpler.  */\n \n@@ -352,6 +842,11 @@ ctf_serialize (ctf_dict_t *fp)\n      then allocate a new buffer and memcpy the finished header to the start of\n      the buffer.  (We will adjust this later with strtab length info.)  */\n \n+  hdr.cth_lbloff = hdr.cth_objtoff = 0;\n+  hdr.cth_funcoff = hdr.cth_objtoff + objt_size;\n+  hdr.cth_objtidxoff = hdr.cth_funcoff + func_size;\n+  hdr.cth_funcidxoff = hdr.cth_objtidxoff + objtidx_size;\n+  hdr.cth_varoff = hdr.cth_funcidxoff + funcidx_size;\n   hdr.cth_typeoff = hdr.cth_varoff + (nvars * sizeof (ctf_varent_t));\n   hdr.cth_stroff = hdr.cth_typeoff + type_size;\n   hdr.cth_strlen = 0;\n@@ -362,14 +857,122 @@ ctf_serialize (ctf_dict_t *fp)\n     return (ctf_set_errno (fp, EAGAIN));\n \n   memcpy (buf, &hdr, sizeof (ctf_header_t));\n-  t = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_varoff;\n+  t = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_objtoff;\n \n   hdrp = (ctf_header_t *) buf;\n   if ((fp->ctf_flags & LCTF_CHILD) && (fp->ctf_parname != NULL))\n     ctf_str_add_ref (fp, fp->ctf_parname, &hdrp->cth_parname);\n   if (fp->ctf_cuname != NULL)\n     ctf_str_add_ref (fp, fp->ctf_cuname, &hdrp->cth_cuname);\n \n+  /* Sort the linker's symbols into name order if need be: if\n+     ctf_link_shuffle_syms has not been called at all, just use all the symbols\n+     that were added to this dict, and don't bother sorting them since this is\n+     probably an ld -r and will likely just be consumed by ld again, with no\n+     ctf_lookup_by_symbol()s ever done on it.  */\n+\n+  if ((objtidx_size != 0) || (funcidx_size != 0))\n+    {\n+      ctf_next_t *i = NULL;\n+      void *symname;\n+      const char **walk;\n+      int err;\n+\n+      if (symfp->ctf_dynsyms)\n+\tndynsyms = ctf_dynhash_elements (symfp->ctf_dynsyms);\n+      else\n+\tndynsyms = ctf_dynhash_elements (symfp->ctf_objthash)\n+\t  + ctf_dynhash_elements (symfp->ctf_funchash);\n+\n+      if ((sym_name_order = calloc (ndynsyms, sizeof (const char *))) == NULL)\n+\tgoto oom;\n+\n+      walk = sym_name_order;\n+\n+      if (symfp->ctf_dynsyms)\n+\t{\n+\t  while ((err = ctf_dynhash_next_sorted (symfp->ctf_dynsyms, &i, &symname,\n+\t\t\t\t\t\t NULL, ctf_dynhash_sort_by_name,\n+\t\t\t\t\t\t NULL)) == 0)\n+\t    *walk++ = (const char *) symname;\n+\t  if (err != ECTF_NEXT_END)\n+\t    goto symerr;\n+\t}\n+      else\n+\t{\n+\t  while ((err = ctf_dynhash_next (symfp->ctf_objthash, &i, &symname,\n+\t\t\t\t\t  NULL)) == 0)\n+\t    *walk++ = (const char *) symname;\n+\t  if (err != ECTF_NEXT_END)\n+\t    goto symerr;\n+\n+\t  while ((err = ctf_dynhash_next (symfp->ctf_funchash, &i, &symname,\n+\t\t\t\t\t  NULL)) == 0)\n+\t    *walk++ = (const char *) symname;\n+\t  if (err != ECTF_NEXT_END)\n+\t    goto symerr;\n+\t}\n+    }\n+\n+  /* Emit the object and function sections, and if necessary their indexes.\n+     Emission is done in symtab order if there is no index, and in index\n+     (name) order otherwise.  */\n+\n+  if ((objtidx_size == 0) && symfp->ctf_dynsymidx)\n+    {\n+      ctf_dprintf (\"Emitting unindexed objt symtypetab\\n\");\n+      if (emit_symtypetab (fp, symfp, (uint32_t *) t, symfp->ctf_dynsymidx,\n+\t\t\t   NULL, symfp->ctf_dynsymmax + 1, maxobjt, objt_size,\n+\t\t\t   symflags | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n+\tgoto err;\t\t\t\t/* errno is set for us.  */\n+    }\n+  else\n+    {\n+      ctf_dprintf (\"Emitting indexed objt symtypetab\\n\");\n+      if (emit_symtypetab (fp, symfp, (uint32_t *) t, NULL, sym_name_order,\n+\t\t\t   ndynsyms, maxobjt, objt_size, symflags) < 0)\n+\tgoto err;\t\t\t\t/* errno is set for us.  */\n+    }\n+\n+  t += objt_size;\n+\n+  if ((funcidx_size == 0) && symfp->ctf_dynsymidx)\n+    {\n+      ctf_dprintf (\"Emitting unindexed func symtypetab\\n\");\n+      if (emit_symtypetab (fp, symfp, (uint32_t *) t, symfp->ctf_dynsymidx,\n+\t\t\t   NULL, symfp->ctf_dynsymmax + 1, maxfunc,\n+\t\t\t   func_size, symflags | CTF_SYMTYPETAB_EMIT_FUNCTION\n+\t\t\t   | CTF_SYMTYPETAB_EMIT_PAD) < 0)\n+\tgoto err;\t\t\t\t/* errno is set for us.  */\n+    }\n+  else\n+    {\n+      ctf_dprintf (\"Emitting indexed func symtypetab\\n\");\n+      if (emit_symtypetab (fp, symfp, (uint32_t *) t, NULL, sym_name_order,\n+\t\t\t   ndynsyms, maxfunc, func_size,\n+\t\t\t   symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+\tgoto err;\t\t\t\t/* errno is set for us.  */\n+    }\n+\n+  t += func_size;\n+\n+  if (objtidx_size > 0)\n+    if (emit_symtypetab_index (fp, symfp, (uint32_t *) t, sym_name_order,\n+\t\t\t       ndynsyms, objtidx_size, symflags) < 0)\n+      goto err;\n+\n+  t += objtidx_size;\n+\n+  if (funcidx_size > 0)\n+    if (emit_symtypetab_index (fp, symfp, (uint32_t *) t, sym_name_order,\n+\t\t\t       ndynsyms, funcidx_size,\n+\t\t\t       symflags | CTF_SYMTYPETAB_EMIT_FUNCTION) < 0)\n+      goto err;\n+\n+  t += funcidx_size;\n+  free (sym_name_order);\n+  sym_name_order = NULL;\n+\n   /* Work over the variable list, translating everything into ctf_varent_t's and\n      prepping the string table.  */\n \n@@ -486,10 +1089,7 @@ ctf_serialize (ctf_dict_t *fp)\n   ctf_str_purge_refs (fp);\n \n   if (strtab.cts_strs == NULL)\n-    {\n-      free (buf);\n-      return (ctf_set_errno (fp, EAGAIN));\n-    }\n+    goto oom;\n \n   /* Now the string table is constructed, we can sort the buffer of\n      ctf_varent_t's.  */\n@@ -499,9 +1099,8 @@ ctf_serialize (ctf_dict_t *fp)\n \n   if ((newbuf = ctf_realloc (fp, buf, buf_size + strtab.cts_len)) == NULL)\n     {\n-      free (buf);\n       free (strtab.cts_strs);\n-      return (ctf_set_errno (fp, EAGAIN));\n+      goto oom;\n     }\n   buf = newbuf;\n   memcpy (buf + buf_size, strtab.cts_strs, strtab.cts_len);\n@@ -537,13 +1136,25 @@ ctf_serialize (ctf_dict_t *fp)\n   nfp->ctf_add_processing = fp->ctf_add_processing;\n   nfp->ctf_snapshots = fp->ctf_snapshots + 1;\n   nfp->ctf_specific = fp->ctf_specific;\n+  nfp->ctf_nfuncidx = fp->ctf_nfuncidx;\n+  nfp->ctf_nobjtidx = fp->ctf_nobjtidx;\n+  nfp->ctf_objthash = fp->ctf_objthash;\n+  nfp->ctf_funchash = fp->ctf_funchash;\n+  nfp->ctf_dynsyms = fp->ctf_dynsyms;\n   nfp->ctf_ptrtab = fp->ctf_ptrtab;\n+  nfp->ctf_dynsymidx = fp->ctf_dynsymidx;\n+  nfp->ctf_dynsymmax = fp->ctf_dynsymmax;\n   nfp->ctf_ptrtab_len = fp->ctf_ptrtab_len;\n   nfp->ctf_link_inputs = fp->ctf_link_inputs;\n   nfp->ctf_link_outputs = fp->ctf_link_outputs;\n   nfp->ctf_errs_warnings = fp->ctf_errs_warnings;\n+  nfp->ctf_funcidx_names = fp->ctf_funcidx_names;\n+  nfp->ctf_objtidx_names = fp->ctf_objtidx_names;\n+  nfp->ctf_funcidx_sxlate = fp->ctf_funcidx_sxlate;\n+  nfp->ctf_objtidx_sxlate = fp->ctf_objtidx_sxlate;\n   nfp->ctf_str_prov_offset = fp->ctf_str_prov_offset;\n   nfp->ctf_syn_ext_strtab = fp->ctf_syn_ext_strtab;\n+  nfp->ctf_in_flight_dynsyms = fp->ctf_in_flight_dynsyms;\n   nfp->ctf_link_in_cu_mapping = fp->ctf_link_in_cu_mapping;\n   nfp->ctf_link_out_cu_mapping = fp->ctf_link_out_cu_mapping;\n   nfp->ctf_link_type_mapping = fp->ctf_link_type_mapping;\n@@ -574,6 +1185,14 @@ ctf_serialize (ctf_dict_t *fp)\n   memset (&fp->ctf_errs_warnings, 0, sizeof (ctf_list_t));\n   fp->ctf_add_processing = NULL;\n   fp->ctf_ptrtab = NULL;\n+  fp->ctf_funcidx_names = NULL;\n+  fp->ctf_objtidx_names = NULL;\n+  fp->ctf_funcidx_sxlate = NULL;\n+  fp->ctf_objtidx_sxlate = NULL;\n+  fp->ctf_objthash = NULL;\n+  fp->ctf_funchash = NULL;\n+  fp->ctf_dynsyms = NULL;\n+  fp->ctf_dynsymidx = NULL;\n   fp->ctf_link_inputs = NULL;\n   fp->ctf_link_outputs = NULL;\n   fp->ctf_syn_ext_strtab = NULL;\n@@ -587,6 +1206,7 @@ ctf_serialize (ctf_dict_t *fp)\n   fp->ctf_dvhash = NULL;\n   memset (&fp->ctf_dvdefs, 0, sizeof (ctf_list_t));\n   memset (fp->ctf_lookups, 0, sizeof (fp->ctf_lookups));\n+  memset (&fp->ctf_in_flight_dynsyms, 0, sizeof (fp->ctf_in_flight_dynsyms));\n   memset (&fp->ctf_dedup, 0, sizeof (fp->ctf_dedup));\n   fp->ctf_structs.ctn_writable = NULL;\n   fp->ctf_unions.ctn_writable = NULL;\n@@ -597,10 +1217,22 @@ ctf_serialize (ctf_dict_t *fp)\n   memcpy (fp, nfp, sizeof (ctf_dict_t));\n   memcpy (nfp, &ofp, sizeof (ctf_dict_t));\n \n-  nfp->ctf_refcnt = 1;\t\t/* Force nfp to be freed.  */\n+  nfp->ctf_refcnt = 1;\t\t\t\t/* Force nfp to be freed.  */\n   ctf_dict_close (nfp);\n \n   return 0;\n+\n+symerr:\n+  ctf_err_warn (fp, 0, err, _(\"error serializing symtypetabs\"));\n+  goto err;\n+oom:\n+  free (buf);\n+  free (sym_name_order);\n+  return (ctf_set_errno (fp, EAGAIN));\n+err:\n+  free (buf);\n+  free (sym_name_order);\n+  return -1;\t\t\t\t\t/* errno is set for us.  */\n }\n \n ctf_names_t *\n@@ -1598,6 +2230,49 @@ ctf_add_variable (ctf_dict_t *fp, const char *name, ctf_id_t ref)\n   return 0;\n }\n \n+int\n+ctf_add_funcobjt_sym (ctf_dict_t *fp, int is_function, const char *name, ctf_id_t id)\n+{\n+  ctf_dict_t *tmp = fp;\n+  char *dupname;\n+  ctf_dynhash_t *h = is_function ? fp->ctf_funchash : fp->ctf_objthash;\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  if (ctf_dynhash_lookup (fp->ctf_objthash, name) != NULL ||\n+      ctf_dynhash_lookup (fp->ctf_funchash, name) != NULL)\n+    return (ctf_set_errno (fp, ECTF_DUPLICATE));\n+\n+  if (ctf_lookup_by_id (&tmp, id) == NULL)\n+    return -1;                                  /* errno is set for us.  */\n+\n+  if (is_function && ctf_type_kind (fp, id) != CTF_K_FUNCTION)\n+    return (ctf_set_errno (fp, ECTF_NOTFUNC));\n+\n+  if ((dupname = strdup (name)) == NULL)\n+    return (ctf_set_errno (fp, ENOMEM));\n+\n+  if (ctf_dynhash_insert (h, dupname, (void *) (uintptr_t) id) < 0)\n+    {\n+      free (dupname);\n+      return (ctf_set_errno (fp, ENOMEM));\n+    }\n+  return 0;\n+}\n+\n+int\n+ctf_add_objt_sym (ctf_dict_t *fp, const char *name, ctf_id_t id)\n+{\n+  return (ctf_add_funcobjt_sym (fp, 0, name, id));\n+}\n+\n+int\n+ctf_add_func_sym (ctf_dict_t *fp, const char *name, ctf_id_t id)\n+{\n+  return (ctf_add_funcobjt_sym (fp, 1, name, id));\n+}\n+\n typedef struct ctf_bundle\n {\n   ctf_dict_t *ctb_dict;\t\t/* CTF dict handle.  */"
    },
    {
      "sha": "202fad0396324f299bb3455d622a224e36e642b4",
      "filename": "libctf/ctf-hash.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -476,6 +476,13 @@ ctf_dynhash_next (ctf_dynhash_t *h, ctf_next_t **it, void **key, void **value)\n   return ECTF_NEXT_END;\n }\n \n+int\n+ctf_dynhash_sort_by_name (const ctf_next_hkv_t *one, const ctf_next_hkv_t *two,\n+\t\t\t  void *unused _libctf_unused_)\n+{\n+  return strcmp ((char *) one->hkv_key, (char *) two->hkv_key);\n+}\n+\n /* Traverse a sorted dynhash, in _next iterator form.\n \n    See ctf_dynhash_next for notes on error returns, etc."
    },
    {
      "sha": "62ea360436873dd5559ce37b7fd16701d982ba34",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 56,
      "deletions": 6,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -43,6 +43,15 @@ extern \"C\"\n {\n #endif\n \n+/* Tuning.  */\n+\n+/* The proportion of symtypetab entries which must be pads before we consider it\n+   worthwhile to emit a symtypetab section as an index.  Indexes cost time to\n+   look up, but save space all told.  Do not set to 1, since this will cause\n+   indexes to be eschewed completely, even in child dicts, at considerable space\n+   cost.  */\n+#define CTF_INDEX_PAD_THRESHOLD .75\n+\n /* Compiler attributes.  */\n \n #if defined (__GNUC__)\n@@ -61,13 +70,15 @@ extern \"C\"\n #define _libctf_unlikely_(x) __builtin_expect ((x), 0)\n #define _libctf_unused_ __attribute__ ((__unused__))\n #define _libctf_malloc_ __attribute__((__malloc__))\n+#define _libctf_nonnull_ __attribute__((__nonnull__))\n \n #else\n \n #define _libctf_printflike_(string_index,first_to_check)\n #define _libctf_unlikely_(x) (x)\n #define _libctf_unused_\n #define _libctf_malloc_\n+#define _libctf_nonnull_\n #define __extension__\n \n #endif\n@@ -232,6 +243,14 @@ typedef struct ctf_str_atom_ref\n   uint32_t *caf_ref;\t\t/* A single ref to this string.  */\n } ctf_str_atom_ref_t;\n \n+/* A single linker-provided symbol, during symbol addition, possibly before we\n+   have been given external strtab refs.  */\n+typedef struct ctf_in_flight_dynsym\n+{\n+  ctf_list_t cid_list;\t\t/* List forward/back pointers.  */\n+  ctf_link_sym_t cid_sym;\t/* The linker-known symbol.  */\n+} ctf_in_flight_dynsym_t;\n+\n /* The structure used as the key in a ctf_link_type_mapping.  The value is a\n    type index, not a type ID.  */\n \n@@ -380,11 +399,28 @@ struct ctf_dict\n   unsigned char *ctf_dynbase;\t  /* Freeable CTF file pointer. */\n   unsigned char *ctf_buf;\t  /* Uncompressed CTF data buffer.  */\n   size_t ctf_size;\t\t  /* Size of CTF header + uncompressed data.  */\n-  uint32_t *ctf_sxlate;\t\t  /* Translation table for symtab entries.  */\n+  uint32_t *ctf_sxlate;\t\t  /* Translation table for unindexed symtypetab\n+\t\t\t\t     entries.  */\n   unsigned long ctf_nsyms;\t  /* Number of entries in symtab xlate table.  */\n   uint32_t *ctf_txlate;\t\t  /* Translation table for type IDs.  */\n   uint32_t *ctf_ptrtab;\t\t  /* Translation table for pointer-to lookups.  */\n   size_t ctf_ptrtab_len;\t  /* Num types storable in ptrtab currently.  */\n+  uint32_t *ctf_funcidx_names;\t  /* Name of each function symbol in symtypetab\n+\t\t\t\t     (if indexed).  */\n+  uint32_t *ctf_objtidx_names;\t  /* Likewise, for object symbols.  */\n+  size_t ctf_nfuncidx;\t\t  /* Number of funcidx entries.  */\n+  uint32_t *ctf_funcidx_sxlate;\t  /* Offsets into funcinfo for a given funcidx.  */\n+  uint32_t *ctf_objtidx_sxlate;\t  /* Likewise, for ctf_objtidx.  */\n+  size_t ctf_nobjtidx;\t\t  /* Number of objtidx entries.  */\n+  ctf_dynhash_t *ctf_objthash;\t  /* name -> type ID.  */\n+  ctf_dynhash_t *ctf_funchash;\t  /* name -> CTF_K_FUNCTION type ID.  */\n+\n+  /* The next three are linker-derived state found in ctf_link targets only.  */\n+\n+  ctf_dynhash_t *ctf_dynsyms;\t  /* Symbol info from ctf_link_shuffle_syms.  */\n+  ctf_link_sym_t **ctf_dynsymidx;  /* Indexes ctf_dynsyms by symidx.  */\n+  uint32_t ctf_dynsymmax;\t  /* Maximum ctf_dynsym index.  */\n+  ctf_list_t ctf_in_flight_dynsyms; /* Dynsyms during accumulation.  */\n   struct ctf_varent *ctf_vars;\t  /* Sorted variable->type mapping.  */\n   unsigned long ctf_nvars;\t  /* Number of variables in ctf_vars.  */\n   unsigned long ctf_typemax;\t  /* Maximum valid type ID number.  */\n@@ -494,14 +530,18 @@ struct ctf_next\n   /* We can save space on this side of things by noting that a dictionary is\n      either dynamic or not, as a whole, and a given iterator can only iterate\n      over one kind of thing at once: so we can overlap the DTD and non-DTD\n-     members, and the structure, variable and enum members, etc.  */\n+     members, and the structure, variable and enum members, etc.\n+\n+     Some of the _next iterators actually thunk down to another _next iterator\n+     themselves, so one of the options in here is a _next iterator!  */\n   union\n   {\n     const ctf_member_t *ctn_mp;\n     const ctf_lmember_t *ctn_lmp;\n     const ctf_dmdef_t *ctn_dmd;\n     const ctf_enum_t *ctn_en;\n     const ctf_dvdef_t *ctn_dvd;\n+    ctf_next_t *ctn_next;\n     ctf_next_hkv_t *ctn_sorted_hkv;\n     void **ctn_hash_slot;\n   } u;\n@@ -542,16 +582,20 @@ struct ctf_next\n #define LCTF_VBYTES(fp, kind, size, vlen) \\\n   ((fp)->ctf_dictops->ctfo_get_vbytes(fp, kind, size, vlen))\n \n-#define LCTF_CHILD\t0x0001\t/* CTF dict is a child */\n-#define LCTF_RDWR\t0x0002\t/* CTF dict is writable */\n-#define LCTF_DIRTY\t0x0004\t/* CTF dict has been modified */\n+#define LCTF_CHILD\t0x0001\t/* CTF dict is a child.  */\n+#define LCTF_RDWR\t0x0002\t/* CTF dict is writable.  */\n+#define LCTF_DIRTY\t0x0004\t/* CTF dict has been modified.  */\n \n extern ctf_names_t *ctf_name_table (ctf_dict_t *, int);\n extern const ctf_type_t *ctf_lookup_by_id (ctf_dict_t **, ctf_id_t);\n extern ctf_id_t ctf_lookup_by_rawname (ctf_dict_t *, int, const char *);\n extern ctf_id_t ctf_lookup_by_rawhash (ctf_dict_t *, ctf_names_t *, const char *);\n extern void ctf_set_ctl_hashes (ctf_dict_t *);\n \n+extern int ctf_symtab_skippable (ctf_link_sym_t *sym);\n+extern int ctf_add_funcobjt_sym (ctf_dict_t *, int is_function,\n+\t\t\t\t const char *, ctf_id_t);\n+\n extern ctf_dict_t *ctf_get_dict (ctf_dict_t *fp, ctf_id_t type);\n \n typedef unsigned int (*ctf_hash_fun) (const void *ptr);\n@@ -598,6 +642,9 @@ extern void ctf_dynhash_iter_remove (ctf_dynhash_t *, ctf_hash_iter_remove_f,\n \t\t\t\t     void *);\n extern void *ctf_dynhash_iter_find (ctf_dynhash_t *, ctf_hash_iter_find_f,\n \t\t\t\t    void *);\n+extern int ctf_dynhash_sort_by_name (const ctf_next_hkv_t *,\n+\t\t\t\t     const ctf_next_hkv_t *,\n+\t\t\t\t     void * _libctf_unused_);\n extern int ctf_dynhash_next (ctf_dynhash_t *, ctf_next_t **,\n \t\t\t     void **key, void **value);\n extern int ctf_dynhash_next_sorted (ctf_dynhash_t *, ctf_next_t **,\n@@ -721,7 +768,10 @@ extern void ctf_assert_fail_internal (ctf_dict_t *, const char *,\n \t\t\t\t      size_t, const char *);\n extern const char *ctf_link_input_name (ctf_dict_t *);\n \n-extern Elf64_Sym *ctf_sym_to_elf64 (const Elf32_Sym *src, Elf64_Sym *dst);\n+extern ctf_link_sym_t *ctf_elf32_to_link_sym (ctf_dict_t *fp, ctf_link_sym_t *dst,\n+\t\t\t\t\t      const Elf32_Sym *src, uint32_t symidx);\n+extern ctf_link_sym_t *ctf_elf64_to_link_sym (ctf_dict_t *fp, ctf_link_sym_t *dst,\n+\t\t\t\t\t      const Elf64_Sym *src, uint32_t symidx);\n extern const char *ctf_lookup_symbol_name (ctf_dict_t *fp, unsigned long symidx);\n \n /* Variables, all underscore-prepended. */"
    },
    {
      "sha": "4b86ca98095787316e42a4799131ffed1dde3215",
      "filename": "libctf/ctf-link.c",
      "status": "modified",
      "additions": 331,
      "deletions": 15,
      "changes": 346,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -51,10 +51,6 @@ ctf_add_type_mapping (ctf_dict_t *src_fp, ctf_id_t src_type,\n \n   dst_type = LCTF_TYPE_TO_INDEX(dst_fp, dst_type);\n \n-  /* This dynhash is a bit tricky: it has a multivalued (structural) key, so we\n-     need to use the sized-hash machinery to generate key hashing and equality\n-     functions.  */\n-\n   if (dst_fp->ctf_link_type_mapping == NULL)\n     {\n       ctf_hash_fun f = ctf_hash_type_key;\n@@ -574,7 +570,7 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n   ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n   ctf_dict_t *per_cu_out_fp;\n   ctf_id_t dst_type = 0;\n-  ctf_dict_t *check_fp;\n+  ctf_dict_t *insert_fp;\n   ctf_dvdef_t *dvd;\n \n   /* See if this variable is filtered out.  */\n@@ -590,18 +586,18 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n      dict, we want to try to add to that first: if it reports a duplicate,\n      or if the type is in a child already, add straight to the child.  */\n \n-  check_fp = arg->out_fp;\n+  insert_fp = arg->out_fp;\n \n-  dst_type = ctf_type_mapping (arg->in_fp, type, &check_fp);\n+  dst_type = ctf_type_mapping (arg->in_fp, type, &insert_fp);\n   if (dst_type != 0)\n     {\n-      if (check_fp == arg->out_fp)\n+      if (insert_fp == arg->out_fp)\n \t{\n-\t  if (check_variable (name, check_fp, dst_type, &dvd))\n+\t  if (check_variable (name, insert_fp, dst_type, &dvd))\n \t    {\n \t      /* No variable here: we can add it.  */\n-\t      if (ctf_add_variable (check_fp, name, dst_type) < 0)\n-\t\treturn (ctf_set_errno (arg->out_fp, ctf_errno (check_fp)));\n+\t      if (ctf_add_variable (insert_fp, name, dst_type) < 0)\n+\t\treturn (ctf_set_errno (arg->out_fp, ctf_errno (insert_fp)));\n \t      return 0;\n \t    }\n \n@@ -628,11 +624,11 @@ ctf_link_one_variable (const char *name, ctf_id_t type, void *arg_)\n \t\t\t\t\t  arg->cu_name)) == NULL)\n     return -1;\t\t\t\t\t/* Errno is set for us.  */\n \n-  /* If the type was not found, check for it in the child too. */\n+  /* If the type was not found, check for it in the child too.  */\n   if (dst_type == 0)\n     {\n-      check_fp = per_cu_out_fp;\n-      dst_type = ctf_type_mapping (arg->in_fp, type, &check_fp);\n+      insert_fp = per_cu_out_fp;\n+      dst_type = ctf_type_mapping (arg->in_fp, type, &insert_fp);\n \n       if (dst_type == 0)\n \t{\n@@ -1153,6 +1149,169 @@ ctf_link_deduplicating_variables (ctf_dict_t *fp, ctf_dict_t **inputs,\n   return 0;\n }\n \n+/* Check for symbol conflicts during linking.  Three possibilities: already\n+   exists, conflicting, or nonexistent.  We don't have a dvd structure we can\n+   use as a flag like check_variable does, so we use a tristate return\n+   value instead: -1: conflicting; 1: nonexistent: 0: already exists.  */\n+\n+static int\n+check_sym (ctf_dict_t *fp, const char *name, ctf_id_t type, int functions)\n+{\n+  ctf_dynhash_t *thishash = functions ? fp->ctf_funchash : fp->ctf_objthash;\n+  ctf_dynhash_t *thathash = functions ? fp->ctf_objthash : fp->ctf_funchash;\n+  void *value;\n+\n+  /* Wrong type (function when object is wanted, etc).  */\n+  if (ctf_dynhash_lookup_kv (thathash, name, NULL, NULL))\n+    return -1;\n+\n+  /* Not present at all yet.  */\n+  if (!ctf_dynhash_lookup_kv (thishash, name, NULL, &value))\n+    return 1;\n+\n+  /* Already present.  */\n+  if ((ctf_id_t) (uintptr_t) value == type)\n+    return 0;\n+\n+  /* Wrong type.  */\n+  return -1;\n+}\n+\n+/* Do a deduplicating link of one symtypetab (function info or data object) in\n+   one input dict.  */\n+\n+static int\n+ctf_link_deduplicating_one_symtypetab (ctf_dict_t *fp, ctf_dict_t *input,\n+\t\t\t\t       int cu_mapped, int functions)\n+{\n+  ctf_next_t *it = NULL;\n+  const char *name;\n+  ctf_id_t type;\n+  const char *in_file_name;\n+\n+  if (ctf_cuname (input) != NULL)\n+    in_file_name = ctf_cuname (input);\n+  else\n+    in_file_name = \"unnamed-CU\";\n+\n+  while ((type = ctf_symbol_next (input, &it, &name, functions)) != CTF_ERR)\n+    {\n+      ctf_id_t dst_type;\n+      ctf_dict_t *per_cu_out_fp;\n+      ctf_dict_t *insert_fp = fp;\n+      int sym;\n+\n+      /* Look in the parent first.  */\n+\n+      dst_type = ctf_type_mapping (input, type, &insert_fp);\n+      if (dst_type != 0)\n+\t{\n+\t  if (insert_fp == fp)\n+\t    {\n+\t      sym = check_sym (fp, name, dst_type, functions);\n+\n+\t      /* Already present: next symbol.  */\n+\t      if (sym == 0)\n+\t\tcontinue;\n+\t      /* Not present: add it.  */\n+\t      else if (sym > 0)\n+\t\t{\n+\t\t  if (ctf_add_funcobjt_sym (fp, functions,\n+\t\t\t\t\t    name, dst_type) < 0)\n+\t\t    return -1; \t\t\t/* errno is set for us.  */\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Can't add to the parent due to a name clash (most unlikely), or because\n+\t it references a type only present in the child.  Try adding to the\n+\t child, creating if need be.  If we can't do that, skip it.  Don't add\n+\t to a child if we're doing a CU-mapped link, since that has only one\n+\t output.  */\n+      if (cu_mapped)\n+\t{\n+\t  ctf_dprintf (\"Symbol %s in input file %s depends on a type %lx \"\n+\t\t       \"hidden due to conflicts: skipped.\\n\", name,\n+\t\t       in_file_name, type);\n+\t  continue;\n+\t}\n+\n+      if ((per_cu_out_fp = ctf_create_per_cu (fp, in_file_name,\n+\t\t\t\t\t      in_file_name)) == NULL)\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+\n+      /* If the type was not found, check for it in the child too.  */\n+      if (dst_type == 0)\n+\t{\n+\t  insert_fp = per_cu_out_fp;\n+\t  dst_type = ctf_type_mapping (input, type, &insert_fp);\n+\n+\t  if (dst_type == 0)\n+\t    {\n+\t      ctf_err_warn (fp, 1, 0,\n+\t\t\t    _(\"type %lx for symbol %s in input file %s \"\n+\t\t\t      \"not found: skipped\"), type, name, in_file_name);\n+\t      continue;\n+\t    }\n+\t}\n+\n+      sym = check_sym (per_cu_out_fp, name, dst_type, functions);\n+\n+      /* Already present: next symbol.  */\n+      if (sym == 0)\n+\tcontinue;\n+      /* Not present: add it.  */\n+      else if (sym > 0)\n+\t{\n+\t  if (ctf_add_funcobjt_sym (per_cu_out_fp, functions,\n+\t\t\t\t    name, dst_type) < 0)\n+\t    return -1;\t\t\t\t/* errno is set for us.  */\n+\t}\n+      else\n+\t{\n+\t  /* Perhaps this should be an assertion failure.  */\n+\t  ctf_err_warn (fp, 0, ECTF_DUPLICATE,\n+\t\t\t_(\"symbol %s in input file %s found conflicting \"\n+\t\t\t  \"even when trying in per-CU dict.\"), name,\n+\t\t\tin_file_name);\n+\t  return (ctf_set_errno (fp, ECTF_DUPLICATE));\n+\t}\n+    }\n+  if (ctf_errno (input) != ECTF_NEXT_END)\n+    {\n+      ctf_set_errno (fp, ctf_errno (input));\n+      ctf_err_warn (fp, 0, ctf_errno (input),\n+\t\t    functions ? _(\"iterating over function symbols\") :\n+\t\t    _(\"iterating over data symbols\"));\n+      return -1;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Do a deduplicating link of the function info and data objects\n+   in the inputs.  */\n+static int\n+ctf_link_deduplicating_syms (ctf_dict_t *fp, ctf_dict_t **inputs,\n+\t\t\t     size_t ninputs, int cu_mapped)\n+{\n+  size_t i;\n+\n+  for (i = 0; i < ninputs; i++)\n+    {\n+      if (ctf_link_deduplicating_one_symtypetab (fp, inputs[i],\n+\t\t\t\t\t\t cu_mapped, 0) < 0)\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+\n+      if (ctf_link_deduplicating_one_symtypetab (fp, inputs[i],\n+\t\t\t\t\t\t cu_mapped, 1) < 0)\n+\treturn -1;\t\t\t\t/* errno is set for us.  */\n+    }\n+\n+  return 0;\n+}\n+\n /* Do the per-CU part of a deduplicating link.  */\n static int\n ctf_link_deduplicating_per_cu (ctf_dict_t *fp)\n@@ -1305,6 +1464,11 @@ ctf_link_deduplicating_per_cu (ctf_dict_t *fp)\n \t  goto err_inputs_outputs;\n \t}\n \n+      /* For now, we omit symbol section linking for CU-mapped links, until it\n+\t is clear how to unify the symbol table across such links.  (Perhaps we\n+\t should emit an unconditionally indexed symtab, like the compiler\n+\t does.)  */\n+\n       if (ctf_link_deduplicating_close_inputs (fp, in, inputs, ninputs) < 0)\n \t{\n \t  free (inputs);\n@@ -1457,6 +1621,15 @@ ctf_link_deduplicating (ctf_dict_t *fp)\n       goto err;\n     }\n \n+  if (ctf_link_deduplicating_syms (fp, inputs, ninputs, 0) < 0)\n+    {\n+      ctf_err_warn (fp, 0, 0, _(\"deduplicating link symbol emission failed for \"\n+\t\t\t\t\"%s\"), ctf_link_input_name (fp));\n+      for (i = 1; i < noutputs; i++)\n+\tctf_dict_close (outputs[i]);\n+      goto err;\n+    }\n+\n   /* Now close all the inputs, including per-CU intermediates.  */\n \n   if (ctf_link_deduplicating_close_inputs (fp, NULL, inputs, ninputs) < 0)\n@@ -1591,19 +1764,162 @@ ctf_link_add_strtab (ctf_dict_t *fp, ctf_link_strtab_string_f *add_string,\n \terr = iter_arg.err;\n     }\n \n+  if (err)\n+    ctf_set_errno (fp, err);\n+\n   return -err;\n }\n \n-/* Not yet implemented.  */\n+/* Inform the ctf-link machinery of a new symbol in the target symbol table\n+   (which must be some symtab that is not usually stripped, and which\n+   is in agreement with ctf_bfdopen_ctfsect).  May be called either before or\n+   after ctf_link_add_strtab.  */\n int\n ctf_link_add_linker_symbol (ctf_dict_t *fp, ctf_link_sym_t *sym)\n {\n+  ctf_in_flight_dynsym_t *cid;\n+\n+  /* Cheat a little: if there is already an ENOMEM error code recorded against\n+     this dict, we shouldn't even try to add symbols because there will be no\n+     memory to do so: probably we failed to add some previous symbol.  This\n+     makes out-of-memory exits 'sticky' across calls to this function, so the\n+     caller doesn't need to worry about error conditions.  */\n+\n+  if (ctf_errno (fp) == ENOMEM)\n+    return -ENOMEM;\t\t\t\t/* errno is set for us.  */\n+\n+  if (ctf_symtab_skippable (sym))\n+    return 0;\n+\n+  if (sym->st_type != STT_OBJECT && sym->st_type != STT_FUNC)\n+    return 0;\n+\n+  /* Add the symbol to the in-flight list.  */\n+\n+  if ((cid = malloc (sizeof (ctf_in_flight_dynsym_t))) == NULL)\n+    goto oom;\n+\n+  cid->cid_sym = *sym;\n+  ctf_list_append (&fp->ctf_in_flight_dynsyms, cid);\n+\n   return 0;\n+\n+ oom:\n+  ctf_dynhash_destroy (fp->ctf_dynsyms);\n+  fp->ctf_dynsyms = NULL;\n+  ctf_set_errno (fp, ENOMEM);\n+  return -ENOMEM;\n }\n+\n+/* Impose an ordering on symbols.  The ordering takes effect immediately, but\n+   since the ordering info does not include type IDs, lookups may return nothing\n+   until such IDs are added by calls to ctf_add_*_sym.  Must be called after\n+   ctf_link_add_strtab and ctf_link_add_linker_symbol.  */\n int\n ctf_link_shuffle_syms (ctf_dict_t *fp)\n {\n+  ctf_in_flight_dynsym_t *did, *nid;\n+  ctf_next_t *i = NULL;\n+  int err = ENOMEM;\n+  void *name_, *sym_;\n+\n+  if (!fp->ctf_dynsyms)\n+    {\n+      fp->ctf_dynsyms = ctf_dynhash_create (ctf_hash_string,\n+\t\t\t\t\t    ctf_hash_eq_string,\n+\t\t\t\t\t    NULL, free);\n+      if (!fp->ctf_dynsyms)\n+\t{\n+\t  ctf_set_errno (fp, ENOMEM);\n+\t  return -ENOMEM;\n+\t}\n+    }\n+\n+  /* Add all the symbols, excluding only those we already know are prohibited\n+     from appearing in symtypetabs.  */\n+\n+  for (did = ctf_list_next (&fp->ctf_in_flight_dynsyms); did != NULL; did = nid)\n+    {\n+      ctf_link_sym_t *new_sym;\n+\n+      nid = ctf_list_next (did);\n+      ctf_list_delete (&fp->ctf_in_flight_dynsyms, did);\n+\n+      /* We might get a name or an external strtab offset.  The strtab offset is\n+\t guaranteed resolvable at this point, so turn it into a string.  */\n+\n+      if (did->cid_sym.st_name == NULL)\n+\t{\n+\t  uint32_t off = CTF_SET_STID (did->cid_sym.st_nameidx, CTF_STRTAB_1);\n+\n+\t  did->cid_sym.st_name = ctf_strraw (fp, off);\n+\t  did->cid_sym.st_nameidx_set = 0;\n+\t  if (!ctf_assert (fp, did->cid_sym.st_name != NULL))\n+\t    return -ECTF_INTERNAL;\t\t/* errno is set for us.  */\n+\t}\n+\n+      /* The symbol might have turned out to be nameless, so we have to recheck\n+\t for skippability here.  */\n+      if (!ctf_symtab_skippable (&did->cid_sym))\n+\t{\n+\t  ctf_dprintf (\"symbol name from linker: %s\\n\", did->cid_sym.st_name);\n+\n+\t  if ((new_sym = malloc (sizeof (ctf_link_sym_t))) == NULL)\n+\t    goto local_oom;\n+\n+\t  memcpy (new_sym, &did->cid_sym, sizeof (ctf_link_sym_t));\n+\t  if (ctf_dynhash_cinsert (fp->ctf_dynsyms, new_sym->st_name, new_sym) < 0)\n+\t    goto local_oom;\n+\n+\t  if (fp->ctf_dynsymmax < new_sym->st_symidx)\n+\t    fp->ctf_dynsymmax = new_sym->st_symidx;\n+\t}\n+\n+      free (did);\n+      continue;\n+\n+    local_oom:\n+      free (did);\n+      free (new_sym);\n+      goto err;\n+    }\n+\n+  /* Construct a mapping from shndx to the symbol info.  */\n+  free (fp->ctf_dynsymidx);\n+  if ((fp->ctf_dynsymidx = calloc (fp->ctf_dynsymmax + 1,\n+\t\t\t\t   sizeof (ctf_link_sym_t *))) == NULL)\n+    goto err;\n+\n+  while ((err = ctf_dynhash_next (fp->ctf_dynsyms, &i, &name_, &sym_)) == 0)\n+    {\n+      const char *name = (const char *) name;\n+      ctf_link_sym_t *symp = (ctf_link_sym_t *) sym_;\n+\n+      if (!ctf_assert (fp, symp->st_symidx <= fp->ctf_dynsymmax))\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  err = ctf_errno (fp);\n+\t  goto err;\n+\t}\n+      fp->ctf_dynsymidx[symp->st_symidx] = symp;\n+    }\n+  if (err != ECTF_NEXT_END)\n+    {\n+      ctf_err_warn (fp, 0, err, _(\"error iterating over shuffled symbols\"));\n+      goto err;\n+    }\n   return 0;\n+\n+ err:\n+  /* Leave the in-flight symbols around: they'll be freed at\n+     dict close time regardless.  */\n+  ctf_dynhash_destroy (fp->ctf_dynsyms);\n+  fp->ctf_dynsyms = NULL;\n+  free (fp->ctf_dynsymidx);\n+  fp->ctf_dynsymidx = NULL;\n+  fp->ctf_dynsymmax = 0;\n+  ctf_set_errno (fp, err);\n+  return -err;\n }\n \n typedef struct ctf_name_list_accum_cb_arg"
    },
    {
      "sha": "a862b407bcb60413d4795c205a31ac1bfd303b4a",
      "filename": "libctf/ctf-lookup.c",
      "status": "modified",
      "additions": 440,
      "deletions": 132,
      "changes": 572,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -20,6 +20,7 @@\n #include <ctf-impl.h>\n #include <elf.h>\n #include <string.h>\n+#include <assert.h>\n \n /* Compare the given input string and length against a table of known C storage\n    qualifier keywords.  We just ignore these in ctf_lookup_by_name, below.  To\n@@ -192,21 +193,66 @@ ctf_lookup_by_name (ctf_dict_t *fp, const char *name)\n   return CTF_ERR;\n }\n \n-typedef struct ctf_lookup_var_key\n+/* Return the pointer to the internal CTF type data corresponding to the\n+   given type ID.  If the ID is invalid, the function returns NULL.\n+   This function is not exported outside of the library.  */\n+\n+const ctf_type_t *\n+ctf_lookup_by_id (ctf_dict_t **fpp, ctf_id_t type)\n {\n-  ctf_dict_t *clvk_fp;\n-  const char *clvk_name;\n-} ctf_lookup_var_key_t;\n+  ctf_dict_t *fp = *fpp;\t/* Caller passes in starting CTF dict.  */\n+  ctf_id_t idx;\n+\n+  if ((fp = ctf_get_dict (fp, type)) == NULL)\n+    {\n+      (void) ctf_set_errno (*fpp, ECTF_NOPARENT);\n+      return NULL;\n+    }\n+\n+  /* If this dict is writable, check for a dynamic type.  */\n+\n+  if (fp->ctf_flags & LCTF_RDWR)\n+    {\n+      ctf_dtdef_t *dtd;\n+\n+      if ((dtd = ctf_dynamic_type (fp, type)) != NULL)\n+\t{\n+\t  *fpp = fp;\n+\t  return &dtd->dtd_data;\n+\t}\n+      (void) ctf_set_errno (*fpp, ECTF_BADID);\n+      return NULL;\n+    }\n+\n+  /* Check for a type in the static portion.  */\n+\n+  idx = LCTF_TYPE_TO_INDEX (fp, type);\n+  if (idx > 0 && (unsigned long) idx <= fp->ctf_typemax)\n+    {\n+      *fpp = fp;\t\t/* Function returns ending CTF dict.  */\n+      return (LCTF_INDEX_TO_TYPEPTR (fp, idx));\n+    }\n+\n+  (void) ctf_set_errno (*fpp, ECTF_BADID);\n+  return NULL;\n+}\n+\n+typedef struct ctf_lookup_idx_key\n+{\n+  ctf_dict_t *clik_fp;\n+  const char *clik_name;\n+  uint32_t *clik_names;\n+} ctf_lookup_idx_key_t;\n \n /* A bsearch function for variable names.  */\n \n static int\n-ctf_lookup_var (const void *key_, const void *memb_)\n+ctf_lookup_var (const void *key_, const void *lookup_)\n {\n-  const ctf_lookup_var_key_t *key = key_;\n-  const ctf_varent_t *memb = memb_;\n+  const ctf_lookup_idx_key_t *key = key_;\n+  const ctf_varent_t *lookup = lookup_;\n \n-  return (strcmp (key->clvk_name, ctf_strptr (key->clvk_fp, memb->ctv_name)));\n+  return (strcmp (key->clik_name, ctf_strptr (key->clik_fp, lookup->ctv_name)));\n }\n \n /* Given a variable name, return the type of the variable with that name.  */\n@@ -215,7 +261,7 @@ ctf_id_t\n ctf_lookup_variable (ctf_dict_t *fp, const char *name)\n {\n   ctf_varent_t *ent;\n-  ctf_lookup_var_key_t key = { fp, name };\n+  ctf_lookup_idx_key_t key = { fp, name, NULL };\n \n   /* This array is sorted, so we can bsearch for it.  */\n \n@@ -233,211 +279,473 @@ ctf_lookup_variable (ctf_dict_t *fp, const char *name)\n   return ent->ctv_type;\n }\n \n-/* Given a symbol table index, return the name of that symbol from the secondary\n-   string table, or the null string (never NULL).  */\n+typedef struct ctf_symidx_sort_arg_cb\n+{\n+  ctf_dict_t *fp;\n+  uint32_t *names;\n+} ctf_symidx_sort_arg_cb_t;\n+\n+static int\n+sort_symidx_by_name (const void *one_, const void *two_, void *arg_)\n+{\n+  const uint32_t *one = one_;\n+  const uint32_t *two = two_;\n+  ctf_symidx_sort_arg_cb_t *arg = arg_;\n+\n+  return (strcmp (ctf_strptr (arg->fp, arg->names[*one]),\n+\t\t  ctf_strptr (arg->fp, arg->names[*two])));\n+}\n+\n+/* Sort a symbol index section by name.  Takes a 1:1 mapping of names to the\n+   corresponding symbol table.  Returns a lexicographically sorted array of idx\n+   indexes (and thus, of indexes into the corresponding func info / data object\n+   section).  */\n+\n+static uint32_t *\n+ctf_symidx_sort (ctf_dict_t *fp, uint32_t *idx, size_t *nidx,\n+\t\t\t size_t len)\n+{\n+  uint32_t *sorted;\n+  size_t i;\n+\n+  if ((sorted = malloc (len)) == NULL)\n+    {\n+      ctf_set_errno (fp, ENOMEM);\n+      return NULL;\n+    }\n+\n+  *nidx = len / sizeof (uint32_t);\n+  for (i = 0; i < *nidx; i++)\n+    sorted[i] = i;\n+\n+  if (!(fp->ctf_header->cth_flags & CTF_F_IDXSORTED))\n+    {\n+      ctf_symidx_sort_arg_cb_t arg = { fp, idx };\n+      ctf_dprintf (\"Index section unsorted: sorting.\");\n+      ctf_qsort_r (sorted, *nidx, sizeof (uint32_t), sort_symidx_by_name, &arg);\n+      fp->ctf_header->cth_flags |= CTF_F_IDXSORTED;\n+    }\n+\n+  return sorted;\n+}\n+\n+/* Given a symbol index, return the name of that symbol from the table provided\n+   by ctf_link_shuffle_syms, or failing that from the secondary string table, or\n+   the null string.  */\n const char *\n ctf_lookup_symbol_name (ctf_dict_t *fp, unsigned long symidx)\n {\n   const ctf_sect_t *sp = &fp->ctf_symtab;\n-  Elf64_Sym sym, *gsp;\n+  ctf_link_sym_t sym;\n+  int err;\n \n-  if (sp->cts_data == NULL)\n+  if (fp->ctf_dynsymidx)\n     {\n-      ctf_set_errno (fp, ECTF_NOSYMTAB);\n-      return _CTF_NULLSTR;\n+      err = EINVAL;\n+      if (symidx > fp->ctf_dynsymmax)\n+\tgoto try_parent;\n+\n+      ctf_link_sym_t *symp = fp->ctf_dynsymidx[symidx];\n+\n+      if (!symp)\n+\tgoto try_parent;\n+\n+      return symp->st_name;\n     }\n \n+  err = ECTF_NOSYMTAB;\n+  if (sp->cts_data == NULL)\n+    goto try_parent;\n+\n   if (symidx >= fp->ctf_nsyms)\n+    goto try_parent;\n+\n+  switch (sp->cts_entsize)\n     {\n-      ctf_set_errno (fp, EINVAL);\n+    case sizeof (Elf64_Sym):\n+      {\n+\tconst Elf64_Sym *symp = (Elf64_Sym *) sp->cts_data + symidx;\n+\tctf_elf64_to_link_sym (fp, &sym, symp, symidx);\n+      }\n+      break;\n+    case sizeof (Elf32_Sym):\n+      {\n+\tconst Elf32_Sym *symp = (Elf32_Sym *) sp->cts_data + symidx;\n+\tctf_elf32_to_link_sym (fp, &sym, symp, symidx);\n+      }\n+      break;\n+    default:\n+      ctf_set_errno (fp, ECTF_SYMTAB);\n       return _CTF_NULLSTR;\n     }\n \n-  if (sp->cts_entsize == sizeof (Elf32_Sym))\n-    {\n-      const Elf32_Sym *symp = (Elf32_Sym *) sp->cts_data + symidx;\n-      gsp = ctf_sym_to_elf64 (symp, &sym);\n-    }\n-  else\n-      gsp = (Elf64_Sym *) sp->cts_data + symidx;\n+  assert (!sym.st_nameidx_set);\n \n-  if (gsp->st_name < fp->ctf_str[CTF_STRTAB_1].cts_len)\n-    return (const char *) fp->ctf_str[CTF_STRTAB_1].cts_strs + gsp->st_name;\n+  return sym.st_name;\n \n-  return _CTF_NULLSTR;\n+ try_parent:\n+  if (fp->ctf_parent)\n+    return ctf_lookup_symbol_name (fp->ctf_parent, symidx);\n+  else\n+    {\n+      ctf_set_errno (fp, err);\n+      return _CTF_NULLSTR;\n+    }\n }\n \n-/* Given a symbol table index, return the type of the data object described\n-   by the corresponding entry in the symbol table.  */\n+/* Iterate over all symbols with types: if FUNC, function symbols, otherwise,\n+   data symbols.  The name argument is not optional.  The return order is\n+   arbitrary, though is likely to be in symbol index or name order.  You can\n+   change the value of 'functions' in the middle of iteration over non-dynamic\n+   dicts, but doing so on dynamic dicts will fail.  (This is probably not very\n+   useful, but there is no reason to prohibit it.)  */\n \n ctf_id_t\n-ctf_lookup_by_symbol (ctf_dict_t *fp, unsigned long symidx)\n+ctf_symbol_next (ctf_dict_t *fp, ctf_next_t **it, const char **name,\n+\t\t int functions)\n {\n-  const ctf_sect_t *sp = &fp->ctf_symtab;\n-  ctf_id_t type;\n+  ctf_id_t sym;\n+  ctf_next_t *i = *it;\n+  int err;\n \n-  if (sp->cts_data == NULL)\n-    return (ctf_set_errno (fp, ECTF_NOSYMTAB));\n+  if (!i)\n+    {\n+      if ((i = ctf_next_create ()) == NULL)\n+\treturn ctf_set_errno (fp, ENOMEM);\n \n-  if (symidx >= fp->ctf_nsyms)\n-    return (ctf_set_errno (fp, EINVAL));\n+      i->cu.ctn_fp = fp;\n+      i->ctn_iter_fun = (void (*) (void)) ctf_symbol_next;\n+      i->ctn_n = 0;\n+      *it = i;\n+    }\n+\n+  if ((void (*) (void)) ctf_symbol_next != i->ctn_iter_fun)\n+    return (ctf_set_errno (fp, ECTF_NEXT_WRONGFUN));\n \n-  if (sp->cts_entsize == sizeof (Elf32_Sym))\n+  if (fp != i->cu.ctn_fp)\n+    return (ctf_set_errno (fp, ECTF_NEXT_WRONGFP));\n+\n+  /* We intentionally use raw access, not ctf_lookup_by_symbol, to avoid\n+     incurring additional sorting cost for unsorted symtypetabs coming from the\n+     compiler, to allow ctf_symbol_next to work in the absence of a symtab, and\n+     finally because it's easier to work out what the name of each symbol is if\n+     we do that.  */\n+\n+  if (fp->ctf_flags & LCTF_RDWR)\n     {\n-      const Elf32_Sym *symp = (Elf32_Sym *) sp->cts_data + symidx;\n-      if (ELF32_ST_TYPE (symp->st_info) != STT_OBJECT)\n-\treturn (ctf_set_errno (fp, ECTF_NOTDATA));\n+      ctf_dynhash_t *dynh = functions ? fp->ctf_funchash : fp->ctf_objthash;\n+      void *dyn_name = NULL, *dyn_value = NULL;\n+\n+      if (!dynh)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  return (ctf_set_errno (fp, ECTF_NEXT_END));\n+\t}\n+\n+      err = ctf_dynhash_next (dynh, &i->u.ctn_next, &dyn_name, &dyn_value);\n+      /* This covers errors and also end-of-iteration.  */\n+      if (err != 0)\n+\t{\n+\t  ctf_next_destroy (i);\n+\t  *it = NULL;\n+\t  return ctf_set_errno (fp, err);\n+\t}\n+\n+      *name = dyn_name;\n+      sym = (ctf_id_t) (uintptr_t) dyn_value;\n     }\n-  else\n+  else if ((!functions && fp->ctf_objtidx_names) ||\n+\t   (functions && fp->ctf_funcidx_names))\n     {\n-      const Elf64_Sym *symp = (Elf64_Sym *) sp->cts_data + symidx;\n-      if (ELF64_ST_TYPE (symp->st_info) != STT_OBJECT)\n-\treturn (ctf_set_errno (fp, ECTF_NOTDATA));\n+      ctf_header_t *hp = fp->ctf_header;\n+      uint32_t *idx = functions ? fp->ctf_funcidx_names : fp->ctf_objtidx_names;\n+      uint32_t *tab;\n+      size_t len;\n+\n+      if (functions)\n+\t{\n+\t  len = (hp->cth_varoff - hp->cth_funcidxoff) / sizeof (uint32_t);\n+\t  tab = (uint32_t *) (fp->ctf_buf + hp->cth_funcoff);\n+\t}\n+      else\n+\t{\n+\t  len = (hp->cth_funcidxoff - hp->cth_objtidxoff) / sizeof (uint32_t);\n+\t  tab = (uint32_t *) (fp->ctf_buf + hp->cth_objtoff);\n+\t}\n+\n+      do\n+\t{\n+\t  if (i->ctn_n >= len)\n+\t    goto end;\n+\n+\t  *name = ctf_strptr (fp, idx[i->ctn_n]);\n+\t  sym = tab[i->ctn_n++];\n+\t} while (sym == -1u || sym == 0);\n     }\n+  else\n+    {\n+      /* Skip over pads in ctf_xslate, padding for typeless symbols in the\n+\t symtypetab itself, and symbols in the wrong table.  */\n+      for (; i->ctn_n < fp->ctf_nsyms; i->ctn_n++)\n+\t{\n+\t  ctf_header_t *hp = fp->ctf_header;\n \n-  if (fp->ctf_sxlate[symidx] == -1u)\n-    return (ctf_set_errno (fp, ECTF_NOTYPEDAT));\n+\t  if (fp->ctf_sxlate[i->ctn_n] == -1u)\n+\t    continue;\n \n-  type = *(uint32_t *) ((uintptr_t) fp->ctf_buf + fp->ctf_sxlate[symidx]);\n-  if (type == 0)\n-    return (ctf_set_errno (fp, ECTF_NOTYPEDAT));\n+\t  sym = *(uint32_t *) ((uintptr_t) fp->ctf_buf + fp->ctf_sxlate[i->ctn_n]);\n \n-  return type;\n+\t  if (sym == 0)\n+\t    continue;\n+\n+\t  if (functions)\n+\t    {\n+\t      if (fp->ctf_sxlate[i->ctn_n] >= hp->cth_funcoff\n+\t\t  && fp->ctf_sxlate[i->ctn_n] < hp->cth_objtidxoff)\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (fp->ctf_sxlate[i->ctn_n] >= hp->cth_objtoff\n+\t\t  && fp->ctf_sxlate[i->ctn_n] < hp->cth_funcoff)\n+\t\tbreak;\n+\t    }\n+\t}\n+\n+      if (i->ctn_n >= fp->ctf_nsyms)\n+\tgoto end;\n+\n+      *name = ctf_lookup_symbol_name (fp, i->ctn_n++);\n+    }\n+\n+  return sym;\n+\n+ end:\n+  ctf_next_destroy (i);\n+  *it = NULL;\n+  return (ctf_set_errno (fp, ECTF_NEXT_END));\n }\n \n-/* Return the native dict of a given type: if called on a child and the\n-   type is in the parent, return the parent.  Needed if you plan to access\n-   the type directly, without using the API.  */\n-ctf_dict_t *\n-ctf_get_dict (ctf_dict_t *fp, ctf_id_t type)\n+/* A bsearch function for function and object index names.  */\n+\n+static int\n+ctf_lookup_idx_name (const void *key_, const void *idx_)\n {\n-    if ((fp->ctf_flags & LCTF_CHILD) && LCTF_TYPE_ISPARENT (fp, type))\n-      return fp->ctf_parent;\n+  const ctf_lookup_idx_key_t *key = key_;\n+  const uint32_t *idx = idx_;\n \n-    return fp;\n+  return (strcmp (key->clik_name, ctf_strptr (key->clik_fp, key->clik_names[*idx])));\n }\n \n-/* Return the pointer to the internal CTF type data corresponding to the\n-   given type ID.  If the ID is invalid, the function returns NULL.\n-   This function is not exported outside of the library.  */\n+/* Given a symbol number, look up that symbol in the function or object\n+   index table (which must exist).  Return 0 if not found there (or pad).  */\n \n-const ctf_type_t *\n-ctf_lookup_by_id (ctf_dict_t **fpp, ctf_id_t type)\n+static ctf_id_t\n+ctf_try_lookup_indexed (ctf_dict_t *fp, unsigned long symidx, int is_function)\n {\n-  ctf_dict_t *fp = *fpp;\t/* Caller passes in starting CTF dict.  */\n-  ctf_id_t idx;\n+  const char *symname = ctf_lookup_symbol_name (fp, symidx);\n+  struct ctf_header *hp = fp->ctf_header;\n+  uint32_t *symtypetab;\n+  uint32_t *names;\n+  uint32_t *sxlate;\n+  size_t nidx;\n \n-  if ((fp = ctf_get_dict (fp, type)) == NULL)\n-    {\n-      (void) ctf_set_errno (*fpp, ECTF_NOPARENT);\n-      return NULL;\n-    }\n+  ctf_dprintf (\"Looking up type of object with symtab idx %lx (%s) in \"\n+\t       \"indexed symtypetab\\n\", symidx, symname);\n \n-  /* If this dict is writable, check for a dynamic type.  */\n+  if (symname[0] == '\\0')\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n \n-  if (fp->ctf_flags & LCTF_RDWR)\n+  if (is_function)\n     {\n-      ctf_dtdef_t *dtd;\n-\n-      if ((dtd = ctf_dynamic_type (fp, type)) != NULL)\n+      if (!fp->ctf_funcidx_sxlate)\n \t{\n-\t  *fpp = fp;\n-\t  return &dtd->dtd_data;\n+\t  if ((fp->ctf_funcidx_sxlate\n+\t       = ctf_symidx_sort (fp, (uint32_t *)\n+\t\t\t\t  (fp->ctf_buf + hp->cth_funcidxoff),\n+\t\t\t\t  &fp->ctf_nfuncidx,\n+\t\t\t\t  hp->cth_varoff - hp->cth_funcidxoff))\n+\t      == NULL)\n+\t    {\n+\t      ctf_err_warn (fp, 0, 0, _(\"cannot sort function symidx\"));\n+\t      return -1;\t\t\t\t/* errno is set for us.  */\n+\t    }\n \t}\n-      (void) ctf_set_errno (*fpp, ECTF_BADID);\n-      return NULL;\n+      symtypetab = (uint32_t *) (fp->ctf_buf + hp->cth_funcoff);\n+      sxlate = fp->ctf_funcidx_sxlate;\n+      names = fp->ctf_funcidx_names;\n+      nidx = fp->ctf_nfuncidx;\n     }\n+  else\n+    {\n+      if (!fp->ctf_objtidx_sxlate)\n+\t{\n+\t  if ((fp->ctf_objtidx_sxlate\n+\t       = ctf_symidx_sort (fp, (uint32_t *)\n+\t\t\t\t  (fp->ctf_buf + hp->cth_objtidxoff),\n+\t\t\t\t  &fp->ctf_nobjtidx,\n+\t\t\t\t  hp->cth_funcidxoff - hp->cth_objtidxoff))\n+\t      == NULL)\n+\t    {\n+\t      ctf_err_warn (fp, 0, 0, _(\"cannot sort object symidx\"));\n+\t      return -1;\t\t\t\t/* errno is set for us. */\n+\t    }\n+\t}\n \n-  /* Check for a type in the static portion.  */\n+      symtypetab = (uint32_t *) (fp->ctf_buf + hp->cth_objtoff);\n+      sxlate = fp->ctf_objtidx_sxlate;\n+      names = fp->ctf_objtidx_names;\n+      nidx = fp->ctf_nobjtidx;\n+    }\n \n-  idx = LCTF_TYPE_TO_INDEX (fp, type);\n-  if (idx > 0 && (unsigned long) idx <= fp->ctf_typemax)\n+  ctf_lookup_idx_key_t key = { fp, symname, names };\n+  uint32_t *idx;\n+\n+  idx = bsearch (&key, sxlate, nidx, sizeof (uint32_t), ctf_lookup_idx_name);\n+\n+  if (!idx)\n     {\n-      *fpp = fp;\t\t/* Function returns ending CTF dict.  */\n-      return (LCTF_INDEX_TO_TYPEPTR (fp, idx));\n+      ctf_dprintf (\"%s not found in idx\\n\", symname);\n+      return 0;\n     }\n \n-  (void) ctf_set_errno (*fpp, ECTF_BADID);\n-  return NULL;\n+  /* Should be impossible, but be paranoid.  */\n+  if ((idx - sxlate) > (ptrdiff_t) nidx)\n+    return (ctf_set_errno (fp, ECTF_CORRUPT));\n+\n+  ctf_dprintf (\"Symbol %lx (%s) is of type %x\\n\", symidx, symname,\n+\t       symtypetab[*idx]);\n+  return symtypetab[*idx];\n }\n \n-/* Given a symbol table index, return the info for the function described\n-   by the corresponding entry in the symbol table.  */\n+/* Given a symbol table index, return the type of the function or data object\n+   described by the corresponding entry in the symbol table.  We can only return\n+   symbols in read-only dicts and in dicts for which ctf_link_shuffle_syms has\n+   been called to assign symbol indexes to symbol names.  */\n \n-int\n-ctf_func_info (ctf_dict_t *fp, unsigned long symidx, ctf_funcinfo_t *fip)\n+ctf_id_t\n+ctf_lookup_by_symbol (ctf_dict_t *fp, unsigned long symidx)\n {\n   const ctf_sect_t *sp = &fp->ctf_symtab;\n-  const uint32_t *dp;\n-  uint32_t info, kind, n;\n+  ctf_id_t type = 0;\n+  int err = 0;\n+\n+  /* Shuffled dynsymidx present?  Use that.  */\n+  if (fp->ctf_dynsymidx)\n+    {\n+      const ctf_link_sym_t *sym;\n+\n+      ctf_dprintf (\"Looking up type of object with symtab idx %lx in \"\n+\t\t   \"writable dict symtypetab\\n\", symidx);\n+\n+      /* The dict must be dynamic.  */\n+      if (!ctf_assert (fp, fp->ctf_flags & LCTF_RDWR))\n+\treturn CTF_ERR;\n+\n+      err = EINVAL;\n+      if (symidx > fp->ctf_dynsymmax)\n+\tgoto try_parent;\n+\n+      sym = fp->ctf_dynsymidx[symidx];\n+      err = ECTF_NOTYPEDAT;\n+      if (!sym || (sym->st_shndx != STT_OBJECT && sym->st_shndx != STT_FUNC))\n+\tgoto try_parent;\n+\n+      if (!ctf_assert (fp, !sym->st_nameidx_set))\n+\treturn CTF_ERR;\n+\n+      if (fp->ctf_objthash == NULL\n+\t  || ((type = (ctf_id_t) (uintptr_t)\n+\t       ctf_dynhash_lookup (fp->ctf_objthash, sym->st_name)) == 0))\n+\t{\n+\t  if (fp->ctf_funchash == NULL\n+\t      || ((type = (ctf_id_t) (uintptr_t)\n+\t\t   ctf_dynhash_lookup (fp->ctf_funchash, sym->st_name)) == 0))\n+\t    goto try_parent;\n+\t}\n+\n+      return type;\n+    }\n \n+  err = ECTF_NOSYMTAB;\n   if (sp->cts_data == NULL)\n-    return (ctf_set_errno (fp, ECTF_NOSYMTAB));\n+    goto try_parent;\n \n+  /* This covers both out-of-range lookups and a dynamic dict which hasn't been\n+     shuffled yet.  */\n+  err = EINVAL;\n   if (symidx >= fp->ctf_nsyms)\n-    return (ctf_set_errno (fp, EINVAL));\n+    goto try_parent;\n \n-  if (sp->cts_entsize == sizeof (Elf32_Sym))\n+  if (fp->ctf_objtidx_names)\n     {\n-      const Elf32_Sym *symp = (Elf32_Sym *) sp->cts_data + symidx;\n-      if (ELF32_ST_TYPE (symp->st_info) != STT_FUNC)\n-\treturn (ctf_set_errno (fp, ECTF_NOTFUNC));\n+      if ((type = ctf_try_lookup_indexed (fp, symidx, 0)) == CTF_ERR)\n+\treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n     }\n-  else\n+  if (type == 0 && fp->ctf_funcidx_names)\n     {\n-      const Elf64_Sym *symp = (Elf64_Sym *) sp->cts_data + symidx;\n-      if (ELF64_ST_TYPE (symp->st_info) != STT_FUNC)\n-\treturn (ctf_set_errno (fp, ECTF_NOTFUNC));\n+      if ((type = ctf_try_lookup_indexed (fp, symidx, 1)) == CTF_ERR)\n+\treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n     }\n+  if (type != 0)\n+    return type;\n+\n+  err = ECTF_NOTYPEDAT;\n+  if (fp->ctf_objtidx_names && fp->ctf_funcidx_names)\n+    goto try_parent;\n+\n+  /* Table must be nonindexed.  */\n+\n+  ctf_dprintf (\"Looking up object type %lx in 1:1 dict symtypetab\\n\", symidx);\n \n   if (fp->ctf_sxlate[symidx] == -1u)\n-    return (ctf_set_errno (fp, ECTF_NOFUNCDAT));\n+    goto try_parent;\n+\n+  type = *(uint32_t *) ((uintptr_t) fp->ctf_buf + fp->ctf_sxlate[symidx]);\n \n-  dp = (uint32_t *) ((uintptr_t) fp->ctf_buf + fp->ctf_sxlate[symidx]);\n+  if (type == 0)\n+    goto try_parent;\n \n-  info = *dp++;\n-  kind = LCTF_INFO_KIND (fp, info);\n-  n = LCTF_INFO_VLEN (fp, info);\n+  return type;\n+ try_parent:\n+  if (fp->ctf_parent)\n+    return ctf_lookup_by_symbol (fp->ctf_parent, symidx);\n+  else\n+    return (ctf_set_errno (fp, err));\n+}\n \n-  if (kind == CTF_K_UNKNOWN && n == 0)\n-    return (ctf_set_errno (fp, ECTF_NOFUNCDAT));\n+/* Given a symbol table index, return the info for the function described\n+   by the corresponding entry in the symbol table, which may be a function\n+   symbol or may be a data symbol that happens to be a function pointer.  */\n \n-  if (kind != CTF_K_FUNCTION)\n-    return (ctf_set_errno (fp, ECTF_CORRUPT));\n+int\n+ctf_func_info (ctf_dict_t *fp, unsigned long symidx, ctf_funcinfo_t *fip)\n+{\n+  ctf_id_t type;\n \n-  fip->ctc_return = *dp++;\n-  fip->ctc_argc = n;\n-  fip->ctc_flags = 0;\n+  if ((type = ctf_lookup_by_symbol (fp, symidx)) == CTF_ERR)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n \n-  if (n != 0 && dp[n - 1] == 0)\n-    {\n-      fip->ctc_flags |= CTF_FUNC_VARARG;\n-      fip->ctc_argc--;\n-    }\n+  if (ctf_type_kind (fp, type) != CTF_K_FUNCTION)\n+    return (ctf_set_errno (fp, ECTF_NOTFUNC));\n \n-  return 0;\n+  return ctf_func_type_info (fp, type, fip);\n }\n \n /* Given a symbol table index, return the arguments for the function described\n    by the corresponding entry in the symbol table.  */\n \n int\n ctf_func_args (ctf_dict_t *fp, unsigned long symidx, uint32_t argc,\n-\t       ctf_id_t * argv)\n+\t       ctf_id_t *argv)\n {\n-  const uint32_t *dp;\n-  ctf_funcinfo_t f;\n-\n-  if (ctf_func_info (fp, symidx, &f) < 0)\n-    return -1;\t\t\t/* errno is set for us.  */\n-\n-  /* The argument data is two uint32_t's past the translation table\n-     offset: one for the function info, and one for the return type. */\n+  ctf_id_t type;\n \n-  dp = (uint32_t *) ((uintptr_t) fp->ctf_buf + fp->ctf_sxlate[symidx]) + 2;\n+  if ((type = ctf_lookup_by_symbol (fp, symidx)) == CTF_ERR)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n \n-  for (argc = MIN (argc, f.ctc_argc); argc != 0; argc--)\n-    *argv++ = *dp++;\n+  if (ctf_type_kind (fp, type) != CTF_K_FUNCTION)\n+    return (ctf_set_errno (fp, ECTF_NOTFUNC));\n \n-  return 0;\n+  return ctf_func_type_args (fp, type, argc, argv);\n }"
    },
    {
      "sha": "3281c678ac4664bbc3847c1f2ae2b8e07c312b3e",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 139,
      "deletions": 61,
      "changes": 200,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -27,8 +27,6 @@\n #include <bfd.h>\n #include <zlib.h>\n \n-#include \"elf-bfd.h\"\n-\n static const ctf_dmodel_t _libctf_models[] = {\n   {\"ILP32\", CTF_MODEL_ILP32, 4, 1, 2, 4, 4},\n   {\"LP64\", CTF_MODEL_LP64, 8, 1, 2, 4, 8},\n@@ -220,55 +218,88 @@ static const ctf_dictops_t ctf_dictops[] = {\n   {get_kind_v2, get_root_v2, get_vlen_v2, get_ctt_size_v2, get_vbytes_v2},\n };\n \n-/* Initialize the symtab translation table by filling each entry with the\n-  offset of the CTF type or function data corresponding to each STT_FUNC or\n-  STT_OBJECT entry in the symbol table.  */\n+/* Initialize the symtab translation table as appropriate for its indexing\n+   state.  For unindexed symtypetabs, fill each entry with the offset of the CTF\n+   type or function data corresponding to each STT_FUNC or STT_OBJECT entry in\n+   the symbol table.  For indexed symtypetabs, do nothing: the needed\n+   initialization for indexed lookups may be quite expensive, so it is done only\n+   as needed, when lookups happen.  (In particular, the majority of indexed\n+   symtypetabs come from the compiler, and all the linker does is iteration over\n+   all entries, which doesn't need this initialization.)\n+\n+   The SP symbol table section may be NULL if there is no symtab.  */\n \n static int\n-init_symtab (ctf_dict_t *fp, const ctf_header_t *hp,\n-\t     const ctf_sect_t *sp, const ctf_sect_t *strp)\n+init_symtab (ctf_dict_t *fp, const ctf_header_t *hp, const ctf_sect_t *sp)\n {\n-  const unsigned char *symp = sp->cts_data;\n+  const unsigned char *symp;\n+  int skip_func_info = 0;\n+  int i;\n   uint32_t *xp = fp->ctf_sxlate;\n   uint32_t *xend = xp + fp->ctf_nsyms;\n \n   uint32_t objtoff = hp->cth_objtoff;\n   uint32_t funcoff = hp->cth_funcoff;\n \n-  uint32_t info, vlen;\n-  Elf64_Sym sym, *gsp;\n-  const char *name;\n-\n-  /* The CTF data object and function type sections are ordered to match\n-     the relative order of the respective symbol types in the symtab.\n-     If no type information is available for a symbol table entry, a\n-     pad is inserted in the CTF section.  As a further optimization,\n-     anonymous or undefined symbols are omitted from the CTF data.  */\n-\n-  for (; xp < xend; xp++, symp += sp->cts_entsize)\n+  /* If the CTF_F_NEWFUNCINFO flag is not set, pretend the func info section\n+     is empty: this compiler is too old to emit a function info section we\n+     understand.  */\n+\n+  if (!(hp->cth_flags & CTF_F_NEWFUNCINFO))\n+    skip_func_info = 1;\n+\n+  if (hp->cth_objtidxoff < hp->cth_funcidxoff)\n+    fp->ctf_objtidx_names = (uint32_t *) (fp->ctf_buf + hp->cth_objtidxoff);\n+  if (hp->cth_funcidxoff < hp->cth_varoff && !skip_func_info)\n+    fp->ctf_funcidx_names = (uint32_t *) (fp->ctf_buf + hp->cth_funcidxoff);\n+\n+  /* Don't bother doing the rest if everything is indexed, or if we don't have a\n+     symbol table: we will never use it.  */\n+  if ((fp->ctf_objtidx_names && fp->ctf_funcidx_names) || !sp || !sp->cts_data)\n+    return 0;\n+\n+  /* The CTF data object and function type sections are ordered to match the\n+     relative order of the respective symbol types in the symtab, unless there\n+     is an index section, in which case the order is arbitrary and the index\n+     gives the mapping.  If no type information is available for a symbol table\n+     entry, a pad is inserted in the CTF section.  As a further optimization,\n+     anonymous or undefined symbols are omitted from the CTF data.  If an\n+     index is available for function symbols but not object symbols, or vice\n+     versa, we populate the xslate table for the unindexed symbols only.  */\n+\n+  for (i = 0, symp = sp->cts_data; xp < xend; xp++, symp += sp->cts_entsize,\n+\t i++)\n     {\n-      if (sp->cts_entsize == sizeof (Elf32_Sym))\n-\tgsp = ctf_sym_to_elf64 ((Elf32_Sym *) (uintptr_t) symp, &sym);\n-      else\n-\tgsp = (Elf64_Sym *) (uintptr_t) symp;\n+      ctf_link_sym_t sym;\n \n-      if (gsp->st_name < strp->cts_size)\n-\tname = (const char *) strp->cts_data + gsp->st_name;\n-      else\n-\tname = _CTF_NULLSTR;\n+      switch (sp->cts_entsize)\n+\t{\n+\tcase sizeof (Elf64_Sym):\n+\t  {\n+\t    const Elf64_Sym *symp64 = (Elf64_Sym *) (uintptr_t) symp;\n+\t    ctf_elf64_to_link_sym (fp, &sym, symp64, i);\n+\t  }\n+\t  break;\n+\tcase sizeof (Elf32_Sym):\n+\t  {\n+\t    const Elf32_Sym *symp32 = (Elf32_Sym *) (uintptr_t) symp;\n+\t    ctf_elf32_to_link_sym (fp, &sym, symp32, i);\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  return ECTF_SYMTAB;\n+\t}\n \n-      if (gsp->st_name == 0 || gsp->st_shndx == SHN_UNDEF\n-\t  || strcmp (name, \"_START_\") == 0 || strcmp (name, \"_END_\") == 0)\n+      if (ctf_symtab_skippable (&sym))\n \t{\n \t  *xp = -1u;\n \t  continue;\n \t}\n \n-      switch (ELF64_ST_TYPE (gsp->st_info))\n+      switch (sym.st_type)\n \t{\n \tcase STT_OBJECT:\n-\t  if (objtoff >= hp->cth_funcoff\n-\t      || (gsp->st_shndx == SHN_EXTABS && gsp->st_value == 0))\n+\t  if (fp->ctf_objtidx_names || objtoff >= hp->cth_funcoff)\n \t    {\n \t      *xp = -1u;\n \t      break;\n@@ -279,25 +310,15 @@ init_symtab (ctf_dict_t *fp, const ctf_header_t *hp,\n \t  break;\n \n \tcase STT_FUNC:\n-\t  if (funcoff >= hp->cth_objtidxoff)\n+\t  if (fp->ctf_funcidx_names || funcoff >= hp->cth_objtidxoff\n+\t      || skip_func_info)\n \t    {\n \t      *xp = -1u;\n \t      break;\n \t    }\n \n \t  *xp = funcoff;\n-\n-\t  info = *(uint32_t *) ((uintptr_t) fp->ctf_buf + funcoff);\n-\t  vlen = LCTF_INFO_VLEN (fp, info);\n-\n-\t  /* If we encounter a zero pad at the end, just skip it.  Otherwise\n-\t     skip over the function and its return type (+2) and the argument\n-\t     list (vlen).\n-\t   */\n-\t  if (LCTF_INFO_KIND (fp, info) == CTF_K_UNKNOWN && vlen == 0)\n-\t    funcoff += sizeof (uint32_t);\t/* Skip pad.  */\n-\t  else\n-\t    funcoff += sizeof (uint32_t) * (vlen + 2);\n+\t  funcoff += sizeof (uint32_t);\n \t  break;\n \n \tdefault:\n@@ -1012,9 +1033,7 @@ flip_lbls (void *start, size_t len)\n }\n \n /* Flip the endianness of the data-object or function sections or their indexes,\n-   all arrays of uint32_t.  (The function section has more internal structure,\n-   but that structure is an array of uint32_t, so can be treated as one big\n-   array for byte-swapping.)  */\n+   all arrays of uint32_t.  */\n \n static void\n flip_objts (void *start, size_t len)\n@@ -1379,16 +1398,22 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t info.  We do not support dynamically upgrading such entries (none\n \t should exist in any case, since dwarf2ctf does not create them).  */\n \n-      ctf_err_warn (NULL, 0, 0, _(\"ctf_bufopen: CTF version %d symsect not \"\n-\t\t\t\t  \"supported\"), pp->ctp_version);\n+      ctf_err_warn (NULL, 0, ECTF_NOTSUP, _(\"ctf_bufopen: CTF version %d \"\n+\t\t\t\t\t    \"symsect not supported\"),\n+\t\t    pp->ctp_version);\n       return (ctf_set_open_errno (errp, ECTF_NOTSUP));\n     }\n \n   if (pp->ctp_version < CTF_VERSION_3)\n     hdrsz = sizeof (ctf_header_v2_t);\n \n   if (_libctf_unlikely_ (pp->ctp_flags > CTF_F_MAX))\n-    return (ctf_set_open_errno (errp, ECTF_FLAGS));\n+    {\n+      ctf_err_warn (NULL, 0, ECTF_FLAGS, _(\"ctf_bufopen: invalid header \"\n+\t\t\t\t\t   \"flags: %x\"),\n+\t\t    (unsigned int) pp->ctp_flags);\n+      return (ctf_set_open_errno (errp, ECTF_FLAGS));\n+    }\n \n   if (ctfsect->cts_size < hdrsz)\n     return (ctf_set_open_errno (errp, ECTF_NOCTFBUF));\n@@ -1423,7 +1448,10 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n       || hp->cth_funcoff > fp->ctf_size || hp->cth_objtidxoff > fp->ctf_size\n       || hp->cth_funcidxoff > fp->ctf_size || hp->cth_typeoff > fp->ctf_size\n       || hp->cth_stroff > fp->ctf_size)\n-    return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+    {\n+      ctf_err_warn (NULL, 0, ECTF_CORRUPT, _(\"header offset exceeds CTF size\"));\n+      return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+    }\n \n   if (hp->cth_lbloff > hp->cth_objtoff\n       || hp->cth_objtoff > hp->cth_funcoff\n@@ -1432,13 +1460,46 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n       || hp->cth_objtidxoff > hp->cth_funcidxoff\n       || hp->cth_funcidxoff > hp->cth_varoff\n       || hp->cth_varoff > hp->cth_typeoff || hp->cth_typeoff > hp->cth_stroff)\n-    return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+    {\n+      ctf_err_warn (NULL, 0, ECTF_CORRUPT, _(\"overlapping CTF sections\"));\n+      return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+    }\n \n   if ((hp->cth_lbloff & 3) || (hp->cth_objtoff & 2)\n       || (hp->cth_funcoff & 2) || (hp->cth_objtidxoff & 2)\n       || (hp->cth_funcidxoff & 2) || (hp->cth_varoff & 3)\n       || (hp->cth_typeoff & 3))\n-    return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+    {\n+      ctf_err_warn (NULL, 0, ECTF_CORRUPT,\n+\t\t    _(\"CTF sections not properly aligned\"));\n+      return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+    }\n+\n+  /* This invariant will be lifted in v4, but for now it is true.  */\n+\n+  if ((hp->cth_funcidxoff - hp->cth_objtidxoff != 0) &&\n+      (hp->cth_funcidxoff - hp->cth_objtidxoff\n+       != hp->cth_funcoff - hp->cth_objtoff))\n+    {\n+      ctf_err_warn (NULL, 0, ECTF_CORRUPT,\n+\t\t    _(\"Object index section exists is neither empty nor the \"\n+\t\t      \"same length as the object section: %u versus %u \"\n+\t\t      \"bytes\"), hp->cth_funcoff - hp->cth_objtoff,\n+\t\t    hp->cth_funcidxoff - hp->cth_objtidxoff);\n+      return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+    }\n+\n+  if ((hp->cth_varoff - hp->cth_funcidxoff != 0) &&\n+      (hp->cth_varoff - hp->cth_funcidxoff\n+       != hp->cth_objtidxoff - hp->cth_funcoff))\n+    {\n+      ctf_err_warn (NULL, 0, ECTF_CORRUPT,\n+\t\t    _(\"Function index section exists is neither empty nor the \"\n+\t\t      \"same length as the function section: %u versus %u \"\n+\t\t      \"bytes\"), hp->cth_objtidxoff - hp->cth_funcoff,\n+\t\t    hp->cth_varoff - hp->cth_funcidxoff);\n+      return (ctf_set_open_errno (errp, ECTF_CORRUPT));\n+    }\n \n   /* Once everything is determined to be valid, attempt to decompress the CTF\n      data buffer if it is compressed, or copy it into new storage if it is not\n@@ -1586,10 +1647,12 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n   if ((err = init_types (fp, hp)) != 0)\n     goto bad;\n \n-  /* If we have a symbol table section, allocate and initialize\n-     the symtab translation table, pointed to by ctf_sxlate.  This table may be\n-     too large for the actual size of the object and function info sections: if\n-     so, ctf_nsyms will be adjusted and the excess will never be used.  */\n+  /* Allocate and initialize the symtab translation table, pointed to by\n+     ctf_sxlate, and the corresponding index sections.  This table may be too\n+     large for the actual size of the object and function info sections: if so,\n+     ctf_nsyms will be adjusted and the excess will never be used.  It's\n+     possible to do indexed symbol lookups even without a symbol table, so check\n+     even in that case.  */\n \n   if (symsect != NULL)\n     {\n@@ -1601,11 +1664,11 @@ ctf_bufopen_internal (const ctf_sect_t *ctfsect, const ctf_sect_t *symsect,\n \t  err = ENOMEM;\n \t  goto bad;\n \t}\n-\n-      if ((err = init_symtab (fp, hp, symsect, strsect)) != 0)\n-\tgoto bad;\n     }\n \n+  if ((err = init_symtab (fp, hp, symsect)) != 0)\n+    goto bad;\n+\n   ctf_set_ctl_hashes (fp);\n \n   if (symsect != NULL)\n@@ -1649,6 +1712,7 @@ ctf_dict_close (ctf_dict_t *fp)\n {\n   ctf_dtdef_t *dtd, *ntd;\n   ctf_dvdef_t *dvd, *nvd;\n+  ctf_in_flight_dynsym_t *did, *nid;\n   ctf_err_warning_t *err, *nerr;\n \n   if (fp == NULL)\n@@ -1701,6 +1765,20 @@ ctf_dict_close (ctf_dict_t *fp)\n       ctf_dvd_delete (fp, dvd);\n     }\n   ctf_dynhash_destroy (fp->ctf_dvhash);\n+\n+  free (fp->ctf_funcidx_sxlate);\n+  free (fp->ctf_objtidx_sxlate);\n+  ctf_dynhash_destroy (fp->ctf_objthash);\n+  ctf_dynhash_destroy (fp->ctf_funchash);\n+  free (fp->ctf_dynsymidx);\n+  ctf_dynhash_destroy (fp->ctf_dynsyms);\n+  for (did = ctf_list_next (&fp->ctf_in_flight_dynsyms); did != NULL; did = nid)\n+    {\n+      nid = ctf_list_next (did);\n+      ctf_list_delete (&fp->ctf_in_flight_dynsyms, did);\n+      free (did);\n+    }\n+\n   ctf_str_free_atoms (fp);\n   free (fp->ctf_tmp_typeslice);\n "
    },
    {
      "sha": "ed65b51ee1f4da0d3e079194a896db5a95452208",
      "filename": "libctf/ctf-string.c",
      "status": "modified",
      "additions": 29,
      "deletions": 24,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-string.c?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -259,6 +259,28 @@ ctf_str_add_external (ctf_dict_t *fp, const char *str, uint32_t offset)\n     return 0;\n \n   atom->csa_external_offset = CTF_SET_STID (offset, CTF_STRTAB_1);\n+\n+  if (!fp->ctf_syn_ext_strtab)\n+    fp->ctf_syn_ext_strtab = ctf_dynhash_create (ctf_hash_integer,\n+\t\t\t\t\t\t ctf_hash_eq_integer,\n+\t\t\t\t\t\t NULL, NULL);\n+  if (!fp->ctf_syn_ext_strtab)\n+    {\n+      ctf_set_errno (fp, ENOMEM);\n+      return 0;\n+    }\n+\n+  if (ctf_dynhash_insert (fp->ctf_syn_ext_strtab,\n+\t\t\t  (void *) (uintptr_t)\n+\t\t\t  atom->csa_external_offset,\n+\t\t\t  (void *) atom->csa_str) < 0)\n+    {\n+      /* No need to bother freeing the syn_ext_strtab: it will get freed at\n+\t ctf_str_write_strtab time if unreferenced.  */\n+      ctf_set_errno (fp, ENOMEM);\n+      return 0;\n+    }\n+\n   return 1;\n }\n \n@@ -285,17 +307,20 @@ ctf_str_remove_ref (ctf_dict_t *fp, const char *str, uint32_t *ref)\n }\n \n /* A ctf_dynhash_iter_remove() callback that removes atoms later than a given\n-   snapshot ID.  */\n+   snapshot ID.  External atoms are never removed, because they came from the\n+   linker string table and are still present even if you roll back type\n+   additions.  */\n static int\n ctf_str_rollback_atom (void *key _libctf_unused_, void *value, void *arg)\n {\n   ctf_str_atom_t *atom = (ctf_str_atom_t *) value;\n   ctf_snapshot_id_t *id = (ctf_snapshot_id_t *) arg;\n \n-  return (atom->csa_snapshot_id > id->snapshot_id);\n+  return (atom->csa_snapshot_id > id->snapshot_id)\n+    && (atom->csa_external_offset == 0);\n }\n \n-/* Roll back, deleting all atoms created after a particular ID.  */\n+/* Roll back, deleting all (internal) atoms created after a particular ID.  */\n void\n ctf_str_rollback (ctf_dict_t *fp, ctf_snapshot_id_t id)\n {\n@@ -455,32 +480,15 @@ ctf_str_write_strtab (ctf_dict_t *fp)\n   if ((strtab.cts_strs = malloc (strtab.cts_len)) == NULL)\n     goto oom_sorttab;\n \n-  if (!fp->ctf_syn_ext_strtab)\n-    fp->ctf_syn_ext_strtab = ctf_dynhash_create (ctf_hash_integer,\n-\t\t\t\t\t\t ctf_hash_eq_integer,\n-\t\t\t\t\t\t NULL, NULL);\n-  if (!fp->ctf_syn_ext_strtab)\n-    goto oom_strtab;\n-\n   /* Update all refs: also update the strtab appropriately.  */\n   for (i = 0; i < s.strtab_count; i++)\n     {\n       if (sorttab[i]->csa_external_offset)\n \t{\n-\t  /* External strtab entry: populate the synthetic external strtab.\n-\n-\t     This is safe because you cannot ctf_rollback to before the point\n-\t     when a ctf_update is done, and the strtab is written at ctf_update\n-\t     time.  So any atoms we reference here are sure to stick around\n-\t     until ctf_dict_close.  */\n+\t  /* External strtab entry.  */\n \n \t  any_external = 1;\n \t  ctf_str_update_refs (sorttab[i], sorttab[i]->csa_external_offset);\n-\t  if (ctf_dynhash_insert (fp->ctf_syn_ext_strtab,\n-\t\t\t\t  (void *) (uintptr_t)\n-\t\t\t\t  sorttab[i]->csa_external_offset,\n-\t\t\t\t  (void *) sorttab[i]->csa_str) < 0)\n-\t    goto oom_strtab;\n \t  sorttab[i]->csa_offset = sorttab[i]->csa_external_offset;\n \t}\n       else\n@@ -510,9 +518,6 @@ ctf_str_write_strtab (ctf_dict_t *fp)\n   fp->ctf_str_prov_offset = strtab.cts_len + 1;\n   return strtab;\n \n- oom_strtab:\n-  free (strtab.cts_strs);\n-  strtab.cts_strs = NULL;\n  oom_sorttab:\n   free (sorttab);\n  oom:"
    },
    {
      "sha": "dd8ee4fd0eec8b13ea5d89792ea5c641bf274540",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -642,6 +642,18 @@ ctf_type_resolve_unsliced (ctf_dict_t *fp, ctf_id_t type)\n   return type;\n }\n \n+/* Return the native dict of a given type: if called on a child and the\n+   type is in the parent, return the parent.  Needed if you plan to access\n+   the type directly, without using the API.  */\n+ctf_dict_t *\n+ctf_get_dict (ctf_dict_t *fp, ctf_id_t type)\n+{\n+    if ((fp->ctf_flags & LCTF_CHILD) && LCTF_TYPE_ISPARENT (fp, type))\n+      return fp->ctf_parent;\n+\n+    return fp;\n+}\n+\n /* Look up a name in the given name table, in the appropriate hash given the\n    kind of the identifier.  The name is a raw, undecorated identifier.  */\n "
    },
    {
      "sha": "0a15b868908755a24e7e2ca770224f668a4ffd44",
      "filename": "libctf/ctf-util.c",
      "status": "modified",
      "additions": 41,
      "deletions": 7,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-util.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/ctf-util.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-util.c?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -108,17 +108,48 @@ ctf_list_splice (ctf_list_t *lp, ctf_list_t *append)\n   append->l_prev = NULL;\n }\n \n-/* Convert a 32-bit ELF symbol into Elf64 and return a pointer to it.  */\n+/* Convert a 32-bit ELF symbol to a ctf_link_sym_t.  */\n \n-Elf64_Sym *\n-ctf_sym_to_elf64 (const Elf32_Sym *src, Elf64_Sym *dst)\n+ctf_link_sym_t *\n+ctf_elf32_to_link_sym (ctf_dict_t *fp, ctf_link_sym_t *dst, const Elf32_Sym *src,\n+\t\t       uint32_t symidx)\n {\n-  dst->st_name = src->st_name;\n+  /* The name must be in the external string table.  */\n+  if (src->st_name < fp->ctf_str[CTF_STRTAB_1].cts_len)\n+    dst->st_name = (const char *) fp->ctf_str[CTF_STRTAB_1].cts_strs + src->st_name;\n+  else\n+    dst->st_name = _CTF_NULLSTR;\n+  dst->st_nameidx_set = 0;\n+  dst->st_symidx = symidx;\n+  dst->st_shndx = src->st_shndx;\n+  dst->st_type = ELF32_ST_TYPE (src->st_info);\n   dst->st_value = src->st_value;\n-  dst->st_size = src->st_size;\n-  dst->st_info = src->st_info;\n-  dst->st_other = src->st_other;\n+\n+  return dst;\n+}\n+\n+/* Convert a 64-bit ELF symbol to a ctf_link_sym_t.  */\n+\n+ctf_link_sym_t *\n+ctf_elf64_to_link_sym (ctf_dict_t *fp, ctf_link_sym_t *dst, const Elf64_Sym *src,\n+\t\t       uint32_t symidx)\n+{\n+  /* The name must be in the external string table.  */\n+  if (src->st_name < fp->ctf_str[CTF_STRTAB_1].cts_len)\n+    dst->st_name = (const char *) fp->ctf_str[CTF_STRTAB_1].cts_strs + src->st_name;\n+  else\n+    dst->st_name = _CTF_NULLSTR;\n+  dst->st_nameidx_set = 0;\n+  dst->st_symidx = symidx;\n   dst->st_shndx = src->st_shndx;\n+  dst->st_type = ELF32_ST_TYPE (src->st_info);\n+\n+  /* We only care if the value is zero, so avoid nonzeroes turning into\n+     zeroes.  */\n+  if (_libctf_unlikely_ (src->st_value != 0 && ((uint32_t) src->st_value == 0)))\n+    dst->st_value = 1;\n+  else\n+    dst->st_value = (uint32_t) src->st_value;\n \n   return dst;\n }\n@@ -212,6 +243,9 @@ ctf_next_destroy (ctf_next_t *i)\n \n   if (i->ctn_iter_fun == (void (*) (void)) ctf_dynhash_next_sorted)\n     free (i->u.ctn_sorted_hkv);\n+  if (i->ctn_iter_fun == (void (*) (void)) ctf_symbol_next\n+      && i->cu.ctn_fp->ctf_flags & LCTF_RDWR)\n+    ctf_next_destroy (i->u.ctn_next);\n   free (i);\n }\n "
    },
    {
      "sha": "7369d639a82256daf2debace7e49b413b0da5e2c",
      "filename": "libctf/libctf.ver",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/libctf.ver",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1136c379718cb9f6a82e71029f86cd8cf70fa6be/libctf/libctf.ver",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/libctf.ver?ref=1136c379718cb9f6a82e71029f86cd8cf70fa6be",
      "patch": "@@ -182,5 +182,9 @@ LIBCTF_1.1 {\n \tctf_dict_close;\n \tctf_parent_dict;\n \n+\tctf_symbol_next;\n+\tctf_add_objt_sym;\n+\tctf_add_func_sym;\n+\n \tctf_link_add_linker_symbol;\n } LIBCTF_1.0;"
    }
  ]
}