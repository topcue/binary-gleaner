{
  "sha": "064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
  "node_id": "C_kwDOANOeidoAKDA2NGYzYzZhMDFiYTg5MDM2OTA4MWE5ZjJjOWNiMWQ2MmY4YjljMzQ",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-12T23:03:33Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-18T17:34:05Z"
    },
    "message": "Move \"catch fork\" to a new file\n\nThe \"catch fork\" code is reasonably self-contained, and so this patch\nmoves it out of breakpoint.c (the second largest source file in gdb)\nand into a new file, break-catch-fork.c.",
    "tree": {
      "sha": "4f331caaaf49d9503a2a98a4dffe52c076e1e1cf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4f331caaaf49d9503a2a98a4dffe52c076e1e1cf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "59505f2cec80bfd0b721a53104dbbf7f300127b7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/59505f2cec80bfd0b721a53104dbbf7f300127b7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/59505f2cec80bfd0b721a53104dbbf7f300127b7"
    }
  ],
  "stats": {
    "total": 530,
    "additions": 287,
    "deletions": 243
  },
  "files": [
    {
      "sha": "6ae511d0e1d9ceb9d463ff4d5ced2b14835a0b24",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
      "patch": "@@ -999,6 +999,7 @@ COMMON_SFILES = \\\n \tbfd-target.c \\\n \tblock.c \\\n \tblockframe.c \\\n+\tbreak-catch-fork.c \\\n \tbreak-catch-sig.c \\\n \tbreak-catch-syscall.c \\\n \tbreak-catch-throw.c \\"
    },
    {
      "sha": "af44a9fe76e27893a085c8ca933fd1985a648adb",
      "filename": "gdb/break-catch-fork.c",
      "status": "added",
      "additions": 286,
      "deletions": 0,
      "changes": 286,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34/gdb/break-catch-fork.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34/gdb/break-catch-fork.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-fork.c?ref=064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
      "patch": "@@ -0,0 +1,286 @@\n+/* Everything about vfork catchpoints, for GDB.\n+\n+   Copyright (C) 1986-2022 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+\n+#include \"annotate.h\"\n+#include \"arch-utils.h\"\n+#include \"breakpoint.h\"\n+#include \"cli/cli-decode.h\"\n+#include \"inferior.h\"\n+#include \"mi/mi-common.h\"\n+#include \"target.h\"\n+#include \"valprint.h\"\n+\n+/* An instance of this type is used to represent a fork or vfork\n+   catchpoint.  A breakpoint is really of this type iff its ops pointer points\n+   to CATCH_FORK_BREAKPOINT_OPS.  */\n+\n+struct fork_catchpoint : public breakpoint\n+{\n+  /* True if the breakpoint is for vfork, false for fork.  */\n+  bool is_vfork;\n+\n+  /* Process id of a child process whose forking triggered this\n+     catchpoint.  This field is only valid immediately after this\n+     catchpoint has triggered.  */\n+  ptid_t forked_inferior_pid;\n+};\n+\n+/* Implement the \"insert\" breakpoint_ops method for fork\n+   catchpoints.  */\n+\n+static int\n+insert_catch_fork (struct bp_location *bl)\n+{\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n+\n+  if (c->is_vfork)\n+    return target_insert_vfork_catchpoint (inferior_ptid.pid ());\n+  else\n+    return target_insert_fork_catchpoint (inferior_ptid.pid ());\n+}\n+\n+/* Implement the \"remove\" breakpoint_ops method for fork\n+   catchpoints.  */\n+\n+static int\n+remove_catch_fork (struct bp_location *bl, enum remove_bp_reason reason)\n+{\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n+\n+  if (c->is_vfork)\n+    return target_remove_vfork_catchpoint (inferior_ptid.pid ());\n+  else\n+    return target_remove_fork_catchpoint (inferior_ptid.pid ());\n+}\n+\n+/* Implement the \"breakpoint_hit\" breakpoint_ops method for fork\n+   catchpoints.  */\n+\n+static int\n+breakpoint_hit_catch_fork (const struct bp_location *bl,\n+\t\t\t   const address_space *aspace, CORE_ADDR bp_addr,\n+\t\t\t   const target_waitstatus &ws)\n+{\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n+\n+  if (ws.kind () != (c->is_vfork\n+\t\t     ? TARGET_WAITKIND_VFORKED\n+\t\t     : TARGET_WAITKIND_FORKED))\n+    return 0;\n+\n+  c->forked_inferior_pid = ws.child_ptid ();\n+  return 1;\n+}\n+\n+/* Implement the \"print_it\" breakpoint_ops method for fork\n+   catchpoints.  */\n+\n+static enum print_stop_action\n+print_it_catch_fork (bpstat *bs)\n+{\n+  struct ui_out *uiout = current_uiout;\n+  struct breakpoint *b = bs->breakpoint_at;\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) bs->breakpoint_at;\n+\n+  annotate_catchpoint (b->number);\n+  maybe_print_thread_hit_breakpoint (uiout);\n+  if (b->disposition == disp_del)\n+    uiout->text (\"Temporary catchpoint \");\n+  else\n+    uiout->text (\"Catchpoint \");\n+  if (uiout->is_mi_like_p ())\n+    {\n+      uiout->field_string (\"reason\",\n+\t\t\t   async_reason_lookup (c->is_vfork\n+\t\t\t\t\t\t? EXEC_ASYNC_VFORK\n+\t\t\t\t\t\t: EXEC_ASYNC_FORK));\n+      uiout->field_string (\"disp\", bpdisp_text (b->disposition));\n+    }\n+  uiout->field_signed (\"bkptno\", b->number);\n+  if (c->is_vfork)\n+    uiout->text (\" (vforked process \");\n+  else\n+    uiout->text (\" (forked process \");\n+  uiout->field_signed (\"newpid\", c->forked_inferior_pid.pid ());\n+  uiout->text (\"), \");\n+  return PRINT_SRC_AND_LOC;\n+}\n+\n+/* Implement the \"print_one\" breakpoint_ops method for fork\n+   catchpoints.  */\n+\n+static void\n+print_one_catch_fork (struct breakpoint *b, struct bp_location **last_loc)\n+{\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n+  struct value_print_options opts;\n+  struct ui_out *uiout = current_uiout;\n+\n+  get_user_print_options (&opts);\n+\n+  /* Field 4, the address, is omitted (which makes the columns not\n+     line up too nicely with the headers, but the effect is relatively\n+     readable).  */\n+  if (opts.addressprint)\n+    uiout->field_skip (\"addr\");\n+  annotate_field (5);\n+  const char *name = c->is_vfork ? \"vfork\" : \"fork\";\n+  uiout->text (name);\n+  if (c->forked_inferior_pid != null_ptid)\n+    {\n+      uiout->text (\", process \");\n+      uiout->field_signed (\"what\", c->forked_inferior_pid.pid ());\n+      uiout->spaces (1);\n+    }\n+\n+  if (uiout->is_mi_like_p ())\n+    uiout->field_string (\"catch-type\", name);\n+}\n+\n+/* Implement the \"print_mention\" breakpoint_ops method for fork\n+   catchpoints.  */\n+\n+static void\n+print_mention_catch_fork (struct breakpoint *b)\n+{\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n+  printf_filtered (_(\"Catchpoint %d (%s)\"), c->number,\n+\t\t   c->is_vfork ? \"vfork\" : \"fork\");\n+}\n+\n+/* Implement the \"print_recreate\" breakpoint_ops method for fork\n+   catchpoints.  */\n+\n+static void\n+print_recreate_catch_fork (struct breakpoint *b, struct ui_file *fp)\n+{\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n+  fprintf_unfiltered (fp, \"catch %s\",\n+\t\t      c->is_vfork ? \"vfork\" : \"fork\");\n+  print_recreate_thread (b, fp);\n+}\n+\n+/* The breakpoint_ops structure to be used in fork catchpoints.  */\n+\n+static struct breakpoint_ops catch_fork_breakpoint_ops;\n+\n+static void\n+create_fork_vfork_event_catchpoint (struct gdbarch *gdbarch,\n+\t\t\t\t    bool temp, const char *cond_string,\n+\t\t\t\t    bool is_vfork)\n+{\n+  std::unique_ptr<fork_catchpoint> c (new fork_catchpoint ());\n+\n+  init_catchpoint (c.get (), gdbarch, temp, cond_string,\n+\t\t   &catch_fork_breakpoint_ops);\n+  c->is_vfork = is_vfork;\n+  c->forked_inferior_pid = null_ptid;\n+\n+  install_breakpoint (0, std::move (c), 1);\n+}\n+\n+typedef enum\n+{\n+  catch_fork_temporary, catch_vfork_temporary,\n+  catch_fork_permanent, catch_vfork_permanent\n+}\n+catch_fork_kind;\n+\n+static void\n+catch_fork_command_1 (const char *arg, int from_tty,\n+\t\t      struct cmd_list_element *command)\n+{\n+  struct gdbarch *gdbarch = get_current_arch ();\n+  const char *cond_string = NULL;\n+  catch_fork_kind fork_kind;\n+\n+  fork_kind = (catch_fork_kind) (uintptr_t) command->context ();\n+  bool temp = (fork_kind == catch_fork_temporary\n+\t       || fork_kind == catch_vfork_temporary);\n+\n+  if (!arg)\n+    arg = \"\";\n+  arg = skip_spaces (arg);\n+\n+  /* The allowed syntax is:\n+     catch [v]fork\n+     catch [v]fork if <cond>\n+\n+     First, check if there's an if clause.  */\n+  cond_string = ep_parse_optional_if_clause (&arg);\n+\n+  if ((*arg != '\\0') && !isspace (*arg))\n+    error (_(\"Junk at end of arguments.\"));\n+\n+  /* If this target supports it, create a fork or vfork catchpoint\n+     and enable reporting of such events.  */\n+  switch (fork_kind)\n+    {\n+    case catch_fork_temporary:\n+    case catch_fork_permanent:\n+      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string, false);\n+      break;\n+    case catch_vfork_temporary:\n+    case catch_vfork_permanent:\n+      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string, true);\n+      break;\n+    default:\n+      error (_(\"unsupported or unknown fork kind; cannot catch it\"));\n+      break;\n+    }\n+}\n+\n+static void\n+initialize_ops ()\n+{\n+  struct breakpoint_ops *ops;\n+\n+  initialize_breakpoint_ops ();\n+\n+  /* Fork catchpoints.  */\n+  ops = &catch_fork_breakpoint_ops;\n+  *ops = base_breakpoint_ops;\n+  ops->insert_location = insert_catch_fork;\n+  ops->remove_location = remove_catch_fork;\n+  ops->breakpoint_hit = breakpoint_hit_catch_fork;\n+  ops->print_it = print_it_catch_fork;\n+  ops->print_one = print_one_catch_fork;\n+  ops->print_mention = print_mention_catch_fork;\n+  ops->print_recreate = print_recreate_catch_fork;\n+}\n+\n+void _initialize_break_catch_fork ();\n+void\n+_initialize_break_catch_fork ()\n+{\n+  initialize_ops ();\n+\n+  add_catch_command (\"fork\", _(\"Catch calls to fork.\"),\n+\t\t     catch_fork_command_1,\n+\t\t     NULL,\n+\t\t     (void *) (uintptr_t) catch_fork_permanent,\n+\t\t     (void *) (uintptr_t) catch_fork_temporary);\n+  add_catch_command (\"vfork\", _(\"Catch calls to vfork.\"),\n+\t\t     catch_fork_command_1,\n+\t\t     NULL,\n+\t\t     (void *) (uintptr_t) catch_vfork_permanent,\n+\t\t     (void *) (uintptr_t) catch_vfork_temporary);\n+}"
    },
    {
      "sha": "bfda5d70d9e2c6927fc164e26cacd9d29b3f2da6",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 0,
      "deletions": 243,
      "changes": 243,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/064f3c6a01ba890369081a9f2c9cb1d62f8b9c34/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=064f3c6a01ba890369081a9f2c9cb1d62f8b9c34",
      "patch": "@@ -7722,162 +7722,6 @@ disable_breakpoints_in_freed_objfile (struct objfile *objfile)\n     }\n }\n \n-/* FORK & VFORK catchpoints.  */\n-\n-/* An instance of this type is used to represent a fork or vfork\n-   catchpoint.  A breakpoint is really of this type iff its ops pointer points\n-   to CATCH_FORK_BREAKPOINT_OPS.  */\n-\n-struct fork_catchpoint : public breakpoint\n-{\n-  /* True if the breakpoint is for vfork, false for fork.  */\n-  bool is_vfork;\n-\n-  /* Process id of a child process whose forking triggered this\n-     catchpoint.  This field is only valid immediately after this\n-     catchpoint has triggered.  */\n-  ptid_t forked_inferior_pid;\n-};\n-\n-/* Implement the \"insert\" breakpoint_ops method for fork\n-   catchpoints.  */\n-\n-static int\n-insert_catch_fork (struct bp_location *bl)\n-{\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n-\n-  if (c->is_vfork)\n-    return target_insert_vfork_catchpoint (inferior_ptid.pid ());\n-  else\n-    return target_insert_fork_catchpoint (inferior_ptid.pid ());\n-}\n-\n-/* Implement the \"remove\" breakpoint_ops method for fork\n-   catchpoints.  */\n-\n-static int\n-remove_catch_fork (struct bp_location *bl, enum remove_bp_reason reason)\n-{\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n-\n-  if (c->is_vfork)\n-    return target_remove_vfork_catchpoint (inferior_ptid.pid ());\n-  else\n-    return target_remove_fork_catchpoint (inferior_ptid.pid ());\n-}\n-\n-/* Implement the \"breakpoint_hit\" breakpoint_ops method for fork\n-   catchpoints.  */\n-\n-static int\n-breakpoint_hit_catch_fork (const struct bp_location *bl,\n-\t\t\t   const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t   const target_waitstatus &ws)\n-{\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n-\n-  if (ws.kind () != (c->is_vfork\n-\t\t     ? TARGET_WAITKIND_VFORKED\n-\t\t     : TARGET_WAITKIND_FORKED))\n-    return 0;\n-\n-  c->forked_inferior_pid = ws.child_ptid ();\n-  return 1;\n-}\n-\n-/* Implement the \"print_it\" breakpoint_ops method for fork\n-   catchpoints.  */\n-\n-static enum print_stop_action\n-print_it_catch_fork (bpstat *bs)\n-{\n-  struct ui_out *uiout = current_uiout;\n-  struct breakpoint *b = bs->breakpoint_at;\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) bs->breakpoint_at;\n-\n-  annotate_catchpoint (b->number);\n-  maybe_print_thread_hit_breakpoint (uiout);\n-  if (b->disposition == disp_del)\n-    uiout->text (\"Temporary catchpoint \");\n-  else\n-    uiout->text (\"Catchpoint \");\n-  if (uiout->is_mi_like_p ())\n-    {\n-      uiout->field_string (\"reason\",\n-\t\t\t   async_reason_lookup (c->is_vfork\n-\t\t\t\t\t\t? EXEC_ASYNC_VFORK\n-\t\t\t\t\t\t: EXEC_ASYNC_FORK));\n-      uiout->field_string (\"disp\", bpdisp_text (b->disposition));\n-    }\n-  uiout->field_signed (\"bkptno\", b->number);\n-  if (c->is_vfork)\n-    uiout->text (\" (vforked process \");\n-  else\n-    uiout->text (\" (forked process \");\n-  uiout->field_signed (\"newpid\", c->forked_inferior_pid.pid ());\n-  uiout->text (\"), \");\n-  return PRINT_SRC_AND_LOC;\n-}\n-\n-/* Implement the \"print_one\" breakpoint_ops method for fork\n-   catchpoints.  */\n-\n-static void\n-print_one_catch_fork (struct breakpoint *b, struct bp_location **last_loc)\n-{\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n-  struct value_print_options opts;\n-  struct ui_out *uiout = current_uiout;\n-\n-  get_user_print_options (&opts);\n-\n-  /* Field 4, the address, is omitted (which makes the columns not\n-     line up too nicely with the headers, but the effect is relatively\n-     readable).  */\n-  if (opts.addressprint)\n-    uiout->field_skip (\"addr\");\n-  annotate_field (5);\n-  const char *name = c->is_vfork ? \"vfork\" : \"fork\";\n-  uiout->text (name);\n-  if (c->forked_inferior_pid != null_ptid)\n-    {\n-      uiout->text (\", process \");\n-      uiout->field_signed (\"what\", c->forked_inferior_pid.pid ());\n-      uiout->spaces (1);\n-    }\n-\n-  if (uiout->is_mi_like_p ())\n-    uiout->field_string (\"catch-type\", name);\n-}\n-\n-/* Implement the \"print_mention\" breakpoint_ops method for fork\n-   catchpoints.  */\n-\n-static void\n-print_mention_catch_fork (struct breakpoint *b)\n-{\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n-  printf_filtered (_(\"Catchpoint %d (%s)\"), c->number,\n-\t\t   c->is_vfork ? \"vfork\" : \"fork\");\n-}\n-\n-/* Implement the \"print_recreate\" breakpoint_ops method for fork\n-   catchpoints.  */\n-\n-static void\n-print_recreate_catch_fork (struct breakpoint *b, struct ui_file *fp)\n-{\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n-  fprintf_unfiltered (fp, \"catch %s\",\n-\t\t      c->is_vfork ? \"vfork\" : \"fork\");\n-  print_recreate_thread (b, fp);\n-}\n-\n-/* The breakpoint_ops structure to be used in fork catchpoints.  */\n-\n-static struct breakpoint_ops catch_fork_breakpoint_ops;\n-\n /* An instance of this type is used to represent an solib catchpoint.\n    A breakpoint is really of this type iff its ops pointer points to\n    CATCH_SOLIB_BREAKPOINT_OPS.  */\n@@ -8142,21 +7986,6 @@ install_breakpoint (int internal, std::unique_ptr<breakpoint> &&arg, int update_\n     update_global_location_list (UGLL_MAY_INSERT);\n }\n \n-static void\n-create_fork_vfork_event_catchpoint (struct gdbarch *gdbarch,\n-\t\t\t\t    bool temp, const char *cond_string,\n-\t\t\t\t    bool is_vfork)\n-{\n-  std::unique_ptr<fork_catchpoint> c (new fork_catchpoint ());\n-\n-  init_catchpoint (c.get (), gdbarch, temp, cond_string,\n-\t\t   &catch_fork_breakpoint_ops);\n-  c->is_vfork = is_vfork;\n-  c->forked_inferior_pid = null_ptid;\n-\n-  install_breakpoint (0, std::move (c), 1);\n-}\n-\n /* Exec catchpoints.  */\n \n /* An instance of this type is used to represent an exec catchpoint.\n@@ -11163,57 +10992,6 @@ ep_parse_optional_if_clause (const char **arg)\n /* Commands to deal with catching events, such as signals, exceptions,\n    process start/exit, etc.  */\n \n-typedef enum\n-{\n-  catch_fork_temporary, catch_vfork_temporary,\n-  catch_fork_permanent, catch_vfork_permanent\n-}\n-catch_fork_kind;\n-\n-static void\n-catch_fork_command_1 (const char *arg, int from_tty,\n-\t\t      struct cmd_list_element *command)\n-{\n-  struct gdbarch *gdbarch = get_current_arch ();\n-  const char *cond_string = NULL;\n-  catch_fork_kind fork_kind;\n-\n-  fork_kind = (catch_fork_kind) (uintptr_t) command->context ();\n-  bool temp = (fork_kind == catch_fork_temporary\n-\t       || fork_kind == catch_vfork_temporary);\n-\n-  if (!arg)\n-    arg = \"\";\n-  arg = skip_spaces (arg);\n-\n-  /* The allowed syntax is:\n-     catch [v]fork\n-     catch [v]fork if <cond>\n-\n-     First, check if there's an if clause.  */\n-  cond_string = ep_parse_optional_if_clause (&arg);\n-\n-  if ((*arg != '\\0') && !isspace (*arg))\n-    error (_(\"Junk at end of arguments.\"));\n-\n-  /* If this target supports it, create a fork or vfork catchpoint\n-     and enable reporting of such events.  */\n-  switch (fork_kind)\n-    {\n-    case catch_fork_temporary:\n-    case catch_fork_permanent:\n-      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string, false);\n-      break;\n-    case catch_vfork_temporary:\n-    case catch_vfork_permanent:\n-      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string, true);\n-      break;\n-    default:\n-      error (_(\"unsupported or unknown fork kind; cannot catch it\"));\n-      break;\n-    }\n-}\n-\n static void\n catch_exec_command_1 (const char *arg, int from_tty,\n \t\t      struct cmd_list_element *command)\n@@ -15264,17 +15042,6 @@ initialize_breakpoint_ops (void)\n   ops->create_breakpoints_sal = strace_marker_create_breakpoints_sal;\n   ops->decode_location = strace_marker_decode_location;\n \n-  /* Fork catchpoints.  */\n-  ops = &catch_fork_breakpoint_ops;\n-  *ops = base_breakpoint_ops;\n-  ops->insert_location = insert_catch_fork;\n-  ops->remove_location = remove_catch_fork;\n-  ops->breakpoint_hit = breakpoint_hit_catch_fork;\n-  ops->print_it = print_it_catch_fork;\n-  ops->print_one = print_one_catch_fork;\n-  ops->print_mention = print_mention_catch_fork;\n-  ops->print_recreate = print_recreate_catch_fork;\n-\n   /* Exec catchpoints.  */\n   ops = &catch_exec_breakpoint_ops;\n   *ops = base_breakpoint_ops;\n@@ -15590,16 +15357,6 @@ Set temporary catchpoints to catch events.\"),\n \t\t\t&tcatch_cmdlist,\n \t\t\t0/*allow-unknown*/, &cmdlist);\n \n-  add_catch_command (\"fork\", _(\"Catch calls to fork.\"),\n-\t\t     catch_fork_command_1,\n-\t\t     NULL,\n-\t\t     (void *) (uintptr_t) catch_fork_permanent,\n-\t\t     (void *) (uintptr_t) catch_fork_temporary);\n-  add_catch_command (\"vfork\", _(\"Catch calls to vfork.\"),\n-\t\t     catch_fork_command_1,\n-\t\t     NULL,\n-\t\t     (void *) (uintptr_t) catch_vfork_permanent,\n-\t\t     (void *) (uintptr_t) catch_vfork_temporary);\n   add_catch_command (\"exec\", _(\"Catch calls to exec.\"),\n \t\t     catch_exec_command_1,\n \t\t     NULL,"
    }
  ]
}