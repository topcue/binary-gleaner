{
  "sha": "74fd118fb91f49377b63931d092b6d42dd8b3b3c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzRmZDExOGZiOTFmNDkzNzdiNjM5MzFkMDkyYjZkNDJkZDhiM2IzYw==",
  "commit": {
    "author": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-05-25T10:22:15Z"
    },
    "committer": {
      "name": "Nick Clifton",
      "email": "nickc@redhat.com",
      "date": "2021-05-25T10:22:15Z"
    },
    "message": "Add range checks to local array accesses in elf32-arm.c.\n\nbfd\t* elf32-arn.c (struct elf_arm_obj_tdata): Add num_entries field.\n\t(elf32_arm_num_entries): New macro.\n\t(elf32_arm_allocate_local_sym_info): Initialise the new field.\n\tAllocate arrays individually so that buffer overruns can be\n\tdetected by memory checkers.\n\t(elf32_arm_create_local_iplt): Check num_entries.\n\t(elf32_arm_get_plt_info): Likewise.\n\t(elf32_arm_final_link_relocate): Likewise.\n\t(elf32_arm_check_relocs): Likewise.\n\t(elf32_arm_size_dynamic_sections): Likewise.\n\t(elf32_arm_output_arch_local_syms): Likewise.",
    "tree": {
      "sha": "282cb26ac49bb00a87a1b20623d3f6bca09f3f02",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/282cb26ac49bb00a87a1b20623d3f6bca09f3f02"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/74fd118fb91f49377b63931d092b6d42dd8b3b3c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74fd118fb91f49377b63931d092b6d42dd8b3b3c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/74fd118fb91f49377b63931d092b6d42dd8b3b3c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/74fd118fb91f49377b63931d092b6d42dd8b3b3c/comments",
  "author": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickclifton",
    "id": 31441682,
    "node_id": "MDQ6VXNlcjMxNDQxNjgy",
    "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickclifton",
    "html_url": "https://github.com/nickclifton",
    "followers_url": "https://api.github.com/users/nickclifton/followers",
    "following_url": "https://api.github.com/users/nickclifton/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions",
    "organizations_url": "https://api.github.com/users/nickclifton/orgs",
    "repos_url": "https://api.github.com/users/nickclifton/repos",
    "events_url": "https://api.github.com/users/nickclifton/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickclifton/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cc850f74725370808bd1e11ac9440d75df4cb23e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cc850f74725370808bd1e11ac9440d75df4cb23e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cc850f74725370808bd1e11ac9440d75df4cb23e"
    }
  ],
  "stats": {
    "total": 126,
    "additions": 105,
    "deletions": 21
  },
  "files": [
    {
      "sha": "fec2dcbb6811c4b483899eb9ecd380ab76f6a841",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74fd118fb91f49377b63931d092b6d42dd8b3b3c/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74fd118fb91f49377b63931d092b6d42dd8b3b3c/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=74fd118fb91f49377b63931d092b6d42dd8b3b3c",
      "patch": "@@ -1,3 +1,17 @@\n+2021-05-25  Nick Clifton  <nickc@redhat.com>\n+\n+\t* elf32-arn.c (struct elf_arm_obj_tdata): Add num_entries field.\n+\t(elf32_arm_num_entries): New macro.\n+\t(elf32_arm_allocate_local_sym_info): Initialise the new field.\n+\tAllocate arrays individually so that buffer overruns can be\n+\tdetected by memory checkers.\n+\t(elf32_arm_create_local_iplt): Check num_entries.\n+\t(elf32_arm_get_plt_info): Likewise.\n+\t(elf32_arm_final_link_relocate): Likewise.\n+\t(elf32_arm_check_relocs): Likewise.\n+\t(elf32_arm_size_dynamic_sections): Likewise.\n+\t(elf32_arm_output_arch_local_syms): Likewise.\n+\n 2021-05-25  Nick Clifton  <nickc@redhat.com>\n \n \t* elf32-arm.c: Fix formatting."
    },
    {
      "sha": "a9119c497805e5bf2e54e8fa1fee81694326e2b1",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 91,
      "deletions": 21,
      "changes": 112,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/74fd118fb91f49377b63931d092b6d42dd8b3b3c/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/74fd118fb91f49377b63931d092b6d42dd8b3b3c/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=74fd118fb91f49377b63931d092b6d42dd8b3b3c",
      "patch": "@@ -3152,6 +3152,10 @@ struct elf_arm_obj_tdata\n   /* Zero to warn when linking objects with incompatible wchar_t sizes.  */\n   int no_wchar_size_warning;\n \n+  /* The number of entries in each of the arrays in this strcuture.\n+     Used to avoid buffer overruns.  */\n+  bfd_size_type num_entries;\n+\n   /* tls_type for each local got entry.  */\n   char *local_got_tls_type;\n \n@@ -3168,6 +3172,9 @@ struct elf_arm_obj_tdata\n #define elf_arm_tdata(bfd) \\\n   ((struct elf_arm_obj_tdata *) (bfd)->tdata.any)\n \n+#define elf32_arm_num_entries(bfd) \\\n+  (elf_arm_tdata (bfd)->num_entries)\n+\n #define elf32_arm_local_got_tls_type(bfd) \\\n   (elf_arm_tdata (bfd)->local_got_tls_type)\n \n@@ -3581,35 +3588,48 @@ elf32_arm_allocate_local_sym_info (bfd *abfd)\n   if (elf_local_got_refcounts (abfd) == NULL)\n     {\n       bfd_size_type num_syms;\n-      bfd_size_type size;\n-      char *data;\n+\n+      elf32_arm_num_entries (abfd) = 0;\n+\n+      /* Whilst it might be tempting to allocate a single block of memory and\n+\t then divide it up amoungst the arrays in the elf_arm_obj_tdata\n+\t structure, this interferes with the work of memory checkers looking\n+\t for buffer overruns.  So allocate each array individually.  */\n \n       num_syms = elf_tdata (abfd)->symtab_hdr.sh_info;\n-      size = num_syms * (sizeof (bfd_signed_vma)\n-\t\t\t + sizeof (bfd_vma)\n-\t\t\t + sizeof (struct arm_local_iplt_info *)\n-\t\t\t + sizeof (struct fdpic_local)\n-\t\t\t + sizeof (char));\n-      data = bfd_zalloc (abfd, size);\n-      if (data == NULL)\n+\n+      elf_local_got_refcounts (abfd) = bfd_zalloc\n+\t(abfd, num_syms * sizeof (* elf_local_got_refcounts (abfd)));\n+\n+      if (elf_local_got_refcounts (abfd) == NULL)\n \treturn false;\n \n-      /* It is important that these all be allocated in descending\n-\t order of required alignment, so that arrays allocated later\n-\t will be sufficiently aligned.  */\n-      elf_local_got_refcounts (abfd) = (bfd_signed_vma *) data;\n-      data += num_syms * sizeof (bfd_signed_vma);\n+      elf32_arm_local_tlsdesc_gotent (abfd) = bfd_zalloc\n+\t(abfd, num_syms * sizeof (* elf32_arm_local_tlsdesc_gotent (abfd)));\n \n-      elf32_arm_local_tlsdesc_gotent (abfd) = (bfd_vma *) data;\n-      data += num_syms * sizeof (bfd_vma);\n+      if (elf32_arm_local_tlsdesc_gotent (abfd) == NULL)\n+\treturn false;\n \n-      elf32_arm_local_iplt (abfd) = (struct arm_local_iplt_info **) data;\n-      data += num_syms * sizeof (struct arm_local_iplt_info *);\n+      elf32_arm_local_iplt (abfd) = bfd_zalloc\n+\t(abfd, num_syms * sizeof (* elf32_arm_local_iplt (abfd)));\n \n-      elf32_arm_local_fdpic_cnts (abfd) = (struct fdpic_local *) data;\n-      data += num_syms * sizeof (struct fdpic_local);\n+      if (elf32_arm_local_iplt (abfd) == NULL)\n+\treturn false;\n+\n+      elf32_arm_local_fdpic_cnts (abfd) = bfd_zalloc\n+\t(abfd, num_syms * sizeof (* elf32_arm_local_fdpic_cnts (abfd)));\n+\n+      if (elf32_arm_local_fdpic_cnts (abfd) == NULL)\n+\treturn false;\n+\n+      elf32_arm_local_got_tls_type (abfd) = bfd_zalloc\n+\t(abfd, num_syms * sizeof (* elf32_arm_local_got_tls_type (abfd)));\n+\n+      if (elf32_arm_local_got_tls_type (abfd) == NULL)\n+\treturn false;\n+\n+      elf32_arm_num_entries (abfd) = num_syms;\n \n-      elf32_arm_local_got_tls_type (abfd) = data;\n #if GCC_VERSION >= 3000\n       BFD_ASSERT (__alignof__ (*elf32_arm_local_tlsdesc_gotent (abfd))\n \t\t  <= __alignof__ (*elf_local_got_refcounts (abfd)));\n@@ -3637,6 +3657,7 @@ elf32_arm_create_local_iplt (bfd *abfd, unsigned long r_symndx)\n     return NULL;\n \n   BFD_ASSERT (r_symndx < elf_tdata (abfd)->symtab_hdr.sh_info);\n+  BFD_ASSERT (r_symndx < elf32_arm_num_entries (abfd));\n   ptr = &elf32_arm_local_iplt (abfd)[r_symndx];\n   if (*ptr == NULL)\n     *ptr = bfd_zalloc (abfd, sizeof (**ptr));\n@@ -3672,6 +3693,9 @@ elf32_arm_get_plt_info (bfd *abfd, struct elf32_arm_link_hash_table *globals,\n   if (elf32_arm_local_iplt (abfd) == NULL)\n     return false;\n \n+  if (r_symndx >= elf32_arm_num_entries (abfd))\n+    return false;\n+\n   local_iplt = elf32_arm_local_iplt (abfd)[r_symndx];\n   if (local_iplt == NULL)\n     return false;\n@@ -11649,6 +11673,15 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t  {\n \t    BFD_ASSERT (local_got_offsets != NULL);\n \n+\t    if (r_symndx >= elf32_arm_num_entries (input_bfd))\n+\t      {\n+\t\t_bfd_error_handler (_(\"\\\n+%pB: expected symbol index in range 0..%lu but found local symbol with index %lu\"),\n+\t\t\t\t    input_bfd,\n+\t\t\t\t    (unsigned long) elf32_arm_num_entries (input_bfd),\n+\t\t\t\t    r_symndx);\n+\t\treturn false;\n+\t      }\n \t    off = local_got_offsets[r_symndx];\n \t    offplt = local_tlsdesc_gotents[r_symndx];\n \t    tls_type = elf32_arm_local_got_tls_type (input_bfd)[r_symndx];\n@@ -12569,6 +12602,13 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t  {\n \t    struct fdpic_local *local_fdpic_cnts = elf32_arm_local_fdpic_cnts (input_bfd);\n \t    int dynindx = elf_section_data (sym_sec->output_section)->dynindx;\n+\n+\t    if (r_symndx >= elf32_arm_num_entries (input_bfd))\n+\t      {\n+\t\t* error_message = _(\"local symbol index too big\");\n+\t\treturn bfd_reloc_dangerous;\n+\t      }\n+\n \t    int offset = local_fdpic_cnts[r_symndx].funcdesc_offset & ~1;\n \t    bfd_vma addr = dynreloc_value - sym_sec->output_section->vma;\n \t    bfd_vma seg = -1;\n@@ -12721,6 +12761,13 @@ elf32_arm_final_link_relocate (reloc_howto_type *\t    howto,\n \t    struct fdpic_local *local_fdpic_cnts = elf32_arm_local_fdpic_cnts (input_bfd);\n \t    Elf_Internal_Rela outrel;\n \t    int dynindx = elf_section_data (sym_sec->output_section)->dynindx;\n+\n+\t    if (r_symndx >= elf32_arm_num_entries (input_bfd))\n+\t      {\n+\t\t* error_message = _(\"local symbol index too big\");\n+\t\treturn bfd_reloc_dangerous;\n+\t      }\n+\n \t    int offset = local_fdpic_cnts[r_symndx].funcdesc_offset & ~1;\n \t    bfd_vma addr = dynreloc_value - sym_sec->output_section->vma;\n \t    bfd_vma seg = -1;\n@@ -15277,6 +15324,8 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      {\n \t\tif (!elf32_arm_allocate_local_sym_info (abfd))\n \t\t  return false;\n+\t\tif (r_symndx >= elf32_arm_num_entries (abfd))\n+\t\t  return false;\n \t\telf32_arm_local_fdpic_cnts (abfd) [r_symndx].gotofffuncdesc_cnt += 1;\n \t\telf32_arm_local_fdpic_cnts (abfd) [r_symndx].funcdesc_offset = -1;\n \t      }\n@@ -15309,6 +15358,8 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t      {\n \t\tif (!elf32_arm_allocate_local_sym_info (abfd))\n \t\t  return false;\n+\t\tif (r_symndx >= elf32_arm_num_entries (abfd))\n+\t\t  return false;\n \t\telf32_arm_local_fdpic_cnts (abfd) [r_symndx].funcdesc_cnt += 1;\n \t\telf32_arm_local_fdpic_cnts (abfd) [r_symndx].funcdesc_offset = -1;\n \t      }\n@@ -15363,6 +15414,13 @@ elf32_arm_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t\t  /* This is a global offset table entry for a local symbol.  */\n \t\t  if (!elf32_arm_allocate_local_sym_info (abfd))\n \t\t    return false;\n+\t\t  if (r_symndx >= elf32_arm_num_entries (abfd))\n+\t\t    {\n+\t\t      _bfd_error_handler (_(\"%pB: bad symbol index: %d\"), abfd,\n+\t\t\t\t\t  r_symndx);\n+\t\t      return false;\n+\t\t    }\n+\n \t\t  elf_local_got_refcounts (abfd)[r_symndx] += 1;\n \t\t  old_tls_type = elf32_arm_local_got_tls_type (abfd) [r_symndx];\n \t\t}\n@@ -16703,6 +16761,9 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n \t   ++local_got, ++local_iplt_ptr, ++local_tls_type,\n \t   ++local_tlsdesc_gotent, ++symndx, ++local_fdpic_cnts)\n \t{\n+\t  if (symndx >= elf32_arm_num_entries (ibfd))\n+\t    return false;\n+\n \t  *local_tlsdesc_gotent = (bfd_vma) -1;\n \t  local_iplt = *local_iplt_ptr;\n \n@@ -18164,6 +18225,15 @@ elf32_arm_output_arch_local_syms (bfd *output_bfd,\n \t  if (local_iplt != NULL)\n \t    {\n \t      num_syms = elf_symtab_hdr (input_bfd).sh_info;\n+\t      if (num_syms > elf32_arm_num_entries (input_bfd))\n+\t\t{\n+\t\t  _bfd_error_handler (_(\"\\\n+%pB: Number of symbols in input file has increased from %lu to %u\\n\"),\n+\t\t\t\t      input_bfd,\n+\t\t\t\t      (unsigned long) elf32_arm_num_entries (input_bfd),\n+\t\t\t\t      num_syms);\n+\t\t  return false;\n+\t\t}\n \t      for (i = 0; i < num_syms; i++)\n \t\tif (local_iplt[i] != NULL\n \t\t    && !elf32_arm_output_plt_map_1 (&osi, true,"
    }
  ]
}