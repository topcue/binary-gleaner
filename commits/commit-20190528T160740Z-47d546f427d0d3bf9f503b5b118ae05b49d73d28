{
  "sha": "47d546f427d0d3bf9f503b5b118ae05b49d73d28",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDdkNTQ2ZjQyN2QwZDNiZjlmNTAzYjViMTE4YWUwNWI0OWQ3M2QyOA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-04-23T21:45:46Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-05-28T16:07:40Z"
    },
    "message": "libctf: creation functions\n\nThe CTF creation process looks roughly like (error handling elided):\n\nint err;\nctf_file_t *foo = ctf_create (&err);\n\nctf_id_t type = ctf_add_THING (foo, ...);\nctf_update (foo);\nctf_*write (...);\n\nSome ctf_add_THING functions accept other type IDs as arguments,\ndepending on the type: cv-quals, pointers, and structure and union\nmembers all take other types as arguments.  So do 'slices', which\nlet you take an existing integral type and recast it as a type\nwith a different bitness or offset within a byte, for bitfields.\nOne class of THING is not a type: \"variables\", which are mappings\nof names (in the internal string table) to types.  These are mostly\nuseful when encoding variables that do not appear in a symbol table\nbut which some external user has some other way to figure out the\naddress of at runtime (dynamic symbol lookup or querying a VM\ninterpreter or something).\n\nYou can snapshot the creation process at any point: rolling back to a\nsnapshot deletes all types and variables added since that point.\n\nYou can make arbitrary type queries on the CTF container during the\ncreation process, but you must call ctf_update() first, which\ntranslates the growing dynamic container into a static one (this uses\nthe CTF opening machinery, added in a later commit), which is quite\nexpensive.  This function must also be called after adding types\nand before writing the container out.\n\nBecause addition of types involves looking up existing types, we add a\nlittle of the type lookup machinery here, as well: only enough to\nlook up types in dynamic containers under construction.\n\nlibctf/\n\t* ctf-create.c: New file.\n\t* ctf-lookup.c: New file.\n\ninclude/\n\t* ctf-api.h (zlib.h): New include.\n\t(ctf_sect_t): New.\n\t(ctf_sect_names_t): Likewise.\n\t(ctf_encoding_t): Likewise.\n\t(ctf_membinfo_t): Likewise.\n\t(ctf_arinfo_t): Likewise.\n\t(ctf_funcinfo_t): Likewise.\n\t(ctf_lblinfo_t): Likewise.\n\t(ctf_snapshot_id_t): Likewise.\n\t(CTF_FUNC_VARARG): Likewise.\n\t(ctf_simple_open): Likewise.\n\t(ctf_bufopen): Likewise.\n\t(ctf_create): Likewise.\n\t(ctf_add_array): Likewise.\n\t(ctf_add_const): Likewise.\n\t(ctf_add_enum_encoded): Likewise.\n\t(ctf_add_enum): Likewise.\n\t(ctf_add_float): Likewise.\n\t(ctf_add_forward): Likewise.\n\t(ctf_add_function): Likewise.\n\t(ctf_add_integer): Likewise.\n\t(ctf_add_slice): Likewise.\n\t(ctf_add_pointer): Likewise.\n\t(ctf_add_type): Likewise.\n\t(ctf_add_typedef): Likewise.\n\t(ctf_add_restrict): Likewise.\n\t(ctf_add_struct): Likewise.\n\t(ctf_add_union): Likewise.\n\t(ctf_add_struct_sized): Likewise.\n\t(ctf_add_union_sized): Likewise.\n\t(ctf_add_volatile): Likewise.\n\t(ctf_add_enumerator): Likewise.\n\t(ctf_add_member): Likewise.\n\t(ctf_add_member_offset): Likewise.\n\t(ctf_add_member_encoded): Likewise.\n\t(ctf_add_variable): Likewise.\n\t(ctf_set_array): Likewise.\n\t(ctf_update): Likewise.\n\t(ctf_snapshot): Likewise.\n\t(ctf_rollback): Likewise.\n\t(ctf_discard): Likewise.\n\t(ctf_write): Likewise.\n\t(ctf_gzwrite): Likewise.\n\t(ctf_compress_write): Likewise.",
    "tree": {
      "sha": "69f964b1297b2260e92412ca31f8941159ddebfe",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/69f964b1297b2260e92412ca31f8941159ddebfe"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/47d546f427d0d3bf9f503b5b118ae05b49d73d28",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/47d546f427d0d3bf9f503b5b118ae05b49d73d28",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/47d546f427d0d3bf9f503b5b118ae05b49d73d28",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/47d546f427d0d3bf9f503b5b118ae05b49d73d28/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a5be9bbe896d4adb6077e9bb2ebcaaa4426bdde1"
    }
  ],
  "stats": {
    "total": 1791,
    "additions": 1791,
    "deletions": 0
  },
  "files": [
    {
      "sha": "f069a9dfd40be4df49e7fc579a4bafd653219695",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/47d546f427d0d3bf9f503b5b118ae05b49d73d28/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/47d546f427d0d3bf9f503b5b118ae05b49d73d28/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=47d546f427d0d3bf9f503b5b118ae05b49d73d28",
      "patch": "@@ -1,3 +1,50 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (zlib.h): New include.\n+\t(ctf_sect_t): New.\n+\t(ctf_sect_names_t): Likewise.\n+\t(ctf_encoding_t): Likewise.\n+\t(ctf_membinfo_t): Likewise.\n+\t(ctf_arinfo_t): Likewise.\n+\t(ctf_funcinfo_t): Likewise.\n+\t(ctf_lblinfo_t): Likewise.\n+\t(ctf_snapshot_id_t): Likewise.\n+\t(CTF_FUNC_VARARG): Likewise.\n+\t(ctf_simple_open): Likewise.\n+\t(ctf_bufopen): Likewise.\n+\t(ctf_create): Likewise.\n+\t(ctf_add_array): Likewise.\n+\t(ctf_add_const): Likewise.\n+\t(ctf_add_enum_encoded): Likewise.\n+\t(ctf_add_enum): Likewise.\n+\t(ctf_add_float): Likewise.\n+\t(ctf_add_forward): Likewise.\n+\t(ctf_add_function): Likewise.\n+\t(ctf_add_integer): Likewise.\n+\t(ctf_add_slice): Likewise.\n+\t(ctf_add_pointer): Likewise.\n+\t(ctf_add_type): Likewise.\n+\t(ctf_add_typedef): Likewise.\n+\t(ctf_add_restrict): Likewise.\n+\t(ctf_add_struct): Likewise.\n+\t(ctf_add_union): Likewise.\n+\t(ctf_add_struct_sized): Likewise.\n+\t(ctf_add_union_sized): Likewise.\n+\t(ctf_add_volatile): Likewise.\n+\t(ctf_add_enumerator): Likewise.\n+\t(ctf_add_member): Likewise.\n+\t(ctf_add_member_offset): Likewise.\n+\t(ctf_add_member_encoded): Likewise.\n+\t(ctf_add_variable): Likewise.\n+\t(ctf_set_array): Likewise.\n+\t(ctf_update): Likewise.\n+\t(ctf_snapshot): Likewise.\n+\t(ctf_rollback): Likewise.\n+\t(ctf_discard): Likewise.\n+\t(ctf_write): Likewise.\n+\t(ctf_gzwrite): Likewise.\n+\t(ctf_compress_write): Likewise.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_errno): New declaration."
    },
    {
      "sha": "eb7f0d64c16c45df99633e894b2896a813657f90",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 129,
      "deletions": 0,
      "changes": 129,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/47d546f427d0d3bf9f503b5b118ae05b49d73d28/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/47d546f427d0d3bf9f503b5b118ae05b49d73d28/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=47d546f427d0d3bf9f503b5b118ae05b49d73d28",
      "patch": "@@ -27,6 +27,7 @@\n #include <sys/param.h>\n #include <sys/types.h>\n #include <ctf.h>\n+#include <zlib.h>\n \n #ifdef\t__cplusplus\n extern \"C\"\n@@ -44,6 +45,81 @@ typedef struct ctf_file ctf_file_t;\n typedef struct ctf_archive_internal ctf_archive_t;\n typedef long ctf_id_t;\n \n+/* If the debugger needs to provide the CTF library with a set of raw buffers\n+   for use as the CTF data, symbol table, and string table, it can do so by\n+   filling in ctf_sect_t structures and passing them to ctf_bufopen().\n+\n+   The contents of this structure must always be in native endianness (no\n+   byteswapping is performed).  */\n+\n+typedef struct ctf_sect\n+{\n+  const char *cts_name;\t\t  /* Section name (if any).  */\n+  unsigned long cts_type;\t  /* Section type (ELF SHT_... value).  */\n+  unsigned long cts_flags;\t  /* Section flags (ELF SHF_... value).  */\n+  const void *cts_data;\t\t  /* Pointer to section data.  */\n+  size_t cts_size;\t\t  /* Size of data in bytes.  */\n+  size_t cts_entsize;\t\t  /* Size of each section entry (symtab only).  */\n+  off64_t cts_offset;\t\t  /* File offset of this section (if any).  */\n+} ctf_sect_t;\n+\n+/* Symbolic names for CTF sections.  */\n+\n+typedef enum ctf_sect_names\n+  {\n+   CTF_SECT_HEADER,\n+   CTF_SECT_LABEL,\n+   CTF_SECT_OBJT,\n+   CTF_SECT_FUNC,\n+   CTF_SECT_VAR,\n+   CTF_SECT_TYPE,\n+   CTF_SECT_STR\n+  } ctf_sect_names_t;\n+\n+/* Encoding information for integers, floating-point values, and certain other\n+   intrinsics can be obtained by calling ctf_type_encoding(), below.  The flags\n+   field will contain values appropriate for the type defined in <ctf.h>.  */\n+\n+typedef struct ctf_encoding\n+{\n+  uint32_t cte_format;\t\t /* Data format (CTF_INT_* or CTF_FP_* flags).  */\n+  uint32_t cte_offset;\t\t /* Offset of value in bits.  */\n+  uint32_t cte_bits;\t\t /* Size of storage in bits.  */\n+} ctf_encoding_t;\n+\n+typedef struct ctf_membinfo\n+{\n+  ctf_id_t ctm_type;\t\t/* Type of struct or union member.  */\n+  unsigned long ctm_offset;\t/* Offset of member in bits.  */\n+} ctf_membinfo_t;\n+\n+typedef struct ctf_arinfo\n+{\n+  ctf_id_t ctr_contents;\t/* Type of array contents.  */\n+  ctf_id_t ctr_index;\t\t/* Type of array index.  */\n+  uint32_t ctr_nelems;\t\t/* Number of elements.  */\n+} ctf_arinfo_t;\n+\n+typedef struct ctf_funcinfo\n+{\n+  ctf_id_t ctc_return;\t\t/* Function return type.  */\n+  uint32_t ctc_argc;\t\t/* Number of typed arguments to function.  */\n+  uint32_t ctc_flags;\t\t/* Function attributes (see below).  */\n+} ctf_funcinfo_t;\n+\n+typedef struct ctf_lblinfo\n+{\n+  ctf_id_t ctb_type;\t\t/* Last type associated with the label.  */\n+} ctf_lblinfo_t;\n+\n+typedef struct ctf_snapshot_id\n+{\n+  unsigned long dtd_id;\t\t/* Highest DTD ID at time of snapshot.  */\n+  unsigned long snapshot_id;\t/* Snapshot id at time of snapshot.  */\n+} ctf_snapshot_id_t;\n+\n+#define\tCTF_FUNC_VARARG\t0x1\t/* Function arguments end with varargs.  */\n+\n /* Functions that return integer status or a ctf_id_t use the following value\n    to indicate failure.  ctf_errno() can be used to obtain an error code.  */\n #define\tCTF_ERR\t(-1L)\n@@ -122,8 +198,61 @@ enum\n #define\tCTF_ADD_NONROOT\t0\t/* Type only visible in nested scope.  */\n #define\tCTF_ADD_ROOT\t1\t/* Type visible at top-level scope.  */\n \n+extern ctf_file_t *ctf_simple_open (const char *, size_t, const char *, size_t,\n+\t\t\t\t   size_t, const char *, size_t, int *);\n+extern ctf_file_t *ctf_bufopen (const ctf_sect_t *, const ctf_sect_t *,\n+\t\t\t\tconst ctf_sect_t *, int *);\n+\n extern int ctf_errno (ctf_file_t *);\n extern const char *ctf_errmsg (int);\n+extern ctf_id_t ctf_add_array (ctf_file_t *, uint32_t,\n+\t\t\t       const ctf_arinfo_t *);\n+extern ctf_id_t ctf_add_const (ctf_file_t *, uint32_t, ctf_id_t);\n+extern ctf_id_t ctf_add_enum_encoded (ctf_file_t *, uint32_t, const char *,\n+\t\t\t\t      const ctf_encoding_t *);\n+extern ctf_id_t ctf_add_enum (ctf_file_t *, uint32_t, const char *);\n+extern ctf_id_t ctf_add_float (ctf_file_t *, uint32_t,\n+\t\t\t       const char *, const ctf_encoding_t *);\n+extern ctf_id_t ctf_add_forward (ctf_file_t *, uint32_t, const char *,\n+\t\t\t\t uint32_t);\n+extern ctf_id_t ctf_add_function (ctf_file_t *, uint32_t,\n+\t\t\t\t  const ctf_funcinfo_t *, const ctf_id_t *);\n+extern ctf_id_t ctf_add_integer (ctf_file_t *, uint32_t, const char *,\n+\t\t\t\t const ctf_encoding_t *);\n+extern ctf_id_t ctf_add_slice (ctf_file_t *, uint32_t, ctf_id_t, const ctf_encoding_t *);\n+extern ctf_id_t ctf_add_pointer (ctf_file_t *, uint32_t, ctf_id_t);\n+extern ctf_id_t ctf_add_type (ctf_file_t *, ctf_file_t *, ctf_id_t);\n+extern ctf_id_t ctf_add_typedef (ctf_file_t *, uint32_t, const char *,\n+\t\t\t\t ctf_id_t);\n+extern ctf_id_t ctf_add_restrict (ctf_file_t *, uint32_t, ctf_id_t);\n+extern ctf_id_t ctf_add_struct (ctf_file_t *, uint32_t, const char *);\n+extern ctf_id_t ctf_add_union (ctf_file_t *, uint32_t, const char *);\n+extern ctf_id_t ctf_add_struct_sized (ctf_file_t *, uint32_t, const char *,\n+\t\t\t\t      size_t);\n+extern ctf_id_t ctf_add_union_sized (ctf_file_t *, uint32_t, const char *,\n+\t\t\t\t     size_t);\n+extern ctf_id_t ctf_add_volatile (ctf_file_t *, uint32_t, ctf_id_t);\n+\n+extern int ctf_add_enumerator (ctf_file_t *, ctf_id_t, const char *, int);\n+extern int ctf_add_member (ctf_file_t *, ctf_id_t, const char *, ctf_id_t);\n+extern int ctf_add_member_offset (ctf_file_t *, ctf_id_t, const char *,\n+\t\t\t\t  ctf_id_t, unsigned long);\n+extern int ctf_add_member_encoded (ctf_file_t *, ctf_id_t, const char *,\n+\t\t\t\t   ctf_id_t, unsigned long,\n+\t\t\t\t   const ctf_encoding_t);\n+\n+extern int ctf_add_variable (ctf_file_t *, const char *, ctf_id_t);\n+\n+extern int ctf_set_array (ctf_file_t *, ctf_id_t, const ctf_arinfo_t *);\n+\n+extern ctf_file_t *ctf_create (int *);\n+extern int ctf_update (ctf_file_t *);\n+extern ctf_snapshot_id_t ctf_snapshot (ctf_file_t *);\n+extern int ctf_rollback (ctf_file_t *, ctf_snapshot_id_t);\n+extern int ctf_discard (ctf_file_t *);\n+extern int ctf_write (ctf_file_t *, int);\n+extern int ctf_gzwrite (ctf_file_t * fp, gzFile fd);\n+extern int ctf_compress_write (ctf_file_t * fp, int fd);\n \n extern void ctf_setdebug (int debug);\n extern int ctf_getdebug (void);"
    },
    {
      "sha": "8474d209674f79a72c9f4090c39fd4c186e4e8b4",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/47d546f427d0d3bf9f503b5b118ae05b49d73d28/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/47d546f427d0d3bf9f503b5b118ae05b49d73d28/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=47d546f427d0d3bf9f503b5b118ae05b49d73d28",
      "patch": "@@ -1,3 +1,8 @@\n+2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-create.c: New file.\n+\t* ctf-lookup.c: New file.\n+\n 2019-05-28  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.h: New definitions and declarations for type creation"
    },
    {
      "sha": "1035c5ab16decdf44dfc8dc4646237f14daa0ef5",
      "filename": "libctf/ctf-create.c",
      "status": "added",
      "additions": 1547,
      "deletions": 0,
      "changes": 1547,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/47d546f427d0d3bf9f503b5b118ae05b49d73d28/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/47d546f427d0d3bf9f503b5b118ae05b49d73d28/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=47d546f427d0d3bf9f503b5b118ae05b49d73d28",
      "patch": "@@ -0,0 +1,1547 @@\n+/* CTF file creation.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <sys/param.h>\n+#include <assert.h>\n+#include <string.h>\n+#include <zlib.h>\n+\n+/* To create an empty CTF container, we just declare a zeroed header and call\n+   ctf_bufopen() on it.  If ctf_bufopen succeeds, we mark the new container r/w\n+   and initialize the dynamic members.  We set dtvstrlen to 1 to reserve the\n+   first byte of the string table for a \\0 byte, and we start assigning type\n+   IDs at 1 because type ID 0 is used as a sentinel and a not-found\n+   indicator.  */\n+\n+ctf_file_t *\n+ctf_create (int *errp)\n+{\n+  static const ctf_header_t hdr = { .cth_preamble = { CTF_MAGIC, CTF_VERSION, 0 } };\n+\n+  ctf_dynhash_t *dthash;\n+  ctf_dynhash_t *dvhash;\n+  ctf_dynhash_t *dtbyname;\n+  ctf_sect_t cts;\n+  ctf_file_t *fp;\n+\n+  libctf_init_debug();\n+  dthash = ctf_dynhash_create (ctf_hash_integer, ctf_hash_eq_integer,\n+\t\t\t       NULL, NULL);\n+  if (dthash == NULL)\n+    {\n+      ctf_set_open_errno (errp, EAGAIN);\n+      goto err;\n+    }\n+\n+  dvhash = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t       NULL, NULL);\n+  if (dvhash == NULL)\n+    {\n+      ctf_set_open_errno (errp, EAGAIN);\n+      goto err_dt;\n+    }\n+\n+  dtbyname = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n+\t\t\t\t free, NULL);\n+  if (dtbyname == NULL)\n+    {\n+      ctf_set_open_errno (errp, EAGAIN);\n+      goto err_dv;\n+    }\n+\n+  cts.cts_name = _CTF_SECTION;\n+  cts.cts_type = SHT_PROGBITS;\n+  cts.cts_flags = 0;\n+  cts.cts_data = &hdr;\n+  cts.cts_size = sizeof (hdr);\n+  cts.cts_entsize = 1;\n+  cts.cts_offset = 0;\n+\n+  if ((fp = ctf_bufopen (&cts, NULL, NULL, errp)) == NULL)\n+      goto err_dtbyname;\n+\n+  fp->ctf_flags |= LCTF_RDWR;\n+  fp->ctf_dtbyname = dtbyname;\n+  fp->ctf_dthash = dthash;\n+  fp->ctf_dvhash = dvhash;\n+  fp->ctf_dtvstrlen = 1;\n+  fp->ctf_dtnextid = 1;\n+  fp->ctf_dtoldid = 0;\n+  fp->ctf_snapshots = 0;\n+  fp->ctf_snapshot_lu = 0;\n+\n+  return fp;\n+\n+ err_dtbyname:\n+  ctf_dynhash_destroy (dtbyname);\n+ err_dv:\n+  ctf_dynhash_destroy (dvhash);\n+ err_dt:\n+  ctf_dynhash_destroy (dthash);\n+ err:\n+  return NULL;\n+}\n+\n+static unsigned char *\n+ctf_copy_smembers (ctf_dtdef_t *dtd, uint32_t soff, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_member_t ctm;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      if (dmd->dmd_name)\n+\t{\n+\t  ctm.ctm_name = soff;\n+\t  soff += strlen (dmd->dmd_name) + 1;\n+\t}\n+      else\n+\tctm.ctm_name = 0;\n+\n+      ctm.ctm_type = (uint32_t) dmd->dmd_type;\n+      ctm.ctm_offset = (uint32_t) dmd->dmd_offset;\n+\n+      memcpy (t, &ctm, sizeof (ctm));\n+      t += sizeof (ctm);\n+    }\n+\n+  return t;\n+}\n+\n+static unsigned char *\n+ctf_copy_lmembers (ctf_dtdef_t *dtd, uint32_t soff, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_lmember_t ctlm;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      if (dmd->dmd_name)\n+\t{\n+\t  ctlm.ctlm_name = soff;\n+\t  soff += strlen (dmd->dmd_name) + 1;\n+\t}\n+      else\n+\tctlm.ctlm_name = 0;\n+\n+      ctlm.ctlm_type = (uint32_t) dmd->dmd_type;\n+      ctlm.ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (dmd->dmd_offset);\n+      ctlm.ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (dmd->dmd_offset);\n+\n+      memcpy (t, &ctlm, sizeof (ctlm));\n+      t += sizeof (ctlm);\n+    }\n+\n+  return t;\n+}\n+\n+static unsigned char *\n+ctf_copy_emembers (ctf_dtdef_t *dtd, uint32_t soff, unsigned char *t)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  ctf_enum_t cte;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      cte.cte_name = soff;\n+      cte.cte_value = dmd->dmd_value;\n+      soff += strlen (dmd->dmd_name) + 1;\n+      memcpy (t, &cte, sizeof (cte));\n+      t += sizeof (cte);\n+    }\n+\n+  return t;\n+}\n+\n+static unsigned char *\n+ctf_copy_membnames (ctf_dtdef_t *dtd, unsigned char *s)\n+{\n+  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+  size_t len;\n+\n+  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      if (dmd->dmd_name == NULL)\n+\tcontinue;\t\t\t/* Skip anonymous members.  */\n+      len = strlen (dmd->dmd_name) + 1;\n+      memcpy (s, dmd->dmd_name, len);\n+      s += len;\n+    }\n+\n+  return s;\n+}\n+\n+/* Sort a newly-constructed static variable array.  */\n+\n+static int\n+ctf_sort_var (const void *one_, const void *two_, void *strtab_)\n+{\n+  const ctf_varent_t *one = one_;\n+  const ctf_varent_t *two = two_;\n+  const char *strtab = strtab_;\n+  const char *n1 = strtab + CTF_NAME_OFFSET (one->ctv_name);\n+  const char *n2 = strtab + CTF_NAME_OFFSET (two->ctv_name);\n+\n+  return (strcmp (n1, n2));\n+}\n+\n+/* If the specified CTF container is writable and has been modified, reload this\n+   container with the updated type definitions.  In order to make this code and\n+   the rest of libctf as simple as possible, we perform updates by taking the\n+   dynamic type definitions and creating an in-memory CTF file containing the\n+   definitions, and then call ctf_simple_open() on it.  This not only leverages\n+   ctf_simple_open(), but also avoids having to bifurcate the rest of the library\n+   code with different lookup paths for static and dynamic type definitions.  We\n+   are therefore optimizing greatly for lookup over update, which we assume will\n+   be an uncommon operation.  We perform one extra trick here for the benefit of\n+   callers and to keep our code simple: ctf_simple_open() will return a new\n+   ctf_file_t, but we want to keep the fp constant for the caller, so after\n+   ctf_simple_open() returns, we use memcpy to swap the interior of the old and\n+   new ctf_file_t's, and then free the old.  */\n+int\n+ctf_update (ctf_file_t *fp)\n+{\n+  ctf_file_t ofp, *nfp;\n+  ctf_header_t hdr;\n+  ctf_dtdef_t *dtd;\n+  ctf_dvdef_t *dvd;\n+  ctf_varent_t *dvarents;\n+\n+  unsigned char *s, *s0, *t;\n+  unsigned long i;\n+  size_t buf_size, type_size, nvars;\n+  void *buf;\n+  int err;\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  /* Update required?  */\n+  if (!(fp->ctf_flags & LCTF_DIRTY))\n+    return 0;\n+\n+  /* Fill in an initial CTF header.  We will leave the label, object,\n+     and function sections empty and only output a header, type section,\n+     and string table.  The type section begins at a 4-byte aligned\n+     boundary past the CTF header itself (at relative offset zero).  */\n+\n+  memset (&hdr, 0, sizeof (hdr));\n+  hdr.cth_magic = CTF_MAGIC;\n+  hdr.cth_version = CTF_VERSION;\n+\n+  if (fp->ctf_flags & LCTF_CHILD)\n+    hdr.cth_parname = 1;\t\t/* parname added just below.  */\n+\n+  /* Iterate through the dynamic type definition list and compute the\n+     size of the CTF type section we will need to generate.  */\n+\n+  for (type_size = 0, dtd = ctf_list_next (&fp->ctf_dtdefs);\n+       dtd != NULL; dtd = ctf_list_next (dtd))\n+    {\n+      uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+      uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n+\n+      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n+\ttype_size += sizeof (ctf_stype_t);\n+      else\n+\ttype_size += sizeof (ctf_type_t);\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_INTEGER:\n+\tcase CTF_K_FLOAT:\n+\t  type_size += sizeof (uint32_t);\n+\t  break;\n+\tcase CTF_K_ARRAY:\n+\t  type_size += sizeof (ctf_array_t);\n+\t  break;\n+\tcase CTF_K_SLICE:\n+\t  type_size += sizeof (ctf_slice_t);\n+\t  break;\n+\tcase CTF_K_FUNCTION:\n+\t  type_size += sizeof (uint32_t) * (vlen + (vlen & 1));\n+\t  break;\n+\tcase CTF_K_STRUCT:\n+\tcase CTF_K_UNION:\n+\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n+\t    type_size += sizeof (ctf_member_t) * vlen;\n+\t  else\n+\t    type_size += sizeof (ctf_lmember_t) * vlen;\n+\t  break;\n+\tcase CTF_K_ENUM:\n+\t  type_size += sizeof (ctf_enum_t) * vlen;\n+\t  break;\n+\t}\n+    }\n+\n+  /* Computing the number of entries in the CTF variable section is much\n+     simpler.  */\n+\n+  for (nvars = 0, dvd = ctf_list_next (&fp->ctf_dvdefs);\n+       dvd != NULL; dvd = ctf_list_next (dvd), nvars++);\n+\n+  /* Fill in the string table and type offset and size, compute the size\n+     of the entire CTF buffer we need, and then allocate a new buffer and\n+     memcpy the finished header to the start of the buffer.  */\n+\n+  hdr.cth_typeoff = hdr.cth_varoff + (nvars * sizeof (ctf_varent_t));\n+  hdr.cth_stroff = hdr.cth_typeoff + type_size;\n+  hdr.cth_strlen = fp->ctf_dtvstrlen;\n+  if (fp->ctf_parname != NULL)\n+    hdr.cth_strlen += strlen (fp->ctf_parname) + 1;\n+\n+  buf_size = sizeof (ctf_header_t) + hdr.cth_stroff + hdr.cth_strlen;\n+\n+  if ((buf = ctf_data_alloc (buf_size)) == NULL)\n+    return (ctf_set_errno (fp, EAGAIN));\n+\n+  memcpy (buf, &hdr, sizeof (ctf_header_t));\n+  t = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_varoff;\n+  s = s0 = (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_stroff;\n+\n+  s[0] = '\\0';\n+  s++;\n+\n+  if (fp->ctf_parname != NULL)\n+    {\n+      memcpy (s, fp->ctf_parname, strlen (fp->ctf_parname) + 1);\n+      s += strlen (fp->ctf_parname) + 1;\n+    }\n+\n+  /* Work over the variable list, translating everything into\n+     ctf_varent_t's and filling out the string table, then sort the buffer\n+     of ctf_varent_t's.  */\n+\n+  dvarents = (ctf_varent_t *) t;\n+  for (i = 0, dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL;\n+       dvd = ctf_list_next (dvd), i++)\n+    {\n+      ctf_varent_t *var = &dvarents[i];\n+      size_t len = strlen (dvd->dvd_name) + 1;\n+\n+      var->ctv_name = (uint32_t) (s - s0);\n+      var->ctv_type = dvd->dvd_type;\n+      memcpy (s, dvd->dvd_name, len);\n+      s += len;\n+    }\n+  assert (i == nvars);\n+\n+  qsort_r (dvarents, nvars, sizeof (ctf_varent_t), ctf_sort_var, s0);\n+  t += sizeof (ctf_varent_t) * nvars;\n+\n+  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_typeoff);\n+\n+  /* We now take a final lap through the dynamic type definition list and\n+     copy the appropriate type records and strings to the output buffer.  */\n+\n+  for (dtd = ctf_list_next (&fp->ctf_dtdefs);\n+       dtd != NULL; dtd = ctf_list_next (dtd))\n+    {\n+\n+      uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+      uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n+\n+      ctf_array_t cta;\n+      uint32_t encoding;\n+      size_t len;\n+\n+      if (dtd->dtd_name != NULL)\n+\t{\n+\t  dtd->dtd_data.ctt_name = (uint32_t) (s - s0);\n+\t  len = strlen (dtd->dtd_name) + 1;\n+\t  memcpy (s, dtd->dtd_name, len);\n+\t  s += len;\n+\t}\n+      else\n+\tdtd->dtd_data.ctt_name = 0;\n+\n+      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n+\tlen = sizeof (ctf_stype_t);\n+      else\n+\tlen = sizeof (ctf_type_t);\n+\n+      memcpy (t, &dtd->dtd_data, len);\n+      t += len;\n+\n+      switch (kind)\n+\t{\n+\tcase CTF_K_INTEGER:\n+\tcase CTF_K_FLOAT:\n+\t  if (kind == CTF_K_INTEGER)\n+\t    {\n+\t      encoding = CTF_INT_DATA (dtd->dtd_u.dtu_enc.cte_format,\n+\t\t\t\t       dtd->dtd_u.dtu_enc.cte_offset,\n+\t\t\t\t       dtd->dtd_u.dtu_enc.cte_bits);\n+\t    }\n+\t  else\n+\t    {\n+\t      encoding = CTF_FP_DATA (dtd->dtd_u.dtu_enc.cte_format,\n+\t\t\t\t      dtd->dtd_u.dtu_enc.cte_offset,\n+\t\t\t\t      dtd->dtd_u.dtu_enc.cte_bits);\n+\t    }\n+\t  memcpy (t, &encoding, sizeof (encoding));\n+\t  t += sizeof (encoding);\n+\t  break;\n+\n+\tcase CTF_K_SLICE:\n+\t  memcpy (t, &dtd->dtd_u.dtu_slice, sizeof (struct ctf_slice));\n+\t  t += sizeof (struct ctf_slice);\n+\t  break;\n+\n+\tcase CTF_K_ARRAY:\n+\t  cta.cta_contents = (uint32_t) dtd->dtd_u.dtu_arr.ctr_contents;\n+\t  cta.cta_index = (uint32_t) dtd->dtd_u.dtu_arr.ctr_index;\n+\t  cta.cta_nelems = dtd->dtd_u.dtu_arr.ctr_nelems;\n+\t  memcpy (t, &cta, sizeof (cta));\n+\t  t += sizeof (cta);\n+\t  break;\n+\n+\tcase CTF_K_FUNCTION:\n+\t  {\n+\t    uint32_t *argv = (uint32_t *) (uintptr_t) t;\n+\t    uint32_t argc;\n+\n+\t    for (argc = 0; argc < vlen; argc++)\n+\t      *argv++ = (uint32_t) dtd->dtd_u.dtu_argv[argc];\n+\n+\t    if (vlen & 1)\n+\t      *argv++ = 0;\t/* Pad to 4-byte boundary.  */\n+\n+\t    t = (unsigned char *) argv;\n+\t    break;\n+\t  }\n+\n+\tcase CTF_K_STRUCT:\n+\tcase CTF_K_UNION:\n+\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n+\t    t = ctf_copy_smembers (dtd, (uint32_t) (s - s0), t);\n+\t  else\n+\t    t = ctf_copy_lmembers (dtd, (uint32_t) (s - s0), t);\n+\t  s = ctf_copy_membnames (dtd, s);\n+\t  break;\n+\n+\tcase CTF_K_ENUM:\n+\t  t = ctf_copy_emembers (dtd, (uint32_t) (s - s0), t);\n+\t  s = ctf_copy_membnames (dtd, s);\n+\t  break;\n+\t}\n+    }\n+  assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_stroff);\n+\n+  /* Finally, we are ready to ctf_simple_open() the new container.  If this\n+     is successful, we then switch nfp and fp and free the old container.  */\n+\n+  ctf_data_protect (buf, buf_size);\n+\n+  if ((nfp = ctf_simple_open (buf, buf_size, NULL, 0, 0, NULL, 0, &err)) == NULL)\n+    {\n+      ctf_data_free (buf, buf_size);\n+      return (ctf_set_errno (fp, err));\n+    }\n+\n+  (void) ctf_setmodel (nfp, ctf_getmodel (fp));\n+  (void) ctf_import (nfp, fp->ctf_parent);\n+\n+  nfp->ctf_refcnt = fp->ctf_refcnt;\n+  nfp->ctf_flags |= fp->ctf_flags & ~LCTF_DIRTY;\n+  nfp->ctf_data.cts_data = NULL;\t/* Force ctf_data_free() on close.  */\n+  nfp->ctf_dthash = fp->ctf_dthash;\n+  nfp->ctf_dtdefs = fp->ctf_dtdefs;\n+  nfp->ctf_dtbyname = fp->ctf_dtbyname;\n+  nfp->ctf_dvhash = fp->ctf_dvhash;\n+  nfp->ctf_dvdefs = fp->ctf_dvdefs;\n+  nfp->ctf_dtvstrlen = fp->ctf_dtvstrlen;\n+  nfp->ctf_dtnextid = fp->ctf_dtnextid;\n+  nfp->ctf_dtoldid = fp->ctf_dtnextid - 1;\n+  nfp->ctf_snapshots = fp->ctf_snapshots + 1;\n+  nfp->ctf_specific = fp->ctf_specific;\n+\n+  nfp->ctf_snapshot_lu = fp->ctf_snapshots;\n+\n+  fp->ctf_dtbyname = NULL;\n+  fp->ctf_dthash = NULL;\n+  memset (&fp->ctf_dtdefs, 0, sizeof (ctf_list_t));\n+\n+  fp->ctf_dvhash = NULL;\n+  memset (&fp->ctf_dvdefs, 0, sizeof (ctf_list_t));\n+\n+  memcpy (&ofp, fp, sizeof (ctf_file_t));\n+  memcpy (fp, nfp, sizeof (ctf_file_t));\n+  memcpy (nfp, &ofp, sizeof (ctf_file_t));\n+\n+  /* Initialize the ctf_lookup_by_name top-level dictionary.  We keep an\n+     array of type name prefixes and the corresponding ctf_dynhash to use.\n+     NOTE: This code must be kept in sync with the code in ctf_bufopen().  */\n+\n+  fp->ctf_lookups[0].ctl_hash = fp->ctf_structs;\n+  fp->ctf_lookups[1].ctl_hash = fp->ctf_unions;\n+  fp->ctf_lookups[2].ctl_hash = fp->ctf_enums;\n+  fp->ctf_lookups[3].ctl_hash = fp->ctf_names;\n+\n+  nfp->ctf_refcnt = 1;\t\t/* Force nfp to be freed.  */\n+  ctf_file_close (nfp);\n+\n+  return 0;\n+}\n+\n+static char *\n+ctf_prefixed_name (int kind, const char *name)\n+{\n+  char *prefixed;\n+\n+  switch (kind)\n+    {\n+    case CTF_K_STRUCT:\n+      prefixed = ctf_strdup (\"struct \");\n+      break;\n+    case CTF_K_UNION:\n+      prefixed = ctf_strdup (\"union \");\n+      break;\n+    case CTF_K_ENUM:\n+      prefixed = ctf_strdup (\"enum \");\n+      break;\n+    default:\n+      prefixed = ctf_strdup (\"\");\n+    }\n+\n+  prefixed = ctf_str_append (prefixed, name);\n+  return prefixed;\n+}\n+\n+void\n+ctf_dtd_insert (ctf_file_t *fp, ctf_dtdef_t *dtd)\n+{\n+  ctf_dynhash_insert (fp->ctf_dthash, (void *) dtd->dtd_type, dtd);\n+  ctf_list_append (&fp->ctf_dtdefs, dtd);\n+  if (dtd->dtd_name)\n+    {\n+      int kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+      ctf_dynhash_insert (fp->ctf_dtbyname, ctf_prefixed_name (kind,\n+\t\t\t\t\t\t\t       dtd->dtd_name),\n+\t\t\t  dtd);\n+    }\n+}\n+\n+void\n+ctf_dtd_delete (ctf_file_t *fp, ctf_dtdef_t *dtd)\n+{\n+  ctf_dmdef_t *dmd, *nmd;\n+  int kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+\n+  ctf_dynhash_remove (fp->ctf_dthash, (void *) dtd->dtd_type);\n+\n+  switch (kind)\n+    {\n+    case CTF_K_STRUCT:\n+    case CTF_K_UNION:\n+    case CTF_K_ENUM:\n+      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t   dmd != NULL; dmd = nmd)\n+\t{\n+\t  if (dmd->dmd_name != NULL)\n+\t    {\n+\t      fp->ctf_dtvstrlen -= strlen (dmd->dmd_name) + 1;\n+\t      ctf_free (dmd->dmd_name);\n+\t    }\n+\t  nmd = ctf_list_next (dmd);\n+\t  ctf_free (dmd);\n+\t}\n+      break;\n+    case CTF_K_FUNCTION:\n+      ctf_free (dtd->dtd_u.dtu_argv);\n+      break;\n+    }\n+\n+  if (dtd->dtd_name)\n+    {\n+      char *name;\n+\n+      name = ctf_prefixed_name (kind, dtd->dtd_name);\n+      ctf_dynhash_remove (fp->ctf_dtbyname, name);\n+      free (name);\n+\n+      fp->ctf_dtvstrlen -= strlen (dtd->dtd_name) + 1;\n+      ctf_free (dtd->dtd_name);\n+    }\n+\n+  ctf_list_delete (&fp->ctf_dtdefs, dtd);\n+  ctf_free (dtd);\n+}\n+\n+ctf_dtdef_t *\n+ctf_dtd_lookup (const ctf_file_t *fp, ctf_id_t type)\n+{\n+  return (ctf_dtdef_t *) ctf_dynhash_lookup (fp->ctf_dthash, (void *) type);\n+}\n+\n+static ctf_id_t\n+ctf_dtd_lookup_type_by_name (ctf_file_t *fp, int kind, const char *name)\n+{\n+  ctf_dtdef_t *dtd;\n+  char *decorated = ctf_prefixed_name (kind, name);\n+\n+  dtd = (ctf_dtdef_t *) ctf_dynhash_lookup (fp->ctf_dtbyname, decorated);\n+  free (decorated);\n+\n+  if (dtd)\n+    return dtd->dtd_type;\n+\n+  return 0;\n+}\n+\n+ctf_dtdef_t *\n+ctf_dynamic_type (const ctf_file_t *fp, ctf_id_t id)\n+{\n+  ctf_id_t idx;\n+\n+  if ((fp->ctf_flags & LCTF_CHILD) && LCTF_TYPE_ISPARENT (fp, id))\n+    fp = fp->ctf_parent;\n+\n+  idx = LCTF_TYPE_TO_INDEX(fp, id);\n+\n+  if (((unsigned long) idx > fp->ctf_typemax) &&\n+      ((unsigned long) idx < fp->ctf_dtnextid))\n+    return ctf_dtd_lookup (fp, id);\n+  return NULL;\n+}\n+\n+void\n+ctf_dvd_insert (ctf_file_t *fp, ctf_dvdef_t *dvd)\n+{\n+  ctf_dynhash_insert (fp->ctf_dvhash, dvd->dvd_name, dvd);\n+  ctf_list_append (&fp->ctf_dvdefs, dvd);\n+}\n+\n+void\n+ctf_dvd_delete (ctf_file_t *fp, ctf_dvdef_t *dvd)\n+{\n+  ctf_dynhash_remove (fp->ctf_dvhash, dvd->dvd_name);\n+\n+  fp->ctf_dtvstrlen -= strlen (dvd->dvd_name) + 1;\n+  ctf_free (dvd->dvd_name);\n+\n+  ctf_list_delete (&fp->ctf_dvdefs, dvd);\n+  ctf_free (dvd);\n+}\n+\n+ctf_dvdef_t *\n+ctf_dvd_lookup (const ctf_file_t *fp, const char *name)\n+{\n+  return (ctf_dvdef_t *) ctf_dynhash_lookup (fp->ctf_dvhash, name);\n+}\n+\n+/* Discard all of the dynamic type definitions and variable definitions that\n+   have been added to the container since the last call to ctf_update().  We\n+   locate such types by scanning the dtd list and deleting elements that have\n+   type IDs greater than ctf_dtoldid, which is set by ctf_update(), above, and\n+   by scanning the variable list and deleting elements that have update IDs\n+   equal to the current value of the last-update snapshot count (indicating that\n+   they were added after the most recent call to ctf_update()).  */\n+int\n+ctf_discard (ctf_file_t *fp)\n+{\n+  ctf_snapshot_id_t last_update =\n+    { fp->ctf_dtoldid,\n+      fp->ctf_snapshot_lu + 1 };\n+\n+  /* Update required?  */\n+  if (!(fp->ctf_flags & LCTF_DIRTY))\n+    return 0;\n+\n+  return (ctf_rollback (fp, last_update));\n+}\n+\n+ctf_snapshot_id_t\n+ctf_snapshot (ctf_file_t *fp)\n+{\n+  ctf_snapshot_id_t snapid;\n+  snapid.dtd_id = fp->ctf_dtnextid - 1;\n+  snapid.snapshot_id = fp->ctf_snapshots++;\n+  return snapid;\n+}\n+\n+/* Like ctf_discard(), only discards everything after a particular ID.  */\n+int\n+ctf_rollback (ctf_file_t *fp, ctf_snapshot_id_t id)\n+{\n+  ctf_dtdef_t *dtd, *ntd;\n+  ctf_dvdef_t *dvd, *nvd;\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  if (fp->ctf_dtoldid > id.dtd_id)\n+    return (ctf_set_errno (fp, ECTF_OVERROLLBACK));\n+\n+  if (fp->ctf_snapshot_lu >= id.snapshot_id)\n+    return (ctf_set_errno (fp, ECTF_OVERROLLBACK));\n+\n+  for (dtd = ctf_list_next (&fp->ctf_dtdefs); dtd != NULL; dtd = ntd)\n+    {\n+      ntd = ctf_list_next (dtd);\n+\n+      if (LCTF_TYPE_TO_INDEX (fp, dtd->dtd_type) <= id.dtd_id)\n+\tcontinue;\n+\n+      ctf_dtd_delete (fp, dtd);\n+    }\n+\n+  for (dvd = ctf_list_next (&fp->ctf_dvdefs); dvd != NULL; dvd = nvd)\n+    {\n+      nvd = ctf_list_next (dvd);\n+\n+      if (dvd->dvd_snapshots <= id.snapshot_id)\n+\tcontinue;\n+\n+      ctf_dvd_delete (fp, dvd);\n+    }\n+\n+  fp->ctf_dtnextid = id.dtd_id + 1;\n+  fp->ctf_snapshots = id.snapshot_id;\n+\n+  if (fp->ctf_snapshots == fp->ctf_snapshot_lu)\n+    fp->ctf_flags &= ~LCTF_DIRTY;\n+\n+  return 0;\n+}\n+\n+static ctf_id_t\n+ctf_add_generic (ctf_file_t *fp, uint32_t flag, const char *name,\n+\t\t ctf_dtdef_t **rp)\n+{\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type;\n+  char *s = NULL;\n+\n+  if (flag != CTF_ADD_NONROOT && flag != CTF_ADD_ROOT)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  if (LCTF_INDEX_TO_TYPE (fp, fp->ctf_dtnextid, 1) > CTF_MAX_TYPE)\n+    return (ctf_set_errno (fp, ECTF_FULL));\n+\n+  if (LCTF_INDEX_TO_TYPE (fp, fp->ctf_dtnextid, 1) == CTF_MAX_PTYPE)\n+    return (ctf_set_errno (fp, ECTF_FULL));\n+\n+  if ((dtd = ctf_alloc (sizeof (ctf_dtdef_t))) == NULL)\n+    return (ctf_set_errno (fp, EAGAIN));\n+\n+  if (name != NULL && (s = ctf_strdup (name)) == NULL)\n+    {\n+      ctf_free (dtd);\n+      return (ctf_set_errno (fp, EAGAIN));\n+    }\n+\n+  type = fp->ctf_dtnextid++;\n+  type = LCTF_INDEX_TO_TYPE (fp, type, (fp->ctf_flags & LCTF_CHILD));\n+\n+  memset (dtd, 0, sizeof (ctf_dtdef_t));\n+  dtd->dtd_name = s;\n+  dtd->dtd_type = type;\n+\n+  if (s != NULL)\n+    fp->ctf_dtvstrlen += strlen (s) + 1;\n+\n+  ctf_dtd_insert (fp, dtd);\n+  fp->ctf_flags |= LCTF_DIRTY;\n+\n+  *rp = dtd;\n+  return type;\n+}\n+\n+/* When encoding integer sizes, we want to convert a byte count in the range\n+   1-8 to the closest power of 2 (e.g. 3->4, 5->8, etc).  The clp2() function\n+   is a clever implementation from \"Hacker's Delight\" by Henry Warren, Jr.  */\n+static size_t\n+clp2 (size_t x)\n+{\n+  x--;\n+\n+  x |= (x >> 1);\n+  x |= (x >> 2);\n+  x |= (x >> 4);\n+  x |= (x >> 8);\n+  x |= (x >> 16);\n+\n+  return (x + 1);\n+}\n+\n+static ctf_id_t\n+ctf_add_encoded (ctf_file_t *fp, uint32_t flag,\n+\t\t const char *name, const ctf_encoding_t *ep, uint32_t kind)\n+{\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type;\n+\n+  if (ep == NULL)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, flag, 0);\n+  dtd->dtd_data.ctt_size = clp2 (P2ROUNDUP (ep->cte_bits, NBBY) / NBBY);\n+  dtd->dtd_u.dtu_enc = *ep;\n+\n+  return type;\n+}\n+\n+static ctf_id_t\n+ctf_add_reftype (ctf_file_t *fp, uint32_t flag, ctf_id_t ref, uint32_t kind)\n+{\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type;\n+  ctf_file_t *tmp = fp;\n+\n+  if (ref == CTF_ERR || ref < 0 || ref > CTF_MAX_TYPE)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if (ctf_lookup_by_id (&tmp, ref) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((type = ctf_add_generic (fp, flag, NULL, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, flag, 0);\n+  dtd->dtd_data.ctt_type = (uint32_t) ref;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_slice (ctf_file_t *fp, uint32_t flag, ctf_id_t ref,\n+\t       const ctf_encoding_t *ep)\n+{\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type;\n+  int kind;\n+  const ctf_type_t *tp;\n+  ctf_file_t *tmp = fp;\n+\n+  if (ep == NULL)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if ((ep->cte_bits > 255) || (ep->cte_offset > 255))\n+    return (ctf_set_errno (fp, ECTF_SLICEOVERFLOW));\n+\n+  if (ref == CTF_ERR || ref < 0 || ref > CTF_MAX_TYPE)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if ((tp = ctf_lookup_by_id (&tmp, ref)) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  kind = ctf_type_kind_unsliced (tmp, ref);\n+  if ((kind != CTF_K_INTEGER) && (kind != CTF_K_FLOAT) &&\n+      (kind != CTF_K_ENUM))\n+    return (ctf_set_errno (fp, ECTF_NOTINTFP));\n+\n+  if ((type = ctf_add_generic (fp, flag, NULL, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_SLICE, flag, 0);\n+  dtd->dtd_data.ctt_size = clp2 (P2ROUNDUP (ep->cte_bits, NBBY) / NBBY);\n+  dtd->dtd_u.dtu_slice.cts_type = ref;\n+  dtd->dtd_u.dtu_slice.cts_bits = ep->cte_bits;\n+  dtd->dtd_u.dtu_slice.cts_offset = ep->cte_offset;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_integer (ctf_file_t *fp, uint32_t flag,\n+\t\t const char *name, const ctf_encoding_t *ep)\n+{\n+  return (ctf_add_encoded (fp, flag, name, ep, CTF_K_INTEGER));\n+}\n+\n+ctf_id_t\n+ctf_add_float (ctf_file_t *fp, uint32_t flag,\n+\t       const char *name, const ctf_encoding_t *ep)\n+{\n+  return (ctf_add_encoded (fp, flag, name, ep, CTF_K_FLOAT));\n+}\n+\n+ctf_id_t\n+ctf_add_pointer (ctf_file_t *fp, uint32_t flag, ctf_id_t ref)\n+{\n+  return (ctf_add_reftype (fp, flag, ref, CTF_K_POINTER));\n+}\n+\n+ctf_id_t\n+ctf_add_array (ctf_file_t *fp, uint32_t flag, const ctf_arinfo_t *arp)\n+{\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type;\n+  ctf_file_t *tmp = fp;\n+\n+  if (arp == NULL)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if (ctf_lookup_by_id (&tmp, arp->ctr_contents) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  tmp = fp;\n+  if (ctf_lookup_by_id (&tmp, arp->ctr_index) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((type = ctf_add_generic (fp, flag, NULL, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_ARRAY, flag, 0);\n+  dtd->dtd_data.ctt_size = 0;\n+  dtd->dtd_u.dtu_arr = *arp;\n+\n+  return type;\n+}\n+\n+int\n+ctf_set_array (ctf_file_t *fp, ctf_id_t type, const ctf_arinfo_t *arp)\n+{\n+  ctf_dtdef_t *dtd = ctf_dtd_lookup (fp, type);\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  if (dtd == NULL\n+      || LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info) != CTF_K_ARRAY)\n+    return (ctf_set_errno (fp, ECTF_BADID));\n+\n+  fp->ctf_flags |= LCTF_DIRTY;\n+  dtd->dtd_u.dtu_arr = *arp;\n+\n+  return 0;\n+}\n+\n+ctf_id_t\n+ctf_add_function (ctf_file_t *fp, uint32_t flag,\n+\t\t  const ctf_funcinfo_t *ctc, const ctf_id_t *argv)\n+{\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type;\n+  uint32_t vlen;\n+  ctf_id_t *vdat = NULL;\n+  ctf_file_t *tmp = fp;\n+  size_t i;\n+\n+  if (ctc == NULL || (ctc->ctc_flags & ~CTF_FUNC_VARARG) != 0\n+      || (ctc->ctc_argc != 0 && argv == NULL))\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  vlen = ctc->ctc_argc;\n+  if (ctc->ctc_flags & CTF_FUNC_VARARG)\n+    vlen++;\t       /* Add trailing zero to indicate varargs (see below).  */\n+\n+  if (ctf_lookup_by_id (&tmp, ctc->ctc_return) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  for (i = 0; i < ctc->ctc_argc; i++)\n+    {\n+      tmp = fp;\n+      if (ctf_lookup_by_id (&tmp, argv[i]) == NULL)\n+\treturn CTF_ERR;\t\t/* errno is set for us.  */\n+    }\n+\n+  if (vlen > CTF_MAX_VLEN)\n+    return (ctf_set_errno (fp, EOVERFLOW));\n+\n+  if (vlen != 0 && (vdat = ctf_alloc (sizeof (ctf_id_t) * vlen)) == NULL)\n+    return (ctf_set_errno (fp, EAGAIN));\n+\n+  if ((type = ctf_add_generic (fp, flag, NULL, &dtd)) == CTF_ERR)\n+    {\n+      ctf_free (vdat);\n+      return CTF_ERR;\t\t   /* errno is set for us.  */\n+    }\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_FUNCTION, flag, vlen);\n+  dtd->dtd_data.ctt_type = (uint32_t) ctc->ctc_return;\n+\n+  memcpy (vdat, argv, sizeof (ctf_id_t) * ctc->ctc_argc);\n+  if (ctc->ctc_flags & CTF_FUNC_VARARG)\n+    vdat[vlen - 1] = 0;\t\t   /* Add trailing zero to indicate varargs.  */\n+  dtd->dtd_u.dtu_argv = vdat;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_struct_sized (ctf_file_t *fp, uint32_t flag, const char *name,\n+\t\t      size_t size)\n+{\n+  ctf_hash_t *hp = fp->ctf_structs;\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type = 0;\n+\n+  /* Promote forwards to structs.  */\n+\n+  if (name != NULL)\n+    {\n+      type = ctf_hash_lookup_type (hp, fp, name);\n+      if (type == 0)\n+\ttype = ctf_dtd_lookup_type_by_name (fp, CTF_K_STRUCT, name);\n+    }\n+\n+  if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n+    dtd = ctf_dtd_lookup (fp, type);\n+  else if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_STRUCT, flag, 0);\n+\n+  if (size > CTF_MAX_SIZE)\n+    {\n+      dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n+      dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n+      dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n+    }\n+  else\n+    dtd->dtd_data.ctt_size = (uint32_t) size;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_struct (ctf_file_t *fp, uint32_t flag, const char *name)\n+{\n+  return (ctf_add_struct_sized (fp, flag, name, 0));\n+}\n+\n+ctf_id_t\n+ctf_add_union_sized (ctf_file_t *fp, uint32_t flag, const char *name,\n+\t\t     size_t size)\n+{\n+  ctf_hash_t *hp = fp->ctf_unions;\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type = 0;\n+\n+  /* Promote forwards to unions.  */\n+  if (name != NULL)\n+    {\n+      type = ctf_hash_lookup_type (hp, fp, name);\n+      if (type == 0)\n+\ttype = ctf_dtd_lookup_type_by_name (fp, CTF_K_UNION, name);\n+    }\n+\n+  if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n+    dtd = ctf_dtd_lookup (fp, type);\n+  else if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_UNION, flag, 0);\n+\n+  if (size > CTF_MAX_SIZE)\n+    {\n+      dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n+      dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n+      dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n+    }\n+  else\n+    dtd->dtd_data.ctt_size = (uint32_t) size;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_union (ctf_file_t *fp, uint32_t flag, const char *name)\n+{\n+  return (ctf_add_union_sized (fp, flag, name, 0));\n+}\n+\n+ctf_id_t\n+ctf_add_enum (ctf_file_t *fp, uint32_t flag, const char *name)\n+{\n+  ctf_hash_t *hp = fp->ctf_enums;\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type = 0;\n+\n+  /* Promote forwards to enums.  */\n+  if (name != NULL)\n+    {\n+      type = ctf_hash_lookup_type (hp, fp, name);\n+      if (type == 0)\n+\ttype = ctf_dtd_lookup_type_by_name (fp, CTF_K_ENUM, name);\n+    }\n+\n+  if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n+    dtd = ctf_dtd_lookup (fp, type);\n+  else if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_ENUM, flag, 0);\n+  dtd->dtd_data.ctt_size = fp->ctf_dmodel->ctd_int;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_enum_encoded (ctf_file_t *fp, uint32_t flag, const char *name,\n+\t\t      const ctf_encoding_t *ep)\n+{\n+  ctf_hash_t *hp = fp->ctf_enums;\n+  ctf_id_t type = 0;\n+\n+  /* First, create the enum if need be, using most of the same machinery as\n+     ctf_add_enum(), to ensure that we do not allow things past that are not\n+     enums or forwards to them.  (This includes other slices: you cannot slice a\n+     slice, which would be a useless thing to do anyway.)  */\n+\n+  if (name != NULL)\n+    {\n+      type = ctf_hash_lookup_type (hp, fp, name);\n+      if (type == 0)\n+\ttype = ctf_dtd_lookup_type_by_name (fp, CTF_K_ENUM, name);\n+    }\n+\n+  if (type != 0)\n+    {\n+      if ((ctf_type_kind (fp, type) != CTF_K_FORWARD) &&\n+\t  (ctf_type_kind_unsliced (fp, type) != CTF_K_ENUM))\n+\treturn (ctf_set_errno (fp, ECTF_NOTINTFP));\n+    }\n+  else if ((type = ctf_add_enum (fp, flag, name)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  /* Now attach a suitable slice to it.  */\n+\n+  return ctf_add_slice (fp, flag, type, ep);\n+}\n+\n+ctf_id_t\n+ctf_add_forward (ctf_file_t *fp, uint32_t flag, const char *name,\n+\t\t uint32_t kind)\n+{\n+  ctf_hash_t *hp;\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type = 0;\n+\n+  switch (kind)\n+    {\n+    case CTF_K_STRUCT:\n+      hp = fp->ctf_structs;\n+      break;\n+    case CTF_K_UNION:\n+      hp = fp->ctf_unions;\n+      break;\n+    case CTF_K_ENUM:\n+      hp = fp->ctf_enums;\n+      break;\n+    default:\n+      return (ctf_set_errno (fp, ECTF_NOTSUE));\n+    }\n+\n+  /* If the type is already defined or exists as a forward tag, just\n+     return the ctf_id_t of the existing definition.  */\n+\n+  if (name != NULL)\n+    {\n+      if (((type = ctf_hash_lookup_type (hp, fp, name)) != 0)\n+\t  || (type = ctf_dtd_lookup_type_by_name (fp, kind, name)) != 0)\n+\treturn type;\n+    }\n+\n+  if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_FORWARD, flag, 0);\n+  dtd->dtd_data.ctt_type = kind;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_typedef (ctf_file_t *fp, uint32_t flag, const char *name,\n+\t\t ctf_id_t ref)\n+{\n+  ctf_dtdef_t *dtd;\n+  ctf_id_t type;\n+  ctf_file_t *tmp = fp;\n+\n+  if (ref == CTF_ERR || ref < 0 || ref > CTF_MAX_TYPE)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if (ctf_lookup_by_id (&tmp, ref) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((type = ctf_add_generic (fp, flag, name, &dtd)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_TYPEDEF, flag, 0);\n+  dtd->dtd_data.ctt_type = (uint32_t) ref;\n+\n+  return type;\n+}\n+\n+ctf_id_t\n+ctf_add_volatile (ctf_file_t *fp, uint32_t flag, ctf_id_t ref)\n+{\n+  return (ctf_add_reftype (fp, flag, ref, CTF_K_VOLATILE));\n+}\n+\n+ctf_id_t\n+ctf_add_const (ctf_file_t *fp, uint32_t flag, ctf_id_t ref)\n+{\n+  return (ctf_add_reftype (fp, flag, ref, CTF_K_CONST));\n+}\n+\n+ctf_id_t\n+ctf_add_restrict (ctf_file_t *fp, uint32_t flag, ctf_id_t ref)\n+{\n+  return (ctf_add_reftype (fp, flag, ref, CTF_K_RESTRICT));\n+}\n+\n+int\n+ctf_add_enumerator (ctf_file_t *fp, ctf_id_t enid, const char *name,\n+\t\t    int value)\n+{\n+  ctf_dtdef_t *dtd = ctf_dtd_lookup (fp, enid);\n+  ctf_dmdef_t *dmd;\n+\n+  uint32_t kind, vlen, root;\n+  char *s;\n+\n+  if (name == NULL)\n+    return (ctf_set_errno (fp, EINVAL));\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  if (dtd == NULL)\n+    return (ctf_set_errno (fp, ECTF_BADID));\n+\n+  kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+  root = LCTF_INFO_ISROOT (fp, dtd->dtd_data.ctt_info);\n+  vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n+\n+  if (kind != CTF_K_ENUM)\n+    return (ctf_set_errno (fp, ECTF_NOTENUM));\n+\n+  if (vlen == CTF_MAX_VLEN)\n+    return (ctf_set_errno (fp, ECTF_DTFULL));\n+\n+  for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+       dmd != NULL; dmd = ctf_list_next (dmd))\n+    {\n+      if (strcmp (dmd->dmd_name, name) == 0)\n+\treturn (ctf_set_errno (fp, ECTF_DUPLICATE));\n+    }\n+\n+  if ((dmd = ctf_alloc (sizeof (ctf_dmdef_t))) == NULL)\n+    return (ctf_set_errno (fp, EAGAIN));\n+\n+  if ((s = ctf_strdup (name)) == NULL)\n+    {\n+      ctf_free (dmd);\n+      return (ctf_set_errno (fp, EAGAIN));\n+    }\n+\n+  dmd->dmd_name = s;\n+  dmd->dmd_type = CTF_ERR;\n+  dmd->dmd_offset = 0;\n+  dmd->dmd_value = value;\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, root, vlen + 1);\n+  ctf_list_append (&dtd->dtd_u.dtu_members, dmd);\n+\n+  fp->ctf_dtvstrlen += strlen (s) + 1;\n+  fp->ctf_flags |= LCTF_DIRTY;\n+\n+  return 0;\n+}\n+\n+int\n+ctf_add_member_offset (ctf_file_t *fp, ctf_id_t souid, const char *name,\n+\t\t       ctf_id_t type, unsigned long bit_offset)\n+{\n+  ctf_dtdef_t *dtd = ctf_dtd_lookup (fp, souid);\n+  ctf_dmdef_t *dmd;\n+\n+  ssize_t msize, malign, ssize;\n+  uint32_t kind, vlen, root;\n+  char *s = NULL;\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  if (dtd == NULL)\n+    return (ctf_set_errno (fp, ECTF_BADID));\n+\n+  kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+  root = LCTF_INFO_ISROOT (fp, dtd->dtd_data.ctt_info);\n+  vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n+\n+  if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n+    return (ctf_set_errno (fp, ECTF_NOTSOU));\n+\n+  if (vlen == CTF_MAX_VLEN)\n+    return (ctf_set_errno (fp, ECTF_DTFULL));\n+\n+  if (name != NULL)\n+    {\n+      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\t   dmd != NULL; dmd = ctf_list_next (dmd))\n+\t{\n+\t  if (dmd->dmd_name != NULL && strcmp (dmd->dmd_name, name) == 0)\n+\t    return (ctf_set_errno (fp, ECTF_DUPLICATE));\n+\t}\n+    }\n+\n+  if ((msize = ctf_type_size (fp, type)) == CTF_ERR ||\n+      (malign = ctf_type_align (fp, type)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((dmd = ctf_alloc (sizeof (ctf_dmdef_t))) == NULL)\n+    return (ctf_set_errno (fp, EAGAIN));\n+\n+  if (name != NULL && (s = ctf_strdup (name)) == NULL)\n+    {\n+      ctf_free (dmd);\n+      return (ctf_set_errno (fp, EAGAIN));\n+    }\n+\n+  dmd->dmd_name = s;\n+  dmd->dmd_type = type;\n+  dmd->dmd_value = -1;\n+\n+  if (kind == CTF_K_STRUCT && vlen != 0)\n+    {\n+      if (bit_offset == (unsigned long) - 1)\n+\t{\n+\t  /* Natural alignment.  */\n+\n+\t  ctf_dmdef_t *lmd = ctf_list_prev (&dtd->dtd_u.dtu_members);\n+\t  ctf_id_t ltype = ctf_type_resolve (fp, lmd->dmd_type);\n+\t  size_t off = lmd->dmd_offset;\n+\n+\t  ctf_encoding_t linfo;\n+\t  ssize_t lsize;\n+\n+\t  if (ctf_type_encoding (fp, ltype, &linfo) != CTF_ERR)\n+\t    off += linfo.cte_bits;\n+\t  else if ((lsize = ctf_type_size (fp, ltype)) != CTF_ERR)\n+\t    off += lsize * NBBY;\n+\n+\t  /* Round up the offset of the end of the last member to\n+\t     the next byte boundary, convert 'off' to bytes, and\n+\t     then round it up again to the next multiple of the\n+\t     alignment required by the new member.  Finally,\n+\t     convert back to bits and store the result in\n+\t     dmd_offset.  Technically we could do more efficient\n+\t     packing if the new member is a bit-field, but we're\n+\t     the \"compiler\" and ANSI says we can do as we choose.  */\n+\n+\t  off = roundup (off, NBBY) / NBBY;\n+\t  off = roundup (off, MAX (malign, 1));\n+\t  dmd->dmd_offset = off * NBBY;\n+\t  ssize = off + msize;\n+\t}\n+      else\n+\t{\n+\t  /* Specified offset in bits.  */\n+\n+\t  dmd->dmd_offset = bit_offset;\n+\t  ssize = ctf_get_ctt_size (fp, &dtd->dtd_data, NULL, NULL);\n+\t  ssize = MAX (ssize, (bit_offset / NBBY) + msize);\n+\t}\n+    }\n+  else\n+    {\n+      dmd->dmd_offset = 0;\n+      ssize = ctf_get_ctt_size (fp, &dtd->dtd_data, NULL, NULL);\n+      ssize = MAX (ssize, msize);\n+    }\n+\n+  if (ssize > CTF_MAX_SIZE)\n+    {\n+      dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n+      dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (ssize);\n+      dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (ssize);\n+    }\n+  else\n+    dtd->dtd_data.ctt_size = (uint32_t) ssize;\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, root, vlen + 1);\n+  ctf_list_append (&dtd->dtd_u.dtu_members, dmd);\n+\n+  if (s != NULL)\n+    fp->ctf_dtvstrlen += strlen (s) + 1;\n+\n+  fp->ctf_flags |= LCTF_DIRTY;\n+  return 0;\n+}\n+\n+int\n+ctf_add_member_encoded (ctf_file_t *fp, ctf_id_t souid, const char *name,\n+\t\t\tctf_id_t type, unsigned long bit_offset,\n+\t\t\tconst ctf_encoding_t encoding)\n+{\n+  ctf_dtdef_t *dtd = ctf_dtd_lookup (fp, type);\n+  int kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n+  int otype = type;\n+\n+  if ((kind != CTF_K_INTEGER) && (kind != CTF_K_FLOAT) && (kind != CTF_K_ENUM))\n+    return (ctf_set_errno (fp, ECTF_NOTINTFP));\n+\n+  if ((type = ctf_add_slice (fp, CTF_ADD_NONROOT, otype, &encoding)) == CTF_ERR)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  return ctf_add_member_offset (fp, souid, name, type, bit_offset);\n+}\n+\n+int\n+ctf_add_member (ctf_file_t *fp, ctf_id_t souid, const char *name,\n+\t\tctf_id_t type)\n+{\n+  return ctf_add_member_offset (fp, souid, name, type, (unsigned long) - 1);\n+}\n+\n+int\n+ctf_add_variable (ctf_file_t *fp, const char *name, ctf_id_t ref)\n+{\n+  ctf_dvdef_t *dvd;\n+  ctf_file_t *tmp = fp;\n+\n+  if (!(fp->ctf_flags & LCTF_RDWR))\n+    return (ctf_set_errno (fp, ECTF_RDONLY));\n+\n+  if (ctf_dvd_lookup (fp, name) != NULL)\n+    return (ctf_set_errno (fp, ECTF_DUPLICATE));\n+\n+  if (ctf_lookup_by_id (&tmp, ref) == NULL)\n+    return CTF_ERR;\t\t/* errno is set for us.  */\n+\n+  if ((dvd = ctf_alloc (sizeof (ctf_dvdef_t))) == NULL)\n+    return (ctf_set_errno (fp, EAGAIN));\n+\n+  if (name != NULL && (dvd->dvd_name = ctf_strdup (name)) == NULL)\n+    {\n+      ctf_free (dvd);\n+      return (ctf_set_errno (fp, EAGAIN));\n+    }\n+  dvd->dvd_type = ref;\n+  dvd->dvd_snapshots = fp->ctf_snapshots;\n+\n+  ctf_dvd_insert (fp, dvd);\n+\n+  fp->ctf_dtvstrlen += strlen (name) + 1;\n+  fp->ctf_flags |= LCTF_DIRTY;\n+  return 0;\n+}\n+\n+/* Write the compressed CTF data stream to the specified gzFile descriptor.\n+   This is useful for saving the results of dynamic CTF containers.  */\n+int\n+ctf_gzwrite (ctf_file_t *fp, gzFile fd)\n+{\n+  const unsigned char *buf = fp->ctf_base;\n+  ssize_t resid = fp->ctf_size;\n+  ssize_t len;\n+\n+  while (resid != 0)\n+    {\n+      if ((len = gzwrite (fd, buf, resid)) <= 0)\n+\treturn (ctf_set_errno (fp, errno));\n+      resid -= len;\n+      buf += len;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Compress the specified CTF data stream and write it to the specified file\n+   descriptor.  */\n+int\n+ctf_compress_write (ctf_file_t *fp, int fd)\n+{\n+  unsigned char *buf;\n+  unsigned char *bp;\n+  ctf_header_t h;\n+  ctf_header_t *hp = &h;\n+  ssize_t header_len = sizeof (ctf_header_t);\n+  ssize_t compress_len;\n+  size_t max_compress_len = compressBound (fp->ctf_size - header_len);\n+  ssize_t len;\n+  int rc;\n+  int err = 0;\n+\n+  memcpy (hp, fp->ctf_base, header_len);\n+  hp->cth_flags |= CTF_F_COMPRESS;\n+\n+  if ((buf = ctf_data_alloc (max_compress_len)) == NULL)\n+    return (ctf_set_errno (fp, ECTF_ZALLOC));\n+\n+  compress_len = max_compress_len;\n+  if ((rc = compress (buf, (uLongf *) & compress_len,\n+\t\t      fp->ctf_base + header_len,\n+\t\t      fp->ctf_size - header_len)) != Z_OK)\n+    {\n+      ctf_dprintf (\"zlib deflate err: %s\\n\", zError (rc));\n+      err = ctf_set_errno (fp, ECTF_COMPRESS);\n+      goto ret;\n+    }\n+\n+  while (header_len > 0)\n+    {\n+      if ((len = write (fd, hp, header_len)) < 0)\n+\t{\n+\t  err = ctf_set_errno (fp, errno);\n+\t  goto ret;\n+\t}\n+      header_len -= len;\n+      hp += len;\n+    }\n+\n+  bp = buf;\n+  while (compress_len > 0)\n+    {\n+      if ((len = write (fd, bp, compress_len)) < 0)\n+\t{\n+\t  err = ctf_set_errno (fp, errno);\n+\t  goto ret;\n+\t}\n+      compress_len -= len;\n+      bp += len;\n+    }\n+\n+ret:\n+  ctf_data_free (buf, max_compress_len);\n+  return err;\n+}\n+\n+/* Write the uncompressed CTF data stream to the specified file descriptor.\n+   This is useful for saving the results of dynamic CTF containers.  */\n+int\n+ctf_write (ctf_file_t *fp, int fd)\n+{\n+  const unsigned char *buf = fp->ctf_base;\n+  ssize_t resid = fp->ctf_size;\n+  ssize_t len;\n+\n+  while (resid != 0)\n+    {\n+      if ((len = write (fd, buf, resid)) < 0)\n+\treturn (ctf_set_errno (fp, errno));\n+      resid -= len;\n+      buf += len;\n+    }\n+\n+  return 0;\n+}"
    },
    {
      "sha": "e76afb6e0afa1c23f3ade4c57a20b36a3040e8cd",
      "filename": "libctf/ctf-lookup.c",
      "status": "added",
      "additions": 63,
      "deletions": 0,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/47d546f427d0d3bf9f503b5b118ae05b49d73d28/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/47d546f427d0d3bf9f503b5b118ae05b49d73d28/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=47d546f427d0d3bf9f503b5b118ae05b49d73d28",
      "patch": "@@ -0,0 +1,63 @@\n+/* Type lookup.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <elf.h>\n+#include <string.h>\n+\n+/* Return the pointer to the internal CTF type data corresponding to the\n+   given type ID.  If the ID is invalid, the function returns NULL.\n+   This function is not exported outside of the library.  */\n+\n+const ctf_type_t *\n+ctf_lookup_by_id (ctf_file_t **fpp, ctf_id_t type)\n+{\n+  ctf_file_t *fp = *fpp;\t/* Caller passes in starting CTF container.  */\n+  ctf_id_t idx;\n+\n+  if ((fp->ctf_flags & LCTF_CHILD) && LCTF_TYPE_ISPARENT (fp, type)\n+      && (fp = fp->ctf_parent) == NULL)\n+    {\n+      (void) ctf_set_errno (*fpp, ECTF_NOPARENT);\n+      return NULL;\n+    }\n+\n+  idx = LCTF_TYPE_TO_INDEX (fp, type);\n+  if (idx > 0 && (unsigned long) idx <= fp->ctf_typemax)\n+    {\n+      *fpp = fp;\t\t/* Function returns ending CTF container.  */\n+      return (LCTF_INDEX_TO_TYPEPTR (fp, idx));\n+    }\n+\n+  /* If this container is writable, check for a dynamic type.  */\n+\n+  if (fp->ctf_flags & LCTF_RDWR)\n+    {\n+      ctf_dtdef_t *dtd;\n+\n+      if ((dtd = ctf_dynamic_type (fp, type)) != NULL)\n+\t{\n+\t  *fpp = fp;\n+\t  return &dtd->dtd_data;\n+\t}\n+    }\n+  (void) ctf_set_errno (*fpp, ECTF_BADID);\n+  return NULL;\n+}\n+"
    }
  ]
}