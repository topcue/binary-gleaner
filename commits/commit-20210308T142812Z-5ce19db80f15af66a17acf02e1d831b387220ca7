{
  "sha": "5ce19db80f15af66a17acf02e1d831b387220ca7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWNlMTlkYjgwZjE1YWY2NmExN2FjZjAyZTFkODMxYjM4NzIyMGNhNw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:12Z"
    },
    "message": "Split out ada_ternop_slice\n\nThis splits TERNOP_SLICE into a new function for future use.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (ada_ternop_slice): New function.\n\t(ada_evaluate_subexp): Use it.",
    "tree": {
      "sha": "b581378777ff5db09bf109dfe549750412df3b31",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b581378777ff5db09bf109dfe549750412df3b31"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5ce19db80f15af66a17acf02e1d831b387220ca7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5ce19db80f15af66a17acf02e1d831b387220ca7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5ce19db80f15af66a17acf02e1d831b387220ca7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5ce19db80f15af66a17acf02e1d831b387220ca7/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "214b13ac3b8f041af4bd643808590955528a1d27",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/214b13ac3b8f041af4bd643808590955528a1d27",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/214b13ac3b8f041af4bd643808590955528a1d27"
    }
  ],
  "stats": {
    "total": 158,
    "additions": 88,
    "deletions": 70
  },
  "files": [
    {
      "sha": "f0c62cf2014ab4184dc6a1822b7e794d626bd933",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ce19db80f15af66a17acf02e1d831b387220ca7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ce19db80f15af66a17acf02e1d831b387220ca7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5ce19db80f15af66a17acf02e1d831b387220ca7",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (ada_ternop_slice): New function.\n+\t(ada_evaluate_subexp): Use it.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ada-lang.c (ada_equal_binop): New function."
    },
    {
      "sha": "c039183373fab6f83689bc8314cfc49e082b1110",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 83,
      "deletions": 70,
      "changes": 153,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5ce19db80f15af66a17acf02e1d831b387220ca7/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5ce19db80f15af66a17acf02e1d831b387220ca7/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=5ce19db80f15af66a17acf02e1d831b387220ca7",
      "patch": "@@ -10107,6 +10107,87 @@ ada_equal_binop (struct type *expect_type,\n   return value_from_longest (type, (LONGEST) tem);\n }\n \n+/* A helper function for TERNOP_SLICE.  */\n+\n+static value *\n+ada_ternop_slice (struct expression *exp,\n+\t\t  enum noside noside,\n+\t\t  struct value *array, struct value *low_bound_val,\n+\t\t  struct value *high_bound_val)\n+{\n+  LONGEST low_bound;\n+  LONGEST high_bound;\n+\n+  low_bound_val = coerce_ref (low_bound_val);\n+  high_bound_val = coerce_ref (high_bound_val);\n+  low_bound = value_as_long (low_bound_val);\n+  high_bound = value_as_long (high_bound_val);\n+\n+  /* If this is a reference to an aligner type, then remove all\n+     the aligners.  */\n+  if (value_type (array)->code () == TYPE_CODE_REF\n+      && ada_is_aligner_type (TYPE_TARGET_TYPE (value_type (array))))\n+    TYPE_TARGET_TYPE (value_type (array)) =\n+      ada_aligned_type (TYPE_TARGET_TYPE (value_type (array)));\n+\n+  if (ada_is_any_packed_array_type (value_type (array)))\n+    error (_(\"cannot slice a packed array\"));\n+\n+  /* If this is a reference to an array or an array lvalue,\n+     convert to a pointer.  */\n+  if (value_type (array)->code () == TYPE_CODE_REF\n+      || (value_type (array)->code () == TYPE_CODE_ARRAY\n+\t  && VALUE_LVAL (array) == lval_memory))\n+    array = value_addr (array);\n+\n+  if (noside == EVAL_AVOID_SIDE_EFFECTS\n+      && ada_is_array_descriptor_type (ada_check_typedef\n+\t\t\t\t       (value_type (array))))\n+    return empty_array (ada_type_of_array (array, 0), low_bound,\n+\t\t\thigh_bound);\n+\n+  array = ada_coerce_to_simple_array_ptr (array);\n+\n+  /* If we have more than one level of pointer indirection,\n+     dereference the value until we get only one level.  */\n+  while (value_type (array)->code () == TYPE_CODE_PTR\n+\t && (TYPE_TARGET_TYPE (value_type (array))->code ()\n+\t     == TYPE_CODE_PTR))\n+    array = value_ind (array);\n+\n+  /* Make sure we really do have an array type before going further,\n+     to avoid a SEGV when trying to get the index type or the target\n+     type later down the road if the debug info generated by\n+     the compiler is incorrect or incomplete.  */\n+  if (!ada_is_simple_array_type (value_type (array)))\n+    error (_(\"cannot take slice of non-array\"));\n+\n+  if (ada_check_typedef (value_type (array))->code ()\n+      == TYPE_CODE_PTR)\n+    {\n+      struct type *type0 = ada_check_typedef (value_type (array));\n+\n+      if (high_bound < low_bound || noside == EVAL_AVOID_SIDE_EFFECTS)\n+\treturn empty_array (TYPE_TARGET_TYPE (type0), low_bound, high_bound);\n+      else\n+\t{\n+\t  struct type *arr_type0 =\n+\t    to_fixed_array_type (TYPE_TARGET_TYPE (type0), NULL, 1);\n+\n+\t  return ada_value_slice_from_ptr (array, arr_type0,\n+\t\t\t\t\t   longest_to_int (low_bound),\n+\t\t\t\t\t   longest_to_int (high_bound));\n+\t}\n+    }\n+  else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n+    return array;\n+  else if (high_bound < low_bound)\n+    return empty_array (value_type (array), low_bound, high_bound);\n+  else\n+    return ada_value_slice (array, longest_to_int (low_bound),\n+\t\t\t    longest_to_int (high_bound));\n+}\n+\n /* Implement the evaluate_exp routine in the exp_descriptor structure\n    for the Ada language.  */\n \n@@ -10548,80 +10629,12 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t  = evaluate_subexp (nullptr, exp, pos, noside);\n \tstruct value *high_bound_val\n \t  = evaluate_subexp (nullptr, exp, pos, noside);\n-\tLONGEST low_bound;\n-\tLONGEST high_bound;\n-\n-\tlow_bound_val = coerce_ref (low_bound_val);\n-\thigh_bound_val = coerce_ref (high_bound_val);\n-\tlow_bound = value_as_long (low_bound_val);\n-\thigh_bound = value_as_long (high_bound_val);\n \n \tif (noside == EVAL_SKIP)\n \t  goto nosideret;\n \n-\t/* If this is a reference to an aligner type, then remove all\n-\t   the aligners.  */\n-\tif (value_type (array)->code () == TYPE_CODE_REF\n-\t    && ada_is_aligner_type (TYPE_TARGET_TYPE (value_type (array))))\n-\t  TYPE_TARGET_TYPE (value_type (array)) =\n-\t    ada_aligned_type (TYPE_TARGET_TYPE (value_type (array)));\n-\n-\tif (ada_is_any_packed_array_type (value_type (array)))\n-\t  error (_(\"cannot slice a packed array\"));\n-\n-\t/* If this is a reference to an array or an array lvalue,\n-\t   convert to a pointer.  */\n-\tif (value_type (array)->code () == TYPE_CODE_REF\n-\t    || (value_type (array)->code () == TYPE_CODE_ARRAY\n-\t\t&& VALUE_LVAL (array) == lval_memory))\n-\t  array = value_addr (array);\n-\n-\tif (noside == EVAL_AVOID_SIDE_EFFECTS\n-\t    && ada_is_array_descriptor_type (ada_check_typedef\n-\t\t\t\t\t     (value_type (array))))\n-\t  return empty_array (ada_type_of_array (array, 0), low_bound,\n-\t\t\t      high_bound);\n-\n-\tarray = ada_coerce_to_simple_array_ptr (array);\n-\n-\t/* If we have more than one level of pointer indirection,\n-\t   dereference the value until we get only one level.  */\n-\twhile (value_type (array)->code () == TYPE_CODE_PTR\n-\t       && (TYPE_TARGET_TYPE (value_type (array))->code ()\n-\t\t     == TYPE_CODE_PTR))\n-\t  array = value_ind (array);\n-\n-\t/* Make sure we really do have an array type before going further,\n-\t   to avoid a SEGV when trying to get the index type or the target\n-\t   type later down the road if the debug info generated by\n-\t   the compiler is incorrect or incomplete.  */\n-\tif (!ada_is_simple_array_type (value_type (array)))\n-\t  error (_(\"cannot take slice of non-array\"));\n-\n-\tif (ada_check_typedef (value_type (array))->code ()\n-\t    == TYPE_CODE_PTR)\n-\t  {\n-\t    struct type *type0 = ada_check_typedef (value_type (array));\n-\n-\t    if (high_bound < low_bound || noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t      return empty_array (TYPE_TARGET_TYPE (type0), low_bound, high_bound);\n-\t    else\n-\t      {\n-\t\tstruct type *arr_type0 =\n-\t\t  to_fixed_array_type (TYPE_TARGET_TYPE (type0), NULL, 1);\n-\n-\t\treturn ada_value_slice_from_ptr (array, arr_type0,\n-\t\t\t\t\t\t longest_to_int (low_bound),\n-\t\t\t\t\t\t longest_to_int (high_bound));\n-\t      }\n-\t  }\n-\telse if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t  return array;\n-\telse if (high_bound < low_bound)\n-\t  return empty_array (value_type (array), low_bound, high_bound);\n-\telse\n-\t  return ada_value_slice (array, longest_to_int (low_bound),\n-\t\t\t\t  longest_to_int (high_bound));\n+\treturn ada_ternop_slice (exp, noside, array, low_bound_val,\n+\t\t\t\t high_bound_val);\n       }\n \n     case UNOP_IN_RANGE:"
    }
  ]
}