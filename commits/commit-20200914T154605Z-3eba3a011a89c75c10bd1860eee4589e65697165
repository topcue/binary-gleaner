{
  "sha": "3eba3a011a89c75c10bd1860eee4589e65697165",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6M2ViYTNhMDExYTg5Yzc1YzEwYmQxODYwZWVlNDU4OWU2NTY5NzE2NQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-09-14T14:30:10Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-09-14T15:46:05Z"
    },
    "message": "Various m68k fixes for gdb\n\nRecently I tried the m68k port of gdb.  It had some issues, which are\nfixed in this patch.\n\n* Various types of return values were not being handled properly.  In\n  particular:\n\n  * arrays are returned by following the same convention as\n    structures.  This matters in languages like Ada, where an array\n    can in fact be returned as a value.\n\n  * \"long double\" was not being handled correctly in\n    m68k_svr4_return_value.\n\n  * GCC's m68k back end does not return vector types in registers, so\n    change gdb to follow.\n\n  * GCC's m68k back end doesn't faithfully implement the ABI, and so\n    some objects with unusual size (not possible in C, but possible in\n    Ada) are not returned correctly.\n\n* gcc implements an m68k ABI variant that it simply describes as\n  \"embedded\".  This ABI is similar to the SVR4 ABI, but rather than\n  returning pointer-typed values in %a0, such values are returned in\n  %d0.  To support this, an ELF osabi sniffer is added.\n\n* Commit 85f7484a (\"m68k: tag floating-point ABI used\") adds an\n  attribute that can be used to recognize when hard- or soft-float is\n  in use.  gdb can now read this tag and choose the ABI accordingly.\n\nI was unable to run the gdb test suite with this patch.  Instead, I\ntested it using qemu and the internal AdaCore test suite.\n\ngdb/ChangeLog\n2020-09-14  Tom Tromey  <tromey@adacore.com>\n\n\t* m68k-tdep.c (m68k_extract_return_value): Use\n\tpointer_result_regnum.\n\t(m68k_store_return_value): Likewise.\n\t(m68k_reg_struct_return_p): Handle vectors and arrays.\n\t(m68k_return_value): Handle arrays.\n\t(m68k_svr4_return_value): Fix single-element aggregate handling.\n\tHandle long double.  Adjust for embedded ABI.\n\t(m68k_svr4_init_abi): Set pointer_result_regnum.\n\t(m68k_embedded_init_abi): New function.\n\t(m68k_gdbarch_init): Handle Tag_GNU_M68K_ABI_FP.\n\t(m68k_osabi_sniffer): New function.\n\t(_initialize_m68k_tdep): Register osabi sniffer.\n\t* m68k-tdep.h (struct gdbarch_tdep) <pointer_result_regnum>: New\n\tmember.",
    "tree": {
      "sha": "9465ab269218fe38dcdcbabc3220940c25817a1f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9465ab269218fe38dcdcbabc3220940c25817a1f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3eba3a011a89c75c10bd1860eee4589e65697165",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3eba3a011a89c75c10bd1860eee4589e65697165",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3eba3a011a89c75c10bd1860eee4589e65697165",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3eba3a011a89c75c10bd1860eee4589e65697165/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "33f4dd48cefa64257880e6d98124c3f3e54f5196",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/33f4dd48cefa64257880e6d98124c3f3e54f5196",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/33f4dd48cefa64257880e6d98124c3f3e54f5196"
    }
  ],
  "stats": {
    "total": 193,
    "additions": 147,
    "deletions": 46
  },
  "files": [
    {
      "sha": "dabc7266dba458759fb1cceedcd698bd00541c69",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3eba3a011a89c75c10bd1860eee4589e65697165/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3eba3a011a89c75c10bd1860eee4589e65697165/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=3eba3a011a89c75c10bd1860eee4589e65697165",
      "patch": "@@ -1,3 +1,20 @@\n+2020-09-14  Tom Tromey  <tromey@adacore.com>\n+\n+\t* m68k-tdep.c (m68k_extract_return_value): Use\n+\tpointer_result_regnum.\n+\t(m68k_store_return_value): Likewise.\n+\t(m68k_reg_struct_return_p): Handle vectors and arrays.\n+\t(m68k_return_value): Handle arrays.\n+\t(m68k_svr4_return_value): Fix single-element aggregate handling.\n+\tHandle long double.  Adjust for embedded ABI.\n+\t(m68k_svr4_init_abi): Set pointer_result_regnum.\n+\t(m68k_embedded_init_abi): New function.\n+\t(m68k_gdbarch_init): Handle Tag_GNU_M68K_ABI_FP.\n+\t(m68k_osabi_sniffer): New function.\n+\t(_initialize_m68k_tdep): Register osabi sniffer.\n+\t* m68k-tdep.h (struct gdbarch_tdep) <pointer_result_regnum>: New\n+\tmember.\n+\n 2020-09-14  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* xml-support.c (xml_fetch_content_from_file): Replace xfree"
    },
    {
      "sha": "7685c5da1bb8bc89ab16750f4b97c9fd36855441",
      "filename": "gdb/m68k-tdep.c",
      "status": "modified",
      "additions": 126,
      "deletions": 46,
      "changes": 172,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3eba3a011a89c75c10bd1860eee4589e65697165/gdb/m68k-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3eba3a011a89c75c10bd1860eee4589e65697165/gdb/m68k-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.c?ref=3eba3a011a89c75c10bd1860eee4589e65697165",
      "patch": "@@ -34,6 +34,8 @@\n #include \"target-descriptions.h\"\n #include \"floatformat.h\"\n #include \"target-float.h\"\n+#include \"elf-bfd.h\"\n+#include \"elf/m68k.h\"\n \n #include \"m68k-tdep.h\"\n \f\n@@ -272,7 +274,12 @@ m68k_value_to_register (struct frame_info *frame, int regnum,\n    %d0/%d1 instead of in memory by using -freg-struct-return.  This is\n    the default on NetBSD a.out, OpenBSD and GNU/Linux and several\n    embedded systems.  This convention is implemented by setting the\n-   struct_return member of `struct gdbarch_tdep' to reg_struct_return.  */\n+   struct_return member of `struct gdbarch_tdep' to reg_struct_return.\n+\n+   GCC also has an \"embedded\" ABI.  This works like the SVR4 ABI,\n+   except that pointers are returned in %D0.  This is implemented by\n+   setting the pointer_result_regnum member of `struct gdbarch_tdep'\n+   as appropriate.  */\n \n /* Read a function return value of TYPE from REGCACHE, and copy that\n    into VALBUF.  */\n@@ -284,7 +291,13 @@ m68k_extract_return_value (struct type *type, struct regcache *regcache,\n   int len = TYPE_LENGTH (type);\n   gdb_byte buf[M68K_MAX_REGISTER_SIZE];\n \n-  if (len <= 4)\n+  if (type->code () == TYPE_CODE_PTR && len == 4)\n+    {\n+      struct gdbarch *gdbarch = regcache->arch ();\n+      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      regcache->raw_read (tdep->pointer_result_regnum, valbuf);\n+    }\n+  else if (len <= 4)\n     {\n       regcache->raw_read (M68K_D0_REGNUM, buf);\n       memcpy (valbuf, buf + (4 - len), len);\n@@ -314,8 +327,6 @@ m68k_svr4_extract_return_value (struct type *type, struct regcache *regcache,\n       regcache->raw_read (M68K_FP0_REGNUM, buf);\n       target_float_convert (buf, fpreg_type, valbuf, type);\n     }\n-  else if (type->code () == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)\n-    regcache->raw_read (M68K_A0_REGNUM, valbuf);\n   else\n     m68k_extract_return_value (type, regcache, valbuf);\n }\n@@ -328,7 +339,16 @@ m68k_store_return_value (struct type *type, struct regcache *regcache,\n {\n   int len = TYPE_LENGTH (type);\n \n-  if (len <= 4)\n+  if (type->code () == TYPE_CODE_PTR && len == 4)\n+    {\n+      struct gdbarch *gdbarch = regcache->arch ();\n+      struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+      regcache->raw_write (tdep->pointer_result_regnum, valbuf);\n+      /* gdb historically also set D0 in the SVR4 case.  */\n+      if (tdep->pointer_result_regnum != M68K_D0_REGNUM)\n+\tregcache->raw_write (M68K_D0_REGNUM, valbuf);\n+    }\n+  else if (len <= 4)\n     regcache->raw_write_part (M68K_D0_REGNUM, 4 - len, len, valbuf);\n   else if (len <= 8)\n     {\n@@ -354,11 +374,6 @@ m68k_svr4_store_return_value (struct type *type, struct regcache *regcache,\n       target_float_convert (valbuf, type, buf, fpreg_type);\n       regcache->raw_write (M68K_FP0_REGNUM, buf);\n     }\n-  else if (type->code () == TYPE_CODE_PTR && TYPE_LENGTH (type) == 4)\n-    {\n-      regcache->raw_write (M68K_A0_REGNUM, valbuf);\n-      regcache->raw_write (M68K_D0_REGNUM, valbuf);\n-    }\n   else\n     m68k_store_return_value (type, regcache, valbuf);\n }\n@@ -375,11 +390,28 @@ m68k_reg_struct_return_p (struct gdbarch *gdbarch, struct type *type)\n   int len = TYPE_LENGTH (type);\n \n   gdb_assert (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION\n-\t      || code == TYPE_CODE_COMPLEX);\n+\t      || code == TYPE_CODE_COMPLEX || code == TYPE_CODE_ARRAY);\n \n   if (tdep->struct_return == pcc_struct_return)\n     return 0;\n \n+  const bool is_vector = code == TYPE_CODE_ARRAY && type->is_vector ();\n+\n+  if (is_vector\n+      && check_typedef (TYPE_TARGET_TYPE (type))->code () == TYPE_CODE_FLT)\n+    return 0;\n+\n+  /* According to m68k_return_in_memory in the m68k GCC back-end,\n+     strange things happen for small aggregate types.  Aggregate types\n+     with only one component are always returned like the type of the\n+     component.  Aggregate types whose size is 2, 4, or 8 are returned\n+     in registers if their natural alignment is at least 16 bits.\n+\n+     We reject vectors here, as experimentally this gives the correct\n+     answer.  */\n+  if (!is_vector && (len == 2 || len == 4 || len == 8))\n+    return type_align (type) >= 2;\n+\n   return (len == 1 || len == 2 || len == 4 || len == 8);\n }\n \n@@ -398,7 +430,7 @@ m68k_return_value (struct gdbarch *gdbarch, struct value *function,\n \n   /* GCC returns a `long double' in memory too.  */\n   if (((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION\n-\t|| code == TYPE_CODE_COMPLEX)\n+\t|| code == TYPE_CODE_COMPLEX || code == TYPE_CODE_ARRAY)\n        && !m68k_reg_struct_return_p (gdbarch, type))\n       || (code == TYPE_CODE_FLT && TYPE_LENGTH (type) == 12))\n     {\n@@ -432,9 +464,23 @@ m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,\n {\n   enum type_code code = type->code ();\n \n-  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION\n-       || code == TYPE_CODE_COMPLEX)\n-      && !m68k_reg_struct_return_p (gdbarch, type))\n+  /* Aggregates with a single member are always returned like their\n+     sole element.  */\n+  if ((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)\n+      && type->num_fields () == 1)\n+    {\n+      type = check_typedef (type->field (0).type ());\n+      return m68k_svr4_return_value (gdbarch, function, type, regcache,\n+\t\t\t\t     readbuf, writebuf);\n+    }\n+\n+  if (((code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION\n+\t|| code == TYPE_CODE_COMPLEX || code == TYPE_CODE_ARRAY)\n+       && !m68k_reg_struct_return_p (gdbarch, type))\n+      /* GCC may return a `long double' in memory too.  */\n+      || (!gdbarch_tdep (gdbarch)->float_return\n+\t  && code == TYPE_CODE_FLT\n+\t  && TYPE_LENGTH (type) == 12))\n     {\n       /* The System V ABI says that:\n \n@@ -444,32 +490,25 @@ m68k_svr4_return_value (struct gdbarch *gdbarch, struct value *function,\n \t register %a0.\"\n \n \t So the ABI guarantees that we can always find the return\n-\t value just after the function has returned.  */\n+\t value just after the function has returned.\n+\n+\t However, GCC also implements the \"embedded\" ABI.  That ABI\n+\t does not preserve %a0 across calls, but does write the value\n+\t back to %d0.  */\n \n       if (readbuf)\n \t{\n+\t  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n \t  ULONGEST addr;\n \n-\t  regcache_raw_read_unsigned (regcache, M68K_A0_REGNUM, &addr);\n+\t  regcache_raw_read_unsigned (regcache, tdep->pointer_result_regnum,\n+\t\t\t\t      &addr);\n \t  read_memory (addr, readbuf, TYPE_LENGTH (type));\n \t}\n \n       return RETURN_VALUE_ABI_RETURNS_ADDRESS;\n     }\n \n-  /* This special case is for structures consisting of a single\n-     `float' or `double' member.  These structures are returned in\n-     %fp0.  For these structures, we call ourselves recursively,\n-     changing TYPE into the type of the first member of the structure.\n-     Since that should work for all structures that have only one\n-     member, we don't bother to check the member's type here.  */\n-  if (code == TYPE_CODE_STRUCT && type->num_fields () == 1)\n-    {\n-      type = check_typedef (type->field (0).type ());\n-      return m68k_svr4_return_value (gdbarch, function, type, regcache,\n-\t\t\t\t     readbuf, writebuf);\n-    }\n-\n   if (readbuf)\n     m68k_svr4_extract_return_value (type, regcache, readbuf);\n   if (writebuf)\n@@ -1062,7 +1101,23 @@ m68k_svr4_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n \n   /* SVR4 uses %a0 instead of %a1.  */\n   tdep->struct_value_regnum = M68K_A0_REGNUM;\n+\n+  /* SVR4 returns pointers in %a0.  */\n+  tdep->pointer_result_regnum = M68K_A0_REGNUM;\n+}\n+\n+/* GCC's m68k \"embedded\" ABI.  This is like the SVR4 ABI, but pointer\n+   values are returned in %d0, not %a0.  */\n+\n+static void\n+m68k_embedded_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n+{\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\n+  m68k_svr4_init_abi (info, gdbarch);\n+  tdep->pointer_result_regnum = M68K_D0_REGNUM;\n }\n+\n \f\n \n /* Function: m68k_gdbarch_init\n@@ -1155,6 +1210,24 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n \tflavour = m68k_coldfire_flavour;\n     }\n   \n+  /* Try to figure out if the arch uses floating registers to return\n+     floating point values from functions.  On ColdFire, floating\n+     point values are returned in D0.  */\n+  int float_return = 0;\n+  if (has_fp && flavour != m68k_coldfire_flavour)\n+    float_return = 1;\n+#ifdef HAVE_ELF\n+  if (info.abfd && bfd_get_flavour (info.abfd) == bfd_target_elf_flavour)\n+    {\n+      int fp_abi = bfd_elf_get_obj_attr_int (info.abfd, OBJ_ATTR_GNU,\n+\t\t\t\t\t     Tag_GNU_M68K_ABI_FP);\n+      if (fp_abi == 1)\n+\tfloat_return = 1;\n+      else if (fp_abi == 2)\n+\tfloat_return = 0;\n+    }\n+#endif /* HAVE_ELF */\n+\n   /* If there is already a candidate, use it.  */\n   for (best_arch = gdbarch_list_lookup_by_info (arches, &info);\n        best_arch != NULL;\n@@ -1166,6 +1239,9 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n       if (has_fp != gdbarch_tdep (best_arch->gdbarch)->fpregs_present)\n \tcontinue;\n \n+      if (float_return != gdbarch_tdep (best_arch->gdbarch)->float_return)\n+\tcontinue;\n+\n       break;\n     }\n \n@@ -1179,6 +1255,7 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   tdep = XCNEW (struct gdbarch_tdep);\n   gdbarch = gdbarch_alloc (&info, tdep);\n   tdep->fpregs_present = has_fp;\n+  tdep->float_return = float_return;\n   tdep->flavour = flavour;\n \n   if (flavour == m68k_coldfire_flavour || flavour == m68k_fido_flavour)\n@@ -1214,22 +1291,6 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   if (has_fp)\n     set_gdbarch_fp0_regnum (gdbarch, M68K_FP0_REGNUM);\n \n-  /* Try to figure out if the arch uses floating registers to return\n-     floating point values from functions.  */\n-  if (has_fp)\n-    {\n-      /* On ColdFire, floating point values are returned in D0.  */\n-      if (flavour == m68k_coldfire_flavour)\n-\ttdep->float_return = 0;\n-      else\n-\ttdep->float_return = 1;\n-    }\n-  else\n-    {\n-      /* No floating registers, so can't use them for returning values.  */\n-      tdep->float_return = 0;\n-    }\n-\n   /* Function call & return.  */\n   set_gdbarch_push_dummy_call (gdbarch, m68k_push_dummy_call);\n   set_gdbarch_return_value (gdbarch, m68k_return_value);\n@@ -1242,6 +1303,7 @@ m68k_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n #else\n   tdep->jb_pc = -1;\n #endif\n+  tdep->pointer_result_regnum = M68K_D0_REGNUM;\n   tdep->struct_value_regnum = M68K_A1_REGNUM;\n   tdep->struct_return = reg_struct_return;\n \n@@ -1281,9 +1343,27 @@ m68k_dump_tdep (struct gdbarch *gdbarch, struct ui_file *file)\n     return;\n }\n \n+/* OSABI sniffer for m68k.  */\n+\n+static enum gdb_osabi\n+m68k_osabi_sniffer (bfd *abfd)\n+{\n+  unsigned int elfosabi = elf_elfheader (abfd)->e_ident[EI_OSABI];\n+\n+  if (elfosabi == ELFOSABI_NONE)\n+    return GDB_OSABI_SVR4;\n+\n+  return GDB_OSABI_UNKNOWN;\n+}\n+\n void _initialize_m68k_tdep ();\n void\n _initialize_m68k_tdep ()\n {\n   gdbarch_register (bfd_arch_m68k, m68k_gdbarch_init, m68k_dump_tdep);\n+\n+  gdbarch_register_osabi_sniffer (bfd_arch_m68k, bfd_target_elf_flavour,\n+\t\t\t\t  m68k_osabi_sniffer);\n+  gdbarch_register_osabi (bfd_arch_m68k, 0, GDB_OSABI_SVR4,\n+\t\t\t  m68k_embedded_init_abi);\n }"
    },
    {
      "sha": "513190fe8cc4a91a721f45ac1ece30610d144d4e",
      "filename": "gdb/m68k-tdep.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3eba3a011a89c75c10bd1860eee4589e65697165/gdb/m68k-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3eba3a011a89c75c10bd1860eee4589e65697165/gdb/m68k-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m68k-tdep.h?ref=3eba3a011a89c75c10bd1860eee4589e65697165",
      "patch": "@@ -79,6 +79,10 @@ struct gdbarch_tdep\n      passed to a function.  */\n   int struct_value_regnum;\n \n+  /* Register in which a pointer value is returned.  In the SVR4 ABI,\n+     this is %a0, but in GCC's \"embedded\" ABI, this is %d0.  */\n+  int pointer_result_regnum;\n+\n   /* Convention for returning structures.  */\n   enum struct_return struct_return;\n "
    }
  ]
}