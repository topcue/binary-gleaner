{
  "sha": "3685de750e6a091663a0abe42528cad29e960e35",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzY4NWRlNzUwZTZhMDkxNjYzYTBhYmU0MjUyOGNhZDI5ZTk2MGUzNQ==",
  "commit": {
    "author": {
      "name": "Siddhesh Poyarekar",
      "email": "siddhesh@gotplt.org",
      "date": "2021-02-19T02:35:33Z"
    },
    "committer": {
      "name": "Siddhesh Poyarekar",
      "email": "siddhesh@gotplt.org",
      "date": "2021-02-19T02:35:33Z"
    },
    "message": "binutils: Avoid renaming over existing files\n\nRenaming over existing files needs additional care to restore\npermissions and ownership, which may not always succeed.\nAdditionally, other properties of the file such as extended attributes\nmay be lost, making the operation flaky.\n\nFor predictable results, resort to rename() only if the file does not\nexist, otherwise copy the file contents into the existing file.  This\nensures that no additional tricks are needed to retain file\nproperties.\n\nThis also allows dropping of the redundant set_times on the tmpfile in\nobjcopy/strip since now we no longer rename over existing files.\n\nbinutils/\n\n\t* ar.c (write_archive): Remove TARGET_STAT.  Adjust call to\n\tSMART_RENAME.\n\t* arsup.c (ar_save): Likewise.\n\t* objcopy (strip_main): Don't copy TMPFD.  Don't set times on\n\ttemporary file and adjust call to SMART_RENAME.\n\t(copy_main): Likewise.\n\t* rename.c [!S_ISLNK]: Remove definitions.\n\t(try_preserve_permissions): Remove function.\n\t(smart_rename): Remove FD, PRESERVE_DATES arguments.  Use\n\trename system call only if TO does not exist.\n\t* bucomm.h (smart_rename): Adjust declaration.",
    "tree": {
      "sha": "2c71a3c3f24af21550fde8cef7431a3f9d248659",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2c71a3c3f24af21550fde8cef7431a3f9d248659"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3685de750e6a091663a0abe42528cad29e960e35",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3685de750e6a091663a0abe42528cad29e960e35",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3685de750e6a091663a0abe42528cad29e960e35",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3685de750e6a091663a0abe42528cad29e960e35/comments",
  "author": {
    "login": "siddhesh",
    "id": 158582,
    "node_id": "MDQ6VXNlcjE1ODU4Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/siddhesh",
    "html_url": "https://github.com/siddhesh",
    "followers_url": "https://api.github.com/users/siddhesh/followers",
    "following_url": "https://api.github.com/users/siddhesh/following{/other_user}",
    "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions",
    "organizations_url": "https://api.github.com/users/siddhesh/orgs",
    "repos_url": "https://api.github.com/users/siddhesh/repos",
    "events_url": "https://api.github.com/users/siddhesh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/siddhesh/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "siddhesh",
    "id": 158582,
    "node_id": "MDQ6VXNlcjE1ODU4Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/158582?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/siddhesh",
    "html_url": "https://github.com/siddhesh",
    "followers_url": "https://api.github.com/users/siddhesh/followers",
    "following_url": "https://api.github.com/users/siddhesh/following{/other_user}",
    "gists_url": "https://api.github.com/users/siddhesh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/siddhesh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/siddhesh/subscriptions",
    "organizations_url": "https://api.github.com/users/siddhesh/orgs",
    "repos_url": "https://api.github.com/users/siddhesh/repos",
    "events_url": "https://api.github.com/users/siddhesh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/siddhesh/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "668c18f17fc4ea91675a2b638c31bfbefa29665f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/668c18f17fc4ea91675a2b638c31bfbefa29665f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/668c18f17fc4ea91675a2b638c31bfbefa29665f"
    }
  ],
  "stats": {
    "total": 175,
    "additions": 33,
    "deletions": 142
  },
  "files": [
    {
      "sha": "04813322072d25723c3d173cda36bb19faa3d1fe",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3685de750e6a091663a0abe42528cad29e960e35/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3685de750e6a091663a0abe42528cad29e960e35/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=3685de750e6a091663a0abe42528cad29e960e35",
      "patch": "@@ -1,3 +1,17 @@\n+2021-02-19  Siddhesh Poyarekar  <siddhesh@gotplt.org>\n+\n+\t* ar.c (write_archive): Remove TARGET_STAT.  Adjust call to\n+\tSMART_RENAME.\n+\t* arsup.c (ar_save): Likewise.\n+\t* objcopy (strip_main): Don't copy TMPFD.  Don't set times on\n+\ttemporary file and adjust call to SMART_RENAME.\n+\t(copy_main): Likewise.\n+\t* rename.c [!S_ISLNK]: Remove definitions.\n+\t(try_preserve_permissions): Remove function.\n+\t(smart_rename): Remove FD, PRESERVE_DATES arguments.  Use\n+\trename system call only if TO does not exist.\n+\t* bucomm.h (smart_rename): Adjust declaration.\n+\n 2021-02-18  Nick Clifton  <nickc@redhat.com>\n \n \t* objcopy.c (merge_gnu_build_notes): Handle notes with a start"
    },
    {
      "sha": "44df48c5c677c9ab53b8ad4856a62479de29a38e",
      "filename": "binutils/ar.c",
      "status": "modified",
      "additions": 1,
      "deletions": 8,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3685de750e6a091663a0abe42528cad29e960e35/binutils/ar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3685de750e6a091663a0abe42528cad29e960e35/binutils/ar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ar.c?ref=3685de750e6a091663a0abe42528cad29e960e35",
      "patch": "@@ -1253,7 +1253,6 @@ write_archive (bfd *iarch)\n   char *old_name, *new_name;\n   bfd *contents_head = iarch->archive_next;\n   int ofd = -1;\n-  struct stat target_stat;\n \n   old_name = xstrdup (bfd_get_filename (iarch));\n   new_name = make_tempname (old_name, &ofd);\n@@ -1298,12 +1297,6 @@ write_archive (bfd *iarch)\n   if (!bfd_set_archive_head (obfd, contents_head))\n     bfd_fatal (old_name);\n \n-#if !defined (_WIN32) || defined (__CYGWIN32__)\n-  ofd = dup (ofd);\n-#endif\n-  if (ofd == -1 || bfd_stat (iarch, &target_stat) != 0)\n-    bfd_fatal (old_name);\n-\n   if (!bfd_close (obfd))\n     bfd_fatal (old_name);\n \n@@ -1313,7 +1306,7 @@ write_archive (bfd *iarch)\n   /* We don't care if this fails; we might be creating the archive.  */\n   bfd_close (iarch);\n \n-  if (smart_rename (new_name, old_name, ofd, &target_stat, 0) != 0)\n+  if (smart_rename (new_name, old_name, NULL) != 0)\n     xexit (1);\n   free (old_name);\n   free (new_name);"
    },
    {
      "sha": "f7ce8f0bc82066cfe287f8c0a9d089bdad9f438d",
      "filename": "binutils/arsup.c",
      "status": "modified",
      "additions": 1,
      "deletions": 12,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3685de750e6a091663a0abe42528cad29e960e35/binutils/arsup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3685de750e6a091663a0abe42528cad29e960e35/binutils/arsup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/arsup.c?ref=3685de750e6a091663a0abe42528cad29e960e35",
      "patch": "@@ -343,18 +343,11 @@ ar_save (void)\n     }\n   else\n     {\n-      bfd_boolean skip_stat = FALSE;\n       struct stat target_stat;\n-      int ofd = real_ofd;\n \n       if (deterministic > 0)\n         obfd->flags |= BFD_DETERMINISTIC_OUTPUT;\n \n-#if !defined (_WIN32) || defined (__CYGWIN32__)\n-      /* It's OK to fail; at worst it will result in SMART_RENAME using a slow\n-         copy fallback to write the output.  */\n-      ofd = dup (ofd);\n-#endif\n       bfd_close (obfd);\n \n       if (stat (real_name, &target_stat) != 0)\n@@ -363,18 +356,14 @@ ar_save (void)\n \t     Create the real empty output file here so smart_rename will\n \t     update the mode according to the process umask.  */\n \t  obfd = bfd_openw (real_name, NULL);\n-\t  if (obfd == NULL\n-\t      || bfd_stat (obfd, &target_stat) != 0)\n-\t    skip_stat = TRUE;\n \t  if (obfd != NULL)\n \t    {\n \t      bfd_set_format (obfd, bfd_archive);\n \t      bfd_close (obfd);\n \t    }\n \t}\n \n-      smart_rename (temp_name, real_name, ofd,\n-\t\t    skip_stat ? NULL : &target_stat, 0);\n+      smart_rename (temp_name, real_name, NULL);\n       obfd = 0;\n       free (temp_name);\n       free (real_name);"
    },
    {
      "sha": "aa7e33d8cd15e04ab12691bb29cb4365080998fc",
      "filename": "binutils/bucomm.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3685de750e6a091663a0abe42528cad29e960e35/binutils/bucomm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3685de750e6a091663a0abe42528cad29e960e35/binutils/bucomm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/bucomm.h?ref=3685de750e6a091663a0abe42528cad29e960e35",
      "patch": "@@ -71,7 +71,7 @@ extern void print_version (const char *);\n /* In rename.c.  */\n extern void set_times (const char *, const struct stat *);\n \n-extern int smart_rename (const char *, const char *, int, struct stat *, int);\n+extern int smart_rename (const char *, const char *, struct stat *);\n \n \n /* In libiberty.  */"
    },
    {
      "sha": "abbcb7c51907527e2dfa1d8c1f59c550929f3479",
      "filename": "binutils/objcopy.c",
      "status": "modified",
      "additions": 7,
      "deletions": 35,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3685de750e6a091663a0abe42528cad29e960e35/binutils/objcopy.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3685de750e6a091663a0abe42528cad29e960e35/binutils/objcopy.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objcopy.c?ref=3685de750e6a091663a0abe42528cad29e960e35",
      "patch": "@@ -4837,7 +4837,6 @@ strip_main (int argc, char *argv[])\n       struct stat statbuf;\n       char *tmpname;\n       int tmpfd = -1;\n-      int copyfd = -1;\n \n       if (get_file_size (argv[i]) < 1)\n \t{\n@@ -4851,12 +4850,7 @@ strip_main (int argc, char *argv[])\n       else\n \ttmpname = output_file;\n \n-      if (tmpname == NULL\n-#if !defined (_WIN32) || defined (__CYGWIN32__)\n-\t  /* Retain a copy of TMPFD since we will need it for SMART_RENAME.  */\n-\t  || (tmpfd >= 0 && (copyfd = dup (tmpfd)) == -1)\n-#endif\n-      )\n+      if (tmpname == NULL)\n \t{\n \t  bfd_nonfatal_message (argv[i], NULL, NULL,\n \t\t\t\t_(\"could not create temporary file to hold stripped copy\"));\n@@ -4869,23 +4863,15 @@ strip_main (int argc, char *argv[])\n \t\t output_target, NULL);\n       if (status == 0)\n \t{\n-\t  if (preserve_dates)\n-\t    set_times (tmpname, &statbuf);\n \t  if (output_file != tmpname)\n \t    status = (smart_rename (tmpname,\n \t\t\t\t    output_file ? output_file : argv[i],\n-\t\t\t\t    copyfd, &statbuf, preserve_dates) != 0);\n+\t\t\t\t    preserve_dates ? &statbuf : NULL) != 0);\n \t  if (status == 0)\n \t    status = hold_status;\n \t}\n       else\n-\t{\n-#if !defined (_WIN32) || defined (__CYGWIN32__)\n-\t  if (copyfd >= 0)\n-\t    close (copyfd);\n-#endif\n-\t  unlink_if_ordinary (tmpname);\n-\t}\n+\tunlink_if_ordinary (tmpname);\n       if (output_file != tmpname)\n \tfree (tmpname);\n     }\n@@ -5093,7 +5079,6 @@ copy_main (int argc, char *argv[])\n   bfd_boolean use_globalize = FALSE;\n   bfd_boolean use_keep_global = FALSE;\n   int c, tmpfd = -1;\n-  int copyfd = -1;\n   struct stat statbuf;\n   const bfd_arch_info_type *input_arch = NULL;\n \n@@ -5938,12 +5923,7 @@ copy_main (int argc, char *argv[])\n   else\n     tmpname = output_filename;\n \n-  if (tmpname == NULL\n-#if !defined (_WIN32) || defined (__CYGWIN32__)\n-      /* Retain a copy of TMPFD since we will need it for SMART_RENAME.  */\n-      || (tmpfd >= 0 && (copyfd = dup (tmpfd)) == -1)\n-#endif\n-  )\n+  if (tmpname == NULL)\n     {\n       fatal (_(\"warning: could not create temporary file whilst copying '%s', (error: %s)\"),\n \t     input_filename, strerror (errno));\n@@ -5953,20 +5933,12 @@ copy_main (int argc, char *argv[])\n \t     output_target, input_arch);\n   if (status == 0)\n     {\n-      if (preserve_dates)\n-\tset_times (tmpname, &statbuf);\n       if (tmpname != output_filename)\n-\tstatus = (smart_rename (tmpname, input_filename, copyfd, &statbuf,\n-\t\t\t\tpreserve_dates) != 0);\n+\tstatus = (smart_rename (tmpname, input_filename,\n+\t\t\t\tpreserve_dates ? &statbuf : NULL) != 0);\n     }\n   else\n-    {\n-#if !defined (_WIN32) || defined (__CYGWIN32__)\n-      if (copyfd >= 0)\n-\tclose (copyfd);\n-#endif\n-      unlink_if_ordinary (tmpname);\n-    }\n+    unlink_if_ordinary (tmpname);\n \n   if (tmpname != output_filename)\n     free (tmpname);"
    },
    {
      "sha": "2ff092ee22b5df9b85689091c73de76675f254cb",
      "filename": "binutils/rename.c",
      "status": "modified",
      "additions": 9,
      "deletions": 86,
      "changes": 95,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3685de750e6a091663a0abe42528cad29e960e35/binutils/rename.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3685de750e6a091663a0abe42528cad29e960e35/binutils/rename.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/rename.c?ref=3685de750e6a091663a0abe42528cad29e960e35",
      "patch": "@@ -122,61 +122,13 @@ set_times (const char *destination, const struct stat *statbuf)\n     non_fatal (_(\"%s: cannot set time: %s\"), destination, strerror (errno));\n }\n \n-#ifndef S_ISLNK\n-#ifdef S_IFLNK\n-#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)\n-#else\n-#define S_ISLNK(m) 0\n-#define lstat stat\n-#endif\n-#endif\n-\n-#if !defined (_WIN32) || defined (__CYGWIN32__)\n-/* Try to preserve the permission bits and ownership of an existing file when\n-   rename overwrites it.  FD is the file being renamed and TARGET_STAT has the\n-   status of the file that was overwritten.  */\n-static void\n-try_preserve_permissions (int fd, struct stat *target_stat)\n-{\n-  struct stat from_stat;\n-  int ret = 0;\n-\n-  if (fstat (fd, &from_stat) != 0)\n-    return;\n-\n-  int from_mode = from_stat.st_mode & 0777;\n-  int to_mode = target_stat->st_mode & 0777;\n-\n-  /* Fix up permissions before we potentially lose ownership with fchown.\n-     Clear the setxid bits because in case the fchown below fails then we don't\n-     want to end up with a sxid file owned by the invoking user.  If the user\n-     hasn't changed or if fchown succeeded, we add back the sxid bits at the\n-     end.  */\n-  if (from_mode != to_mode)\n-    fchmod (fd, to_mode);\n-\n-  /* Fix up ownership, this will clear the setxid bits.  */\n-  if (from_stat.st_uid != target_stat->st_uid\n-      || from_stat.st_gid != target_stat->st_gid)\n-    ret = fchown (fd, target_stat->st_uid, target_stat->st_gid);\n-\n-  /* Fix up the sxid bits if either the fchown wasn't needed or it\n-     succeeded.  */\n-  if (ret == 0)\n-    fchmod (fd, target_stat->st_mode & 07777);\n-}\n-#endif\n-\n-/* Rename FROM to TO, copying if TO is either a link or is not a regular file.\n-   FD is an open file descriptor pointing to FROM that we can use to safely fix\n-   up permissions of the file after renaming.  TARGET_STAT has the file status\n-   that is used to fix up permissions and timestamps after rename.  Return 0 if\n-   ok, -1 if error and FD is closed before returning.  */\n+/* Rename FROM to TO, copying if TO exists.  TARGET_STAT has the file status\n+   that, if non-NULL, is used to fix up timestamps after rename.  Return 0 if\n+   ok, -1 if error.  */\n \n int\n-smart_rename (const char *from, const char *to, int fd ATTRIBUTE_UNUSED,\n-\t      struct stat *target_stat ATTRIBUTE_UNUSED,\n-\t      int preserve_dates ATTRIBUTE_UNUSED)\n+smart_rename (const char *from, const char *to,\n+\t      struct stat *target_stat ATTRIBUTE_UNUSED)\n {\n   int ret = 0;\n   struct stat to_stat;\n@@ -199,37 +151,10 @@ smart_rename (const char *from, const char *to, int fd ATTRIBUTE_UNUSED,\n       unlink (from);\n     }\n #else\n-  /* Avoid a full copy and use rename if we can fix up permissions of the\n-     file after renaming, i.e.:\n-\n-     - TO is not a symbolic link\n-     - TO is a regular file with only one hard link\n-     - We have permission to write to TO\n-     - FD is available to safely fix up permissions to be the same as the file\n-       we overwrote with the rename.\n-\n-     Note though that the actual file on disk that TARGET_STAT describes may\n-     have changed and we're only trying to preserve the status we know about.\n-     At no point do we try to interact with the new file changes, so there can\n-     only be two outcomes, i.e. either the external file change survives\n-     without knowledge of our change (if it happens after the rename syscall)\n-     or our rename and permissions fixup survive without any knowledge of the\n-     external change.  */\n-  if (! exists\n-      || (fd >= 0\n-\t  && !S_ISLNK (to_stat.st_mode)\n-\t  && S_ISREG (to_stat.st_mode)\n-\t  && (to_stat.st_mode & S_IWUSR)\n-\t  && to_stat.st_nlink == 1)\n-      )\n+  /* Avoid a full copy and use rename if TO does not exist.  */\n+  if (!exists)\n     {\n-      ret = rename (from, to);\n-      if (ret == 0)\n-\t{\n-\t  if (exists && target_stat != NULL)\n-\t    try_preserve_permissions (fd, target_stat);\n-\t}\n-      else\n+      if ((ret = rename (from, to)) != 0)\n \t{\n \t  /* We have to clean up here.  */\n \t  non_fatal (_(\"unable to rename '%s'; reason: %s\"), to, strerror (errno));\n@@ -242,12 +167,10 @@ smart_rename (const char *from, const char *to, int fd ATTRIBUTE_UNUSED,\n       if (ret != 0)\n \tnon_fatal (_(\"unable to copy file '%s'; reason: %s\"), to, strerror (errno));\n \n-      if (preserve_dates && target_stat != NULL)\n+      if (target_stat != NULL)\n \tset_times (to, target_stat);\n       unlink (from);\n     }\n-  if (fd >= 0)\n-    close (fd);\n #endif /* _WIN32 && !__CYGWIN32__ */\n \n   return ret;"
    }
  ]
}