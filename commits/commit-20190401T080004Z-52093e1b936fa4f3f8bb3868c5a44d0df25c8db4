{
  "sha": "52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTIwOTNlMWI5MzZmYTRmM2Y4YmIzODY4YzVhNDRkMGRmMjVjOGRiNA==",
  "commit": {
    "author": {
      "name": "Marco Barisione",
      "email": "mbarisione@undo.io",
      "date": "2019-04-01T07:59:53Z"
    },
    "committer": {
      "name": "Marco Barisione",
      "email": "mbarisione@undo.io",
      "date": "2019-04-01T08:00:04Z"
    },
    "message": "Add gdb.Value.format_string ()\n\nThe str () function, called on a gdb.Value instance, produces a string\nrepresentation similar to what can be achieved with the print command,\nbut it doesn't allow to specify additional formatting settings, for\ninstance disabling pretty printers.\n\nThis patch introduces a new format_string () method to gdb.Value which\nallows specifying more formatting options, thus giving access to more\nfeatures provided by the internal C function common_val_print ().\n\ngdb/ChangeLog:\n\n2019-04-01  Marco Barisione  <mbarisione@undo.io>\n\n\tAdd gdb.Value.format_string ().\n\t* python/py-value.c (copy_py_bool_obj):\n\t(valpy_format_string): Add gdb.Value.format_string ().\n\t* NEWS: Document the addition of gdb.Value.format_string ().\n\ngdb/doc/ChangeLog:\n\n2019-04-01  Marco Barisione  <mbarisione@undo.io>\n\n\t* python.texi (Values From Inferior): Document\n\tgdb.Value.format_string ().\n\ngdb/testsuite/ChangeLog:\n\n2019-04-01  Marco Barisione  <mbarisione@undo.io>\n\n\tTest gdb.Value.format_string ().\n\t* gdb.python/py-format-string.exp: New test.\n\t* gdb.python/py-format-string.c: New file.\n\t* gdb.python/py-format-string.py: New file.",
    "tree": {
      "sha": "469d4c4d62e846bdd08b14a8beffbe4c975fd3ff",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/469d4c4d62e846bdd08b14a8beffbe4c975fd3ff"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/comments",
  "author": {
    "login": "barisione",
    "id": 4679325,
    "node_id": "MDQ6VXNlcjQ2NzkzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4679325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisione",
    "html_url": "https://github.com/barisione",
    "followers_url": "https://api.github.com/users/barisione/followers",
    "following_url": "https://api.github.com/users/barisione/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisione/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisione/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisione/subscriptions",
    "organizations_url": "https://api.github.com/users/barisione/orgs",
    "repos_url": "https://api.github.com/users/barisione/repos",
    "events_url": "https://api.github.com/users/barisione/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisione/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisione",
    "id": 4679325,
    "node_id": "MDQ6VXNlcjQ2NzkzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4679325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisione",
    "html_url": "https://github.com/barisione",
    "followers_url": "https://api.github.com/users/barisione/followers",
    "following_url": "https://api.github.com/users/barisione/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisione/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisione/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisione/subscriptions",
    "organizations_url": "https://api.github.com/users/barisione/orgs",
    "repos_url": "https://api.github.com/users/barisione/repos",
    "events_url": "https://api.github.com/users/barisione/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisione/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8828efdb24ef337e074183a0db3ac6399a3c09ba",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8828efdb24ef337e074183a0db3ac6399a3c09ba",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8828efdb24ef337e074183a0db3ac6399a3c09ba"
    }
  ],
  "stats": {
    "total": 1377,
    "additions": 1377,
    "deletions": 0
  },
  "files": [
    {
      "sha": "dc9e7b3cb827e661e3a12ca12cb3f976df0835bf",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
      "patch": "@@ -16,6 +16,15 @@\n \n * Support for Pointer Authentication on AArch64 Linux.\n \n+* Python API\n+\n+  ** The gdb.Value type has a new method 'format_string' which returns a\n+     string representing the value.  The formatting is controlled by the\n+     optional keyword arguments: 'raw', 'pretty_arrays', 'pretty_structs',\n+     'array_indexes', 'symbols', 'unions', 'deref_refs', 'actual_objects',\n+     'static_members', 'max_elements', 'repeat_threshold', and 'format'.\n+\n+\n *** Changes in GDB 8.3\n \n * GDB and GDBserver now support access to additional registers on"
    },
    {
      "sha": "67165ac3ba8b9178bef6529302f68b3690db7e2c",
      "filename": "gdb/doc/python.texi",
      "status": "modified",
      "additions": 80,
      "deletions": 0,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/doc/python.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/doc/python.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/python.texi?ref=52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
      "patch": "@@ -864,6 +864,86 @@ Like @code{Value.cast}, but works as if the C@t{++} @code{reinterpret_cast}\n operator were used.  Consult a C@t{++} reference for details.\n @end defun\n \n+@defun Value.format_string (...)\n+Convert a @code{gdb.Value} to a string, similarly to what the @code{print}\n+command does.  Invoked with no arguments, this is equivalent to calling\n+the @code{str} function on the @code{gdb.Value}.  The representation of\n+the same value may change across different versions of @value{GDBN}, so\n+you shouldn't, for instance, parse the strings returned by this method.\n+\n+All the arguments are keyword only.  If an argument is not specified, the\n+current global default setting is used.\n+\n+@table @code\n+@item raw\n+@code{True} if pretty-printers (@pxref{Pretty Printing}) should not be\n+used to format the value.  @code{False} if enabled pretty-printers\n+matching the type represented by the @code{gdb.Value} should be used to\n+format it.\n+\n+@item pretty_arrays\n+@code{True} if arrays should be pretty printed to be more convenient to\n+read, @code{False} if they shouldn't (see @code{set print array} in\n+@ref{Print Settings}).\n+\n+@item pretty_structs\n+@code{True} if structs should be pretty printed to be more convenient to\n+read, @code{False} if they shouldn't (see @code{set print pretty} in\n+@ref{Print Settings}).\n+\n+@item array_indexes\n+@code{True} if array indexes should be included in the string\n+representation of arrays, @code{False} if they shouldn't (see @code{set\n+print array-indexes} in @ref{Print Settings}).\n+\n+@item symbols\n+@code{True} if the string representation of a pointer should include the\n+corresponding symbol name (if one exists), @code{False} if it shouldn't\n+(see @code{set print symbol} in @ref{Print Settings}).\n+\n+@item unions\n+@code{True} if unions which are contained in other structures or unions\n+should be expanded, @code{False} if they shouldn't (see @code{set print\n+union} in @ref{Print Settings}).\n+\n+@item deref_refs\n+@code{True} if C@t{++} references should be resolved to the value they\n+refer to, @code{False} (the default) if they shouldn't.  Note that, unlike\n+for the @code{print} command, references are not automatically expanded\n+when using the @code{format_string} method or the @code{str}\n+function.  There is no global @code{print} setting to change the default\n+behaviour.\n+\n+@item actual_objects\n+@code{True} if the representation of a pointer to an object should\n+identify the @emph{actual} (derived) type of the object rather than the\n+@emph{declared} type, using the virtual function table.  @code{False} if\n+the @emph{declared} type should be used.  (See @code{set print object} in\n+@ref{Print Settings}).\n+\n+@item static_fields\n+@code{True} if static members should be included in the string\n+representation of a C@t{++} object, @code{False} if they shouldn't (see\n+@code{set print static-members} in @ref{Print Settings}).\n+\n+@item max_elements\n+Number of array elements to print, or @code{0} to print an unlimited\n+number of elements (see @code{set print elements} in @ref{Print\n+Settings}).\n+\n+@item repeat_threshold\n+Set the threshold for suppressing display of repeated array elements, or\n+@code{0} to represent all elements, even if repeated.  (See @code{set\n+print repeats} in @ref{Print Settings}).\n+\n+@item format\n+A string containing a single character representing the format to use for\n+the returned string.  For instance, @code{'x'} is equivalent to using the\n+@value{GDBN} command @code{print} with the @code{/x} option and formats\n+the value as a hexadecimal number.\n+@end table\n+@end defun\n+\n @defun Value.string (@r{[}encoding@r{[}, errors@r{[}, length@r{]]]})\n If this @code{gdb.Value} represents a string, then this method\n converts the contents to a Python string.  Otherwise, this method will"
    },
    {
      "sha": "1dcb60d72a967e5bc4972531566592593b8123ca",
      "filename": "gdb/python/py-value.c",
      "status": "modified",
      "additions": 164,
      "deletions": 0,
      "changes": 164,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/python/py-value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/python/py-value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-value.c?ref=52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
      "patch": "@@ -588,6 +588,165 @@ valpy_string (PyObject *self, PyObject *args, PyObject *kw)\n \t\t\t   encoding, errors);\n }\n \n+/* Given a Python object, copy its truth value to a C int (the value\n+   pointed by dest).\n+   If src_obj is NULL, then *dest is not modified.\n+\n+   Return true in case of success (including src_obj being NULL), false\n+   in case of error.  */\n+\n+static bool\n+copy_py_bool_obj (int *dest, PyObject *src_obj)\n+{\n+  if (src_obj)\n+    {\n+      int cmp = PyObject_IsTrue (src_obj);\n+      if (cmp < 0)\n+\treturn false;\n+      *dest = cmp;\n+    }\n+\n+  return true;\n+}\n+\n+/* Implementation of gdb.Value.format_string (...) -> string.\n+   Return Unicode string with value contents formatted using the\n+   keyword-only arguments.  */\n+\n+static PyObject *\n+valpy_format_string (PyObject *self, PyObject *args, PyObject *kw)\n+{\n+  static const char *keywords[] =\n+    {\n+      /* Basic C/C++ options.  */\n+      \"raw\",\t\t\t/* See the /r option to print.  */\n+      \"pretty_arrays\",\t\t/* See set print array on|off.  */\n+      \"pretty_structs\",\t\t/* See set print pretty on|off.  */\n+      \"array_indexes\",\t\t/* See set print array-indexes on|off.  */\n+      \"symbols\",\t\t/* See set print symbol on|off.  */\n+      \"unions\",\t\t\t/* See set print union on|off.  */\n+      /* C++ options.  */\n+      \"deref_refs\",\t\t/* No corresponding setting.  */\n+      \"actual_objects\",\t\t/* See set print object on|off.  */\n+      \"static_members\",\t\t/* See set print static-members on|off.  */\n+      /* C non-bool options.  */\n+      \"max_elements\", \t\t/* See set print elements N.  */\n+      \"repeat_threshold\",\t/* See set print repeats.  */\n+      \"format\",\t\t\t/* The format passed to the print command.  */\n+      NULL\n+    };\n+\n+  /* This function has too many arguments to be useful as positionals, so\n+     the user should specify them all as keyword arguments.\n+     Python 3.3 and later have a way to specify it (both in C and Python\n+     itself), but we could be compiled with older versions, so we just\n+     check that the args tuple is empty.  */\n+  Py_ssize_t positional_count = PyObject_Length (args);\n+  if (positional_count < 0)\n+    return NULL;\n+  else if (positional_count > 0)\n+    {\n+      /* This matches the error message that Python 3.3 raises when\n+\t passing positionals to functions expecting keyword-only\n+\t arguments.  */\n+      PyErr_Format (PyExc_TypeError,\n+\t\t    \"format_string() takes 0 positional arguments but %zu were given\",\n+\t\t    positional_count);\n+      return NULL;\n+    }\n+\n+  struct value_print_options opts;\n+  get_user_print_options (&opts);\n+  opts.deref_ref = 0;\n+\n+  /* We need objects for booleans as the \"p\" flag for bools is new in\n+     Python 3.3.  */\n+  PyObject *raw_obj = NULL;\n+  PyObject *pretty_arrays_obj = NULL;\n+  PyObject *pretty_structs_obj = NULL;\n+  PyObject *array_indexes_obj = NULL;\n+  PyObject *symbols_obj = NULL;\n+  PyObject *unions_obj = NULL;\n+  PyObject *deref_refs_obj = NULL;\n+  PyObject *actual_objects_obj = NULL;\n+  PyObject *static_members_obj = NULL;\n+  char *format = NULL;\n+  if (!gdb_PyArg_ParseTupleAndKeywords (args,\n+\t\t\t\t\tkw,\n+\t\t\t\t\t\"|O!O!O!O!O!O!O!O!O!IIs\",\n+\t\t\t\t\tkeywords,\n+\t\t\t\t\t&PyBool_Type, &raw_obj,\n+\t\t\t\t\t&PyBool_Type, &pretty_arrays_obj,\n+\t\t\t\t\t&PyBool_Type, &pretty_structs_obj,\n+\t\t\t\t\t&PyBool_Type, &array_indexes_obj,\n+\t\t\t\t\t&PyBool_Type, &symbols_obj,\n+\t\t\t\t\t&PyBool_Type, &unions_obj,\n+\t\t\t\t\t&PyBool_Type, &deref_refs_obj,\n+\t\t\t\t\t&PyBool_Type, &actual_objects_obj,\n+\t\t\t\t\t&PyBool_Type, &static_members_obj,\n+\t\t\t\t\t&opts.print_max,\n+\t\t\t\t\t&opts.repeat_count_threshold,\n+\t\t\t\t\t&format))\n+    return NULL;\n+\n+  /* Set boolean arguments.  */\n+  if (!copy_py_bool_obj (&opts.raw, raw_obj))\n+    return NULL;\n+  if (!copy_py_bool_obj (&opts.prettyformat_arrays, pretty_arrays_obj))\n+    return NULL;\n+  if (!copy_py_bool_obj (&opts.prettyformat_structs, pretty_structs_obj))\n+    return NULL;\n+  if (!copy_py_bool_obj (&opts.print_array_indexes, array_indexes_obj))\n+    return NULL;\n+  if (!copy_py_bool_obj (&opts.symbol_print, symbols_obj))\n+    return NULL;\n+  if (!copy_py_bool_obj (&opts.unionprint, unions_obj))\n+    return NULL;\n+  if (!copy_py_bool_obj (&opts.deref_ref, deref_refs_obj))\n+    return NULL;\n+  if (!copy_py_bool_obj (&opts.objectprint, actual_objects_obj))\n+    return NULL;\n+  if (!copy_py_bool_obj (&opts.static_field_print, static_members_obj))\n+    return NULL;\n+\n+  /* Numeric arguments for which 0 means unlimited (which we represent as\n+     UINT_MAX).  */\n+  if (opts.print_max == 0)\n+    opts.print_max = UINT_MAX;\n+  if (opts.repeat_count_threshold == 0)\n+    opts.repeat_count_threshold = UINT_MAX;\n+\n+  /* Other arguments.  */\n+  if (format != NULL)\n+    {\n+      if (strlen (format) == 1)\n+\topts.format = format[0];\n+      else\n+\t{\n+\t  /* Mimic the message on standard Python ones for similar\n+\t     errors.  */\n+\t  PyErr_SetString (PyExc_ValueError,\n+\t\t\t   \"a single character is required\");\n+\t  return NULL;\n+\t}\n+    }\n+\n+  string_file stb;\n+\n+  TRY\n+    {\n+      common_val_print (((value_object *) self)->value, &stb, 0,\n+\t\t\t&opts, python_language);\n+    }\n+  CATCH (except, RETURN_MASK_ALL)\n+    {\n+      GDB_PY_HANDLE_EXCEPTION (except);\n+    }\n+  END_CATCH\n+\n+  return PyUnicode_Decode (stb.c_str (), stb.size (), host_charset (), NULL);\n+}\n+\n /* A helper function that implements the various cast operators.  */\n \n static PyObject *\n@@ -1944,6 +2103,11 @@ Return a lazy string representation of the value.\" },\n Return Unicode string representation of the value.\" },\n   { \"fetch_lazy\", valpy_fetch_lazy, METH_NOARGS,\n     \"Fetches the value from the inferior, if it was lazy.\" },\n+  { \"format_string\", (PyCFunction) valpy_format_string,\n+    METH_VARARGS | METH_KEYWORDS,\n+    \"format_string (...) -> string\\n\\\n+Return a string representation of the value using the specified\\n\\\n+formatting options\" },\n   {NULL}  /* Sentinel */\n };\n "
    },
    {
      "sha": "120ecce989ccb17a9b4de6cc7307c3338f8f37e1",
      "filename": "gdb/testsuite/gdb.python/py-format-string.c",
      "status": "added",
      "additions": 118,
      "deletions": 0,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/testsuite/gdb.python/py-format-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/testsuite/gdb.python/py-format-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-format-string.c?ref=52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
      "patch": "@@ -0,0 +1,118 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+typedef struct point\n+{\n+  int x;\n+  int y;\n+} point_t;\n+\n+typedef union\n+{\n+  int an_int;\n+  char a_char;\n+} union_t;\n+\n+typedef struct\n+{\n+  union_t the_union;\n+} struct_union_t;\n+\n+typedef enum\n+{\n+  ENUM_FOO,\n+  ENUM_BAR,\n+} enum_t;\n+\n+typedef void (*function_t) (int);\n+\n+static void\n+my_function(int n)\n+{\n+}\n+\n+#ifdef __cplusplus\n+\n+struct Base\n+{\n+  Base (int a_) : a (a_) {}\n+\n+  virtual int get_number () { return a; }\n+\n+  int a;\n+\n+  static int a_static_member;\n+};\n+\n+int Base::a_static_member = 2019;\n+\n+struct Deriv : Base\n+{\n+  Deriv (int b_) : Base (42), b (b_) {}\n+\n+  virtual int get_number () { return b; }\n+\n+  int b;\n+};\n+\n+#endif\n+\n+int global_symbol = 42;\n+\n+int\n+main ()\n+{\n+  point_t a_point_t = { 42, 12 };\n+  point_t *a_point_t_pointer = &a_point_t;\n+#ifdef __cplusplus\n+  point_t &a_point_t_ref = a_point_t;\n+#endif\n+  struct point another_point = { 123, 456 };\n+\n+  struct_union_t a_struct_with_union;\n+  a_struct_with_union.the_union.an_int = 42;\n+\n+  enum_t an_enum = ENUM_BAR;\n+\n+  const char *a_string = \"hello world\";\n+  const char *a_binary_string = \"hello\\0world\";\n+  const char a_binary_string_array[] = \"hello\\0world\";\n+\n+  const int letters_repeat = 10;\n+  char a_big_string[26 * letters_repeat + 1];\n+  a_big_string[26 * letters_repeat] = '\\0';\n+  for (int i = 0; i < letters_repeat; i++)\n+    for (char c = 'A'; c <= 'Z'; c++)\n+      a_big_string[i * 26 + c - 'A'] = c;\n+\n+  int an_array[] = { 2, 3, 5 };\n+\n+  int an_array_with_repetition[] = {\n+    1,\t\t\t\t\t/*  1 time.   */\n+    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\t/* 12 times.  */\n+    5, 5, 5,\t\t\t\t/*  3 times   */\n+    };\n+\n+  int *a_symbol_pointer = &global_symbol;\n+\n+#ifdef __cplusplus\n+  Deriv a_deriv (123);\n+  Base &a_base_ref = a_deriv;\n+#endif\n+\n+  return 0; /* break here */\n+}"
    },
    {
      "sha": "2f574fbfa5a922fda0af060132fe0bf34714fae8",
      "filename": "gdb/testsuite/gdb.python/py-format-string.exp",
      "status": "added",
      "additions": 957,
      "deletions": 0,
      "changes": 957,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/testsuite/gdb.python/py-format-string.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/testsuite/gdb.python/py-format-string.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-format-string.exp?ref=52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
      "patch": "@@ -0,0 +1,957 @@\n+# Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file is part of the GDB testsuite.  It tests the\n+# gdb.Value.format_string () method.\n+\n+load_lib gdb-python.exp\n+\n+standard_testfile\n+\n+if [get_compiler_info c++] {\n+    return -1\n+}\n+\n+# Build inferior to language specification.\n+proc build_inferior {exefile lang} {\n+  global srcdir subdir srcfile testfile hex\n+\n+  if { [gdb_compile \"${srcdir}/${subdir}/${srcfile}\" \"${exefile}\" executable \"debug $lang\"] != \"\" } {\n+      untested \"failed to compile in $lang mode\"\n+      return -1\n+  }\n+\n+  return 0\n+}\n+\n+# Restart GDB.\n+proc prepare_gdb {exefile} {\n+  global srcdir subdir srcfile testfile hex\n+\n+  gdb_exit\n+  gdb_start\n+  gdb_reinitialize_dir $srcdir/$subdir\n+  gdb_load ${exefile}\n+\n+  # Skip all tests if Python scripting is not enabled.\n+  if { [skip_python_tests] } { continue }\n+\n+  if ![runto_main] then {\n+      perror \"couldn't run to breakpoint\"\n+      return\n+  }\n+\n+  # Load the pretty printer.\n+  set remote_python_file \\\n+    [gdb_remote_download host ${srcdir}/${subdir}/${testfile}.py]\n+  gdb_test_no_output \"source ${remote_python_file}\" \"load python file\"\n+\n+  runto_bp \"break here\"\n+}\n+\n+# Set breakpoint and run to that breakpoint.\n+proc runto_bp {bp} {\n+  gdb_breakpoint [gdb_get_line_number $bp]\n+  gdb_continue_to_breakpoint $bp\n+}\n+\n+# Set an option using the GDB command in $set_cmd, execute $body, and then\n+# restore the option using the GDB command in $unset_cmd.\n+proc with_temp_option { set_cmd unset_cmd body } {\n+  with_test_prefix $set_cmd {\n+    gdb_test \"$set_cmd\" \".*\"\n+    uplevel 1 $body\n+    gdb_test \"$unset_cmd\" \".*\"\n+  }\n+}\n+\n+# A regular expression for a pointer.\n+set default_pointer_regexp \"0x\\[a-fA-F0-9\\]+\"\n+\n+# A regular expression for a non-expanded C++ reference.\n+#\n+# Stringifying a C++ reference produces an address preceeded by a \"@\" in\n+# Python, but, by default, the C++ reference/class is expanded by the\n+# GDB print command.\n+set default_ref_regexp \"@${default_pointer_regexp}\"\n+\n+# The whole content of the C variable a_big_string, i.e. the whole English\n+# alphabet repeated 10 times.\n+set whole_big_string \"\"\n+set alphabet \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n+for {set i 0} {$i < 10} {incr i} {\n+  append whole_big_string $alphabet\n+}\n+unset alphabet\n+\n+# Produces a potentially cut down version of $whole_big_string like GDB\n+# would represent it.\n+# $max is the maximum number of characters allowed in the string (but\n+# the return value may contain more to accound for the extra quotes and\n+# \"...\" added by GDB).\n+proc get_cut_big_string { max } {\n+  global whole_big_string\n+\n+  set whole_size [string length $whole_big_string]\n+  if { $max > $whole_size } {\n+    return \"\\\"${whole_big_string}\\\"\"\n+  }\n+\n+  set cut_string [string range $whole_big_string 0 [expr $max - 1]]\n+  return \"\\\"${cut_string}\\\"...\"\n+}\n+\n+# A dictionary mapping from C variable names to their default string\n+# representation when using str () or gdb.Value.format_string () with\n+# no arguments.\n+# This usually matches what the print command prints if used with no\n+# options, except for C++ references which are not expanded by\n+# default in Python.  See the comment above $default_ref_regexp.\n+set default_regexp_dict [dict create \\\n+  \"a_point_t\"\t\t\t\"Pretty Point \\\\(42, 12\\\\)\" \\\n+  \"a_point_t_pointer\"\t\t$default_pointer_regexp \\\n+  \"a_point_t_ref\"\t\t\"Pretty Point \\\\(42, 12\\\\)\" \\\n+  \"another_point\"\t\t\"Pretty Point \\\\(123, 456\\\\)\" \\\n+  \"a_struct_with_union\"\t\t\"\\\\{the_union = \\\\{an_int = 42, a_char = 42 '\\\\*'\\\\}\\\\}\" \\\n+  \"an_enum\"\t\t\t\"ENUM_BAR\" \\\n+  \"a_string\"\t\t\t\"${default_pointer_regexp} \\\"hello world\\\"\" \\\n+  \"a_binary_string\"\t\t\"${default_pointer_regexp} \\\"hello\\\"\" \\\n+  \"a_binary_string_array\"\t\"\\\"hello\\\\\\\\000world\\\"\" \\\n+  \"a_big_string\"\t\t[get_cut_big_string 200] \\\n+  \"an_array\"\t\t\t\"\\\\{2, 3, 5\\\\}\" \\\n+  \"an_array_with_repetition\"\t\"\\\\{1, 3 <repeats 12 times>, 5, 5, 5\\\\}\" \\\n+  \"a_symbol_pointer\"\t\t\"${default_pointer_regexp} <global_symbol>\" \\\n+  \"a_base_ref\"\t\t\t\"${default_ref_regexp}\" \\\n+  ]\n+\n+# A sentinel value to pass to function to get them to use a default value\n+# instead.\n+# Note that we cannot use $undefined for default arguments in function\n+# definitions as we would just get the literal \"$undefined\" string, so\n+# we need to repeat the string.\n+set undefined \"\\000UNDEFINED\\000\"\n+\n+# Return $value if it's not $undefined, otherwise return the default value\n+# (from $default_regexp_dict) for the variable $var.\n+proc get_value_or_default { var value } {\n+  global undefined\n+  if { $value != $undefined } {\n+    return $value\n+  }\n+\n+  global default_regexp_dict\n+  return [dict get $default_regexp_dict $var]\n+}\n+\n+# Check that using gdb.Value.format_string on the value representing the\n+# variable $var produces $expected.\n+proc check_format_string {\n+\tvar\n+\topts\n+\t{ expected \"\\000UNDEFINED\\000\" }\n+\t{ name \"\\000UNDEFINED\\000\" }\n+  } {\n+  global undefined\n+\n+  set expected [get_value_or_default $var $expected]\n+  if { $name == $undefined } {\n+    set name \"${var} with option ${opts}\"\n+  }\n+\n+  gdb_test \\\n+    \"python print (gdb.parse_and_eval ('${var}').format_string (${opts}))\" \\\n+    $expected \\\n+    $name\n+}\n+\n+# Check that printing $var with no options set, produces the expected\n+# output.\n+proc check_var_with_no_opts {\n+\tvar\n+\t{ expected \"\\000UNDEFINED\\000\" }\n+  } {\n+  set expected [get_value_or_default $var $expected]\n+\n+  with_test_prefix \"${var}\" {\n+    check_format_string \\\n+      $var \\\n+      \"\" \\\n+      $expected \\\n+      \"no opts\"\n+    # str () should behave like gdb.Value.format_string () with no args.\n+    gdb_test \\\n+      \"python print (str (gdb.parse_and_eval ('${var}')))\" \\\n+      $expected \\\n+      \"str\"\n+  }\n+}\n+\n+# Check that printing $var with $opt set to True and set to False,\n+# produces the expected output.\n+proc check_var_with_bool_opt {\n+\topt\n+\tvar\n+\t{ true_expected  \"\\000UNDEFINED\\000\" }\n+\t{ false_expected \"\\000UNDEFINED\\000\" }\n+  } {\n+  set true_expected  [get_value_or_default $var $true_expected]\n+  set false_expected [get_value_or_default $var $false_expected]\n+\n+  with_test_prefix \"${var} with option ${opt}\" {\n+    # Option set to True.\n+    check_format_string \\\n+      $var \\\n+      \"${opt}=True\" \\\n+      $true_expected \\\n+      \"${opt}=true\"\n+    # Option set to False.\n+    check_format_string \\\n+      $var \\\n+      \"${opt}=False\" \\\n+      $false_expected \\\n+      \"${opt}=false\"\n+  }\n+}\n+\n+# Test gdb.Value.format_string with no options.\n+proc test_no_opts {} {\n+  global current_lang\n+\n+  check_var_with_no_opts \"a_point_t\"\n+  check_var_with_no_opts \"a_point_t_pointer\"\n+  check_var_with_no_opts \"another_point\"\n+  check_var_with_no_opts \"a_struct_with_union\"\n+  check_var_with_no_opts \"an_enum\"\n+  check_var_with_no_opts \"a_string\"\n+  check_var_with_no_opts \"a_binary_string\"\n+  check_var_with_no_opts \"a_binary_string_array\"\n+  check_var_with_no_opts \"a_big_string\"\n+  check_var_with_no_opts \"an_array\"\n+  check_var_with_no_opts \"an_array_with_repetition\"\n+  check_var_with_no_opts \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    # Nothing changes in all of the C++ tests because deref_refs is not\n+    # True.\n+    check_var_with_no_opts \"a_point_t_ref\"\n+    check_var_with_no_opts \"a_base_ref\"\n+  }\n+}\n+\n+# Test the raw option for gdb.Value.format_string.\n+proc test_raw {} {\n+  global current_lang\n+  global default_ref_regexp\n+\n+  check_var_with_bool_opt \"raw\" \"a_point_t\" \\\n+    \"{x = 42, y = 12}\"\n+  check_var_with_bool_opt \"raw\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"raw\" \"another_point\" \\\n+    \"{x = 123, y = 456}\"\n+  check_var_with_bool_opt \"raw\" \"a_struct_with_union\"\n+  check_var_with_bool_opt \"raw\" \"an_enum\"\n+  check_var_with_bool_opt \"raw\" \"a_string\"\n+  check_var_with_bool_opt \"raw\" \"a_binary_string\"\n+  check_var_with_bool_opt \"raw\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"raw\" \"a_big_string\"\n+  check_var_with_bool_opt \"raw\" \"an_array\"\n+  check_var_with_bool_opt \"raw\" \"an_array_with_repetition\"\n+  check_var_with_bool_opt \"raw\" \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    check_var_with_bool_opt \"raw\" \"a_point_t_ref\" \\\n+      ${default_ref_regexp}\n+    check_var_with_bool_opt \"raw\" \"a_base_ref\"\n+  }\n+\n+  with_temp_option \\\n+\t\"disable pretty-printer '' test_lookup_function\" \\\n+\t\"enable pretty-printer '' test_lookup_function\" {\n+    check_var_with_no_opts \"a_point_t\" \\\n+      \"{x = 42, y = 12}\"\n+    check_var_with_bool_opt \"raw\" \"a_point_t\" \\\n+      \"{x = 42, y = 12}\" \\\n+      \"{x = 42, y = 12}\"\n+  }\n+}\n+\n+# Test the pretty_arrays option for gdb.Value.format_string.\n+proc test_pretty_arrays {} {\n+  global current_lang\n+\n+  set an_array_pretty \"  \\\\{2,\\[\\r\\n\\]+  3,\\[\\r\\n\\]+  5\\\\}\"\n+  set an_array_with_repetition_pretty \\\n+    \"  \\\\{1,\\[\\r\\n\\]+  3 <repeats 12 times>,\\[\\r\\n\\]+  5,\\[\\r\\n\\]+  5,\\[\\r\\n\\]+  5\\\\}\"\n+\n+  check_var_with_bool_opt \"pretty_arrays\" \"a_point_t\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"another_point\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"a_struct_with_union\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"an_enum\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"a_string\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"a_binary_string\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"a_big_string\"\n+  check_var_with_bool_opt \"pretty_arrays\" \"an_array\" \\\n+    $an_array_pretty\n+  check_var_with_bool_opt \"pretty_arrays\" \"an_array_with_repetition\" \\\n+    $an_array_with_repetition_pretty\n+  check_var_with_bool_opt \"pretty_arrays\" \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    check_var_with_bool_opt \"pretty_arrays\" \"a_point_t_ref\"\n+    check_var_with_bool_opt \"pretty_arrays\" \"a_base_ref\"\n+  }\n+\n+  with_temp_option \"set print array on\" \"set print array off\" {\n+    check_var_with_no_opts \"an_array\" \\\n+      $an_array_pretty\n+    check_var_with_bool_opt \"pretty_arrays\" \"an_array\" \\\n+      $an_array_pretty\n+\n+    check_var_with_no_opts \"an_array_with_repetition\" \\\n+      $an_array_with_repetition_pretty\n+    check_var_with_bool_opt \"pretty_arrays\" \"an_array_with_repetition\" \\\n+      $an_array_with_repetition_pretty\n+  }\n+}\n+\n+# Test the pretty_structs option for gdb.Value.format_string.\n+proc test_pretty_structs {} {\n+  global current_lang\n+\n+  set a_struct_with_union_pretty \\\n+    \"\\\\{\\[\\r\\n\\]+  the_union = \\\\{\\[\\r\\n\\]+    an_int = 42,\\[\\r\\n\\]+    a_char = 42 '\\\\*'\\[\\r\\n\\]+  \\\\}\\[\\r\\n\\]+\\\\}\"\n+\n+  check_var_with_bool_opt \"pretty_structs\" \"a_point_t\"\n+  check_var_with_bool_opt \"pretty_structs\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"pretty_structs\" \"another_point\"\n+  check_var_with_bool_opt \"pretty_structs\" \"a_struct_with_union\" \\\n+    $a_struct_with_union_pretty\n+  check_var_with_bool_opt \"pretty_structs\" \"an_enum\"\n+  check_var_with_bool_opt \"pretty_structs\" \"a_string\"\n+  check_var_with_bool_opt \"pretty_structs\" \"a_binary_string\"\n+  check_var_with_bool_opt \"pretty_structs\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"pretty_structs\" \"a_big_string\"\n+  check_var_with_bool_opt \"pretty_structs\" \"an_array\"\n+  check_var_with_bool_opt \"pretty_structs\" \"an_array_with_repetition\"\n+  check_var_with_bool_opt \"pretty_structs\" \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    check_var_with_bool_opt \"pretty_structs\" \"a_point_t_ref\"\n+    check_var_with_bool_opt \"pretty_structs\" \"a_base_ref\"\n+  }\n+\n+  with_temp_option \"set print structs on\" \"set print structs off\" {\n+    check_var_with_no_opts \"a_struct_with_union\"\n+    check_var_with_bool_opt \"pretty_structs\" \"a_struct_with_union\" \\\n+      $a_struct_with_union_pretty\n+  }\n+\n+  # point_t is usually printed through the pretty printer.\n+  # Try disabling it.\n+  with_temp_option \\\n+\t\"disable pretty-printer '' test_lookup_function\" \\\n+\t\"enable pretty-printer '' test_lookup_function\" {\n+    check_var_with_no_opts \"a_point_t\" \\\n+      \"{x = 42, y = 12}\"\n+    check_var_with_bool_opt \"pretty_structs\" \"a_point_t\" \\\n+      \"\\\\{\\[\\r\\n\\]+  x = 42, *\\[\\r\\n\\]+  y = 12\\[\\r\\n\\]+\\\\}\" \\\n+      \"{x = 42, y = 12}\" \\\n+  }\n+}\n+\n+# Test the array_indexes option for gdb.Value.format_string.\n+proc test_array_indexes {} {\n+  global current_lang\n+\n+  set an_array_with_indexes \"\\\\{\\\\\\[0\\\\\\] = 2, \\\\\\[1\\\\\\] = 3, \\\\\\[2\\\\\\] = 5\\\\}\"\n+  set an_array_with_repetition_with_indexes \\\n+    \"\\\\{\\\\\\[0\\\\\\] = 1, \\\\\\[1\\\\\\] = 3 <repeats 12 times>, \\\\\\[13\\\\\\] = 5, \\\\\\[14\\\\\\] = 5, \\\\\\[15\\\\\\] = 5\\\\}\"\n+\n+  check_var_with_bool_opt \"array_indexes\" \"a_point_t\"\n+  check_var_with_bool_opt \"array_indexes\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"array_indexes\" \"another_point\"\n+  check_var_with_bool_opt \"array_indexes\" \"a_struct_with_union\"\n+  check_var_with_bool_opt \"array_indexes\" \"an_enum\"\n+  check_var_with_bool_opt \"array_indexes\" \"a_string\"\n+  check_var_with_bool_opt \"array_indexes\" \"a_binary_string\"\n+  check_var_with_bool_opt \"array_indexes\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"array_indexes\" \"a_big_string\"\n+  check_var_with_bool_opt \"array_indexes\" \"an_array\" \\\n+    $an_array_with_indexes\n+  check_var_with_bool_opt \"array_indexes\" \"an_array_with_repetition\" \\\n+    $an_array_with_repetition_with_indexes\n+  check_var_with_bool_opt \"array_indexes\" \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    check_var_with_bool_opt \"array_indexes\" \"a_point_t_ref\"\n+    check_var_with_bool_opt \"array_indexes\" \"a_base_ref\"\n+  }\n+\n+  with_temp_option \\\n+\t\"set print array-indexes on\" \\\n+\t\"set print array-indexes off\" {\n+    check_var_with_no_opts \"an_array\" \\\n+      $an_array_with_indexes\n+    check_var_with_bool_opt \"array_indexes\" \"an_array\" \\\n+      $an_array_with_indexes\n+\n+    check_var_with_no_opts \"an_array_with_repetition\" \\\n+      $an_array_with_repetition_with_indexes\n+    check_var_with_bool_opt \"array_indexes\" \"an_array_with_repetition\" \\\n+      $an_array_with_repetition_with_indexes\n+  }\n+}\n+\n+# Test the symbols option for gdb.Value.format_string.\n+proc test_symbols {} {\n+  global undefined\n+  global current_lang\n+  global default_pointer_regexp\n+\n+  check_var_with_bool_opt \"symbols\" \"a_point_t\"\n+  check_var_with_bool_opt \"symbols\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"symbols\" \"another_point\"\n+  check_var_with_bool_opt \"symbols\" \"a_struct_with_union\"\n+  check_var_with_bool_opt \"symbols\" \"an_enum\"\n+  check_var_with_bool_opt \"symbols\" \"a_string\"\n+  check_var_with_bool_opt \"symbols\" \"a_binary_string\"\n+  check_var_with_bool_opt \"symbols\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"symbols\" \"a_big_string\"\n+  check_var_with_bool_opt \"symbols\" \"an_array\"\n+  check_var_with_bool_opt \"symbols\" \"an_array_with_repetition\"\n+  check_var_with_bool_opt \"symbols\" \"a_symbol_pointer\" \\\n+    $undefined \\\n+    $default_pointer_regexp\n+\n+  if { $current_lang == \"c++\" } {\n+    check_var_with_bool_opt \"symbols\" \"a_point_t_ref\"\n+    check_var_with_bool_opt \"symbols\" \"a_base_ref\"\n+  }\n+\n+  with_temp_option \"set print symbol off\" \"set print symbol on\" {\n+    check_var_with_no_opts \"a_symbol_pointer\" \\\n+      $default_pointer_regexp\n+    check_var_with_bool_opt \"symbols\" \"a_symbol_pointer\" \\\n+      $undefined \\\n+      $default_pointer_regexp\n+  }\n+}\n+\n+# Test the unions option for gdb.Value.format_string.\n+proc test_unions {} {\n+  global undefined\n+  global current_lang\n+\n+  check_var_with_bool_opt \"unions\" \"a_point_t\"\n+  check_var_with_bool_opt \"unions\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"unions\" \"another_point\"\n+  check_var_with_bool_opt \"unions\" \"a_struct_with_union\" \\\n+    $undefined \\\n+    \"\\\\{the_union = \\\\{...\\\\}\\\\}\"\n+  check_var_with_bool_opt \"unions\" \"an_enum\"\n+  check_var_with_bool_opt \"unions\" \"a_string\"\n+  check_var_with_bool_opt \"unions\" \"a_binary_string\"\n+  check_var_with_bool_opt \"unions\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"unions\" \"a_big_string\"\n+  check_var_with_bool_opt \"unions\" \"an_array\"\n+  check_var_with_bool_opt \"unions\" \"an_array_with_repetition\"\n+  check_var_with_bool_opt \"unions\" \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    check_var_with_bool_opt \"unions\" \"a_point_t_ref\"\n+    check_var_with_bool_opt \"unions\" \"a_base_ref\"\n+  }\n+\n+  with_temp_option \"set print union off\" \"set print union on\" {\n+    check_var_with_no_opts \"a_struct_with_union\" \\\n+      \"\\\\{the_union = \\\\{...\\\\}\\\\}\"\n+    check_var_with_bool_opt \"unions\" \"a_struct_with_union\" \\\n+      $undefined \\\n+      \"\\\\{the_union = \\\\{...\\\\}\\\\}\"\n+  }\n+}\n+\n+# Test the deref_refs option for gdb.Value.format_string.\n+proc test_deref_refs {} {\n+  global current_lang\n+  global default_pointer_regexp\n+  global default_ref_regexp\n+\n+  check_var_with_bool_opt \"deref_refs\" \"a_point_t\"\n+  check_var_with_bool_opt \"deref_refs\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"deref_refs\" \"another_point\"\n+  check_var_with_bool_opt \"deref_refs\" \"a_struct_with_union\"\n+  check_var_with_bool_opt \"deref_refs\" \"an_enum\"\n+  check_var_with_bool_opt \"deref_refs\" \"a_string\"\n+  check_var_with_bool_opt \"deref_refs\" \"a_binary_string\"\n+  check_var_with_bool_opt \"deref_refs\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"deref_refs\" \"a_big_string\"\n+  check_var_with_bool_opt \"deref_refs\" \"an_array\"\n+  check_var_with_bool_opt \"deref_refs\" \"an_array_with_repetition\"\n+  check_var_with_bool_opt \"deref_refs\" \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    check_var_with_bool_opt \"deref_refs\" \"a_point_t_ref\"\n+    check_var_with_bool_opt \"deref_refs\" \"a_base_ref\" \\\n+      \"${default_ref_regexp}: \\\\{_vptr\\\\.Base = ${default_pointer_regexp} <vtable for Deriv\\\\+16>, a = 42, static a_static_member = 2019\\\\}\"\n+  }\n+}\n+\n+# Test the actual_objects option for gdb.Value.format_string.\n+proc test_actual_objects {} {\n+  global current_lang\n+\n+  check_var_with_bool_opt \"actual_objects\" \"a_point_t\"\n+  check_var_with_bool_opt \"actual_objects\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"actual_objects\" \"another_point\"\n+  check_var_with_bool_opt \"actual_objects\" \"a_struct_with_union\"\n+  check_var_with_bool_opt \"actual_objects\" \"an_enum\"\n+  check_var_with_bool_opt \"actual_objects\" \"a_string\"\n+  check_var_with_bool_opt \"actual_objects\" \"a_binary_string\"\n+  check_var_with_bool_opt \"actual_objects\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"actual_objects\" \"a_big_string\"\n+  check_var_with_bool_opt \"actual_objects\" \"an_array\"\n+  check_var_with_bool_opt \"actual_objects\" \"an_array_with_repetition\"\n+  check_var_with_bool_opt \"actual_objects\" \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    # Nothing changes in all of the C++ tests because deref_refs is not\n+    # True.\n+    check_var_with_bool_opt \"actual_objects\" \"a_point_t_ref\"\n+    check_var_with_bool_opt \"actual_objects\" \"a_base_ref\"\n+\n+    with_temp_option \"set print object on\" \"set print object off\" {\n+      check_var_with_no_opts \"a_point_t_ref\"\n+      check_var_with_bool_opt \"actual_objects\" \"a_point_t_ref\"\n+\n+      check_var_with_no_opts \"a_base_ref\"\n+      check_var_with_bool_opt \"actual_objects\" \"a_base_ref\"\n+    }\n+  }\n+}\n+\n+# Test the static_members option for gdb.Value.format_string.\n+proc test_static_members {} {\n+  global current_lang\n+\n+  check_var_with_bool_opt \"static_members\" \"a_point_t\"\n+  check_var_with_bool_opt \"static_members\" \"a_point_t_pointer\"\n+  check_var_with_bool_opt \"static_members\" \"another_point\"\n+  check_var_with_bool_opt \"static_members\" \"a_struct_with_union\"\n+  check_var_with_bool_opt \"static_members\" \"an_enum\"\n+  check_var_with_bool_opt \"static_members\" \"a_string\"\n+  check_var_with_bool_opt \"static_members\" \"a_binary_string\"\n+  check_var_with_bool_opt \"static_members\" \"a_binary_string_array\"\n+  check_var_with_bool_opt \"static_members\" \"a_big_string\"\n+  check_var_with_bool_opt \"static_members\" \"an_array\"\n+  check_var_with_bool_opt \"static_members\" \"an_array_with_repetition\"\n+  check_var_with_bool_opt \"static_members\" \"a_symbol_pointer\"\n+\n+  if { $current_lang == \"c++\" } {\n+    # Nothing changes in all of the C++ tests because deref_refs is not\n+    # True.\n+    check_var_with_bool_opt \"static_members\" \"a_point_t_ref\"\n+    check_var_with_bool_opt \"static_members\" \"a_base_ref\"\n+\n+    with_temp_option \\\n+\t\"set print static-members off\" \\\n+\t\"set print static-members on\" {\n+      check_var_with_no_opts \"a_point_t_ref\"\n+      check_var_with_bool_opt \"static_members\" \"a_point_t_ref\"\n+\n+      check_var_with_no_opts \"a_base_ref\"\n+      check_var_with_bool_opt \"static_members\" \"a_base_ref\"\n+    }\n+  }\n+}\n+\n+# Test the max_elements option for gdb.Value.format_string.\n+proc test_max_elements {} {\n+  global current_lang\n+  global default_pointer_regexp\n+\n+  # 200 is the default maximum number of elements, so setting it should\n+  # not change the output.\n+  set opts \"max_elements=200\"\n+  with_test_prefix $opts {\n+    check_format_string \"a_point_t\" $opts\n+    check_format_string \"a_point_t_pointer\" $opts\n+    check_format_string \"another_point\" $opts\n+    check_format_string \"a_struct_with_union\" $opts\n+    check_format_string \"an_enum\" $opts\n+    check_format_string \"a_string\" $opts\n+    check_format_string \"a_binary_string\" $opts\n+    check_format_string \"a_binary_string_array\" $opts\n+    check_format_string \"a_big_string\" $opts\n+    check_format_string \"an_array\" $opts\n+    check_format_string \"an_array_with_repetition\" $opts\n+    check_format_string \"a_symbol_pointer\" $opts\n+\n+    if { $current_lang == \"c++\" } {\n+      check_format_string \"a_point_t_ref\" $opts\n+      check_format_string \"a_base_ref\" $opts\n+    }\n+  }\n+\n+  set opts \"max_elements=3\"\n+  with_test_prefix $opts {\n+    check_format_string \"a_point_t\" $opts\n+    check_format_string \"a_point_t_pointer\" $opts\n+    check_format_string \"another_point\" $opts\n+    check_format_string \"a_struct_with_union\" $opts\n+    check_format_string \"an_enum\" $opts\n+    check_format_string \"a_string\" $opts \\\n+      \"${default_pointer_regexp} \\\"hel\\\"...\"\n+    check_format_string \"a_binary_string\" $opts \\\n+      \"${default_pointer_regexp} \\\"hel\\\"...\"\n+    # This will print four characters instead of three, see\n+    # <https://sourceware.org/bugzilla/show_bug.cgi?id=24331>.\n+    check_format_string \"a_binary_string_array\" $opts \\\n+      \"\\\"hell\\\"...\"\n+    check_format_string \"a_big_string\" $opts \\\n+      [get_cut_big_string 3]\n+    check_format_string \"an_array\" $opts\n+    check_format_string \"an_array_with_repetition\" $opts \\\n+      \"\\\\{1, 3 <repeats 12 times>...\\\\}\"\n+    check_format_string \"a_symbol_pointer\" $opts\n+\n+    if { $current_lang == \"c++\" } {\n+      check_format_string \"a_point_t_ref\" $opts\n+      check_format_string \"a_base_ref\" $opts\n+    }\n+  }\n+\n+  # Both 1,000 (we don't have that many elements) and 0 (unlimited) should\n+  # mean no truncation.\n+  foreach opts { \"max_elements=1000\" \"max_elements=0\" } {\n+    with_test_prefix $opts {\n+      check_format_string \"a_point_t\" $opts\n+      check_format_string \"a_point_t_pointer\" $opts\n+      check_format_string \"another_point\" $opts\n+      check_format_string \"a_struct_with_union\" $opts\n+      check_format_string \"an_enum\" $opts\n+      check_format_string \"a_string\" $opts\n+      check_format_string \"a_binary_string\" $opts\n+      check_format_string \"a_binary_string_array\" $opts\n+      check_format_string \"a_big_string\" $opts \\\n+        [get_cut_big_string 1000]\n+      check_format_string \"an_array\" $opts\n+      check_format_string \"an_array_with_repetition\" $opts\n+      check_format_string \"a_symbol_pointer\" $opts\n+\n+      if { $current_lang == \"c++\" } {\n+        check_format_string \"a_point_t_ref\" $opts\n+        check_format_string \"a_base_ref\" $opts\n+      }\n+    }\n+  }\n+\n+  with_temp_option \"set print elements 4\" \"set print elements 200\" {\n+    check_format_string \"a_string\" \"\" \\\n+      \"${default_pointer_regexp} \\\"hell\\\"...\"\n+    check_format_string \"a_binary_string\" \"\" \\\n+      \"${default_pointer_regexp} \\\"hell\\\"...\"\n+    check_format_string \"a_binary_string_array\" \"\" \\\n+      \"\\\"hell\\\"...\"\n+    check_format_string \"an_array_with_repetition\" \"\" \\\n+      \"\\\\{1, 3 <repeats 12 times>...\\\\}\"\n+  }\n+}\n+\n+# Test the repeat_threshold option for gdb.Value.format_string.\n+proc test_repeat_threshold {} {\n+  global current_lang\n+  global default_pointer_regexp\n+\n+  # 10 is the default threshold for repeated items, so setting it should\n+  # not change the output.\n+  set opts \"repeat_threshold=10\"\n+  with_test_prefix $opts {\n+    check_format_string \"a_point_t\" $opts\n+    check_format_string \"a_point_t_pointer\" $opts\n+    check_format_string \"another_point\" $opts\n+    check_format_string \"a_struct_with_union\" $opts\n+    check_format_string \"an_enum\" $opts\n+    check_format_string \"a_string\" $opts\n+    check_format_string \"a_binary_string\" $opts\n+    check_format_string \"a_binary_string_array\" $opts\n+    check_format_string \"a_big_string\" $opts\n+    check_format_string \"an_array\" $opts\n+    check_format_string \"an_array_with_repetition\" $opts\n+    check_format_string \"a_symbol_pointer\" $opts\n+\n+    if { $current_lang == \"c++\" } {\n+      check_format_string \"a_point_t_ref\" $opts\n+      check_format_string \"a_base_ref\" $opts\n+    }\n+  }\n+\n+  set opts \"repeat_threshold=1\"\n+  with_test_prefix $opts {\n+    check_format_string \"a_point_t\" $opts\n+    check_format_string \"a_point_t_pointer\" $opts\n+    check_format_string \"another_point\" $opts\n+    check_format_string \"a_struct_with_union\" $opts\n+    check_format_string \"an_enum\" $opts\n+    check_format_string \"a_string\" $opts \\\n+      \"${default_pointer_regexp} \\\"he\\\", 'l' <repeats 2 times>, \\\"o world\\\"\"\n+    check_format_string \"a_binary_string\" $opts \\\n+      \"${default_pointer_regexp} \\\"he\\\", 'l' <repeats 2 times>, \\\"o\\\"\"\n+    check_format_string \"a_binary_string_array\" $opts \\\n+      \"\\\"he\\\", 'l' <repeats 2 times>, \\\"o\\\\\\\\000world\\\"\"\n+    check_format_string \"a_big_string\" $opts\n+    check_format_string \"an_array\" $opts\n+    check_format_string \"an_array_with_repetition\" $opts \\\n+      \"\\\\{1, 3 <repeats 12 times>, 5 <repeats 3 times>\\\\}\"\n+\n+    check_format_string \"a_symbol_pointer\" $opts\n+\n+    if { $current_lang == \"c++\" } {\n+      check_format_string \"a_point_t_ref\" $opts\n+      check_format_string \"a_base_ref\" $opts\n+    }\n+  }\n+\n+  set opts \"repeat_threshold=3\"\n+  with_test_prefix $opts {\n+    check_format_string \"a_point_t\" $opts\n+    check_format_string \"a_point_t_pointer\" $opts\n+    check_format_string \"another_point\" $opts\n+    check_format_string \"a_struct_with_union\" $opts\n+    check_format_string \"an_enum\" $opts\n+    check_format_string \"a_string\" $opts\n+    check_format_string \"a_binary_string\" $opts\n+    check_format_string \"a_binary_string_array\" $opts\n+    check_format_string \"a_big_string\" $opts\n+    check_format_string \"an_array\" $opts\n+    check_format_string \"an_array_with_repetition\" $opts\n+    check_format_string \"a_symbol_pointer\" $opts\n+\n+    if { $current_lang == \"c++\" } {\n+      check_format_string \"a_point_t_ref\" $opts\n+      check_format_string \"a_base_ref\" $opts\n+    }\n+  }\n+\n+  # Both 100 (we don't have that many repeated elements) and 0 (unlimited)\n+  # should mean no truncation.\n+  foreach opts { \"repeat_threshold=100\" \"repeat_threshold=0\" } {\n+    with_test_prefix $opts {\n+      check_format_string \"a_point_t\" $opts\n+      check_format_string \"a_point_t_pointer\" $opts\n+      check_format_string \"another_point\" $opts\n+      check_format_string \"a_struct_with_union\" $opts\n+      check_format_string \"an_enum\" $opts\n+      check_format_string \"a_string\" $opts\n+      check_format_string \"a_binary_string\" $opts\n+      check_format_string \"a_binary_string_array\" $opts\n+      check_format_string \"a_big_string\" $opts\n+      check_format_string \"an_array\" $opts\n+      check_format_string \"an_array_with_repetition\" $opts \\\n+        \"\\\\{1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 5, 5\\\\}\"\n+      check_format_string \"a_symbol_pointer\" $opts\n+\n+      if { $current_lang == \"c++\" } {\n+        check_format_string \"a_point_t_ref\" $opts\n+        check_format_string \"a_base_ref\" $opts\n+      }\n+    }\n+  }\n+\n+  with_temp_option \"set print repeats 1\" \"set print repeats 10\" {\n+    check_format_string \"an_array_with_repetition\" \"\" \\\n+      \"\\\\{1, 3 <repeats 12 times>, 5 <repeats 3 times>\\\\}\"\n+  }\n+}\n+\n+# Test the format option for gdb.Value.format_string.\n+proc test_format {} {\n+  global current_lang\n+  global default_pointer_regexp\n+\n+  # Hexadecimal.\n+  set opts \"format='x'\"\n+  with_test_prefix $opts {\n+    gdb_test \"python print (gdb.Value (42).format_string (${opts}))\" \\\n+      \"0x2a\" \\\n+      \"42 with option ${opts}\"\n+\n+    check_format_string \"a_point_t\" $opts\n+    check_format_string \"a_point_t_pointer\" $opts\n+    check_format_string \"another_point\" $opts\n+    check_format_string \"a_struct_with_union\" $opts \\\n+      \"\\\\{the_union = \\\\{an_int = 0x2a, a_char = 0x2a\\\\}\\\\}\"\n+    check_format_string \"an_enum\" $opts \\\n+      \"0x1\"\n+    check_format_string \"a_string\" $opts \\\n+      $default_pointer_regexp\n+    check_format_string \"a_binary_string\" $opts \\\n+      $default_pointer_regexp\n+    check_format_string \"a_binary_string_array\" $opts \\\n+      \"\\\\{0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x0, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x0\\\\}\"\n+    check_format_string \"a_big_string\" $opts \\\n+      \"\\\\{0x41, 0x42, 0x43, 0x44, 0x45, \\[, x0-9a-f\\]+\\.\\.\\.\\\\}\"\n+    check_format_string \"an_array\" $opts \\\n+      \"\\\\{0x2, 0x3, 0x5\\\\}\"\n+    check_format_string \"an_array_with_repetition\" $opts \\\n+      \"\\\\{0x1, 0x3 <repeats 12 times>, 0x5, 0x5, 0x5\\\\}\"\n+    check_format_string \"a_symbol_pointer\" $opts \\\n+      $default_pointer_regexp\n+\n+    if { $current_lang == \"c++\" } {\n+      check_format_string \"a_point_t_ref\" $opts\n+      check_format_string \"a_base_ref\" $opts\n+    }\n+  }\n+\n+  # Decimal.\n+  set opts \"format='d'\"\n+  with_test_prefix $opts {\n+    set decimal_pointer_regexp \"\\[0-9\\]+\"\n+    gdb_test \"python print (gdb.Value (0x2a).format_string (${opts}))\" \\\n+      \"42\" \\\n+      \"0x2a with option ${opts}\"\n+\n+    check_format_string \"a_point_t\" $opts\n+    check_format_string \"a_point_t_pointer\" $opts \\\n+      $decimal_pointer_regexp\n+    check_format_string \"another_point\" $opts\n+    check_format_string \"a_struct_with_union\" $opts \\\n+      \"\\\\{the_union = \\\\{an_int = 42, a_char = 42\\\\}\\\\}\"\n+    check_format_string \"an_enum\" $opts \\\n+      \"1\"\n+    check_format_string \"a_string\" $opts \\\n+      $decimal_pointer_regexp\n+    check_format_string \"a_binary_string\" $opts \\\n+      $decimal_pointer_regexp\n+    check_format_string \"a_binary_string_array\" $opts \\\n+      \"\\\\{104, 101, 108, 108, 111, 0, 119, 111, 114, 108, 100, 0\\\\}\"\n+    check_format_string \"a_big_string\" $opts \\\n+      \"\\\\{65, 66, 67, 68, 69, \\[, 0-9\\]+\\.\\.\\.\\\\}\"\n+    check_format_string \"an_array\" $opts\n+    check_format_string \"an_array_with_repetition\" $opts\n+    check_format_string \"a_symbol_pointer\" $opts \\\n+      $decimal_pointer_regexp\n+\n+    if { $current_lang == \"c++\" } {\n+      check_format_string \"a_point_t_ref\" $opts\n+      check_format_string \"a_base_ref\" $opts\n+    }\n+  }\n+}\n+\n+# Test mixing options.\n+proc test_mixed {} {\n+  global current_lang\n+  global default_ref_regexp\n+  global default_pointer_regexp\n+\n+  check_format_string \"a_point_t\" \\\n+    \"raw=True, format='x'\" \\\n+    \"\\\\{x = 0x2a, y = 0xc\\\\}\"\n+\n+  check_format_string \"an_array\" \\\n+    \"array_indexes=True, pretty_arrays=True\" \\\n+    \"  \\\\{\\\\\\[0\\\\\\] = 2,\\[\\r\\n\\]+  \\\\\\[1\\\\\\] = 3,\\[\\r\\n\\]+  \\\\\\[2\\\\\\] = 5\\\\}\"\n+\n+  check_format_string \"a_struct_with_union\" \\\n+    \"pretty_structs=True, unions=False\" \\\n+    \"\\\\{\\[\\r\\n\\]+  the_union = \\\\{\\.\\.\\.\\\\}\\[\\r\\n\\]+\\\\}\"\n+\n+  check_format_string \"a_symbol_pointer\" \\\n+    \"symbols=False, format='d'\" \\\n+    \"\\[0-9\\]+\"\n+\n+  if { $current_lang == \"c++\" } {\n+    check_format_string \"a_point_t_ref\" \\\n+      \"deref_refs=True, actual_objects=True, raw=True\" \\\n+      \"${default_ref_regexp}: \\\\{x = 42, y = 12\\\\}\"\n+\n+    check_format_string \"a_base_ref\" \\\n+      \"deref_refs=True, static_members=False\" \\\n+      \"${default_ref_regexp}: \\\\{_vptr\\\\.Base = ${default_pointer_regexp} <vtable for Deriv\\\\+16>, a = 42\\\\}\"\n+  }\n+}\n+\n+# Test passing invalid arguments to gdb.Value.format_string.\n+proc test_invalid_args {} {\n+  check_format_string \\\n+    \"a_point_t\" \\\n+    \"12\" \\\n+    \"TypeError: format_string\\\\(\\\\) takes 0 positional arguments but 1 were given.*\"\n+\n+  check_format_string \\\n+    \"a_point_t\" \\\n+    \"invalid=True\" \\\n+    \"TypeError: 'invalid' is an invalid keyword argument for this function.*\"\n+\n+  check_format_string \\\n+    \"a_point_t\" \\\n+    \"raw='hello'\" \\\n+    \"TypeError: argument 1 must be bool, not str.*\"\n+\n+  check_format_string \\\n+    \"a_point_t\" \\\n+    \"format='xd'\" \\\n+    \"ValueError: a single character is required.*\"\n+}\n+\n+# Run all the tests in common for both C and C++.\n+proc test_all_common {} {\n+  # No options.\n+  test_no_opts\n+  # Single options set to True/False.\n+  test_raw\n+  test_pretty_arrays\n+  test_pretty_structs\n+  test_array_indexes\n+  test_symbols\n+  test_unions\n+  test_deref_refs\n+  test_actual_objects\n+  test_static_members\n+  test_max_elements\n+  test_repeat_threshold\n+  test_format\n+  # Multiple options mixed together.\n+  test_mixed\n+  # Various error conditions.\n+  test_invalid_args\n+}\n+\n+# The current language (\"c\" or \"c++\" while running tests).\n+set current_lang \"\"\n+\n+with_test_prefix \"format_string\" {\n+  # Perform C Tests.\n+  if { [build_inferior \"${binfile}\" \"c\"] == 0 } {\n+    with_test_prefix \"lang_c\" {\n+      set current_lang \"c\"\n+      prepare_gdb \"${binfile}\"\n+      test_all_common\n+    }\n+  }\n+\n+  # Perform C++ Tests.\n+  if { [build_inferior \"${binfile}-cxx\" \"c++\"] == 0 } {\n+    with_test_prefix \"lang_cpp\" {\n+      set current_lang \"c++\"\n+      prepare_gdb \"${binfile}-cxx\"\n+      test_all_common\n+    }\n+  }\n+}"
    },
    {
      "sha": "c2ad88e862bb094a09016716aca4716a18828d9f",
      "filename": "gdb/testsuite/gdb.python/py-format-string.py",
      "status": "added",
      "additions": 49,
      "deletions": 0,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/testsuite/gdb.python/py-format-string.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52093e1b936fa4f3f8bb3868c5a44d0df25c8db4/gdb/testsuite/gdb.python/py-format-string.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-format-string.py?ref=52093e1b936fa4f3f8bb3868c5a44d0df25c8db4",
      "patch": "@@ -0,0 +1,49 @@\n+# Copyright (C) 2008-2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This file is part of the GDB testsuite.  It tests python pretty\n+# printers.\n+\n+import gdb\n+\n+class PointPrinter (object):\n+    def __init__ (self, val):\n+        self.val = val\n+\n+    def to_string (self):\n+        return 'Pretty Point (%s, %s)' % (self.val['x'], self.val['y'])\n+\n+def test_lookup_function (val):\n+    \"Look-up and return a pretty-printer that can print val.\"\n+\n+    # Get the type.\n+    type = val.type\n+\n+    # If it points to a reference, get the reference.\n+    if type.code == gdb.TYPE_CODE_REF:\n+        type = type.target ()\n+\n+    # Get the unqualified type, stripped of typedefs.\n+    type = type.unqualified ().strip_typedefs ()\n+\n+    # Get the type name.\n+    typename = type.tag\n+\n+    if typename == 'point':\n+        return PointPrinter (val)\n+\n+    return None\n+\n+gdb.pretty_printers.append (test_lookup_function)"
    }
  ]
}