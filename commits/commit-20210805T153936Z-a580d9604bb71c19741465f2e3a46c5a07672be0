{
  "sha": "a580d9604bb71c19741465f2e3a46c5a07672be0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTU4MGQ5NjA0YmI3MWMxOTc0MTQ2NWYyZTNhNDZjNWEwNzY3MmJlMA==",
  "commit": {
    "author": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2020-09-14T16:02:29Z"
    },
    "committer": {
      "name": "Zoran Zaric",
      "email": "zoran.zaric@amd.com",
      "date": "2021-08-05T15:39:36Z"
    },
    "message": "Move compilation unit info to dwarf_expr_context\n\nThis patch moves the compilation unit context information and support\nfrom dwarf_expr_executor and dwarf_evaluate_loc_desc to\ndwarf_expr_context evaluator. The idea is to report an error when a\ngiven operation requires a compilation unit information to be resolved,\nwhich is not available.\n\nWith this change, it also makes sense to always acquire ref_addr_size\ninformation from the compilation unit context, considering that all\nDWARF operations that refer to that information require a compilation\nunit context to be present during their evaluation.\n\ngdb/ChangeLog:\n\n\t* dwarf2/expr.c (ensure_have_per_cu): New function.\n\t(dwarf_expr_context::dwarf_expr_context): Add compilation unit\n\tcontext information.\n\t(dwarf_expr_context::get_base_type): Move from\n\tdwarf_evaluate_loc_desc.\n\t(dwarf_expr_context::get_addr_index): Remove method.\n\t(dwarf_expr_context::dwarf_variable_value): Remove method.\n\t(dwarf_expr_context::execute_stack_op): Call compilation unit\n\tcontext info check. Inline get_addr_index and\n\tdwarf_variable_value methods.\n\t* dwarf2/expr.h (struct dwarf_expr_context): Add compilation\n\tcontext info.\n        (dwarf_expr_context::get_addr_index): Remove method.\n        (dwarf_expr_context::dwarf_variable_value): Remove method.\n        (dwarf_expr_context::ref_addr_size): Remove member.\n\t* dwarf2/frame.c (dwarf_expr_executor::get_addr_index): Remove\n\tmethod.\n\t(dwarf_expr_executor::dwarf_variable_value): Remove method.\n\t* dwarf2/loc.c (sect_variable_value): Expose function.\n\t(dwarf_evaluate_loc_desc::get_addr_index): Remove method.\n\t(dwarf_evaluate_loc_desc::dwarf_variable_value): Remove method.\n\t(class dwarf_evaluate_loc_desc): Move compilation unit context\n\tinformation to dwarf_expr_context class.\n\t* dwarf2/loc.h (sect_variable_value): Expose function.",
    "tree": {
      "sha": "90f1099bf62a413710f2e0f464fe96ece9da0666",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/90f1099bf62a413710f2e0f464fe96ece9da0666"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a580d9604bb71c19741465f2e3a46c5a07672be0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a580d9604bb71c19741465f2e3a46c5a07672be0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a580d9604bb71c19741465f2e3a46c5a07672be0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a580d9604bb71c19741465f2e3a46c5a07672be0/comments",
  "author": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "ZaricZoran",
    "id": 81635026,
    "node_id": "MDQ6VXNlcjgxNjM1MDI2",
    "avatar_url": "https://avatars.githubusercontent.com/u/81635026?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/ZaricZoran",
    "html_url": "https://github.com/ZaricZoran",
    "followers_url": "https://api.github.com/users/ZaricZoran/followers",
    "following_url": "https://api.github.com/users/ZaricZoran/following{/other_user}",
    "gists_url": "https://api.github.com/users/ZaricZoran/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/ZaricZoran/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/ZaricZoran/subscriptions",
    "organizations_url": "https://api.github.com/users/ZaricZoran/orgs",
    "repos_url": "https://api.github.com/users/ZaricZoran/repos",
    "events_url": "https://api.github.com/users/ZaricZoran/events{/privacy}",
    "received_events_url": "https://api.github.com/users/ZaricZoran/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6c7779b34b38ca71df9460c07bc4c03d01dfaa0b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6c7779b34b38ca71df9460c07bc4c03d01dfaa0b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6c7779b34b38ca71df9460c07bc4c03d01dfaa0b"
    }
  ],
  "stats": {
    "total": 157,
    "additions": 75,
    "deletions": 82
  },
  "files": [
    {
      "sha": "812dac08a13e5e752e6ac005987f48a9c532f5e5",
      "filename": "gdb/dwarf2/expr.c",
      "status": "modified",
      "additions": 56,
      "deletions": 16,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/expr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/expr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.c?ref=a580d9604bb71c19741465f2e3a46c5a07672be0",
      "patch": "@@ -68,6 +68,16 @@ ensure_have_frame (frame_info *frame, const char *op_name)\n \t\t _(\"%s evaluation requires a frame.\"), op_name);\n }\n \n+/* Ensure that a PER_CU is defined and throw an exception otherwise.  */\n+\n+static void\n+ensure_have_per_cu (dwarf2_per_cu_data *per_cu, const char* op_name)\n+{\n+  if (per_cu == nullptr)\n+    throw_error (GENERIC_ERROR,\n+\t\t _(\"%s evaluation requires a compilation unit.\"), op_name);\n+}\n+\n /* See expr.h.  */\n \n CORE_ADDR\n@@ -197,6 +207,23 @@ dwarf_expr_context::get_frame_base (const gdb_byte **start,\n \t\t\t\t   start, length);\n }\n \n+/* See expr.h.  */\n+\n+struct type *\n+dwarf_expr_context::get_base_type (cu_offset die_cu_off)\n+{\n+  if (per_cu == nullptr)\n+    return builtin_type (this->gdbarch)->builtin_int;\n+\n+  struct type *result = dwarf2_get_die_type (die_cu_off, this->per_cu,\n+\t\t\t\t\t     this->per_objfile);\n+\n+  if (result == nullptr)\n+    error (_(\"Could not find type for operation\"));\n+\n+  return result;\n+}\n+\n /* Require that TYPE be an integral type; throw an exception if not.  */\n \n static void\n@@ -693,14 +720,20 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \tcase DW_OP_addrx:\n \tcase DW_OP_GNU_addr_index:\n+\t  ensure_have_per_cu (this->per_cu, \"DW_OP_addrx\");\n+\n \t  op_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);\n-\t  result = this->get_addr_index (uoffset);\n+\t  result = dwarf2_read_addr_index (this->per_cu, this->per_objfile,\n+\t\t\t\t\t   uoffset);\n \t  result += this->per_objfile->objfile->text_section_offset ();\n \t  result_val = value_from_ulongest (address_type, result);\n \t  break;\n \tcase DW_OP_GNU_const_index:\n+\t  ensure_have_per_cu (this->per_cu, \"DW_OP_GNU_const_index\");\n+\n \t  op_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);\n-\t  result = this->get_addr_index (uoffset);\n+\t  result = dwarf2_read_addr_index (this->per_cu, this->per_objfile,\n+\t\t\t\t\t   uoffset);\n \t  result_val = value_from_ulongest (address_type, result);\n \t  break;\n \n@@ -830,15 +863,14 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \tcase DW_OP_GNU_implicit_pointer:\n \t  {\n \t    int64_t len;\n+\t    ensure_have_per_cu (this->per_cu, \"DW_OP_implicit_pointer\");\n \n-\t    if (this->ref_addr_size == -1)\n-\t      error (_(\"DWARF-2 expression error: DW_OP_implicit_pointer \"\n-\t\t       \"is not allowed in frame context\"));\n+\t    int ref_addr_size = this->per_cu->ref_addr_size ();\n \n \t    /* The referred-to DIE of sect_offset kind.  */\n-\t    this->len = extract_unsigned_integer (op_ptr, this->ref_addr_size,\n-\t\t\t\t\t\t byte_order);\n-\t    op_ptr += this->ref_addr_size;\n+\t    this->len = extract_unsigned_integer (op_ptr, ref_addr_size,\n+\t\t\t\t\t\t  byte_order);\n+\t    op_ptr += ref_addr_size;\n \n \t    /* The byte offset into the data.  */\n \t    op_ptr = safe_read_sleb128 (op_ptr, op_end, &len);\n@@ -1004,7 +1036,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t      {\n \t\top_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);\n \t\tcu_offset type_die_cu_off = (cu_offset) uoffset;\n-\t\ttype = get_base_type (type_die_cu_off, 0);\n+\t\ttype = get_base_type (type_die_cu_off);\n \t      }\n \t    else\n \t      type = address_type;\n@@ -1327,13 +1359,17 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \n \tcase DW_OP_GNU_variable_value:\n \t  {\n+\t    ensure_have_per_cu (this->per_cu, \"DW_OP_GNU_variable_value\");\n+\t    int ref_addr_size = this->per_cu->ref_addr_size ();\n+\n \t    sect_offset sect_off\n \t      = (sect_offset) extract_unsigned_integer (op_ptr,\n-\t\t\t\t\t\t\tthis->ref_addr_size,\n+\t\t\t\t\t\t\tref_addr_size,\n \t\t\t\t\t\t\tbyte_order);\n-\t    op_ptr += this->ref_addr_size;\n-\t    result_val = value_cast (address_type,\n-\t\t\t\t     this->dwarf_variable_value (sect_off));\n+\t    op_ptr += ref_addr_size;\n+\t    result_val = sect_variable_value (sect_off, this->per_cu,\n+\t\t\t\t\t      this->per_objfile);\n+\t    result_val = value_cast (address_type, result_val);\n \t  }\n \t  break;\n \t\n@@ -1403,7 +1439,11 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    data = op_ptr;\n \t    op_ptr += n;\n \n-\t    type = get_base_type (type_die_cu_off, n);\n+\t    type = get_base_type (type_die_cu_off);\n+\n+\t    if (TYPE_LENGTH (type) != n)\n+\t      error (_(\"DW_OP_const_type has different sizes for type and data\"));\n+\n \t    result_val = value_from_contents (type, data);\n \t  }\n \t  break;\n@@ -1417,7 +1457,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    op_ptr = safe_read_uleb128 (op_ptr, op_end, &uoffset);\n \t    cu_offset type_die_cu_off = (cu_offset) uoffset;\n \n-\t    type = get_base_type (type_die_cu_off, 0);\n+\t    type = get_base_type (type_die_cu_off);\n \t    result_val = this->get_reg_value (type, reg);\n \t  }\n \t  break;\n@@ -1435,7 +1475,7 @@ dwarf_expr_context::execute_stack_op (const gdb_byte *op_ptr,\n \t    if (to_underlying (type_die_cu_off) == 0)\n \t      type = address_type;\n \t    else\n-\t      type = get_base_type (type_die_cu_off, 0);\n+\t      type = get_base_type (type_die_cu_off);\n \n \t    result_val = fetch (0);\n \t    pop ();"
    },
    {
      "sha": "76c4672653b10941b3291f1fa1f5fb045a3a1aa5",
      "filename": "gdb/dwarf2/expr.h",
      "status": "modified",
      "additions": 8,
      "deletions": 21,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/expr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/expr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/expr.h?ref=a580d9604bb71c19741465f2e3a46c5a07672be0",
      "patch": "@@ -137,10 +137,6 @@ struct dwarf_expr_context\n   /* Target address size in bytes.  */\n   int addr_size = 0;\n \n-  /* DW_FORM_ref_addr size in bytes.  If -1 DWARF is executed from a frame\n-     context and operations depending on DW_FORM_ref_addr are not allowed.  */\n-  int ref_addr_size = 0;\n-\n   /* The current depth of dwarf expression recursion, via DW_OP_call*,\n      DW_OP_fbreg, DW_OP_push_object_address, etc., and the maximum\n      depth we'll tolerate before raising an error.  */\n@@ -189,6 +185,9 @@ struct dwarf_expr_context\n   /* Frame information used for the evaluation.  */\n   frame_info *frame = nullptr;\n \n+  /* Compilation unit used for the evaluation.  */\n+  dwarf2_per_cu_data *per_cu = nullptr;\n+\n   /* Read LENGTH bytes at ADDR into BUF.  */\n   virtual void read_mem (gdb_byte *buf, CORE_ADDR addr, size_t length) = 0;\n \n@@ -208,19 +207,6 @@ struct dwarf_expr_context\n      subroutine.  */\n   virtual void dwarf_call (cu_offset die_cu_off) = 0;\n \n-  /* Execute \"variable value\" operation on the DIE at SECT_OFF.  */\n-  virtual struct value *dwarf_variable_value (sect_offset sect_off) = 0;\n-\n-  /* Return the base type given by the indicated DIE at DIE_CU_OFF.\n-     This can throw an exception if the DIE is invalid or does not\n-     represent a base type.  SIZE is non-zero if this function should\n-     verify that the resulting type has the correct size.  */\n-  virtual struct type *get_base_type (cu_offset die_cu_off, int size)\n-  {\n-    /* Anything will do.  */\n-    return builtin_type (this->gdbarch)->builtin_int;\n-  }\n-\n   /* Push on DWARF stack an entry evaluated for DW_TAG_call_site's\n      parameter matching KIND and KIND_U at the caller of specified BATON.\n      If DEREF_SIZE is not -1 then use DW_AT_call_data_value instead of\n@@ -229,10 +215,6 @@ struct dwarf_expr_context\n \t\t\t\t\t   union call_site_parameter_u kind_u,\n \t\t\t\t\t   int deref_size) = 0;\n \n-  /* Return the address indexed by DW_OP_addrx or DW_OP_GNU_addr_index.\n-     This can throw an exception if the index is out of range.  */\n-  virtual CORE_ADDR get_addr_index (unsigned int index) = 0;\n-\n   /* Return the `object address' for DW_OP_push_object_address.  */\n   virtual CORE_ADDR get_object_address () = 0;\n \n@@ -255,6 +237,11 @@ struct dwarf_expr_context\n      START and LENGTH.  The result must be live until the current\n      expression evaluation is complete.  */\n   void get_frame_base (const gdb_byte **start, size_t *length);\n+\n+  /* Return the base type given by the indicated DIE at DIE_CU_OFF.\n+     This can throw an exception if the DIE is invalid or does not\n+     represent a base type.  */\n+  struct type *get_base_type (cu_offset die_cu_off);\n };\n \n /* Return the value of register number REG (a DWARF register number),"
    },
    {
      "sha": "c519197cb4cbecf228d553fc07663aeb41d863e2",
      "filename": "gdb/dwarf2/frame.c",
      "status": "modified",
      "additions": 0,
      "deletions": 11,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame.c?ref=a580d9604bb71c19741465f2e3a46c5a07672be0",
      "patch": "@@ -259,16 +259,6 @@ class dwarf_expr_executor : public dwarf_expr_context\n     invalid (\"DW_OP_call*\");\n   }\n \n-  struct value *dwarf_variable_value (sect_offset sect_off) override\n-  {\n-    invalid (\"DW_OP_GNU_variable_value\");\n-  }\n-\n-  CORE_ADDR get_addr_index (unsigned int index) override\n-  {\n-    invalid (\"DW_OP_addrx or DW_OP_GNU_addr_index\");\n-  }\n-\n  private:\n \n   void invalid (const char *op) ATTRIBUTE_NORETURN\n@@ -290,7 +280,6 @@ execute_stack_op (const gdb_byte *exp, ULONGEST len, int addr_size,\n   ctx.frame = this_frame;\n   ctx.gdbarch = get_frame_arch (this_frame);\n   ctx.addr_size = addr_size;\n-  ctx.ref_addr_size = -1;\n \n   ctx.push_address (initial, initial_in_stack_memory);\n   ctx.eval (exp, len);"
    },
    {
      "sha": "7e565d318910520796fd54e3b95e7abfd0b6f60d",
      "filename": "gdb/dwarf2/loc.c",
      "status": "modified",
      "additions": 3,
      "deletions": 34,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/loc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/loc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.c?ref=a580d9604bb71c19741465f2e3a46c5a07672be0",
      "patch": "@@ -651,12 +651,10 @@ compute_var_value (const char *name)\n   return nullptr;\n }\n \n-/* Given context CTX, section offset SECT_OFF, and compilation unit\n-   data PER_CU, execute the \"variable value\" operation on the DIE\n-   found at SECT_OFF.  */\n+/* See loc.h.  */\n \n-static struct value *\n-sect_variable_value (struct dwarf_expr_context *ctx, sect_offset sect_off,\n+struct value *\n+sect_variable_value (sect_offset sect_off,\n \t\t     dwarf2_per_cu_data *per_cu,\n \t\t     dwarf2_per_objfile *per_objfile)\n {\n@@ -696,7 +694,6 @@ class dwarf_evaluate_loc_desc : public dwarf_expr_context\n     : dwarf_expr_context (per_objfile)\n   {}\n \n-  struct dwarf2_per_cu_data *per_cu;\n   CORE_ADDR obj_address;\n \n   /* Helper function for dwarf2_evaluate_loc_desc.  Computes the PC for\n@@ -722,32 +719,6 @@ class dwarf_evaluate_loc_desc : public dwarf_expr_context\n     per_cu_dwarf_call (this, die_offset, per_cu, per_objfile);\n   }\n \n-  /* Helper interface of sect_variable_value for\n-     dwarf2_evaluate_loc_desc.  */\n-\n-  struct value *dwarf_variable_value (sect_offset sect_off) override\n-  {\n-    return sect_variable_value (this, sect_off, per_cu, per_objfile);\n-  }\n-\n-  struct type *get_base_type (cu_offset die_offset, int size) override\n-  {\n-    struct type *result = dwarf2_get_die_type (die_offset, per_cu, per_objfile);\n-    if (result == NULL)\n-      error (_(\"Could not find type for DW_OP_const_type\"));\n-    if (size != 0 && TYPE_LENGTH (result) != size)\n-      error (_(\"DW_OP_const_type has different sizes for type and data\"));\n-    return result;\n-  }\n-\n-  /* Callback function for dwarf2_evaluate_loc_desc.\n-     Fetch the address indexed by DW_OP_addrx or DW_OP_GNU_addr_index.  */\n-\n-  CORE_ADDR get_addr_index (unsigned int index) override\n-  {\n-    return dwarf2_read_addr_index (per_cu, per_objfile, index);\n-  }\n-\n   /* Callback function for get_object_address. Return the address of the VLA\n      object.  */\n \n@@ -2237,7 +2208,6 @@ dwarf2_evaluate_loc_desc_full (struct type *type, struct frame_info *frame,\n \n   ctx.gdbarch = per_objfile->objfile->arch ();\n   ctx.addr_size = per_cu->addr_size ();\n-  ctx.ref_addr_size = per_cu->ref_addr_size ();\n \n   try\n     {\n@@ -2504,7 +2474,6 @@ dwarf2_locexpr_baton_eval (const struct dwarf2_locexpr_baton *dlbaton,\n \n   ctx.gdbarch = per_objfile->objfile->arch ();\n   ctx.addr_size = dlbaton->per_cu->addr_size ();\n-  ctx.ref_addr_size = dlbaton->per_cu->ref_addr_size ();\n \n   if (push_initial_value)\n     ctx.push_address (ctx.obj_address, false);"
    },
    {
      "sha": "9929a4aa00fadc8956b1d2bf42b0317b8436857a",
      "filename": "gdb/dwarf2/loc.h",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/loc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a580d9604bb71c19741465f2e3a46c5a07672be0/gdb/dwarf2/loc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/loc.h?ref=a580d9604bb71c19741465f2e3a46c5a07672be0",
      "patch": "@@ -53,6 +53,14 @@ extern void func_get_frame_base_dwarf_block (struct symbol *framefunc,\n \t\t\t\t\t     const gdb_byte **start,\n \t\t\t\t\t     size_t *length);\n \n+/* Given section offset SECT_OFF, and compilation unit data\n+   PER_CU, execute the \"variable value\" operation on the DIE\n+   found at SECT_OFF.  */\n+\n+struct value *sect_variable_value (sect_offset sect_off,\n+\t\t\t\t   dwarf2_per_cu_data *per_cu,\n+\t\t\t\t   dwarf2_per_objfile *per_objfile);\n+\n /* Evaluate a location description, starting at DATA and with length\n    SIZE, to find the current location of variable of TYPE in the context\n    of FRAME.  */"
    }
  ]
}