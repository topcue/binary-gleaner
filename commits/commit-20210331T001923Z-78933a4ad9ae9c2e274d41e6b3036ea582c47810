{
  "sha": "78933a4ad9ae9c2e274d41e6b3036ea582c47810",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Nzg5MzNhNGFkOWFlOWMyZTI3NGQ0MWU2YjMwMzZlYTU4MmM0NzgxMA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:06:19Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:19:23Z"
    },
    "message": "Use bool in opcodes\n\ncpu/\n\t* frv.opc: Replace bfd_boolean with bool, FALSE with false, and\n\tTRUE with true throughout.\nopcodes/\n\t* sysdep.h (POISON_BFD_BOOLEAN): Define.\n\t* aarch64-asm-2.c, * aarch64-asm.c, * aarch64-asm.h,\n\t* aarch64-dis-2.c, * aarch64-dis.c, * aarch64-dis.h,\n\t* aarch64-gen.c, * aarch64-opc.c, * aarch64-opc.h, * arc-dis.c,\n\t* arc-dis.h, * arc-fxi.h, * arc-opc.c, * arm-dis.c, * bfin-dis.c,\n\t* cris-dis.c, * csky-dis.c, * csky-opc.h, * dis-buf.c,\n\t* disassemble.c, * frv-opc.c, * frv-opc.h, * h8300-dis.c,\n\t* i386-dis.c, * m68k-dis.c, * metag-dis.c, * microblaze-dis.c,\n\t* microblaze-dis.h, * micromips-opc.c, * mips-dis.c,\n\t* mips-formats.h, * mips-opc.c, * mips16-opc.c, * mmix-dis.c,\n\t* msp430-dis.c, * nds32-dis.c, * nfp-dis.c, * nios2-dis.c,\n\t* ppc-dis.c, * riscv-dis.c, * score-dis.c, * score7-dis.c,\n\t* tic6x-dis.c, * v850-dis.c, * vax-dis.c, * wasm32-dis.c,\n\t* xtensa-dis.c: Replace bfd_boolean with bool, FALSE with false,\n\tand TRUE with true throughout.",
    "tree": {
      "sha": "d88281747f95a9e279e16043aaf57c7093481d85",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d88281747f95a9e279e16043aaf57c7093481d85"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/78933a4ad9ae9c2e274d41e6b3036ea582c47810",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78933a4ad9ae9c2e274d41e6b3036ea582c47810",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/78933a4ad9ae9c2e274d41e6b3036ea582c47810",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78933a4ad9ae9c2e274d41e6b3036ea582c47810/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    }
  ],
  "stats": {
    "total": 3323,
    "additions": 1673,
    "deletions": 1650
  },
  "files": [
    {
      "sha": "f6e50879c232a04b362f81e0ae0f789002772d9c",
      "filename": "cpu/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/cpu/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/cpu/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/ChangeLog?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-31  Alan Modra  <amodra@gmail.com>\n+\n+\t* frv.opc: Replace bfd_boolean with bool, FALSE with false, and\n+\tTRUE with true throughout.\n+\n 2021-03-29  Alan Modra  <amodra@gmail.com>\n \n \t* frv.opc (frv_is_branch_major, frv_is_float_major),"
    },
    {
      "sha": "54acb9c902a5f7609d433ec09449e1a9dc318cc6",
      "filename": "cpu/frv.opc",
      "status": "modified",
      "additions": 77,
      "deletions": 77,
      "changes": 154,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/cpu/frv.opc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/cpu/frv.opc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/cpu/frv.opc?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -66,15 +66,15 @@ typedef struct\n   const CGEN_INSN *      insn[FRV_VLIW_SIZE];\n } FRV_VLIW;\n \n-bfd_boolean frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n-bfd_boolean frv_is_float_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n-bfd_boolean frv_is_media_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n-bfd_boolean frv_is_branch_insn  (const CGEN_INSN *);\n-bfd_boolean frv_is_float_insn   (const CGEN_INSN *);\n-bfd_boolean frv_is_media_insn   (const CGEN_INSN *);\n-void        frv_vliw_reset      (FRV_VLIW *, unsigned long, unsigned long);\n-int         frv_vliw_add_insn   (FRV_VLIW *, const CGEN_INSN *);\n-bfd_boolean spr_valid           (long);\n+bool frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n+bool frv_is_float_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n+bool frv_is_media_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n+bool frv_is_branch_insn  (const CGEN_INSN *);\n+bool frv_is_float_insn   (const CGEN_INSN *);\n+bool frv_is_media_insn   (const CGEN_INSN *);\n+void frv_vliw_reset      (FRV_VLIW *, unsigned long, unsigned long);\n+int  frv_vliw_add_insn   (FRV_VLIW *, const CGEN_INSN *);\n+bool spr_valid           (long);\n /* -- */\n \f\n /* -- opc.c */\n@@ -88,117 +88,117 @@ bfd_boolean spr_valid           (long);\n /* Returns TRUE if {MAJOR,MACH} is a major branch of the FRV\n    development tree.  */\n \n-bfd_boolean\n+bool\n frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)\n {\n   switch (mach)\n     {\n     case bfd_mach_fr400:\n       if (major >= FR400_MAJOR_B_1 && major <= FR400_MAJOR_B_6)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case bfd_mach_fr450:\n       if (major >= FR450_MAJOR_B_1 && major <= FR450_MAJOR_B_6)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n       if (major >= FR500_MAJOR_B_1 && major <= FR500_MAJOR_B_6)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Returns TRUE if {MAJOR,MACH} supports floating point insns.  */\n \n-bfd_boolean\n+bool\n frv_is_float_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)\n {\n   switch (mach)\n     {\n     case bfd_mach_fr400:\n     case bfd_mach_fr450:\n-      return FALSE;\n+      return false;\n     default:\n       if (major >= FR500_MAJOR_F_1 && major <= FR500_MAJOR_F_8)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Returns TRUE if {MAJOR,MACH} supports media insns.  */\n \n-bfd_boolean\n+bool\n frv_is_media_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)\n {\n   switch (mach)\n     {\n     case bfd_mach_fr400:\n       if (major >= FR400_MAJOR_M_1 && major <= FR400_MAJOR_M_2)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case bfd_mach_fr450:\n       if (major >= FR450_MAJOR_M_1 && major <= FR450_MAJOR_M_6)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n       if (major >= FR500_MAJOR_M_1 && major <= FR500_MAJOR_M_8)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n frv_is_branch_insn (const CGEN_INSN *insn)\n {\n   if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),\n \t\t\t   bfd_mach_fr400))\n-    return TRUE;\n+    return true;\n   if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),\n \t\t\t   bfd_mach_fr450))\n-    return TRUE;\n+    return true;\n   if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),\n \t\t\t   bfd_mach_fr500))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n frv_is_float_insn (const CGEN_INSN *insn)\n {\n   if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),\n \t\t\t  bfd_mach_fr400))\n-    return TRUE;\n+    return true;\n   if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),\n \t\t\t  bfd_mach_fr450))\n-    return TRUE;\n+    return true;\n   if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),\n \t\t\t  bfd_mach_fr500))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n frv_is_media_insn (const CGEN_INSN *insn)\n {\n   if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),\n \t\t\t  bfd_mach_fr400))\n-    return TRUE;\n+    return true;\n   if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),\n \t\t\t  bfd_mach_fr450))\n-    return TRUE;\n+    return true;\n   if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),\n \t\t\t  bfd_mach_fr500))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* This table represents the allowable packing for vliw insns for the fr400.\n@@ -439,17 +439,17 @@ frv_vliw_reset (FRV_VLIW *vliw, unsigned long mach, unsigned long elf_flags)\n /* Return TRUE if unit1 is a match for unit2.\n    Unit1 comes from the insn's UNIT attribute. unit2 comes from one of the\n    *_allowed_vliw tables above.  */\n-static bfd_boolean\n+static bool\n match_unit (FRV_VLIW *vliw,\n \t    CGEN_ATTR_VALUE_ENUM_TYPE unit1, CGEN_ATTR_VALUE_ENUM_TYPE unit2)\n {\n   /* Map any specialized implementation units to actual ones.  */\n   unit1 = vliw->unit_mapping[unit1];\n \n   if (unit1 == unit2)\n-    return TRUE;\n+    return true;\n   if (unit1 < unit2)\n-    return FALSE;\n+    return false;\n \n   switch (unit1)\n     {\n@@ -459,34 +459,34 @@ match_unit (FRV_VLIW *vliw,\n       /* The 01 versions of these units are within 2 enums of the 0 or 1\n \t versions.  */\n       if (unit1 - unit2 <= 2)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case UNIT_IALL:\n     case UNIT_FMALL:\n       /* The ALL versions of these units are within 5 enums of the 0, 1, 2 or 3\n \t versions.  */\n       if (unit1 - unit2 <= 5)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return TRUE if the vliws match, FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n match_vliw (VLIW_COMBO *vliw1, VLIW_COMBO *vliw2, int vliw_size)\n {\n   int i;\n \n   for (i = 0; i < vliw_size; ++i)\n     if ((*vliw1)[i] != (*vliw2)[i])\n-      return FALSE;\n+      return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Find the next vliw vliw in the table that can accomodate the new insn.\n@@ -523,22 +523,22 @@ add_next_to_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE unit)\n /* Look for the given major insn type in the given vliw.\n    Returns TRUE if found, FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n find_major_in_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)\n {\n   int i;\n \n   for (i = 0; i < vliw->next_slot; ++i)\n     if (vliw->major[i] == major)\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Check for constraints between the insns in the vliw due to major insn\n    types.  */\n \n-static bfd_boolean\n+static bool\n fr400_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)\n {\n   /* In the cpu file, all media insns are represented as being allowed in\n@@ -555,10 +555,10 @@ fr400_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n     default:\n       break;\n     }\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n fr450_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)\n {\n   CGEN_ATTR_VALUE_ENUM_TYPE other_major;\n@@ -569,7 +569,7 @@ fr450_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n   /* (M4, M5) and (M4, M6) are allowed.  */\n   if (other_major == FR450_MAJOR_M_4)\n     if (major == FR450_MAJOR_M_5 || major == FR450_MAJOR_M_6)\n-      return TRUE;\n+      return true;\n \n   /* Otherwise, instructions in even-numbered media categories cannot be\n      executed in parallel with other media instructions.  */\n@@ -589,23 +589,23 @@ fr450_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n \t       || other_major == FR450_MAJOR_M_6);\n \n     default:\n-      return TRUE;\n+      return true;\n     }\n }\n \n-static bfd_boolean\n+static bool\n find_unit_in_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE unit)\n {\n   int i;\n \n   for (i = 0; i < vliw->next_slot; ++i)\n     if (CGEN_INSN_ATTR_VALUE (vliw->insn[i], CGEN_INSN_UNIT) == unit)\n-      return TRUE;\n+      return true;\n \n-  return FALSE; /* Not found.  */\n+  return false; /* Not found.  */\n }\n \n-static bfd_boolean\n+static bool\n find_major_in_slot (FRV_VLIW *vliw,\n \t\t    CGEN_ATTR_VALUE_ENUM_TYPE major,\n \t\t    CGEN_ATTR_VALUE_ENUM_TYPE slot)\n@@ -614,12 +614,12 @@ find_major_in_slot (FRV_VLIW *vliw,\n \n   for (i = 0; i < vliw->next_slot; ++i)\n     if (vliw->major[i] == major && (*vliw->current_vliw)[i] == slot)\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n fr550_find_media_in_vliw (FRV_VLIW *vliw)\n {\n   int i;\n@@ -635,13 +635,13 @@ fr550_find_media_in_vliw (FRV_VLIW *vliw)\n \t  || CGEN_INSN_NUM (vliw->insn[i]) == FRV_INSN_MCLRACC_1)\n \tcontinue;\n \n-      return TRUE; /* Found one.  */\n+      return true; /* Found one.  */\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n fr550_find_float_in_vliw (FRV_VLIW *vliw)\n {\n   int i;\n@@ -655,13 +655,13 @@ fr550_find_float_in_vliw (FRV_VLIW *vliw)\n       if (CGEN_INSN_NUM (vliw->insn[i]) == FRV_INSN_FNOP)\n \tcontinue;\n \n-      return TRUE; /* Found one.  */\n+      return true; /* Found one.  */\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n fr550_check_insn_major_constraints (FRV_VLIW *vliw,\n \t\t\t\t    CGEN_ATTR_VALUE_ENUM_TYPE major,\n \t\t\t\t    const CGEN_INSN *insn)\n@@ -709,10 +709,10 @@ fr550_check_insn_major_constraints (FRV_VLIW *vliw,\n     default:\n       break;\n     }\n-  return TRUE; /* All OK.  */\n+  return true; /* All OK.  */\n }\n \n-static bfd_boolean\n+static bool\n fr500_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)\n {\n   /* TODO: A table might be faster for some of the more complex instances\n@@ -732,7 +732,7 @@ fr500_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n     case FR500_MAJOR_F_4:\n     case FR500_MAJOR_F_8:\n     case FR500_MAJOR_M_8:\n-      return TRUE; /* OK */\n+      return true; /* OK */\n     case FR500_MAJOR_I_2:\n       /* Cannot coexist with I-3 insn.  */\n       return ! find_major_in_vliw (vliw, FR500_MAJOR_I_3);\n@@ -816,10 +816,10 @@ fr500_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n       abort ();\n       break;\n     }\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n check_insn_major_constraints (FRV_VLIW *vliw,\n \t\t\t      CGEN_ATTR_VALUE_ENUM_TYPE major,\n \t\t\t      const CGEN_INSN *insn)\n@@ -919,12 +919,12 @@ frv_vliw_add_insn (FRV_VLIW *vliw, const CGEN_INSN *insn)\n   return 1;\n }\n \n-bfd_boolean\n+bool\n spr_valid (long regno)\n {\n-  if (regno < 0)     return FALSE;\n-  if (regno <= 4095) return TRUE;\n-  return FALSE;\n+  if (regno < 0)     return false;\n+  if (regno <= 4095) return true;\n+  return false;\n }\n /* -- */\n \f"
    },
    {
      "sha": "6d29147debe455d4fae8bf571e7eb3227b0a2b4a",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -1,3 +1,21 @@\n+2021-03-31  Alan Modra  <amodra@gmail.com>\n+\n+\t* sysdep.h (POISON_BFD_BOOLEAN): Define.\n+\t* aarch64-asm-2.c, * aarch64-asm.c, * aarch64-asm.h,\n+\t* aarch64-dis-2.c, * aarch64-dis.c, * aarch64-dis.h,\n+\t* aarch64-gen.c, * aarch64-opc.c, * aarch64-opc.h, * arc-dis.c,\n+\t* arc-dis.h, * arc-fxi.h, * arc-opc.c, * arm-dis.c, * bfin-dis.c,\n+\t* cris-dis.c, * csky-dis.c, * csky-opc.h, * dis-buf.c,\n+\t* disassemble.c, * frv-opc.c, * frv-opc.h, * h8300-dis.c,\n+\t* i386-dis.c, * m68k-dis.c, * metag-dis.c, * microblaze-dis.c,\n+\t* microblaze-dis.h, * micromips-opc.c, * mips-dis.c,\n+\t* mips-formats.h, * mips-opc.c, * mips16-opc.c, * mmix-dis.c,\n+\t* msp430-dis.c, * nds32-dis.c, * nfp-dis.c, * nios2-dis.c,\n+\t* ppc-dis.c, * riscv-dis.c, * score-dis.c, * score7-dis.c,\n+\t* tic6x-dis.c, * v850-dis.c, * vax-dis.c, * wasm32-dis.c,\n+\t* xtensa-dis.c: Replace bfd_boolean with bool, FALSE with false,\n+\tand TRUE with true throughout.\n+\n 2021-03-31  Alan Modra  <amodra@gmail.com>\n \n \t* aarch64-dis.c: Include stdint.h in place of bfd_stdint.h."
    },
    {
      "sha": "26d61da4ff75489517c46d9542d9a64441a1f6b2",
      "filename": "opcodes/aarch64-asm-2.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-asm-2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-asm-2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-asm-2.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -603,7 +603,7 @@ aarch64_find_real_opcode (const aarch64_opcode *opcode)\n   return aarch64_opcode_table + value;\n }\n \n-bfd_boolean\n+bool\n aarch64_insert_operand (const aarch64_operand *self,\n \t\t\t   const aarch64_opnd_info *info,\n \t\t\t   aarch64_insn *code, const aarch64_inst *inst,"
    },
    {
      "sha": "fa1612c01309d88f995b7fc9751ad47b3b9a1bdb",
      "filename": "opcodes/aarch64-asm.c",
      "status": "modified",
      "additions": 128,
      "deletions": 128,
      "changes": 256,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-asm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-asm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-asm.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -79,31 +79,31 @@ insert_all_fields (const aarch64_operand *self, aarch64_insn *code,\n /* Operand inserters.  */\n \n /* Insert nothing.  */\n-bfd_boolean\n+bool\n aarch64_ins_none (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t  const aarch64_opnd_info *info ATTRIBUTE_UNUSED,\n \t\t  aarch64_insn *code ATTRIBUTE_UNUSED,\n \t\t  const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t  aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n /* Insert register number.  */\n-bfd_boolean\n+bool\n aarch64_ins_regno (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t   aarch64_insn *code,\n \t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t   aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   insert_field (self->fields[0], code, info->reg.regno, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Insert register number, index and/or other data for SIMD register element\n    operand, e.g. the last source operand in\n      SQDMLAL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>].  */\n-bfd_boolean\n+bool\n aarch64_ins_reglane (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t     aarch64_insn *code, const aarch64_inst *inst,\n \t\t     aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n@@ -188,11 +188,11 @@ aarch64_ins_reglane (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t  assert (0);\n \t}\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Insert regno and len field of a register list operand, e.g. Vn in TBL.  */\n-bfd_boolean\n+bool\n aarch64_ins_reglist (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t     aarch64_insn *code,\n \t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -202,12 +202,12 @@ aarch64_ins_reglist (const aarch64_operand *self, const aarch64_opnd_info *info,\n   insert_field (self->fields[0], code, info->reglist.first_regno, 0);\n   /* len */\n   insert_field (FLD_len, code, info->reglist.num_regs - 1, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Insert Rt and opcode fields for a register list operand, e.g. Vt\n    in AdvSIMD load/store instructions.  */\n-bfd_boolean\n+bool\n aarch64_ins_ldst_reglist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t  const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t  const aarch64_inst *inst,\n@@ -246,12 +246,12 @@ aarch64_ins_ldst_reglist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     }\n   insert_field (FLD_opcode, code, value, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Insert Rt and S fields for a register list operand, e.g. Vt in AdvSIMD load\n    single structure to all lanes instructions.  */\n-bfd_boolean\n+bool\n aarch64_ins_ldst_reglist_r (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t    const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t    const aarch64_inst *inst,\n@@ -272,12 +272,12 @@ aarch64_ins_ldst_reglist_r (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     value = (aarch64_insn) 1;\n   insert_field (FLD_S, code, value, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Insert Q, opcode<2:1>, S, size and Rt fields for a register element list\n    operand e.g. Vt in AdvSIMD load/store single element instructions.  */\n-bfd_boolean\n+bool\n aarch64_ins_ldst_elemlist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t   const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -321,13 +321,13 @@ aarch64_ins_ldst_elemlist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   gen_sub_field (FLD_asisdlso_opcode, 1, 2, &field);\n   insert_field_2 (&field, code, opcodeh2, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Insert fields immh:immb and/or Q for e.g. the shift immediate in\n    SSHR <Vd>.<T>, <Vn>.<T>, #<shift>\n    or SSHR <V><d>, <V><n>, #<shift>.  */\n-bfd_boolean\n+bool\n aarch64_ins_advsimd_imm_shift (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t       const aarch64_opnd_info *info,\n \t\t\t       aarch64_insn *code, const aarch64_inst *inst,\n@@ -377,12 +377,12 @@ aarch64_ins_advsimd_imm_shift (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     imm = info->imm.value + (8 << (unsigned)val);\n   insert_fields (code, imm, 0, 2, FLD_immb, FLD_immh);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Insert fields for e.g. the immediate operands in\n    BFM <Wd>, <Wn>, #<immr>, #<imms>.  */\n-bfd_boolean\n+bool\n aarch64_ins_imm (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t aarch64_insn *code,\n \t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -396,12 +396,12 @@ aarch64_ins_imm (const aarch64_operand *self, const aarch64_opnd_info *info,\n   if (operand_need_shift_by_four (self))\n     imm >>= 4;\n   insert_all_fields (self, code, imm);\n-  return TRUE;\n+  return true;\n }\n \n /* Insert immediate and its shift amount for e.g. the last operand in\n      MOVZ <Wd>, #<imm16>{, LSL #<shift>}.  */\n-bfd_boolean\n+bool\n aarch64_ins_imm_half (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t      aarch64_insn *code, const aarch64_inst *inst,\n \t\t      aarch64_operand_error *errors)\n@@ -410,12 +410,12 @@ aarch64_ins_imm_half (const aarch64_operand *self, const aarch64_opnd_info *info\n   aarch64_ins_imm (self, info, code, inst, errors);\n   /* hw */\n   insert_field (FLD_hw, code, info->shifter.amount >> 4, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Insert cmode and \"a:b:c:d:e:f:g:h\" fields for e.g. the last operand in\n      MOVI <Vd>.<T>, #<imm8> {, LSL #<amount>}.  */\n-bfd_boolean\n+bool\n aarch64_ins_advsimd_imm_modified (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t\t  const aarch64_opnd_info *info,\n \t\t\t\t  aarch64_insn *code,\n@@ -443,7 +443,7 @@ aarch64_ins_advsimd_imm_modified (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   insert_fields (code, imm, 0, 2, FLD_defgh, FLD_abc);\n \n   if (kind == AARCH64_MOD_NONE)\n-    return TRUE;\n+    return true;\n \n   /* shift amount partially in cmode */\n   assert (kind == AARCH64_MOD_LSL || kind == AARCH64_MOD_MSL);\n@@ -455,7 +455,7 @@ aarch64_ins_advsimd_imm_modified (const aarch64_operand *self ATTRIBUTE_UNUSED,\n       /* For 8-bit move immediate, the optional LSL #0 does not require\n \t encoding.  */\n       if (esize == 1)\n-\treturn TRUE;\n+\treturn true;\n       amount >>= 3;\n       if (esize == 4)\n \tgen_sub_field (FLD_cmode, 1, 2, &field);\t/* per word */\n@@ -470,22 +470,22 @@ aarch64_ins_advsimd_imm_modified (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     }\n   insert_field_2 (&field, code, amount, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Insert fields for an 8-bit floating-point immediate.  */\n-bfd_boolean\n+bool\n aarch64_ins_fpimm (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t   aarch64_insn *code,\n \t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t   aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   insert_all_fields (self, code, info->imm.value);\n-  return TRUE;\n+  return true;\n }\n \n /* Insert 1-bit rotation immediate (#90 or #270).  */\n-bfd_boolean\n+bool\n aarch64_ins_imm_rotate1 (const aarch64_operand *self,\n \t\t\t const aarch64_opnd_info *info,\n \t\t\t aarch64_insn *code, const aarch64_inst *inst,\n@@ -494,11 +494,11 @@ aarch64_ins_imm_rotate1 (const aarch64_operand *self,\n   uint64_t rot = (info->imm.value - 90) / 180;\n   assert (rot < 2U);\n   insert_field (self->fields[0], code, rot, inst->opcode->mask);\n-  return TRUE;\n+  return true;\n }\n \n /* Insert 2-bit rotation immediate (#0, #90, #180 or #270).  */\n-bfd_boolean\n+bool\n aarch64_ins_imm_rotate2 (const aarch64_operand *self,\n \t\t\t const aarch64_opnd_info *info,\n \t\t\t aarch64_insn *code, const aarch64_inst *inst,\n@@ -507,24 +507,24 @@ aarch64_ins_imm_rotate2 (const aarch64_operand *self,\n   uint64_t rot = info->imm.value / 90;\n   assert (rot < 4U);\n   insert_field (self->fields[0], code, rot, inst->opcode->mask);\n-  return TRUE;\n+  return true;\n }\n \n /* Insert #<fbits> for the immediate operand in fp fix-point instructions,\n    e.g.  SCVTF <Dd>, <Wn>, #<fbits>.  */\n-bfd_boolean\n+bool\n aarch64_ins_fbits (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t   aarch64_insn *code,\n \t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t   aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   insert_field (self->fields[0], code, 64 - info->imm.value, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Insert arithmetic immediate for e.g. the last operand in\n      SUBS <Wd>, <Wn|WSP>, #<imm> {, <shift>}.  */\n-bfd_boolean\n+bool\n aarch64_ins_aimm (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t  aarch64_insn *code, const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t  aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n@@ -534,18 +534,18 @@ aarch64_ins_aimm (const aarch64_operand *self, const aarch64_opnd_info *info,\n   insert_field (self->fields[0], code, value, 0);\n   /* imm12 (unsigned) */\n   insert_field (self->fields[1], code, info->imm.value, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Common routine shared by aarch64_ins{,_inv}_limm.  INVERT_P says whether\n    the operand should be inverted before encoding.  */\n-static bfd_boolean\n+static bool\n aarch64_ins_limm_1 (const aarch64_operand *self,\n \t\t    const aarch64_opnd_info *info, aarch64_insn *code,\n-\t\t    const aarch64_inst *inst, bfd_boolean invert_p,\n+\t\t    const aarch64_inst *inst, bool invert_p,\n \t\t    aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n-  bfd_boolean res;\n+  bool res;\n   aarch64_insn value;\n   uint64_t imm = info->imm.value;\n   int esize = aarch64_get_qualifier_esize (inst->operands[0].qualifier);\n@@ -562,7 +562,7 @@ aarch64_ins_limm_1 (const aarch64_operand *self,\n \n /* Insert logical/bitmask immediate for e.g. the last operand in\n      ORR <Wd|WSP>, <Wn>, #<imm>.  */\n-bfd_boolean\n+bool\n aarch64_ins_limm (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\t  aarch64_insn *code, const aarch64_inst *inst,\n \t\t  aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n@@ -572,18 +572,18 @@ aarch64_ins_limm (const aarch64_operand *self, const aarch64_opnd_info *info,\n }\n \n /* Insert a logical/bitmask immediate for the BIC alias of AND (etc.).  */\n-bfd_boolean\n+bool\n aarch64_ins_inv_limm (const aarch64_operand *self,\n \t\t      const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t      const aarch64_inst *inst,\n \t\t      aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n-  return aarch64_ins_limm_1 (self, info, code, inst, TRUE, errors);\n+  return aarch64_ins_limm_1 (self, info, code, inst, true, errors);\n }\n \n /* Encode Ft for e.g. STR <Qt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]\n    or LDP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>.  */\n-bfd_boolean\n+bool\n aarch64_ins_ft (const aarch64_operand *self, const aarch64_opnd_info *info,\n \t\taarch64_insn *code, const aarch64_inst *inst,\n \t\taarch64_operand_error *errors)\n@@ -616,24 +616,24 @@ aarch64_ins_ft (const aarch64_operand *self, const aarch64_opnd_info *info,\n       insert_fields (code, value, 0, 2, FLD_ldst_size, FLD_opc1);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Encode the address operand for e.g. STXRB <Ws>, <Wt>, [<Xn|SP>{,#0}].  */\n-bfd_boolean\n+bool\n aarch64_ins_addr_simple (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t\t aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   /* Rn */\n   insert_field (FLD_Rn, code, info->addr.base_regno, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the address operand for e.g.\n      STR <Qt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}].  */\n-bfd_boolean\n+bool\n aarch64_ins_addr_regoff (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -662,12 +662,12 @@ aarch64_ins_addr_regoff (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     S = info->shifter.operator_present && info->shifter.amount_present;\n   insert_field (FLD_S, code, S, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Encode the address operand for e.g.\n      stlur <Xt>, [<Xn|SP>{, <amount>}].  */\n-bfd_boolean\n+bool\n aarch64_ins_addr_offset (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -686,11 +686,11 @@ aarch64_ins_addr_offset (const aarch64_operand *self ATTRIBUTE_UNUSED,\n       assert (info->addr.preind == 1 && info->addr.postind == 0);\n       insert_field (self->fields[2], code, 1, 0);\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the address operand for e.g. LDRSW <Xt>, [<Xn|SP>, #<simm>]!.  */\n-bfd_boolean\n+bool\n aarch64_ins_addr_simm (const aarch64_operand *self,\n \t\t       const aarch64_opnd_info *info,\n \t\t       aarch64_insn *code,\n@@ -720,11 +720,11 @@ aarch64_ins_addr_simm (const aarch64_operand *self,\n \tinsert_field (self->fields[1], code, 1, 0);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Encode the address operand for e.g. LDRAA <Xt>, [<Xn|SP>{, #<simm>}].  */\n-bfd_boolean\n+bool\n aarch64_ins_addr_simm10 (const aarch64_operand *self,\n \t\t\t const aarch64_opnd_info *info,\n \t\t\t aarch64_insn *code,\n@@ -745,11 +745,11 @@ aarch64_ins_addr_simm10 (const aarch64_operand *self,\n       assert (info->addr.preind == 1 && info->addr.postind == 0);\n       insert_field (self->fields[3], code, 1, 0);\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the address operand for e.g. LDRSW <Xt>, [<Xn|SP>{, #<pimm>}].  */\n-bfd_boolean\n+bool\n aarch64_ins_addr_uimm12 (const aarch64_operand *self,\n \t\t\t const aarch64_opnd_info *info,\n \t\t\t aarch64_insn *code,\n@@ -762,12 +762,12 @@ aarch64_ins_addr_uimm12 (const aarch64_operand *self,\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   /* uimm12 */\n   insert_field (self->fields[1], code,info->addr.offset.imm >> shift, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the address operand for e.g.\n      LD1 {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>}, [<Xn|SP>], <Xm|#<amount>>.  */\n-bfd_boolean\n+bool\n aarch64_ins_simd_addr_post (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t    const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -780,23 +780,23 @@ aarch64_ins_simd_addr_post (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     insert_field (FLD_Rm, code, info->addr.offset.regno, 0);\n   else\n     insert_field (FLD_Rm, code, 0x1f, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the condition operand for e.g. CSEL <Xd>, <Xn>, <Xm>, <cond>.  */\n-bfd_boolean\n+bool\n aarch64_ins_cond (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t  const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t  const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t  aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   /* cond */\n   insert_field (FLD_cond, code, info->cond->value, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the system register operand for e.g. MRS <Xt>, <systemreg>.  */\n-bfd_boolean\n+bool\n aarch64_ins_sysreg (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t    const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t    const aarch64_inst *inst,\n@@ -820,7 +820,7 @@ aarch64_ins_sysreg (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\tdetail->kind = AARCH64_OPDE_SYNTAX_ERROR;\n \t\tdetail->error = _(\"specified register cannot be read from\");\n \t\tdetail->index = info->idx;\n-\t\tdetail->non_fatal = TRUE;\n+\t\tdetail->non_fatal = true;\n \t  }\n \telse if (opcode_flags == F_SYS_WRITE\n \t\t && sysreg_flags\n@@ -829,17 +829,17 @@ aarch64_ins_sysreg (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\tdetail->kind = AARCH64_OPDE_SYNTAX_ERROR;\n \t\tdetail->error = _(\"specified register cannot be written to\");\n \t\tdetail->index = info->idx;\n-\t\tdetail->non_fatal = TRUE;\n+\t\tdetail->non_fatal = true;\n \t  }\n      }\n   /* op0:op1:CRn:CRm:op2 */\n   insert_fields (code, info->sysreg.value, inst->opcode->mask, 5,\n \t\t FLD_op2, FLD_CRm, FLD_CRn, FLD_op1, FLD_op0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the PSTATE field operand for e.g. MSR <pstatefield>, #<imm>.  */\n-bfd_boolean\n+bool\n aarch64_ins_pstatefield (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -848,11 +848,11 @@ aarch64_ins_pstatefield (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* op1:op2 */\n   insert_fields (code, info->pstatefield, inst->opcode->mask, 2,\n \t\t FLD_op2, FLD_op1);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the system instruction op operand for e.g. AT <at_op>, <Xt>.  */\n-bfd_boolean\n+bool\n aarch64_ins_sysins_op (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t       const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t       const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -861,25 +861,25 @@ aarch64_ins_sysins_op (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* op1:CRn:CRm:op2 */\n   insert_fields (code, info->sysins_op->value, inst->opcode->mask, 4,\n \t\t FLD_op2, FLD_CRm, FLD_CRn, FLD_op1);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the memory barrier option operand for e.g. DMB <option>|#<imm>.  */\n \n-bfd_boolean\n+bool\n aarch64_ins_barrier (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t     const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t     aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   /* CRm */\n   insert_field (FLD_CRm, code, info->barrier->value, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the memory barrier option operand for DSB <option>nXS|#<imm>.  */\n \n-bfd_boolean\n+bool\n aarch64_ins_barrier_dsb_nxs (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t     const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -889,40 +889,40 @@ aarch64_ins_barrier_dsb_nxs (const aarch64_operand *self ATTRIBUTE_UNUSED,\n      encoded in CRm<3:2>.  */\n   aarch64_insn value = (info->barrier->value >> 2) - 4;\n   insert_field (FLD_CRm_dsb_nxs, code, value, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the prefetch operation option operand for e.g.\n      PRFM <prfop>, [<Xn|SP>{, #<pimm>}].  */\n \n-bfd_boolean\n+bool\n aarch64_ins_prfop (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t   const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t   aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   /* prfop in Rt */\n   insert_field (FLD_Rt, code, info->prfop->value, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the hint number for instructions that alias HINT but take an\n    operand.  */\n \n-bfd_boolean\n+bool\n aarch64_ins_hint (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t  const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t  const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t  aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   /* CRm:op2.  */\n   insert_fields (code, info->hint_option->value, 0, 2, FLD_op2, FLD_CRm);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode the extended register operand for e.g.\n      STR <Qt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}].  */\n-bfd_boolean\n+bool\n aarch64_ins_reg_extended (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t  const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t  const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -941,12 +941,12 @@ aarch64_ins_reg_extended (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* imm3 */\n   insert_field (FLD_imm3, code, info->shifter.amount, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Encode the shifted register operand for e.g.\n      SUBS <Xd>, <Xn>, <Xm> {, <shift> #<amount>}.  */\n-bfd_boolean\n+bool\n aarch64_ins_reg_shifted (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -960,14 +960,14 @@ aarch64_ins_reg_shifted (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* imm6 */\n   insert_field (FLD_imm6, code, info->shifter.amount, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [<base>, #<simm4>*<factor>, MUL VL],\n    where <simm4> is a 4-bit signed value and where <factor> is 1 plus\n    SELF's operand-dependent value.  fields[0] specifies the field that\n    holds <base>.  <simm4> is encoded in the SVE_imm4 field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_ri_s4xvl (const aarch64_operand *self,\n \t\t\t       const aarch64_opnd_info *info,\n \t\t\t       aarch64_insn *code,\n@@ -977,14 +977,14 @@ aarch64_ins_sve_addr_ri_s4xvl (const aarch64_operand *self,\n   int factor = 1 + get_operand_specific_data (self);\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   insert_field (FLD_SVE_imm4, code, info->addr.offset.imm / factor, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [<base>, #<simm6>*<factor>, MUL VL],\n    where <simm6> is a 6-bit signed value and where <factor> is 1 plus\n    SELF's operand-dependent value.  fields[0] specifies the field that\n    holds <base>.  <simm6> is encoded in the SVE_imm6 field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_ri_s6xvl (const aarch64_operand *self,\n \t\t\t       const aarch64_opnd_info *info,\n \t\t\t       aarch64_insn *code,\n@@ -994,15 +994,15 @@ aarch64_ins_sve_addr_ri_s6xvl (const aarch64_operand *self,\n   int factor = 1 + get_operand_specific_data (self);\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   insert_field (FLD_SVE_imm6, code, info->addr.offset.imm / factor, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [<base>, #<simm9>*<factor>, MUL VL],\n    where <simm9> is a 9-bit signed value and where <factor> is 1 plus\n    SELF's operand-dependent value.  fields[0] specifies the field that\n    holds <base>.  <simm9> is encoded in the concatenation of the SVE_imm6\n    and imm3 fields, with imm3 being the less-significant part.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_ri_s9xvl (const aarch64_operand *self,\n \t\t\t       const aarch64_opnd_info *info,\n \t\t\t       aarch64_insn *code,\n@@ -1013,13 +1013,13 @@ aarch64_ins_sve_addr_ri_s9xvl (const aarch64_operand *self,\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   insert_fields (code, info->addr.offset.imm / factor, 0,\n \t\t 2, FLD_imm3, FLD_SVE_imm6);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [X<n>, #<SVE_imm4> << <shift>], where <SVE_imm4>\n    is a 4-bit signed number and where <shift> is SELF's operand-dependent\n    value.  fields[0] specifies the base register field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_ri_s4 (const aarch64_operand *self,\n \t\t\t    const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1028,13 +1028,13 @@ aarch64_ins_sve_addr_ri_s4 (const aarch64_operand *self,\n   int factor = 1 << get_operand_specific_data (self);\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   insert_field (FLD_SVE_imm4, code, info->addr.offset.imm / factor, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [X<n>, #<SVE_imm6> << <shift>], where <SVE_imm6>\n    is a 6-bit unsigned number and where <shift> is SELF's operand-dependent\n    value.  fields[0] specifies the base register field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_ri_u6 (const aarch64_operand *self,\n \t\t\t    const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1043,28 +1043,28 @@ aarch64_ins_sve_addr_ri_u6 (const aarch64_operand *self,\n   int factor = 1 << get_operand_specific_data (self);\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   insert_field (FLD_SVE_imm6, code, info->addr.offset.imm / factor, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [X<n>, X<m>{, LSL #<shift>}], where <shift>\n    is SELF's operand-dependent value.  fields[0] specifies the base\n    register field and fields[1] specifies the offset register field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_rr_lsl (const aarch64_operand *self,\n \t\t\t     const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t\t     aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   insert_field (self->fields[1], code, info->addr.offset.regno, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [X<n>, Z<m>.<T>, (S|U)XTW {#<shift>}], where\n    <shift> is SELF's operand-dependent value.  fields[0] specifies the\n    base register field, fields[1] specifies the offset register field and\n    fields[2] is a single-bit field that selects SXTW over UXTW.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_rz_xtw (const aarch64_operand *self,\n \t\t\t     const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1076,13 +1076,13 @@ aarch64_ins_sve_addr_rz_xtw (const aarch64_operand *self,\n     insert_field (self->fields[2], code, 0, 0);\n   else\n     insert_field (self->fields[2], code, 1, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [Z<n>.<T>, #<imm5> << <shift>], where <imm5> is a\n    5-bit unsigned number and where <shift> is SELF's operand-dependent value.\n    fields[0] specifies the base register field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_zi_u5 (const aarch64_operand *self,\n \t\t\t    const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1091,28 +1091,28 @@ aarch64_ins_sve_addr_zi_u5 (const aarch64_operand *self,\n   int factor = 1 << get_operand_specific_data (self);\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   insert_field (FLD_imm5, code, info->addr.offset.imm / factor, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [Z<n>.<T>, Z<m>.<T>{, <modifier> {#<msz>}}],\n    where <modifier> is fixed by the instruction and where <msz> is a\n    2-bit unsigned number.  fields[0] specifies the base register field\n    and fields[1] specifies the offset register field.  */\n-static bfd_boolean\n+static bool\n aarch64_ext_sve_addr_zz (const aarch64_operand *self,\n \t\t\t const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   insert_field (self->fields[0], code, info->addr.base_regno, 0);\n   insert_field (self->fields[1], code, info->addr.offset.regno, 0);\n   insert_field (FLD_SVE_msz, code, info->shifter.amount, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE address [Z<n>.<T>, Z<m>.<T>{, LSL #<msz>}], where\n    <msz> is a 2-bit unsigned number.  fields[0] specifies the base register\n    field and fields[1] specifies the offset register field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_zz_lsl (const aarch64_operand *self,\n \t\t\t     const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1124,7 +1124,7 @@ aarch64_ins_sve_addr_zz_lsl (const aarch64_operand *self,\n /* Encode an SVE address [Z<n>.<T>, Z<m>.<T>, SXTW {#<msz>}], where\n    <msz> is a 2-bit unsigned number.  fields[0] specifies the base register\n    field and fields[1] specifies the offset register field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_zz_sxtw (const aarch64_operand *self,\n \t\t\t      const aarch64_opnd_info *info,\n \t\t\t      aarch64_insn *code,\n@@ -1137,7 +1137,7 @@ aarch64_ins_sve_addr_zz_sxtw (const aarch64_operand *self,\n /* Encode an SVE address [Z<n>.<T>, Z<m>.<T>, UXTW {#<msz>}], where\n    <msz> is a 2-bit unsigned number.  fields[0] specifies the base register\n    field and fields[1] specifies the offset register field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_addr_zz_uxtw (const aarch64_operand *self,\n \t\t\t      const aarch64_opnd_info *info,\n \t\t\t      aarch64_insn *code,\n@@ -1148,7 +1148,7 @@ aarch64_ins_sve_addr_zz_uxtw (const aarch64_operand *self,\n }\n \n /* Encode an SVE ADD/SUB immediate.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_aimm (const aarch64_operand *self,\n \t\t      const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t      const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1160,11 +1160,11 @@ aarch64_ins_sve_aimm (const aarch64_operand *self,\n     insert_all_fields (self, code, ((info->imm.value / 256) & 0xff) | 256);\n   else\n     insert_all_fields (self, code, info->imm.value & 0xff);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE CPY/DUP immediate.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_asimm (const aarch64_operand *self,\n \t\t       const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t       const aarch64_inst *inst,\n@@ -1177,7 +1177,7 @@ aarch64_ins_sve_asimm (const aarch64_operand *self,\n    array specifies which field to use for Zn.  MM is encoded in the\n    concatenation of imm5 and SVE_tszh, with imm5 being the less\n    significant part.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_index (const aarch64_operand *self,\n \t\t       const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t       const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1187,11 +1187,11 @@ aarch64_ins_sve_index (const aarch64_operand *self,\n   insert_field (self->fields[0], code, info->reglane.regno, 0);\n   insert_fields (code, (info->reglane.index * 2 + 1) * esize, 0,\n \t\t 2, FLD_imm5, FLD_SVE_tszh);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode a logical/bitmask immediate for the MOV alias of SVE DUPM.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_limm_mov (const aarch64_operand *self,\n \t\t\t  const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t  const aarch64_inst *inst,\n@@ -1203,7 +1203,7 @@ aarch64_ins_sve_limm_mov (const aarch64_operand *self,\n /* Encode Zn[MM], where Zn occupies the least-significant part of the field\n    and where MM occupies the most-significant part.  The operand-dependent\n    value specifies the number of bits in Zn.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_quad_index (const aarch64_operand *self,\n \t\t\t    const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1213,37 +1213,37 @@ aarch64_ins_sve_quad_index (const aarch64_operand *self,\n   assert (info->reglane.regno < (1U << reg_bits));\n   unsigned int val = (info->reglane.index << reg_bits) + info->reglane.regno;\n   insert_all_fields (self, code, val);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode {Zn.<T> - Zm.<T>}.  The fields array specifies which field\n    to use for Zn.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_reglist (const aarch64_operand *self,\n \t\t\t const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t\t aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   insert_field (self->fields[0], code, info->reglist.first_regno, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode <pattern>{, MUL #<amount>}.  The fields array specifies which\n    fields to use for <pattern>.  <amount> - 1 is encoded in the SVE_imm4\n    field.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_scale (const aarch64_operand *self,\n \t\t       const aarch64_opnd_info *info, aarch64_insn *code,\n \t\t       const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t       aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   insert_all_fields (self, code, info->imm.value);\n   insert_field (FLD_SVE_imm4, code, info->shifter.amount - 1, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE shift left immediate.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_shlimm (const aarch64_operand *self,\n \t\t\tconst aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\tconst aarch64_inst *inst,\n@@ -1256,11 +1256,11 @@ aarch64_ins_sve_shlimm (const aarch64_operand *self,\n   prev_operand = &inst->operands[info->idx - 1];\n   esize = aarch64_get_qualifier_esize (prev_operand->qualifier);\n   insert_all_fields (self, code, 8 * esize + info->imm.value);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode an SVE shift right immediate.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_shrimm (const aarch64_operand *self,\n \t\t\tconst aarch64_opnd_info *info, aarch64_insn *code,\n \t\t\tconst aarch64_inst *inst,\n@@ -1274,12 +1274,12 @@ aarch64_ins_sve_shrimm (const aarch64_operand *self,\n   prev_operand = &inst->operands[info->idx - opnd_backshift];\n   esize = aarch64_get_qualifier_esize (prev_operand->qualifier);\n   insert_all_fields (self, code, 16 * esize - info->imm.value);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode a single-bit immediate that selects between #0.5 and #1.0.\n    The fields array specifies which field to use.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_float_half_one (const aarch64_operand *self,\n \t\t\t\tconst aarch64_opnd_info *info,\n \t\t\t\taarch64_insn *code,\n@@ -1290,12 +1290,12 @@ aarch64_ins_sve_float_half_one (const aarch64_operand *self,\n     insert_field (self->fields[0], code, 0, 0);\n   else\n     insert_field (self->fields[0], code, 1, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode a single-bit immediate that selects between #0.5 and #2.0.\n    The fields array specifies which field to use.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_float_half_two (const aarch64_operand *self,\n \t\t\t\tconst aarch64_opnd_info *info,\n \t\t\t\taarch64_insn *code,\n@@ -1306,12 +1306,12 @@ aarch64_ins_sve_float_half_two (const aarch64_operand *self,\n     insert_field (self->fields[0], code, 0, 0);\n   else\n     insert_field (self->fields[0], code, 1, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Encode a single-bit immediate that selects between #0.0 and #1.0.\n    The fields array specifies which field to use.  */\n-bfd_boolean\n+bool\n aarch64_ins_sve_float_zero_one (const aarch64_operand *self,\n \t\t\t\tconst aarch64_opnd_info *info,\n \t\t\t\taarch64_insn *code,\n@@ -1322,7 +1322,7 @@ aarch64_ins_sve_float_zero_one (const aarch64_operand *self,\n     insert_field (self->fields[0], code, 0, 0);\n   else\n     insert_field (self->fields[0], code, 1, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Miscellaneous encoding functions.  */\n@@ -2002,7 +2002,7 @@ convert_to_real (aarch64_inst *inst, const aarch64_opcode *real)\n    Return the encoded result in *CODE and if QLF_SEQ is not NULL, return the\n    matched operand qualifier sequence in *QLF_SEQ.  */\n \n-bfd_boolean\n+bool\n aarch64_opcode_encode (const aarch64_opcode *opcode,\n \t\t       const aarch64_inst *inst_ori, aarch64_insn *code,\n \t\t       aarch64_opnd_qualifier_t *qlf_seq,\n@@ -2083,7 +2083,7 @@ aarch64_opcode_encode (const aarch64_opcode *opcode,\n       if (operand_has_inserter (opnd)\n \t  && !aarch64_insert_operand (opnd, info, &inst->value, inst,\n \t\t\t\t      mismatch_detail))\n-\t    return FALSE;\n+\t    return false;\n     }\n \n   /* Call opcode encoders indicated by flags.  */\n@@ -2097,14 +2097,14 @@ aarch64_opcode_encode (const aarch64_opcode *opcode,\n   /* Run a verifier if the instruction has one set.  */\n   if (opcode->verifier)\n     {\n-      enum err_type result = opcode->verifier (inst, *code, 0, TRUE,\n+      enum err_type result = opcode->verifier (inst, *code, 0, true,\n \t\t\t\t\t       mismatch_detail, insn_sequence);\n       switch (result)\n \t{\n \tcase ERR_UND:\n \tcase ERR_UNP:\n \tcase ERR_NYI:\n-\t  return FALSE;\n+\t  return false;\n \tdefault:\n \t  break;\n \t}\n@@ -2113,14 +2113,14 @@ aarch64_opcode_encode (const aarch64_opcode *opcode,\n   /* Always run constrain verifiers, this is needed because constrains need to\n      maintain a global state.  Regardless if the instruction has the flag set\n      or not.  */\n-  enum err_type result = verify_constraints (inst, *code, 0, TRUE,\n+  enum err_type result = verify_constraints (inst, *code, 0, true,\n \t\t\t\t\t     mismatch_detail, insn_sequence);\n   switch (result)\n     {\n     case ERR_UND:\n     case ERR_UNP:\n     case ERR_NYI:\n-      return FALSE;\n+      return false;\n     default:\n       break;\n     }\n@@ -2131,5 +2131,5 @@ aarch64_opcode_encode (const aarch64_opcode *opcode,\n \n   *code = inst->value;\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "5ea24badab70117b6f757e9be6151d2e371319a5",
      "filename": "opcodes/aarch64-asm.h",
      "status": "modified",
      "additions": 6,
      "deletions": 7,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-asm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-asm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-asm.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -30,17 +30,16 @@ const aarch64_opcode* aarch64_find_real_opcode (const aarch64_opcode *);\n \n /* Switch-table-based high-level operand inserter.  */\n \n-bfd_boolean aarch64_insert_operand (const aarch64_operand *,\n-\t\t\t\t    const aarch64_opnd_info *, aarch64_insn *,\n-\t\t\t\t    const aarch64_inst *,\n-\t\t\t\t    aarch64_operand_error *);\n+bool aarch64_insert_operand (const aarch64_operand *,\n+\t\t\t     const aarch64_opnd_info *, aarch64_insn *,\n+\t\t\t     const aarch64_inst *, aarch64_operand_error *);\n \n /* Operand inserters.  */\n \n #define AARCH64_DECL_OPD_INSERTER(x)\t\\\n-  bfd_boolean aarch64_##x (const aarch64_operand *, const aarch64_opnd_info *, \\\n-\t\t\t   aarch64_insn *, const aarch64_inst *, \\\n-\t\t\t   aarch64_operand_error *)\n+  bool aarch64_##x (const aarch64_operand *, const aarch64_opnd_info *, \\\n+\t\t    aarch64_insn *, const aarch64_inst *,\t\t\\\n+\t\t    aarch64_operand_error *)\n \n AARCH64_DECL_OPD_INSERTER (ins_none);\n AARCH64_DECL_OPD_INSERTER (ins_regno);"
    },
    {
      "sha": "1b98ee64748be84eafe9e411f3a20dc011be36bb",
      "filename": "opcodes/aarch64-dis-2.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-dis-2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-dis-2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-dis-2.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -23797,7 +23797,7 @@ aarch64_find_next_alias_opcode (const aarch64_opcode *opcode)\n   return aarch64_opcode_table + value;\n }\n \n-bfd_boolean\n+bool\n aarch64_extract_operand (const aarch64_operand *self,\n \t\t\t   aarch64_opnd_info *info,\n \t\t\t   aarch64_insn code, const aarch64_inst *inst,"
    },
    {
      "sha": "2549e6c32560a37152a7a2eeb45ef8176ad86f3d",
      "filename": "opcodes/aarch64-dis.c",
      "status": "modified",
      "additions": 212,
      "deletions": 212,
      "changes": 424,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -252,27 +252,27 @@ get_expected_qualifier (const aarch64_inst *inst, int i)\n \n /* Operand extractors.  */\n \n-bfd_boolean\n+bool\n aarch64_ext_none (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t  aarch64_opnd_info *info ATTRIBUTE_UNUSED,\n \t\t  const aarch64_insn code ATTRIBUTE_UNUSED,\n \t\t  const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t  aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n aarch64_ext_regno (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t   const aarch64_insn code,\n \t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t   aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   info->reg.regno = extract_field (self->fields[0], code, 0);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n aarch64_ext_regno_pair (const aarch64_operand *self ATTRIBUTE_UNUSED, aarch64_opnd_info *info,\n \t\t   const aarch64_insn code ATTRIBUTE_UNUSED,\n \t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -281,11 +281,11 @@ aarch64_ext_regno_pair (const aarch64_operand *self ATTRIBUTE_UNUSED, aarch64_op\n   assert (info->idx == 1\n \t  || info->idx ==3);\n   info->reg.regno = inst->operands[info->idx - 1].reg.regno + 1;\n-  return TRUE;\n+  return true;\n }\n \n /* e.g. IC <ic_op>{, <Xt>}.  */\n-bfd_boolean\n+bool\n aarch64_ext_regrt_sysins (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t\t  const aarch64_insn code,\n \t\t\t  const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -300,11 +300,11 @@ aarch64_ext_regrt_sysins (const aarch64_operand *self, aarch64_opnd_info *info,\n      not.  */\n   info->present = aarch64_sys_ins_reg_has_xt (inst->operands[0].sysins_op);\n \n-  return TRUE;\n+  return true;\n }\n \n /* e.g. SQDMLAL <Va><d>, <Vb><n>, <Vm>.<Ts>[<index>].  */\n-bfd_boolean\n+bool\n aarch64_ext_reglane (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t     const aarch64_insn code,\n \t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -344,7 +344,7 @@ aarch64_ext_reglane (const aarch64_operand *self, aarch64_opnd_info *info,\n \t  while (++pos <= 3 && (value & 0x1) == 0)\n \t    value >>= 1;\n \t  if (pos > 3)\n-\t    return FALSE;\n+\t    return false;\n \t  info->qualifier = get_sreg_qualifier_from_value (pos);\n \t  info->reglane.index = (unsigned) (value >> 1);\n \t}\n@@ -362,7 +362,7 @@ aarch64_ext_reglane (const aarch64_operand *self, aarch64_opnd_info *info,\n \t  info->reglane.regno &= 0x1f;\n \t  break;\n \tdefault:\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   else if (inst->opcode->iclass == cryptosm3)\n@@ -402,23 +402,23 @@ aarch64_ext_reglane (const aarch64_operand *self, aarch64_opnd_info *info,\n \t  info->reglane.index = extract_field (FLD_H, code, 0);\n \t  break;\n \tdefault:\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (inst->opcode->op == OP_FCMLA_ELEM\n \t  && info->qualifier != AARCH64_OPND_QLF_S_H)\n \t{\n \t  /* Complex operand takes two elements.  */\n \t  if (info->reglane.index & 1)\n-\t    return FALSE;\n+\t    return false;\n \t  info->reglane.index /= 2;\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n aarch64_ext_reglist (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t     const aarch64_insn code,\n \t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -428,11 +428,11 @@ aarch64_ext_reglist (const aarch64_operand *self, aarch64_opnd_info *info,\n   info->reglist.first_regno = extract_field (self->fields[0], code, 0);\n   /* len */\n   info->reglist.num_regs = extract_field (FLD_len, code, 0) + 1;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode Rt and opcode fields of Vt in AdvSIMD load/store instructions.  */\n-bfd_boolean\n+bool\n aarch64_ext_ldst_reglist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t  aarch64_opnd_info *info, const aarch64_insn code,\n \t\t\t  const aarch64_inst *inst,\n@@ -467,17 +467,17 @@ aarch64_ext_ldst_reglist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   value = extract_field (FLD_opcode, code, 0);\n   /* PR 21595: Check for a bogus value.  */\n   if (value >= ARRAY_SIZE (data))\n-    return FALSE;\n+    return false;\n   if (expected_num != data[value].num_elements || data[value].is_reserved)\n-    return FALSE;\n+    return false;\n   info->reglist.num_regs = data[value].num_regs;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode Rt and S fields of Vt in AdvSIMD load single structure to all\n    lanes instructions.  */\n-bfd_boolean\n+bool\n aarch64_ext_ldst_reglist_r (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t    aarch64_opnd_info *info, const aarch64_insn code,\n \t\t\t    const aarch64_inst *inst,\n@@ -499,12 +499,12 @@ aarch64_ext_ldst_reglist_r (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   if (info->reglist.num_regs == 1 && value == (aarch64_insn) 1)\n     info->reglist.num_regs = 2;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode Q, opcode<2:1>, S, size and Rt fields of Vt in AdvSIMD\n    load/store single element instructions.  */\n-bfd_boolean\n+bool\n aarch64_ext_ldst_elemlist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t   aarch64_opnd_info *info, const aarch64_insn code,\n \t\t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -531,15 +531,15 @@ aarch64_ext_ldst_elemlist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     case 0x1:\n       if (QSsize & 0x1)\n \t/* UND.  */\n-\treturn FALSE;\n+\treturn false;\n       info->qualifier = AARCH64_OPND_QLF_S_H;\n       /* Index encoded in \"Q:S:size<1>\".  */\n       info->reglist.index = QSsize >> 1;\n       break;\n     case 0x2:\n       if ((QSsize >> 1) & 0x1)\n \t/* UND.  */\n-\treturn FALSE;\n+\treturn false;\n       if ((QSsize & 0x1) == 0)\n \t{\n \t  info->qualifier = AARCH64_OPND_QLF_S_S;\n@@ -550,14 +550,14 @@ aarch64_ext_ldst_elemlist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t{\n \t  if (extract_field (FLD_S, code, 0))\n \t    /* UND */\n-\t    return FALSE;\n+\t    return false;\n \t  info->qualifier = AARCH64_OPND_QLF_S_D;\n \t  /* Index encoded in \"Q\".  */\n \t  info->reglist.index = QSsize >> 3;\n \t}\n       break;\n     default:\n-      return FALSE;\n+      return false;\n     }\n \n   info->reglist.has_index = 1;\n@@ -567,14 +567,14 @@ aarch64_ext_ldst_elemlist (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   info->reglist.num_regs = get_opcode_dependent_value (inst->opcode);\n   assert (info->reglist.num_regs >= 1 && info->reglist.num_regs <= 4);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode fields immh:immb and/or Q for e.g.\n    SSHR <Vd>.<T>, <Vn>.<T>, #<shift>\n    or SSHR <V><d>, <V><n>, #<shift>.  */\n \n-bfd_boolean\n+bool\n aarch64_ext_advsimd_imm_shift (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t       aarch64_opnd_info *info, const aarch64_insn code,\n \t\t\t       const aarch64_inst *inst,\n@@ -586,7 +586,7 @@ aarch64_ext_advsimd_imm_shift (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \n   immh = extract_field (FLD_immh, code, 0);\n   if (immh == 0)\n-    return FALSE;\n+    return false;\n   imm = extract_fields (code, 0, 2, FLD_immh, FLD_immb);\n   pos = 4;\n   /* Get highest set bit in immh.  */\n@@ -634,11 +634,11 @@ aarch64_ext_advsimd_imm_shift (const aarch64_operand *self ATTRIBUTE_UNUSED,\n        1xxx\t(UInt(immh:immb)-64)  */\n     info->imm.value = imm - (8 << pos);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode shift immediate for e.g. sshr (imm).  */\n-bfd_boolean\n+bool\n aarch64_ext_shll_imm (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t      aarch64_opnd_info *info, const aarch64_insn code,\n \t\t      const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -652,15 +652,15 @@ aarch64_ext_shll_imm (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     case 0: imm = 8; break;\n     case 1: imm = 16; break;\n     case 2: imm = 32; break;\n-    default: return FALSE;\n+    default: return false;\n     }\n   info->imm.value = imm;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode imm for e.g. BFM <Wd>, <Wn>, #<immr>, #<imms>.\n    value in the field(s) will be extracted as unsigned immediate value.  */\n-bfd_boolean\n+bool\n aarch64_ext_imm (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t const aarch64_insn code,\n \t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -682,11 +682,11 @@ aarch64_ext_imm (const aarch64_operand *self, aarch64_opnd_info *info,\n     imm <<= 12;\n \n   info->imm.value = imm;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode imm and its shifter for e.g. MOVZ <Wd>, #<imm16>{, LSL #<shift>}.  */\n-bfd_boolean\n+bool\n aarch64_ext_imm_half (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t      const aarch64_insn code,\n \t\t      const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -695,12 +695,12 @@ aarch64_ext_imm_half (const aarch64_operand *self, aarch64_opnd_info *info,\n   aarch64_ext_imm (self, info, code, inst, errors);\n   info->shifter.kind = AARCH64_MOD_LSL;\n   info->shifter.amount = extract_field (FLD_hw, code, 0) << 4;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode cmode and \"a:b:c:d:e:f:g:h\" for e.g.\n      MOVI <Vd>.<T>, #<imm8> {, LSL #<amount>}.  */\n-bfd_boolean\n+bool\n aarch64_ext_advsimd_imm_modified (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t\t  aarch64_opnd_info *info,\n \t\t\t\t  const aarch64_insn code,\n@@ -749,7 +749,7 @@ aarch64_ext_advsimd_imm_modified (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \tcase 4: gen_sub_field (FLD_cmode, 1, 2, &field); break;\t/* per word */\n \tcase 2: gen_sub_field (FLD_cmode, 1, 1, &field); break;\t/* per half */\n \tcase 1: gen_sub_field (FLD_cmode, 1, 0, &field); break;\t/* per byte */\n-\tdefault: assert (0); return FALSE;\n+\tdefault: assert (0); return false;\n \t}\n       /* 00: 0; 01: 8; 10:16; 11:24.  */\n       info->shifter.amount = extract_field_2 (&field, code, 0) << 3;\n@@ -762,26 +762,26 @@ aarch64_ext_advsimd_imm_modified (const aarch64_operand *self ATTRIBUTE_UNUSED,\n       break;\n     default:\n       assert (0);\n-      return FALSE;\n+      return false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode an 8-bit floating-point immediate.  */\n-bfd_boolean\n+bool\n aarch64_ext_fpimm (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t   const aarch64_insn code,\n \t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t   aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   info->imm.value = extract_all_fields (self, code);\n   info->imm.is_fp = 1;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode a 1-bit rotate immediate (#90 or #270).  */\n-bfd_boolean\n+bool\n aarch64_ext_imm_rotate1 (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t\t const aarch64_insn code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -790,11 +790,11 @@ aarch64_ext_imm_rotate1 (const aarch64_operand *self, aarch64_opnd_info *info,\n   uint64_t rot = extract_field (self->fields[0], code, 0);\n   assert (rot < 2U);\n   info->imm.value = rot * 180 + 90;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode a 2-bit rotate immediate (#0, #90, #180 or #270).  */\n-bfd_boolean\n+bool\n aarch64_ext_imm_rotate2 (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t\t const aarch64_insn code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -803,23 +803,23 @@ aarch64_ext_imm_rotate2 (const aarch64_operand *self, aarch64_opnd_info *info,\n   uint64_t rot = extract_field (self->fields[0], code, 0);\n   assert (rot < 4U);\n   info->imm.value = rot * 90;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode scale for e.g. SCVTF <Dd>, <Wn>, #<fbits>.  */\n-bfd_boolean\n+bool\n aarch64_ext_fbits (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t   aarch64_opnd_info *info, const aarch64_insn code,\n \t\t   const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t   aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   info->imm.value = 64- extract_field (FLD_scale, code, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode arithmetic immediate for e.g.\n      SUBS <Wd>, <Wn|WSP>, #<imm> {, <shift>}.  */\n-bfd_boolean\n+bool\n aarch64_ext_aimm (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t  aarch64_opnd_info *info, const aarch64_insn code,\n \t\t  const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -831,18 +831,18 @@ aarch64_ext_aimm (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* shift */\n   value = extract_field (FLD_shift, code, 0);\n   if (value >= 2)\n-    return FALSE;\n+    return false;\n   info->shifter.amount = value ? 12 : 0;\n   /* imm12 (unsigned) */\n   info->imm.value = extract_field (FLD_imm12, code, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Return true if VALUE is a valid logical immediate encoding, storing the\n    decoded value in *RESULT if so.  ESIZE is the number of bytes in the\n    decoded immediate.  */\n-static bfd_boolean\n+static bool\n decode_limm (uint32_t esize, aarch64_insn value, int64_t *result)\n {\n   uint64_t imm, mask;\n@@ -870,19 +870,19 @@ decode_limm (uint32_t esize, aarch64_insn value, int64_t *result)\n \tcase 0x30 ... 0x37: /* 110xxx */ simd_size =  8; S &= 0x7; break;\n \tcase 0x38 ... 0x3b: /* 1110xx */ simd_size =  4; S &= 0x3; break;\n \tcase 0x3c ... 0x3d: /* 11110x */ simd_size =  2; S &= 0x1; break;\n-\tdefault: return FALSE;\n+\tdefault: return false;\n \t}\n       mask = (1ull << simd_size) - 1;\n       /* Top bits are IGNORED.  */\n       R &= simd_size - 1;\n     }\n \n   if (simd_size > esize * 8)\n-    return FALSE;\n+    return false;\n \n   /* NOTE: if S = simd_size - 1 we get 0xf..f which is rejected.  */\n   if (S == simd_size - 1)\n-    return FALSE;\n+    return false;\n   /* S+1 consecutive bits to 1.  */\n   /* NOTE: S can't be 63 due to detection above.  */\n   imm = (1ull << (S + 1)) - 1;\n@@ -908,11 +908,11 @@ decode_limm (uint32_t esize, aarch64_insn value, int64_t *result)\n \n   *result = imm & ~((uint64_t) -1 << (esize * 4) << (esize * 4));\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode a logical immediate for e.g. ORR <Wd|WSP>, <Wn>, #<imm>.  */\n-bfd_boolean\n+bool\n aarch64_ext_limm (const aarch64_operand *self,\n \t\t  aarch64_opnd_info *info, const aarch64_insn code,\n \t\t  const aarch64_inst *inst,\n@@ -928,21 +928,21 @@ aarch64_ext_limm (const aarch64_operand *self,\n }\n \n /* Decode a logical immediate for the BIC alias of AND (etc.).  */\n-bfd_boolean\n+bool\n aarch64_ext_inv_limm (const aarch64_operand *self,\n \t\t      aarch64_opnd_info *info, const aarch64_insn code,\n \t\t      const aarch64_inst *inst,\n \t\t      aarch64_operand_error *errors)\n {\n   if (!aarch64_ext_limm (self, info, code, inst, errors))\n-    return FALSE;\n+    return false;\n   info->imm.value = ~info->imm.value;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode Ft for e.g. STR <Qt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}]\n    or LDP <Qt1>, <Qt2>, [<Xn|SP>], #<imm>.  */\n-bfd_boolean\n+bool\n aarch64_ext_ft (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\taarch64_opnd_info *info,\n \t\tconst aarch64_insn code, const aarch64_inst *inst,\n@@ -966,7 +966,7 @@ aarch64_ext_ft (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \tcase 0: qualifier = AARCH64_OPND_QLF_S_S; break;\n \tcase 1: qualifier = AARCH64_OPND_QLF_S_D; break;\n \tcase 2: qualifier = AARCH64_OPND_QLF_S_Q; break;\n-\tdefault: return FALSE;\n+\tdefault: return false;\n \t}\n       info->qualifier = qualifier;\n     }\n@@ -975,15 +975,15 @@ aarch64_ext_ft (const aarch64_operand *self ATTRIBUTE_UNUSED,\n       /* opc1:size */\n       value = extract_fields (code, 0, 2, FLD_opc1, FLD_ldst_size);\n       if (value > 0x4)\n-\treturn FALSE;\n+\treturn false;\n       info->qualifier = get_sreg_qualifier_from_value (value);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode the address operand for e.g. STXRB <Ws>, <Wt>, [<Xn|SP>{,#0}].  */\n-bfd_boolean\n+bool\n aarch64_ext_addr_simple (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t aarch64_opnd_info *info,\n \t\t\t aarch64_insn code,\n@@ -992,12 +992,12 @@ aarch64_ext_addr_simple (const aarch64_operand *self ATTRIBUTE_UNUSED,\n {\n   /* Rn */\n   info->addr.base_regno = extract_field (FLD_Rn, code, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode the address operand for e.g.\n      stlur <Xt>, [<Xn|SP>{, <amount>}].  */\n-bfd_boolean\n+bool\n aarch64_ext_addr_offset (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t aarch64_opnd_info *info,\n \t\t\t aarch64_insn code, const aarch64_inst *inst,\n@@ -1015,12 +1015,12 @@ aarch64_ext_addr_offset (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     info->addr.writeback = 1;\n     info->addr.preind = 1;\n   }\n-  return TRUE;\n+  return true;\n }\n \n /* Decode the address operand for e.g.\n      STR <Qt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}].  */\n-bfd_boolean\n+bool\n aarch64_ext_addr_regoff (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t aarch64_opnd_info *info,\n \t\t\t aarch64_insn code, const aarch64_inst *inst,\n@@ -1035,7 +1035,7 @@ aarch64_ext_addr_regoff (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* option */\n   value = extract_field (FLD_option, code, 0);\n   info->shifter.kind =\n-    aarch64_get_operand_modifier_from_value (value, TRUE /* extend_p */);\n+    aarch64_get_operand_modifier_from_value (value, true /* extend_p */);\n   /* Fix-up the shifter kind; although the table-driven approach is\n      efficient, it is slightly inflexible, thus needing this fix-up.  */\n   if (info->shifter.kind == AARCH64_MOD_UXTX)\n@@ -1060,11 +1060,11 @@ aarch64_ext_addr_regoff (const aarch64_operand *self ATTRIBUTE_UNUSED,\n       info->shifter.amount_present = 1;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode the address operand for e.g. LDRSW <Xt>, [<Xn|SP>], #<simm>.  */\n-bfd_boolean\n+bool\n aarch64_ext_addr_simm (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t       aarch64_insn code, const aarch64_inst *inst,\n \t\t       aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n@@ -1097,11 +1097,11 @@ aarch64_ext_addr_simm (const aarch64_operand *self, aarch64_opnd_info *info,\n \tinfo->addr.postind = 1;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode the address operand for e.g. LDRSW <Xt>, [<Xn|SP>{, #<simm>}].  */\n-bfd_boolean\n+bool\n aarch64_ext_addr_uimm12 (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t\t aarch64_insn code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1114,11 +1114,11 @@ aarch64_ext_addr_uimm12 (const aarch64_operand *self, aarch64_opnd_info *info,\n   info->addr.base_regno = extract_field (self->fields[0], code, 0);\n   /* uimm12 */\n   info->addr.offset.imm = extract_field (self->fields[1], code, 0) << shift;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode the address operand for e.g. LDRAA <Xt>, [<Xn|SP>{, #<simm>}].  */\n-bfd_boolean\n+bool\n aarch64_ext_addr_simm10 (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t\t aarch64_insn code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1136,12 +1136,12 @@ aarch64_ext_addr_simm10 (const aarch64_operand *self, aarch64_opnd_info *info,\n     info->addr.writeback = 1;\n     info->addr.preind = 1;\n   }\n-  return TRUE;\n+  return true;\n }\n \n /* Decode the address operand for e.g.\n      LD1 {<Vt>.<T>, <Vt2>.<T>, <Vt3>.<T>}, [<Xn|SP>], <Xm|#<amount>>.  */\n-bfd_boolean\n+bool\n aarch64_ext_simd_addr_post (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t    aarch64_opnd_info *info,\n \t\t\t    aarch64_insn code, const aarch64_inst *inst,\n@@ -1171,11 +1171,11 @@ aarch64_ext_simd_addr_post (const aarch64_operand *self ATTRIBUTE_UNUSED,\n     info->addr.offset.is_reg = 1;\n   info->addr.writeback = 1;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode the condition operand for e.g. CSEL <Xd>, <Xn>, <Xm>, <cond>.  */\n-bfd_boolean\n+bool\n aarch64_ext_cond (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t  aarch64_opnd_info *info,\n \t\t  aarch64_insn code, const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1185,11 +1185,11 @@ aarch64_ext_cond (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* cond */\n   value = extract_field (FLD_cond, code, 0);\n   info->cond = get_cond_from_value (value);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode the system register operand for e.g. MRS <Xt>, <systemreg>.  */\n-bfd_boolean\n+bool\n aarch64_ext_sysreg (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t    aarch64_opnd_info *info,\n \t\t    aarch64_insn code,\n@@ -1214,11 +1214,11 @@ aarch64_ext_sysreg (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \tinfo->sysreg.flags = F_REG_WRITE;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode the PSTATE field operand for e.g. MSR <pstatefield>, #<imm>.  */\n-bfd_boolean\n+bool\n aarch64_ext_pstatefield (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1229,13 +1229,13 @@ aarch64_ext_pstatefield (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   info->pstatefield = extract_fields (code, 0, 2, FLD_op1, FLD_op2);\n   for (i = 0; aarch64_pstatefields[i].name != NULL; ++i)\n     if (aarch64_pstatefields[i].value == (aarch64_insn)info->pstatefield)\n-      return TRUE;\n+      return true;\n   /* Reserved value in <pstatefield>.  */\n-  return FALSE;\n+  return false;\n }\n \n /* Decode the system instruction op operand for e.g. AT <at_op>, <Xt>.  */\n-bfd_boolean\n+bool\n aarch64_ext_sysins_op (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t       aarch64_opnd_info *info,\n \t\t       aarch64_insn code,\n@@ -1262,7 +1262,7 @@ aarch64_ext_sysins_op (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t    aarch64_sys_regs_sr[].  */\n \tvalue = value & ~(0x7);\n \tbreak;\n-    default: assert (0); return FALSE;\n+    default: assert (0); return false;\n     }\n \n   for (i = 0; sysins_ops[i].name != NULL; ++i)\n@@ -1273,15 +1273,15 @@ aarch64_ext_sysins_op (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t     info->sysins_op->name,\n \t\t     (unsigned)info->sysins_op->value,\n \t\t     aarch64_sys_ins_reg_has_xt (info->sysins_op), i);\n-\treturn TRUE;\n+\treturn true;\n       }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Decode the memory barrier option operand for e.g. DMB <option>|#<imm>.  */\n \n-bfd_boolean\n+bool\n aarch64_ext_barrier (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t     aarch64_opnd_info *info,\n \t\t     aarch64_insn code,\n@@ -1290,12 +1290,12 @@ aarch64_ext_barrier (const aarch64_operand *self ATTRIBUTE_UNUSED,\n {\n   /* CRm */\n   info->barrier = aarch64_barrier_options + extract_field (FLD_CRm, code, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode the memory barrier option operand for DSB <option>nXS|#<imm>.  */\n \n-bfd_boolean\n+bool\n aarch64_ext_barrier_dsb_nxs (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t     aarch64_opnd_info *info,\n \t\t     aarch64_insn code,\n@@ -1305,27 +1305,27 @@ aarch64_ext_barrier_dsb_nxs (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* For the DSB nXS barrier variant immediate is encoded in 2-bit field.  */\n   aarch64_insn field = extract_field (FLD_CRm_dsb_nxs, code, 0);\n   info->barrier = aarch64_barrier_dsb_nxs_options + field;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode the prefetch operation option operand for e.g.\n      PRFM <prfop>, [<Xn|SP>{, #<pimm>}].  */\n \n-bfd_boolean\n+bool\n aarch64_ext_prfop (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t   aarch64_opnd_info *info,\n \t\t   aarch64_insn code, const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t   aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   /* prfop in Rt */\n   info->prfop = aarch64_prfops + extract_field (FLD_Rt, code, 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode the hint number for an alias taking an operand.  Set info->hint_option\n    to the matching name/value pair in aarch64_hint_options.  */\n \n-bfd_boolean\n+bool\n aarch64_ext_hint (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t  aarch64_opnd_info *info,\n \t\t  aarch64_insn code,\n@@ -1343,16 +1343,16 @@ aarch64_ext_hint (const aarch64_operand *self ATTRIBUTE_UNUSED,\n       if (hint_number == HINT_VAL (aarch64_hint_options[i].value))\n \t{\n \t  info->hint_option = &(aarch64_hint_options[i]);\n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Decode the extended register operand for e.g.\n      STR <Qt>, [<Xn|SP>, <R><m>{, <extend> {<amount>}}].  */\n-bfd_boolean\n+bool\n aarch64_ext_reg_extended (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t  aarch64_opnd_info *info,\n \t\t\t  aarch64_insn code,\n@@ -1366,7 +1366,7 @@ aarch64_ext_reg_extended (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* option */\n   value = extract_field (FLD_option, code, 0);\n   info->shifter.kind =\n-    aarch64_get_operand_modifier_from_value (value, TRUE /* extend_p */);\n+    aarch64_get_operand_modifier_from_value (value, true /* extend_p */);\n   /* imm3 */\n   info->shifter.amount = extract_field (FLD_imm3, code,  0);\n \n@@ -1381,12 +1381,12 @@ aarch64_ext_reg_extended (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t  || info->shifter.kind == AARCH64_MOD_SXTX))\n     info->qualifier = AARCH64_OPND_QLF_X;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode the shifted register operand for e.g.\n      SUBS <Xd>, <Xn>, <Xm> {, <shift> #<amount>}.  */\n-bfd_boolean\n+bool\n aarch64_ext_reg_shifted (const aarch64_operand *self ATTRIBUTE_UNUSED,\n \t\t\t aarch64_opnd_info *info,\n \t\t\t aarch64_insn code,\n@@ -1400,48 +1400,48 @@ aarch64_ext_reg_shifted (const aarch64_operand *self ATTRIBUTE_UNUSED,\n   /* shift */\n   value = extract_field (FLD_shift, code, 0);\n   info->shifter.kind =\n-    aarch64_get_operand_modifier_from_value (value, FALSE /* extend_p */);\n+    aarch64_get_operand_modifier_from_value (value, false /* extend_p */);\n   if (info->shifter.kind == AARCH64_MOD_ROR\n       && inst->opcode->iclass != log_shift)\n     /* ROR is not available for the shifted register operand in arithmetic\n        instructions.  */\n-    return FALSE;\n+    return false;\n   /* imm6 */\n   info->shifter.amount = extract_field (FLD_imm6, code,  0);\n \n   /* This makes the constraint checking happy.  */\n   info->shifter.operator_present = 1;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Decode an SVE address [<base>, #<offset>*<factor>, MUL VL],\n    where <offset> is given by the OFFSET parameter and where <factor> is\n    1 plus SELF's operand-dependent value.  fields[0] specifies the field\n    that holds <base>.  */\n-static bfd_boolean\n+static bool\n aarch64_ext_sve_addr_reg_mul_vl (const aarch64_operand *self,\n \t\t\t\t aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t\t int64_t offset)\n {\n   info->addr.base_regno = extract_field (self->fields[0], code, 0);\n   info->addr.offset.imm = offset * (1 + get_operand_specific_data (self));\n-  info->addr.offset.is_reg = FALSE;\n-  info->addr.writeback = FALSE;\n-  info->addr.preind = TRUE;\n+  info->addr.offset.is_reg = false;\n+  info->addr.writeback = false;\n+  info->addr.preind = true;\n   if (offset != 0)\n     info->shifter.kind = AARCH64_MOD_MUL_VL;\n   info->shifter.amount = 1;\n   info->shifter.operator_present = (info->addr.offset.imm != 0);\n-  info->shifter.amount_present = FALSE;\n-  return TRUE;\n+  info->shifter.amount_present = false;\n+  return true;\n }\n \n /* Decode an SVE address [<base>, #<simm4>*<factor>, MUL VL],\n    where <simm4> is a 4-bit signed value and where <factor> is 1 plus\n    SELF's operand-dependent value.  fields[0] specifies the field that\n    holds <base>.  <simm4> is encoded in the SVE_imm4 field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_ri_s4xvl (const aarch64_operand *self,\n \t\t\t       aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t       const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1458,7 +1458,7 @@ aarch64_ext_sve_addr_ri_s4xvl (const aarch64_operand *self,\n    where <simm6> is a 6-bit signed value and where <factor> is 1 plus\n    SELF's operand-dependent value.  fields[0] specifies the field that\n    holds <base>.  <simm6> is encoded in the SVE_imm6 field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_ri_s6xvl (const aarch64_operand *self,\n \t\t\t       aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t       const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1476,7 +1476,7 @@ aarch64_ext_sve_addr_ri_s6xvl (const aarch64_operand *self,\n    SELF's operand-dependent value.  fields[0] specifies the field that\n    holds <base>.  <simm9> is encoded in the concatenation of the SVE_imm6\n    and imm3 fields, with imm3 being the less-significant part.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_ri_s9xvl (const aarch64_operand *self,\n \t\t\t       aarch64_opnd_info *info,\n \t\t\t       aarch64_insn code,\n@@ -1493,25 +1493,25 @@ aarch64_ext_sve_addr_ri_s9xvl (const aarch64_operand *self,\n /* Decode an SVE address [<base>, #<offset> << <shift>], where <offset>\n    is given by the OFFSET parameter and where <shift> is SELF's operand-\n    dependent value.  fields[0] specifies the base register field <base>.  */\n-static bfd_boolean\n+static bool\n aarch64_ext_sve_addr_reg_imm (const aarch64_operand *self,\n \t\t\t      aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t      int64_t offset)\n {\n   info->addr.base_regno = extract_field (self->fields[0], code, 0);\n   info->addr.offset.imm = offset * (1 << get_operand_specific_data (self));\n-  info->addr.offset.is_reg = FALSE;\n-  info->addr.writeback = FALSE;\n-  info->addr.preind = TRUE;\n-  info->shifter.operator_present = FALSE;\n-  info->shifter.amount_present = FALSE;\n-  return TRUE;\n+  info->addr.offset.is_reg = false;\n+  info->addr.writeback = false;\n+  info->addr.preind = true;\n+  info->shifter.operator_present = false;\n+  info->shifter.amount_present = false;\n+  return true;\n }\n \n /* Decode an SVE address [X<n>, #<SVE_imm4> << <shift>], where <SVE_imm4>\n    is a 4-bit signed number and where <shift> is SELF's operand-dependent\n    value.  fields[0] specifies the base register field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_ri_s4 (const aarch64_operand *self,\n \t\t\t    aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1524,7 +1524,7 @@ aarch64_ext_sve_addr_ri_s4 (const aarch64_operand *self,\n /* Decode an SVE address [X<n>, #<SVE_imm6> << <shift>], where <SVE_imm6>\n    is a 6-bit unsigned number and where <shift> is SELF's operand-dependent\n    value.  fields[0] specifies the base register field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_ri_u6 (const aarch64_operand *self,\n \t\t\t    aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1537,7 +1537,7 @@ aarch64_ext_sve_addr_ri_u6 (const aarch64_operand *self,\n /* Decode an SVE address [X<n>, X<m>{, LSL #<shift>}], where <shift>\n    is SELF's operand-dependent value.  fields[0] specifies the base\n    register field and fields[1] specifies the offset register field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_rr_lsl (const aarch64_operand *self,\n \t\t\t     aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1547,49 +1547,49 @@ aarch64_ext_sve_addr_rr_lsl (const aarch64_operand *self,\n \n   index_regno = extract_field (self->fields[1], code, 0);\n   if (index_regno == 31 && (self->flags & OPD_F_NO_ZR) != 0)\n-    return FALSE;\n+    return false;\n \n   info->addr.base_regno = extract_field (self->fields[0], code, 0);\n   info->addr.offset.regno = index_regno;\n-  info->addr.offset.is_reg = TRUE;\n-  info->addr.writeback = FALSE;\n-  info->addr.preind = TRUE;\n+  info->addr.offset.is_reg = true;\n+  info->addr.writeback = false;\n+  info->addr.preind = true;\n   info->shifter.kind = AARCH64_MOD_LSL;\n   info->shifter.amount = get_operand_specific_data (self);\n   info->shifter.operator_present = (info->shifter.amount != 0);\n   info->shifter.amount_present = (info->shifter.amount != 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode an SVE address [X<n>, Z<m>.<T>, (S|U)XTW {#<shift>}], where\n    <shift> is SELF's operand-dependent value.  fields[0] specifies the\n    base register field, fields[1] specifies the offset register field and\n    fields[2] is a single-bit field that selects SXTW over UXTW.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_rz_xtw (const aarch64_operand *self,\n \t\t\t     aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t\t     aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   info->addr.base_regno = extract_field (self->fields[0], code, 0);\n   info->addr.offset.regno = extract_field (self->fields[1], code, 0);\n-  info->addr.offset.is_reg = TRUE;\n-  info->addr.writeback = FALSE;\n-  info->addr.preind = TRUE;\n+  info->addr.offset.is_reg = true;\n+  info->addr.writeback = false;\n+  info->addr.preind = true;\n   if (extract_field (self->fields[2], code, 0))\n     info->shifter.kind = AARCH64_MOD_SXTW;\n   else\n     info->shifter.kind = AARCH64_MOD_UXTW;\n   info->shifter.amount = get_operand_specific_data (self);\n-  info->shifter.operator_present = TRUE;\n+  info->shifter.operator_present = true;\n   info->shifter.amount_present = (info->shifter.amount != 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode an SVE address [Z<n>.<T>, #<imm5> << <shift>], where <imm5> is a\n    5-bit unsigned number and where <shift> is SELF's operand-dependent value.\n    fields[0] specifies the base register field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_zi_u5 (const aarch64_operand *self,\n \t\t\t    aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1603,27 +1603,27 @@ aarch64_ext_sve_addr_zi_u5 (const aarch64_operand *self,\n    where <modifier> is given by KIND and where <msz> is a 2-bit unsigned\n    number.  fields[0] specifies the base register field and fields[1]\n    specifies the offset register field.  */\n-static bfd_boolean\n+static bool\n aarch64_ext_sve_addr_zz (const aarch64_operand *self, aarch64_opnd_info *info,\n \t\t\t aarch64_insn code, enum aarch64_modifier_kind kind)\n {\n   info->addr.base_regno = extract_field (self->fields[0], code, 0);\n   info->addr.offset.regno = extract_field (self->fields[1], code, 0);\n-  info->addr.offset.is_reg = TRUE;\n-  info->addr.writeback = FALSE;\n-  info->addr.preind = TRUE;\n+  info->addr.offset.is_reg = true;\n+  info->addr.writeback = false;\n+  info->addr.preind = true;\n   info->shifter.kind = kind;\n   info->shifter.amount = extract_field (FLD_SVE_msz, code, 0);\n   info->shifter.operator_present = (kind != AARCH64_MOD_LSL\n \t\t\t\t    || info->shifter.amount != 0);\n   info->shifter.amount_present = (info->shifter.amount != 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode an SVE address [Z<n>.<T>, Z<m>.<T>{, LSL #<msz>}], where\n    <msz> is a 2-bit unsigned number.  fields[0] specifies the base register\n    field and fields[1] specifies the offset register field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_zz_lsl (const aarch64_operand *self,\n \t\t\t     aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t     const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1635,7 +1635,7 @@ aarch64_ext_sve_addr_zz_lsl (const aarch64_operand *self,\n /* Decode an SVE address [Z<n>.<T>, Z<m>.<T>, SXTW {#<msz>}], where\n    <msz> is a 2-bit unsigned number.  fields[0] specifies the base register\n    field and fields[1] specifies the offset register field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_zz_sxtw (const aarch64_operand *self,\n \t\t\t      aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t      const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1647,7 +1647,7 @@ aarch64_ext_sve_addr_zz_sxtw (const aarch64_operand *self,\n /* Decode an SVE address [Z<n>.<T>, Z<m>.<T>, UXTW {#<msz>}], where\n    <msz> is a 2-bit unsigned number.  fields[0] specifies the base register\n    field and fields[1] specifies the offset register field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_addr_zz_uxtw (const aarch64_operand *self,\n \t\t\t      aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t      const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1658,7 +1658,7 @@ aarch64_ext_sve_addr_zz_uxtw (const aarch64_operand *self,\n \n /* Finish decoding an SVE arithmetic immediate, given that INFO already\n    has the raw field value and that the low 8 bits decode to VALUE.  */\n-static bfd_boolean\n+static bool\n decode_sve_aimm (aarch64_opnd_info *info, int64_t value)\n {\n   info->shifter.kind = AARCH64_MOD_LSL;\n@@ -1674,11 +1674,11 @@ decode_sve_aimm (aarch64_opnd_info *info, int64_t value)\n   info->shifter.operator_present = (info->shifter.amount != 0);\n   info->shifter.amount_present = (info->shifter.amount != 0);\n   info->imm.value = value;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode an SVE ADD/SUB immediate.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_aimm (const aarch64_operand *self,\n \t\t      aarch64_opnd_info *info, const aarch64_insn code,\n \t\t      const aarch64_inst *inst,\n@@ -1689,7 +1689,7 @@ aarch64_ext_sve_aimm (const aarch64_operand *self,\n }\n \n /* Decode an SVE CPY/DUP immediate.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_asimm (const aarch64_operand *self,\n \t\t       aarch64_opnd_info *info, const aarch64_insn code,\n \t\t       const aarch64_inst *inst,\n@@ -1701,7 +1701,7 @@ aarch64_ext_sve_asimm (const aarch64_operand *self,\n \n /* Decode a single-bit immediate that selects between #0.5 and #1.0.\n    The fields array specifies which field to use.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_float_half_one (const aarch64_operand *self,\n \t\t\t\taarch64_opnd_info *info, aarch64_insn code,\n \t\t\t\tconst aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1711,13 +1711,13 @@ aarch64_ext_sve_float_half_one (const aarch64_operand *self,\n     info->imm.value = 0x3f800000;\n   else\n     info->imm.value = 0x3f000000;\n-  info->imm.is_fp = TRUE;\n-  return TRUE;\n+  info->imm.is_fp = true;\n+  return true;\n }\n \n /* Decode a single-bit immediate that selects between #0.5 and #2.0.\n    The fields array specifies which field to use.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_float_half_two (const aarch64_operand *self,\n \t\t\t\taarch64_opnd_info *info, aarch64_insn code,\n \t\t\t\tconst aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1727,13 +1727,13 @@ aarch64_ext_sve_float_half_two (const aarch64_operand *self,\n     info->imm.value = 0x40000000;\n   else\n     info->imm.value = 0x3f000000;\n-  info->imm.is_fp = TRUE;\n-  return TRUE;\n+  info->imm.is_fp = true;\n+  return true;\n }\n \n /* Decode a single-bit immediate that selects between #0.0 and #1.0.\n    The fields array specifies which field to use.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_float_zero_one (const aarch64_operand *self,\n \t\t\t\taarch64_opnd_info *info, aarch64_insn code,\n \t\t\t\tconst aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1743,15 +1743,15 @@ aarch64_ext_sve_float_zero_one (const aarch64_operand *self,\n     info->imm.value = 0x3f800000;\n   else\n     info->imm.value = 0x0;\n-  info->imm.is_fp = TRUE;\n-  return TRUE;\n+  info->imm.is_fp = true;\n+  return true;\n }\n \n /* Decode Zn[MM], where MM has a 7-bit triangular encoding.  The fields\n    array specifies which field to use for Zn.  MM is encoded in the\n    concatenation of imm5 and SVE_tszh, with imm5 being the less\n    significant part.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_index (const aarch64_operand *self,\n \t\t       aarch64_opnd_info *info, aarch64_insn code,\n \t\t       const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1766,11 +1766,11 @@ aarch64_ext_sve_index (const aarch64_operand *self,\n   while ((val & 1) == 0)\n     val /= 2;\n   info->reglane.index = val / 2;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode a logical immediate for the MOV alias of SVE DUPM.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_limm_mov (const aarch64_operand *self,\n \t\t\t  aarch64_opnd_info *info, const aarch64_insn code,\n \t\t\t  const aarch64_inst *inst,\n@@ -1784,7 +1784,7 @@ aarch64_ext_sve_limm_mov (const aarch64_operand *self,\n /* Decode Zn[MM], where Zn occupies the least-significant part of the field\n    and where MM occupies the most-significant part.  The operand-dependent\n    value specifies the number of bits in Zn.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_quad_index (const aarch64_operand *self,\n \t\t\t    aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t    const aarch64_inst *inst ATTRIBUTE_UNUSED,\n@@ -1794,41 +1794,41 @@ aarch64_ext_sve_quad_index (const aarch64_operand *self,\n   unsigned int val = extract_all_fields (self, code);\n   info->reglane.regno = val & ((1 << reg_bits) - 1);\n   info->reglane.index = val >> reg_bits;\n-  return TRUE;\n+  return true;\n }\n \n /* Decode {Zn.<T> - Zm.<T>}.  The fields array specifies which field\n    to use for Zn.  The opcode-dependent value specifies the number\n    of registers in the list.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_reglist (const aarch64_operand *self,\n \t\t\t aarch64_opnd_info *info, aarch64_insn code,\n \t\t\t const aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t\t\t aarch64_operand_error *errors ATTRIBUTE_UNUSED)\n {\n   info->reglist.first_regno = extract_field (self->fields[0], code, 0);\n   info->reglist.num_regs = get_opcode_dependent_value (inst->opcode);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode <pattern>{, MUL #<amount>}.  The fields array specifies which\n    fields to use for <pattern>.  <amount> - 1 is encoded in the SVE_imm4\n    field.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_scale (const aarch64_operand *self,\n \t\t       aarch64_opnd_info *info, aarch64_insn code,\n \t\t       const aarch64_inst *inst, aarch64_operand_error *errors)\n {\n   int val;\n \n   if (!aarch64_ext_imm (self, info, code, inst, errors))\n-    return FALSE;\n+    return false;\n   val = extract_field (FLD_SVE_imm4, code, 0);\n   info->shifter.kind = AARCH64_MOD_MUL;\n   info->shifter.amount = val + 1;\n   info->shifter.operator_present = (val != 0);\n   info->shifter.amount_present = (val != 0);\n-  return TRUE;\n+  return true;\n }\n \n /* Return the top set bit in VALUE, which is expected to be relatively\n@@ -1842,31 +1842,31 @@ get_top_bit (uint64_t value)\n }\n \n /* Decode an SVE shift-left immediate.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_shlimm (const aarch64_operand *self,\n \t\t\taarch64_opnd_info *info, const aarch64_insn code,\n \t\t\tconst aarch64_inst *inst, aarch64_operand_error *errors)\n {\n   if (!aarch64_ext_imm (self, info, code, inst, errors)\n       || info->imm.value == 0)\n-    return FALSE;\n+    return false;\n \n   info->imm.value -= get_top_bit (info->imm.value);\n-  return TRUE;\n+  return true;\n }\n \n /* Decode an SVE shift-right immediate.  */\n-bfd_boolean\n+bool\n aarch64_ext_sve_shrimm (const aarch64_operand *self,\n \t\t\taarch64_opnd_info *info, const aarch64_insn code,\n \t\t\tconst aarch64_inst *inst, aarch64_operand_error *errors)\n {\n   if (!aarch64_ext_imm (self, info, code, inst, errors)\n       || info->imm.value == 0)\n-    return FALSE;\n+    return false;\n \n   info->imm.value = get_top_bit (info->imm.value) * 2 - info->imm.value;\n-  return TRUE;\n+  return true;\n }\n \f\n /* Bitfields that are commonly used to encode certain operands' information\n@@ -2600,7 +2600,7 @@ convert_to_alias (aarch64_inst *inst, const aarch64_opcode *alias)\n     }\n }\n \n-static bfd_boolean\n+static bool\n aarch64_opcode_decode (const aarch64_opcode *, const aarch64_insn,\n \t\t       aarch64_inst *, int, aarch64_operand_error *errors);\n \n@@ -2759,7 +2759,7 @@ determine_disassembling_preference (struct aarch64_inst *inst,\n    and fill in the operand qualifiers accordingly.  Return true if no\n    problems are found.  */\n \n-static bfd_boolean\n+static bool\n aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n {\n   int i, variant;\n@@ -2774,7 +2774,7 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n     case sve_index:\n       i = extract_fields (inst->value, 0, 2, FLD_SVE_tszh, FLD_imm5);\n       if ((i & 31) == 0)\n-\treturn FALSE;\n+\treturn false;\n       while ((i & 1) == 0)\n \t{\n \t  i >>= 1;\n@@ -2810,7 +2810,7 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n       i = extract_fields (inst->value, 0, 2, FLD_SVE_tszh, FLD_SVE_tszl_8);\n     sve_shift:\n       if (i == 0)\n-\treturn FALSE;\n+\treturn false;\n       while (i != 1)\n \t{\n \t  i >>= 1;\n@@ -2825,7 +2825,7 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n     case sve_size_bhs:\n       variant = extract_field (FLD_size, inst->value, 0);\n       if (variant >= 3)\n-\treturn FALSE;\n+\treturn false;\n       break;\n \n     case sve_size_bhsd:\n@@ -2835,7 +2835,7 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n     case sve_size_hsd:\n       i = extract_field (FLD_size, inst->value, 0);\n       if (i < 1)\n-\treturn FALSE;\n+\treturn false;\n       variant = i - 1;\n       break;\n \n@@ -2851,7 +2851,7 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n     case sve_size_hsd2:\n       i = extract_field (FLD_SVE_size, inst->value, 0);\n       if (i < 1)\n-\treturn FALSE;\n+\treturn false;\n       variant = i - 1;\n       break;\n \n@@ -2865,7 +2865,7 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n     case sve_shift_tsz_bhsd:\n       i = extract_fields (inst->value, 0, 2, FLD_SVE_tszh, FLD_SVE_tszl_19);\n       if (i == 0)\n-\treturn FALSE;\n+\treturn false;\n       while (i != 1)\n \t{\n \t  i >>= 1;\n@@ -2876,11 +2876,11 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n     case sve_size_tsz_bhs:\n       i = extract_fields (inst->value, 0, 2, FLD_SVE_sz, FLD_SVE_tszl_19);\n       if (i == 0)\n-\treturn FALSE;\n+\treturn false;\n       while (i != 1)\n \t{\n \t  if (i & 1)\n-\t    return FALSE;\n+\t    return false;\n \t  i >>= 1;\n \t  variant += 1;\n \t}\n@@ -2889,7 +2889,7 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n     case sve_shift_tsz_hsd:\n       i = extract_fields (inst->value, 0, 2, FLD_SVE_sz, FLD_SVE_tszl_19);\n       if (i == 0)\n-\treturn FALSE;\n+\treturn false;\n       while (i != 1)\n \t{\n \t  i >>= 1;\n@@ -2899,12 +2899,12 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n \n     default:\n       /* No mapping between instruction class and qualifiers.  */\n-      return TRUE;\n+      return true;\n     }\n \n   for (i = 0; i < AARCH64_MAX_OPND_NUM; ++i)\n     inst->operands[i].qualifier = inst->opcode->qualifiers_list[variant][i];\n-  return TRUE;\n+  return true;\n }\n /* Decode the CODE according to OPCODE; fill INST.  Return 0 if the decoding\n    fails, which meanes that CODE is not an instruction of OPCODE; otherwise\n@@ -2914,7 +2914,7 @@ aarch64_decode_variant_using_iclass (aarch64_inst *inst)\n    determined and used to disassemble CODE; this is done just before the\n    return.  */\n \n-static bfd_boolean\n+static bool\n aarch64_opcode_decode (const aarch64_opcode *opcode, const aarch64_insn code,\n \t\t       aarch64_inst *inst, int noaliases_p,\n \t\t       aarch64_operand_error *errors)\n@@ -2983,7 +2983,7 @@ aarch64_opcode_decode (const aarch64_opcode *opcode, const aarch64_insn code,\n \n   /* If the opcode has a verifier, then check it now.  */\n   if (opcode->verifier\n-      && opcode->verifier (inst, code, 0, FALSE, errors, NULL) != ERR_OK)\n+      && opcode->verifier (inst, code, 0, false, errors, NULL) != ERR_OK)\n     {\n       DEBUG_TRACE (\"operand verifier FAIL\");\n       goto decode_fail;\n@@ -3000,15 +3000,15 @@ aarch64_opcode_decode (const aarch64_opcode *opcode, const aarch64_insn code,\n       if (!noaliases_p)\n \tdetermine_disassembling_preference (inst, errors);\n       DEBUG_TRACE (\"SUCCESS\");\n-      return TRUE;\n+      return true;\n     }\n   else\n     {\n       DEBUG_TRACE (\"constraint matching FAIL\");\n     }\n \n  decode_fail:\n-  return FALSE;\n+  return false;\n }\n \f\n /* This does some user-friendly fix-up to *INST.  It is currently focus on\n@@ -3040,7 +3040,7 @@ user_friendly_fixup (aarch64_inst *inst)\n \n enum err_type\n aarch64_decode_insn (aarch64_insn insn, aarch64_inst *inst,\n-\t\t     bfd_boolean noaliases_p,\n+\t\t     bool noaliases_p,\n \t\t     aarch64_operand_error *errors)\n {\n   const aarch64_opcode *opcode = aarch64_opcode_lookup (insn);\n@@ -3081,7 +3081,7 @@ aarch64_decode_insn (aarch64_insn insn, aarch64_inst *inst,\n static void\n print_operands (bfd_vma pc, const aarch64_opcode *opcode,\n \t\tconst aarch64_opnd_info *opnds, struct disassemble_info *info,\n-\t\tbfd_boolean *has_notes)\n+\t\tbool *has_notes)\n {\n   char *notes = NULL;\n   int i, pcrel_p, num_printed;\n@@ -3115,7 +3115,7 @@ print_operands (bfd_vma pc, const aarch64_opcode *opcode,\n \n     if (notes && !no_notes)\n       {\n-\t*has_notes = TRUE;\n+\t*has_notes = true;\n \t(*info->fprintf_func) (info->stream, \"  // note: %s\", notes);\n       }\n }\n@@ -3203,7 +3203,7 @@ print_aarch64_insn (bfd_vma pc, const aarch64_inst *inst,\n \t\t    struct disassemble_info *info,\n \t\t    aarch64_operand_error *mismatch_details)\n {\n-  bfd_boolean has_notes = FALSE;\n+  bool has_notes = false;\n \n   print_mnemonic_name (inst, info);\n   print_operands (pc, inst->opcode, inst->operands, info, &has_notes);\n@@ -3218,7 +3218,7 @@ print_aarch64_insn (bfd_vma pc, const aarch64_inst *inst,\n   /* Always run constraint verifiers, this is needed because constraints need to\n      maintain a global state regardless of whether the instruction has the flag\n      set or not.  */\n-  enum err_type result = verify_constraints (inst, code, pc, FALSE,\n+  enum err_type result = verify_constraints (inst, code, pc, false,\n \t\t\t\t\t     mismatch_details, &insn_sequence);\n   switch (result)\n     {\n@@ -3298,14 +3298,14 @@ print_insn_aarch64_word (bfd_vma pc,\n /* Disallow mapping symbols ($x, $d etc) from\n    being displayed in symbol relative addresses.  */\n \n-bfd_boolean\n+bool\n aarch64_symbol_is_valid (asymbol * sym,\n \t\t\t struct disassemble_info * info ATTRIBUTE_UNUSED)\n {\n   const char * name;\n \n   if (sym == NULL)\n-    return FALSE;\n+    return false;\n \n   name = bfd_asymbol_name (sym);\n \n@@ -3353,14 +3353,14 @@ get_sym_code_type (struct disassemble_info *info, int n,\n \n   /* If the symbol is in a different section, ignore it.  */\n   if (info->section != NULL && info->section != info->symtab[n]->section)\n-    return FALSE;\n+    return false;\n \n   if (n >= info->symtab_size)\n-    return FALSE;\n+    return false;\n \n   as = info->symtab[n];\n   if (bfd_asymbol_flavour (as) != bfd_target_elf_flavour)\n-    return FALSE;\n+    return false;\n   es = (elf_symbol_type *) as;\n \n   type = ELF_ST_TYPE (es->internal_elf_sym.st_info);\n@@ -3369,7 +3369,7 @@ get_sym_code_type (struct disassemble_info *info, int n,\n   if (type == STT_FUNC)\n     {\n       *map_type = MAP_INSN;\n-      return TRUE;\n+      return true;\n     }\n \n   /* Check for mapping symbols.  */\n@@ -3379,10 +3379,10 @@ get_sym_code_type (struct disassemble_info *info, int n,\n       && (name[2] == '\\0' || name[2] == '.'))\n     {\n       *map_type = (name[1] == 'x' ? MAP_INSN : MAP_DATA);\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Set the feature bits in arch_variant in order to get the correct disassembly\n@@ -3413,11 +3413,11 @@ print_insn_aarch64 (bfd_vma pc,\n   int\t\tstatus;\n   void\t\t(*printer) (bfd_vma, uint32_t, struct disassemble_info *,\n \t\t\t    aarch64_operand_error *);\n-  bfd_boolean   found = FALSE;\n+  bool   found = false;\n   unsigned int\tsize = 4;\n   unsigned long\tdata;\n   aarch64_operand_error errors;\n-  static bfd_boolean set_features;\n+  static bool set_features;\n \n   if (info->disassembler_options)\n     {\n@@ -3432,7 +3432,7 @@ print_insn_aarch64 (bfd_vma pc,\n   if (!set_features)\n     {\n       select_aarch64_variant (info->mach);\n-      set_features = TRUE;\n+      set_features = true;\n     }\n \n   /* Aarch64 instructions are always little-endian */\n@@ -3457,7 +3457,7 @@ print_insn_aarch64 (bfd_vma pc,\n     {\n       int last_sym = -1;\n       bfd_vma addr, section_vma = 0;\n-      bfd_boolean can_use_search_opt_p;\n+      bool can_use_search_opt_p;\n       int n;\n \n       if (pc <= last_mapping_addr)\n@@ -3488,7 +3488,7 @@ print_insn_aarch64 (bfd_vma pc,\n \t  if (get_sym_code_type (info, n, &type))\n \t    {\n \t      last_sym = n;\n-\t      found = TRUE;\n+\t      found = true;\n \t    }\n \t}\n \n@@ -3516,7 +3516,7 @@ print_insn_aarch64 (bfd_vma pc,\n \t      if (get_sym_code_type (info, n, &type))\n \t\t{\n \t\t  last_sym = n;\n-\t\t  found = TRUE;\n+\t\t  found = true;\n \t\t  break;\n \t\t}\n \t    }"
    },
    {
      "sha": "09305b9c07dac6099fa0617ca845cecaf3841ecf",
      "filename": "opcodes/aarch64-dis.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-dis.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-dis.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-dis.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -50,17 +50,17 @@ const aarch64_opcode* aarch64_find_next_alias_opcode (const aarch64_opcode *);\n \n /* Switch-table-based high-level operand extractor.  */\n \n-bfd_boolean\n+bool\n aarch64_extract_operand (const aarch64_operand *, aarch64_opnd_info *,\n \t\t\t const aarch64_insn, const aarch64_inst *,\n \t\t\t aarch64_operand_error *);\n \n /* Operand extractors.  */\n \n #define AARCH64_DECL_OPD_EXTRACTOR(x)\t\\\n-  bfd_boolean aarch64_##x (const aarch64_operand *, aarch64_opnd_info *, \\\n-\t\t\t   const aarch64_insn, const aarch64_inst *, \\\n-\t\t\t   aarch64_operand_error *)\n+  bool aarch64_##x (const aarch64_operand *, aarch64_opnd_info *,\t\\\n+\t\t    const aarch64_insn, const aarch64_inst *,\t\t\\\n+\t\t    aarch64_operand_error *)\n \n AARCH64_DECL_OPD_EXTRACTOR (ext_none);\n AARCH64_DECL_OPD_EXTRACTOR (ext_regno);"
    },
    {
      "sha": "356c5efcf3c30f94bac0f6ebd2e79e4e27db6e1a",
      "filename": "opcodes/aarch64-gen.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-gen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-gen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-gen.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -984,7 +984,7 @@ print_operand_inserter (void)\n     printf (\"Enter print_operand_inserter\\n\");\n \n   printf (\"\\n\");\n-  printf (\"bfd_boolean\\n\");\n+  printf (\"bool\\n\");\n   printf (\"aarch64_insert_operand (const aarch64_operand *self,\\n\\\n \t\t\t   const aarch64_opnd_info *info,\\n\\\n \t\t\t   aarch64_insn *code, const aarch64_inst *inst,\\n\\\n@@ -1041,7 +1041,7 @@ print_operand_extractor (void)\n     printf (\"Enter print_operand_extractor\\n\");\n \n   printf (\"\\n\");\n-  printf (\"bfd_boolean\\n\");\n+  printf (\"bool\\n\");\n   printf (\"aarch64_extract_operand (const aarch64_operand *self,\\n\\\n \t\t\t   aarch64_opnd_info *info,\\n\\\n \t\t\t   aarch64_insn code, const aarch64_inst *inst,\\n\\"
    },
    {
      "sha": "79b37bf61f55e77848283b2178d02d66872203f3",
      "filename": "opcodes/aarch64-opc.c",
      "status": "modified",
      "additions": 68,
      "deletions": 68,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-opc.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -32,7 +32,7 @@\n #include \"aarch64-opc.h\"\n \n #ifdef DEBUG_AARCH64\n-int debug_dump = FALSE;\n+int debug_dump = false;\n #endif /* DEBUG_AARCH64 */\n \n /* The enumeration strings associated with each value of a 5-bit SVE\n@@ -102,14 +102,14 @@ const char *const aarch64_sve_prfop_array[16] = {\n /* Helper functions to determine which operand to be used to encode/decode\n    the size:Q fields for AdvSIMD instructions.  */\n \n-static inline bfd_boolean\n+static inline bool\n vector_qualifier_p (enum aarch64_opnd_qualifier qualifier)\n {\n   return (qualifier >= AARCH64_OPND_QLF_V_8B\n \t  && qualifier <= AARCH64_OPND_QLF_V_1Q);\n }\n \n-static inline bfd_boolean\n+static inline bool\n fp_qualifier_p (enum aarch64_opnd_qualifier qualifier)\n {\n   return (qualifier >= AARCH64_OPND_QLF_S_B\n@@ -423,21 +423,21 @@ aarch64_get_operand_modifier_value (enum aarch64_modifier_kind kind)\n \n enum aarch64_modifier_kind\n aarch64_get_operand_modifier_from_value (aarch64_insn value,\n-\t\t\t\t\t bfd_boolean extend_p)\n+\t\t\t\t\t bool extend_p)\n {\n   if (extend_p)\n     return AARCH64_MOD_UXTB + value;\n   else\n     return AARCH64_MOD_LSL - value;\n }\n \n-bfd_boolean\n+bool\n aarch64_extend_operator_p (enum aarch64_modifier_kind kind)\n {\n   return kind > AARCH64_MOD_LSL && kind <= AARCH64_MOD_SXTX;\n }\n \n-static inline bfd_boolean\n+static inline bool\n aarch64_shift_operator_p (enum aarch64_modifier_kind kind)\n {\n   return kind >= AARCH64_MOD_ROR && kind <= AARCH64_MOD_LSL;\n@@ -760,13 +760,13 @@ struct operand_qualifier_data aarch64_opnd_qualifiers[] =\n   {0, 0, 0, \"retrieving\", 0},\n };\n \n-static inline bfd_boolean\n+static inline bool\n operand_variant_qualifier_p (aarch64_opnd_qualifier_t qualifier)\n {\n   return aarch64_opnd_qualifiers[qualifier].kind == OQK_OPD_VARIANT;\n }\n \n-static inline bfd_boolean\n+static inline bool\n qualifier_value_in_range_constraint_p (aarch64_opnd_qualifier_t qualifier)\n {\n   return aarch64_opnd_qualifiers[qualifier].kind == OQK_VALUE_IN_RANGE;\n@@ -856,20 +856,20 @@ dump_match_qualifiers (const struct aarch64_opnd_info *opnd,\n /* This function checks if the given instruction INSN is a destructive\n    instruction based on the usage of the registers.  It does not recognize\n    unary destructive instructions.  */\n-bfd_boolean\n+bool\n aarch64_is_destructive_by_operands (const aarch64_opcode *opcode)\n {\n   int i = 0;\n   const enum aarch64_opnd *opnds = opcode->operands;\n \n   if (opnds[0] == AARCH64_OPND_NIL)\n-    return FALSE;\n+    return false;\n \n   while (opnds[++i] != AARCH64_OPND_NIL)\n     if (opnds[i] == opnds[0])\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* TODO improve this, we can have an extra field at the runtime to\n@@ -1021,7 +1021,7 @@ aarch64_find_best_match (const aarch64_inst *inst,\n    succeeds.  */\n \n static int\n-match_operands_qualifier (aarch64_inst *inst, bfd_boolean update_p)\n+match_operands_qualifier (aarch64_inst *inst, bool update_p)\n {\n   int i, nops;\n   aarch64_opnd_qualifier_seq_t qualifiers;\n@@ -1039,7 +1039,7 @@ match_operands_qualifier (aarch64_inst *inst, bfd_boolean update_p)\n       nops = aarch64_num_of_operands (inst->opcode);\n       for (i = 0; i < nops; ++i)\n \tif (inst->operands[i].qualifier != qualifiers[i])\n-\t  return FALSE;\n+\t  return false;\n     }\n \n   /* Update the qualifiers.  */\n@@ -1066,7 +1066,7 @@ match_operands_qualifier (aarch64_inst *inst, bfd_boolean update_p)\n    If SHIFT_AMOUNT is not NULL, on the return of TRUE, the logical left shift\n    amount will be returned in *SHIFT_AMOUNT.  */\n \n-bfd_boolean\n+bool\n aarch64_wide_constant_p (uint64_t value, int is32, unsigned int *shift_amount)\n {\n   int amount;\n@@ -1080,7 +1080,7 @@ aarch64_wide_constant_p (uint64_t value, int is32, unsigned int *shift_amount)\n \t permitted.  */\n       if (value >> 32 != 0 && value >> 32 != 0xffffffff)\n \t/* Immediate out of range.  */\n-\treturn FALSE;\n+\treturn false;\n       value &= 0xffffffff;\n     }\n \n@@ -1097,16 +1097,16 @@ aarch64_wide_constant_p (uint64_t value, int is32, unsigned int *shift_amount)\n \n   if (amount == -1)\n     {\n-      DEBUG_TRACE (\"exit FALSE with 0x%\" PRIx64 \"(%\" PRIi64 \")\", value, value);\n-      return FALSE;\n+      DEBUG_TRACE (\"exit false with 0x%\" PRIx64 \"(%\" PRIi64 \")\", value, value);\n+      return false;\n     }\n \n   if (shift_amount != NULL)\n     *shift_amount = amount;\n \n-  DEBUG_TRACE (\"exit TRUE with amount %d\", amount);\n+  DEBUG_TRACE (\"exit true with amount %d\", amount);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Build the accepted values for immediate logical SIMD instructions.\n@@ -1239,12 +1239,12 @@ build_immediate_table (void)\n    If ENCODING is not NULL, on the return of TRUE, the standard encoding for\n    VALUE will be returned in *ENCODING.  */\n \n-bfd_boolean\n+bool\n aarch64_logical_immediate_p (uint64_t value, int esize, aarch64_insn *encoding)\n {\n   simd_imm_encoding imm_enc;\n   const simd_imm_encoding *imm_encoding;\n-  static bfd_boolean initialized = FALSE;\n+  static bool initialized = false;\n   uint64_t upper;\n   int i;\n \n@@ -1254,14 +1254,14 @@ aarch64_logical_immediate_p (uint64_t value, int esize, aarch64_insn *encoding)\n   if (!initialized)\n     {\n       build_immediate_table ();\n-      initialized = TRUE;\n+      initialized = true;\n     }\n \n   /* Allow all zeros or all ones in top bits, so that\n      constant expressions like ~1 are permitted.  */\n   upper = (uint64_t) -1 << (esize * 4) << (esize * 4);\n   if ((value & ~upper) != value && (value | upper) != value)\n-    return FALSE;\n+    return false;\n \n   /* Replicate to a full 64-bit value.  */\n   value &= ~upper;\n@@ -1274,13 +1274,13 @@ aarch64_logical_immediate_p (uint64_t value, int esize, aarch64_insn *encoding)\n             sizeof(simd_immediates[0]), simd_imm_encoding_cmp);\n   if (imm_encoding == NULL)\n     {\n-      DEBUG_TRACE (\"exit with FALSE\");\n-      return FALSE;\n+      DEBUG_TRACE (\"exit with false\");\n+      return false;\n     }\n   if (encoding != NULL)\n     *encoding = imm_encoding->encoding;\n-  DEBUG_TRACE (\"exit with TRUE\");\n-  return TRUE;\n+  DEBUG_TRACE (\"exit with true\");\n+  return true;\n }\n \n /* If 64-bit immediate IMM is in the format of\n@@ -2768,7 +2768,7 @@ aarch64_match_operands_constraint (aarch64_inst *inst,\n      constraint checking will carried out by operand_general_constraint_met_p,\n      which has be to called after this in order to get all of the operands'\n      qualifiers established.  */\n-  if (match_operands_qualifier (inst, TRUE /* update_p */) == 0)\n+  if (match_operands_qualifier (inst, true /* update_p */) == 0)\n     {\n       DEBUG_TRACE (\"FAIL on operand qualifier matching\");\n       if (mismatch_detail)\n@@ -3099,20 +3099,20 @@ print_register_offset_address (char *buf, size_t size,\n \t\t\t       const char *base, const char *offset)\n {\n   char tb[16];\t\t\t/* Temporary buffer.  */\n-  bfd_boolean print_extend_p = TRUE;\n-  bfd_boolean print_amount_p = TRUE;\n+  bool print_extend_p = true;\n+  bool print_amount_p = true;\n   const char *shift_name = aarch64_operand_modifiers[opnd->shifter.kind].name;\n \n   if (!opnd->shifter.amount && (opnd->qualifier != AARCH64_OPND_QLF_S_B\n \t\t\t\t|| !opnd->shifter.amount_present))\n     {\n       /* Not print the shift/extend amount when the amount is zero and\n          when it is not the special case of 8-bit load/store instruction.  */\n-      print_amount_p = FALSE;\n+      print_amount_p = false;\n       /* Likewise, no need to print the shift operator LSL in such a\n \t situation.  */\n       if (opnd->shifter.kind == AARCH64_MOD_LSL)\n-\tprint_extend_p = FALSE;\n+\tprint_extend_p = false;\n     }\n \n   /* Prepare for the extend/shift.  */\n@@ -3695,7 +3695,7 @@ aarch64_print_operand (char *buf, size_t size, bfd_vma pc,\n \t{\n \t  const aarch64_sys_reg *sr = aarch64_sys_regs + i;\n \n-\t  bfd_boolean exact_match\n+\t  bool exact_match\n \t    = (!(sr->flags & (F_REG_READ | F_REG_WRITE))\n \t    || (sr->flags & opnd->sysreg.flags) == opnd->sysreg.flags)\n \t    && AARCH64_CPU_HAS_FEATURE (features, sr->features);\n@@ -4685,7 +4685,7 @@ const aarch64_sys_reg aarch64_sys_regs [] =\n   { 0, CPENC (0,0,0,0,0), 0, 0 }\n };\n \n-bfd_boolean\n+bool\n aarch64_sys_reg_deprecated_p (const uint32_t reg_flags)\n {\n   return (reg_flags & F_DEPRECATED) != 0;\n@@ -4711,12 +4711,12 @@ const aarch64_sys_reg aarch64_pstatefields [] =\n   { 0,\t  CPENC (0,0,0,0,0), 0, 0 },\n };\n \n-bfd_boolean\n+bool\n aarch64_pstatefield_supported_p (const aarch64_feature_set features,\n \t\t\t\t const aarch64_sys_reg *reg)\n {\n   if (!(reg->flags & F_ARCHEXT))\n-    return TRUE;\n+    return true;\n \n   return AARCH64_CPU_HAS_ALL_FEATURES (features, reg->features);\n }\n@@ -4878,13 +4878,13 @@ const aarch64_sys_ins_reg aarch64_sys_regs_sr[] =\n     { 0,       CPENS(0,0,0,0), 0 }\n };\n \n-bfd_boolean\n+bool\n aarch64_sys_ins_reg_has_xt (const aarch64_sys_ins_reg *sys_ins_reg)\n {\n   return (sys_ins_reg->flags & F_HASXT) != 0;\n }\n \n-extern bfd_boolean\n+extern bool\n aarch64_sys_ins_reg_supported_p (const aarch64_feature_set features,\n \t\t const char *reg_name,\n                  aarch64_insn reg_value,\n@@ -4896,15 +4896,15 @@ aarch64_sys_ins_reg_supported_p (const aarch64_feature_set features,\n     {\n       const char *suffix = strrchr (reg_name, '_');\n       if (suffix && !strcmp (suffix, \"_el3\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (!(reg_flags & F_ARCHEXT))\n-    return TRUE;\n+    return true;\n \n   if (reg_features\n       && AARCH64_CPU_HAS_ALL_FEATURES (features, reg_features))\n-    return TRUE;\n+    return true;\n \n   /* ARMv8.4 TLB instructions.  */\n   if ((reg_value == CPENS (0, C8, C1, 0)\n@@ -4954,17 +4954,17 @@ aarch64_sys_ins_reg_supported_p (const aarch64_feature_set features,\n        || reg_value == CPENS (6, C8, C5, 1)\n        || reg_value == CPENS (6, C8, C5, 5))\n       && AARCH64_CPU_HAS_FEATURE (features, AARCH64_FEATURE_V8_4))\n-    return TRUE;\n+    return true;\n \n   /* DC CVAP.  Values are from aarch64_sys_regs_dc.  */\n   if (reg_value == CPENS (3, C7, C12, 1)\n       && AARCH64_CPU_HAS_FEATURE (features, AARCH64_FEATURE_V8_2))\n-    return TRUE;\n+    return true;\n \n   /* DC CVADP.  Values are from aarch64_sys_regs_dc.  */\n   if (reg_value == CPENS (3, C7, C13, 1)\n       && AARCH64_CPU_HAS_FEATURE (features, AARCH64_FEATURE_CVADP))\n-    return TRUE;\n+    return true;\n \n   /* DC <dc_op> for ARMv8.5-A Memory Tagging Extension.  */\n   if ((reg_value == CPENS (0, C7, C6, 3)\n@@ -4986,20 +4986,20 @@ aarch64_sys_ins_reg_supported_p (const aarch64_feature_set features,\n        || reg_value == CPENS (3, C7, C14, 5)\n        || reg_value == CPENS (3, C7, C4, 4))\n       && AARCH64_CPU_HAS_FEATURE (features, AARCH64_FEATURE_MEMTAG))\n-    return TRUE;\n+    return true;\n \n   /* AT S1E1RP, AT S1E1WP.  Values are from aarch64_sys_regs_at.  */\n   if ((reg_value == CPENS (0, C7, C9, 0)\n        || reg_value == CPENS (0, C7, C9, 1))\n       && AARCH64_CPU_HAS_FEATURE (features, AARCH64_FEATURE_V8_2))\n-    return TRUE;\n+    return true;\n \n   /* CFP/DVP/CPP RCTX : Value are from aarch64_sys_regs_sr. */\n   if (reg_value == CPENS (3, C7, C3, 0)\n       && AARCH64_CPU_HAS_FEATURE (features, AARCH64_FEATURE_PREDRES))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n #undef C0\n@@ -5025,7 +5025,7 @@ aarch64_sys_ins_reg_supported_p (const aarch64_feature_set features,\n static enum err_type\n verify_ldpsw (const struct aarch64_inst *inst ATTRIBUTE_UNUSED,\n \t      const aarch64_insn insn, bfd_vma pc ATTRIBUTE_UNUSED,\n-\t      bfd_boolean encoding ATTRIBUTE_UNUSED,\n+\t      bool encoding ATTRIBUTE_UNUSED,\n \t      aarch64_operand_error *mismatch_detail ATTRIBUTE_UNUSED,\n \t      aarch64_instr_sequence *insn_sequence ATTRIBUTE_UNUSED)\n {\n@@ -5055,7 +5055,7 @@ verify_ldpsw (const struct aarch64_inst *inst ATTRIBUTE_UNUSED,\n \n static enum err_type\n verify_elem_sd (const struct aarch64_inst *inst, const aarch64_insn insn,\n-\t\tbfd_vma pc ATTRIBUTE_UNUSED, bfd_boolean encoding,\n+\t\tbfd_vma pc ATTRIBUTE_UNUSED, bool encoding,\n \t\taarch64_operand_error *mismatch_detail ATTRIBUTE_UNUSED,\n \t\taarch64_instr_sequence *insn_sequence ATTRIBUTE_UNUSED)\n {\n@@ -5130,7 +5130,7 @@ enum err_type\n verify_constraints (const struct aarch64_inst *inst,\n \t\t    const aarch64_insn insn ATTRIBUTE_UNUSED,\n \t\t    bfd_vma pc,\n-\t\t    bfd_boolean encoding,\n+\t\t    bool encoding,\n \t\t    aarch64_operand_error *mismatch_detail,\n \t\t    aarch64_instr_sequence *insn_sequence)\n {\n@@ -5154,7 +5154,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t  mismatch_detail->error = _(\"instruction opens new dependency \"\n \t\t\t\t     \"sequence without ending previous one\");\n \t  mismatch_detail->index = -1;\n-\t  mismatch_detail->non_fatal = TRUE;\n+\t  mismatch_detail->non_fatal = true;\n \t  res = ERR_VFI;\n \t}\n \n@@ -5173,7 +5173,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t  mismatch_detail->kind = AARCH64_OPDE_SYNTAX_ERROR;\n \t  mismatch_detail->error = _(\"previous `movprfx' sequence not closed\");\n \t  mismatch_detail->index = -1;\n-\t  mismatch_detail->non_fatal = TRUE;\n+\t  mismatch_detail->non_fatal = true;\n \t  res = ERR_VFI;\n \t  /* Reset the sequence.  */\n \t  init_insn_sequence (NULL, insn_sequence);\n@@ -5193,7 +5193,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t      mismatch_detail->error = _(\"SVE instruction expected after \"\n \t\t\t\t\t \"`movprfx'\");\n \t      mismatch_detail->index = -1;\n-\t      mismatch_detail->non_fatal = TRUE;\n+\t      mismatch_detail->non_fatal = true;\n \t      res = ERR_VFI;\n \t      goto done;\n \t    }\n@@ -5206,7 +5206,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t      mismatch_detail->error = _(\"SVE `movprfx' compatible instruction \"\n \t\t\t\t\t \"expected\");\n \t      mismatch_detail->index = -1;\n-\t      mismatch_detail->non_fatal = TRUE;\n+\t      mismatch_detail->non_fatal = true;\n \t      res = ERR_VFI;\n \t      goto done;\n \t    }\n@@ -5216,13 +5216,13 @@ verify_constraints (const struct aarch64_inst *inst,\n \t  aarch64_opnd_info blk_pred, inst_pred;\n \t  memset (&blk_pred, 0, sizeof (aarch64_opnd_info));\n \t  memset (&inst_pred, 0, sizeof (aarch64_opnd_info));\n-\t  bfd_boolean predicated = FALSE;\n+\t  bool predicated = false;\n \t  assert (blk_dest.type == AARCH64_OPND_SVE_Zd);\n \n \t  /* Determine if the movprfx instruction used is predicated or not.  */\n \t  if (insn_sequence->instr->operands[1].type == AARCH64_OPND_SVE_Pg3)\n \t    {\n-\t      predicated = TRUE;\n+\t      predicated = true;\n \t      blk_pred = insn_sequence->instr->operands[1];\n \t    }\n \n@@ -5293,7 +5293,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t\t  mismatch_detail->error = _(\"predicated instruction expected \"\n \t\t\t\t\t     \"after `movprfx'\");\n \t\t  mismatch_detail->index = -1;\n-\t\t  mismatch_detail->non_fatal = TRUE;\n+\t\t  mismatch_detail->non_fatal = true;\n \t\t  res = ERR_VFI;\n \t\t  goto done;\n \t\t}\n@@ -5305,7 +5305,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t\t  mismatch_detail->error = _(\"merging predicate expected due \"\n \t\t\t\t\t     \"to preceding `movprfx'\");\n \t\t  mismatch_detail->index = inst_pred_idx;\n-\t\t  mismatch_detail->non_fatal = TRUE;\n+\t\t  mismatch_detail->non_fatal = true;\n \t\t  res = ERR_VFI;\n \t\t  goto done;\n \t\t}\n@@ -5318,7 +5318,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t\t\t\t\t     \"from that in preceding \"\n \t\t\t\t\t     \"`movprfx'\");\n \t\t  mismatch_detail->index = inst_pred_idx;\n-\t\t  mismatch_detail->non_fatal = TRUE;\n+\t\t  mismatch_detail->non_fatal = true;\n \t\t  res = ERR_VFI;\n \t\t  goto done;\n \t\t}\n@@ -5337,7 +5337,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t\t\t\t\t \"`movprfx' not used in current \"\n \t\t\t\t\t \"instruction\");\n \t      mismatch_detail->index = 0;\n-\t      mismatch_detail->non_fatal = TRUE;\n+\t      mismatch_detail->non_fatal = true;\n \t      res = ERR_VFI;\n \t      goto done;\n \t    }\n@@ -5349,7 +5349,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t      mismatch_detail->error = _(\"output register of preceding \"\n \t\t\t\t\t \"`movprfx' expected as output\");\n \t      mismatch_detail->index = 0;\n-\t      mismatch_detail->non_fatal = TRUE;\n+\t      mismatch_detail->non_fatal = true;\n \t      res = ERR_VFI;\n \t      goto done;\n \t    }\n@@ -5361,7 +5361,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t      mismatch_detail->error = _(\"output register of preceding \"\n \t\t\t\t\t \"`movprfx' used as input\");\n \t      mismatch_detail->index = last_op_usage;\n-\t      mismatch_detail->non_fatal = TRUE;\n+\t      mismatch_detail->non_fatal = true;\n \t      res = ERR_VFI;\n \t      goto done;\n \t    }\n@@ -5377,7 +5377,7 @@ verify_constraints (const struct aarch64_inst *inst,\n \t      mismatch_detail->error = _(\"register size not compatible with \"\n \t\t\t\t\t \"previous `movprfx'\");\n \t      mismatch_detail->index = 0;\n-\t      mismatch_detail->non_fatal = TRUE;\n+\t      mismatch_detail->non_fatal = true;\n \t      res = ERR_VFI;\n \t      goto done;\n \t    }\n@@ -5405,22 +5405,22 @@ verify_constraints (const struct aarch64_inst *inst,\n    (with any element size, not just ESIZE) and if using DUPM would\n    therefore be OK.  ESIZE is the number of bytes in the immediate.  */\n \n-bfd_boolean\n+bool\n aarch64_sve_dupm_mov_immediate_p (uint64_t uvalue, int esize)\n {\n   int64_t svalue = uvalue;\n   uint64_t upper = (uint64_t) -1 << (esize * 4) << (esize * 4);\n \n   if ((uvalue & ~upper) != uvalue && (uvalue | upper) != uvalue)\n-    return FALSE;\n+    return false;\n   if (esize <= 4 || (uint32_t) uvalue == (uint32_t) (uvalue >> 32))\n     {\n       svalue = (int32_t) uvalue;\n       if (esize <= 2 || (uint16_t) uvalue == (uint16_t) (uvalue >> 16))\n \t{\n \t  svalue = (int16_t) uvalue;\n \t  if (esize == 1 || (uint8_t) uvalue == (uint8_t) (uvalue >> 8))\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n   if ((svalue & 0xff) == 0)"
    },
    {
      "sha": "a4a2b6f209a8b2eec60d70795e858a8816dbd27e",
      "filename": "opcodes/aarch64-opc.h",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/aarch64-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/aarch64-opc.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -195,7 +195,7 @@ extern const aarch64_operand aarch64_operands[];\n \n enum err_type\n verify_constraints (const struct aarch64_inst *, const aarch64_insn, bfd_vma,\n-\t\t    bfd_boolean, aarch64_operand_error *, aarch64_instr_sequence*);\n+\t\t    bool, aarch64_operand_error *, aarch64_instr_sequence*);\n \n /* Operand flags.  */\n \n@@ -242,37 +242,37 @@ verify_constraints (const struct aarch64_inst *, const aarch64_insn, bfd_vma,\n #define HINT_FLAG(val) (val >> 8)\n #define HINT_VAL(val) (val & 0xff)\n \n-static inline bfd_boolean\n+static inline bool\n operand_has_inserter (const aarch64_operand *operand)\n {\n   return (operand->flags & OPD_F_HAS_INSERTER) != 0;\n }\n \n-static inline bfd_boolean\n+static inline bool\n operand_has_extractor (const aarch64_operand *operand)\n {\n   return (operand->flags & OPD_F_HAS_EXTRACTOR) != 0;\n }\n \n-static inline bfd_boolean\n+static inline bool\n operand_need_sign_extension (const aarch64_operand *operand)\n {\n   return (operand->flags & OPD_F_SEXT) != 0;\n }\n \n-static inline bfd_boolean\n+static inline bool\n operand_need_shift_by_two (const aarch64_operand *operand)\n {\n   return (operand->flags & OPD_F_SHIFT_BY_2) != 0;\n }\n \n-static inline bfd_boolean\n+static inline bool\n operand_need_shift_by_four (const aarch64_operand *operand)\n {\n   return (operand->flags & OPD_F_SHIFT_BY_4) != 0;\n }\n \n-static inline bfd_boolean\n+static inline bool\n operand_maybe_stack_pointer (const aarch64_operand *operand)\n {\n   return (operand->flags & OPD_F_MAYBE_SP) != 0;\n@@ -484,11 +484,11 @@ int aarch64_select_operand_for_sizeq_field_coding (const aarch64_opcode *);\n \n aarch64_insn aarch64_get_operand_modifier_value (enum aarch64_modifier_kind);\n enum aarch64_modifier_kind\n-aarch64_get_operand_modifier_from_value (aarch64_insn, bfd_boolean);\n+aarch64_get_operand_modifier_from_value (aarch64_insn, bool);\n \n \n-bfd_boolean aarch64_wide_constant_p (uint64_t, int, unsigned int *);\n-bfd_boolean aarch64_logical_immediate_p (uint64_t, int, aarch64_insn *);\n+bool aarch64_wide_constant_p (uint64_t, int, unsigned int *);\n+bool aarch64_logical_immediate_p (uint64_t, int, aarch64_insn *);\n int aarch64_shrink_expanded_imm8 (uint64_t);\n \n /* Copy the content of INST->OPERANDS[SRC] to INST->OPERANDS[DST].  */"
    },
    {
      "sha": "78e8e80eed92a31d5f9ca64b8be4e4f5e2a72674",
      "filename": "opcodes/arc-dis.c",
      "status": "modified",
      "additions": 55,
      "deletions": 55,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arc-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arc-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arc-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -61,7 +61,7 @@ struct arc_disassemble_info\n   unsigned insn_len;\n \n   /* TRUE if we have limm.  */\n-  bfd_boolean limm_p;\n+  bool limm_p;\n \n   /* LIMM value, if exists.  */\n   unsigned limm;\n@@ -123,7 +123,7 @@ static linkclass decodelist = NULL;\n static unsigned enforced_isa_mask = ARC_OPCODE_NONE;\n \n /* True if we want to print using only hex numbers.  */\n-static bfd_boolean print_hex = FALSE;\n+static bool print_hex = false;\n \n /* Macros section.  */\n \n@@ -143,17 +143,17 @@ static bfd_boolean print_hex = FALSE;\n /* Functions implementation.  */\n \n /* Initialize private data.  */\n-static bfd_boolean\n+static bool\n init_arc_disasm_info (struct disassemble_info *info)\n {\n   struct arc_disassemble_info *arc_infop\n     = calloc (sizeof (*arc_infop), 1);\n \n   if (arc_infop == NULL)\n-    return FALSE;\n+    return false;\n \n   info->private_data = arc_infop;\n-  return TRUE;\n+  return true;\n }\n \n /* Add a new element to the decode list.  */\n@@ -173,7 +173,7 @@ add_to_decodelist (insn_class_t     insn_class,\n /* Return TRUE if we need to skip the opcode from being\n    disassembled.  */\n \n-static bfd_boolean\n+static bool\n skip_this_opcode (const struct arc_opcode *opcode)\n {\n   linkclass t = decodelist;\n@@ -183,7 +183,7 @@ skip_this_opcode (const struct arc_opcode *opcode)\n       && (OPCODE_32BIT_INSN (opcode->opcode) != 0x06\n \t  /* Can be an APEX extensions.  */\n \t  && OPCODE_32BIT_INSN (opcode->opcode) != 0x07))\n-    return FALSE;\n+    return false;\n \n   /* or not a known truble class.  */\n   switch (opcode->insn_class)\n@@ -194,18 +194,18 @@ skip_this_opcode (const struct arc_opcode *opcode)\n     case MPY:\n       break;\n     default:\n-      return FALSE;\n+      return false;\n     }\n \n   while (t != NULL)\n     {\n       if ((t->insn_class == opcode->insn_class)\n \t  && (t->subclass == opcode->subclass))\n-\treturn FALSE;\n+\treturn false;\n       t = t->nxt;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n static bfd_vma\n@@ -218,7 +218,7 @@ bfd_getm32 (unsigned int data)\n   return value;\n }\n \n-static bfd_boolean\n+static bool\n special_flag_p (const char *opname,\n \t\tconst char *flgname)\n {\n@@ -240,10 +240,10 @@ special_flag_p (const char *opname,\n \t    break; /* End of the array.  */\n \n \t  if (strcmp (flgname, arc_flag_operands[flgidx].name) == 0)\n-\t    return TRUE;\n+\t    return true;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Find opcode from ARC_TABLE given the instruction described by INSN and\n@@ -255,19 +255,19 @@ find_format_from_table (struct disassemble_info *info,\n                         unsigned long long insn,\n \t\t\tunsigned int insn_len,\n                         unsigned isa_mask,\n-\t\t\tbfd_boolean *has_limm,\n-\t\t\tbfd_boolean overlaps)\n+\t\t\tbool *has_limm,\n+\t\t\tbool overlaps)\n {\n   unsigned int i = 0;\n   const struct arc_opcode *opcode = NULL;\n   const struct arc_opcode *t_op = NULL;\n   const unsigned char *opidx;\n   const unsigned char *flgidx;\n-  bfd_boolean warn_p = FALSE;\n+  bool warn_p = false;\n \n   do\n     {\n-      bfd_boolean invalid = FALSE;\n+      bool invalid = false;\n \n       opcode = &arc_table[i++];\n \n@@ -280,7 +280,7 @@ find_format_from_table (struct disassemble_info *info,\n       if ((insn & opcode->mask) != opcode->opcode)\n \tcontinue;\n \n-      *has_limm = FALSE;\n+      *has_limm = false;\n \n       /* Possible candidate, check the operands.  */\n       for (opidx = opcode->operands; *opidx; opidx++)\n@@ -305,14 +305,14 @@ find_format_from_table (struct disassemble_info *info,\n \t      if ((value == 0x3E && insn_len == 4)\n \t\t  || (value == limmind && insn_len == 2))\n \t\t{\n-\t\t  invalid = TRUE;\n+\t\t  invalid = true;\n \t\t  break;\n \t\t}\n \t    }\n \n \t  if (operand->flags & ARC_OPERAND_LIMM\n \t      && !(operand->flags & ARC_OPERAND_DUPLICATE))\n-\t    *has_limm = TRUE;\n+\t    *has_limm = true;\n \t}\n \n       /* Check the flags.  */\n@@ -351,7 +351,7 @@ find_format_from_table (struct disassemble_info *info,\n \n \t  if (!foundA && foundB)\n \t    {\n-\t      invalid = TRUE;\n+\t      invalid = true;\n \t      break;\n \t    }\n \t}\n@@ -362,7 +362,7 @@ find_format_from_table (struct disassemble_info *info,\n       if (insn_len == 4\n \t  && overlaps)\n \t{\n-\t  warn_p = TRUE;\n+\t  warn_p = true;\n \t  t_op = opcode;\n \t  if (skip_this_opcode (opcode))\n \t    continue;\n@@ -410,7 +410,7 @@ find_format_from_table (struct disassemble_info *info,\n    that calls to OPERAND_ITERATOR_NEXT will iterate over the opcode's\n    operands.  */\n \n-static bfd_boolean\n+static bool\n find_format (bfd_vma                       memaddr,\n \t     unsigned long long            insn,\n \t     unsigned int *                insn_len,\n@@ -420,7 +420,7 @@ find_format (bfd_vma                       memaddr,\n              struct arc_operand_iterator * iter)\n {\n   const struct arc_opcode *opcode = NULL;\n-  bfd_boolean needs_limm = FALSE;\n+  bool needs_limm = false;\n   const extInstruction_t *einsn, *i;\n   unsigned limm = 0;\n   struct arc_disassemble_info *arc_infop = info->private_data;\n@@ -440,18 +440,18 @@ find_format (bfd_vma                       memaddr,\n \t\t\t\t     _(\"An error occurred while generating the \"\n \t\t\t\t       \"extension instruction operations\"));\n \t      *opcode_result = NULL;\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  opcode = find_format_from_table (info, opcode, insn, *insn_len,\n-\t\t\t\t\t   isa_mask, &needs_limm, FALSE);\n+\t\t\t\t\t   isa_mask, &needs_limm, false);\n \t}\n     }\n \n   /* Then, try finding the first match in the opcode table.  */\n   if (opcode == NULL)\n     opcode = find_format_from_table (info, arc_opcodes, insn, *insn_len,\n-\t\t\t\t     isa_mask, &needs_limm, TRUE);\n+\t\t\t\t     isa_mask, &needs_limm, true);\n \n   if (opcode != NULL && needs_limm)\n     {\n@@ -486,7 +486,7 @@ find_format (bfd_vma                       memaddr,\n   arc_infop->limm = limm;\n   arc_infop->limm_p = needs_limm;\n \n-  return TRUE;\n+  return true;\n }\n \n static void\n@@ -694,7 +694,7 @@ extract_operand_value (const struct arc_operand *operand,\n   else\n     {\n       if (operand->extract)\n-\tvalue = (*operand->extract) (insn, (bfd_boolean *) NULL);\n+\tvalue = (*operand->extract) (insn, (bool *) NULL);\n       else\n         {\n           if (operand->flags & ARC_OPERAND_ALIGNED32)\n@@ -724,22 +724,22 @@ extract_operand_value (const struct arc_operand *operand,\n    into VALUE.  If there is no operand returned then OPERAND and VALUE are\n    unchanged.  */\n \n-static bfd_boolean\n+static bool\n operand_iterator_next (struct arc_operand_iterator *iter,\n                        const struct arc_operand **operand,\n                        int *value)\n {\n   if (*iter->opidx == 0)\n     {\n       *operand = NULL;\n-      return FALSE;\n+      return false;\n     }\n \n   *operand = &arc_operands[*iter->opidx];\n   *value = extract_operand_value (*operand, iter->insn, iter->limm);\n   iter->opidx++;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Helper for parsing the options.  */\n@@ -796,7 +796,7 @@ parse_option (const char *option)\n       add_to_decodelist (FLOAT, CVT);\n     }\n   else if (startswith (option, \"hex\"))\n-    print_hex = TRUE;\n+    print_hex = true;\n   else\n     /* xgettext:c-format */\n     opcodes_error_handler (_(\"unrecognised disassembler option: %s\"), option);\n@@ -941,14 +941,14 @@ print_insn_arc (bfd_vma memaddr,\n   unsigned long long insn = 0;\n   unsigned isa_mask = ARC_OPCODE_NONE;\n   const struct arc_opcode *opcode;\n-  bfd_boolean need_comma;\n-  bfd_boolean open_braket;\n+  bool need_comma;\n+  bool open_braket;\n   int size;\n   const struct arc_operand *operand;\n   int value, vpcl;\n   struct arc_operand_iterator iter;\n   struct arc_disassemble_info *arc_infop;\n-  bfd_boolean rpcl = FALSE, rset = FALSE;\n+  bool rpcl = false, rset = false;\n \n   if (info->disassembler_options)\n     {\n@@ -1146,7 +1146,7 @@ print_insn_arc (bfd_vma memaddr,\n   info->target2\t\t   = 0;\n \n   /* FIXME to be moved in dissasemble_init_for_target.  */\n-  info->disassembler_needs_relocs = TRUE;\n+  info->disassembler_needs_relocs = true;\n \n   /* Find the first match in the opcode table.  */\n   if (!find_format (memaddr, insn, &insn_len, isa_mask, info, &opcode, &iter))\n@@ -1201,8 +1201,8 @@ print_insn_arc (bfd_vma memaddr,\n   if (opcode->operands[0] != 0)\n     (*info->fprintf_func) (info->stream, \"\\t\");\n \n-  need_comma = FALSE;\n-  open_braket = FALSE;\n+  need_comma = false;\n+  open_braket = false;\n   arc_infop->operands_count = 0;\n \n   /* Now extract and print the operands.  */\n@@ -1213,7 +1213,7 @@ print_insn_arc (bfd_vma memaddr,\n       if (open_braket && (operand->flags & ARC_OPERAND_BRAKET))\n \t{\n \t  (*info->fprintf_func) (info->stream, \"]\");\n-\t  open_braket = FALSE;\n+\t  open_braket = false;\n \t  continue;\n \t}\n \n@@ -1238,25 +1238,25 @@ print_insn_arc (bfd_vma memaddr,\n       if (!open_braket && (operand->flags & ARC_OPERAND_BRAKET))\n \t{\n \t  (*info->fprintf_func) (info->stream, \"[\");\n-\t  open_braket = TRUE;\n-\t  need_comma = FALSE;\n+\t  open_braket = true;\n+\t  need_comma = false;\n \t  continue;\n \t}\n \n-      need_comma = TRUE;\n+      need_comma = true;\n \n       if (operand->flags & ARC_OPERAND_PCREL)\n \t{\n-\t  rpcl = TRUE;\n+\t  rpcl = true;\n \t  vpcl = value;\n-\t  rset = TRUE;\n+\t  rset = true;\n \n \t  info->target = (bfd_vma) (memaddr & ~3) + value;\n \t}\n       else if (!(operand->flags & ARC_OPERAND_IR))\n \t{\n \t  vpcl = value;\n-\t  rset = TRUE;\n+\t  rset = true;\n \t}\n \n       /* Print the operand as directed by the flags.  */\n@@ -1285,9 +1285,9 @@ print_insn_arc (bfd_vma memaddr,\n \t      (*info->fprintf_func) (info->stream, \"%s\", rname);\n \t    }\n \t  if (value == 63)\n-\t    rpcl = TRUE;\n+\t    rpcl = true;\n \t  else\n-\t    rpcl = FALSE;\n+\t    rpcl = false;\n \t}\n       else if (operand->flags & ARC_OPERAND_LIMM)\n \t{\n@@ -1321,7 +1321,7 @@ print_insn_arc (bfd_vma memaddr,\n \t  const char *addrtype = get_addrtype (value);\n \t  (*info->fprintf_func) (info->stream, \"%s\", addrtype);\n \t  /* A colon follow an address type.  */\n-\t  need_comma = FALSE;\n+\t  need_comma = false;\n \t}\n       else\n \t{\n@@ -1334,7 +1334,7 @@ print_insn_arc (bfd_vma memaddr,\n \t      switch (value)\n \t\t{\n \t\tcase 0:\n-\t\t  need_comma = FALSE;\n+\t\t  need_comma = false;\n \t\t  break;\n \t\tcase 1:\n \t\t  (*info->fprintf_func) (info->stream, \"r13\");\n@@ -1344,8 +1344,8 @@ print_insn_arc (bfd_vma memaddr,\n \t\t\t\t\t regnames[13 + value - 1]);\n \t\t  break;\n \t\t}\n-\t      rpcl = FALSE;\n-\t      rset = FALSE;\n+\t      rpcl = false;\n+\t      rset = false;\n \t    }\n \t  else\n \t    {\n@@ -1463,7 +1463,7 @@ void arc_insn_decode (bfd_vma addr,\n   /* There was an error when disassembling, for example memory read error.  */\n   if (disasm_func (addr, info) < 0)\n     {\n-      insn->valid = FALSE;\n+      insn->valid = false;\n       return;\n     }\n \n@@ -1476,11 +1476,11 @@ void arc_insn_decode (bfd_vma addr,\n   /* Quick exit if memory at this address is not an instruction.  */\n   if (info->insn_type == dis_noninsn)\n     {\n-      insn->valid = FALSE;\n+      insn->valid = false;\n       return;\n     }\n \n-  insn->valid = TRUE;\n+  insn->valid = true;\n \n   opcode = (const struct arc_opcode *) arc_infop->opcode;\n   insn->insn_class = opcode->insn_class;"
    },
    {
      "sha": "a2471e15c8ccda766d97e0dd7ec77000f74b1c48",
      "filename": "opcodes/arc-dis.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arc-dis.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arc-dis.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arc-dis.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -117,7 +117,7 @@ struct arc_instruction\n   bfd_vma address;\n \n   /* Whether this is a valid instruction.  */\n-  bfd_boolean valid;\n+  bool valid;\n \n   insn_class_t insn_class;\n "
    },
    {
      "sha": "0271b8b8b11fea60d5c453d8a4bed33a8f94b344",
      "filename": "opcodes/arc-fxi.h",
      "status": "modified",
      "additions": 42,
      "deletions": 39,
      "changes": 81,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arc-fxi.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arc-fxi.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arc-fxi.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -25,7 +25,8 @@\n    insn = 00100bbb00101111FBBB111110001001.  */\n static unsigned long long\n insert_limm (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t     long long int value ATTRIBUTE_UNUSED, const char **errmsg ATTRIBUTE_UNUSED)\n+\t     long long int value ATTRIBUTE_UNUSED,\n+\t     const char **errmsg ATTRIBUTE_UNUSED)\n {\n \n   return insn;\n@@ -36,7 +37,8 @@ insert_limm (unsigned long long insn ATTRIBUTE_UNUSED,\n #define EXTRACT_LIMM\n /* mask = 00000000000000000000000000000000.  */\n static ATTRIBUTE_UNUSED int\n-extract_limm (unsigned long long insn ATTRIBUTE_UNUSED, bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+extract_limm (unsigned long long insn ATTRIBUTE_UNUSED,\n+\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -65,7 +67,7 @@ insert_uimm6_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000000000000000111111000000.  */\n static long long int\n extract_uimm6_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t  bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t  bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -97,7 +99,7 @@ insert_simm12_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000000000000000111111222222.  */\n static long long int\n extract_simm12_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t   bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t   bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -133,7 +135,7 @@ insert_simm3_5_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000011100000000.  */\n static ATTRIBUTE_UNUSED int\n extract_simm3_5_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t   bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t   bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -165,7 +167,8 @@ insert_limm_s (unsigned long long insn ATTRIBUTE_UNUSED,\n #define EXTRACT_LIMM_S\n /* mask = 0000000000000000.  */\n static ATTRIBUTE_UNUSED int\n-extract_limm_s (unsigned long long insn ATTRIBUTE_UNUSED, bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+extract_limm_s (unsigned long long insn ATTRIBUTE_UNUSED,\n+\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -196,7 +199,7 @@ insert_uimm7_a32_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000000011111.  */\n static long long int\n extract_uimm7_a32_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -227,7 +230,7 @@ insert_uimm7_9_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000001111111.  */\n static long long int\n extract_uimm7_9_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t   bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t   bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -258,7 +261,7 @@ insert_uimm3_13_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000000000111.  */\n static long long int\n extract_uimm3_13_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -291,7 +294,7 @@ insert_simm11_a32_7_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000111111111.  */\n static long long int\n extract_simm11_a32_7_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -327,7 +330,7 @@ insert_uimm6_13_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000002220111.  */\n static long long int\n extract_uimm6_13_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -359,7 +362,7 @@ insert_uimm5_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000000011111.  */\n static long long int\n extract_uimm5_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -393,7 +396,7 @@ insert_simm9_a16_8 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000111111102000000000000000.  */\n static long long int\n extract_simm9_a16_8 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t     bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t     bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -429,7 +432,7 @@ insert_uimm6_8 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000000000000000111111000000.  */\n static long long int\n extract_uimm6_8 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -463,7 +466,7 @@ insert_simm21_a16_5 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000111111111102222222222000000.  */\n static long long int\n extract_simm21_a16_5 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t      bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -503,7 +506,7 @@ insert_simm25_a16_5 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000111111111102222222222003333.  */\n static long long int\n extract_simm25_a16_5 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t      bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -542,7 +545,7 @@ insert_simm10_a16_7_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000111111111.  */\n static long long int\n extract_simm10_a16_7_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -579,7 +582,7 @@ insert_simm7_a16_10_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000000111111.  */\n static long long int\n extract_simm7_a16_10_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -617,7 +620,7 @@ insert_simm21_a32_5 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000111111111002222222222000000.  */\n static long long int\n extract_simm21_a32_5 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t      bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -657,7 +660,7 @@ insert_simm25_a32_5 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000111111111002222222222003333.  */\n static long long int\n extract_simm25_a32_5 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t      bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -696,7 +699,7 @@ insert_simm13_a32_5_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000011111111111.  */\n static long long int\n extract_simm13_a32_5_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -733,7 +736,7 @@ insert_simm8_a16_9_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000001111111.  */\n static long long int\n extract_simm8_a16_9_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t       bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t       bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -768,7 +771,7 @@ insert_uimm3_23 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000000000000000000111000000.  */\n static long long int\n extract_uimm3_23 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t  bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t  bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -799,7 +802,7 @@ insert_uimm10_6_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000001111111111.  */\n static long long int\n extract_uimm10_6_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -831,7 +834,7 @@ insert_uimm6_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000002200011110.  */\n static long long int\n extract_uimm6_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -864,7 +867,7 @@ insert_simm9_8 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000111111112000000000000000.  */\n static long long int\n extract_simm9_8 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -902,7 +905,7 @@ insert_uimm10_a32_8_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000011111111.  */\n static long long int\n extract_uimm10_a32_8_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -933,7 +936,7 @@ insert_simm9_7_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000111111111.  */\n static long long int\n extract_simm9_7_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t   bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t   bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -970,7 +973,7 @@ insert_uimm6_a16_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000000011111.  */\n static long long int\n extract_uimm6_a16_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -1004,7 +1007,7 @@ insert_uimm5_a32_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000020000011000.  */\n static long long int\n extract_uimm5_a32_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -1039,7 +1042,7 @@ insert_simm11_a32_13_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000022222200111.  */\n static long long int\n extract_simm11_a32_13_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t\t bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t\t bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -1076,7 +1079,7 @@ insert_uimm7_13_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000022220111.  */\n static long long int\n extract_uimm7_13_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -1110,7 +1113,7 @@ insert_uimm6_a16_21 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000000000000000011111000000.  */\n static long long int\n extract_uimm6_a16_21 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t      bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -1142,7 +1145,7 @@ insert_uimm7_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000022200011110.  */\n static long long int\n extract_uimm7_11_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -1176,7 +1179,7 @@ insert_uimm7_a16_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000000000000000111111000000.  */\n static long long int\n extract_uimm7_a16_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t      bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -1210,7 +1213,7 @@ insert_simm13_a16_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000000000000000111111222222.  */\n static long long int\n extract_simm13_a16_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t       bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t       bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -1246,7 +1249,7 @@ insert_uimm8_8_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000000011111111.  */\n static long long int\n extract_uimm8_8_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t   bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t   bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -1277,7 +1280,7 @@ insert_uimm6_5_s (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 0000011111100000.  */\n static long long int\n extract_uimm6_5_s (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t   bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t   bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n \n@@ -1308,7 +1311,7 @@ insert_uimm6_axx_ (unsigned long long insn ATTRIBUTE_UNUSED,\n /* mask = 00000000000000000000000000000000.  */\n static ATTRIBUTE_UNUSED int\n extract_uimm6_axx_ (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned value = 0;\n "
    },
    {
      "sha": "b27324eee1dfa585ce895a542e714c5751c24601",
      "filename": "opcodes/arc-opc.c",
      "status": "modified",
      "additions": 93,
      "deletions": 93,
      "changes": 186,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arc-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arc-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arc-opc.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -67,13 +67,13 @@ insert_rb_chk (unsigned long long  insn,\n }\n \n static long long\n-extract_rb (unsigned long long  insn,\n-\t    bfd_boolean *       invalid)\n+extract_rb (unsigned long long insn,\n+\t    bool *invalid)\n {\n   int value = (((insn >> 12) & 0x07) << 3) | ((insn >> 24) & 0x07);\n \n   if (value == 0x3e && invalid)\n-    *invalid = TRUE; /* A limm operand, it should be extracted in a\n+    *invalid = true; /* A limm operand, it should be extracted in a\n \t\t\tdifferent way.  */\n \n   return value;\n@@ -167,8 +167,8 @@ insert_rhv1 (unsigned long long  insn,\n }\n \n static long long\n-extract_rhv1 (unsigned long long  insn,\n-\t      bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_rhv1 (unsigned long long insn,\n+\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = ((insn & 0x7) << 3) | ((insn >> 5) & 0x7);\n \n@@ -190,8 +190,8 @@ insert_rhv2 (unsigned long long  insn,\n }\n \n static long long\n-extract_rhv2 (unsigned long long  insn,\n-\t      bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_rhv2 (unsigned long long insn,\n+\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = ((insn >> 5) & 0x07) | ((insn & 0x03) << 3);\n \n@@ -210,7 +210,7 @@ insert_r0 (unsigned long long  insn,\n \n static long long\n extract_r0 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   return 0;\n }\n@@ -228,7 +228,7 @@ insert_r1 (unsigned long long  insn,\n \n static long long\n extract_r1 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t    bool* invalid ATTRIBUTE_UNUSED)\n {\n   return 1;\n }\n@@ -245,7 +245,7 @@ insert_r2 (unsigned long long  insn,\n \n static long long\n extract_r2 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   return 2;\n }\n@@ -262,7 +262,7 @@ insert_r3 (unsigned long long  insn,\n \n static long long\n extract_r3 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   return 3;\n }\n@@ -279,7 +279,7 @@ insert_sp (unsigned long long  insn,\n \n static long long\n extract_sp (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   return 28;\n }\n@@ -296,7 +296,7 @@ insert_gp (unsigned long long  insn,\n \n static long long\n extract_gp (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t    bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   return 26;\n }\n@@ -313,7 +313,7 @@ insert_pcl (unsigned long long  insn,\n \n static long long\n extract_pcl (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t     bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t     bool *invalid ATTRIBUTE_UNUSED)\n {\n   return 63;\n }\n@@ -330,7 +330,7 @@ insert_blink (unsigned long long  insn,\n \n static long long\n extract_blink (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t       bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t       bool *invalid ATTRIBUTE_UNUSED)\n {\n   return 31;\n }\n@@ -347,7 +347,7 @@ insert_ilink1 (unsigned long long  insn,\n \n static long long\n extract_ilink1 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   return 29;\n }\n@@ -364,7 +364,7 @@ insert_ilink2 (unsigned long long  insn,\n \n static long long\n extract_ilink2 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\tbfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   return 30;\n }\n@@ -396,8 +396,8 @@ insert_ras (unsigned long long  insn,\n }\n \n static long long\n-extract_ras (unsigned long long  insn,\n-\t     bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_ras (unsigned long long insn,\n+\t     bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = insn & 0x07;\n \n@@ -434,8 +434,8 @@ insert_rbs (unsigned long long  insn,\n }\n \n static long long\n-extract_rbs (unsigned long long  insn,\n-\t     bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_rbs (unsigned long long insn,\n+\t     bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = (insn >> 8) & 0x07;\n \n@@ -472,8 +472,8 @@ insert_rcs (unsigned long long  insn,\n }\n \n static long long\n-extract_rcs (unsigned long long  insn,\n-\t     bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_rcs (unsigned long long insn,\n+\t     bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = (insn >> 5) & 0x07;\n \n@@ -525,8 +525,8 @@ insert_simm3s (unsigned long long  insn,\n }\n \n static long long\n-extract_simm3s (unsigned long long  insn,\n-\t\tbfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_simm3s (unsigned long long insn,\n+\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = (insn >> 8) & 0x07;\n \n@@ -554,8 +554,8 @@ insert_rrange (unsigned long long  insn,\n }\n \n static long long\n-extract_rrange (unsigned long long  insn,\n-\t\tbfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_rrange (unsigned long long insn,\n+\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   return (insn >> 1) & 0x0F;\n }\n@@ -591,8 +591,8 @@ insert_fpel (unsigned long long  insn,\n }\n \n static long long\n-extract_fpel (unsigned long long  insn,\n-\t      bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_fpel (unsigned long long insn,\n+\t      bool *invalid ATTRIBUTE_UNUSED)\n {\n   return (insn & 0x0100) ? 27 : -1;\n }\n@@ -613,8 +613,8 @@ insert_blinkel (unsigned long long  insn,\n }\n \n static long long\n-extract_blinkel (unsigned long long  insn,\n-\t\t bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_blinkel (unsigned long long insn,\n+\t\t bool *invalid ATTRIBUTE_UNUSED)\n {\n   return (insn & 0x0200) ? 31 : -1;\n }\n@@ -635,8 +635,8 @@ insert_pclel (unsigned long long  insn,\n }\n \n static long long\n-extract_pclel (unsigned long long  insn,\n-\t       bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_pclel (unsigned long long insn,\n+\t       bool *invalid ATTRIBUTE_UNUSED)\n {\n   return (insn & 0x0400) ? 63 : -1;\n }\n@@ -661,8 +661,8 @@ insert_w6 (unsigned long long  insn,\n /* mask = 00000000000000000000111111000000.  */\n \n static long long\n-extract_w6 (unsigned long long  insn,\n-\t    bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_w6 (unsigned long long insn,\n+\t    bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n \n@@ -696,8 +696,8 @@ insert_g_s (unsigned long long  insn,\n /* mask = 0000011100022000.  */\n \n static long long\n-extract_g_s (unsigned long long  insn,\n-\t     bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_g_s (unsigned long long insn,\n+\t     bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n   int signbit = 1 << (6 - 1);\n@@ -741,9 +741,9 @@ insert_nps_3bit_reg_at_##OFFSET##_##NAME\t\t         \\\n }                                                                \\\n                                                                  \\\n static long long\t\t\t\t\t\t \\\n-extract_nps_3bit_reg_at_##OFFSET##_##NAME                        \\\n-                    (unsigned long long  insn,                   \\\n-                     bfd_boolean *       invalid ATTRIBUTE_UNUSED)     \\\n+extract_nps_3bit_reg_at_##OFFSET##_##NAME\t\t\t \\\n+  (unsigned long long insn,\t\t\t\t\t \\\n+   bool *invalid ATTRIBUTE_UNUSED)\t\t\t\t \\\n {                                                                \\\n   int value = (insn >> (OFFSET)) & 0x07;\t\t\t \\\n   if (value > 3)                                                 \\\n@@ -791,8 +791,8 @@ insert_nps_bitop_size_2b (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_bitop_size_2b (unsigned long long  insn,\n-                           bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_bitop_size_2b (unsigned long long insn,\n+                           bool *invalid ATTRIBUTE_UNUSED)\n {\n   return  1 << ((insn >> 10) & 0x3);\n }\n@@ -808,8 +808,8 @@ insert_nps_bitop_uimm8 (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_bitop_uimm8 (unsigned long long  insn,\n-                         bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_bitop_uimm8 (unsigned long long insn,\n+                         bool *invalid ATTRIBUTE_UNUSED)\n {\n   return (((insn >> 12) & 0x7) << 5) | (insn & 0x1f);\n }\n@@ -836,8 +836,8 @@ insert_nps_rflt_uimm6 (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_rflt_uimm6 (unsigned long long  insn,\n-\t\t\tbfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_rflt_uimm6 (unsigned long long insn,\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   return (insn >> 6) & 0x3f;\n }\n@@ -852,8 +852,8 @@ insert_nps_dst_pos_and_size (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_dst_pos_and_size (unsigned long long  insn,\n-                              bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_dst_pos_and_size (unsigned long long insn,\n+                              bool *invalid ATTRIBUTE_UNUSED)\n {\n   return (insn & 0x1f);\n }\n@@ -872,8 +872,8 @@ insert_nps_cmem_uimm16 (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_cmem_uimm16 (unsigned long long  insn,\n-                         bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_cmem_uimm16 (unsigned long long insn,\n+                         bool *invalid ATTRIBUTE_UNUSED)\n {\n   return (NPS_CMEM_HIGH_VALUE << 16) | (insn & 0xffff);\n }\n@@ -901,8 +901,8 @@ insert_nps_imm_offset (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_imm_offset (unsigned long long  insn,\n-\t\t\tbfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_imm_offset (unsigned long long insn,\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   return ((insn >> 10) & 0x7) * 16;\n }\n@@ -935,8 +935,8 @@ insert_nps_imm_entry (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_imm_entry (unsigned long long  insn,\n-\t\t       bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_imm_entry (unsigned long long insn,\n+\t\t       bool *invalid ATTRIBUTE_UNUSED)\n {\n   int imm_entry = ((insn >> 2) & 0x7);\n   return (1 << (imm_entry + 4));\n@@ -958,8 +958,8 @@ insert_nps_size_16bit (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_size_16bit (unsigned long long  insn,\n-\t\t\tbfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_size_16bit (unsigned long long insn,\n+\t\t\tbool *invalid ATTRIBUTE_UNUSED)\n {\n   return ((insn & 0xfc0) >> 6) ? ((insn & 0xfc0) >> 6) : 64;\n }\n@@ -988,8 +988,8 @@ insert_nps_##NAME##_pos (unsigned long long  insn,\t      \\\n }                                                             \\\n                                                               \\\n static long long                                              \\\n-extract_nps_##NAME##_pos (unsigned long long  insn,\t      \\\n-                          bfd_boolean *       invalid ATTRIBUTE_UNUSED)     \\\n+extract_nps_##NAME##_pos (unsigned long long insn,\t      \\\n+                          bool *invalid ATTRIBUTE_UNUSED)     \\\n {                                                             \\\n   return ((insn >> SHIFT) & 0x3) * 8;                         \\\n }\n@@ -1015,8 +1015,8 @@ insert_nps_##NAME (unsigned long long  insn,\t\t\t\t\\\n   }                                                                     \\\n                                                                         \\\n static long long                                                        \\\n-extract_nps_##NAME (unsigned long long  insn,                           \\\n-                    bfd_boolean *       invalid ATTRIBUTE_UNUSED)       \\\n+extract_nps_##NAME (unsigned long long insn,\t\t\t\t\\\n+                    bool *invalid ATTRIBUTE_UNUSED)\t\t\t\\\n {                                                                       \\\n   return ((insn >> SHIFT) & ((1 << BITS) - 1)) + BIAS;                  \\\n }\n@@ -1034,39 +1034,39 @@ MAKE_BIAS_INSERT_EXTRACT_FUNCS (hash_len,1,8,3,1,2)\n MAKE_BIAS_INSERT_EXTRACT_FUNCS (index3,4,7,2,4,0)\n \n static long long\n-extract_nps_qcmp_m3 (unsigned long long  insn,\n-                     bfd_boolean *       invalid)\n+extract_nps_qcmp_m3 (unsigned long long insn,\n+                     bool *invalid)\n {\n   int m3 = (insn >> 5) & 0xf;\n   if (m3 == 0xf)\n-    *invalid = TRUE;\n+    *invalid = true;\n   return m3;\n }\n \n static long long\n-extract_nps_qcmp_m2 (unsigned long long  insn,\n-                     bfd_boolean *       invalid)\n+extract_nps_qcmp_m2 (unsigned long long insn,\n+                     bool *invalid)\n {\n-  bfd_boolean tmp_invalid = FALSE;\n+  bool tmp_invalid = false;\n   int m2 = (insn >> 15) & 0x1;\n   int m3 = extract_nps_qcmp_m3 (insn, &tmp_invalid);\n \n   if (m2 == 0 && m3 == 0xf)\n-    *invalid = TRUE;\n+    *invalid = true;\n   return m2;\n }\n \n static long long\n-extract_nps_qcmp_m1 (unsigned long long  insn,\n-                     bfd_boolean *       invalid)\n+extract_nps_qcmp_m1 (unsigned long long insn,\n+                     bool *invalid)\n {\n-  bfd_boolean tmp_invalid = FALSE;\n+  bool tmp_invalid = false;\n   int m1 = (insn >> 14) & 0x1;\n   int m2 = extract_nps_qcmp_m2 (insn, &tmp_invalid);\n   int m3 = extract_nps_qcmp_m3 (insn, &tmp_invalid);\n \n   if (m1 == 0 && m2 == 0 && m3 == 0xf)\n-    *invalid = TRUE;\n+    *invalid = true;\n   return m1;\n }\n \n@@ -1096,8 +1096,8 @@ insert_nps_calc_entry_size (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_calc_entry_size (unsigned long long  insn,\n-                             bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_calc_entry_size (unsigned long long insn,\n+                             bool *invalid ATTRIBUTE_UNUSED)\n {\n   unsigned entry_size = (insn >> 8) & 0xf;\n   return 1 << entry_size;\n@@ -1112,8 +1112,8 @@ insert_nps_bitop_mod4 (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_bitop_mod4 (unsigned long long  insn,\n-                            bfd_boolean *   invalid ATTRIBUTE_UNUSED)\n+extract_nps_bitop_mod4 (unsigned long long insn,\n+                            bool *invalid ATTRIBUTE_UNUSED)\n {\n   return ((insn >> 30) & 0x2) | ((insn >> 47) & 0x1);\n }\n@@ -1127,11 +1127,11 @@ insert_nps_bitop_dst_pos3_pos4 (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_bitop_dst_pos3_pos4 (unsigned long long  insn,\n-                                 bfd_boolean *       invalid)\n+extract_nps_bitop_dst_pos3_pos4 (unsigned long long insn,\n+                                 bool *invalid)\n {\n   if (((insn >> 42) & 0x1f) != ((insn >> 37) & 0x1f))\n-    *invalid = TRUE;\n+    *invalid = true;\n   return ((insn >> 37) & 0x1f);\n }\n \n@@ -1146,13 +1146,13 @@ insert_nps_bitop_ins_ext (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_bitop_ins_ext (unsigned long long  insn,\n-                           bfd_boolean *       invalid)\n+extract_nps_bitop_ins_ext (unsigned long long insn,\n+                           bool *invalid)\n {\n   int value = (insn >> 20) & 0x1f;\n \n   if (value > 28)\n-    *invalid = TRUE;\n+    *invalid = true;\n   return value;\n }\n \n@@ -1170,8 +1170,8 @@ insert_nps_##NAME (unsigned long long  insn,\t\t\t\t\\\n }                                                                       \\\n                                                                         \\\n static long long\t\t\t\t\t\t\t\\\n-extract_nps_##NAME (unsigned long long  insn,\t\t\t\t\\\n-                    bfd_boolean *       invalid ATTRIBUTE_UNUSED)       \\\n+extract_nps_##NAME (unsigned long long insn,\t\t\t\t\\\n+                    bool *invalid ATTRIBUTE_UNUSED)\t\t\t\\\n {                                                                       \\\n   int value = (insn >> SHIFT) & ((1 << BITS) - 1);                      \\\n   if (value == 0)                                                       \\\n@@ -1201,8 +1201,8 @@ insert_nps_min_hofs (unsigned long long  insn,\n }\n \n static long long\n-extract_nps_min_hofs (unsigned long long  insn,\n-                      bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_min_hofs (unsigned long long insn,\n+                      bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = (insn >> 6) & 0xF;\n   return value * 16;\n@@ -1220,8 +1220,8 @@ insert_nps_##NAME (unsigned long long  insn,\t\t\t       \\\n }                                                                      \\\n                                                                        \\\n static long long\t\t\t\t\t\t       \\\n-extract_nps_##NAME (unsigned long long  insn ATTRIBUTE_UNUSED,         \\\n-                    bfd_boolean *       invalid ATTRIBUTE_UNUSED)      \\\n+extract_nps_##NAME (unsigned long long insn ATTRIBUTE_UNUSED,\t       \\\n+\t\t    bool *invalid ATTRIBUTE_UNUSED)\t\t       \\\n {                                                                      \\\n   return ARC_NPS400_ADDRTYPE_##VALUE;                                  \\\n }\n@@ -1255,14 +1255,14 @@ insert_nps_rbdouble_64 (unsigned long long  insn,\n \n \n static long long\n-extract_nps_rbdouble_64 (unsigned long long  insn,\n-                         bfd_boolean *       invalid)\n+extract_nps_rbdouble_64 (unsigned long long insn,\n+                         bool *invalid)\n {\n   int value1 = (insn >> 43) & 0x1F;\n   int value2 = (insn >> 48) & 0x1F;\n \n   if (value1 != value2)\n-    *invalid = TRUE;\n+    *invalid = true;\n \n   return value1;\n }\n@@ -1282,15 +1282,15 @@ insert_nps_misc_imm_offset (unsigned long long  insn,\n }\n \n static long long int\n-extract_nps_misc_imm_offset (unsigned long long  insn,\n-\t\t\t     bfd_boolean *       invalid ATTRIBUTE_UNUSED)\n+extract_nps_misc_imm_offset (unsigned long long insn,\n+\t\t\t     bool *invalid ATTRIBUTE_UNUSED)\n {\n   return ((insn >> 8) & 0x1f) * 4;\n }\n \n static long long int\n extract_uimm12_20 (unsigned long long insn ATTRIBUTE_UNUSED,\n-\t\t   bfd_boolean * invalid ATTRIBUTE_UNUSED)\n+\t\t   bool *invalid ATTRIBUTE_UNUSED)\n {\n   int value = 0;\n "
    },
    {
      "sha": "797998722cf7524fd9b8433695d4952b0e6b3ebb",
      "filename": "opcodes/arm-dis.c",
      "status": "modified",
      "additions": 330,
      "deletions": 330,
      "changes": 660,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arm-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/arm-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arm-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -5252,7 +5252,7 @@ enum vpt_pred_state\n struct vpt_block\n {\n   /* Are we in a vpt block.  */\n-  bfd_boolean in_vpt_block;\n+  bool in_vpt_block;\n \n   /* Next predicate state if in vpt block.  */\n   enum vpt_pred_state next_pred_state;\n@@ -5269,7 +5269,7 @@ struct vpt_block\n \n static struct vpt_block vpt_block_state =\n {\n-  FALSE,\n+  false,\n   PRED_NONE,\n   0,\n   0,\n@@ -5282,7 +5282,7 @@ static unsigned int regname_selected = 1;\n #define NUM_ARM_OPTIONS   ARRAY_SIZE (regnames)\n #define arm_regnames      regnames[regname_selected].reg_names\n \n-static bfd_boolean force_thumb = FALSE;\n+static bool force_thumb = false;\n static uint16_t cde_coprocs = 0;\n \n /* Current IT instruction state.  This contains the same state as the IT\n@@ -5334,7 +5334,7 @@ num_instructions_vpt_block (long given)\n static void\n mark_outside_vpt_block (void)\n {\n-  vpt_block_state.in_vpt_block = FALSE;\n+  vpt_block_state.in_vpt_block = false;\n   vpt_block_state.next_pred_state = PRED_NONE;\n   vpt_block_state.predicate_mask = 0;\n   vpt_block_state.current_insn_num = 0;\n@@ -5344,7 +5344,7 @@ mark_outside_vpt_block (void)\n static void\n mark_inside_vpt_block (long given)\n {\n-  vpt_block_state.in_vpt_block = TRUE;\n+  vpt_block_state.in_vpt_block = true;\n   vpt_block_state.next_pred_state = PRED_THEN;\n   vpt_block_state.predicate_mask = mve_extract_pred_mask (given);\n   vpt_block_state.current_insn_num = 0;\n@@ -5448,7 +5448,7 @@ arm_decode_bitfield (const char *ptr,\n \n static void\n arm_decode_shift (long given, fprintf_ftype func, void *stream,\n-\t\t  bfd_boolean print_shift)\n+\t\t  bool print_shift)\n {\n   func (stream, \"%s\", arm_regnames[given & 0xf]);\n \n@@ -5487,7 +5487,7 @@ arm_decode_shift (long given, fprintf_ftype func, void *stream,\n \n /* Return TRUE if the MATCHED_INSN can be inside an IT block.  */\n \n-static bfd_boolean\n+static bool\n is_mve_okay_in_it (enum mve_instructions matched_insn)\n {\n   switch (matched_insn)\n@@ -5513,13 +5513,13 @@ is_mve_okay_in_it (enum mve_instructions matched_insn)\n     case MVE_SRSHR:\n     case MVE_SQSHLL:\n     case MVE_SQSHL:\n-      return TRUE;\n+      return true;\n     default:\n-      return FALSE;\n+      return false;\n     }\n }\n \n-static bfd_boolean\n+static bool\n is_mve_architecture (struct disassemble_info *info)\n {\n   struct arm_private_data *private_data = info->private_data;\n@@ -5530,18 +5530,18 @@ is_mve_architecture (struct disassemble_info *info)\n \n   if (ARM_CPU_HAS_FEATURE (arm_ext_v8_1m_main, allowed_arches)\n       && !ARM_CPU_IS_ANY (allowed_arches))\n-    return TRUE;\n+    return true;\n   else\n-    return FALSE;\n+    return false;\n }\n \n-static bfd_boolean\n+static bool\n is_vpt_instruction (long given)\n {\n \n   /* If mkh:mkl is '0000' then its not a vpt/vpst instruction.  */\n   if ((given & 0x0040e000) == 0)\n-    return FALSE;\n+    return false;\n \n   /* VPT floating point T1 variant.  */\n   if (((given & 0xefb10f50) == 0xee310f00 && ((given & 0x1001) != 0x1))\n@@ -5562,9 +5562,9 @@ is_vpt_instruction (long given)\n       || ((given & 0xff811f50) == 0xfe011f40)\n   /* VPST vector T variant.  */\n       || ((given & 0xffbf1fff) == 0xfe310f4d))\n-    return TRUE;\n+    return true;\n   else\n-    return FALSE;\n+    return false;\n }\n \n /* Decode a bitfield from opcode GIVEN, with starting bitfield = START\n@@ -5609,32 +5609,32 @@ arm_decode_field_multiple (unsigned long given, unsigned int start,\n    This helps us decode instructions that change mnemonic depending on specific\n    operand values/encodings.  */\n \n-static bfd_boolean\n+static bool\n is_mve_encoding_conflict (unsigned long given,\n \t\t\t  enum mve_instructions matched_insn)\n {\n   switch (matched_insn)\n     {\n     case MVE_VPST:\n       if (arm_decode_field_multiple (given, 13, 15, 22, 22) == 0)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VPT_FP_T1:\n       if (arm_decode_field_multiple (given, 13, 15, 22, 22) == 0)\n-\treturn TRUE;\n+\treturn true;\n       if ((arm_decode_field (given, 12, 12) == 0)\n \t  && (arm_decode_field (given, 0, 0) == 1))\n-\treturn TRUE;\n-      return FALSE;\n+\treturn true;\n+      return false;\n \n     case MVE_VPT_FP_T2:\n       if (arm_decode_field_multiple (given, 13, 15, 22, 22) == 0)\n-\treturn TRUE;\n+\treturn true;\n       if (arm_decode_field (given, 0, 3) == 0xd)\n-\treturn TRUE;\n-      return FALSE;\n+\treturn true;\n+      return false;\n \n     case MVE_VPT_VEC_T1:\n     case MVE_VPT_VEC_T2:\n@@ -5643,23 +5643,23 @@ is_mve_encoding_conflict (unsigned long given,\n     case MVE_VPT_VEC_T5:\n     case MVE_VPT_VEC_T6:\n       if (arm_decode_field_multiple (given, 13, 15, 22, 22) == 0)\n-\treturn TRUE;\n+\treturn true;\n       if (arm_decode_field (given, 20, 21) == 3)\n-\treturn TRUE;\n-      return FALSE;\n+\treturn true;\n+      return false;\n \n     case MVE_VCMP_FP_T1:\n       if ((arm_decode_field (given, 12, 12) == 0)\n \t  && (arm_decode_field (given, 0, 0) == 1))\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VCMP_FP_T2:\n       if (arm_decode_field (given, 0, 3) == 0xd)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VQADD_T2:\n     case MVE_VQSUB_T2:\n@@ -5702,41 +5702,41 @@ is_mve_encoding_conflict (unsigned long given,\n     case MVE_VCMP_VEC_T5:\n     case MVE_VCMP_VEC_T6:\n       if (arm_decode_field (given, 20, 21) == 3)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VLD2:\n     case MVE_VLD4:\n     case MVE_VST2:\n     case MVE_VST4:\n       if (arm_decode_field (given, 7, 8) == 3)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSTRB_T1:\n     case MVE_VSTRH_T2:\n       if ((arm_decode_field (given, 24, 24) == 0)\n \t  && (arm_decode_field (given, 21, 21) == 0))\n \t{\n-\t    return TRUE;\n+\t    return true;\n \t}\n       else if ((arm_decode_field (given, 7, 8) == 3))\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSTRB_T5:\n     case MVE_VSTRH_T6:\n     case MVE_VSTRW_T7:\n       if ((arm_decode_field (given, 24, 24) == 0)\n \t  && (arm_decode_field (given, 21, 21) == 0))\n \t{\n-\t    return TRUE;\n+\t    return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VCVT_FP_FIX_VEC:\n       return (arm_decode_field (given, 16, 21) & 0x38) == 0;\n@@ -5747,41 +5747,41 @@ is_mve_encoding_conflict (unsigned long given,\n \tunsigned long cmode = arm_decode_field (given, 8, 11);\n \n \tif ((cmode & 1) == 0)\n-\t  return TRUE;\n+\t  return true;\n \telse if ((cmode & 0xc) == 0xc)\n-\t  return TRUE;\n+\t  return true;\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VMVN_IMM:\n       {\n \tunsigned long cmode = arm_decode_field (given, 8, 11);\n \n \tif (cmode == 0xe)\n-\t  return TRUE;\n+\t  return true;\n \telse if ((cmode & 0x9) == 1)\n-\t  return TRUE;\n+\t  return true;\n \telse if ((cmode & 0xd) == 9)\n-\t  return TRUE;\n+\t  return true;\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VMOV_IMM_TO_VEC:\n       if ((arm_decode_field (given, 5, 5) == 1)\n \t  && (arm_decode_field (given, 8, 11) != 0xe))\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VMOVL:\n       {\n \tunsigned long size = arm_decode_field (given, 19, 20);\n \tif ((size == 0) || (size == 3))\n-\t  return TRUE;\n+\t  return true;\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VMAXA:\n@@ -5800,32 +5800,32 @@ is_mve_encoding_conflict (unsigned long given,\n     case MVE_VQMOVUN:\n     case MVE_VQMOVN:\n       if (arm_decode_field (given, 18, 19) == 3)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VMLSLDAV:\n     case MVE_VRMLSLDAVH:\n     case MVE_VMLALDAV:\n     case MVE_VADDLV:\n       if (arm_decode_field (given, 20, 22) == 7)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VRMLALDAVH:\n       if ((arm_decode_field (given, 20, 22) & 6) == 6)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VDWDUP:\n     case MVE_VIWDUP:\n       if ((arm_decode_field (given, 20, 21) == 3)\n \t  || (arm_decode_field (given, 1, 3) == 7))\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n \n     case MVE_VSHLL_T1:\n@@ -5834,12 +5834,12 @@ is_mve_encoding_conflict (unsigned long given,\n \t  unsigned long sz = arm_decode_field (given, 19, 20);\n \n \t  if ((sz == 1) || (sz == 2))\n-\t    return TRUE;\n+\t    return true;\n \t  else\n-\t    return FALSE;\n+\t    return false;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VQSHL_T2:\n     case MVE_VQSHLU_T3:\n@@ -5849,15 +5849,15 @@ is_mve_encoding_conflict (unsigned long given,\n     case MVE_VSLI:\n     case MVE_VSRI:\n       if (arm_decode_field (given, 19, 21) == 0)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VCTP:\n     if (arm_decode_field (given, 16, 19) == 0xf)\n-      return TRUE;\n+      return true;\n     else\n-      return FALSE;\n+      return false;\n \n     case MVE_ASRLI:\n     case MVE_ASRL:\n@@ -5871,9 +5871,9 @@ is_mve_encoding_conflict (unsigned long given,\n     case MVE_UQSHLL:\n     case MVE_URSHRL:\n       if (arm_decode_field (given, 9, 11) == 0x7)\n-\treturn TRUE;\n+\treturn true;\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_CSINC:\n     case MVE_CSINV:\n@@ -5883,27 +5883,27 @@ is_mve_encoding_conflict (unsigned long given,\n \trn = arm_decode_field (given, 16, 19);\n \t/* CSET/CSETM.  */\n \tif (rm == 0xf && rn == 0xf)\n-\t  return TRUE;\n+\t  return true;\n \t/* CINC/CINV.  */\n \telse if (rn == rm && rn != 0xf)\n-\t  return TRUE;\n+\t  return true;\n       }\n     /* Fall through.  */\n     case MVE_CSEL:\n     case MVE_CSNEG:\n       if (arm_decode_field (given, 0, 3) == 0xd)\n-\treturn TRUE;\n+\treturn true;\n       /* CNEG.  */\n       else if (matched_insn == MVE_CSNEG)\n \tif (arm_decode_field (given, 0, 3) == arm_decode_field (given, 16, 19))\n-\t  return TRUE;\n-      return FALSE;\n+\t  return true;\n+      return false;\n \n     default:\n     case MVE_VADD_FP_T1:\n     case MVE_VADD_FP_T2:\n     case MVE_VADD_VEC_T1:\n-      return FALSE;\n+      return false;\n \n     }\n }\n@@ -5986,7 +5986,7 @@ print_mve_vld_str_addr (struct disassemble_info *info,\n    Otherwise, return TRUE and set UNDEFINED_CODE to give a reason as to why\n    this encoding is undefined.  */\n \n-static bfd_boolean\n+static bool\n is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n \t\t  enum mve_undefined *undefined_code)\n {\n@@ -5998,10 +5998,10 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n       if (arm_decode_field_multiple (given, 5, 5, 22, 22) == 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VQADD_T1:\n     case MVE_VQSUB_T1:\n@@ -6017,171 +6017,171 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n       if (arm_decode_field (given, 20, 21) == 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VLDRB_T1:\n       if (arm_decode_field (given, 7, 8) == 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VLDRH_T2:\n       if (arm_decode_field (given, 7, 8) <= 1)\n \t{\n \t  *undefined_code = UNDEF_SIZE_LE_1;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSTRB_T1:\n       if ((arm_decode_field (given, 7, 8) == 0))\n \t{\n \t  *undefined_code = UNDEF_SIZE_0;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSTRH_T2:\n       if ((arm_decode_field (given, 7, 8) <= 1))\n \t{\n \t  *undefined_code = UNDEF_SIZE_LE_1;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VLDRB_GATHER_T1:\n       if (arm_decode_field (given, 7, 8) == 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else if ((arm_decode_field (given, 28, 28) == 0)\n \t       && (arm_decode_field (given, 7, 8) == 0))\n \t{\n \t  *undefined_code = UNDEF_NOT_UNS_SIZE_0;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VLDRH_GATHER_T2:\n       if (arm_decode_field (given, 7, 8) == 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else if ((arm_decode_field (given, 28, 28) == 0)\n \t       && (arm_decode_field (given, 7, 8) == 1))\n \t{\n \t  *undefined_code = UNDEF_NOT_UNS_SIZE_1;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else if (arm_decode_field (given, 7, 8) == 0)\n \t{\n \t  *undefined_code = UNDEF_SIZE_0;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VLDRW_GATHER_T3:\n       if (arm_decode_field (given, 7, 8) != 2)\n \t{\n \t  *undefined_code = UNDEF_SIZE_NOT_2;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else if (arm_decode_field (given, 28, 28) == 0)\n \t{\n \t  *undefined_code = UNDEF_NOT_UNSIGNED;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VLDRD_GATHER_T4:\n       if (arm_decode_field (given, 7, 8) != 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_NOT_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else if (arm_decode_field (given, 28, 28) == 0)\n \t{\n \t  *undefined_code = UNDEF_NOT_UNSIGNED;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSTRB_SCATTER_T1:\n       if (arm_decode_field (given, 7, 8) == 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSTRH_SCATTER_T2:\n       {\n \tunsigned long size = arm_decode_field (given, 7, 8);\n \tif (size == 3)\n \t  {\n \t    *undefined_code = UNDEF_SIZE_3;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (size == 0)\n \t  {\n \t    *undefined_code = UNDEF_SIZE_0;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VSTRW_SCATTER_T3:\n       if (arm_decode_field (given, 7, 8) != 2)\n \t{\n \t  *undefined_code = UNDEF_SIZE_NOT_2;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSTRD_SCATTER_T4:\n       if (arm_decode_field (given, 7, 8) != 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_NOT_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VCVT_FP_FIX_VEC:\n       {\n \tunsigned long imm6 = arm_decode_field (given, 16, 21);\n \tif ((imm6 & 0x20) == 0)\n \t  {\n \t    *undefined_code = UNDEF_VCVT_IMM6;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n \tif ((arm_decode_field (given, 9, 9) == 0)\n \t    && ((imm6 & 0x30) == 0x20))\n \t  {\n \t    *undefined_code = UNDEF_VCVT_FSI_IMM6;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case MVE_VNEG_FP:\n@@ -6193,15 +6193,15 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n \tif (size == 0)\n \t  {\n \t    *undefined_code = UNDEF_SIZE_0;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (size == 3)\n \t  {\n \t    *undefined_code = UNDEF_SIZE_3;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VMOV_VEC_LANE_TO_GP:\n@@ -6215,23 +6215,23 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n \t    if ((op1 == 0) || (op1 == 1))\n \t      {\n \t\t*undefined_code = UNDEF_BAD_U_OP1_OP2;\n-\t\treturn TRUE;\n+\t\treturn true;\n \t      }\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \t  }\n \telse if (op2 == 2)\n \t  {\n \t    if ((op1 == 0) || (op1 == 1))\n \t      {\n \t\t*undefined_code = UNDEF_BAD_OP1_OP2;\n-\t\treturn TRUE;\n+\t\treturn true;\n \t      }\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case MVE_VMOV_GP_TO_VEC_LANE:\n@@ -6241,19 +6241,19 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n \t  if ((op1 == 0) || (op1 == 1))\n \t    {\n \t      *undefined_code = UNDEF_BAD_OP1_OP2;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t  else\n-\t    return FALSE;\n+\t    return false;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VMOV_VEC_TO_VEC:\n       if ((arm_decode_field (given, 5, 5) == 1)\n \t  || (arm_decode_field (given, 22, 22) == 1))\n-\t  return TRUE;\n-      return FALSE;\n+\t  return true;\n+      return false;\n \n     case MVE_VMOV_IMM_TO_VEC:\n       if (arm_decode_field (given, 5, 5) == 0)\n@@ -6263,23 +6263,23 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n \tif (((cmode & 9) == 1) || ((cmode & 5) == 1))\n \t  {\n \t    *undefined_code = UNDEF_OP_0_BAD_CMODE;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSHLL_T2:\n     case MVE_VMOVN:\n       if (arm_decode_field (given, 18, 19) == 2)\n \t{\n \t  *undefined_code = UNDEF_SIZE_2;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VRMLALDAVH:\n     case MVE_VMLADAV_T1:\n@@ -6289,10 +6289,10 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n \t  && (arm_decode_field (given, 12, 12) == 1))\n \t{\n \t  *undefined_code = UNDEF_XCHG_UNS;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VQSHRN:\n     case MVE_VQSHRUN:\n@@ -6301,13 +6301,13 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n       {\n \tunsigned long sz = arm_decode_field (given, 19, 20);\n \tif (sz == 1)\n-\t  return FALSE;\n+\t  return false;\n \telse if ((sz & 2) == 2)\n-\t  return FALSE;\n+\t  return false;\n \telse\n \t  {\n \t    *undefined_code = UNDEF_SIZE;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n       }\n       break;\n@@ -6322,15 +6322,15 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n       {\n \tunsigned long sz = arm_decode_field (given, 19, 21);\n \tif ((sz & 7) == 1)\n-\t  return FALSE;\n+\t  return false;\n \telse if ((sz & 6) == 2)\n-\t  return FALSE;\n+\t  return false;\n \telse if ((sz & 4) == 4)\n-\t  return FALSE;\n+\t  return false;\n \telse\n \t  {\n \t    *undefined_code = UNDEF_SIZE;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n       }\n \n@@ -6339,19 +6339,19 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n       if (arm_decode_field (given, 19, 20) == 0)\n \t{\n \t  *undefined_code = UNDEF_SIZE_0;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VABS_VEC:\n \tif (arm_decode_field (given, 18, 19) == 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n \telse\n-\t  return FALSE;\n+\t  return false;\n \n     case MVE_VQNEG:\n     case MVE_VQABS:\n@@ -6361,18 +6361,18 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n       if (arm_decode_field (given, 18, 19) == 3)\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VREV16:\n       if (arm_decode_field (given, 18, 19) == 0)\n-\treturn FALSE;\n+\treturn false;\n       else\n \t{\n \t  *undefined_code = UNDEF_SIZE_NOT_0;\n-\t  return TRUE;\n+\t  return true;\n \t}\n \n     case MVE_VREV32:\n@@ -6381,31 +6381,31 @@ is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n \tif ((size & 2) == 2)\n \t  {\n \t    *undefined_code = UNDEF_SIZE_2;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VREV64:\n       if (arm_decode_field (given, 18, 19) != 3)\n-\treturn FALSE;\n+\treturn false;\n       else\n \t{\n \t  *undefined_code = UNDEF_SIZE_3;\n-\t  return TRUE;\n+\t  return true;\n \t}\n \n     default:\n-      return FALSE;\n+      return false;\n     }\n }\n \n /* Return FALSE if GIVEN is not an unpredictable encoding for MATCHED_INSN.\n    Otherwise, return TRUE and set UNPREDICTABLE_CODE to give a reason as to\n    why this encoding is unpredictable.  */\n \n-static bfd_boolean\n+static bool\n is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \t\t      enum mve_unpredictable *unpredictable_code)\n {\n@@ -6419,10 +6419,10 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \t  && (arm_decode_field (given, 5, 5) == 1))\n \t{\n \t  *unpredictable_code = UNPRED_FCA_0_FCB_1;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VPT_VEC_T4:\n     case MVE_VPT_VEC_T5:\n@@ -6433,26 +6433,26 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n       if (arm_decode_field (given, 0, 3) == 0xd)\n \t{\n \t  *unpredictable_code = UNPRED_R13;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VDUP:\n       {\n \tunsigned long gpr = arm_decode_field (given, 12, 15);\n \tif (gpr == 0xd)\n \t  {\n \t    *unpredictable_code = UNPRED_R13;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (gpr == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case MVE_VQADD_T2:\n@@ -6486,15 +6486,15 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif (gpr == 0xd)\n \t  {\n \t    *unpredictable_code = UNPRED_R13;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (gpr == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case MVE_VLD2:\n@@ -6505,22 +6505,22 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif ((rn == 0xd) && (arm_decode_field (given, 21, 21) == 1))\n \t  {\n \t    *unpredictable_code = UNPRED_R13_AND_WB;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n \tif (rn == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n \tif (arm_decode_field_multiple (given, 13, 15, 22, 22) > 6)\n \t  {\n \t    *unpredictable_code = UNPRED_Q_GT_6;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VLD4:\n@@ -6531,22 +6531,22 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif ((rn == 0xd) && (arm_decode_field (given, 21, 21) == 1))\n \t  {\n \t    *unpredictable_code = UNPRED_R13_AND_WB;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n \tif (rn == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n \tif (arm_decode_field_multiple (given, 13, 15, 22, 22) > 4)\n \t  {\n \t    *unpredictable_code = UNPRED_Q_GT_4;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VLDRB_T5:\n@@ -6561,22 +6561,22 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif ((rn == 0xd) && (arm_decode_field (given, 21, 21) == 1))\n \t  {\n \t    *unpredictable_code = UNPRED_R13_AND_WB;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (rn == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VLDRB_GATHER_T1:\n       if (arm_decode_field (given, 0, 0) == 1)\n \t{\n \t  *unpredictable_code = UNPRED_OS;\n-\t  return TRUE;\n+\t  return true;\n \t}\n \n       /*  fall through.  */\n@@ -6591,16 +6591,16 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif (qd == qm)\n \t  {\n \t    *unpredictable_code = UNPRED_Q_REGS_EQUAL;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n \tif (arm_decode_field (given, 16, 19) == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case MVE_VLDRW_GATHER_T5:\n@@ -6612,36 +6612,36 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif (qd == qm)\n \t  {\n \t    *unpredictable_code = UNPRED_Q_REGS_EQUAL;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VSTRB_SCATTER_T1:\n       if (arm_decode_field (given, 16, 19) == 0xf)\n \t{\n \t  *unpredictable_code = UNPRED_R15;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else if (arm_decode_field (given, 0, 0) == 1)\n \t{\n \t  *unpredictable_code = UNPRED_OS;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VSTRH_SCATTER_T2:\n     case MVE_VSTRW_SCATTER_T3:\n     case MVE_VSTRD_SCATTER_T4:\n       if (arm_decode_field (given, 16, 19) == 0xf)\n \t{\n \t  *unpredictable_code = UNPRED_R15;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VMOV2_VEC_LANE_TO_GP:\n     case MVE_VMOV2_GP_TO_VEC_LANE:\n@@ -6654,20 +6654,20 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif ((rt == 0xd) || (rt2 == 0xd))\n \t  {\n \t    *unpredictable_code = UNPRED_R13;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if ((rt == 0xf) || (rt2 == 0xf))\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (rt == rt2)\n \t  {\n \t    *unpredictable_code = UNPRED_GP_REGS_EQUAL;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case MVE_VMAXV:\n@@ -6687,15 +6687,15 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif (rda == 0xd)\n \t  {\n \t    *unpredictable_code = UNPRED_R13;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (rda == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case MVE_VMULL_INT:\n@@ -6713,13 +6713,13 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \t    if ((Qd == Qn) || (Qd == Qm))\n \t      {\n \t\t*unpredictable_code = UNPRED_Q_REGS_EQ_AND_SIZE_2;\n-\t\treturn TRUE;\n+\t\treturn true;\n \t      }\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VCMUL_FP:\n@@ -6738,13 +6738,13 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \t    if ((Qd == Qn) || (Qd == Qm))\n \t      {\n \t\t*unpredictable_code = UNPRED_Q_REGS_EQ_AND_SIZE_1;\n-\t\treturn TRUE;\n+\t\treturn true;\n \t      }\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VQDMULL_T2:\n@@ -6753,12 +6753,12 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif (gpr == 0xd)\n \t  {\n \t    *unpredictable_code = UNPRED_R13;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (gpr == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n \tif (arm_decode_field (given, 28, 28) == 1)\n@@ -6770,13 +6770,13 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \t    if (Qd == Qn)\n \t      {\n \t\t*unpredictable_code = UNPRED_Q_REGS_EQ_AND_SIZE_1;\n-\t\treturn TRUE;\n+\t\treturn true;\n \t      }\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     case MVE_VMLSLDAV:\n@@ -6786,20 +6786,20 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n       if (arm_decode_field (given, 20, 22) == 6)\n \t{\n \t  *unpredictable_code = UNPRED_R13;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VDWDUP:\n     case MVE_VIWDUP:\n       if (arm_decode_field (given, 1, 3) == 6)\n \t{\n \t  *unpredictable_code = UNPRED_R13;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VCADD_VEC:\n     case MVE_VHCADD:\n@@ -6809,10 +6809,10 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif ((Qd == Qm) && arm_decode_field (given, 20, 21) == 2)\n \t  {\n \t    *unpredictable_code = UNPRED_Q_REGS_EQ_AND_SIZE_2;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VCADD_FP:\n@@ -6822,10 +6822,10 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif ((Qd == Qm) && arm_decode_field (given, 20, 20) == 1)\n \t  {\n \t    *unpredictable_code = UNPRED_Q_REGS_EQ_AND_SIZE_1;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_VCMLA_FP:\n@@ -6843,24 +6843,24 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \t    if ((Qda == Qn) || (Qda == Qm))\n \t      {\n \t\t*unpredictable_code = UNPRED_Q_REGS_EQ_AND_SIZE_1;\n-\t\treturn TRUE;\n+\t\treturn true;\n \t      }\n \t    else\n-\t      return FALSE;\n+\t      return false;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n \n       }\n \n     case MVE_VCTP:\n       if (arm_decode_field (given, 16, 19) == 0xd)\n \t{\n \t  *unpredictable_code = UNPRED_R13;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       else\n-\treturn FALSE;\n+\treturn false;\n \n     case MVE_VREV64:\n       {\n@@ -6870,10 +6870,10 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif (qd == qm)\n \t  {\n \t    *unpredictable_code = UNPRED_Q_REGS_EQUAL;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse\n-\t  return FALSE;\n+\t  return false;\n       }\n \n     case MVE_LSLL:\n@@ -6893,19 +6893,19 @@ is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n \tif (gpr == 0xd)\n \t  {\n \t    *unpredictable_code = UNPRED_R13;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \telse if (gpr == 0xf)\n \t  {\n \t    *unpredictable_code = UNPRED_R15;\n-\t    return TRUE;\n+\t    return true;\n \t  }\n \n-\treturn FALSE;\n+\treturn false;\n       }\n \n     default:\n-      return FALSE;\n+      return false;\n     }\n }\n \n@@ -8021,12 +8021,12 @@ print_vec_condition (struct disassemble_info *info, long given,\n    Return TRUE if the instuction matched, FALSE if this is not a\n    recognised coprocessor instruction.  */\n \n-static bfd_boolean\n+static bool\n print_insn_coprocessor_1 (const struct sopcode32 *opcodes,\n \t\t\t  bfd_vma pc,\n \t\t\t  struct disassemble_info *info,\n \t\t\t  long given,\n-\t\t\t  bfd_boolean thumb)\n+\t\t\t  bool thumb)\n {\n   const struct sopcode32 *insn;\n   void *stream = info->stream;\n@@ -8045,7 +8045,7 @@ print_insn_coprocessor_1 (const struct sopcode32 *opcodes,\n   for (insn = opcodes; insn->assembler; insn++)\n     {\n       unsigned long u_reg = 16;\n-      bfd_boolean is_unpredictable = FALSE;\n+      bool is_unpredictable = false;\n       signed long value_in_comment = 0;\n       const char *c;\n \n@@ -8122,7 +8122,7 @@ print_insn_coprocessor_1 (const struct sopcode32 *opcodes,\n \t  || insn->value == 0xfc000000) /* stc2  */\n \t{\n \t  if (cp_num == 9 || cp_num == 10 || cp_num == 11)\n-\t    is_unpredictable = TRUE;\n+\t    is_unpredictable = true;\n \n \t  /* Armv8.1-M Mainline FP & MVE instructions.  */\n \t  if (ARM_CPU_HAS_FEATURE (arm_ext_v8_1m_main, allowed_arches)\n@@ -8254,7 +8254,7 @@ print_insn_coprocessor_1 (const struct sopcode32 *opcodes,\n \n \t\tcase 'C':\n \t\t  {\n-\t\t    bfd_boolean single = ((given >> 8) & 1) == 0;\n+\t\t    bool single = ((given >> 8) & 1) == 0;\n \t\t    char reg_prefix = single ? 's' : 'd';\n \t\t    int Dreg = (given >> 22) & 0x1;\n \t\t    int Vdreg = (given >> 12) & 0xf;\n@@ -8279,12 +8279,12 @@ print_insn_coprocessor_1 (const struct sopcode32 *opcodes,\n \n \t\tcase 'u':\n \t\t  if (cond != COND_UNCOND)\n-\t\t    is_unpredictable = TRUE;\n+\t\t    is_unpredictable = true;\n \n \t\t  /* Fall through.  */\n \t\tcase 'c':\n \t\t  if (cond != COND_UNCOND && cp_num == 9)\n-\t\t    is_unpredictable = TRUE;\n+\t\t    is_unpredictable = true;\n \n \t\t  /* Fall through.  */\n \t\tcase 'b':\n@@ -8423,7 +8423,7 @@ print_insn_coprocessor_1 (const struct sopcode32 *opcodes,\n \t\t      {\n \t\t      case 'R':\n \t\t\tif (value == 15)\n-\t\t\t  is_unpredictable = TRUE;\n+\t\t\t  is_unpredictable = true;\n \t\t\t/* Fall through.  */\n \t\t      case 'r':\n \t\t\tif (c[1] == 'u')\n@@ -8432,7 +8432,7 @@ print_insn_coprocessor_1 (const struct sopcode32 *opcodes,\n \t\t\t    ++ c;\n \n \t\t\t    if (u_reg == value)\n-\t\t\t      is_unpredictable = TRUE;\n+\t\t\t      is_unpredictable = true;\n \t\t\t    u_reg = value;\n \t\t\t  }\n \t\t\tfunc (stream, \"%s\", arm_regnames[value]);\n@@ -8755,26 +8755,26 @@ print_insn_coprocessor_1 (const struct sopcode32 *opcodes,\n       if (is_unpredictable)\n \tfunc (stream, UNPREDICTABLE_INSTRUCTION);\n \n-      return TRUE;\n+      return true;\n     }\n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n print_insn_coprocessor (bfd_vma pc,\n \t\t\tstruct disassemble_info *info,\n \t\t\tlong given,\n-\t\t\tbfd_boolean thumb)\n+\t\t\tbool thumb)\n {\n   return print_insn_coprocessor_1 (coprocessor_opcodes,\n \t\t\t\t   pc, info, given, thumb);\n }\n \n-static bfd_boolean\n+static bool\n print_insn_generic_coprocessor (bfd_vma pc,\n \t\t\t\tstruct disassemble_info *info,\n \t\t\t\tlong given,\n-\t\t\t\tbfd_boolean thumb)\n+\t\t\t\tbool thumb)\n {\n   return print_insn_coprocessor_1 (generic_coprocessor_opcodes,\n \t\t\t\t   pc, info, given, thumb);\n@@ -8846,7 +8846,7 @@ print_arm_address (bfd_vma pc, struct disassemble_info *info, long given)\n \t  else\n \t    {\n \t      func (stream, \", %s\", NEGATIVE_BIT_SET ? \"-\" : \"\");\n-\t      arm_decode_shift (given, func, stream, TRUE);\n+\t      arm_decode_shift (given, func, stream, true);\n \t    }\n \n \t  func (stream, \"]%s\",\n@@ -8865,7 +8865,7 @@ print_arm_address (bfd_vma pc, struct disassemble_info *info, long given)\n \t    {\n \t      func (stream, \"], %s\",\n \t\t    NEGATIVE_BIT_SET ? \"-\" : \"\");\n-\t      arm_decode_shift (given, func, stream, TRUE);\n+\t      arm_decode_shift (given, func, stream, true);\n \t    }\n \t}\n       if (NEGATIVE_BIT_SET)\n@@ -8879,8 +8879,8 @@ print_arm_address (bfd_vma pc, struct disassemble_info *info, long given)\n /* Print one cde instruction on INFO->STREAM.\n    Return TRUE if the instuction matched, FALSE if this is not a\n    recognised cde instruction.  */\n-static bfd_boolean\n-print_insn_cde (struct disassemble_info *info, long given, bfd_boolean thumb)\n+static bool\n+print_insn_cde (struct disassemble_info *info, long given, bool thumb)\n {\n   const struct cdeopcode32 *insn;\n   void *stream = info->stream;\n@@ -8899,7 +8899,7 @@ print_insn_cde (struct disassemble_info *info, long given, bfd_boolean thumb)\n \n       if ((given & insn->mask) == insn->value)\n       {\n-\tbfd_boolean is_unpredictable = FALSE;\n+\tbool is_unpredictable = false;\n \tconst char *c;\n \n \tfor (c = insn->assembler; *c; c++)\n@@ -8924,11 +8924,11 @@ print_insn_cde (struct disassemble_info *info, long given, bfd_boolean thumb)\n \t\t{\n \t\t  case 'S':\n \t\t    if (value > 10)\n-\t\t      is_unpredictable = TRUE;\n+\t\t      is_unpredictable = true;\n \t\t    /* Fall through.  */\n \t\t  case 'R':\n \t\t    if (value == 13)\n-\t\t      is_unpredictable = TRUE;\n+\t\t      is_unpredictable = true;\n \t\t    /* Fall through.  */\n \t\t  case 'r':\n \t\t    func (stream, \"%s\", arm_regnames[value]);\n@@ -8999,22 +8999,22 @@ print_insn_cde (struct disassemble_info *info, long given, bfd_boolean thumb)\n       if (is_unpredictable)\n \tfunc (stream, UNPREDICTABLE_INSTRUCTION);\n \n-      return TRUE;\n+      return true;\n       }\n     }\n-    return FALSE;\n+    return false;\n   }\n   else\n-    return FALSE;\n+    return false;\n }\n \n \n /* Print one neon instruction on INFO->STREAM.\n    Return TRUE if the instuction matched, FALSE if this is not a\n    recognised neon instruction.  */\n \n-static bfd_boolean\n-print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)\n+static bool\n+print_insn_neon (struct disassemble_info *info, long given, bool thumb)\n {\n   const struct opcode32 *insn;\n   void *stream = info->stream;\n@@ -9041,7 +9041,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)\n \t;\n       /* vdup is also a valid neon instruction.  */\n       else if ((given & 0xff900f5f) != 0xee800b10)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   for (insn = neon_opcodes; insn->assembler; insn++)\n@@ -9087,7 +9087,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)\n       if ((given & cond_mask) == cond_value)\n \t{\n \t  signed long value_in_comment = 0;\n-\t  bfd_boolean is_unpredictable = FALSE;\n+\t  bool is_unpredictable = false;\n \t  const char *c;\n \n \t  for (c = insn->assembler; *c; c++)\n@@ -9102,7 +9102,7 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)\n \n \t\t    case 'u':\n \t\t      if (thumb && ifthen_state)\n-\t\t\tis_unpredictable = TRUE;\n+\t\t\tis_unpredictable = true;\n \n \t\t      /* Fall through.  */\n \t\t    case 'c':\n@@ -9175,34 +9175,34 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)\n                             {\n                               int amask = (1 << size) - 1;\n                               if ((idx_align & (1 << size)) != 0)\n-                                return FALSE;\n+                                return false;\n                               if (size > 0)\n                                 {\n                                   if ((idx_align & amask) == amask)\n                                     align = 8 << size;\n                                   else if ((idx_align & amask) != 0)\n-                                    return FALSE;\n+                                    return false;\n                                 }\n                               }\n                             break;\n \n                           case 2:\n                             if (size == 2 && (idx_align & 2) != 0)\n-                              return FALSE;\n+                              return false;\n                             align = (idx_align & 1) ? 16 << size : 0;\n                             break;\n \n                           case 3:\n                             if ((size == 2 && (idx_align & 3) != 0)\n                                 || (idx_align & 1) != 0)\n-                              return FALSE;\n+                              return false;\n                             break;\n \n                           case 4:\n                             if (size == 2)\n                               {\n                                 if ((idx_align & 3) == 3)\n-                                  return FALSE;\n+                                  return false;\n                                 align = (idx_align & 3) * 64;\n                               }\n                             else\n@@ -9520,17 +9520,17 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)\n \t  if (is_unpredictable)\n \t    func (stream, UNPREDICTABLE_INSTRUCTION);\n \n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* Print one mve instruction on INFO->STREAM.\n    Return TRUE if the instuction matched, FALSE if this is not a\n    recognised mve instruction.  */\n \n-static bfd_boolean\n+static bool\n print_insn_mve (struct disassemble_info *info, long given)\n {\n   const struct mopcode32 *insn;\n@@ -9543,8 +9543,8 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t  && !is_mve_encoding_conflict (given, insn->mve_op))\n \t{\n \t  signed long value_in_comment = 0;\n-\t  bfd_boolean is_unpredictable = FALSE;\n-\t  bfd_boolean is_undefined = FALSE;\n+\t  bool is_unpredictable = false;\n+\t  bool is_undefined = false;\n \t  const char *c;\n \t  enum mve_unpredictable unpredictable_cond = UNPRED_NONE;\n \t  enum mve_undefined undefined_cond = UNDEF_NONE;\n@@ -9553,15 +9553,15 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t     There are a few exceptions; check for them.  */\n \t  if (ifthen_state && !is_mve_okay_in_it (insn->mve_op))\n \t    {\n-\t      is_unpredictable = TRUE;\n+\t      is_unpredictable = true;\n \t      unpredictable_cond = UNPRED_IT_BLOCK;\n \t    }\n \t  else if (is_mve_unpredictable (given, insn->mve_op,\n \t\t\t\t\t &unpredictable_cond))\n-\t    is_unpredictable = TRUE;\n+\t    is_unpredictable = true;\n \n \t  if (is_mve_undefined (given, insn->mve_op, &undefined_cond))\n-\t    is_undefined = TRUE;\n+\t    is_undefined = true;\n \n \t  /* In \"VORR Qd, Qm, Qn\", if Qm==Qn, VORR is nothing but VMOV,\n \t     i.e \"VMOV Qd, Qm\".  */\n@@ -9715,7 +9715,7 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t\t\t  {\n \t\t\t  case 'Z':\n \t\t\t    if (value == 13)\n-\t\t\t      is_unpredictable = TRUE;\n+\t\t\t      is_unpredictable = true;\n \t\t\t    else if (value == 15)\n \t\t\t      func (stream, \"zr\");\n \t\t\t    else\n@@ -9733,7 +9733,7 @@ print_insn_mve (struct disassemble_info *info, long given)\n \n \t\t\t  case 'S':\n \t\t\t    if (value == 13 || value == 15)\n-\t\t\t      is_unpredictable = TRUE;\n+\t\t\t      is_unpredictable = true;\n \t\t\t    else\n \t\t\t      func (stream, \"%s\", arm_regnames[value]);\n \t\t\t    break;\n@@ -9894,10 +9894,10 @@ print_insn_mve (struct disassemble_info *info, long given)\n \t  else if (vpt_block_state.in_vpt_block)\n \t    update_vpt_block_state ();\n \n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n-  return FALSE;\n+  return false;\n }\n \n \n@@ -9979,13 +9979,13 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n   fprintf_ftype func = info->fprintf_func;\n   struct arm_private_data *private_data = info->private_data;\n \n-  if (print_insn_coprocessor (pc, info, given, FALSE))\n+  if (print_insn_coprocessor (pc, info, given, false))\n     return;\n \n-  if (print_insn_neon (info, given, FALSE))\n+  if (print_insn_neon (info, given, false))\n     return;\n \n-  if (print_insn_generic_coprocessor (pc, info, given, FALSE))\n+  if (print_insn_generic_coprocessor (pc, info, given, false))\n     return;\n \n   for (insn = arm_opcodes; insn->assembler; insn++)\n@@ -10005,15 +10005,15 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t{\n \t  unsigned long u_reg = 16;\n \t  unsigned long U_reg = 16;\n-\t  bfd_boolean is_unpredictable = FALSE;\n+\t  bool is_unpredictable = false;\n \t  signed long value_in_comment = 0;\n \t  const char *c;\n \n \t  for (c = insn->assembler; *c; c++)\n \t    {\n \t      if (*c == '%')\n \t\t{\n-\t\t  bfd_boolean allow_unpredictable = FALSE;\n+\t\t  bool allow_unpredictable = false;\n \n \t\t  switch (*++c)\n \t\t    {\n@@ -10032,7 +10032,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t      break;\n \n \t\t    case 'S':\n-\t\t      allow_unpredictable = TRUE;\n+\t\t      allow_unpredictable = true;\n \t\t      /* Fall through.  */\n \t\t    case 's':\n                       if ((given & 0x004f0000) == 0x004f0000)\n@@ -10058,7 +10058,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t      func (stream, \"[pc], #%s%d\",\n \t\t\t\t    NEGATIVE_BIT_SET ? \"-\" : \"\", (int) offset);\n \t\t\t      if (! allow_unpredictable)\n-\t\t\t\tis_unpredictable = TRUE;\n+\t\t\t\tis_unpredictable = true;\n \t\t\t    }\n \t\t\t}\n \t\t      else\n@@ -10096,7 +10096,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t\t  if (! allow_unpredictable\n \t\t\t\t      && WRITEBACK_BIT_SET\n \t\t\t\t      && ((given & 0xf) == ((given >> 12) & 0xf)))\n-\t\t\t\t    is_unpredictable = TRUE;\n+\t\t\t\t    is_unpredictable = true;\n \t\t\t\t}\n \n \t\t\t      func (stream, \"]%s\",\n@@ -10125,7 +10125,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t\t     destination of the load/store is unpredictable.  */\n \t\t\t\t  if (! allow_unpredictable\n \t\t\t\t      && (given & 0xf) == ((given >> 12) & 0xf))\n-\t\t\t\t    is_unpredictable = TRUE;\n+\t\t\t\t    is_unpredictable = true;\n \t\t\t\t}\n \n \t\t\t      if (! allow_unpredictable)\n@@ -10137,7 +10137,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t\t      /* Specifying the PC register as the post-indexed\n \t\t\t\t\t registers is also unpredictable.  */\n \t\t\t\t      || (! IMMEDIATE_BIT_SET && ((given & 0xf) == 0xf)))\n-\t\t\t\t    is_unpredictable = TRUE;\n+\t\t\t\t    is_unpredictable = true;\n \t\t\t\t}\n \t\t\t    }\n \t\t\t}\n@@ -10178,12 +10178,12 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t    }\n \t\t\tfunc (stream, \"}\");\n \t\t\tif (! started)\n-\t\t\t  is_unpredictable = TRUE;\n+\t\t\t  is_unpredictable = true;\n \t\t      }\n \t\t      break;\n \n \t\t    case 'q':\n-\t\t      arm_decode_shift (given, func, stream, FALSE);\n+\t\t      arm_decode_shift (given, func, stream, false);\n \t\t      break;\n \n \t\t    case 'o':\n@@ -10208,7 +10208,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t  value_in_comment = a;\n \t\t\t}\n \t\t      else\n-\t\t\tarm_decode_shift (given, func, stream, TRUE);\n+\t\t\tarm_decode_shift (given, func, stream, true);\n \t\t      break;\n \n \t\t    case 'p':\n@@ -10224,7 +10224,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t\t\t\t     arm_ext_v6))\n \t\t\t    func (stream, \"p\");\n \t\t\t  else\n-\t\t\t    is_unpredictable = TRUE;\n+\t\t\t    is_unpredictable = true;\n \t\t\t}\n \t\t      break;\n \n@@ -10360,7 +10360,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t  {\n \t\t\t  case 'R':\n \t\t\t    if (value == 15)\n-\t\t\t      is_unpredictable = TRUE;\n+\t\t\t      is_unpredictable = true;\n \t\t\t    /* Fall through.  */\n \t\t\t  case 'r':\n \t\t\t  case 'T':\n@@ -10374,7 +10374,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t\t++ c;\n \n \t\t\t\tif (u_reg == value)\n-\t\t\t\t  is_unpredictable = TRUE;\n+\t\t\t\t  is_unpredictable = true;\n \t\t\t\tu_reg = value;\n \t\t\t      }\n \t\t\t    if (c[1] == 'U')\n@@ -10383,7 +10383,7 @@ print_insn_arm (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t\t\t++ c;\n \n \t\t\t\tif (U_reg == value)\n-\t\t\t\t  is_unpredictable = TRUE;\n+\t\t\t\t  is_unpredictable = true;\n \t\t\t\tU_reg = value;\n \t\t\t      }\n \t\t\t    func (stream, \"%s\", arm_regnames[value]);\n@@ -10836,28 +10836,28 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)\n   const struct opcode32 *insn;\n   void *stream = info->stream;\n   fprintf_ftype func = info->fprintf_func;\n-  bfd_boolean is_mve = is_mve_architecture (info);\n+  bool is_mve = is_mve_architecture (info);\n \n-  if (print_insn_coprocessor (pc, info, given, TRUE))\n+  if (print_insn_coprocessor (pc, info, given, true))\n     return;\n \n-  if (!is_mve && print_insn_neon (info, given, TRUE))\n+  if (!is_mve && print_insn_neon (info, given, true))\n     return;\n \n   if (is_mve && print_insn_mve (info, given))\n     return;\n \n-  if (print_insn_cde (info, given, TRUE))\n+  if (print_insn_cde (info, given, true))\n     return;\n \n-  if (print_insn_generic_coprocessor (pc, info, given, TRUE))\n+  if (print_insn_generic_coprocessor (pc, info, given, true))\n     return;\n \n   for (insn = thumb32_opcodes; insn->assembler; insn++)\n     if ((given & insn->mask) == insn->value)\n       {\n-\tbfd_boolean is_clrm = FALSE;\n-\tbfd_boolean is_unpredictable = FALSE;\n+\tbool is_clrm = false;\n+\tbool is_unpredictable = false;\n \tsigned long value_in_comment = 0;\n \tconst char *c = insn->assembler;\n \n@@ -11019,7 +11019,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)\n \t\t  unsigned int op  = (given & 0x00000f00) >> 8;\n \t\t  unsigned int i12 = (given & 0x00000fff);\n \t\t  unsigned int i8  = (given & 0x000000ff);\n-\t\t  bfd_boolean writeback = FALSE, postind = FALSE;\n+\t\t  bool writeback = false, postind = false;\n \t\t  bfd_vma offset = 0;\n \n \t\t  func (stream, \"[%s\", arm_regnames[Rn]);\n@@ -11054,22 +11054,22 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)\n \n \t\t    case 0xF:  /* 8-bit + preindex with wb.  */\n \t\t      offset = i8;\n-\t\t      writeback = TRUE;\n+\t\t      writeback = true;\n \t\t      break;\n \n \t\t    case 0xD:  /* 8-bit - preindex with wb.  */\n \t\t      offset = -i8;\n-\t\t      writeback = TRUE;\n+\t\t      writeback = true;\n \t\t      break;\n \n \t\t    case 0xB:  /* 8-bit + postindex.  */\n \t\t      offset = i8;\n-\t\t      postind = TRUE;\n+\t\t      postind = true;\n \t\t      break;\n \n \t\t    case 0x9:  /* 8-bit - postindex.  */\n \t\t      offset = -i8;\n-\t\t      postind = TRUE;\n+\t\t      postind = true;\n \t\t      break;\n \n \t\t    default:\n@@ -11153,7 +11153,7 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)\n \t\tbreak;\n \n \t      case 'n':\n-\t\tis_clrm = TRUE;\n+\t\tis_clrm = true;\n \t\t/* Fall through.  */\n \t      case 'm':\n \t\t{\n@@ -11473,11 +11473,11 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)\n \n \t\t    case 'S':\n \t\t      if (val == 13)\n-\t\t\tis_unpredictable = TRUE;\n+\t\t\tis_unpredictable = true;\n \t\t      /* Fall through.  */\n \t\t    case 'R':\n \t\t      if (val == 15)\n-\t\t\tis_unpredictable = TRUE;\n+\t\t\tis_unpredictable = true;\n \t\t      /* Fall through.  */\n \t\t    case 'r':\n \t\t      func (stream, \"%s\", arm_regnames[val]);\n@@ -11577,14 +11577,14 @@ print_insn_data (bfd_vma pc ATTRIBUTE_UNUSED,\n    Also disallow private symbol, with __tagsym$$ prefix,\n    from ARM RVCT toolchain being displayed.  */\n \n-bfd_boolean\n+bool\n arm_symbol_is_valid (asymbol * sym,\n \t\t     struct disassemble_info * info ATTRIBUTE_UNUSED)\n {\n   const char * name;\n \n   if (sym == NULL)\n-    return FALSE;\n+    return false;\n \n   name = bfd_asymbol_name (sym);\n \n@@ -11657,7 +11657,7 @@ parse_arm_disassembler_options (const char *options)\n   return;\n }\n \n-static bfd_boolean\n+static bool\n mapping_symbol_for_insn (bfd_vma pc, struct disassemble_info *info,\n \t\t\t enum map_type *map_symbol);\n \n@@ -11667,7 +11667,7 @@ mapping_symbol_for_insn (bfd_vma pc, struct disassemble_info *info,\n static void\n find_ifthen_state (bfd_vma pc,\n \t\t   struct disassemble_info *info,\n-\t\t   bfd_boolean little)\n+\t\t   bool little)\n {\n   unsigned char b[2];\n   unsigned int insn;\n@@ -11724,7 +11724,7 @@ find_ifthen_state (bfd_vma pc,\n       if ((insn & 0xff00) == 0xbf00 && (insn & 0xf) != 0)\n \t{\n \t  enum map_type type = MAP_ARM;\n-\t  bfd_boolean found = mapping_symbol_for_insn (addr, info, &type);\n+\t  bool found = mapping_symbol_for_insn (addr, info, &type);\n \n \t  if (!found || (found && type == MAP_THUMB))\n \t    {\n@@ -11763,10 +11763,10 @@ is_mapping_symbol (struct disassemble_info *info, int n,\n       *map_type = ((name[1] == 'a') ? MAP_ARM\n \t\t   : (name[1] == 't') ? MAP_THUMB\n \t\t   : MAP_DATA);\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Try to infer the code type (ARM or Thumb) from a mapping symbol.\n@@ -11779,7 +11779,7 @@ get_map_sym_type (struct disassemble_info *info,\n {\n   /* If the symbol is in a different section, ignore it.  */\n   if (info->section != NULL && info->section != info->symtab[n]->section)\n-    return FALSE;\n+    return false;\n \n   return is_mapping_symbol (info, n, map_type);\n }\n@@ -11797,7 +11797,7 @@ get_sym_code_type (struct disassemble_info *info,\n \n   /* If the symbol is in a different section, ignore it.  */\n   if (info->section != NULL && info->section != info->symtab[n]->section)\n-    return FALSE;\n+    return false;\n \n   es = *(elf_symbol_type **)(info->symtab + n);\n   type = ELF_ST_TYPE (es->internal_elf_sym.st_info);\n@@ -11810,10 +11810,10 @@ get_sym_code_type (struct disassemble_info *info,\n \t*map_type = MAP_THUMB;\n       else\n \t*map_type = MAP_ARM;\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Search the mapping symbol state for instruction at pc.  This is only\n@@ -11826,14 +11826,14 @@ get_sym_code_type (struct disassemble_info *info,\n    Return TRUE if the mapping state can be determined, and map_symbol\n    will be updated accordingly.  Otherwise, return FALSE.  */\n \n-static bfd_boolean\n+static bool\n mapping_symbol_for_insn (bfd_vma pc, struct disassemble_info *info,\n \t\t\t enum map_type *map_symbol)\n {\n   bfd_vma addr, section_vma = 0;\n   int n, last_sym = -1;\n-  bfd_boolean found = FALSE;\n-  bfd_boolean can_use_search_opt_p = FALSE;\n+  bool found = false;\n+  bool can_use_search_opt_p = false;\n \n   /* Default to DATA.  A text section is required by the ABI to contain an\n      INSN mapping symbol at the start.  A data section has no such\n@@ -11850,7 +11850,7 @@ mapping_symbol_for_insn (bfd_vma pc, struct disassemble_info *info,\n \n   if (info->private_data == NULL\n       || bfd_asymbol_flavour (*info->symtab) != bfd_target_elf_flavour)\n-    return FALSE;\n+    return false;\n \n   private_data = info->private_data;\n \n@@ -11886,7 +11886,7 @@ mapping_symbol_for_insn (bfd_vma pc, struct disassemble_info *info,\n \tif (get_map_sym_type (info, n, &type))\n \t  {\n \t    last_sym = n;\n-\t    found = TRUE;\n+\t    found = true;\n \t  }\n       }\n \n@@ -11914,7 +11914,7 @@ mapping_symbol_for_insn (bfd_vma pc, struct disassemble_info *info,\n \t    if (get_map_sym_type (info, n, &type))\n \t      {\n \t\tlast_sym = n;\n-\t\tfound = TRUE;\n+\t\tfound = true;\n \t\tbreak;\n \t      }\n \t  }\n@@ -11931,7 +11931,7 @@ mapping_symbol_for_insn (bfd_vma pc, struct disassemble_info *info,\n       if (n >= 0 && get_sym_code_type (info, n, &type))\n \t{\n \t  last_sym = n;\n-\t  found = TRUE;\n+\t  found = true;\n \t}\n     }\n \n@@ -12035,17 +12035,17 @@ select_arm_features (unsigned long mach,\n    the relevant number of data bytes exist.  */\n \n static int\n-print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n+print_insn (bfd_vma pc, struct disassemble_info *info, bool little)\n {\n   unsigned char b[4];\n   unsigned long given;\n-  int           status;\n-  int           is_thumb = FALSE;\n-  int           is_data = FALSE;\n-  int           little_code;\n+  int status;\n+  int is_thumb = false;\n+  int is_data = false;\n+  int little_code;\n   unsigned int\tsize = 4;\n-  void\t \t(*printer) (bfd_vma, struct disassemble_info *, long);\n-  bfd_boolean   found = FALSE;\n+  void (*printer) (bfd_vma, struct disassemble_info *, long);\n+  bool found = false;\n   struct arm_private_data *private_data;\n \n   /* Clear instruction information field.  */\n@@ -12189,7 +12189,7 @@ print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n     }\n \n   if (force_thumb)\n-    is_thumb = TRUE;\n+    is_thumb = true;\n \n   if (is_data)\n     info->display_endian = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;\n@@ -12310,13 +12310,13 @@ print_insn_big_arm (bfd_vma pc, struct disassemble_info *info)\n       && (elf_elfheader (info->section->owner)->e_flags & EF_ARM_BE8))\n     info->endian_code = BFD_ENDIAN_LITTLE;\n \n-  return print_insn (pc, info, FALSE);\n+  return print_insn (pc, info, false);\n }\n \n int\n print_insn_little_arm (bfd_vma pc, struct disassemble_info *info)\n {\n-  return print_insn (pc, info, TRUE);\n+  return print_insn (pc, info, true);\n }\n \n const disasm_options_and_args_t *"
    },
    {
      "sha": "599b9a0ef26f0c9086e7571a5c347991a945ade4",
      "filename": "opcodes/bfin-dis.c",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/bfin-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/bfin-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bfin-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -44,7 +44,7 @@ typedef unsigned int bu32;\n struct private\n {\n   TIword iw0;\n-  bfd_boolean comment, parallel;\n+  bool comment, parallel;\n };\n \n typedef enum\n@@ -1571,7 +1571,7 @@ decode_LOGI2op_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \");\\t\\t/* bit\");\n       OUTS (outf, imm7d (src));\n       OUTS (outf, \" */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else if (opc == 1)\n     {\n@@ -1582,7 +1582,7 @@ decode_LOGI2op_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \");\\t\\t/* bit\");\n       OUTS (outf, imm7d (src));\n       OUTS (outf, \" */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else if (opc == 2)\n     {\n@@ -1593,7 +1593,7 @@ decode_LOGI2op_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \");\\t\\t/* bit\");\n       OUTS (outf, imm7d (src));\n       OUTS (outf, \" */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else if (opc == 3)\n     {\n@@ -1604,7 +1604,7 @@ decode_LOGI2op_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \");\\t\\t/* bit\");\n       OUTS (outf, imm7d (src));\n       OUTS (outf, \" */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else if (opc == 4)\n     {\n@@ -1615,7 +1615,7 @@ decode_LOGI2op_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \");\\t\\t/* bit\");\n       OUTS (outf, imm7d (src));\n       OUTS (outf, \" */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else if (opc == 5)\n     {\n@@ -1773,7 +1773,7 @@ decode_COMPI2opD_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \"(\");\n       OUTS (outf, imm32 (*pval));\n       OUTS (outf, \") */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else if (op == 1)\n     {\n@@ -1783,7 +1783,7 @@ decode_COMPI2opD_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \";\\t\\t/* (\");\n       OUTS (outf, imm7d (src));\n       OUTS (outf, \") */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else\n     return 0;\n@@ -1829,7 +1829,7 @@ decode_COMPI2opP_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \"(\");\n       OUTS (outf, imm32 (*pval));\n       OUTS (outf, \") */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else if (op == 1)\n     {\n@@ -1839,7 +1839,7 @@ decode_COMPI2opP_0 (TIword iw0, disassemble_info *outf)\n       OUTS (outf, \";\\t\\t/* (\");\n       OUTS (outf, imm7d (src));\n       OUTS (outf, \") */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else\n     return 0;\n@@ -2045,7 +2045,7 @@ decode_dagMODik_0 (TIword iw0, disassemble_info *outf)\n       else if (op == 2 || op == 3)\n \tOUTS (outf, \"4\");\n       OUTS (outf, \") */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n \n   return 2;\n@@ -2745,7 +2745,7 @@ decode_LDIMMhalf_0 (TIword iw0, TIword iw1, disassemble_info *outf)\n \t}\n \n       OUTS (outf, \" */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   if (S == 1 || Z == 1)\n     {\n@@ -2756,7 +2756,7 @@ decode_LDIMMhalf_0 (TIword iw0, TIword iw1, disassemble_info *outf)\n       OUTS (outf, \"(\");\n       OUTS (outf, imm32 (*pval));\n       OUTS (outf, \") */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   return 4;\n }\n@@ -2921,7 +2921,7 @@ decode_linkage_0 (TIword iw0, TIword iw1, disassemble_info *outf)\n       OUTS (outf, \";\\t\\t/* (\");\n       OUTS (outf, uimm16s4d (framesize));\n       OUTS (outf, \") */\");\n-      priv->comment = TRUE;\n+      priv->comment = true;\n     }\n   else if (R == 1)\n     OUTS (outf, \"UNLINK\");\n@@ -4773,8 +4773,8 @@ print_insn_bfin (bfd_vma pc, disassemble_info *outf)\n   struct private priv;\n   int count;\n \n-  priv.parallel = FALSE;\n-  priv.comment = FALSE;\n+  priv.parallel = false;\n+  priv.comment = false;\n   outf->private_data = &priv;\n \n   count = _print_insn_bfin (pc, outf);\n@@ -4786,29 +4786,29 @@ print_insn_bfin (bfd_vma pc, disassemble_info *outf)\n   if (count == 4 && (priv.iw0 & 0xc000) == 0xc000 && (priv.iw0 & BIT_MULTI_INS)\n       && ((priv.iw0 & 0xe800) != 0xe800 /* Not Linkage.  */ ))\n     {\n-      bfd_boolean legal = TRUE;\n+      bool legal = true;\n       int len;\n \n-      priv.parallel = TRUE;\n+      priv.parallel = true;\n       OUTS (outf, \" || \");\n       len = _print_insn_bfin (pc + 4, outf);\n       if (len == -1)\n \treturn -1;\n       OUTS (outf, \" || \");\n       if (len != 2)\n-\tlegal = FALSE;\n+\tlegal = false;\n       len = _print_insn_bfin (pc + 6, outf);\n       if (len == -1)\n \treturn -1;\n       if (len != 2)\n-\tlegal = FALSE;\n+\tlegal = false;\n \n       if (legal)\n \tcount = 8;\n       else\n \t{\n \t  OUTS (outf, \";\\t\\t/* ILLEGAL PARALLEL INSTRUCTION */\");\n-\t  priv.comment = TRUE;\n+\t  priv.comment = true;\n \t  count = 0;\n \t}\n     }"
    },
    {
      "sha": "0385e582442d3fec9506951bb5e917fc12895efd",
      "filename": "opcodes/cris-dis.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/cris-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/cris-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/cris-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -74,7 +74,7 @@ struct cris_disasm_data\n {\n   /* Whether to print something less confusing if we find something\n      matching a switch-construct.  */\n-  bfd_boolean trace_case;\n+  bool trace_case;\n \n   /* Whether this code is flagged as crisv32.  FIXME: Should be an enum\n      that includes \"compatible\".  */\n@@ -99,7 +99,7 @@ static int cris_constraint\n /* Parse disassembler options and store state in info.  FIXME: For the\n    time being, we abuse static variables.  */\n \n-static bfd_boolean\n+static bool\n cris_parse_disassembler_options (disassemble_info *info,\n \t\t\t\t enum cris_disass_family distype)\n {\n@@ -108,15 +108,15 @@ cris_parse_disassembler_options (disassemble_info *info,\n   info->private_data = calloc (1, sizeof (struct cris_disasm_data));\n   disdata = (struct cris_disasm_data *) info->private_data;\n   if (disdata == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Default true.  */\n   disdata->trace_case\n     = (info->disassembler_options == NULL\n        || (strcmp (info->disassembler_options, \"nocase\") != 0));\n \n   disdata->distype = distype;\n-  return TRUE;\n+  return true;\n }\n \n static const struct cris_spec_reg *\n@@ -594,7 +594,7 @@ static char *\n format_reg (struct cris_disasm_data *disdata,\n \t    int regno,\n \t    char *outbuffer_start,\n-\t    bfd_boolean with_reg_prefix)\n+\t    bool with_reg_prefix)\n {\n   char *outbuffer = outbuffer_start;\n \n@@ -628,7 +628,7 @@ format_reg (struct cris_disasm_data *disdata,\n static char *\n format_sup_reg (unsigned int regno,\n \t\tchar *outbuffer_start,\n-\t\tbfd_boolean with_reg_prefix)\n+\t\tbool with_reg_prefix)\n {\n   char *outbuffer = outbuffer_start;\n   int i;\n@@ -741,7 +741,7 @@ print_with_operands (const struct cris_opcode *opcodep,\n \t\t     const struct cris_opcode *prefix_opcodep,\n \t\t     unsigned int prefix_insn,\n \t\t     unsigned char *prefix_buffer,\n-\t\t     bfd_boolean with_reg_prefix)\n+\t\t     bool with_reg_prefix)\n {\n   /* Get a buffer of somewhat reasonable size where we store\n      intermediate parts of the insn.  */\n@@ -1389,7 +1389,7 @@ print_with_operands (const struct cris_opcode *opcodep,\n static int\n print_insn_cris_generic (bfd_vma memaddr,\n \t\t\t disassemble_info *info,\n-\t\t\t bfd_boolean with_reg_prefix)\n+\t\t\t bool with_reg_prefix)\n {\n   int nbytes;\n   unsigned int insn;\n@@ -1581,7 +1581,7 @@ print_insn_cris_with_register_prefix (bfd_vma vma,\n   if (info->private_data == NULL\n       && !cris_parse_disassembler_options (info, cris_dis_v0_v10))\n     return -1;\n-  return print_insn_cris_generic (vma, info, TRUE);\n+  return print_insn_cris_generic (vma, info, true);\n }\n \n /* Disassemble, prefixing register names with `$'.  CRIS v32.  */\n@@ -1593,7 +1593,7 @@ print_insn_crisv32_with_register_prefix (bfd_vma vma,\n   if (info->private_data == NULL\n       && !cris_parse_disassembler_options (info, cris_dis_v32))\n     return -1;\n-  return print_insn_cris_generic (vma, info, TRUE);\n+  return print_insn_cris_generic (vma, info, true);\n }\n \n /* Disassemble, prefixing register names with `$'.\n@@ -1606,7 +1606,7 @@ print_insn_crisv10_v32_with_register_prefix (bfd_vma vma,\n   if (info->private_data == NULL\n       && !cris_parse_disassembler_options (info, cris_dis_common_v10_v32))\n     return -1;\n-  return print_insn_cris_generic (vma, info, TRUE);\n+  return print_insn_cris_generic (vma, info, true);\n }\n \n /* Disassemble, no prefixes on register names.  CRIS v0..v10.  */\n@@ -1618,7 +1618,7 @@ print_insn_cris_without_register_prefix (bfd_vma vma,\n   if (info->private_data == NULL\n       && !cris_parse_disassembler_options (info, cris_dis_v0_v10))\n     return -1;\n-  return print_insn_cris_generic (vma, info, FALSE);\n+  return print_insn_cris_generic (vma, info, false);\n }\n \n /* Disassemble, no prefixes on register names.  CRIS v32.  */\n@@ -1630,7 +1630,7 @@ print_insn_crisv32_without_register_prefix (bfd_vma vma,\n   if (info->private_data == NULL\n       && !cris_parse_disassembler_options (info, cris_dis_v32))\n     return -1;\n-  return print_insn_cris_generic (vma, info, FALSE);\n+  return print_insn_cris_generic (vma, info, false);\n }\n \n /* Disassemble, no prefixes on register names.\n@@ -1643,7 +1643,7 @@ print_insn_crisv10_v32_without_register_prefix (bfd_vma vma,\n   if (info->private_data == NULL\n       && !cris_parse_disassembler_options (info, cris_dis_common_v10_v32))\n     return -1;\n-  return print_insn_cris_generic (vma, info, FALSE);\n+  return print_insn_cris_generic (vma, info, false);\n }\n \n /* Return a disassembler-function that prints registers with a `$' prefix,"
    },
    {
      "sha": "cdd911be09aa18eb1e385b0a51dc807a4bd1e6e5",
      "filename": "opcodes/csky-dis.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/csky-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/csky-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/csky-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -100,9 +100,9 @@ get_sym_code_type (struct disassemble_info *info,\n       && (name[2] == 0 || name[2] == '.'))\n     {\n       *sym_type = ((name[1] == 't') ? CUR_TEXT : CUR_DATA);\n-      return TRUE;\n+      return true;\n     }\n-  return FALSE;\n+  return false;\n }\n \n static int\n@@ -200,7 +200,7 @@ csky_find_inst_info (struct csky_opcode_info const **pinfo,\n   return NULL;\n }\n \n-static bfd_boolean\n+static bool\n is_extern_symbol (struct disassemble_info *info, int addr)\n {\n   unsigned int rel_count = 0;\n@@ -212,24 +212,24 @@ is_extern_symbol (struct disassemble_info *info, int addr)\n       struct reloc_cache_entry *pt = info->section->relocation;\n       for (; rel_count < info->section->reloc_count; rel_count++, pt++)\n \tif ((long unsigned int)addr == pt->address)\n-\t  return TRUE;\n-      return FALSE;\n+\t  return true;\n+      return false;\n     }\n-  return FALSE;\n+  return false;\n }\n \n \n /* Suppress printing of mapping symbols emitted by the assembler to mark\n    the beginning of code and data sequences.  */\n \n-bfd_boolean\n+bool\n csky_symbol_is_valid (asymbol *sym,\n \t\t      struct disassemble_info *info ATTRIBUTE_UNUSED)\n {\n   const char *name;\n \n   if (sym == NULL)\n-    return FALSE;\n+    return false;\n   name = bfd_asymbol_name (sym);\n   return name && *name != '$';\n }\n@@ -776,7 +776,7 @@ csky_output_operand (char *str, struct operand const *oprnd,\n     case OPRND_TYPE_PSR_BITS_LIST:\n       {\n \tstruct psrbit const *bits;\n-\tint first_oprnd = TRUE;\n+\tint first_oprnd = true;\n \tint i = 0;\n \tif (IS_CSKY_V1 (mach_flag))\n \t  {\n@@ -797,7 +797,7 @@ csky_output_operand (char *str, struct operand const *oprnd,\n \t\t    strcat (str, \", \");\n \t\t  strcat (str, bits[i].name);\n \t\t  value &= ~bits[i].value;\n-\t\t  first_oprnd = FALSE;\n+\t\t  first_oprnd = false;\n \t\t}\n \t      i++;\n \t    }\n@@ -1049,7 +1049,7 @@ print_insn_csky (bfd_vma memaddr, struct disassemble_info *info)\n   int status;\n   char str[256];\n   unsigned long given;\n-  int is_data = FALSE;\n+  int is_data = false;\n   void (*printer) (bfd_vma, struct disassemble_info *, long);\n   unsigned int  size = 4;\n "
    },
    {
      "sha": "27452bd6545f022b01ba6022d9318a662de0999e",
      "filename": "opcodes/csky-opc.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/csky-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/csky-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/csky-opc.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -280,7 +280,7 @@ struct csky_opcode\n   signed int relax;\n   /* Worker function to call when this instruction needs special assembler\n      handling.  */\n-  bfd_boolean (*work)(void);\n+  bool (*work) (void);\n };\n \n /* The following are the opcodes used in relax/fix process.  */"
    },
    {
      "sha": "2a934652a1ef1b2784a800232317203ef9982438",
      "filename": "opcodes/dis-buf.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/dis-buf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/dis-buf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/dis-buf.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -98,9 +98,9 @@ generic_symbol_at_address (bfd_vma addr ATTRIBUTE_UNUSED,\n \n /* Just return TRUE.  */\n \n-bfd_boolean\n+bool\n generic_symbol_is_valid (asymbol * sym ATTRIBUTE_UNUSED,\n \t\t\t struct disassemble_info *info ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "8590e945c58e8902ab9aecb93b8eb2ca4ca4c76d",
      "filename": "opcodes/disassemble.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/disassemble.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/disassemble.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/disassemble.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -125,7 +125,7 @@ enum epbf_isa_attr\n \n disassembler_ftype\n disassembler (enum bfd_architecture a,\n-\t      bfd_boolean big ATTRIBUTE_UNUSED,\n+\t      bool big ATTRIBUTE_UNUSED,\n \t      unsigned long mach ATTRIBUTE_UNUSED,\n \t      bfd *abfd ATTRIBUTE_UNUSED)\n {\n@@ -606,19 +606,19 @@ disassemble_init_for_target (struct disassemble_info * info)\n #ifdef ARCH_aarch64\n     case bfd_arch_aarch64:\n       info->symbol_is_valid = aarch64_symbol_is_valid;\n-      info->disassembler_needs_relocs = TRUE;\n+      info->disassembler_needs_relocs = true;\n       break;\n #endif\n #ifdef ARCH_arm\n     case bfd_arch_arm:\n       info->symbol_is_valid = arm_symbol_is_valid;\n-      info->disassembler_needs_relocs = TRUE;\n+      info->disassembler_needs_relocs = true;\n       break;\n #endif\n #ifdef ARCH_csky\n     case bfd_arch_csky:\n       info->symbol_is_valid = csky_symbol_is_valid;\n-      info->disassembler_needs_relocs = TRUE;\n+      info->disassembler_needs_relocs = true;\n       break;\n #endif\n \n@@ -640,7 +640,7 @@ disassemble_init_for_target (struct disassemble_info * info)\n #endif\n #ifdef ARCH_metag\n     case bfd_arch_metag:\n-      info->disassembler_needs_relocs = TRUE;\n+      info->disassembler_needs_relocs = true;\n       break;\n #endif\n #ifdef ARCH_m32c\n@@ -681,7 +681,7 @@ disassemble_init_for_target (struct disassemble_info * info)\n #endif\n #ifdef ARCH_pru\n     case bfd_arch_pru:\n-      info->disassembler_needs_relocs = TRUE;\n+      info->disassembler_needs_relocs = true;\n       break;\n #endif\n #ifdef ARCH_powerpc"
    },
    {
      "sha": "587bc1b5e6d5dd9ad3cad10390b11f5e001caff6",
      "filename": "opcodes/frv-opc.c",
      "status": "modified",
      "additions": 68,
      "deletions": 68,
      "changes": 136,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/frv-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/frv-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/frv-opc.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -42,117 +42,117 @@ This file is part of the GNU Binutils and/or GDB, the GNU debugger.\n /* Returns TRUE if {MAJOR,MACH} is a major branch of the FRV\n    development tree.  */\n \n-bfd_boolean\n+bool\n frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)\n {\n   switch (mach)\n     {\n     case bfd_mach_fr400:\n       if (major >= FR400_MAJOR_B_1 && major <= FR400_MAJOR_B_6)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case bfd_mach_fr450:\n       if (major >= FR450_MAJOR_B_1 && major <= FR450_MAJOR_B_6)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n       if (major >= FR500_MAJOR_B_1 && major <= FR500_MAJOR_B_6)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Returns TRUE if {MAJOR,MACH} supports floating point insns.  */\n \n-bfd_boolean\n+bool\n frv_is_float_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)\n {\n   switch (mach)\n     {\n     case bfd_mach_fr400:\n     case bfd_mach_fr450:\n-      return FALSE;\n+      return false;\n     default:\n       if (major >= FR500_MAJOR_F_1 && major <= FR500_MAJOR_F_8)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Returns TRUE if {MAJOR,MACH} supports media insns.  */\n \n-bfd_boolean\n+bool\n frv_is_media_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)\n {\n   switch (mach)\n     {\n     case bfd_mach_fr400:\n       if (major >= FR400_MAJOR_M_1 && major <= FR400_MAJOR_M_2)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case bfd_mach_fr450:\n       if (major >= FR450_MAJOR_M_1 && major <= FR450_MAJOR_M_6)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n       if (major >= FR500_MAJOR_M_1 && major <= FR500_MAJOR_M_8)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n frv_is_branch_insn (const CGEN_INSN *insn)\n {\n   if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),\n \t\t\t   bfd_mach_fr400))\n-    return TRUE;\n+    return true;\n   if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),\n \t\t\t   bfd_mach_fr450))\n-    return TRUE;\n+    return true;\n   if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),\n \t\t\t   bfd_mach_fr500))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n frv_is_float_insn (const CGEN_INSN *insn)\n {\n   if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),\n \t\t\t  bfd_mach_fr400))\n-    return TRUE;\n+    return true;\n   if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),\n \t\t\t  bfd_mach_fr450))\n-    return TRUE;\n+    return true;\n   if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),\n \t\t\t  bfd_mach_fr500))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n frv_is_media_insn (const CGEN_INSN *insn)\n {\n   if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),\n \t\t\t  bfd_mach_fr400))\n-    return TRUE;\n+    return true;\n   if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),\n \t\t\t  bfd_mach_fr450))\n-    return TRUE;\n+    return true;\n   if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),\n \t\t\t  bfd_mach_fr500))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* This table represents the allowable packing for vliw insns for the fr400.\n@@ -393,17 +393,17 @@ frv_vliw_reset (FRV_VLIW *vliw, unsigned long mach, unsigned long elf_flags)\n /* Return TRUE if unit1 is a match for unit2.\n    Unit1 comes from the insn's UNIT attribute. unit2 comes from one of the\n    *_allowed_vliw tables above.  */\n-static bfd_boolean\n+static bool\n match_unit (FRV_VLIW *vliw,\n \t    CGEN_ATTR_VALUE_ENUM_TYPE unit1, CGEN_ATTR_VALUE_ENUM_TYPE unit2)\n {\n   /* Map any specialized implementation units to actual ones.  */\n   unit1 = vliw->unit_mapping[unit1];\n \n   if (unit1 == unit2)\n-    return TRUE;\n+    return true;\n   if (unit1 < unit2)\n-    return FALSE;\n+    return false;\n \n   switch (unit1)\n     {\n@@ -413,34 +413,34 @@ match_unit (FRV_VLIW *vliw,\n       /* The 01 versions of these units are within 2 enums of the 0 or 1\n \t versions.  */\n       if (unit1 - unit2 <= 2)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     case UNIT_IALL:\n     case UNIT_FMALL:\n       /* The ALL versions of these units are within 5 enums of the 0, 1, 2 or 3\n \t versions.  */\n       if (unit1 - unit2 <= 5)\n-\treturn TRUE;\n+\treturn true;\n       break;\n     default:\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return TRUE if the vliws match, FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n match_vliw (VLIW_COMBO *vliw1, VLIW_COMBO *vliw2, int vliw_size)\n {\n   int i;\n \n   for (i = 0; i < vliw_size; ++i)\n     if ((*vliw1)[i] != (*vliw2)[i])\n-      return FALSE;\n+      return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Find the next vliw vliw in the table that can accomodate the new insn.\n@@ -477,22 +477,22 @@ add_next_to_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE unit)\n /* Look for the given major insn type in the given vliw.\n    Returns TRUE if found, FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n find_major_in_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)\n {\n   int i;\n \n   for (i = 0; i < vliw->next_slot; ++i)\n     if (vliw->major[i] == major)\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Check for constraints between the insns in the vliw due to major insn\n    types.  */\n \n-static bfd_boolean\n+static bool\n fr400_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)\n {\n   /* In the cpu file, all media insns are represented as being allowed in\n@@ -509,10 +509,10 @@ fr400_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n     default:\n       break;\n     }\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n fr450_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)\n {\n   CGEN_ATTR_VALUE_ENUM_TYPE other_major;\n@@ -523,7 +523,7 @@ fr450_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n   /* (M4, M5) and (M4, M6) are allowed.  */\n   if (other_major == FR450_MAJOR_M_4)\n     if (major == FR450_MAJOR_M_5 || major == FR450_MAJOR_M_6)\n-      return TRUE;\n+      return true;\n \n   /* Otherwise, instructions in even-numbered media categories cannot be\n      executed in parallel with other media instructions.  */\n@@ -543,23 +543,23 @@ fr450_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n \t       || other_major == FR450_MAJOR_M_6);\n \n     default:\n-      return TRUE;\n+      return true;\n     }\n }\n \n-static bfd_boolean\n+static bool\n find_unit_in_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE unit)\n {\n   int i;\n \n   for (i = 0; i < vliw->next_slot; ++i)\n     if (CGEN_INSN_ATTR_VALUE (vliw->insn[i], CGEN_INSN_UNIT) == unit)\n-      return TRUE;\n+      return true;\n \n-  return FALSE; /* Not found.  */\n+  return false; /* Not found.  */\n }\n \n-static bfd_boolean\n+static bool\n find_major_in_slot (FRV_VLIW *vliw,\n \t\t    CGEN_ATTR_VALUE_ENUM_TYPE major,\n \t\t    CGEN_ATTR_VALUE_ENUM_TYPE slot)\n@@ -568,12 +568,12 @@ find_major_in_slot (FRV_VLIW *vliw,\n \n   for (i = 0; i < vliw->next_slot; ++i)\n     if (vliw->major[i] == major && (*vliw->current_vliw)[i] == slot)\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n fr550_find_media_in_vliw (FRV_VLIW *vliw)\n {\n   int i;\n@@ -589,13 +589,13 @@ fr550_find_media_in_vliw (FRV_VLIW *vliw)\n \t  || CGEN_INSN_NUM (vliw->insn[i]) == FRV_INSN_MCLRACC_1)\n \tcontinue;\n \n-      return TRUE; /* Found one.  */\n+      return true; /* Found one.  */\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n fr550_find_float_in_vliw (FRV_VLIW *vliw)\n {\n   int i;\n@@ -609,13 +609,13 @@ fr550_find_float_in_vliw (FRV_VLIW *vliw)\n       if (CGEN_INSN_NUM (vliw->insn[i]) == FRV_INSN_FNOP)\n \tcontinue;\n \n-      return TRUE; /* Found one.  */\n+      return true; /* Found one.  */\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n fr550_check_insn_major_constraints (FRV_VLIW *vliw,\n \t\t\t\t    CGEN_ATTR_VALUE_ENUM_TYPE major,\n \t\t\t\t    const CGEN_INSN *insn)\n@@ -663,10 +663,10 @@ fr550_check_insn_major_constraints (FRV_VLIW *vliw,\n     default:\n       break;\n     }\n-  return TRUE; /* All OK.  */\n+  return true; /* All OK.  */\n }\n \n-static bfd_boolean\n+static bool\n fr500_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)\n {\n   /* TODO: A table might be faster for some of the more complex instances\n@@ -686,7 +686,7 @@ fr500_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n     case FR500_MAJOR_F_4:\n     case FR500_MAJOR_F_8:\n     case FR500_MAJOR_M_8:\n-      return TRUE; /* OK */\n+      return true; /* OK */\n     case FR500_MAJOR_I_2:\n       /* Cannot coexist with I-3 insn.  */\n       return ! find_major_in_vliw (vliw, FR500_MAJOR_I_3);\n@@ -770,10 +770,10 @@ fr500_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE ma\n       abort ();\n       break;\n     }\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n check_insn_major_constraints (FRV_VLIW *vliw,\n \t\t\t      CGEN_ATTR_VALUE_ENUM_TYPE major,\n \t\t\t      const CGEN_INSN *insn)\n@@ -873,12 +873,12 @@ frv_vliw_add_insn (FRV_VLIW *vliw, const CGEN_INSN *insn)\n   return 1;\n }\n \n-bfd_boolean\n+bool\n spr_valid (long regno)\n {\n-  if (regno < 0)     return FALSE;\n-  if (regno <= 4095) return TRUE;\n-  return FALSE;\n+  if (regno < 0)     return false;\n+  if (regno <= 4095) return true;\n+  return false;\n }\n /* -- */\n /* The hash functions are recorded here to help keep assembler code out of"
    },
    {
      "sha": "14fdc1238dc3c1c901f52ff881f0e00e91822e2f",
      "filename": "opcodes/frv-opc.h",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/frv-opc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/frv-opc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/frv-opc.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -58,15 +58,15 @@ typedef struct\n   const CGEN_INSN *      insn[FRV_VLIW_SIZE];\n } FRV_VLIW;\n \n-bfd_boolean frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n-bfd_boolean frv_is_float_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n-bfd_boolean frv_is_media_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n-bfd_boolean frv_is_branch_insn  (const CGEN_INSN *);\n-bfd_boolean frv_is_float_insn   (const CGEN_INSN *);\n-bfd_boolean frv_is_media_insn   (const CGEN_INSN *);\n-void        frv_vliw_reset      (FRV_VLIW *, unsigned long, unsigned long);\n-int         frv_vliw_add_insn   (FRV_VLIW *, const CGEN_INSN *);\n-bfd_boolean spr_valid           (long);\n+bool frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n+bool frv_is_float_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n+bool frv_is_media_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);\n+bool frv_is_branch_insn  (const CGEN_INSN *);\n+bool frv_is_float_insn   (const CGEN_INSN *);\n+bool frv_is_media_insn   (const CGEN_INSN *);\n+void frv_vliw_reset      (FRV_VLIW *, unsigned long, unsigned long);\n+int  frv_vliw_add_insn   (FRV_VLIW *, const CGEN_INSN *);\n+bool spr_valid           (long);\n /* -- */\n /* Enum declaration for frv instruction types.  */\n typedef enum cgen_insn_type {"
    },
    {
      "sha": "a69b89c4e19a5c872cf9b5817cce9edaca2885ab",
      "filename": "opcodes/h8300-dis.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/h8300-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/h8300-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/h8300-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -317,7 +317,7 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n   int dispregno[3] = { 0, 0, 0 };\n   int cst[3] = { 0, 0, 0 };\n   int cstlen[3] = { 0, 0, 0 };\n-  static bfd_boolean init = 0;\n+  static bool init = 0;\n   const struct h8_instruction *qi;\n   char const **pregnames = mach != 0 ? lregnames : wregnames;\n   int status;"
    },
    {
      "sha": "21e40850544405a32a1dea4d1625917a79d281a8",
      "filename": "opcodes/i386-dis.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/i386-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/i386-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/i386-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -8599,7 +8599,7 @@ static const struct dis386 rm_table[][8] = {\n #define NOTRACK_PREFIX\t(0x3e | 0x100)\n \n /* Remember if the current op is a jump instruction.  */\n-static bfd_boolean op_is_jump = FALSE;\n+static bool op_is_jump = false;\n \n static int\n ckprefix (void)\n@@ -9708,7 +9708,7 @@ print_insn (bfd_vma pc, disassemble_info *info)\n     }\n \n   /* Reset jump operation indicator.  */\n-  op_is_jump = FALSE;\n+  op_is_jump = false;\n \n   {\n     int jump_detection = 0;\n@@ -9730,7 +9730,7 @@ print_insn (bfd_vma pc, disassemble_info *info)\n     /* Determine if this is a jump or branch.  */\n     if ((jump_detection & 0x3) == 0x3)\n       {\n-\top_is_jump = TRUE;\n+\top_is_jump = true;\n \tif (jump_detection & 0x4)\n \t  the_info->insn_type = dis_condbranch;\n \telse\n@@ -11548,7 +11548,7 @@ OP_E_memory (int bytemode, int sizeflag)\n \t\t\t || bytemode == v_bndmk_mode\n \t\t\t || bytemode == bnd_mode\n \t\t\t || bytemode == bnd_swap_mode);\n-      bfd_boolean check_gather = FALSE;\n+      bool check_gather = false;\n       const char **indexes64 = names64;\n       const char **indexes32 = names32;\n "
    },
    {
      "sha": "fe2536d870e44d5e38137620a03904da2415a920",
      "filename": "opcodes/m68k-dis.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/m68k-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/m68k-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/m68k-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -409,7 +409,7 @@ fetch_arg (unsigned char *buffer,\n    A similar case exists for the movem instructions where the register\n    mask is interpreted differently for different EAs.  */\n \n-static bfd_boolean\n+static bool\n m68k_valid_ea (char code, int val)\n {\n   int mode, mask;"
    },
    {
      "sha": "ca5be994dd89638ee188d89f4b5e7948ef165fef",
      "filename": "opcodes/metag-dis.c",
      "status": "modified",
      "additions": 79,
      "deletions": 83,
      "changes": 162,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/metag-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/metag-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/metag-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -641,7 +641,7 @@ cache_addr_str (char *buf, unsigned int buf_size, unsigned int insn_word,\n static void\n lookup_reg_list (char *reg_buf, size_t buf_len, unsigned int reg_unit,\n \t\t unsigned int reg_no, unsigned int rmask,\n-\t\t bfd_boolean is_fpu_64bit)\n+\t\t bool is_fpu_64bit)\n {\n   const char *regs[MGET_MSET_MAX_REGS];\n   size_t used_regs = 1, i, remaining;\n@@ -727,7 +727,7 @@ print_get_set (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t       const insn_template *template,\n \t       disassemble_info *outf)\n {\n-  bfd_boolean is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n+  bool is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n   char buf[OPERAND_WIDTH];\n   char addr_buf[ADDR_WIDTH];\n   unsigned int reg_unit, reg_no;\n@@ -776,8 +776,8 @@ print_get_set_ext (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t   const insn_template *template,\n \t\t   disassemble_info *outf)\n {\n-  bfd_boolean is_get = MINOR_OPCODE (template->meta_opcode) == GET_EXT_MINOR;\n-  bfd_boolean is_mov = MINOR_OPCODE (template->meta_opcode) == MOV_EXT_MINOR;\n+  bool is_get = MINOR_OPCODE (template->meta_opcode) == GET_EXT_MINOR;\n+  bool is_mov = MINOR_OPCODE (template->meta_opcode) == MOV_EXT_MINOR;\n   char buf[OPERAND_WIDTH];\n   char addr_buf[ADDR_WIDTH];\n   unsigned int reg_unit, reg_no;\n@@ -815,9 +815,9 @@ print_mget_mset (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t const insn_template *template,\n \t\t disassemble_info *outf)\n {\n-  bfd_boolean is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n-  bfd_boolean is_fpu = (MINOR_OPCODE (template->meta_opcode) & 0x6) == 0x6;\n-  bfd_boolean is_64bit = (MINOR_OPCODE (template->meta_opcode) & 0x1) == 0x1;\n+  bool is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n+  bool is_fpu = (MINOR_OPCODE (template->meta_opcode) & 0x6) == 0x6;\n+  bool is_64bit = (MINOR_OPCODE (template->meta_opcode) & 0x1) == 0x1;\n   char buf[OPERAND_WIDTH];\n   char addr_buf[ADDR_WIDTH];\n   char reg_buf[REG_WIDTH];\n@@ -1185,7 +1185,7 @@ print_alu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   unsigned int unit_bit = (insn_word >> 24) & 0x1;\n   unsigned int ca = (insn_word >> 5) & 0x1;\n   unsigned int se = (insn_word >> 1) & 0x1;\n-  bfd_boolean is_quickrot = template->arg_type & GP_ARGS_QR;\n+  bool is_quickrot = template->arg_type & GP_ARGS_QR;\n   enum metag_unit base_unit;\n   enum metag_unit dest_unit;\n   const char *dest_reg;\n@@ -1719,7 +1719,7 @@ print_fmov (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   unsigned int p = (insn_word >> 6) & 0x1;\n   unsigned int d = (insn_word >> 5) & 0x1;\n   unsigned int cc = (insn_word >> 1) & CC_MASK;\n-  bfd_boolean show_cond = cc != COND_A && cc != COND_NV;\n+  bool show_cond = cc != COND_A && cc != COND_NV;\n   const char *dest_reg;\n   const char *src_reg;\n   const char *cc_flags;\n@@ -1769,8 +1769,8 @@ print_fmmov (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   char buf[OPERAND_WIDTH * 2];\n   char data_buf[REG_WIDTH];\n   char fpu_buf[REG_WIDTH];\n-  bfd_boolean to_fpu = MAJOR_OPCODE (insn_word) == OPC_GET;\n-  bfd_boolean is_mmovl = MINOR_OPCODE (insn_word) & 0x1;\n+  bool to_fpu = MAJOR_OPCODE (insn_word) == OPC_GET;\n+  bool is_mmovl = MINOR_OPCODE (insn_word) & 0x1;\n   unsigned int rmask = (insn_word >> 7) & RMASK_MASK;\n   unsigned int fpu_no, data_no, data_unit;\n \n@@ -1782,7 +1782,7 @@ print_fmmov (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   else\n     data_unit = UNIT_D0;\n \n-  lookup_reg_list (data_buf, REG_WIDTH, data_unit, data_no, rmask, FALSE);\n+  lookup_reg_list (data_buf, REG_WIDTH, data_unit, data_no, rmask, false);\n   lookup_reg_list (fpu_buf, REG_WIDTH, UNIT_FX, fpu_no,\n \t\t   convert_fx_rmask (rmask), is_mmovl);\n \n@@ -1921,7 +1921,7 @@ print_fcmp (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   unsigned int d = (insn_word >> 5) & 0x1;\n   unsigned int q = (insn_word >> 7) & 0x1;\n   unsigned int cc = (insn_word >> 1) & CC_MASK;\n-  bfd_boolean show_cond = cc != COND_A && cc != COND_NV;\n+  bool show_cond = cc != COND_A && cc != COND_NV;\n   const char *dest_reg;\n   const char *src_reg;\n   const char *cc_flags;\n@@ -1958,7 +1958,7 @@ print_fminmax (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   unsigned int d = (insn_word >> 5) & 0x1;\n   unsigned int src1_no, src2_no, dest_no;\n   unsigned int cc = (insn_word >> 1) & CC_MASK;\n-  bfd_boolean show_cond = cc != COND_A && cc != COND_NV;\n+  bool show_cond = cc != COND_A && cc != COND_NV;\n   const char *dest_reg;\n   const char *src1_reg;\n   const char *src2_reg;\n@@ -1994,7 +1994,7 @@ print_fconv (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   unsigned int z = (insn_word >> 12) & 0x1;\n   unsigned int src_no, dest_no;\n   unsigned int cc = (insn_word >> 1) & CC_MASK;\n-  bfd_boolean show_cond = cc != COND_A && cc != COND_NV;\n+  bool show_cond = cc != COND_A && cc != COND_NV;\n   const char *dest_reg;\n   const char *src_reg;\n   const char *cc_flags;\n@@ -2027,7 +2027,7 @@ print_fconvx (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   unsigned int xl = (insn_word >> 7) & 0x1;\n   unsigned int src_no, dest_no, fraction_bits;\n   unsigned int cc = (insn_word >> 1) & CC_MASK;\n-  bfd_boolean show_cond = cc != COND_A && cc != COND_NV;\n+  bool show_cond = cc != COND_A && cc != COND_NV;\n   const char *dest_reg;\n   const char *src_reg;\n   const char *cc_flags;\n@@ -2067,7 +2067,7 @@ print_fbarith (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   unsigned int d = (insn_word >> 5) & 0x1;\n   unsigned int src1_no, src2_no, dest_no;\n   unsigned int cc = (insn_word >> 1) & CC_MASK;\n-  bfd_boolean show_cond = cc != COND_A && cc != COND_NV;\n+  bool show_cond = cc != COND_A && cc != COND_NV;\n   const char *dest_reg;\n   const char *src1_reg;\n   const char *src2_reg;\n@@ -2099,20 +2099,17 @@ print_fearith (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n {\n   char buf[OPERAND_WIDTH];\n   char prefix_buf[10];\n-  bfd_boolean is_muz = (MINOR_OPCODE (insn_word) == 0x6 &&\n-\t\t\t((insn_word >> 4) & 0x1));\n-  bfd_boolean is_mac = (MINOR_OPCODE (insn_word) == 0x6 &&\n-\t\t\t(insn_word & 0x1f) == 0);\n-  bfd_boolean is_maw = (MINOR_OPCODE (insn_word) == 0x6 &&\n-\t\t\t((insn_word >> 3) & 0x1));\n+  bool is_muz = MINOR_OPCODE (insn_word) == 0x6 && ((insn_word >> 4) & 0x1);\n+  bool is_mac = MINOR_OPCODE (insn_word) == 0x6 && (insn_word & 0x1f) == 0;\n+  bool is_maw = MINOR_OPCODE (insn_word) == 0x6 && ((insn_word >> 3) & 0x1);\n   unsigned int o3o = insn_word & 0x1;\n   unsigned int q = is_muz && ((insn_word >> 1) & 0x1);\n   unsigned int n = (insn_word >> 7) & 0x1;\n   unsigned int p = (insn_word >> 6) & 0x1;\n   unsigned int d = (insn_word >> 5) & 0x1;\n   unsigned int cc = (insn_word >> 1) & CC_MASK;\n-  bfd_boolean show_cond = (MINOR_OPCODE (insn_word) == 0x5 && cc != COND_A &&\n-\t\t\t   cc != COND_NV);\n+  bool show_cond = (MINOR_OPCODE (insn_word) == 0x5 && cc != COND_A\n+\t\t    && cc != COND_NV);\n   unsigned int src1_no, src2_no, dest_no;\n   const char *dest_reg;\n   const char *src1_reg;\n@@ -2208,7 +2205,7 @@ print_fget_set_acf (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t    const insn_template *template,\n \t\t    disassemble_info *outf)\n {\n-  bfd_boolean is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n+  bool is_get = MAJOR_OPCODE (template->meta_opcode) == OPC_GET;\n   char buf[OPERAND_WIDTH];\n   char addr_buf[ADDR_WIDTH];\n   unsigned int part;\n@@ -2273,7 +2270,7 @@ lookup_dsp_name (unsigned int num, unsigned int unit)\n \n /* Return the name of the DSP RAM register for NUM and UNIT.  */\n static const char *\n-lookup_dspram_name (unsigned int num, unsigned int unit, bfd_boolean load)\n+lookup_dspram_name (unsigned int num, unsigned int unit, bool load)\n {\n   size_t i, nentries;\n \n@@ -2293,7 +2290,7 @@ lookup_dspram_name (unsigned int num, unsigned int unit, bfd_boolean load)\n    number in a DSP instruction. SOURCE indicates whether this\n    register is a source or destination operand.  */\n static const char *\n-lookup_any_reg_name (unsigned int unit, unsigned int num, bfd_boolean source)\n+lookup_any_reg_name (unsigned int unit, unsigned int num, bool source)\n {\n   /* A register with the top bit set (5th bit) indicates a DSPRAM\n      register.  */\n@@ -2322,15 +2319,15 @@ print_dget_set (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\tconst insn_template *template,\n \t\tdisassemble_info *outf)\n {\n-  bfd_boolean is_get = (template->meta_opcode & 0x100);\n+  bool is_get = (template->meta_opcode & 0x100);\n   char buf[OPERAND_WIDTH];\n   char addr_buf[ADDR_WIDTH];\n   char prefix[DSP_PREFIX_WIDTH];\n   unsigned int part;\n   const char *reg_name[2];\n-  bfd_boolean is_high = FALSE;\n-  bfd_boolean is_dual = (insn_word & 0x4);\n-  bfd_boolean is_template = (insn_word & 0x2);\n+  bool is_high = false;\n+  bool is_dual = (insn_word & 0x4);\n+  bool is_template = (insn_word & 0x2);\n   const char *base_reg = \"?\";\n   unsigned int addr_unit, base_no, unit;\n \n@@ -2438,8 +2435,8 @@ print_dtemplate (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n   char buf[OPERAND_WIDTH];\n   char prefix[DSP_PREFIX_WIDTH];\n   unsigned int offset[4];\n-  bfd_boolean is_half = (MINOR_OPCODE (insn_word) == 0x5);\n-  bfd_boolean daop_only = (MINOR_OPCODE (insn_word) == 0x3);\n+  bool is_half = (MINOR_OPCODE (insn_word) == 0x5);\n+  bool daop_only = (MINOR_OPCODE (insn_word) == 0x3);\n \n   offset[0] = ((insn_word >> 19) & REG_MASK);\n   offset[1] = ((insn_word >> 14) & REG_MASK);\n@@ -2463,8 +2460,8 @@ print_dtemplate (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n static void\n decode_template_definition(unsigned int insn_word, char *buf, size_t len)\n {\n-  bfd_boolean load = ((insn_word >> 13) & 0x1);\n-  bfd_boolean dspram = (((insn_word >> 17) & 0x3) == 0x3);\n+  bool load = ((insn_word >> 13) & 0x1);\n+  bool dspram = (((insn_word >> 17) & 0x3) == 0x3);\n   const char *template[1];\n   unsigned int tidx = ((insn_word >> 9) & TEMPLATE_REGS_MASK);\n   enum metag_unit au, ram_unit;\n@@ -2487,7 +2484,7 @@ decode_template_definition(unsigned int insn_word, char *buf, size_t len)\n     }\n   else\n     {\n-      bfd_boolean im = (((insn_word >> 18) & 0x1) != 0);\n+      bool im = (((insn_word >> 18) & 0x1) != 0);\n \n       au = (((insn_word >> 23) & 0x1) == 0) ? UNIT_A0 : UNIT_A1;\n       addr_reg_nums[0] = ((insn_word >> 19) & DSP_REG_MASK);\n@@ -2535,36 +2532,36 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t    const insn_template *template,\n \t    disassemble_info *outf)\n {\n-  bfd_boolean is_dual = FALSE;\n+  bool is_dual = false;\n   unsigned int data_unit = (((insn_word >> 24) & 0x1) ? UNIT_D1 : UNIT_D0);\n   const char *reg_names[3];\n   unsigned int reg_nums[3];\n-  bfd_boolean ac = ((insn_word >> 7) & 0x1);\n+  bool ac = ((insn_word >> 7) & 0x1);\n   char buf[OPERAND_WIDTH];\n   char prefix[DSP_PREFIX_WIDTH];\n   size_t len;\n-  bfd_boolean is_mod = FALSE;\n-  bfd_boolean is_overflow = FALSE;\n+  bool is_mod = false;\n+  bool is_overflow = false;\n   unsigned int reg_brackets[3];\n-  bfd_boolean is_w_mx = FALSE;\n-  bfd_boolean is_b_mx = FALSE;\n-  bfd_boolean imm = FALSE;\n-  bfd_boolean is_quickrot64 = FALSE;\n-  bfd_boolean conditional = FALSE;\n+  bool is_w_mx = false;\n+  bool is_b_mx = false;\n+  bool imm = false;\n+  bool is_quickrot64 = false;\n+  bool conditional = false;\n   const char *cc_flags = NULL;\n-  bfd_boolean is_unsigned = FALSE;\n+  bool is_unsigned = false;\n \n   memset (reg_brackets, 0, sizeof (reg_brackets));\n \n   if (template->arg_type & DSP_ARGS_1)\n     {\n-      bfd_boolean is_template = FALSE;\n+      bool is_template = false;\n       const char *addr_reg = NULL;\n-      bfd_boolean qr = FALSE;\n-      bfd_boolean is_acc_add = FALSE;\n-      bfd_boolean is_acc_sub = FALSE;\n-      bfd_boolean is_acc_zero = FALSE;\n-      bfd_boolean is_split8 = (template->arg_type & DSP_ARGS_SPLIT8);\n+      bool qr = false;\n+      bool is_acc_add = false;\n+      bool is_acc_sub = false;\n+      bool is_acc_zero = false;\n+      bool is_split8 = (template->arg_type & DSP_ARGS_SPLIT8);\n \n       /* Read DU bit.  */\n       data_unit = ((insn_word >> 24) & 0x1) ? UNIT_D1 : UNIT_D0;\n@@ -2638,11 +2635,11 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t  is_acc_sub = ((insn_word & 0x84) == 0x84);\n \t\t}\n \t      else\n-\t\treg_names[0] = lookup_any_reg_name (data_unit, 0, FALSE);\n+\t\treg_names[0] = lookup_any_reg_name (data_unit, 0, false);\n \n \t      /* These are dummy arguments anyway so the register\n \t\t number does not matter.  */\n-\t      reg_names[1] = lookup_any_reg_name (data_unit, 0, TRUE);\n+\t      reg_names[1] = lookup_any_reg_name (data_unit, 0, true);\n \n \t      /* De.r,Dx.r,De.r|ACe.r */\n \t      if ((template->arg_type & DSP_ARGS_ACC2) &&\n@@ -2680,10 +2677,10 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t      aunit = (data_unit == UNIT_D0) ? UNIT_A0 : UNIT_A1;\n \t\t      addr_reg = lookup_reg_name (aunit, reg_no + 2);\n \n-\t\t      qr = TRUE;\n+\t\t      qr = true;\n \t\t    }\n \n-\t\t  reg_names[2] = lookup_any_reg_name (data_unit, 0, TRUE);\n+\t\t  reg_names[2] = lookup_any_reg_name (data_unit, 0, true);\n \t\t}\n \t    }\n \n@@ -2751,7 +2748,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t    }\n \t  else\n \t    {\n-\t      bfd_boolean o2r = (insn_word & 0x1);\n+\t      bool o2r = (insn_word & 0x1);\n \n \t      /* De.r|ACe.r,Dx.r,De.r */\n \t      if ((template->arg_type & DSP_ARGS_DACC) &&\n@@ -2773,14 +2770,14 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t      else\n \t\t{\n \t\t  reg_names[0] = lookup_any_reg_name (data_unit,\n-\t\t\t\t\t\t      reg_nums[0], FALSE);\n+\t\t\t\t\t\t      reg_nums[0], false);\n \t\t  if (reg_nums[0] > 15)\n \t\t    reg_brackets[0] = 1;\n \t\t}\n \n \t      if (imm)\n \t\t{\n-\t\t  reg_names[1] = lookup_any_reg_name (data_unit, reg_nums[0], TRUE);\n+\t\t  reg_names[1] = lookup_any_reg_name (data_unit, reg_nums[0], true);\n \n \t\t  if (reg_brackets[0])\n \t\t    reg_brackets[1] = 1;\n@@ -2793,7 +2790,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t    }\n \t\t  else\n \t\t  {\n-\t\t    reg_names[1] = lookup_any_reg_name (data_unit, reg_nums[1], TRUE);\n+\t\t    reg_names[1] = lookup_any_reg_name (data_unit, reg_nums[1], true);\n \n \t\t    if (reg_nums[1] > 15)\n \t\t      reg_brackets[1] = 1;\n@@ -2826,7 +2823,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t      aunit = (data_unit == UNIT_D0) ? UNIT_A0 : UNIT_A1;\n \t\t      addr_reg = lookup_reg_name (aunit, reg_no + 2);\n \n-\t\t      qr = TRUE;\n+\t\t      qr = true;\n \t\t    }\n \n \t\t  if (o2r)\n@@ -2843,7 +2840,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t      else\n \t\t\t{\n \t\t\t  reg_names[2] = lookup_any_reg_name (data_unit,\n-\t\t\t\t\t\t\t      reg_nums[2], TRUE);\n+\t\t\t\t\t\t\t      reg_nums[2], true);\n \t\t\t  if (reg_nums[2] > 15)\n \t\t\t    reg_brackets[2] = 1;\n \t\t\t}\n@@ -2919,14 +2916,13 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n     }\n   else if (template->arg_type & DSP_ARGS_2) /* Group 2.  */\n     {\n-      bfd_boolean is_template;\n-      bfd_boolean o2r = FALSE;\n+      bool is_template;\n+      bool o2r = false;\n       int major = MAJOR_OPCODE (template->meta_opcode);\n-      bfd_boolean is_neg_or_mov = (major == OPC_ADD || major == OPC_SUB);\n-      bfd_boolean is_cmp_tst = ((major == OPC_CMP) &&\n-\t\t\t\t((insn_word & 0x0000002c) == 0));\n-      bfd_boolean is_fpu_mov = template->insn_type == INSN_DSP_FPU;\n-      bfd_boolean to_fpu = (template->meta_opcode >> 7) & 0x1;\n+      bool is_neg_or_mov = (major == OPC_ADD || major == OPC_SUB);\n+      bool is_cmp_tst = major == OPC_CMP && (insn_word & 0x0000002c) == 0;\n+      bool is_fpu_mov = template->insn_type == INSN_DSP_FPU;\n+      bool to_fpu = (template->meta_opcode >> 7) & 0x1;\n \n       if (major == OPC_9)\n \timm = (insn_word & 0x2);\n@@ -3014,7 +3010,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t}\n \t      else\n \t\t{\n-\t\t  reg_names[0] = lookup_any_reg_name (data_unit, reg_nums[0], TRUE);\n+\t\t  reg_names[0] = lookup_any_reg_name (data_unit, reg_nums[0], true);\n \t\t  if (reg_nums[0] > 15)\n \t\t    reg_brackets[0] = 1;\n \t\t}\n@@ -3096,7 +3092,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t      else\n \t\t\t{\n \t\t\t  reg_names[1] = lookup_any_reg_name (data_unit,\n-\t\t\t\t\t\t\t      reg_nums[1], TRUE);\n+\t\t\t\t\t\t\t      reg_nums[1], true);\n \t\t\t  if (reg_nums[1] > 15)\n \t\t\t    reg_brackets[1] = 1;\n \t\t\t}\n@@ -3122,13 +3118,13 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n     {\n       /* If both the C and CA bits are set, then the Rd register can\n \t be in any unit. Figure out which unit from the Ud field.  */\n-      bfd_boolean all_units = (((insn_word) & 0x04000020) == 0x04000020);\n+      bool all_units = (((insn_word) & 0x04000020) == 0x04000020);\n       enum metag_unit ud_unit = ((insn_word >> 1) & UNIT_MASK);\n       enum metag_unit ram_unit, acc_unit;\n-      bfd_boolean round = FALSE;\n-      bfd_boolean clamp9 = FALSE;\n-      bfd_boolean clamp8 = FALSE;\n-      bfd_boolean is_template = ((insn_word & 0x04000002) == 0x2);\n+      bool round = false;\n+      bool clamp9 = false;\n+      bool clamp8 = false;\n+      bool is_template = ((insn_word & 0x04000002) == 0x2);\n \n       imm = ((insn_word >> 25) & 0x1);\n       ac = (insn_word & 0x1);\n@@ -3165,7 +3161,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t    reg_names[0] = lookup_reg_name (data_unit, reg_nums[0]);\n \t  else\n \t    {\n-\t      reg_names[0] = lookup_any_reg_name (data_unit, reg_nums[0], FALSE);\n+\t      reg_names[0] = lookup_any_reg_name (data_unit, reg_nums[0], false);\n \t      if (reg_nums[0] > 15)\n \t\treg_brackets[0] = 1;\n \t    }\n@@ -3177,7 +3173,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t}\n       else\n \t{\n-\t  reg_names[1] = lookup_any_reg_name (data_unit, reg_nums[1], TRUE);\n+\t  reg_names[1] = lookup_any_reg_name (data_unit, reg_nums[1], true);\n \t  if (reg_nums[1] > 15)\n \t    reg_brackets[1] = 1;\n \t}\n@@ -3195,15 +3191,15 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t{\n \t  reg_nums[2] = ((insn_word >> 9) & REG_MASK);\n \n-\t  reg_names[2] = lookup_any_reg_name (data_unit, reg_nums[2], TRUE);\n+\t  reg_names[2] = lookup_any_reg_name (data_unit, reg_nums[2], true);\n \n \t  if (reg_nums[2] > 15)\n \t\t  reg_brackets[2] = 1;\n \n \t  if (is_template)\n \t    {\n-\t      bfd_boolean load = ((insn_word >> 13) & 0x1);\n-\t      bfd_boolean dspram = (((insn_word >> 17) & 0x3) == 0x3);\n+\t      bool load = ((insn_word >> 13) & 0x1);\n+\t      bool dspram = (((insn_word >> 17) & 0x3) == 0x3);\n \t      const char *tname[1];\n \t      unsigned int tidx = ((insn_word >> 9) & TEMPLATE_REGS_MASK);\n \t      enum metag_unit au;\n@@ -3235,7 +3231,7 @@ print_dalu (unsigned int insn_word, bfd_vma pc ATTRIBUTE_UNUSED,\n \t\t}\n \t      else\n \t\t{\n-\t\t  bfd_boolean im = (((insn_word >> 18) & 0x1) != 0);\n+\t\t  bool im = (((insn_word >> 18) & 0x1) != 0);\n \n \t\t  au = (((insn_word >> 23) & 0x1) == 0) ? UNIT_A0 : UNIT_A1;\n \t\t  addr_reg_nums[0] = ((insn_word >> 19) & DSP_REG_MASK);"
    },
    {
      "sha": "aa75c4cc1fd12e01e8078e30f037ac2a4b8e47e3",
      "filename": "opcodes/microblaze-dis.c",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/microblaze-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/microblaze-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/microblaze-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -221,16 +221,16 @@ read_insn_microblaze (bfd_vma memaddr,\n int\n print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n {\n-  fprintf_ftype       print_func = info->fprintf_func;\n-  void *              stream = info->stream;\n-  unsigned long       inst, prev_inst;\n-  struct op_code_struct * op, *pop;\n-  int                 immval = 0;\n-  bfd_boolean         immfound = FALSE;\n-  static bfd_vma      prev_insn_addr = -1; /* Init the prev insn addr.  */\n-  static int          prev_insn_vma = -1;  /* Init the prev insn vma.  */\n-  int                 curr_insn_vma = info->buffer_vma;\n-  struct string_buf   buf;\n+  fprintf_ftype print_func = info->fprintf_func;\n+  void *stream = info->stream;\n+  unsigned long inst, prev_inst;\n+  struct op_code_struct *op, *pop;\n+  int immval = 0;\n+  bool immfound = false;\n+  static bfd_vma prev_insn_addr = -1;\t/* Init the prev insn addr.  */\n+  static int prev_insn_vma = -1;\t/* Init the prev insn vma.  */\n+  int curr_insn_vma = info->buffer_vma;\n+  struct string_buf buf;\n \n   buf.which = 0;\n   info->bytes_per_chunk = 4;\n@@ -249,12 +249,12 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n \t  if (pop->instr == imm)\n \t    {\n \t      immval = (get_int_field_imm (prev_inst) << 16) & 0xffff0000;\n-\t      immfound = TRUE;\n+\t      immfound = true;\n \t    }\n \t  else\n \t    {\n \t      immval = 0;\n-\t      immfound = FALSE;\n+\t      immfound = false;\n \t    }\n \t}\n     }\n@@ -448,12 +448,12 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)\n \n enum microblaze_instr\n get_insn_microblaze (long inst,\n-  \t\t     bfd_boolean *isunsignedimm,\n+  \t\t     bool *isunsignedimm,\n   \t\t     enum microblaze_instr_type *insn_type,\n   \t\t     short *delay_slots)\n {\n   struct op_code_struct * op;\n-  *isunsignedimm = FALSE;\n+  *isunsignedimm = false;\n \n   /* Just a linear search of the table.  */\n   for (op = opcodes; op->name != 0; op ++)\n@@ -475,7 +475,7 @@ enum microblaze_instr\n microblaze_decode_insn (long insn, int *rd, int *ra, int *rb, int *immed)\n {\n   enum microblaze_instr op;\n-  bfd_boolean t1;\n+  bool t1;\n   enum microblaze_instr_type t2;\n   short t3;\n \n@@ -489,40 +489,40 @@ microblaze_decode_insn (long insn, int *rd, int *ra, int *rb, int *immed)\n }\n \n unsigned long\n-microblaze_get_target_address (long inst, bfd_boolean immfound, int immval,\n+microblaze_get_target_address (long inst, bool immfound, int immval,\n \t\t\t       long pcval, long r1val, long r2val,\n-\t\t\t       bfd_boolean *targetvalid,\n-\t\t\t       bfd_boolean *unconditionalbranch)\n+\t\t\t       bool *targetvalid,\n+\t\t\t       bool *unconditionalbranch)\n {\n   struct op_code_struct * op;\n   long targetaddr = 0;\n \n-  *unconditionalbranch = FALSE;\n+  *unconditionalbranch = false;\n   /* Just a linear search of the table.  */\n   for (op = opcodes; op->name != 0; op ++)\n     if (op->bit_sequence == (inst & op->opcode_mask))\n       break;\n \n   if (op->name == 0)\n     {\n-      *targetvalid = FALSE;\n+      *targetvalid = false;\n     }\n   else if (op->instr_type == branch_inst)\n     {\n       switch (op->inst_type)\n \t{\n         case INST_TYPE_R2:\n-          *unconditionalbranch = TRUE;\n+          *unconditionalbranch = true;\n         /* Fall through.  */\n         case INST_TYPE_RD_R2:\n         case INST_TYPE_R1_R2:\n           targetaddr = r2val;\n-          *targetvalid = TRUE;\n+          *targetvalid = true;\n           if (op->inst_offset_type == INST_PC_OFFSET)\n \t    targetaddr += pcval;\n           break;\n         case INST_TYPE_IMM:\n-          *unconditionalbranch = TRUE;\n+          *unconditionalbranch = true;\n         /* Fall through.  */\n         case INST_TYPE_RD_IMM:\n         case INST_TYPE_R1_IMM:\n@@ -539,10 +539,10 @@ microblaze_get_target_address (long inst, bfd_boolean immfound, int immval,\n             }\n           if (op->inst_offset_type == INST_PC_OFFSET)\n \t    targetaddr += pcval;\n-          *targetvalid = TRUE;\n+          *targetvalid = true;\n           break;\n \tdefault:\n-\t  *targetvalid = FALSE;\n+\t  *targetvalid = false;\n \t  break;\n         }\n     }\n@@ -560,9 +560,9 @@ microblaze_get_target_address (long inst, bfd_boolean immfound, int immval,\n \t    targetaddr |= 0xFFFF0000;\n \t}\n       targetaddr += r1val;\n-      *targetvalid = TRUE;\n+      *targetvalid = true;\n     }\n   else\n-    *targetvalid = FALSE;\n+    *targetvalid = false;\n   return targetaddr;\n }"
    },
    {
      "sha": "584cb3d1b864aa2f40338e263f8e5a96c0bdf020",
      "filename": "opcodes/microblaze-dis.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/microblaze-dis.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/microblaze-dis.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/microblaze-dis.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -28,10 +28,10 @@ extern \"C\" {\n \n extern enum microblaze_instr microblaze_decode_insn (long, int *, int *,\n \t\t\t\t\t\t     int *, int *);\n-extern unsigned long microblaze_get_target_address (long, bfd_boolean, int,\n-\t\t\t       long, long, long, bfd_boolean *, bfd_boolean *);\n-\n-extern enum microblaze_instr get_insn_microblaze (long, bfd_boolean *,\n+extern unsigned long microblaze_get_target_address (long, bool, int,\n+\t\t\t\t\t\t    long, long, long,\n+\t\t\t\t\t\t    bool *, bool *);\n+extern enum microblaze_instr get_insn_microblaze (long, bool *,\n \t\t\t\t\t\t  enum microblaze_instr_type *,\n   \t\t     \t\t\t\t  short *);\n "
    },
    {
      "sha": "6553c29ef438e5db87d4b0eef5e9c5b3542c5f41",
      "filename": "opcodes/micromips-opc.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/micromips-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/micromips-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/micromips-opc.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -72,25 +72,25 @@ decode_micromips_operand (const char *p)\n \tcase 'y': MAPPED_REG (0, 0, GP, reg_31_map);\n \tcase 'z': MAPPED_REG (0, 0, GP, reg_0_map);\n \n-\tcase 'A': INT_ADJ (7, 0, 63, 2, FALSE);\t /* (-64 .. 63) << 2 */\n-\tcase 'B': MAPPED_INT (3, 1, int_b_map, FALSE);\n-\tcase 'C': MAPPED_INT (4, 0, int_c_map, TRUE);\n+\tcase 'A': INT_ADJ (7, 0, 63, 2, false);\t /* (-64 .. 63) << 2 */\n+\tcase 'B': MAPPED_INT (3, 1, int_b_map, false);\n+\tcase 'C': MAPPED_INT (4, 0, int_c_map, true);\n \tcase 'D': BRANCH (10, 0, 1);\n \tcase 'E': BRANCH (7, 0, 1);\n \tcase 'F': HINT (4, 0);\n-\tcase 'G': INT_ADJ (4, 0, 14, 0, FALSE);\t /* (-1 .. 14) */\n-\tcase 'H': INT_ADJ (4, 0, 15, 1, FALSE);\t /* (0 .. 15) << 1 */\n-\tcase 'I': INT_ADJ (7, 0, 126, 0, FALSE); /* (-1 .. 126) */\n-\tcase 'J': INT_ADJ (4, 0, 15, 2, FALSE);\t /* (0 .. 15) << 2 */\n-\tcase 'L': INT_ADJ (4, 0, 15, 0, FALSE);\t /* (0 .. 15) */\n-\tcase 'M': INT_ADJ (3, 1, 8, 0, FALSE);   /* (1 .. 8) */\n+\tcase 'G': INT_ADJ (4, 0, 14, 0, false);\t /* (-1 .. 14) */\n+\tcase 'H': INT_ADJ (4, 0, 15, 1, false);\t /* (0 .. 15) << 1 */\n+\tcase 'I': INT_ADJ (7, 0, 126, 0, false); /* (-1 .. 126) */\n+\tcase 'J': INT_ADJ (4, 0, 15, 2, false);\t /* (0 .. 15) << 2 */\n+\tcase 'L': INT_ADJ (4, 0, 15, 0, false);\t /* (0 .. 15) */\n+\tcase 'M': INT_ADJ (3, 1, 8, 0, false);   /* (1 .. 8) */\n \tcase 'N': SPECIAL (2, 4, LWM_SWM_LIST);\n \tcase 'O': HINT (4, 0);\n-\tcase 'P': INT_ADJ (5, 0, 31, 2, FALSE);\t /* (0 .. 31) << 2 */\n-\tcase 'Q': INT_ADJ (23, 0, 4194303, 2, FALSE);\n+\tcase 'P': INT_ADJ (5, 0, 31, 2, false);\t /* (0 .. 31) << 2 */\n+\tcase 'Q': INT_ADJ (23, 0, 4194303, 2, false);\n \t  \t\t\t\t\t /* (-4194304 .. 4194303) */\n-\tcase 'U': INT_ADJ (5, 0, 31, 2, FALSE);\t /* (0 .. 31) << 2 */\n-\tcase 'W': INT_ADJ (6, 1, 63, 2, FALSE);\t /* (0 .. 63) << 2 */\n+\tcase 'U': INT_ADJ (5, 0, 31, 2, false);\t /* (0 .. 31) << 2 */\n+\tcase 'W': INT_ADJ (6, 1, 63, 2, false);\t /* (0 .. 63) << 2 */\n \tcase 'X': SINT (4, 1);\n \tcase 'Y': SPECIAL (9, 1, ADDIUSP_INT);\n \tcase 'Z': UINT (0, 0);\t\t\t /* 0 only */\n@@ -101,17 +101,17 @@ decode_micromips_operand (const char *p)\n       switch (p[1])\n \t{\n \tcase 'A': BIT (5, 6, 0);\t\t /* (0 .. 31) */\n-\tcase 'B': MSB (5, 11, 1, TRUE, 32);\t /* (1 .. 32), 32-bit op */\n-\tcase 'C': MSB (5, 11, 1, FALSE, 32);\t /* (1 .. 32), 32-bit op */\n+\tcase 'B': MSB (5, 11, 1, true, 32);\t /* (1 .. 32), 32-bit op */\n+\tcase 'C': MSB (5, 11, 1, false, 32);\t /* (1 .. 32), 32-bit op */\n \tcase 'E': BIT (5, 6, 32);\t\t /* (32 .. 63) */\n-\tcase 'F': MSB (5, 11, 33, TRUE, 64);\t /* (33 .. 64), 64-bit op */\n-\tcase 'G': MSB (5, 11, 33, FALSE, 64);\t /* (33 .. 64), 64-bit op */\n-\tcase 'H': MSB (5, 11, 1, FALSE, 64);\t /* (1 .. 32), 64-bit op */\n+\tcase 'F': MSB (5, 11, 33, true, 64);\t /* (33 .. 64), 64-bit op */\n+\tcase 'G': MSB (5, 11, 33, false, 64);\t /* (33 .. 64), 64-bit op */\n+\tcase 'H': MSB (5, 11, 1, false, 64);\t /* (1 .. 32), 64-bit op */\n \tcase 'J': HINT (10, 16);\n-\tcase 'T': INT_ADJ (10, 16, 511, 0, FALSE);\t/* (-512 .. 511) << 0 */\n-\tcase 'U': INT_ADJ (10, 16, 511, 1, FALSE);\t/* (-512 .. 511) << 1 */\n-\tcase 'V': INT_ADJ (10, 16, 511, 2, FALSE);\t/* (-512 .. 511) << 2 */\n-\tcase 'W': INT_ADJ (10, 16, 511, 3, FALSE);\t/* (-512 .. 511) << 3 */\n+\tcase 'T': INT_ADJ (10, 16, 511, 0, false);\t/* (-512 .. 511) << 0 */\n+\tcase 'U': INT_ADJ (10, 16, 511, 1, false);\t/* (-512 .. 511) << 1 */\n+\tcase 'V': INT_ADJ (10, 16, 511, 2, false);\t/* (-512 .. 511) << 2 */\n+\tcase 'W': INT_ADJ (10, 16, 511, 3, false);\t/* (-512 .. 511) << 3 */\n \n \tcase 'd': REG (5, 6, MSA);\n \tcase 'e': REG (5, 11, MSA);"
    },
    {
      "sha": "d51942035b58d92af2125c849b9e431bf3bb4556",
      "filename": "opcodes/mips-dis.c",
      "status": "modified",
      "additions": 38,
      "deletions": 38,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mips-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mips-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mips-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -920,7 +920,7 @@ set_default_mips_dis_options (struct disassemble_info *info)\n /* Parse an ASE disassembler option and set the corresponding global\n    ASE flag(s).  Return TRUE if successful, FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n parse_mips_ase_option (const char *option)\n {\n   if (startswith (option, \"msa\"))\n@@ -931,7 +931,7 @@ parse_mips_ase_option (const char *option)\n \t   || (mips_isa & INSN_ISA_MASK) == ISA_MIPS64R5\n \t   || (mips_isa & INSN_ISA_MASK) == ISA_MIPS64R6)\n \t  mips_ase |= ASE_MSA64;\n-      return TRUE;\n+      return true;\n     }\n \n   if (startswith (option, \"virt\"))\n@@ -942,47 +942,47 @@ parse_mips_ase_option (const char *option)\n \t  || mips_isa & ISA_MIPS64R5\n \t  || mips_isa & ISA_MIPS64R6)\n \tmips_ase |= ASE_VIRT64;\n-      return TRUE;\n+      return true;\n     }\n \n   if (startswith (option, \"xpa\"))\n     {\n       mips_ase |= ASE_XPA;\n-      return TRUE;\n+      return true;\n     }\n \n   if (startswith (option, \"ginv\"))\n     {\n       mips_ase |= ASE_GINV;\n-      return TRUE;\n+      return true;\n     }\n \n   if (startswith (option, \"loongson-mmi\"))\n     {\n       mips_ase |= ASE_LOONGSON_MMI;\n-      return TRUE;\n+      return true;\n     }\n \n   if (startswith (option, \"loongson-cam\"))\n     {\n       mips_ase |= ASE_LOONGSON_CAM;\n-      return TRUE;\n+      return true;\n     }\n   \n   /* Put here for match ext2 frist */\n   if (startswith (option, \"loongson-ext2\"))\n     {\n       mips_ase |= ASE_LOONGSON_EXT2;\n-      return TRUE;\n+      return true;\n     }\n \n   if (startswith (option, \"loongson-ext\"))\n     {\n       mips_ase |= ASE_LOONGSON_EXT;\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n static void\n@@ -1654,7 +1654,7 @@ print_insn_arg (struct disassemble_info *info,\n /* Validate the arguments for INSN, which is described by OPCODE.\n    Use DECODE_OPERAND to get the encoding of each operand.  */\n \n-static bfd_boolean\n+static bool\n validate_insn_args (const struct mips_opcode *opcode,\n \t\t    const struct mips_operand *(*decode_operand) (const char *),\n \t\t    unsigned int insn)\n@@ -1705,7 +1705,7 @@ validate_insn_args (const struct mips_opcode *opcode,\n \t\t    reg2 = uval >> 5;\n \n \t\t    if (reg1 != reg2 || reg1 == 0)\n-\t\t      return FALSE;\n+\t\t      return false;\n \t\t  }\n \t\tbreak;\n \n@@ -1716,20 +1716,20 @@ validate_insn_args (const struct mips_opcode *opcode,\n \t\t    prev_op = (const struct mips_check_prev_operand *) operand;\n \n \t\t    if (!prev_op->zero_ok && uval == 0)\n-\t\t      return FALSE;\n+\t\t      return false;\n \n \t\t    if (((prev_op->less_than_ok && uval < state.last_regno)\n \t\t\t|| (prev_op->greater_than_ok && uval > state.last_regno)\n \t\t\t|| (prev_op->equal_ok && uval == state.last_regno)))\n \t\t      break;\n \n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t  }\n \n \t\tcase OP_NON_ZERO_REG:\n \t\t  {\n \t\t    if (uval == 0)\n-\t\t      return FALSE;\n+\t\t      return false;\n \t\t  }\n \t\tbreak;\n \n@@ -1760,7 +1760,7 @@ validate_insn_args (const struct mips_opcode *opcode,\n \t    ++s;\n \t}\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Print the arguments for INSN, which is described by OPCODE.\n@@ -1890,7 +1890,7 @@ print_insn_mips (bfd_vma memaddr,\n   static const struct mips_opcode *mips_hash[OP_MASK_OP + 1];\n   const fprintf_ftype infprintf = info->fprintf_func;\n   const struct mips_opcode *op;\n-  static bfd_boolean init = 0;\n+  static bool init = 0;\n   void *is = info->stream;\n \n   /* Build a hash table to shorten the search time.  */\n@@ -2002,8 +2002,8 @@ print_mips16_insn_arg (struct disassemble_info *info,\n \t\t       struct mips_print_arg_state *state,\n \t\t       const struct mips_opcode *opcode,\n \t\t       char type, bfd_vma memaddr,\n-\t\t       unsigned insn, bfd_boolean use_extend,\n-\t\t       unsigned extend, bfd_boolean is_offset)\n+\t\t       unsigned insn, bool use_extend,\n+\t\t       unsigned extend, bool is_offset)\n {\n   const fprintf_ftype infprintf = info->fprintf_func;\n   void *is = info->stream;\n@@ -2024,7 +2024,7 @@ print_mips16_insn_arg (struct disassemble_info *info,\n       break;\n \n     default:\n-      operand = decode_mips16_operand (type, FALSE);\n+      operand = decode_mips16_operand (type, false);\n       if (!operand)\n \t{\n \t  /* xgettext:c-format */\n@@ -2061,7 +2061,7 @@ print_mips16_insn_arg (struct disassemble_info *info,\n       ext_size = 0;\n       if (use_extend)\n \t{\n-\t  ext_operand = decode_mips16_operand (type, TRUE);\n+\t  ext_operand = decode_mips16_operand (type, true);\n \t  if (ext_operand != operand\n \t      || (operand->type == OP_INT && operand->lsb == 0\n \t\t  && mips_opcode_32bit_p (opcode)))\n@@ -2134,16 +2134,16 @@ print_mips16_insn_arg (struct disassemble_info *info,\n    This word is data and depending on the value it may interfere with\n    disassembly of further PLT entries.  We make use of the fact PLT\n    symbols are marked BSF_SYNTHETIC.  */\n-static bfd_boolean\n+static bool\n is_mips16_plt_tail (struct disassemble_info *info, bfd_vma addr)\n {\n   if (info->symbols\n       && info->symbols[0]\n       && (info->symbols[0]->flags & BSF_SYNTHETIC)\n       && addr == bfd_asymbol_value (info->symbols[0]) + 12)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Whether none, a 32-bit or a 16-bit instruction match has been done.  */\n@@ -2166,8 +2166,8 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)\n   const struct mips_opcode *op, *opend;\n   struct mips_print_arg_state state;\n   void *is = info->stream;\n-  bfd_boolean have_second;\n-  bfd_boolean extend_only;\n+  bool have_second;\n+  bool extend_only;\n   unsigned int second;\n   unsigned int first;\n   unsigned int full;\n@@ -2211,7 +2211,7 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)\n       return -1;\n     }\n \n-  extend_only = FALSE;\n+  extend_only = false;\n \n   if (info->endian == BFD_ENDIAN_BIG)\n     first = bfd_getb16 (buffer);\n@@ -2221,7 +2221,7 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)\n   status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);\n   if (status == 0)\n     {\n-      have_second = TRUE;\n+      have_second = true;\n       if (info->endian == BFD_ENDIAN_BIG)\n \tsecond = bfd_getb16 (buffer);\n       else\n@@ -2230,7 +2230,7 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)\n     }\n   else\n     {\n-      have_second = FALSE;\n+      have_second = false;\n       second = 0;\n       full = first;\n     }\n@@ -2270,7 +2270,7 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)\n \t  if (op->pinfo2 & INSN2_SHORT_ONLY)\n \t    {\n \t      match = MATCH_NONE;\n-\t      extend_only = TRUE;\n+\t      extend_only = true;\n \t    }\n \t  else\n \t    match = MATCH_FULL;\n@@ -2315,10 +2315,10 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)\n \t\t  const struct mips_operand *operand;\n \t\t  unsigned int reg, sel;\n \n-\t\t  operand = decode_mips16_operand (*s, TRUE);\n+\t\t  operand = decode_mips16_operand (*s, true);\n \t\t  reg = mips_extract_operand (operand, (first << 16) | second);\n \t\t  s += 2;\n-\t\t  operand = decode_mips16_operand (*s, TRUE);\n+\t\t  operand = decode_mips16_operand (*s, true);\n \t\t  sel = mips_extract_operand (operand, (first << 16) | second);\n \n \t\t  /* CP0 register including 'sel' code for mftc0, to be\n@@ -2339,11 +2339,11 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)\n \t\t  {\n \t\t    case MATCH_FULL:\n \t\t      print_mips16_insn_arg (info, &state, op, *s, memaddr + 2,\n-\t\t\t\t\t     second, TRUE, first, s[1] == '(');\n+\t\t\t\t\t     second, true, first, s[1] == '(');\n \t\t      break;\n \t\t    case MATCH_SHORT:\n \t\t      print_mips16_insn_arg (info, &state, op, *s, memaddr,\n-\t\t\t\t\t     first, FALSE, 0, s[1] == '(');\n+\t\t\t\t\t     first, false, 0, s[1] == '(');\n \t\t      break;\n \t\t    case MATCH_NONE:\t/* Stop the compiler complaining.  */\n \t\t      break;\n@@ -2500,8 +2500,8 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)\n    have been derived from function symbols defined elsewhere or could\n    define data).  Otherwise, return 0.  */\n \n-static bfd_boolean\n-is_compressed_mode_p (struct disassemble_info *info, bfd_boolean micromips_p)\n+static bool\n+is_compressed_mode_p (struct disassemble_info *info, bool micromips_p)\n {\n   int i;\n   int l;\n@@ -2562,9 +2562,9 @@ _print_insn_mips (bfd_vma memaddr,\n #endif\n \n #if SYMTAB_AVAILABLE\n-  if (is_compressed_mode_p (info, TRUE))\n+  if (is_compressed_mode_p (info, true))\n     return print_insn_micromips (memaddr, info);\n-  if (is_compressed_mode_p (info, FALSE))\n+  if (is_compressed_mode_p (info, false))\n     return print_insn_mips16 (memaddr, info);\n #endif\n "
    },
    {
      "sha": "85a577442b3966f1ff39fcb74cbf94597a1886c2",
      "filename": "opcodes/mips-formats.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mips-formats.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mips-formats.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mips-formats.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -30,18 +30,18 @@\n   INT_BIAS(SIZE, LSB, MAX_VAL, 0, SHIFT, PRINT_HEX)\n \n #define UINT(SIZE, LSB) \\\n-  INT_ADJ(SIZE, LSB, (1 << (SIZE)) - 1, 0, FALSE)\n+  INT_ADJ(SIZE, LSB, (1 << (SIZE)) - 1, 0, false)\n \n #define SINT(SIZE, LSB) \\\n-  INT_ADJ(SIZE, LSB, (1 << ((SIZE) - 1)) - 1, 0, FALSE)\n+  INT_ADJ(SIZE, LSB, (1 << ((SIZE) - 1)) - 1, 0, false)\n \n #define HINT(SIZE, LSB) \\\n-  INT_ADJ(SIZE, LSB, (1 << (SIZE)) - 1, 0, TRUE)\n+  INT_ADJ(SIZE, LSB, (1 << (SIZE)) - 1, 0, true)\n \n #define BIT(SIZE, LSB, BIAS) \\\n   { \\\n     static const struct mips_int_operand op = { \\\n-      { OP_INT, SIZE, LSB }, (1 << (SIZE)) - 1, BIAS, 0, TRUE \\\n+      { OP_INT, SIZE, LSB }, (1 << (SIZE)) - 1, BIAS, 0, true \\\n     }; \\\n     return &op.root; \\\n   }\n@@ -117,20 +117,20 @@\n   { \\\n     static const struct mips_pcrel_operand op = { \\\n       { { OP_PCREL, SIZE, LSB }, \\\n-\t(1 << ((SIZE) - (IS_SIGNED))) - 1, 0, SHIFT, TRUE }, \\\n+\t(1 << ((SIZE) - (IS_SIGNED))) - 1, 0, SHIFT, true }, \\\n       ALIGN_LOG2, INCLUDE_ISA_BIT, FLIP_ISA_BIT \\\n     }; \\\n     return &op.root.root; \\\n   }\n \n #define JUMP(SIZE, LSB, SHIFT) \\\n-  PCREL (SIZE, LSB, FALSE, SHIFT, SIZE + SHIFT, TRUE, FALSE)\n+  PCREL (SIZE, LSB, false, SHIFT, SIZE + SHIFT, true, false)\n \n #define JALX(SIZE, LSB, SHIFT) \\\n-  PCREL (SIZE, LSB, FALSE, SHIFT, SIZE + SHIFT, TRUE, TRUE)\n+  PCREL (SIZE, LSB, false, SHIFT, SIZE + SHIFT, true, true)\n \n #define BRANCH(SIZE, LSB, SHIFT) \\\n-  PCREL (SIZE, LSB, TRUE, SHIFT, 0, TRUE, FALSE)\n+  PCREL (SIZE, LSB, true, SHIFT, 0, true, false)\n \n #define SPECIAL(SIZE, LSB, TYPE) \\\n   { \\"
    },
    {
      "sha": "175f91a919e23305767f281441626f25213eb6c4",
      "filename": "opcodes/mips-opc.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mips-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mips-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mips-opc.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -43,19 +43,19 @@ decode_mips_operand (const char *p)\n     case '-':\n       switch (p[1])\n \t{\n-\tcase 'a': INT_ADJ (19, 0, 262143, 2, FALSE);\n-\tcase 'b': INT_ADJ (18, 0, 131071, 3, FALSE);\n+\tcase 'a': INT_ADJ (19, 0, 262143, 2, false);\n+\tcase 'b': INT_ADJ (18, 0, 131071, 3, false);\n \tcase 'd': SPECIAL (0, 0, REPEAT_DEST_REG);\n \tcase 'm': SPECIAL (20, 6, SAVE_RESTORE_LIST);\n \tcase 's': SPECIAL (5, 21, NON_ZERO_REG);\n \tcase 't': SPECIAL (5, 16, NON_ZERO_REG);\n-\tcase 'u': PREV_CHECK (5, 16, TRUE, FALSE, FALSE, FALSE);\n-\tcase 'v': PREV_CHECK (5, 16, TRUE, TRUE, FALSE, FALSE);\n-\tcase 'w': PREV_CHECK (5, 16, FALSE, TRUE, TRUE, TRUE);\n-\tcase 'x': PREV_CHECK (5, 21, TRUE, FALSE, FALSE, TRUE);\n-\tcase 'y': PREV_CHECK (5, 21, FALSE, TRUE, FALSE, FALSE);\n-\tcase 'A': PCREL (19, 0, TRUE, 2, 2, FALSE, FALSE);\n-\tcase 'B': PCREL (18, 0, TRUE, 3, 3, FALSE, FALSE);\n+\tcase 'u': PREV_CHECK (5, 16, true, false, false, false);\n+\tcase 'v': PREV_CHECK (5, 16, true, true, false, false);\n+\tcase 'w': PREV_CHECK (5, 16, false, true, true, true);\n+\tcase 'x': PREV_CHECK (5, 21, true, false, false, true);\n+\tcase 'y': PREV_CHECK (5, 21, false, true, false, false);\n+\tcase 'A': PCREL (19, 0, true, 2, 2, false, false);\n+\tcase 'B': PCREL (18, 0, true, 3, 3, false, false);\n \t}\n       break;\n \n@@ -74,12 +74,12 @@ decode_mips_operand (const char *p)\n \tcase '0': REG (5, 16, VI);\n \n \tcase 'A': BIT (5, 6, 0);\t\t/* (0 .. 31) */\n-\tcase 'B': MSB (5, 11, 1, TRUE, 32);\t/* (1 .. 32), 32-bit op */\n-\tcase 'C': MSB (5, 11, 1, FALSE, 32);\t/* (1 .. 32), 32-bit op */\n+\tcase 'B': MSB (5, 11, 1, true, 32);\t/* (1 .. 32), 32-bit op */\n+\tcase 'C': MSB (5, 11, 1, false, 32);\t/* (1 .. 32), 32-bit op */\n \tcase 'E': BIT (5, 6, 32);\t\t/* (32 .. 63) */\n-\tcase 'F': MSB (5, 11, 33, TRUE, 64);\t/* (33 .. 64), 64-bit op */\n-\tcase 'G': MSB (5, 11, 33, FALSE, 64);\t/* (33 .. 64), 64-bit op */\n-\tcase 'H': MSB (5, 11, 1, FALSE, 64);\t/* (1 .. 32), 64-bit op */\n+\tcase 'F': MSB (5, 11, 33, true, 64);\t/* (33 .. 64), 64-bit op */\n+\tcase 'G': MSB (5, 11, 33, false, 64);\t/* (33 .. 64), 64-bit op */\n+\tcase 'H': MSB (5, 11, 1, false, 64);\t/* (1 .. 32), 64-bit op */\n \tcase 'I': UINT (2, 6);\n \tcase 'J': HINT (10, 11);\n \tcase 'K': SPECIAL (4, 21, VU0_MATCH_SUFFIX);\n@@ -90,20 +90,20 @@ decode_mips_operand (const char *p)\n \tcase 'P': BIT (5, 6, 32);\t\t/* (32 .. 63) */\n \tcase 'Q': SINT (10, 6);\n \tcase 'R': SPECIAL (0, 0, PC);\n-\tcase 'S': MSB (5, 11, 0, FALSE, 63);\t/* (0 .. 31), 64-bit op */\n-\tcase 'T': INT_ADJ (10, 16, 511, 0, FALSE); /* (-512 .. 511) << 0 */\n-\tcase 'U': INT_ADJ (10, 16, 511, 1, FALSE); /* (-512 .. 511) << 1 */\n-\tcase 'V': INT_ADJ (10, 16, 511, 2, FALSE); /* (-512 .. 511) << 2 */\n-\tcase 'W': INT_ADJ (10, 16, 511, 3, FALSE); /* (-512 .. 511) << 3 */\n+\tcase 'S': MSB (5, 11, 0, false, 63);\t/* (0 .. 31), 64-bit op */\n+\tcase 'T': INT_ADJ (10, 16, 511, 0, false); /* (-512 .. 511) << 0 */\n+\tcase 'U': INT_ADJ (10, 16, 511, 1, false); /* (-512 .. 511) << 1 */\n+\tcase 'V': INT_ADJ (10, 16, 511, 2, false); /* (-512 .. 511) << 2 */\n+\tcase 'W': INT_ADJ (10, 16, 511, 3, false); /* (-512 .. 511) << 3 */\n \tcase 'X': BIT (5, 16, 32);\t\t/* (32 .. 63) */\n \tcase 'Z': REG (5, 0, FP);\n \n \tcase 'a': SINT (8, 6);\n \tcase 'b': SINT (8, 3);\n-\tcase 'c': INT_ADJ (9, 6, 255, 4, FALSE); /* (-256 .. 255) << 4 */\n+\tcase 'c': INT_ADJ (9, 6, 255, 4, false); /* (-256 .. 255) << 4 */\n \tcase 'd': REG (5, 6, MSA);\n \tcase 'e': REG (5, 11, MSA);\n-\tcase 'f': INT_ADJ (15, 6, 32767, 3, TRUE);\n+\tcase 'f': INT_ADJ (15, 6, 32767, 3, true);\n \tcase 'g': SINT (5, 6);\n \tcase 'h': REG (5, 16, MSA);\n \tcase 'i': JALX (26, 0, 2);\n@@ -116,7 +116,7 @@ decode_mips_operand (const char *p)\n \tcase 'p': BIT (5, 6, 0);\t\t/* (0 .. 31), 32-bit op */\n \tcase 'q': REG (0, 0, R5900_Q);\n \tcase 'r': REG (0, 0, R5900_R);\n-\tcase 's': MSB (5, 11, 0, FALSE, 31);\t/* (0 .. 31) */\n+\tcase 's': MSB (5, 11, 0, false, 31);\t/* (0 .. 31) */\n \tcase 't': REG (5, 16, COPRO);\n \tcase 'u': SPECIAL (3, 16, IMM_INDEX);\n \tcase 'v': SPECIAL (2, 16, IMM_INDEX);"
    },
    {
      "sha": "e3dc3fba5fd56c31825e352a9632992fdee72962",
      "filename": "opcodes/mips16-opc.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mips16-opc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mips16-opc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mips16-opc.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -45,7 +45,7 @@ static unsigned char reg32r_map[] = {\n    The extended forms all have an lsb of 0.  */\n \n const struct mips_operand *\n-decode_mips16_operand (char type, bfd_boolean extended_p)\n+decode_mips16_operand (char type, bool extended_p)\n {\n   switch (type)\n     {\n@@ -75,14 +75,14 @@ decode_mips16_operand (char type, bfd_boolean extended_p)\n \n     case 'a': JUMP (26, 0, 2);\n     case 'b': BIT (5, 22, 0);\t\t\t/* (0 .. 31) */\n-    case 'c': MSB (5, 16, 1, TRUE, 32);\t\t/* (1 .. 32) */\n-    case 'd': MSB (5, 16, 1, FALSE, 32);\t/* (1 .. 32) */\n+    case 'c': MSB (5, 16, 1, true, 32);\t\t/* (1 .. 32) */\n+    case 'd': MSB (5, 16, 1, false, 32);\t/* (1 .. 32) */\n     case 'e': HINT (11, 0);\n     case 'i': JALX (26, 0, 2);\n     case 'l': SPECIAL (6, 5, ENTRY_EXIT_LIST);\n     case 'm': SPECIAL (7, 0, SAVE_RESTORE_LIST);\n-    case 'n': INT_BIAS (2, 0, 3, 1, 0, FALSE);\t/* (1 .. 4) */\n-    case 'o': INT_ADJ (5, 16, 31, 4, FALSE);\t/* (0 .. 31) << 4 */\n+    case 'n': INT_BIAS (2, 0, 3, 1, 0, false);\t/* (1 .. 4) */\n+    case 'o': INT_ADJ (5, 16, 31, 4, false);\t/* (0 .. 31) << 4 */\n     case 'r': MAPPED_REG (3, 16, GP, reg_m16_map);\n     case 's': HINT (3, 24);\n     case 'u': HINT (16, 0);\n@@ -103,11 +103,11 @@ decode_mips16_operand (char type, bfd_boolean extended_p)\n       case '5': SINT (16, 0);\n       case '8': SINT (16, 0);\n \n-      case 'A': PCREL (16, 0, TRUE, 0, 2, FALSE, FALSE);\n-      case 'B': PCREL (16, 0, TRUE, 0, 3, FALSE, FALSE);\n+      case 'A': PCREL (16, 0, true, 0, 2, false, false);\n+      case 'B': PCREL (16, 0, true, 0, 3, false, false);\n       case 'C': SINT (16, 0);\n       case 'D': SINT (16, 0);\n-      case 'E': PCREL (16, 0, TRUE, 0, 2, FALSE, FALSE);\n+      case 'E': PCREL (16, 0, true, 0, 2, false, false);\n       case 'F': SINT (15, 0);\n       case 'H': SINT (16, 0);\n       case 'K': SINT (16, 0);\n@@ -123,24 +123,24 @@ decode_mips16_operand (char type, bfd_boolean extended_p)\n   else\n     switch (type)\n       {\n-      case '<': INT_ADJ (3, 2, 8, 0, FALSE);\n-      case '[': INT_ADJ (3, 2, 8, 0, FALSE);\n-      case ']': INT_ADJ (3, 8, 8, 0, FALSE);\n+      case '<': INT_ADJ (3, 2, 8, 0, false);\n+      case '[': INT_ADJ (3, 2, 8, 0, false);\n+      case ']': INT_ADJ (3, 8, 8, 0, false);\n \n       case '5': UINT (5, 0);\n       case '8': UINT (8, 0);\n \n-      case 'A': PCREL (8, 0, FALSE, 2, 2, FALSE, FALSE);\n-      case 'B': PCREL (5, 0, FALSE, 3, 3, FALSE, FALSE);\n-      case 'C': INT_ADJ (8, 0, 255, 3, FALSE);\t/* (0 .. 255) << 3 */\n-      case 'D': INT_ADJ (5, 0, 31, 3, FALSE);\t/* (0 .. 31) << 3 */\n-      case 'E': PCREL (5, 0, FALSE, 2, 2, FALSE, FALSE);\n+      case 'A': PCREL (8, 0, false, 2, 2, false, false);\n+      case 'B': PCREL (5, 0, false, 3, 3, false, false);\n+      case 'C': INT_ADJ (8, 0, 255, 3, false);\t/* (0 .. 255) << 3 */\n+      case 'D': INT_ADJ (5, 0, 31, 3, false);\t/* (0 .. 31) << 3 */\n+      case 'E': PCREL (5, 0, false, 2, 2, false, false);\n       case 'F': SINT (4, 0);\n-      case 'H': INT_ADJ (5, 0, 31, 1, FALSE);\t/* (0 .. 31) << 1 */\n-      case 'K': INT_ADJ (8, 0, 127, 3, FALSE);\t/* (-128 .. 127) << 3 */\n+      case 'H': INT_ADJ (5, 0, 31, 1, false);\t/* (0 .. 31) << 1 */\n+      case 'K': INT_ADJ (8, 0, 127, 3, false);\t/* (-128 .. 127) << 3 */\n       case 'U': UINT (8, 0);\n-      case 'V': INT_ADJ (8, 0, 255, 2, FALSE);\t/* (0 .. 255) << 2 */\n-      case 'W': INT_ADJ (5, 0, 31, 2, FALSE);\t/* (0 .. 31) << 2 */\n+      case 'V': INT_ADJ (8, 0, 255, 2, false);\t/* (0 .. 255) << 2 */\n+      case 'W': INT_ADJ (5, 0, 31, 2, false);\t/* (0 .. 31) << 2 */\n \n       case 'j': SINT (5, 0);\n       case 'k': SINT (8, 0);"
    },
    {
      "sha": "16eb168402b114751774616e5e07f1a4eefb170e",
      "filename": "opcodes/mmix-dis.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mmix-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/mmix-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mmix-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -69,14 +69,14 @@ struct mmix_dis_info\n \n /* Initialize a target-specific array in INFO.  */\n \n-static bfd_boolean\n+static bool\n initialize_mmix_dis_info (struct disassemble_info *info)\n {\n   struct mmix_dis_info *minfop = malloc (sizeof (struct mmix_dis_info));\n   long i;\n \n   if (minfop == NULL)\n-    return FALSE;\n+    return false;\n \n   memset (minfop, 0, sizeof (*minfop));\n \n@@ -103,7 +103,7 @@ initialize_mmix_dis_info (struct disassemble_info *info)\n \t    {\n \t      FATAL_DEBUG;\n \t      free (minfop);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  nsyms = bfd_canonicalize_symtab (abfd, syms);\n \n@@ -133,7 +133,7 @@ initialize_mmix_dis_info (struct disassemble_info *info)\n     minfop->spec_reg_name[mmix_spec_regs[i].number] = mmix_spec_regs[i].name;\n \n   info->private_data = (void *) minfop;\n-  return TRUE;\n+  return true;\n }\n \n /* A table indexed by the first byte is constructed as we disassemble each"
    },
    {
      "sha": "1dac64414a1a56c06b651f83440e046a4c90959f",
      "filename": "opcodes/msp430-dis.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/msp430-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/msp430-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/msp430-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -37,7 +37,7 @@\n \n #define PS(x)   (0xffff & (x))\n \n-static bfd_boolean\n+static bool\n msp430dis_read_two_bytes (bfd_vma            addr,\n \t\t\t  disassemble_info * info,\n \t\t\t  bfd_byte *         buffer,\n@@ -47,7 +47,7 @@ msp430dis_read_two_bytes (bfd_vma            addr,\n \n   status = info->read_memory_func (addr, buffer, 2, info);\n   if (status == 0)\n-    return TRUE;\n+    return true;\n \n   /* PR 20150: A status of EIO means that there were no more bytes left\n      to read in the current section.  This can happen when disassembling\n@@ -65,10 +65,10 @@ msp430dis_read_two_bytes (bfd_vma            addr,\n \tsprintf (comm, _(\"Error: read from memory failed\"));\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n msp430dis_opcode_unsigned (bfd_vma            addr,\n \t\t\t   disassemble_info * info,\n \t\t\t   unsigned short *   return_val,\n@@ -79,16 +79,16 @@ msp430dis_opcode_unsigned (bfd_vma            addr,\n   if (msp430dis_read_two_bytes (addr, info, buffer, comm))\n     {\n       * return_val = bfd_getl16 (buffer);\n-      return TRUE;\n+      return true;\n     }\n   else\n     {\n       * return_val = 0;\n-      return FALSE;\n+      return false;\n     }\n }\n \n-static bfd_boolean\n+static bool\n msp430dis_opcode_signed (bfd_vma            addr,\n \t\t\t disassemble_info * info,\n \t\t\t signed int *       return_val,\n@@ -104,12 +104,12 @@ msp430dis_opcode_signed (bfd_vma            addr,\n       if (status & 0x8000)\n \tstatus |= -1U << 16;\n       * return_val = status;\n-      return TRUE;\n+      return true;\n     }\n   else\n     {\n       * return_val = 0;\n-      return FALSE;\n+      return false;\n     }\n }\n "
    },
    {
      "sha": "e501f2ad565cab82d27af4da9b6e4c084ff15685",
      "filename": "opcodes/nds32-dis.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/nds32-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/nds32-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/nds32-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -982,8 +982,8 @@ print_insn_nds32 (bfd_vma pc, disassemble_info *info)\n   int n;\n   int last_symbol_index = -1;\n   bfd_vma addr;\n-  int is_data = FALSE;\n-  bfd_boolean found = FALSE;\n+  int is_data = false;\n+  bool found = false;\n   struct nds32_private_data *private_data;\n   unsigned int size;\n   enum map_type mapping_type = MAP_CODE;\n@@ -1025,7 +1025,7 @@ print_insn_nds32 (bfd_vma pc, disassemble_info *info)\n \t      if (get_mapping_symbol_type (info, n, &mapping_type))\n \t\t{\n \t\t  last_symbol_index = n;\n-\t\t  found = TRUE;\n+\t\t  found = true;\n \t\t}\n \t    }\n \n@@ -1189,21 +1189,21 @@ print_insn_nds32 (bfd_vma pc, disassemble_info *info)\n \n /* Ignore disassembling unnecessary name.  */\n \n-static bfd_boolean\n+static bool\n nds32_symbol_is_valid (asymbol *sym,\n \t\t       struct disassemble_info *info ATTRIBUTE_UNUSED)\n {\n   const char *name;\n \n   if (sym == NULL)\n-    return FALSE;\n+    return false;\n \n   name = bfd_asymbol_name (sym);\n \n   /* Mapping symbol is invalid.  */\n   if (name[0] == '$')\n-    return FALSE;\n-  return TRUE;\n+    return false;\n+  return true;\n }\n \n static void\n@@ -1286,35 +1286,35 @@ is_mapping_symbol (struct disassemble_info *info, int n,\n   if (name[1] == 'c')\n     {\n       *map_type = MAP_CODE;\n-      return TRUE;\n+      return true;\n     }\n   else if (name[1] == 'd' && name[2] == '0')\n     {\n       *map_type = MAP_DATA0;\n-      return TRUE;\n+      return true;\n     }\n   else if (name[1] == 'd' && name[2] == '1')\n     {\n       *map_type = MAP_DATA1;\n-      return TRUE;\n+      return true;\n     }\n   else if (name[1] == 'd' && name[2] == '2')\n     {\n       *map_type = MAP_DATA2;\n-      return TRUE;\n+      return true;\n     }\n   else if (name[1] == 'd' && name[2] == '3')\n     {\n       *map_type = MAP_DATA3;\n-      return TRUE;\n+      return true;\n     }\n   else if (name[1] == 'd' && name[2] == '4')\n     {\n       *map_type = MAP_DATA4;\n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n static int\n@@ -1324,7 +1324,7 @@ get_mapping_symbol_type (struct disassemble_info *info, int n,\n   /* If the symbol is in a different section, ignore it.  */\n   if (info->section != NULL\n       && info->section != info->symtab[n]->section)\n-    return FALSE;\n+    return false;\n \n   return is_mapping_symbol (info, n, map_type);\n }"
    },
    {
      "sha": "b74ccb3fce59f60a374ee692bca50df85c22371f",
      "filename": "opcodes/nfp-dis.c",
      "status": "modified",
      "additions": 37,
      "deletions": 37,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/nfp-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/nfp-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/nfp-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -929,13 +929,13 @@ nfp_me_print_invalid (uint64_t instr, struct disassemble_info *dinfo)\n   return _NFP_ERR_CONT;\n }\n \n-static bfd_boolean\n+static bool\n nfp_me_is_imm_opnd10 (unsigned int opnd)\n {\n   return _BF (opnd, 9, 8) == 0x3;\n }\n \n-static bfd_boolean\n+static bool\n nfp_me_is_imm_opnd8 (unsigned int opnd)\n {\n   return _BTST (opnd, 5);\n@@ -957,7 +957,7 @@ nfp_me_imm_opnd8 (unsigned int opnd, unsigned int imm8_msb)\n \n /* Print an unrestricted/10-bit operand.\n    This can mostly be generic across NFP families at the moment.  */\n-static bfd_boolean\n+static bool\n nfp_me_print_opnd10 (unsigned int opnd, char bank, int num_ctx, int lmem_ext,\n \t\t     struct disassemble_info *dinfo)\n {\n@@ -1021,16 +1021,16 @@ nfp_me_print_opnd10 (unsigned int opnd, char bank, int num_ctx, int lmem_ext,\n   else\n     {\n       dinfo->fprintf_func (dinfo->stream, \"<opnd:0x%x>\", opnd);\n-      return FALSE;\n+      return false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Print a restricted/8-bit operand.\n    This can mostly be generic across NFP families at the moment.  */\n \n-static bfd_boolean\n+static bool\n nfp_me_print_opnd8 (unsigned int opnd, char bank, int num_ctx, int lmem_ext,\n \t\t    unsigned int imm8_msb, struct disassemble_info *dinfo)\n {\n@@ -1088,10 +1088,10 @@ nfp_me_print_opnd8 (unsigned int opnd, char bank, int num_ctx, int lmem_ext,\n   else\n     {\n       dinfo->fprintf_func (dinfo->stream, \"<opnd:0x%x>\", opnd);\n-      return FALSE;\n+      return false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n static int\n@@ -1110,7 +1110,7 @@ nfp_me27_28_print_alu_shf (uint64_t instr, unsigned int pred_cc,\n   unsigned int shift = _BF (instr, 32, 28);\n   char dst_bank = 'A' + _BTST (instr, 36);\n   unsigned int nocc = _BTST (instr, 40);\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (swap)\n     {\n@@ -1232,7 +1232,7 @@ nfp_me27_28_print_alu (uint64_t instr, unsigned int pred_cc,\n   char dst_bank = 'A' + _BTST (instr, 36);\n   unsigned int nocc = _BTST (instr, 40);\n   int do_close_bracket = 1;\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (swap)\n     {\n@@ -1329,7 +1329,7 @@ nfp_me27_28_print_alu (uint64_t instr, unsigned int pred_cc,\n       if (!nfp_me27_28_crc_op[_BF (srcA, 7, 5)])\n \t{\n \t  dinfo->fprintf_func (dinfo->stream, _(\", <invalid CRC operator>, \"));\n-\t  err = TRUE;\n+\t  err = true;\n \t}\n       else\n \t{\n@@ -1380,7 +1380,7 @@ nfp_me27_28_print_alu (uint64_t instr, unsigned int pred_cc,\n       if (!nfp_me27_28_alu_op[op])\n \t{\n \t  dinfo->fprintf_func (dinfo->stream, \", <operator:0x%x>, \", op);\n-\t  err = TRUE;\n+\t  err = true;\n \t}\n       else\n \t{\n@@ -1422,7 +1422,7 @@ nfp_me27_28_print_immed (uint64_t instr, unsigned int pred_cc,\n   unsigned int wd = _BTST (instr, 30);\n   unsigned int inv = _BTST (instr, 31);\n   unsigned int byte_shift = _BF (instr, 34, 33);\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (nfp_me_is_imm_opnd10 (srcB))\n     {\n@@ -1494,7 +1494,7 @@ nfp_me27_28_print_ld_field (uint64_t instr, unsigned int pred_cc,\n   unsigned int src = _BF (instr, 17, 10);\n   unsigned int sc = _BF (instr, 9, 8);\n   unsigned int dst = _BF (instr, 7, 0);\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (swap)\n     {\n@@ -1611,7 +1611,7 @@ nfp_me27_28_print_local_csr (uint64_t instr,\n   unsigned int csr_num = _BF (instr, 32, 22);\n   unsigned int src = srcA;\n   char src_bank = 'A';\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (nfp_me_is_imm_opnd10 (srcA) && !nfp_me_is_imm_opnd10 (srcB))\n     {\n@@ -1728,7 +1728,7 @@ nfp_me27_28_print_br_byte (uint64_t instr,\n   unsigned int eq = _BTST (instr, 19);\n   unsigned int defer = _BF (instr, 21, 20);\n   unsigned int br_addr = _BFS (instr, 40, 40, 13) | _BF (instr, 34, 22);\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (eq)\n     dinfo->fprintf_func (dinfo->stream, \"br=byte[\");\n@@ -1770,7 +1770,7 @@ nfp_me27_28_print_br_bit (uint64_t instr, unsigned int src_lmext,\n   unsigned int b = _BTST (instr, 18);\n   unsigned int defer = _BF (instr, 21, 20);\n   unsigned int br_addr = _BFS (instr, 40, 40, 13) | _BF (instr, 34, 22);\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (b)\n     dinfo->fprintf_func (dinfo->stream, \"br_bset[\");\n@@ -1808,7 +1808,7 @@ nfp_me27_28_print_br_alu (uint64_t instr, unsigned int src_lmext,\n   unsigned int srcB = _BF (instr, 19, 10);\n   unsigned int defer = _BF (instr, 21, 20);\n   unsigned int imm = _BF (instr, 30, 22);\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (nfp_me_is_imm_opnd10 (srcA))\n     imm = (imm << 8) | nfp_me_imm_opnd10 (srcA);\n@@ -1851,7 +1851,7 @@ nfp_me27_28_print_mult (uint64_t instr, unsigned int pred_cc,\n   unsigned int swap = _BTST (instr, 30);\n   unsigned int mtype = _BF (instr, 32, 31);\n   unsigned int nocc = _BTST (instr, 40);\n-  bfd_boolean err = FALSE;\n+  bool err = false;\n \n   if (swap)\n     {\n@@ -1884,7 +1884,7 @@ nfp_me27_28_print_mult (uint64_t instr, unsigned int pred_cc,\n       if (!s)\n \t{\n \t  s = \"<invalid mul_step>\";\n-\t  err = TRUE;\n+\t  err = true;\n \t}\n       dinfo->fprintf_func (dinfo->stream, \"_%s\", s);\n     }\n@@ -1964,7 +1964,7 @@ nfp_me27_print_cmd (uint64_t instr, int third_party_32bit,\n   unsigned int indref = _BTST (instr, 41);\n   unsigned int mode = _BF (instr, 44, 42);\n \n-  bfd_boolean err = FALSE;\n+  bool err = false;\n   int cpp_target = -1;\n   int cpp_action = -1;\n   const char *mnemonic = NULL;\n@@ -2243,7 +2243,7 @@ nfp_me28_print_cmd (uint64_t instr, int third_party_32bit,\n   unsigned int indref = _BTST (instr, 41);\n   unsigned int mode = _BF (instr, 44, 42);\n \n-  bfd_boolean err = FALSE;\n+  bool err = false;\n   int cpp_target = -1;\n   int cpp_action = -1;\n   const char *mnemonic = NULL;\n@@ -2523,7 +2523,7 @@ nfp_me28_print_mult (uint64_t instr, int num_ctx,\n \t\t\t\t gpr_wrboth, num_ctx, dinfo);\n }\n \n-static bfd_boolean\n+static bool\n init_nfp3200_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)\n {\n   Elf_Internal_Shdr *sec = NULL;\n@@ -2536,7 +2536,7 @@ init_nfp3200_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)\n \n   if (!dinfo->section)\n     /* No section info, will use default values.  */\n-    return TRUE;\n+    return true;\n \n   sec_cnt = elf_numsections (dinfo->section->owner);\n \n@@ -2553,7 +2553,7 @@ init_nfp3200_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)\n   if (sec_idx == sec_cnt)\n     {\n       dinfo->fprintf_func (dinfo->stream, _(\"File has no ME-Config section.\"));\n-      return FALSE;\n+      return false;\n     }\n \n   for (roff = 0; (bfd_size_type) roff < sec->sh_size;\n@@ -2567,14 +2567,14 @@ init_nfp3200_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)\n \t{\n \t  dinfo->fprintf_func (dinfo->stream,\n \t\t\t       _(\"File has invalid ME-Config section.\"));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       mecfg = &priv->mecfgs[isl][menum][1];\n \n       if (!bfd_get_section_contents (dinfo->section->owner, sec->bfd_section,\n \t\t\t\t     buffer, roff, sizeof (buffer)))\n-\treturn FALSE;\n+\treturn false;\n \n       mecfg_ent.ctx_enables = bfd_getl32 (buffer + offsetof (Elf_Nfp_MeConfig,\n \t\t\t\t\t\t\t     ctx_enables));\n@@ -2586,10 +2586,10 @@ init_nfp3200_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)\n       mecfg->scs_cnt = _BTST (mecfg_ent.misc_control, 2);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n init_nfp6000_mecsr_sec (nfp_priv_data * priv, Elf_Internal_Shdr * sec,\n \t\t\tint is_for_text, struct disassemble_info *dinfo)\n {\n@@ -2599,7 +2599,7 @@ init_nfp6000_mecsr_sec (nfp_priv_data * priv, Elf_Internal_Shdr * sec,\n   size_t isl, menum;\n \n   if (sec->sh_entsize != sizeof (ireg))\n-    return FALSE;\n+    return false;\n \n   isl = SHI_NFP_IREG_ISLAND (sec->sh_info);\n \n@@ -2622,7 +2622,7 @@ init_nfp6000_mecsr_sec (nfp_priv_data * priv, Elf_Internal_Shdr * sec,\n \n       if (!bfd_get_section_contents (dinfo->section->owner, sec->bfd_section,\n \t\t\t\t     buffer, ireg_off, sizeof (buffer)))\n-\treturn FALSE;\n+\treturn false;\n \n       ireg.cpp_offset_lo = bfd_getl32 (buffer\n \t+ offsetof (Elf_Nfp_InitRegEntry, cpp_offset_lo));\n@@ -2656,10 +2656,10 @@ init_nfp6000_mecsr_sec (nfp_priv_data * priv, Elf_Internal_Shdr * sec,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n init_nfp6000_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)\n {\n   int mecfg_orders[64][2];\n@@ -2672,7 +2672,7 @@ init_nfp6000_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)\n \n   if (!dinfo->section)\n     /* No section info, will use default values.  */\n-    return TRUE;\n+    return true;\n \n   sec_cnt = elf_numsections (dinfo->section->owner);\n \n@@ -2709,11 +2709,11 @@ init_nfp6000_priv (nfp_priv_data * priv, struct disassemble_info *dinfo)\n \t{\n \t  dinfo->fprintf_func (dinfo->stream,\n \t\t\t       _(\"Error processing section %u \"), sec_idx);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n static int\n@@ -2752,7 +2752,7 @@ static nfp_priv_data *\n init_nfp_priv (struct disassemble_info *dinfo)\n {\n   nfp_priv_data *priv;\n-  int ret = FALSE;\n+  int ret = false;\n \n   if (dinfo->private_data)\n     return (nfp_priv_data *) dinfo->private_data;"
    },
    {
      "sha": "9709dd3a34bcf9b14332824fde20b5b0412b0b63",
      "filename": "opcodes/nios2-dis.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/nios2-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/nios2-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/nios2-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -73,7 +73,7 @@ typedef struct _nios2_disassembler_state\n   nios2_opcode_hash *hash[OPCODE_HASH_SIZE];\n   nios2_opcode_hash *ps_hash[OPCODE_HASH_SIZE];\n   const struct nios2_opcode *nop;\n-  bfd_boolean init;\n+  bool init;\n } nios2_disassembler_state;\n \n static nios2_disassembler_state"
    },
    {
      "sha": "dc0825a811eaee2e4c9fc565199971222f3e8b39",
      "filename": "opcodes/ppc-dis.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/ppc-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/ppc-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ppc-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -399,14 +399,14 @@ static unsigned short vle_opcd_indices[VLE_OPCD_SEGS + 1];\n #define SPE2_OPCD_SEGS (1 + SPE2_XOP_TO_SEG (SPE2_XOP (-1)))\n static unsigned short spe2_opcd_indices[SPE2_OPCD_SEGS + 1];\n \n-static bfd_boolean\n+static bool\n ppc_symbol_is_valid (asymbol *sym,\n \t\t     struct disassemble_info *info ATTRIBUTE_UNUSED)\n {\n   elf_symbol_type * est;\n \n   if (sym == NULL)\n-    return FALSE;\n+    return false;\n \n   est = elf_symbol_from (sym);\n   \n@@ -416,9 +416,9 @@ ppc_symbol_is_valid (asymbol *sym,\n       && ELF_ST_VISIBILITY (est->internal_elf_sym.st_other) == STV_HIDDEN\n       && ELF_ST_BIND (est->internal_elf_sym.st_info) == STB_LOCAL\n       && ELF_ST_TYPE (est->internal_elf_sym.st_info) == STT_NOTYPE)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Calculate opcode table indices to speed up disassembly,\n@@ -530,7 +530,7 @@ operand_value_powerpc (const struct powerpc_operand *operand,\n \n /* Determine whether the optional operand(s) should be printed.  */\n \n-static bfd_boolean\n+static bool\n skip_optional_operands (const unsigned char *opindex,\n \t\t\tuint64_t insn, ppc_cpu_t dialect)\n {\n@@ -541,19 +541,19 @@ skip_optional_operands (const unsigned char *opindex,\n     {\n       operand = &powerpc_operands[*opindex];\n       if ((operand->flags & PPC_OPERAND_NEXT) != 0)\n-\treturn FALSE;\n+\treturn false;\n       if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0)\n \t{\n \t  /* Negative count is used as a flag to extract function.  */\n \t  --num_optional;\n \t  if (operand_value_powerpc (operand, insn, dialect)\n \t      != ppc_optional_operand_value (operand, insn, dialect,\n \t\t\t\t\t     num_optional))\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Find a match for INSN in the opcode table, given machine DIALECT.  */\n@@ -683,7 +683,7 @@ lookup_vle (uint64_t insn)\n     {\n       uint64_t table_opcd = opcode->opcode;\n       uint64_t table_mask = opcode->mask;\n-      bfd_boolean table_op_is_short = PPC_OP_SE_VLE(table_mask);\n+      bool table_op_is_short = PPC_OP_SE_VLE(table_mask);\n       uint64_t insn2;\n       const unsigned char *opindex;\n       const struct powerpc_operand *operand;\n@@ -861,7 +861,7 @@ print_insn_powerpc (bfd_vma memaddr,\n \tneed_7spaces = 7,\n \tneed_paren\n       } op_separator;\n-      bfd_boolean skip_optional;\n+      bool skip_optional;\n       int blanks;\n \n       (*info->fprintf_func) (info->stream, \"%s\", opcode->name);\n@@ -872,7 +872,7 @@ print_insn_powerpc (bfd_vma memaddr,\n \n       /* Now extract and print the operands.  */\n       op_separator = blanks;\n-      skip_optional = FALSE;\n+      skip_optional = false;\n       for (opindex = opcode->operands; *opindex != 0; opindex++)\n \t{\n \t  int64_t value;"
    },
    {
      "sha": "025d134845965987cde089ab0d0fe2b8e485afbf",
      "filename": "opcodes/riscv-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/riscv-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/riscv-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/riscv-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -55,7 +55,7 @@ set_default_riscv_dis_options (void)\n   no_aliases = 0;\n }\n \n-static bfd_boolean\n+static bool\n parse_riscv_dis_option_without_args (const char *option)\n {\n   if (strcmp (option, \"no-aliases\") == 0)\n@@ -66,8 +66,8 @@ parse_riscv_dis_option_without_args (const char *option)\n       riscv_fpr_names = riscv_fpr_names_numeric;\n     }\n   else\n-    return FALSE;\n-  return TRUE;\n+    return false;\n+  return true;\n }\n \n static void\n@@ -374,7 +374,7 @@ print_insn_args (const char *d, insn_t l, bfd_vma pc, disassemble_info *info)\n \tcase 'E':\n \t  {\n \t    static const char *riscv_csr_hash[4096]; /* Total 2^12 CSRs.  */\n-\t    static bfd_boolean init_csr = FALSE;\n+\t    static bool init_csr = false;\n \t    unsigned int csr = EXTRACT_OPERAND (CSR, l);\n \n \t    if (!init_csr)\n@@ -429,7 +429,7 @@ static int\n riscv_disassemble_insn (bfd_vma memaddr, insn_t word, disassemble_info *info)\n {\n   const struct riscv_opcode *op;\n-  static bfd_boolean init = 0;\n+  static bool init = 0;\n   static const struct riscv_opcode *riscv_hash[OP_MASK_OP + 1];\n   struct riscv_private_data *pd;\n   int insnlen;\n@@ -616,14 +616,14 @@ riscv_get_disassembler (bfd *abfd)\n /* Prevent use of the fake labels that are generated as part of the DWARF\n    and for relaxable relocations in the assembler.  */\n \n-bfd_boolean\n+bool\n riscv_symbol_is_valid (asymbol * sym,\n                        struct disassemble_info * info ATTRIBUTE_UNUSED)\n {\n   const char * name;\n \n   if (sym == NULL)\n-    return FALSE;\n+    return false;\n \n   name = bfd_asymbol_name (sym);\n "
    },
    {
      "sha": "c1b9227e8c2ff3a9d19feb139161657833ef05a3",
      "filename": "opcodes/score-dis.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/score-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/score-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/score-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -36,7 +36,7 @@\n #ifdef BFD64\n /* s3_s7: opcodes and export prototypes.  */\n extern int\n-s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little);\n+s7_print_insn (bfd_vma pc, struct disassemble_info *info, bool little);\n \n struct score_opcode\n {\n@@ -1048,7 +1048,7 @@ print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)\n /* NOTE: There are no checks in these routines that\n    the relevant number of data bytes exist.  */\n static int\n-s3_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n+s3_print_insn (bfd_vma pc, struct disassemble_info *info, bool little)\n {\n   unsigned char b[6];\n   bfd_vma given, given_h, given_l, given_16, given_32, given_48;\n@@ -1179,18 +1179,18 @@ int\n print_insn_big_score (bfd_vma pc, struct disassemble_info *info)\n {\n   if (score_get_arch (info) == bfd_mach_score3)\n-    return s3_print_insn (pc, info, FALSE);\n+    return s3_print_insn (pc, info, false);\n   else\n-    return s7_print_insn (pc, info, FALSE);\n+    return s7_print_insn (pc, info, false);\n }\n \n int\n print_insn_little_score (bfd_vma pc, struct disassemble_info *info)\n {\n   if (score_get_arch (info) == bfd_mach_score3)\n-    return s3_print_insn (pc, info, TRUE);\n+    return s3_print_insn (pc, info, true);\n   else\n-    return s7_print_insn (pc, info, TRUE);\n+    return s7_print_insn (pc, info, true);\n }\n #else /* not BFD64 */\n int"
    },
    {
      "sha": "53873079594c0abc28e2a19645082d62ff09d526",
      "filename": "opcodes/score7-dis.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/score7-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/score7-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/score7-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -539,7 +539,7 @@ static unsigned int regname_selected = 0;\n \n /* s3_s7: opcodes and export prototypes.  */\n int\n-s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little);\n+s7_print_insn (bfd_vma pc, struct disassemble_info *info, bool little);\n \n /* Print one instruction from PC on INFO->STREAM.\n    Return the size of the instruction.  */\n@@ -867,14 +867,14 @@ print_insn_score16 (bfd_vma pc, struct disassemble_info *info, long given)\n /* NOTE: There are no checks in these routines that\n    the relevant number of data bytes exist.  */\n int\n-s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n+s7_print_insn (bfd_vma pc, struct disassemble_info *info, bool little)\n {\n   unsigned char b[4];\n   unsigned long given;\n   long ridparity;\n   int status;\n-  bfd_boolean insn_pce_p = FALSE;\n-  bfd_boolean insn_16_p = FALSE;\n+  bool insn_pce_p = false;\n+  bool insn_16_p = false;\n \n   info->display_endian = little ? BFD_ENDIAN_LITTLE : BFD_ENDIAN_BIG;\n \n@@ -883,7 +883,7 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n       info->bytes_per_chunk = 2;\n       status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);\n       b[3] = b[2] = 0;\n-      insn_16_p = TRUE;\n+      insn_16_p = true;\n     }\n   else\n     {\n@@ -894,7 +894,7 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n \t  info->bytes_per_chunk = 2;\n \t  status = info->read_memory_func (pc, (bfd_byte *) b, 2, info);\n \t  b[3] = b[2] = 0;\n-\t  insn_16_p = TRUE;\n+\t  insn_16_p = true;\n \t}\n     }\n \n@@ -911,13 +911,13 @@ s7_print_insn (bfd_vma pc, struct disassemble_info *info, bfd_boolean little)\n \n   if ((given & 0x80008000) == 0x80008000)\n     {\n-      insn_pce_p = FALSE;\n-      insn_16_p = FALSE;\n+      insn_pce_p = false;\n+      insn_16_p = false;\n     }\n   else if ((given & 0x8000) == 0x8000)\n-    insn_pce_p = TRUE;\n+    insn_pce_p = true;\n   else\n-    insn_16_p = TRUE;\n+    insn_16_p = true;\n \n   /* 16 bit instruction.  */\n   if (insn_16_p)"
    },
    {
      "sha": "74fbee729f9c874fc5804a3cce80a3c4bf1e848c",
      "filename": "opcodes/sysdep.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/sysdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/sysdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/sysdep.h?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -71,3 +71,5 @@ extern char *stpcpy (char *__dest, const char *__src);\n #define OPCODES_SIGSETJMP(buf)\t\tsetjmp(buf)\n #define OPCODES_SIGLONGJMP(buf,val)\tlongjmp((buf), (val))\n #endif\n+\n+#define POISON_BFD_BOOLEAN 1"
    },
    {
      "sha": "41cbd4024c1cce395a4676219636145f2070264b",
      "filename": "opcodes/tic6x-dis.c",
      "status": "modified",
      "additions": 111,
      "deletions": 111,
      "changes": 222,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/tic6x-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/tic6x-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/tic6x-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -189,7 +189,7 @@ tic6x_extract_16 (unsigned char *p, tic6x_fetch_packet_header *header,\n /* FP points to a fetch packet.  Return whether it is header-based; if\n    it is, fill in HEADER.  */\n \n-static bfd_boolean\n+static bool\n tic6x_check_fetch_packet_header (unsigned char *fp,\n \t\t\t\t tic6x_fetch_packet_header *header,\n \t\t\t\t struct disassemble_info *info)\n@@ -206,10 +206,10 @@ tic6x_check_fetch_packet_header (unsigned char *fp,\n       header->br = 0;\n       header->sat = 0;\n       for (i = 0; i < 7; i++)\n-\theader->word_compact[i] = FALSE;\n+\theader->word_compact[i] = false;\n       for (i = 0; i < 14; i++)\n-\theader->p_bits[i] = FALSE;\n-      return FALSE;\n+\theader->p_bits[i] = false;\n+      return false;\n     }\n \n   for (i = 0; i < 7; i++)\n@@ -225,7 +225,7 @@ tic6x_check_fetch_packet_header (unsigned char *fp,\n   for (i = 0; i < 14; i++)\n     header->p_bits[i] = (header->header & (1u << i)) != 0;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Disassemble the instruction at ADDR and print it using\n@@ -241,10 +241,10 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n   unsigned char fp[32];\n   unsigned int opcode;\n   tic6x_opcode_id opcode_id;\n-  bfd_boolean fetch_packet_header_based;\n+  bool fetch_packet_header_based;\n   tic6x_fetch_packet_header header;\n   unsigned int num_bits;\n-  bfd_boolean bad_offset = FALSE;\n+  bool bad_offset = false;\n \n   fp_offset = addr & 0x1f;\n   fp_addr = addr - fp_offset;\n@@ -263,10 +263,10 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n   if (fetch_packet_header_based)\n     {\n       if (fp_offset & 0x1)\n-\tbad_offset = TRUE;\n+\tbad_offset = true;\n       if ((fp_offset & 0x3) && (fp_offset >= 28\n \t\t\t\t|| !header.word_compact[fp_offset >> 2]))\n-\tbad_offset = TRUE;\n+\tbad_offset = true;\n       if (fp_offset == 28)\n \t{\n \t  info->bytes_per_chunk = 4;\n@@ -280,7 +280,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n     {\n       num_bits = 32;\n       if (fp_offset & 0x3)\n-\tbad_offset = TRUE;\n+\tbad_offset = true;\n     }\n \n   if (bad_offset)\n@@ -311,7 +311,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n       const tic6x_insn_format *const fmt\n \t= &tic6x_insn_format_table[opc->format];\n       const tic6x_insn_field *creg_field;\n-      bfd_boolean p_bit;\n+      bool p_bit;\n       const char *parallel;\n       const char *cond = \"\";\n       const char *func_unit;\n@@ -325,14 +325,14 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t separating commas and trailing NUL).  */\n       char operands[TIC6X_MAX_OPERANDS][24] = { { 0 } };\n       bfd_vma operands_addresses[TIC6X_MAX_OPERANDS] = { 0 };\n-      bfd_boolean operands_text[TIC6X_MAX_OPERANDS] = { FALSE };\n-      bfd_boolean operands_pcrel[TIC6X_MAX_OPERANDS] = { FALSE };\n+      bool operands_text[TIC6X_MAX_OPERANDS] = { false };\n+      bool operands_pcrel[TIC6X_MAX_OPERANDS] = { false };\n       unsigned int fix;\n       unsigned int num_operands;\n       unsigned int op_num;\n-      bfd_boolean fixed_ok;\n-      bfd_boolean operands_ok;\n-      bfd_boolean have_t = FALSE;\n+      bool fixed_ok;\n+      bool operands_ok;\n+      bool have_t = false;\n \n       if (opc->flags & TIC6X_FLAG_MACRO)\n \tcontinue;\n@@ -384,7 +384,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t  const tic6x_insn_field *cc_field;\n           unsigned int s_value = 0;\n           unsigned int z_value = 0;\n-          bfd_boolean cond_known = FALSE;\n+          bool cond_known = false;\n           static const char *const conds[2][2] =\n             {\n               { \"[a0] \", \"[!a0] \" },\n@@ -400,7 +400,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t      cc_value = tic6x_field_bits (opcode, cc_field);\n \t      s_value = (cc_value & 0x2) >> 1;\n \t      z_value = (cc_value & 0x1);\n-\t      cond_known = TRUE;\n+\t      cond_known = true;\n \t    }\n \t  else\n \t    {\n@@ -424,7 +424,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t}\n \n \t      z_value = tic6x_field_bits (opcode, z_field);\n-\t      cond_known = TRUE;\n+\t      cond_known = true;\n \t    }\n \n           if (!cond_known)\n@@ -437,7 +437,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \n       /* All fixed fields must have matching values; all fields with\n \t restricted ranges must have values within those ranges.  */\n-      fixed_ok = TRUE;\n+      fixed_ok = true;\n       for (fix = 0; fix < opc->num_fixed_fields; fix++)\n \t{\n \t  unsigned int field_bits;\n@@ -455,7 +455,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t  if (field_bits < opc->fixed_fields[fix].min_val\n \t      || field_bits > opc->fixed_fields[fix].max_val)\n \t    {\n-\t      fixed_ok = FALSE;\n+\t      fixed_ok = false;\n \t      break;\n \t    }\n \t}\n@@ -501,10 +501,10 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t  status = info->read_memory_func (fp_addr - 32, fp_prev, 32, info);\n \t  if (status)\n \t    /* No previous instruction to be parallel with.  */\n-\t    p_bit = FALSE;\n+\t    p_bit = false;\n \t  else\n \t    {\n-\t      bfd_boolean prev_header_based;\n+\t      bool prev_header_based;\n \t      tic6x_fetch_packet_header prev_header;\n \n \t      prev_header_based\n@@ -537,8 +537,8 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t  unsigned int fld_num;\n \t  char func_unit_char;\n \t  const char *data_str;\n-\t  bfd_boolean have_areg = FALSE;\n-\t  bfd_boolean have_cross = FALSE;\n+\t  bool have_areg = false;\n+\t  bool have_cross = false;\n \n \t  func_unit_side = (opc->flags & TIC6X_FLAG_SIDE_B_ONLY) ? 2 : 0;\n \t  func_unit_cross = 0;\n@@ -594,19 +594,19 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t\t      opcode, fld_num);\n \t\t      abort ();\n \t\t    }\n-\t\t  have_cross = TRUE;\n+\t\t  have_cross = true;\n \t\t  func_unit_cross = fld_val;\n \t\t  break;\n \n                 case tic6x_coding_rside:\n                   /* If the format has a t field, use it for src/dst register side.  */\n-                  have_t = TRUE;\n+                  have_t = true;\n                   t_val = fld_val;\n                   func_unit_data_side = (t_val ? 2 : 1);\n                   break;\n \n \t\tcase tic6x_coding_areg:\n-\t\t  have_areg = TRUE;\n+\t\t  have_areg = true;\n \t\t  break;\n \n \t\tdefault:\n@@ -711,98 +711,98 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n       /* For each operand there must be one or more fields set based\n \t on that operand, that can together be used to derive the\n \t operand value.  */\n-      operands_ok = TRUE;\n+      operands_ok = true;\n       num_operands = opc->num_operands;\n       for (op_num = 0; op_num < num_operands; op_num++)\n \t{\n \t  unsigned int fld_num;\n \t  unsigned int mem_base_reg = 0;\n-\t  bfd_boolean mem_base_reg_known = FALSE;\n-\t  bfd_boolean mem_base_reg_known_long = FALSE;\n+\t  bool mem_base_reg_known = false;\n+\t  bool mem_base_reg_known_long = false;\n \t  unsigned int mem_offset = 0;\n-\t  bfd_boolean mem_offset_known = FALSE;\n-\t  bfd_boolean mem_offset_known_long = FALSE;\n+\t  bool mem_offset_known = false;\n+\t  bool mem_offset_known_long = false;\n \t  unsigned int mem_mode = 0;\n-\t  bfd_boolean mem_mode_known = FALSE;\n+\t  bool mem_mode_known = false;\n \t  unsigned int mem_scaled = 0;\n-\t  bfd_boolean mem_scaled_known = FALSE;\n+\t  bool mem_scaled_known = false;\n \t  unsigned int crlo = 0;\n-\t  bfd_boolean crlo_known = FALSE;\n+\t  bool crlo_known = false;\n \t  unsigned int crhi = 0;\n-\t  bfd_boolean crhi_known = FALSE;\n-\t  bfd_boolean spmask_skip_operand = FALSE;\n+\t  bool crhi_known = false;\n+\t  bool spmask_skip_operand = false;\n \t  unsigned int fcyc_bits = 0;\n-\t  bfd_boolean prev_sploop_found = FALSE;\n+\t  bool prev_sploop_found = false;\n \n \t  switch (opc->operand_info[op_num].form)\n \t    {\n \t    case tic6x_operand_b15reg:\n \t      /* Fully determined by the functional unit.  */\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"b15\");\n \t      continue;\n \n \t    case tic6x_operand_zreg:\n \t      /* Fully determined by the functional unit.  */\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"%c0\",\n \t\t\t(func_unit_side == 2 ? 'b' : 'a'));\n \t      continue;\n \n \t    case tic6x_operand_retreg:\n \t      /* Fully determined by the functional unit.  */\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"%c3\",\n \t\t\t(func_unit_side == 2 ? 'b' : 'a'));\n \t      continue;\n \n \t    case tic6x_operand_irp:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"irp\");\n \t      continue;\n \n \t    case tic6x_operand_nrp:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"nrp\");\n \t      continue;\n \n \t    case tic6x_operand_ilc:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"ilc\");\n \t      continue;\n \n \t    case tic6x_operand_hw_const_minus_1:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"-1\");\n \t      continue;\n \n \t    case tic6x_operand_hw_const_0:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"0\");\n \t      continue;\n \n \t    case tic6x_operand_hw_const_1:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"1\");\n \t      continue;\n \n \t    case tic6x_operand_hw_const_5:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"5\");\n \t      continue;\n \n \t    case tic6x_operand_hw_const_16:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"16\");\n \t      continue;\n \n \t    case tic6x_operand_hw_const_24:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"24\");\n \t      continue;\n \n \t    case tic6x_operand_hw_const_31:\n-\t      operands_text[op_num] = TRUE;\n+\t      operands_text[op_num] = true;\n \t      snprintf (operands[op_num], 24, \"31\");\n \t      continue;\n \n@@ -844,13 +844,13 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t    {\n \t\t    case tic6x_operand_asm_const:\n \t\t    case tic6x_operand_link_const:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      snprintf (operands[op_num], 24, \"%u\", fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_mem_long:\n \t\t      mem_offset = fld_val;\n-\t\t      mem_offset_known_long = TRUE;\n+\t\t      mem_offset_known_long = true;\n \t\t      break;\n \n \t\t    default:\n@@ -860,12 +860,12 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t  break;\n \n \t\tcase tic6x_coding_lcst_high16:\n-\t\t  operands_text[op_num] = TRUE;\n+\t\t  operands_text[op_num] = true;\n \t\t  snprintf (operands[op_num], 24, \"%u\", fld_val << 16);\n \t\t  break;\n \n                 case tic6x_coding_scst_l3i:\n-\t\t  operands_text[op_num] = TRUE;\n+\t\t  operands_text[op_num] = true;\n                   if (fld_val == 0)\n \t\t    {\n \t\t      signed_fld_val = 8;\n@@ -880,15 +880,15 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t  break;\n \n \t\tcase tic6x_coding_scst:\n-\t\t  operands_text[op_num] = TRUE;\n+\t\t  operands_text[op_num] = true;\n \t\t  signed_fld_val = (signed int) fld_val;\n \t\t  signed_fld_val ^= (1 << (tic6x_field_width (field) - 1));\n \t\t  signed_fld_val -= (1 << (tic6x_field_width (field) - 1));\n \t\t  snprintf (operands[op_num], 24, \"%d\", signed_fld_val);\n \t\t  break;\n \n \t\tcase tic6x_coding_ucst_minus_one:\n-\t\t  operands_text[op_num] = TRUE;\n+\t\t  operands_text[op_num] = true;\n \t\t  snprintf (operands[op_num], 24, \"%u\", fld_val + 1);\n \t\t  break;\n \n@@ -902,21 +902,21 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t    signed_fld_val *= 2;\n \t\t  else\n \t\t    signed_fld_val *= 4;\n-\t\t  operands_pcrel[op_num] = TRUE;\n+\t\t  operands_pcrel[op_num] = true;\n \t\t  operands_addresses[op_num] = fp_addr + signed_fld_val;\n \t\t  break;\n \n \t\tcase tic6x_coding_regpair_msb:\n \t\t  if (opc->operand_info[op_num].form != tic6x_operand_regpair)\n \t\t    abort ();\n-\t\t  operands_text[op_num] = TRUE;\n+\t\t  operands_text[op_num] = true;\n \t\t  snprintf (operands[op_num], 24, \"%c%u:%c%u\",\n \t\t\t    (func_unit_side == 2 ? 'b' : 'a'), (fld_val | 0x1),\n \t\t\t    (func_unit_side == 2 ? 'b' : 'a'), (fld_val | 0x1) - 1);\n \t\t  break;\n \n \t\tcase tic6x_coding_pcrel_half_unsigned:\n-\t\t  operands_pcrel[op_num] = TRUE;\n+\t\t  operands_pcrel[op_num] = true;\n \t\t  operands_addresses[op_num] = fp_addr + 2 * fld_val;\n \t\t  break;\n \n@@ -936,59 +936,59 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t\t  printf (\"opcode %x: operand treg but missing t field\\n\", opcode);\n \t\t\t  abort ();\n \t\t\t}\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n                       reg_side = t_val ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u\", reg_side, reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_reg:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n                       reg_side = (func_unit_side == 2) ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u\", reg_side,  reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_reg_nors:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n                       reg_side = (func_unit_side == 2) ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u\", reg_side, fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_reg_bside:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      snprintf (operands[op_num], 24, \"b%u\", reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_reg_bside_nors:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      snprintf (operands[op_num], 24, \"b%u\", fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_xreg:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n                       reg_side = ((func_unit_side == 2) ^ func_unit_cross) ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u\", reg_side,  reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_dreg:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n                       reg_side = (func_unit_data_side == 2) ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u\", reg_side,  reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_regpair:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      if (fld_val & 1)\n-\t\t\toperands_ok = FALSE;\n+\t\t\toperands_ok = false;\n                       reg_side = (func_unit_side == 2) ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u:%c%u\",\n                                 reg_side, reg_base + fld_val + 1,\n \t\t\t\treg_side, reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_xregpair:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      if (fld_val & 1)\n-\t\t\toperands_ok = FALSE;\n+\t\t\toperands_ok = false;\n                       reg_side = ((func_unit_side == 2) ^ func_unit_cross) ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u:%c%u\",\n \t\t\t\treg_side, reg_base + fld_val + 1,\n@@ -1001,35 +1001,35 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t\t  printf (\"opcode %x: operand tregpair but missing t field\\n\", opcode);\n \t\t\t  abort ();\n \t\t\t}\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      if (fld_val & 1)\n-\t\t\toperands_ok = FALSE;\n+\t\t\toperands_ok = false;\n                       reg_side = t_val ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u:%c%u\",\n \t\t\t\treg_side, reg_base + fld_val + 1,\n \t\t\t\treg_side, reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_dregpair:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      if (fld_val & 1)\n-\t\t\toperands_ok = FALSE;\n+\t\t\toperands_ok = false;\n                       reg_side = (func_unit_data_side) == 2 ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"%c%u:%c%u\",\n \t\t\t\treg_side, reg_base + fld_val + 1,\n \t\t\t\treg_side, reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_mem_deref:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n                       reg_side = func_unit_side == 2 ? 'b' : 'a';\n \t\t      snprintf (operands[op_num], 24, \"*%c%u\", reg_side, reg_base + fld_val);\n \t\t      break;\n \n \t\t    case tic6x_operand_mem_short:\n \t\t    case tic6x_operand_mem_ndw:\n \t\t      mem_base_reg = fld_val;\n-\t\t      mem_base_reg_known = TRUE;\n+\t\t      mem_base_reg_known = true;\n \t\t      break;\n \n \t\t    default:\n@@ -1051,7 +1051,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t\t  abort ();\n \t\t\t}\n \t\t      mem_base_reg = 0x4 | fld_val;\n-\t\t      mem_base_reg_known = TRUE;\n+\t\t      mem_base_reg_known = true;\n \t\t      break;\n \n \t\t    default:\n@@ -1065,14 +1065,14 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t  switch (opc->operand_info[op_num].form)\n \t\t    {\n \t\t    case tic6x_operand_areg:\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      snprintf (operands[op_num], 24, \"b%u\",\n \t\t\t\tfld_val ? 15u : 14u);\n \t\t      break;\n \n \t\t    case tic6x_operand_mem_long:\n \t\t      mem_base_reg = fld_val ? 15u : 14u;\n-\t\t      mem_base_reg_known_long = TRUE;\n+\t\t      mem_base_reg_known_long = true;\n \t\t      break;\n \n \t\t    default:\n@@ -1088,42 +1088,42 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\tcase tic6x_coding_mem_offset_noscale:\n \t\tcase tic6x_coding_mem_offset:\n \t\t  mem_offset = fld_val;\n-\t\t  mem_offset_known = TRUE;\n+\t\t  mem_offset_known = true;\n \t\t  if (num_bits == 16)\n \t\t    {\n-\t\t      mem_mode_known = TRUE;\n+\t\t      mem_mode_known = true;\n \t\t      mem_mode = TIC6X_INSN16_MEM_MODE_VAL (opc->flags);\n-\t\t      mem_scaled_known = TRUE;\n-\t\t      mem_scaled = TRUE;\n+\t\t      mem_scaled_known = true;\n+\t\t      mem_scaled = true;\n \t\t      if (opc->flags & TIC6X_FLAG_INSN16_B15PTR)\n \t\t\t{\n-\t\t\t  mem_base_reg_known = TRUE;\n+\t\t\t  mem_base_reg_known = true;\n \t\t\t  mem_base_reg = 15;\n \t\t\t}\n \t\t      if ( enc->coding_method == tic6x_coding_mem_offset_noscale\n \t\t\t   || enc->coding_method == tic6x_coding_mem_offset_noscale )\n-\t\t\tmem_scaled = FALSE;\n+\t\t\tmem_scaled = false;\n \t\t    }\n \t\t  break;\n \n \t\tcase tic6x_coding_mem_mode:\n \t\t  mem_mode = fld_val;\n-\t\t  mem_mode_known = TRUE;\n+\t\t  mem_mode_known = true;\n \t\t  break;\n \n \t\tcase tic6x_coding_scaled:\n \t\t  mem_scaled = fld_val;\n-\t\t  mem_scaled_known = TRUE;\n+\t\t  mem_scaled_known = true;\n \t\t  break;\n \n \t\tcase tic6x_coding_crlo:\n \t\t  crlo = fld_val;\n-\t\t  crlo_known = TRUE;\n+\t\t  crlo_known = true;\n \t\t  break;\n \n \t\tcase tic6x_coding_crhi:\n \t\t  crhi = fld_val;\n-\t\t  crhi_known = TRUE;\n+\t\t  crhi_known = true;\n \t\t  break;\n \n \t\tcase tic6x_coding_fstg:\n@@ -1132,7 +1132,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t    {\n \t\t      bfd_vma search_fp_addr = fp_addr;\n \t\t      bfd_vma search_fp_offset = fp_offset;\n-\t\t      bfd_boolean search_fp_header_based\n+\t\t      bool search_fp_header_based\n \t\t\t= fetch_packet_header_based;\n \t\t      tic6x_fetch_packet_header search_fp_header = header;\n \t\t      unsigned char search_fp[32];\n@@ -1214,13 +1214,13 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t\t\t  || ((search_opcode & 0x003ffffe)\n \t\t\t\t      == 0x0003e000)))\n \t\t\t    {\n-\t\t\t      prev_sploop_found = TRUE;\n+\t\t\t      prev_sploop_found = true;\n \t\t\t      sploop_ii = ((search_opcode >> 23) & 0x1f) + 1;\n \t\t\t    }\n \t\t\t  else if (search_num_bits == 16\n \t\t\t\t   && (search_opcode & 0x3c7e) == 0x0c66)\n \t\t\t    {\n-\t\t\t      prev_sploop_found = TRUE;\n+\t\t\t      prev_sploop_found = true;\n \t\t\t      sploop_ii\n \t\t\t\t= (((search_opcode >> 7) & 0x7)\n \t\t\t\t   | ((search_opcode >> 11) & 0x8)) + 1;\n@@ -1243,16 +1243,16 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t\t      else if (sploop_ii <= 14)\n \t\t\t\tfcyc_bits = 4;\n \t\t\t      else\n-\t\t\t\tprev_sploop_found = FALSE;\n+\t\t\t\tprev_sploop_found = false;\n \t\t\t    }\n \t\t\t  if (prev_sploop_found)\n \t\t\t    break;\n \t\t\t}\n \t\t    }\n \t\t  if (!prev_sploop_found)\n \t\t    {\n-\t\t      operands_ok = FALSE;\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_ok = false;\n+\t\t      operands_text[op_num] = true;\n \t\t      break;\n \t\t    }\n \t\t  if (fcyc_bits > tic6x_field_width(field))\n@@ -1265,26 +1265,26 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t      int i, t;\n \t\t      for (t = 0, i = fcyc_bits; i < 6; i++)\n \t\t\tt = (t << 1) | ((fld_val >> i) & 1);\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      snprintf (operands[op_num], 24, \"%u\", t);\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      snprintf (operands[op_num], 24, \"%u\",\n \t\t\t\tfld_val & ((1 << fcyc_bits) - 1));\n \t\t    }\n \t\t  break;\n \n \t\tcase tic6x_coding_spmask:\n \t\t  if (fld_val == 0)\n-\t\t    spmask_skip_operand = TRUE;\n+\t\t    spmask_skip_operand = true;\n \t\t  else\n \t\t    {\n \t\t      char *p;\n \t\t      unsigned int i;\n \n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      p = operands[op_num];\n \t\t      for (i = 0; i < 8; i++)\n \t\t\tif (fld_val & (1 << i))\n@@ -1317,7 +1317,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t      printf (\"opcode %x: long access but operands already known ?\\n\", opcode);\n \t\t      abort ();\n \t\t    }\n-\t\t  operands_text[op_num] = TRUE;\n+\t\t  operands_text[op_num] = true;\n \t\t  snprintf (operands[op_num], 24, \"*+b%u(%u)\", mem_base_reg,\n \t\t\t    mem_offset * opc->operand_info[op_num].size);\n \t\t}\n@@ -1329,8 +1329,8 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t{\n \t\t  char side;\n \t\t  char base[4];\n-\t\t  bfd_boolean offset_is_reg;\n-\t\t  bfd_boolean offset_scaled;\n+\t\t  bool offset_is_reg;\n+\t\t  bool offset_scaled;\n \t\t  char offset[4];\n \t\t  char offsetp[6];\n \n@@ -1356,7 +1356,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t\t  == tic6x_operand_mem_ndw)\n \t\t\toffset_scaled = mem_scaled != 0;\n \t\t      else\n-\t\t\toffset_scaled = TRUE;\n+\t\t\toffset_scaled = true;\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -1368,7 +1368,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t\t}\n \t\t      else\n \t\t\t{\n-\t\t\t  offset_scaled = FALSE;\n+\t\t\t  offset_scaled = false;\n \t\t\t  snprintf (offset, 4, \"%u\",\n \t\t\t\t    (mem_offset\n \t\t\t\t     * opc->operand_info[op_num].size));\n@@ -1380,7 +1380,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t  else\n \t\t    snprintf (offsetp, 6, \"(%s)\", offset);\n \n-\t\t  operands_text[op_num] = TRUE;\n+\t\t  operands_text[op_num] = true;\n \t\t  switch (mem_mode & ~4u)\n \t\t    {\n \t\t    case 0:\n@@ -1393,7 +1393,7 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \n \t\t    case 2:\n \t\t    case 3:\n-\t\t      operands_ok = FALSE;\n+\t\t      operands_ok = false;\n \t\t      break;\n \n \t\t    case 8:\n@@ -1456,12 +1456,12 @@ print_insn_tic6x (bfd_vma addr, struct disassemble_info *info)\n \t\t    }\n \t\t  if (crid == tic6x_ctrl_max)\n \t\t    {\n-\t\t      operands_text[op_num] = TRUE;\n-\t\t      operands_ok = FALSE;\n+\t\t      operands_text[op_num] = true;\n+\t\t      operands_ok = false;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      operands_text[op_num] = TRUE;\n+\t\t      operands_text[op_num] = true;\n \t\t      snprintf (operands[op_num], 24, \"%s\",\n \t\t\t\ttic6x_ctrl_table[crid].name);\n \t\t    }"
    },
    {
      "sha": "88bd4512d4a25374e1d9f4a70d63d08da12ec8df",
      "filename": "opcodes/v850-dis.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/v850-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/v850-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/v850-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -85,7 +85,7 @@ get_operand_value (const struct v850_operand *operand,\n \t\t   int bytes_read,\n \t\t   bfd_vma memaddr,\n \t\t   struct disassemble_info * info,\n-\t\t   bfd_boolean noerror,\n+\t\t   bool noerror,\n \t\t   int *invalid)\n {\n   unsigned long value;\n@@ -382,7 +382,7 @@ disassemble (bfd_vma memaddr,\n \t       *opindex_ptr != 0;\n \t       opindex_ptr++, opnum++)\n \t    {\n-\t      bfd_boolean square = FALSE;\n+\t      bool square = false;\n \t      long value;\n \t      int flag;\n \t      char *prefix;\n@@ -428,15 +428,15 @@ disassemble (bfd_vma memaddr,\n \t      if (opnum == 1 && opnum == memop)\n \t\t{\n \t\t  info->fprintf_func (info->stream, \"%s[\", prefix);\n-\t\t  square = TRUE;\n+\t\t  square = true;\n \t\t}\n \t      else if (   (strcmp (\"stc.w\", op->name) == 0\n \t\t\t|| strcmp (\"cache\", op->name) == 0\n \t\t\t|| strcmp (\"pref\",  op->name) == 0)\n \t\t       && opnum == 2 && opnum == memop)\n \t\t{\n \t\t  info->fprintf_func (info->stream, \", [\");\n-\t\t  square = TRUE;\n+\t\t  square = true;\n \t\t}\n \t      else if (   (strcmp (op->name, \"pushsp\") == 0\n \t\t\t|| strcmp (op->name, \"popsp\") == 0\n@@ -451,7 +451,7 @@ disassemble (bfd_vma memaddr,\n \t\t       && opnum == memop)\n \t\t{\n \t\t  info->fprintf_func (info->stream, \"%s[\", prefix);\n-\t\t  square = TRUE;\n+\t\t  square = true;\n \t\t}\n \t      else if (opnum == 2\n \t\t       && (   op->opcode == 0x00e407e0 /* clr1 */\n@@ -461,7 +461,7 @@ disassemble (bfd_vma memaddr,\n \t\t\t   ))\n \t\t{\n \t\t  info->fprintf_func (info->stream, \", %s[\", prefix);\n-\t\t  square = TRUE;\n+\t\t  square = true;\n \t\t}\n \t      else if (opnum > 1)\n \t\tinfo->fprintf_func (info->stream, \", %s\", prefix);"
    },
    {
      "sha": "e218d4969cacda45b0030f65f85a4503e2995369",
      "filename": "opcodes/vax-dis.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/vax-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/vax-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/vax-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -116,7 +116,7 @@ static bfd_vma *     entry_addr = NULL;\n    entry addresses, which can be useful to disassemble ROM images, since\n    there's no symbol table.  Returns TRUE upon success, FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n parse_disassembler_options (const char *options)\n {\n   const char * entry_switch = \"entry:\";\n@@ -137,13 +137,13 @@ parse_disassembler_options (const char *options)\n \t}\n \n       if (entry_addr == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       entry_addr[entry_addr_occupied_slots] = bfd_scan_vma (options, NULL, 0);\n       entry_addr_occupied_slots ++;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n #if 0 /* FIXME:  Ideally the disassembler should have target specific\n@@ -179,7 +179,7 @@ free_entry_array (void)\n    table at all.  Forced entry points can be given by supplying several\n    -M options to objdump: -M entry:0xffbb7730.  */\n \n-static bfd_boolean\n+static bool\n is_function_entry (struct disassemble_info *info, bfd_vma addr)\n {\n   unsigned int i;\n@@ -189,30 +189,30 @@ is_function_entry (struct disassemble_info *info, bfd_vma addr)\n       && info->symbols[0]\n       && (info->symbols[0]->flags & (BSF_FUNCTION | BSF_SYNTHETIC))\n       && addr == bfd_asymbol_value (info->symbols[0]))\n-    return TRUE;\n+    return true;\n \n   /* Check for forced function entry address.  */\n   for (i = entry_addr_occupied_slots; i--;)\n     if (entry_addr[i] == addr)\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Check if the given address is the last longword of a PLT entry.\n    This longword is data and depending on the value it may interfere\n    with disassembly of further PLT entries.  We make use of the fact\n    PLT symbols are marked BSF_SYNTHETIC.  */\n-static bfd_boolean\n+static bool\n is_plt_tail (struct disassemble_info *info, bfd_vma addr)\n {\n   if (info->symbols\n       && info->symbols[0]\n       && (info->symbols[0]->flags & BSF_SYNTHETIC)\n       && addr == bfd_asymbol_value (info->symbols[0]) + 8)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n static int\n@@ -388,7 +388,7 @@ print_insn_arg (const char *d,\n int\n print_insn_vax (bfd_vma memaddr, disassemble_info *info)\n {\n-  static bfd_boolean parsed_disassembler_options = FALSE;\n+  static bool parsed_disassembler_options = false;\n   const struct vot *votp;\n   const char *argp;\n   unsigned char *arg;\n@@ -405,7 +405,7 @@ print_insn_vax (bfd_vma memaddr, disassemble_info *info)\n       parse_disassembler_options (info->disassembler_options);\n \n       /* To avoid repeated parsing of these options.  */\n-      parsed_disassembler_options = TRUE;\n+      parsed_disassembler_options = true;\n     }\n \n   if (OPCODES_SIGSETJMP (priv.bailout) != 0)"
    },
    {
      "sha": "f207cb9a9c3dd1c5beec72bce68858400235cd31",
      "filename": "opcodes/wasm32-dis.c",
      "status": "modified",
      "additions": 29,
      "deletions": 29,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/wasm32-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/wasm32-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/wasm32-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -77,8 +77,8 @@ enum wasm_class\n \n struct wasm32_private_data\n {\n-  bfd_boolean print_registers;\n-  bfd_boolean print_well_known_globals;\n+  bool print_registers;\n+  bool print_well_known_globals;\n \n   /* Limit valid symbols to those with a given prefix.  */\n   const char *section_prefix;\n@@ -121,9 +121,9 @@ parse_wasm32_disassembler_options (struct disassemble_info *info,\n   while (opts != NULL)\n     {\n       if (startswith (opts, \"registers\"))\n-        private->print_registers = TRUE;\n+        private->print_registers = true;\n       else if (startswith (opts, \"globals\"))\n-        private->print_well_known_globals = TRUE;\n+        private->print_well_known_globals = true;\n \n       opts = strchr (opts, ',');\n       if (opts)\n@@ -135,24 +135,24 @@ parse_wasm32_disassembler_options (struct disassemble_info *info,\n    are unhelpful to print, and arguments to a \"call\" insn, which we\n    want to be in a section matching a given prefix.  */\n \n-static bfd_boolean\n+static bool\n wasm32_symbol_is_valid (asymbol *sym,\n                         struct disassemble_info *info)\n {\n   struct wasm32_private_data *private_data = info->private_data;\n \n   if (sym == NULL)\n-    return FALSE;\n+    return false;\n \n   if (strcmp(sym->section->name, \"*ABS*\") == 0)\n-    return FALSE;\n+    return false;\n \n   if (private_data && private_data->section_prefix != NULL\n       && strncmp (sym->section->name, private_data->section_prefix,\n                   strlen (private_data->section_prefix)))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Initialize the disassembler structures for INFO.  */\n@@ -164,8 +164,8 @@ disassemble_init_wasm32 (struct disassemble_info *info)\n     {\n       static struct wasm32_private_data private;\n \n-      private.print_registers = FALSE;\n-      private.print_well_known_globals = FALSE;\n+      private.print_registers = false;\n+      private.print_well_known_globals = false;\n       private.section_prefix = NULL;\n \n       info->private_data = &private;\n@@ -189,11 +189,11 @@ disassemble_init_wasm32 (struct disassemble_info *info)\n    wasm_read_leb128 ().  */\n \n static uint64_t\n-wasm_read_leb128 (bfd_vma                   pc,\n-                  struct disassemble_info * info,\n-                  bfd_boolean *             error_return,\n-                  unsigned int *            length_return,\n-                  bfd_boolean               sign)\n+wasm_read_leb128 (bfd_vma pc,\n+                  struct disassemble_info *info,\n+                  bool *error_return,\n+                  unsigned int *length_return,\n+                  bool sign)\n {\n   uint64_t result = 0;\n   unsigned int num_read = 0;\n@@ -288,7 +288,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n   uint64_t val;\n   int len;\n   unsigned int bytes_read;\n-  bfd_boolean error;\n+  bool error;\n \n   if (info->read_memory_func (pc, buffer, 1, info))\n     return -1;\n@@ -312,7 +312,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n \n   if (op->clas == wasm_typed)\n     {\n-      val = wasm_read_leb128 (pc + len, info, &error, &bytes_read, FALSE);\n+      val = wasm_read_leb128 (pc + len, info, &error, &bytes_read, false);\n       if (error)\n \treturn -1;\n       len += bytes_read;\n@@ -357,7 +357,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n       {\n \tuint32_t target_count, i;\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \ttarget_count = val;\n \tif (error || target_count != val || target_count == (uint32_t) -1)\n \t  return -1;\n@@ -367,7 +367,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n \t  {\n \t    uint32_t target;\n \t    val = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\t    FALSE);\n+\t\t\t\t    false);\n \t    target = val;\n \t    if (error || target != val)\n \t      return -1;\n@@ -382,7 +382,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n       {\n \tuint32_t depth;\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \tdepth = val;\n \tif (error || depth != val)\n \t  return -1;\n@@ -396,7 +396,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n \n     case wasm_constant_i32:\n     case wasm_constant_i64:\n-      val = wasm_read_leb128 (pc + len, info, &error, &bytes_read, TRUE);\n+      val = wasm_read_leb128 (pc + len, info, &error, &bytes_read, true);\n       if (error)\n \treturn -1;\n       len += bytes_read;\n@@ -433,7 +433,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n       {\n \tuint32_t function_index;\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \tfunction_index = val;\n \tif (error || function_index != val)\n \t  return -1;\n@@ -449,14 +449,14 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n       {\n \tuint32_t type_index, xtra_index;\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \ttype_index = val;\n \tif (error || type_index != val)\n \t  return -1;\n \tlen += bytes_read;\n \tprin (stream, \" %u\", type_index);\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \txtra_index = val;\n \tif (error || xtra_index != val)\n \t  return -1;\n@@ -471,7 +471,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n       {\n \tuint32_t local_index;\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \tlocal_index = val;\n \tif (error || local_index != val)\n \t  return -1;\n@@ -509,7 +509,7 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n       {\n \tuint32_t reserved_size;\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \treserved_size = val;\n \tif (error || reserved_size != val)\n \t  return -1;\n@@ -523,13 +523,13 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n       {\n \tuint32_t flags, offset;\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \tflags = val;\n \tif (error || flags != val)\n \t  return -1;\n \tlen += bytes_read;\n \tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n-\t\t\t\tFALSE);\n+\t\t\t\tfalse);\n \toffset = val;\n \tif (error || offset != val)\n \t  return -1;"
    },
    {
      "sha": "64c9a4ed4e054785545b0266f52ac3b2903dcc3a",
      "filename": "opcodes/xtensa-dis.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/xtensa-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/78933a4ad9ae9c2e274d41e6b3036ea582c47810/opcodes/xtensa-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/xtensa-dis.c?ref=78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "patch": "@@ -315,7 +315,7 @@ print_insn_xtensa (bfd_vma memaddr, struct disassemble_info *info)\n \t  priv.insn_table_entry_count =\n \t    xtensa_read_table_entries (abfd, section,\n \t\t\t\t       &priv.insn_table_entries,\n-\t\t\t\t       XTENSA_PROP_SEC_NAME, FALSE);\n+\t\t\t\t       XTENSA_PROP_SEC_NAME, false);\n \t  if (priv.insn_table_entry_count == 0)\n \t    {\n \t      free (priv.insn_table_entries);\n@@ -324,7 +324,7 @@ print_insn_xtensa (bfd_vma memaddr, struct disassemble_info *info)\n \t      priv.insn_table_entry_count =\n \t\txtensa_read_table_entries (abfd, section,\n \t\t\t\t\t   &priv.insn_table_entries,\n-\t\t\t\t\t   XTENSA_INSN_SEC_NAME, FALSE);\n+\t\t\t\t\t   XTENSA_INSN_SEC_NAME, false);\n \t    }\n \t  priv.insn_table_cur_idx = 0;\n \t  xtensa_coalesce_insn_tables (&priv);"
    }
  ]
}