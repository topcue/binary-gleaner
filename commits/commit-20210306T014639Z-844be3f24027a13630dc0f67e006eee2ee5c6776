{
  "sha": "844be3f24027a13630dc0f67e006eee2ee5c6776",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODQ0YmUzZjI0MDI3YTEzNjMwZGMwZjY3ZTAwNmVlZTJlZTVjNjc3Ng==",
  "commit": {
    "author": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2021-03-05T23:31:26Z"
    },
    "committer": {
      "name": "Weimin Pan",
      "email": "weimin.pan@oracle.com",
      "date": "2021-03-06T01:46:39Z"
    },
    "message": "CTF: set up debug info for function arguments\n\nAdded this support in read_func_kind_type after gcc started generating\nCTF for function arguments.\n\nReplaced XNEW with std::vector and NULL with nullptr.\n\nExpanded gdb.base/ctf-ptype.exp to test function arguments. Also fixed\nsome typos.\n\ngdb/ChangeLog:\n\n\t* ctfread.c (read_func_kind_type): Set up function arguments.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.base/ctf-ptype.exp: Add function tests and fix typos.",
    "tree": {
      "sha": "b15161035fc1b169ce248c285e7652b0911bfd0c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b15161035fc1b169ce248c285e7652b0911bfd0c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/844be3f24027a13630dc0f67e006eee2ee5c6776",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/844be3f24027a13630dc0f67e006eee2ee5c6776",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/844be3f24027a13630dc0f67e006eee2ee5c6776",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/844be3f24027a13630dc0f67e006eee2ee5c6776/comments",
  "author": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "wmwpan",
    "id": 50341885,
    "node_id": "MDQ6VXNlcjUwMzQxODg1",
    "avatar_url": "https://avatars.githubusercontent.com/u/50341885?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/wmwpan",
    "html_url": "https://github.com/wmwpan",
    "followers_url": "https://api.github.com/users/wmwpan/followers",
    "following_url": "https://api.github.com/users/wmwpan/following{/other_user}",
    "gists_url": "https://api.github.com/users/wmwpan/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/wmwpan/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/wmwpan/subscriptions",
    "organizations_url": "https://api.github.com/users/wmwpan/orgs",
    "repos_url": "https://api.github.com/users/wmwpan/repos",
    "events_url": "https://api.github.com/users/wmwpan/events{/privacy}",
    "received_events_url": "https://api.github.com/users/wmwpan/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "019989fdf14506c72e1e5d5ef1604ef343a44ac2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/019989fdf14506c72e1e5d5ef1604ef343a44ac2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/019989fdf14506c72e1e5d5ef1604ef343a44ac2"
    }
  ],
  "stats": {
    "total": 170,
    "additions": 109,
    "deletions": 61
  },
  "files": [
    {
      "sha": "76849f6a8407562599575e271bcf2458a465b60e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/844be3f24027a13630dc0f67e006eee2ee5c6776/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/844be3f24027a13630dc0f67e006eee2ee5c6776/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=844be3f24027a13630dc0f67e006eee2ee5c6776",
      "patch": "@@ -1,3 +1,7 @@\n+2021-03-06  Weimin Pan  <weimin.pan@oracle.com>\n+\n+\t* ctfread.c (read_func_kind_type): Set up function arguments.\n+\n 2021-03-05  Craig Blackmore  <craig.blackmore@embecosm.com>\n \t    Andrew Burgess  <andrew.burgess@embecosm.com>\n "
    },
    {
      "sha": "dfd543a39421fd7c3547d35bb6f3b78c5454497f",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 85,
      "deletions": 58,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/844be3f24027a13630dc0f67e006eee2ee5c6776/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/844be3f24027a13630dc0f67e006eee2ee5c6776/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=844be3f24027a13630dc0f67e006eee2ee5c6776",
      "patch": "@@ -99,7 +99,7 @@ struct ctf_fp_info\n /* Cleanup function for the ctf_dict_key data.  */\n ctf_fp_info::~ctf_fp_info ()\n {\n-  if (!fp)\n+  if (fp == nullptr)\n     return;\n \n   ctf_archive_t *arc = ctf_get_arc (fp);\n@@ -258,15 +258,15 @@ get_tid_type (struct objfile *of, ctf_id_t tid)\n \n   htab = (htab_t) ctf_tid_key.get (of);\n   if (htab == NULL)\n-    return NULL;\n+    return nullptr;\n \n   ids.tid = tid;\n-  ids.type = NULL;\n+  ids.type = nullptr;\n   slot = (struct ctf_tid_and_type *) htab_find (htab, &ids);\n   if (slot)\n     return slot->type;\n   else\n-    return NULL;\n+    return nullptr;\n }\n \n /* Return the size of storage in bits for INTEGER, FLOAT, or ENUM.  */\n@@ -292,7 +292,7 @@ set_symbol_address (struct objfile *of, struct symbol *sym, const char *name)\n {\n   struct bound_minimal_symbol msym;\n \n-  msym = lookup_minimal_symbol (name, NULL, of);\n+  msym = lookup_minimal_symbol (name, nullptr, of);\n   if (msym.minsym != NULL)\n     {\n       SET_SYMBOL_VALUE_ADDRESS (sym, BMSYMBOL_VALUE_ADDRESS (msym));\n@@ -339,7 +339,7 @@ ctf_init_float_type (struct objfile *objfile,\n   struct type *type;\n \n   format = gdbarch_floatformat_for_type (gdbarch, name_hint, bits);\n-  if (format != NULL)\n+  if (format != nullptr)\n     type = init_float_type (objfile, bits, name, format);\n   else\n     type = init_type (objfile, TYPE_CODE_ERROR, bits, name);\n@@ -369,10 +369,10 @@ ctf_add_member_cb (const char *name,\n \n   kind = ctf_type_kind (ccp->fp, tid);\n   t = get_tid_type (ccp->of, tid);\n-  if (t == NULL)\n+  if (t == nullptr)\n     {\n       t = read_type_record (ccp, tid);\n-      if (t == NULL)\n+      if (t == nullptr)\n \t{\n \t  complaint (_(\"ctf_add_member_cb: %s has NO type (%ld)\"), name, tid);\n \t  t = objfile_type (ccp->of)->builtin_error;\n@@ -405,11 +405,11 @@ ctf_add_enum_member_cb (const char *name, int enum_value, void *arg)\n \n   fp = &new_field.field;\n   FIELD_NAME (*fp) = name;\n-  fp->set_type (NULL);\n+  fp->set_type (nullptr);\n   SET_FIELD_ENUMVAL (*fp, enum_value);\n   FIELD_BITSIZE (*fp) = 0;\n \n-  if (name != NULL)\n+  if (name != nullptr)\n     {\n       struct symbol *sym = new (&ccp->of->objfile_obstack) symbol;\n       OBJSTAT (ccp->of, n_syms++);\n@@ -435,10 +435,10 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n {\n   struct objfile *objfile = ccp->of;\n   ctf_dict_t *fp = ccp->fp;\n-  struct symbol *sym = NULL;\n+  struct symbol *sym = nullptr;\n \n   gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n-  if (name != NULL)\n+  if (name != nullptr)\n     {\n       sym = new (&objfile->objfile_obstack) symbol;\n       OBJSTAT (objfile, n_syms++);\n@@ -448,7 +448,7 @@ new_symbol (struct ctf_context *ccp, struct type *type, ctf_id_t tid)\n       SYMBOL_DOMAIN (sym) = VAR_DOMAIN;\n       SYMBOL_ACLASS_INDEX (sym) = LOC_OPTIMIZED_OUT;\n \n-      if (type != NULL)\n+      if (type != nullptr)\n \tSYMBOL_TYPE (sym) = type;\n \n       uint32_t kind = ctf_type_kind (fp, tid);\n@@ -499,22 +499,22 @@ read_base_type (struct ctf_context *ccp, ctf_id_t tid)\n   struct objfile *of = ccp->of;\n   ctf_dict_t *fp = ccp->fp;\n   ctf_encoding_t cet;\n-  struct type *type = NULL;\n+  struct type *type = nullptr;\n   char *name;\n   uint32_t kind;\n \n   if (ctf_type_encoding (fp, tid, &cet))\n     {\n       complaint (_(\"ctf_type_encoding read_base_type failed - %s\"),\n \t\t ctf_errmsg (ctf_errno (fp)));\n-      return NULL;\n+      return nullptr;\n     }\n \n   gdb::unique_xmalloc_ptr<char> copied_name (ctf_type_aname_raw (fp, tid));\n-  if (copied_name == NULL || strlen (copied_name.get ()) == 0)\n+  if (copied_name == nullptr || strlen (copied_name.get ()) == 0)\n     {\n       name = ctf_type_aname (fp, tid);\n-      if (name == NULL)\n+      if (name == nullptr)\n \tcomplaint (_(\"ctf_type_aname read_base_type failed - %s\"),\n \t\t   ctf_errmsg (ctf_errno (fp)));\n     }\n@@ -566,7 +566,7 @@ read_base_type (struct ctf_context *ccp, ctf_id_t tid)\n       type = init_type (of, TYPE_CODE_ERROR, cet.cte_bits, name);\n     }\n \n-  if (name != NULL && strcmp (name, \"char\") == 0)\n+  if (name != nullptr && strcmp (name, \"char\") == 0)\n     type->set_has_no_signedness (true);\n \n   return set_tid_type (of, tid, type);\n@@ -599,7 +599,7 @@ read_structure_type (struct ctf_context *ccp, ctf_id_t tid)\n   type = alloc_type (of);\n \n   gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n-  if (name != NULL && strlen (name.get() ) != 0)\n+  if (name != nullptr && strlen (name.get ()) != 0)\n     type->set_name (obstack_strdup (&of->objfile_obstack, name.get ()));\n \n   kind = ctf_type_kind (fp, tid);\n@@ -651,13 +651,14 @@ read_func_kind_type (struct ctf_context *ccp, ctf_id_t tid)\n {\n   struct objfile *of = ccp->of;\n   ctf_dict_t *fp = ccp->fp;\n-  struct type *type, *rettype;\n+  struct type *type, *rettype, *atype;\n   ctf_funcinfo_t cfi;\n+  uint32_t argc;\n \n   type = alloc_type (of);\n \n   gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n-  if (name != NULL && strlen (name.get ()) != 0)\n+  if (name != nullptr && strlen (name.get ()) != 0)\n     type->set_name (obstack_strdup (&of->objfile_obstack, name.get ()));\n \n   type->set_code (TYPE_CODE_FUNC);\n@@ -666,6 +667,32 @@ read_func_kind_type (struct ctf_context *ccp, ctf_id_t tid)\n   TYPE_TARGET_TYPE (type) = rettype;\n   set_type_align (type, ctf_type_align (fp, tid));\n \n+  /* Set up function's arguments.  */\n+  argc = cfi.ctc_argc;\n+  type->set_num_fields (argc);\n+  if ((cfi.ctc_flags & CTF_FUNC_VARARG) != 0)\n+    type->set_has_varargs (true);\n+\n+  if (argc != 0)\n+    {\n+      std::vector<ctf_id_t> argv (argc);\n+      if (ctf_func_type_args (fp, tid, argc, argv.data ()) == CTF_ERR)\n+\treturn nullptr;\n+\n+      type->set_fields\n+\t((struct field *) TYPE_ZALLOC (type, argc * sizeof (struct field)));\n+      struct type *void_type = objfile_type (of)->builtin_void;\n+      /* If failed to find the argument type, fill it with void_type.  */\n+      for (int iparam = 0; iparam < argc; iparam++)\n+\t{\n+\t  atype = get_tid_type (of, argv[iparam]);\n+\t  if (atype != nullptr)\n+\t    type->field (iparam).set_type (atype);\n+\t  else\n+\t    type->field (iparam).set_type (void_type);\n+\t}\n+    }\n+\n   return set_tid_type (of, tid, type);\n }\n \n@@ -683,7 +710,7 @@ read_enum_type (struct ctf_context *ccp, ctf_id_t tid)\n   type = alloc_type (of);\n \n   gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (fp, tid));\n-  if (name != NULL && strlen (name.get ()) != 0)\n+  if (name != nullptr && strlen (name.get ()) != 0)\n     type->set_name (obstack_strdup (&of->objfile_obstack, name.get ()));\n \n   type->set_code (TYPE_CODE_ENUM);\n@@ -740,7 +767,7 @@ add_array_cv_type (struct ctf_context *ccp,\n   el_type = TYPE_TARGET_TYPE (inner_array);\n   cnst |= TYPE_CONST (el_type);\n   voltl |= TYPE_VOLATILE (el_type);\n-  TYPE_TARGET_TYPE (inner_array) = make_cv_type (cnst, voltl, el_type, NULL);\n+  TYPE_TARGET_TYPE (inner_array) = make_cv_type (cnst, voltl, el_type, nullptr);\n \n   return set_tid_type (ccp->of, tid, base_type);\n }\n@@ -760,15 +787,15 @@ read_array_type (struct ctf_context *ccp, ctf_id_t tid)\n     {\n       complaint (_(\"ctf_array_info read_array_type failed - %s\"),\n \t\t ctf_errmsg (ctf_errno (fp)));\n-      return NULL;\n+      return nullptr;\n     }\n \n   element_type = get_tid_type (objfile, ar.ctr_contents);\n-  if (element_type == NULL)\n-    return NULL;\n+  if (element_type == nullptr)\n+    return nullptr;\n \n   idx_type = get_tid_type (objfile, ar.ctr_index);\n-  if (idx_type == NULL)\n+  if (idx_type == nullptr)\n     idx_type = objfile_type (objfile)->builtin_int;\n \n   range_type = create_static_range_type (NULL, idx_type, 0, ar.ctr_nelems - 1);\n@@ -796,10 +823,10 @@ read_const_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   struct type *base_type, *cv_type;\n \n   base_type = get_tid_type (objfile, btid);\n-  if (base_type == NULL)\n+  if (base_type == nullptr)\n     {\n       base_type = read_type_record (ccp, btid);\n-      if (base_type == NULL)\n+      if (base_type == nullptr)\n \t{\n \t  complaint (_(\"read_const_type: NULL base type (%ld)\"), btid);\n \t  base_type = objfile_type (objfile)->builtin_error;\n@@ -820,10 +847,10 @@ read_volatile_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   struct type *base_type, *cv_type;\n \n   base_type = get_tid_type (objfile, btid);\n-  if (base_type == NULL)\n+  if (base_type == nullptr)\n     {\n       base_type = read_type_record (ccp, btid);\n-      if (base_type == NULL)\n+      if (base_type == nullptr)\n \t{\n \t  complaint (_(\"read_volatile_type: NULL base type (%ld)\"), btid);\n \t  base_type = objfile_type (objfile)->builtin_error;\n@@ -846,10 +873,10 @@ read_restrict_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   struct type *base_type, *cv_type;\n \n   base_type = get_tid_type (objfile, btid);\n-  if (base_type == NULL)\n+  if (base_type == nullptr)\n     {\n       base_type = read_type_record (ccp, btid);\n-      if (base_type == NULL)\n+      if (base_type == nullptr)\n \t{\n \t  complaint (_(\"read_restrict_type: NULL base type (%ld)\"), btid);\n \t  base_type = objfile_type (objfile)->builtin_error;\n@@ -876,7 +903,7 @@ read_typedef_type (struct ctf_context *ccp, ctf_id_t tid,\n   if (target_type != this_type)\n     TYPE_TARGET_TYPE (this_type) = target_type;\n   else\n-    TYPE_TARGET_TYPE (this_type) = NULL;\n+    TYPE_TARGET_TYPE (this_type) = nullptr;\n \n   this_type->set_target_is_stub (TYPE_TARGET_TYPE (this_type) != nullptr);\n \n@@ -892,10 +919,10 @@ read_pointer_type (struct ctf_context *ccp, ctf_id_t tid, ctf_id_t btid)\n   struct type *target_type, *type;\n \n   target_type = get_tid_type (of, btid);\n-  if (target_type == NULL)\n+  if (target_type == nullptr)\n     {\n       target_type = read_type_record (ccp, btid);\n-      if (target_type == NULL)\n+      if (target_type == nullptr)\n \t{\n \t  complaint (_(\"read_pointer_type: NULL target type (%ld)\"), btid);\n \t  target_type = objfile_type (ccp->of)->builtin_error;\n@@ -915,7 +942,7 @@ read_type_record (struct ctf_context *ccp, ctf_id_t tid)\n {\n   ctf_dict_t *fp = ccp->fp;\n   uint32_t kind;\n-  struct type *type = NULL;\n+  struct type *type = nullptr;\n   ctf_id_t btid;\n \n   kind = ctf_type_kind (fp, tid);\n@@ -981,7 +1008,7 @@ ctf_add_type_cb (ctf_id_t tid, void *arg)\n \n   /* Check if tid's type has already been defined.  */\n   type = get_tid_type (ccp->of, tid);\n-  if (type != NULL)\n+  if (type != nullptr)\n     return 0;\n \n   ctf_id_t btid = ctf_type_reference (ccp->fp, tid);\n@@ -1041,7 +1068,7 @@ static int\n ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n {\n   struct ctf_context *ccp = (struct ctf_context *) arg;\n-  struct symbol *sym = NULL;\n+  struct symbol *sym = nullptr;\n   struct type *type;\n   uint32_t kind;\n \n@@ -1051,7 +1078,7 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n   switch (kind)\n     {\n       case CTF_K_FUNCTION:\n-\tif (name && !strcmp(name, \"main\"))\n+\tif (name != nullptr && strcmp (name, \"main\") == 0)\n \t  set_objfile_main_name (ccp->of, name, language_c);\n \tbreak;\n       case CTF_K_INTEGER:\n@@ -1071,7 +1098,7 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n       case CTF_K_STRUCT:\n       case CTF_K_UNION:\n       case CTF_K_ENUM:\n-\tif (type == NULL)\n+\tif (type == nullptr)\n \t{\n \t  complaint (_(\"ctf_add_var_cb: %s has NO type (%ld)\"), name, id);\n \t  type = objfile_type (ccp->of)->builtin_error;\n@@ -1089,7 +1116,7 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n \tbreak;\n     }\n \n-  if (sym)\n+  if (sym != nullptr)\n     set_symbol_address (ccp->of, sym, name);\n \n   return 0;\n@@ -1105,11 +1132,11 @@ add_stt_obj (struct ctf_context *ccp, unsigned long idx)\n   ctf_id_t tid;\n \n   if ((tid = ctf_lookup_by_symbol (ccp->fp, idx)) == CTF_ERR)\n-    return NULL;\n+    return nullptr;\n \n   type = get_tid_type (ccp->of, tid);\n-  if (type == NULL)\n-    return NULL;\n+  if (type == nullptr)\n+    return nullptr;\n \n   sym = new_symbol (ccp, type, tid);\n \n@@ -1130,19 +1157,19 @@ add_stt_func (struct ctf_context *ccp, unsigned long idx)\n   struct type *void_type = objfile_type (ccp->of)->builtin_void;\n \n   if (ctf_func_info (ccp->fp, idx, &finfo) == CTF_ERR)\n-    return NULL;\n+    return nullptr;\n \n   argc = finfo.ctc_argc;\n   if (ctf_func_args (ccp->fp, idx, argc, argv) == CTF_ERR)\n-    return NULL;\n+    return nullptr;\n \n   gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (ccp->fp, idx));\n-  if (name == NULL)\n-    return NULL;\n+  if (name == nullptr)\n+    return nullptr;\n \n   tid = ctf_lookup_by_symbol (ccp->fp, idx);\n   ftype = get_tid_type (ccp->of, tid);\n-  if (finfo.ctc_flags & CTF_FUNC_VARARG)\n+  if ((finfo.ctc_flags & CTF_FUNC_VARARG) != 0)\n     ftype->set_has_varargs (true);\n   ftype->set_num_fields (argc);\n \n@@ -1164,7 +1191,7 @@ add_stt_func (struct ctf_context *ccp, unsigned long idx)\n \n   sym = new_symbol (ccp, ftype, tid);\n   rettyp = get_tid_type (ccp->of, finfo.ctc_return);\n-  if (rettyp != NULL)\n+  if (rettyp != nullptr)\n     SYMBOL_TYPE (sym) = rettyp;\n   else\n     SYMBOL_TYPE (sym) = void_type;\n@@ -1195,7 +1222,7 @@ ctf_start_symtab (ctf_psymtab *pst,\n \n   ccp = pst->context;\n   ccp->builder = new buildsym_compunit\n-\t\t       (of, of->original_name, NULL,\n+\t\t       (of, of->original_name, nullptr,\n \t\t       language_c, text_offset);\n   ccp->builder->record_debugformat (\"ctf\");\n }\n@@ -1214,7 +1241,7 @@ ctf_end_symtab (ctf_psymtab *pst,\n   struct compunit_symtab *result\n     = ccp->builder->end_symtab (end_addr, section);\n   delete ccp->builder;\n-  ccp->builder = NULL;\n+  ccp->builder = nullptr;\n   return result;\n }\n \n@@ -1245,14 +1272,14 @@ ctf_psymtab::expand_psymtab (struct objfile *objfile)\n   for (unsigned long i = 0; ; i++)\n     {\n       sym = add_stt_obj (ccp, i);\n-      if (sym == NULL)\n+      if (sym == nullptr)\n \t{\n \t  if (ctf_errno (ccp->fp) == EINVAL\n \t      || ctf_errno (ccp->fp) == ECTF_NOSYMTAB)\n \t    break;\n \t  sym = add_stt_func (ccp, i);\n \t}\n-      if (sym == NULL)\n+      if (sym == nullptr)\n \tcontinue;\n \n       set_symbol_address (ccp->of, sym, sym->linkage_name ());\n@@ -1339,7 +1366,7 @@ ctf_psymtab_type_cb (ctf_id_t tid, void *arg)\n \n   ccp = (struct ctf_context *) arg;\n   gdb::unique_xmalloc_ptr<char> name (ctf_type_aname_raw (ccp->fp, tid));\n-  if (name == NULL || strlen (name.get ()) == 0)\n+  if (name == nullptr || strlen (name.get ()) == 0)\n     return 0;\n \n   domain_enum domain = UNDEF_DOMAIN;\n@@ -1478,12 +1505,12 @@ elfctf_build_psymtabs (struct objfile *of)\n   int err;\n \n   ctf_archive_t *arc = ctf_bfdopen (abfd, &err);\n-  if (arc == NULL)\n+  if (arc == nullptr)\n     error (_(\"ctf_bfdopen failed on %s - %s\"),\n \t   bfd_get_filename (abfd), ctf_errmsg (err));\n \n   ctf_dict_t *fp = ctf_dict_open (arc, NULL, &err);\n-  if (fp == NULL)\n+  if (fp == nullptr)\n     error (_(\"ctf_dict_open failed on %s - %s\"),\n \t   bfd_get_filename (abfd), ctf_errmsg (err));\n   ctf_dict_key.emplace (of, fp);"
    },
    {
      "sha": "9e1d61f726ad14dfc4d3cdd1a21adcced2a7d833",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/844be3f24027a13630dc0f67e006eee2ee5c6776/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/844be3f24027a13630dc0f67e006eee2ee5c6776/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=844be3f24027a13630dc0f67e006eee2ee5c6776",
      "patch": "@@ -1,3 +1,7 @@\n+2021-03-06  Weimin Pan  <weimin.pan@oracle.com>\n+\n+\t* gdb.base/ctf-ptype.exp: Add function tests and fix typos.\n+\n 2021-03-03  Markus Metzger  <markus.t.metzger@intel.com>\n \n \t* gdb.btrace/rn-dl-bind.exp: Add ldflags=-Wl,-z,lazy."
    },
    {
      "sha": "056f7129f420160b092c28b18ccaba008035132f",
      "filename": "gdb/testsuite/gdb.base/ctf-ptype.exp",
      "status": "modified",
      "additions": 16,
      "deletions": 3,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/844be3f24027a13630dc0f67e006eee2ee5c6776/gdb/testsuite/gdb.base/ctf-ptype.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/844be3f24027a13630dc0f67e006eee2ee5c6776/gdb/testsuite/gdb.base/ctf-ptype.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/ctf-ptype.exp?ref=844be3f24027a13630dc0f67e006eee2ee5c6776",
      "patch": "@@ -63,10 +63,10 @@ gdb_test \"ptype struct t_struct\" \"type = struct t_struct \\{.*\\[\\r\\n\\]    (unsign\n \n # Test the equivalence between '.' and '->' for struct member references.\n \n-if [gdb_test \"ptype v_t_struct_p.v_float_member\"\t\"type = float\"]<0 then {\n+if [gdb_test \"ptype v_struct1.v_float_member\"\t\"type = float\"]<0 then {\n     return -1\n }\n-if [gdb_test \"ptype v_t_struct_p->v_float_member\"\t\"type = float\"]<0 then {\n+if [gdb_test \"ptype v_struct1->v_float_member\"\t\"type = float\"]<0 then {\n     return -1\n }\n if [gdb_test \"ptype v_t_struct_p.v_float_member\"\t\"type = float\"]<0 then {\n@@ -211,7 +211,7 @@ gdb_test \"ptype the_highest\" \\\n \n gdb_test \"ptype the_highest.anonymous_level_1\" \\\n          \"type = struct \\{.*\\[\\r\\n\\] *int b;.*\\[\\r\\n\\] *struct \\{.*\\[\\r\\n\\] *int c;.*\\[\\r\\n\\] *\\} anonymous_level_2;.*\\[\\r\\n\\]}.*\" \\\n-         \"ptype the_highest\"\n+         \"ptype the_highest.anonymous_level_1\"\n \n # Print the type of the identifier ID, and check the response:\n # - Expect to see PROTOTYPED as the type.  PROTOTYPED is not a regular\n@@ -255,8 +255,21 @@ proc ptype_maybe_prototyped { id prototyped plain { overprototyped \"NO-MATCH\" }\n     }\n }\n \n+ptype_maybe_prototyped \"func_type\" \"int (*)(int (*)(int, float), float)\" \\\n+                                   \"int (*)()\"\n ptype_maybe_prototyped \"old_fptr\" \"double (*)()\" \"double (*)()\" \\\n                                   \"double (*)(void)\"\n+ptype_maybe_prototyped \"new_fptr\" \"double (*)()\" \"double (*)()\"\n+ptype_maybe_prototyped \"fptr\" \"int (*)(int, float)\" \"int (*)()\"\n+ptype_maybe_prototyped \"fptr2\" \"int *(*)(int (*)(int, float), float)\" \\\n+                               \"int *(*)()\"\n+ptype_maybe_prototyped \"xptr\" \"int (*)(int (*)(), int (*)(), int)\" \\\n+                              \"int (*)()\" \\\n+                              \"int (*)(int (*)(void), int (*)(void), int)\"\n+ptype_maybe_prototyped \"ffptr\" \"int (*(*)(char))(short int)\" \\\n+                               \"int (*(*)())()\"\n+ptype_maybe_prototyped \"fffptr\" \"int (*(*(*)(char))(short int))(long int)\" \\\n+                                \"int (*(*(*)())())()\"\n \n # Test printing type of string constants and array constants, but\n # requires a running process.  These call malloc, and can take a long"
    }
  ]
}