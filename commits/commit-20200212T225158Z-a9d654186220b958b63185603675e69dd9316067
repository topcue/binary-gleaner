{
  "sha": "a9d654186220b958b63185603675e69dd9316067",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTlkNjU0MTg2MjIwYjk1OGI2MzE4NTYwMzY3NWU2OWRkOTMxNjA2Nw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-12T22:45:08Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-02-12T22:51:58Z"
    },
    "message": "Change fde table to a vector\n\nThis removes struct dwarf2_fde_table, replacing it with a typedef of\nstd::vector.  This simplifies the code somewhat.\n\ngdb/ChangeLog\n2020-02-12  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/frame.c (struct dwarf2_fde_table): Remove.\n\t(dwarf2_fde_table): Typedef for std::vector.\n\t(dwarf2_frame_objfile_data): Remove the deleter.  Now static.\n\t(dwarf2_frame_find_fde, add_fde, decode_frame_entry_1)\n\t(decode_frame_entry): Update.\n\t(dwarf2_build_frame_info): Use \"new\".",
    "tree": {
      "sha": "f1b17665f940ee85aa0c56de0e5c4526f29aa1bd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f1b17665f940ee85aa0c56de0e5c4526f29aa1bd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a9d654186220b958b63185603675e69dd9316067",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a9d654186220b958b63185603675e69dd9316067",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a9d654186220b958b63185603675e69dd9316067",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a9d654186220b958b63185603675e69dd9316067/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7559c21717237c565ff1604e7a99ce0a89ce4ebd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7559c21717237c565ff1604e7a99ce0a89ce4ebd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7559c21717237c565ff1604e7a99ce0a89ce4ebd"
    }
  ],
  "stats": {
    "total": 185,
    "additions": 70,
    "deletions": 115
  },
  "files": [
    {
      "sha": "16a14436575a1d5169d7ff82e2795da8deb3b8a3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a9d654186220b958b63185603675e69dd9316067/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a9d654186220b958b63185603675e69dd9316067/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=a9d654186220b958b63185603675e69dd9316067",
      "patch": "@@ -1,3 +1,12 @@\n+2020-02-12  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/frame.c (struct dwarf2_fde_table): Remove.\n+\t(dwarf2_fde_table): Typedef for std::vector.\n+\t(dwarf2_frame_objfile_data): Remove the deleter.  Now static.\n+\t(dwarf2_frame_find_fde, add_fde, decode_frame_entry_1)\n+\t(decode_frame_entry): Update.\n+\t(dwarf2_build_frame_info): Use \"new\".\n+\n 2020-02-12  Christian Biesinger  <cbiesinger@google.com>\n \n \t* arm-tdep.c (arm_gdbarch_init): Update."
    },
    {
      "sha": "0e1564e32568498e6f1bca1339eb0db375e3794a",
      "filename": "gdb/dwarf2/frame.c",
      "status": "modified",
      "additions": 61,
      "deletions": 115,
      "changes": 176,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a9d654186220b958b63185603675e69dd9316067/gdb/dwarf2/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a9d654186220b958b63185603675e69dd9316067/gdb/dwarf2/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame.c?ref=a9d654186220b958b63185603675e69dd9316067",
      "patch": "@@ -129,11 +129,7 @@ struct dwarf2_fde\n   unsigned char eh_frame_p;\n };\n \n-struct dwarf2_fde_table\n-{\n-  int num_entries;\n-  struct dwarf2_fde **entries;\n-};\n+typedef std::vector<dwarf2_fde *> dwarf2_fde_table;\n \n /* A minimal decoding of DWARF2 compilation units.  We only decode\n    what's needed to get to the call frame information.  */\n@@ -1471,9 +1467,7 @@ dwarf2_frame_cfa (struct frame_info *this_frame)\n   return get_frame_base (this_frame);\n }\n \f\n-const struct objfile_key<dwarf2_fde_table,\n-\t\t\t gdb::noop_deleter<dwarf2_fde_table>>\n-  dwarf2_frame_objfile_data;\n+static const struct objfile_key<dwarf2_fde_table> dwarf2_frame_objfile_data;\n \n \f\n \n@@ -1636,7 +1630,7 @@ dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)\n {\n   for (objfile *objfile : current_program_space->objfiles ())\n     {\n-      struct dwarf2_fde_table *fde_table;\n+      dwarf2_fde_table *fde_table;\n       CORE_ADDR offset;\n       CORE_ADDR seek_pc;\n \n@@ -1648,20 +1642,20 @@ dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)\n \t}\n       gdb_assert (fde_table != NULL);\n \n-      if (fde_table->num_entries == 0)\n+      if (fde_table->empty ())\n \tcontinue;\n \n       gdb_assert (!objfile->section_offsets.empty ());\n       offset = objfile->text_section_offset ();\n \n-      gdb_assert (fde_table->num_entries > 0);\n-      if (*pc < offset + fde_table->entries[0]->initial_location)\n+      gdb_assert (!fde_table->empty ());\n+      if (*pc < offset + (*fde_table)[0]->initial_location)\n         continue;\n \n       seek_pc = *pc - offset;\n-      auto end = fde_table->entries + fde_table->num_entries;\n-      auto it = gdb::binary_search (fde_table->entries, end, seek_pc, bsearch_fde_cmp);\n-      if (it != end)\n+      auto it = gdb::binary_search (fde_table->begin (), fde_table->end (),\n+\t\t\t\t    seek_pc, bsearch_fde_cmp);\n+      if (it != fde_table->end ())\n         {\n           *pc = (*it)->initial_location + offset;\n \t  if (out_offset)\n@@ -1672,18 +1666,15 @@ dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)\n   return NULL;\n }\n \n-/* Add a pointer to new FDE to the FDE_TABLE, allocating space for it.  */\n+/* Add FDE to FDE_TABLE.  */\n static void\n-add_fde (struct dwarf2_fde_table *fde_table, struct dwarf2_fde *fde)\n+add_fde (dwarf2_fde_table *fde_table, struct dwarf2_fde *fde)\n {\n   if (fde->address_range == 0)\n     /* Discard useless FDEs.  */\n     return;\n \n-  fde_table->num_entries += 1;\n-  fde_table->entries = XRESIZEVEC (struct dwarf2_fde *, fde_table->entries,\n-\t\t\t\t   fde_table->num_entries);\n-  fde_table->entries[fde_table->num_entries - 1] = fde;\n+  fde_table->push_back (fde);\n }\n \n #define DW64_CIE_ID 0xffffffffffffffffULL\n@@ -1702,7 +1693,7 @@ static const gdb_byte *decode_frame_entry (struct comp_unit *unit,\n \t\t\t\t\t   const gdb_byte *start,\n \t\t\t\t\t   int eh_frame_p,\n \t\t\t\t\t   dwarf2_cie_table &cie_table,\n-\t\t\t\t\t   struct dwarf2_fde_table *fde_table,\n+\t\t\t\t\t   dwarf2_fde_table *fde_table,\n \t\t\t\t\t   enum eh_frame_type entry_type);\n \n /* Decode the next CIE or FDE, entry_type specifies the expected type.\n@@ -1712,7 +1703,7 @@ static const gdb_byte *\n decode_frame_entry_1 (struct comp_unit *unit, const gdb_byte *start,\n \t\t      int eh_frame_p,\n                       dwarf2_cie_table &cie_table,\n-                      struct dwarf2_fde_table *fde_table,\n+                      dwarf2_fde_table *fde_table,\n                       enum eh_frame_type entry_type)\n {\n   struct gdbarch *gdbarch = get_objfile_arch (unit->objfile);\n@@ -2014,7 +2005,7 @@ static const gdb_byte *\n decode_frame_entry (struct comp_unit *unit, const gdb_byte *start,\n \t\t    int eh_frame_p,\n \t\t    dwarf2_cie_table &cie_table,\n-                    struct dwarf2_fde_table *fde_table,\n+                    dwarf2_fde_table *fde_table,\n                     enum eh_frame_type entry_type)\n {\n   enum { NONE, ALIGN4, ALIGN8, FAIL } workaround = NONE;\n@@ -2128,11 +2119,8 @@ dwarf2_build_frame_info (struct objfile *objfile)\n   struct comp_unit *unit;\n   const gdb_byte *frame_ptr;\n   dwarf2_cie_table cie_table;\n-  struct dwarf2_fde_table fde_table;\n-  struct dwarf2_fde_table *fde_table2;\n-\n-  fde_table.num_entries = 0;\n-  fde_table.entries = NULL;\n+  dwarf2_fde_table fde_table;\n+  dwarf2_fde_table *fde_table2;\n \n   /* Build a minimal decoding of the DWARF2 compilation unit.  */\n   unit = XOBNEW (&objfile->objfile_obstack, comp_unit);\n@@ -2181,12 +2169,7 @@ dwarf2_build_frame_info (struct objfile *objfile)\n \t      warning (_(\"skipping .eh_frame info of %s: %s\"),\n \t\t       objfile_name (objfile), e.what ());\n \n-\t      if (fde_table.num_entries != 0)\n-\t\t{\n-                  xfree (fde_table.entries);\n-\t\t  fde_table.entries = NULL;\n-\t\t  fde_table.num_entries = 0;\n-\t\t}\n+\t      fde_table.clear ();\n \t      /* The cie_table is discarded below.  */\n \t    }\n \n@@ -2200,7 +2183,7 @@ dwarf2_build_frame_info (struct objfile *objfile)\n                            &unit->dwarf_frame_size);\n   if (unit->dwarf_frame_size)\n     {\n-      int num_old_fde_entries = fde_table.num_entries;\n+      size_t num_old_fde_entries = fde_table.size ();\n \n       try\n \t{\n@@ -2215,95 +2198,58 @@ dwarf2_build_frame_info (struct objfile *objfile)\n \t  warning (_(\"skipping .debug_frame info of %s: %s\"),\n \t\t   objfile_name (objfile), e.what ());\n \n-\t  if (fde_table.num_entries != 0)\n-\t    {\n-\t      fde_table.num_entries = num_old_fde_entries;\n-\t      if (num_old_fde_entries == 0)\n-\t\t{\n-\t\t  xfree (fde_table.entries);\n-\t\t  fde_table.entries = NULL;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  fde_table.entries\n-\t\t    = XRESIZEVEC (struct dwarf2_fde *, fde_table.entries,\n-\t\t\t\t  fde_table.num_entries);\n-\t\t}\n-\t    }\n-\t  fde_table.num_entries = num_old_fde_entries;\n+\t  fde_table.resize (num_old_fde_entries);\n \t}\n     }\n \n-  /* Copy fde_table to obstack: it is needed at runtime.  */\n-  fde_table2 = XOBNEW (&objfile->objfile_obstack, struct dwarf2_fde_table);\n+  fde_table2 = new dwarf2_fde_table;\n \n-  if (fde_table.num_entries == 0)\n-    {\n-      fde_table2->entries = NULL;\n-      fde_table2->num_entries = 0;\n-    }\n-  else\n-    {\n-      struct dwarf2_fde *fde_prev = NULL;\n-      struct dwarf2_fde *first_non_zero_fde = NULL;\n-      int i;\n-\n-      /* Prepare FDE table for lookups.  */\n-      std::sort (fde_table.entries, fde_table.entries + fde_table.num_entries,\n-\t\t fde_is_less_than);\n-\n-      /* Check for leftovers from --gc-sections.  The GNU linker sets\n-\t the relevant symbols to zero, but doesn't zero the FDE *end*\n-\t ranges because there's no relocation there.  It's (offset,\n-\t length), not (start, end).  On targets where address zero is\n-\t just another valid address this can be a problem, since the\n-\t FDEs appear to be non-empty in the output --- we could pick\n-\t out the wrong FDE.  To work around this, when overlaps are\n-\t detected, we prefer FDEs that do not start at zero.\n-\n-\t Start by finding the first FDE with non-zero start.  Below\n-\t we'll discard all FDEs that start at zero and overlap this\n-\t one.  */\n-      for (i = 0; i < fde_table.num_entries; i++)\n-\t{\n-\t  struct dwarf2_fde *fde = fde_table.entries[i];\n+  struct dwarf2_fde *fde_prev = NULL;\n+  struct dwarf2_fde *first_non_zero_fde = NULL;\n \n-\t  if (fde->initial_location != 0)\n-\t    {\n-\t      first_non_zero_fde = fde;\n-\t      break;\n-\t    }\n-\t}\n+  /* Prepare FDE table for lookups.  */\n+  std::sort (fde_table.begin (), fde_table.end (), fde_is_less_than);\n \n-      /* Since we'll be doing bsearch, squeeze out identical (except\n-\t for eh_frame_p) fde entries so bsearch result is predictable.\n-\t Also discard leftovers from --gc-sections.  */\n-      fde_table2->num_entries = 0;\n-      for (i = 0; i < fde_table.num_entries; i++)\n+  /* Check for leftovers from --gc-sections.  The GNU linker sets\n+     the relevant symbols to zero, but doesn't zero the FDE *end*\n+     ranges because there's no relocation there.  It's (offset,\n+     length), not (start, end).  On targets where address zero is\n+     just another valid address this can be a problem, since the\n+     FDEs appear to be non-empty in the output --- we could pick\n+     out the wrong FDE.  To work around this, when overlaps are\n+     detected, we prefer FDEs that do not start at zero.\n+\n+     Start by finding the first FDE with non-zero start.  Below\n+     we'll discard all FDEs that start at zero and overlap this\n+     one.  */\n+  for (struct dwarf2_fde *fde : fde_table)\n+    {\n+      if (fde->initial_location != 0)\n \t{\n-\t  struct dwarf2_fde *fde = fde_table.entries[i];\n-\n-\t  if (fde->initial_location == 0\n-\t      && first_non_zero_fde != NULL\n-\t      && (first_non_zero_fde->initial_location\n-\t\t  < fde->initial_location + fde->address_range))\n-\t    continue;\n-\n-\t  if (fde_prev != NULL\n-\t      && fde_prev->initial_location == fde->initial_location)\n-\t    continue;\n-\n-\t  obstack_grow (&objfile->objfile_obstack, &fde_table.entries[i],\n-\t\t\tsizeof (fde_table.entries[0]));\n-\t  ++fde_table2->num_entries;\n-\t  fde_prev = fde;\n+\t  first_non_zero_fde = fde;\n+\t  break;\n \t}\n-      fde_table2->entries\n-\t= (struct dwarf2_fde **) obstack_finish (&objfile->objfile_obstack);\n+    }\n+\n+  /* Since we'll be doing bsearch, squeeze out identical (except\n+     for eh_frame_p) fde entries so bsearch result is predictable.\n+     Also discard leftovers from --gc-sections.  */\n+  for (struct dwarf2_fde *fde : fde_table)\n+    {\n+      if (fde->initial_location == 0\n+\t  && first_non_zero_fde != NULL\n+\t  && (first_non_zero_fde->initial_location\n+\t      < fde->initial_location + fde->address_range))\n+\tcontinue;\n+\n+      if (fde_prev != NULL\n+\t  && fde_prev->initial_location == fde->initial_location)\n+\tcontinue;\n \n-      /* Discard the original fde_table.  */\n-      xfree (fde_table.entries);\n+      fde_table2->push_back (fde);\n+      fde_prev = fde;\n     }\n+  fde_table2->shrink_to_fit ();\n \n   dwarf2_frame_objfile_data.set (objfile, fde_table2);\n }"
    }
  ]
}