{
  "sha": "f3f8ece4b1c77c925d1f1566df0bf632790a4d24",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjNmOGVjZTRiMWM3N2M5MjVkMWYxNTY2ZGYwYmY2MzI3OTBhNGQyNA==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-01-10T20:05:48Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-01-10T20:05:48Z"
    },
    "message": "switch inferior/thread before calling target methods\n\nOnce each inferior has its own target stack, we'll need to make sure\nthat the right inferior is selected before we call into target\nmethods.\n\nIt kind of sounds worse than it is in practice.  Not that many places\nneed to be concerned.\n\nIn thread.c, we add a new switch_to_thread_if_alive function that\ncentralizes the switching before calls to target_thread_alive.  Other\ncases are handled with explicit switching.\n\ngdb/ChangeLog:\n2020-01-10  Pedro Alves  <palves@redhat.com>\n\n\t* gdbthread.h (scoped_restore_current_thread)\n\t<dont_restore, restore, m_dont_restore>: Declare.\n\t* thread.c (thread_alive): Add assertion.  Return bool.\n\t(switch_to_thread_if_alive): New.\n\t(prune_threads): Switch inferior/thread.\n\t(print_thread_info_1): Switch thread before calling target methods.\n\t(scoped_restore_current_thread::restore): New, factored out from\n\t...\n\t(scoped_restore_current_thread::~scoped_restore_current_thread):\n\t... this.\n\t(scoped_restore_current_thread::scoped_restore_current_thread):\n\tAdd assertion.\n\t(thread_apply_all_command, thread_select): Use\n\tswitch_to_thread_if_alive.\n\t* infrun.c (proceed, restart_threads, handle_signal_stop)\n\t(switch_back_to_stepped_thread): Switch current thread before\n\tcalling target methods.",
    "tree": {
      "sha": "6ded291c77a7b5e3d235093c573275247425e4e3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6ded291c77a7b5e3d235093c573275247425e4e3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f3f8ece4b1c77c925d1f1566df0bf632790a4d24",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f3f8ece4b1c77c925d1f1566df0bf632790a4d24",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f3f8ece4b1c77c925d1f1566df0bf632790a4d24",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f3f8ece4b1c77c925d1f1566df0bf632790a4d24/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "db2d40f7d0b8477ca5ad9e305b8137a085434c97",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/db2d40f7d0b8477ca5ad9e305b8137a085434c97",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/db2d40f7d0b8477ca5ad9e305b8137a085434c97"
    }
  ],
  "stats": {
    "total": 108,
    "additions": 86,
    "deletions": 22
  },
  "files": [
    {
      "sha": "a733f0dfa01aafcdd9b1954e1b6f35d7e5247e6e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3f8ece4b1c77c925d1f1566df0bf632790a4d24/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3f8ece4b1c77c925d1f1566df0bf632790a4d24/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f3f8ece4b1c77c925d1f1566df0bf632790a4d24",
      "patch": "@@ -1,3 +1,23 @@\n+2020-01-10  Pedro Alves  <palves@redhat.com>\n+\n+\t* gdbthread.h (scoped_restore_current_thread)\n+\t<dont_restore, restore, m_dont_restore>: Declare.\n+\t* thread.c (thread_alive): Add assertion.  Return bool.\n+\t(switch_to_thread_if_alive): New.\n+\t(prune_threads): Switch inferior/thread.\n+\t(print_thread_info_1): Switch thread before calling target methods.\n+\t(scoped_restore_current_thread::restore): New, factored out from\n+\t...\n+\t(scoped_restore_current_thread::~scoped_restore_current_thread):\n+\t... this.\n+\t(scoped_restore_current_thread::scoped_restore_current_thread):\n+\tAdd assertion.\n+\t(thread_apply_all_command, thread_select): Use\n+\tswitch_to_thread_if_alive.\n+\t* infrun.c (proceed, restart_threads, handle_signal_stop)\n+\t(switch_back_to_stepped_thread): Switch current thread before\n+\tcalling target methods.\n+\n 2020-01-10  Pedro Alves <palves@redhat.com>\n \n \t* inferior.c (switch_to_inferior_no_thread): New function,"
    },
    {
      "sha": "2fa5cd89b4181363d98c09b944afa8364225bb91",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 14,
      "deletions": 2,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3f8ece4b1c77c925d1f1566df0bf632790a4d24/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3f8ece4b1c77c925d1f1566df0bf632790a4d24/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=f3f8ece4b1c77c925d1f1566df0bf632790a4d24",
      "patch": "@@ -2940,6 +2940,8 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n     {\n       for (thread_info *tp : all_non_exited_threads (resume_ptid))\n \t{\n+\t  switch_to_thread_no_regs (tp);\n+\n \t  /* Ignore the current thread here.  It's handled\n \t     afterwards.  */\n \t  if (tp == cur_thr)\n@@ -2957,6 +2959,8 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \n \t  thread_step_over_chain_enqueue (tp);\n \t}\n+\n+      switch_to_thread (cur_thr);\n     }\n \n   /* Enqueue the current thread last, so that we move all other\n@@ -2993,6 +2997,8 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t   Start all other threads that are implicitly resumed too.  */\n       for (thread_info *tp : all_non_exited_threads (resume_ptid))\n         {\n+\t  switch_to_thread_no_regs (tp);\n+\n \t  if (tp->resumed)\n \t    {\n \t      if (debug_infrun)\n@@ -4377,6 +4383,7 @@ stop_all_threads (void)\n \t\t\t\t\t    \"infrun:   %s executing, \"\n \t\t\t\t\t    \"need stop\\n\",\n \t\t\t\t\t    target_pid_to_str (t->ptid).c_str ());\n+\t\t      switch_to_thread_no_regs (t);\n \t\t      target_stop (t->ptid);\n \t\t      t->stop_requested = 1;\n \t\t    }\n@@ -5221,6 +5228,8 @@ restart_threads (struct thread_info *event_thread)\n \n   for (thread_info *tp : all_non_exited_threads ())\n     {\n+      switch_to_thread_no_regs (tp);\n+\n       if (tp == event_thread)\n \t{\n \t  if (debug_infrun)\n@@ -5479,9 +5488,8 @@ handle_signal_stop (struct execution_control_state *ecs)\n     {\n       struct regcache *regcache = get_thread_regcache (ecs->event_thread);\n       struct gdbarch *reg_gdbarch = regcache->arch ();\n-      scoped_restore save_inferior_ptid = make_scoped_restore (&inferior_ptid);\n \n-      inferior_ptid = ecs->ptid;\n+      switch_to_thread (ecs->event_thread);\n \n       fprintf_unfiltered (gdb_stdlog, \"infrun: stop_pc = %s\\n\",\n \t\t\t  paddress (reg_gdbarch,\n@@ -6924,6 +6932,8 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \n       for (thread_info *tp : all_non_exited_threads ())\n         {\n+\t  switch_to_thread_no_regs (tp);\n+\n \t  /* Ignore threads of processes the caller is not\n \t     resuming.  */\n \t  if (!sched_multi\n@@ -6975,6 +6985,8 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t      return 1;\n \t    }\n \t}\n+\n+      switch_to_thread (ecs->event_thread);\n     }\n \n   return 0;"
    },
    {
      "sha": "17a79e22c6b32785b06ebb408bc323312de97fcf",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 52,
      "deletions": 20,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f3f8ece4b1c77c925d1f1566df0bf632790a4d24/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f3f8ece4b1c77c925d1f1566df0bf632790a4d24/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=f3f8ece4b1c77c925d1f1566df0bf632790a4d24",
      "patch": "@@ -62,8 +62,6 @@ static int highest_thread_num;\n    spawned new threads we haven't heard of yet.  */\n static int threads_executing;\n \n-static int thread_alive (struct thread_info *);\n-\n /* RAII type used to increase / decrease the refcount of each thread\n    in a given list of threads.  */\n \n@@ -679,24 +677,54 @@ any_live_thread_of_inferior (inferior *inf)\n }\n \n /* Return true if TP is an active thread.  */\n-static int\n-thread_alive (struct thread_info *tp)\n+static bool\n+thread_alive (thread_info *tp)\n {\n   if (tp->state == THREAD_EXITED)\n-    return 0;\n-  if (!target_thread_alive (tp->ptid))\n-    return 0;\n-  return 1;\n+    return false;\n+\n+  /* Ensure we're looking at the right target stack.  */\n+  gdb_assert (tp->inf == current_inferior ());\n+\n+  return target_thread_alive (tp->ptid);\n+}\n+\n+/* Switch to thread TP if it is alive.  Returns true if successfully\n+   switched, false otherwise.  */\n+\n+static bool\n+switch_to_thread_if_alive (thread_info *thr)\n+{\n+  scoped_restore_current_thread restore_thread;\n+\n+  /* Switch inferior first, so that we're looking at the right target\n+     stack.  */\n+  switch_to_inferior_no_thread (thr->inf);\n+\n+  if (thread_alive (thr))\n+    {\n+      switch_to_thread (thr);\n+      restore_thread.dont_restore ();\n+      return true;\n+    }\n+\n+  return false;\n }\n \n /* See gdbthreads.h.  */\n \n void\n prune_threads (void)\n {\n+  scoped_restore_current_thread restore_thread;\n+\n   for (thread_info *tp : all_threads_safe ())\n-    if (!thread_alive (tp))\n-      delete_thread (tp);\n+    {\n+      switch_to_inferior_no_thread (tp->inf);\n+\n+      if (!thread_alive (tp))\n+\tdelete_thread (tp);\n+    }\n }\n \n /* See gdbthreads.h.  */\n@@ -1037,6 +1065,9 @@ print_thread_info_1 (struct ui_out *uiout, const char *requested_threads,\n     gdb::optional<ui_out_emit_list> list_emitter;\n     gdb::optional<ui_out_emit_table> table_emitter;\n \n+    /* We'll be switching threads temporarily below.  */\n+    scoped_restore_current_thread restore_thread;\n+\n     if (uiout->is_mi_like_p ())\n       list_emitter.emplace (uiout, \"threads\");\n     else\n@@ -1054,6 +1085,10 @@ print_thread_info_1 (struct ui_out *uiout, const char *requested_threads,\n \n \t    if (!uiout->is_mi_like_p ())\n \t      {\n+\t\t/* Switch inferiors so we're looking at the right\n+\t\t   target stack.  */\n+\t\tswitch_to_inferior_no_thread (tp->inf);\n+\n \t\ttarget_id_col_width\n \t\t  = std::max (target_id_col_width,\n \t\t\t      thread_target_id_str (tp).size ());\n@@ -1085,9 +1120,6 @@ print_thread_info_1 (struct ui_out *uiout, const char *requested_threads,\n \tuiout->table_body ();\n       }\n \n-    /* We'll be switching threads temporarily.  */\n-    scoped_restore_current_thread restore_thread;\n-\n     for (inferior *inf : all_inferiors ())\n       for (thread_info *tp : inf->threads ())\n \t{\n@@ -1116,6 +1148,9 @@ print_thread_info_1 (struct ui_out *uiout, const char *requested_threads,\n \t  if (show_global_ids || uiout->is_mi_like_p ())\n \t    uiout->field_signed (\"id\", tp->global_num);\n \n+\t  /* Switch to the thread (and inferior / target).  */\n+\t  switch_to_thread (tp);\n+\n \t  /* For the CLI, we stuff everything into the target-id field.\n \t     This is a gross hack to make the output come out looking\n \t     correct.  The underlying problem here is that ui-out has no\n@@ -1147,9 +1182,8 @@ print_thread_info_1 (struct ui_out *uiout, const char *requested_threads,\n \t    uiout->text (\"(running)\\n\");\n \t  else\n \t    {\n-\t      /* The switch below puts us at the top of the stack (leaf\n+\t      /* The switch above put us at the top of the stack (leaf\n \t\t frame).  */\n-\t      switch_to_thread (tp);\n \t      print_stack_frame (get_selected_frame (NULL),\n \t\t\t\t /* For MI output, print frame level.  */\n \t\t\t\t uiout->is_mi_like_p (),\n@@ -1662,7 +1696,7 @@ thread_apply_all_command (const char *cmd, int from_tty)\n       scoped_restore_current_thread restore_thread;\n \n       for (thread_info *thr : thr_list_cpy)\n-\tif (thread_alive (thr))\n+\tif (switch_to_thread_if_alive (thr))\n \t  thr_try_catch_cmd (thr, cmd, from_tty, flags);\n     }\n }\n@@ -1819,7 +1853,7 @@ thread_apply_command (const char *tidlist, int from_tty)\n \t  continue;\n \t}\n \n-      if (!thread_alive (tp))\n+      if (!switch_to_thread_if_alive (tp))\n \t{\n \t  warning (_(\"Thread %s has terminated.\"), print_thread_id (tp));\n \t  continue;\n@@ -1987,11 +2021,9 @@ show_print_thread_events (struct ui_file *file, int from_tty,\n void\n thread_select (const char *tidstr, thread_info *tp)\n {\n-  if (!thread_alive (tp))\n+  if (!switch_to_thread_if_alive (tp))\n     error (_(\"Thread ID %s has terminated.\"), tidstr);\n \n-  switch_to_thread (tp);\n-\n   annotate_thread_changed ();\n \n   /* Since the current thread may have changed, see if there is any"
    }
  ]
}