{
  "sha": "389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Mzg5ZTdkZGJjMmIwOGJkNWNhYzhjOGY0NGEwM2U5MzYwOWZkNDNkMQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-10-08T00:03:02Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-12-11T22:49:01Z"
    },
    "message": "Introduce new layout code\n\nThis introduces a new approach to window layout for the TUI.  The idea\nbehind this code is that a layout should be specified in a declarative\nway, and then be applied by generic code that does not need to know\nthe specifics of every possible layout.\n\nThis patch itself does not change any behavior, because the new layout\nengine isn't yet connected to anything.  That is, this merely\nintroduces the implementation.\n\nThis generic approach makes the code more maintainable.  It also\nenables some future changes:\n\n* New window types are simpler to add;\n* User-specified layouts are possible; and\n* Horizontal layouts are more attainable\n\ngdb/ChangeLog\n2019-12-11  Tom Tromey  <tom@tromey.com>\n\n\t* tui/tui-layout.h (class tui_layout_base)\n\t(class tui_layout_window, class tui_layout_split): New.\n\t* tui/tui-layout.c (tui_get_window_by_name)\n\t(tui_layout_window::clone, tui_layout_window::apply)\n\t(tui_layout_window::get_sizes, tui_layout_window::add_split)\n\t(tui_layout_split::add_window, tui_layout_split::clone)\n\t(tui_layout_split::get_sizes)\n\t(tui_layout_split::set_weights_from_heights)\n\t(tui_layout_split::adjust_size, tui_layout_split::apply): New\n\tfunctions.\n\t(tui_layout_split::add_split, tui_layout_split::add_split)\n\t(tui_layout_split::set_weights_from_heights)\n\t(tui_layout_split::set_weights_from_heights): New functions.\n\nChange-Id: I3a4cae666327b617d862aaa356f8179f945c6a4e",
    "tree": {
      "sha": "ec0e670d8caa28b67bccb1673e19041993200223",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ec0e670d8caa28b67bccb1673e19041993200223"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fb3184d8ee941e75d61b3d9ce8fcf7028c8877b8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fb3184d8ee941e75d61b3d9ce8fcf7028c8877b8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fb3184d8ee941e75d61b3d9ce8fcf7028c8877b8"
    }
  ],
  "stats": {
    "total": 522,
    "additions": 522,
    "deletions": 0
  },
  "files": [
    {
      "sha": "595b98743d629a9480a9b08aae0a19e6ba546f96",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1",
      "patch": "@@ -1,3 +1,19 @@\n+2019-12-11  Tom Tromey  <tom@tromey.com>\n+\n+\t* tui/tui-layout.h (class tui_layout_base)\n+\t(class tui_layout_window, class tui_layout_split): New.\n+\t* tui/tui-layout.c (tui_get_window_by_name)\n+\t(tui_layout_window::clone, tui_layout_window::apply)\n+\t(tui_layout_window::get_sizes, tui_layout_window::add_split)\n+\t(tui_layout_split::add_window, tui_layout_split::clone)\n+\t(tui_layout_split::get_sizes)\n+\t(tui_layout_split::set_weights_from_heights)\n+\t(tui_layout_split::adjust_size, tui_layout_split::apply): New\n+\tfunctions.\n+\t(tui_layout_split::add_split, tui_layout_split::add_split)\n+\t(tui_layout_split::set_weights_from_heights)\n+\t(tui_layout_split::set_weights_from_heights): New functions.\n+\n 2019-12-11  Tom Tromey  <tom@tromey.com>\n \n \t* tui/tui-wingeneral.c (tui_gen_win_info::make_window): Update."
    },
    {
      "sha": "91f270dcfc302c03f3b940aaa985ba73576e1dcd",
      "filename": "gdb/tui/tui-layout.c",
      "status": "modified",
      "additions": 360,
      "deletions": 0,
      "changes": 360,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1/gdb/tui/tui-layout.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1/gdb/tui/tui-layout.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-layout.c?ref=389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1",
      "patch": "@@ -543,6 +543,366 @@ show_source_or_disasm_and_command (enum tui_layout_type layout_type)\n \n \f\n \n+/* Helper function that returns a TUI window, given its name.  */\n+\n+static tui_gen_win_info *\n+tui_get_window_by_name (const std::string &name)\n+{\n+  if (name == \"src\")\n+    {\n+      if (tui_win_list[SRC_WIN] == nullptr)\n+\ttui_win_list[SRC_WIN] = new tui_source_window ();\n+      return tui_win_list[SRC_WIN];\n+    }\n+  else if (name == \"cmd\")\n+    {\n+      if (tui_win_list[CMD_WIN] == nullptr)\n+\ttui_win_list[CMD_WIN] = new tui_cmd_window ();\n+      return tui_win_list[CMD_WIN];\n+    }\n+  else if (name == \"regs\")\n+    {\n+      if (tui_win_list[DATA_WIN] == nullptr)\n+\ttui_win_list[DATA_WIN] = new tui_data_window ();\n+      return tui_win_list[DATA_WIN];\n+    }\n+  else if (name == \"asm\")\n+    {\n+      if (tui_win_list[DISASSEM_WIN] == nullptr)\n+\ttui_win_list[DISASSEM_WIN] = new tui_disasm_window ();\n+      return tui_win_list[DISASSEM_WIN];\n+    }\n+  else\n+    {\n+      gdb_assert (name == \"locator\");\n+      return tui_locator_win_info_ptr ();\n+    }\n+}\n+\n+/* See tui-layout.h.  */\n+\n+std::unique_ptr<tui_layout_base>\n+tui_layout_window::clone () const\n+{\n+  tui_layout_window *result = new tui_layout_window (m_contents.c_str ());\n+  return std::unique_ptr<tui_layout_base> (result);\n+}\n+\n+/* See tui-layout.h.  */\n+\n+void\n+tui_layout_window::apply (int x_, int y_, int width_, int height_)\n+{\n+  x = x_;\n+  y = y_;\n+  width = width_;\n+  height = height_;\n+  gdb_assert (m_window != nullptr);\n+  m_window->resize (height, width, x, y);\n+}\n+\n+/* See tui-layout.h.  */\n+\n+void\n+tui_layout_window::get_sizes (int *min_height, int *max_height)\n+{\n+  if (m_window == nullptr)\n+    m_window = tui_get_window_by_name (m_contents);\n+  *min_height = m_window->min_height ();\n+  *max_height = m_window->max_height ();\n+}\n+\n+/* See tui-layout.h.  */\n+\n+bool\n+tui_layout_window::top_boxed_p () const\n+{\n+  gdb_assert (m_window != nullptr);\n+  return m_window->can_box ();\n+}\n+\n+/* See tui-layout.h.  */\n+\n+bool\n+tui_layout_window::bottom_boxed_p () const\n+{\n+  gdb_assert (m_window != nullptr);\n+  return m_window->can_box ();\n+}\n+\n+/* See tui-layout.h.  */\n+\n+tui_layout_split *\n+tui_layout_split::add_split (int weight)\n+{\n+  tui_layout_split *result = new tui_layout_split ();\n+  split s = {weight, std::unique_ptr<tui_layout_base> (result)};\n+  m_splits.push_back (std::move (s));\n+  return result;\n+}\n+\n+/* See tui-layout.h.  */\n+\n+void\n+tui_layout_split::add_window (const char *name, int weight)\n+{\n+  tui_layout_window *result = new tui_layout_window (name);\n+  split s = {weight, std::unique_ptr<tui_layout_base> (result)};\n+  m_splits.push_back (std::move (s));\n+}\n+\n+/* See tui-layout.h.  */\n+\n+std::unique_ptr<tui_layout_base>\n+tui_layout_split::clone () const\n+{\n+  tui_layout_split *result = new tui_layout_split ();\n+  for (const split &item : m_splits)\n+    {\n+      std::unique_ptr<tui_layout_base> next = item.layout->clone ();\n+      split s = {item.weight, std::move (next)};\n+      result->m_splits.push_back (std::move (s));\n+    }\n+  return std::unique_ptr<tui_layout_base> (result);\n+}\n+\n+/* See tui-layout.h.  */\n+\n+void\n+tui_layout_split::get_sizes (int *min_height, int *max_height)\n+{\n+  *min_height = 0;\n+  *max_height = 0;\n+  for (const split &item : m_splits)\n+    {\n+      int new_min, new_max;\n+      item.layout->get_sizes (&new_min, &new_max);\n+      *min_height += new_min;\n+      *max_height += new_max;\n+    }\n+}\n+\n+/* See tui-layout.h.  */\n+\n+bool\n+tui_layout_split::top_boxed_p () const\n+{\n+  if (m_splits.empty ())\n+    return false;\n+  return m_splits[0].layout->top_boxed_p ();\n+}\n+\n+/* See tui-layout.h.  */\n+\n+bool\n+tui_layout_split::bottom_boxed_p () const\n+{\n+  if (m_splits.empty ())\n+    return false;\n+  return m_splits.back ().layout->top_boxed_p ();\n+}\n+\n+/* See tui-layout.h.  */\n+\n+void\n+tui_layout_split::set_weights_from_heights ()\n+{\n+  for (int i = 0; i < m_splits.size (); ++i)\n+    m_splits[i].weight = m_splits[i].layout->height;\n+}\n+\n+/* See tui-layout.h.  */\n+\n+bool\n+tui_layout_split::adjust_size (const char *name, int new_height)\n+{\n+  /* Look through the children.  If one is a layout holding the named\n+     window, we're done; or if one actually is the named window,\n+     update it.  */\n+  int found_index = -1;\n+  for (int i = 0; i < m_splits.size (); ++i)\n+    {\n+      if (m_splits[i].layout->adjust_size (name, new_height))\n+\treturn true;\n+      const char *win_name = m_splits[i].layout->get_name ();\n+      if (win_name != nullptr && strcmp (name, win_name) == 0)\n+\t{\n+\t  found_index = i;\n+\t  break;\n+\t}\n+    }\n+\n+  if (found_index == -1)\n+    return false;\n+  if (m_splits[found_index].layout->height == new_height)\n+    return true;\n+\n+  set_weights_from_heights ();\n+  int delta = m_splits[found_index].weight - new_height;\n+  m_splits[found_index].weight = new_height;\n+\n+  /* Distribute the \"delta\" over the next window; but if the next\n+     window cannot hold it all, keep going until we either find a\n+     window that does, or until we loop all the way around.  */\n+  for (int i = 0; delta != 0 && i < m_splits.size () - 1; ++i)\n+    {\n+      int index = (found_index + 1 + i) % m_splits.size ();\n+\n+      int new_min, new_max;\n+      m_splits[index].layout->get_sizes (&new_min, &new_max);\n+\n+      if (delta < 0)\n+\t{\n+\t  /* The primary window grew, so we are trying to shrink other\n+\t     windows.  */\n+\t  int available = m_splits[index].weight - new_min;\n+\t  int shrink_by = std::min (available, -delta);\n+\t  m_splits[index].weight -= shrink_by;\n+\t  delta += shrink_by;\n+\t}\n+      else\n+\t{\n+\t  /* The primary window shrank, so we are trying to grow other\n+\t     windows.  */\n+\t  int available = new_max - m_splits[index].weight;\n+\t  int grow_by = std::min (available, delta);\n+\t  m_splits[index].weight += grow_by;\n+\t  delta -= grow_by;\n+\t}\n+    }\n+\n+  if (delta != 0)\n+    {\n+      warning (_(\"Invalid window height specified\"));\n+      /* Effectively undo any modifications made here.  */\n+      set_weights_from_heights ();\n+    }\n+  else\n+    {\n+      /* Simply re-apply the updated layout.  */\n+      apply (x, y, width, height);\n+    }\n+\n+  return true;\n+}\n+\n+/* See tui-layout.h.  */\n+\n+void\n+tui_layout_split::apply (int x_, int y_, int width_, int height_)\n+{\n+  x = x_;\n+  y = y_;\n+  width = width_;\n+  height = height_;\n+\n+  struct height_info\n+  {\n+    int height;\n+    int min_height;\n+    int max_height;\n+    /* True if this window will share a box border with the previous\n+       window in the list.  */\n+    bool share_box;\n+  };\n+\n+  std::vector<height_info> info (m_splits.size ());\n+\n+  /* Step 1: Find the min and max height of each sub-layout.\n+     Fixed-sized layouts are given their desired height, and then the\n+     remaining space is distributed among the remaining windows\n+     according to the weights given.  */\n+  int available_height = height;\n+  int last_index = -1;\n+  int total_weight = 0;\n+  for (int i = 0; i < m_splits.size (); ++i)\n+    {\n+      bool cmd_win_already_exists = TUI_CMD_WIN != nullptr;\n+\n+      /* Always call get_sizes, to ensure that the window is\n+\t instantiated.  This is a bit gross but less gross than adding\n+\t special cases for this in other places.  */\n+      m_splits[i].layout->get_sizes (&info[i].min_height, &info[i].max_height);\n+\n+      if (!m_applied\n+\t  && cmd_win_already_exists\n+\t  && m_splits[i].layout->get_name () != nullptr\n+\t  && strcmp (m_splits[i].layout->get_name (), \"cmd\") == 0)\n+\t{\n+\t  /* If this layout has never been applied, then it means the\n+\t     user just changed the layout.  In this situation, it's\n+\t     desirable to keep the size of the command window the\n+\t     same.  Setting the min and max heights this way ensures\n+\t     that the resizing step, below, does the right thing with\n+\t     this window.  */\n+\t  info[i].min_height = TUI_CMD_WIN->height;\n+\t  info[i].max_height = TUI_CMD_WIN->height;\n+\t}\n+\n+      if (info[i].min_height == info[i].max_height)\n+\tavailable_height -= info[i].min_height;\n+      else\n+\t{\n+\t  last_index = i;\n+\t  total_weight += m_splits[i].weight;\n+\t}\n+\n+      /* Two adjacent boxed windows will share a border, making a bit\n+\t more height available.  */\n+      if (i > 0\n+\t  && m_splits[i - 1].layout->bottom_boxed_p ()\n+\t  && m_splits[i].layout->top_boxed_p ())\n+\tinfo[i].share_box = true;\n+    }\n+\n+  /* Step 2: Compute the height of each sub-layout.  Fixed-sized items\n+     are given their fixed size, while others are resized according to\n+     their weight.  */\n+  int used_height = 0;\n+  for (int i = 0; i < m_splits.size (); ++i)\n+    {\n+      /* Compute the height and clamp to the allowable range.  */\n+      info[i].height = available_height * m_splits[i].weight / total_weight;\n+      if (info[i].height > info[i].max_height)\n+\tinfo[i].height = info[i].max_height;\n+      if (info[i].height < info[i].min_height)\n+\tinfo[i].height = info[i].min_height;\n+      /* If there is any leftover height, just redistribute it to the\n+\t last resizeable window, by dropping it from the allocated\n+\t height.  We could try to be fancier here perhaps, by\n+\t redistributing this height among all windows, not just the\n+\t last window.  */\n+      if (info[i].min_height != info[i].max_height)\n+\t{\n+\t  used_height += info[i].height;\n+\t  if (info[i].share_box)\n+\t    --used_height;\n+\t}\n+    }\n+\n+  /* Allocate any leftover height.  */\n+  if (available_height >= used_height && last_index != -1)\n+    info[last_index].height += available_height - used_height;\n+\n+  /* Step 3: Resize.  */\n+  int height_accum = 0;\n+  for (int i = 0; i < m_splits.size (); ++i)\n+    {\n+      /* If we fall off the bottom, just make allocations overlap.\n+\t GIGO.  */\n+      if (height_accum + info[i].height > height)\n+\theight_accum = height - info[i].height;\n+      else if (info[i].share_box)\n+\t--height_accum;\n+      m_splits[i].layout->apply (x, y + height_accum, width, info[i].height);\n+      height_accum += info[i].height;\n+    }\n+\n+  m_applied = true;\n+}\n+\n+\f\n+\n /* Function to initialize gdb commands, for tui window layout\n    manipulation.  */\n "
    },
    {
      "sha": "d7f0731e312dcced3760b27892cf7d139424b78e",
      "filename": "gdb/tui/tui-layout.h",
      "status": "modified",
      "additions": 146,
      "deletions": 0,
      "changes": 146,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1/gdb/tui/tui-layout.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1/gdb/tui/tui-layout.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-layout.h?ref=389e7ddbc2b08bd5cac8c8f44a03e93609fd43d1",
      "patch": "@@ -25,6 +25,152 @@\n #include \"tui/tui.h\"\n #include \"tui/tui-data.h\"\n \n+/* The basic object in a TUI layout.  This represents a single piece\n+   of screen real estate.  Subclasses determine the exact\n+   behavior.  */\n+class tui_layout_base\n+{\n+public:\n+\n+  DISABLE_COPY_AND_ASSIGN (tui_layout_base);\n+\n+  /* Clone this object.  Ordinarily a layout is cloned before it is\n+     used, so that any necessary modifications do not affect the\n+     \"skeleton\" layout.  */\n+  virtual std::unique_ptr<tui_layout_base> clone () const = 0;\n+\n+  /* Change the size and location of this layout.  */\n+  virtual void apply (int x, int y, int width, int height) = 0;\n+\n+  /* Return the minimum and maximum height of this layout.  */\n+  virtual void get_sizes (int *min_height, int *max_height) = 0;\n+\n+  /* True if the topmost item in this layout is boxed.  */\n+  virtual bool top_boxed_p () const = 0;\n+\n+  /* True if the bottommost item in this layout is boxed.  */\n+  virtual bool bottom_boxed_p () const = 0;\n+\n+  /* Return the name of this layout's window, or nullptr if this\n+     layout does not represent a single window.  */\n+  virtual const char *get_name () const\n+  {\n+    return nullptr;\n+  }\n+\n+  /* Adjust the size of the window named NAME to NEW_HEIGHT, updating\n+     the sizes of the other windows around it.  */\n+  virtual bool adjust_size (const char *name, int new_height) = 0;\n+\n+  /* The most recent space allocation.  */\n+  int x = 0;\n+  int y = 0;\n+  int width = 0;\n+  int height = 0;\n+\n+protected:\n+\n+  tui_layout_base () = default;\n+};\n+\n+/* A TUI layout object that displays a single window.  The window is\n+   given by name.  */\n+class tui_layout_window : public tui_layout_base\n+{\n+public:\n+\n+  explicit tui_layout_window (const char *name)\n+    : m_contents (name)\n+  {\n+  }\n+\n+  DISABLE_COPY_AND_ASSIGN (tui_layout_window);\n+\n+  std::unique_ptr<tui_layout_base> clone () const override;\n+\n+  void apply (int x, int y, int width, int height) override;\n+\n+  const char *get_name () const override\n+  {\n+    return m_contents.c_str ();\n+  }\n+\n+  bool adjust_size (const char *name, int new_height) override\n+  {\n+    return false;\n+  }\n+\n+  bool top_boxed_p () const override;\n+\n+  bool bottom_boxed_p () const override;\n+\n+protected:\n+\n+  void get_sizes (int *min_height, int *max_height) override;\n+\n+private:\n+\n+  /* Type of content to display.  */\n+  std::string m_contents;\n+\n+  /* When a layout is applied, this is updated to point to the window\n+     object.  */\n+  tui_gen_win_info *m_window = nullptr;\n+};\n+\n+/* A TUI layout that holds other layouts.  */\n+class tui_layout_split : public tui_layout_base\n+{\n+public:\n+\n+  tui_layout_split () = default;\n+\n+  DISABLE_COPY_AND_ASSIGN (tui_layout_split);\n+\n+  /* Add a new split layout to this layout.  WEIGHT is the desired\n+     size, which is relative to the other weights given in this\n+     layout.  */\n+  tui_layout_split *add_split (int weight);\n+\n+  /* Add a new window to this layout.  NAME is the name of the window\n+     to add.  WEIGHT is the desired size, which is relative to the\n+     other weights given in this layout.  */\n+  void add_window (const char *name, int weight);\n+\n+  std::unique_ptr<tui_layout_base> clone () const override;\n+\n+  void apply (int x, int y, int width, int height) override;\n+\n+  bool adjust_size (const char *name, int new_height) override;\n+\n+  bool top_boxed_p () const override;\n+\n+  bool bottom_boxed_p () const override;\n+\n+protected:\n+\n+  void get_sizes (int *min_height, int *max_height) override;\n+\n+private:\n+\n+  /* Set the weights from the current heights.  */\n+  void set_weights_from_heights ();\n+\n+  struct split\n+  {\n+    /* The requested weight.  */\n+    int weight;\n+    /* The layout.  */\n+    std::unique_ptr<tui_layout_base> layout;\n+  };\n+\n+  /* The splits.  */\n+  std::vector<split> m_splits;\n+\n+  /* True if this layout has already been applied at least once.  */\n+  bool m_applied = false;\n+};\n+\n extern void tui_add_win_to_layout (enum tui_win_type);\n extern void tui_set_layout (enum tui_layout_type);\n "
    }
  ]
}