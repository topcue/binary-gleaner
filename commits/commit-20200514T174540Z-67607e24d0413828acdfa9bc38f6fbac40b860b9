{
  "sha": "67607e24d0413828acdfa9bc38f6fbac40b860b9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Njc2MDdlMjRkMDQxMzgyOGFjZGZhOWJjMzhmNmZiYWM0MGI4NjBiOQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-14T17:45:40Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-14T17:45:40Z"
    },
    "message": "gdb: add type::code / type::set_code\n\nAdd the code and set_code methods on code, in order to remove the\nTYPE_CODE macro.  In this patch, the TYPE_CODE macro is changed to use\ntype::code, so all the call sites that are used to set the type code are\nchanged to use type::set_code.  The next patch will remove TYPE_CODE\ncompletely.\n\ngdb/ChangeLog:\n\n\t* gdbtypes.h (struct type) <code, set_code>: New methods.\n\t(TYPE_CODE): Use type::code.  Change all call sites used to set\n\tthe code to use type::set_code instead.",
    "tree": {
      "sha": "244fb4d92616ef31b9b22197d5a90df09e0147b2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/244fb4d92616ef31b9b22197d5a90df09e0147b2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/67607e24d0413828acdfa9bc38f6fbac40b860b9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/67607e24d0413828acdfa9bc38f6fbac40b860b9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/67607e24d0413828acdfa9bc38f6fbac40b860b9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/67607e24d0413828acdfa9bc38f6fbac40b860b9/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "02eba61aa6cad683e96cf13f483adc04982c0c2b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/02eba61aa6cad683e96cf13f483adc04982c0c2b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/02eba61aa6cad683e96cf13f483adc04982c0c2b"
    }
  ],
  "stats": {
    "total": 123,
    "additions": 71,
    "deletions": 52
  },
  "files": [
    {
      "sha": "c945505d208c7b66f98e9352b1f695755772a978",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -1,3 +1,9 @@\n+2020-05-14  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdbtypes.h (struct type) <code, set_code>: New methods.\n+\t(TYPE_CODE): Use type::code.  Change all call sites used to set\n+\tthe code to use type::set_code instead.\n+\n 2020-05-14  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \t    Tom de Vries  <tdevries@suse.de>\n \t    Pedro Alves  <palves@redhat.com>"
    },
    {
      "sha": "9bed6430cc3f6689c83f8549073da6502d0ce5ac",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -8027,7 +8027,7 @@ empty_record (struct type *templ)\n {\n   struct type *type = alloc_type_copy (templ);\n \n-  TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+  type->set_code (TYPE_CODE_STRUCT);\n   TYPE_NFIELDS (type) = 0;\n   TYPE_FIELDS (type) = NULL;\n   INIT_NONE_SPECIFIC (type);\n@@ -8083,7 +8083,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n     }\n \n   rtype = alloc_type_copy (type);\n-  TYPE_CODE (rtype) = TYPE_CODE_STRUCT;\n+  rtype->set_code (TYPE_CODE_STRUCT);\n   INIT_NONE_SPECIFIC (rtype);\n   TYPE_NFIELDS (rtype) = nfields;\n   TYPE_FIELDS (rtype) = (struct field *)\n@@ -8358,7 +8358,7 @@ template_to_static_fixed_type (struct type *type0)\n \t  if (type == type0)\n \t    {\n \t      TYPE_TARGET_TYPE (type0) = type = alloc_type_copy (type0);\n-\t      TYPE_CODE (type) = TYPE_CODE (type0);\n+\t      type->set_code (TYPE_CODE(type0));\n \t      INIT_NONE_SPECIFIC (type);\n \t      TYPE_NFIELDS (type) = nfields;\n \t      TYPE_FIELDS (type) = (struct field *)\n@@ -8407,7 +8407,7 @@ to_record_with_fixed_variant_part (struct type *type, const gdb_byte *valaddr,\n     dval = dval0;\n \n   rtype = alloc_type_copy (type);\n-  TYPE_CODE (rtype) = TYPE_CODE_STRUCT;\n+  rtype->set_code (TYPE_CODE_STRUCT);\n   INIT_NONE_SPECIFIC (rtype);\n   TYPE_NFIELDS (rtype) = nfields;\n   TYPE_FIELDS (rtype) =\n@@ -10376,7 +10376,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n         /* The result type will have code OP_STRING, bashed there from \n            OP_ARRAY.  Bash it back.  */\n         if (TYPE_CODE (value_type (result)) == TYPE_CODE_STRING)\n-          TYPE_CODE (value_type (result)) = TYPE_CODE_ARRAY;\n+          value_type (result)->set_code (TYPE_CODE_ARRAY);\n         return result;\n       }\n "
    },
    {
      "sha": "4b2993feb7635c8ae94f781c38ea9739872dbb52",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -1880,7 +1880,7 @@ decode_base_type (struct coff_symbol *cs,\n \t{\n \t  /* Anonymous structure type.  */\n \t  type = coff_alloc_type (cs->c_symnum);\n-\t  TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+\t  type->set_code (TYPE_CODE_STRUCT);\n \t  TYPE_NAME (type) = NULL;\n \t  INIT_CPLUS_SPECIFIC (type);\n \t  TYPE_LENGTH (type) = 0;\n@@ -1914,15 +1914,15 @@ decode_base_type (struct coff_symbol *cs,\n \t\t\t\t\taux->x_sym.x_fcnary.x_fcn.x_endndx.l,\n \t\t\t\t\tobjfile);\n \t}\n-      TYPE_CODE (type) = TYPE_CODE_UNION;\n+      type->set_code (TYPE_CODE_UNION);\n       return type;\n \n     case T_ENUM:\n       if (cs->c_naux != 1)\n \t{\n \t  /* Anonymous enum type.  */\n \t  type = coff_alloc_type (cs->c_symnum);\n-\t  TYPE_CODE (type) = TYPE_CODE_ENUM;\n+\t  type->set_code (TYPE_CODE_ENUM);\n \t  TYPE_NAME (type) = NULL;\n \t  TYPE_LENGTH (type) = 0;\n \t  TYPE_FIELDS (type) = 0;\n@@ -1990,7 +1990,7 @@ coff_read_struct_type (int index, int length, int lastsym,\n   int done = 0;\n \n   type = coff_alloc_type (index);\n-  TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+  type->set_code (TYPE_CODE_STRUCT);\n   INIT_CPLUS_SPECIFIC (type);\n   TYPE_LENGTH (type) = length;\n \n@@ -2121,7 +2121,7 @@ coff_read_enum_type (int index, int length, int lastsym,\n     TYPE_LENGTH (type) = length;\n   else /* Assume ints.  */\n     TYPE_LENGTH (type) = gdbarch_int_bit (gdbarch) / TARGET_CHAR_BIT;\n-  TYPE_CODE (type) = TYPE_CODE_ENUM;\n+  type->set_code (TYPE_CODE_ENUM);\n   TYPE_NFIELDS (type) = nsyms;\n   TYPE_FIELDS (type) = (struct field *)\n     TYPE_ALLOC (type, sizeof (struct field) * nsyms);"
    },
    {
      "sha": "06c036df10a74cae680e8d8e6f1e6e4d7239c3e2",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -600,9 +600,9 @@ read_structure_type (struct ctf_context *ccp, ctf_id_t tid)\n \n   kind = ctf_type_kind (fp, tid);\n   if (kind == CTF_K_UNION)\n-    TYPE_CODE (type) = TYPE_CODE_UNION;\n+    type->set_code (TYPE_CODE_UNION);\n   else\n-    TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+    type->set_code (TYPE_CODE_STRUCT);\n \n   TYPE_LENGTH (type) = ctf_type_size (fp, tid);\n   set_type_align (type, ctf_type_align (fp, tid));\n@@ -656,7 +656,7 @@ read_func_kind_type (struct ctf_context *ccp, ctf_id_t tid)\n   if (name != NULL && strlen (name.get ()) != 0)\n     TYPE_NAME (type) = obstack_strdup (&of->objfile_obstack, name.get ());\n \n-  TYPE_CODE (type) = TYPE_CODE_FUNC;\n+  type->set_code (TYPE_CODE_FUNC);\n   ctf_func_type_info (fp, tid, &cfi);\n   rettype = get_tid_type (of, cfi.ctc_return);\n   TYPE_TARGET_TYPE (type) = rettype;\n@@ -682,7 +682,7 @@ read_enum_type (struct ctf_context *ccp, ctf_id_t tid)\n   if (name != NULL && strlen (name.get ()) != 0)\n     TYPE_NAME (type) = obstack_strdup (&of->objfile_obstack, name.get ());\n \n-  TYPE_CODE (type) = TYPE_CODE_ENUM;\n+  type->set_code (TYPE_CODE_ENUM);\n   TYPE_LENGTH (type) = ctf_type_size (fp, tid);\n   ctf_func_type_info (fp, tid, &fi);\n   target_type = get_tid_type (of, fi.ctc_return);"
    },
    {
      "sha": "4809202c9039ad39db588ef168d47ff31cfc154c",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -9325,7 +9325,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \n       /* Smash this type to be a structure type.  We have to do this\n \t because the type has already been recorded.  */\n-      TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+      type->set_code (TYPE_CODE_STRUCT);\n       TYPE_NFIELDS (type) = 3;\n       /* Save the field we care about.  */\n       struct field saved_field = TYPE_FIELD (type, 0);\n@@ -9368,7 +9368,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n     {\n       /* Smash this type to be a structure type.  We have to do this\n \t because the type has already been recorded.  */\n-      TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+      type->set_code (TYPE_CODE_STRUCT);\n \n       struct type *field_type = TYPE_FIELD_TYPE (type, 0);\n       const char *variant_name\n@@ -9415,7 +9415,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \n       /* Smash this type to be a structure type.  We have to do this\n \t because the type has already been recorded.  */\n-      TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+      type->set_code (TYPE_CODE_STRUCT);\n \n       /* Make space for the discriminant field.  */\n       struct field *disr_field = &TYPE_FIELD (disr_type, 0);\n@@ -15369,15 +15369,15 @@ read_structure_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   if (die->tag == DW_TAG_structure_type)\n     {\n-      TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+      type->set_code (TYPE_CODE_STRUCT);\n     }\n   else if (die->tag == DW_TAG_union_type)\n     {\n-      TYPE_CODE (type) = TYPE_CODE_UNION;\n+      type->set_code (TYPE_CODE_UNION);\n     }\n   else\n     {\n-      TYPE_CODE (type) = TYPE_CODE_STRUCT;\n+      type->set_code (TYPE_CODE_STRUCT);\n     }\n \n   if (cu->language == language_cplus && die->tag == DW_TAG_class_type)\n@@ -15937,7 +15937,7 @@ read_enumeration_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   type = alloc_type (objfile);\n \n-  TYPE_CODE (type) = TYPE_CODE_ENUM;\n+  type->set_code (TYPE_CODE_ENUM);\n   name = dwarf2_full_name (NULL, die, cu);\n   if (name != NULL)\n     TYPE_NAME (type) = name;"
    },
    {
      "sha": "f1cfb930c97171f8fdbd5aafc5f675d102032458",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -658,7 +658,7 @@ fake_method::fake_method (type_instance_flags flags,\n \n   TYPE_MAIN_TYPE (type) = &m_main_type;\n   TYPE_LENGTH (type) = 1;\n-  TYPE_CODE (type) = TYPE_CODE_METHOD;\n+  type->set_code (TYPE_CODE_METHOD);\n   TYPE_CHAIN (type) = type;\n   TYPE_INSTANCE_FLAGS (type) = flags;\n   if (num_types > 0)"
    },
    {
      "sha": "671ee52891777037b23d683aaaf31b757c6f187a",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -182,7 +182,7 @@ alloc_type (struct objfile *objfile)\n \n   /* Initialize the fields that might not be zero.  */\n \n-  TYPE_CODE (type) = TYPE_CODE_UNDEF;\n+  type->set_code (TYPE_CODE_UNDEF);\n   TYPE_CHAIN (type) = type;\t/* Chain back to itself.  */\n \n   return type;\n@@ -209,7 +209,7 @@ alloc_type_arch (struct gdbarch *gdbarch)\n \n   /* Initialize the fields that might not be zero.  */\n \n-  TYPE_CODE (type) = TYPE_CODE_UNDEF;\n+  type->set_code (TYPE_CODE_UNDEF);\n   TYPE_CHAIN (type) = type;\t/* Chain back to itself.  */\n \n   return type;\n@@ -366,7 +366,7 @@ make_pointer_type (struct type *type, struct type **typeptr)\n \n   TYPE_LENGTH (ntype)\n     = gdbarch_ptr_bit (get_type_arch (type)) / TARGET_CHAR_BIT;\n-  TYPE_CODE (ntype) = TYPE_CODE_PTR;\n+  ntype->set_code (TYPE_CODE_PTR);\n \n   /* Mark pointers as unsigned.  The target converts between pointers\n      and addresses (CORE_ADDRs) using gdbarch_pointer_to_address and\n@@ -450,7 +450,7 @@ make_reference_type (struct type *type, struct type **typeptr,\n \n   TYPE_LENGTH (ntype) =\n     gdbarch_ptr_bit (get_type_arch (type)) / TARGET_CHAR_BIT;\n-  TYPE_CODE (ntype) = refcode;\n+  ntype->set_code (refcode);\n \n   *reftype = ntype;\n \n@@ -515,7 +515,7 @@ make_function_type (struct type *type, struct type **typeptr)\n   TYPE_TARGET_TYPE (ntype) = type;\n \n   TYPE_LENGTH (ntype) = 1;\n-  TYPE_CODE (ntype) = TYPE_CODE_FUNC;\n+  ntype->set_code (TYPE_CODE_FUNC);\n \n   INIT_FUNC_SPECIFIC (ntype);\n \n@@ -861,7 +861,7 @@ allocate_stub_method (struct type *type)\n   struct type *mtype;\n \n   mtype = alloc_type_copy (type);\n-  TYPE_CODE (mtype) = TYPE_CODE_METHOD;\n+  mtype->set_code (TYPE_CODE_METHOD);\n   TYPE_LENGTH (mtype) = 1;\n   TYPE_STUB (mtype) = 1;\n   TYPE_TARGET_TYPE (mtype) = type;\n@@ -928,7 +928,7 @@ create_range_type (struct type *result_type, struct type *index_type,\n \n   if (result_type == NULL)\n     result_type = alloc_type_copy (index_type);\n-  TYPE_CODE (result_type) = TYPE_CODE_RANGE;\n+  result_type->set_code (TYPE_CODE_RANGE);\n   TYPE_TARGET_TYPE (result_type) = index_type;\n   if (TYPE_STUB (index_type))\n     TYPE_TARGET_STUB (result_type) = 1;\n@@ -1278,7 +1278,7 @@ create_array_type_with_stride (struct type *result_type,\n   if (result_type == NULL)\n     result_type = alloc_type_copy (range_type);\n \n-  TYPE_CODE (result_type) = TYPE_CODE_ARRAY;\n+  result_type->set_code (TYPE_CODE_ARRAY);\n   TYPE_TARGET_TYPE (result_type) = element_type;\n \n   TYPE_NFIELDS (result_type) = 1;\n@@ -1357,7 +1357,7 @@ create_string_type (struct type *result_type,\n   result_type = create_array_type (result_type,\n \t\t\t\t   string_char_type,\n \t\t\t\t   range_type);\n-  TYPE_CODE (result_type) = TYPE_CODE_STRING;\n+  result_type->set_code (TYPE_CODE_STRING);\n   return result_type;\n }\n \n@@ -1369,7 +1369,7 @@ lookup_string_range_type (struct type *string_char_type,\n \n   result_type = lookup_array_range_type (string_char_type,\n \t\t\t\t\t low_bound, high_bound);\n-  TYPE_CODE (result_type) = TYPE_CODE_STRING;\n+  result_type->set_code (TYPE_CODE_STRING);\n   return result_type;\n }\n \n@@ -1379,7 +1379,7 @@ create_set_type (struct type *result_type, struct type *domain_type)\n   if (result_type == NULL)\n     result_type = alloc_type_copy (domain_type);\n \n-  TYPE_CODE (result_type) = TYPE_CODE_SET;\n+  result_type->set_code (TYPE_CODE_SET);\n   TYPE_NFIELDS (result_type) = 1;\n   TYPE_FIELDS (result_type)\n     = (struct field *) TYPE_ZALLOC (result_type, sizeof (struct field));\n@@ -1508,7 +1508,7 @@ smash_to_memberptr_type (struct type *type, struct type *self_type,\n \t\t\t struct type *to_type)\n {\n   smash_type (type);\n-  TYPE_CODE (type) = TYPE_CODE_MEMBERPTR;\n+  type->set_code (TYPE_CODE_MEMBERPTR);\n   TYPE_TARGET_TYPE (type) = to_type;\n   set_type_self_type (type, self_type);\n   /* Assume that a data member pointer is the same size as a normal\n@@ -1527,7 +1527,7 @@ void\n smash_to_methodptr_type (struct type *type, struct type *to_type)\n {\n   smash_type (type);\n-  TYPE_CODE (type) = TYPE_CODE_METHODPTR;\n+  type->set_code (TYPE_CODE_METHODPTR);\n   TYPE_TARGET_TYPE (type) = to_type;\n   set_type_self_type (type, TYPE_SELF_TYPE (to_type));\n   TYPE_LENGTH (type) = cplus_method_ptr_size (to_type);\n@@ -1546,7 +1546,7 @@ smash_to_method_type (struct type *type, struct type *self_type,\n \t\t      int nargs, int varargs)\n {\n   smash_type (type);\n-  TYPE_CODE (type) = TYPE_CODE_METHOD;\n+  type->set_code (TYPE_CODE_METHOD);\n   TYPE_TARGET_TYPE (type) = to_type;\n   set_type_self_type (type, self_type);\n   TYPE_FIELDS (type) = args;\n@@ -3111,7 +3111,7 @@ allocate_gnat_aux_type (struct type *type)\n static void\n set_type_code (struct type *type, enum type_code code)\n {\n-  TYPE_CODE (type) = code;\n+  type->set_code (code);\n \n   switch (code)\n     {"
    },
    {
      "sha": "9f4924e9404e1716b87c6531d92e9e6340a6a66f",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 16,
      "deletions": 3,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -874,6 +874,21 @@ struct main_type\n \n struct type\n {\n+  /* Get the type code of this type. \n+\n+     Note that the code can be TYPE_CODE_TYPEDEF, so if you want the real\n+     type, you need to do `check_typedef (type)->code ()`.  */\n+  type_code code () const\n+  {\n+    return this->main_type->code;\n+  }\n+\n+  /* Set the type code of this type.  */\n+  void set_code (type_code code)\n+  {\n+    this->main_type->code = code;\n+  }\n+\n   /* * Return the dynamic property of the requested KIND from this type's\n      list of dynamic properties.  */\n   dynamic_prop *dyn_prop (dynamic_prop_node_kind kind) const;\n@@ -1420,9 +1435,7 @@ extern unsigned type_align (struct type *);\n    space in struct type.  */\n extern bool set_type_align (struct type *, ULONGEST);\n \n-/* * Note that TYPE_CODE can be TYPE_CODE_TYPEDEF, so if you want the real\n-   type, you need to do TYPE_CODE (check_type (this_type)).  */\n-#define TYPE_CODE(thistype) TYPE_MAIN_TYPE(thistype)->code\n+#define TYPE_CODE(thistype) ((thistype)->code ())\n #define TYPE_NFIELDS(thistype) TYPE_MAIN_TYPE(thistype)->nfields\n #define TYPE_FIELDS(thistype) TYPE_MAIN_TYPE(thistype)->flds_bnds.fields\n "
    },
    {
      "sha": "621069ec20de32b79b14e2a1989840bc28bdcc53",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -1015,7 +1015,7 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n \t  TYPE_NAME (t) = obconcat (&mdebugread_objfile->objfile_obstack,\n \t\t\t\t    name, (char *) NULL);\n \n-\tTYPE_CODE (t) = type_code;\n+\tt->set_code (type_code);\n \tTYPE_LENGTH (t) = sh->value;\n \tTYPE_NFIELDS (t) = nfields;\n \tTYPE_FIELDS (t) = f = ((struct field *)\n@@ -1668,7 +1668,7 @@ parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,\n \n \t  if (TYPE_CODE (tp) != type_code)\n \t    {\n-\t      TYPE_CODE (tp) = type_code;\n+\t      tp->set_code (type_code);\n \t    }\n \n \t  /* Do not set the tag name if it is a compiler generated tag name\n@@ -1709,7 +1709,7 @@ parse_type (int fd, union aux_ext *ax, unsigned int aux_index, int *bs,\n \t  if (TYPE_CODE (tp) != type_code)\n \t    {\n \t      bad_tag_guess_complaint (sym_name);\n-\t      TYPE_CODE (tp) = type_code;\n+\t      tp->set_code (type_code);\n \t    }\n \t  if (TYPE_NAME (tp) == NULL\n \t      || strcmp (TYPE_NAME (tp), name) != 0)"
    },
    {
      "sha": "eb0ea1bfc83823c5147f6a078e907c76bd5e0d8a",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -981,7 +981,7 @@ rust_composite_type (struct type *original,\n   if (field2 != NULL)\n     ++nfields;\n \n-  TYPE_CODE (result) = TYPE_CODE_STRUCT;\n+  result->set_code (TYPE_CODE_STRUCT);\n   TYPE_NAME (result) = name;\n \n   TYPE_NFIELDS (result) = nfields;"
    },
    {
      "sha": "5601c8012e42c2b5f5017cbcd2ed86b3f3c5a30c",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -1687,7 +1687,7 @@ read_type (const char **pp, struct objfile *objfile)\n \t   fill in the rest of the fields when we get the full\n \t   type.  */\n \ttype = dbx_alloc_type (typenums, objfile);\n-\tTYPE_CODE (type) = code;\n+\ttype->set_code (code);\n \tTYPE_NAME (type) = type_name;\n \tINIT_CPLUS_SPECIFIC (type);\n \tTYPE_STUB (type) = 1;\n@@ -1716,14 +1716,14 @@ read_type (const char **pp, struct objfile *objfile)\n       /* Allocate and enter the typedef type first.\n          This handles recursive types.  */\n       type = dbx_alloc_type (typenums, objfile);\n-      TYPE_CODE (type) = TYPE_CODE_TYPEDEF;\n+      type->set_code (TYPE_CODE_TYPEDEF);\n       {\n \tstruct type *xtype = read_type (pp, objfile);\n \n \tif (type == xtype)\n \t  {\n \t    /* It's being defined as itself.  That means it is \"void\".  */\n-\t    TYPE_CODE (type) = TYPE_CODE_VOID;\n+\t    type->set_code (TYPE_CODE_VOID);\n \t    TYPE_LENGTH (type) = 1;\n \t  }\n \telse if (type_size >= 0 || is_string)\n@@ -2022,7 +2022,7 @@ read_type (const char **pp, struct objfile *objfile)\n       type = dbx_alloc_type (typenums, objfile);\n       type = read_array_type (pp, type, objfile);\n       if (is_string)\n-\tTYPE_CODE (type) = TYPE_CODE_STRING;\n+\ttype->set_code (TYPE_CODE_STRING);\n       if (is_vector)\n \tmake_vector_type (type);\n       break;\n@@ -2370,7 +2370,7 @@ read_member_functions (struct stab_field_info *fip, const char **pp,\n \n \t  /* These are methods, not functions.  */\n \t  if (TYPE_CODE (new_sublist->fn_field.type) == TYPE_CODE_FUNC)\n-\t    TYPE_CODE (new_sublist->fn_field.type) = TYPE_CODE_METHOD;\n+\t    new_sublist->fn_field.type->set_code (TYPE_CODE_METHOD);\n \t  else\n \t    gdb_assert (TYPE_CODE (new_sublist->fn_field.type)\n \t\t\t== TYPE_CODE_METHOD);\n@@ -3477,7 +3477,7 @@ read_struct_type (const char **pp, struct type *type, enum type_code type_code,\n     }\n \n   INIT_CPLUS_SPECIFIC (type);\n-  TYPE_CODE (type) = type_code;\n+  type->set_code (type_code);\n   TYPE_STUB (type) = 0;\n \n   /* First comes the total size in bytes.  */\n@@ -3652,7 +3652,7 @@ read_enum_type (const char **pp, struct type *type,\n \n   TYPE_LENGTH (type) = gdbarch_int_bit (gdbarch) / HOST_CHAR_BIT;\n   set_length_in_type_chain (type);\n-  TYPE_CODE (type) = TYPE_CODE_ENUM;\n+  type->set_code (TYPE_CODE_ENUM);\n   TYPE_STUB (type) = 0;\n   if (unsigned_enum)\n     TYPE_UNSIGNED (type) = 1;"
    },
    {
      "sha": "2e7abf5b599825affdf7471566fdf3995ea9df62",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/67607e24d0413828acdfa9bc38f6fbac40b860b9/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=67607e24d0413828acdfa9bc38f6fbac40b860b9",
      "patch": "@@ -3792,7 +3792,7 @@ value_slice (struct value *array, int lowbound, int length)\n     slice_type = create_array_type (NULL,\n \t\t\t\t    element_type,\n \t\t\t\t    slice_range_type);\n-    TYPE_CODE (slice_type) = TYPE_CODE (array_type);\n+    slice_type->set_code (TYPE_CODE (array_type));\n \n     if (VALUE_LVAL (array) == lval_memory && value_lazy (array))\n       slice = allocate_value_lazy (slice_type);"
    }
  ]
}