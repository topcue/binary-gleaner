{
  "sha": "08a057e64bb74f4194a216f6693e04b1ad230f48",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDhhMDU3ZTY0YmI3NGY0MTk0YTIxNmY2NjkzZTA0YjFhZDIzMGY0OA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:40Z"
    },
    "message": "Convert ada-exp.y to use operations\n\nThis converts the Ada parser to generate operations rather than\nexp_elements.\n\nThis was the most difficult of the parser conversions, partly due to\nthe decision to integrate Ada expression resolution into the parse,\nand partly due to Ada aggregregate assignment.  A couple of new\nper-parse globals are introduced, along with a number of helper\nfunctions.  Resolution is done in 'ada_pop', yielding the unfortunate\nrule that ada-exp.y should generally not use parser_state::pop\n(exceptions are marked).\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-exp.y: Create operations.\n\t(empty_stoken): Remove.\n\t(ada_pop, ada_wrap, ada_addrof, ada_un_wrap2, ada_wrap2)\n\t(ada_wrap_op, ada_wrap3, ada_funcall): New functions.\n\t(components): New global.\n\t(push_component, choice_component, pop_component, pop_components):\n\tNew functions.\n\t(associations): New global\n\t(push_association, pop_association, pop_associations): New\n\tfunctions.\n\t(ada_parse): Update.\n\t(write_var_from_sym, write_int): Create operations.\n\t(write_exp_op_with_string): Remove.\n\t(write_object_renaming, write_selectors, write_ambiguous_var)\n\t(write_var_or_type, write_name_assoc): Create operations.\n\t* ada-lang.h (ada_index_type): Declare.\n\t* ada-lang.c (ada_index_type): No longer static.",
    "tree": {
      "sha": "f4c76837efc277a660dfc9c2aef46262afb6a7aa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f4c76837efc277a660dfc9c2aef46262afb6a7aa"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/08a057e64bb74f4194a216f6693e04b1ad230f48",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08a057e64bb74f4194a216f6693e04b1ad230f48",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/08a057e64bb74f4194a216f6693e04b1ad230f48",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08a057e64bb74f4194a216f6693e04b1ad230f48/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d308ba78cfaf7c1b3a8d33ceb66c9a180352b888"
    }
  ],
  "stats": {
    "total": 692,
    "additions": 483,
    "deletions": 209
  },
  "files": [
    {
      "sha": "5ecd54e7a06a62de83eca51cf1123fa31ec0f468",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08a057e64bb74f4194a216f6693e04b1ad230f48/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08a057e64bb74f4194a216f6693e04b1ad230f48/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=08a057e64bb74f4194a216f6693e04b1ad230f48",
      "patch": "@@ -1,3 +1,23 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-exp.y: Create operations.\n+\t(empty_stoken): Remove.\n+\t(ada_pop, ada_wrap, ada_addrof, ada_un_wrap2, ada_wrap2)\n+\t(ada_wrap_op, ada_wrap3, ada_funcall): New functions.\n+\t(components): New global.\n+\t(push_component, choice_component, pop_component, pop_components):\n+\tNew functions.\n+\t(associations): New global\n+\t(push_association, pop_association, pop_associations): New\n+\tfunctions.\n+\t(ada_parse): Update.\n+\t(write_var_from_sym, write_int): Create operations.\n+\t(write_exp_op_with_string): Remove.\n+\t(write_object_renaming, write_selectors, write_ambiguous_var)\n+\t(write_var_or_type, write_name_assoc): Create operations.\n+\t* ada-lang.h (ada_index_type): Declare.\n+\t* ada-lang.c (ada_index_type): No longer static.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* f-exp.y: Create operations."
    },
    {
      "sha": "de88c863cff24fde405bef6a037a9c65d9a8b4d0",
      "filename": "gdb/ada-exp.y",
      "status": "modified",
      "additions": 453,
      "deletions": 203,
      "changes": 656,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08a057e64bb74f4194a216f6693e04b1ad230f48/gdb/ada-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08a057e64bb74f4194a216f6693e04b1ad230f48/gdb/ada-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-exp.y?ref=08a057e64bb74f4194a216f6693e04b1ad230f48",
      "patch": "@@ -47,6 +47,7 @@\n #include \"objfiles.h\" /* For have_full_symbols and have_partial_symbols */\n #include \"frame.h\"\n #include \"block.h\"\n+#include \"ada-exp.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n \n@@ -67,8 +68,6 @@ struct name_info {\n \n static struct parser_state *pstate = NULL;\n \n-static struct stoken empty_stoken = { \"\", 0 };\n-\n /* If expression is in the context of TYPE'(...), then TYPE, else\n  * NULL.  */\n static struct type *type_qualifier;\n@@ -90,9 +89,6 @@ static struct type* write_var_or_type (struct parser_state *,\n \n static void write_name_assoc (struct parser_state *, struct stoken);\n \n-static void write_exp_op_with_string (struct parser_state *, enum exp_opcode,\n-\t\t\t\t      struct stoken);\n-\n static const struct block *block_lookup (const struct block *, const char *);\n \n static LONGEST convert_char_literal (struct type *, LONGEST);\n@@ -114,6 +110,233 @@ static struct type *type_boolean (struct parser_state *);\n \n static struct type *type_system_address (struct parser_state *);\n \n+using namespace expr;\n+\n+/* Handle Ada type resolution for OP.  DEPROCEDURE_P and CONTEXT_TYPE\n+   are passed to the resolve method, if called.  */\n+static operation_up\n+resolve (operation_up &&op, bool deprocedure_p, struct type *context_type)\n+{\n+  operation_up result = std::move (op);\n+  ada_resolvable *res = dynamic_cast<ada_resolvable *> (result.get ());\n+  if (res != nullptr\n+      && res->resolve (pstate->expout.get (),\n+\t\t       deprocedure_p,\n+\t\t       pstate->parse_completion,\n+\t\t       pstate->block_tracker,\n+\t\t       context_type))\n+    result\n+      = make_operation<ada_funcall_operation> (std::move (result),\n+\t\t\t\t\t       std::vector<operation_up> ());\n+\n+  return result;\n+}\n+\n+/* Like parser_state::pop, but handles Ada type resolution.\n+   DEPROCEDURE_P and CONTEXT_TYPE are passed to the resolve method, if\n+   called.  */\n+static operation_up\n+ada_pop (bool deprocedure_p = true, struct type *context_type = nullptr)\n+{\n+  /* Of course it's ok to call parser_state::pop here... */\n+  return resolve (pstate->pop (), deprocedure_p, context_type);\n+}\n+\n+/* Like parser_state::wrap, but use ada_pop to pop the value.  */\n+template<typename T>\n+void\n+ada_wrap ()\n+{\n+  operation_up arg = ada_pop ();\n+  pstate->push_new<T> (std::move (arg));\n+}\n+\n+/* Create and push an address-of operation, as appropriate for Ada.\n+   If TYPE is not NULL, the resulting operation will be wrapped in a\n+   cast to TYPE.  */\n+static void\n+ada_addrof (struct type *type = nullptr)\n+{\n+  operation_up arg = ada_pop (false);\n+  operation_up addr = make_operation<unop_addr_operation> (std::move (arg));\n+  operation_up wrapped\n+    = make_operation<ada_wrapped_operation> (std::move (addr));\n+  if (type != nullptr)\n+    wrapped = make_operation<unop_cast_operation> (std::move (wrapped), type);\n+  pstate->push (std::move (wrapped));\n+}\n+\n+/* A variant of parser_state::wrap2 that uses ada_pop to pop both\n+   operands, and then pushes a new Ada-wrapped operation of the\n+   template type T.  */\n+template<typename T>\n+void\n+ada_un_wrap2 ()\n+{\n+  operation_up rhs = ada_pop ();\n+  operation_up lhs = ada_pop ();\n+  operation_up wrapped = make_operation<T> (std::move (lhs), std::move (rhs));\n+  pstate->push_new<ada_wrapped_operation> (std::move (wrapped));\n+}\n+\n+/* A variant of parser_state::wrap2 that uses ada_pop to pop both\n+   operands.  Unlike ada_un_wrap2, ada_wrapped_operation is not\n+   used.  */\n+template<typename T>\n+void\n+ada_wrap2 ()\n+{\n+  operation_up rhs = ada_pop ();\n+  operation_up lhs = ada_pop ();\n+  pstate->push_new<T> (std::move (lhs), std::move (rhs));\n+}\n+\n+/* A variant of parser_state::wrap2 that uses ada_pop to pop both\n+   operands.  OP is also passed to the constructor of the new binary\n+   operation.  */\n+template<typename T>\n+void\n+ada_wrap_op (enum exp_opcode op)\n+{\n+  operation_up rhs = ada_pop ();\n+  operation_up lhs = ada_pop ();\n+  pstate->push_new<T> (op, std::move (lhs), std::move (rhs));\n+}\n+\n+/* Pop three operands using ada_pop, then construct a new ternary\n+   operation of type T and push it.  */\n+template<typename T>\n+void\n+ada_wrap3 ()\n+{\n+  operation_up rhs = ada_pop ();\n+  operation_up mid = ada_pop ();\n+  operation_up lhs = ada_pop ();\n+  pstate->push_new<T> (std::move (lhs), std::move (mid), std::move (rhs));\n+}\n+\n+/* Pop NARGS operands, then a callee operand, and use these to\n+   construct and push a new Ada function call operation.  */\n+static void\n+ada_funcall (int nargs)\n+{\n+  /* We use the ordinary pop here, because we're going to do\n+     resolution in a separate step, in order to handle array\n+     indices.  */\n+  std::vector<operation_up> args = pstate->pop_vector (nargs);\n+  /* Call parser_state::pop here, because we don't want to\n+     function-convert the callee slot of a call we're already\n+     constructing.  */\n+  operation_up callee = pstate->pop ();\n+\n+  ada_var_value_operation *vvo\n+    = dynamic_cast<ada_var_value_operation *> (callee.get ());\n+  int array_arity = 0;\n+  struct type *callee_t = nullptr;\n+  if (vvo == nullptr\n+      || SYMBOL_DOMAIN (vvo->get_symbol ()) != UNDEF_DOMAIN)\n+    {\n+      struct value *callee_v = callee->evaluate (nullptr,\n+\t\t\t\t\t\t pstate->expout.get (),\n+\t\t\t\t\t\t EVAL_AVOID_SIDE_EFFECTS);\n+      callee_t = ada_check_typedef (value_type (callee_v));\n+      array_arity = ada_array_arity (callee_t);\n+    }\n+\n+  for (int i = 0; i < nargs; ++i)\n+    {\n+      struct type *subtype = nullptr;\n+      if (i < array_arity)\n+\tsubtype = ada_index_type (callee_t, i + 1, \"array type\");\n+      args[i] = resolve (std::move (args[i]), true, subtype);\n+    }\n+\n+  std::unique_ptr<ada_funcall_operation> funcall\n+    (new ada_funcall_operation (std::move (callee), std::move (args)));\n+  funcall->resolve (pstate->expout.get (), true, pstate->parse_completion,\n+\t\t    pstate->block_tracker, nullptr);\n+  pstate->push (std::move (funcall));\n+}\n+\n+/* The components being constructed during this parse.  */\n+static std::vector<ada_component_up> components;\n+\n+/* Create a new ada_component_up of the indicated type and arguments,\n+   and push it on the global 'components' vector.  */\n+template<typename T, typename... Arg>\n+void\n+push_component (Arg... args)\n+{\n+  components.emplace_back (new T (std::forward<Arg> (args)...));\n+}\n+\n+/* Examine the final element of the 'components' vector, and return it\n+   as a pointer to an ada_choices_component.  The caller is\n+   responsible for ensuring that the final element is in fact an\n+   ada_choices_component.  */\n+static ada_choices_component *\n+choice_component ()\n+{\n+  ada_component *last = components.back ().get ();\n+  ada_choices_component *result = dynamic_cast<ada_choices_component *> (last);\n+  gdb_assert (result != nullptr);\n+  return result;\n+}\n+\n+/* Pop the most recent component from the global stack, and return\n+   it.  */\n+static ada_component_up\n+pop_component ()\n+{\n+  ada_component_up result = std::move (components.back ());\n+  components.pop_back ();\n+  return result;\n+}\n+\n+/* Pop the N most recent components from the global stack, and return\n+   them in a vector.  */\n+static std::vector<ada_component_up>\n+pop_components (int n)\n+{\n+  std::vector<ada_component_up> result (n);\n+  for (int i = 1; i <= n; ++i)\n+    result[n - i] = pop_component ();\n+  return result;\n+}\n+\n+/* The associations being constructed during this parse.  */\n+static std::vector<ada_association_up> associations;\n+\n+/* Create a new ada_association_up of the indicated type and\n+   arguments, and push it on the global 'associations' vector.  */\n+template<typename T, typename... Arg>\n+void\n+push_association (Arg... args)\n+{\n+  associations.emplace_back (new T (std::forward<Arg> (args)...));\n+}\n+\n+/* Pop the most recent association from the global stack, and return\n+   it.  */\n+static ada_association_up\n+pop_association ()\n+{\n+  ada_association_up result = std::move (associations.back ());\n+  associations.pop_back ();\n+  return result;\n+}\n+\n+/* Pop the N most recent associations from the global stack, and\n+   return them in a vector.  */\n+static std::vector<ada_association_up>\n+pop_associations (int n)\n+{\n+  std::vector<ada_association_up> result (n);\n+  for (int i = 1; i <= n; ++i)\n+    result[n - i] = pop_association ();\n+  return result;\n+}\n+\n %}\n \n %union\n@@ -135,7 +358,7 @@ static struct type *type_system_address (struct parser_state *);\n \n %type <lval> positional_list component_groups component_associations\n %type <lval> aggregate_component_list \n-%type <tval> var_or_type\n+%type <tval> var_or_type type_prefix opt_type_prefix\n \n %token <typed_val> INT NULL_PTR CHARLIT\n %token <typed_val_float> FLOAT\n@@ -188,43 +411,38 @@ start   :\texp1\n /* Expressions, including the sequencing operator.  */\n exp1\t:\texp\n \t|\texp1 ';' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_COMMA); }\n+\t\t\t{ ada_wrap2<comma_operation> (); }\n \t| \tprimary ASSIGN exp   /* Extension for convenience */\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN); }\n+\t\t\t{ ada_wrap2<ada_assign_operation> (); }\n \t;\n \n /* Expressions, not including the sequencing operator.  */\n primary :\tprimary DOT_ALL\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_IND); }\n+\t\t\t{ ada_wrap<ada_unop_ind_operation> (); }\n \t;\n \n primary :\tprimary DOT_ID\n-\t\t\t{ write_exp_op_with_string (pstate, STRUCTOP_STRUCT,\n-\t\t\t\t\t\t    $2); }\n+\t\t\t{\n+\t\t\t  operation_up arg = ada_pop ();\n+\t\t\t  pstate->push_new<ada_structop_operation>\n+\t\t\t    (std::move (arg), copy_name ($2));\n+\t\t\t}\n \t;\n \n primary :\tprimary '(' arglist ')'\n-\t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t  write_exp_elt_longcst (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t}\n+\t\t\t{ ada_funcall ($3); }\n \t|\tvar_or_type '(' arglist ')'\n \t\t\t{\n \t\t\t  if ($1 != NULL)\n \t\t\t    {\n \t\t\t      if ($3 != 1)\n \t\t\t\terror (_(\"Invalid conversion\"));\n-\t\t\t      write_exp_elt_opcode (pstate, UNOP_CAST);\n-\t\t\t      write_exp_elt_type (pstate, $1);\n-\t\t\t      write_exp_elt_opcode (pstate, UNOP_CAST);\n+\t\t\t      operation_up arg = ada_pop ();\n+\t\t\t      pstate->push_new<unop_cast_operation>\n+\t\t\t\t(std::move (arg), $1);\n \t\t\t    }\n \t\t\t  else\n-\t\t\t    {\n-\t\t\t      write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t      write_exp_elt_longcst (pstate, $3);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t    }\n+\t\t\t    ada_funcall ($3);\n \t\t\t}\n \t;\n \n@@ -233,9 +451,10 @@ primary :\tvar_or_type '\\'' save_qualifier { type_qualifier = $1; }\n \t\t\t{\n \t\t\t  if ($1 == NULL)\n \t\t\t    error (_(\"Type required for qualification\"));\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_QUAL);\n-\t\t\t  write_exp_elt_type (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_QUAL);\n+\t\t\t  operation_up arg = ada_pop (true,\n+\t\t\t\t\t\t      check_typedef ($1));\n+\t\t\t  pstate->push_new<ada_qual_operation>\n+\t\t\t    (std::move (arg), $1);\n \t\t\t  type_qualifier = $3;\n \t\t\t}\n \t;\n@@ -245,10 +464,10 @@ save_qualifier : \t{ $$ = type_qualifier; }\n \n primary :\n \t\tprimary '(' simple_exp DOTDOT simple_exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, TERNOP_SLICE); }\n+\t\t\t{ ada_wrap3<ada_ternop_slice_operation> (); }\n \t|\tvar_or_type '(' simple_exp DOTDOT simple_exp ')'\n \t\t\t{ if ($1 == NULL) \n-\t\t\t    write_exp_elt_opcode (pstate, TERNOP_SLICE);\n+\t\t\t    ada_wrap3<ada_ternop_slice_operation> ();\n \t\t\t  else\n \t\t\t    error (_(\"Cannot slice a type\"));\n \t\t\t}\n@@ -267,38 +486,40 @@ primary :\t'(' exp1 ')'\t{ }\n \n primary :\tvar_or_type\t%prec VAR\n \t\t\t{ if ($1 != NULL)\n-\t\t\t    {\n-\t\t\t      write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t\t      write_exp_elt_type (pstate, $1);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t\t    }\n+\t\t\t    pstate->push_new<type_operation> ($1);\n \t\t\t}\n \t;\n \n primary :\tDOLLAR_VARIABLE /* Various GDB extensions */\n-\t\t\t{ write_dollar_variable (pstate, $1); }\n+\t\t\t{ pstate->push_dollar ($1); }\n \t;\n \n primary :     \taggregate\n+\t\t\t{\n+\t\t\t  pstate->push_new<ada_aggregate_operation>\n+\t\t\t    (pop_component ());\n+\t\t\t}\n \t;        \n \n simple_exp : \tprimary\n \t;\n \n simple_exp :\t'-' simple_exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_NEG); }\n+\t\t\t{ ada_wrap<ada_neg_operation> (); }\n \t;\n \n simple_exp :\t'+' simple_exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PLUS); }\n+\t\t\t{\n+\t\t\t  /* No need to do anything.  */\n+\t\t\t}\n \t;\n \n simple_exp :\tNOT simple_exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT); }\n+\t\t\t{ ada_wrap<unary_logical_not_operation> (); }\n \t;\n \n simple_exp :    ABS simple_exp\t   %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ABS); }\n+\t\t\t{ ada_wrap<ada_abs_operation> (); }\n \t;\n \n arglist\t:\t\t{ $$ = 0; }\n@@ -319,111 +540,114 @@ primary :\t'{' var_or_type '}' primary  %prec '.'\n \t\t\t{ \n \t\t\t  if ($2 == NULL)\n \t\t\t    error (_(\"Type required within braces in coercion\"));\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_MEMVAL);\n-\t\t\t  write_exp_elt_type (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_MEMVAL);\n+\t\t\t  operation_up arg = ada_pop ();\n+\t\t\t  pstate->push_new<unop_memval_operation>\n+\t\t\t    (std::move (arg), $2);\n \t\t\t}\n \t;\n \n /* Binary operators in order of decreasing precedence.  */\n \n simple_exp \t: \tsimple_exp STARSTAR simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_EXP); }\n+\t\t\t{ ada_wrap2<ada_binop_exp_operation> (); }\n \t;\n \n simple_exp\t:\tsimple_exp '*' simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_MUL); }\n+\t\t\t{ ada_wrap2<ada_binop_mul_operation> (); }\n \t;\n \n simple_exp\t:\tsimple_exp '/' simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_DIV); }\n+\t\t\t{ ada_wrap2<ada_binop_div_operation> (); }\n \t;\n \n simple_exp\t:\tsimple_exp REM simple_exp /* May need to be fixed to give correct Ada REM */\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REM); }\n+\t\t\t{ ada_wrap2<ada_binop_rem_operation> (); }\n \t;\n \n simple_exp\t:\tsimple_exp MOD simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_MOD); }\n+\t\t\t{ ada_wrap2<ada_binop_mod_operation> (); }\n \t;\n \n simple_exp\t:\tsimple_exp '@' simple_exp\t/* GDB extension */\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REPEAT); }\n+\t\t\t{ ada_wrap2<repeat_operation> (); }\n \t;\n \n simple_exp\t:\tsimple_exp '+' simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ADD); }\n+\t\t\t{ ada_wrap_op<ada_binop_addsub_operation> (BINOP_ADD); }\n \t;\n \n simple_exp\t:\tsimple_exp '&' simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_CONCAT); }\n+\t\t\t{ ada_wrap2<concat_operation> (); }\n \t;\n \n simple_exp\t:\tsimple_exp '-' simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUB); }\n+\t\t\t{ ada_wrap_op<ada_binop_addsub_operation> (BINOP_SUB); }\n \t;\n \n relation :\tsimple_exp\n \t;\n \n relation :\tsimple_exp '=' simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }\n+\t\t\t{ ada_wrap_op<ada_binop_equal_operation> (BINOP_EQUAL); }\n \t;\n \n relation :\tsimple_exp NOTEQUAL simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }\n+\t\t\t{ ada_wrap_op<ada_binop_equal_operation> (BINOP_NOTEQUAL); }\n \t;\n \n relation :\tsimple_exp LEQ simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LEQ); }\n+\t\t\t{ ada_un_wrap2<leq_operation> (); }\n \t;\n \n relation :\tsimple_exp IN simple_exp DOTDOT simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, TERNOP_IN_RANGE); }\n+\t\t\t{ ada_wrap3<ada_ternop_range_operation> (); }\n \t|       simple_exp IN primary TICK_RANGE tick_arglist\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_IN_BOUNDS);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $5);\n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_IN_BOUNDS);\n+\t\t\t{\n+\t\t\t  operation_up rhs = ada_pop ();\n+\t\t\t  operation_up lhs = ada_pop ();\n+\t\t\t  pstate->push_new<ada_binop_in_bounds_operation>\n+\t\t\t    (std::move (lhs), std::move (rhs), $5);\n \t\t\t}\n  \t|\tsimple_exp IN var_or_type\t%prec TICK_ACCESS\n \t\t\t{ \n \t\t\t  if ($3 == NULL)\n \t\t\t    error (_(\"Right operand of 'in' must be type\"));\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n-\t\t\t  write_exp_elt_type (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n+\t\t\t  operation_up arg = ada_pop ();\n+\t\t\t  pstate->push_new<ada_unop_range_operation>\n+\t\t\t    (std::move (arg), $3);\n \t\t\t}\n \t|\tsimple_exp NOT IN simple_exp DOTDOT simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, TERNOP_IN_RANGE);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n-\t\t\t}\n+\t\t\t{ ada_wrap3<ada_ternop_range_operation> ();\n+\t\t\t  ada_wrap<unary_logical_not_operation> (); }\n \t|       simple_exp NOT IN primary TICK_RANGE tick_arglist\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_IN_BOUNDS);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $6);\n-\t\t\t  write_exp_elt_opcode (pstate, BINOP_IN_BOUNDS);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n+\t\t\t{\n+\t\t\t  operation_up rhs = ada_pop ();\n+\t\t\t  operation_up lhs = ada_pop ();\n+\t\t\t  pstate->push_new<ada_binop_in_bounds_operation>\n+\t\t\t    (std::move (lhs), std::move (rhs), $6);\n+\t\t\t  ada_wrap<unary_logical_not_operation> ();\n \t\t\t}\n  \t|\tsimple_exp NOT IN var_or_type\t%prec TICK_ACCESS\n \t\t\t{ \n \t\t\t  if ($4 == NULL)\n \t\t\t    error (_(\"Right operand of 'in' must be type\"));\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n-\t\t\t  write_exp_elt_type (pstate, $4);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_IN_RANGE);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT);\n+\t\t\t  operation_up arg = ada_pop ();\n+\t\t\t  pstate->push_new<ada_unop_range_operation>\n+\t\t\t    (std::move (arg), $4);\n+\t\t\t  ada_wrap<unary_logical_not_operation> ();\n \t\t\t}\n \t;\n \n relation :\tsimple_exp GEQ simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GEQ); }\n+\t\t\t{ ada_un_wrap2<geq_operation> (); }\n \t;\n \n relation :\tsimple_exp '<' simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LESS); }\n+\t\t\t{ ada_un_wrap2<less_operation> (); }\n \t;\n \n relation :\tsimple_exp '>' simple_exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GTR); }\n+\t\t\t{ ada_un_wrap2<gtr_operation> (); }\n \t;\n \n exp\t:\trelation\n@@ -436,36 +660,36 @@ exp\t:\trelation\n \n and_exp :\n \t\trelation _AND_ relation \n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_AND); }\n+\t\t\t{ ada_wrap2<ada_bitwise_and_operation> (); }\n \t|\tand_exp _AND_ relation\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_AND); }\n+\t\t\t{ ada_wrap2<ada_bitwise_and_operation> (); }\n \t;\n \n and_then_exp :\n \t       relation _AND_ THEN relation\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n+\t\t\t{ ada_wrap2<logical_and_operation> (); }\n \t|\tand_then_exp _AND_ THEN relation\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n+\t\t\t{ ada_wrap2<logical_and_operation> (); }\n \t;\n \n or_exp :\n \t\trelation OR relation \n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_IOR); }\n+\t\t\t{ ada_wrap2<ada_bitwise_ior_operation> (); }\n \t|\tor_exp OR relation\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_IOR); }\n+\t\t\t{ ada_wrap2<ada_bitwise_ior_operation> (); }\n \t;\n \n or_else_exp :\n \t       relation OR ELSE relation\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n+\t\t\t{ ada_wrap2<logical_or_operation> (); }\n \t|      or_else_exp OR ELSE relation\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n+\t\t\t{ ada_wrap2<logical_or_operation> (); }\n \t;\n \n xor_exp :       relation XOR relation\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n+\t\t\t{ ada_wrap2<ada_bitwise_xor_operation> (); }\n \t|\txor_exp XOR relation\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n+\t\t\t{ ada_wrap2<ada_bitwise_xor_operation> (); }\n \t;\n \n /* Primaries can denote types (OP_TYPE).  In cases such as \n@@ -477,37 +701,51 @@ xor_exp :       relation XOR relation\n    aType'access evaluates to a type that evaluate_subexp attempts to \n    evaluate. */\n primary :\tprimary TICK_ACCESS\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ADDR); }\n+\t\t\t{ ada_addrof (); }\n \t|\tprimary TICK_ADDRESS\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ADDR);\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t      type_system_address (pstate));\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST);\n-\t\t\t}\n+\t\t\t{ ada_addrof (type_system_address (pstate)); }\n \t|\tprimary TICK_FIRST tick_arglist\n-\t\t\t{ write_int (pstate, $3, type_int (pstate));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_ATR_FIRST); }\n+\t\t\t{\n+\t\t\t  operation_up arg = ada_pop ();\n+\t\t\t  pstate->push_new<ada_unop_atr_operation>\n+\t\t\t    (std::move (arg), OP_ATR_FIRST, $3);\n+\t\t\t}\n \t|\tprimary TICK_LAST tick_arglist\n-\t\t\t{ write_int (pstate, $3, type_int (pstate));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_ATR_LAST); }\n+\t\t\t{\n+\t\t\t  operation_up arg = ada_pop ();\n+\t\t\t  pstate->push_new<ada_unop_atr_operation>\n+\t\t\t    (std::move (arg), OP_ATR_LAST, $3);\n+\t\t\t}\n \t| \tprimary TICK_LENGTH tick_arglist\n-\t\t\t{ write_int (pstate, $3, type_int (pstate));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_ATR_LENGTH); }\n+\t\t\t{\n+\t\t\t  operation_up arg = ada_pop ();\n+\t\t\t  pstate->push_new<ada_unop_atr_operation>\n+\t\t\t    (std::move (arg), OP_ATR_LENGTH, $3);\n+\t\t\t}\n \t|       primary TICK_SIZE\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_SIZE); }\n+\t\t\t{ ada_wrap<ada_atr_size_operation> (); }\n \t|\tprimary TICK_TAG\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_TAG); }\n+\t\t\t{ ada_wrap<ada_atr_tag_operation> (); }\n \t|       opt_type_prefix TICK_MIN '(' exp ',' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_MIN); }\n+\t\t\t{ ada_wrap2<ada_binop_min_operation> (); }\n \t|       opt_type_prefix TICK_MAX '(' exp ',' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_MAX); }\n+\t\t\t{ ada_wrap2<ada_binop_max_operation> (); }\n \t| \topt_type_prefix TICK_POS '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_POS); }\n+\t\t\t{ ada_wrap<ada_pos_operation> (); }\n \t|\ttype_prefix TICK_VAL '(' exp ')'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_VAL); }\n+\t\t\t{\n+\t\t\t  operation_up arg = ada_pop ();\n+\t\t\t  pstate->push_new<ada_atr_val_operation>\n+\t\t\t    ($1, std::move (arg));\n+\t\t\t}\n \t|\ttype_prefix TICK_MODULUS\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_ATR_MODULUS); }\n+\t\t\t{\n+\t\t\t  struct type *type_arg = check_typedef ($1);\n+\t\t\t  if (!ada_is_modular_type (type_arg))\n+\t\t\t    error (_(\"'modulus must be applied to modular type\"));\n+\t\t\t  write_int (pstate, ada_modulus (type_arg),\n+\t\t\t\t     TYPE_TARGET_TYPE (type_arg));\n+\t\t\t}\n \t;\n \n tick_arglist :\t\t\t%prec '('\n@@ -521,18 +759,15 @@ type_prefix :\n \t\t\t{ \n \t\t\t  if ($1 == NULL)\n \t\t\t    error (_(\"Prefix must be type\"));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t\t  write_exp_elt_type (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPE); }\n+\t\t\t  $$ = $1;\n+\t\t\t}\n \t;\n \n opt_type_prefix :\n \t\ttype_prefix\n+\t\t\t{ $$ = $1; }\n \t| \t/* EMPTY */\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t  parse_type (pstate)->builtin_void);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPE); }\n+\t\t\t{ $$ = parse_type (pstate)->builtin_void; }\n \t;\n \n \n@@ -549,10 +784,13 @@ primary\t:\tCHARLIT\n \t;\n \n primary\t:\tFLOAT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_floatcst (pstate, $1.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n+\t\t\t{\n+\t\t\t  float_data data;\n+\t\t\t  std::copy (std::begin ($1.val), std::end ($1.val),\n+\t\t\t\t     std::begin (data));\n+\t\t\t  pstate->push_new<float_const_operation>\n+\t\t\t    ($1.type, data);\n+\t\t\t  ada_wrap<ada_wrapped_operation> ();\n \t\t\t}\n \t;\n \n@@ -562,7 +800,8 @@ primary\t:\tNULL_PTR\n \n primary\t:\tSTRING\n \t\t\t{ \n-\t\t\t  write_exp_op_with_string (pstate, OP_STRING, $1);\n+\t\t\t  pstate->push_new<ada_string_operation>\n+\t\t\t    (copy_name ($1));\n \t\t\t}\n \t;\n \n@@ -584,15 +823,15 @@ var_or_type:\tNAME   \t    %prec VAR\n \t\t\t{ \n \t\t\t  $$ = write_var_or_type (pstate, NULL, $1);\n \t\t\t  if ($$ == NULL)\n-\t\t\t    write_exp_elt_opcode (pstate, UNOP_ADDR);\n+\t\t\t    ada_addrof ();\n \t\t\t  else\n \t\t\t    $$ = lookup_pointer_type ($$);\n \t\t\t}\n \t|\tblock NAME TICK_ACCESS\n \t\t\t{ \n \t\t\t  $$ = write_var_or_type (pstate, $1, $2);\n \t\t\t  if ($$ == NULL)\n-\t\t\t    write_exp_elt_opcode (pstate, UNOP_ADDR);\n+\t\t\t    ada_addrof ();\n \t\t\t  else\n \t\t\t    $$ = lookup_pointer_type ($$);\n \t\t\t}\n@@ -608,18 +847,20 @@ block   :       NAME COLONCOLON\n aggregate :\n \t\t'(' aggregate_component_list ')'  \n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_AGGREGATE);\n-\t\t\t  write_exp_elt_longcst (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_AGGREGATE);\n+\t\t\t  std::vector<ada_component_up> components\n+\t\t\t    = pop_components ($2);\n+\n+\t\t\t  push_component<ada_aggregate_component>\n+\t\t\t    (std::move (components));\n \t\t\t}\n \t;\n \n aggregate_component_list :\n \t\tcomponent_groups\t { $$ = $1; }\n \t|\tpositional_list exp\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_POSITIONAL);\n-\t\t\t  write_exp_elt_longcst (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_POSITIONAL);\n+\t\t\t{\n+\t\t\t  push_component<ada_positional_component>\n+\t\t\t    ($1, ada_pop ());\n \t\t\t  $$ = $1 + 1;\n \t\t\t}\n \t|\tpositional_list component_groups\n@@ -628,15 +869,15 @@ aggregate_component_list :\n \n positional_list :\n \t\texp ','\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_POSITIONAL);\n-\t\t\t  write_exp_elt_longcst (pstate, 0);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_POSITIONAL);\n+\t\t\t{\n+\t\t\t  push_component<ada_positional_component>\n+\t\t\t    (0, ada_pop ());\n \t\t\t  $$ = 1;\n \t\t\t} \n \t|\tpositional_list exp ','\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_POSITIONAL);\n-\t\t\t  write_exp_elt_longcst (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_POSITIONAL);\n+\t\t\t{\n+\t\t\t  push_component<ada_positional_component>\n+\t\t\t    ($1, ada_pop ());\n \t\t\t  $$ = $1 + 1; \n \t\t\t}\n \t;\n@@ -649,15 +890,16 @@ component_groups:\n \t;\n \n others \t:\tOTHERS ARROW exp\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_OTHERS); }\n+\t\t\t{\n+\t\t\t  push_component<ada_others_component> (ada_pop ());\n+\t\t\t}\n \t;\n \n component_group :\n \t\tcomponent_associations\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_CHOICES);\n-\t\t\t  write_exp_elt_longcst (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_CHOICES);\n+\t\t\t  ada_choices_component *choices = choice_component ();\n+\t\t\t  choices->set_associations (pop_associations ($1));\n \t\t\t}\n \t;\n \n@@ -667,36 +909,60 @@ component_group :\n    decisions until after the => or '|', we convert the ambiguity to a \n    resolved shift/reduce conflict. */\n component_associations :\n-\t\tNAME ARROW \n-\t\t\t{ write_name_assoc (pstate, $1); }\n-\t\t    exp\t{ $$ = 1; }\n+\t\tNAME ARROW exp\n+\t\t\t{\n+\t\t\t  push_component<ada_choices_component> (ada_pop ());\n+\t\t\t  write_name_assoc (pstate, $1);\n+\t\t\t  $$ = 1;\n+\t\t\t}\n \t|\tsimple_exp ARROW exp\n-\t\t\t{ $$ = 1; }\n-\t|\tsimple_exp DOTDOT simple_exp ARROW \n-\t\t\t{ write_exp_elt_opcode (pstate, OP_DISCRETE_RANGE);\n-\t\t\t  write_exp_op_with_string (pstate, OP_NAME,\n-\t\t\t\t\t\t    empty_stoken);\n+\t\t\t{\n+\t\t\t  push_component<ada_choices_component> (ada_pop ());\n+\t\t\t  push_association<ada_name_association> (ada_pop ());\n+\t\t\t  $$ = 1;\n+\t\t\t}\n+\t|\tsimple_exp DOTDOT simple_exp ARROW exp\n+\t\t\t{\n+\t\t\t  push_component<ada_choices_component> (ada_pop ());\n+\t\t\t  operation_up rhs = ada_pop ();\n+\t\t\t  operation_up lhs = ada_pop ();\n+\t\t\t  push_association<ada_discrete_range_association>\n+\t\t\t    (std::move (lhs), std::move (rhs));\n+\t\t\t  $$ = 1;\n+\t\t\t}\n+\t|\tNAME '|' component_associations\n+\t\t\t{\n+\t\t\t  write_name_assoc (pstate, $1);\n+\t\t\t  $$ = $3 + 1;\n+\t\t\t}\n+\t|\tsimple_exp '|' component_associations\n+\t\t\t{\n+\t\t\t  push_association<ada_name_association> (ada_pop ());\n+\t\t\t  $$ = $3 + 1;\n+\t\t\t}\n+\t|\tsimple_exp DOTDOT simple_exp '|' component_associations\n+\n+\t\t\t{\n+\t\t\t  operation_up rhs = ada_pop ();\n+\t\t\t  operation_up lhs = ada_pop ();\n+\t\t\t  push_association<ada_discrete_range_association>\n+\t\t\t    (std::move (lhs), std::move (rhs));\n+\t\t\t  $$ = $5 + 1;\n \t\t\t}\n-\t\t    exp { $$ = 1; }\n-\t|\tNAME '|' \n-\t\t\t{ write_name_assoc (pstate, $1); }\n-\t\t    component_associations  { $$ = $4 + 1; }\n-\t|\tsimple_exp '|'  \n-\t\t    component_associations  { $$ = $3 + 1; }\n-\t|\tsimple_exp DOTDOT simple_exp '|'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_DISCRETE_RANGE); }\n-\t\t    component_associations  { $$ = $6 + 1; }\n \t;\n \n /* Some extensions borrowed from C, for the benefit of those who find they\n    can't get used to Ada notation in GDB.  */\n \n primary\t:\t'*' primary\t\t%prec '.'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_IND); }\n+\t\t\t{ ada_wrap<ada_unop_ind_operation> (); }\n \t|\t'&' primary\t\t%prec '.'\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ADDR); }\n+\t\t\t{ ada_addrof (); }\n \t|\tprimary '[' exp ']'\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUBSCRIPT); }\n+\t\t\t{\n+\t\t\t  ada_wrap2<subscript_operation> ();\n+\t\t\t  ada_wrap<ada_wrapped_operation> ();\n+\t\t\t}\n \t;\n \n %%\n@@ -737,8 +1003,18 @@ ada_parse (struct parser_state *par_state)\n   type_qualifier = NULL;\n   obstack_free (&temp_parse_space, NULL);\n   obstack_init (&temp_parse_space);\n+  components.clear ();\n+  associations.clear ();\n \n-  return yyparse ();\n+  int result = yyparse ();\n+  if (!result)\n+    {\n+      struct type *context_type = nullptr;\n+      if (par_state->void_context_p)\n+\tcontext_type = parse_type (par_state)->builtin_void;\n+      pstate->set_operation (ada_pop (true, context_type));\n+    }\n+  return result;\n }\n \n static void\n@@ -758,33 +1034,18 @@ write_var_from_sym (struct parser_state *par_state,\n   if (symbol_read_needs_frame (sym))\n     par_state->block_tracker->update (block, INNERMOST_BLOCK_FOR_SYMBOLS);\n \n-  write_exp_elt_opcode (par_state, OP_VAR_VALUE);\n-  write_exp_elt_block (par_state, block);\n-  write_exp_elt_sym (par_state, sym);\n-  write_exp_elt_opcode (par_state, OP_VAR_VALUE);\n+  par_state->push_new<ada_var_value_operation> (sym, block);\n }\n \n /* Write integer or boolean constant ARG of type TYPE.  */\n \n static void\n write_int (struct parser_state *par_state, LONGEST arg, struct type *type)\n {\n-  write_exp_elt_opcode (par_state, OP_LONG);\n-  write_exp_elt_type (par_state, type);\n-  write_exp_elt_longcst (par_state, arg);\n-  write_exp_elt_opcode (par_state, OP_LONG);\n+  pstate->push_new<long_const_operation> (type, arg);\n+  ada_wrap<ada_wrapped_operation> ();\n }\n \n-/* Write an OPCODE, string, OPCODE sequence to the current expression.  */\n-static void\n-write_exp_op_with_string (struct parser_state *par_state,\n-\t\t\t  enum exp_opcode opcode, struct stoken token)\n-{\n-  write_exp_elt_opcode (par_state, opcode);\n-  write_exp_string (par_state, token);\n-  write_exp_elt_opcode (par_state, opcode);\n-}\n-  \n /* Emit expression corresponding to the renamed object named \n  * designated by RENAMED_ENTITY[0 .. RENAMED_ENTITY_LEN-1] in the\n  * context of ORIG_LEFT_CONTEXT, to which is applied the operations\n@@ -852,7 +1113,7 @@ write_object_renaming (struct parser_state *par_state,\n       switch (*renaming_expr) {\n       case 'A':\n \trenaming_expr += 1;\n-\twrite_exp_elt_opcode (par_state, UNOP_IND);\n+\tada_wrap<ada_unop_ind_operation> ();\n \tbreak;\n       case 'L':\n \tslice_state = LOWER_BOUND;\n@@ -866,10 +1127,7 @@ write_object_renaming (struct parser_state *par_state,\n \t    if (next == renaming_expr)\n \t      goto BadEncoding;\n \t    renaming_expr = next;\n-\t    write_exp_elt_opcode (par_state, OP_LONG);\n-\t    write_exp_elt_type (par_state, type_int (par_state));\n-\t    write_exp_elt_longcst (par_state, (LONGEST) val);\n-\t    write_exp_elt_opcode (par_state, OP_LONG);\n+\t    write_int (par_state, val, type_int (par_state));\n \t  }\n \telse\n \t  {\n@@ -896,25 +1154,19 @@ write_object_renaming (struct parser_state *par_state,\n \t\t\t\tindex_sym_info.symbol);\n \t  }\n \tif (slice_state == SIMPLE_INDEX)\n-\t  {\n-\t    write_exp_elt_opcode (par_state, OP_FUNCALL);\n-\t    write_exp_elt_longcst (par_state, (LONGEST) 1);\n-\t    write_exp_elt_opcode (par_state, OP_FUNCALL);\n-\t  }\n+\t  ada_funcall (1);\n \telse if (slice_state == LOWER_BOUND)\n \t  slice_state = UPPER_BOUND;\n \telse if (slice_state == UPPER_BOUND)\n \t  {\n-\t    write_exp_elt_opcode (par_state, TERNOP_SLICE);\n+\t    ada_wrap3<ada_ternop_slice_operation> ();\n \t    slice_state = SIMPLE_INDEX;\n \t  }\n \tbreak;\n \n       case 'R':\n \t{\n-\t  struct stoken field_name;\n \t  const char *end;\n-\t  char *buf;\n \n \t  renaming_expr += 1;\n \n@@ -923,13 +1175,12 @@ write_object_renaming (struct parser_state *par_state,\n \t  end = strchr (renaming_expr, 'X');\n \t  if (end == NULL)\n \t    end = renaming_expr + strlen (renaming_expr);\n-\t  field_name.length = end - renaming_expr;\n-\t  buf = (char *) malloc (end - renaming_expr + 1);\n-\t  field_name.ptr = buf;\n-\t  strncpy (buf, renaming_expr, end - renaming_expr);\n-\t  buf[end - renaming_expr] = '\\000';\n+\n+\t  operation_up arg = ada_pop ();\n+\t  pstate->push_new<ada_structop_operation>\n+\t    (std::move (arg), std::string (renaming_expr,\n+\t\t\t\t\t   end - renaming_expr));\n \t  renaming_expr = end;\n-\t  write_exp_op_with_string (par_state, STRUCTOP_STRUCT, field_name);\n \t  break;\n \t}\n \n@@ -1085,15 +1336,14 @@ write_selectors (struct parser_state *par_state, char *sels)\n {\n   while (*sels != '\\0')\n     {\n-      struct stoken field_name;\n       char *p = chop_separator (sels);\n       sels = p;\n       while (*sels != '\\0' && *sels != '.' \n \t     && (sels[0] != '_' || sels[1] != '_'))\n \tsels += 1;\n-      field_name.length = sels - p;\n-      field_name.ptr = p;\n-      write_exp_op_with_string (par_state, STRUCTOP_STRUCT, field_name);\n+      operation_up arg = ada_pop ();\n+      pstate->push_new<ada_structop_operation>\n+\t(std::move (arg), std::string (p, sels - p));\n     }\n }\n \n@@ -1111,10 +1361,7 @@ write_ambiguous_var (struct parser_state *par_state,\n   sym->set_linkage_name (obstack_strndup (&temp_parse_space, name, len));\n   sym->set_language (language_ada, nullptr);\n \n-  write_exp_elt_opcode (par_state, OP_VAR_VALUE);\n-  write_exp_elt_block (par_state, block);\n-  write_exp_elt_sym (par_state, sym);\n-  write_exp_elt_opcode (par_state, OP_VAR_VALUE);\n+  par_state->push_new<ada_var_value_operation> (sym, block);\n }\n \n /* A convenient wrapper around ada_get_field_index that takes\n@@ -1303,7 +1550,8 @@ write_var_or_type (struct parser_state *par_state,\n \t\t= ada_lookup_simple_minsym (encoded_name);\n \t      if (msym.minsym != NULL)\n \t\t{\n-\t\t  write_exp_msymbol (par_state, msym);\n+\t\t  par_state->push_new<ada_var_msym_value_operation>\n+\t\t    (msym.minsym, msym.objfile);\n \t\t  /* Maybe cause error here rather than later? FIXME? */\n \t\t  write_selectors (par_state, encoded_name + tail_index);\n \t\t  return NULL;\n@@ -1365,13 +1613,15 @@ write_name_assoc (struct parser_state *par_state, struct stoken name)\n \t\t\t\t  VAR_DOMAIN);\n \n       if (syms.size () != 1 || SYMBOL_CLASS (syms[0].symbol) == LOC_TYPEDEF)\n-\twrite_exp_op_with_string (par_state, OP_NAME, name);\n+\tpstate->push_new<ada_string_operation> (copy_name (name));\n       else\n \twrite_var_from_sym (par_state, syms[0].block, syms[0].symbol);\n     }\n   else\n     if (write_var_or_type (par_state, NULL, name) != NULL)\n       error (_(\"Invalid use of type.\"));\n+\n+  push_association<ada_name_association> (ada_pop ());\n }\n \n /* Convert the character literal whose ASCII value would be VAL to the"
    },
    {
      "sha": "fd072d5aac4244084da3044cc0fad90f9935a42c",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08a057e64bb74f4194a216f6693e04b1ad230f48/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08a057e64bb74f4194a216f6693e04b1ad230f48/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=08a057e64bb74f4194a216f6693e04b1ad230f48",
      "patch": "@@ -2898,13 +2898,9 @@ ada_array_element_type (struct type *type, int nindices)\n   return NULL;\n }\n \n-/* The type of nth index in arrays of given type (n numbering from 1).\n-   Does not examine memory.  Throws an error if N is invalid or TYPE\n-   is not an array type.  NAME is the name of the Ada attribute being\n-   evaluated ('range, 'first, 'last, or 'length); it is used in building\n-   the error message.  */\n+/* See ada-lang.h.  */\n \n-static struct type *\n+struct type *\n ada_index_type (struct type *type, int n, const char *name)\n {\n   struct type *result_type;"
    },
    {
      "sha": "8aaf9757a625f62ff3998aed63149626ce5b5763",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08a057e64bb74f4194a216f6693e04b1ad230f48/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08a057e64bb74f4194a216f6693e04b1ad230f48/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=08a057e64bb74f4194a216f6693e04b1ad230f48",
      "patch": "@@ -417,4 +417,12 @@ extern block_symbol ada_resolve_variable (struct symbol *sym,\n \t\t\t\t\t  int deprocedure_p,\n \t\t\t\t\t  innermost_block_tracker *tracker);\n \n+/* The type of nth index in arrays of given type (n numbering from 1).\n+   Does not examine memory.  Throws an error if N is invalid or TYPE\n+   is not an array type.  NAME is the name of the Ada attribute being\n+   evaluated ('range, 'first, 'last, or 'length); it is used in building\n+   the error message.  */\n+extern struct type *ada_index_type (struct type *type, int n,\n+\t\t\t\t    const char *name);\n+\n #endif"
    }
  ]
}