{
  "sha": "faeb9f13c179a4c78bc295a0d0bbd788239704d9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmFlYjlmMTNjMTc5YTRjNzhiYzI5NWEwZDBiYmQ3ODgyMzk3MDRkOQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-24T12:50:00Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-25T10:09:11Z"
    },
    "message": "gdb/fortran: add support for ASSOCIATED builtin\n\nThis commit adds support for the ASSOCIATED builtin to the Fortran\nexpression evaluator.  The ASSOCIATED builtin takes one or two\narguments.\n\nWhen passed a single pointer argument GDB returns a boolean indicating\nif the pointer is associated with anything.\n\nWhen passed two arguments the second argument should either be some a\npointer could point at or a second pointer.\n\nIf the second argument is a pointer target, then the result from\nassociated indicates if the pointer is pointing at this target.\n\nIf the second argument is another pointer, then the result from\nassociated indicates if the two pointers are pointing at the same\nthing.\n\ngdb/ChangeLog:\n\n\t* f-exp.y (f77_keywords): Add 'associated'.\n\t* f-lang.c (fortran_associated): New function.\n\t(evaluate_subexp_f): Handle FORTRAN_ASSOCIATED.\n\t(operator_length_f): Likewise.\n\t(print_unop_or_binop_subexp_f): New function.\n\t(print_subexp_f): Make use of print_unop_or_binop_subexp_f for\n\tFORTRAN_ASSOCIATED, FORTRAN_LBOUND, and FORTRAN_UBOUND.\n\t(dump_subexp_body_f): Handle FORTRAN_ASSOCIATED.\n\t(operator_check_f): Likewise.\n\t* std-operator.def: Add FORTRAN_ASSOCIATED.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.fortran/associated.exp: New file.\n\t* gdb.fortran/associated.f90: New file.",
    "tree": {
      "sha": "e711b096230391385126b9dc36c0f4c807221266",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/e711b096230391385126b9dc36c0f4c807221266"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/faeb9f13c179a4c78bc295a0d0bbd788239704d9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/faeb9f13c179a4c78bc295a0d0bbd788239704d9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/faeb9f13c179a4c78bc295a0d0bbd788239704d9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/faeb9f13c179a4c78bc295a0d0bbd788239704d9/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "170f4b23b6df18f6f9eb178530b96d3b056818ed",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/170f4b23b6df18f6f9eb178530b96d3b056818ed",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/170f4b23b6df18f6f9eb178530b96d3b056818ed"
    }
  ],
  "stats": {
    "total": 450,
    "additions": 436,
    "deletions": 14
  },
  "files": [
    {
      "sha": "77814795d1dc94b322a65e911de8c0e0029ad2a6",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "patch": "@@ -1,3 +1,16 @@\n+2021-02-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* f-exp.y (f77_keywords): Add 'associated'.\n+\t* f-lang.c (fortran_associated): New function.\n+\t(evaluate_subexp_f): Handle FORTRAN_ASSOCIATED.\n+\t(operator_length_f): Likewise.\n+\t(print_unop_or_binop_subexp_f): New function.\n+\t(print_subexp_f): Make use of print_unop_or_binop_subexp_f for\n+\tFORTRAN_ASSOCIATED, FORTRAN_LBOUND, and FORTRAN_UBOUND.\n+\t(dump_subexp_body_f): Handle FORTRAN_ASSOCIATED.\n+\t(operator_check_f): Likewise.\n+\t* std-operator.def: Add FORTRAN_ASSOCIATED.\n+\n 2021-02-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* f-exp.y (fortran_operators): Add \".xor.\"."
    },
    {
      "sha": "f5360c10ef6f2b74811e0064f623f73fd504554f",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "patch": "@@ -1048,6 +1048,7 @@ static const struct token f77_keywords[] =\n   { \"lbound\", UNOP_OR_BINOP_INTRINSIC, FORTRAN_LBOUND, false },\n   { \"ubound\", UNOP_OR_BINOP_INTRINSIC, FORTRAN_UBOUND, false },\n   { \"allocated\", UNOP_INTRINSIC, UNOP_FORTRAN_ALLOCATED, false },\n+  { \"associated\", UNOP_OR_BINOP_INTRINSIC, FORTRAN_ASSOCIATED, false },\n };\n \n /* Implementation of a dynamically expandable buffer for processing input"
    },
    {
      "sha": "31fff34ae76ab28fb2b9f0a7dbabd6b7a0f7718c",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 232,
      "deletions": 14,
      "changes": 246,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "patch": "@@ -799,6 +799,179 @@ fortran_value_subarray (struct value *array, struct expression *exp,\n   return array;\n }\n \n+/* Evaluate FORTRAN_ASSOCIATED expressions.  Both GDBARCH and LANG are\n+   extracted from the expression being evaluated.  POINTER is the required\n+   first argument to the 'associated' keyword, and TARGET is the optional\n+   second argument, this will be nullptr if the user only passed one\n+   argument to their use of 'associated'.  */\n+\n+static struct value *\n+fortran_associated (struct gdbarch *gdbarch, const language_defn *lang,\n+\t\t    struct value *pointer, struct value *target = nullptr)\n+{\n+  struct type *result_type = language_bool_type (lang, gdbarch);\n+\n+  /* All Fortran pointers should have the associated property, this is\n+     how we know the pointer is pointing at something or not.  */\n+  struct type *pointer_type = check_typedef (value_type (pointer));\n+  if (TYPE_ASSOCIATED_PROP (pointer_type) == nullptr\n+      && pointer_type->code () != TYPE_CODE_PTR)\n+    error (_(\"ASSOCIATED can only be applied to pointers\"));\n+\n+  /* Get an address from POINTER.  Fortran (or at least gfortran) models\n+     array pointers as arrays with a dynamic data address, so we need to\n+     use two approaches here, for real pointers we take the contents of the\n+     pointer as an address.  For non-pointers we take the address of the\n+     content.  */\n+  CORE_ADDR pointer_addr;\n+  if (pointer_type->code () == TYPE_CODE_PTR)\n+    pointer_addr = value_as_address (pointer);\n+  else\n+    pointer_addr = value_address (pointer);\n+\n+  /* The single argument case, is POINTER associated with anything?  */\n+  if (target == nullptr)\n+    {\n+      bool is_associated = false;\n+\n+      /* If POINTER is an actual pointer and doesn't have an associated\n+\t property then we need to figure out whether this pointer is\n+\t associated by looking at the value of the pointer itself.  We make\n+\t the assumption that a non-associated pointer will be set to 0.\n+\t This is probably true for most targets, but might not be true for\n+\t everyone.  */\n+      if (pointer_type->code () == TYPE_CODE_PTR\n+\t  && TYPE_ASSOCIATED_PROP (pointer_type) == nullptr)\n+\tis_associated = (pointer_addr != 0);\n+      else\n+\tis_associated = !type_not_associated (pointer_type);\n+      return value_from_longest (result_type, is_associated ? 1 : 0);\n+    }\n+\n+  /* The two argument case, is POINTER associated with TARGET?  */\n+\n+  struct type *target_type = check_typedef (value_type (target));\n+\n+  struct type *pointer_target_type;\n+  if (pointer_type->code () == TYPE_CODE_PTR)\n+    pointer_target_type = TYPE_TARGET_TYPE (pointer_type);\n+  else\n+    pointer_target_type = pointer_type;\n+\n+  struct type *target_target_type;\n+  if (target_type->code () == TYPE_CODE_PTR)\n+    target_target_type = TYPE_TARGET_TYPE (target_type);\n+  else\n+    target_target_type = target_type;\n+\n+  if (pointer_target_type->code () != target_target_type->code ()\n+      || (pointer_target_type->code () != TYPE_CODE_ARRAY\n+\t  && (TYPE_LENGTH (pointer_target_type)\n+\t      != TYPE_LENGTH (target_target_type))))\n+    error (_(\"arguments to associated must be of same type and kind\"));\n+\n+  /* If TARGET is not in memory, or the original pointer is specifically\n+     known to be not associated with anything, then the answer is obviously\n+     false.  Alternatively, if POINTER is an actual pointer and has no\n+     associated property, then we have to check if its associated by\n+     looking the value of the pointer itself.  We make the assumption that\n+     a non-associated pointer will be set to 0.  This is probably true for\n+     most targets, but might not be true for everyone.  */\n+  if (value_lval_const (target) != lval_memory\n+      || type_not_associated (pointer_type)\n+      || (TYPE_ASSOCIATED_PROP (pointer_type) == nullptr\n+\t  && pointer_type->code () == TYPE_CODE_PTR\n+\t  && pointer_addr == 0))\n+    return value_from_longest (result_type, 0);\n+\n+  /* See the comment for POINTER_ADDR above.  */\n+  CORE_ADDR target_addr;\n+  if (target_type->code () == TYPE_CODE_PTR)\n+    target_addr = value_as_address (target);\n+  else\n+    target_addr = value_address (target);\n+\n+  /* Wrap the following checks inside a do { ... } while (false) loop so\n+     that we can use `break' to jump out of the loop.  */\n+  bool is_associated = false;\n+  do\n+    {\n+      /* If the addresses are different then POINTER is definitely not\n+\t pointing at TARGET.  */\n+      if (pointer_addr != target_addr)\n+\tbreak;\n+\n+      /* If POINTER is a real pointer (i.e. not an array pointer, which are\n+\t implemented as arrays with a dynamic content address), then this\n+\t is all the checking that is needed.  */\n+      if (pointer_type->code () == TYPE_CODE_PTR)\n+\t{\n+\t  is_associated = true;\n+\t  break;\n+\t}\n+\n+      /* We have an array pointer.  Check the number of dimensions.  */\n+      int pointer_dims = calc_f77_array_dims (pointer_type);\n+      int target_dims = calc_f77_array_dims (target_type);\n+      if (pointer_dims != target_dims)\n+\tbreak;\n+\n+      /* Now check that every dimension has the same upper bound, lower\n+\t bound, and stride value.  */\n+      int dim = 0;\n+      while (dim < pointer_dims)\n+\t{\n+\t  LONGEST pointer_lowerbound, pointer_upperbound, pointer_stride;\n+\t  LONGEST target_lowerbound, target_upperbound, target_stride;\n+\n+\t  pointer_type = check_typedef (pointer_type);\n+\t  target_type = check_typedef (target_type);\n+\n+\t  struct type *pointer_range = pointer_type->index_type ();\n+\t  struct type *target_range = target_type->index_type ();\n+\n+\t  if (!get_discrete_bounds (pointer_range, &pointer_lowerbound,\n+\t\t\t\t    &pointer_upperbound))\n+\t    break;\n+\n+\t  if (!get_discrete_bounds (target_range, &target_lowerbound,\n+\t\t\t\t    &target_upperbound))\n+\t    break;\n+\n+\t  if (pointer_lowerbound != target_lowerbound\n+\t      || pointer_upperbound != target_upperbound)\n+\t    break;\n+\n+\t  /* Figure out the stride (in bits) for both pointer and target.\n+\t     If either doesn't have a stride then we take the element size,\n+\t     but we need to convert to bits (hence the * 8).  */\n+\t  pointer_stride = pointer_range->bounds ()->bit_stride ();\n+\t  if (pointer_stride == 0)\n+\t    pointer_stride\n+\t      = type_length_units (check_typedef\n+\t\t\t\t     (TYPE_TARGET_TYPE (pointer_type))) * 8;\n+\t  target_stride = target_range->bounds ()->bit_stride ();\n+\t  if (target_stride == 0)\n+\t    target_stride\n+\t      = type_length_units (check_typedef\n+\t\t\t\t     (TYPE_TARGET_TYPE (target_type))) * 8;\n+\t  if (pointer_stride != target_stride)\n+\t    break;\n+\n+\t  ++dim;\n+\t}\n+\n+      if (dim < pointer_dims)\n+\tbreak;\n+\n+      is_associated = true;\n+    }\n+  while (false);\n+\n+  return value_from_longest (result_type, is_associated ? 1 : 0);\n+}\n+\n+\n /* Special expression evaluation cases for Fortran.  */\n \n static struct value *\n@@ -999,6 +1172,32 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n       }\n       break;\n \n+    case FORTRAN_ASSOCIATED:\n+      {\n+\tint nargs = longest_to_int (exp->elts[pc + 1].longconst);\n+\t(*pos) += 2;\n+\n+\t/* This assertion should be enforced by the expression parser.  */\n+\tgdb_assert (nargs == 1 || nargs == 2);\n+\n+\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n+\n+\tif (nargs == 1)\n+\t  {\n+\t    if (noside == EVAL_SKIP)\n+\t      return eval_skip_value (exp);\n+\t    return fortran_associated (exp->gdbarch, exp->language_defn,\n+\t\t\t\t       arg1);\n+\t  }\n+\n+\targ2 = evaluate_subexp (nullptr, exp, pos, noside);\n+\tif (noside == EVAL_SKIP)\n+\t  return eval_skip_value (exp);\n+\treturn fortran_associated (exp->gdbarch, exp->language_defn,\n+\t\t\t\t   arg1, arg2);\n+      }\n+      break;\n+\n     case BINOP_FORTRAN_CMPLX:\n       arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n@@ -1143,6 +1342,7 @@ operator_length_f (const struct expression *exp, int pc, int *oplenp,\n       args = 2;\n       break;\n \n+    case FORTRAN_ASSOCIATED:\n     case FORTRAN_LBOUND:\n     case FORTRAN_UBOUND:\n       oplen = 3;\n@@ -1191,6 +1391,27 @@ print_binop_subexp_f (struct expression *exp, int *pos,\n   fputs_filtered (\")\", stream);\n }\n \n+/* Helper for PRINT_SUBEXP_F.  Arguments are as for PRINT_SUBEXP_F, except\n+   the extra argument NAME which is the text that should be printed as the\n+   name of this operation.  */\n+\n+static void\n+print_unop_or_binop_subexp_f (struct expression *exp, int *pos,\n+\t\t\t      struct ui_file *stream, enum precedence prec,\n+\t\t\t      const char *name)\n+{\n+  unsigned nargs = longest_to_int (exp->elts[*pos + 1].longconst);\n+  (*pos) += 3;\n+  fprintf_filtered (stream, \"%s (\", name);\n+  for (unsigned tem = 0; tem < nargs; tem++)\n+    {\n+      if (tem != 0)\n+\tfputs_filtered (\", \", stream);\n+      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n+    }\n+  fputs_filtered (\")\", stream);\n+}\n+\n /* Special expression printing for Fortran.  */\n \n static void\n@@ -1230,22 +1451,17 @@ print_subexp_f (struct expression *exp, int *pos,\n       print_binop_subexp_f (exp, pos, stream, prec, \"MODULO\");\n       return;\n \n+    case FORTRAN_ASSOCIATED:\n+      print_unop_or_binop_subexp_f (exp, pos, stream, prec, \"ASSOCIATED\");\n+      return;\n+\n     case FORTRAN_LBOUND:\n+      print_unop_or_binop_subexp_f (exp, pos, stream, prec, \"LBOUND\");\n+      return;\n+\n     case FORTRAN_UBOUND:\n-      {\n-\tunsigned nargs = longest_to_int (exp->elts[*pos + 1].longconst);\n-\t(*pos) += 3;\n-\tfprintf_filtered (stream, \"%s (\",\n-\t\t\t  ((op == FORTRAN_LBOUND) ? \"LBOUND\" : \"UBOUND\"));\n-\tfor (unsigned tem = 0; tem < nargs; tem++)\n-\t  {\n-\t    if (tem != 0)\n-\t      fputs_filtered (\", \", stream);\n-\t    print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-\t  }\n-\tfputs_filtered (\")\", stream);\n-\treturn;\n-      }\n+      print_unop_or_binop_subexp_f (exp, pos, stream, prec, \"UBOUND\");\n+      return;\n \n     case OP_F77_UNDETERMINED_ARGLIST:\n       (*pos)++;\n@@ -1277,6 +1493,7 @@ dump_subexp_body_f (struct expression *exp,\n       operator_length_f (exp, (elt + 1), &oplen, &nargs);\n       break;\n \n+    case FORTRAN_ASSOCIATED:\n     case FORTRAN_LBOUND:\n     case FORTRAN_UBOUND:\n       operator_length_f (exp, (elt + 3), &oplen, &nargs);\n@@ -1311,6 +1528,7 @@ operator_check_f (struct expression *exp, int pos,\n     case UNOP_FORTRAN_ALLOCATED:\n     case BINOP_FORTRAN_CMPLX:\n     case BINOP_FORTRAN_MODULO:\n+    case FORTRAN_ASSOCIATED:\n     case FORTRAN_LBOUND:\n     case FORTRAN_UBOUND:\n       /* Any references to objfiles are held in the arguments to this"
    },
    {
      "sha": "99b5d90381ae0152682b99ffe7e35e5b56dec111",
      "filename": "gdb/std-operator.def",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/std-operator.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/std-operator.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/std-operator.def?ref=faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "patch": "@@ -447,3 +447,4 @@ OP (BINOP_FORTRAN_MODULO)\n /* Builtins that take one or two operands.  */\n OP (FORTRAN_LBOUND)\n OP (FORTRAN_UBOUND)\n+OP (FORTRAN_ASSOCIATED)"
    },
    {
      "sha": "21c98fa941ab499917f920c03dedc1815bcf9713",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "patch": "@@ -1,3 +1,8 @@\n+2021-02-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.fortran/associated.exp: New file.\n+\t* gdb.fortran/associated.f90: New file.\n+\n 2021-02-25  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.fortran/dot-ops.exp (dot_operations): Test \".xor.\"."
    },
    {
      "sha": "d9976f7e8bc8667e822b46f998ef169b5fce3e97",
      "filename": "gdb/testsuite/gdb.fortran/associated.exp",
      "status": "added",
      "additions": 87,
      "deletions": 0,
      "changes": 87,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/testsuite/gdb.fortran/associated.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/testsuite/gdb.fortran/associated.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/associated.exp?ref=faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "patch": "@@ -0,0 +1,87 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/> .\n+\n+# Testing GDB's implementation of ASSOCIATED keyword.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+\n+standard_testfile \".f90\"\n+load_lib fortran.exp\n+\n+if {[prepare_for_testing ${testfile}.exp ${testfile} ${srcfile} \\\n+\t {debug f90}]} {\n+    return -1\n+}\n+\n+if ![fortran_runto_main] {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+gdb_breakpoint [gdb_get_line_number \"Test Breakpoint\"]\n+gdb_breakpoint [gdb_get_line_number \"Final Breakpoint\"]\n+\n+# We place a limit on the number of tests that can be run, just in\n+# case something goes wrong, and GDB gets stuck in an loop here.\n+set found_final_breakpoint false\n+set test_count 0\n+while { $test_count < 500 } {\n+    with_test_prefix \"test $test_count\" {\n+\tincr test_count\n+\n+\tgdb_test_multiple \"continue\" \"continue\" {\n+\t    -re -wrap \"! Test Breakpoint\" {\n+\t\t# We can run a test from here.\n+\t    }\n+\t    -re \"! Final Breakpoint\" {\n+\t\t# We're done with the tests.\n+\t\tset found_final_breakpoint true\n+\t    }\n+\t}\n+\n+\tif ($found_final_breakpoint) {\n+\t    break\n+\t}\n+\n+\t# First grab the expected answer.\n+\tset answer [get_valueof \"\" \"answer\" \"**unknown**\"]\n+\n+\t# Now move up a frame and figure out a command for us to run\n+\t# as a test.\n+\tset command \"\"\n+\tgdb_test_multiple \"up\" \"up\" {\n+\t    -re -wrap \"\\r\\n\\[0-9\\]+\\[ \\t\\]+call test_associated \\\\((\\[^\\r\\n\\]+)\\\\)\" {\n+\t\tset command $expect_out(1,string)\n+\t    }\n+\t}\n+\n+\tgdb_assert { ![string equal $command \"\"] } \"found a command to run\"\n+\n+\tgdb_test \"p $command\" \" = $answer\"\n+    }\n+}\n+\n+# Ensure we reached the final breakpoint.  If more tests have been added\n+# to the test script, and this starts failing, then the safety 'while'\n+# loop above might need to be increased.\n+gdb_assert {$found_final_breakpoint} \"ran all compiled in tests\"\n+\n+# Now perform the final tests.  These should all be error condition\n+# checks, for things that can't be compiled into the test source file.\n+gdb_test \"p associated (array_1d_p, an_integer)\" \\\n+    \"arguments to associated must be of same type and kind\"\n+\n+gdb_test \"p associated (an_integer_p, a_real)\" \\\n+    \"arguments to associated must be of same type and kind\""
    },
    {
      "sha": "093af53f830912695f2775ef2dd16201b356b115",
      "filename": "gdb/testsuite/gdb.fortran/associated.f90",
      "status": "added",
      "additions": 97,
      "deletions": 0,
      "changes": 97,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/testsuite/gdb.fortran/associated.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/faeb9f13c179a4c78bc295a0d0bbd788239704d9/gdb/testsuite/gdb.fortran/associated.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/associated.f90?ref=faeb9f13c179a4c78bc295a0d0bbd788239704d9",
      "patch": "@@ -0,0 +1,97 @@\n+! Copyright 2021 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+!\n+! Start of test program.\n+!\n+program test\n+\n+  ! Things to point at.\n+  integer, target :: array_1d (1:10) = 0\n+  integer, target :: array_2d (1:10, 1:10) = 0\n+  integer, target :: an_integer = 0\n+  integer, target :: other_integer = 0\n+  real, target :: a_real = 0.0\n+\n+  ! Things to point with.\n+  integer, pointer :: array_1d_p (:) => null ()\n+  integer, pointer :: other_1d_p (:) => null ()\n+  integer, pointer :: array_2d_p (:,:) => null ()\n+  integer, pointer :: an_integer_p => null ()\n+  integer, pointer :: other_integer_p => null ()\n+  real, pointer :: a_real_p => null ()\n+\n+  ! The start of the tests.\n+  call test_associated (associated (array_1d_p))\n+  call test_associated (associated (array_1d_p, array_1d))\n+\n+  array_1d_p => array_1d\n+  call test_associated (associated (array_1d_p, array_1d))\n+\n+  array_1d_p => array_1d (2:10)\n+  call test_associated (associated (array_1d_p, array_1d))\n+\n+  array_1d_p => array_1d (1:9)\n+  call test_associated (associated (array_1d_p, array_1d))\n+\n+  array_1d_p => array_2d (3, :)\n+  call test_associated (associated (array_1d_p, array_1d))\n+  call test_associated (associated (array_1d_p, array_2d (2, :)))\n+  call test_associated (associated (array_1d_p, array_2d (3, :)))\n+\n+  array_1d_p => null ()\n+  call test_associated (associated (array_1d_p))\n+  call test_associated (associated (array_1d_p, array_2d (3, :)))\n+\n+  call test_associated (associated (an_integer_p))\n+  call test_associated (associated (an_integer_p, an_integer))\n+  an_integer_p => an_integer\n+  call test_associated (associated (an_integer_p))\n+  call test_associated (associated (an_integer_p, an_integer))\n+\n+  call test_associated (associated (an_integer_p, other_integer_p))\n+  other_integer_p => other_integer\n+  call test_associated (associated (other_integer_p))\n+  call test_associated (associated (an_integer_p, other_integer_p))\n+  call test_associated (associated (other_integer_p, an_integer_p))\n+  call test_associated (associated (other_integer_p, an_integer))\n+\n+  other_integer_p = an_integer_p\n+  call test_associated (associated (an_integer_p, other_integer_p))\n+  call test_associated (associated (other_integer_p, an_integer_p))\n+\n+  call test_associated (associated (a_real_p))\n+  call test_associated (associated (a_real_p, a_real))\n+  a_real_p => a_real\n+  call test_associated (associated (a_real_p, a_real))\n+\n+  ! Setup for final tests, these are performed at the print line\n+  ! below.  These final tests are all error conditon checks,\n+  ! i.e. things that can't be compiled into Fortran.\n+  array_1d_p => array_1d\n+\n+  print *, \"\" ! Final Breakpoint\n+  print *, an_integer\n+  print *, a_real\n+\n+contains\n+\n+  subroutine test_associated (answer)\n+    logical :: answer\n+\n+    print *,answer\t! Test Breakpoint\n+  end subroutine test_associated\n+\n+end program test"
    }
  ]
}