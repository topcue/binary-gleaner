{
  "sha": "08c428aff4a793b63c7dd2229ae172879623e3a2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDhjNDI4YWZmNGE3OTNiNjNjN2RkMjIyOWFlMTcyODc5NjIzZTNhMg==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:37:52Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:40:40Z"
    },
    "message": "libctf: eliminate dtd_u, part 5: structs / unions\n\nEliminate the dynamic member storage for structs and unions as we have\nfor other dynamic types.  This is much like the previous enum\nelimination, except that structs and unions are the only types for which\na full-sized ctf_type_t might be needed.  Up to now, this decision has\nbeen made in the individual ctf_add_{struct,union}_sized functions and\nduplicated in ctf_add_member_offset.  The vlen machinery lets us\nsimplify this, always allocating a ctf_lmember_t and setting the\ndtd_data's ctt_size to CTF_LSIZE_SENT: we figure out whether this is\nreally justified and (almost always) repack things down into a\nctf_stype_t at ctf_serialize time.\n\nThis allows us to eliminate the dynamic member paths from the iterators and\nquery functions in ctf-types.c in favour of always using the large-structure\nvlen stuff for dynamic types (the diff is ugly but that's just because of the\nvolume of reindentation this calls for).  This also means the large-structure\nvlen stuff gets more heavily tested, which is nice because it was an almost\ntotally unused code path before now (it only kicked in for structures of size\n>4GiB, and how often do you see those?)\n\nThe only extra complexity here is ctf_add_type.  Back in the days of the\nnondeduplicating linker this was called a ridiculous number of times for\ncountless identical copies of structures: eschewing the repeated lookups of the\ndtd in ctf_add_member_offset and adding the members directly saved an amazing\namount of time.  Now the nondeduplicating linker is gone, this is extreme\noveroptimization: we can rip out the direct addition and use ctf_member_next and\nctf_add_member_offset, just like ctf_dedup_emit does.\n\nWe augment a ctf_add_type test to try adding a self-referential struct, the only\nthing the ctf_add_type part of this change really perturbs.\n\nThis completes the elimination of dtd_u.\n\nlibctf/ChangeLog\n2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h (ctf_dtdef_t) <dtu_members>: Remove.\n\t<dtd_u>: Likewise.\n\t(ctf_dmdef_t): Remove.\n\t(struct ctf_next) <u.ctn_dmd>: Remove.\n\t* ctf-create.c (INITIAL_VLEN): New, more-or-less arbitrary initial\n\tvlen size.\n\t(ctf_add_enum): Use it.\n\t(ctf_dtd_delete): Do not free the (removed) dmd; remove string\n\trefs from the vlen on struct deletion.\n\t(ctf_add_struct_sized): Populate the vlen: do it by hand if\n\tpromoting forwards.  Always populate the full-size\n\tlsizehi/lsizelo members.\n\t(ctf_add_union_sized): Likewise.\n\t(ctf_add_member_offset): Set up the vlen rather than the dmd.\n\tExpand it as needed, repointing string refs via\n\tctf_str_move_pending. Add the member names as pending strings.\n\tAlways populate the full-size lsizehi/lsizelo members.\n\t(membadd): Remove, folding back into...\n\t(ctf_add_type_internal): ... here, adding via an ordinary\n\tctf_add_struct_sized and _next iteration rather than doing\n\teverything by hand.\n\t* ctf-serialize.c (ctf_copy_smembers): Remove this...\n\t(ctf_copy_lmembers): ... and this...\n\t(ctf_emit_type_sect): ... folding into here. Figure out if a\n\tctf_stype_t is needed here, not in ctf_add_*_sized.\n\t(ctf_type_sect_size): Figure out the ctf_stype_t stuff the same\n\tway here.\n\t* ctf-types.c (ctf_member_next): Remove the dmd path and always\n\tuse the vlen.  Force large-structure usage for dynamic types.\n\t(ctf_type_align): Likewise.\n\t(ctf_member_info): Likewise.\n\t(ctf_type_rvisit): Likewise.\n\t* testsuite/libctf-regression/type-add-unnamed-struct-ctf.c: Add a\n\tself-referential type to this test.\n\t* testsuite/libctf-regression/type-add-unnamed-struct.c: Adjusted\n\taccordingly.\n\t* testsuite/libctf-regression/type-add-unnamed-struct.lk: Likewise.",
    "tree": {
      "sha": "d6c1e1a4945afb465889f9ff8d0337b548c6e111",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d6c1e1a4945afb465889f9ff8d0337b548c6e111"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/08c428aff4a793b63c7dd2229ae172879623e3a2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08c428aff4a793b63c7dd2229ae172879623e3a2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/08c428aff4a793b63c7dd2229ae172879623e3a2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/08c428aff4a793b63c7dd2229ae172879623e3a2/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "77d724a7ecdb3fa84557b0ee5c8b7ea949ce56a5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/77d724a7ecdb3fa84557b0ee5c8b7ea949ce56a5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/77d724a7ecdb3fa84557b0ee5c8b7ea949ce56a5"
    }
  ],
  "stats": {
    "total": 733,
    "additions": 323,
    "deletions": 410
  },
  "files": [
    {
      "sha": "7874a77630505c4c6e1141d29f6d2593152485fa",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=08c428aff4a793b63c7dd2229ae172879623e3a2",
      "patch": "@@ -1,3 +1,43 @@\n+2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_dtdef_t) <dtu_members>: Remove.\n+\t<dtd_u>: Likewise.\n+\t(ctf_dmdef_t): Remove.\n+\t(struct ctf_next) <u.ctn_dmd>: Remove.\n+\t* ctf-create.c (INITIAL_VLEN): New, more-or-less arbitrary initial\n+\tvlen size.\n+\t(ctf_add_enum): Use it.\n+\t(ctf_dtd_delete): Do not free the (removed) dmd; remove string\n+\trefs from the vlen on struct deletion.\n+\t(ctf_add_struct_sized): Populate the vlen: do it by hand if\n+\tpromoting forwards.  Always populate the full-size\n+\tlsizehi/lsizelo members.\n+\t(ctf_add_union_sized): Likewise.\n+\t(ctf_add_member_offset): Set up the vlen rather than the dmd.\n+\tExpand it as needed, repointing string refs via\n+\tctf_str_move_pending. Add the member names as pending strings.\n+\tAlways populate the full-size lsizehi/lsizelo members.\n+\t(membadd): Remove, folding back into...\n+\t(ctf_add_type_internal): ... here, adding via an ordinary\n+\tctf_add_struct_sized and _next iteration rather than doing\n+\teverything by hand.\n+\t* ctf-serialize.c (ctf_copy_smembers): Remove this...\n+\t(ctf_copy_lmembers): ... and this...\n+\t(ctf_emit_type_sect): ... folding into here. Figure out if a\n+\tctf_stype_t is needed here, not in ctf_add_*_sized.\n+\t(ctf_type_sect_size): Figure out the ctf_stype_t stuff the same\n+\tway here.\n+\t* ctf-types.c (ctf_member_next): Remove the dmd path and always\n+\tuse the vlen.  Force large-structure usage for dynamic types.\n+\t(ctf_type_align): Likewise.\n+\t(ctf_member_info): Likewise.\n+\t(ctf_type_rvisit): Likewise.\n+\t* testsuite/libctf-regression/type-add-unnamed-struct-ctf.c: Add a\n+\tself-referential type to this test.\n+\t* testsuite/libctf-regression/type-add-unnamed-struct.c: Adjusted\n+\taccordingly.\n+\t* testsuite/libctf-regression/type-add-unnamed-struct.lk: Likewise.\n+\n 2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-impl.h (ctf_dtdef_t) <dtd_vlen_alloc>: New."
    },
    {
      "sha": "e87b91e928e8549235eae38171714da6bf4825ee",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 105,
      "deletions": 155,
      "changes": 260,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=08c428aff4a793b63c7dd2229ae172879623e3a2",
      "patch": "@@ -30,6 +30,12 @@\n #define roundup(x, y)  ((((x) + ((y) - 1)) / (y)) * (y))\n #endif\n \n+/* The initial size of a dynamic type's vlen in members.  Arbitrary: the bigger\n+   this is, the less allocation needs to be done for small structure\n+   initialization, and the more memory is wasted for small structures during CTF\n+   construction.  No effect on generated CTF or ctf_open()ed CTF. */\n+#define INITIAL_VLEN 16\n+\n /* Make sure the ptrtab has enough space for at least one more type.\n \n    We start with 4KiB of ptrtab, enough for a thousand types, then grow it 25%\n@@ -244,7 +250,6 @@ ctf_dtd_insert (ctf_dict_t *fp, ctf_dtdef_t *dtd, int flag, int kind)\n void\n ctf_dtd_delete (ctf_dict_t *fp, ctf_dtdef_t *dtd)\n {\n-  ctf_dmdef_t *dmd, *nmd;\n   int kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n   size_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n   int name_kind = kind;\n@@ -256,14 +261,14 @@ ctf_dtd_delete (ctf_dict_t *fp, ctf_dtdef_t *dtd)\n     {\n     case CTF_K_STRUCT:\n     case CTF_K_UNION:\n-      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-\t   dmd != NULL; dmd = nmd)\n-\t{\n-\t  if (dmd->dmd_name != NULL)\n-\t      free (dmd->dmd_name);\n-\t  nmd = ctf_list_next (dmd);\n-\t  free (dmd);\n-\t}\n+      {\n+\tctf_lmember_t *memb = (ctf_lmember_t *) dtd->dtd_vlen;\n+\tsize_t i;\n+\n+\tfor (i = 0; i < vlen; i++)\n+\t  ctf_str_remove_ref (fp, ctf_strraw (fp, memb[i].ctlm_name),\n+\t\t\t      &memb[i].ctlm_name);\n+      }\n       break;\n     case CTF_K_ENUM:\n       {\n@@ -797,6 +802,7 @@ ctf_add_struct_sized (ctf_dict_t *fp, uint32_t flag, const char *name,\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type = 0;\n+  size_t initial_vlen = sizeof (ctf_lmember_t) * INITIAL_VLEN;\n \n   /* Promote root-visible forwards to structs.  */\n   if (name != NULL)\n@@ -805,19 +811,21 @@ ctf_add_struct_sized (ctf_dict_t *fp, uint32_t flag, const char *name,\n   if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n     dtd = ctf_dtd_lookup (fp, type);\n   else if ((type = ctf_add_generic (fp, flag, name, CTF_K_STRUCT,\n-\t\t\t\t    0, &dtd)) == CTF_ERR)\n+\t\t\t\t    initial_vlen, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us.  */\n \n-  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_STRUCT, flag, 0);\n-\n-  if (size > CTF_MAX_SIZE)\n+  /* Forwards won't have any vlen yet.  */\n+  if (dtd->dtd_vlen_alloc == 0)\n     {\n-      dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n-      dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n-      dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n+      if ((dtd->dtd_vlen = calloc (1, initial_vlen)) == NULL)\n+\treturn (ctf_set_errno (fp, ENOMEM));\n+      dtd->dtd_vlen_alloc = initial_vlen;\n     }\n-  else\n-    dtd->dtd_data.ctt_size = (uint32_t) size;\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_STRUCT, flag, 0);\n+  dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n+  dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n+  dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n \n   return type;\n }\n@@ -834,6 +842,7 @@ ctf_add_union_sized (ctf_dict_t *fp, uint32_t flag, const char *name,\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type = 0;\n+  size_t initial_vlen = sizeof (ctf_lmember_t) * INITIAL_VLEN;\n \n   /* Promote root-visible forwards to unions.  */\n   if (name != NULL)\n@@ -842,19 +851,21 @@ ctf_add_union_sized (ctf_dict_t *fp, uint32_t flag, const char *name,\n   if (type != 0 && ctf_type_kind (fp, type) == CTF_K_FORWARD)\n     dtd = ctf_dtd_lookup (fp, type);\n   else if ((type = ctf_add_generic (fp, flag, name, CTF_K_UNION,\n-\t\t\t\t    0, &dtd)) == CTF_ERR)\n+\t\t\t\t    initial_vlen, &dtd)) == CTF_ERR)\n     return CTF_ERR;\t\t/* errno is set for us */\n \n-  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_UNION, flag, 0);\n-\n-  if (size > CTF_MAX_SIZE)\n+  /* Forwards won't have any vlen yet.  */\n+  if (dtd->dtd_vlen_alloc == 0)\n     {\n-      dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n-      dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n-      dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n+      if ((dtd->dtd_vlen = calloc (1, initial_vlen)) == NULL)\n+\treturn (ctf_set_errno (fp, ENOMEM));\n+      dtd->dtd_vlen_alloc = initial_vlen;\n     }\n-  else\n-    dtd->dtd_data.ctt_size = (uint32_t) size;\n+\n+  dtd->dtd_data.ctt_info = CTF_TYPE_INFO (CTF_K_UNION, flag, 0);\n+  dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n+  dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n+  dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n \n   return type;\n }\n@@ -870,7 +881,7 @@ ctf_add_enum (ctf_dict_t *fp, uint32_t flag, const char *name)\n {\n   ctf_dtdef_t *dtd;\n   ctf_id_t type = 0;\n-  size_t initial_vlen = sizeof (ctf_enum_t) * 16;\n+  size_t initial_vlen = sizeof (ctf_enum_t) * INITIAL_VLEN;\n \n   /* Promote root-visible forwards to enums.  */\n   if (name != NULL)\n@@ -1066,12 +1077,13 @@ ctf_add_member_offset (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n \t\t       ctf_id_t type, unsigned long bit_offset)\n {\n   ctf_dtdef_t *dtd = ctf_dtd_lookup (fp, souid);\n-  ctf_dmdef_t *dmd;\n \n   ssize_t msize, malign, ssize;\n   uint32_t kind, vlen, root;\n-  char *s = NULL;\n+  size_t i;\n   int is_incomplete = 0;\n+  unsigned char *old_vlen;\n+  ctf_lmember_t *memb;\n \n   if (!(fp->ctf_flags & LCTF_RDWR))\n     return (ctf_set_errno (fp, ECTF_RDONLY));\n@@ -1092,14 +1104,26 @@ ctf_add_member_offset (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n   if (vlen == CTF_MAX_VLEN)\n     return (ctf_set_errno (fp, ECTF_DTFULL));\n \n+  old_vlen = dtd->dtd_vlen;\n+  if (ctf_grow_vlen (fp, dtd, sizeof (ctf_lmember_t) * (vlen + 1)) < 0)\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+  memb = (ctf_lmember_t *) dtd->dtd_vlen;\n+\n+  if (dtd->dtd_vlen != old_vlen)\n+    {\n+      ptrdiff_t move = (signed char *) dtd->dtd_vlen - (signed char *) old_vlen;\n+\n+      /* Remove pending refs in the old vlen region and reapply them.  */\n+\n+      for (i = 0; i < vlen; i++)\n+\tctf_str_move_pending (fp, &memb[i].ctlm_name, move);\n+    }\n+\n   if (name != NULL)\n     {\n-      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-\t   dmd != NULL; dmd = ctf_list_next (dmd))\n-\t{\n-\t  if (dmd->dmd_name != NULL && strcmp (dmd->dmd_name, name) == 0)\n-\t    return (ctf_set_errno (fp, ECTF_DUPLICATE));\n-\t}\n+      for (i = 0; i < vlen; i++)\n+\tif (strcmp (ctf_strptr (fp, memb[i].ctlm_name), name) == 0)\n+\t  return (ctf_set_errno (fp, ECTF_DUPLICATE));\n     }\n \n   if ((msize = ctf_type_size (fp, type)) < 0 ||\n@@ -1124,28 +1148,19 @@ ctf_add_member_offset (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n \treturn -1;\t\t/* errno is set for us.  */\n     }\n \n-  if ((dmd = malloc (sizeof (ctf_dmdef_t))) == NULL)\n-    return (ctf_set_errno (fp, EAGAIN));\n-\n-  if (name != NULL && (s = strdup (name)) == NULL)\n-    {\n-      free (dmd);\n-      return (ctf_set_errno (fp, EAGAIN));\n-    }\n-\n-  dmd->dmd_name = s;\n-  dmd->dmd_type = type;\n-  dmd->dmd_value = -1;\n+  memb[vlen].ctlm_name = ctf_str_add_pending (fp, name, &memb[vlen].ctlm_name);\n+  memb[vlen].ctlm_type = type;\n+  if (memb[vlen].ctlm_name == 0 && name != NULL && name[0] != '\\0')\n+    return -1;\t\t\t/* errno is set for us.  */\n \n   if (kind == CTF_K_STRUCT && vlen != 0)\n     {\n       if (bit_offset == (unsigned long) - 1)\n \t{\n \t  /* Natural alignment.  */\n \n-\t  ctf_dmdef_t *lmd = ctf_list_prev (&dtd->dtd_u.dtu_members);\n-\t  ctf_id_t ltype = ctf_type_resolve (fp, lmd->dmd_type);\n-\t  size_t off = lmd->dmd_offset;\n+\t  ctf_id_t ltype = ctf_type_resolve (fp, memb[vlen - 1].ctlm_type);\n+\t  size_t off = CTF_LMEM_OFFSET(&memb[vlen - 1]);\n \n \t  ctf_encoding_t linfo;\n \t  ssize_t lsize;\n@@ -1155,10 +1170,7 @@ ctf_add_member_offset (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n \t     cannot insert right after such a member without explicit offset\n \t     specification, because its alignment and size is not known.  */\n \t  if (ltype == CTF_ERR)\n-\t    {\n-\t      free (dmd);\n-\t      return -1;\t/* errno is set for us.  */\n-\t    }\n+\t    return -1;\t/* errno is set for us.  */\n \n \t  if (is_incomplete)\n \t    {\n@@ -1176,14 +1188,15 @@ ctf_add_member_offset (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n \t    off += lsize * CHAR_BIT;\n \t  else if (lsize == -1 && ctf_errno (fp) == ECTF_INCOMPLETE)\n \t    {\n+\t      const char *lname = ctf_strraw (fp, memb[vlen - 1].ctlm_name);\n+\n \t      ctf_err_warn (fp, 1, ECTF_INCOMPLETE,\n \t\t\t    _(\"ctf_add_member_offset: cannot add member %s of \"\n \t\t\t      \"type %lx to struct %lx without specifying \"\n \t\t\t      \"explicit offset after member %s of type %lx, \"\n \t\t\t      \"which is an incomplete type\\n\"),\n \t\t\t    name ? name : _(\"(unnamed member)\"), type, souid,\n-\t\t\t    lmd->dmd_name ? lmd->dmd_name\n-\t\t\t    : _(\"(unnamed member)\"), ltype);\n+\t\t\t    lname ? lname : _(\"(unnamed member)\"), ltype);\n \t      return -1;\t\t\t/* errno is set for us.  */\n \t    }\n \n@@ -1198,36 +1211,32 @@ ctf_add_member_offset (ctf_dict_t *fp, ctf_id_t souid, const char *name,\n \n \t  off = roundup (off, CHAR_BIT) / CHAR_BIT;\n \t  off = roundup (off, MAX (malign, 1));\n-\t  dmd->dmd_offset = off * CHAR_BIT;\n+\t  memb[vlen].ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (off * CHAR_BIT);\n+\t  memb[vlen].ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (off * CHAR_BIT);\n \t  ssize = off + msize;\n \t}\n       else\n \t{\n \t  /* Specified offset in bits.  */\n \n-\t  dmd->dmd_offset = bit_offset;\n+\t  memb[vlen].ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (bit_offset);\n+\t  memb[vlen].ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (bit_offset);\n \t  ssize = ctf_get_ctt_size (fp, &dtd->dtd_data, NULL, NULL);\n \t  ssize = MAX (ssize, ((signed) bit_offset / CHAR_BIT) + msize);\n \t}\n     }\n   else\n     {\n-      dmd->dmd_offset = 0;\n+      memb[vlen].ctlm_offsethi = 0;\n+      memb[vlen].ctlm_offsetlo = 0;\n       ssize = ctf_get_ctt_size (fp, &dtd->dtd_data, NULL, NULL);\n       ssize = MAX (ssize, msize);\n     }\n \n-  if ((size_t) ssize > CTF_MAX_SIZE)\n-    {\n-      dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n-      dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (ssize);\n-      dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (ssize);\n-    }\n-  else\n-    dtd->dtd_data.ctt_size = (uint32_t) ssize;\n-\n+  dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n+  dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (ssize);\n+  dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (ssize);\n   dtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, root, vlen + 1);\n-  ctf_list_append (&dtd->dtd_u.dtu_members, dmd);\n \n   fp->ctf_flags |= LCTF_DIRTY;\n   return 0;\n@@ -1411,41 +1420,6 @@ membcmp (const char *name, ctf_id_t type _libctf_unused_, unsigned long offset,\n   return 0;\n }\n \n-static int\n-membadd (const char *name, ctf_id_t type, unsigned long offset, void *arg)\n-{\n-  ctf_bundle_t *ctb = arg;\n-  ctf_dmdef_t *dmd;\n-  char *s = NULL;\n-\n-  if ((dmd = malloc (sizeof (ctf_dmdef_t))) == NULL)\n-    return (ctf_set_errno (ctb->ctb_dict, EAGAIN));\n-\n-  /* Unnamed members in non-dynamic dicts have a name of \"\", while dynamic dicts\n-     use NULL.  Adapt.  */\n-\n-  if (name[0] == 0)\n-    name = NULL;\n-\n-  if (name != NULL && (s = strdup (name)) == NULL)\n-    {\n-      free (dmd);\n-      return (ctf_set_errno (ctb->ctb_dict, EAGAIN));\n-    }\n-\n-  /* For now, dmd_type is copied as the src_fp's type; it is reset to an\n-    equivalent dst_fp type by a final loop in ctf_add_type(), below.  */\n-  dmd->dmd_name = s;\n-  dmd->dmd_type = type;\n-  dmd->dmd_offset = offset;\n-  dmd->dmd_value = -1;\n-\n-  ctf_list_append (&ctb->ctb_dtd->dtd_u.dtu_members, dmd);\n-\n-  ctb->ctb_dict->ctf_flags |= LCTF_DIRTY;\n-  return 0;\n-}\n-\n /* Record the correspondence between a source and ctf_add_type()-added\n    destination type: both types are translated into parent type IDs if need be,\n    so they relate to the actual dictionary they are in.  Outside controlled\n@@ -1828,11 +1802,10 @@ ctf_add_type_internal (ctf_dict_t *dst_fp, ctf_dict_t *src_fp, ctf_id_t src_type\n     case CTF_K_STRUCT:\n     case CTF_K_UNION:\n       {\n-\tctf_dmdef_t *dmd;\n-\tint errs = 0;\n-\tsize_t size;\n-\tssize_t ssize;\n-\tctf_dtdef_t *dtd;\n+\tctf_next_t *i = NULL;\n+\tssize_t offset;\n+\tconst char *membname;\n+\tctf_id_t src_membtype;\n \n \t/* Technically to match a struct or union we need to check both\n \t   ways (src members vs. dst, dst members vs. src) but we make\n@@ -1867,67 +1840,44 @@ ctf_add_type_internal (ctf_dict_t *dst_fp, ctf_dict_t *src_fp, ctf_id_t src_type\n \t    break;\n \t  }\n \n-\t/* Unlike the other cases, copying structs and unions is done\n-\t   manually so as to avoid repeated lookups in ctf_add_member\n-\t   and to ensure the exact same member offsets as in src_type.  */\n-\n-\tdst_type = ctf_add_generic (dst_fp, flag, name, kind, 0, &dtd);\n+\tdst_type = ctf_add_struct_sized (dst_fp, flag, name,\n+\t\t\t\t\t ctf_type_size (src_fp, src_type));\n \tif (dst_type == CTF_ERR)\n \t  return CTF_ERR;\t\t\t/* errno is set for us.  */\n \n-\tdst.ctb_type = dst_type;\n-\tdst.ctb_dtd = dtd;\n-\n \t/* Pre-emptively add this struct to the type mapping so that\n \t   structures that refer to themselves work.  */\n \tctf_add_type_mapping (src_fp, src_type, dst_fp, dst_type);\n \n-\tif (ctf_member_iter (src_fp, src_type, membadd, &dst) != 0)\n-\t  errs++;\t       /* Increment errs and fail at bottom of case.  */\n-\n-\tif ((ssize = ctf_type_size (src_fp, src_type)) < 0)\n-\t  return CTF_ERR;\t\t\t/* errno is set for us.  */\n-\n-\tsize = (size_t) ssize;\n-\tif (size > CTF_MAX_SIZE)\n-\t  {\n-\t    dtd->dtd_data.ctt_size = CTF_LSIZE_SENT;\n-\t    dtd->dtd_data.ctt_lsizehi = CTF_SIZE_TO_LSIZE_HI (size);\n-\t    dtd->dtd_data.ctt_lsizelo = CTF_SIZE_TO_LSIZE_LO (size);\n-\t  }\n-\telse\n-\t  dtd->dtd_data.ctt_size = (uint32_t) size;\n-\n-\tdtd->dtd_data.ctt_info = CTF_TYPE_INFO (kind, flag, vlen);\n-\n-\t/* Make a final pass through the members changing each dmd_type (a\n-\t   src_fp type) to an equivalent type in dst_fp.  We pass through all\n-\t   members, leaving any that fail set to CTF_ERR, unless they fail\n-\t   because they are marking a member of type not representable in this\n-\t   version of CTF, in which case we just want to silently omit them:\n-\t   no consumer can do anything with them anyway.  */\n-\tfor (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-\t     dmd != NULL; dmd = ctf_list_next (dmd))\n+\twhile ((offset = ctf_member_next (src_fp, src_type, &i, &membname,\n+\t\t\t\t\t  &src_membtype, 0)) >= 0)\n \t  {\n \t    ctf_dict_t *dst = dst_fp;\n-\t    ctf_id_t memb_type;\n+\t    ctf_id_t dst_membtype = ctf_type_mapping (src_fp, src_membtype, &dst);\n \n-\t    memb_type = ctf_type_mapping (src_fp, dmd->dmd_type, &dst);\n-\t    if (memb_type == 0)\n+\t    if (dst_membtype == 0)\n \t      {\n-\t\tif ((dmd->dmd_type =\n-\t\t     ctf_add_type_internal (dst_fp, src_fp, dmd->dmd_type,\n-\t\t\t\t\t    proc_tracking_fp)) == CTF_ERR)\n+\t\tdst_membtype = ctf_add_type_internal (dst_fp, src_fp,\n+\t\t\t\t\t\t      src_membtype,\n+\t\t\t\t\t\t      proc_tracking_fp);\n+\t\tif (dst_membtype == CTF_ERR)\n \t\t  {\n \t\t    if (ctf_errno (dst_fp) != ECTF_NONREPRESENTABLE)\n-\t\t      errs++;\n+\t\t      {\n+\t\t\tctf_next_destroy (i);\n+\t\t\tbreak;\n+\t\t      }\n \t\t  }\n \t      }\n-\t    else\n-\t      dmd->dmd_type = memb_type;\n-\t  }\n \n-\tif (errs)\n+\t    if (ctf_add_member_offset (dst_fp, dst_type, membname,\n+\t\t\t\t       dst_membtype, offset) < 0)\n+\t      {\n+\t\tctf_next_destroy (i);\n+\t\tbreak;\n+\t      }\n+\t  }\n+\tif (ctf_errno (src_fp) != ECTF_NEXT_END)\n \t  return CTF_ERR;\t\t\t/* errno is set for us.  */\n \tbreak;\n       }"
    },
    {
      "sha": "87dd03b78fc95d010c99b7209a404dcb50fb2f00",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 0,
      "deletions": 14,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=08c428aff4a793b63c7dd2229ae172879623e3a2",
      "patch": "@@ -179,26 +179,13 @@ typedef struct ctf_decl\n   int cd_enomem;\t\t     /* Nonzero if OOM during printing.  */\n } ctf_decl_t;\n \n-typedef struct ctf_dmdef\n-{\n-  ctf_list_t dmd_list;\t\t/* List forward/back pointers.  */\n-  char *dmd_name;\t\t/* Name of this member.  */\n-  ctf_id_t dmd_type;\t\t/* Type of this member (for sou).  */\n-  unsigned long dmd_offset;\t/* Offset of this member in bits (for sou).  */\n-  int dmd_value;\t\t/* Value of this member (for enum).  */\n-} ctf_dmdef_t;\n-\n typedef struct ctf_dtdef\n {\n   ctf_list_t dtd_list;\t\t/* List forward/back pointers.  */\n   ctf_id_t dtd_type;\t\t/* Type identifier for this definition.  */\n   ctf_type_t dtd_data;\t\t/* Type node, including name.  */\n   size_t dtd_vlen_alloc;\t/* Total vlen space allocated.  */\n   unsigned char *dtd_vlen;\t/* Variable-length data for this type.  */\n-  union\n-  {\n-    ctf_list_t dtu_members;\t/* struct, union, or enum */\n-  } dtd_u;\n } ctf_dtdef_t;\n \n typedef struct ctf_dvdef\n@@ -557,7 +544,6 @@ struct ctf_next\n   {\n     const ctf_member_t *ctn_mp;\n     const ctf_lmember_t *ctn_lmp;\n-    const ctf_dmdef_t *ctn_dmd;\n     const ctf_enum_t *ctn_en;\n     const ctf_dvdef_t *ctn_dvd;\n     ctf_next_hkv_t *ctn_sorted_hkv;"
    },
    {
      "sha": "0811b7b6efed4e2d3f1ae4fa4ca9dacb1c19ce26",
      "filename": "libctf/ctf-serialize.c",
      "status": "modified",
      "additions": 59,
      "deletions": 58,
      "changes": 117,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ctf-serialize.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ctf-serialize.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-serialize.c?ref=08c428aff4a793b63c7dd2229ae172879623e3a2",
      "patch": "@@ -719,57 +719,6 @@ ctf_emit_symtypetab_sects (ctf_dict_t *fp, emit_symtypetab_state_t *s,\n \n /* Type section.  */\n \n-static unsigned char *\n-ctf_copy_smembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n-{\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  ctf_member_t ctm;\n-\n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n-    {\n-      ctf_member_t *copied;\n-\n-      ctm.ctm_name = 0;\n-      ctm.ctm_type = (uint32_t) dmd->dmd_type;\n-      ctm.ctm_offset = (uint32_t) dmd->dmd_offset;\n-\n-      memcpy (t, &ctm, sizeof (ctm));\n-      copied = (ctf_member_t *) t;\n-      if (dmd->dmd_name)\n-\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctm_name);\n-\n-      t += sizeof (ctm);\n-    }\n-\n-  return t;\n-}\n-\n-static unsigned char *\n-ctf_copy_lmembers (ctf_dict_t *fp, ctf_dtdef_t *dtd, unsigned char *t)\n-{\n-  ctf_dmdef_t *dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-  ctf_lmember_t ctlm;\n-\n-  for (; dmd != NULL; dmd = ctf_list_next (dmd))\n-    {\n-      ctf_lmember_t *copied;\n-\n-      ctlm.ctlm_name = 0;\n-      ctlm.ctlm_type = (uint32_t) dmd->dmd_type;\n-      ctlm.ctlm_offsethi = CTF_OFFSET_TO_LMEMHI (dmd->dmd_offset);\n-      ctlm.ctlm_offsetlo = CTF_OFFSET_TO_LMEMLO (dmd->dmd_offset);\n-\n-      memcpy (t, &ctlm, sizeof (ctlm));\n-      copied = (ctf_lmember_t *) t;\n-      if (dmd->dmd_name)\n-\tctf_str_add_ref (fp, dmd->dmd_name, &copied->ctlm_name);\n-\n-      t += sizeof (ctlm);\n-    }\n-\n-  return t;\n-}\n-\n /* Iterate through the dynamic type definition list and compute the\n    size of the CTF type section.  */\n \n@@ -784,8 +733,20 @@ ctf_type_sect_size (ctf_dict_t *fp)\n     {\n       uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n       uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n+      size_t type_ctt_size = dtd->dtd_data.ctt_size;\n+\n+      /* Shrink ctf_type_t-using types from a ctf_type_t to a ctf_stype_t\n+\t if possible.  */\n+\n+      if (kind == CTF_K_STRUCT || kind == CTF_K_UNION)\n+\t{\n+\t  size_t lsize = CTF_TYPE_LSIZE (&dtd->dtd_data);\n+\n+\t  if (lsize <= CTF_MAX_SIZE)\n+\t    type_ctt_size = lsize;\n+\t}\n \n-      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n+      if (type_ctt_size != CTF_LSIZE_SENT)\n \ttype_size += sizeof (ctf_stype_t);\n       else\n \ttype_size += sizeof (ctf_type_t);\n@@ -807,7 +768,7 @@ ctf_type_sect_size (ctf_dict_t *fp)\n \t  break;\n \tcase CTF_K_STRUCT:\n \tcase CTF_K_UNION:\n-\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n+\t  if (type_ctt_size < CTF_LSTRUCT_THRESH)\n \t    type_size += sizeof (ctf_member_t) * vlen;\n \t  else\n \t    type_size += sizeof (ctf_lmember_t) * vlen;\n@@ -836,13 +797,24 @@ ctf_emit_type_sect (ctf_dict_t *fp, unsigned char **tptr)\n     {\n       uint32_t kind = LCTF_INFO_KIND (fp, dtd->dtd_data.ctt_info);\n       uint32_t vlen = LCTF_INFO_VLEN (fp, dtd->dtd_data.ctt_info);\n-\n+      size_t type_ctt_size = dtd->dtd_data.ctt_size;\n       size_t len;\n       ctf_stype_t *copied;\n       const char *name;\n       size_t i;\n \n-      if (dtd->dtd_data.ctt_size != CTF_LSIZE_SENT)\n+      /* Shrink ctf_type_t-using types from a ctf_type_t to a ctf_stype_t\n+\t if possible.  */\n+\n+      if (kind == CTF_K_STRUCT || kind == CTF_K_UNION)\n+\t{\n+\t  size_t lsize = CTF_TYPE_LSIZE (&dtd->dtd_data);\n+\n+\t  if (lsize <= CTF_MAX_SIZE)\n+\t    type_ctt_size = lsize;\n+\t}\n+\n+      if (type_ctt_size != CTF_LSIZE_SENT)\n \tlen = sizeof (ctf_stype_t);\n       else\n \tlen = sizeof (ctf_type_t);\n@@ -855,6 +827,7 @@ ctf_emit_type_sect (ctf_dict_t *fp, unsigned char **tptr)\n \t  ctf_str_add_ref (fp, name, &copied->ctt_name);\n \t  ctf_str_add_ref (fp, name, &dtd->dtd_data.ctt_name);\n \t}\n+      copied->ctt_size = type_ctt_size;\n       t += len;\n \n       switch (kind)\n@@ -880,12 +853,40 @@ ctf_emit_type_sect (ctf_dict_t *fp, unsigned char **tptr)\n \t  t += sizeof (uint32_t) * (vlen + (vlen & 1));\n \t  break;\n \n+\t  /* These need to be copied across element by element, depending on\n+\t     their ctt_size.  */\n \tcase CTF_K_STRUCT:\n \tcase CTF_K_UNION:\n-\t  if (dtd->dtd_data.ctt_size < CTF_LSTRUCT_THRESH)\n-\t    t = ctf_copy_smembers (fp, dtd, t);\n+\t  {\n+\t    ctf_lmember_t *dtd_vlen = (ctf_lmember_t *) dtd->dtd_vlen;\n+\t    ctf_lmember_t *t_lvlen = (ctf_lmember_t *) t;\n+\t    ctf_member_t *t_vlen = (ctf_member_t *) t;\n+\n+\t    for (i = 0; i < vlen; i++)\n+\t      {\n+\t\tconst char *name = ctf_strraw (fp, dtd_vlen[i].ctlm_name);\n+\n+\t\tctf_str_add_ref (fp, name, &dtd_vlen[i].ctlm_name);\n+\n+\t\tif (type_ctt_size < CTF_LSTRUCT_THRESH)\n+\t\t  {\n+\t\t    t_vlen[i].ctm_name = dtd_vlen[i].ctlm_name;\n+\t\t    t_vlen[i].ctm_type = dtd_vlen[i].ctlm_type;\n+\t\t    t_vlen[i].ctm_offset = CTF_LMEM_OFFSET (&dtd_vlen[i]);\n+\t\t    ctf_str_add_ref (fp, name, &t_vlen[i].ctm_name);\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    t_lvlen[i] = dtd_vlen[i];\n+\t\t    ctf_str_add_ref (fp, name, &t_lvlen[i].ctlm_name);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\t  if (type_ctt_size < CTF_LSTRUCT_THRESH)\n+\t    t += sizeof (ctf_member_t) * vlen;\n \t  else\n-\t    t = ctf_copy_lmembers (fp, dtd, t);\n+\t    t += sizeof (ctf_lmember_t) * vlen;\n \t  break;\n \n \tcase CTF_K_ENUM:"
    },
    {
      "sha": "df7673ecd2efbd7acf7675b01fbeb379c4c2c1e0",
      "filename": "libctf/ctf-types.c",
      "status": "modified",
      "additions": 116,
      "deletions": 182,
      "changes": 298,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ctf-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/ctf-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-types.c?ref=08c428aff4a793b63c7dd2229ae172879623e3a2",
      "patch": "@@ -101,24 +101,17 @@ ctf_member_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n \n       dtd = ctf_dynamic_type (fp, type);\n       i->ctn_iter_fun = (void (*) (void)) ctf_member_next;\n-\n-      /* We depend below on the RDWR state indicating whether the DTD-related\n-\t fields or the DMD-related fields have been initialized.  */\n-\n-      assert ((dtd && (fp->ctf_flags & LCTF_RDWR))\n-\t      || (!dtd && (!(fp->ctf_flags & LCTF_RDWR))));\n+      i->ctn_n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n \n       if (dtd == NULL)\n \t{\n-\t  i->ctn_n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n-\n \t  if (i->ctn_size < CTF_LSTRUCT_THRESH)\n \t    i->u.ctn_mp = (const ctf_member_t *) ((uintptr_t) tp + increment);\n \t  else\n \t    i->u.ctn_lmp = (const ctf_lmember_t *) ((uintptr_t) tp + increment);\n \t}\n       else\n-\ti->u.ctn_dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n+\ti->u.ctn_lmp = (const ctf_lmember_t *) dtd->dtd_vlen;\n \n       *it = i;\n     }\n@@ -141,71 +134,46 @@ ctf_member_next (ctf_dict_t *fp, ctf_id_t type, ctf_next_t **it,\n  retry:\n   if (!i->ctn_type)\n     {\n-      if (!(fp->ctf_flags & LCTF_RDWR))\n-\t{\n-\t  if (i->ctn_n == 0)\n-\t    goto end_iter;\n-\n-\t  if (i->ctn_size < CTF_LSTRUCT_THRESH)\n-\t    {\n-\t      const char *membname = ctf_strptr (fp, i->u.ctn_mp->ctm_name);\n-\n-\t      if (name)\n-\t\t*name = membname;\n-\t      if (membtype)\n-\t\t*membtype = i->u.ctn_mp->ctm_type;\n-\t      offset = i->u.ctn_mp->ctm_offset;\n-\n-\t      if (membname[0] == 0\n-\t\t  && (ctf_type_kind (fp, i->u.ctn_mp->ctm_type) == CTF_K_STRUCT\n-\t\t      || ctf_type_kind (fp, i->u.ctn_mp->ctm_type) == CTF_K_UNION))\n-\t\ti->ctn_type = i->u.ctn_mp->ctm_type;\n+      if (i->ctn_n == 0)\n+\tgoto end_iter;\n \n-\t      i->u.ctn_mp++;\n-\t    }\n-\t  else\n-\t    {\n-\t      const char *membname = ctf_strptr (fp, i->u.ctn_lmp->ctlm_name);\n+      /* Dynamic structures in read-write dicts always use lmembers.  */\n+      if (i->ctn_size < CTF_LSTRUCT_THRESH\n+\t  && !(fp->ctf_flags & LCTF_RDWR))\n+\t{\n+\t  const char *membname = ctf_strptr (fp, i->u.ctn_mp->ctm_name);\n \n-\t      if (name)\n-\t\t*name = membname;\n-\t      if (membtype)\n-\t\t*membtype = i->u.ctn_lmp->ctlm_type;\n-\t      offset = (unsigned long) CTF_LMEM_OFFSET (i->u.ctn_lmp);\n+\t  if (name)\n+\t    *name = membname;\n+\t  if (membtype)\n+\t    *membtype = i->u.ctn_mp->ctm_type;\n+\t  offset = i->u.ctn_mp->ctm_offset;\n \n-\t      if (membname[0] == 0\n-\t\t  && (ctf_type_kind (fp, i->u.ctn_lmp->ctlm_type) == CTF_K_STRUCT\n-\t\t      || ctf_type_kind (fp, i->u.ctn_lmp->ctlm_type) == CTF_K_UNION))\n-\t\ti->ctn_type = i->u.ctn_lmp->ctlm_type;\n+\t  if (membname[0] == 0\n+\t      && (ctf_type_kind (fp, i->u.ctn_mp->ctm_type) == CTF_K_STRUCT\n+\t\t  || ctf_type_kind (fp, i->u.ctn_mp->ctm_type) == CTF_K_UNION))\n+\t    i->ctn_type = i->u.ctn_mp->ctm_type;\n \n-\t      i->u.ctn_lmp++;\n-\t    }\n-\t  i->ctn_n--;\n+\t  i->u.ctn_mp++;\n \t}\n       else\n \t{\n-\t  if (i->u.ctn_dmd == NULL)\n-\t    goto end_iter;\n-\t  /* The dmd contains a NULL for unnamed dynamic members.  Don't inflict\n-\t     this on our callers.  */\n+\t  const char *membname = ctf_strptr (fp, i->u.ctn_lmp->ctlm_name);\n+\n \t  if (name)\n-\t    {\n-\t      if (i->u.ctn_dmd->dmd_name)\n-\t\t*name = i->u.ctn_dmd->dmd_name;\n-\t      else\n-\t\t*name = \"\";\n-\t    }\n+\t    *name = membname;\n \t  if (membtype)\n-\t    *membtype = i->u.ctn_dmd->dmd_type;\n-\t  offset = i->u.ctn_dmd->dmd_offset;\n+\t    *membtype = i->u.ctn_lmp->ctlm_type;\n+\t  offset = (unsigned long) CTF_LMEM_OFFSET (i->u.ctn_lmp);\n \n-\t  if (i->u.ctn_dmd->dmd_name == NULL\n-\t      && (ctf_type_kind (fp, i->u.ctn_dmd->dmd_type) == CTF_K_STRUCT\n-\t\t  || ctf_type_kind (fp, i->u.ctn_dmd->dmd_type) == CTF_K_UNION))\n-\t    i->ctn_type = i->u.ctn_dmd->dmd_type;\n+\t  if (membname[0] == 0\n+\t      && (ctf_type_kind (fp, i->u.ctn_lmp->ctlm_type) == CTF_K_STRUCT\n+\t\t  || ctf_type_kind (fp, i->u.ctn_lmp->ctlm_type) == CTF_K_UNION))\n+\t    i->ctn_type = i->u.ctn_lmp->ctlm_type;\n \n-\t  i->u.ctn_dmd = ctf_list_next (i->u.ctn_dmd);\n+\t  i->u.ctn_lmp++;\n \t}\n+      i->ctn_n--;\n \n       /* The callers might want automatic recursive sub-struct traversal.  */\n       if (!(flags & CTF_MN_RECURSE))\n@@ -996,53 +964,44 @@ ctf_type_align (ctf_dict_t *fp, ctf_id_t type)\n     case CTF_K_UNION:\n       {\n \tsize_t align = 0;\n+\tint dynamic = 0;\n \tctf_dtdef_t *dtd;\n \n-\tif ((dtd = ctf_dynamic_type (ofp, type)) == NULL)\n-\t  {\n-\t    uint32_t n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n-\t    ssize_t size, increment;\n-\t    const void *vmp;\n+\tif ((dtd = ctf_dynamic_type (ofp, type)) != NULL)\n+\t  dynamic = 1;\n \n-\t    (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n-\t    vmp = (unsigned char *) tp + increment;\n+\tuint32_t n = LCTF_INFO_VLEN (fp, tp->ctt_info);\n+\tssize_t size, increment;\n+\tconst void *vmp;\n \n-\t    if (kind == CTF_K_STRUCT)\n-\t      n = MIN (n, 1);\t/* Only use first member for structs.  */\n+\t(void) ctf_get_ctt_size (fp, tp, &size, &increment);\n \n-\t    if (size < CTF_LSTRUCT_THRESH)\n-\t      {\n-\t\tconst ctf_member_t *mp = vmp;\n-\t\tfor (; n != 0; n--, mp++)\n-\t\t  {\n-\t\t    ssize_t am = ctf_type_align (ofp, mp->ctm_type);\n-\t\t    align = MAX (align, (size_t) am);\n-\t\t  }\n-\t      }\n-\t    else\n+\tif (!dynamic)\n+\t  vmp = (unsigned char *) tp + increment;\n+\telse\n+\t  vmp = dtd->dtd_vlen;\n+\n+\tif (kind == CTF_K_STRUCT)\n+\t  n = MIN (n, 1);\t/* Only use first member for structs.  */\n+\n+\tif (size < CTF_LSTRUCT_THRESH && !dynamic)\n+\t  {\n+\t    const ctf_member_t *mp = vmp;\n+\t    for (; n != 0; n--, mp++)\n \t      {\n-\t\tconst ctf_lmember_t *lmp = vmp;\n-\t\tfor (; n != 0; n--, lmp++)\n-\t\t  {\n-\t\t    ssize_t am = ctf_type_align (ofp, lmp->ctlm_type);\n-\t\t    align = MAX (align, (size_t) am);\n-\t\t  }\n+\t\tssize_t am = ctf_type_align (ofp, mp->ctm_type);\n+\t\talign = MAX (align, (size_t) am);\n \t      }\n \t  }\n \telse\n \t  {\n-\t      ctf_dmdef_t *dmd;\n-\n-\t      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-\t\t   dmd != NULL; dmd = ctf_list_next (dmd))\n-\t\t{\n-\t\t  ssize_t am = ctf_type_align (ofp, dmd->dmd_type);\n-\t\t  align = MAX (align, (size_t) am);\n-\t\t  if (kind == CTF_K_STRUCT)\n-\t\t    break;\n-\t\t}\n+\t    const ctf_lmember_t *lmp = vmp;\n+\t    for (; n != 0; n--, lmp++)\n+\t      {\n+\t\tssize_t am = ctf_type_align (ofp, lmp->ctlm_type);\n+\t\talign = MAX (align, (size_t) am);\n+\t      }\n \t  }\n-\n \treturn align;\n       }\n \n@@ -1390,8 +1349,10 @@ ctf_member_info (ctf_dict_t *fp, ctf_id_t type, const char *name,\n   ctf_dict_t *ofp = fp;\n   const ctf_type_t *tp;\n   ctf_dtdef_t *dtd;\n+  const void *vmp;\n   ssize_t size, increment;\n   uint32_t kind, n;\n+  int dynamic = 0;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n     return -1;\t\t\t/* errno is set for us.  */\n@@ -1405,73 +1366,54 @@ ctf_member_info (ctf_dict_t *fp, ctf_id_t type, const char *name,\n   if (kind != CTF_K_STRUCT && kind != CTF_K_UNION)\n     return (ctf_set_errno (ofp, ECTF_NOTSOU));\n \n-  if ((dtd = ctf_dynamic_type (fp, type)) == NULL)\n-    {\n-      if (size < CTF_LSTRUCT_THRESH)\n-\t{\n-\t  const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t\t   increment);\n+  if ((dtd = ctf_dynamic_type (ofp, type)) != NULL)\n+    dynamic = 1;\n \n-\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n-\t    {\n-\t      const char *membname = ctf_strptr (fp, mp->ctm_name);\n+  if (!dynamic)\n+    vmp = (unsigned char *) tp + increment;\n+  else\n+    vmp = dtd->dtd_vlen;\n \n-\t      if (membname[0] == 0\n-\t\t  && (ctf_type_kind (fp, mp->ctm_type) == CTF_K_STRUCT\n-\t\t      || ctf_type_kind (fp, mp->ctm_type) == CTF_K_UNION)\n-\t\t  && (ctf_member_info (fp, mp->ctm_type, name, mip) == 0))\n-\t\treturn 0;\n+  if (size < CTF_LSTRUCT_THRESH && !dynamic)\n+    {\n+      const ctf_member_t *mp = vmp;\n \n-\t      if (strcmp (membname, name) == 0)\n-\t\t{\n-\t\t  mip->ctm_type = mp->ctm_type;\n-\t\t  mip->ctm_offset = mp->ctm_offset;\n-\t\t  return 0;\n-\t\t}\n-\t    }\n-\t}\n-      else\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n \t{\n-\t  const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t\t      increment);\n+\t  const char *membname = ctf_strptr (fp, mp->ctm_name);\n \n-\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n-\t    {\n-\t      const char *membname = ctf_strptr (fp, lmp->ctlm_name);\n-\n-\t      if (membname[0] == 0\n-\t\t  && (ctf_type_kind (fp, lmp->ctlm_type) == CTF_K_STRUCT\n-\t\t      || ctf_type_kind (fp, lmp->ctlm_type) == CTF_K_UNION)\n-\t\t  && (ctf_member_info (fp, lmp->ctlm_type, name, mip) == 0))\n-\t\treturn 0;\n+\t  if (membname[0] == 0\n+\t      && (ctf_type_kind (fp, mp->ctm_type) == CTF_K_STRUCT\n+\t\t  || ctf_type_kind (fp, mp->ctm_type) == CTF_K_UNION)\n+\t      && (ctf_member_info (fp, mp->ctm_type, name, mip) == 0))\n+\t    return 0;\n \n-\t      if (strcmp (membname, name) == 0)\n-\t\t{\n-\t\t  mip->ctm_type = lmp->ctlm_type;\n-\t\t  mip->ctm_offset = (unsigned long) CTF_LMEM_OFFSET (lmp);\n-\t\t  return 0;\n-\t\t}\n+\t  if (strcmp (membname, name) == 0)\n+\t    {\n+\t      mip->ctm_type = mp->ctm_type;\n+\t      mip->ctm_offset = mp->ctm_offset;\n+\t      return 0;\n \t    }\n \t}\n     }\n   else\n     {\n-      ctf_dmdef_t *dmd;\n+      const ctf_lmember_t *lmp = vmp;\n \n-      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-\t   dmd != NULL; dmd = ctf_list_next (dmd))\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n \t{\n-\t  if (dmd->dmd_name == NULL\n-\t      && (ctf_type_kind (fp, dmd->dmd_type) == CTF_K_STRUCT\n-\t\t  || ctf_type_kind (fp, dmd->dmd_type) == CTF_K_UNION)\n-\t      && (ctf_member_info (fp, dmd->dmd_type, name, mip) == 0))\n+\t  const char *membname = ctf_strptr (fp, lmp->ctlm_name);\n+\n+\t  if (membname[0] == 0\n+\t      && (ctf_type_kind (fp, lmp->ctlm_type) == CTF_K_STRUCT\n+\t\t  || ctf_type_kind (fp, lmp->ctlm_type) == CTF_K_UNION)\n+\t      && (ctf_member_info (fp, lmp->ctlm_type, name, mip) == 0))\n \t    return 0;\n \n-\t  if (dmd->dmd_name != NULL\n-\t      && strcmp (dmd->dmd_name, name) == 0)\n+\t  if (strcmp (membname, name) == 0)\n \t    {\n-\t      mip->ctm_type = dmd->dmd_type;\n-\t      mip->ctm_offset = dmd->dmd_offset;\n+\t      mip->ctm_type = lmp->ctlm_type;\n+\t      mip->ctm_offset = (unsigned long) CTF_LMEM_OFFSET (lmp);\n \t      return 0;\n \t    }\n \t}\n@@ -1688,8 +1630,10 @@ ctf_type_rvisit (ctf_dict_t *fp, ctf_id_t type, ctf_visit_f *func,\n   ctf_id_t otype = type;\n   const ctf_type_t *tp;\n   const ctf_dtdef_t *dtd;\n+  const void *vmp;\n   ssize_t size, increment;\n   uint32_t kind, n;\n+  int dynamic = 0;\n   int rc;\n \n   if ((type = ctf_type_resolve (fp, type)) == CTF_ERR)\n@@ -1708,48 +1652,38 @@ ctf_type_rvisit (ctf_dict_t *fp, ctf_id_t type, ctf_visit_f *func,\n \n   (void) ctf_get_ctt_size (fp, tp, &size, &increment);\n \n-  if ((dtd = ctf_dynamic_type (fp, type)) == NULL)\n+  if ((dtd = ctf_dynamic_type (fp, type)) != NULL)\n+    dynamic = 1;\n+\n+  if (!dynamic)\n+    vmp = (unsigned char *) tp + increment;\n+  else\n+    vmp = dtd->dtd_vlen;\n+\n+  if (size < CTF_LSTRUCT_THRESH && !dynamic)\n     {\n-      if (size < CTF_LSTRUCT_THRESH)\n-\t{\n-\t  const ctf_member_t *mp = (const ctf_member_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t\t   increment);\n+      const ctf_member_t *mp = vmp;\n \n-\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n-\t    {\n-\t      if ((rc = ctf_type_rvisit (fp, mp->ctm_type,\n-\t\t\t\t\t func, arg, ctf_strptr (fp,\n-\t\t\t\t\t\t\t\tmp->ctm_name),\n-\t\t\t\t\t offset + mp->ctm_offset,\n-\t\t\t\t\t depth + 1)) != 0)\n-\t\treturn rc;\n-\t    }\n-\t}\n-      else\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, mp++)\n \t{\n-\t  const ctf_lmember_t *lmp = (const ctf_lmember_t *) ((uintptr_t) tp +\n-\t\t\t\t\t\t\t      increment);\n-\n-\t  for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n-\t    {\n-\t      if ((rc = ctf_type_rvisit (fp, lmp->ctlm_type,\n-\t\t\t\t\t func, arg, ctf_strptr (fp,\n-\t\t\t\t\t\t\t\tlmp->ctlm_name),\n-\t\t\t\t\t offset + (unsigned long) CTF_LMEM_OFFSET (lmp),\n-\t\t\t\t\t depth + 1)) != 0)\n-\t\treturn rc;\n-\t    }\n+\t  if ((rc = ctf_type_rvisit (fp, mp->ctm_type,\n+\t\t\t\t     func, arg, ctf_strptr (fp,\n+\t\t\t\t\t\t\t    mp->ctm_name),\n+\t\t\t\t     offset + mp->ctm_offset,\n+\t\t\t\t     depth + 1)) != 0)\n+\t    return rc;\n \t}\n     }\n   else\n     {\n-      ctf_dmdef_t *dmd;\n+      const ctf_lmember_t *lmp = vmp;\n \n-      for (dmd = ctf_list_next (&dtd->dtd_u.dtu_members);\n-\t   dmd != NULL; dmd = ctf_list_next (dmd))\n+      for (n = LCTF_INFO_VLEN (fp, tp->ctt_info); n != 0; n--, lmp++)\n \t{\n-\t  if ((rc = ctf_type_rvisit (fp, dmd->dmd_type, func, arg,\n-\t\t\t\t     dmd->dmd_name, dmd->dmd_offset,\n+\t  if ((rc = ctf_type_rvisit (fp, lmp->ctlm_type,\n+\t\t\t\t     func, arg, ctf_strptr (fp,\n+\t\t\t\t\t\t\t    lmp->ctlm_name),\n+\t\t\t\t     offset + (unsigned long) CTF_LMEM_OFFSET (lmp),\n \t\t\t\t     depth + 1)) != 0)\n \t    return rc;\n \t}"
    },
    {
      "sha": "a1573a70059d22bd03d09588757791a9ca2e06c9",
      "filename": "libctf/testsuite/libctf-regression/type-add-unnamed-struct-ctf.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/testsuite/libctf-regression/type-add-unnamed-struct-ctf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/testsuite/libctf-regression/type-add-unnamed-struct-ctf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-regression/type-add-unnamed-struct-ctf.c?ref=08c428aff4a793b63c7dd2229ae172879623e3a2",
      "patch": "@@ -12,6 +12,7 @@ struct foo\n     struct\n     {\n       int baz;\n+      struct foo *foo;\n     };\n   };\n };"
    },
    {
      "sha": "16ff0948b1710a194ebc3539fc3c655e7a399103",
      "filename": "libctf/testsuite/libctf-regression/type-add-unnamed-struct.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/testsuite/libctf-regression/type-add-unnamed-struct.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/testsuite/libctf-regression/type-add-unnamed-struct.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-regression/type-add-unnamed-struct.c?ref=08c428aff4a793b63c7dd2229ae172879623e3a2",
      "patch": "@@ -13,7 +13,7 @@ main (int argc, char *argv[])\n   ctf_id_t newtype;\n   const char *memb;\n   ctf_membinfo_t mi;\n-  const char *membs[] = { \"bar\", \"baz\", NULL };\n+  const char *membs[] = { \"bar\", \"baz\", \"foo\", NULL };\n   const char **walk;\n   int err;\n "
    },
    {
      "sha": "b818a2400a17cf5abcb6ac6acb45e21abf1c086b",
      "filename": "libctf/testsuite/libctf-regression/type-add-unnamed-struct.lk",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/testsuite/libctf-regression/type-add-unnamed-struct.lk",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/08c428aff4a793b63c7dd2229ae172879623e3a2/libctf/testsuite/libctf-regression/type-add-unnamed-struct.lk",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-regression/type-add-unnamed-struct.lk?ref=08c428aff4a793b63c7dd2229ae172879623e3a2",
      "patch": "@@ -1,3 +1,4 @@\n # source: type-add-unnamed-struct-ctf.c\n Looked up bar, type [0-9a-f]*, offset [0-9a-f]*\n Looked up baz, type [0-9a-f]*, offset [0-9a-f]*\n+Looked up foo, type [0-9a-f]*, offset [0-9a-f]*"
    }
  ]
}