{
  "sha": "015dc7e1f8a971692a910e6cfc64faf9216e75c3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDE1ZGM3ZTFmOGE5NzE2OTJhOTEwZTZjZmM2NGZhZjkyMTZlNzVjMw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:09:37Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:19:23Z"
    },
    "message": "Use bool in binutils\n\n\t* sysdep.h (POISON_BFD_BOOLEAN): Define.\n\t* addr2line.c, * ar.c, * arsup.c, * bfdtest2.c, * binemul.c,\n\t* binemul.h, * bucomm.c, * bucomm.h, * budbg.h, * coffgrok.c,\n\t* debug.c, * debug.h, * dlltool.c, * dwarf.c, * dwarf.h,\n\t* elfedit.c, * emul_aix.c, * mclex.c, * nm.c, * objcopy.c,\n\t* objdump.c, * od-macho.c, * prdbg.c, * rdcoff.c, * rddbg.c,\n\t* readelf.c, * rename.c, * stabs.c, * strings.c, * windint.h,\n\t* windmc.c, * windmc.h, * windres.c, * winduni.c,\n\t* wrstabs.c: Replace bfd_boolean with bool, FALSE with false,\n\tand TRUE with true throughout.",
    "tree": {
      "sha": "53f0eb6489d86f4a6b734115c79c4e131af5416c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/53f0eb6489d86f4a6b734115c79c4e131af5416c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/015dc7e1f8a971692a910e6cfc64faf9216e75c3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/015dc7e1f8a971692a910e6cfc64faf9216e75c3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/015dc7e1f8a971692a910e6cfc64faf9216e75c3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/015dc7e1f8a971692a910e6cfc64faf9216e75c3/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/78933a4ad9ae9c2e274d41e6b3036ea582c47810",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/78933a4ad9ae9c2e274d41e6b3036ea582c47810"
    }
  ],
  "stats": {
    "total": 6485,
    "additions": 3241,
    "deletions": 3244
  },
  "files": [
    {
      "sha": "f068a1ddcb6800bdbe48def6118234029675005a",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -1,3 +1,16 @@\n+2021-03-31  Alan Modra  <amodra@gmail.com>\n+\n+\t* sysdep.h (POISON_BFD_BOOLEAN): Define.\n+\t* addr2line.c, * ar.c, * arsup.c, * bfdtest2.c, * binemul.c,\n+\t* binemul.h, * bucomm.c, * bucomm.h, * budbg.h, * coffgrok.c,\n+\t* debug.c, * debug.h, * dlltool.c, * dwarf.c, * dwarf.h,\n+\t* elfedit.c, * emul_aix.c, * mclex.c, * nm.c, * objcopy.c,\n+\t* objdump.c, * od-macho.c, * prdbg.c, * rdcoff.c, * rddbg.c,\n+\t* readelf.c, * rename.c, * stabs.c, * strings.c, * windint.h,\n+\t* windmc.c, * windmc.h, * windres.c, * winduni.c,\n+\t* wrstabs.c: Replace bfd_boolean with bool, FALSE with false,\n+\tand TRUE with true throughout.\n+\n 2021-03-31  Alan Modra  <amodra@gmail.com>\n \n \t* coffdump.c: Include stdint.h in place of bfd_stdint.h."
    },
    {
      "sha": "578c64adbd1313ba2fbbd6a58fe8aa83a7bb822f",
      "filename": "binutils/addr2line.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/addr2line.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/addr2line.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/addr2line.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -38,12 +38,12 @@\n #include \"bucomm.h\"\n #include \"elf-bfd.h\"\n \n-static bfd_boolean unwind_inlines;\t/* -i, unwind inlined functions. */\n-static bfd_boolean with_addresses;\t/* -a, show addresses.  */\n-static bfd_boolean with_functions;\t/* -f, show function names.  */\n-static bfd_boolean do_demangle;\t\t/* -C, demangle names.  */\n-static bfd_boolean pretty_print;\t/* -p, print on one line.  */\n-static bfd_boolean base_names;\t\t/* -s, strip directory names.  */\n+static bool unwind_inlines;\t/* -i, unwind inlined functions. */\n+static bool with_addresses;\t/* -a, show addresses.  */\n+static bool with_functions;\t/* -f, show function names.  */\n+static bool do_demangle;\t/* -C, demangle names.  */\n+static bool pretty_print;\t/* -p, print on one line.  */\n+static bool base_names;\t\t/* -s, strip directory names.  */\n \n /* Flags passed to the name demangler.  */\n static int demangle_flags = DMGL_PARAMS | DMGL_ANSI;\n@@ -117,7 +117,7 @@ slurp_symtab (bfd *abfd)\n {\n   long storage;\n   long symcount;\n-  bfd_boolean dynamic = FALSE;\n+  bool dynamic = false;\n \n   if ((bfd_get_file_flags (abfd) & HAS_SYMS) == 0)\n     return;\n@@ -126,7 +126,7 @@ slurp_symtab (bfd *abfd)\n   if (storage == 0)\n     {\n       storage = bfd_get_dynamic_symtab_upper_bound (abfd);\n-      dynamic = TRUE;\n+      dynamic = true;\n     }\n   if (storage < 0)\n     bfd_fatal (bfd_get_filename (abfd));\n@@ -167,7 +167,7 @@ static const char *filename;\n static const char *functionname;\n static unsigned int line;\n static unsigned int discriminator;\n-static bfd_boolean found;\n+static bool found;\n \n /* Look for an address in a section.  This is called via\n    bfd_map_over_sections.  */\n@@ -267,7 +267,7 @@ translate_addresses (bfd *abfd, asection *section)\n             printf (\"\\n\");\n         }\n \n-      found = FALSE;\n+      found = false;\n       if (section)\n \tfind_offset_in_section (abfd, section);\n       else\n@@ -337,7 +337,7 @@ translate_addresses (bfd *abfd, asection *section)\n \t      else\n \t\tprintf (\"?\\n\");\n               if (!unwind_inlines)\n-                found = FALSE;\n+                found = false;\n               else\n                 found = bfd_find_inliner_info (abfd, &filename, &functionname,\n \t\t\t\t\t       &line);\n@@ -455,13 +455,13 @@ main (int argc, char **argv)\n \tcase 0:\n \t  break;\t\t/* We've been given a long option.  */\n \tcase 'a':\n-\t  with_addresses = TRUE;\n+\t  with_addresses = true;\n \t  break;\n \tcase 'b':\n \t  target = optarg;\n \t  break;\n \tcase 'C':\n-\t  do_demangle = TRUE;\n+\t  do_demangle = true;\n \t  if (optarg != NULL)\n \t    {\n \t      enum demangling_styles style;\n@@ -484,13 +484,13 @@ main (int argc, char **argv)\n \t  file_name = optarg;\n \t  break;\n \tcase 's':\n-\t  base_names = TRUE;\n+\t  base_names = true;\n \t  break;\n \tcase 'f':\n-\t  with_functions = TRUE;\n+\t  with_functions = true;\n \t  break;\n         case 'p':\n-          pretty_print = TRUE;\n+          pretty_print = true;\n           break;\n \tcase 'v':\n \tcase 'V':\n@@ -501,7 +501,7 @@ main (int argc, char **argv)\n \t  usage (stdout, 0);\n \t  break;\n \tcase 'i':\n-\t  unwind_inlines = TRUE;\n+\t  unwind_inlines = true;\n \t  break;\n \tcase 'j':\n \t  section_name = optarg;"
    },
    {
      "sha": "71bbde65ed6e2866b5b7f8cd09026c44fd8bc65b",
      "filename": "binutils/ar.c",
      "status": "modified",
      "additions": 35,
      "deletions": 35,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/ar.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/ar.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ar.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -54,7 +54,7 @@ static void delete_members (bfd *, char **files_to_delete);\n \n static void move_members (bfd *, char **files_to_move);\n static void replace_members\n-  (bfd *, char **files_to_replace, bfd_boolean quick);\n+  (bfd *, char **files_to_replace, bool quick);\n static void print_descr (bfd * abfd);\n static void write_archive (bfd *);\n static int  ranlib_only (const char *archname);\n@@ -124,19 +124,19 @@ get_pos_bfd (bfd **, enum pos, const char *);\n \n /* For extract/delete only.  If COUNTED_NAME_MODE is TRUE, we only\n    extract the COUNTED_NAME_COUNTER instance of that name.  */\n-static bfd_boolean counted_name_mode = 0;\n+static bool counted_name_mode = 0;\n static int counted_name_counter = 0;\n \n /* Whether to truncate names of files stored in the archive.  */\n-static bfd_boolean ar_truncate = FALSE;\n+static bool ar_truncate = false;\n \n /* Whether to use a full file name match when searching an archive.\n    This is convenient for archives created by the Microsoft lib\n    program.  */\n-static bfd_boolean full_pathname = FALSE;\n+static bool full_pathname = false;\n \n /* Whether to create a \"thin\" archive (symbol index only -- no files).  */\n-static bfd_boolean make_thin_archive = FALSE;\n+static bool make_thin_archive = false;\n \n #define LIBDEPS\t\"__.LIBDEP\"\n /* Text to store in the __.LIBDEP archive element for the linker to use.  */\n@@ -215,7 +215,7 @@ map_over_members (bfd *arch, void (*function)(bfd *), char **files, int count)\n \n   for (; count > 0; files++, count--)\n     {\n-      bfd_boolean found = FALSE;\n+      bool found = false;\n \n       match_count = 0;\n       for (head = arch->archive_next; head; head = head->archive_next)\n@@ -257,7 +257,7 @@ map_over_members (bfd *arch, void (*function)(bfd *), char **files, int count)\n \t\t  continue;\n \t\t}\n \n-\t      found = TRUE;\n+\t      found = true;\n \t      function (head);\n \t      head->archive_pass = 1;\n \t      /* PR binutils/15796: Once a file has been matched, do not\n@@ -275,7 +275,7 @@ map_over_members (bfd *arch, void (*function)(bfd *), char **files, int count)\n     }\n }\n \f\n-bfd_boolean operation_alters_arch = FALSE;\n+bool operation_alters_arch = false;\n \n static void\n usage (int help)\n@@ -519,22 +519,22 @@ decode_options (int argc, char **argv)\n \t  break;\n         case 'd':\n           operation = del;\n-          operation_alters_arch = TRUE;\n+          operation_alters_arch = true;\n           break;\n         case 'm':\n           operation = move;\n-          operation_alters_arch = TRUE;\n+          operation_alters_arch = true;\n           break;\n         case 'p':\n           operation = print_files;\n           break;\n         case 'q':\n           operation = quick_append;\n-          operation_alters_arch = TRUE;\n+          operation_alters_arch = true;\n           break;\n         case 'r':\n           operation = replace;\n-          operation_alters_arch = TRUE;\n+          operation_alters_arch = true;\n           break;\n         case 't':\n           operation = print_table;\n@@ -557,7 +557,7 @@ decode_options (int argc, char **argv)\n           display_offsets = 1;\n           break;\n         case 'V':\n-          show_version = TRUE;\n+          show_version = true;\n           break;\n         case 's':\n           write_armap = 1;\n@@ -584,22 +584,22 @@ decode_options (int argc, char **argv)\n           mri_mode = 1;\n           break;\n         case 'N':\n-          counted_name_mode = TRUE;\n+          counted_name_mode = true;\n           break;\n         case 'f':\n-          ar_truncate = TRUE;\n+          ar_truncate = true;\n           break;\n         case 'P':\n-          full_pathname = TRUE;\n+          full_pathname = true;\n           break;\n         case 'T':\n-          make_thin_archive = TRUE;\n+          make_thin_archive = true;\n           break;\n         case 'D':\n-          deterministic = TRUE;\n+          deterministic = true;\n           break;\n         case 'U':\n-          deterministic = FALSE;\n+          deterministic = false;\n           break;\n \tcase OPTION_PLUGIN:\n #if BFD_SUPPORTS_PLUGINS\n@@ -650,25 +650,25 @@ static void\n ranlib_main (int argc, char **argv)\n {\n   int arg_index, status = 0;\n-  bfd_boolean touch = FALSE;\n+  bool touch = false;\n   int c;\n \n   while ((c = getopt_long (argc, argv, \"DhHUvVt\", long_options, NULL)) != EOF)\n     {\n       switch (c)\n         {\n \tcase 'D':\n-\t  deterministic = TRUE;\n+\t  deterministic = true;\n \t  break;\n         case 'U':\n-          deterministic = FALSE;\n+          deterministic = false;\n           break;\n \tcase 'h':\n \tcase 'H':\n \t  show_help = 1;\n \t  break;\n \tcase 't':\n-\t  touch = TRUE;\n+\t  touch = true;\n \t  break;\n \tcase 'v':\n \tcase 'V':\n@@ -1292,7 +1292,7 @@ write_archive (bfd *iarch)\n     obfd->flags |= BFD_ARCHIVE_FULL_PATH;\n \n   if (make_thin_archive || bfd_is_thin_archive (iarch))\n-    bfd_set_thin_archive (obfd, TRUE);\n+    bfd_set_thin_archive (obfd, true);\n \n   if (!bfd_set_archive_head (obfd, contents_head))\n     bfd_fatal (old_name);\n@@ -1307,7 +1307,7 @@ write_archive (bfd *iarch)\n   /* We don't care if this fails; we might be creating the archive.  */\n   bfd_close (iarch);\n \n-  if (smart_rename (new_name, old_name, tmpfd, NULL, FALSE) != 0)\n+  if (smart_rename (new_name, old_name, tmpfd, NULL, false) != 0)\n     xexit (1);\n   free (old_name);\n   free (new_name);\n@@ -1357,8 +1357,8 @@ static void\n delete_members (bfd *arch, char **files_to_delete)\n {\n   bfd **current_ptr_ptr;\n-  bfd_boolean found;\n-  bfd_boolean something_changed = FALSE;\n+  bool found;\n+  bool something_changed = false;\n   int match_count;\n \n   for (; *files_to_delete != NULL; ++files_to_delete)\n@@ -1371,12 +1371,12 @@ delete_members (bfd *arch, char **files_to_delete)\n \n       if (!strcmp (*files_to_delete, \"__.SYMDEF\"))\n \t{\n-\t  arch->has_armap = FALSE;\n+\t  arch->has_armap = false;\n \t  write_armap = -1;\n \t  continue;\n \t}\n \n-      found = FALSE;\n+      found = false;\n       match_count = 0;\n       current_ptr_ptr = &(arch->archive_next);\n       while (*current_ptr_ptr)\n@@ -1393,8 +1393,8 @@ delete_members (bfd *arch, char **files_to_delete)\n \t\t}\n \t      else\n \t\t{\n-\t\t  found = TRUE;\n-\t\t  something_changed = TRUE;\n+\t\t  found = true;\n+\t\t  something_changed = true;\n \t\t  if (verbose)\n \t\t    printf (\"d - %s\\n\",\n \t\t\t    *files_to_delete);\n@@ -1471,9 +1471,9 @@ move_members (bfd *arch, char **files_to_move)\n /* Ought to default to replacing in place, but this is existing practice!  */\n \n static void\n-replace_members (bfd *arch, char **files_to_move, bfd_boolean quick)\n+replace_members (bfd *arch, char **files_to_move, bool quick)\n {\n-  bfd_boolean changed = FALSE;\n+  bool changed = false;\n   bfd **after_bfd;\t\t/* New entries go after this one.  */\n   bfd *current;\n   bfd **current_ptr;\n@@ -1493,7 +1493,7 @@ replace_members (bfd *arch, char **files_to_move, bfd_boolean quick)\n \t\t\t\tnormalize (bfd_get_filename (current), arch)) == 0\n \t\t  && current->arelt_data != NULL)\n \t\t{\n-\t\t  bfd_boolean replaced;\n+\t\t  bool replaced;\n \t\t  if (newer_only)\n \t\t    {\n \t\t      struct stat fsbuf, asbuf;\n@@ -1531,7 +1531,7 @@ replace_members (bfd *arch, char **files_to_move, bfd_boolean quick)\n \t\t    {\n \t\t      /* Snip out this entry from the chain.  */\n \t\t      *current_ptr = (*current_ptr)->archive_next;\n-\t\t      changed = TRUE;\n+\t\t      changed = true;\n \t\t    }\n \n \t\t  goto next_file;"
    },
    {
      "sha": "5cf34e2c112c1aba715eab5d373d65c10f6ed6a9",
      "filename": "binutils/arsup.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/arsup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/arsup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/arsup.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -74,15 +74,15 @@ map_over_list (bfd *arch, void (*function) (bfd *, bfd *), struct list *list)\n \t want to hack multiple references.  */\n       for (ptr = list; ptr; ptr = ptr->next)\n \t{\n-\t  bfd_boolean found = FALSE;\n+\t  bool found = false;\n \t  bfd *prev = arch;\n \n \t  for (head = arch->archive_next; head; head = head->archive_next)\n \t    {\n \t      if (bfd_get_filename (head) != NULL\n \t\t  && FILENAME_CMP (ptr->name, bfd_get_filename (head)) == 0)\n \t\t{\n-\t\t  found = TRUE;\n+\t\t  found = true;\n \t\t  function (head, prev);\n \t\t}\n \t      prev = head;\n@@ -98,7 +98,7 @@ map_over_list (bfd *arch, void (*function) (bfd *, bfd *), struct list *list)\n static void\n ar_directory_doer (bfd *abfd, bfd *ignore ATTRIBUTE_UNUSED)\n {\n-  print_arelt_descr(outfile, abfd, verbose, FALSE);\n+  print_arelt_descr(outfile, abfd, verbose, false);\n }\n \n void\n@@ -364,7 +364,7 @@ ar_save (void)\n \t    }\n \t}\n \n-      smart_rename (temp_name, real_name, temp_fd, NULL, FALSE);\n+      smart_rename (temp_name, real_name, temp_fd, NULL, false);\n       obfd = 0;\n       free (temp_name);\n       free (real_name);"
    },
    {
      "sha": "b33fc7114307129fd4c2731a7a094801a2b7cd9e",
      "filename": "binutils/bfdtest2.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/bfdtest2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/bfdtest2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/bfdtest2.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -53,13 +53,13 @@ iovec_stat (struct bfd *abfd ATTRIBUTE_UNUSED,\n   return fstat (fileno ((FILE*) stream), sb);\r\n }\r\n \r\n-static bfd_boolean\r\n+static bool\r\n check_format_any (struct bfd *abfd, bfd_format format)\r\n {\r\n   char** targets = NULL;\r\n \r\n   if (bfd_check_format_matches (abfd, format, &targets))\r\n-    return TRUE;\r\n+    return true;\r\n \r\n   if (targets)\r\n     {\r\n@@ -68,7 +68,7 @@ check_format_any (struct bfd *abfd, bfd_format format)\n       return bfd_check_format (abfd, format);\r\n     }\r\n \r\n-  return FALSE;\r\n+  return false;\r\n }\r\n \r\n int\r"
    },
    {
      "sha": "baa78f40e72aa44ab1aa324e023f78eb53518e02",
      "filename": "binutils/binemul.c",
      "status": "modified",
      "additions": 31,
      "deletions": 31,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/binemul.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/binemul.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/binemul.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -38,9 +38,9 @@ ar_emul_default_usage (FILE *fp)\n   fprintf (fp, _(\"  No emulation specific options\\n\"));\n }\n \n-bfd_boolean\n+bool\n ar_emul_append (bfd **after_bfd, char *file_name, const char *target,\n-\t\tbfd_boolean verbose, bfd_boolean flatten)\n+\t\tbool verbose, bool flatten)\n {\n   bfd *new_bfd;\n \n@@ -50,45 +50,45 @@ ar_emul_append (bfd **after_bfd, char *file_name, const char *target,\n     return bin_dummy_emulation.ar_append (after_bfd, new_bfd,\n \t\t\t\t\t  verbose, flatten);\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n ar_emul_append_bfd (bfd **after_bfd, bfd *new_bfd,\n-\t\tbfd_boolean verbose, bfd_boolean flatten)\n+\t\tbool verbose, bool flatten)\n {\n   if (bin_dummy_emulation.ar_append)\n     return bin_dummy_emulation.ar_append (after_bfd, new_bfd,\n \t\t\t\t\t  verbose, flatten);\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n any_ok (bfd *new_bfd ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n do_ar_emul_append (bfd **after_bfd, bfd *new_bfd,\n-\t\t   bfd_boolean verbose, bfd_boolean flatten,\n-\t\t   bfd_boolean (*check) (bfd *))\n+\t\t   bool verbose, bool flatten,\n+\t\t   bool (*check) (bfd *))\n {\n   /* When flattening, add the members of an archive instead of the\n      archive itself.  */\n   if (flatten && bfd_check_format (new_bfd, bfd_archive))\n     {\n       bfd *elt;\n-      bfd_boolean added = FALSE;\n+      bool added = false;\n \n       for (elt = bfd_openr_next_archived_file (new_bfd, NULL);\n            elt;\n            elt = bfd_openr_next_archived_file (new_bfd, elt))\n         {\n-          if (do_ar_emul_append (after_bfd, elt, verbose, TRUE, check))\n+          if (do_ar_emul_append (after_bfd, elt, verbose, true, check))\n             {\n-              added = TRUE;\n+              added = true;\n               after_bfd = &((*after_bfd)->archive_next);\n             }\n         }\n@@ -97,26 +97,26 @@ do_ar_emul_append (bfd **after_bfd, bfd *new_bfd,\n     }\n \n   if (!check (new_bfd))\n-    return FALSE;\n+    return false;\n \n   AR_EMUL_APPEND_PRINT_VERBOSE (verbose, bfd_get_filename (new_bfd));\n \n   new_bfd->archive_next = *after_bfd;\n   *after_bfd = new_bfd;\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n ar_emul_default_append (bfd **after_bfd, bfd *new_bfd,\n-\t\t\tbfd_boolean verbose, bfd_boolean flatten)\n+\t\t\tbool verbose, bool flatten)\n {\n   return do_ar_emul_append (after_bfd, new_bfd, verbose, flatten, any_ok);\n }\n \n-bfd_boolean\n+bool\n ar_emul_replace (bfd **after_bfd, char *file_name, const char *target,\n-\t\t bfd_boolean verbose)\n+\t\t bool verbose)\n {\n   bfd *new_bfd;\n \n@@ -127,43 +127,43 @@ ar_emul_replace (bfd **after_bfd, char *file_name, const char *target,\n     return bin_dummy_emulation.ar_replace (after_bfd, new_bfd,\n \t\t\t\t\t   verbose);\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n ar_emul_replace_bfd (bfd **after_bfd, bfd *new_bfd,\n-\t\t bfd_boolean verbose)\n+\t\t bool verbose)\n {\n   if (bin_dummy_emulation.ar_replace)\n     return bin_dummy_emulation.ar_replace (after_bfd, new_bfd,\n \t\t\t\t\t   verbose);\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n ar_emul_default_replace (bfd **after_bfd, bfd *new_bfd,\n-\t\t\t bfd_boolean verbose)\n+\t\t\t bool verbose)\n {\n   AR_EMUL_REPLACE_PRINT_VERBOSE (verbose, bfd_get_filename (new_bfd));\n \n   new_bfd->archive_next = *after_bfd;\n   *after_bfd = new_bfd;\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n ar_emul_parse_arg (char *arg)\n {\n   if (bin_dummy_emulation.ar_parse_arg)\n     return bin_dummy_emulation.ar_parse_arg (arg);\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n ar_emul_default_parse_arg (char *arg ATTRIBUTE_UNUSED)\n {\n-  return FALSE;\n+  return false;\n }"
    },
    {
      "sha": "c15260fe97edc122f65e00eae4125766d09f67e3",
      "filename": "binutils/binemul.h",
      "status": "modified",
      "additions": 13,
      "deletions": 21,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/binemul.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/binemul.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/binemul.h?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -28,23 +28,15 @@\n \n extern void ar_emul_usage (FILE *);\n extern void ar_emul_default_usage (FILE *);\n-extern bfd_boolean ar_emul_append (bfd **, char *, const char *,\n-\t\t\t\t   bfd_boolean, bfd_boolean);\n-extern bfd_boolean ar_emul_append_bfd (bfd **, bfd *,\n-\t\t\t\t       bfd_boolean, bfd_boolean);\n-extern bfd_boolean ar_emul_default_append (bfd **, bfd *,\n-\t\t\t\t\t   bfd_boolean, bfd_boolean);\n-extern bfd_boolean do_ar_emul_append (bfd **, bfd *,\n-\t\t\t\t      bfd_boolean, bfd_boolean,\n-\t\t\t\t      bfd_boolean (*)(bfd *));\n-extern bfd_boolean ar_emul_replace (bfd **, char *, const char *,\n-\t\t\t\t    bfd_boolean);\n-extern bfd_boolean ar_emul_replace_bfd (bfd **, bfd *,\n-\t\t\t\t\tbfd_boolean);\n-extern bfd_boolean ar_emul_default_replace (bfd **, bfd *,\n-\t\t\t\t\t    bfd_boolean);\n-extern bfd_boolean ar_emul_parse_arg (char *);\n-extern bfd_boolean ar_emul_default_parse_arg (char *);\n+extern bool ar_emul_append (bfd **, char *, const char *, bool, bool);\n+extern bool ar_emul_append_bfd (bfd **, bfd *, bool, bool);\n+extern bool ar_emul_default_append (bfd **, bfd *, bool, bool);\n+extern bool do_ar_emul_append (bfd **, bfd *, bool, bool, bool (*)(bfd *));\n+extern bool ar_emul_replace (bfd **, char *, const char *, bool);\n+extern bool ar_emul_replace_bfd (bfd **, bfd *, bool);\n+extern bool ar_emul_default_replace (bfd **, bfd *, bool);\n+extern bool ar_emul_parse_arg (char *);\n+extern bool ar_emul_default_parse_arg (char *);\n \n /* Macros for common output.  */\n \n@@ -64,10 +56,10 @@ extern bfd_boolean ar_emul_default_parse_arg (char *);\n typedef struct bin_emulation_xfer_struct\n {\n   /* Print out the extra options.  */\n-  void (* ar_usage) (FILE *fp);\n-  bfd_boolean (* ar_append) (bfd **, bfd *, bfd_boolean, bfd_boolean);\n-  bfd_boolean (* ar_replace) (bfd **, bfd *, bfd_boolean);\n-  bfd_boolean (* ar_parse_arg) (char *);\n+  void (*ar_usage) (FILE *fp);\n+  bool (*ar_append) (bfd **, bfd *, bool, bool);\n+  bool (*ar_replace) (bfd **, bfd *, bool);\n+  bool (*ar_parse_arg) (char *);\n }\n bin_emulation_xfer_type;\n "
    },
    {
      "sha": "5a3eab62f98e46f8bea71661dd929adb26a16eb6",
      "filename": "binutils/bucomm.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/bucomm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/bucomm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/bucomm.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -435,7 +435,7 @@ display_info (void)\n    Mode       User\\tGroup\\tSize\\tDate               Name */\n \n void\n-print_arelt_descr (FILE *file, bfd *abfd, bfd_boolean verbose, bfd_boolean offsets)\n+print_arelt_descr (FILE *file, bfd *abfd, bool verbose, bool offsets)\n {\n   struct stat buf;\n \n@@ -677,24 +677,24 @@ bfd_get_archive_filename (const bfd *abfd)\n    is valid for writing.  For security reasons absolute paths\n    and paths containing /../ are not allowed.  See PR 17533.  */\n \n-bfd_boolean\n+bool\n is_valid_archive_path (char const * pathname)\n {\n   const char * n = pathname;\n \n   if (IS_ABSOLUTE_PATH (n))\n-    return FALSE;\n+    return false;\n \n   while (*n)\n     {\n       if (*n == '.' && *++n == '.' && ( ! *++n || IS_DIR_SEPARATOR (*n)))\n-\treturn FALSE;\n+\treturn false;\n \n       while (*n && ! IS_DIR_SEPARATOR (*n))\n \tn++;\n       while (IS_DIR_SEPARATOR (*n))\n \tn++;\n     }\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "78f61762cac9f50188dd72ca98e7f29f7c8cee1f",
      "filename": "binutils/bucomm.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/bucomm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/bucomm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/bucomm.h?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -49,7 +49,7 @@ void list_supported_architectures (const char *, FILE *);\n \n int display_info (void);\n \n-void print_arelt_descr (FILE *, bfd *, bfd_boolean, bfd_boolean);\n+void print_arelt_descr (FILE *, bfd *, bool, bool);\n \n char *make_tempname (const char *, int *);\n char *make_tempdir (const char *);\n@@ -58,7 +58,7 @@ bfd_vma parse_vma (const char *, const char *);\n \n off_t get_file_size (const char *);\n \n-bfd_boolean is_valid_archive_path (char const *);\n+bool is_valid_archive_path (char const *);\n \n extern char *program_name;\n \n@@ -72,7 +72,7 @@ extern void print_version (const char *);\n extern void set_times (const char *, const struct stat *);\n \n extern int smart_rename (const char *, const char *, int,\n-\t\t\t struct stat *, bfd_boolean);\n+\t\t\t struct stat *, bool);\n \n \n /* In libiberty.  */"
    },
    {
      "sha": "a426a1f6178f2ce9df4a7bd7b3550b48cbd575ab",
      "filename": "binutils/budbg.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/budbg.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/budbg.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/budbg.h?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -24,28 +24,28 @@\n \n /* Routine used to read generic debugging information.  */\n \n-extern void *read_debugging_info (bfd *, asymbol **, long, bfd_boolean);\n+extern void *read_debugging_info (bfd *, asymbol **, long, bool);\n \n /* Routine used to print generic debugging information.  */\n \n-extern bfd_boolean print_debugging_info\n+extern bool print_debugging_info\n   (FILE *, void *, bfd *, asymbol **,\n-   char * (*) (struct bfd *, const char *, int), bfd_boolean);\n+   char * (*) (struct bfd *, const char *, int), bool);\n \n /* Routines used to read and write stabs information.  */\n \n-extern void *start_stab (void *, bfd *, bfd_boolean, asymbol **, long);\n+extern void *start_stab (void *, bfd *, bool, asymbol **, long);\n \n-extern bfd_boolean finish_stab (void *, void *);\n+extern bool finish_stab (void *, void *);\n \n-extern bfd_boolean parse_stab\n+extern bool parse_stab\n   (void *, void *, int, int, bfd_vma, const char *);\n \n-extern bfd_boolean write_stabs_in_sections_debugging_info\n+extern bool write_stabs_in_sections_debugging_info\n   (bfd *, void *, bfd_byte **, bfd_size_type *, bfd_byte **, bfd_size_type *);\n \n /* Routine used to read COFF debugging information.  */\n \n-extern bfd_boolean parse_coff (bfd *, asymbol **, long, void *);\n+extern bool parse_coff (bfd *, asymbol **, long, void *);\n \n #endif"
    },
    {
      "sha": "e3882544b0611c42246a37343285760de3d1ba66",
      "filename": "binutils/coffgrok.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/coffgrok.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/coffgrok.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/coffgrok.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -720,7 +720,7 @@ static struct coff_ofile *\n doit (void)\n {\n   unsigned int i;\n-  bfd_boolean infile = FALSE;\n+  bool infile = false;\n   struct coff_ofile *head =\n     (struct coff_ofile *) xmalloc (sizeof (struct coff_ofile));\n \n@@ -753,7 +753,7 @@ doit (void)\n \t    if (infile)\n \t      pop_scope ();\n \t    else\n-\t      infile = TRUE;\n+\t      infile = true;\n \n \t    push_scope (1);\n \t    file_scope = n->scope = top_scope;"
    },
    {
      "sha": "93887374d15dd87ef0844ba8dda2fdad3cee4186",
      "filename": "binutils/debug.c",
      "status": "modified",
      "additions": 194,
      "deletions": 194,
      "changes": 388,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/debug.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/debug.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/debug.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -111,7 +111,7 @@ struct debug_type_s\n       struct debug_indirect_type *kindirect;\n       /* DEBUG_KIND_INT.  */\n       /* Whether the integer is unsigned.  */\n-      bfd_boolean kint;\n+      bool kint;\n       /* DEBUG_KIND_STRUCT, DEBUG_KIND_UNION, DEBUG_KIND_CLASS,\n          DEBUG_KIND_UNION_CLASS.  */\n       struct debug_class_type *kclass;\n@@ -194,7 +194,7 @@ struct debug_function_type\n   /* NULL terminated array of argument types.  */\n   debug_type *arg_types;\n   /* Whether the function takes a variable number of arguments.  */\n-  bfd_boolean varargs;\n+  bool varargs;\n };\n \n /* Information kept for a range.  */\n@@ -222,7 +222,7 @@ struct debug_array_type\n   /* Upper bound.  */\n   bfd_signed_vma upper;\n   /* Whether this array is really a string.  */\n-  bfd_boolean stringp;\n+  bool stringp;\n };\n \n /* Information kept for a set.  */\n@@ -232,7 +232,7 @@ struct debug_set_type\n   /* Base type.  */\n   debug_type type;\n   /* Whether this set is really a bitstring.  */\n-  bfd_boolean bitstringp;\n+  bool bitstringp;\n };\n \n /* Information kept for an offset type (a based pointer).  */\n@@ -256,7 +256,7 @@ struct debug_method_type\n   /* A NULL terminated array of argument types.  */\n   debug_type *arg_types;\n   /* Whether the method takes a variable number of arguments.  */\n-  bfd_boolean varargs;\n+  bool varargs;\n };\n \n /* Information kept for a named type.  */\n@@ -280,7 +280,7 @@ struct debug_field_s\n   /* Visibility of the field.  */\n   enum debug_visibility visibility;\n   /* Whether this is a static member.  */\n-  bfd_boolean static_member;\n+  bool static_member;\n   union\n     {\n       /* If static_member is false.  */\n@@ -308,7 +308,7 @@ struct debug_baseclass_s\n   /* Bit position of the base class in the object.  */\n   unsigned int bitpos;\n   /* Whether the base class is virtual.  */\n-  bfd_boolean is_virtual;\n+  bool is_virtual;\n   /* Visibility of the base class.  */\n   enum debug_visibility visibility;\n };\n@@ -335,9 +335,9 @@ struct debug_method_variant_s\n   /* The visibility of the function.  */\n   enum debug_visibility visibility;\n   /* Whether the function is const.  */\n-  bfd_boolean constp;\n+  bool constp;\n   /* Whether the function is volatile.  */\n-  bfd_boolean volatilep;\n+  bool volatilep;\n   /* The offset to the function in the virtual function table.  */\n   bfd_vma voffset;\n   /* If voffset is VOFFSET_STATIC_METHOD, this is a static method.  */\n@@ -565,28 +565,28 @@ static struct debug_type_s *debug_make_type\n   (struct debug_handle *, enum debug_type_kind, unsigned int);\n static struct debug_type_s *debug_get_real_type\n   (void *, debug_type, struct debug_type_real_list *);\n-static bfd_boolean debug_write_name\n+static bool debug_write_name\n   (struct debug_handle *, const struct debug_write_fns *, void *,\n    struct debug_name *);\n-static bfd_boolean debug_write_type\n+static bool debug_write_type\n   (struct debug_handle *, const struct debug_write_fns *, void *,\n    struct debug_type_s *, struct debug_name *);\n-static bfd_boolean debug_write_class_type\n+static bool debug_write_class_type\n   (struct debug_handle *, const struct debug_write_fns *, void *,\n    struct debug_type_s *, const char *);\n-static bfd_boolean debug_write_function\n+static bool debug_write_function\n   (struct debug_handle *, const struct debug_write_fns *, void *,\n    const char *, enum debug_object_linkage, struct debug_function *);\n-static bfd_boolean debug_write_block\n+static bool debug_write_block\n   (struct debug_handle *, const struct debug_write_fns *, void *,\n    struct debug_block *);\n-static bfd_boolean debug_write_linenos\n+static bool debug_write_linenos\n   (struct debug_handle *, const struct debug_write_fns *, void *, bfd_vma);\n-static bfd_boolean debug_set_class_id\n+static bool debug_set_class_id\n   (struct debug_handle *, const char *, struct debug_type_s *);\n-static bfd_boolean debug_type_samep\n+static bool debug_type_samep\n   (struct debug_handle *, struct debug_type_s *, struct debug_type_s *);\n-static bfd_boolean debug_class_type_samep\n+static bool debug_class_type_samep\n   (struct debug_handle *, struct debug_type_s *, struct debug_type_s *);\n \f\n /* Issue an error message.  */\n@@ -671,7 +671,7 @@ debug_init (void)\n /* Set the source filename.  This implicitly starts a new compilation\n    unit.  */\n \n-bfd_boolean\n+bool\n debug_set_filename (void *handle, const char *name)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -706,13 +706,13 @@ debug_set_filename (void *handle, const char *name)\n   info->current_block = NULL;\n   info->current_lineno = NULL;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Change source files to the given file name.  This is used for\n    include files in a single compilation unit.  */\n \n-bfd_boolean\n+bool\n debug_start_source (void *handle, const char *name)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -724,15 +724,15 @@ debug_start_source (void *handle, const char *name)\n   if (info->current_unit == NULL)\n     {\n       debug_error (_(\"debug_start_source: no debug_set_filename call\"));\n-      return FALSE;\n+      return false;\n     }\n \n   for (f = info->current_unit->files; f != NULL; f = f->next)\n     {\n       if (filename_cmp (f->filename, name) == 0)\n \t{\n \t  info->current_file = f;\n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n \n@@ -749,7 +749,7 @@ debug_start_source (void *handle, const char *name)\n \n   info->current_file = f;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Record a function definition.  This implicitly starts a function\n@@ -760,9 +760,9 @@ debug_start_source (void *handle, const char *name)\n    debug_record_parameter.  FIXME: There is no way to specify nested\n    functions.  */\n \n-bfd_boolean\n+bool\n debug_record_function (void *handle, const char *name,\n-\t\t       debug_type return_type, bfd_boolean global,\n+\t\t       debug_type return_type, bool global,\n \t\t       bfd_vma addr)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -773,12 +773,12 @@ debug_record_function (void *handle, const char *name,\n   if (name == NULL)\n     name = \"\";\n   if (return_type == NULL)\n-    return FALSE;\n+    return false;\n \n   if (info->current_unit == NULL)\n     {\n       debug_error (_(\"debug_record_function: no debug_set_filename call\"));\n-      return FALSE;\n+      return false;\n     }\n \n   f = (struct debug_function *) xmalloc (sizeof *f);\n@@ -807,30 +807,30 @@ debug_record_function (void *handle, const char *name,\n \t\t\t       ? DEBUG_LINKAGE_GLOBAL\n \t\t\t       : DEBUG_LINKAGE_STATIC));\n   if (n == NULL)\n-    return FALSE;\n+    return false;\n \n   n->u.function = f;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Record a parameter for the current function.  */\n \n-bfd_boolean\n+bool\n debug_record_parameter (void *handle, const char *name, debug_type type,\n \t\t\tenum debug_parm_kind kind, bfd_vma val)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_parameter *p, **pp;\n \n   if (name == NULL || type == NULL)\n-    return FALSE;\n+    return false;\n \n   if (info->current_unit == NULL\n       || info->current_function == NULL)\n     {\n       debug_error (_(\"debug_record_parameter: no current function\"));\n-      return FALSE;\n+      return false;\n     }\n \n   p = (struct debug_parameter *) xmalloc (sizeof *p);\n@@ -847,12 +847,12 @@ debug_record_parameter (void *handle, const char *name, debug_type type,\n     ;\n   *pp = p;\n \n-  return TRUE;\n+  return true;\n }\n \n /* End a function.  FIXME: This should handle function nesting.  */\n \n-bfd_boolean\n+bool\n debug_end_function (void *handle, bfd_vma addr)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -862,29 +862,29 @@ debug_end_function (void *handle, bfd_vma addr)\n       || info->current_function == NULL)\n     {\n       debug_error (_(\"debug_end_function: no current function\"));\n-      return FALSE;\n+      return false;\n     }\n \n   if (info->current_block->parent != NULL)\n     {\n       debug_error (_(\"debug_end_function: some blocks were not closed\"));\n-      return FALSE;\n+      return false;\n     }\n \n   info->current_block->end = addr;\n \n   info->current_function = NULL;\n   info->current_block = NULL;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start a block in a function.  All local information will be\n    recorded in this block, until the matching call to debug_end_block.\n    debug_start_block and debug_end_block may be nested.  The bfd_vma\n    argument is the address at which this block starts.  */\n \n-bfd_boolean\n+bool\n debug_start_block (void *handle, bfd_vma addr)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -896,7 +896,7 @@ debug_start_block (void *handle, bfd_vma addr)\n       || info->current_block == NULL)\n     {\n       debug_error (_(\"debug_start_block: no current block\"));\n-      return FALSE;\n+      return false;\n     }\n \n   b = (struct debug_block *) xmalloc (sizeof *b);\n@@ -915,14 +915,14 @@ debug_start_block (void *handle, bfd_vma addr)\n \n   info->current_block = b;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Finish a block in a function.  This matches the call to\n    debug_start_block.  The argument is the address at which this block\n    ends.  */\n \n-bfd_boolean\n+bool\n debug_end_block (void *handle, bfd_vma addr)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -932,27 +932,27 @@ debug_end_block (void *handle, bfd_vma addr)\n       || info->current_block == NULL)\n     {\n       debug_error (_(\"debug_end_block: no current block\"));\n-      return FALSE;\n+      return false;\n     }\n \n   parent = info->current_block->parent;\n   if (parent == NULL)\n     {\n       debug_error (_(\"debug_end_block: attempt to close top level block\"));\n-      return FALSE;\n+      return false;\n     }\n \n   info->current_block->end = addr;\n \n   info->current_block = parent;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Associate a line number in the current source file and function\n    with a given address.  */\n \n-bfd_boolean\n+bool\n debug_record_line (void *handle, unsigned long lineno, bfd_vma addr)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -962,7 +962,7 @@ debug_record_line (void *handle, unsigned long lineno, bfd_vma addr)\n   if (info->current_unit == NULL)\n     {\n       debug_error (_(\"debug_record_line: no current unit\"));\n-      return FALSE;\n+      return false;\n     }\n \n   l = info->current_lineno;\n@@ -974,7 +974,7 @@ debug_record_line (void *handle, unsigned long lineno, bfd_vma addr)\n \t    {\n \t      l->linenos[i] = lineno;\n \t      l->addrs[i] = addr;\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t}\n     }\n@@ -1003,77 +1003,77 @@ debug_record_line (void *handle, unsigned long lineno, bfd_vma addr)\n \n   info->current_lineno = l;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start a named common block.  This is a block of variables that may\n    move in memory.  */\n \n-bfd_boolean\n+bool\n debug_start_common_block (void *handle ATTRIBUTE_UNUSED,\n \t\t\t  const char *name ATTRIBUTE_UNUSED)\n {\n   /* FIXME */\n   debug_error (_(\"debug_start_common_block: not implemented\"));\n-  return FALSE;\n+  return false;\n }\n \n /* End a named common block.  */\n \n-bfd_boolean\n+bool\n debug_end_common_block (void *handle ATTRIBUTE_UNUSED,\n \t\t\tconst char *name ATTRIBUTE_UNUSED)\n {\n   /* FIXME */\n   debug_error (_(\"debug_end_common_block: not implemented\"));\n-  return FALSE;\n+  return false;\n }\n \n /* Record a named integer constant.  */\n \n-bfd_boolean\n+bool\n debug_record_int_const (void *handle, const char *name, bfd_vma val)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_name *n;\n \n   if (name == NULL)\n-    return FALSE;\n+    return false;\n \n   n = debug_add_to_current_namespace (info, name, DEBUG_OBJECT_INT_CONSTANT,\n \t\t\t\t      DEBUG_LINKAGE_NONE);\n   if (n == NULL)\n-    return FALSE;\n+    return false;\n \n   n->u.int_constant = val;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Record a named floating point constant.  */\n \n-bfd_boolean\n+bool\n debug_record_float_const (void *handle, const char *name, double val)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_name *n;\n \n   if (name == NULL)\n-    return FALSE;\n+    return false;\n \n   n = debug_add_to_current_namespace (info, name, DEBUG_OBJECT_FLOAT_CONSTANT,\n \t\t\t\t      DEBUG_LINKAGE_NONE);\n   if (n == NULL)\n-    return FALSE;\n+    return false;\n \n   n->u.float_constant = val;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Record a typed constant with an integral value.  */\n \n-bfd_boolean\n+bool\n debug_record_typed_const (void *handle, const char *name, debug_type type,\n \t\t\t  bfd_vma val)\n {\n@@ -1082,12 +1082,12 @@ debug_record_typed_const (void *handle, const char *name, debug_type type,\n   struct debug_typed_constant *tc;\n \n   if (name == NULL || type == NULL)\n-    return FALSE;\n+    return false;\n \n   n = debug_add_to_current_namespace (info, name, DEBUG_OBJECT_TYPED_CONSTANT,\n \t\t\t\t      DEBUG_LINKAGE_NONE);\n   if (n == NULL)\n-    return FALSE;\n+    return false;\n \n   tc = (struct debug_typed_constant *) xmalloc (sizeof *tc);\n   memset (tc, 0, sizeof *tc);\n@@ -1097,25 +1097,25 @@ debug_record_typed_const (void *handle, const char *name, debug_type type,\n \n   n->u.typed_constant = tc;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Record a label.  */\n \n-bfd_boolean\n+bool\n debug_record_label (void *handle ATTRIBUTE_UNUSED,\n \t\t    const char *name ATTRIBUTE_UNUSED,\n \t\t    debug_type type ATTRIBUTE_UNUSED,\n \t\t    bfd_vma addr ATTRIBUTE_UNUSED)\n {\n   /* FIXME.  */\n   debug_error (_(\"debug_record_label: not implemented\"));\n-  return FALSE;\n+  return false;\n }\n \n /* Record a variable.  */\n \n-bfd_boolean\n+bool\n debug_record_variable (void *handle, const char *name, debug_type type,\n \t\t       enum debug_var_kind kind, bfd_vma val)\n {\n@@ -1126,13 +1126,13 @@ debug_record_variable (void *handle, const char *name, debug_type type,\n   struct debug_variable *v;\n \n   if (name == NULL || type == NULL)\n-    return FALSE;\n+    return false;\n \n   if (info->current_unit == NULL\n       || info->current_file == NULL)\n     {\n       debug_error (_(\"debug_record_variable: no current file\"));\n-      return FALSE;\n+      return false;\n     }\n \n   if (kind == DEBUG_GLOBAL || kind == DEBUG_STATIC)\n@@ -1154,7 +1154,7 @@ debug_record_variable (void *handle, const char *name, debug_type type,\n \n   n = debug_add_to_namespace (info, nsp, name, DEBUG_OBJECT_VARIABLE, linkage);\n   if (n == NULL)\n-    return FALSE;\n+    return false;\n \n   v = (struct debug_variable *) xmalloc (sizeof *v);\n   memset (v, 0, sizeof *v);\n@@ -1165,7 +1165,7 @@ debug_record_variable (void *handle, const char *name, debug_type type,\n \n   n->u.variable = v;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Make a type with a given kind and size.  */\n@@ -1224,7 +1224,7 @@ debug_make_void_type (void *handle)\n    if the integer is unsigned.  */\n \n debug_type\n-debug_make_int_type (void *handle, unsigned int size, bfd_boolean unsignedp)\n+debug_make_int_type (void *handle, unsigned int size, bool unsignedp)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_type_s *t;\n@@ -1275,7 +1275,7 @@ debug_make_complex_type (void *handle, unsigned int size)\n    The fourth argument is a NULL terminated array of fields.  */\n \n debug_type\n-debug_make_struct_type (void *handle, bfd_boolean structp, bfd_vma size,\n+debug_make_struct_type (void *handle, bool structp, bfd_vma size,\n \t\t\tdebug_field *fields)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -1306,10 +1306,10 @@ debug_make_struct_type (void *handle, bfd_boolean structp, bfd_vma size,\n    object has its own virtual function table.  */\n \n debug_type\n-debug_make_object_type (void *handle, bfd_boolean structp, bfd_vma size,\n+debug_make_object_type (void *handle, bool structp, bfd_vma size,\n \t\t\tdebug_field *fields, debug_baseclass *baseclasses,\n \t\t\tdebug_method *methods, debug_type vptrbase,\n-\t\t\tbfd_boolean ownvptr)\n+\t\t\tbool ownvptr)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_type_s *t;\n@@ -1393,7 +1393,7 @@ debug_make_pointer_type (void *handle, debug_type type)\n \n debug_type\n debug_make_function_type (void *handle, debug_type type,\n-\t\t\t  debug_type *arg_types, bfd_boolean varargs)\n+\t\t\t  debug_type *arg_types, bool varargs)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_type_s *t;\n@@ -1476,7 +1476,7 @@ debug_make_range_type (void *handle, debug_type type, bfd_signed_vma lower,\n debug_type\n debug_make_array_type (void *handle, debug_type element_type,\n \t\t       debug_type range_type, bfd_signed_vma lower,\n-\t\t       bfd_signed_vma upper, bfd_boolean stringp)\n+\t\t       bfd_signed_vma upper, bool stringp)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_type_s *t;\n@@ -1508,7 +1508,7 @@ debug_make_array_type (void *handle, debug_type element_type,\n    CHILL.  */\n \n debug_type\n-debug_make_set_type (void *handle, debug_type type, bfd_boolean bitstringp)\n+debug_make_set_type (void *handle, debug_type type, bool bitstringp)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_type_s *t;\n@@ -1570,7 +1570,7 @@ debug_make_offset_type (void *handle, debug_type base_type,\n debug_type\n debug_make_method_type (void *handle, debug_type return_type,\n \t\t\tdebug_type domain_type, debug_type *arg_types,\n-\t\t\tbfd_boolean varargs)\n+\t\t\tbool varargs)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n   struct debug_type_s *t;\n@@ -1678,7 +1678,7 @@ debug_make_undefined_tagged_type (void *handle, const char *name,\n \n debug_baseclass\n debug_make_baseclass (void *handle ATTRIBUTE_UNUSED, debug_type type,\n-\t\t      bfd_vma bitpos, bfd_boolean is_virtual,\n+\t\t      bfd_vma bitpos, bool is_virtual,\n \t\t      enum debug_visibility visibility)\n {\n   struct debug_baseclass_s *b;\n@@ -1712,7 +1712,7 @@ debug_make_field (void *handle ATTRIBUTE_UNUSED, const char *name,\n \n   f->name = name;\n   f->type = type;\n-  f->static_member = FALSE;\n+  f->static_member = false;\n   f->u.f.bitpos = bitpos;\n   f->u.f.bitsize = bitsize;\n   f->visibility = visibility;\n@@ -1738,7 +1738,7 @@ debug_make_static_member (void *handle ATTRIBUTE_UNUSED, const char *name,\n \n   f->name = name;\n   f->type = type;\n-  f->static_member = TRUE;\n+  f->static_member = true;\n   f->u.s.physname = physname;\n   f->visibility = visibility;\n \n@@ -1776,7 +1776,7 @@ debug_method_variant\n debug_make_method_variant (void *handle ATTRIBUTE_UNUSED,\n \t\t\t   const char *physname, debug_type type,\n \t\t\t   enum debug_visibility visibility,\n-\t\t\t   bfd_boolean constp, bfd_boolean volatilep,\n+\t\t\t   bool constp, bool volatilep,\n \t\t\t   bfd_vma voffset, debug_type context)\n {\n   struct debug_method_variant_s *m;\n@@ -1803,7 +1803,7 @@ debug_method_variant\n debug_make_static_method_variant (void *handle ATTRIBUTE_UNUSED,\n \t\t\t\t  const char *physname, debug_type type,\n \t\t\t\t  enum debug_visibility visibility,\n-\t\t\t\t  bfd_boolean constp, bfd_boolean volatilep)\n+\t\t\t\t  bool constp, bool volatilep)\n {\n   struct debug_method_variant_s *m;\n \n@@ -1921,7 +1921,7 @@ debug_tag_type (void *handle, const char *name, debug_type type)\n \n /* Record the size of a given type.  */\n \n-bfd_boolean\n+bool\n debug_record_type_size (void *handle ATTRIBUTE_UNUSED, debug_type type,\n \t\t\tunsigned int size)\n {\n@@ -1931,7 +1931,7 @@ debug_record_type_size (void *handle ATTRIBUTE_UNUSED, debug_type type,\n \n   type->size = size;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Find a named type.  */\n@@ -2163,7 +2163,7 @@ debug_get_return_type (void *handle, debug_type type)\n \n const debug_type *\n debug_get_parameter_types (void *handle, debug_type type,\n-\t\t\t   bfd_boolean *pvarargs)\n+\t\t\t   bool *pvarargs)\n {\n   if (type == NULL)\n     return NULL;\n@@ -2303,7 +2303,7 @@ debug_get_field_physname (void *handle ATTRIBUTE_UNUSED, debug_field field)\n /* Write out the debugging information.  This is given a handle to\n    debugging information, and a set of function pointers to call.  */\n \n-bfd_boolean\n+bool\n debug_write (void *handle, const struct debug_write_fns *fns, void *fhandle)\n {\n   struct debug_handle *info = (struct debug_handle *) handle;\n@@ -2327,42 +2327,42 @@ debug_write (void *handle, const struct debug_write_fns *fns, void *fhandle)\n   for (u = info->units; u != NULL; u = u->next)\n     {\n       struct debug_file *f;\n-      bfd_boolean first_file;\n+      bool first_file;\n \n       info->current_write_lineno = u->linenos;\n       info->current_write_lineno_index = 0;\n \n       if (! (*fns->start_compilation_unit) (fhandle, u->files->filename))\n-\treturn FALSE;\n+\treturn false;\n \n-      first_file = TRUE;\n+      first_file = true;\n       for (f = u->files; f != NULL; f = f->next)\n \t{\n \t  struct debug_name *n;\n \n \t  if (first_file)\n-\t    first_file = FALSE;\n+\t    first_file = false;\n \t  else if (! (*fns->start_source) (fhandle, f->filename))\n-\t    return FALSE;\n+\t    return false;\n \n \t  if (f->globals != NULL)\n \t    for (n = f->globals->list; n != NULL; n = n->next)\n \t      if (! debug_write_name (info, fns, fhandle, n))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t}\n \n       /* Output any line number information which hasn't already been\n          handled.  */\n       if (! debug_write_linenos (info, fns, fhandle, (bfd_vma) -1))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Write out an element in a namespace.  */\n \n-static bfd_boolean\n+static bool\n debug_write_name (struct debug_handle *info,\n \t\t  const struct debug_write_fns *fns, void *fhandle,\n \t\t  struct debug_name *n)\n@@ -2372,16 +2372,16 @@ debug_write_name (struct debug_handle *info,\n     case DEBUG_OBJECT_TYPE:\n       if (! debug_write_type (info, fns, fhandle, n->u.type, n)\n \t  || ! (*fns->typdef) (fhandle, n->name))\n-\treturn FALSE;\n-      return TRUE;\n+\treturn false;\n+      return true;\n     case DEBUG_OBJECT_TAG:\n       if (! debug_write_type (info, fns, fhandle, n->u.tag, n))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->tag) (fhandle, n->name);\n     case DEBUG_OBJECT_VARIABLE:\n       if (! debug_write_type (info, fns, fhandle, n->u.variable->type,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->variable) (fhandle, n->name, n->u.variable->kind,\n \t\t\t       n->u.variable->val);\n     case DEBUG_OBJECT_FUNCTION:\n@@ -2394,12 +2394,12 @@ debug_write_name (struct debug_handle *info,\n     case DEBUG_OBJECT_TYPED_CONSTANT:\n       if (! debug_write_type (info, fns, fhandle, n->u.typed_constant->type,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->typed_constant) (fhandle, n->name,\n \t\t\t\t     n->u.typed_constant->val);\n     default:\n       abort ();\n-      return FALSE;\n+      return false;\n     }\n   /*NOTREACHED*/\n }\n@@ -2410,7 +2410,7 @@ debug_write_name (struct debug_handle *info,\n    then the name argument is a tag from a DEBUG_KIND_TAGGED type which\n    points to this one.  */\n \n-static bfd_boolean\n+static bool\n debug_write_type (struct debug_handle *info,\n \t\t  const struct debug_write_fns *fns, void *fhandle,\n \t\t  struct debug_type_s *type, struct debug_name *name)\n@@ -2453,7 +2453,7 @@ debug_write_type (struct debug_handle *info,\n \t\t  if (! debug_set_class_id (info,\n \t\t\t\t\t    type->u.knamed->name->name,\n \t\t\t\t\t    real))\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t}\n \t      id = real->u.kclass->id;\n \t    }\n@@ -2482,7 +2482,7 @@ debug_write_type (struct debug_handle *info,\n     {\n     case DEBUG_KIND_ILLEGAL:\n       debug_error (_(\"debug_write_type: illegal type encountered\"));\n-      return FALSE;\n+      return false;\n     case DEBUG_KIND_INDIRECT:\n       return debug_write_type (info, fns, fhandle, *type->u.kindirect->slot,\n \t\t\t       name);\n@@ -2503,7 +2503,7 @@ debug_write_type (struct debug_handle *info,\n \t  if (type->u.kclass->id <= info->base_id)\n \t    {\n \t      if (! debug_set_class_id (info, tag, type))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \n \t  if (info->mark == type->u.kclass->mark)\n@@ -2524,7 +2524,7 @@ debug_write_type (struct debug_handle *info,\n \t\t\t\t\t: 0),\n \t\t\t\t       type->kind == DEBUG_KIND_STRUCT,\n \t\t\t\t       type->size))\n-\treturn FALSE;\n+\treturn false;\n       if (type->u.kclass != NULL\n \t  && type->u.kclass->fields != NULL)\n \t{\n@@ -2537,7 +2537,7 @@ debug_write_type (struct debug_handle *info,\n \t\t\t\t      (struct debug_name *) NULL)\n \t\t  || ! (*fns->struct_field) (fhandle, f->name, f->u.f.bitpos,\n \t\t\t\t\t     f->u.f.bitsize, f->visibility))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t}\n       return (*fns->end_struct_type) (fhandle);\n@@ -2553,13 +2553,13 @@ debug_write_type (struct debug_handle *info,\n     case DEBUG_KIND_POINTER:\n       if (! debug_write_type (info, fns, fhandle, type->u.kpointer,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->pointer_type) (fhandle);\n     case DEBUG_KIND_FUNCTION:\n       if (! debug_write_type (info, fns, fhandle,\n \t\t\t      type->u.kfunction->return_type,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       if (type->u.kfunction->arg_types == NULL)\n \tis = -1;\n       else\n@@ -2568,19 +2568,19 @@ debug_write_type (struct debug_handle *info,\n \t    if (! debug_write_type (info, fns, fhandle,\n \t\t\t\t    type->u.kfunction->arg_types[is],\n \t\t\t\t    (struct debug_name *) NULL))\n-\t      return FALSE;\n+\t      return false;\n \t}\n       return (*fns->function_type) (fhandle, is,\n \t\t\t\t    type->u.kfunction->varargs);\n     case DEBUG_KIND_REFERENCE:\n       if (! debug_write_type (info, fns, fhandle, type->u.kreference,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->reference_type) (fhandle);\n     case DEBUG_KIND_RANGE:\n       if (! debug_write_type (info, fns, fhandle, type->u.krange->type,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->range_type) (fhandle, type->u.krange->lower,\n \t\t\t\t type->u.krange->upper);\n     case DEBUG_KIND_ARRAY:\n@@ -2589,28 +2589,28 @@ debug_write_type (struct debug_handle *info,\n \t  || ! debug_write_type (info, fns, fhandle,\n \t\t\t\t type->u.karray->range_type,\n \t\t\t\t (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->array_type) (fhandle, type->u.karray->lower,\n \t\t\t\t type->u.karray->upper,\n \t\t\t\t type->u.karray->stringp);\n     case DEBUG_KIND_SET:\n       if (! debug_write_type (info, fns, fhandle, type->u.kset->type,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->set_type) (fhandle, type->u.kset->bitstringp);\n     case DEBUG_KIND_OFFSET:\n       if (! debug_write_type (info, fns, fhandle, type->u.koffset->base_type,\n \t\t\t      (struct debug_name *) NULL)\n \t  || ! debug_write_type (info, fns, fhandle,\n \t\t\t\t type->u.koffset->target_type,\n \t\t\t\t (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->offset_type) (fhandle);\n     case DEBUG_KIND_METHOD:\n       if (! debug_write_type (info, fns, fhandle,\n \t\t\t      type->u.kmethod->return_type,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       if (type->u.kmethod->arg_types == NULL)\n \tis = -1;\n       else\n@@ -2619,14 +2619,14 @@ debug_write_type (struct debug_handle *info,\n \t    if (! debug_write_type (info, fns, fhandle,\n \t\t\t\t    type->u.kmethod->arg_types[is],\n \t\t\t\t    (struct debug_name *) NULL))\n-\t      return FALSE;\n+\t      return false;\n \t}\n       if (type->u.kmethod->domain_type != NULL)\n \t{\n \t  if (! debug_write_type (info, fns, fhandle,\n \t\t\t\t  type->u.kmethod->domain_type,\n \t\t\t\t  (struct debug_name *) NULL))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       return (*fns->method_type) (fhandle,\n \t\t\t\t  type->u.kmethod->domain_type != NULL,\n@@ -2635,12 +2635,12 @@ debug_write_type (struct debug_handle *info,\n     case DEBUG_KIND_CONST:\n       if (! debug_write_type (info, fns, fhandle, type->u.kconst,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->const_type) (fhandle);\n     case DEBUG_KIND_VOLATILE:\n       if (! debug_write_type (info, fns, fhandle, type->u.kvolatile,\n \t\t\t      (struct debug_name *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       return (*fns->volatile_type) (fhandle);\n     case DEBUG_KIND_NAMED:\n       return debug_write_type (info, fns, fhandle, type->u.knamed->type,\n@@ -2650,13 +2650,13 @@ debug_write_type (struct debug_handle *info,\n \t\t\t       type->u.knamed->name);\n     default:\n       abort ();\n-      return FALSE;\n+      return false;\n     }\n }\n \n /* Write out a class type.  */\n \n-static bfd_boolean\n+static bool\n debug_write_class_type (struct debug_handle *info,\n \t\t\tconst struct debug_write_fns *fns, void *fhandle,\n \t\t\tstruct debug_type_s *type, const char *tag)\n@@ -2675,7 +2675,7 @@ debug_write_class_type (struct debug_handle *info,\n       if (type->u.kclass->id <= info->base_id)\n \t{\n \t  if (! debug_set_class_id (info, tag, type))\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n       if (info->mark == type->u.kclass->mark)\n@@ -2695,7 +2695,7 @@ debug_write_class_type (struct debug_handle *info,\n \t{\n \t  if (! debug_write_type (info, fns, fhandle, vptrbase,\n \t\t\t\t  (struct debug_name *) NULL))\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n@@ -2704,7 +2704,7 @@ debug_write_class_type (struct debug_handle *info,\n \t\t\t\t  type->size,\n \t\t\t\t  vptrbase != NULL,\n \t\t\t\t  vptrbase == type))\n-    return FALSE;\n+    return false;\n \n   if (type->u.kclass != NULL)\n     {\n@@ -2717,19 +2717,19 @@ debug_write_class_type (struct debug_handle *info,\n \t      f = type->u.kclass->fields[i];\n \t      if (! debug_write_type (info, fns, fhandle, f->type,\n \t\t\t\t      (struct debug_name *) NULL))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      if (f->static_member)\n \t\t{\n \t\t  if (! (*fns->class_static_member) (fhandle, f->name,\n \t\t\t\t\t\t     f->u.s.physname,\n \t\t\t\t\t\t     f->visibility))\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t}\n \t      else\n \t\t{\n \t\t  if (! (*fns->struct_field) (fhandle, f->name, f->u.f.bitpos,\n \t\t\t\t\t      f->u.f.bitsize, f->visibility))\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t}\n \t    }\n \t}\n@@ -2743,10 +2743,10 @@ debug_write_class_type (struct debug_handle *info,\n \t      b = type->u.kclass->baseclasses[i];\n \t      if (! debug_write_type (info, fns, fhandle, b->type,\n \t\t\t\t      (struct debug_name *) NULL))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      if (! (*fns->class_baseclass) (fhandle, b->bitpos, b->is_virtual,\n \t\t\t\t\t     b->visibility))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t}\n \n@@ -2759,7 +2759,7 @@ debug_write_class_type (struct debug_handle *info,\n \n \t      m = type->u.kclass->methods[i];\n \t      if (! (*fns->class_start_method) (fhandle, m->name))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      for (j = 0; m->variants[j] != NULL; j++)\n \t\t{\n \t\t  struct debug_method_variant_s *v;\n@@ -2769,11 +2769,11 @@ debug_write_class_type (struct debug_handle *info,\n \t\t    {\n \t\t      if (! debug_write_type (info, fns, fhandle, v->context,\n \t\t\t\t\t      (struct debug_name *) NULL))\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t    }\n \t\t  if (! debug_write_type (info, fns, fhandle, v->type,\n \t\t\t\t\t  (struct debug_name *) NULL))\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t  if (v->voffset != VOFFSET_STATIC_METHOD)\n \t\t    {\n \t\t      if (! (*fns->class_method_variant) (fhandle, v->physname,\n@@ -2782,7 +2782,7 @@ debug_write_class_type (struct debug_handle *info,\n \t\t\t\t\t\t\t  v->volatilep,\n \t\t\t\t\t\t\t  v->voffset,\n \t\t\t\t\t\t\t  v->context != NULL))\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -2791,11 +2791,11 @@ debug_write_class_type (struct debug_handle *info,\n \t\t\t\t\t\t\t\t v->visibility,\n \t\t\t\t\t\t\t\t v->constp,\n \t\t\t\t\t\t\t\t v->volatilep))\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t    }\n \t\t}\n \t      if (! (*fns->class_end_method) (fhandle))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t}\n     }\n@@ -2805,7 +2805,7 @@ debug_write_class_type (struct debug_handle *info,\n \n /* Write out information for a function.  */\n \n-static bfd_boolean\n+static bool\n debug_write_function (struct debug_handle *info,\n \t\t      const struct debug_write_fns *fns, void *fhandle,\n \t\t      const char *name, enum debug_object_linkage linkage,\n@@ -2815,36 +2815,36 @@ debug_write_function (struct debug_handle *info,\n   struct debug_block *b;\n \n   if (! debug_write_linenos (info, fns, fhandle, function->blocks->start))\n-    return FALSE;\n+    return false;\n \n   if (! debug_write_type (info, fns, fhandle, function->return_type,\n \t\t\t  (struct debug_name *) NULL))\n-    return FALSE;\n+    return false;\n \n   if (! (*fns->start_function) (fhandle, name,\n \t\t\t\tlinkage == DEBUG_LINKAGE_GLOBAL))\n-    return FALSE;\n+    return false;\n \n   for (p = function->parameters; p != NULL; p = p->next)\n     {\n       if (! debug_write_type (info, fns, fhandle, p->type,\n \t\t\t      (struct debug_name *) NULL)\n \t  || ! (*fns->function_parameter) (fhandle, p->name, p->kind, p->val))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   for (b = function->blocks; b != NULL; b = b->next)\n     {\n       if (! debug_write_block (info, fns, fhandle, b))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   return (*fns->end_function) (fhandle);\n }\n \n /* Write out information for a block.  */\n \n-static bfd_boolean\n+static bool\n debug_write_block (struct debug_handle *info,\n \t\t   const struct debug_write_fns *fns, void *fhandle,\n \t\t   struct debug_block *block)\n@@ -2853,46 +2853,46 @@ debug_write_block (struct debug_handle *info,\n   struct debug_block *b;\n \n   if (! debug_write_linenos (info, fns, fhandle, block->start))\n-    return FALSE;\n+    return false;\n \n   /* I can't see any point to writing out a block with no local\n      variables, so we don't bother, except for the top level block.  */\n   if (block->locals != NULL || block->parent == NULL)\n     {\n       if (! (*fns->start_block) (fhandle, block->start))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (block->locals != NULL)\n     {\n       for (n = block->locals->list; n != NULL; n = n->next)\n \t{\n \t  if (! debug_write_name (info, fns, fhandle, n))\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n   for (b = block->children; b != NULL; b = b->next)\n     {\n       if (! debug_write_block (info, fns, fhandle, b))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (! debug_write_linenos (info, fns, fhandle, block->end))\n-    return FALSE;\n+    return false;\n \n   if (block->locals != NULL || block->parent == NULL)\n     {\n       if (! (*fns->end_block) (fhandle, block->end))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Write out line number information up to ADDRESS.  */\n \n-static bfd_boolean\n+static bool\n debug_write_linenos (struct debug_handle *info,\n \t\t     const struct debug_write_fns *fns, void *fhandle,\n \t\t     bfd_vma address)\n@@ -2910,12 +2910,12 @@ debug_write_linenos (struct debug_handle *info,\n \t    break;\n \n \t  if (l->addrs[info->current_write_lineno_index] >= address)\n-\t    return TRUE;\n+\t    return true;\n \n \t  if (! (*fns->lineno) (fhandle, l->file->filename,\n \t\t\t\tl->linenos[info->current_write_lineno_index],\n \t\t\t\tl->addrs[info->current_write_lineno_index]))\n-\t    return FALSE;\n+\t    return false;\n \n \t  ++info->current_write_lineno_index;\n \t}\n@@ -2924,15 +2924,15 @@ debug_write_linenos (struct debug_handle *info,\n       info->current_write_lineno_index = 0;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Get the ID number for a class.  If during the same call to\n    debug_write we find a struct with the same definition with the same\n    name, we use the same ID.  This type of things happens because the\n    same struct will be defined by multiple compilation units.  */\n \n-static bfd_boolean\n+static bool\n debug_set_class_id (struct debug_handle *info, const char *tag,\n \t\t    struct debug_type_s *type)\n {\n@@ -2947,7 +2947,7 @@ debug_set_class_id (struct debug_handle *info, const char *tag,\n   c = type->u.kclass;\n \n   if (c->id > info->base_id)\n-    return TRUE;\n+    return true;\n \n   for (l = info->id_list; l != NULL; l = l->next)\n     {\n@@ -2970,7 +2970,7 @@ debug_set_class_id (struct debug_handle *info, const char *tag,\n       if (debug_type_samep (info, l->type, type))\n \t{\n \t  c->id = l->type->u.kclass->id;\n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n \n@@ -2988,40 +2988,40 @@ debug_set_class_id (struct debug_handle *info, const char *tag,\n   l->next = info->id_list;\n   info->id_list = l;\n \n-  return TRUE;\n+  return true;\n }\n \n /* See if two types are the same.  At this point, we don't care about\n    tags and the like.  */\n \n-static bfd_boolean\n+static bool\n debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t\t  struct debug_type_s *t2)\n {\n   struct debug_type_compare_list *l;\n   struct debug_type_compare_list top;\n-  bfd_boolean ret;\n+  bool ret;\n \n   if (t1 == NULL)\n     return t2 == NULL;\n   if (t2 == NULL)\n-    return FALSE;\n+    return false;\n \n   while (t1->kind == DEBUG_KIND_INDIRECT)\n     {\n       t1 = *t1->u.kindirect->slot;\n       if (t1 == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n   while (t2->kind == DEBUG_KIND_INDIRECT)\n     {\n       t2 = *t2->u.kindirect->slot;\n       if (t2 == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (t1 == t2)\n-    return TRUE;\n+    return true;\n \n   /* As a special case, permit a typedef to match a tag, since C++\n      debugging output will sometimes add a typedef where C debugging\n@@ -3035,7 +3035,7 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \n   if (t1->kind != t2->kind\n       || t1->size != t2->size)\n-    return FALSE;\n+    return false;\n \n   /* Get rid of the trivial cases first.  */\n   switch (t1->kind)\n@@ -3046,7 +3046,7 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n     case DEBUG_KIND_FLOAT:\n     case DEBUG_KIND_COMPLEX:\n     case DEBUG_KIND_BOOL:\n-      return TRUE;\n+      return true;\n     case DEBUG_KIND_INT:\n       return t1->u.kint == t2->u.kint;\n     }\n@@ -3058,7 +3058,7 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n   for (l = info->compare_list; l != NULL; l = l->next)\n     {\n       if (l->t1 == t1 && l->t2 == t2)\n-\treturn TRUE;\n+\treturn true;\n     }\n \n   top.t1 = t1;\n@@ -3070,7 +3070,7 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n     {\n     default:\n       abort ();\n-      ret = FALSE;\n+      ret = false;\n       break;\n \n     case DEBUG_KIND_STRUCT:\n@@ -3080,10 +3080,10 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n       if (t1->u.kclass == NULL)\n \tret = t2->u.kclass == NULL;\n       else if (t2->u.kclass == NULL)\n-\tret = FALSE;\n+\tret = false;\n       else if (t1->u.kclass->id > info->base_id\n \t       && t1->u.kclass->id == t2->u.kclass->id)\n-\tret = TRUE;\n+\tret = true;\n       else\n \tret = debug_class_type_samep (info, t1, t2);\n       break;\n@@ -3092,7 +3092,7 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n       if (t1->u.kenum == NULL)\n \tret = t2->u.kenum == NULL;\n       else if (t2->u.kenum == NULL)\n-\tret = FALSE;\n+\tret = false;\n       else\n \t{\n \t  const char **pn1, **pn2;\n@@ -3127,9 +3127,9 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t\t\t\t t2->u.kfunction->return_type)\n \t  || ((t1->u.kfunction->arg_types == NULL)\n \t      != (t2->u.kfunction->arg_types == NULL)))\n-\tret = FALSE;\n+\tret = false;\n       else if (t1->u.kfunction->arg_types == NULL)\n-\tret = TRUE;\n+\tret = true;\n       else\n \t{\n \t  struct debug_type_s **a1, **a2;\n@@ -3186,9 +3186,9 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t\t\t\t t2->u.kmethod->domain_type)\n \t  || ((t1->u.kmethod->arg_types == NULL)\n \t      != (t2->u.kmethod->arg_types == NULL)))\n-\tret = FALSE;\n+\tret = false;\n       else if (t1->u.kmethod->arg_types == NULL)\n-\tret = TRUE;\n+\tret = true;\n       else\n \t{\n \t  struct debug_type_s **a1, **a2;\n@@ -3230,7 +3230,7 @@ debug_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n /* See if two classes are the same.  This is a subroutine of\n    debug_type_samep.  */\n \n-static bfd_boolean\n+static bool\n debug_class_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t\t\tstruct debug_type_s *t2)\n {\n@@ -3243,7 +3243,7 @@ debug_class_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n       || (c1->baseclasses == NULL) != (c2->baseclasses == NULL)\n       || (c1->methods == NULL) != (c2->methods == NULL)\n       || (c1->vptrbase == NULL) != (c2->vptrbase == NULL))\n-    return FALSE;\n+    return false;\n \n   if (c1->fields != NULL)\n     {\n@@ -3260,17 +3260,17 @@ debug_class_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t  if (f1->name[0] != f2->name[0]\n \t      || f1->visibility != f2->visibility\n \t      || f1->static_member != f2->static_member)\n-\t    return FALSE;\n+\t    return false;\n \t  if (f1->static_member)\n \t    {\n \t      if (strcmp (f1->u.s.physname, f2->u.s.physname) != 0)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t  else\n \t    {\n \t      if (f1->u.f.bitpos != f2->u.f.bitpos\n \t\t  || f1->u.f.bitsize != f2->u.f.bitsize)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t  /* We do the checks which require function calls last.  We\n              don't require that the types of fields have the same\n@@ -3284,16 +3284,16 @@ debug_class_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t\t\t\t\t\t\t  f1->type, NULL),\n \t\t\t\t     debug_get_real_type ((void *) info,\n \t\t\t\t\t\t\t  f2->type, NULL)))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       if (*pf1 != NULL || *pf2 != NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (c1->vptrbase != NULL)\n     {\n       if (! debug_type_samep (info, c1->vptrbase, c2->vptrbase))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (c1->baseclasses != NULL)\n@@ -3312,10 +3312,10 @@ debug_class_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t      || b1->is_virtual != b2->is_virtual\n \t      || b1->visibility != b2->visibility\n \t      || ! debug_type_samep (info, b1->type, b2->type))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       if (*pb1 != NULL || *pb2 != NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (c1->methods != NULL)\n@@ -3333,7 +3333,7 @@ debug_class_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t  if (m1->name[0] != m2->name[0]\n \t      || strcmp (m1->name, m2->name) != 0\n \t      || (m1->variants == NULL) != (m2->variants == NULL))\n-\t    return FALSE;\n+\t    return false;\n \t  if (m1->variants == NULL)\n \t    {\n \t      struct debug_method_variant_s **pv1, **pv2;\n@@ -3354,21 +3354,21 @@ debug_class_type_samep (struct debug_handle *info, struct debug_type_s *t1,\n \t\t      || (v1->context == NULL) != (v2->context == NULL)\n \t\t      || strcmp (v1->physname, v2->physname) != 0\n \t\t      || ! debug_type_samep (info, v1->type, v2->type))\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t  if (v1->context != NULL)\n \t\t    {\n \t\t      if (! debug_type_samep (info, v1->context,\n \t\t\t\t\t      v2->context))\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t    }\n \t\t}\n \t      if (*pv1 != NULL || *pv2 != NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t}\n       if (*pm1 != NULL || *pm2 != NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "bac616b93ee001b3e324eef105eb77c4227778a0",
      "filename": "binutils/debug.h",
      "status": "modified",
      "additions": 89,
      "deletions": 92,
      "changes": 181,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/debug.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/debug.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/debug.h?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -169,45 +169,45 @@ struct debug_write_fns\n {\n   /* This is called at the start of each new compilation unit with the\n      name of the main file in the new unit.  */\n-  bfd_boolean (*start_compilation_unit) (void *, const char *);\n+  bool (*start_compilation_unit) (void *, const char *);\n \n   /* This is called at the start of each source file within a\n      compilation unit, before outputting any global information for\n      that file.  The argument is the name of the file.  */\n-  bfd_boolean (*start_source) (void *, const char *);\n+  bool (*start_source) (void *, const char *);\n \n   /* Each writer must keep a stack of types.  */\n \n   /* Push an empty type onto the type stack.  This type can appear if\n      there is a reference to a type which is never defined.  */\n-  bfd_boolean (*empty_type) (void *);\n+  bool (*empty_type) (void *);\n \n   /* Push a void type onto the type stack.  */\n-  bfd_boolean (*void_type) (void *);\n+  bool (*void_type) (void *);\n \n   /* Push an integer type onto the type stack, given the size and\n      whether it is unsigned.  */\n-  bfd_boolean (*int_type) (void *, unsigned int, bfd_boolean);\n+  bool (*int_type) (void *, unsigned int, bool);\n \n   /* Push a floating type onto the type stack, given the size.  */\n-  bfd_boolean (*float_type) (void *, unsigned int);\n+  bool (*float_type) (void *, unsigned int);\n \n   /* Push a complex type onto the type stack, given the size.  */\n-  bfd_boolean (*complex_type) (void *, unsigned int);\n+  bool (*complex_type) (void *, unsigned int);\n \n-  /* Push a bfd_boolean type onto the type stack, given the size.  */\n-  bfd_boolean (*bool_type) (void *, unsigned int);\n+  /* Push a bool type onto the type stack, given the size.  */\n+  bool (*bool_type) (void *, unsigned int);\n \n   /* Push an enum type onto the type stack, given the tag, a NULL\n      terminated array of names and the associated values.  If there is\n      no tag, the tag argument will be NULL.  If this is an undefined\n      enum, the names and values arguments will be NULL.  */\n-  bfd_boolean (*enum_type)\n+  bool (*enum_type)\n     (void *, const char *, const char **, bfd_signed_vma *);\n \n   /* Pop the top type on the type stack, and push a pointer to that\n      type onto the type stack.  */\n-  bfd_boolean (*pointer_type) (void *);\n+  bool (*pointer_type) (void *);\n \n   /* Push a function type onto the type stack.  The second argument\n      indicates the number of argument types that have been pushed onto\n@@ -217,34 +217,34 @@ struct debug_write_fns\n      function takes a variable number of arguments.  The return type\n      of the function is pushed onto the type stack below the argument\n      types, if any.  */\n-  bfd_boolean (*function_type) (void *, int, bfd_boolean);\n+  bool (*function_type) (void *, int, bool);\n \n   /* Pop the top type on the type stack, and push a reference to that\n      type onto the type stack.  */\n-  bfd_boolean (*reference_type) (void *);\n+  bool (*reference_type) (void *);\n \n   /* Pop the top type on the type stack, and push a range of that type\n      with the given lower and upper bounds onto the type stack.  */\n-  bfd_boolean (*range_type) (void *, bfd_signed_vma, bfd_signed_vma);\n+  bool (*range_type) (void *, bfd_signed_vma, bfd_signed_vma);\n \n   /* Push an array type onto the type stack.  The top type on the type\n      stack is the range, and the next type on the type stack is the\n      element type.  These should be popped before the array type is\n      pushed.  The arguments are the lower bound, the upper bound, and\n      whether the array is a string.  */\n-  bfd_boolean (*array_type)\n-    (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);\n+  bool (*array_type)\n+    (void *, bfd_signed_vma, bfd_signed_vma, bool);\n \n   /* Pop the top type on the type stack, and push a set of that type\n      onto the type stack.  The argument indicates whether this set is\n      a bitstring.  */\n-  bfd_boolean (*set_type) (void *, bfd_boolean);\n+  bool (*set_type) (void *, bool);\n \n   /* Push an offset type onto the type stack.  The top type on the\n      type stack is the target type, and the next type on the type\n      stack is the base type.  These should be popped before the offset\n      type is pushed.  */\n-  bfd_boolean (*offset_type) (void *);\n+  bool (*offset_type) (void *);\n \n   /* Push a method type onto the type stack.  If the second argument\n      is TRUE, the top type on the stack is the class to which the\n@@ -258,15 +258,15 @@ struct debug_write_fns\n      type on the type stack below the domain and the argument types is\n      the return type of the method.  All these types must be popped,\n      and then the method type must be pushed.  */\n-  bfd_boolean (*method_type) (void *, bfd_boolean, int, bfd_boolean);\n+  bool (*method_type) (void *, bool, int, bool);\n \n   /* Pop the top type off the type stack, and push a const qualified\n      version of that type onto the type stack.  */\n-  bfd_boolean (*const_type) (void *);\n+  bool (*const_type) (void *);\n \n   /* Pop the top type off the type stack, and push a volatile\n      qualified version of that type onto the type stack.  */\n-  bfd_boolean (*volatile_type) (void *);\n+  bool (*volatile_type) (void *);\n \n   /* Start building a struct.  This is followed by calls to the\n      struct_field function, and finished by a call to the\n@@ -277,18 +277,18 @@ struct debug_write_fns\n      for a union.  The fifth argument is the size.  If this is an\n      undefined struct or union, the size will be 0 and struct_field\n      will not be called before end_struct_type is called.  */\n-  bfd_boolean (*start_struct_type)\n-    (void *, const char *, unsigned int, bfd_boolean, unsigned int);\n+  bool (*start_struct_type)\n+    (void *, const char *, unsigned int, bool, unsigned int);\n \n   /* Add a field to the struct type currently being built.  The type\n      of the field should be popped off the type stack.  The arguments\n      are the name, the bit position, the bit size (may be zero if the\n      field is not packed), and the visibility.  */\n-  bfd_boolean (*struct_field)\n+  bool (*struct_field)\n     (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);\n \n   /* Finish building a struct, and push it onto the type stack.  */\n-  bfd_boolean (*end_struct_type) (void *);\n+  bool (*end_struct_type) (void *);\n \n   /* Start building a class.  This is followed by calls to several\n      functions: struct_field, class_static_member, class_baseclass,\n@@ -301,30 +301,29 @@ struct debug_write_fns\n      found in the type itself, and is FALSE if the type of the object\n      holding the virtual function table should be popped from the type\n      stack.  */\n-  bfd_boolean (*start_class_type)\n-    (void *, const char *, unsigned int, bfd_boolean, unsigned int,\n-     bfd_boolean, bfd_boolean);\n+  bool (*start_class_type)\n+    (void *, const char *, unsigned int, bool, unsigned int, bool, bool);\n \n   /* Add a static member to the class currently being built.  The\n      arguments are the field name, the physical name, and the\n      visibility.  The type must be popped off the type stack.  */\n-  bfd_boolean (*class_static_member)\n+  bool (*class_static_member)\n     (void *, const char *, const char *, enum debug_visibility);\n \n   /* Add a baseclass to the class currently being built.  The type of\n      the baseclass must be popped off the type stack.  The arguments\n      are the bit position, whether the class is virtual, and the\n      visibility.  */\n-  bfd_boolean (*class_baseclass)\n-    (void *, bfd_vma, bfd_boolean, enum debug_visibility);\n+  bool (*class_baseclass)\n+    (void *, bfd_vma, bool, enum debug_visibility);\n \n   /* Start adding a method to the class currently being built.  This\n      is followed by calls to class_method_variant and\n      class_static_method_variant to describe different variants of the\n      method which take different arguments.  The method is finished\n      with a call to class_end_method.  The argument is the method\n      name.  */\n-  bfd_boolean (*class_start_method) (void *, const char *);\n+  bool (*class_start_method) (void *, const char *);\n \n   /* Describe a variant to the class method currently being built.\n      The type of the variant must be popped off the type stack.  The\n@@ -333,27 +332,25 @@ struct debug_write_fns\n      const, whether the variant is volatile, the offset in the virtual\n      function table, and whether the context is on the type stack\n      (below the variant type).  */\n-  bfd_boolean (*class_method_variant)\n-    (void *, const char *, enum debug_visibility, bfd_boolean,\n-     bfd_boolean, bfd_vma, bfd_boolean);\n+  bool (*class_method_variant)\n+    (void *, const char *, enum debug_visibility, bool, bool, bfd_vma, bool);\n \n   /* Describe a static variant to the class method currently being\n      built.  The arguments are the same as for class_method_variant,\n      except that the last two arguments are omitted.  The type of the\n      variant must be popped off the type stack.  */\n-  bfd_boolean (*class_static_method_variant)\n-    (void *, const char *, enum debug_visibility, bfd_boolean,\n-     bfd_boolean);\n+  bool (*class_static_method_variant)\n+    (void *, const char *, enum debug_visibility, bool, bool);\n \n   /* Finish describing a class method.  */\n-  bfd_boolean (*class_end_method) (void *);\n+  bool (*class_end_method) (void *);\n \n   /* Finish describing a class, and push it onto the type stack.  */\n-  bfd_boolean (*end_class_type) (void *);\n+  bool (*end_class_type) (void *);\n \n   /* Push a type on the stack which was given a name by an earlier\n      call to typdef.  */\n-  bfd_boolean (*typedef_type) (void *, const char *);\n+  bool (*typedef_type) (void *, const char *);\n \n   /* Push a tagged type on the stack which was defined earlier.  If\n      the second argument is not NULL, the type was defined by a call\n@@ -364,58 +361,58 @@ struct debug_write_fns\n      for a struct (class) being defined, in between the call to\n      start_struct_type (start_class_type) and the call to\n      end_struct_type (end_class_type).  */\n-  bfd_boolean (*tag_type)\n+  bool (*tag_type)\n     (void *, const char *, unsigned int, enum debug_type_kind);\n \n   /* Pop the type stack, and typedef it to the given name.  */\n-  bfd_boolean (*typdef) (void *, const char *);\n+  bool (*typdef) (void *, const char *);\n \n   /* Pop the type stack, and declare it as a tagged struct or union or\n      enum or whatever.  The tag passed down here is redundant, since\n      was also passed when enum_type, start_struct_type, or\n      start_class_type was called.  */\n-  bfd_boolean (*tag) (void *, const char *);\n+  bool (*tag) (void *, const char *);\n \n   /* This is called to record a named integer constant.  */\n-  bfd_boolean (*int_constant) (void *, const char *, bfd_vma);\n+  bool (*int_constant) (void *, const char *, bfd_vma);\n \n   /* This is called to record a named floating point constant.  */\n-  bfd_boolean (*float_constant) (void *, const char *, double);\n+  bool (*float_constant) (void *, const char *, double);\n \n   /* This is called to record a typed integer constant.  The type is\n      popped off the type stack.  */\n-  bfd_boolean (*typed_constant) (void *, const char *, bfd_vma);\n+  bool (*typed_constant) (void *, const char *, bfd_vma);\n \n   /* This is called to record a variable.  The type is popped off the\n      type stack.  */\n-  bfd_boolean (*variable)\n+  bool (*variable)\n     (void *, const char *, enum debug_var_kind, bfd_vma);\n \n   /* Start writing out a function.  The return type must be popped off\n-     the stack.  The bfd_boolean is TRUE if the function is global.  This\n+     the stack.  The bool is TRUE if the function is global.  This\n      is followed by calls to function_parameter, followed by block\n      information.  */\n-  bfd_boolean (*start_function) (void *, const char *, bfd_boolean);\n+  bool (*start_function) (void *, const char *, bool);\n \n   /* Record a function parameter for the current function.  The type\n      must be popped off the stack.  */\n-  bfd_boolean (*function_parameter)\n+  bool (*function_parameter)\n     (void *, const char *, enum debug_parm_kind, bfd_vma);\n \n   /* Start writing out a block.  There is at least one top level block\n      per function.  Blocks may be nested.  The argument is the\n      starting address of the block.  */\n-  bfd_boolean (*start_block) (void *, bfd_vma);\n+  bool (*start_block) (void *, bfd_vma);\n \n   /* Finish writing out a block.  The argument is the ending address\n      of the block.  */\n-  bfd_boolean (*end_block) (void *, bfd_vma);\n+  bool (*end_block) (void *, bfd_vma);\n \n   /* Finish writing out a function.  */\n-  bfd_boolean (*end_function) (void *);\n+  bool (*end_function) (void *);\n \n   /* Record line number information for the current compilation unit.  */\n-  bfd_boolean (*lineno) (void *, const char *, unsigned long, bfd_vma);\n+  bool (*lineno) (void *, const char *, unsigned long, bfd_vma);\n };\n \n /* Exported functions.  */\n@@ -433,81 +430,81 @@ extern void *debug_init (void);\n /* Set the source filename.  This implicitly starts a new compilation\n    unit.  */\n \n-extern bfd_boolean debug_set_filename (void *, const char *);\n+extern bool debug_set_filename (void *, const char *);\n \n /* Change source files to the given file name.  This is used for\n    include files in a single compilation unit.  */\n \n-extern bfd_boolean debug_start_source (void *, const char *);\n+extern bool debug_start_source (void *, const char *);\n \n /* Record a function definition.  This implicitly starts a function\n    block.  The debug_type argument is the type of the return value.\n-   The bfd_boolean indicates whether the function is globally visible.\n+   The bool indicates whether the function is globally visible.\n    The bfd_vma is the address of the start of the function.  Currently\n    the parameter types are specified by calls to\n    debug_record_parameter.  */\n \n-extern bfd_boolean debug_record_function\n-  (void *, const char *, debug_type, bfd_boolean, bfd_vma);\n+extern bool debug_record_function\n+  (void *, const char *, debug_type, bool, bfd_vma);\n \n /* Record a parameter for the current function.  */\n \n-extern bfd_boolean debug_record_parameter\n+extern bool debug_record_parameter\n   (void *, const char *, debug_type, enum debug_parm_kind, bfd_vma);\n \n /* End a function definition.  The argument is the address where the\n    function ends.  */\n \n-extern bfd_boolean debug_end_function (void *, bfd_vma);\n+extern bool debug_end_function (void *, bfd_vma);\n \n /* Start a block in a function.  All local information will be\n    recorded in this block, until the matching call to debug_end_block.\n    debug_start_block and debug_end_block may be nested.  The argument\n    is the address at which this block starts.  */\n \n-extern bfd_boolean debug_start_block (void *, bfd_vma);\n+extern bool debug_start_block (void *, bfd_vma);\n \n /* Finish a block in a function.  This matches the call to\n    debug_start_block.  The argument is the address at which this block\n    ends.  */\n \n-extern bfd_boolean debug_end_block (void *, bfd_vma);\n+extern bool debug_end_block (void *, bfd_vma);\n \n /* Associate a line number in the current source file with a given\n    address.  */\n \n-extern bfd_boolean debug_record_line (void *, unsigned long, bfd_vma);\n+extern bool debug_record_line (void *, unsigned long, bfd_vma);\n \n /* Start a named common block.  This is a block of variables that may\n    move in memory.  */\n \n-extern bfd_boolean debug_start_common_block (void *, const char *);\n+extern bool debug_start_common_block (void *, const char *);\n \n /* End a named common block.  */\n \n-extern bfd_boolean debug_end_common_block (void *, const char *);\n+extern bool debug_end_common_block (void *, const char *);\n \n /* Record a named integer constant.  */\n \n-extern bfd_boolean debug_record_int_const (void *, const char *, bfd_vma);\n+extern bool debug_record_int_const (void *, const char *, bfd_vma);\n \n /* Record a named floating point constant.  */\n \n-extern bfd_boolean debug_record_float_const (void *, const char *, double);\n+extern bool debug_record_float_const (void *, const char *, double);\n \n /* Record a typed constant with an integral value.  */\n \n-extern bfd_boolean debug_record_typed_const\n+extern bool debug_record_typed_const\n   (void *, const char *, debug_type, bfd_vma);\n \n /* Record a label.  */\n \n-extern bfd_boolean debug_record_label\n+extern bool debug_record_label\n   (void *, const char *, debug_type, bfd_vma);\n \n /* Record a variable.  */\n \n-extern bfd_boolean debug_record_variable\n+extern bool debug_record_variable\n   (void *, const char *, debug_type, enum debug_var_kind, bfd_vma);\n \n /* Make an indirect type.  The first argument is a pointer to the\n@@ -524,10 +521,10 @@ extern debug_type debug_make_indirect_type\n \n extern debug_type debug_make_void_type (void *);\n \n-/* Make an integer type of a given size.  The bfd_boolean argument is TRUE\n+/* Make an integer type of a given size.  The bool argument is TRUE\n    if the integer is unsigned.  */\n \n-extern debug_type debug_make_int_type (void *, unsigned int, bfd_boolean);\n+extern debug_type debug_make_int_type (void *, unsigned int, bool);\n \n /* Make a floating point type of a given size.  FIXME: On some\n    platforms, like an Alpha, you probably need to be able to specify\n@@ -548,18 +545,18 @@ extern debug_type debug_make_complex_type (void *, unsigned int);\n    The fourth argument is a NULL terminated array of fields.  */\n \n extern debug_type debug_make_struct_type\n-  (void *, bfd_boolean, bfd_vma, debug_field *);\n+  (void *, bool, bfd_vma, debug_field *);\n \n /* Make an object type.  The first three arguments after the handle\n    are the same as for debug_make_struct_type.  The next arguments are\n    a NULL terminated array of base classes, a NULL terminated array of\n    methods, the type of the object holding the virtual function table\n-   if it is not this object, and a bfd_boolean which is TRUE if this\n+   if it is not this object, and a bool which is TRUE if this\n    object has its own virtual function table.  */\n \n extern debug_type debug_make_object_type\n-  (void *, bfd_boolean, bfd_vma, debug_field *, debug_baseclass *,\n-   debug_method *, debug_type, bfd_boolean);\n+  (void *, bool, bfd_vma, debug_field *, debug_baseclass *,\n+   debug_method *, debug_type, bool);\n \n /* Make an enumeration type.  The arguments are a null terminated\n    array of strings, and an array of corresponding values.  */\n@@ -578,7 +575,7 @@ extern debug_type debug_make_pointer_type (void *, debug_type);\n    are unknown.  */\n \n extern debug_type debug_make_function_type\n-  (void *, debug_type, debug_type *, bfd_boolean);\n+  (void *, debug_type, debug_type *, bool);\n \n /* Make a reference to a given type.  */\n \n@@ -598,13 +595,13 @@ extern debug_type debug_make_range_type\n \n extern debug_type debug_make_array_type\n   (void *, debug_type, debug_type, bfd_signed_vma, bfd_signed_vma,\n-   bfd_boolean);\n+   bool);\n \n /* Make a set of a given type.  For example, a Pascal set type.  The\n-   bfd_boolean argument is TRUE if this set is actually a bitstring, as in\n+   bool argument is TRUE if this set is actually a bitstring, as in\n    CHILL.  */\n \n-extern debug_type debug_make_set_type (void *, debug_type, bfd_boolean);\n+extern debug_type debug_make_set_type (void *, debug_type, bool);\n \n /* Make a type for a pointer which is relative to an object.  The\n    second argument is the type of the object to which the pointer is\n@@ -624,7 +621,7 @@ extern debug_type debug_make_offset_type (void *, debug_type, debug_type);\n    the argument types from the mangled name.  */\n \n extern debug_type debug_make_method_type\n-  (void *, debug_type, debug_type, debug_type *, bfd_boolean);\n+  (void *, debug_type, debug_type, debug_type *, bool);\n \n /* Make a const qualified version of a given type.  */\n \n@@ -647,7 +644,7 @@ extern debug_type debug_make_undefined_tagged_type\n    class.  */\n \n extern debug_baseclass debug_make_baseclass\n-  (void *, debug_type, bfd_vma, bfd_boolean, enum debug_visibility);\n+  (void *, debug_type, bfd_vma, bool, enum debug_visibility);\n \n /* Make a field for a struct.  The second argument is the name.  The\n    third argument is the type of the field.  The fourth argument is\n@@ -685,16 +682,16 @@ extern debug_method debug_make_method\n    function context.  */\n \n extern debug_method_variant debug_make_method_variant\n-  (void *, const char *, debug_type, enum debug_visibility, bfd_boolean,\n-   bfd_boolean, bfd_vma, debug_type);\n+  (void *, const char *, debug_type, enum debug_visibility, bool,\n+   bool, bfd_vma, debug_type);\n \n /* Make a static method argument.  The arguments are the same as for\n    debug_make_method_variant, except that the last two are omitted\n    since a static method can not also be virtual.  */\n \n extern debug_method_variant debug_make_static_method_variant\n-  (void *, const char *, debug_type, enum debug_visibility, bfd_boolean,\n-   bfd_boolean);\n+  (void *, const char *, debug_type, enum debug_visibility, bool,\n+   bool);\n \n /* Name a type.  This returns a new type with an attached name.  */\n \n@@ -707,7 +704,7 @@ extern debug_type debug_tag_type (void *, const char *, debug_type);\n \n /* Record the size of a given type.  */\n \n-extern bfd_boolean debug_record_type_size (void *, debug_type, unsigned int);\n+extern bool debug_record_type_size (void *, debug_type, unsigned int);\n \n /* Find a named type.  */\n \n@@ -738,11 +735,11 @@ extern debug_type debug_get_return_type (void *, debug_type);\n    method type (actually, parameter types are not currently stored for\n    function types).  This may be used to determine whether a method\n    type is a stub method or not.  The last argument points to a\n-   bfd_boolean which is set to TRUE if the function takes a variable\n+   bool which is set to TRUE if the function takes a variable\n    number of arguments.  */\n \n extern const debug_type *debug_get_parameter_types\n-  (void *, debug_type, bfd_boolean *);\n+  (void *, debug_type, bool *);\n \n /* Get the target type of a pointer or reference or const or volatile\n    type.  */\n@@ -786,7 +783,7 @@ extern const char *debug_get_field_physname (void *, debug_field);\n    first void * is the debugging handle.  The second void * is a handle\n    which is passed to the functions.  */\n \n-extern bfd_boolean debug_write\n+extern bool debug_write\n   (void *, const struct debug_write_fns *, void *);\n \n #endif /* DEBUG_H */"
    },
    {
      "sha": "b26c17852e3ea146c2491a87ff056b9c2288eb81",
      "filename": "binutils/dlltool.c",
      "status": "modified",
      "additions": 43,
      "deletions": 43,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/dlltool.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/dlltool.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dlltool.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -355,7 +355,7 @@ static char *exp_name;\n static char *imp_name;\n static char *delayimp_name;\n static char *identify_imp_name;\n-static bfd_boolean identify_strict;\n+static bool identify_strict;\n \n /* Types used to implement a linked list of dllnames associated\n    with the specified import lib. Used by the identify_* code.\n@@ -376,14 +376,14 @@ typedef struct dll_name_list_t\n /* Types used to pass data to iterator functions.  */\n typedef struct symname_search_data_t\n {\n-  const char * symname;\n-  bfd_boolean  found;\n+  const char *symname;\n+  bool found;\n } symname_search_data_type;\n \n typedef struct identify_data_t\n {\n-   dll_name_list_type * list;\n-   bfd_boolean          ms_style_implib;\n+   dll_name_list_type *list;\n+   bool ms_style_implib;\n } identify_data_type;\n \n \n@@ -403,23 +403,23 @@ static int dontdeltemps = 0;\n \n /* TRUE if we should export all symbols.  Otherwise, we only export\n    symbols listed in .drectve sections or in the def file.  */\n-static bfd_boolean export_all_symbols;\n+static bool export_all_symbols;\n \n /* TRUE if we should exclude the symbols in DEFAULT_EXCLUDES when\n    exporting all symbols.  */\n-static bfd_boolean do_default_excludes = TRUE;\n+static bool do_default_excludes = true;\n \n-static bfd_boolean use_nul_prefixed_import_tables = FALSE;\n+static bool use_nul_prefixed_import_tables = false;\n \n /* Default symbols to exclude when exporting all the symbols.  */\n static const char *default_excludes = \"DllMain@12,DllEntryPoint@0,impure_ptr\";\n \n /* TRUE if we should add __imp_<SYMBOL> to import libraries for backward\n    compatibility to old Cygwin releases.  */\n-static bfd_boolean create_compat_implib;\n+static bool create_compat_implib;\n \n /* TRUE if we have to write PE+ import libraries.  */\n-static bfd_boolean create_for_pep;\n+static bool create_for_pep;\n \n static char *def_file;\n \n@@ -611,7 +611,7 @@ struct mac\n   int how_dljtab_roff1; /* Offset for the ind 32 reloc into idata 5.  */\n   int how_dljtab_roff2; /* Offset for the ind 32 reloc into idata 5.  */\n   int how_dljtab_roff3; /* Offset for the ind 32 reloc into idata 5.  */\n-  bfd_boolean how_seh;\n+  bool how_seh;\n   const char *trampoline;\n };\n \n@@ -625,7 +625,7 @@ mtable[] =\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-mapcs-32\",\n     \"pe-arm-little\", bfd_arch_arm,\n     arm_jtab, sizeof (arm_jtab), 8,\n-    0, 0, 0, 0, 0, FALSE, 0\n+    0, 0, 0, 0, 0, false, 0\n   }\n   ,\n   {\n@@ -634,7 +634,7 @@ mtable[] =\n     \"jmp *\", \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"\",\n     \"pe-i386\",bfd_arch_i386,\n     i386_jtab, sizeof (i386_jtab), 2,\n-    i386_dljtab, sizeof (i386_dljtab), 2, 7, 12, FALSE, i386_trampoline\n+    i386_dljtab, sizeof (i386_dljtab), 2, 7, 12, false, i386_trampoline\n   }\n   ,\n   {\n@@ -644,7 +644,7 @@ mtable[] =\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-mthumb-interwork\",\n     \"pe-arm-little\", bfd_arch_arm,\n     thumb_jtab, sizeof (thumb_jtab), 12,\n-    0, 0, 0, 0, 0, FALSE, 0\n+    0, 0, 0, 0, 0, false, 0\n   }\n   ,\n #define MARM_INTERWORK 3\n@@ -654,7 +654,7 @@ mtable[] =\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-mthumb-interwork\",\n     \"pe-arm-little\", bfd_arch_arm,\n     arm_interwork_jtab, sizeof (arm_interwork_jtab), 12,\n-    0, 0, 0, 0, 0, FALSE, 0\n+    0, 0, 0, 0, 0, false, 0\n   }\n   ,\n   {\n@@ -664,7 +664,7 @@ mtable[] =\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"\",\n     \"pe-mcore-big\", bfd_arch_mcore,\n     mcore_be_jtab, sizeof (mcore_be_jtab), 8,\n-    0, 0, 0, 0, 0, FALSE, 0\n+    0, 0, 0, 0, 0, false, 0\n   }\n   ,\n   {\n@@ -674,7 +674,7 @@ mtable[] =\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-EL\",\n     \"pe-mcore-little\", bfd_arch_mcore,\n     mcore_le_jtab, sizeof (mcore_le_jtab), 8,\n-    0, 0, 0, 0, 0, FALSE, 0\n+    0, 0, 0, 0, 0, false, 0\n   }\n   ,\n   {\n@@ -684,7 +684,7 @@ mtable[] =\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"\",\n     \"elf32-mcore-big\", bfd_arch_mcore,\n     mcore_be_jtab, sizeof (mcore_be_jtab), 8,\n-    0, 0, 0, 0, 0, FALSE, 0\n+    0, 0, 0, 0, 0, false, 0\n   }\n   ,\n   {\n@@ -694,7 +694,7 @@ mtable[] =\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-EL\",\n     \"elf32-mcore-little\", bfd_arch_mcore,\n     mcore_le_jtab, sizeof (mcore_le_jtab), 8,\n-    0, 0, 0, 0, 0, FALSE, 0\n+    0, 0, 0, 0, 0, false, 0\n   }\n   ,\n   {\n@@ -704,7 +704,7 @@ mtable[] =\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-mapcs-32\",\n     \"pe-arm-wince-little\", bfd_arch_arm,\n     arm_jtab, sizeof (arm_jtab), 8,\n-    0, 0, 0, 0, 0, FALSE, 0\n+    0, 0, 0, 0, 0, false, 0\n   }\n   ,\n   {\n@@ -713,7 +713,7 @@ mtable[] =\n     \"jmp *\", \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"\",\n     \"pe-x86-64\",bfd_arch_i386,\n     i386_jtab, sizeof (i386_jtab), 2,\n-    i386_x64_dljtab, sizeof (i386_x64_dljtab), 2, 9, 14, TRUE, i386_x64_trampoline\n+    i386_x64_dljtab, sizeof (i386_x64_dljtab), 2, 9, 14, true, i386_x64_trampoline\n   }\n   ,\n   { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }\n@@ -762,7 +762,7 @@ static void run (const char *, char *);\n static void scan_drectve_symbols (bfd *);\n static void scan_filtered_symbols (bfd *, void *, long, unsigned int);\n static void add_excludes (const char *);\n-static bfd_boolean match_exclude (const char *);\n+static bool match_exclude (const char *);\n static void set_default_excludes (void);\n static long filter_symbols (bfd *, void *, long, unsigned int);\n static void scan_all_symbols (bfd *);\n@@ -793,7 +793,7 @@ static void identify_dll_for_implib (void);\n static void identify_search_archive\n   (bfd *, void (*) (bfd *, bfd *, void *),  void *);\n static void identify_search_member (bfd *, bfd *, void *);\n-static bfd_boolean identify_process_section_p (asection *, bfd_boolean);\n+static bool identify_process_section_p (asection *, bool);\n static void identify_search_section (bfd *, asection *, void *);\n static void identify_member_contains_symname (bfd *, bfd  *, void *);\n \n@@ -1445,7 +1445,7 @@ scan_filtered_symbols (bfd *abfd, void *minisyms, long symcount,\n       asymbol *sym;\n       const char *symbol_name;\n \n-      sym = bfd_minisymbol_to_symbol (abfd, FALSE, from, store);\n+      sym = bfd_minisymbol_to_symbol (abfd, false, from, store);\n       if (sym == NULL)\n \tbfd_fatal (bfd_get_filename (abfd));\n \n@@ -1504,15 +1504,15 @@ add_excludes (const char *new_excludes)\n \n /* See if STRING is on the list of symbols to exclude.  */\n \n-static bfd_boolean\n+static bool\n match_exclude (const char *string)\n {\n   struct string_list *excl_item;\n \n   for (excl_item = excludes; excl_item; excl_item = excl_item->next)\n     if (strcmp (string, excl_item->string) == 0)\n-      return TRUE;\n-  return FALSE;\n+      return true;\n+  return false;\n }\n \n /* Add the default list of symbols to exclude.  */\n@@ -1544,7 +1544,7 @@ filter_symbols (bfd *abfd, void *minisyms, long symcount, unsigned int size)\n       int keep = 0;\n       asymbol *sym;\n \n-      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const void *) from, store);\n+      sym = bfd_minisymbol_to_symbol (abfd, false, (const void *) from, store);\n       if (sym == NULL)\n \tbfd_fatal (bfd_get_filename (abfd));\n \n@@ -1589,7 +1589,7 @@ scan_all_symbols (bfd *abfd)\n       return;\n     }\n \n-  symcount = bfd_read_minisymbols (abfd, FALSE, &minisyms, &size);\n+  symcount = bfd_read_minisymbols (abfd, false, &minisyms, &size);\n   if (symcount < 0)\n     bfd_fatal (bfd_get_filename (abfd));\n \n@@ -3195,7 +3195,7 @@ identify_member_contains_symname (bfd  * abfd,\n                    search_data->symname,\n                    strlen (search_data->symname)) == 0)\n \t{\n-\t  search_data->found = TRUE;\n+\t  search_data->found = true;\n \t  break;\n \t}\n     }\n@@ -3229,11 +3229,11 @@ identify_dll_for_implib (void)\n \n   /* Initialize identify_data.  */\n   identify_data.list = dll_name_list_create ();\n-  identify_data.ms_style_implib = FALSE;\n+  identify_data.ms_style_implib = false;\n \n   /* Initialize search_data.  */\n   search_data.symname = \"__NULL_IMPORT_DESCRIPTOR\";\n-  search_data.found = FALSE;\n+  search_data.found = false;\n \n   if (bfd_init () != BFD_INIT_MAGIC)\n     fatal (_(\"fatal error: libbfd ABI mismatch\"));\n@@ -3257,7 +3257,7 @@ identify_dll_for_implib (void)\n \t\t\t   identify_member_contains_symname,\n \t\t\t   (void *)(& search_data));\n   if (search_data.found)\n-    identify_data.ms_style_implib = TRUE;\n+    identify_data.ms_style_implib = true;\n \n   /* Rewind the bfd.  */\n   if (! bfd_close (abfd))\n@@ -3372,8 +3372,8 @@ identify_search_member (bfd  *abfd,\n    By default, this is .idata$7 (.idata$6 if the import library is\n    ms-style).  */\n \n-static bfd_boolean\n-identify_process_section_p (asection * section, bfd_boolean ms_style_implib)\n+static bool\n+identify_process_section_p (asection * section, bool ms_style_implib)\n {\n   static const char * SECTION_NAME = \".idata$7\";\n   static const char * MS_SECTION_NAME = \".idata$6\";\n@@ -3382,8 +3382,8 @@ identify_process_section_p (asection * section, bfd_boolean ms_style_implib)\n     (ms_style_implib ? MS_SECTION_NAME : SECTION_NAME);\n \n   if (strcmp (section_name, section->name) == 0)\n-    return TRUE;\n-  return FALSE;\n+    return true;\n+  return false;\n }\n \n /* If *section has contents and its name is .idata$7 (.idata$6 if\n@@ -3396,7 +3396,7 @@ identify_search_section (bfd * abfd, asection * section, void * obj)\n   bfd_byte *data = 0;\n   bfd_size_type datasize;\n   identify_data_type * identify_data = (identify_data_type *)obj;\n-  bfd_boolean ms_style = identify_data->ms_style_implib;\n+  bool ms_style = identify_data->ms_style_implib;\n \n   if ((section->flags & SEC_HAS_CONTENTS) == 0)\n     return;\n@@ -3803,19 +3803,19 @@ main (int ac, char **av)\n       switch (c)\n \t{\n \tcase OPTION_EXPORT_ALL_SYMS:\n-\t  export_all_symbols = TRUE;\n+\t  export_all_symbols = true;\n \t  break;\n \tcase OPTION_NO_EXPORT_ALL_SYMS:\n-\t  export_all_symbols = FALSE;\n+\t  export_all_symbols = false;\n \t  break;\n \tcase OPTION_EXCLUDE_SYMS:\n \t  add_excludes (optarg);\n \t  break;\n \tcase OPTION_NO_DEFAULT_EXCLUDES:\n-\t  do_default_excludes = FALSE;\n+\t  do_default_excludes = false;\n \t  break;\n \tcase OPTION_USE_NUL_PREFIXED_IMPORT_TABLES:\n-\t  use_nul_prefixed_import_tables = TRUE;\n+\t  use_nul_prefixed_import_tables = true;\n \t  break;\n \tcase OPTION_ADD_STDCALL_UNDERSCORE:\n \t  add_stdcall_underscore = 1;\n@@ -3980,7 +3980,7 @@ main (int ac, char **av)\n      symbols in the .drectve section.  The default excludes are meant\n      to avoid exporting DLL entry point and Cygwin32 impure_ptr.  */\n   if (! export_all_symbols)\n-    do_default_excludes = FALSE;\n+    do_default_excludes = false;\n \n   if (do_default_excludes)\n     set_default_excludes ();"
    },
    {
      "sha": "a8b65621b19d2abaadbb39f4012d1ac433fa98f0",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 180,
      "deletions": 180,
      "changes": 360,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -78,8 +78,8 @@ typedef struct dwo_info\n   struct dwo_info * next;\n } dwo_info;\n \n-static dwo_info *   first_dwo_info = NULL;\n-static bfd_boolean  need_dwo_info;\n+static dwo_info *first_dwo_info = NULL;\n+static bool need_dwo_info;\n \n separate_info * first_separate_info = NULL;\n \n@@ -107,7 +107,7 @@ int do_debug_cu_index;\n int do_wide;\n int do_debug_links;\n int do_follow_links = DEFAULT_FOR_FOLLOW_LINKS;\n-bfd_boolean do_checks;\n+bool do_checks;\n \n int dwarf_cutoff_level = -1;\n unsigned long dwarf_start_die;\n@@ -145,13 +145,13 @@ static int tu_count = 0;\n static struct cu_tu_set *cu_sets = NULL;\n static struct cu_tu_set *tu_sets = NULL;\n \n-static bfd_boolean load_cu_tu_indexes (void *);\n+static bool load_cu_tu_indexes (void *);\n \n /* An array that indicates for a given level of CU nesting whether\n    the latest DW_AT_type seen for that level was a signed type or\n    an unsigned type.  */\n #define MAX_CU_NESTING (1 << 8)\n-static bfd_boolean level_type_signed[MAX_CU_NESTING];\n+static bool level_type_signed[MAX_CU_NESTING];\n \n /* Values for do_debug_lines.  */\n #define FLAG_DEBUG_LINES_RAW\t 1\n@@ -341,7 +341,7 @@ dwarf_vmatoa64 (dwarf_vma hvalue, dwarf_vma lvalue, char *buf,\n dwarf_vma\n read_leb128 (unsigned char *data,\n \t     const unsigned char *const end,\n-\t     bfd_boolean sign,\n+\t     bool sign,\n \t     unsigned int *length_return,\n \t     int *status_return)\n {\n@@ -737,7 +737,7 @@ fetch_indirect_line_string (dwarf_vma offset)\n \n static const char *\n fetch_indexed_string (dwarf_vma idx, struct cu_tu_set *this_set,\n-\t\t      dwarf_vma offset_size, bfd_boolean dwo)\n+\t\t      dwarf_vma offset_size, bool dwo)\n {\n   enum dwarf_section_display_enum str_sec_idx = dwo ? str_dwo : str;\n   enum dwarf_section_display_enum idx_sec_idx = dwo ? str_index_dwo : str_index;\n@@ -2214,20 +2214,20 @@ get_type_abbrev_from_form (unsigned long                 form,\n    found starting at DATA.  */\n \n static void\n-get_type_signedness (abbrev_entry *         entry,\n-\t\t     const struct dwarf_section * section,\n-\t\t     unsigned char *        data,\n-\t\t     unsigned const char *  end,\n-\t\t     dwarf_vma              cu_offset,\n-\t\t     dwarf_vma              pointer_size,\n-\t\t     dwarf_vma              offset_size,\n-\t\t     int                    dwarf_version,\n-\t\t     bfd_boolean *          is_signed,\n-\t\t     unsigned int\t    nesting)\n+get_type_signedness (abbrev_entry *entry,\n+\t\t     const struct dwarf_section *section,\n+\t\t     unsigned char *data,\n+\t\t     unsigned const char *end,\n+\t\t     dwarf_vma cu_offset,\n+\t\t     dwarf_vma pointer_size,\n+\t\t     dwarf_vma offset_size,\n+\t\t     int dwarf_version,\n+\t\t     bool *is_signed,\n+\t\t     unsigned int nesting)\n {\n   abbrev_attr *   attr;\n \n-  * is_signed = FALSE;\n+  * is_signed = false;\n \n #define MAX_NESTING 20\n   if (nesting > MAX_NESTING)\n@@ -2295,7 +2295,7 @@ get_type_signedness (abbrev_entry *         entry,\n \t    case DW_ATE_unsigned:\n \t    case DW_ATE_unsigned_char:\n \t    case DW_ATE_unsigned_fixed:\n-\t      * is_signed = FALSE;\n+\t      * is_signed = false;\n \t      break;\n \n \t    default:\n@@ -2306,7 +2306,7 @@ get_type_signedness (abbrev_entry *         entry,\n \t    case DW_ATE_imaginary_float:\n \t    case DW_ATE_decimal_float:\n \t    case DW_ATE_signed_fixed:\n-\t      * is_signed = TRUE;\n+\t      * is_signed = true;\n \t      break;\n \t    }\n \t  break;\n@@ -2315,10 +2315,10 @@ get_type_signedness (abbrev_entry *         entry,\n }\n \n static void\n-read_and_print_leb128 (unsigned char *        data,\n-\t\t       unsigned int *         bytes_read,\n-\t\t       unsigned const char *  end,\n-\t\t       bfd_boolean            is_signed)\n+read_and_print_leb128 (unsigned char *data,\n+\t\t       unsigned int *bytes_read,\n+\t\t       unsigned const char *end,\n+\t\t       bool is_signed)\n {\n   int status;\n   dwarf_vma val = read_leb128 (data, end, is_signed, bytes_read, &status);\n@@ -2363,9 +2363,9 @@ display_discr_list (unsigned long          form,\n       return;\n     }\n \n-  bfd_boolean is_signed =\n+  bool is_signed =\n     (level > 0 && level <= MAX_CU_NESTING)\n-    ? level_type_signed [level - 1] : FALSE;\n+    ? level_type_signed [level - 1] : false;\n \n   printf (\"(\");\n   while (uvalue)\n@@ -2728,7 +2728,7 @@ read_and_display_attr_value (unsigned long           attribute,\n       if (!do_loc)\n \t{\n \t  const char *suffix = strrchr (section->name, '.');\n-\t  bfd_boolean dwo = suffix && strcmp (suffix, \".dwo\") == 0;\n+\t  bool dwo = suffix && strcmp (suffix, \".dwo\") == 0;\n \n \t  if (do_wide)\n \t    /* We have already displayed the form name.  */\n@@ -2953,7 +2953,7 @@ read_and_display_attr_value (unsigned long           attribute,\n \t      case DW_FORM_strx2:\n \t      case DW_FORM_strx3:\n \t      case DW_FORM_strx4:\n-\t\tadd_dwo_name (fetch_indexed_string (uvalue, this_set, offset_size, FALSE), cu_offset);\n+\t\tadd_dwo_name (fetch_indexed_string (uvalue, this_set, offset_size, false), cu_offset);\n \t\tbreak;\n \t      case DW_FORM_string:\n \t\tadd_dwo_name ((const char *) orig_data, cu_offset);\n@@ -2985,7 +2985,7 @@ read_and_display_attr_value (unsigned long           attribute,\n \t      case DW_FORM_strx2:\n \t      case DW_FORM_strx3:\n \t      case DW_FORM_strx4:\n-\t\tadd_dwo_dir (fetch_indexed_string (uvalue, this_set, offset_size, FALSE), cu_offset);\n+\t\tadd_dwo_dir (fetch_indexed_string (uvalue, this_set, offset_size, false), cu_offset);\n \t\tbreak;\n \t      case DW_FORM_string:\n \t\tadd_dwo_dir ((const char *) orig_data, cu_offset);\n@@ -3027,10 +3027,10 @@ read_and_display_attr_value (unsigned long           attribute,\n       if (level >= 0 && level < MAX_CU_NESTING\n \t  && uvalue < (size_t) (end - start))\n \t{\n-\t  bfd_boolean is_signed = FALSE;\n-\t  abbrev_entry *  type_abbrev;\n-\t  unsigned char * type_data;\n-\t  unsigned long   type_cu_offset;\n+\t  bool is_signed = false;\n+\t  abbrev_entry *type_abbrev;\n+\t  unsigned char *type_data;\n+\t  unsigned long type_cu_offset;\n \n \t  type_abbrev = get_type_abbrev_from_form (form, uvalue, cu_offset,\n \t\t\t\t\t\t   section, NULL, & type_data, & type_cu_offset);\n@@ -3422,7 +3422,7 @@ read_and_display_attr (unsigned long           attribute,\n    following debug links, then attempt to load the requested section\n    from one of the separate debug info files.  */\n \n-static bfd_boolean\n+static bool\n load_debug_section_with_follow (enum dwarf_section_display_enum sec_enum,\n \t\t\t\tvoid * handle)\n {\n@@ -3441,7 +3441,7 @@ load_debug_section_with_follow (enum dwarf_section_display_enum sec_enum,\n \t      }\n \t}\n \n-      return TRUE;\n+      return true;\n     }\n \n   if (do_follow_links)\n@@ -3456,16 +3456,16 @@ load_debug_section_with_follow (enum dwarf_section_display_enum sec_enum,\n \n \t      /* FIXME: We should check to see if any of the remaining debug info\n \t\t files also contain this section, and, umm, do something about it.  */\n-\t      return TRUE;\n+\t      return true;\n \t    }\n \t}\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n static void\n-introduce (struct dwarf_section * section, bfd_boolean raw)\n+introduce (struct dwarf_section * section, bool raw)\n {\n   if (raw)\n     {\n@@ -3495,12 +3495,12 @@ introduce (struct dwarf_section * section, bfd_boolean raw)\n    Returns TRUE upon success.  Otherwise an error or warning message is\n    printed and FALSE is returned.  */\n \n-static bfd_boolean\n-process_debug_info (struct dwarf_section *           section,\n-\t\t    void *                           file,\n-\t\t    enum dwarf_section_display_enum  abbrev_sec,\n-\t\t    bfd_boolean                      do_loc,\n-\t\t    bfd_boolean                      do_types)\n+static bool\n+process_debug_info (struct dwarf_section * section,\n+\t\t    void *file,\n+\t\t    enum dwarf_section_display_enum abbrev_sec,\n+\t\t    bool do_loc,\n+\t\t    bool do_types)\n {\n   unsigned char *start = section->start;\n   unsigned char *end = start + section->size;\n@@ -3532,7 +3532,7 @@ process_debug_info (struct dwarf_section *           section,\n \t    {\n \t      warn (_(\"Reserved length value (0x%s) found in section %s\\n\"),\n \t\t    dwarf_vmatoa (\"x\", length), section->name);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  else\n \t    section_begin += length + 4;\n@@ -3544,14 +3544,14 @@ process_debug_info (struct dwarf_section *           section,\n \t    {\n \t      warn (_(\"Corrupt unit length (0x%s) found in section %s\\n\"),\n \t\t    dwarf_vmatoa (\"x\", length), section->name);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \n       if (num_units == 0)\n \t{\n \t  error (_(\"No comp units in %s section ?\\n\"), section->name);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       /* Then allocate an array to hold the information.  */\n@@ -3562,7 +3562,7 @@ process_debug_info (struct dwarf_section *           section,\n \t  error (_(\"Not enough memory for a debug info array of %u entries\\n\"),\n \t\t num_units);\n \t  alloc_num_debug_info_entries = num_debug_info_entries = 0;\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       /* PR 17531: file: 92ca3797.\n@@ -3590,11 +3590,11 @@ process_debug_info (struct dwarf_section *           section,\n     {\n       warn (_(\"Unable to locate %s section!\\n\"),\n \t    debug_displays [abbrev_sec].section.uncompressed_name);\n-      return FALSE;\n+      return false;\n     }\n \n   if (!do_loc && dwarf_start_die == 0)\n-    introduce (section, FALSE);\n+    introduce (section, false);\n \n   free_all_abbrevs ();\n   free (cu_abbrev_map);\n@@ -3765,13 +3765,13 @@ process_debug_info (struct dwarf_section *           section,\n       if (compunit.cu_version < 5)\n \tSAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);\n \n-      bfd_boolean do_dwo_id = FALSE;\n+      bool do_dwo_id = false;\n       uint64_t dwo_id = 0;\n       if (compunit.cu_unit_type == DW_UT_split_compile\n \t  || compunit.cu_unit_type == DW_UT_skeleton)\n \t{\n \t  SAFE_BYTE_GET_AND_INC (dwo_id, hdrptr, 8, end);\n-\t  do_dwo_id = TRUE;\n+\t  do_dwo_id = true;\n \t}\n \n       /* PR 17512: file: 001-108546-0.001:0.1.  */\n@@ -3985,7 +3985,7 @@ process_debug_info (struct dwarf_section *           section,\n \t\t    }\n \t\t}\n \t      if (dwarf_start_die != 0 && level < saved_level)\n-\t\treturn TRUE;\n+\t\treturn true;\n \t      continue;\n \t    }\n \n@@ -4027,7 +4027,7 @@ process_debug_info (struct dwarf_section *           section,\n \t\t}\n \t      warn (_(\"DIE at offset 0x%lx refers to abbreviation number %lu which does not exist\\n\"),\n \t\t    die_offset, abbrev_number);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  if (!do_loc && do_printing)\n@@ -4127,7 +4127,7 @@ process_debug_info (struct dwarf_section *           section,\n   if (!do_loc)\n     printf (\"\\n\");\n \n-  return TRUE;\n+  return true;\n }\n \n /* Locate and scan the .debug_info section in the file and record the pointer\n@@ -4152,12 +4152,12 @@ load_debug_info (void * file)\n   (void) load_cu_tu_indexes (file);\n \n   if (load_debug_section_with_follow (info, file)\n-      && process_debug_info (&debug_displays [info].section, file, abbrev, TRUE, FALSE))\n+      && process_debug_info (&debug_displays [info].section, file, abbrev, true, false))\n     return num_debug_info_entries;\n \n   if (load_debug_section_with_follow (info_dwo, file)\n       && process_debug_info (&debug_displays [info_dwo].section, file,\n-\t\t\t     abbrev_dwo, TRUE, FALSE))\n+\t\t\t     abbrev_dwo, true, false))\n     return num_debug_info_entries;\n \n   num_debug_info_entries = DEBUG_INFO_UNAVAILABLE;\n@@ -4282,12 +4282,12 @@ read_debug_line_header (struct dwarf_section * section,\n }\n \n static unsigned char *\n-display_formatted_table (unsigned char *                   data,\n-\t\t\t unsigned char *                   start,\n-\t\t\t unsigned char *                   end,\n-\t\t\t const DWARF2_Internal_LineInfo *  linfo,\n-\t\t\t struct dwarf_section *            section,\n-\t\t\t bfd_boolean                       is_dir)\n+display_formatted_table (unsigned char *data,\n+\t\t\t unsigned char *start,\n+\t\t\t unsigned char *end,\n+\t\t\t const DWARF2_Internal_LineInfo *linfo,\n+\t\t\t struct dwarf_section *section,\n+\t\t\t bool is_dir)\n {\n   unsigned char *format_start, format_count, *format, formati;\n   dwarf_vma data_count, datai;\n@@ -4421,7 +4421,7 @@ display_debug_sup (struct dwarf_section *  section,\n   dwarf_vma checksum_len;\n \n \n-  introduce (section, TRUE);\n+  introduce (section, true);\n   if (section->size < 4)\n     {\n       error (_(\"corrupt .debug_sup section: size is too small\\n\"));\n@@ -4449,7 +4449,7 @@ display_debug_sup (struct dwarf_section *  section,\n     }\n   start += sup_filename_len + 1;\n \n-  checksum_len = read_leb128 (start, end, FALSE /* unsigned */, & num_read, & status);\n+  checksum_len = read_leb128 (start, end, false /* unsigned */, & num_read, & status);\n   if (status)\n     {\n       error (_(\"corrupt .debug_sup section: bad LEB128 field for checksum length\\n\"));\n@@ -4490,7 +4490,7 @@ display_debug_lines_raw (struct dwarf_section *  section,\n   unsigned char *start = section->start;\n   int verbose_view = 0;\n \n-  introduce (section, TRUE);\n+  introduce (section, true);\n \n   while (data < end)\n     {\n@@ -4586,9 +4586,9 @@ display_debug_lines_raw (struct dwarf_section *  section,\n \t      load_debug_section_with_follow (line_str, file);\n \n \t      data = display_formatted_table (data, start, end, &linfo, section,\n-\t\t\t\t\t      TRUE);\n+\t\t\t\t\t      true);\n \t      data = display_formatted_table (data, start, end, &linfo, section,\n-\t\t\t\t\t      FALSE);\n+\t\t\t\t\t      false);\n \t    }\n \t  else\n \t    {\n@@ -4910,7 +4910,7 @@ display_debug_lines_decoded (struct dwarf_section *  section,\n {\n   static DWARF2_Internal_LineInfo saved_linfo;\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   while (data < end)\n     {\n@@ -5738,7 +5738,7 @@ display_debug_pubnames_worker (struct dwarf_section *section,\n      we test for that later on.  */\n   load_debug_info (file);\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   while (start < end)\n     {\n@@ -5883,7 +5883,7 @@ display_debug_macinfo (struct dwarf_section *section,\n   unsigned char *curr = start;\n   enum dwarf_macinfo_record_type op;\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   while (curr < end)\n     {\n@@ -6045,17 +6045,17 @@ display_debug_macro (struct dwarf_section *section,\n   unsigned char *end = start + section->size;\n   unsigned char *curr = start;\n   unsigned char *extended_op_buf[256];\n-  bfd_boolean is_dwo = FALSE;\n+  bool is_dwo = false;\n   const char *suffix = strrchr (section->name, '.');\n \n   if (suffix && strcmp (suffix, \".dwo\") == 0)\n-    is_dwo = TRUE;\n+    is_dwo = true;\n \n   load_debug_section_with_follow (str, file);\n   load_debug_section_with_follow (line, file);\n   load_debug_section_with_follow (str_index, file);\n   \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   while (curr < end)\n     {\n@@ -6257,7 +6257,7 @@ display_debug_macro (struct dwarf_section *section,\n \t      READ_ULEB (lineno, curr, end);\n \t      READ_ULEB (offset, curr, end);\n \t      string = (const unsigned char *)\n-\t\tfetch_indexed_string (offset, NULL, offset_size, FALSE);\n+\t\tfetch_indexed_string (offset, NULL, offset_size, false);\n \t      if (op == DW_MACRO_define_strx)\n \t\tprintf (\" DW_MACRO_define_strx \");\n \t      else\n@@ -6326,7 +6326,7 @@ display_debug_abbrev (struct dwarf_section *section,\n   unsigned char *start = section->start;\n   const unsigned char *end = start + section->size;\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   do\n     {\n@@ -6379,7 +6379,7 @@ display_debug_abbrev (struct dwarf_section *section,\n /* Return true when ADDR is the maximum address, when addresses are\n    POINTER_SIZE bytes long.  */\n \n-static bfd_boolean\n+static bool\n is_max_address (dwarf_vma addr, unsigned int pointer_size)\n {\n   dwarf_vma mask = ~(~(dwarf_vma) 1 << (pointer_size * 8 - 1));\n@@ -6944,12 +6944,12 @@ display_debug_loc (struct dwarf_section *section, void *file)\n   unsigned char *next = start, *vnext = vstart;\n   unsigned int *array = NULL;\n   const char *suffix = strrchr (section->name, '.');\n-  bfd_boolean is_dwo = FALSE;\n+  bool is_dwo = false;\n   int is_loclists = strstr (section->name, \"debug_loclists\") != NULL;\n   dwarf_vma expected_start = 0;\n \n   if (suffix && strcmp (suffix, \".dwo\") == 0)\n-    is_dwo = TRUE;\n+    is_dwo = true;\n \n   bytes = section->size;\n \n@@ -7066,7 +7066,7 @@ display_debug_loc (struct dwarf_section *section, void *file)\n   if (!locs_sorted)\n     array = (unsigned int *) xcmalloc (num_loc_list, sizeof (unsigned int));\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   if (reloc_at (section, 0))\n     printf (_(\" Warning: This section has relocations - addresses seen here may not be accurate.\\n\\n\"));\n@@ -7212,7 +7212,7 @@ display_debug_str (struct dwarf_section *section,\n       return 0;\n     }\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   while (bytes)\n     {\n@@ -7259,19 +7259,19 @@ display_debug_str (struct dwarf_section *section,\n static int\n display_debug_info (struct dwarf_section *section, void *file)\n {\n-  return process_debug_info (section, file, section->abbrev_sec, FALSE, FALSE);\n+  return process_debug_info (section, file, section->abbrev_sec, false, false);\n }\n \n static int\n display_debug_types (struct dwarf_section *section, void *file)\n {\n-  return process_debug_info (section, file, section->abbrev_sec, FALSE, TRUE);\n+  return process_debug_info (section, file, section->abbrev_sec, false, true);\n }\n \n static int\n display_trace_info (struct dwarf_section *section, void *file)\n {\n-  return process_debug_info (section, file, section->abbrev_sec, FALSE, TRUE);\n+  return process_debug_info (section, file, section->abbrev_sec, false, true);\n }\n \n static int\n@@ -7281,7 +7281,7 @@ display_debug_aranges (struct dwarf_section *section,\n   unsigned char *start = section->start;\n   unsigned char *end = start + section->size;\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   /* It does not matter if this load fails,\n      we test for that later on.  */\n@@ -7441,7 +7441,7 @@ display_debug_addr (struct dwarf_section *section,\n       return 0;\n     }\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   /* PR  17531: file: cf38d01b.\n      We use xcalloc because a corrupt file may not have initialised all of the\n@@ -7546,14 +7546,14 @@ display_debug_str_offsets (struct dwarf_section *section,\n   unsigned char *curr = start;\n \n   const char *suffix = strrchr (section->name, '.');\n-  bfd_boolean dwo = suffix && strcmp (suffix, \".dwo\") == 0;\n+  bool dwo = suffix && strcmp (suffix, \".dwo\") == 0;\n \n   if (dwo)\n     load_debug_section_with_follow (str_dwo, file);\n   else\n     load_debug_section_with_follow (str, file);\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   while (curr < end)\n     {\n@@ -7925,7 +7925,7 @@ display_debug_ranges (struct dwarf_section *section,\n     warn (_(\"Range lists in %s section start at 0x%lx\\n\"),\n \t  section->name, (unsigned long) range_entries[0].ranges_offset);\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   printf (_(\"    Offset   Begin    End\\n\"));\n \n@@ -8667,12 +8667,12 @@ display_debug_frames (struct dwarf_section *section,\n   Frame_Chunk *chunks = NULL, *forward_refs = NULL;\n   Frame_Chunk *remembered_state = NULL;\n   Frame_Chunk *rs;\n-  bfd_boolean is_eh = strcmp (section->name, \".eh_frame\") == 0;\n+  bool is_eh = strcmp (section->name, \".eh_frame\") == 0;\n   unsigned int max_regs = 0;\n   const char *bad_reg = _(\"bad register: \");\n   unsigned int saved_eh_addr_size = eh_addr_size;\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   while (start < end)\n     {\n@@ -8688,7 +8688,7 @@ display_debug_frames (struct dwarf_section *section,\n       unsigned int encoded_ptr_size = saved_eh_addr_size;\n       unsigned int offset_size;\n       unsigned int initial_length_size;\n-      bfd_boolean all_nops;\n+      bool all_nops;\n       static Frame_Chunk fde_fc;\n \n       saved_start = start;\n@@ -9117,7 +9117,7 @@ display_debug_frames (struct dwarf_section *section,\n \t  start = tmp;\n \t}\n \n-      all_nops = TRUE;\n+      all_nops = true;\n \n       /* Now we know what registers are used, make a second pass over\n \t the chunk, this time actually printing out the info.  */\n@@ -9143,7 +9143,7 @@ display_debug_frames (struct dwarf_section *section,\n \n \t  /* Make a note if something other than DW_CFA_nop happens.  */\n \t  if (op != DW_CFA_nop)\n-\t    all_nops = FALSE;\n+\t    all_nops = false;\n \n \t  /* Warning: if you add any more cases to this switch, be\n \t     sure to add them to the corresponding switch above.  */\n@@ -9654,7 +9654,7 @@ display_debug_names (struct dwarf_section *section, void *file)\n   const unsigned char *const section_end = section->start + section->size;\n   unsigned char *unit_end;\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   load_debug_section_with_follow (str, file);\n \n@@ -9667,7 +9667,7 @@ display_debug_names (struct dwarf_section *section, void *file)\n       uint32_t augmentation_string_size;\n       unsigned int i;\n       unsigned long sec_off;\n-      bfd_boolean augmentation_printable;\n+      bool augmentation_printable;\n       const char *augmentation_string;\n \n       unit_start = hdrptr;\n@@ -9735,7 +9735,7 @@ display_debug_names (struct dwarf_section *section, void *file)\n \n       printf (_(\"Augmentation string:\"));\n \n-      augmentation_printable = TRUE;\n+      augmentation_printable = true;\n       augmentation_string = (const char *) hdrptr;\n \n       for (i = 0; i < augmentation_string_size; i++)\n@@ -9746,7 +9746,7 @@ display_debug_names (struct dwarf_section *section, void *file)\n \t  printf (\" %02x\", uc);\n \n \t  if (uc != 0 && !ISPRINT (uc))\n-\t    augmentation_printable = FALSE;\n+\t    augmentation_printable = false;\n \t}\n \n       if (augmentation_printable)\n@@ -10010,7 +10010,7 @@ display_debug_links (struct dwarf_section *  section,\n   const unsigned char * filename;\n   unsigned int          filelen;\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   /* The .gnu_debuglink section is formatted as:\n       (c-string)  Filename.\n@@ -10093,7 +10093,7 @@ display_gdb_index (struct dwarf_section *section,\n \n   /* The documentation for the format of this file is in gdb/dwarf2read.c.  */\n \n-  introduce (section, FALSE);\n+  introduce (section, false);\n \n   if (section->size < 6 * sizeof (uint32_t))\n     {\n@@ -10432,7 +10432,7 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n \n   if (do_display)\n     {\n-      introduce (section, FALSE);\n+      introduce (section, false);\n \n       printf (_(\"  Version:                 %u\\n\"), version);\n       if (version >= 2)\n@@ -10514,7 +10514,7 @@ process_cu_tu_index (struct dwarf_section *section, int do_display)\n       unsigned char *poffsets = ppool + (size_t) ncols * 4;\n       unsigned char *psizes = poffsets + (size_t) nused * ncols * 4;\n       unsigned char *pend = psizes + (size_t) nused * ncols * 4;\n-      bfd_boolean is_tu_index;\n+      bool is_tu_index;\n       struct cu_tu_set *this_set = NULL;\n       unsigned int row;\n       unsigned char *prow;\n@@ -10706,25 +10706,25 @@ static int cu_tu_indexes_read = -1; /* Tri-state variable.  */\n    section sets that we can use to associate a .debug_info.dwo section\n    with its associated .debug_abbrev.dwo section in a .dwp file.  */\n \n-static bfd_boolean\n+static bool\n load_cu_tu_indexes (void *file)\n {\n   /* If we have already loaded (or tried to load) the CU and TU indexes\n      then do not bother to repeat the task.  */\n   if (cu_tu_indexes_read == -1)\n     {\n-      cu_tu_indexes_read = TRUE;\n+      cu_tu_indexes_read = true;\n \n       if (load_debug_section_with_follow (dwp_cu_index, file))\n \tif (! process_cu_tu_index (&debug_displays [dwp_cu_index].section, 0))\n-\t  cu_tu_indexes_read = FALSE;\n+\t  cu_tu_indexes_read = false;\n \n       if (load_debug_section_with_follow (dwp_tu_index, file))\n \tif (! process_cu_tu_index (&debug_displays [dwp_tu_index].section, 0))\n-\t  cu_tu_indexes_read = FALSE;\n+\t  cu_tu_indexes_read = false;\n     }\n \n-  return (bfd_boolean) cu_tu_indexes_read;\n+  return (bool) cu_tu_indexes_read;\n }\n \n /* Find the set of sections that includes section SHNDX.  */\n@@ -10905,10 +10905,10 @@ calc_gnu_debuglink_crc32 (unsigned long          crc,\n   return ~crc & 0xffffffff;\n }\n \n-typedef bfd_boolean (*   check_func_type) (const char *, void *);\n-typedef const char * (*  parse_func_type) (struct dwarf_section *, void *);\n+typedef bool (*check_func_type) (const char *, void *);\n+typedef const char *(* parse_func_type) (struct dwarf_section *, void *);\n \n-static bfd_boolean\n+static bool\n check_gnu_debuglink (const char * pathname, void * crc_pointer)\n {\n   static unsigned char buffer [8 * 1024];\n@@ -10919,7 +10919,7 @@ check_gnu_debuglink (const char * pathname, void * crc_pointer)\n \n   sep_data = open_debug_file (pathname);\n   if (sep_data == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Yes - we are opening the file twice...  */\n   f = fopen (pathname, \"rb\");\n@@ -10928,7 +10928,7 @@ check_gnu_debuglink (const char * pathname, void * crc_pointer)\n       /* Paranoia: This should never happen.  */\n       close_debug_file (sep_data);\n       warn (_(\"Unable to reopen separate debug info file: %s\\n\"), pathname);\n-      return FALSE;\n+      return false;\n     }\n \n   while ((count = fread (buffer, 1, sizeof (buffer), f)) > 0)\n@@ -10941,10 +10941,10 @@ check_gnu_debuglink (const char * pathname, void * crc_pointer)\n       close_debug_file (sep_data);\n       warn (_(\"Separate debug info file %s found, but CRC does not match - ignoring\\n\"),\n \t    pathname);\n-      return FALSE;\n+      return false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n static const char *\n@@ -10967,18 +10967,18 @@ parse_gnu_debuglink (struct dwarf_section * section, void * data)\n   return name;\n }\n \n-static bfd_boolean\n+static bool\n check_gnu_debugaltlink (const char * filename, void * data ATTRIBUTE_UNUSED)\n {\n   void * sep_data = open_debug_file (filename);\n \n   if (sep_data == NULL)\n-    return FALSE;\n+    return false;\n \n   /* FIXME: We should now extract the build-id in the separate file\n      and check it...  */\n \n-  return TRUE;\n+  return true;\n }\n \n typedef struct build_id_data\n@@ -11030,7 +11030,7 @@ add_separate_debug_file (const char * filename, void * handle)\n    file. If successful, store the path of the file in filename and\n    return TRUE, otherwise return FALSE.  */\n \n-static bfd_boolean\n+static bool\n debuginfod_fetch_separate_debug_info (struct dwarf_section * section,\n                                       char ** filename,\n                                       void * file)\n@@ -11052,16 +11052,16 @@ debuginfod_fetch_separate_debug_info (struct dwarf_section * section,\n       filelen = strnlen ((const char *)section->start, section->size);\n       if (filelen == section->size)\n         /* Corrupt debugaltlink.  */\n-        return FALSE;\n+        return false;\n \n       build_id = section->start + filelen + 1;\n       build_id_len = section->size - (filelen + 1);\n \n       if (build_id_len == 0)\n-        return FALSE;\n+        return false;\n     }\n   else\n-    return FALSE;\n+    return false;\n \n   if (build_id)\n     {\n@@ -11070,7 +11070,7 @@ debuginfod_fetch_separate_debug_info (struct dwarf_section * section,\n \n       client = debuginfod_begin ();\n       if (client == NULL)\n-        return FALSE;\n+        return false;\n \n       /* Query debuginfod servers for the target file. If found its path\n          will be stored in filename.  */\n@@ -11087,11 +11087,11 @@ debuginfod_fetch_separate_debug_info (struct dwarf_section * section,\n           /* File successfully retrieved. Close fd since we want to\n              use open_debug_file () on filename instead.  */\n           close (fd);\n-          return TRUE;\n+          return true;\n         }\n     }\n \n-  return FALSE;\n+  return false;\n }\n #endif\n \n@@ -11436,12 +11436,12 @@ check_for_and_load_links (void * file, const char * filename)\n    If TRUE is returned then the linked list starting at first_separate_info\n    will be populated with open file handles.  */\n \n-bfd_boolean\n+bool\n load_separate_debug_files (void * file, const char * filename)\n {\n   /* Skip this operation if we are not interested in debug links.  */\n   if (! do_follow_links && ! do_debug_links)\n-    return FALSE;\n+    return false;\n \n   /* See if there are any dwo links.  */\n   if (load_debug_section (str, file)\n@@ -11451,13 +11451,13 @@ load_separate_debug_files (void * file, const char * filename)\n       free_dwo_info ();\n \n       if (process_debug_info (& debug_displays[info].section, file, abbrev,\n-\t\t\t      TRUE, FALSE))\n+\t\t\t      true, false))\n \t{\n-\t  bfd_boolean introduced = FALSE;\n-\t  dwo_info *   dwinfo;\n-\t  const char * dir = NULL;\n-\t  const char * id = NULL;\n-\t  const char * name = NULL;\n+\t  bool introduced = false;\n+\t  dwo_info *dwinfo;\n+\t  const char *dir = NULL;\n+\t  const char *id = NULL;\n+\t  const char *name = NULL;\n \n \t  for (dwinfo = first_dwo_info; dwinfo != NULL; dwinfo = dwinfo->next)\n \t    {\n@@ -11500,7 +11500,7 @@ load_separate_debug_files (void * file, const char * filename)\n \t\t\t{\n \t\t\t  printf (_(\"The %s section contains link(s) to dwo file(s):\\n\\n\"),\n \t\t\t\t  debug_displays [info].section.uncompressed_name);\n-\t\t\t  introduced = TRUE;\n+\t\t\t  introduced = true;\n \t\t\t}\n \n \t\t      printf (_(\"  Name:      %s\\n\"), name);\n@@ -11524,18 +11524,18 @@ load_separate_debug_files (void * file, const char * filename)\n   if (! do_follow_links)\n     /* The other debug links will be displayed by display_debug_links()\n        so we do not need to do any further processing here.  */\n-    return FALSE;\n+    return false;\n \n   /* FIXME: We do not check for the presence of both link sections in the same file.  */\n   /* FIXME: We do not check for the presence of multiple, same-name debuglink sections.  */\n   /* FIXME: We do not check for the presence of a dwo link as well as a debuglink.  */\n \n   check_for_and_load_links (file, filename);\n   if (first_separate_info != NULL)\n-    return TRUE;\n+    return true;\n \n   do_follow_links = 0;\n-  return FALSE;\n+  return false;\n }\n \n void\n@@ -11753,53 +11753,53 @@ dwarf_select_sections_all (void)\n \n struct dwarf_section_display debug_displays[] =\n {\n-  { { \".debug_abbrev\",\t    \".zdebug_abbrev\",\tNO_ABBREVS },      display_debug_abbrev,   &do_debug_abbrevs,\tFALSE },\n-  { { \".debug_aranges\",\t    \".zdebug_aranges\",\tNO_ABBREVS },      display_debug_aranges,  &do_debug_aranges,\tTRUE },\n-  { { \".debug_frame\",       \".zdebug_frame\",\tNO_ABBREVS },      display_debug_frames,   &do_debug_frames,\tTRUE },\n-  { { \".debug_info\",\t    \".zdebug_info\",\tABBREV (abbrev)},  display_debug_info,\t   &do_debug_info,\tTRUE },\n-  { { \".debug_line\",\t    \".zdebug_line\",\tNO_ABBREVS },      display_debug_lines,    &do_debug_lines,\tTRUE },\n-  { { \".debug_pubnames\",    \".zdebug_pubnames\",\tNO_ABBREVS },      display_debug_pubnames, &do_debug_pubnames,\tFALSE },\n-  { { \".debug_gnu_pubnames\", \".zdebug_gnu_pubnames\", NO_ABBREVS }, display_debug_gnu_pubnames, &do_debug_pubnames, FALSE },\n-  { { \".eh_frame\",\t    \"\",\t\t\tNO_ABBREVS },      display_debug_frames,   &do_debug_frames,\tTRUE },\n-  { { \".debug_macinfo\",\t    \".zdebug_macinfo\",\tNO_ABBREVS },      display_debug_macinfo,  &do_debug_macinfo,\tFALSE },\n-  { { \".debug_macro\",\t    \".zdebug_macro\",\tNO_ABBREVS },      display_debug_macro,    &do_debug_macinfo,\tTRUE },\n-  { { \".debug_str\",\t    \".zdebug_str\",\tNO_ABBREVS },      display_debug_str,\t   &do_debug_str,\tFALSE },\n-  { { \".debug_line_str\",    \".zdebug_line_str\",\tNO_ABBREVS },      display_debug_str,\t   &do_debug_str,\tFALSE },\n-  { { \".debug_loc\",\t    \".zdebug_loc\",\tNO_ABBREVS },      display_debug_loc,\t   &do_debug_loc,\tTRUE },\n-  { { \".debug_loclists\",    \".zdebug_loclists\",\tNO_ABBREVS },      display_debug_loc,\t   &do_debug_loc,\tTRUE },\n-  { { \".debug_pubtypes\",    \".zdebug_pubtypes\",\tNO_ABBREVS },      display_debug_pubnames, &do_debug_pubtypes,\tFALSE },\n-  { { \".debug_gnu_pubtypes\", \".zdebug_gnu_pubtypes\", NO_ABBREVS }, display_debug_gnu_pubnames, &do_debug_pubtypes, FALSE },\n-  { { \".debug_ranges\",\t    \".zdebug_ranges\",\tNO_ABBREVS },      display_debug_ranges,   &do_debug_ranges,\tTRUE },\n-  { { \".debug_rnglists\",    \".zdebug_rnglists\",\tNO_ABBREVS },      display_debug_ranges,   &do_debug_ranges,\tTRUE },\n-  { { \".debug_static_func\", \".zdebug_static_func\", NO_ABBREVS },   display_debug_not_supported, NULL,\t\tFALSE },\n-  { { \".debug_static_vars\", \".zdebug_static_vars\", NO_ABBREVS },   display_debug_not_supported, NULL,\t\tFALSE },\n-  { { \".debug_types\",\t    \".zdebug_types\",\tABBREV (abbrev) }, display_debug_types,    &do_debug_info,\tTRUE },\n-  { { \".debug_weaknames\",   \".zdebug_weaknames\", NO_ABBREVS },     display_debug_not_supported, NULL,\t\tFALSE },\n-  { { \".gdb_index\",\t    \"\",\t\t\tNO_ABBREVS },      display_gdb_index,      &do_gdb_index,\tFALSE },\n-  { { \".debug_names\",\t    \"\",\t\t\tNO_ABBREVS },      display_debug_names,    &do_gdb_index,\tFALSE },\n-  { { \".trace_info\",\t    \"\",\t\t\tABBREV (trace_abbrev) }, display_trace_info, &do_trace_info,\tTRUE },\n-  { { \".trace_abbrev\",\t    \"\",\t\t\tNO_ABBREVS },      display_debug_abbrev,   &do_trace_abbrevs,\tFALSE },\n-  { { \".trace_aranges\",\t    \"\",\t\t\tNO_ABBREVS },      display_debug_aranges,  &do_trace_aranges,\tFALSE },\n-  { { \".debug_info.dwo\",    \".zdebug_info.dwo\",\tABBREV (abbrev_dwo) }, display_debug_info, &do_debug_info,\tTRUE },\n-  { { \".debug_abbrev.dwo\",  \".zdebug_abbrev.dwo\", NO_ABBREVS },    display_debug_abbrev,   &do_debug_abbrevs,\tFALSE },\n-  { { \".debug_types.dwo\",   \".zdebug_types.dwo\", ABBREV (abbrev_dwo) }, display_debug_types, &do_debug_info,\tTRUE },\n-  { { \".debug_line.dwo\",    \".zdebug_line.dwo\", NO_ABBREVS },      display_debug_lines,    &do_debug_lines,\tTRUE },\n-  { { \".debug_loc.dwo\",\t    \".zdebug_loc.dwo\",\tNO_ABBREVS },      display_debug_loc,\t   &do_debug_loc,\tTRUE },\n-  { { \".debug_macro.dwo\",   \".zdebug_macro.dwo\", NO_ABBREVS },     display_debug_macro,    &do_debug_macinfo,\tTRUE },\n-  { { \".debug_macinfo.dwo\", \".zdebug_macinfo.dwo\", NO_ABBREVS },   display_debug_macinfo,  &do_debug_macinfo,\tFALSE },\n-  { { \".debug_str.dwo\",     \".zdebug_str.dwo\",  NO_ABBREVS },      display_debug_str,      &do_debug_str,\tTRUE },\n-  { { \".debug_str_offsets\", \".zdebug_str_offsets\", NO_ABBREVS },   display_debug_str_offsets, &do_debug_str_offsets, TRUE },\n-  { { \".debug_str_offsets.dwo\", \".zdebug_str_offsets.dwo\", NO_ABBREVS }, display_debug_str_offsets, &do_debug_str_offsets, TRUE },\n-  { { \".debug_addr\",\t    \".zdebug_addr\",     NO_ABBREVS },      display_debug_addr,     &do_debug_addr,\tTRUE },\n-  { { \".debug_cu_index\",    \"\",\t\t\tNO_ABBREVS },      display_cu_index,       &do_debug_cu_index,\tFALSE },\n-  { { \".debug_tu_index\",    \"\",\t\t\tNO_ABBREVS },      display_cu_index,       &do_debug_cu_index,\tFALSE },\n-  { { \".gnu_debuglink\",     \"\",                 NO_ABBREVS },      display_debug_links,    &do_debug_links,     FALSE },\n-  { { \".gnu_debugaltlink\",  \"\",                 NO_ABBREVS },      display_debug_links,    &do_debug_links,     FALSE },\n-  { { \".debug_sup\",         \"\",\t\t\tNO_ABBREVS },      display_debug_sup,      &do_debug_links,\tFALSE },\n+  { { \".debug_abbrev\",\t    \".zdebug_abbrev\",\tNO_ABBREVS },      display_debug_abbrev,   &do_debug_abbrevs,\tfalse },\n+  { { \".debug_aranges\",\t    \".zdebug_aranges\",\tNO_ABBREVS },      display_debug_aranges,  &do_debug_aranges,\ttrue },\n+  { { \".debug_frame\",       \".zdebug_frame\",\tNO_ABBREVS },      display_debug_frames,   &do_debug_frames,\ttrue },\n+  { { \".debug_info\",\t    \".zdebug_info\",\tABBREV (abbrev)},  display_debug_info,\t   &do_debug_info,\ttrue },\n+  { { \".debug_line\",\t    \".zdebug_line\",\tNO_ABBREVS },      display_debug_lines,    &do_debug_lines,\ttrue },\n+  { { \".debug_pubnames\",    \".zdebug_pubnames\",\tNO_ABBREVS },      display_debug_pubnames, &do_debug_pubnames,\tfalse },\n+  { { \".debug_gnu_pubnames\", \".zdebug_gnu_pubnames\", NO_ABBREVS }, display_debug_gnu_pubnames, &do_debug_pubnames, false },\n+  { { \".eh_frame\",\t    \"\",\t\t\tNO_ABBREVS },      display_debug_frames,   &do_debug_frames,\ttrue },\n+  { { \".debug_macinfo\",\t    \".zdebug_macinfo\",\tNO_ABBREVS },      display_debug_macinfo,  &do_debug_macinfo,\tfalse },\n+  { { \".debug_macro\",\t    \".zdebug_macro\",\tNO_ABBREVS },      display_debug_macro,    &do_debug_macinfo,\ttrue },\n+  { { \".debug_str\",\t    \".zdebug_str\",\tNO_ABBREVS },      display_debug_str,\t   &do_debug_str,\tfalse },\n+  { { \".debug_line_str\",    \".zdebug_line_str\",\tNO_ABBREVS },      display_debug_str,\t   &do_debug_str,\tfalse },\n+  { { \".debug_loc\",\t    \".zdebug_loc\",\tNO_ABBREVS },      display_debug_loc,\t   &do_debug_loc,\ttrue },\n+  { { \".debug_loclists\",    \".zdebug_loclists\",\tNO_ABBREVS },      display_debug_loc,\t   &do_debug_loc,\ttrue },\n+  { { \".debug_pubtypes\",    \".zdebug_pubtypes\",\tNO_ABBREVS },      display_debug_pubnames, &do_debug_pubtypes,\tfalse },\n+  { { \".debug_gnu_pubtypes\", \".zdebug_gnu_pubtypes\", NO_ABBREVS }, display_debug_gnu_pubnames, &do_debug_pubtypes, false },\n+  { { \".debug_ranges\",\t    \".zdebug_ranges\",\tNO_ABBREVS },      display_debug_ranges,   &do_debug_ranges,\ttrue },\n+  { { \".debug_rnglists\",    \".zdebug_rnglists\",\tNO_ABBREVS },      display_debug_ranges,   &do_debug_ranges,\ttrue },\n+  { { \".debug_static_func\", \".zdebug_static_func\", NO_ABBREVS },   display_debug_not_supported, NULL,\t\tfalse },\n+  { { \".debug_static_vars\", \".zdebug_static_vars\", NO_ABBREVS },   display_debug_not_supported, NULL,\t\tfalse },\n+  { { \".debug_types\",\t    \".zdebug_types\",\tABBREV (abbrev) }, display_debug_types,    &do_debug_info,\ttrue },\n+  { { \".debug_weaknames\",   \".zdebug_weaknames\", NO_ABBREVS },     display_debug_not_supported, NULL,\t\tfalse },\n+  { { \".gdb_index\",\t    \"\",\t\t\tNO_ABBREVS },      display_gdb_index,      &do_gdb_index,\tfalse },\n+  { { \".debug_names\",\t    \"\",\t\t\tNO_ABBREVS },      display_debug_names,    &do_gdb_index,\tfalse },\n+  { { \".trace_info\",\t    \"\",\t\t\tABBREV (trace_abbrev) }, display_trace_info, &do_trace_info,\ttrue },\n+  { { \".trace_abbrev\",\t    \"\",\t\t\tNO_ABBREVS },      display_debug_abbrev,   &do_trace_abbrevs,\tfalse },\n+  { { \".trace_aranges\",\t    \"\",\t\t\tNO_ABBREVS },      display_debug_aranges,  &do_trace_aranges,\tfalse },\n+  { { \".debug_info.dwo\",    \".zdebug_info.dwo\",\tABBREV (abbrev_dwo) }, display_debug_info, &do_debug_info,\ttrue },\n+  { { \".debug_abbrev.dwo\",  \".zdebug_abbrev.dwo\", NO_ABBREVS },    display_debug_abbrev,   &do_debug_abbrevs,\tfalse },\n+  { { \".debug_types.dwo\",   \".zdebug_types.dwo\", ABBREV (abbrev_dwo) }, display_debug_types, &do_debug_info,\ttrue },\n+  { { \".debug_line.dwo\",    \".zdebug_line.dwo\", NO_ABBREVS },      display_debug_lines,    &do_debug_lines,\ttrue },\n+  { { \".debug_loc.dwo\",\t    \".zdebug_loc.dwo\",\tNO_ABBREVS },      display_debug_loc,\t   &do_debug_loc,\ttrue },\n+  { { \".debug_macro.dwo\",   \".zdebug_macro.dwo\", NO_ABBREVS },     display_debug_macro,    &do_debug_macinfo,\ttrue },\n+  { { \".debug_macinfo.dwo\", \".zdebug_macinfo.dwo\", NO_ABBREVS },   display_debug_macinfo,  &do_debug_macinfo,\tfalse },\n+  { { \".debug_str.dwo\",     \".zdebug_str.dwo\",  NO_ABBREVS },      display_debug_str,      &do_debug_str,\ttrue },\n+  { { \".debug_str_offsets\", \".zdebug_str_offsets\", NO_ABBREVS },   display_debug_str_offsets, &do_debug_str_offsets, true },\n+  { { \".debug_str_offsets.dwo\", \".zdebug_str_offsets.dwo\", NO_ABBREVS }, display_debug_str_offsets, &do_debug_str_offsets, true },\n+  { { \".debug_addr\",\t    \".zdebug_addr\",     NO_ABBREVS },      display_debug_addr,     &do_debug_addr,\ttrue },\n+  { { \".debug_cu_index\",    \"\",\t\t\tNO_ABBREVS },      display_cu_index,       &do_debug_cu_index,\tfalse },\n+  { { \".debug_tu_index\",    \"\",\t\t\tNO_ABBREVS },      display_cu_index,       &do_debug_cu_index,\tfalse },\n+  { { \".gnu_debuglink\",     \"\",                 NO_ABBREVS },      display_debug_links,    &do_debug_links,     false },\n+  { { \".gnu_debugaltlink\",  \"\",                 NO_ABBREVS },      display_debug_links,    &do_debug_links,     false },\n+  { { \".debug_sup\",         \"\",\t\t\tNO_ABBREVS },      display_debug_sup,      &do_debug_links,\tfalse },\n   /* Separate debug info files can containt their own .debug_str section,\n      and this might be in *addition* to a .debug_str section already present\n      in the main file.  Hence we need to have two entries for .debug_str.  */\n-  { { \".debug_str\",\t    \".zdebug_str\",\tNO_ABBREVS },      display_debug_str,\t   &do_debug_str,\tFALSE },\n+  { { \".debug_str\",\t    \".zdebug_str\",\tNO_ABBREVS },      display_debug_str,\t   &do_debug_str,\tfalse },\n };\n \n /* A static assertion.  */"
    },
    {
      "sha": "2070c6f3daf8f86eb9b4176fb697932d2f7b0279",
      "filename": "binutils/dwarf.h",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/dwarf.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/dwarf.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.h?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -150,10 +150,10 @@ struct dwarf_section\n    and a pointer to a function that can decode it.  */\n struct dwarf_section_display\n {\n-  struct dwarf_section  section;\n-  int (*                display) (struct dwarf_section *, void *);\n-  int *                 enabled;\n-  bfd_boolean           relocate;\n+  struct dwarf_section section;\n+  int (*display) (struct dwarf_section *, void *);\n+  int *enabled;\n+  bool relocate;\n };\n \n extern struct dwarf_section_display debug_displays [];\n@@ -221,7 +221,7 @@ extern int do_debug_cu_index;\n extern int do_wide;\n extern int do_debug_links;\n extern int do_follow_links;\n-extern bfd_boolean do_checks;\n+extern bool do_checks;\n \n extern int dwarf_cutoff_level;\n extern unsigned long dwarf_start_die;\n@@ -232,11 +232,11 @@ extern void init_dwarf_regnames_by_elf_machine_code (unsigned int);\n extern void init_dwarf_regnames_by_bfd_arch_and_mach (enum bfd_architecture arch,\n \t\t\t\t\t\t      unsigned long mach);\n \n-extern bfd_boolean  load_debug_section (enum dwarf_section_display_enum, void *);\n-extern void         free_debug_section (enum dwarf_section_display_enum);\n-extern bfd_boolean  load_separate_debug_files (void *, const char *);\n-extern void         close_debug_file (void *);\n-extern void *       open_debug_file (const char *);\n+extern bool load_debug_section (enum dwarf_section_display_enum, void *);\n+extern void free_debug_section (enum dwarf_section_display_enum);\n+extern bool load_separate_debug_files (void *, const char *);\n+extern void close_debug_file (void *);\n+extern void *open_debug_file (const char *);\n \n extern void free_debug_memory (void);\n \n@@ -254,10 +254,10 @@ extern void * xcrealloc (void *, size_t, size_t);\n /* A callback into the client.  Returns TRUE if there is a\n    relocation against the given debug section at the given\n    offset.  */\n-extern bfd_boolean reloc_at (struct dwarf_section *, dwarf_vma);\n+extern bool reloc_at (struct dwarf_section *, dwarf_vma);\n \n extern dwarf_vma read_leb128 (unsigned char *, const unsigned char *const,\n-\t\t\t      bfd_boolean, unsigned int *, int *);\n+\t\t\t      bool, unsigned int *, int *);\n \n #if HAVE_LIBDEBUGINFOD\n extern unsigned char * get_build_id (void *);\n@@ -276,7 +276,7 @@ report_leb_status (int status, const char *file, unsigned long lnum)\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       unsigned int _len;\t\t\t\t\t\\\n-      read_leb128 (start, end, FALSE, &_len, NULL);\t\t\\\n+      read_leb128 (start, end, false, &_len, NULL);\t\t\\\n       start += _len;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n@@ -285,7 +285,7 @@ report_leb_status (int status, const char *file, unsigned long lnum)\n   do\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       unsigned int _len;\t\t\t\t\t\\\n-      read_leb128 (start, end, TRUE, &_len, NULL);\t\t\\\n+      read_leb128 (start, end, true, &_len, NULL);\t\t\\\n       start += _len;\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n@@ -297,7 +297,7 @@ report_leb_status (int status, const char *file, unsigned long lnum)\n       unsigned int _len;\t\t\t\t\t\\\n       int _status;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n-      _val = read_leb128 (start, end, FALSE, &_len, &_status);\t\\\n+      _val = read_leb128 (start, end, false, &_len, &_status);\t\\\n       start += _len;\t\t\t\t\t\t\\\n       (var) = _val;\t\t\t\t\t\t\\\n       if ((var) != _val)\t\t\t\t\t\\\n@@ -313,7 +313,7 @@ report_leb_status (int status, const char *file, unsigned long lnum)\n       unsigned int _len;\t\t\t\t\t\\\n       int _status;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n-      _val = read_leb128 (start, end, TRUE, &_len, &_status);\t\\\n+      _val = read_leb128 (start, end, true, &_len, &_status);\t\\\n       start += _len;\t\t\t\t\t\t\\\n       (var) = _val;\t\t\t\t\t\t\\\n       if ((var) != _val)\t\t\t\t\t\\"
    },
    {
      "sha": "ddcace90f3a5aeb5e831bcab74d252f1f0b13e36",
      "filename": "binutils/elfedit.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/elfedit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/elfedit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/elfedit.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -540,7 +540,7 @@ process_object (const char *file_name, FILE *file)\n \n static int\n process_archive (const char * file_name, FILE * file,\n-\t\t bfd_boolean is_thin_archive)\n+\t\t bool is_thin_archive)\n {\n   struct archive_info arch;\n   struct archive_info nested_arch;\n@@ -566,7 +566,7 @@ process_archive (const char * file_name, FILE * file,\n \n   if (fstat (fileno (file), &statbuf) < 0\n       || setup_archive (&arch, file_name, file, statbuf.st_size,\n-\t\t\tis_thin_archive, FALSE) != 0)\n+\t\t\tis_thin_archive, false) != 0)\n     {\n       ret = 1;\n       goto out;\n@@ -770,9 +770,9 @@ process_file (const char *file_name)\n     }\n \n   if (memcmp (armag, ARMAG, SARMAG) == 0)\n-    ret = process_archive (file_name, file, FALSE);\n+    ret = process_archive (file_name, file, false);\n   else if (memcmp (armag, ARMAGT, SARMAG) == 0)\n-    ret = process_archive (file_name, file, TRUE);\n+    ret = process_archive (file_name, file, true);\n   else\n     {\n       rewind (file);"
    },
    {
      "sha": "8ce9ba1ce50d6eea83df057765788d4fa84b2b75",
      "filename": "binutils/emul_aix.c",
      "status": "modified",
      "additions": 28,
      "deletions": 28,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/emul_aix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/emul_aix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/emul_aix.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -28,13 +28,13 @@\n \n /* Default to <bigaf>.  */\n /* FIXME: write only variable.  */\n-static bfd_boolean big_archive = TRUE;\n+static bool big_archive = true;\n \n /* Whether to include 32 bit objects.  */\n-static bfd_boolean X32 = TRUE;\n+static bool X32 = true;\n \n /* Whether to include 64 bit objects.  */\n-static bfd_boolean X64 = FALSE;\n+static bool X64 = false;\n \n static void\n ar_emul_aix_usage (FILE *fp)\n@@ -47,7 +47,7 @@ ar_emul_aix_usage (FILE *fp)\n   fprintf (fp, _(\"  [-X32_64]    - accepts 32 and 64 bit objects\\n\"));\n }\n \n-static bfd_boolean\n+static bool\n check_aix (bfd *try_bfd)\n {\n   extern const bfd_target rs6000_xcoff_vec;\n@@ -57,68 +57,68 @@ check_aix (bfd *try_bfd)\n   if (bfd_check_format (try_bfd, bfd_object))\n     {\n       if (!X32 && try_bfd->xvec == &rs6000_xcoff_vec)\n-\treturn FALSE;\n+\treturn false;\n \n       if (!X64 && (try_bfd->xvec == &rs6000_xcoff64_vec\n \t\t   || try_bfd->xvec == &rs6000_xcoff64_aix_vec))\n-\treturn FALSE;\n+\treturn false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n ar_emul_aix_append (bfd **after_bfd, bfd *new_bfd,\n-\t\t    bfd_boolean verbose, bfd_boolean flatten)\n+\t\t    bool verbose, bool flatten)\n {\n   return do_ar_emul_append (after_bfd, new_bfd, verbose, flatten, check_aix);\n }\n \n-static bfd_boolean\n+static bool\n ar_emul_aix_replace (bfd **after_bfd, bfd *new_bfd,\n-\t\t     bfd_boolean verbose)\n+\t\t     bool verbose)\n {\n   if (!check_aix (new_bfd))\n-    return FALSE;\n+    return false;\n \n   AR_EMUL_REPLACE_PRINT_VERBOSE (verbose, bfd_get_filename (new_bfd));\n \n   new_bfd->archive_next = *after_bfd;\n   *after_bfd = new_bfd;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n ar_emul_aix_parse_arg (char *arg)\n {\n   if (startswith (arg, \"-X32_64\"))\n     {\n-      big_archive = TRUE;\n-      X32 = TRUE;\n-      X64 = TRUE;\n+      big_archive = true;\n+      X32 = true;\n+      X64 = true;\n     }\n   else if (startswith (arg, \"-X32\"))\n     {\n-      big_archive = TRUE;\n-      X32 = TRUE;\n-      X64 = FALSE;\n+      big_archive = true;\n+      X32 = true;\n+      X64 = false;\n     }\n   else if (startswith (arg, \"-X64\"))\n     {\n-      big_archive = TRUE;\n-      X32 = FALSE;\n-      X64 = TRUE;\n+      big_archive = true;\n+      X32 = false;\n+      X64 = true;\n     }\n   else if (startswith (arg, \"-g\"))\n     {\n-      big_archive = FALSE;\n-      X32 = TRUE;\n-      X64 = FALSE;\n+      big_archive = false;\n+      X32 = true;\n+      X64 = false;\n     }\n   else\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n struct bin_emulation_xfer_struct bin_aix_emulation ="
    },
    {
      "sha": "aa1814cc7451152a1874f8e85b5c7a3c15cbe8ad",
      "filename": "binutils/mclex.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/mclex.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/mclex.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/mclex.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -34,9 +34,9 @@\n #include <assert.h>\n \n /* Exported globals.  */\n-bfd_boolean mclex_want_nl = FALSE;\n-bfd_boolean mclex_want_line = FALSE;\n-bfd_boolean mclex_want_filename = FALSE;\n+bool mclex_want_nl = false;\n+bool mclex_want_line = false;\n+bool mclex_want_filename = false;\n \n /* Local globals.  */\n static unichar *input_stream = NULL;\n@@ -365,7 +365,7 @@ yylex (void)\n \t  && (input_stream_pos[1] == '\\n'\n \t      || (input_stream_pos[1] == '\\r' && input_stream_pos[2] == '\\n')))\n \t{\n-\t  mclex_want_line = FALSE;\n+\t  mclex_want_line = false;\n           return skip_until_eol () ? MCENDLINE : -1;\n \t}\n       if (!skip_until_eol ())\n@@ -383,15 +383,15 @@ yylex (void)\n \tinput_line += 1;\n       if (mclex_want_nl && ch == '\\n')\n \t{\n-\t  mclex_want_nl = FALSE;\n+\t  mclex_want_nl = false;\n \t  return NL;\n \t}\n     }\n   start_token = input_stream_pos;\n   ++input_stream_pos;\n   if (mclex_want_filename)\n     {\n-      mclex_want_filename = FALSE;\n+      mclex_want_filename = false;\n       if (ch == '\"')\n \t{\n \t  start_token++;"
    },
    {
      "sha": "64105ca627f230353275c246ee8d82ee08c2414a",
      "filename": "binutils/nm.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/nm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/nm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/nm.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -461,11 +461,11 @@ print_symname (const char *form, struct extended_symbol_info *info,\n   if (info != NULL && info->elfinfo && with_symbol_versions)\n     {\n       const char *version_string;\n-      bfd_boolean hidden;\n+      bool hidden;\n \n       version_string\n \t= bfd_get_symbol_version_string (abfd, &info->elfinfo->symbol,\n-\t\t\t\t\t FALSE, &hidden);\n+\t\t\t\t\t false, &hidden);\n       if (version_string && version_string[0])\n \t{\n \t  const char *at = \"@@\";\n@@ -487,7 +487,7 @@ print_symdef_entry (bfd *abfd)\n {\n   symindex idx = BFD_NO_MORE_SYMBOLS;\n   carsym *thesym;\n-  bfd_boolean everprinted = FALSE;\n+  bool everprinted = false;\n \n   for (idx = bfd_get_next_mapent (abfd, idx, &thesym);\n        idx != BFD_NO_MORE_SYMBOLS;\n@@ -497,7 +497,7 @@ print_symdef_entry (bfd *abfd)\n       if (!everprinted)\n \t{\n \t  printf (_(\"\\nArchive index:\\n\"));\n-\t  everprinted = TRUE;\n+\t  everprinted = true;\n \t}\n       elt = bfd_get_elt_at_index (abfd, idx);\n       if (elt == NULL)\n@@ -512,14 +512,14 @@ print_symdef_entry (bfd *abfd)\n \f\n \n /* True when we can report missing plugin error.  */\n-bfd_boolean report_plugin_err = TRUE;\n+bool report_plugin_err = true;\n \n /* Choose which symbol entries to print;\n    compact them downward to get rid of the rest.\n    Return the number of symbols to be printed.  */\n \n static long\n-filter_symbols (bfd *abfd, bfd_boolean is_dynamic, void *minisyms,\n+filter_symbols (bfd *abfd, bool is_dynamic, void *minisyms,\n \t\tlong symcount, unsigned int size)\n {\n   bfd_byte *from, *fromend, *to;\n@@ -549,7 +549,7 @@ filter_symbols (bfd *abfd, bfd_boolean is_dynamic, void *minisyms,\n \t  && strcmp (sym->name + (sym->name[2] == '_'), \"__gnu_lto_slim\") == 0\n \t  && report_plugin_err)\n \t{\n-\t  report_plugin_err = FALSE;\n+\t  report_plugin_err = false;\n \t  non_fatal (_(\"%s: plugin needed to handle lto object\"),\n \t\t     bfd_get_filename (abfd));\n \t}\n@@ -603,7 +603,7 @@ filter_symbols (bfd *abfd, bfd_boolean is_dynamic, void *minisyms,\n /* These globals are used to pass information into the sorting\n    routines.  */\n static bfd *sort_bfd;\n-static bfd_boolean sort_dynamic;\n+static bool sort_dynamic;\n static asymbol *sort_x;\n static asymbol *sort_y;\n \n@@ -794,7 +794,7 @@ size_forward2 (const void *P_x, const void *P_y)\n    size.  */\n \n static long\n-sort_symbols_by_size (bfd *abfd, bfd_boolean is_dynamic, void *minisyms,\n+sort_symbols_by_size (bfd *abfd, bool is_dynamic, void *minisyms,\n \t\t      long symcount, unsigned int size,\n \t\t      struct size_sym **symsizesp)\n {\n@@ -1088,11 +1088,11 @@ print_symbol (bfd *        abfd,\n /* Print the symbols when sorting by size.  */\n \n static void\n-print_size_symbols (bfd *              abfd,\n-\t\t    bfd_boolean        is_dynamic,\n-\t\t    struct size_sym *  symsizes,\n-\t\t    long               symcount,\n-\t\t    bfd *              archive_bfd)\n+print_size_symbols (bfd *abfd,\n+\t\t    bool is_dynamic,\n+\t\t    struct size_sym *symsizes,\n+\t\t    long symcount,\n+\t\t    bfd *archive_bfd)\n {\n   asymbol *store;\n   struct size_sym *from;\n@@ -1127,12 +1127,12 @@ print_size_symbols (bfd *              abfd,\n    SIZE is the size of a symbol in MINISYMS.  */\n \n static void\n-print_symbols (bfd *         abfd,\n-\t       bfd_boolean   is_dynamic,\n-\t       void *        minisyms,\n-\t       long          symcount,\n-\t       unsigned int  size,\n-\t       bfd *         archive_bfd)\n+print_symbols (bfd *abfd,\n+\t       bool is_dynamic,\n+\t       void *minisyms,\n+\t       long symcount,\n+\t       unsigned int size,\n+\t       bfd *archive_bfd)\n {\n   asymbol *store;\n   bfd_byte *from;\n@@ -1250,7 +1250,7 @@ display_rel_file (bfd *abfd, bfd *archive_bfd)\n      LTO plugin.  */\n   if (abfd->lto_slim_object)\n     {\n-      report_plugin_err = FALSE;\n+      report_plugin_err = false;\n       non_fatal (_(\"%s: plugin needed to handle lto object\"),\n \t\t bfd_get_filename (abfd));\n     }\n@@ -1418,21 +1418,21 @@ display_archive (bfd *file)\n     }\n }\n \n-static bfd_boolean\n+static bool\n display_file (char *filename)\n {\n-  bfd_boolean retval = TRUE;\n+  bool retval = true;\n   bfd *file;\n   char **matching;\n \n   if (get_file_size (filename) < 1)\n-    return FALSE;\n+    return false;\n \n   file = bfd_openr (filename, target ? target : plugin_target);\n   if (file == NULL)\n     {\n       bfd_nonfatal (filename);\n-      return FALSE;\n+      return false;\n     }\n \n   /* If printing line numbers, decompress the debug sections.  */\n@@ -1457,7 +1457,7 @@ display_file (char *filename)\n \t  list_matching_formats (matching);\n \t  free (matching);\n \t}\n-      retval = FALSE;\n+      retval = false;\n     }\n \n   if (!bfd_close (file))"
    },
    {
      "sha": "092bc9e668a007e9c21b2e8e6caf7e5a54bc9eba",
      "filename": "binutils/objcopy.c",
      "status": "modified",
      "additions": 240,
      "deletions": 239,
      "changes": 479,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/objcopy.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/objcopy.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objcopy.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -50,8 +50,8 @@ static short pe_minor_subsystem_version = -1;\n \n struct is_specified_symbol_predicate_data\n {\n-  const char *  name;\n-  bfd_boolean\tfound;\n+  const char *name;\n+  bool found;\n };\n \n /* A node includes symbol name mapping to support redefine_sym.  */\n@@ -91,13 +91,13 @@ static int copy_byte = -1;\n static int interleave = 0; /* Initialised to 4 in copy_main().  */\n static int copy_width = 1;\n \n-static bfd_boolean keep_section_symbols = FALSE ;/* True if section symbols should be retained.  */\n-static bfd_boolean verbose;\t\t/* Print file and target names.  */\n-static bfd_boolean preserve_dates;\t/* Preserve input file timestamp.  */\n+static bool keep_section_symbols = false ;/* True if section symbols should be retained.  */\n+static bool verbose;\t\t/* Print file and target names.  */\n+static bool preserve_dates;\t/* Preserve input file timestamp.  */\n static int deterministic = -1;\t\t/* Enable deterministic archives.  */\n static int status = 0;\t\t\t/* Exit status.  */\n \n-static bfd_boolean    merge_notes = FALSE;\t/* Merge note sections.  */\n+static bool    merge_notes = false;\t/* Merge note sections.  */\n \n typedef struct merged_note_section\n {\n@@ -135,13 +135,14 @@ static enum locals_action discard_locals;\n /* Structure used to hold lists of sections and actions to take.  */\n struct section_list\n {\n-  struct section_list * next;\t   /* Next section to change.  */\n-  const char *\t\tpattern;   /* Section name pattern.  */\n-  bfd_boolean\t\tused;\t   /* Whether this entry was used.  */\n+  struct section_list *next;\t/* Next section to change.  */\n+  const char *pattern;\t\t/* Section name pattern.  */\n+  bool used;\t\t\t/* Whether this entry was used.  */\n \n-  unsigned int          context;   /* What to do with matching sections.  */\n+  unsigned int context;\t\t/* What to do with matching sections.  */\n   /* Flag bits used in the context field.\n-     COPY and REMOVE are mutually exlusive.  SET and ALTER are mutually exclusive.  */\n+     COPY and REMOVE are mutually exlusive.\n+     SET and ALTER are mutually exclusive.  */\n #define SECTION_CONTEXT_REMOVE    (1 << 0) /* Remove this section.  */\n #define SECTION_CONTEXT_COPY      (1 << 1) /* Copy this section, delete all non-copied section.  */\n #define SECTION_CONTEXT_KEEP      (1 << 2) /* Keep this section.  */\n@@ -153,34 +154,34 @@ struct section_list\n #define SECTION_CONTEXT_REMOVE_RELOCS (1 << 8) /* Remove relocations for this section.  */\n #define SECTION_CONTEXT_SET_ALIGNMENT (1 << 9) /* Set alignment for section.  */\n \n-  bfd_vma\t\tvma_val;   /* Amount to change by or set to.  */\n-  bfd_vma\t\tlma_val;   /* Amount to change by or set to.  */\n-  flagword\t\tflags;\t   /* What to set the section flags to.\t */\n-  unsigned int\t        alignment; /* Alignment of output section.  */\n+  bfd_vma vma_val;\t\t/* Amount to change by or set to.  */\n+  bfd_vma lma_val;\t\t/* Amount to change by or set to.  */\n+  flagword flags;\t\t/* What to set the section flags to.  */\n+  unsigned int alignment;\t/* Alignment of output section.  */\n };\n \n static struct section_list *change_sections;\n \n /* TRUE if some sections are to be removed.  */\n-static bfd_boolean sections_removed;\n+static bool sections_removed;\n \n /* TRUE if only some sections are to be copied.  */\n-static bfd_boolean sections_copied;\n+static bool sections_copied;\n \n /* Changes to the start address.  */\n static bfd_vma change_start = 0;\n-static bfd_boolean set_start_set = FALSE;\n+static bool set_start_set = false;\n static bfd_vma set_start;\n \n /* Changes to section addresses.  */\n static bfd_vma change_section_address = 0;\n \n /* Filling gaps between sections.  */\n-static bfd_boolean gap_fill_set = FALSE;\n+static bool gap_fill_set = false;\n static bfd_byte gap_fill = 0;\n \n /* Pad to a given address.  */\n-static bfd_boolean pad_to_set = FALSE;\n+static bool pad_to_set = false;\n static bfd_vma pad_to;\n \n /* Use alternative machine code?  */\n@@ -221,7 +222,7 @@ static struct section_add *dump_sections;\n static const char * gnu_debuglink_filename = NULL;\n \n /* Whether to convert debugging information.  */\n-static bfd_boolean convert_debugging = FALSE;\n+static bool convert_debugging = false;\n \n /* Whether to compress/decompress DWARF debug sections.  */\n static enum\n@@ -238,16 +239,16 @@ static enum\n static enum bfd_link_elf_stt_common do_elf_stt_common = unchanged;\n \n /* Whether to change the leading character in symbol names.  */\n-static bfd_boolean change_leading_char = FALSE;\n+static bool change_leading_char = false;\n \n /* Whether to remove the leading character from global symbol names.  */\n-static bfd_boolean remove_leading_char = FALSE;\n+static bool remove_leading_char = false;\n \n /* Whether to permit wildcard in symbol comparison.  */\n-static bfd_boolean wildcard = FALSE;\n+static bool wildcard = false;\n \n /* True if --localize-hidden is in effect.  */\n-static bfd_boolean localize_hidden = FALSE;\n+static bool localize_hidden = false;\n \n /* List of symbols to strip, keep, localize, keep-global, weaken,\n    or redefine.  */\n@@ -272,18 +273,18 @@ static char *keepglobal_specific_buffer = NULL;\n static char *weaken_specific_buffer = NULL;\n \n /* If this is TRUE, we weaken global symbols (set BSF_WEAK).  */\n-static bfd_boolean weaken = FALSE;\n+static bool weaken = false;\n \n /* If this is TRUE, we retain BSF_FILE symbols.  */\n-static bfd_boolean keep_file_symbols = FALSE;\n+static bool keep_file_symbols = false;\n \n /* Prefix symbols/sections.  */\n static char *prefix_symbols_string = 0;\n static char *prefix_sections_string = 0;\n static char *prefix_alloc_sections_string = 0;\n \n /* True if --extract-symbol was passed on the command line.  */\n-static bfd_boolean extract_symbol = FALSE;\n+static bool extract_symbol = false;\n \n /* If `reverse_bytes' is nonzero, then reverse the order of every chunk\n    of <reverse_bytes> bytes within each output section.  */\n@@ -537,7 +538,7 @@ extern unsigned int _bfd_srec_len;\n /* Restrict the generation of Srecords to type S3 only.\n    This variable is defined in bfd/srec.c and can be toggled\n    on by the --srec-forceS3 command line switch.  */\n-extern bfd_boolean _bfd_srec_forceS3;\n+extern bool _bfd_srec_forceS3;\n \n /* Width of data in bytes for verilog output.\n    This variable is declared in bfd/verilog.c and can be modified by\n@@ -552,7 +553,7 @@ static void copy_section (bfd *, asection *, void *);\n static void get_sections (bfd *, asection *, void *);\n static int compare_section_lma (const void *, const void *);\n static void mark_symbols_used_in_relocations (bfd *, asection *, void *);\n-static bfd_boolean write_debugging_info (bfd *, void *, long *, asymbol ***);\n+static bool write_debugging_info (bfd *, void *, long *, asymbol ***);\n static const char *lookup_sym_redefinition (const char *);\n static const char *find_section_rename (const char *, flagword *);\n \f\n@@ -913,7 +914,7 @@ parse_symflags (const char *s, const char **other)\n    entry as used.  */\n \n static struct section_list *\n-find_section_list (const char *name, bfd_boolean add, unsigned int context)\n+find_section_list (const char *name, bool add, unsigned int context)\n {\n   struct section_list *p, *match = NULL;\n \n@@ -960,7 +961,7 @@ find_section_list (const char *name, bfd_boolean add, unsigned int context)\n             {\n               if (fnmatch (p->pattern + 1, name, 0) == 0)\n                 {\n-                  p->used = TRUE;\n+                  p->used = true;\n                   return NULL;\n                 }\n             }\n@@ -978,13 +979,13 @@ find_section_list (const char *name, bfd_boolean add, unsigned int context)\n   if (! add)\n     {\n       if (match != NULL)\n-        match->used = TRUE;\n+        match->used = true;\n       return match;\n     }\n \n   p = (struct section_list *) xmalloc (sizeof (struct section_list));\n   p->pattern = name;\n-  p->used = FALSE;\n+  p->used = false;\n   p->context = context;\n   p->vma_val = 0;\n   p->lma_val = 0;\n@@ -1110,7 +1111,7 @@ add_specific_symbols (const char *filename, htab_t htab, char **buffer_p)\n       char * eol;\n       char * name;\n       char * name_end;\n-      int finished = FALSE;\n+      int finished = false;\n \n       for (eol = line;; eol ++)\n \t{\n@@ -1121,19 +1122,19 @@ add_specific_symbols (const char *filename, htab_t htab, char **buffer_p)\n \t      /* Cope with \\n\\r.  */\n \t      if (eol[1] == '\\r')\n \t\t++ eol;\n-\t      finished = TRUE;\n+\t      finished = true;\n \t      break;\n \n \t    case '\\r':\n \t      * eol = '\\0';\n \t      /* Cope with \\r\\n.  */\n \t      if (eol[1] == '\\n')\n \t\t++ eol;\n-\t      finished = TRUE;\n+\t      finished = true;\n \t      break;\n \n \t    case 0:\n-\t      finished = TRUE;\n+\t      finished = true;\n \t      break;\n \n \t    case '#':\n@@ -1204,7 +1205,7 @@ is_specified_symbol_predicate (void **slot, void *data)\n     {\n       if (! fnmatch (slot_name, d->name, 0))\n \t{\n-\t  d->found = TRUE;\n+\t  d->found = true;\n \t  /* Continue traversal, there might be a non-match rule.  */\n \t  return 1;\n \t}\n@@ -1213,7 +1214,7 @@ is_specified_symbol_predicate (void **slot, void *data)\n     {\n       if (! fnmatch (slot_name + 1, d->name, 0))\n \t{\n-\t  d->found = FALSE;\n+\t  d->found = false;\n \t  /* Stop traversal.  */\n \t  return 0;\n \t}\n@@ -1223,15 +1224,15 @@ is_specified_symbol_predicate (void **slot, void *data)\n   return 1;\n }\n \n-static bfd_boolean\n+static bool\n is_specified_symbol (const char *name, htab_t htab)\n {\n   if (wildcard)\n     {\n       struct is_specified_symbol_predicate_data data;\n \n       data.name = name;\n-      data.found = FALSE;\n+      data.found = false;\n \n       htab_traverse (htab, is_specified_symbol_predicate, &data);\n \n@@ -1271,25 +1272,25 @@ group_signature (asection *group)\n \n /* Return TRUE if the section is a DWO section.  */\n \n-static bfd_boolean\n+static bool\n is_dwo_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n {\n   const char *name;\n   int len;\n \n   if (sec == NULL || (name = bfd_section_name (sec)) == NULL)\n-    return FALSE;\n+    return false;\n \n   len = strlen (name);\n   if (len < 5)\n-    return FALSE;\n+    return false;\n \n   return strncmp (name + len - 4, \".dwo\", 4) == 0;\n }\n \n /* Return TRUE if section SEC is in the update list.  */\n \n-static bfd_boolean\n+static bool\n is_update_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n {\n   if (update_sections != NULL)\n@@ -1301,14 +1302,14 @@ is_update_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n \t   pupdate = pupdate->next)\n \t{\n \t  if (strcmp (sec->name, pupdate->name) == 0)\n-\t    return TRUE;\n+\t    return true;\n \t}\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n is_mergeable_note_section (bfd * abfd, asection * sec)\n {\n   if (merge_notes\n@@ -1317,28 +1318,28 @@ is_mergeable_note_section (bfd * abfd, asection * sec)\n       /* FIXME: We currently only support merging GNU_BUILD_NOTEs.\n \t We should add support for more note types.  */\n       && (startswith (sec->name, GNU_BUILD_ATTRS_SECTION_NAME)))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* See if a non-group section is being removed.  */\n \n-static bfd_boolean\n+static bool\n is_strip_section_1 (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n {\n-  if (find_section_list (bfd_section_name (sec), FALSE, SECTION_CONTEXT_KEEP)\n+  if (find_section_list (bfd_section_name (sec), false, SECTION_CONTEXT_KEEP)\n       != NULL)\n-    return FALSE;\n+    return false;\n \n   if (sections_removed || sections_copied)\n     {\n       struct section_list *p;\n       struct section_list *q;\n \n-      p = find_section_list (bfd_section_name (sec), FALSE,\n+      p = find_section_list (bfd_section_name (sec), false,\n \t\t\t     SECTION_CONTEXT_REMOVE);\n-      q = find_section_list (bfd_section_name (sec), FALSE,\n+      q = find_section_list (bfd_section_name (sec), false,\n \t\t\t     SECTION_CONTEXT_COPY);\n \n       if (p && q)\n@@ -1349,9 +1350,9 @@ is_strip_section_1 (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n \t       bfd_section_name (sec));\n \n       if (p != NULL)\n-\treturn TRUE;\n+\treturn true;\n       if (sections_copied && q == NULL)\n-\treturn TRUE;\n+\treturn true;\n     }\n \n   if ((bfd_section_flags (sec) & SEC_DEBUGGING) != 0)\n@@ -1366,29 +1367,29 @@ is_strip_section_1 (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n \t     This section has for pe-coff special meaning.   See\n \t     pe-dll.c file in ld, and peXXigen.c in bfd for details.  */\n \t  if (strcmp (bfd_section_name (sec), \".reloc\") != 0)\n-\t    return TRUE;\n+\t    return true;\n \t}\n \n       if (strip_symbols == STRIP_DWO)\n \treturn is_dwo_section (abfd, sec);\n \n       if (strip_symbols == STRIP_NONDEBUG)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (strip_symbols == STRIP_NONDWO)\n     return !is_dwo_section (abfd, sec);\n \n-  return FALSE;\n+  return false;\n }\n \n /* See if a section is being removed.  */\n \n-static bfd_boolean\n+static bool\n is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n {\n   if (is_strip_section_1 (abfd, sec))\n-    return TRUE;\n+    return true;\n \n   if ((bfd_section_flags (sec) & SEC_GROUP) != 0)\n     {\n@@ -1399,7 +1400,7 @@ is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n       gsym = group_signature (sec);\n       /* Strip groups without a valid signature.  */\n       if (gsym == NULL)\n-\treturn TRUE;\n+\treturn true;\n \n       /* PR binutils/3181\n \t If we are going to strip the group signature symbol, then\n@@ -1408,26 +1409,26 @@ is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)\n       if ((strip_symbols == STRIP_ALL\n \t   && !is_specified_symbol (gname, keep_specific_htab))\n \t  || is_specified_symbol (gname, strip_specific_htab))\n-\treturn TRUE;\n+\treturn true;\n \n       /* Remove the group section if all members are removed.  */\n       first = elt = elf_next_in_group (sec);\n       while (elt != NULL)\n \t{\n \t  if (!is_strip_section_1 (abfd, elt))\n-\t    return FALSE;\n+\t    return false;\n \t  elt = elf_next_in_group (elt);\n \t  if (elt == first)\n \t    break;\n \t}\n \n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n is_nondebug_keep_contents_section (bfd *ibfd, asection *isection)\n {\n   /* Always keep ELF note sections.  */\n@@ -1442,12 +1443,12 @@ is_nondebug_keep_contents_section (bfd *ibfd, asection *isection)\n   if (bfd_get_flavour (ibfd) == bfd_target_coff_flavour)\n     return strcmp (bfd_section_name (isection), \".buildid\") == 0;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Return true if SYM is a hidden symbol.  */\n \n-static bfd_boolean\n+static bool\n is_hidden_symbol (asymbol *sym)\n {\n   elf_symbol_type *elf_sym;\n@@ -1458,15 +1459,15 @@ is_hidden_symbol (asymbol *sym)\n       {\n       case STV_HIDDEN:\n       case STV_INTERNAL:\n-\treturn TRUE;\n+\treturn true;\n       }\n-  return FALSE;\n+  return false;\n }\n \n /* Empty name is hopefully never a valid symbol name.  */\n static const char * empty_name = \"\";\n \n-static bfd_boolean\n+static bool\n need_sym_before (struct addsym_node **node, const char *sym)\n {\n   int count;\n@@ -1484,11 +1485,11 @@ need_sym_before (struct addsym_node **node, const char *sym)\n \t  free ((char *) ptr->othersym);\n \t  ptr->othersym = empty_name;\n \t  *node = ptr;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       ptr = ptr->next;\n     }\n-  return FALSE;\n+  return false;\n }\n \n static asymbol *\n@@ -1528,11 +1529,11 @@ filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,\n       asymbol *sym = from[src_count];\n       flagword flags = sym->flags;\n       char *name = (char *) bfd_asymbol_name (sym);\n-      bfd_boolean keep;\n-      bfd_boolean used_in_reloc = FALSE;\n-      bfd_boolean undefined;\n-      bfd_boolean rem_leading_char;\n-      bfd_boolean add_leading_char;\n+      bool keep;\n+      bool used_in_reloc = false;\n+      bool undefined;\n+      bool rem_leading_char;\n+      bool add_leading_char;\n \n       undefined = bfd_is_und_section (bfd_asymbol_section (sym));\n \n@@ -1578,8 +1579,8 @@ filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,\n \t{\n \t  name[0] = bfd_get_symbol_leading_char (obfd);\n \t  bfd_set_asymbol_name (sym, name);\n-\t  rem_leading_char = FALSE;\n-\t  add_leading_char = FALSE;\n+\t  rem_leading_char = false;\n+\t  add_leading_char = false;\n \t}\n \n       /* Remove leading char.  */\n@@ -1613,25 +1614,25 @@ filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,\n \t}\n \n       if (strip_symbols == STRIP_ALL)\n-\tkeep = FALSE;\n+\tkeep = false;\n       else if ((flags & BSF_KEEP) != 0\t\t/* Used in relocation.  */\n \t       || ((flags & BSF_SECTION_SYM) != 0\n \t\t   && ((*bfd_asymbol_section (sym)->symbol_ptr_ptr)->flags\n \t\t       & BSF_KEEP) != 0))\n \t{\n-\t  keep = TRUE;\n-\t  used_in_reloc = TRUE;\n+\t  keep = true;\n+\t  used_in_reloc = true;\n \t}\n       else if (relocatable\t\t\t/* Relocatable file.  */\n \t       && ((flags & (BSF_GLOBAL | BSF_WEAK)) != 0\n \t\t   || bfd_is_com_section (bfd_asymbol_section (sym))))\n-\tkeep = TRUE;\n+\tkeep = true;\n       else if (bfd_decode_symclass (sym) == 'I')\n \t/* Global symbols in $idata sections need to be retained\n \t   even if relocatable is FALSE.  External users of the\n \t   library containing the $idata section may reference these\n \t   symbols.  */\n-\tkeep = TRUE;\n+\tkeep = true;\n       else if ((flags & BSF_GLOBAL) != 0\t/* Global symbol.  */\n \t       || (flags & BSF_WEAK) != 0\n \t       || undefined\n@@ -1644,7 +1645,7 @@ filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,\n       else if (bfd_coff_get_comdat_section (abfd, bfd_asymbol_section (sym)))\n \t/* COMDAT sections store special information in local\n \t   symbols, so we cannot risk stripping any of them.  */\n-\tkeep = TRUE;\n+\tkeep = true;\n       else\t\t\t/* Local symbol.  */\n \tkeep = (strip_symbols != STRIP_UNNEEDED\n \t\t&& (discard_locals != LOCALS_ALL\n@@ -1661,21 +1662,21 @@ filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,\n \t      status = 1;\n \t    }\n \t  else\n-\t    keep = FALSE;\n+\t    keep = false;\n \t}\n \n       if (keep\n \t  && !(flags & BSF_KEEP)\n \t  && is_specified_symbol (name, strip_unneeded_htab))\n-\tkeep = FALSE;\n+\tkeep = false;\n \n       if (!keep\n \t  && ((keep_file_symbols && (flags & BSF_FILE))\n \t      || is_specified_symbol (name, keep_specific_htab)))\n-\tkeep = TRUE;\n+\tkeep = true;\n \n       if (keep && is_strip_section (abfd, bfd_asymbol_section (sym)))\n-\tkeep = FALSE;\n+\tkeep = false;\n \n       if (keep)\n \t{\n@@ -1888,7 +1889,7 @@ add_redefine_syms_file (const char *filename)\n /* Copy unknown object file IBFD onto OBFD.\n    Returns TRUE upon success, FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n copy_unknown_object (bfd *ibfd, bfd *obfd)\n {\n   char *cbuf;\n@@ -1900,21 +1901,21 @@ copy_unknown_object (bfd *ibfd, bfd *obfd)\n   if (bfd_stat_arch_elt (ibfd, &buf) != 0)\n     {\n       bfd_nonfatal_message (NULL, ibfd, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n \n   size = buf.st_size;\n   if (size < 0)\n     {\n       non_fatal (_(\"stat returns negative size for `%s'\"),\n \t\t bfd_get_archive_filename (ibfd));\n-      return FALSE;\n+      return false;\n     }\n \n   if (bfd_seek (ibfd, (file_ptr) 0, SEEK_SET) != 0)\n     {\n       bfd_nonfatal (bfd_get_archive_filename (ibfd));\n-      return FALSE;\n+      return false;\n     }\n \n   if (verbose)\n@@ -1934,15 +1935,15 @@ copy_unknown_object (bfd *ibfd, bfd *obfd)\n \t{\n \t  bfd_nonfatal_message (NULL, ibfd, NULL, NULL);\n \t  free (cbuf);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (bfd_bwrite (cbuf, (bfd_size_type) tocopy, obfd)\n \t  != (bfd_size_type) tocopy)\n \t{\n \t  bfd_nonfatal_message (NULL, obfd, NULL, NULL);\n \t  free (cbuf);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       ncopied += tocopy;\n@@ -1952,7 +1953,7 @@ copy_unknown_object (bfd *ibfd, bfd *obfd)\n      unknown object in an archive.  */\n   chmod (bfd_get_filename (obfd), buf.st_mode | S_IRUSR);\n   free (cbuf);\n-  return TRUE;\n+  return true;\n }\n \n typedef struct objcopy_internal_note\n@@ -1973,7 +1974,7 @@ typedef struct objcopy_internal_note\n \n /* Returns TRUE iff PNOTE1 overlaps or adjoins PNOTE2.  */\n \n-static bfd_boolean\n+static bool\n overlaps_or_adjoins (objcopy_internal_note * pnote1,\n \t\t     objcopy_internal_note * pnote2)\n {\n@@ -1987,42 +1988,42 @@ overlaps_or_adjoins (objcopy_internal_note * pnote1,\n     return BFD_ALIGN (pnote2->end, 16) < pnote1->start;\n \n   if (pnote1->end < pnote2->end)\n-    return TRUE;\n+    return true;\n \n   if (pnote2->end < pnote1->end)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Returns TRUE iff NEEDLE is fully contained by HAYSTACK.  */\n \n-static bfd_boolean\n+static bool\n contained_by (objcopy_internal_note * needle,\n \t      objcopy_internal_note * haystack)\n {\n   return needle->start >= haystack->start && needle->end <= haystack->end;\n }\n \n-static bfd_boolean\n+static bool\n is_open_note (objcopy_internal_note * pnote)\n {\n   return pnote->note.type == NT_GNU_BUILD_ATTRIBUTE_OPEN;\n }\n \n-static bfd_boolean\n+static bool\n is_func_note (objcopy_internal_note * pnote)\n {\n   return pnote->note.type == NT_GNU_BUILD_ATTRIBUTE_FUNC;\n }\n \n-static bfd_boolean\n+static bool\n is_deleted_note (objcopy_internal_note * pnote)\n {\n   return pnote->note.type == 0;\n }\n \n-static bfd_boolean\n+static bool\n is_version_note (objcopy_internal_note * pnote)\n {\n   return (pnote->note.namesz > 4\n@@ -2032,12 +2033,12 @@ is_version_note (objcopy_internal_note * pnote)\n \t  && pnote->note.namedata[3] == GNU_BUILD_ATTRIBUTE_VERSION);\n }\n \n-static bfd_boolean\n+static bool\n is_64bit (bfd * abfd)\n {\n   /* Should never happen, but let's be paranoid.  */\n   if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)\n-    return FALSE;\n+    return false;\n \n   return elf_elfheader (abfd)->e_ident[EI_CLASS] == ELFCLASS64;\n }\n@@ -2582,7 +2583,7 @@ check_new_section_flags (flagword flags, bfd * abfd, const char * secname)\n /* Copy object file IBFD onto OBFD.\n    Returns TRUE upon success, FALSE otherwise.  */\n \n-static bfd_boolean\n+static bool\n copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n {\n   bfd_vma start;\n@@ -2606,27 +2607,27 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t may need to tidy temporary files.  */\n       non_fatal (_(\"unable to change endianness of '%s'\"),\n \t\t bfd_get_archive_filename (ibfd));\n-      return FALSE;\n+      return false;\n     }\n \n   if (ibfd->read_only)\n     {\n       non_fatal (_(\"unable to modify '%s' due to errors\"),\n \t\t bfd_get_archive_filename (ibfd));\n-      return FALSE;\n+      return false;\n     }\n \n   if (!bfd_set_format (obfd, bfd_get_format (ibfd)))\n     {\n       bfd_nonfatal_message (NULL, obfd, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n \n   if (ibfd->sections == NULL)\n     {\n       non_fatal (_(\"error: the input file '%s' has no sections\"),\n \t\t bfd_get_archive_filename (ibfd));\n-      return FALSE;\n+      return false;\n     }\n \n   if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)\n@@ -2636,14 +2637,14 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t{\n \t  non_fatal (_(\"--compress-debug-sections=[zlib|zlib-gnu|zlib-gabi] is unsupported on `%s'\"),\n \t\t     bfd_get_archive_filename (ibfd));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (do_elf_stt_common)\n \t{\n \t  non_fatal (_(\"--elf-stt-common=[yes|no] is unsupported on `%s'\"),\n \t\t     bfd_get_archive_filename (ibfd));\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n@@ -2681,7 +2682,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t  || !bfd_set_file_flags (obfd, flags))\n \t{\n \t  bfd_nonfatal_message (NULL, ibfd, NULL, NULL);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n@@ -2718,13 +2719,13 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \tnon_fatal (_(\"Output file cannot represent architecture `%s'\"),\n \t\t   bfd_printable_arch_mach (bfd_get_arch (ibfd),\n \t\t\t\t\t    bfd_get_mach (ibfd)));\n-      return FALSE;\n+      return false;\n     }\n \n   if (!bfd_set_format (obfd, bfd_get_format (ibfd)))\n     {\n       bfd_nonfatal_message (NULL, ibfd, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n \n   if (bfd_get_flavour (obfd) == bfd_target_coff_flavour\n@@ -2801,15 +2802,15 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n   if (symsize < 0)\n     {\n       bfd_nonfatal_message (NULL, ibfd, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n \n   osympp = isympp = (asymbol **) xmalloc (symsize);\n   symcount = bfd_canonicalize_symtab (ibfd, isympp);\n   if (symcount < 0)\n     {\n       bfd_nonfatal_message (NULL, ibfd, NULL, NULL);\n-      return FALSE;\n+      return false;\n     }\n   /* PR 17512: file:  d6323821\n      If the symbol table could not be loaded do not pretend that we have\n@@ -2836,7 +2837,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t{\n \t  flagword flags;\n \n-\t  pset = find_section_list (padd->name, FALSE,\n+\t  pset = find_section_list (padd->name, false,\n \t\t\t\t    SECTION_CONTEXT_SET_FLAGS);\n \t  if (pset != NULL)\n \t    {\t      \n@@ -2852,7 +2853,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t\t    _(\"can't add section '%s'\"), padd->name);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  else\n \t    {\n@@ -2867,26 +2868,26 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t  bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t\t\t_(\"can't create section `%s'\"),\n \t\t\t\t\tpadd->name);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t    }\n \n \t  if (!bfd_set_section_size (padd->section, padd->size))\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n-\t  pset = find_section_list (padd->name, FALSE,\n+\t  pset = find_section_list (padd->name, false,\n \t\t\t\t    SECTION_CONTEXT_SET_VMA | SECTION_CONTEXT_ALTER_VMA);\n \t  if (pset != NULL\n \t      && !bfd_set_section_vma (padd->section, pset->vma_val))\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n-\t  pset = find_section_list (padd->name, FALSE,\n+\t  pset = find_section_list (padd->name, false,\n \t\t\t\t    SECTION_CONTEXT_SET_LMA | SECTION_CONTEXT_ALTER_LMA);\n \t  if (pset != NULL)\n \t    {\n@@ -2896,7 +2897,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t  (padd->section, bfd_section_alignment (padd->section)))\n \t\t{\n \t\t  bfd_nonfatal_message (NULL, obfd, padd->section, NULL);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t    }\n \t}\n@@ -2914,14 +2915,14 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t  if (pupdate->section == NULL)\n \t    {\n \t      non_fatal (_(\"error: %s not found, can't be updated\"), pupdate->name);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  osec = pupdate->section->output_section;\n \t  if (!bfd_set_section_size (osec, pupdate->size))\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, osec, NULL);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n     }\n@@ -3030,7 +3031,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t\t     strerror (errno));\n \t\t  free (contents);\n \t\t  fclose (f);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t    }\n \t  else\n@@ -3063,7 +3064,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t      bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t\t    _(\"cannot create debug link section `%s'\"),\n \t\t\t\t    gnu_debuglink_filename);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  /* Special processing for PE format files.  We\n@@ -3197,7 +3198,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n      have been created, but before their contents are set.  */\n   dhandle = NULL;\n   if (convert_debugging)\n-    dhandle = read_debugging_info (ibfd, isympp, symcount, FALSE);\n+    dhandle = read_debugging_info (ibfd, isympp, symcount, false);\n \n    if ((obfd->flags & (EXEC_P | DYNAMIC)) != 0\n        && (obfd->flags & HAS_RELOC) == 0)\n@@ -3265,7 +3266,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t  if (bfd_get_error () != bfd_error_no_error)\n \t    {\n \t      status = 1;\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \n@@ -3275,7 +3276,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \n   if (convert_debugging && dhandle != NULL)\n     {\n-      bfd_boolean res;\n+      bool res;\n \n       res = write_debugging_info (obfd, dhandle, &symcount, &osympp);\n \n@@ -3285,7 +3286,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n       if (! res)\n \t{\n \t  status = 1;\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n@@ -3307,7 +3308,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t\t\t\t  0, padd->size))\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n     }\n@@ -3325,7 +3326,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t\t\t\t  0, pupdate->size))\n \t    {\n \t      bfd_nonfatal_message (NULL, obfd, osec, NULL);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n     }\n@@ -3376,7 +3377,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t      bfd_nonfatal_message\n \t\t(NULL, obfd, osec,\n \t\t _(\"error: failed to copy merged notes into output\"));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  merged = merged->next;\n@@ -3403,7 +3404,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t  bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t\t_(\"cannot fill debug link section `%s'\"),\n \t\t\t\tgnu_debuglink_filename);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n@@ -3441,7 +3442,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t\t    {\n \t\t      bfd_nonfatal_message (NULL, obfd, osections[i], NULL);\n \t\t      free (buf);\n-\t\t      return FALSE;\n+\t\t      return false;\n \t\t    }\n \n \t\t  left -= now;\n@@ -3463,7 +3464,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n     {\n       bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t    _(\"error copying private BFD data\"));\n-      return FALSE;\n+      return false;\n     }\n \n   /* Switch to the alternate machine code.  We have to do this at the\n@@ -3485,7 +3486,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Read each archive element in turn from IBFD, copy the\n@@ -3496,7 +3497,7 @@ copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)\n \n static void\n copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,\n-\t      bfd_boolean force_output_target,\n+\t      bool force_output_target,\n \t      const bfd_arch_info_type *input_arch)\n {\n   struct name_list\n@@ -3538,7 +3539,7 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,\n \t   strerror (errno));\n \n   if (strip_symbols == STRIP_ALL)\n-    obfd->has_armap = FALSE;\n+    obfd->has_armap = false;\n   else\n     obfd->has_armap = ibfd->has_armap;\n   obfd->is_thin_archive = ibfd->is_thin_archive;\n@@ -3564,8 +3565,8 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,\n       bfd *last_element;\n       struct stat buf;\n       int stat_status = 0;\n-      bfd_boolean del = TRUE;\n-      bfd_boolean ok_object;\n+      bool del = true;\n+      bool ok_object;\n \n       /* PR binutils/17533: Do not allow directory traversal\n \t outside of the current directory tree by archive members.  */\n@@ -3644,7 +3645,7 @@ copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,\n \n \t  if (del && bfd_get_arch (this_element) == bfd_arch_unknown)\n \t    /* Try again as an unknown object file.  */\n-\t    ok_object = FALSE;\n+\t    ok_object = false;\n \t  else if (!bfd_close (output_bfd))\n \t    {\n \t      bfd_nonfatal_message (output_name, NULL, NULL, NULL);\n@@ -3805,18 +3806,18 @@ copy_file (const char *input_filename, const char *output_filename, int ofd,\n \n   if (bfd_check_format (ibfd, bfd_archive))\n     {\n-      bfd_boolean force_output_target;\n+      bool force_output_target;\n       bfd *obfd;\n \n       /* bfd_get_target does not return the correct value until\n \t bfd_check_format succeeds.  */\n       if (output_target == NULL)\n \t{\n \t  output_target = bfd_get_target (ibfd);\n-\t  force_output_target = FALSE;\n+\t  force_output_target = false;\n \t}\n       else\n-\tforce_output_target = TRUE;\n+\tforce_output_target = true;\n \n       if (ofd >= 0)\n \tobfd = bfd_fdopenw (output_filename, output_target, ofd);\n@@ -4013,7 +4014,7 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n   const char * name;\n   const char * new_name;\n   char *prefix = NULL;\n-  bfd_boolean make_nobits;\n+  bool make_nobits;\n   unsigned int alignment;\n \n   if (is_strip_section (ibfd, isection))\n@@ -4051,9 +4052,9 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n       name = n;\n     }\n \n-  make_nobits = FALSE;\n+  make_nobits = false;\n \n-  p = find_section_list (bfd_section_name (isection), FALSE,\n+  p = find_section_list (bfd_section_name (isection), false,\n \t\t\t SECTION_CONTEXT_SET_FLAGS);\n   if (p != NULL)\n     {\n@@ -4067,7 +4068,7 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n       flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD | SEC_GROUP);\n       if (bfd_get_flavour (obfd) == bfd_target_elf_flavour)\n \t{\n-\t  make_nobits = TRUE;\n+\t  make_nobits = true;\n \n \t  /* Twiddle the input section flags so that it seems to\n \t     elf.c:copy_private_bfd_data that section flags have not\n@@ -4101,7 +4102,7 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n     }\n \n   vma = bfd_section_vma (isection);\n-  p = find_section_list (bfd_section_name (isection), FALSE,\n+  p = find_section_list (bfd_section_name (isection), false,\n \t\t\t SECTION_CONTEXT_ALTER_VMA | SECTION_CONTEXT_SET_VMA);\n   if (p != NULL)\n     {\n@@ -4120,7 +4121,7 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n     }\n \n   lma = isection->lma;\n-  p = find_section_list (bfd_section_name (isection), FALSE,\n+  p = find_section_list (bfd_section_name (isection), false,\n \t\t\t SECTION_CONTEXT_ALTER_LMA | SECTION_CONTEXT_SET_LMA);\n   if (p != NULL)\n     {\n@@ -4134,7 +4135,7 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n \n   osection->lma = lma;\n \n-  p = find_section_list (bfd_section_name (isection), FALSE,\n+  p = find_section_list (bfd_section_name (isection), false,\n \t\t\t SECTION_CONTEXT_SET_ALIGNMENT);\n   if (p != NULL)\n     alignment = p->alignment;\n@@ -4191,8 +4192,8 @@ setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n \n /* Return TRUE if input section ISECTION should be skipped.  */\n \n-static bfd_boolean\n-skip_section (bfd *ibfd, sec_ptr isection, bfd_boolean skip_copy)\n+static bool\n+skip_section (bfd *ibfd, sec_ptr isection, bool skip_copy)\n {\n   sec_ptr osection;\n   bfd_size_type size;\n@@ -4201,33 +4202,33 @@ skip_section (bfd *ibfd, sec_ptr isection, bfd_boolean skip_copy)\n   /* If we have already failed earlier on,\n      do not keep on generating complaints now.  */\n   if (status != 0)\n-    return TRUE;\n+    return true;\n \n   if (extract_symbol)\n-    return TRUE;\n+    return true;\n \n   if (is_strip_section (ibfd, isection))\n-    return TRUE;\n+    return true;\n \n   if (is_update_section (ibfd, isection))\n-    return TRUE;\n+    return true;\n \n   /* When merging a note section we skip the copying of the contents,\n      but not the copying of the relocs associated with the contents.  */\n   if (skip_copy && is_mergeable_note_section (ibfd, isection))\n-    return TRUE;\n+    return true;\n \n   flags = bfd_section_flags (isection);\n   if ((flags & SEC_GROUP) != 0)\n-    return TRUE;\n+    return true;\n \n   osection = isection->output_section;\n   size = bfd_section_size (isection);\n \n   if (size == 0 || osection == 0)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Add section SECTION_PATTERN to the list of sections that will have their\n@@ -4236,18 +4237,18 @@ skip_section (bfd *ibfd, sec_ptr isection, bfd_boolean skip_copy)\n static void\n handle_remove_relocations_option (const char *section_pattern)\n {\n-  find_section_list (section_pattern, TRUE, SECTION_CONTEXT_REMOVE_RELOCS);\n+  find_section_list (section_pattern, true, SECTION_CONTEXT_REMOVE_RELOCS);\n }\n \n /* Return TRUE if ISECTION from IBFD should have its relocations removed,\n    otherwise return FALSE.  If the user has requested that relocations be\n    removed from a section that does not have relocations then this\n    function will still return TRUE.  */\n \n-static bfd_boolean\n+static bool\n discard_relocations (bfd *ibfd ATTRIBUTE_UNUSED, asection *isection)\n {\n-  return (find_section_list (bfd_section_name (isection), FALSE,\n+  return (find_section_list (bfd_section_name (isection), false,\n \t\t\t     SECTION_CONTEXT_REMOVE_RELOCS) != NULL);\n }\n \n@@ -4259,7 +4260,7 @@ discard_relocations (bfd *ibfd ATTRIBUTE_UNUSED, asection *isection)\n static void\n handle_remove_section_option (const char *section_pattern)\n {\n-  find_section_list (section_pattern, TRUE, SECTION_CONTEXT_REMOVE);\n+  find_section_list (section_pattern, true, SECTION_CONTEXT_REMOVE);\n   if (strncmp (section_pattern, \".rel\", 4) == 0)\n     {\n       section_pattern += 4;\n@@ -4268,7 +4269,7 @@ handle_remove_section_option (const char *section_pattern)\n       if (*section_pattern)\n \thandle_remove_relocations_option (section_pattern);\n     }\n-  sections_removed = TRUE;\n+  sections_removed = true;\n }\n \n /* Copy relocations in input section ISECTION of IBFD to an output\n@@ -4284,7 +4285,7 @@ copy_relocations_in_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n   long relcount;\n   sec_ptr osection;\n \n- if (skip_section (ibfd, isection, FALSE))\n+ if (skip_section (ibfd, isection, false))\n     return;\n \n   osection = isection->output_section;\n@@ -4386,7 +4387,7 @@ copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n   sec_ptr osection;\n   bfd_size_type size;\n \n-  if (skip_section (ibfd, isection, TRUE))\n+  if (skip_section (ibfd, isection, true))\n     return;\n \n   osection = isection->output_section;\n@@ -4478,7 +4479,7 @@ copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)\n       free (memhunk);\n     }\n   else if ((p = find_section_list (bfd_section_name (isection),\n-\t\t\t\t   FALSE, SECTION_CONTEXT_SET_FLAGS)) != NULL\n+\t\t\t\t   false, SECTION_CONTEXT_SET_FLAGS)) != NULL\n \t   && (p->flags & SEC_HAS_CONTENTS) != 0)\n     {\n       void *memhunk = xmalloc (size);\n@@ -4612,7 +4613,7 @@ mark_symbols_used_in_relocations (bfd *ibfd, sec_ptr isection, void *symbolsarg)\n \n /* Write out debugging information.  */\n \n-static bfd_boolean\n+static bool\n write_debugging_info (bfd *obfd, void *dhandle,\n \t\t      long *symcountp ATTRIBUTE_UNUSED,\n \t\t      asymbol ***symppp ATTRIBUTE_UNUSED)\n@@ -4628,7 +4629,7 @@ write_debugging_info (bfd *obfd, void *dhandle,\n       if (! write_stabs_in_sections_debugging_info (obfd, dhandle, &syms,\n \t\t\t\t\t\t    &symsize, &strings,\n \t\t\t\t\t\t    &stringsize))\n-\treturn FALSE;\n+\treturn false;\n \n       flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING;\n       stabsec = bfd_make_section_with_flags (obfd, \".stab\", flags);\n@@ -4643,7 +4644,7 @@ write_debugging_info (bfd *obfd, void *dhandle,\n \t  bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t\t_(\"can't create debugging section\"));\n \t  free (strings);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       /* We can get away with setting the section contents now because\n@@ -4657,16 +4658,16 @@ write_debugging_info (bfd *obfd, void *dhandle,\n \t  bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t\t_(\"can't set debugging section contents\"));\n \t  free (strings);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n-      return TRUE;\n+      return true;\n     }\n \n   bfd_nonfatal_message (NULL, obfd, NULL,\n \t\t\t_(\"don't know how to write debugging information for %s\"),\n \t\t\tbfd_get_target (obfd));\n-  return FALSE;\n+  return false;\n }\n \n /* If neither -D nor -U was specified explicitly,\n@@ -4683,12 +4684,12 @@ strip_main (int argc, char *argv[])\n {\n   char *input_target = NULL;\n   char *output_target = NULL;\n-  bfd_boolean show_version = FALSE;\n-  bfd_boolean formats_info = FALSE;\n+  bool show_version = false;\n+  bool formats_info = false;\n   int c;\n   int i;\n   char *output_file = NULL;\n-  bfd_boolean merge_notes_set = FALSE;\n+  bool merge_notes_set = false;\n \n   while ((c = getopt_long (argc, argv, \"I:O:F:K:MN:R:o:sSpdgxXHhVvwDU\",\n \t\t\t   strip_options, (int *) 0)) != EOF)\n@@ -4708,7 +4709,7 @@ strip_main (int argc, char *argv[])\n \t  handle_remove_section_option (optarg);\n \t  break;\n \tcase OPTION_KEEP_SECTION:\n-\t  find_section_list (optarg, TRUE, SECTION_CONTEXT_KEEP);\n+\t  find_section_list (optarg, true, SECTION_CONTEXT_KEEP);\n \t  break;\n \tcase OPTION_REMOVE_RELOCS:\n \t  handle_remove_relocations_option (optarg);\n@@ -4731,12 +4732,12 @@ strip_main (int argc, char *argv[])\n \t  add_specific_symbol (optarg, keep_specific_htab);\n \t  break;\n \tcase 'M':\n-\t  merge_notes = TRUE;\n-\t  merge_notes_set = TRUE;\n+\t  merge_notes = true;\n+\t  merge_notes_set = true;\n \t  break;\n \tcase OPTION_NO_MERGE_NOTES:\n-\t  merge_notes = FALSE;\n-\t  merge_notes_set = TRUE;\n+\t  merge_notes = false;\n+\t  merge_notes_set = true;\n \t  break;\n \tcase 'N':\n \t  add_specific_symbol (optarg, strip_specific_htab);\n@@ -4745,13 +4746,13 @@ strip_main (int argc, char *argv[])\n \t  output_file = optarg;\n \t  break;\n \tcase 'p':\n-\t  preserve_dates = TRUE;\n+\t  preserve_dates = true;\n \t  break;\n \tcase 'D':\n-\t  deterministic = TRUE;\n+\t  deterministic = true;\n \t  break;\n \tcase 'U':\n-\t  deterministic = FALSE;\n+\t  deterministic = false;\n \t  break;\n \tcase 'x':\n \t  discard_locals = LOCALS_ALL;\n@@ -4760,13 +4761,13 @@ strip_main (int argc, char *argv[])\n \t  discard_locals = LOCALS_START_L;\n \t  break;\n \tcase 'v':\n-\t  verbose = TRUE;\n+\t  verbose = true;\n \t  break;\n \tcase 'V':\n-\t  show_version = TRUE;\n+\t  show_version = true;\n \t  break;\n \tcase OPTION_FORMATS_INFO:\n-\t  formats_info = TRUE;\n+\t  formats_info = true;\n \t  break;\n \tcase OPTION_ONLY_KEEP_DEBUG:\n \t  strip_symbols = STRIP_NONDEBUG;\n@@ -4775,13 +4776,13 @@ strip_main (int argc, char *argv[])\n \t  keep_file_symbols = 1;\n \t  break;\n \tcase OPTION_KEEP_SECTION_SYMBOLS:\n-\t  keep_section_symbols = TRUE;\n+\t  keep_section_symbols = true;\n \t  break;\n \tcase 0:\n \t  /* We've been given a long option.  */\n \t  break;\n \tcase 'w':\n-\t  wildcard = TRUE;\n+\t  wildcard = true;\n \t  break;\n \tcase 'H':\n \tcase 'h':\n@@ -4799,7 +4800,7 @@ strip_main (int argc, char *argv[])\n \t  || strip_symbols == STRIP_UNNEEDED\n \t  || strip_symbols == STRIP_NONDEBUG\n \t  || strip_symbols == STRIP_NONDWO))\n-    merge_notes = TRUE;\n+    merge_notes = true;\n \n   if (formats_info)\n     {\n@@ -5077,11 +5078,11 @@ copy_main (int argc, char *argv[])\n   char *tmpname;\n   char *input_target = NULL;\n   char *output_target = NULL;\n-  bfd_boolean show_version = FALSE;\n-  bfd_boolean change_warn = TRUE;\n-  bfd_boolean formats_info = FALSE;\n-  bfd_boolean use_globalize = FALSE;\n-  bfd_boolean use_keep_global = FALSE;\n+  bool show_version = false;\n+  bool change_warn = true;\n+  bool formats_info = false;\n+  bool use_globalize = false;\n+  bool use_keep_global = false;\n   int c;\n   int tmpfd = -1;\n   int copyfd;\n@@ -5137,16 +5138,16 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase 'j':\n-\t  find_section_list (optarg, TRUE, SECTION_CONTEXT_COPY);\n-\t  sections_copied = TRUE;\n+\t  find_section_list (optarg, true, SECTION_CONTEXT_COPY);\n+\t  sections_copied = true;\n \t  break;\n \n \tcase 'R':\n \t  handle_remove_section_option (optarg);\n \t  break;\n \n \tcase OPTION_KEEP_SECTION:\n-\t  find_section_list (optarg, TRUE, SECTION_CONTEXT_KEEP);\n+\t  find_section_list (optarg, true, SECTION_CONTEXT_KEEP);\n \t  break;\n \n         case OPTION_REMOVE_RELOCS:\n@@ -5187,10 +5188,10 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase 'M':\n-\t  merge_notes = TRUE;\n+\t  merge_notes = true;\n \t  break;\n \tcase OPTION_NO_MERGE_NOTES:\n-\t  merge_notes = FALSE;\n+\t  merge_notes = false;\n \t  break;\n \n \tcase 'N':\n@@ -5206,12 +5207,12 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase OPTION_GLOBALIZE_SYMBOL:\n-\t  use_globalize = TRUE;\n+\t  use_globalize = true;\n \t  add_specific_symbol (optarg, globalize_specific_htab);\n \t  break;\n \n \tcase 'G':\n-\t  use_keep_global = TRUE;\n+\t  use_keep_global = true;\n \t  add_specific_symbol (optarg, keepglobal_specific_htab);\n \t  break;\n \n@@ -5220,19 +5221,19 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase 'p':\n-\t  preserve_dates = TRUE;\n+\t  preserve_dates = true;\n \t  break;\n \n \tcase 'D':\n-\t  deterministic = TRUE;\n+\t  deterministic = true;\n \t  break;\n \n \tcase 'U':\n-\t  deterministic = FALSE;\n+\t  deterministic = false;\n \t  break;\n \n \tcase 'w':\n-\t  wildcard = TRUE;\n+\t  wildcard = true;\n \t  break;\n \n \tcase 'x':\n@@ -5244,19 +5245,19 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase 'v':\n-\t  verbose = TRUE;\n+\t  verbose = true;\n \t  break;\n \n \tcase 'V':\n-\t  show_version = TRUE;\n+\t  show_version = true;\n \t  break;\n \n \tcase OPTION_FORMATS_INFO:\n-\t  formats_info = TRUE;\n+\t  formats_info = true;\n \t  break;\n \n \tcase OPTION_WEAKEN:\n-\t  weaken = TRUE;\n+\t  weaken = true;\n \t  break;\n \n \tcase OPTION_ADD_SECTION:\n@@ -5389,7 +5390,7 @@ copy_main (int argc, char *argv[])\n \t    strncpy (name, optarg, len);\n \t    name[len] = '\\0';\n \n-\t    p = find_section_list (name, TRUE, context);\n+\t    p = find_section_list (name, true, context);\n \n \t    val = parse_vma (s + 1, option);\n \t    if (*s == '-')\n@@ -5418,11 +5419,11 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase OPTION_CHANGE_WARNINGS:\n-\t  change_warn = TRUE;\n+\t  change_warn = true;\n \t  break;\n \n \tcase OPTION_CHANGE_LEADING_CHAR:\n-\t  change_leading_char = TRUE;\n+\t  change_leading_char = true;\n \t  break;\n \n \tcase OPTION_COMPRESS_DEBUG_SECTIONS:\n@@ -5445,7 +5446,7 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase OPTION_DEBUGGING:\n-\t  convert_debugging = TRUE;\n+\t  convert_debugging = true;\n \t  break;\n \n \tcase OPTION_DECOMPRESS_DEBUG_SECTIONS:\n@@ -5477,21 +5478,21 @@ copy_main (int argc, char *argv[])\n \t\tnon_fatal (_(\"Warning: truncating gap-fill from 0x%s to 0x%x\"),\n \t\t\t   buff, gap_fill);\n \t      }\n-\t    gap_fill_set = TRUE;\n+\t    gap_fill_set = true;\n \t  }\n \t  break;\n \n \tcase OPTION_NO_CHANGE_WARNINGS:\n-\t  change_warn = FALSE;\n+\t  change_warn = false;\n \t  break;\n \n \tcase OPTION_PAD_TO:\n \t  pad_to = parse_vma (optarg, \"--pad-to\");\n-\t  pad_to_set = TRUE;\n+\t  pad_to_set = true;\n \t  break;\n \n \tcase OPTION_REMOVE_LEADING_CHAR:\n-\t  remove_leading_char = TRUE;\n+\t  remove_leading_char = true;\n \t  break;\n \n \tcase OPTION_REDEFINE_SYM:\n@@ -5544,7 +5545,7 @@ copy_main (int argc, char *argv[])\n \t    strncpy (name, optarg, len);\n \t    name[len] = '\\0';\n \n-\t    p = find_section_list (name, TRUE, SECTION_CONTEXT_SET_FLAGS);\n+\t    p = find_section_list (name, true, SECTION_CONTEXT_SET_FLAGS);\n \n \t    p->flags = parse_flags (s + 1);\n \t  }\n@@ -5584,7 +5585,7 @@ copy_main (int argc, char *argv[])\n \t    strncpy (name, optarg, len);\n \t    name[len] = '\\0';\n \n-\t    p = find_section_list (name, TRUE, SECTION_CONTEXT_SET_ALIGNMENT);\n+\t    p = find_section_list (name, true, SECTION_CONTEXT_SET_ALIGNMENT);\n \t    if (p)\n \t      p->alignment = palign;\n \t  }\n@@ -5636,15 +5637,15 @@ copy_main (int argc, char *argv[])\n \n \tcase OPTION_SET_START:\n \t  set_start = parse_vma (optarg, \"--set-start\");\n-\t  set_start_set = TRUE;\n+\t  set_start_set = true;\n \t  break;\n \n \tcase OPTION_SREC_LEN:\n \t  _bfd_srec_len = parse_vma (optarg, \"--srec-len\");\n \t  break;\n \n \tcase OPTION_SREC_FORCES3:\n-\t  _bfd_srec_forceS3 = TRUE;\n+\t  _bfd_srec_forceS3 = true;\n \t  break;\n \n \tcase OPTION_STRIP_SYMBOLS:\n@@ -5663,11 +5664,11 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase OPTION_KEEP_SECTION_SYMBOLS:\n-\t  keep_section_symbols = TRUE;\n+\t  keep_section_symbols = true;\n \t  break;\n \n \tcase OPTION_LOCALIZE_HIDDEN:\n-\t  localize_hidden = TRUE;\n+\t  localize_hidden = true;\n \t  break;\n \n \tcase OPTION_LOCALIZE_SYMBOLS:\n@@ -5687,13 +5688,13 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase OPTION_GLOBALIZE_SYMBOLS:\n-\t  use_globalize = TRUE;\n+\t  use_globalize = true;\n \t  add_specific_symbols (optarg, globalize_specific_htab,\n \t\t\t\t&globalize_specific_buffer);\n \t  break;\n \n \tcase OPTION_KEEPGLOBAL_SYMBOLS:\n-\t  use_keep_global = TRUE;\n+\t  use_keep_global = true;\n \t  add_specific_symbols (optarg, keepglobal_specific_htab,\n \t\t\t\t&keepglobal_specific_buffer);\n \t  break;\n@@ -5746,7 +5747,7 @@ copy_main (int argc, char *argv[])\n \t  break;\n \n \tcase OPTION_EXTRACT_SYMBOL:\n-\t  extract_symbol = TRUE;\n+\t  extract_symbol = true;\n \t  break;\n \n \tcase OPTION_REVERSE_BYTES:"
    },
    {
      "sha": "bffd7441eba6a2df61d2be566f760eb9ecfdd45b",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 205,
      "deletions": 205,
      "changes": 410,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -85,7 +85,7 @@ static char *default_target = NULL;\t/* Default at runtime.  */\n static int show_version = 0;\t\t/* Show the version number.  */\n static int dump_section_contents;\t/* -s */\n static int dump_section_headers;\t/* -h */\n-static bfd_boolean dump_file_header;\t/* -f */\n+static bool dump_file_header;\t\t/* -f */\n static int dump_symtab;\t\t\t/* -t */\n static int dump_dynamic_symtab;\t\t/* -T */\n static int dump_reloc_info;\t\t/* -r */\n@@ -96,18 +96,18 @@ static char *dump_private_options;\t/* -P */\n static int no_addresses;\t\t/* --no-addresses */\n static int prefix_addresses;\t\t/* --prefix-addresses */\n static int with_line_numbers;\t\t/* -l */\n-static bfd_boolean with_source_code;\t/* -S */\n+static bool with_source_code;\t\t/* -S */\n static int show_raw_insn;\t\t/* --show-raw-insn */\n static int dump_dwarf_section_info;\t/* --dwarf */\n static int dump_stab_section_info;\t/* --stabs */\n static int dump_ctf_section_info;       /* --ctf */\n static char *dump_ctf_section_name;\n static char *dump_ctf_parent_name;\t/* --ctf-parent */\n static int do_demangle;\t\t\t/* -C, --demangle */\n-static bfd_boolean disassemble;\t\t/* -d */\n-static bfd_boolean disassemble_all;\t/* -D */\n+static bool disassemble;\t\t/* -d */\n+static bool disassemble_all;\t\t/* -D */\n static int disassemble_zeroes;\t\t/* --disassemble-zeroes */\n-static bfd_boolean formats_info;\t/* -i */\n+static bool formats_info;\t\t/* -i */\n static int wide_output;\t\t\t/* -w */\n static int insn_width;\t\t\t/* --insn-width */\n static bfd_vma start_address = (bfd_vma) -1; /* --start-address */\n@@ -118,26 +118,26 @@ static int suppress_bfd_header;\n static int dump_special_syms = 0;\t/* --special-syms */\n static bfd_vma adjust_section_vma = 0;\t/* --adjust-vma */\n static int file_start_context = 0;      /* --file-start-context */\n-static bfd_boolean display_file_offsets;/* -F */\n+static bool display_file_offsets;\t/* -F */\n static const char *prefix;\t\t/* --prefix */\n static int prefix_strip;\t\t/* --prefix-strip */\n static size_t prefix_length;\n-static bfd_boolean unwind_inlines;\t/* --inlines.  */\n+static bool unwind_inlines;\t\t/* --inlines.  */\n static const char * disasm_sym;\t\t/* Disassembly start symbol.  */\n static const char * source_comment;     /* --source_comment.  */\n-static bfd_boolean visualize_jumps = FALSE;          /* --visualize-jumps.  */\n-static bfd_boolean color_output = FALSE;             /* --visualize-jumps=color.  */\n-static bfd_boolean extended_color_output = FALSE;    /* --visualize-jumps=extended-color.  */\n-static int process_links = FALSE;       /* --process-links.  */\n+static bool visualize_jumps = false;\t/* --visualize-jumps.  */\n+static bool color_output = false;\t/* --visualize-jumps=color.  */\n+static bool extended_color_output = false; /* --visualize-jumps=extended-color.  */\n+static int process_links = false;       /* --process-links.  */\n \n static int demangle_flags = DMGL_ANSI | DMGL_PARAMS;\n \n /* A structure to record the sections mentioned in -j switches.  */\n struct only\n {\n-  const char * name; /* The name of the section.  */\n-  bfd_boolean  seen; /* A flag to indicate that the section has been found in one or more input files.  */\n-  struct only * next; /* Pointer to the next structure in the list.  */\n+  const char *name; /* The name of the section.  */\n+  bool seen; /* A flag to indicate that the section has been found in one or more input files.  */\n+  struct only *next; /* Pointer to the next structure in the list.  */\n };\n /* Pointer to an array of 'only' structures.\n    This pointer is NULL if the -j switch has not been used.  */\n@@ -151,13 +151,13 @@ static int include_path_count;\n    function.  */\n struct objdump_disasm_info\n {\n-  bfd *              abfd;\n-  bfd_boolean        require_sec;\n-  arelent **         dynrelbuf;\n-  long               dynrelcount;\n+  bfd *abfd;\n+  bool require_sec;\n+  arelent **dynrelbuf;\n+  long dynrelcount;\n   disassembler_ftype disassemble_fn;\n-  arelent *          reloc;\n-  const char *       symbol;\n+  arelent *reloc;\n+  const char *symbol;\n };\n \n /* Architecture to disassemble for, or default if NULL.  */\n@@ -387,7 +387,7 @@ static struct option long_options[]=\n   {\"line-numbers\", no_argument, NULL, 'l'},\n   {\"no-show-raw-insn\", no_argument, &show_raw_insn, -1},\n   {\"no-addresses\", no_argument, &no_addresses, 1},\n-  {\"process-links\", no_argument, &process_links, TRUE},\n+  {\"process-links\", no_argument, &process_links, true},\n   {\"prefix-addresses\", no_argument, &prefix_addresses, 1},\n   {\"recurse-limit\", no_argument, NULL, OPTION_RECURSE_LIMIT},\n   {\"recursion-limit\", no_argument, NULL, OPTION_RECURSE_LIMIT},\n@@ -495,22 +495,22 @@ sanitize_string (const char * in)\n \f\n /* Returns TRUE if the specified section should be dumped.  */\n \n-static bfd_boolean\n+static bool\n process_section_p (asection * section)\n {\n   struct only * only;\n \n   if (only_list == NULL)\n-    return TRUE;\n+    return true;\n \n   for (only = only_list; only; only = only->next)\n     if (strcmp (only->name, section->name) == 0)\n       {\n-\tonly->seen = TRUE;\n-\treturn TRUE;\n+\tonly->seen = true;\n+\treturn true;\n       }\n \n-  return FALSE;\n+  return false;\n }\n \n /* Add an entry to the 'only' list.  */\n@@ -528,7 +528,7 @@ add_only (char * name)\n \n   only = xmalloc (sizeof * only);\n   only->name = name;\n-  only->seen = FALSE;\n+  only->seen = false;\n   only->next = only_list;\n   only_list = only;\n }\n@@ -543,7 +543,7 @@ add_only (char * name)\n static void\n free_only_list (void)\n {\n-  bfd_boolean at_least_one_seen = FALSE;\n+  bool at_least_one_seen = false;\n   struct only * only;\n   struct only * next;\n \n@@ -553,7 +553,7 @@ free_only_list (void)\n   for (only = only_list; only; only = only->next)\n     if (only->seen)\n       {\n-\tat_least_one_seen = TRUE;\n+\tat_least_one_seen = true;\n \tbreak;\n       }\n \n@@ -818,7 +818,7 @@ slurp_dynamic_symtab (bfd *abfd)\n    table of sorted symbol names, even if they are marked as\n    debugging/section symbols.  */\n \n-static bfd_boolean\n+static bool\n is_significant_symbol_name (const char * name)\n {\n   return strncmp (name, \".plt\", 4) == 0 || strcmp (name, \".got\") == 0;\n@@ -864,7 +864,7 @@ compare_symbols (const void *ap, const void *bp)\n   const char *bn;\n   size_t anl;\n   size_t bnl;\n-  bfd_boolean as, af, bs, bf;\n+  bool as, af, bs, bf;\n   flagword aflags;\n   flagword bflags;\n \n@@ -1025,7 +1025,7 @@ compare_relocs (const void *ap, const void *bp)\n \n static void\n objdump_print_value (bfd_vma vma, struct disassemble_info *inf,\n-\t\t     bfd_boolean skip_zeroes)\n+\t\t     bool skip_zeroes)\n {\n   char buf[30];\n   char *p;\n@@ -1053,7 +1053,7 @@ objdump_print_symname (bfd *abfd, struct disassemble_info *inf,\n {\n   char *alloc;\n   const char *name, *version_string = NULL;\n-  bfd_boolean hidden = FALSE;\n+  bool hidden = false;\n \n   alloc = NULL;\n   name = bfd_asymbol_name (sym);\n@@ -1066,11 +1066,11 @@ objdump_print_symname (bfd *abfd, struct disassemble_info *inf,\n     }\n \n   if ((sym->flags & (BSF_SECTION_SYM | BSF_SYNTHETIC)) == 0)\n-    version_string = bfd_get_symbol_version_string (abfd, sym, TRUE,\n+    version_string = bfd_get_symbol_version_string (abfd, sym, true,\n \t\t\t\t\t\t    &hidden);\n \n   if (bfd_is_und_section (bfd_asymbol_section (sym)))\n-    hidden = TRUE;\n+    hidden = true;\n \n   name = sanitize_string (name);\n \n@@ -1092,12 +1092,12 @@ objdump_print_symname (bfd *abfd, struct disassemble_info *inf,\n     free (alloc);\n }\n \n-static inline bfd_boolean\n-sym_ok (bfd_boolean               want_section,\n-\tbfd *                     abfd ATTRIBUTE_UNUSED,\n-\tlong                      place,\n-\tasection *                sec,\n-\tstruct disassemble_info * inf)\n+static inline bool\n+sym_ok (bool want_section,\n+\tbfd *abfd ATTRIBUTE_UNUSED,\n+\tlong place,\n+\tasection *sec,\n+\tstruct disassemble_info *inf)\n {\n   if (want_section)\n     {\n@@ -1106,7 +1106,7 @@ sym_ok (bfd_boolean               want_section,\n \t the same owner.  */\n       if (sorted_syms[place]->section->owner == sec->owner\n \t  && sorted_syms[place]->section != sec)\n-\treturn FALSE;\n+\treturn false;\n \n       /* Note - we cannot just compare section pointers because they could\n \t be different, but the same...  Ie the symbol that we are trying to\n@@ -1117,7 +1117,7 @@ sym_ok (bfd_boolean               want_section,\n \t will be the same.  */\n       if (strcmp (bfd_section_name (sorted_syms[place]->section),\n \t\t  bfd_section_name (sec)) != 0)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   return inf->symbol_is_valid (sorted_syms[place], inf);\n@@ -1147,7 +1147,7 @@ find_symbol_for_address (bfd_vma vma,\n   bfd *abfd;\n   asection *sec;\n   unsigned int opb;\n-  bfd_boolean want_section;\n+  bool want_section;\n   long rel_count;\n \n   if (sorted_symcount < 1)\n@@ -1195,7 +1195,7 @@ find_symbol_for_address (bfd_vma vma,\n \t && (bfd_asymbol_value (sorted_syms[min])\n \t     == bfd_asymbol_value (sorted_syms[thisplace])))\n     {\n-      if (sym_ok (TRUE, abfd, min, sec, inf))\n+      if (sym_ok (true, abfd, min, sec, inf))\n \t{\n \t  thisplace = min;\n \n@@ -1336,7 +1336,7 @@ find_symbol_for_address (bfd_vma vma,\n static void\n objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,\n \t\t\t     bfd_vma vma, struct disassemble_info *inf,\n-\t\t\t     bfd_boolean skip_zeroes)\n+\t\t\t     bool skip_zeroes)\n {\n   if (!no_addresses)\n     {\n@@ -1354,12 +1354,12 @@ objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,\n       if (vma < secaddr)\n \t{\n \t  (*inf->fprintf_func) (inf->stream, \"-0x\");\n-\t  objdump_print_value (secaddr - vma, inf, TRUE);\n+\t  objdump_print_value (secaddr - vma, inf, true);\n \t}\n       else if (vma > secaddr)\n \t{\n \t  (*inf->fprintf_func) (inf->stream, \"+0x\");\n-\t  objdump_print_value (vma - secaddr, inf, TRUE);\n+\t  objdump_print_value (vma - secaddr, inf, true);\n \t}\n       (*inf->fprintf_func) (inf->stream, \">\");\n     }\n@@ -1383,12 +1383,12 @@ objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,\n       else if (bfd_asymbol_value (sym) > vma)\n \t{\n \t  (*inf->fprintf_func) (inf->stream, \"-0x\");\n-\t  objdump_print_value (bfd_asymbol_value (sym) - vma, inf, TRUE);\n+\t  objdump_print_value (bfd_asymbol_value (sym) - vma, inf, true);\n \t}\n       else if (vma > bfd_asymbol_value (sym))\n \t{\n \t  (*inf->fprintf_func) (inf->stream, \"+0x\");\n-\t  objdump_print_value (vma - bfd_asymbol_value (sym), inf, TRUE);\n+\t  objdump_print_value (vma - bfd_asymbol_value (sym), inf, true);\n \t}\n \n       (*inf->fprintf_func) (inf->stream, \">\");\n@@ -1405,11 +1405,11 @@ objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,\n static void\n objdump_print_addr (bfd_vma vma,\n \t\t    struct disassemble_info *inf,\n-\t\t    bfd_boolean skip_zeroes)\n+\t\t    bool skip_zeroes)\n {\n   struct objdump_disasm_info *aux;\n   asymbol *sym = NULL;\n-  bfd_boolean skip_find = FALSE;\n+  bool skip_find = false;\n \n   aux = (struct objdump_disasm_info *) inf->application_data;\n \n@@ -1438,7 +1438,7 @@ objdump_print_addr (bfd_vma vma,\n       vma += bfd_asymbol_value (sym);\n \n       if (bfd_is_und_section (bfd_asymbol_section (sym)))\n-\tskip_find = TRUE;\n+\tskip_find = true;\n     }\n \n   if (!skip_find)\n@@ -1716,7 +1716,7 @@ show_line (bfd *abfd, asection *section, bfd_vma addr_offset)\n   const char *functionname;\n   unsigned int linenumber;\n   unsigned int discriminator;\n-  bfd_boolean reloc;\n+  bool reloc;\n   char *path = NULL;\n \n   if (! with_line_numbers && ! with_source_code)\n@@ -1766,10 +1766,10 @@ show_line (bfd *abfd, asection *section, bfd_vma addr_offset)\n       path_up[PATH_MAX] = '\\0';\n \n       filename = path;\n-      reloc = TRUE;\n+      reloc = true;\n     }\n   else\n-    reloc = FALSE;\n+    reloc = false;\n \n   if (with_line_numbers)\n     {\n@@ -2026,16 +2026,16 @@ jump_info_end_address (const struct jump_info *ji)\n \n /* Test if an address is one of the start addresses of a jump.  */\n \n-static bfd_boolean\n+static bool\n jump_info_is_start_address (const struct jump_info *ji, bfd_vma address)\n {\n-  bfd_boolean result = FALSE;\n+  bool result = false;\n   size_t i;\n \n   for (i = ji->start.count; i-- > 0;)\n     if (address == ji->start.addresses[i])\n       {\n-\tresult = TRUE;\n+\tresult = true;\n \tbreak;\n       }\n \n@@ -2044,7 +2044,7 @@ jump_info_is_start_address (const struct jump_info *ji, bfd_vma address)\n \n /* Test if an address is the target address of a jump.  */\n \n-static bfd_boolean\n+static bool\n jump_info_is_end_address (const struct jump_info *ji, bfd_vma address)\n {\n   return (address == ji->end);\n@@ -2118,7 +2118,7 @@ jump_info_move_linked (struct jump_info *node,\n \n /* Test if two jumps intersect.  */\n \n-static bfd_boolean\n+static bool\n jump_info_intersect (const struct jump_info *a,\n \t\t     const struct jump_info *b)\n {\n@@ -2469,7 +2469,7 @@ disassemble_jumps (struct disassemble_info * inf,\n \t{\n \t  /* Test if the jump intersects with any\n \t     jump from current group.  */\n-\t  bfd_boolean ok = TRUE;\n+\t  bool ok = true;\n \t  struct jump_info *it_collision;\n \n \t  for (it_collision = base;\n@@ -2479,7 +2479,7 @@ disassemble_jumps (struct disassemble_info * inf,\n \t      /* This jump intersects so we leave it out.  */\n \t      if (jump_info_intersect (it_collision, it))\n \t\t{\n-\t\t  ok = FALSE;\n+\t\t  ok = false;\n \t\t  break;\n \t\t}\n \t    }\n@@ -2575,15 +2575,15 @@ print_jump_visualisation (bfd_vma addr, int max_level, char *line_buffer,\n /* Disassemble some data in memory between given values.  */\n \n static void\n-disassemble_bytes (struct disassemble_info * inf,\n-\t\t   disassembler_ftype        disassemble_fn,\n-\t\t   bfd_boolean               insns,\n-\t\t   bfd_byte *                data,\n-\t\t   bfd_vma                   start_offset,\n-\t\t   bfd_vma                   stop_offset,\n-\t\t   bfd_vma\t\t     rel_offset,\n-\t\t   arelent ***               relppp,\n-\t\t   arelent **                relppend)\n+disassemble_bytes (struct disassemble_info *inf,\n+\t\t   disassembler_ftype disassemble_fn,\n+\t\t   bool insns,\n+\t\t   bfd_byte *data,\n+\t\t   bfd_vma start_offset,\n+\t\t   bfd_vma stop_offset,\n+\t\t   bfd_vma rel_offset,\n+\t\t   arelent ***relppp,\n+\t\t   arelent **relppend)\n {\n   struct objdump_disasm_info *aux;\n   asection *section;\n@@ -2662,7 +2662,7 @@ disassemble_bytes (struct disassemble_info * inf,\n   addr_offset = start_offset;\n   while (addr_offset < stop_offset)\n     {\n-      bfd_boolean need_nl = FALSE;\n+      bool need_nl = false;\n \n       octets = 0;\n \n@@ -2726,9 +2726,9 @@ disassemble_bytes (struct disassemble_info * inf,\n \t    }\n \t  else\n \t    {\n-\t      aux->require_sec = TRUE;\n+\t      aux->require_sec = true;\n \t      objdump_print_address (section->vma + addr_offset, inf);\n-\t      aux->require_sec = FALSE;\n+\t      aux->require_sec = false;\n \t      putchar (' ');\n \t    }\n \n@@ -2967,7 +2967,7 @@ disassemble_bytes (struct disassemble_info * inf,\n \t  if (!wide_output)\n \t    putchar ('\\n');\n \t  else\n-\t    need_nl = TRUE;\n+\t    need_nl = true;\n \t}\n \n       while ((*relppp) < relppend\n@@ -2987,7 +2987,7 @@ disassemble_bytes (struct disassemble_info * inf,\n \t      if (!no_addresses)\n \t\t{\n \t\t  objdump_print_value (section->vma - rel_offset + q->address,\n-\t\t\t\t       inf, TRUE);\n+\t\t\t\t       inf, true);\n \t\t  printf (\": \");\n \t\t}\n \n@@ -3029,11 +3029,11 @@ disassemble_bytes (struct disassemble_info * inf,\n \t\t    }\n \t\t  else\n \t\t    printf (\"+0x\");\n-\t\t  objdump_print_value (addend, inf, TRUE);\n+\t\t  objdump_print_value (addend, inf, true);\n \t\t}\n \n \t      printf (\"\\n\");\n-\t      need_nl = FALSE;\n+\t      need_nl = false;\n \t    }\n \t  ++(*relppp);\n \t}\n@@ -3052,23 +3052,23 @@ disassemble_bytes (struct disassemble_info * inf,\n static void\n disassemble_section (bfd *abfd, asection *section, void *inf)\n {\n-  const struct elf_backend_data * bed;\n-  bfd_vma                      sign_adjust = 0;\n-  struct disassemble_info *    pinfo = (struct disassemble_info *) inf;\n-  struct objdump_disasm_info * paux;\n-  unsigned int                 opb = pinfo->octets_per_byte;\n-  bfd_byte *                   data = NULL;\n-  bfd_size_type                datasize = 0;\n-  arelent **                   rel_pp = NULL;\n-  arelent **                   rel_ppstart = NULL;\n-  arelent **                   rel_ppend;\n-  bfd_vma                      stop_offset;\n-  asymbol *                    sym = NULL;\n-  long                         place = 0;\n-  long                         rel_count;\n-  bfd_vma                      rel_offset;\n-  unsigned long                addr_offset;\n-  bfd_boolean                  do_print;\n+  const struct elf_backend_data *bed;\n+  bfd_vma sign_adjust = 0;\n+  struct disassemble_info *pinfo = (struct disassemble_info *) inf;\n+  struct objdump_disasm_info *paux;\n+  unsigned int opb = pinfo->octets_per_byte;\n+  bfd_byte *data = NULL;\n+  bfd_size_type datasize = 0;\n+  arelent **rel_pp = NULL;\n+  arelent **rel_ppstart = NULL;\n+  arelent **rel_ppend;\n+  bfd_vma stop_offset;\n+  asymbol *sym = NULL;\n+  long place = 0;\n+  long rel_count;\n+  bfd_vma rel_offset;\n+  unsigned long addr_offset;\n+  bool do_print;\n   enum loop_control\n   {\n    stop_offset_reached,\n@@ -3178,11 +3178,11 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n   printf (_(\"\\nDisassembly of section %s:\\n\"), sanitize_string (section->name));\n \n   /* Find the nearest symbol forwards from our current position.  */\n-  paux->require_sec = TRUE;\n+  paux->require_sec = true;\n   sym = (asymbol *) find_symbol_for_address (section->vma + addr_offset,\n                                              (struct disassemble_info *) inf,\n                                              &place);\n-  paux->require_sec = FALSE;\n+  paux->require_sec = false;\n \n   /* PR 9774: If the target used signed addresses then we must make\n      sure that we sign extend the value that we calculate for 'addr'\n@@ -3204,7 +3204,7 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n       bfd_vma addr;\n       asymbol *nextsym;\n       bfd_vma nextstop_offset;\n-      bfd_boolean insns;\n+      bool insns;\n \n       addr = section->vma + addr_offset;\n       addr = ((addr & ((sign_adjust << 1) - 1)) ^ sign_adjust) - sign_adjust;\n@@ -3241,7 +3241,7 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n \t\t{\n \t\tcase function_sym:\n \t\t  if (sym->flags & BSF_FUNCTION)\n-\t\t    do_print = FALSE;\n+\t\t    do_print = false;\n \t\t  break;\n \n \t\tcase stop_offset_reached:\n@@ -3253,7 +3253,7 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n \t\t     that the name of sym is different from\n \t\t     paux->symbol.  */\n \t\t  if (! bfd_is_local_label (abfd, sym))\n-\t\t    do_print = FALSE;\n+\t\t    do_print = false;\n \t\t  break;\n \t\t}\n \t    }\n@@ -3274,7 +3274,7 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n \t\t if the current symbol matches the requested symbol.  */\n \t      if (streq (name, paux->symbol))\n \t\t{\n-\t\t  do_print = TRUE;\n+\t\t  do_print = true;\n \n \t\t  if (sym->flags & BSF_FUNCTION)\n \t\t    {\n@@ -3310,7 +3310,7 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n \t{\n \t  pinfo->fprintf_func (pinfo->stream, \"\\n\");\n \t  objdump_print_addr_with_sym (abfd, section, sym, addr,\n-\t\t\t\t       pinfo, FALSE);\n+\t\t\t\t       pinfo, false);\n \t  pinfo->fprintf_func (pinfo->stream, \":\\n\");\n \t}\n \n@@ -3363,9 +3363,9 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n \t      && (strstr (bfd_asymbol_name (sym), \"gcc2_compiled\")\n \t\t  == NULL))\n \t  || (sym->flags & BSF_FUNCTION) != 0)\n-\tinsns = TRUE;\n+\tinsns = true;\n       else\n-\tinsns = FALSE;\n+\tinsns = false;\n \n       if (do_print)\n \t{\n@@ -3452,7 +3452,7 @@ disassemble_data (bfd *abfd)\n \n   disasm_info.application_data = (void *) &aux;\n   aux.abfd = abfd;\n-  aux.require_sec = FALSE;\n+  aux.require_sec = false;\n   aux.dynrelbuf = NULL;\n   aux.dynrelcount = 0;\n   aux.reloc = NULL;\n@@ -3500,7 +3500,7 @@ disassemble_data (bfd *abfd)\n   disasm_info.octets_per_byte = bfd_octets_per_byte (abfd, NULL);\n   disasm_info.skip_zeroes = DEFAULT_SKIP_ZEROES;\n   disasm_info.skip_zeroes_at_end = DEFAULT_SKIP_ZEROES_AT_END;\n-  disasm_info.disassembler_needs_relocs = FALSE;\n+  disasm_info.disassembler_needs_relocs = false;\n \n   if (bfd_big_endian (abfd))\n     disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_BIG;\n@@ -3548,7 +3548,7 @@ disassemble_data (bfd *abfd)\n   disassemble_free_target (&disasm_info);\n }\n \f\n-static bfd_boolean\n+static bool\n load_specific_debug_section (enum dwarf_section_display_enum debug,\n \t\t\t     asection *sec, void *file)\n {\n@@ -3557,13 +3557,13 @@ load_specific_debug_section (enum dwarf_section_display_enum debug,\n   bfd_byte *contents;\n   bfd_size_type amt;\n   size_t alloced;\n-  bfd_boolean ret;\n+  bool ret;\n \n   if (section->start != NULL)\n     {\n       /* If it is already loaded, do nothing.  */\n       if (streq (section->filename, bfd_get_filename (abfd)))\n-\treturn TRUE;\n+\treturn true;\n       free (section->start);\n     }\n \n@@ -3581,7 +3581,7 @@ load_specific_debug_section (enum dwarf_section_display_enum debug,\n       printf (_(\"\\nSection '%s' has an invalid size: %#llx.\\n\"),\n \t      sanitize_string (section->name),\n \t      (unsigned long long) section->size);\n-      return FALSE;\n+      return false;\n     }\n \n   section->start = contents = xmalloc (alloced);\n@@ -3625,31 +3625,31 @@ load_specific_debug_section (enum dwarf_section_display_enum debug,\n       free_debug_section (debug);\n       printf (_(\"\\nCan't get contents for section '%s'.\\n\"),\n \t      sanitize_string (section->name));\n-      return FALSE;\n+      return false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n reloc_at (struct dwarf_section * dsec, dwarf_vma offset)\n {\n   arelent ** relocs;\n   arelent * rp;\n \n   if (dsec == NULL || dsec->reloc_info == NULL)\n-    return FALSE;\n+    return false;\n \n   relocs = (arelent **) dsec->reloc_info;\n \n   for (; (rp = * relocs) != NULL; ++ relocs)\n     if (rp->address == offset)\n-      return TRUE;\n+      return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n load_debug_section (enum dwarf_section_display_enum debug, void *file)\n {\n   struct dwarf_section *section = &debug_displays [debug].section;\n@@ -3660,7 +3660,7 @@ load_debug_section (enum dwarf_section_display_enum debug, void *file)\n   if (section->start != NULL)\n     {\n       if (streq (section->filename, bfd_get_filename (abfd)))\n-\treturn TRUE;\n+\treturn true;\n     }\n \n   /* Locate the debug section.  */\n@@ -3674,7 +3674,7 @@ load_debug_section (enum dwarf_section_display_enum debug, void *file)\n         section->name = section->compressed_name;\n     }\n   if (sec == NULL)\n-    return FALSE;\n+    return false;\n \n   return load_specific_debug_section (debug, sec, file);\n }\n@@ -3824,7 +3824,7 @@ read_section_stabs (bfd *abfd, const char *sect_name, bfd_size_type *size_ptr,\n     {\n       printf (_(\"No %s section present\\n\\n\"),\n \t      sanitize_string (sect_name));\n-      return FALSE;\n+      return false;\n     }\n \n   if (!bfd_malloc_and_get_section (abfd, stabsect, &contents))\n@@ -4242,7 +4242,7 @@ dump_target_specific (bfd *abfd)\n \n   /* Clear all options.  */\n   for (opt = (*desc)->options; opt->name; opt++)\n-    opt->selected = FALSE;\n+    opt->selected = false;\n \n   /* Decode options.  */\n   b = dump_private_options;\n@@ -4256,7 +4256,7 @@ dump_target_specific (bfd *abfd)\n       for (opt = (*desc)->options; opt->name; opt++)\n         if (strcmp (opt->name, b) == 0)\n           {\n-            opt->selected = TRUE;\n+            opt->selected = true;\n             break;\n           }\n       if (opt->name == NULL)\n@@ -4416,7 +4416,7 @@ dump_data (bfd *abfd)\n /* Should perhaps share code and display with nm?  */\n \n static void\n-dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bfd_boolean dynamic)\n+dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bool dynamic)\n {\n   asymbol **current;\n   long max_count;\n@@ -4771,7 +4771,7 @@ adjust_addresses (bfd *abfd ATTRIBUTE_UNUSED,\n {\n   if ((section->flags & SEC_DEBUGGING) == 0)\n     {\n-      bfd_boolean *has_reloc_p = (bfd_boolean *) arg;\n+      bool *has_reloc_p = (bool *) arg;\n       section->vma += adjust_section_vma;\n       if (*has_reloc_p)\n \tsection->lma += adjust_section_vma;\n@@ -4793,7 +4793,7 @@ sign_extend_address (bfd *abfd ATTRIBUTE_UNUSED,\n /* Dump selected contents of ABFD.  */\n \n static void\n-dump_bfd (bfd *abfd, bfd_boolean is_mainfile)\n+dump_bfd (bfd *abfd, bool is_mainfile)\n {\n   const struct elf_backend_data * bed;\n \n@@ -4823,7 +4823,7 @@ dump_bfd (bfd *abfd, bfd_boolean is_mainfile)\n \t  separate_info * i;\n \n \t  for (i = first_separate_info; i != NULL; i = i->next)\n-\t    dump_bfd (i->handle, FALSE);\n+\t    dump_bfd (i->handle, false);\n \t}\n     }\n \n@@ -4844,7 +4844,7 @@ dump_bfd (bfd *abfd, bfd_boolean is_mainfile)\n      bfd_find_nearest_line will not do the right thing.  */\n   if (adjust_section_vma != 0)\n     {\n-      bfd_boolean has_reloc = (abfd->flags & HAS_RELOC);\n+      bool has_reloc = (abfd->flags & HAS_RELOC);\n       bfd_map_over_sections (abfd, adjust_addresses, &has_reloc);\n     }\n \n@@ -4856,7 +4856,7 @@ dump_bfd (bfd *abfd, bfd_boolean is_mainfile)\n \t    sanitize_string (bfd_get_filename (abfd)),\n \t    abfd->xvec->name);\n   if (dump_ar_hdrs)\n-    print_arelt_descr (stdout, abfd, TRUE, FALSE);\n+    print_arelt_descr (stdout, abfd, true, false);\n   if (dump_file_header)\n     dump_bfd_header (abfd);\n   if (dump_private_headers)\n@@ -4923,9 +4923,9 @@ dump_bfd (bfd *abfd, bfd_boolean is_mainfile)\n     }\n \n   if (dump_symtab)\n-    dump_symbols (abfd, FALSE);\n+    dump_symbols (abfd, false);\n   if (dump_dynamic_symtab)\n-    dump_symbols (abfd, TRUE);\n+    dump_symbols (abfd, true);\n   if (dump_dwarf_section_info)\n     dump_dwarf (abfd);\n   if (dump_ctf_section_info)\n@@ -4945,7 +4945,7 @@ dump_bfd (bfd *abfd, bfd_boolean is_mainfile)\n     {\n       void *dhandle;\n \n-      dhandle = read_debugging_info (abfd, syms, symcount, TRUE);\n+      dhandle = read_debugging_info (abfd, syms, symcount, true);\n       if (dhandle != NULL)\n \t{\n \t  if (!print_debugging_info (stdout, dhandle, abfd, syms,\n@@ -5001,7 +5001,7 @@ display_object_bfd (bfd *abfd)\n \n   if (bfd_check_format_matches (abfd, bfd_object, &matching))\n     {\n-      dump_bfd (abfd, TRUE);\n+      dump_bfd (abfd, true);\n       return;\n     }\n \n@@ -5021,7 +5021,7 @@ display_object_bfd (bfd *abfd)\n \n   if (bfd_check_format_matches (abfd, bfd_core, &matching))\n     {\n-      dump_bfd (abfd, TRUE);\n+      dump_bfd (abfd, true);\n       return;\n     }\n \n@@ -5095,7 +5095,7 @@ display_any_bfd (bfd *file, int level)\n }\n \n static void\n-display_file (char *filename, char *target, bfd_boolean last_file)\n+display_file (char *filename, char *target, bool last_file)\n {\n   bfd *file;\n \n@@ -5133,7 +5133,7 @@ main (int argc, char **argv)\n {\n   int c;\n   char *target = default_target;\n-  bfd_boolean seenflag = FALSE;\n+  bool seenflag = false;\n \n #if defined (HAVE_SETLOCALE)\n #if defined (HAVE_LC_MESSAGES)\n@@ -5185,16 +5185,16 @@ main (int argc, char **argv)\n \t  add_only (optarg);\n \t  break;\n \tcase 'F':\n-\t  display_file_offsets = TRUE;\n+\t  display_file_offsets = true;\n \t  break;\n \tcase 'l':\n-\t  with_line_numbers = TRUE;\n+\t  with_line_numbers = true;\n \t  break;\n \tcase 'b':\n \t  target = optarg;\n \t  break;\n \tcase 'C':\n-\t  do_demangle = TRUE;\n+\t  do_demangle = true;\n \t  if (optarg != NULL)\n \t    {\n \t      enum demangling_styles style;\n@@ -5214,7 +5214,7 @@ main (int argc, char **argv)\n \t  demangle_flags |= DMGL_NO_RECURSE_LIMIT;\n \t  break;\n \tcase 'w':\n-\t  do_wide = wide_output = TRUE;\n+\t  do_wide = wide_output = true;\n \t  break;\n \tcase OPTION_ADJUST_VMA:\n \t  adjust_section_vma = parse_vma (optarg, \"--adjust-vma\");\n@@ -5247,23 +5247,23 @@ main (int argc, char **argv)\n \t    fatal (_(\"error: instruction width must be positive\"));\n \t  break;\n \tcase OPTION_INLINES:\n-\t  unwind_inlines = TRUE;\n+\t  unwind_inlines = true;\n \t  break;\n \tcase OPTION_VISUALIZE_JUMPS:\n-\t  visualize_jumps = TRUE;\n-\t  color_output = FALSE;\n-\t  extended_color_output = FALSE;\n+\t  visualize_jumps = true;\n+\t  color_output = false;\n+\t  extended_color_output = false;\n \t  if (optarg != NULL)\n \t    {\n \t      if (streq (optarg, \"color\"))\n-\t\tcolor_output = TRUE;\n+\t\tcolor_output = true;\n \t      else if (streq (optarg, \"extended-color\"))\n \t\t{\n-\t\t  color_output = TRUE;\n-\t\t  extended_color_output = TRUE;\n+\t\t  color_output = true;\n+\t\t  extended_color_output = true;\n \t\t}\n \t      else if (streq (optarg, \"off\"))\n-\t\tvisualize_jumps = FALSE;\n+\t\tvisualize_jumps = false;\n \t      else\n \t\tnonfatal (_(\"unrecognized argument to --visualize-option\"));\n \t    }\n@@ -5293,93 +5293,93 @@ main (int argc, char **argv)\n \t  break;\n \n \tcase 'f':\n-\t  dump_file_header = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_file_header = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'i':\n-\t  formats_info = TRUE;\n-\t  seenflag = TRUE;\n+\t  formats_info = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'I':\n \t  add_include_path (optarg);\n \t  break;\n \tcase 'p':\n-\t  dump_private_headers = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_private_headers = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'P':\n \t  dump_private_options = optarg;\n-\t  seenflag = TRUE;\n+\t  seenflag = true;\n \t  break;\n \tcase 'x':\n-\t  dump_private_headers = TRUE;\n-\t  dump_symtab = TRUE;\n-\t  dump_reloc_info = TRUE;\n-\t  dump_file_header = TRUE;\n-\t  dump_ar_hdrs = TRUE;\n-\t  dump_section_headers = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_private_headers = true;\n+\t  dump_symtab = true;\n+\t  dump_reloc_info = true;\n+\t  dump_file_header = true;\n+\t  dump_ar_hdrs = true;\n+\t  dump_section_headers = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 't':\n-\t  dump_symtab = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_symtab = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'T':\n-\t  dump_dynamic_symtab = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_dynamic_symtab = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'd':\n-\t  disassemble = TRUE;\n-\t  seenflag = TRUE;\n+\t  disassemble = true;\n+\t  seenflag = true;\n \t  disasm_sym = optarg;\n \t  break;\n \tcase 'z':\n-\t  disassemble_zeroes = TRUE;\n+\t  disassemble_zeroes = true;\n \t  break;\n \tcase 'D':\n-\t  disassemble = TRUE;\n-\t  disassemble_all = TRUE;\n-\t  seenflag = TRUE;\n+\t  disassemble = true;\n+\t  disassemble_all = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'S':\n-\t  disassemble = TRUE;\n-\t  with_source_code = TRUE;\n-\t  seenflag = TRUE;\n+\t  disassemble = true;\n+\t  with_source_code = true;\n+\t  seenflag = true;\n \t  break;\n \tcase OPTION_SOURCE_COMMENT:\n-\t  disassemble = TRUE;\n-\t  with_source_code = TRUE;\n-\t  seenflag = TRUE;\n+\t  disassemble = true;\n+\t  with_source_code = true;\n+\t  seenflag = true;\n \t  if (optarg)\n \t    source_comment = xstrdup (sanitize_string (optarg));\n \t  else\n \t    source_comment = xstrdup (\"# \");\n \t  break;\n \tcase 'g':\n \t  dump_debugging = 1;\n-\t  seenflag = TRUE;\n+\t  seenflag = true;\n \t  break;\n \tcase 'e':\n \t  dump_debugging = 1;\n \t  dump_debugging_tags = 1;\n-\t  do_demangle = TRUE;\n-\t  seenflag = TRUE;\n+\t  do_demangle = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'L':\n-\t  process_links = TRUE;\n-\t  do_follow_links = TRUE;\n+\t  process_links = true;\n+\t  do_follow_links = true;\n \t  break;\n \tcase 'W':\n-\t  dump_dwarf_section_info = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_dwarf_section_info = true;\n+\t  seenflag = true;\n \t  if (optarg)\n \t    dwarf_select_sections_by_letters (optarg);\n \t  else\n \t    dwarf_select_sections_all ();\n \t  break;\n \tcase OPTION_DWARF:\n-\t  dump_dwarf_section_info = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_dwarf_section_info = true;\n+\t  seenflag = true;\n \t  if (optarg)\n \t    dwarf_select_sections_by_names (optarg);\n \t  else\n@@ -5399,46 +5399,46 @@ main (int argc, char **argv)\n \t  }\n \t  break;\n \tcase OPTION_DWARF_CHECK:\n-\t  dwarf_check = TRUE;\n+\t  dwarf_check = true;\n \t  break;\n #ifdef ENABLE_LIBCTF\n \tcase OPTION_CTF:\n-\t  dump_ctf_section_info = TRUE;\n+\t  dump_ctf_section_info = true;\n \t  dump_ctf_section_name = xstrdup (optarg);\n-\t  seenflag = TRUE;\n+\t  seenflag = true;\n \t  break;\n \tcase OPTION_CTF_PARENT:\n \t  dump_ctf_parent_name = xstrdup (optarg);\n \t  break;\n #endif\n \tcase 'G':\n-\t  dump_stab_section_info = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_stab_section_info = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 's':\n-\t  dump_section_contents = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_section_contents = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'r':\n-\t  dump_reloc_info = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_reloc_info = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'R':\n-\t  dump_dynamic_reloc_info = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_dynamic_reloc_info = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'a':\n-\t  dump_ar_hdrs = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_ar_hdrs = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'h':\n-\t  dump_section_headers = TRUE;\n-\t  seenflag = TRUE;\n+\t  dump_section_headers = true;\n+\t  seenflag = true;\n \t  break;\n \tcase 'v':\n \tcase 'V':\n-\t  show_version = TRUE;\n-\t  seenflag = TRUE;\n+\t  show_version = true;\n+\t  seenflag = true;\n \t  break;\n \n \tcase 'H':\n@@ -5460,7 +5460,7 @@ main (int argc, char **argv)\n   else\n     {\n       if (optind == argc)\n-\tdisplay_file (\"a.out\", target, TRUE);\n+\tdisplay_file (\"a.out\", target, true);\n       else\n \tfor (; optind < argc;)\n \t  {"
    },
    {
      "sha": "29066680b7378c3fbfcbcaf935e5d959bfaedf13",
      "filename": "binutils/od-macho.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/od-macho.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/od-macho.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/od-macho.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -464,7 +464,7 @@ dump_segment (bfd *abfd ATTRIBUTE_UNUSED, bfd_mach_o_load_command *cmd)\n }\n \n static void\n-dump_dysymtab (bfd *abfd, bfd_mach_o_load_command *cmd, bfd_boolean verbose)\n+dump_dysymtab (bfd *abfd, bfd_mach_o_load_command *cmd, bool verbose)\n {\n   bfd_mach_o_dysymtab_command *dysymtab = &cmd->command.dysymtab;\n   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);\n@@ -656,26 +656,26 @@ dump_dysymtab (bfd *abfd, bfd_mach_o_load_command *cmd, bfd_boolean verbose)\n \n }\n \n-static bfd_boolean\n+static bool\n load_and_dump (bfd *abfd, ufile_ptr off, unsigned int len,\n \t       void (*dump)(bfd *abfd, unsigned char *buf, unsigned int len,\n \t\t\t    ufile_ptr off))\n {\n   unsigned char *buf;\n \n   if (len == 0)\n-    return TRUE;\n+    return true;\n \n   buf = xmalloc (len);\n \n   if (bfd_seek (abfd, off, SEEK_SET) == 0\n       && bfd_bread (buf, len, abfd) == len)\n     dump (abfd, buf, len, off);\n   else\n-    return FALSE;\n+    return false;\n \n   free (buf);\n-  return TRUE;\n+  return true;\n }\n \n static const bfd_mach_o_xlat_name bfd_mach_o_dyld_rebase_type_name[] =\n@@ -968,7 +968,7 @@ dump_dyld_info_export (bfd *abfd, unsigned char *buf, unsigned int len,\n \n static void\n dump_dyld_info (bfd *abfd, bfd_mach_o_load_command *cmd,\n-\t\tbfd_boolean verbose)\n+\t\tbool verbose)\n {\n   bfd_mach_o_dyld_info_command *dinfo = &cmd->command.dyld_info;\n \n@@ -1527,7 +1527,7 @@ dump_build_version (bfd *abfd, bfd_mach_o_load_command *cmd)\n \n static void\n dump_load_command (bfd *abfd, bfd_mach_o_load_command *cmd,\n-                   unsigned int idx, bfd_boolean verbose)\n+                   unsigned int idx, bool verbose)\n {\n   bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);\n   const char *cmd_name;\n@@ -1769,9 +1769,9 @@ dump_load_commands (bfd *abfd, unsigned int cmd32, unsigned int cmd64)\n   for (cmd = mdata->first_command, i = 0; cmd != NULL; cmd = cmd->next, i++)\n     {\n       if (cmd32 == 0)\n-        dump_load_command (abfd, cmd, i, FALSE);\n+        dump_load_command (abfd, cmd, i, false);\n       else if (cmd->type == cmd32 || cmd->type == cmd64)\n-        dump_load_command (abfd, cmd, i, TRUE);\n+        dump_load_command (abfd, cmd, i, true);\n     }\n }\n "
    },
    {
      "sha": "6c14dcac9a87a2e31cd0e73bd187798b6215b048",
      "filename": "binutils/prdbg.c",
      "status": "modified",
      "additions": 423,
      "deletions": 430,
      "changes": 853,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/prdbg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/prdbg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/prdbg.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -76,120 +76,113 @@ struct pr_stack\n };\n \n static void indent (struct pr_handle *);\n-static bfd_boolean push_type (struct pr_handle *, const char *);\n-static bfd_boolean prepend_type (struct pr_handle *, const char *);\n-static bfd_boolean append_type (struct pr_handle *, const char *);\n-static bfd_boolean substitute_type (struct pr_handle *, const char *);\n-static bfd_boolean indent_type (struct pr_handle *);\n+static bool push_type (struct pr_handle *, const char *);\n+static bool prepend_type (struct pr_handle *, const char *);\n+static bool append_type (struct pr_handle *, const char *);\n+static bool substitute_type (struct pr_handle *, const char *);\n+static bool indent_type (struct pr_handle *);\n static char *pop_type (struct pr_handle *);\n-static void print_vma (bfd_vma, char *, bfd_boolean, bfd_boolean);\n-static bfd_boolean pr_fix_visibility\n-  (struct pr_handle *, enum debug_visibility);\n-static bfd_boolean pr_start_compilation_unit (void *, const char *);\n-static bfd_boolean pr_start_source (void *, const char *);\n-static bfd_boolean pr_empty_type (void *);\n-static bfd_boolean pr_void_type (void *);\n-static bfd_boolean pr_int_type (void *, unsigned int, bfd_boolean);\n-static bfd_boolean pr_float_type (void *, unsigned int);\n-static bfd_boolean pr_complex_type (void *, unsigned int);\n-static bfd_boolean pr_bool_type (void *, unsigned int);\n-static bfd_boolean pr_enum_type\n+static void print_vma (bfd_vma, char *, bool, bool);\n+static bool pr_fix_visibility (struct pr_handle *, enum debug_visibility);\n+static bool pr_start_compilation_unit (void *, const char *);\n+static bool pr_start_source (void *, const char *);\n+static bool pr_empty_type (void *);\n+static bool pr_void_type (void *);\n+static bool pr_int_type (void *, unsigned int, bool);\n+static bool pr_float_type (void *, unsigned int);\n+static bool pr_complex_type (void *, unsigned int);\n+static bool pr_bool_type (void *, unsigned int);\n+static bool pr_enum_type\n   (void *, const char *, const char **, bfd_signed_vma *);\n-static bfd_boolean pr_pointer_type (void *);\n-static bfd_boolean pr_function_type (void *, int, bfd_boolean);\n-static bfd_boolean pr_reference_type (void *);\n-static bfd_boolean pr_range_type (void *, bfd_signed_vma, bfd_signed_vma);\n-static bfd_boolean pr_array_type\n-  (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);\n-static bfd_boolean pr_set_type (void *, bfd_boolean);\n-static bfd_boolean pr_offset_type (void *);\n-static bfd_boolean pr_method_type (void *, bfd_boolean, int, bfd_boolean);\n-static bfd_boolean pr_const_type (void *);\n-static bfd_boolean pr_volatile_type (void *);\n-static bfd_boolean pr_start_struct_type\n-  (void *, const char *, unsigned int, bfd_boolean, unsigned int);\n-static bfd_boolean pr_struct_field\n+static bool pr_pointer_type (void *);\n+static bool pr_function_type (void *, int, bool);\n+static bool pr_reference_type (void *);\n+static bool pr_range_type (void *, bfd_signed_vma, bfd_signed_vma);\n+static bool pr_array_type (void *, bfd_signed_vma, bfd_signed_vma, bool);\n+static bool pr_set_type (void *, bool);\n+static bool pr_offset_type (void *);\n+static bool pr_method_type (void *, bool, int, bool);\n+static bool pr_const_type (void *);\n+static bool pr_volatile_type (void *);\n+static bool pr_start_struct_type\n+  (void *, const char *, unsigned int, bool, unsigned int);\n+static bool pr_struct_field\n   (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);\n-static bfd_boolean pr_end_struct_type (void *);\n-static bfd_boolean pr_start_class_type\n-  (void *, const char *, unsigned int, bfd_boolean, unsigned int,\n-   bfd_boolean, bfd_boolean);\n-static bfd_boolean pr_class_static_member\n+static bool pr_end_struct_type (void *);\n+static bool pr_start_class_type\n+  (void *, const char *, unsigned int, bool, unsigned int, bool, bool);\n+static bool pr_class_static_member\n   (void *, const char *, const char *, enum debug_visibility);\n-static bfd_boolean pr_class_baseclass\n-  (void *, bfd_vma, bfd_boolean, enum debug_visibility);\n-static bfd_boolean pr_class_start_method (void *, const char *);\n-static bfd_boolean pr_class_method_variant\n-  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,\n-   bfd_vma, bfd_boolean);\n-static bfd_boolean pr_class_static_method_variant\n-  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);\n-static bfd_boolean pr_class_end_method (void *);\n-static bfd_boolean pr_end_class_type (void *);\n-static bfd_boolean pr_typedef_type (void *, const char *);\n-static bfd_boolean pr_tag_type\n+static bool pr_class_baseclass\n+  (void *, bfd_vma, bool, enum debug_visibility);\n+static bool pr_class_start_method (void *, const char *);\n+static bool pr_class_method_variant\n+  (void *, const char *, enum debug_visibility, bool, bool, bfd_vma, bool);\n+static bool pr_class_static_method_variant\n+  (void *, const char *, enum debug_visibility, bool, bool);\n+static bool pr_class_end_method (void *);\n+static bool pr_end_class_type (void *);\n+static bool pr_typedef_type (void *, const char *);\n+static bool pr_tag_type\n   (void *, const char *, unsigned int, enum debug_type_kind);\n-static bfd_boolean pr_typdef (void *, const char *);\n-static bfd_boolean pr_tag (void *, const char *);\n-static bfd_boolean pr_int_constant (void *, const char *, bfd_vma);\n-static bfd_boolean pr_float_constant (void *, const char *, double);\n-static bfd_boolean pr_typed_constant (void *, const char *, bfd_vma);\n-static bfd_boolean pr_variable\n-  (void *, const char *, enum debug_var_kind, bfd_vma);\n-static bfd_boolean pr_start_function (void *, const char *, bfd_boolean);\n-static bfd_boolean pr_function_parameter\n+static bool pr_typdef (void *, const char *);\n+static bool pr_tag (void *, const char *);\n+static bool pr_int_constant (void *, const char *, bfd_vma);\n+static bool pr_float_constant (void *, const char *, double);\n+static bool pr_typed_constant (void *, const char *, bfd_vma);\n+static bool pr_variable (void *, const char *, enum debug_var_kind, bfd_vma);\n+static bool pr_start_function (void *, const char *, bool);\n+static bool pr_function_parameter\n   (void *, const char *, enum debug_parm_kind, bfd_vma);\n-static bfd_boolean pr_start_block (void *, bfd_vma);\n-static bfd_boolean pr_end_block (void *, bfd_vma);\n-static bfd_boolean pr_end_function (void *);\n-static bfd_boolean pr_lineno (void *, const char *, unsigned long, bfd_vma);\n-static bfd_boolean append_parent (struct pr_handle *, const char *);\n+static bool pr_start_block (void *, bfd_vma);\n+static bool pr_end_block (void *, bfd_vma);\n+static bool pr_end_function (void *);\n+static bool pr_lineno (void *, const char *, unsigned long, bfd_vma);\n+static bool append_parent (struct pr_handle *, const char *);\n /* Only used by tg_ code.  */\n-static bfd_boolean tg_fix_visibility\n+static bool tg_fix_visibility\n   (struct pr_handle *, enum debug_visibility);\n static void find_address_in_section (bfd *, asection *, void *);\n static void translate_addresses (bfd *, char *, FILE *, asymbol **);\n static const char *visibility_name (enum debug_visibility);\n /* Tags style replacements.  */\n-static bfd_boolean tg_start_compilation_unit (void *, const char *);\n-static bfd_boolean tg_start_source (void *, const char *);\n-static bfd_boolean tg_enum_type\n+static bool tg_start_compilation_unit (void *, const char *);\n+static bool tg_start_source (void *, const char *);\n+static bool tg_enum_type\n   (void *, const char *, const char **, bfd_signed_vma *);\n-static bfd_boolean tg_start_struct_type\n-  (void *, const char *, unsigned int, bfd_boolean, unsigned int);\n-static bfd_boolean pr_struct_field\n+static bool tg_start_struct_type\n+  (void *, const char *, unsigned int, bool, unsigned int);\n+static bool pr_struct_field\n   (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);\n-static bfd_boolean tg_struct_field\n+static bool tg_struct_field\n   (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);\n-static bfd_boolean tg_struct_field\n+static bool tg_struct_field\n   (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);\n-static bfd_boolean tg_end_struct_type (void *);\n-static bfd_boolean tg_start_class_type\n-  (void *, const char *, unsigned int, bfd_boolean, unsigned int, bfd_boolean, bfd_boolean);\n-static bfd_boolean tg_class_static_member\n+static bool tg_end_struct_type (void *);\n+static bool tg_start_class_type\n+  (void *, const char *, unsigned int, bool, unsigned int, bool, bool);\n+static bool tg_class_static_member\n   (void *, const char *, const char *, enum debug_visibility);\n-static bfd_boolean tg_class_baseclass\n-  (void *, bfd_vma, bfd_boolean, enum debug_visibility);\n-static bfd_boolean tg_class_method_variant\n-  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);\n-static bfd_boolean tg_class_static_method_variant\n-  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);\n-static bfd_boolean tg_end_class_type (void *);\n-static bfd_boolean tg_tag_type\n+static bool tg_class_baseclass (void *, bfd_vma, bool, enum debug_visibility);\n+static bool tg_class_method_variant\n+  (void *, const char *, enum debug_visibility, bool, bool, bfd_vma, bool);\n+static bool tg_class_static_method_variant\n+  (void *, const char *, enum debug_visibility, bool, bool);\n+static bool tg_end_class_type (void *);\n+static bool tg_tag_type\n   (void *, const char *, unsigned int, enum debug_type_kind);\n-static bfd_boolean tg_typdef (void *, const char *);\n-static bfd_boolean tg_tag (void *, const char *);\n-static bfd_boolean tg_int_constant (void *, const char *, bfd_vma);\n-static bfd_boolean tg_float_constant (void *, const char *, double);\n-static bfd_boolean tg_typed_constant (void *, const char *, bfd_vma);\n-static bfd_boolean tg_variable\n-  (void *, const char *, enum debug_var_kind, bfd_vma);\n-static bfd_boolean tg_start_function (void *, const char *, bfd_boolean);\n-static bfd_boolean tg_function_parameter\n+static bool tg_typdef (void *, const char *);\n+static bool tg_tag (void *, const char *);\n+static bool tg_int_constant (void *, const char *, bfd_vma);\n+static bool tg_float_constant (void *, const char *, double);\n+static bool tg_typed_constant (void *, const char *, bfd_vma);\n+static bool tg_variable (void *, const char *, enum debug_var_kind, bfd_vma);\n+static bool tg_start_function (void *, const char *, bool);\n+static bool tg_function_parameter\n   (void *, const char *, enum debug_parm_kind, bfd_vma);\n-static bfd_boolean tg_start_block (void *, bfd_vma);\n-static bfd_boolean tg_end_block (void *, bfd_vma);\n-static bfd_boolean tg_lineno (void *, const char *, unsigned long, bfd_vma);\n+static bool tg_start_block (void *, bfd_vma);\n+static bool tg_end_block (void *, bfd_vma);\n+static bool tg_lineno (void *, const char *, unsigned long, bfd_vma);\n \f\n static const struct debug_write_fns pr_fns =\n {\n@@ -291,10 +284,10 @@ static int demangle_flags = DMGL_ANSI | DMGL_PARAMS;\n \f\n /* Print out the generic debugging information recorded in dhandle.  */\n \n-bfd_boolean\n+bool\n print_debugging_info (FILE *f, void *dhandle, bfd *abfd, asymbol **syms,\n \t\t      char * (*demangler) (struct bfd *, const char *, int),\n-\t\t      bfd_boolean as_tags)\n+\t\t      bool as_tags)\n {\n   struct pr_handle info;\n \n@@ -332,13 +325,13 @@ indent (struct pr_handle *info)\n \n /* Push a type on the type stack.  */\n \n-static bfd_boolean\n+static bool\n push_type (struct pr_handle *info, const char *type)\n {\n   struct pr_stack *n;\n \n   if (type == NULL)\n-    return FALSE;\n+    return false;\n \n   n = (struct pr_stack *) xmalloc (sizeof *n);\n   memset (n, 0, sizeof *n);\n@@ -349,12 +342,12 @@ push_type (struct pr_handle *info, const char *type)\n   n->next = info->stack;\n   info->stack = n;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Prepend a string onto the type on the top of the type stack.  */\n \n-static bfd_boolean\n+static bool\n prepend_type (struct pr_handle *info, const char *s)\n {\n   char *n;\n@@ -366,18 +359,18 @@ prepend_type (struct pr_handle *info, const char *s)\n   free (info->stack->type);\n   info->stack->type = n;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Append a string to the type on the top of the type stack.  */\n \n-static bfd_boolean\n+static bool\n append_type (struct pr_handle *info, const char *s)\n {\n   unsigned int len;\n \n   if (s == NULL)\n-    return FALSE;\n+    return false;\n \n   assert (info->stack != NULL);\n \n@@ -386,18 +379,18 @@ append_type (struct pr_handle *info, const char *s)\n \t\t\t\t\t len + strlen (s) + 1);\n   strcpy (info->stack->type + len, s);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Append a string to the parents on the top of the type stack.  */\n \n-static bfd_boolean\n+static bool\n append_parent (struct pr_handle *info, const char *s)\n {\n   unsigned int len;\n \n   if (s == NULL)\n-    return FALSE;\n+    return false;\n \n   assert (info->stack != NULL);\n \n@@ -406,14 +399,14 @@ append_parent (struct pr_handle *info, const char *s)\n \t\t\t\t\t    len + strlen (s) + 1);\n   strcpy (info->stack->parents + len, s);\n \n-  return TRUE;\n+  return true;\n }\n \n /* We use an underscore to indicate where the name should go in a type\n    string.  This function substitutes a string for the underscore.  If\n    there is no underscore, the name follows the type.  */\n \n-static bfd_boolean\n+static bool\n substitute_type (struct pr_handle *info, const char *s)\n {\n   char *u;\n@@ -434,7 +427,7 @@ substitute_type (struct pr_handle *info, const char *s)\n       free (info->stack->type);\n       info->stack->type = n;\n \n-      return TRUE;\n+      return true;\n     }\n \n   if (strchr (s, '|') != NULL\n@@ -443,30 +436,30 @@ substitute_type (struct pr_handle *info, const char *s)\n     {\n       if (! prepend_type (info, \"(\")\n \t  || ! append_type (info, \")\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (*s == '\\0')\n-    return TRUE;\n+    return true;\n \n   return (append_type (info, \" \")\n \t  && append_type (info, s));\n }\n \n /* Indent the type at the top of the stack by appending spaces.  */\n \n-static bfd_boolean\n+static bool\n indent_type (struct pr_handle *info)\n {\n   unsigned int i;\n \n   for (i = 0; i < info->indent; i++)\n     {\n       if (! append_type (info, \" \"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Pop a type from the type stack.  */\n@@ -490,7 +483,7 @@ pop_type (struct pr_handle *info)\n /* Print a VMA value into a string.  */\n \n static void\n-print_vma (bfd_vma vma, char *buf, bfd_boolean unsignedp, bfd_boolean hexp)\n+print_vma (bfd_vma vma, char *buf, bool unsignedp, bool hexp)\n {\n   if (sizeof (vma) <= sizeof (unsigned long))\n     {\n@@ -531,7 +524,7 @@ print_vma (bfd_vma vma, char *buf, bfd_boolean unsignedp, bfd_boolean hexp)\n \f\n /* Start a new compilation unit.  */\n \n-static bfd_boolean\n+static bool\n pr_start_compilation_unit (void *p, const char *filename)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -540,12 +533,12 @@ pr_start_compilation_unit (void *p, const char *filename)\n \n   fprintf (info->f, \"%s:\\n\", filename);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start a source file within a compilation unit.  */\n \n-static bfd_boolean\n+static bool\n pr_start_source (void *p, const char *filename)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -554,12 +547,12 @@ pr_start_source (void *p, const char *filename)\n \n   fprintf (info->f, \" %s:\\n\", filename);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push an empty type onto the type stack.  */\n \n-static bfd_boolean\n+static bool\n pr_empty_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -569,7 +562,7 @@ pr_empty_type (void *p)\n \n /* Push a void type onto the type stack.  */\n \n-static bfd_boolean\n+static bool\n pr_void_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -579,8 +572,8 @@ pr_void_type (void *p)\n \n /* Push an integer type onto the type stack.  */\n \n-static bfd_boolean\n-pr_int_type (void *p, unsigned int size, bfd_boolean unsignedp)\n+static bool\n+pr_int_type (void *p, unsigned int size, bool unsignedp)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char ab[40];\n@@ -591,7 +584,7 @@ pr_int_type (void *p, unsigned int size, bfd_boolean unsignedp)\n \n /* Push a floating type onto the type stack.  */\n \n-static bfd_boolean\n+static bool\n pr_float_type (void *p, unsigned int size)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -608,20 +601,20 @@ pr_float_type (void *p, unsigned int size)\n \n /* Push a complex type onto the type stack.  */\n \n-static bfd_boolean\n+static bool\n pr_complex_type (void *p, unsigned int size)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n \n   if (! pr_float_type (p, size))\n-    return FALSE;\n+    return false;\n \n   return prepend_type (info, \"complex \");\n }\n \n-/* Push a bfd_boolean type onto the type stack.  */\n+/* Push a bool type onto the type stack.  */\n \n-static bfd_boolean\n+static bool\n pr_bool_type (void *p, unsigned int size)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -634,7 +627,7 @@ pr_bool_type (void *p, unsigned int size)\n \n /* Push an enum type onto the type stack.  */\n \n-static bfd_boolean\n+static bool\n pr_enum_type (void *p, const char *tag, const char **names,\n \t      bfd_signed_vma *values)\n {\n@@ -643,20 +636,20 @@ pr_enum_type (void *p, const char *tag, const char **names,\n   bfd_signed_vma val;\n \n   if (! push_type (info, \"enum \"))\n-    return FALSE;\n+    return false;\n   if (tag != NULL)\n     {\n       if (! append_type (info, tag)\n \t  || ! append_type (info, \" \"))\n-\treturn FALSE;\n+\treturn false;\n     }\n   if (! append_type (info, \"{ \"))\n-    return FALSE;\n+    return false;\n \n   if (names == NULL)\n     {\n       if (! append_type (info, \"/* undefined */\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n   else\n     {\n@@ -666,20 +659,20 @@ pr_enum_type (void *p, const char *tag, const char **names,\n \t  if (i > 0)\n \t    {\n \t      if (! append_type (info, \", \"))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \n \t  if (! append_type (info, names[i]))\n-\t    return FALSE;\n+\t    return false;\n \n \t  if (values[i] != val)\n \t    {\n \t      char ab[22];\n \n-\t      print_vma (values[i], ab, FALSE, FALSE);\n+\t      print_vma (values[i], ab, false, false);\n \t      if (! append_type (info, \" = \")\n \t\t  || ! append_type (info, ab))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      val = values[i];\n \t    }\n \n@@ -692,7 +685,7 @@ pr_enum_type (void *p, const char *tag, const char **names,\n \n /* Turn the top type on the stack into a pointer.  */\n \n-static bfd_boolean\n+static bool\n pr_pointer_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -708,8 +701,8 @@ pr_pointer_type (void *p)\n \n /* Turn the top type on the stack into a function returning that type.  */\n \n-static bfd_boolean\n-pr_function_type (void *p, int argcount, bfd_boolean varargs)\n+static bool\n+pr_function_type (void *p, int argcount, bool varargs)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char **arg_types;\n@@ -735,13 +728,13 @@ pr_function_type (void *p, int argcount, bfd_boolean varargs)\n \t  if (! substitute_type (info, \"\"))\n \t    {\n \t      free (arg_types);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  arg_types[i] = pop_type (info);\n \t  if (arg_types[i] == NULL)\n \t    {\n \t      free (arg_types);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  len += strlen (arg_types[i]) + 2;\n \t}\n@@ -779,16 +772,16 @@ pr_function_type (void *p, int argcount, bfd_boolean varargs)\n   strcat (s, \")\");\n \n   if (! substitute_type (info, s))\n-    return FALSE;\n+    return false;\n \n   free (s);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Turn the top type on the stack into a reference to that type.  */\n \n-static bfd_boolean\n+static bool\n pr_reference_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -800,7 +793,7 @@ pr_reference_type (void *p)\n \n /* Make a range type.  */\n \n-static bfd_boolean\n+static bool\n pr_range_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -809,10 +802,10 @@ pr_range_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper)\n   assert (info->stack != NULL);\n \n   if (! substitute_type (info, \"\"))\n-    return FALSE;\n+    return false;\n \n-  print_vma (lower, abl, FALSE, FALSE);\n-  print_vma (upper, abu, FALSE, FALSE);\n+  print_vma (lower, abl, false, false);\n+  print_vma (upper, abu, false, false);\n \n   return (prepend_type (info, \"range (\")\n \t  && append_type (info, \"):\")\n@@ -823,91 +816,91 @@ pr_range_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper)\n \n /* Make an array type.  */\n \n-static bfd_boolean\n+static bool\n pr_array_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper,\n-\t       bfd_boolean stringp)\n+\t       bool stringp)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *range_type;\n   char abl[22], abu[22], ab[50];\n \n   range_type = pop_type (info);\n   if (range_type == NULL)\n-    return FALSE;\n+    return false;\n \n   if (lower == 0)\n     {\n       if (upper == -1)\n \tsprintf (ab, \"|[]\");\n       else\n \t{\n-\t  print_vma (upper + 1, abu, FALSE, FALSE);\n+\t  print_vma (upper + 1, abu, false, false);\n \t  sprintf (ab, \"|[%s]\", abu);\n \t}\n     }\n   else\n     {\n-      print_vma (lower, abl, FALSE, FALSE);\n-      print_vma (upper, abu, FALSE, FALSE);\n+      print_vma (lower, abl, false, false);\n+      print_vma (upper, abu, false, false);\n       sprintf (ab, \"|[%s:%s]\", abl, abu);\n     }\n \n   if (! substitute_type (info, ab))\n-    return FALSE;\n+    return false;\n \n   if (strcmp (range_type, \"int\") != 0)\n     {\n       if (! append_type (info, \":\")\n \t  || ! append_type (info, range_type))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (stringp)\n     {\n       if (! append_type (info, \" /* string */\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Make a set type.  */\n \n-static bfd_boolean\n-pr_set_type (void *p, bfd_boolean bitstringp)\n+static bool\n+pr_set_type (void *p, bool bitstringp)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n \n   if (! substitute_type (info, \"\"))\n-    return FALSE;\n+    return false;\n \n   if (! prepend_type (info, \"set { \")\n       || ! append_type (info, \" }\"))\n-    return FALSE;\n+    return false;\n \n   if (bitstringp)\n     {\n       if (! append_type (info, \"/* bitstring */\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Make an offset type.  */\n \n-static bfd_boolean\n+static bool\n pr_offset_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *t;\n \n   if (! substitute_type (info, \"\"))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   return (substitute_type (info, \"\")\n \t  && prepend_type (info, \" \")\n@@ -917,8 +910,8 @@ pr_offset_type (void *p)\n \n /* Make a method type.  */\n \n-static bfd_boolean\n-pr_method_type (void *p, bfd_boolean domain, int argcount, bfd_boolean varargs)\n+static bool\n+pr_method_type (void *p, bool domain, int argcount, bool varargs)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   unsigned int len;\n@@ -933,10 +926,10 @@ pr_method_type (void *p, bfd_boolean domain, int argcount, bfd_boolean varargs)\n   else\n     {\n       if (! substitute_type (info, \"\"))\n-\treturn FALSE;\n+\treturn false;\n       domain_type = pop_type (info);\n       if (domain_type == NULL)\n-\treturn FALSE;\n+\treturn false;\n       if (startswith (domain_type, \"class \")\n \t  && strchr (domain_type + sizeof \"class \" - 1, ' ') == NULL)\n \tdomain_type += sizeof \"class \" - 1;\n@@ -962,13 +955,13 @@ pr_method_type (void *p, bfd_boolean domain, int argcount, bfd_boolean varargs)\n \t  if (! substitute_type (info, \"\"))\n \t    {\n \t      free (arg_types);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  arg_types[i] = pop_type (info);\n \t  if (arg_types[i] == NULL)\n \t    {\n \t      free (arg_types);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  len += strlen (arg_types[i]) + 2;\n \t}\n@@ -1010,16 +1003,16 @@ pr_method_type (void *p, bfd_boolean domain, int argcount, bfd_boolean varargs)\n   strcat (s, \")\");\n \n   if (! substitute_type (info, s))\n-    return FALSE;\n+    return false;\n \n   free (s);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Make a const qualified type.  */\n \n-static bfd_boolean\n+static bool\n pr_const_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1029,7 +1022,7 @@ pr_const_type (void *p)\n \n /* Make a volatile qualified type.  */\n \n-static bfd_boolean\n+static bool\n pr_volatile_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1039,56 +1032,56 @@ pr_volatile_type (void *p)\n \n /* Start accumulating a struct type.  */\n \n-static bfd_boolean\n+static bool\n pr_start_struct_type (void *p, const char *tag, unsigned int id,\n-\t\t      bfd_boolean structp, unsigned int size)\n+\t\t      bool structp, unsigned int size)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n \n   info->indent += 2;\n \n   if (! push_type (info, structp ? \"struct \" : \"union \"))\n-    return FALSE;\n+    return false;\n   if (tag != NULL)\n     {\n       if (! append_type (info, tag))\n-\treturn FALSE;\n+\treturn false;\n     }\n   else\n     {\n       char idbuf[20];\n \n       sprintf (idbuf, \"%%anon%u\", id);\n       if (! append_type (info, idbuf))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (! append_type (info, \" {\"))\n-    return FALSE;\n+    return false;\n   if (size != 0 || tag != NULL)\n     {\n       char ab[30];\n \n       if (! append_type (info, \" /*\"))\n-\treturn FALSE;\n+\treturn false;\n \n       if (size != 0)\n \t{\n \t  sprintf (ab, \" size %u\", size);\n \t  if (! append_type (info, ab))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       if (tag != NULL)\n \t{\n \t  sprintf (ab, \" id %u\", id);\n \t  if (! append_type (info, ab))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       if (! append_type (info, \" */\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n   if (! append_type (info, \"\\n\"))\n-    return FALSE;\n+    return false;\n \n   info->stack->visibility = DEBUG_VISIBILITY_PUBLIC;\n \n@@ -1097,7 +1090,7 @@ pr_start_struct_type (void *p, const char *tag, unsigned int id,\n \n /* Output the visibility of a field in a struct.  */\n \n-static bfd_boolean\n+static bool\n pr_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)\n {\n   const char *s = NULL;\n@@ -1107,7 +1100,7 @@ pr_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)\n   assert (info->stack != NULL);\n \n   if (info->stack->visibility == visibility)\n-    return TRUE;\n+    return true;\n \n   switch (visibility)\n     {\n@@ -1125,7 +1118,7 @@ pr_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)\n       break;\n     default:\n       abort ();\n-      return FALSE;\n+      return false;\n     }\n \n   /* Trim off a trailing space in the struct string, to make the\n@@ -1139,16 +1132,16 @@ pr_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)\n   if (! append_type (info, s)\n       || ! append_type (info, \":\\n\")\n       || ! indent_type (info))\n-    return FALSE;\n+    return false;\n \n   info->stack->visibility = visibility;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a field to a struct type.  */\n \n-static bfd_boolean\n+static bool\n pr_struct_field (void *p, const char *name, bfd_vma bitpos, bfd_vma bitsize,\n \t\t enum debug_visibility visibility)\n {\n@@ -1157,40 +1150,40 @@ pr_struct_field (void *p, const char *name, bfd_vma bitpos, bfd_vma bitsize,\n   char *t;\n \n   if (! substitute_type (info, name))\n-    return FALSE;\n+    return false;\n \n   if (! append_type (info, \"; /* \"))\n-    return FALSE;\n+    return false;\n \n   if (bitsize != 0)\n     {\n-      print_vma (bitsize, ab, TRUE, FALSE);\n+      print_vma (bitsize, ab, true, false);\n       if (! append_type (info, \"bitsize \")\n \t  || ! append_type (info, ab)\n \t  || ! append_type (info, \", \"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  print_vma (bitpos, ab, TRUE, FALSE);\n+  print_vma (bitpos, ab, true, false);\n   if (! append_type (info, \"bitpos \")\n       || ! append_type (info, ab)\n       || ! append_type (info, \" */\\n\")\n       || ! indent_type (info))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   if (! pr_fix_visibility (info, visibility))\n-    return FALSE;\n+    return false;\n \n   return append_type (info, t);\n }\n \n /* Finish a struct type.  */\n \n-static bfd_boolean\n+static bool\n pr_end_struct_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1208,15 +1201,15 @@ pr_end_struct_type (void *p)\n   *s++ = '}';\n   *s = '\\0';\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start a class type.  */\n \n-static bfd_boolean\n+static bool\n pr_start_class_type (void *p, const char *tag, unsigned int id,\n-\t\t     bfd_boolean structp, unsigned int size,\n-\t\t     bfd_boolean vptr, bfd_boolean ownvptr)\n+\t\t     bool structp, unsigned int size,\n+\t\t     bool vptr, bool ownvptr)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *tv = NULL;\n@@ -1227,31 +1220,31 @@ pr_start_class_type (void *p, const char *tag, unsigned int id,\n     {\n       tv = pop_type (info);\n       if (tv == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (! push_type (info, structp ? \"class \" : \"union class \"))\n-    return FALSE;\n+    return false;\n   if (tag != NULL)\n     {\n       if (! append_type (info, tag))\n-\treturn FALSE;\n+\treturn false;\n     }\n   else\n     {\n       char idbuf[20];\n \n       sprintf (idbuf, \"%%anon%u\", id);\n       if (! append_type (info, idbuf))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (! append_type (info, \" {\"))\n-    return FALSE;\n+    return false;\n   if (size != 0 || vptr || ownvptr || tag != NULL)\n     {\n       if (! append_type (info, \" /*\"))\n-\treturn FALSE;\n+\treturn false;\n \n       if (size != 0)\n \t{\n@@ -1260,23 +1253,23 @@ pr_start_class_type (void *p, const char *tag, unsigned int id,\n \t  sprintf (ab, \"%u\", size);\n \t  if (! append_type (info, \" size \")\n \t      || ! append_type (info, ab))\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n       if (vptr)\n \t{\n \t  if (! append_type (info, \" vtable \"))\n-\t    return FALSE;\n+\t    return false;\n \t  if (ownvptr)\n \t    {\n \t      if (! append_type (info, \"self \"))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t  else\n \t    {\n \t      if (! append_type (info, tv)\n \t\t  || ! append_type (info, \" \"))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t}\n \n@@ -1286,11 +1279,11 @@ pr_start_class_type (void *p, const char *tag, unsigned int id,\n \n \t  sprintf (ab, \" id %u\", id);\n \t  if (! append_type (info, ab))\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n       if (! append_type (info, \" */\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   info->stack->visibility = DEBUG_VISIBILITY_PRIVATE;\n@@ -1301,37 +1294,37 @@ pr_start_class_type (void *p, const char *tag, unsigned int id,\n \n /* Add a static member to a class.  */\n \n-static bfd_boolean\n+static bool\n pr_class_static_member (void *p, const char *name, const char *physname,\n \t\t\tenum debug_visibility visibility)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *t;\n \n   if (! substitute_type (info, name))\n-    return FALSE;\n+    return false;\n \n   if (! prepend_type (info, \"static \")\n       || ! append_type (info, \"; /* \")\n       || ! append_type (info, physname)\n       || ! append_type (info, \" */\\n\")\n       || ! indent_type (info))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   if (! pr_fix_visibility (info, visibility))\n-    return FALSE;\n+    return false;\n \n   return append_type (info, t);\n }\n \n /* Add a base class to a class.  */\n \n-static bfd_boolean\n-pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n+static bool\n+pr_class_baseclass (void *p, bfd_vma bitpos, bool is_virtual,\n \t\t    enum debug_visibility visibility)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1343,24 +1336,24 @@ pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n   assert (info->stack != NULL && info->stack->next != NULL);\n \n   if (! substitute_type (info, \"\"))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   if (startswith (t, \"class \"))\n     t += sizeof \"class \" - 1;\n \n   /* Push it back on to take advantage of the prepend_type and\n      append_type routines.  */\n   if (! push_type (info, t))\n-    return FALSE;\n+    return false;\n \n   if (is_virtual)\n     {\n       if (! prepend_type (info, \"virtual \"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   switch (visibility)\n@@ -1380,15 +1373,15 @@ pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n     }\n \n   if (! prepend_type (info, prefix))\n-    return FALSE;\n+    return false;\n \n   if (bitpos != 0)\n     {\n-      print_vma (bitpos, ab, TRUE, FALSE);\n+      print_vma (bitpos, ab, true, false);\n       if (! append_type (info, \" /* bitpos \")\n \t  || ! append_type (info, ab)\n \t  || ! append_type (info, \" */\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Now the top of the stack is something like \"public A / * bitpos\n@@ -1405,11 +1398,11 @@ pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n     if (*l == ':')\n       break;\n   if (! prepend_type (info, l == s ? \" : \" : \", \"))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   n = (char *) xmalloc (strlen (info->stack->type) + strlen (t) + 1);\n   memcpy (n, info->stack->type, s - info->stack->type);\n@@ -1421,28 +1414,28 @@ pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n \n   free (t);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start adding a method to a class.  */\n \n-static bfd_boolean\n+static bool\n pr_class_start_method (void *p, const char *name)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n \n   assert (info->stack != NULL);\n   info->stack->method = name;\n-  return TRUE;\n+  return true;\n }\n \n /* Add a variant to a method.  */\n \n-static bfd_boolean\n+static bool\n pr_class_method_variant (void *p, const char *physname,\n \t\t\t enum debug_visibility visibility,\n-\t\t\t bfd_boolean constp, bfd_boolean volatilep,\n-\t\t\t bfd_vma voffset, bfd_boolean context)\n+\t\t\t bool constp, bool volatilep,\n+\t\t\t bfd_vma voffset, bool context)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *method_type;\n@@ -1455,25 +1448,25 @@ pr_class_method_variant (void *p, const char *physname,\n   if (volatilep)\n     {\n       if (! append_type (info, \" volatile\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n   if (constp)\n     {\n       if (! append_type (info, \" const\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Stick the name of the method into its type.  */\n   if (! substitute_type (info,\n \t\t\t (context\n \t\t\t  ? info->stack->next->next->method\n \t\t\t  : info->stack->next->method)))\n-    return FALSE;\n+    return false;\n \n   /* Get the type.  */\n   method_type = pop_type (info);\n   if (method_type == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Pull off the context type if there is one.  */\n   if (! context)\n@@ -1482,19 +1475,19 @@ pr_class_method_variant (void *p, const char *physname,\n     {\n       context_type = pop_type (info);\n       if (context_type == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Now the top of the stack is the class.  */\n \n   if (! pr_fix_visibility (info, visibility))\n-    return FALSE;\n+    return false;\n \n   if (! append_type (info, method_type)\n       || ! append_type (info, \" /* \")\n       || ! append_type (info, physname)\n       || ! append_type (info, \" \"))\n-    return FALSE;\n+    return false;\n   if (context || voffset != 0)\n     {\n       char ab[22];\n@@ -1504,12 +1497,12 @@ pr_class_method_variant (void *p, const char *physname,\n \t  if (! append_type (info, \"context \")\n \t      || ! append_type (info, context_type)\n \t      || ! append_type (info, \" \"))\n-\t    return FALSE;\n+\t    return false;\n \t}\n-      print_vma (voffset, ab, TRUE, FALSE);\n+      print_vma (voffset, ab, true, false);\n       if (! append_type (info, \"voffset \")\n \t  || ! append_type (info, ab))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   return (append_type (info, \" */;\\n\")\n@@ -1518,10 +1511,10 @@ pr_class_method_variant (void *p, const char *physname,\n \n /* Add a static variant to a method.  */\n \n-static bfd_boolean\n+static bool\n pr_class_static_method_variant (void *p, const char *physname,\n \t\t\t\tenum debug_visibility visibility,\n-\t\t\t\tbfd_boolean constp, bfd_boolean volatilep)\n+\t\t\t\tbool constp, bool volatilep)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *method_type;\n@@ -1534,31 +1527,31 @@ pr_class_static_method_variant (void *p, const char *physname,\n   if (volatilep)\n     {\n       if (! append_type (info, \" volatile\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n   if (constp)\n     {\n       if (! append_type (info, \" const\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Mark it as static.  */\n   if (! prepend_type (info, \"static \"))\n-    return FALSE;\n+    return false;\n \n   /* Stick the name of the method into its type.  */\n   if (! substitute_type (info, info->stack->next->method))\n-    return FALSE;\n+    return false;\n \n   /* Get the type.  */\n   method_type = pop_type (info);\n   if (method_type == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Now the top of the stack is the class.  */\n \n   if (! pr_fix_visibility (info, visibility))\n-    return FALSE;\n+    return false;\n \n   return (append_type (info, method_type)\n \t  && append_type (info, \" /* \")\n@@ -1569,26 +1562,26 @@ pr_class_static_method_variant (void *p, const char *physname,\n \n /* Finish up a method.  */\n \n-static bfd_boolean\n+static bool\n pr_class_end_method (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n \n   info->stack->method = NULL;\n-  return TRUE;\n+  return true;\n }\n \n /* Finish up a class.  */\n \n-static bfd_boolean\n+static bool\n pr_end_class_type (void *p)\n {\n   return pr_end_struct_type (p);\n }\n \n /* Push a type on the stack using a typedef name.  */\n \n-static bfd_boolean\n+static bool\n pr_typedef_type (void *p, const char *name)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1598,7 +1591,7 @@ pr_typedef_type (void *p, const char *name)\n \n /* Push a type on the stack using a tag name.  */\n \n-static bfd_boolean\n+static bool\n pr_tag_type (void *p, const char *name, unsigned int id,\n \t     enum debug_type_kind kind)\n {\n@@ -1625,11 +1618,11 @@ pr_tag_type (void *p, const char *name, unsigned int id,\n       break;\n     default:\n       /* PR 25625: Corrupt input can trigger this case.  */\n-      return FALSE;\n+      return false;\n     }\n \n   if (! push_type (info, t))\n-    return FALSE;\n+    return false;\n   if (name != NULL)\n     tag = name;\n   else\n@@ -1639,90 +1632,90 @@ pr_tag_type (void *p, const char *name, unsigned int id,\n     }\n \n   if (! append_type (info, tag))\n-    return FALSE;\n+    return false;\n   if (name != NULL && kind != DEBUG_KIND_ENUM)\n     {\n       sprintf (idbuf, \" /* id %u */\", id);\n       if (! append_type (info, idbuf))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a typedef.  */\n \n-static bfd_boolean\n+static bool\n pr_typdef (void *p, const char *name)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *s;\n \n   if (! substitute_type (info, name))\n-    return FALSE;\n+    return false;\n \n   s = pop_type (info);\n   if (s == NULL)\n-    return FALSE;\n+    return false;\n \n   indent (info);\n   fprintf (info->f, \"typedef %s;\\n\", s);\n \n   free (s);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a tag.  The tag should already be in the string on the\n    stack, so all we have to do here is print it out.  */\n \n-static bfd_boolean\n+static bool\n pr_tag (void *p, const char *name ATTRIBUTE_UNUSED)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *t;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   indent (info);\n   fprintf (info->f, \"%s;\\n\", t);\n \n   free (t);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output an integer constant.  */\n \n-static bfd_boolean\n+static bool\n pr_int_constant (void *p, const char *name, bfd_vma val)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char ab[22];\n \n   indent (info);\n-  print_vma (val, ab, FALSE, FALSE);\n+  print_vma (val, ab, false, false);\n   fprintf (info->f, \"const int %s = %s;\\n\", name, ab);\n-  return TRUE;\n+  return true;\n }\n \n /* Output a floating point constant.  */\n \n-static bfd_boolean\n+static bool\n pr_float_constant (void *p, const char *name, double val)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n \n   indent (info);\n   fprintf (info->f, \"const double %s = %g;\\n\", name, val);\n-  return TRUE;\n+  return true;\n }\n \n /* Output a typed constant.  */\n \n-static bfd_boolean\n+static bool\n pr_typed_constant (void *p, const char *name, bfd_vma val)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1731,20 +1724,20 @@ pr_typed_constant (void *p, const char *name, bfd_vma val)\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   indent (info);\n-  print_vma (val, ab, FALSE, FALSE);\n+  print_vma (val, ab, false, false);\n   fprintf (info->f, \"const %s %s = %s;\\n\", t, name, ab);\n \n   free (t);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a variable.  */\n \n-static bfd_boolean\n+static bool\n pr_variable (void *p, const char *name, enum debug_var_kind kind,\n \t     bfd_vma val)\n {\n@@ -1753,11 +1746,11 @@ pr_variable (void *p, const char *name, enum debug_var_kind kind,\n   char ab[22];\n \n   if (! substitute_type (info, name))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   indent (info);\n   switch (kind)\n@@ -1772,28 +1765,28 @@ pr_variable (void *p, const char *name, enum debug_var_kind kind,\n     default:\n       break;\n     }\n-  print_vma (val, ab, TRUE, TRUE);\n+  print_vma (val, ab, true, true);\n   fprintf (info->f, \"%s /* %s */;\\n\", t, ab);\n \n   free (t);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start outputting a function.  */\n \n-static bfd_boolean\n-pr_start_function (void *p, const char *name, bfd_boolean global)\n+static bool\n+pr_start_function (void *p, const char *name, bool global)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *t;\n \n   if (! substitute_type (info, name))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   indent (info);\n   if (! global)\n@@ -1802,12 +1795,12 @@ pr_start_function (void *p, const char *name, bfd_boolean global)\n \n   info->parameter = 1;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a function parameter.  */\n \n-static bfd_boolean\n+static bool\n pr_function_parameter (void *p, const char *name,\n \t\t       enum debug_parm_kind kind, bfd_vma val)\n {\n@@ -1819,35 +1812,35 @@ pr_function_parameter (void *p, const char *name,\n       || kind == DEBUG_PARM_REF_REG)\n     {\n       if (! pr_reference_type (p))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (! substitute_type (info, name))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   if (info->parameter != 1)\n     fprintf (info->f, \", \");\n \n   if (kind == DEBUG_PARM_REG || kind == DEBUG_PARM_REF_REG)\n     fprintf (info->f, \"register \");\n \n-  print_vma (val, ab, TRUE, TRUE);\n+  print_vma (val, ab, true, true);\n   fprintf (info->f, \"%s /* %s */\", t, ab);\n \n   free (t);\n \n   ++info->parameter;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start writing out a block.  */\n \n-static bfd_boolean\n+static bool\n pr_start_block (void *p, bfd_vma addr)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1860,32 +1853,32 @@ pr_start_block (void *p, bfd_vma addr)\n     }\n \n   indent (info);\n-  print_vma (addr, ab, TRUE, TRUE);\n+  print_vma (addr, ab, true, true);\n   fprintf (info->f, \"{ /* %s */\\n\", ab);\n \n   info->indent += 2;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Write out line number information.  */\n \n-static bfd_boolean\n+static bool\n pr_lineno (void *p, const char *filename, unsigned long lineno, bfd_vma addr)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char ab[22];\n \n   indent (info);\n-  print_vma (addr, ab, TRUE, TRUE);\n+  print_vma (addr, ab, true, true);\n   fprintf (info->f, \"/* file %s line %lu addr %s */\\n\", filename, lineno, ab);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Finish writing out a block.  */\n \n-static bfd_boolean\n+static bool\n pr_end_block (void *p, bfd_vma addr)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1894,18 +1887,18 @@ pr_end_block (void *p, bfd_vma addr)\n   info->indent -= 2;\n \n   indent (info);\n-  print_vma (addr, ab, TRUE, TRUE);\n+  print_vma (addr, ab, true, true);\n   fprintf (info->f, \"} /* %s */\\n\", ab);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Finish writing out a function.  */\n \n-static bfd_boolean\n+static bool\n pr_end_function (void *p ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \f\n /* Tags style generation functions start here.  */\n@@ -1915,7 +1908,7 @@ static bfd_vma pc;\n static const char *filename;\n static const char *functionname;\n static unsigned int line;\n-static bfd_boolean found;\n+static bool found;\n \n /* Look for an address in a section.  This is called via\n    bfd_map_over_sections.  */\n@@ -1949,7 +1942,7 @@ static void\n translate_addresses (bfd *abfd, char *addr_hex, FILE *f, asymbol **syms)\n {\n   pc = bfd_scan_vma (addr_hex, NULL, 16);\n-  found = FALSE;\n+  found = false;\n   bfd_map_over_sections (abfd, find_address_in_section, syms);\n \n   if (! found)\n@@ -1960,7 +1953,7 @@ translate_addresses (bfd *abfd, char *addr_hex, FILE *f, asymbol **syms)\n \n /* Start a new compilation unit.  */\n \n-static bfd_boolean\n+static bool\n tg_start_compilation_unit (void * p, const char *fname ATTRIBUTE_UNUSED)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1969,12 +1962,12 @@ tg_start_compilation_unit (void * p, const char *fname ATTRIBUTE_UNUSED)\n   /* Should it be relative? best way to do it here?.  */\n   info->filename = strdup (fname);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start a source file within a compilation unit.  */\n \n-static bfd_boolean\n+static bool\n tg_start_source (void *p, const char *fname)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -1983,12 +1976,12 @@ tg_start_source (void *p, const char *fname)\n   /* Should it be relative? best way to do it here?.  */\n   info->filename = strdup (fname);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push an enum type onto the type stack.  */\n \n-static bfd_boolean\n+static bool\n tg_enum_type (void *p, const char *tag, const char **names,\n \t      bfd_signed_vma *values)\n {\n@@ -1998,7 +1991,7 @@ tg_enum_type (void *p, const char *tag, const char **names,\n   char ab[22];\n \n   if (! pr_enum_type (p, tag, names, values))\n-    return FALSE;\n+    return false;\n \n   name = tag ? tag : \"unknown\";\n   /* Generate an entry for the enum.  */\n@@ -2011,20 +2004,20 @@ tg_enum_type (void *p, const char *tag, const char **names,\n     {\n       for (i = 0; names[i] != NULL; i++)\n \t{\n-\t  print_vma (values[i], ab, FALSE, FALSE);\n+\t  print_vma (values[i], ab, false, false);\n \t  fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:g\\tenum:%s\\tvalue:%s\\n\",\n \t\t   names[i], info->filename, name, ab);\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start accumulating a struct type.  */\n \n-static bfd_boolean\n+static bool\n tg_start_struct_type (void *p, const char *tag, unsigned int id,\n-\t\t      bfd_boolean structp,\n+\t\t      bool structp,\n \t\t      unsigned int size ATTRIBUTE_UNUSED)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -2040,7 +2033,7 @@ tg_start_struct_type (void *p, const char *tag, unsigned int id,\n     }\n \n   if (! push_type (info, name))\n-    return FALSE;\n+    return false;\n \n   info->stack->flavor = structp ? \"struct\" : \"union\";\n \n@@ -2054,24 +2047,24 @@ tg_start_struct_type (void *p, const char *tag, unsigned int id,\n \n /* Output the visibility of a field in a struct.  */\n \n-static bfd_boolean\n+static bool\n tg_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)\n {\n   assert (info->stack != NULL);\n \n   if (info->stack->visibility == visibility)\n-    return TRUE;\n+    return true;\n \n   assert (info->stack->visibility != DEBUG_VISIBILITY_IGNORE);\n \n   info->stack->visibility = visibility;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a field to a struct type.  */\n \n-static bfd_boolean\n+static bool\n tg_struct_field (void *p, const char *name, bfd_vma bitpos ATTRIBUTE_UNUSED,\n \t\t bfd_vma bitsize ATTRIBUTE_UNUSED,\n \t\t enum debug_visibility visibility)\n@@ -2081,38 +2074,38 @@ tg_struct_field (void *p, const char *name, bfd_vma bitpos ATTRIBUTE_UNUSED,\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   if (! tg_fix_visibility (info, visibility))\n-    return FALSE;\n+    return false;\n \n   /* It happens, a bug? */\n   if (! name[0])\n-    return TRUE;\n+    return true;\n \n   fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:m\\ttype:%s\\t%s:%s\\taccess:%s\\n\",\n \t   name, info->filename, t, info->stack->flavor, info->stack->type,\n \t   visibility_name (visibility));\n \n-  return TRUE;\n+  return true;\n }\n \n /* Finish a struct type.  */\n \n-static bfd_boolean\n+static bool\n tg_end_struct_type (void *p ATTRIBUTE_UNUSED)\n {\n   assert (((struct pr_handle *) p)->stack != NULL);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start a class type.  */\n \n-static bfd_boolean\n+static bool\n tg_start_class_type (void *p, const char *tag, unsigned int id,\n-\t\t     bfd_boolean structp, unsigned int size,\n-\t\t     bfd_boolean vptr, bfd_boolean ownvptr)\n+\t\t     bool structp, unsigned int size,\n+\t\t     bool vptr, bool ownvptr)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *tv = NULL;\n@@ -2125,7 +2118,7 @@ tg_start_class_type (void *p, const char *tag, unsigned int id,\n     {\n       tv = pop_type (info);\n       if (tv == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (tag != NULL)\n@@ -2137,7 +2130,7 @@ tg_start_class_type (void *p, const char *tag, unsigned int id,\n     }\n \n   if (! push_type (info, name))\n-    return FALSE;\n+    return false;\n \n   info->stack->flavor = structp ? \"class\" : \"union class\";\n   info->stack->parents = NULL;\n@@ -2148,29 +2141,29 @@ tg_start_class_type (void *p, const char *tag, unsigned int id,\n       if (vptr)\n \t{\n \t  if (! append_type (info, \" vtable \"))\n-\t    return FALSE;\n+\t    return false;\n \t  if (ownvptr)\n \t    {\n \t      if (! append_type (info, \"self \"))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t  else\n \t    {\n \t      if (! append_type (info, tv)\n \t\t  || ! append_type (info, \" \"))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t}\n     }\n \n   info->stack->visibility = DEBUG_VISIBILITY_PRIVATE;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a static member to a class.  */\n \n-static bfd_boolean\n+static bool\n tg_class_static_member (void *p, const char *name,\n \t\t\tconst char *physname ATTRIBUTE_UNUSED,\n \t\t\tenum debug_visibility visibility)\n@@ -2184,33 +2177,33 @@ tg_class_static_member (void *p, const char *name,\n   len_class = strlen (info->stack->next->type);\n   full_name = (char *) xmalloc (len_var + len_class + 3);\n   if (! full_name)\n-    return FALSE;\n+    return false;\n   sprintf (full_name, \"%s::%s\", info->stack->next->type, name);\n \n   if (! substitute_type (info, full_name))\n     {\n       free (full_name);\n-      return FALSE;\n+      return false;\n     }\n \n   if (! prepend_type (info, \"static \"))\n     {\n       free (full_name);\n-      return FALSE;\n+      return false;\n     }\n \n   t = pop_type (info);\n   if (t == NULL)\n     {\n       free (full_name);\n-      return FALSE;\n+      return false;\n     }\n \n   if (! tg_fix_visibility (info, visibility))\n     {\n       free (t);\n       free (full_name);\n-      return FALSE;\n+      return false;\n     }\n \n   fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:x\\ttype:%s\\tclass:%s\\taccess:%s\\n\",\n@@ -2219,14 +2212,14 @@ tg_class_static_member (void *p, const char *name,\n   free (t);\n   free (full_name);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a base class to a class.  */\n \n-static bfd_boolean\n+static bool\n tg_class_baseclass (void *p, bfd_vma bitpos ATTRIBUTE_UNUSED,\n-\t\t    bfd_boolean is_virtual, enum debug_visibility visibility)\n+\t\t    bool is_virtual, enum debug_visibility visibility)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *t;\n@@ -2236,20 +2229,20 @@ tg_class_baseclass (void *p, bfd_vma bitpos ATTRIBUTE_UNUSED,\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   if (startswith (t, \"class \"))\n     t += sizeof \"class \" - 1;\n \n   /* Push it back on to take advantage of the prepend_type and\n      append_type routines.  */\n   if (! push_type (info, t))\n-    return FALSE;\n+    return false;\n \n   if (is_virtual)\n     {\n       if (! prepend_type (info, \"virtual \"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   switch (visibility)\n@@ -2269,32 +2262,32 @@ tg_class_baseclass (void *p, bfd_vma bitpos ATTRIBUTE_UNUSED,\n     }\n \n   if (! prepend_type (info, prefix))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   if (info->stack->num_parents && ! append_parent (info, \", \"))\n-    return FALSE;\n+    return false;\n \n   if (! append_parent (info, t))\n-    return FALSE;\n+    return false;\n   info->stack->num_parents++;\n \n   free (t);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a variant to a method.  */\n \n-static bfd_boolean\n+static bool\n tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,\n \t\t\t enum debug_visibility visibility,\n-\t\t\t bfd_boolean constp, bfd_boolean volatilep,\n+\t\t\t bool constp, bool volatilep,\n \t\t\t bfd_vma voffset ATTRIBUTE_UNUSED,\n-\t\t\t bfd_boolean context)\n+\t\t\t bool context)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *method_type;\n@@ -2308,12 +2301,12 @@ tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,\n   if (volatilep)\n     {\n       if (! append_type (info, \" volatile\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n   if (constp)\n     {\n       if (! append_type (info, \" const\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   method_name = strdup (context ? info->stack->next->next->method\n@@ -2323,15 +2316,15 @@ tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,\n   if (! substitute_type (info, method_name))\n     {\n       free (method_name);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Get the type.  */\n   method_type = pop_type (info);\n   if (method_type == NULL)\n     {\n       free (method_name);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Pull off the context type if there is one.  */\n@@ -2344,7 +2337,7 @@ tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,\n \t{\n \t  free (method_type);\n \t  free (method_name);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n@@ -2354,7 +2347,7 @@ tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,\n       free (method_type);\n       free (method_name);\n       free (context_type);\n-      return FALSE;\n+      return false;\n     }\n \n   fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:p\\ttype:%s\\tclass:%s\\n\",\n@@ -2363,16 +2356,16 @@ tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,\n   free (method_name);\n   free (context_type);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a static variant to a method.  */\n \n-static bfd_boolean\n+static bool\n tg_class_static_method_variant (void *p,\n \t\t\t\tconst char *physname ATTRIBUTE_UNUSED,\n \t\t\t\tenum debug_visibility visibility,\n-\t\t\t\tbfd_boolean constp, bfd_boolean volatilep)\n+\t\t\t\tbool constp, bool volatilep)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *method_type;\n@@ -2386,40 +2379,40 @@ tg_class_static_method_variant (void *p,\n   if (volatilep)\n     {\n       if (! append_type (info, \" volatile\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n   if (constp)\n     {\n       if (! append_type (info, \" const\"))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Mark it as static.  */\n   if (! prepend_type (info, \"static \"))\n-    return FALSE;\n+    return false;\n \n   method_name = strdup (info->stack->next->method);\n   /* Stick the name of the method into its type.  */\n   if (! substitute_type (info, info->stack->next->method))\n     {\n       free (method_name);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Get the type.  */\n   method_type = pop_type (info);\n   if (method_type == NULL)\n     {\n       free (method_name);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Now the top of the stack is the class.  */\n   if (! tg_fix_visibility (info, visibility))\n     {\n       free (method_type);\n       free (method_name);\n-      return FALSE;\n+      return false;\n     }\n \n   fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:p\\ttype:%s\\tclass:%s\\taccess:%s\\n\",\n@@ -2428,12 +2421,12 @@ tg_class_static_method_variant (void *p,\n   free (method_type);\n   free (method_name);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Finish up a class.  */\n \n-static bfd_boolean\n+static bool\n tg_end_class_type (void *p)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -2452,7 +2445,7 @@ tg_end_class_type (void *p)\n \n /* Push a type on the stack using a tag name.  */\n \n-static bfd_boolean\n+static bool\n tg_tag_type (void *p, const char *name, unsigned int id,\n \t     enum debug_type_kind kind)\n {\n@@ -2479,11 +2472,11 @@ tg_tag_type (void *p, const char *name, unsigned int id,\n       break;\n     default:\n       abort ();\n-      return FALSE;\n+      return false;\n     }\n \n   if (! push_type (info, t))\n-    return FALSE;\n+    return false;\n   if (name != NULL)\n     tag = name;\n   else\n@@ -2493,79 +2486,79 @@ tg_tag_type (void *p, const char *name, unsigned int id,\n     }\n \n   if (! append_type (info, tag))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a typedef.  */\n \n-static bfd_boolean\n+static bool\n tg_typdef (void *p, const char *name)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *s;\n \n   s = pop_type (info);\n   if (s == NULL)\n-    return FALSE;\n+    return false;\n \n   fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:t\\ttype:%s\\n\", name,\n \t   info->filename, s);\n \n   free (s);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a tag.  The tag should already be in the string on the\n    stack, so all we have to do here is print it out.  */\n \n-static bfd_boolean\n+static bool\n tg_tag (void *p ATTRIBUTE_UNUSED, const char *name ATTRIBUTE_UNUSED)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *t;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n   free (t);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output an integer constant.  */\n \n-static bfd_boolean\n+static bool\n tg_int_constant (void *p, const char *name, bfd_vma val)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char ab[22];\n \n   indent (info);\n-  print_vma (val, ab, FALSE, FALSE);\n+  print_vma (val, ab, false, false);\n   fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:v\\ttype:const int\\tvalue:%s\\n\",\n \t   name, info->filename, ab);\n-  return TRUE;\n+  return true;\n }\n \n /* Output a floating point constant.  */\n \n-static bfd_boolean\n+static bool\n tg_float_constant (void *p, const char *name, double val)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n \n   indent (info);\n   fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:v\\ttype:const double\\tvalue:%g\\n\",\n \t   name, info->filename, val);\n-  return TRUE;\n+  return true;\n }\n \n /* Output a typed constant.  */\n \n-static bfd_boolean\n+static bool\n tg_typed_constant (void *p, const char *name, bfd_vma val)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n@@ -2574,21 +2567,21 @@ tg_typed_constant (void *p, const char *name, bfd_vma val)\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   indent (info);\n-  print_vma (val, ab, FALSE, FALSE);\n+  print_vma (val, ab, false, false);\n   fprintf (info->f, \"%s\\t%s\\t0;\\\"\\tkind:v\\ttype:const %s\\tvalue:%s\\n\",\n \t   name, info->filename, t, ab);\n \n   free (t);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a variable.  */\n \n-static bfd_boolean\n+static bool\n tg_variable (void *p, const char *name, enum debug_var_kind kind,\n \t     bfd_vma val ATTRIBUTE_UNUSED)\n {\n@@ -2597,7 +2590,7 @@ tg_variable (void *p, const char *name, enum debug_var_kind kind,\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   dname = NULL;\n   if (info->demangler)\n@@ -2644,13 +2637,13 @@ tg_variable (void *p, const char *name, enum debug_var_kind kind,\n \n   free (t);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start outputting a function.  */\n \n-static bfd_boolean\n-tg_start_function (void *p, const char *name, bfd_boolean global)\n+static bool\n+tg_start_function (void *p, const char *name, bool global)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char *dname;\n@@ -2665,7 +2658,7 @@ tg_start_function (void *p, const char *name, bfd_boolean global)\n     dname = info->demangler (info->abfd, name, demangle_flags);\n \n   if (! substitute_type (info, dname ? dname : name))\n-    return FALSE;\n+    return false;\n \n   info->stack->method = NULL;\n   if (dname != NULL)\n@@ -2692,16 +2685,16 @@ tg_start_function (void *p, const char *name, bfd_boolean global)\n   info->stack->parents = strdup (name);\n \n   if (! info->stack->method && ! append_type (info, \"(\"))\n-    return FALSE;\n+    return false;\n \n   info->parameter = 1;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a function parameter.  */\n \n-static bfd_boolean\n+static bool\n tg_function_parameter (void *p, const char *name, enum debug_parm_kind kind,\n \t\t       bfd_vma val ATTRIBUTE_UNUSED)\n {\n@@ -2712,45 +2705,45 @@ tg_function_parameter (void *p, const char *name, enum debug_parm_kind kind,\n       || kind == DEBUG_PARM_REF_REG)\n     {\n       if (! pr_reference_type (p))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (! substitute_type (info, name))\n-    return FALSE;\n+    return false;\n \n   t = pop_type (info);\n   if (t == NULL)\n-    return FALSE;\n+    return false;\n \n   if (! info->stack->method)\n     {\n       if (info->parameter != 1 && ! append_type (info, \", \"))\n-\treturn FALSE;\n+\treturn false;\n \n       if (kind == DEBUG_PARM_REG || kind == DEBUG_PARM_REF_REG)\n \tif (! append_type (info, \"register \"))\n-\t  return FALSE;\n+\t  return false;\n \n       if (! append_type (info, t))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   free (t);\n \n   ++info->parameter;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start writing out a block.  */\n \n-static bfd_boolean\n+static bool\n tg_start_block (void *p, bfd_vma addr)\n {\n   struct pr_handle *info = (struct pr_handle *) p;\n   char ab[22], kind, *partof;\n   char *t;\n-  bfd_boolean local;\n+  bool local;\n \n   if (info->parameter > 0)\n     {\n@@ -2760,7 +2753,7 @@ tg_start_block (void *p, bfd_vma addr)\n       fprintf (info->f, \"%s\\t%s\\t\", info->stack->parents, info->filename);\n       free (info->stack->parents);\n \n-      print_vma (addr, ab, TRUE, TRUE);\n+      print_vma (addr, ab, true, true);\n       translate_addresses (info->abfd, ab, info->f, info->syms);\n       local = info->stack->flavor != NULL;\n       if (info->stack->method && *info->stack->method)\n@@ -2773,11 +2766,11 @@ tg_start_block (void *p, bfd_vma addr)\n \t  kind = 'f';\n \t  partof = NULL;\n \t  if (! info->stack->method && ! append_type (info, \")\"))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       t = pop_type (info);\n       if (t == NULL)\n-\treturn FALSE;\n+\treturn false;\n       fprintf (info->f, \";\\\"\\tkind:%c\\ttype:%s\", kind, t);\n       if (local)\n \tfputs (\"\\tfile:\", info->f);\n@@ -2789,25 +2782,25 @@ tg_start_block (void *p, bfd_vma addr)\n       fputc ('\\n', info->f);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Write out line number information.  */\n \n-static bfd_boolean\n+static bool\n tg_lineno (void *p ATTRIBUTE_UNUSED, const char *fname ATTRIBUTE_UNUSED,\n \t   unsigned long lineno ATTRIBUTE_UNUSED,\n \t   bfd_vma addr ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n /* Finish writing out a block.  */\n \n-static bfd_boolean\n+static bool\n tg_end_block (void *p ATTRIBUTE_UNUSED, bfd_vma addr ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n /* Convert the visibility value into a human readable name.  */\n@@ -2833,7 +2826,7 @@ visibility_name (enum debug_visibility visibility)\n       break;\n     default:\n       abort ();\n-      return FALSE;\n+      return false;\n     }\n   return s;\n }"
    },
    {
      "sha": "a00e39ffa87813e92220f97bb1110cc652bfdb67",
      "filename": "binutils/rdcoff.c",
      "status": "modified",
      "additions": 69,
      "deletions": 69,
      "changes": 138,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/rdcoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/rdcoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/rdcoff.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -86,7 +86,7 @@ struct coff_types\n static debug_type *coff_get_slot (struct coff_types *, long);\n static debug_type parse_coff_type\n   (bfd *, struct coff_symbols *, struct coff_types *, long, int,\n-   union internal_auxent *, bfd_boolean, void *);\n+   union internal_auxent *, bool, void *);\n static debug_type parse_coff_base_type\n   (bfd *, struct coff_symbols *, struct coff_types *, long, int,\n    union internal_auxent *, void *);\n@@ -96,10 +96,10 @@ static debug_type parse_coff_struct_type\n static debug_type parse_coff_enum_type\n   (bfd *, struct coff_symbols *, struct coff_types *,\n    union internal_auxent *, void *);\n-static bfd_boolean parse_coff_symbol\n+static bool parse_coff_symbol\n   (bfd *, struct coff_types *, asymbol *, long, struct internal_syment *,\n-   void *, debug_type, bfd_boolean);\n-static bfd_boolean external_coff_symbol_p (int sym_class);\n+   void *, debug_type, bool);\n+static bool external_coff_symbol_p (int sym_class);\n \f\n /* Return the slot for a type.  */\n \n@@ -140,7 +140,7 @@ coff_get_slot (struct coff_types *types, long indx)\n static debug_type\n parse_coff_type (bfd *abfd, struct coff_symbols *symbols,\n \t\t struct coff_types *types, long coff_symno, int ntype,\n-\t\t union internal_auxent *pauxent, bfd_boolean useaux,\n+\t\t union internal_auxent *pauxent, bool useaux,\n \t\t void *dhandle)\n {\n   debug_type type;\n@@ -162,7 +162,7 @@ parse_coff_type (bfd *abfd, struct coff_symbols *symbols,\n \t  type = parse_coff_type (abfd, symbols, types, coff_symno, newtype,\n \t\t\t\t  pauxent, useaux, dhandle);\n \t  type = debug_make_function_type (dhandle, type, (debug_type *) NULL,\n-\t\t\t\t\t   FALSE);\n+\t\t\t\t\t   false);\n \t}\n       else if (ISARY (ntype))\n \t{\n@@ -188,14 +188,14 @@ parse_coff_type (bfd *abfd, struct coff_symbols *symbols,\n \t    }\n \n \t  type = parse_coff_type (abfd, symbols, types, coff_symno, newtype,\n-\t\t\t\t  pauxent, FALSE, dhandle);\n+\t\t\t\t  pauxent, false, dhandle);\n \t  type = debug_make_array_type (dhandle, type,\n \t\t\t\t\tparse_coff_base_type (abfd, symbols,\n \t\t\t\t\t\t\t      types,\n \t\t\t\t\t\t\t      coff_symno,\n \t\t\t\t\t\t\t      T_INT,\n \t\t\t\t\t\t\t      NULL, dhandle),\n-\t\t\t\t\t0, n - 1, FALSE);\n+\t\t\t\t\t0, n - 1, false);\n \t}\n       else\n \t{\n@@ -240,7 +240,7 @@ parse_coff_base_type (bfd *abfd, struct coff_symbols *symbols,\n \t\t      union internal_auxent *pauxent, void *dhandle)\n {\n   debug_type ret;\n-  bfd_boolean set_basic;\n+  bool set_basic;\n   const char *name;\n   debug_type *slot;\n \n@@ -249,7 +249,7 @@ parse_coff_base_type (bfd *abfd, struct coff_symbols *symbols,\n       && types->basic[ntype] != DEBUG_TYPE_NULL)\n     return types->basic[ntype];\n \n-  set_basic = TRUE;\n+  set_basic = true;\n   name = NULL;\n \n   switch (ntype)\n@@ -265,23 +265,23 @@ parse_coff_base_type (bfd *abfd, struct coff_symbols *symbols,\n       break;\n \n     case T_CHAR:\n-      ret = debug_make_int_type (dhandle, 1, FALSE);\n+      ret = debug_make_int_type (dhandle, 1, false);\n       name = \"char\";\n       break;\n \n     case T_SHORT:\n-      ret = debug_make_int_type (dhandle, 2, FALSE);\n+      ret = debug_make_int_type (dhandle, 2, false);\n       name = \"short\";\n       break;\n \n     case T_INT:\n       /* FIXME: Perhaps the size should depend upon the architecture.  */\n-      ret = debug_make_int_type (dhandle, 4, FALSE);\n+      ret = debug_make_int_type (dhandle, 4, false);\n       name = \"int\";\n       break;\n \n     case T_LONG:\n-      ret = debug_make_int_type (dhandle, 4, FALSE);\n+      ret = debug_make_int_type (dhandle, 4, false);\n       name = \"long\";\n       break;\n \n@@ -301,28 +301,28 @@ parse_coff_base_type (bfd *abfd, struct coff_symbols *symbols,\n       break;\n \n     case T_UCHAR:\n-      ret = debug_make_int_type (dhandle, 1, TRUE);\n+      ret = debug_make_int_type (dhandle, 1, true);\n       name = \"unsigned char\";\n       break;\n \n     case T_USHORT:\n-      ret = debug_make_int_type (dhandle, 2, TRUE);\n+      ret = debug_make_int_type (dhandle, 2, true);\n       name = \"unsigned short\";\n       break;\n \n     case T_UINT:\n-      ret = debug_make_int_type (dhandle, 4, TRUE);\n+      ret = debug_make_int_type (dhandle, 4, true);\n       name = \"unsigned int\";\n       break;\n \n     case T_ULONG:\n-      ret = debug_make_int_type (dhandle, 4, TRUE);\n+      ret = debug_make_int_type (dhandle, 4, true);\n       name = \"unsigned long\";\n       break;\n \n     case T_STRUCT:\n       if (pauxent == NULL)\n-\tret = debug_make_struct_type (dhandle, TRUE, 0,\n+\tret = debug_make_struct_type (dhandle, true, 0,\n \t\t\t\t      (debug_field *) NULL);\n       else\n \tret = parse_coff_struct_type (abfd, symbols, types, ntype, pauxent,\n@@ -331,20 +331,20 @@ parse_coff_base_type (bfd *abfd, struct coff_symbols *symbols,\n       slot = coff_get_slot (types, coff_symno);\n       *slot = ret;\n \n-      set_basic = FALSE;\n+      set_basic = false;\n       break;\n \n     case T_UNION:\n       if (pauxent == NULL)\n-\tret = debug_make_struct_type (dhandle, FALSE, 0, (debug_field *) NULL);\n+\tret = debug_make_struct_type (dhandle, false, 0, (debug_field *) NULL);\n       else\n \tret = parse_coff_struct_type (abfd, symbols, types, ntype, pauxent,\n \t\t\t\t      dhandle);\n \n       slot = coff_get_slot (types, coff_symno);\n       *slot = ret;\n \n-      set_basic = FALSE;\n+      set_basic = false;\n       break;\n \n     case T_ENUM:\n@@ -357,7 +357,7 @@ parse_coff_base_type (bfd *abfd, struct coff_symbols *symbols,\n       slot = coff_get_slot (types, coff_symno);\n       *slot = ret;\n \n-      set_basic = FALSE;\n+      set_basic = false;\n       break;\n     }\n \n@@ -383,15 +383,15 @@ parse_coff_struct_type (bfd *abfd, struct coff_symbols *symbols,\n   int alloc;\n   debug_field *fields;\n   int count;\n-  bfd_boolean done;\n+  bool done;\n \n   symend = pauxent->x_sym.x_fcnary.x_fcn.x_endndx.l;\n \n   alloc = 10;\n   fields = (debug_field *) xmalloc (alloc * sizeof *fields);\n   count = 0;\n \n-  done = FALSE;\n+  done = false;\n   while (! done\n \t && symbols->coff_symno < symend\n \t && symbols->symno < symbols->symcount)\n@@ -446,7 +446,7 @@ parse_coff_struct_type (bfd *abfd, struct coff_symbols *symbols,\n \t  break;\n \n \tcase C_EOS:\n-\t  done = TRUE;\n+\t  done = true;\n \t  break;\n \t}\n \n@@ -456,7 +456,7 @@ parse_coff_struct_type (bfd *abfd, struct coff_symbols *symbols,\n \t  debug_field f;\n \n \t  ftype = parse_coff_type (abfd, symbols, types, this_coff_symno,\n-\t\t\t\t   syment.n_type, psubaux, TRUE, dhandle);\n+\t\t\t\t   syment.n_type, psubaux, true, dhandle);\n \t  f = debug_make_field (dhandle, bfd_asymbol_name (sym), ftype,\n \t\t\t\tbitpos, bitsize, DEBUG_VISIBILITY_PUBLIC);\n \t  if (f == DEBUG_FIELD_NULL)\n@@ -493,7 +493,7 @@ parse_coff_enum_type (bfd *abfd, struct coff_symbols *symbols,\n   const char **names;\n   bfd_signed_vma *vals;\n   int count;\n-  bfd_boolean done;\n+  bool done;\n \n   symend = pauxent->x_sym.x_fcnary.x_fcn.x_endndx.l;\n \n@@ -502,7 +502,7 @@ parse_coff_enum_type (bfd *abfd, struct coff_symbols *symbols,\n   vals = (bfd_signed_vma *) xmalloc (alloc * sizeof *vals);\n   count = 0;\n \n-  done = FALSE;\n+  done = false;\n   while (! done\n \t && symbols->coff_symno < symend\n \t && symbols->symno < symbols->symcount)\n@@ -542,7 +542,7 @@ parse_coff_enum_type (bfd *abfd, struct coff_symbols *symbols,\n \t  break;\n \n \tcase C_EOS:\n-\t  done = TRUE;\n+\t  done = true;\n \t  break;\n \t}\n     }\n@@ -554,11 +554,11 @@ parse_coff_enum_type (bfd *abfd, struct coff_symbols *symbols,\n \n /* Handle a single COFF symbol.  */\n \n-static bfd_boolean\n+static bool\n parse_coff_symbol (bfd *abfd ATTRIBUTE_UNUSED, struct coff_types *types,\n \t\t   asymbol *sym, long coff_symno,\n \t\t   struct internal_syment *psyment, void *dhandle,\n-\t\t   debug_type type, bfd_boolean within_function)\n+\t\t   debug_type type, bool within_function)\n {\n   switch (psyment->n_sclass)\n     {\n@@ -568,14 +568,14 @@ parse_coff_symbol (bfd *abfd ATTRIBUTE_UNUSED, struct coff_types *types,\n     case C_AUTO:\n       if (! debug_record_variable (dhandle, bfd_asymbol_name (sym), type,\n \t\t\t\t   DEBUG_LOCAL, bfd_asymbol_value (sym)))\n-\treturn FALSE;\n+\treturn false;\n       break;\n \n     case C_WEAKEXT:\n     case C_EXT:\n       if (! debug_record_variable (dhandle, bfd_asymbol_name (sym), type,\n \t\t\t\t   DEBUG_GLOBAL, bfd_asymbol_value (sym)))\n-\treturn FALSE;\n+\treturn false;\n       break;\n \n     case C_STAT:\n@@ -584,14 +584,14 @@ parse_coff_symbol (bfd *abfd ATTRIBUTE_UNUSED, struct coff_types *types,\n \t\t\t\t    ? DEBUG_LOCAL_STATIC\n \t\t\t\t    : DEBUG_STATIC),\n \t\t\t\t   bfd_asymbol_value (sym)))\n-\treturn FALSE;\n+\treturn false;\n       break;\n \n     case C_REG:\n       /* FIXME: We may need to convert the register number.  */\n       if (! debug_record_variable (dhandle, bfd_asymbol_name (sym), type,\n \t\t\t\t   DEBUG_REGISTER, bfd_asymbol_value (sym)))\n-\treturn FALSE;\n+\treturn false;\n       break;\n \n     case C_LABEL:\n@@ -600,20 +600,20 @@ parse_coff_symbol (bfd *abfd ATTRIBUTE_UNUSED, struct coff_types *types,\n     case C_ARG:\n       if (! debug_record_parameter (dhandle, bfd_asymbol_name (sym), type,\n \t\t\t\t    DEBUG_PARM_STACK, bfd_asymbol_value (sym)))\n-\treturn FALSE;\n+\treturn false;\n       break;\n \n     case C_REGPARM:\n       /* FIXME: We may need to convert the register number.  */\n       if (! debug_record_parameter (dhandle, bfd_asymbol_name (sym), type,\n \t\t\t\t    DEBUG_PARM_REG, bfd_asymbol_value (sym)))\n-\treturn FALSE;\n+\treturn false;\n       break;\n \n     case C_TPDEF:\n       type = debug_name_type (dhandle, bfd_asymbol_name (sym), type);\n       if (type == DEBUG_TYPE_NULL)\n-\treturn FALSE;\n+\treturn false;\n       break;\n \n     case C_STRTAG:\n@@ -624,7 +624,7 @@ parse_coff_symbol (bfd *abfd ATTRIBUTE_UNUSED, struct coff_types *types,\n \n \ttype = debug_tag_type (dhandle, bfd_asymbol_name (sym), type);\n \tif (type == DEBUG_TYPE_NULL)\n-\t  return FALSE;\n+\t  return false;\n \n \t/* Store the named type into the slot, so that references get\n            the name.  */\n@@ -637,29 +637,29 @@ parse_coff_symbol (bfd *abfd ATTRIBUTE_UNUSED, struct coff_types *types,\n       break;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Determine if a symbol has external visibility.  */\n \n-static bfd_boolean\n+static bool\n external_coff_symbol_p (int sym_class)\n {\n   switch (sym_class)\n     {\n     case C_EXT:\n     case C_WEAKEXT:\n-      return TRUE;\n+      return true;\n     default:\n       break;\n     }\n-  return FALSE;\n+  return false;\n }\n \n /* This is the main routine.  It looks through all the symbols and\n    handles them.  */\n \n-bfd_boolean\n+bool\n parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n {\n   struct coff_symbols symbols;\n@@ -671,7 +671,7 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n   int fntype;\n   bfd_vma fnend;\n   alent *linenos;\n-  bfd_boolean within_function;\n+  bool within_function;\n   long this_coff_symno;\n \n   symbols.syms = syms;\n@@ -689,7 +689,7 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n   fntype = 0;\n   fnend = 0;\n   linenos = NULL;\n-  within_function = FALSE;\n+  within_function = false;\n \n   while (symbols.symno < symcount)\n     {\n@@ -706,7 +706,7 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \t{\n \t  non_fatal (_(\"bfd_coff_get_syment failed: %s\"),\n \t\t     bfd_errmsg (bfd_get_error ()));\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       name = bfd_asymbol_name (sym);\n@@ -726,7 +726,7 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \t    {\n \t      non_fatal (_(\"bfd_coff_get_auxent failed: %s\"),\n \t\t\t bfd_errmsg (bfd_get_error ()));\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  paux = &auxent;\n \t}\n@@ -736,7 +736,7 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \t  /* The last C_FILE symbol points to the first external\n              symbol.  */\n \t  if (! debug_set_filename (dhandle, \"*globals*\"))\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n       switch (syment.n_sclass)\n@@ -754,7 +754,7 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \tcase C_FILE:\n \t  next_c_file = syment.n_value;\n \t  if (! debug_set_filename (dhandle, name))\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \n \tcase C_STAT:\n@@ -778,12 +778,12 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \t      break;\n \t    }\n \t  type = parse_coff_type (abfd, &symbols, &types, this_coff_symno,\n-\t\t\t\t  syment.n_type, paux, TRUE, dhandle);\n+\t\t\t\t  syment.n_type, paux, true, dhandle);\n \t  if (type == DEBUG_TYPE_NULL)\n-\t    return FALSE;\n+\t    return false;\n \t  if (! parse_coff_symbol (abfd, &types, sym, this_coff_symno, &syment,\n \t\t\t\t   dhandle, type, within_function))\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \n \tcase C_FCN:\n@@ -793,18 +793,18 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \t\t{\n \t\t  non_fatal (_(\"%ld: .bf without preceding function\"),\n \t\t\t     this_coff_symno);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \n \t      type = parse_coff_type (abfd, &symbols, &types, this_coff_symno,\n-\t\t\t\t      DECREF (fntype), paux, FALSE, dhandle);\n+\t\t\t\t      DECREF (fntype), paux, false, dhandle);\n \t      if (type == DEBUG_TYPE_NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \n \t      if (! debug_record_function (dhandle, fnname, type,\n \t\t\t\t\t   external_coff_symbol_p (fnclass),\n \t\t\t\t\t   bfd_asymbol_value (sym)))\n-\t\treturn FALSE;\n+\t\treturn false;\n \n \t      if (linenos != NULL)\n \t\t{\n@@ -825,7 +825,7 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \t\t      if (! debug_record_line (dhandle,\n \t\t\t\t\t       linenos->line_number + base,\n \t\t\t\t\t       linenos->u.offset + addr))\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t      ++linenos;\n \t\t    }\n \t\t}\n@@ -835,50 +835,50 @@ parse_coff (bfd *abfd, asymbol **syms, long symcount, void *dhandle)\n \t      fnclass = 0;\n \t      fntype = 0;\n \n-\t      within_function = TRUE;\n+\t      within_function = true;\n \t    }\n \t  else if (strcmp (name, \".ef\") == 0)\n \t    {\n \t      if (! within_function)\n \t\t{\n \t\t  non_fatal (_(\"%ld: unexpected .ef\\n\"), this_coff_symno);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \n \t      if (bfd_asymbol_value (sym) > fnend)\n \t\tfnend = bfd_asymbol_value (sym);\n \t      if (! debug_end_function (dhandle, fnend))\n-\t\treturn FALSE;\n+\t\treturn false;\n \n \t      fnend = 0;\n-\t      within_function = FALSE;\n+\t      within_function = false;\n \t    }\n \t  break;\n \n \tcase C_BLOCK:\n \t  if (strcmp (name, \".bb\") == 0)\n \t    {\n \t      if (! debug_start_block (dhandle, bfd_asymbol_value (sym)))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t  else if (strcmp (name, \".eb\") == 0)\n \t    {\n \t      if (! debug_end_block (dhandle, bfd_asymbol_value (sym)))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t  break;\n \n \tdefault:\n \t  type = parse_coff_type (abfd, &symbols, &types, this_coff_symno,\n-\t\t\t\t  syment.n_type, paux, TRUE, dhandle);\n+\t\t\t\t  syment.n_type, paux, true, dhandle);\n \t  if (type == DEBUG_TYPE_NULL)\n-\t    return FALSE;\n+\t    return false;\n \t  if (! parse_coff_symbol (abfd, &types, sym, this_coff_symno, &syment,\n \t\t\t\t   dhandle, type, within_function))\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "a2e41a9545391d353ec4b4cc63dfa722fa17c1af",
      "filename": "binutils/rddbg.c",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/rddbg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/rddbg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/rddbg.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -31,10 +31,10 @@\n #include \"debug.h\"\n #include \"budbg.h\"\n \n-static bfd_boolean read_section_stabs_debugging_info\n-  (bfd *, asymbol **, long, void *, bfd_boolean *);\n-static bfd_boolean read_symbol_stabs_debugging_info\n-  (bfd *, asymbol **, long, void *, bfd_boolean *);\n+static bool read_section_stabs_debugging_info\n+  (bfd *, asymbol **, long, void *, bool *);\n+static bool read_symbol_stabs_debugging_info\n+  (bfd *, asymbol **, long, void *, bool *);\n static void save_stab (int, int, bfd_vma, const char *);\n static void stab_context (void);\n static void free_saved_stabs (void);\n@@ -44,10 +44,10 @@ static void free_saved_stabs (void);\n \n void *\n read_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n-\t\t     bfd_boolean no_messages)\n+\t\t     bool no_messages)\n {\n   void *dhandle;\n-  bfd_boolean found;\n+  bool found;\n \n   dhandle = debug_init ();\n   if (dhandle == NULL)\n@@ -72,7 +72,7 @@ read_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n     {\n       if (! parse_coff (abfd, syms, symcount, dhandle))\n \tgoto err_exit;\n-      found = TRUE;\n+      found = true;\n     }\n \n   if (! found)\n@@ -90,9 +90,9 @@ read_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n \n /* Read stabs in sections debugging information from a BFD.  */\n \n-static bfd_boolean\n+static bool\n read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n-\t\t\t\t   void *dhandle, bfd_boolean *pfound)\n+\t\t\t\t   void *dhandle, bool *pfound)\n {\n   static struct\n     {\n@@ -108,7 +108,7 @@ read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n   unsigned int i;\n   void *shandle;\n \n-  *pfound = FALSE;\n+  *pfound = false;\n   shandle = NULL;\n \n   for (i = 0; i < sizeof names / sizeof names[0]; i++)\n@@ -133,7 +133,7 @@ read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n \t\t       bfd_errmsg (bfd_get_error ()));\n \t      free (shandle);\n \t      free (stabs);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  strsize = bfd_section_size (strsec);\n@@ -146,22 +146,22 @@ read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n \t      free (shandle);\n \t      free (strings);\n \t      free (stabs);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  /* Zero terminate the strings table, just in case.  */\n \t  strings [strsize] = 0;\n \t  if (shandle == NULL)\n \t    {\n-\t      shandle = start_stab (dhandle, abfd, TRUE, syms, symcount);\n+\t      shandle = start_stab (dhandle, abfd, true, syms, symcount);\n \t      if (shandle == NULL)\n \t\t{\n \t\t  free (strings);\n \t\t  free (stabs);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t    }\n \n-\t  *pfound = TRUE;\n+\t  *pfound = true;\n \n \t  stroff = 0;\n \t  next_stroff = 0;\n@@ -248,7 +248,7 @@ read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n \t\t      free (shandle);\n \t\t      free (stabs);\n \t\t      free (strings);\n-\t\t      return FALSE;\n+\t\t      return false;\n \t\t    }\n \n \t\t  /* Don't free f, since I think the stabs code\n@@ -269,17 +269,17 @@ read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n   if (shandle != NULL)\n     {\n       if (! finish_stab (dhandle, shandle))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Read stabs in the symbol table.  */\n \n-static bfd_boolean\n+static bool\n read_symbol_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n-\t\t\t\t  void *dhandle, bfd_boolean *pfound)\n+\t\t\t\t  void *dhandle, bool *pfound)\n {\n   void *shandle;\n   asymbol **ps, **symend;\n@@ -299,16 +299,16 @@ read_symbol_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n \n \t  if (shandle == NULL)\n \t    {\n-\t      shandle = start_stab (dhandle, abfd, FALSE, syms, symcount);\n+\t      shandle = start_stab (dhandle, abfd, false, syms, symcount);\n \t      if (shandle == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \n-\t  *pfound = TRUE;\n+\t  *pfound = true;\n \n \t  s = i.name;\n \t  if (s == NULL || strlen (s) < 1)\n-\t    return FALSE;\n+\t    return false;\n \t  f = NULL;\n \n \t  while (strlen (s) > 0\n@@ -334,7 +334,7 @@ read_symbol_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n \t    {\n \t      stab_context ();\n \t      free_saved_stabs ();\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  /* Don't free f, since I think the stabs code expects\n@@ -348,10 +348,10 @@ read_symbol_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,\n   if (shandle != NULL)\n     {\n       if (! finish_stab (dhandle, shandle))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* Record stabs strings, so that we can give some context for errors.  */"
    },
    {
      "sha": "8ffca057a8af06c72f176654e8d4022437acdfc1",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 738,
      "deletions": 739,
      "changes": 1477,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3"
    },
    {
      "sha": "9746ef394e16a5d6910754c7929a0811723ddf96",
      "filename": "binutils/rename.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/rename.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/rename.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/rename.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -127,7 +127,7 @@ set_times (const char *destination, const struct stat *statbuf)\n \n int\n smart_rename (const char *from, const char *to, int fromfd,\n-\t      struct stat *target_stat, bfd_boolean preserve_dates)\n+\t      struct stat *target_stat, bool preserve_dates)\n {\n   int ret;\n "
    },
    {
      "sha": "274bfb0e7fa23319859c7e5a795cd3d5b8aed49f",
      "filename": "binutils/stabs.c",
      "status": "modified",
      "additions": 506,
      "deletions": 506,
      "changes": 1012,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/stabs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/stabs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/stabs.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3"
    },
    {
      "sha": "3ecdb929953d6c6a3f999b17f62a9e76d6958e64",
      "filename": "binutils/strings.c",
      "status": "modified",
      "additions": 35,
      "deletions": 35,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/strings.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/strings.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/strings.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -97,16 +97,16 @@ static int address_radix;\n static int string_min;\n \n /* Whether or not we include all whitespace as a graphic char.   */\n-static bfd_boolean include_all_whitespace;\n+static bool include_all_whitespace;\n \n /* TRUE means print address within file for each string.  */\n-static bfd_boolean print_addresses;\n+static bool print_addresses;\n \n /* TRUE means print filename for each string.  */\n-static bfd_boolean print_filenames;\n+static bool print_filenames;\n \n /* TRUE means for object files scan only the data section.  */\n-static bfd_boolean datasection_only;\n+static bool datasection_only;\n \n /* The BFD object file format.  */\n static char *target;\n@@ -134,7 +134,7 @@ static struct option long_options[] =\n   {NULL, 0, NULL, 0}\n };\n \n-static bfd_boolean strings_file (char *);\n+static bool strings_file (char *);\n static void print_strings (const char *, FILE *, file_ptr, int, int, char *);\n static void usage (FILE *, int) ATTRIBUTE_NORETURN;\n \f\n@@ -145,7 +145,7 @@ main (int argc, char **argv)\n {\n   int optc;\n   int exit_status = 0;\n-  bfd_boolean files_given = FALSE;\n+  bool files_given = false;\n   char *s;\n   int numeric_opt = 0;\n \n@@ -162,13 +162,13 @@ main (int argc, char **argv)\n   expandargv (&argc, &argv);\n \n   string_min = 4;\n-  include_all_whitespace = FALSE;\n-  print_addresses = FALSE;\n-  print_filenames = FALSE;\n+  include_all_whitespace = false;\n+  print_addresses = false;\n+  print_filenames = false;\n   if (DEFAULT_STRINGS_ALL)\n-    datasection_only = FALSE;\n+    datasection_only = false;\n   else\n-    datasection_only = TRUE;\n+    datasection_only = true;\n   target = NULL;\n   encoding = 's';\n   output_separator = NULL;\n@@ -179,15 +179,15 @@ main (int argc, char **argv)\n       switch (optc)\n \t{\n \tcase 'a':\n-\t  datasection_only = FALSE;\n+\t  datasection_only = false;\n \t  break;\n \n \tcase 'd':\n-\t  datasection_only = TRUE;\n+\t  datasection_only = true;\n \t  break;\n \n \tcase 'f':\n-\t  print_filenames = TRUE;\n+\t  print_filenames = true;\n \t  break;\n \n \tcase 'H':\n@@ -201,16 +201,16 @@ main (int argc, char **argv)\n \t  break;\n \n \tcase 'w':\n-\t  include_all_whitespace = TRUE;\n+\t  include_all_whitespace = true;\n \t  break;\n \n \tcase 'o':\n-\t  print_addresses = TRUE;\n+\t  print_addresses = true;\n \t  address_radix = 8;\n \t  break;\n \n \tcase 't':\n-\t  print_addresses = TRUE;\n+\t  print_addresses = true;\n \t  if (optarg[1] != '\\0')\n \t    usage (stderr, 1);\n \t  switch (optarg[0])\n@@ -293,20 +293,20 @@ main (int argc, char **argv)\n \n   if (optind >= argc)\n     {\n-      datasection_only = FALSE;\n+      datasection_only = false;\n       SET_BINARY (fileno (stdin));\n       print_strings (\"{standard input}\", stdin, 0, 0, 0, (char *) NULL);\n-      files_given = TRUE;\n+      files_given = true;\n     }\n   else\n     {\n       for (; optind < argc; ++optind)\n \t{\n \t  if (strcmp (argv[optind], \"-\") == 0)\n-\t    datasection_only = FALSE;\n+\t    datasection_only = false;\n \t  else\n \t    {\n-\t      files_given = TRUE;\n+\t      files_given = true;\n \t      exit_status |= !strings_file (argv[optind]);\n \t    }\n \t}\n@@ -324,7 +324,7 @@ main (int argc, char **argv)\n \n static void\n strings_a_section (bfd *abfd, asection *sect, const char *filename,\n-\t\t   bfd_boolean *got_a_section)\n+\t\t   bool *got_a_section)\n {\n   bfd_size_type sectsize;\n   bfd_byte *mem;\n@@ -343,7 +343,7 @@ strings_a_section (bfd *abfd, asection *sect, const char *filename,\n       return;\n     }\n \n-  *got_a_section = TRUE;\n+  *got_a_section = true;\n   print_strings (filename, NULL, sect->filepos, 0, sectsize, (char *) mem);\n   free (mem);\n }\n@@ -354,44 +354,44 @@ strings_a_section (bfd *abfd, asection *sect, const char *filename,\n    Return TRUE if successful,\n    FALSE if not (such as if FILE is not an object file).  */\n \n-static bfd_boolean\n+static bool\n strings_object_file (const char *file)\n {\n   bfd *abfd;\n   asection *s;\n-  bfd_boolean got_a_section;\n+  bool got_a_section;\n \n   abfd = bfd_openr (file, target);\n \n   if (abfd == NULL)\n     /* Treat the file as a non-object file.  */\n-    return FALSE;\n+    return false;\n \n   /* This call is mainly for its side effect of reading in the sections.\n      We follow the traditional behavior of `strings' in that we don't\n      complain if we don't recognize a file to be an object file.  */\n   if (!bfd_check_format (abfd, bfd_object))\n     {\n       bfd_close (abfd);\n-      return FALSE;\n+      return false;\n     }\n \n-  got_a_section = FALSE;\n+  got_a_section = false;\n   for (s = abfd->sections; s != NULL; s = s->next)\n     strings_a_section (abfd, s, file, &got_a_section);\n \n   if (!bfd_close (abfd))\n     {\n       bfd_nonfatal (file);\n-      return FALSE;\n+      return false;\n     }\n \n   return got_a_section;\n }\n \n /* Print the strings in FILE.  Return TRUE if ok, FALSE if an error occurs.  */\n \n-static bfd_boolean\n+static bool\n strings_file (char *file)\n {\n   struct stat st;\n@@ -405,12 +405,12 @@ strings_file (char *file)\n       else\n \tnon_fatal (_(\"Warning: could not locate '%s'.  reason: %s\"),\n \t\t   file, strerror (errno));\n-      return FALSE;\n+      return false;\n     }\n   else if (S_ISDIR (st.st_mode))\n     {\n       non_fatal (_(\"Warning: '%s' is a directory\"), file);\n-      return FALSE;\n+      return false;\n     }\n \n   /* If we weren't told to scan the whole file,\n@@ -426,7 +426,7 @@ strings_file (char *file)\n \t{\n \t  fprintf (stderr, \"%s: \", program_name);\n \t  perror (file);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       print_strings (file, stream, (file_ptr) 0, 0, 0, (char *) 0);\n@@ -435,11 +435,11 @@ strings_file (char *file)\n \t{\n \t  fprintf (stderr, \"%s: \", program_name);\n \t  perror (file);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* Read the next character, return EOF if none available."
    },
    {
      "sha": "981ec025fc7468ca2c4d96a5f903789d61c2a21c",
      "filename": "binutils/sysdep.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/sysdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/sysdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/sysdep.h?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -201,4 +201,6 @@ size_t strnlen (const char *, size_t);\n #define HOST_WIDEST_INT long\n #endif\n \n+#define POISON_BFD_BOOLEAN 1\n+\n #endif /* _BIN_SYSDEP_H */"
    },
    {
      "sha": "3a335c6ea9f5ddf99ca083f4de9adb693069c2ff",
      "filename": "binutils/windint.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/windint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/windint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/windint.h?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -1063,7 +1063,7 @@ struct __attribute__ ((__packed__)) bin_toolbar\n };\n #define BIN_TOOLBAR_SIZE 12\n \n-extern bfd_boolean target_is_bigendian;\n+extern bool target_is_bigendian;\n \n typedef struct windres_bfd\n {"
    },
    {
      "sha": "af32f3bf22ca0cbf251d9ecd1d5c8908682bb350",
      "filename": "binutils/windmc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/windmc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/windmc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/windmc.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -50,7 +50,7 @@ typedef struct mc_msg_item\n   struct bin_messagetable_item *res;\n } mc_msg_item;\n \n-bfd_boolean target_is_bigendian = 0;\n+bool target_is_bigendian = 0;\n const char *def_target_arch;\n \n /* Globals and static variable definitions. */"
    },
    {
      "sha": "edea8735801e0e29bef26d0611491790418a9eef",
      "filename": "binutils/windmc.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/windmc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/windmc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/windmc.h?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -89,9 +89,9 @@ void mc_set_inputfile (const char *);\n void mc_set_content (const unichar *);\n \n /* Lexer control variables. Used by mcparser.y file.  */\n-extern bfd_boolean mclex_want_nl;\n-extern bfd_boolean mclex_want_line;\n-extern bfd_boolean mclex_want_filename;\n+extern bool mclex_want_nl;\n+extern bool mclex_want_line;\n+extern bool mclex_want_filename;\n \n void mc_fatal (const char *, ...);\n void mc_warn (const char *, ...);"
    },
    {
      "sha": "0fbf1f9fa5e6310f3820716c5e1647d56ec9aeb8",
      "filename": "binutils/windres.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/windres.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/windres.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/windres.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -48,7 +48,7 @@\n \n int verbose = 0;\n \n-bfd_boolean target_is_bigendian = 0;\n+bool target_is_bigendian = 0;\n const char *def_target_arch;\n \n static void set_endianness (bfd *, const char *);\n@@ -713,12 +713,12 @@ quot (const char *string)\n #if defined (_WIN32) && !defined (__CYGWIN__)\n   /* For Windows shells, quote \"like this\".   */\n   {\n-    bfd_boolean quoted = FALSE;\n+    bool quoted = false;\n \n     dest = buf;\n     if (strchr (string, ' '))\n       {\n-\tquoted = TRUE;\n+\tquoted = true;\n \t*dest++ = '\"';\n       }\n "
    },
    {
      "sha": "7d44c291ae4af8c9d02e9bdea6e428f67883ce0a",
      "filename": "binutils/winduni.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/winduni.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/winduni.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/winduni.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -832,7 +832,7 @@ wind_WideCharToMultiByte (rc_uint_type cp, const unichar *u, char *mb, rc_uint_t\n {\n   rc_uint_type ret = 0;\n #if defined (_WIN32) || defined (__CYGWIN__)\n-  WINBOOL used_def = FALSE;\n+  WINBOOL used_def = false;\n \n   ret = (rc_uint_type) WideCharToMultiByte (cp, 0, u, -1, mb, mb_len,\n \t\t\t\t      \t    NULL, & used_def);"
    },
    {
      "sha": "d5347f50894b8d1d69cbc7d79d6a30d27133106b",
      "filename": "binutils/wrstabs.c",
      "status": "modified",
      "additions": 257,
      "deletions": 257,
      "changes": 514,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/wrstabs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/015dc7e1f8a971692a910e6cfc64faf9216e75c3/binutils/wrstabs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/wrstabs.c?ref=015dc7e1f8a971692a910e6cfc64faf9216e75c3",
      "patch": "@@ -71,7 +71,7 @@ struct stab_type_stack\n   /* The size of the type.  */\n   unsigned int size;\n   /* Whether type string defines a new type.  */\n-  bfd_boolean definition;\n+  bool definition;\n   /* String defining struct fields.  */\n   char *fields;\n   /* NULL terminated array of strings defining base classes for a\n@@ -173,79 +173,79 @@ struct stab_write_handle\n \n static struct bfd_hash_entry *string_hash_newfunc\n   (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);\n-static bfd_boolean stab_write_symbol\n+static bool stab_write_symbol\n   (struct stab_write_handle *, int, int, bfd_vma, const char *);\n-static bfd_boolean stab_push_string\n-  (struct stab_write_handle *, const char *, long, bfd_boolean, unsigned int);\n-static bfd_boolean stab_push_defined_type\n+static bool stab_push_string\n+  (struct stab_write_handle *, const char *, long, bool, unsigned int);\n+static bool stab_push_defined_type\n   (struct stab_write_handle *, long, unsigned int);\n static char *stab_pop_type (struct stab_write_handle *);\n-static bfd_boolean stab_modify_type\n+static bool stab_modify_type\n   (struct stab_write_handle *, int, unsigned int, long **, size_t *);\n static long stab_get_struct_index\n   (struct stab_write_handle *, const char *, unsigned int,\n    enum debug_type_kind, unsigned int *);\n-static bfd_boolean stab_class_method_var\n+static bool stab_class_method_var\n   (struct stab_write_handle *, const char *, enum debug_visibility,\n-   bfd_boolean, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);\n-static bfd_boolean stab_start_compilation_unit (void *, const char *);\n-static bfd_boolean stab_start_source (void *, const char *);\n-static bfd_boolean stab_empty_type (void *);\n-static bfd_boolean stab_void_type (void *);\n-static bfd_boolean stab_int_type (void *, unsigned int, bfd_boolean);\n-static bfd_boolean stab_float_type (void *, unsigned int);\n-static bfd_boolean stab_complex_type (void *, unsigned int);\n-static bfd_boolean stab_bool_type (void *, unsigned int);\n-static bfd_boolean stab_enum_type\n+   bool, bool, bool, bfd_vma, bool);\n+static bool stab_start_compilation_unit (void *, const char *);\n+static bool stab_start_source (void *, const char *);\n+static bool stab_empty_type (void *);\n+static bool stab_void_type (void *);\n+static bool stab_int_type (void *, unsigned int, bool);\n+static bool stab_float_type (void *, unsigned int);\n+static bool stab_complex_type (void *, unsigned int);\n+static bool stab_bool_type (void *, unsigned int);\n+static bool stab_enum_type\n   (void *, const char *, const char **, bfd_signed_vma *);\n-static bfd_boolean stab_pointer_type (void *);\n-static bfd_boolean stab_function_type (void *, int, bfd_boolean);\n-static bfd_boolean stab_reference_type (void *);\n-static bfd_boolean stab_range_type (void *, bfd_signed_vma, bfd_signed_vma);\n-static bfd_boolean stab_array_type\n-  (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);\n-static bfd_boolean stab_set_type (void *, bfd_boolean);\n-static bfd_boolean stab_offset_type (void *);\n-static bfd_boolean stab_method_type (void *, bfd_boolean, int, bfd_boolean);\n-static bfd_boolean stab_const_type (void *);\n-static bfd_boolean stab_volatile_type (void *);\n-static bfd_boolean stab_start_struct_type\n-  (void *, const char *, unsigned int, bfd_boolean, unsigned int);\n-static bfd_boolean stab_struct_field\n+static bool stab_pointer_type (void *);\n+static bool stab_function_type (void *, int, bool);\n+static bool stab_reference_type (void *);\n+static bool stab_range_type (void *, bfd_signed_vma, bfd_signed_vma);\n+static bool stab_array_type\n+  (void *, bfd_signed_vma, bfd_signed_vma, bool);\n+static bool stab_set_type (void *, bool);\n+static bool stab_offset_type (void *);\n+static bool stab_method_type (void *, bool, int, bool);\n+static bool stab_const_type (void *);\n+static bool stab_volatile_type (void *);\n+static bool stab_start_struct_type\n+  (void *, const char *, unsigned int, bool, unsigned int);\n+static bool stab_struct_field\n   (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);\n-static bfd_boolean stab_end_struct_type (void *);\n-static bfd_boolean stab_start_class_type\n-  (void *, const char *, unsigned int, bfd_boolean, unsigned int,\n-   bfd_boolean, bfd_boolean);\n-static bfd_boolean stab_class_static_member\n+static bool stab_end_struct_type (void *);\n+static bool stab_start_class_type\n+  (void *, const char *, unsigned int, bool, unsigned int,\n+   bool, bool);\n+static bool stab_class_static_member\n   (void *, const char *, const char *, enum debug_visibility);\n-static bfd_boolean stab_class_baseclass\n-  (void *, bfd_vma, bfd_boolean, enum debug_visibility);\n-static bfd_boolean stab_class_start_method (void *, const char *);\n-static bfd_boolean stab_class_method_variant\n-  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,\n-   bfd_vma, bfd_boolean);\n-static bfd_boolean stab_class_static_method_variant\n-  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);\n-static bfd_boolean stab_class_end_method (void *);\n-static bfd_boolean stab_end_class_type (void *);\n-static bfd_boolean stab_typedef_type (void *, const char *);\n-static bfd_boolean stab_tag_type\n+static bool stab_class_baseclass\n+  (void *, bfd_vma, bool, enum debug_visibility);\n+static bool stab_class_start_method (void *, const char *);\n+static bool stab_class_method_variant\n+  (void *, const char *, enum debug_visibility, bool, bool,\n+   bfd_vma, bool);\n+static bool stab_class_static_method_variant\n+  (void *, const char *, enum debug_visibility, bool, bool);\n+static bool stab_class_end_method (void *);\n+static bool stab_end_class_type (void *);\n+static bool stab_typedef_type (void *, const char *);\n+static bool stab_tag_type\n   (void *, const char *, unsigned int, enum debug_type_kind);\n-static bfd_boolean stab_typdef (void *, const char *);\n-static bfd_boolean stab_tag (void *, const char *);\n-static bfd_boolean stab_int_constant (void *, const char *, bfd_vma);\n-static bfd_boolean stab_float_constant (void *, const char *, double);\n-static bfd_boolean stab_typed_constant (void *, const char *, bfd_vma);\n-static bfd_boolean stab_variable\n+static bool stab_typdef (void *, const char *);\n+static bool stab_tag (void *, const char *);\n+static bool stab_int_constant (void *, const char *, bfd_vma);\n+static bool stab_float_constant (void *, const char *, double);\n+static bool stab_typed_constant (void *, const char *, bfd_vma);\n+static bool stab_variable\n   (void *, const char *, enum debug_var_kind, bfd_vma);\n-static bfd_boolean stab_start_function (void *, const char *, bfd_boolean);\n-static bfd_boolean stab_function_parameter\n+static bool stab_start_function (void *, const char *, bool);\n+static bool stab_function_parameter\n   (void *, const char *, enum debug_parm_kind, bfd_vma);\n-static bfd_boolean stab_start_block (void *, bfd_vma);\n-static bfd_boolean stab_end_block (void *, bfd_vma);\n-static bfd_boolean stab_end_function (void *);\n-static bfd_boolean stab_lineno (void *, const char *, unsigned long, bfd_vma);\n+static bool stab_start_block (void *, bfd_vma);\n+static bool stab_end_block (void *, bfd_vma);\n+static bool stab_end_function (void *);\n+static bool stab_lineno (void *, const char *, unsigned long, bfd_vma);\n \n static const struct debug_write_fns stab_fns =\n {\n@@ -334,7 +334,7 @@ string_hash_newfunc (struct bfd_hash_entry *entry,\n \n /* Add a symbol to the stabs debugging information we are building.  */\n \n-static bfd_boolean\n+static bool\n stab_write_symbol (struct stab_write_handle *info, int type, int desc,\n \t\t   bfd_vma value, const char *string)\n {\n@@ -347,12 +347,12 @@ stab_write_symbol (struct stab_write_handle *info, int type, int desc,\n     {\n       struct string_hash_entry *h;\n \n-      h = string_hash_lookup (&info->strhash, string, TRUE, TRUE);\n+      h = string_hash_lookup (&info->strhash, string, true, true);\n       if (h == NULL)\n \t{\n \t  non_fatal (_(\"string_hash_lookup failed: %s\"),\n \t\t     bfd_errmsg (bfd_get_error ()));\n-\t  return FALSE;\n+\t  return false;\n \t}\n       if (h->index != -1)\n \tstrx = h->index;\n@@ -387,14 +387,14 @@ stab_write_symbol (struct stab_write_handle *info, int type, int desc,\n \n   info->symbols_size += STAB_SYMBOL_SIZE;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push a string on to the type stack.  */\n \n-static bfd_boolean\n+static bool\n stab_push_string (struct stab_write_handle *info, const char *string,\n-\t\t  long tindex, bfd_boolean definition, unsigned int size)\n+\t\t  long tindex, bool definition, unsigned int size)\n {\n   struct stab_type_stack *s;\n \n@@ -412,19 +412,19 @@ stab_push_string (struct stab_write_handle *info, const char *string,\n   s->next = info->type_stack;\n   info->type_stack = s;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push a type index which has already been defined.  */\n \n-static bfd_boolean\n+static bool\n stab_push_defined_type (struct stab_write_handle *info, long tindex,\n \t\t\tunsigned int size)\n {\n   char buf[20];\n \n   sprintf (buf, \"%ld\", tindex);\n-  return stab_push_string (info, buf, tindex, FALSE, size);\n+  return stab_push_string (info, buf, tindex, false, size);\n }\n \n /* Pop a type off the type stack.  The caller is responsible for\n@@ -458,7 +458,7 @@ stab_pop_type (struct stab_write_handle *info)\n    the symbols, *PSYMSIZE the size of the symbols, *PSTRINGS to the\n    strings, and *PSTRINGSIZE to the size of the strings.  */\n \n-bfd_boolean\n+bool\n write_stabs_in_sections_debugging_info (bfd *abfd, void *dhandle,\n \t\t\t\t\tbfd_byte **psyms,\n \t\t\t\t\tbfd_size_type *psymsize,\n@@ -487,7 +487,7 @@ write_stabs_in_sections_debugging_info (bfd *abfd, void *dhandle,\n     {\n       non_fatal (\"bfd_hash_table_init_failed: %s\",\n \t\t bfd_errmsg (bfd_get_error ()));\n-      return FALSE;\n+      return false;\n     }\n \n   info.type_stack = NULL;\n@@ -502,23 +502,23 @@ write_stabs_in_sections_debugging_info (bfd *abfd, void *dhandle,\n \n   /* The initial symbol holds the string size.  */\n   if (! stab_write_symbol (&info, 0, 0, 0, (const char *) NULL))\n-    return FALSE;\n+    return false;\n \n   /* Output an initial N_SO symbol.  */\n   info.so_offset = info.symbols_size;\n   if (! stab_write_symbol (&info, N_SO, 0, 0, bfd_get_filename (abfd)))\n-    return FALSE;\n+    return false;\n \n   if (! debug_write (dhandle, &stab_fns, (void *) &info))\n-    return FALSE;\n+    return false;\n \n   if (info.pending_lbrac != (bfd_vma) -1)\n-    return FALSE;\n+    return false;\n \n   /* Output a trailing N_SO.  */\n   if (! stab_write_symbol (&info, N_SO, 0, info.last_text_address,\n \t\t\t   (const char *) NULL))\n-    return FALSE;\n+    return false;\n \n   /* Put the string size in the initial symbol.  */\n   bfd_put_32 (abfd, info.strings_size, info.symbols + 8);\n@@ -537,12 +537,12 @@ write_stabs_in_sections_debugging_info (bfd *abfd, void *dhandle,\n       p += strlen ((char *) p) + 1;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start writing out information for a compilation unit.  */\n \n-static bfd_boolean\n+static bool\n stab_start_compilation_unit (void *p, const char *filename)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -559,7 +559,7 @@ stab_start_compilation_unit (void *p, const char *filename)\n \n /* Start writing out information for a particular source file.  */\n \n-static bfd_boolean\n+static bool\n stab_start_source (void *p, const char *filename)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -576,7 +576,7 @@ stab_start_source (void *p, const char *filename)\n /* Push an empty type.  This shouldn't normally happen.  We just use a\n    void type.  */\n \n-static bfd_boolean\n+static bool\n stab_empty_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -596,13 +596,13 @@ stab_empty_type (void *p)\n \n       sprintf (buf, \"%ld=%ld\", tindex, tindex);\n \n-      return stab_push_string (info, buf, tindex, FALSE, 0);\n+      return stab_push_string (info, buf, tindex, false, 0);\n     }\n }\n \n /* Push a void type.  */\n \n-static bfd_boolean\n+static bool\n stab_void_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -621,22 +621,22 @@ stab_void_type (void *p)\n \n       sprintf (buf, \"%ld=%ld\", tindex, tindex);\n \n-      return stab_push_string (info, buf, tindex, TRUE, 0);\n+      return stab_push_string (info, buf, tindex, true, 0);\n     }\n }\n \n /* Push an integer type.  */\n \n-static bfd_boolean\n-stab_int_type (void *p, unsigned int size, bfd_boolean unsignedp)\n+static bool\n+stab_int_type (void *p, unsigned int size, bool unsignedp)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n   long *cache;\n \n   if (size <= 0 || (size > sizeof (long) && size != 8))\n     {\n       non_fatal (_(\"stab_int_type: bad size %u\"), size);\n-      return FALSE;\n+      return false;\n     }\n \n   if (unsignedp)\n@@ -681,13 +681,13 @@ stab_int_type (void *p, unsigned int size, bfd_boolean unsignedp)\n \t    abort ();\n \t}\n \n-      return stab_push_string (info, buf, tindex, TRUE, size);\n+      return stab_push_string (info, buf, tindex, true, size);\n     }\n }\n \n /* Push a floating point type.  */\n \n-static bfd_boolean\n+static bool\n stab_float_type (void *p, unsigned int size)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -706,8 +706,8 @@ stab_float_type (void *p, unsigned int size)\n       char buf[50];\n \n       /* Floats are defined as a subrange of int.  */\n-      if (! stab_int_type (info, 4, FALSE))\n-\treturn FALSE;\n+      if (! stab_int_type (info, 4, false))\n+\treturn false;\n       int_type = stab_pop_type (info);\n \n       tindex = info->type_index;\n@@ -722,13 +722,13 @@ stab_float_type (void *p, unsigned int size)\n \n       free (int_type);\n \n-      return stab_push_string (info, buf, tindex, TRUE, size);\n+      return stab_push_string (info, buf, tindex, true, size);\n     }\n }\n \n /* Push a complex type.  */\n \n-static bfd_boolean\n+static bool\n stab_complex_type (void *p, unsigned int size)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -740,13 +740,13 @@ stab_complex_type (void *p, unsigned int size)\n \n   sprintf (buf, \"%ld=r%ld;%u;0;\", tindex, tindex, size);\n \n-  return stab_push_string (info, buf, tindex, TRUE, size * 2);\n+  return stab_push_string (info, buf, tindex, true, size * 2);\n }\n \n-/* Push a bfd_boolean type.  We use an XCOFF predefined type, since gdb\n+/* Push a bool type.  We use an XCOFF predefined type, since gdb\n    always recognizes them.  */\n \n-static bfd_boolean\n+static bool\n stab_bool_type (void *p, unsigned int size)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -777,7 +777,7 @@ stab_bool_type (void *p, unsigned int size)\n \n /* Push an enum type.  */\n \n-static bfd_boolean\n+static bool\n stab_enum_type (void *p, const char *tag, const char **names,\n \t\tbfd_signed_vma *vals)\n {\n@@ -791,15 +791,15 @@ stab_enum_type (void *p, const char *tag, const char **names,\n   if (names == NULL)\n     {\n       if (tag == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       buf = (char *) xmalloc (10 + strlen (tag));\n       sprintf (buf, \"xe%s:\", tag);\n       /* FIXME: The size is just a guess.  */\n-      if (! stab_push_string (info, buf, 0, FALSE, 4))\n-\treturn FALSE;\n+      if (! stab_push_string (info, buf, 0, false, 4))\n+\treturn false;\n       free (buf);\n-      return TRUE;\n+      return true;\n     }\n \n   len = 10;\n@@ -826,26 +826,26 @@ stab_enum_type (void *p, const char *tag, const char **names,\n   if (tag == NULL)\n     {\n       /* FIXME: The size is just a guess.  */\n-      if (! stab_push_string (info, buf, 0, FALSE, 4))\n-\treturn FALSE;\n+      if (! stab_push_string (info, buf, 0, false, 4))\n+\treturn false;\n     }\n   else\n     {\n       /* FIXME: The size is just a guess.  */\n       if (! stab_write_symbol (info, N_LSYM, 0, 0, buf)\n \t  || ! stab_push_defined_type (info, tindex, 4))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push a modification of the top type on the stack.  Cache the\n    results in CACHE and CACHE_ALLOC.  */\n \n-static bfd_boolean\n+static bool\n stab_modify_type (struct stab_write_handle *info, int mod,\n \t\t  unsigned int size, long **cache, size_t *cache_alloc)\n {\n@@ -854,13 +854,13 @@ stab_modify_type (struct stab_write_handle *info, int mod,\n   char *s, *buf;\n \n   if (info->type_stack == NULL)\n-    return FALSE;\n+    return false;\n   targindex = info->type_stack->index;\n \n   if (targindex <= 0\n       || cache == NULL)\n     {\n-      bfd_boolean definition;\n+      bool definition;\n \n       /* Either the target type has no index, or we aren't caching\n          this modifier.  Either way we have no way of recording the\n@@ -871,7 +871,7 @@ stab_modify_type (struct stab_write_handle *info, int mod,\n       sprintf (buf, \"%c%s\", mod, s);\n       free (s);\n       if (! stab_push_string (info, buf, 0, definition, size))\n-\treturn FALSE;\n+\treturn false;\n       free (buf);\n     }\n   else\n@@ -902,7 +902,7 @@ stab_modify_type (struct stab_write_handle *info, int mod,\n              referenced).  */\n \t  free (stab_pop_type (info));\n \t  if (! stab_push_defined_type (info, tindex, size))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       else\n \t{\n@@ -916,19 +916,19 @@ stab_modify_type (struct stab_write_handle *info, int mod,\n \n \t  (*cache)[targindex] = tindex;\n \n-\t  if (! stab_push_string (info, buf, tindex, TRUE, size))\n-\t    return FALSE;\n+\t  if (! stab_push_string (info, buf, tindex, true, size))\n+\t    return false;\n \n \t  free (buf);\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push a pointer type.  */\n \n-static bfd_boolean\n+static bool\n stab_pointer_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -940,9 +940,9 @@ stab_pointer_type (void *p)\n \n /* Push a function type.  */\n \n-static bfd_boolean\n+static bool\n stab_function_type (void *p, int argcount,\n-\t\t    bfd_boolean varargs ATTRIBUTE_UNUSED)\n+\t\t    bool varargs ATTRIBUTE_UNUSED)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n   int i;\n@@ -965,7 +965,7 @@ stab_function_type (void *p, int argcount,\n \t  free (s);\n \n \t  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))\n-\t    return FALSE;\n+\t    return false;\n \n \t  free (buf);\n \t}\n@@ -977,7 +977,7 @@ stab_function_type (void *p, int argcount,\n \n /* Push a reference type.  */\n \n-static bfd_boolean\n+static bool\n stab_reference_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -989,11 +989,11 @@ stab_reference_type (void *p)\n \n /* Push a range type.  */\n \n-static bfd_boolean\n+static bool\n stab_range_type (void *p, bfd_signed_vma low, bfd_signed_vma high)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   unsigned int size;\n   char *s, *buf;\n \n@@ -1006,21 +1006,21 @@ stab_range_type (void *p, bfd_signed_vma low, bfd_signed_vma high)\n   free (s);\n \n   if (! stab_push_string (info, buf, 0, definition, size))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push an array type.  */\n \n-static bfd_boolean\n+static bool\n stab_array_type (void *p, bfd_signed_vma low, bfd_signed_vma high,\n-\t\t bfd_boolean stringp)\n+\t\t bool stringp)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   unsigned int element_size;\n   char *range, *element, *buf;\n   long tindex;\n@@ -1046,7 +1046,7 @@ stab_array_type (void *p, bfd_signed_vma low, bfd_signed_vma high,\n          attribute.  */\n       tindex = info->type_index;\n       ++info->type_index;\n-      definition = TRUE;\n+      definition = true;\n       sprintf (buf, \"%ld=@S;\", tindex);\n     }\n \n@@ -1060,20 +1060,20 @@ stab_array_type (void *p, bfd_signed_vma low, bfd_signed_vma high,\n   else\n     size = element_size * ((high - low) + 1);\n   if (! stab_push_string (info, buf, tindex, definition, size))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push a set type.  */\n \n-static bfd_boolean\n-stab_set_type (void *p, bfd_boolean bitstringp)\n+static bool\n+stab_set_type (void *p, bool bitstringp)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   char *s, *buf;\n   long tindex;\n \n@@ -1093,28 +1093,28 @@ stab_set_type (void *p, bfd_boolean bitstringp)\n          attribute.  */\n       tindex = info->type_index;\n       ++info->type_index;\n-      definition = TRUE;\n+      definition = true;\n       sprintf (buf, \"%ld=@S;\", tindex);\n     }\n \n   sprintf (buf + strlen (buf), \"S%s\", s);\n   free (s);\n \n   if (! stab_push_string (info, buf, tindex, definition, 0))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push an offset type.  */\n \n-static bfd_boolean\n+static bool\n stab_offset_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   char *target, *base, *buf;\n \n   definition = info->type_stack->definition;\n@@ -1129,21 +1129,21 @@ stab_offset_type (void *p)\n   free (target);\n \n   if (! stab_push_string (info, buf, 0, definition, 0))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push a method type.  */\n \n-static bfd_boolean\n-stab_method_type (void *p, bfd_boolean domainp, int argcount,\n-\t\t  bfd_boolean varargs)\n+static bool\n+stab_method_type (void *p, bool domainp, int argcount,\n+\t\t  bool varargs)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   char *domain, *return_type, *buf;\n   char **args;\n   int i;\n@@ -1158,7 +1158,7 @@ stab_method_type (void *p, bfd_boolean domainp, int argcount,\n   if (! domainp)\n     {\n       if (! stab_empty_type (p))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   definition = info->type_stack->definition;\n@@ -1180,7 +1180,7 @@ stab_method_type (void *p, bfd_boolean domainp, int argcount,\n \t{\n \t  args = (char **) xmalloc (1 * sizeof (*args));\n \t  if (! stab_empty_type (p))\n-\t    return FALSE;\n+\t    return false;\n \t  definition = definition || info->type_stack->definition;\n \t  args[0] = stab_pop_type (info);\n \t  argcount = 1;\n@@ -1197,7 +1197,7 @@ stab_method_type (void *p, bfd_boolean domainp, int argcount,\n       if (! varargs)\n \t{\n \t  if (! stab_empty_type (p))\n-\t    return FALSE;\n+\t    return false;\n \t  definition = definition || info->type_stack->definition;\n \t  args[argcount] = stab_pop_type (info);\n \t  ++argcount;\n@@ -1227,16 +1227,16 @@ stab_method_type (void *p, bfd_boolean domainp, int argcount,\n   free (args);\n \n   if (! stab_push_string (info, buf, 0, definition, 0))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push a const version of a type.  */\n \n-static bfd_boolean\n+static bool\n stab_const_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -1247,7 +1247,7 @@ stab_const_type (void *p)\n \n /* Push a volatile version of a type.  */\n \n-static bfd_boolean\n+static bool\n stab_volatile_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -1307,52 +1307,52 @@ stab_get_struct_index (struct stab_write_handle *info, const char *tag,\n /* Start outputting a struct.  We ignore the tag, and handle it in\n    stab_tag.  */\n \n-static bfd_boolean\n+static bool\n stab_start_struct_type (void *p, const char *tag, unsigned int id,\n-\t\t\tbfd_boolean structp, unsigned int size)\n+\t\t\tbool structp, unsigned int size)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n   long tindex;\n-  bfd_boolean definition;\n+  bool definition;\n   char buf[40];\n \n   if (id == 0)\n     {\n       tindex = 0;\n       *buf = '\\0';\n-      definition = FALSE;\n+      definition = false;\n     }\n   else\n     {\n       tindex = stab_get_struct_index (info, tag, id, DEBUG_KIND_ILLEGAL,\n \t\t\t\t     &size);\n       if (tindex < 0)\n-\treturn FALSE;\n+\treturn false;\n       sprintf (buf, \"%ld=\", tindex);\n-      definition = TRUE;\n+      definition = true;\n     }\n \n   sprintf (buf + strlen (buf), \"%c%u\",\n \t   structp ? 's' : 'u',\n \t   size);\n \n   if (! stab_push_string (info, buf, tindex, definition, size))\n-    return FALSE;\n+    return false;\n \n   info->type_stack->fields = (char *) xmalloc (1);\n   info->type_stack->fields[0] = '\\0';\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a field to a struct.  */\n \n-static bfd_boolean\n+static bool\n stab_struct_field (void *p, const char *name, bfd_vma bitpos,\n \t\t   bfd_vma bitsize, enum debug_visibility visibility)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   unsigned int size;\n   char *s, *n;\n   const char *vis;\n@@ -1364,7 +1364,7 @@ stab_struct_field (void *p, const char *name, bfd_vma bitpos,\n   /* Add this field to the end of the current struct fields, which is\n      currently on the top of the stack.  */\n   if (info->type_stack->fields == NULL)\n-    return FALSE;\n+    return false;\n \n   n = (char *) xmalloc (strlen (info->type_stack->fields)\n \t\t\t+ strlen (name)\n@@ -1404,24 +1404,24 @@ stab_struct_field (void *p, const char *name, bfd_vma bitpos,\n   info->type_stack->fields = n;\n \n   if (definition)\n-    info->type_stack->definition = TRUE;\n+    info->type_stack->definition = true;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Finish up a struct.  */\n \n-static bfd_boolean\n+static bool\n stab_end_struct_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   long tindex;\n   unsigned int size;\n   char *fields, *first, *buf;\n \n   if (info->type_stack == NULL || info->type_stack->fields == NULL)\n-    return FALSE;\n+    return false;\n \n   definition = info->type_stack->definition;\n   tindex = info->type_stack->index;\n@@ -1435,22 +1435,22 @@ stab_end_struct_type (void *p)\n   free (fields);\n \n   if (! stab_push_string (info, buf, tindex, definition, size))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start outputting a class.  */\n \n-static bfd_boolean\n+static bool\n stab_start_class_type (void *p, const char *tag, unsigned int id,\n-\t\t       bfd_boolean structp, unsigned int size,\n-\t\t       bfd_boolean vptr, bfd_boolean ownvptr)\n+\t\t       bool structp, unsigned int size,\n+\t\t       bool vptr, bool ownvptr)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition = FALSE;\n+  bool definition = false;\n   char *vstring = NULL;\n \n   if (vptr && !ownvptr)\n@@ -1460,7 +1460,7 @@ stab_start_class_type (void *p, const char *tag, unsigned int id,\n     }\n \n   if (! stab_start_struct_type (p, tag, id, structp, size))\n-    return FALSE;\n+    return false;\n \n   if (vptr)\n     {\n@@ -1469,34 +1469,34 @@ stab_start_class_type (void *p, const char *tag, unsigned int id,\n       if (ownvptr)\n \t{\n \t  if (info->type_stack->index < 1)\n-\t    return FALSE;\n+\t    return false;\n \t  vtable = (char *) xmalloc (20);\n \t  sprintf (vtable, \"~%%%ld\", info->type_stack->index);\n \t}\n       else\n \t{\n \t  if (vstring == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t  vtable = (char *) xmalloc (strlen (vstring) + 3);\n \t  sprintf (vtable, \"~%%%s\", vstring);\n \t  free (vstring);\n \t  if (definition)\n-\t    info->type_stack->definition = TRUE;\n+\t    info->type_stack->definition = true;\n \t}\n       info->type_stack->vtable = vtable;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a static member to the class on the type stack.  */\n \n-static bfd_boolean\n+static bool\n stab_class_static_member (void *p, const char *name, const char *physname,\n \t\t\t  enum debug_visibility visibility)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   char *s, *n;\n   const char *vis;\n \n@@ -1507,7 +1507,7 @@ stab_class_static_member (void *p, const char *name, const char *physname,\n      currently on the top of the stack.  */\n \n   if (info->type_stack->fields == NULL)\n-    return FALSE;\n+    return false;\n   n = (char *) xmalloc (strlen (info->type_stack->fields)\n \t\t\t+ strlen (name)\n \t\t\t+ strlen (s)\n@@ -1539,19 +1539,19 @@ stab_class_static_member (void *p, const char *name, const char *physname,\n   info->type_stack->fields = n;\n \n   if (definition)\n-    info->type_stack->definition = TRUE;\n+    info->type_stack->definition = true;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a base class to the class on the type stack.  */\n \n-static bfd_boolean\n-stab_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n+static bool\n+stab_class_baseclass (void *p, bfd_vma bitpos, bool is_virtual,\n \t\t      enum debug_visibility visibility)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n-  bfd_boolean definition;\n+  bool definition;\n   char *s;\n   char *buf;\n   unsigned int c;\n@@ -1588,7 +1588,7 @@ stab_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n   /* Add the new baseclass to the existing ones.  */\n \n   if (info->type_stack == NULL || info->type_stack->fields == NULL)\n-    return FALSE;\n+    return false;\n \n   if (info->type_stack->baseclasses == NULL)\n     c = 0;\n@@ -1607,21 +1607,21 @@ stab_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,\n   info->type_stack->baseclasses = baseclasses;\n \n   if (definition)\n-    info->type_stack->definition = TRUE;\n+    info->type_stack->definition = true;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start adding a method to the class on the type stack.  */\n \n-static bfd_boolean\n+static bool\n stab_class_start_method (void *p, const char *name)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n   char *m;\n \n   if (info->type_stack == NULL || info->type_stack->fields == NULL)\n-    return FALSE;\n+    return false;\n \n   if (info->type_stack->methods == NULL)\n     {\n@@ -1640,19 +1640,19 @@ stab_class_start_method (void *p, const char *name)\n \n   info->type_stack->methods = m;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a variant, either static or not, to the current method.  */\n \n-static bfd_boolean\n+static bool\n stab_class_method_var (struct stab_write_handle *info, const char *physname,\n \t\t       enum debug_visibility visibility,\n-\t\t       bfd_boolean staticp, bfd_boolean constp,\n-\t\t       bfd_boolean volatilep, bfd_vma voffset,\n-\t\t       bfd_boolean contextp)\n+\t\t       bool staticp, bool constp,\n+\t\t       bool volatilep, bfd_vma voffset,\n+\t\t       bool contextp)\n {\n-  bfd_boolean definition;\n+  bool definition;\n   char *type;\n   char *context = NULL;\n   char visc, qualc, typec;\n@@ -1667,7 +1667,7 @@ stab_class_method_var (struct stab_write_handle *info, const char *physname,\n     }\n \n   if (info->type_stack == NULL || info->type_stack->methods == NULL)\n-    return FALSE;\n+    return false;\n \n   switch (visibility)\n     {\n@@ -1729,58 +1729,58 @@ stab_class_method_var (struct stab_write_handle *info, const char *physname,\n     }\n \n   if (definition)\n-    info->type_stack->definition = TRUE;\n+    info->type_stack->definition = true;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Add a variant to the current method.  */\n \n-static bfd_boolean\n+static bool\n stab_class_method_variant (void *p, const char *physname,\n \t\t\t   enum debug_visibility visibility,\n-\t\t\t   bfd_boolean constp, bfd_boolean volatilep,\n-\t\t\t   bfd_vma voffset, bfd_boolean contextp)\n+\t\t\t   bool constp, bool volatilep,\n+\t\t\t   bfd_vma voffset, bool contextp)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n \n-  return stab_class_method_var (info, physname, visibility, FALSE, constp,\n+  return stab_class_method_var (info, physname, visibility, false, constp,\n \t\t\t\tvolatilep, voffset, contextp);\n }\n \n /* Add a static variant to the current method.  */\n \n-static bfd_boolean\n+static bool\n stab_class_static_method_variant (void *p, const char *physname,\n \t\t\t\t  enum debug_visibility visibility,\n-\t\t\t\t  bfd_boolean constp, bfd_boolean volatilep)\n+\t\t\t\t  bool constp, bool volatilep)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n \n-  return stab_class_method_var (info, physname, visibility, TRUE, constp,\n-\t\t\t\tvolatilep, 0, FALSE);\n+  return stab_class_method_var (info, physname, visibility, true, constp,\n+\t\t\t\tvolatilep, 0, false);\n }\n \n /* Finish up a method.  */\n \n-static bfd_boolean\n+static bool\n stab_class_end_method (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n \n   if (info->type_stack == NULL || info->type_stack->methods == NULL)\n-    return FALSE;\n+    return false;\n \n   /* We allocated enough room on info->type_stack->methods to add the\n      trailing semicolon.  */\n   strcat (info->type_stack->methods, \";\");\n \n-  return TRUE;\n+  return true;\n }\n \n /* Finish up a class.  */\n \n-static bfd_boolean\n+static bool\n stab_end_class_type (void *p)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -1791,7 +1791,7 @@ stab_end_class_type (void *p)\n   if (info->type_stack == NULL\n       || info->type_stack->string == NULL\n       || info->type_stack->fields == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Work out the size we need to allocate for the class definition.  */\n \n@@ -1852,27 +1852,27 @@ stab_end_class_type (void *p)\n   free (info->type_stack->string);\n   info->type_stack->string = buf;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Push a typedef which was previously defined.  */\n \n-static bfd_boolean\n+static bool\n stab_typedef_type (void *p, const char *name)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n   struct string_hash_entry *h;\n \n-  h = string_hash_lookup (&info->typedef_hash, name, FALSE, FALSE);\n+  h = string_hash_lookup (&info->typedef_hash, name, false, false);\n   if (h == NULL || h->index < 1)\n-    return FALSE;\n+    return false;\n \n   return stab_push_defined_type (info, h->index, h->size);\n }\n \n /* Push a struct, union or class tag.  */\n \n-static bfd_boolean\n+static bool\n stab_tag_type (void *p, const char *name, unsigned int id,\n \t       enum debug_type_kind kind)\n {\n@@ -1882,14 +1882,14 @@ stab_tag_type (void *p, const char *name, unsigned int id,\n \n   tindex = stab_get_struct_index (info, name, id, kind, &size);\n   if (tindex < 0)\n-    return FALSE;\n+    return false;\n \n   return stab_push_defined_type (info, tindex, size);\n }\n \n /* Define a typedef.  */\n \n-static bfd_boolean\n+static bool\n stab_typdef (void *p, const char *name)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -1916,29 +1916,29 @@ stab_typdef (void *p, const char *name)\n   free (s);\n \n   if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  h = string_hash_lookup (&info->typedef_hash, name, TRUE, FALSE);\n+  h = string_hash_lookup (&info->typedef_hash, name, true, false);\n   if (h == NULL)\n     {\n       non_fatal (_(\"string_hash_lookup failed: %s\"),\n \t\t bfd_errmsg (bfd_get_error ()));\n-      return FALSE;\n+      return false;\n     }\n \n   /* I don't think we care about redefinitions.  */\n \n   h->index = tindex;\n   h->size = size;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Define a tag.  */\n \n-static bfd_boolean\n+static bool\n stab_tag (void *p, const char *tag)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -1952,16 +1952,16 @@ stab_tag (void *p, const char *tag)\n   free (s);\n \n   if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Define an integer constant.  */\n \n-static bfd_boolean\n+static bool\n stab_int_constant (void *p, const char *name, bfd_vma val)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -1971,16 +1971,16 @@ stab_int_constant (void *p, const char *name, bfd_vma val)\n   sprintf (buf, \"%s:c=i%ld\", name, (long) val);\n \n   if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Define a floating point constant.  */\n \n-static bfd_boolean\n+static bool\n stab_float_constant (void *p, const char *name, double val)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -1990,16 +1990,16 @@ stab_float_constant (void *p, const char *name, double val)\n   sprintf (buf, \"%s:c=f%g\", name, val);\n \n   if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Define a typed constant.  */\n \n-static bfd_boolean\n+static bool\n stab_typed_constant (void *p, const char *name, bfd_vma val)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -2012,16 +2012,16 @@ stab_typed_constant (void *p, const char *name, bfd_vma val)\n   free (s);\n \n   if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Record a variable.  */\n \n-static bfd_boolean\n+static bool\n stab_variable (void *p, const char *name, enum debug_var_kind kind,\n \t       bfd_vma val)\n {\n@@ -2082,23 +2082,23 @@ stab_variable (void *p, const char *name, enum debug_var_kind kind,\n   free (s);\n \n   if (! stab_write_symbol (info, stab_type, 0, val, buf))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start outputting a function.  */\n \n-static bfd_boolean\n-stab_start_function (void *p, const char *name, bfd_boolean globalp)\n+static bool\n+stab_start_function (void *p, const char *name, bool globalp)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n   char *rettype, *buf;\n \n   if (info->nesting != 0 || info->fun_offset != -1)\n-    return FALSE;\n+    return false;\n \n   rettype = stab_pop_type (info);\n \n@@ -2111,16 +2111,16 @@ stab_start_function (void *p, const char *name, bfd_boolean globalp)\n   info->fun_offset = info->symbols_size;\n \n   if (! stab_write_symbol (info, N_FUN, 0, 0, buf))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Output a function parameter.  */\n \n-static bfd_boolean\n+static bool\n stab_function_parameter (void *p, const char *name, enum debug_parm_kind kind, bfd_vma val)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -2161,16 +2161,16 @@ stab_function_parameter (void *p, const char *name, enum debug_parm_kind kind, b\n   free (s);\n \n   if (! stab_write_symbol (info, stab_type, 0, val, buf))\n-    return FALSE;\n+    return false;\n \n   free (buf);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Start a block.  */\n \n-static bfd_boolean\n+static bool\n stab_start_block (void *p, bfd_vma addr)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -2199,7 +2199,7 @@ stab_start_block (void *p, bfd_vma addr)\n   if (info->nesting == 1)\n     {\n       info->fnaddr = addr;\n-      return TRUE;\n+      return true;\n     }\n \n   /* We have to output the LBRAC symbol after any variables which are\n@@ -2211,19 +2211,19 @@ stab_start_block (void *p, bfd_vma addr)\n     {\n       if (! stab_write_symbol (info, N_LBRAC, 0, info->pending_lbrac,\n \t\t\t       (const char *) NULL))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Remember the address and output it later.  */\n \n   info->pending_lbrac = addr - info->fnaddr;\n \n-  return TRUE;\n+  return true;\n }\n \n /* End a block.  */\n \n-static bfd_boolean\n+static bool\n stab_end_block (void *p, bfd_vma addr)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n@@ -2236,48 +2236,48 @@ stab_end_block (void *p, bfd_vma addr)\n     {\n       if (! stab_write_symbol (info, N_LBRAC, 0, info->pending_lbrac,\n \t\t\t       (const char *) NULL))\n-\treturn FALSE;\n+\treturn false;\n       info->pending_lbrac = (bfd_vma) -1;\n     }\n \n   if (info->nesting < 1)\n-    return FALSE;\n+    return false;\n \n   --info->nesting;\n \n   /* We ignore the outermost block.  */\n   if (info->nesting == 0)\n-    return TRUE;\n+    return true;\n \n   return stab_write_symbol (info, N_RBRAC, 0, addr - info->fnaddr,\n \t\t\t    (const char *) NULL);\n }\n \n /* End a function.  */\n \n-static bfd_boolean\n+static bool\n stab_end_function (void *p ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n /* Output a line number.  */\n \n-static bfd_boolean\n+static bool\n stab_lineno (void *p, const char *file, unsigned long lineno, bfd_vma addr)\n {\n   struct stab_write_handle *info = (struct stab_write_handle *) p;\n \n   if (info->lineno_filename == NULL)\n-    return FALSE;\n+    return false;\n \n   if (addr > info->last_text_address)\n     info->last_text_address = addr;\n \n   if (filename_cmp (file, info->lineno_filename) != 0)\n     {\n       if (! stab_write_symbol (info, N_SOL, 0, addr, file))\n-\treturn FALSE;\n+\treturn false;\n       info->lineno_filename = file;\n     }\n "
    }
  ]
}