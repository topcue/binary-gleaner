{
  "sha": "b4b1a226df8d51da9594200ad803ad303c15cd36",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjRiMWEyMjZkZjhkNTFkYTk1OTQyMDBhZDgwM2FkMzAzYzE1Y2QzNg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-07-06T19:53:28Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-03-26T16:02:11Z"
    },
    "message": "gdb: defer commit resume until all available events are consumed\n\nRationale\n---------\n\nLet's say you have multiple threads hitting a conditional breakpoint\nat the same time, and all of these are going to evaluate to false.\nAll these threads will need to be resumed.\n\nCurrently, GDB fetches one target event (one SIGTRAP representing the\nbreakpoint hit) and decides that the thread should be resumed.  It\ncalls resume and commit_resume immediately.  It then fetches the\nsecond target event, and does the same, until it went through all\nthreads.\n\nThe result is therefore something like:\n\n  - consume event for thread A\n  - resume thread A\n  - commit resume (affects thread A)\n  - consume event for thread B\n  - resume thread B\n  - commit resume (affects thread B)\n  - consume event for thread C\n  - resume thread C\n  - commit resume (affects thread C)\n\nFor targets where it's beneficial to group resumptions requests (most\nlikely those that implement target_ops::commit_resume), it would be\nmuch better to have:\n\n  - consume event for thread A\n  - resume thread A\n  - consume event for thread B\n  - resume thread B\n  - consume event for thread C\n  - resume thread C\n  - commit resume (affects threads A, B and C)\n\nImplementation details\n----------------------\n\nTo achieve this, this patch adds another check in\nmaybe_set_commit_resumed_all_targets to avoid setting the\ncommit-resumed flag of targets that readily have events to provide to\ninfrun.\n\nTo determine if a target has events readily available to report, this\npatch adds an `has_pending_events` target_ops method.  The method\nreturns a simple bool to say whether or not it has pending events to\nreport.\n\nTesting\n=======\n\nTo test this, I start GDBserver with a program that spawns multiple\nthreads:\n\n $ ../gdbserver/gdbserver --once :1234 ~/src/many-threads-stepping-over-breakpoints/many-threads-stepping-over-breakpoints\n\nI then connect with GDB and install a conditional breakpoint that always\nevaluates to false (and force the evaluation to be done by GDB):\n\n $ ./gdb -nx --data-directory=data-directory \\\n     /home/simark/src/many-threads-stepping-over-breakpoints/many-threads-stepping-over-breakpoints \\\n     -ex \"set breakpoint condition-evaluation host\" \\\n     -ex \"set pag off\" \\\n     -ex \"set confirm off\" \\\n     -ex \"maint set target-non-stop on\" \\\n     -ex \"tar rem :1234\" \\\n     -ex \"tb main\" \\\n     -ex \"b 13 if 0\" \\\n     -ex c \\\n     -ex \"set debug infrun\" \\\n     -ex \"set debug remote 1\" \\\n     -ex \"set debug displaced\"\n\nI then do \"continue\" and look at the log.\n\nThe remote target receives a bunch of stop notifications for all\nthreads that have hit the breakpoint.  infrun consumes and processes\none event, decides it should not cause a stop, prepares a displaced\nstep, after which we should see:\n\n [infrun] maybe_set_commit_resumed_all_process_targets: not requesting commit-resumed for target remote, target has pending events\n\nSame for a second thread (since we have 2 displaced step buffers).\nFor the following threads, their displaced step is deferred since\nthere are no more buffers available.\n\nAfter consuming the last event the remote target has to offer, we get:\n\n [infrun] maybe_set_commit_resumed_all_process_targets: enabling commit-resumed for target remote\n [infrun] maybe_call_commit_resumed_all_process_targets: calling commit_resumed for target remote\n [remote] Sending packet: $vCont;s:p14d16b.14d1b1;s:p14d16b.14d1b2#55\n [remote] Packet received: OK\n\nWithout the patch, there would have been one vCont;s just after each\nprepared displaced step.\n\ngdb/ChangeLog:\nyyyy-mm-dd  Simon Marchi  <simon.marchi@efficios.com>\n\t    Pedro Alves  <pedro@palves.net>\n\n\t* async-event.c (async_event_handler_marked): New.\n\t* async-event.h (async_event_handler_marked): Declare.\n\t* infrun.c (maybe_set_commit_resumed_all_targets): Switch to\n\tinferior before calling target method.  Don't commit-resumed if\n\ttarget_has_pending_events is true.\n\t* remote.c (remote_target::has_pending_events): New.\n\t* target-delegates.c: Regenerate.\n\t* target.c (target_has_pending_events): New.\n\t* target.h (target_ops::has_pending_events): New target method.\n\t(target_has_pending_events): New.\n\nChange-Id: I18112ba19a1ff4986530c660f530d847bb4a1f1d",
    "tree": {
      "sha": "3bede2638d337cf225cbb0a4319bab863134316d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3bede2638d337cf225cbb0a4319bab863134316d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b4b1a226df8d51da9594200ad803ad303c15cd36",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b4b1a226df8d51da9594200ad803ad303c15cd36",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b4b1a226df8d51da9594200ad803ad303c15cd36",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b4b1a226df8d51da9594200ad803ad303c15cd36/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1192f124a308601f5fef7a35715ccd6f904e7b17",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1192f124a308601f5fef7a35715ccd6f904e7b17",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1192f124a308601f5fef7a35715ccd6f904e7b17"
    }
  ],
  "stats": {
    "total": 108,
    "additions": 108,
    "deletions": 0
  },
  "files": [
    {
      "sha": "fa4d5b7d24c3dc9b0b35181f31524f20e59df2a8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b4b1a226df8d51da9594200ad803ad303c15cd36",
      "patch": "@@ -1,3 +1,18 @@\n+2021-03-26  Simon Marchi  <simon.marchi@efficios.com>\n+\t    Pedro Alves  <pedro@palves.net>\n+\n+\t* async-event.c: Include \"infrun.h\".\n+\t(async_event_handler_marked): New.\n+\t* async-event.h (async_event_handler_marked): Declare.\n+\t* infrun.c (maybe_set_commit_resumed_all_targets): Switch to\n+\tinferior before calling target method.  Don't commit-resumed if\n+\ttarget_has_pending_events is true.\n+\t* remote.c (remote_target::has_pending_events): New.\n+\t* target-delegates.c: Regenerate.\n+\t* target.c (target_has_pending_events): New.\n+\t* target.h (target_ops::has_pending_events): New target method.\n+\t(target_has_pending_events): New.\n+\n 2021-03-26  Simon Marchi  <simon.marchi@efficios.com>\n \t    Pedro Alves  <pedro@palves.net>\n "
    },
    {
      "sha": "7b1abfe65f88a8c5305317b772bc54e0bf6fb46b",
      "filename": "gdb/async-event.c",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/async-event.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/async-event.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/async-event.c?ref=b4b1a226df8d51da9594200ad803ad303c15cd36",
      "patch": "@@ -308,6 +308,14 @@ clear_async_event_handler (async_event_handler *async_handler_ptr)\n   async_handler_ptr->ready = 0;\n }\n \n+/* See event-loop.h.  */\n+\n+bool\n+async_event_handler_marked (async_event_handler *handler)\n+{\n+  return handler->ready;\n+}\n+\n /* Check if asynchronous event handlers are ready, and call the\n    handler function for one that is.  */\n "
    },
    {
      "sha": "47759d5c2d396d66f89f8bcf0184030e55d9c7d1",
      "filename": "gdb/async-event.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/async-event.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/async-event.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/async-event.h?ref=b4b1a226df8d51da9594200ad803ad303c15cd36",
      "patch": "@@ -78,6 +78,9 @@ extern void\n    loop.  */\n extern void mark_async_event_handler (struct async_event_handler *handler);\n \n+/* Return true if HANDLER is marked.  */\n+extern bool async_event_handler_marked (async_event_handler *handler);\n+\n /* Mark the handler (ASYNC_HANDLER_PTR) as NOT ready.  */\n \n extern void clear_async_event_handler (struct async_event_handler *handler);"
    },
    {
      "sha": "6176fa94fe36d27c069e46f8ee98d72c44ae2aae",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=b4b1a226df8d51da9594200ad803ad303c15cd36",
      "patch": "@@ -2766,6 +2766,8 @@ schedlock_applies (struct thread_info *tp)\n static void\n maybe_set_commit_resumed_all_targets ()\n {\n+  scoped_restore_current_thread restore_thread;\n+\n   for (inferior *inf : all_non_exited_inferiors ())\n     {\n       process_stratum_target *proc_target = inf->process_target ();\n@@ -2807,6 +2809,16 @@ maybe_set_commit_resumed_all_targets ()\n \t  continue;\n \t}\n \n+      switch_to_inferior_no_thread (inf);\n+\n+      if (target_has_pending_events ())\n+\t{\n+\t  infrun_debug_printf (\"not requesting commit-resumed for target %s, \"\n+\t\t\t       \"target has pending events\",\n+\t\t\t       proc_target->shortname ());\n+\t  continue;\n+\t}\n+\n       infrun_debug_printf (\"enabling commit-resumed for target %s\",\n \t\t\t   proc_target->shortname ());\n "
    },
    {
      "sha": "fd0ad9c74cbce89adc963cf850eb9969f150ebd7",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=b4b1a226df8d51da9594200ad803ad303c15cd36",
      "patch": "@@ -429,6 +429,7 @@ class remote_target : public process_stratum_target\n   void commit_resumed () override;\n   void resume (ptid_t, int, enum gdb_signal) override;\n   ptid_t wait (ptid_t, struct target_waitstatus *, target_wait_flags) override;\n+  bool has_pending_events () override;\n \n   void fetch_registers (struct regcache *, int) override;\n   void store_registers (struct regcache *, int) override;\n@@ -6820,6 +6821,26 @@ remote_target::commit_resumed ()\n   vcont_builder.flush ();\n }\n \n+/* Implementation of target_has_pending_events.  */\n+\n+bool\n+remote_target::has_pending_events ()\n+{\n+  if (target_can_async_p ())\n+    {\n+      remote_state *rs = get_remote_state ();\n+\n+      if (async_event_handler_marked (rs->remote_async_inferior_event_token))\n+\treturn true;\n+\n+      /* Note that BUFCNT can be negative, indicating sticky\n+\t error.  */\n+      if (rs->remote_desc->bufcnt != 0)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n \f\n \n /* Non-stop version of target_stop.  Uses `vCont;t' to stop a remote"
    },
    {
      "sha": "cc8c64a4f1e678d9c23ebb98b5d24097c0f9a433",
      "filename": "gdb/target-delegates.c",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/target-delegates.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/target-delegates.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-delegates.c?ref=b4b1a226df8d51da9594200ad803ad303c15cd36",
      "patch": "@@ -84,6 +84,7 @@ struct dummy_target : public target_ops\n   bool is_async_p () override;\n   void async (int arg0) override;\n   int async_wait_fd () override;\n+  bool has_pending_events () override;\n   void thread_events (int arg0) override;\n   bool supports_non_stop () override;\n   bool always_non_stop_p () override;\n@@ -258,6 +259,7 @@ struct debug_target : public target_ops\n   bool is_async_p () override;\n   void async (int arg0) override;\n   int async_wait_fd () override;\n+  bool has_pending_events () override;\n   void thread_events (int arg0) override;\n   bool supports_non_stop () override;\n   bool always_non_stop_p () override;\n@@ -2199,6 +2201,31 @@ debug_target::async_wait_fd ()\n   return result;\n }\n \n+bool\n+target_ops::has_pending_events ()\n+{\n+  return this->beneath ()->has_pending_events ();\n+}\n+\n+bool\n+dummy_target::has_pending_events ()\n+{\n+  return false;\n+}\n+\n+bool\n+debug_target::has_pending_events ()\n+{\n+  bool result;\n+  fprintf_unfiltered (gdb_stdlog, \"-> %s->has_pending_events (...)\\n\", this->beneath ()->shortname ());\n+  result = this->beneath ()->has_pending_events ();\n+  fprintf_unfiltered (gdb_stdlog, \"<- %s->has_pending_events (\", this->beneath ()->shortname ());\n+  fputs_unfiltered (\") = \", gdb_stdlog);\n+  target_debug_print_bool (result);\n+  fputs_unfiltered (\"\\n\", gdb_stdlog);\n+  return result;\n+}\n+\n void\n target_ops::thread_events (int arg0)\n {"
    },
    {
      "sha": "995e7ef1dac174405cb25005fdd63620025a8a22",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=b4b1a226df8d51da9594200ad803ad303c15cd36",
      "patch": "@@ -2679,6 +2679,14 @@ target_commit_resumed ()\n   current_inferior ()->top_target ()->commit_resumed ();\n }\n \n+/* See target.h.  */\n+\n+bool\n+target_has_pending_events ()\n+{\n+  return current_inferior ()->top_target ()->has_pending_events ();\n+}\n+\n void\n target_pass_signals (gdb::array_view<const unsigned char> pass_signals)\n {"
    },
    {
      "sha": "adae49dc32958ef88e0cee3c205e2bcaac0068cd",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b1a226df8d51da9594200ad803ad303c15cd36/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=b4b1a226df8d51da9594200ad803ad303c15cd36",
      "patch": "@@ -719,6 +719,15 @@ struct target_ops\n       TARGET_DEFAULT_NORETURN (tcomplain ());\n     virtual int async_wait_fd ()\n       TARGET_DEFAULT_NORETURN (noprocess ());\n+    /* Return true if the target has pending events to report to the\n+       core.  If true, then GDB avoids resuming the target until all\n+       pending events are consumed, so that multiple resumptions can\n+       be coalesced as an optimization.  Most targets can't tell\n+       whether they have pending events without calling target_wait,\n+       so we default to returning false.  The only downside is that a\n+       potential optimization is missed.  */\n+    virtual bool has_pending_events ()\n+      TARGET_DEFAULT_RETURN (false);\n     virtual void thread_events (int)\n       TARGET_DEFAULT_IGNORE ();\n     /* This method must be implemented in some situations.  See the\n@@ -1485,6 +1494,11 @@ extern ptid_t default_target_wait (struct target_ops *ops,\n \t\t\t\t   struct target_waitstatus *status,\n \t\t\t\t   target_wait_flags options);\n \n+/* Return true if the target has pending events to report to the core.\n+   See target_ops::has_pending_events().  */\n+\n+extern bool target_has_pending_events ();\n+\n /* Fetch at least register REGNO, or all regs if regno == -1.  No result.  */\n \n extern void target_fetch_registers (struct regcache *regcache, int regno);"
    }
  ]
}