{
  "sha": "bf31e6044082986689e17af54e2ca3cc1ac8419b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmYzMWU2MDQ0MDgyOTg2Njg5ZTE3YWY1NGUyY2EzY2MxYWM4NDE5Yg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-31T11:54:31Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-12-31T13:00:21Z"
    },
    "message": "asan: alpha-vms: Heap-buffer-overflow\n\nThis fixes yet more errors in the alpha-vms buffer size checks.\n\n\t* vms-alpha.c (_bfd_vms_slurp_eisd): Don't overflow when checking\n\toffset.  Don't overflow when checking rec_size, and do allow\n\trec_size to the end of the buffer.  Ensure eisd->type can be\n\taccessed, not just the first 32 bytes.  Don't call\n\t_bfd_vms_save_counted_string with zero length remaining.  Fail\n\ton empty string section name.\n\t(_bfd_vms_slurp_egsd): Formatting.  Catch more reads past end\n\tof record size.  Correct remaining length calculation.  Fail\n\ton empty string section name.  Consolidate error paths.",
    "tree": {
      "sha": "37c4b17ab773a456d5d16f64b6b1a76b814d74a3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/37c4b17ab773a456d5d16f64b6b1a76b814d74a3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bf31e6044082986689e17af54e2ca3cc1ac8419b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf31e6044082986689e17af54e2ca3cc1ac8419b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bf31e6044082986689e17af54e2ca3cc1ac8419b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bf31e6044082986689e17af54e2ca3cc1ac8419b/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "930be6676412ab9a13ae7614ba57fb7e86a1ce72",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/930be6676412ab9a13ae7614ba57fb7e86a1ce72",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/930be6676412ab9a13ae7614ba57fb7e86a1ce72"
    }
  ],
  "stats": {
    "total": 104,
    "additions": 53,
    "deletions": 51
  },
  "files": [
    {
      "sha": "003f013b41537b3721bd1c30161a96712cbf03f2",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf31e6044082986689e17af54e2ca3cc1ac8419b/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf31e6044082986689e17af54e2ca3cc1ac8419b/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=bf31e6044082986689e17af54e2ca3cc1ac8419b",
      "patch": "@@ -1,3 +1,15 @@\n+2019-12-31  Alan Modra  <amodra@gmail.com>\n+\n+\t* vms-alpha.c (_bfd_vms_slurp_eisd): Don't overflow when checking\n+\toffset.  Don't overflow when checking rec_size, and do allow\n+\trec_size to the end of the buffer.  Ensure eisd->type can be\n+\taccessed, not just the first 32 bytes.  Don't call\n+\t_bfd_vms_save_counted_string with zero length remaining.  Fail\n+\ton empty string section name.\n+\t(_bfd_vms_slurp_egsd): Formatting.  Catch more reads past end\n+\tof record size.  Correct remaining length calculation.  Fail\n+\ton empty string section name.  Consolidate error paths.\n+\n 2019-12-30  Alan Modra  <amodra@gmail.com>\n \n \t* vms-alpha.c (alpha_vms_free_private): New function, extracted.."
    },
    {
      "sha": "2d289c3e8cfce32702a83c1e0f5679934052ceb5",
      "filename": "bfd/vms-alpha.c",
      "status": "modified",
      "additions": 41,
      "deletions": 51,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bf31e6044082986689e17af54e2ca3cc1ac8419b/bfd/vms-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bf31e6044082986689e17af54e2ca3cc1ac8419b/bfd/vms-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/vms-alpha.c?ref=bf31e6044082986689e17af54e2ca3cc1ac8419b",
      "patch": "@@ -529,12 +529,12 @@ _bfd_vms_slurp_eisd (bfd *abfd, unsigned int offset)\n       asection *section;\n       flagword bfd_flags;\n \n-      /* PR 17512: file: 3d9e9fe9.\n-\t 12 is the offset of the eisdsize field from the start of the record (8)\n-\t plus the size of the eisdsize field (4).  */\n-      if (offset >= PRIV (recrd.rec_size) - 12)\n+      /* PR 17512: file: 3d9e9fe9.  */\n+      if (offset > PRIV (recrd.rec_size)\n+\t  || (PRIV (recrd.rec_size) - offset\n+\t      < offsetof (struct vms_eisd, eisdsize) + 4))\n \treturn FALSE;\n-      eisd = (struct vms_eisd *)(PRIV (recrd.rec) + offset);\n+      eisd = (struct vms_eisd *) (PRIV (recrd.rec) + offset);\n       rec_size = bfd_getl32 (eisd->eisdsize);\n       if (rec_size == 0)\n \tbreak;\n@@ -547,11 +547,10 @@ _bfd_vms_slurp_eisd (bfd *abfd, unsigned int offset)\n \t}\n \n       /* Make sure that there is enough data present in the record.  */\n-      /* FIXME: Should we use sizeof (struct vms_eisd) rather than just 32 here ?  */\n-      if (rec_size < 32)\n+      if (rec_size < offsetof (struct vms_eisd, type) + 1)\n \treturn FALSE;\n       /* Make sure that the record is not too big either.  */\n-      if (offset + rec_size >= PRIV (recrd.rec_size))\n+      if (rec_size > PRIV (recrd.rec_size) - offset)\n \treturn FALSE;\n \n       offset += rec_size;\n@@ -592,15 +591,15 @@ _bfd_vms_slurp_eisd (bfd *abfd, unsigned int offset)\n \n       if (flags & EISD__M_GBL)\n \t{\n-\t  if (rec_size < offsetof (struct vms_eisd, gblnam))\n+\t  if (rec_size <= offsetof (struct vms_eisd, gblnam))\n \t    return FALSE;\n \t  else if (rec_size < sizeof (struct vms_eisd))\n \t    name = _bfd_vms_save_counted_string (abfd, eisd->gblnam,\n \t\t\t\t\t\t rec_size - offsetof (struct vms_eisd, gblnam));\n \t  else\n \t    name = _bfd_vms_save_counted_string (abfd, eisd->gblnam,\n \t\t\t\t\t\t EISD__K_GBLNAMLEN);\n-\t  if (name == NULL)\n+\t  if (name == NULL || name[0] == 0)\n \t    return FALSE;\n \t  bfd_flags |= SEC_COFF_SHARED_LIBRARY;\n \t  bfd_flags &= ~(SEC_ALLOC | SEC_LOAD);\n@@ -1181,6 +1180,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n   unsigned int gsd_size;\n   unsigned char *vms_rec;\n   bfd_vma base_addr;\n+  long psindx;\n \n   vms_debug2 ((2, \"EGSD\\n\"));\n \n@@ -1210,16 +1210,9 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n       /* PR 21615: Check for size overflow.  */\n       if (PRIV (recrd.rec_size) < gsd_size)\n \t{\n-\t  _bfd_error_handler (_(\"corrupt EGSD record: size (%#x) is larger than remaining space (%#x)\"),\n-\t\t\t      gsd_size, PRIV (recrd.rec_size));\n-\t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n-\t}\n-\n-      if (gsd_size < 4)\n-\t{\n-\t  _bfd_error_handler (_(\"corrupt EGSD record: size (%#x) is too small\"),\n-\t\t\t      gsd_size);\n+\t  _bfd_error_handler (_(\"corrupt EGSD record type %d: size (%#x) \"\n+\t\t\t\t\"is larger than remaining space (%#x)\"),\n+\t\t\t      gsd_type, gsd_size, PRIV (recrd.rec_size));\n \t  bfd_set_error (bfd_error_bad_value);\n \t  return FALSE;\n \t}\n@@ -1229,10 +1222,19 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \tcase EGSD__C_PSC:\n \t  /* Program section definition.  */\n \t  {\n-\t    struct vms_egps *egps = (struct vms_egps *)vms_rec;\n+\t    struct vms_egps *egps = (struct vms_egps *) vms_rec;\n \t    flagword new_flags, vms_flags;\n \t    asection *section;\n \n+\t    if (offsetof (struct vms_egps, flags) + 2 > gsd_size)\n+\t      {\n+\t      too_small:\n+\t\t_bfd_error_handler (_(\"corrupt EGSD record type %d: size (%#x) \"\n+\t\t\t\t      \"is too small\"),\n+\t\t\t\t    gsd_type, gsd_size);\n+\t\tbfd_set_error (bfd_error_bad_value);\n+\t\treturn FALSE;\n+\t      }\n \t    vms_flags = bfd_getl16 (egps->flags);\n \n \t    if ((vms_flags & EGPS__V_REL) == 0)\n@@ -1245,9 +1247,14 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \t      {\n \t\tchar *name;\n \t\tbfd_vma align_addr;\n+\t\tsize_t left;\n \n-\t\tname = _bfd_vms_save_counted_string (abfd, &egps->namlng,\n-\t\t\t\t\t\t     gsd_size - 4);\n+\t\tif (offsetof (struct vms_egps, namlng) >= gsd_size)\n+\t\t  goto too_small;\n+\t\tleft = gsd_size - offsetof (struct vms_egps, namlng);\n+\t\tname = _bfd_vms_save_counted_string (abfd, &egps->namlng, left);\n+\t\tif (name == NULL || name[0] == 0)\n+\t\t  return FALSE;\n \n \t\tsection = bfd_make_section (abfd, name);\n \t\tif (!section)\n@@ -1314,18 +1321,16 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \t    struct vms_egsy *egsy = (struct vms_egsy *) vms_rec;\n \t    flagword old_flags;\n \n+\t    if (offsetof (struct vms_egsy, flags) + 2 > gsd_size)\n+\t      goto too_small;\n \t    old_flags = bfd_getl16 (egsy->flags);\n \t    if (old_flags & EGSY__V_DEF)\n \t      nameoff = ESDF__B_NAMLNG;\n \t    else\n \t      nameoff = ESRF__B_NAMLNG;\n \n \t    if (nameoff >= gsd_size)\n-\t      {\n-\t\t_bfd_error_handler (_(\"ECSD__C_SYM record is too small\"));\n-\t\tbfd_set_error (bfd_error_bad_value);\n-\t\treturn FALSE;\n-\t      }\n+\t      goto too_small;\n \t    entry = add_symbol (abfd, vms_rec + nameoff, gsd_size - nameoff);\n \t    if (entry == NULL)\n \t      return FALSE;\n@@ -1343,8 +1348,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \n \t    if (old_flags & EGSY__V_DEF)\n \t      {\n-\t\tstruct vms_esdf *esdf = (struct vms_esdf *)vms_rec;\n-\t\tlong psindx;\n+\t\tstruct vms_esdf *esdf = (struct vms_esdf *) vms_rec;\n \n \t\tentry->value = bfd_getl64 (esdf->value);\n \t\tif (PRIV (sections) == NULL)\n@@ -1354,7 +1358,9 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \t\t/* PR 21813: Check for an out of range index.  */\n \t\tif (psindx < 0 || psindx >= (int) PRIV (section_count))\n \t\t  {\n-\t\t    _bfd_error_handler (_(\"corrupt EGSD record: its psindx field is too big (%#lx)\"),\n+\t\t  bad_psindx:\n+\t\t    _bfd_error_handler (_(\"corrupt EGSD record: its psindx \"\n+\t\t\t\t\t  \"field is too big (%#lx)\"),\n \t\t\t\t\tpsindx);\n \t\t    bfd_set_error (bfd_error_bad_value);\n \t\t    return FALSE;\n@@ -1367,14 +1373,9 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \n \t\t    entry->code_value = bfd_getl64 (esdf->code_address);\n \t\t    psindx = bfd_getl32 (esdf->ca_psindx);\n-\t\t/* PR 21813: Check for an out of range index.  */\n+\t\t    /* PR 21813: Check for an out of range index.  */\n \t\t    if (psindx < 0 || psindx >= (int) PRIV (section_count))\n-\t\t      {\n-\t\t\t_bfd_error_handler (_(\"corrupt EGSD record: its psindx field is too big (%#lx)\"),\n-\t\t\t\t\t    psindx);\n-\t\t\tbfd_set_error (bfd_error_bad_value);\n-\t\t\treturn FALSE;\n-\t\t      }\n+\t\t      goto bad_psindx;\n \t\t    entry->code_section = PRIV (sections)[psindx];\n \t\t  }\n \t      }\n@@ -1391,11 +1392,7 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \t    old_flags = bfd_getl16 (egst->header.flags);\n \n \t    if (nameoff >= gsd_size)\n-\t      {\n-\t\t_bfd_error_handler (_(\"ECSD__C_SYMG record is too small\"));\n-\t\tbfd_set_error (bfd_error_bad_value);\n-\t\treturn FALSE;\n-\t      }\n+\t      goto too_small;\n \t    entry = add_symbol (abfd, &egst->namlng, gsd_size - nameoff);\n \t    if (entry == NULL)\n \t      return FALSE;\n@@ -1408,19 +1405,12 @@ _bfd_vms_slurp_egsd (bfd *abfd)\n \n \t    if (old_flags & EGSY__V_REL)\n \t      {\n-\t\tlong psindx;\n-\n \t\tif (PRIV (sections) == NULL)\n \t\t  return FALSE;\n \t\tpsindx = bfd_getl32 (egst->psindx);\n \t\t/* PR 21813: Check for an out of range index.  */\n \t\tif (psindx < 0 || psindx >= (int) PRIV (section_count))\n-\t\t  {\n-\t\t    _bfd_error_handler (_(\"corrupt EGSD record: its psindx field is too big (%#lx)\"),\n-\t\t\t\t\tpsindx);\n-\t\t    bfd_set_error (bfd_error_bad_value);\n-\t\t    return FALSE;\n-\t\t  }\n+\t\t  goto bad_psindx;\n \t\tentry->section = PRIV (sections)[psindx];\n \t      }\n \t    else"
    }
  ]
}