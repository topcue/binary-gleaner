{
  "sha": "d3a071228e8f7cf9da017f2d0d6c28468a652795",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDNhMDcxMjI4ZThmN2NmOWRhMDE3ZjJkMGQ2YzI4NDY4YTY1Mjc5NQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-10-13T16:01:19Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-10-13T16:01:19Z"
    },
    "message": "gdb: don't pass TARGET_WNOHANG to targets that can't async (PR 26642)\n\nDebugging with \"maintenance set target-async off\" on Linux has been\nbroken since 5b6d1e4fa4f (\"Multi-target support\").\n\nThe issue is easy to reproduce:\n\n    $ ./gdb -q --data-directory=data-directory -nx ./test\n    Reading symbols from ./test...\n    (gdb) maintenance set target-async off\n    (gdb) start\n    Temporary breakpoint 1 at 0x1151: file test.c, line 5.\n    Starting program: /home/simark/build/binutils-gdb/gdb/test\n\n... and it hangs there.\n\nThe difference between pre-5b6d1e4fa4f and 5b6d1e4fa4f is that\nfetch_inferior_event now calls target_wait with TARGET_WNOHANG for\nnon-async-capable targets, whereas it didn't before.\n\nFor non-async-capable targets, this is how it's expected to work when\nresuming execution:\n\n1. we call resume\n2. the infrun async handler is marked in prepare_to_wait, to immediately\n   wake up the event loop when we get back to it\n3. fetch_inferior_event calls the target's wait method without\n   TARGET_WNOHANG, effectively blocking until the target has something\n   to report\n\nHowever, since we call the target's wait method with TARGET_WNOHANG,\nthis happens:\n\n1. we call resume\n2. the infrun async handler is marked in prepare_to_wait, to immediately\n   wake up the event loop when we get back to it\n3. fetch_inferior_event calls the target's wait method with\n   TARGET_WNOHANG, the target has nothing to report yet\n4. we go back to blocking on the event loop\n5. SIGCHLD finally arrives, but the event loop is not woken up, because\n   we are not in async mode.  Normally, we should have been stuck in\n   waitpid the SIGCHLD would have unblocked us.\n\nWe end up in this situation because these two necessary conditions are\nmet:\n\n1. GDB uses the TARGET_WNOHANG option with a target that can't do async.\n   I don't think this makes sense.  I mean, it's technically possible,\n   the doc for TARGET_WNOHANG is:\n\n  /* Return immediately if there's no event already queued.  If this\n     options is not requested, target_wait blocks waiting for an\n     event.  */\n  TARGET_WNOHANG = 1,\n\n   ... which isn't in itself necessarily incompatible with synchronous\n   targets.  It could be possible for a target to support non-blocking\n   polls, while not having a way to asynchronously wake up the event\n   loop, which is also necessary to support async.  But as of today,\n   we don't expect GDB and sync targets to work this way.\n\n2. The linux-nat target, even in the mode where it emulates a\n   synchronous target (with \"maintenance set target-async off\") respects\n   TARGET_WNOHANG.  Other non-async targets, such as windows_nat_target,\n   simply don't check / support TARGET_WNOHANG, so their wait method is\n   always blocking.\n\nFix the first issue by avoiding using TARGET_WNOHANG on non-async\ntargets, in do_target_wait_1.  Add an assert in target_wait to verify it\ndoesn't happen.\n\nThe new test gdb.base/maint-target-async-off.exp is a simple test that\njust tries running to main and then to the end of the program, with\n\"maintenance set target-async off\".\n\ngdb/ChangeLog:\n\n\tPR gdb/26642\n\t* infrun.c (do_target_wait_1): Clear TARGET_WNOHANG if the\n\ttarget can't do async.\n\t* target.c (target_wait): Assert that we don't pass\n\tTARGET_WNOHANG to a target that can't async.\n\ngdb/testsuite/ChangeLog:\n\n\tPR gdb/26642\n\t* gdb.base/maint-target-async-off.c: New test.\n\t* gdb.base/maint-target-async-off.exp: New test.\n\nChange-Id: I69ad3a14598863d21338a8c4e78700a58ce7ad86",
    "tree": {
      "sha": "34b01cde0d8577fed1503dd76cfb772b92de66e7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/34b01cde0d8577fed1503dd76cfb772b92de66e7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d3a071228e8f7cf9da017f2d0d6c28468a652795",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3a071228e8f7cf9da017f2d0d6c28468a652795",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d3a071228e8f7cf9da017f2d0d6c28468a652795",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3a071228e8f7cf9da017f2d0d6c28468a652795/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b07993f695bdca0153ee7b9123be9348f6aad4a6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b07993f695bdca0153ee7b9123be9348f6aad4a6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b07993f695bdca0153ee7b9123be9348f6aad4a6"
    }
  ],
  "stats": {
    "total": 89,
    "additions": 88,
    "deletions": 1
  },
  "files": [
    {
      "sha": "954eaa35d4df44c501c569e03e62d4c3fb96a48a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d3a071228e8f7cf9da017f2d0d6c28468a652795",
      "patch": "@@ -1,3 +1,11 @@\n+2020-10-13  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\tPR gdb/26642\n+\t* infrun.c (do_target_wait_1): Clear TARGET_WNOHANG if the\n+\ttarget can't do async.\n+\t* target.c (target_wait): Assert that we don't pass\n+\tTARGET_WNOHANG to a target that can't async.\n+\n 2020-10-13  Kamil Rytarowski  <n54@gmx.com>\n \n \t* Makefile.in (ALL_64_TARGET_OBS, ALL_TARGET_OBS)"
    },
    {
      "sha": "8ae39a2877b3152b10c65437833884fb631c4248",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=d3a071228e8f7cf9da017f2d0d6c28468a652795",
      "patch": "@@ -3533,6 +3533,11 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n \n   /* But if we don't find one, we'll have to wait.  */\n \n+  /* We can't ask a non-async target to do a non-blocking wait, so this will be\n+     a blocking wait.  */\n+  if (!target_can_async_p ())\n+    options &= ~TARGET_WNOHANG;\n+\n   if (deprecated_target_wait_hook)\n     event_ptid = deprecated_target_wait_hook (ptid, status, options);\n   else"
    },
    {
      "sha": "a111ea3c333661da5fd312eaa321307a97ee7ccf",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 6,
      "deletions": 1,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=d3a071228e8f7cf9da017f2d0d6c28468a652795",
      "patch": "@@ -1992,7 +1992,12 @@ ptid_t\n target_wait (ptid_t ptid, struct target_waitstatus *status,\n \t     target_wait_flags options)\n {\n-  return current_top_target ()->wait (ptid, status, options);\n+  target_ops *target = current_top_target ();\n+\n+  if (!target->can_async_p ())\n+    gdb_assert ((options & TARGET_WNOHANG) == 0);\n+\n+  return target->wait (ptid, status, options);\n }\n \n /* See target.h.  */"
    },
    {
      "sha": "5a04e4fd70e2cea1ef8fecb1a06df9fc5493bd20",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=d3a071228e8f7cf9da017f2d0d6c28468a652795",
      "patch": "@@ -1,3 +1,9 @@\n+2020-10-13  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\tPR gdb/26642\n+\t* gdb.base/maint-target-async-off.c: New test.\n+\t* gdb.base/maint-target-async-off.exp: New test.\n+\n 2020-10-13  Alan Modra  <amodra@gmail.com>\n \n \t* gdb.arch/powerpc-altivec.s,"
    },
    {
      "sha": "9d7b2f1a4c28b1c5298708fddf4c8c8ed2f11675",
      "filename": "gdb/testsuite/gdb.base/maint-target-async-off.c",
      "status": "added",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/testsuite/gdb.base/maint-target-async-off.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/testsuite/gdb.base/maint-target-async-off.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/maint-target-async-off.c?ref=d3a071228e8f7cf9da017f2d0d6c28468a652795",
      "patch": "@@ -0,0 +1,22 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2020 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"
    },
    {
      "sha": "0b2f4a3a9c527118b6a41c41add6ee17f7005c72",
      "filename": "gdb/testsuite/gdb.base/maint-target-async-off.exp",
      "status": "added",
      "additions": 41,
      "deletions": 0,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/testsuite/gdb.base/maint-target-async-off.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3a071228e8f7cf9da017f2d0d6c28468a652795/gdb/testsuite/gdb.base/maint-target-async-off.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/maint-target-async-off.exp?ref=d3a071228e8f7cf9da017f2d0d6c28468a652795",
      "patch": "@@ -0,0 +1,41 @@\n+# Copyright 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Verify that debugging with \"maintenance target-async off\" works somewhat.  At\n+# least running to main and to the end of the program.\n+\n+standard_testfile\n+\n+save_vars { GDBFLAGS } {\n+    # Enable target-async off this way, because with board\n+    # native-extended-gdbserver, the remote target is already open when\n+    # returning from prepare_for_testing, and that would be too late to toggle\n+    # it.\n+    append GDBFLAGS { -ex \"maintenance set target-async off\" }\n+\n+    if { [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}] } {\n+\treturn\n+    }\n+}\n+\n+# Make sure our command-line flag worked.\n+gdb_test \"maintenance show target-async\" \"Controlling the inferior in asynchronous mode is off\\\\.\"\n+\n+if { ![runto_main] } {\n+    fail \"can't run to main\"\n+    return\n+}\n+\n+gdb_continue_to_end"
    }
  ]
}