{
  "sha": "e0b317de31ab0e99ef8d14e9f751ae7e7d16abde",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTBiMzE3ZGUzMWFiMGU5OWVmOGQxNGU5Zjc1MWFlN2U3ZDE2YWJkZQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-26T02:32:42Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-02-26T02:34:54Z"
    },
    "message": "rx: memory allocation without checking for NULL return\n\n\t* elf32-rx.c (rx_elf_relocate_section): Use bfd_malloc rather than\n\tmalloc.  Check for NULL return from bfd_malloc.\n\t(rx_table_find, rx_table_map): Likewise.\n\t(rx_set_section_contents): Check bfd_alloc return.\n\t(rx_dump_symtab): Don't alloc internal_syms or external_syms.",
    "tree": {
      "sha": "ac70fa408b84ae4b2b88ef59b08cd7ef0e9b74c1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ac70fa408b84ae4b2b88ef59b08cd7ef0e9b74c1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e0b317de31ab0e99ef8d14e9f751ae7e7d16abde",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e0b317de31ab0e99ef8d14e9f751ae7e7d16abde",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e0b317de31ab0e99ef8d14e9f751ae7e7d16abde",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e0b317de31ab0e99ef8d14e9f751ae7e7d16abde/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "da3ec71fd49cb138d597870262a00a82578e96d0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/da3ec71fd49cb138d597870262a00a82578e96d0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/da3ec71fd49cb138d597870262a00a82578e96d0"
    }
  ],
  "stats": {
    "total": 62,
    "additions": 39,
    "deletions": 23
  },
  "files": [
    {
      "sha": "3b69b8065608d341c90924d1a79385dd6afdcd86",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e0b317de31ab0e99ef8d14e9f751ae7e7d16abde/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e0b317de31ab0e99ef8d14e9f751ae7e7d16abde/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=e0b317de31ab0e99ef8d14e9f751ae7e7d16abde",
      "patch": "@@ -1,3 +1,11 @@\n+2020-02-26  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf32-rx.c (rx_elf_relocate_section): Use bfd_malloc rather than\n+\tmalloc.  Check for NULL return from bfd_malloc.\n+\t(rx_table_find, rx_table_map): Likewise.\n+\t(rx_set_section_contents): Check bfd_alloc return.\n+\t(rx_dump_symtab): Don't alloc internal_syms or external_syms.\n+\n 2020-02-26  Alan Modra  <amodra@gmail.com>\n \n \t* aoutx.h: Indent labels correctly.  Format error strings."
    },
    {
      "sha": "89b7ed50954dc2a8081edbae8819f03909193fe9",
      "filename": "bfd/elf32-rx.c",
      "status": "modified",
      "additions": 31,
      "deletions": 23,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e0b317de31ab0e99ef8d14e9f751ae7e7d16abde/bfd/elf32-rx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e0b317de31ab0e99ef8d14e9f751ae7e7d16abde/bfd/elf32-rx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rx.c?ref=e0b317de31ab0e99ef8d14e9f751ae7e7d16abde",
      "patch": "@@ -576,7 +576,9 @@ rx_elf_relocate_section\n \n \t      /* We have already done error checking in rx_table_find().  */\n \n-\t      buf = (char *) malloc (13 + strlen (name + 20));\n+\t      buf = (char *) bfd_malloc (13 + strlen (name + 20));\n+\t      if (buf == NULL)\n+\t\treturn FALSE;\n \n \t      sprintf (buf, \"$tablestart$%s\", name + 20);\n \t      table_start_cache = get_symbol_value (buf,\n@@ -618,7 +620,10 @@ rx_elf_relocate_section\n \t      idx = (int) (entry_vma - table_start_cache) / 4;\n \n \t      /* This will look like $tableentry$<N>$<name> */\n-\t      buf = (char *) malloc (12 + 20 + strlen (name + 20));\n+\t      buf = (char *) bfd_malloc (12 + 20 + strlen (name + 20));\n+\t      if (buf == NULL)\n+\t\treturn FALSE;\n+\n \t      sprintf (buf, \"$tableentry$%d$%s\", idx, name + 20);\n \n \t      h = (struct elf_link_hash_entry *) bfd_link_hash_lookup (info->hash, buf, FALSE, FALSE, TRUE);\n@@ -3335,26 +3340,14 @@ rx_dump_symtab (bfd * abfd, void * internal_syms, void * external_syms)\n   Elf_Internal_Sym * isymend;\n   Elf_Internal_Sym * isym;\n   Elf_Internal_Shdr * symtab_hdr;\n-  bfd_boolean free_internal = FALSE, free_external = FALSE;\n   char * st_info_str;\n   char * st_info_stb_str;\n   char * st_other_str;\n   char * st_shndx_str;\n \n-  if (! internal_syms)\n-    {\n-      internal_syms = bfd_malloc (1000);\n-      free_internal = 1;\n-    }\n-  if (! external_syms)\n-    {\n-      external_syms = bfd_malloc (1000);\n-      free_external = 1;\n-    }\n-\n   symtab_hdr = &elf_tdata (abfd)->symtab_hdr;\n   locsymcount = symtab_hdr->sh_size / get_elf_backend_data (abfd)->s->sizeof_sym;\n-  if (free_internal)\n+  if (!internal_syms)\n     isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,\n \t\t\t\t    symtab_hdr->sh_info, 0,\n \t\t\t\t    internal_syms, external_syms, NULL);\n@@ -3406,10 +3399,6 @@ rx_dump_symtab (bfd * abfd, void * internal_syms, void * external_syms)\n \t      isym->st_other, st_other_str,\n \t      isym->st_shndx, st_shndx_str);\n     }\n-  if (free_internal)\n-    free (internal_syms);\n-  if (free_external)\n-    free (external_syms);\n }\n \n char *\n@@ -3618,6 +3607,8 @@ rx_set_section_contents (bfd *\t       abfd,\n       char * cloc = (char *) location;\n \n       swapped_data = (char *) bfd_alloc (abfd, count);\n+      if (swapped_data == NULL)\n+\treturn FALSE;\n \n       for (i = 0; i < count; i += 4)\n \t{\n@@ -3782,7 +3773,9 @@ rx_table_find (struct bfd_hash_entry *vent, void *vinfo)\n      find all the related symbols and mark their sections as SEC_KEEP\n      so we don't garbage collect them.  */\n \n-  buf = (char *) malloc (12 + 10 + strlen (tname));\n+  buf = (char *) bfd_malloc (12 + 10 + strlen (tname));\n+  if (buf == NULL)\n+    return FALSE;\n \n   sprintf (buf, \"$tableend$%s\", tname);\n   h = bfd_link_hash_lookup (info->info->hash, buf, FALSE, FALSE, TRUE);\n@@ -3911,7 +3904,9 @@ rx_table_map (struct bfd_hash_entry *vent, void *vinfo)\n \t\t+ ent->u.def.section->output_section->vma\n \t\t+ ent->u.def.section->output_offset);\n \n-  buf = (char *) malloc (12 + 10 + strlen (tname));\n+  buf = (char *) bfd_malloc (12 + 10 + strlen (tname));\n+  if (buf == NULL)\n+    return FALSE;\n \n   sprintf (buf, \"$tableend$%s\", tname);\n   end_addr = get_symbol_value_maybe (buf, info->info);\n@@ -3931,8 +3926,21 @@ rx_table_map (struct bfd_hash_entry *vent, void *vinfo)\n \n   info->table_start = start_addr;\n   info->table_size = (int) (end_addr - start_addr) / 4;\n-  info->table_handlers = (bfd_vma *) malloc (info->table_size * sizeof (bfd_vma));\n-  info->table_entries = (struct bfd_link_hash_entry **) malloc (info->table_size * sizeof (struct bfd_link_hash_entry));\n+  info->table_handlers = (bfd_vma *)\n+    bfd_malloc (info->table_size * sizeof (bfd_vma));\n+  if (info->table_handlers == NULL)\n+    {\n+      free (buf);\n+      return FALSE;\n+    }\n+  info->table_entries = (struct bfd_link_hash_entry **)\n+    bfd_malloc (info->table_size * sizeof (struct bfd_link_hash_entry));\n+  if (info->table_entries == NULL)\n+    {\n+      free (info->table_handlers);\n+      free (buf);\n+      return FALSE;\n+    }\n \n   for (idx = 0; idx < (int) (end_addr - start_addr) / 4; idx ++)\n     {"
    }
  ]
}