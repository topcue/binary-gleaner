{
  "sha": "0c929e83c1fdb29e553021b1d03565862accfd2d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGM5MjllODNjMWZkYjI5ZTU1MzAyMWIxZDAzNTY1ODYyYWNjZmQyZA==",
  "commit": {
    "author": {
      "name": "Cl\u00e9ment Chigot",
      "email": "clement.chigot@atos.net",
      "date": "2021-03-11T10:08:18Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-12T02:39:21Z"
    },
    "message": "bfd: move xcoff64_ppc_relocate_section after the HOWTO table\n\nThis will be needed for later commits, as xcoff64_ppc_relocate_section\nwill use the HOWTO table unlike now.\n\n\t* coff64-rs6000.c (xcoff64_ppc_relocate_section): Move.",
    "tree": {
      "sha": "6fab5abcfbde1b952d9fed6f4f4ac0292721c835",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6fab5abcfbde1b952d9fed6f4f4ac0292721c835"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0c929e83c1fdb29e553021b1d03565862accfd2d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0c929e83c1fdb29e553021b1d03565862accfd2d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0c929e83c1fdb29e553021b1d03565862accfd2d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0c929e83c1fdb29e553021b1d03565862accfd2d/comments",
  "author": {
    "login": "Helflym",
    "id": 23002587,
    "node_id": "MDQ6VXNlcjIzMDAyNTg3",
    "avatar_url": "https://avatars.githubusercontent.com/u/23002587?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/Helflym",
    "html_url": "https://github.com/Helflym",
    "followers_url": "https://api.github.com/users/Helflym/followers",
    "following_url": "https://api.github.com/users/Helflym/following{/other_user}",
    "gists_url": "https://api.github.com/users/Helflym/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/Helflym/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/Helflym/subscriptions",
    "organizations_url": "https://api.github.com/users/Helflym/orgs",
    "repos_url": "https://api.github.com/users/Helflym/repos",
    "events_url": "https://api.github.com/users/Helflym/events{/privacy}",
    "received_events_url": "https://api.github.com/users/Helflym/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6d4d932867fa8b3c685b3a358bf81f7f6c6ea7d6"
    }
  ],
  "stats": {
    "total": 382,
    "additions": 194,
    "deletions": 188
  },
  "files": [
    {
      "sha": "9c301d0f19f4ac2bf1733eceb1b81177fa5ba20c",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0c929e83c1fdb29e553021b1d03565862accfd2d/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0c929e83c1fdb29e553021b1d03565862accfd2d/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=0c929e83c1fdb29e553021b1d03565862accfd2d",
      "patch": "@@ -1,3 +1,7 @@\n+2021-03-12  Cl\u00e9ment Chigot  <clement.chigot@atos.net>\n+\n+\t* coff64-rs6000.c (xcoff64_ppc_relocate_section): Move.\n+\n 2021-03-12  Cl\u00e9ment Chigot  <clement.chigot@atos.net>\n \n \t* coff64-rs6000.c (xcoff64_write_object_contents): Remove."
    },
    {
      "sha": "3f74130da0ddd03a1323fc3936c078d372a5f93c",
      "filename": "bfd/coff64-rs6000.c",
      "status": "modified",
      "additions": 190,
      "deletions": 188,
      "changes": 378,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0c929e83c1fdb29e553021b1d03565862accfd2d/bfd/coff64-rs6000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0c929e83c1fdb29e553021b1d03565862accfd2d/bfd/coff64-rs6000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff64-rs6000.c?ref=0c929e83c1fdb29e553021b1d03565862accfd2d",
      "patch": "@@ -814,194 +814,6 @@ xcoff64_reloc_type_br (bfd *input_bfd,\n   return TRUE;\n }\n \n-/* This is the relocation function for the PowerPC64.\n-   See xcoff_ppc_relocation_section for more information. */\n-\n-bfd_boolean\n-xcoff64_ppc_relocate_section (bfd *output_bfd,\n-\t\t\t      struct bfd_link_info *info,\n-\t\t\t      bfd *input_bfd,\n-\t\t\t      asection *input_section,\n-\t\t\t      bfd_byte *contents,\n-\t\t\t      struct internal_reloc *relocs,\n-\t\t\t      struct internal_syment *syms,\n-\t\t\t      asection **sections)\n-{\n-  struct internal_reloc *rel;\n-  struct internal_reloc *relend;\n-\n-  rel = relocs;\n-  relend = rel + input_section->reloc_count;\n-  for (; rel < relend; rel++)\n-    {\n-      long symndx;\n-      struct xcoff_link_hash_entry *h;\n-      struct internal_syment *sym;\n-      bfd_vma addend;\n-      bfd_vma val;\n-      struct reloc_howto_struct howto;\n-      bfd_vma relocation;\n-      bfd_vma value_to_relocate;\n-      bfd_vma address;\n-      bfd_byte *location;\n-\n-      /* Relocation type R_REF is a special relocation type which is\n-\t merely used to prevent garbage collection from occurring for\n-\t the csect including the symbol which it references.  */\n-      if (rel->r_type == R_REF)\n-\tcontinue;\n-\n-      /* howto */\n-      howto.type = rel->r_type;\n-      howto.rightshift = 0;\n-      howto.bitsize = (rel->r_size & 0x3f) + 1;\n-      howto.size = howto.bitsize > 16 ? (howto.bitsize > 32 ? 4 : 2) : 1;\n-      howto.pc_relative = FALSE;\n-      howto.bitpos = 0;\n-      howto.complain_on_overflow = (rel->r_size & 0x80\n-\t\t\t\t    ? complain_overflow_signed\n-\t\t\t\t    : complain_overflow_bitfield);\n-      howto.special_function = NULL;\n-      howto.name = \"internal\";\n-      howto.partial_inplace = TRUE;\n-      howto.src_mask = howto.dst_mask = N_ONES (howto.bitsize);\n-      howto.pcrel_offset = FALSE;\n-\n-      /* symbol */\n-      val = 0;\n-      addend = 0;\n-      h = NULL;\n-      sym = NULL;\n-      symndx = rel->r_symndx;\n-\n-      if (-1 != symndx)\n-\t{\n-\t  asection *sec;\n-\n-\t  h = obj_xcoff_sym_hashes (input_bfd)[symndx];\n-\t  sym = syms + symndx;\n-\t  addend = - sym->n_value;\n-\n-\t  if (NULL == h)\n-\t    {\n-\t      sec = sections[symndx];\n-\t      /* Hack to make sure we use the right TOC anchor value\n-\t\t if this reloc is against the TOC anchor.  */\n-\t      if (sec->name[3] == '0'\n-\t\t  && strcmp (sec->name, \".tc0\") == 0)\n-\t\tval = xcoff_data (output_bfd)->toc;\n-\t      else\n-\t\tval = (sec->output_section->vma\n-\t\t       + sec->output_offset\n-\t\t       + sym->n_value\n-\t\t       - sec->vma);\n-\t    }\n-\t  else\n-\t    {\n-\t      if (info->unresolved_syms_in_objects != RM_IGNORE\n-\t\t  && (h->flags & XCOFF_WAS_UNDEFINED) != 0)\n-                info->callbacks->undefined_symbol\n-\t\t  (info, h->root.root.string, input_bfd, input_section,\n-\t\t   rel->r_vaddr - input_section->vma,\n-\t\t   info->unresolved_syms_in_objects == RM_DIAGNOSE\n-\t\t   && !info->warn_unresolved_syms);\n-\n-\t      if (h->root.type == bfd_link_hash_defined\n-\t\t  || h->root.type == bfd_link_hash_defweak)\n-\t\t{\n-\t\t  sec = h->root.u.def.section;\n-\t\t  val = (h->root.u.def.value\n-\t\t\t + sec->output_section->vma\n-\t\t\t + sec->output_offset);\n-\t\t}\n-\t      else if (h->root.type == bfd_link_hash_common)\n-\t\t{\n-\t\t  sec = h->root.u.c.p->section;\n-\t\t  val = (sec->output_section->vma\n-\t\t\t + sec->output_offset);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  BFD_ASSERT (bfd_link_relocatable (info)\n-\t\t\t      || (h->flags & XCOFF_DEF_DYNAMIC) != 0\n-\t\t\t      || (h->flags & XCOFF_IMPORT) != 0);\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (rel->r_type >= XCOFF_MAX_CALCULATE_RELOCATION\n-\t  || !((*xcoff64_calculate_relocation[rel->r_type])\n-\t      (input_bfd, input_section, output_bfd, rel, sym, &howto, val,\n-\t       addend, &relocation, contents)))\n-\treturn FALSE;\n-\n-      /* address */\n-      address = rel->r_vaddr - input_section->vma;\n-      location = contents + address;\n-\n-      if (address > input_section->size)\n-\tabort ();\n-\n-      /* Get the value we are going to relocate.  */\n-      if (1 == howto.size)\n-\tvalue_to_relocate = bfd_get_16 (input_bfd, location);\n-      else if (2 == howto.size)\n-\tvalue_to_relocate = bfd_get_32 (input_bfd, location);\n-      else\n-\tvalue_to_relocate = bfd_get_64 (input_bfd, location);\n-\n-      /* overflow.\n-\n-\t FIXME: We may drop bits during the addition\n-\t which we don't check for.  We must either check at every single\n-\t operation, which would be tedious, or we must do the computations\n-\t in a type larger than bfd_vma, which would be inefficient.  */\n-\n-      if (((*xcoff_complain_overflow[howto.complain_on_overflow])\n-\t   (input_bfd, value_to_relocate, relocation, &howto)))\n-\t{\n-\t  const char *name;\n-\t  char buf[SYMNMLEN + 1];\n-\t  char reloc_type_name[10];\n-\n-\t  if (symndx == -1)\n-\t    {\n-\t      name = \"*ABS*\";\n-\t    }\n-\t  else if (h != NULL)\n-\t    {\n-\t      name = NULL;\n-\t    }\n-\t  else\n-\t    {\n-\t      name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);\n-\t      if (name == NULL)\n-\t\tname = \"UNKNOWN\";\n-\t    }\n-\t  sprintf (reloc_type_name, \"0x%02x\", rel->r_type);\n-\n-\t  (*info->callbacks->reloc_overflow)\n-\t    (info, (h ? &h->root : NULL), name, reloc_type_name,\n-\t     (bfd_vma) 0, input_bfd, input_section,\n-\t     rel->r_vaddr - input_section->vma);\n-\t}\n-\n-      /* Add RELOCATION to the right bits of VALUE_TO_RELOCATE.  */\n-      value_to_relocate = ((value_to_relocate & ~howto.dst_mask)\n-\t\t\t   | (((value_to_relocate & howto.src_mask)\n-\t\t\t       + relocation) & howto.dst_mask));\n-\n-      /* Put the value back in the object file.  */\n-      if (1 == howto.size)\n-\tbfd_put_16 (input_bfd, value_to_relocate, location);\n-      else if (2 == howto.size)\n-\tbfd_put_32 (input_bfd, value_to_relocate, location);\n-      else\n-\tbfd_put_64 (input_bfd, value_to_relocate, location);\n-\n-    }\n-  return TRUE;\n-}\n \n \f\n /* The XCOFF reloc table.  Actually, XCOFF relocations specify the\n@@ -1496,6 +1308,196 @@ xcoff64_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,\n   return NULL;\n }\n \n+/* This is the relocation function for the PowerPC64.\n+   See xcoff_ppc_relocation_section for more information. */\n+\n+bfd_boolean\n+xcoff64_ppc_relocate_section (bfd *output_bfd,\n+\t\t\t      struct bfd_link_info *info,\n+\t\t\t      bfd *input_bfd,\n+\t\t\t      asection *input_section,\n+\t\t\t      bfd_byte *contents,\n+\t\t\t      struct internal_reloc *relocs,\n+\t\t\t      struct internal_syment *syms,\n+\t\t\t      asection **sections)\n+{\n+  struct internal_reloc *rel;\n+  struct internal_reloc *relend;\n+\n+  rel = relocs;\n+  relend = rel + input_section->reloc_count;\n+  for (; rel < relend; rel++)\n+    {\n+      long symndx;\n+      struct xcoff_link_hash_entry *h;\n+      struct internal_syment *sym;\n+      bfd_vma addend;\n+      bfd_vma val;\n+      struct reloc_howto_struct howto;\n+      bfd_vma relocation;\n+      bfd_vma value_to_relocate;\n+      bfd_vma address;\n+      bfd_byte *location;\n+\n+      /* Relocation type R_REF is a special relocation type which is\n+\t merely used to prevent garbage collection from occurring for\n+\t the csect including the symbol which it references.  */\n+      if (rel->r_type == R_REF)\n+\tcontinue;\n+\n+      /* howto */\n+      howto.type = rel->r_type;\n+      howto.rightshift = 0;\n+      howto.bitsize = (rel->r_size & 0x3f) + 1;\n+      howto.size = howto.bitsize > 16 ? (howto.bitsize > 32 ? 4 : 2) : 1;\n+      howto.pc_relative = FALSE;\n+      howto.bitpos = 0;\n+      howto.complain_on_overflow = (rel->r_size & 0x80\n+\t\t\t\t    ? complain_overflow_signed\n+\t\t\t\t    : complain_overflow_bitfield);\n+      howto.special_function = NULL;\n+      howto.name = \"internal\";\n+      howto.partial_inplace = TRUE;\n+      howto.src_mask = howto.dst_mask = N_ONES (howto.bitsize);\n+      howto.pcrel_offset = FALSE;\n+\n+      /* symbol */\n+      val = 0;\n+      addend = 0;\n+      h = NULL;\n+      sym = NULL;\n+      symndx = rel->r_symndx;\n+\n+      if (-1 != symndx)\n+\t{\n+\t  asection *sec;\n+\n+\t  h = obj_xcoff_sym_hashes (input_bfd)[symndx];\n+\t  sym = syms + symndx;\n+\t  addend = - sym->n_value;\n+\n+\t  if (NULL == h)\n+\t    {\n+\t      sec = sections[symndx];\n+\t      /* Hack to make sure we use the right TOC anchor value\n+\t\t if this reloc is against the TOC anchor.  */\n+\t      if (sec->name[3] == '0'\n+\t\t  && strcmp (sec->name, \".tc0\") == 0)\n+\t\tval = xcoff_data (output_bfd)->toc;\n+\t      else\n+\t\tval = (sec->output_section->vma\n+\t\t       + sec->output_offset\n+\t\t       + sym->n_value\n+\t\t       - sec->vma);\n+\t    }\n+\t  else\n+\t    {\n+\t      if (info->unresolved_syms_in_objects != RM_IGNORE\n+\t\t  && (h->flags & XCOFF_WAS_UNDEFINED) != 0)\n+                info->callbacks->undefined_symbol\n+\t\t  (info, h->root.root.string, input_bfd, input_section,\n+\t\t   rel->r_vaddr - input_section->vma,\n+\t\t   info->unresolved_syms_in_objects == RM_DIAGNOSE\n+\t\t   && !info->warn_unresolved_syms);\n+\n+\t      if (h->root.type == bfd_link_hash_defined\n+\t\t  || h->root.type == bfd_link_hash_defweak)\n+\t\t{\n+\t\t  sec = h->root.u.def.section;\n+\t\t  val = (h->root.u.def.value\n+\t\t\t + sec->output_section->vma\n+\t\t\t + sec->output_offset);\n+\t\t}\n+\t      else if (h->root.type == bfd_link_hash_common)\n+\t\t{\n+\t\t  sec = h->root.u.c.p->section;\n+\t\t  val = (sec->output_section->vma\n+\t\t\t + sec->output_offset);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  BFD_ASSERT (bfd_link_relocatable (info)\n+\t\t\t      || (h->flags & XCOFF_DEF_DYNAMIC) != 0\n+\t\t\t      || (h->flags & XCOFF_IMPORT) != 0);\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (rel->r_type >= XCOFF_MAX_CALCULATE_RELOCATION\n+\t  || !((*xcoff64_calculate_relocation[rel->r_type])\n+\t      (input_bfd, input_section, output_bfd, rel, sym, &howto, val,\n+\t       addend, &relocation, contents)))\n+\treturn FALSE;\n+\n+      /* address */\n+      address = rel->r_vaddr - input_section->vma;\n+      location = contents + address;\n+\n+      if (address > input_section->size)\n+\tabort ();\n+\n+      /* Get the value we are going to relocate.  */\n+      if (1 == howto.size)\n+\tvalue_to_relocate = bfd_get_16 (input_bfd, location);\n+      else if (2 == howto.size)\n+\tvalue_to_relocate = bfd_get_32 (input_bfd, location);\n+      else\n+\tvalue_to_relocate = bfd_get_64 (input_bfd, location);\n+\n+      /* overflow.\n+\n+\t FIXME: We may drop bits during the addition\n+\t which we don't check for.  We must either check at every single\n+\t operation, which would be tedious, or we must do the computations\n+\t in a type larger than bfd_vma, which would be inefficient.  */\n+\n+      if (((*xcoff_complain_overflow[howto.complain_on_overflow])\n+\t   (input_bfd, value_to_relocate, relocation, &howto)))\n+\t{\n+\t  const char *name;\n+\t  char buf[SYMNMLEN + 1];\n+\t  char reloc_type_name[10];\n+\n+\t  if (symndx == -1)\n+\t    {\n+\t      name = \"*ABS*\";\n+\t    }\n+\t  else if (h != NULL)\n+\t    {\n+\t      name = NULL;\n+\t    }\n+\t  else\n+\t    {\n+\t      name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);\n+\t      if (name == NULL)\n+\t\tname = \"UNKNOWN\";\n+\t    }\n+\t  sprintf (reloc_type_name, \"0x%02x\", rel->r_type);\n+\n+\t  (*info->callbacks->reloc_overflow)\n+\t    (info, (h ? &h->root : NULL), name, reloc_type_name,\n+\t     (bfd_vma) 0, input_bfd, input_section,\n+\t     rel->r_vaddr - input_section->vma);\n+\t}\n+\n+      /* Add RELOCATION to the right bits of VALUE_TO_RELOCATE.  */\n+      value_to_relocate = ((value_to_relocate & ~howto.dst_mask)\n+\t\t\t   | (((value_to_relocate & howto.src_mask)\n+\t\t\t       + relocation) & howto.dst_mask));\n+\n+      /* Put the value back in the object file.  */\n+      if (1 == howto.size)\n+\tbfd_put_16 (input_bfd, value_to_relocate, location);\n+      else if (2 == howto.size)\n+\tbfd_put_32 (input_bfd, value_to_relocate, location);\n+      else\n+\tbfd_put_64 (input_bfd, value_to_relocate, location);\n+\n+    }\n+  return TRUE;\n+}\n+\n+\n /* PR 21786:  The PE/COFF standard does not require NUL termination for any of\n    the ASCII fields in the archive headers.  So in order to be able to extract\n    numerical values we provide our own versions of strtol and strtoll which"
    }
  ]
}