{
  "sha": "ac3d4064096ecd4b012e5db91b1530df5cb4a7cc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWMzZDQwNjQwOTZlY2Q0YjAxMmU1ZGI5MWIxNTMwZGY1Y2I0YTdjYw==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-11-06T17:19:02Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-11-06T17:19:02Z"
    },
    "message": "Split macro_buffer in two classes, fix Clang build\n\nGDB currently fails to build with (at least) Clang 10 and 11, due to:\n\n $ make\n   CXX    macroexp.o\n ../../src/gdb/macroexp.c:125:3: error: definition of implicit copy constructor for 'macro_buffer' is deprecated because it has a user-declared destructor [-Werror,-Wdeprecated-copy-dtor]\n   ~macro_buffer ()\n   ^\n\nNow, we could just add the copy constructor, like we already have a\ncopy assignment operator.  And like that assignment operator, we would\nassert that only shared buffers can be copied from.\n\nHowever, it is hard to see why only shared buffers need to be copied.\nI mean, it must be true, otherwise macro support would be broken,\nsince currently GDB is relying on the default implementation of the\ncopy constructor, which just copies the fields, which can't work\ncorrectly for the non-shared version.  Still, it's not easy to tell\nfrom the code that that is indeed correct, that there isn't some\ncorner case that would require copying a non-shared buffer.\n\nOr to put it simply - the tangling of shared and non-shared buffers in\nthe same macro_buffer struct makes this structure hard to understand.\n\nMy reaction was -- try splitting the macro_buffer class into two\nclasses, one for non-shared buffers, and another for shared buffers.\n\nComments and asserts like these:\n\n  ...\n      SRC must be a shared buffer; DEST must not be one.  */\n\n  static void\n  scan (struct macro_buffer *dest,\n        struct macro_buffer *src,\n        struct macro_name_list *no_loop,\n        const macro_scope &scope)\n   {\n    gdb_assert (src->shared);\n    gdb_assert (! dest->shared);\n\n... made me suspect it should be possible.  Then after the split it\nshould be easier to reimplement either of the classes if we want.\n\nSo I decided to try splitting the struct in two distinct types, and\nsee where that leads.  It turns out that there is really no good\nreason for a single struct, no code that wants to work with either\nshared or non-shared buffers.  It's always shared for input being\nparsed, and non-shared for output.\n\nThis commit is the result.  I named the new classes\nshared_macro_buffer and growable_macro_buffer.\n\nA future direction could be for example to make shared_macro_buffer\nwrap a string_view and growable_macro_buffer a std::string.  With that\nin mind, other than text/len, only the 'last_token' field is common to\nboth classes.  I didn't feel like creating a base class just for that\nsingle field.\n\nI constified shared_macro_buffer's 'text' field, which of course had\nsome knock-on effects, fixed in the patch.\n\nOn the original warning issued by Clang -- now it is clear that only\nthe shared version needs to be copied.  Since this class doesn't need\na user-declared destructor, the default implementations of the copy\nassign/ctor can be used, and Clang no longer warns.\n\nThe growable version doesn't need to be copied, so I disabled\ncopy/assign for it.\n\ngdb/ChangeLog:\n\n\t* macroexp.c (struct macro_buffer): Split in two classes.  Add\n\tuses adjusted.\n\t(struct shared_macro_buffer): New, factored out from struct\n\tmacro_buffer.\n\t(struct growable_macro_buffer): New, factored out from struct\n\tmacro_buffer.\n\t(set_token, get_comment, get_identifier, get_pp_number)\n\t(get_character_constant, get_string_literal, get_punctuator)\n\t(get_next_token_for_substitution): Constify parameters.\n\t(substitute_args): Constify locals.\n\nChange-Id: I5712e30e826d949715703b2e9172adf04e63b152",
    "tree": {
      "sha": "ad4c3513a96961ced982880a7148518aa4ce78b5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ad4c3513a96961ced982880a7148518aa4ce78b5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/ac3d4064096ecd4b012e5db91b1530df5cb4a7cc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ac3d4064096ecd4b012e5db91b1530df5cb4a7cc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/ac3d4064096ecd4b012e5db91b1530df5cb4a7cc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ac3d4064096ecd4b012e5db91b1530df5cb4a7cc/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2c72361c810f4b6223949363f635376e4311ac7a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2c72361c810f4b6223949363f635376e4311ac7a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2c72361c810f4b6223949363f635376e4311ac7a"
    }
  ],
  "stats": {
    "total": 284,
    "additions": 138,
    "deletions": 146
  },
  "files": [
    {
      "sha": "b846426f89e3e1b4d0e4d7aef3d408e6af649a51",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ac3d4064096ecd4b012e5db91b1530df5cb4a7cc/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ac3d4064096ecd4b012e5db91b1530df5cb4a7cc/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=ac3d4064096ecd4b012e5db91b1530df5cb4a7cc",
      "patch": "@@ -1,3 +1,16 @@\n+2020-11-06  Pedro Alves  <pedro@palves.net>\n+\n+\t* macroexp.c (struct macro_buffer): Split in two classes.  Add\n+\tuses adjusted.\n+\t(struct shared_macro_buffer): New, factored out from struct\n+\tmacro_buffer.\n+\t(struct growable_macro_buffer): New, factored out from struct\n+\tmacro_buffer.\n+\t(set_token, get_comment, get_identifier, get_pp_number)\n+\t(get_character_constant, get_string_literal, get_punctuator)\n+\t(get_next_token_for_substitution): Constify parameters.\n+\t(substitute_args): Constify locals.\n+\n 2020-11-05  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (read_cutu_die_from_dwo)"
    },
    {
      "sha": "9b15af3673592a2102d54e5ff2932111b80167ec",
      "filename": "gdb/macroexp.c",
      "status": "modified",
      "additions": 125,
      "deletions": 146,
      "changes": 271,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ac3d4064096ecd4b012e5db91b1530df5cb4a7cc/gdb/macroexp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ac3d4064096ecd4b012e5db91b1530df5cb4a7cc/gdb/macroexp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macroexp.c?ref=ac3d4064096ecd4b012e5db91b1530df5cb4a7cc",
      "patch": "@@ -26,37 +26,20 @@\n \n \n \f\n-/* A resizeable, substringable string type.  */\n \n+/* A string type that we can use to refer to substrings of other\n+   strings.  */\n \n-/* A string type that we can resize, quickly append to, and use to\n-   refer to substrings of other strings.  */\n-struct macro_buffer\n+struct shared_macro_buffer\n {\n-  /* An array of characters.  The first LEN bytes are the real text,\n-     but there are SIZE bytes allocated to the array.  If SIZE is\n-     zero, then this doesn't point to a malloc'ed block.  If SHARED is\n-     non-zero, then this buffer is actually a pointer into some larger\n-     string, and we shouldn't append characters to it, etc.  Because\n-     of sharing, we can't assume in general that the text is\n+  /* An array of characters.  This buffer is a pointer into some\n+     larger string and thus we can't assume in that the text is\n      null-terminated.  */\n-  char *text;\n+  const char *text;\n \n   /* The number of characters in the string.  */\n   int len;\n \n-  /* The number of characters allocated to the string.  If SHARED is\n-     non-zero, this is meaningless; in this case, we set it to zero so\n-     that any \"do we have room to append something?\" tests will fail,\n-     so we don't always have to check SHARED before using this field.  */\n-  int size;\n-\n-  /* Zero if TEXT can be safely realloc'ed (i.e., it's its own malloc\n-     block).  Non-zero if TEXT is actually pointing into the middle of\n-     some other block, or to a string literal, and we shouldn't\n-     reallocate it.  */\n-  bool shared;\n-\n   /* For detecting token splicing. \n \n      This is the index in TEXT of the first character of the token\n@@ -71,33 +54,15 @@ struct macro_buffer\n      is non-zero if it is an identifier token, zero otherwise.  */\n   int is_identifier = 0;\n \n-\n-  macro_buffer ()\n+  shared_macro_buffer ()\n     : text (NULL),\n-      len (0),\n-      size (0),\n-      shared (false)\n-  {\n-  }\n-\n-  /* Set the macro buffer to the empty string, guessing that its\n-     final contents will fit in N bytes.  (It'll get resized if it\n-     doesn't, so the guess doesn't have to be right.)  Allocate the\n-     initial storage with xmalloc.  */\n-  explicit macro_buffer (int n)\n-    : len (0),\n-      size (n),\n-      shared (false)\n+      len (0)\n   {\n-    if (n > 0)\n-      text = (char *) xmalloc (n);\n-    else\n-      text = NULL;\n   }\n \n   /* Set the macro buffer to refer to the LEN bytes at ADDR, as a\n      shared substring.  */\n-  macro_buffer (const char *addr, int len)\n+  shared_macro_buffer (const char *addr, int len)\n   {\n     set_shared (addr, len);\n   }\n@@ -106,45 +71,68 @@ struct macro_buffer\n      shared substring.  */\n   void set_shared (const char *addr, int len_)\n   {\n-    text = (char *) addr;\n+    text = addr;\n     len = len_;\n-    size = 0;\n-    shared = true;\n   }\n+};\n+\n+/* A string type that we can resize and quickly append to.  */\n+\n+struct growable_macro_buffer\n+{\n+  /* An array of characters.  The first LEN bytes are the real text,\n+     but there are SIZE bytes allocated to the array.  */\n+  char *text;\n+\n+  /* The number of characters in the string.  */\n+  int len;\n+\n+  /* The number of characters allocated to the string.  */\n+  int size;\n+\n+  /* For detecting token splicing.\n \n-  macro_buffer& operator= (const macro_buffer &src)\n+     This is the index in TEXT of the first character of the token\n+     that abuts the end of TEXT.  If TEXT contains no tokens, then we\n+     set this equal to LEN.  If TEXT ends in whitespace, then there is\n+     no token abutting the end of TEXT (it's just whitespace), and\n+     again, we set this equal to LEN.  We set this to -1 if we don't\n+     know the nature of TEXT.  */\n+  int last_token = -1;\n+\n+  /* Set the macro buffer to the empty string, guessing that its\n+     final contents will fit in N bytes.  (It'll get resized if it\n+     doesn't, so the guess doesn't have to be right.)  Allocate the\n+     initial storage with xmalloc.  */\n+  explicit growable_macro_buffer (int n)\n+    : len (0),\n+      size (n)\n   {\n-    gdb_assert (src.shared);\n-    gdb_assert (shared);\n-    set_shared (src.text, src.len);\n-    last_token = src.last_token;\n-    is_identifier = src.is_identifier;\n-    return *this;\n+    if (n > 0)\n+      text = (char *) xmalloc (n);\n+    else\n+      text = NULL;\n   }\n \n-  ~macro_buffer ()\n+  DISABLE_COPY_AND_ASSIGN (growable_macro_buffer);\n+\n+  ~growable_macro_buffer ()\n   {\n-    if (! shared && size)\n-      xfree (text);\n+    xfree (text);\n   }\n \n   /* Release the text of the buffer to the caller.  */\n   gdb::unique_xmalloc_ptr<char> release ()\n   {\n-    gdb_assert (! shared);\n     gdb_assert (size);\n     char *result = text;\n     text = NULL;\n     return gdb::unique_xmalloc_ptr<char> (result);\n   }\n \n-  /* Resize the buffer to be at least N bytes long.  Raise an error if\n-     the buffer shouldn't be resized.  */\n+  /* Resize the buffer to be at least N bytes long.  */\n   void resize_buffer (int n)\n   {\n-    /* We shouldn't be trying to resize shared strings.  */\n-    gdb_assert (! shared);\n-\n     if (size == 0)\n       size = n;\n     else\n@@ -212,7 +200,7 @@ macro_is_identifier_nondigit (int c)\n \n \n static void\n-set_token (struct macro_buffer *tok, char *start, char *end)\n+set_token (shared_macro_buffer *tok, const char *start, const char *end)\n {\n   tok->set_shared (start, end - start);\n   tok->last_token = 0;\n@@ -223,14 +211,14 @@ set_token (struct macro_buffer *tok, char *start, char *end)\n \n \n static int\n-get_comment (struct macro_buffer *tok, char *p, char *end)\n+get_comment (shared_macro_buffer *tok, const char *p, const char *end)\n {\n   if (p + 2 > end)\n     return 0;\n   else if (p[0] == '/'\n \t   && p[1] == '*')\n     {\n-      char *tok_start = p;\n+      const char *tok_start = p;\n \n       p += 2;\n \n@@ -249,7 +237,7 @@ get_comment (struct macro_buffer *tok, char *p, char *end)\n   else if (p[0] == '/'\n \t   && p[1] == '/')\n     {\n-      char *tok_start = p;\n+      const char *tok_start = p;\n \n       p += 2;\n       for (; p < end; p++)\n@@ -265,12 +253,12 @@ get_comment (struct macro_buffer *tok, char *p, char *end)\n \n \n static int\n-get_identifier (struct macro_buffer *tok, char *p, char *end)\n+get_identifier (shared_macro_buffer *tok, const char *p, const char *end)\n {\n   if (p < end\n       && macro_is_identifier_nondigit (*p))\n     {\n-      char *tok_start = p;\n+      const char *tok_start = p;\n \n       while (p < end\n \t     && (macro_is_identifier_nondigit (*p)\n@@ -287,15 +275,15 @@ get_identifier (struct macro_buffer *tok, char *p, char *end)\n \n \n static int\n-get_pp_number (struct macro_buffer *tok, char *p, char *end)\n+get_pp_number (shared_macro_buffer *tok, const char *p, const char *end)\n {\n   if (p < end\n       && (macro_is_digit (*p)\n \t  || (*p == '.'\n \t      && p + 2 <= end\n \t      && macro_is_digit (p[1]))))\n     {\n-      char *tok_start = p;\n+      const char *tok_start = p;\n \n       while (p < end)\n \t{\n@@ -326,7 +314,8 @@ get_pp_number (struct macro_buffer *tok, char *p, char *end)\n    Signal an error if it contains a malformed or incomplete character\n    constant.  */\n static int\n-get_character_constant (struct macro_buffer *tok, char *p, char *end)\n+get_character_constant (shared_macro_buffer *tok,\n+\t\t\tconst char *p, const char *end)\n {\n   /* ISO/IEC 9899:1999 (E)  Section 6.4.4.4  paragraph 1 \n      But of course, what really matters is that we handle it the same\n@@ -337,7 +326,7 @@ get_character_constant (struct macro_buffer *tok, char *p, char *end)\n \t  && (p[0] == 'L' || p[0] == 'u' || p[0] == 'U')\n \t  && p[1] == '\\''))\n     {\n-      char *tok_start = p;\n+      const char *tok_start = p;\n       int char_count = 0;\n \n       if (*p == '\\'')\n@@ -387,15 +376,15 @@ get_character_constant (struct macro_buffer *tok, char *p, char *end)\n    literal, and return 1.  Otherwise, return zero.  Signal an error if\n    it contains a malformed or incomplete string literal.  */\n static int\n-get_string_literal (struct macro_buffer *tok, char *p, char *end)\n+get_string_literal (shared_macro_buffer *tok, const char *p, const char *end)\n {\n   if ((p + 1 <= end\n        && *p == '\"')\n       || (p + 2 <= end\n \t  && (p[0] == 'L' || p[0] == 'u' || p[0] == 'U')\n \t  && p[1] == '\"'))\n     {\n-      char *tok_start = p;\n+      const char *tok_start = p;\n \n       if (*p == '\"')\n \tp++;\n@@ -437,7 +426,7 @@ get_string_literal (struct macro_buffer *tok, char *p, char *end)\n \n \n static int\n-get_punctuator (struct macro_buffer *tok, char *p, char *end)\n+get_punctuator (shared_macro_buffer *tok, const char *p, const char *end)\n {\n   /* Here, speed is much less important than correctness and clarity.  */\n \n@@ -493,18 +482,16 @@ get_punctuator (struct macro_buffer *tok, char *p, char *end)\n \n /* Peel the next preprocessor token off of SRC, and put it in TOK.\n    Mutate TOK to refer to the first token in SRC, and mutate SRC to\n-   refer to the text after that token.  SRC must be a shared buffer;\n-   the resulting TOK will be shared, pointing into the same string SRC\n-   does.  Initialize TOK's last_token field.  Return non-zero if we\n-   succeed, or 0 if we didn't find any more tokens in SRC.  */\n+   refer to the text after that token.  The resulting TOK will point\n+   into the same string SRC does.  Initialize TOK's last_token field.\n+   Return non-zero if we succeed, or 0 if we didn't find any more\n+   tokens in SRC.  */\n+\n static int\n-get_token (struct macro_buffer *tok,\n-\t   struct macro_buffer *src)\n+get_token (shared_macro_buffer *tok, shared_macro_buffer *src)\n {\n-  char *p = src->text;\n-  char *end = p + src->len;\n-\n-  gdb_assert (src->shared);\n+  const char *p = src->text;\n+  const char *end = p + src->len;\n \n   /* From the ISO C standard, ISO/IEC 9899:1999 (E), section 6.4:\n \n@@ -583,11 +570,11 @@ get_token (struct macro_buffer *tok,\n    fine to return with DEST set to \"x y\".  Similarly, \"<\" and \"<\" must\n    yield \"< <\", not \"<<\", etc.  */\n static void\n-append_tokens_without_splicing (struct macro_buffer *dest,\n-\t\t\t\tstruct macro_buffer *src)\n+append_tokens_without_splicing (growable_macro_buffer *dest,\n+                                shared_macro_buffer *src)\n {\n   int original_dest_len = dest->len;\n-  struct macro_buffer dest_tail, new_token;\n+  shared_macro_buffer dest_tail, new_token;\n \n   gdb_assert (src->last_token != -1);\n   gdb_assert (dest->last_token != -1);\n@@ -653,7 +640,7 @@ append_tokens_without_splicing (struct macro_buffer *dest,\n    stringify; it is LEN bytes long.  */\n \n static void\n-stringify (struct macro_buffer *dest, const char *arg, int len)\n+stringify (growable_macro_buffer *dest, const char *arg, int len)\n {\n   /* Trim initial whitespace from ARG.  */\n   while (len > 0 && macro_is_whitespace (*arg))\n@@ -702,7 +689,7 @@ gdb::unique_xmalloc_ptr<char>\n macro_stringify (const char *str)\n {\n   int len = strlen (str);\n-  struct macro_buffer buffer (len);\n+  growable_macro_buffer buffer (len);\n \n   stringify (&buffer, str, len);\n   buffer.appendc ('\\0');\n@@ -780,17 +767,17 @@ currently_rescanning (struct macro_name_list *list, const char *name)\n    following the invocation.  */\n \n static bool\n-gather_arguments (const char *name, struct macro_buffer *src, int nargs,\n-\t\t  std::vector<struct macro_buffer> *args_ptr)\n+gather_arguments (const char *name, shared_macro_buffer *src, int nargs,\n+\t\t  std::vector<shared_macro_buffer> *args_ptr)\n {\n-  struct macro_buffer tok;\n-  std::vector<struct macro_buffer> args;\n+  shared_macro_buffer tok;\n+  std::vector<shared_macro_buffer> args;\n \n   /* Does SRC start with an opening paren token?  Read from a copy of\n      SRC, so SRC itself is unaffected if we don't find an opening\n      paren.  */\n   {\n-    struct macro_buffer temp (src->text, src->len);\n+    shared_macro_buffer temp (src->text, src->len);\n \n     if (! get_token (&tok, &temp)\n \t|| tok.len != 1\n@@ -803,7 +790,7 @@ gather_arguments (const char *name, struct macro_buffer *src, int nargs,\n \n   for (;;)\n     {\n-      struct macro_buffer *arg;\n+      shared_macro_buffer *arg;\n       int depth;\n \n       /* Initialize the next argument.  */\n@@ -874,8 +861,8 @@ gather_arguments (const char *name, struct macro_buffer *src, int nargs,\n \n /* The `expand' and `substitute_args' functions both invoke `scan'\n    recursively, so we need a forward declaration somewhere.  */\n-static void scan (struct macro_buffer *dest,\n-\t\t  struct macro_buffer *src,\n+static void scan (growable_macro_buffer *dest,\n+\t\t  shared_macro_buffer *src,\n \t\t  struct macro_name_list *no_loop,\n \t\t  const macro_scope &scope);\n \n@@ -891,8 +878,8 @@ static void scan (struct macro_buffer *dest,\n    index.  If TOK is not an argument, return -1.  */\n \n static int\n-find_parameter (const struct macro_buffer *tok,\n-\t\tint is_varargs, const struct macro_buffer *va_arg_name,\n+find_parameter (const shared_macro_buffer *tok,\n+\t\tint is_varargs, const shared_macro_buffer *va_arg_name,\n \t\tint argc, const char * const *argv)\n {\n   int i;\n@@ -916,11 +903,11 @@ find_parameter (const struct macro_buffer *tok,\n    updates the passed-in state variables.  */\n \n static void\n-get_next_token_for_substitution (struct macro_buffer *replacement_list,\n-\t\t\t\t struct macro_buffer *token,\n-\t\t\t\t char **start,\n-\t\t\t\t struct macro_buffer *lookahead,\n-\t\t\t\t char **lookahead_start,\n+get_next_token_for_substitution (shared_macro_buffer *replacement_list,\n+\t\t\t\t shared_macro_buffer *token,\n+\t\t\t\t const char **start,\n+\t\t\t\t shared_macro_buffer *lookahead,\n+\t\t\t\t const char **lookahead_start,\n \t\t\t\t int *lookahead_valid,\n \t\t\t\t bool *keep_going)\n {\n@@ -952,27 +939,27 @@ get_next_token_for_substitution (struct macro_buffer *replacement_list,\n    NO_LOOP.  */\n \n static void\n-substitute_args (struct macro_buffer *dest,\n+substitute_args (growable_macro_buffer *dest,\n \t\t struct macro_definition *def,\n-\t\t int is_varargs, const struct macro_buffer *va_arg_name,\n-\t\t const std::vector<struct macro_buffer> &argv,\n+\t\t int is_varargs, const shared_macro_buffer *va_arg_name,\n+\t\t const std::vector<shared_macro_buffer> &argv,\n \t\t struct macro_name_list *no_loop,\n \t\t const macro_scope &scope)\n {\n   /* The token we are currently considering.  */\n-  struct macro_buffer tok;\n+  shared_macro_buffer tok;\n   /* The replacement list's pointer from just before TOK was lexed.  */\n-  char *original_rl_start;\n+  const char *original_rl_start;\n   /* We have a single lookahead token to handle token splicing.  */\n-  struct macro_buffer lookahead;\n+  shared_macro_buffer lookahead;\n   /* The lookahead token might not be valid.  */\n   int lookahead_valid;\n   /* The replacement list's pointer from just before LOOKAHEAD was\n      lexed.  */\n-  char *lookahead_rl_start;\n+  const char *lookahead_rl_start;\n \n   /* A macro buffer for the macro's replacement list.  */\n-  struct macro_buffer replacement_list (def->replacement,\n+  shared_macro_buffer replacement_list (def->replacement,\n \t\t\t\t\tstrlen (def->replacement));\n \n   gdb_assert (dest->len == 0);\n@@ -1190,7 +1177,7 @@ substitute_args (struct macro_buffer *dest,\n \t\t mutates its source, so we need to scan a new buffer\n \t\t referring to the argument's text, not the argument\n \t\t itself.  */\n-\t      struct macro_buffer arg_src (argv[arg].text, argv[arg].len);\n+\t      shared_macro_buffer arg_src (argv[arg].text, argv[arg].len);\n \t      scan (dest, &arg_src, no_loop, scope);\n \t      substituted = 1;\n \t    }\n@@ -1217,9 +1204,9 @@ substitute_args (struct macro_buffer *dest,\n    we don't expand it.)  If we return zero, leave SRC unchanged.  */\n static int\n expand (const char *id,\n-\tstruct macro_definition *def, \n-\tstruct macro_buffer *dest,\n-\tstruct macro_buffer *src,\n+\tstruct macro_definition *def,\n+\tgrowable_macro_buffer *dest,\n+\tshared_macro_buffer *src,\n \tstruct macro_name_list *no_loop,\n \tconst macro_scope &scope)\n {\n@@ -1236,15 +1223,15 @@ expand (const char *id,\n   /* What kind of macro are we expanding?  */\n   if (def->kind == macro_object_like)\n     {\n-      struct macro_buffer replacement_list (def->replacement,\n+      shared_macro_buffer replacement_list (def->replacement,\n \t\t\t\t\t    strlen (def->replacement));\n \n       scan (dest, &replacement_list, &new_no_loop, scope);\n       return 1;\n     }\n   else if (def->kind == macro_function_like)\n     {\n-      struct macro_buffer va_arg_name;\n+      shared_macro_buffer va_arg_name;\n       int is_varargs = 0;\n \n       if (def->argc >= 1)\n@@ -1272,7 +1259,7 @@ expand (const char *id,\n \t    }\n \t}\n \n-      std::vector<struct macro_buffer> argv;\n+      std::vector<shared_macro_buffer> argv;\n       /* If we couldn't find any argument list, then we don't expand\n \t this macro.  */\n       if (!gather_arguments (id, src, is_varargs ? def->argc : -1,\n@@ -1304,21 +1291,21 @@ expand (const char *id,\n \t splicing operator \"##\" don't get macro references expanded,\n \t so we can't really tell whether it's appropriate to macro-\n \t expand an argument until we see how it's being used.  */\n-      struct macro_buffer substituted (0);\n+      growable_macro_buffer substituted (0);\n       substitute_args (&substituted, def, is_varargs, &va_arg_name,\n \t\t       argv, no_loop, scope);\n \n       /* Now `substituted' is the macro's replacement list, with all\n-\t argument values substituted into it properly.  Re-scan it for\n+\t argument values substituted into it properly.\tRe-scan it for\n \t macro references, but don't expand invocations of this macro.\n \n \t We create a new buffer, `substituted_src', which points into\n-\t `substituted', and scan that.  We can't scan `substituted'\n+\t `substituted', and scan that.\tWe can't scan `substituted'\n \t itself, since the tokenization process moves the buffer's\n \t text pointer around, and we still need to be able to find\n \t `substituted's original text buffer after scanning it so we\n \t can free it.  */\n-      struct macro_buffer substituted_src (substituted.text, substituted.len);\n+      shared_macro_buffer substituted_src (substituted.text, substituted.len);\n       scan (dest, &substituted_src, &new_no_loop, scope);\n \n       return 1;\n@@ -1333,19 +1320,14 @@ expand (const char *id,\n    expansion to DEST and return non-zero.  Otherwise, return zero, and\n    leave DEST unchanged.\n \n-   SRC_FIRST and SRC_REST must be shared buffers; DEST must not be one.\n    SRC_FIRST must be a string built by get_token.  */\n static int\n-maybe_expand (struct macro_buffer *dest,\n-\t      struct macro_buffer *src_first,\n-\t      struct macro_buffer *src_rest,\n+maybe_expand (growable_macro_buffer *dest,\n+\t      shared_macro_buffer *src_first,\n+\t      shared_macro_buffer *src_rest,\n \t      struct macro_name_list *no_loop,\n \t      const macro_scope &scope)\n {\n-  gdb_assert (src_first->shared);\n-  gdb_assert (src_rest->shared);\n-  gdb_assert (! dest->shared);\n-\n   /* Is this token an identifier?  */\n   if (src_first->is_identifier)\n     {\n@@ -1371,22 +1353,19 @@ maybe_expand (struct macro_buffer *dest,\n \n /* Expand macro references in SRC, appending the results to DEST.\n    Assume we are re-scanning the result of expanding the macros named\n-   in NO_LOOP, and don't try to re-expand references to them.\n+   in NO_LOOP, and don't try to re-expand references to them.  */\n \n-   SRC must be a shared buffer; DEST must not be one.  */\n static void\n-scan (struct macro_buffer *dest,\n-      struct macro_buffer *src,\n+scan (growable_macro_buffer *dest,\n+      shared_macro_buffer *src,\n       struct macro_name_list *no_loop,\n       const macro_scope &scope)\n {\n-  gdb_assert (src->shared);\n-  gdb_assert (! dest->shared);\n \n   for (;;)\n     {\n-      struct macro_buffer tok;\n-      char *original_src_start = src->text;\n+      shared_macro_buffer tok;\n+      const char *original_src_start = src->text;\n \n       /* Find the next token in SRC.  */\n       if (! get_token (&tok, src))\n@@ -1419,9 +1398,9 @@ scan (struct macro_buffer *dest,\n gdb::unique_xmalloc_ptr<char>\n macro_expand (const char *source, const macro_scope &scope)\n {\n-  struct macro_buffer src (source, strlen (source));\n+  shared_macro_buffer src (source, strlen (source));\n \n-  struct macro_buffer dest (0);\n+  growable_macro_buffer dest (0);\n   dest.last_token = 0;\n \n   scan (&dest, &src, 0, scope);\n@@ -1441,13 +1420,13 @@ macro_expand_once (const char *source, const macro_scope &scope)\n gdb::unique_xmalloc_ptr<char>\n macro_expand_next (const char **lexptr, const macro_scope &scope)\n {\n-  struct macro_buffer tok;\n+  shared_macro_buffer tok;\n \n   /* Set up SRC to refer to the input text, pointed to by *lexptr.  */\n-  struct macro_buffer src (*lexptr, strlen (*lexptr));\n+  shared_macro_buffer src (*lexptr, strlen (*lexptr));\n \n   /* Set up DEST to receive the expansion, if there is one.  */\n-  struct macro_buffer dest (0);\n+  growable_macro_buffer dest (0);\n   dest.last_token = 0;\n \n   /* Get the text's first preprocessing token.  */"
    }
  ]
}