{
  "sha": "6244c1196a49a5732ac3667b4df0f157cf681d7b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjI0NGMxMTk2YTQ5YTU3MzJhYzM2NjdiNGRmMGYxNTdjZjY4MWQ3Yg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-12-09T18:51:45Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-12-09T18:51:45Z"
    },
    "message": "gdb: make discrete_position return optional\n\nInstead of returning a boolean status and returning the value through a\npointer, return an optional that does both jobs.  This helps in the\nfollowing patches, and I think it is an improvement in general.\n\ngdb/ChangeLog:\n\n\t* ada-lang.c (ada_value_slice_from_ptr): Adjust.\n\t(ada_value_slice): Adjust.\n\t(pos_atr): Adjust.\n\t* gdbtypes.c (get_discrete_bounds): Adjust.\n\t(discrete_position): Return optional.\n\t* gdbtypes.h (discrete_position): Return optional.\n\nChange-Id: I758dbd8858b296ee472ed39ec35db1dbd624a5ae",
    "tree": {
      "sha": "77a97a40d9cc1477eefef80e6b100f21ec2f239d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/77a97a40d9cc1477eefef80e6b100f21ec2f239d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6244c1196a49a5732ac3667b4df0f157cf681d7b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6244c1196a49a5732ac3667b4df0f157cf681d7b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6244c1196a49a5732ac3667b4df0f157cf681d7b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6244c1196a49a5732ac3667b4df0f157cf681d7b/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "037311d1df303c91395cdfe07b6ab414de99e420",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/037311d1df303c91395cdfe07b6ab414de99e420",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/037311d1df303c91395cdfe07b6ab414de99e420"
    }
  ],
  "stats": {
    "total": 73,
    "additions": 48,
    "deletions": 25
  },
  "files": [
    {
      "sha": "468bbca3d02559fdb320e2511c1b66bd0d000ecf",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6244c1196a49a5732ac3667b4df0f157cf681d7b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6244c1196a49a5732ac3667b4df0f157cf681d7b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6244c1196a49a5732ac3667b4df0f157cf681d7b",
      "patch": "@@ -1,3 +1,12 @@\n+2020-12-09  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* ada-lang.c (ada_value_slice_from_ptr): Adjust.\n+\t(ada_value_slice): Adjust.\n+\t(pos_atr): Adjust.\n+\t* gdbtypes.c (get_discrete_bounds): Adjust.\n+\t(discrete_position): Return optional.\n+\t* gdbtypes.h (discrete_position): Return optional.\n+\n 2020-12-07  Tom Tromey  <tromey@adacore.com>\n \n \t* maint.c (_initialize_maint_cmds): Use expression command"
    },
    {
      "sha": "5813ecded4472610c8b07e8a9e11bab1c18cb5f8",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 16,
      "deletions": 11,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6244c1196a49a5732ac3667b4df0f157cf681d7b/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6244c1196a49a5732ac3667b4df0f157cf681d7b/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=6244c1196a49a5732ac3667b4df0f157cf681d7b",
      "patch": "@@ -2815,11 +2815,13 @@ ada_value_slice_from_ptr (struct value *array_ptr, struct type *type,\n \t\t\t       type0->dyn_prop (DYN_PROP_BYTE_STRIDE),\n \t\t\t       TYPE_FIELD_BITSIZE (type0, 0));\n   int base_low =  ada_discrete_type_low_bound (type0->index_type ());\n-  LONGEST base_low_pos, low_pos;\n+  gdb::optional<LONGEST> base_low_pos, low_pos;\n   CORE_ADDR base;\n \n-  if (!discrete_position (base_index_type, low, &low_pos)\n-      || !discrete_position (base_index_type, base_low, &base_low_pos))\n+  low_pos = discrete_position (base_index_type, low);\n+  base_low_pos = discrete_position (base_index_type, base_low);\n+\n+  if (!low_pos.has_value () || !base_low_pos.has_value ())\n     {\n       warning (_(\"unable to get positions in slice, use bounds instead\"));\n       low_pos = low;\n@@ -2830,7 +2832,7 @@ ada_value_slice_from_ptr (struct value *array_ptr, struct type *type,\n   if (stride == 0)\n     stride = TYPE_LENGTH (TYPE_TARGET_TYPE (type0));\n \n-  base = value_as_address (array_ptr) + (low_pos - base_low_pos) * stride;\n+  base = value_as_address (array_ptr) + (*low_pos - *base_low_pos) * stride;\n   return value_at_lazy (slice_type, base);\n }\n \n@@ -2846,18 +2848,21 @@ ada_value_slice (struct value *array, int low, int high)\n \t\t\t      (NULL, TYPE_TARGET_TYPE (type), index_type,\n \t\t\t       type->dyn_prop (DYN_PROP_BYTE_STRIDE),\n \t\t\t       TYPE_FIELD_BITSIZE (type, 0));\n-  LONGEST low_pos, high_pos;\n+  gdb::optional<LONGEST> low_pos, high_pos;\n+\n \n-  if (!discrete_position (base_index_type, low, &low_pos)\n-      || !discrete_position (base_index_type, high, &high_pos))\n+  low_pos = discrete_position (base_index_type, low);\n+  high_pos = discrete_position (base_index_type, high);\n+\n+  if (!low_pos.has_value () || !high_pos.has_value ())\n     {\n       warning (_(\"unable to get positions in slice, use bounds instead\"));\n       low_pos = low;\n       high_pos = high;\n     }\n \n   return value_cast (slice_type,\n-\t\t     value_slice (array, low, high_pos - low_pos + 1));\n+\t\t     value_slice (array, low, *high_pos - *low_pos + 1));\n }\n \n /* If type is a record type in the form of a standard GNAT array\n@@ -8926,15 +8931,15 @@ pos_atr (struct value *arg)\n {\n   struct value *val = coerce_ref (arg);\n   struct type *type = value_type (val);\n-  LONGEST result;\n \n   if (!discrete_type_p (type))\n     error (_(\"'POS only defined on discrete types\"));\n \n-  if (!discrete_position (type, value_as_long (val), &result))\n+  gdb::optional<LONGEST> result = discrete_position (type, value_as_long (val));\n+  if (!result.has_value ())\n     error (_(\"enumeration value is invalid: can't find 'POS\"));\n \n-  return result;\n+  return *result;\n }\n \n static struct value *"
    },
    {
      "sha": "0c91edd48a54a14c391f8dccd3b357b472601c9c",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 20,
      "deletions": 13,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6244c1196a49a5732ac3667b4df0f157cf681d7b/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6244c1196a49a5732ac3667b4df0f157cf681d7b/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=6244c1196a49a5732ac3667b4df0f157cf681d7b",
      "patch": "@@ -1062,9 +1062,21 @@ get_discrete_bounds (struct type *type, LONGEST *lowp, LONGEST *highp)\n \n       if (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ENUM)\n \t{\n-\t  if (!discrete_position (TYPE_TARGET_TYPE (type), *lowp, lowp)\n-\t      || ! discrete_position (TYPE_TARGET_TYPE (type), *highp, highp))\n+\t  gdb::optional<LONGEST> low_pos\n+\t    = discrete_position (TYPE_TARGET_TYPE (type), *lowp);\n+\n+\t  if (!low_pos.has_value ())\n+\t    return 0;\n+\n+\t  *lowp = *low_pos;\n+\n+\t  gdb::optional<LONGEST> high_pos\n+\t    = discrete_position (TYPE_TARGET_TYPE (type), *highp);\n+\n+\t  if (!high_pos.has_value ())\n \t    return 0;\n+\n+\t  *highp = *high_pos;\n \t}\n       return 1;\n     case TYPE_CODE_ENUM:\n@@ -1160,8 +1172,8 @@ get_array_bounds (struct type *type, LONGEST *low_bound, LONGEST *high_bound)\n    in which case the value of POS is unmodified.\n */\n \n-int\n-discrete_position (struct type *type, LONGEST val, LONGEST *pos)\n+gdb::optional<LONGEST>\n+discrete_position (struct type *type, LONGEST val)\n {\n   if (type->code () == TYPE_CODE_RANGE)\n     type = TYPE_TARGET_TYPE (type);\n@@ -1173,19 +1185,14 @@ discrete_position (struct type *type, LONGEST val, LONGEST *pos)\n       for (i = 0; i < type->num_fields (); i += 1)\n \t{\n \t  if (val == TYPE_FIELD_ENUMVAL (type, i))\n-\t    {\n-\t      *pos = i;\n-\t      return 1;\n-\t    }\n+\t    return i;\n \t}\n+\n       /* Invalid enumeration value.  */\n-      return 0;\n+      return {};\n     }\n   else\n-    {\n-      *pos = val;\n-      return 1;\n-    }\n+    return val;\n }\n \n /* If the array TYPE has static bounds calculate and update its"
    },
    {
      "sha": "e30485652702e3847ea73f96281a1b1411447915",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 3,
      "deletions": 1,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6244c1196a49a5732ac3667b4df0f157cf681d7b/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6244c1196a49a5732ac3667b4df0f157cf681d7b/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=6244c1196a49a5732ac3667b4df0f157cf681d7b",
      "patch": "@@ -46,6 +46,7 @@\n \n #include \"hashtab.h\"\n #include \"gdbsupport/array-view.h\"\n+#include \"gdbsupport/gdb_optional.h\"\n #include \"gdbsupport/offset-type.h\"\n #include \"gdbsupport/enum-flags.h\"\n #include \"gdbsupport/underlying.h\"\n@@ -2477,7 +2478,8 @@ extern int get_discrete_bounds (struct type *, LONGEST *, LONGEST *);\n extern bool get_array_bounds (struct type *type, LONGEST *low_bound,\n \t\t\t      LONGEST *high_bound);\n \n-extern int discrete_position (struct type *type, LONGEST val, LONGEST *pos);\n+extern gdb::optional<LONGEST> discrete_position (struct type *type,\n+\t\t\t\t\t\t LONGEST val);\n \n extern int class_types_same_p (const struct type *, const struct type *);\n "
    }
  ]
}