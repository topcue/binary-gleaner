{
  "sha": "aed57c537116ae91f553ac835b3f96d1f87b3bb0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YWVkNTdjNTM3MTE2YWU5MWY1NTNhYzgzNWIzZjk2ZDFmODdiM2JiMA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2018-11-23T19:20:05Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-10T01:28:14Z"
    },
    "message": "Remove most uses of ALL_OBJFILES\n\nThis removes most uses of ALL_OBJFILES, replacing them with ranged for\nloops.  The remaining uses are all in macros, and will be removed in\nsubsequent patches.\n\ngdb/ChangeLog\n2019-01-09  Tom Tromey  <tom@tromey.com>\n\n\t* symtab.c (iterate_over_symtabs, matching_obj_sections)\n\t(expand_symtab_containing_pc, lookup_static_symbol)\n\t(basic_lookup_transparent_type, find_pc_sect_compunit_symtab)\n\t(find_symbol_at_address, find_line_symtab, find_main_name): Use\n\tall_objfiles.\n\t* probe.c (find_probe_by_pc, collect_probes): Use all_objfiles.\n\t* breakpoint.c (create_overlay_event_breakpoint)\n\t(create_longjmp_master_breakpoint)\n\t(create_std_terminate_master_breakpoint)\n\t(create_exception_master_breakpoint): Use all_objfiles.\n\t* linux-thread-db.c (try_thread_db_load_from_pdir)\n\t(has_libpthread): Use all_objfiles.\n\t* ada-lang.c (add_nonlocal_symbols): Use all_objfiles.\n\t* linespec.c (iterate_over_all_matching_symtabs)\n\t(search_minsyms_for_name): Use all_objfiles.\n\t* maint.c (maintenance_info_sections): Use all_objfiles.\n\t* main.c (captured_main_1): Use all_objfiles.\n\t* spu-tdep.c (spu_objfile_from_frame): Use all_objfiles.\n\t* guile/scm-objfile.c (gdbscm_objfiles): Use all_objfiles.\n\t* guile/scm-pretty-print.c\n\t(ppscm_find_pretty_printer_from_objfiles): Use all_objfiles.\n\t* solib-spu.c (append_ocl_sos): Use all_objfiles.\n\t* symmisc.c (maintenance_print_symbols): Use all_objfiles.\n\t(maintenance_print_msymbols): Use all_objfiles.\n\t* source.c (select_source_symtab): Use all_objfiles.\n\t* jit.c (jit_find_objf_with_entry_addr): Use all_objfiles.\n\t* symfile.c (remove_symbol_file_command)\n\t(expand_symtabs_matching, map_symbol_filenames): Use\n\tall_objfiles.\n\t* ppc-linux-tdep.c (ppc_linux_spe_context_inferior_created): Use\n\tall_objfiles.\n\t* dwarf2-frame.c (dwarf2_frame_find_fde): Use all_objfiles.\n\t* objc-lang.c (find_methods): Use all_objfiles.\n\t* objfiles.c (have_partial_symbols, have_full_symbols)\n\t(have_minimal_symbols, qsort_cmp)\n\t(default_iterate_over_objfiles_in_search_order): Use\n\tall_objfiles.\n\t* hppa-tdep.c (find_unwind_entry): Use all_objfiles.\n\t* psymtab.c (maintenance_print_psymbols): Use all_objfiles.\n\t(maintenance_check_psymtabs): Use all_objfiles.\n\t(ALL_PSYMTABS): Remove.\n\t* compile/compile-object-run.c (do_module_cleanup): Use\n\tall_objfiles.\n\t* blockframe.c (find_pc_partial_function): Use all_objfiles.\n\t* cp-support.c (add_symbol_overload_list_qualified): Use\n\tall_objfiles.\n\t* windows-tdep.c (windows_iterate_over_objfiles_in_search_order):\n\tUse all_objfiles.\n\t* dwarf-index-write.c (save_gdb_index_command): Use all_objfiles.\n\t* python/py-xmethods.c (gdbpy_get_matching_xmethod_workers): Use\n\tall_objfiles.\n\t* python/py-objfile.c (objfpy_lookup_objfile_by_name)\n\t(objfpy_lookup_objfile_by_build_id): Use all_objfiles.\n\t* python/py-prettyprint.c (find_pretty_printer_from_objfiles):\n\tUses all_objfiles.\n\t* solib.c (solib_read_symbols): Use all_objfiles",
    "tree": {
      "sha": "c2699609b04041be0ab313616b8a20e771a7a47e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c2699609b04041be0ab313616b8a20e771a7a47e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/aed57c537116ae91f553ac835b3f96d1f87b3bb0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aed57c537116ae91f553ac835b3f96d1f87b3bb0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/aed57c537116ae91f553ac835b3f96d1f87b3bb0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/aed57c537116ae91f553ac835b3f96d1f87b3bb0/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "99d89cdea6c296bdd94ce532350d139d3900ff78",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/99d89cdea6c296bdd94ce532350d139d3900ff78",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/99d89cdea6c296bdd94ce532350d139d3900ff78"
    }
  ],
  "stats": {
    "total": 1237,
    "additions": 621,
    "deletions": 616
  },
  "files": [
    {
      "sha": "00160cf74d441907d5205bf5cceeeffcd53b5047",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 59,
      "deletions": 0,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -1,3 +1,62 @@\n+2019-01-09  Tom Tromey  <tom@tromey.com>\n+\n+\t* symtab.c (iterate_over_symtabs, matching_obj_sections)\n+\t(expand_symtab_containing_pc, lookup_static_symbol)\n+\t(basic_lookup_transparent_type, find_pc_sect_compunit_symtab)\n+\t(find_symbol_at_address, find_line_symtab, find_main_name): Use\n+\tall_objfiles.\n+\t* probe.c (find_probe_by_pc, collect_probes): Use all_objfiles.\n+\t* breakpoint.c (create_overlay_event_breakpoint)\n+\t(create_longjmp_master_breakpoint)\n+\t(create_std_terminate_master_breakpoint)\n+\t(create_exception_master_breakpoint): Use all_objfiles.\n+\t* linux-thread-db.c (try_thread_db_load_from_pdir)\n+\t(has_libpthread): Use all_objfiles.\n+\t* ada-lang.c (add_nonlocal_symbols): Use all_objfiles.\n+\t* linespec.c (iterate_over_all_matching_symtabs)\n+\t(search_minsyms_for_name): Use all_objfiles.\n+\t* maint.c (maintenance_info_sections): Use all_objfiles.\n+\t* main.c (captured_main_1): Use all_objfiles.\n+\t* spu-tdep.c (spu_objfile_from_frame): Use all_objfiles.\n+\t* guile/scm-objfile.c (gdbscm_objfiles): Use all_objfiles.\n+\t* guile/scm-pretty-print.c\n+\t(ppscm_find_pretty_printer_from_objfiles): Use all_objfiles.\n+\t* solib-spu.c (append_ocl_sos): Use all_objfiles.\n+\t* symmisc.c (maintenance_print_symbols): Use all_objfiles.\n+\t(maintenance_print_msymbols): Use all_objfiles.\n+\t* source.c (select_source_symtab): Use all_objfiles.\n+\t* jit.c (jit_find_objf_with_entry_addr): Use all_objfiles.\n+\t* symfile.c (remove_symbol_file_command)\n+\t(expand_symtabs_matching, map_symbol_filenames): Use\n+\tall_objfiles.\n+\t* ppc-linux-tdep.c (ppc_linux_spe_context_inferior_created): Use\n+\tall_objfiles.\n+\t* dwarf2-frame.c (dwarf2_frame_find_fde): Use all_objfiles.\n+\t* objc-lang.c (find_methods): Use all_objfiles.\n+\t* objfiles.c (have_partial_symbols, have_full_symbols)\n+\t(have_minimal_symbols, qsort_cmp)\n+\t(default_iterate_over_objfiles_in_search_order): Use\n+\tall_objfiles.\n+\t* hppa-tdep.c (find_unwind_entry): Use all_objfiles.\n+\t* psymtab.c (maintenance_print_psymbols): Use all_objfiles.\n+\t(maintenance_check_psymtabs): Use all_objfiles.\n+\t(ALL_PSYMTABS): Remove.\n+\t* compile/compile-object-run.c (do_module_cleanup): Use\n+\tall_objfiles.\n+\t* blockframe.c (find_pc_partial_function): Use all_objfiles.\n+\t* cp-support.c (add_symbol_overload_list_qualified): Use\n+\tall_objfiles.\n+\t* windows-tdep.c (windows_iterate_over_objfiles_in_search_order):\n+\tUse all_objfiles.\n+\t* dwarf-index-write.c (save_gdb_index_command): Use all_objfiles.\n+\t* python/py-xmethods.c (gdbpy_get_matching_xmethod_workers): Use\n+\tall_objfiles.\n+\t* python/py-objfile.c (objfpy_lookup_objfile_by_name)\n+\t(objfpy_lookup_objfile_by_build_id): Use all_objfiles.\n+\t* python/py-prettyprint.c (find_pretty_printer_from_objfiles):\n+\tUses all_objfiles.\n+\t* solib.c (solib_read_symbols): Use all_objfiles\n+\n 2019-01-09  Tom Tromey  <tom@tromey.com>\n \n \t* probe.c (parse_probes_in_pspace): Use all_objfiles."
    },
    {
      "sha": "f462f684ec8406aeb27a27fa2adcf5b2ca8f62b6",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -5604,7 +5604,6 @@ add_nonlocal_symbols (struct obstack *obstackp,\n \t\t      const lookup_name_info &lookup_name,\n \t\t      domain_enum domain, int global)\n {\n-  struct objfile *objfile;\n   struct compunit_symtab *cu;\n   struct match_data data;\n \n@@ -5613,7 +5612,7 @@ add_nonlocal_symbols (struct obstack *obstackp,\n \n   bool is_wild_match = lookup_name.ada ().wild_match_p ();\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       data.objfile = objfile;\n \n@@ -5646,7 +5645,7 @@ add_nonlocal_symbols (struct obstack *obstackp,\n       const char *name = ada_lookup_name (lookup_name);\n       std::string name1 = std::string (\"<_ada_\") + name + '>';\n \n-      ALL_OBJFILES (objfile)\n+      for (objfile *objfile : all_objfiles (current_program_space))\n         {\n \t  data.objfile = objfile;\n \t  objfile->sf->qf->map_matching_symbols (objfile, name1.c_str (),"
    },
    {
      "sha": "106f8a49c2b7acf579737d07fccc881c2ed6f65b",
      "filename": "gdb/blockframe.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/blockframe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/blockframe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/blockframe.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -217,7 +217,6 @@ find_pc_partial_function (CORE_ADDR pc, const char **name, CORE_ADDR *address,\n   struct symbol *f;\n   struct bound_minimal_symbol msymbol;\n   struct compunit_symtab *compunit_symtab = NULL;\n-  struct objfile *objfile;\n   CORE_ADDR mapped_pc;\n \n   /* To ensure that the symbol returned belongs to the correct setion\n@@ -237,18 +236,19 @@ find_pc_partial_function (CORE_ADDR pc, const char **name, CORE_ADDR *address,\n     goto return_cached_value;\n \n   msymbol = lookup_minimal_symbol_by_pc_section (mapped_pc, section);\n-  ALL_OBJFILES (objfile)\n-  {\n-    if (objfile->sf)\n-      {\n-\tcompunit_symtab\n-\t  = objfile->sf->qf->find_pc_sect_compunit_symtab (objfile, msymbol,\n-\t\t\t\t\t\t\t   mapped_pc, section,\n-\t\t\t\t\t\t\t   0);\n-      }\n-    if (compunit_symtab != NULL)\n-      break;\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      if (objfile->sf)\n+\t{\n+\t  compunit_symtab\n+\t    = objfile->sf->qf->find_pc_sect_compunit_symtab (objfile, msymbol,\n+\t\t\t\t\t\t\t     mapped_pc,\n+\t\t\t\t\t\t\t     section,\n+\t\t\t\t\t\t\t     0);\n+\t}\n+      if (compunit_symtab != NULL)\n+\tbreak;\n+    }\n \n   if (compunit_symtab != NULL)\n     {"
    },
    {
      "sha": "48a1c6414e32f90ef696887c337361a6ed5445a2",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 103,
      "deletions": 108,
      "changes": 211,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -3203,10 +3203,9 @@ free_breakpoint_objfile_data (struct objfile *obj, void *data)\n static void\n create_overlay_event_breakpoint (void)\n {\n-  struct objfile *objfile;\n   const char *const func_name = \"_ovly_debug_event\";\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       struct breakpoint *b;\n       struct breakpoint_objfile_data *bp_objfile_data;\n@@ -3262,95 +3261,93 @@ create_longjmp_master_breakpoint (void)\n \n   ALL_PSPACES (pspace)\n   {\n-    struct objfile *objfile;\n-\n     set_current_program_space (pspace);\n \n-    ALL_OBJFILES (objfile)\n-    {\n-      int i;\n-      struct gdbarch *gdbarch;\n-      struct breakpoint_objfile_data *bp_objfile_data;\n+    for (objfile *objfile : all_objfiles (current_program_space))\n+      {\n+\tint i;\n+\tstruct gdbarch *gdbarch;\n+\tstruct breakpoint_objfile_data *bp_objfile_data;\n \n-      gdbarch = get_objfile_arch (objfile);\n+\tgdbarch = get_objfile_arch (objfile);\n \n-      bp_objfile_data = get_breakpoint_objfile_data (objfile);\n+\tbp_objfile_data = get_breakpoint_objfile_data (objfile);\n \n-      if (!bp_objfile_data->longjmp_searched)\n-\t{\n-\t  std::vector<probe *> ret\n-\t    = find_probes_in_objfile (objfile, \"libc\", \"longjmp\");\n+\tif (!bp_objfile_data->longjmp_searched)\n+\t  {\n+\t    std::vector<probe *> ret\n+\t      = find_probes_in_objfile (objfile, \"libc\", \"longjmp\");\n \n-\t  if (!ret.empty ())\n-\t    {\n-\t      /* We are only interested in checking one element.  */\n-\t      probe *p = ret[0];\n+\t    if (!ret.empty ())\n+\t      {\n+\t\t/* We are only interested in checking one element.  */\n+\t\tprobe *p = ret[0];\n \n-\t      if (!p->can_evaluate_arguments ())\n-\t\t{\n-\t\t  /* We cannot use the probe interface here, because it does\n-\t\t     not know how to evaluate arguments.  */\n-\t\t  ret.clear ();\n-\t\t}\n-\t    }\n-\t  bp_objfile_data->longjmp_probes = ret;\n-\t  bp_objfile_data->longjmp_searched = 1;\n-\t}\n+\t\tif (!p->can_evaluate_arguments ())\n+\t\t  {\n+\t\t    /* We cannot use the probe interface here, because it does\n+\t\t       not know how to evaluate arguments.  */\n+\t\t    ret.clear ();\n+\t\t  }\n+\t      }\n+\t    bp_objfile_data->longjmp_probes = ret;\n+\t    bp_objfile_data->longjmp_searched = 1;\n+\t  }\n \n-      if (!bp_objfile_data->longjmp_probes.empty ())\n-\t{\n-\t  for (probe *p : bp_objfile_data->longjmp_probes)\n-\t    {\n-\t      struct breakpoint *b;\n+\tif (!bp_objfile_data->longjmp_probes.empty ())\n+\t  {\n+\t    for (probe *p : bp_objfile_data->longjmp_probes)\n+\t      {\n+\t\tstruct breakpoint *b;\n+\n+\t\tb = create_internal_breakpoint (gdbarch,\n+\t\t\t\t\t\tp->get_relocated_address (objfile),\n+\t\t\t\t\t\tbp_longjmp_master,\n+\t\t\t\t\t\t&internal_breakpoint_ops);\n+\t\tb->location = new_probe_location (\"-probe-stap libc:longjmp\");\n+\t\tb->enable_state = bp_disabled;\n+\t      }\n \n-\t      b = create_internal_breakpoint (gdbarch,\n-\t\t\t\t\t      p->get_relocated_address (objfile),\n-\t\t\t\t\t      bp_longjmp_master,\n-\t\t\t\t\t      &internal_breakpoint_ops);\n-\t      b->location = new_probe_location (\"-probe-stap libc:longjmp\");\n-\t      b->enable_state = bp_disabled;\n-\t    }\n+\t    continue;\n+\t  }\n \n+\tif (!gdbarch_get_longjmp_target_p (gdbarch))\n \t  continue;\n-\t}\n-\n-      if (!gdbarch_get_longjmp_target_p (gdbarch))\n-\tcontinue;\n \n-      for (i = 0; i < NUM_LONGJMP_NAMES; i++)\n-\t{\n-\t  struct breakpoint *b;\n-\t  const char *func_name;\n-\t  CORE_ADDR addr;\n-\t  struct explicit_location explicit_loc;\n+\tfor (i = 0; i < NUM_LONGJMP_NAMES; i++)\n+\t  {\n+\t    struct breakpoint *b;\n+\t    const char *func_name;\n+\t    CORE_ADDR addr;\n+\t    struct explicit_location explicit_loc;\n \n-\t  if (msym_not_found_p (bp_objfile_data->longjmp_msym[i].minsym))\n-\t    continue;\n+\t    if (msym_not_found_p (bp_objfile_data->longjmp_msym[i].minsym))\n+\t      continue;\n \n-\t  func_name = longjmp_names[i];\n-\t  if (bp_objfile_data->longjmp_msym[i].minsym == NULL)\n-\t    {\n-\t      struct bound_minimal_symbol m;\n+\t    func_name = longjmp_names[i];\n+\t    if (bp_objfile_data->longjmp_msym[i].minsym == NULL)\n+\t      {\n+\t\tstruct bound_minimal_symbol m;\n \n-\t      m = lookup_minimal_symbol_text (func_name, objfile);\n-\t      if (m.minsym == NULL)\n-\t\t{\n-\t\t  /* Prevent future lookups in this objfile.  */\n-\t\t  bp_objfile_data->longjmp_msym[i].minsym = &msym_not_found;\n-\t\t  continue;\n-\t\t}\n-\t      bp_objfile_data->longjmp_msym[i] = m;\n-\t    }\n+\t\tm = lookup_minimal_symbol_text (func_name, objfile);\n+\t\tif (m.minsym == NULL)\n+\t\t  {\n+\t\t    /* Prevent future lookups in this objfile.  */\n+\t\t    bp_objfile_data->longjmp_msym[i].minsym = &msym_not_found;\n+\t\t    continue;\n+\t\t  }\n+\t\tbp_objfile_data->longjmp_msym[i] = m;\n+\t      }\n \n-\t  addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->longjmp_msym[i]);\n-\t  b = create_internal_breakpoint (gdbarch, addr, bp_longjmp_master,\n-\t\t\t\t\t  &internal_breakpoint_ops);\n-\t  initialize_explicit_location (&explicit_loc);\n-\t  explicit_loc.function_name = ASTRDUP (func_name);\n-\t  b->location = new_explicit_location (&explicit_loc);\n-\t  b->enable_state = bp_disabled;\n-\t}\n-    }\n+\t    addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->longjmp_msym[i]);\n+\t    b = create_internal_breakpoint (gdbarch, addr, bp_longjmp_master,\n+\t\t\t\t\t    &internal_breakpoint_ops);\n+\t    initialize_explicit_location (&explicit_loc);\n+\t    explicit_loc.function_name = ASTRDUP (func_name);\n+\t    b->location = new_explicit_location (&explicit_loc);\n+\t    b->enable_state = bp_disabled;\n+\t  }\n+      }\n   }\n }\n \n@@ -3365,46 +3362,45 @@ create_std_terminate_master_breakpoint (void)\n \n   ALL_PSPACES (pspace)\n   {\n-    struct objfile *objfile;\n     CORE_ADDR addr;\n \n     set_current_program_space (pspace);\n \n-    ALL_OBJFILES (objfile)\n-    {\n-      struct breakpoint *b;\n-      struct breakpoint_objfile_data *bp_objfile_data;\n-      struct explicit_location explicit_loc;\n+    for (objfile *objfile : all_objfiles (current_program_space))\n+      {\n+\tstruct breakpoint *b;\n+\tstruct breakpoint_objfile_data *bp_objfile_data;\n+\tstruct explicit_location explicit_loc;\n \n-      bp_objfile_data = get_breakpoint_objfile_data (objfile);\n+\tbp_objfile_data = get_breakpoint_objfile_data (objfile);\n \n-      if (msym_not_found_p (bp_objfile_data->terminate_msym.minsym))\n-\tcontinue;\n+\tif (msym_not_found_p (bp_objfile_data->terminate_msym.minsym))\n+\t  continue;\n \n-      if (bp_objfile_data->terminate_msym.minsym == NULL)\n-\t{\n-\t  struct bound_minimal_symbol m;\n+\tif (bp_objfile_data->terminate_msym.minsym == NULL)\n+\t  {\n+\t    struct bound_minimal_symbol m;\n \n-\t  m = lookup_minimal_symbol (func_name, NULL, objfile);\n-\t  if (m.minsym == NULL || (MSYMBOL_TYPE (m.minsym) != mst_text\n-\t\t\t\t   && MSYMBOL_TYPE (m.minsym) != mst_file_text))\n-\t    {\n-\t      /* Prevent future lookups in this objfile.  */\n-\t      bp_objfile_data->terminate_msym.minsym = &msym_not_found;\n-\t      continue;\n-\t    }\n-\t  bp_objfile_data->terminate_msym = m;\n-\t}\n+\t    m = lookup_minimal_symbol (func_name, NULL, objfile);\n+\t    if (m.minsym == NULL || (MSYMBOL_TYPE (m.minsym) != mst_text\n+\t\t\t\t     && MSYMBOL_TYPE (m.minsym) != mst_file_text))\n+\t      {\n+\t\t/* Prevent future lookups in this objfile.  */\n+\t\tbp_objfile_data->terminate_msym.minsym = &msym_not_found;\n+\t\tcontinue;\n+\t      }\n+\t    bp_objfile_data->terminate_msym = m;\n+\t  }\n \n-      addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->terminate_msym);\n-      b = create_internal_breakpoint (get_objfile_arch (objfile), addr,\n-                                      bp_std_terminate_master,\n-\t\t\t\t      &internal_breakpoint_ops);\n-      initialize_explicit_location (&explicit_loc);\n-      explicit_loc.function_name = ASTRDUP (func_name);\n-      b->location = new_explicit_location (&explicit_loc);\n-      b->enable_state = bp_disabled;\n-    }\n+\taddr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->terminate_msym);\n+\tb = create_internal_breakpoint (get_objfile_arch (objfile), addr,\n+\t\t\t\t\tbp_std_terminate_master,\n+\t\t\t\t\t&internal_breakpoint_ops);\n+\tinitialize_explicit_location (&explicit_loc);\n+\texplicit_loc.function_name = ASTRDUP (func_name);\n+\tb->location = new_explicit_location (&explicit_loc);\n+\tb->enable_state = bp_disabled;\n+      }\n   }\n }\n \n@@ -3413,10 +3409,9 @@ create_std_terminate_master_breakpoint (void)\n static void\n create_exception_master_breakpoint (void)\n {\n-  struct objfile *objfile;\n   const char *const func_name = \"_Unwind_DebugHook\";\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       struct breakpoint *b;\n       struct gdbarch *gdbarch;"
    },
    {
      "sha": "8abe494218eb38de72216848427fde2c45ef6efd",
      "filename": "gdb/compile/compile-object-run.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/compile/compile-object-run.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/compile/compile-object-run.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-run.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -62,7 +62,6 @@ static void\n do_module_cleanup (void *arg, int registers_valid)\n {\n   struct do_module_cleanup *data = (struct do_module_cleanup *) arg;\n-  struct objfile *objfile;\n \n   if (data->executedp != NULL)\n     {\n@@ -83,7 +82,7 @@ do_module_cleanup (void *arg, int registers_valid)\n \t}\n     }\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     if ((objfile->flags & OBJF_USERLOADED) == 0\n         && (strcmp (objfile_name (objfile), data->objfile_name_string) == 0))\n       {"
    },
    {
      "sha": "a5349ed3e3150b151a124892ad1d9d40f4890391",
      "filename": "gdb/cp-support.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/cp-support.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/cp-support.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -1374,17 +1374,16 @@ add_symbol_overload_list_qualified (const char *func_name,\n \t\t\t\t    std::vector<symbol *> *overload_list)\n {\n   struct compunit_symtab *cust;\n-  struct objfile *objfile;\n   const struct block *b, *surrounding_static_block = 0;\n \n   /* Look through the partial symtabs for all symbols which begin by\n      matching FUNC_NAME.  Make sure we read that symbol table in.  */\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    if (objfile->sf)\n-      objfile->sf->qf->expand_symtabs_for_function (objfile, func_name);\n-  }\n+  for (objfile *objf : all_objfiles (current_program_space))\n+    {\n+      if (objf->sf)\n+\tobjf->sf->qf->expand_symtabs_for_function (objf, func_name);\n+    }\n \n   /* Search upwards from currently selected frame (so that we can\n      complete on local vars.  */\n@@ -1397,6 +1396,7 @@ add_symbol_overload_list_qualified (const char *func_name,\n   /* Go through the symtabs and check the externs and statics for\n      symbols which match.  */\n \n+  struct objfile *objfile;\n   ALL_COMPUNITS (objfile, cust)\n   {\n     QUIT;"
    },
    {
      "sha": "f1118f722c56dcec7c19ba9414cadf2fb6047770",
      "filename": "gdb/dwarf-index-write.c",
      "status": "modified",
      "additions": 25,
      "deletions": 26,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/dwarf-index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/dwarf-index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf-index-write.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -1640,7 +1640,6 @@ write_psymtabs_to_index (struct dwarf2_per_objfile *dwarf2_per_objfile,\n static void\n save_gdb_index_command (const char *arg, int from_tty)\n {\n-  struct objfile *objfile;\n   const char dwarf5space[] = \"-dwarf-5 \";\n   dw_index_kind index_kind = dw_index_kind::GDB_INDEX;\n \n@@ -1658,35 +1657,35 @@ save_gdb_index_command (const char *arg, int from_tty)\n   if (!*arg)\n     error (_(\"usage: save gdb-index [-dwarf-5] DIRECTORY\"));\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    struct stat st;\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      struct stat st;\n \n-    /* If the objfile does not correspond to an actual file, skip it.  */\n-    if (stat (objfile_name (objfile), &st) < 0)\n-      continue;\n+      /* If the objfile does not correspond to an actual file, skip it.  */\n+      if (stat (objfile_name (objfile), &st) < 0)\n+\tcontinue;\n \n-    struct dwarf2_per_objfile *dwarf2_per_objfile\n-      = get_dwarf2_per_objfile (objfile);\n+      struct dwarf2_per_objfile *dwarf2_per_objfile\n+\t= get_dwarf2_per_objfile (objfile);\n \n-    if (dwarf2_per_objfile != NULL)\n-      {\n-\tTRY\n-\t  {\n-\t    const char *basename = lbasename (objfile_name (objfile));\n-\t    write_psymtabs_to_index (dwarf2_per_objfile, arg, basename,\n-\t\t\t\t     index_kind);\n-\t  }\n-\tCATCH (except, RETURN_MASK_ERROR)\n-\t  {\n-\t    exception_fprintf (gdb_stderr, except,\n-\t\t\t       _(\"Error while writing index for `%s': \"),\n-\t\t\t       objfile_name (objfile));\n-\t  }\n-\tEND_CATCH\n-      }\n+      if (dwarf2_per_objfile != NULL)\n+\t{\n+\t  TRY\n+\t    {\n+\t      const char *basename = lbasename (objfile_name (objfile));\n+\t      write_psymtabs_to_index (dwarf2_per_objfile, arg, basename,\n+\t\t\t\t       index_kind);\n+\t    }\n+\t  CATCH (except, RETURN_MASK_ERROR)\n+\t    {\n+\t      exception_fprintf (gdb_stderr, except,\n+\t\t\t\t _(\"Error while writing index for `%s': \"),\n+\t\t\t\t objfile_name (objfile));\n+\t    }\n+\t  END_CATCH\n+\t    }\n \n-  }\n+    }\n }\n \n void"
    },
    {
      "sha": "deb8a8002922d95b655a56e609eebd1895c8adbd",
      "filename": "gdb/dwarf2-frame.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/dwarf2-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/dwarf2-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2-frame.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -1702,9 +1702,7 @@ bsearch_fde_cmp (const void *key, const void *element)\n static struct dwarf2_fde *\n dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)\n {\n-  struct objfile *objfile;\n-\n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       struct dwarf2_fde_table *fde_table;\n       struct dwarf2_fde **p_fde;"
    },
    {
      "sha": "79b784aad622c2f5d9f05425bde8ac490ba9255b",
      "filename": "gdb/guile/scm-objfile.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/guile/scm-objfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/guile/scm-objfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-objfile.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -366,17 +366,16 @@ gdbscm_get_current_objfile (void)\n static SCM\n gdbscm_objfiles (void)\n {\n-  struct objfile *objf;\n   SCM result;\n \n   result = SCM_EOL;\n \n-  ALL_OBJFILES (objf)\n-  {\n-    SCM item = ofscm_scm_from_objfile (objf);\n+  for (objfile *objf : all_objfiles (current_program_space))\n+    {\n+      SCM item = ofscm_scm_from_objfile (objf);\n \n-    result = scm_cons (item, result);\n-  }\n+      result = scm_cons (item, result);\n+    }\n \n   return scm_reverse_x (result, SCM_EOL);\n }"
    },
    {
      "sha": "d621ed5e912f049e286d632074cf708b9899f6a7",
      "filename": "gdb/guile/scm-pretty-print.c",
      "status": "modified",
      "additions": 12,
      "deletions": 13,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/guile/scm-pretty-print.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/guile/scm-pretty-print.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-pretty-print.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -427,19 +427,18 @@ ppscm_search_pp_list (SCM list, SCM value)\n static SCM\n ppscm_find_pretty_printer_from_objfiles (SCM value)\n {\n-  struct objfile *objfile;\n-\n-  ALL_OBJFILES (objfile)\n-  {\n-    objfile_smob *o_smob = ofscm_objfile_smob_from_objfile (objfile);\n-    SCM pp = ppscm_search_pp_list (ofscm_objfile_smob_pretty_printers (o_smob),\n-\t\t\t\t   value);\n-\n-    /* Note: This will return if pp is a <gdb:exception> object,\n-       which is what we want.  */\n-    if (gdbscm_is_true (pp))\n-      return pp;\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      objfile_smob *o_smob = ofscm_objfile_smob_from_objfile (objfile);\n+      SCM pp\n+\t= ppscm_search_pp_list (ofscm_objfile_smob_pretty_printers (o_smob),\n+\t\t\t\tvalue);\n+\n+      /* Note: This will return if pp is a <gdb:exception> object,\n+\t which is what we want.  */\n+      if (gdbscm_is_true (pp))\n+\treturn pp;\n+    }\n \n   return SCM_BOOL_F;\n }"
    },
    {
      "sha": "d825bcea28caa7c60b1c046de08bcd13048d2379",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 49,
      "deletions": 50,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -483,7 +483,6 @@ struct unwind_table_entry *\n find_unwind_entry (CORE_ADDR pc)\n {\n   int first, middle, last;\n-  struct objfile *objfile;\n   struct hppa_objfile_private *priv;\n \n   if (hppa_debug)\n@@ -498,61 +497,61 @@ find_unwind_entry (CORE_ADDR pc)\n       return NULL;\n     }\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    struct hppa_unwind_info *ui;\n-    ui = NULL;\n-    priv = ((struct hppa_objfile_private *)\n-\t    objfile_data (objfile, hppa_objfile_priv_data));\n-    if (priv)\n-      ui = ((struct hppa_objfile_private *) priv)->unwind_info;\n-\n-    if (!ui)\n-      {\n-\tread_unwind_info (objfile);\n-        priv = ((struct hppa_objfile_private *)\n-\t\tobjfile_data (objfile, hppa_objfile_priv_data));\n-\tif (priv == NULL)\n-\t  error (_(\"Internal error reading unwind information.\"));\n-        ui = ((struct hppa_objfile_private *) priv)->unwind_info;\n-      }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      struct hppa_unwind_info *ui;\n+      ui = NULL;\n+      priv = ((struct hppa_objfile_private *)\n+\t      objfile_data (objfile, hppa_objfile_priv_data));\n+      if (priv)\n+\tui = ((struct hppa_objfile_private *) priv)->unwind_info;\n+\n+      if (!ui)\n+\t{\n+\t  read_unwind_info (objfile);\n+\t  priv = ((struct hppa_objfile_private *)\n+\t\t  objfile_data (objfile, hppa_objfile_priv_data));\n+\t  if (priv == NULL)\n+\t    error (_(\"Internal error reading unwind information.\"));\n+\t  ui = ((struct hppa_objfile_private *) priv)->unwind_info;\n+\t}\n \n-    /* First, check the cache.  */\n+      /* First, check the cache.  */\n \n-    if (ui->cache\n-\t&& pc >= ui->cache->region_start\n-\t&& pc <= ui->cache->region_end)\n-      {\n-\tif (hppa_debug)\n-\t  fprintf_unfiltered (gdb_stdlog, \"%s (cached) }\\n\",\n-            hex_string ((uintptr_t) ui->cache));\n-        return ui->cache;\n-      }\n+      if (ui->cache\n+\t  && pc >= ui->cache->region_start\n+\t  && pc <= ui->cache->region_end)\n+\t{\n+\t  if (hppa_debug)\n+\t    fprintf_unfiltered (gdb_stdlog, \"%s (cached) }\\n\",\n+\t\t\t\thex_string ((uintptr_t) ui->cache));\n+\t  return ui->cache;\n+\t}\n \n-    /* Not in the cache, do a binary search.  */\n+      /* Not in the cache, do a binary search.  */\n \n-    first = 0;\n-    last = ui->last;\n+      first = 0;\n+      last = ui->last;\n \n-    while (first <= last)\n-      {\n-\tmiddle = (first + last) / 2;\n-\tif (pc >= ui->table[middle].region_start\n-\t    && pc <= ui->table[middle].region_end)\n-\t  {\n-\t    ui->cache = &ui->table[middle];\n-\t    if (hppa_debug)\n-\t      fprintf_unfiltered (gdb_stdlog, \"%s }\\n\",\n-                hex_string ((uintptr_t) ui->cache));\n-\t    return &ui->table[middle];\n-\t  }\n+      while (first <= last)\n+\t{\n+\t  middle = (first + last) / 2;\n+\t  if (pc >= ui->table[middle].region_start\n+\t      && pc <= ui->table[middle].region_end)\n+\t    {\n+\t      ui->cache = &ui->table[middle];\n+\t      if (hppa_debug)\n+\t\tfprintf_unfiltered (gdb_stdlog, \"%s }\\n\",\n+\t\t\t\t    hex_string ((uintptr_t) ui->cache));\n+\t      return &ui->table[middle];\n+\t    }\n \n-\tif (pc < ui->table[middle].region_start)\n-\t  last = middle - 1;\n-\telse\n-\t  first = middle + 1;\n-      }\n-  }\t\t\t\t/* ALL_OBJFILES() */\n+\t  if (pc < ui->table[middle].region_start)\n+\t    last = middle - 1;\n+\t  else\n+\t    first = middle + 1;\n+\t}\n+    }\n \n   if (hppa_debug)\n     fprintf_unfiltered (gdb_stdlog, \"NULL (not found) }\\n\");"
    },
    {
      "sha": "e77c03ad59b649a727426a995053ba5feb45f096",
      "filename": "gdb/jit.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/jit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/jit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/jit.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -986,9 +986,7 @@ jit_unregister_code (struct objfile *objfile)\n static struct objfile *\n jit_find_objf_with_entry_addr (CORE_ADDR entry_addr)\n {\n-  struct objfile *objf;\n-\n-  ALL_OBJFILES (objf)\n+  for (objfile *objf : all_objfiles (current_program_space))\n     {\n       struct jit_objfile_data *objf_data;\n "
    },
    {
      "sha": "0d08bbee9437b09f84ef72a9a7ff6c155ef7b805",
      "filename": "gdb/linespec.c",
      "status": "modified",
      "additions": 42,
      "deletions": 43,
      "changes": 85,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/linespec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/linespec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linespec.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -1130,7 +1130,6 @@ iterate_over_all_matching_symtabs\n    struct program_space *search_pspace, bool include_inline,\n    gdb::function_view<symbol_found_callback_ftype> callback)\n {\n-  struct objfile *objfile;\n   struct program_space *pspace;\n \n   ALL_PSPACES (pspace)\n@@ -1142,46 +1141,48 @@ iterate_over_all_matching_symtabs\n \n     set_current_program_space (pspace);\n \n-    ALL_OBJFILES (objfile)\n-    {\n-      struct compunit_symtab *cu;\n+    for (objfile *objfile : all_objfiles (current_program_space))\n+      {\n+\tstruct compunit_symtab *cu;\n \n-      if (objfile->sf)\n-\tobjfile->sf->qf->expand_symtabs_matching (objfile,\n-\t\t\t\t\t\t  NULL,\n-\t\t\t\t\t\t  lookup_name,\n-\t\t\t\t\t\t  NULL, NULL,\n-\t\t\t\t\t\t  search_domain);\n+\tif (objfile->sf)\n+\t  objfile->sf->qf->expand_symtabs_matching (objfile,\n+\t\t\t\t\t\t    NULL,\n+\t\t\t\t\t\t    lookup_name,\n+\t\t\t\t\t\t    NULL, NULL,\n+\t\t\t\t\t\t    search_domain);\n \n-      ALL_OBJFILE_COMPUNITS (objfile, cu)\n-\t{\n-\t  struct symtab *symtab = COMPUNIT_FILETABS (cu);\n+\tALL_OBJFILE_COMPUNITS (objfile, cu)\n+\t  {\n+\t    struct symtab *symtab = COMPUNIT_FILETABS (cu);\n \n-\t  iterate_over_file_blocks (symtab, lookup_name, name_domain, callback);\n+\t    iterate_over_file_blocks (symtab, lookup_name, name_domain,\n+\t\t\t\t      callback);\n \n-\t  if (include_inline)\n-\t    {\n-\t      struct block *block;\n-\t      int i;\n+\t    if (include_inline)\n+\t      {\n+\t\tstruct block *block;\n+\t\tint i;\n \n-\t      for (i = FIRST_LOCAL_BLOCK;\n-\t\t   i < BLOCKVECTOR_NBLOCKS (SYMTAB_BLOCKVECTOR (symtab));\n-\t\t   i++)\n-\t\t{\n-\t\t  block = BLOCKVECTOR_BLOCK (SYMTAB_BLOCKVECTOR (symtab), i);\n-\t\t  state->language->la_iterate_over_symbols\n-\t\t    (block, lookup_name, name_domain, [&] (block_symbol *bsym)\n-\t\t     {\n-\t\t       /* Restrict calls to CALLBACK to symbols\n-\t\t\t  representing inline symbols only.  */\n-\t\t       if (SYMBOL_INLINED (bsym->symbol))\n-\t\t\t return callback (bsym);\n-\t\t       return true;\n-\t\t     });\n-\t\t}\n-\t    }\n-\t}\n-    }\n+\t\tfor (i = FIRST_LOCAL_BLOCK;\n+\t\t     i < BLOCKVECTOR_NBLOCKS (SYMTAB_BLOCKVECTOR (symtab));\n+\t\t     i++)\n+\t\t  {\n+\t\t    block = BLOCKVECTOR_BLOCK (SYMTAB_BLOCKVECTOR (symtab), i);\n+\t\t    state->language->la_iterate_over_symbols\n+\t\t      (block, lookup_name, name_domain,\n+\t\t       [&] (block_symbol *bsym)\n+\t\t       {\n+\t\t\t /* Restrict calls to CALLBACK to symbols\n+\t\t\t    representing inline symbols only.  */\n+\t\t\t if (SYMBOL_INLINED (bsym->symbol))\n+\t\t\t   return callback (bsym);\n+\t\t\t return true;\n+\t\t       });\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n   }\n }\n \n@@ -4351,26 +4352,24 @@ search_minsyms_for_name (struct collect_info *info,\n \n       ALL_PSPACES (pspace)\n       {\n-\tstruct objfile *objfile;\n-\n \tif (search_pspace != NULL && search_pspace != pspace)\n \t  continue;\n \tif (pspace->executing_startup)\n \t  continue;\n \n \tset_current_program_space (pspace);\n \n-\tALL_OBJFILES (objfile)\n-\t{\n-\t  iterate_over_minimal_symbols (objfile, name,\n-\t\t\t\t\t[&] (struct minimal_symbol *msym)\n+\tfor (objfile *objfile : all_objfiles (current_program_space))\n+\t  {\n+\t    iterate_over_minimal_symbols (objfile, name,\n+\t\t\t\t\t  [&] (struct minimal_symbol *msym)\n \t\t\t\t\t  {\n \t\t\t\t\t    add_minsym (msym, objfile, nullptr,\n \t\t\t\t\t\t\tinfo->state->list_mode,\n \t\t\t\t\t\t\t&minsyms);\n \t\t\t\t\t    return false;\n \t\t\t\t\t  });\n-\t}\n+\t  }\n       }\n     }\n   else"
    },
    {
      "sha": "d6cbc34f3312002bbfddaffc87069eb5f0f0279e",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -1053,12 +1053,10 @@ try_thread_db_load_from_pdir_1 (struct objfile *obj, const char *subdir)\n static int\n try_thread_db_load_from_pdir (const char *subdir)\n {\n-  struct objfile *obj;\n-\n   if (!auto_load_thread_db)\n     return 0;\n \n-  ALL_OBJFILES (obj)\n+  for (objfile *obj : all_objfiles (current_program_space))\n     if (libpthread_name_p (objfile_name (obj)))\n       {\n \tif (try_thread_db_load_from_pdir_1 (obj, subdir))\n@@ -1167,9 +1165,7 @@ thread_db_load_search (void)\n static int\n has_libpthread (void)\n {\n-  struct objfile *obj;\n-\n-  ALL_OBJFILES (obj)\n+  for (objfile *obj : all_objfiles (current_program_space))\n     if (libpthread_name_p (objfile_name (obj)))\n       return 1;\n "
    },
    {
      "sha": "7d9492b8761b1902cae6322f23573c19b9041a16",
      "filename": "gdb/main.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/main.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -485,7 +485,6 @@ captured_main_1 (struct captured_main_args *context)\n \n   int i;\n   int save_auto_load;\n-  struct objfile *objfile;\n   int ret = 1;\n \n #ifdef HAVE_USEFUL_SBRK\n@@ -1124,7 +1123,7 @@ captured_main_1 (struct captured_main_args *context)\n      We wait until now because it is common to add to the source search\n      path in local_gdbinit.  */\n   global_auto_load = save_auto_load;\n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     load_auto_scripts_for_objfile (objfile);\n \n   /* Process '-x' and '-ex' options.  */"
    },
    {
      "sha": "01d04df75bfd22562ad8a45c433083d3e7336aa2",
      "filename": "gdb/maint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/maint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/maint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/maint.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -348,7 +348,6 @@ maintenance_info_sections (const char *arg, int from_tty)\n       printf_filtered (_(\"file type %s.\\n\"), bfd_get_target (exec_bfd));\n       if (arg && *arg && match_substring (arg, \"ALLOBJ\"))\n \t{\n-\t  struct objfile *ofile;\n \t  struct obj_section *osect;\n \n \t  /* Only this function cares about the 'ALLOBJ' argument; \n@@ -358,7 +357,7 @@ maintenance_info_sections (const char *arg, int from_tty)\n \t  if (strcmp (arg, \"ALLOBJ\") == 0)\n \t    arg = NULL;\n \n-\t  ALL_OBJFILES (ofile)\n+\t  for (objfile *ofile : all_objfiles (current_program_space))\n \t    {\n \t      printf_filtered (_(\"  Object file: %s\\n\"), \n \t\t\t       bfd_get_filename (ofile->obfd));"
    },
    {
      "sha": "ec0ea56063b4efdeb2d45f411f828285c0b2970f",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -972,8 +972,6 @@ find_methods (char type, const char *theclass, const char *category,\n \t      const char *selector,\n \t      std::vector<const char *> *symbol_names)\n {\n-  struct objfile *objfile = NULL;\n-\n   const char *symname = NULL;\n \n   char ntype = '\\0';\n@@ -986,7 +984,7 @@ find_methods (char type, const char *theclass, const char *category,\n \n   gdb_assert (symbol_names != NULL);\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       unsigned int *objc_csym;\n       struct minimal_symbol *msymbol = NULL;"
    },
    {
      "sha": "c9a727aff7de06230421c2a97291d86619f3bb8a",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 20,
      "deletions": 29,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -1016,13 +1016,11 @@ objfile_has_symbols (struct objfile *objfile)\n int\n have_partial_symbols (void)\n {\n-  struct objfile *ofp;\n-\n-  ALL_OBJFILES (ofp)\n-  {\n-    if (objfile_has_partial_symbols (ofp))\n-      return 1;\n-  }\n+  for (objfile *ofp : all_objfiles (current_program_space))\n+    {\n+      if (objfile_has_partial_symbols (ofp))\n+\treturn 1;\n+    }\n   return 0;\n }\n \n@@ -1033,13 +1031,11 @@ have_partial_symbols (void)\n int\n have_full_symbols (void)\n {\n-  struct objfile *ofp;\n-\n-  ALL_OBJFILES (ofp)\n-  {\n-    if (objfile_has_full_symbols (ofp))\n-      return 1;\n-  }\n+  for (objfile *ofp : all_objfiles (current_program_space))\n+    {\n+      if (objfile_has_full_symbols (ofp))\n+\treturn 1;\n+    }\n   return 0;\n }\n \n@@ -1072,15 +1068,13 @@ objfile_purge_solibs (void)\n int\n have_minimal_symbols (void)\n {\n-  struct objfile *ofp;\n-\n-  ALL_OBJFILES (ofp)\n-  {\n-    if (ofp->per_bfd->minimal_symbol_count > 0)\n-      {\n-\treturn 1;\n-      }\n-  }\n+  for (objfile *ofp : all_objfiles (current_program_space))\n+    {\n+      if (ofp->per_bfd->minimal_symbol_count > 0)\n+\t{\n+\t  return 1;\n+\t}\n+    }\n   return 0;\n }\n \n@@ -1145,9 +1139,7 @@ qsort_cmp (const void *a, const void *b)\n \t{\n \t  /* Sort on sequence number of the objfile in the chain.  */\n \n-\t  const struct objfile *objfile;\n-\n-\t  ALL_OBJFILES (objfile)\n+\t  for (objfile *objfile : all_objfiles (current_program_space))\n \t    if (objfile == objfile1)\n \t      return -1;\n \t    else if (objfile == objfile2)\n@@ -1502,7 +1494,7 @@ shared_objfile_contains_address_p (struct program_space *pspace,\n }\n \n /* The default implementation for the \"iterate_over_objfiles_in_search_order\"\n-   gdbarch method.  It is equivalent to use the ALL_OBJFILES macro,\n+   gdbarch method.  It is equivalent to use the all_objfiles iterable,\n    searching the objfiles in the order they are stored internally,\n    ignoring CURRENT_OBJFILE.\n \n@@ -1516,9 +1508,8 @@ default_iterate_over_objfiles_in_search_order\n    void *cb_data, struct objfile *current_objfile)\n {\n   int stop = 0;\n-  struct objfile *objfile;\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n        stop = cb (objfile, cb_data);\n        if (stop)"
    },
    {
      "sha": "48bf56dd2f8d691586d4a44cde4c368ec89b0e5f",
      "filename": "gdb/ppc-linux-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/ppc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/ppc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-tdep.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -1788,10 +1788,8 @@ ppc_linux_spe_context_lookup (struct objfile *objfile)\n static void\n ppc_linux_spe_context_inferior_created (struct target_ops *t, int from_tty)\n {\n-  struct objfile *objfile;\n-\n   ppc_linux_spe_context_lookup (NULL);\n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     ppc_linux_spe_context_lookup (objfile);\n }\n "
    },
    {
      "sha": "7450e4cede545e72d945a75f6c90a73c7def8a0e",
      "filename": "gdb/probe.c",
      "status": "modified",
      "additions": 18,
      "deletions": 20,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/probe.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -244,29 +244,28 @@ find_probes_in_objfile (struct objfile *objfile, const char *provider,\n struct bound_probe\n find_probe_by_pc (CORE_ADDR pc)\n {\n-  struct objfile *objfile;\n   struct bound_probe result;\n \n   result.objfile = NULL;\n   result.prob = NULL;\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    if (!objfile->sf || !objfile->sf->sym_probe_fns\n-\t|| objfile->sect_index_text == -1)\n-      continue;\n-\n-    /* If this proves too inefficient, we can replace with a hash.  */\n-    const std::vector<probe *> &probes\n-      = objfile->sf->sym_probe_fns->sym_get_probes (objfile);\n-    for (probe *p : probes)\n-      if (p->get_relocated_address (objfile) == pc)\n-\t{\n-\t  result.objfile = objfile;\n-\t  result.prob = p;\n-\t  return result;\n-\t}\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      if (!objfile->sf || !objfile->sf->sym_probe_fns\n+\t  || objfile->sect_index_text == -1)\n+\tcontinue;\n+\n+      /* If this proves too inefficient, we can replace with a hash.  */\n+      const std::vector<probe *> &probes\n+\t= objfile->sf->sym_probe_fns->sym_get_probes (objfile);\n+      for (probe *p : probes)\n+\tif (p->get_relocated_address (objfile) == pc)\n+\t  {\n+\t    result.objfile = objfile;\n+\t    result.prob = p;\n+\t    return result;\n+\t  }\n+    }\n \n   return result;\n }\n@@ -282,7 +281,6 @@ static std::vector<bound_probe>\n collect_probes (const std::string &objname, const std::string &provider,\n \t\tconst std::string &probe_name, const static_probe_ops *spops)\n {\n-  struct objfile *objfile;\n   std::vector<bound_probe> result;\n   gdb::optional<compiled_regex> obj_pat, prov_pat, probe_pat;\n \n@@ -296,7 +294,7 @@ collect_probes (const std::string &objname, const std::string &provider,\n     obj_pat.emplace (objname.c_str (), REG_NOSUB,\n \t\t     _(\"Invalid object file regexp\"));\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       if (! objfile->sf || ! objfile->sf->sym_probe_fns)\n \tcontinue;"
    },
    {
      "sha": "cd1f5036f4bc1ab39c0faf7bac66e75e2e5e32bb",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 76,
      "deletions": 83,
      "changes": 159,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -108,12 +108,6 @@ require_partial_symbols (struct objfile *objfile, int verbose)\n \n #undef ALL_OBJFILE_PSYMTABS\n \n-/* Traverse all psymtabs in all objfiles.  */\n-\n-#define ALL_PSYMTABS(objfile, p) \\\n-  ALL_OBJFILES (objfile)\t \\\n-    ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, p)\n-\n /* Helper function for psym_map_symtabs_matching_filename that\n    expands the symtabs and calls the iterator.  */\n \n@@ -1874,7 +1868,6 @@ maintenance_print_psymbols (const char *args, int from_tty)\n {\n   struct ui_file *outfile = gdb_stdout;\n   char *address_arg = NULL, *source_arg = NULL, *objfile_arg = NULL;\n-  struct objfile *objfile;\n   struct partial_symtab *ps;\n   int i, outfile_idx, found;\n   CORE_ADDR pc = 0;\n@@ -1944,7 +1937,7 @@ maintenance_print_psymbols (const char *args, int from_tty)\n     }\n \n   found = 0;\n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       int printed_objfile_header = 0;\n       int print_for_objfile = 1;\n@@ -2148,93 +2141,93 @@ maintenance_check_psymtabs (const char *ignore, int from_tty)\n   struct compunit_symtab *cust = NULL;\n   struct partial_symtab *ps;\n   const struct blockvector *bv;\n-  struct objfile *objfile;\n   struct block *b;\n   int length;\n \n-  ALL_PSYMTABS (objfile, ps)\n-  {\n-    struct gdbarch *gdbarch = get_objfile_arch (objfile);\n-\n-    /* We don't call psymtab_to_symtab here because that may cause symtab\n-       expansion.  When debugging a problem it helps if checkers leave\n-       things unchanged.  */\n-    cust = ps->compunit_symtab;\n-\n-    /* First do some checks that don't require the associated symtab.  */\n-    if (ps->text_high (objfile) < ps->text_low (objfile))\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    ALL_OBJFILE_PSYMTABS_REQUIRED (objfile, ps)\n       {\n-\tprintf_filtered (\"Psymtab \");\n-\tputs_filtered (ps->filename);\n-\tprintf_filtered (\" covers bad range \");\n-\tfputs_filtered (paddress (gdbarch, ps->text_low (objfile)),\n-\t\t\tgdb_stdout);\n-\tprintf_filtered (\" - \");\n-\tfputs_filtered (paddress (gdbarch, ps->text_high (objfile)),\n-\t\t\tgdb_stdout);\n-\tprintf_filtered (\"\\n\");\n-\tcontinue;\n-      }\n+\tstruct gdbarch *gdbarch = get_objfile_arch (objfile);\n \n-    /* Now do checks requiring the associated symtab.  */\n-    if (cust == NULL)\n-      continue;\n-    bv = COMPUNIT_BLOCKVECTOR (cust);\n-    b = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);\n-    partial_symbol **psym = &objfile->static_psymbols[ps->statics_offset];\n-    length = ps->n_static_syms;\n-    while (length--)\n-      {\n-\tsym = block_lookup_symbol (b, symbol_search_name (*psym),\n-\t\t\t\t   symbol_name_match_type::SEARCH_NAME,\n-\t\t\t\t   (*psym)->domain);\n-\tif (!sym)\n+\t/* We don't call psymtab_to_symtab here because that may cause symtab\n+\t   expansion.  When debugging a problem it helps if checkers leave\n+\t   things unchanged.  */\n+\tcust = ps->compunit_symtab;\n+\n+\t/* First do some checks that don't require the associated symtab.  */\n+\tif (ps->text_high (objfile) < ps->text_low (objfile))\n \t  {\n-\t    printf_filtered (\"Static symbol `\");\n-\t    puts_filtered ((*psym)->name);\n-\t    printf_filtered (\"' only found in \");\n+\t    printf_filtered (\"Psymtab \");\n \t    puts_filtered (ps->filename);\n-\t    printf_filtered (\" psymtab\\n\");\n+\t    printf_filtered (\" covers bad range \");\n+\t    fputs_filtered (paddress (gdbarch, ps->text_low (objfile)),\n+\t\t\t    gdb_stdout);\n+\t    printf_filtered (\" - \");\n+\t    fputs_filtered (paddress (gdbarch, ps->text_high (objfile)),\n+\t\t\t    gdb_stdout);\n+\t    printf_filtered (\"\\n\");\n+\t    continue;\n \t  }\n-\tpsym++;\n-      }\n-    b = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);\n-    psym = &objfile->global_psymbols[ps->globals_offset];\n-    length = ps->n_global_syms;\n-    while (length--)\n-      {\n-\tsym = block_lookup_symbol (b, symbol_search_name (*psym),\n-\t\t\t\t   symbol_name_match_type::SEARCH_NAME,\n-\t\t\t\t   (*psym)->domain);\n-\tif (!sym)\n+\n+\t/* Now do checks requiring the associated symtab.  */\n+\tif (cust == NULL)\n+\t  continue;\n+\tbv = COMPUNIT_BLOCKVECTOR (cust);\n+\tb = BLOCKVECTOR_BLOCK (bv, STATIC_BLOCK);\n+\tpartial_symbol **psym = &objfile->static_psymbols[ps->statics_offset];\n+\tlength = ps->n_static_syms;\n+\twhile (length--)\n+\t  {\n+\t    sym = block_lookup_symbol (b, symbol_search_name (*psym),\n+\t\t\t\t       symbol_name_match_type::SEARCH_NAME,\n+\t\t\t\t       (*psym)->domain);\n+\t    if (!sym)\n+\t      {\n+\t\tprintf_filtered (\"Static symbol `\");\n+\t\tputs_filtered ((*psym)->name);\n+\t\tprintf_filtered (\"' only found in \");\n+\t\tputs_filtered (ps->filename);\n+\t\tprintf_filtered (\" psymtab\\n\");\n+\t      }\n+\t    psym++;\n+\t  }\n+\tb = BLOCKVECTOR_BLOCK (bv, GLOBAL_BLOCK);\n+\tpsym = &objfile->global_psymbols[ps->globals_offset];\n+\tlength = ps->n_global_syms;\n+\twhile (length--)\n \t  {\n-\t    printf_filtered (\"Global symbol `\");\n-\t    puts_filtered ((*psym)->name);\n-\t    printf_filtered (\"' only found in \");\n+\t    sym = block_lookup_symbol (b, symbol_search_name (*psym),\n+\t\t\t\t       symbol_name_match_type::SEARCH_NAME,\n+\t\t\t\t       (*psym)->domain);\n+\t    if (!sym)\n+\t      {\n+\t\tprintf_filtered (\"Global symbol `\");\n+\t\tputs_filtered ((*psym)->name);\n+\t\tprintf_filtered (\"' only found in \");\n+\t\tputs_filtered (ps->filename);\n+\t\tprintf_filtered (\" psymtab\\n\");\n+\t      }\n+\t    psym++;\n+\t  }\n+\tif (ps->raw_text_high () != 0\n+\t    && (ps->text_low (objfile) < BLOCK_START (b)\n+\t\t|| ps->text_high (objfile) > BLOCK_END (b)))\n+\t  {\n+\t    printf_filtered (\"Psymtab \");\n \t    puts_filtered (ps->filename);\n-\t    printf_filtered (\" psymtab\\n\");\n+\t    printf_filtered (\" covers \");\n+\t    fputs_filtered (paddress (gdbarch, ps->text_low (objfile)),\n+\t\t\t    gdb_stdout);\n+\t    printf_filtered (\" - \");\n+\t    fputs_filtered (paddress (gdbarch, ps->text_high (objfile)),\n+\t\t\t    gdb_stdout);\n+\t    printf_filtered (\" but symtab covers only \");\n+\t    fputs_filtered (paddress (gdbarch, BLOCK_START (b)), gdb_stdout);\n+\t    printf_filtered (\" - \");\n+\t    fputs_filtered (paddress (gdbarch, BLOCK_END (b)), gdb_stdout);\n+\t    printf_filtered (\"\\n\");\n \t  }\n-\tpsym++;\n       }\n-    if (ps->raw_text_high () != 0\n-\t&& (ps->text_low (objfile) < BLOCK_START (b)\n-\t    || ps->text_high (objfile) > BLOCK_END (b)))\n-      {\n-\tprintf_filtered (\"Psymtab \");\n-\tputs_filtered (ps->filename);\n-\tprintf_filtered (\" covers \");\n-\tfputs_filtered (paddress (gdbarch, ps->text_low (objfile)),\n-\t\t\tgdb_stdout);\n-\tprintf_filtered (\" - \");\n-\tfputs_filtered (paddress (gdbarch, ps->text_high (objfile)),\n-\t\t\tgdb_stdout);\n-\tprintf_filtered (\" but symtab covers only \");\n-\tfputs_filtered (paddress (gdbarch, BLOCK_START (b)), gdb_stdout);\n-\tprintf_filtered (\" - \");\n-\tfputs_filtered (paddress (gdbarch, BLOCK_END (b)), gdb_stdout);\n-\tprintf_filtered (\"\\n\");\n-      }\n-  }\n }\n \n void"
    },
    {
      "sha": "d9cf548adb35264bade3d6b6053bb7b519f3a8d4",
      "filename": "gdb/python/py-objfile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/python/py-objfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/python/py-objfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-objfile.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -501,9 +501,7 @@ objfpy_build_id_matches (const struct bfd_build_id *build_id,\n static struct objfile *\n objfpy_lookup_objfile_by_name (const char *name)\n {\n-  struct objfile *objfile;\n-\n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       const char *filename;\n \n@@ -529,9 +527,7 @@ objfpy_lookup_objfile_by_name (const char *name)\n static struct objfile *\n objfpy_lookup_objfile_by_build_id (const char *build_id)\n {\n-  struct objfile *objfile;\n-\n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       const struct bfd_build_id *obfd_build_id;\n "
    },
    {
      "sha": "4092fdb79f3e9a0a71b9c3a9d14a9d88a812385a",
      "filename": "gdb/python/py-prettyprint.c",
      "status": "modified",
      "additions": 18,
      "deletions": 20,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/python/py-prettyprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/python/py-prettyprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-prettyprint.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -93,28 +93,26 @@ search_pp_list (PyObject *list, PyObject *value)\n static PyObject *\n find_pretty_printer_from_objfiles (PyObject *value)\n {\n-  struct objfile *obj;\n+  for (objfile *obj : all_objfiles (current_program_space))\n+    {\n+      gdbpy_ref<> objf = objfile_to_objfile_object (obj);\n+      if (objf == NULL)\n+\t{\n+\t  /* Ignore the error and continue.  */\n+\t  PyErr_Clear ();\n+\t  continue;\n+\t}\n \n-  ALL_OBJFILES (obj)\n-  {\n-    gdbpy_ref<> objf = objfile_to_objfile_object (obj);\n-    if (objf == NULL)\n-      {\n-\t/* Ignore the error and continue.  */\n-\tPyErr_Clear ();\n-\tcontinue;\n-      }\n-\n-    gdbpy_ref<> pp_list (objfpy_get_printers (objf.get (), NULL));\n-    gdbpy_ref<> function (search_pp_list (pp_list.get (), value));\n-\n-    /* If there is an error in any objfile list, abort the search and exit.  */\n-    if (function == NULL)\n-      return NULL;\n+      gdbpy_ref<> pp_list (objfpy_get_printers (objf.get (), NULL));\n+      gdbpy_ref<> function (search_pp_list (pp_list.get (), value));\n \n-    if (function != Py_None)\n-      return function.release ();\n-  }\n+      /* If there is an error in any objfile list, abort the search and exit.  */\n+      if (function == NULL)\n+\treturn NULL;\n+\n+      if (function != Py_None)\n+\treturn function.release ();\n+    }\n \n   Py_RETURN_NONE;\n }"
    },
    {
      "sha": "acf521dfe3441d98704669944028dfa52d7e41d4",
      "filename": "gdb/python/py-xmethods.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/python/py-xmethods.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/python/py-xmethods.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-xmethods.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -121,8 +121,6 @@ gdbpy_get_matching_xmethod_workers\n    struct type *obj_type, const char *method_name,\n    std::vector<xmethod_worker_up> *dm_vec)\n {\n-  struct objfile *objfile;\n-\n   gdb_assert (obj_type != NULL && method_name != NULL);\n \n   gdbpy_enter enter_py (get_current_arch (), current_language);\n@@ -145,7 +143,7 @@ gdbpy_get_matching_xmethod_workers\n   /* Gather debug method matchers registered with the object files.\n      This could be done differently by iterating over each objfile's matcher\n      list individually, but there's no data yet to show it's needed.  */\n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       gdbpy_ref<> py_objfile = objfile_to_objfile_object (objfile);\n "
    },
    {
      "sha": "d68150eb3cc508d2ad938a7c714f01bbd9adafef",
      "filename": "gdb/solib-spu.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/solib-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/solib-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-spu.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -101,9 +101,8 @@ static void\n append_ocl_sos (struct so_list **link_ptr)\n {\n   CORE_ADDR *ocl_program_addr_base;\n-  struct objfile *objfile;\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       ocl_program_addr_base\n \t= (CORE_ADDR *) objfile_data (objfile, ocl_program_data_key);"
    },
    {
      "sha": "24f40d112491f08630d83ca9841b2dfd8ff4b1ad",
      "filename": "gdb/solib.c",
      "status": "modified",
      "additions": 8,
      "deletions": 4,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/solib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/solib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -677,11 +677,15 @@ solib_read_symbols (struct so_list *so, symfile_add_flags flags)\n       TRY\n \t{\n \t  /* Have we already loaded this shared object?  */\n-\t  ALL_OBJFILES (so->objfile)\n+\t  so->objfile = nullptr;\n+\t  for (objfile *objfile : all_objfiles (current_program_space))\n \t    {\n-\t      if (filename_cmp (objfile_name (so->objfile), so->so_name) == 0\n-\t\t  && so->objfile->addr_low == so->addr_low)\n-\t\tbreak;\n+\t      if (filename_cmp (objfile_name (objfile), so->so_name) == 0\n+\t\t  && objfile->addr_low == so->addr_low)\n+\t\t{\n+\t\t  so->objfile = objfile;\n+\t\t  break;\n+\t\t}\n \t    }\n \t  if (so->objfile == NULL)\n \t    {"
    },
    {
      "sha": "74c895c27b8d10bf4a92932aa937517eb4c76ed6",
      "filename": "gdb/source.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/source.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/source.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -288,13 +288,13 @@ select_source_symtab (struct symtab *s)\n   if (current_source_symtab)\n     return;\n \n-  ALL_OBJFILES (ofp)\n-  {\n-    if (ofp->sf)\n-      s = ofp->sf->qf->find_last_source_symtab (ofp);\n-    if (s)\n-      current_source_symtab = s;\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      if (objfile->sf)\n+\ts = objfile->sf->qf->find_last_source_symtab (objfile);\n+      if (s)\n+\tcurrent_source_symtab = s;\n+    }\n   if (current_source_symtab)\n     return;\n "
    },
    {
      "sha": "0f6fb6dd7207dd248decb4d5b4bcf4f8411cf8bc",
      "filename": "gdb/spu-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/spu-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/spu-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/spu-tdep.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -2000,12 +2000,11 @@ spu_objfile_from_frame (struct frame_info *frame)\n {\n   struct gdbarch *gdbarch = get_frame_arch (frame);\n   struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n-  struct objfile *obj;\n \n   if (gdbarch_bfd_arch_info (gdbarch)->arch != bfd_arch_spu)\n     return NULL;\n \n-  ALL_OBJFILES (obj)\n+  for (objfile *obj : all_objfiles (current_program_space))\n     {\n       if (obj->sections != obj->sections_end\n \t  && SPUADDR_SPU (obj_section_addr (obj->sections)) == tdep->id)"
    },
    {
      "sha": "8d05173dd9a2ddbb0314760ea214aa09f81025ce",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 32,
      "deletions": 29,
      "changes": 61,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -2351,12 +2351,16 @@ remove_symbol_file_command (const char *args, int from_tty)\n \n       addr = parse_and_eval_address (argv[1]);\n \n-      ALL_OBJFILES (objf)\n+      for (objfile *objfile : all_objfiles (current_program_space))\n \t{\n-\t  if ((objf->flags & OBJF_USERLOADED) != 0\n-\t      && (objf->flags & OBJF_SHARED) != 0\n-\t      && objf->pspace == pspace && is_addr_in_objfile (addr, objf))\n-\t    break;\n+\t  if ((objfile->flags & OBJF_USERLOADED) != 0\n+\t      && (objfile->flags & OBJF_SHARED) != 0\n+\t      && objfile->pspace == pspace\n+\t      && is_addr_in_objfile (addr, objfile))\n+\t    {\n+\t      objf = objfile;\n+\t      break;\n+\t    }\n \t}\n     }\n   else if (argv[0] != NULL)\n@@ -2368,13 +2372,16 @@ remove_symbol_file_command (const char *args, int from_tty)\n \n       gdb::unique_xmalloc_ptr<char> filename (tilde_expand (argv[0]));\n \n-      ALL_OBJFILES (objf)\n+      for (objfile *objfile : all_objfiles (current_program_space))\n \t{\n-\t  if ((objf->flags & OBJF_USERLOADED) != 0\n-\t      && (objf->flags & OBJF_SHARED) != 0\n-\t      && objf->pspace == pspace\n-\t      && filename_cmp (filename.get (), objfile_name (objf)) == 0)\n-\t    break;\n+\t  if ((objfile->flags & OBJF_USERLOADED) != 0\n+\t      && (objfile->flags & OBJF_SHARED) != 0\n+\t      && objfile->pspace == pspace\n+\t      && filename_cmp (filename.get (), objfile_name (objfile)) == 0)\n+\t    {\n+\t      objf = objfile;\n+\t      break;\n+\t    }\n \t}\n     }\n \n@@ -3791,16 +3798,14 @@ expand_symtabs_matching\n    gdb::function_view<expand_symtabs_exp_notify_ftype> expansion_notify,\n    enum search_domain kind)\n {\n-  struct objfile *objfile;\n-\n-  ALL_OBJFILES (objfile)\n-  {\n-    if (objfile->sf)\n-      objfile->sf->qf->expand_symtabs_matching (objfile, file_matcher,\n-\t\t\t\t\t\tlookup_name,\n-\t\t\t\t\t\tsymbol_matcher,\n-\t\t\t\t\t\texpansion_notify, kind);\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      if (objfile->sf)\n+\tobjfile->sf->qf->expand_symtabs_matching (objfile, file_matcher,\n+\t\t\t\t\t\t  lookup_name,\n+\t\t\t\t\t\t  symbol_matcher,\n+\t\t\t\t\t\t  expansion_notify, kind);\n+    }\n }\n \n /* Wrapper around the quick_symbol_functions map_symbol_filenames \"method\".\n@@ -3811,14 +3816,12 @@ void\n map_symbol_filenames (symbol_filename_ftype *fun, void *data,\n \t\t      int need_fullname)\n {\n-  struct objfile *objfile;\n-\n-  ALL_OBJFILES (objfile)\n-  {\n-    if (objfile->sf)\n-      objfile->sf->qf->map_symbol_filenames (objfile, fun, data,\n-\t\t\t\t\t     need_fullname);\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      if (objfile->sf)\n+\tobjfile->sf->qf->map_symbol_filenames (objfile, fun, data,\n+\t\t\t\t\t       need_fullname);\n+    }\n }\n \n #if GDB_SELF_TEST"
    },
    {
      "sha": "14e764994efc27f21a338d2b9636ccec43e9cc65",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 8,
      "deletions": 10,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -470,12 +470,11 @@ maintenance_print_symbols (const char *args, int from_tty)\n     }\n   else\n     {\n-      struct objfile *objfile;\n       struct compunit_symtab *cu;\n       struct symtab *s;\n       int found = 0;\n \n-      ALL_OBJFILES (objfile)\n+      for (objfile *objfile : all_objfiles (current_program_space))\n \t{\n \t  int print_for_objfile = 1;\n \n@@ -690,7 +689,6 @@ maintenance_print_msymbols (const char *args, int from_tty)\n {\n   struct ui_file *outfile = gdb_stdout;\n   char *objfile_arg = NULL;\n-  struct objfile *objfile;\n   int i, outfile_idx;\n \n   dont_repeat ();\n@@ -734,13 +732,13 @@ maintenance_print_msymbols (const char *args, int from_tty)\n       outfile = &arg_outfile;\n     }\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    QUIT;\n-    if (objfile_arg == NULL\n-\t|| compare_filenames_for_search (objfile_name (objfile), objfile_arg))\n-      dump_msymbols (objfile, outfile);\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      QUIT;\n+      if (objfile_arg == NULL\n+\t  || compare_filenames_for_search (objfile_name (objfile), objfile_arg))\n+\tdump_msymbols (objfile, outfile);\n+    }\n }\n \n static void"
    },
    {
      "sha": "17ee94607e2ccec9d9ac8d4460abca34d4e3a798",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 103,
      "deletions": 107,
      "changes": 210,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -464,7 +464,6 @@ void\n iterate_over_symtabs (const char *name,\n \t\t      gdb::function_view<bool (symtab *)> callback)\n {\n-  struct objfile *objfile;\n   gdb::unique_xmalloc_ptr<char> real_path;\n \n   /* Here we are interested in canonicalizing an absolute path, not\n@@ -475,7 +474,7 @@ iterate_over_symtabs (const char *name,\n       gdb_assert (IS_ABSOLUTE_PATH (real_path.get ()));\n     }\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       if (iterate_over_some_symtabs (name, real_path.get (),\n \t\t\t\t     objfile->compunit_symtabs, NULL,\n@@ -486,7 +485,7 @@ iterate_over_symtabs (const char *name,\n   /* Same search rules as above apply here, but now we look thru the\n      psymtabs.  */\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       if (objfile->sf\n \t  && objfile->sf->qf->map_symtabs_matching_filename (objfile,\n@@ -1013,9 +1012,12 @@ matching_obj_sections (struct obj_section *obj_first,\n \n   /* Otherwise check that they are in corresponding objfiles.  */\n \n-  ALL_OBJFILES (obj)\n-    if (obj->obfd == first->owner)\n-      break;\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    if (objfile->obfd == first->owner)\n+      {\n+\tobj = objfile;\n+\tbreak;\n+      }\n   gdb_assert (obj != NULL);\n \n   if (obj->separate_debug_objfile != NULL\n@@ -1033,7 +1035,6 @@ matching_obj_sections (struct obj_section *obj_first,\n void\n expand_symtab_containing_pc (CORE_ADDR pc, struct obj_section *section)\n {\n-  struct objfile *objfile;\n   struct bound_minimal_symbol msymbol;\n \n   /* If we know that this is not a text address, return failure.  This is\n@@ -1048,16 +1049,16 @@ expand_symtab_containing_pc (CORE_ADDR pc, struct obj_section *section)\n \t  || MSYMBOL_TYPE (msymbol.minsym) == mst_file_bss))\n     return;\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    struct compunit_symtab *cust = NULL;\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      struct compunit_symtab *cust = NULL;\n \n-    if (objfile->sf)\n-      cust = objfile->sf->qf->find_pc_sect_compunit_symtab (objfile, msymbol,\n-\t\t\t\t\t\t\t    pc, section, 0);\n-    if (cust)\n-      return;\n-  }\n+      if (objfile->sf)\n+\tcust = objfile->sf->qf->find_pc_sect_compunit_symtab (objfile, msymbol,\n+\t\t\t\t\t\t\t      pc, section, 0);\n+      if (cust)\n+\treturn;\n+    }\n }\n \f\n /* Hash function for the symbol cache.  */\n@@ -2576,7 +2577,6 @@ struct block_symbol\n lookup_static_symbol (const char *name, const domain_enum domain)\n {\n   struct symbol_cache *cache = get_symbol_cache (current_program_space);\n-  struct objfile *objfile;\n   struct block_symbol result;\n   struct block_symbol_cache *bsc;\n   struct symbol_cache_slot *slot;\n@@ -2592,7 +2592,7 @@ lookup_static_symbol (const char *name, const domain_enum domain)\n       return result;\n     }\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       result = lookup_symbol_in_objfile (objfile, STATIC_BLOCK, name, domain);\n       if (result.symbol != NULL)\n@@ -2793,27 +2793,26 @@ basic_lookup_transparent_type_1 (struct objfile *objfile, int block_index,\n struct type *\n basic_lookup_transparent_type (const char *name)\n {\n-  struct objfile *objfile;\n   struct type *t;\n \n   /* Now search all the global symbols.  Do the symtab's first, then\n      check the psymtab's.  If a psymtab indicates the existence\n      of the desired name as a global, then do psymtab-to-symtab\n      conversion on the fly and return the found symbol.  */\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    t = basic_lookup_transparent_type_1 (objfile, GLOBAL_BLOCK, name);\n-    if (t)\n-      return t;\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      t = basic_lookup_transparent_type_1 (objfile, GLOBAL_BLOCK, name);\n+      if (t)\n+\treturn t;\n+    }\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    t = basic_lookup_transparent_type_quick (objfile, GLOBAL_BLOCK, name);\n-    if (t)\n-      return t;\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      t = basic_lookup_transparent_type_quick (objfile, GLOBAL_BLOCK, name);\n+      if (t)\n+\treturn t;\n+    }\n \n   /* Now search the static file-level symbols.\n      Not strictly correct, but more useful than an error.\n@@ -2822,19 +2821,19 @@ basic_lookup_transparent_type (const char *name)\n      of the desired name as a file-level static, then do psymtab-to-symtab\n      conversion on the fly and return the found symbol.  */\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    t = basic_lookup_transparent_type_1 (objfile, STATIC_BLOCK, name);\n-    if (t)\n-      return t;\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      t = basic_lookup_transparent_type_1 (objfile, STATIC_BLOCK, name);\n+      if (t)\n+\treturn t;\n+    }\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    t = basic_lookup_transparent_type_quick (objfile, STATIC_BLOCK, name);\n-    if (t)\n-      return t;\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      t = basic_lookup_transparent_type_quick (objfile, STATIC_BLOCK, name);\n+      if (t)\n+\treturn t;\n+    }\n \n   return (struct type *) 0;\n }\n@@ -2877,7 +2876,7 @@ find_pc_sect_compunit_symtab (CORE_ADDR pc, struct obj_section *section)\n {\n   struct compunit_symtab *cust;\n   struct compunit_symtab *best_cust = NULL;\n-  struct objfile *objfile;\n+  struct objfile *obj_file;\n   CORE_ADDR distance = 0;\n   struct bound_minimal_symbol msymbol;\n \n@@ -2910,7 +2909,7 @@ find_pc_sect_compunit_symtab (CORE_ADDR pc, struct obj_section *section)\n      It also happens for objfiles that have their functions reordered.\n      For these, the symtab we are looking for is not necessarily read in.  */\n \n-  ALL_COMPUNITS (objfile, cust)\n+  ALL_COMPUNITS (obj_file, cust)\n   {\n     struct block *b;\n     const struct blockvector *bv;\n@@ -2929,15 +2928,15 @@ find_pc_sect_compunit_symtab (CORE_ADDR pc, struct obj_section *section)\n \t/* In order to better support objfiles that contain both\n \t   stabs and coff debugging info, we continue on if a psymtab\n \t   can't be found.  */\n-\tif ((objfile->flags & OBJF_REORDERED) && objfile->sf)\n+\tif ((obj_file->flags & OBJF_REORDERED) && obj_file->sf)\n \t  {\n \t    struct compunit_symtab *result;\n \n \t    result\n-\t      = objfile->sf->qf->find_pc_sect_compunit_symtab (objfile,\n-\t\t\t\t\t\t\t       msymbol,\n-\t\t\t\t\t\t\t       pc, section,\n-\t\t\t\t\t\t\t       0);\n+\t      = obj_file->sf->qf->find_pc_sect_compunit_symtab (obj_file,\n+\t\t\t\t\t\t\t\tmsymbol,\n+\t\t\t\t\t\t\t\tpc, section,\n+\t\t\t\t\t\t\t\t0);\n \t    if (result != NULL)\n \t      return result;\n \t  }\n@@ -2948,8 +2947,8 @@ find_pc_sect_compunit_symtab (CORE_ADDR pc, struct obj_section *section)\n \n \t    ALL_BLOCK_SYMBOLS (b, iter, sym)\n \t      {\n-\t\tfixup_symbol_section (sym, objfile);\n-\t\tif (matching_obj_sections (SYMBOL_OBJ_SECTION (objfile, sym),\n+\t\tfixup_symbol_section (sym, obj_file);\n+\t\tif (matching_obj_sections (SYMBOL_OBJ_SECTION (obj_file, sym),\n \t\t\t\t\t   section))\n \t\t  break;\n \t      }\n@@ -2967,19 +2966,19 @@ find_pc_sect_compunit_symtab (CORE_ADDR pc, struct obj_section *section)\n \n   /* Not found in symtabs, search the \"quick\" symtabs (e.g. psymtabs).  */\n \n-  ALL_OBJFILES (objfile)\n-  {\n-    struct compunit_symtab *result;\n-\n-    if (!objfile->sf)\n-      continue;\n-    result = objfile->sf->qf->find_pc_sect_compunit_symtab (objfile,\n-\t\t\t\t\t\t\t    msymbol,\n-\t\t\t\t\t\t\t    pc, section,\n-\t\t\t\t\t\t\t    1);\n-    if (result != NULL)\n-      return result;\n-  }\n+  for (objfile *objf : all_objfiles (current_program_space))\n+    {\n+      struct compunit_symtab *result;\n+\n+      if (!objf->sf)\n+\tcontinue;\n+      result = objf->sf->qf->find_pc_sect_compunit_symtab (objf,\n+\t\t\t\t\t\t\t   msymbol,\n+\t\t\t\t\t\t\t   pc, section,\n+\t\t\t\t\t\t\t   1);\n+      if (result != NULL)\n+\treturn result;\n+    }\n \n   return NULL;\n }\n@@ -2999,35 +2998,33 @@ find_pc_compunit_symtab (CORE_ADDR pc)\n struct symbol *\n find_symbol_at_address (CORE_ADDR address)\n {\n-  struct objfile *objfile;\n-\n-  ALL_OBJFILES (objfile)\n-  {\n-    if (objfile->sf == NULL\n-\t|| objfile->sf->qf->find_compunit_symtab_by_address == NULL)\n-      continue;\n-\n-    struct compunit_symtab *symtab\n-      = objfile->sf->qf->find_compunit_symtab_by_address (objfile, address);\n-    if (symtab != NULL)\n-      {\n-\tconst struct blockvector *bv = COMPUNIT_BLOCKVECTOR (symtab);\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      if (objfile->sf == NULL\n+\t  || objfile->sf->qf->find_compunit_symtab_by_address == NULL)\n+\tcontinue;\n \n-\tfor (int i = GLOBAL_BLOCK; i <= STATIC_BLOCK; ++i)\n-\t  {\n-\t    struct block *b = BLOCKVECTOR_BLOCK (bv, i);\n-\t    struct block_iterator iter;\n-\t    struct symbol *sym;\n+      struct compunit_symtab *symtab\n+\t= objfile->sf->qf->find_compunit_symtab_by_address (objfile, address);\n+      if (symtab != NULL)\n+\t{\n+\t  const struct blockvector *bv = COMPUNIT_BLOCKVECTOR (symtab);\n \n-\t    ALL_BLOCK_SYMBOLS (b, iter, sym)\n+\t  for (int i = GLOBAL_BLOCK; i <= STATIC_BLOCK; ++i)\n \t    {\n-\t      if (SYMBOL_CLASS (sym) == LOC_STATIC\n-\t\t  && SYMBOL_VALUE_ADDRESS (sym) == address)\n-\t\treturn sym;\n+\t      struct block *b = BLOCKVECTOR_BLOCK (bv, i);\n+\t      struct block_iterator iter;\n+\t      struct symbol *sym;\n+\n+\t      ALL_BLOCK_SYMBOLS (b, iter, sym)\n+\t\t{\n+\t\t  if (SYMBOL_CLASS (sym) == LOC_STATIC\n+\t\t      && SYMBOL_VALUE_ADDRESS (sym) == address)\n+\t\t    return sym;\n+\t\t}\n \t    }\n-\t  }\n-      }\n-  }\n+\t}\n+    }\n \n   return NULL;\n }\n@@ -3352,7 +3349,6 @@ find_line_symtab (struct symtab *symtab, int line,\n          BEST_INDEX and BEST_LINETABLE identify the item for it.  */\n       int best;\n \n-      struct objfile *objfile;\n       struct compunit_symtab *cu;\n       struct symtab *s;\n \n@@ -3361,13 +3357,14 @@ find_line_symtab (struct symtab *symtab, int line,\n       else\n \tbest = 0;\n \n-      ALL_OBJFILES (objfile)\n-      {\n-\tif (objfile->sf)\n-\t  objfile->sf->qf->expand_symtabs_with_fullname (objfile,\n-\t\t\t\t\t\t   symtab_to_fullname (symtab));\n-      }\n+      for (objfile *objfile : all_objfiles (current_program_space))\n+\t{\n+\t  if (objfile->sf)\n+\t    objfile->sf->qf->expand_symtabs_with_fullname\n+\t      (objfile, symtab_to_fullname (symtab));\n+\t}\n \n+      struct objfile *objfile;\n       ALL_FILETABS (objfile, cu, s)\n       {\n \tstruct linetable *l;\n@@ -5691,23 +5688,22 @@ static void\n find_main_name (void)\n {\n   const char *new_main_name;\n-  struct objfile *objfile;\n \n   /* First check the objfiles to see whether a debuginfo reader has\n      picked up the appropriate main name.  Historically the main name\n      was found in a more or less random way; this approach instead\n      relies on the order of objfile creation -- which still isn't\n      guaranteed to get the correct answer, but is just probably more\n      accurate.  */\n-  ALL_OBJFILES (objfile)\n-  {\n-    if (objfile->per_bfd->name_of_main != NULL)\n-      {\n-\tset_main_name (objfile->per_bfd->name_of_main,\n-\t\t       objfile->per_bfd->language_of_main);\n-\treturn;\n-      }\n-  }\n+  for (objfile *objfile : all_objfiles (current_program_space))\n+    {\n+      if (objfile->per_bfd->name_of_main != NULL)\n+\t{\n+\t  set_main_name (objfile->per_bfd->name_of_main,\n+\t\t\t objfile->per_bfd->language_of_main);\n+\t  return;\n+\t}\n+    }\n \n   /* Try to see if the main procedure is in Ada.  */\n   /* FIXME: brobecker/2005-03-07: Another way of doing this would"
    },
    {
      "sha": "9258f39eca3598f47c7d7249ec70bdbc1a9e5a92",
      "filename": "gdb/windows-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/aed57c537116ae91f553ac835b3f96d1f87b3bb0/gdb/windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-tdep.c?ref=aed57c537116ae91f553ac835b3f96d1f87b3bb0",
      "patch": "@@ -415,7 +415,6 @@ windows_iterate_over_objfiles_in_search_order\n    void *cb_data, struct objfile *current_objfile)\n {\n   int stop;\n-  struct objfile *objfile;\n \n   if (current_objfile)\n     {\n@@ -424,7 +423,7 @@ windows_iterate_over_objfiles_in_search_order\n \treturn;\n     }\n \n-  ALL_OBJFILES (objfile)\n+  for (objfile *objfile : all_objfiles (current_program_space))\n     {\n       if (objfile != current_objfile)\n \t{"
    }
  ]
}