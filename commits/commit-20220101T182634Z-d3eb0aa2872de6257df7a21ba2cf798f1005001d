{
  "sha": "d3eb0aa2872de6257df7a21ba2cf798f1005001d",
  "node_id": "C_kwDOANOeidoAKGQzZWIwYWEyODcyZGU2MjU3ZGY3YTIxYmEyY2Y3OThmMTAwNTAwMWQ",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2016-08-13T07:25:06Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2022-01-01T18:26:34Z"
    },
    "message": "sim: mips: clean up bad style/whitespace\n\nThis doesn't fix all the problems, but grabs a bunch of the more\nobvious ones.",
    "tree": {
      "sha": "15f9be0c6e70af96db0f63a7f04da0381dfe3fca",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/15f9be0c6e70af96db0f63a7f04da0381dfe3fca"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d3eb0aa2872de6257df7a21ba2cf798f1005001d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3eb0aa2872de6257df7a21ba2cf798f1005001d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d3eb0aa2872de6257df7a21ba2cf798f1005001d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3eb0aa2872de6257df7a21ba2cf798f1005001d/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "efd811591c125aa948d3e56a9cce7c084f047dcb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/efd811591c125aa948d3e56a9cce7c084f047dcb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/efd811591c125aa948d3e56a9cce7c084f047dcb"
    }
  ],
  "stats": {
    "total": 690,
    "additions": 345,
    "deletions": 345
  },
  "files": [
    {
      "sha": "e5c58ca6832175abb6404220e6737a9903584741",
      "filename": "sim/mips/cp1.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/cp1.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/cp1.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/cp1.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -127,7 +127,7 @@ value_fpr (sim_cpu *cpu,\n     }\n \n   /* For values not yet accessed, set to the desired format.  */\n-  if (fmt < fmt_uninterpreted) \n+  if (fmt < fmt_uninterpreted)\n     {\n       if (FPR_STATE[fpr] == fmt_uninterpreted)\n \t{\n@@ -1119,7 +1119,7 @@ fp_binary_r(sim_cpu *cpu,\n \t    address_word cia,\n \t    int (*sim_fpu_op)(sim_fpu *, const sim_fpu *, const sim_fpu *),\n \t    unsigned64 op1,\n-\t    unsigned64 op2) \n+\t    unsigned64 op2)\n {\n   sim_fpu wop1;\n   sim_fpu wop2;"
    },
    {
      "sha": "96c51a7b736dd165575f35ca3e2df5212855ad5e",
      "filename": "sim/mips/cp1.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/cp1.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/cp1.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/cp1.h?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -23,7 +23,7 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n #ifndef CP1_H\n #define CP1_H\n \n-/* See sim-main.h for allocation of registers FCR0 and FCR31 (FCSR) \n+/* See sim-main.h for allocation of registers FCR0 and FCR31 (FCSR)\n    in CPU state (struct sim_cpu), and for FPU functions.  */\n \n #define fcsr_FCC_mask      (0xFE800000)"
    },
    {
      "sha": "bc103e448962afb2d363b6f77cb0ddd39b7f1804",
      "filename": "sim/mips/dsp.igen",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dsp.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dsp.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/dsp.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -190,7 +190,7 @@\n \t  if (sat == 1)\n \t    {\n \t      if (setcond == 2)\n-\t\th0 = 0x7fff; \n+\t\th0 = 0x7fff;\n \t      else if (setcond == 1)\n \t\th0 = 0x8000;\n \t    }\n@@ -239,11 +239,11 @@\n \t}\n     }\n   if (setcond == 2)\n-    result = 0x7fffffff; \n+    result = 0x7fffffff;\n   else if (setcond == 1)\n     result = 0x80000000;\n   else\n-    result = v1 << shift; \n+    result = v1 << shift;\n   GPR[rd] = EXTEND32 (result);\n }\n \n@@ -1833,7 +1833,7 @@\n \tresult = 0x7fffffff;\n       else if (setcond == 2)\n \tresult = 0x80000000;\n-      else \n+      else\n \t{\n \t  if (shift != 0)\n \t    result = ((result >> (shift - 1)) + 1) >> 1;"
    },
    {
      "sha": "299eb2f001fc04bb34b368cd89ac924eb7940dbc",
      "filename": "sim/mips/dsp2.igen",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dsp2.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dsp2.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/dsp2.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -151,7 +151,7 @@\n   signed64 prod;\n   unsigned32 result;\n   w1 = (signed32) v1;\n-  w2 = (signed32 )v2;\n+  w2 = (signed32) v2;\n   if (w1 == (signed32) 0x80000000 && w2 == (signed32) 0x80000000)\n     {\n       DSPCR |= DSPCR_OUFLAG5;"
    },
    {
      "sha": "56c23d8dad43f785c3bd36e28862fb2bdcccb37f",
      "filename": "sim/mips/dv-tx3904cpu.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dv-tx3904cpu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dv-tx3904cpu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/dv-tx3904cpu.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -1,8 +1,8 @@\n /*  This file is part of the program GDB, the GNU debugger.\n-    \n+\n     Copyright (C) 1998-2022 Free Software Foundation, Inc.\n     Contributed by Cygnus Solutions.\n-    \n+\n     This program is free software; you can redistribute it and/or modify\n     it under the terms of the GNU General Public License as published by\n     the Free Software Foundation; either version 3 of the License, or\n@@ -15,7 +15,7 @@\n \n     You should have received a copy of the GNU General Public License\n     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-    \n+\n     */\n \n /* This must come before any other includes.  */\n@@ -26,20 +26,20 @@\n \n /* DEVICE\n \n-   \n+\n    tx3904cpu - tx3904 cpu virtual device\n \n-   \n+\n    DESCRIPTION\n \n-   \n+\n    Implements the external tx3904 functionality.  This includes the\n    delivery of of interrupts generated from other devices and the\n    handling of device specific registers.\n \n \n    PROPERTIES\n-   \n+\n    none\n \n \n@@ -88,7 +88,7 @@ struct tx3904cpu {\n \n \n \n-/* input port ID's */ \n+/* input port ID's */\n \n enum {\n   RESET_PORT,\n@@ -170,13 +170,13 @@ deliver_tx3904cpu_interrupt (struct hw *me,\n \t was cleared with a negative pending_level. */\n       CAUSE &= ~ (cause_IP_mask << cause_IP_shift);\n \n-      if(controller->pending_level > 0) /* interrupt set */\n+      if (controller->pending_level > 0) /* interrupt set */\n \t{\n \t  /* set hardware-interrupt subfields of CAUSE register */\n \t  CAUSE |= (controller->pending_level & cause_IP_mask) << cause_IP_shift;\n \n \t  /* check for enabled / unmasked interrupts */\n-\t  if((SR & status_IEc) &&\n+\t  if ((SR & status_IEc) &&\n \t     (controller->pending_level & ((SR >> status_IM_shift) & status_IM_mask)))\n \t    {\n \t      controller->pending_level = 0;\n@@ -185,7 +185,7 @@ deliver_tx3904cpu_interrupt (struct hw *me,\n \t  else\n \t    {\n \t      /* reschedule soon */\n-\t      if(controller->event != NULL)\n+\t      if (controller->event != NULL)\n \t\thw_event_queue_deschedule(me, controller->event);\n \t      controller->event =\n \t\thw_event_queue_schedule (me, 1, deliver_tx3904cpu_interrupt, NULL);\n@@ -207,34 +207,34 @@ tx3904cpu_port_event (struct hw *me,\n   struct tx3904cpu *controller = hw_data (me);\n \n   switch (my_port)\n-    {      \n+    {\n     case RESET_PORT:\n       controller->pending_reset = 1;\n       HW_TRACE ((me, \"port-in reset\"));\n       break;\n-      \n+\n     case NMI_PORT:\n       controller->pending_nmi = 1;\n       HW_TRACE ((me, \"port-in nmi\"));\n       break;\n-      \n+\n     case LEVEL_PORT:\n       /* level == 0 means that the interrupt was cleared */\n-      if(level == 0)\n+      if (level == 0)\n \tcontroller->pending_level = -1; /* signal end of interrupt */\n       else\n \tcontroller->pending_level = level;\n       HW_TRACE ((me, \"port-in level=%d\", level));\n       break;\n-      \n+\n     default:\n       hw_abort (me, \"bad switch\");\n       break;\n     }\n \n   /* Schedule an event to be delivered immediately after current\n      instruction. */\n-  if(controller->event != NULL)\n+  if (controller->event != NULL)\n     hw_event_queue_deschedule(me, controller->event);\n   controller->event =\n     hw_event_queue_schedule (me, 0, deliver_tx3904cpu_interrupt, NULL);"
    },
    {
      "sha": "26e395b91ca7f4bba9e56d17d0286132f29ab8e5",
      "filename": "sim/mips/dv-tx3904irc.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dv-tx3904irc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dv-tx3904irc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/dv-tx3904irc.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -1,8 +1,8 @@\n /*  This file is part of the program GDB, the GNU debugger.\n-    \n+\n     Copyright (C) 1998-2022 Free Software Foundation, Inc.\n     Contributed by Cygnus Solutions.\n-    \n+\n     This program is free software; you can redistribute it and/or modify\n     it under the terms of the GNU General Public License as published by\n     the Free Software Foundation; either version 3 of the License, or\n@@ -15,7 +15,7 @@\n \n     You should have received a copy of the GNU General Public License\n     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-    \n+\n     */\n \n /* This must come before any other includes.  */\n@@ -27,13 +27,13 @@\n \n /* DEVICE\n \n-   \n+\n    tx3904irc - tx3904 interrupt controller\n \n-   \n+\n    DESCRIPTION\n \n-   \n+\n    Implements the tx3904 interrupt controller described in the tx3904\n    user guide.  It does not include the interrupt detection circuit\n    that preprocesses the eight external interrupts, so assumes that\n@@ -79,7 +79,7 @@\n \n    External interrupts.  Level = 0 -> level interrupt cleared.\n \n-   \n+\n    dmac0-3 (input)\n \n    DMA internal interrupts, correspond to DMA channels 0-3.  Level = 0 -> level interrupt cleared.\n@@ -178,11 +178,11 @@ static const struct hw_port_descriptor tx3904irc_ports[] = {\n struct tx3904irc {\n   address_word base_address; /* control register base */\n   unsigned_4 isr;\n-#define ISR_SET(c,s) ((c)->isr &= ~ (1 << (s)))\n+#define ISR_SET(c, s) ((c)->isr &= ~(1 << (s)))\n   unsigned_4 imr;\n #define IMR_GET(c) ((c)->imr)\n   unsigned_4 ilr[4];\n-#define ILR_GET(c,s) LSEXTRACTED32((c)->ilr[(s)/4], (s) % 4 * 8 + 2, (s) % 4 * 8)\n+#define ILR_GET(c, s) LSEXTRACTED32((c)->ilr[(s) / 4], (s) % 4 * 8 + 2, (s) % 4 * 8)\n };\n \n \n@@ -264,7 +264,7 @@ tx3904irc_port_event (struct hw *me,\n   struct tx3904irc *controller = hw_data (me);\n \n   /* handle deactivated interrupt */\n-  if(level == 0)\n+  if (level == 0)\n     {\n       HW_TRACE ((me, \"interrupt cleared on port %d\", my_port));\n       hw_port_event(me, IP_PORT, 0);\n@@ -273,7 +273,7 @@ tx3904irc_port_event (struct hw *me,\n \n   switch (my_port)\n     {\n-    case INT0_PORT: \n+    case INT0_PORT:\n       {\n \tint ip_number = 32; /* compute IP[5:0] */\n \tHW_TRACE ((me, \"port-event INT[0]\"));\n@@ -290,10 +290,10 @@ tx3904irc_port_event (struct hw *me,\n \n \tHW_TRACE ((me, \"interrupt asserted on port %d\", source));\n \tISR_SET(controller, source);\n-\tif(ILR_GET(controller, source) > IMR_GET(controller))\n+\tif (ILR_GET(controller, source) > IMR_GET(controller))\n \t  {\n \t    int ip_number = 16 + source; /* compute IP[4:0] */\n-\t    HW_TRACE ((me, \"interrupt level %d\", ILR_GET(controller,source)));\n+\t    HW_TRACE ((me, \"interrupt level %d\", ILR_GET(controller, source)));\n \t    hw_port_event(me, IP_PORT, ip_number);\n \t  }\n \tbreak;\n@@ -360,7 +360,7 @@ tx3904irc_io_read_buffer (struct hw *me,\n     }\n \n   return nr_bytes;\n-}     \n+}\n \n \n \n@@ -405,7 +405,7 @@ tx3904irc_io_write_buffer (struct hw *me,\n       /* HW_TRACE ((me, \"post: %08lx\", (long) *register_ptr)); */\n     }\n   return nr_bytes;\n-}     \n+}\n \n \n const struct hw_descriptor dv_tx3904irc_descriptor[] = {"
    },
    {
      "sha": "fed9fcab7b5879e335b7a152386f929a53b2f541",
      "filename": "sim/mips/dv-tx3904sio.c",
      "status": "modified",
      "additions": 44,
      "deletions": 44,
      "changes": 88,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dv-tx3904sio.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dv-tx3904sio.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/dv-tx3904sio.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -1,8 +1,8 @@\n /*  This file is part of the program GDB, the GNU debugger.\n-    \n+\n     Copyright (C) 1998-2022 Free Software Foundation, Inc.\n     Contributed by Cygnus Solutions.\n-    \n+\n     This program is free software; you can redistribute it and/or modify\n     it under the terms of the GNU General Public License as published by\n     the Free Software Foundation; either version 3 of the License, or\n@@ -15,7 +15,7 @@\n \n     You should have received a copy of the GNU General Public License\n     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-    \n+\n     */\n \n /* This must come before any other includes.  */\n@@ -30,20 +30,20 @@\n \n /* DEVICE\n \n-   \n+\n    tx3904sio - tx3904 serial I/O\n \n-   \n+\n    DESCRIPTION\n \n-   \n+\n    Implements one tx3904 serial I/O controller described in the tx3904\n    user guide.  Three instances are required for SIO0 and SIO1 within\n    the tx3904, at different base addresses.\n \n    Both internal and system clocks are synthesized as divided versions\n    of the simulator clock.\n-   \n+\n    There is no support for:\n     - CTS/RTS flow control\n     - baud rate emulation - use infinite speed instead\n@@ -103,7 +103,7 @@ static void tx3904sio_poll(struct hw*, void* data);\n \n \n /* register numbers; each is one word long */\n-enum \n+enum\n {\n   SLCR_REG = 0,\n   SLSR_REG = 1,\n@@ -126,7 +126,7 @@ enum\n };\n \n \n-static const struct hw_port_descriptor tx3904sio_ports[] = \n+static const struct hw_port_descriptor tx3904sio_ports[] =\n {\n   { \"int\", INT_PORT, 0, output_port, },\n   { \"reset\", RESET_PORT, 0, input_port, },\n@@ -136,7 +136,7 @@ static const struct hw_port_descriptor tx3904sio_ports[] =\n \n \n /* Generic FIFO */\n-struct tx3904sio_fifo \n+struct tx3904sio_fifo\n {\n   int size, used;\n   unsigned_1 *buffer;\n@@ -147,7 +147,7 @@ struct tx3904sio_fifo\n /* The timer/counter register internal state.  Note that we store\n    state using the control register images, in host endian order. */\n \n-struct tx3904sio \n+struct tx3904sio\n {\n   address_word base_address; /* control register base */\n   enum {sio_tcp, sio_stdio} backend; /* backend */\n@@ -226,12 +226,12 @@ attach_tx3904sio_regs (struct hw *me,\n \t\t     attach_space, attach_address, attach_size,\n \t\t     me);\n \n-  if(hw_find_property(me, \"backend\") != NULL)\n+  if (hw_find_property(me, \"backend\") != NULL)\n     {\n       const char* value = hw_find_string_property(me, \"backend\");\n-      if(! strcmp(value, \"tcp\"))\n+      if (!strcmp(value, \"tcp\"))\n \tcontroller->backend = sio_tcp;\n-      else if(! strcmp(value, \"stdio\"))\n+      else if (!strcmp(value, \"stdio\"))\n \tcontroller->backend = sio_stdio;\n       else\n \thw_abort(me, \"illegal value for backend parameter `%s': use tcp or stdio\", value);\n@@ -343,7 +343,7 @@ tx3904sio_io_read_buffer (struct hw *me,\n \tcase TFIFO_REG: register_value = 0; break;\n \tcase SFIFO_REG:\n \t  /* consume rx fifo for MS byte */\n-\t  if(reg_offset == 0 && tx3904sio_fifo_nonempty(me, & controller->rx_fifo))\n+\t  if (reg_offset == 0 && tx3904sio_fifo_nonempty(me, & controller->rx_fifo))\n \t    register_value = (tx3904sio_fifo_pop(me, & controller->rx_fifo) << 24);\n \t  else\n \t    register_value = 0;\n@@ -358,7 +358,7 @@ tx3904sio_io_read_buffer (struct hw *me,\n     }\n \n   return nr_bytes;\n-}     \n+}\n \n \n \n@@ -394,7 +394,7 @@ tx3904sio_io_write_buffer (struct hw *me,\n \tcase SDICR_REG:\n \t  {\n \t    unsigned_4 last_int, next_int;\n-\t    \n+\n \t    /* deassert interrupt upon clear */\n \t    last_int = controller->sdisr & controller->sdicr;\n \t    /* HW_TRACE ((me, \"sdicr - sdisr %08x sdicr %08x\",\n@@ -403,13 +403,13 @@ tx3904sio_io_write_buffer (struct hw *me,\n \t    /* HW_TRACE ((me, \"sdicr + sdisr %08x sdicr %08x\",\n \t       controller->sdisr, controller->sdicr)); */\n \t    next_int = controller->sdisr & controller->sdicr;\n-\t    \n-\t    if(SDICR_GET_SDMAE(controller))\n+\n+\t    if (SDICR_GET_SDMAE(controller))\n \t      hw_abort(me, \"Cannot support DMA-driven sio.\");\n \n-\t    if(~last_int & next_int) /* any bits set? */\n+\t    if (~last_int & next_int) /* any bits set? */\n \t      hw_port_event(me, INT_PORT, 1);\n-\t    if(last_int & ~next_int) /* any bits cleared? */\n+\t    if (last_int & ~next_int) /* any bits cleared? */\n \t      hw_port_event(me, INT_PORT, 0);\n \t  }\n \tbreak;\n@@ -420,41 +420,41 @@ tx3904sio_io_write_buffer (struct hw *me,\n \n \t    /* deassert interrupt upon clear */\n \t    last_int = controller->sdisr & controller->sdicr;\n-\t    /* HW_TRACE ((me, \"sdisr - sdisr %08x sdicr %08x\", \n+\t    /* HW_TRACE ((me, \"sdisr - sdisr %08x sdicr %08x\",\n \t       controller->sdisr, controller->sdicr)); */\n \t    SDISR_CLEAR_FLAG_BYTE(controller, reg_offset, write_byte);\n-\t    /* HW_TRACE ((me, \"sdisr + sdisr %08x sdicr %08x\", \n+\t    /* HW_TRACE ((me, \"sdisr + sdisr %08x sdicr %08x\",\n \t       controller->sdisr, controller->sdicr)); */\n \t    next_int = controller->sdisr & controller->sdicr;\n \n-\t    if(~last_int & next_int) /* any bits set? */\n+\t    if (~last_int & next_int) /* any bits set? */\n \t      hw_port_event(me, INT_PORT, 1);\n-\t    if(last_int & ~next_int) /* any bits cleared? */\n+\t    if (last_int & ~next_int) /* any bits cleared? */\n \t      hw_port_event(me, INT_PORT, 0);\n \t  }\n \tbreak;\n-\t\n+\n \tcase SFCR_REG:\n \t  SFCR_SET_BYTE(controller, reg_offset, write_byte);\n-\t  if(SFCR_GET_FRSTE(controller))\n+\t  if (SFCR_GET_FRSTE(controller))\n \t    {\n-\t      if(SFCR_GET_TFRST(controller)) tx3904sio_fifo_reset(me, & controller->tx_fifo);\n-\t      if(SFCR_GET_RFRST(controller)) tx3904sio_fifo_reset(me, & controller->rx_fifo);\n+\t      if (SFCR_GET_TFRST(controller)) tx3904sio_fifo_reset(me, & controller->tx_fifo);\n+\t      if (SFCR_GET_RFRST(controller)) tx3904sio_fifo_reset(me, & controller->rx_fifo);\n \t    }\n \t  break;\n-\t  \n+\n \tcase SBGR_REG:\n \t  SBGR_SET_BYTE(controller, reg_offset, write_byte);\n \t  break;\n-\t  \n+\n \tcase SFIFO_REG: /* unwriteable */ break;\n-\t  \n-\tcase TFIFO_REG: \n-\t  if(reg_offset == 3) /* first byte */\n+\n+\tcase TFIFO_REG:\n+\t  if (reg_offset == 3) /* first byte */\n \t    tx3904sio_fifo_push(me, & controller->tx_fifo, write_byte);\n \t  break;\n \n-\tdefault: \n+\tdefault:\n \t  HW_TRACE ((me, \"write to illegal register %d\", reg_number));\n \t}\n     } /* loop over bytes */\n@@ -463,7 +463,7 @@ tx3904sio_io_write_buffer (struct hw *me,\n   tx3904sio_tickle(me);\n \n   return nr_bytes;\n-}     \n+}\n \n \n \n@@ -481,7 +481,7 @@ tx3904sio_tickle(struct hw *me)\n   unsigned_4 last_int, next_int;\n \n   /* HW_TRACE ((me, \"tickle backend: %02x\", controller->backend)); */\n-  switch(controller->backend) \n+  switch (controller->backend)\n     {\n     case sio_tcp:\n \n@@ -529,20 +529,20 @@ tx3904sio_tickle(struct hw *me)\n   /* Update RDIS / TDIS flags */\n   last_int = controller->sdisr & controller->sdicr;\n   /* HW_TRACE ((me, \"tickle - sdisr %08x sdicr %08x\", controller->sdisr, controller->sdicr)); */\n-  if(tx3904sio_fifo_nonempty(me, & controller->rx_fifo))\n+  if (tx3904sio_fifo_nonempty(me, & controller->rx_fifo))\n     SDISR_SET_RDIS(controller);\n-  if(! tx3904sio_fifo_nonempty(me, & controller->tx_fifo))\n+  if (!tx3904sio_fifo_nonempty(me, & controller->tx_fifo))\n     SDISR_SET_TDIS(controller);\n   next_int = controller->sdisr & controller->sdicr;\n   /* HW_TRACE ((me, \"tickle + sdisr %08x sdicr %08x\", controller->sdisr, controller->sdicr)); */\n \n-  if(~last_int & next_int) /* any bits set? */\n+  if (~last_int & next_int) /* any bits set? */\n     hw_port_event(me, INT_PORT, 1);\n-  if(last_int & ~next_int) /* any bits cleared? */\n+  if (last_int & ~next_int) /* any bits cleared? */\n     hw_port_event(me, INT_PORT, 0);\n \n   /* Add periodic polling for this port, if it's not already going. */\n-  if(controller->poll_event == NULL)\n+  if (controller->poll_event == NULL)\n     {\n       controller->poll_event = hw_event_queue_schedule (me, 1000,\n \t\t\t\t\t\t\ttx3904sio_poll, NULL);\n@@ -579,13 +579,13 @@ void\n tx3904sio_fifo_push(struct hw* me, struct tx3904sio_fifo* fifo, char it)\n {\n   /* HW_TRACE ((me, \"push %02x -> fifo\", it)); */\n-  if(fifo->size == fifo->used) /* full */\n+  if (fifo->size == fifo->used) /* full */\n     {\n       int next_size = fifo->size * 2 + 16;\n       unsigned_1* next_buf = zalloc(next_size);\n       memcpy(next_buf, fifo->buffer, fifo->used);\n \n-      if(fifo->buffer != NULL) free(fifo->buffer);\n+      if (fifo->buffer != NULL) free(fifo->buffer);\n       fifo->buffer = next_buf;\n       fifo->size = next_size;\n     }"
    },
    {
      "sha": "22b564cf302699ca5bbb823b694946ec650f2430",
      "filename": "sim/mips/dv-tx3904tmr.c",
      "status": "modified",
      "additions": 59,
      "deletions": 59,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dv-tx3904tmr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/dv-tx3904tmr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/dv-tx3904tmr.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -1,8 +1,8 @@\n /*  This file is part of the program GDB, the GNU debugger.\n-    \n+\n     Copyright (C) 1998-2022 Free Software Foundation, Inc.\n     Contributed by Cygnus Solutions.\n-    \n+\n     This program is free software; you can redistribute it and/or modify\n     it under the terms of the GNU General Public License as published by\n     the Free Software Foundation; either version 3 of the License, or\n@@ -15,7 +15,7 @@\n \n     You should have received a copy of the GNU General Public License\n     along with this program.  If not, see <http://www.gnu.org/licenses/>.\n-    \n+\n     */\n \n /* This must come before any other includes.  */\n@@ -27,20 +27,20 @@\n \n /* DEVICE\n \n-   \n+\n    tx3904tmr - tx3904 timer\n \n-   \n+\n    DESCRIPTION\n \n-   \n+\n    Implements one tx3904 timer/counter described in the tx3904\n    user guide.  Three instances are required for TMR0, TMR1, and\n-   TMR3 within the tx3904, at different base addresses.  \n+   TMR3 within the tx3904, at different base addresses.\n \n    Both internal and system clocks are synthesized as divided versions\n    of the simulator clock.\n-   \n+\n    There is no support for:\n     - edge sensitivity of external clock\n     - different mode restrictions for TMR0..2\n@@ -70,7 +70,7 @@\n    Rate of timer clock signal.  This number is the number of simulator\n    ticks per clock signal tick.  Default 1.\n \n-   \n+\n    ext <ticks>\n \n    Rate of \"external input clock signal\", the other clock input of the\n@@ -108,7 +108,7 @@ static void deliver_tx3904tmr_tick (struct hw *me, void *data);\n \n \n /* register numbers; each is one word long */\n-enum \n+enum\n {\n   TCR_REG = 0,\n   TISR_REG = 1,\n@@ -133,7 +133,7 @@ enum\n };\n \n \n-static const struct hw_port_descriptor tx3904tmr_ports[] = \n+static const struct hw_port_descriptor tx3904tmr_ports[] =\n {\n   { \"int\", INT_PORT, 0, output_port, },\n   { \"ff\", FF_PORT, 0, output_port, },\n@@ -228,10 +228,10 @@ attach_tx3904tmr_regs (struct hw *me,\n \t\t     attach_space, attach_address, attach_size,\n \t\t     me);\n \n-  if(hw_find_property(me, \"clock\") != NULL)\n+  if (hw_find_property(me, \"clock\") != NULL)\n     controller->clock_ticks = (unsigned_4) hw_find_integer_property(me, \"clock\");\n \n-  if(hw_find_property(me, \"ext\") != NULL)\n+  if (hw_find_property(me, \"ext\") != NULL)\n     controller->ext_ticks = (unsigned_4) hw_find_integer_property(me, \"ext\");\n \n   controller->base_address = attach_address;\n@@ -258,12 +258,12 @@ tx3904tmr_finish (struct hw *me)\n   attach_tx3904tmr_regs (me, controller);\n \n   /* Initialize to reset state */\n-  controller->tcr = \n+  controller->tcr =\n     controller->itmr =\n     controller->ccdr =\n-    controller->pmgr = \n+    controller->pmgr =\n     controller->wtmr =\n-    controller->tisr = \n+    controller->tisr =\n     controller->trr = 0;\n   controller->cpra = controller->cprb = 0x00FFFFFF;\n   controller->ff = 0;\n@@ -293,16 +293,16 @@ tx3904tmr_port_event (struct hw *me,\n \t/* preset flip-flop to FFI value */\n \tcontroller->ff = GET_PMGR_FFI(controller);\n \n-\tcontroller->tcr = \n+\tcontroller->tcr =\n \t  controller->itmr =\n \t  controller->ccdr =\n-\t  controller->pmgr = \n+\t  controller->pmgr =\n \t  controller->wtmr =\n-\t  controller->tisr = \n+\t  controller->tisr =\n \t  controller->trr = 0;\n \tcontroller->cpra = controller->cprb = 0x00FFFFFF;\n \tcontroller->last_ticks = controller->roundoff_ticks = 0;\n-\tif(controller->event != NULL)\n+\tif (controller->event != NULL)\n \t  hw_event_queue_deschedule(me, controller->event);\n \tcontroller->event = NULL;\n \tbreak;\n@@ -355,7 +355,7 @@ tx3904tmr_io_read_buffer (struct hw *me,\n     }\n \n   return nr_bytes;\n-}     \n+}\n \n \n \n@@ -381,58 +381,58 @@ tx3904tmr_io_write_buffer (struct hw *me,\n       switch (reg_number)\n \t{\n \tcase TCR_REG:\n-\t  if(reg_offset == 0) /* first byte */\n+\t  if (reg_offset == 0) /* first byte */\n \t    {\n \t      /* update register, but mask out NOP bits */\n \t      controller->tcr = (unsigned_4) (write_byte & 0xef);\n \n \t      /* Reset counter value if timer suspended and CRE is set. */\n-\t      if(GET_TCR_TCE(controller) == 0 &&\n+\t      if (GET_TCR_TCE(controller) == 0 &&\n \t\t GET_TCR_CRE(controller) == 1)\n \t\tcontroller->trr = 0;\n \t    }\n \t  /* HW_TRACE ((me, \"tcr: %08lx\", (long) controller->tcr)); */\n \t  break;\n \n \tcase ITMR_REG:\n-\t  if(reg_offset == 1) /* second byte */\n+\t  if (reg_offset == 1) /* second byte */\n \t    {\n \t      SET_ITMR_TIIE(controller, write_byte & 0x80);\n \t    }\n-\t  else if(reg_offset == 0) /* first byte */\n+\t  else if (reg_offset == 0) /* first byte */\n \t    {\n \t      SET_ITMR_TZCE(controller, write_byte & 0x01);\n \t    }\n \t  /* HW_TRACE ((me, \"itmr: %08lx\", (long) controller->itmr)); */\n \t  break;\n \n \tcase CCDR_REG:\n-\t  if(reg_offset == 0) /* first byte */\n+\t  if (reg_offset == 0) /* first byte */\n \t    {\n \t      controller->ccdr = write_byte & 0x07;\n \t    }\n \t  /* HW_TRACE ((me, \"ccdr: %08lx\", (long) controller->ccdr)); */\n \t  break;\n \n \tcase PMGR_REG:\n-\t  if(reg_offset == 1) /* second byte */\n+\t  if (reg_offset == 1) /* second byte */\n \t    {\n \t      SET_PMGR_TPIBE(controller, write_byte & 0x80);\n \t      SET_PMGR_TPIAE(controller, write_byte & 0x40);\n \t    }\n-\t  else if(reg_offset == 0) /* first byte */\n+\t  else if (reg_offset == 0) /* first byte */\n \t    {\n \t      SET_PMGR_FFI(controller, write_byte & 0x01);\n \t    }\n \t  /* HW_TRACE ((me, \"pmgr: %08lx\", (long) controller->pmgr)); */\n \t  break;\n \n \tcase WTMR_REG:\n-\t  if(reg_offset == 1) /* second byte */\n+\t  if (reg_offset == 1) /* second byte */\n \t    {\n \t      SET_WTMR_TWIE(controller, write_byte & 0x80);\n \t    }\n-\t  else if(reg_offset == 0) /* first byte */\n+\t  else if (reg_offset == 0) /* first byte */\n \t    {\n \t      SET_WTMR_WDIS(controller, write_byte & 0x80);\n \t      SET_WTMR_TWC(controller, write_byte & 0x01);\n@@ -441,40 +441,40 @@ tx3904tmr_io_write_buffer (struct hw *me,\n \t  break;\n \n \tcase TISR_REG:\n-\t  if(reg_offset == 0) /* first byte */\n+\t  if (reg_offset == 0) /* first byte */\n \t    {\n \t      /* All bits must be zero in given byte, according to\n                  spec. */\n \n \t      /* Send an \"interrupt off\" event on the interrupt port */\n-\t      if(controller->tisr != 0) /* any interrupts active? */\n+\t      if (controller->tisr != 0) /* any interrupts active? */\n \t\t{\n-\t\t  hw_port_event(me, INT_PORT, 0);\t\t  \n+\t\t  hw_port_event (me, INT_PORT, 0);\n \t\t}\n-\t      \n+\n \t      /* clear interrupt status register */\n \t      controller->tisr = 0;\n \t    }\n \t  /* HW_TRACE ((me, \"tisr: %08lx\", (long) controller->tisr)); */\n \t  break;\n \n \tcase CPRA_REG:\n-\t  if(reg_offset < 3) /* first, second, or third byte */\n+\t  if (reg_offset < 3) /* first, second, or third byte */\n \t    {\n \t      MBLIT32(controller->cpra, (reg_offset*8)+7, (reg_offset*8), write_byte);\n \t    }\n \t  /* HW_TRACE ((me, \"cpra: %08lx\", (long) controller->cpra)); */\n \t  break;\n \n \tcase CPRB_REG:\n-\t  if(reg_offset < 3) /* first, second, or third byte */\n+\t  if (reg_offset < 3) /* first, second, or third byte */\n \t    {\n \t      MBLIT32(controller->cprb, (reg_offset*8)+7, (reg_offset*8), write_byte);\n \t    }\n \t  /* HW_TRACE ((me, \"cprb: %08lx\", (long) controller->cprb)); */\n \t  break;\n \n-\tdefault: \n+\tdefault:\n \t  HW_TRACE ((me, \"write to illegal register %d\", reg_number));\n \t}\n     } /* loop over bytes */\n@@ -484,7 +484,7 @@ tx3904tmr_io_write_buffer (struct hw *me,\n   hw_event_queue_schedule(me, 1, deliver_tx3904tmr_tick, NULL);\n \n   return nr_bytes;\n-}     \n+}\n \n \n \n@@ -502,39 +502,39 @@ deliver_tx3904tmr_tick (struct hw *me,\n   signed_8 quotient, remainder;\n \n   /* compute simulation ticks between last tick and this tick */\n-  if(controller->last_ticks != 0)\n+  if (controller->last_ticks != 0)\n     warp = this_ticks - controller->last_ticks + controller->roundoff_ticks;\n   else\n     {\n       controller->last_ticks = this_ticks; /* initialize */\n       warp = controller->roundoff_ticks;\n     }\n \n-  if(controller->event != NULL)\n+  if (controller->event != NULL)\n     hw_event_queue_deschedule(me, controller->event);\n   controller->event = NULL;\n \n   /* Check whether the timer ticking is enabled at this moment.  This\n      largely a function of the TCE bit, but is also slightly\n      mode-dependent. */\n-  switch((int) GET_TCR_TMODE(controller))\n+  switch ((int) GET_TCR_TMODE(controller))\n     {\n     case 0: /* interval */\n       /* do not advance counter if TCE = 0 or if holding at count = CPRA */\n-      if(GET_TCR_TCE(controller) == 0 ||\n+      if (GET_TCR_TCE(controller) == 0 ||\n \t controller->trr == controller->cpra)\n \treturn;\n       break;\n \n     case 1: /* pulse generator */\n       /* do not advance counter if TCE = 0 */\n-      if(GET_TCR_TCE(controller) == 0)\n+      if (GET_TCR_TCE(controller) == 0)\n \treturn;\n       break;\n \n     case 2: /* watchdog */\n       /* do not advance counter if TCE = 0 and WDIS = 1 */\n-      if(GET_TCR_TCE(controller) == 0 &&\n+      if (GET_TCR_TCE(controller) == 0 &&\n \t GET_WTMR_WDIS(controller) == 1)\n \treturn;\n       break;\n@@ -550,11 +550,11 @@ deliver_tx3904tmr_tick (struct hw *me,\n      reschedule dummy events here. */\n \n \n-  /* find appropriate divisor etc. */ \n-  if(GET_TCR_CCS(controller) == 0) /* internal system clock */\n+  /* find appropriate divisor etc. */\n+  if (GET_TCR_CCS(controller) == 0) /* internal system clock */\n     {\n       /* apply internal clock divider */\n-      if(GET_TCR_CCDE(controller)) /* divisor circuit enabled? */\n+      if (GET_TCR_CCDE(controller)) /* divisor circuit enabled? */\n \tdivisor = controller->clock_ticks * (1 << (1 + GET_CCDR_CDR(controller)));\n       else\n \tdivisor = controller->clock_ticks;\n@@ -582,35 +582,35 @@ deliver_tx3904tmr_tick (struct hw *me,\n       /* next 24-bit counter value */\n       unsigned_4 next_trr = (controller->trr + 1) % (1 << 24);\n       quotient --;\n-      \n-      switch((int) GET_TCR_TMODE(controller))\n+\n+      switch ((int) GET_TCR_TMODE(controller))\n \t{\n \tcase 0: /* interval timer mode */\n \t  {\n \t    /* Current or next counter value matches CPRA value?  The\n \t       first case covers counter holding at maximum before\n \t       reset.  The second case covers normal counting\n \t       behavior. */\n-\t    if(controller->trr == controller->cpra ||\n+\t    if (controller->trr == controller->cpra ||\n \t       next_trr == controller->cpra)\n \t      {\n \t\t/* likely hold CPRA value */\n-\t\tif(controller->trr == controller->cpra)\n+\t\tif (controller->trr == controller->cpra)\n \t\t  next_trr = controller->cpra;\n \n \t\tSET_TISR_TIIS(controller);\n \n \t\t/* Signal an interrupt if it is enabled with TIIE,\n \t\t   and if we just arrived at CPRA.  Don't repeatedly\n \t\t   interrupt if holding due to TZCE=0 */\n-\t\tif(GET_ITMR_TIIE(controller) &&\n+\t\tif (GET_ITMR_TIIE(controller) &&\n \t\t   next_trr != controller->trr)\n \t\t  {\n \t\t    hw_port_event(me, INT_PORT, 1);\n \t\t  }\n \n \t\t/* Reset counter? */\n-\t\tif(GET_ITMR_TZCE(controller))\n+\t\tif (GET_ITMR_TZCE(controller))\n \t\t  {\n \t\t    next_trr = 0;\n \t\t  }\n@@ -621,30 +621,30 @@ deliver_tx3904tmr_tick (struct hw *me,\n \tcase 1: /* pulse generator mode */\n \t  {\n \t    /* first trip point */\n-\t    if(next_trr == controller->cpra)\n+\t    if (next_trr == controller->cpra)\n \t      {\n \t\t/* flip flip-flop & report */\n \t\tcontroller->ff ^= 1;\n \t\thw_port_event(me, FF_PORT, controller->ff);\n \t\tSET_TISR_TPIAS(controller);\n \n \t\t/* signal interrupt */\n-\t\tif(GET_PMGR_TPIAE(controller))\n+\t\tif (GET_PMGR_TPIAE(controller))\n \t\t  {\n \t\t    hw_port_event(me, INT_PORT, 1);\n \t\t  }\n \n \t      }\n \t    /* second trip point */\n-\t    else if(next_trr == controller->cprb)\n+\t    else if (next_trr == controller->cprb)\n \t      {\n \t\t/* flip flip-flop & report */\n \t\tcontroller->ff ^= 1;\n \t\thw_port_event(me, FF_PORT, controller->ff);\n \t\tSET_TISR_TPIBS(controller);\n \n \t\t/* signal interrupt */\n-\t\tif(GET_PMGR_TPIBE(controller))\n+\t\tif (GET_PMGR_TPIBE(controller))\n \t\t  {\n \t\t    hw_port_event(me, INT_PORT, 1);\n \t\t  }\n@@ -658,12 +658,12 @@ deliver_tx3904tmr_tick (struct hw *me,\n \tcase 2: /* watchdog timer mode */\n \t  {\n \t    /* watchdog timer expiry */\n-\t    if(next_trr == controller->cpra)\n+\t    if (next_trr == controller->cpra)\n \t      {\n \t\tSET_TISR_TWIS(controller);\n \n \t\t/* signal interrupt */\n-\t\tif(GET_WTMR_TWIE(controller))\n+\t\tif (GET_WTMR_TWIE(controller))\n \t\t  {\n \t\t    hw_port_event(me, INT_PORT, 1);\n \t\t  }"
    },
    {
      "sha": "ede1e261d7437846c329e0a1f9940b433fcbfab2",
      "filename": "sim/mips/interp.c",
      "status": "modified",
      "additions": 73,
      "deletions": 73,
      "changes": 146,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/interp.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -69,7 +69,7 @@ char* pr_uword64 (uword64 addr);\n #define RSVD_INSTRUCTION_MASK      (0xFC00003F)\n \n #define RSVD_INSTRUCTION_ARG_SHIFT 6\n-#define RSVD_INSTRUCTION_ARG_MASK  0xFFFFF  \n+#define RSVD_INSTRUCTION_ARG_MASK  0xFFFFF\n \n \n /* Bits in the Debug register */\n@@ -122,13 +122,13 @@ static void ColdReset (SIM_DESC sd);\n #define K1SIZE  (0x20000000)\n \n /* Simple run-time monitor support.\n-   \n+\n    We emulate the monitor by placing magic reserved instructions at\n    the monitor's entry points; when we hit these instructions, instead\n    of raising an exception (as we would normally), we look at the\n    instruction and perform the appropriate monitory operation.\n-   \n-   `*_monitor_base' are the physical addresses at which the corresponding \n+\n+   `*_monitor_base' are the physical addresses at which the corresponding\n         monitor vectors are located.  `0' means none.  By default,\n         install all three.\n     The RSVD_INSTRUCTION... macros specify the magic instructions we\n@@ -245,7 +245,7 @@ Re-compile simulator with \\\"-DWITH_TRACE_ANY_P\\\" to enable this option.\\n\");\n       display_mem_info = 1;\n       break;\n     }\n-  \n+\n   return SIM_RC_OK;\n }\n \n@@ -288,7 +288,7 @@ static const OPTION mips_options[] =\n     '\\0', NULL, \"List configured memory regions\", mips_option_handler },\n   { { \"memory-info\", no_argument, NULL, OPTION_INFO_MEMORY },\n     '\\0', NULL, NULL, mips_option_handler },\n-  \n+\n   { {NULL, no_argument, NULL, 0}, '\\0', NULL, NULL, NULL }\n };\n \n@@ -364,7 +364,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n   CPU_MAX_INSNS (cpu) = nr_itable_entries;\n \n   STATE = 0;\n-  \n+\n   if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)\n     return 0;\n   sim_add_option_table (sd, NULL, mips_options);\n@@ -430,7 +430,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n \t      /* Delete old region. */\n \t      sim_do_commandf (sd, \"memory delete %d:0x%\" PRIxTW \"@%d\",\n \t\t\t       match->space, match->addr, match->level);\n-\t    }\t      \n+\t    }\n \t  else if (mem_size == 0)\n \t    mem_size = MEM_SIZE;\n \t  /* Limit to KSEG1 size (512MB) */\n@@ -455,13 +455,13 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n \n       /* ROM: 0x9FC0_0000 - 0x9FFF_FFFF and 0xBFC0_0000 - 0xBFFF_FFFF */\n       sim_do_commandf (sd, \"memory alias 0x%x@1,0x%x,0x%0x\",\n-\t\t       0x9FC00000, \n+\t\t       0x9FC00000,\n \t\t       4 * 1024 * 1024, /* 4 MB */\n \t\t       0xBFC00000);\n \n       /* SRAM: 0x8000_0000 - 0x803F_FFFF and 0xA000_0000 - 0xA03F_FFFF */\n       sim_do_commandf (sd, \"memory alias 0x%x@1,0x%x,0x%0x\",\n-\t\t       0x80000000, \n+\t\t       0x80000000,\n \t\t       4 * 1024 * 1024, /* 4 MB */\n \t\t       0xA0000000);\n \n@@ -470,8 +470,8 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n \t{\n \t  unsigned size = 4 * 1024 * 1024;  /* 4 MB */\n \t  sim_do_commandf (sd, \"memory alias 0x%x@1,0x%x,0x%0x\",\n-\t\t\t   0x88000000 + (i * size), \n-\t\t\t   size, \n+\t\t\t   0x88000000 + (i * size),\n+\t\t\t   size,\n \t\t\t   0xA8000000 + (i * size));\n \t}\n     }\n@@ -501,13 +501,13 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n \n       /* ROM: 0x9FC0_0000 - 0x9FFF_FFFF and 0xBFC0_0000 - 0xBFFF_FFFF */\n       sim_do_commandf (sd, \"memory alias 0x%x@1,0x%x,0x%0x\",\n-\t\t       0x9FC00000, \n+\t\t       0x9FC00000,\n \t\t       4 * 1024 * 1024, /* 4 MB */\n \t\t       0xBFC00000);\n \n       /* SRAM: 0x8000_0000 - 0x803F_FFFF and 0xA000_0000 - 0xA03F_FFFF */\n       sim_do_commandf (sd, \"memory alias 0x%x@1,0x%x,0x%0x\",\n-\t\t       0x80000000, \n+\t\t       0x80000000,\n \t\t       4 * 1024 * 1024, /* 4 MB */\n \t\t       0xA0000000);\n \n@@ -516,8 +516,8 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n \t{\n \t  unsigned size = 4 * 1024 * 1024;  /* 4 MB */\n \t  sim_do_commandf (sd, \"memory alias 0x%x@1,0x%x,0x%0x\",\n-\t\t\t   0x88000000 + (i * size), \n-\t\t\t   size, \n+\t\t\t   0x88000000 + (i * size),\n+\t\t\t   size,\n \t\t\t   0xA8000000 + (i * size));\n \t}\n \n@@ -566,7 +566,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n       sim_hw_parse (sd, \"/tx3904sio@0xfffff400 > int sio1 /tx3904irc\");\n \n       /* add PAL timer & I/O module */\n-      if(! strcmp(board, BOARD_JMR3904_PAL))\n+      if (!strcmp(board, BOARD_JMR3904_PAL))\n \t{\n \t /* the device */\n \t sim_hw_parse (sd, \"/pal@0xffff0000\");\n@@ -578,7 +578,7 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n \t sim_hw_parse (sd, \"/pal@0x31000000 > int int0 /tx3904irc\");\n \t}\n \n-      if(! strcmp(board, BOARD_JMR3904_DEBUG))\n+      if (!strcmp(board, BOARD_JMR3904_DEBUG))\n \t{\n \t  /* -- DEBUG: glue interrupt generators --- */\n \t  sim_hw_parse (sd, \"/glue@0xffff0000/reg 0xffff0000 0x50\");\n@@ -688,9 +688,9 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n     open_trace(sd);\n \n   /*\n-  sim_io_eprintf (sd, \"idt@%x pmon@%x lsipmon@%x\\n\", \n+  sim_io_eprintf (sd, \"idt@%x pmon@%x lsipmon@%x\\n\",\n \t\t  idt_monitor_base,\n-\t\t  pmon_monitor_base, \n+\t\t  pmon_monitor_base,\n \t\t  lsipmon_monitor_base);\n   */\n \n@@ -783,8 +783,8 @@ sim_open (SIM_OPEN_KIND kind, host_callback *cb,\n   /* Write an abort sequence into the TRAP (common) exception vector\n      addresses.  This is to catch code executing a TRAP (et.al.)\n      instruction without installing a trap handler. */\n-  if ((idt_monitor_base != 0) || \n-      (pmon_monitor_base != 0) || \n+  if ((idt_monitor_base != 0) ||\n+      (pmon_monitor_base != 0) ||\n       (lsipmon_monitor_base != 0))\n     {\n       unsigned32 halt[2] = { 0x2404002f /* addiu r4, r0, 47 */,\n@@ -868,7 +868,7 @@ mips_reg_store (SIM_CPU *cpu, int rn, unsigned char *memory, int length)\n \t{\n \t  if (length == 8)\n \t    {\n-\t      cpu->fgr[rn - FGR_BASE] = \n+\t      cpu->fgr[rn - FGR_BASE] =\n \t\t(unsigned32) T2H_8 (*(unsigned64*)memory);\n \t      return 8;\n \t    }\n@@ -1096,7 +1096,7 @@ sim_firmware_command (SIM_DESC sd, char *arg)\n \tp ++; /* skip over @ */\n \n \taddress = strtoul (p, &q, 0);\n-\tif (*q != '\\0') \n+\tif (*q != '\\0')\n \t  {\n \t    sim_io_printf (sd, \"Invalid address given to the\"\n \t\t\t   \"`sim firmware NAME@ADDRESS' command: %s\\n\",\n@@ -1152,7 +1152,7 @@ Recognized firmware names are: `idt', `pmon', `lsipmon', and `none'.\\n\",\n \t\t     arg);\n       return SIM_RC_FAIL;\n     }\n-  \n+\n   return SIM_RC_OK;\n }\n \n@@ -1340,7 +1340,7 @@ sim_monitor (SIM_DESC sd,\n \tsim_memopt *entry, *match = NULL;\n \n \t/* Search for memory region mapped to KSEG0 or KSEG1. */\n-\tfor (entry = STATE_MEMOPT (sd); \n+\tfor (entry = STATE_MEMOPT (sd);\n \t     entry != NULL;\n \t     entry = entry->next)\n \t  {\n@@ -1350,7 +1350,7 @@ sim_monitor (SIM_DESC sd,\n \t    else\n \t      {\n \t\tsim_memopt *alias;\n-\t\tfor (alias = entry->alias; \n+\t\tfor (alias = entry->alias;\n \t\t     alias != NULL;\n \t\t     alias = alias->next)\n \t\t  if ((alias->addr == K0BASE || alias->addr == K1BASE)\n@@ -1374,7 +1374,7 @@ sim_monitor (SIM_DESC sd,\n \t/* sim_io_eprintf (sd, \"sim: get_mem_info() deprecated\\n\"); */\n \tbreak;\n       }\n-    \n+\n     case 158: /* PMON printf */\n       /* in:  A0 = pointer to format string */\n       /*      A1 = optional argument 1 */\n@@ -1666,11 +1666,11 @@ mips16_entry (SIM_DESC sd,\n \t      FPR_STATE[0] = fmt_uninterpreted;\n \t      FPR_STATE[1] = fmt_uninterpreted;\n \t    }\n-\t}\t  \n+\t}\n \n       PC = RA;\n     }\n-  \n+\n }\n \n /*-- trace support ----------------------------------------------------------*/\n@@ -1723,7 +1723,7 @@ dotrace (SIM_DESC sd,\n {\n   if (STATE & simTRACE) {\n     va_list ap;\n-    fprintf(tracefh,\"%d %s ; width %d ; \", \n+    fprintf(tracefh,\"%d %s ; width %d ; \",\n \t\ttype,\n \t\tpr_addr(address),\n \t\twidth);\n@@ -1764,27 +1764,27 @@ ColdReset (SIM_DESC sd)\n       /* RESET: Fixed PC address: */\n       PC = (unsigned_word) UNSIGNED64 (0xFFFFFFFFBFC00000);\n       /* The reset vector address is in the unmapped, uncached memory space. */\n-      \n+\n       SR &= ~(status_SR | status_TS | status_RP);\n       SR |= (status_ERL | status_BEV);\n-      \n+\n       /* Cheat and allow access to the complete register set immediately */\n       if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT\n \t  && WITH_TARGET_WORD_BITSIZE == 64)\n \tSR |= status_FR; /* 64bit registers */\n-      \n+\n       /* Ensure that any instructions with pending register updates are\n \t cleared: */\n       PENDING_INVALIDATE();\n-      \n+\n       /* Initialise the FPU registers to the unknown state */\n       if (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT)\n \t{\n \t  int rn;\n \t  for (rn = 0; (rn < 32); rn++)\n \t    FPR_STATE[rn] = fmt_uninterpreted;\n \t}\n-      \n+\n       /* Initialise the Config0 register. */\n       C0_CONFIG = 0x80000000 \t\t/* Config1 present */\n \t| 2;\t\t\t\t/* KSEG0 uncached */\n@@ -1838,7 +1838,7 @@ signal_exception (SIM_DESC sd,\n           if (INDELAYSLOT())\n             {\n               CANCELDELAYSLOT();\n-              \n+\n               Debug |= Debug_DBD;  /* signaled from within in delay slot */\n               DEPC = cia - 4;      /* reference the branch instruction */\n             }\n@@ -1847,7 +1847,7 @@ signal_exception (SIM_DESC sd,\n               Debug &= ~Debug_DBD; /* not signaled from within a delay slot */\n               DEPC = cia;\n             }\n-        \n+\n           Debug |= Debug_DM;            /* in debugging mode */\n           Debug |= Debug_DBp;           /* raising a DBp exception */\n           PC = 0xBFC00200;\n@@ -1991,7 +1991,7 @@ signal_exception (SIM_DESC sd,\n        case FPE:\n \t sim_engine_halt (SD, CPU, NULL, PC,\n \t\t\t  sim_stopped, SIM_SIGFPE);\n-\t \n+\n        case BreakPoint:\n \t sim_engine_halt (SD, CPU, NULL, PC, sim_stopped, SIM_SIGTRAP);\n \t break;\n@@ -2040,7 +2040,7 @@ signal_exception (SIM_DESC sd,\n    that are UNPREDICTABLE. ...\"  (MIPS64 Architecture for Programmers\n    Volume II, The MIPS64 Instruction Set.  MIPS Document MD00087 revision\n    0.95, page 2.)\n-  \n+\n    For UNPREDICTABLE behaviour, we print a message, if possible print\n    the offending instructions mips.igen instruction name (provided by\n    the caller), and stop the simulator.\n@@ -2106,7 +2106,7 @@ cop_ld (SIM_DESC sd,\n {\n \n #ifdef DEBUG\n-  printf(\"DBG: COP_LD: coproc_num = %d, coproc_reg = %d, value = 0x%s : PC = 0x%s\\n\", coproc_num, coproc_reg, pr_uword64(memword), pr_addr(cia) );\n+  printf(\"DBG: COP_LD: coproc_num = %d, coproc_reg = %d, value = 0x%s : PC = 0x%s\\n\", coproc_num, coproc_reg, pr_uword64(memword), pr_addr(cia));\n #endif\n \n   switch (coproc_num) {\n@@ -2314,7 +2314,7 @@ decode_coproc (SIM_DESC sd,\n \t\t/* 29 = TagHi              R4000   VR4100  VR4300 */\n \t\t/* 30 = ErrorEPC           R4000   VR4100  VR4300 */\n \t\tif (STATE_VERBOSE_P(SD))\n-\t\t  sim_io_eprintf (SD, \n+\t\t  sim_io_eprintf (SD,\n \t\t\t\t  \"Warning: PC 0x%lx:interp.c decode_coproc DEADC0DE\\n\",\n \t\t\t\t  (unsigned long)cia);\n \t\tGPR[rt] = 0xDEADC0DE; /* CPR[0,rd] */\n@@ -2343,23 +2343,23 @@ decode_coproc (SIM_DESC sd,\n \t\tcfg = C0_CONFIG;\n \t\tbreak;\n \t      case 1:\n-\t\t/* MIPS32 r/o Config1: \n+\t\t/* MIPS32 r/o Config1:\n \t\t   Config2 present */\n \t\tcfg = 0x80000000;\n-\t\t/* MIPS16 implemented. \n+\t\t/* MIPS16 implemented.\n \t\t   XXX How to check configuration? */\n \t\tcfg |= 0x0000004;\n \t\tif (CURRENT_FLOATING_POINT == HARD_FLOATING_POINT)\n \t\t  /* MDMX & FPU implemented */\n \t\t  cfg |= 0x00000021;\n \t\tbreak;\n \t      case 2:\n-\t\t/* MIPS32 r/o Config2: \n+\t\t/* MIPS32 r/o Config2:\n \t\t   Config3 present. */\n \t\tcfg = 0x80000000;\n \t\tbreak;\n \t      case 3:\n-\t\t/* MIPS32 r/o Config3: \n+\t\t/* MIPS32 r/o Config3:\n \t\t   SmartMIPS implemented. */\n \t\tcfg = 0x00000002;\n \t\tbreak;\n@@ -2408,26 +2408,26 @@ decode_coproc (SIM_DESC sd,\n            read/modify/write sequence fails. */\n       }\n     break;\n-    \n+\n     case 2: /* co-processor 2 */\n       {\n \tint handle = 0;\n \n \n-\tif(! handle)\n+\tif (!handle)\n \t  {\n \t    sim_io_eprintf(sd, \"COP2 instruction 0x%08X at PC = 0x%s : No handler present\\n\",\n \t\t\t   instruction,pr_addr(cia));\n \t  }\n       }\n     break;\n-    \n+\n     case 1: /* should not occur (FPU co-processor) */\n     case 3: /* should not occur (FPU co-processor) */\n       SignalException(ReservedInstruction,instruction);\n       break;\n     }\n-  \n+\n   return;\n }\n \n@@ -2445,14 +2445,14 @@ get_cell (void)\n   static int cell=0;\n   if (++cell>=NUMCELLS) cell=0;\n   return buf[cell];\n-}     \n+}\n \n /* Print routines to handle variable size regs, etc */\n \n /* Eliminate warning from compiler on 32-bit systems */\n-static int thirty_two = 32;\t\n+static int thirty_two = 32;\n \n-char* \n+char*\n pr_addr (SIM_ADDR addr)\n {\n   char *paddr_str=get_cell();\n@@ -2474,7 +2474,7 @@ pr_addr (SIM_ADDR addr)\n   return paddr_str;\n }\n \n-char* \n+char*\n pr_uword64 (uword64 addr)\n {\n   char *paddr_str=get_cell();\n@@ -2501,18 +2501,18 @@ mips_core_signal (SIM_DESC sd,\n     {\n     case sim_core_unmapped_signal:\n       sim_io_eprintf (sd, \"mips-core: %d byte %s to unmapped address 0x%lx at 0x%lx\\n\",\n-                      nr_bytes, copy, \n+                      nr_bytes, copy,\n \t\t      (unsigned long) addr, (unsigned long) ip);\n       COP0_BADVADDR = addr;\n       SignalExceptionDataReference();\n       break;\n \n     case sim_core_unaligned_signal:\n       sim_io_eprintf (sd, \"mips-core: %d byte %s to unaligned address 0x%lx at 0x%lx\\n\",\n-                      nr_bytes, copy, \n+                      nr_bytes, copy,\n \t\t      (unsigned long) addr, (unsigned long) ip);\n       COP0_BADVADDR = addr;\n-      if(transfer == read_transfer) \n+      if (transfer == read_transfer)\n \tSignalExceptionAddressLoad();\n       else\n \tSignalExceptionAddressStore();\n@@ -2530,8 +2530,8 @@ mips_cpu_exception_trigger(SIM_DESC sd, sim_cpu* cpu, address_word cia)\n {\n   ASSERT(cpu != NULL);\n \n-  if(cpu->exc_suspended > 0)\n-    sim_io_eprintf(sd, \"Warning, nested exception triggered (%d)\\n\", cpu->exc_suspended); \n+  if (cpu->exc_suspended > 0)\n+    sim_io_eprintf(sd, \"Warning, nested exception triggered (%d)\\n\", cpu->exc_suspended);\n \n   PC = cia;\n   memcpy(cpu->exc_trigger_registers, cpu->registers, sizeof(cpu->exc_trigger_registers));\n@@ -2543,9 +2543,9 @@ mips_cpu_exception_suspend(SIM_DESC sd, sim_cpu* cpu, int exception)\n {\n   ASSERT(cpu != NULL);\n \n-  if(cpu->exc_suspended > 0)\n-    sim_io_eprintf(sd, \"Warning, nested exception signal (%d then %d)\\n\", \n-\t\t   cpu->exc_suspended, exception); \n+  if (cpu->exc_suspended > 0)\n+    sim_io_eprintf(sd, \"Warning, nested exception signal (%d then %d)\\n\",\n+\t\t   cpu->exc_suspended, exception);\n \n   memcpy(cpu->exc_suspend_registers, cpu->registers, sizeof(cpu->exc_suspend_registers));\n   memcpy(cpu->registers, cpu->exc_trigger_registers, sizeof(cpu->registers));\n@@ -2557,26 +2557,26 @@ mips_cpu_exception_resume(SIM_DESC sd, sim_cpu* cpu, int exception)\n {\n   ASSERT(cpu != NULL);\n \n-  if(exception == 0 && cpu->exc_suspended > 0)\n+  if (exception == 0 && cpu->exc_suspended > 0)\n     {\n       /* warn not for breakpoints */\n-      if(cpu->exc_suspended != sim_signal_to_host(sd, SIM_SIGTRAP))\n+      if (cpu->exc_suspended != sim_signal_to_host(sd, SIM_SIGTRAP))\n \tsim_io_eprintf(sd, \"Warning, resuming but ignoring pending exception signal (%d)\\n\",\n-\t\t       cpu->exc_suspended); \n+\t\t       cpu->exc_suspended);\n     }\n-  else if(exception != 0 && cpu->exc_suspended > 0)\n+  else if (exception != 0 && cpu->exc_suspended > 0)\n     {\n-      if(exception != cpu->exc_suspended) \n+      if (exception != cpu->exc_suspended)\n \tsim_io_eprintf(sd, \"Warning, resuming with mismatched exception signal (%d vs %d)\\n\",\n-\t\t       cpu->exc_suspended, exception); \n-      \n-      memcpy(cpu->registers, cpu->exc_suspend_registers, sizeof(cpu->registers)); \n+\t\t       cpu->exc_suspended, exception);\n+\n+      memcpy(cpu->registers, cpu->exc_suspend_registers, sizeof(cpu->registers));\n     }\n-  else if(exception != 0 && cpu->exc_suspended == 0)\n+  else if (exception != 0 && cpu->exc_suspended == 0)\n     {\n-      sim_io_eprintf(sd, \"Warning, ignoring spontanous exception signal (%d)\\n\", exception); \n+      sim_io_eprintf(sd, \"Warning, ignoring spontanous exception signal (%d)\\n\", exception);\n     }\n-  cpu->exc_suspended = 0; \n+  cpu->exc_suspended = 0;\n }\n \n "
    },
    {
      "sha": "3641e3652bc13b5341ee3a068ee24cffd863dd6d",
      "filename": "sim/mips/m16.igen",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/m16.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/m16.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/m16.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -860,17 +860,17 @@\n {\n   do_dsll (SD_, TRY, TRX, SHIFT);\n }\n-  \n+\n 11110,5.SHAMT_4_0,1.S5,00000 + 00110,3.RX,3.RY,000,01:EXT-SHIFT:16::DSLL\n \"dsll r<TRY>, r<TRX>, <SHAMT>\"\n *mips16:\n *vr4100:\n {\n   do_dsll (SD_, TRY, TRX, SHAMT);\n }\n-  \n-  \n-  \n+\n+\n+\n 11101,3.SHAMT,3.RY,01000:SHIFT64:16::DSRL\n \"dsrl r<TRY>, <SHIFT>\"\n *mips16:\n@@ -1043,7 +1043,7 @@\n   STATE &= ~simDELAYSLOT;\n   return target;\n }\n-  \n+\n // compute basepc dependant on us being in a delay slot\n :function:::address_word:basepc:\n {"
    },
    {
      "sha": "afd0e1f8f6c40257cf32ec8d5feaafb5d44ae97b",
      "filename": "sim/mips/m16e.igen",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/m16e.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/m16e.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/m16e.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -2,11 +2,11 @@\n \n // Simulator definition for the MIPS16e instructions.\n // Copyright (C) 2005-2022 Free Software Foundation, Inc.\n-// Contributed by Nigel Stephens (nigel@mips.com) and \n+// Contributed by Nigel Stephens (nigel@mips.com) and\n //                David Ung (davidu@mips.com) of MIPS Technologies.\n //\n // This file is part of GDB, the GNU debugger.\n-// \n+//\n // This program is free software; you can redistribute it and/or modify\n // it under the terms of the GNU General Public License as published by\n // the Free Software Foundation; either version 3 of the License, or\n@@ -168,7 +168,7 @@\n \n :function:::void:do_save:int xsregs, int aregs, int ras0s1, int framesize\n {\n-  unsigned_word temp;    \n+  unsigned_word temp;\n   int args, astatic;\n \n   temp = GPR[29];\n@@ -194,11 +194,11 @@\n     sim_engine_abort (SD, CPU, CIA, \"save: aregs=%d causes unpredictable results\\n\", aregs);\n   }\n   if (args > 0) {\n-    do_store (SD_, AccessLength_WORD, temp, 0, GPR[4]); \n+    do_store (SD_, AccessLength_WORD, temp, 0, GPR[4]);\n     if (args > 1) {\n-      do_store (SD_,AccessLength_WORD, temp, 4 , GPR[5]); \n+      do_store (SD_,AccessLength_WORD, temp, 4 , GPR[5]);\n       if (args > 2) {\n-\tdo_store (SD_,AccessLength_WORD, temp, 8 , GPR[6]); \n+\tdo_store (SD_,AccessLength_WORD, temp, 8 , GPR[6]);\n \tif (args > 3) {\n \t  do_store (SD_,AccessLength_WORD, temp, 12, GPR[7]);\n \t}\n@@ -207,29 +207,29 @@\n   }\n \n   if (ras0s1 & 4)\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[31]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[31]);\n \n   switch (xsregs) {\n   case 7:\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[30]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[30]);\n   case 6:\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[23]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[23]);\n   case 5:\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[22]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[22]);\n   case 4:\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[21]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[21]);\n   case 3:\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[20]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[20]);\n   case 2:\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[19]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[19]);\n   case 1:\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[18]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[18]);\n   }\n \n   if (ras0s1 & 1)\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[17]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[17]);\n   if (ras0s1 & 2)\n-    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[16]); \n+    do_store (SD_,AccessLength_WORD, temp -= 4, 0, GPR[16]);\n \n   switch (aregs) {\n   case 0: case 4: case 8: case 12: case 14:\n@@ -285,7 +285,7 @@\n :function:::void:do_restore:int xsregs, int aregs, int ras0s1, int framesize\n *mips16e\n {\n-  unsigned_word temp, temp2;    \n+  unsigned_word temp, temp2;\n   int astatic;\n \n   temp = GPR[29] + framesize;\n@@ -298,25 +298,25 @@\n \n   switch (xsregs) {\n   case 7:\n-    GPR[30] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[30] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n   case 6:\n-    GPR[23] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[23] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n   case 5:\n-    GPR[22] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[22] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n   case 4:\n-    GPR[21] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[21] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n   case 3:\n-    GPR[20] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[20] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n   case 2:\n-    GPR[19] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[19] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n   case 1:\n-    GPR[18] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[18] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n   }\n \n   if (ras0s1 & 1)\n-    GPR[17] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[17] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n   if (ras0s1 & 2)\n-    GPR[16] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0)); \n+    GPR[16] = EXTEND32 (do_load (SD_,AccessLength_WORD, temp -= 4, 0));\n \n   switch (aregs) {\n   case 0: case 4: case 8: case 12: case 14:\n@@ -356,7 +356,7 @@\n 01100,100,0,3.RAS,4.FS:I8:16::RESTORE\n \"restore %s<RAS>,<SFRAME>\"\n *mips16e\n-{ \n+{\n   do_restore (SD_,0,0,RAS,SFRAME);\n }\n "
    },
    {
      "sha": "c8caeb1d2da30e2a58373744a7683626a84ccb63",
      "filename": "sim/mips/m16run.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/m16run.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/m16run.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/m16run.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -11,10 +11,10 @@\n     but WITHOUT ANY WARRANTY; without even the implied warranty of\n     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n     GNU General Public License for more details.\n- \n+\n     You should have received a copy of the GNU General Public License\n     along with this program; if not, see <http://www.gnu.org/licenses/>.\n- \n+\n     */\n \n /* This must come before any other includes.  */"
    },
    {
      "sha": "41830ecb7690c821159e9c0bb205d8c687071dc1",
      "filename": "sim/mips/mdmx.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mdmx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mdmx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mdmx.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -40,16 +40,16 @@ along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n    The 24-bit accumulators are signed and are represented as 32-bit\n    signed values, which are reduced to 24-bit signed values prior to\n    Round and Clamp operations.\n-  \n+\n    A 16-bit packed halfword element (QH) is always signed.\n    The 48-bit accumulators are signed and are represented as 64-bit\n    signed values, which are reduced to 48-bit signed values prior to\n    Round and Clamp operations.\n-  \n+\n    The code below assumes a 2's-complement representation of signed\n    quantities.  Care is required to clear extended sign bits when\n    repacking fields.\n-  \n+\n    The code (and the code for arithmetic shifts in mips.igen) also makes\n    the (not guaranteed portable) assumption that right shifts of signed\n    quantities in C do sign extension.  */\n@@ -374,7 +374,7 @@ mdmx_cpr_op(sim_cpu *cpu,\n \t    int op,\n \t    unsigned64 op1,\n \t    int vt,\n-\t    MX_fmtsel fmtsel) \n+\t    MX_fmtsel fmtsel)\n {\n   unsigned64 op2;\n   unsigned64 result = 0;\n@@ -849,7 +849,7 @@ mdmx_acc_op(sim_cpu *cpu,\n \t    int op,\n \t    unsigned64 op1,\n \t    int vt,\n-\t    MX_fmtsel fmtsel) \n+\t    MX_fmtsel fmtsel)\n {\n   unsigned64 op2;\n \n@@ -897,7 +897,7 @@ unsigned64\n mdmx_rac_op(sim_cpu *cpu,\n \t    address_word cia,\n \t    int op,\n-\t    int fmt) \n+\t    int fmt)\n {\n   unsigned64    result;\n   unsigned int  shift;\n@@ -935,7 +935,7 @@ mdmx_wacl(sim_cpu *cpu,\n \t  address_word cia,\n \t  int fmt,\n \t  unsigned64 vs,\n-\t  unsigned64 vt) \n+\t  unsigned64 vt)\n {\n   int           i;\n \n@@ -1330,7 +1330,7 @@ mdmx_round_op(sim_cpu *cpu,\n \t      address_word cia,\n \t      int rm,\n \t      int vt,\n-\t      MX_fmtsel fmtsel) \n+\t      MX_fmtsel fmtsel)\n {\n   unsigned64 op2;\n   unsigned64 result = 0;"
    },
    {
      "sha": "fb9bef3bac1e2843d968c6b32de8395c26fcf5c9",
      "filename": "sim/mips/mdmx.igen",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mdmx.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mdmx.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mdmx.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -6,7 +6,7 @@\n // Corporation (SiByte).\n //\n // This file is part of GDB, the GNU debugger.\n-// \n+//\n // This program is free software; you can redistribute it and/or modify\n // it under the terms of the GNU General Public License as published by\n // the Free Software Foundation; either version 3 of the License, or"
    },
    {
      "sha": "b2ebe2fc7f97aa76c3e92a80bc00e879bf8bdc9f",
      "filename": "sim/mips/micromips.igen",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/micromips.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/micromips.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/micromips.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -85,7 +85,7 @@\n *micromips32:\n *micromips64:\n {\n-  switch(reg)\n+  switch (reg)\n     {\n     case 0: return 0;\n     case 1: return 17;\n@@ -1311,7 +1311,7 @@\n {\n   if (lwmregs & 0x10)\n     {\n-      switch(lwmregs & 0xf)\n+      switch (lwmregs & 0xf)\n         {\n         case 0:\n           return \"ra\";\n@@ -1339,7 +1339,7 @@\n     }\n   else\n     {\n-      switch(lwmregs & 0xf)\n+      switch (lwmregs & 0xf)\n         {\n         case 1:\n           return \"s0\";"
    },
    {
      "sha": "a033fce9d04246ab6c2e0b7b3b3dcdea43ad1e21",
      "filename": "sim/mips/mips.igen",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mips.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mips.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mips.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -4921,7 +4921,7 @@\n   do_xori (SD_, RS, RT, IMMEDIATE);\n }\n \n-\f\n+\n //\n // MIPS Architecture:\n //\n@@ -5730,7 +5730,7 @@\n   PENDING_FILL (RT, v);\n   TRACE_ALU_RESULT (v);\n }\n-  \n+\n 010001,00000,5.RT,5.FS,00000000000:COP1:32,f::MFC1b\n \"mfc1 r<RT>, f<FS>\"\n *mipsIV:\n@@ -5742,7 +5742,7 @@\n *vr4100:\n *vr5000:\n *r3900:\n-{ \n+{\n   do_mfc1b (SD_, RT, FS);\n }\n \n@@ -5851,14 +5851,14 @@\n *mipsI:\n *mipsII:\n *mipsIII:\n-{ \n+{\n   check_fpu (SD_);\n   if (SizeFGR () == 64)\n     PENDING_FILL ((FS + FGR_BASE), (SET64HI (0xDEADC0DE) | VL4_8 (GPR[RT])));\n   else\n     PENDING_FILL ((FS + FGR_BASE), VL4_8 (GPR[RT]));\n   TRACE_FP_RESULT (GPR[RT]);\n-} \n+}\n \n 010001,00100,5.RT,5.FS,00000000000:COP1:32,f::MTC1b\n \"mtc1 r<RT>, f<FS>\"\n@@ -6229,7 +6229,7 @@\n   do_trunc_fmt (SD_, fmt_word, FMT, FD, FS);\n }\n \n-\f\n+\n //\n // MIPS Architecture:\n //"
    },
    {
      "sha": "be0772bf87436e376fa011ebfb2f2bcdcf0e628a",
      "filename": "sim/mips/mips3264r2.igen",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mips3264r2.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mips3264r2.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mips3264r2.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -5,7 +5,7 @@\n // Contributed by David Ung, of MIPS Technologies.\n //\n // This file is part of the MIPS sim.\n-// \n+//\n // This program is free software; you can redistribute it and/or modify\n // it under the terms of the GNU General Public License as published by\n // the Free Software Foundation; either version 3 of the License, or"
    },
    {
      "sha": "0bcda0e0f589563209306ba1bbb1102203b6ff74",
      "filename": "sim/mips/mips3d.igen",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mips3d.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/mips3d.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/mips3d.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -6,7 +6,7 @@\n // Corporation (SiByte).\n //\n // This file is part of GDB, the GNU debugger.\n-// \n+//\n // This program is free software; you can redistribute it and/or modify\n // it under the terms of the GNU General Public License as published by\n // the Free Software Foundation; either version 3 of the License, or"
    },
    {
      "sha": "2401914cd2f870a74d85f179d1e1dd982d1031ad",
      "filename": "sim/mips/sb1.igen",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/sb1.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/sb1.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/sb1.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -6,7 +6,7 @@\n // Corporation (SiByte).\n //\n // This file is part of GDB, the GNU debugger.\n-// \n+//\n // This program is free software; you can redistribute it and/or modify\n // it under the terms of the GNU General Public License as published by\n // the Free Software Foundation; either version 3 of the License, or"
    },
    {
      "sha": "876593b33f83ebe8974331c183ad6398a70f3fb4",
      "filename": "sim/mips/sim-main.c",
      "status": "modified",
      "additions": 63,
      "deletions": 63,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/sim-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/sim-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/sim-main.c?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -82,7 +82,7 @@ load_memory (SIM_DESC SD,\n     }\n \n   dotrace (SD, CPU, tracefh,((IorD == isDATA) ? 0 : 2),(unsigned int)(pAddr&0xFFFFFFFF),(AccessLength + 1),\"load%s\",((IorD == isDATA) ? \"\" : \" instruction\"));\n-  \n+\n   /* Read the specified number of bytes from memory.  Adjust for\n      host/target byte ordering/ Align the least significant byte\n      read. */\n@@ -123,12 +123,12 @@ load_memory (SIM_DESC SD,\n     default:\n       abort ();\n     }\n-  \n+\n #ifdef DEBUG\n   printf(\"DBG: LoadMemory() : (offset %d) : value = 0x%s%s\\n\",\n \t (int)(pAddr & LOADDRMASK),pr_uword64(value1),pr_uword64(value));\n #endif /* DEBUG */\n-  \n+\n   /* See also store_memory. Position data in correct byte lanes. */\n   if (AccessLength <= LOADDRMASK)\n     {\n@@ -141,12 +141,12 @@ load_memory (SIM_DESC SD,\n \t   is already in the correct postition. */\n \tvalue <<= ((pAddr & LOADDRMASK) * 8);\n     }\n-  \n+\n #ifdef DEBUG\n   printf(\"DBG: LoadMemory() : shifted value = 0x%s%s\\n\",\n \t pr_uword64(value1),pr_uword64(value));\n #endif /* DEBUG */\n-  \n+\n   *memvalp = value;\n   if (memval1p) *memval1p = value1;\n }\n@@ -179,24 +179,24 @@ store_memory (SIM_DESC SD,\n #ifdef DEBUG\n   sim_io_printf(sd,\"DBG: StoreMemory(%d,%d,0x%s,0x%s,0x%s,0x%s)\\n\",CCA,AccessLength,pr_uword64(MemElem),pr_uword64(MemElem1),pr_addr(pAddr),pr_addr(vAddr));\n #endif /* DEBUG */\n-  \n+\n #if defined(WARN_MEM)\n   if (CCA != uncached)\n     sim_io_eprintf(sd,\"StoreMemory CCA (%d) is not uncached (currently all accesses treated as cached)\\n\",CCA);\n #endif /* WARN_MEM */\n-  \n+\n   if (((pAddr & LOADDRMASK) + AccessLength) > LOADDRMASK)\n     sim_io_error (SD, \"STORE AccessLength of %d would extend over %d bit aligned boundary for physical address 0x%s\\n\",\n \t\t  AccessLength,\n \t\t  (LOADDRMASK + 1) << 3,\n \t\t  pr_addr(pAddr));\n-  \n+\n   dotrace (SD, CPU, tracefh,1,(unsigned int)(pAddr&0xFFFFFFFF),(AccessLength + 1),\"store\");\n-  \n+\n #ifdef DEBUG\n   printf(\"DBG: StoreMemory: offset = %d MemElem = 0x%s%s\\n\",(unsigned int)(pAddr & LOADDRMASK),pr_uword64(MemElem1),pr_uword64(MemElem));\n #endif /* DEBUG */\n-  \n+\n   /* See also load_memory. Position data in correct byte lanes. */\n   if (AccessLength <= LOADDRMASK)\n     {\n@@ -209,11 +209,11 @@ store_memory (SIM_DESC SD,\n \t   is already in the correct postition. */\n \tMemElem >>= ((pAddr & LOADDRMASK) * 8);\n     }\n-  \n+\n #ifdef DEBUG\n   printf(\"DBG: StoreMemory: shift = %d MemElem = 0x%s%s\\n\",shift,pr_uword64(MemElem1),pr_uword64(MemElem));\n #endif /* DEBUG */\n-  \n+\n   switch (AccessLength)\n     {\n     case AccessLength_QUADWORD:\n@@ -248,8 +248,8 @@ store_memory (SIM_DESC SD,\n       break;\n     default:\n       abort ();\n-    }\t\n-  \n+    }\n+\n   return;\n }\n \n@@ -375,7 +375,7 @@ cache_op (SIM_DESC SD,\n         case 3: /* Create Dirty */\n         case 4: /* Hit Invalidate */\n         case 5: /* Hit Writeback Invalidate */\n-        case 6: /* Hit Writeback */ \n+        case 6: /* Hit Writeback */\n           if (!dcache_warning)\n             {\n               sim_io_eprintf(SD,\"Data CACHE operation %d to be coded\\n\",(op >> 2));\n@@ -403,70 +403,70 @@ pending_tick (SIM_DESC SD,\n \t      sim_cpu *CPU,\n \t      address_word cia)\n {\n-  if (PENDING_TRACE)\t\t\t\t\t\t\t\n-    sim_io_eprintf (SD, \"PENDING_DRAIN - 0x%lx - pending_in = %d, pending_out = %d, pending_total = %d\\n\", (unsigned long) cia, PENDING_IN, PENDING_OUT, PENDING_TOTAL); \n-  if (PENDING_OUT != PENDING_IN)\t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\t\n-      int loop;\t\t\t\t\t\t\t\n-      int index = PENDING_OUT;\t\t\t\t\t\n-      int total = PENDING_TOTAL;\t\t\t\t\t\n-      if (PENDING_TOTAL == 0)\t\t\t\t\t\t\n-\tsim_engine_abort (SD, CPU, cia, \"PENDING_DRAIN - Mis-match on pending update pointers\\n\"); \n+  if (PENDING_TRACE)\n+    sim_io_eprintf (SD, \"PENDING_DRAIN - 0x%lx - pending_in = %d, pending_out = %d, pending_total = %d\\n\", (unsigned long) cia, PENDING_IN, PENDING_OUT, PENDING_TOTAL);\n+  if (PENDING_OUT != PENDING_IN)\n+    {\n+      int loop;\n+      int index = PENDING_OUT;\n+      int total = PENDING_TOTAL;\n+      if (PENDING_TOTAL == 0)\n+\tsim_engine_abort (SD, CPU, cia, \"PENDING_DRAIN - Mis-match on pending update pointers\\n\");\n       for (loop = 0, index = PENDING_OUT;\n \t   (loop < total);\n \t   loop++, index = (index + 1) % PSLOTS)\n-\t{\t\t\t\t\t\t\t\t\n-\t  if (PENDING_SLOT_DEST[index] != NULL)\t\t\t\n-\t    {\t\t\t\t\t\t\t\t\n-\t      PENDING_SLOT_DELAY[index] -= 1;\t\t\t\t\n-\t      if (PENDING_SLOT_DELAY[index] == 0)\t\t\t\n-\t\t{\t\t\t\t\t\t\t\n+\t{\n+\t  if (PENDING_SLOT_DEST[index] != NULL)\n+\t    {\n+\t      PENDING_SLOT_DELAY[index] -= 1;\n+\t      if (PENDING_SLOT_DELAY[index] == 0)\n+\t\t{\n \t\t  if (PENDING_TRACE)\n \t\t    sim_io_eprintf (SD, \"PENDING_DRAIN - drained - index %d, dest %p, bit %d, val %\" PRIx64 \", size %d\\n\",\n \t\t\t\t    index,\n \t\t\t\t    PENDING_SLOT_DEST[index],\n \t\t\t\t    PENDING_SLOT_BIT[index],\n \t\t\t\t    PENDING_SLOT_VALUE[index],\n \t\t\t\t    PENDING_SLOT_SIZE[index]);\n-\t\t  if (PENDING_SLOT_BIT[index] >= 0)\t\t\t\n-\t\t    switch (PENDING_SLOT_SIZE[index])                 \n-\t\t      {\t\t\t\t\t\t\n+\t\t  if (PENDING_SLOT_BIT[index] >= 0)\n+\t\t    switch (PENDING_SLOT_SIZE[index])\n+\t\t      {\n \t\t      case 4:\n-\t\t\tif (PENDING_SLOT_VALUE[index])\t\t\n-\t\t\t  *(unsigned32*)PENDING_SLOT_DEST[index] |= \t\n-\t\t\t    BIT32 (PENDING_SLOT_BIT[index]);\t\t\n-\t\t\telse\t\t\t\t\t\t\n-\t\t\t  *(unsigned32*)PENDING_SLOT_DEST[index] &= \t\n-\t\t\t    BIT32 (PENDING_SLOT_BIT[index]);\t\t\n-\t\t\tbreak;\t\t\t\t\t\n-\t\t      case 8:\t\t\t\t\t\n-\t\t\tif (PENDING_SLOT_VALUE[index])\t\t\n-\t\t\t  *(unsigned64*)PENDING_SLOT_DEST[index] |= \t\n-\t\t\t    BIT64 (PENDING_SLOT_BIT[index]);\t\t\n-\t\t\telse\t\t\t\t\t\t\n-\t\t\t  *(unsigned64*)PENDING_SLOT_DEST[index] &= \t\n-\t\t\t    BIT64 (PENDING_SLOT_BIT[index]);\t\t\n-\t\t\tbreak;\t\t\t\t\t\n+\t\t\tif (PENDING_SLOT_VALUE[index])\n+\t\t\t  *(unsigned32*)PENDING_SLOT_DEST[index] |=\n+\t\t\t    BIT32 (PENDING_SLOT_BIT[index]);\n+\t\t\telse\n+\t\t\t  *(unsigned32*)PENDING_SLOT_DEST[index] &=\n+\t\t\t    BIT32 (PENDING_SLOT_BIT[index]);\n+\t\t\tbreak;\n+\t\t      case 8:\n+\t\t\tif (PENDING_SLOT_VALUE[index])\n+\t\t\t  *(unsigned64*)PENDING_SLOT_DEST[index] |=\n+\t\t\t    BIT64 (PENDING_SLOT_BIT[index]);\n+\t\t\telse\n+\t\t\t  *(unsigned64*)PENDING_SLOT_DEST[index] &=\n+\t\t\t    BIT64 (PENDING_SLOT_BIT[index]);\n+\t\t\tbreak;\n \t\t      }\n \t\t  else\n-\t\t    switch (PENDING_SLOT_SIZE[index])                 \n-\t\t      {\t\t\t\t\t\t\n-\t\t      case 4:\t\t\t\t\t\n-\t\t\t*(unsigned32*)PENDING_SLOT_DEST[index] = \t\n-\t\t\t  PENDING_SLOT_VALUE[index];\t\t\t\n-\t\t\tbreak;\t\t\t\t\t\n-\t\t      case 8:\t\t\t\t\t\n-\t\t\t*(unsigned64*)PENDING_SLOT_DEST[index] = \t\n-\t\t\t  PENDING_SLOT_VALUE[index];\t\t\t\n-\t\t\tbreak;\t\t\t\t\t\n-\t\t      }\t\t\t\t\t\t\t\n+\t\t    switch (PENDING_SLOT_SIZE[index])\n+\t\t      {\n+\t\t      case 4:\n+\t\t\t*(unsigned32*)PENDING_SLOT_DEST[index] =\n+\t\t\t  PENDING_SLOT_VALUE[index];\n+\t\t\tbreak;\n+\t\t      case 8:\n+\t\t\t*(unsigned64*)PENDING_SLOT_DEST[index] =\n+\t\t\t  PENDING_SLOT_VALUE[index];\n+\t\t\tbreak;\n+\t\t      }\n \t\t  if (PENDING_OUT == index)\n \t\t    {\n \t\t      PENDING_SLOT_DEST[index] = NULL;\n \t\t      PENDING_OUT = (PENDING_OUT + 1) % PSLOTS;\n \t\t      PENDING_TOTAL--;\n \t\t    }\n-\t\t}\t\t\t\t\t\t\t\n+\t\t}\n \t      else if (PENDING_TRACE && PENDING_SLOT_DELAY[index] > 0)\n \t\tsim_io_eprintf (SD, \"PENDING_DRAIN - queued - index %d, delay %d, dest %p, bit %d, val %\" PRIx64 \", size %d\\n\",\n \t\t\t\tindex, PENDING_SLOT_DELAY[index],\n@@ -475,9 +475,9 @@ pending_tick (SIM_DESC SD,\n \t\t\t\tPENDING_SLOT_VALUE[index],\n \t\t\t\tPENDING_SLOT_SIZE[index]);\n \n-\t    }\t\t\t\t\t\t\t\t\n-\t}\t\t\t\t\t\t\t\t\n-    }\t\t\t\t\t\t\t\t\t\n+\t    }\n+\t}\n+    }\n }\n \n "
    },
    {
      "sha": "faba1166800146727d84ed70f9fca638f738b87e",
      "filename": "sim/mips/sim-main.h",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/sim-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/sim-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/sim-main.h?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -238,21 +238,21 @@ enum float_operation\n   };\n \n \n-/* The internal representation of an MDMX accumulator. \n+/* The internal representation of an MDMX accumulator.\n    Note that 24 and 48 bit accumulator elements are represented in\n    32 or 64 bits.  Since the accumulators are 2's complement with\n    overflow suppressed, high-order bits can be ignored in most contexts.  */\n \n typedef signed32 signed24;\n typedef signed64 signed48;\n \n-typedef union { \n+typedef union {\n   signed24  ob[8];\n-  signed48  qh[4]; \n+  signed48  qh[4];\n } MDMX_accumulator;\n \n \n-/* Conventional system arguments.  */ \n+/* Conventional system arguments.  */\n #define SIM_STATE  sim_cpu *cpu, address_word cia\n #define SIM_ARGS   CPU, cia\n \n@@ -446,7 +446,7 @@ struct _sim_cpu {\n   pending_write_queue pending;\n \n   /* The MDMX accumulator (used only for MDMX ASE).  */\n-  MDMX_accumulator acc; \n+  MDMX_accumulator acc;\n #define ACC             ((CPU)->acc)\n \n   /* LLBIT = Load-Linked bit. A bit of \"virtual\" state used by atomic\n@@ -632,7 +632,7 @@ enum ExceptionCause {\n \n /* The following break instructions are reserved for use by the\n    simulator.  The first is used to halt the simulation.  The second\n-   is used by gdb for break-points.  NOTE: Care must be taken, since \n+   is used by gdb for break-points.  NOTE: Care must be taken, since\n    this value may be used in later revisions of the MIPS ISA. */\n #define HALT_INSTRUCTION_MASK   (0x03FFFFC0)\n \n@@ -697,7 +697,7 @@ void decode_coproc (SIM_DESC sd, sim_cpu *cpu, address_word cia,\n \t\t (rt), (rd), (sel))\n \n int sim_monitor (SIM_DESC sd, sim_cpu *cpu, address_word cia, unsigned int arg);\n-  \n+\n \n /* FPR access.  */\n unsigned64 value_fpr (SIM_STATE, int fpr, FP_formats);"
    },
    {
      "sha": "947568e0331d3cc3830d9e0bc6843e3bf24b2592",
      "filename": "sim/mips/smartmips.igen",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/smartmips.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/smartmips.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/smartmips.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -2,11 +2,11 @@\n //\n // Simulator definition for the SmartMIPS extensions.\n // Copyright (C) 2005-2022 Free Software Foundation, Inc.\n-// Contributed by Nigel Stephens (nigel@mips.com) and \n+// Contributed by Nigel Stephens (nigel@mips.com) and\n //                David Ung (davidu@mips.com) of MIPS Technologies.\n //\n // This file is part of GDB, the GNU debugger.\n-// \n+//\n // This program is free software; you can redistribute it and/or modify\n // it under the terms of the GNU General Public License as published by\n // the Free Software Foundation; either version 3 of the License, or"
    },
    {
      "sha": "c4cc524731dfd19163e68f452d580755c3af8483",
      "filename": "sim/mips/tx.igen",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/tx.igen",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d3eb0aa2872de6257df7a21ba2cf798f1005001d/sim/mips/tx.igen",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/mips/tx.igen?ref=d3eb0aa2872de6257df7a21ba2cf798f1005001d",
      "patch": "@@ -16,7 +16,7 @@\n   LO = EXTEND32 (prod);\n   HI = EXTEND32 (VH4_8 (prod));\n   TRACE_ALU_RESULT2 (HI, LO);\n-  if(RD != 0 )\n+  if (RD != 0)\n     GPR[RD] = LO;\n }\n \n@@ -34,7 +34,7 @@\n   LO = EXTEND32 (prod);\n   HI = EXTEND32 (VH4_8 (prod));\n   TRACE_ALU_RESULT2 (HI, LO);\n-  if(RD != 0)\n+  if (RD != 0)\n     GPR[RD] = LO;\n }\n "
    }
  ]
}