{
  "sha": "7ba99d2188454b9e08bdbf3616773a16ad9c9f95",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2JhOTlkMjE4ODQ1NGI5ZTA4YmRiZjM2MTY3NzNhMTZhZDljOWY5NQ==",
  "commit": {
    "author": {
      "name": "Ali Tamur",
      "email": "tamur@google.com",
      "date": "2019-08-27T02:22:09Z"
    },
    "committer": {
      "name": "Ali Tamur",
      "email": "tamur@google.com",
      "date": "2019-10-21T21:22:12Z"
    },
    "message": "DWARF 5 support: Handle line table and file indexes\n\n*  Fix handling of file and directory indexes in line tables; in DWARF 5 the\nindexes are zero-based. Make file_names field private to abstract this detail\nfrom the clients. Introduce file_names, is_valid_file_index and\nfile_names_size methods. Reflect these changes in clients.\n*  Handle DW_FORM_data16 in read_formatted_entries; it is used to record MD5\nof the file entries in DWARF 5.\n*  Fix a bug in line header parsing that calculates the length of the header\nincorrectly. (Seemingly this manifests itself only in DWARF 5).\n\nTested with CC=/usr/bin/gcc (version 8.3.0) against master branch (also with\n-gsplit-dwarf and -gdwarf-4 flags) and there was no increase in the set of\ntests that fails. (gdb still cannot debug a 'hello world' program with DWARF 5,\nso for the time being, this is all we care about).\n\nThis is part of an effort to support DWARF 5 in gdb.\n\ngdb/ChangeLog:\n\n\t* dwarf2read.c (dir_index): Change type.\n\t(file_name_index): Likewise.\n\t(line_header::include_dir_at): Change comment and implementation on\n\twhether it is DWARF 5.\n\t(line_header::is_valid_file_index): New function.\n\t(line_header::file_name_at): Change comment and implementation on\n\twhether it is DWARF 5.\n\t(line_header::file_names): Change to private field renamed as\n\tm_file_names and introduce a new accessor method.\n\t(line_header::file_names_size): New method.\n\t(line_header::include_dirs): Change to private field and rename as\n\tm_include_dirs.\n\t(dw2_get_file_names_reader): Define local var at a smaller scope and\n\treflect API change.\n\t(dwarf2_cu::setup_type_unit_groups): Reflect API change.\n\t(process_structure_scope): Likewise.\n\t(line_header::add_include_dir): Change message and reflect renaming.\n\t(line_header::add_file_name): Likewise.\n\t(read_formatted_entries): Handle DW_FORM_data16.\n\t(dwarf_decode_line_header): Fix line header length calculation.\n\t(psymtab_include_file_name): Change comment and API.\n\t(lnp_state_machine::m_file): Update comment and reflect type change.\n\t(lnp_state_machine::record_line): Reflect type change.\n\t(dwarf_decode_lines): Reflect API change.\n\t(file_file_name): Likewise.\n\t(file_full_name): Likewise.",
    "tree": {
      "sha": "af6877515e6af4c6e35128cf25d7d3bc3d6b9575",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/af6877515e6af4c6e35128cf25d7d3bc3d6b9575"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7ba99d2188454b9e08bdbf3616773a16ad9c9f95",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7ba99d2188454b9e08bdbf3616773a16ad9c9f95",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7ba99d2188454b9e08bdbf3616773a16ad9c9f95",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7ba99d2188454b9e08bdbf3616773a16ad9c9f95/comments",
  "author": {
    "login": "alitamur",
    "id": 59383390,
    "node_id": "MDQ6VXNlcjU5MzgzMzkw",
    "avatar_url": "https://avatars.githubusercontent.com/u/59383390?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alitamur",
    "html_url": "https://github.com/alitamur",
    "followers_url": "https://api.github.com/users/alitamur/followers",
    "following_url": "https://api.github.com/users/alitamur/following{/other_user}",
    "gists_url": "https://api.github.com/users/alitamur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alitamur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alitamur/subscriptions",
    "organizations_url": "https://api.github.com/users/alitamur/orgs",
    "repos_url": "https://api.github.com/users/alitamur/repos",
    "events_url": "https://api.github.com/users/alitamur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alitamur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "alitamur",
    "id": 59383390,
    "node_id": "MDQ6VXNlcjU5MzgzMzkw",
    "avatar_url": "https://avatars.githubusercontent.com/u/59383390?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/alitamur",
    "html_url": "https://github.com/alitamur",
    "followers_url": "https://api.github.com/users/alitamur/followers",
    "following_url": "https://api.github.com/users/alitamur/following{/other_user}",
    "gists_url": "https://api.github.com/users/alitamur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/alitamur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/alitamur/subscriptions",
    "organizations_url": "https://api.github.com/users/alitamur/orgs",
    "repos_url": "https://api.github.com/users/alitamur/repos",
    "events_url": "https://api.github.com/users/alitamur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/alitamur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "45f47c3a25d7574d21b9f451efce38c06256f591",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/45f47c3a25d7574d21b9f451efce38c06256f591",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/45f47c3a25d7574d21b9f451efce38c06256f591"
    }
  ],
  "stats": {
    "total": 212,
    "additions": 137,
    "deletions": 75
  },
  "files": [
    {
      "sha": "a70f3e1795c663dc3359196376234050034ed80c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ba99d2188454b9e08bdbf3616773a16ad9c9f95/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ba99d2188454b9e08bdbf3616773a16ad9c9f95/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7ba99d2188454b9e08bdbf3616773a16ad9c9f95",
      "patch": "@@ -1,3 +1,32 @@\n+2019-10-21  Ali Tamur  <tamu@google.com>\n+\n+\t* dwarf2read.c (dir_index): Change type.\n+\t(file_name_index): Likewise.\n+\t(line_header::include_dir_at): Change comment and implementation on\n+\twhether it is DWARF 5.\n+\t(line_header::is_valid_file_index): New function.\n+\t(line_header::file_name_at): Change comment and implementation on\n+\twhether it is DWARF 5.\n+\t(line_header::file_names): Change to private field renamed as\n+\tm_file_names and introduce a new accessor method.\n+\t(line_header::file_names_size): New method.\n+\t(line_header::include_dirs): Change to private field and rename as\n+\tm_include_dirs.\n+\t(dw2_get_file_names_reader): Define local var at a smaller scope and\n+\treflect API change.\n+\t(dwarf2_cu::setup_type_unit_groups): Reflect API change.\n+\t(process_structure_scope): Likewise.\n+\t(line_header::add_include_dir): Change message and reflect renaming.\n+\t(line_header::add_file_name): Likewise.\n+\t(read_formatted_entries): Handle DW_FORM_data16.\n+\t(dwarf_decode_line_header): Fix line header length calculation.\n+\t(psymtab_include_file_name): Change comment and API.\n+\t(lnp_state_machine::m_file): Update comment and reflect type change.\n+\t(lnp_state_machine::record_line): Reflect type change.\n+\t(dwarf_decode_lines): Reflect API change.\n+\t(file_file_name): Likewise.\n+\t(file_full_name): Likewise.\n+\n 2019-10-21  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* objfiles.c (sort_cmp): Ensure that !(a < a) holds true."
    },
    {
      "sha": "4372a47c6d61a2527fde4c6be92e276cc30f4a96",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 108,
      "deletions": 75,
      "changes": 183,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7ba99d2188454b9e08bdbf3616773a16ad9c9f95/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7ba99d2188454b9e08bdbf3616773a16ad9c9f95/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=7ba99d2188454b9e08bdbf3616773a16ad9c9f95",
      "patch": "@@ -909,13 +909,13 @@ typedef void (die_reader_func_ftype) (const struct die_reader_specs *reader,\n \t\t\t\t      int has_children,\n \t\t\t\t      void *data);\n \n-/* A 1-based directory index.  This is a strong typedef to prevent\n-   accidentally using a directory index as a 0-based index into an\n-   array/vector.  */\n-enum class dir_index : unsigned int {};\n+/* dir_index is 1-based in DWARF 4 and before, and is 0-based in DWARF 5 and\n+   later.  */\n+typedef int dir_index;\n \n-/* Likewise, a 1-based file name index.  */\n-enum class file_name_index : unsigned int {};\n+/* file_name_index is 1-based in DWARF 4 and before, and is 0-based in DWARF 5\n+   and later.  */\n+typedef int file_name_index;\n \n struct file_entry\n {\n@@ -967,32 +967,47 @@ struct line_header\n   void add_file_name (const char *name, dir_index d_index,\n \t\t      unsigned int mod_time, unsigned int length);\n \n-  /* Return the include dir at INDEX (1-based).  Returns NULL if INDEX\n-     is out of bounds.  */\n+  /* Return the include dir at INDEX (0-based in DWARF 5 and 1-based before).\n+     Returns NULL if INDEX is out of bounds.  */\n   const char *include_dir_at (dir_index index) const\n   {\n-    /* Convert directory index number (1-based) to vector index\n-       (0-based).  */\n-    size_t vec_index = to_underlying (index) - 1;\n-\n-    if (vec_index >= include_dirs.size ())\n+    int vec_index;\n+    if (version >= 5)\n+      vec_index = index;\n+    else\n+      vec_index = index - 1;\n+    if (vec_index < 0 || vec_index >= m_include_dirs.size ())\n       return NULL;\n-    return include_dirs[vec_index];\n+    return m_include_dirs[vec_index];\n   }\n \n-  /* Return the file name at INDEX (1-based).  Returns NULL if INDEX\n-     is out of bounds.  */\n-  file_entry *file_name_at (file_name_index index)\n+  bool is_valid_file_index (int file_index)\n   {\n-    /* Convert file name index number (1-based) to vector index\n-       (0-based).  */\n-    size_t vec_index = to_underlying (index) - 1;\n+    if (version >= 5)\n+      return 0 <= file_index && file_index < file_names_size ();\n+    return 1 <= file_index && file_index <= file_names_size ();\n+  }\n \n-    if (vec_index >= file_names.size ())\n+  /* Return the file name at INDEX (0-based in DWARF 5 and 1-based before).\n+     Returns NULL if INDEX is out of bounds.  */\n+  file_entry *file_name_at (file_name_index index)\n+  {\n+    int vec_index;\n+    if (version >= 5)\n+      vec_index = index;\n+    else\n+      vec_index = index - 1;\n+    if (vec_index < 0 || vec_index >= m_file_names.size ())\n       return NULL;\n-    return &file_names[vec_index];\n+    return &m_file_names[vec_index];\n   }\n \n+  /* The indexes are 0-based in DWARF 5 and 1-based in DWARF 4. Therefore,\n+     this method should only be used to iterate through all file entries in an\n+     index-agnostic manner.  */\n+  std::vector<file_entry> &file_names ()\n+  { return m_file_names; }\n+\n   /* Offset of line number information in .debug_line section.  */\n   sect_offset sect_off {};\n \n@@ -1015,16 +1030,23 @@ struct line_header\n      element is standard_opcode_lengths[opcode_base - 1].  */\n   std::unique_ptr<unsigned char[]> standard_opcode_lengths;\n \n-  /* The include_directories table.  Note these are observing\n-     pointers.  The memory is owned by debug_line_buffer.  */\n-  std::vector<const char *> include_dirs;\n-\n-  /* The file_names table.  */\n-  std::vector<file_entry> file_names;\n+  int file_names_size ()\n+  { return m_file_names.size(); }\n \n   /* The start and end of the statement program following this\n      header.  These point into dwarf2_per_objfile->line_buffer.  */\n   const gdb_byte *statement_program_start {}, *statement_program_end {};\n+\n+ private:\n+  /* The include_directories table.  Note these are observing\n+     pointers.  The memory is owned by debug_line_buffer.  */\n+  std::vector<const char *> m_include_dirs;\n+\n+  /* The file_names table. This is private because the meaning of indexes\n+     differs among DWARF versions (The first valid index is 1 in DWARF 4 and\n+     before, and is 0 in DWARF 5 and later).  So the client should use\n+     file_name_at method for access.  */\n+  std::vector<file_entry> m_file_names;\n };\n \n typedef std::unique_ptr<line_header> line_header_up;\n@@ -3640,7 +3662,6 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   struct dwarf2_per_cu_data *lh_cu;\n   struct attribute *attr;\n-  int i;\n   void **slot;\n   struct quick_file_names *qfn;\n \n@@ -3699,12 +3720,12 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n   if (strcmp (fnd.name, \"<unknown>\") != 0)\n     ++offset;\n \n-  qfn->num_file_names = offset + lh->file_names.size ();\n+  qfn->num_file_names = offset + lh->file_names_size ();\n   qfn->file_names =\n     XOBNEWVEC (&objfile->objfile_obstack, const char *, qfn->num_file_names);\n   if (offset != 0)\n     qfn->file_names[0] = xstrdup (fnd.name);\n-  for (i = 0; i < lh->file_names.size (); ++i)\n+  for (int i = 0; i < lh->file_names_size (); ++i)\n     qfn->file_names[i + offset] = file_full_name (i + 1, lh.get (), fnd.comp_dir);\n   qfn->real_names = NULL;\n \n@@ -11702,14 +11723,14 @@ dwarf2_cu::setup_type_unit_groups (struct die_info *die)\n \t process_full_type_unit still needs to know if this is the first\n \t time.  */\n \n-      tu_group->num_symtabs = line_header->file_names.size ();\n+      tu_group->num_symtabs = line_header->file_names_size ();\n       tu_group->symtabs = XNEWVEC (struct symtab *,\n-\t\t\t\t   line_header->file_names.size ());\n+\t\t\t\t   line_header->file_names_size ());\n \n-      for (i = 0; i < line_header->file_names.size (); ++i)\n+      auto &file_names = line_header->file_names ();\n+      for (i = 0; i < file_names.size (); ++i)\n \t{\n-\t  file_entry &fe = line_header->file_names[i];\n-\n+\t  file_entry &fe = file_names[i];\n \t  dwarf2_start_subfile (this, fe.name,\n \t\t\t\tfe.include_dir (line_header));\n \t  buildsym_compunit *b = get_builder ();\n@@ -11738,10 +11759,10 @@ dwarf2_cu::setup_type_unit_groups (struct die_info *die)\n \t\t\tcompunit_language (cust),\n \t\t\t0, cust));\n \n-      for (i = 0; i < line_header->file_names.size (); ++i)\n+      auto &file_names = line_header->file_names ();\n+      for (i = 0; i < file_names.size (); ++i)\n \t{\n-\t  file_entry &fe = line_header->file_names[i];\n-\n+\t  file_entry &fe = file_names[i];\n \t  fe.symtab = tu_group->symtabs[i];\n \t}\n     }\n@@ -16215,7 +16236,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t    {\n \t      /* Any related symtab will do.  */\n \t      symtab\n-\t\t= cu->line_header->file_name_at (file_name_index (1))->symtab;\n+\t\t= cu->line_header->file_names ()[0].symtab;\n \t    }\n \t  else\n \t    {\n@@ -20270,10 +20291,16 @@ void\n line_header::add_include_dir (const char *include_dir)\n {\n   if (dwarf_line_debug >= 2)\n-    fprintf_unfiltered (gdb_stdlog, \"Adding dir %zu: %s\\n\",\n-\t\t\tinclude_dirs.size () + 1, include_dir);\n-\n-  include_dirs.push_back (include_dir);\n+    {\n+      size_t new_size;\n+      if (version >= 5)\n+        new_size = m_include_dirs.size ();\n+      else\n+        new_size = m_include_dirs.size () + 1;\n+      fprintf_unfiltered (gdb_stdlog, \"Adding dir %zu: %s\\n\",\n+\t\t\t  new_size, include_dir);\n+    }\n+  m_include_dirs.push_back (include_dir);\n }\n \n void\n@@ -20283,10 +20310,16 @@ line_header::add_file_name (const char *name,\n \t\t\t    unsigned int length)\n {\n   if (dwarf_line_debug >= 2)\n-    fprintf_unfiltered (gdb_stdlog, \"Adding file %u: %s\\n\",\n-\t\t\t(unsigned) file_names.size () + 1, name);\n-\n-  file_names.emplace_back (name, d_index, mod_time, length);\n+    {\n+      size_t new_size;\n+      if (version >= 5)\n+        new_size = file_names_size ();\n+      else\n+        new_size = file_names_size () + 1;\n+      fprintf_unfiltered (gdb_stdlog, \"Adding file %zu: %s\\n\",\n+\t\t\t  new_size, name);\n+    }\n+  m_file_names.emplace_back (name, d_index, mod_time, length);\n }\n \n /* A convenience function to find the proper .debug_line section for a CU.  */\n@@ -20400,6 +20433,11 @@ read_formatted_entries (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t      buf += 8;\n \t      break;\n \n+\t    case DW_FORM_data16:\n+\t      /*  This is used for MD5, but file_entry does not record MD5s. */\n+\t      buf += 16;\n+\t      break;\n+\n \t    case DW_FORM_udata:\n \t      uint.emplace (read_unsigned_leb128 (abfd, buf, &bytes_read));\n \t      buf += bytes_read;\n@@ -20500,12 +20538,15 @@ dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n     read_checked_initial_length_and_offset (abfd, line_ptr, &cu->header,\n \t\t\t\t\t    &bytes_read, &offset_size);\n   line_ptr += bytes_read;\n+\n+  const gdb_byte *start_here = line_ptr;\n+\n   if (line_ptr + lh->total_length > (section->buffer + section->size))\n     {\n       dwarf2_statement_list_fits_in_line_number_section_complaint ();\n       return 0;\n     }\n-  lh->statement_program_end = line_ptr + lh->total_length;\n+  lh->statement_program_end = start_here + lh->total_length;\n   lh->version = read_2_bytes (abfd, line_ptr);\n   line_ptr += 2;\n   if (lh->version > 5)\n@@ -20535,6 +20576,7 @@ dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n     }\n   lh->header_length = read_offset_1 (abfd, line_ptr, offset_size);\n   line_ptr += offset_size;\n+  lh->statement_program_start = line_ptr + lh->header_length;\n   lh->minimum_instruction_length = read_1_byte (abfd, line_ptr);\n   line_ptr += 1;\n   if (lh->version >= 4)\n@@ -20619,7 +20661,6 @@ dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n \t}\n       line_ptr += bytes_read;\n     }\n-  lh->statement_program_start = line_ptr;\n \n   if (line_ptr > (section->buffer + section->size))\n     complaint (_(\"line number info header doesn't \"\n@@ -20629,19 +20670,17 @@ dwarf_decode_line_header (sect_offset sect_off, struct dwarf2_cu *cu)\n }\n \n /* Subroutine of dwarf_decode_lines to simplify it.\n-   Return the file name of the psymtab for included file FILE_INDEX\n-   in line header LH of PST.\n+   Return the file name of the psymtab for the given file_entry.\n    COMP_DIR is the compilation directory (DW_AT_comp_dir) or NULL if unknown.\n    If space for the result is malloc'd, *NAME_HOLDER will be set.\n    Returns NULL if FILE_INDEX should be ignored, i.e., it is pst->filename.  */\n \n static const char *\n-psymtab_include_file_name (const struct line_header *lh, int file_index,\n+psymtab_include_file_name (const struct line_header *lh, const file_entry &fe,\n \t\t\t   const struct partial_symtab *pst,\n \t\t\t   const char *comp_dir,\n \t\t\t   gdb::unique_xmalloc_ptr<char> *name_holder)\n {\n-  const file_entry &fe = lh->file_names[file_index];\n   const char *include_name = fe.name;\n   const char *include_name_to_compare = include_name;\n   const char *pst_filename;\n@@ -20816,8 +20855,8 @@ class lnp_state_machine\n      and initialized according to the DWARF spec.  */\n \n   unsigned char m_op_index = 0;\n-  /* The line table index (1-based) of the current file.  */\n-  file_name_index m_file = (file_name_index) 1;\n+  /* The line table index of the current file.  */\n+  file_name_index m_file = 1;\n   unsigned int m_line = 1;\n \n   /* These are initialized in the constructor.  */\n@@ -21009,7 +21048,7 @@ lnp_state_machine::record_line (bool end_sequence)\n       fprintf_unfiltered (gdb_stdlog,\n \t\t\t  \"Processing actual line %u: file %u,\"\n \t\t\t  \" address %s, is_stmt %u, discrim %u\\n\",\n-\t\t\t  m_line, to_underlying (m_file),\n+\t\t\t  m_line, m_file,\n \t\t\t  paddress (m_gdbarch, m_address),\n \t\t\t  m_is_stmt, m_discriminator);\n     }\n@@ -21348,17 +21387,15 @@ dwarf_decode_lines (struct line_header *lh, const char *comp_dir,\n \n   if (decode_for_pst_p)\n     {\n-      int file_index;\n-\n       /* Now that we're done scanning the Line Header Program, we can\n          create the psymtab of each included file.  */\n-      for (file_index = 0; file_index < lh->file_names.size (); file_index++)\n-        if (lh->file_names[file_index].included_p == 1)\n+      for (auto &file_entry : lh->file_names ())\n+        if (file_entry.included_p == 1)\n           {\n \t    gdb::unique_xmalloc_ptr<char> name_holder;\n \t    const char *include_name =\n-\t      psymtab_include_file_name (lh, file_index, pst, comp_dir,\n-\t\t\t\t\t &name_holder);\n+\t      psymtab_include_file_name (lh, file_entry, pst,\n+\t\t\t\t\t comp_dir, &name_holder);\n \t    if (include_name != NULL)\n               dwarf2_create_include_psymtab (include_name, pst, objfile);\n           }\n@@ -21370,14 +21407,10 @@ dwarf_decode_lines (struct line_header *lh, const char *comp_dir,\n \t line numbers).  */\n       buildsym_compunit *builder = cu->get_builder ();\n       struct compunit_symtab *cust = builder->get_compunit_symtab ();\n-      int i;\n \n-      for (i = 0; i < lh->file_names.size (); i++)\n+      for (auto &fe : lh->file_names ())\n \t{\n-\t  file_entry &fe = lh->file_names[i];\n-\n \t  dwarf2_start_subfile (cu, fe.name, fe.include_dir (lh));\n-\n \t  if (builder->get_current_subfile ()->symtab == NULL)\n \t    {\n \t      builder->get_current_subfile ()->symtab\n@@ -24182,17 +24215,17 @@ file_file_name (int file, struct line_header *lh)\n {\n   /* Is the file number a valid index into the line header's file name\n      table?  Remember that file numbers start with one, not zero.  */\n-  if (1 <= file && file <= lh->file_names.size ())\n+  if (lh->is_valid_file_index (file))\n     {\n-      const file_entry &fe = lh->file_names[file - 1];\n+      const file_entry *fe = lh->file_name_at (file);\n \n-      if (!IS_ABSOLUTE_PATH (fe.name))\n+      if (!IS_ABSOLUTE_PATH (fe->name))\n \t{\n-\t  const char *dir = fe.include_dir (lh);\n+\t  const char *dir = fe->include_dir (lh);\n \t  if (dir != NULL)\n-\t    return concat (dir, SLASH_STRING, fe.name, (char *) NULL);\n+\t    return concat (dir, SLASH_STRING, fe->name, (char *) NULL);\n \t}\n-      return xstrdup (fe.name);\n+      return xstrdup (fe->name);\n     }\n   else\n     {\n@@ -24220,7 +24253,7 @@ file_full_name (int file, struct line_header *lh, const char *comp_dir)\n {\n   /* Is the file number a valid index into the line header's file name\n      table?  Remember that file numbers start with one, not zero.  */\n-  if (1 <= file && file <= lh->file_names.size ())\n+  if (lh->is_valid_file_index (file))\n     {\n       char *relative = file_file_name (file, lh);\n "
    }
  ]
}