{
  "sha": "2a1ebfb221f5f52a743b7ea4c504a7318956c49c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmExZWJmYjIyMWY1ZjUyYTc0M2I3ZWE0YzUwNGE3MzE4OTU2YzQ5Yw==",
  "commit": {
    "author": {
      "name": "Claudiu Zissulescu",
      "email": "claziss@gmail.com",
      "date": "2020-01-07T13:29:16Z"
    },
    "committer": {
      "name": "Claudiu Zissulescu",
      "email": "claziss@gmail.com",
      "date": "2020-01-07T13:29:31Z"
    },
    "message": "[ARC] Improve parsing instruction operands.\n\nWe use gas' expression function to parse the operands of an\ninstruction in a generic way. There are situations when we have labels\nand registers having the same name as well as the substraction sign\ndoesn't always stands for the arithmetical operation but for the\nregister range (e.g. enter instruction). This patch improves parsing\nsymbols found in a instruction operand, cleans up code and avoids\nusing default or undefined variables.\n\ngas/\nxxxx-xx-xx  Claudiu Zissulescu  <claziss@synopsys.com>\n\n\t* config/tc-arc.c (parse_reloc_symbol): New function.\n\t(tokenize_arguments): Clean up, use parse_reloc_symbol function.\n\t(md_operand): Set X_md to absent.\n\t(arc_parse_name): Check for X_md.",
    "tree": {
      "sha": "2cc322ae1838a24b87fcdf27dad55ada867968b2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2cc322ae1838a24b87fcdf27dad55ada867968b2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2a1ebfb221f5f52a743b7ea4c504a7318956c49c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2a1ebfb221f5f52a743b7ea4c504a7318956c49c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2a1ebfb221f5f52a743b7ea4c504a7318956c49c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2a1ebfb221f5f52a743b7ea4c504a7318956c49c/comments",
  "author": {
    "login": "claziss",
    "id": 2761368,
    "node_id": "MDQ6VXNlcjI3NjEzNjg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/claziss",
    "html_url": "https://github.com/claziss",
    "followers_url": "https://api.github.com/users/claziss/followers",
    "following_url": "https://api.github.com/users/claziss/following{/other_user}",
    "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/claziss/subscriptions",
    "organizations_url": "https://api.github.com/users/claziss/orgs",
    "repos_url": "https://api.github.com/users/claziss/repos",
    "events_url": "https://api.github.com/users/claziss/events{/privacy}",
    "received_events_url": "https://api.github.com/users/claziss/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "claziss",
    "id": 2761368,
    "node_id": "MDQ6VXNlcjI3NjEzNjg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/2761368?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/claziss",
    "html_url": "https://github.com/claziss",
    "followers_url": "https://api.github.com/users/claziss/followers",
    "following_url": "https://api.github.com/users/claziss/following{/other_user}",
    "gists_url": "https://api.github.com/users/claziss/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/claziss/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/claziss/subscriptions",
    "organizations_url": "https://api.github.com/users/claziss/orgs",
    "repos_url": "https://api.github.com/users/claziss/repos",
    "events_url": "https://api.github.com/users/claziss/events{/privacy}",
    "received_events_url": "https://api.github.com/users/claziss/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bb82aefe17866cdcb996ae35a3895bb36b4d674b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb82aefe17866cdcb996ae35a3895bb36b4d674b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bb82aefe17866cdcb996ae35a3895bb36b4d674b"
    }
  ],
  "stats": {
    "total": 208,
    "additions": 117,
    "deletions": 91
  },
  "files": [
    {
      "sha": "1c61732fab3b7e693b2bf737dd4195b5c1548d41",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a1ebfb221f5f52a743b7ea4c504a7318956c49c/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a1ebfb221f5f52a743b7ea4c504a7318956c49c/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=2a1ebfb221f5f52a743b7ea4c504a7318956c49c",
      "patch": "@@ -1,3 +1,10 @@\n+2020-01-07  Claudiu Zissulescu  <claziss@synopsys.com>\n+\n+\t* onfig/tc-arc.c (parse_reloc_symbol): New function.\n+\t(tokenize_arguments): Clean up, use parse_reloc_symbol function.\n+\t(md_operand): Set X_md to absent.\n+\t(arc_parse_name): Check for X_md.\n+\n 2020-01-03  Sergey Belyashov  <sergey.belyashov@gmail.com>\n \n \tPR 25311"
    },
    {
      "sha": "ed1e3fb5dd5c9504c66e1f377f3d85a4f322a33b",
      "filename": "gas/config/tc-arc.c",
      "status": "modified",
      "additions": 110,
      "deletions": 91,
      "changes": 201,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a1ebfb221f5f52a743b7ea4c504a7318956c49c/gas/config/tc-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a1ebfb221f5f52a743b7ea4c504a7318956c49c/gas/config/tc-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arc.c?ref=2a1ebfb221f5f52a743b7ea4c504a7318956c49c",
      "patch": "@@ -1092,6 +1092,102 @@ debug_exp (expressionS *t)\n   fflush (stderr);\n }\n \n+/* Helper for parsing an argument, used for sorting out the relocation\n+   type.  */\n+\n+static void\n+parse_reloc_symbol (expressionS *resultP)\n+{\n+  char *reloc_name, c, *sym_name;\n+  size_t len;\n+  int i;\n+  const struct arc_reloc_op_tag *r;\n+  expressionS right;\n+  symbolS *base;\n+\n+  /* A relocation operand has the following form\n+     @identifier@relocation_type.  The identifier is already in\n+     tok!  */\n+  if (resultP->X_op != O_symbol)\n+    {\n+      as_bad (_(\"No valid label relocation operand\"));\n+      resultP->X_op = O_illegal;\n+      return;\n+    }\n+\n+  /* Parse @relocation_type.  */\n+  input_line_pointer++;\n+  c = get_symbol_name (&reloc_name);\n+  len = input_line_pointer - reloc_name;\n+  if (len == 0)\n+    {\n+      as_bad (_(\"No relocation operand\"));\n+      resultP->X_op = O_illegal;\n+      return;\n+    }\n+\n+  /* Go through known relocation and try to find a match.  */\n+  r = &arc_reloc_op[0];\n+  for (i = arc_num_reloc_op - 1; i >= 0; i--, r++)\n+    if (len == r->length\n+\t&& memcmp (reloc_name, r->name, len) == 0)\n+      break;\n+  if (i < 0)\n+    {\n+      as_bad (_(\"Unknown relocation operand: @%s\"), reloc_name);\n+      resultP->X_op = O_illegal;\n+      return;\n+    }\n+\n+  *input_line_pointer = c;\n+  SKIP_WHITESPACE_AFTER_NAME ();\n+  /* Extra check for TLS: base.  */\n+  if (*input_line_pointer == '@')\n+    {\n+      if (resultP->X_op_symbol != NULL\n+\t  || resultP->X_op != O_symbol)\n+\t{\n+\t  as_bad (_(\"Unable to parse TLS base: %s\"),\n+\t\t  input_line_pointer);\n+\t  resultP->X_op = O_illegal;\n+\t  return;\n+\t}\n+      input_line_pointer++;\n+      c = get_symbol_name (&sym_name);\n+      base = symbol_find_or_make (sym_name);\n+      resultP->X_op = O_subtract;\n+      resultP->X_op_symbol = base;\n+      restore_line_pointer (c);\n+      right.X_add_number = 0;\n+    }\n+\n+  if ((*input_line_pointer != '+')\n+      && (*input_line_pointer != '-'))\n+    right.X_add_number = 0;\n+  else\n+    {\n+      /* Parse the constant of a complex relocation expression\n+\t like @identifier@reloc +/- const.  */\n+      if (! r->complex_expr)\n+\t{\n+\t  as_bad (_(\"@%s is not a complex relocation.\"), r->name);\n+\t  resultP->X_op = O_illegal;\n+\t  return;\n+\t}\n+      expression (&right);\n+      if (right.X_op != O_constant)\n+\t{\n+\t  as_bad (_(\"Bad expression: @%s + %s.\"),\n+\t\t  r->name, input_line_pointer);\n+\t  resultP->X_op = O_illegal;\n+\t  return;\n+\t}\n+    }\n+\n+  resultP->X_md = r->op;\n+  resultP->X_add_number = right.X_add_number;\n+}\n+\n /* Parse the arguments to an opcode.  */\n \n static int\n@@ -1104,11 +1200,6 @@ tokenize_arguments (char *str,\n   bfd_boolean saw_arg = FALSE;\n   int brk_lvl = 0;\n   int num_args = 0;\n-  int i;\n-  size_t len;\n-  const struct arc_reloc_op_tag *r;\n-  expressionS tmpE;\n-  char *reloc_name, c;\n \n   memset (tok, 0, sizeof (*tok) * ntok);\n \n@@ -1170,95 +1261,21 @@ tokenize_arguments (char *str,\n \t    goto err;\n \n \t  /* Parse @label.  */\n+\t  input_line_pointer++;\n \t  tok->X_op = O_symbol;\n \t  tok->X_md = O_absent;\n \t  expression (tok);\n-\t  if (*input_line_pointer != '@')\n-\t    goto normalsymbol; /* This is not a relocation.  */\n-\n-\trelocationsym:\n-\n-\t  /* A relocation operand has the following form\n-\t     @identifier@relocation_type.  The identifier is already\n-\t     in tok!  */\n-\t  if (tok->X_op != O_symbol)\n-\t    {\n-\t      as_bad (_(\"No valid label relocation operand\"));\n-\t      goto err;\n-\t    }\n-\n-\t  /* Parse @relocation_type.  */\n-\t  input_line_pointer++;\n-\t  c = get_symbol_name (&reloc_name);\n-\t  len = input_line_pointer - reloc_name;\n-\t  if (len == 0)\n-\t    {\n-\t      as_bad (_(\"No relocation operand\"));\n-\t      goto err;\n-\t    }\n-\n-\t  /* Go through known relocation and try to find a match.  */\n-\t  r = &arc_reloc_op[0];\n-\t  for (i = arc_num_reloc_op - 1; i >= 0; i--, r++)\n-\t    if (len == r->length\n-\t\t&& memcmp (reloc_name, r->name, len) == 0)\n-\t      break;\n-\t  if (i < 0)\n-\t    {\n-\t      as_bad (_(\"Unknown relocation operand: @%s\"), reloc_name);\n-\t      goto err;\n-\t    }\n \n-\t  *input_line_pointer = c;\n-\t  SKIP_WHITESPACE_AFTER_NAME ();\n-\t  /* Extra check for TLS: base.  */\n \t  if (*input_line_pointer == '@')\n-\t    {\n-\t      symbolS *base;\n-\t      if (tok->X_op_symbol != NULL\n-\t\t  || tok->X_op != O_symbol)\n-\t\t{\n-\t\t  as_bad (_(\"Unable to parse TLS base: %s\"),\n-\t\t\t  input_line_pointer);\n-\t\t  goto err;\n-\t\t}\n-\t      input_line_pointer++;\n-\t      char *sym_name;\n-\t      c = get_symbol_name (&sym_name);\n-\t      base = symbol_find_or_make (sym_name);\n-\t      tok->X_op = O_subtract;\n-\t      tok->X_op_symbol = base;\n-\t      restore_line_pointer (c);\n-\t      tmpE.X_add_number = 0;\n-\t    }\n-\t  if ((*input_line_pointer != '+')\n-\t\t   && (*input_line_pointer != '-'))\n-\t    {\n-\t      tmpE.X_add_number = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Parse the constant of a complex relocation expression\n-\t\t like @identifier@reloc +/- const.  */\n-\t      if (! r->complex_expr)\n-\t\t{\n-\t\t  as_bad (_(\"@%s is not a complex relocation.\"), r->name);\n-\t\t  goto err;\n-\t\t}\n-\t      expression (&tmpE);\n-\t      if (tmpE.X_op != O_constant)\n-\t\t{\n-\t\t  as_bad (_(\"Bad expression: @%s + %s.\"),\n-\t\t\t  r->name, input_line_pointer);\n-\t\t  goto err;\n-\t\t}\n-\t    }\n-\n-\t  tok->X_md = r->op;\n-\t  tok->X_add_number = tmpE.X_add_number;\n+\t    parse_reloc_symbol (tok);\n \n \t  debug_exp (tok);\n \n+\t  if (tok->X_op == O_illegal\n+              || tok->X_op == O_absent\n+              || num_args == ntok)\n+\t    goto err;\n+\n \t  saw_comma = FALSE;\n \t  saw_arg = TRUE;\n \t  tok++;\n@@ -1282,9 +1299,8 @@ tokenize_arguments (char *str,\n \t     identifier@relocation_type, if it is the case parse the\n \t     relocation type as well.  */\n \t  if (*input_line_pointer == '@')\n-\t    goto relocationsym;\n+\t    parse_reloc_symbol (tok);\n \n-\tnormalsymbol:\n \t  debug_exp (tok);\n \n \t  if (tok->X_op == O_illegal\n@@ -3336,16 +3352,18 @@ md_atof (int type, char *litP, int *sizeP)\n \n /* Called for any expression that can not be recognized.  When the\n    function is called, `input_line_pointer' will point to the start of\n-   the expression.  */\n+   the expression.  We use it when we have complex operations like\n+   @label1 - @label2.  */\n \n void\n-md_operand (expressionS *expressionP ATTRIBUTE_UNUSED)\n+md_operand (expressionS *expressionP)\n {\n   char *p = input_line_pointer;\n   if (*p == '@')\n     {\n       input_line_pointer++;\n       expressionP->X_op = O_symbol;\n+      expressionP->X_md = O_absent;\n       expression (expressionP);\n     }\n }\n@@ -3364,7 +3382,8 @@ arc_parse_name (const char *name,\n   if (!assembling_insn)\n     return FALSE;\n \n-  if (e->X_op == O_symbol)\n+  if (e->X_op == O_symbol\n+      && e->X_md == O_absent)\n     return FALSE;\n \n   sym = hash_find (arc_reg_hash, name);"
    }
  ]
}