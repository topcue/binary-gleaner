{
  "sha": "8df017996f662ce6ab23aea4abeb8f7ac1f62651",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGRmMDE3OTk2ZjY2MmNlNmFiMjNhZWE0YWJlYjhmN2FjMWY2MjY1MQ==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-06-18T20:28:18Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2020-06-18T22:03:08Z"
    },
    "message": "gcore, handle exited threads better\n\nAn early (and since discarded) version of this series tried to make\nexited threads have distinct PTID between each other, and that change\nexposed a problem in linux-tdep.c...  This was exposed by the\ngdb.threads/gcore-stale-thread.exp testcase, which is exactly about\ncalling gcore with an exited thread selected:\n\n (gdb) [Thread 0x7ffff7fb6740 (LWP 31523) exited]\n PASS: gdb.threads/gcore-stale-thread.exp: continue to breakpoint: break-here\n gcore /home/pedro/gdb/binutils-gdb/build/gdb/testsuite/outputs/gdb.threads/gcore-stale-thread/gcore-stale-thread.core\n /home/pedro/gdb/binutils-gdb/build/../src/gdb/inferior.c:66: internal-error: void set_current_inferior(inferior*): Assertion `inf != NULL' failed.\n A problem internal to GDB has been detected,\n\nThat was find_inferior_ptid being called on the \"exited\" ptid, which\non that previous (and discarded attempt) had pid==-1.  The problem is\nthat linux-tdep.c, where it looks for the signalled thread, isn't\nconsidering exited threads.  Also, while at it, that code isn't\nconsidering multi-target either, since it is using\niterate_over_threads which iterates over all threads of all targets.\nFixed by switching to range-for iteration instead.\n\ngdb/ChangeLog:\n2020-06-18  Pedro Alves  <palves@redhat.com>\n\n\t* linux-tdep.c (find_signalled_thread(thread_info *,void *)):\n\tDelete.\n\t(find_signalled_thread()): New, factored out from\n\tlinux_make_corefile_notes and adjusted to handle exited threads.\n\t(linux_make_corefile_notes): Adjust to use the new\n\tfind_signalled_thread.",
    "tree": {
      "sha": "0d5cc78af50669c9f30ff31f98631382e44370a7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0d5cc78af50669c9f30ff31f98631382e44370a7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8df017996f662ce6ab23aea4abeb8f7ac1f62651",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8df017996f662ce6ab23aea4abeb8f7ac1f62651",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8df017996f662ce6ab23aea4abeb8f7ac1f62651",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8df017996f662ce6ab23aea4abeb8f7ac1f62651/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "41792d688a5a1f158d6e9ecda2b603ae122d69a1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/41792d688a5a1f158d6e9ecda2b603ae122d69a1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/41792d688a5a1f158d6e9ecda2b603ae122d69a1"
    }
  ],
  "stats": {
    "total": 69,
    "additions": 42,
    "deletions": 27
  },
  "files": [
    {
      "sha": "ab911076394b9254a9554ddc490e30bfe3daa0f2",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8df017996f662ce6ab23aea4abeb8f7ac1f62651/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8df017996f662ce6ab23aea4abeb8f7ac1f62651/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8df017996f662ce6ab23aea4abeb8f7ac1f62651",
      "patch": "@@ -1,3 +1,12 @@\n+2020-06-18  Pedro Alves  <palves@redhat.com>\n+\n+\t* linux-tdep.c (find_signalled_thread(thread_info *,void *)):\n+\tDelete.\n+\t(find_signalled_thread()): New, factored out from\n+\tlinux_make_corefile_notes and adjusted to handle exited threads.\n+\t(linux_make_corefile_notes): Adjust to use the new\n+\tfind_signalled_thread.\n+\n 2020-06-18  Pedro Alves  <palves@redhat.com>\n \n \t* linux-tdep.c (btrace_fetch): Save/restore current thread instead"
    },
    {
      "sha": "fd4337f100d6f6af18e03de3c94177ab12b2ae44",
      "filename": "gdb/linux-tdep.c",
      "status": "modified",
      "additions": 33,
      "deletions": 27,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8df017996f662ce6ab23aea4abeb8f7ac1f62651/gdb/linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8df017996f662ce6ab23aea4abeb8f7ac1f62651/gdb/linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-tdep.c?ref=8df017996f662ce6ab23aea4abeb8f7ac1f62651",
      "patch": "@@ -1396,18 +1396,6 @@ linux_find_memory_regions (struct gdbarch *gdbarch,\n \t\t\t\t\t &data);\n }\n \n-/* Determine which signal stopped execution.  */\n-\n-static int\n-find_signalled_thread (struct thread_info *info, void *data)\n-{\n-  if (info->suspend.stop_signal != GDB_SIGNAL_0\n-      && info->ptid.pid () == inferior_ptid.pid ())\n-    return 1;\n-\n-  return 0;\n-}\n-\n /* This is used to pass information from\n    linux_make_mappings_corefile_notes through\n    linux_find_memory_regions_full.  */\n@@ -1855,6 +1843,30 @@ linux_fill_prpsinfo (struct elf_internal_linux_prpsinfo *p)\n   return 1;\n }\n \n+/* Find the signalled thread.  In case there's more than one signalled\n+   thread, prefer the current thread, if it is signalled.  If no\n+   thread was signalled, default to the current thread, unless it has\n+   exited, in which case return NULL.  */\n+\n+static thread_info *\n+find_signalled_thread ()\n+{\n+  thread_info *curr_thr = inferior_thread ();\n+  if (curr_thr->state != THREAD_EXITED\n+      && curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n+    return curr_thr;\n+\n+  for (thread_info *thr : current_inferior ()->non_exited_threads ())\n+    if (thr->suspend.stop_signal != GDB_SIGNAL_0)\n+      return thr;\n+\n+  /* Default to the current thread, unless it has exited.  */\n+  if (curr_thr->state != THREAD_EXITED)\n+    return curr_thr;\n+\n+  return nullptr;\n+}\n+\n /* Build the note section for a corefile, and return it in a malloc\n    buffer.  */\n \n@@ -1864,7 +1876,6 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n   struct linux_corefile_thread_data thread_args;\n   struct elf_internal_linux_prpsinfo prpsinfo;\n   char *note_data = NULL;\n-  struct thread_info *curr_thr, *signalled_thr;\n \n   if (! gdbarch_iterate_over_regset_sections_p (gdbarch))\n     return NULL;\n@@ -1892,26 +1903,21 @@ linux_make_corefile_notes (struct gdbarch *gdbarch, bfd *obfd, int *note_size)\n     }\n \n   /* Like the kernel, prefer dumping the signalled thread first.\n-     \"First thread\" is what tools use to infer the signalled thread.\n-     In case there's more than one signalled thread, prefer the\n-     current thread, if it is signalled.  */\n-  curr_thr = inferior_thread ();\n-  if (curr_thr->suspend.stop_signal != GDB_SIGNAL_0)\n-    signalled_thr = curr_thr;\n-  else\n-    {\n-      signalled_thr = iterate_over_threads (find_signalled_thread, NULL);\n-      if (signalled_thr == NULL)\n-\tsignalled_thr = curr_thr;\n-    }\n+     \"First thread\" is what tools use to infer the signalled\n+     thread.  */\n+  thread_info *signalled_thr = find_signalled_thread ();\n \n   thread_args.gdbarch = gdbarch;\n   thread_args.obfd = obfd;\n   thread_args.note_data = note_data;\n   thread_args.note_size = note_size;\n-  thread_args.stop_signal = signalled_thr->suspend.stop_signal;\n+  if (signalled_thr != nullptr)\n+    thread_args.stop_signal = signalled_thr->suspend.stop_signal;\n+  else\n+    thread_args.stop_signal = GDB_SIGNAL_0;\n \n-  linux_corefile_thread (signalled_thr, &thread_args);\n+  if (signalled_thr != nullptr)\n+    linux_corefile_thread (signalled_thr, &thread_args);\n   for (thread_info *thr : current_inferior ()->non_exited_threads ())\n     {\n       if (thr == signalled_thr)"
    }
  ]
}