{
  "sha": "59505f2cec80bfd0b721a53104dbbf7f300127b7",
  "node_id": "C_kwDOANOeidoAKDU5NTA1ZjJjZWM4MGJmZDBiNzIxYTUzMTA0ZGJiZjdmMzAwMTI3Yjc",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-12T22:55:50Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-18T17:34:05Z"
    },
    "message": "Unify \"catch fork\" and \"catch vfork\"\n\nI noticed that \"catch fork\" and \"catch vfork\" are nearly identical.\nThis patch simplifies the code by unifying these two cases.",
    "tree": {
      "sha": "aba21c5fcaf107701aa69ecbef759d634326c4aa",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/aba21c5fcaf107701aa69ecbef759d634326c4aa"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/59505f2cec80bfd0b721a53104dbbf7f300127b7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/59505f2cec80bfd0b721a53104dbbf7f300127b7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/59505f2cec80bfd0b721a53104dbbf7f300127b7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/59505f2cec80bfd0b721a53104dbbf7f300127b7/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d322d6d69df61a1af481de7e50359c3d92c0de14",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d322d6d69df61a1af481de7e50359c3d92c0de14",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d322d6d69df61a1af481de7e50359c3d92c0de14"
    }
  ],
  "stats": {
    "total": 183,
    "additions": 41,
    "deletions": 142
  },
  "files": [
    {
      "sha": "ede8b43dcabffb3b45f61439220992f18974fde6",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 41,
      "deletions": 142,
      "changes": 183,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/59505f2cec80bfd0b721a53104dbbf7f300127b7/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/59505f2cec80bfd0b721a53104dbbf7f300127b7/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=59505f2cec80bfd0b721a53104dbbf7f300127b7",
      "patch": "@@ -7730,6 +7730,9 @@ disable_breakpoints_in_freed_objfile (struct objfile *objfile)\n \n struct fork_catchpoint : public breakpoint\n {\n+  /* True if the breakpoint is for vfork, false for fork.  */\n+  bool is_vfork;\n+\n   /* Process id of a child process whose forking triggered this\n      catchpoint.  This field is only valid immediately after this\n      catchpoint has triggered.  */\n@@ -7742,7 +7745,12 @@ struct fork_catchpoint : public breakpoint\n static int\n insert_catch_fork (struct bp_location *bl)\n {\n-  return target_insert_fork_catchpoint (inferior_ptid.pid ());\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n+\n+  if (c->is_vfork)\n+    return target_insert_vfork_catchpoint (inferior_ptid.pid ());\n+  else\n+    return target_insert_fork_catchpoint (inferior_ptid.pid ());\n }\n \n /* Implement the \"remove\" breakpoint_ops method for fork\n@@ -7751,7 +7759,12 @@ insert_catch_fork (struct bp_location *bl)\n static int\n remove_catch_fork (struct bp_location *bl, enum remove_bp_reason reason)\n {\n-  return target_remove_fork_catchpoint (inferior_ptid.pid ());\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n+\n+  if (c->is_vfork)\n+    return target_remove_vfork_catchpoint (inferior_ptid.pid ());\n+  else\n+    return target_remove_fork_catchpoint (inferior_ptid.pid ());\n }\n \n /* Implement the \"breakpoint_hit\" breakpoint_ops method for fork\n@@ -7764,7 +7777,9 @@ breakpoint_hit_catch_fork (const struct bp_location *bl,\n {\n   struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n \n-  if (ws.kind () != TARGET_WAITKIND_FORKED)\n+  if (ws.kind () != (c->is_vfork\n+\t\t     ? TARGET_WAITKIND_VFORKED\n+\t\t     : TARGET_WAITKIND_FORKED))\n     return 0;\n \n   c->forked_inferior_pid = ws.child_ptid ();\n@@ -7789,11 +7804,17 @@ print_it_catch_fork (bpstat *bs)\n     uiout->text (\"Catchpoint \");\n   if (uiout->is_mi_like_p ())\n     {\n-      uiout->field_string (\"reason\", async_reason_lookup (EXEC_ASYNC_FORK));\n+      uiout->field_string (\"reason\",\n+\t\t\t   async_reason_lookup (c->is_vfork\n+\t\t\t\t\t\t? EXEC_ASYNC_VFORK\n+\t\t\t\t\t\t: EXEC_ASYNC_FORK));\n       uiout->field_string (\"disp\", bpdisp_text (b->disposition));\n     }\n   uiout->field_signed (\"bkptno\", b->number);\n-  uiout->text (\" (forked process \");\n+  if (c->is_vfork)\n+    uiout->text (\" (vforked process \");\n+  else\n+    uiout->text (\" (forked process \");\n   uiout->field_signed (\"newpid\", c->forked_inferior_pid.pid ());\n   uiout->text (\"), \");\n   return PRINT_SRC_AND_LOC;\n@@ -7817,7 +7838,8 @@ print_one_catch_fork (struct breakpoint *b, struct bp_location **last_loc)\n   if (opts.addressprint)\n     uiout->field_skip (\"addr\");\n   annotate_field (5);\n-  uiout->text (\"fork\");\n+  const char *name = c->is_vfork ? \"vfork\" : \"fork\";\n+  uiout->text (name);\n   if (c->forked_inferior_pid != null_ptid)\n     {\n       uiout->text (\", process \");\n@@ -7826,7 +7848,7 @@ print_one_catch_fork (struct breakpoint *b, struct bp_location **last_loc)\n     }\n \n   if (uiout->is_mi_like_p ())\n-    uiout->field_string (\"catch-type\", \"fork\");\n+    uiout->field_string (\"catch-type\", name);\n }\n \n /* Implement the \"print_mention\" breakpoint_ops method for fork\n@@ -7835,7 +7857,9 @@ print_one_catch_fork (struct breakpoint *b, struct bp_location **last_loc)\n static void\n print_mention_catch_fork (struct breakpoint *b)\n {\n-  printf_filtered (_(\"Catchpoint %d (fork)\"), b->number);\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n+  printf_filtered (_(\"Catchpoint %d (%s)\"), c->number,\n+\t\t   c->is_vfork ? \"vfork\" : \"fork\");\n }\n \n /* Implement the \"print_recreate\" breakpoint_ops method for fork\n@@ -7844,129 +7868,16 @@ print_mention_catch_fork (struct breakpoint *b)\n static void\n print_recreate_catch_fork (struct breakpoint *b, struct ui_file *fp)\n {\n-  fprintf_unfiltered (fp, \"catch fork\");\n+  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n+  fprintf_unfiltered (fp, \"catch %s\",\n+\t\t      c->is_vfork ? \"vfork\" : \"fork\");\n   print_recreate_thread (b, fp);\n }\n \n /* The breakpoint_ops structure to be used in fork catchpoints.  */\n \n static struct breakpoint_ops catch_fork_breakpoint_ops;\n \n-/* Implement the \"insert\" breakpoint_ops method for vfork\n-   catchpoints.  */\n-\n-static int\n-insert_catch_vfork (struct bp_location *bl)\n-{\n-  return target_insert_vfork_catchpoint (inferior_ptid.pid ());\n-}\n-\n-/* Implement the \"remove\" breakpoint_ops method for vfork\n-   catchpoints.  */\n-\n-static int\n-remove_catch_vfork (struct bp_location *bl, enum remove_bp_reason reason)\n-{\n-  return target_remove_vfork_catchpoint (inferior_ptid.pid ());\n-}\n-\n-/* Implement the \"breakpoint_hit\" breakpoint_ops method for vfork\n-   catchpoints.  */\n-\n-static int\n-breakpoint_hit_catch_vfork (const struct bp_location *bl,\n-\t\t\t    const address_space *aspace, CORE_ADDR bp_addr,\n-\t\t\t    const target_waitstatus &ws)\n-{\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n-\n-  if (ws.kind () != TARGET_WAITKIND_VFORKED)\n-    return 0;\n-\n-  c->forked_inferior_pid = ws.child_ptid ();\n-  return 1;\n-}\n-\n-/* Implement the \"print_it\" breakpoint_ops method for vfork\n-   catchpoints.  */\n-\n-static enum print_stop_action\n-print_it_catch_vfork (bpstat *bs)\n-{\n-  struct ui_out *uiout = current_uiout;\n-  struct breakpoint *b = bs->breakpoint_at;\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n-\n-  annotate_catchpoint (b->number);\n-  maybe_print_thread_hit_breakpoint (uiout);\n-  if (b->disposition == disp_del)\n-    uiout->text (\"Temporary catchpoint \");\n-  else\n-    uiout->text (\"Catchpoint \");\n-  if (uiout->is_mi_like_p ())\n-    {\n-      uiout->field_string (\"reason\", async_reason_lookup (EXEC_ASYNC_VFORK));\n-      uiout->field_string (\"disp\", bpdisp_text (b->disposition));\n-    }\n-  uiout->field_signed (\"bkptno\", b->number);\n-  uiout->text (\" (vforked process \");\n-  uiout->field_signed (\"newpid\", c->forked_inferior_pid.pid ());\n-  uiout->text (\"), \");\n-  return PRINT_SRC_AND_LOC;\n-}\n-\n-/* Implement the \"print_one\" breakpoint_ops method for vfork\n-   catchpoints.  */\n-\n-static void\n-print_one_catch_vfork (struct breakpoint *b, struct bp_location **last_loc)\n-{\n-  struct fork_catchpoint *c = (struct fork_catchpoint *) b;\n-  struct value_print_options opts;\n-  struct ui_out *uiout = current_uiout;\n-\n-  get_user_print_options (&opts);\n-  /* Field 4, the address, is omitted (which makes the columns not\n-     line up too nicely with the headers, but the effect is relatively\n-     readable).  */\n-  if (opts.addressprint)\n-    uiout->field_skip (\"addr\");\n-  annotate_field (5);\n-  uiout->text (\"vfork\");\n-  if (c->forked_inferior_pid != null_ptid)\n-    {\n-      uiout->text (\", process \");\n-      uiout->field_signed (\"what\", c->forked_inferior_pid.pid ());\n-      uiout->spaces (1);\n-    }\n-\n-  if (uiout->is_mi_like_p ())\n-    uiout->field_string (\"catch-type\", \"vfork\");\n-}\n-\n-/* Implement the \"print_mention\" breakpoint_ops method for vfork\n-   catchpoints.  */\n-\n-static void\n-print_mention_catch_vfork (struct breakpoint *b)\n-{\n-  printf_filtered (_(\"Catchpoint %d (vfork)\"), b->number);\n-}\n-\n-/* Implement the \"print_recreate\" breakpoint_ops method for vfork\n-   catchpoints.  */\n-\n-static void\n-print_recreate_catch_vfork (struct breakpoint *b, struct ui_file *fp)\n-{\n-  fprintf_unfiltered (fp, \"catch vfork\");\n-  print_recreate_thread (b, fp);\n-}\n-\n-/* The breakpoint_ops structure to be used in vfork catchpoints.  */\n-\n-static struct breakpoint_ops catch_vfork_breakpoint_ops;\n-\n /* An instance of this type is used to represent an solib catchpoint.\n    A breakpoint is really of this type iff its ops pointer points to\n    CATCH_SOLIB_BREAKPOINT_OPS.  */\n@@ -8234,12 +8145,13 @@ install_breakpoint (int internal, std::unique_ptr<breakpoint> &&arg, int update_\n static void\n create_fork_vfork_event_catchpoint (struct gdbarch *gdbarch,\n \t\t\t\t    bool temp, const char *cond_string,\n-\t\t\t\t    const struct breakpoint_ops *ops)\n+\t\t\t\t    bool is_vfork)\n {\n   std::unique_ptr<fork_catchpoint> c (new fork_catchpoint ());\n \n-  init_catchpoint (c.get (), gdbarch, temp, cond_string, ops);\n-\n+  init_catchpoint (c.get (), gdbarch, temp, cond_string,\n+\t\t   &catch_fork_breakpoint_ops);\n+  c->is_vfork = is_vfork;\n   c->forked_inferior_pid = null_ptid;\n \n   install_breakpoint (0, std::move (c), 1);\n@@ -11290,13 +11202,11 @@ catch_fork_command_1 (const char *arg, int from_tty,\n     {\n     case catch_fork_temporary:\n     case catch_fork_permanent:\n-      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string,\n-\t\t\t\t\t  &catch_fork_breakpoint_ops);\n+      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string, false);\n       break;\n     case catch_vfork_temporary:\n     case catch_vfork_permanent:\n-      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string,\n-\t\t\t\t\t  &catch_vfork_breakpoint_ops);\n+      create_fork_vfork_event_catchpoint (gdbarch, temp, cond_string, true);\n       break;\n     default:\n       error (_(\"unsupported or unknown fork kind; cannot catch it\"));\n@@ -15365,17 +15275,6 @@ initialize_breakpoint_ops (void)\n   ops->print_mention = print_mention_catch_fork;\n   ops->print_recreate = print_recreate_catch_fork;\n \n-  /* Vfork catchpoints.  */\n-  ops = &catch_vfork_breakpoint_ops;\n-  *ops = base_breakpoint_ops;\n-  ops->insert_location = insert_catch_vfork;\n-  ops->remove_location = remove_catch_vfork;\n-  ops->breakpoint_hit = breakpoint_hit_catch_vfork;\n-  ops->print_it = print_it_catch_vfork;\n-  ops->print_one = print_one_catch_vfork;\n-  ops->print_mention = print_mention_catch_vfork;\n-  ops->print_recreate = print_recreate_catch_vfork;\n-\n   /* Exec catchpoints.  */\n   ops = &catch_exec_breakpoint_ops;\n   *ops = base_breakpoint_ops;"
    }
  ]
}