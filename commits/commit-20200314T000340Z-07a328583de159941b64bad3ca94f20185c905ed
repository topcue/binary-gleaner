{
  "sha": "07a328583de159941b64bad3ca94f20185c905ed",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDdhMzI4NTgzZGUxNTk5NDFiNjRiYWQzY2E5NGYyMDE4NWM5MDVlZA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-13T23:39:52Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-14T00:03:40Z"
    },
    "message": "Convert Pascal to value-based API\n\nThis finishes the conversion of Pascal to the value-based API, by\nintroducing two more value-based analogues of existing val-print\nfunctions.\n\ngdb/ChangeLog\n2020-03-13  Tom Tromey  <tom@tromey.com>\n\n\t* p-valprint.c (pascal_object_print_value_fields)\n\t(pascal_object_print_value): New functions.",
    "tree": {
      "sha": "6ef9b5abed3b4f1cd7a1daee458e35511c544d6e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6ef9b5abed3b4f1cd7a1daee458e35511c544d6e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/07a328583de159941b64bad3ca94f20185c905ed",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/07a328583de159941b64bad3ca94f20185c905ed",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/07a328583de159941b64bad3ca94f20185c905ed",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/07a328583de159941b64bad3ca94f20185c905ed/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "64d64d3a76bb57305b278082ed1a29f0982b664d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/64d64d3a76bb57305b278082ed1a29f0982b664d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/64d64d3a76bb57305b278082ed1a29f0982b664d"
    }
  ],
  "stats": {
    "total": 315,
    "additions": 315,
    "deletions": 0
  },
  "files": [
    {
      "sha": "bf07c402dd2657b3cef4d8d194b1348f06a59ffc",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/07a328583de159941b64bad3ca94f20185c905ed/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/07a328583de159941b64bad3ca94f20185c905ed/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=07a328583de159941b64bad3ca94f20185c905ed",
      "patch": "@@ -1,3 +1,8 @@\n+2020-03-13  Tom Tromey  <tom@tromey.com>\n+\n+\t* p-valprint.c (pascal_object_print_value_fields)\n+\t(pascal_object_print_value): New functions.\n+\n 2020-03-13  Tom Tromey  <tom@tromey.com>\n \n \t* p-valprint.c (pascal_value_print_inner): Rewrite."
    },
    {
      "sha": "d53cfd54a63630eb58bdaedfbdebd88e1f50211a",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 310,
      "deletions": 0,
      "changes": 310,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/07a328583de159941b64bad3ca94f20185c905ed/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/07a328583de159941b64bad3ca94f20185c905ed/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=07a328583de159941b64bad3ca94f20185c905ed",
      "patch": "@@ -50,6 +50,11 @@ static void pascal_object_print_value_fields (struct type *, const gdb_byte *,\n \t\t\t\t\t      const struct value_print_options *,\n \t\t\t\t\t      struct type **, int);\n \n+static void pascal_object_print_value_fields (struct value *, struct ui_file *,\n+\t\t\t\t\t      int,\n+\t\t\t\t\t      const struct value_print_options *,\n+\t\t\t\t\t      struct type **, int);\n+\n /* Decorations for Pascal.  */\n \n static const struct generic_val_print_decorations p_decorations =\n@@ -833,6 +838,10 @@ static void pascal_object_print_value (struct type *, const gdb_byte *,\n \t\t\t\t       const struct value_print_options *,\n \t\t\t\t       struct type **);\n \n+static void pascal_object_print_value (struct value *, struct ui_file *, int,\n+\t\t\t\t       const struct value_print_options *,\n+\t\t\t\t       struct type **);\n+\n /* It was changed to this after 2.4.5.  */\n const char pascal_vtbl_ptr_name[] =\n {'_', '_', 'v', 't', 'b', 'l', '_', 'p', 't', 'r', '_', 't', 'y', 'p', 'e', 0};\n@@ -1062,6 +1071,188 @@ pascal_object_print_value_fields (struct type *type, const gdb_byte *valaddr,\n   fprintf_filtered (stream, \"}\");\n }\n \n+/* Mutually recursive subroutines of pascal_object_print_value and\n+   pascal_value_print to print out a structure's fields:\n+   pascal_object_print_value_fields and pascal_object_print_value.\n+\n+   VAL, STREAM, RECURSE, and OPTIONS have the same meanings as in\n+   pascal_object_print_value and c_value_print.\n+\n+   DONT_PRINT is an array of baseclass types that we\n+   should not print, or zero if called from top level.  */\n+\n+static void\n+pascal_object_print_value_fields (struct value *val, struct ui_file *stream,\n+\t\t\t\t  int recurse,\n+\t\t\t\t  const struct value_print_options *options,\n+\t\t\t\t  struct type **dont_print_vb,\n+\t\t\t\t  int dont_print_statmem)\n+{\n+  int i, len, n_baseclasses;\n+  char *last_dont_print\n+    = (char *) obstack_next_free (&dont_print_statmem_obstack);\n+\n+  struct type *type = check_typedef (value_type (val));\n+\n+  fprintf_filtered (stream, \"{\");\n+  len = TYPE_NFIELDS (type);\n+  n_baseclasses = TYPE_N_BASECLASSES (type);\n+\n+  /* Print out baseclasses such that we don't print\n+     duplicates of virtual baseclasses.  */\n+  if (n_baseclasses > 0)\n+    pascal_object_print_value (val, stream, recurse + 1,\n+\t\t\t       options, dont_print_vb);\n+\n+  if (!len && n_baseclasses == 1)\n+    fprintf_styled (stream, metadata_style.style (), \"<No data fields>\");\n+  else\n+    {\n+      struct obstack tmp_obstack = dont_print_statmem_obstack;\n+      int fields_seen = 0;\n+      const gdb_byte *valaddr = value_contents_for_printing (val);\n+\n+      if (dont_print_statmem == 0)\n+\t{\n+\t  /* If we're at top level, carve out a completely fresh\n+\t     chunk of the obstack and use that until this particular\n+\t     invocation returns.  */\n+\t  obstack_finish (&dont_print_statmem_obstack);\n+\t}\n+\n+      for (i = n_baseclasses; i < len; i++)\n+\t{\n+\t  /* If requested, skip printing of static fields.  */\n+\t  if (!options->pascal_static_field_print\n+\t      && field_is_static (&TYPE_FIELD (type, i)))\n+\t    continue;\n+\t  if (fields_seen)\n+\t    fprintf_filtered (stream, \", \");\n+\t  else if (n_baseclasses > 0)\n+\t    {\n+\t      if (options->prettyformat)\n+\t\t{\n+\t\t  fprintf_filtered (stream, \"\\n\");\n+\t\t  print_spaces_filtered (2 + 2 * recurse, stream);\n+\t\t  fputs_filtered (\"members of \", stream);\n+\t\t  fputs_filtered (TYPE_NAME (type), stream);\n+\t\t  fputs_filtered (\": \", stream);\n+\t\t}\n+\t    }\n+\t  fields_seen = 1;\n+\n+\t  if (options->prettyformat)\n+\t    {\n+\t      fprintf_filtered (stream, \"\\n\");\n+\t      print_spaces_filtered (2 + 2 * recurse, stream);\n+\t    }\n+\t  else\n+\t    {\n+\t      wrap_here (n_spaces (2 + 2 * recurse));\n+\t    }\n+\n+\t  annotate_field_begin (TYPE_FIELD_TYPE (type, i));\n+\n+\t  if (field_is_static (&TYPE_FIELD (type, i)))\n+\t    {\n+\t      fputs_filtered (\"static \", stream);\n+\t      fprintf_symbol_filtered (stream,\n+\t\t\t\t       TYPE_FIELD_NAME (type, i),\n+\t\t\t\t       current_language->la_language,\n+\t\t\t\t       DMGL_PARAMS | DMGL_ANSI);\n+\t    }\n+\t  else\n+\t    fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t\t\t  variable_name_style.style (), stream);\n+\t  annotate_field_name_end ();\n+\t  fputs_filtered (\" = \", stream);\n+\t  annotate_field_value ();\n+\n+\t  if (!field_is_static (&TYPE_FIELD (type, i))\n+\t      && TYPE_FIELD_PACKED (type, i))\n+\t    {\n+\t      struct value *v;\n+\n+\t      /* Bitfields require special handling, especially due to byte\n+\t         order problems.  */\n+\t      if (TYPE_FIELD_IGNORE (type, i))\n+\t\t{\n+\t\t  fputs_styled (\"<optimized out or zero length>\",\n+\t\t\t\tmetadata_style.style (), stream);\n+\t\t}\n+\t      else if (value_bits_synthetic_pointer (val,\n+\t\t\t\t\t\t     TYPE_FIELD_BITPOS (type,\n+\t\t\t\t\t\t\t\t\ti),\n+\t\t\t\t\t\t     TYPE_FIELD_BITSIZE (type,\n+\t\t\t\t\t\t\t\t\t i)))\n+\t\t{\n+\t\t  fputs_styled (_(\"<synthetic pointer>\"),\n+\t\t\t\tmetadata_style.style (), stream);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct value_print_options opts = *options;\n+\n+\t\t  v = value_field_bitfield (type, i, valaddr, 0, val);\n+\n+\t\t  opts.deref_ref = 0;\n+\t\t  common_val_print (v, stream, recurse + 1, &opts,\n+\t\t\t\t    current_language);\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      if (TYPE_FIELD_IGNORE (type, i))\n+\t\t{\n+\t\t  fputs_styled (\"<optimized out or zero length>\",\n+\t\t\t\tmetadata_style.style (), stream);\n+\t\t}\n+\t      else if (field_is_static (&TYPE_FIELD (type, i)))\n+\t\t{\n+\t\t  /* struct value *v = value_static_field (type, i);\n+\t\t     v4.17 specific.  */\n+\t\t  struct value *v;\n+\n+\t\t  v = value_field_bitfield (type, i, valaddr, 0, val);\n+\n+\t\t  if (v == NULL)\n+\t\t    val_print_optimized_out (NULL, stream);\n+\t\t  else\n+\t\t    pascal_object_print_static_field (v, stream, recurse + 1,\n+\t\t\t\t\t\t      options);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  struct value_print_options opts = *options;\n+\n+\t\t  opts.deref_ref = 0;\n+\n+\t\t  struct value *v = value_primitive_field (val, 0, i,\n+\t\t\t\t\t\t\t   value_type (val));\n+\t\t  common_val_print (v, stream, recurse + 1, &opts,\n+\t\t\t\t    current_language);\n+\t\t}\n+\t    }\n+\t  annotate_field_end ();\n+\t}\n+\n+      if (dont_print_statmem == 0)\n+\t{\n+\t  /* Free the space used to deal with the printing\n+\t     of the members from top level.  */\n+\t  obstack_free (&dont_print_statmem_obstack, last_dont_print);\n+\t  dont_print_statmem_obstack = tmp_obstack;\n+\t}\n+\n+      if (options->prettyformat)\n+\t{\n+\t  fprintf_filtered (stream, \"\\n\");\n+\t  print_spaces_filtered (2 * recurse, stream);\n+\t}\n+    }\n+  fprintf_filtered (stream, \"}\");\n+}\n+\n /* Special val_print routine to avoid printing multiple copies of virtual\n    baseclasses.  */\n \n@@ -1188,6 +1379,125 @@ pascal_object_print_value (struct type *type, const gdb_byte *valaddr,\n     }\n }\n \n+/* Special val_print routine to avoid printing multiple copies of virtual\n+   baseclasses.  */\n+\n+static void\n+pascal_object_print_value (struct value *val, struct ui_file *stream,\n+\t\t\t   int recurse,\n+\t\t\t   const struct value_print_options *options,\n+\t\t\t   struct type **dont_print_vb)\n+{\n+  struct type **last_dont_print\n+    = (struct type **) obstack_next_free (&dont_print_vb_obstack);\n+  struct obstack tmp_obstack = dont_print_vb_obstack;\n+  struct type *type = check_typedef (value_type (val));\n+  int i, n_baseclasses = TYPE_N_BASECLASSES (type);\n+\n+  if (dont_print_vb == 0)\n+    {\n+      /* If we're at top level, carve out a completely fresh\n+         chunk of the obstack and use that until this particular\n+         invocation returns.  */\n+      /* Bump up the high-water mark.  Now alpha is omega.  */\n+      obstack_finish (&dont_print_vb_obstack);\n+    }\n+\n+  for (i = 0; i < n_baseclasses; i++)\n+    {\n+      LONGEST boffset = 0;\n+      struct type *baseclass = check_typedef (TYPE_BASECLASS (type, i));\n+      const char *basename = TYPE_NAME (baseclass);\n+      int skip = 0;\n+\n+      if (BASETYPE_VIA_VIRTUAL (type, i))\n+\t{\n+\t  struct type **first_dont_print\n+\t    = (struct type **) obstack_base (&dont_print_vb_obstack);\n+\n+\t  int j = (struct type **) obstack_next_free (&dont_print_vb_obstack)\n+\t    - first_dont_print;\n+\n+\t  while (--j >= 0)\n+\t    if (baseclass == first_dont_print[j])\n+\t      goto flush_it;\n+\n+\t  obstack_ptr_grow (&dont_print_vb_obstack, baseclass);\n+\t}\n+\n+      struct value *base_value;\n+      try\n+\t{\n+\t  base_value = value_primitive_field (val, 0, i, type);\n+\t}\n+      catch (const gdb_exception_error &ex)\n+\t{\n+\t  if (ex.error == NOT_AVAILABLE_ERROR)\n+\t    skip = -1;\n+\t  else\n+\t    skip = 1;\n+\t}\n+\n+      if (skip == 0)\n+\t{\n+\t  /* The virtual base class pointer might have been clobbered by the\n+\t     user program. Make sure that it still points to a valid memory\n+\t     location.  */\n+\n+\t  if (boffset < 0 || boffset >= TYPE_LENGTH (type))\n+\t    {\n+\t      CORE_ADDR address= value_address (val);\n+\t      gdb::byte_vector buf (TYPE_LENGTH (baseclass));\n+\n+\t      if (target_read_memory (address + boffset, buf.data (),\n+\t\t\t\t      TYPE_LENGTH (baseclass)) != 0)\n+\t\tskip = 1;\n+\t      base_value = value_from_contents_and_address (baseclass,\n+\t\t\t\t\t\t\t    buf.data (),\n+\t\t\t\t\t\t\t    address + boffset);\n+\t      baseclass = value_type (base_value);\n+\t      boffset = 0;\n+\t    }\n+\t}\n+\n+      if (options->prettyformat)\n+\t{\n+\t  fprintf_filtered (stream, \"\\n\");\n+\t  print_spaces_filtered (2 * recurse, stream);\n+\t}\n+      fputs_filtered (\"<\", stream);\n+      /* Not sure what the best notation is in the case where there is no\n+         baseclass name.  */\n+\n+      fputs_filtered (basename ? basename : \"\", stream);\n+      fputs_filtered (\"> = \", stream);\n+\n+      if (skip < 0)\n+\tval_print_unavailable (stream);\n+      else if (skip > 0)\n+\tval_print_invalid_address (stream);\n+      else\n+\tpascal_object_print_value_fields\n+\t  (base_value, stream, recurse, options,\n+\t   (struct type **) obstack_base (&dont_print_vb_obstack),\n+\t   0);\n+      fputs_filtered (\", \", stream);\n+\n+    flush_it:\n+      ;\n+    }\n+\n+  if (dont_print_vb == 0)\n+    {\n+      /* Free the space used to deal with the printing\n+         of this type from top level.  */\n+      obstack_free (&dont_print_vb_obstack, last_dont_print);\n+      /* Reset watermark so that we can continue protecting\n+         ourselves from whatever we were protecting ourselves.  */\n+      dont_print_vb_obstack = tmp_obstack;\n+    }\n+}\n+\n /* Print value of a static member.\n    To avoid infinite recursion when printing a class that contains\n    a static instance of the class, we keep the addresses of all printed"
    }
  ]
}