{
  "sha": "b209b5a6b8a4433be961a0f016439f381de65bfc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjIwOWI1YTZiOGE0NDMzYmU5NjFhMGYwMTY0MzlmMzgxZGU2NWJmYw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-01-13T03:03:34Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-01-13T11:36:02Z"
    },
    "message": "SHF_LINK_ORDER fixup_link_order in ld\n\nThis moves the SHF_LINK_ORDER sorting from bfd_elf_final_link to\nthe linker which means generic ELF targets now support SHF_LINK_ORDER\nand  we cope with odd cases that require resizing of output sections.\nThe patch also fixes two bugs in the current implementation,\nintroduced by commit cd6d537c48fa.  The pattern test used by that\ncommit meant that sections matching something like\n\"*(.IA_64.unwind* .gnu.linkonce.ia64unw.*)\" would not properly sort a\nmix of sections matching the two wildcards.  That commit also assumed\na stable qsort.\n\nbfd/\n\tPR 27160\n\t* section.c (struct bfd_section): Remove pattern field.\n\t(BFD_FAKE_SECTION): Adjust to suit.\n\t* bfd-in2.h: Regenerate.\n\t* elflink.c (compare_link_order, elf_fixup_link_order): Delete.\n\t(bfd_elf_final_link): Don't call elf_fixup_link_order.\nld/\n\tPR 27160\n\t* ldlang.h (lang_output_section_statement_type): Add data field.\n\t(lang_input_section_type, lang_section_bst_type): Add pattern field.\n\t(statement_list): Declare.\n\t(lang_add_section): Adjust prototype.\n\t* emultempl/aarch64elf.em: Adjust lang_add_section calls.\n\t* emultempl/armelf.em: Likewise.\n\t* emultempl/beos.em: Likewise.\n\t* emultempl/cskyelf.em: Likewise.\n\t* emultempl/hppaelf.em: Likewise.\n\t* emultempl/m68hc1xelf.em: Likewise.\n\t* emultempl/metagelf.em: Likewise.\n\t* emultempl/mipself.em: Likewise.\n\t* emultempl/mmo.em: Likewise.\n\t* emultempl/msp430.em: Likewise.\n\t* emultempl/nios2elf.em: Likewise.\n\t* emultempl/pe.em: Likewise.\n\t* emultempl/pep.em: Likewise.\n\t* emultempl/ppc64elf.em: Likewise.\n\t* emultempl/spuelf.em: Likewise.\n\t* emultempl/vms.em: Likewise.\n\t* ldelf.c: Likewise.\n\t* ldelfgen.c: Include ldctor.h.\n\t(struct os_sections): New.\n\t(add_link_order_input_section, link_order_scan): New functions.\n\t(compare_link_order, fixup_link_order): New functions.\n\t(ldelf_map_segments): Call link_order_scan and fixup_link_order.\n\t* ldlang.c (statement_list): Make global.\n\t(output_section_callback_fast): Save pattern in tree node.\n\t(lang_add_section): Add pattern parameter, save in lang_input_section.\n\t(output_section_callback_tree_to_list): Adjust lang_add_section calls.\n\t(lang_insert_orphan, output_section_callback): Likewise.\n\t(ldlang_place_orphan): Likewise.\n\t(gc_section_callback): Don't set section->pattern\n\t* testsuite/ld-elf/pr26256-2a.d: Don't xfail generic.\n\t* testsuite/ld-elf/pr26256-3b.d: Likewise.\n\t* testsuite/ld-elf/pr26256-2b.d: Likewise.  notarget xgate.",
    "tree": {
      "sha": "b540de64953f26165ed65e17c6b96a58b95e30c8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b540de64953f26165ed65e17c6b96a58b95e30c8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b209b5a6b8a4433be961a0f016439f381de65bfc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b209b5a6b8a4433be961a0f016439f381de65bfc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b209b5a6b8a4433be961a0f016439f381de65bfc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b209b5a6b8a4433be961a0f016439f381de65bfc/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8c4645b4887660eb704f152f2a14c5108d56c9d7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c4645b4887660eb704f152f2a14c5108d56c9d7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8c4645b4887660eb704f152f2a14c5108d56c9d7"
    }
  ],
  "stats": {
    "total": 599,
    "additions": 349,
    "deletions": 250
  },
  "files": [
    {
      "sha": "0e12e74ea6ed1fccd4846583de2b229d734caf08",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -1,3 +1,12 @@\n+2021-01-13  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 27160\n+\t* section.c (struct bfd_section): Remove pattern field.\n+\t(BFD_FAKE_SECTION): Adjust to suit.\n+\t* bfd-in2.h: Regenerate.\n+\t* elflink.c (compare_link_order, elf_fixup_link_order): Delete.\n+\t(bfd_elf_final_link): Don't call elf_fixup_link_order.\n+\n 2021-01-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR binutils/26792"
    },
    {
      "sha": "d142bb5221348554039a8ba9504f3a65c7eb7a3e",
      "filename": "bfd/bfd-in2.h",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/bfd/bfd-in2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/bfd/bfd-in2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in2.h?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -1184,9 +1184,6 @@ typedef struct bfd_section\n   struct bfd_symbol *symbol;\n   struct bfd_symbol **symbol_ptr_ptr;\n \n-  /* The matching section name pattern in linker script.  */\n-  const char *pattern;\n-\n   /* Early in the link process, map_head and map_tail are used to build\n      a list of input sections attached to an output section.  Later,\n      output sections use these fields for a list of bfd_link_order\n@@ -1380,8 +1377,8 @@ discarded_section (const asection *sec)\n   /* target_index, used_by_bfd, constructor_chain, owner,           */ \\\n      0,            NULL,        NULL,              NULL,               \\\n                                                                        \\\n-  /* symbol,                    symbol_ptr_ptr, pattern,            */ \\\n-     (struct bfd_symbol *) SYM, &SEC.symbol,    NULL,                  \\\n+  /* symbol,                    symbol_ptr_ptr,                     */ \\\n+     (struct bfd_symbol *) SYM, &SEC.symbol,                           \\\n                                                                        \\\n   /* map_head, map_tail, already_assigned                           */ \\\n      { NULL }, { NULL }, NULL                                          \\"
    },
    {
      "sha": "d20857eb6bd063ed60122d526e69b7ab7f32ce4c",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 0,
      "deletions": 194,
      "changes": 194,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -11863,193 +11863,6 @@ elf_reloc_link_order (bfd *output_bfd,\n   return TRUE;\n }\n \n-\n-/* Compare two sections based on the locations of the sections they are\n-   linked to.  Used by elf_fixup_link_order.  */\n-\n-static int\n-compare_link_order (const void *a, const void *b)\n-{\n-  const struct bfd_link_order *alo = *(const struct bfd_link_order **) a;\n-  const struct bfd_link_order *blo = *(const struct bfd_link_order **) b;\n-  asection *asec = elf_linked_to_section (alo->u.indirect.section);\n-  asection *bsec = elf_linked_to_section (blo->u.indirect.section);\n-  bfd_vma apos, bpos;\n-\n-  /* Check if any sections are unordered.  */\n-  if (asec == NULL || bsec == NULL)\n-    {\n-      /* Place unordered sections before ordered sections.  */\n-      if (bsec != NULL)\n-\treturn -1;\n-      else if (asec != NULL)\n-\treturn 1;\n-      return 0;\n-    }\n-\n-  apos = asec->output_section->lma + asec->output_offset;\n-  bpos = bsec->output_section->lma + bsec->output_offset;\n-\n-  if (apos < bpos)\n-    return -1;\n-  if (apos > bpos)\n-    return 1;\n-\n-  /* The only way we should get matching LMAs is when the first of two\n-     sections has zero size.  */\n-  if (asec->size < bsec->size)\n-    return -1;\n-  if (asec->size > bsec->size)\n-    return 1;\n-\n-  /* If they are both zero size then they almost certainly have the same\n-     VMA and thus are not ordered with respect to each other.  Test VMA\n-     anyway, and fall back to id to make the result reproducible across\n-     qsort implementations.  */\n-  apos = asec->output_section->vma + asec->output_offset;\n-  bpos = bsec->output_section->vma + bsec->output_offset;\n-  if (apos < bpos)\n-    return -1;\n-  if (apos > bpos)\n-    return 1;\n-\n-  return asec->id - bsec->id;\n-}\n-\n-\n-/* Looks for sections with SHF_LINK_ORDER set.  Rearranges them into the same\n-   order as their linked sections.  Returns false if this could not be done\n-   because an output section includes both ordered and unordered\n-   sections.  Ideally we'd do this in the linker proper.  */\n-\n-static bfd_boolean\n-elf_fixup_link_order (struct bfd_link_info *info, bfd *abfd, asection *o)\n-{\n-  size_t seen_linkorder;\n-  size_t seen_other;\n-  size_t n;\n-  struct bfd_link_order *p;\n-  bfd *sub;\n-  struct bfd_link_order **sections, **indirect_sections;\n-  asection *other_sec, *linkorder_sec;\n-  bfd_vma offset;  /* Octets.  */\n-\n-  other_sec = NULL;\n-  linkorder_sec = NULL;\n-  seen_other = 0;\n-  seen_linkorder = 0;\n-  for (p = o->map_head.link_order; p != NULL; p = p->next)\n-    {\n-      if (p->type == bfd_indirect_link_order)\n-\t{\n-\t  asection *s = p->u.indirect.section;\n-\t  sub = s->owner;\n-\t  if ((s->flags & SEC_LINKER_CREATED) == 0\n-\t      && bfd_get_flavour (sub) == bfd_target_elf_flavour\n-\t      && elf_section_data (s) != NULL\n-\t      && elf_linked_to_section (s) != NULL)\n-\t    {\n-\t      seen_linkorder++;\n-\t      linkorder_sec = s;\n-\t    }\n-\t  else\n-\t    {\n-\t      seen_other++;\n-\t      other_sec = s;\n-\t    }\n-\t}\n-      else\n-\tseen_other++;\n-\n-      /* Allow mixed ordered and unordered input sections for\n-         non-relocatable link.  */\n-      if (bfd_link_relocatable (info) && seen_other && seen_linkorder)\n-\t{\n-\t  if (other_sec && linkorder_sec)\n-\t    _bfd_error_handler\n-\t      /* xgettext:c-format */\n-\t      (_(\"%pA has both ordered [`%pA' in %pB] \"\n-\t\t \"and unordered [`%pA' in %pB] sections\"),\n-\t       o, linkorder_sec, linkorder_sec->owner,\n-\t       other_sec, other_sec->owner);\n-\t  else\n-\t    _bfd_error_handler\n-\t      (_(\"%pA has both ordered and unordered sections\"), o);\n-\t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n-\t}\n-    }\n-\n-  if (!seen_linkorder)\n-    return TRUE;\n-\n-  /* Non-relocatable output can have both ordered and unordered input\n-     sections.  */\n-  seen_linkorder += seen_other;\n-\n-  sections = bfd_malloc (seen_linkorder * sizeof (*sections));\n-  if (sections == NULL)\n-    return FALSE;\n-\n-  seen_linkorder = 0;\n-  for (p = o->map_head.link_order; p != NULL; p = p->next)\n-    sections[seen_linkorder++] = p;\n-\n-  for (indirect_sections = sections, n = 0;\n-       n < seen_linkorder;\n-       indirect_sections++, n++)\n-    {\n-      /* Find the first bfd_indirect_link_order section.  */\n-      if (indirect_sections[0]->type == bfd_indirect_link_order)\n-\t{\n-\t  /* Count the consecutive bfd_indirect_link_order sections\n-\t     with the same pattern.  */\n-\t  size_t i, n_indirect;\n-\t  const char *pattern\n-\t    = indirect_sections[0]->u.indirect.section->pattern;\n-\t  for (i = n + 1; i < seen_linkorder; i++)\n-\t    if (sections[i]->type != bfd_indirect_link_order\n-\t\t|| sections[i]->u.indirect.section->pattern != pattern)\n-\t      break;\n-\t  n_indirect = i - n;\n-\t  /* Sort the bfd_indirect_link_order sections in the order of\n-\t     their linked section.  */\n-\t  qsort (indirect_sections, n_indirect, sizeof (*sections),\n-\t\t compare_link_order);\n-\t  indirect_sections += n_indirect;\n-\t  n += n_indirect;\n-\t}\n-    }\n-\n-  /* Change the offsets of the bfd_indirect_link_order sections.  */\n-  offset = 0;\n-  for (n = 0; n < seen_linkorder; n++)\n-    if (sections[n]->type == bfd_indirect_link_order)\n-      {\n-\tbfd_vma mask;\n-\tasection *s = sections[n]->u.indirect.section;\n-\tunsigned int opb = bfd_octets_per_byte (abfd, s);\n-\n-\tmask = ~(bfd_vma) 0 << s->alignment_power * opb;\n-\toffset = (offset + ~mask) & mask;\n-\tsections[n]->offset = s->output_offset = offset / opb;\n-\toffset += sections[n]->size;\n-      }\n-    else\n-      offset = sections[n]->offset + sections[n]->size;\n-\n-  free (sections);\n-\n-  /* Verify that fixing up SHF_LINK_ORDER doesn't increase the section\n-     size.  */\n-  if (offset > o->size)\n-    info->callbacks->einfo\n-      (_(\"%F%P: %pA has ordered sections with incompatible alignments\\n\"),\n-       o);\n-\n-  return TRUE;\n-}\n-\n /* Generate an import library in INFO->implib_bfd from symbols in ABFD.\n    Returns TRUE upon success, FALSE otherwise.  */\n \n@@ -12683,13 +12496,6 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)\n       htab->tls_size = end - base;\n     }\n \n-  /* Reorder SHF_LINK_ORDER sections.  */\n-  for (o = abfd->sections; o != NULL; o = o->next)\n-    {\n-      if (!elf_fixup_link_order (info, abfd, o))\n-\treturn FALSE;\n-    }\n-\n   if (!_bfd_elf_fixup_eh_frame_hdr (info))\n     return FALSE;\n "
    },
    {
      "sha": "3e6ba0c09389c21b149e6fc8dff599050b4f7282",
      "filename": "bfd/section.c",
      "status": "modified",
      "additions": 2,
      "deletions": 5,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/bfd/section.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/bfd/section.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/section.c?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -541,9 +541,6 @@ CODE_FRAGMENT\n .  struct bfd_symbol *symbol;\n .  struct bfd_symbol **symbol_ptr_ptr;\n .\n-.  {* The matching section name pattern in linker script.  *}\n-.  const char *pattern;\n-.\n .  {* Early in the link process, map_head and map_tail are used to build\n .     a list of input sections attached to an output section.  Later,\n .     output sections use these fields for a list of bfd_link_order\n@@ -737,8 +734,8 @@ CODE_FRAGMENT\n .  {* target_index, used_by_bfd, constructor_chain, owner,           *}\t\\\n .     0,            NULL,        NULL,              NULL,\t\t\\\n .\t\t\t\t\t\t\t\t\t\\\n-.  {* symbol,                    symbol_ptr_ptr, pattern,            *}\t\\\n-.     (struct bfd_symbol *) SYM, &SEC.symbol,    NULL,\t\t\t\\\n+.  {* symbol,                    symbol_ptr_ptr,                     *}\t\\\n+.     (struct bfd_symbol *) SYM, &SEC.symbol,\t\t\t\t\\\n .\t\t\t\t\t\t\t\t\t\\\n .  {* map_head, map_tail, already_assigned                           *}\t\\\n .     { NULL }, { NULL }, NULL\t\t\t\t\t\t\\"
    },
    {
      "sha": "b1db01110d71b73c42773e590473da01ae15e8c6",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 40,
      "deletions": 0,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -1,3 +1,43 @@\n+2021-01-13  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 27160\n+\t* ldlang.h (lang_output_section_statement_type): Add data field.\n+\t(lang_input_section_type, lang_section_bst_type): Add pattern field.\n+\t(statement_list): Declare.\n+\t(lang_add_section): Adjust prototype.\n+\t* emultempl/aarch64elf.em: Adjust lang_add_section calls.\n+\t* emultempl/armelf.em: Likewise.\n+\t* emultempl/beos.em: Likewise.\n+\t* emultempl/cskyelf.em: Likewise.\n+\t* emultempl/hppaelf.em: Likewise.\n+\t* emultempl/m68hc1xelf.em: Likewise.\n+\t* emultempl/metagelf.em: Likewise.\n+\t* emultempl/mipself.em: Likewise.\n+\t* emultempl/mmo.em: Likewise.\n+\t* emultempl/msp430.em: Likewise.\n+\t* emultempl/nios2elf.em: Likewise.\n+\t* emultempl/pe.em: Likewise.\n+\t* emultempl/pep.em: Likewise.\n+\t* emultempl/ppc64elf.em: Likewise.\n+\t* emultempl/spuelf.em: Likewise.\n+\t* emultempl/vms.em: Likewise.\n+\t* ldelf.c: Likewise.\n+\t* ldelfgen.c: Include ldctor.h.\n+\t(struct os_sections): New.\n+\t(add_link_order_input_section, link_order_scan): New functions.\n+\t(compare_link_order, fixup_link_order): New functions.\n+\t(ldelf_map_segments): Call link_order_scan and fixup_link_order.\n+\t* ldlang.c (statement_list): Make global.\n+\t(output_section_callback_fast): Save pattern in tree node.\n+\t(lang_add_section): Add pattern parameter, save in lang_input_section.\n+\t(output_section_callback_tree_to_list): Adjust lang_add_section calls.\n+\t(lang_insert_orphan, output_section_callback): Likewise.\n+\t(ldlang_place_orphan): Likewise.\n+\t(gc_section_callback): Don't set section->pattern.\n+\t* testsuite/ld-elf/pr26256-2a.d: Don't xfail generic.\n+\t* testsuite/ld-elf/pr26256-3b.d: Likewise.\n+\t* testsuite/ld-elf/pr26256-2b.d: Likewise.  notarget xgate.\n+\n 2021-01-13  Alan Modra  <amodra@gmail.com>\n \n \t* ldlang.h (callback_t): Remove flag_info function parameter."
    },
    {
      "sha": "a1855607327ec4942e5902d2e605788f60741558",
      "filename": "ld/emultempl/aarch64elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/aarch64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/aarch64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/aarch64elf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -192,7 +192,7 @@ elf${ELFSIZE}_aarch64_add_stub_section (const char *stub_sec_name,\n \n   info.input_section = input_section;\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n \n   if (info.add.head == NULL)\n     goto err_ret;"
    },
    {
      "sha": "a4cf93b493daab32c754197aae4847879b10306e",
      "filename": "ld/emultempl/armelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/armelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/armelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/armelf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -246,7 +246,7 @@ elf32_arm_add_stub_section (const char * stub_sec_name,\n \n   info.input_section = after_input_section;\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n \n   if (info.add.head == NULL)\n     goto err_ret;"
    },
    {
      "sha": "bb4395f63ae964e5e71333cc4629417af770d799",
      "filename": "ld/emultempl/beos.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/beos.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/beos.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/beos.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -704,7 +704,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,\n      The sections still have to be sorted, but that has to wait until\n      all such sections have been processed by us.  The sorting is done by\n      sort_sections.  */\n-  lang_add_section (&l->wild_statement.children, s, NULL, os);\n+  lang_add_section (&l->wild_statement.children, s, NULL, NULL, os);\n \n   return os;\n }"
    },
    {
      "sha": "ca38cf62b9826b7b1c58d6b3943b284232f91b62",
      "filename": "ld/emultempl/cskyelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/cskyelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/cskyelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/cskyelf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -189,7 +189,7 @@ elf32_csky_add_stub_section (const char *stub_sec_name,\n \n   info.input_section = input_section;\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n \n   if (info.add.head == NULL)\n     goto err_ret;"
    },
    {
      "sha": "f195a177aba28c0089dbcf173ccf0cd3d680cd16",
      "filename": "ld/emultempl/hppaelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/hppaelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/hppaelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/hppaelf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -193,7 +193,7 @@ hppaelf_add_stub_section (const char *stub_sec_name, asection *input_section)\n \n   info.input_section = input_section;\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n \n   if (info.add.head == NULL)\n     goto err_ret;"
    },
    {
      "sha": "212db7c4e107464e0a3af381fc4d6c944130331d",
      "filename": "ld/emultempl/m68hc1xelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/m68hc1xelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/m68hc1xelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/m68hc1xelf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -275,7 +275,7 @@ m68hc11elf_add_stub_section (const char *stub_sec_name,\n      at the correct place.  */\n   info.input_section = tramp_section;\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n \n   if (info.add.head == NULL)\n     goto err_ret;"
    },
    {
      "sha": "41ada3fbebbb56252700551da7ceba6f543ef2e0",
      "filename": "ld/emultempl/metagelf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/metagelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/metagelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/metagelf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -169,7 +169,7 @@ metagelf_add_stub_section (const char *stub_sec_name, asection *input_section)\n \n   info.input_section = input_section;\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n \n   if (info.add.head == NULL)\n     goto err_ret;"
    },
    {
      "sha": "e27e53cf556f2b175cf5fe127609e8acb7842064",
      "filename": "ld/emultempl/mipself.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/mipself.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/mipself.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mipself.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -175,7 +175,7 @@ mips_add_stub_section (const char *stub_sec_name, asection *input_section,\n \n   /* Initialize a statement list that contains only the new statement.  */\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n   if (info.add.head == NULL)\n     goto err_ret;\n "
    },
    {
      "sha": "fa0b19ae64672618d316dbd3aa84cb8f4e0cb86f",
      "filename": "ld/emultempl/mmo.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/mmo.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/mmo.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/mmo.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -102,7 +102,7 @@ mmo_place_orphan (asection *s,\n      (regardless of whether the linker script lists it as input).  */\n   if (os != NULL)\n     {\n-      lang_add_section (&os->children, s, NULL, os);\n+      lang_add_section (&os->children, s, NULL, NULL, os);\n       return os;\n     }\n "
    },
    {
      "sha": "7e364afda818895ecc975d131ff3b567dcd57436",
      "filename": "ld/emultempl/msp430.em",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/msp430.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/msp430.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/msp430.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -325,7 +325,7 @@ gld${EMULATION_NAME}_place_orphan (asection * s,\n \n   /* Always place orphaned sections in lower.  Optimal placement of either\n      sections is performed later, once section sizes have been finalized.  */\n-  lang_add_section (& lower->children, s, NULL, lower);\n+  lang_add_section (& lower->children, s, NULL, NULL, lower);\n  end:\n   free (upper_name);\n   free (lower_name);\n@@ -358,7 +358,8 @@ change_output_section (lang_statement_union_type **head,\n \t      lang_statement_list_type *old_list\n \t\t= (lang_statement_list_type *) &old_os->children;\n \t      s->output_section = NULL;\n-\t      lang_add_section (&new_os->children, s, NULL, new_os);\n+\t      lang_add_section (&new_os->children, s,\n+\t\t\t\tcurr->input_section.pattern, NULL, new_os);\n \n \t      /* Remove the section from the old output section.  */\n \t      if (prev == NULL)"
    },
    {
      "sha": "fcc2756114005ec0e7ac24340e06d31833307b13",
      "filename": "ld/emultempl/nios2elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/nios2elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/nios2elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/nios2elf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -186,7 +186,7 @@ nios2elf_add_stub_section (const char *stub_sec_name, asection *input_section,\n \n   info.input_section = input_section;\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n \n   if (info.add.head == NULL)\n     goto err_ret;"
    },
    {
      "sha": "f9060be8c6cf760e550fcd9e7eaeb0024d512a33",
      "filename": "ld/emultempl/pe.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/pe.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/pe.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/pe.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -2085,7 +2085,7 @@ gld_${EMULATION_NAME}_place_orphan (asection *s,\n \t       If the section already exists but does not have any flags set,\n \t       then it has been created by the linker, probably as a result of\n \t       a --section-start command line switch.  */\n-\t    lang_add_section (&add_child, s, NULL, os);\n+\t    lang_add_section (&add_child, s, NULL, NULL, os);\n \t    break;\n \t  }\n \n@@ -2099,7 +2099,7 @@ gld_${EMULATION_NAME}_place_orphan (asection *s,\n      unused one and use that.  */\n   if (os == NULL && match_by_name)\n     {\n-      lang_add_section (&match_by_name->children, s, NULL, match_by_name);\n+      lang_add_section (&match_by_name->children, s, NULL, NULL, match_by_name);\n       return match_by_name;\n     }\n "
    },
    {
      "sha": "ca335b5aa6eb8d242c026b16bf3c69782d771128",
      "filename": "ld/emultempl/pep.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/pep.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/pep.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/pep.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -1905,7 +1905,7 @@ gld_${EMULATION_NAME}_place_orphan (asection *s,\n \t       If the section already exists but does not have any flags set,\n \t       then it has been created by the linker, probably as a result of\n \t       a --section-start command line switch.  */\n-\t    lang_add_section (&add_child, s, NULL, os);\n+\t    lang_add_section (&add_child, s, NULL, NULL, os);\n \t    break;\n \t  }\n \n@@ -1919,7 +1919,7 @@ gld_${EMULATION_NAME}_place_orphan (asection *s,\n      unused one and use that.  */\n   if (os == NULL && match_by_name)\n     {\n-      lang_add_section (&match_by_name->children, s, NULL, match_by_name);\n+      lang_add_section (&match_by_name->children, s, NULL, NULL, match_by_name);\n       return match_by_name;\n     }\n "
    },
    {
      "sha": "8253604539538e9dd479483189134f1c6e3f517b",
      "filename": "ld/emultempl/ppc64elf.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/ppc64elf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/ppc64elf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/ppc64elf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -445,7 +445,7 @@ ppc_add_stub_section (const char *stub_sec_name, asection *input_section)\n \n   info.input_section = input_section;\n   lang_list_init (&info.add);\n-  lang_add_section (&info.add, stub_sec, NULL, os);\n+  lang_add_section (&info.add, stub_sec, NULL, NULL, os);\n \n   if (info.add.head == NULL)\n     goto err_ret;"
    },
    {
      "sha": "0c51b8e98f8a7c82a3a29224feab12adf4df1cd0",
      "filename": "ld/emultempl/spuelf.em",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/spuelf.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/spuelf.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/spuelf.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -151,7 +151,7 @@ spu_place_special_section (asection *s, asection *o, const char *output_name)\n       lang_statement_list_type add;\n \n       lang_list_init (&add);\n-      lang_add_section (&add, s, NULL, os);\n+      lang_add_section (&add, s, NULL, NULL, os);\n       *add.tail = os->children.head;\n       os->children.head = add.head;\n     }\n@@ -168,7 +168,7 @@ spu_place_special_section (asection *s, asection *o, const char *output_name)\n \t  lang_add_assignment (exp_assign (\".\", e_size, FALSE));\n \t  pop_stat_ptr ();\n \t}\n-      lang_add_section (&os->children, s, NULL, os);\n+      lang_add_section (&os->children, s, NULL, NULL, os);\n     }\n \n   s->output_section->size += s->size;"
    },
    {
      "sha": "4c869626b9b3a7fda65c68c71225054712390c87",
      "filename": "ld/emultempl/vms.em",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/vms.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/emultempl/vms.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/vms.em?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -116,7 +116,7 @@ vms_place_orphan (asection *s,\n \n   if (hold_data.os != NULL)\n     {\n-      lang_add_section (&hold_data.os->children, s, NULL, hold_data.os);\n+      lang_add_section (&hold_data.os->children, s, NULL, NULL, hold_data.os);\n       return hold_data.os;\n     }\n   else"
    },
    {
      "sha": "9887e53c17ff5ecc865063fbd7879b7d2b512a1e",
      "filename": "ld/ldelf.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ldelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ldelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelf.c?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -2006,7 +2006,7 @@ ldelf_place_orphan (asection *s, const char *secname, int constraint)\n \t    && (elf_section_data (os->bfd_section)->this_hdr.sh_info\n \t\t== elf_section_data (s)->this_hdr.sh_info))\n \t    {\n-\t      lang_add_section (&os->children, s, NULL, os);\n+\t      lang_add_section (&os->children, s, NULL, NULL, os);\n \t      return os;\n \t    }\n \n@@ -2049,7 +2049,7 @@ ldelf_place_orphan (asection *s, const char *secname, int constraint)\n \t\t\t|| !elfoutput\n \t\t\t|| elf_orphan_compatible (s, os->bfd_section)))))\n \t  {\n-\t    lang_add_section (&os->children, s, NULL, os);\n+\t    lang_add_section (&os->children, s, NULL, NULL, os);\n \t    return os;\n \t  }\n \n@@ -2063,7 +2063,7 @@ ldelf_place_orphan (asection *s, const char *secname, int constraint)\n      unused one and use that.  */\n   if (match_by_name)\n     {\n-      lang_add_section (&match_by_name->children, s, NULL, match_by_name);\n+      lang_add_section (&match_by_name->children, s, NULL, NULL, match_by_name);\n       return match_by_name;\n     }\n \n@@ -2088,7 +2088,7 @@ ldelf_place_orphan (asection *s, const char *secname, int constraint)\n       && hold[orphan_text].os != NULL)\n     {\n       os = hold[orphan_text].os;\n-      lang_add_section (&os->children, s, NULL, os);\n+      lang_add_section (&os->children, s, NULL, NULL, os);\n       return os;\n     }\n "
    },
    {
      "sha": "8014e2229b97e78a6931a60c48264cb3fecb9f33",
      "filename": "ld/ldelfgen.c",
      "status": "modified",
      "additions": 243,
      "deletions": 0,
      "changes": 243,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ldelfgen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ldelfgen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldelfgen.c?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -27,20 +27,263 @@\n #include \"ldmisc.h\"\n #include \"ldexp.h\"\n #include \"ldlang.h\"\n+#include \"ldctor.h\"\n #include \"elf-bfd.h\"\n #include \"elf/internal.h\"\n #include \"ldelfgen.h\"\n \n+/* Info attached to an output_section_statement about input sections,\n+   used when sorting SHF_LINK_ORDER sections.  */\n+\n+struct os_sections\n+{\n+  /* Size allocated for isec.  */\n+  unsigned int alloc;\n+  /* Used entries in isec.  */\n+  unsigned int count;\n+  /* How many are SHF_LINK_ORDER.  */\n+  unsigned int ordered;\n+  /* Input sections attached to this output section.  */\n+  struct os_sections_input {\n+    lang_input_section_type *is;\n+    unsigned int idx;\n+  } isec[1];\n+};\n+\n+/* Add IS to data kept for OS.  */\n+\n+static bfd_boolean\n+add_link_order_input_section (lang_input_section_type *is,\n+\t\t\t      lang_output_section_statement_type *os)\n+{\n+  struct os_sections *os_info = os->data;\n+  asection *s;\n+\n+  if (os_info == NULL)\n+    {\n+      os_info = xmalloc (sizeof (*os_info) + 63 * sizeof (*os_info->isec));\n+      os_info->alloc = 64;\n+      os_info->count = 0;\n+      os_info->ordered = 0;\n+      os->data = os_info;\n+    }\n+  if (os_info->count == os_info->alloc)\n+    {\n+      size_t want;\n+      os_info->alloc *= 2;\n+      want = sizeof (*os_info) + (os_info->alloc - 1) * sizeof (*os_info->isec);\n+      os_info = xrealloc (os_info, want);\n+      os->data = os_info;\n+    }\n+  os_info->isec[os_info->count].is = is;\n+  os_info->isec[os_info->count].idx = os_info->count;\n+  os_info->count++;\n+  s = is->section;\n+  if ((s->flags & SEC_LINKER_CREATED) == 0\n+      && elf_section_data (s) != NULL\n+      && elf_linked_to_section (s) != NULL)\n+    os_info->ordered++;\n+  return FALSE;\n+}\n+\n+/* Run over the linker's statement list, extracting info about input\n+   sections attached to each output section.  */\n+\n+static bfd_boolean\n+link_order_scan (lang_statement_union_type *u,\n+\t\t lang_output_section_statement_type *os)\n+{\n+  asection *s;\n+  bfd_boolean ret = FALSE;\n+\n+  for (; u != NULL; u = u->header.next)\n+    {\n+      switch (u->header.type)\n+\t{\n+\tcase lang_wild_statement_enum:\n+\t  if (link_order_scan (u->wild_statement.children.head, os))\n+\t    ret = TRUE;\n+\t  break;\n+\tcase lang_constructors_statement_enum:\n+\t  if (link_order_scan (constructor_list.head, os))\n+\t    ret = TRUE;\n+\t  break;\n+\tcase lang_output_section_statement_enum:\n+\t  if (u->output_section_statement.constraint != -1\n+\t      && link_order_scan (u->output_section_statement.children.head,\n+\t\t\t\t  &u->output_section_statement))\n+\t    ret = TRUE;\n+\t  break;\n+\tcase lang_group_statement_enum:\n+\t  if (link_order_scan (u->group_statement.children.head, os))\n+\t    ret = TRUE;\n+\t  break;\n+\tcase lang_input_section_enum:\n+\t  s = u->input_section.section;\n+\t  if (s->output_section != NULL\n+\t      && s->output_section->owner == link_info.output_bfd\n+\t      && (s->output_section->flags & SEC_EXCLUDE) == 0\n+\t      && ((s->output_section->flags & SEC_HAS_CONTENTS) != 0\n+\t\t  || ((s->output_section->flags & (SEC_LOAD | SEC_THREAD_LOCAL))\n+\t\t      == (SEC_LOAD | SEC_THREAD_LOCAL))))\n+\t    if (add_link_order_input_section (&u->input_section, os))\n+\t      ret = TRUE;\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return ret;\n+}\n+\n+/* Compare two sections based on the locations of the sections they are\n+   linked to.  Used by fixup_link_order.  */\n+\n+static int\n+compare_link_order (const void *a, const void *b)\n+{\n+  const struct os_sections_input *ai = a;\n+  const struct os_sections_input *bi = b;\n+  asection *asec = elf_linked_to_section (ai->is->section);\n+  asection *bsec = elf_linked_to_section (bi->is->section);\n+  bfd_vma apos, bpos;\n+\n+  /* Place unordered sections before ordered sections.  */\n+  if (asec == NULL || bsec == NULL)\n+    {\n+      if (bsec != NULL)\n+\treturn -1;\n+      else if (asec != NULL)\n+\treturn 1;\n+      return ai->idx - bi->idx;\n+    }\n+\n+  apos = asec->output_section->lma + asec->output_offset;\n+  bpos = bsec->output_section->lma + bsec->output_offset;\n+\n+  if (apos < bpos)\n+    return -1;\n+  else if (apos > bpos)\n+    return 1;\n+\n+  /* The only way we should get matching LMAs is when the first of two\n+     sections has zero size.  */\n+  if (asec->size < bsec->size)\n+    return -1;\n+  else if (asec->size > bsec->size)\n+    return 1;\n+\n+  /* If they are both zero size then they almost certainly have the same\n+     VMA and thus are not ordered with respect to each other.  Test VMA\n+     anyway, and fall back to id to make the result reproducible across\n+     qsort implementations.  */\n+  apos = asec->output_section->vma + asec->output_offset;\n+  bpos = bsec->output_section->vma + bsec->output_offset;\n+  if (apos < bpos)\n+    return -1;\n+  else if (apos > bpos)\n+    return 1;\n+\n+  return asec->id - bsec->id;\n+}\n+\n+/* Rearrange sections with SHF_LINK_ORDER into the same order as their\n+   linked sections.  */\n+\n+static bfd_boolean\n+fixup_link_order (lang_output_section_statement_type *os)\n+{\n+  struct os_sections *os_info = os->data;\n+  unsigned int i, j;\n+  lang_input_section_type **orig_is;\n+  asection **save_s;\n+\n+  for (i = 0; i < os_info->count; i = j)\n+    {\n+      /* Normally a linker script will select SHF_LINK_ORDER sections\n+\t with an input section wildcard something like the following:\n+\t *(.IA_64.unwind* .gnu.linkonce.ia64unw.*)\n+\t However if some other random sections are smashed into an\n+\t output section, or if SHF_LINK_ORDER are split up by the\n+\t linker script, then we only want to sort sections matching a\n+\t given wildcard.  That's the purpose of the pattern test.  */\n+      for (j = i + 1; j < os_info->count; j++)\n+\tif (os_info->isec[j].is->pattern != os_info->isec[i].is->pattern)\n+\t  break;\n+      if (j - i > 1)\n+\tqsort (&os_info->isec[i], j - i, sizeof (*os_info->isec),\n+\t       compare_link_order);\n+    }\n+  for (i = 0; i < os_info->count; i++)\n+    if (os_info->isec[i].idx != i)\n+      break;\n+  if (i == os_info->count)\n+    return FALSE;\n+\n+  /* Now reorder the linker input section statements to reflect the\n+     proper sorting.  The is done by rewriting the existing statements\n+     rather than fiddling with lists, since the only thing we need to\n+     change is the bfd section pointer.  */\n+  orig_is = xmalloc (os_info->count * sizeof (*orig_is));\n+  save_s = xmalloc (os_info->count * sizeof (*save_s));\n+  for (i = 0; i < os_info->count; i++)\n+    {\n+      orig_is[os_info->isec[i].idx] = os_info->isec[i].is;\n+      save_s[i] = os_info->isec[i].is->section;\n+    }\n+  for (i = 0; i < os_info->count; i++)\n+    if (os_info->isec[i].idx != i)\n+      {\n+\torig_is[i]->section = save_s[i];\n+\t/* Restore os_info to pristine state before the qsort, for the\n+\t   next pass over sections.  */\n+\tos_info->isec[i].is = orig_is[i];\n+\tos_info->isec[i].idx = i;\n+      }\n+  free (save_s);\n+  free (orig_is);\n+  return TRUE;\n+}\n+\n void\n ldelf_map_segments (bfd_boolean need_layout)\n {\n   int tries = 10;\n+  static bfd_boolean done_link_order_scan = FALSE;\n \n   do\n     {\n       lang_relax_sections (need_layout);\n       need_layout = FALSE;\n \n+      if (link_info.output_bfd->xvec->flavour == bfd_target_elf_flavour)\n+\t{\n+\t  lang_output_section_statement_type *os;\n+\t  if (!done_link_order_scan)\n+\t    {\n+\t      link_order_scan (statement_list.head, NULL);\n+\t      done_link_order_scan = TRUE;\n+\t    }\n+\t  for (os = (void *) lang_os_list.head; os != NULL; os = os->next)\n+\t    {\n+\t      struct os_sections *os_info = os->data;\n+\t      if (os_info != NULL && os_info->ordered != 0)\n+\t\t{\n+\t\t  if (os_info->ordered != os_info->count\n+\t\t      && bfd_link_relocatable (&link_info))\n+\t\t    {\n+\t\t      einfo (_(\"%F%P: \"\n+\t\t\t       \"%pA has both ordered and unordered sections\"),\n+\t\t\t     os->bfd_section);\n+\t\t      return;\n+\t\t    }\n+\t\t  if (os_info->count > 1\n+\t\t      && fixup_link_order (os))\n+\t\t    need_layout = TRUE;\n+\t\t}\n+\t    }\n+\t}\n+\n       if (link_info.output_bfd->xvec->flavour == bfd_target_elf_flavour\n \t  && !bfd_link_relocatable (&link_info))\n \t{"
    },
    {
      "sha": "4ae9cec8853c9ce742e79b60e3a05c03af261244",
      "filename": "ld/ldlang.c",
      "status": "modified",
      "additions": 20,
      "deletions": 17,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ldlang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ldlang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.c?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -69,13 +69,6 @@ static bfd_boolean map_option_f;\n static bfd_vma print_dot;\n static lang_input_statement_type *first_file;\n static const char *current_target;\n-/* Header for list of statements corresponding to any files involved in the\n-   link, either specified from the command-line or added implicitely (eg.\n-   archive member used to resolved undefined symbol, wildcard statement from\n-   linker script, etc.).  Next pointer is in next field of a\n-   lang_statement_header_type (reached via header field in a\n-   lang_statement_union).  */\n-static lang_statement_list_type statement_list;\n static lang_statement_list_type *stat_save[10];\n static lang_statement_list_type **stat_save_ptr = &stat_save[0];\n static struct unique_sections *unique_section_list;\n@@ -103,6 +96,13 @@ static void lang_do_memory_regions (bfd_boolean);\n /* Exported variables.  */\n const char *output_target;\n lang_output_section_statement_type *abs_output_section;\n+/* Header for list of statements corresponding to any files involved in the\n+   link, either specified from the command-line or added implicitely (eg.\n+   archive member used to resolved undefined symbol, wildcard statement from\n+   linker script, etc.).  Next pointer is in next field of a\n+   lang_statement_header_type (reached via header field in a\n+   lang_statement_union).  */\n+lang_statement_list_type statement_list;\n lang_statement_list_type lang_os_list;\n lang_statement_list_type *stat_ptr = &statement_list;\n /* Header for list of statements corresponding to files used in the final\n@@ -582,6 +582,7 @@ output_section_callback_fast (lang_wild_statement_type *ptr,\n   node->left = 0;\n   node->right = 0;\n   node->section = section;\n+  node->pattern = ptr->section_list;\n \n   tree = wild_sort_fast (ptr, sec, file, section);\n   if (tree != NULL)\n@@ -598,7 +599,7 @@ output_section_callback_tree_to_list (lang_wild_statement_type *ptr,\n   if (tree->left)\n     output_section_callback_tree_to_list (ptr, tree->left, output);\n \n-  lang_add_section (&ptr->children, tree->section, NULL,\n+  lang_add_section (&ptr->children, tree->section, tree->pattern, NULL,\n \t\t    (lang_output_section_statement_type *) output);\n \n   if (tree->right)\n@@ -1896,7 +1897,7 @@ lang_insert_orphan (asection *s,\n \n   if (add_child == NULL)\n     add_child = &os->children;\n-  lang_add_section (add_child, s, NULL, os);\n+  lang_add_section (add_child, s, NULL, NULL, os);\n \n   if (after && (s->flags & (SEC_LOAD | SEC_ALLOC)) != 0)\n     {\n@@ -2537,6 +2538,7 @@ lang_discard_section_p (asection *section)\n void\n lang_add_section (lang_statement_list_type *ptr,\n \t\t  asection *section,\n+\t\t  struct wildcard_list *pattern,\n \t\t  struct flag_info *sflag_info,\n \t\t  lang_output_section_statement_type *output)\n {\n@@ -2717,6 +2719,7 @@ lang_add_section (lang_statement_list_type *ptr,\n   /* Add a section reference to the list.  */\n   new_section = new_stat (lang_input_section, ptr);\n   new_section->section = section;\n+  new_section->pattern = pattern;\n }\n \n /* Handle wildcard sorting.  This returns the lang_input_section which\n@@ -2842,14 +2845,16 @@ output_section_callback (lang_wild_statement_type *ptr,\n      of the current list.  */\n \n   if (before == NULL)\n-    lang_add_section (&ptr->children, section, ptr->section_flag_list, os);\n+    lang_add_section (&ptr->children, section, ptr->section_list,\n+\t\t      ptr->section_flag_list, os);\n   else\n     {\n       lang_statement_list_type list;\n       lang_statement_union_type **pp;\n \n       lang_list_init (&list);\n-      lang_add_section (&list, section, ptr->section_flag_list, os);\n+      lang_add_section (&list, section, ptr->section_list,\n+\t\t\tptr->section_flag_list, os);\n \n       /* If we are discarding the section, LIST.HEAD will\n \t be NULL.  */\n@@ -7204,7 +7209,7 @@ ldlang_place_orphan (asection *s)\n \t  && (bfd_link_relocatable (&link_info)\n \t      || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0))\n \tos->addr_tree = exp_intop (0);\n-      lang_add_section (&os->children, s, NULL, os);\n+      lang_add_section (&os->children, s, NULL, NULL, os);\n     }\n   else\n     {\n@@ -7227,7 +7232,7 @@ ldlang_place_orphan (asection *s)\n \t      && (bfd_link_relocatable (&link_info)\n \t\t  || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0))\n \t    os->addr_tree = exp_intop (0);\n-\t  lang_add_section (&os->children, s, NULL, os);\n+\t  lang_add_section (&os->children, s, NULL, NULL, os);\n \t}\n \n       if (config.orphan_handling == orphan_handling_warn)\n@@ -7271,7 +7276,7 @@ lang_place_orphans (void)\n \t\t\tdefault_common_section\n \t\t\t  = lang_output_section_statement_lookup (\".bss\", 0, 1);\n \t\t      lang_add_section (&default_common_section->children, s,\n-\t\t\t\t\tNULL, default_common_section);\n+\t\t\t\t\tNULL, NULL, default_common_section);\n \t\t    }\n \t\t}\n \t      else\n@@ -7485,7 +7490,7 @@ lang_reset_memory_regions (void)\n \n static void\n gc_section_callback (lang_wild_statement_type *ptr,\n-\t\t     struct wildcard_list *sec,\n+\t\t     struct wildcard_list *sec ATTRIBUTE_UNUSED,\n \t\t     asection *section,\n \t\t     lang_input_statement_type *file ATTRIBUTE_UNUSED,\n \t\t     void *data ATTRIBUTE_UNUSED)\n@@ -7494,8 +7499,6 @@ gc_section_callback (lang_wild_statement_type *ptr,\n      should be as well.  */\n   if (ptr->keep_sections)\n     section->flags |= SEC_KEEP;\n-  if (sec)\n-    section->pattern = sec->spec.name;\n }\n \n /* Iterate over sections marking them against GC.  */"
    },
    {
      "sha": "3463d4ca0cc81b7f67e9c8b9b8d62f4bca28763d",
      "filename": "ld/ldlang.h",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ldlang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/ldlang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ldlang.h?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -158,6 +158,9 @@ typedef struct lang_output_section_statement_struct\n \n   lang_output_section_phdr_list *phdrs;\n \n+  /* Used by ELF SHF_LINK_ORDER sorting.  */\n+  void *data;\n+\n   unsigned int block_value;\n   int constraint;\n   flagword flags;\n@@ -323,6 +326,7 @@ typedef struct\n {\n   lang_statement_header_type header;\n   asection *section;\n+  void *pattern;\n } lang_input_section_type;\n \n struct map_symbol_def {\n@@ -364,6 +368,7 @@ typedef bfd_boolean (*lang_match_sec_type_func) (bfd *, const asection *,\n typedef struct lang_section_bst\n {\n   asection *section;\n+  void *pattern;\n   struct lang_section_bst *left;\n   struct lang_section_bst *right;\n } lang_section_bst_type;\n@@ -506,6 +511,7 @@ extern lang_output_section_statement_type *abs_output_section;\n extern lang_statement_list_type lang_os_list;\n extern struct lang_input_statement_flags input_flags;\n extern bfd_boolean lang_has_input_file;\n+extern lang_statement_list_type statement_list;\n extern lang_statement_list_type *stat_ptr;\n extern bfd_boolean delete_output_file_on_failure;\n \n@@ -650,7 +656,7 @@ extern void lang_enter_group\n extern void lang_leave_group\n   (void);\n extern void lang_add_section\n-  (lang_statement_list_type *, asection *,\n+  (lang_statement_list_type *, asection *, struct wildcard_list *,\n    struct flag_info *, lang_output_section_statement_type *);\n extern void lang_new_phdr\n   (const char *, etree_type *, bfd_boolean, bfd_boolean, etree_type *,"
    },
    {
      "sha": "24e8e67ec36e0196ffdaba1c92aadc81ecc971c7",
      "filename": "ld/testsuite/ld-elf/pr26256-2a.d",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/testsuite/ld-elf/pr26256-2a.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/testsuite/ld-elf/pr26256-2a.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-elf/pr26256-2a.d?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -1,7 +1,6 @@\n #source: pr26256-2.s\n #ld: -e _start -T pr26256-2.t\n #nm: -n\n-#xfail: [is_generic]\n \n #...\n [0-9a-f]+ R linkorder2"
    },
    {
      "sha": "3f8c37e267b0c3f59d65823305f87929e15710e6",
      "filename": "ld/testsuite/ld-elf/pr26256-2b.d",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/testsuite/ld-elf/pr26256-2b.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/testsuite/ld-elf/pr26256-2b.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-elf/pr26256-2b.d?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -1,8 +1,7 @@\n #source: pr26256-2.s\n #ld: -e _start\n #nm: -n\n-#xfail: [is_generic]\n-#notarget: fr30-*-* iq2000-*-* ip2k-*-* xstormy16-*-*\n+#notarget: fr30-*-* iq2000-*-* ip2k-*-* xgate-*-* xstormy16-*-*\n # These targets place .linkorder sections before .text sections.\n \n #..."
    },
    {
      "sha": "8a5e6dd59eb7d084b20ead9386a75f590fc34a6d",
      "filename": "ld/testsuite/ld-elf/pr26256-3b.d",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/testsuite/ld-elf/pr26256-3b.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b209b5a6b8a4433be961a0f016439f381de65bfc/ld/testsuite/ld-elf/pr26256-3b.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-elf/pr26256-3b.d?ref=b209b5a6b8a4433be961a0f016439f381de65bfc",
      "patch": "@@ -1,7 +1,6 @@\n #source: pr26256-3.s\n #ld: -e _start -T pr26256-3b.t\n #readelf: -x .rodata -x .text\n-#xfail: [is_generic]\n \n Hex dump of section \\'.rodata\\':\n   0x[a-f0-9]+ +00020301 +040907 +.+"
    }
  ]
}