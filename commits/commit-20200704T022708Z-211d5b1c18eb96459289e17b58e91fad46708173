{
  "sha": "211d5b1c18eb96459289e17b58e91fad46708173",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjExZDViMWMxOGViOTY0NTkyODllMTdiNThlOTFmYWQ0NjcwODE3Mw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-07-03T00:38:25Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-07-04T02:27:08Z"
    },
    "message": "gdb: remove callback in macro expand functions\n\nI started to look into changing the callbacks in macroexp.h to use\ngdb::function_view.  However, I noticed that the passed lookup function\nwas always `standard_macro_lookup`, which looks up a macro in a\n`macro_scope` object.  Since that doesn't look like a very useful\nabstraction, it would be simpler to just pass the scope around and have\nthe various functions call standard_macro_lookup themselves.  This is\nwhat this patch does.\n\ngdb/ChangeLog:\n\n\t* macroexp.h (macro_lookup_ftype): Remove.\n\t(macro_expand, macro_expand_once, macro_expand_next): Remove\n\tlookup function parameters, add scope parameter.\n\t* macroexp.c (scan, substitute_args, expand, maybe_expand,\n\tmacro_expand, macro_expand_once, macro_expand_next): Likewise.\n\t* macroscope.h (standard_macro_lookup): Change parameter type\n\tto macro_scope.\n\t* macroscope.c (standard_macro_lookup): Likewise.\n\t* c-exp.y (lex_one_token): Update.\n\t* macrocmd.c (macro_expand_command): Likewise.\n\t(macro_expand_once_command): Likewise.\n\nChange-Id: Id2431b1489359e1b0274dc2b81e5ea5d225d730c",
    "tree": {
      "sha": "9167b6d775563b6970d1d0c9a5b36b4d4197de94",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9167b6d775563b6970d1d0c9a5b36b4d4197de94"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/211d5b1c18eb96459289e17b58e91fad46708173",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/211d5b1c18eb96459289e17b58e91fad46708173",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/211d5b1c18eb96459289e17b58e91fad46708173",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/211d5b1c18eb96459289e17b58e91fad46708173/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "889d527eb43c90cc37e757a3cddd0837c3fd9dd9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/889d527eb43c90cc37e757a3cddd0837c3fd9dd9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/889d527eb43c90cc37e757a3cddd0837c3fd9dd9"
    }
  ],
  "stats": {
    "total": 163,
    "additions": 72,
    "deletions": 91
  },
  "files": [
    {
      "sha": "513f1711b259d6a324595d9fd78d53cf9c3d99f8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/211d5b1c18eb96459289e17b58e91fad46708173/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/211d5b1c18eb96459289e17b58e91fad46708173/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=211d5b1c18eb96459289e17b58e91fad46708173",
      "patch": "@@ -1,3 +1,17 @@\n+2020-07-02  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* macroexp.h (macro_lookup_ftype): Remove.\n+\t(macro_expand, macro_expand_once, macro_expand_next): Remove\n+\tlookup function parameters, add scope parameter.\n+\t* macroexp.c (scan, substitute_args, expand, maybe_expand,\n+\tmacro_expand, macro_expand_once, macro_expand_next): Likewise.\n+\t* macroscope.h (standard_macro_lookup): Change parameter type\n+\tto macro_scope.\n+\t* macroscope.c (standard_macro_lookup): Likewise.\n+\t* c-exp.y (lex_one_token): Update.\n+\t* macrocmd.c (macro_expand_command): Likewise.\n+\t(macro_expand_once_command): Likewise.\n+\n 2020-07-02  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* inf-loop.c (inferior_event_handler): Remove client_data param."
    },
    {
      "sha": "61fa2fe684db009c2fe1dd5a6c19d03d05bb6328",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/211d5b1c18eb96459289e17b58e91fad46708173/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/211d5b1c18eb96459289e17b58e91fad46708173/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=211d5b1c18eb96459289e17b58e91fad46708173",
      "patch": "@@ -2632,8 +2632,7 @@ lex_one_token (struct parser_state *par_state, bool *is_quoted_name)\n   if (! scanning_macro_expansion ())\n     {\n       char *expanded = macro_expand_next (&pstate->lexptr,\n-                                          standard_macro_lookup,\n-                                          expression_macro_scope);\n+\t\t\t\t\t  *expression_macro_scope);\n \n       if (expanded)\n         scan_macro_expansion (expanded);"
    },
    {
      "sha": "3e900fefaf5028d9e343fd03c6da4c419deed24d",
      "filename": "gdb/macrocmd.c",
      "status": "modified",
      "additions": 10,
      "deletions": 12,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macrocmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macrocmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macrocmd.c?ref=211d5b1c18eb96459289e17b58e91fad46708173",
      "patch": "@@ -47,9 +47,6 @@ macro_inform_no_debuginfo (void)\n static void\n macro_expand_command (const char *exp, int from_tty)\n {\n-  gdb::unique_xmalloc_ptr<struct macro_scope> ms;\n-  gdb::unique_xmalloc_ptr<char> expanded;\n-\n   /* You know, when the user doesn't specify any expression, it would be\n      really cool if this defaulted to the last expression evaluated.\n      Then it would be easy to ask, \"Hey, what did I just evaluate?\"  But\n@@ -60,10 +57,12 @@ macro_expand_command (const char *exp, int from_tty)\n            \" expression you\\n\"\n            \"want to expand.\"));\n \n-  ms = default_macro_scope ();\n-  if (ms)\n+  gdb::unique_xmalloc_ptr<macro_scope> ms = default_macro_scope ();\n+\n+  if (ms != nullptr)\n     {\n-      expanded = macro_expand (exp, standard_macro_lookup, ms.get ());\n+      gdb::unique_xmalloc_ptr<char> expanded = macro_expand (exp, *ms);\n+\n       fputs_filtered (\"expands to: \", gdb_stdout);\n       fputs_filtered (expanded.get (), gdb_stdout);\n       fputs_filtered (\"\\n\", gdb_stdout);\n@@ -76,9 +75,6 @@ macro_expand_command (const char *exp, int from_tty)\n static void\n macro_expand_once_command (const char *exp, int from_tty)\n {\n-  gdb::unique_xmalloc_ptr<struct macro_scope> ms;\n-  gdb::unique_xmalloc_ptr<char> expanded;\n-\n   /* You know, when the user doesn't specify any expression, it would be\n      really cool if this defaulted to the last expression evaluated.\n      And it should set the once-expanded text as the new `last\n@@ -89,10 +85,12 @@ macro_expand_once_command (const char *exp, int from_tty)\n            \" the expression\\n\"\n            \"you want to expand.\"));\n \n-  ms = default_macro_scope ();\n-  if (ms)\n+  gdb::unique_xmalloc_ptr<macro_scope> ms = default_macro_scope ();\n+\n+  if (ms != nullptr)\n     {\n-      expanded = macro_expand_once (exp, standard_macro_lookup, ms.get ());\n+      gdb::unique_xmalloc_ptr<char> expanded = macro_expand_once (exp, *ms);\n+\n       fputs_filtered (\"expands to: \", gdb_stdout);\n       fputs_filtered (expanded.get (), gdb_stdout);\n       fputs_filtered (\"\\n\", gdb_stdout);"
    },
    {
      "sha": "92823807f153450d23dfef46ba0777e93cb53f1b",
      "filename": "gdb/macroexp.c",
      "status": "modified",
      "additions": 18,
      "deletions": 31,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macroexp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macroexp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macroexp.c?ref=211d5b1c18eb96459289e17b58e91fad46708173",
      "patch": "@@ -21,6 +21,7 @@\n #include \"gdb_obstack.h\"\n #include \"macrotab.h\"\n #include \"macroexp.h\"\n+#include \"macroscope.h\"\n #include \"c-lang.h\"\n \n \n@@ -877,9 +878,7 @@ gather_arguments (const char *name, struct macro_buffer *src, int nargs,\n static void scan (struct macro_buffer *dest,\n                   struct macro_buffer *src,\n                   struct macro_name_list *no_loop,\n-                  macro_lookup_ftype *lookup_func,\n-                  void *lookup_baton);\n-\n+\t\t  const macro_scope &scope);\n \n /* A helper function for substitute_args.\n    \n@@ -959,8 +958,7 @@ substitute_args (struct macro_buffer *dest,\n \t\t int is_varargs, const struct macro_buffer *va_arg_name,\n \t\t const std::vector<struct macro_buffer> &argv,\n                  struct macro_name_list *no_loop,\n-                 macro_lookup_ftype *lookup_func,\n-                 void *lookup_baton)\n+\t\t const macro_scope &scope)\n {\n   /* The token we are currently considering.  */\n   struct macro_buffer tok;\n@@ -1194,7 +1192,7 @@ substitute_args (struct macro_buffer *dest,\n \t\t referring to the argument's text, not the argument\n \t\t itself.  */\n \t      struct macro_buffer arg_src (argv[arg].text, argv[arg].len);\n-\t      scan (dest, &arg_src, no_loop, lookup_func, lookup_baton);\n+\t      scan (dest, &arg_src, no_loop, scope);\n \t      substituted = 1;\n \t    }\n \n@@ -1224,8 +1222,7 @@ expand (const char *id,\n         struct macro_buffer *dest,\n         struct macro_buffer *src,\n         struct macro_name_list *no_loop,\n-        macro_lookup_ftype *lookup_func,\n-        void *lookup_baton)\n+\tconst macro_scope &scope)\n {\n   struct macro_name_list new_no_loop;\n \n@@ -1243,7 +1240,7 @@ expand (const char *id,\n       struct macro_buffer replacement_list (def->replacement,\n \t\t\t\t\t    strlen (def->replacement));\n \n-      scan (dest, &replacement_list, &new_no_loop, lookup_func, lookup_baton);\n+      scan (dest, &replacement_list, &new_no_loop, scope);\n       return 1;\n     }\n   else if (def->kind == macro_function_like)\n@@ -1310,7 +1307,7 @@ expand (const char *id,\n          expand an argument until we see how it's being used.  */\n       struct macro_buffer substituted (0);\n       substitute_args (&substituted, def, is_varargs, &va_arg_name,\n-\t\t       argv, no_loop, lookup_func, lookup_baton);\n+\t\t       argv, no_loop, scope);\n \n       /* Now `substituted' is the macro's replacement list, with all\n          argument values substituted into it properly.  Re-scan it for\n@@ -1323,7 +1320,7 @@ expand (const char *id,\n          `substituted's original text buffer after scanning it so we\n          can free it.  */\n       struct macro_buffer substituted_src (substituted.text, substituted.len);\n-      scan (dest, &substituted_src, &new_no_loop, lookup_func, lookup_baton);\n+      scan (dest, &substituted_src, &new_no_loop, scope);\n \n       return 1;\n     }\n@@ -1344,8 +1341,7 @@ maybe_expand (struct macro_buffer *dest,\n               struct macro_buffer *src_first,\n               struct macro_buffer *src_rest,\n               struct macro_name_list *no_loop,\n-              macro_lookup_ftype *lookup_func,\n-              void *lookup_baton)\n+\t      const macro_scope &scope)\n {\n   gdb_assert (src_first->shared);\n   gdb_assert (src_rest->shared);\n@@ -1363,11 +1359,9 @@ maybe_expand (struct macro_buffer *dest,\n       if (! currently_rescanning (no_loop, id.c_str ()))\n         {\n           /* Does this identifier have a macro definition in scope?  */\n-          struct macro_definition *def = lookup_func (id.c_str (),\n-\t\t\t\t\t\t      lookup_baton);\n+          macro_definition *def = standard_macro_lookup (id.c_str (), scope);\n \n-          if (def && expand (id.c_str (), def, dest, src_rest, no_loop,\n-                             lookup_func, lookup_baton))\n+          if (def && expand (id.c_str (), def, dest, src_rest, no_loop, scope))\n \t    return 1;\n         }\n     }\n@@ -1385,8 +1379,7 @@ static void\n scan (struct macro_buffer *dest,\n       struct macro_buffer *src,\n       struct macro_name_list *no_loop,\n-      macro_lookup_ftype *lookup_func,\n-      void *lookup_baton)\n+      const macro_scope &scope)\n {\n   gdb_assert (src->shared);\n   gdb_assert (! dest->shared);\n@@ -1408,7 +1401,7 @@ scan (struct macro_buffer *dest,\n           dest->last_token = dest->len;\n         }\n \n-      if (! maybe_expand (dest, &tok, src, no_loop, lookup_func, lookup_baton))\n+      if (! maybe_expand (dest, &tok, src, no_loop, scope))\n         /* We didn't end up expanding tok as a macro reference, so\n            simply append it to dest.  */\n         append_tokens_without_splicing (dest, &tok);\n@@ -1425,16 +1418,14 @@ scan (struct macro_buffer *dest,\n \n \n gdb::unique_xmalloc_ptr<char>\n-macro_expand (const char *source,\n-              macro_lookup_ftype *lookup_func,\n-              void *lookup_func_baton)\n+macro_expand (const char *source, const macro_scope &scope)\n {\n   struct macro_buffer src (source, strlen (source));\n \n   struct macro_buffer dest (0);\n   dest.last_token = 0;\n \n-  scan (&dest, &src, 0, lookup_func, lookup_func_baton);\n+  scan (&dest, &src, 0, scope);\n \n   dest.appendc ('\\0');\n \n@@ -1443,18 +1434,14 @@ macro_expand (const char *source,\n \n \n gdb::unique_xmalloc_ptr<char>\n-macro_expand_once (const char *source,\n-                   macro_lookup_ftype *lookup_func,\n-                   void *lookup_func_baton)\n+macro_expand_once (const char *source, const macro_scope &scope)\n {\n   error (_(\"Expand-once not implemented yet.\"));\n }\n \n \n char *\n-macro_expand_next (const char **lexptr,\n-                   macro_lookup_ftype *lookup_func,\n-                   void *lookup_baton)\n+macro_expand_next (const char **lexptr, const macro_scope &scope)\n {\n   struct macro_buffer tok;\n \n@@ -1470,7 +1457,7 @@ macro_expand_next (const char **lexptr,\n     return 0;\n \n   /* If it's a macro invocation, expand it.  */\n-  if (maybe_expand (&dest, &tok, &src, 0, lookup_func, lookup_baton))\n+  if (maybe_expand (&dest, &tok, &src, 0, scope))\n     {\n       /* It was a macro invocation!  Package up the expansion as a\n          null-terminated string and return it.  Set *lexptr to the"
    },
    {
      "sha": "ec992f22796ddaccb727d2ebbc5cc06ca040047b",
      "filename": "gdb/macroexp.h",
      "status": "modified",
      "additions": 19,
      "deletions": 33,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macroexp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macroexp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macroexp.h?ref=211d5b1c18eb96459289e17b58e91fad46708173",
      "patch": "@@ -21,38 +21,26 @@\n #ifndef MACROEXP_H\n #define MACROEXP_H\n \n-/* A function for looking up preprocessor macro definitions.  Return\n-   the preprocessor definition of NAME in scope according to BATON, or\n-   zero if NAME is not defined as a preprocessor macro.\n-\n-   The caller must not free or modify the definition returned.  It is\n-   probably unwise for the caller to hold pointers to it for very\n-   long; it probably lives in some objfile's obstacks.  */\n-typedef struct macro_definition *(macro_lookup_ftype) (const char *name,\n-                                                       void *baton);\n-\n-\n-/* Expand any preprocessor macros in SOURCE, and return the expanded\n-   text.  Use LOOKUP_FUNC and LOOKUP_FUNC_BATON to find identifiers'\n-   preprocessor definitions.  SOURCE is a null-terminated string.  The\n-   result is a null-terminated string, allocated using xmalloc; it is\n-   the caller's responsibility to free it.  */\n+struct macro_scope;\n+\n+/* Expand any preprocessor macros in SOURCE (a null-terminated string), and\n+   return the expanded text.\n+\n+   Use SCOPE to find identifiers' preprocessor definitions.\n+\n+   The result is a null-terminated string.  */\n gdb::unique_xmalloc_ptr<char> macro_expand (const char *source,\n-\t\t\t\t\t    macro_lookup_ftype *lookup_func,\n-\t\t\t\t\t    void *lookup_func_baton);\n+\t\t\t\t\t    const macro_scope &scope);\n \n+/* Expand all preprocessor macro references that appear explicitly in SOURCE\n+   (a null-terminated string), but do not expand any new macro references\n+   introduced by that first level of expansion.\n \n-/* Expand all preprocessor macro references that appear explicitly in\n-   SOURCE, but do not expand any new macro references introduced by\n-   that first level of expansion.  Use LOOKUP_FUNC and\n-   LOOKUP_FUNC_BATON to find identifiers' preprocessor definitions.\n-   SOURCE is a null-terminated string.  The result is a\n-   null-terminated string, allocated using xmalloc; it is the caller's\n-   responsibility to free it.  */\n-gdb::unique_xmalloc_ptr<char> macro_expand_once (const char *source,\n-\t\t\t\t\t\t macro_lookup_ftype *lookup_func,\n-\t\t\t\t\t\t void *lookup_func_baton);\n+   Use SCOPE to find identifiers' preprocessor definitions.\n \n+   The result is a null-terminated string.  */\n+gdb::unique_xmalloc_ptr<char> macro_expand_once (const char *source,\n+\t\t\t\t\t\t const macro_scope &scope);\n \n /* If the null-terminated string pointed to by *LEXPTR begins with a\n    macro invocation, return the result of expanding that invocation as\n@@ -61,9 +49,9 @@ gdb::unique_xmalloc_ptr<char> macro_expand_once (const char *source,\n    contains no further macro invocations.\n \n    Otherwise, if *LEXPTR does not start with a macro invocation,\n-   return zero, and leave *LEXPTR unchanged.\n+   return nullptr, and leave *LEXPTR unchanged.\n \n-   Use LOOKUP_FUNC and LOOKUP_BATON to find macro definitions.\n+   Use SCOPE to find macro definitions.\n \n    If this function returns a string, the caller is responsible for\n    freeing it, using xfree.\n@@ -80,9 +68,7 @@ gdb::unique_xmalloc_ptr<char> macro_expand_once (const char *source,\n    much have to do tokenization to find the end of the string that\n    needs to be macro-expanded.  Our C/C++ tokenizer isn't really\n    designed to be called by anything but the yacc parser engine.  */\n-char *macro_expand_next (const char **lexptr,\n-                         macro_lookup_ftype *lookup_func,\n-                         void *lookup_baton);\n+char *macro_expand_next (const char **lexptr, const macro_scope &scope);\n \n /* Functions to classify characters according to cpp rules.  */\n "
    },
    {
      "sha": "3b02c97528e1b2fa173d813c768cdbc2f2cdd6a3",
      "filename": "gdb/macroscope.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macroscope.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macroscope.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macroscope.c?ref=211d5b1c18eb96459289e17b58e91fad46708173",
      "patch": "@@ -140,15 +140,15 @@ default_macro_scope (void)\n    location given by BATON, which must be a pointer to a `struct\n    macro_scope' structure.  */\n struct macro_definition *\n-standard_macro_lookup (const char *name, void *baton)\n+standard_macro_lookup (const char *name, const macro_scope &ms)\n {\n-  struct macro_scope *ms = (struct macro_scope *) baton;\n-  struct macro_definition *result;\n-\n   /* Give user-defined macros priority over all others.  */\n-  result = macro_lookup_definition (macro_main (macro_user_macros), -1, name);\n-  if (! result)\n-    result = macro_lookup_definition (ms->file, ms->line, name);\n+  macro_definition *result\n+    = macro_lookup_definition (macro_main (macro_user_macros), -1, name);\n+\n+  if (result == nullptr)\n+    result = macro_lookup_definition (ms.file, ms.line, name);\n+\n   return result;\n }\n "
    },
    {
      "sha": "6ff3579d6b10848cc233246d1f5c09e86e3e0c49",
      "filename": "gdb/macroscope.h",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macroscope.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/211d5b1c18eb96459289e17b58e91fad46708173/gdb/macroscope.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/macroscope.h?ref=211d5b1c18eb96459289e17b58e91fad46708173",
      "patch": "@@ -56,12 +56,9 @@ gdb::unique_xmalloc_ptr<struct macro_scope> user_macro_scope (void);\n    the user macro scope.  */\n gdb::unique_xmalloc_ptr<struct macro_scope> default_macro_scope (void);\n \n-\n /* Look up the definition of the macro named NAME in scope at the source\n-   location given by BATON, which must be a pointer to a `struct\n-   macro_scope' structure.  This function is suitable for use as\n-   a macro_lookup_ftype function.  */\n-struct macro_definition *standard_macro_lookup (const char *name, void *baton);\n-\n+   location given by MS.  */\n+macro_definition *standard_macro_lookup (const char *name,\n+\t\t\t\t\t const macro_scope &ms);\n \n #endif /* MACROSCOPE_H */"
    }
  ]
}