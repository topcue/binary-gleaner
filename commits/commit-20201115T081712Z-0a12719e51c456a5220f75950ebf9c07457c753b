{
  "sha": "0a12719e51c456a5220f75950ebf9c07457c753b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGExMjcxOWU1MWM0NTZhNTIyMGY3NTk1MGViZjljMDc0NTdjNzUzYg==",
  "commit": {
    "author": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2020-11-15T08:17:12Z"
    },
    "committer": {
      "name": "Joel Brobecker",
      "email": "brobecker@adacore.com",
      "date": "2020-11-15T08:17:12Z"
    },
    "message": "Add support for fixed-point type arithmetic\n\nThis patch adds support for binary operations on fixed-point values,\nas well as for the negative unary operator.\n\ngdb/ChangeLog:\n\n        * eval.c (binop_promote): Add fixed-point type handling.\n        * valarith.c (fixed_point_binop): New function.\n        (scalar_binop): Add fixed-point type handling.\n        (value_neg): Add fixed-point type handling.\n        * valops.c (value_cast_to_fixed_point): New function.\n        (value_cast): Add fixed-point type handling.\n\ngdb/testsuite/ChangeLog:\n\n        * gdb.dwarf2/dw2-fixed-point.exp: Add arithmetic tests.",
    "tree": {
      "sha": "0774c19e0d70680f30b9453efdd28b2cc3614c31",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0774c19e0d70680f30b9453efdd28b2cc3614c31"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0a12719e51c456a5220f75950ebf9c07457c753b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0a12719e51c456a5220f75950ebf9c07457c753b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0a12719e51c456a5220f75950ebf9c07457c753b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0a12719e51c456a5220f75950ebf9c07457c753b/comments",
  "author": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "brobecke",
    "id": 11981700,
    "node_id": "MDQ6VXNlcjExOTgxNzAw",
    "avatar_url": "https://avatars.githubusercontent.com/u/11981700?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/brobecke",
    "html_url": "https://github.com/brobecke",
    "followers_url": "https://api.github.com/users/brobecke/followers",
    "following_url": "https://api.github.com/users/brobecke/following{/other_user}",
    "gists_url": "https://api.github.com/users/brobecke/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/brobecke/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/brobecke/subscriptions",
    "organizations_url": "https://api.github.com/users/brobecke/orgs",
    "repos_url": "https://api.github.com/users/brobecke/repos",
    "events_url": "https://api.github.com/users/brobecke/events{/privacy}",
    "received_events_url": "https://api.github.com/users/brobecke/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0c9150e4de689066b6d7faf326535f573bd29f07",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0c9150e4de689066b6d7faf326535f573bd29f07",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0c9150e4de689066b6d7faf326535f573bd29f07"
    }
  ],
  "stats": {
    "total": 199,
    "additions": 196,
    "deletions": 3
  },
  "files": [
    {
      "sha": "e9f0afd9192bd16b865dbcd815ab65bcb142bdd2",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=0a12719e51c456a5220f75950ebf9c07457c753b",
      "patch": "@@ -1,3 +1,12 @@\n+2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n+\n+\t* eval.c (binop_promote): Add fixed-point type handling.\n+\t* valarith.c (fixed_point_binop): New function.\n+\t(scalar_binop): Add fixed-point type handling.\n+\t(value_neg): Add fixed-point type handling.\n+\t* valops.c (value_cast_to_fixed_point): New function.\n+\t(value_cast): Add fixed-point type handling.\n+\n 2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n \n \t* ada-typeprint.c (ada_print_type): Add handing of fixed-point"
    },
    {
      "sha": "308f47714822220437b363cc896c107576ed4f8b",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=0a12719e51c456a5220f75950ebf9c07457c753b",
      "patch": "@@ -430,6 +430,9 @@ binop_promote (const struct language_defn *language, struct gdbarch *gdbarch,\n \t  && !is_integral_type (type2)))\n     return;\n \n+  if (is_fixed_point_type (type1) || is_fixed_point_type (type2))\n+        return;\n+\n   if (type1->code () == TYPE_CODE_DECFLOAT\n       || type2->code () == TYPE_CODE_DECFLOAT)\n     {"
    },
    {
      "sha": "3c53f6c666a406c8c0543f9dd5ce9ae48ded62b8",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=0a12719e51c456a5220f75950ebf9c07457c753b",
      "patch": "@@ -1,3 +1,7 @@\n+2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n+\n+\t* gdb.dwarf2/dw2-fixed-point.exp: Add arithmetic tests.\n+\n 2020-11-15  Joel Brobecker  <brobecker@adacore.com>\n \n \t* gdb.ada/fixed_points.exp: Add ptype tests."
    },
    {
      "sha": "0252195e1d4806a63bc70f5b09f924c45baab023",
      "filename": "gdb/testsuite/gdb.dwarf2/dw2-fixed-point.exp",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/dw2-fixed-point.exp?ref=0a12719e51c456a5220f75950ebf9c07457c753b",
      "patch": "@@ -143,6 +143,24 @@ gdb_test \"print pck.fp1_range_var\" \\\n gdb_test \"print /x pck.fp1_range_var\" \\\n          \" = 0x1\"\n \n+gdb_test \"print pck.fp1_var + 0.25\" \\\n+         \" = 0.5\"\n+\n+gdb_test \"print pck.fp2_var - pck.fp2_var\" \\\n+         \" = 0\"\n+\n+gdb_test \"print pck.fp3_var * 1\" \\\n+         \" = 0.1\"\n+\n+gdb_test \"print pck.fp3_var / pck.fp3_var\" \\\n+         \" = 1\"\n+\n+gdb_test \"print pck.fp1_range_var - 0.5\" \\\n+         \" = 0.5\"\n+\n+gdb_test \"print -pck.fp1_var\" \\\n+         \" = -0.25\"\n+\n # Set the language to LANG and do a ptype test on pck__fp1_var,\n # pck__fp2_var and pck__fp3_var, verifying that the output matches\n # FP1_RE, FP2_RE, FP2_RE (resp.)."
    },
    {
      "sha": "65a6f13db5e18718ae8b68a404b0622321a4cb6a",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 89,
      "deletions": 2,
      "changes": 91,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=0a12719e51c456a5220f75950ebf9c07457c753b",
      "patch": "@@ -881,6 +881,84 @@ value_args_as_target_float (struct value *arg1, struct value *arg2,\n \t     type2->name ());\n }\n \n+/* Assuming at last one of ARG1 or ARG2 is a fixed point value,\n+   perform the binary operation OP on these two operands, and return\n+   the resulting value (also as a fixed point).  */\n+\n+static struct value *\n+fixed_point_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n+{\n+  struct type *type1 = check_typedef (value_type (arg1));\n+  struct type *type2 = check_typedef (value_type (arg2));\n+\n+  struct value *val;\n+\n+  gdb_assert (is_fixed_point_type (type1) || is_fixed_point_type (type2));\n+  if (!is_fixed_point_type (type1))\n+    {\n+      arg1 = value_cast (type2, arg1);\n+      type1 = type2;\n+    }\n+  if (!is_fixed_point_type (type2))\n+    {\n+      arg2 = value_cast (type1, arg2);\n+      type2 = type1;\n+    }\n+\n+  gdb_mpq v1, v2, res;\n+  v1.read_fixed_point (value_contents (arg1), TYPE_LENGTH (type1),\n+\t\t       type_byte_order (type1), type1->is_unsigned (),\n+\t\t       fixed_point_scaling_factor (type1));\n+  v2.read_fixed_point (value_contents (arg2), TYPE_LENGTH (type2),\n+\t\t       type_byte_order (type2), type2->is_unsigned (),\n+\t\t       fixed_point_scaling_factor (type2));\n+\n+#define INIT_VAL_WITH_FIXED_POINT_VAL(RESULT) \\\n+  do { \\\n+      val = allocate_value (type1); \\\n+      (RESULT).write_fixed_point\t\t\t\\\n+        (value_contents_raw (val), TYPE_LENGTH (type1), \\\n+\t type_byte_order (type1), type1->is_unsigned (), \\\n+\t fixed_point_scaling_factor (type1)); \\\n+     } while (0)\n+\n+  switch (op)\n+    {\n+    case BINOP_ADD:\n+      mpq_add (res.val, v1.val, v2.val);\n+      INIT_VAL_WITH_FIXED_POINT_VAL (res);\n+      break;\n+\n+    case BINOP_SUB:\n+      mpq_sub (res.val, v1.val, v2.val);\n+      INIT_VAL_WITH_FIXED_POINT_VAL (res);\n+      break;\n+\n+    case BINOP_MIN:\n+      INIT_VAL_WITH_FIXED_POINT_VAL (mpq_cmp (v1.val, v2.val) < 0 ? v1 : v2);\n+      break;\n+\n+    case BINOP_MAX:\n+      INIT_VAL_WITH_FIXED_POINT_VAL (mpq_cmp (v1.val, v2.val) > 0 ? v1 : v2);\n+      break;\n+\n+    case BINOP_MUL:\n+      mpq_mul (res.val, v1.val, v2.val);\n+      INIT_VAL_WITH_FIXED_POINT_VAL (res);\n+      break;\n+\n+    case BINOP_DIV:\n+      mpq_div (res.val, v1.val, v2.val);\n+      INIT_VAL_WITH_FIXED_POINT_VAL (res);\n+      break;\n+\n+    default:\n+      error (_(\"Integer-only operation on fixed point number.\"));\n+    }\n+\n+  return val;\n+}\n+\n /* A helper function that finds the type to use for a binary operation\n    involving TYPE1 and TYPE2.  */\n \n@@ -1054,10 +1132,17 @@ scalar_binop (struct value *arg1, struct value *arg2, enum exp_opcode op)\n       || type2->code () == TYPE_CODE_COMPLEX)\n     return complex_binop (arg1, arg2, op);\n \n-  if ((!is_floating_value (arg1) && !is_integral_type (type1))\n-      || (!is_floating_value (arg2) && !is_integral_type (type2)))\n+  if ((!is_floating_value (arg1)\n+       && !is_integral_type (type1)\n+       && !is_fixed_point_type (type1))\n+      || (!is_floating_value (arg2)\n+\t  && !is_integral_type (type2)\n+\t  && !is_fixed_point_type (type2)))\n     error (_(\"Argument to arithmetic operation not a number or boolean.\"));\n \n+  if (is_fixed_point_type (type1) || is_fixed_point_type (type2))\n+    return fixed_point_binop (arg1, arg2, op);\n+\n   if (is_floating_type (type1) || is_floating_type (type2))\n     {\n       result_type = promotion_type (type1, type2);\n@@ -1753,6 +1838,8 @@ value_neg (struct value *arg1)\n \n   if (is_integral_type (type) || is_floating_type (type))\n     return value_binop (value_from_longest (type, 0), arg1, BINOP_SUB);\n+  else if (is_fixed_point_type (type))\n+    return value_binop (value_zero (type, not_lval), arg1, BINOP_SUB);\n   else if (type->code () == TYPE_CODE_ARRAY && type->is_vector ())\n     {\n       struct value *tmp, *val = allocate_value (type);"
    },
    {
      "sha": "0f84a70ceb6e6cc66592f36ad3c6b2f7ad6b7429",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 73,
      "deletions": 1,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a12719e51c456a5220f75950ebf9c07457c753b/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=0a12719e51c456a5220f75950ebf9c07457c753b",
      "patch": "@@ -331,6 +331,60 @@ value_cast_pointers (struct type *type, struct value *arg2,\n   return arg2;\n }\n \n+/* Assuming that TO_TYPE is a fixed point type, return a value\n+   corresponding to the cast of FROM_VAL to that type.  */\n+\n+static struct value *\n+value_cast_to_fixed_point (struct type *to_type, struct value *from_val)\n+{\n+  struct type *from_type = value_type (from_val);\n+\n+  if (from_type == to_type)\n+    return from_val;\n+\n+  gdb_mpq vq;\n+\n+  /* Extract the value as a rational number.  */\n+\n+  if (is_floating_type (from_type))\n+    {\n+      double d = target_float_to_host_double (value_contents (from_val),\n+\t\t\t\t\t      from_type);\n+      mpq_set_d (vq.val, d);\n+    }\n+\n+  else if (is_integral_type (from_type) || is_fixed_point_type (from_type))\n+    {\n+      gdb_mpz vz;\n+\n+      vz.read (value_contents (from_val), TYPE_LENGTH (from_type),\n+\t       type_byte_order (from_type), from_type->is_unsigned ());\n+      mpq_set_z (vq.val, vz.val);\n+\n+      if (is_fixed_point_type (from_type))\n+\tmpq_mul (vq.val, vq.val, fixed_point_scaling_factor (from_type).val);\n+    }\n+\n+  else\n+    error (_(\"Invalid conversion from type %s to fixed point type %s\"),\n+\t   from_type->name (), to_type->name ());\n+\n+  /* Divide that value by the scaling factor to obtain the unscaled\n+     value, first in rational form, and then in integer form.  */\n+\n+  mpq_div (vq.val, vq.val, fixed_point_scaling_factor (to_type).val);\n+  gdb_mpz unscaled = vq.get_rounded ();\n+\n+  /* Finally, create the result value, and pack the unscaled value\n+     in it.  */\n+  struct value *result = allocate_value (to_type);\n+  unscaled.write (value_contents_raw (result),\n+\t\t  TYPE_LENGTH (to_type), type_byte_order (to_type),\n+\t\t  to_type->is_unsigned ());\n+\n+  return result;\n+}\n+\n /* Cast value ARG2 to type TYPE and return as a value.\n    More general than a C cast: accepts any two types of the same length,\n    and if ARG2 is an lvalue it can be cast into anything at all.  */\n@@ -349,6 +403,9 @@ value_cast (struct type *type, struct value *arg2)\n   if (value_type (arg2) == type)\n     return arg2;\n \n+  if (is_fixed_point_type (type))\n+    return value_cast_to_fixed_point (type, arg2);\n+\n   /* Check if we are casting struct reference to struct reference.  */\n   if (TYPE_IS_REFERENCE (check_typedef (type)))\n     {\n@@ -439,7 +496,8 @@ value_cast (struct type *type, struct value *arg2)\n \n   scalar = (code2 == TYPE_CODE_INT || code2 == TYPE_CODE_FLT\n \t    || code2 == TYPE_CODE_DECFLOAT || code2 == TYPE_CODE_ENUM\n-\t    || code2 == TYPE_CODE_RANGE);\n+\t    || code2 == TYPE_CODE_RANGE\n+\t    || is_fixed_point_type (type2));\n \n   if ((code1 == TYPE_CODE_STRUCT || code1 == TYPE_CODE_UNION)\n       && (code2 == TYPE_CODE_STRUCT || code2 == TYPE_CODE_UNION)\n@@ -460,6 +518,20 @@ value_cast (struct type *type, struct value *arg2)\n \t\t\t\tvalue_contents_raw (v), type);\n \t  return v;\n \t}\n+      else if (is_fixed_point_type (type2))\n+\t{\n+\t  gdb_mpq fp_val;\n+\n+\t  fp_val.read_fixed_point\n+\t    (value_contents (arg2), TYPE_LENGTH (type2),\n+\t     type_byte_order (type2), type2->is_unsigned (),\n+\t     fixed_point_scaling_factor (type2));\n+\n+\t  struct value *v = allocate_value (to_type);\n+\t  target_float_from_host_double (value_contents_raw (v),\n+\t\t\t\t\t to_type, mpq_get_d (fp_val.val));\n+\t  return v;\n+\t}\n \n       /* The only option left is an integral type.  */\n       if (type2->is_unsigned ())"
    }
  ]
}