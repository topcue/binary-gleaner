{
  "sha": "9938d15a01031e0aded4159adaa77d5b2b2319f6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTkzOGQxNWEwMTAzMWUwYWRlZDQxNTlhZGFhNzdkNWIyYjIzMTlmNg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-06T16:26:39Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-06T16:26:40Z"
    },
    "message": "Move dwarf2_get_dwz_file to dwarf2/dwz.h\n\nThis moves dwarf2_get_dwz_file and some helper code to dwarf2/dwz.h.\nThe main benefit of this is just shrinking dwarf2/read.c a little bit.\n\ngdb/ChangeLog\n2021-03-06  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/sect-names.h (dwarf2_elf_names): Declare.\n\t* dwarf2/read.h (dwarf2_get_dwz_file): Move to dwz.h.\n\t* dwarf2/read.c (dwarf2_elf_names): No longer static.\n\t(locate_dwz_sections, dwz_search_other_debugdirs)\n\t(dwarf2_get_dwz_file): Move to dwz.c.\n\t* dwarf2/dwz.h (dwarf2_get_dwz_file): Move declaration from\n\tread.h.\n\t* dwarf2/dwz.c (locate_dwz_sections, dwz_search_other_debugdirs)\n\t(dwarf2_get_dwz_file): Move from read.c.",
    "tree": {
      "sha": "645f40859ccd77edd69dd75aaab6ad02b0d82729",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/645f40859ccd77edd69dd75aaab6ad02b0d82729"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9938d15a01031e0aded4159adaa77d5b2b2319f6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9938d15a01031e0aded4159adaa77d5b2b2319f6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9938d15a01031e0aded4159adaa77d5b2b2319f6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9938d15a01031e0aded4159adaa77d5b2b2319f6/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1803565556f36692a0d49e3c1aeae1595a64709d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1803565556f36692a0d49e3c1aeae1595a64709d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1803565556f36692a0d49e3c1aeae1595a64709d"
    }
  ],
  "stats": {
    "total": 511,
    "additions": 269,
    "deletions": 242
  },
  "files": [
    {
      "sha": "a3762b353f7f2e4a4b2c0cac2d4c0a0923e1098e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9938d15a01031e0aded4159adaa77d5b2b2319f6",
      "patch": "@@ -1,3 +1,15 @@\n+2021-03-06  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/sect-names.h (dwarf2_elf_names): Declare.\n+\t* dwarf2/read.h (dwarf2_get_dwz_file): Move to dwz.h.\n+\t* dwarf2/read.c (dwarf2_elf_names): No longer static.\n+\t(locate_dwz_sections, dwz_search_other_debugdirs)\n+\t(dwarf2_get_dwz_file): Move to dwz.c.\n+\t* dwarf2/dwz.h (dwarf2_get_dwz_file): Move declaration from\n+\tread.h.\n+\t* dwarf2/dwz.c (locate_dwz_sections, dwz_search_other_debugdirs)\n+\t(dwarf2_get_dwz_file): Move from read.c.\n+\n 2021-03-06  Tom Tromey  <tom@tromey.com>\n \n \t* debuginfod-support.h: Include scoped_fd.h."
    },
    {
      "sha": "f9d5db6b48a6b56736fd56d95a2268ba8b8790aa",
      "filename": "gdb/dwarf2/dwz.c",
      "status": "modified",
      "additions": 242,
      "deletions": 0,
      "changes": 242,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/dwz.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/dwz.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/dwz.c?ref=9938d15a01031e0aded4159adaa77d5b2b2319f6",
      "patch": "@@ -20,6 +20,16 @@\n #include \"defs.h\"\n #include \"dwarf2/dwz.h\"\n \n+#include \"build-id.h\"\n+#include \"debuginfod-support.h\"\n+#include \"dwarf2/read.h\"\n+#include \"dwarf2/sect-names.h\"\n+#include \"filenames.h\"\n+#include \"gdb_bfd.h\"\n+#include \"gdbcore.h\"\n+#include \"gdbsupport/pathstuff.h\"\n+#include \"gdbsupport/scoped_fd.h\"\n+\n const char *\n dwz_file::read_string (struct objfile *objfile, LONGEST str_offset)\n {\n@@ -38,3 +48,235 @@ dwz_file::read_string (struct objfile *objfile, LONGEST str_offset)\n     return NULL;\n   return (const char *) (str.buffer + str_offset);\n }\n+\n+/* A helper function to find the sections for a .dwz file.  */\n+\n+static void\n+locate_dwz_sections (bfd *abfd, asection *sectp, dwz_file *dwz_file)\n+{\n+  /* Note that we only support the standard ELF names, because .dwz\n+     is ELF-only (at the time of writing).  */\n+  if (dwarf2_elf_names.abbrev.matches (sectp->name))\n+    {\n+      dwz_file->abbrev.s.section = sectp;\n+      dwz_file->abbrev.size = bfd_section_size (sectp);\n+    }\n+  else if (dwarf2_elf_names.info.matches (sectp->name))\n+    {\n+      dwz_file->info.s.section = sectp;\n+      dwz_file->info.size = bfd_section_size (sectp);\n+    }\n+  else if (dwarf2_elf_names.str.matches (sectp->name))\n+    {\n+      dwz_file->str.s.section = sectp;\n+      dwz_file->str.size = bfd_section_size (sectp);\n+    }\n+  else if (dwarf2_elf_names.line.matches (sectp->name))\n+    {\n+      dwz_file->line.s.section = sectp;\n+      dwz_file->line.size = bfd_section_size (sectp);\n+    }\n+  else if (dwarf2_elf_names.macro.matches (sectp->name))\n+    {\n+      dwz_file->macro.s.section = sectp;\n+      dwz_file->macro.size = bfd_section_size (sectp);\n+    }\n+  else if (dwarf2_elf_names.gdb_index.matches (sectp->name))\n+    {\n+      dwz_file->gdb_index.s.section = sectp;\n+      dwz_file->gdb_index.size = bfd_section_size (sectp);\n+    }\n+  else if (dwarf2_elf_names.debug_names.matches (sectp->name))\n+    {\n+      dwz_file->debug_names.s.section = sectp;\n+      dwz_file->debug_names.size = bfd_section_size (sectp);\n+    }\n+}\n+\n+/* Attempt to find a .dwz file (whose full path is represented by\n+   FILENAME) in all of the specified debug file directories provided.\n+\n+   Return the equivalent gdb_bfd_ref_ptr of the .dwz file found, or\n+   nullptr if it could not find anything.  */\n+\n+static gdb_bfd_ref_ptr\n+dwz_search_other_debugdirs (std::string &filename, bfd_byte *buildid,\n+\t\t\t    size_t buildid_len)\n+{\n+  /* Let's assume that the path represented by FILENAME has the\n+     \"/.dwz/\" subpath in it.  This is what (most) GNU/Linux\n+     distributions do, anyway.  */\n+  size_t dwz_pos = filename.find (\"/.dwz/\");\n+\n+  if (dwz_pos == std::string::npos)\n+    return nullptr;\n+\n+  /* This is an obvious assertion, but it's here more to educate\n+     future readers of this code that FILENAME at DWZ_POS *must*\n+     contain a directory separator.  */\n+  gdb_assert (IS_DIR_SEPARATOR (filename[dwz_pos]));\n+\n+  gdb_bfd_ref_ptr dwz_bfd;\n+  std::vector<gdb::unique_xmalloc_ptr<char>> debugdir_vec\n+    = dirnames_to_char_ptr_vec (debug_file_directory);\n+\n+  for (const gdb::unique_xmalloc_ptr<char> &debugdir : debugdir_vec)\n+    {\n+      /* The idea is to iterate over the\n+\t debug file directories provided by the user and\n+\t replace the hard-coded path in the \"filename\" by each\n+\t debug-file-directory.\n+\n+\t For example, suppose that filename is:\n+\n+\t   /usr/lib/debug/.dwz/foo.dwz\n+\n+\t And suppose that we have \"$HOME/bar\" as the\n+\t debug-file-directory.  We would then adjust filename\n+\t to look like:\n+\n+\t   $HOME/bar/.dwz/foo.dwz\n+\n+\t which would hopefully allow us to find the alt debug\n+\t file.  */\n+      std::string ddir = debugdir.get ();\n+\n+      if (ddir.empty ())\n+\tcontinue;\n+\n+      /* Make sure the current debug-file-directory ends with a\n+\t directory separator.  This is needed because, if FILENAME\n+\t contains something like \"/usr/lib/abcde/.dwz/foo.dwz\" and\n+\t DDIR is \"/usr/lib/abc\", then could wrongfully skip it\n+\t below.  */\n+      if (!IS_DIR_SEPARATOR (ddir.back ()))\n+\tddir += SLASH_STRING;\n+\n+      /* Check whether the beginning of FILENAME is DDIR.  If it is,\n+\t then we are dealing with a file which we already attempted to\n+\t open before, so we just skip it and continue processing the\n+\t remaining debug file directories.  */\n+      if (filename.size () > ddir.size ()\n+\t  && filename.compare (0, ddir.size (), ddir) == 0)\n+\tcontinue;\n+\n+      /* Replace FILENAME's default debug-file-directory with\n+\t DDIR.  */\n+      std::string new_filename = ddir + &filename[dwz_pos + 1];\n+\n+      dwz_bfd = gdb_bfd_open (new_filename.c_str (), gnutarget);\n+\n+      if (dwz_bfd == nullptr)\n+\tcontinue;\n+\n+      if (!build_id_verify (dwz_bfd.get (), buildid_len, buildid))\n+\t{\n+\t  dwz_bfd.reset (nullptr);\n+\t  continue;\n+\t}\n+\n+      /* Found it.  */\n+      break;\n+    }\n+\n+  return dwz_bfd;\n+}\n+\n+/* See dwz.h.  */\n+\n+struct dwz_file *\n+dwarf2_get_dwz_file (dwarf2_per_bfd *per_bfd, bool require)\n+{\n+  bfd_size_type buildid_len_arg;\n+  size_t buildid_len;\n+  bfd_byte *buildid;\n+\n+  if (per_bfd->dwz_file != NULL)\n+    return per_bfd->dwz_file.get ();\n+\n+  bfd_set_error (bfd_error_no_error);\n+  gdb::unique_xmalloc_ptr<char> data\n+    (bfd_get_alt_debug_link_info (per_bfd->obfd,\n+\t\t\t\t  &buildid_len_arg, &buildid));\n+  if (data == NULL)\n+    {\n+      if (bfd_get_error () == bfd_error_no_error)\n+\t{\n+\t  if (!require)\n+\t    return nullptr;\n+\t  error (_(\"could not read '.gnu_debugaltlink' section\"));\n+\t}\n+      error (_(\"could not read '.gnu_debugaltlink' section: %s\"),\n+\t     bfd_errmsg (bfd_get_error ()));\n+    }\n+\n+  gdb::unique_xmalloc_ptr<bfd_byte> buildid_holder (buildid);\n+\n+  buildid_len = (size_t) buildid_len_arg;\n+\n+  std::string filename = data.get ();\n+\n+  if (!IS_ABSOLUTE_PATH (filename.c_str ()))\n+    {\n+      gdb::unique_xmalloc_ptr<char> abs\n+\t= gdb_realpath (bfd_get_filename (per_bfd->obfd));\n+\n+      filename = ldirname (abs.get ()) + SLASH_STRING + filename;\n+    }\n+\n+  /* First try the file name given in the section.  If that doesn't\n+     work, try to use the build-id instead.  */\n+  gdb_bfd_ref_ptr dwz_bfd (gdb_bfd_open (filename.c_str (), gnutarget));\n+  if (dwz_bfd != NULL)\n+    {\n+      if (!build_id_verify (dwz_bfd.get (), buildid_len, buildid))\n+\tdwz_bfd.reset (nullptr);\n+    }\n+\n+  if (dwz_bfd == NULL)\n+    dwz_bfd = build_id_to_debug_bfd (buildid_len, buildid);\n+\n+  if (dwz_bfd == nullptr)\n+    {\n+      /* If the user has provided us with different\n+\t debug file directories, we can try them in order.  */\n+      dwz_bfd = dwz_search_other_debugdirs (filename, buildid, buildid_len);\n+    }\n+\n+  if (dwz_bfd == nullptr)\n+    {\n+      gdb::unique_xmalloc_ptr<char> alt_filename;\n+      const char *origname = bfd_get_filename (per_bfd->obfd);\n+\n+      scoped_fd fd (debuginfod_debuginfo_query (buildid,\n+\t\t\t\t\t\tbuildid_len,\n+\t\t\t\t\t\torigname,\n+\t\t\t\t\t\t&alt_filename));\n+\n+      if (fd.get () >= 0)\n+\t{\n+\t  /* File successfully retrieved from server.  */\n+\t  dwz_bfd = gdb_bfd_open (alt_filename.get (), gnutarget);\n+\n+\t  if (dwz_bfd == nullptr)\n+\t    warning (_(\"File \\\"%s\\\" from debuginfod cannot be opened as bfd\"),\n+\t\t     alt_filename.get ());\n+\t  else if (!build_id_verify (dwz_bfd.get (), buildid_len, buildid))\n+\t    dwz_bfd.reset (nullptr);\n+\t}\n+    }\n+\n+  if (dwz_bfd == NULL)\n+    error (_(\"could not find '.gnu_debugaltlink' file for %s\"),\n+\t   bfd_get_filename (per_bfd->obfd));\n+\n+  std::unique_ptr<struct dwz_file> result\n+    (new struct dwz_file (std::move (dwz_bfd)));\n+\n+  for (asection *sec : gdb_bfd_sections (result->dwz_bfd))\n+    locate_dwz_sections (result->dwz_bfd.get (), sec, result.get ());\n+\n+  gdb_bfd_record_inclusion (per_bfd->obfd, result->dwz_bfd.get ());\n+  per_bfd->dwz_file = std::move (result);\n+  return per_bfd->dwz_file.get ();\n+}"
    },
    {
      "sha": "634afbbfbcf8b47eba3d204762a6acf4c007953d",
      "filename": "gdb/dwarf2/dwz.h",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/dwz.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/dwz.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/dwz.h?ref=9938d15a01031e0aded4159adaa77d5b2b2319f6",
      "patch": "@@ -24,6 +24,8 @@\n #include \"dwarf2/index-cache.h\"\n #include \"dwarf2/section.h\"\n \n+struct dwarf2_per_bfd;\n+\n /* This represents a '.dwz' file.  */\n \n struct dwz_file\n@@ -62,4 +64,13 @@ struct dwz_file\n   const char *read_string (struct objfile *objfile, LONGEST str_offset);\n };\n \n+/* Open the separate '.dwz' debug file, if needed.  If there is no\n+   .gnu_debugaltlink section in the file, then the result depends on\n+   REQUIRE: if REQUIRE is true, then error; if REQUIRE is false,\n+   return NULL.  Always error if there is such a section but the file\n+   cannot be found.  */\n+\n+extern dwz_file *dwarf2_get_dwz_file (dwarf2_per_bfd *per_bfd,\n+\t\t\t\t      bool require = false);\n+\n #endif /* GDB_DWARF2_DWZ_H */"
    },
    {
      "sha": "f550a4e5008499cf94c1fa2de83b817ee6e089c3",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 1,
      "deletions": 233,
      "changes": 234,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=9938d15a01031e0aded4159adaa77d5b2b2319f6",
      "patch": "@@ -87,7 +87,6 @@\n #include \"rust-lang.h\"\n #include \"gdbsupport/pathstuff.h\"\n #include \"count-one-bits.h\"\n-#include \"debuginfod-support.h\"\n \n /* When == 1, print basic high level tracing messages.\n    When > 1, be more verbose.\n@@ -324,7 +323,7 @@ get_dwarf2_per_objfile (struct objfile *objfile)\n /* Note that if the debugging section has been compressed, it might\n    have a name like .zdebug_info.  */\n \n-static const struct dwarf2_debug_sections dwarf2_elf_names =\n+const struct dwarf2_debug_sections dwarf2_elf_names =\n {\n   { \".debug_info\", \".zdebug_info\" },\n   { \".debug_abbrev\", \".zdebug_abbrev\" },\n@@ -2149,237 +2148,6 @@ dwarf2_get_section_info (struct objfile *objfile,\n   *sizep = info->size;\n }\n \n-/* A helper function to find the sections for a .dwz file.  */\n-\n-static void\n-locate_dwz_sections (bfd *abfd, asection *sectp, dwz_file *dwz_file)\n-{\n-  /* Note that we only support the standard ELF names, because .dwz\n-     is ELF-only (at the time of writing).  */\n-  if (dwarf2_elf_names.abbrev.matches (sectp->name))\n-    {\n-      dwz_file->abbrev.s.section = sectp;\n-      dwz_file->abbrev.size = bfd_section_size (sectp);\n-    }\n-  else if (dwarf2_elf_names.info.matches (sectp->name))\n-    {\n-      dwz_file->info.s.section = sectp;\n-      dwz_file->info.size = bfd_section_size (sectp);\n-    }\n-  else if (dwarf2_elf_names.str.matches (sectp->name))\n-    {\n-      dwz_file->str.s.section = sectp;\n-      dwz_file->str.size = bfd_section_size (sectp);\n-    }\n-  else if (dwarf2_elf_names.line.matches (sectp->name))\n-    {\n-      dwz_file->line.s.section = sectp;\n-      dwz_file->line.size = bfd_section_size (sectp);\n-    }\n-  else if (dwarf2_elf_names.macro.matches (sectp->name))\n-    {\n-      dwz_file->macro.s.section = sectp;\n-      dwz_file->macro.size = bfd_section_size (sectp);\n-    }\n-  else if (dwarf2_elf_names.gdb_index.matches (sectp->name))\n-    {\n-      dwz_file->gdb_index.s.section = sectp;\n-      dwz_file->gdb_index.size = bfd_section_size (sectp);\n-    }\n-  else if (dwarf2_elf_names.debug_names.matches (sectp->name))\n-    {\n-      dwz_file->debug_names.s.section = sectp;\n-      dwz_file->debug_names.size = bfd_section_size (sectp);\n-    }\n-}\n-\n-/* Attempt to find a .dwz file (whose full path is represented by\n-   FILENAME) in all of the specified debug file directories provided.\n-\n-   Return the equivalent gdb_bfd_ref_ptr of the .dwz file found, or\n-   nullptr if it could not find anything.  */\n-\n-static gdb_bfd_ref_ptr\n-dwz_search_other_debugdirs (std::string &filename, bfd_byte *buildid,\n-\t\t\t    size_t buildid_len)\n-{\n-  /* Let's assume that the path represented by FILENAME has the\n-     \"/.dwz/\" subpath in it.  This is what (most) GNU/Linux\n-     distributions do, anyway.  */\n-  size_t dwz_pos = filename.find (\"/.dwz/\");\n-\n-  if (dwz_pos == std::string::npos)\n-    return nullptr;\n-\n-  /* This is an obvious assertion, but it's here more to educate\n-     future readers of this code that FILENAME at DWZ_POS *must*\n-     contain a directory separator.  */\n-  gdb_assert (IS_DIR_SEPARATOR (filename[dwz_pos]));\n-\n-  gdb_bfd_ref_ptr dwz_bfd;\n-  std::vector<gdb::unique_xmalloc_ptr<char>> debugdir_vec\n-    = dirnames_to_char_ptr_vec (debug_file_directory);\n-\n-  for (const gdb::unique_xmalloc_ptr<char> &debugdir : debugdir_vec)\n-    {\n-      /* The idea is to iterate over the\n-\t debug file directories provided by the user and\n-\t replace the hard-coded path in the \"filename\" by each\n-\t debug-file-directory.\n-\n-\t For example, suppose that filename is:\n-\n-\t   /usr/lib/debug/.dwz/foo.dwz\n-\n-\t And suppose that we have \"$HOME/bar\" as the\n-\t debug-file-directory.  We would then adjust filename\n-\t to look like:\n-\n-\t   $HOME/bar/.dwz/foo.dwz\n-\n-\t which would hopefully allow us to find the alt debug\n-\t file.  */\n-      std::string ddir = debugdir.get ();\n-\n-      if (ddir.empty ())\n-\tcontinue;\n-\n-      /* Make sure the current debug-file-directory ends with a\n-\t directory separator.  This is needed because, if FILENAME\n-\t contains something like \"/usr/lib/abcde/.dwz/foo.dwz\" and\n-\t DDIR is \"/usr/lib/abc\", then could wrongfully skip it\n-\t below.  */\n-      if (!IS_DIR_SEPARATOR (ddir.back ()))\n-\tddir += SLASH_STRING;\n-\n-      /* Check whether the beginning of FILENAME is DDIR.  If it is,\n-\t then we are dealing with a file which we already attempted to\n-\t open before, so we just skip it and continue processing the\n-\t remaining debug file directories.  */\n-      if (filename.size () > ddir.size ()\n-\t  && filename.compare (0, ddir.size (), ddir) == 0)\n-\tcontinue;\n-\n-      /* Replace FILENAME's default debug-file-directory with\n-\t DDIR.  */\n-      std::string new_filename = ddir + &filename[dwz_pos + 1];\n-\n-      dwz_bfd = gdb_bfd_open (new_filename.c_str (), gnutarget);\n-\n-      if (dwz_bfd == nullptr)\n-\tcontinue;\n-\n-      if (!build_id_verify (dwz_bfd.get (), buildid_len, buildid))\n-\t{\n-\t  dwz_bfd.reset (nullptr);\n-\t  continue;\n-\t}\n-\n-      /* Found it.  */\n-      break;\n-    }\n-\n-  return dwz_bfd;\n-}\n-\n-/* See dwarf2read.h.  */\n-\n-struct dwz_file *\n-dwarf2_get_dwz_file (dwarf2_per_bfd *per_bfd, bool require)\n-{\n-  bfd_size_type buildid_len_arg;\n-  size_t buildid_len;\n-  bfd_byte *buildid;\n-\n-  if (per_bfd->dwz_file != NULL)\n-    return per_bfd->dwz_file.get ();\n-\n-  bfd_set_error (bfd_error_no_error);\n-  gdb::unique_xmalloc_ptr<char> data\n-    (bfd_get_alt_debug_link_info (per_bfd->obfd,\n-\t\t\t\t  &buildid_len_arg, &buildid));\n-  if (data == NULL)\n-    {\n-      if (bfd_get_error () == bfd_error_no_error)\n-\t{\n-\t  if (!require)\n-\t    return nullptr;\n-\t  error (_(\"could not read '.gnu_debugaltlink' section\"));\n-\t}\n-      error (_(\"could not read '.gnu_debugaltlink' section: %s\"),\n-\t     bfd_errmsg (bfd_get_error ()));\n-    }\n-\n-  gdb::unique_xmalloc_ptr<bfd_byte> buildid_holder (buildid);\n-\n-  buildid_len = (size_t) buildid_len_arg;\n-\n-  std::string filename = data.get ();\n-\n-  if (!IS_ABSOLUTE_PATH (filename.c_str ()))\n-    {\n-      gdb::unique_xmalloc_ptr<char> abs\n-\t= gdb_realpath (bfd_get_filename (per_bfd->obfd));\n-\n-      filename = ldirname (abs.get ()) + SLASH_STRING + filename;\n-    }\n-\n-  /* First try the file name given in the section.  If that doesn't\n-     work, try to use the build-id instead.  */\n-  gdb_bfd_ref_ptr dwz_bfd (gdb_bfd_open (filename.c_str (), gnutarget));\n-  if (dwz_bfd != NULL)\n-    {\n-      if (!build_id_verify (dwz_bfd.get (), buildid_len, buildid))\n-\tdwz_bfd.reset (nullptr);\n-    }\n-\n-  if (dwz_bfd == NULL)\n-    dwz_bfd = build_id_to_debug_bfd (buildid_len, buildid);\n-\n-  if (dwz_bfd == nullptr)\n-    {\n-      /* If the user has provided us with different\n-\t debug file directories, we can try them in order.  */\n-      dwz_bfd = dwz_search_other_debugdirs (filename, buildid, buildid_len);\n-    }\n-\n-  if (dwz_bfd == nullptr)\n-    {\n-      gdb::unique_xmalloc_ptr<char> alt_filename;\n-      const char *origname = bfd_get_filename (per_bfd->obfd);\n-\n-      scoped_fd fd (debuginfod_debuginfo_query (buildid,\n-\t\t\t\t\t\tbuildid_len,\n-\t\t\t\t\t\torigname,\n-\t\t\t\t\t\t&alt_filename));\n-\n-      if (fd.get () >= 0)\n-\t{\n-\t  /* File successfully retrieved from server.  */\n-\t  dwz_bfd = gdb_bfd_open (alt_filename.get (), gnutarget);\n-\n-\t  if (dwz_bfd == nullptr)\n-\t    warning (_(\"File \\\"%s\\\" from debuginfod cannot be opened as bfd\"),\n-\t\t     alt_filename.get ());\n-\t  else if (!build_id_verify (dwz_bfd.get (), buildid_len, buildid))\n-\t    dwz_bfd.reset (nullptr);\n-\t}\n-    }\n-\n-  if (dwz_bfd == NULL)\n-    error (_(\"could not find '.gnu_debugaltlink' file for %s\"),\n-\t   bfd_get_filename (per_bfd->obfd));\n-\n-  std::unique_ptr<struct dwz_file> result\n-    (new struct dwz_file (std::move (dwz_bfd)));\n-\n-  for (asection *sec : gdb_bfd_sections (result->dwz_bfd))\n-    locate_dwz_sections (result->dwz_bfd.get (), sec, result.get ());\n-\n-  gdb_bfd_record_inclusion (per_bfd->obfd, result->dwz_bfd.get ());\n-  per_bfd->dwz_file = std::move (result);\n-  return per_bfd->dwz_file.get ();\n-}\n \f\n /* DWARF quick_symbols_functions support.  */\n "
    },
    {
      "sha": "5728ba68288241a0d30b68256b52e97beb82d57f",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=9938d15a01031e0aded4159adaa77d5b2b2319f6",
      "patch": "@@ -633,15 +633,6 @@ struct signatured_type\n   struct dwo_unit *dwo_unit;\n };\n \n-/* Open the separate '.dwz' debug file, if needed.  If there is no\n-   .gnu_debugaltlink section in the file, then the result depends on\n-   REQUIRE: if REQUIRE is true, then error; if REQUIRE is false,\n-   return NULL.  Always error if there is such a section but the file\n-   cannot be found.  */\n-\n-extern dwz_file *dwarf2_get_dwz_file (dwarf2_per_bfd *per_bfd,\n-\t\t\t\t      bool require = false);\n-\n /* Return the type of the DIE at DIE_OFFSET in the CU named by\n    PER_CU.  */\n "
    },
    {
      "sha": "bf7ea2cd4b2077833a2ac41fc19d7d6ccb876d0d",
      "filename": "gdb/dwarf2/sect-names.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/sect-names.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9938d15a01031e0aded4159adaa77d5b2b2319f6/gdb/dwarf2/sect-names.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/sect-names.h?ref=9938d15a01031e0aded4159adaa77d5b2b2319f6",
      "patch": "@@ -72,4 +72,7 @@ struct dwarf2_debug_sections {\n   int sentinel;\n };\n \n+/* Section names for ELF.  */\n+extern const struct dwarf2_debug_sections dwarf2_elf_names;\n+\n #endif /* GDB_DWARF2_SECT_NAMES_H */"
    }
  ]
}