{
  "sha": "80b56fad5c99a8c93004b0432dd2b363125de35a",
  "node_id": "C_kwDOANOeidoAKDgwYjU2ZmFkNWM5OWE4YzkzMDA0YjA0MzJkZDJiMzYzMTI1ZGUzNWE",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-10-25T10:17:02Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-10-25T10:17:03Z"
    },
    "message": "binutils: make objdump/readelf --ctf-parent actually useful\n\nThis option has been present since the very early days of the\ndevelopment of libctf as part of binutils, and it shows.  Back in the\nearliest days, I thought we might handle ambiguous types by introducing\nnew ELF sections on the fly named things like .ctf.foo.c for ambiguous\ntypes found only in foo.c, etc.  This turned out to be a terrible idea,\nso we moved to using a CTF archive in the .ctf section which contained\nall the CTF dictionaries -- but the --ctf-parent option in objdump and\nreadelf was never adjusted, and lingered as a mechanism to specify CTF\nparent dictionaries in sections other than .ctf, even though the linker\nhas no way to produce parent dictionaries in different sections from\ntheir children, libctf's ctf_open can't handle such split-up\nparent/child dicts, and they are never found in the wild, emitted by GNU\nld or by any known third-party linking tool.\n\nMeanwhile, the actually-useful ctf_link feature (albeit not used by ld)\nwhich lets you remap the names of CTF archive members (so you can end up\nwith a parent archive member named something other than \".ctf\", still\ncontained with all its children in a single .ctf section) had no support\nin objdump or readelf: there was no way to tell them that these members\nwere parents, so all the types in the associated child dicts always\nappeared corrupted, referencing nonexistent types from a parent objdump\ncouldn't find.\n\nSo adjust --ctf-parent so that rather than taking a section name it\ntakes a member name instead (if not specified, the name is \".ctf\", which\nis what GNU ld emits).  Because the option was always useless before\nnow, this is expected to have no backward-compatibility implications.\n\nAs part of this, we have to slightly adjust the code which skips the\narchive member name if redundant: right now it skips it if it's \".ctf\",\non the assumption that this name will almost always be at the start\nof the objdump output and thus we'll end up with a shared dump\nand then smaller, headed dumps for the per-TU child dicts; but if\nthe parent name has been changed, that won't be true any more.\n\nSo change the rules to \"members named .ctf which appear first in the\nfirst have their member name skipped\".  Since we now need to count\nmembers, move from ctf_archive_iter (for which passing in extra\nparameters requires defining a new struct and is clumsy) to\nctf_archive_next, allowing us to just *call* dump_ctf_archive_member and\nmaintain a member count in the obvious way.  In the process we fix a\ntiny difference between readelf and objdump: if a ctf_dump ever failed,\nreadelf skipped every later member, while objdump tried to keep going as\nmuch as it could.  For a dumping tool the former is clearly preferable.\n\nbinutils/ChangeLog\n2021-10-25  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* objdump.c (usage): --ctf-parent now takes a name, not a section.\n\t(dump_ctf): Don't open a separate section; use the parent_name in\n\tctf_dict_open instead.  Use ctf_archive_next, not ctf_archive_iter,\n\tso we can pass down a member count.\n\t(dump_ctf_archive_member): Add the member count; don't return\n\tanything.  Import parents into children no matter what the\n\tparent's name, while still avoiding displaying the header for the\n\tcommon parent name of \".ctf\".\n\t* readelf.c (usage): Adjust similarly.\n\t(dump_section_as_ctf): Likewise.\n\t(dump_ctf_archive_member): Likewise.  Never stop iterating over\n\tarchive members, even if ctf_dump of one member fails.\n\t* doc/ctf.options.texi: Adjust.",
    "tree": {
      "sha": "c6a84af02a9c4678a620175ac3e569dd8c4b33d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c6a84af02a9c4678a620175ac3e569dd8c4b33d6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/80b56fad5c99a8c93004b0432dd2b363125de35a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/80b56fad5c99a8c93004b0432dd2b363125de35a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/80b56fad5c99a8c93004b0432dd2b363125de35a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/80b56fad5c99a8c93004b0432dd2b363125de35a/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5513527b59e95a53802b5960821aa3c98a280ac8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5513527b59e95a53802b5960821aa3c98a280ac8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5513527b59e95a53802b5960821aa3c98a280ac8"
    }
  ],
  "stats": {
    "total": 207,
    "additions": 86,
    "deletions": 121
  },
  "files": [
    {
      "sha": "ea9cfe4314652eae8e50bcb5f4f81f11e130df1e",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/80b56fad5c99a8c93004b0432dd2b363125de35a/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/80b56fad5c99a8c93004b0432dd2b363125de35a/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=80b56fad5c99a8c93004b0432dd2b363125de35a",
      "patch": "@@ -1,3 +1,19 @@\n+2021-10-25  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* objdump.c (usage): --ctf-parent now takes a name, not a section.\n+\t(dump_ctf): Don't open a separate section; use the parent_name in\n+\tctf_dict_open instead.  Use ctf_archive_next, not ctf_archive_iter,\n+\tso we can pass down a member count.\n+\t(dump_ctf_archive_member): Add the member count; don't return\n+\tanything.  Import parents into children no matter what the\n+\tparent's name, while still avoiding displaying the header for the\n+\tcommon parent name of \".ctf\".\n+\t* readelf.c (usage): Adjust similarly.\n+\t(dump_section_as_ctf): Likewise.\n+\t(dump_ctf_archive_member): Likewise.  Never stop iterating over\n+\tarchive members, even if ctf_dump of one member fails.\n+\t* doc/ctf.options.texi: Adjust.\n+\n 2021-10-19  Nick Clifton  <nickc@redhat.com>\n \n \t* nm.c (filter_symbols): Test for a NULL name before checking to"
    },
    {
      "sha": "34451f9221ab313761239d4c060b91f05accc1c4",
      "filename": "binutils/doc/ctf.options.texi",
      "status": "modified",
      "additions": 11,
      "deletions": 4,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/80b56fad5c99a8c93004b0432dd2b363125de35a/binutils/doc/ctf.options.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/80b56fad5c99a8c93004b0432dd2b363125de35a/binutils/doc/ctf.options.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/doc/ctf.options.texi?ref=80b56fad5c99a8c93004b0432dd2b363125de35a",
      "patch": "@@ -8,8 +8,15 @@\n Display the contents of the specified CTF section.  CTF sections themselves\n contain many subsections, all of which are displayed in order.\n \n-@item --ctf-parent=@var{section}\n \n-Specify the name of another section from which the CTF dictionary can inherit\n-types.  (If none is specified, we assume the CTF dictionary inherits types\n-from the default-named member of the archive contained within this section.)\n+@item --ctf-parent=@var{member}\n+\n+If the CTF section contains ambiguously-defined types, it will consist\n+of an archive of many CTF dictionaries, all inheriting from one\n+dictionary containing unambiguous types.  This member is by default\n+named @var{.ctf}, like the section containing it, but it is possible to\n+change this name using the @code{ctf_link_set_memb_name_changer}\n+function at link time.  When looking at CTF archives that have been\n+created by a linker that uses the name changer to rename the parent\n+archive member, @option{--ctf-parent} can be used to specify the name\n+used for the parent."
    },
    {
      "sha": "43472e19e259ac3c25e5057532d03c085c8f626a",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 28,
      "deletions": 49,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/80b56fad5c99a8c93004b0432dd2b363125de35a/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/80b56fad5c99a8c93004b0432dd2b363125de35a/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=80b56fad5c99a8c93004b0432dd2b363125de35a",
      "patch": "@@ -361,7 +361,7 @@ usage (FILE *stream, int status)\n       --dwarf-check              Make additional dwarf consistency checks.\\n\"));\n #ifdef ENABLE_LIBCTF\n       fprintf (stream, _(\"\\\n-      --ctf-parent=SECTION       Use SECTION as the CTF parent\\n\"));\n+      --ctf-parent=NAME          Use CTF archive member NAME as the CTF parent\\n\"));\n #endif\n       fprintf (stream, _(\"\\\n       --visualize-jumps          Visualize jumps by drawing ASCII art lines\\n\"));\n@@ -4156,29 +4156,27 @@ dump_ctf_errs (ctf_dict_t *fp)\n \n /* Dump one CTF archive member.  */\n \n-static int\n-dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, void *arg)\n+static void\n+dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, ctf_dict_t *parent,\n+\t\t\t size_t member)\n {\n-  ctf_dict_t *parent = (ctf_dict_t *) arg;\n   const char *things[] = {\"Header\", \"Labels\", \"Data objects\",\n \t\t\t  \"Function objects\", \"Variables\", \"Types\", \"Strings\",\n \t\t\t  \"\"};\n   const char **thing;\n   size_t i;\n \n-  /* Only print out the name of non-default-named archive members.\n-     The name .ctf appears everywhere, even for things that aren't\n-     really archives, so printing it out is liable to be confusing.\n+  /* Don't print out the name of the default-named archive member if it appears\n+     first in the list.  The name .ctf appears everywhere, even for things that\n+     aren't really archives, so printing it out is liable to be confusing; also,\n+     the common case by far is for only one archive member to exist, and hiding\n+     it in that case seems worthwhile.  */\n \n-     The parent, if there is one, is the default-owned archive member:\n-     avoid importing it into itself.  (This does no harm, but looks\n-     confusing.)  */\n+  if (strcmp (name, \".ctf\") != 0 || member != 0)\n+    printf (_(\"\\nCTF archive member: %s:\\n\"), sanitize_string (name));\n \n-  if (strcmp (name, \".ctf\") != 0)\n-    {\n-      printf (_(\"\\nCTF archive member: %s:\\n\"), sanitize_string (name));\n-      ctf_import (ctf, parent);\n-    }\n+  if (ctf_parent_name (ctf) != NULL)\n+    ctf_import (ctf, parent);\n \n   for (i = 0, thing = things; *thing[0]; thing++, i++)\n     {\n@@ -4202,31 +4200,30 @@ dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, void *arg)\n     }\n \n   dump_ctf_errs (ctf);\n-\n-  return 0;\n }\n \n /* Dump the CTF debugging information.  */\n \n static void\n dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)\n {\n-  ctf_archive_t *ctfa, *parenta = NULL, *lookparent;\n-  bfd_byte *ctfdata, *parentdata = NULL;\n-  bfd_size_type ctfsize, parentsize;\n+  ctf_archive_t *ctfa = NULL;\n+  bfd_byte *ctfdata = NULL;\n+  bfd_size_type ctfsize;\n   ctf_sect_t ctfsect;\n-  ctf_dict_t *parent = NULL;\n+  ctf_dict_t *parent;\n+  ctf_dict_t *fp;\n+  ctf_next_t *i = NULL;\n+  const char *name;\n+  size_t member = 0;\n   int err;\n \n-  if ((ctfdata = read_section_stabs (abfd, sect_name, &ctfsize, NULL)) == NULL)\n-      bfd_fatal (bfd_get_filename (abfd));\n \n-  if (parent_name\n-      && (parentdata = read_section_stabs (abfd, parent_name, &parentsize,\n-\t\t\t\t\t   NULL)) == NULL)\n+  if ((ctfdata = read_section_stabs (abfd, sect_name, &ctfsize, NULL)) == NULL)\n       bfd_fatal (bfd_get_filename (abfd));\n \n-  /* Load the CTF file and dump it.  */\n+  /* Load the CTF file and dump it.  Preload the parent dict, since it will\n+     need to be imported into every child in turn. */\n \n   ctfsect = make_ctfsect (sect_name, ctfdata, ctfsize);\n   if ((ctfa = ctf_bfdopen_ctfsect (abfd, &ctfsect, &err)) == NULL)\n@@ -4236,25 +4233,7 @@ dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)\n       bfd_fatal (bfd_get_filename (abfd));\n     }\n \n-  if (parentdata)\n-    {\n-      ctfsect = make_ctfsect (parent_name, parentdata, parentsize);\n-      if ((parenta = ctf_bfdopen_ctfsect (abfd, &ctfsect, &err)) == NULL)\n-\t{\n-\t  dump_ctf_errs (NULL);\n-\t  non_fatal (_(\"CTF open failure: %s\"), ctf_errmsg (err));\n-\t  bfd_fatal (bfd_get_filename (abfd));\n-\t}\n-\n-      lookparent = parenta;\n-    }\n-  else\n-    lookparent = ctfa;\n-\n-  /* Assume that the applicable parent archive member is the default one.\n-     (This is what all known implementations are expected to do, if they\n-     put CTFs and their parents in archives together.)  */\n-  if ((parent = ctf_dict_open (lookparent, NULL, &err)) == NULL)\n+  if ((parent = ctf_dict_open (ctfa, parent_name, &err)) == NULL)\n     {\n       dump_ctf_errs (NULL);\n       non_fatal (_(\"CTF open failure: %s\"), ctf_errmsg (err));\n@@ -4263,16 +4242,16 @@ dump_ctf (bfd *abfd, const char *sect_name, const char *parent_name)\n \n   printf (_(\"Contents of CTF section %s:\\n\"), sanitize_string (sect_name));\n \n-  if ((err = ctf_archive_iter (ctfa, dump_ctf_archive_member, parent)) != 0)\n+  while ((fp = ctf_archive_next (ctfa, &i, &name, 0, &err)) != NULL)\n+    dump_ctf_archive_member (fp, name, parent, member++);\n+  if (err != ECTF_NEXT_END)\n     {\n       dump_ctf_errs (NULL);\n       non_fatal (_(\"CTF archive member open failure: %s\"), ctf_errmsg (err));\n       bfd_fatal (bfd_get_filename (abfd));\n     }\n   ctf_dict_close (parent);\n   ctf_close (ctfa);\n-  ctf_close (parenta);\n-  free (parentdata);\n   free (ctfdata);\n }\n #else"
    },
    {
      "sha": "682eacdef145e42c8d65ff84611fcdff0e465800",
      "filename": "binutils/readelf.c",
      "status": "modified",
      "additions": 31,
      "deletions": 68,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/80b56fad5c99a8c93004b0432dd2b363125de35a/binutils/readelf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/80b56fad5c99a8c93004b0432dd2b363125de35a/binutils/readelf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/readelf.c?ref=80b56fad5c99a8c93004b0432dd2b363125de35a",
      "patch": "@@ -4869,8 +4869,7 @@ usage (FILE * stream)\n   fprintf (stream, _(\"\\\n   --ctf=<number|name>    Display CTF info from section <number|name>\\n\"));\n   fprintf (stream, _(\"\\\n-  --ctf-parent=<number|name>\\n\\\n-                         Use section <number|name> as the CTF parent\\n\"));\n+  --ctf-parent=<name>    Use CTF archive member <name> as the CTF parent\\n\"));\n   fprintf (stream, _(\"\\\n   --ctf-symbols=<number|name>\\n\\\n                          Use section <number|name> as the CTF external symtab\\n\"));\n@@ -15164,30 +15163,27 @@ dump_ctf_errs (ctf_dict_t *fp)\n \n /* Dump one CTF archive member.  */\n \n-static int\n-dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, void *arg)\n+static void\n+dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, ctf_dict_t *parent,\n+\t\t\t size_t member)\n {\n-  ctf_dict_t *parent = (ctf_dict_t *) arg;\n   const char *things[] = {\"Header\", \"Labels\", \"Data objects\",\n \t\t\t  \"Function objects\", \"Variables\", \"Types\", \"Strings\",\n \t\t\t  \"\"};\n   const char **thing;\n   size_t i;\n-  int err = 0;\n \n-  /* Only print out the name of non-default-named archive members.\n-     The name .ctf appears everywhere, even for things that aren't\n-     really archives, so printing it out is liable to be confusing.\n+  /* Don't print out the name of the default-named archive member if it appears\n+     first in the list.  The name .ctf appears everywhere, even for things that\n+     aren't really archives, so printing it out is liable to be confusing; also,\n+     the common case by far is for only one archive member to exist, and hiding\n+     it in that case seems worthwhile.  */\n \n-     The parent, if there is one, is the default-owned archive member:\n-     avoid importing it into itself.  (This does no harm, but looks\n-     confusing.)  */\n+  if (strcmp (name, \".ctf\") != 0 || member != 0)\n+    printf (_(\"\\nCTF archive member: %s:\\n\"), name);\n \n-  if (strcmp (name, \".ctf\") != 0)\n-    {\n-      printf (_(\"\\nCTF archive member: %s:\\n\"), name);\n-      ctf_import (ctf, parent);\n-    }\n+  if (ctf_parent_name (ctf) != NULL)\n+    ctf_import (ctf, parent);\n \n   for (i = 0, thing = things; *thing[0]; thing++, i++)\n     {\n@@ -15206,33 +15202,31 @@ dump_ctf_archive_member (ctf_dict_t *ctf, const char *name, void *arg)\n \t{\n \t  error (_(\"Iteration failed: %s, %s\\n\"), *thing,\n \t\t ctf_errmsg (ctf_errno (ctf)));\n-\t  err = 1;\n-\t  goto out;\n+\t  break;\n \t}\n     }\n \n- out:\n   dump_ctf_errs (ctf);\n-  return err;\n }\n \n static bool\n dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n {\n-  Elf_Internal_Shdr *  parent_sec = NULL;\n   Elf_Internal_Shdr *  symtab_sec = NULL;\n   Elf_Internal_Shdr *  strtab_sec = NULL;\n   void *\t       data = NULL;\n   void *\t       symdata = NULL;\n   void *\t       strdata = NULL;\n-  void *\t       parentdata = NULL;\n-  ctf_sect_t\t       ctfsect, symsect, strsect, parentsect;\n+  ctf_sect_t\t       ctfsect, symsect, strsect;\n   ctf_sect_t *\t       symsectp = NULL;\n   ctf_sect_t *\t       strsectp = NULL;\n   ctf_archive_t *      ctfa = NULL;\n-  ctf_archive_t *      parenta = NULL, *lookparent;\n   ctf_dict_t *         parent = NULL;\n+  ctf_dict_t *         fp;\n \n+  ctf_next_t *i = NULL;\n+  const char *name;\n+  size_t member = 0;\n   int err;\n   bool ret = false;\n \n@@ -15279,25 +15273,9 @@ dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n       strsect.cts_data = strdata;\n     }\n \n-  if (dump_ctf_parent_name)\n-    {\n-      if ((parent_sec = find_section (filedata, dump_ctf_parent_name)) == NULL)\n-\t{\n-\t  error (_(\"No CTF parent section named %s\\n\"), dump_ctf_parent_name);\n-\t  goto fail;\n-\t}\n-      if ((parentdata = (void *) get_data (NULL, filedata,\n-\t\t\t\t\t   parent_sec->sh_offset, 1,\n-\t\t\t\t\t   parent_sec->sh_size,\n-\t\t\t\t\t   _(\"CTF parent\"))) == NULL)\n-\tgoto fail;\n-      shdr_to_ctf_sect (&parentsect, parent_sec, filedata);\n-      parentsect.cts_data = parentdata;\n-    }\n-\n   /* Load the CTF file and dump it.  It may be a raw CTF section, or an archive:\n      libctf papers over the difference, so we can pretend it is always an\n-     archive.  Possibly open the parent as well, if one was specified.  */\n+     archive.  */\n \n   if ((ctfa = ctf_arc_bufopen (&ctfsect, symsectp, strsectp, &err)) == NULL)\n     {\n@@ -15309,24 +15287,9 @@ dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n   ctf_arc_symsect_endianness (ctfa, filedata->file_header.e_ident[EI_DATA]\n \t\t\t      != ELFDATA2MSB);\n \n-  if (parentdata)\n-    {\n-      if ((parenta = ctf_arc_bufopen (&parentsect, symsectp, strsectp,\n-\t\t\t\t      &err)) == NULL)\n-\t{\n-\t  dump_ctf_errs (NULL);\n-\t  error (_(\"CTF open failure: %s\\n\"), ctf_errmsg (err));\n-\t  goto fail;\n-\t}\n-      lookparent = parenta;\n-    }\n-  else\n-    lookparent = ctfa;\n-\n-  /* Assume that the applicable parent archive member is the default one.\n-     (This is what all known implementations are expected to do, if they\n-     put CTFs and their parents in archives together.)  */\n-  if ((parent = ctf_dict_open (lookparent, NULL, &err)) == NULL)\n+  /* Preload the parent dict, since it will need to be imported into every\n+     child in turn.  */\n+  if ((parent = ctf_dict_open (ctfa, dump_ctf_parent_name, &err)) == NULL)\n     {\n       dump_ctf_errs (NULL);\n       error (_(\"CTF open failure: %s\\n\"), ctf_errmsg (err));\n@@ -15343,18 +15306,18 @@ dump_section_as_ctf (Elf_Internal_Shdr * section, Filedata * filedata)\n     printf (_(\"\\nDump of CTF section '%s':\\n\"),\n \t    printable_section_name (filedata, section));\n \n-  if ((err = ctf_archive_iter (ctfa, dump_ctf_archive_member, parent)) != 0)\n-    {\n-      dump_ctf_errs (NULL);\n-      error (_(\"CTF member open failure: %s\\n\"), ctf_errmsg (err));\n-      ret = false;\n-    }\n+ while ((fp = ctf_archive_next (ctfa, &i, &name, 0, &err)) != NULL)\n+    dump_ctf_archive_member (fp, name, parent, member++);\n+ if (err != ECTF_NEXT_END)\n+   {\n+     dump_ctf_errs (NULL);\n+     error (_(\"CTF member open failure: %s\\n\"), ctf_errmsg (err));\n+     ret = false;\n+   }\n \n  fail:\n   ctf_dict_close (parent);\n   ctf_close (ctfa);\n-  ctf_close (parenta);\n-  free (parentdata);\n   free (data);\n   free (symdata);\n   free (strdata);"
    }
  ]
}