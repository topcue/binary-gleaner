{
  "sha": "dfc19da6a6d43390544fa446bb1a33723b339a77",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGZjMTlkYTZhNmQ0MzM5MDU0NGZhNDQ2YmIxYTMzNzIzYjMzOWE3Nw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-08-14T01:21:22Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-08-14T03:13:25Z"
    },
    "message": "PR24623, DWARF errors\n\n\tPR 24623\n\t* dwarf2.c (stash_comp_unit): New function, extracted from..\n\t(_bfd_dwarf2_find_nearest_line): ..here.\n\t(find_abstract_instance): Parse comp units and decode line info\n\tas needed.",
    "tree": {
      "sha": "962c139967c1312c0414500c9b625063a5d4b6d0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/962c139967c1312c0414500c9b625063a5d4b6d0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/dfc19da6a6d43390544fa446bb1a33723b339a77",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dfc19da6a6d43390544fa446bb1a33723b339a77",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/dfc19da6a6d43390544fa446bb1a33723b339a77",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dfc19da6a6d43390544fa446bb1a33723b339a77/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c327a44f38ad5ab0dfd8da5184c4c030798ef323",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c327a44f38ad5ab0dfd8da5184c4c030798ef323",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c327a44f38ad5ab0dfd8da5184c4c030798ef323"
    }
  ],
  "stats": {
    "total": 249,
    "additions": 139,
    "deletions": 110
  },
  "files": [
    {
      "sha": "8a028cf0323d88d60a5e3b48d2e6f57f9b26670b",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dfc19da6a6d43390544fa446bb1a33723b339a77/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dfc19da6a6d43390544fa446bb1a33723b339a77/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=dfc19da6a6d43390544fa446bb1a33723b339a77",
      "patch": "@@ -1,3 +1,11 @@\n+2019-08-14  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 24623\n+\t* dwarf2.c (stash_comp_unit): New function, extracted from..\n+\t(_bfd_dwarf2_find_nearest_line): ..here.\n+\t(find_abstract_instance): Parse comp units and decode line info\n+\tas needed.\n+\n 2019-08-14  Alan Modra  <amodra@gmail.com>\n \n \t* dwarf2.c (comp_unit_maybe_decode_line_info): Declare."
    },
    {
      "sha": "057fd91317319105717ad8fa79d85e052b3d0117",
      "filename": "bfd/dwarf2.c",
      "status": "modified",
      "additions": 131,
      "deletions": 110,
      "changes": 241,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dfc19da6a6d43390544fa446bb1a33723b339a77/bfd/dwarf2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dfc19da6a6d43390544fa446bb1a33723b339a77/bfd/dwarf2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf2.c?ref=dfc19da6a6d43390544fa446bb1a33723b339a77",
      "patch": "@@ -2804,6 +2804,7 @@ lookup_symbol_in_variable_table (struct comp_unit *unit,\n   return FALSE;\n }\n \n+static struct comp_unit *stash_comp_unit (struct dwarf2_debug *);\n static bfd_boolean comp_unit_maybe_decode_line_info (struct comp_unit *,\n \t\t\t\t\t\t     struct dwarf2_debug *);\n \n@@ -2877,12 +2878,26 @@ find_abstract_instance (struct comp_unit *   unit,\n \t      if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n \t\tbreak;\n \n-\t  if (u)\n+\t  while (u == NULL)\n \t    {\n-\t      unit = u;\n-\t      info_ptr_end = unit->end_ptr;\n+\t      u = stash_comp_unit (unit->stash);\n+\t      if (u == NULL)\n+\t\tbreak;\n+\t      if (info_ptr >= u->info_ptr_unit && info_ptr < u->end_ptr)\n+\t\tbreak;\n+\t      u = NULL;\n \t    }\n-\t  /* else FIXME: What do we do now ?  */\n+\n+\t  if (u == NULL)\n+\t    {\n+\t      _bfd_error_handler\n+\t\t(_(\"DWARF error: unable to locate abstract instance DIE ref %\"\n+\t\t   PRIu64), (uint64_t) die_ref);\n+\t      bfd_set_error (bfd_error_bad_value);\n+\t      return FALSE;\n+\t    }\n+\t  unit = u;\n+\t  info_ptr_end = unit->end_ptr;\n \t}\n     }\n   else if (attr_ptr->form == DW_FORM_GNU_ref_alt)\n@@ -2982,6 +2997,8 @@ find_abstract_instance (struct comp_unit *   unit,\n \t\t    }\n \t\t  break;\n \t\tcase DW_AT_decl_file:\n+\t\t  if (!comp_unit_maybe_decode_line_info (unit, unit->stash))\n+\t\t    return FALSE;\n \t\t  *filename_ptr = concat_filename (unit->line_table,\n \t\t\t\t\t\t   attr.u.val);\n \t\t  break;\n@@ -3334,7 +3351,7 @@ scan_unit_for_symbols (struct comp_unit *unit)\n   return FALSE;\n }\n \n-/* Parse a DWARF2 compilation unit starting at INFO_PTR.  This\n+/* Parse a DWARF2 compilation unit starting at INFO_PTR.  UNIT_LENGTH\n    includes the compilation unit header that proceeds the DIE's, but\n    does not include the length field that precedes each compilation\n    unit header.  END_PTR points one past the end of this comp unit.\n@@ -4451,6 +4468,90 @@ _bfd_dwarf2_slurp_debug_info (bfd *abfd, bfd *debug_bfd,\n   return TRUE;\n }\n \n+/* Parse the next DWARF2 compilation unit at STASH->INFO_PTR.  */\n+\n+static struct comp_unit *\n+stash_comp_unit (struct dwarf2_debug *stash)\n+{\n+  bfd_size_type length;\n+  unsigned int offset_size;\n+  bfd_byte *info_ptr_unit = stash->info_ptr;\n+\n+  if (stash->info_ptr >= stash->info_ptr_end)\n+    return NULL;\n+\n+  length = read_4_bytes (stash->bfd_ptr, stash->info_ptr,\n+\t\t\t stash->info_ptr_end);\n+  /* A 0xffffff length is the DWARF3 way of indicating\n+     we use 64-bit offsets, instead of 32-bit offsets.  */\n+  if (length == 0xffffffff)\n+    {\n+      offset_size = 8;\n+      length = read_8_bytes (stash->bfd_ptr, stash->info_ptr + 4,\n+\t\t\t     stash->info_ptr_end);\n+      stash->info_ptr += 12;\n+    }\n+  /* A zero length is the IRIX way of indicating 64-bit offsets,\n+     mostly because the 64-bit length will generally fit in 32\n+     bits, and the endianness helps.  */\n+  else if (length == 0)\n+    {\n+      offset_size = 8;\n+      length = read_4_bytes (stash->bfd_ptr, stash->info_ptr + 4,\n+\t\t\t     stash->info_ptr_end);\n+      stash->info_ptr += 8;\n+    }\n+  /* In the absence of the hints above, we assume 32-bit DWARF2\n+     offsets even for targets with 64-bit addresses, because:\n+     a) most of the time these targets will not have generated\n+     more than 2Gb of debug info and so will not need 64-bit\n+     offsets,\n+     and\n+     b) if they do use 64-bit offsets but they are not using\n+     the size hints that are tested for above then they are\n+     not conforming to the DWARF3 standard anyway.  */\n+  else\n+    {\n+      offset_size = 4;\n+      stash->info_ptr += 4;\n+    }\n+\n+  if (length != 0\n+      && stash->info_ptr + length <= stash->info_ptr_end\n+      && stash->info_ptr + length > stash->info_ptr)\n+    {\n+      struct comp_unit *each = parse_comp_unit (stash, length, info_ptr_unit,\n+\t\t\t\t\t\toffset_size);\n+      if (each)\n+\t{\n+\t  if (stash->all_comp_units)\n+\t    stash->all_comp_units->prev_unit = each;\n+\t  else\n+\t    stash->last_comp_unit = each;\n+\n+\t  each->next_unit = stash->all_comp_units;\n+\t  stash->all_comp_units = each;\n+\n+\t  stash->info_ptr += length;\n+\n+\t  if ((bfd_size_type) (stash->info_ptr - stash->sec_info_ptr)\n+\t      == stash->sec->size)\n+\t    {\n+\t      stash->sec = find_debug_info (stash->bfd_ptr,\n+\t\t\t\t\t    stash->debug_sections,\n+\t\t\t\t\t    stash->sec);\n+\t      stash->sec_info_ptr = stash->info_ptr;\n+\t    }\n+\t  return each;\n+\t}\n+    }\n+\n+  /* Don't trust any of the DWARF info after a corrupted length or\n+     parse error.  */\n+  stash->info_ptr = stash->info_ptr_end;\n+  return NULL;\n+}\n+\n /* Scan the debug information in PINFO looking for a DW_TAG_subprogram\n    abbrev with a DW_AT_low_pc attached to it.  Then lookup that same\n    symbol in SYMBOLS and return the difference between the low_pc and\n@@ -4699,113 +4800,33 @@ _bfd_dwarf2_find_nearest_line (bfd *abfd,\n     }\n \n   /* Read each remaining comp. units checking each as they are read.  */\n-  while (stash->info_ptr < stash->info_ptr_end)\n+  while ((each = stash_comp_unit (stash)) != NULL)\n     {\n-      bfd_vma length;\n-      unsigned int offset_size;\n-      bfd_byte *info_ptr_unit = stash->info_ptr;\n-\n-      length = read_4_bytes (stash->bfd_ptr, stash->info_ptr, stash->info_ptr_end);\n-      /* A 0xffffff length is the DWARF3 way of indicating\n-\t we use 64-bit offsets, instead of 32-bit offsets.  */\n-      if (length == 0xffffffff)\n-\t{\n-\t  offset_size = 8;\n-\t  length = read_8_bytes (stash->bfd_ptr, stash->info_ptr + 4, stash->info_ptr_end);\n-\t  stash->info_ptr += 12;\n-\t}\n-      /* A zero length is the IRIX way of indicating 64-bit offsets,\n-\t mostly because the 64-bit length will generally fit in 32\n-\t bits, and the endianness helps.  */\n-      else if (length == 0)\n-\t{\n-\t  offset_size = 8;\n-\t  length = read_4_bytes (stash->bfd_ptr, stash->info_ptr + 4, stash->info_ptr_end);\n-\t  stash->info_ptr += 8;\n-\t}\n-      /* In the absence of the hints above, we assume 32-bit DWARF2\n-\t offsets even for targets with 64-bit addresses, because:\n-\t   a) most of the time these targets will not have generated\n-\t      more than 2Gb of debug info and so will not need 64-bit\n-\t      offsets,\n-\t and\n-\t   b) if they do use 64-bit offsets but they are not using\n-\t      the size hints that are tested for above then they are\n-\t      not conforming to the DWARF3 standard anyway.  */\n+      /* DW_AT_low_pc and DW_AT_high_pc are optional for\n+\t compilation units.  If we don't have them (i.e.,\n+\t unit->high == 0), we need to consult the line info table\n+\t to see if a compilation unit contains the given\n+\t address.  */\n+      if (do_line)\n+\tfound = (((symbol->flags & BSF_FUNCTION) == 0\n+\t\t  || each->arange.high == 0\n+\t\t  || comp_unit_contains_address (each, addr))\n+\t\t && comp_unit_find_line (each, symbol, addr,\n+\t\t\t\t\t filename_ptr,\n+\t\t\t\t\t linenumber_ptr,\n+\t\t\t\t\t stash));\n       else\n-\t{\n-\t  offset_size = 4;\n-\t  stash->info_ptr += 4;\n-\t}\n-\n-      if (length > 0)\n-\t{\n-\t  bfd_byte * new_ptr;\n-\n-\t  /* PR 21151  */\n-\t  if (stash->info_ptr + length > stash->info_ptr_end)\n-\t    return FALSE;\n-\n-\t  each = parse_comp_unit (stash, length, info_ptr_unit,\n-\t\t\t\t  offset_size);\n-\t  if (!each)\n-\t    /* The dwarf information is damaged, don't trust it any\n-\t       more.  */\n-\t    break;\n-\n-\t  new_ptr = stash->info_ptr + length;\n-\t  /* PR 17512: file: 1500698c.  */\n-\t  if (new_ptr < stash->info_ptr)\n-\t    {\n-\t      /* A corrupt length value - do not trust the info any more.  */\n-\t      found = FALSE;\n-\t      break;\n-\t    }\n-\t  else\n-\t    stash->info_ptr = new_ptr;\n-\n-\t  if (stash->all_comp_units)\n-\t    stash->all_comp_units->prev_unit = each;\n-\t  else\n-\t    stash->last_comp_unit = each;\n-\n-\t  each->next_unit = stash->all_comp_units;\n-\t  stash->all_comp_units = each;\n-\n-\t  /* DW_AT_low_pc and DW_AT_high_pc are optional for\n-\t     compilation units.  If we don't have them (i.e.,\n-\t     unit->high == 0), we need to consult the line info table\n-\t     to see if a compilation unit contains the given\n-\t     address.  */\n-\t  if (do_line)\n-\t    found = (((symbol->flags & BSF_FUNCTION) == 0\n-\t\t      || each->arange.high == 0\n-\t\t      || comp_unit_contains_address (each, addr))\n-\t\t     && comp_unit_find_line (each, symbol, addr,\n-\t\t\t\t\t     filename_ptr,\n-\t\t\t\t\t     linenumber_ptr,\n-\t\t\t\t\t     stash));\n-\t  else\n-\t    found = ((each->arange.high == 0\n-\t\t      || comp_unit_contains_address (each, addr))\n-\t\t     && comp_unit_find_nearest_line (each, addr,\n-\t\t\t\t\t\t     filename_ptr,\n-\t\t\t\t\t\t     &function,\n-\t\t\t\t\t\t     linenumber_ptr,\n-\t\t\t\t\t\t     discriminator_ptr,\n-\t\t\t\t\t\t     stash) != 0);\n-\n-\t  if ((bfd_vma) (stash->info_ptr - stash->sec_info_ptr)\n-\t      == stash->sec->size)\n-\t    {\n-\t      stash->sec = find_debug_info (stash->bfd_ptr, debug_sections,\n-\t\t\t\t\t    stash->sec);\n-\t      stash->sec_info_ptr = stash->info_ptr;\n-\t    }\n-\n-\t  if (found)\n-\t    goto done;\n-\t}\n+\tfound = ((each->arange.high == 0\n+\t\t  || comp_unit_contains_address (each, addr))\n+\t\t && comp_unit_find_nearest_line (each, addr,\n+\t\t\t\t\t\t filename_ptr,\n+\t\t\t\t\t\t &function,\n+\t\t\t\t\t\t linenumber_ptr,\n+\t\t\t\t\t\t discriminator_ptr,\n+\t\t\t\t\t\t stash) != 0);\n+\n+      if (found)\n+\tbreak;\n     }\n \n  done:"
    }
  ]
}