{
  "sha": "f2a98603a807101722f12b8d7a1aca9651deb133",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjJhOTg2MDNhODA3MTAxNzIyZjEyYjhkN2ExYWNhOTY1MWRlYjEzMw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:41Z"
    },
    "message": "Remove now-unused C evaluator code\n\nNow that the C parser has switched to the new style, there is no need\nfor the old C evaluation code.  This affects some other languages that\nwere relying on the C code.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* go-lang.c (go_language::expression_ops): Don't declare.\n\t* go-lang.h (class go_language) <expression_ops>: Remove.\n\t* opencl-lang.c (evaluate_subexp_opencl, exp_descriptor_opencl):\n\tRemove.\n\t(class opencl_language) <expression_ops>: Remove.\n\t* d-lang.c (class d_language) <expression_ops>: Remove.\n\t* c-lang.h (evaluate_subexp_c, exp_descriptor_c): Don't declare.\n\t* c-lang.c (evaluate_subexp_c, exp_descriptor_c): Remove.\n\t(class c_language, class cplus_language, class asm_language)\n\t(class minimal_language) <expression_ops>: Remove.",
    "tree": {
      "sha": "0355abc24a75d4fc1920415690cebe7e48cc2712",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0355abc24a75d4fc1920415690cebe7e48cc2712"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f2a98603a807101722f12b8d7a1aca9651deb133",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f2a98603a807101722f12b8d7a1aca9651deb133",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f2a98603a807101722f12b8d7a1aca9651deb133",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f2a98603a807101722f12b8d7a1aca9651deb133/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d3c54a1ce8b250acf83dda2653393f29b70d3390",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3c54a1ce8b250acf83dda2653393f29b70d3390",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d3c54a1ce8b250acf83dda2653393f29b70d3390"
    }
  ],
  "stats": {
    "total": 497,
    "additions": 14,
    "deletions": 483
  },
  "files": [
    {
      "sha": "630679aaecab6fb17237d1ca89014ffaf2f4e8a4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=f2a98603a807101722f12b8d7a1aca9651deb133",
      "patch": "@@ -1,3 +1,16 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* go-lang.c (go_language::expression_ops): Don't declare.\n+\t* go-lang.h (class go_language) <expression_ops>: Remove.\n+\t* opencl-lang.c (evaluate_subexp_opencl, exp_descriptor_opencl):\n+\tRemove.\n+\t(class opencl_language) <expression_ops>: Remove.\n+\t* d-lang.c (class d_language) <expression_ops>: Remove.\n+\t* c-lang.h (evaluate_subexp_c, exp_descriptor_c): Don't declare.\n+\t* c-lang.c (evaluate_subexp_c, exp_descriptor_c): Remove.\n+\t(class c_language, class cplus_language, class asm_language)\n+\t(class minimal_language) <expression_ops>: Remove.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ada-lang.c (resolve_subexp, replace_operator_with_call)"
    },
    {
      "sha": "00ab941bbb8fafad399c7d9243d914194bde4550",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 180,
      "changes": 180,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=f2a98603a807101722f12b8d7a1aca9651deb133",
      "patch": "@@ -579,157 +579,6 @@ parse_one_string (struct obstack *output, const char *data, int len,\n     }\n }\n \n-/* Expression evaluator for the C language family.  Most operations\n-   are delegated to evaluate_subexp_standard; see that function for a\n-   description of the arguments.  */\n-\n-struct value *\n-evaluate_subexp_c (struct type *expect_type, struct expression *exp,\n-\t\t   int *pos, enum noside noside)\n-{\n-  enum exp_opcode op = exp->elts[*pos].opcode;\n-\n-  switch (op)\n-    {\n-    case OP_STRING:\n-      {\n-\tint oplen, limit;\n-\tstruct type *type;\n-\tstruct value *result;\n-\tc_string_type dest_type;\n-\tconst char *dest_charset;\n-\tint satisfy_expected = 0;\n-\n-\tauto_obstack output;\n-\n-\t++*pos;\n-\toplen = longest_to_int (exp->elts[*pos].longconst);\n-\n-\t++*pos;\n-\tlimit = *pos + BYTES_TO_EXP_ELEM (oplen + 1);\n-\tdest_type = ((enum c_string_type_values)\n-\t\t     longest_to_int (exp->elts[*pos].longconst));\n-\tswitch (dest_type & ~C_CHAR)\n-\t  {\n-\t  case C_STRING:\n-\t    type = language_string_char_type (exp->language_defn,\n-\t\t\t\t\t      exp->gdbarch);\n-\t    break;\n-\t  case C_WIDE_STRING:\n-\t    type = lookup_typename (exp->language_defn, \"wchar_t\", NULL, 0);\n-\t    break;\n-\t  case C_STRING_16:\n-\t    type = lookup_typename (exp->language_defn, \"char16_t\", NULL, 0);\n-\t    break;\n-\t  case C_STRING_32:\n-\t    type = lookup_typename (exp->language_defn, \"char32_t\", NULL, 0);\n-\t    break;\n-\t  default:\n-\t    internal_error (__FILE__, __LINE__, _(\"unhandled c_string_type\"));\n-\t  }\n-\n-\t/* Ensure TYPE_LENGTH is valid for TYPE.  */\n-\tcheck_typedef (type);\n-\n-\t/* If the caller expects an array of some integral type,\n-\t   satisfy them.  If something odder is expected, rely on the\n-\t   caller to cast.  */\n-\tif (expect_type && expect_type->code () == TYPE_CODE_ARRAY)\n-\t  {\n-\t    struct type *element_type\n-\t      = check_typedef (TYPE_TARGET_TYPE (expect_type));\n-\n-\t    if (element_type->code () == TYPE_CODE_INT\n-\t\t|| element_type->code () == TYPE_CODE_CHAR)\n-\t      {\n-\t\ttype = element_type;\n-\t\tsatisfy_expected = 1;\n-\t      }\n-\t  }\n-\n-\tdest_charset = charset_for_string_type (dest_type, exp->gdbarch);\n-\n-\t++*pos;\n-\twhile (*pos < limit)\n-\t  {\n-\t    int len;\n-\n-\t    len = longest_to_int (exp->elts[*pos].longconst);\n-\n-\t    ++*pos;\n-\t    if (noside != EVAL_SKIP)\n-\t      parse_one_string (&output, &exp->elts[*pos].string, len,\n-\t\t\t\tdest_charset, type);\n-\t    *pos += BYTES_TO_EXP_ELEM (len);\n-\t  }\n-\n-\t/* Skip the trailing length and opcode.  */\n-\t*pos += 2;\n-\n-\tif (noside == EVAL_SKIP)\n-\t  {\n-\t    /* Return a dummy value of the appropriate type.  */\n-\t    if (expect_type != NULL)\n-\t      result = allocate_value (expect_type);\n-\t    else if ((dest_type & C_CHAR) != 0)\n-\t      result = allocate_value (type);\n-\t    else\n-\t      result = value_cstring (\"\", 0, type);\n-\t    return result;\n-\t  }\n-\n-\tif ((dest_type & C_CHAR) != 0)\n-\t  {\n-\t    LONGEST value;\n-\n-\t    if (obstack_object_size (&output) != TYPE_LENGTH (type))\n-\t      error (_(\"Could not convert character \"\n-\t\t       \"constant to target character set\"));\n-\t    value = unpack_long (type, (gdb_byte *) obstack_base (&output));\n-\t    result = value_from_longest (type, value);\n-\t  }\n-\telse\n-\t  {\n-\t    int i;\n-\n-\t    /* Write the terminating character.  */\n-\t    for (i = 0; i < TYPE_LENGTH (type); ++i)\n-\t      obstack_1grow (&output, 0);\n-\n-\t    if (satisfy_expected)\n-\t      {\n-\t\tLONGEST low_bound, high_bound;\n-\t\tint element_size = TYPE_LENGTH (type);\n-\n-\t\tif (!get_discrete_bounds (expect_type->index_type (),\n-\t\t\t\t\t  &low_bound, &high_bound))\n-\t\t  {\n-\t\t    low_bound = 0;\n-\t\t    high_bound = (TYPE_LENGTH (expect_type) / element_size) - 1;\n-\t\t  }\n-\t\tif (obstack_object_size (&output) / element_size\n-\t\t    > (high_bound - low_bound + 1))\n-\t\t  error (_(\"Too many array elements\"));\n-\n-\t\tresult = allocate_value (expect_type);\n-\t\tmemcpy (value_contents_raw (result), obstack_base (&output),\n-\t\t\tobstack_object_size (&output));\n-\t      }\n-\t    else\n-\t      result = value_cstring ((const char *) obstack_base (&output),\n-\t\t\t\t      obstack_object_size (&output),\n-\t\t\t\t      type);\n-\t  }\n-\treturn result;\n-      }\n-      break;\n-\n-    default:\n-      break;\n-    }\n-  return evaluate_subexp_standard (expect_type, exp, pos, noside);\n-}\n-\n namespace expr\n {\n \n@@ -969,15 +818,6 @@ c_language_arch_info (struct gdbarch *gdbarch,\n   lai->set_bool_type (builtin->builtin_int);\n }\n \n-const struct exp_descriptor exp_descriptor_c = \n-{\n-  print_subexp_standard,\n-  operator_length_standard,\n-  operator_check_standard,\n-  dump_subexp_body_standard,\n-  evaluate_subexp_c\n-};\n-\n /* Class representing the C language.  */\n \n class c_language : public language_defn\n@@ -1049,11 +889,6 @@ class c_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &exp_descriptor_c; }\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return c_op_print_tab; }\n };\n@@ -1232,11 +1067,6 @@ class cplus_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &exp_descriptor_c; }\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return c_op_print_tab; }\n \n@@ -1313,11 +1143,6 @@ class asm_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &exp_descriptor_c; }\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return c_op_print_tab; }\n };\n@@ -1375,11 +1200,6 @@ class minimal_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &exp_descriptor_c; }\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return c_op_print_tab; }\n };"
    },
    {
      "sha": "543a62632d512b0d08e7bc571a842597f6b26f39",
      "filename": "gdb/c-lang.h",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/c-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/c-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.h?ref=f2a98603a807101722f12b8d7a1aca9651deb133",
      "patch": "@@ -90,10 +90,7 @@ extern void c_value_print (struct value *, struct ui_file *,\n \n /* These are in c-lang.c: */\n \n-extern struct value *evaluate_subexp_c (struct type *expect_type,\n-\t\t\t\t\tstruct expression *exp,\n-\t\t\t\t\tint *pos,\n-\t\t\t\t\tenum noside noside);\n+extern void c_printchar (int, struct type *, struct ui_file *);\n \n extern void c_printstr (struct ui_file * stream,\n \t\t\tstruct type *elttype,\n@@ -106,8 +103,6 @@ extern void c_printstr (struct ui_file * stream,\n extern void c_language_arch_info (struct gdbarch *gdbarch,\n \t\t\t\t  struct language_arch_info *lai);\n \n-extern const struct exp_descriptor exp_descriptor_c;\n-\n extern void c_emit_char (int c, struct type *type,\n \t\t\t struct ui_file *stream, int quoter);\n "
    },
    {
      "sha": "4488c10e6092118f394265a844e2315bd5000210",
      "filename": "gdb/d-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/d-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/d-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-lang.c?ref=f2a98603a807101722f12b8d7a1aca9651deb133",
      "patch": "@@ -219,11 +219,6 @@ class d_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &exp_descriptor_c; }\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return d_op_print_tab; }\n };"
    },
    {
      "sha": "3af89b36c2f8c7b0e66229024d359f0fe760c719",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=f2a98603a807101722f12b8d7a1aca9651deb133",
      "patch": "@@ -386,14 +386,6 @@ go_language::demangle_symbol (const char *mangled_name, int options) const\n   return result;\n }\n \n-/* See language.h.  */\n-\n-const struct exp_descriptor *\n-go_language::expression_ops () const\n-{\n-  return &exp_descriptor_c;\n-}\n-\n /* Given a Go symbol, return its package or NULL if unknown.\n    Space for the result is malloc'd, caller must free.  */\n "
    },
    {
      "sha": "5d45c14fc06dbe6e1f4666c6b21fa535e04a4d9b",
      "filename": "gdb/go-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/go-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/go-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.h?ref=f2a98603a807101722f12b8d7a1aca9651deb133",
      "patch": "@@ -137,10 +137,6 @@ class go_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override;\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return op_print_tab; }\n "
    },
    {
      "sha": "b283be173c455b6b826910420eef0b66f7a1288c",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 280,
      "changes": 280,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f2a98603a807101722f12b8d7a1aca9651deb133/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=f2a98603a807101722f12b8d7a1aca9651deb133",
      "patch": "@@ -692,272 +692,6 @@ eval_opencl_assign (struct type *expect_type, struct expression *exp,\n   return value_assign (arg1, arg2);\n }\n \n-/* Expression evaluator for the OpenCL.  Most operations are delegated to\n-   evaluate_subexp_standard; see that function for a description of the\n-   arguments.  */\n-\n-static struct value *\n-evaluate_subexp_opencl (struct type *expect_type, struct expression *exp,\n-\t\t   int *pos, enum noside noside)\n-{\n-  enum exp_opcode op = exp->elts[*pos].opcode;\n-  struct value *arg1 = NULL;\n-  struct value *arg2 = NULL;\n-  struct type *type1, *type2;\n-\n-  switch (op)\n-    {\n-    /* Handle assignment and cast operators to support OpenCL-style\n-       scalar-to-vector widening.  */\n-    case BINOP_ASSIGN:\n-      (*pos)++;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      type1 = value_type (arg1);\n-      arg2 = evaluate_subexp (type1, exp, pos, noside);\n-\n-      return eval_opencl_assign (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case UNOP_CAST:\n-      type1 = exp->elts[*pos + 1].type;\n-      (*pos) += 2;\n-      arg1 = evaluate_subexp (type1, exp, pos, noside);\n-\n-      if (noside == EVAL_SKIP)\n-\treturn value_from_longest (builtin_type (exp->gdbarch)->\n-\t\t\t\t   builtin_int, 1);\n-\n-      return opencl_value_cast (type1, arg1);\n-\n-    case UNOP_CAST_TYPE:\n-      (*pos)++;\n-      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      type1 = value_type (arg1);\n-      arg1 = evaluate_subexp (type1, exp, pos, noside);\n-\n-      if (noside == EVAL_SKIP)\n-\treturn value_from_longest (builtin_type (exp->gdbarch)->\n-\t\t\t\t   builtin_int, 1);\n-\n-      return opencl_value_cast (type1, arg1);\n-\n-    /* Handle binary relational and equality operators that are either not\n-       or differently defined for GNU vectors.  */\n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-    case BINOP_LESS:\n-    case BINOP_GTR:\n-    case BINOP_GEQ:\n-    case BINOP_LEQ:\n-      (*pos)++;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-\n-      if (noside == EVAL_SKIP)\n-\treturn value_from_longest (builtin_type (exp->gdbarch)->\n-\t\t\t\t   builtin_int, 1);\n-\n-      return opencl_relop (expect_type, exp, noside, op, arg1, arg2);\n-\n-    /* Handle the logical unary operator not(!).  */\n-    case UNOP_LOGICAL_NOT:\n-      (*pos)++;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      if (noside == EVAL_SKIP)\n-\treturn value_from_longest (builtin_type (exp->gdbarch)->\n-\t\t\t\t   builtin_int, 1);\n-\n-      return opencl_logical_not (expect_type, exp, noside, op, arg1);\n-\n-    /* Handle the logical operator and(&&) and or(||).  */\n-    case BINOP_LOGICAL_AND:\n-    case BINOP_LOGICAL_OR:\n-      (*pos)++;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      if (noside == EVAL_SKIP)\n-\t{\n-\t  evaluate_subexp (nullptr, exp, pos, noside);\n-\n-\t  return value_from_longest (builtin_type (exp->gdbarch)->\n-\t\t\t\t     builtin_int, 1);\n-\t}\n-      else\n-\t{\n-\t  /* For scalar operations we need to avoid evaluating operands\n-\t     unnecessarily.  However, for vector operations we always need to\n-\t     evaluate both operands.  Unfortunately we only know which of the\n-\t     two cases apply after we know the type of the second operand.\n-\t     Therefore we evaluate it once using EVAL_AVOID_SIDE_EFFECTS.  */\n-\t  int oldpos = *pos;\n-\n-\t  arg2 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-\t  *pos = oldpos;\n-\t  type1 = check_typedef (value_type (arg1));\n-\t  type2 = check_typedef (value_type (arg2));\n-\n-\t  if ((type1->code () == TYPE_CODE_ARRAY && type1->is_vector ())\n-\t      || (type2->code () == TYPE_CODE_ARRAY && type2->is_vector ()))\n-\t    {\n-\t      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-\t      return opencl_relop (nullptr, exp, noside, op, arg1, arg2);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* For scalar built-in types, only evaluate the right\n-\t\t hand operand if the left hand operand compares\n-\t\t unequal(&&)/equal(||) to 0.  */\n-\t      int res;\n-\t      int tmp = value_logical_not (arg1);\n-\n-\t      if (op == BINOP_LOGICAL_OR)\n-\t\ttmp = !tmp;\n-\n-\t      arg2\n-\t\t= evaluate_subexp (nullptr, exp, pos, tmp ? EVAL_SKIP : noside);\n-\t      type1 = language_bool_type (exp->language_defn, exp->gdbarch);\n-\n-\t      if (op == BINOP_LOGICAL_AND)\n-\t\tres = !tmp && !value_logical_not (arg2);\n-\t      else /* BINOP_LOGICAL_OR */\n-\t\tres = tmp || !value_logical_not (arg2);\n-\n-\t      return value_from_longest (type1, res);\n-\t    }\n-\t}\n-\n-    /* Handle the ternary selection operator.  */\n-    case TERNOP_COND:\n-      (*pos)++;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      type1 = check_typedef (value_type (arg1));\n-      if (type1->code () == TYPE_CODE_ARRAY && type1->is_vector ())\n-\t{\n-\t  struct value *arg3, *tmp, *ret;\n-\t  struct type *eltype2, *type3, *eltype3;\n-\t  int t2_is_vec, t3_is_vec, i;\n-\t  LONGEST lowb1, lowb2, lowb3, highb1, highb2, highb3;\n-\n-\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\t  arg3 = evaluate_subexp (nullptr, exp, pos, noside);\n-\t  type2 = check_typedef (value_type (arg2));\n-\t  type3 = check_typedef (value_type (arg3));\n-\t  t2_is_vec\n-\t    = type2->code () == TYPE_CODE_ARRAY && type2->is_vector ();\n-\t  t3_is_vec\n-\t    = type3->code () == TYPE_CODE_ARRAY && type3->is_vector ();\n-\n-\t  /* Widen the scalar operand to a vector if necessary.  */\n-\t  if (t2_is_vec || !t3_is_vec)\n-\t    {\n-\t      arg3 = opencl_value_cast (type2, arg3);\n-\t      type3 = value_type (arg3);\n-\t    }\n-\t  else if (!t2_is_vec || t3_is_vec)\n-\t    {\n-\t      arg2 = opencl_value_cast (type3, arg2);\n-\t      type2 = value_type (arg2);\n-\t    }\n-\t  else if (!t2_is_vec || !t3_is_vec)\n-\t    {\n-\t      /* Throw an error if arg2 or arg3 aren't vectors.  */\n-\t      error (_(\"\\\n-Cannot perform conditional operation on incompatible types\"));\n-\t    }\n-\n-\t  eltype2 = check_typedef (TYPE_TARGET_TYPE (type2));\n-\t  eltype3 = check_typedef (TYPE_TARGET_TYPE (type3));\n-\n-\t  if (!get_array_bounds (type1, &lowb1, &highb1)\n-\t      || !get_array_bounds (type2, &lowb2, &highb2)\n-\t      || !get_array_bounds (type3, &lowb3, &highb3))\n-\t    error (_(\"Could not determine the vector bounds\"));\n-\n-\t  /* Throw an error if the types of arg2 or arg3 are incompatible.  */\n-\t  if (eltype2->code () != eltype3->code ()\n-\t      || TYPE_LENGTH (eltype2) != TYPE_LENGTH (eltype3)\n-\t      || eltype2->is_unsigned () != eltype3->is_unsigned ()\n-\t      || lowb2 != lowb3 || highb2 != highb3)\n-\t    error (_(\"\\\n-Cannot perform operation on vectors with different types\"));\n-\n-\t  /* Throw an error if the sizes of arg1 and arg2/arg3 differ.  */\n-\t  if (lowb1 != lowb2 || lowb1 != lowb3\n-\t      || highb1 != highb2 || highb1 != highb3)\n-\t    error (_(\"\\\n-Cannot perform conditional operation on vectors with different sizes\"));\n-\n-\t  ret = allocate_value (type2);\n-\n-\t  for (i = 0; i < highb1 - lowb1 + 1; i++)\n-\t    {\n-\t      tmp = value_logical_not (value_subscript (arg1, i)) ?\n-\t\t    value_subscript (arg3, i) : value_subscript (arg2, i);\n-\t      memcpy (value_contents_writeable (ret) +\n-\t\t      i * TYPE_LENGTH (eltype2), value_contents_all (tmp),\n-\t\t      TYPE_LENGTH (eltype2));\n-\t    }\n-\n-\t  return ret;\n-\t}\n-      else\n-\t{\n-\t  if (value_logical_not (arg1))\n-\t    {\n-\t      /* Skip the second operand.  */\n-\t      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\n-\t      return evaluate_subexp (nullptr, exp, pos, noside);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Skip the third operand.  */\n-\t      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\t      evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\n-\t      return arg2;\n-\t    }\n-\t}\n-\n-    /* Handle STRUCTOP_STRUCT to allow component access on OpenCL vectors.  */\n-    case STRUCTOP_STRUCT:\n-      {\n-\tint pc = (*pos)++;\n-\tint tem = longest_to_int (exp->elts[pc + 1].longconst);\n-\n-\t(*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\ttype1 = check_typedef (value_type (arg1));\n-\n-\tif (noside == EVAL_SKIP)\n-\t  {\n-\t    return value_from_longest (builtin_type (exp->gdbarch)->\n-\t\t\t\t       builtin_int, 1);\n-\t  }\n-\telse if (type1->code () == TYPE_CODE_ARRAY && type1->is_vector ())\n-\t  {\n-\t    return opencl_component_ref (exp, arg1, &exp->elts[pc + 2].string,\n-\t\t\t\t\t noside);\n-\t  }\n-\telse\n-\t  {\n-\t    struct value *v = value_struct_elt (&arg1, NULL,\n-\t\t\t\t\t\t&exp->elts[pc + 2].string, NULL,\n-\t\t\t\t\t\t\"structure\");\n-\n-\t    if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t      v = value_zero (value_type (v), VALUE_LVAL (v));\n-\t    return v;\n-\t  }\n-      }\n-    default:\n-      break;\n-    }\n-\n-  return evaluate_subexp_c (expect_type, exp, pos, noside);\n-}\n-\n namespace expr\n {\n \n@@ -1119,15 +853,6 @@ Cannot perform conditional operation on vectors with different sizes\"));\n \n } /* namespace expr */\n \n-const struct exp_descriptor exp_descriptor_opencl =\n-{\n-  print_subexp_standard,\n-  operator_length_standard,\n-  operator_check_standard,\n-  dump_subexp_body_standard,\n-  evaluate_subexp_opencl\n-};\n-\n /* Class representing the OpenCL language.  */\n \n class opencl_language : public language_defn\n@@ -1251,11 +976,6 @@ class opencl_language : public language_defn\n \n   /* See language.h.  */\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &exp_descriptor_opencl; }\n-\n-  /* See language.h.  */\n-\n   const struct op_print *opcode_print_table () const override\n   { return c_op_print_tab; }\n };"
    }
  ]
}