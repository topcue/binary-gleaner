{
  "sha": "d2adf9f120dd9ddef67b1d94b24298dfd3410bd1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDJhZGY5ZjEyMGRkOWRkZWY2N2IxZDk0YjI0Mjk4ZGZkMzQxMGJkMQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2018-12-24T21:56:03Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-01-05T15:49:50Z"
    },
    "message": "Remove the exception and cleanup checkers\n\nNow that gdb is transitioning away from cleanups, there is no reason\nto keep the cleanup and exception checker scripts around.  This patch\nremoves them.\n\ngdb/ChangeLog\n2019-01-05  Tom Tromey  <tom@tromey.com>\n\n\t* contrib/cleanup_check.py: Remove.\n\t* contrib/gcc-with-excheck: Remove.\n\t* contrib/exsummary.py: Remove.\n\t* contrib/excheck.py: Remove.",
    "tree": {
      "sha": "c53c35845759ad610b404786d4a8a374a3c8a89d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c53c35845759ad610b404786d4a8a374a3c8a89d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d2adf9f120dd9ddef67b1d94b24298dfd3410bd1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d2adf9f120dd9ddef67b1d94b24298dfd3410bd1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d2adf9f120dd9ddef67b1d94b24298dfd3410bd1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d2adf9f120dd9ddef67b1d94b24298dfd3410bd1/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f87673e04f4ec54301151f74237329df14133569",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f87673e04f4ec54301151f74237329df14133569",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f87673e04f4ec54301151f74237329df14133569"
    }
  ],
  "stats": {
    "total": 881,
    "additions": 7,
    "deletions": 874
  },
  "files": [
    {
      "sha": "4b60367ffb031095f254bd14484ef1683f3bca94",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d2adf9f120dd9ddef67b1d94b24298dfd3410bd1/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d2adf9f120dd9ddef67b1d94b24298dfd3410bd1/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d2adf9f120dd9ddef67b1d94b24298dfd3410bd1",
      "patch": "@@ -1,3 +1,10 @@\n+2019-01-05  Tom Tromey  <tom@tromey.com>\n+\n+\t* contrib/cleanup_check.py: Remove.\n+\t* contrib/gcc-with-excheck: Remove.\n+\t* contrib/exsummary.py: Remove.\n+\t* contrib/excheck.py: Remove.\n+\n 2019-01-05  Joel Brobecker  <brobecker@adacore.com>\n \n \t* thread.c (delete_thread_1): Add gdb_assert that THR is not"
    },
    {
      "sha": "be6babbe94767b9a3c5fb876ceb9decfcb7a61b5",
      "filename": "gdb/contrib/cleanup_check.py",
      "status": "removed",
      "additions": 0,
      "deletions": 335,
      "changes": 335,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f87673e04f4ec54301151f74237329df14133569/gdb/contrib/cleanup_check.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f87673e04f4ec54301151f74237329df14133569/gdb/contrib/cleanup_check.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/contrib/cleanup_check.py?ref=f87673e04f4ec54301151f74237329df14133569",
      "patch": "@@ -1,335 +0,0 @@\n-#   Copyright 2013-2019 Free Software Foundation, Inc.\n-#\n-#   This is free software: you can redistribute it and/or modify it\n-#   under the terms of the GNU General Public License as published by\n-#   the Free Software Foundation, either version 3 of the License, or\n-#   (at your option) any later version.\n-#\n-#   This program is distributed in the hope that it will be useful, but\n-#   WITHOUT ANY WARRANTY; without even the implied warranty of\n-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-#   General Public License for more details.\n-#\n-#   You should have received a copy of the GNU General Public License\n-#   along with this program.  If not, see\n-#   <http://www.gnu.org/licenses/>.\n-\n-import gcc\n-import gccutils\n-import sys\n-\n-want_raii_info = False\n-\n-logging = False\n-show_cfg = False\n-\n-def log(msg, indent=0):\n-    global logging\n-    if logging:\n-        sys.stderr.write('%s%s\\n' % ('  ' * indent, msg))\n-        sys.stderr.flush()\n-\n-def is_cleanup_type(return_type):\n-    if not isinstance(return_type, gcc.PointerType):\n-        return False\n-    if not isinstance(return_type.dereference, gcc.RecordType):\n-        return False\n-    if str(return_type.dereference.name) == 'cleanup':\n-        return True\n-    return False\n-\n-def is_constructor(decl):\n-    \"Return True if the function DECL is a cleanup constructor; False otherwise\"\n-    return is_cleanup_type(decl.type.type) and (not decl.name or str(decl.name) != 'make_final_cleanup')\n-\n-destructor_names = set(['do_cleanups', 'discard_cleanups'])\n-\n-def is_destructor(decl):\n-    return decl.name in destructor_names\n-\n-# This list is just much too long... we should probably have an\n-# attribute instead.\n-special_names = set(['do_final_cleanups', 'discard_final_cleanups',\n-                     'save_cleanups', 'save_final_cleanups',\n-                     'restore_cleanups', 'restore_final_cleanups',\n-                     'exceptions_state_mc_init',\n-                     'make_my_cleanup2', 'make_final_cleanup', 'all_cleanups',\n-                     'save_my_cleanups', 'quit_target'])\n-\n-def needs_special_treatment(decl):\n-    return decl.name in special_names\n-\n-# Sometimes we need a new placeholder object that isn't the same as\n-# anything else.\n-class Dummy(object):\n-    def __init__(self, location):\n-        self.location = location\n-\n-# A wrapper for a cleanup which has been assigned to a variable.\n-# This holds the variable and the location.\n-class Cleanup(object):\n-    def __init__(self, var, location):\n-        self.var = var\n-        self.location = location\n-\n-# A class representing a master cleanup.  This holds a stack of\n-# cleanup objects and supports a merging operation.\n-class MasterCleanup(object):\n-    # Create a new MasterCleanup object.  OTHER, if given, is a\n-    # MasterCleanup object to copy.\n-    def __init__(self, other = None):\n-        # 'cleanups' is a list of cleanups.  Each element is either a\n-        # Dummy, for an anonymous cleanup, or a Cleanup, for a cleanup\n-        # which was assigned to a variable.\n-        if other is None:\n-            self.cleanups = []\n-            self.aliases = {}\n-        else:\n-            self.cleanups = other.cleanups[:]\n-            self.aliases = dict(other.aliases)\n-\n-    def compare_vars(self, definition, argument):\n-        if definition == argument:\n-            return True\n-        if argument in self.aliases:\n-            argument = self.aliases[argument]\n-        if definition in self.aliases:\n-            definition = self.aliases[definition]\n-        return definition == argument\n-\n-    def note_assignment(self, lhs, rhs):\n-        log('noting assignment %s = %s' % (lhs, rhs), 4)\n-        self.aliases[lhs] = rhs\n-\n-    # Merge with another MasterCleanup.\n-    # Returns True if this resulted in a change to our state.\n-    def merge(self, other):\n-        # We do explicit iteration like this so we can easily\n-        # update the list after the loop.\n-        counter = -1\n-        found_named = False\n-        for counter in range(len(self.cleanups) - 1, -1, -1):\n-            var = self.cleanups[counter]\n-            log('merge checking %s' % var, 4)\n-            # Only interested in named cleanups.\n-            if isinstance(var, Dummy):\n-                log('=> merge dummy', 5)\n-                continue\n-            # Now see if VAR is found in OTHER.\n-            if other._find_var(var.var) >= 0:\n-                log ('=> merge found', 5)\n-                break\n-            log('=>merge not found', 5)\n-            found_named = True\n-        if found_named and counter < len(self.cleanups) - 1:\n-            log ('merging to %d' % counter, 4)\n-            if counter < 0:\n-                self.cleanups = []\n-            else:\n-                self.cleanups = self.cleanups[0:counter]\n-            return True\n-        # If SELF is empty but OTHER has some cleanups, then consider\n-        # that a change as well.\n-        if len(self.cleanups) == 0 and len(other.cleanups) > 0:\n-            log('merging non-empty other', 4)\n-            self.cleanups = other.cleanups[:]\n-            return True\n-        return False\n-\n-    # Push a new constructor onto our stack.  LHS is the\n-    # left-hand-side of the GimpleCall statement.  It may be None,\n-    # meaning that this constructor's value wasn't used.\n-    def push(self, location, lhs):\n-        if lhs is None:\n-            obj = Dummy(location)\n-        else:\n-            obj = Cleanup(lhs, location)\n-        log('pushing %s' % lhs, 4)\n-        idx = self._find_var(lhs)\n-        if idx >= 0:\n-            gcc.permerror(location, 'reassigning to known cleanup')\n-            gcc.inform(self.cleanups[idx].location,\n-                       'previous assignment is here')\n-        self.cleanups.append(obj)\n-\n-    # A helper for merge and pop that finds BACK_TO in self.cleanups,\n-    # and returns the index, or -1 if not found.\n-    def _find_var(self, back_to):\n-        for i in range(len(self.cleanups) - 1, -1, -1):\n-            if isinstance(self.cleanups[i], Dummy):\n-                continue\n-            if self.compare_vars(self.cleanups[i].var, back_to):\n-                return i\n-        return -1\n-\n-    # Pop constructors until we find one matching BACK_TO.\n-    # This is invoked when we see a do_cleanups call.\n-    def pop(self, location, back_to):\n-        log('pop:', 4)\n-        i = self._find_var(back_to)\n-        if i >= 0:\n-            self.cleanups = self.cleanups[0:i]\n-        else:\n-            gcc.permerror(location, 'destructor call with unknown argument')\n-\n-    # Check whether ARG is the current master cleanup.  Return True if\n-    # all is well.\n-    def verify(self, location, arg):\n-        log('verify %s' % arg, 4)\n-        return (len(self.cleanups) > 0\n-                and not isinstance(self.cleanups[0], Dummy)\n-                and self.compare_vars(self.cleanups[0].var, arg))\n-\n-    # Check whether SELF is empty.\n-    def isempty(self):\n-        log('isempty: len = %d' % len(self.cleanups), 4)\n-        return len(self.cleanups) == 0\n-\n-    # Emit informational warnings about the cleanup stack.\n-    def inform(self):\n-        for item in reversed(self.cleanups):\n-            gcc.inform(item.location, 'leaked cleanup')\n-\n-class CleanupChecker:\n-    def __init__(self, fun):\n-        self.fun = fun\n-        self.seen_edges = set()\n-        self.bad_returns = set()\n-\n-        # This maps BB indices to a list of master cleanups for the\n-        # BB.\n-        self.master_cleanups = {}\n-\n-    # Pick a reasonable location for the basic block BB.\n-    def guess_bb_location(self, bb):\n-        if isinstance(bb.gimple, list):\n-            for stmt in bb.gimple:\n-                if stmt.loc:\n-                    return stmt.loc\n-        return self.fun.end\n-\n-    # Compute the master cleanup list for BB.\n-    # Modifies MASTER_CLEANUP in place.\n-    def compute_master(self, bb, bb_from, master_cleanup):\n-        if not isinstance(bb.gimple, list):\n-            return\n-        curloc = self.fun.end\n-        for stmt in bb.gimple:\n-            if stmt.loc:\n-                curloc = stmt.loc\n-            if isinstance(stmt, gcc.GimpleCall) and stmt.fndecl:\n-                if is_constructor(stmt.fndecl):\n-                    log('saw constructor %s in bb=%d' % (str(stmt.fndecl), bb.index), 2)\n-                    self.cleanup_aware = True\n-                    master_cleanup.push(curloc, stmt.lhs)\n-                elif is_destructor(stmt.fndecl):\n-                    if str(stmt.fndecl.name) != 'do_cleanups':\n-                        self.only_do_cleanups_seen = False\n-                    log('saw destructor %s in bb=%d, bb_from=%d, argument=%s'\n-                        % (str(stmt.fndecl.name), bb.index, bb_from, str(stmt.args[0])),\n-                        2)\n-                    master_cleanup.pop(curloc, stmt.args[0])\n-                elif needs_special_treatment(stmt.fndecl):\n-                    pass\n-                    # gcc.permerror(curloc, 'function needs special treatment')\n-            elif isinstance(stmt, gcc.GimpleAssign):\n-                if isinstance(stmt.lhs, gcc.VarDecl) and isinstance(stmt.rhs[0], gcc.VarDecl):\n-                    master_cleanup.note_assignment(stmt.lhs, stmt.rhs[0])\n-            elif isinstance(stmt, gcc.GimpleReturn):\n-                if self.is_constructor:\n-                    if not master_cleanup.verify(curloc, stmt.retval):\n-                        gcc.permerror(curloc,\n-                                      'constructor does not return master cleanup')\n-                elif not self.is_special_constructor:\n-                    if not master_cleanup.isempty():\n-                        if curloc not in self.bad_returns:\n-                            gcc.permerror(curloc, 'cleanup stack is not empty at return')\n-                            self.bad_returns.add(curloc)\n-                            master_cleanup.inform()\n-\n-    # Traverse a basic block, updating the master cleanup information\n-    # and propagating to other blocks.\n-    def traverse_bbs(self, edge, bb, bb_from, entry_master):\n-        log('traverse_bbs %d from %d' % (bb.index, bb_from), 1)\n-\n-        # Propagate the entry MasterCleanup though this block.\n-        master_cleanup = MasterCleanup(entry_master)\n-        self.compute_master(bb, bb_from, master_cleanup)\n-\n-        modified = False\n-        if bb.index in self.master_cleanups:\n-            # Merge the newly-computed MasterCleanup into the one we\n-            # have already computed.  If this resulted in a\n-            # significant change, then we need to re-propagate.\n-            modified = self.master_cleanups[bb.index].merge(master_cleanup)\n-        else:\n-            self.master_cleanups[bb.index] = master_cleanup\n-            modified = True\n-\n-        # EDGE is None for the entry BB.\n-        if edge is not None:\n-            # If merging cleanups caused a change, check to see if we\n-            # have a bad loop.\n-            if edge in self.seen_edges:\n-                # This error doesn't really help.\n-                # if modified:\n-                #     gcc.permerror(self.guess_bb_location(bb),\n-                #                   'invalid cleanup use in loop')\n-                return\n-            self.seen_edges.add(edge)\n-\n-        if not modified:\n-            return\n-\n-        # Now propagate to successor nodes.\n-        for edge in bb.succs:\n-            self.traverse_bbs(edge, edge.dest, bb.index, master_cleanup)\n-\n-    def check_cleanups(self):\n-        if not self.fun.cfg or not self.fun.decl:\n-            return 'ignored'\n-        if is_destructor(self.fun.decl):\n-            return 'destructor'\n-        if needs_special_treatment(self.fun.decl):\n-            return 'special'\n-\n-        self.is_constructor = is_constructor(self.fun.decl)\n-        self.is_special_constructor = not self.is_constructor and str(self.fun.decl.name).find('with_cleanup') > -1\n-        # Yuck.\n-        if str(self.fun.decl.name) == 'gdb_xml_create_parser_and_cleanup_1':\n-            self.is_special_constructor = True\n-\n-        if self.is_special_constructor:\n-            gcc.inform(self.fun.start, 'function %s is a special constructor' % (self.fun.decl.name))\n-\n-        # If we only see do_cleanups calls, and this function is not\n-        # itself a constructor, then we can convert it easily to RAII.\n-        self.only_do_cleanups_seen = not self.is_constructor\n-        # If we ever call a constructor, then we are \"cleanup-aware\".\n-        self.cleanup_aware = False\n-\n-        entry_bb = self.fun.cfg.entry\n-        master_cleanup = MasterCleanup()\n-        self.traverse_bbs(None, entry_bb, -1, master_cleanup)\n-        if want_raii_info and self.only_do_cleanups_seen and self.cleanup_aware:\n-            gcc.inform(self.fun.decl.location,\n-                       'function %s could be converted to RAII' % (self.fun.decl.name))\n-        if self.is_constructor:\n-            return 'constructor'\n-        return 'OK'\n-\n-class CheckerPass(gcc.GimplePass):\n-    def execute(self, fun):\n-        if fun.decl:\n-            log(\"Starting \" + fun.decl.name)\n-            if show_cfg:\n-                dot = gccutils.cfg_to_dot(fun.cfg, fun.decl.name)\n-                gccutils.invoke_dot(dot, name=fun.decl.name)\n-        checker = CleanupChecker(fun)\n-        what = checker.check_cleanups()\n-        if fun.decl:\n-            log(fun.decl.name + ': ' + what, 2)\n-\n-ps = CheckerPass(name = 'check-cleanups')\n-# We need the cfg, but we want a relatively high-level Gimple.\n-ps.register_after('cfg')"
    },
    {
      "sha": "4d53f0581fdccf33e3db2392ff139845ee7272a8",
      "filename": "gdb/contrib/excheck.py",
      "status": "removed",
      "additions": 0,
      "deletions": 296,
      "changes": 296,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f87673e04f4ec54301151f74237329df14133569/gdb/contrib/excheck.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f87673e04f4ec54301151f74237329df14133569/gdb/contrib/excheck.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/contrib/excheck.py?ref=f87673e04f4ec54301151f74237329df14133569",
      "patch": "@@ -1,296 +0,0 @@\n-#   Copyright 2011-2019 Free Software Foundation, Inc.\n-#\n-#   This is free software: you can redistribute it and/or modify it\n-#   under the terms of the GNU General Public License as published by\n-#   the Free Software Foundation, either version 3 of the License, or\n-#   (at your option) any later version.\n-#\n-#   This program is distributed in the hope that it will be useful, but\n-#   WITHOUT ANY WARRANTY; without even the implied warranty of\n-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-#   General Public License for more details.\n-#\n-#   You should have received a copy of the GNU General Public License\n-#   along with this program.  If not, see\n-#   <http://www.gnu.org/licenses/>.\n-\n-# This is a GCC plugin that computes some exception-handling data for\n-# gdb.  This data can then be summarized and checked by the\n-# exsummary.py script.\n-\n-# To use:\n-# * First, install the GCC Python plugin.  See\n-#   https://fedorahosted.org/gcc-python-plugin/\n-# * export PYTHON_PLUGIN=/full/path/to/plugin/directory\n-#   This should be the directory holding \"python.so\".\n-# * cd build/gdb; make mostlyclean\n-# * make CC=.../gcc-with-excheck\n-#   This will write a number of .py files in the build directory.\n-# * python .../exsummary.py\n-#   This will show the violations.\n-\n-import gcc\n-import gccutils\n-import sys\n-\n-# Where our output goes.\n-output_file = None\n-\n-# Cleanup functions require special treatment, because they take a\n-# function argument, but in theory the function must be nothrow.\n-cleanup_functions = {\n-    'make_cleanup': 1,\n-    'make_cleanup_dtor': 1,\n-    'make_final_cleanup': 1,\n-    'make_my_cleanup2': 1,\n-    'make_my_cleanup': 1\n-}\n-\n-# Functions which may throw but which we want to ignore.\n-ignore_functions = {\n-    # This one is super special.\n-    'exceptions_state_mc': 1,\n-    # gdb generally pretends that internal_error cannot throw, even\n-    # though it can.\n-    'internal_error': 1,\n-    # do_cleanups and friends are supposedly nothrow but we don't want\n-    # to run afoul of the indirect function call logic.\n-    'do_cleanups': 1,\n-    'do_final_cleanups': 1\n-}\n-\n-# Functions which take a function argument, but which are not\n-# interesting, usually because the argument is not called in the\n-# current context.\n-non_passthrough_functions = {\n-    'signal': 1,\n-    'add_internal_function': 1\n-}\n-\n-# Return True if the type is from Python.\n-def type_is_pythonic(t):\n-    if isinstance(t, gcc.ArrayType):\n-        t = t.type\n-    if not isinstance(t, gcc.RecordType):\n-        return False\n-    # Hack.\n-    return str(t).find('struct Py') == 0\n-\n-# Examine all the fields of a struct.  We don't currently need any\n-# sort of recursion, so this is simple for now.\n-def examine_struct_fields(initializer):\n-    global output_file\n-    for idx2, value2 in initializer.elements:\n-        if isinstance(idx2, gcc.Declaration):\n-            if isinstance(value2, gcc.AddrExpr):\n-                value2 = value2.operand\n-                if isinstance(value2, gcc.FunctionDecl):\n-                    output_file.write(\"declare_nothrow(%s)\\n\"\n-                                      % repr(str(value2.name)))\n-\n-# Examine all global variables looking for pointers to functions in\n-# structures whose types were defined by Python.\n-def examine_globals():\n-    global output_file\n-    vars = gcc.get_variables()\n-    for var in vars:\n-        if not isinstance(var.decl, gcc.VarDecl):\n-            continue\n-        output_file.write(\"################\\n\")\n-        output_file.write(\"# Analysis for %s\\n\" % var.decl.name)\n-        if not var.decl.initial:\n-            continue\n-        if not type_is_pythonic(var.decl.type):\n-            continue\n-\n-        if isinstance(var.decl.type, gcc.ArrayType):\n-            for idx, value in var.decl.initial.elements:\n-                examine_struct_fields(value)\n-        else:\n-            gccutils.check_isinstance(var.decl.type, gcc.RecordType)\n-            examine_struct_fields(var.decl.initial)\n-\n-# Called at the end of compilation to write out some data derived from\n-# globals and to close the output.\n-def close_output(*args):\n-    global output_file\n-    examine_globals()\n-    output_file.close()\n-\n-# The pass which derives some exception-checking information.  We take\n-# a two-step approach: first we get a call graph from the compiler.\n-# This is emitted by the plugin as Python code.  Then, we run a second\n-# program that reads all the generated Python and uses it to get a\n-# global view of exception routes in gdb.\n-class GdbExceptionChecker(gcc.GimplePass):\n-    def __init__(self, output_file):\n-        gcc.GimplePass.__init__(self, 'gdb_exception_checker')\n-        self.output_file = output_file\n-\n-    def log(self, obj):\n-        self.output_file.write(\"# %s\\n\" % str(obj))\n-\n-    # Return true if FN is a call to a method on a Python object.\n-    # We know these cannot throw in the gdb sense.\n-    def fn_is_python_ignorable(self, fn):\n-        if not isinstance(fn, gcc.SsaName):\n-            return False\n-        stmt = fn.def_stmt\n-        if not isinstance(stmt, gcc.GimpleAssign):\n-            return False\n-        if stmt.exprcode is not gcc.ComponentRef:\n-            return False\n-        rhs = stmt.rhs[0]\n-        if not isinstance(rhs, gcc.ComponentRef):\n-            return False\n-        if not isinstance(rhs.field, gcc.FieldDecl):\n-            return False\n-        return rhs.field.name == 'tp_dealloc' or rhs.field.name == 'tp_free'\n-\n-    # Decode a function call and write something to the output.\n-    # THIS_FUN is the enclosing function that we are processing.\n-    # FNDECL is the call to process; it might not actually be a DECL\n-    # node.\n-    # LOC is the location of the call.\n-    def handle_one_fndecl(self, this_fun, fndecl, loc):\n-        callee_name = ''\n-        if isinstance(fndecl, gcc.AddrExpr):\n-            fndecl = fndecl.operand\n-        if isinstance(fndecl, gcc.FunctionDecl):\n-            # Ordinary call to a named function.\n-            callee_name = str(fndecl.name)\n-            self.output_file.write(\"function_call(%s, %s, %s)\\n\"\n-                                   % (repr(callee_name),\n-                                      repr(this_fun.decl.name),\n-                                      repr(str(loc))))\n-        elif self.fn_is_python_ignorable(fndecl):\n-            # Call to tp_dealloc.\n-            pass\n-        elif (isinstance(fndecl, gcc.SsaName)\n-              and isinstance(fndecl.var, gcc.ParmDecl)):\n-            # We can ignore an indirect call via a parameter to the\n-            # current function, because this is handled via the rule\n-            # for passthrough functions.\n-            pass\n-        else:\n-            # Any other indirect call.\n-            self.output_file.write(\"has_indirect_call(%s, %s)\\n\"\n-                                   % (repr(this_fun.decl.name),\n-                                      repr(str(loc))))\n-        return callee_name\n-\n-    # This does most of the work for examine_one_bb.\n-    # THIS_FUN is the enclosing function.\n-    # BB is the basic block to process.\n-    # Returns True if this block is the header of a TRY_CATCH, False\n-    # otherwise.\n-    def examine_one_bb_inner(self, this_fun, bb):\n-        if not bb.gimple:\n-            return False\n-        try_catch = False\n-        for stmt in bb.gimple:\n-            loc = stmt.loc\n-            if not loc:\n-                loc = this_fun.decl.location\n-            if not isinstance(stmt, gcc.GimpleCall):\n-                continue\n-            callee_name = self.handle_one_fndecl(this_fun, stmt.fn, loc)\n-\n-            if callee_name == 'exceptions_state_mc_action_iter':\n-                try_catch = True\n-\n-            global non_passthrough_functions\n-            if callee_name in non_passthrough_functions:\n-                continue\n-\n-            # We have to specially handle calls where an argument to\n-            # the call is itself a function, e.g., qsort.  In general\n-            # we model these as \"passthrough\" -- we assume that in\n-            # addition to the call the qsort there is also a call to\n-            # the argument function.\n-            for arg in stmt.args:\n-                # We are only interested in arguments which are functions.\n-                t = arg.type\n-                if isinstance(t, gcc.PointerType):\n-                    t = t.dereference\n-                if not isinstance(t, gcc.FunctionType):\n-                    continue\n-\n-                if isinstance(arg, gcc.AddrExpr):\n-                    arg = arg.operand\n-\n-                global cleanup_functions\n-                if callee_name in cleanup_functions:\n-                    if not isinstance(arg, gcc.FunctionDecl):\n-                        gcc.inform(loc, 'cleanup argument not a DECL: %s' % repr(arg))\n-                    else:\n-                        # Cleanups must be nothrow.\n-                        self.output_file.write(\"declare_cleanup(%s)\\n\"\n-                                               % repr(str(arg.name)))\n-                else:\n-                    # Assume we have a passthrough function, like\n-                    # qsort or an iterator.  We model this by\n-                    # pretending there is an ordinary call at this\n-                    # point.\n-                    self.handle_one_fndecl(this_fun, arg, loc)\n-        return try_catch\n-\n-    # Examine all the calls in a basic block and generate output for\n-    # them.\n-    # THIS_FUN is the enclosing function.\n-    # BB is the basic block to examine.\n-    # BB_WORKLIST is a list of basic blocks to work on; we add the\n-    # appropriate successor blocks to this.\n-    # SEEN_BBS is a map whose keys are basic blocks we have already\n-    # processed.  We use this to ensure that we only visit a given\n-    # block once.\n-    def examine_one_bb(self, this_fun, bb, bb_worklist, seen_bbs):\n-        try_catch = self.examine_one_bb_inner(this_fun, bb)\n-        for edge in bb.succs:\n-            if edge.dest in seen_bbs:\n-                continue\n-            seen_bbs[edge.dest] = 1\n-            if try_catch:\n-                # This is bogus, but we magically know the right\n-                # answer.\n-                if edge.false_value:\n-                    bb_worklist.append(edge.dest)\n-            else:\n-                bb_worklist.append(edge.dest)\n-\n-    # Iterate over all basic blocks in THIS_FUN.\n-    def iterate_bbs(self, this_fun):\n-        # Iteration must be in control-flow order, because if we see a\n-        # TRY_CATCH construct we need to drop all the contained blocks.\n-        bb_worklist = [this_fun.cfg.entry]\n-        seen_bbs = {}\n-        seen_bbs[this_fun.cfg.entry] = 1\n-        for bb in bb_worklist:\n-            self.examine_one_bb(this_fun, bb, bb_worklist, seen_bbs)\n-\n-    def execute(self, fun):\n-        if fun and fun.cfg and fun.decl:\n-            self.output_file.write(\"################\\n\")\n-            self.output_file.write(\"# Analysis for %s\\n\" % fun.decl.name)\n-            self.output_file.write(\"define_function(%s, %s)\\n\"\n-                                   % (repr(fun.decl.name),\n-                                      repr(str(fun.decl.location))))\n-\n-            global ignore_functions\n-            if fun.decl.name not in ignore_functions:\n-                self.iterate_bbs(fun)\n-\n-def main(**kwargs):\n-    global output_file\n-    output_file = open(gcc.get_dump_base_name() + '.gdb_exc.py', 'w')\n-    # We used to use attributes here, but there didn't seem to be a\n-    # big benefit over hard-coding.\n-    output_file.write('declare_throw(\"throw_exception\")\\n')\n-    output_file.write('declare_throw(\"throw_verror\")\\n')\n-    output_file.write('declare_throw(\"throw_vfatal\")\\n')\n-    output_file.write('declare_throw(\"throw_error\")\\n')\n-    gcc.register_callback(gcc.PLUGIN_FINISH_UNIT, close_output)\n-    ps = GdbExceptionChecker(output_file)\n-    ps.register_after('ssa')\n-\n-main()"
    },
    {
      "sha": "f3f7c60afbdacc4945b78446062a7a6c01a0a1c9",
      "filename": "gdb/contrib/exsummary.py",
      "status": "removed",
      "additions": 0,
      "deletions": 185,
      "changes": 185,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f87673e04f4ec54301151f74237329df14133569/gdb/contrib/exsummary.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f87673e04f4ec54301151f74237329df14133569/gdb/contrib/exsummary.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/contrib/exsummary.py?ref=f87673e04f4ec54301151f74237329df14133569",
      "patch": "@@ -1,185 +0,0 @@\n-#   Copyright 2011-2019 Free Software Foundation, Inc.\n-#\n-#   This is free software: you can redistribute it and/or modify it\n-#   under the terms of the GNU General Public License as published by\n-#   the Free Software Foundation, either version 3 of the License, or\n-#   (at your option) any later version.\n-#\n-#   This program is distributed in the hope that it will be useful, but\n-#   WITHOUT ANY WARRANTY; without even the implied warranty of\n-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-#   General Public License for more details.\n-#\n-#   You should have received a copy of the GNU General Public License\n-#   along with this program.  If not, see\n-#   <http://www.gnu.org/licenses/>.\n-\n-import sys\n-import glob\n-\n-# Compute the summary information from the files created by\n-# excheck.py.  Run in the build directory where you used the\n-# excheck.py plugin.\n-\n-class Function:\n-    def __init__(self, name):\n-        self.name = name\n-        self.location = None\n-        self.callers = []\n-        self.can_throw = False\n-        self.marked_nothrow = False\n-        self.reason = None\n-\n-    def log(self, message):\n-        print \"%s: note: %s\" % (self.location, message)\n-\n-    def set_location(self, location):\n-        self.location = location\n-\n-    # CALLER is an Edge.\n-    def add_caller(self, caller):\n-        # self.log(\"adding call from %s\" % caller.from_fn.name)\n-        self.callers.append(caller)\n-        # self.log(\"len = %d\" % len(self.callers))\n-\n-    def consistency_check(self):\n-        if self.marked_nothrow and self.can_throw:\n-            print (\"%s: error: %s marked as both 'throw' and 'nothrow'\"\n-                   % (self.location, self.name))\n-\n-    def declare_nothrow(self):\n-        self.marked_nothrow = True\n-        self.consistency_check()\n-\n-    def declare_throw(self):\n-        result = not self.can_throw # Return True the first time\n-        self.can_throw = True\n-        self.consistency_check()\n-        return result\n-\n-    def print_stack(self, is_indirect):\n-        if is_indirect:\n-            print (\"%s: error: function %s is marked nothrow but is assumed to throw due to indirect call\"\n-                   % (self.location, self.name))\n-        else:\n-            print (\"%s: error: function %s is marked nothrow but can throw\"\n-                   % (self.location, self.name))\n-\n-        edge = self.reason\n-        while edge is not None:\n-            print (\"%s: info: via call to %s\"\n-                   % (edge.location, edge.to_fn.name))\n-            edge = edge.to_fn.reason\n-\n-    def mark_throw(self, edge, work_list, is_indirect):\n-        if not self.can_throw:\n-            # self.log(\"can throw\")\n-            self.can_throw = True\n-            self.reason = edge\n-            if self.marked_nothrow:\n-                self.print_stack(is_indirect)\n-            else:\n-                # Do this in the 'else' to avoid extra error\n-                # propagation.\n-                work_list.append(self)\n-\n-class Edge:\n-    def __init__(self, from_fn, to_fn, location):\n-        self.from_fn = from_fn\n-        self.to_fn = to_fn\n-        self.location = location\n-\n-# Work list of known-throwing functions.\n-work_list = []\n-# Map from function name to Function object.\n-function_map = {}\n-# Work list of indirect calls.\n-indirect_functions = []\n-# Whether we should process cleanup functions as well.\n-process_cleanups = False\n-# Whether we should process indirect function calls.\n-process_indirect = False\n-\n-def declare(fn_name):\n-    global function_map\n-    if fn_name not in function_map:\n-        function_map[fn_name] = Function(fn_name)\n-    return function_map[fn_name]\n-\n-def define_function(fn_name, location):\n-    fn = declare(fn_name)\n-    fn.set_location(location)\n-\n-def declare_throw(fn_name):\n-    global work_list\n-    fn = declare(fn_name)\n-    if fn.declare_throw():\n-        work_list.append(fn)\n-\n-def declare_nothrow(fn_name):\n-    fn = declare(fn_name)\n-    fn.declare_nothrow()\n-\n-def declare_cleanup(fn_name):\n-    global process_cleanups\n-    fn = declare(fn_name)\n-    if process_cleanups:\n-        fn.declare_nothrow()\n-\n-def function_call(to, frm, location):\n-    to_fn = declare(to)\n-    frm_fn = declare(frm)\n-    to_fn.add_caller(Edge(frm_fn, to_fn, location))\n-\n-def has_indirect_call(fn_name, location):\n-    global indirect_functions\n-    fn = declare(fn_name)\n-    phony = Function(\"<indirect call>\")\n-    phony.add_caller(Edge(fn, phony, location))\n-    indirect_functions.append(phony)\n-\n-def mark_functions(worklist, is_indirect):\n-    for callee in worklist:\n-        for edge in callee.callers:\n-            edge.from_fn.mark_throw(edge, worklist, is_indirect)\n-\n-def help_and_exit():\n-    print \"Usage: exsummary [OPTION]...\"\n-    print \"\"\n-    print \"Read the .py files from the exception checker plugin and\"\n-    print \"generate an error summary.\"\n-    print \"\"\n-    print \"  --cleanups     Include invalid behavior in cleanups\"\n-    print \"  --indirect     Include assumed errors due to indirect function calls\"\n-    sys.exit(0)\n-\n-def main():\n-    global work_list\n-    global indirect_functions\n-    global process_cleanups\n-    global process_indirect\n-\n-    for arg in sys.argv:\n-        if arg == '--cleanups':\n-            process_cleanups = True\n-        elif arg == '--indirect':\n-            process_indirect = True\n-        elif arg == '--help':\n-            help_and_exit()\n-\n-    for fname in sorted(glob.glob('*.c.gdb_exc.py')):\n-        execfile(fname)\n-    print \"================\"\n-    print \"= Ordinary marking\"\n-    print \"================\"\n-    mark_functions(work_list, False)\n-    if process_indirect:\n-        print \"================\"\n-        print \"= Indirect marking\"\n-        print \"================\"\n-        mark_functions(indirect_functions, True)\n-    return 0\n-\n-if __name__ == '__main__':\n-    status = main()\n-    sys.exit(status)"
    },
    {
      "sha": "c4b0570fa4a644e2f106456a5fedd1a2e2121e00",
      "filename": "gdb/contrib/gcc-with-excheck",
      "status": "removed",
      "additions": 0,
      "deletions": 58,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f87673e04f4ec54301151f74237329df14133569/gdb/contrib/gcc-with-excheck",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f87673e04f4ec54301151f74237329df14133569/gdb/contrib/gcc-with-excheck",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/contrib/gcc-with-excheck?ref=f87673e04f4ec54301151f74237329df14133569",
      "patch": "@@ -1,58 +0,0 @@\n-#!/bin/sh\n-#   Copyright 2011-2019 Free Software Foundation, Inc.\n-#\n-#   This is free software: you can redistribute it and/or modify it\n-#   under the terms of the GNU General Public License as published by\n-#   the Free Software Foundation, either version 3 of the License, or\n-#   (at your option) any later version.\n-#\n-#   This program is distributed in the hope that it will be useful, but\n-#   WITHOUT ANY WARRANTY; without even the implied warranty of\n-#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-#   General Public License for more details.\n-#\n-#   You should have received a copy of the GNU General Public License\n-#   along with this program.  If not, see\n-#   <http://www.gnu.org/licenses/>.\n-\n-# You must set PYTHON_PLUGIN in the environment.\n-# It should be the directory holding the \"python.so\" file.\n-# Usage: gcc-with-excheck [-Xx|-Xc] [--] ARGS\n-# -Xx means to invoke the exception checker.\n-# -Xc means to invoke the cleanup checker.\n-# -- means stop processing -X options.\n-# ARGS are passed to gcc.\n-\n-GCC=${GCC:-gcc}\n-exdir=`dirname $0`\n-\n-pargs=\n-while true; do\n-    case \"$1\" in\n-\t-Xc)\n-\t    pargs=\"$pargs -fplugin-arg-python-script=$exdir/cleanup_check.py\"\n-\t    ;;\n-\t-Xx)\n-\t    pargs=\"$pargs -fplugin-arg-python-script=$exdir/excheck.py\"\n-\t    ;;\n-\t-X*)\n-\t    echo \"unrecognized argument $1\" 1>&2\n-\t    exit 1\n-\t    ;;\n-\t--)\n-\t    shift\n-\t    break\n-\t    ;;\n-\t*)\n-\t    break\n-\t    ;;\n-    esac\n-    shift\n-done\n-\n-# Recent versions of the Python plugin build two .so files in\n-# different directories, so we have to set this.  This will be fixed\n-# upstream at some point.\n-export LD_LIBRARY_PATH=$PYTHON_PLUGIN:$PYTHON_PLUGIN/gcc-c-api\n-\n-gcc -fplugin=$PYTHON_PLUGIN/python.so $pargs \"$@\""
    }
  ]
}