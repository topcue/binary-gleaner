{
  "sha": "7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2UxMGFiZDE0NmRiZDE3ZGMxYjRlOTcwMTIxMGU1NzI0ZGYyYjJiMA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-10-29T21:04:33Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-10-29T21:04:36Z"
    },
    "message": "Remove the exec_bfd macro\n\nThis removes the exec_bfd macro, in favor of new accessors on\nprogram_space.  In one spot the accessor can't be used; but this is\nstill a big improvement over the macro, IMO.\n\ngdb/ChangeLog\n2020-10-29  Tom Tromey  <tom@tromey.com>\n\n\t* windows-tdep.c (windows_solib_create_inferior_hook): Update.\n\t* symfile.c (reread_symbols): Update.\n\t* symfile-mem.c (add_symbol_file_from_memory_command)\n\t(add_vsyscall_page): Update.\n\t* source-cache.c (source_cache::get_plain_source_lines): Update.\n\t* solib-svr4.c (find_program_interpreter, elf_locate_base)\n\t(svr4_current_sos_direct, svr4_exec_displacement)\n\t(svr4_relocate_main_executable): Update.\n\t(svr4_iterate_over_objfiles_in_search_order): Update.\n\t* solib-frv.c (enable_break2, enable_break): Update.\n\t* solib-dsbt.c (lm_base, enable_break): Update.\n\t* solib-darwin.c (find_program_interpreter)\n\t(darwin_solib_create_inferior_hook): Update.\n\t* sol-thread.c (rw_common, ps_pdmodel): Update.\n\t* rs6000-nat.c (rs6000_nat_target::create_inferior): Update.\n\t* remote.c (compare_sections_command)\n\t(remote_target::trace_set_readonly_regions): Update.\n\t* remote-sim.c (get_sim_inferior_data)\n\t(gdbsim_target::create_inferior, gdbsim_target::create_inferior): Update.\n\t(gdbsim_target_open, gdbsim_target::files_info): Update.\n\t* exec.h (exec_bfd): Remove macro.\n\t* progspace.c (initialize_progspace): Update.\n\t* proc-service.c (ps_addr_to_core_addr, core_addr_to_ps_addr):\n\tUpdate.\n\t* nto-procfs.c (nto_procfs_target::post_attach)\n\t(nto_procfs_target::create_inferior): Update.\n\t* maint.c (maintenance_info_sections): Update.\n\t* linux-thread-db.c (thread_db_target::get_thread_local_address):\n\tUpdate.\n\t* infcmd.c (post_create_inferior): Update.\n\t* gcore.c (default_gcore_arch, default_gcore_target): Update.\n\t(objfile_find_memory_regions): Update.\n\t* exec.c (validate_exec_file, exec_file_attach)\n\t(exec_read_partial_read_only, print_section_info): Update.\n\t* corelow.c (core_target_open): Update.\n\t* corefile.c (reopen_exec_file, validate_files): Update.\n\t* arm-tdep.c (gdb_print_insn_arm): Update.\n\t* arch-utils.c (gdbarch_update_p, default_print_insn): Update.\n\t* progspace.h (struct program_space) <exec_bfd, set_exec_bfd>: New\n\tmethods.",
    "tree": {
      "sha": "5926969f2b04c133c37f91cb35764598e0ce8912",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5926969f2b04c133c37f91cb35764598e0ce8912"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b55221abba07302964f697db7eb996ff33b26f5a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b55221abba07302964f697db7eb996ff33b26f5a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b55221abba07302964f697db7eb996ff33b26f5a"
    }
  ],
  "stats": {
    "total": 338,
    "additions": 218,
    "deletions": 120
  },
  "files": [
    {
      "sha": "028329e7988aef61c8bbbadbd6d6ea1c8a50ee4b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 43,
      "deletions": 0,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -1,3 +1,46 @@\n+2020-10-29  Tom Tromey  <tom@tromey.com>\n+\n+\t* windows-tdep.c (windows_solib_create_inferior_hook): Update.\n+\t* symfile.c (reread_symbols): Update.\n+\t* symfile-mem.c (add_symbol_file_from_memory_command)\n+\t(add_vsyscall_page): Update.\n+\t* source-cache.c (source_cache::get_plain_source_lines): Update.\n+\t* solib-svr4.c (find_program_interpreter, elf_locate_base)\n+\t(svr4_current_sos_direct, svr4_exec_displacement)\n+\t(svr4_relocate_main_executable): Update.\n+\t(svr4_iterate_over_objfiles_in_search_order): Update.\n+\t* solib-frv.c (enable_break2, enable_break): Update.\n+\t* solib-dsbt.c (lm_base, enable_break): Update.\n+\t* solib-darwin.c (find_program_interpreter)\n+\t(darwin_solib_create_inferior_hook): Update.\n+\t* sol-thread.c (rw_common, ps_pdmodel): Update.\n+\t* rs6000-nat.c (rs6000_nat_target::create_inferior): Update.\n+\t* remote.c (compare_sections_command)\n+\t(remote_target::trace_set_readonly_regions): Update.\n+\t* remote-sim.c (get_sim_inferior_data)\n+\t(gdbsim_target::create_inferior, gdbsim_target::create_inferior): Update.\n+\t(gdbsim_target_open, gdbsim_target::files_info): Update.\n+\t* exec.h (exec_bfd): Remove macro.\n+\t* progspace.c (initialize_progspace): Update.\n+\t* proc-service.c (ps_addr_to_core_addr, core_addr_to_ps_addr):\n+\tUpdate.\n+\t* nto-procfs.c (nto_procfs_target::post_attach)\n+\t(nto_procfs_target::create_inferior): Update.\n+\t* maint.c (maintenance_info_sections): Update.\n+\t* linux-thread-db.c (thread_db_target::get_thread_local_address):\n+\tUpdate.\n+\t* infcmd.c (post_create_inferior): Update.\n+\t* gcore.c (default_gcore_arch, default_gcore_target): Update.\n+\t(objfile_find_memory_regions): Update.\n+\t* exec.c (validate_exec_file, exec_file_attach)\n+\t(exec_read_partial_read_only, print_section_info): Update.\n+\t* corelow.c (core_target_open): Update.\n+\t* corefile.c (reopen_exec_file, validate_files): Update.\n+\t* arm-tdep.c (gdb_print_insn_arm): Update.\n+\t* arch-utils.c (gdbarch_update_p, default_print_insn): Update.\n+\t* progspace.h (struct program_space) <exec_bfd, set_exec_bfd>: New\n+\tmethods.\n+\n 2020-10-29  Tom Tromey  <tom@tromey.com>\n \n \t* progspace.h (current_target_sections): Remove macro."
    },
    {
      "sha": "1f66e0384a0b25901b84ba899ea45a2c48ca933f",
      "filename": "gdb/arch-utils.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/arch-utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/arch-utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arch-utils.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -527,7 +527,7 @@ gdbarch_update_p (struct gdbarch_info info)\n \n   /* Check for the current file.  */\n   if (info.abfd == NULL)\n-    info.abfd = exec_bfd;\n+    info.abfd = current_program_space->exec_bfd ();\n   if (info.abfd == NULL)\n     info.abfd = core_bfd;\n \n@@ -989,7 +989,7 @@ default_print_insn (bfd_vma memaddr, disassemble_info *info)\n   disassembler_ftype disassemble_fn;\n \n   disassemble_fn = disassembler (info->arch, info->endian == BFD_ENDIAN_BIG,\n-\t\t\t\t info->mach, exec_bfd);\n+\t\t\t\t info->mach, current_program_space->exec_bfd ());\n \n   gdb_assert (disassemble_fn != NULL);\n   return (*disassemble_fn) (memaddr, info);"
    },
    {
      "sha": "c007a3865c6d68841a69c88d2cc24c73e4790f9a",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -7756,9 +7756,10 @@ gdb_print_insn_arm (bfd_vma memaddr, disassemble_info *info)\n   /* GDB is able to get bfd_mach from the exe_bfd, info->mach is\n      accurate, so mark USER_SPECIFIED_MACHINE_TYPE bit.  Otherwise,\n      opcodes/arm-dis.c:print_insn reset info->mach, and it will trigger\n-     the assert on the mismatch of info->mach and bfd_get_mach (exec_bfd)\n-     in default_print_insn.  */\n-  if (exec_bfd != NULL)\n+     the assert on the mismatch of info->mach and\n+     bfd_get_mach (current_program_space->exec_bfd ()) in\n+     default_print_insn.  */\n+  if (current_program_space->exec_bfd () != NULL)\n     info->flags |= USER_SPECIFIED_MACHINE_TYPE;\n \n   return default_print_insn (memaddr, info);"
    },
    {
      "sha": "78abbd0716ee61574d0a2fa61fdc7c020c2a5134",
      "filename": "gdb/corefile.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/corefile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/corefile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corefile.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -108,11 +108,11 @@ reopen_exec_file (void)\n   struct stat st;\n \n   /* Don't do anything if there isn't an exec file.  */\n-  if (exec_bfd == NULL)\n+  if (current_program_space->exec_bfd () == NULL)\n     return;\n \n   /* If the timestamp of the exec file has changed, reopen it.  */\n-  std::string filename = bfd_get_filename (exec_bfd);\n+  std::string filename = bfd_get_filename (current_program_space->exec_bfd ());\n   res = stat (filename.c_str (), &st);\n \n   if (res == 0\n@@ -132,11 +132,13 @@ reopen_exec_file (void)\n void\n validate_files (void)\n {\n-  if (exec_bfd && core_bfd)\n+  if (current_program_space->exec_bfd () && core_bfd)\n     {\n-      if (!core_file_matches_executable_p (core_bfd, exec_bfd))\n+      if (!core_file_matches_executable_p (core_bfd,\n+\t\t\t\t\t   current_program_space->exec_bfd ()))\n \twarning (_(\"core file may not match specified executable file.\"));\n-      else if (bfd_get_mtime (exec_bfd) > bfd_get_mtime (core_bfd))\n+      else if (bfd_get_mtime (current_program_space->exec_bfd ())\n+\t       > bfd_get_mtime (core_bfd))\n \twarning (_(\"exec file is newer than core file.\"));\n     }\n }"
    },
    {
      "sha": "e284efcac71819af20e33fcb6664dea1797ff4d3",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -454,7 +454,7 @@ core_target_open (const char *arg, int from_tty)\n      core file.  We don't do this unconditionally since an exec file\n      typically contains more information that helps us determine the\n      architecture than a core file.  */\n-  if (!exec_bfd)\n+  if (!current_program_space->exec_bfd ())\n     set_gdbarch_from_file (core_bfd);\n \n   push_target (std::move (target_holder));\n@@ -495,7 +495,7 @@ core_target_open (const char *arg, int from_tty)\n       switch_to_thread (thread);\n     }\n \n-  if (exec_bfd == nullptr)\n+  if (current_program_space->exec_bfd () == nullptr)\n     locate_exec_from_corefile_build_id (core_bfd, from_tty);\n \n   post_create_inferior (from_tty);"
    },
    {
      "sha": "2c93391791f157865799753ac3f30b715e426c4c",
      "filename": "gdb/exec.c",
      "status": "modified",
      "additions": 24,
      "deletions": 17,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -240,7 +240,8 @@ validate_exec_file (int from_tty)\n   reopen_exec_file ();\n   current_exec_file = get_exec_file (0);\n \n-  const bfd_build_id *exec_file_build_id = build_id_bfd_get (exec_bfd);\n+  const bfd_build_id *exec_file_build_id\n+    = build_id_bfd_get (current_program_space->exec_bfd ());\n   if (exec_file_build_id != nullptr)\n     {\n       /* Prepend the target prefix, to force gdb_bfd_open to open the\n@@ -367,10 +368,11 @@ exec_file_locate_attach (int pid, int defer_bp_reset, int from_tty)\n void\n exec_file_attach (const char *filename, int from_tty)\n {\n-  /* First, acquire a reference to the current exec_bfd.  We release\n+  /* First, acquire a reference to the exec_bfd.  We release\n      this at the end of the function; but acquiring it now lets the\n      BFD cache return it if this call refers to the same file.  */\n-  gdb_bfd_ref_ptr exec_bfd_holder = gdb_bfd_ref_ptr::new_reference (exec_bfd);\n+  gdb_bfd_ref_ptr exec_bfd_holder\n+    = gdb_bfd_ref_ptr::new_reference (current_program_space->exec_bfd ());\n \n   /* Remove any previous exec file.  */\n   current_program_space->exec_close ();\n@@ -451,9 +453,9 @@ exec_file_attach (const char *filename, int from_tty)\n \t\t\t      FOPEN_RUB, scratch_chan);\n       else\n \ttemp = gdb_bfd_open (canonical_pathname, gnutarget, scratch_chan);\n-      exec_bfd = temp.release ();\n+      current_program_space->set_exec_bfd (temp.release ());\n \n-      if (!exec_bfd)\n+      if (!current_program_space->exec_bfd ())\n \t{\n \t  error (_(\"\\\"%ps\\\": could not open as an executable file: %s.\"),\n \t\t styled_string (file_name_style.style (), scratch_pathname),\n@@ -465,12 +467,14 @@ exec_file_attach (const char *filename, int from_tty)\n       gdb_assert (current_program_space->exec_filename == nullptr);\n       if (load_via_target)\n \tcurrent_program_space->exec_filename\n-\t  = make_unique_xstrdup (bfd_get_filename (exec_bfd));\n+\t  = (make_unique_xstrdup\n+\t     (bfd_get_filename (current_program_space->exec_bfd ())));\n       else\n \tcurrent_program_space->exec_filename\n \t  = gdb_realpath_keepfile (scratch_pathname);\n \n-      if (!bfd_check_format_matches (exec_bfd, bfd_object, &matching))\n+      if (!bfd_check_format_matches (current_program_space->exec_bfd (),\n+\t\t\t\t     bfd_object, &matching))\n \t{\n \t  /* Make sure to close exec_bfd, or else \"run\" might try to use\n \t     it.  */\n@@ -480,18 +484,20 @@ exec_file_attach (const char *filename, int from_tty)\n \t\t gdb_bfd_errmsg (bfd_get_error (), matching).c_str ());\n \t}\n \n-      target_section_table sections = build_section_table (exec_bfd);\n+\t  target_section_table sections\n+\t  = build_section_table (current_program_space->exec_bfd ());\n \n-      current_program_space->ebfd_mtime = bfd_get_mtime (exec_bfd);\n+      current_program_space->ebfd_mtime\n+\t= bfd_get_mtime (current_program_space->exec_bfd ());\n \n       validate_files ();\n \n-      set_gdbarch_from_file (exec_bfd);\n+      set_gdbarch_from_file (current_program_space->exec_bfd ());\n \n       /* Add the executable's sections to the current address spaces'\n \t list of sections.  This possibly pushes the exec_ops\n \t target.  */\n-      add_target_sections (&exec_bfd, sections);\n+      add_target_sections (&current_program_space->ebfd, sections);\n \n       /* Tell display code (if any) about the changed file name.  */\n       if (deprecated_exec_file_display_hook)\n@@ -701,13 +707,13 @@ exec_read_partial_read_only (gdb_byte *readbuf, ULONGEST offset,\n   /* It's unduly pedantic to refuse to look at the executable for\n      read-only pieces; so do the equivalent of readonly regions aka\n      QTro packet.  */\n-  if (exec_bfd != NULL)\n+  if (current_program_space->exec_bfd () != NULL)\n     {\n       asection *s;\n       bfd_size_type size;\n       bfd_vma vma;\n \n-      for (s = exec_bfd->sections; s; s = s->next)\n+      for (s = current_program_space->exec_bfd ()->sections; s; s = s->next)\n \t{\n \t  if ((s->flags & SEC_LOAD) == 0\n \t      || (s->flags & SEC_READONLY) == 0)\n@@ -723,7 +729,7 @@ exec_read_partial_read_only (gdb_byte *readbuf, ULONGEST offset,\n \t      if (amt > len)\n \t\tamt = len;\n \n-\t      amt = bfd_get_section_contents (exec_bfd, s,\n+\t      amt = bfd_get_section_contents (current_program_space->exec_bfd (), s,\n \t\t\t\t\t      readbuf, offset - vma, amt);\n \n \t      if (amt == 0)\n@@ -925,7 +931,7 @@ print_section_info (target_section_table *t, bfd *abfd)\n \t\t\t\t  bfd_get_filename (abfd)));\n   wrap_here (\"        \");\n   printf_filtered (_(\"file type %s.\\n\"), bfd_get_target (abfd));\n-  if (abfd == exec_bfd)\n+  if (abfd == current_program_space->exec_bfd ())\n     {\n       /* gcc-3.4 does not like the initialization in\n \t <p == t->sections_end>.  */\n@@ -990,8 +996,9 @@ print_section_info (target_section_table *t, bfd *abfd)\n void\n exec_target::files_info ()\n {\n-  if (exec_bfd)\n-    print_section_info (&current_program_space->target_sections, exec_bfd);\n+  if (current_program_space->exec_bfd ())\n+    print_section_info (&current_program_space->target_sections,\n+\t\t\tcurrent_program_space->exec_bfd ());\n   else\n     puts_filtered (_(\"\\t<no file loaded>\\n\"));\n }"
    },
    {
      "sha": "8590e78710ac50efb2f6c509af490a15631ecde9",
      "filename": "gdb/exec.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/exec.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/exec.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.h?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -30,8 +30,6 @@ struct target_ops;\n struct bfd;\n struct objfile;\n \n-#define exec_bfd current_program_space->ebfd\n-\n /* Builds a section table, given args BFD.  */\n \n extern target_section_table build_section_table (struct bfd *);"
    },
    {
      "sha": "b97a54acb3f1cb642bb8ca78372d222419081cc8",
      "filename": "gdb/gcore.c",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/gcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/gcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gcore.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -171,10 +171,10 @@ default_gcore_arch (void)\n \n   if (bfdarch != NULL)\n     return bfdarch->arch;\n-  if (exec_bfd == NULL)\n+  if (current_program_space->exec_bfd () == NULL)\n     error (_(\"Can't find bfd architecture for corefile (need execfile).\"));\n \n-  return bfd_get_arch (exec_bfd);\n+  return bfd_get_arch (current_program_space->exec_bfd ());\n }\n \n static const char *\n@@ -184,12 +184,12 @@ default_gcore_target (void)\n   if (gdbarch_gcore_bfd_target_p (target_gdbarch ()))\n     return gdbarch_gcore_bfd_target (target_gdbarch ());\n \n-  /* Otherwise, try to fall back to the exec_bfd target.  This will probably\n+  /* Otherwise, try to fall back to the exec target.  This will probably\n      not work for non-ELF targets.  */\n-  if (exec_bfd == NULL)\n+  if (current_program_space->exec_bfd () == NULL)\n     return NULL;\n   else\n-    return bfd_get_target (exec_bfd);\n+    return bfd_get_target (current_program_space->exec_bfd ());\n }\n \n /* Derive a reasonable stack segment by unwinding the target stack,\n@@ -500,7 +500,8 @@ objfile_find_memory_regions (struct target_ops *self,\n \t     obfd);\n \n   /* Make a heap segment.  */\n-  if (derive_heap_segment (exec_bfd, &temp_bottom, &temp_top))\n+  if (derive_heap_segment (current_program_space->exec_bfd (), &temp_bottom,\n+\t\t\t   &temp_top))\n     (*func) (temp_bottom, temp_top - temp_bottom,\n \t     1, /* Heap section will be readable.  */\n \t     1, /* Heap section will be writable.  */"
    },
    {
      "sha": "118049041cfe68860704ed55cc1217bb811f41ee",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -308,7 +308,7 @@ post_create_inferior (int from_tty)\n \tthrow;\n     }\n \n-  if (exec_bfd)\n+  if (current_program_space->exec_bfd ())\n     {\n       const unsigned solib_add_generation\n \t= current_program_space->solib_add_generation;"
    },
    {
      "sha": "0af813ff1098b05224fa3c559565f90d173d396a",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -1800,8 +1800,8 @@ thread_db_target::get_thread_local_address (ptid_t ptid,\n \n       /* Cast assuming host == target.  Joy.  */\n       /* Do proper sign extension for the target.  */\n-      gdb_assert (exec_bfd);\n-      return (bfd_get_sign_extend_vma (exec_bfd) > 0\n+      gdb_assert (current_program_space->exec_bfd ());\n+      return (bfd_get_sign_extend_vma (current_program_space->exec_bfd ()) > 0\n \t      ? (CORE_ADDR) (intptr_t) address\n \t      : (CORE_ADDR) (uintptr_t) address);\n     }"
    },
    {
      "sha": "e8cdda3da0efff21627474698ad0ee4defb760d0",
      "filename": "gdb/maint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/maint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/maint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/maint.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -380,14 +380,16 @@ print_bfd_section_info_maybe_relocated (bfd *abfd, asection *asect,\n static void\n maintenance_info_sections (const char *arg, int from_tty)\n {\n-  if (exec_bfd)\n+  if (current_program_space->exec_bfd ())\n     {\n       bool allobj = false;\n \n       printf_filtered (_(\"Exec file:\\n\"));\n-      printf_filtered (\"    `%s', \", bfd_get_filename (exec_bfd));\n+      printf_filtered (\"    `%s', \",\n+\t\t       bfd_get_filename (current_program_space->exec_bfd ()));\n       wrap_here (\"        \");\n-      printf_filtered (_(\"file type %s.\\n\"), bfd_get_target (exec_bfd));\n+      printf_filtered (_(\"file type %s.\\n\"),\n+\t\t       bfd_get_target (current_program_space->exec_bfd ()));\n \n       /* Only this function cares about the 'ALLOBJ' argument;\n \t if 'ALLOBJ' is the only argument, discard it rather than\n@@ -404,7 +406,7 @@ maintenance_info_sections (const char *arg, int from_tty)\n \t  if (allobj)\n \t    printf_filtered (_(\"  Object file: %s\\n\"),\n \t\t\t     bfd_get_filename (ofile->obfd));\n-\t  else if (ofile->obfd != exec_bfd)\n+\t  else if (ofile->obfd != current_program_space->exec_bfd ())\n \t    continue;\n \n \t  int section_count = gdb_bfd_count_sections (ofile->obfd);"
    },
    {
      "sha": "5ecf9b52c34754747c414ab5c13879c54bc71e13",
      "filename": "gdb/nto-procfs.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/nto-procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/nto-procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nto-procfs.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -728,7 +728,7 @@ nto_procfs_target::attach (const char *args, int from_tty)\n void\n nto_procfs_target::post_attach (pid_t pid)\n {\n-  if (exec_bfd)\n+  if (current_program_space->exec_bfd ())\n     solib_create_inferior_hook (0);\n }\n \n@@ -1322,7 +1322,7 @@ nto_procfs_target::create_inferior (const char *exec_file,\n     push_target (ops);\n   target_terminal::init ();\n \n-  if (exec_bfd != NULL\n+  if (current_program_space->exec_bfd () != NULL\n       || (symfile_objfile != NULL && symfile_objfile->obfd != NULL))\n     solib_create_inferior_hook (0);\n }"
    },
    {
      "sha": "2025f3a66c5d9cd677d9a12daedf32bc93a36360",
      "filename": "gdb/proc-service.c",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/proc-service.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/proc-service.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/proc-service.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -42,7 +42,8 @@\n static CORE_ADDR\n ps_addr_to_core_addr (psaddr_t addr)\n {\n-  if (exec_bfd && bfd_get_sign_extend_vma (exec_bfd))\n+  if (current_program_space->exec_bfd ()\n+      && bfd_get_sign_extend_vma (current_program_space->exec_bfd ()))\n     return (intptr_t) addr;\n   else\n     return (uintptr_t) addr;\n@@ -53,7 +54,8 @@ ps_addr_to_core_addr (psaddr_t addr)\n static psaddr_t\n core_addr_to_ps_addr (CORE_ADDR addr)\n {\n-  if (exec_bfd && bfd_get_sign_extend_vma (exec_bfd))\n+  if (current_program_space->exec_bfd ()\n+      && bfd_get_sign_extend_vma (current_program_space->exec_bfd ()))\n     return (psaddr_t) (intptr_t) addr;\n   else\n     return (psaddr_t) (uintptr_t) addr;"
    },
    {
      "sha": "57edc298da701477deaf7b77b1f7f0965a1dc656",
      "filename": "gdb/progspace.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/progspace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/progspace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/progspace.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -233,7 +233,7 @@ program_space::exec_close ()\n       gdb_bfd_unref (ebfd);\n \n       /* Removing target sections may close the exec_ops target.\n-\t Clear exec_bfd before doing so to prevent recursion.  */\n+\t Clear ebfd before doing so to prevent recursion.  */\n       ebfd = NULL;\n       ebfd_mtime = 0;\n \n@@ -471,7 +471,7 @@ initialize_progspace (void)\n      _initialize_foo routines may need to install their per-pspace\n      data keys.  We can only allocate a progspace when all those\n      modules have done that.  Do this before\n-     initialize_current_architecture, because that accesses exec_bfd,\n-     which in turn dereferences current_program_space.  */\n+     initialize_current_architecture, because that accesses the ebfd\n+     of current_program_space.  */\n   current_program_space = new program_space (new_address_space ());\n }"
    },
    {
      "sha": "5e49083884a754bd9aaf0a41e73a61e8068cb245",
      "filename": "gdb/progspace.h",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/progspace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/progspace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/progspace.h?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -276,6 +276,18 @@ struct program_space\n      to read memory from, this unpushes the exec_ops target.  */\n   void exec_close ();\n \n+  /* Return the exec BFD for this program space.  */\n+  bfd *exec_bfd () const\n+  {\n+    return ebfd;\n+  }\n+\n+  /* Set the exec BFD for this program space to ABFD.  */\n+  void set_exec_bfd (bfd *abfd)\n+  {\n+    ebfd = abfd;\n+  }\n+\n   /* Unique ID number.  */\n   int num = 0;\n "
    },
    {
      "sha": "d0e19b0e061db5290daa75d8dcca73372e22e984",
      "filename": "gdb/remote-sim.c",
      "status": "modified",
      "additions": 10,
      "deletions": 7,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/remote-sim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/remote-sim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-sim.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -211,7 +211,8 @@ get_sim_inferior_data (struct inferior *inf, int sim_instance_needed)\n   if (sim_instance_needed == SIM_INSTANCE_NEEDED\n       && (sim_data == NULL || sim_data->gdbsim_desc == NULL))\n     {\n-      sim_desc = sim_open (SIM_OPEN_DEBUG, &gdb_callback, exec_bfd, sim_argv);\n+      sim_desc = sim_open (SIM_OPEN_DEBUG, &gdb_callback,\n+\t\t\t   current_program_space->exec_bfd (), sim_argv);\n       if (sim_desc == NULL)\n \terror (_(\"Unable to create simulator instance for inferior %d.\"),\n \t       inf->num);\n@@ -620,7 +621,7 @@ gdbsim_target::create_inferior (const char *exec_file,\n   char *arg_buf;\n   const char *args = allargs.c_str ();\n \n-  if (exec_file == 0 || exec_bfd == 0)\n+  if (exec_file == 0 || current_program_space->exec_bfd () == 0)\n     warning (_(\"No executable file specified.\"));\n   if (!sim_data->program_loaded)\n     warning (_(\"No program loaded.\"));\n@@ -648,7 +649,8 @@ gdbsim_target::create_inferior (const char *exec_file,\n       built_argv.reset (arg_buf);\n     }\n \n-  if (sim_create_inferior (sim_data->gdbsim_desc, exec_bfd,\n+  if (sim_create_inferior (sim_data->gdbsim_desc,\n+\t\t\t   current_program_space->exec_bfd (),\n \t\t\t   built_argv.get (), env)\n       != SIM_RC_OK)\n     error (_(\"Unable to create sim inferior.\"));\n@@ -738,7 +740,8 @@ gdbsim_target_open (const char *args, int from_tty)\n   sim_argv = argv.release ();\n \n   init_callbacks ();\n-  gdbsim_desc = sim_open (SIM_OPEN_DEBUG, &gdb_callback, exec_bfd, sim_argv);\n+  gdbsim_desc = sim_open (SIM_OPEN_DEBUG, &gdb_callback,\n+\t\t\t  current_program_space->exec_bfd (), sim_argv);\n \n   if (gdbsim_desc == 0)\n     {\n@@ -1104,13 +1107,13 @@ gdbsim_target::files_info ()\n     = get_sim_inferior_data (current_inferior (), SIM_INSTANCE_NEEDED);\n   const char *file = \"nothing\";\n \n-  if (exec_bfd)\n-    file = bfd_get_filename (exec_bfd);\n+  if (current_program_space->exec_bfd ())\n+    file = bfd_get_filename (current_program_space->exec_bfd ());\n \n   if (remote_debug)\n     fprintf_unfiltered (gdb_stdlog, \"gdbsim_files_info: file \\\"%s\\\"\\n\", file);\n \n-  if (exec_bfd)\n+  if (current_program_space->exec_bfd ())\n     {\n       fprintf_unfiltered (gdb_stdlog, \"\\tAttached to %s running program %s\\n\",\n \t\t\t  target_shortname, file);"
    },
    {
      "sha": "291b7c6e7e5edb8aee5c9608e3516e069a3d8853",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 7,
      "deletions": 6,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -56,7 +56,7 @@\n #include <signal.h>\n #include \"serial.h\"\n \n-#include \"gdbcore.h\" /* for exec_bfd */\n+#include \"gdbcore.h\"\n \n #include \"remote-fileio.h\"\n #include \"gdb/fileio.h\"\n@@ -10770,7 +10770,7 @@ compare_sections_command (const char *args, int from_tty)\n   int res;\n   int read_only = 0;\n \n-  if (!exec_bfd)\n+  if (!current_program_space->exec_bfd ())\n     error (_(\"command cannot be used without an exec file\"));\n \n   if (args != NULL && strcmp (args, \"-r\") == 0)\n@@ -10779,7 +10779,7 @@ compare_sections_command (const char *args, int from_tty)\n       args = NULL;\n     }\n \n-  for (s = exec_bfd->sections; s; s = s->next)\n+  for (s = current_program_space->exec_bfd ()->sections; s; s = s->next)\n     {\n       if (!(s->flags & SEC_LOAD))\n \tcontinue;\t\t/* Skip non-loadable section.  */\n@@ -10799,7 +10799,8 @@ compare_sections_command (const char *args, int from_tty)\n       lma = s->lma;\n \n       gdb::byte_vector sectdata (size);\n-      bfd_get_section_contents (exec_bfd, s, sectdata.data (), 0, size);\n+      bfd_get_section_contents (current_program_space->exec_bfd (), s,\n+\t\t\t\tsectdata.data (), 0, size);\n \n       res = target_verify_memory (sectdata.data (), lma, size);\n \n@@ -13180,14 +13181,14 @@ remote_target::trace_set_readonly_regions ()\n   int anysecs = 0;\n   int offset = 0;\n \n-  if (!exec_bfd)\n+  if (!current_program_space->exec_bfd ())\n     return;\t\t\t/* No information to give.  */\n \n   struct remote_state *rs = get_remote_state ();\n \n   strcpy (rs->buf.data (), \"QTro\");\n   offset = strlen (rs->buf.data ());\n-  for (s = exec_bfd->sections; s; s = s->next)\n+  for (s = current_program_space->exec_bfd ()->sections; s; s = s->next)\n     {\n       char tmp1[40], tmp2[40];\n       int sec_length;"
    },
    {
      "sha": "82b7eff9574359ecab7d79cb6f00209274c2524b",
      "filename": "gdb/rs6000-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 3,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/rs6000-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/rs6000-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-nat.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -581,11 +581,12 @@ rs6000_nat_target::create_inferior (const char *exec_file,\n      Blindly calling rs6000_gdbarch_init used to work in older versions of\n      GDB, as rs6000_gdbarch_init incorrectly used the previous tdep to\n      determine the wordsize.  */\n-  if (exec_bfd)\n+  if (current_program_space->exec_bfd ())\n     {\n       const struct bfd_arch_info *exec_bfd_arch_info;\n \n-      exec_bfd_arch_info = bfd_get_arch_info (exec_bfd);\n+      exec_bfd_arch_info\n+\t= bfd_get_arch_info (current_program_space->exec_bfd ());\n       if (arch == exec_bfd_arch_info->arch)\n \treturn;\n     }\n@@ -594,7 +595,7 @@ rs6000_nat_target::create_inferior (const char *exec_file,\n \n   gdbarch_info_init (&info);\n   info.bfd_arch_info = bfd_get_arch_info (&abfd);\n-  info.abfd = exec_bfd;\n+  info.abfd = current_program_space->exec_bfd ();\n \n   if (!gdbarch_update_p (info))\n     internal_error (__FILE__, __LINE__,"
    },
    {
      "sha": "69a3ac113948bffbffeecf40a8efa76fce5fe680",
      "filename": "gdb/sol-thread.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/sol-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/sol-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sol-thread.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -794,7 +794,7 @@ rw_common (int dowrite, const struct ps_prochandle *ph, psaddr_t addr,\n #if defined (__sparcv9)\n   /* For Sparc64 cross Sparc32, make sure the address has not been\n      accidentally sign-extended (or whatever) to beyond 32 bits.  */\n-  if (bfd_get_arch_size (exec_bfd) == 32)\n+  if (bfd_get_arch_size (current_program_space->exec_bfd ()) == 32)\n     addr &= 0xffffffff;\n #endif\n \n@@ -950,9 +950,9 @@ ps_lsetfpregs (struct ps_prochandle *ph, lwpid_t lwpid,\n ps_err_e\n ps_pdmodel (struct ps_prochandle *ph, int *data_model)\n {\n-  if (exec_bfd == 0)\n+  if (current_program_space->exec_bfd () == 0)\n     *data_model = PR_MODEL_UNKNOWN;\n-  else if (bfd_get_arch_size (exec_bfd) == 32)\n+  else if (bfd_get_arch_size (current_program_space->exec_bfd ()) == 32)\n     *data_model = PR_MODEL_ILP32;\n   else\n     *data_model = PR_MODEL_LP64;"
    },
    {
      "sha": "e784e5618a0568ab0dafb629315ed6ca769679fe",
      "filename": "gdb/solib-darwin.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/solib-darwin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/solib-darwin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-darwin.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -192,12 +192,13 @@ find_program_interpreter (void)\n {\n   char *buf = NULL;\n \n-  /* If we have an exec_bfd, get the interpreter from the load commands.  */\n-  if (exec_bfd)\n+  /* If we have an current exec_bfd, get the interpreter from the load\n+     commands.  */\n+  if (current_program_space->exec_bfd ())\n     {\n       bfd_mach_o_load_command *cmd;\n \n-      if (bfd_mach_o_lookup_command (exec_bfd,\n+      if (bfd_mach_o_lookup_command (current_program_space->exec_bfd (),\n                                      BFD_MACH_O_LC_LOAD_DYLINKER, &cmd) == 1)\n         return cmd->command.dylinker.name_str;\n     }\n@@ -543,7 +544,7 @@ darwin_solib_create_inferior_hook (int from_tty)\n       CORE_ADDR vmaddr;\n \n       /* Find the base address of the executable.  */\n-      vmaddr = bfd_mach_o_get_base_address (exec_bfd);\n+      vmaddr = bfd_mach_o_get_base_address (current_program_space->exec_bfd ());\n \n       /* Relocate.  */\n       if (vmaddr != load_addr)\n@@ -557,7 +558,8 @@ darwin_solib_create_inferior_hook (int from_tty)\n     {\n       /* Dyld hasn't yet relocated itself, so the notifier address may\n \t be incorrect (as it has to be relocated).  */\n-      CORE_ADDR start = bfd_get_start_address (exec_bfd);\n+      CORE_ADDR start\n+\t= bfd_get_start_address (current_program_space->exec_bfd ());\n       if (start == 0)\n \tnotifier = 0;\n       else"
    },
    {
      "sha": "8e1da5dd73d54822d9983070a34cfb78370262da",
      "filename": "gdb/solib-dsbt.c",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/solib-dsbt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/solib-dsbt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-dsbt.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -562,7 +562,7 @@ lm_base (void)\n \t\t\t    \"lm_base: get addr %x by _GLOBAL_OFFSET_TABLE_.\\n\",\n \t\t\t    (unsigned int) addr);\n     }\n-  else if (scan_dyntag (DT_PLTGOT, exec_bfd, &addr))\n+  else if (scan_dyntag (DT_PLTGOT, current_program_space->exec_bfd (), &addr))\n     {\n       struct int_elf32_dsbt_loadmap *ldm;\n \n@@ -778,7 +778,7 @@ enable_break (void)\n   asection *interp_sect;\n   struct dsbt_info *info;\n \n-  if (exec_bfd == NULL)\n+  if (current_program_space->exec_bfd () == NULL)\n     return 0;\n \n   if (!target_has_execution ())\n@@ -793,7 +793,8 @@ enable_break (void)\n \n   /* Find the .interp section; if not found, warn the user and drop\n      into the old breakpoint at symbol code.  */\n-  interp_sect = bfd_get_section_by_name (exec_bfd, \".interp\");\n+  interp_sect = bfd_get_section_by_name (current_program_space->exec_bfd (),\n+\t\t\t\t\t \".interp\");\n   if (interp_sect)\n     {\n       unsigned int interp_sect_size;\n@@ -806,8 +807,8 @@ enable_break (void)\n \t the contents specify the dynamic linker this program uses.  */\n       interp_sect_size = bfd_section_size (interp_sect);\n       buf = (char *) alloca (interp_sect_size);\n-      bfd_get_section_contents (exec_bfd, interp_sect,\n-\t\t\t\tbuf, 0, interp_sect_size);\n+      bfd_get_section_contents (current_program_space->exec_bfd (),\n+\t\t\t\tinterp_sect, buf, 0, interp_sect_size);\n \n       /* Now we need to figure out where the dynamic linker was\n \t loaded so that we can load its symbols and place a breakpoint"
    },
    {
      "sha": "08c9cf7ca5c97dbba78fdd21e8541400c21c304a",
      "filename": "gdb/solib-frv.c",
      "status": "modified",
      "additions": 6,
      "deletions": 4,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/solib-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/solib-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-frv.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -531,7 +531,8 @@ enable_break2 (void)\n \n   /* Find the .interp section; if not found, warn the user and drop\n      into the old breakpoint at symbol code.  */\n-  interp_sect = bfd_get_section_by_name (exec_bfd, \".interp\");\n+  interp_sect = bfd_get_section_by_name (current_program_space->exec_bfd (),\n+\t\t\t\t\t \".interp\");\n   if (interp_sect)\n     {\n       unsigned int interp_sect_size;\n@@ -545,8 +546,8 @@ enable_break2 (void)\n          the contents specify the dynamic linker this program uses.  */\n       interp_sect_size = bfd_section_size (interp_sect);\n       buf = (char *) alloca (interp_sect_size);\n-      bfd_get_section_contents (exec_bfd, interp_sect,\n-\t\t\t\tbuf, 0, interp_sect_size);\n+      bfd_get_section_contents (current_program_space->exec_bfd (),\n+\t\t\t\tinterp_sect, buf, 0, interp_sect_size);\n \n       /* Now we need to figure out where the dynamic linker was\n          loaded so that we can load its symbols and place a breakpoint\n@@ -735,7 +736,8 @@ enable_break (void)\n   /* Check for the presence of a .interp section.  If there is no\n      such section, the executable is statically linked.  */\n \n-  interp_sect = bfd_get_section_by_name (exec_bfd, \".interp\");\n+  interp_sect = bfd_get_section_by_name (current_program_space->exec_bfd (),\n+\t\t\t\t\t \".interp\");\n \n   if (interp_sect == NULL)\n     {"
    },
    {
      "sha": "637a0fcfac41162c9cb7cef6345b04e010957125",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 47,
      "deletions": 28,
      "changes": 75,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -554,20 +554,22 @@ read_program_header (int type, int *p_arch_size, CORE_ADDR *base_addr)\n static gdb::optional<gdb::byte_vector>\n find_program_interpreter (void)\n {\n-  /* If we have an exec_bfd, use its section table.  */\n-  if (exec_bfd\n-      && bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)\n+  /* If we have a current exec_bfd, use its section table.  */\n+  if (current_program_space->exec_bfd ()\n+      && (bfd_get_flavour (current_program_space->exec_bfd ())\n+\t  == bfd_target_elf_flavour))\n    {\n      struct bfd_section *interp_sect;\n \n-     interp_sect = bfd_get_section_by_name (exec_bfd, \".interp\");\n+     interp_sect = bfd_get_section_by_name (current_program_space->exec_bfd (),\n+\t\t\t\t\t    \".interp\");\n      if (interp_sect != NULL)\n       {\n \tint sect_size = bfd_section_size (interp_sect);\n \n \tgdb::byte_vector buf (sect_size);\n-\tbfd_get_section_contents (exec_bfd, interp_sect, buf.data (), 0,\n-\t\t\t\t  sect_size);\n+\tbfd_get_section_contents (current_program_space->exec_bfd (),\n+\t\t\t\t  interp_sect, buf.data (), 0, sect_size);\n \treturn buf;\n       }\n    }\n@@ -762,7 +764,8 @@ elf_locate_base (void)\n   /* Look for DT_MIPS_RLD_MAP first.  MIPS executables use this\n      instead of DT_DEBUG, although they sometimes contain an unused\n      DT_DEBUG.  */\n-  if (scan_dyntag (DT_MIPS_RLD_MAP, exec_bfd, &dyn_ptr, NULL)\n+  if (scan_dyntag (DT_MIPS_RLD_MAP, current_program_space->exec_bfd (),\n+\t\t   &dyn_ptr, NULL)\n       || scan_dyntag_auxv (DT_MIPS_RLD_MAP, &dyn_ptr, NULL))\n     {\n       struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n@@ -780,7 +783,8 @@ elf_locate_base (void)\n   /* Then check DT_MIPS_RLD_MAP_REL.  MIPS executables now use this form\n      because of needing to support PIE.  DT_MIPS_RLD_MAP will also exist\n      in non-PIE.  */\n-  if (scan_dyntag (DT_MIPS_RLD_MAP_REL, exec_bfd, &dyn_ptr, &dyn_ptr_addr)\n+  if (scan_dyntag (DT_MIPS_RLD_MAP_REL, current_program_space->exec_bfd (),\n+\t\t   &dyn_ptr, &dyn_ptr_addr)\n       || scan_dyntag_auxv (DT_MIPS_RLD_MAP_REL, &dyn_ptr, &dyn_ptr_addr))\n     {\n       struct type *ptr_type = builtin_type (target_gdbarch ())->builtin_data_ptr;\n@@ -796,7 +800,7 @@ elf_locate_base (void)\n     }\n \n   /* Find DT_DEBUG.  */\n-  if (scan_dyntag (DT_DEBUG, exec_bfd, &dyn_ptr, NULL)\n+  if (scan_dyntag (DT_DEBUG, current_program_space->exec_bfd (), &dyn_ptr, NULL)\n       || scan_dyntag_auxv (DT_DEBUG, &dyn_ptr, NULL))\n     return dyn_ptr;\n \n@@ -1399,7 +1403,9 @@ svr4_current_sos_direct (struct svr4_info *info)\n \n   /* Assume that everything is a library if the dynamic loader was loaded\n      late by a static executable.  */\n-  if (exec_bfd && bfd_get_section_by_name (exec_bfd, \".dynamic\") == NULL)\n+  if (current_program_space->exec_bfd ()\n+      && bfd_get_section_by_name (current_program_space->exec_bfd (),\n+\t\t\t\t  \".dynamic\") == NULL)\n     ignore_first = 0;\n   else\n     ignore_first = 1;\n@@ -2564,27 +2570,30 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n      a call to gdbarch_convert_from_func_ptr_addr.  */\n   CORE_ADDR entry_point, exec_displacement;\n \n-  if (exec_bfd == NULL)\n+  if (current_program_space->exec_bfd () == NULL)\n     return 0;\n \n   /* Therefore for ELF it is ET_EXEC and not ET_DYN.  Both shared libraries\n      being executed themselves and PIE (Position Independent Executable)\n      executables are ET_DYN.  */\n \n-  if ((bfd_get_file_flags (exec_bfd) & DYNAMIC) == 0)\n+  if ((bfd_get_file_flags (current_program_space->exec_bfd ()) & DYNAMIC) == 0)\n     return 0;\n \n   if (target_auxv_search (current_top_target (), AT_ENTRY, &entry_point) <= 0)\n     return 0;\n \n-  exec_displacement = entry_point - bfd_get_start_address (exec_bfd);\n+  exec_displacement\n+    = entry_point - bfd_get_start_address (current_program_space->exec_bfd ());\n \n   /* Verify the EXEC_DISPLACEMENT candidate complies with the required page\n      alignment.  It is cheaper than the program headers comparison below.  */\n \n-  if (bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)\n+  if (bfd_get_flavour (current_program_space->exec_bfd ())\n+      == bfd_target_elf_flavour)\n     {\n-      const struct elf_backend_data *elf = get_elf_backend_data (exec_bfd);\n+      const struct elf_backend_data *elf\n+\t= get_elf_backend_data (current_program_space->exec_bfd ());\n \n       /* p_align of PT_LOAD segments does not specify any alignment but\n \t only congruency of addresses:\n@@ -2601,7 +2610,8 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n      looking at a different file than the one used by the kernel - for\n      instance, \"gdb program\" connected to \"gdbserver :PORT ld.so program\".  */\n \n-  if (bfd_get_flavour (exec_bfd) == bfd_target_elf_flavour)\n+  if (bfd_get_flavour (current_program_space->exec_bfd ())\n+      == bfd_target_elf_flavour)\n     {\n       /* Be optimistic and return 0 only if GDB was able to verify the headers\n \t really do not match.  */\n@@ -2610,7 +2620,7 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n       gdb::optional<gdb::byte_vector> phdrs_target\n \t= read_program_header (-1, &arch_size, NULL);\n       gdb::optional<gdb::byte_vector> phdrs_binary\n-\t= read_program_headers_from_bfd (exec_bfd);\n+\t= read_program_headers_from_bfd (current_program_space->exec_bfd ());\n       if (phdrs_target && phdrs_binary)\n \t{\n \t  enum bfd_endian byte_order = gdbarch_byte_order (target_gdbarch ());\n@@ -2629,14 +2639,16 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t     content offset for the verification purpose.  */\n \n \t  if (phdrs_target->size () != phdrs_binary->size ()\n-\t      || bfd_get_arch_size (exec_bfd) != arch_size)\n+\t      || bfd_get_arch_size (current_program_space->exec_bfd ()) != arch_size)\n \t    return 0;\n \t  else if (arch_size == 32\n \t\t   && phdrs_target->size () >= sizeof (Elf32_External_Phdr)\n \t           && phdrs_target->size () % sizeof (Elf32_External_Phdr) == 0)\n \t    {\n-\t      Elf_Internal_Ehdr *ehdr2 = elf_tdata (exec_bfd)->elf_header;\n-\t      Elf_Internal_Phdr *phdr2 = elf_tdata (exec_bfd)->phdr;\n+\t      Elf_Internal_Ehdr *ehdr2\n+\t\t= elf_tdata (current_program_space->exec_bfd ())->elf_header;\n+\t      Elf_Internal_Phdr *phdr2\n+\t\t= elf_tdata (current_program_space->exec_bfd ())->phdr;\n \t      CORE_ADDR displacement = 0;\n \t      int i;\n \n@@ -2736,6 +2748,7 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t\t    }\n \n \t\t  /* prelink can convert .plt SHT_NOBITS to SHT_PROGBITS.  */\n+\t\t  bfd *exec_bfd = current_program_space->exec_bfd ();\n \t\t  plt2_asect = bfd_get_section_by_name (exec_bfd, \".plt\");\n \t\t  if (plt2_asect)\n \t\t    {\n@@ -2770,8 +2783,10 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t\t   && phdrs_target->size () >= sizeof (Elf64_External_Phdr)\n \t           && phdrs_target->size () % sizeof (Elf64_External_Phdr) == 0)\n \t    {\n-\t      Elf_Internal_Ehdr *ehdr2 = elf_tdata (exec_bfd)->elf_header;\n-\t      Elf_Internal_Phdr *phdr2 = elf_tdata (exec_bfd)->phdr;\n+\t      Elf_Internal_Ehdr *ehdr2\n+\t\t= elf_tdata (current_program_space->exec_bfd ())->elf_header;\n+\t      Elf_Internal_Phdr *phdr2\n+\t\t= elf_tdata (current_program_space->exec_bfd ())->phdr;\n \t      CORE_ADDR displacement = 0;\n \t      int i;\n \n@@ -2870,7 +2885,9 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t\t    }\n \n \t\t  /* prelink can convert .plt SHT_NOBITS to SHT_PROGBITS.  */\n-\t\t  plt2_asect = bfd_get_section_by_name (exec_bfd, \".plt\");\n+\t\t  plt2_asect\n+\t\t    = bfd_get_section_by_name (current_program_space->exec_bfd (),\n+\t\t\t\t\t       \".plt\");\n \t\t  if (plt2_asect)\n \t\t    {\n \t\t      int content2;\n@@ -2883,8 +2900,9 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n \t\t      filesz = extract_unsigned_integer (buf_filesz_p, 8,\n \t\t\t\t\t\t\t byte_order);\n \n-\t\t      /* PLT2_ASECT is from on-disk file (exec_bfd) while\n-\t\t\t FILESZ is from the in-memory image.  */\n+\t\t      /* PLT2_ASECT is from on-disk file (current\n+\t\t\t exec_bfd) while FILESZ is from the in-memory\n+\t\t\t image.  */\n \t\t      if (content2)\n \t\t\tfilesz += bfd_section_size (plt2_asect);\n \t\t      else\n@@ -2914,7 +2932,7 @@ svr4_exec_displacement (CORE_ADDR *displacementp)\n       printf_unfiltered (_(\"Using PIE (Position Independent Executable) \"\n \t\t\t   \"displacement %s for \\\"%s\\\".\\n\"),\n \t\t\t paddress (target_gdbarch (), exec_displacement),\n-\t\t\t bfd_get_filename (exec_bfd));\n+\t\t\t bfd_get_filename (current_program_space->exec_bfd ()));\n     }\n \n   *displacementp = exec_displacement;\n@@ -2969,10 +2987,11 @@ svr4_relocate_main_executable (void)\n \t\t\t\t   displacement);\n       objfile_relocate (symfile_objfile, new_offsets);\n     }\n-  else if (exec_bfd)\n+  else if (current_program_space->exec_bfd ())\n     {\n       asection *asect;\n \n+      bfd *exec_bfd = current_program_space->exec_bfd ();\n       for (asect = exec_bfd->sections; asect != NULL; asect = asect->next)\n \texec_set_section_address (bfd_get_filename (exec_bfd), asect->index,\n \t\t\t\t  bfd_section_vma (asect) + displacement);\n@@ -3228,7 +3247,7 @@ svr4_iterate_over_objfiles_in_search_order\n         current_objfile = current_objfile->separate_debug_objfile_backlink;\n \n       if (current_objfile == symfile_objfile)\n-\tabfd = exec_bfd;\n+\tabfd = current_program_space->exec_bfd ();\n       else\n \tabfd = current_objfile->obfd;\n "
    },
    {
      "sha": "098fcf72e4e3334b7b2237c9eb799f640ffa0493",
      "filename": "gdb/source-cache.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/source-cache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/source-cache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source-cache.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -68,7 +68,7 @@ source_cache::get_plain_source_lines (struct symtab *s,\n   time_t mtime = 0;\n   if (SYMTAB_OBJFILE (s) != NULL && SYMTAB_OBJFILE (s)->obfd != NULL)\n     mtime = SYMTAB_OBJFILE (s)->mtime;\n-  else if (exec_bfd)\n+  else if (current_program_space->exec_bfd ())\n     mtime = current_program_space->ebfd_mtime;\n \n   if (mtime && mtime < st.st_mtime)"
    },
    {
      "sha": "02761df679af33e8bc4a60fd1cc27293a2ae5d4f",
      "filename": "gdb/symfile-mem.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/symfile-mem.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/symfile-mem.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile-mem.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -146,7 +146,7 @@ add_symbol_file_from_memory_command (const char *args, int from_tty)\n   if (symfile_objfile != NULL)\n     templ = symfile_objfile->obfd;\n   else\n-    templ = exec_bfd;\n+    templ = current_program_space->exec_bfd ();\n   if (templ == NULL)\n     error (_(\"Must use symbol-file or exec-file \"\n \t     \"before add-symbol-file-from-memory.\"));\n@@ -168,8 +168,8 @@ add_vsyscall_page (inferior *inf)\n \n       if (core_bfd != NULL)\n \tbfd = core_bfd;\n-      else if (exec_bfd != NULL)\n-\tbfd = exec_bfd;\n+      else if (current_program_space->exec_bfd () != NULL)\n+\tbfd = current_program_space->exec_bfd ();\n       else\n        /* FIXME: cagney/2004-05-06: Should not require an existing\n \t  BFD when trying to create a run-time BFD of the VSYSCALL"
    },
    {
      "sha": "434ecb9a667c49f4544d0572b8bb65b0e8ab8d95",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -2460,9 +2460,9 @@ reread_symbols (void)\n \t  /* We need to do this whenever any symbols go away.  */\n \t  clear_symtab_users_cleanup defer_clear_users (0);\n \n-\t  if (exec_bfd != NULL\n+\t  if (current_program_space->exec_bfd () != NULL\n \t      && filename_cmp (bfd_get_filename (objfile->obfd),\n-\t\t\t       bfd_get_filename (exec_bfd)) == 0)\n+\t\t\t       bfd_get_filename (current_program_space->exec_bfd ())) == 0)\n \t    {\n \t      /* Reload EXEC_BFD without asking anything.  */\n "
    },
    {
      "sha": "c26d99a2765c4c27c21fe1b41db6a901f9f01f15",
      "filename": "gdb/tracefile-tfile.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/tracefile-tfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/tracefile-tfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracefile-tfile.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -25,7 +25,7 @@\n #include \"regcache.h\"\n #include \"inferior.h\"\n #include \"gdbthread.h\"\n-#include \"exec.h\" /* exec_bfd */\n+#include \"exec.h\"\n #include \"completer.h\"\n #include \"filenames.h\"\n #include \"remote.h\""
    },
    {
      "sha": "5f2b10a8e04e8719f53631d69190b9991bda3176",
      "filename": "gdb/windows-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7e10abd146dbd17dc1b4e9701210e5724df2b2b0/gdb/windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-tdep.c?ref=7e10abd146dbd17dc1b4e9701210e5724df2b2b0",
      "patch": "@@ -914,7 +914,8 @@ windows_solib_create_inferior_hook (int from_tty)\n   /* Rebase executable if the base address changed because of ASLR.  */\n   if (symfile_objfile != nullptr && exec_base != 0)\n     {\n-      CORE_ADDR vmaddr = pe_data (exec_bfd)->pe_opthdr.ImageBase;\n+      CORE_ADDR vmaddr\n+\t= pe_data (current_program_space->exec_bfd ())->pe_opthdr.ImageBase;\n       if (vmaddr != exec_base)\n \tobjfile_rebase (symfile_objfile, exec_base - vmaddr);\n     }"
    }
  ]
}