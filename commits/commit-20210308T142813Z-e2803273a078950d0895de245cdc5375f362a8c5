{
  "sha": "e2803273a078950d0895de245cdc5375f362a8c5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTI4MDMyNzNhMDc4OTUwZDA4OTVkZTI0NWNkYzUzNzVmMzYyYThjNQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:13Z"
    },
    "message": "Introduce class operation\n\nThis patch introduces class operation, the new base class for all\nexpression operations.\n\nIn the new approach, an operation is simply a class that presents a\ncertain interface.  Operations own their operands, and management is\ndone via unique_ptr.\n\nThe operation interface is largely ad hoc, based on the evolution of\nexpression handling in GDB.  Parts (for example,\nevaluate_with_coercion) are probably redundant; however I took this\napproach to try to avoid mixing different kinds of refactorings.\n\nIn some specific situations, rather than add a generic method across\nthe entire operation class hierarchy, I chose instead to use\ndynamic_cast and specialized methods on certain concrete subclasses.\nThis will appear in some subsequent patches.\n\nOne goal of this work is to avoid the kinds of easy-to-make errors\nthat affected the old implementation.  To this end, some helper\nsubclasses are also added here.  These helpers automate the\nimplementation of the 'dump', 'uses_objfile', and 'constant_p'\nmethods.  Nearly every concrete operation that is subsequently added\nwill use these facilities.  (Note that the 'dump' implementation is\nonly outlined here, the body appears in the next patch.)\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* expression.h (expr::operation): New class.\n\t(expr::make_operation): New function.\n\t(expr::operation_up): New typedef.\n\t* expop.h: New file.\n\t* eval.c (operation::evaluate_for_cast)\n\t(operation::evaluate_for_address, operation::evaluate_for_sizeof):\n\tNew methods.\n\t* ax-gdb.c (operation::generate_ax): New method.",
    "tree": {
      "sha": "5831732b28dc39d8afa6d009089f501fe6b0c57c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5831732b28dc39d8afa6d009089f501fe6b0c57c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e2803273a078950d0895de245cdc5375f362a8c5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e2803273a078950d0895de245cdc5375f362a8c5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e2803273a078950d0895de245cdc5375f362a8c5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e2803273a078950d0895de245cdc5375f362a8c5/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "e18c58f290609dcfe8d7df450bb88b1adf44337a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e18c58f290609dcfe8d7df450bb88b1adf44337a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e18c58f290609dcfe8d7df450bb88b1adf44337a"
    }
  ],
  "stats": {
    "total": 487,
    "additions": 487,
    "deletions": 0
  },
  "files": [
    {
      "sha": "abf16c067877971abd21ee379e56a2a27eece6f6",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2803273a078950d0895de245cdc5375f362a8c5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2803273a078950d0895de245cdc5375f362a8c5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=e2803273a078950d0895de245cdc5375f362a8c5",
      "patch": "@@ -1,3 +1,14 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* expression.h (expr::operation): New class.\n+\t(expr::make_operation): New function.\n+\t(expr::operation_up): New typedef.\n+\t* expop.h: New file.\n+\t* eval.c (operation::evaluate_for_cast)\n+\t(operation::evaluate_for_address, operation::evaluate_for_sizeof):\n+\tNew methods.\n+\t* ax-gdb.c (operation::generate_ax): New method.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* ax-gdb.c (gen_expr_binop_rest): Remove \"pc\" parameter."
    },
    {
      "sha": "728b21dfd6a9ba83e7d869d76385bfec56faacac",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2803273a078950d0895de245cdc5375f362a8c5/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2803273a078950d0895de245cdc5375f362a8c5/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=e2803273a078950d0895de245cdc5375f362a8c5",
      "patch": "@@ -2270,6 +2270,32 @@ gen_expr (struct expression *exp, union exp_element **pc,\n     }\n }\n \n+namespace expr\n+{\n+\n+void\n+operation::generate_ax (struct expression *exp,\n+\t\t\tstruct agent_expr *ax,\n+\t\t\tstruct axs_value *value,\n+\t\t\tstruct type *cast_type)\n+{\n+  if (constant_p ())\n+    {\n+      struct value *v = evaluate (nullptr, exp, EVAL_AVOID_SIDE_EFFECTS);\n+      ax_const_l (ax, value_as_long (v));\n+      value->kind = axs_rvalue;\n+      value->type = check_typedef (value_type (v));\n+    }\n+  else\n+    {\n+      do_generate_ax (exp, ax, value, cast_type);\n+      if (cast_type != nullptr)\n+\tgen_cast (ax, value, cast_type);\n+    }\n+}\n+\n+}\n+\n /* This handles the middle-to-right-side of code generation for binary\n    expressions, which is shared between regular binary operations and\n    assign-modify (+= and friends) expressions.  */"
    },
    {
      "sha": "8adbcefb585a0e3875d9839cb136140d6b7e3fa0",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 36,
      "deletions": 0,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2803273a078950d0895de245cdc5375f362a8c5/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2803273a078950d0895de245cdc5375f362a8c5/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=e2803273a078950d0895de245cdc5375f362a8c5",
      "patch": "@@ -40,6 +40,7 @@\n #include \"objfiles.h\"\n #include \"typeprint.h\"\n #include <ctype.h>\n+#include \"expop.h\"\n \n /* Prototypes for local functions.  */\n \n@@ -3267,6 +3268,29 @@ evaluate_subexp_for_address (struct expression *exp, int *pos,\n     }\n }\n \n+namespace expr\n+{\n+\n+value *\n+operation::evaluate_for_cast (struct type *expect_type,\n+\t\t\t      struct expression *exp,\n+\t\t\t      enum noside noside)\n+{\n+  value *val = evaluate (expect_type, exp, noside);\n+  if (noside == EVAL_SKIP)\n+    return eval_skip_value (exp);\n+  return value_cast (expect_type, val);\n+}\n+\n+value *\n+operation::evaluate_for_address (struct expression *exp, enum noside noside)\n+{\n+  value *val = evaluate (nullptr, exp, noside);\n+  return evaluate_subexp_for_address_base (exp, noside, val);\n+}\n+\n+}\n+\n /* Evaluate like `evaluate_subexp' except coercing arrays to pointers.\n    When used in contexts where arrays will be coerced anyway, this is\n    equivalent to `evaluate_subexp' but much faster because it avoids\n@@ -3455,6 +3479,18 @@ evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n   return evaluate_subexp_for_sizeof_base (exp, type);\n }\n \n+namespace expr\n+{\n+\n+value *\n+operation::evaluate_for_sizeof (struct expression *exp, enum noside noside)\n+{\n+  value *val = evaluate (nullptr, exp, EVAL_AVOID_SIDE_EFFECTS);\n+  return evaluate_subexp_for_sizeof_base (exp, value_type (val));\n+}\n+\n+}\n+\n /* Evaluate a subexpression of EXP, at index *POS, and return a value\n    for that subexpression cast to TO_TYPE.  Advance *POS over the\n    subexpression.  */"
    },
    {
      "sha": "861e3c2ee6c80618ebce61d7018f4df5a7f9c438",
      "filename": "gdb/expop.h",
      "status": "added",
      "additions": 315,
      "deletions": 0,
      "changes": 315,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2803273a078950d0895de245cdc5375f362a8c5/gdb/expop.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2803273a078950d0895de245cdc5375f362a8c5/gdb/expop.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expop.h?ref=e2803273a078950d0895de245cdc5375f362a8c5",
      "patch": "@@ -0,0 +1,315 @@\n+/* Definitions for expressions in GDB\n+\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef EXPOP_H\n+#define EXPOP_H\n+\n+#include \"block.h\"\n+#include \"c-lang.h\"\n+#include \"cp-abi.h\"\n+#include \"expression.h\"\n+#include \"objfiles.h\"\n+#include \"gdbsupport/traits.h\"\n+#include \"gdbsupport/enum-flags.h\"\n+\n+struct agent_expr;\n+struct axs_value;\n+\n+namespace expr\n+{\n+\n+/* The check_objfile overloads are used to check whether a particular\n+   component of some operation references an objfile.  The passed-in\n+   objfile will never be a debug objfile.  */\n+\n+/* See if EXP_OBJFILE matches OBJFILE.  */\n+static inline bool\n+check_objfile (struct objfile *exp_objfile, struct objfile *objfile)\n+{\n+  if (exp_objfile->separate_debug_objfile_backlink)\n+    exp_objfile = exp_objfile->separate_debug_objfile_backlink;\n+  return exp_objfile == objfile;\n+}\n+\n+static inline bool \n+check_objfile (struct type *type, struct objfile *objfile)\n+{\n+  struct objfile *ty_objfile = type->objfile_owner ();\n+  if (ty_objfile != nullptr)\n+    return check_objfile (ty_objfile, objfile);\n+  return false;\n+}\n+\n+static inline bool \n+check_objfile (struct symbol *sym, struct objfile *objfile)\n+{\n+  return check_objfile (symbol_objfile (sym), objfile);\n+}\n+\n+static inline bool \n+check_objfile (const struct block *block, struct objfile *objfile)\n+{\n+  return check_objfile (block_objfile (block), objfile);\n+}\n+\n+static inline bool\n+check_objfile (minimal_symbol *minsym, struct objfile *objfile)\n+{\n+  /* This may seem strange but minsyms are only used with an objfile\n+     as well.  */\n+  return false;\n+}\n+\n+static inline bool\n+check_objfile (internalvar *ivar, struct objfile *objfile)\n+{\n+  return false;\n+}\n+\n+static inline bool\n+check_objfile (const std::string &str, struct objfile *objfile)\n+{\n+  return false;\n+}\n+\n+static inline bool \n+check_objfile (const operation_up &op, struct objfile *objfile)\n+{\n+  return op->uses_objfile (objfile);\n+}\n+\n+static inline bool\n+check_objfile (enum exp_opcode val, struct objfile *objfile)\n+{\n+  return false;\n+}\n+\n+static inline bool\n+check_objfile (ULONGEST val, struct objfile *objfile)\n+{\n+  return false;\n+}\n+\n+template<typename T>\n+static inline bool\n+check_objfile (enum_flags<T> val, struct objfile *objfile)\n+{\n+  return false;\n+}\n+\n+template<typename T>\n+static inline bool \n+check_objfile (const std::vector<T> &collection, struct objfile *objfile)\n+{\n+  for (const auto &item : collection)\n+    {\n+      if (check_objfile (item, objfile))\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+template<typename S, typename T>\n+static inline bool \n+check_objfile (const std::pair<S, T> &item, struct objfile *objfile)\n+{\n+  return (check_objfile (item.first, objfile)\n+\t  || check_objfile (item.second, objfile));\n+}\n+\n+/* Base class for most concrete operations.  This class holds data,\n+   specified via template parameters, and supplies generic\n+   implementations of the 'dump' and 'uses_objfile' methods.  */\n+template<typename... Arg>\n+class tuple_holding_operation : public operation\n+{\n+public:\n+\n+  explicit tuple_holding_operation (Arg... args)\n+    : m_storage (std::forward<Arg> (args)...)\n+  {\n+  }\n+\n+  DISABLE_COPY_AND_ASSIGN (tuple_holding_operation);\n+\n+  bool uses_objfile (struct objfile *objfile) const override\n+  {\n+    return do_check_objfile<0, Arg...> (objfile, m_storage);\n+  }\n+\n+  void dump (struct ui_file *stream, int depth) const override\n+  {\n+    do_dump<0, Arg...> (stream, depth, m_storage);\n+  }\n+\n+protected:\n+\n+  /* Storage for the data.  */\n+  std::tuple<Arg...> m_storage;\n+\n+private:\n+\n+  /* do_dump does the work of dumping the data.  */\n+  template<int I, typename... T>\n+  typename std::enable_if<I == sizeof... (T), void>::type\n+  do_dump (struct ui_file *stream, int depth, const std::tuple<T...> &value)\n+    const\n+  {\n+  }\n+\n+  template<int I, typename... T>\n+  typename std::enable_if<I < sizeof... (T), void>::type\n+  do_dump (struct ui_file *stream, int depth, const std::tuple<T...> &value)\n+    const\n+  {\n+    do_dump<I + 1, T...> (stream, depth, value);\n+  }\n+\n+  /* do_check_objfile does the work of checking whether this object\n+     refers to OBJFILE.  */\n+  template<int I, typename... T>\n+  typename std::enable_if<I == sizeof... (T), bool>::type\n+  do_check_objfile (struct objfile *objfile, const std::tuple<T...> &value)\n+    const\n+  {\n+    return false;\n+  }\n+\n+  template<int I, typename... T>\n+  typename std::enable_if<I < sizeof... (T), bool>::type\n+  do_check_objfile (struct objfile *objfile, const std::tuple<T...> &value)\n+    const\n+  {\n+    if (check_objfile (std::get<I> (value), objfile))\n+      return true;\n+    return do_check_objfile<I + 1, T...> (objfile, value);\n+  }\n+};\n+\n+/* The check_constant overloads are used to decide whether a given\n+   concrete operation is a constant.  This is done by checking the\n+   operands.  */\n+\n+static inline bool\n+check_constant (const operation_up &item)\n+{\n+  return item->constant_p ();\n+}\n+\n+static inline bool\n+check_constant (struct minimal_symbol *msym)\n+{\n+  return false;\n+}\n+\n+static inline bool\n+check_constant (struct type *type)\n+{\n+  return true;\n+}\n+\n+static inline bool\n+check_constant (const struct block *block)\n+{\n+  return true;\n+}\n+\n+static inline bool\n+check_constant (const std::string &str)\n+{\n+  return true;\n+}\n+\n+static inline bool\n+check_constant (struct objfile *objfile)\n+{\n+  return true;\n+}\n+\n+static inline bool\n+check_constant (ULONGEST cst)\n+{\n+  return true;\n+}\n+\n+static inline bool\n+check_constant (struct symbol *sym)\n+{\n+  enum address_class sc = SYMBOL_CLASS (sym);\n+  return (sc == LOC_BLOCK\n+\t  || sc == LOC_CONST\n+\t  || sc == LOC_CONST_BYTES\n+\t  || sc == LOC_LABEL);\n+}\n+\n+template<typename T>\n+static inline bool\n+check_constant (const std::vector<T> &collection)\n+{\n+  for (const auto &item : collection)\n+    if (!check_constant (item))\n+      return false;\n+  return true;\n+}\n+\n+template<typename S, typename T>\n+static inline bool\n+check_constant (const std::pair<S, T> &item)\n+{\n+  return check_constant (item.first) && check_constant (item.second);\n+}\n+\n+/* Base class for concrete operations.  This class supplies an\n+   implementation of 'constant_p' that works by checking the\n+   operands.  */\n+template<typename... Arg>\n+class maybe_constant_operation\n+  : public tuple_holding_operation<Arg...>\n+{\n+public:\n+\n+  using tuple_holding_operation<Arg...>::tuple_holding_operation;\n+\n+  bool constant_p () const override\n+  {\n+    return do_check_constant<0, Arg...> (this->m_storage);\n+  }\n+\n+private:\n+\n+  template<int I, typename... T>\n+  typename std::enable_if<I == sizeof... (T), bool>::type\n+  do_check_constant (const std::tuple<T...> &value) const\n+  {\n+    return true;\n+  }\n+\n+  template<int I, typename... T>\n+  typename std::enable_if<I < sizeof... (T), bool>::type\n+  do_check_constant (const std::tuple<T...> &value) const\n+  {\n+    if (!check_constant (std::get<I> (value)))\n+      return false;\n+    return do_check_constant<I + 1, T...> (value);\n+  }\n+};\n+\n+} /* namespace expr */\n+\n+#endif /* EXPOP_H */"
    },
    {
      "sha": "24a0eb37722a3a433b4f2577adf40f28058737ed",
      "filename": "gdb/expression.h",
      "status": "modified",
      "additions": 99,
      "deletions": 0,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e2803273a078950d0895de245cdc5375f362a8c5/gdb/expression.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e2803273a078950d0895de245cdc5375f362a8c5/gdb/expression.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expression.h?ref=e2803273a078950d0895de245cdc5375f362a8c5",
      "patch": "@@ -89,6 +89,105 @@ enum noside\n \t\t\t\t   does in many situations.  */\n   };\n \n+struct expression;\n+struct agent_expr;\n+struct axs_value;\n+struct type;\n+struct ui_file;\n+\n+namespace expr\n+{\n+\n+class operation;\n+typedef std::unique_ptr<operation> operation_up;\n+\n+/* Base class for an operation.  An operation is a single component of\n+   an expression.  */\n+\n+class operation\n+{\n+protected:\n+\n+  operation () = default;\n+  DISABLE_COPY_AND_ASSIGN (operation);\n+\n+public:\n+\n+  virtual ~operation () = default;\n+\n+  /* Evaluate this operation.  */\n+  virtual value *evaluate (struct type *expect_type,\n+\t\t\t   struct expression *exp,\n+\t\t\t   enum noside noside) = 0;\n+\n+  /* Evaluate this operation in a context where C-like coercion is\n+     needed.  */\n+  virtual value *evaluate_with_coercion (struct expression *exp,\n+\t\t\t\t\t enum noside noside)\n+  {\n+    return evaluate (nullptr, exp, noside);\n+  }\n+\n+  /* Evaluate this expression in the context of a cast to\n+     EXPECT_TYPE.  */\n+  virtual value *evaluate_for_cast (struct type *expect_type,\n+\t\t\t\t    struct expression *exp,\n+\t\t\t\t    enum noside noside);\n+\n+  /* Evaluate this expression in the context of a sizeof\n+     operation.  */\n+  virtual value *evaluate_for_sizeof (struct expression *exp,\n+\t\t\t\t      enum noside noside);\n+\n+  /* Evaluate this expression in the context of an address-of\n+     operation.  Must return the address.  */\n+  virtual value *evaluate_for_address (struct expression *exp,\n+\t\t\t\t       enum noside noside);\n+\n+  /* True if this is a constant expression.  */\n+  virtual bool constant_p () const\n+  { return false; }\n+\n+  /* Return true if this operation uses OBJFILE (and will become\n+     dangling when OBJFILE is unloaded), otherwise return false.\n+     OBJFILE must not be a separate debug info file.  */\n+  virtual bool uses_objfile (struct objfile *objfile) const\n+  { return false; }\n+\n+  /* Generate agent expression bytecodes for this operation.  */\n+  void generate_ax (struct expression *exp, struct agent_expr *ax,\n+\t\t    struct axs_value *value,\n+\t\t    struct type *cast_type = nullptr);\n+\n+  /* Return the opcode that is implemented by this operation.  */\n+  virtual enum exp_opcode opcode () const = 0;\n+\n+  /* Print this operation to STREAM.  */\n+  virtual void dump (struct ui_file *stream, int depth) const = 0;\n+\n+protected:\n+\n+  /* Called by generate_ax to do the work for this particular\n+     operation.  */\n+  virtual void do_generate_ax (struct expression *exp,\n+\t\t\t       struct agent_expr *ax,\n+\t\t\t       struct axs_value *value,\n+\t\t\t       struct type *cast_type)\n+  {\n+    error (_(\"Cannot translate to agent expression\"));\n+  }\n+};\n+\n+/* A helper function for creating an operation_up, given a type.  */\n+template<typename T, typename... Arg>\n+operation_up\n+make_operation (Arg... args)\n+{\n+  return operation_up (new T (std::forward<Arg> (args)...));\n+}\n+\n+}\n+\n union exp_element\n   {\n     enum exp_opcode opcode;"
    }
  ]
}