{
  "sha": "11e1b75f0696f6e406fe8ccc759bac2fbc8fc151",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MTFlMWI3NWYwNjk2ZjZlNDA2ZmU4Y2NjNzU5YmFjMmZiYzhmYzE1MQ==",
  "commit": {
    "author": {
      "name": "Alan Hayward",
      "email": "alan.hayward@arm.com",
      "date": "2019-03-22T10:39:11Z"
    },
    "committer": {
      "name": "Alan Hayward",
      "email": "alan.hayward@arm.com",
      "date": "2019-03-22T10:39:11Z"
    },
    "message": "AArch64: DWARF unwinder support for signed return addresses\n\nPauth address signing is enabled at binary compile time.  When enabled the\nreturn addresses for functions may be mangled.  This patch adds functionality\nto restore the original address for use in the DWARF unwinder.\n\nDW_CFA_AARCH64_negate_ra_state in a binary indicates the toggling of address\nsigning between enabled and disabled.  Ensure the state is stored in the DWARF\nregister ra_state.\n\nEnsure the pauth DWARF registers are initialised.\n\ngdb/ChangeLog:\n\n\t* aarch64-tdep.c (aarch64_frame_unmask_address): New function.\n\t(aarch64_dwarf2_prev_register): Unmask PC value.\n\t(aarch64_dwarf2_frame_init_reg): Init pauth registers.\n\t(aarch64_execute_dwarf_cfa_vendor_op): Check for\n\tDW_CFA_AARCH64_negate_ra_state.\n\t(aarch64_gdbarch_init): Add aarch64_execute_dwarf_cfa_vendor_op.",
    "tree": {
      "sha": "ebfb580bc0d7ea7d1bddbc258f2f9f64d5690583",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ebfb580bc0d7ea7d1bddbc258f2f9f64d5690583"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/11e1b75f0696f6e406fe8ccc759bac2fbc8fc151",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/11e1b75f0696f6e406fe8ccc759bac2fbc8fc151",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/11e1b75f0696f6e406fe8ccc759bac2fbc8fc151",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/11e1b75f0696f6e406fe8ccc759bac2fbc8fc151/comments",
  "author": {
    "login": "a74nh",
    "id": 4146708,
    "node_id": "MDQ6VXNlcjQxNDY3MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/a74nh",
    "html_url": "https://github.com/a74nh",
    "followers_url": "https://api.github.com/users/a74nh/followers",
    "following_url": "https://api.github.com/users/a74nh/following{/other_user}",
    "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions",
    "organizations_url": "https://api.github.com/users/a74nh/orgs",
    "repos_url": "https://api.github.com/users/a74nh/repos",
    "events_url": "https://api.github.com/users/a74nh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/a74nh/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "a74nh",
    "id": 4146708,
    "node_id": "MDQ6VXNlcjQxNDY3MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/a74nh",
    "html_url": "https://github.com/a74nh",
    "followers_url": "https://api.github.com/users/a74nh/followers",
    "following_url": "https://api.github.com/users/a74nh/following{/other_user}",
    "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions",
    "organizations_url": "https://api.github.com/users/a74nh/orgs",
    "repos_url": "https://api.github.com/users/a74nh/repos",
    "events_url": "https://api.github.com/users/a74nh/events{/privacy}",
    "received_events_url": "https://api.github.com/users/a74nh/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "34dcc7cf95f756862bdfebb753ab2de39fec4c9e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/34dcc7cf95f756862bdfebb753ab2de39fec4c9e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/34dcc7cf95f756862bdfebb753ab2de39fec4c9e"
    }
  ],
  "stats": {
    "total": 97,
    "additions": 95,
    "deletions": 2
  },
  "files": [
    {
      "sha": "13b117205df9e802529fcfe86f8826bcc8208dfd",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/11e1b75f0696f6e406fe8ccc759bac2fbc8fc151/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/11e1b75f0696f6e406fe8ccc759bac2fbc8fc151/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=11e1b75f0696f6e406fe8ccc759bac2fbc8fc151",
      "patch": "@@ -1,3 +1,13 @@\n+2019-03-22  Alan Hayward  <alan.hayward@arm.com>\n+\t    Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* aarch64-tdep.c (aarch64_frame_unmask_address): New function.\n+\t(aarch64_dwarf2_prev_register): Unmask PC value.\n+\t(aarch64_dwarf2_frame_init_reg): Init pauth registers.\n+\t(aarch64_execute_dwarf_cfa_vendor_op): Check for\n+\tDW_CFA_AARCH64_negate_ra_state.\n+\t(aarch64_gdbarch_init): Add aarch64_execute_dwarf_cfa_vendor_op.\n+\n 2019-03-22  Alan Hayward  <alan.hayward@arm.com>\n \t    Jiong Wang  <jiong.wang@arm.com>\n "
    },
    {
      "sha": "07430c0f25bbbc9453598b5c05be6060261b48f7",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 85,
      "deletions": 2,
      "changes": 87,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/11e1b75f0696f6e406fe8ccc759bac2fbc8fc151/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/11e1b75f0696f6e406fe8ccc759bac2fbc8fc151/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=11e1b75f0696f6e406fe8ccc759bac2fbc8fc151",
      "patch": "@@ -34,6 +34,7 @@\n #include \"frame-base.h\"\n #include \"trad-frame.h\"\n #include \"objfiles.h\"\n+#include \"dwarf2.h\"\n #include \"dwarf2-frame.h\"\n #include \"gdbtypes.h\"\n #include \"prologue-value.h\"\n@@ -248,6 +249,26 @@ class instruction_reader : public abstract_instruction_reader\n \n } // namespace\n \n+/* If address signing is enabled, mask off the signature bits from ADDR, using\n+   the register values in THIS_FRAME.  */\n+\n+static CORE_ADDR\n+aarch64_frame_unmask_address (struct gdbarch_tdep *tdep,\n+\t\t\t      struct frame_info *this_frame,\n+\t\t\t      CORE_ADDR addr)\n+{\n+  if (tdep->has_pauth ()\n+      && frame_unwind_register_unsigned (this_frame,\n+\t\t\t\t\t tdep->pauth_ra_state_regnum))\n+    {\n+      int cmask_num = AARCH64_PAUTH_CMASK_REGNUM (tdep->pauth_reg_base);\n+      CORE_ADDR cmask = frame_unwind_register_unsigned (this_frame, cmask_num);\n+      addr = addr & ~cmask;\n+    }\n+\n+  return addr;\n+}\n+\n /* Analyze a prologue, looking for a recognizable stack frame\n    and frame pointer.  Scan until we encounter a store that could\n    clobber the stack frame unexpectedly, or an unknown instruction.  */\n@@ -1013,12 +1034,14 @@ static struct value *\n aarch64_dwarf2_prev_register (struct frame_info *this_frame,\n \t\t\t      void **this_cache, int regnum)\n {\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (get_frame_arch (this_frame));\n   CORE_ADDR lr;\n \n   switch (regnum)\n     {\n     case AARCH64_PC_REGNUM:\n       lr = frame_unwind_register_unsigned (this_frame, AARCH64_LR_REGNUM);\n+      lr = aarch64_frame_unmask_address (tdep, this_frame, lr);\n       return frame_unwind_got_constant (this_frame, regnum, lr);\n \n     default:\n@@ -1027,25 +1050,82 @@ aarch64_dwarf2_prev_register (struct frame_info *this_frame,\n     }\n }\n \n+static const unsigned char op_lit0 = DW_OP_lit0;\n+static const unsigned char op_lit1 = DW_OP_lit1;\n+\n /* Implement the \"init_reg\" dwarf2_frame_ops method.  */\n \n static void\n aarch64_dwarf2_frame_init_reg (struct gdbarch *gdbarch, int regnum,\n \t\t\t       struct dwarf2_frame_state_reg *reg,\n \t\t\t       struct frame_info *this_frame)\n {\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+\n   switch (regnum)\n     {\n     case AARCH64_PC_REGNUM:\n       reg->how = DWARF2_FRAME_REG_FN;\n       reg->loc.fn = aarch64_dwarf2_prev_register;\n-      break;\n+      return;\n+\n     case AARCH64_SP_REGNUM:\n       reg->how = DWARF2_FRAME_REG_CFA;\n-      break;\n+      return;\n+    }\n+\n+  /* Init pauth registers.  */\n+  if (tdep->has_pauth ())\n+    {\n+      if (regnum == tdep->pauth_ra_state_regnum)\n+\t{\n+\t  /* Initialize RA_STATE to zero.  */\n+\t  reg->how = DWARF2_FRAME_REG_SAVED_VAL_EXP;\n+\t  reg->loc.exp.start = &op_lit0;\n+\t  reg->loc.exp.len = 1;\n+\t  return;\n+\t}\n+      else if (regnum == AARCH64_PAUTH_DMASK_REGNUM (tdep->pauth_reg_base)\n+\t       || regnum == AARCH64_PAUTH_CMASK_REGNUM (tdep->pauth_reg_base))\n+\t{\n+\t  reg->how = DWARF2_FRAME_REG_SAME_VALUE;\n+\t  return;\n+\t}\n     }\n }\n \n+/* Implement the execute_dwarf_cfa_vendor_op method.  */\n+\n+static bool\n+aarch64_execute_dwarf_cfa_vendor_op (struct gdbarch *gdbarch, gdb_byte op,\n+\t\t\t\t     struct dwarf2_frame_state *fs)\n+{\n+  struct gdbarch_tdep *tdep = gdbarch_tdep (gdbarch);\n+  struct dwarf2_frame_state_reg *ra_state;\n+\n+  if (tdep->has_pauth () && op == DW_CFA_AARCH64_negate_ra_state)\n+    {\n+      /* Allocate RA_STATE column if it's not allocated yet.  */\n+      fs->regs.alloc_regs (AARCH64_DWARF_PAUTH_RA_STATE + 1);\n+\n+      /* Toggle the status of RA_STATE between 0 and 1.  */\n+      ra_state = &(fs->regs.reg[AARCH64_DWARF_PAUTH_RA_STATE]);\n+      ra_state->how = DWARF2_FRAME_REG_SAVED_VAL_EXP;\n+\n+      if (ra_state->loc.exp.start == nullptr\n+\t  || ra_state->loc.exp.start == &op_lit0)\n+\tra_state->loc.exp.start = &op_lit1;\n+      else\n+\tra_state->loc.exp.start = &op_lit0;\n+\n+      ra_state->loc.exp.len = 1;\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* When arguments must be pushed onto the stack, they go on in reverse\n    order.  The code below implements a FILO (stack) to do this.  */\n \n@@ -3192,6 +3272,9 @@ aarch64_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n   gdbarch_init_osabi (info, gdbarch);\n \n   dwarf2_frame_set_init_reg (gdbarch, aarch64_dwarf2_frame_init_reg);\n+  /* Register DWARF CFA vendor handler.  */\n+  set_gdbarch_execute_dwarf_cfa_vendor_op (gdbarch,\n+\t\t\t\t\t   aarch64_execute_dwarf_cfa_vendor_op);\n \n   /* Add some default predicates.  */\n   frame_unwind_append_unwinder (gdbarch, &aarch64_stub_unwind);"
    }
  ]
}