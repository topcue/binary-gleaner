{
  "sha": "20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjBhNWZjYmQ1YjI4Y2NhODg1MTFhYzVhOWFkNWU1NDI1MWU4ZmE2ZA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-23T15:39:24Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-09-23T15:39:24Z"
    },
    "message": "Handle bit offset and bit size in base types\n\nPR symtab/25470 points out that the Zig programming language allows\nintegers of various bit sizes (including zero), not just sizes that\nare a multiple of 8.\n\nThis is supported in DWARF by applying both a byte size and a\nDW_AT_bit_size.\n\nThis patch adds support for this feature to integer and boolean types.\nOther base types are not handled -- for floating-point types, this\ndidn't seem to make sense, and for character types I didn't see much\nneed.  (These can be added later if desired.)\n\nI've also added support for DW_AT_data_bit_offset at the same time.  I\ndon't know whether the Zig compiler requires this, but it was\ndescribed in the same section in the DWARF standard and was easy to\nadd.\n\nA new test case is supplied, using the DWARF assembler.\n\ngdb/ChangeLog\n2020-09-23  Tom Tromey  <tom@tromey.com>\n\n\tPR symtab/25470:\n\t* value.c (unpack_long, pack_long, pack_unsigned_long): Handle bit\n\toffset and bit size.\n\t* printcmd.c (print_scalar_formatted): Handle zero-length\n\tinteger.\n\t(print_scalar_formatted): Use bit_size_differs_p.\n\t* gdbtypes.h (enum type_specific_kind) <TYPE_SPECIFIC_INT>: New\n\tconstant.\n\t(union type_specific): <int_stuff>: New member.\n\t(struct type) <bit_size_differs_p, bit_size, bit_offset>: New\n\tmethods.\n\t* gdbtypes.c (init_integer_type, init_boolean_type): Initialize\n\tTYPE_SPECIFIC_FIELD.\n\t(recursive_dump_type, copy_type_recursive): Update.\n\t* dwarf2/read.c (read_base_type): Handle DW_AT_bit_size and\n\tDW_AT_data_bit_offset.\n\ngdb/testsuite/ChangeLog\n2020-09-23  Tom Tromey  <tom@tromey.com>\n\n\t* gdb.dwarf2/intbits.exp: New file.\n\t* gdb.dwarf2/intbits.c: New file.",
    "tree": {
      "sha": "5443c2824f7d53f50d8d280f64d19f398f523f65",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5443c2824f7d53f50d8d280f64d19f398f523f65"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bac51ab78d4bee5273c7d6306ff6d41545fd5628",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bac51ab78d4bee5273c7d6306ff6d41545fd5628",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bac51ab78d4bee5273c7d6306ff6d41545fd5628"
    }
  ],
  "stats": {
    "total": 413,
    "additions": 406,
    "deletions": 7
  },
  "files": [
    {
      "sha": "241f3e7027195dc79e006a49ba690eb9371919ed",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -1,3 +1,22 @@\n+2020-09-23  Tom Tromey  <tom@tromey.com>\n+\n+\tPR symtab/25470:\n+\t* value.c (unpack_long, pack_long, pack_unsigned_long): Handle bit\n+\toffset and bit size.\n+\t* printcmd.c (print_scalar_formatted): Handle zero-length\n+\tinteger.\n+\t(print_scalar_formatted): Use bit_size_differs_p.\n+\t* gdbtypes.h (enum type_specific_kind) <TYPE_SPECIFIC_INT>: New\n+\tconstant.\n+\t(union type_specific): <int_stuff>: New member.\n+\t(struct type) <bit_size_differs_p, bit_size, bit_offset>: New\n+\tmethods.\n+\t* gdbtypes.c (init_integer_type, init_boolean_type): Initialize\n+\tTYPE_SPECIFIC_FIELD.\n+\t(recursive_dump_type, copy_type_recursive): Update.\n+\t* dwarf2/read.c (read_base_type): Handle DW_AT_bit_size and\n+\tDW_AT_data_bit_offset.\n+\n 2020-09-23  Tom Tromey  <tom@tromey.com>\n \n \t* utils.h (class gdb_argv): Add move operators."
    },
    {
      "sha": "977bdb856893b7794d4c32b1b97aef5a157aa9df",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -18054,6 +18054,26 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n \n   type->set_endianity_is_not_default (gdbarch_byte_order (arch) != byte_order);\n \n+  if (TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_INT)\n+    {\n+      attr = dwarf2_attr (die, DW_AT_bit_size, cu);\n+      if (attr != nullptr && DW_UNSND (attr) <= 8 * TYPE_LENGTH (type))\n+\t{\n+\t  unsigned real_bit_size = DW_UNSND (attr);\n+\t  attr = dwarf2_attr (die, DW_AT_data_bit_offset, cu);\n+\t  /* Only use the attributes if they make sense together.  */\n+\t  if (attr == nullptr\n+\t      || DW_UNSND (attr) + real_bit_size <= 8 * TYPE_LENGTH (type))\n+\t    {\n+\t      TYPE_MAIN_TYPE (type)->type_specific.int_stuff.bit_size\n+\t\t= real_bit_size;\n+\t      if (attr != nullptr)\n+\t\tTYPE_MAIN_TYPE (type)->type_specific.int_stuff.bit_offset\n+\t\t  = DW_UNSND (attr);\n+\t    }\n+\t}\n+    }\n+\n   return set_die_type (die, type, cu);\n }\n "
    },
    {
      "sha": "43c05d344d0b5b8265c5a065d277ab6c0951f047",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -3194,6 +3194,10 @@ init_integer_type (struct objfile *objfile,\n   if (unsigned_p)\n     t->set_is_unsigned (true);\n \n+  TYPE_SPECIFIC_FIELD (t) = TYPE_SPECIFIC_INT;\n+  TYPE_MAIN_TYPE (t)->type_specific.int_stuff.bit_size = bit;\n+  TYPE_MAIN_TYPE (t)->type_specific.int_stuff.bit_offset = 0;\n+\n   return t;\n }\n \n@@ -3228,6 +3232,10 @@ init_boolean_type (struct objfile *objfile,\n   if (unsigned_p)\n     t->set_is_unsigned (true);\n \n+  TYPE_SPECIFIC_FIELD (t) = TYPE_SPECIFIC_INT;\n+  TYPE_MAIN_TYPE (t)->type_specific.int_stuff.bit_size = bit;\n+  TYPE_MAIN_TYPE (t)->type_specific.int_stuff.bit_offset = 0;\n+\n   return t;\n }\n \n@@ -5188,6 +5196,16 @@ recursive_dump_type (struct type *type, int spaces)\n \tgdb_print_host_address (TYPE_SELF_TYPE (type), gdb_stdout);\n \tputs_filtered (\"\\n\");\n \tbreak;\n+\n+    case TYPE_SPECIFIC_INT:\n+      if (type->bit_size_differs_p ())\n+\t{\n+\t  unsigned bit_size = type->bit_size ();\n+\t  unsigned bit_off = type->bit_offset ();\n+\t  printfi_filtered (spaces, \" bit size = %u, bit offset = %u\\n\",\n+\t\t\t    bit_size, bit_off);\n+\t}\n+      break;\n     }\n \n   if (spaces == 0)\n@@ -5411,6 +5429,12 @@ copy_type_recursive (struct objfile *objfile,\n \t\t\t  copy_type_recursive (objfile, TYPE_SELF_TYPE (type),\n \t\t\t\t\t       copied_types));\n       break;\n+    case TYPE_SPECIFIC_INT:\n+      TYPE_SPECIFIC_FIELD (new_type) = TYPE_SPECIFIC_INT;\n+      TYPE_MAIN_TYPE (new_type)->type_specific.int_stuff\n+\t= TYPE_MAIN_TYPE (type)->type_specific.int_stuff;\n+      break;\n+\n     default:\n       gdb_assert_not_reached (\"bad type_specific_kind\");\n     }"
    },
    {
      "sha": "e1673658a48fc0c581308df20b30b7b0dea6ee66",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 42,
      "deletions": 1,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -599,7 +599,8 @@ enum type_specific_kind\n   TYPE_SPECIFIC_FLOATFORMAT,\n   /* Note: This is used by TYPE_CODE_FUNC and TYPE_CODE_METHOD.  */\n   TYPE_SPECIFIC_FUNC,\n-  TYPE_SPECIFIC_SELF_TYPE\n+  TYPE_SPECIFIC_SELF_TYPE,\n+  TYPE_SPECIFIC_INT\n };\n \n union type_owner\n@@ -764,6 +765,21 @@ union type_specific\n      is a member of.  */\n \n   struct type *self_type;\n+\n+  /* * An integer-like scalar type may be stored in just part of its\n+     enclosing storage bytes.  This structure describes this\n+     situation.  */\n+  struct\n+  {\n+    /* * The bit size of the integer.  This can be 0.  For integers\n+       that fill their storage (the ordinary case), this field holds\n+       the byte size times 8.  */\n+    unsigned short bit_size;\n+    /* * The bit offset of the integer.  This is ordinarily 0, and can\n+       only be non-zero if the bit size is less than the storage\n+       size.  */\n+    unsigned short bit_offset;\n+  } int_stuff;\n };\n \n /* * Main structure representing a type in GDB.\n@@ -1182,6 +1198,31 @@ struct type\n   /* * Remove dynamic property of kind KIND from this type, if it exists.  */\n   void remove_dyn_prop (dynamic_prop_node_kind kind);\n \n+  /* * Return true if this is an integer type whose logical (bit) size\n+     differs from its storage size; false otherwise.  Always return\n+     false for non-integer (i.e., non-TYPE_SPECIFIC_INT) types.  */\n+  bool bit_size_differs_p () const\n+  {\n+    return (main_type->type_specific_field == TYPE_SPECIFIC_INT\n+\t    && main_type->type_specific.int_stuff.bit_size != 8 * length);\n+  }\n+\n+  /* * Return the logical (bit) size for this integer type.  Only\n+     valid for integer (TYPE_SPECIFIC_INT) types.  */\n+  unsigned short bit_size () const\n+  {\n+    gdb_assert (main_type->type_specific_field == TYPE_SPECIFIC_INT);\n+    return main_type->type_specific.int_stuff.bit_size;\n+  }\n+\n+  /* * Return the bit offset for this integer type.  Only valid for\n+     integer (TYPE_SPECIFIC_INT) types.  */\n+  unsigned short bit_offset () const\n+  {\n+    gdb_assert (main_type->type_specific_field == TYPE_SPECIFIC_INT);\n+    return main_type->type_specific.int_stuff.bit_offset;\n+  }\n+\n   /* * Type that is a pointer to this type.\n      NULL if no such pointer-to type is known yet.\n      The debugger may add the address of such a type"
    },
    {
      "sha": "d3b1075ed8fcefcdbff5b1804b12ea8511c3eef6",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 13,
      "deletions": 3,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -374,6 +374,15 @@ print_scalar_formatted (const gdb_byte *valaddr, struct type *type,\n \tvaladdr += TYPE_LENGTH (type) - len;\n     }\n \n+  /* Allow LEN == 0, and in this case, don't assume that VALADDR is\n+     valid.  */\n+  const gdb_byte zero = 0;\n+  if (len == 0)\n+    {\n+      len = 1;\n+      valaddr = &zero;\n+    }\n+\n   if (size != 0 && (options->format == 'x' || options->format == 't'))\n     {\n       /* Truncate to fit.  */\n@@ -404,8 +413,8 @@ print_scalar_formatted (const gdb_byte *valaddr, struct type *type,\n      long, and then printing the long.  PR cli/16242 suggests changing\n      this to using C-style hex float format.\n \n-     Biased range types must also be unbiased here; the unbiasing is\n-     done by unpack_long.  */\n+     Biased range types and sub-word scalar types must also be handled\n+     here; the value is correctly computed by unpack_long.  */\n   gdb::byte_vector converted_bytes;\n   /* Some cases below will unpack the value again.  In the biased\n      range case, we want to avoid this, so we store the unpacked value\n@@ -418,7 +427,8 @@ print_scalar_formatted (const gdb_byte *valaddr, struct type *type,\n \t   || options->format == 'z'\n \t   || options->format == 'd'\n \t   || options->format == 'u'))\n-      || (type->code () == TYPE_CODE_RANGE && type->bounds ()->bias != 0))\n+      || (type->code () == TYPE_CODE_RANGE && type->bounds ()->bias != 0)\n+      || type->bit_size_differs_p ())\n     {\n       val_long.emplace (unpack_long (type, valaddr));\n       converted_bytes.resize (TYPE_LENGTH (type));"
    },
    {
      "sha": "c85f3ed9427a51e4bf714cadaf7e43b2b529dddb",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -1,3 +1,8 @@\n+2020-09-23  Tom Tromey  <tom@tromey.com>\n+\n+\t* gdb.dwarf2/intbits.exp: New file.\n+\t* gdb.dwarf2/intbits.c: New file.\n+\n 2020-09-20  Pedro Alves  <pedro@palves.net>\n \n \t* lib/mi-support.exp (mi_uncatched_gdb_exit) Switch to the main"
    },
    {
      "sha": "72b70d40903e88a46a069c08a23a898da56e4a67",
      "filename": "gdb/testsuite/gdb.dwarf2/intbits.c",
      "status": "added",
      "additions": 48,
      "deletions": 0,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/testsuite/gdb.dwarf2/intbits.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/testsuite/gdb.dwarf2/intbits.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/intbits.c?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -0,0 +1,48 @@\n+/* Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* A 16 bit slot holding a 7-bit value of -1.  Note that, for all\n+   these values, we explicitly set the endian-ness in the DWARF to\n+   avoid issues.  */\n+unsigned char i16_m1[2] = { 0x7f, 0 };\n+\n+/* A 16 bit slot holding a 1-bit value of 1 at offset 2.  */\n+unsigned char u16_1[2] = { 0x4, 0 };\n+\n+/* A 32 bit slot holding a 17-bit value of -2.  */\n+unsigned char u32_m2[4] = { 0xfe, 0xff, 0x01, 0 };\n+\n+/* A 32 bit slot holding a 31 bit value of 1.  The high bit should be\n+   ignored when reading.  */\n+unsigned char u32_1[4] = { 1, 0, 0, 0x80 };\n+\n+/* A 32 bit slot holding a 31 bit value of 1, offset by 1 bit.  */\n+unsigned char u32_1_off[4] = { 2, 0, 0, 0 };\n+\n+/* A 32 bit slot holding a 30 bit value of 1, offset by 1 bit.\n+   Big-endian.  */\n+unsigned char be30_1_off[4] = { 0x80, 0, 0, 2 };\n+\n+/* A 32 bit slot holding a 0 bit value.  We don't use 0 in the array\n+   here, to catch any situation where gdb tries to use the memory.  */\n+unsigned char u32_0[4] = { 0xff, 0xff, 0xff, 0xff };\n+\n+int\n+main (void)\n+{\n+  return 0;\n+}"
    },
    {
      "sha": "311801869e9ac4a73221169f0d258783a9bb9516",
      "filename": "gdb/testsuite/gdb.dwarf2/intbits.exp",
      "status": "added",
      "additions": 201,
      "deletions": 0,
      "changes": 201,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/testsuite/gdb.dwarf2/intbits.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/testsuite/gdb.dwarf2/intbits.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.dwarf2/intbits.exp?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -0,0 +1,201 @@\n+# Copyright 2020 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test support for non-byte-sized integer base types.\n+\n+load_lib dwarf.exp\n+\n+# This test can only be run on targets which support DWARF-2 and use gas.\n+if {![dwarf2_support]} {\n+    return 0\n+}\n+\n+standard_testfile .c .S\n+\n+set executable ${testfile}\n+set asm_file [standard_output_file ${srcfile2}]\n+\n+if [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}] {\n+    return -1\n+}\n+\n+# Create the DWARF.\n+Dwarf::assemble ${asm_file} {\n+    cu {} {\n+\tDW_TAG_compile_unit {\n+\t    {DW_AT_language @DW_LANG_C_plus_plus}\n+\t} {\n+\t    declare_labels i7_type u1_type u17_type u31_type \\\n+\t\tu31_1_type u32_0_type u0_0_type be30_1_type\n+\n+\t    i7_type: DW_TAG_base_type {\n+\t\t{DW_AT_encoding @DW_ATE_signed}\n+\t\t{DW_AT_endianity @DW_END_little}\n+\t\t{DW_AT_name \"i7\"}\n+\t\t{DW_AT_byte_size 2 DW_FORM_udata}\n+\t\t{DW_AT_bit_size 7 DW_FORM_udata}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name \"v_i16_m1\"}\n+\t\t{DW_AT_type :${i7_type}}\n+\t\t{DW_AT_external 1 DW_FORM_flag}\n+\t\t{DW_AT_location {DW_OP_addr [gdb_target_symbol \"i16_m1\"]}\n+\t\t    SPECIAL_expr}\n+\t    }\n+\n+\t    u1_type: DW_TAG_base_type {\n+\t\t{DW_AT_encoding @DW_ATE_boolean}\n+\t\t{DW_AT_endianity @DW_END_little}\n+\t\t{DW_AT_name \"u1\"}\n+\t\t{DW_AT_byte_size 2 DW_FORM_udata}\n+\t\t{DW_AT_bit_size 1 DW_FORM_udata}\n+\t\t{DW_AT_data_bit_offset 2 DW_FORM_udata}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name \"v_u16_1\"}\n+\t\t{DW_AT_type :${u1_type}}\n+\t\t{DW_AT_external 1 DW_FORM_flag}\n+\t\t{DW_AT_location {DW_OP_addr [gdb_target_symbol \"u16_1\"]}\n+\t\t    SPECIAL_expr}\n+\t    }\n+\n+\t    u17_type: DW_TAG_base_type {\n+\t\t{DW_AT_encoding @DW_ATE_signed}\n+\t\t{DW_AT_endianity @DW_END_little}\n+\t\t{DW_AT_name \"u17\"}\n+\t\t{DW_AT_byte_size 4 DW_FORM_udata}\n+\t\t{DW_AT_bit_size 17 DW_FORM_udata}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name \"v_u32_m2\"}\n+\t\t{DW_AT_type :${u17_type}}\n+\t\t{DW_AT_external 1 DW_FORM_flag}\n+\t\t{DW_AT_location {DW_OP_addr [gdb_target_symbol \"u32_m2\"]}\n+\t\t    SPECIAL_expr}\n+\t    }\n+\n+\t    u31_type: DW_TAG_base_type {\n+\t\t{DW_AT_encoding @DW_ATE_unsigned}\n+\t\t{DW_AT_endianity @DW_END_little}\n+\t\t{DW_AT_name \"u31\"}\n+\t\t{DW_AT_byte_size 4 DW_FORM_udata}\n+\t\t{DW_AT_bit_size 31 DW_FORM_udata}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name \"v_u32_1\"}\n+\t\t{DW_AT_type :${u31_type}}\n+\t\t{DW_AT_external 1 DW_FORM_flag}\n+\t\t{DW_AT_location {DW_OP_addr [gdb_target_symbol \"u32_1\"]}\n+\t\t    SPECIAL_expr}\n+\t    }\n+\n+\t    u31_1_type: DW_TAG_base_type {\n+\t\t{DW_AT_encoding @DW_ATE_unsigned}\n+\t\t{DW_AT_endianity @DW_END_little}\n+\t\t{DW_AT_name \"u31_1\"}\n+\t\t{DW_AT_byte_size 4 DW_FORM_udata}\n+\t\t{DW_AT_bit_size 31 DW_FORM_udata}\n+\t\t{DW_AT_data_bit_offset 1 DW_FORM_udata}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name \"v_u32_1_off\"}\n+\t\t{DW_AT_type :${u31_1_type}}\n+\t\t{DW_AT_external 1 DW_FORM_flag}\n+\t\t{DW_AT_location {DW_OP_addr [gdb_target_symbol \"u32_1_off\"]}\n+\t\t    SPECIAL_expr}\n+\t    }\n+\n+\t    be30_1_type: DW_TAG_base_type {\n+\t\t{DW_AT_encoding @DW_ATE_unsigned}\n+\t\t{DW_AT_endianity @DW_END_big}\n+\t\t{DW_AT_name \"be30_1\"}\n+\t\t{DW_AT_byte_size 4 DW_FORM_udata}\n+\t\t{DW_AT_bit_size 30 DW_FORM_udata}\n+\t\t{DW_AT_data_bit_offset 1 DW_FORM_udata}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name \"v_be30_1_off\"}\n+\t\t{DW_AT_type :${be30_1_type}}\n+\t\t{DW_AT_external 1 DW_FORM_flag}\n+\t\t{DW_AT_location {DW_OP_addr [gdb_target_symbol \"be30_1_off\"]}\n+\t\t    SPECIAL_expr}\n+\t    }\n+\n+\t    u32_0_type: DW_TAG_base_type {\n+\t\t{DW_AT_encoding @DW_ATE_unsigned}\n+\t\t{DW_AT_endianity @DW_END_little}\n+\t\t{DW_AT_name \"u32_0\"}\n+\t\t{DW_AT_byte_size 4 DW_FORM_udata}\n+\t\t{DW_AT_bit_size 0 DW_FORM_udata}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name \"v_u32_0\"}\n+\t\t{DW_AT_type :${u32_0_type}}\n+\t\t{DW_AT_external 1 DW_FORM_flag}\n+\t\t{DW_AT_location {DW_OP_addr [gdb_target_symbol \"u32_0\"]}\n+\t\t    SPECIAL_expr}\n+\t    }\n+\n+\t    u0_0_type: DW_TAG_base_type {\n+\t\t{DW_AT_encoding @DW_ATE_unsigned}\n+\t\t{DW_AT_endianity @DW_END_little}\n+\t\t{DW_AT_name \"u0_0\"}\n+\t\t{DW_AT_byte_size 0 DW_FORM_udata}\n+\t    }\n+\n+\t    DW_TAG_variable {\n+\t\t{DW_AT_name \"v_u0_0\"}\n+\t\t{DW_AT_type :${u0_0_type}}\n+\t\t{DW_AT_external 1 DW_FORM_flag}\n+\t\t{DW_AT_location {DW_OP_addr [gdb_target_symbol \"u32_0\"]}\n+\t\t    SPECIAL_expr}\n+\t    }\n+\t}\n+    }\n+}\n+\n+if {[prepare_for_testing \"failed to prepare\" ${executable} \\\n+\t [list ${asm_file} ${srcfile}] {}]} {\n+    return -1\n+}\n+\n+if {![runto_main]} {\n+    return -1\n+}\n+\n+gdb_test \"print v_i16_m1\" \"= -1\"\n+gdb_test \"print v_u16_1\" \"= true\"\n+gdb_test \"print v_u32_m2\" \"= -2\"\n+gdb_test \"print v_u32_1\" \"= 1\"\n+gdb_test \"print v_u32_0\" \"= 0\"\n+gdb_test \"print v_u0_0\" \"= 0\"\n+\n+gdb_test \"print v_i16_m1 = 7\" \"= 7\"\n+gdb_test \"print v_i16_m1\" \"= 7\" \"print v_i16_m1 after assignment\"\n+\n+gdb_test \"print v_u32_1_off\" \"= 1\"\n+gdb_test \"print v_u32_1_off = 7\" \" = 7\"\n+gdb_test \"x/4xb &v_u32_1_off\" \":\\t0x0e\\t0x00\\t0x00\\t0x00\"\n+\n+gdb_test \"print v_be30_1_off\" \"= 1\"\n+gdb_test \"print v_be30_1_off = 7\" \" = 7\"\n+gdb_test \"x/4xb &v_be30_1_off\" \":\\t0x00\\t0x00\\t0x00\\t0x0e\""
    },
    {
      "sha": "7c36c31dccd7b61da4a9b5e658de3218b1ccd148",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 34,
      "deletions": 3,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=20a5fcbd5b28cca88511ac5a9ad5e54251e8fa6d",
      "patch": "@@ -2776,10 +2776,27 @@ unpack_long (struct type *type, const gdb_byte *valaddr)\n     case TYPE_CODE_MEMBERPTR:\n       {\n \tLONGEST result;\n-\tif (nosign)\n-\t  result = extract_unsigned_integer (valaddr, len, byte_order);\n+\n+\tif (type->bit_size_differs_p ())\n+\t  {\n+\t    unsigned bit_off = type->bit_offset ();\n+\t    unsigned bit_size = type->bit_size ();\n+\t    if (bit_size == 0)\n+\t      {\n+\t\t/* unpack_bits_as_long doesn't handle this case the\n+\t\t   way we'd like, so handle it here.  */\n+\t\tresult = 0;\n+\t      }\n+\t    else\n+\t      result = unpack_bits_as_long (type, valaddr, bit_off, bit_size);\n+\t  }\n \telse\n-\t  result = extract_signed_integer (valaddr, len, byte_order);\n+\t  {\n+\t    if (nosign)\n+\t      result = extract_unsigned_integer (valaddr, len, byte_order);\n+\t    else\n+\t      result = extract_signed_integer (valaddr, len, byte_order);\n+\t  }\n \tif (code == TYPE_CODE_RANGE)\n \t  result += type->bounds ()->bias;\n \treturn result;\n@@ -3339,6 +3356,13 @@ pack_long (gdb_byte *buf, struct type *type, LONGEST num)\n     case TYPE_CODE_FLAGS:\n     case TYPE_CODE_BOOL:\n     case TYPE_CODE_MEMBERPTR:\n+      if (type->bit_size_differs_p ())\n+\t{\n+\t  unsigned bit_off = type->bit_offset ();\n+\t  unsigned bit_size = type->bit_size ();\n+\t  num &= ((ULONGEST) 1 << bit_size) - 1;\n+\t  num <<= bit_off;\n+\t}\n       store_signed_integer (buf, len, byte_order, num);\n       break;\n \n@@ -3381,6 +3405,13 @@ pack_unsigned_long (gdb_byte *buf, struct type *type, ULONGEST num)\n     case TYPE_CODE_BOOL:\n     case TYPE_CODE_RANGE:\n     case TYPE_CODE_MEMBERPTR:\n+      if (type->bit_size_differs_p ())\n+\t{\n+\t  unsigned bit_off = type->bit_offset ();\n+\t  unsigned bit_size = type->bit_size ();\n+\t  num &= ((ULONGEST) 1 << bit_size) - 1;\n+\t  num <<= bit_off;\n+\t}\n       store_unsigned_integer (buf, len, byte_order, num);\n       break;\n "
    }
  ]
}