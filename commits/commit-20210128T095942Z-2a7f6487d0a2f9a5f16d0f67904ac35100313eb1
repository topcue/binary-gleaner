{
  "sha": "2a7f6487d0a2f9a5f16d0f67904ac35100313eb1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MmE3ZjY0ODdkMGEyZjlhNWYxNmQwZjY3OTA0YWMzNTEwMDMxM2ViMQ==",
  "commit": {
    "author": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-01-28T09:59:42Z"
    },
    "committer": {
      "name": "Tom de Vries",
      "email": "tdevries@suse.de",
      "date": "2021-01-28T09:59:42Z"
    },
    "message": "[gdb/breakpoints] Fix longjmp master breakpoint with separate debug info\n\nWhen running test-case gdb.base/longjmp.exp with target board unix/-m32, we\nrun into:\n...\n(gdb) next^M\nWarning:^M\nCannot insert breakpoint 0.^M\nCannot access memory at address 0x7dbf7353^M\n^M\n__libc_siglongjmp (env=0x804a040 <env>, val=1) at longjmp.c:28^M\n28        longjmps++;^M\n(gdb) FAIL: gdb.base/longjmp.exp: next over longjmp(1)\n...\n\nThe failure to access memory happens in i386_get_longjmp_target and is due to\nglibc having pointer encryption (aka \"pointer mangling\" or \"pointer guard\") of\nthe long jump buffer.  This is a known problem.\n\nIn create_longjmp_master_breakpoint (which attempts to install a master\nlongjmp breakpoint) a preference scheme is present, which installs a\nprobe breakpoint if a libc:longjmp probe is present, and otherwise falls back\nto setting breakpoints at the names in the longjmp_names array.\n\nBut in fact, both the probe breakpoint and the longjmp_names breakpoints are\nset.  The latter ones are set when processing libc.so.debug, and the former\none when processing libc.so.  In other words, this is the longjmp variant of\nPR26881, which describes the same problem for master exception breakpoints.\n\nThis problem only triggers when the glibc debug info package is installed,\nwhich is not due to the debug info itself in libc.so.debug, but due to the\nminimal symbols (because create_longjmp_master_breakpoint uses minimal symbols\nto translate the longjmp_names to addresses).\n\nThe problem doesn't trigger for -m64, because there tdep->jb_pc_offset is not\nset.\n\nFix this similar to commit 1940319c0ef (the fix for PR26881): only install\nlongjmp_names breakpoints in libc.so/libc.so.debug if installing the\nlibc:longjmp probe in libc.so failed.\n\nTested on x86_64-linux.\n\ngdb/ChangeLog:\n\n2021-01-28  Tom de Vries  <tdevries@suse.de>\n\n\tPR breakpoints/27205\n\t* breakpoint.c (create_longjmp_master_breakpoint_probe)\n\t(create_longjmp_master_breakpoint_names): New function, factored out\n\tof ...\n\t(create_longjmp_master_breakpoint): ... here.  Only try to install\n\tlongjmp_names breakpoints in libc.so/libc.so.debug if installing probe\n\tbreakpoint in libc.so failed.",
    "tree": {
      "sha": "44313aee8bd7f4585023abd5cc8d5501f62e407d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/44313aee8bd7f4585023abd5cc8d5501f62e407d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2a7f6487d0a2f9a5f16d0f67904ac35100313eb1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2a7f6487d0a2f9a5f16d0f67904ac35100313eb1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2a7f6487d0a2f9a5f16d0f67904ac35100313eb1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2a7f6487d0a2f9a5f16d0f67904ac35100313eb1/comments",
  "author": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vries",
    "id": 4057235,
    "node_id": "MDQ6VXNlcjQwNTcyMzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/4057235?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vries",
    "html_url": "https://github.com/vries",
    "followers_url": "https://api.github.com/users/vries/followers",
    "following_url": "https://api.github.com/users/vries/following{/other_user}",
    "gists_url": "https://api.github.com/users/vries/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vries/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vries/subscriptions",
    "organizations_url": "https://api.github.com/users/vries/orgs",
    "repos_url": "https://api.github.com/users/vries/repos",
    "events_url": "https://api.github.com/users/vries/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vries/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "def97fb945a98544938087eff3111e16ce58da6d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/def97fb945a98544938087eff3111e16ce58da6d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/def97fb945a98544938087eff3111e16ce58da6d"
    }
  ],
  "stats": {
    "total": 192,
    "additions": 118,
    "deletions": 74
  },
  "files": [
    {
      "sha": "f16a4d61be297f4f955071f549daa84506039028",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a7f6487d0a2f9a5f16d0f67904ac35100313eb1/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a7f6487d0a2f9a5f16d0f67904ac35100313eb1/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=2a7f6487d0a2f9a5f16d0f67904ac35100313eb1",
      "patch": "@@ -1,3 +1,13 @@\n+2021-01-28  Tom de Vries  <tdevries@suse.de>\n+\n+\tPR breakpoints/27205\n+\t* breakpoint.c (create_longjmp_master_breakpoint_probe)\n+\t(create_longjmp_master_breakpoint_names): New function, factored out\n+\tof ...\n+\t(create_longjmp_master_breakpoint): ... here.  Only try to install\n+\tlongjmp_names breakpoints in libc.so/libc.so.debug if installing probe\n+\tbreakpoint in libc.so failed.\n+\n 2021-01-27  Lancelot SIX  <lsix@lancelotsix.com>\n \n \tPR gdb/27133"
    },
    {
      "sha": "70b0d88cb45aedcf24a389e6bbfcbee0c926a8c4",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 108,
      "deletions": 74,
      "changes": 182,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2a7f6487d0a2f9a5f16d0f67904ac35100313eb1/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2a7f6487d0a2f9a5f16d0f67904ac35100313eb1/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=2a7f6487d0a2f9a5f16d0f67904ac35100313eb1",
      "patch": "@@ -3327,100 +3327,134 @@ create_overlay_event_breakpoint (void)\n     }\n }\n \n-static void\n-create_longjmp_master_breakpoint (void)\n+/* Install a master longjmp breakpoint for OBJFILE using a probe.  Return\n+   true if a breakpoint was installed.  */\n+\n+static bool\n+create_longjmp_master_breakpoint_probe (objfile *objfile)\n {\n-  scoped_restore_current_program_space restore_pspace;\n+  struct gdbarch *gdbarch = objfile->arch ();\n+  struct breakpoint_objfile_data *bp_objfile_data\n+    = get_breakpoint_objfile_data (objfile);\n \n-  for (struct program_space *pspace : program_spaces)\n+  if (!bp_objfile_data->longjmp_searched)\n     {\n-      set_current_program_space (pspace);\n+      std::vector<probe *> ret\n+\t= find_probes_in_objfile (objfile, \"libc\", \"longjmp\");\n \n-      for (objfile *objfile : current_program_space->objfiles ())\n+      if (!ret.empty ())\n \t{\n-\t  int i;\n-\t  struct gdbarch *gdbarch;\n-\t  struct breakpoint_objfile_data *bp_objfile_data;\n+\t  /* We are only interested in checking one element.  */\n+\t  probe *p = ret[0];\n \n-\t  gdbarch = objfile->arch ();\n+\t  if (!p->can_evaluate_arguments ())\n+\t    {\n+\t      /* We cannot use the probe interface here,\n+\t\t because it does not know how to evaluate\n+\t\t arguments.  */\n+\t      ret.clear ();\n+\t    }\n+\t}\n+      bp_objfile_data->longjmp_probes = ret;\n+      bp_objfile_data->longjmp_searched = 1;\n+    }\n \n-\t  bp_objfile_data = get_breakpoint_objfile_data (objfile);\n+  if (bp_objfile_data->longjmp_probes.empty ())\n+    return false;\n \n-\t  if (!bp_objfile_data->longjmp_searched)\n-\t    {\n-\t      std::vector<probe *> ret\n-\t\t= find_probes_in_objfile (objfile, \"libc\", \"longjmp\");\n+  for (probe *p : bp_objfile_data->longjmp_probes)\n+    {\n+      struct breakpoint *b;\n \n-\t      if (!ret.empty ())\n-\t\t{\n-\t\t  /* We are only interested in checking one element.  */\n-\t\t  probe *p = ret[0];\n+      b = create_internal_breakpoint (gdbarch,\n+\t\t\t\t      p->get_relocated_address (objfile),\n+\t\t\t\t      bp_longjmp_master,\n+\t\t\t\t      &internal_breakpoint_ops);\n+      b->location = new_probe_location (\"-probe-stap libc:longjmp\");\n+      b->enable_state = bp_disabled;\n+    }\n \n-\t\t  if (!p->can_evaluate_arguments ())\n-\t\t    {\n-\t\t      /* We cannot use the probe interface here,\n-\t\t\t because it does not know how to evaluate\n-\t\t\t arguments.  */\n-\t\t      ret.clear ();\n-\t\t    }\n-\t\t}\n-\t      bp_objfile_data->longjmp_probes = ret;\n-\t      bp_objfile_data->longjmp_searched = 1;\n-\t    }\n+  return true;\n+}\n \n-\t  if (!bp_objfile_data->longjmp_probes.empty ())\n-\t    {\n-\t      for (probe *p : bp_objfile_data->longjmp_probes)\n-\t\t{\n-\t\t  struct breakpoint *b;\n-\n-\t\t  b = create_internal_breakpoint (gdbarch,\n-\t\t\t\t\t\t  p->get_relocated_address (objfile),\n-\t\t\t\t\t\t  bp_longjmp_master,\n-\t\t\t\t\t\t  &internal_breakpoint_ops);\n-\t\t  b->location = new_probe_location (\"-probe-stap libc:longjmp\");\n-\t\t  b->enable_state = bp_disabled;\n-\t\t}\n+/* Install master longjmp breakpoints for OBJFILE using longjmp_names.\n+   Return true if at least one breakpoint was installed.  */\n+\n+static bool\n+create_longjmp_master_breakpoint_names (objfile *objfile)\n+{\n+  struct gdbarch *gdbarch = objfile->arch ();\n+  if (!gdbarch_get_longjmp_target_p (gdbarch))\n+    return false;\n \n+  struct breakpoint_objfile_data *bp_objfile_data\n+    = get_breakpoint_objfile_data (objfile);\n+  unsigned int installed_bp = 0;\n+\n+  for (int i = 0; i < NUM_LONGJMP_NAMES; i++)\n+    {\n+      struct breakpoint *b;\n+      const char *func_name;\n+      CORE_ADDR addr;\n+      struct explicit_location explicit_loc;\n+\n+      if (msym_not_found_p (bp_objfile_data->longjmp_msym[i].minsym))\n+\tcontinue;\n+\n+      func_name = longjmp_names[i];\n+      if (bp_objfile_data->longjmp_msym[i].minsym == NULL)\n+\t{\n+\t  struct bound_minimal_symbol m;\n+\n+\t  m = lookup_minimal_symbol_text (func_name, objfile);\n+\t  if (m.minsym == NULL)\n+\t    {\n+\t      /* Prevent future lookups in this objfile.  */\n+\t      bp_objfile_data->longjmp_msym[i].minsym = &msym_not_found;\n \t      continue;\n \t    }\n+\t  bp_objfile_data->longjmp_msym[i] = m;\n+\t}\n \n-\t  if (!gdbarch_get_longjmp_target_p (gdbarch))\n-\t    continue;\n+      addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->longjmp_msym[i]);\n+      b = create_internal_breakpoint (gdbarch, addr, bp_longjmp_master,\n+\t\t\t\t      &internal_breakpoint_ops);\n+      initialize_explicit_location (&explicit_loc);\n+      explicit_loc.function_name = ASTRDUP (func_name);\n+      b->location = new_explicit_location (&explicit_loc);\n+      b->enable_state = bp_disabled;\n+      installed_bp++;\n+    }\n \n-\t  for (i = 0; i < NUM_LONGJMP_NAMES; i++)\n-\t    {\n-\t      struct breakpoint *b;\n-\t      const char *func_name;\n-\t      CORE_ADDR addr;\n-\t      struct explicit_location explicit_loc;\n+  return installed_bp > 0;\n+}\n \n-\t      if (msym_not_found_p (bp_objfile_data->longjmp_msym[i].minsym))\n-\t\tcontinue;\n+/* Create a master longjmp breakpoint.  */\n \n-\t      func_name = longjmp_names[i];\n-\t      if (bp_objfile_data->longjmp_msym[i].minsym == NULL)\n-\t\t{\n-\t\t  struct bound_minimal_symbol m;\n+static void\n+create_longjmp_master_breakpoint (void)\n+{\n+  scoped_restore_current_program_space restore_pspace;\n \n-\t\t  m = lookup_minimal_symbol_text (func_name, objfile);\n-\t\t  if (m.minsym == NULL)\n-\t\t    {\n-\t\t      /* Prevent future lookups in this objfile.  */\n-\t\t      bp_objfile_data->longjmp_msym[i].minsym = &msym_not_found;\n-\t\t      continue;\n-\t\t    }\n-\t\t  bp_objfile_data->longjmp_msym[i] = m;\n-\t\t}\n+  for (struct program_space *pspace : program_spaces)\n+    {\n+      set_current_program_space (pspace);\n \n-\t      addr = BMSYMBOL_VALUE_ADDRESS (bp_objfile_data->longjmp_msym[i]);\n-\t      b = create_internal_breakpoint (gdbarch, addr, bp_longjmp_master,\n-\t\t\t\t\t      &internal_breakpoint_ops);\n-\t      initialize_explicit_location (&explicit_loc);\n-\t      explicit_loc.function_name = ASTRDUP (func_name);\n-\t      b->location = new_explicit_location (&explicit_loc);\n-\t      b->enable_state = bp_disabled;\n-\t    }\n+      for (objfile *obj : current_program_space->objfiles ())\n+\t{\n+\t  /* Skip separate debug object, it's handled in the loop below.  */\n+\t  if (obj->separate_debug_objfile_backlink != nullptr)\n+\t    continue;\n+\n+\t  /* Try a probe kind breakpoint on main objfile.  */\n+\t  if (create_longjmp_master_breakpoint_probe (obj))\n+\t    continue;\n+\n+\t  /* Try longjmp_names kind breakpoints on main and separate_debug\n+\t     objfiles.  */\n+\t  for (objfile *debug_objfile : obj->separate_debug_objfiles ())\n+\t    if (create_longjmp_master_breakpoint_names (debug_objfile))\n+\t      break;\n \t}\n     }\n }"
    }
  ]
}