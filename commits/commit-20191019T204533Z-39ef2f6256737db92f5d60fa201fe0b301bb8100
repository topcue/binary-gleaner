{
  "sha": "39ef2f6256737db92f5d60fa201fe0b301bb8100",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzllZjJmNjI1NjczN2RiOTJmNWQ2MGZhMjAxZmUwYjMwMWJiODEwMA==",
  "commit": {
    "author": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-10-03T05:36:35Z"
    },
    "committer": {
      "name": "Christian Biesinger",
      "email": "cbiesinger@google.com",
      "date": "2019-10-19T20:45:33Z"
    },
    "message": "Replace some more qsort calls with std::sort\n\nThis has better typesafety, avoids a function pointer indirection,\nand can benefit from inlining.\n\ngdb/ChangeLog:\n\n2019-10-19  Christian Biesinger  <cbiesinger@google.com>\n\n\t* bcache.c (bcache::print_statistics): Use std::sort instead of qsort.\n\t* breakpoint.c (bp_locations_compare): Rename to...\n\t(bp_location_is_less_than): ...this, and change to std::sort semantics.\n\t(update_global_location_list): Use std::sort instead of qsort.\n\t* buildsym.c (compare_line_numbers): Rename to...\n\t(lte_is_less_than): ...this, and change to std::sort semantics.\n\t(buildsym_compunit::end_symtab_with_blockvector): Use std::sort\n\tinstead of qsort.\n\t* disasm.c (compare_lines): Rename to...\n\t(line_is_less_than): ...this, and change to std::sort semantics.\n\t(do_mixed_source_and_assembly_deprecated): Call std::sort instead\n\tof qsort.\n\t* dwarf2-frame.c (qsort_fde_cmp): Rename to...\n\t(fde_is_less_than): ...this, and change to std::sort semantics.\n\t(dwarf2_build_frame_info): Call std::sort instead of qsort.\n\t* mdebugread.c (compare_blocks):\n\t(block_is_less_than): ...this, and change to std::sort semantics.\n\t(sort_blocks): Call std::sort instead of qsort.\n\t* objfiles.c (qsort_cmp): Rename to...\n\t(sort_cmp): ...this, and change to std::sort semantics.\n\t(update_section_map): Call std::sort instead of qsort.\n\t* remote.c (compare_pnums): Remove.\n\t(map_regcache_remote_table): Call std::sort instead of qsort.\n\t* utils.c (compare_positive_ints): Remove.\n\t* utils.h (compare_positive_ints): Remove.\n\t* xcoffread.c (compare_lte): Remove.\n\t(arrange_linetable): Call std::sort instead of qsort.\n\nChange-Id: Ibcddce12a3d07448701e731b7150fa23611d86de",
    "tree": {
      "sha": "13ff1a57f5ecac08df8f0ecdc2f3544cb4d97564",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/13ff1a57f5ecac08df8f0ecdc2f3544cb4d97564"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/39ef2f6256737db92f5d60fa201fe0b301bb8100",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/39ef2f6256737db92f5d60fa201fe0b301bb8100",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/39ef2f6256737db92f5d60fa201fe0b301bb8100",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/39ef2f6256737db92f5d60fa201fe0b301bb8100/comments",
  "author": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "cbiesinger",
    "id": 1483109,
    "node_id": "MDQ6VXNlcjE0ODMxMDk=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1483109?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/cbiesinger",
    "html_url": "https://github.com/cbiesinger",
    "followers_url": "https://api.github.com/users/cbiesinger/followers",
    "following_url": "https://api.github.com/users/cbiesinger/following{/other_user}",
    "gists_url": "https://api.github.com/users/cbiesinger/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/cbiesinger/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/cbiesinger/subscriptions",
    "organizations_url": "https://api.github.com/users/cbiesinger/orgs",
    "repos_url": "https://api.github.com/users/cbiesinger/repos",
    "events_url": "https://api.github.com/users/cbiesinger/events{/privacy}",
    "received_events_url": "https://api.github.com/users/cbiesinger/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "18338fcee6c75bf0b41f803b84ae15221676f8cd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/18338fcee6c75bf0b41f803b84ae15221676f8cd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/18338fcee6c75bf0b41f803b84ae15221676f8cd"
    }
  ],
  "stats": {
    "total": 248,
    "additions": 114,
    "deletions": 134
  },
  "files": [
    {
      "sha": "d8e3fe1a2dc0005ed35b5e1ecd26b03cfa83402b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -1,3 +1,33 @@\n+2019-10-19  Christian Biesinger  <cbiesinger@google.com>\n+\n+\t* bcache.c (bcache::print_statistics): Use std::sort instead of qsort.\n+\t* breakpoint.c (bp_locations_compare): Rename to...\n+\t(bp_location_is_less_than): ...this, and change to std::sort semantics.\n+\t(update_global_location_list): Use std::sort instead of qsort.\n+\t* buildsym.c (compare_line_numbers): Rename to...\n+\t(lte_is_less_than): ...this, and change to std::sort semantics.\n+\t(buildsym_compunit::end_symtab_with_blockvector): Use std::sort\n+\tinstead of qsort.\n+\t* disasm.c (compare_lines): Rename to...\n+\t(line_is_less_than): ...this, and change to std::sort semantics.\n+\t(do_mixed_source_and_assembly_deprecated): Call std::sort instead\n+\tof qsort.\n+\t* dwarf2-frame.c (qsort_fde_cmp): Rename to...\n+\t(fde_is_less_than): ...this, and change to std::sort semantics.\n+\t(dwarf2_build_frame_info): Call std::sort instead of qsort.\n+\t* mdebugread.c (compare_blocks):\n+\t(block_is_less_than): ...this, and change to std::sort semantics.\n+\t(sort_blocks): Call std::sort instead of qsort.\n+\t* objfiles.c (qsort_cmp): Rename to...\n+\t(sort_cmp): ...this, and change to std::sort semantics.\n+\t(update_section_map): Call std::sort instead of qsort.\n+\t* remote.c (compare_pnums): Remove.\n+\t(map_regcache_remote_table): Call std::sort instead of qsort.\n+\t* utils.c (compare_positive_ints): Remove.\n+\t* utils.h (compare_positive_ints): Remove.\n+\t* xcoffread.c (compare_lte): Remove.\n+\t(arrange_linetable): Call std::sort instead of qsort.\n+\n 2019-10-19  Sergio Durigan Junior  <sergiodj@redhat.com>\n \n \t* symfile.c (init_entry_point_info): Fix typo."
    },
    {
      "sha": "3f0a63be229f08d82ebf65a8df2e685ff52288df",
      "filename": "gdb/bcache.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/bcache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/bcache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bcache.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -23,6 +23,8 @@\n #include \"gdb_obstack.h\"\n #include \"bcache.h\"\n \n+#include <algorithm>\n+\n /* The type used to hold a single bcache string.  The user data is\n    stored in d.data.  Since it can be any type, it needs to have the\n    same alignment as the most strict alignment of any type on the host\n@@ -311,10 +313,8 @@ bcache::print_statistics (const char *type)\n \n     /* To compute the median, we need the set of chain lengths\n        sorted.  */\n-    qsort (chain_length, m_num_buckets, sizeof (chain_length[0]),\n-\t   compare_positive_ints);\n-    qsort (entry_size, m_unique_count, sizeof (entry_size[0]),\n-\t   compare_positive_ints);\n+    std::sort (chain_length, chain_length + m_num_buckets);\n+    std::sort (entry_size, entry_size + m_unique_count);\n \n     if (m_num_buckets > 0)\n       {"
    },
    {
      "sha": "c9587ffe95a96c53ca795e3479ca5c5efbabe7d0",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 12,
      "deletions": 17,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -519,7 +519,7 @@ bool target_exact_watchpoints = false;\n \n static struct breakpoint *breakpoint_chain;\n \n-/* Array is sorted by bp_locations_compare - primarily by the ADDRESS.  */\n+/* Array is sorted by bp_location_is_less_than - primarily by the ADDRESS.  */\n \n static struct bp_location **bp_locations;\n \n@@ -773,7 +773,7 @@ show_condition_evaluation_mode (struct ui_file *file, int from_tty,\n \n /* A comparison function for bp_location AP and BP that is used by\n    bsearch.  This comparison function only cares about addresses, unlike\n-   the more general bp_locations_compare function.  */\n+   the more general bp_location_is_less_than function.  */\n \n static int\n bp_locations_compare_addrs (const void *ap, const void *bp)\n@@ -11428,41 +11428,36 @@ breakpoint_auto_delete (bpstat bs)\n }\n \n /* A comparison function for bp_location AP and BP being interfaced to\n-   qsort.  Sort elements primarily by their ADDRESS (no matter what\n+   std::sort.  Sort elements primarily by their ADDRESS (no matter what\n    bl_address_is_meaningful says), secondarily by ordering first\n    permanent elements and terciarily just ensuring the array is sorted\n-   stable way despite qsort being an unstable algorithm.  */\n+   stable way despite std::sort being an unstable algorithm.  */\n \n static int\n-bp_locations_compare (const void *ap, const void *bp)\n+bp_location_is_less_than (const bp_location *a, const bp_location *b)\n {\n-  const struct bp_location *a = *(const struct bp_location **) ap;\n-  const struct bp_location *b = *(const struct bp_location **) bp;\n-\n   if (a->address != b->address)\n-    return (a->address > b->address) - (a->address < b->address);\n+    return a->address < b->address;\n \n   /* Sort locations at the same address by their pspace number, keeping\n      locations of the same inferior (in a multi-inferior environment)\n      grouped.  */\n \n   if (a->pspace->num != b->pspace->num)\n-    return ((a->pspace->num > b->pspace->num)\n-\t    - (a->pspace->num < b->pspace->num));\n+    return a->pspace->num < b->pspace->num;\n \n   /* Sort permanent breakpoints first.  */\n   if (a->permanent != b->permanent)\n-    return (a->permanent < b->permanent) - (a->permanent > b->permanent);\n+    return a->permanent > b->permanent;\n \n   /* Make the internal GDB representation stable across GDB runs\n      where A and B memory inside GDB can differ.  Breakpoint locations of\n      the same type at the same address can be sorted in arbitrary order.  */\n \n   if (a->owner->number != b->owner->number)\n-    return ((a->owner->number > b->owner->number)\n-\t    - (a->owner->number < b->owner->number));\n+    return a->owner->number < b->owner->number;\n \n-  return (a > b) - (a < b);\n+  return a < b;\n }\n \n /* Set bp_locations_placed_address_before_address_max and\n@@ -11677,8 +11672,8 @@ update_global_location_list (enum ugll_insert_mode insert_mode)\n   ALL_BREAKPOINTS (b)\n     for (loc = b->loc; loc; loc = loc->next)\n       *locp++ = loc;\n-  qsort (bp_locations, bp_locations_count, sizeof (*bp_locations),\n-\t bp_locations_compare);\n+  std::sort (bp_locations, bp_locations + bp_locations_count,\n+\t     bp_location_is_less_than);\n \n   bp_locations_target_extensions_update ();\n "
    },
    {
      "sha": "954a6106c6aecb75f52401e9038375a79c525091",
      "filename": "gdb/buildsym.c",
      "status": "modified",
      "additions": 11,
      "deletions": 15,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/buildsym.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/buildsym.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/buildsym.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -49,8 +49,6 @@ struct pending_block\n     struct block *block;\n   };\n \n-static int compare_line_numbers (const void *ln1p, const void *ln2p);\n-\n /* Initial sizes of data structures.  These are realloc'd larger if\n    needed, and realloc'd down to the size actually used, when\n    completed.  */\n@@ -729,23 +727,20 @@ buildsym_compunit::record_line (struct subfile *subfile, int line,\n \n /* Needed in order to sort line tables from IBM xcoff files.  Sigh!  */\n \n-static int\n-compare_line_numbers (const void *ln1p, const void *ln2p)\n+static bool\n+lte_is_less_than (const linetable_entry &ln1, const linetable_entry &ln2)\n {\n-  struct linetable_entry *ln1 = (struct linetable_entry *) ln1p;\n-  struct linetable_entry *ln2 = (struct linetable_entry *) ln2p;\n-\n   /* Note: this code does not assume that CORE_ADDRs can fit in ints.\n      Please keep it that way.  */\n-  if (ln1->pc < ln2->pc)\n-    return -1;\n+  if (ln1.pc < ln2.pc)\n+    return true;\n \n-  if (ln1->pc > ln2->pc)\n-    return 1;\n+  if (ln1.pc > ln2.pc)\n+    return false;\n \n   /* If pc equal, sort by line.  I'm not sure whether this is optimum\n      behavior (see comment at struct linetable in symtab.h).  */\n-  return ln1->line - ln2->line;\n+  return ln1.line < ln2.line;\n }\n \f\n /* Subroutine of end_symtab to simplify it.  Look for a subfile that\n@@ -968,9 +963,10 @@ buildsym_compunit::end_symtab_with_blockvector (struct block *static_block,\n \t     scrambled in reordered executables.  Sort it if\n \t     OBJF_REORDERED is true.  */\n \t  if (m_objfile->flags & OBJF_REORDERED)\n-\t    qsort (subfile->line_vector->item,\n-\t\t   subfile->line_vector->nitems,\n-\t\t   sizeof (struct linetable_entry), compare_line_numbers);\n+\t    std::sort (subfile->line_vector->item,\n+\t\t       subfile->line_vector->item\n+\t\t\t + subfile->line_vector->nitems,\n+\t\t       lte_is_less_than);\n \t}\n \n       /* Allocate a symbol table if necessary.  */"
    },
    {
      "sha": "164939b58826ded1b08455b22b2e558188676275",
      "filename": "gdb/disasm.c",
      "status": "modified",
      "additions": 14,
      "deletions": 16,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/disasm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/disasm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/disasm.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -163,28 +163,27 @@ gdb_disassembler::dis_asm_print_address (bfd_vma addr,\n   print_address (self->arch (), addr, self->stream ());\n }\n \n-static int\n-compare_lines (const void *mle1p, const void *mle2p)\n+static bool\n+line_is_less_than (const deprecated_dis_line_entry &mle1,\n+\t\t   const deprecated_dis_line_entry &mle2)\n {\n-  struct deprecated_dis_line_entry *mle1, *mle2;\n-  int val;\n-\n-  mle1 = (struct deprecated_dis_line_entry *) mle1p;\n-  mle2 = (struct deprecated_dis_line_entry *) mle2p;\n+  bool val;\n \n   /* End of sequence markers have a line number of 0 but don't want to\n      be sorted to the head of the list, instead sort by PC.  */\n-  if (mle1->line == 0 || mle2->line == 0)\n+  if (mle1.line == 0 || mle2.line == 0)\n     {\n-      val = mle1->start_pc - mle2->start_pc;\n-      if (val == 0)\n-        val = mle1->line - mle2->line;\n+      if (mle1.start_pc != mle2.start_pc)\n+\tval = mle1.start_pc < mle2.start_pc;\n+    else\n+        val = mle1.line < mle2.line;\n     }\n   else\n     {\n-      val = mle1->line - mle2->line;\n-      if (val == 0)\n-        val = mle1->start_pc - mle2->start_pc;\n+      if (mle1.line != mle2.line)\n+\tval = mle1.line < mle2.line;\n+      else\n+        val = mle1.start_pc < mle2.start_pc;\n     }\n   return val;\n }\n@@ -404,8 +403,7 @@ do_mixed_source_and_assembly_deprecated\n   /* Now, sort mle by line #s (and, then by addresses within lines).  */\n \n   if (out_of_order)\n-    qsort (mle, newlines, sizeof (struct deprecated_dis_line_entry),\n-\t   compare_lines);\n+    std::sort (mle, mle + newlines, line_is_less_than);\n \n   /* Now, for each line entry, emit the specified lines (unless\n      they have been emitted before), followed by the assembly code"
    },
    {
      "sha": "45af947c8e5325f03d0e6419951bcea30e575ece",
      "filename": "gdb/dwarf2-frame.c",
      "status": "modified",
      "additions": 9,
      "deletions": 10,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/dwarf2-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/dwarf2-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2-frame.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -44,6 +44,8 @@\n #include \"selftest-arch.h\"\n #endif\n \n+#include <algorithm>\n+\n struct comp_unit;\n \n /* Call Frame Information (CFI).  */\n@@ -2181,25 +2183,22 @@ Corrupt data in %s:%s; align 8 workaround apparently succeeded\"),\n   return ret;\n }\n \f\n-static int\n-qsort_fde_cmp (const void *a, const void *b)\n+static bool\n+fde_is_less_than (const dwarf2_fde *aa, const dwarf2_fde *bb)\n {\n-  struct dwarf2_fde *aa = *(struct dwarf2_fde **)a;\n-  struct dwarf2_fde *bb = *(struct dwarf2_fde **)b;\n-\n   if (aa->initial_location == bb->initial_location)\n     {\n       if (aa->address_range != bb->address_range\n           && aa->eh_frame_p == 0 && bb->eh_frame_p == 0)\n         /* Linker bug, e.g. gold/10400.\n            Work around it by keeping stable sort order.  */\n-        return (a < b) ? -1 : 1;\n+        return aa < bb;\n       else\n         /* Put eh_frame entries after debug_frame ones.  */\n-        return aa->eh_frame_p - bb->eh_frame_p;\n+        return aa->eh_frame_p < bb->eh_frame_p;\n     }\n \n-  return (aa->initial_location < bb->initial_location) ? -1 : 1;\n+  return aa->initial_location < bb->initial_location;\n }\n \n void\n@@ -2347,8 +2346,8 @@ dwarf2_build_frame_info (struct objfile *objfile)\n       int i;\n \n       /* Prepare FDE table for lookups.  */\n-      qsort (fde_table.entries, fde_table.num_entries,\n-             sizeof (fde_table.entries[0]), qsort_fde_cmp);\n+      std::sort (fde_table.entries, fde_table.entries + fde_table.num_entries,\n+\t\t fde_is_less_than);\n \n       /* Check for leftovers from --gc-sections.  The GNU linker sets\n \t the relevant symbols to zero, but doesn't zero the FDE *end*"
    },
    {
      "sha": "d53d57f13674472f6ee0f3bc6959a29a60be1834",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -68,6 +68,8 @@\n \n #include \"expression.h\"\n \n+#include <algorithm>\n+\n /* Provide a way to test if we have both ECOFF and ELF symbol tables.\n    We use this define in order to know whether we should override a \n    symbol's ECOFF section with its ELF section.  This is necessary in \n@@ -4560,17 +4562,16 @@ add_line (struct linetable *lt, int lineno, CORE_ADDR adr, int last)\n \n /* Blocks with a smaller low bound should come first.  */\n \n-static int\n-compare_blocks (const void *arg1, const void *arg2)\n+static bool\n+block_is_less_than (const struct block *b1, const struct block *b2)\n {\n-  LONGEST addr_diff;\n-  struct block **b1 = (struct block **) arg1;\n-  struct block **b2 = (struct block **) arg2;\n-\n-  addr_diff = (BLOCK_START ((*b1))) - (BLOCK_START ((*b2)));\n-  if (addr_diff == 0)\n-    return (BLOCK_END ((*b2))) - (BLOCK_END ((*b1)));\n-  return addr_diff;\n+  CORE_ADDR start1 = BLOCK_START (b1);\n+  CORE_ADDR start2 = BLOCK_START (b2);\n+\n+  if (start1 != start2)\n+    return start1 < start2;\n+\n+  return (BLOCK_END (b2)) < (BLOCK_END (b1));\n }\n \n /* Sort the blocks of a symtab S.\n@@ -4600,10 +4601,9 @@ sort_blocks (struct symtab *s)\n    * to detect -O3 images in advance.\n    */\n   if (BLOCKVECTOR_NBLOCKS (bv) > FIRST_LOCAL_BLOCK + 1)\n-    qsort (&BLOCKVECTOR_BLOCK (bv, FIRST_LOCAL_BLOCK),\n-\t   BLOCKVECTOR_NBLOCKS (bv) - FIRST_LOCAL_BLOCK,\n-\t   sizeof (struct block *),\n-\t   compare_blocks);\n+    std::sort (&BLOCKVECTOR_BLOCK (bv, FIRST_LOCAL_BLOCK),\n+\t       &BLOCKVECTOR_BLOCK (bv, BLOCKVECTOR_NBLOCKS (bv)),\n+\t       block_is_less_than);\n \n   {\n     CORE_ADDR high = 0;"
    },
    {
      "sha": "f1e708de0fd8947faf41eca32d0bad00ccf907db",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 12,
      "deletions": 14,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -1019,18 +1019,16 @@ have_minimal_symbols (void)\n \n /* Qsort comparison function.  */\n \n-static int\n-qsort_cmp (const void *a, const void *b)\n+static bool\n+sort_cmp (const struct obj_section *sect1, const obj_section *sect2)\n {\n-  const struct obj_section *sect1 = *(const struct obj_section **) a;\n-  const struct obj_section *sect2 = *(const struct obj_section **) b;\n   const CORE_ADDR sect1_addr = obj_section_addr (sect1);\n   const CORE_ADDR sect2_addr = obj_section_addr (sect2);\n \n   if (sect1_addr < sect2_addr)\n-    return -1;\n+    return true;\n   else if (sect1_addr > sect2_addr)\n-    return 1;\n+    return false;\n   else\n     {\n       /* Sections are at the same address.  This could happen if\n@@ -1047,12 +1045,12 @@ qsort_cmp (const void *a, const void *b)\n \t  /* Case A.  The ordering doesn't matter: separate debuginfo files\n \t     will be filtered out later.  */\n \n-\t  return 0;\n+\t  return false;\n \t}\n \n       /* Case B.  Maintain stable sort order, so bugs in GDB are easier to\n \t triage.  This section could be slow (since we iterate over all\n-\t objfiles in each call to qsort_cmp), but this shouldn't happen\n+\t objfiles in each call to sort_cmp), but this shouldn't happen\n \t very often (GDB is already in a confused state; one hopes this\n \t doesn't happen at all).  If you discover that significant time is\n \t spent in the loops below, do 'set complaints 100' and examine the\n@@ -1067,9 +1065,9 @@ qsort_cmp (const void *a, const void *b)\n \n \t  ALL_OBJFILE_OSECTIONS (objfile1, osect)\n \t    if (osect == sect1)\n-\t      return -1;\n+\t      return true;\n \t    else if (osect == sect2)\n-\t      return 1;\n+\t      return false;\n \n \t  /* We should have found one of the sections before getting here.  */\n \t  gdb_assert_not_reached (\"section not found\");\n@@ -1080,9 +1078,9 @@ qsort_cmp (const void *a, const void *b)\n \n \t  for (objfile *objfile : current_program_space->objfiles ())\n \t    if (objfile == objfile1)\n-\t      return -1;\n+\t      return true;\n \t    else if (objfile == objfile2)\n-\t      return 1;\n+\t      return false;\n \n \t  /* We should have found one of the objfiles before getting here.  */\n \t  gdb_assert_not_reached (\"objfile not found\");\n@@ -1091,7 +1089,7 @@ qsort_cmp (const void *a, const void *b)\n \n   /* Unreachable.  */\n   gdb_assert_not_reached (\"unexpected code path\");\n-  return 0;\n+  return false;\n }\n \n /* Select \"better\" obj_section to keep.  We prefer the one that came from\n@@ -1283,7 +1281,7 @@ update_section_map (struct program_space *pspace,\n       if (insert_section_p (objfile->obfd, s->the_bfd_section))\n \tmap[i++] = s;\n \n-  qsort (map, alloc_size, sizeof (*map), qsort_cmp);\n+  std::sort (map, map + alloc_size, sort_cmp);\n   map_size = filter_debuginfo_sections(map, alloc_size);\n   map_size = filter_overlapping_sections(map, map_size);\n "
    },
    {
      "sha": "4e2f82a68d5dc3551c843164d6d87dcde5f991e8",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 4,
      "deletions": 18,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -75,6 +75,7 @@\n #include \"gdbsupport/scoped_restore.h\"\n #include \"gdbsupport/environ.h\"\n #include \"gdbsupport/byte-vector.h\"\n+#include <algorithm>\n #include <unordered_map>\n \n /* The remote target.  */\n@@ -1275,22 +1276,6 @@ show_remote_exec_file (struct ui_file *file, int from_tty,\n   fprintf_filtered (file, \"%s\\n\", remote_exec_file_var);\n }\n \n-static int\n-compare_pnums (const void *lhs_, const void *rhs_)\n-{\n-  const struct packet_reg * const *lhs\n-    = (const struct packet_reg * const *) lhs_;\n-  const struct packet_reg * const *rhs\n-    = (const struct packet_reg * const *) rhs_;\n-\n-  if ((*lhs)->pnum < (*rhs)->pnum)\n-    return -1;\n-  else if ((*lhs)->pnum == (*rhs)->pnum)\n-    return 0;\n-  else\n-    return 1;\n-}\n-\n static int\n map_regcache_remote_table (struct gdbarch *gdbarch, struct packet_reg *regs)\n {\n@@ -1321,8 +1306,9 @@ map_regcache_remote_table (struct gdbarch *gdbarch, struct packet_reg *regs)\n     if (regs[regnum].pnum != -1)\n       remote_regs[num_remote_regs++] = &regs[regnum];\n \n-  qsort (remote_regs, num_remote_regs, sizeof (struct packet_reg *),\n-\t compare_pnums);\n+  std::sort (remote_regs, remote_regs + num_remote_regs,\n+\t     [] (const packet_reg *a, const packet_reg *b)\n+\t      { return a->pnum < b->pnum; });\n \n   for (regnum = 0, offset = 0; regnum < num_remote_regs; regnum++)\n     {"
    },
    {
      "sha": "3afb8e5945f5b15d49b0c815d05d13c9467330a5",
      "filename": "gdb/utils.c",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/utils.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -3050,14 +3050,6 @@ gdb_argv::reset (const char *s)\n   m_argv = argv;\n }\n \n-int\n-compare_positive_ints (const void *ap, const void *bp)\n-{\n-  /* Because we know we're comparing two ints which are positive,\n-     there's no danger of overflow here.  */\n-  return * (int *) ap - * (int *) bp;\n-}\n-\n #define AMBIGUOUS_MESS1\t\".\\nMatching formats:\"\n #define AMBIGUOUS_MESS2\t\\\n   \".\\nUse \\\"set gnutarget format-name\\\" to specify the format.\""
    },
    {
      "sha": "af8b461b6e1529df16e630275e77d60b224a1a83",
      "filename": "gdb/utils.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/utils.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/utils.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/utils.h?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -101,8 +101,6 @@ extern int streq_hash (const void *, const void *);\n \n extern int subset_compare (const char *, const char *);\n \n-int compare_positive_ints (const void *ap, const void *bp);\n-\n /* Compare C strings for std::sort.  */\n \n static inline bool"
    },
    {
      "sha": "bc4877389b0f1ce7e0c84388298cdb1c2df39180",
      "filename": "gdb/xcoffread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 16,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/xcoffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/39ef2f6256737db92f5d60fa201fe0b301bb8100/gdb/xcoffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xcoffread.c?ref=39ef2f6256737db92f5d60fa201fe0b301bb8100",
      "patch": "@@ -28,6 +28,7 @@\n #include <sys/file.h>\n #endif\n #include <sys/stat.h>\n+#include <algorithm>\n \n #include \"coff/internal.h\"\n #include \"libcoff.h\"\t\t/* FIXME, internal data from BFD */\n@@ -234,8 +235,6 @@ static void read_xcoff_symtab (struct objfile *, struct partial_symtab *);\n static void add_stab_to_list (char *, struct pending_stabs **);\n #endif\n \n-static int compare_lte (const void *, const void *);\n-\n static struct linetable *arrange_linetable (struct linetable *);\n \n static void record_include_end (struct coff_symbol *);\n@@ -407,18 +406,6 @@ add_stab_to_list (char *stabname, struct pending_stabs **stabvector)\n /* *INDENT-ON* */\n \n \n-\n-/* compare line table entry addresses.  */\n-\n-static int\n-compare_lte (const void *lte1p, const void *lte2p)\n-{\n-  struct linetable_entry *lte1 = (struct linetable_entry *) lte1p;\n-  struct linetable_entry *lte2 = (struct linetable_entry *) lte2p;\n-\n-  return lte1->pc - lte2->pc;\n-}\n-\n /* Given a line table with function entries are marked, arrange its\n    functions in ascending order and strip off function entry markers\n    and return it in a newly created table.  If the old one is good\n@@ -471,8 +458,9 @@ arrange_linetable (struct linetable *oldLineTb)\n       return oldLineTb;\n     }\n   else if (function_count > 1)\n-    qsort (fentry, function_count,\n-\t   sizeof (struct linetable_entry), compare_lte);\n+    std::sort (fentry, fentry + function_count,\n+\t       [] (const linetable_entry &lte1, const linetable_entry& lte2)\n+\t        { return lte1.pc < lte2.pc; });\n \n   /* Allocate a new line table.  */\n   newLineTb = (struct linetable *)"
    }
  ]
}