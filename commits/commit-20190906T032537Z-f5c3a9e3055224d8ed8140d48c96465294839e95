{
  "sha": "f5c3a9e3055224d8ed8140d48c96465294839e95",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjVjM2E5ZTMwNTUyMjRkOGVkODE0MGQ0OGM5NjQ2NTI5NDgzOWU5NQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-06T02:53:41Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-09-06T03:25:37Z"
    },
    "message": "beos.em qsort predicate tidy\n\nlang_input_section_type** is better than lang_statement_union_type**\nhere since that is in fact the type passed to the qsort predicate,\nand I think it's worth factoring out the common indirections.\n\n\t* emultempl/beos.em (sort_by_file_name): Use appropriate\n\tintermediary variables.\n\t(sort_by_section_name): Likewise.",
    "tree": {
      "sha": "0e20f57b81079c94d9a11dcda841b6ddce7f348e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0e20f57b81079c94d9a11dcda841b6ddce7f348e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f5c3a9e3055224d8ed8140d48c96465294839e95",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5c3a9e3055224d8ed8140d48c96465294839e95",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f5c3a9e3055224d8ed8140d48c96465294839e95",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f5c3a9e3055224d8ed8140d48c96465294839e95/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b16c44debcf8a446e94e161e328169f5c8d5d811",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b16c44debcf8a446e94e161e328169f5c8d5d811",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b16c44debcf8a446e94e161e328169f5c8d5d811"
    }
  ],
  "stats": {
    "total": 59,
    "additions": 30,
    "deletions": 29
  },
  "files": [
    {
      "sha": "84a15d6fa306670d09cbf6b4bef217b00443fa8c",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5c3a9e3055224d8ed8140d48c96465294839e95/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5c3a9e3055224d8ed8140d48c96465294839e95/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=f5c3a9e3055224d8ed8140d48c96465294839e95",
      "patch": "@@ -1,3 +1,9 @@\n+2019-09-06  Alan Modra  <amodra@gmail.com>\n+\n+\t* emultempl/beos.em (sort_by_file_name): Use appropriate\n+\tintermediary variables.\n+\t(sort_by_section_name): Likewise.\n+\n 2019-09-06  Alan Modra  <amodra@gmail.com>\n \n \t* emultempl/elf32.em (gld${EMULATION_NAME}_search_needed): Constify"
    },
    {
      "sha": "3ec285ba34bf8f5ed4022bfb3b941d35617b43f3",
      "filename": "ld/emultempl/beos.em",
      "status": "modified",
      "additions": 24,
      "deletions": 29,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f5c3a9e3055224d8ed8140d48c96465294839e95/ld/emultempl/beos.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f5c3a9e3055224d8ed8140d48c96465294839e95/ld/emultempl/beos.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/beos.em?ref=f5c3a9e3055224d8ed8140d48c96465294839e95",
      "patch": "@@ -393,17 +393,18 @@ gld_${EMULATION_NAME}_after_open (void)\n static int\n sort_by_file_name (const void *a, const void *b)\n {\n-  const lang_statement_union_type *const *ra = a;\n-  const lang_statement_union_type *const *rb = b;\n+  const lang_input_section_type *const *ra = a;\n+  const lang_input_section_type *const *rb = b;\n+  asection *sa = (*ra)->section;\n+  asection *sb = (*rb)->section;\n   int i, a_sec, b_sec;\n \n-  i = filename_cmp ((*ra)->input_section.section->owner->my_archive->filename,\n-\t\t    (*rb)->input_section.section->owner->my_archive->filename);\n+  i = filename_cmp (sa->owner->my_archive->filename,\n+\t\t    sb->owner->my_archive->filename);\n   if (i != 0)\n     return i;\n \n-  i = filename_cmp ((*ra)->input_section.section->owner->filename,\n-\t\t    (*rb)->input_section.section->owner->filename);\n+  i = filename_cmp (sa->owner->filename, sb->owner->filename);\n   if (i != 0)\n     return i;\n   /* the tail idata4/5 are the only ones without relocs to an\n@@ -412,36 +413,29 @@ sort_by_file_name (const void *a, const void *b)\n      and HNT properly. if no reloc this one is import by ordinal\n      so we have to sort by section contents */\n \n-  if ((*ra)->input_section.section->reloc_count\n-      + (*rb)->input_section.section->reloc_count)\n+  if (sa->reloc_count + sb->reloc_count != 0)\n     {\n-      i = ((*ra)->input_section.section->reloc_count\n-\t   > (*rb)->input_section.section->reloc_count) ? -1 : 0;\n+      i = sa->reloc_count > sb->reloc_count ? -1 : 0;\n       if (i != 0)\n \treturn i;\n \n-      return ((*ra)->input_section.section->reloc_count\n-\t      > (*rb)->input_section.section->reloc_count) ? 0 : 1;\n+      return sa->reloc_count > sb->reloc_count ? 0 : 1;\n     }\n   else\n     {\n       /* don't sort .idata$6 or .idata$7 FIXME dlltool eliminate .idata$7 */\n-      if ((strcmp ((*ra)->input_section.section->name, \".idata$6\") == 0))\n+      if ((strcmp (sa->name, \".idata$6\") == 0))\n \treturn 0;\n \n-      if (!bfd_get_section_contents ((*ra)->input_section.section->owner,\n-\t\t\t\t     (*ra)->input_section.section, &a_sec,\n-\t\t\t\t     (file_ptr) 0,\n-\t\t\t\t     (bfd_size_type) sizeof(a_sec)))\n+      if (!bfd_get_section_contents (sa->owner, sa, &a_sec, (file_ptr) 0,\n+\t\t\t\t     (bfd_size_type) sizeof (a_sec)))\n \teinfo (_(\"%F%P: %pB: can't read contents of section .idata: %E\\n\"),\n-\t       (*ra)->input_section.section->owner);\n+\t       sa->owner);\n \n-      if (!bfd_get_section_contents ((*rb)->input_section.section->owner,\n-\t\t\t\t     (*rb)->input_section.section, &b_sec,\n-\t\t\t\t     (file_ptr) 0,\n-\t\t\t\t     (bfd_size_type) sizeof(b_sec)))\n+      if (!bfd_get_section_contents (sb->owner, sb, &b_sec, (file_ptr) 0,\n+\t\t\t\t     (bfd_size_type) sizeof (b_sec)))\n \teinfo (_(\"%F%P: %pB: can't read contents of section .idata: %E\\n\"),\n-\t       (*rb)->input_section.section->owner);\n+\t       sb->owner);\n \n       i = a_sec < b_sec ? -1 : 0;\n       if (i != 0)\n@@ -454,18 +448,19 @@ sort_by_file_name (const void *a, const void *b)\n static int\n sort_by_section_name (const void *a, const void *b)\n {\n-  const lang_statement_union_type *const *ra = a;\n-  const lang_statement_union_type *const *rb = b;\n+  const lang_input_section_type *const *ra = a;\n+  const lang_input_section_type *const *rb = b;\n+  const char *sna = (*ra)->section->name;\n+  const char *snb = (*rb)->section->name;\n   int i;\n-  i = strcmp ((*ra)->input_section.section->name,\n-\t      (*rb)->input_section.section->name);\n+  i = strcmp (sna, snb);\n   /* This is a hack to make .stab and .stabstr last, so we don't have\n      to fix strip/objcopy for .reloc sections.\n      FIXME stripping images with a .rsrc section still needs to be fixed.  */\n   if (i != 0)\n     {\n-      if ((CONST_STRNEQ ((*ra)->input_section.section->name, \".stab\"))\n-\t  && (! CONST_STRNEQ ((*rb)->input_section.section->name, \".stab\")))\n+      if ((CONST_STRNEQ (sna, \".stab\"))\n+\t  && (!CONST_STRNEQ (snb, \".stab\")))\n \treturn 1;\n     }\n   return i;"
    }
  ]
}