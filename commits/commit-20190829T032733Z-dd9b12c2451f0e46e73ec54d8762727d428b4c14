{
  "sha": "dd9b12c2451f0e46e73ec54d8762727d428b4c14",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGQ5YjEyYzI0NTFmMGU0NmU3M2VjNTRkODc2MjcyN2Q0MjhiNGMxNA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-08-29T02:00:11Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-08-29T03:27:33Z"
    },
    "message": "PowerPC64 xlate_pcrel_opt\n\nWe can easily support an offset on the second instruction of a\nsequence marked with R_PPC64_PCREL_OPT.  For example,\n  pla ra,symbol@pcrel\n  ld rt,off(ra)\ncan be optimised to\n  pld rt,symbol+off@pcrel\n  nop\n\n\t* elf64-ppc.c (xlate_pcrel_opt): Add poff parameter.  Allow offset\n\ton second insn, return it in poff.\n\t(ppc64_elf_relocate_section): Add offset to paddi addend for\n\tPCREL_OPT.",
    "tree": {
      "sha": "16eaf6d814475f3b04a3edd5319852d19aacbfa1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/16eaf6d814475f3b04a3edd5319852d19aacbfa1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/dd9b12c2451f0e46e73ec54d8762727d428b4c14",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dd9b12c2451f0e46e73ec54d8762727d428b4c14",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/dd9b12c2451f0e46e73ec54d8762727d428b4c14",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/dd9b12c2451f0e46e73ec54d8762727d428b4c14/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "507685a390b47d853f22176273cb949e2ee8da81",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/507685a390b47d853f22176273cb949e2ee8da81",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/507685a390b47d853f22176273cb949e2ee8da81"
    }
  ],
  "stats": {
    "total": 48,
    "additions": 29,
    "deletions": 19
  },
  "files": [
    {
      "sha": "e604dc75f8e31a482ceab1306faab42800a953e6",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dd9b12c2451f0e46e73ec54d8762727d428b4c14/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dd9b12c2451f0e46e73ec54d8762727d428b4c14/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=dd9b12c2451f0e46e73ec54d8762727d428b4c14",
      "patch": "@@ -1,3 +1,10 @@\n+2019-08-29  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf64-ppc.c (xlate_pcrel_opt): Add poff parameter.  Allow offset\n+\ton second insn, return it in poff.\n+\t(ppc64_elf_relocate_section): Add offset to paddi addend for\n+\tPCREL_OPT.\n+\n 2019-08-28  Jim Wilson  <jimw@sifive.com>\n \n \t* elfnn-riscv.c (_bfd_riscv_relax_lui): Add check to exclude abs"
    },
    {
      "sha": "a5bd3426ee4727f597fe7ec87f06b42221725b01",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 22,
      "deletions": 19,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/dd9b12c2451f0e46e73ec54d8762727d428b4c14/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/dd9b12c2451f0e46e73ec54d8762727d428b4c14/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=dd9b12c2451f0e46e73ec54d8762727d428b4c14",
      "patch": "@@ -8265,25 +8265,26 @@ ok_lo_toc_insn (unsigned int insn, enum elf_ppc64_reloc_type r_type)\n \n /* PCREL_OPT in one instance flags to the linker that a pair of insns:\n      pld ra,symbol@got@pcrel\n-     load/store rt,0(ra)\n+     load/store rt,off(ra)\n    or\n      pla ra,symbol@pcrel\n-     load/store rt,0(ra)\n+     load/store rt,off(ra)\n    may be translated to\n-     pload/pstore rt,symbol@pcrel\n+     pload/pstore rt,symbol+off@pcrel\n      nop.\n    This function returns true if the optimization is possible, placing\n-   the prefix insn in *PINSN1 and a NOP in *PINSN2.\n+   the prefix insn in *PINSN1, a NOP in *PINSN2 and the offset in *POFF.\n \n    On entry to this function, the linker has already determined that\n    the pld can be replaced with pla: *PINSN1 is that pla insn,\n    while *PINSN2 is the second instruction.  */\n \n static bfd_boolean\n-xlate_pcrel_opt (uint64_t *pinsn1, uint64_t *pinsn2)\n+xlate_pcrel_opt (uint64_t *pinsn1, uint64_t *pinsn2, bfd_signed_vma *poff)\n {\n   uint32_t insn2 = *pinsn2 >> 32;\n   uint64_t i1new;\n+  bfd_signed_vma off;\n \n   /* Check that regs match.  */\n   if (((insn2 >> 16) & 31) != ((*pinsn1 >> 21) & 31))\n@@ -8306,68 +8307,68 @@ xlate_pcrel_opt (uint64_t *pinsn1, uint64_t *pinsn2)\n     case 52: /* stfs */\n     case 54: /* stfd */\n       /* These are the PMLS cases, where we just need to tack a prefix\n-\t on the insn.  Check that the D field is zero.  */\n-      if ((insn2 & 0xffff) != 0)\n-\treturn FALSE;\n+\t on the insn.  */\n       i1new = ((1ULL << 58) | (2ULL << 56) | (1ULL << 52)\n \t       | (insn2 & ((63ULL << 26) | (31ULL << 21))));\n+      off = insn2 & 0xffff;\n       break;\n \n     case 58: /* lwa, ld */\n-      if ((insn2 & 0xfffd) != 0)\n+      if ((insn2 & 1) != 0)\n \treturn FALSE;\n       i1new = ((1ULL << 58) | (1ULL << 52)\n \t       | (insn2 & 2 ? 41ULL << 26 : 57ULL << 26)\n \t       | (insn2 & (31ULL << 21)));\n+      off = insn2 & 0xfffc;\n       break;\n \n     case 57: /* lxsd, lxssp */\n-      if ((insn2 & 0xfffc) != 0 || (insn2 & 3) < 2)\n+      if ((insn2 & 3) < 2)\n \treturn FALSE;\n       i1new = ((1ULL << 58) | (1ULL << 52)\n \t       | ((40ULL | (insn2 & 3)) << 26)\n \t       | (insn2 & (31ULL << 21)));\n+      off = insn2 & 0xfffc;\n       break;\n \n     case 61: /* stxsd, stxssp, lxv, stxv  */\n       if ((insn2 & 3) == 0)\n \treturn FALSE;\n       else if ((insn2 & 3) >= 2)\n \t{\n-\t  if ((insn2 & 0xfffc) != 0)\n-\t    return FALSE;\n \t  i1new = ((1ULL << 58) | (1ULL << 52)\n \t\t   | ((44ULL | (insn2 & 3)) << 26)\n \t\t   | (insn2 & (31ULL << 21)));\n+\t  off = insn2 & 0xfffc;\n \t}\n       else\n \t{\n-\t  if ((insn2 & 0xfff0) != 0)\n-\t    return FALSE;\n \t  i1new = ((1ULL << 58) | (1ULL << 52)\n \t\t   | ((50ULL | (insn2 & 4) | ((insn2 & 8) >> 3)) << 26)\n \t\t   | (insn2 & (31ULL << 21)));\n+\t  off = insn2 & 0xfff0;\n \t}\n       break;\n \n     case 56: /* lq */\n-      if ((insn2 & 0xffff) != 0)\n-\treturn FALSE;\n       i1new = ((1ULL << 58) | (1ULL << 52)\n \t       | (insn2 & ((63ULL << 26) | (31ULL << 21))));\n+      off = insn2 & 0xffff;\n       break;\n \n     case 62: /* std, stq */\n-      if ((insn2 & 0xfffd) != 0)\n+      if ((insn2 & 1) != 0)\n \treturn FALSE;\n       i1new = ((1ULL << 58) | (1ULL << 52)\n \t       | ((insn2 & 2) == 0 ? 61ULL << 26 : 60ULL << 26)\n \t       | (insn2 & (31ULL << 21)));\n+      off = insn2 & 0xfffc;\n       break;\n     }\n \n   *pinsn1 = i1new;\n   *pinsn2 = (uint64_t) NOP << 32;\n+  *poff = (off ^ 0x8000) - 0x8000;\n   return TRUE;\n }\n \n@@ -15408,12 +15409,15 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t\t      if (off2 + 4 <= input_section->size)\n \t\t\t{\n \t\t\t  uint64_t pinsn2;\n+\t\t\t  bfd_signed_vma addend_off;\n \t\t\t  pinsn2 = bfd_get_32 (input_bfd, contents + off2);\n \t\t\t  pinsn2 <<= 32;\n \t\t\t  if ((pinsn2 & (63ULL << 58)) == 1ULL << 58)\n \t\t\t    break;\n-\t\t\t  if (xlate_pcrel_opt (&pinsn, &pinsn2))\n+\t\t\t  if (xlate_pcrel_opt (&pinsn, &pinsn2, &addend_off))\n \t\t\t    {\n+\t\t\t      addend += addend_off;\n+\t\t\t      rel->r_addend = addend;\n \t\t\t      bfd_put_32 (input_bfd, pinsn >> 32,\n \t\t\t\t\t  contents + offset);\n \t\t\t      bfd_put_32 (input_bfd, pinsn,\n@@ -15428,7 +15432,6 @@ ppc64_elf_relocate_section (bfd *output_bfd,\n \t  break;\n \t}\n \n-      /* Set `addend'.  */\n       tls_type = 0;\n       save_unresolved_reloc = unresolved_reloc;\n       switch (r_type)"
    }
  ]
}