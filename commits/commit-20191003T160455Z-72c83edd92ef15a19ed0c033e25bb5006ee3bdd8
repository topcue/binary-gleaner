{
  "sha": "72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzJjODNlZGQ5MmVmMTVhMTllZDBjMDMzZTI1YmI1MDA2ZWUzYmRkOA==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-07-13T20:06:55Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2019-10-03T16:04:55Z"
    },
    "message": "libctf: add the ctf_link machinery\n\nThis is the start of work on the core of the linking mechanism for CTF\nsections.  This commit handles the type and string sections.\n\nThe linker calls these functions in sequence:\n\nctf_link_add_ctf: to add each CTF section in the input in turn to a\n  newly-created ctf_file_t (which will appear in the output, and which\n  itself will become the shared parent that contains types that all\n  TUs have in common (in all link modes) and all types that do not\n  have conflicting definitions between types (by default).  Input files\n  that are themselves products of ld -r are supported, though this is\n  not heavily tested yet.\n\nctf_link: called once all input files are added to merge the types in\n  all the input containers into the output container, eliminating\n  duplicates.\n\nctf_link_add_strtab: called once the ELF string table is finalized and\n  all its offsets are known, this calls a callback provided by the\n  linker which returns the string content and offset of every string in\n  the ELF strtab in turn: all these strings which appear in the input\n  CTF strtab are eliminated from it in favour of the ELF strtab:\n  equally, any strings that only appear in the input strtab will\n  reappear in the internal CTF strtab of the output.\n\nctf_link_shuffle_syms (not yet implemented): called once the ELF symtab\n  is finalized, this calls a callback provided by the linker which\n  returns information on every symbol in turn as a ctf_link_sym_t.  This\n  is then used to shuffle the function info and data object sections in\n  the CTF section into symbol table order, eliminating the index\n  sections which map those sections to symbol names before that point.\n  Currently just returns ECTF_NOTYET.\n\nctf_link_write: Returns a buffer containing either a serialized\n  ctf_file_t (if there are no types with conflicting definitions in the\n  object files in the link) or a ctf_archive_t containing a large\n  ctf_file_t (the common types) and a bunch of small ones named after\n  individual CUs in which conflicting types are found (containing the\n  conflicting types, and all types that reference them).  A threshold\n  size above which compression takes place is passed as one parameter.\n  (Currently, only gzip compression is supported, but I hope to add lzma\n  as well.)\n\nLifetime rules for this are simple: don't close the input CTF files\nuntil you've called ctf_link for the last time.  We do not assume\nthat symbols or strings passed in by the callback outlast the\ncall to ctf_link_add_strtab or ctf_link_shuffle_syms.\n\nRight now, the duplicate elimination mechanism is the one already\npresent as part of the ctf_add_type function, and is not particularly\ngood: it misses numerous actual duplicates, and the conflicting-types\ndetection hardly ever reports that types conflict, even when they do\n(one of them just tends to get silently dropped): it is also very slow.\nThis will all be fixed in the next few weeks, but the fix hardly touches\nany of this code, and the linker does work without it, just not as\nwell as it otherwise might.  (And when no CTF section is present,\nthere is no effect on performance, of course.  So only people using\na trunk GCC with not-yet-committed patches will even notice.  By the\ntime it gets upstream, things should be better.)\n\nv3: Fix error handling.\nv4: check for strdup failure.\nv5: fix tabdamage.\n\ninclude/\n\t* ctf-api.h (struct ctf_link_sym): New, a symbol in flight to the\n\tlibctf linking machinery.\n\t(CTF_LINK_SHARE_UNCONFLICTED): New.\n\t(CTF_LINK_SHARE_DUPLICATED): New.\n\t(ECTF_LINKADDEDLATE): New, replacing ECTF_UNUSED.\n\t(ECTF_NOTYET): New, a 'not yet implemented' message.\n\t(ctf_link_add_ctf): New, add an input file's CTF to the link.\n\t(ctf_link): New, merge the type and string sections.\n\t(ctf_link_strtab_string_f): New, callback for feeding strtab info.\n\t(ctf_link_iter_symbol_f): New, callback for feeding symtab info.\n\t(ctf_link_add_strtab): New, tell the CTF linker about the ELF\n\tstrtab's strings.\n\t(ctf_link_shuffle_syms): New, ask the CTF linker to shuffle its\n\tsymbols into symtab order.\n\t(ctf_link_write): New, ask the CTF linker to write the CTF out.\n\nlibctf/\n\t* ctf-link.c: New file, linking of the string and type sections.\n\t* Makefile.am (libctf_a_SOURCES): Add it.\n\t* Makefile.in: Regenerate.\n\n\t* ctf-impl.h (ctf_file_t): New fields ctf_link_inputs,\n\tctf_link_outputs.\n\t* ctf-create.c (ctf_update): Update accordingly.\n\t* ctf-open.c (ctf_file_close): Likewise.\n\t* ctf-error.c (_ctf_errlist): Updated with new errors.",
    "tree": {
      "sha": "6fc2904033510fc4e2d60ce2036ad9cb11baede9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6fc2904033510fc4e2d60ce2036ad9cb11baede9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d18f9f16299170e94a3d2e8a45aa349a25278aa3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d18f9f16299170e94a3d2e8a45aa349a25278aa3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d18f9f16299170e94a3d2e8a45aa349a25278aa3"
    }
  ],
  "stats": {
    "total": 635,
    "additions": 619,
    "deletions": 16
  },
  "files": [
    {
      "sha": "6980ec2510e65c92eb38e0a82ff3b0c49bcdd973",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -1,3 +1,21 @@\n+2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (struct ctf_link_sym): New, a symbol in flight to the\n+\tlibctf linking machinery.\n+\t(CTF_LINK_SHARE_UNCONFLICTED): New.\n+\t(CTF_LINK_SHARE_DUPLICATED): New.\n+\t(ECTF_LINKADDEDLATE): New, replacing ECTF_UNUSED.\n+\t(ECTF_NOTYET): New, a 'not yet implemented' message.\n+\t(ctf_link_add_ctf): New, add an input file's CTF to the link.\n+\t(ctf_link): New, merge the type and string sections.\n+\t(ctf_link_strtab_string_f): New, callback for feeding strtab info.\n+\t(ctf_link_iter_symbol_f): New, callback for feeding symtab info.\n+\t(ctf_link_add_strtab): New, tell the CTF linker about the ELF\n+\tstrtab's strings.\n+\t(ctf_link_shuffle_syms): New, ask the CTF linker to shuffle its\n+\tsymbols into symtab order.\n+\t(ctf_link_write): New, ask the CTF linker to write the CTF out.\n+\n 2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-api.h (ctf_arc_write_fd): New."
    },
    {
      "sha": "e4c6f9fc5b344967b9259488e8c5c77f86ab2723",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 37,
      "deletions": 2,
      "changes": 39,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -65,6 +65,28 @@ typedef struct ctf_sect\n   size_t cts_entsize;\t\t  /* Size of each section entry (symtab only).  */\n } ctf_sect_t;\n \n+/* A minimal symbol extracted from a linker's internal symbol table\n+   representation.  */\n+\n+typedef struct ctf_link_sym\n+{\n+  /* The st_name will not be accessed outside the call to\n+     ctf_link_shuffle_syms().  */\n+\n+  const char *st_name;\n+  uint32_t st_shndx;\n+  uint32_t st_type;\n+  uint32_t st_value;\n+} ctf_link_sym_t;\n+\n+/* Indication of how to share types when linking.  */\n+\n+/* Share all types thare are not in conflict.  The default.  */\n+#define CTF_LINK_SHARE_UNCONFLICTED 0x0\n+\n+/* Share only types that are used by multiple inputs.  Not implemented yet.  */\n+#define CTF_LINK_SHARE_DUPLICATED 0x1\n+\n /* Symbolic names for CTF sections.  */\n \n typedef enum ctf_sect_names\n@@ -145,7 +167,7 @@ enum\n    ECTF_NOSYMTAB,\t\t/* Symbol table data is not available.  */\n    ECTF_NOPARENT,\t\t/* Parent CTF container is not available.  */\n    ECTF_DMODEL,\t\t\t/* Data model mismatch.  */\n-   ECTF_UNUSED,\t\t\t/* Unused error.  */\n+   ECTF_LINKADDEDLATE,\t\t/* File added to link too late.  */\n    ECTF_ZALLOC,\t\t\t/* Failed to allocate (de)compression buffer.  */\n    ECTF_DECOMPRESS,\t\t/* Failed to decompress CTF data.  */\n    ECTF_STRTAB,\t\t\t/* String table for this string is missing.  */\n@@ -180,7 +202,8 @@ enum\n    ECTF_ARNNAME,\t\t/* Name not found in CTF archive.  */\n    ECTF_SLICEOVERFLOW,\t\t/* Overflow of type bitness or offset in slice.  */\n    ECTF_DUMPSECTUNKNOWN,\t/* Unknown section number in dump.  */\n-   ECTF_DUMPSECTCHANGED\t\t/* Section changed in middle of dump.  */\n+   ECTF_DUMPSECTCHANGED,\t/* Section changed in middle of dump.  */\n+   ECTF_NOTYET\t\t\t/* Feature not yet implemented.  */\n   };\n \n /* The CTF data model is inferred to be the caller's data model or the data\n@@ -385,6 +408,18 @@ extern int ctf_gzwrite (ctf_file_t *fp, gzFile fd);\n extern int ctf_compress_write (ctf_file_t * fp, int fd);\n extern unsigned char *ctf_write_mem (ctf_file_t *, size_t *, size_t threshold);\n \n+extern int ctf_link_add_ctf (ctf_file_t *, ctf_archive_t *, const char *);\n+extern int ctf_link (ctf_file_t *, int share_mode);\n+typedef const char *ctf_link_strtab_string_f (uint32_t *offset, void *arg);\n+extern int ctf_link_add_strtab (ctf_file_t *, ctf_link_strtab_string_f *,\n+\t\t\t\tvoid *);\n+typedef ctf_link_sym_t *ctf_link_iter_symbol_f (ctf_link_sym_t *dest,\n+\t\t\t\t\t\tvoid *arg);\n+extern int ctf_link_shuffle_syms (ctf_file_t *, ctf_link_iter_symbol_f *,\n+\t\t\t\t  void *);\n+extern unsigned char *ctf_link_write (ctf_file_t *, size_t *size,\n+\t\t\t\t      size_t threshold);\n+\n extern void ctf_setdebug (int debug);\n extern int ctf_getdebug (void);\n "
    },
    {
      "sha": "959a038b87774031bad412548b92c70bbb08c94a",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -1,3 +1,15 @@\n+2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-link.c: New file, linking of the string and type sections.\n+\t* Makefile.am (libctf_a_SOURCES): Add it.\n+\t* Makefile.in: Regenerate.\n+\n+\t* ctf-impl.h (ctf_file_t): New fields ctf_link_inputs,\n+\tctf_link_outputs.\n+\t* ctf-create.c (ctf_update): Update accordingly.\n+\t* ctf-open.c (ctf_file_close): Likewise.\n+\t* ctf-error.c (_ctf_errlist): Updated with new errors.\n+\n 2019-07-13  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-dump.c (ctf_dump_funcs): Check the right error value."
    },
    {
      "sha": "a0a27b46c37e3d4693918ff8d66866d472521eb3",
      "filename": "libctf/Makefile.am",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/Makefile.am?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -33,8 +33,8 @@ AM_CFLAGS = -std=gnu99 @ac_libctf_warn_cflags@ @warn@ @c_warn@ @WARN_PEDANTIC@ @\n noinst_LIBRARIES = libctf.a\n \n libctf_a_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c ctf-decl.c ctf-error.c \\\n-\t\t   ctf-hash.c ctf-labels.c ctf-lookup.c ctf-open.c ctf-open-bfd.c \\\n-\t\t   ctf-string.c ctf-subr.c ctf-types.c ctf-util.c\n+\t\t   ctf-hash.c ctf-labels.c ctf-link.c ctf-lookup.c ctf-open.c \\\n+\t\t   ctf-open-bfd.c ctf-string.c ctf-subr.c ctf-types.c ctf-util.c\n if NEED_CTF_QSORT_R\n libctf_a_SOURCES += ctf-qsort_r.c\n endif"
    },
    {
      "sha": "1d2efb9e75645efd1ea4422c9695d1015083b03d",
      "filename": "libctf/Makefile.in",
      "status": "modified",
      "additions": 11,
      "deletions": 10,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/Makefile.in?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -131,16 +131,16 @@ am__v_AR_1 =\n libctf_a_AR = $(AR) $(ARFLAGS)\n libctf_a_LIBADD =\n am__libctf_a_SOURCES_DIST = ctf-archive.c ctf-dump.c ctf-create.c \\\n-\tctf-decl.c ctf-error.c ctf-hash.c ctf-labels.c ctf-lookup.c \\\n-\tctf-open.c ctf-open-bfd.c ctf-string.c ctf-subr.c ctf-types.c \\\n-\tctf-util.c ctf-qsort_r.c\n+\tctf-decl.c ctf-error.c ctf-hash.c ctf-labels.c ctf-link.c \\\n+\tctf-lookup.c ctf-open.c ctf-open-bfd.c ctf-string.c ctf-subr.c \\\n+\tctf-types.c ctf-util.c ctf-qsort_r.c\n @NEED_CTF_QSORT_R_TRUE@am__objects_1 = ctf-qsort_r.$(OBJEXT)\n am_libctf_a_OBJECTS = ctf-archive.$(OBJEXT) ctf-dump.$(OBJEXT) \\\n \tctf-create.$(OBJEXT) ctf-decl.$(OBJEXT) ctf-error.$(OBJEXT) \\\n-\tctf-hash.$(OBJEXT) ctf-labels.$(OBJEXT) ctf-lookup.$(OBJEXT) \\\n-\tctf-open.$(OBJEXT) ctf-open-bfd.$(OBJEXT) ctf-string.$(OBJEXT) \\\n-\tctf-subr.$(OBJEXT) ctf-types.$(OBJEXT) ctf-util.$(OBJEXT) \\\n-\t$(am__objects_1)\n+\tctf-hash.$(OBJEXT) ctf-labels.$(OBJEXT) ctf-link.$(OBJEXT) \\\n+\tctf-lookup.$(OBJEXT) ctf-open.$(OBJEXT) ctf-open-bfd.$(OBJEXT) \\\n+\tctf-string.$(OBJEXT) ctf-subr.$(OBJEXT) ctf-types.$(OBJEXT) \\\n+\tctf-util.$(OBJEXT) $(am__objects_1)\n libctf_a_OBJECTS = $(am_libctf_a_OBJECTS)\n AM_V_P = $(am__v_P_@AM_V@)\n am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\n@@ -331,9 +331,9 @@ AM_CPPFLAGS = -D_GNU_SOURCE -I$(top_srcdir) -I$(top_srcdir)/../include -I$(top_s\n AM_CFLAGS = -std=gnu99 @ac_libctf_warn_cflags@ @warn@ @c_warn@ @WARN_PEDANTIC@ @WERROR@ $(ZLIBINC)\n noinst_LIBRARIES = libctf.a\n libctf_a_SOURCES = ctf-archive.c ctf-dump.c ctf-create.c ctf-decl.c \\\n-\tctf-error.c ctf-hash.c ctf-labels.c ctf-lookup.c ctf-open.c \\\n-\tctf-open-bfd.c ctf-string.c ctf-subr.c ctf-types.c ctf-util.c \\\n-\t$(am__append_1)\n+\tctf-error.c ctf-hash.c ctf-labels.c ctf-link.c ctf-lookup.c \\\n+\tctf-open.c ctf-open-bfd.c ctf-string.c ctf-subr.c ctf-types.c \\\n+\tctf-util.c $(am__append_1)\n all: config.h\n \t$(MAKE) $(AM_MAKEFLAGS) all-am\n \n@@ -409,6 +409,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-error.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-hash.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-labels.Po@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-link.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-lookup.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-open-bfd.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ctf-open.Po@am__quote@"
    },
    {
      "sha": "fc37d6a40f83a4ac821f3deb326fb01beaa94579",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -470,6 +470,8 @@ ctf_update (ctf_file_t *fp)\n   nfp->ctf_dtoldid = fp->ctf_dtnextid - 1;\n   nfp->ctf_snapshots = fp->ctf_snapshots + 1;\n   nfp->ctf_specific = fp->ctf_specific;\n+  nfp->ctf_link_inputs = fp->ctf_link_inputs;\n+  nfp->ctf_link_outputs = fp->ctf_link_outputs;\n   nfp->ctf_syn_ext_strtab = fp->ctf_syn_ext_strtab;\n \n   nfp->ctf_snapshot_lu = fp->ctf_snapshots;\n@@ -480,6 +482,8 @@ ctf_update (ctf_file_t *fp)\n   nfp->ctf_str_atoms = fp->ctf_str_atoms;\n   fp->ctf_str_atoms = NULL;\n   memset (&fp->ctf_dtdefs, 0, sizeof (ctf_list_t));\n+  fp->ctf_link_inputs = NULL;\n+  fp->ctf_link_outputs = NULL;\n   fp->ctf_syn_ext_strtab = NULL;\n \n   fp->ctf_dvhash = NULL;"
    },
    {
      "sha": "7f6a4ce5d477bb9a902d691af36bdab016ee7a4c",
      "filename": "libctf/ctf-error.c",
      "status": "modified",
      "additions": 3,
      "deletions": 2,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-error.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-error.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-error.c?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -33,7 +33,7 @@ static const char *const _ctf_errlist[] = {\n   \"Symbol table information is not available\",\t     /* ECTF_NOSYMTAB */\n   \"Type information is in parent and unavailable\",   /* ECTF_NOPARENT */\n   \"Cannot import types with different data model\",   /* ECTF_DMODEL */\n-  \"Unused error\",\t\t\t\t     /* ECTF_UNUSED */\n+  \"File added to link too late\",\t\t     /* ECTF_LINKADDEDLATE */\n   \"Failed to allocate (de)compression buffer\",\t     /* ECTF_ZALLOC */\n   \"Failed to decompress CTF data\",\t\t     /* ECTF_DECOMPRESS */\n   \"External string table is not available\",\t     /* ECTF_STRTAB */\n@@ -68,7 +68,8 @@ static const char *const _ctf_errlist[] = {\n   \"Name not found in CTF archive\",\t\t     /* ECTF_ARNNAME */\n   \"Overflow of type bitness or offset in slice\",     /* ECTF_SLICEOVERFLOW */\n   \"Unknown section number in dump\",\t\t     /* ECTF_DUMPSECTUNKNOWN */\n-  \"Section changed in middle of dump\"\t\t     /* ECTF_DUMPSECTCHANGED */\n+  \"Section changed in middle of dump\",\t\t     /* ECTF_DUMPSECTCHANGED */\n+  \"Feature not yet implemented\"\t\t\t     /* ECTF_NOTYET */\n };\n \n static const int _ctf_nerr = sizeof (_ctf_errlist) / sizeof (_ctf_errlist[0]);"
    },
    {
      "sha": "9fb58f59715c6a35e59c221e0d8183e1412bc2f3",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -267,6 +267,8 @@ struct ctf_file\n   unsigned long ctf_snapshots;\t  /* ctf_snapshot() plus ctf_update() count.  */\n   unsigned long ctf_snapshot_lu;  /* ctf_snapshot() call count at last update.  */\n   ctf_archive_t *ctf_archive;\t  /* Archive this ctf_file_t came from.  */\n+  ctf_dynhash_t *ctf_link_inputs; /* Inputs to this link.  */\n+  ctf_dynhash_t *ctf_link_outputs; /* Additional outputs from this link.  */\n   char *ctf_tmp_typeslice;\t  /* Storage for slicing up type names.  */\n   size_t ctf_tmp_typeslicelen;\t  /* Size of the typeslice.  */\n   void *ctf_specific;\t\t  /* Data for ctf_get/setspecific().  */"
    },
    {
      "sha": "8f18a4927163027379a64bc9e35262e875ac69e8",
      "filename": "libctf/ctf-link.c",
      "status": "added",
      "additions": 528,
      "deletions": 0,
      "changes": 528,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-link.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-link.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-link.c?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -0,0 +1,528 @@\n+/* CTF linking.\n+   Copyright (C) 2019 Free Software Foundation, Inc.\n+\n+   This file is part of libctf.\n+\n+   libctf is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   This program is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+   See the GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program; see the file COPYING.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include <ctf-impl.h>\n+#include <string.h>\n+\n+/* Linker machinery.\n+\n+   CTF linking consists of adding CTF archives full of content to be merged into\n+   this one to the current file (which must be writable) by calling\n+   ctf_link_add_ctf().  Once this is done, a call to ctf_link() will merge the\n+   type tables together, generating new CTF files as needed, with this one as a\n+   parent, to contain types from the inputs which conflict.\n+   ctf_link_add_strtab() takes a callback which provides string/offset pairs to\n+   be added to the external symbol table and deduplicated from all CTF string\n+   tables in the output link; ctf_link_shuffle_syms() takes a callback which\n+   provides symtab entries in ascending order, and shuffles the function and\n+   data sections to match; and ctf_link_write() emits a CTF file (if there are\n+   no conflicts requiring per-compilation-unit sub-CTF files) or CTF archives\n+   (otherwise) and returns it, suitable for addition in the .ctf section of the\n+   output.  */\n+\n+/* Add a file to a link.  */\n+\n+static void ctf_arc_close_thunk (void *arc)\n+{\n+  ctf_arc_close ((ctf_archive_t *) arc);\n+}\n+\n+static void ctf_file_close_thunk (void *file)\n+{\n+  ctf_file_close ((ctf_file_t *) file);\n+}\n+\n+int\n+ctf_link_add_ctf (ctf_file_t *fp, ctf_archive_t *ctf, const char *name)\n+{\n+  char *dupname = NULL;\n+\n+  if (fp->ctf_link_outputs)\n+    return (ctf_set_errno (fp, ECTF_LINKADDEDLATE));\n+  if (fp->ctf_link_inputs == NULL)\n+    fp->ctf_link_inputs = ctf_dynhash_create (ctf_hash_string,\n+\t\t\t\t\t      ctf_hash_eq_string, free,\n+\t\t\t\t\t      ctf_arc_close_thunk);\n+\n+  if (fp->ctf_link_inputs == NULL)\n+    goto oom;\n+\n+  if ((dupname = strdup (name)) == NULL)\n+    goto oom;\n+\n+  if (ctf_dynhash_insert (fp->ctf_link_inputs, dupname, ctf) < 0)\n+    goto oom;\n+\n+  return 0;\n+ oom:\n+  free (fp->ctf_link_inputs);\n+  fp->ctf_link_inputs = NULL;\n+  free (dupname);\n+  return (ctf_set_errno (fp, ENOMEM));\n+}\n+\n+typedef struct ctf_link_in_member_cb_arg\n+{\n+  ctf_file_t *out_fp;\n+  const char *file_name;\n+  ctf_file_t *in_fp;\n+  ctf_file_t *main_input_fp;\n+  const char *cu_name;\n+  char *arcname;\n+  int done_main_member;\n+  int share_mode;\n+  int in_input_cu_file;\n+} ctf_link_in_member_cb_arg_t;\n+\n+/* Link one type into the link.  We rely on ctf_add_type() to detect\n+   duplicates.  This is not terribly reliable yet (unnmamed types will be\n+   mindlessly duplicated), but will improve shortly.  */\n+\n+static int\n+ctf_link_one_type (ctf_id_t type, int isroot _libctf_unused_, void *arg_)\n+{\n+  ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n+  ctf_file_t *per_cu_out_fp;\n+  int err;\n+\n+  if (arg->share_mode != CTF_LINK_SHARE_UNCONFLICTED)\n+    {\n+      ctf_dprintf (\"Share-duplicated mode not yet implemented.\\n\");\n+      return ctf_set_errno (arg->out_fp, ECTF_NOTYET);\n+    }\n+\n+  /* Simply call ctf_add_type: if it reports a conflict and we're adding to the\n+     main CTF file, add to the per-CU archive member instead, creating it if\n+     necessary.  If we got this type from a per-CU archive member, add it\n+     straight back to the corresponding member in the output.  */\n+\n+  if (!arg->in_input_cu_file)\n+    {\n+      if (ctf_add_type (arg->out_fp, arg->in_fp, type) != CTF_ERR)\n+\treturn 0;\n+\n+      err = ctf_errno (arg->out_fp);\n+      if (err != ECTF_CONFLICT)\n+\t{\n+\t  ctf_dprintf (\"Cannot link type %lx from archive member %s, input file %s \"\n+\t\t       \"into output link: %s\\n\", type, arg->arcname, arg->file_name,\n+\t\t       ctf_errmsg (err));\n+\t  return -1;\n+\t}\n+      ctf_set_errno (arg->out_fp, 0);\n+    }\n+\n+  if ((per_cu_out_fp = ctf_dynhash_lookup (arg->out_fp->ctf_link_outputs,\n+\t\t\t\t\t   arg->arcname)) == NULL)\n+    {\n+      int err;\n+\n+      if ((per_cu_out_fp = ctf_create (&err)) == NULL)\n+\t{\n+\t  ctf_dprintf (\"Cannot create per-CU CTF archive for member %s: %s\\n\",\n+\t\t       arg->arcname, ctf_errmsg (err));\n+\t  ctf_set_errno (arg->out_fp, err);\n+\t  return -1;\n+\t}\n+\n+      if (ctf_dynhash_insert (arg->out_fp->ctf_link_outputs, arg->arcname,\n+\t\t\t      per_cu_out_fp) < 0)\n+\t{\n+\t  ctf_set_errno (arg->out_fp, ENOMEM);\n+\t  return -1;\n+\t}\n+\n+      ctf_import (per_cu_out_fp, arg->out_fp);\n+      ctf_cuname_set (per_cu_out_fp, arg->cu_name);\n+    }\n+\n+  if (ctf_add_type (per_cu_out_fp, arg->in_fp, type) != CTF_ERR)\n+    return 0;\n+\n+  err = ctf_errno (per_cu_out_fp);\n+  if (err == ECTF_CONFLICT)\n+      /* Conflicts are possible at this stage only if a non-ld user has combined\n+\t multiple TUs into a single output dictionary.  Even in this case we do not\n+\t want to stop the link or propagate the error.  */\n+      ctf_set_errno (arg->out_fp, 0);\n+\n+  return 0;\t\t\t\t\t/* As above: do not lose types.  */\n+}\n+\n+/* Merge every type and variable in this archive member into the link, so we can\n+   relink things that have already had ld run on them.  We use the archive\n+   member name, sans any leading '.ctf.', as the CU name for ambiguous types if\n+   there is one and it's not the default: otherwise, we use the name of the\n+   input file.  */\n+static int\n+ctf_link_one_input_archive_member (ctf_file_t *in_fp, const char *name, void *arg_)\n+{\n+  ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n+  int err = 0;\n+\n+  if (strcmp (name, _CTF_SECTION) == 0)\n+    {\n+      /* This file is the default member of this archive, and has already been\n+\t explicitly processed.\n+\n+\t In the default sharing mode of CTF_LINK_SHARE_UNCONFLICTED, it does no\n+\t harm to rescan an existing shared repo again: all the types will just\n+\t end up in the same place.  But in CTF_LINK_SHARE_DUPLICATED mode, this\n+\t causes the system to erroneously conclude that all types are duplicated\n+\t and should be shared, even if they are not.  */\n+\n+      if (arg->done_main_member)\n+\treturn 0;\n+      arg->arcname = strdup (\".ctf.\");\n+      if (arg->arcname)\n+\t{\n+\t  char *new_name;\n+\n+\t  new_name = ctf_str_append (arg->arcname, arg->file_name);\n+\t  if (new_name)\n+\t    arg->arcname = new_name;\n+\t  else\n+\t    free (arg->arcname);\n+\t}\n+    }\n+  else\n+    {\n+      arg->arcname = strdup (name);\n+\n+      /* Get ambiguous types from our parent.  */\n+      ctf_import (in_fp, arg->main_input_fp);\n+      arg->in_input_cu_file = 1;\n+    }\n+\n+  if (!arg->arcname)\n+    return ctf_set_errno (in_fp, ENOMEM);\n+\n+  arg->cu_name = name;\n+  if (strncmp (arg->cu_name, \".ctf.\", strlen (\".ctf.\")) == 0)\n+    arg->cu_name += strlen (\".ctf.\");\n+  arg->in_fp = in_fp;\n+\n+  err = ctf_type_iter_all (in_fp, ctf_link_one_type, arg);\n+\n+  arg->in_input_cu_file = 0;\n+  free (arg->arcname);\n+\n+  if (err < 0)\n+      return -1;\t\t\t\t/* Errno is set for us.  */\n+\n+  return 0;\n+}\n+\n+/* Link one input file's types into the output file.  */\n+static void\n+ctf_link_one_input_archive (void *key, void *value, void *arg_)\n+{\n+  const char *file_name = (const char *) key;\n+  ctf_archive_t *arc = (ctf_archive_t *) value;\n+  ctf_link_in_member_cb_arg_t *arg = (ctf_link_in_member_cb_arg_t *) arg_;\n+  int err;\n+\n+  arg->file_name = file_name;\n+  arg->done_main_member = 0;\n+  if ((arg->main_input_fp = ctf_arc_open_by_name (arc, NULL, &err)) == NULL)\n+    if (err != ECTF_ARNNAME)\n+      {\n+\tctf_dprintf (\"Cannot open main archive member in input file %s in the \"\n+\t\t     \"link: skipping: %s.\\n\", arg->file_name,\n+\t\t     ctf_errmsg (err));\n+\treturn;\n+      }\n+\n+  if (ctf_link_one_input_archive_member (arg->main_input_fp,\n+\t\t\t\t\t _CTF_SECTION, arg) < 0)\n+    {\n+      ctf_file_close (arg->main_input_fp);\n+      return;\n+    }\n+  arg->done_main_member = 1;\n+  if (ctf_archive_iter (arc, ctf_link_one_input_archive_member, arg) < 0)\n+    ctf_dprintf (\"Cannot traverse archive in input file %s: link \"\n+\t\t \"cannot continue: %s.\\n\", arg->file_name,\n+\t\t ctf_errmsg (ctf_errno (arg->out_fp)));\n+  else\n+    {\n+      /* The only error indication to the caller is the errno: so ensure that it\n+\t is zero if there was no actual error from the caller.  */\n+      ctf_set_errno (arg->out_fp, 0);\n+    }\n+  ctf_file_close (arg->main_input_fp);\n+}\n+\n+/* Merge types and variable sections in all files added to the link\n+   together.  */\n+int\n+ctf_link (ctf_file_t *fp, int share_mode)\n+{\n+  ctf_link_in_member_cb_arg_t arg;\n+\n+  memset (&arg, 0, sizeof (struct ctf_link_in_member_cb_arg));\n+  arg.out_fp = fp;\n+  arg.share_mode = share_mode;\n+\n+  if (fp->ctf_link_inputs == NULL)\n+    return 0;\t\t\t\t\t/* Nothing to do. */\n+\n+  if (fp->ctf_link_outputs == NULL)\n+    fp->ctf_link_outputs = ctf_dynhash_create (ctf_hash_string,\n+\t\t\t\t\t       ctf_hash_eq_string, free,\n+\t\t\t\t\t       ctf_file_close_thunk);\n+\n+  if (fp->ctf_link_outputs == NULL)\n+    return ctf_set_errno (fp, ENOMEM);\n+\n+  ctf_dynhash_iter (fp->ctf_link_inputs, ctf_link_one_input_archive,\n+\t\t    &arg);\n+\n+  if (ctf_errno (fp) != 0)\n+    return -1;\n+  return 0;\n+}\n+\n+typedef struct ctf_link_out_string_cb_arg\n+{\n+  const char *str;\n+  uint32_t offset;\n+  int err;\n+} ctf_link_out_string_cb_arg_t;\n+\n+/* Intern a string in the string table of an output per-CU CTF file.  */\n+static void\n+ctf_link_intern_extern_string (void *key _libctf_unused_, void *value,\n+\t\t\t       void *arg_)\n+{\n+  ctf_file_t *fp = (ctf_file_t *) value;\n+  ctf_link_out_string_cb_arg_t *arg = (ctf_link_out_string_cb_arg_t *) arg_;\n+\n+  fp->ctf_flags |= LCTF_DIRTY;\n+  if (ctf_str_add_external (fp, arg->str, arg->offset) == NULL)\n+    arg->err = ENOMEM;\n+}\n+\n+/* Repeatedly call ADD_STRING to acquire strings from the external string table,\n+   adding them to the atoms table for this CU and all subsidiary CUs.\n+\n+   If ctf_link() is also called, it must be called first if you want the new CTF\n+   files ctf_link() can create to get their strings dedupped against the ELF\n+   strtab properly.  */\n+int\n+ctf_link_add_strtab (ctf_file_t *fp, ctf_link_strtab_string_f *add_string,\n+\t\t     void *arg)\n+{\n+  const char *str;\n+  uint32_t offset;\n+  int err = 0;\n+\n+  while ((str = add_string (&offset, arg)) != NULL)\n+    {\n+      ctf_link_out_string_cb_arg_t iter_arg = { str, offset, 0 };\n+\n+      fp->ctf_flags |= LCTF_DIRTY;\n+      if (ctf_str_add_external (fp, str, offset) == NULL)\n+\terr = ENOMEM;\n+\n+      ctf_dynhash_iter (fp->ctf_link_outputs, ctf_link_intern_extern_string,\n+\t\t\t&iter_arg);\n+      if (iter_arg.err)\n+\terr = iter_arg.err;\n+    }\n+\n+  return -err;\n+}\n+\n+/* Not yet implemented.  */\n+int\n+ctf_link_shuffle_syms (ctf_file_t *fp _libctf_unused_,\n+\t\t       ctf_link_iter_symbol_f *add_sym _libctf_unused_,\n+\t\t       void *arg _libctf_unused_)\n+{\n+  return 0;\n+}\n+\n+typedef struct ctf_name_list_accum_cb_arg\n+{\n+  char **names;\n+  ctf_file_t *fp;\n+  ctf_file_t **files;\n+  size_t i;\n+} ctf_name_list_accum_cb_arg_t;\n+\n+/* Accumulate the names and a count of the names in the link output hash,\n+   and run ctf_update() on them to generate them.  */\n+static void\n+ctf_accumulate_archive_names (void *key, void *value, void *arg_)\n+{\n+  const char *name = (const char *) key;\n+  ctf_file_t *fp = (ctf_file_t *) value;\n+  char **names;\n+  ctf_file_t **files;\n+  ctf_name_list_accum_cb_arg_t *arg = (ctf_name_list_accum_cb_arg_t *) arg_;\n+  int err;\n+\n+  if ((err = ctf_update (fp)) < 0)\n+    {\n+      ctf_set_errno (arg->fp, ctf_errno (fp));\n+      return;\n+    }\n+\n+  if ((names = realloc (arg->names, sizeof (char *) * ++(arg->i))) == NULL)\n+    {\n+      (arg->i)--;\n+      ctf_set_errno (arg->fp, ENOMEM);\n+      return;\n+    }\n+\n+  if ((files = realloc (arg->files, sizeof (ctf_file_t *) * arg->i)) == NULL)\n+    {\n+      (arg->i)--;\n+      ctf_set_errno (arg->fp, ENOMEM);\n+      return;\n+    }\n+  arg->names = names;\n+  arg->names[(arg->i) - 1] = (char *) name;\n+  arg->files = files;\n+  arg->files[(arg->i) - 1] = fp;\n+}\n+\n+/* Write out a CTF archive (if there are per-CU CTF files) or a CTF file\n+   (otherwise) into a new dynamically-allocated string, and return it.\n+   Members with sizes above THRESHOLD are compressed.  */\n+unsigned char *\n+ctf_link_write (ctf_file_t *fp, size_t *size, size_t threshold)\n+{\n+  ctf_name_list_accum_cb_arg_t arg;\n+  char **names;\n+  ctf_file_t **files;\n+  FILE *f = NULL;\n+  int err;\n+  long fsize;\n+  const char *errloc;\n+  unsigned char *buf = NULL;\n+\n+  memset (&arg, 0, sizeof (ctf_name_list_accum_cb_arg_t));\n+  arg.fp = fp;\n+\n+  if (ctf_update (fp) < 0)\n+    {\n+      errloc = \"CTF file construction\";\n+      goto err;\n+    }\n+\n+  if (fp->ctf_link_outputs)\n+    {\n+      ctf_dynhash_iter (fp->ctf_link_outputs, ctf_accumulate_archive_names, &arg);\n+      if (ctf_errno (fp) < 0)\n+\t{\n+\t  errloc = \"hash creation\";\n+\t  goto err;\n+\t}\n+    }\n+\n+  /* No extra outputs? Just write a simple ctf_file_t.  */\n+  if (arg.i == 0)\n+    return ctf_write_mem (fp, size, threshold);\n+\n+  /* Writing an archive.  Stick ourselves (the shared repository, parent of all\n+     other archives) on the front of it with the default name.  */\n+  if ((names = realloc (arg.names, sizeof (char *) * (arg.i + 1))) == NULL)\n+    {\n+      errloc = \"name reallocation\";\n+      goto err_no;\n+    }\n+  arg.names = names;\n+  memmove (&(arg.names[1]), arg.names, sizeof (char *) * (arg.i));\n+  arg.names[0] = (char *) _CTF_SECTION;\n+\n+  if ((files = realloc (arg.files,\n+\t\t\tsizeof (struct ctf_file *) * (arg.i + 1))) == NULL)\n+    {\n+      errloc = \"ctf_file reallocation\";\n+      goto err_no;\n+    }\n+  arg.files = files;\n+  memmove (&(arg.files[1]), arg.files, sizeof (ctf_file_t *) * (arg.i));\n+  arg.files[0] = fp;\n+\n+  if ((f = tmpfile ()) == NULL)\n+    {\n+      errloc = \"tempfile creation\";\n+      goto err_no;\n+    }\n+\n+  if ((err = ctf_arc_write_fd (fileno (f), arg.files, arg.i + 1,\n+\t\t\t       (const char **) arg.names,\n+\t\t\t       threshold)) < 0)\n+    {\n+      errloc = \"archive writing\";\n+      ctf_set_errno (fp, err);\n+      goto err;\n+    }\n+\n+  if (fseek (f, 0, SEEK_END) < 0)\n+    {\n+      errloc = \"seeking to end\";\n+      goto err_no;\n+    }\n+\n+  if ((fsize = ftell (f)) < 0)\n+    {\n+      errloc = \"filesize determination\";\n+      goto err_no;\n+    }\n+\n+  if (fseek (f, 0, SEEK_SET) < 0)\n+    {\n+      errloc = \"filepos resetting\";\n+      goto err_no;\n+    }\n+\n+  if ((buf = malloc (fsize)) == NULL)\n+    {\n+      errloc = \"CTF archive buffer allocation\";\n+      goto err_no;\n+    }\n+\n+  while (!feof (f) && fread (buf, fsize, 1, f) == 0)\n+    if (ferror (f))\n+      {\n+\terrloc = \"reading archive from temporary file\";\n+\tgoto err_no;\n+      }\n+\n+  *size = fsize;\n+  free (arg.names);\n+  free (arg.files);\n+  return buf;\n+\n+ err_no:\n+  ctf_set_errno (fp, errno);\n+ err:\n+  free (buf);\n+  if (f)\n+    fclose (f);\n+  free (arg.names);\n+  free (arg.files);\n+  ctf_dprintf (\"Cannot write archive in link: %s failure: %s\\n\", errloc,\n+\t       ctf_errmsg (ctf_errno (fp)));\n+  return NULL;\n+}"
    },
    {
      "sha": "3bc102a37d185fa4625d146afa61d0d0d4aa2d48",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/72c83edd92ef15a19ed0c033e25bb5006ee3bdd8/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=72c83edd92ef15a19ed0c033e25bb5006ee3bdd8",
      "patch": "@@ -1625,6 +1625,8 @@ ctf_file_close (ctf_file_t *fp)\n   ctf_free (fp->ctf_dynbase);\n \n   ctf_dynhash_destroy (fp->ctf_syn_ext_strtab);\n+  ctf_dynhash_destroy (fp->ctf_link_inputs);\n+  ctf_dynhash_destroy (fp->ctf_link_outputs);\n \n   ctf_free (fp->ctf_sxlate);\n   ctf_free (fp->ctf_txlate);"
    }
  ]
}