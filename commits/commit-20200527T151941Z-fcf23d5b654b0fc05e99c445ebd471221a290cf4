{
  "sha": "fcf23d5b654b0fc05e99c445ebd471221a290cf4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmNmMjNkNWI2NTRiMGZjMDVlOTljNDQ1ZWJkNDcxMjIxYTI5MGNmNA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:14:11Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:19:41Z"
    },
    "message": "Make mapped_debug_names independent of objfile\n\nmapped_debug_names currently has a dwarf2_per_objfile field.  Since we\nwant it to become objfile-independent, this field must be removed.\n\nThis patch removes it, and then arranges for all methods that needed it\nto accept a dwarf2_per_objfile parameter.  This trickles down at various\nplaces, like the dw2_debug_names_iterator type.\n\nUltimately, the objfile only seems to be needed because we might need to\nread a string from the string section.  For that, we might need to read\nin the section, and if it's a relocatable section, the objfile is needed\nin order to do the relocation.  This pattern happens often (that we to\npass an objfile only because a section might be read).  I think it's a\nbit ugly, but I don't have a good alternative right now.\n\ngdb/ChangeLog:\n\n\t* dwarf2/read.c (struct mapped_index_base) <symbol_name_at,\n\tbuild_name_components, find_name_components_bounds>:\n\tAdd per_objfile parameter.\n\t(struct mapped_index) <symbol_name_at>: Likewise.\n\t(struct mapped_debug_names): Remove constructor.\n\t<dwarf2_per_objfile>: Remove field.\n\t<namei_to_name, symbol_name_at>: Add per_objfile parameter.\n\t(mapped_index_base::find_name_components_bounds,\n\tmapped_index_base::build_name_components,\n\tdw2_expand_symtabs_matching_symbol): Likewise.\n\t(class mock_mapped_index) <symbol_name_at>: Likewise.\n\t(check_match): Likewise.\n\t(check_find_bounds_finds): Likewise.\n\t(test_mapped_index_find_name_component_bounds): Update.\n\t(CHECK_MATCH): Update.\n\t(dw2_expand_symtabs_matching): Update.\n\t(class dw2_debug_names_iterator) <dw2_debug_names_iterator>: Add\n\tper_objfile parameter.\n\t<find_vec_in_debug_names>: Likewise.\n\t<m_per_objfile>: New field.\n\t(mapped_debug_names::namei_to_name): Add dwarf2_per_objfile\n\tparameter.\n\t(dw2_debug_names_iterator::find_vec_in_debug_names): Likewise.\n\t(dw2_debug_names_iterator::next): Update.\n\t(dw2_debug_names_lookup_symbol): Update.\n\t(dw2_debug_names_expand_symtabs_for_function): Update.\n\t(dw2_debug_names_map_matching_symbols): Update.\n\t(dw2_debug_names_expand_symtabs_matching): Update.\n\t(dwarf2_read_debug_names): Update.\n\nChange-Id: I00ee0d939390d353442675c7d400a261307c57a1",
    "tree": {
      "sha": "d509805d44d80ecc3ff25d61c6e3c654c8c4982c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d509805d44d80ecc3ff25d61c6e3c654c8c4982c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fcf23d5b654b0fc05e99c445ebd471221a290cf4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fcf23d5b654b0fc05e99c445ebd471221a290cf4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fcf23d5b654b0fc05e99c445ebd471221a290cf4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fcf23d5b654b0fc05e99c445ebd471221a290cf4/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7188ed02d2a7e3fce00a0214e70457c5ef56df6b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7188ed02d2a7e3fce00a0214e70457c5ef56df6b"
    }
  ],
  "stats": {
    "total": 200,
    "additions": 126,
    "deletions": 74
  },
  "files": [
    {
      "sha": "a7f989ec71818fbcdfec8546ec5dbc2225b7af69",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fcf23d5b654b0fc05e99c445ebd471221a290cf4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fcf23d5b654b0fc05e99c445ebd471221a290cf4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=fcf23d5b654b0fc05e99c445ebd471221a290cf4",
      "patch": "@@ -1,3 +1,35 @@\n+2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* dwarf2/read.c (struct mapped_index_base) <symbol_name_at,\n+\tbuild_name_components, find_name_components_bounds>:\n+\tAdd per_objfile parameter.\n+\t(struct mapped_index) <symbol_name_at>: Likewise.\n+\t(struct mapped_debug_names): Remove constructor.\n+\t<dwarf2_per_objfile>: Remove field.\n+\t<namei_to_name, symbol_name_at>: Add per_objfile parameter.\n+\t(mapped_index_base::find_name_components_bounds,\n+\tmapped_index_base::build_name_components,\n+\tdw2_expand_symtabs_matching_symbol): Likewise.\n+\t(class mock_mapped_index) <symbol_name_at>: Likewise.\n+\t(check_match): Likewise.\n+\t(check_find_bounds_finds): Likewise.\n+\t(test_mapped_index_find_name_component_bounds): Update.\n+\t(CHECK_MATCH): Update.\n+\t(dw2_expand_symtabs_matching): Update.\n+\t(class dw2_debug_names_iterator) <dw2_debug_names_iterator>: Add\n+\tper_objfile parameter.\n+\t<find_vec_in_debug_names>: Likewise.\n+\t<m_per_objfile>: New field.\n+\t(mapped_debug_names::namei_to_name): Add dwarf2_per_objfile\n+\tparameter.\n+\t(dw2_debug_names_iterator::find_vec_in_debug_names): Likewise.\n+\t(dw2_debug_names_iterator::next): Update.\n+\t(dw2_debug_names_lookup_symbol): Update.\n+\t(dw2_debug_names_expand_symtabs_for_function): Update.\n+\t(dw2_debug_names_map_matching_symbols): Update.\n+\t(dw2_debug_names_expand_symtabs_matching): Update.\n+\t(dwarf2_read_debug_names): Update.\n+\n 2020-05-27  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* dwarf2/read.h (struct dwarf2_cu): Forward-declare."
    },
    {
      "sha": "df15068269cc1ad71d0c05019d371666e421a5b3",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 94,
      "deletions": 74,
      "changes": 168,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fcf23d5b654b0fc05e99c445ebd471221a290cf4/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fcf23d5b654b0fc05e99c445ebd471221a290cf4/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=fcf23d5b654b0fc05e99c445ebd471221a290cf4",
      "patch": "@@ -164,7 +164,8 @@ struct mapped_index_base\n   virtual size_t symbol_name_count () const = 0;\n \n   /* Get the name of the symbol at IDX in the symbol table.  */\n-  virtual const char *symbol_name_at (offset_type idx) const = 0;\n+  virtual const char *symbol_name_at\n+    (offset_type idx, dwarf2_per_objfile *per_objfile) const = 0;\n \n   /* Return whether the name at IDX in the symbol table should be\n      ignored.  */\n@@ -175,15 +176,16 @@ struct mapped_index_base\n \n   /* Build the symbol name component sorted vector, if we haven't\n      yet.  */\n-  void build_name_components ();\n+  void build_name_components (dwarf2_per_objfile *per_objfile);\n \n   /* Returns the lower (inclusive) and upper (exclusive) bounds of the\n      possible matches for LN_NO_PARAMS in the name component\n      vector.  */\n   std::pair<std::vector<name_component>::const_iterator,\n \t    std::vector<name_component>::const_iterator>\n     find_name_components_bounds (const lookup_name_info &ln_no_params,\n-\t\t\t\t enum language lang) const;\n+\t\t\t\t enum language lang,\n+\t\t\t\t dwarf2_per_objfile *per_objfile) const;\n \n   /* Prevent deleting/destroying via a base class pointer.  */\n protected:\n@@ -221,7 +223,8 @@ struct mapped_index final : public mapped_index_base\n \n   /* Convenience method to get at the name of the symbol at IDX in the\n      symbol table.  */\n-  const char *symbol_name_at (offset_type idx) const override\n+  const char *symbol_name_at\n+    (offset_type idx, dwarf2_per_objfile *per_objfile) const override\n   { return this->constant_pool + MAYBE_SWAP (this->symbol_table[idx].name); }\n \n   size_t symbol_name_count () const override\n@@ -232,11 +235,6 @@ struct mapped_index final : public mapped_index_base\n    Uninitialized map has CU_COUNT 0.  */\n struct mapped_debug_names final : public mapped_index_base\n {\n-  mapped_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile_)\n-  : dwarf2_per_objfile (dwarf2_per_objfile_)\n-  {}\n-\n-  struct dwarf2_per_objfile *dwarf2_per_objfile;\n   bfd_endian dwarf5_byte_order;\n   bool dwarf5_is_dwarf64;\n   bool augmentation_is_gdb;\n@@ -268,13 +266,15 @@ struct mapped_debug_names final : public mapped_index_base\n \n   std::unordered_map<ULONGEST, index_val> abbrev_map;\n \n-  const char *namei_to_name (uint32_t namei) const;\n+  const char *namei_to_name\n+    (uint32_t namei, dwarf2_per_objfile *per_objfile) const;\n \n   /* Implementation of the mapped_index_base virtual interface, for\n      the name_components cache.  */\n \n-  const char *symbol_name_at (offset_type idx) const override\n-  { return namei_to_name (idx); }\n+  const char *symbol_name_at\n+    (offset_type idx, dwarf2_per_objfile *per_objfile) const override\n+  { return namei_to_name (idx, per_objfile); }\n \n   size_t symbol_name_count () const override\n   { return this->name_count; }\n@@ -3691,7 +3691,8 @@ dw2_expand_symtabs_matching_symbol\n    const lookup_name_info &lookup_name_in,\n    gdb::function_view<expand_symtabs_symbol_matcher_ftype> symbol_matcher,\n    enum search_domain kind,\n-   gdb::function_view<bool (offset_type)> match_callback);\n+   gdb::function_view<bool (offset_type)> match_callback,\n+   dwarf2_per_objfile *per_objfile);\n \n static void\n dw2_expand_symtabs_matching_one\n@@ -3741,7 +3742,7 @@ dw2_map_matching_symbols\n \t  dw2_expand_symtabs_matching_one (per_cu, dwarf2_per_objfile, nullptr,\n \t\t\t\t\t   nullptr);\n \treturn true;\n-      });\n+      }, dwarf2_per_objfile);\n     }\n   else\n     {\n@@ -3840,7 +3841,8 @@ make_sort_after_prefix_name (const char *search_name)\n std::pair<std::vector<name_component>::const_iterator,\n \t  std::vector<name_component>::const_iterator>\n mapped_index_base::find_name_components_bounds\n-  (const lookup_name_info &lookup_name_without_params, language lang) const\n+  (const lookup_name_info &lookup_name_without_params, language lang,\n+   dwarf2_per_objfile *per_objfile) const\n {\n   auto *name_cmp\n     = this->name_components_casing == case_sensitive_on ? strcmp : strcasecmp;\n@@ -3853,7 +3855,7 @@ mapped_index_base::find_name_components_bounds\n   auto lookup_compare_lower = [&] (const name_component &elem,\n \t\t\t\t   const char *name)\n     {\n-      const char *elem_qualified = this->symbol_name_at (elem.idx);\n+      const char *elem_qualified = this->symbol_name_at (elem.idx, per_objfile);\n       const char *elem_name = elem_qualified + elem.name_offset;\n       return name_cmp (elem_name, name) < 0;\n     };\n@@ -3863,7 +3865,7 @@ mapped_index_base::find_name_components_bounds\n   auto lookup_compare_upper = [&] (const char *name,\n \t\t\t\t   const name_component &elem)\n     {\n-      const char *elem_qualified = this->symbol_name_at (elem.idx);\n+      const char *elem_qualified = this->symbol_name_at (elem.idx, per_objfile);\n       const char *elem_name = elem_qualified + elem.name_offset;\n       return name_cmp (name, elem_name) < 0;\n     };\n@@ -3912,7 +3914,7 @@ mapped_index_base::find_name_components_bounds\n /* See declaration.  */\n \n void\n-mapped_index_base::build_name_components ()\n+mapped_index_base::build_name_components (dwarf2_per_objfile *per_objfile)\n {\n   if (!this->name_components.empty ())\n     return;\n@@ -3930,7 +3932,7 @@ mapped_index_base::build_name_components ()\n       if (this->symbol_name_slot_invalid (idx))\n \tcontinue;\n \n-      const char *name = this->symbol_name_at (idx);\n+      const char *name = this->symbol_name_at (idx, per_objfile);\n \n       /* Add each name component to the name component table.  */\n       unsigned int previous_len = 0;\n@@ -3968,8 +3970,10 @@ mapped_index_base::build_name_components ()\n   auto name_comp_compare = [&] (const name_component &left,\n \t\t\t\tconst name_component &right)\n     {\n-      const char *left_qualified = this->symbol_name_at (left.idx);\n-      const char *right_qualified = this->symbol_name_at (right.idx);\n+      const char *left_qualified\n+\t= this->symbol_name_at (left.idx, per_objfile);\n+      const char *right_qualified\n+\t= this->symbol_name_at (right.idx, per_objfile);\n \n       const char *left_name = left_qualified + left.name_offset;\n       const char *right_name = right_qualified + right.name_offset;\n@@ -3995,14 +3999,15 @@ dw2_expand_symtabs_matching_symbol\n    const lookup_name_info &lookup_name_in,\n    gdb::function_view<expand_symtabs_symbol_matcher_ftype> symbol_matcher,\n    enum search_domain kind,\n-   gdb::function_view<bool (offset_type)> match_callback)\n+   gdb::function_view<bool (offset_type)> match_callback,\n+   dwarf2_per_objfile *per_objfile)\n {\n   lookup_name_info lookup_name_without_params\n     = lookup_name_in.make_ignore_params ();\n \n   /* Build the symbol name component sorted vector, if we haven't\n      yet.  */\n-  index.build_name_components ();\n+  index.build_name_components (per_objfile);\n \n   /* The same symbol may appear more than once in the range though.\n      E.g., if we're looking for symbols that complete \"w\", and we have\n@@ -4052,14 +4057,15 @@ dw2_expand_symtabs_matching_symbol\n \n       auto bounds\n \t= index.find_name_components_bounds (lookup_name_without_params,\n-\t\t\t\t\t     lang_e);\n+\t\t\t\t\t     lang_e, per_objfile);\n \n       /* Now for each symbol name in range, check to see if we have a name\n \t match, and if so, call the MATCH_CALLBACK callback.  */\n \n       for (; bounds.first != bounds.second; ++bounds.first)\n \t{\n-\t  const char *qualified = index.symbol_name_at (bounds.first->idx);\n+\t  const char *qualified\n+\t    = index.symbol_name_at (bounds.first->idx, per_objfile);\n \n \t  if (!name_matcher (qualified, lookup_name_without_params, NULL)\n \t      || (symbol_matcher != NULL && !symbol_matcher (qualified)))\n@@ -4112,7 +4118,8 @@ class mock_mapped_index : public mapped_index_base\n   }\n \n   /* Get the name of the symbol at IDX in the symbol table.  */\n-  const char *symbol_name_at (offset_type idx) const override\n+  const char *symbol_name_at\n+    (offset_type idx, dwarf2_per_objfile *per_objfile) const override\n   {\n     return m_symbol_table[idx];\n   }\n@@ -4142,7 +4149,8 @@ check_match (const char *file, int line,\n \t     mock_mapped_index &mock_index,\n \t     const char *name, symbol_name_match_type match_type,\n \t     bool completion_mode,\n-\t     std::initializer_list<const char *> expected_list)\n+\t     std::initializer_list<const char *> expected_list,\n+\t     dwarf2_per_objfile *per_objfile)\n {\n   lookup_name_info lookup_name (name, match_type, completion_mode);\n \n@@ -4167,14 +4175,14 @@ check_match (const char *file, int line,\n \t\t\t\t      NULL, ALL_DOMAIN,\n \t\t\t\t      [&] (offset_type idx)\n   {\n-    const char *matched_name = mock_index.symbol_name_at (idx);\n+    const char *matched_name = mock_index.symbol_name_at (idx, per_objfile);\n     const char *expected_str\n       = expected_it == expected_end ? NULL : *expected_it++;\n \n     if (expected_str == NULL || strcmp (expected_str, matched_name) != 0)\n       mismatch (expected_str, matched_name);\n     return true;\n-  });\n+  }, per_objfile);\n \n   const char *expected_str\n   = expected_it == expected_end ? NULL : *expected_it++;\n@@ -4235,13 +4243,15 @@ static const char *test_symbols[] = {\n static bool\n check_find_bounds_finds (mapped_index_base &index,\n \t\t\t const char *search_name,\n-\t\t\t gdb::array_view<const char *> expected_syms)\n+\t\t\t gdb::array_view<const char *> expected_syms,\n+\t\t\t dwarf2_per_objfile *per_objfile)\n {\n   lookup_name_info lookup_name (search_name,\n \t\t\t\tsymbol_name_match_type::FULL, true);\n \n   auto bounds = index.find_name_components_bounds (lookup_name,\n-\t\t\t\t\t\t   language_cplus);\n+\t\t\t\t\t\t   language_cplus,\n+\t\t\t\t\t\t   per_objfile);\n \n   size_t distance = std::distance (bounds.first, bounds.second);\n   if (distance != expected_syms.size ())\n@@ -4250,7 +4260,7 @@ check_find_bounds_finds (mapped_index_base &index,\n   for (size_t exp_elem = 0; exp_elem < distance; exp_elem++)\n     {\n       auto nc_elem = bounds.first + exp_elem;\n-      const char *qualified = index.symbol_name_at (nc_elem->idx);\n+      const char *qualified = index.symbol_name_at (nc_elem->idx, per_objfile);\n       if (strcmp (qualified, expected_syms[exp_elem]) != 0)\n \treturn false;\n     }\n@@ -4266,7 +4276,7 @@ test_mapped_index_find_name_component_bounds ()\n {\n   mock_mapped_index mock_index (test_symbols);\n \n-  mock_index.build_name_components ();\n+  mock_index.build_name_components (NULL /* per_objfile */);\n \n   /* Test the lower-level mapped_index::find_name_component_bounds\n      method in completion mode.  */\n@@ -4276,8 +4286,9 @@ test_mapped_index_find_name_component_bounds ()\n       \"t1_func1\",\n     };\n \n-    SELF_CHECK (check_find_bounds_finds (mock_index,\n-\t\t\t\t\t \"t1_func\", expected_syms));\n+    SELF_CHECK (check_find_bounds_finds\n+\t\t  (mock_index, \"t1_func\", expected_syms,\n+\t\t   NULL /* per_objfile */));\n   }\n \n   /* Check that the increment-last-char in the name matching algorithm\n@@ -4287,14 +4298,15 @@ test_mapped_index_find_name_component_bounds ()\n       \"\\377\",\n       \"\\377\\377123\",\n     };\n-    SELF_CHECK (check_find_bounds_finds (mock_index,\n-\t\t\t\t\t \"\\377\", expected_syms1));\n+    SELF_CHECK (check_find_bounds_finds\n+\t\t  (mock_index, \"\\377\", expected_syms1, NULL /* per_objfile */));\n \n     static const char *expected_syms2[] = {\n       \"\\377\\377123\",\n     };\n-    SELF_CHECK (check_find_bounds_finds (mock_index,\n-\t\t\t\t\t \"\\377\\377\", expected_syms2));\n+    SELF_CHECK (check_find_bounds_finds\n+\t\t  (mock_index, \"\\377\\377\", expected_syms2,\n+\t\t   NULL /* per_objfile */));\n   }\n }\n \n@@ -4320,7 +4332,7 @@ test_dw2_expand_symtabs_matching_symbol ()\n   any_mismatch |= !check_match (__FILE__, __LINE__,\t\t\t\\\n \t\t\t\tmock_index,\t\t\t\t\\\n \t\t\t\tNAME, MATCH_TYPE, COMPLETION_MODE,\t\\\n-\t\t\t\tEXPECTED_LIST)\n+\t\t\t\tEXPECTED_LIST, NULL)\n \n   /* Identity checks.  */\n   for (const char *sym : test_symbols)\n@@ -4743,7 +4755,7 @@ dw2_expand_symtabs_matching\n       dw2_expand_marked_cus (dwarf2_per_objfile, idx, file_matcher,\n \t\t\t     expansion_notify, kind);\n       return true;\n-    });\n+    }, dwarf2_per_objfile);\n }\n \n /* A helper for dw2_find_pc_sect_compunit_symtab which finds the most specific\n@@ -5170,9 +5182,8 @@ create_cus_from_debug_names (dwarf2_per_bfd *per_bfd,\n static bool\n dwarf2_read_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n-  std::unique_ptr<mapped_debug_names> map\n-    (new mapped_debug_names (dwarf2_per_objfile));\n-  mapped_debug_names dwz_map (dwarf2_per_objfile);\n+  std::unique_ptr<mapped_debug_names> map (new mapped_debug_names);\n+  mapped_debug_names dwz_map;\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n \n   if (!read_debug_names_from_section (objfile, objfile_name (objfile),\n@@ -5234,33 +5245,36 @@ class dw2_debug_names_iterator\n   dw2_debug_names_iterator (const mapped_debug_names &map,\n \t\t\t    gdb::optional<block_enum> block_index,\n \t\t\t    domain_enum domain,\n-\t\t\t    const char *name)\n+\t\t\t    const char *name, dwarf2_per_objfile *per_objfile)\n     : m_map (map), m_block_index (block_index), m_domain (domain),\n-      m_addr (find_vec_in_debug_names (map, name))\n+      m_addr (find_vec_in_debug_names (map, name, per_objfile)),\n+      m_per_objfile (per_objfile)\n   {}\n \n   dw2_debug_names_iterator (const mapped_debug_names &map,\n-\t\t\t    search_domain search, uint32_t namei)\n+\t\t\t    search_domain search, uint32_t namei, dwarf2_per_objfile *per_objfile)\n     : m_map (map),\n       m_search (search),\n-      m_addr (find_vec_in_debug_names (map, namei))\n+      m_addr (find_vec_in_debug_names (map, namei, per_objfile)),\n+      m_per_objfile (per_objfile)\n   {}\n \n   dw2_debug_names_iterator (const mapped_debug_names &map,\n \t\t\t    block_enum block_index, domain_enum domain,\n-\t\t\t    uint32_t namei)\n+\t\t\t    uint32_t namei, dwarf2_per_objfile *per_objfile)\n     : m_map (map), m_block_index (block_index), m_domain (domain),\n-      m_addr (find_vec_in_debug_names (map, namei))\n+      m_addr (find_vec_in_debug_names (map, namei, per_objfile)),\n+      m_per_objfile (per_objfile)\n   {}\n \n   /* Return the next matching CU or NULL if there are no more.  */\n   dwarf2_per_cu_data *next ();\n \n private:\n   static const gdb_byte *find_vec_in_debug_names (const mapped_debug_names &map,\n-\t\t\t\t\t\t  const char *name);\n+\t\t\t\t\t\t  const char *name, dwarf2_per_objfile *per_objfile);\n   static const gdb_byte *find_vec_in_debug_names (const mapped_debug_names &map,\n-\t\t\t\t\t\t  uint32_t namei);\n+\t\t\t\t\t\t  uint32_t namei, dwarf2_per_objfile *per_objfile);\n \n   /* The internalized form of .debug_names.  */\n   const mapped_debug_names &m_map;\n@@ -5276,10 +5290,13 @@ class dw2_debug_names_iterator\n   /* The list of CUs from the index entry of the symbol, or NULL if\n      not found.  */\n   const gdb_byte *m_addr;\n+\n+  dwarf2_per_objfile *m_per_objfile;\n };\n \n const char *\n-mapped_debug_names::namei_to_name (uint32_t namei) const\n+mapped_debug_names::namei_to_name\n+  (uint32_t namei, dwarf2_per_objfile *dwarf2_per_objfile) const\n {\n   const ULONGEST namei_string_offs\n     = extract_unsigned_integer ((name_table_string_offs_reordered\n@@ -5296,7 +5313,7 @@ mapped_debug_names::namei_to_name (uint32_t namei) const\n \n const gdb_byte *\n dw2_debug_names_iterator::find_vec_in_debug_names\n-  (const mapped_debug_names &map, const char *name)\n+  (const mapped_debug_names &map, const char *name, dwarf2_per_objfile *per_objfile)\n {\n   int (*cmp) (const char *, const char *);\n \n@@ -5332,7 +5349,7 @@ dw2_debug_names_iterator::find_vec_in_debug_names\n       complaint (_(\"Wrong .debug_names with name index %u but name_count=%u \"\n \t\t   \"[in module %s]\"),\n \t\t namei, map.name_count,\n-\t\t objfile_name (map.dwarf2_per_objfile->objfile));\n+\t\t objfile_name (per_objfile->objfile));\n       return NULL;\n     }\n \n@@ -5347,7 +5364,7 @@ dw2_debug_names_iterator::find_vec_in_debug_names\n \n       if (full_hash == namei_full_hash)\n \t{\n-\t  const char *const namei_string = map.namei_to_name (namei);\n+\t  const char *const namei_string = map.namei_to_name (namei, per_objfile);\n \n #if 0 /* An expensive sanity check.  */\n \t  if (namei_full_hash != dwarf5_djb_hash (namei_string))\n@@ -5377,14 +5394,14 @@ dw2_debug_names_iterator::find_vec_in_debug_names\n \n const gdb_byte *\n dw2_debug_names_iterator::find_vec_in_debug_names\n-  (const mapped_debug_names &map, uint32_t namei)\n+  (const mapped_debug_names &map, uint32_t namei, dwarf2_per_objfile *per_objfile)\n {\n   if (namei >= map.name_count)\n     {\n       complaint (_(\"Wrong .debug_names with name index %u but name_count=%u \"\n \t\t   \"[in module %s]\"),\n \t\t namei, map.name_count,\n-\t\t objfile_name (map.dwarf2_per_objfile->objfile));\n+\t\t objfile_name (per_objfile->objfile));\n       return NULL;\n     }\n \n@@ -5403,8 +5420,8 @@ dw2_debug_names_iterator::next ()\n   if (m_addr == NULL)\n     return NULL;\n \n-  struct dwarf2_per_objfile *dwarf2_per_objfile = m_map.dwarf2_per_objfile;\n-  struct objfile *objfile = dwarf2_per_objfile->objfile;\n+  dwarf2_per_bfd *per_bfd = m_per_objfile->per_bfd;\n+  struct objfile *objfile = m_per_objfile->objfile;\n   bfd *const abfd = objfile->obfd;\n \n  again:\n@@ -5467,33 +5484,33 @@ dw2_debug_names_iterator::next ()\n \t{\n \tcase DW_IDX_compile_unit:\n \t  /* Don't crash on bad data.  */\n-\t  if (ull >= dwarf2_per_objfile->per_bfd->all_comp_units.size ())\n+\t  if (ull >= m_per_objfile->per_bfd->all_comp_units.size ())\n \t    {\n \t      complaint (_(\".debug_names entry has bad CU index %s\"\n \t\t\t   \" [in module %s]\"),\n \t\t\t pulongest (ull),\n-\t\t\t objfile_name (dwarf2_per_objfile->objfile));\n+\t\t\t objfile_name (objfile));\n \t      continue;\n \t    }\n-\t  per_cu = dwarf2_per_objfile->per_bfd->get_cutu (ull);\n+\t  per_cu = per_bfd->get_cutu (ull);\n \t  break;\n \tcase DW_IDX_type_unit:\n \t  /* Don't crash on bad data.  */\n-\t  if (ull >= dwarf2_per_objfile->per_bfd->all_type_units.size ())\n+\t  if (ull >= per_bfd->all_type_units.size ())\n \t    {\n \t      complaint (_(\".debug_names entry has bad TU index %s\"\n \t\t\t   \" [in module %s]\"),\n \t\t\t pulongest (ull),\n-\t\t\t objfile_name (dwarf2_per_objfile->objfile));\n+\t\t\t objfile_name (objfile));\n \t      continue;\n \t    }\n-\t  per_cu = &dwarf2_per_objfile->per_bfd->get_tu (ull)->per_cu;\n+\t  per_cu = &per_bfd->get_tu (ull)->per_cu;\n \t  break;\n \tcase DW_IDX_die_offset:\n \t  /* In a per-CU index (as opposed to a per-module index), index\n \t     entries without CU attribute implicitly refer to the single CU.  */\n \t  if (per_cu == NULL)\n-\t    per_cu = dwarf2_per_objfile->per_bfd->get_cu (0);\n+\t    per_cu = per_bfd->get_cu (0);\n \t  break;\n \tcase DW_IDX_GNU_internal:\n \t  if (!m_map.augmentation_is_gdb)\n@@ -5509,7 +5526,7 @@ dw2_debug_names_iterator::next ()\n     }\n \n   /* Skip if already read in.  */\n-  if (dwarf2_per_objfile->symtab_set_p (per_cu))\n+  if (m_per_objfile->symtab_set_p (per_cu))\n     goto again;\n \n   /* Check static vs global.  */\n@@ -5634,7 +5651,8 @@ dw2_debug_names_lookup_symbol (struct objfile *objfile, block_enum block_index,\n     }\n   const auto &map = *mapp;\n \n-  dw2_debug_names_iterator iter (map, block_index, domain, name);\n+  dw2_debug_names_iterator iter (map, block_index, domain, name,\n+\t\t\t\t dwarf2_per_objfile);\n \n   struct compunit_symtab *stab_best = NULL;\n   struct dwarf2_per_cu_data *per_cu;\n@@ -5698,7 +5716,8 @@ dw2_debug_names_expand_symtabs_for_function (struct objfile *objfile,\n     {\n       const mapped_debug_names &map = *dwarf2_per_objfile->per_bfd->debug_names_table;\n \n-      dw2_debug_names_iterator iter (map, {}, VAR_DOMAIN, func_name);\n+      dw2_debug_names_iterator iter (map, {}, VAR_DOMAIN, func_name,\n+\t\t\t\t     dwarf2_per_objfile);\n \n       struct dwarf2_per_cu_data *per_cu;\n       while ((per_cu = iter.next ()) != NULL)\n@@ -5737,14 +5756,15 @@ dw2_debug_names_map_matching_symbols\n     {\n       /* The name was matched, now expand corresponding CUs that were\n \t marked.  */\n-      dw2_debug_names_iterator iter (map, block_kind, domain, namei);\n+      dw2_debug_names_iterator iter (map, block_kind, domain, namei,\n+\t\t\t\t     dwarf2_per_objfile);\n \n       struct dwarf2_per_cu_data *per_cu;\n       while ((per_cu = iter.next ()) != NULL)\n \tdw2_expand_symtabs_matching_one (per_cu, dwarf2_per_objfile, nullptr,\n \t\t\t\t\t nullptr);\n       return true;\n-    });\n+    }, dwarf2_per_objfile);\n \n   /* It's a shame we couldn't do this inside the\n      dw2_expand_symtabs_matching_symbol callback, but that skips CUs\n@@ -5802,14 +5822,14 @@ dw2_debug_names_expand_symtabs_matching\n     {\n       /* The name was matched, now expand corresponding CUs that were\n \t marked.  */\n-      dw2_debug_names_iterator iter (map, kind, namei);\n+      dw2_debug_names_iterator iter (map, kind, namei, dwarf2_per_objfile);\n \n       struct dwarf2_per_cu_data *per_cu;\n       while ((per_cu = iter.next ()) != NULL)\n \tdw2_expand_symtabs_matching_one (per_cu, dwarf2_per_objfile,\n \t\t\t\t\t file_matcher, expansion_notify);\n       return true;\n-    });\n+    }, dwarf2_per_objfile);\n }\n \n const struct quick_symbol_functions dwarf2_debug_names_functions ="
    }
  ]
}