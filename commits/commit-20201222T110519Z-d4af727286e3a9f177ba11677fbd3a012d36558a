{
  "sha": "d4af727286e3a9f177ba11677fbd3a012d36558a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDRhZjcyNzI4NmUzYTlmMTc3YmExMTY3N2ZiZDNhMDEyZDM2NTU4YQ==",
  "commit": {
    "author": {
      "name": "Anton Kolesov",
      "email": "Anton.Kolesov@synopsys.com",
      "date": "2016-12-22T18:52:16Z"
    },
    "committer": {
      "name": "Shahab Vahedi",
      "email": "shahab@synopsys.com",
      "date": "2020-12-22T11:05:19Z"
    },
    "message": "arc: Add support for signal frames for Linux targets\n\nImplement functions needed to unwind signal frames on ARC Linux targets.\n\ngdb/ChangeLog\n\n\t* arc-linux-tdep.c (arc_linux_sc_reg_offsets): New static variable.\n\t(arc_linux_is_sigtramp): New function.\n\t(arc_linux_sigcontext_addr): Likewise.\n\t(arc_linux_init_osabi): Use them.",
    "tree": {
      "sha": "4b4295e77472494ddacf8f2605310ffc43a47cef",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/4b4295e77472494ddacf8f2605310ffc43a47cef"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d4af727286e3a9f177ba11677fbd3a012d36558a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d4af727286e3a9f177ba11677fbd3a012d36558a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d4af727286e3a9f177ba11677fbd3a012d36558a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d4af727286e3a9f177ba11677fbd3a012d36558a/comments",
  "author": {
    "login": "anthony-kolesov",
    "id": 602123,
    "node_id": "MDQ6VXNlcjYwMjEyMw==",
    "avatar_url": "https://avatars.githubusercontent.com/u/602123?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/anthony-kolesov",
    "html_url": "https://github.com/anthony-kolesov",
    "followers_url": "https://api.github.com/users/anthony-kolesov/followers",
    "following_url": "https://api.github.com/users/anthony-kolesov/following{/other_user}",
    "gists_url": "https://api.github.com/users/anthony-kolesov/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/anthony-kolesov/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/anthony-kolesov/subscriptions",
    "organizations_url": "https://api.github.com/users/anthony-kolesov/orgs",
    "repos_url": "https://api.github.com/users/anthony-kolesov/repos",
    "events_url": "https://api.github.com/users/anthony-kolesov/events{/privacy}",
    "received_events_url": "https://api.github.com/users/anthony-kolesov/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": null,
  "parents": [
    {
      "sha": "b4e3cd0440109d0a5552d3313ccbd35c8103335b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b4e3cd0440109d0a5552d3313ccbd35c8103335b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b4e3cd0440109d0a5552d3313ccbd35c8103335b"
    }
  ],
  "stats": {
    "total": 188,
    "additions": 188,
    "deletions": 0
  },
  "files": [
    {
      "sha": "05c82f60888bd5ac8ee6e27c39604806ca95642a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d4af727286e3a9f177ba11677fbd3a012d36558a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d4af727286e3a9f177ba11677fbd3a012d36558a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d4af727286e3a9f177ba11677fbd3a012d36558a",
      "patch": "@@ -1,3 +1,10 @@\n+2020-12-22  Anton Kolesov  <anton.kolesov@synopsys.com>\n+\n+\t* arc-linux-tdep.c (arc_linux_sc_reg_offsets): New static variable.\n+\t(arc_linux_is_sigtramp): New function.\n+\t(arc_linux_sigcontext_addr): Likewise.\n+\t(arc_linux_init_osabi): Use them.\n+\n 2020-12-22  Anton Kolesov  <anton.kolesov@synopsys.com>\n \n \t* arc-tdep.c (arc_make_sigtramp_frame_cache): New function."
    },
    {
      "sha": "c86bd601c9b8e874d0cee7b56bda3c3738287a41",
      "filename": "gdb/arc-linux-tdep.c",
      "status": "modified",
      "additions": 181,
      "deletions": 0,
      "changes": 181,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d4af727286e3a9f177ba11677fbd3a012d36558a/gdb/arc-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d4af727286e3a9f177ba11677fbd3a012d36558a/gdb/arc-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arc-linux-tdep.c?ref=d4af727286e3a9f177ba11677fbd3a012d36558a",
      "patch": "@@ -33,6 +33,60 @@\n \n #define REGOFF(offset) (offset * ARC_REGISTER_SIZE)\n \n+/* arc_linux_sc_reg_offsets[i] is the offset of register i in the `struct\n+   sigcontext'.  Array index is an internal GDB register number, as defined in\n+   arc-tdep.h:arc_regnum.\n+\n+   From <include/uapi/asm/sigcontext.h> and <include/uapi/asm/ptrace.h>.\n+\n+   The layout of this struct is tightly bound to \"arc_regnum\" enum\n+   in arc-tdep.h.  Any change of order in there, must be reflected\n+   here as well.  */\n+static const int arc_linux_sc_reg_offsets[] = {\n+  /* R0 - R12.  */\n+  REGOFF (22), REGOFF (21), REGOFF (20), REGOFF (19),\n+  REGOFF (18), REGOFF (17), REGOFF (16), REGOFF (15),\n+  REGOFF (14), REGOFF (13), REGOFF (12), REGOFF (11),\n+  REGOFF (10),\n+\n+  /* R13 - R25.  */\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER,\n+\n+  REGOFF (9),\t\t\t/* R26 (GP) */\n+  REGOFF (8),\t\t\t/* FP */\n+  REGOFF (23),\t\t\t/* SP */\n+  ARC_OFFSET_NO_REGISTER,\t/* ILINK */\n+  ARC_OFFSET_NO_REGISTER,\t/* R30 */\n+  REGOFF (7),\t\t\t/* BLINK */\n+\n+  /* R32 - R59.  */\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER, ARC_OFFSET_NO_REGISTER,\n+  ARC_OFFSET_NO_REGISTER,\n+\n+  REGOFF (4),\t\t\t/* LP_COUNT */\n+  ARC_OFFSET_NO_REGISTER,\t/* RESERVED */\n+  ARC_OFFSET_NO_REGISTER,\t/* LIMM */\n+  ARC_OFFSET_NO_REGISTER,\t/* PCL */\n+\n+  REGOFF (6),\t\t\t/* PC  */\n+  REGOFF (5),\t\t\t/* STATUS32 */\n+  REGOFF (2),\t\t\t/* LP_START */\n+  REGOFF (3),\t\t\t/* LP_END */\n+  REGOFF (1),\t\t\t/* BTA */\n+};\n+\n /* arc_linux_core_reg_offsets[i] is the offset in the .reg section of GDB\n    regnum i.  Array index is an internal GDB register number, as defined in\n    arc-tdep.h:arc_regnum.\n@@ -87,6 +141,127 @@ static const int arc_linux_core_reg_offsets[] = {\n   REGOFF (6)\t\t\t/* ERET */\n };\n \n+/* Is THIS_FRAME a sigtramp function - the function that returns from\n+   signal handler into normal execution flow? This is the case if the PC is\n+   either at the start of, or in the middle of the two instructions:\n+\n+     mov r8, __NR_rt_sigreturn ; __NR_rt_sigreturn == 139\n+     trap_s 0 ; `swi' for ARC700\n+\n+   On ARC uClibc Linux this function is called __default_rt_sa_restorer.\n+\n+   Returns TRUE if this is a sigtramp frame.  */\n+\n+static bool\n+arc_linux_is_sigtramp (struct frame_info *this_frame)\n+{\n+  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n+  CORE_ADDR pc = get_frame_pc (this_frame);\n+\n+  if (arc_debug)\n+    {\n+      debug_printf (\"arc-linux: arc_linux_is_sigtramp, pc=%s\\n\",\n+\t\t    paddress(gdbarch, pc));\n+    }\n+\n+  static const gdb_byte insns_be_hs[] = {\n+    0x20, 0x8a, 0x12, 0xc2,\t/* mov  r8,nr_rt_sigreturn */\n+    0x78, 0x1e\t\t\t/* trap_s 0 */\n+  };\n+  static const gdb_byte insns_be_700[] = {\n+    0x20, 0x8a, 0x12, 0xc2,\t/* mov  r8,nr_rt_sigreturn */\n+    0x22, 0x6f, 0x00, 0x3f\t/* swi */\n+  };\n+\n+  gdb_byte arc_sigtramp_insns[sizeof (insns_be_700)];\n+  size_t insns_sz;\n+  if (arc_mach_is_arcv2 (gdbarch))\n+    {\n+      insns_sz = sizeof (insns_be_hs);\n+      memcpy (arc_sigtramp_insns, insns_be_hs, insns_sz);\n+    }\n+  else\n+    {\n+      insns_sz = sizeof (insns_be_700);\n+      memcpy (arc_sigtramp_insns, insns_be_700, insns_sz);\n+    }\n+  if (gdbarch_byte_order (gdbarch) == BFD_ENDIAN_LITTLE)\n+    {\n+      /* On little endian targets, ARC code section is in what is called\n+\t \"middle endian\", where half-words are in the big-endian order,\n+\t only bytes inside the halfwords are in the little endian order.\n+\t As a result it is very easy to convert big endian instruction to\n+\t little endian, since it is needed to swap bytes in the halfwords,\n+\t so there is no need to have information on whether that is a\n+\t 4-byte instruction or 2-byte.  */\n+      gdb_assert ((insns_sz % 2) == 0);\n+      for (int i = 0; i < insns_sz; i += 2)\n+\tstd::swap (arc_sigtramp_insns[i], arc_sigtramp_insns[i+1]);\n+    }\n+\n+  gdb_byte buf[insns_sz];\n+\n+  /* Read the memory at the PC.  Since we are stopped, any breakpoint must\n+     have been removed.  */\n+  if (!safe_frame_unwind_memory (this_frame, pc, buf, insns_sz))\n+    {\n+      /* Failed to unwind frame.  */\n+      return FALSE;\n+    }\n+\n+  /* Is that code the sigtramp instruction sequence?  */\n+  if (memcmp (buf, arc_sigtramp_insns, insns_sz) == 0)\n+    return TRUE;\n+\n+  /* No - look one instruction earlier in the code...  */\n+  if (!safe_frame_unwind_memory (this_frame, pc - 4, buf, insns_sz))\n+    {\n+      /* Failed to unwind frame.  */\n+      return FALSE;\n+    }\n+\n+  return (memcmp (buf, arc_sigtramp_insns, insns_sz) == 0);\n+}\n+\n+/* Get sigcontext structure of sigtramp frame - it contains saved\n+   registers of interrupted frame.\n+\n+   Stack pointer points to the rt_sigframe structure, and sigcontext can\n+   be found as in:\n+\n+   struct rt_sigframe {\n+     struct siginfo info;\n+     struct ucontext uc;\n+     ...\n+   };\n+\n+   struct ucontext {\n+     unsigned long uc_flags;\n+     struct ucontext *uc_link;\n+     stack_t uc_stack;\n+     struct sigcontext uc_mcontext;\n+     sigset_t uc_sigmask;\n+   };\n+\n+   sizeof (struct siginfo) == 0x80\n+   offsetof (struct ucontext, uc_mcontext) == 0x14\n+\n+   GDB cannot include linux headers and use offsetof () because those are\n+   target headers and GDB might be built for a different run host.  There\n+   doesn't seem to be an established mechanism to figure out those offsets\n+   via gdbserver, so the only way is to hardcode values in the GDB,\n+   meaning that GDB will be broken if values will change.  That seems to\n+   be a very unlikely scenario and other arches (aarch64, alpha, amd64,\n+   etc) in GDB hardcode values.  */\n+\n+static CORE_ADDR\n+arc_linux_sigcontext_addr (struct frame_info *this_frame)\n+{\n+  const int ucontext_offset = 0x80;\n+  const int sigcontext_offset = 0x14;\n+  return get_frame_sp (this_frame) + ucontext_offset + sigcontext_offset;\n+}\n+\n /* Implement the \"cannot_fetch_register\" gdbarch method.  */\n \n static int\n@@ -430,6 +605,12 @@ arc_linux_init_osabi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   if (arc_debug)\n     debug_printf (\"arc-linux: GNU/Linux OS/ABI initialization.\\n\");\n \n+  /* Fill in target-dependent info in ARC-private structure.  */\n+  tdep->is_sigtramp = arc_linux_is_sigtramp;\n+  tdep->sigcontext_addr = arc_linux_sigcontext_addr;\n+  tdep->sc_reg_offset = arc_linux_sc_reg_offsets;\n+  tdep->sc_num_regs = ARRAY_SIZE (arc_linux_sc_reg_offsets);\n+\n   /* If we are using Linux, we have in uClibc\n      (libc/sysdeps/linux/arc/bits/setjmp.h):\n "
    }
  ]
}