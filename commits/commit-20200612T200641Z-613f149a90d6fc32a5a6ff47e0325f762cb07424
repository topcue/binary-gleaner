{
  "sha": "613f149a90d6fc32a5a6ff47e0325f762cb07424",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjEzZjE0OWE5MGQ2ZmMzMmE1YTZmZjQ3ZTAzMjVmNzYyY2IwNzQyNA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-12T20:06:41Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-06-12T20:06:41Z"
    },
    "message": "gdbserver: remove support for Neutrino\n\nThis port has been unmaintained for years, remove it.\n\ngdbserver/ChangeLog:\n\n\t* configure: Re-generate.\n\t* configure.ac: Remove srv_qnx test.\n\t* configure.srv: Remove nto case.\n\t* nto-low.cc, nto-low.h, nto-x86-low.cc: Remove.\n\t* remote-utils.c: Remove __QNX__-guarded code.\n\nChange-Id: I8a1ad9c740a69352da1f6993778dbf951eebb22f",
    "tree": {
      "sha": "a3086accc640d461ab2c44828a473ca1729949bf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a3086accc640d461ab2c44828a473ca1729949bf"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/613f149a90d6fc32a5a6ff47e0325f762cb07424",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/613f149a90d6fc32a5a6ff47e0325f762cb07424",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/613f149a90d6fc32a5a6ff47e0325f762cb07424",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/613f149a90d6fc32a5a6ff47e0325f762cb07424/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a"
    }
  ],
  "stats": {
    "total": 1232,
    "additions": 8,
    "deletions": 1224
  },
  "files": [
    {
      "sha": "07cf443354e375e2787fc0ad6dddab3bc7ad64cc",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=613f149a90d6fc32a5a6ff47e0325f762cb07424",
      "patch": "@@ -1,3 +1,11 @@\n+2020-06-12  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* configure: Re-generate.\n+\t* configure.ac: Remove srv_qnx test.\n+\t* configure.srv: Remove nto case.\n+\t* nto-low.cc, nto-low.h, nto-x86-low.cc: Remove.\n+\t* remote-utils.c: Remove __QNX__-guarded code.\n+\n 2020-06-12  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* configure: Re-generate."
    },
    {
      "sha": "0f77ac6cb8dd3144990f32c679cf7c68c4f0307b",
      "filename": "gdbserver/configure",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure?ref=613f149a90d6fc32a5a6ff47e0325f762cb07424",
      "patch": "@@ -10252,8 +10252,6 @@ if test \"${srv_mingwce}\" = \"yes\"; then\n elif test \"${srv_mingw}\" = \"yes\"; then\n   # WIN32APILIBS is set by GDB_AC_COMMON.\n   LIBS=\"$LIBS $WIN32APILIBS\"\n-elif test \"${srv_qnx}\" = \"yes\"; then\n-  LIBS=\"$LIBS -lsocket\"\n fi\n \n if test \"${srv_linux_usrregs}\" = \"yes\"; then"
    },
    {
      "sha": "10f2f4c0cb07a3ca2db153eea13bf8c34bebce30",
      "filename": "gdbserver/configure.ac",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure.ac?ref=613f149a90d6fc32a5a6ff47e0325f762cb07424",
      "patch": "@@ -225,8 +225,6 @@ if test \"${srv_mingwce}\" = \"yes\"; then\n elif test \"${srv_mingw}\" = \"yes\"; then\n   # WIN32APILIBS is set by GDB_AC_COMMON.\n   LIBS=\"$LIBS $WIN32APILIBS\"\n-elif test \"${srv_qnx}\" = \"yes\"; then\n-  LIBS=\"$LIBS -lsocket\"\n fi\n \n if test \"${srv_linux_usrregs}\" = \"yes\"; then"
    },
    {
      "sha": "0a3bf32dd18c79fe729009f2f9e858249da1c6a6",
      "filename": "gdbserver/configure.srv",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/configure.srv",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/configure.srv",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/configure.srv?ref=613f149a90d6fc32a5a6ff47e0325f762cb07424",
      "patch": "@@ -136,10 +136,6 @@ case \"${gdbserver_host}\" in\n \t\t\tsrv_tgtobj=\"${srv_tgtobj} arch/i386.o\"\n \t\t\tsrv_mingw=yes\n \t\t\t;;\n-  i[34567]86-*-nto*)\tsrv_regobj=\"\"\n-\t\t\tsrv_tgtobj=\"nto-low.o nto-x86-low.o arch/i386.o\"\n-\t\t\tsrv_qnx=\"yes\"\n-\t\t\t;;\n   ia64-*-linux*)\tsrv_regobj=reg-ia64.o\n \t\t\tsrv_tgtobj=\"$srv_linux_obj linux-ia64-low.o\"\n \t\t\tsrv_linux_usrregs=yes"
    },
    {
      "sha": "a88ad02f6454fc87335deaf4fb7be2deb5aea81a",
      "filename": "gdbserver/nto-low.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 965,
      "changes": 965,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/nto-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/nto-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/nto-low.cc?ref=fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "patch": "@@ -1,965 +0,0 @@\n-/* QNX Neutrino specific low level interface, for the remote server\n-   for GDB.\n-   Copyright (C) 2009-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-\n-#include \"server.h\"\n-#include \"gdbthread.h\"\n-#include \"nto-low.h\"\n-#include \"hostio.h\"\n-#include \"debug.h\"\n-\n-#include <limits.h>\n-#include <fcntl.h>\n-#include <spawn.h>\n-#include <sys/procfs.h>\n-#include <sys/auxv.h>\n-#include <sys/iomgr.h>\n-#include <sys/neutrino.h>\n-\n-\n-int using_threads = 1;\n-\n-const struct target_desc *nto_tdesc;\n-\n-static void\n-nto_trace (const char *fmt, ...)\n-{\n-  va_list arg_list;\n-\n-  if (debug_threads == 0)\n-    return;\n-  fprintf (stderr, \"nto:\");\n-  va_start (arg_list, fmt);\n-  vfprintf (stderr, fmt, arg_list);\n-  va_end (arg_list);\n-}\n-\n-#define TRACE nto_trace\n-\n-/* Structure holding neutrino specific information about\n-   inferior.  */\n-\n-struct nto_inferior\n-{\n-  char nto_procfs_path[PATH_MAX];\n-  int ctl_fd;\n-  pid_t pid;\n-  int exit_signo; /* For tracking exit status.  */\n-};\n-\n-static struct nto_inferior nto_inferior;\n-\n-static void\n-init_nto_inferior (struct nto_inferior *nto_inferior)\n-{\n-  memset (nto_inferior, 0, sizeof (struct nto_inferior));\n-  nto_inferior->ctl_fd = -1;\n-  nto_inferior->pid = -1;\n-}\n-\n-static void\n-do_detach (void)\n-{\n-  if (nto_inferior.ctl_fd != -1)\n-    {\n-      nto_trace (\"Closing fd\\n\");\n-      close (nto_inferior.ctl_fd);\n-      init_nto_inferior (&nto_inferior);\n-    }\n-}\n-\n-/* Set current thread. Return 1 on success, 0 otherwise.  */\n-\n-static int\n-nto_set_thread (ptid_t ptid)\n-{\n-  int res = 0;\n-\n-  TRACE (\"%s pid: %d tid: %ld\\n\", __func__, ptid.pid (),\n-\t ptid.lwp ());\n-  if (nto_inferior.ctl_fd != -1\n-      && ptid != null_ptid\n-      && ptid != minus_one_ptid)\n-    {\n-      pthread_t tid = ptid.lwp ();\n-\n-      if (EOK == devctl (nto_inferior.ctl_fd, DCMD_PROC_CURTHREAD, &tid,\n-\t  sizeof (tid), 0))\n-\tres = 1;\n-      else\n-\tTRACE (\"%s: Error: failed to set current thread\\n\", __func__);\n-    }\n-  return res;\n-}\n-\n-/* This function will determine all alive threads.  Note that we do not list\n-   dead but unjoined threads even though they are still in the process' thread\n-   list.  \n-\n-   NTO_INFERIOR must not be NULL.  */\n-\n-static void\n-nto_find_new_threads (struct nto_inferior *nto_inferior)\n-{\n-  pthread_t tid;\n-\n-  TRACE (\"%s pid:%d\\n\", __func__, nto_inferior->pid);\n-\n-  if (nto_inferior->ctl_fd == -1)\n-    return;\n-\n-  for (tid = 1;; ++tid)\n-    {\n-      procfs_status status;\n-      ptid_t ptid;\n-      int err;\n-\n-      status.tid = tid;\n-      err = devctl (nto_inferior->ctl_fd, DCMD_PROC_TIDSTATUS, &status,\n-\t\t    sizeof (status), 0);\n-\n-      if (err != EOK || status.tid == 0)\n-\tbreak;\n-\n-      /* All threads in between are gone.  */\n-      while (tid != status.tid || status.state == STATE_DEAD)\n-\t{\n-\t  struct thread_info *ti;\n-\n-\t  ptid = ptid_t (nto_inferior->pid, tid, 0);\n-\t  ti = find_thread_ptid (ptid);\n-\t  if (ti != NULL)\n-\t    {\n-\t      TRACE (\"Removing thread %d\\n\", tid);\n-\t      remove_thread (ti);\n-\t    }\n-\t  if (tid == status.tid)\n-\t    break;\n-\t  ++tid;\n-\t}\n-\n-      if (status.state != STATE_DEAD)\n-\t{\n-\t  TRACE (\"Adding thread %d\\n\", tid);\n-\t  ptid = ptid_t (nto_inferior->pid, tid, 0);\n-\t  if (!find_thread_ptid (ptid))\n-\t    add_thread (ptid, NULL);\n-\t}\n-    }\n-}\n-\n-/* Given pid, open procfs path.  */\n-\n-static pid_t\n-do_attach (pid_t pid)\n-{\n-  procfs_status status;\n-  struct sigevent event;\n-\n-  if (nto_inferior.ctl_fd != -1)\n-    {\n-      close (nto_inferior.ctl_fd);\n-      init_nto_inferior (&nto_inferior);\n-    }\n-  xsnprintf (nto_inferior.nto_procfs_path, PATH_MAX - 1, \"/proc/%d/as\", pid);\n-  nto_inferior.ctl_fd = open (nto_inferior.nto_procfs_path, O_RDWR);\n-  if (nto_inferior.ctl_fd == -1)\n-    {\n-      TRACE (\"Failed to open %s\\n\", nto_inferior.nto_procfs_path);\n-      init_nto_inferior (&nto_inferior);\n-      return -1;\n-    }\n-  if (devctl (nto_inferior.ctl_fd, DCMD_PROC_STOP, &status, sizeof (status), 0)\n-      != EOK)\n-    {\n-      do_detach ();\n-      return -1;\n-    }\n-  nto_inferior.pid = pid;\n-  /* Define a sigevent for process stopped notification.  */\n-  event.sigev_notify = SIGEV_SIGNAL_THREAD;\n-  event.sigev_signo = SIGUSR1;\n-  event.sigev_code = 0;\n-  event.sigev_value.sival_ptr = NULL;\n-  event.sigev_priority = -1;\n-  devctl (nto_inferior.ctl_fd, DCMD_PROC_EVENT, &event, sizeof (event), 0);\n-\n-  if (devctl (nto_inferior.ctl_fd, DCMD_PROC_STATUS, &status, sizeof (status),\n-\t      0) == EOK\n-      && (status.flags & _DEBUG_FLAG_STOPPED))\n-    {\n-      ptid_t ptid;\n-      struct process_info *proc;\n-\n-      kill (pid, SIGCONT);\n-      ptid = ptid_t (status.pid, status.tid, 0);\n-      the_low_target.arch_setup ();\n-      proc = add_process (status.pid, 1);\n-      proc->tdesc = nto_tdesc;\n-      TRACE (\"Adding thread: pid=%d tid=%ld\\n\", status.pid,\n-\t     ptid.lwp ());\n-      nto_find_new_threads (&nto_inferior);\n-    }\n-  else\n-    {\n-      do_detach ();\n-      return -1;\n-    }\n-\n-  return pid;\n-}\n-\n-/* Read or write LEN bytes from/to inferior's MEMADDR memory address\n-   into gdbservers's MYADDR buffer.  Return number of bytes actually\n-   transfered.  */\n-\n-static int\n-nto_xfer_memory (off_t memaddr, unsigned char *myaddr, int len,\n-\t\t int dowrite)\n-{\n-  int nbytes = 0;\n-\n-  if (lseek (nto_inferior.ctl_fd, memaddr, SEEK_SET) == memaddr)\n-    {\n-      if (dowrite)\n-\tnbytes = write (nto_inferior.ctl_fd, myaddr, len);\n-      else\n-\tnbytes = read (nto_inferior.ctl_fd, myaddr, len);\n-      if (nbytes < 0)\n-\tnbytes = 0;\n-    }\n-  if (nbytes == 0)\n-    {\n-      int e = errno;\n-      TRACE (\"Error in %s : errno=%d (%s)\\n\", __func__, e, safe_strerror (e));\n-    }\n-  return nbytes;\n-}\n-\n-/* Insert or remove breakpoint or watchpoint at address ADDR.\n-   TYPE can be one of Neutrino breakpoint types.  SIZE must be 0 for\n-   inserting the point, -1 for removing it.  \n-\n-   Return 0 on success, 1 otherwise.  */\n-\n-static int\n-nto_breakpoint (CORE_ADDR addr, int type, int size)\n-{\n-  procfs_break brk;\n-\n-  brk.type = type;\n-  brk.addr = addr;\n-  brk.size = size;\n-  if (devctl (nto_inferior.ctl_fd, DCMD_PROC_BREAK, &brk, sizeof (brk), 0)\n-      != EOK)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Read auxiliary vector from inferior's initial stack into gdbserver's\n-   MYADDR buffer, up to LEN bytes.  \n-\n-   Return number of bytes read.  */\n-\n-static int\n-nto_read_auxv_from_initial_stack (CORE_ADDR initial_stack,\n-\t\t\t\t  unsigned char *myaddr,\n-\t\t\t\t  unsigned int len)\n-{\n-  int data_ofs = 0;\n-  int anint;\n-  unsigned int len_read = 0;\n-\n-  /* Skip over argc, argv and envp... Comment from ldd.c:\n-\n-     The startup frame is set-up so that we have:\n-     auxv\n-     NULL\n-     ...\n-     envp2\n-     envp1 <----- void *frame + (argc + 2) * sizeof(char *)\n-     NULL\n-     ...\n-     argv2\n-     argv1\n-     argc  <------ void * frame\n-\n-     On entry to ldd, frame gives the address of argc on the stack.  */\n-  if (nto_xfer_memory (initial_stack, (unsigned char *)&anint,\n-\t\t       sizeof (anint), 0) != sizeof (anint))\n-    return 0;\n-\n-  /* Size of pointer is assumed to be 4 bytes (32 bit arch. ) */\n-  data_ofs += (anint + 2) * sizeof (void *); /* + 2 comes from argc itself and\n-\t\t\t\t\t\tNULL terminating pointer in\n-\t\t\t\t\t\targv.  */\n-\n-  /* Now loop over env table:  */\n-  while (nto_xfer_memory (initial_stack + data_ofs,\n-\t\t\t  (unsigned char *)&anint, sizeof (anint), 0)\n-\t == sizeof (anint))\n-    {\n-      data_ofs += sizeof (anint);\n-      if (anint == 0)\n-\tbreak;\n-    }\n-  initial_stack += data_ofs;\n-\n-  memset (myaddr, 0, len);\n-  while (len_read <= len - sizeof (auxv_t))\n-    {\n-      auxv_t *auxv = (auxv_t *)myaddr;\n-\n-      /* Search backwards until we have read AT_PHDR (num. 3),\n-\t AT_PHENT (num 4), AT_PHNUM (num 5)  */\n-      if (nto_xfer_memory (initial_stack, (unsigned char *)auxv,\n-\t\t\t   sizeof (auxv_t), 0) == sizeof (auxv_t))\n-\t{\n-\t  if (auxv->a_type != AT_NULL)\n-\t    {\n-\t      auxv++;\n-\t      len_read += sizeof (auxv_t);\n-\t    }\n-\t  if (auxv->a_type == AT_PHNUM) /* That's all we need.  */\n-\t    break;\n-\t  initial_stack += sizeof (auxv_t);\n-\t}\n-      else\n-\tbreak;\n-    }\n-  TRACE (\"auxv: len_read: %d\\n\", len_read);\n-  return len_read;\n-}\n-\n-/* Start inferior specified by PROGRAM, using PROGRAM_ARGS as its\n-   arguments.  */\n-\n-int\n-nto_process_target::create_inferior (const char *program,\n-\t\t\t\t     const std::vector<char *> &program_args)\n-{\n-  struct inheritance inherit;\n-  pid_t pid;\n-  sigset_t set;\n-\n-  TRACE (\"%s %s\\n\", __func__, program);\n-  /* Clear any pending SIGUSR1's but keep the behavior the same.  */\n-  signal (SIGUSR1, signal (SIGUSR1, SIG_IGN));\n-\n-  sigemptyset (&set);\n-  sigaddset (&set, SIGUSR1);\n-  sigprocmask (SIG_UNBLOCK, &set, NULL);\n-\n-  memset (&inherit, 0, sizeof (inherit));\n-  inherit.flags |= SPAWN_SETGROUP | SPAWN_HOLD;\n-  inherit.pgroup = SPAWN_NEWPGROUP;\n-  pid = spawnp (program, 0, NULL, &inherit,\n-\t\tprogram_args.data (), 0);\n-  sigprocmask (SIG_BLOCK, &set, NULL);\n-\n-  if (pid == -1)\n-    return -1;\n-\n-  if (do_attach (pid) != pid)\n-    return -1;\n-\n-  return pid;\n-}\n-\n-/* Attach to process PID.  */\n-\n-int\n-nto_process_target::attach (unsigned long pid)\n-{\n-  TRACE (\"%s %ld\\n\", __func__, pid);\n-  if (do_attach (pid) != pid)\n-    error (\"Unable to attach to %ld\\n\", pid);\n-  return 0;\n-}\n-\n-/* Send signal to process PID.  */\n-\n-int\n-nto_process_target::kill (process_info *proc)\n-{\n-  int pid = proc->pid;\n-\n-  TRACE (\"%s %d\\n\", __func__, pid);\n-  kill (pid, SIGKILL);\n-  do_detach ();\n-  return 0;\n-}\n-\n-/* Detach from process PID.  */\n-\n-int\n-nto_process_target::detach (process_info *proc)\n-{\n-  TRACE (\"%s %d\\n\", __func__, proc->pid);\n-  do_detach ();\n-  return 0;\n-}\n-\n-void\n-nto_process_target::mourn (struct process_info *process)\n-{\n-  remove_process (process);\n-}\n-\n-void\n-nto_process_target::join (int pid)\n-{\n-  error (_(\"nto target does not implement the join op\"));\n-}\n-\n-/* Check if the given thread is alive.  \n-\n-   Return true if alive, false otherwise.  */\n-\n-bool\n-nto_process_target::thread_alive (ptid_t ptid)\n-{\n-  int res;\n-\n-  TRACE (\"%s pid:%d tid:%d\\n\", __func__, ptid.pid (),\n-\t ptid.lwp ());\n-  if (SignalKill (0, ptid.pid (), ptid.lwp (),\n-\t\t  0, 0, 0) == -1)\n-    res = 0;\n-  else\n-    res = 1;\n-  TRACE (\"%s: %s\\n\", __func__, res ? \"yes\" : \"no\");\n-  return res;\n-}\n-\n-/* Resume inferior's execution.  */\n-\n-void\n-nto_process_target::resume (thread_resume *resume_info, size_t n)\n-{\n-  /* We can only work in all-stop mode.  */\n-  procfs_status status;\n-  procfs_run run;\n-  int err;\n-\n-  TRACE (\"%s\\n\", __func__);\n-  /* Workaround for aliasing rules violation. */\n-  sigset_t *run_fault = (sigset_t *) (void *) &run.fault;\n-\n-  nto_set_thread (resume_info->thread);\n-\n-  run.flags = _DEBUG_RUN_FAULT | _DEBUG_RUN_TRACE;\n-  if (resume_info->kind == resume_step)\n-    run.flags |= _DEBUG_RUN_STEP;\n-  run.flags |= _DEBUG_RUN_ARM;\n-\n-  sigemptyset (run_fault);\n-  sigaddset (run_fault, FLTBPT);\n-  sigaddset (run_fault, FLTTRACE);\n-  sigaddset (run_fault, FLTILL);\n-  sigaddset (run_fault, FLTPRIV);\n-  sigaddset (run_fault, FLTBOUNDS);\n-  sigaddset (run_fault, FLTIOVF);\n-  sigaddset (run_fault, FLTIZDIV);\n-  sigaddset (run_fault, FLTFPE);\n-  sigaddset (run_fault, FLTPAGE);\n-  sigaddset (run_fault, FLTSTACK);\n-  sigaddset (run_fault, FLTACCESS);\n-\n-  sigemptyset (&run.trace);\n-  if (resume_info->sig)\n-    {\n-      int signal_to_pass;\n-\n-      devctl (nto_inferior.ctl_fd, DCMD_PROC_STATUS, &status, sizeof (status),\n-\t      0);\n-      signal_to_pass = resume_info->sig;\n-      if (status.why & (_DEBUG_WHY_SIGNALLED | _DEBUG_WHY_FAULTED))\n-\t{\n-\t  if (signal_to_pass != status.info.si_signo)\n-\t    {\n-\t      kill (status.pid, signal_to_pass);\n-\t      run.flags |= _DEBUG_RUN_CLRFLT | _DEBUG_RUN_CLRSIG;\n-\t    }\n-\t  else\t\t/* Let it kill the program without telling us.  */\n-\t    sigdelset (&run.trace, signal_to_pass);\n-\t}\n-    }\n-  else\n-    run.flags |= _DEBUG_RUN_CLRSIG | _DEBUG_RUN_CLRFLT;\n-\n-  sigfillset (&run.trace);\n-\n-  regcache_invalidate ();\n-\n-  err = devctl (nto_inferior.ctl_fd, DCMD_PROC_RUN, &run, sizeof (run), 0);\n-  if (err != EOK)\n-    TRACE (\"Error: %d \\\"%s\\\"\\n\", err, safe_strerror (err));\n-}\n-\n-/* Wait for inferior's event.  \n-\n-   Return ptid of thread that caused the event.  */\n-\n-ptid_t\n-nto_process_target::wait (ptid_t ptid, target_waitstatus *ourstatus,\n-\t\t\t  int target_options)\n-{\n-  sigset_t set;\n-  siginfo_t info;\n-  procfs_status status;\n-  const int trace_mask = (_DEBUG_FLAG_TRACE_EXEC | _DEBUG_FLAG_TRACE_RD\n-\t\t\t  | _DEBUG_FLAG_TRACE_WR | _DEBUG_FLAG_TRACE_MODIFY);\n-\n-  TRACE (\"%s\\n\", __func__);\n-\n-  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n-\n-  sigemptyset (&set);\n-  sigaddset (&set, SIGUSR1);\n-\n-  devctl (nto_inferior.ctl_fd, DCMD_PROC_STATUS, &status, sizeof (status), 0);\n-  while (!(status.flags & _DEBUG_FLAG_ISTOP))\n-    {\n-      sigwaitinfo (&set, &info);\n-      devctl (nto_inferior.ctl_fd, DCMD_PROC_STATUS, &status, sizeof (status),\n-\t      0);\n-    }\n-  nto_find_new_threads (&nto_inferior);\n-\n-  if (status.flags & _DEBUG_FLAG_SSTEP)\n-    {\n-      TRACE (\"SSTEP\\n\");\n-      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-    }\n-  /* Was it a breakpoint?  */\n-  else if (status.flags & trace_mask)\n-    {\n-      TRACE (\"STOPPED\\n\");\n-      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-    }\n-  else if (status.flags & _DEBUG_FLAG_ISTOP)\n-    {\n-      TRACE (\"ISTOP\\n\");\n-      switch (status.why)\n-\t{\n-\tcase _DEBUG_WHY_SIGNALLED:\n-\t  TRACE (\"  SIGNALLED\\n\");\n-\t  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\t  ourstatus->value.sig =\n-\t    gdb_signal_from_host (status.info.si_signo);\n-\t  nto_inferior.exit_signo = ourstatus->value.sig;\n-\t  break;\n-\tcase _DEBUG_WHY_FAULTED:\n-\t  TRACE (\"  FAULTED\\n\");\n-\t  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\t  if (status.info.si_signo == SIGTRAP)\n-\t    {\n-\t      ourstatus->value.sig = 0;\n-\t      nto_inferior.exit_signo = 0;\n-\t    }\n-\t  else\n-\t    {\n-\t      ourstatus->value.sig =\n-\t\tgdb_signal_from_host (status.info.si_signo);\n-\t      nto_inferior.exit_signo = ourstatus->value.sig;\n-\t    }\n-\t  break;\n-\n-\tcase _DEBUG_WHY_TERMINATED:\n-\t  {\n-\t    int waitval = 0;\n-\n-\t    TRACE (\"  TERMINATED\\n\");\n-\t    waitpid (ptid.pid (), &waitval, WNOHANG);\n-\t    if (nto_inferior.exit_signo)\n-\t      {\n-\t\t/* Abnormal death.  */\n-\t\tourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-\t\tourstatus->value.sig = nto_inferior.exit_signo;\n-\t      }\n-\t    else\n-\t      {\n-\t\t/* Normal death.  */\n-\t\tourstatus->kind = TARGET_WAITKIND_EXITED;\n-\t\tourstatus->value.integer = WEXITSTATUS (waitval);\n-\t      }\n-\t    nto_inferior.exit_signo = 0;\n-\t    break;\n-\t  }\n-\n-\tcase _DEBUG_WHY_REQUESTED:\n-\t  TRACE (\"REQUESTED\\n\");\n-\t  /* We are assuming a requested stop is due to a SIGINT.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\t  ourstatus->value.sig = GDB_SIGNAL_INT;\n-\t  nto_inferior.exit_signo = 0;\n-\t  break;\n-\t}\n-    }\n-\n-  return ptid_t (status.pid, status.tid, 0);\n-}\n-\n-/* Fetch inferior's registers for currently selected thread (CURRENT_INFERIOR).\n-   If REGNO is -1, fetch all registers, or REGNO register only otherwise.  */\n-\n-void\n-nto_process_target::fetch_registers (regcache *regcache, int regno)\n-{\n-  int regsize;\n-  procfs_greg greg;\n-\n-  TRACE (\"%s (regno=%d)\\n\", __func__, regno);\n-  if (regno >= the_low_target.num_regs)\n-    return;\n-\n-  if (current_thread == NULL)\n-    {\n-      TRACE (\"current_thread is NULL\\n\");\n-      return;\n-    }\n-  ptid_t ptid = ptid_of (current_thread);\n-  if (!nto_set_thread (ptid))\n-    return;\n-\n-  if (devctl (nto_inferior.ctl_fd, DCMD_PROC_GETGREG, &greg, sizeof (greg),\n-\t      &regsize) == EOK)\n-    {\n-      if (regno == -1) /* All registers. */\n-\t{\n-\t  for (regno = 0; regno != the_low_target.num_regs; ++regno)\n-\t    {\n-\t      const unsigned int registeroffset\n-\t\t= the_low_target.register_offset (regno);\n-\t      supply_register (regcache, regno,\n-\t\t\t       ((char *)&greg) + registeroffset);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  const unsigned int registeroffset\n-\t    = the_low_target.register_offset (regno);\n-\t  if (registeroffset == -1)\n-\t    return;\n-\t  supply_register (regcache, regno, ((char *)&greg) + registeroffset);\n-\t}\n-    }\n-  else\n-    TRACE (\"ERROR reading registers from inferior.\\n\");\n-}\n-\n-/* Store registers for currently selected thread (CURRENT_INFERIOR).  \n-   We always store all registers, regardless of REGNO.  */\n-\n-void\n-nto_process_target::store_registers (regcache *regcache, int regno)\n-{\n-  procfs_greg greg;\n-  int err;\n-\n-  TRACE (\"%s (regno:%d)\\n\", __func__, regno);\n-\n-  if (current_thread == NULL)\n-    {\n-      TRACE (\"current_thread is NULL\\n\");\n-      return;\n-    }\n-  ptid_t ptid = ptid_of (current_thread);\n-  if (!nto_set_thread (ptid))\n-    return;\n-\n-  memset (&greg, 0, sizeof (greg));\n-  for  (regno = 0; regno != the_low_target.num_regs; ++regno)\n-    {\n-      const unsigned int regoffset\n-\t= the_low_target.register_offset (regno);\n-      collect_register (regcache, regno, ((char *)&greg) + regoffset);\n-    }\n-  err = devctl (nto_inferior.ctl_fd, DCMD_PROC_SETGREG, &greg, sizeof (greg),\n-\t\t0);\n-  if (err != EOK)\n-    TRACE (\"Error: setting registers.\\n\");\n-}\n-\n-/* Read LEN bytes from inferior's memory address MEMADDR into\n-   gdbserver's MYADDR buffer.  \n-\n-   Return 0 on success -1 otherwise.  */\n-\n-int\n-nto_process_target::read_memory (CORE_ADDR memaddr, unsigned char *myaddr,\n-\t\t\t\t int len)\n-{\n-  TRACE (\"%s memaddr:0x%08lx, len:%d\\n\", __func__, memaddr, len);\n-\n-  if (nto_xfer_memory (memaddr, myaddr, len, 0) != len)\n-    {\n-      TRACE (\"Failed to read memory\\n\");\n-      return -1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Write LEN bytes from gdbserver's buffer MYADDR into inferior's\n-   memory at address MEMADDR.  \n-\n-   Return 0 on success -1 otherwise.  */\n-\n-int\n-nto_process_target::write_memory (CORE_ADDR memaddr,\n-\t\t\t\t  const unsigned char *myaddr, int len)\n-{\n-  int len_written;\n-\n-  TRACE (\"%s memaddr: 0x%08llx len: %d\\n\", __func__, memaddr, len);\n-  if ((len_written = nto_xfer_memory (memaddr, (unsigned char *)myaddr, len,\n-\t\t\t\t      1))\n-      != len)\n-    {\n-      TRACE (\"Wanted to write: %d but written: %d\\n\", len, len_written);\n-      return -1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Stop inferior.  We always stop all threads.  */\n-\n-void\n-nto_process_target::request_interrupt ()\n-{\n-  TRACE (\"%s\\n\", __func__);\n-  nto_set_thread (ptid_t (nto_inferior.pid, 1, 0));\n-  if (EOK != devctl (nto_inferior.ctl_fd, DCMD_PROC_STOP, NULL, 0, 0))\n-    TRACE (\"Error stopping inferior.\\n\");\n-}\n-\n-bool\n-nto_process_target::supports_read_auxv ()\n-{\n-  return true;\n-}\n-\n-/* Read auxiliary vector from inferior's memory into gdbserver's buffer\n-   MYADDR.  We always read whole auxv.  \n-   \n-   Return number of bytes stored in MYADDR buffer, 0 if OFFSET > 0\n-   or -1 on error.  */\n-\n-int\n-nto_process_target::read_auxv (CORE_ADDR offset, unsigned char *myaddr,\n-\t\t\t       unsigned int len)\n-{\n-  int err;\n-  CORE_ADDR initial_stack;\n-  procfs_info procinfo;\n-\n-  TRACE (\"%s\\n\", __func__);\n-  if (offset > 0)\n-    return 0;\n-\n-  err = devctl (nto_inferior.ctl_fd, DCMD_PROC_INFO, &procinfo,\n-\t\tsizeof procinfo, 0);\n-  if (err != EOK)\n-    return -1;\n-\n-  initial_stack = procinfo.initial_stack;\n-\n-  return nto_read_auxv_from_initial_stack (initial_stack, myaddr, len);\n-}\n-\n-bool\n-nto_process_target::supports_z_point_type (char z_type)\n-{\n-  switch (z_type)\n-    {\n-    case Z_PACKET_SW_BP:\n-    case Z_PACKET_HW_BP:\n-    case Z_PACKET_WRITE_WP:\n-    case Z_PACKET_READ_WP:\n-    case Z_PACKET_ACCESS_WP:\n-      return true;\n-    default:\n-      return false;\n-    }\n-}\n-\n-/* Insert {break/watch}point at address ADDR.  SIZE is not used.  */\n-\n-int\n-nto_process_target::insert_point (enum raw_bkpt_type type, CORE_ADDR addr,\n-\t\t\t\t  int size, raw_breakpoint *bp)\n-{\n-  int wtype = _DEBUG_BREAK_HW; /* Always request HW.  */\n-\n-  TRACE (\"%s type:%c addr: 0x%08lx len:%d\\n\", __func__, (int)type, addr, size);\n-  switch (type)\n-    {\n-    case raw_bkpt_type_sw:\n-      wtype = _DEBUG_BREAK_EXEC;\n-      break;\n-    case raw_bkpt_type_hw:\n-      wtype |= _DEBUG_BREAK_EXEC;\n-      break;\n-    case raw_bkpt_type_write_wp:\n-      wtype |= _DEBUG_BREAK_RW;\n-      break;\n-    case raw_bkpt_type_read_wp:\n-      wtype |= _DEBUG_BREAK_RD;\n-      break;\n-    case raw_bkpt_type_access_wp:\n-      wtype |= _DEBUG_BREAK_RW;\n-      break;\n-    default:\n-      return 1; /* Not supported.  */\n-    }\n-  return nto_breakpoint (addr, wtype, 0);\n-}\n-\n-/* Remove {break/watch}point at address ADDR.  SIZE is not used.  */\n-\n-int\n-nto_process_target::remove_point (enum raw_bkpt_type type, CORE_ADDR addr,\n-\t\t\t\t  int size, raw_breakpoint *bp)\n-{\n-  int wtype = _DEBUG_BREAK_HW; /* Always request HW.  */\n-\n-  TRACE (\"%s type:%c addr: 0x%08lx len:%d\\n\", __func__, (int)type, addr, size);\n-  switch (type)\n-    {\n-    case raw_bkpt_type_sw:\n-      wtype = _DEBUG_BREAK_EXEC;\n-      break;\n-    case raw_bkpt_type_hw:\n-      wtype |= _DEBUG_BREAK_EXEC;\n-      break;\n-    case raw_bkpt_type_write_wp:\n-      wtype |= _DEBUG_BREAK_RW;\n-      break;\n-    case raw_bkpt_type_read_wp:\n-      wtype |= _DEBUG_BREAK_RD;\n-      break;\n-    case raw_bkpt_type_access_wp:\n-      wtype |= _DEBUG_BREAK_RW;\n-      break;\n-    default:\n-      return 1; /* Not supported.  */\n-    }\n-  return nto_breakpoint (addr, wtype, -1);\n-}\n-\n-bool\n-nto_process_target::supports_hardware_single_step ()\n-{\n-  return true;\n-}\n-\n-/* Check if the reason of stop for current thread (CURRENT_INFERIOR) is\n-   a watchpoint.\n-\n-   Return true if stopped by watchpoint, false otherwise.  */\n-\n-bool\n-nto_process_target::stopped_by_watchpoint ()\n-{\n-  bool ret = false;\n-\n-  TRACE (\"%s\\n\", __func__);\n-  if (nto_inferior.ctl_fd != -1 && current_thread != NULL)\n-    {\n-      ptid_t ptid = ptid_of (current_thread);\n-      if (nto_set_thread (ptid))\n-\t{\n-\t  const int watchmask = _DEBUG_FLAG_TRACE_RD | _DEBUG_FLAG_TRACE_WR\n-\t\t\t\t| _DEBUG_FLAG_TRACE_MODIFY;\n-\t  procfs_status status;\n-\t  int err;\n-\n-\t  err = devctl (nto_inferior.ctl_fd, DCMD_PROC_STATUS, &status,\n-\t\t\tsizeof (status), 0);\n-\t  if (err == EOK && (status.flags & watchmask))\n-\t    ret = true;\n-\t}\n-    }\n-  TRACE (\"%s: %s\\n\", __func__, ret ? \"yes\" : \"no\");\n-  return ret;\n-}\n-\n-/* Get instruction pointer for CURRENT_INFERIOR thread.  \n-\n-   Return inferior's instruction pointer value, or 0 on error.  */ \n-\n-CORE_ADDR\n-nto_process_target::stopped_data_address ()\n-{\n-  CORE_ADDR ret = (CORE_ADDR)0;\n-\n-  TRACE (\"%s\\n\", __func__);\n-  if (nto_inferior.ctl_fd != -1 && current_thread != NULL)\n-    {\n-      ptid_t ptid = ptid_of (current_thread);\n-\n-      if (nto_set_thread (ptid))\n-\t{\n-\t  procfs_status status;\n-\n-\t  if (devctl (nto_inferior.ctl_fd, DCMD_PROC_STATUS, &status,\n-\t\t      sizeof (status), 0) == EOK)\n-\t    ret = status.ip;\n-\t}\n-    }\n-  TRACE (\"%s: 0x%08lx\\n\", __func__, ret);\n-  return ret;\n-}\n-\n-/* Implementation of the target_ops method \"sw_breakpoint_from_kind\".  */\n-\n-const gdb_byte *\n-nto_process_target::sw_breakpoint_from_kind (int kind, int *size)\n-{\n-  *size = the_low_target.breakpoint_len;\n-  return the_low_target.breakpoint;\n-}\n-\n-/* The QNX Neutrino target ops object.  */\n-\n-static nto_process_target the_nto_target;\n-\n-/* Global function called by server.c.  Initializes QNX Neutrino\n-   gdbserver.  */\n-\n-void\n-initialize_low (void)\n-{\n-  sigset_t set;\n-\n-  TRACE (\"%s\\n\", __func__);\n-  set_target_ops (&the_nto_target);\n-\n-  /* We use SIGUSR1 to gain control after we block waiting for a process.\n-     We use sigwaitevent to wait.  */\n-  sigemptyset (&set);\n-  sigaddset (&set, SIGUSR1);\n-  sigprocmask (SIG_BLOCK, &set, NULL);\n-}\n-"
    },
    {
      "sha": "e26dcab331d28e8f77b7e5ca7aad2ddfa1ee2e3d",
      "filename": "gdbserver/nto-low.h",
      "status": "removed",
      "additions": 0,
      "deletions": 109,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/nto-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/nto-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/nto-low.h?ref=fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "patch": "@@ -1,109 +0,0 @@\n-/* Internal interfaces for the QNX Neutrino specific target code for gdbserver.\n-   Copyright (C) 2009-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef GDBSERVER_NTO_LOW_H\n-#define GDBSERVER_NTO_LOW_H\n-\n-struct target_desc;\n-\n-enum regset_type\n-{\n-  NTO_REG_GENERAL,\n-  NTO_REG_FLOAT,\n-  NTO_REG_SYSTEM,\n-  NTO_REG_ALT,\n-  NTO_REG_END\n-};\n-\n-struct nto_target_ops\n-{\n-  /* Architecture specific setup.  */\n-  void (*arch_setup) (void);\n-  int num_regs;\n-  int (*register_offset) (int gdbregno);\n-  const unsigned char *breakpoint;\n-  int breakpoint_len;\n-};\n-\n-extern struct nto_target_ops the_low_target;\n-\n-/* Target ops definitions for a QNX Neutrino target.  */\n-\n-class nto_process_target : public process_stratum_target\n-{\n-public:\n-\n-  int create_inferior (const char *program,\n-\t\t       const std::vector<char *> &program_args) override;\n-\n-  int attach (unsigned long pid) override;\n-\n-  int kill (process_info *proc) override;\n-\n-  int detach (process_info *proc) override;\n-\n-  void mourn (process_info *proc) override;\n-\n-  void join (int pid) override;\n-\n-  bool thread_alive (ptid_t pid) override;\n-\n-  void resume (thread_resume *resume_info, size_t n) override;\n-\n-  ptid_t wait (ptid_t ptid, target_waitstatus *status,\n-\t       int options) override;\n-\n-  void fetch_registers (regcache *regcache, int regno) override;\n-\n-  void store_registers (regcache *regcache, int regno) override;\n-\n-  int read_memory (CORE_ADDR memaddr, unsigned char *myaddr,\n-\t\t   int len) override;\n-\n-  int write_memory (CORE_ADDR memaddr, const unsigned char *myaddr,\n-\t\t    int len) override;\n-\n-  void request_interrupt () override;\n-\n-  bool supports_read_auxv () override;\n-\n-  int read_auxv (CORE_ADDR offset, unsigned char *myaddr,\n-\t\t unsigned int len) override;\n-\n-  bool supports_z_point_type (char z_type) override;\n-\n-  int insert_point (enum raw_bkpt_type type, CORE_ADDR addr,\n-\t\t    int size, raw_breakpoint *bp) override;\n-\n-  int remove_point (enum raw_bkpt_type type, CORE_ADDR addr,\n-\t\t    int size, raw_breakpoint *bp) override;\n-\n-  bool supports_hardware_single_step () override;\n-\n-  bool stopped_by_watchpoint () override;\n-\n-  CORE_ADDR stopped_data_address () override;\n-\n-  const gdb_byte *sw_breakpoint_from_kind (int kind, int *size) override;\n-};\n-\n-/* The inferior's target description.  This is a global because the\n-   LynxOS ports support neither bi-arch nor multi-process.  */\n-extern const struct target_desc *nto_tdesc;\n-\n-#endif /* GDBSERVER_NTO_LOW_H */"
    },
    {
      "sha": "efee95736222baaeee46295e72cc2101585bd578",
      "filename": "gdbserver/nto-x86-low.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 109,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/nto-x86-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fdb95bf546c7ea42fc61bed73bacd04ef237aa1a/gdbserver/nto-x86-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/nto-x86-low.cc?ref=fdb95bf546c7ea42fc61bed73bacd04ef237aa1a",
      "patch": "@@ -1,109 +0,0 @@\n-/* QNX Neutrino specific low level interface, for the remote server\n-   for GDB.\n-   Copyright (C) 2009-2020 Free Software Foundation, Inc.\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"server.h\"\n-#include \"nto-low.h\"\n-#include \"regdef.h\"\n-#include \"regcache.h\"\n-\n-#include <x86/context.h>\n-#include \"gdbsupport/x86-xstate.h\"\n-#include \"arch/i386.h\"\n-#include \"x86-tdesc.h\"\n-\n-const unsigned char x86_breakpoint[] = { 0xCC };\n-#define x86_breakpoint_len 1\n-\n-/* Returns offset in appropriate Neutrino's context structure.\n-   Defined in x86/context.h.\n-   GDBREGNO is index into regs_i386 array.  It is autogenerated and\n-   hopefully doesn't change.  */\n-static int\n-nto_x86_register_offset (int gdbregno)\n-{\n-  if (gdbregno >= 0 && gdbregno < 16)\n-    {\n-      X86_CPU_REGISTERS *dummy = (void*)0;\n-      /* GPRs  */\n-      switch (gdbregno)\n-\t{\n-\tcase 0: \n-\t  return (int)&(dummy->eax);\n-\tcase 1:\n-\t  return (int)&(dummy->ecx);\n-\tcase 2:\n-\t  return (int)&(dummy->edx);\n-\tcase 3:\n-\t  return (int)&(dummy->ebx);\n-\tcase 4:\n-\t  return (int)&(dummy->esp);\n-\tcase 5:\n-\t  return (int)&(dummy->ebp);\n-\tcase 6:\n-\t  return (int)&(dummy->esi);\n-\tcase 7:\n-\t  return (int)&(dummy->edi);\n-\tcase 8:\n-\t  return (int)&(dummy->eip);\n-\tcase 9:\n-\t  return (int)&(dummy->efl);\n-\tcase 10:\n-\t  return (int)&(dummy->cs);\n-\tcase 11:\n-\t  return (int)&(dummy->ss);\n-#ifdef __SEGMENTS__\n-\tcase 12:\n-\t  return (int)&(dummy->ds);\n-\tcase 13:\n-\t  return (int)&(dummy->es);\n-\tcase 14:\n-\t  return (int)&(dummy->fs);\n-\tcase 15:\n-\t  return (int)&(dummy->gs);\n-#endif\n-\tdefault:\n-\t  return -1;\n-\t}\n-    }\n-  return -1;\n-}\n-\n-static void\n-nto_x86_arch_setup (void)\n-{\n-  the_low_target.num_regs = 16;\n-  struct target_desc *tdesc\n-    = i386_create_target_description (X86_XSTATE_SSE_MASK, false, false);\n-\n-  init_target_desc (tdesc, i386_expedite_regs);\n-\n-  nto_tdesc = tdesc;\n-}\n-\n-struct nto_target_ops the_low_target =\n-{\n-  nto_x86_arch_setup,\n-  0, /* num_regs */\n-  nto_x86_register_offset,\n-  x86_breakpoint,\n-  x86_breakpoint_len\n-};\n-\n-\n-"
    },
    {
      "sha": "c26668dc0f8a902241e7b0b2faab6e550ad31326",
      "filename": "gdbserver/remote-utils.cc",
      "status": "modified",
      "additions": 0,
      "deletions": 33,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/remote-utils.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/613f149a90d6fc32a5a6ff47e0325f762cb07424/gdbserver/remote-utils.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.cc?ref=613f149a90d6fc32a5a6ff47e0325f762cb07424",
      "patch": "@@ -68,10 +68,6 @@\n #include <ws2tcpip.h>\n #endif\n \n-#if __QNX__\n-#include <sys/iomgr.h>\n-#endif /* __QNX__ */\n-\n #ifndef HAVE_SOCKLEN_T\n typedef int socklen_t;\n #endif\n@@ -804,28 +800,6 @@ block_unblock_async_io (int block)\n #endif\n }\n \n-#ifdef __QNX__\n-static void\n-nto_comctrl (int enable)\n-{\n-  struct sigevent event;\n-\n-  if (enable)\n-    {\n-      event.sigev_notify = SIGEV_SIGNAL_THREAD;\n-      event.sigev_signo = SIGIO;\n-      event.sigev_code = 0;\n-      event.sigev_value.sival_ptr = NULL;\n-      event.sigev_priority = -1;\n-      ionotify (remote_desc, _NOTIFY_ACTION_POLLARM, _NOTIFY_COND_INPUT,\n-\t\t&event);\n-    }\n-  else\n-    ionotify (remote_desc, _NOTIFY_ACTION_POLL, _NOTIFY_COND_INPUT, NULL);\n-}\n-#endif /* __QNX__ */\n-\n-\n /* Current state of asynchronous I/O.  */\n static int async_io_enabled;\n \n@@ -839,9 +813,6 @@ enable_async_io (void)\n   block_unblock_async_io (0);\n \n   async_io_enabled = 1;\n-#ifdef __QNX__\n-  nto_comctrl (1);\n-#endif /* __QNX__ */\n }\n \n /* Disable asynchronous I/O.  */\n@@ -854,10 +825,6 @@ disable_async_io (void)\n   block_unblock_async_io (1);\n \n   async_io_enabled = 0;\n-#ifdef __QNX__\n-  nto_comctrl (0);\n-#endif /* __QNX__ */\n-\n }\n \n void"
    }
  ]
}