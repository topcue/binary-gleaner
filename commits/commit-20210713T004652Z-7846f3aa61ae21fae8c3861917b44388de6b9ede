{
  "sha": "7846f3aa61ae21fae8c3861917b44388de6b9ede",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Nzg0NmYzYWE2MWFlMjFmYWU4YzM4NjE5MTdiNDQzODhkZTZiOWVkZQ==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-28T02:24:45Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-07-13T00:46:52Z"
    },
    "message": "gdb: add setter / getter for thread_info resumed state\n\nA following patch will want to do things when a thread's resumed state\nchanges.  Make the `resumed` field private (renamed to `m_resumed`) and\nadd a getter and a setter for it.  The following patch in question will\ntherefore be able to add some code to the setter.\n\nChange-Id: I360c48cc55a036503174313261ce4e757d795319",
    "tree": {
      "sha": "9441331c6b9017afa73850662c6407020cefabe5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9441331c6b9017afa73850662c6407020cefabe5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7846f3aa61ae21fae8c3861917b44388de6b9ede",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7846f3aa61ae21fae8c3861917b44388de6b9ede",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7846f3aa61ae21fae8c3861917b44388de6b9ede",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7846f3aa61ae21fae8c3861917b44388de6b9ede/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "8b6a69b2f37fd1370aa823320f9dc3fd482e1e78",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8b6a69b2f37fd1370aa823320f9dc3fd482e1e78",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/8b6a69b2f37fd1370aa823320f9dc3fd482e1e78"
    }
  ],
  "stats": {
    "total": 74,
    "additions": 40,
    "deletions": 34
  },
  "files": [
    {
      "sha": "3288fee354818b22b7ee664c6e2df6ae16e8a399",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=7846f3aa61ae21fae8c3861917b44388de6b9ede",
      "patch": "@@ -407,8 +407,7 @@ breakpoints_should_be_inserted_now (void)\n       /* Don't remove breakpoints yet if, even though all threads are\n \t stopped, we still have events to process.  */\n       for (thread_info *tp : all_non_exited_threads ())\n-\tif (tp->resumed\n-\t    && tp->suspend.waitstatus_pending_p)\n+\tif (tp->resumed () && tp->suspend.waitstatus_pending_p)\n \t  return 1;\n     }\n   return 0;"
    },
    {
      "sha": "babdd0711335e5837fcdc7f3fd8b5207474cc0be",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 15,
      "deletions": 8,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=7846f3aa61ae21fae8c3861917b44388de6b9ede",
      "patch": "@@ -293,14 +293,11 @@ class thread_info : public refcounted_object,\n      thread is off and running.  */\n   bool executing = false;\n \n-  /* True if this thread is resumed from infrun's perspective.\n-     Note that a thread can be marked both as not-executing and\n-     resumed at the same time.  This happens if we try to resume a\n-     thread that has a wait status pending.  We shouldn't let the\n-     thread really run until that wait status has been processed, but\n-     we should not process that wait status if we didn't try to let\n-     the thread run.  */\n-  bool resumed = false;\n+  bool resumed () const\n+  { return m_resumed; }\n+\n+  void set_resumed (bool resumed)\n+  { m_resumed = resumed; }\n \n   /* Frontend view of the thread state.  Note that the THREAD_RUNNING/\n      THREAD_STOPPED states are different from EXECUTING.  When the\n@@ -393,6 +390,16 @@ class thread_info : public refcounted_object,\n \n   /* Displaced-step state for this thread.  */\n   displaced_step_thread_state displaced_step_state;\n+\n+private:\n+  /* True if this thread is resumed from infrun's perspective.\n+     Note that a thread can be marked both as not-executing and\n+     resumed at the same time.  This happens if we try to resume a\n+     thread that has a wait status pending.  We shouldn't let the\n+     thread really run until that wait status has been processed, but\n+     we should not process that wait status if we didn't try to let\n+     the thread run.  */\n+  bool m_resumed = false;\n };\n \n /* A gdb::ref_ptr pointer to a thread_info.  */"
    },
    {
      "sha": "0da3bc27942b7e755017d717d03554652b690026",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=7846f3aa61ae21fae8c3861917b44388de6b9ede",
      "patch": "@@ -1920,15 +1920,15 @@ start_step_over (void)\n \t}\n \n       if (tp->control.trap_expected\n-\t  || tp->resumed\n+\t  || tp->resumed ()\n \t  || tp->executing)\n \t{\n \t  internal_error (__FILE__, __LINE__,\n \t\t\t  \"[%s] has inconsistent state: \"\n \t\t\t  \"trap_expected=%d, resumed=%d, executing=%d\\n\",\n \t\t\t  target_pid_to_str (tp->ptid).c_str (),\n \t\t\t  tp->control.trap_expected,\n-\t\t\t  tp->resumed,\n+\t\t\t  tp->resumed (),\n \t\t\t  tp->executing);\n \t}\n \n@@ -1953,7 +1953,7 @@ start_step_over (void)\n \n       /* If the thread's step over could not be initiated because no buffers\n \t were available, it was re-added to the global step over chain.  */\n-      if (tp->resumed)\n+      if (tp->resumed  ())\n \t{\n \t  infrun_debug_printf (\"[%s] was resumed.\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str ());\n@@ -2219,7 +2219,7 @@ resume_1 (enum gdb_signal sig)\n \t currently_stepping (tp));\n \n       tp->inf->process_target ()->threads_executing = true;\n-      tp->resumed = true;\n+      tp->set_resumed (true);\n \n       /* FIXME: What should we do if we are supposed to resume this\n \t thread with a signal?  Maybe we should maintain a queue of\n@@ -2341,7 +2341,7 @@ resume_1 (enum gdb_signal sig)\n \n \t      resume_ptid = internal_resume_ptid (user_step);\n \t      do_target_resume (resume_ptid, false, GDB_SIGNAL_0);\n-\t      tp->resumed = true;\n+\t      tp->set_resumed (true);\n \t      return;\n \t    }\n \t}\n@@ -2550,7 +2550,7 @@ resume_1 (enum gdb_signal sig)\n     }\n \n   do_target_resume (resume_ptid, step, sig);\n-  tp->resumed = true;\n+  tp->set_resumed (true);\n }\n \n /* Resume the inferior.  SIG is the signal to give the inferior\n@@ -2802,7 +2802,7 @@ maybe_set_commit_resumed_all_targets ()\n \t resuming more threads.  */\n       bool has_thread_with_pending_status = false;\n       for (thread_info *thread : all_non_exited_threads (proc_target))\n-\tif (thread->resumed && thread->suspend.waitstatus_pending_p)\n+\tif (thread->resumed () && thread->suspend.waitstatus_pending_p)\n \t  {\n \t    has_thread_with_pending_status = true;\n \t    break;\n@@ -3237,7 +3237,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t\tcontinue;\n \t      }\n \n-\t    if (tp->resumed)\n+\t    if (tp->resumed ())\n \t      {\n \t\tinfrun_debug_printf (\"[%s] resumed\",\n \t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n@@ -3262,7 +3262,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t      error (_(\"Command aborted.\"));\n \t  }\n       }\n-    else if (!cur_thr->resumed && !thread_is_in_step_over_chain (cur_thr))\n+    else if (!cur_thr->resumed () && !thread_is_in_step_over_chain (cur_thr))\n       {\n \t/* The thread wasn't started, and isn't queued, run it now.  */\n \treset_ecs (ecs, cur_thr);\n@@ -3407,7 +3407,7 @@ infrun_thread_stop_requested (ptid_t ptid)\n       /* Otherwise we can process the (new) pending event now.  Set\n \t it so this pending event is considered by\n \t do_target_wait.  */\n-      tp->resumed = true;\n+      tp->set_resumed (true);\n     }\n }\n \n@@ -3504,7 +3504,7 @@ random_pending_event_thread (inferior *inf, ptid_t waiton_ptid)\n   auto has_event = [&] (thread_info *tp)\n     {\n       return (tp->ptid.matches (waiton_ptid)\n-\t      && tp->resumed\n+\t      && tp->resumed ()\n \t      && tp->suspend.waitstatus_pending_p);\n     };\n \n@@ -3849,7 +3849,7 @@ prepare_for_detach (void)\n \t\t    }\n \t\t}\n \t      else\n-\t\tthr->resumed = false;\n+\t\tthr->set_resumed (false);\n \t    }\n \t}\n \n@@ -4890,7 +4890,7 @@ handle_one (const wait_one_event &event)\n \n       t->stop_requested = 0;\n       t->executing = 0;\n-      t->resumed = false;\n+      t->set_resumed (false);\n       t->control.may_range_step = 0;\n \n       /* This may be the first time we see the inferior report\n@@ -5060,7 +5060,7 @@ stop_all_threads (void)\n \n \t\t  /* The thread may be not executing, but still be\n \t\t     resumed with a pending status to process.  */\n-\t\t  t->resumed = false;\n+\t\t  t->set_resumed (false);\n \t\t}\n \t    }\n \n@@ -5805,7 +5805,7 @@ restart_threads (struct thread_info *event_thread)\n \t  continue;\n \t}\n \n-      if (tp->resumed)\n+      if (tp->resumed ())\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] resumed\",\n \t\t\t      target_pid_to_str (tp->ptid).c_str ());\n@@ -5817,7 +5817,7 @@ restart_threads (struct thread_info *event_thread)\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] needs step-over\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str ());\n-\t  gdb_assert (!tp->resumed);\n+\t  gdb_assert (!tp->resumed ());\n \t  continue;\n \t}\n \n@@ -5826,7 +5826,7 @@ restart_threads (struct thread_info *event_thread)\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] has pending status\",\n \t\t\t       target_pid_to_str (tp->ptid).c_str ());\n-\t  tp->resumed = true;\n+\t  tp->set_resumed (true);\n \t  continue;\n \t}\n \n@@ -5870,7 +5870,7 @@ static int\n resumed_thread_with_pending_status (struct thread_info *tp,\n \t\t\t\t    void *arg)\n {\n-  return (tp->resumed\n+  return (tp->resumed ()\n \t  && tp->suspend.waitstatus_pending_p);\n }\n \n@@ -5956,7 +5956,7 @@ finish_step_over (struct execution_control_state *ecs)\n \t  /* This was cleared early, by handle_inferior_event.  Set it\n \t     so this pending event is considered by\n \t     do_target_wait.  */\n-\t  tp->resumed = true;\n+\t  tp->set_resumed (true);\n \n \t  gdb_assert (!tp->executing);\n \n@@ -7516,7 +7516,7 @@ restart_after_all_stop_detach (process_stratum_target *proc_target)\n \n       /* If we have a pending event to process, skip resuming the\n \t target and go straight to processing it.  */\n-      if (thr->resumed && thr->suspend.waitstatus_pending_p)\n+      if (thr->resumed () && thr->suspend.waitstatus_pending_p)\n \treturn;\n     }\n \n@@ -7621,7 +7621,7 @@ keep_going_stepped_thread (struct thread_info *tp)\n \t\t\t\t     get_frame_address_space (frame),\n \t\t\t\t     tp->suspend.stop_pc);\n \n-      tp->resumed = true;\n+      tp->set_resumed (true);\n       resume_ptid = internal_resume_ptid (tp->control.stepping_command);\n       do_target_resume (resume_ptid, false, GDB_SIGNAL_0);\n     }\n@@ -8036,7 +8036,7 @@ static void\n keep_going_pass_signal (struct execution_control_state *ecs)\n {\n   gdb_assert (ecs->event_thread->ptid == inferior_ptid);\n-  gdb_assert (!ecs->event_thread->resumed);\n+  gdb_assert (!ecs->event_thread->resumed ());\n \n   /* Save the pc before execution, to compare with pc after stop.  */\n   ecs->event_thread->prev_pc"
    },
    {
      "sha": "b908a5bfce5f0e28e1a00618863888bdd388feef",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=7846f3aa61ae21fae8c3861917b44388de6b9ede",
      "patch": "@@ -8132,7 +8132,7 @@ static ptid_t\n first_remote_resumed_thread (remote_target *target)\n {\n   for (thread_info *tp : all_non_exited_threads (target, minus_one_ptid))\n-    if (tp->resumed)\n+    if (tp->resumed ())\n       return tp->ptid;\n   return null_ptid;\n }"
    },
    {
      "sha": "c6c63b742db4821c9b1c03738201aaa4da5a52e5",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7846f3aa61ae21fae8c3861917b44388de6b9ede/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=7846f3aa61ae21fae8c3861917b44388de6b9ede",
      "patch": "@@ -708,7 +708,7 @@ void\n set_resumed (process_stratum_target *targ, ptid_t ptid, bool resumed)\n {\n   for (thread_info *tp : all_non_exited_threads (targ, ptid))\n-    tp->resumed = resumed;\n+    tp->set_resumed (resumed);\n }\n \n /* Helper for set_running, that marks one thread either running or"
    }
  ]
}