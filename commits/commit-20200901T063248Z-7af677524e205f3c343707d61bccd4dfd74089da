{
  "sha": "7af677524e205f3c343707d61bccd4dfd74089da",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2FmNjc3NTI0ZTIwNWYzYzM0MzcwN2Q2MWJjY2Q0ZGZkNzQwODlkYQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-09-01T02:05:37Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-09-01T06:32:48Z"
    },
    "message": "PR26420, PR26421, PR26425, PR26427 UBSAN: tc-arm.c left shifts\n\n\tPR 26420\n\tPR 26421\n\tPR 26425\n\tPR 26427\n\t* config/tc-arm.c (struct arm_it): Make size, size_req, cond and\n\tuncond_value unsigned.\n\t(parse_vfp_reg_list): Make setmask unsigned, vpr_str_len size_t.\n\t(parse_big_immediate): Cast generic_bignum elements to unsigned.\n\t(encode_thumb32_immediate): Shift left 0xffU.\n\t(double_to_single): Make sign unsigned.  Tidy.\n\t(move_or_literal_pool): Cast LITTLE_NUM elements to uint64_t or\n\tvalueT.\n\t(vfp_or_neon_is_neon): Adjust inst.uncond_value expression.\n\t(md_assemble): Likewise.\n\t(handle_pred_state): Make cond unsigned.\n\t(thumb32_negate_data_op): Make variables unsigned.\n\t(md_apply_fix): Make value and newval unsigned, adjust uses.",
    "tree": {
      "sha": "425997c5fd06bf60e615e75aa96dfde87be8e793",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/425997c5fd06bf60e615e75aa96dfde87be8e793"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7af677524e205f3c343707d61bccd4dfd74089da",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7af677524e205f3c343707d61bccd4dfd74089da",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7af677524e205f3c343707d61bccd4dfd74089da",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7af677524e205f3c343707d61bccd4dfd74089da/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f911bb2201c5642151d06622e6ad3d20d5d8cc7b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f911bb2201c5642151d06622e6ad3d20d5d8cc7b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f911bb2201c5642151d06622e6ad3d20d5d8cc7b"
    }
  ],
  "stats": {
    "total": 176,
    "additions": 98,
    "deletions": 78
  },
  "files": [
    {
      "sha": "add6fd89eed5d21a2e442eba16948ce0b326b593",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7af677524e205f3c343707d61bccd4dfd74089da/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7af677524e205f3c343707d61bccd4dfd74089da/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=7af677524e205f3c343707d61bccd4dfd74089da",
      "patch": "@@ -1,3 +1,23 @@\n+2020-09-01  Alan Modra  <amodra@gmail.com>\n+\n+\tPR 26420\n+\tPR 26421\n+\tPR 26425\n+\tPR 26427\n+\t* config/tc-arm.c (struct arm_it): Make size, size_req, cond and\n+\tuncond_value unsigned.\n+\t(parse_vfp_reg_list): Make setmask unsigned, vpr_str_len size_t.\n+\t(parse_big_immediate): Cast generic_bignum elements to unsigned.\n+\t(encode_thumb32_immediate): Shift left 0xffU.\n+\t(double_to_single): Make sign unsigned.  Tidy.\n+\t(move_or_literal_pool): Cast LITTLE_NUM elements to uint64_t or\n+\tvalueT.\n+\t(vfp_or_neon_is_neon): Adjust inst.uncond_value expression.\n+\t(md_assemble): Likewise.\n+\t(handle_pred_state): Make cond unsigned.\n+\t(thumb32_negate_data_op): Make variables unsigned.\n+\t(md_apply_fix): Make value and newval unsigned, adjust uses.\n+\n 2020-08-31  Alan Modra  <amodra@gmail.com>\n \n \tPR 26510"
    },
    {
      "sha": "a645ffec901a19063d5eeb9e98aa5f2947539f64",
      "filename": "gas/config/tc-arm.c",
      "status": "modified",
      "additions": 78,
      "deletions": 78,
      "changes": 156,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7af677524e205f3c343707d61bccd4dfd74089da/gas/config/tc-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7af677524e205f3c343707d61bccd4dfd74089da/gas/config/tc-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-arm.c?ref=7af677524e205f3c343707d61bccd4dfd74089da",
      "patch": "@@ -517,13 +517,13 @@ struct arm_it\n {\n   const char *\terror;\n   unsigned long instruction;\n-  int\t\tsize;\n-  int\t\tsize_req;\n-  int\t\tcond;\n+  unsigned int\tsize;\n+  unsigned int\tsize_req;\n+  unsigned int\tcond;\n   /* \"uncond_value\" is set to the value in place of the conditional field in\n-     unconditional versions of the instruction, or -1 if nothing is\n+     unconditional versions of the instruction, or -1u if nothing is\n      appropriate.  */\n-  int\t\tuncond_value;\n+  unsigned int\tuncond_value;\n   struct neon_type vectype;\n   /* This does not indicate an actual NEON instruction, only that\n      the mnemonic accepts neon-style type suffixes.  */\n@@ -2175,9 +2175,9 @@ parse_vfp_reg_list (char **ccp, unsigned int *pbase, enum reg_list_els etype,\n \n   do\n     {\n-      int setmask = 1, addregs = 1;\n+      unsigned int setmask = 1, addregs = 1;\n       const char vpr_str[] = \"vpr\";\n-      int vpr_str_len = strlen (vpr_str);\n+      size_t vpr_str_len = strlen (vpr_str);\n \n       new_base = arm_typed_reg_parse (&str, regtype, &regtype, NULL);\n \n@@ -5263,12 +5263,12 @@ parse_big_immediate (char **str, int i, expressionS *in_exp,\n \n       inst.operands[i].imm = 0;\n       for (j = 0; j < parts; j++, idx++)\n-\tinst.operands[i].imm |= generic_bignum[idx]\n-\t\t\t\t<< (LITTLENUM_NUMBER_OF_BITS * j);\n+\tinst.operands[i].imm |= ((unsigned) generic_bignum[idx]\n+\t\t\t\t << (LITTLENUM_NUMBER_OF_BITS * j));\n       inst.operands[i].reg = 0;\n       for (j = 0; j < parts; j++, idx++)\n-\tinst.operands[i].reg |= generic_bignum[idx]\n-\t\t\t\t<< (LITTLENUM_NUMBER_OF_BITS * j);\n+\tinst.operands[i].reg |= ((unsigned) generic_bignum[idx]\n+\t\t\t\t << (LITTLENUM_NUMBER_OF_BITS * j));\n       inst.operands[i].regisimm = 1;\n     }\n   else if (!(exp_p->X_op == O_symbol && allow_symbol_p))\n@@ -8289,7 +8289,7 @@ encode_thumb32_immediate (unsigned int val)\n   for (i = 1; i <= 24; i++)\n     {\n       a = val >> i;\n-      if ((val & ~(0xff << i)) == 0)\n+      if ((val & ~(0xffU << i)) == 0)\n \treturn ((val >> i) & 0x7f) | ((32 - i) << 7);\n     }\n \n@@ -8773,9 +8773,9 @@ is_double_a_single (bfd_int64_t v)\n static int\n double_to_single (bfd_int64_t v)\n {\n-  int sign = (int) ((v >> 63) & 1l);\n-  int exp = (int) ((v >> 52) & 0x7FF);\n-  bfd_int64_t mantissa = (v & (bfd_int64_t)0xFFFFFFFFFFFFFULL);\n+  unsigned int sign = (v >> 63) & 1;\n+  int exp = (v >> 52) & 0x7FF;\n+  bfd_int64_t mantissa = (v & (bfd_int64_t) 0xFFFFFFFFFFFFFULL);\n \n   if (exp == 0x7FF)\n     exp = 0xFF;\n@@ -8867,17 +8867,16 @@ move_or_literal_pool (int i, enum lit_type t, bfd_boolean mode_3)\n \t    l = generic_bignum;\n \n #if defined BFD_HOST_64_BIT\n-\t  v =\n-\t    ((((((((bfd_int64_t) l[3] & LITTLENUM_MASK)\n-\t\t  << LITTLENUM_NUMBER_OF_BITS)\n-\t\t | ((bfd_int64_t) l[2] & LITTLENUM_MASK))\n+\t  v = ((((bfd_uint64_t) l[3] & LITTLENUM_MASK)\n \t\t<< LITTLENUM_NUMBER_OF_BITS)\n-\t       | ((bfd_int64_t) l[1] & LITTLENUM_MASK))\n-\t      << LITTLENUM_NUMBER_OF_BITS)\n-\t     | ((bfd_int64_t) l[0] & LITTLENUM_MASK));\n+\t       | (((bfd_int64_t) l[2] & LITTLENUM_MASK)\n+\t\t  << LITTLENUM_NUMBER_OF_BITS)\n+\t       | (((bfd_uint64_t) l[1] & LITTLENUM_MASK)\n+\t\t  << LITTLENUM_NUMBER_OF_BITS)\n+\t       | (l[0] & LITTLENUM_MASK));\n #else\n-\t  v = ((l[1] & LITTLENUM_MASK) << LITTLENUM_NUMBER_OF_BITS)\n-\t    |  (l[0] & LITTLENUM_MASK);\n+\t  v = ((((valueT) l[1] & LITTLENUM_MASK) << LITTLENUM_NUMBER_OF_BITS)\n+\t       | (l[0] & LITTLENUM_MASK));\n #endif\n \t}\n       else\n@@ -16834,7 +16833,7 @@ if (!thumb_mode && (check & NEON_CHECK_CC))\n \tfirst_error (_(BAD_COND));\n \treturn FAIL;\n       }\n-    if (inst.uncond_value != -1)\n+    if (inst.uncond_value != -1u)\n       inst.instruction |= inst.uncond_value << 28;\n   }\n \n@@ -23065,7 +23064,8 @@ handle_pred_state (void)\n \n     case MANUAL_PRED_BLOCK:\n       {\n-\tint cond, is_last;\n+\tunsigned int cond;\n+\tint is_last;\n \tif (now_pred.type == SCALAR_PRED)\n \t  {\n \t    /* Check conditional suffixes.  */\n@@ -23461,7 +23461,7 @@ md_assemble (char *str)\n \n   /* The value which unconditional instructions should have in place of the\n      condition field.  */\n-  inst.uncond_value = (opcode->tag == OT_csuffixF) ? 0xf : -1;\n+  inst.uncond_value = (opcode->tag == OT_csuffixF) ? 0xf : -1u;\n \n   if (thumb_mode)\n     {\n@@ -28178,10 +28178,10 @@ negate_data_op (unsigned long * instruction,\n /* Like negate_data_op, but for Thumb-2.   */\n \n static unsigned int\n-thumb32_negate_data_op (offsetT *instruction, unsigned int value)\n+thumb32_negate_data_op (valueT *instruction, unsigned int value)\n {\n-  int op, new_inst;\n-  int rd;\n+  unsigned int op, new_inst;\n+  unsigned int rd;\n   unsigned int negated, inverted;\n \n   negated = encode_thumb32_immediate (-value);\n@@ -28317,8 +28317,8 @@ md_apply_fix (fixS *\tfixP,\n \t       valueT * valP,\n \t       segT\tseg)\n {\n-  offsetT\t value = * valP;\n-  offsetT\t newval;\n+  valueT\t value = * valP;\n+  valueT\t newval;\n   unsigned int\t newimm;\n   unsigned long\t temp;\n   int\t\t sign;\n@@ -28381,7 +28381,7 @@ md_apply_fix (fixS *\tfixP,\n       temp = md_chars_to_number (buf, INSN_SIZE);\n \n       /* If the offset is negative, we should use encoding A2 for ADR.  */\n-      if ((temp & 0xfff0000) == 0x28f0000 && value < 0)\n+      if ((temp & 0xfff0000) == 0x28f0000 && (offsetT) value < 0)\n \tnewimm = negate_data_op (&temp, value);\n       else\n \t{\n@@ -28399,7 +28399,7 @@ md_apply_fix (fixS *\tfixP,\n \t      && ((temp >> DATA_OP_SHIFT) & 0xf) == OPCODE_MOV\n \t      && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6t2)\n \t      && !((temp >> SBIT_SHIFT) & 0x1)\n-\t      && value >= 0 && value <= 0xffff)\n+\t      && value <= 0xffff)\n \t    {\n \t      /* Clear bits[23:20] to change encoding from A1 to A2.  */\n \t      temp &= 0xff0fffff;\n@@ -28496,9 +28496,9 @@ md_apply_fix (fixS *\tfixP,\n       /* Fall through.  */\n \n     case BFD_RELOC_ARM_LITERAL:\n-      sign = value > 0;\n+      sign = (offsetT) value > 0;\n \n-      if (value < 0)\n+      if ((offsetT) value < 0)\n \tvalue = - value;\n \n       if (validate_offset_imm (value, 0) == FAIL)\n@@ -28526,9 +28526,9 @@ md_apply_fix (fixS *\tfixP,\n \n     case BFD_RELOC_ARM_OFFSET_IMM8:\n     case BFD_RELOC_ARM_HWLITERAL:\n-      sign = value > 0;\n+      sign = (offsetT) value > 0;\n \n-      if (value < 0)\n+      if ((offsetT) value < 0)\n \tvalue = - value;\n \n       if (validate_offset_imm (value, 1) == FAIL)\n@@ -28555,7 +28555,7 @@ md_apply_fix (fixS *\tfixP,\n       break;\n \n     case BFD_RELOC_ARM_T32_OFFSET_U8:\n-      if (value < 0 || value > 1020 || value % 4 != 0)\n+      if (value > 1020 || value % 4 != 0)\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"bad immediate value for offset (%ld)\"), (long) value);\n       value /= 4;\n@@ -28591,7 +28591,7 @@ md_apply_fix (fixS *\tfixP,\n       if ((newval & 0xf0000000) == 0xe0000000)\n \t{\n \t  /* Doubleword load/store: 8-bit offset, scaled by 4.  */\n-\t  if (value >= 0)\n+\t  if ((offsetT) value >= 0)\n \t    newval |= (1 << 23);\n \t  else\n \t    value = -value;\n@@ -28613,7 +28613,7 @@ md_apply_fix (fixS *\tfixP,\n       else if ((newval & 0x000f0000) == 0x000f0000)\n \t{\n \t  /* PC-relative, 12-bit offset.  */\n-\t  if (value >= 0)\n+\t  if ((offsetT) value >= 0)\n \t    newval |= (1 << 23);\n \t  else\n \t    value = -value;\n@@ -28628,7 +28628,7 @@ md_apply_fix (fixS *\tfixP,\n       else if ((newval & 0x00000100) == 0x00000100)\n \t{\n \t  /* Writeback: 8-bit, +/- offset.  */\n-\t  if (value >= 0)\n+\t  if ((offsetT) value >= 0)\n \t    newval |= (1 << 9);\n \t  else\n \t    value = -value;\n@@ -28643,7 +28643,7 @@ md_apply_fix (fixS *\tfixP,\n       else if ((newval & 0x00000f00) == 0x00000e00)\n \t{\n \t  /* T-instruction: positive 8-bit offset.  */\n-\t  if (value < 0 || value > 0xff)\n+\t  if (value > 0xff)\n \t    {\n \t      as_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t\t    _(\"offset out of range\"));\n@@ -28655,8 +28655,8 @@ md_apply_fix (fixS *\tfixP,\n       else\n \t{\n \t  /* Positive 12-bit or negative 8-bit offset.  */\n-\t  int limit;\n-\t  if (value >= 0)\n+\t  unsigned int limit;\n+\t  if ((offsetT) value >= 0)\n \t    {\n \t      newval |= (1 << 23);\n \t      limit = 0xfff;\n@@ -28682,7 +28682,7 @@ md_apply_fix (fixS *\tfixP,\n \n     case BFD_RELOC_ARM_SHIFT_IMM:\n       newval = md_chars_to_number (buf, INSN_SIZE);\n-      if (((unsigned long) value) > 32\n+      if (value > 32\n \t  || (value == 32\n \t      && (((newval & 0x60) == 0) || (newval & 0x60) == 0x60)))\n \t{\n@@ -28745,7 +28745,7 @@ md_apply_fix (fixS *\tfixP,\n \t      if ((newval & 0x00100000) == 0)\n \t\t{\n \t\t  /* 12 bit immediate for addw/subw.  */\n-\t\t  if (value < 0)\n+\t\t  if ((offsetT) value < 0)\n \t\t    {\n \t\t      value = -value;\n \t\t      newval ^= 0x00a00000;\n@@ -28768,7 +28768,7 @@ md_apply_fix (fixS *\tfixP,\n \t\t  && (((newval >> 16) & 0xf) == 0xf)\n \t\t  && ARM_CPU_HAS_FEATURE (cpu_variant, arm_ext_v6t2_v8m)\n \t\t  && !((newval >> T2_SBIT_SHIFT) & 0x1)\n-\t\t  && value >= 0 && value <= 0xffff)\n+\t\t  && value <= 0xffff)\n \t\t{\n \t\t  /* Toggle bit[25] to change encoding from T2 to T3.  */\n \t\t  newval ^= 1 << 25;\n@@ -28799,7 +28799,7 @@ md_apply_fix (fixS *\tfixP,\n       break;\n \n     case BFD_RELOC_ARM_SMC:\n-      if (((unsigned long) value) > 0xf)\n+      if (value > 0xf)\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"invalid smc expression\"));\n \n@@ -28809,7 +28809,7 @@ md_apply_fix (fixS *\tfixP,\n       break;\n \n     case BFD_RELOC_ARM_HVC:\n-      if (((unsigned long) value) > 0xffff)\n+      if (value > 0xffff)\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"invalid hvc expression\"));\n       newval = md_chars_to_number (buf, INSN_SIZE);\n@@ -28820,7 +28820,7 @@ md_apply_fix (fixS *\tfixP,\n     case BFD_RELOC_ARM_SWI:\n       if (fixP->tc_fix_data != 0)\n \t{\n-\t  if (((unsigned long) value) > 0xff)\n+\t  if (value > 0xff)\n \t    as_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t\t  _(\"invalid swi expression\"));\n \t  newval = md_chars_to_number (buf, THUMB_SIZE);\n@@ -28829,7 +28829,7 @@ md_apply_fix (fixS *\tfixP,\n \t}\n       else\n \t{\n-\t  if (((unsigned long) value) > 0x00ffffff)\n+\t  if (value > 0x00ffffff)\n \t    as_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t\t  _(\"invalid swi expression\"));\n \t  newval = md_chars_to_number (buf, INSN_SIZE);\n@@ -28839,7 +28839,7 @@ md_apply_fix (fixS *\tfixP,\n       break;\n \n     case BFD_RELOC_ARM_MULTI:\n-      if (((unsigned long) value) > 0xffff)\n+      if (value > 0xffff)\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"invalid expression in load/store multiple\"));\n       newval = value | md_chars_to_number (buf, INSN_SIZE);\n@@ -28923,8 +28923,8 @@ md_apply_fix (fixS *\tfixP,\n       if (value & temp)\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"misaligned branch destination\"));\n-      if ((value & (offsetT)0xfe000000) != (offsetT)0\n-\t  && (value & (offsetT)0xfe000000) != (offsetT)0xfe000000)\n+      if ((value & 0xfe000000) != 0\n+\t  && (value & 0xfe000000) != 0xfe000000)\n \tas_bad_where (fixP->fx_file, fixP->fx_line, BAD_RANGE);\n \n       if (fixP->fx_done || !seg->use_rela_p)\n@@ -28952,7 +28952,7 @@ md_apply_fix (fixS *\tfixP,\n \n \t FIXME: It may be better to remove the instruction completely and\n \t perform relaxation.  */\n-      if (value == -2)\n+      if ((offsetT) value == -2)\n \t{\n \t  newval = md_chars_to_number (buf, THUMB_SIZE);\n \t  newval = 0xbf00; /* NOP encoding T1 */\n@@ -29225,24 +29225,24 @@ md_apply_fix (fixS *\tfixP,\n       if ((newval & 0x0f200f00) == 0x0d000900)\n \t{\n \t  /* This is a fp16 vstr/vldr.  The immediate offset in the mnemonic\n-\t     has permitted values that are multiples of 2, in the range 0\n+\t     has permitted values that are multiples of 2, in the range -510\n \t     to 510.  */\n-\t  if (value < -510 || value > 510 || (value & 1))\n+\t  if (value + 510 > 510 + 510 || (value & 1))\n \t    as_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t\t  _(\"co-processor offset out of range\"));\n \t}\n       else if ((newval & 0xfe001f80) == 0xec000f80)\n \t{\n-\t  if (value < -511 || value > 512 || (value & 3))\n+\t  if (value + 511 > 512 + 511 || (value & 3))\n \t    as_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t\t  _(\"co-processor offset out of range\"));\n \t}\n-      else if (value < -1023 || value > 1023 || (value & 3))\n+      else if (value + 1023 > 1023 + 1023 || (value & 3))\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"co-processor offset out of range\"));\n     cp_off_common:\n-      sign = value > 0;\n-      if (value < 0)\n+      sign = (offsetT) value > 0;\n+      if ((offsetT) value < 0)\n \tvalue = -value;\n       if (fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM\n \t  || fixP->fx_r_type == BFD_RELOC_ARM_CP_OFF_IMM_S2)\n@@ -29284,7 +29284,7 @@ md_apply_fix (fixS *\tfixP,\n \n     case BFD_RELOC_ARM_CP_OFF_IMM_S2:\n     case BFD_RELOC_ARM_T32_CP_OFF_IMM_S2:\n-      if (value < -255 || value > 255)\n+      if (value + 255 > 255 + 255)\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"co-processor offset out of range\"));\n       value *= 4;\n@@ -29390,11 +29390,11 @@ md_apply_fix (fixS *\tfixP,\n \t\t\t_(\"invalid Hi register with immediate\"));\n \n \t/* If value is negative, choose the opposite instruction.  */\n-\tif (value < 0)\n+\tif ((offsetT) value < 0)\n \t  {\n \t    value = -value;\n \t    subtract = !subtract;\n-\t    if (value < 0)\n+\t    if ((offsetT) value < 0)\n \t      as_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t\t    _(\"immediate value out of range\"));\n \t  }\n@@ -29478,7 +29478,7 @@ md_apply_fix (fixS *\tfixP,\n \n     case BFD_RELOC_ARM_THUMB_IMM:\n       newval = md_chars_to_number (buf, THUMB_SIZE);\n-      if (value < 0 || value > 255)\n+      if (value > 255)\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"invalid immediate: %ld is out of range\"),\n \t\t      (long) value);\n@@ -29490,7 +29490,7 @@ md_apply_fix (fixS *\tfixP,\n       /* 5bit shift value (0..32).  LSL cannot take 32.\t */\n       newval = md_chars_to_number (buf, THUMB_SIZE) & 0xf83f;\n       temp = newval & 0xf800;\n-      if (value < 0 || value > 32 || (value == 32 && temp == T_OPCODE_LSL_I))\n+      if (value > 32 || (value == 32 && temp == T_OPCODE_LSL_I))\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"invalid shift value: %ld\"), (long) value);\n       /* Shifts of zero must be encoded as LSL.\t */\n@@ -29517,7 +29517,7 @@ md_apply_fix (fixS *\tfixP,\n \t  /* REL format relocations are limited to a 16-bit addend.  */\n \t  if (!fixP->fx_done)\n \t    {\n-\t      if (value < -0x8000 || value > 0x7fff)\n+\t      if (value + 0x8000 > 0x7fff + 0x8000)\n \t\t  as_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t\t\t_(\"offset out of range\"));\n \t    }\n@@ -29560,7 +29560,7 @@ md_apply_fix (fixS *\tfixP,\n \tbfd_vma encoded_addend = value;\n \n \t/* Check that addend can be encoded in instruction.  */\n-\tif (!seg->use_rela_p && (value < 0 || value > 255))\n+\tif (!seg->use_rela_p && value > 255)\n \t  as_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t\t_(\"the offset 0x%08lX is not representable\"),\n \t\t\t(unsigned long) encoded_addend);\n@@ -29626,7 +29626,7 @@ md_apply_fix (fixS *\tfixP,\n        {\n \t bfd_vma insn;\n \t bfd_vma encoded_addend;\n-\t bfd_vma addend_abs = llabs (value);\n+\t bfd_vma addend_abs = llabs ((offsetT) value);\n \n \t /* Check that the absolute value of the addend can be\n \t    expressed as an 8-bit constant plus a rotation.  */\n@@ -29642,7 +29642,7 @@ md_apply_fix (fixS *\tfixP,\n \t /* If the addend is positive, use an ADD instruction.\n \t    Otherwise use a SUB.  Take care not to destroy the S bit.  */\n \t insn &= 0xff1fffff;\n-\t if (value < 0)\n+\t if ((offsetT) value < 0)\n \t   insn |= 1 << 22;\n \t else\n \t   insn |= 1 << 23;\n@@ -29667,7 +29667,7 @@ md_apply_fix (fixS *\tfixP,\n       if (!seg->use_rela_p)\n \t{\n \t  bfd_vma insn;\n-\t  bfd_vma addend_abs = llabs (value);\n+\t  bfd_vma addend_abs = llabs ((offsetT) value);\n \n \t  /* Check that the absolute value of the addend can be\n \t     encoded in 12 bits.  */\n@@ -29681,7 +29681,7 @@ md_apply_fix (fixS *\tfixP,\n \n \t  /* If the addend is negative, clear bit 23 of the instruction.\n \t     Otherwise set it.  */\n-\t  if (value < 0)\n+\t  if ((offsetT) value < 0)\n \t    insn &= ~(1 << 23);\n \t  else\n \t    insn |= 1 << 23;\n@@ -29706,7 +29706,7 @@ md_apply_fix (fixS *\tfixP,\n       if (!seg->use_rela_p)\n \t{\n \t  bfd_vma insn;\n-\t  bfd_vma addend_abs = llabs (value);\n+\t  bfd_vma addend_abs = llabs ((offsetT) value);\n \n \t  /* Check that the absolute value of the addend can be\n \t     encoded in 8 bits.  */\n@@ -29720,7 +29720,7 @@ md_apply_fix (fixS *\tfixP,\n \n \t  /* If the addend is negative, clear bit 23 of the instruction.\n \t     Otherwise set it.  */\n-\t  if (value < 0)\n+\t  if ((offsetT) value < 0)\n \t    insn &= ~(1 << 23);\n \t  else\n \t    insn |= 1 << 23;\n@@ -29746,7 +29746,7 @@ md_apply_fix (fixS *\tfixP,\n       if (!seg->use_rela_p)\n \t{\n \t  bfd_vma insn;\n-\t  bfd_vma addend_abs = llabs (value);\n+\t  bfd_vma addend_abs = llabs ((offsetT) value);\n \n \t  /* Check that the absolute value of the addend is a multiple of\n \t     four and, when divided by four, fits in 8 bits.  */\n@@ -29765,7 +29765,7 @@ md_apply_fix (fixS *\tfixP,\n \n \t  /* If the addend is negative, clear bit 23 of the instruction.\n \t     Otherwise set it.  */\n-\t  if (value < 0)\n+\t  if ((offsetT) value < 0)\n \t    insn &= ~(1 << 23);\n \t  else\n \t    insn |= 1 << 23;\n@@ -29813,7 +29813,7 @@ md_apply_fix (fixS *\tfixP,\n \t{\n \t  fixP->fx_done = 0;\n \t}\n-      if ((value & ~0x7f) && ((value & ~0x3f) != ~0x3f))\n+      if ((value & ~0x7f) && ((value & ~0x3f) != (valueT) ~0x3f))\n \tas_bad_where (fixP->fx_file, fixP->fx_line,\n \t\t      _(\"branch out of range\"));\n "
    }
  ]
}