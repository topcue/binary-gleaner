{
  "sha": "43816ebc335481c99808c4fdfffb9ea3f510b19a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDM4MTZlYmMzMzU0ODFjOTk4MDhjNGZkZmZmYjllYTNmNTEwYjE5YQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-10-31T16:31:28Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-01-08T18:17:18Z"
    },
    "message": "Remove some explicit memory management from dwarf2read.c\n\nI noticed a few spots in dwarf2read.c that could be improved by moving\nto unique_xmalloc_ptr or, in one case, std::vector.\n\ngdb/ChangeLog\n2020-01-08  Tom Tromey  <tromey@adacore.com>\n\n\t* dwarf2read.c (add_partial_symbol): Use unique_xmalloc_ptr.\n\t(dwarf2_compute_name, open_dwo_file): Likewise.\n\t(process_enumeration_scope): Use std::vector.\n\t(guess_partial_die_structure_name): Use unique_xmalloc_ptr.\n\t(partial_die_info::fixup, dwarf2_start_subfile)\n\t(guess_full_die_structure_name, dwarf2_name): Likewise.\n\t(determine_prefix): Update.\n\t(guess_full_die_structure_name): Make return type const.\n\t(partial_die_full_name): Return unique_xmalloc_ptr.\n\t(DW_FIELD_ALLOC_CHUNK): Remove.\n\nChange-Id: I1cb278c608041ef36ef1f77c7e7565c921038d08",
    "tree": {
      "sha": "8e5885cd646c1453ff6390e227b3640081cad869",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8e5885cd646c1453ff6390e227b3640081cad869"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/43816ebc335481c99808c4fdfffb9ea3f510b19a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/43816ebc335481c99808c4fdfffb9ea3f510b19a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/43816ebc335481c99808c4fdfffb9ea3f510b19a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/43816ebc335481c99808c4fdfffb9ea3f510b19a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "915808f652b63746052b1ef59403650b45a30e4f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/915808f652b63746052b1ef59403650b45a30e4f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/915808f652b63746052b1ef59403650b45a30e4f"
    }
  ],
  "stats": {
    "total": 156,
    "additions": 68,
    "deletions": 88
  },
  "files": [
    {
      "sha": "ab9aa9fbd69d9cd35857dba945d5bb689937058b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/43816ebc335481c99808c4fdfffb9ea3f510b19a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/43816ebc335481c99808c4fdfffb9ea3f510b19a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=43816ebc335481c99808c4fdfffb9ea3f510b19a",
      "patch": "@@ -1,3 +1,16 @@\n+2020-01-08  Tom Tromey  <tromey@adacore.com>\n+\n+\t* dwarf2read.c (add_partial_symbol): Use unique_xmalloc_ptr.\n+\t(dwarf2_compute_name, open_dwo_file): Likewise.\n+\t(process_enumeration_scope): Use std::vector.\n+\t(guess_partial_die_structure_name): Use unique_xmalloc_ptr.\n+\t(partial_die_info::fixup, dwarf2_start_subfile)\n+\t(guess_full_die_structure_name, dwarf2_name): Likewise.\n+\t(determine_prefix): Update.\n+\t(guess_full_die_structure_name): Make return type const.\n+\t(partial_die_full_name): Return unique_xmalloc_ptr.\n+\t(DW_FIELD_ALLOC_CHUNK): Remove.\n+\n 2020-01-07  Tom Tromey  <tromey@adacore.com>\n \n \tPR build/24937:"
    },
    {
      "sha": "03c27982b184f49fc1f94c623751209a9e0262c8",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 55,
      "deletions": 88,
      "changes": 143,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/43816ebc335481c99808c4fdfffb9ea3f510b19a/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/43816ebc335481c99808c4fdfffb9ea3f510b19a/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=43816ebc335481c99808c4fdfffb9ea3f510b19a",
      "patch": "@@ -1343,11 +1343,6 @@ struct dwarf_block\n #define ATTR_ALLOC_CHUNK 4\n #endif\n \n-/* Allocate fields for structs, unions and enums in this size.  */\n-#ifndef DW_FIELD_ALLOC_CHUNK\n-#define DW_FIELD_ALLOC_CHUNK 4\n-#endif\n-\n /* FIXME: We might want to set this from BFD via bfd_arch_bits_per_byte,\n    but this would require a corresponding change in unpack_field_as_long\n    and friends.  */\n@@ -8907,7 +8902,7 @@ partial_die_parent_scope (struct partial_die_info *pdi,\n /* Return the fully scoped name associated with PDI, from compilation unit\n    CU.  The result will be allocated with malloc.  */\n \n-static char *\n+static gdb::unique_xmalloc_ptr<char>\n partial_die_full_name (struct partial_die_info *pdi,\n \t\t       struct dwarf2_cu *cu)\n {\n@@ -8933,15 +8928,16 @@ partial_die_full_name (struct partial_die_info *pdi,\n \t  attr.u.unsnd = to_underlying (pdi->sect_off);\n \t  die = follow_die_ref (NULL, &attr, &ref_cu);\n \n-\t  return xstrdup (dwarf2_full_name (NULL, die, ref_cu));\n+\t  return make_unique_xstrdup (dwarf2_full_name (NULL, die, ref_cu));\n \t}\n     }\n \n   parent_scope = partial_die_parent_scope (pdi, cu);\n   if (parent_scope == NULL)\n     return NULL;\n   else\n-    return typename_concat (NULL, parent_scope, pdi->name, 0, cu);\n+    return gdb::unique_xmalloc_ptr<char> (typename_concat (NULL, parent_scope,\n+\t\t\t\t\t\t\t   pdi->name, 0, cu));\n }\n \n static void\n@@ -8954,13 +8950,13 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n   CORE_ADDR addr = 0;\n   const char *actual_name = NULL;\n   CORE_ADDR baseaddr;\n-  char *built_actual_name;\n \n   baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n \n-  built_actual_name = partial_die_full_name (pdi, cu);\n+  gdb::unique_xmalloc_ptr<char> built_actual_name\n+    = partial_die_full_name (pdi, cu);\n   if (built_actual_name != NULL)\n-    actual_name = built_actual_name;\n+    actual_name = built_actual_name.get ();\n \n   if (actual_name == NULL)\n     actual_name = pdi->name;\n@@ -9053,10 +9049,7 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n \t  /* Static Variable.  Skip symbols whose value we cannot know (those\n \t     without location descriptors or constant values).  */\n \t  if (!has_loc && !pdi->has_const_value)\n-\t    {\n-\t      xfree (built_actual_name);\n-\t      return;\n-\t    }\n+\t    return;\n \n \t  add_psymbol_to_list (actual_name,\n \t\t\t       built_actual_name != NULL,\n@@ -9106,10 +9099,7 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n          union or class entry that does not have a byte size attribute\n          and that has a DW_AT_declaration attribute.\"  */\n       if (!pdi->has_byte_size && pdi->is_declaration)\n-\t{\n-\t  xfree (built_actual_name);\n-\t  return;\n-\t}\n+\treturn;\n \n       /* NOTE: carlton/2003-10-07: See comment in new_symbol about\n \t static vs. global.  */\n@@ -9134,8 +9124,6 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n     default:\n       break;\n     }\n-\n-  xfree (built_actual_name);\n }\n \n /* Read a partial die corresponding to a namespace; also, add a symbol\n@@ -10912,11 +10900,10 @@ dwarf2_compute_name (const char *name,\n \t  prefix = determine_prefix (die, cu);\n \t  if (*prefix != '\\0')\n \t    {\n-\t      char *prefixed_name = typename_concat (NULL, prefix, name,\n-\t\t\t\t\t\t     physname, cu);\n+\t      gdb::unique_xmalloc_ptr<char> prefixed_name\n+\t\t(typename_concat (NULL, prefix, name, physname, cu));\n \n-\t      buf.puts (prefixed_name);\n-\t      xfree (prefixed_name);\n+\t      buf.puts (prefixed_name.get ());\n \t    }\n \t  else\n \t    buf.puts (name);\n@@ -12958,16 +12945,15 @@ open_dwo_file (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   if (comp_dir != NULL)\n     {\n-      char *path_to_try = concat (comp_dir, SLASH_STRING,\n-\t\t\t\t  file_name, (char *) NULL);\n+      gdb::unique_xmalloc_ptr<char> path_to_try\n+\t(concat (comp_dir, SLASH_STRING, file_name, (char *) NULL));\n \n       /* NOTE: If comp_dir is a relative path, this will also try the\n \t search path, which seems useful.  */\n       gdb_bfd_ref_ptr abfd (try_open_dwop_file (dwarf2_per_objfile,\n-\t\t\t\t\t\tpath_to_try,\n+\t\t\t\t\t\tpath_to_try.get (),\n \t\t\t\t\t\t0 /*is_dwp*/,\n \t\t\t\t\t\t1 /*search_cwd*/));\n-      xfree (path_to_try);\n       if (abfd != NULL)\n \treturn abfd;\n     }\n@@ -16548,8 +16534,7 @@ process_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)\n     {\n       struct die_info *child_die;\n       struct symbol *sym;\n-      struct field *fields = NULL;\n-      int num_fields = 0;\n+      std::vector<struct field> fields;\n       const char *name;\n \n       child_die = die->child;\n@@ -16566,34 +16551,26 @@ process_enumeration_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t{\n \t\t  sym = new_symbol (child_die, this_type, cu);\n \n-\t\t  if ((num_fields % DW_FIELD_ALLOC_CHUNK) == 0)\n-\t\t    {\n-\t\t      fields = (struct field *)\n-\t\t\txrealloc (fields,\n-\t\t\t\t  (num_fields + DW_FIELD_ALLOC_CHUNK)\n-\t\t\t\t  * sizeof (struct field));\n-\t\t    }\n-\n-\t\t  FIELD_NAME (fields[num_fields]) = sym->linkage_name ();\n-\t\t  FIELD_TYPE (fields[num_fields]) = NULL;\n-\t\t  SET_FIELD_ENUMVAL (fields[num_fields], SYMBOL_VALUE (sym));\n-\t\t  FIELD_BITSIZE (fields[num_fields]) = 0;\n+\t\t  fields.emplace_back ();\n+\t\t  struct field &field = fields.back ();\n \n-\t\t  num_fields++;\n+\t\t  FIELD_NAME (field) = sym->linkage_name ();\n+\t\t  FIELD_TYPE (field) = NULL;\n+\t\t  SET_FIELD_ENUMVAL (field, SYMBOL_VALUE (sym));\n+\t\t  FIELD_BITSIZE (field) = 0;\n \t\t}\n \t    }\n \n \t  child_die = sibling_die (child_die);\n \t}\n \n-      if (num_fields)\n+      if (!fields.empty ())\n \t{\n-\t  TYPE_NFIELDS (this_type) = num_fields;\n+\t  TYPE_NFIELDS (this_type) = fields.size ();\n \t  TYPE_FIELDS (this_type) = (struct field *)\n-\t    TYPE_ALLOC (this_type, sizeof (struct field) * num_fields);\n-\t  memcpy (TYPE_FIELDS (this_type), fields,\n-\t\t  sizeof (struct field) * num_fields);\n-\t  xfree (fields);\n+\t    TYPE_ALLOC (this_type, sizeof (struct field) * fields.size ());\n+\t  memcpy (TYPE_FIELDS (this_type), fields.data (),\n+\t\t  sizeof (struct field) * fields.size ());\n \t}\n     }\n \n@@ -19345,16 +19322,15 @@ guess_partial_die_structure_name (struct partial_die_info *struct_pdi,\n       if (child_pdi->tag == DW_TAG_subprogram\n \t  && child_pdi->linkage_name != NULL)\n \t{\n-\t  char *actual_class_name\n-\t    = language_class_name_from_physname (cu->language_defn,\n-\t\t\t\t\t\t child_pdi->linkage_name);\n+\t  gdb::unique_xmalloc_ptr<char> actual_class_name\n+\t    (language_class_name_from_physname (cu->language_defn,\n+\t\t\t\t\t\tchild_pdi->linkage_name));\n \t  if (actual_class_name != NULL)\n \t    {\n \t      struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n \t      struct_pdi->name\n \t\t= obstack_strdup (&objfile->per_bfd->storage_obstack,\n-\t\t\t\t  actual_class_name);\n-\t      xfree (actual_class_name);\n+\t\t\t\t  actual_class_name.get ());\n \t    }\n \t  break;\n \t}\n@@ -19419,24 +19395,22 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n \t  || tag == DW_TAG_union_type)\n       && linkage_name != NULL)\n     {\n-      char *demangled;\n-\n-      demangled = gdb_demangle (linkage_name, DMGL_TYPES);\n-      if (demangled)\n+      gdb::unique_xmalloc_ptr<char> demangled\n+\t(gdb_demangle (linkage_name, DMGL_TYPES));\n+      if (demangled != nullptr)\n \t{\n \t  const char *base;\n \n \t  /* Strip any leading namespaces/classes, keep only the base name.\n \t     DW_AT_name for named DIEs does not contain the prefixes.  */\n-\t  base = strrchr (demangled, ':');\n-\t  if (base && base > demangled && base[-1] == ':')\n+\t  base = strrchr (demangled.get (), ':');\n+\t  if (base && base > demangled.get () && base[-1] == ':')\n \t    base++;\n \t  else\n-\t    base = demangled;\n+\t    base = demangled.get ();\n \n \t  struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n \t  name = obstack_strdup (&objfile->per_bfd->storage_obstack, base);\n-\t  xfree (demangled);\n \t}\n     }\n \n@@ -21716,7 +21690,7 @@ static void\n dwarf2_start_subfile (struct dwarf2_cu *cu, const char *filename,\n \t\t      const char *dirname)\n {\n-  char *copy = NULL;\n+  gdb::unique_xmalloc_ptr<char> copy;\n \n   /* In order not to lose the line information directory,\n      we concatenate it to the filename when it makes sense.\n@@ -21727,14 +21701,11 @@ dwarf2_start_subfile (struct dwarf2_cu *cu, const char *filename,\n \n   if (!IS_ABSOLUTE_PATH (filename) && dirname != NULL)\n     {\n-      copy = concat (dirname, SLASH_STRING, filename, (char *)NULL);\n-      filename = copy;\n+      copy.reset (concat (dirname, SLASH_STRING, filename, (char *) NULL));\n+      filename = copy.get ();\n     }\n \n   cu->get_builder ()->start_subfile (filename);\n-\n-  if (copy != NULL)\n-    xfree (copy);\n }\n \n /* Start a symtab for DWARF.  NAME, COMP_DIR, LOW_PC are passed to the\n@@ -22702,7 +22673,7 @@ read_type_die_1 (struct die_info *die, struct dwarf2_cu *cu)\n    This is the full-die version of guess_partial_die_structure_name.\n    In this case we know DIE has no useful parent.  */\n \n-static char *\n+static const char *\n guess_full_die_structure_name (struct die_info *die, struct dwarf2_cu *cu)\n {\n   struct die_info *spec_die;\n@@ -22728,33 +22699,32 @@ guess_full_die_structure_name (struct die_info *die, struct dwarf2_cu *cu)\n \n \t  if (linkage_name != NULL)\n \t    {\n-\t      char *actual_name\n-\t\t= language_class_name_from_physname (cu->language_defn,\n-\t\t\t\t\t\t     linkage_name);\n-\t      char *name = NULL;\n+\t      gdb::unique_xmalloc_ptr<char> actual_name\n+\t\t(language_class_name_from_physname (cu->language_defn,\n+\t\t\t\t\t\t    linkage_name));\n+\t      const char *name = NULL;\n \n \t      if (actual_name != NULL)\n \t\t{\n \t\t  const char *die_name = dwarf2_name (die, cu);\n \n \t\t  if (die_name != NULL\n-\t\t      && strcmp (die_name, actual_name) != 0)\n+\t\t      && strcmp (die_name, actual_name.get ()) != 0)\n \t\t    {\n \t\t      /* Strip off the class name from the full name.\n \t\t\t We want the prefix.  */\n \t\t      int die_name_len = strlen (die_name);\n-\t\t      int actual_name_len = strlen (actual_name);\n+\t\t      int actual_name_len = strlen (actual_name.get ());\n+\t\t      const char *ptr = actual_name.get ();\n \n \t\t      /* Test for '::' as a sanity check.  */\n \t\t      if (actual_name_len > die_name_len + 2\n-\t\t\t  && actual_name[actual_name_len\n-\t\t\t\t\t - die_name_len - 1] == ':')\n+\t\t\t  && ptr[actual_name_len - die_name_len - 1] == ':')\n \t\t\tname = obstack_strndup (\n \t\t\t  &objfile->per_bfd->storage_obstack,\n-\t\t\t  actual_name, actual_name_len - die_name_len - 2);\n+\t\t\t  ptr, actual_name_len - die_name_len - 2);\n \t\t    }\n \t\t}\n-\t      xfree (actual_name);\n \t      return name;\n \t    }\n \t}\n@@ -22941,7 +22911,7 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n \t\t|| die->tag == DW_TAG_structure_type\n \t\t|| die->tag == DW_TAG_union_type))\n \t  {\n-\t    char *name = guess_full_die_structure_name (die, cu);\n+\t    const char *name = guess_full_die_structure_name (die, cu);\n \t    if (name != NULL)\n \t      return name;\n \t  }\n@@ -23115,27 +23085,24 @@ dwarf2_name (struct die_info *die, struct dwarf2_cu *cu)\n \t http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */\n       if (!attr || DW_STRING (attr) == NULL)\n \t{\n-\t  char *demangled = NULL;\n-\n \t  attr = dw2_linkage_name_attr (die, cu);\n \t  if (attr == NULL || DW_STRING (attr) == NULL)\n \t    return NULL;\n \n \t  /* Avoid demangling DW_STRING (attr) the second time on a second\n \t     call for the same DIE.  */\n \t  if (!DW_STRING_IS_CANONICAL (attr))\n-\t    demangled = gdb_demangle (DW_STRING (attr), DMGL_TYPES);\n-\n-\t  if (demangled)\n \t    {\n+\t      gdb::unique_xmalloc_ptr<char> demangled\n+\t\t(gdb_demangle (DW_STRING (attr), DMGL_TYPES));\n+\n \t      const char *base;\n \n \t      /* FIXME: we already did this for the partial symbol... */\n \t      DW_STRING (attr)\n \t\t= obstack_strdup (&objfile->per_bfd->storage_obstack,\n-\t\t\t\t  demangled);\n+\t\t\t\t  demangled.get ());\n \t      DW_STRING_IS_CANONICAL (attr) = 1;\n-\t      xfree (demangled);\n \n \t      /* Strip any leading namespaces/classes, keep only the base name.\n \t\t DW_AT_name for named DIEs does not contain the prefixes.  */"
    }
  ]
}