{
  "sha": "5f56f7cbd22219e84df3caece06f469c5063e5fb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWY1NmY3Y2JkMjIyMTllODRkZjNjYWVjZTA2ZjQ2OWM1MDYzZTVmYg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-03-13T23:39:52Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-03-14T00:03:40Z"
    },
    "message": "Convert Rust printing to value-based API\n\nFor Rust, it was simple to convert the printing code to the\nvalue-based API all at once.\n\ngdb/ChangeLog\n2020-03-13  Tom Tromey  <tom@tromey.com>\n\n\t* rust-lang.c (val_print_struct, rust_print_enum): Use the value\n\tAPI.\n\t(rust_val_print): Rewrite.\n\t(rust_value_print_inner): New function, from rust_val_print.\n\t(rust_language_defn): Use rust_value_print_inner.",
    "tree": {
      "sha": "b9fc706b33e8600301d2bbb53eb2fae7fc600b51",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b9fc706b33e8600301d2bbb53eb2fae7fc600b51"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5f56f7cbd22219e84df3caece06f469c5063e5fb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f56f7cbd22219e84df3caece06f469c5063e5fb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5f56f7cbd22219e84df3caece06f469c5063e5fb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f56f7cbd22219e84df3caece06f469c5063e5fb/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "26792ee0345c09bd1c76f3ee0e16ed15ab7215b9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/26792ee0345c09bd1c76f3ee0e16ed15ab7215b9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/26792ee0345c09bd1c76f3ee0e16ed15ab7215b9"
    }
  ],
  "stats": {
    "total": 128,
    "additions": 70,
    "deletions": 58
  },
  "files": [
    {
      "sha": "79ed024125521386d0c85ee1ed2524c272d57cfe",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f56f7cbd22219e84df3caece06f469c5063e5fb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f56f7cbd22219e84df3caece06f469c5063e5fb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5f56f7cbd22219e84df3caece06f469c5063e5fb",
      "patch": "@@ -1,3 +1,11 @@\n+2020-03-13  Tom Tromey  <tom@tromey.com>\n+\n+\t* rust-lang.c (val_print_struct, rust_print_enum): Use the value\n+\tAPI.\n+\t(rust_val_print): Rewrite.\n+\t(rust_value_print_inner): New function, from rust_val_print.\n+\t(rust_language_defn): Use rust_value_print_inner.\n+\n 2020-03-13  Tom Tromey  <tom@tromey.com>\n \n \t* ada-valprint.c (ada_value_print_inner): New function."
    },
    {
      "sha": "2afdeb3aca3f53600c13c618871844a44bb2cd57",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 62,
      "deletions": 58,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5f56f7cbd22219e84df3caece06f469c5063e5fb/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5f56f7cbd22219e84df3caece06f469c5063e5fb/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=5f56f7cbd22219e84df3caece06f469c5063e5fb",
      "patch": "@@ -351,6 +351,10 @@ rust_printstr (struct ui_file *stream, struct type *type,\n \n \f\n \n+static void rust_value_print_inner (struct value *val, struct ui_file *stream,\n+\t\t\t\t    int recurse,\n+\t\t\t\t    const struct value_print_options *options);\n+\n /* Helper function to print a string slice.  */\n \n static void\n@@ -369,13 +373,12 @@ rust_val_print_str (struct ui_file *stream, struct value *val,\n /* rust_val_print helper for structs and untagged unions.  */\n \n static void\n-val_print_struct (struct type *type, int embedded_offset,\n-\t\t  CORE_ADDR address, struct ui_file *stream,\n-\t\t  int recurse, struct value *val,\n+val_print_struct (struct value *val, struct ui_file *stream, int recurse,\n \t\t  const struct value_print_options *options)\n {\n   int i;\n   int first_field;\n+  struct type *type = check_typedef (value_type (val));\n \n   if (rust_slice_type_p (type) && strcmp (TYPE_NAME (type), \"&str\") == 0)\n     {\n@@ -386,7 +389,7 @@ val_print_struct (struct type *type, int embedded_offset,\n \t However, RUST_VAL_PRINT_STR looks up the fields of the string\n \t inside VAL, assuming that VAL is the string.\n \t So, recreate VAL as a value representing just the string.  */\n-      val = value_at_lazy (type, value_address (val) + embedded_offset);\n+      val = value_at_lazy (type, value_address (val));\n       rust_val_print_str (stream, val, options);\n       return;\n     }\n@@ -441,11 +444,8 @@ val_print_struct (struct type *type, int embedded_offset,\n \t  fputs_filtered (\": \", stream);\n         }\n \n-      val_print (TYPE_FIELD_TYPE (type, i),\n-\t\t embedded_offset + TYPE_FIELD_BITPOS (type, i) / 8,\n-\t\t address,\n-\t\t stream, recurse + 1, val, &opts,\n-\t\t current_language);\n+      rust_value_print_inner (value_field (val, i), stream, recurse + 1,\n+\t\t\t      &opts);\n     }\n \n   if (options->prettyformat)\n@@ -463,12 +463,11 @@ val_print_struct (struct type *type, int embedded_offset,\n /* rust_val_print helper for discriminated unions (Rust enums).  */\n \n static void\n-rust_print_enum (struct type *type, int embedded_offset,\n-\t\t CORE_ADDR address, struct ui_file *stream,\n-\t\t int recurse, struct value *val,\n+rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n \t\t const struct value_print_options *options)\n {\n   struct value_print_options opts = *options;\n+  struct type *type = check_typedef (value_type (val));\n \n   opts.deref_ref = 0;\n \n@@ -482,9 +481,7 @@ rust_print_enum (struct type *type, int embedded_offset,\n     }\n \n   const gdb_byte *valaddr = value_contents_for_printing (val);\n-  struct field *variant_field = rust_enum_variant (type,\n-\t\t\t\t\t\t   valaddr + embedded_offset);\n-  embedded_offset += FIELD_BITPOS (*variant_field) / 8;\n+  struct field *variant_field = rust_enum_variant (type, valaddr);\n   struct type *variant_type = FIELD_TYPE (*variant_field);\n \n   int nfields = TYPE_NFIELDS (variant_type);\n@@ -508,6 +505,10 @@ rust_print_enum (struct type *type, int embedded_offset,\n       fprintf_filtered (stream, \"{\");\n     }\n \n+  struct value *union_value = value_field (val, 0);\n+  int fieldno = (variant_field - &TYPE_FIELD (value_type (union_value), 0));\n+  val = value_field (union_value, fieldno);\n+\n   bool first_field = true;\n   for (int j = 0; j < TYPE_NFIELDS (variant_type); j++)\n     {\n@@ -520,12 +521,8 @@ rust_print_enum (struct type *type, int embedded_offset,\n \t\t\t  styled_string (variable_name_style.style (),\n \t\t\t\t\t TYPE_FIELD_NAME (variant_type, j)));\n \n-      val_print (TYPE_FIELD_TYPE (variant_type, j),\n-\t\t (embedded_offset\n-\t\t  + TYPE_FIELD_BITPOS (variant_type, j) / 8),\n-\t\t address,\n-\t\t stream, recurse + 1, val, &opts,\n-\t\t current_language);\n+      rust_value_print_inner (value_field (val, j), stream, recurse + 1,\n+\t\t\t      &opts);\n     }\n \n   if (is_tuple)\n@@ -556,9 +553,24 @@ rust_val_print (struct type *type, int embedded_offset,\n \t\tstruct value *val,\n \t\tconst struct value_print_options *options)\n {\n-  const gdb_byte *valaddr = value_contents_for_printing (val);\n+  generic_val_print (type, embedded_offset, address, stream,\n+\t\t     recurse, val, options, &rust_decorations);\n+}\n \n-  type = check_typedef (type);\n+/* la_value_print_inner implementation for Rust.  */\n+static void\n+rust_value_print_inner (struct value *val, struct ui_file *stream,\n+\t\t\tint recurse,\n+\t\t\tconst struct value_print_options *options)\n+{\n+  struct value_print_options opts = *options;\n+  opts.deref_ref = 1;\n+\n+  if (opts.prettyformat == Val_prettyformat_default)\n+    opts.prettyformat = (opts.prettyformat_structs\n+\t\t\t ? Val_prettyformat : Val_no_prettyformat);\n+\n+  struct type *type = check_typedef (value_type (val));\n   switch (TYPE_CODE (type))\n     {\n     case TYPE_CODE_PTR:\n@@ -568,34 +580,32 @@ rust_val_print (struct type *type, int embedded_offset,\n \tif (TYPE_CODE (TYPE_TARGET_TYPE (type)) == TYPE_CODE_ARRAY\n \t    && rust_u8_type_p (TYPE_TARGET_TYPE (TYPE_TARGET_TYPE (type)))\n \t    && get_array_bounds (TYPE_TARGET_TYPE (type), &low_bound,\n-\t\t\t\t &high_bound)) {\n-\t  /* We have a pointer to a byte string, so just print\n-\t     that.  */\n-\t  struct type *elttype = check_typedef (TYPE_TARGET_TYPE (type));\n-\t  CORE_ADDR addr;\n-\t  struct gdbarch *arch = get_type_arch (type);\n-\t  int unit_size = gdbarch_addressable_memory_unit_size (arch);\n+\t\t\t\t &high_bound))\n+\t  {\n+\t    /* We have a pointer to a byte string, so just print\n+\t       that.  */\n+\t    struct type *elttype = check_typedef (TYPE_TARGET_TYPE (type));\n+\t    CORE_ADDR addr = value_as_address (val);\n+\t    struct gdbarch *arch = get_type_arch (type);\n \n-\t  addr = unpack_pointer (type, valaddr + embedded_offset * unit_size);\n-\t  if (options->addressprint)\n-\t    {\n-\t      fputs_filtered (paddress (arch, addr), stream);\n-\t      fputs_filtered (\" \", stream);\n-\t    }\n+\t    if (opts.addressprint)\n+\t      {\n+\t\tfputs_filtered (paddress (arch, addr), stream);\n+\t\tfputs_filtered (\" \", stream);\n+\t      }\n \n-\t  fputs_filtered (\"b\", stream);\n-\t  val_print_string (TYPE_TARGET_TYPE (elttype), \"ASCII\", addr,\n-\t\t\t    high_bound - low_bound + 1, stream,\n-\t\t\t    options);\n-\t  break;\n-\t}\n+\t    fputs_filtered (\"b\", stream);\n+\t    val_print_string (TYPE_TARGET_TYPE (elttype), \"ASCII\", addr,\n+\t\t\t      high_bound - low_bound + 1, stream,\n+\t\t\t      &opts);\n+\t    break;\n+\t  }\n       }\n-      /* Fall through.  */\n+      goto generic_print;\n \n     case TYPE_CODE_METHODPTR:\n     case TYPE_CODE_MEMBERPTR:\n-      c_val_print (type, embedded_offset, address, stream,\n-\t\t   recurse, val, options);\n+      c_value_print_inner (val, stream, recurse, &opts);\n       break;\n \n     case TYPE_CODE_INT:\n@@ -610,8 +620,6 @@ rust_val_print (struct type *type, int embedded_offset,\n \n     case TYPE_CODE_STRING:\n       {\n-\tstruct gdbarch *arch = get_type_arch (type);\n-\tint unit_size = gdbarch_addressable_memory_unit_size (arch);\n \tLONGEST low_bound, high_bound;\n \n \tif (!get_array_bounds (type, &low_bound, &high_bound))\n@@ -622,8 +630,8 @@ rust_val_print (struct type *type, int embedded_offset,\n \t   encoding.  */\n \tfputs_filtered (\"b\", stream);\n \trust_printstr (stream, TYPE_TARGET_TYPE (type),\n-\t\t       valaddr + embedded_offset * unit_size,\n-\t\t       high_bound - low_bound + 1, \"ASCII\", 0, options);\n+\t\t       value_contents_for_printing (val),\n+\t\t       high_bound - low_bound + 1, \"ASCII\", 0, &opts);\n       }\n       break;\n \n@@ -645,24 +653,20 @@ rust_val_print (struct type *type, int embedded_offset,\n \t for printing a union is same as that for a struct, the only\n \t difference is that the input type will have overlapping\n \t fields.  */\n-      val_print_struct (type, embedded_offset, address, stream,\n-\t\t\trecurse, val, options);\n+      val_print_struct (val, stream, recurse, &opts);\n       break;\n \n     case TYPE_CODE_STRUCT:\n       if (rust_enum_p (type))\n-\trust_print_enum (type, embedded_offset, address, stream,\n-\t\t\t recurse, val, options);\n+\trust_print_enum (val, stream, recurse, &opts);\n       else\n-\tval_print_struct (type, embedded_offset, address, stream,\n-\t\t\t  recurse, val, options);\n+\tval_print_struct (val, stream, recurse, &opts);\n       break;\n \n     default:\n     generic_print:\n       /* Nothing special yet.  */\n-      generic_val_print (type, embedded_offset, address, stream,\n-\t\t\t recurse, val, options, &rust_decorations);\n+      generic_value_print (val, stream, recurse, &opts, &rust_decorations);\n     }\n }\n \n@@ -2154,7 +2158,7 @@ extern const struct language_defn rust_language_defn =\n   rust_print_type,\t\t/* Print a type using appropriate syntax */\n   rust_print_typedef,\t\t/* Print a typedef using appropriate syntax */\n   rust_val_print,\t\t/* Print a value using appropriate syntax */\n-  nullptr,\t\t\t/* la_value_print_inner */\n+  rust_value_print_inner,\t/* la_value_print_inner */\n   c_value_print,\t\t/* Print a top-level value */\n   default_read_var_value,\t/* la_read_var_value */\n   NULL,\t\t\t\t/* Language specific skip_trampoline */"
    }
  ]
}