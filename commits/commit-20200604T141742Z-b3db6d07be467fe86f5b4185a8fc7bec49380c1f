{
  "sha": "b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjNkYjZkMDdiZTQ2N2ZlODZmNWI0MTg1YThmYzdiZWM0OTM4MGMxZg==",
  "commit": {
    "author": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-06-04T14:14:41Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-06-04T14:17:42Z"
    },
    "message": "opcodes: support insn endianness in cgen_cpu_open\n\nThis patch adds support for a new CGEN_OPEN_INSN_ENDIAN argument\nfor @arch@_cgen_cpu_open.  This is useful for architectures in\nwhich the endianness of the instruction words is not the same\nthan the endianness used for data.\n\nAn accompanying patch has been sent to the CGEN mailing list that\nadds support for this argument on the CGEN side [1].  Its been\nalready pre-approved [2], and will be applied simultaneously with\nthis binutils series.\n\n[1] https://sourceware.org/pipermail/cgen/2020q2/002733.html\n[2] https://sourceware.org/pipermail/cgen/2020q2/002737.html\n\ninclude/ChangeLog:\n\n2020-06-04  Jose E. Marchesi  <jemarch@gnu.org>\n\n\t* opcode/cgen.h (enum cgen_cpu_open_arg): New value\n\tCGEN_CPU_OPEN_INSN_ENDIAN.\n\nopcodes/ChangeLog:\n\n2020-06-04  Jose E. Marchesi  <jemarch@gnu.org>\n\n\t* cgen-dis.in (cpu_desc_list): New field `insn_endian'.\n\t(print_insn_): Handle instruction endian.\n\t* bpf-dis.c: Regenerate.\n\t* bpf-desc.c: Regenerate.\n\t* epiphany-dis.c: Likewise.\n\t* epiphany-desc.c: Likewise.\n\t* fr30-dis.c: Likewise.\n\t* fr30-desc.c: Likewise.\n\t* frv-dis.c: Likewise.\n\t* frv-desc.c: Likewise.\n\t* ip2k-dis.c: Likewise.\n\t* ip2k-desc.c: Likewise.\n\t* iq2000-dis.c: Likewise.\n\t* iq2000-desc.c: Likewise.\n\t* lm32-dis.c: Likewise.\n\t* lm32-desc.c: Likewise.\n\t* m32c-dis.c: Likewise.\n\t* m32c-desc.c: Likewise.\n\t* m32r-dis.c: Likewise.\n\t* m32r-desc.c: Likewise.\n\t* mep-dis.c: Likewise.\n\t* mep-desc.c: Likewise.\n\t* mt-dis.c: Likewise.\n\t* mt-desc.c: Likewise.\n\t* or1k-dis.c: Likewise.\n\t* or1k-desc.c: Likewise.\n\t* xc16x-dis.c: Likewise.\n\t* xc16x-desc.c: Likewise.\n\t* xstormy16-dis.c: Likewise.\n\t* xstormy16-desc.c: Likewise.\n\nbinutils/ChangeLog:\n\n2020-06-04  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\n\t* objdump.c (disassemble_data): Set disasm_info.endian_code to\n        disasm_info.endian after the latter is initialized to the\n        endianness reported by BFD.",
    "tree": {
      "sha": "8486190d571c898ad12e24350e5e06a59a5bfac0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8486190d571c898ad12e24350e5e06a59a5bfac0"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/comments",
  "author": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0cfcd4f003ce0ed5467fd0ceeff4a191439c5923",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0cfcd4f003ce0ed5467fd0ceeff4a191439c5923",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0cfcd4f003ce0ed5467fd0ceeff4a191439c5923"
    }
  ],
  "stats": {
    "total": 328,
    "additions": 257,
    "deletions": 71
  },
  "files": [
    {
      "sha": "10806a9353009d40bac7f4ac8dda0dab849d94fe",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1,3 +1,9 @@\n+2020-06-04  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\n+\t* objdump.c (disassemble_data): Set disasm_info.endian_code to\n+\tdisasm_info.endian after the latter is initialized to the\n+\tendianness reported by BFD.\n+\n 2020-06-04  Alan Modra  <amodra@gmail.com>\n \n \t* testsuite/binutils-all/i386/i386.exp: Remove global directive"
    },
    {
      "sha": "9b3d5b7acb8defde4b252b1517a5f82f0918d2be",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -3479,6 +3479,8 @@ disassemble_data (bfd *abfd)\n        instead.  */\n     disasm_info.endian = BFD_ENDIAN_UNKNOWN;\n \n+  disasm_info.endian_code = disasm_info.endian;\n+\n   /* Allow the target to customize the info structure.  */\n   disassemble_init_for_target (& disasm_info);\n "
    },
    {
      "sha": "df4208eda10cb660aabb849327000bcb5b98b921",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1,3 +1,8 @@\n+2020-06-04  Jose E. Marchesi  <jemarch@gnu.org>\n+\n+\t* opcode/cgen.h (enum cgen_cpu_open_arg): New value\n+\tCGEN_CPU_OPEN_INSN_ENDIAN.\n+\n 2020-06-03  Nelson Chu  <nelson.chu@sifive.com>\n \n \t* opcode/riscv.h: Remove #include \"bfd.h\".  And change the return"
    },
    {
      "sha": "3f325447b9ecd4389f21e697727c3364580cb5bb",
      "filename": "include/opcode/cgen.h",
      "status": "modified",
      "additions": 8,
      "deletions": 1,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/include/opcode/cgen.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/include/opcode/cgen.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/opcode/cgen.h?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1392,7 +1392,9 @@ enum cgen_cpu_open_arg {\n      Multiple machines can be specified by repeated use.  */\n   CGEN_CPU_OPEN_BFDMACH,\n   /* Select endian, arg is CGEN_ENDIAN_*.  */\n-  CGEN_CPU_OPEN_ENDIAN\n+  CGEN_CPU_OPEN_ENDIAN,\n+  /* Select instruction endian, arg is CGEN_ENDIAN_*.  */\n+  CGEN_CPU_OPEN_INSN_ENDIAN,\n };\n \n /* Open a cpu descriptor table for use.\n@@ -1465,6 +1467,11 @@ extern CGEN_INSN_INT cgen_get_insn_value\n extern void cgen_put_insn_value\n   (CGEN_CPU_DESC, unsigned char *, int, CGEN_INSN_INT);\n \n+extern CGEN_INSN_INT cgen_get_base_insn_value\n+  (CGEN_CPU_DESC, unsigned char *, int);\n+extern void cgen_put_base_insn_value\n+  (CGEN_CPU_DESC, unsigned char *, int, CGEN_INSN_INT);\n+\n /* Read in a cpu description file.\n    ??? For future concerns, including adding instructions to the assembler/\n    disassembler at run-time.  */"
    },
    {
      "sha": "dc4c285eb06907daf4e15e18c46e0e0c465bace0",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 33,
      "deletions": 0,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1,3 +1,36 @@\n+2020-06-04  Jose E. Marchesi  <jemarch@gnu.org>\n+\n+\t* cgen-dis.in (cpu_desc_list): New field `insn_endian'.\n+\t(print_insn_): Handle instruction endian.\n+\t* bpf-dis.c: Regenerate.\n+\t* bpf-desc.c: Regenerate.\n+\t* epiphany-dis.c: Likewise.\n+\t* epiphany-desc.c: Likewise.\n+\t* fr30-dis.c: Likewise.\n+\t* fr30-desc.c: Likewise.\n+\t* frv-dis.c: Likewise.\n+\t* frv-desc.c: Likewise.\n+\t* ip2k-dis.c: Likewise.\n+\t* ip2k-desc.c: Likewise.\n+\t* iq2000-dis.c: Likewise.\n+\t* iq2000-desc.c: Likewise.\n+\t* lm32-dis.c: Likewise.\n+\t* lm32-desc.c: Likewise.\n+\t* m32c-dis.c: Likewise.\n+\t* m32c-desc.c: Likewise.\n+\t* m32r-dis.c: Likewise.\n+\t* m32r-desc.c: Likewise.\n+\t* mep-dis.c: Likewise.\n+\t* mep-desc.c: Likewise.\n+\t* mt-dis.c: Likewise.\n+\t* mt-desc.c: Likewise.\n+\t* or1k-dis.c: Likewise.\n+\t* or1k-desc.c: Likewise.\n+\t* xc16x-dis.c: Likewise.\n+\t* xc16x-desc.c: Likewise.\n+\t* xstormy16-dis.c: Likewise.\n+\t* xstormy16-desc.c: Likewise.\n+\n 2020-06-03  Nick Clifton  <nickc@redhat.com>\n \n \t* po/sr.po: Updated Serbian translation."
    },
    {
      "sha": "abd8c41006f20ccfde3c6984bc92bd81aa87020a",
      "filename": "opcodes/bpf-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/bpf-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/bpf-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1701,6 +1701,7 @@ bpf_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -1714,6 +1715,7 @@ bpf_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -1748,6 +1750,9 @@ bpf_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -1777,11 +1782,8 @@ bpf_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = bpf_cgen_rebuild_tables;"
    },
    {
      "sha": "21d9308be038a1b7f293564484b9f35a10308edf",
      "filename": "opcodes/bpf-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/bpf-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/bpf-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/bpf-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -507,6 +507,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -519,12 +520,16 @@ print_insn_bpf (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -590,9 +595,11 @@ print_insn_bpf (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = bpf_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "378b984551dbd72929280e73c1f8eef22df4f2fb",
      "filename": "opcodes/cgen-dis.in",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/cgen-dis.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/cgen-dis.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/cgen-dis.in?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -341,6 +341,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -353,12 +354,16 @@ print_insn_@arch@ (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -424,9 +429,11 @@ print_insn_@arch@ (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = @arch@_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "fbd1f8b9f6a89849324e53efd91ea0a9eb8246a9",
      "filename": "opcodes/epiphany-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/epiphany-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/epiphany-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/epiphany-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -2139,6 +2139,7 @@ epiphany_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -2152,6 +2153,7 @@ epiphany_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -2186,6 +2188,9 @@ epiphany_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -2215,11 +2220,8 @@ epiphany_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = epiphany_cgen_rebuild_tables;"
    },
    {
      "sha": "966b39fe099ef19a4f1d7156facc5eb87737f41d",
      "filename": "opcodes/epiphany-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/epiphany-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/epiphany-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/epiphany-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -582,6 +582,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -594,12 +595,16 @@ print_insn_epiphany (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -665,9 +670,11 @@ print_insn_epiphany (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = epiphany_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "836b1b9e4be1bcfa4d40982eb8ce5a39e295277e",
      "filename": "opcodes/fr30-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/fr30-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/fr30-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/fr30-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1616,6 +1616,7 @@ fr30_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -1629,6 +1630,7 @@ fr30_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -1663,6 +1665,9 @@ fr30_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -1692,11 +1697,8 @@ fr30_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = fr30_cgen_rebuild_tables;"
    },
    {
      "sha": "b98ea94a1a6e1f87f8079ca73b72fa4d5710a78d",
      "filename": "opcodes/fr30-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/fr30-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/fr30-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/fr30-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -603,6 +603,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -615,12 +616,16 @@ print_insn_fr30 (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -686,9 +691,11 @@ print_insn_fr30 (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = fr30_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "5c90bb429744ca347b05024da9af11c0fd2142e4",
      "filename": "opcodes/frv-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/frv-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/frv-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/frv-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -6356,6 +6356,7 @@ frv_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -6369,6 +6370,7 @@ frv_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -6403,6 +6405,9 @@ frv_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -6432,11 +6437,8 @@ frv_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = frv_cgen_rebuild_tables;"
    },
    {
      "sha": "60f1a6141ed7cadf5576cbe22789be7e312fad42",
      "filename": "opcodes/frv-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/frv-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/frv-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/frv-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -700,6 +700,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -712,12 +713,16 @@ print_insn_frv (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -783,9 +788,11 @@ print_insn_frv (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = frv_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "9e6b4e27ab296da728f17c84efb817293b3ae292",
      "filename": "opcodes/ip2k-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/ip2k-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/ip2k-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ip2k-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1045,6 +1045,7 @@ ip2k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -1058,6 +1059,7 @@ ip2k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -1092,6 +1094,9 @@ ip2k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -1121,11 +1126,8 @@ ip2k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = ip2k_cgen_rebuild_tables;"
    },
    {
      "sha": "4a53a7c24631e1314d2025cbc33d3464a092145f",
      "filename": "opcodes/ip2k-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/ip2k-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/ip2k-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ip2k-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -592,6 +592,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -604,12 +605,16 @@ print_insn_ip2k (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -675,9 +680,11 @@ print_insn_ip2k (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = ip2k_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "db5ce60f58a693eabc44952876a9b58ca2267555",
      "filename": "opcodes/iq2000-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/iq2000-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/iq2000-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/iq2000-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -2050,6 +2050,7 @@ iq2000_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -2063,6 +2064,7 @@ iq2000_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -2097,6 +2099,9 @@ iq2000_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -2126,11 +2131,8 @@ iq2000_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = iq2000_cgen_rebuild_tables;"
    },
    {
      "sha": "3aab139c51f01913382550859b2a29682532d7ae",
      "filename": "opcodes/iq2000-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/iq2000-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/iq2000-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/iq2000-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -493,6 +493,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -505,12 +506,16 @@ print_insn_iq2000 (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -576,9 +581,11 @@ print_insn_iq2000 (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = iq2000_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "0270333a73d31fc6227fb8952df56c16b17cb56f",
      "filename": "opcodes/lm32-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/lm32-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/lm32-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/lm32-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1032,6 +1032,7 @@ lm32_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -1045,6 +1046,7 @@ lm32_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -1079,6 +1081,9 @@ lm32_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -1108,11 +1113,8 @@ lm32_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = lm32_cgen_rebuild_tables;"
    },
    {
      "sha": "7ba84b3a66e5fabea54cf412ca113508b50e1f41",
      "filename": "opcodes/lm32-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/lm32-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/lm32-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/lm32-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -451,6 +451,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -463,12 +464,16 @@ print_insn_lm32 (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -534,9 +539,11 @@ print_insn_lm32 (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = lm32_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "2dcccec3b60be7da8d5c96feab5aae26150c2409",
      "filename": "opcodes/m32c-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/m32c-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/m32c-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/m32c-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -63063,6 +63063,7 @@ m32c_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -63076,6 +63077,7 @@ m32c_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -63110,6 +63112,9 @@ m32c_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -63139,11 +63144,8 @@ m32c_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = m32c_cgen_rebuild_tables;"
    },
    {
      "sha": "41afca3cc0a8f598911b9ab0e1afbffcaba3c79d",
      "filename": "opcodes/m32c-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/m32c-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/m32c-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/m32c-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1195,6 +1195,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -1207,12 +1208,16 @@ print_insn_m32c (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -1278,9 +1283,11 @@ print_insn_m32c (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = m32c_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "bb96818c94ca5f3c52511d6bcc7615f3bb36aa24",
      "filename": "opcodes/m32r-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/m32r-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/m32r-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/m32r-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1395,6 +1395,7 @@ m32r_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -1408,6 +1409,7 @@ m32r_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -1442,6 +1444,9 @@ m32r_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -1471,11 +1476,8 @@ m32r_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = m32r_cgen_rebuild_tables;"
    },
    {
      "sha": "e66673980191e2b3bf009206a86fdc775040192d",
      "filename": "opcodes/m32r-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/m32r-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/m32r-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/m32r-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -583,6 +583,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -595,12 +596,16 @@ print_insn_m32r (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -666,9 +671,11 @@ print_insn_m32r (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = m32r_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "e255641f27e36ba51ddab885093cf07e91287c58",
      "filename": "opcodes/mep-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/mep-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/mep-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mep-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -6256,6 +6256,7 @@ mep_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -6269,6 +6270,7 @@ mep_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -6303,6 +6305,9 @@ mep_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -6332,11 +6337,8 @@ mep_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = mep_cgen_rebuild_tables;"
    },
    {
      "sha": "d2df5883031fe7e1845c8212b73f21b004acb6e9",
      "filename": "opcodes/mep-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/mep-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/mep-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mep-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1491,6 +1491,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -1503,12 +1504,16 @@ print_insn_mep (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -1574,9 +1579,11 @@ print_insn_mep (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = mep_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "37a02c9b8d53adf54c96a2e12106ead3e84410df",
      "filename": "opcodes/mt-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/mt-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/mt-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mt-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1176,6 +1176,7 @@ mt_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -1189,6 +1190,7 @@ mt_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -1223,6 +1225,9 @@ mt_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -1252,11 +1257,8 @@ mt_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = mt_cgen_rebuild_tables;"
    },
    {
      "sha": "3d552e8acbbe330641e32fdaa6cbb094f9c02ff2",
      "filename": "opcodes/mt-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/mt-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/mt-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/mt-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -594,6 +594,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -606,12 +607,16 @@ print_insn_mt (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -677,9 +682,11 @@ print_insn_mt (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = mt_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "a4f32d67b38b80efd986281311254faca251358f",
      "filename": "opcodes/or1k-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/or1k-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/or1k-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/or1k-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -2070,6 +2070,7 @@ or1k_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -2083,6 +2084,7 @@ or1k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -2117,6 +2119,9 @@ or1k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -2146,11 +2151,8 @@ or1k_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = or1k_cgen_rebuild_tables;"
    },
    {
      "sha": "d350d2bbae2de48a842d0f967cd379d6036af021",
      "filename": "opcodes/or1k-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/or1k-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/or1k-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/or1k-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -478,6 +478,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -490,12 +491,16 @@ print_insn_or1k (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -561,9 +566,11 @@ print_insn_or1k (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = or1k_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "4532c1720e712018ab4c722e2ddd2f6d5847c4a1",
      "filename": "opcodes/xc16x-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/xc16x-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/xc16x-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/xc16x-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -3379,6 +3379,7 @@ xc16x_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -3392,6 +3393,7 @@ xc16x_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -3426,6 +3428,9 @@ xc16x_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -3455,11 +3460,8 @@ xc16x_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = xc16x_cgen_rebuild_tables;"
    },
    {
      "sha": "2cf926b68f8120b8dc33b608e80ad5cb7457ac72",
      "filename": "opcodes/xc16x-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/xc16x-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/xc16x-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/xc16x-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -724,6 +724,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -736,12 +737,16 @@ print_insn_xc16x (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -807,9 +812,11 @@ print_insn_xc16x (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = xc16x_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    },
    {
      "sha": "a62d1f7eccd3720a6ddebcda0e7a7288f5561bc2",
      "filename": "opcodes/xstormy16-desc.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/xstormy16-desc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/xstormy16-desc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/xstormy16-desc.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -1347,6 +1347,7 @@ xstormy16_cgen_rebuild_tables (CGEN_CPU_TABLE *cd)\n    CGEN_CPU_OPEN_MACHS:   bitmap of values in enum mach_attr\n    CGEN_CPU_OPEN_BFDMACH: specify 1 mach using bfd name\n    CGEN_CPU_OPEN_ENDIAN:  specify endian choice\n+   CGEN_CPU_OPEN_INSN_ENDIAN: specify instruction endian choice\n    CGEN_CPU_OPEN_END:     terminates arguments\n \n    ??? Simultaneous multiple isas might not make sense, but it's not (yet)\n@@ -1360,6 +1361,7 @@ xstormy16_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   CGEN_BITSET *isas = 0;  /* 0 = \"unspecified\" */\n   unsigned int machs = 0; /* 0 = \"unspecified\" */\n   enum cgen_endian endian = CGEN_ENDIAN_UNKNOWN;\n+  enum cgen_endian insn_endian = CGEN_ENDIAN_UNKNOWN;\n   va_list ap;\n \n   if (! init_p)\n@@ -1394,6 +1396,9 @@ xstormy16_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n \tcase CGEN_CPU_OPEN_ENDIAN :\n \t  endian = va_arg (ap, enum cgen_endian);\n \t  break;\n+\tcase CGEN_CPU_OPEN_INSN_ENDIAN :\n+\t  insn_endian = va_arg (ap, enum cgen_endian);\n+\t  break;\n \tdefault :\n \t  opcodes_error_handler\n \t    (/* xgettext:c-format */\n@@ -1423,11 +1428,8 @@ xstormy16_cgen_cpu_open (enum cgen_cpu_open_arg arg_type, ...)\n   cd->isas = cgen_bitset_copy (isas);\n   cd->machs = machs;\n   cd->endian = endian;\n-  /* FIXME: for the sparc case we can determine insn-endianness statically.\n-     The worry here is where both data and insn endian can be independently\n-     chosen, in which case this function will need another argument.\n-     Actually, will want to allow for more arguments in the future anyway.  */\n-  cd->insn_endian = endian;\n+  cd->insn_endian\n+    = (insn_endian == CGEN_ENDIAN_UNKNOWN ? endian : insn_endian);\n \n   /* Table (re)builder.  */\n   cd->rebuild_tables = xstormy16_cgen_rebuild_tables;"
    },
    {
      "sha": "8382c3da85d1ad1f5a99ceda022d1976df9d91ee",
      "filename": "opcodes/xstormy16-dis.c",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/xstormy16-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b3db6d07be467fe86f5b4185a8fc7bec49380c1f/opcodes/xstormy16-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/xstormy16-dis.c?ref=b3db6d07be467fe86f5b4185a8fc7bec49380c1f",
      "patch": "@@ -472,6 +472,7 @@ typedef struct cpu_desc_list\n   CGEN_BITSET *isa;\n   int mach;\n   int endian;\n+  int insn_endian;\n   CGEN_CPU_DESC cd;\n } cpu_desc_list;\n \n@@ -484,12 +485,16 @@ print_insn_xstormy16 (bfd_vma pc, disassemble_info *info)\n   static CGEN_BITSET *prev_isa;\n   static int prev_mach;\n   static int prev_endian;\n+  static int prev_insn_endian;\n   int length;\n   CGEN_BITSET *isa;\n   int mach;\n   int endian = (info->endian == BFD_ENDIAN_BIG\n \t\t? CGEN_ENDIAN_BIG\n \t\t: CGEN_ENDIAN_LITTLE);\n+  int insn_endian = (info->endian_code == BFD_ENDIAN_BIG\n+                     ? CGEN_ENDIAN_BIG\n+                     : CGEN_ENDIAN_LITTLE);\n   enum bfd_architecture arch;\n \n   /* ??? gdb will set mach but leave the architecture as \"unknown\" */\n@@ -555,9 +560,11 @@ print_insn_xstormy16 (bfd_vma pc, disassemble_info *info)\n       prev_isa = cgen_bitset_copy (isa);\n       prev_mach = mach;\n       prev_endian = endian;\n+      prev_insn_endian = insn_endian;\n       cd = xstormy16_cgen_cpu_open (CGEN_CPU_OPEN_ISAS, prev_isa,\n \t\t\t\t CGEN_CPU_OPEN_BFDMACH, mach_name,\n \t\t\t\t CGEN_CPU_OPEN_ENDIAN, prev_endian,\n+                                 CGEN_CPU_OPEN_INSN_ENDIAN, prev_insn_endian,\n \t\t\t\t CGEN_CPU_OPEN_END);\n       if (!cd)\n \tabort ();"
    }
  ]
}