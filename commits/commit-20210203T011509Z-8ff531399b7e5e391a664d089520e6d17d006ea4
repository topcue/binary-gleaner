{
  "sha": "8ff531399b7e5e391a664d089520e6d17d006ea4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGZmNTMxMzk5YjdlNWUzOTFhNjY0ZDA4OTUyMGU2ZDE3ZDAwNmVhNA==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2020-12-13T01:35:05Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-02-03T01:15:09Z"
    },
    "message": "prepare_for_detach and ongoing displaced stepping\n\nI noticed that \"detach\" while a program was running sometimes resulted\nin the process crashing.  I tracked it down to this change to\nprepare_for_detach in commit 187b041e (\"gdb: move displaced stepping\nlogic to gdbarch, allow starting concurrent displaced steps\"):\n\n    /* Is any thread of this process displaced stepping?  If not,\n       there's nothing else to do.  */\n -  if (displaced->step_thread == nullptr)\n +  if (displaced_step_in_progress (inf))\n      return;\n\nThe problem above is that the condition was inadvertently flipped.  It\nshould have been:\n\n   if (!displaced_step_in_progress (inf))\n\nSo I fixed it, and wrote a testcase to exercise it.  The testcase has\na number of threads constantly stepping over a breakpoint, and then\nGDB detaches the process, while threads are running and stepping over\nthe breakpoint.  And then I was surprised that my testcase would hang\n-- GDB would get stuck in an infinite loop in prepare_for_detach,\nhere:\n\n  while (displaced_step_in_progress (inf))\n    {\n      ...\n\nWhat is going on is that since we now have two displaced stepping\nbuffers, as one displaced step finishes, GDB starts another, and\nthere's another one already in progress, and on and on, so the\ndisplaced_step_in_progress condition never turns false.  This happens\nbecause we go via the whole handle_inferior_event, which tries to\nstart new step overs when one finishes.  And also because while we\nremove breakpoints from the target before prepare_for_detach is\ncalled, handle_inferior_event ends up calling insert_breakpoints via\ne.g. keep_going.\n\nThinking through all this, I came to the conclusion that going through\nthe whole handle_inferior_event isn't ideal.  A _lot_ is done by that\nfunction, e.g., some thread may get a signal which is passed to the\ninferior, and gdb decides to try to get over the signal handler, which\nreinstalls breakpoints.  Or some process may exit.  We can end up\nreporting these events via normal_stop while detaching, maybe end up\nrunning some breakpoint commands, or maybe even something runs an\ninferior function call.  Etc.  All this after the user has already\ndeclared they don't want to debug the process anymore, by asking to\ndetach.\n\nI came to the conclusion that it's better to do the minimal amount of\nwork possible, in a more controlled fashion, without going through\nhandle_inferior_event.  So in the new approach implemented by this\npatch, if there are threads of the inferior that we're detaching in\nthe middle of a displaced step, stop them, and cancel the displaced\nstep.  This is basically what stop_all_threads already does, via\nwait_one and (the now factored out) handle_one, so I'm reusing those.\n\ngdb/ChangeLog:\n\n\t* infrun.c (struct wait_one_event): Move higher up.\n\t(prepare_for_detach): Abort in-progress displaced steps instead of\n\tletting them complete.\n\t(handle_one): If the inferior is detaching, don't add the thread\n\tback to the global step-over chain.\n\t(restart_threads): Don't restart threads if detaching.\n\t(handle_signal_stop): Remove inferior::detaching reference.",
    "tree": {
      "sha": "071dc899e21b33d0fbe41b90dda4c90d9e540bc3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/071dc899e21b33d0fbe41b90dda4c90d9e540bc3"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8ff531399b7e5e391a664d089520e6d17d006ea4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ff531399b7e5e391a664d089520e6d17d006ea4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8ff531399b7e5e391a664d089520e6d17d006ea4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8ff531399b7e5e391a664d089520e6d17d006ea4/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9147506842aaedfa90e89dd7f4913a990dbf947d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9147506842aaedfa90e89dd7f4913a990dbf947d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9147506842aaedfa90e89dd7f4913a990dbf947d"
    }
  ],
  "stats": {
    "total": 134,
    "additions": 77,
    "deletions": 57
  },
  "files": [
    {
      "sha": "62aab57972f591e01ee74b63dff8d2d0f7bb6225",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ff531399b7e5e391a664d089520e6d17d006ea4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ff531399b7e5e391a664d089520e6d17d006ea4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=8ff531399b7e5e391a664d089520e6d17d006ea4",
      "patch": "@@ -1,3 +1,13 @@\n+2021-02-03  Pedro Alves  <pedro@palves.net>\n+\n+\t* infrun.c (struct wait_one_event): Move higher up.\n+\t(prepare_for_detach): Abort in-progress displaced steps instead of\n+\tletting them complete.\n+\t(handle_one): If the inferior is detaching, don't add the thread\n+\tback to the global step-over chain.\n+\t(restart_threads): Don't restart threads if detaching.\n+\t(handle_signal_stop): Remove inferior::detaching reference.\n+\n 2021-02-03  Pedro Alves  <pedro@palves.net>\n \n \t* infrun.c (prepare_for_detach): Don't release scoped_restore"
    },
    {
      "sha": "71bf10f4c5eae5fc64fcbde41f98d20fd2e5766c",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 67,
      "deletions": 57,
      "changes": 124,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8ff531399b7e5e391a664d089520e6d17d006ea4/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8ff531399b7e5e391a664d089520e6d17d006ea4/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=8ff531399b7e5e391a664d089520e6d17d006ea4",
      "patch": "@@ -3551,6 +3551,22 @@ do_target_wait (ptid_t wait_ptid, execution_control_state *ecs,\n   return false;\n }\n \n+/* An event reported by wait_one.  */\n+\n+struct wait_one_event\n+{\n+  /* The target the event came out of.  */\n+  process_stratum_target *target;\n+\n+  /* The PTID the event was for.  */\n+  ptid_t ptid;\n+\n+  /* The waitstatus.  */\n+  target_waitstatus ws;\n+};\n+\n+static bool handle_one (const wait_one_event &event);\n+\n /* Prepare and stabilize the inferior for detaching it.  E.g.,\n    detaching while a thread is displaced stepping is a recipe for\n    crashing it, as nothing would readjust the PC out of the scratch\n@@ -3561,53 +3577,60 @@ prepare_for_detach (void)\n {\n   struct inferior *inf = current_inferior ();\n   ptid_t pid_ptid = ptid_t (inf->pid);\n-\n-  /* Is any thread of this process displaced stepping?  If not,\n-     there's nothing else to do.  */\n-  if (displaced_step_in_progress (inf))\n-    return;\n-\n-  infrun_debug_printf (\"displaced-stepping in-process while detaching\");\n+  scoped_restore_current_thread restore_thread;\n \n   scoped_restore restore_detaching = make_scoped_restore (&inf->detaching, true);\n \n-  while (displaced_step_in_progress (inf))\n+  /* Remove all threads of INF from the global step-over chain.  We\n+     want to stop any ongoing step-over, not start any new one.  */\n+  thread_info *next;\n+  for (thread_info *tp = global_thread_step_over_chain_head;\n+       tp != nullptr;\n+       tp = next)\n     {\n-      struct execution_control_state ecss;\n-      struct execution_control_state *ecs;\n+      next = global_thread_step_over_chain_next (tp);\n+      if (tp->inf == inf)\n+\tglobal_thread_step_over_chain_remove (tp);\n+    }\n \n-      ecs = &ecss;\n-      memset (ecs, 0, sizeof (*ecs));\n+  if (displaced_step_in_progress (inf))\n+    {\n+      infrun_debug_printf (\"displaced-stepping in-process while detaching\");\n \n-      overlay_cache_invalid = 1;\n-      /* Flush target cache before starting to handle each event.\n-\t Target was running and cache could be stale.  This is just a\n-\t heuristic.  Running threads may modify target memory, but we\n-\t don't get any event.  */\n-      target_dcache_invalidate ();\n+      /* Stop threads currently displaced stepping, aborting it.  */\n \n-      do_target_wait (pid_ptid, ecs, 0);\n+      for (thread_info *thr : inf->non_exited_threads ())\n+\t{\n+\t  if (thr->displaced_step_state.in_progress ())\n+\t    {\n+\t      if (thr->executing)\n+\t\t{\n+\t\t  if (!thr->stop_requested)\n+\t\t    {\n+\t\t      target_stop (thr->ptid);\n+\t\t      thr->stop_requested = true;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tthr->resumed = false;\n+\t    }\n+\t}\n \n-      if (debug_infrun)\n-\tprint_target_wait_results (pid_ptid, ecs->ptid, &ecs->ws);\n+      while (displaced_step_in_progress (inf))\n+\t{\n+\t  wait_one_event event;\n \n-      /* If an error happens while handling the event, propagate GDB's\n-\t knowledge of the executing state to the frontend/user running\n-\t state.  */\n-      scoped_finish_thread_state finish_state (inf->process_target (),\n-\t\t\t\t\t       minus_one_ptid);\n+\t  event.target = inf->process_target ();\n+\t  event.ptid = do_target_wait_1 (inf, pid_ptid, &event.ws, 0);\n \n-      /* Now figure out what to do with the result of the result.  */\n-      handle_inferior_event (ecs);\n+\t  if (debug_infrun)\n+\t    print_target_wait_results (pid_ptid, event.ptid, &event.ws);\n \n-      /* No error, don't finish the state yet.  */\n-      finish_state.release ();\n+\t  handle_one (event);\n+\t}\n \n-      /* Breakpoints and watchpoints are not installed on the target\n-\t at this point, and signals are passed directly to the\n-\t inferior, so this must mean the process is gone.  */\n-      if (!ecs->wait_some_more)\n-\terror (_(\"Program exited while detaching\"));\n+      /* It's OK to leave some of the threads of INF stopped, since\n+\t they'll be detached shortly.  */\n     }\n }\n \n@@ -4361,20 +4384,6 @@ poll_one_curr_target (struct target_waitstatus *ws)\n   return event_ptid;\n }\n \n-/* An event reported by wait_one.  */\n-\n-struct wait_one_event\n-{\n-  /* The target the event came out of.  */\n-  process_stratum_target *target;\n-\n-  /* The PTID the event was for.  */\n-  ptid_t ptid;\n-\n-  /* The waitstatus.  */\n-  target_waitstatus ws;\n-};\n-\n /* Wait for one event out of any target.  */\n \n static wait_one_event\n@@ -4558,9 +4567,10 @@ mark_non_executing_threads (process_stratum_target *target,\n /* Handle one event after stopping threads.  If the eventing thread\n    reports back any interesting event, we leave it pending.  If the\n    eventing thread was in the middle of a displaced step, we\n-   cancel/finish it.  Returns true if there are no resumed threads\n-   left in the target (thus there's no point in waiting further),\n-   false otherwise.  */\n+   cancel/finish it, and unless the thread's inferior is being\n+   detached, put the thread back in the step-over chain.  Returns true\n+   if there are no resumed threads left in the target (thus there's no\n+   point in waiting further), false otherwise.  */\n \n static bool\n handle_one (const wait_one_event &event)\n@@ -4663,7 +4673,8 @@ handle_one (const wait_one_event &event)\n \t\t target_pid_to_str (t->ptid).c_str ());\n \n \t      t->control.trap_expected = 0;\n-\t      global_thread_step_over_chain_enqueue (t);\n+\t      if (!t->inf->detaching)\n+\t\tglobal_thread_step_over_chain_enqueue (t);\n \t    }\n \t}\n       else\n@@ -4687,7 +4698,8 @@ handle_one (const wait_one_event &event)\n \t    {\n \t      /* Add it back to the step-over queue.  */\n \t      t->control.trap_expected = 0;\n-\t      global_thread_step_over_chain_enqueue (t);\n+\t      if (!t->inf->detaching)\n+\t\tglobal_thread_step_over_chain_enqueue (t);\n \t    }\n \n \t  regcache = get_thread_regcache (t);\n@@ -6111,7 +6123,6 @@ handle_signal_stop (struct execution_control_state *ecs)\n   if (random_signal)\n     {\n       /* Signal not for debugging purposes.  */\n-      struct inferior *inf = find_inferior_ptid (ecs->target, ecs->ptid);\n       enum gdb_signal stop_signal = ecs->event_thread->suspend.stop_signal;\n \n       infrun_debug_printf (\"random signal (%s)\",\n@@ -6124,8 +6135,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t to remain stopped.  */\n       if (stop_soon != NO_STOP_QUIETLY\n \t  || ecs->event_thread->stop_requested\n-\t  || (!inf->detaching\n-\t      && signal_stop_state (ecs->event_thread->suspend.stop_signal)))\n+\t  || signal_stop_state (ecs->event_thread->suspend.stop_signal))\n \t{\n \t  stop_waiting (ecs);\n \t  return;"
    }
  ]
}