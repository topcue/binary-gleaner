{
  "sha": "8c4c18181ea382adf407df235c7991feb0647bab",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGM0YzE4MTgxZWEzODJhZGY0MDdkZjIzNWM3OTkxZmViMDY0N2JhYg==",
  "commit": {
    "author": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-08-04T16:11:31Z"
    },
    "committer": {
      "name": "Jose E. Marchesi",
      "email": "jose.marchesi@oracle.com",
      "date": "2020-08-04T16:11:31Z"
    },
    "message": "sim: generated files for the eBPF simulator\n\nThis patch adds the CGEN generated files for the eBPF simulator.\n\nsim/ChangeLog:\n\n2020-08-04  Jose E. Marchesi  <jose.marchesi@oracle.com>\n\t    David Faust <david.faust@oracle.com>\n\n\t* bpf/arch.c: Likewise.\n\t* bpf/arch.h: Likewise.\n\t* bpf/cpu.c: Likewise.\n\t* bpf/cpu.h: Likewise.\n\t* bpf/cpuall.h: Likewise.\n\t* bpf/decode-be.c: Likewise.\n\t* bpf/decode-be.h: Likewise.\n\t* bpf/decode-le.c: Likewise.\n\t* bpf/decode-le.h: Likewise.\n\t* bpf/defs-be.h: Likewise.\n\t* bpf/defs-le.h: Likewise.\n\t* bpf/sem-be.c: Likewise.\n\t* bpf/sem-le.c: Likewise.",
    "tree": {
      "sha": "3ddda99c5fc728cafab2a872eacf2354baa410ab",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/3ddda99c5fc728cafab2a872eacf2354baa410ab"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8c4c18181ea382adf407df235c7991feb0647bab",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c4c18181ea382adf407df235c7991feb0647bab",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8c4c18181ea382adf407df235c7991feb0647bab",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8c4c18181ea382adf407df235c7991feb0647bab/comments",
  "author": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jemarch",
    "id": 7061875,
    "node_id": "MDQ6VXNlcjcwNjE4NzU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jemarch",
    "html_url": "https://github.com/jemarch",
    "followers_url": "https://api.github.com/users/jemarch/followers",
    "following_url": "https://api.github.com/users/jemarch/following{/other_user}",
    "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions",
    "organizations_url": "https://api.github.com/users/jemarch/orgs",
    "repos_url": "https://api.github.com/users/jemarch/repos",
    "events_url": "https://api.github.com/users/jemarch/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jemarch/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "b26e2ae7d333d84a85daaa9ca699c8bae2bd05bc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b26e2ae7d333d84a85daaa9ca699c8bae2bd05bc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/b26e2ae7d333d84a85daaa9ca699c8bae2bd05bc"
    }
  ],
  "stats": {
    "total": 9943,
    "additions": 9943,
    "deletions": 0
  },
  "files": [
    {
      "sha": "5316e248266f1b50ec105ae1ec209e5e8257eb22",
      "filename": "sim/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ChangeLog?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -1,3 +1,20 @@\n+2020-08-04  Jose E. Marchesi  <jose.marchesi@oracle.com>\n+\t    David Faust <david.faust@oracle.com>\n+\n+\t* bpf/arch.c: Likewise.\n+\t* bpf/arch.h: Likewise.\n+\t* bpf/cpu.c: Likewise.\n+\t* bpf/cpu.h: Likewise.\n+\t* bpf/cpuall.h: Likewise.\n+\t* bpf/decode-be.c: Likewise.\n+\t* bpf/decode-be.h: Likewise.\n+\t* bpf/decode-le.c: Likewise.\n+\t* bpf/decode-le.h: Likewise.\n+\t* bpf/defs-be.h: Likewise.\n+\t* bpf/defs-le.h: Likewise.\n+\t* bpf/sem-be.c: Likewise.\n+\t* bpf/sem-le.c: Likewise.\n+\n 2020-08-04  Jose E. Marchesi  <jose.marchesi@oracle.com>\n \t    David Faust <david.faust@oracle.com>\n "
    },
    {
      "sha": "d4b6d139c5b0ab26b47dd14b4d829bd9d4be02a5",
      "filename": "sim/bpf/arch.c",
      "status": "added",
      "additions": 35,
      "deletions": 0,
      "changes": 35,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/arch.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/arch.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/arch.c?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,35 @@\n+/* Simulator support for bpf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#include \"sim-main.h\"\n+#include \"bfd.h\"\n+\n+const SIM_MACH *sim_machs[] =\n+{\n+#ifdef HAVE_CPU_BPFBF\n+  & bpf_mach,\n+#endif\n+  0\n+};\n+"
    },
    {
      "sha": "734d65398fca78b8e737c44b9a3dda60b1ac126d",
      "filename": "sim/bpf/arch.h",
      "status": "added",
      "additions": 50,
      "deletions": 0,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/arch.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/arch.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/arch.h?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,50 @@\n+/* Simulator header for bpf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef BPF_ARCH_H\n+#define BPF_ARCH_H\n+\n+#define TARGET_BIG_ENDIAN 1\n+\n+#define WI  DI\n+#define UWI UDI\n+#define AI  UDI\n+\n+#define IAI UDI\n+\n+/* Enum declaration for model types.  */\n+typedef enum model_type {\n+  MODEL_BPF_DEF, MODEL_MAX\n+} MODEL_TYPE;\n+\n+#define MAX_MODELS ((int) MODEL_MAX)\n+\n+/* Enum declaration for unit types.  */\n+typedef enum unit_type {\n+  UNIT_NONE, UNIT_BPF_DEF_U_EXEC, UNIT_MAX\n+} UNIT_TYPE;\n+\n+#define MAX_UNITS (1)\n+\n+#endif /* BPF_ARCH_H */"
    },
    {
      "sha": "c19de5d8e1fe3b43463608259c6c514ab38eb040",
      "filename": "sim/bpf/cpu.c",
      "status": "added",
      "additions": 69,
      "deletions": 0,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/cpu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/cpu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/cpu.c?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,69 @@\n+/* Misc. support for CPU family bpfbf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#define WANT_CPU bpfbf\n+#define WANT_CPU_BPFBF\n+\n+#include \"sim-main.h\"\n+#include \"cgen-ops.h\"\n+\n+/* Get the value of h-gpr.  */\n+\n+DI\n+bpfbf_h_gpr_get (SIM_CPU *current_cpu, UINT regno)\n+{\n+  return CPU (h_gpr[regno]);\n+}\n+\n+/* Set a value for h-gpr.  */\n+\n+void\n+bpfbf_h_gpr_set (SIM_CPU *current_cpu, UINT regno, DI newval)\n+{\n+  CPU (h_gpr[regno]) = newval;\n+}\n+\n+/* Get the value of h-pc.  */\n+\n+UDI\n+bpfbf_h_pc_get (SIM_CPU *current_cpu)\n+{\n+  return GET_H_PC ();\n+}\n+\n+/* Set a value for h-pc.  */\n+\n+void\n+bpfbf_h_pc_set (SIM_CPU *current_cpu, UDI newval)\n+{\n+  SET_H_PC (newval);\n+}\n+\n+/* Record trace results for INSN.  */\n+\n+void\n+bpfbf_record_trace_results (SIM_CPU *current_cpu, CGEN_INSN *insn,\n+\t\t\t    int *indices, TRACE_RECORD *tr)\n+{\n+}"
    },
    {
      "sha": "1e23fbeabf56c802a7d9b0774d2ebdc7cea91a4c",
      "filename": "sim/bpf/cpu.h",
      "status": "added",
      "additions": 81,
      "deletions": 0,
      "changes": 81,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/cpu.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/cpu.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/cpu.h?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,81 @@\n+/* CPU family header for bpfbf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef CPU_BPFBF_H\n+#define CPU_BPFBF_H\n+\n+/* Maximum number of instructions that are fetched at a time.\n+   This is for LIW type instructions sets (e.g. m32r).  */\n+#define MAX_LIW_INSNS 1\n+\n+/* Maximum number of instructions that can be executed in parallel.  */\n+#define MAX_PARALLEL_INSNS 1\n+\n+/* The size of an \"int\" needed to hold an instruction word.\n+   This is usually 32 bits, but some architectures needs 64 bits.  */\n+typedef CGEN_INSN_LGUINT CGEN_INSN_WORD;\n+\n+#include \"cgen-engine.h\"\n+\n+/* CPU state information.  */\n+typedef struct {\n+  /* Hardware elements.  */\n+  struct {\n+  /* General Purpose Registers */\n+  DI h_gpr[16];\n+#define GET_H_GPR(a1) CPU (h_gpr)[a1]\n+#define SET_H_GPR(a1, x) (CPU (h_gpr)[a1] = (x))\n+  /* program counter */\n+  UDI h_pc;\n+#define GET_H_PC() CPU (h_pc)\n+#define SET_H_PC(x) \\\n+do { \\\n+CPU (h_pc) = (x);\\\n+;} while (0)\n+  } hardware;\n+#define CPU_CGEN_HW(cpu) (& (cpu)->cpu_data.hardware)\n+} BPFBF_CPU_DATA;\n+\n+/* Cover fns for register access.  */\n+DI bpfbf_h_gpr_get (SIM_CPU *, UINT);\n+void bpfbf_h_gpr_set (SIM_CPU *, UINT, DI);\n+UDI bpfbf_h_pc_get (SIM_CPU *);\n+void bpfbf_h_pc_set (SIM_CPU *, UDI);\n+\n+/* These must be hand-written.  */\n+extern CPUREG_FETCH_FN bpfbf_fetch_register;\n+extern CPUREG_STORE_FN bpfbf_store_register;\n+\n+typedef struct {\n+  int empty;\n+} MODEL_BPF_DEF_DATA;\n+\n+/* Collection of various things for the trace handler to use.  */\n+\n+typedef struct trace_record {\n+  IADDR pc;\n+  /* FIXME:wip */\n+} TRACE_RECORD;\n+\n+#endif /* CPU_BPFBF_H */"
    },
    {
      "sha": "3933dea35395fcaf9f8a985c94b4bb33aeaadb2e",
      "filename": "sim/bpf/cpuall.h",
      "status": "added",
      "additions": 65,
      "deletions": 0,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/cpuall.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/cpuall.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/cpuall.h?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,65 @@\n+/* Simulator CPU header for bpf.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef BPF_CPUALL_H\n+#define BPF_CPUALL_H\n+\n+/* Include files for each cpu family.  */\n+\n+#ifdef WANT_CPU_BPFBF\n+#include \"eng.h\"\n+#include \"cpu.h\"\n+#include \"decode.h\"\n+#endif\n+\n+extern const SIM_MACH bpf_mach;\n+\n+#ifndef WANT_CPU\n+/* The ARGBUF struct.  */\n+struct argbuf {\n+  /* These are the baseclass definitions.  */\n+  IADDR addr;\n+  const IDESC *idesc;\n+  char trace_p;\n+  char profile_p;\n+  /* ??? Temporary hack for skip insns.  */\n+  char skip_count;\n+  char unused;\n+  /* cpu specific data follows */\n+};\n+#endif\n+\n+#ifndef WANT_CPU\n+/* A cached insn.\n+\n+   ??? SCACHE used to contain more than just argbuf.  We could delete the\n+   type entirely and always just use ARGBUF, but for future concerns and as\n+   a level of abstraction it is left in.  */\n+\n+struct scache {\n+  struct argbuf argbuf;\n+};\n+#endif\n+\n+#endif /* BPF_CPUALL_H */"
    },
    {
      "sha": "22d95ddec1f4629ceab82f430b77db5e3ec0f3ac",
      "filename": "sim/bpf/decode-be.c",
      "status": "added",
      "additions": 1129,
      "deletions": 0,
      "changes": 1129,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/decode-be.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/decode-be.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/decode-be.c?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,1129 @@\n+/* Simulator instruction decoder for bpfbf_ebpfbe.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#define WANT_CPU bpfbf\n+#define WANT_CPU_BPFBF\n+\n+#include \"sim-main.h\"\n+#include \"sim-assert.h\"\n+\n+/* The instruction descriptor array.\n+   This is computed at runtime.  Space for it is not malloc'd to save a\n+   teensy bit of cpu in the decoder.  Moving it to malloc space is trivial\n+   but won't be done until necessary (we don't currently support the runtime\n+   addition of instructions nor an SMP machine with different cpus).  */\n+static IDESC bpfbf_ebpfbe_insn_data[BPFBF_EBPFBE_INSN__MAX];\n+\n+/* Commas between elements are contained in the macros.\n+   Some of these are conditionally compiled out.  */\n+\n+static const struct insn_sem bpfbf_ebpfbe_insn_sem[] =\n+{\n+  { VIRTUAL_INSN_X_INVALID, BPFBF_EBPFBE_INSN_X_INVALID, BPFBF_EBPFBE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_AFTER, BPFBF_EBPFBE_INSN_X_AFTER, BPFBF_EBPFBE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_BEFORE, BPFBF_EBPFBE_INSN_X_BEFORE, BPFBF_EBPFBE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_CTI_CHAIN, BPFBF_EBPFBE_INSN_X_CTI_CHAIN, BPFBF_EBPFBE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_CHAIN, BPFBF_EBPFBE_INSN_X_CHAIN, BPFBF_EBPFBE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_BEGIN, BPFBF_EBPFBE_INSN_X_BEGIN, BPFBF_EBPFBE_SFMT_EMPTY },\n+  { BPF_INSN_ADDIBE, BPFBF_EBPFBE_INSN_ADDIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_ADDRBE, BPFBF_EBPFBE_INSN_ADDRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_ADD32IBE, BPFBF_EBPFBE_INSN_ADD32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_ADD32RBE, BPFBF_EBPFBE_INSN_ADD32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_SUBIBE, BPFBF_EBPFBE_INSN_SUBIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_SUBRBE, BPFBF_EBPFBE_INSN_SUBRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_SUB32IBE, BPFBF_EBPFBE_INSN_SUB32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_SUB32RBE, BPFBF_EBPFBE_INSN_SUB32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_MULIBE, BPFBF_EBPFBE_INSN_MULIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_MULRBE, BPFBF_EBPFBE_INSN_MULRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_MUL32IBE, BPFBF_EBPFBE_INSN_MUL32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_MUL32RBE, BPFBF_EBPFBE_INSN_MUL32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_DIVIBE, BPFBF_EBPFBE_INSN_DIVIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_DIVRBE, BPFBF_EBPFBE_INSN_DIVRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_DIV32IBE, BPFBF_EBPFBE_INSN_DIV32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_DIV32RBE, BPFBF_EBPFBE_INSN_DIV32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_ORIBE, BPFBF_EBPFBE_INSN_ORIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_ORRBE, BPFBF_EBPFBE_INSN_ORRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_OR32IBE, BPFBF_EBPFBE_INSN_OR32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_OR32RBE, BPFBF_EBPFBE_INSN_OR32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_ANDIBE, BPFBF_EBPFBE_INSN_ANDIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_ANDRBE, BPFBF_EBPFBE_INSN_ANDRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_AND32IBE, BPFBF_EBPFBE_INSN_AND32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_AND32RBE, BPFBF_EBPFBE_INSN_AND32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_LSHIBE, BPFBF_EBPFBE_INSN_LSHIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_LSHRBE, BPFBF_EBPFBE_INSN_LSHRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_LSH32IBE, BPFBF_EBPFBE_INSN_LSH32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_LSH32RBE, BPFBF_EBPFBE_INSN_LSH32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_RSHIBE, BPFBF_EBPFBE_INSN_RSHIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_RSHRBE, BPFBF_EBPFBE_INSN_RSHRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_RSH32IBE, BPFBF_EBPFBE_INSN_RSH32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_RSH32RBE, BPFBF_EBPFBE_INSN_RSH32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_MODIBE, BPFBF_EBPFBE_INSN_MODIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_MODRBE, BPFBF_EBPFBE_INSN_MODRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_MOD32IBE, BPFBF_EBPFBE_INSN_MOD32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_MOD32RBE, BPFBF_EBPFBE_INSN_MOD32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_XORIBE, BPFBF_EBPFBE_INSN_XORIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_XORRBE, BPFBF_EBPFBE_INSN_XORRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_XOR32IBE, BPFBF_EBPFBE_INSN_XOR32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_XOR32RBE, BPFBF_EBPFBE_INSN_XOR32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_ARSHIBE, BPFBF_EBPFBE_INSN_ARSHIBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_ARSHRBE, BPFBF_EBPFBE_INSN_ARSHRBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_ARSH32IBE, BPFBF_EBPFBE_INSN_ARSH32IBE, BPFBF_EBPFBE_SFMT_ADDIBE },\n+  { BPF_INSN_ARSH32RBE, BPFBF_EBPFBE_INSN_ARSH32RBE, BPFBF_EBPFBE_SFMT_ADDRBE },\n+  { BPF_INSN_NEGBE, BPFBF_EBPFBE_INSN_NEGBE, BPFBF_EBPFBE_SFMT_NEGBE },\n+  { BPF_INSN_NEG32BE, BPFBF_EBPFBE_INSN_NEG32BE, BPFBF_EBPFBE_SFMT_NEGBE },\n+  { BPF_INSN_MOVIBE, BPFBF_EBPFBE_INSN_MOVIBE, BPFBF_EBPFBE_SFMT_MOVIBE },\n+  { BPF_INSN_MOVRBE, BPFBF_EBPFBE_INSN_MOVRBE, BPFBF_EBPFBE_SFMT_MOVRBE },\n+  { BPF_INSN_MOV32IBE, BPFBF_EBPFBE_INSN_MOV32IBE, BPFBF_EBPFBE_SFMT_MOVIBE },\n+  { BPF_INSN_MOV32RBE, BPFBF_EBPFBE_INSN_MOV32RBE, BPFBF_EBPFBE_SFMT_MOVRBE },\n+  { BPF_INSN_ENDLEBE, BPFBF_EBPFBE_INSN_ENDLEBE, BPFBF_EBPFBE_SFMT_ENDLEBE },\n+  { BPF_INSN_ENDBEBE, BPFBF_EBPFBE_INSN_ENDBEBE, BPFBF_EBPFBE_SFMT_ENDLEBE },\n+  { BPF_INSN_LDDWBE, BPFBF_EBPFBE_INSN_LDDWBE, BPFBF_EBPFBE_SFMT_LDDWBE },\n+  { BPF_INSN_LDABSW, BPFBF_EBPFBE_INSN_LDABSW, BPFBF_EBPFBE_SFMT_LDABSW },\n+  { BPF_INSN_LDABSH, BPFBF_EBPFBE_INSN_LDABSH, BPFBF_EBPFBE_SFMT_LDABSH },\n+  { BPF_INSN_LDABSB, BPFBF_EBPFBE_INSN_LDABSB, BPFBF_EBPFBE_SFMT_LDABSB },\n+  { BPF_INSN_LDABSDW, BPFBF_EBPFBE_INSN_LDABSDW, BPFBF_EBPFBE_SFMT_LDABSDW },\n+  { BPF_INSN_LDINDWBE, BPFBF_EBPFBE_INSN_LDINDWBE, BPFBF_EBPFBE_SFMT_LDINDWBE },\n+  { BPF_INSN_LDINDHBE, BPFBF_EBPFBE_INSN_LDINDHBE, BPFBF_EBPFBE_SFMT_LDINDHBE },\n+  { BPF_INSN_LDINDBBE, BPFBF_EBPFBE_INSN_LDINDBBE, BPFBF_EBPFBE_SFMT_LDINDBBE },\n+  { BPF_INSN_LDINDDWBE, BPFBF_EBPFBE_INSN_LDINDDWBE, BPFBF_EBPFBE_SFMT_LDINDDWBE },\n+  { BPF_INSN_LDXWBE, BPFBF_EBPFBE_INSN_LDXWBE, BPFBF_EBPFBE_SFMT_LDXWBE },\n+  { BPF_INSN_LDXHBE, BPFBF_EBPFBE_INSN_LDXHBE, BPFBF_EBPFBE_SFMT_LDXHBE },\n+  { BPF_INSN_LDXBBE, BPFBF_EBPFBE_INSN_LDXBBE, BPFBF_EBPFBE_SFMT_LDXBBE },\n+  { BPF_INSN_LDXDWBE, BPFBF_EBPFBE_INSN_LDXDWBE, BPFBF_EBPFBE_SFMT_LDXDWBE },\n+  { BPF_INSN_STXWBE, BPFBF_EBPFBE_INSN_STXWBE, BPFBF_EBPFBE_SFMT_STXWBE },\n+  { BPF_INSN_STXHBE, BPFBF_EBPFBE_INSN_STXHBE, BPFBF_EBPFBE_SFMT_STXHBE },\n+  { BPF_INSN_STXBBE, BPFBF_EBPFBE_INSN_STXBBE, BPFBF_EBPFBE_SFMT_STXBBE },\n+  { BPF_INSN_STXDWBE, BPFBF_EBPFBE_INSN_STXDWBE, BPFBF_EBPFBE_SFMT_STXDWBE },\n+  { BPF_INSN_STBBE, BPFBF_EBPFBE_INSN_STBBE, BPFBF_EBPFBE_SFMT_STBBE },\n+  { BPF_INSN_STHBE, BPFBF_EBPFBE_INSN_STHBE, BPFBF_EBPFBE_SFMT_STHBE },\n+  { BPF_INSN_STWBE, BPFBF_EBPFBE_INSN_STWBE, BPFBF_EBPFBE_SFMT_STWBE },\n+  { BPF_INSN_STDWBE, BPFBF_EBPFBE_INSN_STDWBE, BPFBF_EBPFBE_SFMT_STDWBE },\n+  { BPF_INSN_JEQIBE, BPFBF_EBPFBE_INSN_JEQIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JEQRBE, BPFBF_EBPFBE_INSN_JEQRBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JEQ32IBE, BPFBF_EBPFBE_INSN_JEQ32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JEQ32RBE, BPFBF_EBPFBE_INSN_JEQ32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JGTIBE, BPFBF_EBPFBE_INSN_JGTIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JGTRBE, BPFBF_EBPFBE_INSN_JGTRBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JGT32IBE, BPFBF_EBPFBE_INSN_JGT32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JGT32RBE, BPFBF_EBPFBE_INSN_JGT32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JGEIBE, BPFBF_EBPFBE_INSN_JGEIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JGERBE, BPFBF_EBPFBE_INSN_JGERBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JGE32IBE, BPFBF_EBPFBE_INSN_JGE32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JGE32RBE, BPFBF_EBPFBE_INSN_JGE32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JLTIBE, BPFBF_EBPFBE_INSN_JLTIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JLTRBE, BPFBF_EBPFBE_INSN_JLTRBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JLT32IBE, BPFBF_EBPFBE_INSN_JLT32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JLT32RBE, BPFBF_EBPFBE_INSN_JLT32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JLEIBE, BPFBF_EBPFBE_INSN_JLEIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JLERBE, BPFBF_EBPFBE_INSN_JLERBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JLE32IBE, BPFBF_EBPFBE_INSN_JLE32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JLE32RBE, BPFBF_EBPFBE_INSN_JLE32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSETIBE, BPFBF_EBPFBE_INSN_JSETIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSETRBE, BPFBF_EBPFBE_INSN_JSETRBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSET32IBE, BPFBF_EBPFBE_INSN_JSET32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSET32RBE, BPFBF_EBPFBE_INSN_JSET32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JNEIBE, BPFBF_EBPFBE_INSN_JNEIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JNERBE, BPFBF_EBPFBE_INSN_JNERBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JNE32IBE, BPFBF_EBPFBE_INSN_JNE32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JNE32RBE, BPFBF_EBPFBE_INSN_JNE32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSGTIBE, BPFBF_EBPFBE_INSN_JSGTIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSGTRBE, BPFBF_EBPFBE_INSN_JSGTRBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSGT32IBE, BPFBF_EBPFBE_INSN_JSGT32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSGT32RBE, BPFBF_EBPFBE_INSN_JSGT32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSGEIBE, BPFBF_EBPFBE_INSN_JSGEIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSGERBE, BPFBF_EBPFBE_INSN_JSGERBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSGE32IBE, BPFBF_EBPFBE_INSN_JSGE32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSGE32RBE, BPFBF_EBPFBE_INSN_JSGE32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSLTIBE, BPFBF_EBPFBE_INSN_JSLTIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSLTRBE, BPFBF_EBPFBE_INSN_JSLTRBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSLT32IBE, BPFBF_EBPFBE_INSN_JSLT32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSLT32RBE, BPFBF_EBPFBE_INSN_JSLT32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSLEIBE, BPFBF_EBPFBE_INSN_JSLEIBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSLERBE, BPFBF_EBPFBE_INSN_JSLERBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_JSLE32IBE, BPFBF_EBPFBE_INSN_JSLE32IBE, BPFBF_EBPFBE_SFMT_JEQIBE },\n+  { BPF_INSN_JSLE32RBE, BPFBF_EBPFBE_INSN_JSLE32RBE, BPFBF_EBPFBE_SFMT_JEQRBE },\n+  { BPF_INSN_CALLBE, BPFBF_EBPFBE_INSN_CALLBE, BPFBF_EBPFBE_SFMT_CALLBE },\n+  { BPF_INSN_JA, BPFBF_EBPFBE_INSN_JA, BPFBF_EBPFBE_SFMT_JA },\n+  { BPF_INSN_EXIT, BPFBF_EBPFBE_INSN_EXIT, BPFBF_EBPFBE_SFMT_EXIT },\n+  { BPF_INSN_XADDDWBE, BPFBF_EBPFBE_INSN_XADDDWBE, BPFBF_EBPFBE_SFMT_XADDDWBE },\n+  { BPF_INSN_XADDWBE, BPFBF_EBPFBE_INSN_XADDWBE, BPFBF_EBPFBE_SFMT_XADDWBE },\n+  { BPF_INSN_BRKPT, BPFBF_EBPFBE_INSN_BRKPT, BPFBF_EBPFBE_SFMT_EXIT },\n+};\n+\n+static const struct insn_sem bpfbf_ebpfbe_insn_sem_invalid =\n+{\n+  VIRTUAL_INSN_X_INVALID, BPFBF_EBPFBE_INSN_X_INVALID, BPFBF_EBPFBE_SFMT_EMPTY\n+};\n+\n+/* Initialize an IDESC from the compile-time computable parts.  */\n+\n+static INLINE void\n+init_idesc (SIM_CPU *cpu, IDESC *id, const struct insn_sem *t)\n+{\n+  const CGEN_INSN *insn_table = CGEN_CPU_INSN_TABLE (CPU_CPU_DESC (cpu))->init_entries;\n+\n+  id->num = t->index;\n+  id->sfmt = t->sfmt;\n+  if ((int) t->type <= 0)\n+    id->idata = & cgen_virtual_insn_table[- (int) t->type];\n+  else\n+    id->idata = & insn_table[t->type];\n+  id->attrs = CGEN_INSN_ATTRS (id->idata);\n+  /* Oh my god, a magic number.  */\n+  id->length = CGEN_INSN_BITSIZE (id->idata) / 8;\n+\n+#if WITH_PROFILE_MODEL_P\n+  id->timing = & MODEL_TIMING (CPU_MODEL (cpu)) [t->index];\n+  {\n+    SIM_DESC sd = CPU_STATE (cpu);\n+    SIM_ASSERT (t->index == id->timing->num);\n+  }\n+#endif\n+\n+  /* Semantic pointers are initialized elsewhere.  */\n+}\n+\n+/* Initialize the instruction descriptor table.  */\n+\n+void\n+bpfbf_ebpfbe_init_idesc_table (SIM_CPU *cpu)\n+{\n+  IDESC *id,*tabend;\n+  const struct insn_sem *t,*tend;\n+  int tabsize = BPFBF_EBPFBE_INSN__MAX;\n+  IDESC *table = bpfbf_ebpfbe_insn_data;\n+\n+  memset (table, 0, tabsize * sizeof (IDESC));\n+\n+  /* First set all entries to the `invalid insn'.  */\n+  t = & bpfbf_ebpfbe_insn_sem_invalid;\n+  for (id = table, tabend = table + tabsize; id < tabend; ++id)\n+    init_idesc (cpu, id, t);\n+\n+  /* Now fill in the values for the chosen cpu.  */\n+  for (t = bpfbf_ebpfbe_insn_sem, tend = t + sizeof (bpfbf_ebpfbe_insn_sem) / sizeof (*t);\n+       t != tend; ++t)\n+    {\n+      init_idesc (cpu, & table[t->index], t);\n+    }\n+\n+  /* Link the IDESC table into the cpu.  */\n+  CPU_IDESC (cpu) = table;\n+}\n+\n+/* Given an instruction, return a pointer to its IDESC entry.  */\n+\n+const IDESC *\n+bpfbf_ebpfbe_decode (SIM_CPU *current_cpu, IADDR pc,\n+              CGEN_INSN_WORD base_insn,\n+              ARGBUF *abuf)\n+{\n+  /* Result of decoder.  */\n+  BPFBF_EBPFBE_INSN_TYPE itype;\n+\n+  {\n+    CGEN_INSN_WORD insn = base_insn;\n+\n+    {\n+      unsigned int val = (((insn >> 0) & (255 << 0)));\n+      switch (val)\n+      {\n+      case 4 : itype = BPFBF_EBPFBE_INSN_ADD32IBE; goto extract_sfmt_addibe;\n+      case 5 : itype = BPFBF_EBPFBE_INSN_JA; goto extract_sfmt_ja;\n+      case 7 : itype = BPFBF_EBPFBE_INSN_ADDIBE; goto extract_sfmt_addibe;\n+      case 12 : itype = BPFBF_EBPFBE_INSN_ADD32RBE; goto extract_sfmt_addrbe;\n+      case 15 : itype = BPFBF_EBPFBE_INSN_ADDRBE; goto extract_sfmt_addrbe;\n+      case 20 : itype = BPFBF_EBPFBE_INSN_SUB32IBE; goto extract_sfmt_addibe;\n+      case 21 : itype = BPFBF_EBPFBE_INSN_JEQIBE; goto extract_sfmt_jeqibe;\n+      case 22 : itype = BPFBF_EBPFBE_INSN_JEQ32IBE; goto extract_sfmt_jeqibe;\n+      case 23 : itype = BPFBF_EBPFBE_INSN_SUBIBE; goto extract_sfmt_addibe;\n+      case 24 : itype = BPFBF_EBPFBE_INSN_LDDWBE; goto extract_sfmt_lddwbe;\n+      case 28 : itype = BPFBF_EBPFBE_INSN_SUB32RBE; goto extract_sfmt_addrbe;\n+      case 29 : itype = BPFBF_EBPFBE_INSN_JEQRBE; goto extract_sfmt_jeqrbe;\n+      case 30 : itype = BPFBF_EBPFBE_INSN_JEQ32RBE; goto extract_sfmt_jeqrbe;\n+      case 31 : itype = BPFBF_EBPFBE_INSN_SUBRBE; goto extract_sfmt_addrbe;\n+      case 32 : itype = BPFBF_EBPFBE_INSN_LDABSW; goto extract_sfmt_ldabsw;\n+      case 36 : itype = BPFBF_EBPFBE_INSN_MUL32IBE; goto extract_sfmt_addibe;\n+      case 37 : itype = BPFBF_EBPFBE_INSN_JGTIBE; goto extract_sfmt_jeqibe;\n+      case 38 : itype = BPFBF_EBPFBE_INSN_JGT32IBE; goto extract_sfmt_jeqibe;\n+      case 39 : itype = BPFBF_EBPFBE_INSN_MULIBE; goto extract_sfmt_addibe;\n+      case 40 : itype = BPFBF_EBPFBE_INSN_LDABSH; goto extract_sfmt_ldabsh;\n+      case 44 : itype = BPFBF_EBPFBE_INSN_MUL32RBE; goto extract_sfmt_addrbe;\n+      case 45 : itype = BPFBF_EBPFBE_INSN_JGTRBE; goto extract_sfmt_jeqrbe;\n+      case 46 : itype = BPFBF_EBPFBE_INSN_JGT32RBE; goto extract_sfmt_jeqrbe;\n+      case 47 : itype = BPFBF_EBPFBE_INSN_MULRBE; goto extract_sfmt_addrbe;\n+      case 48 : itype = BPFBF_EBPFBE_INSN_LDABSB; goto extract_sfmt_ldabsb;\n+      case 52 : itype = BPFBF_EBPFBE_INSN_DIV32IBE; goto extract_sfmt_addibe;\n+      case 53 : itype = BPFBF_EBPFBE_INSN_JGEIBE; goto extract_sfmt_jeqibe;\n+      case 54 : itype = BPFBF_EBPFBE_INSN_JGE32IBE; goto extract_sfmt_jeqibe;\n+      case 55 : itype = BPFBF_EBPFBE_INSN_DIVIBE; goto extract_sfmt_addibe;\n+      case 56 : itype = BPFBF_EBPFBE_INSN_LDABSDW; goto extract_sfmt_ldabsdw;\n+      case 60 : itype = BPFBF_EBPFBE_INSN_DIV32RBE; goto extract_sfmt_addrbe;\n+      case 61 : itype = BPFBF_EBPFBE_INSN_JGERBE; goto extract_sfmt_jeqrbe;\n+      case 62 : itype = BPFBF_EBPFBE_INSN_JGE32RBE; goto extract_sfmt_jeqrbe;\n+      case 63 : itype = BPFBF_EBPFBE_INSN_DIVRBE; goto extract_sfmt_addrbe;\n+      case 64 : itype = BPFBF_EBPFBE_INSN_LDINDWBE; goto extract_sfmt_ldindwbe;\n+      case 68 : itype = BPFBF_EBPFBE_INSN_OR32IBE; goto extract_sfmt_addibe;\n+      case 69 : itype = BPFBF_EBPFBE_INSN_JSETIBE; goto extract_sfmt_jeqibe;\n+      case 70 : itype = BPFBF_EBPFBE_INSN_JSET32IBE; goto extract_sfmt_jeqibe;\n+      case 71 : itype = BPFBF_EBPFBE_INSN_ORIBE; goto extract_sfmt_addibe;\n+      case 72 : itype = BPFBF_EBPFBE_INSN_LDINDHBE; goto extract_sfmt_ldindhbe;\n+      case 76 : itype = BPFBF_EBPFBE_INSN_OR32RBE; goto extract_sfmt_addrbe;\n+      case 77 : itype = BPFBF_EBPFBE_INSN_JSETRBE; goto extract_sfmt_jeqrbe;\n+      case 78 : itype = BPFBF_EBPFBE_INSN_JSET32RBE; goto extract_sfmt_jeqrbe;\n+      case 79 : itype = BPFBF_EBPFBE_INSN_ORRBE; goto extract_sfmt_addrbe;\n+      case 80 : itype = BPFBF_EBPFBE_INSN_LDINDBBE; goto extract_sfmt_ldindbbe;\n+      case 84 : itype = BPFBF_EBPFBE_INSN_AND32IBE; goto extract_sfmt_addibe;\n+      case 85 : itype = BPFBF_EBPFBE_INSN_JNEIBE; goto extract_sfmt_jeqibe;\n+      case 86 : itype = BPFBF_EBPFBE_INSN_JNE32IBE; goto extract_sfmt_jeqibe;\n+      case 87 : itype = BPFBF_EBPFBE_INSN_ANDIBE; goto extract_sfmt_addibe;\n+      case 88 : itype = BPFBF_EBPFBE_INSN_LDINDDWBE; goto extract_sfmt_ldinddwbe;\n+      case 92 : itype = BPFBF_EBPFBE_INSN_AND32RBE; goto extract_sfmt_addrbe;\n+      case 93 : itype = BPFBF_EBPFBE_INSN_JNERBE; goto extract_sfmt_jeqrbe;\n+      case 94 : itype = BPFBF_EBPFBE_INSN_JNE32RBE; goto extract_sfmt_jeqrbe;\n+      case 95 : itype = BPFBF_EBPFBE_INSN_ANDRBE; goto extract_sfmt_addrbe;\n+      case 97 : itype = BPFBF_EBPFBE_INSN_LDXWBE; goto extract_sfmt_ldxwbe;\n+      case 98 : itype = BPFBF_EBPFBE_INSN_STWBE; goto extract_sfmt_stwbe;\n+      case 99 : itype = BPFBF_EBPFBE_INSN_STXWBE; goto extract_sfmt_stxwbe;\n+      case 100 : itype = BPFBF_EBPFBE_INSN_LSH32IBE; goto extract_sfmt_addibe;\n+      case 101 : itype = BPFBF_EBPFBE_INSN_JSGTIBE; goto extract_sfmt_jeqibe;\n+      case 102 : itype = BPFBF_EBPFBE_INSN_JSGT32IBE; goto extract_sfmt_jeqibe;\n+      case 103 : itype = BPFBF_EBPFBE_INSN_LSHIBE; goto extract_sfmt_addibe;\n+      case 105 : itype = BPFBF_EBPFBE_INSN_LDXHBE; goto extract_sfmt_ldxhbe;\n+      case 106 : itype = BPFBF_EBPFBE_INSN_STHBE; goto extract_sfmt_sthbe;\n+      case 107 : itype = BPFBF_EBPFBE_INSN_STXHBE; goto extract_sfmt_stxhbe;\n+      case 108 : itype = BPFBF_EBPFBE_INSN_LSH32RBE; goto extract_sfmt_addrbe;\n+      case 109 : itype = BPFBF_EBPFBE_INSN_JSGTRBE; goto extract_sfmt_jeqrbe;\n+      case 110 : itype = BPFBF_EBPFBE_INSN_JSGT32RBE; goto extract_sfmt_jeqrbe;\n+      case 111 : itype = BPFBF_EBPFBE_INSN_LSHRBE; goto extract_sfmt_addrbe;\n+      case 113 : itype = BPFBF_EBPFBE_INSN_LDXBBE; goto extract_sfmt_ldxbbe;\n+      case 114 : itype = BPFBF_EBPFBE_INSN_STBBE; goto extract_sfmt_stbbe;\n+      case 115 : itype = BPFBF_EBPFBE_INSN_STXBBE; goto extract_sfmt_stxbbe;\n+      case 116 : itype = BPFBF_EBPFBE_INSN_RSH32IBE; goto extract_sfmt_addibe;\n+      case 117 : itype = BPFBF_EBPFBE_INSN_JSGEIBE; goto extract_sfmt_jeqibe;\n+      case 118 : itype = BPFBF_EBPFBE_INSN_JSGE32IBE; goto extract_sfmt_jeqibe;\n+      case 119 : itype = BPFBF_EBPFBE_INSN_RSHIBE; goto extract_sfmt_addibe;\n+      case 121 : itype = BPFBF_EBPFBE_INSN_LDXDWBE; goto extract_sfmt_ldxdwbe;\n+      case 122 : itype = BPFBF_EBPFBE_INSN_STDWBE; goto extract_sfmt_stdwbe;\n+      case 123 : itype = BPFBF_EBPFBE_INSN_STXDWBE; goto extract_sfmt_stxdwbe;\n+      case 124 : itype = BPFBF_EBPFBE_INSN_RSH32RBE; goto extract_sfmt_addrbe;\n+      case 125 : itype = BPFBF_EBPFBE_INSN_JSGERBE; goto extract_sfmt_jeqrbe;\n+      case 126 : itype = BPFBF_EBPFBE_INSN_JSGE32RBE; goto extract_sfmt_jeqrbe;\n+      case 127 : itype = BPFBF_EBPFBE_INSN_RSHRBE; goto extract_sfmt_addrbe;\n+      case 132 : itype = BPFBF_EBPFBE_INSN_NEG32BE; goto extract_sfmt_negbe;\n+      case 133 : itype = BPFBF_EBPFBE_INSN_CALLBE; goto extract_sfmt_callbe;\n+      case 135 : itype = BPFBF_EBPFBE_INSN_NEGBE; goto extract_sfmt_negbe;\n+      case 140 : itype = BPFBF_EBPFBE_INSN_BRKPT; goto extract_sfmt_exit;\n+      case 148 : itype = BPFBF_EBPFBE_INSN_MOD32IBE; goto extract_sfmt_addibe;\n+      case 149 : itype = BPFBF_EBPFBE_INSN_EXIT; goto extract_sfmt_exit;\n+      case 151 : itype = BPFBF_EBPFBE_INSN_MODIBE; goto extract_sfmt_addibe;\n+      case 156 : itype = BPFBF_EBPFBE_INSN_MOD32RBE; goto extract_sfmt_addrbe;\n+      case 159 : itype = BPFBF_EBPFBE_INSN_MODRBE; goto extract_sfmt_addrbe;\n+      case 164 : itype = BPFBF_EBPFBE_INSN_XOR32IBE; goto extract_sfmt_addibe;\n+      case 165 : itype = BPFBF_EBPFBE_INSN_JLTIBE; goto extract_sfmt_jeqibe;\n+      case 166 : itype = BPFBF_EBPFBE_INSN_JLT32IBE; goto extract_sfmt_jeqibe;\n+      case 167 : itype = BPFBF_EBPFBE_INSN_XORIBE; goto extract_sfmt_addibe;\n+      case 172 : itype = BPFBF_EBPFBE_INSN_XOR32RBE; goto extract_sfmt_addrbe;\n+      case 173 : itype = BPFBF_EBPFBE_INSN_JLTRBE; goto extract_sfmt_jeqrbe;\n+      case 174 : itype = BPFBF_EBPFBE_INSN_JLT32RBE; goto extract_sfmt_jeqrbe;\n+      case 175 : itype = BPFBF_EBPFBE_INSN_XORRBE; goto extract_sfmt_addrbe;\n+      case 180 : itype = BPFBF_EBPFBE_INSN_MOV32IBE; goto extract_sfmt_movibe;\n+      case 181 : itype = BPFBF_EBPFBE_INSN_JLEIBE; goto extract_sfmt_jeqibe;\n+      case 182 : itype = BPFBF_EBPFBE_INSN_JLE32IBE; goto extract_sfmt_jeqibe;\n+      case 183 : itype = BPFBF_EBPFBE_INSN_MOVIBE; goto extract_sfmt_movibe;\n+      case 188 : itype = BPFBF_EBPFBE_INSN_MOV32RBE; goto extract_sfmt_movrbe;\n+      case 189 : itype = BPFBF_EBPFBE_INSN_JLERBE; goto extract_sfmt_jeqrbe;\n+      case 190 : itype = BPFBF_EBPFBE_INSN_JLE32RBE; goto extract_sfmt_jeqrbe;\n+      case 191 : itype = BPFBF_EBPFBE_INSN_MOVRBE; goto extract_sfmt_movrbe;\n+      case 195 : itype = BPFBF_EBPFBE_INSN_XADDWBE; goto extract_sfmt_xaddwbe;\n+      case 196 : itype = BPFBF_EBPFBE_INSN_ARSH32IBE; goto extract_sfmt_addibe;\n+      case 197 : itype = BPFBF_EBPFBE_INSN_JSLTIBE; goto extract_sfmt_jeqibe;\n+      case 198 : itype = BPFBF_EBPFBE_INSN_JSLT32IBE; goto extract_sfmt_jeqibe;\n+      case 199 : itype = BPFBF_EBPFBE_INSN_ARSHIBE; goto extract_sfmt_addibe;\n+      case 204 : itype = BPFBF_EBPFBE_INSN_ARSH32RBE; goto extract_sfmt_addrbe;\n+      case 205 : itype = BPFBF_EBPFBE_INSN_JSLTRBE; goto extract_sfmt_jeqrbe;\n+      case 206 : itype = BPFBF_EBPFBE_INSN_JSLT32RBE; goto extract_sfmt_jeqrbe;\n+      case 207 : itype = BPFBF_EBPFBE_INSN_ARSHRBE; goto extract_sfmt_addrbe;\n+      case 212 : itype = BPFBF_EBPFBE_INSN_ENDLEBE; goto extract_sfmt_endlebe;\n+      case 213 : itype = BPFBF_EBPFBE_INSN_JSLEIBE; goto extract_sfmt_jeqibe;\n+      case 214 : itype = BPFBF_EBPFBE_INSN_JSLE32IBE; goto extract_sfmt_jeqibe;\n+      case 219 : itype = BPFBF_EBPFBE_INSN_XADDDWBE; goto extract_sfmt_xadddwbe;\n+      case 220 : itype = BPFBF_EBPFBE_INSN_ENDBEBE; goto extract_sfmt_endlebe;\n+      case 221 : itype = BPFBF_EBPFBE_INSN_JSLERBE; goto extract_sfmt_jeqrbe;\n+      case 222 : itype = BPFBF_EBPFBE_INSN_JSLE32RBE; goto extract_sfmt_jeqrbe;\n+      default : itype = BPFBF_EBPFBE_INSN_X_INVALID; goto extract_sfmt_empty;\n+      }\n+    }\n+  }\n+\n+  /* The instruction has been decoded, now extract the fields.  */\n+\n+ extract_sfmt_empty:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+#define FLD(f) abuf->fields.sfmt_empty.f\n+\n+\n+  /* Record the fields for the semantic handler.  */\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_empty\", (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_addibe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    INT f_imm32;\n+    UINT f_dstbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_addibe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_addrbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_addrbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_negbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_lddwbe.f\n+    UINT f_dstbe;\n+\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_negbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_movibe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    INT f_imm32;\n+    UINT f_dstbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_dstbe) = f_dstbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_movibe\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_dstbe 0x%x\", 'x', f_dstbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_movrbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_srcbe) = f_srcbe;\n+  FLD (f_dstbe) = f_dstbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_movrbe\", \"f_srcbe 0x%x\", 'x', f_srcbe, \"f_dstbe 0x%x\", 'x', f_dstbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_endlebe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    INT f_imm32;\n+    UINT f_dstbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_endlebe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_lddwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_lddwbe.f\n+    UINT f_imm64_c;\n+    UINT f_imm64_b;\n+    UINT f_imm64_a;\n+    UINT f_dstbe;\n+    DI f_imm64;\n+    /* Contents of trailing part of insn.  */\n+    UINT word_1;\n+    UINT word_2;\n+\n+  word_1 = GETIMEMUSI (current_cpu, pc + 8);\n+  word_2 = GETIMEMUSI (current_cpu, pc + 12);\n+    f_imm64_c = (0|(EXTRACT_LSB0_UINT (word_2, 32, 31, 32) << 0));\n+    f_imm64_b = (0|(EXTRACT_LSB0_UINT (word_1, 32, 31, 32) << 0));\n+    f_imm64_a = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+{\n+  f_imm64 = ((((((UDI) (UINT) (f_imm64_c))) << (32))) | (((UDI) (UINT) (f_imm64_a))));\n+}\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm64) = f_imm64;\n+  FLD (f_dstbe) = f_dstbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_lddwbe\", \"f_imm64 0x%x\", 'x', f_imm64, \"f_dstbe 0x%x\", 'x', f_dstbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldabsw:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldabsw\", \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldabsh:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldabsh\", \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldabsb:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldabsb\", \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldabsdw:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldabsdw\", \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldindwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+    UINT f_srcbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldindwbe\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldindhbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+    UINT f_srcbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldindhbe\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldindbbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+    UINT f_srcbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldindbbe\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldinddwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+    UINT f_srcbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldinddwbe\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldxwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  FLD (f_dstbe) = f_dstbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldxwbe\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, \"f_dstbe 0x%x\", 'x', f_dstbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldxhbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  FLD (f_dstbe) = f_dstbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldxhbe\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, \"f_dstbe 0x%x\", 'x', f_dstbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldxbbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  FLD (f_dstbe) = f_dstbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldxbbe\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, \"f_dstbe 0x%x\", 'x', f_dstbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldxdwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  FLD (f_dstbe) = f_dstbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldxdwbe\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, \"f_dstbe 0x%x\", 'x', f_dstbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stxwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stxwbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stxhbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stxhbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stxbbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stxbbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stxdwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stxdwbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stbbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stbbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_imm32 0x%x\", 'x', f_imm32, \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_sthbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_sthbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_imm32 0x%x\", 'x', f_imm32, \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stwbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_imm32 0x%x\", 'x', f_imm32, \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stdwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stdwbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_imm32 0x%x\", 'x', f_imm32, \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_jeqibe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_jeqibe\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#if WITH_PROFILE_MODEL_P\n+  /* Record the fields for profiling.  */\n+  if (PROFILE_MODEL_P (current_cpu))\n+    {\n+    }\n+#endif\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_jeqrbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_jeqrbe\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#if WITH_PROFILE_MODEL_P\n+  /* Record the fields for profiling.  */\n+  if (PROFILE_MODEL_P (current_cpu))\n+    {\n+    }\n+#endif\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_callbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwbe.f\n+    INT f_imm32;\n+    UINT f_srcbe;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_callbe\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ja:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stbbe.f\n+    HI f_offset16;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ja\", \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#if WITH_PROFILE_MODEL_P\n+  /* Record the fields for profiling.  */\n+  if (PROFILE_MODEL_P (current_cpu))\n+    {\n+    }\n+#endif\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_exit:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+#define FLD(f) abuf->fields.sfmt_empty.f\n+\n+\n+  /* Record the fields for the semantic handler.  */\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_exit\", (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_xadddwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_xadddwbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_xaddwbe:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfbe_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwbe.f\n+    HI f_offset16;\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstbe) = f_dstbe;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcbe) = f_srcbe;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_xaddwbe\", \"f_dstbe 0x%x\", 'x', f_dstbe, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcbe 0x%x\", 'x', f_srcbe, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+}"
    },
    {
      "sha": "431d7c605c8aec2d55a5ae782d42510263249f20",
      "filename": "sim/bpf/decode-be.h",
      "status": "added",
      "additions": 94,
      "deletions": 0,
      "changes": 94,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/decode-be.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/decode-be.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/decode-be.h?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,94 @@\n+/* Decode header for bpfbf_ebpfbe.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef BPFBF_EBPFBE_DECODE_H\n+#define BPFBF_EBPFBE_DECODE_H\n+\n+extern const IDESC *bpfbf_ebpfbe_decode (SIM_CPU *, IADDR,\n+                                  CGEN_INSN_WORD,\n+                                  ARGBUF *);\n+extern void bpfbf_ebpfbe_init_idesc_table (SIM_CPU *);\n+extern void bpfbf_ebpfbe_sem_init_idesc_table (SIM_CPU *);\n+extern void bpfbf_ebpfbe_semf_init_idesc_table (SIM_CPU *);\n+\n+/* Enum declaration for instructions in cpu family bpfbf.  */\n+typedef enum bpfbf_ebpfbe_insn_type {\n+  BPFBF_EBPFBE_INSN_X_INVALID, BPFBF_EBPFBE_INSN_X_AFTER, BPFBF_EBPFBE_INSN_X_BEFORE, BPFBF_EBPFBE_INSN_X_CTI_CHAIN\n+ , BPFBF_EBPFBE_INSN_X_CHAIN, BPFBF_EBPFBE_INSN_X_BEGIN, BPFBF_EBPFBE_INSN_ADDIBE, BPFBF_EBPFBE_INSN_ADDRBE\n+ , BPFBF_EBPFBE_INSN_ADD32IBE, BPFBF_EBPFBE_INSN_ADD32RBE, BPFBF_EBPFBE_INSN_SUBIBE, BPFBF_EBPFBE_INSN_SUBRBE\n+ , BPFBF_EBPFBE_INSN_SUB32IBE, BPFBF_EBPFBE_INSN_SUB32RBE, BPFBF_EBPFBE_INSN_MULIBE, BPFBF_EBPFBE_INSN_MULRBE\n+ , BPFBF_EBPFBE_INSN_MUL32IBE, BPFBF_EBPFBE_INSN_MUL32RBE, BPFBF_EBPFBE_INSN_DIVIBE, BPFBF_EBPFBE_INSN_DIVRBE\n+ , BPFBF_EBPFBE_INSN_DIV32IBE, BPFBF_EBPFBE_INSN_DIV32RBE, BPFBF_EBPFBE_INSN_ORIBE, BPFBF_EBPFBE_INSN_ORRBE\n+ , BPFBF_EBPFBE_INSN_OR32IBE, BPFBF_EBPFBE_INSN_OR32RBE, BPFBF_EBPFBE_INSN_ANDIBE, BPFBF_EBPFBE_INSN_ANDRBE\n+ , BPFBF_EBPFBE_INSN_AND32IBE, BPFBF_EBPFBE_INSN_AND32RBE, BPFBF_EBPFBE_INSN_LSHIBE, BPFBF_EBPFBE_INSN_LSHRBE\n+ , BPFBF_EBPFBE_INSN_LSH32IBE, BPFBF_EBPFBE_INSN_LSH32RBE, BPFBF_EBPFBE_INSN_RSHIBE, BPFBF_EBPFBE_INSN_RSHRBE\n+ , BPFBF_EBPFBE_INSN_RSH32IBE, BPFBF_EBPFBE_INSN_RSH32RBE, BPFBF_EBPFBE_INSN_MODIBE, BPFBF_EBPFBE_INSN_MODRBE\n+ , BPFBF_EBPFBE_INSN_MOD32IBE, BPFBF_EBPFBE_INSN_MOD32RBE, BPFBF_EBPFBE_INSN_XORIBE, BPFBF_EBPFBE_INSN_XORRBE\n+ , BPFBF_EBPFBE_INSN_XOR32IBE, BPFBF_EBPFBE_INSN_XOR32RBE, BPFBF_EBPFBE_INSN_ARSHIBE, BPFBF_EBPFBE_INSN_ARSHRBE\n+ , BPFBF_EBPFBE_INSN_ARSH32IBE, BPFBF_EBPFBE_INSN_ARSH32RBE, BPFBF_EBPFBE_INSN_NEGBE, BPFBF_EBPFBE_INSN_NEG32BE\n+ , BPFBF_EBPFBE_INSN_MOVIBE, BPFBF_EBPFBE_INSN_MOVRBE, BPFBF_EBPFBE_INSN_MOV32IBE, BPFBF_EBPFBE_INSN_MOV32RBE\n+ , BPFBF_EBPFBE_INSN_ENDLEBE, BPFBF_EBPFBE_INSN_ENDBEBE, BPFBF_EBPFBE_INSN_LDDWBE, BPFBF_EBPFBE_INSN_LDABSW\n+ , BPFBF_EBPFBE_INSN_LDABSH, BPFBF_EBPFBE_INSN_LDABSB, BPFBF_EBPFBE_INSN_LDABSDW, BPFBF_EBPFBE_INSN_LDINDWBE\n+ , BPFBF_EBPFBE_INSN_LDINDHBE, BPFBF_EBPFBE_INSN_LDINDBBE, BPFBF_EBPFBE_INSN_LDINDDWBE, BPFBF_EBPFBE_INSN_LDXWBE\n+ , BPFBF_EBPFBE_INSN_LDXHBE, BPFBF_EBPFBE_INSN_LDXBBE, BPFBF_EBPFBE_INSN_LDXDWBE, BPFBF_EBPFBE_INSN_STXWBE\n+ , BPFBF_EBPFBE_INSN_STXHBE, BPFBF_EBPFBE_INSN_STXBBE, BPFBF_EBPFBE_INSN_STXDWBE, BPFBF_EBPFBE_INSN_STBBE\n+ , BPFBF_EBPFBE_INSN_STHBE, BPFBF_EBPFBE_INSN_STWBE, BPFBF_EBPFBE_INSN_STDWBE, BPFBF_EBPFBE_INSN_JEQIBE\n+ , BPFBF_EBPFBE_INSN_JEQRBE, BPFBF_EBPFBE_INSN_JEQ32IBE, BPFBF_EBPFBE_INSN_JEQ32RBE, BPFBF_EBPFBE_INSN_JGTIBE\n+ , BPFBF_EBPFBE_INSN_JGTRBE, BPFBF_EBPFBE_INSN_JGT32IBE, BPFBF_EBPFBE_INSN_JGT32RBE, BPFBF_EBPFBE_INSN_JGEIBE\n+ , BPFBF_EBPFBE_INSN_JGERBE, BPFBF_EBPFBE_INSN_JGE32IBE, BPFBF_EBPFBE_INSN_JGE32RBE, BPFBF_EBPFBE_INSN_JLTIBE\n+ , BPFBF_EBPFBE_INSN_JLTRBE, BPFBF_EBPFBE_INSN_JLT32IBE, BPFBF_EBPFBE_INSN_JLT32RBE, BPFBF_EBPFBE_INSN_JLEIBE\n+ , BPFBF_EBPFBE_INSN_JLERBE, BPFBF_EBPFBE_INSN_JLE32IBE, BPFBF_EBPFBE_INSN_JLE32RBE, BPFBF_EBPFBE_INSN_JSETIBE\n+ , BPFBF_EBPFBE_INSN_JSETRBE, BPFBF_EBPFBE_INSN_JSET32IBE, BPFBF_EBPFBE_INSN_JSET32RBE, BPFBF_EBPFBE_INSN_JNEIBE\n+ , BPFBF_EBPFBE_INSN_JNERBE, BPFBF_EBPFBE_INSN_JNE32IBE, BPFBF_EBPFBE_INSN_JNE32RBE, BPFBF_EBPFBE_INSN_JSGTIBE\n+ , BPFBF_EBPFBE_INSN_JSGTRBE, BPFBF_EBPFBE_INSN_JSGT32IBE, BPFBF_EBPFBE_INSN_JSGT32RBE, BPFBF_EBPFBE_INSN_JSGEIBE\n+ , BPFBF_EBPFBE_INSN_JSGERBE, BPFBF_EBPFBE_INSN_JSGE32IBE, BPFBF_EBPFBE_INSN_JSGE32RBE, BPFBF_EBPFBE_INSN_JSLTIBE\n+ , BPFBF_EBPFBE_INSN_JSLTRBE, BPFBF_EBPFBE_INSN_JSLT32IBE, BPFBF_EBPFBE_INSN_JSLT32RBE, BPFBF_EBPFBE_INSN_JSLEIBE\n+ , BPFBF_EBPFBE_INSN_JSLERBE, BPFBF_EBPFBE_INSN_JSLE32IBE, BPFBF_EBPFBE_INSN_JSLE32RBE, BPFBF_EBPFBE_INSN_CALLBE\n+ , BPFBF_EBPFBE_INSN_JA, BPFBF_EBPFBE_INSN_EXIT, BPFBF_EBPFBE_INSN_XADDDWBE, BPFBF_EBPFBE_INSN_XADDWBE\n+ , BPFBF_EBPFBE_INSN_BRKPT, BPFBF_EBPFBE_INSN__MAX\n+} BPFBF_EBPFBE_INSN_TYPE;\n+\n+/* Enum declaration for semantic formats in cpu family bpfbf.  */\n+typedef enum bpfbf_ebpfbe_sfmt_type {\n+  BPFBF_EBPFBE_SFMT_EMPTY, BPFBF_EBPFBE_SFMT_ADDIBE, BPFBF_EBPFBE_SFMT_ADDRBE, BPFBF_EBPFBE_SFMT_NEGBE\n+ , BPFBF_EBPFBE_SFMT_MOVIBE, BPFBF_EBPFBE_SFMT_MOVRBE, BPFBF_EBPFBE_SFMT_ENDLEBE, BPFBF_EBPFBE_SFMT_LDDWBE\n+ , BPFBF_EBPFBE_SFMT_LDABSW, BPFBF_EBPFBE_SFMT_LDABSH, BPFBF_EBPFBE_SFMT_LDABSB, BPFBF_EBPFBE_SFMT_LDABSDW\n+ , BPFBF_EBPFBE_SFMT_LDINDWBE, BPFBF_EBPFBE_SFMT_LDINDHBE, BPFBF_EBPFBE_SFMT_LDINDBBE, BPFBF_EBPFBE_SFMT_LDINDDWBE\n+ , BPFBF_EBPFBE_SFMT_LDXWBE, BPFBF_EBPFBE_SFMT_LDXHBE, BPFBF_EBPFBE_SFMT_LDXBBE, BPFBF_EBPFBE_SFMT_LDXDWBE\n+ , BPFBF_EBPFBE_SFMT_STXWBE, BPFBF_EBPFBE_SFMT_STXHBE, BPFBF_EBPFBE_SFMT_STXBBE, BPFBF_EBPFBE_SFMT_STXDWBE\n+ , BPFBF_EBPFBE_SFMT_STBBE, BPFBF_EBPFBE_SFMT_STHBE, BPFBF_EBPFBE_SFMT_STWBE, BPFBF_EBPFBE_SFMT_STDWBE\n+ , BPFBF_EBPFBE_SFMT_JEQIBE, BPFBF_EBPFBE_SFMT_JEQRBE, BPFBF_EBPFBE_SFMT_CALLBE, BPFBF_EBPFBE_SFMT_JA\n+ , BPFBF_EBPFBE_SFMT_EXIT, BPFBF_EBPFBE_SFMT_XADDDWBE, BPFBF_EBPFBE_SFMT_XADDWBE\n+} BPFBF_EBPFBE_SFMT_TYPE;\n+\n+/* Function unit handlers (user written).  */\n+\n+extern int bpfbf_model_bpf_def_u_exec (SIM_CPU *, const IDESC *, int /*unit_num*/, int /*referenced*/);\n+\n+/* Profiling before/after handlers (user written) */\n+\n+extern void bpfbf_model_insn_before (SIM_CPU *, int /*first_p*/);\n+extern void bpfbf_model_insn_after (SIM_CPU *, int /*last_p*/, int /*cycles*/);\n+\n+#endif /* BPFBF_EBPFBE_DECODE_H */"
    },
    {
      "sha": "8181485e4c7273c4c63d1f9ae1bc8bfb1ac92de8",
      "filename": "sim/bpf/decode-le.c",
      "status": "added",
      "additions": 1129,
      "deletions": 0,
      "changes": 1129,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/decode-le.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/decode-le.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/decode-le.c?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,1129 @@\n+/* Simulator instruction decoder for bpfbf_ebpfle.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#define WANT_CPU bpfbf\n+#define WANT_CPU_BPFBF\n+\n+#include \"sim-main.h\"\n+#include \"sim-assert.h\"\n+\n+/* The instruction descriptor array.\n+   This is computed at runtime.  Space for it is not malloc'd to save a\n+   teensy bit of cpu in the decoder.  Moving it to malloc space is trivial\n+   but won't be done until necessary (we don't currently support the runtime\n+   addition of instructions nor an SMP machine with different cpus).  */\n+static IDESC bpfbf_ebpfle_insn_data[BPFBF_EBPFLE_INSN__MAX];\n+\n+/* Commas between elements are contained in the macros.\n+   Some of these are conditionally compiled out.  */\n+\n+static const struct insn_sem bpfbf_ebpfle_insn_sem[] =\n+{\n+  { VIRTUAL_INSN_X_INVALID, BPFBF_EBPFLE_INSN_X_INVALID, BPFBF_EBPFLE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_AFTER, BPFBF_EBPFLE_INSN_X_AFTER, BPFBF_EBPFLE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_BEFORE, BPFBF_EBPFLE_INSN_X_BEFORE, BPFBF_EBPFLE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_CTI_CHAIN, BPFBF_EBPFLE_INSN_X_CTI_CHAIN, BPFBF_EBPFLE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_CHAIN, BPFBF_EBPFLE_INSN_X_CHAIN, BPFBF_EBPFLE_SFMT_EMPTY },\n+  { VIRTUAL_INSN_X_BEGIN, BPFBF_EBPFLE_INSN_X_BEGIN, BPFBF_EBPFLE_SFMT_EMPTY },\n+  { BPF_INSN_ADDILE, BPFBF_EBPFLE_INSN_ADDILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_ADDRLE, BPFBF_EBPFLE_INSN_ADDRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_ADD32ILE, BPFBF_EBPFLE_INSN_ADD32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_ADD32RLE, BPFBF_EBPFLE_INSN_ADD32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_SUBILE, BPFBF_EBPFLE_INSN_SUBILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_SUBRLE, BPFBF_EBPFLE_INSN_SUBRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_SUB32ILE, BPFBF_EBPFLE_INSN_SUB32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_SUB32RLE, BPFBF_EBPFLE_INSN_SUB32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_MULILE, BPFBF_EBPFLE_INSN_MULILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_MULRLE, BPFBF_EBPFLE_INSN_MULRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_MUL32ILE, BPFBF_EBPFLE_INSN_MUL32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_MUL32RLE, BPFBF_EBPFLE_INSN_MUL32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_DIVILE, BPFBF_EBPFLE_INSN_DIVILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_DIVRLE, BPFBF_EBPFLE_INSN_DIVRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_DIV32ILE, BPFBF_EBPFLE_INSN_DIV32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_DIV32RLE, BPFBF_EBPFLE_INSN_DIV32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_ORILE, BPFBF_EBPFLE_INSN_ORILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_ORRLE, BPFBF_EBPFLE_INSN_ORRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_OR32ILE, BPFBF_EBPFLE_INSN_OR32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_OR32RLE, BPFBF_EBPFLE_INSN_OR32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_ANDILE, BPFBF_EBPFLE_INSN_ANDILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_ANDRLE, BPFBF_EBPFLE_INSN_ANDRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_AND32ILE, BPFBF_EBPFLE_INSN_AND32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_AND32RLE, BPFBF_EBPFLE_INSN_AND32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_LSHILE, BPFBF_EBPFLE_INSN_LSHILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_LSHRLE, BPFBF_EBPFLE_INSN_LSHRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_LSH32ILE, BPFBF_EBPFLE_INSN_LSH32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_LSH32RLE, BPFBF_EBPFLE_INSN_LSH32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_RSHILE, BPFBF_EBPFLE_INSN_RSHILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_RSHRLE, BPFBF_EBPFLE_INSN_RSHRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_RSH32ILE, BPFBF_EBPFLE_INSN_RSH32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_RSH32RLE, BPFBF_EBPFLE_INSN_RSH32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_MODILE, BPFBF_EBPFLE_INSN_MODILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_MODRLE, BPFBF_EBPFLE_INSN_MODRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_MOD32ILE, BPFBF_EBPFLE_INSN_MOD32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_MOD32RLE, BPFBF_EBPFLE_INSN_MOD32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_XORILE, BPFBF_EBPFLE_INSN_XORILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_XORRLE, BPFBF_EBPFLE_INSN_XORRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_XOR32ILE, BPFBF_EBPFLE_INSN_XOR32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_XOR32RLE, BPFBF_EBPFLE_INSN_XOR32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_ARSHILE, BPFBF_EBPFLE_INSN_ARSHILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_ARSHRLE, BPFBF_EBPFLE_INSN_ARSHRLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_ARSH32ILE, BPFBF_EBPFLE_INSN_ARSH32ILE, BPFBF_EBPFLE_SFMT_ADDILE },\n+  { BPF_INSN_ARSH32RLE, BPFBF_EBPFLE_INSN_ARSH32RLE, BPFBF_EBPFLE_SFMT_ADDRLE },\n+  { BPF_INSN_NEGLE, BPFBF_EBPFLE_INSN_NEGLE, BPFBF_EBPFLE_SFMT_NEGLE },\n+  { BPF_INSN_NEG32LE, BPFBF_EBPFLE_INSN_NEG32LE, BPFBF_EBPFLE_SFMT_NEGLE },\n+  { BPF_INSN_MOVILE, BPFBF_EBPFLE_INSN_MOVILE, BPFBF_EBPFLE_SFMT_MOVILE },\n+  { BPF_INSN_MOVRLE, BPFBF_EBPFLE_INSN_MOVRLE, BPFBF_EBPFLE_SFMT_MOVRLE },\n+  { BPF_INSN_MOV32ILE, BPFBF_EBPFLE_INSN_MOV32ILE, BPFBF_EBPFLE_SFMT_MOVILE },\n+  { BPF_INSN_MOV32RLE, BPFBF_EBPFLE_INSN_MOV32RLE, BPFBF_EBPFLE_SFMT_MOVRLE },\n+  { BPF_INSN_ENDLELE, BPFBF_EBPFLE_INSN_ENDLELE, BPFBF_EBPFLE_SFMT_ENDLELE },\n+  { BPF_INSN_ENDBELE, BPFBF_EBPFLE_INSN_ENDBELE, BPFBF_EBPFLE_SFMT_ENDLELE },\n+  { BPF_INSN_LDDWLE, BPFBF_EBPFLE_INSN_LDDWLE, BPFBF_EBPFLE_SFMT_LDDWLE },\n+  { BPF_INSN_LDABSW, BPFBF_EBPFLE_INSN_LDABSW, BPFBF_EBPFLE_SFMT_LDABSW },\n+  { BPF_INSN_LDABSH, BPFBF_EBPFLE_INSN_LDABSH, BPFBF_EBPFLE_SFMT_LDABSH },\n+  { BPF_INSN_LDABSB, BPFBF_EBPFLE_INSN_LDABSB, BPFBF_EBPFLE_SFMT_LDABSB },\n+  { BPF_INSN_LDABSDW, BPFBF_EBPFLE_INSN_LDABSDW, BPFBF_EBPFLE_SFMT_LDABSDW },\n+  { BPF_INSN_LDINDWLE, BPFBF_EBPFLE_INSN_LDINDWLE, BPFBF_EBPFLE_SFMT_LDINDWLE },\n+  { BPF_INSN_LDINDHLE, BPFBF_EBPFLE_INSN_LDINDHLE, BPFBF_EBPFLE_SFMT_LDINDHLE },\n+  { BPF_INSN_LDINDBLE, BPFBF_EBPFLE_INSN_LDINDBLE, BPFBF_EBPFLE_SFMT_LDINDBLE },\n+  { BPF_INSN_LDINDDWLE, BPFBF_EBPFLE_INSN_LDINDDWLE, BPFBF_EBPFLE_SFMT_LDINDDWLE },\n+  { BPF_INSN_LDXWLE, BPFBF_EBPFLE_INSN_LDXWLE, BPFBF_EBPFLE_SFMT_LDXWLE },\n+  { BPF_INSN_LDXHLE, BPFBF_EBPFLE_INSN_LDXHLE, BPFBF_EBPFLE_SFMT_LDXHLE },\n+  { BPF_INSN_LDXBLE, BPFBF_EBPFLE_INSN_LDXBLE, BPFBF_EBPFLE_SFMT_LDXBLE },\n+  { BPF_INSN_LDXDWLE, BPFBF_EBPFLE_INSN_LDXDWLE, BPFBF_EBPFLE_SFMT_LDXDWLE },\n+  { BPF_INSN_STXWLE, BPFBF_EBPFLE_INSN_STXWLE, BPFBF_EBPFLE_SFMT_STXWLE },\n+  { BPF_INSN_STXHLE, BPFBF_EBPFLE_INSN_STXHLE, BPFBF_EBPFLE_SFMT_STXHLE },\n+  { BPF_INSN_STXBLE, BPFBF_EBPFLE_INSN_STXBLE, BPFBF_EBPFLE_SFMT_STXBLE },\n+  { BPF_INSN_STXDWLE, BPFBF_EBPFLE_INSN_STXDWLE, BPFBF_EBPFLE_SFMT_STXDWLE },\n+  { BPF_INSN_STBLE, BPFBF_EBPFLE_INSN_STBLE, BPFBF_EBPFLE_SFMT_STBLE },\n+  { BPF_INSN_STHLE, BPFBF_EBPFLE_INSN_STHLE, BPFBF_EBPFLE_SFMT_STHLE },\n+  { BPF_INSN_STWLE, BPFBF_EBPFLE_INSN_STWLE, BPFBF_EBPFLE_SFMT_STWLE },\n+  { BPF_INSN_STDWLE, BPFBF_EBPFLE_INSN_STDWLE, BPFBF_EBPFLE_SFMT_STDWLE },\n+  { BPF_INSN_JEQILE, BPFBF_EBPFLE_INSN_JEQILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JEQRLE, BPFBF_EBPFLE_INSN_JEQRLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JEQ32ILE, BPFBF_EBPFLE_INSN_JEQ32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JEQ32RLE, BPFBF_EBPFLE_INSN_JEQ32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JGTILE, BPFBF_EBPFLE_INSN_JGTILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JGTRLE, BPFBF_EBPFLE_INSN_JGTRLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JGT32ILE, BPFBF_EBPFLE_INSN_JGT32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JGT32RLE, BPFBF_EBPFLE_INSN_JGT32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JGEILE, BPFBF_EBPFLE_INSN_JGEILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JGERLE, BPFBF_EBPFLE_INSN_JGERLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JGE32ILE, BPFBF_EBPFLE_INSN_JGE32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JGE32RLE, BPFBF_EBPFLE_INSN_JGE32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JLTILE, BPFBF_EBPFLE_INSN_JLTILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JLTRLE, BPFBF_EBPFLE_INSN_JLTRLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JLT32ILE, BPFBF_EBPFLE_INSN_JLT32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JLT32RLE, BPFBF_EBPFLE_INSN_JLT32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JLEILE, BPFBF_EBPFLE_INSN_JLEILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JLERLE, BPFBF_EBPFLE_INSN_JLERLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JLE32ILE, BPFBF_EBPFLE_INSN_JLE32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JLE32RLE, BPFBF_EBPFLE_INSN_JLE32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSETILE, BPFBF_EBPFLE_INSN_JSETILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSETRLE, BPFBF_EBPFLE_INSN_JSETRLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSET32ILE, BPFBF_EBPFLE_INSN_JSET32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSET32RLE, BPFBF_EBPFLE_INSN_JSET32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JNEILE, BPFBF_EBPFLE_INSN_JNEILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JNERLE, BPFBF_EBPFLE_INSN_JNERLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JNE32ILE, BPFBF_EBPFLE_INSN_JNE32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JNE32RLE, BPFBF_EBPFLE_INSN_JNE32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSGTILE, BPFBF_EBPFLE_INSN_JSGTILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSGTRLE, BPFBF_EBPFLE_INSN_JSGTRLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSGT32ILE, BPFBF_EBPFLE_INSN_JSGT32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSGT32RLE, BPFBF_EBPFLE_INSN_JSGT32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSGEILE, BPFBF_EBPFLE_INSN_JSGEILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSGERLE, BPFBF_EBPFLE_INSN_JSGERLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSGE32ILE, BPFBF_EBPFLE_INSN_JSGE32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSGE32RLE, BPFBF_EBPFLE_INSN_JSGE32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSLTILE, BPFBF_EBPFLE_INSN_JSLTILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSLTRLE, BPFBF_EBPFLE_INSN_JSLTRLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSLT32ILE, BPFBF_EBPFLE_INSN_JSLT32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSLT32RLE, BPFBF_EBPFLE_INSN_JSLT32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSLEILE, BPFBF_EBPFLE_INSN_JSLEILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSLERLE, BPFBF_EBPFLE_INSN_JSLERLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_JSLE32ILE, BPFBF_EBPFLE_INSN_JSLE32ILE, BPFBF_EBPFLE_SFMT_JEQILE },\n+  { BPF_INSN_JSLE32RLE, BPFBF_EBPFLE_INSN_JSLE32RLE, BPFBF_EBPFLE_SFMT_JEQRLE },\n+  { BPF_INSN_CALLLE, BPFBF_EBPFLE_INSN_CALLLE, BPFBF_EBPFLE_SFMT_CALLLE },\n+  { BPF_INSN_JA, BPFBF_EBPFLE_INSN_JA, BPFBF_EBPFLE_SFMT_JA },\n+  { BPF_INSN_EXIT, BPFBF_EBPFLE_INSN_EXIT, BPFBF_EBPFLE_SFMT_EXIT },\n+  { BPF_INSN_XADDDWLE, BPFBF_EBPFLE_INSN_XADDDWLE, BPFBF_EBPFLE_SFMT_XADDDWLE },\n+  { BPF_INSN_XADDWLE, BPFBF_EBPFLE_INSN_XADDWLE, BPFBF_EBPFLE_SFMT_XADDWLE },\n+  { BPF_INSN_BRKPT, BPFBF_EBPFLE_INSN_BRKPT, BPFBF_EBPFLE_SFMT_EXIT },\n+};\n+\n+static const struct insn_sem bpfbf_ebpfle_insn_sem_invalid =\n+{\n+  VIRTUAL_INSN_X_INVALID, BPFBF_EBPFLE_INSN_X_INVALID, BPFBF_EBPFLE_SFMT_EMPTY\n+};\n+\n+/* Initialize an IDESC from the compile-time computable parts.  */\n+\n+static INLINE void\n+init_idesc (SIM_CPU *cpu, IDESC *id, const struct insn_sem *t)\n+{\n+  const CGEN_INSN *insn_table = CGEN_CPU_INSN_TABLE (CPU_CPU_DESC (cpu))->init_entries;\n+\n+  id->num = t->index;\n+  id->sfmt = t->sfmt;\n+  if ((int) t->type <= 0)\n+    id->idata = & cgen_virtual_insn_table[- (int) t->type];\n+  else\n+    id->idata = & insn_table[t->type];\n+  id->attrs = CGEN_INSN_ATTRS (id->idata);\n+  /* Oh my god, a magic number.  */\n+  id->length = CGEN_INSN_BITSIZE (id->idata) / 8;\n+\n+#if WITH_PROFILE_MODEL_P\n+  id->timing = & MODEL_TIMING (CPU_MODEL (cpu)) [t->index];\n+  {\n+    SIM_DESC sd = CPU_STATE (cpu);\n+    SIM_ASSERT (t->index == id->timing->num);\n+  }\n+#endif\n+\n+  /* Semantic pointers are initialized elsewhere.  */\n+}\n+\n+/* Initialize the instruction descriptor table.  */\n+\n+void\n+bpfbf_ebpfle_init_idesc_table (SIM_CPU *cpu)\n+{\n+  IDESC *id,*tabend;\n+  const struct insn_sem *t,*tend;\n+  int tabsize = BPFBF_EBPFLE_INSN__MAX;\n+  IDESC *table = bpfbf_ebpfle_insn_data;\n+\n+  memset (table, 0, tabsize * sizeof (IDESC));\n+\n+  /* First set all entries to the `invalid insn'.  */\n+  t = & bpfbf_ebpfle_insn_sem_invalid;\n+  for (id = table, tabend = table + tabsize; id < tabend; ++id)\n+    init_idesc (cpu, id, t);\n+\n+  /* Now fill in the values for the chosen cpu.  */\n+  for (t = bpfbf_ebpfle_insn_sem, tend = t + sizeof (bpfbf_ebpfle_insn_sem) / sizeof (*t);\n+       t != tend; ++t)\n+    {\n+      init_idesc (cpu, & table[t->index], t);\n+    }\n+\n+  /* Link the IDESC table into the cpu.  */\n+  CPU_IDESC (cpu) = table;\n+}\n+\n+/* Given an instruction, return a pointer to its IDESC entry.  */\n+\n+const IDESC *\n+bpfbf_ebpfle_decode (SIM_CPU *current_cpu, IADDR pc,\n+              CGEN_INSN_WORD base_insn,\n+              ARGBUF *abuf)\n+{\n+  /* Result of decoder.  */\n+  BPFBF_EBPFLE_INSN_TYPE itype;\n+\n+  {\n+    CGEN_INSN_WORD insn = base_insn;\n+\n+    {\n+      unsigned int val = (((insn >> 0) & (255 << 0)));\n+      switch (val)\n+      {\n+      case 4 : itype = BPFBF_EBPFLE_INSN_ADD32ILE; goto extract_sfmt_addile;\n+      case 5 : itype = BPFBF_EBPFLE_INSN_JA; goto extract_sfmt_ja;\n+      case 7 : itype = BPFBF_EBPFLE_INSN_ADDILE; goto extract_sfmt_addile;\n+      case 12 : itype = BPFBF_EBPFLE_INSN_ADD32RLE; goto extract_sfmt_addrle;\n+      case 15 : itype = BPFBF_EBPFLE_INSN_ADDRLE; goto extract_sfmt_addrle;\n+      case 20 : itype = BPFBF_EBPFLE_INSN_SUB32ILE; goto extract_sfmt_addile;\n+      case 21 : itype = BPFBF_EBPFLE_INSN_JEQILE; goto extract_sfmt_jeqile;\n+      case 22 : itype = BPFBF_EBPFLE_INSN_JEQ32ILE; goto extract_sfmt_jeqile;\n+      case 23 : itype = BPFBF_EBPFLE_INSN_SUBILE; goto extract_sfmt_addile;\n+      case 24 : itype = BPFBF_EBPFLE_INSN_LDDWLE; goto extract_sfmt_lddwle;\n+      case 28 : itype = BPFBF_EBPFLE_INSN_SUB32RLE; goto extract_sfmt_addrle;\n+      case 29 : itype = BPFBF_EBPFLE_INSN_JEQRLE; goto extract_sfmt_jeqrle;\n+      case 30 : itype = BPFBF_EBPFLE_INSN_JEQ32RLE; goto extract_sfmt_jeqrle;\n+      case 31 : itype = BPFBF_EBPFLE_INSN_SUBRLE; goto extract_sfmt_addrle;\n+      case 32 : itype = BPFBF_EBPFLE_INSN_LDABSW; goto extract_sfmt_ldabsw;\n+      case 36 : itype = BPFBF_EBPFLE_INSN_MUL32ILE; goto extract_sfmt_addile;\n+      case 37 : itype = BPFBF_EBPFLE_INSN_JGTILE; goto extract_sfmt_jeqile;\n+      case 38 : itype = BPFBF_EBPFLE_INSN_JGT32ILE; goto extract_sfmt_jeqile;\n+      case 39 : itype = BPFBF_EBPFLE_INSN_MULILE; goto extract_sfmt_addile;\n+      case 40 : itype = BPFBF_EBPFLE_INSN_LDABSH; goto extract_sfmt_ldabsh;\n+      case 44 : itype = BPFBF_EBPFLE_INSN_MUL32RLE; goto extract_sfmt_addrle;\n+      case 45 : itype = BPFBF_EBPFLE_INSN_JGTRLE; goto extract_sfmt_jeqrle;\n+      case 46 : itype = BPFBF_EBPFLE_INSN_JGT32RLE; goto extract_sfmt_jeqrle;\n+      case 47 : itype = BPFBF_EBPFLE_INSN_MULRLE; goto extract_sfmt_addrle;\n+      case 48 : itype = BPFBF_EBPFLE_INSN_LDABSB; goto extract_sfmt_ldabsb;\n+      case 52 : itype = BPFBF_EBPFLE_INSN_DIV32ILE; goto extract_sfmt_addile;\n+      case 53 : itype = BPFBF_EBPFLE_INSN_JGEILE; goto extract_sfmt_jeqile;\n+      case 54 : itype = BPFBF_EBPFLE_INSN_JGE32ILE; goto extract_sfmt_jeqile;\n+      case 55 : itype = BPFBF_EBPFLE_INSN_DIVILE; goto extract_sfmt_addile;\n+      case 56 : itype = BPFBF_EBPFLE_INSN_LDABSDW; goto extract_sfmt_ldabsdw;\n+      case 60 : itype = BPFBF_EBPFLE_INSN_DIV32RLE; goto extract_sfmt_addrle;\n+      case 61 : itype = BPFBF_EBPFLE_INSN_JGERLE; goto extract_sfmt_jeqrle;\n+      case 62 : itype = BPFBF_EBPFLE_INSN_JGE32RLE; goto extract_sfmt_jeqrle;\n+      case 63 : itype = BPFBF_EBPFLE_INSN_DIVRLE; goto extract_sfmt_addrle;\n+      case 64 : itype = BPFBF_EBPFLE_INSN_LDINDWLE; goto extract_sfmt_ldindwle;\n+      case 68 : itype = BPFBF_EBPFLE_INSN_OR32ILE; goto extract_sfmt_addile;\n+      case 69 : itype = BPFBF_EBPFLE_INSN_JSETILE; goto extract_sfmt_jeqile;\n+      case 70 : itype = BPFBF_EBPFLE_INSN_JSET32ILE; goto extract_sfmt_jeqile;\n+      case 71 : itype = BPFBF_EBPFLE_INSN_ORILE; goto extract_sfmt_addile;\n+      case 72 : itype = BPFBF_EBPFLE_INSN_LDINDHLE; goto extract_sfmt_ldindhle;\n+      case 76 : itype = BPFBF_EBPFLE_INSN_OR32RLE; goto extract_sfmt_addrle;\n+      case 77 : itype = BPFBF_EBPFLE_INSN_JSETRLE; goto extract_sfmt_jeqrle;\n+      case 78 : itype = BPFBF_EBPFLE_INSN_JSET32RLE; goto extract_sfmt_jeqrle;\n+      case 79 : itype = BPFBF_EBPFLE_INSN_ORRLE; goto extract_sfmt_addrle;\n+      case 80 : itype = BPFBF_EBPFLE_INSN_LDINDBLE; goto extract_sfmt_ldindble;\n+      case 84 : itype = BPFBF_EBPFLE_INSN_AND32ILE; goto extract_sfmt_addile;\n+      case 85 : itype = BPFBF_EBPFLE_INSN_JNEILE; goto extract_sfmt_jeqile;\n+      case 86 : itype = BPFBF_EBPFLE_INSN_JNE32ILE; goto extract_sfmt_jeqile;\n+      case 87 : itype = BPFBF_EBPFLE_INSN_ANDILE; goto extract_sfmt_addile;\n+      case 88 : itype = BPFBF_EBPFLE_INSN_LDINDDWLE; goto extract_sfmt_ldinddwle;\n+      case 92 : itype = BPFBF_EBPFLE_INSN_AND32RLE; goto extract_sfmt_addrle;\n+      case 93 : itype = BPFBF_EBPFLE_INSN_JNERLE; goto extract_sfmt_jeqrle;\n+      case 94 : itype = BPFBF_EBPFLE_INSN_JNE32RLE; goto extract_sfmt_jeqrle;\n+      case 95 : itype = BPFBF_EBPFLE_INSN_ANDRLE; goto extract_sfmt_addrle;\n+      case 97 : itype = BPFBF_EBPFLE_INSN_LDXWLE; goto extract_sfmt_ldxwle;\n+      case 98 : itype = BPFBF_EBPFLE_INSN_STWLE; goto extract_sfmt_stwle;\n+      case 99 : itype = BPFBF_EBPFLE_INSN_STXWLE; goto extract_sfmt_stxwle;\n+      case 100 : itype = BPFBF_EBPFLE_INSN_LSH32ILE; goto extract_sfmt_addile;\n+      case 101 : itype = BPFBF_EBPFLE_INSN_JSGTILE; goto extract_sfmt_jeqile;\n+      case 102 : itype = BPFBF_EBPFLE_INSN_JSGT32ILE; goto extract_sfmt_jeqile;\n+      case 103 : itype = BPFBF_EBPFLE_INSN_LSHILE; goto extract_sfmt_addile;\n+      case 105 : itype = BPFBF_EBPFLE_INSN_LDXHLE; goto extract_sfmt_ldxhle;\n+      case 106 : itype = BPFBF_EBPFLE_INSN_STHLE; goto extract_sfmt_sthle;\n+      case 107 : itype = BPFBF_EBPFLE_INSN_STXHLE; goto extract_sfmt_stxhle;\n+      case 108 : itype = BPFBF_EBPFLE_INSN_LSH32RLE; goto extract_sfmt_addrle;\n+      case 109 : itype = BPFBF_EBPFLE_INSN_JSGTRLE; goto extract_sfmt_jeqrle;\n+      case 110 : itype = BPFBF_EBPFLE_INSN_JSGT32RLE; goto extract_sfmt_jeqrle;\n+      case 111 : itype = BPFBF_EBPFLE_INSN_LSHRLE; goto extract_sfmt_addrle;\n+      case 113 : itype = BPFBF_EBPFLE_INSN_LDXBLE; goto extract_sfmt_ldxble;\n+      case 114 : itype = BPFBF_EBPFLE_INSN_STBLE; goto extract_sfmt_stble;\n+      case 115 : itype = BPFBF_EBPFLE_INSN_STXBLE; goto extract_sfmt_stxble;\n+      case 116 : itype = BPFBF_EBPFLE_INSN_RSH32ILE; goto extract_sfmt_addile;\n+      case 117 : itype = BPFBF_EBPFLE_INSN_JSGEILE; goto extract_sfmt_jeqile;\n+      case 118 : itype = BPFBF_EBPFLE_INSN_JSGE32ILE; goto extract_sfmt_jeqile;\n+      case 119 : itype = BPFBF_EBPFLE_INSN_RSHILE; goto extract_sfmt_addile;\n+      case 121 : itype = BPFBF_EBPFLE_INSN_LDXDWLE; goto extract_sfmt_ldxdwle;\n+      case 122 : itype = BPFBF_EBPFLE_INSN_STDWLE; goto extract_sfmt_stdwle;\n+      case 123 : itype = BPFBF_EBPFLE_INSN_STXDWLE; goto extract_sfmt_stxdwle;\n+      case 124 : itype = BPFBF_EBPFLE_INSN_RSH32RLE; goto extract_sfmt_addrle;\n+      case 125 : itype = BPFBF_EBPFLE_INSN_JSGERLE; goto extract_sfmt_jeqrle;\n+      case 126 : itype = BPFBF_EBPFLE_INSN_JSGE32RLE; goto extract_sfmt_jeqrle;\n+      case 127 : itype = BPFBF_EBPFLE_INSN_RSHRLE; goto extract_sfmt_addrle;\n+      case 132 : itype = BPFBF_EBPFLE_INSN_NEG32LE; goto extract_sfmt_negle;\n+      case 133 : itype = BPFBF_EBPFLE_INSN_CALLLE; goto extract_sfmt_callle;\n+      case 135 : itype = BPFBF_EBPFLE_INSN_NEGLE; goto extract_sfmt_negle;\n+      case 140 : itype = BPFBF_EBPFLE_INSN_BRKPT; goto extract_sfmt_exit;\n+      case 148 : itype = BPFBF_EBPFLE_INSN_MOD32ILE; goto extract_sfmt_addile;\n+      case 149 : itype = BPFBF_EBPFLE_INSN_EXIT; goto extract_sfmt_exit;\n+      case 151 : itype = BPFBF_EBPFLE_INSN_MODILE; goto extract_sfmt_addile;\n+      case 156 : itype = BPFBF_EBPFLE_INSN_MOD32RLE; goto extract_sfmt_addrle;\n+      case 159 : itype = BPFBF_EBPFLE_INSN_MODRLE; goto extract_sfmt_addrle;\n+      case 164 : itype = BPFBF_EBPFLE_INSN_XOR32ILE; goto extract_sfmt_addile;\n+      case 165 : itype = BPFBF_EBPFLE_INSN_JLTILE; goto extract_sfmt_jeqile;\n+      case 166 : itype = BPFBF_EBPFLE_INSN_JLT32ILE; goto extract_sfmt_jeqile;\n+      case 167 : itype = BPFBF_EBPFLE_INSN_XORILE; goto extract_sfmt_addile;\n+      case 172 : itype = BPFBF_EBPFLE_INSN_XOR32RLE; goto extract_sfmt_addrle;\n+      case 173 : itype = BPFBF_EBPFLE_INSN_JLTRLE; goto extract_sfmt_jeqrle;\n+      case 174 : itype = BPFBF_EBPFLE_INSN_JLT32RLE; goto extract_sfmt_jeqrle;\n+      case 175 : itype = BPFBF_EBPFLE_INSN_XORRLE; goto extract_sfmt_addrle;\n+      case 180 : itype = BPFBF_EBPFLE_INSN_MOV32ILE; goto extract_sfmt_movile;\n+      case 181 : itype = BPFBF_EBPFLE_INSN_JLEILE; goto extract_sfmt_jeqile;\n+      case 182 : itype = BPFBF_EBPFLE_INSN_JLE32ILE; goto extract_sfmt_jeqile;\n+      case 183 : itype = BPFBF_EBPFLE_INSN_MOVILE; goto extract_sfmt_movile;\n+      case 188 : itype = BPFBF_EBPFLE_INSN_MOV32RLE; goto extract_sfmt_movrle;\n+      case 189 : itype = BPFBF_EBPFLE_INSN_JLERLE; goto extract_sfmt_jeqrle;\n+      case 190 : itype = BPFBF_EBPFLE_INSN_JLE32RLE; goto extract_sfmt_jeqrle;\n+      case 191 : itype = BPFBF_EBPFLE_INSN_MOVRLE; goto extract_sfmt_movrle;\n+      case 195 : itype = BPFBF_EBPFLE_INSN_XADDWLE; goto extract_sfmt_xaddwle;\n+      case 196 : itype = BPFBF_EBPFLE_INSN_ARSH32ILE; goto extract_sfmt_addile;\n+      case 197 : itype = BPFBF_EBPFLE_INSN_JSLTILE; goto extract_sfmt_jeqile;\n+      case 198 : itype = BPFBF_EBPFLE_INSN_JSLT32ILE; goto extract_sfmt_jeqile;\n+      case 199 : itype = BPFBF_EBPFLE_INSN_ARSHILE; goto extract_sfmt_addile;\n+      case 204 : itype = BPFBF_EBPFLE_INSN_ARSH32RLE; goto extract_sfmt_addrle;\n+      case 205 : itype = BPFBF_EBPFLE_INSN_JSLTRLE; goto extract_sfmt_jeqrle;\n+      case 206 : itype = BPFBF_EBPFLE_INSN_JSLT32RLE; goto extract_sfmt_jeqrle;\n+      case 207 : itype = BPFBF_EBPFLE_INSN_ARSHRLE; goto extract_sfmt_addrle;\n+      case 212 : itype = BPFBF_EBPFLE_INSN_ENDLELE; goto extract_sfmt_endlele;\n+      case 213 : itype = BPFBF_EBPFLE_INSN_JSLEILE; goto extract_sfmt_jeqile;\n+      case 214 : itype = BPFBF_EBPFLE_INSN_JSLE32ILE; goto extract_sfmt_jeqile;\n+      case 219 : itype = BPFBF_EBPFLE_INSN_XADDDWLE; goto extract_sfmt_xadddwle;\n+      case 220 : itype = BPFBF_EBPFLE_INSN_ENDBELE; goto extract_sfmt_endlele;\n+      case 221 : itype = BPFBF_EBPFLE_INSN_JSLERLE; goto extract_sfmt_jeqrle;\n+      case 222 : itype = BPFBF_EBPFLE_INSN_JSLE32RLE; goto extract_sfmt_jeqrle;\n+      default : itype = BPFBF_EBPFLE_INSN_X_INVALID; goto extract_sfmt_empty;\n+      }\n+    }\n+  }\n+\n+  /* The instruction has been decoded, now extract the fields.  */\n+\n+ extract_sfmt_empty:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+#define FLD(f) abuf->fields.sfmt_empty.f\n+\n+\n+  /* Record the fields for the semantic handler.  */\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_empty\", (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_addile:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    INT f_imm32;\n+    UINT f_dstle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_addile\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_addrle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_addrle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_negle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_lddwle.f\n+    UINT f_dstle;\n+\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_negle\", \"f_dstle 0x%x\", 'x', f_dstle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_movile:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    INT f_imm32;\n+    UINT f_dstle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_dstle) = f_dstle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_movile\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_dstle 0x%x\", 'x', f_dstle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_movrle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_srcle) = f_srcle;\n+  FLD (f_dstle) = f_dstle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_movrle\", \"f_srcle 0x%x\", 'x', f_srcle, \"f_dstle 0x%x\", 'x', f_dstle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_endlele:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    INT f_imm32;\n+    UINT f_dstle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_endlele\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_lddwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_lddwle.f\n+    UINT f_imm64_c;\n+    UINT f_imm64_b;\n+    UINT f_imm64_a;\n+    UINT f_dstle;\n+    DI f_imm64;\n+    /* Contents of trailing part of insn.  */\n+    UINT word_1;\n+    UINT word_2;\n+\n+  word_1 = GETIMEMUSI (current_cpu, pc + 8);\n+  word_2 = GETIMEMUSI (current_cpu, pc + 12);\n+    f_imm64_c = (0|(EXTRACT_LSB0_UINT (word_2, 32, 31, 32) << 0));\n+    f_imm64_b = (0|(EXTRACT_LSB0_UINT (word_1, 32, 31, 32) << 0));\n+    f_imm64_a = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+{\n+  f_imm64 = ((((((UDI) (UINT) (f_imm64_c))) << (32))) | (((UDI) (UINT) (f_imm64_a))));\n+}\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm64) = f_imm64;\n+  FLD (f_dstle) = f_dstle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_lddwle\", \"f_imm64 0x%x\", 'x', f_imm64, \"f_dstle 0x%x\", 'x', f_dstle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldabsw:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldabsw\", \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldabsh:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldabsh\", \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldabsb:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldabsb\", \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldabsdw:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldabsdw\", \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldindwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+    UINT f_srcle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldindwle\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldindhle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+    UINT f_srcle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldindhle\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldindble:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+    UINT f_srcle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldindble\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldinddwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+    UINT f_srcle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldinddwle\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldxwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  FLD (f_dstle) = f_dstle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldxwle\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, \"f_dstle 0x%x\", 'x', f_dstle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldxhle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  FLD (f_dstle) = f_dstle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldxhle\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, \"f_dstle 0x%x\", 'x', f_dstle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldxble:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  FLD (f_dstle) = f_dstle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldxble\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, \"f_dstle 0x%x\", 'x', f_dstle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ldxdwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  FLD (f_dstle) = f_dstle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ldxdwle\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, \"f_dstle 0x%x\", 'x', f_dstle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stxwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stxwle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stxhle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stxhle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stxble:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stxble\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stxdwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stxdwle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stble:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stble\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_imm32 0x%x\", 'x', f_imm32, \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_sthle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_sthle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_imm32 0x%x\", 'x', f_imm32, \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stwle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_imm32 0x%x\", 'x', f_imm32, \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_stdwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_stdwle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_imm32 0x%x\", 'x', f_imm32, \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_jeqile:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    INT f_imm32;\n+    HI f_offset16;\n+    UINT f_dstle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_imm32) = f_imm32;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_jeqile\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_dstle 0x%x\", 'x', f_dstle, \"f_imm32 0x%x\", 'x', f_imm32, (char *) 0));\n+\n+#if WITH_PROFILE_MODEL_P\n+  /* Record the fields for profiling.  */\n+  if (PROFILE_MODEL_P (current_cpu))\n+    {\n+    }\n+#endif\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_jeqrle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_jeqrle\", \"f_offset16 0x%x\", 'x', f_offset16, \"f_dstle 0x%x\", 'x', f_dstle, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#if WITH_PROFILE_MODEL_P\n+  /* Record the fields for profiling.  */\n+  if (PROFILE_MODEL_P (current_cpu))\n+    {\n+    }\n+#endif\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_callle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldindwle.f\n+    INT f_imm32;\n+    UINT f_srcle;\n+\n+    f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_imm32) = f_imm32;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_callle\", \"f_imm32 0x%x\", 'x', f_imm32, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_ja:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_stble.f\n+    HI f_offset16;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_offset16) = f_offset16;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_ja\", \"f_offset16 0x%x\", 'x', f_offset16, (char *) 0));\n+\n+#if WITH_PROFILE_MODEL_P\n+  /* Record the fields for profiling.  */\n+  if (PROFILE_MODEL_P (current_cpu))\n+    {\n+    }\n+#endif\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_exit:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+#define FLD(f) abuf->fields.sfmt_empty.f\n+\n+\n+  /* Record the fields for the semantic handler.  */\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_exit\", (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_xadddwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_xadddwle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+ extract_sfmt_xaddwle:\n+  {\n+    const IDESC *idesc = &bpfbf_ebpfle_insn_data[itype];\n+    CGEN_INSN_WORD insn = base_insn;\n+#define FLD(f) abuf->fields.sfmt_ldxwle.f\n+    HI f_offset16;\n+    UINT f_srcle;\n+    UINT f_dstle;\n+\n+    f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0));\n+    f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0));\n+    f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0));\n+\n+  /* Record the fields for the semantic handler.  */\n+  FLD (f_dstle) = f_dstle;\n+  FLD (f_offset16) = f_offset16;\n+  FLD (f_srcle) = f_srcle;\n+  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, \"sfmt_xaddwle\", \"f_dstle 0x%x\", 'x', f_dstle, \"f_offset16 0x%x\", 'x', f_offset16, \"f_srcle 0x%x\", 'x', f_srcle, (char *) 0));\n+\n+#undef FLD\n+    return idesc;\n+  }\n+\n+}"
    },
    {
      "sha": "d854f1d4ed05b4886c171da390e03f68a2b755fe",
      "filename": "sim/bpf/decode-le.h",
      "status": "added",
      "additions": 94,
      "deletions": 0,
      "changes": 94,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/decode-le.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/decode-le.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/decode-le.h?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,94 @@\n+/* Decode header for bpfbf_ebpfle.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef BPFBF_EBPFLE_DECODE_H\n+#define BPFBF_EBPFLE_DECODE_H\n+\n+extern const IDESC *bpfbf_ebpfle_decode (SIM_CPU *, IADDR,\n+                                  CGEN_INSN_WORD,\n+                                  ARGBUF *);\n+extern void bpfbf_ebpfle_init_idesc_table (SIM_CPU *);\n+extern void bpfbf_ebpfle_sem_init_idesc_table (SIM_CPU *);\n+extern void bpfbf_ebpfle_semf_init_idesc_table (SIM_CPU *);\n+\n+/* Enum declaration for instructions in cpu family bpfbf.  */\n+typedef enum bpfbf_ebpfle_insn_type {\n+  BPFBF_EBPFLE_INSN_X_INVALID, BPFBF_EBPFLE_INSN_X_AFTER, BPFBF_EBPFLE_INSN_X_BEFORE, BPFBF_EBPFLE_INSN_X_CTI_CHAIN\n+ , BPFBF_EBPFLE_INSN_X_CHAIN, BPFBF_EBPFLE_INSN_X_BEGIN, BPFBF_EBPFLE_INSN_ADDILE, BPFBF_EBPFLE_INSN_ADDRLE\n+ , BPFBF_EBPFLE_INSN_ADD32ILE, BPFBF_EBPFLE_INSN_ADD32RLE, BPFBF_EBPFLE_INSN_SUBILE, BPFBF_EBPFLE_INSN_SUBRLE\n+ , BPFBF_EBPFLE_INSN_SUB32ILE, BPFBF_EBPFLE_INSN_SUB32RLE, BPFBF_EBPFLE_INSN_MULILE, BPFBF_EBPFLE_INSN_MULRLE\n+ , BPFBF_EBPFLE_INSN_MUL32ILE, BPFBF_EBPFLE_INSN_MUL32RLE, BPFBF_EBPFLE_INSN_DIVILE, BPFBF_EBPFLE_INSN_DIVRLE\n+ , BPFBF_EBPFLE_INSN_DIV32ILE, BPFBF_EBPFLE_INSN_DIV32RLE, BPFBF_EBPFLE_INSN_ORILE, BPFBF_EBPFLE_INSN_ORRLE\n+ , BPFBF_EBPFLE_INSN_OR32ILE, BPFBF_EBPFLE_INSN_OR32RLE, BPFBF_EBPFLE_INSN_ANDILE, BPFBF_EBPFLE_INSN_ANDRLE\n+ , BPFBF_EBPFLE_INSN_AND32ILE, BPFBF_EBPFLE_INSN_AND32RLE, BPFBF_EBPFLE_INSN_LSHILE, BPFBF_EBPFLE_INSN_LSHRLE\n+ , BPFBF_EBPFLE_INSN_LSH32ILE, BPFBF_EBPFLE_INSN_LSH32RLE, BPFBF_EBPFLE_INSN_RSHILE, BPFBF_EBPFLE_INSN_RSHRLE\n+ , BPFBF_EBPFLE_INSN_RSH32ILE, BPFBF_EBPFLE_INSN_RSH32RLE, BPFBF_EBPFLE_INSN_MODILE, BPFBF_EBPFLE_INSN_MODRLE\n+ , BPFBF_EBPFLE_INSN_MOD32ILE, BPFBF_EBPFLE_INSN_MOD32RLE, BPFBF_EBPFLE_INSN_XORILE, BPFBF_EBPFLE_INSN_XORRLE\n+ , BPFBF_EBPFLE_INSN_XOR32ILE, BPFBF_EBPFLE_INSN_XOR32RLE, BPFBF_EBPFLE_INSN_ARSHILE, BPFBF_EBPFLE_INSN_ARSHRLE\n+ , BPFBF_EBPFLE_INSN_ARSH32ILE, BPFBF_EBPFLE_INSN_ARSH32RLE, BPFBF_EBPFLE_INSN_NEGLE, BPFBF_EBPFLE_INSN_NEG32LE\n+ , BPFBF_EBPFLE_INSN_MOVILE, BPFBF_EBPFLE_INSN_MOVRLE, BPFBF_EBPFLE_INSN_MOV32ILE, BPFBF_EBPFLE_INSN_MOV32RLE\n+ , BPFBF_EBPFLE_INSN_ENDLELE, BPFBF_EBPFLE_INSN_ENDBELE, BPFBF_EBPFLE_INSN_LDDWLE, BPFBF_EBPFLE_INSN_LDABSW\n+ , BPFBF_EBPFLE_INSN_LDABSH, BPFBF_EBPFLE_INSN_LDABSB, BPFBF_EBPFLE_INSN_LDABSDW, BPFBF_EBPFLE_INSN_LDINDWLE\n+ , BPFBF_EBPFLE_INSN_LDINDHLE, BPFBF_EBPFLE_INSN_LDINDBLE, BPFBF_EBPFLE_INSN_LDINDDWLE, BPFBF_EBPFLE_INSN_LDXWLE\n+ , BPFBF_EBPFLE_INSN_LDXHLE, BPFBF_EBPFLE_INSN_LDXBLE, BPFBF_EBPFLE_INSN_LDXDWLE, BPFBF_EBPFLE_INSN_STXWLE\n+ , BPFBF_EBPFLE_INSN_STXHLE, BPFBF_EBPFLE_INSN_STXBLE, BPFBF_EBPFLE_INSN_STXDWLE, BPFBF_EBPFLE_INSN_STBLE\n+ , BPFBF_EBPFLE_INSN_STHLE, BPFBF_EBPFLE_INSN_STWLE, BPFBF_EBPFLE_INSN_STDWLE, BPFBF_EBPFLE_INSN_JEQILE\n+ , BPFBF_EBPFLE_INSN_JEQRLE, BPFBF_EBPFLE_INSN_JEQ32ILE, BPFBF_EBPFLE_INSN_JEQ32RLE, BPFBF_EBPFLE_INSN_JGTILE\n+ , BPFBF_EBPFLE_INSN_JGTRLE, BPFBF_EBPFLE_INSN_JGT32ILE, BPFBF_EBPFLE_INSN_JGT32RLE, BPFBF_EBPFLE_INSN_JGEILE\n+ , BPFBF_EBPFLE_INSN_JGERLE, BPFBF_EBPFLE_INSN_JGE32ILE, BPFBF_EBPFLE_INSN_JGE32RLE, BPFBF_EBPFLE_INSN_JLTILE\n+ , BPFBF_EBPFLE_INSN_JLTRLE, BPFBF_EBPFLE_INSN_JLT32ILE, BPFBF_EBPFLE_INSN_JLT32RLE, BPFBF_EBPFLE_INSN_JLEILE\n+ , BPFBF_EBPFLE_INSN_JLERLE, BPFBF_EBPFLE_INSN_JLE32ILE, BPFBF_EBPFLE_INSN_JLE32RLE, BPFBF_EBPFLE_INSN_JSETILE\n+ , BPFBF_EBPFLE_INSN_JSETRLE, BPFBF_EBPFLE_INSN_JSET32ILE, BPFBF_EBPFLE_INSN_JSET32RLE, BPFBF_EBPFLE_INSN_JNEILE\n+ , BPFBF_EBPFLE_INSN_JNERLE, BPFBF_EBPFLE_INSN_JNE32ILE, BPFBF_EBPFLE_INSN_JNE32RLE, BPFBF_EBPFLE_INSN_JSGTILE\n+ , BPFBF_EBPFLE_INSN_JSGTRLE, BPFBF_EBPFLE_INSN_JSGT32ILE, BPFBF_EBPFLE_INSN_JSGT32RLE, BPFBF_EBPFLE_INSN_JSGEILE\n+ , BPFBF_EBPFLE_INSN_JSGERLE, BPFBF_EBPFLE_INSN_JSGE32ILE, BPFBF_EBPFLE_INSN_JSGE32RLE, BPFBF_EBPFLE_INSN_JSLTILE\n+ , BPFBF_EBPFLE_INSN_JSLTRLE, BPFBF_EBPFLE_INSN_JSLT32ILE, BPFBF_EBPFLE_INSN_JSLT32RLE, BPFBF_EBPFLE_INSN_JSLEILE\n+ , BPFBF_EBPFLE_INSN_JSLERLE, BPFBF_EBPFLE_INSN_JSLE32ILE, BPFBF_EBPFLE_INSN_JSLE32RLE, BPFBF_EBPFLE_INSN_CALLLE\n+ , BPFBF_EBPFLE_INSN_JA, BPFBF_EBPFLE_INSN_EXIT, BPFBF_EBPFLE_INSN_XADDDWLE, BPFBF_EBPFLE_INSN_XADDWLE\n+ , BPFBF_EBPFLE_INSN_BRKPT, BPFBF_EBPFLE_INSN__MAX\n+} BPFBF_EBPFLE_INSN_TYPE;\n+\n+/* Enum declaration for semantic formats in cpu family bpfbf.  */\n+typedef enum bpfbf_ebpfle_sfmt_type {\n+  BPFBF_EBPFLE_SFMT_EMPTY, BPFBF_EBPFLE_SFMT_ADDILE, BPFBF_EBPFLE_SFMT_ADDRLE, BPFBF_EBPFLE_SFMT_NEGLE\n+ , BPFBF_EBPFLE_SFMT_MOVILE, BPFBF_EBPFLE_SFMT_MOVRLE, BPFBF_EBPFLE_SFMT_ENDLELE, BPFBF_EBPFLE_SFMT_LDDWLE\n+ , BPFBF_EBPFLE_SFMT_LDABSW, BPFBF_EBPFLE_SFMT_LDABSH, BPFBF_EBPFLE_SFMT_LDABSB, BPFBF_EBPFLE_SFMT_LDABSDW\n+ , BPFBF_EBPFLE_SFMT_LDINDWLE, BPFBF_EBPFLE_SFMT_LDINDHLE, BPFBF_EBPFLE_SFMT_LDINDBLE, BPFBF_EBPFLE_SFMT_LDINDDWLE\n+ , BPFBF_EBPFLE_SFMT_LDXWLE, BPFBF_EBPFLE_SFMT_LDXHLE, BPFBF_EBPFLE_SFMT_LDXBLE, BPFBF_EBPFLE_SFMT_LDXDWLE\n+ , BPFBF_EBPFLE_SFMT_STXWLE, BPFBF_EBPFLE_SFMT_STXHLE, BPFBF_EBPFLE_SFMT_STXBLE, BPFBF_EBPFLE_SFMT_STXDWLE\n+ , BPFBF_EBPFLE_SFMT_STBLE, BPFBF_EBPFLE_SFMT_STHLE, BPFBF_EBPFLE_SFMT_STWLE, BPFBF_EBPFLE_SFMT_STDWLE\n+ , BPFBF_EBPFLE_SFMT_JEQILE, BPFBF_EBPFLE_SFMT_JEQRLE, BPFBF_EBPFLE_SFMT_CALLLE, BPFBF_EBPFLE_SFMT_JA\n+ , BPFBF_EBPFLE_SFMT_EXIT, BPFBF_EBPFLE_SFMT_XADDDWLE, BPFBF_EBPFLE_SFMT_XADDWLE\n+} BPFBF_EBPFLE_SFMT_TYPE;\n+\n+/* Function unit handlers (user written).  */\n+\n+extern int bpfbf_model_bpf_def_u_exec (SIM_CPU *, const IDESC *, int /*unit_num*/, int /*referenced*/);\n+\n+/* Profiling before/after handlers (user written) */\n+\n+extern void bpfbf_model_insn_before (SIM_CPU *, int /*first_p*/);\n+extern void bpfbf_model_insn_after (SIM_CPU *, int /*last_p*/, int /*cycles*/);\n+\n+#endif /* BPFBF_EBPFLE_DECODE_H */"
    },
    {
      "sha": "fc6dbb4d7a4f07b30ccf866a97b144f9c9895ba5",
      "filename": "sim/bpf/defs-be.h",
      "status": "added",
      "additions": 383,
      "deletions": 0,
      "changes": 383,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/defs-be.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/defs-be.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/defs-be.h?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,383 @@\n+/* ISA definitions header for ebpfbe.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef DEFS_BPFBF_EBPFBE_H\n+#define DEFS_BPFBF_EBPFBE_H\n+\n+/* Instruction argument buffer.  */\n+\n+union sem_fields {\n+  struct { /* no operands */\n+    int empty;\n+  } sfmt_empty;\n+  struct { /*  */\n+    INT f_imm32;\n+    UINT f_srcbe;\n+  } sfmt_ldindwbe;\n+  struct { /*  */\n+    DI f_imm64;\n+    UINT f_dstbe;\n+  } sfmt_lddwbe;\n+  struct { /*  */\n+    INT f_imm32;\n+    UINT f_dstbe;\n+    HI f_offset16;\n+  } sfmt_stbbe;\n+  struct { /*  */\n+    UINT f_dstbe;\n+    UINT f_srcbe;\n+    HI f_offset16;\n+  } sfmt_ldxwbe;\n+#if WITH_SCACHE_PBB\n+  /* Writeback handler.  */\n+  struct {\n+    /* Pointer to argbuf entry for insn whose results need writing back.  */\n+    const struct argbuf *abuf;\n+  } write;\n+  /* x-before handler */\n+  struct {\n+    /*const SCACHE *insns[MAX_PARALLEL_INSNS];*/\n+    int first_p;\n+  } before;\n+  /* x-after handler */\n+  struct {\n+    int empty;\n+  } after;\n+  /* This entry is used to terminate each pbb.  */\n+  struct {\n+    /* Number of insns in pbb.  */\n+    int insn_count;\n+    /* Next pbb to execute.  */\n+    SCACHE *next;\n+    SCACHE *branch_target;\n+  } chain;\n+#endif\n+};\n+\n+/* The ARGBUF struct.  */\n+struct argbuf {\n+  /* These are the baseclass definitions.  */\n+  IADDR addr;\n+  const IDESC *idesc;\n+  char trace_p;\n+  char profile_p;\n+  /* ??? Temporary hack for skip insns.  */\n+  char skip_count;\n+  char unused;\n+  /* cpu specific data follows */\n+  union sem semantic;\n+  int written;\n+  union sem_fields fields;\n+};\n+\n+/* A cached insn.\n+\n+   ??? SCACHE used to contain more than just argbuf.  We could delete the\n+   type entirely and always just use ARGBUF, but for future concerns and as\n+   a level of abstraction it is left in.  */\n+\n+struct scache {\n+  struct argbuf argbuf;\n+};\n+\n+/* Macros to simplify extraction, reading and semantic code.\n+   These define and assign the local vars that contain the insn's fields.  */\n+\n+#define EXTRACT_IFMT_EMPTY_VARS \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_EMPTY_CODE \\\n+  length = 0; \\\n+\n+#define EXTRACT_IFMT_ADDIBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_code; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_ADDIBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_ADDRBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_code; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_ADDRBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_NEGBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_code; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_NEGBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_ENDLEBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_code; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_ENDLEBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_LDDWBE_VARS \\\n+  UINT f_imm64_a; \\\n+  UINT f_imm64_b; \\\n+  UINT f_imm64_c; \\\n+  DI f_imm64; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_class; \\\n+  /* Contents of trailing part of insn.  */ \\\n+  UINT word_1; \\\n+  UINT word_2; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_LDDWBE_CODE \\\n+  length = 16; \\\n+  word_1 = GETIMEMUSI (current_cpu, pc + 8); \\\n+  word_2 = GETIMEMUSI (current_cpu, pc + 12); \\\n+  f_imm64_a = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_imm64_b = (0|(EXTRACT_LSB0_UINT (word_1, 32, 31, 32) << 0)); \\\n+  f_imm64_c = (0|(EXTRACT_LSB0_UINT (word_2, 32, 31, 32) << 0)); \\\n+{\\\n+  f_imm64 = ((((((UDI) (UINT) (f_imm64_c))) << (32))) | (((UDI) (UINT) (f_imm64_a))));\\\n+}\\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_LDABSW_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_regs; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_LDABSW_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_regs = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 8) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_LDINDWBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_LDINDWBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_LDXWBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_LDXWBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_STBBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_STBBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_JEQIBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_code; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_JEQIBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_JEQRBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_dstbe; \\\n+  UINT f_op_code; \\\n+  UINT f_srcbe; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_JEQRBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_dstbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_srcbe = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_CALLBE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_regs; \\\n+  UINT f_op_code; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_CALLBE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_regs = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 8) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_JA_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_regs; \\\n+  UINT f_op_code; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_JA_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_regs = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 8) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_EXIT_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_regs; \\\n+  UINT f_op_code; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_EXIT_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_regs = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 8) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#endif /* DEFS_BPFBF_EBPFBE_H */"
    },
    {
      "sha": "aeb8a44e8843048a07b2936ecace71eaafb13dfa",
      "filename": "sim/bpf/defs-le.h",
      "status": "added",
      "additions": 383,
      "deletions": 0,
      "changes": 383,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/defs-le.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/defs-le.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/defs-le.h?ref=8c4c18181ea382adf407df235c7991feb0647bab",
      "patch": "@@ -0,0 +1,383 @@\n+/* ISA definitions header for ebpfle.\n+\n+THIS FILE IS MACHINE GENERATED WITH CGEN.\n+\n+Copyright (C) 1996-2020 Free Software Foundation, Inc.\n+\n+This file is part of the GNU simulators.\n+\n+   This file is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   It is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License along\n+   with this program; if not, write to the Free Software Foundation, Inc.,\n+   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.\n+\n+*/\n+\n+#ifndef DEFS_BPFBF_EBPFLE_H\n+#define DEFS_BPFBF_EBPFLE_H\n+\n+/* Instruction argument buffer.  */\n+\n+union sem_fields {\n+  struct { /* no operands */\n+    int empty;\n+  } sfmt_empty;\n+  struct { /*  */\n+    INT f_imm32;\n+    UINT f_srcle;\n+  } sfmt_ldindwle;\n+  struct { /*  */\n+    DI f_imm64;\n+    UINT f_dstle;\n+  } sfmt_lddwle;\n+  struct { /*  */\n+    INT f_imm32;\n+    UINT f_dstle;\n+    HI f_offset16;\n+  } sfmt_stble;\n+  struct { /*  */\n+    UINT f_dstle;\n+    UINT f_srcle;\n+    HI f_offset16;\n+  } sfmt_ldxwle;\n+#if WITH_SCACHE_PBB\n+  /* Writeback handler.  */\n+  struct {\n+    /* Pointer to argbuf entry for insn whose results need writing back.  */\n+    const struct argbuf *abuf;\n+  } write;\n+  /* x-before handler */\n+  struct {\n+    /*const SCACHE *insns[MAX_PARALLEL_INSNS];*/\n+    int first_p;\n+  } before;\n+  /* x-after handler */\n+  struct {\n+    int empty;\n+  } after;\n+  /* This entry is used to terminate each pbb.  */\n+  struct {\n+    /* Number of insns in pbb.  */\n+    int insn_count;\n+    /* Next pbb to execute.  */\n+    SCACHE *next;\n+    SCACHE *branch_target;\n+  } chain;\n+#endif\n+};\n+\n+/* The ARGBUF struct.  */\n+struct argbuf {\n+  /* These are the baseclass definitions.  */\n+  IADDR addr;\n+  const IDESC *idesc;\n+  char trace_p;\n+  char profile_p;\n+  /* ??? Temporary hack for skip insns.  */\n+  char skip_count;\n+  char unused;\n+  /* cpu specific data follows */\n+  union sem semantic;\n+  int written;\n+  union sem_fields fields;\n+};\n+\n+/* A cached insn.\n+\n+   ??? SCACHE used to contain more than just argbuf.  We could delete the\n+   type entirely and always just use ARGBUF, but for future concerns and as\n+   a level of abstraction it is left in.  */\n+\n+struct scache {\n+  struct argbuf argbuf;\n+};\n+\n+/* Macros to simplify extraction, reading and semantic code.\n+   These define and assign the local vars that contain the insn's fields.  */\n+\n+#define EXTRACT_IFMT_EMPTY_VARS \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_EMPTY_CODE \\\n+  length = 0; \\\n+\n+#define EXTRACT_IFMT_ADDILE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_code; \\\n+  UINT f_dstle; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_ADDILE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_ADDRLE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_code; \\\n+  UINT f_dstle; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_ADDRLE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_NEGLE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_code; \\\n+  UINT f_dstle; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_NEGLE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_ENDLELE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_code; \\\n+  UINT f_dstle; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_ENDLELE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_LDDWLE_VARS \\\n+  UINT f_imm64_a; \\\n+  UINT f_imm64_b; \\\n+  UINT f_imm64_c; \\\n+  DI f_imm64; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_dstle; \\\n+  UINT f_op_class; \\\n+  /* Contents of trailing part of insn.  */ \\\n+  UINT word_1; \\\n+  UINT word_2; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_LDDWLE_CODE \\\n+  length = 16; \\\n+  word_1 = GETIMEMUSI (current_cpu, pc + 8); \\\n+  word_2 = GETIMEMUSI (current_cpu, pc + 12); \\\n+  f_imm64_a = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_imm64_b = (0|(EXTRACT_LSB0_UINT (word_1, 32, 31, 32) << 0)); \\\n+  f_imm64_c = (0|(EXTRACT_LSB0_UINT (word_2, 32, 31, 32) << 0)); \\\n+{\\\n+  f_imm64 = ((((((UDI) (UINT) (f_imm64_c))) << (32))) | (((UDI) (UINT) (f_imm64_a))));\\\n+}\\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_LDABSW_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_regs; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_LDABSW_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_regs = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 8) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_LDINDWLE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_dstle; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_LDINDWLE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_LDXWLE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_dstle; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_LDXWLE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_STBLE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_mode; \\\n+  UINT f_op_size; \\\n+  UINT f_dstle; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_STBLE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_mode = EXTRACT_LSB0_LGUINT (insn, 64, 7, 3); \\\n+  f_op_size = EXTRACT_LSB0_LGUINT (insn, 64, 4, 2); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_JEQILE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_code; \\\n+  UINT f_dstle; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_JEQILE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_JEQRLE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_srcle; \\\n+  UINT f_op_code; \\\n+  UINT f_dstle; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_JEQRLE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_srcle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 4) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_dstle = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 11, 4) << 0)); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_CALLLE_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_regs; \\\n+  UINT f_op_code; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_CALLLE_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_regs = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 8) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_JA_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_regs; \\\n+  UINT f_op_code; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_JA_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_regs = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 8) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#define EXTRACT_IFMT_EXIT_VARS \\\n+  INT f_imm32; \\\n+  HI f_offset16; \\\n+  UINT f_regs; \\\n+  UINT f_op_code; \\\n+  UINT f_op_src; \\\n+  UINT f_op_class; \\\n+  unsigned int length;\n+#define EXTRACT_IFMT_EXIT_CODE \\\n+  length = 8; \\\n+  f_imm32 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 63, 32) << 0)); \\\n+  f_offset16 = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 31, 16) << 0)); \\\n+  f_regs = (0|(EXTRACT_LSB0_LGUINT (insn, 64, 15, 8) << 0)); \\\n+  f_op_code = EXTRACT_LSB0_LGUINT (insn, 64, 7, 4); \\\n+  f_op_src = EXTRACT_LSB0_LGUINT (insn, 64, 3, 1); \\\n+  f_op_class = EXTRACT_LSB0_LGUINT (insn, 64, 2, 3); \\\n+\n+#endif /* DEFS_BPFBF_EBPFLE_H */"
    },
    {
      "sha": "12b65c77a131c2b43696242163e81a4ea15cc5c9",
      "filename": "sim/bpf/sem-be.c",
      "status": "added",
      "additions": 3207,
      "deletions": 0,
      "changes": 3207,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/sem-be.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/sem-be.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/sem-be.c?ref=8c4c18181ea382adf407df235c7991feb0647bab"
    },
    {
      "sha": "8bb1debfb7f414098092f494e099e22a8cc08f72",
      "filename": "sim/bpf/sem-le.c",
      "status": "added",
      "additions": 3207,
      "deletions": 0,
      "changes": 3207,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/sem-le.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8c4c18181ea382adf407df235c7991feb0647bab/sim/bpf/sem-le.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/bpf/sem-le.c?ref=8c4c18181ea382adf407df235c7991feb0647bab"
    }
  ]
}