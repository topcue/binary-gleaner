{
  "sha": "5897a389841a67317309213b95bb503d43fbf16c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTg5N2EzODk4NDFhNjczMTczMDkyMTNiOTViYjUwM2Q0M2ZiZjE2Yw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-15T05:54:03Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-05-15T05:59:36Z"
    },
    "message": "display_debug_frames\n\n\t* dwarf.c (display_debug_frames): Delete initial_length_size.\n\tAvoid pointer UB.  Constrain data reads to length given in header.\n\tSanity check cie header length.  Only skip up to next FDE on\n\tfinding augmentation data too long.",
    "tree": {
      "sha": "7d5f9030f7250ec539bfa16dd6a970d93af98cef",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7d5f9030f7250ec539bfa16dd6a970d93af98cef"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5897a389841a67317309213b95bb503d43fbf16c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5897a389841a67317309213b95bb503d43fbf16c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5897a389841a67317309213b95bb503d43fbf16c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5897a389841a67317309213b95bb503d43fbf16c/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c93c4a85406ebd811ec0b29f1dec882cbba56659",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c93c4a85406ebd811ec0b29f1dec882cbba56659",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c93c4a85406ebd811ec0b29f1dec882cbba56659"
    }
  ],
  "stats": {
    "total": 217,
    "additions": 114,
    "deletions": 103
  },
  "files": [
    {
      "sha": "29d4406c61f0dc0bacd2a89b95b642e8877ae1da",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5897a389841a67317309213b95bb503d43fbf16c/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5897a389841a67317309213b95bb503d43fbf16c/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=5897a389841a67317309213b95bb503d43fbf16c",
      "patch": "@@ -1,3 +1,10 @@\n+2021-05-15  Alan Modra  <amodra@gmail.com>\n+\n+\t* dwarf.c (display_debug_frames): Delete initial_length_size.\n+\tAvoid pointer UB.  Constrain data reads to length given in header.\n+\tSanity check cie header length.  Only skip up to next FDE on\n+\tfinding augmentation data too long.\n+\n 2021-05-15  Alan Modra  <amodra@gmail.com>\n \n \t* dwarf.c (read_cie): Add more sanity checks to ensure data"
    },
    {
      "sha": "d2af05acb7ced5b4ef3a56678cd5aae54a0818d0",
      "filename": "binutils/dwarf.c",
      "status": "modified",
      "additions": 107,
      "deletions": 103,
      "changes": 210,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5897a389841a67317309213b95bb503d43fbf16c/binutils/dwarf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5897a389841a67317309213b95bb503d43fbf16c/binutils/dwarf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dwarf.c?ref=5897a389841a67317309213b95bb503d43fbf16c",
      "patch": "@@ -8587,7 +8587,6 @@ display_debug_frames (struct dwarf_section *section,\n       bfd_size_type augmentation_data_len = 0;\n       unsigned int encoded_ptr_size = saved_eh_addr_size;\n       unsigned int offset_size;\n-      unsigned int initial_length_size;\n       bool all_nops;\n       static Frame_Chunk fde_fc;\n \n@@ -8612,32 +8611,29 @@ display_debug_frames (struct dwarf_section *section,\n \t{\n \t  SAFE_BYTE_GET_AND_INC (length, start, 8, end);\n \t  offset_size = 8;\n-\t  initial_length_size = 12;\n \t}\n       else\n-\t{\n-\t  offset_size = 4;\n-\t  initial_length_size = 4;\n-\t}\n+\toffset_size = 4;\n \n-      block_end = saved_start + length + initial_length_size;\n-      if (block_end > end || block_end < start)\n+      if (length > (size_t) (end - start))\n \t{\n \t  warn (\"Invalid length 0x%s in FDE at %#08lx\\n\",\n \t\tdwarf_vmatoa_1 (NULL, length, offset_size),\n \t\t(unsigned long) (saved_start - section_start));\n \t  block_end = end;\n \t}\n+      else\n+\tblock_end = start + length;\n \n-      SAFE_BYTE_GET_AND_INC (cie_id, start, offset_size, end);\n+      SAFE_BYTE_GET_AND_INC (cie_id, start, offset_size, block_end);\n \n       if (is_eh ? (cie_id == 0) : ((offset_size == 4 && cie_id == DW_CIE_ID)\n \t\t\t\t   || (offset_size == 8 && cie_id == DW64_CIE_ID)))\n \t{\n \t  int version;\n \t  unsigned int mreg;\n \n-\t  start = read_cie (start, end, &cie, &version,\n+\t  start = read_cie (start, block_end, &cie, &version,\n \t\t\t    &augmentation_data_len, &augmentation_data);\n \t  /* PR 17512: file: 027-135133-0.005.  */\n \t  if (cie == NULL)\n@@ -8725,11 +8721,13 @@ display_debug_frames (struct dwarf_section *section,\n \t\t      SAFE_BYTE_GET_AND_INC (length, cie_scan, 8, end);\n \t\t      off_size = 8;\n \t\t    }\n-\t\t  if (length != 0)\n+\t\t  if (length != 0 && length <= (size_t) (end - cie_scan))\n \t\t    {\n \t\t      dwarf_vma c_id;\n+\t\t      unsigned char *cie_end = cie_scan + length;\n \n-\t\t      SAFE_BYTE_GET_AND_INC (c_id, cie_scan, off_size, end);\n+\t\t      SAFE_BYTE_GET_AND_INC (c_id, cie_scan, off_size,\n+\t\t\t\t\t     cie_end);\n \t\t      if (is_eh\n \t\t\t  ? c_id == 0\n \t\t\t  : ((off_size == 4 && c_id == DW_CIE_ID)\n@@ -8738,7 +8736,7 @@ display_debug_frames (struct dwarf_section *section,\n \t\t\t  int version;\n \t\t\t  unsigned int mreg;\n \n-\t\t\t  read_cie (cie_scan, end, &cie, &version,\n+\t\t\t  read_cie (cie_scan, cie_end, &cie, &version,\n \t\t\t\t    &augmentation_data_len, &augmentation_data);\n \t\t\t  /* PR 17512: file: 3450-2098-0.004.  */\n \t\t\t  if (cie == NULL)\n@@ -8823,29 +8821,32 @@ display_debug_frames (struct dwarf_section *section,\n \t\t  warn (_(\"Probably corrupt segment size: %d - using 4 instead\\n\"), fc->segment_size);\n \t\t  fc->segment_size = 4;\n \t\t}\n-\t      SAFE_BYTE_GET_AND_INC (segment_selector, start, fc->segment_size, end);\n+\t      SAFE_BYTE_GET_AND_INC (segment_selector, start,\n+\t\t\t\t     fc->segment_size, block_end);\n \t    }\n \n-\t  fc->pc_begin = get_encoded_value (&start, fc->fde_encoding, section, end);\n+\t  fc->pc_begin = get_encoded_value (&start, fc->fde_encoding, section,\n+\t\t\t\t\t    block_end);\n \n \t  /* FIXME: It appears that sometimes the final pc_range value is\n \t     encoded in less than encoded_ptr_size bytes.  See the x86_64\n \t     run of the \"objcopy on compressed debug sections\" test for an\n \t     example of this.  */\n-\t  SAFE_BYTE_GET_AND_INC (fc->pc_range, start, encoded_ptr_size, end);\n+\t  SAFE_BYTE_GET_AND_INC (fc->pc_range, start, encoded_ptr_size,\n+\t\t\t\t block_end);\n \n \t  if (cie->augmentation[0] == 'z')\n \t    {\n-\t      READ_ULEB (augmentation_data_len, start, end);\n+\t      READ_ULEB (augmentation_data_len, start, block_end);\n \t      augmentation_data = start;\n \t      /* PR 17512 file: 722-8446-0.004 and PR 22386.  */\n-\t      if (augmentation_data_len > (bfd_size_type) (end - start))\n+\t      if (augmentation_data_len > (bfd_size_type) (block_end - start))\n \t\t{\n \t\t  warn (_(\"Augmentation data too long: 0x%s, \"\n \t\t\t  \"expected at most %#lx\\n\"),\n \t\t\tdwarf_vmatoa (\"x\", augmentation_data_len),\n-\t\t\t(unsigned long) (end - start));\n-\t\t  start = end;\n+\t\t\t(unsigned long) (block_end - start));\n+\t\t  start = block_end;\n \t\t  augmentation_data = NULL;\n \t\t  augmentation_data_len = 0;\n \t\t}\n@@ -8889,7 +8890,6 @@ display_debug_frames (struct dwarf_section *section,\n \t    {\n \t      unsigned int reg, op, opa;\n \t      unsigned long temp;\n-\t      unsigned char * new_start;\n \n \t      op = *start++;\n \t      opa = op & 0x3f;\n@@ -8903,7 +8903,7 @@ display_debug_frames (struct dwarf_section *section,\n \t\tcase DW_CFA_advance_loc:\n \t\t  break;\n \t\tcase DW_CFA_offset:\n-\t\t  SKIP_ULEB (start, end);\n+\t\t  SKIP_ULEB (start, block_end);\n \t\t  if (frame_need_space (fc, opa) >= 0)\n \t\t    fc->col_type[opa] = DW_CFA_undefined;\n \t\t  break;\n@@ -8912,105 +8912,111 @@ display_debug_frames (struct dwarf_section *section,\n \t\t    fc->col_type[opa] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_set_loc:\n-\t\t  start += encoded_ptr_size;\n+\t\t  if ((size_t) (block_end - start) < encoded_ptr_size)\n+\t\t    start = block_end;\n+\t\t  else\n+\t\t    start += encoded_ptr_size;\n \t\t  break;\n \t\tcase DW_CFA_advance_loc1:\n-\t\t  start += 1;\n+\t\t  if ((size_t) (block_end - start) < 1)\n+\t\t    start = block_end;\n+\t\t  else\n+\t\t    start += 1;\n \t\t  break;\n \t\tcase DW_CFA_advance_loc2:\n-\t\t  start += 2;\n+\t\t  if ((size_t) (block_end - start) < 2)\n+\t\t    start = block_end;\n+\t\t  else\n+\t\t    start += 2;\n \t\t  break;\n \t\tcase DW_CFA_advance_loc4:\n-\t\t  start += 4;\n+\t\t  if ((size_t) (block_end - start) < 4)\n+\t\t    start = block_end;\n+\t\t  else\n+\t\t    start += 4;\n \t\t  break;\n \t\tcase DW_CFA_offset_extended:\n \t\tcase DW_CFA_val_offset:\n-\t\t  READ_ULEB (reg, start, end);\n-\t\t  SKIP_ULEB (start, end);\n+\t\t  READ_ULEB (reg, start, block_end);\n+\t\t  SKIP_ULEB (start, block_end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_restore_extended:\n-\t\t  READ_ULEB (reg, start, end);\n+\t\t  READ_ULEB (reg, start, block_end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_undefined:\n-\t\t  READ_ULEB (reg, start, end);\n+\t\t  READ_ULEB (reg, start, block_end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_same_value:\n-\t\t  READ_ULEB (reg, start, end);\n+\t\t  READ_ULEB (reg, start, block_end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_register:\n-\t\t  READ_ULEB (reg, start, end);\n-\t\t  SKIP_ULEB (start, end);\n+\t\t  READ_ULEB (reg, start, block_end);\n+\t\t  SKIP_ULEB (start, block_end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_def_cfa:\n-\t\t  SKIP_ULEB (start, end);\n-\t\t  SKIP_ULEB (start, end);\n+\t\t  SKIP_ULEB (start, block_end);\n+\t\t  SKIP_ULEB (start, block_end);\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_register:\n-\t\t  SKIP_ULEB (start, end);\n+\t\t  SKIP_ULEB (start, block_end);\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_offset:\n-\t\t  SKIP_ULEB (start, end);\n+\t\t  SKIP_ULEB (start, block_end);\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_expression:\n-\t\t  READ_ULEB (temp, start, end);\n-\t\t  new_start = start + temp;\n-\t\t  if (new_start < start)\n-\t\t    {\n-\t\t      warn (_(\"Corrupt CFA_def expression value: %lu\\n\"), temp);\n-\t\t      start = block_end;\n-\t\t    }\n+\t\t  READ_ULEB (temp, start, block_end);\n+\t\t  if ((size_t) (block_end - start) < temp)\n+\t\t    start = block_end;\n \t\t  else\n-\t\t    start = new_start;\n+\t\t    start += temp;\n \t\t  break;\n \t\tcase DW_CFA_expression:\n \t\tcase DW_CFA_val_expression:\n-\t\t  READ_ULEB (reg, start, end);\n-\t\t  READ_ULEB (temp, start, end);\n-\t\t  new_start = start + temp;\n-\t\t  if (new_start < start)\n-\t\t    {\n-\t\t      /* PR 17512: file:306-192417-0.005.  */\n-\t\t      warn (_(\"Corrupt CFA expression value: %lu\\n\"), temp);\n-\t\t      start = block_end;\n-\t\t    }\n+\t\t  READ_ULEB (reg, start, block_end);\n+\t\t  READ_ULEB (temp, start, block_end);\n+\t\t  if ((size_t) (block_end - start) < temp)\n+\t\t    start = block_end;\n \t\t  else\n-\t\t    start = new_start;\n+\t\t    start += temp;\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_offset_extended_sf:\n \t\tcase DW_CFA_val_offset_sf:\n-\t\t  READ_ULEB (reg, start, end);\n-\t\t  SKIP_SLEB (start, end);\n+\t\t  READ_ULEB (reg, start, block_end);\n+\t\t  SKIP_SLEB (start, block_end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_sf:\n-\t\t  SKIP_ULEB (start, end);\n-\t\t  SKIP_SLEB (start, end);\n+\t\t  SKIP_ULEB (start, block_end);\n+\t\t  SKIP_SLEB (start, block_end);\n \t\t  break;\n \t\tcase DW_CFA_def_cfa_offset_sf:\n-\t\t  SKIP_SLEB (start, end);\n+\t\t  SKIP_SLEB (start, block_end);\n \t\t  break;\n \t\tcase DW_CFA_MIPS_advance_loc8:\n-\t\t  start += 8;\n+\t\t  if ((size_t) (block_end - start) < 8)\n+\t\t    start = block_end;\n+\t\t  else\n+\t\t    start += 8;\n \t\t  break;\n \t\tcase DW_CFA_GNU_args_size:\n-\t\t  SKIP_ULEB (start, end);\n+\t\t  SKIP_ULEB (start, block_end);\n \t\t  break;\n \t\tcase DW_CFA_GNU_negative_offset_extended:\n-\t\t  READ_ULEB (reg, start, end);\n-\t\t  SKIP_ULEB (start, end);\n+\t\t  READ_ULEB (reg, start, block_end);\n+\t\t  SKIP_ULEB (start, block_end);\n \t\t  if (frame_need_space (fc, reg) >= 0)\n \t\t    fc->col_type[reg] = DW_CFA_undefined;\n \t\t  break;\n@@ -9028,7 +9034,6 @@ display_debug_frames (struct dwarf_section *section,\n \n       while (start < block_end)\n \t{\n-\t  unsigned char * tmp;\n \t  unsigned op, opa;\n \t  unsigned long ul, roffs;\n \t  /* Note: It is tempting to use an unsigned long for 'reg' but there\n@@ -9066,7 +9071,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_offset:\n-\t      READ_ULEB (roffs, start, end);\n+\t      READ_ULEB (roffs, start, block_end);\n \t      if (opa >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9104,7 +9109,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_set_loc:\n-\t      vma = get_encoded_value (&start, fc->fde_encoding, section, block_end);\n+\t      vma = get_encoded_value (&start, fc->fde_encoding, section,\n+\t\t\t\t       block_end);\n \t      if (do_debug_frames_interp)\n \t\tframe_display_row (fc, &need_col_headers, &max_regs);\n \t      else\n@@ -9114,7 +9120,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_advance_loc1:\n-\t      SAFE_BYTE_GET_AND_INC (ofs, start, 1, end);\n+\t      SAFE_BYTE_GET_AND_INC (ofs, start, 1, block_end);\n \t      if (do_debug_frames_interp)\n \t\tframe_display_row (fc, &need_col_headers, &max_regs);\n \t      else\n@@ -9153,8 +9159,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_offset_extended:\n-\t      READ_ULEB (reg, start, end);\n-\t      READ_ULEB (roffs, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n+\t      READ_ULEB (roffs, start, block_end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9169,8 +9175,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_val_offset:\n-\t      READ_ULEB (reg, start, end);\n-\t      READ_ULEB (roffs, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n+\t      READ_ULEB (roffs, start, block_end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9185,7 +9191,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_restore_extended:\n-\t      READ_ULEB (reg, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9207,7 +9213,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_undefined:\n-\t      READ_ULEB (reg, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9221,7 +9227,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_same_value:\n-\t      READ_ULEB (reg, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9235,8 +9241,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_register:\n-\t      READ_ULEB (reg, start, end);\n-\t      READ_ULEB (roffs, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n+\t      READ_ULEB (roffs, start, block_end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9299,24 +9305,24 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_def_cfa:\n-\t      READ_ULEB (fc->cfa_reg, start, end);\n-\t      READ_ULEB (fc->cfa_offset, start, end);\n+\t      READ_ULEB (fc->cfa_reg, start, block_end);\n+\t      READ_ULEB (fc->cfa_offset, start, block_end);\n \t      fc->cfa_exp = 0;\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_def_cfa: %s ofs %d\\n\",\n \t\t\tregname (fc->cfa_reg, 0), (int) fc->cfa_offset);\n \t      break;\n \n \t    case DW_CFA_def_cfa_register:\n-\t      READ_ULEB (fc->cfa_reg, start, end);\n+\t      READ_ULEB (fc->cfa_reg, start, block_end);\n \t      fc->cfa_exp = 0;\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_def_cfa_register: %s\\n\",\n \t\t\tregname (fc->cfa_reg, 0));\n \t      break;\n \n \t    case DW_CFA_def_cfa_offset:\n-\t      READ_ULEB (fc->cfa_offset, start, end);\n+\t      READ_ULEB (fc->cfa_offset, start, block_end);\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_def_cfa_offset: %d\\n\", (int) fc->cfa_offset);\n \t      break;\n@@ -9327,8 +9333,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_def_cfa_expression:\n-\t      READ_ULEB (ul, start, end);\n-\t      if (start >= block_end || ul > (unsigned long) (block_end - start))\n+\t      READ_ULEB (ul, start, block_end);\n+\t      if (ul > (size_t) (block_end - start))\n \t\t{\n \t\t  printf (_(\"  DW_CFA_def_cfa_expression: <corrupt len %lu>\\n\"), ul);\n \t\t  break;\n@@ -9345,14 +9351,13 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_expression:\n-\t      READ_ULEB (reg, start, end);\n-\t      READ_ULEB (ul, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n+\t      READ_ULEB (ul, start, block_end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n \t      /* PR 17512: file: 069-133014-0.006.  */\n \t      /* PR 17512: file: 98c02eb4.  */\n-\t      tmp = start + ul;\n-\t      if (start >= block_end || tmp > block_end || tmp < start)\n+\t      if (ul > (size_t) (block_end - start))\n \t\t{\n \t\t  printf (_(\"  DW_CFA_expression: <corrupt len %lu>\\n\"), ul);\n \t\t  break;\n@@ -9367,16 +9372,15 @@ display_debug_frames (struct dwarf_section *section,\n \t\t}\n \t      if (*reg_prefix == '\\0')\n \t\tfc->col_type[reg] = DW_CFA_expression;\n-\t      start = tmp;\n+\t      start += ul;\n \t      break;\n \n \t    case DW_CFA_val_expression:\n-\t      READ_ULEB (reg, start, end);\n-\t      READ_ULEB (ul, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n+\t      READ_ULEB (ul, start, block_end);\n \t      if (reg >= (unsigned int) fc->ncols)\n \t\treg_prefix = bad_reg;\n-\t      tmp = start + ul;\n-\t      if (start >= block_end || tmp > block_end || tmp < start)\n+\t      if (ul > (size_t) (block_end - start))\n \t\t{\n \t\t  printf (\"  DW_CFA_val_expression: <corrupt len %lu>\\n\", ul);\n \t\t  break;\n@@ -9391,12 +9395,12 @@ display_debug_frames (struct dwarf_section *section,\n \t\t}\n \t      if (*reg_prefix == '\\0')\n \t\tfc->col_type[reg] = DW_CFA_val_expression;\n-\t      start = tmp;\n+\t      start += ul;\n \t      break;\n \n \t    case DW_CFA_offset_extended_sf:\n-\t      READ_ULEB (reg, start, end);\n-\t      READ_SLEB (l, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n+\t      READ_SLEB (l, start, block_end);\n \t      if (frame_need_space (fc, reg) < 0)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9411,8 +9415,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_val_offset_sf:\n-\t      READ_ULEB (reg, start, end);\n-\t      READ_SLEB (l, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n+\t      READ_SLEB (l, start, block_end);\n \t      if (frame_need_space (fc, reg) < 0)\n \t\treg_prefix = bad_reg;\n \t      if (! do_debug_frames_interp || *reg_prefix != '\\0')\n@@ -9427,8 +9431,8 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_def_cfa_sf:\n-\t      READ_ULEB (fc->cfa_reg, start, end);\n-\t      READ_ULEB (fc->cfa_offset, start, end);\n+\t      READ_ULEB (fc->cfa_reg, start, block_end);\n+\t      READ_ULEB (fc->cfa_offset, start, block_end);\n \t      fc->cfa_offset = fc->cfa_offset * fc->data_factor;\n \t      fc->cfa_exp = 0;\n \t      if (! do_debug_frames_interp)\n@@ -9437,7 +9441,7 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_def_cfa_offset_sf:\n-\t      READ_ULEB (fc->cfa_offset, start, end);\n+\t      READ_ULEB (fc->cfa_offset, start, block_end);\n \t      fc->cfa_offset *= fc->data_factor;\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_def_cfa_offset_sf: %d\\n\", (int) fc->cfa_offset);\n@@ -9462,14 +9466,14 @@ display_debug_frames (struct dwarf_section *section,\n \t      break;\n \n \t    case DW_CFA_GNU_args_size:\n-\t      READ_ULEB (ul, start, end);\n+\t      READ_ULEB (ul, start, block_end);\n \t      if (! do_debug_frames_interp)\n \t\tprintf (\"  DW_CFA_GNU_args_size: %ld\\n\", ul);\n \t      break;\n \n \t    case DW_CFA_GNU_negative_offset_extended:\n-\t      READ_ULEB (reg, start, end);\n-\t      READ_SLEB (l, start, end);\n+\t      READ_ULEB (reg, start, block_end);\n+\t      READ_SLEB (l, start, block_end);\n \t      l = - l;\n \t      if (frame_need_space (fc, reg) < 0)\n \t\treg_prefix = bad_reg;"
    }
  ]
}