{
  "sha": "b9249c461c72b35dd9b6f274406c336f6a68ae98",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjkyNDljNDYxYzcyYjM1ZGQ5YjZmMjc0NDA2YzMzNmY2YTY4YWU5OA==",
  "commit": {
    "author": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2015-05-21T15:16:45Z"
    },
    "committer": {
      "name": "Mike Frysinger",
      "email": "vapier@gentoo.org",
      "date": "2021-02-05T00:02:19Z"
    },
    "message": "sim: riscv: new port\n\nThis is a hand-written implementation that should have fairly complete\ncoverage for the base integer instruction set (\"i\"), and for the atomic\n(\"a\") and integer multiplication+division (\"m\") extensions.  It also\ncovers 32-bit & 64-bit targets.\n\nThe unittest coverage is a bit weak atm, but should get better.",
    "tree": {
      "sha": "2f2314445c8c95e8dc1c3c8de6d824e9042b15fe",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2f2314445c8c95e8dc1c3c8de6d824e9042b15fe"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b9249c461c72b35dd9b6f274406c336f6a68ae98",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b9249c461c72b35dd9b6f274406c336f6a68ae98",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b9249c461c72b35dd9b6f274406c336f6a68ae98",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b9249c461c72b35dd9b6f274406c336f6a68ae98/comments",
  "author": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "vapier",
    "id": 176950,
    "node_id": "MDQ6VXNlcjE3Njk1MA==",
    "avatar_url": "https://avatars.githubusercontent.com/u/176950?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/vapier",
    "html_url": "https://github.com/vapier",
    "followers_url": "https://api.github.com/users/vapier/followers",
    "following_url": "https://api.github.com/users/vapier/following{/other_user}",
    "gists_url": "https://api.github.com/users/vapier/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/vapier/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/vapier/subscriptions",
    "organizations_url": "https://api.github.com/users/vapier/orgs",
    "repos_url": "https://api.github.com/users/vapier/repos",
    "events_url": "https://api.github.com/users/vapier/events{/privacy}",
    "received_events_url": "https://api.github.com/users/vapier/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a9ab6e2ea07829d89b97d1f47ecb524c251252e7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a9ab6e2ea07829d89b97d1f47ecb524c251252e7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a9ab6e2ea07829d89b97d1f47ecb524c251252e7"
    }
  ],
  "stats": {
    "total": 18290,
    "additions": 18290,
    "deletions": 0
  },
  "files": [
    {
      "sha": "6130371a447d67fc2e15c44e31605d83d0246ae1",
      "filename": "sim/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/ChangeLog?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -1,3 +1,8 @@\n+2021-02-04  Mike Frysinger  <vapier@gentoo.org>\n+\n+\t* configure.tgt (sim_arch): Add entry for riscv*-*-*.\n+\t* configure: Regenerate.\n+\n 2021-01-30  Mike Frysinger  <vapier@gentoo.org>\n \n \t* Makefile.in (nltvals): Change to gennltvals.py."
    },
    {
      "sha": "d1a15263c7513f054cc6fab3dd49192e065e2d87",
      "filename": "sim/common/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/common/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/common/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/common/ChangeLog?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -1,3 +1,9 @@\n+2021-02-04  Mike Frysinger  <vapier@gentoo.org>\n+\n+\t* gennltvals.py (TARGETS): Add riscv.\n+\t(TARGET_DIRS): Likewise.\n+\t* nltvals.def: Regenerate from the latest libgloss sources.\n+\n 2021-01-31  Mike Frysinger  <vapier@gentoo.org>\n \n \t* cgen-trace.c (cgen_trace_insn): Add \"%s\" argument."
    },
    {
      "sha": "23b218728c2b9bb4645af5aaca162ff86dad6a67",
      "filename": "sim/common/gennltvals.py",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/common/gennltvals.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/common/gennltvals.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/common/gennltvals.py?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -50,6 +50,7 @@\n     'd10v': 'newlib/libc/sys/d10v/sys',\n     'i960': 'libgloss/i960',\n     'mcore': 'libgloss/mcore',\n+    'riscv': 'libgloss/riscv/machine',\n     'v850': 'libgloss/v850/sys',\n }\n TARGETS = {\n@@ -66,6 +67,7 @@\n     'mn10300',\n     'msp430',\n     'pru',\n+    'riscv',\n     'sparc',\n     'v850',\n }"
    },
    {
      "sha": "6f93316ea0226b08a00c9406ab67f5ee4a20c2e8",
      "filename": "sim/common/nltvals.def",
      "status": "modified",
      "additions": 48,
      "deletions": 0,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/common/nltvals.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/common/nltvals.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/common/nltvals.def?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -546,6 +546,54 @@\n /* end pru sys target macros */\n #endif\n #endif\n+#ifdef NL_TARGET_riscv\n+#ifdef sys_defs\n+/* from syscall.h */\n+/* begin riscv sys target macros */\n+ { \"SYS_access\", 1033 },\n+ { \"SYS_brk\", 214 },\n+ { \"SYS_chdir\", 49 },\n+ { \"SYS_close\", 57 },\n+ { \"SYS_dup\", 23 },\n+ { \"SYS_exit\", 93 },\n+ { \"SYS_exit_group\", 94 },\n+ { \"SYS_faccessat\", 48 },\n+ { \"SYS_fcntl\", 25 },\n+ { \"SYS_fstat\", 80 },\n+ { \"SYS_fstatat\", 79 },\n+ { \"SYS_getcwd\", 17 },\n+ { \"SYS_getdents\", 61 },\n+ { \"SYS_getegid\", 177 },\n+ { \"SYS_geteuid\", 175 },\n+ { \"SYS_getgid\", 176 },\n+ { \"SYS_getmainvars\", 2011 },\n+ { \"SYS_getpid\", 172 },\n+ { \"SYS_gettimeofday\", 169 },\n+ { \"SYS_getuid\", 174 },\n+ { \"SYS_kill\", 129 },\n+ { \"SYS_link\", 1025 },\n+ { \"SYS_lseek\", 62 },\n+ { \"SYS_lstat\", 1039 },\n+ { \"SYS_mkdir\", 1030 },\n+ { \"SYS_mmap\", 222 },\n+ { \"SYS_mremap\", 216 },\n+ { \"SYS_munmap\", 215 },\n+ { \"SYS_open\", 1024 },\n+ { \"SYS_openat\", 56 },\n+ { \"SYS_pread\", 67 },\n+ { \"SYS_pwrite\", 68 },\n+ { \"SYS_read\", 63 },\n+ { \"SYS_rt_sigaction\", 134 },\n+ { \"SYS_stat\", 1038 },\n+ { \"SYS_time\", 1062 },\n+ { \"SYS_times\", 153 },\n+ { \"SYS_uname\", 160 },\n+ { \"SYS_unlink\", 1026 },\n+ { \"SYS_write\", 64 },\n+ { \"SYS_writev\", 66 },\n+/* end riscv sys target macros */\n+#endif\n+#endif\n #ifdef NL_TARGET_sparc\n #ifdef sys_defs\n /* from syscall.h */"
    },
    {
      "sha": "1f1ce75f699d1677c1e00d9cd6834e2c4d1ff19d",
      "filename": "sim/configure",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/configure?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -690,6 +690,7 @@ moxie\n msp430\n or1k\n pru\n+riscv\n rl78\n rx\n sh\n@@ -4028,6 +4029,13 @@ subdirs=\"$subdirs aarch64\"\n   subdirs=\"$subdirs pru\"\n \n \n+       ;;\n+   riscv*-*-*)\n+\n+  sim_arch=riscv\n+  subdirs=\"$subdirs riscv\"\n+\n+\n        ;;\n    rl78-*-*)\n "
    },
    {
      "sha": "5f201060f1c1a90f4267b7ef6b9c93575a84e10b",
      "filename": "sim/configure.tgt",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/configure.tgt",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/configure.tgt",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/configure.tgt?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -85,6 +85,9 @@ case \"${target}\" in\n    pru*-*-*)\n        SIM_ARCH(pru)\n        ;;\n+   riscv*-*-*)\n+       SIM_ARCH(riscv)\n+       ;;\n    rl78-*-*)\n        SIM_ARCH(rl78)\n        ;;"
    },
    {
      "sha": "e55363d8938f05d9c43def07da8f457b7cd36149",
      "filename": "sim/riscv/ChangeLog",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/ChangeLog?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,5 @@\n+2021-02-04  Mike Frysinger  <vapier@gentoo.org>\n+\n+\t* Makefile.in, configure.ac, interp.c, machs.c, machs.h,\n+\tmodel_list.def, sim-main.c, sim-main.h: New files.\n+\t* aclocal.m4, config.in, configure: Regenerated."
    },
    {
      "sha": "17cb288eba3d3a7df5f3aca65bc4c5ea449540e3",
      "filename": "sim/riscv/Makefile.in",
      "status": "added",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/Makefile.in?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,30 @@\n+#    Makefile template for Configure for the example basic simulator.\n+#    Copyright (C) 2005-2021 Free Software Foundation, Inc.\n+#    Written by Mike Frysinger.\n+#\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This selects the newlib/libgloss syscall definitions.\n+NL_TARGET = -DNL_TARGET_riscv\n+\n+## COMMON_PRE_CONFIG_FRAG\n+\n+SIM_OBJS = \\\n+\t$(SIM_NEW_COMMON_OBJS) \\\n+\tsim-resume.o \\\n+\tinterp.o \\\n+\tmachs.o \\\n+\tsim-main.o\n+\n+## COMMON_POST_CONFIG_FRAG"
    },
    {
      "sha": "e9f11c775c310ba5c0051681d74d579dd6f39321",
      "filename": "sim/riscv/aclocal.m4",
      "status": "added",
      "additions": 119,
      "deletions": 0,
      "changes": 119,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/aclocal.m4",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/aclocal.m4",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/aclocal.m4?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,119 @@\n+# generated automatically by aclocal 1.15.1 -*- Autoconf -*-\n+\n+# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+# PARTICULAR PURPOSE.\n+\n+m4_ifndef([AC_CONFIG_MACRO_DIRS], [m4_defun([_AM_CONFIG_MACRO_DIRS], [])m4_defun([AC_CONFIG_MACRO_DIRS], [_AM_CONFIG_MACRO_DIRS($@)])])\n+# AM_CONDITIONAL                                            -*- Autoconf -*-\n+\n+# Copyright (C) 1997-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_CONDITIONAL(NAME, SHELL-CONDITION)\n+# -------------------------------------\n+# Define a conditional.\n+AC_DEFUN([AM_CONDITIONAL],\n+[AC_PREREQ([2.52])dnl\n+ m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],\n+       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl\n+AC_SUBST([$1_TRUE])dnl\n+AC_SUBST([$1_FALSE])dnl\n+_AM_SUBST_NOTMAKE([$1_TRUE])dnl\n+_AM_SUBST_NOTMAKE([$1_FALSE])dnl\n+m4_define([_AM_COND_VALUE_$1], [$2])dnl\n+if $2; then\n+  $1_TRUE=\n+  $1_FALSE='#'\n+else\n+  $1_TRUE='#'\n+  $1_FALSE=\n+fi\n+AC_CONFIG_COMMANDS_PRE(\n+[if test -z \"${$1_TRUE}\" && test -z \"${$1_FALSE}\"; then\n+  AC_MSG_ERROR([[conditional \"$1\" was never defined.\n+Usually this means the macro was only invoked conditionally.]])\n+fi])])\n+\n+# Copyright (C) 2003-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# Check whether the underlying file-system supports filenames\n+# with a leading dot.  For instance MS-DOS doesn't.\n+AC_DEFUN([AM_SET_LEADING_DOT],\n+[rm -rf .tst 2>/dev/null\n+mkdir .tst 2>/dev/null\n+if test -d .tst; then\n+  am__leading_dot=.\n+else\n+  am__leading_dot=_\n+fi\n+rmdir .tst 2>/dev/null\n+AC_SUBST([am__leading_dot])])\n+\n+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-\n+# From Jim Meyering\n+\n+# Copyright (C) 1996-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# AM_MAINTAINER_MODE([DEFAULT-MODE])\n+# ----------------------------------\n+# Control maintainer-specific portions of Makefiles.\n+# Default is to disable them, unless 'enable' is passed literally.\n+# For symmetry, 'disable' may be passed as well.  Anyway, the user\n+# can override the default with the --enable/--disable switch.\n+AC_DEFUN([AM_MAINTAINER_MODE],\n+[m4_case(m4_default([$1], [disable]),\n+       [enable], [m4_define([am_maintainer_other], [disable])],\n+       [disable], [m4_define([am_maintainer_other], [enable])],\n+       [m4_define([am_maintainer_other], [enable])\n+        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])\n+AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n+  dnl maintainer-mode's default is 'disable' unless 'enable' is passed\n+  AC_ARG_ENABLE([maintainer-mode],\n+    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],\n+      am_maintainer_other[ make rules and dependencies not useful\n+      (and sometimes confusing) to the casual installer])],\n+    [USE_MAINTAINER_MODE=$enableval],\n+    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))\n+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])\n+  AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])\n+  MAINT=$MAINTAINER_MODE_TRUE\n+  AC_SUBST([MAINT])dnl\n+]\n+)\n+\n+# Copyright (C) 2006-2017 Free Software Foundation, Inc.\n+#\n+# This file is free software; the Free Software Foundation\n+# gives unlimited permission to copy and/or distribute it,\n+# with or without modifications, as long as this notice is preserved.\n+\n+# _AM_SUBST_NOTMAKE(VARIABLE)\n+# ---------------------------\n+# Prevent Automake from outputting VARIABLE = @VARIABLE@ in Makefile.in.\n+# This macro is traced by Automake.\n+AC_DEFUN([_AM_SUBST_NOTMAKE])\n+\n+# AM_SUBST_NOTMAKE(VARIABLE)\n+# --------------------------\n+# Public sister of _AM_SUBST_NOTMAKE.\n+AC_DEFUN([AM_SUBST_NOTMAKE], [_AM_SUBST_NOTMAKE($@)])\n+"
    },
    {
      "sha": "cb5ea1b01c95768650c6885bdacf41f90c81f8a9",
      "filename": "sim/riscv/config.in",
      "status": "added",
      "additions": 242,
      "deletions": 0,
      "changes": 242,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/config.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/config.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/config.in?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,242 @@\n+/* config.in.  Generated from configure.ac by autoheader.  */\n+\n+/* Define if building universal (internal helper macro) */\n+#undef AC_APPLE_UNIVERSAL_BUILD\n+\n+/* Sim debug setting */\n+#undef DEBUG\n+\n+/* Define to 1 if translation of program messages to the user's native\n+   language is requested. */\n+#undef ENABLE_NLS\n+\n+/* Define to 1 if you have the <dlfcn.h> header file. */\n+#undef HAVE_DLFCN_H\n+\n+/* Define to 1 if you have the <fcntl.h> header file. */\n+#undef HAVE_FCNTL_H\n+\n+/* Define to 1 if you have the <fpu_control.h> header file. */\n+#undef HAVE_FPU_CONTROL_H\n+\n+/* Define to 1 if you have the `ftruncate' function. */\n+#undef HAVE_FTRUNCATE\n+\n+/* Define to 1 if you have the `getrusage' function. */\n+#undef HAVE_GETRUSAGE\n+\n+/* Define to 1 if you have the <inttypes.h> header file. */\n+#undef HAVE_INTTYPES_H\n+\n+/* Define to 1 if you have the `nsl' library (-lnsl). */\n+#undef HAVE_LIBNSL\n+\n+/* Define to 1 if you have the `socket' library (-lsocket). */\n+#undef HAVE_LIBSOCKET\n+\n+/* Define to 1 if you have the `lstat' function. */\n+#undef HAVE_LSTAT\n+\n+/* Define to 1 if you have the <memory.h> header file. */\n+#undef HAVE_MEMORY_H\n+\n+/* Define to 1 if you have the `mmap' function. */\n+#undef HAVE_MMAP\n+\n+/* Define to 1 if you have the `munmap' function. */\n+#undef HAVE_MUNMAP\n+\n+/* Define to 1 if you have the `posix_fallocate' function. */\n+#undef HAVE_POSIX_FALLOCATE\n+\n+/* Define to 1 if you have the `sigaction' function. */\n+#undef HAVE_SIGACTION\n+\n+/* Define to 1 if the system has the type `socklen_t'. */\n+#undef HAVE_SOCKLEN_T\n+\n+/* Define to 1 if you have the <stdint.h> header file. */\n+#undef HAVE_STDINT_H\n+\n+/* Define to 1 if you have the <stdlib.h> header file. */\n+#undef HAVE_STDLIB_H\n+\n+/* Define to 1 if you have the <strings.h> header file. */\n+#undef HAVE_STRINGS_H\n+\n+/* Define to 1 if you have the <string.h> header file. */\n+#undef HAVE_STRING_H\n+\n+/* Define to 1 if `st_atime' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_ATIME\n+\n+/* Define to 1 if `st_blksize' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_BLKSIZE\n+\n+/* Define to 1 if `st_blocks' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_BLOCKS\n+\n+/* Define to 1 if `st_ctime' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_CTIME\n+\n+/* Define to 1 if `st_dev' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_DEV\n+\n+/* Define to 1 if `st_gid' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_GID\n+\n+/* Define to 1 if `st_ino' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_INO\n+\n+/* Define to 1 if `st_mode' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_MODE\n+\n+/* Define to 1 if `st_mtime' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_MTIME\n+\n+/* Define to 1 if `st_nlink' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_NLINK\n+\n+/* Define to 1 if `st_rdev' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_RDEV\n+\n+/* Define to 1 if `st_size' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_SIZE\n+\n+/* Define to 1 if `st_uid' is a member of `struct stat'. */\n+#undef HAVE_STRUCT_STAT_ST_UID\n+\n+/* Define to 1 if you have the <sys/mman.h> header file. */\n+#undef HAVE_SYS_MMAN_H\n+\n+/* Define to 1 if you have the <sys/resource.h> header file. */\n+#undef HAVE_SYS_RESOURCE_H\n+\n+/* Define to 1 if you have the <sys/stat.h> header file. */\n+#undef HAVE_SYS_STAT_H\n+\n+/* Define to 1 if you have the <sys/times.h> header file. */\n+#undef HAVE_SYS_TIMES_H\n+\n+/* Define to 1 if you have the <sys/time.h> header file. */\n+#undef HAVE_SYS_TIME_H\n+\n+/* Define to 1 if you have the <sys/types.h> header file. */\n+#undef HAVE_SYS_TYPES_H\n+\n+/* Define to 1 if you have the `time' function. */\n+#undef HAVE_TIME\n+\n+/* Define to 1 if you have the `truncate' function. */\n+#undef HAVE_TRUNCATE\n+\n+/* Define to 1 if you have the <unistd.h> header file. */\n+#undef HAVE_UNISTD_H\n+\n+/* Define to 1 if you have the <windows.h> header file. */\n+#undef HAVE_WINDOWS_H\n+\n+/* Define to 1 if you have the `__setfpucw' function. */\n+#undef HAVE___SETFPUCW\n+\n+/* Define to the sub-directory in which libtool stores uninstalled libraries.\n+   */\n+#undef LT_OBJDIR\n+\n+/* Name of this package. */\n+#undef PACKAGE\n+\n+/* Define to the address where bug reports for this package should be sent. */\n+#undef PACKAGE_BUGREPORT\n+\n+/* Define to the full name of this package. */\n+#undef PACKAGE_NAME\n+\n+/* Define to the full name and version of this package. */\n+#undef PACKAGE_STRING\n+\n+/* Define to the one symbol short name of this package. */\n+#undef PACKAGE_TARNAME\n+\n+/* Define to the home page for this package. */\n+#undef PACKAGE_URL\n+\n+/* Define to the version of this package. */\n+#undef PACKAGE_VERSION\n+\n+/* Additional package description */\n+#undef PKGVERSION\n+\n+/* Sim profile settings */\n+#undef PROFILE\n+\n+/* Bug reporting address */\n+#undef REPORT_BUGS_TO\n+\n+/* Define as the return type of signal handlers (`int' or `void'). */\n+#undef RETSIGTYPE\n+\n+/* Define to 1 if you have the ANSI C header files. */\n+#undef STDC_HEADERS\n+\n+/* Enable extensions on AIX 3, Interix.  */\n+#ifndef _ALL_SOURCE\n+# undef _ALL_SOURCE\n+#endif\n+/* Enable GNU extensions on systems that have them.  */\n+#ifndef _GNU_SOURCE\n+# undef _GNU_SOURCE\n+#endif\n+/* Enable threading extensions on Solaris.  */\n+#ifndef _POSIX_PTHREAD_SEMANTICS\n+# undef _POSIX_PTHREAD_SEMANTICS\n+#endif\n+/* Enable extensions on HP NonStop.  */\n+#ifndef _TANDEM_SOURCE\n+# undef _TANDEM_SOURCE\n+#endif\n+/* Enable general extensions on Solaris.  */\n+#ifndef __EXTENSIONS__\n+# undef __EXTENSIONS__\n+#endif\n+\n+\n+/* Sim assert settings */\n+#undef WITH_ASSERT\n+\n+/* Sim debug setting */\n+#undef WITH_DEBUG\n+\n+/* Sim default environment */\n+#undef WITH_ENVIRONMENT\n+\n+/* Sim profile settings */\n+#undef WITH_PROFILE\n+\n+/* How to route I/O */\n+#undef WITH_STDIO\n+\n+/* Sim trace settings */\n+#undef WITH_TRACE\n+\n+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n+   significant byte first (like Motorola and SPARC, unlike Intel). */\n+#if defined AC_APPLE_UNIVERSAL_BUILD\n+# if defined __BIG_ENDIAN__\n+#  define WORDS_BIGENDIAN 1\n+# endif\n+#else\n+# ifndef WORDS_BIGENDIAN\n+#  undef WORDS_BIGENDIAN\n+# endif\n+#endif\n+\n+/* Define to 1 if on MINIX. */\n+#undef _MINIX\n+\n+/* Define to 2 if the system does not provide POSIX.1 features except with\n+   this defined. */\n+#undef _POSIX_1_SOURCE\n+\n+/* Define to 1 if you need to in order for `stat' and other things to work. */\n+#undef _POSIX_SOURCE"
    },
    {
      "sha": "8236dc35c12a1eaf93a21d3b89c1166f474764b0",
      "filename": "sim/riscv/configure",
      "status": "added",
      "additions": 16145,
      "deletions": 0,
      "changes": 16145,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/configure?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98"
    },
    {
      "sha": "6d5dce9175047376633f2a36baf7eefdc182f8a0",
      "filename": "sim/riscv/configure.ac",
      "status": "added",
      "additions": 28,
      "deletions": 0,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/configure.ac?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,28 @@\n+dnl Process this file with autoconf to produce a configure script.\n+AC_INIT(Makefile.in)\n+sinclude(../common/acinclude.m4)\n+\n+SIM_AC_COMMON\n+\n+SIM_AC_OPTION_ENDIAN(LITTLE)\n+SIM_AC_OPTION_ALIGNMENT(NONSTRICT_ALIGNMENT)\n+SIM_AC_OPTION_ENVIRONMENT\n+SIM_AC_OPTION_WARNINGS\n+\n+# Select the default model for the target.\n+riscv_model=\n+case \"${target}\" in\n+riscv32*) riscv_model=\"RV32G\" ;;\n+riscv*) riscv_model=\"RV64G\" ;;\n+esac\n+SIM_AC_OPTION_DEFAULT_MODEL(${riscv_model})\n+\n+# Select the bitsize of the target.\n+riscv_addr_bitsize=\n+case \"${target}\" in\n+riscv32*) riscv_addr_bitsize=32 ;;\n+riscv*) riscv_addr_bitsize=64 ;;\n+esac\n+SIM_AC_OPTION_BITSIZE($riscv_addr_bitsize)\n+\n+SIM_AC_OUTPUT"
    },
    {
      "sha": "1bf60a43aec40579184a4673cbe48f269d6968d4",
      "filename": "sim/riscv/interp.c",
      "status": "added",
      "additions": 153,
      "deletions": 0,
      "changes": 153,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/interp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/interp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/interp.c?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,153 @@\n+/* RISC-V simulator.\n+\n+   Copyright (C) 2005-2021 Free Software Foundation, Inc.\n+   Contributed by Mike Frysinger.\n+\n+   This file is part of simulators.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+\n+#include \"sim-main.h\"\n+#include \"sim-options.h\"\n+\f\n+void\n+sim_engine_run (SIM_DESC sd,\n+\t\tint next_cpu_nr, /* ignore  */\n+\t\tint nr_cpus, /* ignore  */\n+\t\tint siggnal) /* ignore  */\n+{\n+  SIM_CPU *cpu;\n+\n+  SIM_ASSERT (STATE_MAGIC (sd) == SIM_MAGIC_NUMBER);\n+\n+  cpu = STATE_CPU (sd, 0);\n+\n+  while (1)\n+    {\n+      step_once (cpu);\n+      if (sim_events_tick (sd))\n+\tsim_events_process (sd);\n+    }\n+}\n+\f\n+static void\n+free_state (SIM_DESC sd)\n+{\n+  if (STATE_MODULES (sd) != NULL)\n+    sim_module_uninstall (sd);\n+  sim_cpu_free_all (sd);\n+  sim_state_free (sd);\n+}\n+\n+SIM_DESC\n+sim_open (SIM_OPEN_KIND kind, host_callback *callback,\n+\t  struct bfd *abfd, char * const *argv)\n+{\n+  char c;\n+  int i;\n+  SIM_DESC sd = sim_state_alloc (kind, callback);\n+\n+  /* The cpu data is kept in a separately allocated chunk of memory.  */\n+  if (sim_cpu_alloc_all (sd, 1, /*cgen_cpu_max_extra_bytes ()*/0) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  if (sim_pre_argv_init (sd, argv[0]) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  /* XXX: Default to the Virtual environment.  */\n+  if (STATE_ENVIRONMENT (sd) == ALL_ENVIRONMENT)\n+    STATE_ENVIRONMENT (sd) = VIRTUAL_ENVIRONMENT;\n+\n+  /* The parser will print an error message for us, so we silently return.  */\n+  if (sim_parse_args (sd, argv) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  /* Check for/establish the a reference program image.  */\n+  if (sim_analyze_program (sd,\n+\t\t\t   (STATE_PROG_ARGV (sd) != NULL\n+\t\t\t    ? *STATE_PROG_ARGV (sd)\n+\t\t\t    : NULL), abfd) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  /* Establish any remaining configuration options.  */\n+  if (sim_config (sd) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  if (sim_post_argv_init (sd) != SIM_RC_OK)\n+    {\n+      free_state (sd);\n+      return 0;\n+    }\n+\n+  /* CPU specific initialization.  */\n+  for (i = 0; i < MAX_NR_PROCESSORS; ++i)\n+    {\n+      SIM_CPU *cpu = STATE_CPU (sd, i);\n+\n+      initialize_cpu (sd, cpu, i);\n+    }\n+\n+  /* Allocate external memory if none specified by user.\n+     Use address 4 here in case the user wanted address 0 unmapped.  */\n+  if (sim_core_read_buffer (sd, NULL, read_map, &c, 4, 1) == 0)\n+    sim_do_commandf (sd, \"memory-size %#x\", DEFAULT_MEM_SIZE);\n+\n+  return sd;\n+}\n+\f\n+SIM_RC\n+sim_create_inferior (SIM_DESC sd, struct bfd *abfd,\n+\t\t     char * const *argv, char * const *env)\n+{\n+  SIM_CPU *cpu = STATE_CPU (sd, 0);\n+  SIM_ADDR addr;\n+\n+  /* Set the PC.  */\n+  if (abfd != NULL)\n+    addr = bfd_get_start_address (abfd);\n+  else\n+    addr = 0;\n+  sim_pc_set (cpu, addr);\n+\n+  /* Standalone mode (i.e. `run`) will take care of the argv for us in\n+     sim_open() -> sim_parse_args().  But in debug mode (i.e. 'target sim'\n+     with `gdb`), we need to handle it because the user can change the\n+     argv on the fly via gdb's 'run'.  */\n+  if (STATE_PROG_ARGV (sd) != argv)\n+    {\n+      freeargv (STATE_PROG_ARGV (sd));\n+      STATE_PROG_ARGV (sd) = dupargv (argv);\n+    }\n+\n+  initialize_env (sd, (void *)argv, (void *)env);\n+\n+  return SIM_RC_OK;\n+}"
    },
    {
      "sha": "853a3afb42f61a07bb475708df925a213391a43e",
      "filename": "sim/riscv/machs.c",
      "status": "added",
      "additions": 125,
      "deletions": 0,
      "changes": 125,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/machs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/machs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/machs.c?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,125 @@\n+/* RISC-V simulator.\n+\n+   Copyright (C) 2005-2021 Free Software Foundation, Inc.\n+   Contributed by Mike Frysinger.\n+\n+   This file is part of simulators.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+\n+#include \"sim-main.h\"\n+\n+static void\n+riscv_model_init (SIM_CPU *cpu)\n+{\n+}\n+\n+static void\n+riscv_init_cpu (SIM_CPU *cpu)\n+{\n+}\n+\n+static void\n+riscv_prepare_run (SIM_CPU *cpu)\n+{\n+}\n+\n+static const SIM_MACH_IMP_PROPERTIES riscv_imp_properties =\n+{\n+  sizeof (SIM_CPU),\n+  0,\n+};\n+\n+#if WITH_TARGET_WORD_BITSIZE >= 32\n+\n+static const SIM_MACH rv32i_mach;\n+\n+static const SIM_MODEL rv32_models[] =\n+{\n+#define M(ext) { \"RV32\"#ext, &rv32i_mach, MODEL_RV32##ext, NULL, riscv_model_init },\n+#include \"model_list.def\"\n+#undef M\n+  { 0, NULL, 0, NULL, NULL, }\n+};\n+\n+static const SIM_MACH rv32i_mach =\n+{\n+  \"rv32i\", \"riscv:rv32\", MACH_RV32I,\n+  32, 32, &rv32_models[0], &riscv_imp_properties,\n+  riscv_init_cpu,\n+  riscv_prepare_run\n+};\n+\n+#endif\n+\n+#if WITH_TARGET_WORD_BITSIZE >= 64\n+\n+static const SIM_MACH rv64i_mach;\n+\n+static const SIM_MODEL rv64_models[] =\n+{\n+#define M(ext) { \"RV64\"#ext, &rv64i_mach, MODEL_RV64##ext, NULL, riscv_model_init },\n+#include \"model_list.def\"\n+#undef M\n+  { 0, NULL, 0, NULL, NULL, }\n+};\n+\n+static const SIM_MACH rv64i_mach =\n+{\n+  \"rv64i\", \"riscv:rv64\", MACH_RV64I,\n+  64, 64, &rv64_models[0], &riscv_imp_properties,\n+  riscv_init_cpu,\n+  riscv_prepare_run\n+};\n+\n+#endif\n+\n+#if WITH_TARGET_WORD_BITSIZE >= 128\n+\n+static const SIM_MACH rv128i_mach;\n+\n+static const SIM_MODEL rv128_models[] =\n+{\n+#define M(ext) { \"RV128\"#ext, &rv128i_mach, MODEL_RV128##ext, NULL, riscv_model_init },\n+#include \"model_list.def\"\n+#undef M\n+  { 0, NULL, 0, NULL, NULL, }\n+};\n+\n+static const SIM_MACH rv128i_mach =\n+{\n+  \"rv128i\", \"riscv:rv128\", MACH_RV128I,\n+  128, 128, &rv128_models[0], &riscv_imp_properties,\n+  riscv_init_cpu,\n+  riscv_prepare_run\n+};\n+\n+#endif\n+\n+/* Order matters here.  */\n+const SIM_MACH *sim_machs[] =\n+{\n+#if WITH_TARGET_WORD_BITSIZE >= 128\n+  &rv128i_mach,\n+#endif\n+#if WITH_TARGET_WORD_BITSIZE >= 64\n+  &rv64i_mach,\n+#endif\n+#if WITH_TARGET_WORD_BITSIZE >= 32\n+  &rv32i_mach,\n+#endif\n+  NULL\n+};"
    },
    {
      "sha": "903488bc7650503bdf634e4fc7efb528ec20838b",
      "filename": "sim/riscv/machs.h",
      "status": "added",
      "additions": 45,
      "deletions": 0,
      "changes": 45,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/machs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/machs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/machs.h?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,45 @@\n+/* RISC-V simulator.\n+\n+   Copyright (C) 2005-2021 Free Software Foundation, Inc.\n+   Contributed by Mike Frysinger.\n+\n+   This file is part of simulators.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef RISCV_SIM_MACHS_H\n+#define RISCV_SIM_MACHS_H\n+\n+typedef enum model_type {\n+#define M(ext) MODEL_RV32##ext,\n+#include \"model_list.def\"\n+#undef M\n+#define M(ext) MODEL_RV64##ext,\n+#include \"model_list.def\"\n+#undef M\n+#define M(ext) MODEL_RV128##ext,\n+#include \"model_list.def\"\n+#undef M\n+  MODEL_MAX\n+} MODEL_TYPE;\n+\n+typedef enum mach_attr {\n+  MACH_BASE,\n+  MACH_RV32I,\n+  MACH_RV64I,\n+  MACH_RV128I,\n+  MACH_MAX\n+} MACH_ATTR;\n+\n+#endif"
    },
    {
      "sha": "5efd85ab280f9dbdb2dd99beeb70b5c30748e3db",
      "filename": "sim/riscv/model_list.def",
      "status": "added",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/model_list.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/model_list.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/model_list.def?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,9 @@\n+M(G)\n+M(I)\n+M(IM)\n+M(IMA)\n+M(IA)\n+M(E)\n+M(EM)\n+M(EMA)\n+M(EA)"
    },
    {
      "sha": "323b7d9a57c73ecd9d2707a343957dafc5d917ec",
      "filename": "sim/riscv/sim-main.c",
      "status": "added",
      "additions": 1150,
      "deletions": 0,
      "changes": 1150,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/sim-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/sim-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/sim-main.c?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,1150 @@\n+/* RISC-V simulator.\n+\n+   Copyright (C) 2005-2021 Free Software Foundation, Inc.\n+   Contributed by Mike Frysinger.\n+\n+   This file is part of simulators.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* This file contains the main simulator decoding logic.  i.e. everything that\n+   is architecture specific.  */\n+\n+#include \"config.h\"\n+\n+#include <inttypes.h>\n+#include <time.h>\n+\n+#include \"sim-main.h\"\n+#include \"sim-syscall.h\"\n+\n+#include \"opcode/riscv.h\"\n+\n+#include \"targ-vals.h\"\n+\f\n+#define TRACE_REG(cpu, reg) \\\n+  TRACE_REGISTER (cpu, \"wrote %s = %#\" PRIxTW, riscv_gpr_names_abi[reg], \\\n+\t\t  cpu->regs[reg])\n+\f\n+static const struct riscv_opcode *riscv_hash[OP_MASK_OP + 1];\n+#define OP_HASH_IDX(i) ((i) & (riscv_insn_length (i) == 2 ? 0x3 : 0x7f))\n+\n+#define RISCV_ASSERT_RV32(cpu, fmt, args...) \\\n+  do { \\\n+    if (RISCV_XLEN (cpu) != 32) \\\n+      { \\\n+\tSIM_DESC sd = CPU_STATE (cpu); \\\n+\tTRACE_INSN (cpu, \"RV32I-only \" fmt, ## args); \\\n+\tsim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL); \\\n+      } \\\n+  } while (0)\n+\n+#define RISCV_ASSERT_RV64(cpu, fmt, args...) \\\n+  do { \\\n+    if (RISCV_XLEN (cpu) != 64) \\\n+      { \\\n+\tSIM_DESC sd = CPU_STATE (cpu); \\\n+\tTRACE_INSN (cpu, \"RV64I-only \" fmt, ## args); \\\n+\tsim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL); \\\n+      } \\\n+  } while (0)\n+\n+static INLINE void\n+store_rd (SIM_CPU *cpu, int rd, unsigned_word val)\n+{\n+  if (rd)\n+    {\n+      cpu->regs[rd] = val;\n+      TRACE_REG (cpu, rd);\n+    }\n+}\n+\n+static INLINE unsigned_word\n+fetch_csr (SIM_CPU *cpu, const char *name, int csr, unsigned_word *reg)\n+{\n+  /* Handle pseudo registers.  */\n+  switch (csr)\n+    {\n+    /* Allow certain registers only in respective modes.  */\n+    case CSR_CYCLEH:\n+    case CSR_INSTRETH:\n+    case CSR_TIMEH:\n+      RISCV_ASSERT_RV32 (cpu, \"CSR: %s\", name);\n+      break;\n+    }\n+\n+  return *reg;\n+}\n+\n+static INLINE void\n+store_csr (SIM_CPU *cpu, const char *name, int csr, unsigned_word *reg,\n+\t   unsigned_word val)\n+{\n+  switch (csr)\n+    {\n+    /* These are pseudo registers that modify sub-fields of fcsr.  */\n+    case CSR_FRM:\n+      val &= 0x7;\n+      *reg = val;\n+      cpu->csr.fcsr = (cpu->csr.fcsr & ~0xe0) | (val << 5);\n+      break;\n+    case CSR_FFLAGS:\n+      val &= 0x1f;\n+      *reg = val;\n+      cpu->csr.fcsr = (cpu->csr.fcsr & ~0x1f) | val;\n+      break;\n+    /* Keep the sub-fields in sync.  */\n+    case CSR_FCSR:\n+      *reg = val;\n+      cpu->csr.frm = (val >> 5) & 0x7;\n+      cpu->csr.fflags = val & 0x1f;\n+      break;\n+\n+    /* Allow certain registers only in respective modes.  */\n+    case CSR_CYCLEH:\n+    case CSR_INSTRETH:\n+    case CSR_TIMEH:\n+      RISCV_ASSERT_RV32 (cpu, \"CSR: %s\", name);\n+\n+    /* All the rest are immutable.  */\n+    default:\n+      val = *reg;\n+      break;\n+    }\n+\n+  TRACE_REGISTER (cpu, \"wrote CSR %s = %#\" PRIxTW, name, val);\n+}\n+\n+static inline unsigned_word\n+ashiftrt (unsigned_word val, unsigned_word shift)\n+{\n+  unsigned32 sign = (val & 0x80000000) ? ~(0xfffffffful >> shift) : 0;\n+  return (val >> shift) | sign;\n+}\n+\n+static inline unsigned_word\n+ashiftrt64 (unsigned_word val, unsigned_word shift)\n+{\n+  unsigned64 sign =\n+    (val & 0x8000000000000000ull) ? ~(0xffffffffffffffffull >> shift) : 0;\n+  return (val >> shift) | sign;\n+}\n+\n+static sim_cia\n+execute_i (SIM_CPU *cpu, unsigned_word iw, const struct riscv_opcode *op)\n+{\n+  SIM_DESC sd = CPU_STATE (cpu);\n+  int rd = (iw >> OP_SH_RD) & OP_MASK_RD;\n+  int rs1 = (iw >> OP_SH_RS1) & OP_MASK_RS1;\n+  int rs2 = (iw >> OP_SH_RS2) & OP_MASK_RS2;\n+  const char *rd_name = riscv_gpr_names_abi[rd];\n+  const char *rs1_name = riscv_gpr_names_abi[rs1];\n+  const char *rs2_name = riscv_gpr_names_abi[rs2];\n+  unsigned int csr = (iw >> OP_SH_CSR) & OP_MASK_CSR;\n+  unsigned_word i_imm = EXTRACT_ITYPE_IMM (iw);\n+  unsigned_word u_imm = EXTRACT_UTYPE_IMM ((unsigned64) iw);\n+  unsigned_word s_imm = EXTRACT_STYPE_IMM (iw);\n+  unsigned_word sb_imm = EXTRACT_SBTYPE_IMM (iw);\n+  unsigned_word shamt_imm = ((iw >> OP_SH_SHAMT) & OP_MASK_SHAMT);\n+  unsigned_word tmp;\n+  sim_cia pc = cpu->pc + 4;\n+\n+  TRACE_EXTRACT (cpu,\n+\t\t \"rd:%-2i:%-4s  \"\n+\t\t \"rs1:%-2i:%-4s %0*\" PRIxTW \"  \"\n+\t\t \"rs2:%-2i:%-4s %0*\" PRIxTW \"  \"\n+\t\t \"match:%#x mask:%#x\",\n+\t\t rd, rd_name,\n+\t\t rs1, rs1_name, (int) sizeof (unsigned_word) * 2, cpu->regs[rs1],\n+\t\t rs2, rs2_name, (int) sizeof (unsigned_word) * 2, cpu->regs[rs2],\n+\t\t (unsigned) op->match, (unsigned) op->mask);\n+\n+  switch (op->match)\n+    {\n+    case MATCH_ADD:\n+      TRACE_INSN (cpu, \"add %s, %s, %s;  // %s = %s + %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      store_rd (cpu, rd, cpu->regs[rs1] + cpu->regs[rs2]);\n+      break;\n+    case MATCH_ADDW:\n+      TRACE_INSN (cpu, \"addw %s, %s, %s;  // %s = %s + %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 (cpu->regs[rs1] + cpu->regs[rs2]));\n+      break;\n+    case MATCH_ADDI:\n+      TRACE_INSN (cpu, \"addi %s, %s, %#\" PRIxTW \";  // %s = %s + %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, i_imm, rd_name, rs1_name, i_imm);\n+      store_rd (cpu, rd, cpu->regs[rs1] + i_imm);\n+      break;\n+    case MATCH_ADDIW:\n+      TRACE_INSN (cpu, \"addiw %s, %s, %#\" PRIxTW \";  // %s = %s + %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, i_imm, rd_name, rs1_name, i_imm);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 (cpu->regs[rs1] + i_imm));\n+      break;\n+    case MATCH_AND:\n+      TRACE_INSN (cpu, \"and %s, %s, %s;  // %s = %s & %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      store_rd (cpu, rd, cpu->regs[rs1] & cpu->regs[rs2]);\n+      break;\n+    case MATCH_ANDI:\n+      TRACE_INSN (cpu, \"andi %s, %s, %\" PRIiTW \";  // %s = %s & %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, i_imm, rd_name, rs1_name, i_imm);\n+      store_rd (cpu, rd, cpu->regs[rs1] & i_imm);\n+      break;\n+    case MATCH_OR:\n+      TRACE_INSN (cpu, \"or %s, %s, %s;  // %s = %s | %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      store_rd (cpu, rd, cpu->regs[rs1] | cpu->regs[rs2]);\n+      break;\n+    case MATCH_ORI:\n+      TRACE_INSN (cpu, \"ori %s, %s, %\" PRIiTW \";  // %s = %s | %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, i_imm, rd_name, rs1_name, i_imm);\n+      store_rd (cpu, rd, cpu->regs[rs1] | i_imm);\n+      break;\n+    case MATCH_XOR:\n+      TRACE_INSN (cpu, \"xor %s, %s, %s;  // %s = %s ^ %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      store_rd (cpu, rd, cpu->regs[rs1] ^ cpu->regs[rs2]);\n+      break;\n+    case MATCH_XORI:\n+      TRACE_INSN (cpu, \"xori %s, %s, %\" PRIiTW \";  // %s = %s ^ %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, i_imm, rd_name, rs1_name, i_imm);\n+      store_rd (cpu, rd, cpu->regs[rs1] ^ i_imm);\n+      break;\n+    case MATCH_SUB:\n+      TRACE_INSN (cpu, \"sub %s, %s, %s;  // %s = %s - %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      store_rd (cpu, rd, cpu->regs[rs1] - cpu->regs[rs2]);\n+      break;\n+    case MATCH_SUBW:\n+      TRACE_INSN (cpu, \"subw %s, %s, %s;  // %s = %s - %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 (cpu->regs[rs1] - cpu->regs[rs2]));\n+      break;\n+    case MATCH_LUI:\n+      TRACE_INSN (cpu, \"lui %s, %#\" PRIxTW \";\", rd_name, u_imm);\n+      store_rd (cpu, rd, u_imm);\n+      break;\n+    case MATCH_SLL:\n+      TRACE_INSN (cpu, \"sll %s, %s, %s;  // %s = %s << %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      u_imm = RISCV_XLEN (cpu) == 32 ? 0x1f : 0x3f;\n+      store_rd (cpu, rd, cpu->regs[rs1] << (cpu->regs[rs2] & u_imm));\n+      break;\n+    case MATCH_SLLW:\n+      TRACE_INSN (cpu, \"sllw %s, %s, %s;  // %s = %s << %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 (\n+\t(unsigned32) cpu->regs[rs1] << (cpu->regs[rs2] & 0x1f)));\n+      break;\n+    case MATCH_SLLI:\n+      TRACE_INSN (cpu, \"slli %s, %s, %\" PRIiTW \";  // %s = %s << %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, shamt_imm, rd_name, rs1_name, shamt_imm);\n+      if (RISCV_XLEN (cpu) == 32 && shamt_imm > 0x1f)\n+\tsim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL);\n+      store_rd (cpu, rd, cpu->regs[rs1] << shamt_imm);\n+      break;\n+    case MATCH_SLLIW:\n+      TRACE_INSN (cpu, \"slliw %s, %s, %\" PRIiTW \";  // %s = %s << %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, shamt_imm, rd_name, rs1_name, shamt_imm);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 ((unsigned32) cpu->regs[rs1] << shamt_imm));\n+      break;\n+    case MATCH_SRL:\n+      TRACE_INSN (cpu, \"srl %s, %s, %s;  // %s = %s >> %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      u_imm = RISCV_XLEN (cpu) == 32 ? 0x1f : 0x3f;\n+      store_rd (cpu, rd, cpu->regs[rs1] >> (cpu->regs[rs2] & u_imm));\n+      break;\n+    case MATCH_SRLW:\n+      TRACE_INSN (cpu, \"srlw %s, %s, %s;  // %s = %s >> %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 (\n+\t(unsigned32) cpu->regs[rs1] >> (cpu->regs[rs2] & 0x1f)));\n+      break;\n+    case MATCH_SRLI:\n+      TRACE_INSN (cpu, \"srli %s, %s, %\" PRIiTW \";  // %s = %s >> %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, shamt_imm, rd_name, rs1_name, shamt_imm);\n+      if (RISCV_XLEN (cpu) == 32 && shamt_imm > 0x1f)\n+\tsim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL);\n+      store_rd (cpu, rd, cpu->regs[rs1] >> shamt_imm);\n+      break;\n+    case MATCH_SRLIW:\n+      TRACE_INSN (cpu, \"srliw %s, %s, %\" PRIiTW \";  // %s = %s >> %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, shamt_imm, rd_name, rs1_name, shamt_imm);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 ((unsigned32) cpu->regs[rs1] >> shamt_imm));\n+      break;\n+    case MATCH_SRA:\n+      TRACE_INSN (cpu, \"sra %s, %s, %s;  // %s = %s >>> %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      if (RISCV_XLEN (cpu) == 32)\n+\ttmp = ashiftrt (cpu->regs[rs1], cpu->regs[rs2] & 0x1f);\n+      else\n+\ttmp = ashiftrt64 (cpu->regs[rs1], cpu->regs[rs2] & 0x3f);\n+      store_rd (cpu, rd, tmp);\n+      break;\n+    case MATCH_SRAW:\n+      TRACE_INSN (cpu, \"sraw %s, %s, %s;  // %s = %s >>> %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 (\n+\tashiftrt ((signed32) cpu->regs[rs1], cpu->regs[rs2] & 0x1f)));\n+      break;\n+    case MATCH_SRAI:\n+      TRACE_INSN (cpu, \"srai %s, %s, %\" PRIiTW \";  // %s = %s >>> %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, shamt_imm, rd_name, rs1_name, shamt_imm);\n+      if (RISCV_XLEN (cpu) == 32)\n+\t{\n+\t  if (shamt_imm > 0x1f)\n+\t    sim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL);\n+\t  tmp = ashiftrt (cpu->regs[rs1], shamt_imm);\n+\t}\n+      else\n+\ttmp = ashiftrt64 (cpu->regs[rs1], shamt_imm);\n+      store_rd (cpu, rd, tmp);\n+      break;\n+    case MATCH_SRAIW:\n+      TRACE_INSN (cpu, \"sraiw %s, %s, %\" PRIiTW \";  // %s = %s >>> %#\" PRIxTW,\n+\t\t  rd_name, rs1_name, shamt_imm, rd_name, rs1_name, shamt_imm);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 (\n+\tashiftrt ((signed32) cpu->regs[rs1], shamt_imm)));\n+      break;\n+    case MATCH_SLT:\n+      TRACE_INSN (cpu, \"slt\");\n+      store_rd (cpu, rd,\n+\t\t!!((signed_word) cpu->regs[rs1] < (signed_word) cpu->regs[rs2]));\n+      break;\n+    case MATCH_SLTU:\n+      TRACE_INSN (cpu, \"sltu\");\n+      store_rd (cpu, rd, !!((unsigned_word) cpu->regs[rs1] <\n+\t\t\t    (unsigned_word) cpu->regs[rs2]));\n+      break;\n+    case MATCH_SLTI:\n+      TRACE_INSN (cpu, \"slti\");\n+      store_rd (cpu, rd, !!((signed_word) cpu->regs[rs1] <\n+\t\t\t    (signed_word) i_imm));\n+      break;\n+    case MATCH_SLTIU:\n+      TRACE_INSN (cpu, \"sltiu\");\n+      store_rd (cpu, rd, !!((unsigned_word) cpu->regs[rs1] <\n+\t\t\t    (unsigned_word) i_imm));\n+      break;\n+    case MATCH_AUIPC:\n+      TRACE_INSN (cpu, \"auipc %s, %\" PRIiTW \";  // %s = pc + %\" PRIiTW,\n+\t\t  rd_name, u_imm, rd_name, u_imm);\n+      store_rd (cpu, rd, cpu->pc + u_imm);\n+      break;\n+    case MATCH_BEQ:\n+      TRACE_INSN (cpu, \"beq %s, %s, %#\" PRIxTW \";  \"\n+\t\t       \"// if (%s == %s) goto %#\" PRIxTW,\n+\t\t  rs1_name, rs2_name, sb_imm, rs1_name, rs2_name, sb_imm);\n+      if (cpu->regs[rs1] == cpu->regs[rs2])\n+\t{\n+\t  pc = cpu->pc + sb_imm;\n+\t  TRACE_BRANCH (cpu, \"to %#\" PRIxTW, pc);\n+\t}\n+      break;\n+    case MATCH_BLT:\n+      TRACE_INSN (cpu, \"blt %s, %s, %#\" PRIxTW \";  \"\n+\t\t       \"// if (%s < %s) goto %#\" PRIxTW,\n+\t\t  rs1_name, rs2_name, sb_imm, rs1_name, rs2_name, sb_imm);\n+      if ((signed_word) cpu->regs[rs1] < (signed_word) cpu->regs[rs2])\n+\t{\n+\t  pc = cpu->pc + sb_imm;\n+\t  TRACE_BRANCH (cpu, \"to %#\" PRIxTW, pc);\n+\t}\n+      break;\n+    case MATCH_BLTU:\n+      TRACE_INSN (cpu, \"bltu %s, %s, %#\" PRIxTW \";  \"\n+\t\t       \"// if (%s < %s) goto %#\" PRIxTW,\n+\t\t  rs1_name, rs2_name, sb_imm, rs1_name, rs2_name, sb_imm);\n+      if ((unsigned_word) cpu->regs[rs1] < (unsigned_word) cpu->regs[rs2])\n+\t{\n+\t  pc = cpu->pc + sb_imm;\n+\t  TRACE_BRANCH (cpu, \"to %#\" PRIxTW, pc);\n+\t}\n+      break;\n+    case MATCH_BGE:\n+      TRACE_INSN (cpu, \"bge %s, %s, %#\" PRIxTW \";  \"\n+\t\t       \"// if (%s >= %s) goto %#\" PRIxTW,\n+\t\t  rs1_name, rs2_name, sb_imm, rs1_name, rs2_name, sb_imm);\n+      if ((signed_word) cpu->regs[rs1] >= (signed_word) cpu->regs[rs2])\n+\t{\n+\t  pc = cpu->pc + sb_imm;\n+\t  TRACE_BRANCH (cpu, \"to %#\" PRIxTW, pc);\n+\t}\n+      break;\n+    case MATCH_BGEU:\n+      TRACE_INSN (cpu, \"bgeu %s, %s, %#\" PRIxTW \";  \"\n+\t\t       \"// if (%s >= %s) goto %#\" PRIxTW,\n+\t\t  rs1_name, rs2_name, sb_imm, rs1_name, rs2_name, sb_imm);\n+      if ((unsigned_word) cpu->regs[rs1] >= (unsigned_word) cpu->regs[rs2])\n+\t{\n+\t  pc = cpu->pc + sb_imm;\n+\t  TRACE_BRANCH (cpu, \"to %#\" PRIxTW, pc);\n+\t}\n+      break;\n+    case MATCH_BNE:\n+      TRACE_INSN (cpu, \"bne %s, %s, %#\" PRIxTW \";  \"\n+\t\t       \"// if (%s != %s) goto %#\" PRIxTW,\n+\t\t  rs1_name, rs2_name, sb_imm, rs1_name, rs2_name, sb_imm);\n+      if (cpu->regs[rs1] != cpu->regs[rs2])\n+\t{\n+\t  pc = cpu->pc + sb_imm;\n+\t  TRACE_BRANCH (cpu, \"to %#\" PRIxTW, pc);\n+\t}\n+      break;\n+    case MATCH_JAL:\n+      TRACE_INSN (cpu, \"jal %s, %\" PRIiTW \";\", rd_name,\n+\t\t  EXTRACT_UJTYPE_IMM (iw));\n+      store_rd (cpu, rd, cpu->pc + 4);\n+      pc = cpu->pc + EXTRACT_UJTYPE_IMM (iw);\n+      TRACE_BRANCH (cpu, \"to %#\" PRIxTW, pc);\n+      break;\n+    case MATCH_JALR:\n+      TRACE_INSN (cpu, \"jalr %s, %s, %\" PRIiTW \";\", rd_name, rs1_name, i_imm);\n+      store_rd (cpu, rd, cpu->pc + 4);\n+      pc = cpu->regs[rs1] + i_imm;\n+      TRACE_BRANCH (cpu, \"to %#\" PRIxTW, pc);\n+      break;\n+\n+    case MATCH_LD:\n+      TRACE_INSN (cpu, \"ld %s, %\" PRIiTW \"(%s);\",\n+\t\t  rd_name, i_imm, rs1_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd,\n+\tsim_core_read_unaligned_8 (cpu, cpu->pc, read_map,\n+\t\t\t\t   cpu->regs[rs1] + i_imm));\n+      break;\n+    case MATCH_LW:\n+      TRACE_INSN (cpu, \"lw %s, %\" PRIiTW \"(%s);\",\n+\t\t  rd_name, i_imm, rs1_name);\n+      store_rd (cpu, rd, EXTEND32 (\n+\tsim_core_read_unaligned_4 (cpu, cpu->pc, read_map,\n+\t\t\t\t   cpu->regs[rs1] + i_imm)));\n+      break;\n+    case MATCH_LWU:\n+      TRACE_INSN (cpu, \"lwu %s, %\" PRIiTW \"(%s);\",\n+\t\t  rd_name, i_imm, rs1_name);\n+      store_rd (cpu, rd,\n+\tsim_core_read_unaligned_4 (cpu, cpu->pc, read_map,\n+\t\t\t\t   cpu->regs[rs1] + i_imm));\n+      break;\n+    case MATCH_LH:\n+      TRACE_INSN (cpu, \"lh %s, %\" PRIiTW \"(%s);\",\n+\t\t  rd_name, i_imm, rs1_name);\n+      store_rd (cpu, rd, EXTEND16 (\n+\tsim_core_read_unaligned_2 (cpu, cpu->pc, read_map,\n+\t\t\t\t   cpu->regs[rs1] + i_imm)));\n+      break;\n+    case MATCH_LHU:\n+      TRACE_INSN (cpu, \"lbu %s, %\" PRIiTW \"(%s);\",\n+\t\t  rd_name, i_imm, rs1_name);\n+      store_rd (cpu, rd,\n+\tsim_core_read_unaligned_2 (cpu, cpu->pc, read_map,\n+\t\t\t\t   cpu->regs[rs1] + i_imm));\n+      break;\n+    case MATCH_LB:\n+      TRACE_INSN (cpu, \"lb %s, %\" PRIiTW \"(%s);\",\n+\t\t  rd_name, i_imm, rs1_name);\n+      store_rd (cpu, rd, EXTEND8 (\n+\tsim_core_read_unaligned_1 (cpu, cpu->pc, read_map,\n+\t\t\t\t   cpu->regs[rs1] + i_imm)));\n+      break;\n+    case MATCH_LBU:\n+      TRACE_INSN (cpu, \"lbu %s, %\" PRIiTW \"(%s);\",\n+\t\t  rd_name, i_imm, rs1_name);\n+      store_rd (cpu, rd,\n+\tsim_core_read_unaligned_1 (cpu, cpu->pc, read_map,\n+\t\t\t\t   cpu->regs[rs1] + i_imm));\n+      break;\n+    case MATCH_SD:\n+      TRACE_INSN (cpu, \"sd %s, %\" PRIiTW \"(%s);\",\n+\t\t  rs2_name, s_imm, rs1_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      sim_core_write_unaligned_8 (cpu, cpu->pc, write_map,\n+\t\t\t\t  cpu->regs[rs1] + s_imm, cpu->regs[rs2]);\n+      break;\n+    case MATCH_SW:\n+      TRACE_INSN (cpu, \"sw %s, %\" PRIiTW \"(%s);\",\n+\t\t  rs2_name, s_imm, rs1_name);\n+      sim_core_write_unaligned_4 (cpu, cpu->pc, write_map,\n+\t\t\t\t  cpu->regs[rs1] + s_imm, cpu->regs[rs2]);\n+      break;\n+    case MATCH_SH:\n+      TRACE_INSN (cpu, \"sh %s, %\" PRIiTW \"(%s);\",\n+\t\t  rs2_name, s_imm, rs1_name);\n+      sim_core_write_unaligned_2 (cpu, cpu->pc, write_map,\n+\t\t\t\t  cpu->regs[rs1] + s_imm, cpu->regs[rs2]);\n+      break;\n+    case MATCH_SB:\n+      TRACE_INSN (cpu, \"sb %s, %\" PRIiTW \"(%s);\",\n+\t\t  rs2_name, s_imm, rs1_name);\n+      sim_core_write_unaligned_1 (cpu, cpu->pc, write_map,\n+\t\t\t\t  cpu->regs[rs1] + s_imm, cpu->regs[rs2]);\n+      break;\n+\n+    case MATCH_CSRRC:\n+      TRACE_INSN (cpu, \"csrrc\");\n+      switch (csr)\n+\t{\n+#define DECLARE_CSR(name, num, ...) \\\n+\tcase num: \\\n+\t  store_rd (cpu, rd, fetch_csr (cpu, #name, num, &cpu->csr.name)); \\\n+\t  store_csr (cpu, #name, num, &cpu->csr.name, \\\n+\t\t     cpu->csr.name & !cpu->regs[rs1]); \\\n+\t  break;\n+#include \"opcode/riscv-opc.h\"\n+#undef DECLARE_CSR\n+\t}\n+      break;\n+    case MATCH_CSRRS:\n+      TRACE_INSN (cpu, \"csrrs\");\n+      switch (csr)\n+\t{\n+#define DECLARE_CSR(name, num, ...) \\\n+\tcase num: \\\n+\t  store_rd (cpu, rd, fetch_csr (cpu, #name, num, &cpu->csr.name)); \\\n+\t  store_csr (cpu, #name, num, &cpu->csr.name, \\\n+\t\t     cpu->csr.name | cpu->regs[rs1]); \\\n+\t  break;\n+#include \"opcode/riscv-opc.h\"\n+#undef DECLARE_CSR\n+\t}\n+      break;\n+    case MATCH_CSRRW:\n+      TRACE_INSN (cpu, \"csrrw\");\n+      switch (csr)\n+\t{\n+#define DECLARE_CSR(name, num, ...) \\\n+\tcase num: \\\n+\t  store_rd (cpu, rd, fetch_csr (cpu, #name, num, &cpu->csr.name)); \\\n+\t  store_csr (cpu, #name, num, &cpu->csr.name, cpu->regs[rs1]); \\\n+\t  break;\n+#include \"opcode/riscv-opc.h\"\n+#undef DECLARE_CSR\n+\t}\n+      break;\n+\n+    case MATCH_RDCYCLE:\n+      TRACE_INSN (cpu, \"rdcycle %s;\", rd_name);\n+      store_rd (cpu, rd, fetch_csr (cpu, \"cycle\", CSR_CYCLE, &cpu->csr.cycle));\n+      break;\n+    case MATCH_RDCYCLEH:\n+      TRACE_INSN (cpu, \"rdcycleh %s;\", rd_name);\n+      RISCV_ASSERT_RV32 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd,\n+\t\tfetch_csr (cpu, \"cycleh\", CSR_CYCLEH, &cpu->csr.cycleh));\n+      break;\n+    case MATCH_RDINSTRET:\n+      TRACE_INSN (cpu, \"rdinstret %s;\", rd_name);\n+      store_rd (cpu, rd,\n+\t\tfetch_csr (cpu, \"instret\", CSR_INSTRET, &cpu->csr.instret));\n+      break;\n+    case MATCH_RDINSTRETH:\n+      TRACE_INSN (cpu, \"rdinstreth %s;\", rd_name);\n+      RISCV_ASSERT_RV32 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd,\n+\t\tfetch_csr (cpu, \"instreth\", CSR_INSTRETH, &cpu->csr.instreth));\n+      break;\n+    case MATCH_RDTIME:\n+      TRACE_INSN (cpu, \"rdtime %s;\", rd_name);\n+      store_rd (cpu, rd, fetch_csr (cpu, \"time\", CSR_TIME, &cpu->csr.time));\n+      break;\n+    case MATCH_RDTIMEH:\n+      TRACE_INSN (cpu, \"rdtimeh %s;\", rd_name);\n+      RISCV_ASSERT_RV32 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, fetch_csr (cpu, \"timeh\", CSR_TIMEH, &cpu->csr.timeh));\n+      break;\n+\n+    case MATCH_FENCE:\n+      TRACE_INSN (cpu, \"fence;\");\n+      break;\n+    case MATCH_FENCE_I:\n+      TRACE_INSN (cpu, \"fence.i;\");\n+      break;\n+    case MATCH_SBREAK:\n+      TRACE_INSN (cpu, \"sbreak;\");\n+      /* GDB expects us to step over SBREAK.  */\n+      sim_engine_halt (sd, cpu, NULL, cpu->pc + 4, sim_stopped, SIM_SIGTRAP);\n+      break;\n+    case MATCH_ECALL:\n+      TRACE_INSN (cpu, \"ecall;\");\n+      cpu->a0 = sim_syscall (cpu, cpu->a7, cpu->a0, cpu->a1, cpu->a2, cpu->a3);\n+      break;\n+    default:\n+      TRACE_INSN (cpu, \"UNHANDLED INSN: %s\", op->name);\n+      sim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL);\n+    }\n+\n+  return pc;\n+}\n+\n+static unsigned64\n+mulhu (unsigned64 a, unsigned64 b)\n+{\n+#ifdef __GNUC__\n+  return ((__int128)a * b) >> 64;\n+#else\n+  uint64_t t;\n+  uint32_t y1, y2, y3;\n+  uint64_t a0 = (uint32_t)a, a1 = a >> 32;\n+  uint64_t b0 = (uint32_t)b, b1 = b >> 32;\n+\n+  t = a1*b0 + ((a0*b0) >> 32);\n+  y1 = t;\n+  y2 = t >> 32;\n+\n+  t = a0*b1 + y1;\n+  y1 = t;\n+\n+  t = a1*b1 + y2 + (t >> 32);\n+  y2 = t;\n+  y3 = t >> 32;\n+\n+  return ((uint64_t)y3 << 32) | y2;\n+#endif\n+}\n+\n+static unsigned64\n+mulh (signed64 a, signed64 b)\n+{\n+  int negate = (a < 0) != (b < 0);\n+  uint64_t res = mulhu (a < 0 ? -a : a, b < 0 ? -b : b);\n+  return negate ? ~res + (a * b == 0) : res;\n+}\n+\n+static unsigned64\n+mulhsu (signed64 a, unsigned64 b)\n+{\n+  int negate = a < 0;\n+  uint64_t res = mulhu (a < 0 ? -a : a, b);\n+  return negate ? ~res + (a * b == 0) : res;\n+}\n+\n+static sim_cia\n+execute_m (SIM_CPU *cpu, unsigned_word iw, const struct riscv_opcode *op)\n+{\n+  SIM_DESC sd = CPU_STATE (cpu);\n+  int rd = (iw >> OP_SH_RD) & OP_MASK_RD;\n+  int rs1 = (iw >> OP_SH_RS1) & OP_MASK_RS1;\n+  int rs2 = (iw >> OP_SH_RS2) & OP_MASK_RS2;\n+  const char *rd_name = riscv_gpr_names_abi[rd];\n+  const char *rs1_name = riscv_gpr_names_abi[rs1];\n+  const char *rs2_name = riscv_gpr_names_abi[rs2];\n+  unsigned_word tmp, dividend_max;\n+  sim_cia pc = cpu->pc + 4;\n+\n+  dividend_max = -((unsigned_word) 1 << (WITH_TARGET_WORD_BITSIZE - 1));\n+\n+  switch (op->match)\n+    {\n+    case MATCH_DIV:\n+      TRACE_INSN (cpu, \"div %s, %s, %s;  // %s = %s / %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      if (cpu->regs[rs1] == dividend_max && cpu->regs[rs2] == -1)\n+\ttmp = dividend_max;\n+      else if (cpu->regs[rs2])\n+\ttmp = (signed_word) cpu->regs[rs1] / (signed_word) cpu->regs[rs2];\n+      else\n+\ttmp = -1;\n+      store_rd (cpu, rd, tmp);\n+      break;\n+    case MATCH_DIVW:\n+      TRACE_INSN (cpu, \"divw %s, %s, %s;  // %s = %s / %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      if (EXTEND32 (cpu->regs[rs2]) == -1)\n+\ttmp = 1 << 31;\n+      else if (EXTEND32 (cpu->regs[rs2]))\n+\ttmp = EXTEND32 (cpu->regs[rs1]) / EXTEND32 (cpu->regs[rs2]);\n+      else\n+\ttmp = -1;\n+      store_rd (cpu, rd, EXTEND32 (tmp));\n+      break;\n+    case MATCH_DIVU:\n+      TRACE_INSN (cpu, \"divu %s, %s, %s;  // %s = %s / %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      if (cpu->regs[rs2])\n+\tstore_rd (cpu, rd, (unsigned_word) cpu->regs[rs1]\n+\t\t\t   / (unsigned_word) cpu->regs[rs2]);\n+      else\n+\tstore_rd (cpu, rd, -1);\n+      break;\n+    case MATCH_DIVUW:\n+      TRACE_INSN (cpu, \"divuw %s, %s, %s;  // %s = %s / %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      if ((unsigned32) cpu->regs[rs2])\n+\ttmp = (unsigned32) cpu->regs[rs1] / (unsigned32) cpu->regs[rs2];\n+      else\n+\ttmp = -1;\n+      store_rd (cpu, rd, EXTEND32 (tmp));\n+      break;\n+    case MATCH_MUL:\n+      TRACE_INSN (cpu, \"mul %s, %s, %s;  // %s = %s * %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      store_rd (cpu, rd, cpu->regs[rs1] * cpu->regs[rs2]);\n+      break;\n+    case MATCH_MULW:\n+      TRACE_INSN (cpu, \"mulw %s, %s, %s;  // %s = %s * %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      store_rd (cpu, rd, EXTEND32 ((signed32) cpu->regs[rs1]\n+\t\t\t\t   * (signed32) cpu->regs[rs2]));\n+      break;\n+    case MATCH_MULH:\n+      TRACE_INSN (cpu, \"mulh %s, %s, %s;  // %s = %s * %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      if (RISCV_XLEN (cpu) == 32)\n+\tstore_rd (cpu, rd, ((signed64)(signed_word) cpu->regs[rs1]\n+\t\t\t    * (signed64)(signed_word) cpu->regs[rs2]) >> 32);\n+      else\n+\tstore_rd (cpu, rd, mulh (cpu->regs[rs1], cpu->regs[rs2]));\n+      break;\n+    case MATCH_MULHU:\n+      TRACE_INSN (cpu, \"mulhu %s, %s, %s;  // %s = %s * %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      if (RISCV_XLEN (cpu) == 32)\n+\tstore_rd (cpu, rd, ((unsigned64)cpu->regs[rs1]\n+\t\t\t    * (unsigned64)cpu->regs[rs2]) >> 32);\n+      else\n+\tstore_rd (cpu, rd, mulhu (cpu->regs[rs1], cpu->regs[rs2]));\n+      break;\n+    case MATCH_MULHSU:\n+      TRACE_INSN (cpu, \"mulhsu %s, %s, %s;  // %s = %s * %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      if (RISCV_XLEN (cpu) == 32)\n+\tstore_rd (cpu, rd, ((signed64)(signed_word) cpu->regs[rs1]\n+\t\t\t    * (unsigned64)cpu->regs[rs2]) >> 32);\n+      else\n+\tstore_rd (cpu, rd, mulhsu (cpu->regs[rs1], cpu->regs[rs2]));\n+      break;\n+    case MATCH_REM:\n+      TRACE_INSN (cpu, \"rem %s, %s, %s;  // %s = %s %% %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      if (cpu->regs[rs1] == dividend_max && cpu->regs[rs2] == -1)\n+\ttmp = 0;\n+      else if (cpu->regs[rs2])\n+\ttmp = (signed_word) cpu->regs[rs1] % (signed_word) cpu->regs[rs2];\n+      else\n+\ttmp = cpu->regs[rs1];\n+      store_rd (cpu, rd, tmp);\n+      break;\n+    case MATCH_REMW:\n+      TRACE_INSN (cpu, \"remw %s, %s, %s;  // %s = %s %% %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      if (EXTEND32 (cpu->regs[rs2]) == -1)\n+\ttmp = 0;\n+      else if (EXTEND32 (cpu->regs[rs2]))\n+\ttmp = EXTEND32 (cpu->regs[rs1]) % EXTEND32 (cpu->regs[rs2]);\n+      else\n+\ttmp = cpu->regs[rs1];\n+      store_rd (cpu, rd, EXTEND32 (tmp));\n+      break;\n+    case MATCH_REMU:\n+      TRACE_INSN (cpu, \"remu %s, %s, %s;  // %s = %s %% %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      if (cpu->regs[rs2])\n+\tstore_rd (cpu, rd, cpu->regs[rs1] % cpu->regs[rs2]);\n+      else\n+\tstore_rd (cpu, rd, cpu->regs[rs1]);\n+      break;\n+    case MATCH_REMUW:\n+      TRACE_INSN (cpu, \"remuw %s, %s, %s;  // %s = %s %% %s\",\n+\t\t  rd_name, rs1_name, rs2_name, rd_name, rs1_name, rs2_name);\n+      RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+      if ((unsigned32) cpu->regs[rs2])\n+\ttmp = (unsigned32) cpu->regs[rs1] % (unsigned32) cpu->regs[rs2];\n+      else\n+\ttmp = cpu->regs[rs1];\n+      store_rd (cpu, rd, EXTEND32 (tmp));\n+      break;\n+    default:\n+      TRACE_INSN (cpu, \"UNHANDLED INSN: %s\", op->name);\n+      sim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL);\n+    }\n+\n+  return pc;\n+}\n+\n+#define MAX(a, b) ((a) > (b) ? (a) : (b))\n+#define MIN(a, b) ((a) < (b) ? (a) : (b))\n+\n+static sim_cia\n+execute_a (SIM_CPU *cpu, unsigned_word iw, const struct riscv_opcode *op)\n+{\n+  SIM_DESC sd = CPU_STATE (cpu);\n+  int rd = (iw >> OP_SH_RD) & OP_MASK_RD;\n+  int rs1 = (iw >> OP_SH_RS1) & OP_MASK_RS1;\n+  int rs2 = (iw >> OP_SH_RS2) & OP_MASK_RS2;\n+  const char *rd_name = riscv_gpr_names_abi[rd];\n+  const char *rs1_name = riscv_gpr_names_abi[rs1];\n+  const char *rs2_name = riscv_gpr_names_abi[rs2];\n+  struct atomic_mem_reserved_list *amo_prev, *amo_curr;\n+  unsigned_word tmp;\n+  sim_cia pc = cpu->pc + 4;\n+\n+  /* Handle these two load/store operations specifically.  */\n+  switch (op->match)\n+    {\n+    case MATCH_LR_W:\n+      TRACE_INSN (cpu, \"%s %s, (%s);\", op->name, rd_name, rs1_name);\n+      store_rd (cpu, rd,\n+\tsim_core_read_unaligned_4 (cpu, cpu->pc, read_map, cpu->regs[rs1]));\n+\n+      /* Walk the reservation list to find an existing match.  */\n+      amo_curr = sd->amo_reserved_list;\n+      while (amo_curr)\n+\t{\n+\t  if (amo_curr->addr == cpu->regs[rs1])\n+\t    goto done;\n+\t  amo_curr = amo_curr->next;\n+\t}\n+\n+      /* No reservation exists, so add one.  */\n+      amo_curr = xmalloc (sizeof (*amo_curr));\n+      amo_curr->addr = cpu->regs[rs1];\n+      amo_curr->next = sd->amo_reserved_list;\n+      sd->amo_reserved_list = amo_curr;\n+      goto done;\n+    case MATCH_SC_W:\n+      TRACE_INSN (cpu, \"%s %s, %s, (%s);\", op->name, rd_name, rs2_name,\n+\t\t  rs1_name);\n+\n+      /* Walk the reservation list to find a match.  */\n+      amo_curr = amo_prev = sd->amo_reserved_list;\n+      while (amo_curr)\n+\t{\n+\t  if (amo_curr->addr == cpu->regs[rs1])\n+\t    {\n+\t      /* We found a reservation, so operate it.  */\n+\t      sim_core_write_unaligned_4 (cpu, cpu->pc, write_map,\n+\t\t\t\t\t  cpu->regs[rs1], cpu->regs[rs2]);\n+\t      store_rd (cpu, rd, 0);\n+\t      if (amo_curr == sd->amo_reserved_list)\n+\t\tsd->amo_reserved_list = amo_curr->next;\n+\t      else\n+\t\tamo_prev->next = amo_curr->next;\n+\t      free (amo_curr);\n+\t      goto done;\n+\t    }\n+\t  amo_prev = amo_curr;\n+\t  amo_curr = amo_curr->next;\n+\t}\n+\n+      /* If we're still here, then no reservation exists, so mark as failed.  */\n+      store_rd (cpu, rd, 1);\n+      goto done;\n+    }\n+\n+  /* Handle the rest of the atomic insns with common code paths.  */\n+  TRACE_INSN (cpu, \"%s %s, %s, (%s);\",\n+\t      op->name, rd_name, rs2_name, rs1_name);\n+  if (op->xlen_requirement == 64)\n+    tmp = sim_core_read_unaligned_8 (cpu, cpu->pc, read_map, cpu->regs[rs1]);\n+  else\n+    tmp = EXTEND32 (sim_core_read_unaligned_4 (cpu, cpu->pc, read_map,\n+\t\t\t\t\t       cpu->regs[rs1]));\n+  store_rd (cpu, rd, tmp);\n+\n+  switch (op->match)\n+    {\n+    case MATCH_AMOADD_D:\n+    case MATCH_AMOADD_W:\n+      tmp = cpu->regs[rd] + cpu->regs[rs2];\n+      break;\n+    case MATCH_AMOAND_D:\n+    case MATCH_AMOAND_W:\n+      tmp = cpu->regs[rd] & cpu->regs[rs2];\n+      break;\n+    case MATCH_AMOMAX_D:\n+    case MATCH_AMOMAX_W:\n+      tmp = MAX ((signed_word) cpu->regs[rd], (signed_word) cpu->regs[rs2]);\n+      break;\n+    case MATCH_AMOMAXU_D:\n+    case MATCH_AMOMAXU_W:\n+      tmp = MAX ((unsigned_word) cpu->regs[rd], (unsigned_word) cpu->regs[rs2]);\n+      break;\n+    case MATCH_AMOMIN_D:\n+    case MATCH_AMOMIN_W:\n+      tmp = MIN ((signed_word) cpu->regs[rd], (signed_word) cpu->regs[rs2]);\n+      break;\n+    case MATCH_AMOMINU_D:\n+    case MATCH_AMOMINU_W:\n+      tmp = MIN ((unsigned_word) cpu->regs[rd], (unsigned_word) cpu->regs[rs2]);\n+      break;\n+    case MATCH_AMOOR_D:\n+    case MATCH_AMOOR_W:\n+      tmp = cpu->regs[rd] | cpu->regs[rs2];\n+      break;\n+    case MATCH_AMOSWAP_D:\n+    case MATCH_AMOSWAP_W:\n+      tmp = cpu->regs[rs2];\n+      break;\n+    case MATCH_AMOXOR_D:\n+    case MATCH_AMOXOR_W:\n+      tmp = cpu->regs[rd] ^ cpu->regs[rs2];\n+      break;\n+    default:\n+      TRACE_INSN (cpu, \"UNHANDLED INSN: %s\", op->name);\n+      sim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL);\n+    }\n+\n+  if (op->xlen_requirement == 64)\n+    sim_core_write_unaligned_8 (cpu, cpu->pc, write_map, cpu->regs[rs1], tmp);\n+  else\n+    sim_core_write_unaligned_4 (cpu, cpu->pc, write_map, cpu->regs[rs1], tmp);\n+\n+ done:\n+  return pc;\n+}\n+\n+static sim_cia\n+execute_one (SIM_CPU *cpu, unsigned_word iw, const struct riscv_opcode *op)\n+{\n+  SIM_DESC sd = CPU_STATE (cpu);\n+\n+  if (op->xlen_requirement == 32)\n+    RISCV_ASSERT_RV32 (cpu, \"insn: %s\", op->name);\n+  else if (op->xlen_requirement == 64)\n+    RISCV_ASSERT_RV64 (cpu, \"insn: %s\", op->name);\n+\n+  switch (op->insn_class)\n+    {\n+    case INSN_CLASS_A:\n+      return execute_a (cpu, iw, op);\n+    case INSN_CLASS_I:\n+      return execute_i (cpu, iw, op);\n+    case INSN_CLASS_M:\n+      return execute_m (cpu, iw, op);\n+    default:\n+      TRACE_INSN (cpu, \"UNHANDLED EXTENSION: %d\", op->insn_class);\n+      sim_engine_halt (sd, cpu, NULL, cpu->pc, sim_signalled, SIM_SIGILL);\n+    }\n+\n+  return cpu->pc + riscv_insn_length (iw);\n+}\n+\n+/* Decode & execute a single instruction.  */\n+void step_once (SIM_CPU *cpu)\n+{\n+  SIM_DESC sd = CPU_STATE (cpu);\n+  unsigned_word iw;\n+  unsigned int len;\n+  sim_cia pc = cpu->pc;\n+  const struct riscv_opcode *op;\n+  int xlen = RISCV_XLEN (cpu);\n+\n+  if (TRACE_ANY_P (cpu))\n+    trace_prefix (sd, cpu, NULL_CIA, pc, TRACE_LINENUM_P (cpu),\n+\t\t  NULL, 0, \" \"); /* Use a space for gcc warnings.  */\n+\n+  iw = sim_core_read_aligned_2 (cpu, pc, exec_map, pc);\n+\n+  /* Reject non-32-bit opcodes first.  */\n+  len = riscv_insn_length (iw);\n+  if (len != 4)\n+    {\n+      sim_io_printf (sd, \"sim: bad insn len %#x @ %#\" PRIxTA \": %#\" PRIxTW \"\\n\",\n+\t\t     len, pc, iw);\n+      sim_engine_halt (sd, cpu, NULL, pc, sim_signalled, SIM_SIGILL);\n+    }\n+\n+  iw |= ((unsigned_word) sim_core_read_aligned_2 (\n+    cpu, pc, exec_map, pc + 2) << 16);\n+\n+  TRACE_CORE (cpu, \"0x%08\" PRIxTW, iw);\n+\n+  op = riscv_hash[OP_HASH_IDX (iw)];\n+  if (!op)\n+    sim_engine_halt (sd, cpu, NULL, pc, sim_signalled, SIM_SIGILL);\n+\n+  /* NB: Same loop logic as riscv_disassemble_insn.  */\n+  for (; op->name; op++)\n+    {\n+      /* Does the opcode match?  */\n+      if (! op->match_func (op, iw))\n+\tcontinue;\n+      /* Is this a pseudo-instruction and may we print it as such?  */\n+      if (op->pinfo & INSN_ALIAS)\n+\tcontinue;\n+      /* Is this instruction restricted to a certain value of XLEN?  */\n+      if (op->xlen_requirement != 0 && op->xlen_requirement != xlen)\n+\tcontinue;\n+\n+      /* It's a match.  */\n+      pc = execute_one (cpu, iw, op);\n+      break;\n+    }\n+\n+  /* TODO: Handle overflow into high 32 bits.  */\n+  /* TODO: Try to use a common counter and only update on demand (reads).  */\n+  ++cpu->csr.cycle;\n+  ++cpu->csr.instret;\n+\n+  cpu->pc = pc;\n+}\n+\f\n+/* Return the program counter for this cpu. */\n+static sim_cia\n+pc_get (sim_cpu *cpu)\n+{\n+  return cpu->pc;\n+}\n+\n+/* Set the program counter for this cpu to the new pc value. */\n+static void\n+pc_set (sim_cpu *cpu, sim_cia pc)\n+{\n+  cpu->pc = pc;\n+}\n+\n+/* Initialize the state for a single cpu.  Usuaully this involves clearing all\n+   registers back to their reset state.  Should also hook up the fetch/store\n+   helper functions too.  */\n+void\n+initialize_cpu (SIM_DESC sd, SIM_CPU *cpu, int mhartid)\n+{\n+  const char *extensions;\n+  int i;\n+\n+  memset (cpu->regs, 0, sizeof (cpu->regs));\n+\n+  CPU_PC_FETCH (cpu) = pc_get;\n+  CPU_PC_STORE (cpu) = pc_set;\n+\n+  if (!riscv_hash[0])\n+    {\n+      const struct riscv_opcode *op;\n+\n+      for (op = riscv_opcodes; op->name; op++)\n+\tif (!riscv_hash[OP_HASH_IDX (op->match)])\n+\t  riscv_hash[OP_HASH_IDX (op->match)] = op;\n+    }\n+\n+  cpu->csr.misa = 0;\n+  /* RV32 sets this field to 0, and we don't really support RV128 yet.  */\n+  if (RISCV_XLEN (cpu) == 64)\n+    cpu->csr.misa |= (unsigned64)2 << 62;\n+\n+  /* Skip the leading \"rv\" prefix and the two numbers.  */\n+  extensions = MODEL_NAME (CPU_MODEL (cpu)) + 4;\n+  for (i = 0; i < 26; ++i)\n+    {\n+      char ext = 'A' + i;\n+\n+      if (ext == 'X')\n+\tcontinue;\n+      else if (strchr (extensions, ext) != NULL)\n+\t{\n+\t  if (ext == 'G')\n+\t    cpu->csr.misa |= 0x1129;  /* G = IMAFD.  */\n+\t  else\n+\t    cpu->csr.misa |= (1 << i);\n+\t}\n+    }\n+\n+  cpu->csr.mimpid = 0x8000;\n+  cpu->csr.mhartid = mhartid;\n+}\n+\f\n+/* Some utils don't like having a NULL environ.  */\n+static const char * const simple_env[] = { \"HOME=/\", \"PATH=/bin\", NULL };\n+\n+/* Count the number of arguments in an argv.  */\n+static int\n+count_argv (const char * const *argv)\n+{\n+  int i;\n+\n+  if (!argv)\n+    return -1;\n+\n+  for (i = 0; argv[i] != NULL; ++i)\n+    continue;\n+  return i;\n+}\n+\n+void\n+initialize_env (SIM_DESC sd, const char * const *argv, const char * const *env)\n+{\n+  SIM_CPU *cpu = STATE_CPU (sd, 0);\n+  int i;\n+  int argc, argv_flat;\n+  int envc, env_flat;\n+  address_word sp, sp_flat;\n+  unsigned char null[8] = { 0, 0, 0, 0, 0, 0, 0, 0, };\n+\n+  /* Figure out how many bytes the argv strings take up.  */\n+  argc = count_argv (argv);\n+  if (argc == -1)\n+    argc = 0;\n+  argv_flat = argc; /* NUL bytes.  */\n+  for (i = 0; i < argc; ++i)\n+    argv_flat += strlen (argv[i]);\n+\n+  /* Figure out how many bytes the environ strings take up.  */\n+  if (!env)\n+    env = simple_env;\n+  envc = count_argv (env);\n+  env_flat = envc; /* NUL bytes.  */\n+  for (i = 0; i < envc; ++i)\n+    env_flat += strlen (env[i]);\n+\n+  /* Make space for the strings themselves.  */\n+  sp_flat = (DEFAULT_MEM_SIZE - argv_flat - env_flat) & -sizeof (address_word);\n+  /* Then the pointers to the strings.  */\n+  sp = sp_flat - ((argc + 1 + envc + 1) * sizeof (address_word));\n+  /* Then the argc.  */\n+  sp -= sizeof (unsigned_word);\n+\n+  /* Set up the regs the libgloss crt0 expects.  */\n+  cpu->a0 = argc;\n+  cpu->sp = sp;\n+\n+  /* First push the argc value.  */\n+  sim_write (sd, sp, (void *)&argc, sizeof (unsigned_word));\n+  sp += sizeof (unsigned_word);\n+\n+  /* Then the actual argv strings so we know where to point argv[].  */\n+  for (i = 0; i < argc; ++i)\n+    {\n+      unsigned len = strlen (argv[i]) + 1;\n+      sim_write (sd, sp_flat, (void *)argv[i], len);\n+      sim_write (sd, sp, (void *)&sp_flat, sizeof (address_word));\n+      sp_flat += len;\n+      sp += sizeof (address_word);\n+    }\n+  sim_write (sd, sp, null, sizeof (address_word));\n+  sp += sizeof (address_word);\n+\n+  /* Then the actual env strings so we know where to point env[].  */\n+  for (i = 0; i < envc; ++i)\n+    {\n+      unsigned len = strlen (env[i]) + 1;\n+      sim_write (sd, sp_flat, (void *)env[i], len);\n+      sim_write (sd, sp, (void *)&sp_flat, sizeof (address_word));\n+      sp_flat += len;\n+      sp += sizeof (address_word);\n+    }\n+}"
    },
    {
      "sha": "4a1b31ee2fec3ae408ba19476f853c54032d16a0",
      "filename": "sim/riscv/sim-main.h",
      "status": "added",
      "additions": 86,
      "deletions": 0,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/sim-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/riscv/sim-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/riscv/sim-main.h?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,86 @@\n+/* RISC-V simulator.\n+\n+   Copyright (C) 2005-2021 Free Software Foundation, Inc.\n+   Contributed by Mike Frysinger.\n+\n+   This file is part of simulators.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef SIM_MAIN_H\n+#define SIM_MAIN_H\n+\n+#include \"sim-basics.h\"\n+#include \"machs.h\"\n+#include \"sim-base.h\"\n+\n+struct _sim_cpu {\n+  union {\n+    unsigned_word regs[32];\n+    struct {\n+      /* These are the ABI names.  */\n+      unsigned_word zero, ra, sp, gp, tp;\n+      unsigned_word t0, t1, t2;\n+      unsigned_word s0, s1;\n+      unsigned_word a0, a1, a2, a3, a4, a5, a6, a7;\n+      unsigned_word s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n+      unsigned_word t3, t4, t5, t6;\n+    };\n+  };\n+  union {\n+    unsigned_word fpregs[32];\n+    struct {\n+      /* These are the ABI names.  */\n+      unsigned_word ft0, ft1, ft2, ft3, ft4, ft5, ft6, ft7;\n+      unsigned_word fs0, fs1;\n+      unsigned_word fa0, fa1, fa2, fa3, fa4, fa5, fa6, fa7;\n+      unsigned_word fs2, fs3, fs4, fs5, fs6, fs7, fs8, fs9, fs10, fs11;\n+      unsigned_word ft8, ft9, ft10, ft11;\n+    };\n+  };\n+  sim_cia pc;\n+\n+  struct {\n+#define DECLARE_CSR(name, ...) unsigned_word name;\n+#include \"opcode/riscv-opc.h\"\n+#undef DECLARE_CSR\n+  } csr;\n+\n+  sim_cpu_base base;\n+};\n+\n+struct atomic_mem_reserved_list;\n+struct atomic_mem_reserved_list {\n+  struct atomic_mem_reserved_list *next;\n+  address_word addr;\n+};\n+\n+struct sim_state {\n+  sim_cpu *cpu[MAX_NR_PROCESSORS];\n+  struct atomic_mem_reserved_list *amo_reserved_list;\n+\n+  /* ... simulator specific members ... */\n+  sim_state_base base;\n+};\n+\n+extern void step_once (SIM_CPU *);\n+extern void initialize_cpu (SIM_DESC, SIM_CPU *, int);\n+extern void initialize_env (SIM_DESC, const char * const *argv,\n+\t\t\t    const char * const *env);\n+\n+#define DEFAULT_MEM_SIZE (64 * 1024 * 1024)\n+\n+#define RISCV_XLEN(cpu) MACH_WORD_BITSIZE (CPU_MACH (cpu))\n+\n+#endif"
    },
    {
      "sha": "3b2b8df8ffe763f2bc30426592594f5c08b4061e",
      "filename": "sim/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/testsuite/ChangeLog?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -1,3 +1,7 @@\n+2021-02-04  Mike Frysinger  <vapier@gentoo.org>\n+\n+\t* riscv/: New directory.\n+\n 2021-01-15  Mike Frysinger  <vapier@gentoo.org>\n \n \t* Makefile.in (site.exp): Delete tool setting."
    },
    {
      "sha": "c222209850ed1ecc079deec8c94a5ae3f16890b4",
      "filename": "sim/testsuite/riscv/ChangeLog",
      "status": "added",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/riscv/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/riscv/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/testsuite/riscv/ChangeLog?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,3 @@\n+2021-02-04  Mike Frysinger  <vapier@gentoo.org>\n+\n+\t* allinsn.exp, pass.s, testutils.inc: New files."
    },
    {
      "sha": "03bec1b541e7c9f5629d7a513765e23690d4b7a8",
      "filename": "sim/testsuite/riscv/allinsn.exp",
      "status": "added",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/riscv/allinsn.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/riscv/allinsn.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/testsuite/riscv/allinsn.exp?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,15 @@\n+# RISC-V simulator testsuite.\n+\n+if [istarget riscv*-*] {\n+    # all machines\n+    set all_machs \"riscv\"\n+\n+    foreach src [lsort [glob -nocomplain $srcdir/$subdir/*.s]] {\n+\t# If we're only testing specific files and this isn't one of them,\n+\t# skip it.\n+\tif ![runtest_file_p $runtests $src] {\n+\t    continue\n+\t}\n+\trun_sim_test $src $all_machs\n+    }\n+}"
    },
    {
      "sha": "bd428ca16772ec0b093553d86e728da1c72b203a",
      "filename": "sim/testsuite/riscv/pass.s",
      "status": "added",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/riscv/pass.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/riscv/pass.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/testsuite/riscv/pass.s?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,7 @@\n+# check that the sim doesn't die immediately.\n+# mach: riscv\n+\n+.include \"testutils.inc\"\n+\n+\tstart\n+\tpass"
    },
    {
      "sha": "b9680b9c22e09c3591d82408c3bc47d314e2feb7",
      "filename": "sim/testsuite/riscv/testutils.inc",
      "status": "added",
      "additions": 52,
      "deletions": 0,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/riscv/testutils.inc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b9249c461c72b35dd9b6f274406c336f6a68ae98/sim/testsuite/riscv/testutils.inc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/sim/testsuite/riscv/testutils.inc?ref=b9249c461c72b35dd9b6f274406c336f6a68ae98",
      "patch": "@@ -0,0 +1,52 @@\n+# MACRO: exit\n+\t.macro exit nr\n+\tli a0, \\nr\n+\t# The exit utility function.\n+\tli a7, 93;\n+\t# Trigger OS trap.\n+\tecall;\n+\t.endm\n+\n+# MACRO: pass\n+# Write 'pass' to stdout and quit.\n+\t.macro pass\n+\t# syscall write().\n+\tli a7, 64;\n+\t# Use stdout.\n+\tli a0, 1;\n+\t# Point to the string.\n+\tlla a1, 1f;\n+\t# Number of bytes to write.\n+\tli a2, 5;\n+\t# Trigger OS trap.\n+\tecall;\n+\texit 0;\n+\t.data\n+\t1: .asciz \"pass\\n\"\n+\t.endm\n+\n+# MACRO: fail\n+# Write 'fail' to stdout and quit.\n+\t.macro fail\n+\t# syscall write().\n+\tli a7, 64;\n+\t# Use stdout.\n+\tli a0, 1;\n+\t# Point to the string.\n+\tlla a1, 1f;\n+\t# Number of bytes to write.\n+\tli a2, 5;\n+\t# Trigger OS trap.\n+\tecall;\n+\texit 0;\n+\t.data\n+\t1: .asciz \"fail\\n\"\n+\t.endm\n+\n+# MACRO: start\n+# All assembler tests should start with a call to \"start\".\n+\t.macro start\n+\t.text\n+.global _start\n+_start:\n+\t.endm"
    }
  ]
}