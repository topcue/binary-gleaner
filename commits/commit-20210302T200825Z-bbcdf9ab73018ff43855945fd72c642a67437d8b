{
  "sha": "bbcdf9ab73018ff43855945fd72c642a67437d8b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YmJjZGY5YWI3MzAxOGZmNDM4NTU5NDVmZDcyYzY0MmE2NzQzN2Q4Yg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-03-02T20:08:24Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-03-02T20:08:25Z"
    },
    "message": "Rewrite GNAT-encoded fixed point types in DWARF reader\n\ngdb currently supports two different styles of fixed-point.  The\noriginal style, where fixed point types are \"GNAT encoded\", is handled\nprimarily in the Ada code.  The newer style, encoded using DWARF, is\nhandled by the core of gdb.\n\nThis patch changes gdb to read the GNAT encodings in the DWARF reader\nas well.  This removes some code and unifies the two paths.  As a\nresult, GNAT-encoded fixed-point now works a bit better.\n\nOne possible drawback of this change is that, if someone uses stabs,\nthen fixed-point might now stop working.  I consider stabs to be fully\nobsolete, though, so I don't intend to address this.\n\ngdb/ChangeLog\n2021-03-02  Tom Tromey  <tromey@adacore.com>\n\n\t* ada-lang.c (cast_from_gnat_encoded_fixed_point_type)\n\t(cast_to_gnat_encoded_fixed_point_type): Remove.\n\t(ada_value_cast, ada_evaluate_subexp): Update.\n\t(gnat_encoded_fixed_point_type_info)\n\t(ada_is_gnat_encoded_fixed_point_type)\n\t(gnat_encoded_fixed_point_delta)\n\t(gnat_encoded_fixed_point_scaling_factor): Remove.\n\t* ada-lang.h (ada_is_gnat_encoded_fixed_point_type)\n\t(gnat_encoded_fixed_point_delta)\n\t(gnat_encoded_fixed_point_scaling_factor): Don't declare.\n\t* ada-typeprint.c (print_gnat_encoded_fixed_point_type): Remove.\n\t(ada_print_type): Update.\n\t* ada-valprint.c (ada_value_print_num): Update.\n\t* dwarf2/read.c (ada_get_gnat_encoded_number)\n\t(ada_get_gnat_encoded_ratio): New functions.\n\t(finish_fixed_point_type): Use them.  Add parameters.\n\t(GNAT_FIXED_POINT_SUFFIX): New define.\n\t(gnat_encoded_fixed_point_type_info): New function.\n\t(read_base_type): Handle gnat encodings.\n\ngdb/testsuite/ChangeLog\n2021-03-02  Tom Tromey  <tromey@adacore.com>\n\n\t* gdb.ada/fixed_points.exp: Remove most special cases for minimal\n\tencodings.",
    "tree": {
      "sha": "2ee63dbc9109b91a86545693e6091d9e0e4de82d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2ee63dbc9109b91a86545693e6091d9e0e4de82d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bbcdf9ab73018ff43855945fd72c642a67437d8b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bbcdf9ab73018ff43855945fd72c642a67437d8b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bbcdf9ab73018ff43855945fd72c642a67437d8b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bbcdf9ab73018ff43855945fd72c642a67437d8b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/5f9febe0f6ef980d120f9fb5850c0fd3c8fddfa5"
    }
  ],
  "stats": {
    "total": 505,
    "additions": 198,
    "deletions": 307
  },
  "files": [
    {
      "sha": "518e5c29218c7180310bdf0a536450e6087e71d7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 22,
      "deletions": 0,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=bbcdf9ab73018ff43855945fd72c642a67437d8b",
      "patch": "@@ -1,3 +1,25 @@\n+2021-03-02  Tom Tromey  <tromey@adacore.com>\n+\n+\t* ada-lang.c (cast_from_gnat_encoded_fixed_point_type)\n+\t(cast_to_gnat_encoded_fixed_point_type): Remove.\n+\t(ada_value_cast, ada_evaluate_subexp): Update.\n+\t(gnat_encoded_fixed_point_type_info)\n+\t(ada_is_gnat_encoded_fixed_point_type)\n+\t(gnat_encoded_fixed_point_delta)\n+\t(gnat_encoded_fixed_point_scaling_factor): Remove.\n+\t* ada-lang.h (ada_is_gnat_encoded_fixed_point_type)\n+\t(gnat_encoded_fixed_point_delta)\n+\t(gnat_encoded_fixed_point_scaling_factor): Don't declare.\n+\t* ada-typeprint.c (print_gnat_encoded_fixed_point_type): Remove.\n+\t(ada_print_type): Update.\n+\t* ada-valprint.c (ada_value_print_num): Update.\n+\t* dwarf2/read.c (ada_get_gnat_encoded_number)\n+\t(ada_get_gnat_encoded_ratio): New functions.\n+\t(finish_fixed_point_type): Use them.  Add parameters.\n+\t(GNAT_FIXED_POINT_SUFFIX): New define.\n+\t(gnat_encoded_fixed_point_type_info): New function.\n+\t(read_base_type): Handle gnat encodings.\n+\n 2021-03-02  Tom Tromey  <tromey@adacore.com>\n \n \t* ada-lang.c (ada_fold_name, ada_variant_discrim_name)"
    },
    {
      "sha": "7d94586c7f286e9e52597520d33f3acb145a62d6",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 150,
      "changes": 152,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=bbcdf9ab73018ff43855945fd72c642a67437d8b",
      "patch": "@@ -9129,33 +9129,6 @@ unwrap_value (struct value *val)\n     }\n }\n \n-static struct value *\n-cast_from_gnat_encoded_fixed_point_type (struct type *type, struct value *arg)\n-{\n-  struct value *scale\n-    = gnat_encoded_fixed_point_scaling_factor (value_type (arg));\n-  arg = value_cast (value_type (scale), arg);\n-\n-  arg = value_binop (arg, scale, BINOP_MUL);\n-  return value_cast (type, arg);\n-}\n-\n-static struct value *\n-cast_to_gnat_encoded_fixed_point_type (struct type *type, struct value *arg)\n-{\n-  if (type == value_type (arg))\n-    return arg;\n-\n-  struct value *scale = gnat_encoded_fixed_point_scaling_factor (type);\n-  if (ada_is_gnat_encoded_fixed_point_type (value_type (arg)))\n-    arg = cast_from_gnat_encoded_fixed_point_type (value_type (scale), arg);\n-  else\n-    arg = value_cast (value_type (scale), arg);\n-\n-  arg = value_binop (arg, scale, BINOP_DIV);\n-  return value_cast (type, arg);\n-}\n-\n /* Given two array types T1 and T2, return nonzero iff both arrays\n    contain the same number of elements.  */\n \n@@ -9655,12 +9628,6 @@ ada_value_cast (struct type *type, struct value *arg2)\n   if (type == ada_check_typedef (value_type (arg2)))\n     return arg2;\n \n-  if (ada_is_gnat_encoded_fixed_point_type (type))\n-    return cast_to_gnat_encoded_fixed_point_type (type, arg2);\n-\n-  if (ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n-    return cast_from_gnat_encoded_fixed_point_type (type, arg2);\n-\n   return value_cast (type, arg2);\n }\n \n@@ -10058,11 +10025,6 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n \t{\n \t  /* Nothing.  */\n \t}\n-      else if (ada_is_gnat_encoded_fixed_point_type (value_type (arg1)))\n-\targ2 = cast_to_gnat_encoded_fixed_point_type (value_type (arg1), arg2);\n-      else if (ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n-\terror\n-\t  (_(\"Fixed-point values must be assigned to fixed-point variables\"));\n       else\n \targ2 = coerce_for_assign (value_type (arg1), arg2);\n       return ada_value_assign (arg1, arg2);\n@@ -10086,14 +10048,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       type = value_type (arg1);\n       while (type->code () == TYPE_CODE_REF)\n \ttype = TYPE_TARGET_TYPE (type);\n-      if (ada_is_gnat_encoded_fixed_point_type (value_type (arg1))\n-\t  || ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n-\t{\n-\t  if (value_type (arg1) != value_type (arg2))\n-\t    error (_(\"Operands of fixed-point addition must have the same type\"));\n-\t}\n-      else\n-\tbinop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n+      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n       arg1 = value_binop (arg1, arg2, BINOP_ADD);\n       /* We need to special-case the result of adding to a range.\n \t This is done for the benefit of \"ptype\".  gdb's Ada support\n@@ -10122,15 +10077,7 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       type = value_type (arg1);\n       while (type->code () == TYPE_CODE_REF)\n \ttype = TYPE_TARGET_TYPE (type);\n-      if (ada_is_gnat_encoded_fixed_point_type (value_type (arg1))\n-\t  || ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n-\t{\n-\t  if (value_type (arg1) != value_type (arg2))\n-\t    error (_(\"Operands of fixed-point subtraction \"\n-\t\t     \"must have the same type\"));\n-\t}\n-      else\n-\tbinop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n+      binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n       arg1 = value_binop (arg1, arg2, BINOP_SUB);\n       /* We need to special-case the result of adding to a range.\n \t This is done for the benefit of \"ptype\".  gdb's Ada support\n@@ -10156,10 +10103,6 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       else\n \t{\n \t  type = builtin_type (exp->gdbarch)->builtin_double;\n-\t  if (ada_is_gnat_encoded_fixed_point_type (value_type (arg1)))\n-\t    arg1 = cast_from_gnat_encoded_fixed_point_type (type, arg1);\n-\t  if (ada_is_gnat_encoded_fixed_point_type (value_type (arg2)))\n-\t    arg2 = cast_from_gnat_encoded_fixed_point_type (type, arg2);\n \t  binop_promote (exp->language_defn, exp->gdbarch, &arg1, &arg2);\n \t  return ada_value_binop (arg1, arg2, op);\n \t}\n@@ -10186,8 +10129,6 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n       arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       if (noside == EVAL_SKIP)\n \tgoto nosideret;\n-      else if (ada_is_gnat_encoded_fixed_point_type (value_type (arg1)))\n-\treturn value_cast (value_type (arg1), value_neg (arg1));\n       else\n \t{\n \t  unop_promote (exp->language_defn, exp->gdbarch, &arg1);\n@@ -11053,41 +10994,6 @@ ada_evaluate_subexp (struct type *expect_type, struct expression *exp,\n }\n \f\n \n-\t\t\t\t/* Fixed point */\n-\n-/* If TYPE encodes an Ada fixed-point type, return the suffix of the\n-   type name that encodes the 'small and 'delta information.\n-   Otherwise, return NULL.  */\n-\n-static const char *\n-gnat_encoded_fixed_point_type_info (struct type *type)\n-{\n-  const char *name = ada_type_name (type);\n-  enum type_code code = (type == NULL) ? TYPE_CODE_UNDEF : type->code ();\n-\n-  if ((code == TYPE_CODE_INT || code == TYPE_CODE_RANGE) && name != NULL)\n-    {\n-      const char *tail = strstr (name, \"___XF_\");\n-\n-      if (tail == NULL)\n-\treturn NULL;\n-      else\n-\treturn tail + 5;\n-    }\n-  else if (code == TYPE_CODE_RANGE && TYPE_TARGET_TYPE (type) != type)\n-    return gnat_encoded_fixed_point_type_info (TYPE_TARGET_TYPE (type));\n-  else\n-    return NULL;\n-}\n-\n-/* Returns non-zero iff TYPE represents an Ada fixed-point type.  */\n-\n-int\n-ada_is_gnat_encoded_fixed_point_type (struct type *type)\n-{\n-  return gnat_encoded_fixed_point_type_info (type) != NULL;\n-}\n-\n /* Return non-zero iff TYPE represents a System.Address type.  */\n \n int\n@@ -11096,60 +11002,6 @@ ada_is_system_address_type (struct type *type)\n   return (type->name () && strcmp (type->name (), \"system__address\") == 0);\n }\n \n-/* Assuming that TYPE is the representation of an Ada fixed-point\n-   type, return the target floating-point type to be used to represent\n-   of this type during internal computation.  */\n-\n-static struct type *\n-ada_scaling_type (struct type *type)\n-{\n-  return builtin_type (type->arch ())->builtin_long_double;\n-}\n-\n-/* Assuming that TYPE is the representation of an Ada fixed-point\n-   type, return its delta, or NULL if the type is malformed and the\n-   delta cannot be determined.  */\n-\n-struct value *\n-gnat_encoded_fixed_point_delta (struct type *type)\n-{\n-  const char *encoding = gnat_encoded_fixed_point_type_info (type);\n-  struct type *scale_type = ada_scaling_type (type);\n-\n-  long long num, den;\n-\n-  if (sscanf (encoding, \"_%lld_%lld\", &num, &den) < 2)\n-    return nullptr;\n-  else\n-    return value_binop (value_from_longest (scale_type, num),\n-\t\t\tvalue_from_longest (scale_type, den), BINOP_DIV);\n-}\n-\n-/* Assuming that ada_is_gnat_encoded_fixed_point_type (TYPE), return\n-   the scaling factor ('SMALL value) associated with the type.  */\n-\n-struct value *\n-gnat_encoded_fixed_point_scaling_factor (struct type *type)\n-{\n-  const char *encoding = gnat_encoded_fixed_point_type_info (type);\n-  struct type *scale_type = ada_scaling_type (type);\n-\n-  long long num0, den0, num1, den1;\n-  int n;\n-\n-  n = sscanf (encoding, \"_%lld_%lld_%lld_%lld\",\n-\t      &num0, &den0, &num1, &den1);\n-\n-  if (n < 2)\n-    return value_from_longest (scale_type, 1);\n-  else if (n == 4)\n-    return value_binop (value_from_longest (scale_type, num1),\n-\t\t\tvalue_from_longest (scale_type, den1), BINOP_DIV);\n-  else\n-    return value_binop (value_from_longest (scale_type, num0),\n-\t\t\tvalue_from_longest (scale_type, den0), BINOP_DIV);\n-}\n-\n \f\n \n \t\t\t\t/* Range types */"
    },
    {
      "sha": "c3807339559e114b31483114442b3a2e36b3d594",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=bbcdf9ab73018ff43855945fd72c642a67437d8b",
      "patch": "@@ -280,14 +280,8 @@ extern struct type *ada_aligned_type (struct type *);\n extern const gdb_byte *ada_aligned_value_addr (struct type *,\n \t\t\t\t\t       const gdb_byte *);\n \n-extern int ada_is_gnat_encoded_fixed_point_type (struct type *);\n-\n extern int ada_is_system_address_type (struct type *);\n \n-extern struct value *gnat_encoded_fixed_point_delta (struct type *);\n-\n-extern struct value *gnat_encoded_fixed_point_scaling_factor (struct type *);\n-\n extern int ada_which_variant_applies (struct type *, struct value *);\n \n extern struct type *ada_to_fixed_type (struct type *, const gdb_byte *,"
    },
    {
      "sha": "54bbe0f1a011ddc21b9332cedccd29a9b6bc0c54",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 14,
      "deletions": 44,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=bbcdf9ab73018ff43855945fd72c642a67437d8b",
      "patch": "@@ -339,31 +339,6 @@ print_enum_type (struct type *type, struct ui_file *stream)\n   fprintf_filtered (stream, \")\");\n }\n \n-/* Print representation of Ada fixed-point type TYPE on STREAM.  */\n-\n-static void\n-print_gnat_encoded_fixed_point_type (struct type *type, struct ui_file *stream)\n-{\n-  struct value *delta = gnat_encoded_fixed_point_delta (type);\n-  struct value *small = gnat_encoded_fixed_point_scaling_factor (type);\n-\n-  if (delta == nullptr)\n-    fprintf_filtered (stream, \"delta ??\");\n-  else\n-    {\n-      std::string str;\n-      str = target_float_to_string (value_contents (delta),\n-\t\t\t\t    value_type (delta), \"%g\");\n-      fprintf_filtered (stream, \"delta %s\", str.c_str());\n-      if (!value_equal (delta, small))\n-\t{\n-\t  str = target_float_to_string (value_contents (small),\n-\t\t\t\t\tvalue_type (small), \"%g\");\n-\t  fprintf_filtered (stream, \" <'small = %s>\", str.c_str());\n-\t}\n-    }\n-}\n-\n /* Print simple (constrained) array type TYPE on STREAM.  LEVEL is the\n    recursion (indentation) level, in case the element type itself has\n    nested structure, and SHOW is the number of levels of internal\n@@ -1026,27 +1001,22 @@ ada_print_type (struct type *type0, const char *varstring,\n \tfprintf_filtered (stream, \"(false, true)\");\n \tbreak;\n       case TYPE_CODE_INT:\n-\tif (ada_is_gnat_encoded_fixed_point_type (type))\n-\t  print_gnat_encoded_fixed_point_type (type, stream);\n-\telse\n-\t  {\n-\t    const char *name = ada_type_name (type);\n-\n-\t    if (!ada_is_range_type_name (name))\n-\t      fprintf_styled (stream, metadata_style.style (),\n-\t\t\t      _(\"<%s-byte integer>\"),\n-\t\t\t      pulongest (TYPE_LENGTH (type)));\n-\t    else\n-\t      {\n-\t\tfprintf_filtered (stream, \"range \");\n-\t\tprint_range_type (type, stream, 1 /* bounds_prefered_p */);\n-\t      }\n-\t  }\n+\t{\n+\t  const char *name = ada_type_name (type);\n+\n+\t  if (!ada_is_range_type_name (name))\n+\t    fprintf_styled (stream, metadata_style.style (),\n+\t\t\t    _(\"<%s-byte integer>\"),\n+\t\t\t    pulongest (TYPE_LENGTH (type)));\n+\t  else\n+\t    {\n+\t      fprintf_filtered (stream, \"range \");\n+\t      print_range_type (type, stream, 1 /* bounds_prefered_p */);\n+\t    }\n+\t}\n \tbreak;\n       case TYPE_CODE_RANGE:\n-\tif (ada_is_gnat_encoded_fixed_point_type (type))\n-\t  print_gnat_encoded_fixed_point_type (type, stream);\n-\telse if (is_fixed_point_type (type))\n+\tif (is_fixed_point_type (type))\n \t  {\n \t    fprintf_filtered (stream, \"<\");\n \t    print_type_fixed_point (type, stream);"
    },
    {
      "sha": "0d5b6d73076b154131c59428857a73b34ed29b1d",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 16,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=bbcdf9ab73018ff43855945fd72c642a67437d8b",
      "patch": "@@ -741,22 +741,10 @@ ada_value_print_num (struct value *val, struct ui_file *stream, int recurse,\n   struct type *type = ada_check_typedef (value_type (val));\n   const gdb_byte *valaddr = value_contents_for_printing (val);\n \n-  if (ada_is_gnat_encoded_fixed_point_type (type))\n-    {\n-      struct value *scale = gnat_encoded_fixed_point_scaling_factor (type);\n-      val = value_cast (value_type (scale), val);\n-      val = value_binop (val, scale, BINOP_MUL);\n-\n-      const char *fmt = TYPE_LENGTH (type) < 4 ? \"%.11g\" : \"%.17g\";\n-      std::string str\n-\t= target_float_to_string (value_contents (val), value_type (val), fmt);\n-      fputs_filtered (str.c_str (), stream);\n-      return;\n-    }\n-  else if (type->code () == TYPE_CODE_RANGE\n-\t   && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ENUM\n-\t       || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_BOOL\n-\t       || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_CHAR))\n+  if (type->code () == TYPE_CODE_RANGE\n+      && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ENUM\n+\t  || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_BOOL\n+\t  || TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_CHAR))\n     {\n       /* For enum-valued ranges, we want to recurse, because we'll end\n \t up printing the constant's name rather than its numeric"
    },
    {
      "sha": "d4f13229ced091432692811f3f533fba15d88ea4",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 130,
      "deletions": 27,
      "changes": 157,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=bbcdf9ab73018ff43855945fd72c642a67437d8b",
      "patch": "@@ -18408,24 +18408,77 @@ get_dwarf2_unsigned_rational_constant (struct die_info *die,\n   *denominator = std::move (denom);\n }\n \n+/* Assuming that ENCODING is a string whose contents starting at the\n+   K'th character is \"_nn\" where \"nn\" is a decimal number, scan that\n+   number and set RESULT to the value. K is updated to point to the\n+   character immediately following the number.\n+\n+   If the string does not conform to the format described above, false\n+   is returned, and K may or may not be changed.  */\n+\n+static bool\n+ada_get_gnat_encoded_number (const char *encoding, int &k, gdb_mpz *result)\n+{\n+  /* The next character should be an underscore ('_') followed\n+     by a digit.  */\n+  if (encoding[k] != '_' || !isdigit (encoding[k + 1]))\n+    return false;\n+\n+  /* Skip the underscore.  */\n+  k++;\n+  int start = k;\n+\n+  /* Determine the number of digits for our number.  */\n+  while (isdigit (encoding[k]))\n+    k++;\n+  if (k == start)\n+    return false;\n+\n+  std::string copy (&encoding[start], k - start);\n+  if (mpz_set_str (result->val, copy.c_str (), 10) == -1)\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Scan two numbers from ENCODING at OFFSET, assuming the string is of\n+   the form _NN_DD, where NN and DD are decimal numbers.  Set NUM and\n+   DENOM, update OFFSET, and return true on success.  Return false on\n+   failure.  */\n+\n+static bool\n+ada_get_gnat_encoded_ratio (const char *encoding, int &offset,\n+\t\t\t    gdb_mpz *num, gdb_mpz *denom)\n+{\n+  if (!ada_get_gnat_encoded_number (encoding, offset, num))\n+    return false;\n+  return ada_get_gnat_encoded_number (encoding, offset, denom);\n+}\n+\n /* Assuming DIE corresponds to a fixed point type, finish the creation\n-   of the corresponding TYPE by setting its type-specific data.\n-   CU is the DIE's CU.  */\n+   of the corresponding TYPE by setting its type-specific data.  CU is\n+   the DIE's CU.  SUFFIX is the \"XF\" type name suffix coming from GNAT\n+   encodings.  It is nullptr if the GNAT encoding should be\n+   ignored.  */\n \n static void\n-finish_fixed_point_type (struct type *type, struct die_info *die,\n-\t\t\t struct dwarf2_cu *cu)\n+finish_fixed_point_type (struct type *type, const char *suffix,\n+\t\t\t struct die_info *die, struct dwarf2_cu *cu)\n {\n-  struct attribute *attr;\n-\n   gdb_assert (type->code () == TYPE_CODE_FIXED_POINT\n \t      && TYPE_SPECIFIC_FIELD (type) == TYPE_SPECIFIC_FIXED_POINT);\n \n-  attr = dwarf2_attr (die, DW_AT_binary_scale, cu);\n-  if (!attr)\n-    attr = dwarf2_attr (die, DW_AT_decimal_scale, cu);\n-  if (!attr)\n-    attr = dwarf2_attr (die, DW_AT_small, cu);\n+  /* If GNAT encodings are preferred, don't examine the\n+     attributes.  */\n+  struct attribute *attr = nullptr;\n+  if (suffix == nullptr)\n+    {\n+      attr = dwarf2_attr (die, DW_AT_binary_scale, cu);\n+      if (attr == nullptr)\n+\tattr = dwarf2_attr (die, DW_AT_decimal_scale, cu);\n+      if (attr == nullptr)\n+\tattr = dwarf2_attr (die, DW_AT_small, cu);\n+    }\n \n   /* Numerator and denominator of our fixed-point type's scaling factor.\n      The default is a scaling factor of 1, which we use as a fallback\n@@ -18438,11 +18491,29 @@ finish_fixed_point_type (struct type *type, struct die_info *die,\n \n   if (attr == nullptr)\n     {\n-      /* Scaling factor not found.  Assume a scaling factor of 1,\n-\t and hope for the best.  At least the user will be able to see\n-\t the encoded value.  */\n-      complaint (_(\"no scale found for fixed-point type (DIE at %s)\"),\n-\t\t sect_offset_str (die->sect_off));\n+      int offset = 0;\n+      if (suffix != nullptr\n+\t  && ada_get_gnat_encoded_ratio (suffix, offset, &scale_num,\n+\t\t\t\t\t &scale_denom)\n+\t  /* The number might be encoded as _nn_dd_nn_dd, where the\n+\t     second ratio is the 'small value.  In this situation, we\n+\t     want the second value.  */\n+\t  && (suffix[offset] != '_'\n+\t      || ada_get_gnat_encoded_ratio (suffix, offset, &scale_num,\n+\t\t\t\t\t     &scale_denom)))\n+\t{\n+\t  /* Found it.  */\n+\t}\n+      else\n+\t{\n+\t  /* Scaling factor not found.  Assume a scaling factor of 1,\n+\t     and hope for the best.  At least the user will be able to\n+\t     see the encoded value.  */\n+\t  scale_num = 1;\n+\t  scale_denom = 1;\n+\t  complaint (_(\"no scale found for fixed-point type (DIE at %s)\"),\n+\t\t     sect_offset_str (die->sect_off));\n+\t}\n     }\n   else if (attr->name == DW_AT_binary_scale)\n     {\n@@ -18486,6 +18557,20 @@ finish_fixed_point_type (struct type *type, struct die_info *die,\n   mpq_canonicalize (scaling_factor.val);\n }\n \n+/* The gnat-encoding suffix for fixed point.  */\n+\n+#define GNAT_FIXED_POINT_SUFFIX \"___XF_\"\n+\n+/* If NAME encodes an Ada fixed-point type, return a pointer to the\n+   \"XF\" suffix of the name.  The text after this is what encodes the\n+   'small and 'delta information.  Otherwise, return nullptr.  */\n+\n+static const char *\n+gnat_encoded_fixed_point_type_info (const char *name)\n+{\n+  return strstr (name, GNAT_FIXED_POINT_SUFFIX);\n+}\n+\n /* Allocate a floating-point type of size BITS and name NAME.  Pass NAME_HINT\n    (which may be different from NAME) to the architecture back-end to allow\n    it to guess the correct format if necessary.  */\n@@ -18674,20 +18759,38 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n \t of fixed point types for which GNAT is unable to provide\n \t the scaling factor via the standard DWARF mechanisms, and\n \t for which the info is provided via the GNAT encodings instead.\n-\t This is likely what this DIE is about.\n-\n-\t Ideally, GNAT should be declaring this type the same way\n-\t it declares other fixed point types when using the legacy\n-\t GNAT encoding, which is to use a simple signed or unsigned\n-\t base type.  A report to the GNAT team has been created to\n-\t look into it.  In the meantime, pretend this type is a simple\n-\t signed or unsigned integral, rather than a fixed point type,\n-\t to avoid any confusion later on as to how to process this type.  */\n+\t This is likely what this DIE is about.  */\n       encoding = (encoding == DW_ATE_signed_fixed\n \t\t  ? DW_ATE_signed\n \t\t  : DW_ATE_unsigned);\n     }\n \n+  /* With GNAT encodings, fixed-point information will be encoded in\n+     the type name.  Note that this can also occur with the above\n+     zero-over-zero case, which is why this is a separate \"if\" rather\n+     than an \"else if\".  */\n+  const char *gnat_encoding_suffix = nullptr;\n+  if ((encoding == DW_ATE_signed || encoding == DW_ATE_unsigned)\n+      && cu->language == language_ada\n+      && name != nullptr)\n+    {\n+      gnat_encoding_suffix = gnat_encoded_fixed_point_type_info (name);\n+      if (gnat_encoding_suffix != nullptr)\n+\t{\n+\t  gdb_assert (startswith (gnat_encoding_suffix,\n+\t\t\t\t  GNAT_FIXED_POINT_SUFFIX));\n+\t  name = obstack_strndup (&cu->per_objfile->objfile->objfile_obstack,\n+\t\t\t\t  name, gnat_encoding_suffix - name);\n+\t  /* Use -1 here so that SUFFIX points at the \"_\" after the\n+\t     \"XF\".  */\n+\t  gnat_encoding_suffix += strlen (GNAT_FIXED_POINT_SUFFIX) - 1;\n+\n+\t  encoding = (encoding == DW_ATE_signed\n+\t\t      ? DW_ATE_signed_fixed\n+\t\t      : DW_ATE_unsigned_fixed);\n+\t}\n+    }\n+\n   switch (encoding)\n     {\n       case DW_ATE_address:\n@@ -18766,11 +18869,11 @@ read_base_type (struct die_info *die, struct dwarf2_cu *cu)\n \tbreak;\n       case DW_ATE_signed_fixed:\n \ttype = init_fixed_point_type (objfile, bits, 0, name);\n-\tfinish_fixed_point_type (type, die, cu);\n+\tfinish_fixed_point_type (type, gnat_encoding_suffix, die, cu);\n \tbreak;\n       case DW_ATE_unsigned_fixed:\n \ttype = init_fixed_point_type (objfile, bits, 1, name);\n-\tfinish_fixed_point_type (type, die, cu);\n+\tfinish_fixed_point_type (type, gnat_encoding_suffix, die, cu);\n \tbreak;\n \n       default:"
    },
    {
      "sha": "4f7bdbfccf24634ea2b28fa2d95525f973aab00f",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=bbcdf9ab73018ff43855945fd72c642a67437d8b",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-02  Tom Tromey  <tromey@adacore.com>\n+\n+\t* gdb.ada/fixed_points.exp: Remove most special cases for minimal\n+\tencodings.\n+\n 2021-02-27  Lancelot Six  <lsix@lancelotix.com>\n \n \tPR gdb/27393"
    },
    {
      "sha": "7267c3181ed5569ff516f17a12bc33a8f53e2df5",
      "filename": "gdb/testsuite/gdb.ada/fixed_points.exp",
      "status": "modified",
      "additions": 21,
      "deletions": 64,
      "changes": 85,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/testsuite/gdb.ada/fixed_points.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bbcdf9ab73018ff43855945fd72c642a67437d8b/gdb/testsuite/gdb.ada/fixed_points.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.ada/fixed_points.exp?ref=bbcdf9ab73018ff43855945fd72c642a67437d8b",
      "patch": "@@ -49,84 +49,41 @@ foreach_with_prefix scenario {all minimal} {\n     gdb_test \"print Overprecise_Object\" \\\n \t\"= 0.13579135791\"\n \n-    gdb_test_multiple \"ptype Overprecise_Object\" \"\" {\n-\t-re \"type = <2-byte fixed point \\\\(small = 135791357913579/1000000000000000\\\\)>\\r\\n$gdb_prompt $\" {\n-\t    pass $gdb_test_name\n-\t}\n-\t-re \"type = delta 0.135791\\r\\n$gdb_prompt $\" {\n-\t    # The (legacy) output we obtain when the compiler described\n-\t    # our fixed point types using the GNAT encodings rather than\n-\t    # standard DWARF.  OK as well.\n-\t    pass $gdb_test_name\n-\t}\n-    }\n+    gdb_test \"ptype Overprecise_Object\" \\\n+\t\"type = <2-byte fixed point \\\\(small = 135791357913579/1000000000000000\\\\)>\"\n \n     # FP*_Var...\n \n     gdb_test \"print fp1_var\" \\\n \t\" = 0.25\"\n \n-    gdb_test_multiple \"ptype fp1_var\" \"\" {\n-\t-re \"type = <1-byte fixed point \\\\(small = 1/16\\\\)>\\r\\n$gdb_prompt $\" {\n-\t    pass $gdb_test_name\n-\t}\n-\t-re \"type = delta 0\\\\.1 <'small = 0\\\\.0625>\\r\\n$gdb_prompt $\" {\n-\t    # The (legacy) output we obtain when the compiler described\n-\t    # our fixed point types using the GNAT encodings rather than\n-\t    # standard DWARF.  OK as well.\n-\t    pass $gdb_test_name\n-\t}\n-    }\n+    gdb_test \"ptype fp1_var\" \"type = <1-byte fixed point \\\\(small = 1/16\\\\)>\"\n \n     gdb_test \"print fp2_var\" \\\n \t\" = -0.01\"\n \n-    gdb_test_multiple \"ptype fp2_var\" \"\" {\n-\t-re \"type = <8-byte fixed point \\\\(small = 1/100\\\\)>\\r\\n$gdb_prompt $\" {\n-\t    pass $gdb_test_name\n-\t}\n-\t-re \"type = delta 0\\\\.01\\r\\n$gdb_prompt $\" {\n-\t    # The (legacy) output we obtain when the compiler described\n-\t    # our fixed point types using the GNAT encodings rather than\n-\t    # standard DWARF.  OK as well.\n-\t    pass $gdb_test_name\n-\t}\n-    }\n+    gdb_test \"ptype fp2_var\" \"type = <8-byte fixed point \\\\(small = 1/100\\\\)>\"\n \n     gdb_test \"print fp3_var\" \\\n \t\" = 0.1\"\n \n-    gdb_test_multiple \"ptype fp3_var\" \"\" {\n-\t-re \"type = <1-byte fixed point \\\\(small = 1/30\\\\)>\\r\\n$gdb_prompt $\" {\n-\t    pass $gdb_test_name\n-\t}\n-\t-re \"type = delta 0\\\\.1 <'small = 0\\\\.0333333>\\r\\n$gdb_prompt $\" {\n-\t    # The (legacy) output we obtain when the compiler described\n-\t    # our fixed point types using the GNAT encodings rather than\n-\t    # standard DWARF.  OK as well.\n-\t    pass $gdb_test_name\n-\t}\n-    }\n+    gdb_test \"ptype fp3_var\" \"type = <1-byte fixed point \\\\(small = 1/30\\\\)>\"\n+\n+    gdb_test \"print fp2_var + 0\" \\\n+\t\" = -0.01\"\n+    gdb_test \"print 0 + fp2_var\" \\\n+\t\" = -0.01\"\n+    gdb_test \"print fp2_var - 0\" \\\n+\t\" = -0.01\"\n+\n+    set fp4 \"= 2e-07\"\n+    gdb_test \"print fp4_var\" $fp4\n+    gdb_test \"print fp4_var * 1\" $fp4\n+    gdb_test \"print 1 * fp4_var\" $fp4\n+    gdb_test \"print fp4_var / 1\" $fp4\n \n-    # One of the benefits of minimal encoding is that operations work\n-    # a bit better.\n-    if {$scenario == \"minimal\"} {\n-\tgdb_test \"print fp2_var + 0\" \\\n-\t    \" = -0.01\"\n-\tgdb_test \"print 0 + fp2_var\" \\\n-\t    \" = -0.01\"\n-\tgdb_test \"print fp2_var - 0\" \\\n-\t    \" = -0.01\"\n-\n-\tset fp4 \"= 2e-07\"\n-\tgdb_test \"print fp4_var\" $fp4\n-\tgdb_test \"print fp4_var * 1\" $fp4\n-\tgdb_test \"print 1 * fp4_var\" $fp4\n-\tgdb_test \"print fp4_var / 1\" $fp4\n-\n-\t# This only started working in GCC 11.\n-\tif {[test_compiler_info {gcc-11-*}]} {\n-\t    gdb_test \"print fp5_var\" \" = 3e-19\"\n-\t}\n+    # This only started working in GCC 11.\n+    if {$scenario == \"minimal\" && [test_compiler_info {gcc-11-*}]} {\n+\tgdb_test \"print fp5_var\" \" = 3e-19\"\n     }\n }"
    }
  ]
}