{
  "sha": "73cd51e51b294af9591ecc2e8a28a9bec4f466b3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NzNjZDUxZTUxYjI5NGFmOTU5MWVjYzJlOGEyOGE5YmVjNGY0NjZiMw==",
  "commit": {
    "author": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T12:54:24Z"
    },
    "committer": {
      "name": "Andre Vieira",
      "email": "andre.simoesdiasvieira@arm.com",
      "date": "2019-05-16T15:36:58Z"
    },
    "message": "[PATCH 37/57][Arm][OBJDUMP] Add framework for MVE instructions\n\nopcodes/ChangeLog:\n2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t    Michael Collison <michael.collison@arm.com>\n\n\t* arm-dis.c (enum mve_instructions): New enum.\n\t(enum mve_unpredictable): Likewise.\n\t(enum mve_undefined): Likewise.\n\t(struct mopcode32): New struct.\n\t(is_mve_okay_in_it): New function.\n\t(is_mve_architecture): Likewise.\n\t(arm_decode_field): Likewise.\n\t(arm_decode_field_multiple): Likewise.\n\t(is_mve_encoding_conflict): Likewise.\n\t(is_mve_undefined): Likewise.\n\t(is_mve_unpredictable): Likewise.\n\t(print_mve_undefined): Likewise.\n\t(print_mve_unpredictable): Likewise.\n\t(print_insn_coprocessor_1): Use arm_decode_field_multiple.\n\t(print_insn_mve): New function.\n\t(print_insn_thumb32): Handle MVE architecture.\n\t(select_arm_features): Force thumb for Armv8.1-m Mainline.",
    "tree": {
      "sha": "a2d6682e10d89691b75338d463078bee7a159e3a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a2d6682e10d89691b75338d463078bee7a159e3a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/73cd51e51b294af9591ecc2e8a28a9bec4f466b3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/73cd51e51b294af9591ecc2e8a28a9bec4f466b3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/73cd51e51b294af9591ecc2e8a28a9bec4f466b3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/73cd51e51b294af9591ecc2e8a28a9bec4f466b3/comments",
  "author": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "avieira-arm",
    "id": 68072104,
    "node_id": "MDQ6VXNlcjY4MDcyMTA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/avieira-arm",
    "html_url": "https://github.com/avieira-arm",
    "followers_url": "https://api.github.com/users/avieira-arm/followers",
    "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}",
    "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions",
    "organizations_url": "https://api.github.com/users/avieira-arm/orgs",
    "repos_url": "https://api.github.com/users/avieira-arm/repos",
    "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}",
    "received_events_url": "https://api.github.com/users/avieira-arm/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1f6234a335eab15c3ad878338b5256b5bdc190ab",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f6234a335eab15c3ad878338b5256b5bdc190ab",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1f6234a335eab15c3ad878338b5256b5bdc190ab"
    }
  ],
  "stats": {
    "total": 283,
    "additions": 279,
    "deletions": 4
  },
  "files": [
    {
      "sha": "ad73bdf8df7bc30adf5e40d6375c50583612ac2a",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 21,
      "deletions": 0,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/73cd51e51b294af9591ecc2e8a28a9bec4f466b3/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/73cd51e51b294af9591ecc2e8a28a9bec4f466b3/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=73cd51e51b294af9591ecc2e8a28a9bec4f466b3",
      "patch": "@@ -1,3 +1,24 @@\n+2019-05-16  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Michael Collison <michael.collison@arm.com>\n+\n+\t* arm-dis.c (enum mve_instructions): New enum.\n+\t(enum mve_unpredictable): Likewise.\n+\t(enum mve_undefined): Likewise.\n+\t(struct mopcode32): New struct.\n+\t(is_mve_okay_in_it): New function.\n+\t(is_mve_architecture): Likewise.\n+\t(arm_decode_field): Likewise.\n+\t(arm_decode_field_multiple): Likewise.\n+\t(is_mve_encoding_conflict): Likewise.\n+\t(is_mve_undefined): Likewise.\n+\t(is_mve_unpredictable): Likewise.\n+\t(print_mve_undefined): Likewise.\n+\t(print_mve_unpredictable): Likewise.\n+\t(print_insn_coprocessor_1): Use arm_decode_field_multiple.\n+\t(print_insn_mve): New function.\n+\t(print_insn_thumb32): Handle MVE architecture.\n+\t(select_arm_features): Force thumb for Armv8.1-m Mainline.\n+\n 2019-05-10  Nick Clifton  <nickc@redhat.com>\n \n \tPR 24538"
    },
    {
      "sha": "615f34ffca5904a000b88ebde0fd28f7970455a8",
      "filename": "opcodes/arm-dis.c",
      "status": "modified",
      "additions": 258,
      "deletions": 4,
      "changes": 262,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/73cd51e51b294af9591ecc2e8a28a9bec4f466b3/opcodes/arm-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/73cd51e51b294af9591ecc2e8a28a9bec4f466b3/opcodes/arm-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/arm-dis.c?ref=73cd51e51b294af9591ecc2e8a28a9bec4f466b3",
      "patch": "@@ -67,6 +67,23 @@ struct arm_private_data\n   bfd_vma last_mapping_addr;\n };\n \n+enum mve_instructions\n+{\n+  MVE_NONE\n+};\n+\n+enum mve_unpredictable\n+{\n+  UNPRED_IT_BLOCK,\t\t/* Unpredictable because mve insn in it block.\n+\t\t\t\t */\n+  UNPRED_NONE\t\t\t/* No unpredictable behavior.  */\n+};\n+\n+enum mve_undefined\n+{\n+  UNDEF_NONE\t\t\t/* no undefined behavior.  */\n+};\n+\n struct opcode32\n {\n   arm_feature_set arch;\t\t/* Architecture defining this insn.  */\n@@ -75,6 +92,18 @@ struct opcode32\n   const char *  assembler;\t/* How to disassemble this insn.  */\n };\n \n+/* MVE opcodes.  */\n+\n+struct mopcode32\n+{\n+  arm_feature_set arch;\t\t/* Architecture defining this insn.  */\n+  enum mve_instructions mve_op;  /* Specific mve instruction for faster\n+\t\t\t\t    decoding.  */\n+  unsigned long value;\t\t/* If arch is 0 then value is a sentinel.  */\n+  unsigned long mask;\t\t/* Recognise insn if (op & mask) == value.  */\n+  const char *  assembler;\t/* How to disassemble this insn.  */\n+};\n+\n enum isa {\n   ANY,\n   T32,\n@@ -1746,6 +1775,18 @@ static const struct opcode32 neon_opcodes[] =\n   {ARM_FEATURE_CORE_LOW (0), 0 ,0, 0}\n };\n \n+/* mve opcode table.  */\n+\n+/* print_insn_mve recognizes the following format control codes:\n+\n+   %%\t\t\t%\n+\n+   */\n+\n+static const struct mopcode32 mve_opcodes[] =\n+{\n+};\n+\n /* Opcode tables: ARM, 16-bit Thumb, 32-bit Thumb.  All three are partially\n    ordered: they must be searched linearly from the top to obtain a correct\n    match.  */\n@@ -3439,6 +3480,105 @@ arm_decode_shift (long given, fprintf_ftype func, void *stream,\n     }\n }\n \n+/* Return TRUE if the MATCHED_INSN can be inside an IT block.  */\n+\n+static bfd_boolean\n+is_mve_okay_in_it (enum mve_instructions matched_insn)\n+{\n+  return FALSE;\n+}\n+\n+static bfd_boolean\n+is_mve_architecture (struct disassemble_info *info)\n+{\n+  struct arm_private_data *private_data = info->private_data;\n+  arm_feature_set allowed_arches = private_data->features;\n+\n+  arm_feature_set arm_ext_v8_1m_main\n+    = ARM_FEATURE_CORE_HIGH (ARM_EXT2_V8_1M_MAIN);\n+\n+  if (ARM_CPU_HAS_FEATURE (arm_ext_v8_1m_main, allowed_arches)\n+      && !ARM_CPU_IS_ANY (allowed_arches))\n+    return TRUE;\n+  else\n+    return FALSE;\n+}\n+\n+/* Decode a bitfield from opcode GIVEN, with starting bitfield = START\n+   and ending bitfield = END.  END must be greater than START.  */\n+\n+static unsigned long\n+arm_decode_field (unsigned long given, unsigned int start, unsigned int end)\n+{\n+  int bits = end - start;\n+\n+  if (bits < 0)\n+    abort ();\n+\n+  return ((given >> start) & ((2ul << bits) - 1));\n+}\n+\n+/* Decode a bitfield from opcode GIVEN, with multiple bitfields:\n+   START:END and START2:END2.  END/END2 must be greater than\n+   START/START2.  */\n+\n+static unsigned long\n+arm_decode_field_multiple (unsigned long given, unsigned int start,\n+\t\t\t   unsigned int end, unsigned int start2,\n+\t\t\t   unsigned int end2)\n+{\n+  int bits = end - start;\n+  int bits2 = end2 - start2;\n+  unsigned long value = 0;\n+  int width = 0;\n+\n+  if (bits2 < 0)\n+    abort ();\n+\n+  value = arm_decode_field (given, start, end);\n+  width += bits + 1;\n+\n+  value |= ((given >> start2) & ((2ul << bits2) - 1)) << width;\n+  return value;\n+}\n+\n+/* Return TRUE if the GIVEN encoding should not be decoded as MATCHED_INSN.\n+   This helps us decode instructions that change mnemonic depending on specific\n+   operand values/encodings.  */\n+\n+static bfd_boolean\n+is_mve_encoding_conflict (unsigned long given,\n+\t\t\t  enum mve_instructions matched_insn)\n+{\n+  return FALSE;\n+}\n+\n+/* Return FALSE if GIVEN is not an undefined encoding for MATCHED_INSN.\n+   Otherwise, return TRUE and set UNDEFINED_CODE to give a reason as to why\n+   this encoding is undefined.  */\n+\n+static bfd_boolean\n+is_mve_undefined (unsigned long given, enum mve_instructions matched_insn,\n+\t\t  enum mve_undefined *undefined_code)\n+{\n+  *undefined_code = UNDEF_NONE;\n+\n+  return FALSE;\n+}\n+\n+/* Return FALSE if GIVEN is not an unpredictable encoding for MATCHED_INSN.\n+   Otherwise, return TRUE and set UNPREDICTABLE_CODE to give a reason as to\n+   why this encoding is unpredictable.  */\n+\n+static bfd_boolean\n+is_mve_unpredictable (unsigned long given, enum mve_instructions matched_insn,\n+\t\t      enum mve_unpredictable *unpredictable_code)\n+{\n+  *unpredictable_code = UNPRED_NONE;\n+\n+  return FALSE;\n+}\n+\n #define W_BIT 21\n #define I_BIT 22\n #define U_BIT 23\n@@ -3449,6 +3589,43 @@ arm_decode_shift (long given, fprintf_ftype func, void *stream,\n #define NEGATIVE_BIT_SET   ((given & (1 << U_BIT)) == 0)\n #define PRE_BIT_SET         (given & (1 << P_BIT))\n \n+static void\n+print_mve_undefined (struct disassemble_info *info,\n+\t\t     enum mve_undefined undefined_code)\n+{\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+\n+  func (stream, \"\\t\\tundefined instruction: \");\n+\n+  switch (undefined_code)\n+    {\n+    case UNDEF_NONE:\n+      break;\n+    }\n+\n+}\n+\n+static void\n+print_mve_unpredictable (struct disassemble_info *info,\n+\t\t\t enum mve_unpredictable unpredict_code)\n+{\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+\n+  func (stream, \"%s: \", UNPREDICTABLE_INSTRUCTION);\n+\n+  switch (unpredict_code)\n+    {\n+    case UNPRED_IT_BLOCK:\n+      func (stream, \"mve instruction in it block\");\n+      break;\n+\n+    case UNPRED_NONE:\n+      break;\n+    }\n+}\n+\n /* Print one coprocessor instruction on INFO->STREAM.\n    Return TRUE if the instuction matched, FALSE if this is not a\n    recognised coprocessor instruction.  */\n@@ -3726,7 +3903,8 @@ print_insn_coprocessor (bfd_vma pc,\n \n \t\tcase 'J':\n \t\t  {\n-\t\t    int regno = ((given >> 19) & 0x8) | ((given >> 13) & 0x7);\n+\t\t    unsigned long regno\n+\t\t      = arm_decode_field_multiple (given, 13, 15, 22, 22);\n \n \t\t    switch (regno)\n \t\t      {\n@@ -3749,7 +3927,7 @@ print_insn_coprocessor (bfd_vma pc,\n \t\t\tfunc (stream, \"FPCXTS\");\n \t\t\tbreak;\n \t\t      default:\n-\t\t\tfunc (stream, \"<invalid reg %d>\", regno);\n+\t\t\tfunc (stream, \"<invalid reg %lu>\", regno);\n \t\t\tbreak;\n \t\t      }\n \t\t  }\n@@ -4743,6 +4921,75 @@ print_insn_neon (struct disassemble_info *info, long given, bfd_boolean thumb)\n   return FALSE;\n }\n \n+/* Print one mve instruction on INFO->STREAM.\n+   Return TRUE if the instuction matched, FALSE if this is not a\n+   recognised mve instruction.  */\n+\n+static bfd_boolean\n+print_insn_mve (struct disassemble_info *info, long given)\n+{\n+  const struct mopcode32 *insn;\n+  void *stream = info->stream;\n+  fprintf_ftype func = info->fprintf_func;\n+\n+  for (insn = mve_opcodes; insn->assembler; insn++)\n+    {\n+      if (((given & insn->mask) == insn->value)\n+\t  && !is_mve_encoding_conflict (given, insn->mve_op))\n+\t{\n+\t  signed long value_in_comment = 0;\n+\t  bfd_boolean is_unpredictable = FALSE;\n+\t  bfd_boolean is_undefined = FALSE;\n+\t  const char *c;\n+\t  enum mve_unpredictable unpredictable_cond = UNPRED_NONE;\n+\t  enum mve_undefined undefined_cond = UNDEF_NONE;\n+\n+\t  /* Most vector mve instruction are illegal in a it block.\n+\t     There are a few exceptions; check for them.  */\n+\t  if (ifthen_state && !is_mve_okay_in_it (insn->mve_op))\n+\t    {\n+\t      is_unpredictable = TRUE;\n+\t      unpredictable_cond = UNPRED_IT_BLOCK;\n+\t    }\n+\t  else if (is_mve_unpredictable (given, insn->mve_op,\n+\t\t\t\t\t &unpredictable_cond))\n+\t    is_unpredictable = TRUE;\n+\n+\t  if (is_mve_undefined (given, insn->mve_op, &undefined_cond))\n+\t    is_undefined = TRUE;\n+\n+\t  for (c = insn->assembler; *c; c++)\n+\t    {\n+\t      if (*c == '%')\n+\t\t{\n+\t\t  switch (*++c)\n+\t\t    {\n+\t\t    case '%':\n+\t\t      func (stream, \"%%\");\n+\t\t      break;\n+\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tfunc (stream, \"%c\", *c);\n+\t    }\n+\n+\t  if (value_in_comment > 32 || value_in_comment < -16)\n+\t    func (stream, \"\\t; 0x%lx\", value_in_comment);\n+\n+\t  if (is_unpredictable)\n+\t    print_mve_unpredictable (info, unpredictable_cond);\n+\n+\t  if (is_undefined)\n+\t    print_mve_undefined (info, undefined_cond);\n+\n+\t  return TRUE;\n+\t}\n+    }\n+  return FALSE;\n+}\n+\n+\n /* Return the name of a v7A special register.  */\n \n static const char *\n@@ -5653,11 +5900,15 @@ print_insn_thumb32 (bfd_vma pc, struct disassemble_info *info, long given)\n   const struct opcode32 *insn;\n   void *stream = info->stream;\n   fprintf_ftype func = info->fprintf_func;\n+  bfd_boolean is_mve = is_mve_architecture (info);\n \n   if (print_insn_coprocessor (pc, info, given, TRUE))\n     return;\n \n-  if (print_insn_neon (info, given, TRUE))\n+  if ((is_mve == FALSE) && print_insn_neon (info, given, TRUE))\n+    return;\n+\n+  if (is_mve && print_insn_mve (info, given))\n     return;\n \n   for (insn = thumb32_opcodes; insn->assembler; insn++)\n@@ -6764,7 +7015,10 @@ select_arm_features (unsigned long mach,\n     case bfd_mach_arm_8R:\t ARM_SET_FEATURES (ARM_ARCH_V8R); break;\n     case bfd_mach_arm_8M_BASE:\t ARM_SET_FEATURES (ARM_ARCH_V8M_BASE); break;\n     case bfd_mach_arm_8M_MAIN:\t ARM_SET_FEATURES (ARM_ARCH_V8M_MAIN); break;\n-    case bfd_mach_arm_8_1M_MAIN: ARM_SET_FEATURES (ARM_ARCH_V8_1M_MAIN); break;\n+    case bfd_mach_arm_8_1M_MAIN:\n+      ARM_SET_FEATURES (ARM_ARCH_V8_1M_MAIN);\n+      force_thumb = 1;\n+      break;\n       /* If the machine type is unknown allow all architecture types and all\n \t extensions.  */\n     case bfd_mach_arm_unknown:\t ARM_SET_FEATURES (ARM_FEATURE_ALL); break;"
    }
  ]
}