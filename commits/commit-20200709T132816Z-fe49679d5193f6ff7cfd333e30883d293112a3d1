{
  "sha": "fe49679d5193f6ff7cfd333e30883d293112a3d1",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmU0OTY3OWQ1MTkzZjZmZjdjZmQzMzNlMzA4ODNkMjkzMTEyYTNkMQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-07-08T11:51:32Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-07-09T13:28:16Z"
    },
    "message": "Remove powerpc PE support\n\nPlus some leftover powerpc lynxos support.\n\nbfd/\n\t* coff-ppc.c: Delete.\n\t* pe-ppc.c: Delete.\n\t* pei-ppc.c: Delete.\n\t* Makefile.am (BFD32_BACKENDS, BFD32_BACKENDS_CFILES): Remove PE PPC.\n\t* coffcode.h (coff_set_arch_mach_hook, coff_set_flags): Remove\n\tPPCMAGIC code.\n\t(coff_write_object_contents): Remove PPC_PE code.\n\t* config.bfd: Move powerpcle-pe to removed targets.\n\t* configure.ac: Remove powerpc PE entries.\n\t* libcoff-in.h (ppc_allocate_toc_section): Delete.\n\t(ppc_process_before_allocation): Delete.\n\t* peXXigen.c: Remove POWERPC_LE_PE code and comments.\n\t* targets.c: Remove powerpc PE vectors.\n\t* po/SRC-POTFILES.in: Regenerate.\n\t* libcoff.h: Regenerate.\n\t* Makefile.in: Regenerate.\n\t* configure: Regenerate.\nbinutils/\n\t* dlltool.c: Remove powerpc PE support and comments.\n\t* configure.ac: Remove powerpc PE dlltool config.\n\t* configure: Regenerate.\ngas/\n\t* config/obj-coff.h: Remove TE_PE support.\n\t* config/tc-ppc.c: Likewise.\n\t* config/tc-ppc.h: Likewise.\n\t* configure.tgt: Remove powerpc PE and powerpc lynxos.\n\t* testsuite/gas/cfi/cfi.exp (cfi-common-6): Remove powerpc PE\n\tcondition.\n\t* testsuite/gas/macros/macros.exp: Don't xfail powerpc PE.\ninclude/\n\t* coff/powerpc.h: Delete.\nld/\n\t* emulparams/ppcpe.sh: Delete.\n\t* scripttempl/ppcpe.sc: Delete.\n\t* emulparams/ppclynx.sh: Delete.\n\t* Makefile.am (ALL_EMULATION_SOURCES): Remove ppc PE and lynxos.\n\t* configure.tgt: Likewise.\n\t* emultempl/beos.em: Remove powerpc PE support.\n\t* emultempl/pe.em: Likewise.\n\t* po/BLD-POTFILES.in: Regenerate.\n\t* Makefile.in: Regenerate.",
    "tree": {
      "sha": "d3e22fb7645b021227855dbde32c85a9b6fe0a0b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d3e22fb7645b021227855dbde32c85a9b6fe0a0b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/fe49679d5193f6ff7cfd333e30883d293112a3d1",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fe49679d5193f6ff7cfd333e30883d293112a3d1",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/fe49679d5193f6ff7cfd333e30883d293112a3d1",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fe49679d5193f6ff7cfd333e30883d293112a3d1/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c560184eb2074570988c498aaae494d0c4b00328",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c560184eb2074570988c498aaae494d0c4b00328",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c560184eb2074570988c498aaae494d0c4b00328"
    }
  ],
  "stats": {
    "total": 4517,
    "additions": 96,
    "deletions": 4421
  },
  "files": [
    {
      "sha": "afbccc3fa50ef4bb7271a7e0ec255dfbb43b9964",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -1,3 +1,23 @@\n+2020-07-09  Alan Modra  <amodra@gmail.com>\n+\n+\t* coff-ppc.c: Delete.\n+\t* pe-ppc.c: Delete.\n+\t* pei-ppc.c: Delete.\n+\t* Makefile.am (BFD32_BACKENDS, BFD32_BACKENDS_CFILES): Remove PE PPC.\n+\t* coffcode.h (coff_set_arch_mach_hook, coff_set_flags): Remove\n+\tPPCMAGIC code.\n+\t(coff_write_object_contents): Remove PPC_PE code.\n+\t* config.bfd: Move powerpcle-pe to removed targets.\n+\t* configure.ac: Remove powerpc PE entries.\n+\t* libcoff-in.h (ppc_allocate_toc_section): Delete.\n+\t(ppc_process_before_allocation): Delete.\n+\t* peXXigen.c: Remove POWERPC_LE_PE code and comments.\n+\t* targets.c: Remove powerpc PE vectors.\n+\t* po/SRC-POTFILES.in: Regenerate.\n+\t* libcoff.h: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Regenerate.\n+\n 2020-07-09  Nick Clifton  <nickc@redhat.com>\n \n \t* po/fr.po: Updated French translation."
    },
    {
      "sha": "f48a8e708e9a861c241a968e49f1de7c01f6482a",
      "filename": "bfd/Makefile.am",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/Makefile.am?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -370,14 +370,12 @@ BFD32_BACKENDS = \\\n \tpe-arm.lo \\\n \tpe-i386.lo \\\n \tpe-mcore.lo \\\n-\tpe-ppc.lo \\\n \tpe-sh.lo \\\n \tpef.lo \\\n \tpei-arm-wince.lo \\\n \tpei-arm.lo \\\n \tpei-i386.lo \\\n \tpei-mcore.lo \\\n-\tpei-ppc.lo \\\n \tpei-sh.lo \\\n \tpeigen.lo \\\n \tplugin.lo \\\n@@ -505,14 +503,12 @@ BFD32_BACKENDS_CFILES = \\\n \tpe-arm.c \\\n \tpe-i386.c \\\n \tpe-mcore.c \\\n-\tpe-ppc.c \\\n \tpe-sh.c \\\n \tpef.c \\\n \tpei-arm-wince.c \\\n \tpei-arm.c \\\n \tpei-i386.c \\\n \tpei-mcore.c \\\n-\tpei-ppc.c \\\n \tpei-sh.c \\\n \tplugin.c \\\n \tppcboot.c \\"
    },
    {
      "sha": "e2dce2501ee3472e59c012066514a2e740949fd8",
      "filename": "bfd/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/Makefile.in?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -795,14 +795,12 @@ BFD32_BACKENDS = \\\n \tpe-arm.lo \\\n \tpe-i386.lo \\\n \tpe-mcore.lo \\\n-\tpe-ppc.lo \\\n \tpe-sh.lo \\\n \tpef.lo \\\n \tpei-arm-wince.lo \\\n \tpei-arm.lo \\\n \tpei-i386.lo \\\n \tpei-mcore.lo \\\n-\tpei-ppc.lo \\\n \tpei-sh.lo \\\n \tpeigen.lo \\\n \tplugin.lo \\\n@@ -930,14 +928,12 @@ BFD32_BACKENDS_CFILES = \\\n \tpe-arm.c \\\n \tpe-i386.c \\\n \tpe-mcore.c \\\n-\tpe-ppc.c \\\n \tpe-sh.c \\\n \tpef.c \\\n \tpei-arm-wince.c \\\n \tpei-arm.c \\\n \tpei-i386.c \\\n \tpei-mcore.c \\\n-\tpei-ppc.c \\\n \tpei-sh.c \\\n \tplugin.c \\\n \tppcboot.c \\\n@@ -1544,7 +1540,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-arm.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-i386.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-mcore.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-ppc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-sh.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pe-x86_64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pef.Plo@am__quote@\n@@ -1553,7 +1548,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pei-i386.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pei-ia64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pei-mcore.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pei-ppc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pei-sh.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pei-x86_64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/peigen.Plo@am__quote@"
    },
    {
      "sha": "a3ad1ef8e6ce877b4c7d9bb189a5ec67475ab203",
      "filename": "bfd/coff-ppc.c",
      "status": "removed",
      "additions": 0,
      "deletions": 2582,
      "changes": 2582,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c560184eb2074570988c498aaae494d0c4b00328/bfd/coff-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c560184eb2074570988c498aaae494d0c4b00328/bfd/coff-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-ppc.c?ref=c560184eb2074570988c498aaae494d0c4b00328",
      "patch": "@@ -1,2582 +0,0 @@\n-/* BFD back-end for PowerPC Microsoft Portable Executable files.\n-   Copyright (C) 1990-2020 Free Software Foundation, Inc.\n-\n-   Original version pieced together by Kim Knuttila (krk@cygnus.com)\n-\n-   There is nothing new under the sun. This file draws a lot on other\n-   coff files, in particular, those for the rs/6000, alpha, mips, and\n-   intel backends, and the PE work for the arm.\n-\n-   This file is part of BFD, the Binary File Descriptor library.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, 51 Franklin Street - Fifth Floor,\n-   Boston, MA 02110-1301, USA.  */\n-\n-/* Current State:\n-   - objdump works\n-   - relocs generated by gas\n-   - ld will link files, but they do not run.\n-   - dlltool will not produce correct output in some .reloc cases, and will\n-     not produce the right glue code for dll function calls.  */\n-\n-#include \"sysdep.h\"\n-#include \"bfd.h\"\n-#include \"libbfd.h\"\n-\n-#include \"coff/powerpc.h\"\n-#include \"coff/internal.h\"\n-\n-#include \"coff/pe.h\"\n-\n-#ifdef BADMAG\n-#undef BADMAG\n-#endif\n-\n-#define BADMAG(x) PPCBADMAG(x)\n-\n-#include \"libcoff.h\"\n-\n-/* This file is compiled more than once, but we only compile the\n-   final_link routine once.  */\n-extern bfd_boolean ppc_bfd_coff_final_link (bfd *, struct bfd_link_info *);\n-extern void dump_toc (void *);\n-\n-/* The toc is a set of bfd_vma fields. We use the fact that valid\n-   addresses are even (i.e. the bit representing \"1\" is off) to allow\n-   us to encode a little extra information in the field\n-   - Unallocated addresses are initialized to 1.\n-   - Allocated addresses are even numbers.\n-   The first time we actually write a reference to the toc in the bfd,\n-   we want to record that fact in a fixup file (if it is asked for), so\n-   we keep track of whether or not an address has been written by marking\n-   the low order bit with a \"1\" upon writing.  */\n-\n-#define SET_UNALLOCATED(x)  ((x) = 1)\n-#define IS_UNALLOCATED(x)   ((x) == 1)\n-\n-#define IS_WRITTEN(x)       ((x) & 1)\n-#define MARK_AS_WRITTEN(x)  ((x) |= 1)\n-#define MAKE_ADDR_AGAIN(x)  ((x) &= ~1)\n-\n-/* Turn on this check if you suspect something amiss in the hash tables.  */\n-#ifdef DEBUG_HASH\n-\n-/* Need a 7 char string for an eye catcher.  */\n-#define EYE \"krkjunk\"\n-\n-#define HASH_CHECK_DCL char eye_catcher[8];\n-#define HASH_CHECK_INIT(ret)      strcpy(ret->eye_catcher, EYE)\n-#define HASH_CHECK(addr) \\\n- if (strcmp (addr->eye_catcher, EYE) != 0) \\\n-  { \\\n-    fprintf (stderr,\\\n-    /* xgettext: c-format */ \\\n-    _(\"File %s, line %d, Hash check failure, bad eye %8s\\n\"), \\\n-    __FILE__, __LINE__, addr->eye_catcher); \\\n-    abort (); \\\n- }\n-\n-#else\n-\n-#define HASH_CHECK_DCL\n-#define HASH_CHECK_INIT(ret)\n-#define HASH_CHECK(addr)\n-\n-#endif\n-\n-/* In order not to add an int to every hash table item for every coff\n-   linker, we define our own hash table, derived from the coff one.  */\n-\n-/* PE linker hash table entries.  */\n-\n-struct ppc_coff_link_hash_entry\n-{\n-  struct coff_link_hash_entry root; /* First entry, as required.  */\n-\n-  /* As we wonder around the relocs, we'll keep the assigned toc_offset\n-     here.  */\n-  bfd_vma toc_offset;\t\t    /* Our addition, as required.  */\n-  int symbol_is_glue;\n-  unsigned long int glue_insn;\n-\n-  HASH_CHECK_DCL\n-};\n-\n-/* PE linker hash table.  */\n-\n-struct ppc_coff_link_hash_table\n-{\n-  struct coff_link_hash_table root; /* First entry, as required.  */\n-};\n-\n-/* Routine to create an entry in the link hash table.  */\n-\n-static struct bfd_hash_entry *\n-ppc_coff_link_hash_newfunc (struct bfd_hash_entry * entry,\n-\t\t\t    struct bfd_hash_table * table,\n-\t\t\t    const char * string)\n-{\n-  struct ppc_coff_link_hash_entry *ret =\n-    (struct ppc_coff_link_hash_entry *) entry;\n-\n-  /* Allocate the structure if it has not already been allocated by a\n-     subclass.  */\n-  if (ret == (struct ppc_coff_link_hash_entry *) NULL)\n-    ret = (struct ppc_coff_link_hash_entry *)\n-      bfd_hash_allocate (table,\n-\t\t\t sizeof (struct ppc_coff_link_hash_entry));\n-\n-  if (ret == (struct ppc_coff_link_hash_entry *) NULL)\n-    return NULL;\n-\n-  /* Call the allocation method of the superclass.  */\n-  ret = ((struct ppc_coff_link_hash_entry *)\n-\t _bfd_coff_link_hash_newfunc ((struct bfd_hash_entry *) ret,\n-\t\t\t\t      table, string));\n-\n-  if (ret)\n-    {\n-      /* Initialize the local fields.  */\n-      SET_UNALLOCATED (ret->toc_offset);\n-      ret->symbol_is_glue = 0;\n-      ret->glue_insn = 0;\n-\n-      HASH_CHECK_INIT (ret);\n-    }\n-\n-  return (struct bfd_hash_entry *) ret;\n-}\n-\n-/* Initialize a PE linker hash table.  */\n-\n-static bfd_boolean\n-ppc_coff_link_hash_table_init (struct ppc_coff_link_hash_table *table,\n-\t\t\t       bfd *abfd,\n-\t\t\t       struct bfd_hash_entry *(*newfunc)\n-\t\t\t\t (struct bfd_hash_entry *,\n-\t\t\t\t  struct bfd_hash_table *,\n-\t\t\t\t  const char *),\n-\t\t\t       unsigned int entsize)\n-{\n-  return _bfd_coff_link_hash_table_init (&table->root, abfd, newfunc, entsize);\n-}\n-\n-/* Create a PE linker hash table.  */\n-\n-static struct bfd_link_hash_table *\n-ppc_coff_link_hash_table_create (bfd *abfd)\n-{\n-  struct ppc_coff_link_hash_table *ret;\n-  size_t amt = sizeof (struct ppc_coff_link_hash_table);\n-\n-  ret = (struct ppc_coff_link_hash_table *) bfd_malloc (amt);\n-  if (ret == NULL)\n-    return NULL;\n-  if (!ppc_coff_link_hash_table_init (ret, abfd,\n-\t\t\t\t      ppc_coff_link_hash_newfunc,\n-\t\t\t\t      sizeof (struct ppc_coff_link_hash_entry)))\n-    {\n-      free (ret);\n-      return (struct bfd_link_hash_table *) NULL;\n-    }\n-  return &ret->root.root;\n-}\n-\n-/* Now, tailor coffcode.h to use our hash stuff.  */\n-\n-#define coff_bfd_link_hash_table_create ppc_coff_link_hash_table_create\n-\f\n-/* The nt loader points the toc register to &toc + 32768, in order to\n-   use the complete range of a 16-bit displacement. We have to adjust\n-   for this when we fix up loads displaced off the toc reg.  */\n-#define TOC_LOAD_ADJUSTMENT (-32768)\n-#define TOC_SECTION_NAME \".private.toc\"\n-\n-/* The main body of code is in coffcode.h.  */\n-\n-#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)\n-\n-/* In case we're on a 32-bit machine, construct a 64-bit \"-1\" value\n-   from smaller values.  Start with zero, widen, *then* decrement.  */\n-#define MINUS_ONE\t(((bfd_vma)0) - 1)\n-\n-/* These should definitely go in a header file somewhere...  */\n-\n-/* NOP */\n-#define IMAGE_REL_PPC_ABSOLUTE\t\t0x0000\n-\n-/* 64-bit address */\n-#define IMAGE_REL_PPC_ADDR64\t\t0x0001\n-\n-/* 32-bit address */\n-#define IMAGE_REL_PPC_ADDR32\t\t0x0002\n-\n-/* 26-bit address, shifted left 2 (branch absolute) */\n-#define IMAGE_REL_PPC_ADDR24\t\t0x0003\n-\n-/* 16-bit address */\n-#define IMAGE_REL_PPC_ADDR16\t\t0x0004\n-\n-/* 16-bit address, shifted left 2 (load doubleword) */\n-#define IMAGE_REL_PPC_ADDR14\t\t0x0005\n-\n-/* 26-bit PC-relative offset, shifted left 2 (branch relative) */\n-#define IMAGE_REL_PPC_REL24\t\t0x0006\n-\n-/* 16-bit PC-relative offset, shifted left 2 (br cond relative) */\n-#define IMAGE_REL_PPC_REL14\t\t0x0007\n-\n-/* 16-bit offset from TOC base */\n-#define IMAGE_REL_PPC_TOCREL16\t\t0x0008\n-\n-/* 16-bit offset from TOC base, shifted left 2 (load doubleword) */\n-#define IMAGE_REL_PPC_TOCREL14\t\t0x0009\n-\n-/* 32-bit addr w/o image base */\n-#define IMAGE_REL_PPC_ADDR32NB\t\t0x000A\n-\n-/* va of containing section (as in an image sectionhdr) */\n-#define IMAGE_REL_PPC_SECREL\t\t0x000B\n-\n-/* sectionheader number */\n-#define IMAGE_REL_PPC_SECTION\t\t0x000C\n-\n-/* substitute TOC restore instruction iff symbol is glue code */\n-#define IMAGE_REL_PPC_IFGLUE\t\t0x000D\n-\n-/* symbol is glue code; virtual address is TOC restore instruction */\n-#define IMAGE_REL_PPC_IMGLUE\t\t0x000E\n-\n-/* va of containing section (limited to 16 bits) */\n-#define IMAGE_REL_PPC_SECREL16\t\t0x000F\n-\n-/* Stuff to handle immediate data when the number of bits in the\n-   data is greater than the number of bits in the immediate field\n-   We need to do (usually) 32 bit arithmetic on 16 bit chunks.  */\n-#define IMAGE_REL_PPC_REFHI\t\t0x0010\n-#define IMAGE_REL_PPC_REFLO\t\t0x0011\n-#define IMAGE_REL_PPC_PAIR\t\t0x0012\n-\n-/* This is essentially the same as tocrel16, with TOCDEFN assumed.  */\n-#define IMAGE_REL_PPC_TOCREL16_DEFN\t0x0013\n-\n-/* Flag bits in IMAGE_RELOCATION.TYPE.  */\n-\n-/* Subtract reloc value rather than adding it.  */\n-#define IMAGE_REL_PPC_NEG\t\t0x0100\n-\n-/* Fix branch prediction bit to predict branch taken.  */\n-#define IMAGE_REL_PPC_BRTAKEN\t\t0x0200\n-\n-/* Fix branch prediction bit to predict branch not taken.  */\n-#define IMAGE_REL_PPC_BRNTAKEN\t\t0x0400\n-\n-/* TOC slot defined in file (or, data in toc).  */\n-#define IMAGE_REL_PPC_TOCDEFN\t\t0x0800\n-\n-/* Masks to isolate above values in IMAGE_RELOCATION.Type.  */\n-#define IMAGE_REL_PPC_TYPEMASK\t\t0x00FF\n-#define IMAGE_REL_PPC_FLAGMASK\t\t0x0F00\n-\n-#define EXTRACT_TYPE(x)\t\t\t((x) & IMAGE_REL_PPC_TYPEMASK)\n-#define EXTRACT_FLAGS(x) ((x) & IMAGE_REL_PPC_FLAGMASK)\n-#define EXTRACT_JUNK(x)\t \\\n-\t   ((x) & ~(IMAGE_REL_PPC_TYPEMASK | IMAGE_REL_PPC_FLAGMASK))\n-\f\n-/* Static helper functions to make relocation work.  */\n-/* (Work In Progress) */\n-\n-static bfd_reloc_status_type ppc_refhi_reloc\n-  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n-static bfd_reloc_status_type ppc_pair_reloc\n-  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n-static bfd_reloc_status_type ppc_toc16_reloc\n-  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n-static bfd_reloc_status_type ppc_section_reloc\n-  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n-static bfd_reloc_status_type ppc_secrel_reloc\n-  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n-static bfd_reloc_status_type ppc_imglue_reloc\n-  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n-\n-/* FIXME: It'll take a while to get through all of these. I only need a few to\n-   get us started, so those I'll make sure work. Those marked FIXME are either\n-   completely unverified or have a specific unknown marked in the comment.  */\n-\n-/* Relocation entries for Windows/NT on PowerPC.\n-\n-   From the document \"\" we find the following listed as used relocs:\n-\n-     ABSOLUTE\t    : The noop\n-     ADDR[64|32|16] : fields that hold addresses in data fields or the\n-\t\t      16 bit displacement field on a load/store.\n-     ADDR[24|14]    : fields that hold addresses in branch and cond\n-\t\t      branches. These represent [26|16] bit addresses.\n-\t\t      The low order 2 bits are preserved.\n-     REL[24|14]\t    : branches relative to the Instruction Address\n-\t\t      register. These represent [26|16] bit addresses,\n-\t\t      as before. The instruction field will be zero, and\n-\t\t      the address of the SYM will be inserted at link time.\n-     TOCREL16\t    : 16 bit displacement field referring to a slot in\n-\t\t      toc.\n-     TOCREL14\t    : 16 bit displacement field, similar to REL14 or ADDR14.\n-     ADDR32NB\t    : 32 bit address relative to the virtual origin.\n-\t\t      (On the alpha, this is always a linker generated thunk)\n-\t\t      (i.e. 32bit addr relative to the image base)\n-     SECREL\t    : The value is relative to the start of the section\n-\t\t      containing the symbol.\n-     SECTION\t    : access to the header containing the item. Supports the\n-\t\t      codeview debugger.\n-\n-   In particular, note that the document does not indicate that the\n-   relocations listed in the header file are used.  */\n-\n-\n-static reloc_howto_type ppc_coff_howto_table[] =\n-{\n-  /* IMAGE_REL_PPC_ABSOLUTE 0x0000   NOP */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_ABSOLUTE, /* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 0,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_dont, /* dont complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"ABSOLUTE\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n-\t 0x00,\t\t\t/* src_mask */\n-\t 0x00,\t\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_ADDR64 0x0001  64-bit address */\n-  /* Unused: */\n-  HOWTO(IMAGE_REL_PPC_ADDR64,\t/* type */\n-\t0,\t\t\t/* rightshift */\n-\t3,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t64,\t\t\t/* bitsize */\n-\tFALSE,\t\t\t/* pc_relative */\n-\t0,\t\t\t/* bitpos */\n-\tcomplain_overflow_bitfield, /* complain_on_overflow */\n-\t0,\t\t\t/* special_function */\n-\t\"ADDR64\",\t\t/* name */\n-\tTRUE,\t\t\t/* partial_inplace */\n-\tMINUS_ONE,\t\t/* src_mask */\n-\tMINUS_ONE,\t\t/* dst_mask */\n-\tFALSE),\t\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_ADDR32 0x0002  32-bit address */\n-  /* Used: */\n-  HOWTO (IMAGE_REL_PPC_ADDR32,\t/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_bitfield, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"ADDR32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_ADDR24 0x0003  26-bit address, shifted left 2 (branch absolute) */\n-  /* the LI field is in bit 6 through bit 29 is 24 bits, + 2 for the shift */\n-  /* Of course, That's the IBM approved bit numbering, which is not what */\n-  /* anyone else uses.... The li field is in bit 2 thru 25 */\n-  /* Used: */\n-  HOWTO (IMAGE_REL_PPC_ADDR24,\t/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 26,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_bitfield, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"ADDR24\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0x07fffffc,\t\t/* src_mask */\n-\t 0x07fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_ADDR16 0x0004  16-bit address */\n-  /* Used: */\n-  HOWTO (IMAGE_REL_PPC_ADDR16,\t/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"ADDR16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffff,\t\t/* src_mask */\n-\t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_ADDR14 0x0005 */\n-  /*  16-bit address, shifted left 2 (load doubleword) */\n-  /* FIXME: the mask is likely wrong, and the bit position may be as well */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_ADDR14,\t/* type */\n-\t 1,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"ADDR16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffff,\t\t/* src_mask */\n-\t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_REL24 0x0006 */\n-  /*   26-bit PC-relative offset, shifted left 2 (branch relative) */\n-  /* Used: */\n-  HOWTO (IMAGE_REL_PPC_REL24,\t/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 26,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"REL24\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0x3fffffc,\t\t/* src_mask */\n-\t 0x3fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_REL14 0x0007 */\n-  /*   16-bit PC-relative offset, shifted left 2 (br cond relative) */\n-  /* FIXME: the mask is likely wrong, and the bit position may be as well */\n-  /* FIXME: how does it know how far to shift? */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_ADDR14,\t/* type */\n-\t 1,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"ADDR16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffff,\t\t/* src_mask */\n-\t 0xffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_TOCREL16 0x0008 */\n-  /*   16-bit offset from TOC base */\n-  /* Used: */\n-  HOWTO (IMAGE_REL_PPC_TOCREL16,/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_dont, /* complain_on_overflow */\n-\t ppc_toc16_reloc,\t/* special_function */\n-\t \"TOCREL16\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n-\t 0xffff,\t\t/* src_mask */\n-\t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_TOCREL14 0x0009 */\n-  /*   16-bit offset from TOC base, shifted left 2 (load doubleword) */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_TOCREL14,/* type */\n-\t 1,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"TOCREL14\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n-\t 0xffff,\t\t/* src_mask */\n-\t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_ADDR32NB 0x000A */\n-  /*   32-bit addr w/ image base */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_ADDR32NB,/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"ADDR32NB\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_SECREL 0x000B */\n-  /*   va of containing section (as in an image sectionhdr) */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_SECREL,/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t ppc_secrel_reloc,\t/* special_function */\n-\t \"SECREL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_SECTION 0x000C */\n-  /*   sectionheader number */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_SECTION,/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t ppc_section_reloc,\t/* special_function */\n-\t \"SECTION\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_IFGLUE 0x000D */\n-  /*   substitute TOC restore instruction iff symbol is glue code */\n-  /* Used: */\n-  HOWTO (IMAGE_REL_PPC_IFGLUE,/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"IFGLUE\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_IMGLUE 0x000E */\n-  /*   symbol is glue code; virtual address is TOC restore instruction */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_IMGLUE,/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_dont, /* complain_on_overflow */\n-\t ppc_imglue_reloc,\t/* special_function */\n-\t \"IMGLUE\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_SECREL16 0x000F */\n-  /*   va of containing section (limited to 16 bits) */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_SECREL16,/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"SECREL16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffff,\t\t/* src_mask */\n-\t 0xffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_REFHI\t     0x0010 */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_REFHI,\t/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t ppc_refhi_reloc,\t/* special_function */\n-\t \"REFHI\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_REFLO\t     0x0011 */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_REFLO,\t/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t ppc_refhi_reloc,\t/* special_function */\n-\t \"REFLO\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_PAIR\t\t     0x0012 */\n-  /* Unused: */\n-  HOWTO (IMAGE_REL_PPC_PAIR,\t/* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_signed, /* complain_on_overflow */\n-\t ppc_pair_reloc,\t/* special_function */\n-\t \"PAIR\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n-\t 0xffffffff,\t\t/* src_mask */\n-\t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-  /* IMAGE_REL_PPC_TOCREL16_DEFN 0x0013 */\n-  /*   16-bit offset from TOC base, without causing a definition */\n-  /* Used: */\n-  HOWTO ( (IMAGE_REL_PPC_TOCREL16 | IMAGE_REL_PPC_TOCDEFN), /* type */\n-\t 0,\t\t\t/* rightshift */\n-\t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n-\t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n-\t 0,\t\t\t/* bitpos */\n-\t complain_overflow_dont, /* complain_on_overflow */\n-\t 0,\t\t\t/* special_function */\n-\t \"TOCREL16, TOCDEFN\",\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n-\t 0xffff,\t\t/* src_mask */\n-\t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n-\n-};\n-\f\n-/* Some really cheezy macros that can be turned on to test stderr :-)  */\n-\n-#ifdef DEBUG_RELOC\n-#define UN_IMPL(x)\t\t\t\t\t     \\\n-{\t\t\t\t\t\t\t     \\\n-   static int i;\t\t\t\t\t     \\\n-   if (i == 0)\t\t\t\t\t\t     \\\n-     {\t\t\t\t\t\t\t     \\\n-       i = 1;\t\t\t\t\t\t     \\\n-       fprintf (stderr,_(\"Unimplemented Relocation -- %s\\n\"),x); \\\n-     }\t\t\t\t\t\t\t     \\\n-}\n-\n-#define DUMP_RELOC(n,r)\t\t\t\t     \\\n-{\t\t\t\t\t\t     \\\n-   fprintf (stderr,\"%s sym %d, addr %d, addend %d\\n\", \\\n-\t   n, (*(r->sym_ptr_ptr))->name,\t     \\\n-\t   r->address, r->addend);\t\t     \\\n-}\n-\n-/* Given a reloc name, n, and a pointer to an internal_reloc,\n-   dump out interesting information on the contents\n-\n-#define n_name\t\t_n._n_name\n-#define n_zeroes\t_n._n_n._n_zeroes\n-#define n_offset\t_n._n_n._n_offset  */\n-\n-#define DUMP_RELOC2(n,r)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\\\n-   fprintf (stderr,\"%s sym %d, r_vaddr %d %s\\n\",\t\\\n-\t   n, r->r_symndx, r->r_vaddr,\t\t\t\\\n-\t   (((r->r_type) & IMAGE_REL_PPC_TOCDEFN) == 0) \\\n-\t   ?\" \":\" TOCDEFN\"  );\t\t\t\t\\\n-}\n-\n-#else\n-#define UN_IMPL(x)\n-#define DUMP_RELOC(n,r)\n-#define DUMP_RELOC2(n,r)\n-#endif\n-\f\n-/* TOC construction and management routines.  */\n-\n-/* This file is compiled twice, and these variables are defined in one\n-   of the compilations.  FIXME: This is confusing and weird.  Also,\n-   BFD should not use global variables.  */\n-extern bfd *    bfd_of_toc_owner;\n-extern long int global_toc_size;\n-extern long int import_table_size;\n-extern long int first_thunk_address;\n-extern long int thunk_size;\n-\n-enum toc_type\n-{\n-  default_toc,\n-  toc_32,\n-  toc_64\n-};\n-\n-enum ref_category\n-{\n-  priv,\n-  pub,\n-  tocdata\n-};\n-\n-struct list_ele\n-{\n-  struct list_ele *next;\n-  bfd_vma addr;\n-  enum ref_category cat;\n-  int offset;\n-  const char *name;\n-};\n-\n-extern struct list_ele *head;\n-extern struct list_ele *tail;\n-\n-static void\n-record_toc (asection *toc_section,\n-\t    bfd_signed_vma our_toc_offset,\n-\t    enum ref_category cat,\n-\t    const char *name)\n-{\n-  /* Add this entry to our toc addr-offset-name list.  */\n-  size_t amt = sizeof (struct list_ele);\n-  struct list_ele *t = (struct list_ele *) bfd_malloc (amt);\n-\n-  if (t == NULL)\n-    abort ();\n-  t->next = 0;\n-  t->offset = our_toc_offset;\n-  t->name = name;\n-  t->cat = cat;\n-  t->addr = toc_section->output_offset + our_toc_offset;\n-\n-  if (head == 0)\n-    {\n-      head = t;\n-      tail = t;\n-    }\n-  else\n-    {\n-      tail->next = t;\n-      tail = t;\n-    }\n-}\n-\n-#ifdef COFF_IMAGE_WITH_PE\n-\n-/* Record a toc offset against a symbol.  */\n-static bfd_boolean\n-ppc_record_toc_entry (bfd *abfd,\n-\t\t      struct bfd_link_info *info ATTRIBUTE_UNUSED,\n-\t\t      asection *sec ATTRIBUTE_UNUSED,\n-\t\t      int sym,\n-\t\t      enum toc_type toc_kind ATTRIBUTE_UNUSED)\n-{\n-  struct ppc_coff_link_hash_entry *h;\n-  int *local_syms;\n-\n-  h = 0;\n-\n-  h = (struct ppc_coff_link_hash_entry *) (obj_coff_sym_hashes (abfd)[sym]);\n-  if (h != 0)\n-    {\n-      HASH_CHECK(h);\n-    }\n-\n-  if (h == 0)\n-    {\n-      local_syms = obj_coff_local_toc_table(abfd);\n-\n-      if (local_syms == 0)\n-\t{\n-\t  unsigned int i;\n-\t  bfd_size_type amt;\n-\n-\t  /* allocate a table */\n-\t  amt = (bfd_size_type) obj_raw_syment_count (abfd) * sizeof (int);\n-\t  local_syms = (int *) bfd_zalloc (abfd, amt);\n-\t  if (local_syms == 0)\n-\t    return FALSE;\n-\t  obj_coff_local_toc_table (abfd) = local_syms;\n-\n-\t  for (i = 0; i < obj_raw_syment_count (abfd); ++i)\n-\t    {\n-\t      SET_UNALLOCATED (local_syms[i]);\n-\t    }\n-\t}\n-\n-      if (IS_UNALLOCATED(local_syms[sym]))\n-\t{\n-\t  local_syms[sym] = global_toc_size;\n-\t  global_toc_size += 4;\n-\n-\t  /* The size must fit in a 16-bit displacement.  */\n-\t  if (global_toc_size > 65535)\n-\t    {\n-\t      _bfd_error_handler (_(\"TOC overflow\"));\n-\t      bfd_set_error (bfd_error_file_too_big);\n-\t      return FALSE;\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      /* Check to see if there's a toc slot allocated. If not, do it\n-\t here. It will be used in relocate_section.  */\n-      if (IS_UNALLOCATED(h->toc_offset))\n-\t{\n-\t  h->toc_offset = global_toc_size;\n-\t  global_toc_size += 4;\n-\n-\t  /* The size must fit in a 16-bit displacement.  */\n-\t  if (global_toc_size >= 65535)\n-\t    {\n-\t      _bfd_error_handler (_(\"TOC overflow\"));\n-\t      bfd_set_error (bfd_error_file_too_big);\n-\t      return FALSE;\n-\t    }\n-\t}\n-    }\n-\n-  return TRUE;\n-}\n-\n-/* Record a toc offset against a symbol.  */\n-static void\n-ppc_mark_symbol_as_glue (bfd *abfd,\n-\t\t\t int sym,\n-\t\t\t struct internal_reloc *rel)\n-{\n-  struct ppc_coff_link_hash_entry *h;\n-\n-  h = (struct ppc_coff_link_hash_entry *) (obj_coff_sym_hashes (abfd)[sym]);\n-\n-  HASH_CHECK(h);\n-\n-  h->symbol_is_glue = 1;\n-  h->glue_insn = bfd_get_32 (abfd, (bfd_byte *) &rel->r_vaddr);\n-\n-  return;\n-}\n-\n-#endif /* COFF_IMAGE_WITH_PE */\n-\f\n-/* Return TRUE if this relocation should\n-   appear in the output .reloc section.  */\n-\n-static bfd_boolean\n-in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,\n-\t    reloc_howto_type *howto)\n-{\n-  return\n-    (! howto->pc_relative)\n-      && (howto->type != IMAGE_REL_PPC_ADDR32NB)\n-      && (howto->type != IMAGE_REL_PPC_TOCREL16)\n-      && (howto->type != IMAGE_REL_PPC_IMGLUE)\n-      && (howto->type != IMAGE_REL_PPC_IFGLUE)\n-      && (howto->type != IMAGE_REL_PPC_SECREL)\n-      && (howto->type != IMAGE_REL_PPC_SECTION)\n-      && (howto->type != IMAGE_REL_PPC_SECREL16)\n-      && (howto->type != IMAGE_REL_PPC_REFHI)\n-      && (howto->type != IMAGE_REL_PPC_REFLO)\n-      && (howto->type != IMAGE_REL_PPC_PAIR)\n-      && (howto->type != IMAGE_REL_PPC_TOCREL16_DEFN) ;\n-}\n-\n-static bfd_boolean\n-write_base_file_entry (bfd *obfd, struct bfd_link_info *info, bfd_vma addr)\n-{\n-  if (coff_data (obfd)->pe)\n-     addr -= pe_data (obfd)->pe_opthdr.ImageBase;\n-  if (fwrite (&addr, sizeof (addr), 1, (FILE *) info->base_file) == 1)\n-    return TRUE;\n-\n-  bfd_set_error (bfd_error_system_call);\n-  return FALSE;\n-}\n-\n-/* The reloc processing routine for the optimized COFF linker.  */\n-\n-static bfd_boolean\n-coff_ppc_relocate_section (bfd *output_bfd,\n-\t\t\t   struct bfd_link_info *info,\n-\t\t\t   bfd *input_bfd,\n-\t\t\t   asection *input_section,\n-\t\t\t   bfd_byte *contents,\n-\t\t\t   struct internal_reloc *relocs,\n-\t\t\t   struct internal_syment *syms,\n-\t\t\t   asection **sections)\n-{\n-  struct internal_reloc *rel;\n-  struct internal_reloc *relend;\n-  asection *toc_section = 0;\n-  bfd_vma relocation;\n-  reloc_howto_type *howto = 0;\n-\n-  /* If we are performing a relocatable link, we don't need to do a\n-     thing.  The caller will take care of adjusting the reloc\n-     addresses and symbol indices.  */\n-  if (bfd_link_relocatable (info))\n-    return TRUE;\n-\n-  rel = relocs;\n-  relend = rel + input_section->reloc_count;\n-  for (; rel < relend; rel++)\n-    {\n-      long symndx;\n-      struct ppc_coff_link_hash_entry *h;\n-      struct internal_syment *sym;\n-      bfd_vma val;\n-\n-      asection *sec;\n-      bfd_reloc_status_type rstat;\n-      bfd_byte *loc;\n-\n-      unsigned short r_type  = EXTRACT_TYPE (rel->r_type);\n-      unsigned short r_flags = EXTRACT_FLAGS(rel->r_type);\n-\n-      symndx = rel->r_symndx;\n-      loc = contents + rel->r_vaddr - input_section->vma;\n-\n-      /* FIXME: check bounds on r_type */\n-      howto = ppc_coff_howto_table + r_type;\n-\n-      if (symndx == -1)\n-\t{\n-\t  h = NULL;\n-\t  sym = NULL;\n-\t}\n-      else\n-\t{\n-\t  h = (struct ppc_coff_link_hash_entry *)\n-\t    (obj_coff_sym_hashes (input_bfd)[symndx]);\n-\t  if (h != 0)\n-\t    {\n-\t      HASH_CHECK(h);\n-\t    }\n-\n-\t  sym = syms + symndx;\n-\t}\n-\n-      if (r_type == IMAGE_REL_PPC_IMGLUE && h == 0)\n-\t{\n-\t  /* An IMGLUE reloc must have a name. Something is very wrong.  */\n-\t  abort ();\n-\t}\n-\n-      sec = NULL;\n-      val = 0;\n-\n-      /* FIXME: PAIR unsupported in the following code.  */\n-      if (h == NULL)\n-\t{\n-\t  if (symndx == -1)\n-\t    sec = bfd_abs_section_ptr;\n-\t  else\n-\t    {\n-\t      sec = sections[symndx];\n-\t      val = (sec->output_section->vma\n-\t\t     + sec->output_offset\n-\t\t     + sym->n_value);\n-\t      if (! obj_pe (output_bfd))\n-\t\tval -= sec->vma;\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  HASH_CHECK(h);\n-\n-\t  if (h->root.root.type == bfd_link_hash_defined\n-\t      || h->root.root.type == bfd_link_hash_defweak)\n-\t    {\n-\t      sec = h->root.root.u.def.section;\n-\t      val = (h->root.root.u.def.value\n-\t\t     + sec->output_section->vma\n-\t\t     + sec->output_offset);\n-\t    }\n-\t  else\n-\t    (*info->callbacks->undefined_symbol)\n-\t      (info, h->root.root.root.string, input_bfd, input_section,\n-\t       rel->r_vaddr - input_section->vma, TRUE);\n-\t}\n-\n-      rstat = bfd_reloc_ok;\n-\n-      /* Each case must do its own relocation, setting rstat appropriately.  */\n-      switch (r_type)\n-\t{\n-\tdefault:\n-\t  /* xgettext: c-format */\n-\t  _bfd_error_handler (_(\"%pB: unsupported relocation type %#x\"),\n-\t\t\t      input_bfd, r_type);\n-\t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n-\tcase IMAGE_REL_PPC_TOCREL16:\n-\t  {\n-\t    bfd_signed_vma our_toc_offset;\n-\t    int fixit;\n-\n-\t    DUMP_RELOC2(howto->name, rel);\n-\n-\t    if (toc_section == 0)\n-\t      {\n-\t\ttoc_section = bfd_get_section_by_name (bfd_of_toc_owner,\n-\t\t\t\t\t\t       TOC_SECTION_NAME);\n-\n-\t\tif ( toc_section == NULL )\n-\t\t  {\n-\t\t    /* There is no toc section. Something is very wrong.  */\n-\t\t    abort ();\n-\t\t  }\n-\t      }\n-\n-\t    /* Amazing bit tricks present. As we may have seen earlier, we\n-\t       use the 1 bit to tell us whether or not a toc offset has been\n-\t       allocated. Now that they've all been allocated, we will use\n-\t       the 1 bit to tell us if we've written this particular toc\n-\t       entry out.  */\n-\t    fixit = FALSE;\n-\t    if (h == 0)\n-\t      {\n-\t\t/* It is a file local symbol.  */\n-\t\tint *local_toc_table;\n-\t\tchar name[SYMNMLEN + 1];\n-\n-\t\tsym = syms + symndx;\n-\t\tstrncpy (name, sym->_n._n_name, SYMNMLEN);\n-\t\tname[SYMNMLEN] = '\\0';\n-\n-\t\tlocal_toc_table = obj_coff_local_toc_table(input_bfd);\n-\t\tour_toc_offset = local_toc_table[symndx];\n-\n-\t\tif (IS_WRITTEN(our_toc_offset))\n-\t\t  {\n-\t\t    /* If it has been written out, it is marked with the\n-\t\t       1 bit. Fix up our offset, but do not write it out\n-\t\t       again.  */\n-\t\t    MAKE_ADDR_AGAIN(our_toc_offset);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    /* Write out the toc entry.  */\n-\t\t    record_toc (toc_section, our_toc_offset, priv,\n-\t\t\t\tstrdup (name));\n-\n-\t\t    bfd_put_32 (output_bfd, val,\n-\t\t\t       toc_section->contents + our_toc_offset);\n-\n-\t\t    MARK_AS_WRITTEN(local_toc_table[symndx]);\n-\t\t    fixit = TRUE;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\tconst char *name = h->root.root.root.string;\n-\t\tour_toc_offset = h->toc_offset;\n-\n-\t\tif ((r_flags & IMAGE_REL_PPC_TOCDEFN)\n-\t\t    == IMAGE_REL_PPC_TOCDEFN )\n-\t\t  {\n-\t\t    /* This is unbelievable cheese. Some knowledgable asm\n-\t\t       hacker has decided to use r2 as a base for loading\n-\t\t       a value. He/She does this by setting the tocdefn bit,\n-\t\t       and not supplying a toc definition. The behaviour is\n-\t\t       then to use the difference between the value of the\n-\t\t       symbol and the actual location of the toc as the toc\n-\t\t       index.\n-\n-\t\t       In fact, what is usually happening is, because the\n-\t\t       Import Address Table is mapped immediately following\n-\t\t       the toc, some trippy library code trying for speed on\n-\t\t       dll linkage, takes advantage of that and considers\n-\t\t       the IAT to be part of the toc, thus saving a load.  */\n-\n-\t\t    our_toc_offset = val - (toc_section->output_section->vma\n-\t\t\t\t\t    + toc_section->output_offset);\n-\n-\t\t    /* The size must still fit in a 16-bit displacement.  */\n-\t\t    if ((bfd_vma) our_toc_offset >= 65535)\n-\t\t      {\n-\t\t\t_bfd_error_handler\n-\t\t\t  /* xgettext: c-format */\n-\t\t\t  (_(\"%pB: Relocation for %s of %#\" PRIx64 \" exceeds \"\n-\t\t\t     \"Toc size limit\"),\n-\t\t\t   input_bfd, name, (uint64_t) our_toc_offset);\n-\t\t\tbfd_set_error (bfd_error_bad_value);\n-\t\t\treturn FALSE;\n-\t\t      }\n-\n-\t\t    record_toc (toc_section, our_toc_offset, pub,\n-\t\t\t\tstrdup (name));\n-\t\t  }\n-\t\telse if (IS_WRITTEN (our_toc_offset))\n-\t\t  {\n-\t\t    /* If it has been written out, it is marked with the\n-\t\t       1 bit. Fix up our offset, but do not write it out\n-\t\t       again.  */\n-\t\t    MAKE_ADDR_AGAIN(our_toc_offset);\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    record_toc(toc_section, our_toc_offset, pub,\n-\t\t\t       strdup (name));\n-\n-\t\t    /* Write out the toc entry.  */\n-\t\t    bfd_put_32 (output_bfd, val,\n-\t\t\t       toc_section->contents + our_toc_offset);\n-\n-\t\t    MARK_AS_WRITTEN(h->toc_offset);\n-\t\t    /* The tricky part is that this is the address that\n-\t\t       needs a .reloc entry for it.  */\n-\t\t    fixit = TRUE;\n-\t\t  }\n-\t      }\n-\n-\t    if (fixit && info->base_file)\n-\t      {\n-\t\t/* So if this is non pcrelative, and is referenced\n-\t\t   to a section or a common symbol, then it needs a reloc.  */\n-\n-\t\t/* Relocation to a symbol in a section which\n-\t\t   isn't absolute - we output the address here\n-\t\t   to a file.  */\n-\t\tbfd_vma addr = (toc_section->output_section->vma\n-\t\t\t\t+ toc_section->output_offset + our_toc_offset);\n-\n-\t\tif (!write_base_file_entry (output_bfd, info, addr))\n-\t\t  return FALSE;\n-\t      }\n-\n-\t    /* FIXME: this test is conservative.  */\n-\t    if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN\n-\t\t&& (bfd_vma) our_toc_offset > toc_section->size)\n-\t      {\n-\t\t_bfd_error_handler\n-\t\t  /* xgettext: c-format */\n-\t\t  (_(\"%pB: Relocation exceeds allocated TOC (%#\" PRIx64 \")\"),\n-\t\t   input_bfd, (uint64_t) toc_section->size);\n-\t\tbfd_set_error (bfd_error_bad_value);\n-\t\treturn FALSE;\n-\t      }\n-\n-\t    /* Now we know the relocation for this toc reference.  */\n-\t    relocation =  our_toc_offset + TOC_LOAD_ADJUSTMENT;\n-\t    rstat = _bfd_relocate_contents (howto, input_bfd, relocation, loc);\n-\t  }\n-\t  break;\n-\tcase IMAGE_REL_PPC_IFGLUE:\n-\t  {\n-\t    /* To solve this, we need to know whether or not the symbol\n-\t       appearing on the call instruction is a glue function or not.\n-\t       A glue function must announce itself via a IMGLUE reloc, and\n-\t       the reloc contains the required toc restore instruction.  */\n-\t    DUMP_RELOC2 (howto->name, rel);\n-\n-\t    if (h != 0)\n-\t      {\n-\t\tif (h->symbol_is_glue == 1)\n-\t\t  {\n-\t\t    bfd_put_32 (input_bfd, (bfd_vma) h->glue_insn, loc);\n-\t\t  }\n-\t      }\n-\t  }\n-\t  break;\n-\tcase IMAGE_REL_PPC_SECREL:\n-\t  /* Unimplemented: codeview debugging information.  */\n-\t  /* For fast access to the header of the section\n-\t     containing the item.  */\n-\t  break;\n-\tcase IMAGE_REL_PPC_SECTION:\n-\t  /* Unimplemented: codeview debugging information.  */\n-\t  /* Is used to indicate that the value should be relative\n-\t     to the beginning of the section that contains the\n-\t     symbol.  */\n-\t  break;\n-\tcase IMAGE_REL_PPC_ABSOLUTE:\n-\t  {\n-\t    const char *my_name;\n-\t    char buf[SYMNMLEN + 1];\n-\n-\t    if (h == 0)\n-\t      {\n-\t\tstrncpy (buf, (syms+symndx)->_n._n_name, SYMNMLEN);\n-\t\tbuf[SYMNMLEN] = '\\0';\n-\t\tmy_name = buf;\n-\t      }\n-\t    else\n-\t      my_name = h->root.root.root.string;\n-\n-\t    _bfd_error_handler\n-\t      /* xgettext: c-format */\n-\t      (_(\"warning: unsupported reloc %s <file %pB, section %pA>\\n\"\n-\t\t \"sym %ld (%s), r_vaddr %\" PRId64 \" (%#\" PRIx64 \")\"),\n-\t       howto->name, input_bfd, input_section,\n-\t       rel->r_symndx, my_name,\n-\t       (int64_t) rel->r_vaddr, (uint64_t) rel->r_vaddr);\n-\t  }\n-\t  break;\n-\tcase IMAGE_REL_PPC_IMGLUE:\n-\t  {\n-\t    /* There is nothing to do now. This reloc was noted in the first\n-\t       pass over the relocs, and the glue instruction extracted.  */\n-\t    const char *my_name;\n-\n-\t    if (h->symbol_is_glue == 1)\n-\t      break;\n-\t    my_name = h->root.root.root.string;\n-\n-\t    _bfd_error_handler\n-\t      /* xgettext: c-format */\n-\t      (_(\"%pB: Out of order IMGLUE reloc for %s\"), input_bfd, my_name);\n-\t    bfd_set_error (bfd_error_bad_value);\n-\t    return FALSE;\n-\t  }\n-\n-\tcase IMAGE_REL_PPC_ADDR32NB:\n-\t  {\n-\t    const char *name = 0;\n-\n-\t    DUMP_RELOC2 (howto->name, rel);\n-\n-\t    if (CONST_STRNEQ (input_section->name, \".idata$2\") && first_thunk_address == 0)\n-\t      {\n-\t\t/* Set magic values.  */\n-\t\tint idata5offset;\n-\t\tstruct coff_link_hash_entry *myh;\n-\n-\t\tmyh = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t     \"__idata5_magic__\",\n-\t\t\t\t\t     FALSE, FALSE, TRUE);\n-\t\tfirst_thunk_address = myh->root.u.def.value +\n-\t\t  sec->output_section->vma +\n-\t\t    sec->output_offset -\n-\t\t      pe_data(output_bfd)->pe_opthdr.ImageBase;\n-\n-\t\tidata5offset = myh->root.u.def.value;\n-\t\tmyh = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t     \"__idata6_magic__\",\n-\t\t\t\t\t     FALSE, FALSE, TRUE);\n-\n-\t\tthunk_size = myh->root.u.def.value - idata5offset;\n-\t\tmyh = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t     \"__idata4_magic__\",\n-\t\t\t\t\t     FALSE, FALSE, TRUE);\n-\t\timport_table_size = myh->root.u.def.value;\n-\t      }\n-\n-\t    if (h == 0)\n-\t      /* It is a file local symbol.  */\n-\t      sym = syms + symndx;\n-\t    else\n-\t      {\n-\t\tchar *target = 0;\n-\n-\t\tname = h->root.root.root.string;\n-\t\tif (strcmp (\".idata$2\", name) == 0)\n-\t\t  target = \"__idata2_magic__\";\n-\t\telse if (strcmp (\".idata$4\", name) == 0)\n-\t\t  target = \"__idata4_magic__\";\n-\t\telse if (strcmp (\".idata$5\", name) == 0)\n-\t\t  target = \"__idata5_magic__\";\n-\n-\t\tif (target != 0)\n-\t\t  {\n-\t\t    struct coff_link_hash_entry *myh;\n-\n-\t\t    myh = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t\t target,\n-\t\t\t\t\t\t FALSE, FALSE, TRUE);\n-\t\t    if (myh == 0)\n-\t\t      {\n-\t\t\t/* Missing magic cookies. Something is very wrong.  */\n-\t\t\tabort ();\n-\t\t      }\n-\n-\t\t    val = myh->root.u.def.value +\n-\t\t      sec->output_section->vma + sec->output_offset;\n-\t\t    if (first_thunk_address == 0)\n-\t\t      {\n-\t\t\tint idata5offset;\n-\t\t\tmyh = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t\t     \"__idata5_magic__\",\n-\t\t\t\t\t\t     FALSE, FALSE, TRUE);\n-\t\t\tfirst_thunk_address = myh->root.u.def.value +\n-\t\t\t  sec->output_section->vma +\n-\t\t\t    sec->output_offset -\n-\t\t\t      pe_data(output_bfd)->pe_opthdr.ImageBase;\n-\n-\t\t\tidata5offset = myh->root.u.def.value;\n-\t\t\tmyh = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t\t     \"__idata6_magic__\",\n-\t\t\t\t\t\t     FALSE, FALSE, TRUE);\n-\n-\t\t\tthunk_size = myh->root.u.def.value - idata5offset;\n-\t\t\tmyh = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t\t     \"__idata4_magic__\",\n-\t\t\t\t\t\t     FALSE, FALSE, TRUE);\n-\t\t\timport_table_size = myh->root.u.def.value;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\n-\t    rstat = _bfd_relocate_contents (howto,\n-\t\t\t\t\t    input_bfd,\n-\t\t\t\t\t    val -\n-\t\t\t\t\t    pe_data (output_bfd)->pe_opthdr.ImageBase,\n-\t\t\t\t\t    loc);\n-\t  }\n-\t  break;\n-\n-\tcase IMAGE_REL_PPC_REL24:\n-\t  DUMP_RELOC2(howto->name, rel);\n-\t  val -= (input_section->output_section->vma\n-\t\t  + input_section->output_offset);\n-\n-\t  rstat = _bfd_relocate_contents (howto,\n-\t\t\t\t\t  input_bfd,\n-\t\t\t\t\t  val,\n-\t\t\t\t\t  loc);\n-\t  break;\n-\tcase IMAGE_REL_PPC_ADDR16:\n-\tcase IMAGE_REL_PPC_ADDR24:\n-\tcase IMAGE_REL_PPC_ADDR32:\n-\t  DUMP_RELOC2(howto->name, rel);\n-\t  rstat = _bfd_relocate_contents (howto,\n-\t\t\t\t\t  input_bfd,\n-\t\t\t\t\t  val,\n-\t\t\t\t\t  loc);\n-\t  break;\n-\t}\n-\n-      if (info->base_file)\n-\t{\n-\t  /* So if this is non pcrelative, and is referenced\n-\t     to a section or a common symbol, then it needs a reloc.  */\n-\t  if (sym && pe_data(output_bfd)->in_reloc_p (output_bfd, howto))\n-\t    {\n-\t      /* Relocation to a symbol in a section which\n-\t\t isn't absolute - we output the address here\n-\t\t to a file.  */\n-\t      bfd_vma addr = (rel->r_vaddr\n-\t\t\t      - input_section->vma\n-\t\t\t      + input_section->output_offset\n-\t\t\t      + input_section->output_section->vma);\n-\n-\t      if (!write_base_file_entry (output_bfd, info, addr))\n-\t\treturn FALSE;\n-\t    }\n-\t}\n-\n-      switch (rstat)\n-\t{\n-\tdefault:\n-\t  abort ();\n-\tcase bfd_reloc_ok:\n-\t  break;\n-\tcase bfd_reloc_overflow:\n-\t  {\n-\t    const char *name;\n-\t    char buf[SYMNMLEN + 1];\n-\n-\t    if (symndx == -1)\n-\t      name = \"*ABS*\";\n-\t    else if (h != NULL)\n-\t      name = NULL;\n-\t    else if (sym == NULL)\n-\t      name = \"*unknown*\";\n-\t    else if (sym->_n._n_n._n_zeroes == 0\n-\t\t     && sym->_n._n_n._n_offset != 0)\n-\t      name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;\n-\t    else\n-\t      {\n-\t\tstrncpy (buf, sym->_n._n_name, SYMNMLEN);\n-\t\tbuf[SYMNMLEN] = '\\0';\n-\t\tname = buf;\n-\t      }\n-\n-\t    (*info->callbacks->reloc_overflow)\n-\t      (info, (h ? &h->root.root : NULL), name, howto->name,\n-\t       (bfd_vma) 0, input_bfd, input_section,\n-\t       rel->r_vaddr - input_section->vma);\n-\t  }\n-\t}\n-    }\n-\n-  return TRUE;\n-}\n-\n-#ifdef COFF_IMAGE_WITH_PE\n-\n-/* FIXME: BFD should not use global variables.  This file is compiled\n-   twice, and these variables are shared.  This is confusing and\n-   weird.  */\n-\n-long int global_toc_size = 4;\n-\n-bfd* bfd_of_toc_owner = 0;\n-\n-long int import_table_size;\n-long int first_thunk_address;\n-long int thunk_size;\n-\n-struct list_ele *head;\n-struct list_ele *tail;\n-\n-static char *\n-h1 = N_(\"\\n\\t\\t\\tTOC MAPPING\\n\\n\");\n-static char *\n-h2 = N_(\" TOC    disassembly  Comments       Name\\n\");\n-static char *\n-h3 = N_(\" Offset  spelling                   (if present)\\n\");\n-\n-void\n-dump_toc (void * vfile)\n-{\n-  FILE *file = (FILE *) vfile;\n-  struct list_ele *t;\n-\n-  fputs (_(h1), file);\n-  fputs (_(h2), file);\n-  fputs (_(h3), file);\n-\n-  for (t = head; t != 0; t=t->next)\n-    {\n-      const char *cat = \"\";\n-\n-      if (t->cat == priv)\n-\tcat = _(\"private       \");\n-      else if (t->cat == pub)\n-\tcat = _(\"public        \");\n-      else if (t->cat == tocdata)\n-\tcat = _(\"data-in-toc   \");\n-\n-      if (t->offset > global_toc_size)\n-\t{\n-\t  if (t->offset <= global_toc_size + thunk_size)\n-\t    cat = _(\"IAT reference \");\n-\t  else\n-\t    {\n-\t      fprintf (file,\n-\t\t       /* xgettext: c-format */\n-\t\t      _(\"**** global_toc_size %ld(%lx), thunk_size %ld(%lx)\\n\"),\n-\t\t       global_toc_size, (unsigned long) global_toc_size,\n-\t\t       thunk_size, (unsigned long) thunk_size);\n-\t      cat = _(\"Out of bounds!\");\n-\t    }\n-\t}\n-\n-      fprintf (file,\n-\t      \" %04lx    (%d)\", (unsigned long) t->offset, t->offset - 32768);\n-      fprintf (file,\n-\t      \"    %s %s\\n\",\n-\t      cat, t->name);\n-\n-    }\n-\n-  fprintf (file, \"\\n\");\n-}\n-\n-bfd_boolean\n-ppc_allocate_toc_section (struct bfd_link_info *info ATTRIBUTE_UNUSED)\n-{\n-  asection *s;\n-  bfd_byte *foo;\n-  static char test_char = '1';\n-\n-  if ( global_toc_size == 0 ) /* FIXME: does this get me in trouble?  */\n-    return TRUE;\n-\n-  if (bfd_of_toc_owner == 0)\n-    /* No toc owner? Something is very wrong.  */\n-    abort ();\n-\n-  s = bfd_get_section_by_name ( bfd_of_toc_owner , TOC_SECTION_NAME);\n-  if (s == NULL)\n-    /* No toc section? Something is very wrong.  */\n-    abort ();\n-\n-  foo = (bfd_byte *) bfd_alloc (bfd_of_toc_owner, global_toc_size);\n-  memset(foo, test_char, (size_t) global_toc_size);\n-\n-  s->size = global_toc_size;\n-  s->contents = foo;\n-\n-  return TRUE;\n-}\n-\n-bfd_boolean\n-ppc_process_before_allocation (bfd *abfd,\n-\t\t\t       struct bfd_link_info *info)\n-{\n-  asection *sec;\n-  struct internal_reloc *i, *rel;\n-\n-  /* Here we have a bfd that is to be included on the link. We have a hook\n-     to do reloc rummaging, before section sizes are nailed down.  */\n-  _bfd_coff_get_external_symbols (abfd);\n-\n-  /* Rummage around all the relocs and map the toc.  */\n-  sec = abfd->sections;\n-\n-  if (sec == 0)\n-    return TRUE;\n-\n-  for (; sec != 0; sec = sec->next)\n-    {\n-      if (sec->reloc_count == 0)\n-\tcontinue;\n-\n-      /* load the relocs */\n-      /* FIXME: there may be a storage leak here */\n-      i=_bfd_coff_read_internal_relocs(abfd,sec,1,0,0,0);\n-\n-      if (i == 0)\n-\tabort ();\n-\n-      for (rel = i; rel < i + sec->reloc_count; ++rel)\n-\t{\n-\t  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);\n-\t  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);\n-\t  bfd_boolean ok = TRUE;\n-\n-\t  DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, rel);\n-\n-\t  switch(r_type)\n-\t    {\n-\t    case IMAGE_REL_PPC_TOCREL16:\n-\t      /* If TOCDEFN is on, ignore as someone else has allocated the\n-\t\t toc entry.  */\n-\t      if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN)\n-\t\tok = ppc_record_toc_entry(abfd, info, sec,\n-\t\t\t\t\t  rel->r_symndx, default_toc);\n-\t      if (!ok)\n-\t\treturn FALSE;\n-\t      break;\n-\t    case IMAGE_REL_PPC_IMGLUE:\n-\t      ppc_mark_symbol_as_glue (abfd, rel->r_symndx, rel);\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  return TRUE;\n-}\n-\n-#endif\n-\n-static bfd_reloc_status_type\n-ppc_refhi_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t arelent *reloc_entry ATTRIBUTE_UNUSED,\n-\t\t asymbol *symbol ATTRIBUTE_UNUSED,\n-\t\t void * data ATTRIBUTE_UNUSED,\n-\t\t asection *input_section ATTRIBUTE_UNUSED,\n-\t\t bfd *output_bfd,\n-\t\t char **error_message ATTRIBUTE_UNUSED)\n-{\n-  UN_IMPL(\"REFHI\");\n-  DUMP_RELOC(\"REFHI\",reloc_entry);\n-\n-  if (output_bfd == (bfd *) NULL)\n-    return bfd_reloc_continue;\n-\n-  return bfd_reloc_undefined;\n-}\n-\n-static bfd_reloc_status_type\n-ppc_pair_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\tarelent *reloc_entry ATTRIBUTE_UNUSED,\n-\t\tasymbol *symbol ATTRIBUTE_UNUSED,\n-\t\tvoid * data ATTRIBUTE_UNUSED,\n-\t\tasection *input_section ATTRIBUTE_UNUSED,\n-\t\tbfd *output_bfd,\n-\t\tchar **error_message ATTRIBUTE_UNUSED)\n-{\n-  UN_IMPL(\"PAIR\");\n-  DUMP_RELOC(\"PAIR\",reloc_entry);\n-\n-  if (output_bfd == (bfd *) NULL)\n-    return bfd_reloc_continue;\n-\n-  return bfd_reloc_undefined;\n-}\n-\n-static bfd_reloc_status_type\n-ppc_toc16_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t arelent *reloc_entry ATTRIBUTE_UNUSED,\n-\t\t asymbol *symbol ATTRIBUTE_UNUSED,\n-\t\t void * data ATTRIBUTE_UNUSED,\n-\t\t asection *input_section ATTRIBUTE_UNUSED,\n-\t\t bfd *output_bfd,\n-\t\t char **error_message ATTRIBUTE_UNUSED)\n-{\n-  UN_IMPL (\"TOCREL16\");\n-  DUMP_RELOC (\"TOCREL16\",reloc_entry);\n-\n-  if (output_bfd == (bfd *) NULL)\n-    return bfd_reloc_continue;\n-\n-  return bfd_reloc_ok;\n-}\n-\n-static bfd_reloc_status_type\n-ppc_secrel_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t  arelent *reloc_entry ATTRIBUTE_UNUSED,\n-\t\t  asymbol *symbol ATTRIBUTE_UNUSED,\n-\t\t  void * data ATTRIBUTE_UNUSED,\n-\t\t  asection *input_section ATTRIBUTE_UNUSED,\n-\t\t  bfd *output_bfd,\n-\t\t  char **error_message ATTRIBUTE_UNUSED)\n-{\n-  UN_IMPL(\"SECREL\");\n-  DUMP_RELOC(\"SECREL\",reloc_entry);\n-\n-  if (output_bfd == (bfd *) NULL)\n-    return bfd_reloc_continue;\n-\n-  return bfd_reloc_ok;\n-}\n-\n-static bfd_reloc_status_type\n-ppc_section_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t   arelent *reloc_entry ATTRIBUTE_UNUSED,\n-\t\t   asymbol *symbol ATTRIBUTE_UNUSED,\n-\t\t   void * data ATTRIBUTE_UNUSED,\n-\t\t   asection *input_section ATTRIBUTE_UNUSED,\n-\t\t   bfd *output_bfd,\n-\t\t   char **error_message ATTRIBUTE_UNUSED)\n-{\n-  UN_IMPL(\"SECTION\");\n-  DUMP_RELOC(\"SECTION\",reloc_entry);\n-\n-  if (output_bfd == (bfd *) NULL)\n-    return bfd_reloc_continue;\n-\n-  return bfd_reloc_ok;\n-}\n-\n-static bfd_reloc_status_type\n-ppc_imglue_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t  arelent *reloc_entry ATTRIBUTE_UNUSED,\n-\t\t  asymbol *symbol ATTRIBUTE_UNUSED,\n-\t\t  void * data ATTRIBUTE_UNUSED,\n-\t\t  asection *input_section ATTRIBUTE_UNUSED,\n-\t\t  bfd *output_bfd,\n-\t\t  char **error_message ATTRIBUTE_UNUSED)\n-\n-{\n-  UN_IMPL(\"IMGLUE\");\n-  DUMP_RELOC(\"IMGLUE\",reloc_entry);\n-\n-  if (output_bfd == (bfd *) NULL)\n-    return bfd_reloc_continue;\n-\n-  return bfd_reloc_ok;\n-}\n-\f\n-#define MAX_RELOC_INDEX  \\\n-      (sizeof (ppc_coff_howto_table) / sizeof (ppc_coff_howto_table[0]) - 1)\n-\n-/* FIXME: There is a possibility that when we read in a reloc from a file,\n-\t  that there are some bits encoded in the upper portion of the\n-\t  type field. Not yet implemented.  */\n-\n-static void\n-ppc_coff_rtype2howto (arelent *relent, struct internal_reloc *internal)\n-{\n-  /* We can encode one of three things in the type field, aside from the\n-     type:\n-     1. IMAGE_REL_PPC_NEG - indicates the value field is a subtraction\n-\tvalue, rather than an addition value\n-     2. IMAGE_REL_PPC_BRTAKEN, IMAGE_REL_PPC_BRNTAKEN - indicates that\n-\tthe branch is expected to be taken or not.\n-     3. IMAGE_REL_PPC_TOCDEFN - toc slot definition in the file\n-     For now, we just strip this stuff to find the type, and ignore it other\n-     than that.  */\n-  reloc_howto_type *howto;\n-  unsigned short r_type  = EXTRACT_TYPE (internal->r_type);\n-  unsigned short r_flags = EXTRACT_FLAGS(internal->r_type);\n-  unsigned short junk    = EXTRACT_JUNK (internal->r_type);\n-\n-  /* The masking process only slices off the bottom byte for r_type.  */\n-  if ( r_type > MAX_RELOC_INDEX )\n-    abort ();\n-\n-  /* Check for absolute crap.  */\n-  if (junk != 0)\n-    abort ();\n-\n-  switch(r_type)\n-    {\n-    case IMAGE_REL_PPC_ADDR16:\n-    case IMAGE_REL_PPC_REL24:\n-    case IMAGE_REL_PPC_ADDR24:\n-    case IMAGE_REL_PPC_ADDR32:\n-    case IMAGE_REL_PPC_IFGLUE:\n-    case IMAGE_REL_PPC_ADDR32NB:\n-    case IMAGE_REL_PPC_SECTION:\n-    case IMAGE_REL_PPC_SECREL:\n-      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);\n-      howto = ppc_coff_howto_table + r_type;\n-      break;\n-    case IMAGE_REL_PPC_IMGLUE:\n-      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);\n-      howto = ppc_coff_howto_table + r_type;\n-      break;\n-    case IMAGE_REL_PPC_TOCREL16:\n-      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);\n-      if (r_flags & IMAGE_REL_PPC_TOCDEFN)\n-\thowto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16_DEFN;\n-      else\n-\thowto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16;\n-      break;\n-    default:\n-      _bfd_error_handler\n-\t/* xgettext: c-format */\n-\t(_(\"warning: unsupported reloc %s [%d] used -- it may not work\"),\n-\t ppc_coff_howto_table[r_type].name, r_type);\n-      howto = ppc_coff_howto_table + r_type;\n-      break;\n-    }\n-\n-  relent->howto = howto;\n-}\n-\n-static reloc_howto_type *\n-coff_ppc_rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t\t asection *sec,\n-\t\t\t struct internal_reloc *rel,\n-\t\t\t struct coff_link_hash_entry *h ATTRIBUTE_UNUSED,\n-\t\t\t struct internal_syment *sym ATTRIBUTE_UNUSED,\n-\t\t\t bfd_vma *addendp)\n-{\n-  reloc_howto_type *howto;\n-\n-  /* We can encode one of three things in the type field, aside from the\n-     type:\n-     1. IMAGE_REL_PPC_NEG - indicates the value field is a subtraction\n-\tvalue, rather than an addition value\n-     2. IMAGE_REL_PPC_BRTAKEN, IMAGE_REL_PPC_BRNTAKEN - indicates that\n-\tthe branch is expected to be taken or not.\n-     3. IMAGE_REL_PPC_TOCDEFN - toc slot definition in the file\n-     For now, we just strip this stuff to find the type, and ignore it other\n-     than that.  */\n-\n-  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);\n-  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);\n-  unsigned short junk    = EXTRACT_JUNK  (rel->r_type);\n-\n-  /* The masking process only slices off the bottom byte for r_type.  */\n-  if (r_type > MAX_RELOC_INDEX)\n-    abort ();\n-\n-  /* Check for absolute crap.  */\n-  if (junk != 0)\n-    abort ();\n-\n-  switch(r_type)\n-    {\n-    case IMAGE_REL_PPC_ADDR32NB:\n-      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);\n-      *addendp -= pe_data(sec->output_section->owner)->pe_opthdr.ImageBase;\n-      howto = ppc_coff_howto_table + r_type;\n-      break;\n-    case IMAGE_REL_PPC_TOCREL16:\n-      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);\n-      if (r_flags & IMAGE_REL_PPC_TOCDEFN)\n-\thowto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16_DEFN;\n-      else\n-\thowto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16;\n-      break;\n-    case IMAGE_REL_PPC_ADDR16:\n-    case IMAGE_REL_PPC_REL24:\n-    case IMAGE_REL_PPC_ADDR24:\n-    case IMAGE_REL_PPC_ADDR32:\n-    case IMAGE_REL_PPC_IFGLUE:\n-    case IMAGE_REL_PPC_SECTION:\n-    case IMAGE_REL_PPC_SECREL:\n-      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);\n-      howto = ppc_coff_howto_table + r_type;\n-      break;\n-    case IMAGE_REL_PPC_IMGLUE:\n-      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);\n-      howto = ppc_coff_howto_table + r_type;\n-      break;\n-    default:\n-      _bfd_error_handler\n-\t/* xgettext: c-format */\n-\t(_(\"warning: unsupported reloc %s [%d] used -- it may not work\"),\n-\t ppc_coff_howto_table[r_type].name, r_type);\n-      howto = ppc_coff_howto_table + r_type;\n-      break;\n-    }\n-\n-  return howto;\n-}\n-\n-/* A cheesy little macro to make the code a little more readable.  */\n-#define HOW2MAP(bfd_rtype,ppc_rtype)  \\\n- case bfd_rtype: return &ppc_coff_howto_table[ppc_rtype]\n-\n-static reloc_howto_type *\n-ppc_coff_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t\t    bfd_reloc_code_real_type code)\n-{\n-  switch (code)\n-    {\n-      HOW2MAP(BFD_RELOC_32_GOTOFF,    IMAGE_REL_PPC_IMGLUE);\n-      HOW2MAP(BFD_RELOC_16_GOT_PCREL, IMAGE_REL_PPC_IFGLUE);\n-      HOW2MAP(BFD_RELOC_16,\t      IMAGE_REL_PPC_ADDR16);\n-      HOW2MAP(BFD_RELOC_PPC_B26,      IMAGE_REL_PPC_REL24);\n-      HOW2MAP(BFD_RELOC_PPC_BA26,     IMAGE_REL_PPC_ADDR24);\n-      HOW2MAP(BFD_RELOC_PPC_TOC16,    IMAGE_REL_PPC_TOCREL16);\n-      HOW2MAP(BFD_RELOC_16_GOTOFF,    IMAGE_REL_PPC_TOCREL16_DEFN);\n-      HOW2MAP(BFD_RELOC_32,\t      IMAGE_REL_PPC_ADDR32);\n-      HOW2MAP(BFD_RELOC_RVA,\t      IMAGE_REL_PPC_ADDR32NB);\n-    default:\n-      return NULL;\n-    }\n-}\n-#undef HOW2MAP\n-\n-static reloc_howto_type *\n-ppc_coff_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,\n-\t\t\t    const char *r_name)\n-{\n-  unsigned int i;\n-\n-  for (i = 0;\n-       i < sizeof (ppc_coff_howto_table) / sizeof (ppc_coff_howto_table[0]);\n-       i++)\n-    if (ppc_coff_howto_table[i].name != NULL\n-\t&& strcasecmp (ppc_coff_howto_table[i].name, r_name) == 0)\n-      return &ppc_coff_howto_table[i];\n-\n-  return NULL;\n-}\n-\f\n-/* Tailor coffcode.h -- macro heaven.  */\n-\n-#define RTYPE2HOWTO(cache_ptr, dst)  ppc_coff_rtype2howto (cache_ptr, dst)\n-\n-/* We use the special COFF backend linker, with our own special touch.  */\n-\n-#define coff_bfd_reloc_type_lookup   ppc_coff_reloc_type_lookup\n-#define coff_bfd_reloc_name_lookup ppc_coff_reloc_name_lookup\n-#define coff_rtype_to_howto\t     coff_ppc_rtype_to_howto\n-#define coff_relocate_section\t     coff_ppc_relocate_section\n-#define coff_bfd_final_link\t     ppc_bfd_coff_final_link\n-\n-#ifndef COFF_IMAGE_WITH_PE\n-#endif\n-\n-#define SELECT_RELOC(internal, howto) {internal.r_type=howto->type;}\n-\n-#define COFF_PAGE_SIZE\t\t\t     0x1000\n-\n-/* FIXME: This controls some code that used to be in peicode.h and is\n-   now in peigen.c.  It will not control the code in peigen.c.  If\n-   anybody wants to get this working, you will need to fix that.  */\n-#define POWERPC_LE_PE\n-\n-#define COFF_SECTION_ALIGNMENT_ENTRIES \\\n-{ COFF_SECTION_NAME_EXACT_MATCH (\".idata$2\"), \\\n-  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \\\n-{ COFF_SECTION_NAME_EXACT_MATCH (\".idata$3\"), \\\n-  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \\\n-{ COFF_SECTION_NAME_EXACT_MATCH (\".idata$4\"), \\\n-  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \\\n-{ COFF_SECTION_NAME_EXACT_MATCH (\".idata$5\"), \\\n-  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \\\n-{ COFF_SECTION_NAME_EXACT_MATCH (\".idata$6\"), \\\n-  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 1 }, \\\n-{ COFF_SECTION_NAME_EXACT_MATCH (\".reloc\"), \\\n-  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 1 }\n-\n-#include \"coffcode.h\"\n-\f\n-#ifndef COFF_IMAGE_WITH_PE\n-\n-static bfd_boolean\n-ppc_do_last (bfd *abfd)\n-{\n-  if (abfd == bfd_of_toc_owner)\n-    return TRUE;\n-  else\n-    return FALSE;\n-}\n-\n-static bfd *\n-ppc_get_last (void)\n-{\n-  return bfd_of_toc_owner;\n-}\n-\n-/* This piece of machinery exists only to guarantee that the bfd that holds\n-   the toc section is written last.\n-\n-   This does depend on bfd_make_section attaching a new section to the\n-   end of the section list for the bfd.\n-\n-   This is otherwise intended to be functionally the same as\n-   cofflink.c:_bfd_coff_final_link(). It is specifically different only\n-   where the POWERPC_LE_PE macro modifies the code. It is left in as a\n-   precise form of comment. krk@cygnus.com  */\n-\n-/* Do the final link step.  */\n-\n-bfd_boolean\n-ppc_bfd_coff_final_link (bfd *abfd, struct bfd_link_info *info)\n-{\n-  bfd_size_type symesz;\n-  struct coff_final_link_info flaginfo;\n-  bfd_boolean debug_merge_allocated;\n-  asection *o;\n-  struct bfd_link_order *p;\n-  bfd_size_type max_sym_count;\n-  bfd_size_type max_lineno_count;\n-  bfd_size_type max_reloc_count;\n-  bfd_size_type max_output_reloc_count;\n-  bfd_size_type max_contents_size;\n-  file_ptr rel_filepos;\n-  unsigned int relsz;\n-  file_ptr line_filepos;\n-  unsigned int linesz;\n-  bfd *sub;\n-  bfd_byte *external_relocs = NULL;\n-  char strbuf[STRING_SIZE_SIZE];\n-  bfd_size_type amt;\n-\n-  symesz = bfd_coff_symesz (abfd);\n-\n-  flaginfo.info = info;\n-  flaginfo.output_bfd = abfd;\n-  flaginfo.strtab = NULL;\n-  flaginfo.section_info = NULL;\n-  flaginfo.last_file_index = -1;\n-  flaginfo.last_bf_index = -1;\n-  flaginfo.internal_syms = NULL;\n-  flaginfo.sec_ptrs = NULL;\n-  flaginfo.sym_indices = NULL;\n-  flaginfo.outsyms = NULL;\n-  flaginfo.linenos = NULL;\n-  flaginfo.contents = NULL;\n-  flaginfo.external_relocs = NULL;\n-  flaginfo.internal_relocs = NULL;\n-  debug_merge_allocated = FALSE;\n-\n-  coff_data (abfd)->link_info = info;\n-\n-  flaginfo.strtab = _bfd_stringtab_init ();\n-  if (flaginfo.strtab == NULL)\n-    goto error_return;\n-\n-  if (! coff_debug_merge_hash_table_init (&flaginfo.debug_merge))\n-    goto error_return;\n-  debug_merge_allocated = TRUE;\n-\n-  /* Compute the file positions for all the sections.  */\n-  if (! abfd->output_has_begun)\n-    {\n-      if (! bfd_coff_compute_section_file_positions (abfd))\n-\treturn FALSE;\n-    }\n-\n-  /* Count the line numbers and relocation entries required for the\n-     output file.  Set the file positions for the relocs.  */\n-  rel_filepos = obj_relocbase (abfd);\n-  relsz = bfd_coff_relsz (abfd);\n-  max_contents_size = 0;\n-  max_lineno_count = 0;\n-  max_reloc_count = 0;\n-\n-  for (o = abfd->sections; o != NULL; o = o->next)\n-    {\n-      o->reloc_count = 0;\n-      o->lineno_count = 0;\n-\n-      for (p = o->map_head.link_order; p != NULL; p = p->next)\n-\t{\n-\t  if (p->type == bfd_indirect_link_order)\n-\t    {\n-\t      asection *sec;\n-\n-\t      sec = p->u.indirect.section;\n-\n-\t      /* Mark all sections which are to be included in the\n-\t\t link.  This will normally be every section.  We need\n-\t\t to do this so that we can identify any sections which\n-\t\t the linker has decided to not include.  */\n-\t      sec->linker_mark = TRUE;\n-\n-\t      if (info->strip == strip_none\n-\t\t  || info->strip == strip_some)\n-\t\to->lineno_count += sec->lineno_count;\n-\n-\t      if (bfd_link_relocatable (info))\n-\t\to->reloc_count += sec->reloc_count;\n-\n-\t      if (sec->rawsize > max_contents_size)\n-\t\tmax_contents_size = sec->rawsize;\n-\t      if (sec->size > max_contents_size)\n-\t\tmax_contents_size = sec->size;\n-\t      if (sec->lineno_count > max_lineno_count)\n-\t\tmax_lineno_count = sec->lineno_count;\n-\t      if (sec->reloc_count > max_reloc_count)\n-\t\tmax_reloc_count = sec->reloc_count;\n-\t    }\n-\t  else if (bfd_link_relocatable (info)\n-\t\t   && (p->type == bfd_section_reloc_link_order\n-\t\t       || p->type == bfd_symbol_reloc_link_order))\n-\t    ++o->reloc_count;\n-\t}\n-      if (o->reloc_count == 0)\n-\to->rel_filepos = 0;\n-      else\n-\t{\n-\t  o->flags |= SEC_RELOC;\n-\t  o->rel_filepos = rel_filepos;\n-\t  rel_filepos += o->reloc_count * relsz;\n-\t}\n-    }\n-\n-  /* If doing a relocatable link, allocate space for the pointers we\n-     need to keep.  */\n-  if (bfd_link_relocatable (info))\n-    {\n-      unsigned int i;\n-\n-      /* We use section_count + 1, rather than section_count, because\n-\t the target_index fields are 1 based.  */\n-      amt = abfd->section_count + 1;\n-      amt *= sizeof (struct coff_link_section_info);\n-      flaginfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);\n-\n-      if (flaginfo.section_info == NULL)\n-\tgoto error_return;\n-\n-      for (i = 0; i <= abfd->section_count; i++)\n-\t{\n-\t  flaginfo.section_info[i].relocs = NULL;\n-\t  flaginfo.section_info[i].rel_hashes = NULL;\n-\t}\n-    }\n-\n-  /* We now know the size of the relocs, so we can determine the file\n-     positions of the line numbers.  */\n-  line_filepos = rel_filepos;\n-  linesz = bfd_coff_linesz (abfd);\n-  max_output_reloc_count = 0;\n-\n-  for (o = abfd->sections; o != NULL; o = o->next)\n-    {\n-      if (o->lineno_count == 0)\n-\to->line_filepos = 0;\n-      else\n-\t{\n-\t  o->line_filepos = line_filepos;\n-\t  line_filepos += o->lineno_count * linesz;\n-\t}\n-\n-      if (o->reloc_count != 0)\n-\t{\n-\t  /* We don't know the indices of global symbols until we have\n-\t     written out all the local symbols.  For each section in\n-\t     the output file, we keep an array of pointers to hash\n-\t     table entries.  Each entry in the array corresponds to a\n-\t     reloc.  When we find a reloc against a global symbol, we\n-\t     set the corresponding entry in this array so that we can\n-\t     fix up the symbol index after we have written out all the\n-\t     local symbols.\n-\n-\t     Because of this problem, we also keep the relocs in\n-\t     memory until the end of the link.  This wastes memory,\n-\t     but only when doing a relocatable link, which is not the\n-\t     common case.  */\n-\t  BFD_ASSERT (bfd_link_relocatable (info));\n-\t  amt = o->reloc_count;\n-\t  amt *= sizeof (struct internal_reloc);\n-\t  flaginfo.section_info[o->target_index].relocs =\n-\t    (struct internal_reloc *) bfd_malloc (amt);\n-\t  amt = o->reloc_count;\n-\t  amt *= sizeof (struct coff_link_hash_entry *);\n-\t  flaginfo.section_info[o->target_index].rel_hashes =\n-\t    (struct coff_link_hash_entry **) bfd_malloc (amt);\n-\t  if (flaginfo.section_info[o->target_index].relocs == NULL\n-\t      || flaginfo.section_info[o->target_index].rel_hashes == NULL)\n-\t    goto error_return;\n-\n-\t  if (o->reloc_count > max_output_reloc_count)\n-\t    max_output_reloc_count = o->reloc_count;\n-\t}\n-\n-      /* Reset the reloc and lineno counts, so that we can use them to\n-\t count the number of entries we have output so far.  */\n-      o->reloc_count = 0;\n-      o->lineno_count = 0;\n-    }\n-\n-  obj_sym_filepos (abfd) = line_filepos;\n-\n-  /* Figure out the largest number of symbols in an input BFD.  Take\n-     the opportunity to clear the output_has_begun fields of all the\n-     input BFD's.  */\n-  max_sym_count = 0;\n-  for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n-    {\n-      bfd_size_type sz;\n-\n-      sub->output_has_begun = FALSE;\n-      sz = obj_raw_syment_count (sub);\n-      if (sz > max_sym_count)\n-\tmax_sym_count = sz;\n-    }\n-\n-  /* Allocate some buffers used while linking.  */\n-  amt = max_sym_count * sizeof (struct internal_syment);\n-  flaginfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);\n-  amt = max_sym_count * sizeof (asection *);\n-  flaginfo.sec_ptrs = (asection **) bfd_malloc (amt);\n-  amt = max_sym_count * sizeof (long);\n-  flaginfo.sym_indices = (long *) bfd_malloc (amt);\n-  amt = (max_sym_count + 1) * symesz;\n-  flaginfo.outsyms = (bfd_byte *) bfd_malloc (amt);\n-  amt = max_lineno_count * bfd_coff_linesz (abfd);\n-  flaginfo.linenos = (bfd_byte *) bfd_malloc (amt);\n-  flaginfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);\n-  flaginfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);\n-  if (! bfd_link_relocatable (info))\n-    {\n-      amt = max_reloc_count * sizeof (struct internal_reloc);\n-      flaginfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);\n-    }\n-  if ((flaginfo.internal_syms == NULL && max_sym_count > 0)\n-      || (flaginfo.sec_ptrs == NULL && max_sym_count > 0)\n-      || (flaginfo.sym_indices == NULL && max_sym_count > 0)\n-      || flaginfo.outsyms == NULL\n-      || (flaginfo.linenos == NULL && max_lineno_count > 0)\n-      || (flaginfo.contents == NULL && max_contents_size > 0)\n-      || (flaginfo.external_relocs == NULL && max_reloc_count > 0)\n-      || (! bfd_link_relocatable (info)\n-\t  && flaginfo.internal_relocs == NULL\n-\t  && max_reloc_count > 0))\n-    goto error_return;\n-\n-  /* We now know the position of everything in the file, except that\n-     we don't know the size of the symbol table and therefore we don't\n-     know where the string table starts.  We just build the string\n-     table in memory as we go along.  We process all the relocations\n-     for a single input file at once.  */\n-  obj_raw_syment_count (abfd) = 0;\n-\n-  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)\n-    {\n-      if (! bfd_coff_start_final_link (abfd, info))\n-\tgoto error_return;\n-    }\n-\n-  for (o = abfd->sections; o != NULL; o = o->next)\n-    {\n-      for (p = o->map_head.link_order; p != NULL; p = p->next)\n-\t{\n-\t  if (p->type == bfd_indirect_link_order\n-\t      && (bfd_get_flavour (p->u.indirect.section->owner)\n-\t\t  == bfd_target_coff_flavour))\n-\t    {\n-\t      sub = p->u.indirect.section->owner;\n-#ifdef POWERPC_LE_PE\n-\t      if (! sub->output_has_begun && !ppc_do_last(sub))\n-#else\n-\t      if (! sub->output_has_begun)\n-#endif\n-\t\t{\n-\t\t  if (! _bfd_coff_link_input_bfd (&flaginfo, sub))\n-\t\t    goto error_return;\n-\t\t  sub->output_has_begun = TRUE;\n-\t\t}\n-\t    }\n-\t  else if (p->type == bfd_section_reloc_link_order\n-\t\t   || p->type == bfd_symbol_reloc_link_order)\n-\t    {\n-\t      if (! _bfd_coff_reloc_link_order (abfd, &flaginfo, o, p))\n-\t\tgoto error_return;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (! _bfd_default_link_order (abfd, info, o, p))\n-\t\tgoto error_return;\n-\t    }\n-\t}\n-    }\n-\n-#ifdef POWERPC_LE_PE\n-  {\n-    bfd* last_one = ppc_get_last();\n-    if (last_one)\n-      {\n-\tif (! _bfd_coff_link_input_bfd (&flaginfo, last_one))\n-\t  goto error_return;\n-      }\n-    last_one->output_has_begun = TRUE;\n-  }\n-#endif\n-\n-  /* Free up the buffers used by _bfd_coff_link_input_bfd.  */\n-  coff_debug_merge_hash_table_free (&flaginfo.debug_merge);\n-  debug_merge_allocated = FALSE;\n-\n-  free (flaginfo.internal_syms);\n-  flaginfo.internal_syms = NULL;\n-  free (flaginfo.sec_ptrs);\n-  flaginfo.sec_ptrs = NULL;\n-  free (flaginfo.sym_indices);\n-  flaginfo.sym_indices = NULL;\n-  free (flaginfo.linenos);\n-  flaginfo.linenos = NULL;\n-  free (flaginfo.contents);\n-  flaginfo.contents = NULL;\n-  free (flaginfo.external_relocs);\n-  flaginfo.external_relocs = NULL;\n-  free (flaginfo.internal_relocs);\n-  flaginfo.internal_relocs = NULL;\n-\n-  /* The value of the last C_FILE symbol is supposed to be the symbol\n-     index of the first external symbol.  Write it out again if\n-     necessary.  */\n-  if (flaginfo.last_file_index != -1\n-      && (unsigned int) flaginfo.last_file.n_value != obj_raw_syment_count (abfd))\n-    {\n-      file_ptr pos;\n-\n-      flaginfo.last_file.n_value = obj_raw_syment_count (abfd);\n-      bfd_coff_swap_sym_out (abfd, &flaginfo.last_file,\n-\t\t\t     flaginfo.outsyms);\n-      pos = obj_sym_filepos (abfd) + flaginfo.last_file_index * symesz;\n-      if (bfd_seek (abfd, pos, SEEK_SET) != 0\n-\t  || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz)\n-\treturn FALSE;\n-    }\n-\n-  /* Write out the global symbols.  */\n-  flaginfo.failed = FALSE;\n-  bfd_hash_traverse (&info->hash->table, _bfd_coff_write_global_sym, &flaginfo);\n-  if (flaginfo.failed)\n-    goto error_return;\n-\n-  /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */\n-  free (flaginfo.outsyms);\n-  flaginfo.outsyms = NULL;\n-\n-  if (bfd_link_relocatable (info))\n-    {\n-      /* Now that we have written out all the global symbols, we know\n-\t the symbol indices to use for relocs against them, and we can\n-\t finally write out the relocs.  */\n-      amt = max_output_reloc_count * relsz;\n-      external_relocs = (bfd_byte *) bfd_malloc (amt);\n-      if (external_relocs == NULL)\n-\tgoto error_return;\n-\n-      for (o = abfd->sections; o != NULL; o = o->next)\n-\t{\n-\t  struct internal_reloc *irel;\n-\t  struct internal_reloc *irelend;\n-\t  struct coff_link_hash_entry **rel_hash;\n-\t  bfd_byte *erel;\n-\n-\t  if (o->reloc_count == 0)\n-\t    continue;\n-\n-\t  irel = flaginfo.section_info[o->target_index].relocs;\n-\t  irelend = irel + o->reloc_count;\n-\t  rel_hash = flaginfo.section_info[o->target_index].rel_hashes;\n-\t  erel = external_relocs;\n-\t  for (; irel < irelend; irel++, rel_hash++, erel += relsz)\n-\t    {\n-\t      if (*rel_hash != NULL)\n-\t\t{\n-\t\t  BFD_ASSERT ((*rel_hash)->indx >= 0);\n-\t\t  irel->r_symndx = (*rel_hash)->indx;\n-\t\t}\n-\t      bfd_coff_swap_reloc_out (abfd, irel, erel);\n-\t    }\n-\n-\t  amt = relsz * o->reloc_count;\n-\t  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0\n-\t      || bfd_bwrite (external_relocs, amt, abfd) != amt)\n-\t    goto error_return;\n-\t}\n-\n-      free (external_relocs);\n-      external_relocs = NULL;\n-    }\n-\n-  /* Free up the section information.  */\n-  if (flaginfo.section_info != NULL)\n-    {\n-      unsigned int i;\n-\n-      for (i = 0; i < abfd->section_count; i++)\n-\t{\n-\t  free (flaginfo.section_info[i].relocs);\n-\t  free (flaginfo.section_info[i].rel_hashes);\n-\t}\n-      free (flaginfo.section_info);\n-      flaginfo.section_info = NULL;\n-    }\n-\n-  /* If we have optimized stabs strings, output them.  */\n-  if (coff_hash_table (info)->stab_info.stabstr != NULL)\n-    {\n-      if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))\n-\treturn FALSE;\n-    }\n-\n-  /* Write out the string table.  */\n-  if (obj_raw_syment_count (abfd) != 0)\n-    {\n-      file_ptr pos;\n-\n-      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;\n-      if (bfd_seek (abfd, pos, SEEK_SET) != 0)\n-\treturn FALSE;\n-\n-#if STRING_SIZE_SIZE == 4\n-      H_PUT_32 (abfd,\n-\t\t_bfd_stringtab_size (flaginfo.strtab) + STRING_SIZE_SIZE,\n-\t\tstrbuf);\n-#else\n- #error Change H_PUT_32 above\n-#endif\n-\n-      if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)\n-\t  != STRING_SIZE_SIZE)\n-\treturn FALSE;\n-\n-      if (! _bfd_stringtab_emit (abfd, flaginfo.strtab))\n-\treturn FALSE;\n-    }\n-\n-  _bfd_stringtab_free (flaginfo.strtab);\n-\n-  /* Setting symcount to 0 will cause write_object_contents to\n-     not try to write out the symbols.  */\n-  abfd->symcount = 0;\n-\n-  return TRUE;\n-\n- error_return:\n-  if (debug_merge_allocated)\n-    coff_debug_merge_hash_table_free (&flaginfo.debug_merge);\n-  if (flaginfo.strtab != NULL)\n-    _bfd_stringtab_free (flaginfo.strtab);\n-  if (flaginfo.section_info != NULL)\n-    {\n-      unsigned int i;\n-\n-      for (i = 0; i < abfd->section_count; i++)\n-\t{\n-\t  free (flaginfo.section_info[i].relocs);\n-\t  free (flaginfo.section_info[i].rel_hashes);\n-\t}\n-      free (flaginfo.section_info);\n-    }\n-  free (flaginfo.internal_syms);\n-  free (flaginfo.sec_ptrs);\n-  free (flaginfo.sym_indices);\n-  free (flaginfo.outsyms);\n-  free (flaginfo.linenos);\n-  free (flaginfo.contents);\n-  free (flaginfo.external_relocs);\n-  free (flaginfo.internal_relocs);\n-  free (external_relocs);\n-  return FALSE;\n-}\n-#endif\n-\f\n-/* Forward declaration for use by alternative_target field.  */\n-#ifdef TARGET_BIG_SYM\n-extern const bfd_target TARGET_BIG_SYM;\n-#endif\n-\n-/* The transfer vectors that lead the outside world to all of the above.  */\n-\n-#ifdef TARGET_LITTLE_SYM\n-const bfd_target TARGET_LITTLE_SYM =\n-{\n-  TARGET_LITTLE_NAME,\t\t/* name or coff-arm-little */\n-  bfd_target_coff_flavour,\n-  BFD_ENDIAN_LITTLE,\t\t/* data byte order is little */\n-  BFD_ENDIAN_LITTLE,\t\t/* header byte order is little */\n-\n-  (HAS_RELOC | EXEC_P\t\t/* FIXME: object flags */\n-   | HAS_LINENO | HAS_DEBUG\n-   | HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),\n-\n-#ifndef COFF_WITH_PE\n-  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY\n-   | SEC_RELOC),\t\t/* section flags */\n-#else\n-  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY\n-   | SEC_RELOC | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),\n-#endif\n-\n-  0,\t\t\t\t/* leading char */\n-  '/',\t\t\t\t/* ar_pad_char */\n-  15,\t\t\t\t/* ar_max_namelen??? FIXMEmgo */\n-  0,\t\t\t\t/* match priority.  */\n-\n-  bfd_getl64, bfd_getl_signed_64, bfd_putl64,\n-  bfd_getl32, bfd_getl_signed_32, bfd_putl32,\n-  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */\n-\n-  bfd_getl64, bfd_getl_signed_64, bfd_putl64,\n-  bfd_getl32, bfd_getl_signed_32, bfd_putl32,\n-  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */\n-\n-  {\t\t\t\t/* bfd_check_format */\n-    _bfd_dummy_target,\n-    coff_object_p,\n-    bfd_generic_archive_p,\n-    coff_object_p\n-  },\n-  {\t\t\t\t/* bfd_set_format */\n-    _bfd_bool_bfd_false_error,\n-    coff_mkobject,\n-    _bfd_generic_mkarchive,\n-    _bfd_bool_bfd_false_error\n-  },\n-  {\t\t\t\t/* bfd_write_contents */\n-    _bfd_bool_bfd_false_error,\n-    coff_write_object_contents,\n-    _bfd_write_archive_contents,\n-    _bfd_bool_bfd_false_error\n-  },\n-\n-  BFD_JUMP_TABLE_GENERIC (coff),\n-  BFD_JUMP_TABLE_COPY (coff),\n-  BFD_JUMP_TABLE_CORE (_bfd_nocore),\n-  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),\n-  BFD_JUMP_TABLE_SYMBOLS (coff),\n-  BFD_JUMP_TABLE_RELOCS (coff),\n-  BFD_JUMP_TABLE_WRITE (coff),\n-  BFD_JUMP_TABLE_LINK (coff),\n-  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),\n-\n-  /* Alternative_target.  */\n-#ifdef TARGET_BIG_SYM\n-  &TARGET_BIG_SYM,\n-#else\n-  NULL,\n-#endif\n-\n-  COFF_SWAP_TABLE\n-};\n-#endif\n-\n-#ifdef TARGET_BIG_SYM\n-const bfd_target TARGET_BIG_SYM =\n-{\n-  TARGET_BIG_NAME,\n-  bfd_target_coff_flavour,\n-  BFD_ENDIAN_BIG,\t\t/* data byte order is big */\n-  BFD_ENDIAN_BIG,\t\t/* header byte order is big */\n-\n-  (HAS_RELOC | EXEC_P\t\t/* FIXME: object flags */\n-   | HAS_LINENO | HAS_DEBUG\n-   | HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),\n-\n-#ifndef COFF_WITH_PE\n-  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY\n-   | SEC_RELOC),\t\t/* section flags */\n-#else\n-  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY\n-   | SEC_RELOC | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),\n-#endif\n-\n-  0,\t\t\t\t/* leading char */\n-  '/',\t\t\t\t/* ar_pad_char */\n-  15,\t\t\t\t/* ar_max_namelen??? FIXMEmgo */\n-  0,\t\t\t\t/* match priority.  */\n-\n-  bfd_getb64, bfd_getb_signed_64, bfd_putb64,\n-  bfd_getb32, bfd_getb_signed_32, bfd_putb32,\n-  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */\n-\n-  bfd_getb64, bfd_getb_signed_64, bfd_putb64,\n-  bfd_getb32, bfd_getb_signed_32, bfd_putb32,\n-  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */\n-\n-  {\t\t\t\t/* bfd_check_format */\n-    _bfd_dummy_target,\n-    coff_object_p,\n-    bfd_generic_archive_p,\n-    coff_object_p\n-  },\n-  {\t\t\t\t/* bfd_set_format */\n-    _bfd_bool_bfd_false_error,\n-    coff_mkobject,\n-    _bfd_generic_mkarchive,\n-    _bfd_bool_bfd_false_error\n-  },\n-  {\t\t\t\t/* bfd_write_contents */\n-    _bfd_bool_bfd_false_error,\n-    coff_write_object_contents,\n-    _bfd_write_archive_contents,\n-    _bfd_bool_bfd_false_error\n-  },\n-\n-  BFD_JUMP_TABLE_GENERIC (coff),\n-  BFD_JUMP_TABLE_COPY (coff),\n-  BFD_JUMP_TABLE_CORE (_bfd_nocore),\n-  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),\n-  BFD_JUMP_TABLE_SYMBOLS (coff),\n-  BFD_JUMP_TABLE_RELOCS (coff),\n-  BFD_JUMP_TABLE_WRITE (coff),\n-  BFD_JUMP_TABLE_LINK (coff),\n-  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),\n-\n-  /* Alternative_target.  */\n-#ifdef TARGET_LITTLE_SYM\n-  &TARGET_LITTLE_SYM,\n-#else\n-  NULL,\n-#endif\n-\n-  COFF_SWAP_TABLE\n-};\n-\n-#endif"
    },
    {
      "sha": "4b934b9b2b96fb29f1e42e1d214f95720a12e07b",
      "filename": "bfd/coffcode.h",
      "status": "modified",
      "additions": 0,
      "deletions": 36,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/coffcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/coffcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffcode.h?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -2136,11 +2136,6 @@ coff_set_arch_mach_hook (bfd *abfd, void * filehdr)\n   machine = 0;\n   switch (internal_f->f_magic)\n     {\n-#ifdef PPCMAGIC\n-    case PPCMAGIC:\n-      arch = bfd_arch_powerpc;\n-      break;\n-#endif\n #ifdef I386MAGIC\n     case I386MAGIC:\n     case I386PTXMAGIC:\n@@ -2790,12 +2785,6 @@ coff_set_flags (bfd * abfd,\n       return TRUE;\n #endif\n \n-#ifdef PPCMAGIC\n-    case bfd_arch_powerpc:\n-      *magicp = PPCMAGIC;\n-      return TRUE;\n-#endif\n-\n #if defined(I386MAGIC) || defined(AMD64MAGIC)\n     case bfd_arch_i386:\n #if defined(I386MAGIC)\n@@ -2848,9 +2837,7 @@ coff_set_flags (bfd * abfd,\n \n #ifdef RS6000COFF_C\n     case bfd_arch_rs6000:\n-#ifndef PPCMAGIC\n     case bfd_arch_powerpc:\n-#endif\n       BFD_ASSERT (bfd_get_flavour (abfd) == bfd_target_xcoff_flavour);\n       *magicp = bfd_xcoff_magic_number (abfd);\n       return TRUE;\n@@ -3890,11 +3877,6 @@ coff_write_object_contents (bfd * abfd)\n     internal_a.magic = ZMAGIC;\n #endif\n \n-#if defined(PPC_PE)\n-#define __A_MAGIC_SET__\n-    internal_a.magic = IMAGE_NT_OPTIONAL_HDR_MAGIC;\n-#endif\n-\n #if defined MCORE_PE\n #define __A_MAGIC_SET__\n     internal_a.magic = IMAGE_NT_OPTIONAL_HDR_MAGIC;\n@@ -3976,24 +3958,6 @@ coff_write_object_contents (bfd * abfd)\n \treturn FALSE;\n     }\n #endif\n-#ifdef COFF_IMAGE_WITH_PE\n-#ifdef PPC_PE\n-  else if ((abfd->flags & EXEC_P) != 0)\n-    {\n-      bfd_byte b;\n-\n-      /* PowerPC PE appears to require that all executable files be\n-\t rounded up to the page size.  */\n-      b = 0;\n-      if (bfd_seek (abfd,\n-\t\t    (file_ptr) BFD_ALIGN (sym_base, COFF_PAGE_SIZE) - 1,\n-\t\t    SEEK_SET) != 0\n-\t  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)\n-\treturn FALSE;\n-    }\n-#endif\n-#endif\n-\n   /* If bfd_get_symcount (abfd) != 0, then we are not using the COFF\n      backend linker, and obj_raw_syment_count is not valid until after\n      coff_write_symbols is called.  */"
    },
    {
      "sha": "4586a89d0f97b411bed19f2f0af9094c432c7ede",
      "filename": "bfd/config.bfd",
      "status": "modified",
      "additions": 1,
      "deletions": 5,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/config.bfd",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/config.bfd",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/config.bfd?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -53,7 +53,6 @@ case $targ in\n     echo \"*** Use or1k-*-elf or or1k-*-linux as the target instead\" >&2\n     exit 1\n     ;;\n- powerpcle-*-pe | powerpcle-*-winnt* | powerpcle-*-cygwin* | \\\n  xc16x-*-* | \\\n  null)\n     if test \"x$enable_obsolete\" != xyes; then\n@@ -143,6 +142,7 @@ case $targ in\n  mips*-sgi-* | \\\n  mips*el-*-rtems* | \\\n  powerpc-*-lynxos* | powerpc-*-windiss* | \\\n+ powerpcle-*-pe | powerpcle-*-winnt* | powerpcle-*-cygwin* | \\\n  sh*-*-symbianelf* | sh5*-*-* | sh64*-*-* | \\\n  sparc*-*-*aout* | \\\n  sparc*-*-chorus* | \\\n@@ -1145,10 +1145,6 @@ case \"${targ}\" in\n     targ_selvecs=\"rs6000_xcoff_vec powerpc_elf32_vec powerpc_boot_vec\"\n     targ64_selvecs=\"powerpc_elf64_vec powerpc_elf64_le_vec\"\n     ;;\n-  powerpcle-*-pe | powerpcle-*-winnt* | powerpcle-*-cygwin*)\n-    targ_defvec=powerpc_pe_le_vec\n-    targ_selvecs=\"powerpc_pei_le_vec powerpc_pei_vec powerpc_pe_le_vec powerpc_pe_vec\"\n-    ;;\n \n   pru-*-*)\n     targ_defvec=pru_elf32_vec"
    },
    {
      "sha": "ca255aaa55d41f43b627e26a94dfeaa6e0e43eaf",
      "filename": "bfd/configure",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/configure?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -14883,10 +14883,6 @@ do\n     powerpc_elf64_vec)\t\t tb=\"$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf\"; target_size=64 ;;\n     powerpc_elf64_le_vec)\t tb=\"$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf\" target_size=64 ;;\n     powerpc_elf64_fbsd_vec)\t tb=\"$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf\" target_size=64 ;;\n-    powerpc_pe_vec)\t\t tb=\"$tb pe-ppc.lo peigen.lo $coff\" ;;\n-    powerpc_pe_le_vec)\t\t tb=\"$tb pe-ppc.lo peigen.lo $coff\" ;;\n-    powerpc_pei_vec)\t\t tb=\"$tb pei-ppc.lo peigen.lo $coff\" ;;\n-    powerpc_pei_le_vec)\t\t tb=\"$tb pei-ppc.lo peigen.lo $coff\" ;;\n     powerpc_xcoff_vec)\t\t tb=\"$tb coff-rs6000.lo $xcoff\" ;;\n     pru_elf32_vec)\t\t tb=\"$tb elf32-pru.lo elf32.lo $elf\" ;;\n     riscv_elf32_vec)\t\t tb=\"$tb elf32-riscv.lo elfxx-riscv.lo elf32.lo $elf\" ;;"
    },
    {
      "sha": "ee3075aca34ae37871578e77101b1d548f0a0d6f",
      "filename": "bfd/configure.ac",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/configure.ac?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -619,10 +619,6 @@ do\n     powerpc_elf64_vec)\t\t tb=\"$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf\"; target_size=64 ;;\n     powerpc_elf64_le_vec)\t tb=\"$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf\" target_size=64 ;;\n     powerpc_elf64_fbsd_vec)\t tb=\"$tb elf64-ppc.lo elf64-gen.lo elf64.lo $elf\" target_size=64 ;;\n-    powerpc_pe_vec)\t\t tb=\"$tb pe-ppc.lo peigen.lo $coff\" ;;\n-    powerpc_pe_le_vec)\t\t tb=\"$tb pe-ppc.lo peigen.lo $coff\" ;;\n-    powerpc_pei_vec)\t\t tb=\"$tb pei-ppc.lo peigen.lo $coff\" ;;\n-    powerpc_pei_le_vec)\t\t tb=\"$tb pei-ppc.lo peigen.lo $coff\" ;;\n     powerpc_xcoff_vec)\t\t tb=\"$tb coff-rs6000.lo $xcoff\" ;;\n     pru_elf32_vec)\t\t tb=\"$tb elf32-pru.lo elf32.lo $elf\" ;;\n     riscv_elf32_vec)\t\t tb=\"$tb elf32-riscv.lo elfxx-riscv.lo elf32.lo $elf\" ;;"
    },
    {
      "sha": "aa5edc2e96286e5215bb47ddd3878bd08424b6ab",
      "filename": "bfd/libcoff-in.h",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/libcoff-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/libcoff-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libcoff-in.h?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -616,11 +616,3 @@ extern bfd_boolean _bfd_xcoff_define_common_symbol\n extern bfd_boolean _bfd_ppc_xcoff_relocate_section\n   (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,\n    struct internal_reloc *, struct internal_syment *, asection **);\n-\n-/* Functions in coff-ppc.c.  FIXME: These are called by pe.em in the\n-   linker, and so should start with bfd and be declared in bfd.h.  */\n-\n-extern bfd_boolean ppc_allocate_toc_section\n-  (struct bfd_link_info *);\n-extern bfd_boolean ppc_process_before_allocation\n-  (bfd *, struct bfd_link_info *);"
    },
    {
      "sha": "514cec11499b901e2e895a155d8db429b077d354",
      "filename": "bfd/libcoff.h",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/libcoff.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/libcoff.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libcoff.h?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -620,14 +620,6 @@ extern bfd_boolean _bfd_xcoff_define_common_symbol\n extern bfd_boolean _bfd_ppc_xcoff_relocate_section\n   (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,\n    struct internal_reloc *, struct internal_syment *, asection **);\n-\n-/* Functions in coff-ppc.c.  FIXME: These are called by pe.em in the\n-   linker, and so should start with bfd and be declared in bfd.h.  */\n-\n-extern bfd_boolean ppc_allocate_toc_section\n-  (struct bfd_link_info *);\n-extern bfd_boolean ppc_process_before_allocation\n-  (bfd *, struct bfd_link_info *);\n /* Extracted from coffcode.h.  */\n \n typedef struct coff_ptr_struct"
    },
    {
      "sha": "18325761879927458a22004cc7c9407aaacbaa59",
      "filename": "bfd/pe-ppc.c",
      "status": "removed",
      "additions": 0,
      "deletions": 47,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c560184eb2074570988c498aaae494d0c4b00328/bfd/pe-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c560184eb2074570988c498aaae494d0c4b00328/bfd/pe-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pe-ppc.c?ref=c560184eb2074570988c498aaae494d0c4b00328",
      "patch": "@@ -1,47 +0,0 @@\n-/* BFD back-end for PowerPC PECOFF files.\n-   Copyright (C) 1995-2020 Free Software Foundation, Inc.\n-\n-   This file is part of BFD, the Binary File Descriptor library.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, 51 Franklin Street - Fifth Floor,\n-   Boston, MA 02110-1301, USA.  */\n-\n-#include \"sysdep.h\"\n-#include \"bfd.h\"\n-\n-#define E_FILENMLEN     18\n-\n-#define PPC_PE\n-\n-#define TARGET_LITTLE_SYM   powerpc_pe_le_vec\n-#define TARGET_LITTLE_NAME \"pe-powerpcle\"\n-\n-#define TARGET_BIG_SYM      powerpc_pe_vec\n-#define TARGET_BIG_NAME    \"pe-powerpc\"\n-\n-#define COFF_WITH_PE\n-\n-#define COFF_LONG_SECTION_NAMES\n-\n-/* FIXME: verify PCRELOFFSET is always false */\n-\n-/* FIXME: This target no longer works.  Search for POWERPC_LE_PE in\n-   coff-ppc.c and peigen.c.  */\n-\n-#ifndef bfd_pe_print_pdata\n-#define bfd_pe_print_pdata\tNULL\n-#endif\n-\n-#include \"coff-ppc.c\""
    },
    {
      "sha": "3c3fa27e02004d944c75a60f2e6e40ace1aea563",
      "filename": "bfd/peXXigen.c",
      "status": "modified",
      "additions": 1,
      "deletions": 112,
      "changes": 113,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/peXXigen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/peXXigen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/peXXigen.c?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -105,12 +105,6 @@\n #define HighBitSet(val)      ((val) & 0x80000000)\n #define SetHighBit(val)      ((val) | 0x80000000)\n #define WithoutHighBit(val)  ((val) & 0x7fffffff)\n-\n-/* FIXME: This file has various tests of POWERPC_LE_PE.  Those tests\n-   worked when the code was in peicode.h, but no longer work now that\n-   the code is in peigen.c.  PowerPC NT is said to be dead.  If\n-   anybody wants to revive the code, you will have to figure out how\n-   to handle those issues.  */\n \f\n void\n _bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1)\n@@ -222,12 +216,6 @@ _bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1)\n       in->n_sclass = C_STAT;\n     }\n #endif\n-\n-#ifdef coff_swap_sym_in_hook\n-  /* This won't work in peigen.c, but since it's for PPC PE, it's not\n-     worth fixing.  */\n-  coff_swap_sym_in_hook (abfd, ext1, in1);\n-#endif\n }\n \n static bfd_boolean\n@@ -592,15 +580,6 @@ _bfd_XXi_swap_aouthdr_in (bfd * abfd,\n       aouthdr_int->data_start &= 0xffffffff;\n     }\n #endif\n-\n-#ifdef POWERPC_LE_PE\n-  /* These three fields are normally set up by ppc_relocate_section.\n-     In the case of reading a file in, we can pick them up from the\n-     DataDirectory.  */\n-  first_thunk_address = a->DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress;\n-  thunk_size = a->DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size;\n-  import_table_size = a->DataDirectory[PE_IMPORT_TABLE].Size;\n-#endif\n }\n \n /* A support function for below.  */\n@@ -1010,7 +989,7 @@ _bfd_XXi_swap_scnhdr_out (bfd * abfd, void * in, void * out)\n        (0x02000000).  Also, the resource data should also be read and\n        writable.  */\n \n-    /* FIXME: Alignment is also encoded in this field, at least on PPC and\n+    /* FIXME: Alignment is also encoded in this field, at least on\n        ARM-WINCE.  Although - how do we get the original alignment field\n        back ?  */\n \n@@ -1256,26 +1235,13 @@ static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] =\n   N_(\"Reserved\")\n };\n \n-#ifdef POWERPC_LE_PE\n-/* The code for the PPC really falls in the \"architecture dependent\"\n-   category.  However, it's not clear that anyone will ever care, so\n-   we're ignoring the issue for now; if/when PPC matters, some of this\n-   may need to go into peicode.h, or arguments passed to enable the\n-   PPC- specific code.  */\n-#endif\n-\n static bfd_boolean\n pe_print_idata (bfd * abfd, void * vfile)\n {\n   FILE *file = (FILE *) vfile;\n   bfd_byte *data;\n   asection *section;\n   bfd_signed_vma adj;\n-\n-#ifdef POWERPC_LE_PE\n-  asection *rel_section = bfd_get_section_by_name (abfd, \".reldata\");\n-#endif\n-\n   bfd_size_type datasize = 0;\n   bfd_size_type dataoff;\n   bfd_size_type i;\n@@ -1331,56 +1297,6 @@ pe_print_idata (bfd * abfd, void * vfile)\n \n   dataoff = addr - section->vma;\n \n-#ifdef POWERPC_LE_PE\n-  if (rel_section != 0 && rel_section->size != 0)\n-    {\n-      /* The toc address can be found by taking the starting address,\n-\t which on the PPC locates a function descriptor. The\n-\t descriptor consists of the function code starting address\n-\t followed by the address of the toc. The starting address we\n-\t get from the bfd, and the descriptor is supposed to be in the\n-\t .reldata section.  */\n-\n-      bfd_vma loadable_toc_address;\n-      bfd_vma toc_address;\n-      bfd_vma start_address;\n-      bfd_byte *data;\n-      bfd_vma offset;\n-\n-      if (!bfd_malloc_and_get_section (abfd, rel_section, &data))\n-\t{\n-\t  free (data);\n-\t  return FALSE;\n-\t}\n-\n-      offset = abfd->start_address - rel_section->vma;\n-\n-      if (offset >= rel_section->size || offset + 8 > rel_section->size)\n-\t{\n-\t  free (data);\n-\t  return FALSE;\n-\t}\n-\n-      start_address = bfd_get_32 (abfd, data + offset);\n-      loadable_toc_address = bfd_get_32 (abfd, data + offset + 4);\n-      toc_address = loadable_toc_address - 32768;\n-\n-      fprintf (file,\n-\t       _(\"\\nFunction descriptor located at the start address: %04lx\\n\"),\n-\t       (unsigned long int) (abfd->start_address));\n-      fprintf (file,\n-\t       /* xgettext:c-format */\n-\t       _(\"\\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\\n\"),\n-\t       start_address, loadable_toc_address, toc_address);\n-      free (data);\n-    }\n-  else\n-    {\n-      fprintf (file,\n-\t       _(\"\\nNo reldata section! Function descriptor not decoded.\\n\"));\n-    }\n-#endif\n-\n   fprintf (file,\n \t   _(\"\\nThe Import Tables (interpreted %s section contents)\\n\"),\n \t   section->name);\n@@ -1985,33 +1901,6 @@ pe_print_pdata (bfd * abfd, void * vfile)\n       bfd_fprintf_vma (abfd, file, prolog_end_addr);\n       fprintf (file, \"   %x\", em_data);\n #endif\n-\n-#ifdef POWERPC_LE_PE\n-      if (eh_handler == 0 && eh_data != 0)\n-\t{\n-\t  /* Special bits here, although the meaning may be a little\n-\t     mysterious. The only one I know for sure is 0x03\n-\t     Code Significance\n-\t     0x00 None\n-\t     0x01 Register Save Millicode\n-\t     0x02 Register Restore Millicode\n-\t     0x03 Glue Code Sequence.  */\n-\t  switch (eh_data)\n-\t    {\n-\t    case 0x01:\n-\t      fprintf (file, _(\" Register save millicode\"));\n-\t      break;\n-\t    case 0x02:\n-\t      fprintf (file, _(\" Register restore millicode\"));\n-\t      break;\n-\t    case 0x03:\n-\t      fprintf (file, _(\" Glue code sequence\"));\n-\t      break;\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-#endif\n       fprintf (file, \"\\n\");\n     }\n "
    },
    {
      "sha": "b39c11e5f83153b5f0b81ce0857248bb9cb3c1a7",
      "filename": "bfd/pei-ppc.c",
      "status": "removed",
      "additions": 0,
      "deletions": 50,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c560184eb2074570988c498aaae494d0c4b00328/bfd/pei-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c560184eb2074570988c498aaae494d0c4b00328/bfd/pei-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pei-ppc.c?ref=c560184eb2074570988c498aaae494d0c4b00328",
      "patch": "@@ -1,50 +0,0 @@\n-/* BFD back-end for PowerPC PE IMAGE COFF files.\n-   Copyright (C) 1995-2020 Free Software Foundation, Inc.\n-\n-   This file is part of BFD, the Binary File Descriptor library.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, 51 Franklin Street - Fifth Floor,\n-   Boston, MA 02110-1301, USA.  */\n-\n-#include \"sysdep.h\"\n-#include \"bfd.h\"\n-\n-/* setting up for a PE environment stolen directly from the i386 structure */\n-#define E_FILNMLEN\t18\t/* # characters in a file name\t\t*/\n-\n-#define PPC_PE\n-\n-#define TARGET_LITTLE_SYM   powerpc_pei_le_vec\n-#define TARGET_LITTLE_NAME \"pei-powerpcle\"\n-\n-#define TARGET_BIG_SYM      powerpc_pei_vec\n-#define TARGET_BIG_NAME    \"pei-powerpc\"\n-\n-#define COFF_IMAGE_WITH_PE\n-#define COFF_WITH_PE\n-\n-/* Long section names not allowed in executable images, only object files.  */\n-#define COFF_LONG_SECTION_NAMES 0\n-\n-/* FIXME: Verify PCRELOFFSET is always false */\n-\n-/* FIXME: This target no longer works.  Search for POWERPC_LE_PE in\n-   coff-ppc.c and peigen.c.  */\n-\n-#ifndef bfd_pe_print_pdata\n-#define bfd_pe_print_pdata\tNULL\n-#endif\n-\n-#include \"coff-ppc.c\""
    },
    {
      "sha": "83530b27f23e48f062499638883ffeb0e97a5a8e",
      "filename": "bfd/po/SRC-POTFILES.in",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/po/SRC-POTFILES.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/po/SRC-POTFILES.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/po/SRC-POTFILES.in?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -314,7 +314,6 @@ pe-arm-wince.c\n pe-arm.c\n pe-i386.c\n pe-mcore.c\n-pe-ppc.c\n pe-sh.c\n pe-x86_64.c\n pef-traceback.h\n@@ -325,7 +324,6 @@ pei-arm.c\n pei-i386.c\n pei-ia64.c\n pei-mcore.c\n-pei-ppc.c\n pei-sh.c\n pei-x86_64.c\n peicode.h"
    },
    {
      "sha": "35492b92bbecc0f8359ee1a2ef872de69cd91724",
      "filename": "bfd/targets.c",
      "status": "modified",
      "additions": 0,
      "deletions": 8,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/targets.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/bfd/targets.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/targets.c?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -838,10 +838,6 @@ extern const bfd_target powerpc_elf32_vxworks_vec;\n extern const bfd_target powerpc_elf64_vec;\n extern const bfd_target powerpc_elf64_le_vec;\n extern const bfd_target powerpc_elf64_fbsd_vec;\n-extern const bfd_target powerpc_pe_vec;\n-extern const bfd_target powerpc_pe_le_vec;\n-extern const bfd_target powerpc_pei_vec;\n-extern const bfd_target powerpc_pei_le_vec;\n extern const bfd_target powerpc_xcoff_vec;\n extern const bfd_target pru_elf32_vec;\n extern const bfd_target riscv_elf32_vec;\n@@ -1229,10 +1225,6 @@ static const bfd_target * const _bfd_target_vector[] =\n \t&powerpc_elf64_le_vec,\n \t&powerpc_elf64_fbsd_vec,\n #endif\n-\t&powerpc_pe_vec,\n-\t&powerpc_pe_le_vec,\n-\t&powerpc_pei_vec,\n-\t&powerpc_pei_le_vec,\n #if 0\n \t/* This has the same magic number as RS/6000.  */\n \t&powerpc_xcoff_vec,"
    },
    {
      "sha": "9bb68e6991eec12fbba096160d4b08691427f80c",
      "filename": "binutils/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/binutils/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/binutils/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/ChangeLog?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -1,3 +1,9 @@\n+2020-07-09  Alan Modra  <amodra@gmail.com>\n+\n+\t* dlltool.c: Remove powerpc PE support and comments.\n+\t* configure.ac: Remove powerpc PE dlltool config.\n+\t* configure: Regenerate.\n+\n 2020-07-09  Nick Clifton  <nickc@redhat.com>\n \n \t* rclex.c: Add OWNERDRAW keyword."
    },
    {
      "sha": "da7da53f1dedb034efecc8aa3fff7b2f33cb393d",
      "filename": "binutils/configure",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/binutils/configure",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/binutils/configure",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/configure?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -15146,15 +15146,6 @@ do\n \tpowerpc*-aix[5-9].*)\n \t  OBJDUMP_DEFS=\"-DAIX_WEAK_SUPPORT\"\n \t  ;;\n-\tpowerpc*-*-pe* | powerpc*-*-cygwin*)\n-  \t  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'\n-\t  if test -z \"$DLLTOOL_DEFAULT\"; then\n-\t    DLLTOOL_DEFAULT=\"-DDLLTOOL_DEFAULT_PPC\"\n-\t  fi\n-\t  DLLTOOL_DEFS=\"$DLLTOOL_DEFS -DDLLTOOL_PPC\"\n-\t  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'\n-\t  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'\n-\t  ;;\n \tpowerpc*-*-linux* | powerpc*-*-elf* | powerpc*-*-eabi*)\n \t  case \"$BUILD_INSTALL_MISC\" in\n \t    *embedspu*) ;;"
    },
    {
      "sha": "883f3187e722ec7cf6bdf05b24c4f6f958f97e18",
      "filename": "binutils/configure.ac",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/binutils/configure.ac",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/binutils/configure.ac",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/configure.ac?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -330,15 +330,6 @@ changequote(,)dnl\n changequote([,])dnl\n \t  OBJDUMP_DEFS=\"-DAIX_WEAK_SUPPORT\"\n \t  ;;\n-\tpowerpc*-*-pe* | powerpc*-*-cygwin*)\n-  \t  BUILD_DLLTOOL='$(DLLTOOL_PROG)$(EXEEXT)'\n-\t  if test -z \"$DLLTOOL_DEFAULT\"; then\n-\t    DLLTOOL_DEFAULT=\"-DDLLTOOL_DEFAULT_PPC\"\n-\t  fi\n-\t  DLLTOOL_DEFS=\"$DLLTOOL_DEFS -DDLLTOOL_PPC\"\n-\t  BUILD_WINDRES='$(WINDRES_PROG)$(EXEEXT)'\n-\t  BUILD_WINDMC='$(WINDMC_PROG)$(EXEEXT)'\n-\t  ;;\n \tpowerpc*-*-linux* | powerpc*-*-elf* | powerpc*-*-eabi*)\n \t  case \"$BUILD_INSTALL_MISC\" in\n \t    *embedspu*) ;;"
    },
    {
      "sha": "ed016b97dc38cdb1b85d2f6df676b9c9750f0d41",
      "filename": "binutils/dlltool.c",
      "status": "modified",
      "additions": 25,
      "deletions": 299,
      "changes": 324,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/binutils/dlltool.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/binutils/dlltool.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/dlltool.c?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -229,7 +229,7 @@\n    = Array of { short, asciz } entries, one for each imported function.\n    The `short' is the function's ordinal number.\n \n-   .idata$7 = dll name (eg: \"kernel32.dll\"). (.idata$6 for ppc).  */\n+   .idata$7 = dll name (eg: \"kernel32.dll\").  */\n \n #include \"sysdep.h\"\n #include \"bfd.h\"\n@@ -449,10 +449,6 @@ static const char *mname = \"i386\";\n static const char *mname = \"i386:x86-64\";\n #endif\n \n-#ifdef DLLTOOL_DEFAULT_PPC\n-static const char *mname = \"ppc\";\n-#endif\n-\n #ifdef DLLTOOL_DEFAULT_SH\n static const char *mname = \"sh\";\n #endif\n@@ -563,28 +559,6 @@ static const unsigned char mcore_le_jtab[] =\n   0x00, 0x00, 0x00, 0x00 /* <address>      */\n };\n \n-/* This is the glue sequence for PowerPC PE. There is a\n-   tocrel16-tocdefn reloc against the first instruction.\n-   We also need a IMGLUE reloc against the glue function\n-   to restore the toc saved by the third instruction in\n-   the glue.  */\n-static const unsigned char ppc_jtab[] =\n-{\n-  0x00, 0x00, 0x62, 0x81, /* lwz r11,0(r2)               */\n-                          /*   Reloc TOCREL16 __imp_xxx  */\n-  0x00, 0x00, 0x8B, 0x81, /* lwz r12,0(r11)              */\n-  0x04, 0x00, 0x41, 0x90, /* stw r2,4(r1)                */\n-  0xA6, 0x03, 0x89, 0x7D, /* mtctr r12                   */\n-  0x04, 0x00, 0x4B, 0x80, /* lwz r2,4(r11)               */\n-  0x20, 0x04, 0x80, 0x4E  /* bctr                        */\n-};\n-\n-#ifdef DLLTOOL_PPC\n-/* The glue instruction, picks up the toc from the stw in\n-   the above code: \"lwz r2,4(r1)\".  */\n-static bfd_vma ppc_glue_insn = 0x80410004;\n-#endif\n-\n static const char i386_trampoline[] =\n   \"\\tpushl %%ecx\\n\"\n   \"\\tpushl %%edx\\n\"\n@@ -661,16 +635,7 @@ mtable[] =\n   }\n   ,\n   {\n-#define MPPC 2\n-    \"ppc\", \".byte\", \".short\", \".long\", \".asciz\", \"#\",\n-    \"jmp *\", \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"\",\n-    \"pe-powerpcle\",bfd_arch_powerpc,\n-    ppc_jtab, sizeof (ppc_jtab), 0,\n-    0, 0, 0, 0, 0, 0\n-  }\n-  ,\n-  {\n-#define MTHUMB 3\n+#define MTHUMB 2\n     \"thumb\", \".byte\", \".short\", \".long\", \".asciz\", \"@\",\n     \"push\\t{r6}\\n\\tldr\\tr6, [pc, #8]\\n\\tldr\\tr6, [r6]\\n\\tmov\\tip, r6\\n\\tpop\\t{r6}\\n\\tbx\\tip\",\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-mthumb-interwork\",\n@@ -679,7 +644,7 @@ mtable[] =\n     0, 0, 0, 0, 0, 0\n   }\n   ,\n-#define MARM_INTERWORK 4\n+#define MARM_INTERWORK 3\n   {\n     \"arm_interwork\", \".byte\", \".short\", \".long\", \".asciz\", \"@\",\n     \"ldr\\tip,[pc]\\n\\tldr\\tip,[ip]\\n\\tbx\\tip\\n\\t.long\",\n@@ -690,7 +655,7 @@ mtable[] =\n   }\n   ,\n   {\n-#define MMCORE_BE 5\n+#define MMCORE_BE 4\n     \"mcore-be\", \".byte\", \".short\", \".long\", \".asciz\", \"//\",\n     \"lrw r1,[1f]\\n\\tld.w r1,(r1,0)\\n\\tjmp r1\\n\\tnop\\n1:.long\",\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"\",\n@@ -700,7 +665,7 @@ mtable[] =\n   }\n   ,\n   {\n-#define MMCORE_LE 6\n+#define MMCORE_LE 5\n     \"mcore-le\", \".byte\", \".short\", \".long\", \".asciz\", \"//\",\n     \"lrw r1,[1f]\\n\\tld.w r1,(r1,0)\\n\\tjmp r1\\n\\tnop\\n1:.long\",\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-EL\",\n@@ -710,7 +675,7 @@ mtable[] =\n   }\n   ,\n   {\n-#define MMCORE_ELF 7\n+#define MMCORE_ELF 6\n     \"mcore-elf-be\", \".byte\", \".short\", \".long\", \".asciz\", \"//\",\n     \"lrw r1,[1f]\\n\\tld.w r1,(r1,0)\\n\\tjmp r1\\n\\tnop\\n1:.long\",\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"\",\n@@ -720,7 +685,7 @@ mtable[] =\n   }\n   ,\n   {\n-#define MMCORE_ELF_LE 8\n+#define MMCORE_ELF_LE 7\n     \"mcore-elf-le\", \".byte\", \".short\", \".long\", \".asciz\", \"//\",\n     \"lrw r1,[1f]\\n\\tld.w r1,(r1,0)\\n\\tjmp r1\\n\\tnop\\n1:.long\",\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-EL\",\n@@ -730,7 +695,7 @@ mtable[] =\n   }\n   ,\n   {\n-#define MARM_WINCE 9\n+#define MARM_WINCE 8\n     \"arm-wince\", \".byte\", \".short\", \".long\", \".asciz\", \"@\",\n     \"ldr\\tip,[pc]\\n\\tldr\\tpc,[ip]\\n\\t.long\",\n     \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"-mapcs-32\",\n@@ -740,7 +705,7 @@ mtable[] =\n   }\n   ,\n   {\n-#define MX86 10\n+#define MX86 9\n     \"i386:x86-64\", \".byte\", \".short\", \".long\", \".asciz\", \"#\",\n     \"jmp *\", \".global\", \".space\", \".align\\t2\",\".align\\t4\", \"\",\n     \"pe-x86-64\",bfd_arch_i386,\n@@ -888,7 +853,6 @@ rvaafter (int mach)\n     case MARM:\n     case M386:\n     case MX86:\n-    case MPPC:\n     case MTHUMB:\n     case MARM_INTERWORK:\n     case MMCORE_BE:\n@@ -913,7 +877,6 @@ rvabefore (int mach)\n     case MARM:\n     case M386:\n     case MX86:\n-    case MPPC:\n     case MTHUMB:\n     case MARM_INTERWORK:\n     case MMCORE_BE:\n@@ -936,7 +899,6 @@ asm_prefix (int mach, const char *name)\n   switch (mach)\n     {\n     case MARM:\n-    case MPPC:\n     case MTHUMB:\n     case MARM_INTERWORK:\n     case MMCORE_BE:\n@@ -2296,8 +2258,6 @@ typedef struct\n #define INIT_SEC_DATA(id, name, flags, align) \\\n         { id, name, flags, align, NULL, NULL, NULL, 0, NULL }\n \n-#ifndef DLLTOOL_PPC\n-\n #define TEXT 0\n #define DATA 1\n #define BSS 2\n@@ -2324,37 +2284,6 @@ static sinfo secdata[NSECS] =\n   INIT_SEC_DATA (IDATA6, \".idata$6\", SEC_HAS_CONTENTS, 1)\n };\n \n-#else\n-\n-/* Sections numbered to make the order the same as other PowerPC NT\n-   compilers. This also keeps funny alignment thingies from happening.  */\n-#define TEXT   0\n-#define PDATA  1\n-#define RDATA  2\n-#define IDATA5 3\n-#define IDATA4 4\n-#define IDATA6 5\n-#define IDATA7 6\n-#define DATA   7\n-#define BSS    8\n-\n-#define NSECS 9\n-\n-static sinfo secdata[NSECS] =\n-{\n-  INIT_SEC_DATA (TEXT,   \".text\",    SEC_CODE | SEC_HAS_CONTENTS, 3),\n-  INIT_SEC_DATA (PDATA,  \".pdata\",   SEC_HAS_CONTENTS,            2),\n-  INIT_SEC_DATA (RDATA,  \".reldata\", SEC_HAS_CONTENTS,            2),\n-  INIT_SEC_DATA (IDATA5, \".idata$5\", SEC_HAS_CONTENTS,            2),\n-  INIT_SEC_DATA (IDATA4, \".idata$4\", SEC_HAS_CONTENTS,            2),\n-  INIT_SEC_DATA (IDATA6, \".idata$6\", SEC_HAS_CONTENTS,            1),\n-  INIT_SEC_DATA (IDATA7, \".idata$7\", SEC_HAS_CONTENTS,            2),\n-  INIT_SEC_DATA (DATA,   \".data\",    SEC_DATA,                    2),\n-  INIT_SEC_DATA (BSS,    \".bss\",     0,                           2)\n-};\n-\n-#endif\n-\n /* This is what we're trying to make.  We generate the imp symbols with\n    both single and double underscores, for compatibility.\n \n@@ -2376,21 +2305,7 @@ __imp_GetFileVersionInfoSizeW@8:\n # Hint/Name table\n \t.section\t.idata$6\n ID2:\t.short\t2\n-\t.asciz\t\"GetFileVersionInfoSizeW\"\n-\n-\n-   For the PowerPC, here's the variation on the above scheme:\n-\n-# Rather than a simple \"jmp *\", the code to get to the dll function\n-# looks like:\n-         .text\n-         lwz\tr11,[tocv]__imp_function_name(r2)\n-#\t\t   RELOC: 00000000 TOCREL16,TOCDEFN __imp_function_name\n-         lwz\tr12,0(r11)\n-\t stw\tr2,4(r1)\n-\t mtctr\tr12\n-\t lwz\tr2,4(r11)\n-\t bctr  */\n+\t.asciz\t\"GetFileVersionInfoSizeW\"  */\n \n static char *\n make_label (const char *prefix, const char *name)\n@@ -2438,11 +2353,6 @@ make_one_lib_file (export_type *exp, int i, int delay)\n   asymbol *  iname_lab;\n   asymbol ** iname_lab_pp;\n   asymbol ** iname_pp;\n-#ifdef DLLTOOL_PPC\n-  asymbol ** fn_pp;\n-  asymbol ** toc_pp;\n-#define EXTRA\t 2\n-#endif\n #ifndef EXTRA\n #define EXTRA    0\n #endif\n@@ -2503,18 +2413,7 @@ make_one_lib_file (export_type *exp, int i, int delay)\n     {\n       exp_label = bfd_make_empty_symbol (abfd);\n       exp_label->name = make_imp_label (\"\", exp->name);\n-\n-      /* On PowerPC, the function name points to a descriptor in\n-\t the rdata section, the first element of which is a\n-\t pointer to the code (..function_name), and the second\n-\t points to the .toc.  */\n-#ifdef DLLTOOL_PPC\n-      if (machine == MPPC)\n-\texp_label->section = secdata[RDATA].sec;\n-      else\n-#endif\n-\texp_label->section = secdata[TEXT].sec;\n-\n+      exp_label->section = secdata[TEXT].sec;\n       exp_label->flags = BSF_GLOBAL;\n       exp_label->value = 0;\n \n@@ -2558,36 +2457,6 @@ make_one_lib_file (export_type *exp, int i, int delay)\n   iname_lab_pp = ptrs + oidx;\n   ptrs[oidx++] = iname_lab;\n \n-#ifdef DLLTOOL_PPC\n-  /* The symbol referring to the code (.text).  */\n-  {\n-    asymbol *function_name;\n-\n-    function_name = bfd_make_empty_symbol(abfd);\n-    function_name->name = make_label (\"..\", exp->name);\n-    function_name->section = secdata[TEXT].sec;\n-    function_name->flags = BSF_GLOBAL;\n-    function_name->value = 0;\n-\n-    fn_pp = ptrs + oidx;\n-    ptrs[oidx++] = function_name;\n-  }\n-\n-  /* The .toc symbol.  */\n-  {\n-    asymbol *toc_symbol;\n-\n-    toc_symbol = bfd_make_empty_symbol (abfd);\n-    toc_symbol->name = make_label (\".\", \"toc\");\n-    toc_symbol->section = bfd_und_section_ptr;\n-    toc_symbol->flags = BSF_GLOBAL;\n-    toc_symbol->value = 0;\n-\n-    toc_pp = ptrs + oidx;\n-    ptrs[oidx++] = toc_symbol;\n-  }\n-#endif\n-\n   ptrs[oidx] = 0;\n \n   for (i = 0; i < NSECS; i++)\n@@ -2629,13 +2498,7 @@ make_one_lib_file (export_type *exp, int i, int delay)\n \t          rpp[3] = 0;\n \t        }\n \n-\t      if (machine == MPPC)\n-\t\t{\n-\t\t  rel->howto = bfd_reloc_type_lookup (abfd,\n-\t\t\t\t\t\t      BFD_RELOC_16_GOTOFF);\n-\t\t  rel->sym_ptr_ptr = iname_pp;\n-\t\t}\n-\t      else if (machine == MX86)\n+\t      if (machine == MX86)\n \t\t{\n \t\t  rel->howto = bfd_reloc_type_lookup (abfd,\n \t\t\t\t\t\t      BFD_RELOC_32_PCREL);\n@@ -2788,114 +2651,6 @@ make_one_lib_file (export_type *exp, int i, int delay)\n \t  sec->orelocation = rpp;\n \t  sec->reloc_count = 1;\n \t  break;\n-\n-#ifdef DLLTOOL_PPC\n-\tcase PDATA:\n-\t  {\n-\t    /* The .pdata section is 5 words long.\n-\t       Think of it as:\n-\t       struct\n-\t       {\n-\t       bfd_vma BeginAddress,     [0x00]\n-\t       EndAddress,       [0x04]\n-\t       ExceptionHandler, [0x08]\n-\t       HandlerData,      [0x0c]\n-\t       PrologEndAddress; [0x10]\n-\t       };  */\n-\n-\t    /* So this pdata section setups up this as a glue linkage to\n-\t       a dll routine. There are a number of house keeping things\n-\t       we need to do:\n-\n-\t       1. In the name of glue trickery, the ADDR32 relocs for 0,\n-\t       4, and 0x10 are set to point to the same place:\n-\t       \"..function_name\".\n-\t       2. There is one more reloc needed in the pdata section.\n-\t       The actual glue instruction to restore the toc on\n-\t       return is saved as the offset in an IMGLUE reloc.\n-\t       So we need a total of four relocs for this section.\n-\n-\t       3. Lastly, the HandlerData field is set to 0x03, to indicate\n-\t       that this is a glue routine.  */\n-\t    arelent *imglue, *ba_rel, *ea_rel, *pea_rel;\n-\n-\t    /* Alignment must be set to 2**2 or you get extra stuff.  */\n-\t    bfd_set_section_alignment (sec, 2);\n-\n-\t    si->size = 4 * 5;\n-\t    si->data = xmalloc (si->size);\n-\t    memset (si->data, 0, si->size);\n-\t    rpp = xmalloc (sizeof (arelent *) * 5);\n-\t    rpp[0] = imglue  = xmalloc (sizeof (arelent));\n-\t    rpp[1] = ba_rel  = xmalloc (sizeof (arelent));\n-\t    rpp[2] = ea_rel  = xmalloc (sizeof (arelent));\n-\t    rpp[3] = pea_rel = xmalloc (sizeof (arelent));\n-\t    rpp[4] = 0;\n-\n-\t    /* Stick the toc reload instruction in the glue reloc.  */\n-\t    bfd_put_32(abfd, ppc_glue_insn, (char *) &imglue->address);\n-\n-\t    imglue->addend = 0;\n-\t    imglue->howto = bfd_reloc_type_lookup (abfd,\n-\t\t\t\t\t\t   BFD_RELOC_32_GOTOFF);\n-\t    imglue->sym_ptr_ptr = fn_pp;\n-\n-\t    ba_rel->address = 0;\n-\t    ba_rel->addend = 0;\n-\t    ba_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);\n-\t    ba_rel->sym_ptr_ptr = fn_pp;\n-\n-\t    bfd_put_32 (abfd, 0x18, si->data + 0x04);\n-\t    ea_rel->address = 4;\n-\t    ea_rel->addend = 0;\n-\t    ea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);\n-\t    ea_rel->sym_ptr_ptr = fn_pp;\n-\n-\t    /* Mark it as glue.  */\n-\t    bfd_put_32 (abfd, 0x03, si->data + 0x0c);\n-\n-\t    /* Mark the prolog end address.  */\n-\t    bfd_put_32 (abfd, 0x0D, si->data + 0x10);\n-\t    pea_rel->address = 0x10;\n-\t    pea_rel->addend = 0;\n-\t    pea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);\n-\t    pea_rel->sym_ptr_ptr = fn_pp;\n-\n-\t    sec->orelocation = rpp;\n-\t    sec->reloc_count = 4;\n-\t    break;\n-\t  }\n-\tcase RDATA:\n-\t  /* Each external function in a PowerPC PE file has a two word\n-\t     descriptor consisting of:\n-\t     1. The address of the code.\n-\t     2. The address of the appropriate .toc\n-\t     We use relocs to build this.  */\n-\t  si->size = 8;\n-\t  si->data = xmalloc (8);\n-\t  memset (si->data, 0, si->size);\n-\n-\t  rpp = xmalloc (sizeof (arelent *) * 3);\n-\t  rpp[0] = rel = xmalloc (sizeof (arelent));\n-\t  rpp[1] = xmalloc (sizeof (arelent));\n-\t  rpp[2] = 0;\n-\n-\t  rel->address = 0;\n-\t  rel->addend = 0;\n-\t  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);\n-\t  rel->sym_ptr_ptr = fn_pp;\n-\n-\t  rel = rpp[1];\n-\n-\t  rel->address = 4;\n-\t  rel->addend = 0;\n-\t  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);\n-\t  rel->sym_ptr_ptr = toc_pp;\n-\n-\t  sec->orelocation = rpp;\n-\t  sec->reloc_count = 2;\n-\t  break;\n-#endif /* DLLTOOL_PPC */\n \t}\n     }\n \n@@ -3134,30 +2889,7 @@ make_tail (void)\n \tfprintf (f,\"\\t%s\\t0\\n\", ASM_LONG); /* NULL terminating list.  */\n     }\n \n-#ifdef DLLTOOL_PPC\n-  /* Normally, we need to see a null descriptor built in idata$3 to\n-     act as the terminator for the list. The ideal way, I suppose,\n-     would be to mark this section as a comdat type 2 section, so\n-     only one would appear in the final .exe (if our linker supported\n-     comdat, that is) or cause it to be inserted by something else (say\n-     crt0).  */\n-\n-  fprintf (f, \"\\t.section\\t.idata$3\\n\");\n-  fprintf (f, \"\\t%s\\t0\\n\", ASM_LONG);\n-  fprintf (f, \"\\t%s\\t0\\n\", ASM_LONG);\n-  fprintf (f, \"\\t%s\\t0\\n\", ASM_LONG);\n-  fprintf (f, \"\\t%s\\t0\\n\", ASM_LONG);\n-  fprintf (f, \"\\t%s\\t0\\n\", ASM_LONG);\n-#endif\n-\n-#ifdef DLLTOOL_PPC\n-  /* Other PowerPC NT compilers use idata$6 for the dllname, so I\n-     do too. Original, huh?  */\n-  fprintf (f, \"\\t.section\\t.idata$6\\n\");\n-#else\n   fprintf (f, \"\\t.section\\t.idata$7\\n\");\n-#endif\n-\n   fprintf (f, \"\\t%s\\t__%s_iname\\n\", ASM_GLOBAL, imp_name_lab);\n   fprintf (f, \"__%s_iname:\\t%s\\t\\\"%s\\\"\\n\",\n \t   imp_name_lab, ASM_TEXT, dll_name);\n@@ -3463,13 +3195,13 @@ identify_member_contains_symname (bfd  * abfd,\n }\n \n /* This is the main implementation for the --identify option.\n-   Given the name of an import library in identify_imp_name, first determine\n-   if the import library is a GNU binutils-style one (where the DLL name is\n-   stored in an .idata$7 (.idata$6 on PPC) section, or if it is a MS-style\n-   one (where the DLL name, along with much other data, is stored in the\n-   .idata$6 section). We determine the style of import library by searching\n-   for the DLL-structure symbol inserted by MS tools:\n-   __NULL_IMPORT_DESCRIPTOR.\n+   Given the name of an import library in identify_imp_name, first\n+   determine if the import library is a GNU binutils-style one (where\n+   the DLL name is stored in an .idata$7 section), or if it is a\n+   MS-style one (where the DLL name, along with much other data, is\n+   stored in the .idata$6 section).  We determine the style of import\n+   library by searching for the DLL-structure symbol inserted by MS\n+   tools: __NULL_IMPORT_DESCRIPTOR.\n \n    Once we know which section to search, evaluate each section for the\n    appropriate properties that indicate it may contain the name of the\n@@ -3629,19 +3361,13 @@ identify_search_member (bfd  *abfd,\n }\n \n /* This predicate returns true if section->name matches the desired value.\n-   By default, this is .idata$7 (.idata$6 on PPC, or if the import\n-   library is ms-style).  */\n+   By default, this is .idata$7 (.idata$6 if the import library is\n+   ms-style).  */\n \n static bfd_boolean\n identify_process_section_p (asection * section, bfd_boolean ms_style_implib)\n {\n-  static const char * SECTION_NAME =\n-#ifdef DLLTOOL_PPC\n-  /* dllname is stored in idata$6 on PPC */\n-  \".idata$6\";\n-#else\n-  \".idata$7\";\n-#endif\n+  static const char * SECTION_NAME = \".idata$7\";\n   static const char * MS_SECTION_NAME = \".idata$6\";\n \n   const char * section_name =\n@@ -3652,7 +3378,7 @@ identify_process_section_p (asection * section, bfd_boolean ms_style_implib)\n   return FALSE;\n }\n \n-/* If *section has contents and its name is .idata$7 (.data$6 on PPC or if\n+/* If *section has contents and its name is .idata$7 (.idata$6 if\n    import lib ms-generated) -- and it satisfies several other constraints\n    -- then add the contents of the section to obj->list.  */\n \n@@ -3938,7 +3664,7 @@ usage (FILE *file, int status)\n   fprintf (file, _(\"Usage %s <option(s)> <object-file(s)>\\n\"), program_name);\n   /* xgetext:c-format */\n   fprintf (file, _(\"   -m --machine <machine>    Create as DLL for <machine>.  [default: %s]\\n\"), mname);\n-  fprintf (file, _(\"        possible <machine>: arm[_interwork], i386, mcore[-elf]{-le|-be}, ppc, thumb\\n\"));\n+  fprintf (file, _(\"        possible <machine>: arm[_interwork], i386, mcore[-elf]{-le|-be}, thumb\\n\"));\n   fprintf (file, _(\"   -e --output-exp <outname> Generate an export file.\\n\"));\n   fprintf (file, _(\"   -l --output-lib <outname> Generate an interface library.\\n\"));\n   fprintf (file, _(\"   -y --output-delaylib <outname> Create a delay-import library.\\n\"));\n@@ -4372,7 +4098,7 @@ look_for_prog (const char *prog_name, const char *prefix, int end_prefix)\n /* Deduce the name of the program we are want to invoke.\n    PROG_NAME is the basic name of the program we want to run,\n    eg \"as\" or \"ld\".  The catch is that we might want actually\n-   run \"i386-pe-as\" or \"ppc-pe-ld\".\n+   run \"i386-pe-as\".\n \n    If argv[0] contains the full path, then try to find the program\n    in the same place, with and then without a target-like prefix."
    },
    {
      "sha": "0b73294e4f579aae8ae30d1b434094dc64e3586d",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -1,3 +1,13 @@\n+2020-07-09  Alan Modra  <amodra@gmail.com>\n+\n+\t* config/obj-coff.h: Remove TE_PE support.\n+\t* config/tc-ppc.c: Likewise.\n+\t* config/tc-ppc.h: Likewise.\n+\t* configure.tgt: Remove powerpc PE and powerpc lynxos.\n+\t* testsuite/gas/cfi/cfi.exp (cfi-common-6): Remove powerpc PE\n+\tcondition.\n+\t* testsuite/gas/macros/macros.exp: Don't xfail powerpc PE.\n+\n 2020-07-08  Jan Beulich  <jbeulich@suse.com>\n \n \t* testsuite/gas/i386/fma4-lig.d, testsuite/gas/i386/xop-lig.d:"
    },
    {
      "sha": "50da333892174390690900c59b44d1437857a67d",
      "filename": "gas/config/obj-coff.h",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/config/obj-coff.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/config/obj-coff.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/obj-coff.h?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -41,12 +41,8 @@\n #endif\n \n #ifdef TC_PPC\n-#ifdef TE_PE\n-#include \"coff/powerpc.h\"\n-#else\n #include \"coff/rs6000.h\"\n #endif\n-#endif\n \n #ifdef TC_I386\n #ifdef TE_PEP"
    },
    {
      "sha": "1000b618f6df62aa22bfdaffcdad11d06846724e",
      "filename": "gas/config/tc-ppc.c",
      "status": "modified",
      "additions": 14,
      "deletions": 862,
      "changes": 876,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/config/tc-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/config/tc-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ppc.c?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -31,10 +31,6 @@\n #include \"dwarf2dbg.h\"\n #endif\n \n-#ifdef TE_PE\n-#include \"coff/pe.h\"\n-#endif\n-\n #ifdef OBJ_XCOFF\n #include \"coff/xcoff.h\"\n #include \"libxcoff.h\"\n@@ -50,12 +46,8 @@ static int set_target_endian = 0;\n \n /* Whether to use user friendly register names.  */\n #ifndef TARGET_REG_NAMES_P\n-#ifdef TE_PE\n-#define TARGET_REG_NAMES_P TRUE\n-#else\n #define TARGET_REG_NAMES_P FALSE\n #endif\n-#endif\n \n /* Macros for calculating LO, HI, HA, HIGHER, HIGHERA, HIGHEST,\n    HIGHESTA.  */\n@@ -135,20 +127,6 @@ static void ppc_elf_localentry (int);\n static void ppc_elf_abiversion (int);\n static void ppc_elf_gnu_attribute (int);\n #endif\n-\n-#ifdef TE_PE\n-static void ppc_previous (int);\n-static void ppc_pdata (int);\n-static void ppc_ydata (int);\n-static void ppc_reldata (int);\n-static void ppc_rdata (int);\n-static void ppc_ualong (int);\n-static void ppc_znop (int);\n-static void ppc_pe_comm (int);\n-static void ppc_pe_section (int);\n-static void ppc_pe_function (int);\n-static void ppc_pe_tocd (int);\n-#endif\n \f\n /* Generic assembler global variables which must be defined by all\n    targets.  */\n@@ -274,22 +252,6 @@ const pseudo_typeS md_pseudo_table[] =\n   { \"gnu_attribute\", ppc_elf_gnu_attribute, 0},\n #endif\n \n-#ifdef TE_PE\n-  /* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format.  */\n-  { \"previous\", ppc_previous,   0 },\n-  { \"pdata\",    ppc_pdata,      0 },\n-  { \"ydata\",    ppc_ydata,      0 },\n-  { \"reldata\",  ppc_reldata,    0 },\n-  { \"rdata\",    ppc_rdata,      0 },\n-  { \"ualong\",   ppc_ualong,     0 },\n-  { \"znop\",     ppc_znop,       0 },\n-  { \"comm\",\tppc_pe_comm,\t0 },\n-  { \"lcomm\",\tppc_pe_comm,\t1 },\n-  { \"section\",  ppc_pe_section, 0 },\n-  { \"function\",\tppc_pe_function,0 },\n-  { \"tocd\",     ppc_pe_tocd,    0 },\n-#endif\n-\n #if defined (OBJ_XCOFF) || defined (OBJ_ELF)\n   { \"tc\",\tppc_tc,\t\t0 },\n   { \"machine\",  ppc_machine,    0 },\n@@ -1095,21 +1057,6 @@ static struct dw_section {\n } dw_sections[XCOFF_DWSECT_NBR_NAMES];\n #endif /* OBJ_XCOFF */\n \n-#ifdef TE_PE\n-\n-/* Various sections that we need for PE coff support.  */\n-static segT ydata_section;\n-static segT pdata_section;\n-static segT reldata_section;\n-static segT rdata_section;\n-static segT tocdata_section;\n-\n-/* The current section and the previous section. See ppc_previous.  */\n-static segT ppc_previous_section;\n-static segT ppc_current_section;\n-\n-#endif /* TE_PE */\n-\n #ifdef OBJ_ELF\n symbolS *GOT_symbol;\t\t/* Pre-defined \"_GLOBAL_OFFSET_TABLE\" */\n unsigned long *ppc_apuinfo_list;\n@@ -1552,9 +1499,7 @@ extern const char*\n ppc_target_format (void)\n {\n #ifdef OBJ_COFF\n-#ifdef TE_PE\n-  return target_big_endian ? \"pe-powerpc\" : \"pe-powerpcle\";\n-#elif TE_POWERMAC\n+#if TE_POWERMAC\n   return \"xcoff-powermac\";\n #else\n #  ifdef TE_AIX5\n@@ -1950,13 +1895,6 @@ md_begin (void)\n   ppc_data_csects = symbol_make (\"dummy\\001\");\n   symbol_get_tc (ppc_data_csects)->within = ppc_data_csects;\n #endif\n-\n-#ifdef TE_PE\n-\n-  ppc_current_section = text_section;\n-  ppc_previous_section = 0;\n-\n-#endif\n }\n \n void\n@@ -2738,101 +2676,6 @@ ppc_elf_adjust_symtab (void)\n }\n #endif /* OBJ_ELF */\n \f\n-#ifdef TE_PE\n-\n-/*\n- * Summary of parse_toc_entry.\n- *\n- * in:\tInput_line_pointer points to the '[' in one of:\n- *\n- *        [toc] [tocv] [toc32] [toc64]\n- *\n- *      Anything else is an error of one kind or another.\n- *\n- * out:\n- *   return value: success or failure\n- *   toc_kind:     kind of toc reference\n- *   input_line_pointer:\n- *     success: first char after the ']'\n- *     failure: unchanged\n- *\n- * settings:\n- *\n- *     [toc]   - rv == success, toc_kind = default_toc\n- *     [tocv]  - rv == success, toc_kind = data_in_toc\n- *     [toc32] - rv == success, toc_kind = must_be_32\n- *     [toc64] - rv == success, toc_kind = must_be_64\n- *\n- */\n-\n-enum toc_size_qualifier\n-{\n-  default_toc, /* The toc cell constructed should be the system default size */\n-  data_in_toc, /* This is a direct reference to a toc cell                   */\n-  must_be_32,  /* The toc cell constructed must be 32 bits wide              */\n-  must_be_64   /* The toc cell constructed must be 64 bits wide              */\n-};\n-\n-static int\n-parse_toc_entry (enum toc_size_qualifier *toc_kind)\n-{\n-  char *start;\n-  char *toc_spec;\n-  char c;\n-  enum toc_size_qualifier t;\n-\n-  /* Save the input_line_pointer.  */\n-  start = input_line_pointer;\n-\n-  /* Skip over the '[' , and whitespace.  */\n-  ++input_line_pointer;\n-  SKIP_WHITESPACE ();\n-\n-  /* Find the spelling of the operand.  */\n-  c = get_symbol_name (&toc_spec);\n-\n-  if (strcmp (toc_spec, \"toc\") == 0)\n-    {\n-      t = default_toc;\n-    }\n-  else if (strcmp (toc_spec, \"tocv\") == 0)\n-    {\n-      t = data_in_toc;\n-    }\n-  else if (strcmp (toc_spec, \"toc32\") == 0)\n-    {\n-      t = must_be_32;\n-    }\n-  else if (strcmp (toc_spec, \"toc64\") == 0)\n-    {\n-      t = must_be_64;\n-    }\n-  else\n-    {\n-      as_bad (_(\"syntax error: invalid toc specifier `%s'\"), toc_spec);\n-      *input_line_pointer = c;\n-      input_line_pointer = start;\n-      return 0;\n-    }\n-\n-  /* Now find the ']'.  */\n-  *input_line_pointer = c;\n-\n-  SKIP_WHITESPACE_AFTER_NAME ();\t/* leading whitespace could be there.  */\n-  c = *input_line_pointer++; /* input_line_pointer->past char in c.  */\n-\n-  if (c != ']')\n-    {\n-      as_bad (_(\"syntax error: expected `]', found  `%c'\"), c);\n-      input_line_pointer = start;\n-      return 0;\n-    }\n-\n-  *toc_kind = t;\n-  return 1;\n-}\n-#endif\n-\n #if defined (OBJ_XCOFF) || defined (OBJ_ELF)\n /* See whether a symbol is in the TOC section.  */\n \n@@ -2997,7 +2840,7 @@ fixup_size (bfd_reloc_code_real_type reloc, bfd_boolean *pc_relative)\n       /* This switch statement must handle all BFD_RELOC values\n \t possible in instruction fixups.  As is, it handles all\n \t BFD_RELOC values used in bfd/elf64-ppc.c, bfd/elf32-ppc.c,\n-\t bfd/coff-ppc, bfd/coff-rs6000.c and bfd/coff64-rs6000.c.\n+\t bfd/coff-rs6000.c and bfd/coff64-rs6000.c.\n \t Overkill since data and marker relocs need not be handled\n \t here, but this way we can be sure a needed fixup reloc isn't\n \t accidentally omitted.  */\n@@ -3135,9 +2978,7 @@ fixup_size (bfd_reloc_code_real_type reloc, bfd_boolean *pc_relative)\n       pcrel = TRUE;\n       break;\n \n-    case BFD_RELOC_16_GOT_PCREL: /* coff reloc, bad name re size.  */\n     case BFD_RELOC_32:\n-    case BFD_RELOC_32_GOTOFF:\n     case BFD_RELOC_32_PLTOFF:\n #ifdef OBJ_XCOFF\n     case BFD_RELOC_CTOR:\n@@ -3435,137 +3276,22 @@ md_assemble (char *str)\n       hold = input_line_pointer;\n       input_line_pointer = str;\n \n-#ifdef TE_PE\n-      if (*input_line_pointer == '[')\n+      if ((reg_names_p\n+\t   && (((operand->flags & PPC_OPERAND_CR_BIT) != 0)\n+\t       || ((operand->flags & PPC_OPERAND_CR_REG) != 0)))\n+\t  || !register_name (&ex))\n \t{\n-\t  /* We are expecting something like the second argument here:\n-\t   *\n-\t   *    lwz r4,[toc].GS.0.static_int(rtoc)\n-\t   *           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\t   * The argument following the `]' must be a symbol name, and the\n-\t   * register must be the toc register: 'rtoc' or '2'\n-\t   *\n-\t   * The effect is to 0 as the displacement field\n-\t   * in the instruction, and issue an IMAGE_REL_PPC_TOCREL16 (or\n-\t   * the appropriate variation) reloc against it based on the symbol.\n-\t   * The linker will build the toc, and insert the resolved toc offset.\n-\t   *\n-\t   * Note:\n-\t   * o The size of the toc entry is currently assumed to be\n-\t   *   32 bits. This should not be assumed to be a hard coded\n-\t   *   number.\n-\t   * o In an effort to cope with a change from 32 to 64 bits,\n-\t   *   there are also toc entries that are specified to be\n-\t   *   either 32 or 64 bits:\n-\t   *     lwz r4,[toc32].GS.0.static_int(rtoc)\n-\t   *     lwz r4,[toc64].GS.0.static_int(rtoc)\n-\t   *   These demand toc entries of the specified size, and the\n-\t   *   instruction probably requires it.\n-\t   */\n-\n-\t  int valid_toc;\n-\t  enum toc_size_qualifier toc_kind;\n-\t  bfd_reloc_code_real_type toc_reloc;\n-\n-\t  /* Go parse off the [tocXX] part.  */\n-\t  valid_toc = parse_toc_entry (&toc_kind);\n-\n-\t  if (!valid_toc)\n-\t    {\n-\t      ignore_rest_of_line ();\n-\t      break;\n-\t    }\n-\n-\t  /* Now get the symbol following the ']'.  */\n-\t  expression (&ex);\n+\t  char save_lex = lex_type['%'];\n \n-\t  switch (toc_kind)\n+\t  if (((operand->flags & PPC_OPERAND_CR_REG) != 0)\n+\t      || (operand->flags & PPC_OPERAND_CR_BIT) != 0)\n \t    {\n-\t    case default_toc:\n-\t      /* In this case, we may not have seen the symbol yet,\n-\t\t since  it is allowed to appear on a .extern or .globl\n-\t\t or just be a label in the .data section.  */\n-\t      toc_reloc = BFD_RELOC_PPC_TOC16;\n-\t      break;\n-\t    case data_in_toc:\n-\t      /* 1. The symbol must be defined and either in the toc\n-\t\t section, or a global.\n-\t\t 2. The reloc generated must have the TOCDEFN flag set\n-\t\t in upper bit mess of the reloc type.\n-\t\t FIXME: It's a little confusing what the tocv\n-\t\t qualifier can be used for.  At the very least, I've\n-\t\t seen three uses, only one of which I'm sure I can\n-\t\t explain.  */\n-\t      if (ex.X_op == O_symbol)\n-\t\t{\n-\t\t  gas_assert (ex.X_add_symbol != NULL);\n-\t\t  if (symbol_get_bfdsym (ex.X_add_symbol)->section\n-\t\t      != tocdata_section)\n-\t\t    {\n-\t\t      as_bad (_(\"[tocv] symbol is not a toc symbol\"));\n-\t\t    }\n-\t\t}\n-\n-\t      toc_reloc = BFD_RELOC_PPC_TOC16;\n-\t      break;\n-\t    case must_be_32:\n-\t      /* FIXME: these next two specifically specify 32/64 bit\n-\t\t toc entries.  We don't support them today.  Is this\n-\t\t the right way to say that?  */\n-\t      toc_reloc = BFD_RELOC_NONE;\n-\t      as_bad (_(\"unimplemented toc32 expression modifier\"));\n-\t      break;\n-\t    case must_be_64:\n-\t      /* FIXME: see above.  */\n-\t      toc_reloc = BFD_RELOC_NONE;\n-\t      as_bad (_(\"unimplemented toc64 expression modifier\"));\n-\t      break;\n-\t    default:\n-\t      fprintf (stderr,\n-\t\t       _(\"Unexpected return value [%d] from parse_toc_entry!\\n\"),\n-\t\t       toc_kind);\n-\t      abort ();\n-\t      break;\n-\t    }\n-\n-\t  /* We need to generate a fixup for this expression.  */\n-\t  if (fc >= MAX_INSN_FIXUPS)\n-\t    as_fatal (_(\"too many fixups\"));\n-\n-\t  fixups[fc].reloc = toc_reloc;\n-\t  fixups[fc].exp = ex;\n-\t  fixups[fc].opindex = *opindex_ptr;\n-\t  ++fc;\n-\n-\t  /* Ok. We've set up the fixup for the instruction. Now make it\n-\t     look like the constant 0 was found here.  */\n-\t  ex.X_unsigned = 1;\n-\t  ex.X_op = O_constant;\n-\t  ex.X_add_number = 0;\n-\t  ex.X_add_symbol = NULL;\n-\t  ex.X_op_symbol = NULL;\n-\t}\n-\n-      else\n-#endif\t\t/* TE_PE */\n-\t{\n-\t  if ((reg_names_p\n-               && (((operand->flags & PPC_OPERAND_CR_BIT) != 0)\n-\t\t   || ((operand->flags & PPC_OPERAND_CR_REG) != 0)))\n-\t      || !register_name (&ex))\n-\t    {\n-\t      char save_lex = lex_type['%'];\n-\n-\t      if (((operand->flags & PPC_OPERAND_CR_REG) != 0)\n-\t\t  || (operand->flags & PPC_OPERAND_CR_BIT) != 0)\n-\t\t{\n-\t\t  cr_operand = TRUE;\n-\t\t  lex_type['%'] |= LEX_BEGIN_NAME;\n-\t\t}\n-\t      expression (&ex);\n-\t      cr_operand = FALSE;\n-\t      lex_type['%'] = save_lex;\n+\t      cr_operand = TRUE;\n+\t      lex_type['%'] |= LEX_BEGIN_NAME;\n \t    }\n+\t  expression (&ex);\n+\t  cr_operand = FALSE;\n+\t  lex_type['%'] = save_lex;\n \t}\n \n       str = input_line_pointer;\n@@ -5764,574 +5490,6 @@ ppc_machine (int ignore ATTRIBUTE_UNUSED)\n }\n #endif /* defined (OBJ_XCOFF) || defined (OBJ_ELF) */\n \f\n-#ifdef TE_PE\n-\n-/* Pseudo-ops specific to the Windows NT PowerPC PE (coff) format.  */\n-\n-/* Set the current section.  */\n-static void\n-ppc_set_current_section (segT new)\n-{\n-  ppc_previous_section = ppc_current_section;\n-  ppc_current_section = new;\n-}\n-\n-/* pseudo-op: .previous\n-   behaviour: toggles the current section with the previous section.\n-   errors:    None\n-   warnings:  \"No previous section\"  */\n-\n-static void\n-ppc_previous (int ignore ATTRIBUTE_UNUSED)\n-{\n-  if (ppc_previous_section == NULL)\n-    {\n-      as_warn (_(\"no previous section to return to, ignored.\"));\n-      return;\n-    }\n-\n-  subseg_set (ppc_previous_section, 0);\n-\n-  ppc_set_current_section (ppc_previous_section);\n-}\n-\n-/* pseudo-op: .pdata\n-   behaviour: predefined read only data section\n-\t      double word aligned\n-   errors:    None\n-   warnings:  None\n-   initial:   .section .pdata \"adr3\"\n-\t      a - don't know -- maybe a misprint\n-\t      d - initialized data\n-\t      r - readable\n-\t      3 - double word aligned (that would be 4 byte boundary)\n-\n-   commentary:\n-   Tag index tables (also known as the function table) for exception\n-   handling, debugging, etc.  */\n-\n-static void\n-ppc_pdata (int ignore ATTRIBUTE_UNUSED)\n-{\n-  if (pdata_section == 0)\n-    {\n-      pdata_section = subseg_new (\".pdata\", 0);\n-\n-      bfd_set_section_flags (pdata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t\t\t     | SEC_READONLY | SEC_DATA));\n-\n-      bfd_set_section_alignment (pdata_section, 2);\n-    }\n-  else\n-    {\n-      pdata_section = subseg_new (\".pdata\", 0);\n-    }\n-  ppc_set_current_section (pdata_section);\n-}\n-\n-/* pseudo-op: .ydata\n-   behaviour: predefined read only data section\n-\t      double word aligned\n-   errors:    None\n-   warnings:  None\n-   initial:   .section .ydata \"drw3\"\n-\t      a - don't know -- maybe a misprint\n-\t      d - initialized data\n-\t      r - readable\n-\t      3 - double word aligned (that would be 4 byte boundary)\n-   commentary:\n-   Tag tables (also known as the scope table) for exception handling,\n-   debugging, etc.  */\n-\n-static void\n-ppc_ydata (int ignore ATTRIBUTE_UNUSED)\n-{\n-  if (ydata_section == 0)\n-    {\n-      ydata_section = subseg_new (\".ydata\", 0);\n-      bfd_set_section_flags (ydata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t\t\t     | SEC_READONLY | SEC_DATA ));\n-\n-      bfd_set_section_alignment (ydata_section, 3);\n-    }\n-  else\n-    {\n-      ydata_section = subseg_new (\".ydata\", 0);\n-    }\n-  ppc_set_current_section (ydata_section);\n-}\n-\n-/* pseudo-op: .reldata\n-   behaviour: predefined read write data section\n-\t      double word aligned (4-byte)\n-\t      FIXME: relocation is applied to it\n-\t      FIXME: what's the difference between this and .data?\n-   errors:    None\n-   warnings:  None\n-   initial:   .section .reldata \"drw3\"\n-\t      d - initialized data\n-\t      r - readable\n-\t      w - writable\n-\t      3 - double word aligned (that would be 8 byte boundary)\n-\n-   commentary:\n-   Like .data, but intended to hold data subject to relocation, such as\n-   function descriptors, etc.  */\n-\n-static void\n-ppc_reldata (int ignore ATTRIBUTE_UNUSED)\n-{\n-  if (reldata_section == 0)\n-    {\n-      reldata_section = subseg_new (\".reldata\", 0);\n-\n-      bfd_set_section_flags (reldata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t\t\t       | SEC_DATA));\n-\n-      bfd_set_section_alignment (reldata_section, 2);\n-    }\n-  else\n-    {\n-      reldata_section = subseg_new (\".reldata\", 0);\n-    }\n-  ppc_set_current_section (reldata_section);\n-}\n-\n-/* pseudo-op: .rdata\n-   behaviour: predefined read only data section\n-\t      double word aligned\n-   errors:    None\n-   warnings:  None\n-   initial:   .section .rdata \"dr3\"\n-\t      d - initialized data\n-\t      r - readable\n-\t      3 - double word aligned (that would be 4 byte boundary)  */\n-\n-static void\n-ppc_rdata (int ignore ATTRIBUTE_UNUSED)\n-{\n-  if (rdata_section == 0)\n-    {\n-      rdata_section = subseg_new (\".rdata\", 0);\n-      bfd_set_section_flags (rdata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t\t\t     | SEC_READONLY | SEC_DATA ));\n-\n-      bfd_set_section_alignment (rdata_section, 2);\n-    }\n-  else\n-    {\n-      rdata_section = subseg_new (\".rdata\", 0);\n-    }\n-  ppc_set_current_section (rdata_section);\n-}\n-\n-/* pseudo-op: .ualong\n-   behaviour: much like .int, with the exception that no alignment is\n-\t      performed.\n-\t      FIXME: test the alignment statement\n-   errors:    None\n-   warnings:  None  */\n-\n-static void\n-ppc_ualong (int ignore ATTRIBUTE_UNUSED)\n-{\n-  /* Try for long.  */\n-  cons (4);\n-}\n-\n-/* pseudo-op: .znop  <symbol name>\n-   behaviour: Issue a nop instruction\n-\t      Issue a IMAGE_REL_PPC_IFGLUE relocation against it, using\n-\t      the supplied symbol name.\n-   errors:    None\n-   warnings:  Missing symbol name  */\n-\n-static void\n-ppc_znop (int ignore ATTRIBUTE_UNUSED)\n-{\n-  unsigned long insn;\n-  const struct powerpc_opcode *opcode;\n-  char *f;\n-  symbolS *sym;\n-  char *symbol_name;\n-  char c;\n-  char *name;\n-\n-  /* Strip out the symbol name.  */\n-  c = get_symbol_name (&symbol_name);\n-\n-  name = xstrdup (symbol_name);\n-\n-  sym = symbol_find_or_make (name);\n-\n-  *input_line_pointer = c;\n-\n-  SKIP_WHITESPACE_AFTER_NAME ();\n-\n-  /* Look up the opcode in the hash table.  */\n-  opcode = (const struct powerpc_opcode *) hash_find (ppc_hash, \"nop\");\n-\n-  /* Stick in the nop.  */\n-  insn = opcode->opcode;\n-\n-  /* Write out the instruction.  */\n-  f = frag_more (4);\n-  md_number_to_chars (f, insn, 4);\n-  fix_new (frag_now,\n-\t   f - frag_now->fr_literal,\n-\t   4,\n-\t   sym,\n-\t   0,\n-\t   0,\n-\t   BFD_RELOC_16_GOT_PCREL);\n-\n-}\n-\n-/* pseudo-op:\n-   behaviour:\n-   errors:\n-   warnings:  */\n-\n-static void\n-ppc_pe_comm (int lcomm)\n-{\n-  char *name;\n-  char c;\n-  char *p;\n-  offsetT temp;\n-  symbolS *symbolP;\n-  offsetT align;\n-\n-  c = get_symbol_name (&name);\n-\n-  /* just after name is now '\\0'.  */\n-  p = input_line_pointer;\n-  *p = c;\n-  SKIP_WHITESPACE_AFTER_NAME ();\n-  if (*input_line_pointer != ',')\n-    {\n-      as_bad (_(\"expected comma after symbol-name: rest of line ignored.\"));\n-      ignore_rest_of_line ();\n-      return;\n-    }\n-\n-  input_line_pointer++;\t\t/* skip ',' */\n-  if ((temp = get_absolute_expression ()) < 0)\n-    {\n-      as_warn (_(\".COMMon length (%ld.) <0! Ignored.\"), (long) temp);\n-      ignore_rest_of_line ();\n-      return;\n-    }\n-\n-  if (! lcomm)\n-    {\n-      /* The third argument to .comm is the alignment.  */\n-      if (*input_line_pointer != ',')\n-\talign = 3;\n-      else\n-\t{\n-\t  ++input_line_pointer;\n-\t  align = get_absolute_expression ();\n-\t  if (align <= 0)\n-\t    {\n-\t      as_warn (_(\"ignoring bad alignment\"));\n-\t      align = 3;\n-\t    }\n-\t}\n-    }\n-\n-  *p = 0;\n-  symbolP = symbol_find_or_make (name);\n-\n-  *p = c;\n-  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))\n-    {\n-      as_bad (_(\"ignoring attempt to re-define symbol `%s'.\"),\n-\t      S_GET_NAME (symbolP));\n-      ignore_rest_of_line ();\n-      return;\n-    }\n-\n-  if (S_GET_VALUE (symbolP))\n-    {\n-      if (S_GET_VALUE (symbolP) != (valueT) temp)\n-\tas_bad (_(\"length of .comm \\\"%s\\\" is already %ld. Not changed to %ld.\"),\n-\t\tS_GET_NAME (symbolP),\n-\t\t(long) S_GET_VALUE (symbolP),\n-\t\t(long) temp);\n-    }\n-  else\n-    {\n-      S_SET_VALUE (symbolP, (valueT) temp);\n-      S_SET_EXTERNAL (symbolP);\n-      S_SET_SEGMENT (symbolP, bfd_com_section_ptr);\n-    }\n-\n-  demand_empty_rest_of_line ();\n-}\n-\n-/*\n- * implement the .section pseudo op:\n- *\t.section name {, \"flags\"}\n- *                ^         ^\n- *                |         +--- optional flags: 'b' for bss\n- *                |                              'i' for info\n- *                +-- section name               'l' for lib\n- *                                               'n' for noload\n- *                                               'o' for over\n- *                                               'w' for data\n- *\t\t\t\t\t\t 'd' (apparently m88k for data)\n- *                                               'x' for text\n- * But if the argument is not a quoted string, treat it as a\n- * subsegment number.\n- *\n- * FIXME: this is a copy of the section processing from obj-coff.c, with\n- * additions/changes for the moto-pas assembler support. There are three\n- * categories:\n- *\n- * FIXME: I just noticed this. This doesn't work at all really. It it\n- *        setting bits that bfd probably neither understands or uses. The\n- *        correct approach (?) will have to incorporate extra fields attached\n- *        to the section to hold the system specific stuff. (krk)\n- *\n- * Section Contents:\n- * 'a' - unknown - referred to in documentation, but no definition supplied\n- * 'c' - section has code\n- * 'd' - section has initialized data\n- * 'u' - section has uninitialized data\n- * 'i' - section contains directives (info)\n- * 'n' - section can be discarded\n- * 'R' - remove section at link time\n- *\n- * Section Protection:\n- * 'r' - section is readable\n- * 'w' - section is writable\n- * 'x' - section is executable\n- * 's' - section is sharable\n- *\n- * Section Alignment:\n- * '0' - align to byte boundary\n- * '1' - align to halfword boundary\n- * '2' - align to word boundary\n- * '3' - align to doubleword boundary\n- * '4' - align to quadword boundary\n- * '5' - align to 32 byte boundary\n- * '6' - align to 64 byte boundary\n- *\n- */\n-\n-void\n-ppc_pe_section (int ignore ATTRIBUTE_UNUSED)\n-{\n-  /* Strip out the section name.  */\n-  char *section_name;\n-  char c;\n-  char *name;\n-  unsigned int exp;\n-  flagword flags;\n-  segT sec;\n-  int align;\n-\n-  c = get_symbol_name (&section_name);\n-\n-  name = xstrdup (section_name);\n-\n-  *input_line_pointer = c;\n-\n-  SKIP_WHITESPACE_AFTER_NAME ();\n-\n-  exp = 0;\n-  flags = SEC_NO_FLAGS;\n-\n-  if (strcmp (name, \".idata$2\") == 0)\n-    {\n-      align = 0;\n-    }\n-  else if (strcmp (name, \".idata$3\") == 0)\n-    {\n-      align = 0;\n-    }\n-  else if (strcmp (name, \".idata$4\") == 0)\n-    {\n-      align = 2;\n-    }\n-  else if (strcmp (name, \".idata$5\") == 0)\n-    {\n-      align = 2;\n-    }\n-  else if (strcmp (name, \".idata$6\") == 0)\n-    {\n-      align = 1;\n-    }\n-  else\n-    /* Default alignment to 16 byte boundary.  */\n-    align = 4;\n-\n-  if (*input_line_pointer == ',')\n-    {\n-      ++input_line_pointer;\n-      SKIP_WHITESPACE ();\n-      if (*input_line_pointer != '\"')\n-\texp = get_absolute_expression ();\n-      else\n-\t{\n-\t  ++input_line_pointer;\n-\t  while (*input_line_pointer != '\"'\n-\t\t && ! is_end_of_line[(unsigned char) *input_line_pointer])\n-\t    {\n-\t      switch (*input_line_pointer)\n-\t\t{\n-\t\t  /* Section Contents */\n-\t\tcase 'a': /* unknown */\n-\t\t  as_bad (_(\"unsupported section attribute -- 'a'\"));\n-\t\t  break;\n-\t\tcase 'c': /* code section */\n-\t\t  flags |= SEC_CODE;\n-\t\t  break;\n-\t\tcase 'd': /* section has initialized data */\n-\t\t  flags |= SEC_DATA;\n-\t\t  break;\n-\t\tcase 'u': /* section has uninitialized data */\n-\t\t  /* FIXME: This is IMAGE_SCN_CNT_UNINITIALIZED_DATA\n-\t\t     in winnt.h */\n-\t\t  flags |= SEC_ROM;\n-\t\t  break;\n-\t\tcase 'i': /* section contains directives (info) */\n-\t\t  /* FIXME: This is IMAGE_SCN_LNK_INFO\n-\t\t     in winnt.h */\n-\t\t  flags |= SEC_HAS_CONTENTS;\n-\t\t  break;\n-\t\tcase 'n': /* section can be discarded */\n-\t\t  flags &=~ SEC_LOAD;\n-\t\t  break;\n-\t\tcase 'R': /* Remove section at link time */\n-\t\t  flags |= SEC_NEVER_LOAD;\n-\t\t  break;\n-#if IFLICT_BRAIN_DAMAGE\n-\t\t  /* Section Protection */\n-\t\tcase 'r': /* section is readable */\n-\t\t  flags |= IMAGE_SCN_MEM_READ;\n-\t\t  break;\n-\t\tcase 'w': /* section is writable */\n-\t\t  flags |= IMAGE_SCN_MEM_WRITE;\n-\t\t  break;\n-\t\tcase 'x': /* section is executable */\n-\t\t  flags |= IMAGE_SCN_MEM_EXECUTE;\n-\t\t  break;\n-\t\tcase 's': /* section is sharable */\n-\t\t  flags |= IMAGE_SCN_MEM_SHARED;\n-\t\t  break;\n-\n-\t\t  /* Section Alignment */\n-\t\tcase '0': /* align to byte boundary */\n-\t\t  flags |= IMAGE_SCN_ALIGN_1BYTES;\n-\t\t  align = 0;\n-\t\t  break;\n-\t\tcase '1':  /* align to halfword boundary */\n-\t\t  flags |= IMAGE_SCN_ALIGN_2BYTES;\n-\t\t  align = 1;\n-\t\t  break;\n-\t\tcase '2':  /* align to word boundary */\n-\t\t  flags |= IMAGE_SCN_ALIGN_4BYTES;\n-\t\t  align = 2;\n-\t\t  break;\n-\t\tcase '3':  /* align to doubleword boundary */\n-\t\t  flags |= IMAGE_SCN_ALIGN_8BYTES;\n-\t\t  align = 3;\n-\t\t  break;\n-\t\tcase '4':  /* align to quadword boundary */\n-\t\t  flags |= IMAGE_SCN_ALIGN_16BYTES;\n-\t\t  align = 4;\n-\t\t  break;\n-\t\tcase '5':  /* align to 32 byte boundary */\n-\t\t  flags |= IMAGE_SCN_ALIGN_32BYTES;\n-\t\t  align = 5;\n-\t\t  break;\n-\t\tcase '6':  /* align to 64 byte boundary */\n-\t\t  flags |= IMAGE_SCN_ALIGN_64BYTES;\n-\t\t  align = 6;\n-\t\t  break;\n-#endif\n-\t\tdefault:\n-\t\t  as_bad (_(\"unknown section attribute '%c'\"),\n-\t\t\t  *input_line_pointer);\n-\t\t  break;\n-\t\t}\n-\t      ++input_line_pointer;\n-\t    }\n-\t  if (*input_line_pointer == '\"')\n-\t    ++input_line_pointer;\n-\t}\n-    }\n-\n-  sec = subseg_new (name, (subsegT) exp);\n-\n-  ppc_set_current_section (sec);\n-\n-  if (flags != SEC_NO_FLAGS)\n-    {\n-      if (!bfd_set_section_flags (sec, flags))\n-\tas_bad (_(\"error setting flags for \\\"%s\\\": %s\"),\n-\t\tbfd_section_name (sec),\n-\t\tbfd_errmsg (bfd_get_error ()));\n-    }\n-\n-  bfd_set_section_alignment (sec, align);\n-}\n-\n-static void\n-ppc_pe_function (int ignore ATTRIBUTE_UNUSED)\n-{\n-  char *name;\n-  char endc;\n-  symbolS *ext_sym;\n-\n-  endc = get_symbol_name (&name);\n-\n-  ext_sym = symbol_find_or_make (name);\n-\n-  (void) restore_line_pointer (endc);\n-\n-  S_SET_DATA_TYPE (ext_sym, DT_FCN << N_BTSHFT);\n-  SF_SET_FUNCTION (ext_sym);\n-  SF_SET_PROCESS (ext_sym);\n-  coff_add_linesym (ext_sym);\n-\n-  demand_empty_rest_of_line ();\n-}\n-\n-static void\n-ppc_pe_tocd (int ignore ATTRIBUTE_UNUSED)\n-{\n-  if (tocdata_section == 0)\n-    {\n-      tocdata_section = subseg_new (\".tocd\", 0);\n-      /* FIXME: section flags won't work.  */\n-      bfd_set_section_flags (tocdata_section, (SEC_ALLOC | SEC_LOAD | SEC_RELOC\n-\t\t\t\t\t       | SEC_READONLY | SEC_DATA));\n-\n-      bfd_set_section_alignment (tocdata_section, 2);\n-    }\n-  else\n-    {\n-      rdata_section = subseg_new (\".tocd\", 0);\n-    }\n-\n-  ppc_set_current_section (tocdata_section);\n-\n-  demand_empty_rest_of_line ();\n-}\n-\n-/* Don't adjust TOC relocs to use the section symbol.  */\n-\n-int\n-ppc_pe_fix_adjustable (fixS *fix)\n-{\n-  return fix->fx_r_type != BFD_RELOC_PPC_TOC16;\n-}\n-\n-#endif\n-\f\n #ifdef OBJ_XCOFF\n \n /* XCOFF specific symbol and file handling.  */\n@@ -7074,8 +6232,6 @@ ppc_fix_adjustable (fixS *fix)\n \t  && fix->fx_r_type != BFD_RELOC_HI16_S_GOTOFF\n \t  && fix->fx_r_type != BFD_RELOC_PPC64_GOT16_DS\n \t  && fix->fx_r_type != BFD_RELOC_PPC64_GOT16_LO_DS\n-\t  && fix->fx_r_type != BFD_RELOC_16_GOT_PCREL\n-\t  && fix->fx_r_type != BFD_RELOC_32_GOTOFF\n \t  && fix->fx_r_type != BFD_RELOC_PPC64_GOT_PCREL34\n \t  && fix->fx_r_type != BFD_RELOC_24_PLT_PCREL\n \t  && fix->fx_r_type != BFD_RELOC_32_PLTOFF\n@@ -7928,16 +7084,12 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg)\n     fixP->fx_addnumber = 0;\n   else\n     {\n-#ifdef TE_PE\n-      fixP->fx_addnumber = 0;\n-#else\n       /* We want to use the offset within the toc, not the actual VMA\n \t of the symbol.  */\n       fixP->fx_addnumber = (- bfd_section_vma (S_GET_SEGMENT (fixP->fx_addsy))\n \t\t\t    - S_GET_VALUE (ppc_toc_csect));\n       /* Set *valP to avoid errors.  */\n       *valP = value;\n-#endif\n     }\n #endif\n }"
    },
    {
      "sha": "d887c053ff8d277db2755bec59ec6d9d3ba45d01",
      "filename": "gas/config/tc-ppc.h",
      "status": "modified",
      "additions": 1,
      "deletions": 17,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/config/tc-ppc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/config/tc-ppc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-ppc.h?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -30,15 +30,10 @@ struct fix;\n #define TARGET_BYTES_BIG_ENDIAN 1\n #endif\n \n-/* If OBJ_COFF is defined, and TE_PE is not defined, we are assembling\n-   XCOFF for AIX or PowerMac.  If TE_PE is defined, we are assembling\n-   COFF for Windows NT.  */\n-\n+/* If OBJ_COFF is defined we are assembling XCOFF for AIX or PowerMac.  */\n #ifdef OBJ_COFF\n-#ifndef TE_PE\n #define OBJ_XCOFF\n #endif\n-#endif\n \n /* The target BFD architecture.  */\n #define TARGET_ARCH (ppc_arch ())\n@@ -107,17 +102,6 @@ extern ppc_cpu_t ppc_cpu;\n #define TC_INIT_FIX_DATA(FIXP) \\\n   do { (FIXP)->tc_fix_data.ppc_cpu = ppc_cpu; } while (0)\n \f\n-#ifdef TE_PE\n-\n-/* Question marks are permitted in symbol names.  */\n-#define LEX_QM 1\n-\n-/* Don't adjust TOC relocs.  */\n-#define tc_fix_adjustable(FIX) ppc_pe_fix_adjustable (FIX)\n-extern int ppc_pe_fix_adjustable (struct fix *);\n-\n-#endif\n-\n #ifdef OBJ_XCOFF\n \n /* Declarations needed when generating XCOFF code.  XCOFF is an"
    },
    {
      "sha": "831ca901bae0c1673e3b683a6de2b601d8209742",
      "filename": "gas/configure.tgt",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/configure.tgt",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/configure.tgt",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/configure.tgt?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -342,8 +342,6 @@ case ${generic_target} in\n \n   pj*)\t\t\t\t\tfmt=elf ;;\n \n-  ppc-*-pe | ppc-*-cygwin*)\t\tfmt=coff em=pe ;;\n-  ppc-*-winnt*)\t\t\t\tfmt=coff em=pe ;;\n   ppc-*-aix5.[01])\t\t\tfmt=coff em=aix5 ;;\n   ppc-*-aix[5-9].*)\t\t\tfmt=coff em=aix5 ;;\n   ppc-*-aix*)\t\t\t\tfmt=coff em=aix ;;\n@@ -355,7 +353,6 @@ case ${generic_target} in\n   ppc-*-macos*)\t\t\t\tfmt=coff em=macos ;;\n   ppc-*-nto*)\t\t\t\tfmt=elf ;;\n   ppc-*-kaos*)\t\t\t\tfmt=elf ;;\n-  ppc-*-lynxos*)\t\t\tfmt=elf em=lynx ;;\n \n   pru-*-*)\t\t\t\tfmt=elf ;;\n "
    },
    {
      "sha": "8ec4ebcab3ca4c6f87c3638777eddd50107e8354",
      "filename": "gas/testsuite/gas/cfi/cfi.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/testsuite/gas/cfi/cfi.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/testsuite/gas/cfi/cfi.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/cfi/cfi.exp?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -127,8 +127,7 @@ if { ![istarget \"hppa64*-*\"] } then {\n     run_dump_test \"cfi-common-5\"\n   }\n   # Some targets don't support PC relative cfi directives\n-  if { ![istarget \"mips*-*\"] &&\n-       !([istarget powerpc*-*-*] && [is_pecoff_format]) } then {\n+  if { ![istarget \"mips*-*\"] } then {\n     run_dump_test \"cfi-common-6\"\n   }\n   run_dump_test \"cfi-common-7\""
    },
    {
      "sha": "e444486e214d476d27a0bdb3de0ffdecf0c09796",
      "filename": "gas/testsuite/gas/macros/macros.exp",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/testsuite/gas/macros/macros.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/gas/testsuite/gas/macros/macros.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/macros/macros.exp?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -57,7 +57,6 @@ if { ![istarget hppa*-*-*] || [istarget *-*-linux*] } {\n \n     # These fail due to NO_STRING_ESCAPES\n     setup_xfail \"powerpc*-*-aix*\" \"powerpc*-*-beos*\" \"powerpc*-*-macos*\"\n-    setup_xfail \"powerpc*-*-pe\" \"powerpc*-*-*win*\"\n     setup_xfail \"rs6000-*-*\"\n     setup_xfail \"z80-*-*\"\n "
    },
    {
      "sha": "1d7cafbe54d004830d2af4205580c9f301bb4442",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -1,3 +1,7 @@\n+2020-07-09  Alan Modra  <amodra@gmail.com>\n+\n+\t* coff/powerpc.h: Delete.\n+\n 2020-07-04  Nick Clifton  <nickc@redhat.com>\n \n \tBinutils 2.35 branch created."
    },
    {
      "sha": "ecc224369b8e06a59d5e0101948831e1d055c471",
      "filename": "include/coff/powerpc.h",
      "status": "removed",
      "additions": 0,
      "deletions": 57,
      "changes": 57,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c560184eb2074570988c498aaae494d0c4b00328/include/coff/powerpc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c560184eb2074570988c498aaae494d0c4b00328/include/coff/powerpc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/coff/powerpc.h?ref=c560184eb2074570988c498aaae494d0c4b00328",
      "patch": "@@ -1,57 +0,0 @@\n-/* Basic coff information for the PowerPC\n-   Based on coff/rs6000.h, coff/i386.h and others.\n-   \n-   Copyright (C) 2001-2020 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-   \n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-   \n-   You should have received a copy of the GNU General Public License\n-   along with this program; if not, write to the Free Software\n-   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,\n-   MA 02110-1301, USA.\n- \n-   Initial release: Kim Knuttila (krk@cygnus.com)  */\n-#define L_LNNO_SIZE 2\n-#define INCLUDE_COMDAT_FIELDS_IN_AUXENT\n-#include \"coff/external.h\"\n-\n-/* Bits for f_flags:\n- \tF_RELFLG\trelocation info stripped from file\n- \tF_EXEC\t\tfile is executable (no unresolved external references)\n- \tF_LNNO\t\tline numbers stripped from file\n- \tF_LSYMS\t\tlocal symbols stripped from file\n- \tF_AR32WR\tfile has byte ordering of an AR32WR machine (e.g. vax).  */\n-\n-#define F_RELFLG\t(0x0001)\n-#define F_EXEC\t\t(0x0002)\n-#define F_LNNO\t\t(0x0004)\n-#define F_LSYMS\t\t(0x0008)\n-\n-/* extra NT defines */\n-#define PPCMAGIC       0760         /* peeked on aa PowerPC Windows NT box */\n-\n-/* from winnt.h */\n-#define IMAGE_NT_OPTIONAL_HDR_MAGIC        0x10b\n-\n-#define PPCBADMAG(x) ((x).f_magic != PPCMAGIC) \n-\n-/********************** RELOCATION DIRECTIVES **********************/\n-\n-struct external_reloc\n-{\n-  char r_vaddr[4];\n-  char r_symndx[4];\n-  char r_type[2];\n-};\n-\n-#define RELOC struct external_reloc\n-#define RELSZ 10\n-"
    },
    {
      "sha": "14f31a805f5926ff93ad93caf4738997cfced90b",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -1,3 +1,15 @@\n+2020-07-09  Alan Modra  <amodra@gmail.com>\n+\n+\t* emulparams/ppcpe.sh: Delete.\n+\t* scripttempl/ppcpe.sc: Delete.\n+\t* emulparams/ppclynx.sh: Delete.\n+\t* Makefile.am (ALL_EMULATION_SOURCES): Remove ppc PE and lynxos.\n+\t* configure.tgt: Likewise.\n+\t* emultempl/beos.em: Remove powerpc PE support.\n+\t* emultempl/pe.em: Likewise.\n+\t* po/BLD-POTFILES.in: Regenerate.\n+\t* Makefile.in: Regenerate.\n+\n 2020-07-09  Alan Modra  <amodra@gmail.com>\n \n \t* testsuite/ld-gc/gc.exp: Don't set -mminimal-toc for powerpc64,"
    },
    {
      "sha": "38ff2d9bc0a98554bdfe2488e0e8868394757b26",
      "filename": "ld/Makefile.am",
      "status": "modified",
      "additions": 0,
      "deletions": 4,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/Makefile.am",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/Makefile.am",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/Makefile.am?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -342,9 +342,7 @@ ALL_EMULATION_SOURCES = \\\n \tepdp11.c \\\n \tepjelf.c \\\n \tepjlelf.c \\\n-\teppclynx.c \\\n \teppcmacos.c \\\n-\teppcpe.c \\\n \tepruelf.c \\\n \tescore3_elf.c \\\n \tescore7_elf.c \\\n@@ -828,9 +826,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES): $(GEN_DEPENDS)\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epdp11.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjelf.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjlelf.Pc@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppclynx.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcmacos.Pc@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcpe.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epruelf.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore3_elf.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore7_elf.Pc@am__quote@"
    },
    {
      "sha": "aaf322ddf38fa698028df6df1c5dfc458a57091e",
      "filename": "ld/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/Makefile.in?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -825,9 +825,7 @@ ALL_EMULATION_SOURCES = \\\n \tepdp11.c \\\n \tepjelf.c \\\n \tepjlelf.c \\\n-\teppclynx.c \\\n \teppcmacos.c \\\n-\teppcpe.c \\\n \tepruelf.c \\\n \tescore3_elf.c \\\n \tescore7_elf.c \\\n@@ -1440,9 +1438,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epdp11.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjelf.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjlelf.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppclynx.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcmacos.Po@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcpe.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epruelf.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore3_elf.Po@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore7_elf.Po@am__quote@\n@@ -2423,9 +2419,7 @@ $(ALL_EMULATION_SOURCES) $(ALL_64_EMULATION_SOURCES): $(GEN_DEPENDS)\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epdp11.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjelf.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epjlelf.Pc@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppclynx.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcmacos.Pc@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eppcpe.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/epruelf.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore3_elf.Pc@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/escore7_elf.Pc@am__quote@"
    },
    {
      "sha": "32f17d24026b91e8a6e7b995708d7ebd9c1f7f06",
      "filename": "ld/configure.tgt",
      "status": "modified",
      "additions": 0,
      "deletions": 6,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/configure.tgt",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/configure.tgt",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/configure.tgt?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -721,10 +721,6 @@ powerpcle-*-nto*)\ttarg_emul=elf32lppcnto\n powerpc-*-macos*)\ttarg_emul=ppcmacos\n \t\t\ttarg_extra_ofiles=\n \t\t\t;;\n-powerpcle-*-pe | powerpcle-*-winnt* | powerpcle-*-cygwin*)\n-\t\t\ttarg_emul=ppcpe\n-\t\t\ttarg_extra_ofiles=\"deffilep.o pe-dll.o\"\n-\t\t\t;;\n powerpc-*-aix[5-9]*)\ttarg_emul=aix5ppc\n \t\t\ttarg_extra_ofiles=\n \t\t\t;;\n@@ -736,8 +732,6 @@ powerpc-*-beos*)\ttarg_emul=aixppc\n \t\t\t;;\n powerpc-*-windiss*)\ttarg_emul=elf32ppcwindiss\n \t\t\t;;\n-powerpc-*-lynxos*)\ttarg_emul=ppclynx\n-\t\t\t;;\n pru*-*-*)\t\ttarg_emul=pruelf\n \t\t\t;;\n riscv32*-*-linux*)\ttarg_emul=elf32lriscv"
    },
    {
      "sha": "a58b5b047fc847e5e4a948e4f56bdc56b2db3089",
      "filename": "ld/emulparams/ppclynx.sh",
      "status": "removed",
      "additions": 0,
      "deletions": 12,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c560184eb2074570988c498aaae494d0c4b00328/ld/emulparams/ppclynx.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c560184eb2074570988c498aaae494d0c4b00328/ld/emulparams/ppclynx.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/ppclynx.sh?ref=c560184eb2074570988c498aaae494d0c4b00328",
      "patch": "@@ -1,12 +0,0 @@\n-source_sh ${srcdir}/emulparams/elf32ppc.sh\n-\n-TEXT_BASE=0x00002000\n-DYN_TEXT_BASE=0x00400000\n-TEXT_START_ADDR=\"(DEFINED(_DYNAMIC) ? ${DYN_TEXT_BASE} : ${TEXT_BASE})\"\n-case ${LD_FLAG} in\n-    n|N)\tTEXT_START_ADDR=0x1000 ;;\n-esac\n-ELF_INTERPRETER_NAME=\\\"/usr/lib/ld.so.1\\\"\n-\n-# Leave room of SIZEOF_HEADERS before text.\n-EMBEDDED="
    },
    {
      "sha": "ed7df88dcd262bc7e95505999fa63a497b0ef994",
      "filename": "ld/emulparams/ppcpe.sh",
      "status": "removed",
      "additions": 0,
      "deletions": 7,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c560184eb2074570988c498aaae494d0c4b00328/ld/emulparams/ppcpe.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c560184eb2074570988c498aaae494d0c4b00328/ld/emulparams/ppcpe.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emulparams/ppcpe.sh?ref=c560184eb2074570988c498aaae494d0c4b00328",
      "patch": "@@ -1,7 +0,0 @@\n-ARCH=powerpc\n-SCRIPT_NAME=ppcpe\n-OUTPUT_FORMAT=\"pei-powerpcle\"\n-TEMPLATE_NAME=pe\n-SUBSYSTEM=PE_DEF_SUBSYSTEM\n-INITIAL_SYMBOL_CHAR=\\\"_\\\"\n-TARGET_PAGE_SIZE=0x1000"
    },
    {
      "sha": "ace6e3a123ca1a4a0ab0f8fe86bd9b58e2e60294",
      "filename": "ld/emultempl/beos.em",
      "status": "modified",
      "additions": 1,
      "deletions": 20,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/emultempl/beos.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/emultempl/beos.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/beos.em?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -608,22 +608,6 @@ sort_sections (lang_statement_union_type *s)\n static void\n gld_${EMULATION_NAME}_before_allocation (void)\n {\n-#ifdef TARGET_IS_ppcpe\n-  /* Here we rummage through the found bfds to collect toc information */\n-  {\n-    LANG_FOR_EACH_INPUT_STATEMENT (is)\n-    {\n-      if (!ppc_process_before_allocation(is->the_bfd, &link_info))\n-\t{\n-\t  einfo (_(\"%P: errors encountered processing file %s\\n\"),\n-\t\t is->filename);\n-\t}\n-    }\n-  }\n-\n-  /* We have seen it all. Allocate it, and carry on */\n-  ppc_allocate_toc_section (&link_info);\n-#else\n #ifdef TARGET_IS_armpe\n   /* FIXME: we should be able to set the size of the interworking stub\n      section.\n@@ -645,7 +629,6 @@ gld_${EMULATION_NAME}_before_allocation (void)\n   /* We have seen it all. Allocate it, and carry on */\n   arm_allocate_interworking_sections (& link_info);\n #endif /* TARGET_IS_armpe */\n-#endif /* TARGET_IS_ppcpe */\n \n   sort_sections (stat_ptr->head);\n \n@@ -698,9 +681,7 @@ gld${EMULATION_NAME}_place_orphan (asection *s,\n   os = lang_output_section_statement_lookup (output_secname, constraint, TRUE);\n \n   /* Find the '\\$' wild statement for this section.  We currently require the\n-     linker script to explicitly mention \"*(.foo\\$)\".\n-     FIXME: ppcpe.sc has .CRT\\$foo in the .rdata section.  According to the\n-     Microsoft docs this isn't correct so it's not (currently) handled.  */\n+     linker script to explicitly mention \"*(.foo\\$)\".  */\n \n   ps[0] = '\\$';\n   ps[1] = 0;"
    },
    {
      "sha": "eb7c812470b41585f1bb26446a3528d42b6b7637",
      "filename": "ld/emultempl/pe.em",
      "status": "modified",
      "additions": 0,
      "deletions": 17,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/emultempl/pe.em",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/emultempl/pe.em",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/emultempl/pe.em?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -1741,23 +1741,6 @@ gld_${EMULATION_NAME}_after_open (void)\n static void\n gld_${EMULATION_NAME}_before_allocation (void)\n {\n-#ifdef TARGET_IS_ppcpe\n-  /* Here we rummage through the found bfds to collect toc information.  */\n-  {\n-    LANG_FOR_EACH_INPUT_STATEMENT (is)\n-      {\n-\tif (!ppc_process_before_allocation (is->the_bfd, &link_info))\n-\t  {\n-\t    /* xgettext:c-format */\n-\t    einfo (_(\"%P: errors encountered processing file %s\\n\"), is->filename);\n-\t  }\n-      }\n-  }\n-\n-  /* We have seen it all. Allocate it, and carry on.  */\n-  ppc_allocate_toc_section (&link_info);\n-#endif /* TARGET_IS_ppcpe */\n-\n #if defined(TARGET_IS_armpe) || defined(TARGET_IS_arm_wince_pe)\n   /* FIXME: we should be able to set the size of the interworking stub\n      section."
    },
    {
      "sha": "a954e775f69ee313720a14eb4ab86ab09a38b8c5",
      "filename": "ld/po/BLD-POTFILES.in",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/po/BLD-POTFILES.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/fe49679d5193f6ff7cfd333e30883d293112a3d1/ld/po/BLD-POTFILES.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/po/BLD-POTFILES.in?ref=fe49679d5193f6ff7cfd333e30883d293112a3d1",
      "patch": "@@ -262,9 +262,7 @@ epc532macha.c\n epdp11.c\n epjelf.c\n epjlelf.c\n-eppclynx.c\n eppcmacos.c\n-eppcpe.c\n epruelf.c\n escore3_elf.c\n escore7_elf.c"
    },
    {
      "sha": "d8e734b4df26fe5c602b3c2aa604561a8a00cd47",
      "filename": "ld/scripttempl/ppcpe.sc",
      "status": "removed",
      "additions": 0,
      "deletions": 208,
      "changes": 208,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c560184eb2074570988c498aaae494d0c4b00328/ld/scripttempl/ppcpe.sc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c560184eb2074570988c498aaae494d0c4b00328/ld/scripttempl/ppcpe.sc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/scripttempl/ppcpe.sc?ref=c560184eb2074570988c498aaae494d0c4b00328",
      "patch": "@@ -1,208 +0,0 @@\n-# A PE linker script for PowerPC.\n-# Loosely based on Steve Chamberlain's pe.sc.\n-# All new mistakes should be credited to Kim Knuttila (krk@cygnus.com)\n-#\n-# Copyright (C) 2014-2020 Free Software Foundation, Inc.\n-#\n-# Copying and distribution of this file, with or without modification,\n-# are permitted in any medium without royalty provided the copyright\n-# notice and this notice are preserved.\n-#\n-\n-cat <<EOF\n-/* Copyright (C) 2014-2020 Free Software Foundation, Inc.\n-\n-   Copying and distribution of this script, with or without modification,\n-   are permitted in any medium without royalty provided the copyright\n-   notice and this notice are preserved.  */\n-\n-OUTPUT_FORMAT(${OUTPUT_FORMAT})\n-${LIB_SEARCH_DIRS}\n-\n-/* Much of this layout was determined by delving into .exe files for\n-   the box generated by other compilers/linkers/etc. This means that\n-   if a particular feature did not happen to appear in one of the\n-   subject files, then it may not be yet supported.\n-*/\n-\n-/* It's \"mainCRTStartup\", not \"_mainCRTStartup\", and it's located in\n-   one of the two .lib files (libc.lib and kernel32.lib) that currently\n-   must be present on the link line. This means that you must use\n-   \"-u mainCRTStartup\" to make sure it gets included in the link.\n-*/\n-\n-${RELOCATING+ENTRY (mainCRTStartup)}\n-\n-SECTIONS\n-{\n-\n-  /* text - the usual meaning */\n-  .text ${RELOCATING+ __image_base__ + __section_alignment__ } :\n-\t{\n-\t    ${RELOCATING+ KEEP (*(SORT_NONE(.init)))}\n-\t    *(.text)\n-\t    ${RELOCATING+ *(.text.*)}\n-\t    *(.gcc_except_table)\n-\t    ${CONSTRUCTING+ ___CTOR_LIST__ = .; __CTOR_LIST__ = . ;\n-\t\t\tLONG (-1); *(.ctors); *(.ctor); LONG (0); }\n-\t    ${CONSTRUCTING+ ___DTOR_LIST__ = .; __DTOR_LIST__ = . ;\n-\t\t\tLONG (-1); *(.dtors); *(.dtor); LONG (0); }\n-\t    ${RELOCATING+ KEEP (*(SORT_NONE(.fini)))}\n-\t    ${RELOCATING+ etext = .};\n-\t}\n-\n-  /* rdata - Read Only Runtime Data\n-     CTR sections: All of the CRT (read only C runtime data) sections\n-\tappear at the start of the .rdata (read only runtime data)\n-\tsection, in the following order. Don't know if it matters or not.\n-\tNot all sections are always present either.\n-     .rdata: compiler generated read only data\n-     .xdata: compiler generated exception handling table. (Most docs\n-\tseem to suggest that this section is now deprecated infavor\n-\tof the ydata section)\n-     .edata: The exported names table.\n-  */\n-  .rdata BLOCK(__section_alignment__) :\n-\t{\n-\t    *(.CRT\\$XCA);\n-\t    *(.CRT\\$XCC);\n-\t    *(.CRT\\$XCZ);\n-\t    *(.CRT\\$XIA);\n-\t    *(.CRT\\$XIC);\n-\t    *(.CRT\\$XIZ);\n-\t    *(.CRT\\$XLA);\n-\t    *(.CRT\\$XLZ);\n-\t    *(.CRT\\$XPA);\n-\t    *(.CRT\\$XPX);\n-\t    *(.CRT\\$XPZ);\n-\t    *(.CRT\\$XTA);\n-\t    *(.CRT\\$XTZ);\n-\t    *(.rdata);\n-\t    *(.xdata);\n-\t}\n-\n-  .edata BLOCK(__section_alignment__) :\n-\t{\n-\t    *(.edata);\n-\t}\n-\n-  /* data - initialized data\n-     .ydata: exception handling information.\n-     .data: the usual meaning.\n-     .data2: more of the same.\n-     .bss: For some reason, bss appears to be included in the data\n-\tsection, as opposed to being given a section of it's own.\n-     COMMON:\n-  */\n-  .data BLOCK(__section_alignment__) :\n-\t{\n-\t    __data_start__ = . ;\n-\t    *(.ydata);\n-\t    *(.data);\n-\t    *(.data2);\n-\t    __bss_start__ = . ;\n-\t    *(.bss) ;\n-\t    *(COMMON);\n-\t    __bss_end__ = . ;\n-\t    ${RELOCATING+ end =  .};\n-\t    __data_end__ = . ;\n-\t}\n-\n-  /* The exception handling table. A sequence of 5 word entries. Section\n-     address and extent are placed in the DataDirectory.\n-  */\n-  .pdata BLOCK(__section_alignment__) :\n-\t{\n-\t    *(.pdata)\n-\t    ;\n-\t}\n-\n-  /* The idata section is chock full of magic bits.\n-\t1. Boundaries around various idata parts are used to initialize\n-\t   some of the fields of the DataDirectory. In particular, the\n-\t   magic for 2, 4 and 5 are known to be used. Some compilers\n-\t   appear to generate magic section symbols for this purpose.\n-\t   Where we can, we catch such symbols and use our own. This of\n-\t   course is something less than a perfect strategy.\n-\t2. The table of contents is placed immediately after idata4.\n-\t   The \".private.toc\" sections are generated by the ppc bfd. The\n-\t   .toc variable is generated by gas, and resolved here. It is\n-\t   used to initialized function descriptors (and anyone else who\n-\t   needs the address of the module's toc). The only thing\n-\t   interesting about it at all? Most ppc instructions using it\n-\t   have a 16bit displacement field. The convention for addressing\n-\t   is to initialize the .toc value to 32K past the start of the\n-\t   actual toc, and subtract 32K from all references, thus using\n-\t   the entire 64K range. Naturally, the reloc code must agree\n-\t   on this number or you get pretty stupid results.\n-  */\n-  .idata BLOCK(__section_alignment__) :\n-\t{\n-\t    __idata2_magic__ = .;\n-\t    *(.idata\\$2);\n-\t    __idata3_magic__ = .;\n-\t    *(.idata\\$3);\n-\t    __idata4_magic__ = .;\n-\t    *(.idata\\$4);\n-\t    . = ALIGN(4);\n-\t    .toc = . + 32768;\n-\t    *(.private.toc);\n-\t    __idata5_magic__ = .;\n-\t    *(.idata\\$5);\n-\t    __idata6_magic__ = .;\n-\t    *(.idata\\$6);\n-\t    __idata7_magic__ = .;\n-\t    *(.idata\\$7);\n-\t    ;\n-\t}\n-\n-  /* reldata -- data that requires relocation\n-  */\n-  .reldata BLOCK(__section_alignment__) :\n-\t{\n-\t    *(.reldata)\n-\t    ;\n-\t}\n-\n-\n-  /* Resources */\n-  .rsrc BLOCK(__section_alignment__) :\n-\t{\n-\t    *(.rsrc\\$01)\n-\t    *(.rsrc\\$02)\n-\t    ;\n-\t}\n-\n-  .stab BLOCK(__section_alignment__)  ${RELOCATING+(NOLOAD)} :\n-  {\n-    [ .stab ]\n-  }\n-\n-  .stabstr BLOCK(__section_alignment__) ${RELOCATING+(NOLOAD)} :\n-  {\n-    [ .stabstr ]\n-  }\n-\n-  /* The .reloc section is currently generated by the dlltool from Steve\n-     Chamberlain in a second pass of linking. Section address and extent\n-     are placed in the DataDirectory.\n-  */\n-  .reloc BLOCK(__section_alignment__) :\n-\t{\n-\t    *(.reloc)\n-\t    ;\n-\t}\n-\n-  /* We don't do anything useful with codeview debugger support or the\n-     directive section (yet). Hopefully, we junk them correctly.\n-  */\n-  /DISCARD/ BLOCK(__section_alignment__) :\n-\t{\n-\t    *(.debug\\$S)\n-\t    *(.debug\\$T)\n-\t    *(.debug\\$F)\n-\t    *(.drectve)\n-\t    ;\n-\t}\n-}\n-EOF"
    }
  ]
}