{
  "sha": "a008792038c2510800db466897c4bb6305d20042",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YTAwODc5MjAzOGMyNTEwODAwZGI0NjY4OTdjNGJiNjMwNWQyMDA0Mg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-02-07T13:23:40Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2019-02-17T15:35:14Z"
    },
    "message": "Fix pager bugs with style output\n\nI believe this fixes all the pager output problems with styling that\nPhilippe pointed out, plus at least one more.  The patch is somewhat\nhard to reason about, so you may wish to give it a try.  Even writing\nthe tests was hard.\n\nThis removes the style caching, because it was difficult to keep the\nstyle cache correct in all cases.  Since this would cause more style\nescapes to be emitted, instead it changes fputs_styled to try to avoid\nunnecessary changes.\n\nAnother bug was that the wrap buffer was not flushed in the case where\nwrap_column==0.  In the old (pre-patch series) code, characters were\ndirectly emitted in this case; so flushing the wrap buffer here\nrestores this behavior.\n\nOn error the wrap buffer must be emptied.  Otherwise, interrupting\noutput can leave characters in the buffer that will be emitted later.\n\nAs discussed on gdb-patches, this fixes the ada-lang.c problem where\nfiltered and unfiltered printing were mixed.  Now user_select_syms\nuses filtered printing, which is what its callees were already doing.\n\nFinally, it was possible for source line highlighting to be garbled\n(and invalid escape sequences emitted) if the pager was invoked at the\nwrong spot.  To fix this, the patch arranges for source line escapes\nto always be emitted as a unit.\n\ngdb/ChangeLog\n2019-02-17  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.c (user_select_syms): Use filtered printing.\n\t* utils.c (wrap_style): New global.\n\t(desired_style): Remove.\n\t(emit_style_escape): Add stream parameter.\n\t(set_output_style, reset_terminal_style, prompt_for_continue):\n\tUpdate.\n\t(flush_wrap_buffer): Only flush gdb_stdout.\n\t(wrap_here): Set wrap_style.\n\t(fputs_maybe_filtered): Clear the wrap buffer on exception.  Don't\n\ttreat escape sequences as a character.  Change when wrap buffer is\n\tflushed.\n\t(fputs_styled): Do not set the output style when the default is\n\trequested.\n\t* ui-style.h (struct ui_file_style) <is_default>: New method.\n\t* source.c (print_source_lines_base): Emit escape sequences in one\n\tpiece.\n\ngdb/testsuite/ChangeLog\n2019-02-17  Tom Tromey  <tom@tromey.com>\n\n\t* gdb.base/style.exp: Add line-wrapping tests.\n\t* gdb.base/page.exp: Add test for quitting during pagination.",
    "tree": {
      "sha": "a317ce9b81aa7874e144c6d08472a8344237b7d6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a317ce9b81aa7874e144c6d08472a8344237b7d6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/a008792038c2510800db466897c4bb6305d20042",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a008792038c2510800db466897c4bb6305d20042",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/a008792038c2510800db466897c4bb6305d20042",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a008792038c2510800db466897c4bb6305d20042/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "75ba10dc558a450c7dbcdc24f816f6709f2b29f7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/75ba10dc558a450c7dbcdc24f816f6709f2b29f7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/75ba10dc558a450c7dbcdc24f816f6709f2b29f7"
    }
  ],
  "stats": {
    "total": 268,
    "additions": 193,
    "deletions": 75
  },
  "files": [
    {
      "sha": "eb3bc0b7670b40b1748dab9a7ffab644f8c59907",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a008792038c2510800db466897c4bb6305d20042/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a008792038c2510800db466897c4bb6305d20042/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=a008792038c2510800db466897c4bb6305d20042",
      "patch": "@@ -1,3 +1,22 @@\n+2019-02-17  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.c (user_select_syms): Use filtered printing.\n+\t* utils.c (wrap_style): New global.\n+\t(desired_style): Remove.\n+\t(emit_style_escape): Add stream parameter.\n+\t(set_output_style, reset_terminal_style, prompt_for_continue):\n+\tUpdate.\n+\t(flush_wrap_buffer): Only flush gdb_stdout.\n+\t(wrap_here): Set wrap_style.\n+\t(fputs_maybe_filtered): Clear the wrap buffer on exception.  Don't\n+\ttreat escape sequences as a character.  Change when wrap buffer is\n+\tflushed.\n+\t(fputs_styled): Do not set the output style when the default is\n+\trequested.\n+\t* ui-style.h (struct ui_file_style) <is_default>: New method.\n+\t* source.c (print_source_lines_base): Emit escape sequences in one\n+\tpiece.\n+\n 2019-02-17  Joel Brobecker  <brobecker@adacore.com>\n \n \t* gdbtypes.c (type_align): Handle TYPE_CODE_RANGE the same as"
    },
    {
      "sha": "a6fadc846e318ffe97761ec0b6afb9978099a8ff",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 24,
      "deletions": 24,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a008792038c2510800db466897c4bb6305d20042/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a008792038c2510800db466897c4bb6305d20042/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=a008792038c2510800db466897c4bb6305d20042",
      "patch": "@@ -3903,16 +3903,16 @@ user_select_syms (struct block_symbol *syms, int nsyms, int max_results)\n     error (_(\"\\\n canceled because the command is ambiguous\\n\\\n See set/show multiple-symbol.\"));\n-  \n+\n   /* If select_mode is \"all\", then return all possible symbols.\n      Only do that if more than one symbol can be selected, of course.\n      Otherwise, display the menu as usual.  */\n   if (select_mode == multiple_symbols_all && max_results > 1)\n     return nsyms;\n \n-  printf_unfiltered (_(\"[0] cancel\\n\"));\n+  printf_filtered (_(\"[0] cancel\\n\"));\n   if (max_results > 1)\n-    printf_unfiltered (_(\"[1] all\\n\"));\n+    printf_filtered (_(\"[1] all\\n\"));\n \n   sort_choices (syms, nsyms);\n \n@@ -3926,16 +3926,16 @@ See set/show multiple-symbol.\"));\n           struct symtab_and_line sal =\n             find_function_start_sal (syms[i].symbol, 1);\n \n-\t  printf_unfiltered (\"[%d] \", i + first_choice);\n+\t  printf_filtered (\"[%d] \", i + first_choice);\n \t  ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n \t\t\t\t      &type_print_raw_options);\n \t  if (sal.symtab == NULL)\n-\t    printf_unfiltered (_(\" at <no source file available>:%d\\n\"),\n-\t\t\t       sal.line);\n+\t    printf_filtered (_(\" at <no source file available>:%d\\n\"),\n+\t\t\t     sal.line);\n \t  else\n-\t    printf_unfiltered (_(\" at %s:%d\\n\"),\n-\t\t\t       symtab_to_filename_for_display (sal.symtab),\n-\t\t\t       sal.line);\n+\t    printf_filtered (_(\" at %s:%d\\n\"),\n+\t\t\t     symtab_to_filename_for_display (sal.symtab),\n+\t\t\t     sal.line);\n           continue;\n         }\n       else\n@@ -3951,37 +3951,37 @@ See set/show multiple-symbol.\"));\n \n           if (SYMBOL_LINE (syms[i].symbol) != 0 && symtab != NULL)\n \t    {\n-\t      printf_unfiltered (\"[%d] \", i + first_choice);\n+\t      printf_filtered (\"[%d] \", i + first_choice);\n \t      ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n \t\t\t\t\t  &type_print_raw_options);\n-\t      printf_unfiltered (_(\" at %s:%d\\n\"),\n-\t\t\t\t symtab_to_filename_for_display (symtab),\n-\t\t\t\t SYMBOL_LINE (syms[i].symbol));\n+\t      printf_filtered (_(\" at %s:%d\\n\"),\n+\t\t\t       symtab_to_filename_for_display (symtab),\n+\t\t\t       SYMBOL_LINE (syms[i].symbol));\n \t    }\n           else if (is_enumeral\n                    && TYPE_NAME (SYMBOL_TYPE (syms[i].symbol)) != NULL)\n             {\n-              printf_unfiltered ((\"[%d] \"), i + first_choice);\n+              printf_filtered ((\"[%d] \"), i + first_choice);\n               ada_print_type (SYMBOL_TYPE (syms[i].symbol), NULL,\n                               gdb_stdout, -1, 0, &type_print_raw_options);\n-              printf_unfiltered (_(\"'(%s) (enumeral)\\n\"),\n-                                 SYMBOL_PRINT_NAME (syms[i].symbol));\n+              printf_filtered (_(\"'(%s) (enumeral)\\n\"),\n+\t\t\t       SYMBOL_PRINT_NAME (syms[i].symbol));\n             }\n \t  else\n \t    {\n-\t      printf_unfiltered (\"[%d] \", i + first_choice);\n+\t      printf_filtered (\"[%d] \", i + first_choice);\n \t      ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n \t\t\t\t\t  &type_print_raw_options);\n \n \t      if (symtab != NULL)\n-\t\tprintf_unfiltered (is_enumeral\n-\t\t\t\t   ? _(\" in %s (enumeral)\\n\")\n-\t\t\t\t   : _(\" at %s:?\\n\"),\n-\t\t\t\t   symtab_to_filename_for_display (symtab));\n+\t\tprintf_filtered (is_enumeral\n+\t\t\t\t ? _(\" in %s (enumeral)\\n\")\n+\t\t\t\t : _(\" at %s:?\\n\"),\n+\t\t\t\t symtab_to_filename_for_display (symtab));\n \t      else\n-\t\tprintf_unfiltered (is_enumeral\n-\t\t\t\t   ? _(\" (enumeral)\\n\")\n-\t\t\t\t   : _(\" at ?\\n\"));\n+\t\tprintf_filtered (is_enumeral\n+\t\t\t\t ? _(\" (enumeral)\\n\")\n+\t\t\t\t : _(\" at ?\\n\"));\n \t    }\n         }\n     }"
    },
    {
      "sha": "f99215f98103d8ed42fb19251479057b25897a8f",
      "filename": "gdb/source.c",
      "status": "modified",
      "additions": 40,
      "deletions": 22,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a008792038c2510800db466897c4bb6305d20042/gdb/source.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a008792038c2510800db466897c4bb6305d20042/gdb/source.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/source.c?ref=a008792038c2510800db466897c4bb6305d20042",
      "patch": "@@ -1249,7 +1249,6 @@ static void\n print_source_lines_base (struct symtab *s, int line, int stopline,\n \t\t\t print_source_lines_flags flags)\n {\n-  int c;\n   scoped_fd desc;\n   int noprint = 0;\n   int nlines = stopline - line;\n@@ -1343,13 +1342,10 @@ print_source_lines_base (struct symtab *s, int line, int stopline,\n \t   line, symtab_to_filename_for_display (s), s->nlines);\n \n   const char *iter = lines.c_str ();\n-  while (nlines-- > 0)\n+  while (nlines-- > 0 && *iter != '\\0')\n     {\n       char buf[20];\n \n-      c = *iter++;\n-      if (c == '\\0')\n-\tbreak;\n       last_line_listed = current_source_line;\n       if (flags & PRINT_SOURCE_LINES_FILENAME)\n         {\n@@ -1358,33 +1354,55 @@ print_source_lines_base (struct symtab *s, int line, int stopline,\n         }\n       xsnprintf (buf, sizeof (buf), \"%d\\t\", current_source_line++);\n       uiout->text (buf);\n-      do\n+\n+      while (*iter != '\\0')\n \t{\n-\t  if (c < 040 && c != '\\t' && c != '\\n' && c != '\\r' && c != '\\033')\n+\t  /* Find a run of characters that can be emitted at once.\n+\t     This is done so that escape sequences are kept\n+\t     together.  */\n+\t  const char *start = iter;\n+\t  while (true)\n \t    {\n-\t      xsnprintf (buf, sizeof (buf), \"^%c\", c + 0100);\n-\t      uiout->text (buf);\n+\t      int skip_bytes;\n+\n+\t      char c = *iter;\n+\t      if (c == '\\033' && skip_ansi_escape (iter, &skip_bytes))\n+\t\titer += skip_bytes;\n+\t      else if (c < 040 && c != '\\t')\n+\t\tbreak;\n+\t      else if (c == 0177)\n+\t\tbreak;\n+\t      else\n+\t\t++iter;\n \t    }\n-\t  else if (c == 0177)\n-\t    uiout->text (\"^?\");\n-\t  else if (c == '\\r')\n+\t  if (iter > start)\n \t    {\n-\t      /* Skip a \\r character, but only before a \\n.  */\n-\t      if (*iter != '\\n')\n-\t\tprintf_filtered (\"^%c\", c + 0100);\n+\t      std::string text (start, iter);\n+\t      uiout->text (text.c_str ());\n \t    }\n-\t  else\n+\t  if (*iter == '\\r')\n \t    {\n-\t      xsnprintf (buf, sizeof (buf), \"%c\", c);\n+\t      /* Treat either \\r or \\r\\n as a single newline.  */\n+\t      ++iter;\n+\t      if (*iter == '\\n')\n+\t\t++iter;\n+\t      break;\n+\t    }\n+\t  else if (*iter == '\\n')\n+\t    {\n+\t      ++iter;\n+\t      break;\n+\t    }\n+\t  else if (*iter > 0 && *iter < 040)\n+\t    {\n+\t      xsnprintf (buf, sizeof (buf), \"^%c\", *iter + 0100);\n \t      uiout->text (buf);\n \t    }\n+\t  else if (*iter == 0177)\n+\t    uiout->text (\"^?\");\n \t}\n-      while (c != '\\n' && (c = *iter++) != '\\0');\n-      if (c == '\\0')\n-\tbreak;\n+      uiout->text (\"\\n\");\n     }\n-  if (!lines.empty() && lines.back () != '\\n')\n-    uiout->text (\"\\n\");\n }\n \f\n "
    },
    {
      "sha": "88c6a6c2acfc68b5c4c768f237c6dff6db9b72d6",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a008792038c2510800db466897c4bb6305d20042/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a008792038c2510800db466897c4bb6305d20042/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=a008792038c2510800db466897c4bb6305d20042",
      "patch": "@@ -1,3 +1,8 @@\n+2019-02-17  Tom Tromey  <tom@tromey.com>\n+\n+\t* gdb.base/style.exp: Add line-wrapping tests.\n+\t* gdb.base/page.exp: Add test for quitting during pagination.\n+\n 2019-02-17  Joel Brobecker  <brobecker@adacore.com>\n \n \t* gdb.ada/big_packed_array: New testcase."
    },
    {
      "sha": "10ebf0d43b2e4fe74c8047efadd361641188196b",
      "filename": "gdb/testsuite/gdb.base/page.exp",
      "status": "modified",
      "additions": 14,
      "deletions": 0,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a008792038c2510800db466897c4bb6305d20042/gdb/testsuite/gdb.base/page.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a008792038c2510800db466897c4bb6305d20042/gdb/testsuite/gdb.base/page.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/page.exp?ref=a008792038c2510800db466897c4bb6305d20042",
      "patch": "@@ -80,6 +80,20 @@ gdb_expect_list \"paged count remainder\" \"${gdb_prompt} \" {\n     11\n }\n \n+set fours [string repeat 4 40]\n+set str \"1\\\\n2\\\\n3\\\\n$fours\\\\n5\\\\n\"\n+\n+# Avoid some confusing output from readline.\n+gdb_test_no_output \"set editing off\"\n+\n+gdb_test_no_output \"set width 30\"\n+send_gdb \"printf \\\"$str\\\"\\n\"\n+gdb_expect_list \"paged count for interrupt\" \\\n+    \".*$pagination_prompt\" \\\n+    [list 1\\r\\n 2\\r\\n 3\\r\\n 444444444444444444444444444444]\n+\n+gdb_test \"q\" \"Quit\" \"quit while paging\"\n+\n gdb_exit\n return 0\n "
    },
    {
      "sha": "010d9592f343aff56656f074e70ea7a50b74afaa",
      "filename": "gdb/testsuite/gdb.base/style.exp",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a008792038c2510800db466897c4bb6305d20042/gdb/testsuite/gdb.base/style.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a008792038c2510800db466897c4bb6305d20042/gdb/testsuite/gdb.base/style.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/style.exp?ref=a008792038c2510800db466897c4bb6305d20042",
      "patch": "@@ -45,6 +45,24 @@ save_vars { env(TERM) } {\n \n     gdb_test \"print &main\" \" = .* \\033\\\\\\[34m$hex\\033\\\\\\[m <$main_expr>\"\n \n+    # Regression test for a bug where line-wrapping would occur at the\n+    # wrong spot with styling.  There were different bugs at different\n+    # widths, so try two.\n+    foreach width {20 30} {\n+\tgdb_test_no_output \"set width $width\"\n+\t# There was also a bug where the styling could be wrong in the\n+\t# line listing; this is why the words from the source code are\n+\t# spelled out in the final result line of the test.\n+\tgdb_test \"frame\" \\\n+\t    [multi_line \\\n+\t\t \"#0 *$main_expr.*$arg_expr.*\" \\\n+\t\t \".*$arg_expr.*\" \\\n+\t\t \".* at .*$file_expr.*\" \\\n+\t\t \"\\[0-9\\]+.*return.* break here .*\"\n+\t    ] \\\n+\t    \"frame when width=$width\"\n+    }\n+\n     gdb_exit\n     gdb_spawn\n "
    },
    {
      "sha": "04a1d448ba997c494edbc2ba400d81d9d50a8f66",
      "filename": "gdb/ui-style.h",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a008792038c2510800db466897c4bb6305d20042/gdb/ui-style.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a008792038c2510800db466897c4bb6305d20042/gdb/ui-style.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ui-style.h?ref=a008792038c2510800db466897c4bb6305d20042",
      "patch": "@@ -163,6 +163,16 @@ struct ui_file_style\n   /* Return the ANSI escape sequence for this style.  */\n   std::string to_ansi () const;\n \n+  /* Return true if this style is the default style; false\n+     otherwise.  */\n+  bool is_default () const\n+  {\n+    return (m_foreground == NONE\n+\t    && m_background == NONE\n+\t    && m_intensity == NORMAL\n+\t    && !m_reverse);\n+  }\n+\n   /* Return true if this style specified reverse display; false\n      otherwise.  */\n   bool is_reverse () const"
    },
    {
      "sha": "ec2619642a18a6a62a8dab925bf1f3deef13de19",
      "filename": "gdb/utils.c",
      "status": "modified",
      "additions": 63,
      "deletions": 29,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/a008792038c2510800db466897c4bb6305d20042/gdb/utils.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/a008792038c2510800db466897c4bb6305d20042/gdb/utils.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/utils.c?ref=a008792038c2510800db466897c4bb6305d20042",
      "patch": "@@ -72,6 +72,7 @@\n #include <algorithm>\n #include \"common/pathstuff.h\"\n #include \"cli/cli-style.h\"\n+#include \"common/scope-exit.h\"\n \n void (*deprecated_error_begin_hook) (void);\n \n@@ -1282,6 +1283,9 @@ static const char *wrap_indent;\n /* Column number on the screen where wrap_buffer begins, or 0 if wrapping\n    is not in effect.  */\n static int wrap_column;\n+\n+/* The style applied at the time that wrap_here was called.  */\n+static ui_file_style wrap_style;\n \f\n \n /* Initialize the number of lines per page and chars per line.  */\n@@ -1427,21 +1431,19 @@ set_screen_width_and_height (int width, int height)\n \n static ui_file_style applied_style;\n \n-/* The currently desired style.  This can differ from the applied\n-   style when showing the pagination prompt.  */\n-\n-static ui_file_style desired_style;\n-\n-/* Emit an ANSI style escape for STYLE to the wrap buffer.  */\n+/* Emit an ANSI style escape for STYLE.  If STREAM is nullptr, emit to\n+   the wrap buffer; otherwise emit to STREAM.  */\n \n static void\n-emit_style_escape (const ui_file_style &style)\n+emit_style_escape (const ui_file_style &style,\n+\t\t   struct ui_file *stream = nullptr)\n {\n-  if (applied_style == style)\n-    return;\n   applied_style = style;\n \n-  wrap_buffer.append (style.to_ansi ());\n+  if (stream == nullptr)\n+    wrap_buffer.append (style.to_ansi ());\n+  else\n+    fputs_unfiltered (style.to_ansi ().c_str (), stream);\n }\n \n /* See utils.h.  */\n@@ -1465,11 +1467,11 @@ can_emit_style_escape (struct ui_file *stream)\n static void\n set_output_style (struct ui_file *stream, const ui_file_style &style)\n {\n-  if (!can_emit_style_escape (stream)\n-      || style == desired_style)\n+  if (!can_emit_style_escape (stream))\n     return;\n \n-  desired_style = style;\n+  /* Note that we don't pass STREAM here, because we want to emit to\n+     the wrap buffer, not directly to STREAM.  */\n   emit_style_escape (style);\n }\n \n@@ -1482,9 +1484,8 @@ reset_terminal_style (struct ui_file *stream)\n     {\n       /* Force the setting, regardless of what we think the setting\n \t might already be.  */\n-      desired_style = ui_file_style ();\n-      applied_style = desired_style;\n-      wrap_buffer.append (desired_style.to_ansi ());\n+      applied_style = ui_file_style ();\n+      wrap_buffer.append (applied_style.to_ansi ());\n     }\n }\n \n@@ -1504,7 +1505,8 @@ prompt_for_continue (void)\n   bool disable_pagination = pagination_disabled_for_command;\n \n   /* Clear the current styling.  */\n-  emit_style_escape (ui_file_style ());\n+  if (can_emit_style_escape (gdb_stdout))\n+    emit_style_escape (ui_file_style (), gdb_stdout);\n \n   if (annotation_level > 1)\n     printf_unfiltered ((\"\\n\\032\\032pre-prompt-for-continue\\n\"));\n@@ -1551,7 +1553,8 @@ prompt_for_continue (void)\n   pagination_disabled_for_command = disable_pagination;\n \n   /* Restore the current styling.  */\n-  emit_style_escape (desired_style);\n+  if (can_emit_style_escape (gdb_stdout))\n+    emit_style_escape (applied_style);\n \n   dont_repeat ();\t\t/* Forget prev cmd -- CR won't repeat it.  */\n }\n@@ -1589,7 +1592,7 @@ reinitialize_more_filter (void)\n static void\n flush_wrap_buffer (struct ui_file *stream)\n {\n-  if (!wrap_buffer.empty ())\n+  if (stream == gdb_stdout && !wrap_buffer.empty ())\n     {\n       fputs_unfiltered (wrap_buffer.c_str (), stream);\n       wrap_buffer.clear ();\n@@ -1644,6 +1647,7 @@ wrap_here (const char *indent)\n \twrap_indent = \"\";\n       else\n \twrap_indent = indent;\n+      wrap_style = applied_style;\n     }\n }\n \n@@ -1743,6 +1747,14 @@ fputs_maybe_filtered (const char *linebuffer, struct ui_file *stream,\n       return;\n     }\n \n+  auto buffer_clearer\n+    = make_scope_exit ([&] ()\n+\t\t       {\n+\t\t\t wrap_buffer.clear ();\n+\t\t\t wrap_column = 0;\n+\t\t\t wrap_indent = \"\";\n+\t\t       });\n+\n   /* Go through and output each character.  Show line extension\n      when this is necessary; prompt user for new page when this is\n      necessary.  */\n@@ -1759,6 +1771,8 @@ fputs_maybe_filtered (const char *linebuffer, struct ui_file *stream,\n \n       while (*lineptr && *lineptr != '\\n')\n \t{\n+\t  int skip_bytes;\n+\n \t  /* Print a single line.  */\n \t  if (*lineptr == '\\t')\n \t    {\n@@ -1769,6 +1783,14 @@ fputs_maybe_filtered (const char *linebuffer, struct ui_file *stream,\n \t      chars_printed = ((chars_printed >> 3) + 1) << 3;\n \t      lineptr++;\n \t    }\n+\t  else if (*lineptr == '\\033'\n+\t\t   && skip_ansi_escape (lineptr, &skip_bytes))\n+\t    {\n+\t      wrap_buffer.append (lineptr, skip_bytes);\n+\t      /* Note that we don't consider this a character, so we\n+\t\t don't increment chars_printed here.  */\n+\t      lineptr += skip_bytes;\n+\t    }\n \t  else\n \t    {\n \t      wrap_buffer.push_back (*lineptr);\n@@ -1782,15 +1804,18 @@ fputs_maybe_filtered (const char *linebuffer, struct ui_file *stream,\n \n \t      chars_printed = 0;\n \t      lines_printed++;\n-\t      /* If we aren't actually wrapping, don't output newline --\n-\t         if chars_per_line is right, we probably just overflowed\n-\t         anyway; if it's wrong, let us keep going.  */\n \t      if (wrap_column)\n \t\t{\n-\t\t  emit_style_escape (ui_file_style ());\n-\t\t  flush_wrap_buffer (stream);\n+\t\t  if (can_emit_style_escape (stream))\n+\t\t    emit_style_escape (ui_file_style (), stream);\n+\t\t  /* If we aren't actually wrapping, don't output\n+\t\t     newline -- if chars_per_line is right, we\n+\t\t     probably just overflowed anyway; if it's wrong,\n+\t\t     let us keep going.  */\n \t\t  fputc_unfiltered ('\\n', stream);\n \t\t}\n+\t      else\n+\t\tflush_wrap_buffer (stream);\n \n \t      /* Possible new page.  Note that\n \t\t PAGINATION_DISABLED_FOR_COMMAND might be set during\n@@ -1803,8 +1828,8 @@ fputs_maybe_filtered (const char *linebuffer, struct ui_file *stream,\n \t      if (wrap_column)\n \t\t{\n \t\t  fputs_unfiltered (wrap_indent, stream);\n-\t\t  emit_style_escape (desired_style);\n-\t\t  flush_wrap_buffer (stream);\n+\t\t  if (can_emit_style_escape (stream))\n+\t\t    emit_style_escape (wrap_style, stream);\n \t\t  /* FIXME, this strlen is what prevents wrap_indent from\n \t\t     containing tabs.  However, if we recurse to print it\n \t\t     and count its chars, we risk trouble if wrap_indent is\n@@ -1828,6 +1853,8 @@ fputs_maybe_filtered (const char *linebuffer, struct ui_file *stream,\n \t  lineptr++;\n \t}\n     }\n+\n+  buffer_clearer.release ();\n }\n \n void\n@@ -1842,9 +1869,16 @@ void\n fputs_styled (const char *linebuffer, const ui_file_style &style,\n \t      struct ui_file *stream)\n {\n-  set_output_style (stream, style);\n-  fputs_maybe_filtered (linebuffer, stream, 1);\n-  set_output_style (stream, ui_file_style ());\n+  /* This just makes it so we emit somewhat fewer escape\n+     sequences.  */\n+  if (style.is_default ())\n+    fputs_maybe_filtered (linebuffer, stream, 1);\n+  else\n+    {\n+      set_output_style (stream, style);\n+      fputs_maybe_filtered (linebuffer, stream, 1);\n+      set_output_style (stream, ui_file_style ());\n+    }\n }\n \n int"
    }
  ]
}