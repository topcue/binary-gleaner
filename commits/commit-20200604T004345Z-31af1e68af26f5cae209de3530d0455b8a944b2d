{
  "sha": "31af1e68af26f5cae209de3530d0455b8a944b2d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MzFhZjFlNjhhZjI2ZjVjYWUyMDlkZTM1MzBkMDQ1NWI4YTk0NGIyZA==",
  "commit": {
    "author": {
      "name": "Stephen Casner",
      "email": "casner@acm.org",
      "date": "2020-06-04T00:43:45Z"
    },
    "committer": {
      "name": "Stephen Casner",
      "email": "casner@acm.org",
      "date": "2020-06-04T00:43:45Z"
    },
    "message": "Copy several years of fixes from bfd/aoutx.h to bfd/pdp11.c.\n\n* pdp11.c (some_aout_object_p): 4c1534c7a2a - Don't set EXEC_P for\nfiles with relocs.\n(aout_get_external_symbols): 6b8f0fd579d - Return if count is zero.\n0301ce1486b PR 22306 - Handle stringsize of zero, and error for any\nother size that doesn't qcover the header word.\nbf82069dce1 PR 23056 - Allocate an extra byte at the end of the\nstring table, and zero it.\n(translate_symbol_table): 0d329c0a83a PR 22887 - Print an error\nmessage and set bfd_error on finding an invalid name string offset.\n(add_to_stringtab): INLINE -> inline\n(pdp11_aout_swap_reloc_in): 116acb2c268 PR 22887 - Correct r_index\nbound check.\n(squirt_out_relocs): e2996cc315d PR 20921 - Check for and report\nany relocs that could not be recognised.\n92744f05809 PR 20929 - Check for relocs\twithout an associated symbol.\n(find_nearest_line):  808346fcfcf PR 23055 - Check that the symbol\nname exists and is long enough, before attempting to see if it is\nfor a .o file.\nc3864421222 - Correct case for N_SO being the last symbol.\n50455f1ab29 PR 20891 - Handle the case where the main file name\nand the directory name are both empty.\ne82ab856bb4 PR 20892 - Handle the case where function name is empty.\n(aout_link_add_symbols): e517df3dbf7 PR 19629 - Check for out of\nrange string table offsets.\n531336e3a0b PR 20909 - Fix off-by-one error in check for an\nillegal string offset.\n(aout_link_includes_newfunc): Add comment.\n(pdp11_aout_link_input_section): ad756e3f9e6 - Return with an error\non unexpected relocation type rather than ASSERT.",
    "tree": {
      "sha": "24c9be8b0ddec758cb9733f55ebac0ff48358a9b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/24c9be8b0ddec758cb9733f55ebac0ff48358a9b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/31af1e68af26f5cae209de3530d0455b8a944b2d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/31af1e68af26f5cae209de3530d0455b8a944b2d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/31af1e68af26f5cae209de3530d0455b8a944b2d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/31af1e68af26f5cae209de3530d0455b8a944b2d/comments",
  "author": {
    "login": "slcasner",
    "id": 5100408,
    "node_id": "MDQ6VXNlcjUxMDA0MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5100408?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/slcasner",
    "html_url": "https://github.com/slcasner",
    "followers_url": "https://api.github.com/users/slcasner/followers",
    "following_url": "https://api.github.com/users/slcasner/following{/other_user}",
    "gists_url": "https://api.github.com/users/slcasner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/slcasner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/slcasner/subscriptions",
    "organizations_url": "https://api.github.com/users/slcasner/orgs",
    "repos_url": "https://api.github.com/users/slcasner/repos",
    "events_url": "https://api.github.com/users/slcasner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/slcasner/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "slcasner",
    "id": 5100408,
    "node_id": "MDQ6VXNlcjUxMDA0MDg=",
    "avatar_url": "https://avatars.githubusercontent.com/u/5100408?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/slcasner",
    "html_url": "https://github.com/slcasner",
    "followers_url": "https://api.github.com/users/slcasner/followers",
    "following_url": "https://api.github.com/users/slcasner/following{/other_user}",
    "gists_url": "https://api.github.com/users/slcasner/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/slcasner/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/slcasner/subscriptions",
    "organizations_url": "https://api.github.com/users/slcasner/orgs",
    "repos_url": "https://api.github.com/users/slcasner/repos",
    "events_url": "https://api.github.com/users/slcasner/events{/privacy}",
    "received_events_url": "https://api.github.com/users/slcasner/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fda3f1174efb2fb1800e3fcb74819ba2dc9c2dd0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fda3f1174efb2fb1800e3fcb74819ba2dc9c2dd0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fda3f1174efb2fb1800e3fcb74819ba2dc9c2dd0"
    }
  ],
  "stats": {
    "total": 166,
    "additions": 134,
    "deletions": 32
  },
  "files": [
    {
      "sha": "96601f671edb77254cdabbaf523016e66154c260",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/31af1e68af26f5cae209de3530d0455b8a944b2d/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/31af1e68af26f5cae209de3530d0455b8a944b2d/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=31af1e68af26f5cae209de3530d0455b8a944b2d",
      "patch": "@@ -1,3 +1,37 @@\n+2020-06-03  Stephen Casner  <casner@acm.org>\n+\n+\tCopy several years of fixes from bfd/aoutx.h to bfd/pdp11.c.\n+\n+\t* pdp11.c (some_aout_object_p): 4c1534c7a2a - Don't set EXEC_P for\n+\tfiles with relocs.\n+\t(aout_get_external_symbols): 6b8f0fd579d - Return if count is zero.\n+\t0301ce1486b PR 22306 - Handle stringsize of zero, and error for any\n+\tother size that doesn't qcover the header word.\n+\tbf82069dce1 PR 23056 - Allocate an extra byte at the end of the\n+\tstring table, and zero it.\n+\t(translate_symbol_table): 0d329c0a83a PR 22887 - Print an error\n+\tmessage and set bfd_error on finding an invalid name string offset.\n+\t(add_to_stringtab): INLINE -> inline\n+\t(pdp11_aout_swap_reloc_in): 116acb2c268 PR 22887 - Correct r_index\n+\tbound check.\n+\t(squirt_out_relocs): e2996cc315d PR 20921 - Check for and report\n+\tany relocs that could not be recognised.\n+\t92744f05809 PR 20929 - Check for relocs\twithout an associated symbol.\n+\t(find_nearest_line):  808346fcfcf PR 23055 - Check that the symbol\n+\tname exists and is long enough, before attempting to see if it is\n+\tfor a .o file.\n+\tc3864421222 - Correct case for N_SO being the last symbol.\n+\t50455f1ab29 PR 20891 - Handle the case where the main file name\n+\tand the directory name are both empty.\n+\te82ab856bb4 PR 20892 - Handle the case where function name is empty.\n+\t(aout_link_add_symbols): e517df3dbf7 PR 19629 - Check for out of\n+\trange string table offsets.\n+\t531336e3a0b PR 20909 - Fix off-by-one error in check for an\n+\tillegal string offset. \n+\t(aout_link_includes_newfunc): Add comment.\n+\t(pdp11_aout_link_input_section): ad756e3f9e6 - Return with an error\n+\ton unexpected relocation type rather than ASSERT.\n+\n 2020-06-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR ld/26066"
    },
    {
      "sha": "d41aefca2b2f5c8e15e6f842700f8874fbda48f8",
      "filename": "bfd/pdp11.c",
      "status": "modified",
      "additions": 100,
      "deletions": 32,
      "changes": 132,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/31af1e68af26f5cae209de3530d0455b8a944b2d/bfd/pdp11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/31af1e68af26f5cae209de3530d0455b8a944b2d/bfd/pdp11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pdp11.c?ref=31af1e68af26f5cae209de3530d0455b8a944b2d",
      "patch": "@@ -623,8 +623,11 @@ NAME (aout, some_aout_object_p) (bfd *abfd,\n      sets the entry point, and that is likely to be non-zero for most systems. */\n \n   if (execp->a_entry != 0\n-      || (execp->a_entry >= obj_textsec(abfd)->vma\n-\t  && execp->a_entry < obj_textsec(abfd)->vma + obj_textsec(abfd)->size))\n+      || (execp->a_entry >= obj_textsec (abfd)->vma\n+\t  && execp->a_entry < (obj_textsec (abfd)->vma\n+\t\t\t       + obj_textsec (abfd)->size)\n+\t  && execp->a_trsize == 0\n+\t  && execp->a_drsize == 0))\n     abfd->flags |= EXEC_P;\n #ifdef STAT_FOR_EXEC\n   else\n@@ -1241,7 +1244,7 @@ aout_get_external_symbols (bfd *abfd)\n       syms = (struct external_nlist *)\n \t_bfd_malloc_and_read (abfd, count * EXTERNAL_NLIST_SIZE,\n \t\t\t      count * EXTERNAL_NLIST_SIZE);\n-      if (syms == NULL && count != 0)\n+      if (syms == NULL)\n \treturn FALSE;\n #endif\n \n@@ -1255,36 +1258,54 @@ aout_get_external_symbols (bfd *abfd)\n       unsigned char string_chars[BYTES_IN_LONG];\n       bfd_size_type stringsize;\n       char *strings;\n+      bfd_size_type amt = BYTES_IN_LONG;\n \n       /* Get the size of the strings.  */\n       if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0\n-\t  || (bfd_bread ((void *) string_chars, (bfd_size_type) BYTES_IN_LONG,\n-\t\t\tabfd) != BYTES_IN_LONG))\n+\t  || bfd_bread ((void *) string_chars, amt, abfd) != amt)\n \treturn FALSE;\n       stringsize = H_GET_32 (abfd, string_chars);\n+      if (stringsize == 0)\n+\tstringsize = 1;\n+      else if (stringsize < BYTES_IN_LONG\n+\t       || (size_t) stringsize != stringsize)\n+\t{\n+\t  bfd_set_error (bfd_error_bad_value);\n+\t  return FALSE;\n+\t}\n \n #ifdef USE_MMAP\n-      if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize,\n-\t\t\t\t &obj_aout_string_window (abfd), TRUE))\n-\treturn FALSE;\n-      strings = (char *) obj_aout_string_window (abfd).data;\n-#else\n-      strings = bfd_malloc (stringsize + 1);\n-      if (strings == NULL)\n-\treturn FALSE;\n-\n-      /* Skip space for the string count in the buffer for convenience\n-\t when using indexes.  */\n-      if (bfd_bread (strings + 4, stringsize - 4, abfd) != stringsize - 4)\n+      if (stringsize >= BYTES_IN_LONG)\n \t{\n-\t  free (strings);\n-\t  return FALSE;\n+\t  if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize + 1,\n+\t\t\t\t     &obj_aout_string_window (abfd), TRUE))\n+\t    return FALSE;\n+\t  strings = (char *) obj_aout_string_window (abfd).data;\n \t}\n+      else\n #endif\n+\t{\n+\t  strings = (char *) bfd_malloc (stringsize + 1);\n+\t  if (strings == NULL)\n+\t    return FALSE;\n+\n+\t  if (stringsize >= BYTES_IN_LONG)\n+\t    {\n+\t      /* Keep the string count in the buffer for convenience\n+\t\t when indexing with e_strx.  */\n+\t      amt = stringsize - BYTES_IN_LONG;\n+\t      if (bfd_bread (strings + BYTES_IN_LONG, amt, abfd) != amt)\n+\t\t{\n+\t\t  free (strings);\n+\t\t  return FALSE;\n+\t\t}\n+\t    }\n+\t}\n       /* Ensure that a zero index yields an empty string.  */\n       strings[0] = '\\0';\n \n-      strings[stringsize - 1] = 0;\n+      /* Ensure that the string buffer is NUL terminated.  */\n+      strings[stringsize] = 0;\n \n       obj_aout_external_strings (abfd) = strings;\n       obj_aout_external_string_size (abfd) = stringsize;\n@@ -1504,7 +1525,13 @@ NAME (aout, translate_symbol_table) (bfd *abfd,\n       else if (x < strsize)\n \tin->symbol.name = str + x;\n       else\n-\treturn FALSE;\n+\t{\n+\t  _bfd_error_handler\n+\t    (_(\"%pB: invalid string offset %\" PRIu64 \" >= %\" PRIu64),\n+\t     abfd, (uint64_t) x, (uint64_t) strsize);\n+\t  bfd_set_error (bfd_error_bad_value);\n+\t  return FALSE;\n+\t}\n \n       in->symbol.value = GET_WORD (abfd,  ext->e_value);\n       /* TODO: is 0 a safe value here?  */\n@@ -1596,7 +1623,7 @@ NAME (aout, slurp_symbol_table) (bfd *abfd)\n /* Get the index of a string in a strtab, adding it if it is not\n    already present.  */\n \n-static INLINE bfd_size_type\n+static inline bfd_size_type\n add_to_stringtab (bfd *abfd,\n \t\t  struct bfd_strtab_hash *tab,\n \t\t  const char *str,\n@@ -1834,10 +1861,12 @@ pdp11_aout_swap_reloc_in (bfd *\t\t abfd,\n      local or global.  */\n   r_extern = (reloc_entry & RTYPE) == REXT;\n \n-  if (r_extern && r_index > symcount)\n+  if (r_extern && r_index >= symcount)\n     {\n       /* We could arrange to return an error, but it might be useful\n-\t to see the file even if it is bad.  */\n+\t to see the file even if it is bad.  FIXME: Of course this\n+\t means that objdump -r *doesn't* see the actual reloc, and\n+\t objcopy silently writes a different reloc.  */\n       r_extern = 0;\n       r_index = N_ABS;\n     }\n@@ -1960,6 +1989,15 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)\n \t{\n \t  bfd_byte *r;\n \n+\t  if ((*generic)->howto == NULL\n+\t      || (*generic)->sym_ptr_ptr == NULL)\n+\t    {\n+\t      bfd_set_error (bfd_error_invalid_operation);\n+\t      _bfd_error_handler (_(\"%pB: attempt to write out \"\n+\t\t\t\t    \"unknown reloc type\"), abfd);\n+\t      bfd_release (abfd, native);\n+\t      return FALSE;\n+\t    }\n \t  r = native + (*generic)->address;\n \t  pdp11_aout_swap_reloc_out (abfd, *generic, r);\n \t  count--;\n@@ -2229,7 +2267,7 @@ NAME (aout, find_nearest_line) (bfd *abfd,\n   char *buf;\n \n   *filename_ptr = bfd_get_filename (abfd);\n-  *functionname_ptr = 0;\n+  *functionname_ptr = NULL;\n   *line_ptr = 0;\n   if (discriminator_ptr)\n     *discriminator_ptr = 0;\n@@ -2257,7 +2295,10 @@ NAME (aout, find_nearest_line) (bfd *abfd,\n \t\t  const char * symname;\n \n \t\t  symname = q->symbol.name;\n-\t\t  if (strcmp (symname + strlen (symname) - 2, \".o\") == 0)\n+\n+\t\t  if (symname != NULL\n+\t\t      && strlen (symname) > 2\n+\t\t      && strcmp (symname + strlen (symname) - 2, \".o\") == 0)\n \t\t    {\n \t\t      if (q->symbol.value > low_line_vma)\n \t\t\t{\n@@ -2289,7 +2330,7 @@ NAME (aout, find_nearest_line) (bfd *abfd,\n \t      /* Look ahead to next symbol to check if that too is an N_SO.  */\n \t      p++;\n \t      if (*p == NULL)\n-\t\tbreak;\n+\t\tgoto done;\n \t      q = (aout_symbol_type *)(*p);\n \t      if (q->type != (int) N_SO)\n \t\tgoto next;\n@@ -2367,9 +2408,17 @@ NAME (aout, find_nearest_line) (bfd *abfd,\n \t*filename_ptr = main_file_name;\n       else\n \t{\n-\t  sprintf (buf, \"%s%s\", directory_name, main_file_name);\n-\t  *filename_ptr = buf;\n-\t  buf += filelen + 1;\n+\t  if (buf == NULL)\n+\t    /* PR binutils/20891: In a corrupt input file both\n+\t       main_file_name and directory_name can be empty...  */\n+\t    * filename_ptr = NULL;\n+\t  else\n+\t    {\n+\t      snprintf (buf, filelen + 1, \"%s%s\", directory_name,\n+\t\t\tmain_file_name);\n+\t      *filename_ptr = buf;\n+\t      buf += filelen + 1;\n+\t    }\n \t}\n     }\n \n@@ -2378,6 +2427,12 @@ NAME (aout, find_nearest_line) (bfd *abfd,\n       const char *function = func->name;\n       char *colon;\n \n+      if (buf == NULL)\n+\t{\n+\t  /* PR binutils/20892: In a corrupt input file func can be empty.  */\n+\t  * functionname_ptr = NULL;\n+\t  return TRUE;\n+\t}\n       /* The caller expects a symbol name.  We actually have a\n \t function name, without the leading underscore.  Put the\n \t underscore back in, so that the caller gets a symbol name.  */\n@@ -2808,6 +2863,9 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \n       type = H_GET_8 (abfd, p->e_type);\n \n+      /* PR 19629: Corrupt binaries can contain illegal string offsets.  */\n+      if (GET_WORD (abfd, p->e_strx) >= obj_aout_external_string_size (abfd))\n+\treturn FALSE;\n       name = strings + GET_WORD (abfd, p->e_strx);\n       value = GET_WORD (abfd, p->e_value);\n       flags = BSF_GLOBAL;\n@@ -2920,6 +2978,9 @@ aout_link_includes_newfunc (struct bfd_hash_entry *entry,\n   return (struct bfd_hash_entry *) ret;\n }\n \n+/* Write out a symbol that was not associated with an a.out input\n+   object.  */\n+\n static bfd_boolean\n aout_link_write_other_symbol (struct bfd_hash_entry *bh, void *data)\n {\n@@ -3304,8 +3365,15 @@ pdp11_aout_link_input_section (struct aout_final_link_info *flaginfo,\n \tr_extern = (r_type == REXT);\n \n \thowto_idx = r_pcrel;\n-\tBFD_ASSERT (howto_idx < TABLE_SIZE (howto_table_pdp11));\n-\thowto = howto_table_pdp11 + howto_idx;\n+\tif (howto_idx < TABLE_SIZE (howto_table_pdp11))\n+\t  howto = howto_table_pdp11 + howto_idx;\n+\telse\n+\t  {\n+\t    _bfd_error_handler (_(\"%pB: unsupported relocation type\"),\n+\t\t\t\tinput_bfd);\n+\t    bfd_set_error (bfd_error_bad_value);\n+\t    return FALSE;\n+\t  }\n       }\n \n       if (relocatable)"
    }
  ]
}