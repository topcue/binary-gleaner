{
  "sha": "93b54c8ed3644a6604c5244faddf5dae7f60a743",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTNiNTRjOGVkMzY0NGE2NjA0YzUyNDRmYWRkZjVkYWU3ZjYwYTc0Mw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-04-13T18:42:59Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-04-13T20:10:04Z"
    },
    "message": "Introduce async-event.[ch]\n\nThis patch splits out some gdb-specific code from event-loop, into new\nfiles async-event.[ch].  Strictly speaking this code could perhaps be\nput into gdbsupport/, but because gdbserver does not currently use it,\nit seemed better, for size reasons, to split it out.\n\ngdb/ChangeLog\n2020-04-13  Tom Tromey  <tom@tromey.com>\n\n\t* tui/tui-win.c: Include async-event.h.\n\t* remote.c: Include async-event.h.\n\t* remote-notif.c: Include async-event.h.\n\t* record-full.c: Include async-event.h.\n\t* record-btrace.c: Include async-event.h.\n\t* infrun.c: Include async-event.h.\n\t* event-top.c: Include async-event.h.\n\t* event-loop.h: Move some declarations to async-event.h.\n\t* event-loop.c: Don't include ser-event.h or top.h.  Move some\n\tcode to async-event.c.\n\t* async-event.h: New file.\n\t* async-event.c: New file.\n\t* Makefile.in (COMMON_SFILES): Add async-event.c.\n\t(HFILES_NO_SRCDIR): Add async-event.h.",
    "tree": {
      "sha": "1db8cfd6f1f7c967270b9f396622848d179235d5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1db8cfd6f1f7c967270b9f396622848d179235d5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/93b54c8ed3644a6604c5244faddf5dae7f60a743",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/93b54c8ed3644a6604c5244faddf5dae7f60a743",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/93b54c8ed3644a6604c5244faddf5dae7f60a743",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/93b54c8ed3644a6604c5244faddf5dae7f60a743/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c1cd3163d99efe4f7cbe7f228859fd93f28e06bb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c1cd3163d99efe4f7cbe7f228859fd93f28e06bb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c1cd3163d99efe4f7cbe7f228859fd93f28e06bb"
    }
  ],
  "stats": {
    "total": 775,
    "additions": 430,
    "deletions": 345
  },
  "files": [
    {
      "sha": "a108cd1dcedc642b124463469ec9a3f049ac9b90",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -1,3 +1,20 @@\n+2020-04-13  Tom Tromey  <tom@tromey.com>\n+\n+\t* tui/tui-win.c: Include async-event.h.\n+\t* remote.c: Include async-event.h.\n+\t* remote-notif.c: Include async-event.h.\n+\t* record-full.c: Include async-event.h.\n+\t* record-btrace.c: Include async-event.h.\n+\t* infrun.c: Include async-event.h.\n+\t* event-top.c: Include async-event.h.\n+\t* event-loop.h: Move some declarations to async-event.h.\n+\t* event-loop.c: Don't include ser-event.h or top.h.  Move some\n+\tcode to async-event.c.\n+\t* async-event.h: New file.\n+\t* async-event.c: New file.\n+\t* Makefile.in (COMMON_SFILES): Add async-event.c.\n+\t(HFILES_NO_SRCDIR): Add async-event.h.\n+\n 2020-04-13  Tom Tromey  <tom@tromey.com>\n \n \t* utils.c (flush_streams): New function."
    },
    {
      "sha": "bb96998630c46a583c6fa23f1ca60f1bcb625b56",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -955,6 +955,7 @@ COMMON_SFILES = \\\n \talloc.c \\\n \tannotate.c \\\n \tarch-utils.c \\\n+\tasync-event.c \\\n \tauto-load.c \\\n \tauxv.c \\\n \tax-gdb.c \\\n@@ -1212,6 +1213,7 @@ HFILES_NO_SRCDIR = \\\n \tarm-linux-tdep.h \\\n \tarm-nbsd-tdep.h \\\n \tarm-tdep.h \\\n+\tasync-event.h \\\n \tauto-load.h \\\n \tauxv.h \\\n \tax.h \\"
    },
    {
      "sha": "dd65c17468b116f866b2071003576ba1b8d553f3",
      "filename": "gdb/async-event.c",
      "status": "added",
      "additions": 325,
      "deletions": 0,
      "changes": 325,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/async-event.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/async-event.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/async-event.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -0,0 +1,325 @@\n+/* Async events for the GDB event loop.\n+   Copyright (C) 1999-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include \"defs.h\"\n+#include \"async-event.h\"\n+\n+#include \"ser-event.h\"\n+#include \"top.h\"\n+\n+/* PROC is a function to be invoked when the READY flag is set.  This\n+   happens when there has been a signal and the corresponding signal\n+   handler has 'triggered' this async_signal_handler for execution.\n+   The actual work to be done in response to a signal will be carried\n+   out by PROC at a later time, within process_event.  This provides a\n+   deferred execution of signal handlers.\n+\n+   Async_init_signals takes care of setting up such an\n+   async_signal_handler for each interesting signal.  */\n+\n+typedef struct async_signal_handler\n+  {\n+    int ready;\t\t\t    /* If ready, call this handler\n+\t\t\t\t       from the main event loop, using\n+\t\t\t\t       invoke_async_handler.  */\n+    struct async_signal_handler *next_handler;\t/* Ptr to next handler.  */\n+    sig_handler_func *proc;\t    /* Function to call to do the work.  */\n+    gdb_client_data client_data;    /* Argument to async_handler_func.  */\n+  }\n+async_signal_handler;\n+\n+/* PROC is a function to be invoked when the READY flag is set.  This\n+   happens when the event has been marked with\n+   MARK_ASYNC_EVENT_HANDLER.  The actual work to be done in response\n+   to an event will be carried out by PROC at a later time, within\n+   process_event.  This provides a deferred execution of event\n+   handlers.  */\n+typedef struct async_event_handler\n+  {\n+    /* If ready, call this handler from the main event loop, using\n+       invoke_event_handler.  */\n+    int ready;\n+\n+    /* Point to next handler.  */\n+    struct async_event_handler *next_handler;\n+\n+    /* Function to call to do the work.  */\n+    async_event_handler_func *proc;\n+\n+    /* Argument to PROC.  */\n+    gdb_client_data client_data;\n+  }\n+async_event_handler;\n+\n+/* All the async_signal_handlers gdb is interested in are kept onto\n+   this list.  */\n+static struct\n+  {\n+    /* Pointer to first in handler list.  */\n+    async_signal_handler *first_handler;\n+\n+    /* Pointer to last in handler list.  */\n+    async_signal_handler *last_handler;\n+  }\n+sighandler_list;\n+\n+/* All the async_event_handlers gdb is interested in are kept onto\n+   this list.  */\n+static struct\n+  {\n+    /* Pointer to first in handler list.  */\n+    async_event_handler *first_handler;\n+\n+    /* Pointer to last in handler list.  */\n+    async_event_handler *last_handler;\n+  }\n+async_event_handler_list;\n+\n+\n+/* This event is signalled whenever an asynchronous handler needs to\n+   defer an action to the event loop.  */\n+static struct serial_event *async_signal_handlers_serial_event;\n+\n+/* Callback registered with ASYNC_SIGNAL_HANDLERS_SERIAL_EVENT.  */\n+\n+static void\n+async_signals_handler (int error, gdb_client_data client_data)\n+{\n+  /* Do nothing.  Handlers are run by invoke_async_signal_handlers\n+     from instead.  */\n+}\n+\n+void\n+initialize_async_signal_handlers (void)\n+{\n+  async_signal_handlers_serial_event = make_serial_event ();\n+\n+  add_file_handler (serial_event_fd (async_signal_handlers_serial_event),\n+\t\t    async_signals_handler, NULL);\n+}\n+\n+\f\n+\n+/* Create an asynchronous handler, allocating memory for it.\n+   Return a pointer to the newly created handler.\n+   This pointer will be used to invoke the handler by \n+   invoke_async_signal_handler.\n+   PROC is the function to call with CLIENT_DATA argument \n+   whenever the handler is invoked.  */\n+async_signal_handler *\n+create_async_signal_handler (sig_handler_func * proc,\n+\t\t\t     gdb_client_data client_data)\n+{\n+  async_signal_handler *async_handler_ptr;\n+\n+  async_handler_ptr = XNEW (async_signal_handler);\n+  async_handler_ptr->ready = 0;\n+  async_handler_ptr->next_handler = NULL;\n+  async_handler_ptr->proc = proc;\n+  async_handler_ptr->client_data = client_data;\n+  if (sighandler_list.first_handler == NULL)\n+    sighandler_list.first_handler = async_handler_ptr;\n+  else\n+    sighandler_list.last_handler->next_handler = async_handler_ptr;\n+  sighandler_list.last_handler = async_handler_ptr;\n+  return async_handler_ptr;\n+}\n+\n+/* Mark the handler (ASYNC_HANDLER_PTR) as ready.  This information\n+   will be used when the handlers are invoked, after we have waited\n+   for some event.  The caller of this function is the interrupt\n+   handler associated with a signal.  */\n+void\n+mark_async_signal_handler (async_signal_handler * async_handler_ptr)\n+{\n+  async_handler_ptr->ready = 1;\n+  serial_event_set (async_signal_handlers_serial_event);\n+}\n+\n+/* See event-loop.h.  */\n+\n+void\n+clear_async_signal_handler (async_signal_handler *async_handler_ptr)\n+{\n+  async_handler_ptr->ready = 0;\n+}\n+\n+/* See event-loop.h.  */\n+\n+int\n+async_signal_handler_is_marked (async_signal_handler *async_handler_ptr)\n+{\n+  return async_handler_ptr->ready;\n+}\n+\n+/* Call all the handlers that are ready.  Returns true if any was\n+   indeed ready.  */\n+\n+int\n+invoke_async_signal_handlers (void)\n+{\n+  async_signal_handler *async_handler_ptr;\n+  int any_ready = 0;\n+\n+  /* We're going to handle all pending signals, so no need to wake up\n+     the event loop again the next time around.  Note this must be\n+     cleared _before_ calling the callbacks, to avoid races.  */\n+  serial_event_clear (async_signal_handlers_serial_event);\n+\n+  /* Invoke all ready handlers.  */\n+\n+  while (1)\n+    {\n+      for (async_handler_ptr = sighandler_list.first_handler;\n+\t   async_handler_ptr != NULL;\n+\t   async_handler_ptr = async_handler_ptr->next_handler)\n+\t{\n+\t  if (async_handler_ptr->ready)\n+\t    break;\n+\t}\n+      if (async_handler_ptr == NULL)\n+\tbreak;\n+      any_ready = 1;\n+      async_handler_ptr->ready = 0;\n+      /* Async signal handlers have no connection to whichever was the\n+\t current UI, and thus always run on the main one.  */\n+      current_ui = main_ui;\n+      (*async_handler_ptr->proc) (async_handler_ptr->client_data);\n+    }\n+\n+  return any_ready;\n+}\n+\n+/* Delete an asynchronous handler (ASYNC_HANDLER_PTR).\n+   Free the space allocated for it.  */\n+void\n+delete_async_signal_handler (async_signal_handler ** async_handler_ptr)\n+{\n+  async_signal_handler *prev_ptr;\n+\n+  if (sighandler_list.first_handler == (*async_handler_ptr))\n+    {\n+      sighandler_list.first_handler = (*async_handler_ptr)->next_handler;\n+      if (sighandler_list.first_handler == NULL)\n+\tsighandler_list.last_handler = NULL;\n+    }\n+  else\n+    {\n+      prev_ptr = sighandler_list.first_handler;\n+      while (prev_ptr && prev_ptr->next_handler != (*async_handler_ptr))\n+\tprev_ptr = prev_ptr->next_handler;\n+      gdb_assert (prev_ptr);\n+      prev_ptr->next_handler = (*async_handler_ptr)->next_handler;\n+      if (sighandler_list.last_handler == (*async_handler_ptr))\n+\tsighandler_list.last_handler = prev_ptr;\n+    }\n+  xfree ((*async_handler_ptr));\n+  (*async_handler_ptr) = NULL;\n+}\n+\n+/* Create an asynchronous event handler, allocating memory for it.\n+   Return a pointer to the newly created handler.  PROC is the\n+   function to call with CLIENT_DATA argument whenever the handler is\n+   invoked.  */\n+async_event_handler *\n+create_async_event_handler (async_event_handler_func *proc,\n+\t\t\t    gdb_client_data client_data)\n+{\n+  async_event_handler *h;\n+\n+  h = XNEW (struct async_event_handler);\n+  h->ready = 0;\n+  h->next_handler = NULL;\n+  h->proc = proc;\n+  h->client_data = client_data;\n+  if (async_event_handler_list.first_handler == NULL)\n+    async_event_handler_list.first_handler = h;\n+  else\n+    async_event_handler_list.last_handler->next_handler = h;\n+  async_event_handler_list.last_handler = h;\n+  return h;\n+}\n+\n+/* Mark the handler (ASYNC_HANDLER_PTR) as ready.  This information\n+   will be used by gdb_do_one_event.  The caller will be whoever\n+   created the event source, and wants to signal that the event is\n+   ready to be handled.  */\n+void\n+mark_async_event_handler (async_event_handler *async_handler_ptr)\n+{\n+  async_handler_ptr->ready = 1;\n+}\n+\n+/* See event-loop.h.  */\n+\n+void\n+clear_async_event_handler (async_event_handler *async_handler_ptr)\n+{\n+  async_handler_ptr->ready = 0;\n+}\n+\n+/* Check if asynchronous event handlers are ready, and call the\n+   handler function for one that is.  */\n+\n+int\n+check_async_event_handlers ()\n+{\n+  async_event_handler *async_handler_ptr;\n+\n+  for (async_handler_ptr = async_event_handler_list.first_handler;\n+       async_handler_ptr != NULL;\n+       async_handler_ptr = async_handler_ptr->next_handler)\n+    {\n+      if (async_handler_ptr->ready)\n+\t{\n+\t  async_handler_ptr->ready = 0;\n+\t  (*async_handler_ptr->proc) (async_handler_ptr->client_data);\n+\t  return 1;\n+\t}\n+    }\n+\n+  return 0;\n+}\n+\n+/* Delete an asynchronous handler (ASYNC_HANDLER_PTR).\n+   Free the space allocated for it.  */\n+void\n+delete_async_event_handler (async_event_handler **async_handler_ptr)\n+{\n+  async_event_handler *prev_ptr;\n+\n+  if (async_event_handler_list.first_handler == *async_handler_ptr)\n+    {\n+      async_event_handler_list.first_handler\n+\t= (*async_handler_ptr)->next_handler;\n+      if (async_event_handler_list.first_handler == NULL)\n+\tasync_event_handler_list.last_handler = NULL;\n+    }\n+  else\n+    {\n+      prev_ptr = async_event_handler_list.first_handler;\n+      while (prev_ptr && prev_ptr->next_handler != *async_handler_ptr)\n+\tprev_ptr = prev_ptr->next_handler;\n+      gdb_assert (prev_ptr);\n+      prev_ptr->next_handler = (*async_handler_ptr)->next_handler;\n+      if (async_event_handler_list.last_handler == (*async_handler_ptr))\n+\tasync_event_handler_list.last_handler = prev_ptr;\n+    }\n+  xfree (*async_handler_ptr);\n+  *async_handler_ptr = NULL;\n+}"
    },
    {
      "sha": "408f7764f7c913cd71cf30c617fb3052873b816b",
      "filename": "gdb/async-event.h",
      "status": "added",
      "additions": 71,
      "deletions": 0,
      "changes": 71,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/async-event.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/async-event.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/async-event.h?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -0,0 +1,71 @@\n+/* Async events for the GDB event loop.\n+   Copyright (C) 1999-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef ASYNC_EVENT_H\n+#define ASYNC_EVENT_H\n+\n+#include \"event-loop.h\"\n+\n+struct async_signal_handler;\n+struct async_event_handler;\n+typedef void (sig_handler_func) (gdb_client_data);\n+typedef void (async_event_handler_func) (gdb_client_data);\n+\n+extern struct async_signal_handler *\n+  create_async_signal_handler (sig_handler_func *proc, \n+\t\t\t       gdb_client_data client_data);\n+extern void delete_async_signal_handler (struct async_signal_handler **);\n+\n+/* Call the handler from HANDLER the next time through the event\n+   loop.  */\n+extern void mark_async_signal_handler (struct async_signal_handler *handler);\n+\n+/* Returns true if HANDLER is marked ready.  */\n+\n+extern int\n+  async_signal_handler_is_marked (struct async_signal_handler *handler);\n+\n+/* Mark HANDLER as NOT ready.  */\n+\n+extern void clear_async_signal_handler (struct async_signal_handler *handler);\n+\n+/* Create and register an asynchronous event source in the event loop,\n+   and set PROC as its callback.  CLIENT_DATA is passed as argument to\n+   PROC upon its invocation.  Returns a pointer to an opaque structure\n+   used to mark as ready and to later delete this event source from\n+   the event loop.  */\n+extern struct async_event_handler *\n+  create_async_event_handler (async_event_handler_func *proc,\n+\t\t\t      gdb_client_data client_data);\n+\n+/* Remove the event source pointed by HANDLER_PTR created by\n+   CREATE_ASYNC_EVENT_HANDLER from the event loop, and release it.  */\n+extern void\n+  delete_async_event_handler (struct async_event_handler **handler_ptr);\n+\n+/* Call the handler from HANDLER the next time through the event\n+   loop.  */\n+extern void mark_async_event_handler (struct async_event_handler *handler);\n+\n+/* Mark the handler (ASYNC_HANDLER_PTR) as NOT ready.  */\n+\n+extern void clear_async_event_handler (struct async_event_handler *handler);\n+\n+extern void initialize_async_signal_handlers (void);\n+\n+#endif /* ASYNC_EVENT_H */"
    },
    {
      "sha": "e5347d2e3f0c8ef90dbcb6fcdedb6a3ce6cde8c3",
      "filename": "gdb/event-loop.c",
      "status": "modified",
      "additions": 0,
      "deletions": 306,
      "changes": 306,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/event-loop.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/event-loop.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/event-loop.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -19,8 +19,6 @@\n \n #include \"defs.h\"\n #include \"event-loop.h\"\n-#include \"event-top.h\"\n-#include \"ser-event.h\"\n \n #include <chrono>\n \n@@ -35,7 +33,6 @@\n #include <sys/types.h>\n #include \"gdbsupport/gdb_sys_time.h\"\n #include \"gdbsupport/gdb_select.h\"\n-#include \"top.h\"\n \n /* Tell create_file_handler what events we are interested in.\n    This is used by the select version of the event loop.  */\n@@ -60,50 +57,6 @@ typedef struct file_handler\n   }\n file_handler;\n \n-/* PROC is a function to be invoked when the READY flag is set.  This\n-   happens when there has been a signal and the corresponding signal\n-   handler has 'triggered' this async_signal_handler for execution.\n-   The actual work to be done in response to a signal will be carried\n-   out by PROC at a later time, within process_event.  This provides a\n-   deferred execution of signal handlers.\n-\n-   Async_init_signals takes care of setting up such an\n-   async_signal_handler for each interesting signal.  */\n-\n-typedef struct async_signal_handler\n-  {\n-    int ready;\t\t\t    /* If ready, call this handler\n-\t\t\t\t       from the main event loop, using\n-\t\t\t\t       invoke_async_handler.  */\n-    struct async_signal_handler *next_handler;\t/* Ptr to next handler.  */\n-    sig_handler_func *proc;\t    /* Function to call to do the work.  */\n-    gdb_client_data client_data;    /* Argument to async_handler_func.  */\n-  }\n-async_signal_handler;\n-\n-/* PROC is a function to be invoked when the READY flag is set.  This\n-   happens when the event has been marked with\n-   MARK_ASYNC_EVENT_HANDLER.  The actual work to be done in response\n-   to an event will be carried out by PROC at a later time, within\n-   process_event.  This provides a deferred execution of event\n-   handlers.  */\n-typedef struct async_event_handler\n-  {\n-    /* If ready, call this handler from the main event loop, using\n-       invoke_event_handler.  */\n-    int ready;\n-\n-    /* Point to next handler.  */\n-    struct async_event_handler *next_handler;\n-\n-    /* Function to call to do the work.  */\n-    async_event_handler_func *proc;\n-\n-    /* Argument to PROC.  */\n-    gdb_client_data client_data;\n-  }\n-async_event_handler;\n-\n /* Gdb_notifier is just a list of file descriptors gdb is interested in.\n    These are the input file descriptor, and the target file\n    descriptor.  We have two flavors of the notifier, one for platforms\n@@ -198,61 +151,12 @@ static struct\n   }\n timer_list;\n \n-/* All the async_signal_handlers gdb is interested in are kept onto\n-   this list.  */\n-static struct\n-  {\n-    /* Pointer to first in handler list.  */\n-    async_signal_handler *first_handler;\n-\n-    /* Pointer to last in handler list.  */\n-    async_signal_handler *last_handler;\n-  }\n-sighandler_list;\n-\n-/* All the async_event_handlers gdb is interested in are kept onto\n-   this list.  */\n-static struct\n-  {\n-    /* Pointer to first in handler list.  */\n-    async_event_handler *first_handler;\n-\n-    /* Pointer to last in handler list.  */\n-    async_event_handler *last_handler;\n-  }\n-async_event_handler_list;\n-\n-static int invoke_async_signal_handlers (void);\n static void create_file_handler (int fd, int mask, handler_func *proc,\n \t\t\t\t gdb_client_data client_data);\n-static int check_async_event_handlers (void);\n static int gdb_wait_for_event (int);\n static int update_wait_timeout (void);\n static int poll_timers (void);\n \f\n-\n-/* This event is signalled whenever an asynchronous handler needs to\n-   defer an action to the event loop.  */\n-static struct serial_event *async_signal_handlers_serial_event;\n-\n-/* Callback registered with ASYNC_SIGNAL_HANDLERS_SERIAL_EVENT.  */\n-\n-static void\n-async_signals_handler (int error, gdb_client_data client_data)\n-{\n-  /* Do nothing.  Handlers are run by invoke_async_signal_handlers\n-     from instead.  */\n-}\n-\n-void\n-initialize_async_signal_handlers (void)\n-{\n-  async_signal_handlers_serial_event = make_serial_event ();\n-\n-  add_file_handler (serial_event_fd (async_signal_handlers_serial_event),\n-\t\t    async_signals_handler, NULL);\n-}\n-\n /* Process one high level event.  If nothing is ready at this time,\n    wait for something to happen (via gdb_wait_for_event), then process\n    it.  Returns >0 if something was done otherwise returns <0 (this\n@@ -800,216 +704,6 @@ gdb_wait_for_event (int block)\n   return 0;\n }\n \f\n-\n-/* Create an asynchronous handler, allocating memory for it.\n-   Return a pointer to the newly created handler.\n-   This pointer will be used to invoke the handler by \n-   invoke_async_signal_handler.\n-   PROC is the function to call with CLIENT_DATA argument \n-   whenever the handler is invoked.  */\n-async_signal_handler *\n-create_async_signal_handler (sig_handler_func * proc,\n-\t\t\t     gdb_client_data client_data)\n-{\n-  async_signal_handler *async_handler_ptr;\n-\n-  async_handler_ptr = XNEW (async_signal_handler);\n-  async_handler_ptr->ready = 0;\n-  async_handler_ptr->next_handler = NULL;\n-  async_handler_ptr->proc = proc;\n-  async_handler_ptr->client_data = client_data;\n-  if (sighandler_list.first_handler == NULL)\n-    sighandler_list.first_handler = async_handler_ptr;\n-  else\n-    sighandler_list.last_handler->next_handler = async_handler_ptr;\n-  sighandler_list.last_handler = async_handler_ptr;\n-  return async_handler_ptr;\n-}\n-\n-/* Mark the handler (ASYNC_HANDLER_PTR) as ready.  This information\n-   will be used when the handlers are invoked, after we have waited\n-   for some event.  The caller of this function is the interrupt\n-   handler associated with a signal.  */\n-void\n-mark_async_signal_handler (async_signal_handler * async_handler_ptr)\n-{\n-  async_handler_ptr->ready = 1;\n-  serial_event_set (async_signal_handlers_serial_event);\n-}\n-\n-/* See event-loop.h.  */\n-\n-void\n-clear_async_signal_handler (async_signal_handler *async_handler_ptr)\n-{\n-  async_handler_ptr->ready = 0;\n-}\n-\n-/* See event-loop.h.  */\n-\n-int\n-async_signal_handler_is_marked (async_signal_handler *async_handler_ptr)\n-{\n-  return async_handler_ptr->ready;\n-}\n-\n-/* Call all the handlers that are ready.  Returns true if any was\n-   indeed ready.  */\n-\n-static int\n-invoke_async_signal_handlers (void)\n-{\n-  async_signal_handler *async_handler_ptr;\n-  int any_ready = 0;\n-\n-  /* We're going to handle all pending signals, so no need to wake up\n-     the event loop again the next time around.  Note this must be\n-     cleared _before_ calling the callbacks, to avoid races.  */\n-  serial_event_clear (async_signal_handlers_serial_event);\n-\n-  /* Invoke all ready handlers.  */\n-\n-  while (1)\n-    {\n-      for (async_handler_ptr = sighandler_list.first_handler;\n-\t   async_handler_ptr != NULL;\n-\t   async_handler_ptr = async_handler_ptr->next_handler)\n-\t{\n-\t  if (async_handler_ptr->ready)\n-\t    break;\n-\t}\n-      if (async_handler_ptr == NULL)\n-\tbreak;\n-      any_ready = 1;\n-      async_handler_ptr->ready = 0;\n-      /* Async signal handlers have no connection to whichever was the\n-\t current UI, and thus always run on the main one.  */\n-      current_ui = main_ui;\n-      (*async_handler_ptr->proc) (async_handler_ptr->client_data);\n-    }\n-\n-  return any_ready;\n-}\n-\n-/* Delete an asynchronous handler (ASYNC_HANDLER_PTR).\n-   Free the space allocated for it.  */\n-void\n-delete_async_signal_handler (async_signal_handler ** async_handler_ptr)\n-{\n-  async_signal_handler *prev_ptr;\n-\n-  if (sighandler_list.first_handler == (*async_handler_ptr))\n-    {\n-      sighandler_list.first_handler = (*async_handler_ptr)->next_handler;\n-      if (sighandler_list.first_handler == NULL)\n-\tsighandler_list.last_handler = NULL;\n-    }\n-  else\n-    {\n-      prev_ptr = sighandler_list.first_handler;\n-      while (prev_ptr && prev_ptr->next_handler != (*async_handler_ptr))\n-\tprev_ptr = prev_ptr->next_handler;\n-      gdb_assert (prev_ptr);\n-      prev_ptr->next_handler = (*async_handler_ptr)->next_handler;\n-      if (sighandler_list.last_handler == (*async_handler_ptr))\n-\tsighandler_list.last_handler = prev_ptr;\n-    }\n-  xfree ((*async_handler_ptr));\n-  (*async_handler_ptr) = NULL;\n-}\n-\n-/* Create an asynchronous event handler, allocating memory for it.\n-   Return a pointer to the newly created handler.  PROC is the\n-   function to call with CLIENT_DATA argument whenever the handler is\n-   invoked.  */\n-async_event_handler *\n-create_async_event_handler (async_event_handler_func *proc,\n-\t\t\t    gdb_client_data client_data)\n-{\n-  async_event_handler *h;\n-\n-  h = XNEW (struct async_event_handler);\n-  h->ready = 0;\n-  h->next_handler = NULL;\n-  h->proc = proc;\n-  h->client_data = client_data;\n-  if (async_event_handler_list.first_handler == NULL)\n-    async_event_handler_list.first_handler = h;\n-  else\n-    async_event_handler_list.last_handler->next_handler = h;\n-  async_event_handler_list.last_handler = h;\n-  return h;\n-}\n-\n-/* Mark the handler (ASYNC_HANDLER_PTR) as ready.  This information\n-   will be used by gdb_do_one_event.  The caller will be whoever\n-   created the event source, and wants to signal that the event is\n-   ready to be handled.  */\n-void\n-mark_async_event_handler (async_event_handler *async_handler_ptr)\n-{\n-  async_handler_ptr->ready = 1;\n-}\n-\n-/* See event-loop.h.  */\n-\n-void\n-clear_async_event_handler (async_event_handler *async_handler_ptr)\n-{\n-  async_handler_ptr->ready = 0;\n-}\n-\n-/* Check if asynchronous event handlers are ready, and call the\n-   handler function for one that is.  */\n-\n-static int\n-check_async_event_handlers (void)\n-{\n-  async_event_handler *async_handler_ptr;\n-\n-  for (async_handler_ptr = async_event_handler_list.first_handler;\n-       async_handler_ptr != NULL;\n-       async_handler_ptr = async_handler_ptr->next_handler)\n-    {\n-      if (async_handler_ptr->ready)\n-\t{\n-\t  async_handler_ptr->ready = 0;\n-\t  (*async_handler_ptr->proc) (async_handler_ptr->client_data);\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n-}\n-\n-/* Delete an asynchronous handler (ASYNC_HANDLER_PTR).\n-   Free the space allocated for it.  */\n-void\n-delete_async_event_handler (async_event_handler **async_handler_ptr)\n-{\n-  async_event_handler *prev_ptr;\n-\n-  if (async_event_handler_list.first_handler == *async_handler_ptr)\n-    {\n-      async_event_handler_list.first_handler\n-\t= (*async_handler_ptr)->next_handler;\n-      if (async_event_handler_list.first_handler == NULL)\n-\tasync_event_handler_list.last_handler = NULL;\n-    }\n-  else\n-    {\n-      prev_ptr = async_event_handler_list.first_handler;\n-      while (prev_ptr && prev_ptr->next_handler != *async_handler_ptr)\n-\tprev_ptr = prev_ptr->next_handler;\n-      gdb_assert (prev_ptr);\n-      prev_ptr->next_handler = (*async_handler_ptr)->next_handler;\n-      if (async_event_handler_list.last_handler == (*async_handler_ptr))\n-\tasync_event_handler_list.last_handler = prev_ptr;\n-    }\n-  xfree (*async_handler_ptr);\n-  *async_handler_ptr = NULL;\n-}\n-\n /* Create a timer that will expire in MS milliseconds from now.  When\n    the timer is ready, PROC will be executed.  At creation, the timer\n    is added to the timers queue.  This queue is kept sorted in order"
    },
    {
      "sha": "2eaaa0c8b6049212a0ae2116ba677f2faa23aa1a",
      "filename": "gdb/event-loop.h",
      "status": "modified",
      "additions": 8,
      "deletions": 39,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/event-loop.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/event-loop.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/event-loop.h?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -71,11 +71,7 @@\n    Corollary tasks are the creation and deletion of event sources.  */\n \n typedef void *gdb_client_data;\n-struct async_signal_handler;\n-struct async_event_handler;\n typedef void (handler_func) (int, gdb_client_data);\n-typedef void (sig_handler_func) (gdb_client_data);\n-typedef void (async_event_handler_func) (gdb_client_data);\n typedef void (timer_handler_func) (gdb_client_data);\n \n /* Exported functions from event-loop.c */\n@@ -84,50 +80,23 @@ extern int gdb_do_one_event (void);\n extern void delete_file_handler (int fd);\n extern void add_file_handler (int fd, handler_func *proc, \n \t\t\t      gdb_client_data client_data);\n-extern struct async_signal_handler *\n-  create_async_signal_handler (sig_handler_func *proc, \n-\t\t\t       gdb_client_data client_data);\n-extern void delete_async_signal_handler (struct async_signal_handler **);\n extern int create_timer (int milliseconds, \n \t\t\t timer_handler_func *proc, \n \t\t\t gdb_client_data client_data);\n extern void delete_timer (int id);\n \n-/* Call the handler from HANDLER the next time through the event\n-   loop.  */\n-extern void mark_async_signal_handler (struct async_signal_handler *handler);\n+/* Must be defined by client.  */\n \n-/* Returns true if HANDLER is marked ready.  */\n+extern void handle_event_loop_exception (const gdb_exception &);\n \n-extern int\n-  async_signal_handler_is_marked (struct async_signal_handler *handler);\n+/* Must be defined by client.  Returns true if any signal handler was\n+   ready.  */\n \n-/* Mark HANDLER as NOT ready.  */\n+extern int invoke_async_signal_handlers ();\n \n-extern void clear_async_signal_handler (struct async_signal_handler *handler);\n+/* Must be defined by client.  Returns true if any event handler was\n+   ready.  */\n \n-/* Create and register an asynchronous event source in the event loop,\n-   and set PROC as its callback.  CLIENT_DATA is passed as argument to\n-   PROC upon its invocation.  Returns a pointer to an opaque structure\n-   used to mark as ready and to later delete this event source from\n-   the event loop.  */\n-extern struct async_event_handler *\n-  create_async_event_handler (async_event_handler_func *proc,\n-\t\t\t      gdb_client_data client_data);\n-\n-/* Remove the event source pointed by HANDLER_PTR created by\n-   CREATE_ASYNC_EVENT_HANDLER from the event loop, and release it.  */\n-extern void\n-  delete_async_event_handler (struct async_event_handler **handler_ptr);\n-\n-/* Call the handler from HANDLER the next time through the event\n-   loop.  */\n-extern void mark_async_event_handler (struct async_event_handler *handler);\n-\n-/* Mark the handler (ASYNC_HANDLER_PTR) as NOT ready.  */\n-\n-extern void clear_async_event_handler (struct async_event_handler *handler);\n-\n-extern void initialize_async_signal_handlers (void);\n+extern int check_async_event_handlers ();\n \n #endif /* EVENT_LOOP_H */"
    },
    {
      "sha": "5d7a77b5b4bd92e27e3091ae478bbb578ffbda68",
      "filename": "gdb/event-top.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/event-top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/event-top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/event-top.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -41,6 +41,7 @@\n #include \"ser-event.h\"\n #include \"gdbsupport/gdb_select.h\"\n #include \"gdbsupport/gdb-sigmask.h\"\n+#include \"async-event.h\"\n \n /* readline include files.  */\n #include \"readline/readline.h\""
    },
    {
      "sha": "fc76649287c8ec6aa79827811cb976826091e251",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -66,6 +66,7 @@\n #include \"gdbsupport/forward-scope-exit.h\"\n #include \"gdbsupport/gdb_select.h\"\n #include <unordered_map>\n+#include \"async-event.h\"\n \n /* Prototypes for local functions */\n "
    },
    {
      "sha": "acc5f3ba6634d4d07a2fbad3b26cd5b2419637fd",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -42,6 +42,7 @@\n #include <algorithm>\n #include \"gdbarch.h\"\n #include \"cli/cli-style.h\"\n+#include \"async-event.h\"\n \n static const target_info record_btrace_target_info = {\n   \"record-btrace\","
    },
    {
      "sha": "4e1961af1bf8d7dfe50cd0406951229f643df448",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -38,6 +38,7 @@\n #include \"infrun.h\"\n #include \"gdbsupport/gdb_unlinker.h\"\n #include \"gdbsupport/byte-vector.h\"\n+#include \"async-event.h\"\n \n #include <signal.h>\n "
    },
    {
      "sha": "f41ebc3d7352fb79b2bb6727a846d711cff96a7d",
      "filename": "gdb/remote-notif.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/remote-notif.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/remote-notif.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-notif.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -40,6 +40,7 @@\n #include \"inferior.h\"\n #include \"infrun.h\"\n #include \"gdbcmd.h\"\n+#include \"async-event.h\"\n \n bool notif_debug = false;\n "
    },
    {
      "sha": "d4919d99a90ea349e9cf0133d409475281cf16d3",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -77,6 +77,7 @@\n #include \"gdbsupport/byte-vector.h\"\n #include <algorithm>\n #include <unordered_map>\n+#include \"async-event.h\"\n \n /* The remote target.  */\n "
    },
    {
      "sha": "df7480fc57c71fffc9524b0e1534183cac3469bd",
      "filename": "gdb/tui/tui-win.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/tui/tui-win.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/93b54c8ed3644a6604c5244faddf5dae7f60a743/gdb/tui/tui-win.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tui/tui-win.c?ref=93b54c8ed3644a6604c5244faddf5dae7f60a743",
      "patch": "@@ -35,6 +35,7 @@\n #include \"source.h\"\n #include \"event-loop.h\"\n #include \"gdbcmd.h\"\n+#include \"async-event.h\"\n \n #include \"tui/tui.h\"\n #include \"tui/tui-io.h\""
    }
  ]
}