{
  "sha": "33d16dd987d16fe1eb289853e5a444192bb31d9e",
  "node_id": "C_kwDOANOeidoAKDMzZDE2ZGQ5ODdkMTZmZTFlYjI4OTg1M2U1YTQ0NDE5MmJiMzFkOWU",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-08-30T15:49:49Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-10-01T02:05:57Z"
    },
    "message": "gdb: remove TYPE_FIELD_NAME and FIELD_NAME macros\n\nRemove the `TYPE_FIELD_NAME` and `FIELD_NAME` macros, changing all the\ncall sites to use field::name directly.\n\nChange-Id: I6900ae4e1ffab1396e24fb3298e94bf123826ca6",
    "tree": {
      "sha": "06c5ec20fad9309ab4dace3b6c659fa518d272af",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/06c5ec20fad9309ab4dace3b6c659fa518d272af"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/33d16dd987d16fe1eb289853e5a444192bb31d9e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/33d16dd987d16fe1eb289853e5a444192bb31d9e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/33d16dd987d16fe1eb289853e5a444192bb31d9e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/33d16dd987d16fe1eb289853e5a444192bb31d9e/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d3fd12dfc52cf4cbb910830e3ff60dca111f7468",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d3fd12dfc52cf4cbb910830e3ff60dca111f7468"
    }
  ],
  "stats": {
    "total": 313,
    "additions": 155,
    "deletions": 158
  },
  "files": [
    {
      "sha": "1a3ce365d91cb0535abec34080fe95a59f412094",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 27,
      "deletions": 27,
      "changes": 54,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -468,7 +468,7 @@ ada_get_field_index (const struct type *type, const char *field_name,\n   struct type *struct_type = check_typedef ((struct type *) type);\n \n   for (fieldno = 0; fieldno < struct_type->num_fields (); fieldno++)\n-    if (field_name_match (TYPE_FIELD_NAME (struct_type, fieldno), field_name))\n+    if (field_name_match (struct_type->field (fieldno).name (), field_name))\n       return fieldno;\n \n   if (!maybe_missing)\n@@ -1375,13 +1375,13 @@ ada_fixup_array_indexes_type (struct type *index_desc_type)\n      is not equal to the field name.  */\n   if (index_desc_type->field (0).type ()->name () != NULL\n       && strcmp (index_desc_type->field (0).type ()->name (),\n-\t\t TYPE_FIELD_NAME (index_desc_type, 0)) == 0)\n+\t\t index_desc_type->field (0).name ()) == 0)\n     return;\n \n   /* Fixup each field of INDEX_DESC_TYPE.  */\n   for (i = 0; i < index_desc_type->num_fields (); i++)\n    {\n-     const char *name = TYPE_FIELD_NAME (index_desc_type, i);\n+     const char *name = index_desc_type->field (i).name ();\n      struct type *raw_type = ada_check_typedef (ada_find_any_type (name));\n \n      if (raw_type)\n@@ -4644,16 +4644,16 @@ ada_identical_enum_types_p (struct type *type1, struct type *type2)\n      suffix).  */\n   for (i = 0; i < type1->num_fields (); i++)\n     {\n-      const char *name_1 = TYPE_FIELD_NAME (type1, i);\n-      const char *name_2 = TYPE_FIELD_NAME (type2, i);\n+      const char *name_1 = type1->field (i).name ();\n+      const char *name_2 = type2->field (i).name ();\n       int len_1 = strlen (name_1);\n       int len_2 = strlen (name_2);\n \n-      ada_remove_trailing_digits (TYPE_FIELD_NAME (type1, i), &len_1);\n-      ada_remove_trailing_digits (TYPE_FIELD_NAME (type2, i), &len_2);\n+      ada_remove_trailing_digits (type1->field (i).name (), &len_1);\n+      ada_remove_trailing_digits (type2->field (i).name (), &len_2);\n       if (len_1 != len_2\n-\t  || strncmp (TYPE_FIELD_NAME (type1, i),\n-\t\t      TYPE_FIELD_NAME (type2, i),\n+\t  || strncmp (type1->field (i).name (),\n+\t\t      type2->field (i).name (),\n \t\t      len_1) != 0)\n \treturn 0;\n     }\n@@ -5972,7 +5972,7 @@ ada_is_ignored_field (struct type *type, int field_num)\n \n   /* Check the name of that field.  */\n   {\n-    const char *name = TYPE_FIELD_NAME (type, field_num);\n+    const char *name = type->field (field_num).name ();\n \n     /* Anonymous field names should not be printed.\n        brobecker/2007-02-20: I don't think this can actually happen\n@@ -6331,7 +6331,7 @@ ada_parent_type (struct type *type)\n int\n ada_is_parent_field (struct type *type, int field_num)\n {\n-  const char *name = TYPE_FIELD_NAME (ada_check_typedef (type), field_num);\n+  const char *name = ada_check_typedef (type)->field (field_num).name ();\n \n   return (name != NULL\n \t  && (startswith (name, \"PARENT\")\n@@ -6347,7 +6347,7 @@ ada_is_parent_field (struct type *type, int field_num)\n int\n ada_is_wrapper_field (struct type *type, int field_num)\n {\n-  const char *name = TYPE_FIELD_NAME (type, field_num);\n+  const char *name = type->field (field_num).name ();\n \n   if (name != NULL && strcmp (name, \"RETVAL\") == 0)\n     {\n@@ -6406,7 +6406,7 @@ ada_variant_discrim_type (struct type *var_type, struct type *outer_type)\n static int\n ada_is_others_clause (struct type *type, int field_num)\n {\n-  const char *name = TYPE_FIELD_NAME (type, field_num);\n+  const char *name = type->field (field_num).name ();\n \n   return (name != NULL && name[0] == 'O');\n }\n@@ -6511,7 +6511,7 @@ ada_scan_number (const char str[], int k, LONGEST * R, int *new_k)\n static int\n ada_in_variant (LONGEST val, struct type *type, int field_num)\n {\n-  const char *name = TYPE_FIELD_NAME (type, field_num);\n+  const char *name = type->field (field_num).name ();\n   int p;\n \n   p = 0;\n@@ -6671,7 +6671,7 @@ find_struct_field (const char *name, struct type *type, int offset,\n     {\n       int bit_pos = TYPE_FIELD_BITPOS (type, i);\n       int fld_offset = offset + bit_pos / 8;\n-      const char *t_field_name = TYPE_FIELD_NAME (type, i);\n+      const char *t_field_name = type->field (i).name ();\n \n       if (t_field_name == NULL)\n \tcontinue;\n@@ -6781,7 +6781,7 @@ ada_search_struct_field (const char *name, struct value *arg, int offset,\n   type = ada_check_typedef (type);\n   for (i = 0; i < type->num_fields (); i += 1)\n     {\n-      const char *t_field_name = TYPE_FIELD_NAME (type, i);\n+      const char *t_field_name = type->field (i).name ();\n \n       if (t_field_name == NULL)\n \tcontinue;\n@@ -6881,7 +6881,7 @@ ada_index_struct_field_1 (int *index_p, struct value *arg, int offset,\n \n   for (i = 0; i < type->num_fields (); i += 1)\n     {\n-      if (TYPE_FIELD_NAME (type, i) == NULL)\n+      if (type->field (i).name () == NULL)\n \tcontinue;\n       else if (ada_is_wrapper_field (type, i))\n \t{\n@@ -6974,7 +6974,7 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n \n   for (i = 0; i < type->num_fields (); i += 1)\n     {\n-      const char *t_field_name = TYPE_FIELD_NAME (type, i);\n+      const char *t_field_name = type->field (i).name ();\n       struct type *t;\n \n       if (t_field_name == NULL)\n@@ -7016,7 +7016,7 @@ ada_lookup_struct_elt_type (struct type *type, const char *name, int refok,\n \t\t NOT wrapped in a struct, since the compiler sometimes\n \t\t generates these for unchecked variant types.  Revisit\n \t\t if the compiler changes this practice.  */\n-\t      const char *v_field_name = TYPE_FIELD_NAME (field_type, j);\n+\t      const char *v_field_name = field_type->field (j).name ();\n \n \t      if (v_field_name != NULL \n \t\t  && field_name_match (v_field_name, name))\n@@ -7182,7 +7182,7 @@ ada_coerce_ref (struct value *val0)\n static unsigned int\n field_alignment (struct type *type, int f)\n {\n-  const char *name = TYPE_FIELD_NAME (type, f);\n+  const char *name = type->field (f).name ();\n   int len;\n   int align_offset;\n \n@@ -7425,7 +7425,7 @@ dynamic_template_type (struct type *type)\n static int\n is_dynamic_field (struct type *templ_type, int field_num)\n {\n-  const char *name = TYPE_FIELD_NAME (templ_type, field_num);\n+  const char *name = templ_type->field (field_num).name ();\n \n   return name != NULL\n     && templ_type->field (field_num).type ()->code () == TYPE_CODE_PTR\n@@ -7601,7 +7601,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t  ada_ensure_varsize_limit (field_type);\n \n \t  rtype->field (f).set_type (field_type);\n-\t  rtype->field (f).set_name (TYPE_FIELD_NAME (type, f));\n+\t  rtype->field (f).set_name (type->field (f).name ());\n \t  /* The multiplication can potentially overflow.  But because\n \t     the field length has been size-checked just above, and\n \t     assuming that the maximum size is a reasonable value,\n@@ -7624,7 +7624,7 @@ ada_template_to_fixed_record_type_1 (struct type *type,\n \t     to distinguish between the two options.  Stripping it\n \t     would prevent us from printing this field appropriately.  */\n \t  rtype->field (f).set_type (type->field (f).type ());\n-\t  rtype->field (f).set_name (TYPE_FIELD_NAME (type, f));\n+\t  rtype->field (f).set_name (type->field (f).name ());\n \t  if (TYPE_FIELD_BITSIZE (type, f) > 0)\n \t    fld_bit_len =\n \t      TYPE_FIELD_BITSIZE (rtype, f) = TYPE_FIELD_BITSIZE (type, f);\n@@ -7802,7 +7802,7 @@ template_to_static_fixed_type (struct type *type0)\n \t      TYPE_LENGTH (type) = 0;\n \t    }\n \t  type->field (f).set_type (new_type);\n-\t  type->field (f).set_name (TYPE_FIELD_NAME (type0, f));\n+\t  type->field (f).set_name (type0->field (f).name ());\n \t}\n     }\n \n@@ -8691,7 +8691,7 @@ ada_is_aligner_type (struct type *type)\n \n   return (type->code () == TYPE_CODE_STRUCT\n \t  && type->num_fields () == 1\n-\t  && strcmp (TYPE_FIELD_NAME (type, 0), \"F\") == 0);\n+\t  && strcmp (type->field (0).name (), \"F\") == 0);\n }\n \n /* If there is an ___XVS-convention type parallel to SUBTYPE, return\n@@ -8732,7 +8732,7 @@ ada_get_base_type (struct type *raw_type)\n       /* This is an older encoding form where the base type needs to be\n \t looked up by name.  We prefer the newer encoding because it is\n \t more efficient.  */\n-      raw_real_type = ada_find_any_type (TYPE_FIELD_NAME (real_type_namer, 0));\n+      raw_real_type = ada_find_any_type (real_type_namer->field (0).name ());\n       if (raw_real_type == NULL)\n \treturn raw_type;\n       else\n@@ -10229,7 +10229,7 @@ convert_char_literal (struct type *type, LONGEST val)\n \t have a name like \"pkg__QUxx\".  This is safe enough because we\n \t already have the correct type, and because mangling means\n \t there can't be clashes.  */\n-      const char *ename = TYPE_FIELD_NAME (type, f);\n+      const char *ename = type->field (f).name ();\n       size_t elen = strlen (ename);\n \n       if (elen >= len && strcmp (name, ename + elen - len) == 0)"
    },
    {
      "sha": "6bc8912422b5a05fc4c2ca4866de86ccb4913289",
      "filename": "gdb/ada-typeprint.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ada-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ada-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-typeprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -326,7 +326,7 @@ print_enum_type (struct type *type, struct ui_file *stream)\n       if (i)\n \tfprintf_filtered (stream, \", \");\n       wrap_here (\"    \");\n-      fputs_styled (ada_enum_name (TYPE_FIELD_NAME (type, i)),\n+      fputs_styled (ada_enum_name (type->field (i).name ()),\n \t\t    variable_name_style.style (), stream);\n       if (lastval != TYPE_FIELD_ENUMVAL (type, i))\n \t{\n@@ -439,7 +439,7 @@ print_choices (struct type *type, int field_num, struct ui_file *stream,\n {\n   int have_output;\n   int p;\n-  const char *name = TYPE_FIELD_NAME (type, field_num);\n+  const char *name = type->field (field_num).name ();\n \n   have_output = 0;\n \n@@ -620,7 +620,7 @@ print_selected_record_field_types (struct type *type, struct type *outer_type,\n \t  flds += 1;\n \t  fprintf_filtered (stream, \"\\n%*s\", level + 4, \"\");\n \t  ada_print_type (type->field (i).type (),\n-\t\t\t  TYPE_FIELD_NAME (type, i),\n+\t\t\t  type->field (i).name (),\n \t\t\t  stream, show - 1, level + 4, flags);\n \t  fprintf_filtered (stream, \";\");\n \t}\n@@ -682,7 +682,7 @@ print_variant_part (const variant_part &part,\n     name = \"?\";\n   else\n     {\n-      name = TYPE_FIELD_NAME (type, part.discriminant_index);\n+      name = type->field (part.discriminant_index).name ();;\n       discr_type = type->field (part.discriminant_index).type ();\n     }\n \n@@ -851,7 +851,7 @@ print_unchecked_union_type (struct type *type, struct ui_file *stream,\n \t  fprintf_filtered (stream, \"\\n%*swhen ? =>\\n%*s\", level + 8, \"\",\n \t\t\t    level + 12, \"\");\n \t  ada_print_type (type->field (i).type (),\n-\t\t\t  TYPE_FIELD_NAME (type, i),\n+\t\t\t  type->field (i).name (),\n \t\t\t  stream, show - 1, level + 12, flags);\n \t  fprintf_filtered (stream, \";\");\n \t}"
    },
    {
      "sha": "979487f515e2bc54478df76dd4af12bc8b528f79",
      "filename": "gdb/ada-valprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ada-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ada-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-valprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -388,7 +388,7 @@ ada_print_scalar (struct type *type, LONGEST val, struct ui_file *stream)\n \t}\n       if (i < len)\n \t{\n-\t  fputs_styled (ada_enum_name (TYPE_FIELD_NAME (type, i)),\n+\t  fputs_styled (ada_enum_name (type->field (i).name ()),\n \t\t\tvariable_name_style.style (), stream);\n \t}\n       else\n@@ -619,8 +619,8 @@ print_field_values (struct value *value, struct value *outer_value,\n \n       annotate_field_begin (type->field (i).type ());\n       fprintf_filtered (stream, \"%.*s\",\n-\t\t\tada_name_prefix_len (TYPE_FIELD_NAME (type, i)),\n-\t\t\tTYPE_FIELD_NAME (type, i));\n+\t\t\tada_name_prefix_len (type->field (i).name ()),\n+\t\t\ttype->field (i).name ());\n       annotate_field_name_end ();\n       fputs_filtered (\" => \", stream);\n       annotate_field_value ();\n@@ -841,7 +841,7 @@ ada_val_print_enum (struct value *value, struct ui_file *stream, int recurse,\n \n   if (i < len)\n     {\n-      const char *name = ada_enum_name (TYPE_FIELD_NAME (type, i));\n+      const char *name = ada_enum_name (type->field (i).name ());\n \n       if (name[0] == '\\'')\n \tfprintf_filtered (stream, \"%ld %ps\", (long) val,"
    },
    {
      "sha": "a4c29c5c5dd27434252ab5c9181f314eea8e35fa",
      "filename": "gdb/ada-varobj.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ada-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ada-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-varobj.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -502,7 +502,7 @@ ada_varobj_describe_struct_child (struct value *parent_value,\n \t\t name, except that we need to strip suffixes from it.\n \t\t For instance, fields with alignment constraints will\n \t\t have an __XVA suffix added to them.  */\n-\t      const char *field_name = TYPE_FIELD_NAME (parent_type, fieldno);\n+\t      const char *field_name = parent_type->field (fieldno).name ();\n \t      int child_name_len = ada_name_prefix_len (field_name);\n \n \t      *child_name = string_printf (\"%.*s\", child_name_len, field_name);\n@@ -522,7 +522,7 @@ ada_varobj_describe_struct_child (struct value *parent_value,\n \t\t name, except that we need to strip suffixes from it.\n \t\t For instance, fields with alignment constraints will\n \t\t have an __XVA suffix added to them.  */\n-\t      const char *field_name = TYPE_FIELD_NAME (parent_type, fieldno);\n+\t      const char *field_name = parent_type->field (fieldno).name ();\n \t      int child_name_len = ada_name_prefix_len (field_name);\n \n \t      *child_path_expr ="
    },
    {
      "sha": "e07ee3ab6965d883ffb12b145095d0e4ff104f47",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -1337,7 +1337,7 @@ gen_struct_ref_recursive (struct agent_expr *ax, struct axs_value *value,\n \n   for (i = type->num_fields () - 1; i >= nbases; i--)\n     {\n-      const char *this_name = TYPE_FIELD_NAME (type, i);\n+      const char *this_name = type->field (i).name ();\n \n       if (this_name)\n \t{\n@@ -1481,7 +1481,7 @@ gen_struct_elt_for_reference (struct agent_expr *ax, struct axs_value *value,\n \n   for (i = t->num_fields () - 1; i >= TYPE_N_BASECLASSES (t); i--)\n     {\n-      const char *t_field_name = TYPE_FIELD_NAME (t, i);\n+      const char *t_field_name = t->field (i).name ();\n \n       if (t_field_name && strcmp (t_field_name, fieldname) == 0)\n \t{"
    },
    {
      "sha": "107d200bd557b6767025698967ca4ce838570469",
      "filename": "gdb/c-typeprint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/c-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/c-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-typeprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -1206,7 +1206,7 @@ c_type_print_base_struct_union (struct type *type, struct ui_file *stream,\n \t    }\n \n \t  c_print_type_1 (type->field (i).type (),\n-\t\t\t  TYPE_FIELD_NAME (type, i),\n+\t\t\t  type->field (i).name (),\n \t\t\t  stream, newshow, level + 4,\n \t\t\t  language, &local_flags, &local_podata);\n \n@@ -1602,7 +1602,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t      if (i)\n \t\tfprintf_filtered (stream, \", \");\n \t      wrap_here (\"    \");\n-\t      fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t      fputs_styled (type->field (i).name (),\n \t\t\t    variable_name_style.style (), stream);\n \t      if (lastval != TYPE_FIELD_ENUMVAL (type, i))\n \t\t{\n@@ -1650,7 +1650,7 @@ c_type_print_base_1 (struct type *type, struct ui_file *stream,\n \t\t/* We pass \"show\" here and not \"show - 1\" to get enum types\n \t\t   printed.  There's no other way to see them.  */\n \t\tc_print_type_1 (type->field (i).type (),\n-\t\t\t\tTYPE_FIELD_NAME (type, i),\n+\t\t\t\ttype->field (i).name (),\n \t\t\t\tstream, show, level + 4,\n \t\t\t\tlanguage, &local_flags, podata);\n \t\tfprintf_filtered (stream, \" @%s\","
    },
    {
      "sha": "11af9ecf6791655562faec80584a401683f0fe97",
      "filename": "gdb/c-varobj.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/c-varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/c-varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-varobj.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -165,7 +165,7 @@ c_is_path_expr_parent (const struct varobj *var)\n \t      const char *field_name;\n \n \t      gdb_assert (var->index < parent_type->num_fields ());\n-\t      field_name = TYPE_FIELD_NAME (parent_type, var->index);\n+\t      field_name = parent_type->field (var->index).name ();\n \t      return !(field_name == NULL || *field_name == '\\0');\n \t    }\n \t}\n@@ -341,7 +341,7 @@ c_describe_child (const struct varobj *parent, int index,\n \n \t/* If the type is anonymous and the field has no name,\n \t   set an appropriate name.  */\n-\tfield_name = TYPE_FIELD_NAME (type, index);\n+\tfield_name = type->field (index).name ();\n \tif (field_name == NULL || *field_name == '\\0')\n \t  {\n \t    if (cname)\n@@ -761,7 +761,7 @@ cplus_describe_child (const struct varobj *parent, int index,\n \n \t  /* If the type is anonymous and the field has no name,\n \t     set an appropriate name.  */\n-\t  field_name = TYPE_FIELD_NAME (type, type_index);\n+\t  field_name = type->field (type_index).name ();\n \t  if (field_name == NULL || *field_name == '\\0')\n \t    {\n \t      if (cname)\n@@ -780,7 +780,7 @@ cplus_describe_child (const struct varobj *parent, int index,\n \t  else\n \t    {\n \t      if (cname)\n-\t\t*cname = TYPE_FIELD_NAME (type, type_index);\n+\t\t*cname = type->field (type_index).name ();\n \n \t      if (cfull_expression)\n \t\t*cfull_expression\n@@ -798,7 +798,7 @@ cplus_describe_child (const struct varobj *parent, int index,\n \t{\n \t  /* This is a baseclass.  */\n \t  if (cname)\n-\t    *cname = TYPE_FIELD_NAME (type, index);\n+\t    *cname = type->field (index).name ();\n \n \t  if (cvalue && value)\n \t    *cvalue = value_cast (type->field (index).type (), value);\n@@ -827,7 +827,7 @@ cplus_describe_child (const struct varobj *parent, int index,\n \t\t 'class' keyword.  See PR mi/11912  */\n \t      *cfull_expression = string_printf (\"(%s(class %s%s) %s)\",\n \t\t\t\t\t\t ptr,\n-\t\t\t\t\t\t TYPE_FIELD_NAME (type, index),\n+\t\t\t\t\t\t type->field (index).name (),\n \t\t\t\t\t\t ptr,\n \t\t\t\t\t\t parent_expression);\n \t    }"
    },
    {
      "sha": "e9e5398b83a12f712187a915b7a983b163d5f34e",
      "filename": "gdb/compile/compile-c-types.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/compile/compile-c-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/compile/compile-c-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-c-types.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -112,7 +112,7 @@ convert_struct_or_union (compile_c_instance *context, struct type *type)\n       if (bitsize == 0)\n \tbitsize = 8 * TYPE_LENGTH (type->field (i).type ());\n       context->plugin ().build_add_field (result,\n-\t\t\t\t\t  TYPE_FIELD_NAME (type, i),\n+\t\t\t\t\t  type->field (i).name (),\n \t\t\t\t\t  field_type,\n \t\t\t\t\t  bitsize,\n \t\t\t\t\t  TYPE_FIELD_BITPOS (type, i));\n@@ -137,7 +137,7 @@ convert_enum (compile_c_instance *context, struct type *type)\n   for (i = 0; i < type->num_fields (); ++i)\n     {\n       context->plugin ().build_add_enum_constant\n-\t(result, TYPE_FIELD_NAME (type, i), TYPE_FIELD_ENUMVAL (type, i));\n+\t(result, type->field (i).name (), TYPE_FIELD_ENUMVAL (type, i));\n     }\n \n   context->plugin ().finish_enum_type (result);"
    },
    {
      "sha": "8871de17f78a1d649d255572d86e0cc6130d8063",
      "filename": "gdb/compile/compile-cplus-types.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/compile/compile-cplus-types.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/compile/compile-cplus-types.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-cplus-types.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -582,7 +582,7 @@ compile_cplus_convert_struct_or_union_members\n {\n   for (int i = TYPE_N_BASECLASSES (type); i < type->num_fields (); ++i)\n     {\n-      const char *field_name = TYPE_FIELD_NAME (type, i);\n+      const char *field_name = type->field (i).name ();\n \n       if (TYPE_FIELD_IGNORE (type, i)\n \t  || TYPE_FIELD_ARTIFICIAL (type, i))\n@@ -937,7 +937,7 @@ compile_cplus_convert_enum (compile_cplus_instance *instance, struct type *type,\n   for (int i = 0; i < type->num_fields (); ++i)\n     {\n       gdb::unique_xmalloc_ptr<char> fname\n-\t= compile_cplus_instance::decl_name (TYPE_FIELD_NAME (type, i));\n+\t= compile_cplus_instance::decl_name (type->field (i).name ());\n \n       if (TYPE_FIELD_LOC_KIND (type, i) != FIELD_LOC_KIND_ENUMVAL\n \t  || fname == nullptr)"
    },
    {
      "sha": "f28bf26a2407090cd077dfd0eb64db1aebba97a4",
      "filename": "gdb/compile/compile-object-load.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/compile/compile-object-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/compile/compile-object-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/compile/compile-object-load.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -552,7 +552,7 @@ store_regs (struct type *regs_type, CORE_ADDR regs_base)\n \n   for (fieldno = 0; fieldno < regs_type->num_fields (); fieldno++)\n     {\n-      const char *reg_name = TYPE_FIELD_NAME (regs_type, fieldno);\n+      const char *reg_name = regs_type->field (fieldno).name ();\n       ULONGEST reg_bitpos = TYPE_FIELD_BITPOS (regs_type, fieldno);\n       ULONGEST reg_bitsize = TYPE_FIELD_BITSIZE (regs_type, fieldno);\n       ULONGEST reg_offset;"
    },
    {
      "sha": "72c900caa28d9a83b04dfcd38d465ec70d472fc2",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -1073,13 +1073,13 @@ add_struct_fields (struct type *type, completion_list &output,\n       if (i < TYPE_N_BASECLASSES (type))\n \tadd_struct_fields (TYPE_BASECLASS (type, i),\n \t\t\t   output, fieldname, namelen);\n-      else if (TYPE_FIELD_NAME (type, i))\n+      else if (type->field (i).name ())\n \t{\n-\t  if (TYPE_FIELD_NAME (type, i)[0] != '\\0')\n+\t  if (type->field (i).name ()[0] != '\\0')\n \t    {\n-\t      if (! strncmp (TYPE_FIELD_NAME (type, i), \n+\t      if (! strncmp (type->field (i).name (), \n \t\t\t     fieldname, namelen))\n-\t\toutput.emplace_back (xstrdup (TYPE_FIELD_NAME (type, i)));\n+\t\toutput.emplace_back (xstrdup (type->field (i).name ()));\n \t    }\n \t  else if (type->field (i).type ()->code () == TYPE_CODE_UNION)\n \t    {"
    },
    {
      "sha": "f6969a5ab9d98979ce32971c21fbbd29a33e242b",
      "filename": "gdb/cp-valprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/cp-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/cp-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-valprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -231,12 +231,12 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n \t    {\n \t      fputs_filtered (\"static \", stream);\n \t      fprintf_symbol_filtered (stream,\n-\t\t\t\t       TYPE_FIELD_NAME (type, i),\n+\t\t\t\t       type->field (i).name (),\n \t\t\t\t       current_language->la_language,\n \t\t\t\t       DMGL_PARAMS | DMGL_ANSI);\n \t    }\n \t  else\n-\t    fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t    fputs_styled (type->field (i).name (),\n \t\t\t  variable_name_style.style (), stream);\n \t  annotate_field_name_end ();\n \n@@ -246,7 +246,7 @@ cp_print_value_fields (struct value *val, struct ui_file *stream,\n \n \t  /* Do not print leading '=' in case of anonymous\n \t     unions.  */\n-\t  if (strcmp (TYPE_FIELD_NAME (type, i), \"\"))\n+\t  if (strcmp (type->field (i).name (), \"\"))\n \t    fputs_filtered (\" = \", stream);\n \t  else\n \t    {\n@@ -710,7 +710,7 @@ cp_print_class_member (const gdb_byte *valaddr, struct type *type,\n       else\n \tc_type_print_base (self_type, stream, 0, 0, &type_print_raw_options);\n       fprintf_filtered (stream, \"::\");\n-      fputs_styled (TYPE_FIELD_NAME (self_type, fieldno),\n+      fputs_styled (self_type->field (fieldno).name (),\n \t\t    variable_name_style.style (), stream);\n     }\n   else"
    },
    {
      "sha": "d46d51b4cd61973a471bc20b3b04bbec5327ca84",
      "filename": "gdb/d-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/d-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/d-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-valprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -36,8 +36,8 @@ dynamic_array_type (struct type *type,\n {\n   if (type->num_fields () == 2\n       && type->field (0).type ()->code () == TYPE_CODE_INT\n-      && strcmp (TYPE_FIELD_NAME (type, 0), \"length\") == 0\n-      && strcmp (TYPE_FIELD_NAME (type, 1), \"ptr\") == 0\n+      && strcmp (type->field (0).name (), \"length\") == 0\n+      && strcmp (type->field (1).name (), \"ptr\") == 0\n       && !value_bits_any_optimized_out (val,\n \t\t\t\t\tTARGET_CHAR_BIT * embedded_offset,\n \t\t\t\t\tTARGET_CHAR_BIT * TYPE_LENGTH (type)))"
    },
    {
      "sha": "f4967a03f9a4c04cb6c23af16eb75d8ce1d087e3",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -9050,9 +9050,9 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \n #define RUST_ENUM_PREFIX \"RUST$ENCODED$ENUM$\"\n   if (type->num_fields () == 1\n-      && startswith (TYPE_FIELD_NAME (type, 0), RUST_ENUM_PREFIX))\n+      && startswith (type->field (0).name (), RUST_ENUM_PREFIX))\n     {\n-      const char *name = TYPE_FIELD_NAME (type, 0) + strlen (RUST_ENUM_PREFIX);\n+      const char *name = type->field (0).name () + strlen (RUST_ENUM_PREFIX);\n \n       /* Decode the field name to find the offset of the\n \t discriminant.  */\n@@ -9070,7 +9070,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t    {\n \t      complaint (_(\"Could not parse Rust enum encoding string \\\"%s\\\"\"\n \t\t\t   \"[in module %s]\"),\n-\t\t\t TYPE_FIELD_NAME (type, 0),\n+\t\t\t type->field (0).name (),\n \t\t\t objfile_name (objfile));\n \t      return;\n \t    }\n@@ -9102,7 +9102,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t(rust_last_path_segment (type->field (1).type ()->name ()));\n       type->field (1).type ()->set_name\n \t(rust_fully_qualify (&objfile->objfile_obstack, type->name (),\n-\t\t\t     TYPE_FIELD_NAME (type, 1)));\n+\t\t\t     type->field (1).name ()));\n \n       const char *dataless_name\n \t= rust_fully_qualify (&objfile->objfile_obstack, type->name (),\n@@ -9121,7 +9121,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n     }\n   /* A union with a single anonymous field is probably an old-style\n      univariant enum.  */\n-  else if (type->num_fields () == 1 && streq (TYPE_FIELD_NAME (type, 0), \"\"))\n+  else if (type->num_fields () == 1 && streq (type->field (0).name (), \"\"))\n     {\n       /* Smash this type to be a structure type.  We have to do this\n \t because the type has already been recorded.  */\n@@ -9154,7 +9154,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t      /* Could be data-less variant, so keep going.  */\n \t      disr_type = nullptr;\n \t    }\n-\t  else if (strcmp (TYPE_FIELD_NAME (disr_type, 0),\n+\t  else if (strcmp (disr_type->field (0).name (),\n \t\t\t   \"RUST$ENUM$DISR\") != 0)\n \t    {\n \t      /* Not a Rust enum.  */\n@@ -9200,7 +9200,7 @@ quirk_rust_enum (struct type *type, struct objfile *objfile)\n \t  if (TYPE_FIELD_LOC_KIND (enum_type, i) == FIELD_LOC_KIND_ENUMVAL)\n \t    {\n \t      const char *name\n-\t\t= rust_last_path_segment (TYPE_FIELD_NAME (enum_type, i));\n+\t\t= rust_last_path_segment (enum_type->field (i).name ());\n \t      discriminant_map[name] = TYPE_FIELD_ENUMVAL (enum_type, i);\n \t    }\n \t}\n@@ -15327,10 +15327,10 @@ quirk_gcc_member_function_pointer (struct type *type, struct objfile *objfile)\n     return;\n \n   /* Check for __pfn and __delta members.  */\n-  if (TYPE_FIELD_NAME (type, 0) == NULL\n-      || strcmp (TYPE_FIELD_NAME (type, 0), \"__pfn\") != 0\n-      || TYPE_FIELD_NAME (type, 1) == NULL\n-      || strcmp (TYPE_FIELD_NAME (type, 1), \"__delta\") != 0)\n+  if (type->field (0).name () == NULL\n+      || strcmp (type->field (0).name (), \"__pfn\") != 0\n+      || type->field (1).name () == NULL\n+      || strcmp (type->field (1).name (), \"__delta\") != 0)\n     return;\n \n   /* Find the type of the method.  */\n@@ -15421,10 +15421,10 @@ quirk_ada_thick_pointer_struct (struct die_info *die, struct dwarf2_cu *cu,\n     return;\n \n   /* Check for P_ARRAY and P_BOUNDS members.  */\n-  if (TYPE_FIELD_NAME (type, 0) == NULL\n-      || strcmp (TYPE_FIELD_NAME (type, 0), \"P_ARRAY\") != 0\n-      || TYPE_FIELD_NAME (type, 1) == NULL\n-      || strcmp (TYPE_FIELD_NAME (type, 1), \"P_BOUNDS\") != 0)\n+  if (type->field (0).name () == NULL\n+      || strcmp (type->field (0).name (), \"P_ARRAY\") != 0\n+      || type->field (1).name () == NULL\n+      || strcmp (type->field (1).name (), \"P_BOUNDS\") != 0)\n     return;\n \n   /* Make sure we're looking at a pointer to an array.  */\n@@ -15937,7 +15937,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t       i >= TYPE_N_BASECLASSES (t);\n \t\t       --i)\n \t\t    {\n-\t\t      const char *fieldname = TYPE_FIELD_NAME (t, i);\n+\t\t      const char *fieldname = t->field (i).name ();\n \n \t\t      if (is_vtable_name (fieldname, cu))\n \t\t\t{\n@@ -15970,7 +15970,7 @@ process_structure_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t\t   i >= TYPE_N_BASECLASSES (type);\n \t\t   --i)\n \t\t{\n-\t\t  if (strcmp (TYPE_FIELD_NAME (type, i), \"__vfp\") == 0)\n+\t\t  if (strcmp (type->field (i).name (), \"__vfp\") == 0)\n \t\t    {\n \t\t      set_type_vptr_fieldno (type, i);\n \t\t      set_type_vptr_basetype (type, type);"
    },
    {
      "sha": "8fe93183021e24fa2cb6207f393e895954b8a52f",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -2298,7 +2298,7 @@ array_operation::evaluate_struct_tuple (struct value *struct_val,\n \terror (_(\"too many initializers\"));\n       field_type = struct_type->field (fieldno).type ();\n       if (field_type->code () == TYPE_CODE_UNION\n-\t  && TYPE_FIELD_NAME (struct_type, fieldno)[0] == '0')\n+\t  && struct_type->field (fieldno).name ()[0] == '0')\n \terror (_(\"don't know which variant you want to set\"));\n \n       /* Here, struct_type is the type of the inner struct,"
    },
    {
      "sha": "1791cb2945119282e5bcac4a2fa48fac9e0e059c",
      "filename": "gdb/f-typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/f-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/f-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-typeprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -406,7 +406,7 @@ f_language::f_type_print_base (struct type *type, struct ui_file *stream,\n \t      f_type_print_base (type->field (index).type (), stream,\n \t\t\t\t show - 1, level + 4);\n \t      fputs_filtered (\" :: \", stream);\n-\t      fputs_styled (TYPE_FIELD_NAME (type, index),\n+\t      fputs_styled (type->field (index).name (),\n \t\t\t    variable_name_style.style (), stream);\n \t      f_type_print_varspec_suffix (type->field (index).type (),\n \t\t\t\t\t   stream, show - 1, 0, 0, 0, false);"
    },
    {
      "sha": "27d9a73097858340f791c5c5a1977ee56891d43e",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -312,7 +312,7 @@ f_language::value_print_inner (struct value *val, struct ui_file *stream,\n \t      if (printed_field > 0)\n \t\tfputs_filtered (\", \", stream);\n \n-\t      field_name = TYPE_FIELD_NAME (type, index);\n+\t      field_name = type->field (index).name ();\n \t      if (field_name != NULL)\n \t\t{\n \t\t  fputs_styled (field_name, variable_name_style.style (),"
    },
    {
      "sha": "97f016fccd124be303e8177bae29b96882447ab5",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 7,
      "deletions": 8,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -1846,7 +1846,7 @@ lookup_struct_elt (struct type *type, const char *name, int noerr)\n \n   for (i = type->num_fields () - 1; i >= TYPE_N_BASECLASSES (type); i--)\n     {\n-      const char *t_field_name = TYPE_FIELD_NAME (type, i);\n+      const char *t_field_name = type->field (i).name ();\n \n       if (t_field_name && (strcmp_iw (t_field_name, name) == 0))\n \t{\n@@ -4206,8 +4206,7 @@ check_types_equal (struct type *type1, struct type *type2,\n \t      || FIELD_BITSIZE (*field1) != FIELD_BITSIZE (*field2)\n \t      || FIELD_LOC_KIND (*field1) != FIELD_LOC_KIND (*field2))\n \t    return false;\n-\t  if (!compare_maybe_null_strings (FIELD_NAME (*field1),\n-\t\t\t\t\t   FIELD_NAME (*field2)))\n+\t  if (!compare_maybe_null_strings (field1->name (), field2->name ()))\n \t    return false;\n \t  switch (FIELD_LOC_KIND (*field1))\n \t    {\n@@ -5346,10 +5345,10 @@ recursive_dump_type (struct type *type, int spaces)\n \t\t\t TYPE_FIELD_BITSIZE (type, idx));\n       gdb_print_host_address (type->field (idx).type (), gdb_stdout);\n       printf_filtered (\" name '%s' (\",\n-\t\t       TYPE_FIELD_NAME (type, idx) != NULL\n-\t\t       ? TYPE_FIELD_NAME (type, idx)\n+\t\t       type->field (idx).name () != NULL\n+\t\t       ? type->field (idx).name ()\n \t\t       : \"<NULL>\");\n-      gdb_print_host_address (TYPE_FIELD_NAME (type, idx), gdb_stdout);\n+      gdb_print_host_address (type->field (idx).name (), gdb_stdout);\n       printf_filtered (\")\\n\");\n       if (type->field (idx).type () != NULL)\n \t{\n@@ -5558,8 +5557,8 @@ copy_type_recursive (struct objfile *objfile,\n \t    new_type->field (i).set_type\n \t      (copy_type_recursive (objfile, type->field (i).type (),\n \t\t\t\t    copied_types));\n-\t  if (TYPE_FIELD_NAME (type, i))\n-\t    new_type->field (i).set_name (xstrdup (TYPE_FIELD_NAME (type, i)));\n+\t  if (type->field (i).name ())\n+\t    new_type->field (i).set_name (xstrdup (type->field (i).name ()));\n \t  switch (TYPE_FIELD_LOC_KIND (type, i))\n \t    {\n \t    case FIELD_LOC_KIND_BITPOS:"
    },
    {
      "sha": "5ec7a5f97a856b8f3ee6d67027297be129276449",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -1974,7 +1974,7 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n #define TYPE_TAIL_CALL_LIST(thistype) TYPE_MAIN_TYPE(thistype)->type_specific.func_stuff->tail_call_list\n #define TYPE_BASECLASS(thistype,index) ((thistype)->field (index).type ())\n #define TYPE_N_BASECLASSES(thistype) TYPE_CPLUS_SPECIFIC(thistype)->n_baseclasses\n-#define TYPE_BASECLASS_NAME(thistype,index) TYPE_FIELD_NAME(thistype, index)\n+#define TYPE_BASECLASS_NAME(thistype,index) (thistype->field (index).name ())\n #define TYPE_BASECLASS_BITPOS(thistype,index) TYPE_FIELD_BITPOS(thistype,index)\n #define BASETYPE_VIA_PUBLIC(thistype, index) \\\n   ((!TYPE_FIELD_PRIVATE(thistype, index)) && (!TYPE_FIELD_PROTECTED(thistype, index)))\n@@ -1984,7 +1984,6 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n   (TYPE_CPLUS_SPECIFIC(thistype)->virtual_field_bits == NULL ? 0 \\\n     : B_TST(TYPE_CPLUS_SPECIFIC(thistype)->virtual_field_bits, (index)))\n \n-#define FIELD_NAME(thisfld) ((thisfld).name ())\n #define FIELD_LOC_KIND(thisfld) ((thisfld).loc_kind)\n #define FIELD_BITPOS_LVAL(thisfld) ((thisfld).loc.bitpos)\n #define FIELD_BITPOS(thisfld) (FIELD_BITPOS_LVAL (thisfld) + 0)\n@@ -2011,7 +2010,6 @@ extern void set_type_vptr_basetype (struct type *, struct type *);\n #define FIELD_ARTIFICIAL(thisfld) ((thisfld).artificial)\n #define FIELD_BITSIZE(thisfld) ((thisfld).bitsize)\n \n-#define TYPE_FIELD_NAME(thistype, n) ((thistype)->field (n).name ())\n #define TYPE_FIELD_LOC_KIND(thistype, n) FIELD_LOC_KIND ((thistype)->field (n))\n #define TYPE_FIELD_BITPOS(thistype, n) FIELD_BITPOS ((thistype)->field (n))\n #define TYPE_FIELD_ENUMVAL(thistype, n) FIELD_ENUMVAL ((thistype)->field (n))"
    },
    {
      "sha": "c0200b273cd69e30d8a2d886fcf720379e9c3d23",
      "filename": "gdb/gnu-v2-abi.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/gnu-v2-abi.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/gnu-v2-abi.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-v2-abi.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -294,7 +294,7 @@ static int\n vb_match (struct type *type, int index, struct type *basetype)\n {\n   struct type *fieldtype;\n-  const char *name = TYPE_FIELD_NAME (type, index);\n+  const char *name = type->field (index).name ();\n   const char *field_class_name = NULL;\n \n   if (*name != '_')"
    },
    {
      "sha": "72c5d8884d9af7d68442f42c061be420fcae6039",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -82,9 +82,9 @@ gccgo_string_p (struct type *type)\n       type1 = check_typedef (type1);\n \n       if (type0->code () == TYPE_CODE_PTR\n-\t  && strcmp (TYPE_FIELD_NAME (type, 0), \"__data\") == 0\n+\t  && strcmp (type->field (0).name (), \"__data\") == 0\n \t  && type1->code () == TYPE_CODE_INT\n-\t  && strcmp (TYPE_FIELD_NAME (type, 1), \"__length\") == 0)\n+\t  && strcmp (type->field (1).name (), \"__length\") == 0)\n \t{\n \t  struct type *target_type = TYPE_TARGET_TYPE (type0);\n "
    },
    {
      "sha": "04d3d7549001521af88a5f90b1ad960abd4731ae",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -999,7 +999,7 @@ gdbscm_type_field (SCM self, SCM field_scm)\n \n     for (int i = 0; i < type->num_fields (); i++)\n       {\n-\tconst char *t_field_name = TYPE_FIELD_NAME (type, i);\n+\tconst char *t_field_name = type->field (i).name ();\n \n \tif (t_field_name && (strcmp_iw (t_field_name, field.get ()) == 0))\n \t  {\n@@ -1041,7 +1041,7 @@ gdbscm_type_has_field_p (SCM self, SCM field_scm)\n \n     for (int i = 0; i < type->num_fields (); i++)\n       {\n-\tconst char *t_field_name = TYPE_FIELD_NAME (type, i);\n+\tconst char *t_field_name = type->field (i).name ();\n \n \tif (t_field_name && (strcmp_iw (t_field_name, field.get ()) == 0))\n \t  return SCM_BOOL_T;\n@@ -1131,8 +1131,8 @@ gdbscm_field_name (SCM self)\n     = tyscm_get_field_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   struct field *field = tyscm_field_smob_to_field (f_smob);\n \n-  if (FIELD_NAME (*field))\n-    return gdbscm_scm_from_c_string (FIELD_NAME (*field));\n+  if (field->name () != nullptr)\n+    return gdbscm_scm_from_c_string (field->name ());\n   return SCM_BOOL_F;\n }\n "
    },
    {
      "sha": "8209686980f25119a9c44dcde5341b75cc61540b",
      "filename": "gdb/m2-typeprint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/m2-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/m2-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-typeprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -353,8 +353,8 @@ m2_is_long_set (struct type *type)\n \t    return 0;\n \t  if (type->field (i).type ()->code () != TYPE_CODE_SET)\n \t    return 0;\n-\t  if (TYPE_FIELD_NAME (type, i) != NULL\n-\t      && (strcmp (TYPE_FIELD_NAME (type, i), \"\") != 0))\n+\t  if (type->field (i).name () != NULL\n+\t      && (strcmp (type->field (i).name (), \"\") != 0))\n \t    return 0;\n \t  range = type->field (i).type ()->index_type ();\n \t  if ((i > TYPE_N_BASECLASSES (type))\n@@ -492,9 +492,9 @@ m2_is_unbounded_array (struct type *type)\n        */\n       if (type->num_fields () != 2)\n \treturn 0;\n-      if (strcmp (TYPE_FIELD_NAME (type, 0), \"_m2_contents\") != 0)\n+      if (strcmp (type->field (0).name (), \"_m2_contents\") != 0)\n \treturn 0;\n-      if (strcmp (TYPE_FIELD_NAME (type, 1), \"_m2_high\") != 0)\n+      if (strcmp (type->field (1).name (), \"_m2_high\") != 0)\n \treturn 0;\n       if (type->field (0).type ()->code () != TYPE_CODE_PTR)\n \treturn 0;\n@@ -563,7 +563,7 @@ m2_record_fields (struct type *type, struct ui_file *stream, int show,\n \t  QUIT;\n \n \t  print_spaces_filtered (level + 4, stream);\n-\t  fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t  fputs_styled (type->field (i).name (),\n \t\t\tvariable_name_style.style (), stream);\n \t  fputs_filtered (\" : \", stream);\n \t  m2_print_type (type->field (i).type (),\n@@ -609,7 +609,7 @@ m2_enum (struct type *type, struct ui_file *stream, int show, int level)\n \t  if (i > 0)\n \t    fprintf_filtered (stream, \", \");\n \t  wrap_here (\"    \");\n-\t  fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t  fputs_styled (type->field (i).name (),\n \t\t\tvariable_name_style.style (), stream);\n \t  if (lastval != TYPE_FIELD_ENUMVAL (type, i))\n \t    {"
    },
    {
      "sha": "cac8fbeaeb07f6ba8fc2f7180f0ec8c3389ad6b2",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -96,10 +96,10 @@ pascal_is_string_type (struct type *type,int *length_pos, int *length_size,\n       /* Old Borland type pascal strings from Free Pascal Compiler.  */\n       /* Two fields: length and st.  */\n       if (type->num_fields () == 2\n-\t  && TYPE_FIELD_NAME (type, 0)\n-\t  && strcmp (TYPE_FIELD_NAME (type, 0), \"length\") == 0\n-\t  && TYPE_FIELD_NAME (type, 1)\n-\t  && strcmp (TYPE_FIELD_NAME (type, 1), \"st\") == 0)\n+\t  && type->field (0).name ()\n+\t  && strcmp (type->field (0).name (), \"length\") == 0\n+\t  && type->field (1).name ()\n+\t  && strcmp (type->field (1).name (), \"st\") == 0)\n \t{\n \t  if (length_pos)\n \t    *length_pos = TYPE_FIELD_BITPOS (type, 0) / TARGET_CHAR_BIT;\n@@ -110,16 +110,16 @@ pascal_is_string_type (struct type *type,int *length_pos, int *length_size,\n \t  if (char_type)\n \t    *char_type = TYPE_TARGET_TYPE (type->field (1).type ());\n \t  if (arrayname)\n-\t    *arrayname = TYPE_FIELD_NAME (type, 1);\n+\t    *arrayname = type->field (1).name ();\n \t return 2;\n \t};\n       /* GNU pascal strings.  */\n       /* Three fields: Capacity, length and schema$ or _p_schema.  */\n       if (type->num_fields () == 3\n-\t  && TYPE_FIELD_NAME (type, 0)\n-\t  && strcmp (TYPE_FIELD_NAME (type, 0), \"Capacity\") == 0\n-\t  && TYPE_FIELD_NAME (type, 1)\n-\t  && strcmp (TYPE_FIELD_NAME (type, 1), \"length\") == 0)\n+\t  && type->field (0).name ()\n+\t  && strcmp (type->field (0).name (), \"Capacity\") == 0\n+\t  && type->field (1).name ()\n+\t  && strcmp (type->field (1).name (), \"length\") == 0)\n \t{\n \t  if (length_pos)\n \t    *length_pos = TYPE_FIELD_BITPOS (type, 1) / TARGET_CHAR_BIT;\n@@ -136,7 +136,7 @@ pascal_is_string_type (struct type *type,int *length_pos, int *length_size,\n \t\t*char_type = TYPE_TARGET_TYPE (*char_type);\n \t    }\n \t  if (arrayname)\n-\t    *arrayname = TYPE_FIELD_NAME (type, 2);\n+\t    *arrayname = type->field (2).name ();\n \t return 3;\n \t};\n     }"
    },
    {
      "sha": "48bfba8b0d0c2442c2ce23630b8c314e0faa7086",
      "filename": "gdb/p-typeprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/p-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/p-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-typeprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -523,8 +523,8 @@ pascal_language::type_print_base (struct type *type, struct ui_file *stream, int\n \t    {\n \t      QUIT;\n \t      /* Don't print out virtual function table.  */\n-\t      if ((startswith (TYPE_FIELD_NAME (type, i), \"_vptr\"))\n-\t\t  && is_cplus_marker ((TYPE_FIELD_NAME (type, i))[5]))\n+\t      if ((startswith (type->field (i).name (), \"_vptr\"))\n+\t\t  && is_cplus_marker ((type->field (i).name ())[5]))\n \t\tcontinue;\n \n \t      /* If this is a pascal object or class we can print the\n@@ -565,7 +565,7 @@ pascal_language::type_print_base (struct type *type, struct ui_file *stream, int\n \t      if (field_is_static (&type->field (i)))\n \t\tfprintf_filtered (stream, \"static \");\n \t      print_type (type->field (i).type (),\n-\t\t\t\t TYPE_FIELD_NAME (type, i),\n+\t\t\t\t type->field (i).name (),\n \t\t\t\t stream, show - 1, level + 4, flags);\n \t      if (!field_is_static (&type->field (i))\n \t\t  && TYPE_FIELD_PACKED (type, i))\n@@ -710,7 +710,7 @@ pascal_language::type_print_base (struct type *type, struct ui_file *stream, int\n \t      if (i)\n \t\tfprintf_filtered (stream, \", \");\n \t      wrap_here (\"    \");\n-\t      fputs_filtered (TYPE_FIELD_NAME (type, i), stream);\n+\t      fputs_filtered (type->field (i).name (), stream);\n \t      if (lastval != TYPE_FIELD_ENUMVAL (type, i))\n \t\t{\n \t\t  fprintf_filtered (stream,"
    },
    {
      "sha": "44be49848b2fe08682f6b7084e034a6d10a4c172",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -583,12 +583,12 @@ pascal_object_print_value_fields (struct value *val, struct ui_file *stream,\n \t    {\n \t      fputs_filtered (\"static \", stream);\n \t      fprintf_symbol_filtered (stream,\n-\t\t\t\t       TYPE_FIELD_NAME (type, i),\n+\t\t\t\t       type->field (i).name (),\n \t\t\t\t       current_language->la_language,\n \t\t\t\t       DMGL_PARAMS | DMGL_ANSI);\n \t    }\n \t  else\n-\t    fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t    fputs_styled (type->field (i).name (),\n \t\t\t  variable_name_style.style (), stream);\n \t  annotate_field_name_end ();\n \t  fputs_filtered (\" = \", stream);"
    },
    {
      "sha": "f0f835793239185577dc1e9af235d5cd6d76aa92",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -204,13 +204,13 @@ convert_field (struct type *type, int field)\n     }\n \n   arg.reset (NULL);\n-  if (TYPE_FIELD_NAME (type, field))\n+  if (type->field (field).name ())\n     {\n-      const char *field_name = TYPE_FIELD_NAME (type, field);\n+      const char *field_name = type->field (field).name ();\n \n       if (field_name[0] != '\\0')\n \t{\n-\t  arg.reset (PyString_FromString (TYPE_FIELD_NAME (type, field)));\n+\t  arg.reset (PyString_FromString (type->field (field).name ()));\n \t  if (arg == NULL)\n \t    return NULL;\n \t}\n@@ -261,8 +261,8 @@ field_name (struct type *type, int field)\n {\n   gdbpy_ref<> result;\n \n-  if (TYPE_FIELD_NAME (type, field))\n-    result.reset (PyString_FromString (TYPE_FIELD_NAME (type, field)));\n+  if (type->field (field).name ())\n+    result.reset (PyString_FromString (type->field (field).name ()));\n   else\n     result = gdbpy_ref<>::new_reference (Py_None);\n \n@@ -1205,7 +1205,7 @@ typy_getitem (PyObject *self, PyObject *key)\n \n   for (i = 0; i < type->num_fields (); i++)\n     {\n-      const char *t_field_name = TYPE_FIELD_NAME (type, i);\n+      const char *t_field_name = type->field (i).name ();\n \n       if (t_field_name && (strcmp_iw (t_field_name, field.get ()) == 0))\n \treturn convert_field (type, i).release ();\n@@ -1263,7 +1263,7 @@ typy_has_key (PyObject *self, PyObject *args)\n \n   for (i = 0; i < type->num_fields (); i++)\n     {\n-      const char *t_field_name = TYPE_FIELD_NAME (type, i);\n+      const char *t_field_name = type->field (i).name ();\n \n       if (t_field_name && (strcmp_iw (t_field_name, field) == 0))\n \tPy_RETURN_TRUE;"
    },
    {
      "sha": "79284bedb2bc6c219e9847d47a48882affd45e54",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -135,7 +135,7 @@ rust_underscore_fields (struct type *type)\n \t  char buf[20];\n \n \t  xsnprintf (buf, sizeof (buf), \"__%d\", field_number);\n-\t  if (strcmp (buf, TYPE_FIELD_NAME (type, i)) != 0)\n+\t  if (strcmp (buf, type->field (i).name ()) != 0)\n \t    return false;\n \t  field_number++;\n \t}\n@@ -182,7 +182,7 @@ rust_range_type_p (struct type *type)\n     return true;\n \n   i = 0;\n-  if (strcmp (TYPE_FIELD_NAME (type, 0), \"start\") == 0)\n+  if (strcmp (type->field (0).name (), \"start\") == 0)\n     {\n       if (type->num_fields () == 1)\n \treturn true;\n@@ -194,7 +194,7 @@ rust_range_type_p (struct type *type)\n       return false;\n     }\n \n-  return strcmp (TYPE_FIELD_NAME (type, i), \"end\") == 0;\n+  return strcmp (type->field (i).name (), \"end\") == 0;\n }\n \n /* Return true if TYPE is an inclusive range type, otherwise false.\n@@ -244,9 +244,9 @@ rust_get_trait_object_pointer (struct value *value)\n   int vtable_field = 0;\n   for (int i = 0; i < 2; ++i)\n     {\n-      if (strcmp (TYPE_FIELD_NAME (type, i), \"vtable\") == 0)\n+      if (strcmp (type->field (i).name (), \"vtable\") == 0)\n \tvtable_field = i;\n-      else if (strcmp (TYPE_FIELD_NAME (type, i), \"pointer\") != 0)\n+      else if (strcmp (type->field (i).name (), \"pointer\") != 0)\n \treturn NULL;\n     }\n \n@@ -381,7 +381,7 @@ rust_language::val_print_struct\n \n       if (!is_tuple && !is_tuple_struct)\n \t{\n-\t  fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t  fputs_styled (type->field (i).name (),\n \t\t\tvariable_name_style.style (), stream);\n \t  fputs_filtered (\": \", stream);\n \t}\n@@ -463,7 +463,7 @@ rust_language::print_enum (struct value *val, struct ui_file *stream,\n       if (!is_tuple)\n \tfprintf_filtered (stream, \"%ps: \",\n \t\t\t  styled_string (variable_name_style.style (),\n-\t\t\t\t\t TYPE_FIELD_NAME (variant_type, j)));\n+\t\t\t\t\t variant_type->field (j).name ()));\n \n       common_val_print (value_field (val, j), stream, recurse + 1, &opts,\n \t\t\tthis);\n@@ -708,12 +708,12 @@ rust_print_struct_def (struct type *type, const char *varstring,\n       if (!for_rust_enum || flags->print_offsets)\n \tprint_spaces_filtered (level + 2, stream);\n       if (is_enum)\n-\tfputs_styled (TYPE_FIELD_NAME (type, i), variable_name_style.style (),\n+\tfputs_styled (type->field (i).name (), variable_name_style.style (),\n \t\t      stream);\n       else if (!is_tuple_struct)\n \tfprintf_filtered (stream, \"%ps: \",\n \t\t\t  styled_string (variable_name_style.style (),\n-\t\t\t\t\t TYPE_FIELD_NAME (type, i)));\n+\t\t\t\t\t type->field (i).name ()));\n \n       rust_internal_print_type (type->field (i).type (), NULL,\n \t\t\t\tstream, (is_enum ? show : show - 1),\n@@ -840,7 +840,7 @@ rust_internal_print_type (struct type *type, const char *varstring,\n \n \tfor (int i = 0; i < type->num_fields (); ++i)\n \t  {\n-\t    const char *name = TYPE_FIELD_NAME (type, i);\n+\t    const char *name = type->field (i).name ();\n \n \t    QUIT;\n \n@@ -1071,14 +1071,14 @@ rust_compute_range (struct type *type, struct value *range,\n     return;\n \n   i = 0;\n-  if (strcmp (TYPE_FIELD_NAME (type, 0), \"start\") == 0)\n+  if (strcmp (type->field (0).name (), \"start\") == 0)\n     {\n       *kind = RANGE_HIGH_BOUND_DEFAULT;\n       *low = value_as_long (value_field (range, 0));\n       ++i;\n     }\n   if (type->num_fields () > i\n-      && strcmp (TYPE_FIELD_NAME (type, i), \"end\") == 0)\n+      && strcmp (type->field (i).name (), \"end\") == 0)\n     {\n       *kind = (*kind == (RANGE_LOW_BOUND_DEFAULT | RANGE_HIGH_BOUND_DEFAULT)\n \t       ? RANGE_LOW_BOUND_DEFAULT : RANGE_STANDARD);\n@@ -1125,7 +1125,7 @@ rust_subscript (struct type *expect_type, struct expression *exp,\n \t{\n \t  for (int i = 0; i < type->num_fields (); ++i)\n \t    {\n-\t      if (strcmp (TYPE_FIELD_NAME (type, i), \"data_ptr\") == 0)\n+\t      if (strcmp (type->field (i).name (), \"data_ptr\") == 0)\n \t\t{\n \t\t  base_type = TYPE_TARGET_TYPE (type->field (i).type ());\n \t\t  break;"
    },
    {
      "sha": "f63b3720c7557e80103e13a8461463695408b85a",
      "filename": "gdb/stabsread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/stabsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/stabsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -3195,7 +3195,7 @@ read_tilde_fields (struct stab_field_info *fip, const char **pp,\n \t\t   i >= TYPE_N_BASECLASSES (t);\n \t\t   --i)\n \t\t{\n-\t\t  const char *name = TYPE_FIELD_NAME (t, i);\n+\t\t  const char *name = t->field (i).name ();\n \n \t\t  if (!strncmp (name, vptr_name, sizeof (vptr_name) - 2)\n \t\t      && is_cplus_marker (name[sizeof (vptr_name) - 2]))"
    },
    {
      "sha": "62451fef0a183f0483a09dae51019afb283e4dba",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -1973,7 +1973,7 @@ check_field (struct type *type, const char *name,\n \n   for (i = type->num_fields () - 1; i >= TYPE_N_BASECLASSES (type); i--)\n     {\n-      const char *t_field_name = TYPE_FIELD_NAME (type, i);\n+      const char *t_field_name = type->field (i).name ();\n \n       if (t_field_name && (strcmp_iw (t_field_name, name) == 0))\n \t{\n@@ -5609,9 +5609,9 @@ completion_list_add_fields (completion_tracker &tracker,\n \n       if (c == TYPE_CODE_UNION || c == TYPE_CODE_STRUCT)\n \tfor (j = TYPE_N_BASECLASSES (t); j < t->num_fields (); j++)\n-\t  if (TYPE_FIELD_NAME (t, j))\n+\t  if (t->field (j).name ())\n \t    completion_list_add_name (tracker, sym->language (),\n-\t\t\t\t      TYPE_FIELD_NAME (t, j),\n+\t\t\t\t      t->field (j).name (),\n \t\t\t\t      lookup_name, text, word);\n     }\n }"
    },
    {
      "sha": "0d73baa882d30b7b4c44b8b33c6153041d557f17",
      "filename": "gdb/typeprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/typeprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -633,7 +633,7 @@ print_type_scalar (struct type *type, LONGEST val, struct ui_file *stream)\n \t}\n       if (i < len)\n \t{\n-\t  fputs_filtered (TYPE_FIELD_NAME (type, i), stream);\n+\t  fputs_filtered (type->field (i).name (), stream);\n \t}\n       else\n \t{"
    },
    {
      "sha": "a6c3632fe1851d06a89ac5ee568d730cef9c07f2",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -1993,7 +1993,7 @@ struct_field_searcher::search (struct value *arg1, LONGEST offset,\n   if (!m_looking_for_baseclass)\n     for (i = type->num_fields () - 1; i >= nbases; i--)\n       {\n-\tconst char *t_field_name = TYPE_FIELD_NAME (type, i);\n+\tconst char *t_field_name = type->field (i).name ();\n \n \tif (t_field_name && (strcmp_iw (t_field_name, m_name) == 0))\n \t  {\n@@ -3337,7 +3337,7 @@ enum_constant_from_type (struct type *type, const char *name)\n \n   for (i = TYPE_N_BASECLASSES (type); i < type->num_fields (); ++i)\n     {\n-      const char *fname = TYPE_FIELD_NAME (type, i);\n+      const char *fname = type->field (i).name ();\n       int len;\n \n       if (TYPE_FIELD_LOC_KIND (type, i) != FIELD_LOC_KIND_ENUMVAL\n@@ -3509,7 +3509,7 @@ value_struct_elt_for_reference (struct type *domain, int offset,\n \n   for (i = t->num_fields () - 1; i >= TYPE_N_BASECLASSES (t); i--)\n     {\n-      const char *t_field_name = TYPE_FIELD_NAME (t, i);\n+      const char *t_field_name = t->field (i).name ();\n \n       if (t_field_name && strcmp (t_field_name, name) == 0)\n \t{"
    },
    {
      "sha": "c6ea0d82e406ae34d17979a98ee60756996c6cd0",
      "filename": "gdb/valprint.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valprint.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -615,7 +615,7 @@ generic_val_print_enum_1 (struct type *type, LONGEST val,\n     }\n   if (i < len)\n     {\n-      fputs_styled (TYPE_FIELD_NAME (type, i), variable_name_style.style (),\n+      fputs_styled (type->field (i).name (), variable_name_style.style (),\n \t\t    stream);\n     }\n   else if (type->is_flag_enum ())\n@@ -646,7 +646,7 @@ generic_val_print_enum_1 (struct type *type, LONGEST val,\n \t\tfputs_filtered (\" | \", stream);\n \n \t      val &= ~TYPE_FIELD_ENUMVAL (type, i);\n-\t      fputs_styled (TYPE_FIELD_NAME (type, i),\n+\t      fputs_styled (type->field (i).name (),\n \t\t\t    variable_name_style.style (), stream);\n \t    }\n \t}\n@@ -1203,7 +1203,7 @@ val_print_type_code_flags (struct type *type, struct value *original_value,\n   fputs_filtered (\"[\", stream);\n   for (field = 0; field < nfields; field++)\n     {\n-      if (TYPE_FIELD_NAME (type, field)[0] != '\\0')\n+      if (type->field (field).name ()[0] != '\\0')\n \t{\n \t  struct type *field_type = type->field (field).type ();\n \n@@ -1218,7 +1218,7 @@ val_print_type_code_flags (struct type *type, struct value *original_value,\n \t\tfprintf_filtered\n \t\t  (stream, \" %ps\",\n \t\t   styled_string (variable_name_style.style (),\n-\t\t\t\t  TYPE_FIELD_NAME (type, field)));\n+\t\t\t\t  type->field (field).name ()));\n \t    }\n \t  else\n \t    {\n@@ -1229,7 +1229,7 @@ val_print_type_code_flags (struct type *type, struct value *original_value,\n \t\tfield_val &= ((ULONGEST) 1 << field_len) - 1;\n \t      fprintf_filtered (stream, \" %ps=\",\n \t\t\t\tstyled_string (variable_name_style.style (),\n-\t\t\t\t\t       TYPE_FIELD_NAME (type, field)));\n+\t\t\t\t\t       type->field (field).name ()));\n \t      if (field_type->code () == TYPE_CODE_ENUM)\n \t\tgeneric_val_print_enum_1 (field_type, field_val, stream);\n \t      else"
    },
    {
      "sha": "b9d3112387fd916effbd70ab9e6087101fa9f049",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/33d16dd987d16fe1eb289853e5a444192bb31d9e/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=33d16dd987d16fe1eb289853e5a444192bb31d9e",
      "patch": "@@ -2933,7 +2933,7 @@ value_static_field (struct type *type, int fieldno)\n     case FIELD_LOC_KIND_PHYSNAME:\n     {\n       const char *phys_name = TYPE_FIELD_STATIC_PHYSNAME (type, fieldno);\n-      /* TYPE_FIELD_NAME (type, fieldno); */\n+      /* type->field (fieldno).name (); */\n       struct block_symbol sym = lookup_symbol (phys_name, 0, VAR_DOMAIN, 0);\n \n       if (sym.symbol == NULL)"
    }
  ]
}