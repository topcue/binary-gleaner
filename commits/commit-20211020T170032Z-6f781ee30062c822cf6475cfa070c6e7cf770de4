{
  "sha": "6f781ee30062c822cf6475cfa070c6e7cf770de4",
  "node_id": "C_kwDOANOeidoAKDZmNzgxZWUzMDA2MmM4MjJjZjY0NzVjZmEwNzBjNmU3Y2Y3NzBkZTQ",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-10-02T23:17:27Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-10-20T17:00:32Z"
    },
    "message": "Use unique_xmalloc_ptr in breakpoint\n\nThis changes struct breakpoint to use unique_xmalloc_ptr in a couple\nof spots, removing a bit of manual memory management.",
    "tree": {
      "sha": "28f1176383c7f7ce9cf05ab7f7f34b93170e548f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/28f1176383c7f7ce9cf05ab7f7f34b93170e548f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6f781ee30062c822cf6475cfa070c6e7cf770de4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6f781ee30062c822cf6475cfa070c6e7cf770de4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6f781ee30062c822cf6475cfa070c6e7cf770de4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6f781ee30062c822cf6475cfa070c6e7cf770de4/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "23d6ee640578968b0ddef8e08d7dbb5b558a9ce9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/23d6ee640578968b0ddef8e08d7dbb5b558a9ce9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/23d6ee640578968b0ddef8e08d7dbb5b558a9ce9"
    }
  ],
  "stats": {
    "total": 123,
    "additions": 60,
    "deletions": 63
  },
  "files": [
    {
      "sha": "4a5b160f7600b60aaab9381ae2f57f1c3ecb7008",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 53,
      "deletions": 56,
      "changes": 109,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=6f781ee30062c822cf6475cfa070c6e7cf770de4",
      "patch": "@@ -864,8 +864,7 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n {\n   if (*exp == 0)\n     {\n-      xfree (b->cond_string);\n-      b->cond_string = nullptr;\n+      b->cond_string.reset ();\n \n       if (is_watchpoint (b))\n \tstatic_cast<watchpoint *> (b)->cond_exp.reset ();\n@@ -946,8 +945,7 @@ set_breakpoint_condition (struct breakpoint *b, const char *exp,\n \n       /* We know that the new condition parsed successfully.  The\n \t condition string of the breakpoint can be safely updated.  */\n-      xfree (b->cond_string);\n-      b->cond_string = xstrdup (exp);\n+      b->cond_string = make_unique_xstrdup (exp);\n       b->condition_not_parsed = 0;\n     }\n   mark_breakpoint_modified (b);\n@@ -1862,7 +1860,7 @@ update_watchpoint (struct watchpoint *b, int reparse)\n \t{\n \t  b->cond_exp.reset ();\n \n-\t  s = b->cond_string;\n+\t  s = b->cond_string.get ();\n \t  b->cond_exp = parse_exp_1 (&s, 0, b->cond_exp_valid_block, 0);\n \t}\n     }\n@@ -2442,7 +2440,7 @@ build_target_command_list (struct bp_location *bl)\n \t\t need to parse the command to bytecodes again.  */\n \t      loc->cmd_bytecode\n \t\t= parse_cmd_to_aexpr (bl->address,\n-\t\t\t\t      loc->owner->extra_string);\n+\t\t\t\t      loc->owner->extra_string.get ());\n \t    }\n \n \t  /* If we have a NULL bytecode expression, it means something\n@@ -5940,7 +5938,7 @@ print_breakpoint_location (struct breakpoint *b,\n \t    uiout->text (\",\");\n \t  else\n \t    uiout->text (\" \");\n-\t  uiout->text (b->extra_string);\n+\t  uiout->text (b->extra_string.get ());\n \t}\n     }\n \n@@ -6222,7 +6220,7 @@ print_one_breakpoint_location (struct breakpoint *b,\n \tuiout->text (\"\\ttrace only if \");\n       else\n \tuiout->text (\"\\tstop only if \");\n-      uiout->field_string (\"cond\", b->cond_string);\n+      uiout->field_string (\"cond\", b->cond_string.get ());\n \n       /* Print whether the target is doing the breakpoint's condition\n \t evaluation.  If GDB is doing the evaluation, don't print anything.  */\n@@ -8211,7 +8209,10 @@ init_catchpoint (struct breakpoint *b,\n \n   init_raw_breakpoint (b, gdbarch, sal, bp_catchpoint, ops);\n \n-  b->cond_string = (cond_string == NULL) ? NULL : xstrdup (cond_string);\n+  if (cond_string == nullptr)\n+    b->cond_string.reset ();\n+  else\n+    b->cond_string = make_unique_xstrdup (cond_string);\n   b->disposition = temp ? disp_del : disp_donttouch;\n }\n \n@@ -8726,7 +8727,7 @@ bp_loc_is_permanent (struct bp_location *loc)\n static void\n update_dprintf_command_list (struct breakpoint *b)\n {\n-  char *dprintf_args = b->extra_string;\n+  const char *dprintf_args = b->extra_string.get ();\n   char *printf_line = NULL;\n \n   if (!dprintf_args)\n@@ -8851,8 +8852,8 @@ init_breakpoint_sal (struct breakpoint *b, struct gdbarch *gdbarch,\n \t  b->thread = thread;\n \t  b->task = task;\n \n-\t  b->cond_string = cond_string.release ();\n-\t  b->extra_string = extra_string.release ();\n+\t  b->cond_string = std::move (cond_string);\n+\t  b->extra_string = std::move (extra_string);\n \t  b->ignore_count = ignore_count;\n \t  b->enable_state = enabled ? bp_enabled : bp_disabled;\n \t  b->disposition = disposition;\n@@ -8919,7 +8920,7 @@ init_breakpoint_sal (struct breakpoint *b, struct gdbarch *gdbarch,\n \t    error (_(\"Format string required\"));\n \t}\n       else if (b->extra_string)\n-\terror (_(\"Garbage '%s' at end of command\"), b->extra_string);\n+\terror (_(\"Garbage '%s' at end of command\"), b->extra_string.get ());\n     }\n \n \n@@ -8929,8 +8930,8 @@ init_breakpoint_sal (struct breakpoint *b, struct gdbarch *gdbarch,\n   for (bp_location *loc : b->locations ())\n     {\n       if (b->cond_string != nullptr)\n-\tset_breakpoint_location_condition (b->cond_string, loc, b->number,\n-\t\t\t\t\t   loc_num);\n+\tset_breakpoint_location_condition (b->cond_string.get (), loc,\n+\t\t\t\t\t   b->number, loc_num);\n \n       ++loc_num;\n     }\n@@ -9155,13 +9156,14 @@ check_fast_tracepoint_sals (struct gdbarch *gdbarch,\n \n static void\n find_condition_and_thread (const char *tok, CORE_ADDR pc,\n-\t\t\t   char **cond_string, int *thread, int *task,\n-\t\t\t   char **rest)\n+\t\t\t   gdb::unique_xmalloc_ptr<char> *cond_string,\n+\t\t\t   int *thread, int *task,\n+\t\t\t   gdb::unique_xmalloc_ptr<char> *rest)\n {\n-  *cond_string = NULL;\n+  cond_string->reset ();\n   *thread = -1;\n   *task = 0;\n-  *rest = NULL;\n+  rest->reset ();\n   bool force = false;\n \n   while (tok && *tok)\n@@ -9175,7 +9177,7 @@ find_condition_and_thread (const char *tok, CORE_ADDR pc,\n \n       if ((*tok == '\"' || *tok == ',') && rest)\n \t{\n-\t  *rest = savestring (tok, strlen (tok));\n+\t  rest->reset (savestring (tok, strlen (tok)));\n \t  return;\n \t}\n \n@@ -9198,7 +9200,7 @@ find_condition_and_thread (const char *tok, CORE_ADDR pc,\n \t\ttok = tok + strlen (tok);\n \t    }\n \t  cond_end = tok;\n-\t  *cond_string = savestring (cond_start, cond_end - cond_start);\n+\t  cond_string->reset (savestring (cond_start, cond_end - cond_start));\n \t}\n       else if (toklen >= 1 && strncmp (tok, \"-force-condition\", toklen) == 0)\n \t{\n@@ -9231,7 +9233,7 @@ find_condition_and_thread (const char *tok, CORE_ADDR pc,\n \t}\n       else if (rest)\n \t{\n-\t  *rest = savestring (tok, strlen (tok));\n+\t  rest->reset (savestring (tok, strlen (tok)));\n \t  return;\n \t}\n       else\n@@ -9246,16 +9248,18 @@ find_condition_and_thread (const char *tok, CORE_ADDR pc,\n \n static void\n find_condition_and_thread_for_sals (const std::vector<symtab_and_line> &sals,\n-\t\t\t\t    const char *input, char **cond_string,\n-\t\t\t\t    int *thread, int *task, char **rest)\n+\t\t\t\t    const char *input,\n+\t\t\t\t    gdb::unique_xmalloc_ptr<char> *cond_string,\n+\t\t\t\t    int *thread, int *task,\n+\t\t\t\t    gdb::unique_xmalloc_ptr<char> *rest)\n {\n   int num_failures = 0;\n   for (auto &sal : sals)\n     {\n-      char *cond = nullptr;\n+      gdb::unique_xmalloc_ptr<char> cond;\n       int thread_id = 0;\n       int task_id = 0;\n-      char *remaining = nullptr;\n+      gdb::unique_xmalloc_ptr<char> remaining;\n \n       /* Here we want to parse 'arg' to separate condition from thread\n \t number.  But because parsing happens in a context and the\n@@ -9267,10 +9271,10 @@ find_condition_and_thread_for_sals (const std::vector<symtab_and_line> &sals,\n \t{\n \t  find_condition_and_thread (input, sal.pc, &cond, &thread_id,\n \t\t\t\t     &task_id, &remaining);\n-\t  *cond_string = cond;\n+\t  *cond_string = std::move (cond);\n \t  *thread = thread_id;\n \t  *task = task_id;\n-\t  *rest = remaining;\n+\t  *rest = std::move (remaining);\n \t  break;\n \t}\n       catch (const gdb_exception_error &e)\n@@ -9441,15 +9445,15 @@ create_breakpoint (struct gdbarch *gdbarch,\n \n       if (parse_extra)\n \t{\n-\t  char *rest;\n-\t  char *cond;\n+\t  gdb::unique_xmalloc_ptr<char> rest;\n+\t  gdb::unique_xmalloc_ptr<char> cond;\n \n \t  const linespec_sals &lsal = canonical.lsals[0];\n \n \t  find_condition_and_thread_for_sals (lsal.sals, extra_string,\n \t\t\t\t\t      &cond, &thread, &task, &rest);\n-\t  cond_string_copy.reset (cond);\n-\t  extra_string_copy.reset (rest);\n+\t  cond_string_copy = std::move (cond);\n+\t  extra_string_copy = std::move (rest);\n \t}\n       else\n \t{\n@@ -9512,12 +9516,16 @@ create_breakpoint (struct gdbarch *gdbarch,\n       else\n \t{\n \t  /* Create a private copy of condition string.  */\n-\t  b->cond_string = cond_string != NULL ? xstrdup (cond_string) : NULL;\n+\t  b->cond_string.reset (cond_string != NULL\n+\t\t\t\t? xstrdup (cond_string)\n+\t\t\t\t: NULL);\n \t  b->thread = thread;\n \t}\n \n       /* Create a private copy of any extra string.  */\n-      b->extra_string = extra_string != NULL ? xstrdup (extra_string) : NULL;\n+      b->extra_string.reset (extra_string != NULL\n+\t\t\t     ? xstrdup (extra_string)\n+\t\t\t     : NULL);\n       b->ignore_count = ignore_count;\n       b->disposition = tempflag ? disp_del : disp_donttouch;\n       b->condition_not_parsed = 1;\n@@ -10810,7 +10818,7 @@ watch_command_1 (const char *arg, int accessflag, int from_tty,\n     }\n \n   if (cond_start)\n-    w->cond_string = savestring (cond_start, cond_end - cond_start);\n+    w->cond_string.reset (savestring (cond_start, cond_end - cond_start));\n   else\n     w->cond_string = 0;\n \n@@ -12186,13 +12194,13 @@ say_where (struct breakpoint *b)\n \t{\n \t  printf_filtered (_(\" (%s,%s) pending.\"),\n \t\t\t   event_location_to_string (b->location.get ()),\n-\t\t\t   b->extra_string);\n+\t\t\t   b->extra_string.get ());\n \t}\n       else\n \t{\n \t  printf_filtered (_(\" (%s %s) pending.\"),\n \t\t\t   event_location_to_string (b->location.get ()),\n-\t\t\t   b->extra_string);\n+\t\t\t   b->extra_string.get ());\n \t}\n     }\n   else\n@@ -12234,14 +12242,6 @@ say_where (struct breakpoint *b)\n     }\n }\n \n-/* Destructor for the breakpoint base class.  */\n-\n-breakpoint::~breakpoint ()\n-{\n-  xfree (this->cond_string);\n-  xfree (this->extra_string);\n-}\n-\n /* See breakpoint.h.  */\n \n bp_location_range breakpoint::locations ()\n@@ -12579,7 +12579,7 @@ bkpt_print_recreate (struct breakpoint *tp, struct ui_file *fp)\n   /* Print out extra_string if this breakpoint is pending.  It might\n      contain, for example, conditions that were set by the user.  */\n   if (tp->loc == NULL && tp->extra_string != NULL)\n-    fprintf_unfiltered (fp, \" %s\", tp->extra_string);\n+    fprintf_unfiltered (fp, \" %s\", tp->extra_string.get ());\n \n   print_recreate_thread (tp, fp);\n }\n@@ -12988,7 +12988,7 @@ dprintf_print_recreate (struct breakpoint *tp, struct ui_file *fp)\n {\n   fprintf_unfiltered (fp, \"dprintf %s,%s\",\n \t\t      event_location_to_string (tp->location.get ()),\n-\t\t      tp->extra_string);\n+\t\t      tp->extra_string.get ());\n   print_recreate_thread (tp, fp);\n }\n \n@@ -13578,7 +13578,7 @@ update_breakpoint_locations (struct breakpoint *b,\n \t{\n \t  const char *s;\n \n-\t  s = b->cond_string;\n+\t  s = b->cond_string.get ();\n \t  try\n \t    {\n \t      new_loc->cond = parse_exp_1 (&s, sal.pc,\n@@ -13712,22 +13712,19 @@ location_to_sals (struct breakpoint *b, struct event_location *location,\n \tresolve_sal_pc (&sal);\n       if (b->condition_not_parsed && b->extra_string != NULL)\n \t{\n-\t  char *cond_string, *extra_string;\n+\t  gdb::unique_xmalloc_ptr<char> cond_string, extra_string;\n \t  int thread, task;\n \n-\t  find_condition_and_thread_for_sals (sals, b->extra_string,\n+\t  find_condition_and_thread_for_sals (sals, b->extra_string.get (),\n \t\t\t\t\t      &cond_string, &thread,\n \t\t\t\t\t      &task, &extra_string);\n \t  gdb_assert (b->cond_string == NULL);\n \t  if (cond_string)\n-\t    b->cond_string = cond_string;\n+\t    b->cond_string = std::move (cond_string);\n \t  b->thread = thread;\n \t  b->task = task;\n \t  if (extra_string)\n-\t    {\n-\t      xfree (b->extra_string);\n-\t      b->extra_string = extra_string;\n-\t    }\n+\t    b->extra_string = std::move (extra_string);\n \t  b->condition_not_parsed = 0;\n \t}\n \n@@ -15035,7 +15032,7 @@ save_breakpoints (const char *filename, int from_tty,\n \t instead.  */\n \n       if (tp->cond_string)\n-\tfp.printf (\"  condition $bpnum %s\\n\", tp->cond_string);\n+\tfp.printf (\"  condition $bpnum %s\\n\", tp->cond_string.get ());\n \n       if (tp->ignore_count)\n \tfp.printf (\"  ignore $bpnum %d\\n\", tp->ignore_count);"
    },
    {
      "sha": "f19f11eb479ef09edcc66119c29bacb5f5ee7e9d",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=6f781ee30062c822cf6475cfa070c6e7cf770de4",
      "patch": "@@ -720,7 +720,7 @@ using bp_location_range = next_range<bp_location>;\n \n struct breakpoint\n {\n-  virtual ~breakpoint ();\n+  virtual ~breakpoint () = default;\n \n   /* Return a range of this breakpoint's locations.  */\n   bp_location_range locations ();\n@@ -785,11 +785,11 @@ struct breakpoint\n   int input_radix = 0;\n   /* String form of the breakpoint condition (malloc'd), or NULL if\n      there is no condition.  */\n-  char *cond_string = NULL;\n+  gdb::unique_xmalloc_ptr<char> cond_string;\n \n   /* String form of extra parameters, or NULL if there are none.\n      Malloc'd.  */\n-  char *extra_string = NULL;\n+  gdb::unique_xmalloc_ptr<char> extra_string;\n \n   /* Holds the address of the related watchpoint_scope breakpoint when\n      using watchpoints on local variables (might the concept of a"
    },
    {
      "sha": "ab1ddb1bae093e20c5d55d84b3be7c2f7f4b3820",
      "filename": "gdb/guile/scm-breakpoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/guile/scm-breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/guile/scm-breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-breakpoint.c?ref=6f781ee30062c822cf6475cfa070c6e7cf770de4",
      "patch": "@@ -899,7 +899,7 @@ gdbscm_breakpoint_condition (SCM self)\n     = bpscm_get_valid_breakpoint_smob_arg_unsafe (self, SCM_ARG1, FUNC_NAME);\n   char *str;\n \n-  str = bp_smob->bp->cond_string;\n+  str = bp_smob->bp->cond_string.get ();\n   if (! str)\n     return SCM_BOOL_F;\n "
    },
    {
      "sha": "d99d9b18b49f5cf55e5a22425611e11472cf04a7",
      "filename": "gdb/python/py-breakpoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/python/py-breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/python/py-breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-breakpoint.c?ref=6f781ee30062c822cf6475cfa070c6e7cf770de4",
      "patch": "@@ -449,7 +449,7 @@ bppy_get_condition (PyObject *self, void *closure)\n \n   BPPY_REQUIRE_VALID (obj);\n \n-  str = obj->bp->cond_string;\n+  str = obj->bp->cond_string.get ();\n   if (! str)\n     Py_RETURN_NONE;\n "
    },
    {
      "sha": "7f530534fe6e5c9e535e773e3631f3f9f69102b5",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=6f781ee30062c822cf6475cfa070c6e7cf770de4",
      "patch": "@@ -13344,7 +13344,7 @@ remote_target::download_tracepoint (struct bp_location *loc)\n \t    error (\"%s\", err_msg);\n \n \t  encode_source_string (b->number, loc->address,\n-\t\t\t\t\"cond\", b->cond_string,\n+\t\t\t\t\"cond\", b->cond_string.get (),\n \t\t\t\tbuf.data () + strlen (buf.data ()),\n \t\t\t\tbuf.size () - strlen (buf.data ()));\n \t  putpkt (buf.data ());"
    },
    {
      "sha": "df5013e45ae899b86de5b3bb8414eca7cfe8db16",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6f781ee30062c822cf6475cfa070c6e7cf770de4/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=6f781ee30062c822cf6475cfa070c6e7cf770de4",
      "patch": "@@ -3094,7 +3094,7 @@ find_matching_tracepoint_location (struct uploaded_tp *utp)\n       if (b->type == utp->type\n \t  && t->step_count == utp->step\n \t  && t->pass_count == utp->pass\n-\t  && cond_string_is_same (t->cond_string,\n+\t  && cond_string_is_same (t->cond_string.get (),\n \t\t\t\t  utp->cond_string.get ())\n \t  /* FIXME also test actions.  */\n \t  )"
    }
  ]
}