{
  "sha": "d20172fc53017cef12d64b21aa2fdac72072558c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDIwMTcyZmM1MzAxN2NlZjEyZDY0YjIxYWEyZmRhYzcyMDcyNTU4Yw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@ericsson.com",
      "date": "2019-01-02T22:31:08Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@ericsson.com",
      "date": "2019-01-02T22:31:08Z"
    },
    "message": "Place displaced step data directly in inferior structure\n\nThis patch moves the per-inferior data related to displaced stepping to\nbe directly in the inferior structure, rather than in a container on the\nside.\n\nOn notable difference is that previously, we deleted the state on\ninferior exit, which guaranteed a clean state if re-using the inferior\nfor a new run or attach.  We now need to reset the state manually.\n\nAt the same time, I changed step_saved_copy to be a gdb::byte_vector, so\nit is automatically freed on destruction (which should plug the leak\nreported here [1]).\n\n[1] https://sourceware.org/ml/gdb-patches/2018-11/msg00202.html\n\ngdb/ChangeLog:\n\n\t* inferior.h (class inferior) <displaced_step_state>: New field.\n\t* infrun.h (struct displaced_step_state): Move here from\n\tinfrun.c.  Initialize fields, add constructor.\n\t<inf>: Remove field.\n\t<reset>: New method.\n\t* infrun.c (struct displaced_step_inferior_state): Move to\n\tinfrun.h.\n\t(displaced_step_inferior_states): Remove.\n\t(get_displaced_stepping_state): Adust.\n\t(displaced_step_in_progress_any_inferior): Adjust.\n\t(displaced_step_in_progress_thread): Adjust.\n\t(displaced_step_in_progress): Adjust.\n\t(add_displaced_stepping_state): Remove.\n\t(get_displaced_step_closure_by_addr): Adjust.\n\t(remove_displaced_stepping_state): Remove.\n\t(infrun_inferior_exit): Call displaced_step_state.reset.\n\t(use_displaced_stepping): Don't check for NULL.\n\t(displaced_step_prepare_throw): Call\n\tget_displaced_stepping_state.\n\t(displaced_step_fixup): Don't check for NULL.\n\t(prepare_for_detach): Don't check for NULL.",
    "tree": {
      "sha": "405b1ffd879db4b7a5681b885a9f14e1683a405f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/405b1ffd879db4b7a5681b885a9f14e1683a405f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d20172fc53017cef12d64b21aa2fdac72072558c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d20172fc53017cef12d64b21aa2fdac72072558c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d20172fc53017cef12d64b21aa2fdac72072558c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d20172fc53017cef12d64b21aa2fdac72072558c/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "e3319240732bc9543af8ced9d80ec89d0b629b2e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e3319240732bc9543af8ced9d80ec89d0b629b2e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e3319240732bc9543af8ced9d80ec89d0b629b2e"
    }
  ],
  "stats": {
    "total": 213,
    "additions": 91,
    "deletions": 122
  },
  "files": [
    {
      "sha": "c38461883041373d6a6616a22e050cc21966e955",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d20172fc53017cef12d64b21aa2fdac72072558c/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d20172fc53017cef12d64b21aa2fdac72072558c/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d20172fc53017cef12d64b21aa2fdac72072558c",
      "patch": "@@ -1,3 +1,27 @@\n+2019-01-02  Simon Marchi  <simon.marchi@ericsson.com>\n+\n+\t* inferior.h (class inferior) <displaced_step_state>: New field.\n+\t* infrun.h (struct displaced_step_state): Move here from\n+\tinfrun.c.  Initialize fields, add constructor.\n+\t<inf>: Remove field.\n+\t<reset>: New method.\n+\t* infrun.c (struct displaced_step_inferior_state): Move to\n+\tinfrun.h.\n+\t(displaced_step_inferior_states): Remove.\n+\t(get_displaced_stepping_state): Adust.\n+\t(displaced_step_in_progress_any_inferior): Adjust.\n+\t(displaced_step_in_progress_thread): Adjust.\n+\t(displaced_step_in_progress): Adjust.\n+\t(add_displaced_stepping_state): Remove.\n+\t(get_displaced_step_closure_by_addr): Adjust.\n+\t(remove_displaced_stepping_state): Remove.\n+\t(infrun_inferior_exit): Call displaced_step_state.reset.\n+\t(use_displaced_stepping): Don't check for NULL.\n+\t(displaced_step_prepare_throw): Call\n+\tget_displaced_stepping_state.\n+\t(displaced_step_fixup): Don't check for NULL.\n+\t(prepare_for_detach): Don't check for NULL.\n+\n 2019-01-02  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n \n \t* infcall.c (call_function_by_hand_dummy): cleanup/destroy sm"
    },
    {
      "sha": "a82df1a52a5cd8805308035a3f59cb53166c5aec",
      "filename": "gdb/inferior.h",
      "status": "modified",
      "additions": 3,
      "deletions": 0,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d20172fc53017cef12d64b21aa2fdac72072558c/gdb/inferior.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d20172fc53017cef12d64b21aa2fdac72072558c/gdb/inferior.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inferior.h?ref=d20172fc53017cef12d64b21aa2fdac72072558c",
      "patch": "@@ -503,6 +503,9 @@ class inferior : public refcounted_object\n      this gdbarch.  */\n   struct gdbarch *gdbarch = NULL;\n \n+  /* Data related to displaced stepping.  */\n+  displaced_step_inferior_state displaced_step_state;\n+\n   /* Per inferior data-pointers required by other GDB modules.  */\n   REGISTRY_FIELDS;\n };"
    },
    {
      "sha": "150288264f4aaf2420627b8a4833b66e6fa03443",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 20,
      "deletions": 122,
      "changes": 142,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d20172fc53017cef12d64b21aa2fdac72072558c/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d20172fc53017cef12d64b21aa2fdac72072558c/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=d20172fc53017cef12d64b21aa2fdac72072558c",
      "patch": "@@ -1476,53 +1476,12 @@ step_over_info_valid_p (void)\n \n displaced_step_closure::~displaced_step_closure () = default;\n \n-/* Per-inferior displaced stepping state.  */\n-struct displaced_step_inferior_state\n-{\n-  /* The process this displaced step state refers to.  */\n-  inferior *inf;\n-\n-  /* True if preparing a displaced step ever failed.  If so, we won't\n-     try displaced stepping for this inferior again.  */\n-  int failed_before;\n-\n-  /* If this is not nullptr, this is the thread carrying out a\n-     displaced single-step in process PID.  This thread's state will\n-     require fixing up once it has completed its step.  */\n-  thread_info *step_thread;\n-\n-  /* The architecture the thread had when we stepped it.  */\n-  struct gdbarch *step_gdbarch;\n-\n-  /* The closure provided gdbarch_displaced_step_copy_insn, to be used\n-     for post-step cleanup.  */\n-  struct displaced_step_closure *step_closure;\n-\n-  /* The address of the original instruction, and the copy we\n-     made.  */\n-  CORE_ADDR step_original, step_copy;\n-\n-  /* Saved contents of copy area.  */\n-  gdb_byte *step_saved_copy;\n-};\n-\n-/* The list of states of processes involved in displaced stepping\n-   presently.  */\n-static std::forward_list<displaced_step_inferior_state *>\n-  displaced_step_inferior_states;\n-\n /* Get the displaced stepping state of process PID.  */\n \n static displaced_step_inferior_state *\n get_displaced_stepping_state (inferior *inf)\n {\n-  for (auto *state : displaced_step_inferior_states)\n-    {\n-      if (state->inf == inf)\n-\treturn state;\n-    }\n-\n-  return nullptr;\n+  return &inf->displaced_step_state;\n }\n \n /* Returns true if any inferior has a thread doing a displaced\n@@ -1531,9 +1490,9 @@ get_displaced_stepping_state (inferior *inf)\n static bool\n displaced_step_in_progress_any_inferior ()\n {\n-  for (auto *state : displaced_step_inferior_states)\n+  for (inferior *i : all_inferiors ())\n     {\n-      if (state->step_thread != nullptr)\n+      if (i->displaced_step_state.step_thread != nullptr)\n \treturn true;\n     }\n \n@@ -1546,48 +1505,17 @@ displaced_step_in_progress_any_inferior ()\n static int\n displaced_step_in_progress_thread (thread_info *thread)\n {\n-  struct displaced_step_inferior_state *displaced;\n-\n   gdb_assert (thread != NULL);\n \n-  displaced = get_displaced_stepping_state (thread->inf);\n-\n-  return (displaced != NULL && displaced->step_thread == thread);\n+  return get_displaced_stepping_state (thread->inf)->step_thread == thread;\n }\n \n /* Return true if process PID has a thread doing a displaced step.  */\n \n static int\n displaced_step_in_progress (inferior *inf)\n {\n-  struct displaced_step_inferior_state *displaced;\n-\n-  displaced = get_displaced_stepping_state (inf);\n-  if (displaced != NULL && displaced->step_thread != nullptr)\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Add a new displaced stepping state for process PID to the displaced\n-   stepping state list, or return a pointer to an already existing\n-   entry, if it already exists.  Never returns NULL.  */\n-\n-static displaced_step_inferior_state *\n-add_displaced_stepping_state (inferior *inf)\n-{\n-  displaced_step_inferior_state *state\n-    = get_displaced_stepping_state (inf);\n-\n-  if (state != nullptr)\n-    return state;\n-\n-  state = XCNEW (struct displaced_step_inferior_state);\n-  state->inf = inf;\n-\n-  displaced_step_inferior_states.push_front (state);\n-\n-  return state;\n+  return get_displaced_stepping_state (inf)->step_thread != nullptr;\n }\n \n /* If inferior is in displaced stepping, and ADDR equals to starting address\n@@ -1597,42 +1525,21 @@ add_displaced_stepping_state (inferior *inf)\n struct displaced_step_closure*\n get_displaced_step_closure_by_addr (CORE_ADDR addr)\n {\n-  struct displaced_step_inferior_state *displaced\n+  displaced_step_inferior_state *displaced\n     = get_displaced_stepping_state (current_inferior ());\n \n   /* If checking the mode of displaced instruction in copy area.  */\n-  if (displaced != NULL\n-      && displaced->step_thread != nullptr\n+  if (displaced->step_thread != nullptr\n       && displaced->step_copy == addr)\n     return displaced->step_closure;\n \n   return NULL;\n }\n \n-/* Remove the displaced stepping state of process PID.  */\n-\n-static void\n-remove_displaced_stepping_state (inferior *inf)\n-{\n-  gdb_assert (inf != nullptr);\n-\n-  displaced_step_inferior_states.remove_if\n-    ([inf] (displaced_step_inferior_state *state)\n-      {\n-\tif (state->inf == inf)\n-\t  {\n-\t    xfree (state);\n-\t    return true;\n-\t  }\n-\telse\n-\t  return false;\n-      });\n-}\n-\n static void\n infrun_inferior_exit (struct inferior *inf)\n {\n-  remove_displaced_stepping_state (inf);\n+  inf->displaced_step_state.reset ();\n }\n \n /* If ON, and the architecture supports it, GDB will use displaced\n@@ -1669,17 +1576,15 @@ use_displaced_stepping (struct thread_info *tp)\n {\n   struct regcache *regcache = get_thread_regcache (tp);\n   struct gdbarch *gdbarch = regcache->arch ();\n-  struct displaced_step_inferior_state *displaced_state;\n-\n-  displaced_state = get_displaced_stepping_state (tp->inf);\n+  displaced_step_inferior_state *displaced_state\n+    = get_displaced_stepping_state (tp->inf);\n \n   return (((can_use_displaced_stepping == AUTO_BOOLEAN_AUTO\n \t    && target_is_non_stop_p ())\n \t   || can_use_displaced_stepping == AUTO_BOOLEAN_TRUE)\n \t  && gdbarch_displaced_step_copy_insn_p (gdbarch)\n \t  && find_record_target () == NULL\n-\t  && (displaced_state == NULL\n-\t      || !displaced_state->failed_before));\n+\t  && !displaced_state->failed_before);\n }\n \n /* Clean out any stray displaced stepping state.  */\n@@ -1734,14 +1639,12 @@ displaced_step_dump_bytes (struct ui_file *file,\n static int\n displaced_step_prepare_throw (thread_info *tp)\n {\n-  struct cleanup *ignore_cleanups;\n   regcache *regcache = get_thread_regcache (tp);\n   struct gdbarch *gdbarch = regcache->arch ();\n   const address_space *aspace = regcache->aspace ();\n   CORE_ADDR original, copy;\n   ULONGEST len;\n   struct displaced_step_closure *closure;\n-  struct displaced_step_inferior_state *displaced;\n   int status;\n \n   /* We should never reach this function if the architecture does not\n@@ -1760,7 +1663,8 @@ displaced_step_prepare_throw (thread_info *tp)\n   /* We have to displaced step one thread at a time, as we only have\n      access to a single scratch space per inferior.  */\n \n-  displaced = add_displaced_stepping_state (tp->inf);\n+  displaced_step_inferior_state *displaced\n+    = get_displaced_stepping_state (tp->inf);\n \n   if (displaced->step_thread != nullptr)\n     {\n@@ -1816,10 +1720,8 @@ displaced_step_prepare_throw (thread_info *tp)\n     }\n \n   /* Save the original contents of the copy area.  */\n-  displaced->step_saved_copy = (gdb_byte *) xmalloc (len);\n-  ignore_cleanups = make_cleanup (free_current_contents,\n-\t\t\t\t  &displaced->step_saved_copy);\n-  status = target_read_memory (copy, displaced->step_saved_copy, len);\n+  displaced->step_saved_copy.resize (len);\n+  status = target_read_memory (copy, displaced->step_saved_copy.data (), len);\n   if (status != 0)\n     throw_error (MEMORY_ERROR,\n \t\t _(\"Error accessing memory address %s (%s) for \"\n@@ -1830,7 +1732,7 @@ displaced_step_prepare_throw (thread_info *tp)\n       fprintf_unfiltered (gdb_stdlog, \"displaced: saved %s: \",\n \t\t\t  paddress (gdbarch, copy));\n       displaced_step_dump_bytes (gdb_stdlog,\n-\t\t\t\t displaced->step_saved_copy,\n+\t\t\t\t displaced->step_saved_copy.data (),\n \t\t\t\t len);\n     };\n \n@@ -1841,7 +1743,6 @@ displaced_step_prepare_throw (thread_info *tp)\n       /* The architecture doesn't know how or want to displaced step\n \t this instruction or instruction sequence.  Fallback to\n \t stepping over the breakpoint in-line.  */\n-      do_cleanups (ignore_cleanups);\n       return -1;\n     }\n \n@@ -1853,7 +1754,8 @@ displaced_step_prepare_throw (thread_info *tp)\n   displaced->step_original = original;\n   displaced->step_copy = copy;\n \n-  make_cleanup (displaced_step_clear_cleanup, displaced);\n+  cleanup *ignore_cleanups\n+    = make_cleanup (displaced_step_clear_cleanup, displaced);\n \n   /* Resume execution at the copy.  */\n   regcache_write_pc (regcache, copy);\n@@ -1931,7 +1833,7 @@ displaced_step_restore (struct displaced_step_inferior_state *displaced,\n   ULONGEST len = gdbarch_max_insn_length (displaced->step_gdbarch);\n \n   write_memory_ptid (ptid, displaced->step_copy,\n-\t\t     displaced->step_saved_copy, len);\n+\t\t     displaced->step_saved_copy.data (), len);\n   if (debug_displaced)\n     fprintf_unfiltered (gdb_stdlog, \"displaced: restored %s %s\\n\",\n \t\t\ttarget_pid_to_str (ptid),\n@@ -1953,10 +1855,6 @@ displaced_step_fixup (thread_info *event_thread, enum gdb_signal signal)\n     = get_displaced_stepping_state (event_thread->inf);\n   int ret;\n \n-  /* Was any thread of this process doing a displaced step?  */\n-  if (displaced == NULL)\n-    return 0;\n-\n   /* Was this event for the thread we displaced?  */\n   if (displaced->step_thread != event_thread)\n     return 0;\n@@ -3577,7 +3475,7 @@ prepare_for_detach (void)\n \n   /* Is any thread of this process displaced stepping?  If not,\n      there's nothing else to do.  */\n-  if (displaced == NULL || displaced->step_thread == nullptr)\n+  if (displaced->step_thread == nullptr)\n     return;\n \n   if (debug_infrun)"
    },
    {
      "sha": "8f61b75c15b82cb725efc22cc7e55316c0308ddd",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d20172fc53017cef12d64b21aa2fdac72072558c/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d20172fc53017cef12d64b21aa2fdac72072558c/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=d20172fc53017cef12d64b21aa2fdac72072558c",
      "patch": "@@ -258,4 +258,48 @@ struct buf_displaced_step_closure : displaced_step_closure\n   gdb::byte_vector buf;\n };\n \n+/* Per-inferior displaced stepping state.  */\n+struct displaced_step_inferior_state\n+{\n+  displaced_step_inferior_state ()\n+  {\n+    reset ();\n+  }\n+\n+  /* Put this object back in its original state.  */\n+  void reset ()\n+  {\n+    failed_before = 0;\n+    step_thread = nullptr;\n+    step_gdbarch = nullptr;\n+    step_closure = nullptr;\n+    step_original = 0;\n+    step_copy = 0;\n+    step_saved_copy.clear ();\n+  }\n+\n+  /* True if preparing a displaced step ever failed.  If so, we won't\n+     try displaced stepping for this inferior again.  */\n+  int failed_before;\n+\n+  /* If this is not nullptr, this is the thread carrying out a\n+     displaced single-step in process PID.  This thread's state will\n+     require fixing up once it has completed its step.  */\n+  thread_info *step_thread;\n+\n+  /* The architecture the thread had when we stepped it.  */\n+  gdbarch *step_gdbarch;\n+\n+  /* The closure provided gdbarch_displaced_step_copy_insn, to be used\n+     for post-step cleanup.  */\n+  displaced_step_closure *step_closure;\n+\n+  /* The address of the original instruction, and the copy we\n+     made.  */\n+  CORE_ADDR step_original, step_copy;\n+\n+  /* Saved contents of copy area.  */\n+  gdb::byte_vector step_saved_copy;\n+};\n+\n #endif /* INFRUN_H */"
    }
  ]
}