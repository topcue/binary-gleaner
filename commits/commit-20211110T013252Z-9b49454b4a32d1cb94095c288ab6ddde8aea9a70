{
  "sha": "9b49454b4a32d1cb94095c288ab6ddde8aea9a70",
  "node_id": "C_kwDOANOeidoAKDliNDk0NTRiNGEzMmQxY2I5NDA5NWMyODhhYjZkZGRlOGFlYTlhNzA",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-11-10T01:26:46Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-11-10T01:32:52Z"
    },
    "message": "Re: Add --unicode option\n\n\t* objdump: Whitespace fixes.\n\t(long_options): Correct \"ctf\" entry.",
    "tree": {
      "sha": "efcee6e8d4b15c64e07886fc003ff371840912c5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/efcee6e8d4b15c64e07886fc003ff371840912c5"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9b49454b4a32d1cb94095c288ab6ddde8aea9a70",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9b49454b4a32d1cb94095c288ab6ddde8aea9a70",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9b49454b4a32d1cb94095c288ab6ddde8aea9a70",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9b49454b4a32d1cb94095c288ab6ddde8aea9a70/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a9a09f5114c60e9900bc3a5663486d42ff5c2e73",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a9a09f5114c60e9900bc3a5663486d42ff5c2e73",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a9a09f5114c60e9900bc3a5663486d42ff5c2e73"
    }
  ],
  "stats": {
    "total": 78,
    "additions": 39,
    "deletions": 39
  },
  "files": [
    {
      "sha": "cf9cedc71ad1fbdd40900c9fdcd9d0a4686d4920",
      "filename": "binutils/objdump.c",
      "status": "modified",
      "additions": 39,
      "deletions": 39,
      "changes": 78,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9b49454b4a32d1cb94095c288ab6ddde8aea9a70/binutils/objdump.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9b49454b4a32d1cb94095c288ab6ddde8aea9a70/binutils/objdump.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/binutils/objdump.c?ref=9b49454b4a32d1cb94095c288ab6ddde8aea9a70",
      "patch": "@@ -438,7 +438,7 @@ static struct option long_options[]=\n   {\"architecture\", required_argument, NULL, 'm'},\n   {\"archive-headers\", no_argument, NULL, 'a'},\n #ifdef ENABLE_LIBCTF\n-  {\"ctf\", required_argument, NULL, OPTION_CTF},\n+  {\"ctf\", optional_argument, NULL, OPTION_CTF},\n   {\"ctf-parent\", required_argument, NULL, OPTION_CTF_PARENT},\n #endif\n   {\"debugging\", no_argument, NULL, 'g'},\n@@ -509,7 +509,7 @@ nonfatal (const char *msg)\n    Returns the number of characters added to OUT.\n    Returns the number of bytes consumed from IN in CONSUMED.\n    Always consumes at least one byte and displays at least one character.  */\n-   \n+\n static unsigned int\n display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)\n {\n@@ -563,7 +563,7 @@ display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)\n \tout += sprintf (out, \"%02x\", in [j]);\n       out += sprintf (out, \"%c\", unicode_display == unicode_hex ? '>' : '}');\n       break;\n-      \n+\n     case unicode_highlight:\n       if (isatty (1))\n \tout += sprintf (out, \"\\x1B[31;47m\"); /* Red.  */\n@@ -573,7 +573,7 @@ display_utf8 (const unsigned char * in, char * out, unsigned int * consumed)\n \t{\n \tcase 2:\n \t  out += sprintf (out, \"\\\\u%02x%02x\",\n-\t\t  ((in[0] & 0x1c) >> 2), \n+\t\t  ((in[0] & 0x1c) >> 2),\n \t\t  ((in[0] & 0x03) << 6) | (in[1] & 0x3f));\n \t  break;\n \n@@ -915,7 +915,7 @@ dump_headers (bfd *abfd)\n \n   if (wide_output)\n     bfd_map_over_sections (abfd, find_longest_section_name,\n-                           &max_section_name_length);\n+\t\t\t   &max_section_name_length);\n \n   printf (_(\"Idx %-*s Size      %-*s%-*sFile off  Algn\"),\n \t  max_section_name_length, \"Name\",\n@@ -927,7 +927,7 @@ dump_headers (bfd *abfd)\n   printf (\"\\n\");\n \n   bfd_map_over_sections (abfd, dump_section_header,\n-                         &max_section_name_length);\n+\t\t\t &max_section_name_length);\n }\n \f\n static asymbol **\n@@ -1297,7 +1297,7 @@ sym_ok (bool want_section,\n   if (want_section)\n     {\n       /* NB: An object file can have different sections with the same\n-         section name.  Compare compare section pointers if they have\n+\t section name.  Compare compare section pointers if they have\n \t the same owner.  */\n       if (sorted_syms[place]->section->owner == sec->owner\n \t  && sorted_syms[place]->section != sec)\n@@ -1417,7 +1417,7 @@ find_symbol_for_address (bfd_vma vma,\n \t\t      && vma >= bfd_section_vma (sec)\n \t\t      && vma < (bfd_section_vma (sec)\n \t\t\t\t+ bfd_section_size (sec) / opb)));\n-  \n+\n   if (! sym_ok (want_section, abfd, thisplace, sec, inf))\n     {\n       long i;\n@@ -1488,7 +1488,7 @@ find_symbol_for_address (bfd_vma vma,\n \t  if (rel->address == vma)\n \t    {\n \t      /* Absolute relocations do not provide a more helpful\n-\t         symbolic address.  Find a non-absolute relocation\n+\t\t symbolic address.  Find a non-absolute relocation\n \t\t with the same address.  */\n \t      arelent **rel_vma = rel_mid;\n \t      for (rel_mid--;\n@@ -1978,7 +1978,7 @@ show_line (bfd *abfd, asection *section, bfd_vma addr_offset)\n \t    {\n \t      /* Demangle the name.  */\n \t      demangle_alloc = bfd_demangle (abfd, functionname,\n-\t                                          demangle_flags);\n+\t\t\t\t\t     demangle_flags);\n \t    }\n \n \t  /* Demangling adds trailing parens, so don't print those.  */\n@@ -2565,7 +2565,7 @@ disassemble_jumps (struct disassemble_info * inf,\n       inf->bytes_per_line = 0;\n       inf->bytes_per_chunk = 0;\n       inf->flags = ((disassemble_all ? DISASSEMBLE_DATA : 0)\n-        | (wide_output ? WIDE_OUTPUT : 0));\n+\t\t    | (wide_output ? WIDE_OUTPUT : 0));\n       if (machine)\n \tinf->flags |= USER_SPECIFIED_MACHINE_TYPE;\n \n@@ -3376,8 +3376,8 @@ disassemble_section (bfd *abfd, asection *section, void *inf)\n   /* Find the nearest symbol forwards from our current position.  */\n   paux->require_sec = true;\n   sym = (asymbol *) find_symbol_for_address (section->vma + addr_offset,\n-                                             (struct disassemble_info *) inf,\n-                                             &place);\n+\t\t\t\t\t     (struct disassemble_info *) inf,\n+\t\t\t\t\t     &place);\n   paux->require_sec = false;\n \n   /* PR 9774: If the target used signed addresses then we must make\n@@ -3629,7 +3629,7 @@ disassemble_data (bfd *abfd)\n      because that will screw up the relocs.  */\n   sorted_symcount = symcount ? symcount : dynsymcount;\n   sorted_syms = (asymbol **) xmalloc ((sorted_symcount + synthcount)\n-                                      * sizeof (asymbol *));\n+\t\t\t\t      * sizeof (asymbol *));\n   if (sorted_symcount != 0)\n     {\n       memcpy (sorted_syms, symcount ? syms : dynsyms,\n@@ -3909,7 +3909,7 @@ open_debug_file (const char * pathname)\n \n   if (! bfd_check_format (data, bfd_object))\n     return NULL;\n-  \n+\n   return data;\n }\n \n@@ -3972,7 +3972,7 @@ dump_dwarf_section (bfd *abfd, asection *section,\n \telse\n \t  sec->name = sec->xcoff_name;\n \tif (load_specific_debug_section ((enum dwarf_section_display_enum) i,\n-                                         section, abfd))\n+\t\t\t\t\t section, abfd))\n \t  {\n \t    debug_displays [i].display (sec, abfd);\n \n@@ -4438,22 +4438,22 @@ dump_target_specific (bfd *abfd)\n       e = strchr (b, ',');\n \n       if (e)\n-        *e = 0;\n+\t*e = 0;\n \n       for (opt = (*desc)->options; opt->name; opt++)\n-        if (strcmp (opt->name, b) == 0)\n-          {\n-            opt->selected = true;\n-            break;\n-          }\n+\tif (strcmp (opt->name, b) == 0)\n+\t  {\n+\t    opt->selected = true;\n+\t    break;\n+\t  }\n       if (opt->name == NULL)\n-        non_fatal (_(\"target specific dump '%s' not supported\"), b);\n+\tnon_fatal (_(\"target specific dump '%s' not supported\"), b);\n \n       if (e)\n-        {\n-          *e = ',';\n-          b = e + 1;\n-        }\n+\t{\n+\t  *e = ',';\n+\t  b = e + 1;\n+\t}\n     }\n   while (e != NULL);\n \n@@ -4736,8 +4736,8 @@ dump_reloc_set (bfd *abfd, asection *sec, arelent **relpp, long relcount)\n       if (with_line_numbers\n \t  && sec != NULL\n \t  && bfd_find_nearest_line_discriminator (abfd, sec, syms, q->address,\n-                                                  &filename, &functionname,\n-                                                  &linenumber, &discriminator))\n+\t\t\t\t\t\t  &filename, &functionname,\n+\t\t\t\t\t\t  &linenumber, &discriminator))\n \t{\n \t  if (functionname != NULL\n \t      && (last_functionname == NULL\n@@ -4754,15 +4754,15 @@ dump_reloc_set (bfd *abfd, asection *sec, arelent **relpp, long relcount)\n \t\t  || (filename != NULL\n \t\t      && last_filename != NULL\n \t\t      && filename_cmp (filename, last_filename) != 0)\n-                  || (discriminator != last_discriminator)))\n+\t\t  || (discriminator != last_discriminator)))\n \t    {\n-              if (discriminator > 0)\n-                printf (\"%s:%u\\n\", filename == NULL ? \"???\" :\n+\t      if (discriminator > 0)\n+\t\tprintf (\"%s:%u\\n\", filename == NULL ? \"???\" :\n \t\t\tsanitize_string (filename), linenumber);\n-              else\n-                printf (\"%s:%u (discriminator %u)\\n\",\n+\t      else\n+\t\tprintf (\"%s:%u (discriminator %u)\\n\",\n \t\t\tfilename == NULL ? \"???\" : sanitize_string (filename),\n-                        linenumber, discriminator);\n+\t\t\tlinenumber, discriminator);\n \t      last_line = linenumber;\n \t      last_discriminator = discriminator;\n \t      if (last_filename != NULL)\n@@ -5015,7 +5015,7 @@ dump_bfd (bfd *abfd, bool is_mainfile)\n      displaying information about the main file.  Any memory allocated by\n      load_separate_debug_files will be released when we call\n      free_debug_memory below.\n-     \n+\n      The test on is_mainfile is there because the chain of separate debug\n      info files is a global variable shared by all invocations of dump_bfd.  */\n   if (byte_get != NULL && is_mainfile)\n@@ -5088,7 +5088,7 @@ dump_bfd (bfd *abfd, bool is_mainfile)\n \t    {\n \t      asymbol **  extra_syms;\n \t      long        old_symcount = symcount;\n-\t      \n+\n \t      extra_syms = slurp_symtab (i->handle);\n \n \t      if (extra_syms)\n@@ -5253,7 +5253,7 @@ display_any_bfd (bfd *file, int level)\n       bfd *last_arfile = NULL;\n \n       if (level == 0)\n-        printf (_(\"In archive %s:\\n\"), sanitize_string (bfd_get_filename (file)));\n+\tprintf (_(\"In archive %s:\\n\"), sanitize_string (bfd_get_filename (file)));\n       else if (level > 100)\n \t{\n \t  /* Prevent corrupted files from spinning us into an\n@@ -5262,7 +5262,7 @@ display_any_bfd (bfd *file, int level)\n \t  return;\n \t}\n       else\n-        printf (_(\"In nested archive %s:\\n\"),\n+\tprintf (_(\"In nested archive %s:\\n\"),\n \t\tsanitize_string (bfd_get_filename (file)));\n \n       for (;;)"
    }
  ]
}