{
  "sha": "2b0c285ea552d2ce116efb85af749d69ebbddb59",
  "node_id": "C_kwDOANOeidoAKDJiMGMyODVlYTU1MmQyY2UxMTZlZmI4NWFmNzQ5ZDY5ZWJiZGRiNTk",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-14T15:29:42Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2022-01-18T17:01:16Z"
    },
    "message": "Split event_location into subclasses\n\nevent_location uses the old C-style discriminated union approach.\nHowever, it's better to use subclassing, as this makes the code\nclearer and removes some chances for error.  This also enables future\ncleanups to avoid manual memory management and copies.",
    "tree": {
      "sha": "8abbac61485de6eafa837879592ee4fc2930d826",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8abbac61485de6eafa837879592ee4fc2930d826"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/2b0c285ea552d2ce116efb85af749d69ebbddb59",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b0c285ea552d2ce116efb85af749d69ebbddb59",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/2b0c285ea552d2ce116efb85af749d69ebbddb59",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2b0c285ea552d2ce116efb85af749d69ebbddb59/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "49a9cf56ffd49539234e6cb33a5d1d19ba4e2388",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/49a9cf56ffd49539234e6cb33a5d1d19ba4e2388",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/49a9cf56ffd49539234e6cb33a5d1d19ba4e2388"
    }
  ],
  "stats": {
    "total": 520,
    "additions": 281,
    "deletions": 239
  },
  "files": [
    {
      "sha": "4e092300cec94d1f006f35108d10abeb97b176ef",
      "filename": "gdb/location.c",
      "status": "modified",
      "additions": 281,
      "deletions": 239,
      "changes": 520,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/2b0c285ea552d2ce116efb85af749d69ebbddb59/gdb/location.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/2b0c285ea552d2ce116efb85af749d69ebbddb59/gdb/location.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/location.c?ref=2b0c285ea552d2ce116efb85af749d69ebbddb59",
      "patch": "@@ -29,33 +29,267 @@\n #include <ctype.h>\n #include <string.h>\n \n-/* An event location used to set a stop event in the inferior.\n-   This structure is an amalgam of the various ways\n-   to specify where a stop event should be set.  */\n+static gdb::unique_xmalloc_ptr<char> explicit_location_to_string\n+     (const struct explicit_location *explicit_loc);\n+\n+/* The base class for all an event locations used to set a stop event\n+   in the inferior.  */\n \n struct event_location\n {\n+  virtual ~event_location ()\n+  {\n+    xfree (as_string);\n+  }\n+\n+  /* Clone this object.  */\n+  virtual event_location_up clone () const = 0;\n+\n+  /* Return true if this location is empty, false otherwise.  */\n+  virtual bool empty_p () const = 0;\n+\n+  /* Return a string representation of this location.  */\n+  const char *to_string ()\n+  {\n+    if (as_string == nullptr)\n+      as_string = compute_string ();\n+    return as_string;\n+  }\n+\n+  DISABLE_COPY_AND_ASSIGN (event_location);\n+\n   /* The type of this breakpoint specification.  */\n   enum event_location_type type;\n \n-  union\n+  /* Cached string representation of this location.  This is used, e.g., to\n+     save stop event locations to file.  Malloc'd.  */\n+  char *as_string = nullptr;\n+\n+protected:\n+\n+  explicit event_location (enum event_location_type t)\n+    : type (t)\n   {\n-    /* A probe.  */\n-    char *addr_string;\n+  }\n \n-    /* A \"normal\" linespec.  */\n-    struct linespec_location linespec_location;\n+  explicit event_location (const event_location *to_clone)\n+    : type (to_clone->type),\n+      as_string (to_clone->as_string == nullptr\n+\t\t ? nullptr\n+\t\t : xstrdup (to_clone->as_string))\n+  {\n+  }\n \n-    /* An address in the inferior.  */\n-    CORE_ADDR address;\n+  /* Compute the string representation of this object.  This is called\n+     by to_string when needed.  */\n+  virtual char *compute_string () = 0;\n+};\n \n-    /* An explicit location.  */\n-    struct explicit_location explicit_loc;\n-  } u;\n+/* A probe.  */\n+struct event_location_probe : public event_location\n+{\n+  explicit event_location_probe (const char *probe)\n+    : event_location (PROBE_LOCATION),\n+      addr_string (probe == nullptr\n+\t\t   ? nullptr\n+\t\t   : xstrdup (probe))\n+  {\n+  }\n \n-  /* Cached string representation of this location.  This is used, e.g., to\n-     save stop event locations to file.  Malloc'd.  */\n-  char *as_string;\n+  ~event_location_probe ()\n+  {\n+    xfree (addr_string);\n+  }\n+\n+  event_location_up clone () const override\n+  {\n+    return event_location_up (new event_location_probe (this));\n+  }\n+\n+  bool empty_p () const override\n+  {\n+    return addr_string == nullptr;\n+  }\n+\n+  char *addr_string;\n+\n+protected:\n+\n+  explicit event_location_probe (const event_location_probe *to_clone)\n+    : event_location (to_clone),\n+      addr_string (to_clone->addr_string == nullptr\n+\t\t   ? nullptr\n+\t\t   : xstrdup (to_clone->addr_string))\n+  {\n+  }\n+\n+  char *compute_string () override\n+  {\n+    return xstrdup (addr_string);\n+  }\n+};\n+\n+/* A \"normal\" linespec.  */\n+struct event_location_linespec : public event_location\n+{\n+  event_location_linespec (const char **linespec,\n+\t\t\t   symbol_name_match_type match_type)\n+    : event_location (LINESPEC_LOCATION)\n+  {\n+    linespec_location.match_type = match_type;\n+    if (*linespec != NULL)\n+      {\n+\tconst char *p;\n+\tconst char *orig = *linespec;\n+\n+\tlinespec_lex_to_end (linespec);\n+\tp = remove_trailing_whitespace (orig, *linespec);\n+\tif ((p - orig) > 0)\n+\t  linespec_location.spec_string = savestring (orig, p - orig);\n+      }\n+  }\n+\n+  ~event_location_linespec ()\n+  {\n+    xfree (linespec_location.spec_string);\n+  }\n+\n+  event_location_up clone () const override\n+  {\n+    return event_location_up (new event_location_linespec (this));\n+  }\n+\n+  bool empty_p () const override\n+  {\n+    return false;\n+  }\n+\n+  struct linespec_location linespec_location {};\n+\n+protected:\n+\n+  explicit event_location_linespec (const event_location_linespec *to_clone)\n+    : event_location (to_clone),\n+      linespec_location (to_clone->linespec_location)\n+  {\n+    if (linespec_location.spec_string != nullptr)\n+      linespec_location.spec_string = xstrdup (linespec_location.spec_string);\n+  }\n+\n+  char *compute_string () override\n+  {\n+    if (linespec_location.spec_string != nullptr)\n+      {\n+\tstruct linespec_location *ls = &linespec_location;\n+\tif (ls->match_type == symbol_name_match_type::FULL)\n+\t  return concat (\"-qualified \", ls->spec_string, (char *) nullptr);\n+\telse\n+\t  return xstrdup (ls->spec_string);\n+      }\n+    return nullptr;\n+  }\n+};\n+\n+/* An address in the inferior.  */\n+struct event_location_address : public event_location\n+{\n+  event_location_address (CORE_ADDR addr, const char *addr_string,\n+\t\t\t  int addr_string_len)\n+    : event_location (ADDRESS_LOCATION),\n+      address (addr)\n+  {\n+    if (addr_string != nullptr)\n+      as_string = xstrndup (addr_string, addr_string_len);\n+  }\n+\n+  event_location_up clone () const override\n+  {\n+    return event_location_up (new event_location_address (this));\n+  }\n+\n+  bool empty_p () const override\n+  {\n+    return false;\n+  }\n+\n+  CORE_ADDR address;\n+\n+protected:\n+\n+  event_location_address (const event_location_address *to_clone)\n+    : event_location (to_clone),\n+      address (to_clone->address)\n+  {\n+  }\n+\n+  char *compute_string () override\n+  {\n+    const char *addr_string = core_addr_to_string (address);\n+    return xstrprintf (\"*%s\", addr_string).release ();\n+  }\n+};\n+\n+/* An explicit location.  */\n+struct event_location_explicit : public event_location\n+{\n+  explicit event_location_explicit (const struct explicit_location *loc)\n+    : event_location (EXPLICIT_LOCATION)\n+  {\n+    copy_loc (loc);\n+  }\n+\n+  ~event_location_explicit ()\n+  {\n+    xfree (explicit_loc.source_filename);\n+    xfree (explicit_loc.function_name);\n+    xfree (explicit_loc.label_name);\n+  }\n+\n+  event_location_up clone () const override\n+  {\n+    return event_location_up (new event_location_explicit (this));\n+  }\n+\n+  bool empty_p () const override\n+  {\n+    return (explicit_loc.source_filename == nullptr\n+\t    && explicit_loc.function_name == nullptr\n+\t    && explicit_loc.label_name == nullptr\n+\t    && explicit_loc.line_offset.sign == LINE_OFFSET_UNKNOWN);\n+  }\n+\n+  struct explicit_location explicit_loc;\n+\n+protected:\n+\n+  explicit event_location_explicit (const event_location_explicit *to_clone)\n+    : event_location (to_clone)\n+  {\n+    copy_loc (&to_clone->explicit_loc);\n+  }\n+\n+  char *compute_string () override\n+  {\n+    return explicit_location_to_string (&explicit_loc).release ();\n+  }\n+\n+private:\n+\n+  void copy_loc (const struct explicit_location *loc)\n+  {\n+    initialize_explicit_location (&explicit_loc);\n+    if (loc != nullptr)\n+      {\n+\texplicit_loc.func_name_match_type = loc->func_name_match_type;\n+\tif (loc->source_filename != nullptr)\n+\t  explicit_loc.source_filename = xstrdup (loc->source_filename);\n+\tif (loc->function_name != nullptr)\n+\t  explicit_loc.function_name = xstrdup (loc->function_name);\n+\tif (loc->label_name != nullptr)\n+\t  explicit_loc.label_name = xstrdup (loc->label_name);\n+\texplicit_loc.line_offset = loc->line_offset;\n+      }\n+  }\n };\n \n /* See description in location.h.  */\n@@ -82,23 +316,8 @@ event_location_up\n new_linespec_location (const char **linespec,\n \t\t       symbol_name_match_type match_type)\n {\n-  struct event_location *location;\n-\n-  location = XCNEW (struct event_location);\n-  location->type = LINESPEC_LOCATION;\n-  location->u.linespec_location.match_type = match_type;\n-  if (*linespec != NULL)\n-    {\n-      const char *p;\n-      const char *orig = *linespec;\n-\n-      linespec_lex_to_end (linespec);\n-      p = remove_trailing_whitespace (orig, *linespec);\n-      if ((p - orig) > 0)\n-\tlocation->u.linespec_location.spec_string\n-\t  = savestring (orig, p - orig);\n-    }\n-  return event_location_up (location);\n+  return event_location_up (new event_location_linespec (linespec,\n+\t\t\t\t\t\t\t match_type));\n }\n \n /* See description in location.h.  */\n@@ -107,7 +326,7 @@ const linespec_location *\n get_linespec_location (const struct event_location *location)\n {\n   gdb_assert (location->type == LINESPEC_LOCATION);\n-  return &location->u.linespec_location;\n+  return &((event_location_linespec *) location)->linespec_location;\n }\n \n /* See description in location.h.  */\n@@ -116,14 +335,8 @@ event_location_up\n new_address_location (CORE_ADDR addr, const char *addr_string,\n \t\t      int addr_string_len)\n {\n-  struct event_location *location;\n-\n-  location = XCNEW (struct event_location);\n-  location->type = ADDRESS_LOCATION;\n-  location->u.address = addr;\n-  if (addr_string != NULL)\n-    location->as_string = xstrndup (addr_string, addr_string_len);\n-  return event_location_up (location);\n+  return event_location_up (new event_location_address (addr, addr_string,\n+\t\t\t\t\t\t\taddr_string_len));\n }\n \n /* See description in location.h.  */\n@@ -132,7 +345,7 @@ CORE_ADDR\n get_address_location (const struct event_location *location)\n {\n   gdb_assert (location->type == ADDRESS_LOCATION);\n-  return location->u.address;\n+  return ((event_location_address *) location)->address;\n }\n \n /* See description in location.h.  */\n@@ -149,13 +362,7 @@ get_address_string_location (const struct event_location *location)\n event_location_up\n new_probe_location (const char *probe)\n {\n-  struct event_location *location;\n-\n-  location = XCNEW (struct event_location);\n-  location->type = PROBE_LOCATION;\n-  if (probe != NULL)\n-    location->u.addr_string = xstrdup (probe);\n-  return event_location_up (location);\n+  return event_location_up (new event_location_probe (probe));\n }\n \n /* See description in location.h.  */\n@@ -164,42 +371,15 @@ const char *\n get_probe_location (const struct event_location *location)\n {\n   gdb_assert (location->type == PROBE_LOCATION);\n-  return location->u.addr_string;\n+  return ((event_location_probe *) location)->addr_string;\n }\n \n /* See description in location.h.  */\n \n event_location_up\n new_explicit_location (const struct explicit_location *explicit_loc)\n {\n-  struct event_location tmp;\n-\n-  memset (&tmp, 0, sizeof (struct event_location));\n-  tmp.type = EXPLICIT_LOCATION;\n-  initialize_explicit_location (&tmp.u.explicit_loc);\n-  if (explicit_loc != NULL)\n-    {\n-      tmp.u.explicit_loc.func_name_match_type\n-\t= explicit_loc->func_name_match_type;\n-\n-      if (explicit_loc->source_filename != NULL)\n-\t{\n-\t  tmp.u.explicit_loc.source_filename\n-\t    = explicit_loc->source_filename;\n-\t}\n-\n-      if (explicit_loc->function_name != NULL)\n-\ttmp.u.explicit_loc.function_name\n-\t  = explicit_loc->function_name;\n-\n-      if (explicit_loc->label_name != NULL)\n-\ttmp.u.explicit_loc.label_name = explicit_loc->label_name;\n-\n-      if (explicit_loc->line_offset.sign != LINE_OFFSET_UNKNOWN)\n-\ttmp.u.explicit_loc.line_offset = explicit_loc->line_offset;\n-    }\n-\n-  return copy_event_location (&tmp);\n+  return event_location_up (new event_location_explicit (explicit_loc));\n }\n \n /* See description in location.h.  */\n@@ -208,7 +388,7 @@ struct explicit_location *\n get_explicit_location (struct event_location *location)\n {\n   gdb_assert (location->type == EXPLICIT_LOCATION);\n-  return &location->u.explicit_loc;\n+  return &((event_location_explicit *) location)->explicit_loc;\n }\n \n /* See description in location.h.  */\n@@ -217,7 +397,7 @@ const struct explicit_location *\n get_explicit_location_const (const struct event_location *location)\n {\n   gdb_assert (location->type == EXPLICIT_LOCATION);\n-  return &location->u.explicit_loc;\n+  return &((event_location_explicit *) location)->explicit_loc;\n }\n \n /* This convenience function returns a malloc'd string which\n@@ -301,140 +481,21 @@ explicit_location_to_linespec (const struct explicit_location *explicit_loc)\n event_location_up\n copy_event_location (const struct event_location *src)\n {\n-  struct event_location *dst;\n-\n-  dst = XCNEW (struct event_location);\n-  dst->type = src->type;\n-  if (src->as_string != NULL)\n-    dst->as_string = xstrdup (src->as_string);\n-\n-  switch (src->type)\n-    {\n-    case LINESPEC_LOCATION:\n-      dst->u.linespec_location.match_type\n-\t= src->u.linespec_location.match_type;\n-      if (src->u.linespec_location.spec_string != NULL)\n-\tdst->u.linespec_location.spec_string\n-\t  = xstrdup (src->u.linespec_location.spec_string);\n-      break;\n-\n-    case ADDRESS_LOCATION:\n-      dst->u.address = src->u.address;\n-      break;\n-\n-    case EXPLICIT_LOCATION:\n-      dst->u.explicit_loc.func_name_match_type\n-\t= src->u.explicit_loc.func_name_match_type;\n-      if (src->u.explicit_loc.source_filename != NULL)\n-\tdst->u.explicit_loc.source_filename\n-\t  = xstrdup (src->u.explicit_loc.source_filename);\n-\n-      if (src->u.explicit_loc.function_name != NULL)\n-\tdst->u.explicit_loc.function_name\n-\t  = xstrdup (src->u.explicit_loc.function_name);\n-\n-      if (src->u.explicit_loc.label_name != NULL)\n-\tdst->u.explicit_loc.label_name\n-\t  = xstrdup (src->u.explicit_loc.label_name);\n-\n-      dst->u.explicit_loc.line_offset = src->u.explicit_loc.line_offset;\n-      break;\n-\n-\n-    case PROBE_LOCATION:\n-      if (src->u.addr_string != NULL)\n-\tdst->u.addr_string = xstrdup (src->u.addr_string);\n-      break;\n-\n-    default:\n-      gdb_assert_not_reached (\"unknown event location type\");\n-    }\n-\n-  return event_location_up (dst);\n+  return src->clone ();\n }\n \n void\n event_location_deleter::operator() (event_location *location) const\n {\n-  if (location != NULL)\n-    {\n-      xfree (location->as_string);\n-\n-      switch (location->type)\n-\t{\n-\tcase LINESPEC_LOCATION:\n-\t  xfree (location->u.linespec_location.spec_string);\n-\t  break;\n-\n-\tcase ADDRESS_LOCATION:\n-\t  /* Nothing to do.  */\n-\t  break;\n-\n-\tcase EXPLICIT_LOCATION:\n-\t  xfree (location->u.explicit_loc.source_filename);\n-\t  xfree (location->u.explicit_loc.function_name);\n-\t  xfree (location->u.explicit_loc.label_name);\n-\t  break;\n-\n-\tcase PROBE_LOCATION:\n-\t  xfree (location->u.addr_string);\n-\t  break;\n-\n-\tdefault:\n-\t  gdb_assert_not_reached (\"unknown event location type\");\n-\t}\n-\n-      xfree (location);\n-    }\n+  delete location;\n }\n \n /* See description in location.h.  */\n \n const char *\n event_location_to_string (struct event_location *location)\n {\n-  if (location->as_string == NULL)\n-    {\n-      switch (location->type)\n-\t{\n-\tcase LINESPEC_LOCATION:\n-\t  if (location->u.linespec_location.spec_string != NULL)\n-\t    {\n-\t      linespec_location *ls = &location->u.linespec_location;\n-\t      if (ls->match_type == symbol_name_match_type::FULL)\n-\t\t{\n-\t\t  location->as_string\n-\t\t    = concat (\"-qualified \", ls->spec_string, (char *) NULL);\n-\t\t}\n-\t      else\n-\t\tlocation->as_string = xstrdup (ls->spec_string);\n-\t    }\n-\t  break;\n-\n-\tcase ADDRESS_LOCATION:\n-\t  {\n-\t    const char *addr_string\n-\t      = core_addr_to_string (location->u.address);\n-\t    location->as_string\n-\t      = xstrprintf (\"*%s\", addr_string).release ();\n-\t  }\n-\t  break;\n-\n-\tcase EXPLICIT_LOCATION:\n-\t  location->as_string\n-\t    = explicit_location_to_string (&location->u.explicit_loc).release ();\n-\t  break;\n-\n-\tcase PROBE_LOCATION:\n-\t  location->as_string = xstrdup (location->u.addr_string);\n-\t  break;\n-\n-\tdefault:\n-\t  gdb_assert_not_reached (\"unknown event location type\");\n-\t}\n-    }\n-\n-  return location->as_string;\n+  return location->to_string ();\n }\n \n /* Find an instance of the quote character C in the string S that is\n@@ -720,8 +781,6 @@ string_to_explicit_location (const char **argp,\n \t\t\t     const struct language_defn *language,\n \t\t\t     explicit_completion_info *completion_info)\n {\n-  event_location_up location;\n-\n   /* It is assumed that input beginning with '-' and a non-digit\n      character is an explicit location.  \"-p\" is reserved, though,\n      for probe locations.  */\n@@ -732,7 +791,8 @@ string_to_explicit_location (const char **argp,\n       || ((*argp)[0] == '-' && (*argp)[1] == 'p'))\n     return NULL;\n \n-  location = new_explicit_location (NULL);\n+  std::unique_ptr<event_location_explicit> location\n+    (new event_location_explicit ((const explicit_location *) nullptr));\n \n   /* Process option/argument pairs.  dprintf_command\n      requires that processing stop on ','.  */\n@@ -801,17 +861,17 @@ string_to_explicit_location (const char **argp,\n \t{\n \t  set_oarg (explicit_location_lex_one (argp, language,\n \t\t\t\t\t       completion_info));\n-\t  location->u.explicit_loc.source_filename = oarg.release ();\n+\t  location->explicit_loc.source_filename = oarg.release ();\n \t}\n       else if (strncmp (opt.get (), \"-function\", len) == 0)\n \t{\n \t  set_oarg (explicit_location_lex_one_function (argp, language,\n \t\t\t\t\t\t\tcompletion_info));\n-\t  location->u.explicit_loc.function_name = oarg.release ();\n+\t  location->explicit_loc.function_name = oarg.release ();\n \t}\n       else if (strncmp (opt.get (), \"-qualified\", len) == 0)\n \t{\n-\t  location->u.explicit_loc.func_name_match_type\n+\t  location->explicit_loc.func_name_match_type\n \t    = symbol_name_match_type::FULL;\n \t}\n       else if (strncmp (opt.get (), \"-line\", len) == 0)\n@@ -820,15 +880,15 @@ string_to_explicit_location (const char **argp,\n \t  *argp = skip_spaces (*argp);\n \t  if (have_oarg)\n \t    {\n-\t      location->u.explicit_loc.line_offset\n+\t      location->explicit_loc.line_offset\n \t\t= linespec_parse_line_offset (oarg.get ());\n \t      continue;\n \t    }\n \t}\n       else if (strncmp (opt.get (), \"-label\", len) == 0)\n \t{\n \t  set_oarg (explicit_location_lex_one (argp, language, completion_info));\n-\t  location->u.explicit_loc.label_name = oarg.release ();\n+\t  location->explicit_loc.label_name = oarg.release ();\n \t}\n       /* Only emit an \"invalid argument\" error for options\n \t that look like option strings.  */\n@@ -858,17 +918,17 @@ string_to_explicit_location (const char **argp,\n \n   /* One special error check:  If a source filename was given\n      without offset, function, or label, issue an error.  */\n-  if (location->u.explicit_loc.source_filename != NULL\n-      && location->u.explicit_loc.function_name == NULL\n-      && location->u.explicit_loc.label_name == NULL\n-      && (location->u.explicit_loc.line_offset.sign == LINE_OFFSET_UNKNOWN)\n+  if (location->explicit_loc.source_filename != NULL\n+      && location->explicit_loc.function_name == NULL\n+      && location->explicit_loc.label_name == NULL\n+      && (location->explicit_loc.line_offset.sign == LINE_OFFSET_UNKNOWN)\n       && completion_info == NULL)\n     {\n       error (_(\"Source filename requires function, label, or \"\n \t       \"line offset.\"));\n     }\n \n-  return location;\n+  return event_location_up (location.release ());\n }\n \n /* See description in location.h.  */\n@@ -937,7 +997,10 @@ string_to_event_location (const char **stringp,\n \t \"-qualified\", otherwise string_to_explicit_location would\n \t have thrown an error.  Save the flags for \"basic\" linespec\n \t parsing below and discard the explicit location.  */\n-      match_type = location->u.explicit_loc.func_name_match_type;\n+      event_location_explicit *xloc\n+\t= dynamic_cast<event_location_explicit *> (location.get ());\n+      gdb_assert (xloc != nullptr);\n+      match_type = xloc->explicit_loc.func_name_match_type;\n     }\n \n   /* Everything else is a \"basic\" linespec, address, or probe\n@@ -950,28 +1013,7 @@ string_to_event_location (const char **stringp,\n int\n event_location_empty_p (const struct event_location *location)\n {\n-  switch (location->type)\n-    {\n-    case LINESPEC_LOCATION:\n-      /* Linespecs are never \"empty.\"  (NULL is a valid linespec)  */\n-      return 0;\n-\n-    case ADDRESS_LOCATION:\n-      return 0;\n-\n-    case EXPLICIT_LOCATION:\n-      return (location->u.explicit_loc.source_filename == NULL\n-\t      && location->u.explicit_loc.function_name == NULL\n-\t      && location->u.explicit_loc.label_name == NULL\n-\t      && (location->u.explicit_loc.line_offset.sign\n-\t\t  == LINE_OFFSET_UNKNOWN));\n-\n-    case PROBE_LOCATION:\n-      return location->u.addr_string == NULL;\n-\n-    default:\n-      gdb_assert_not_reached (\"unknown event location type\");\n-    }\n+  return location->empty_p ();\n }\n \n /* See description in location.h.  */"
    }
  ]
}