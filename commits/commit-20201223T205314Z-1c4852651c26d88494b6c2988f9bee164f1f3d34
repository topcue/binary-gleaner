{
  "sha": "1c4852651c26d88494b6c2988f9bee164f1f3d34",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWM0ODUyNjUxYzI2ZDg4NDk0YjZjMjk4OGY5YmVlMTY0ZjFmM2QzNA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-10-30T15:09:35Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-12-23T20:53:14Z"
    },
    "message": "gdb: move rust_language into rust-lang.h\n\nMove the rust_language class declaration into the rust-lang.h header\nfile.  This allows for the function implementations called directly in\nrust-lang.c and rust-exp.y without the need for trampoline functions.\n\nThere should be no user visible changes after this commit.\n\ngdb/ChangeLog:\n\n\t* rust-exp.y (rust_parse): Rename to...\n\t(rust_language::parser): ...this.\n\t* rust-lang.c (-rust_printstr): Rename to...\n\t(rust_language::printstr): ...this.\n\t(rust_value_print_inner): Delete declaration.\n\t(val_print_struct): Rename to...\n\t(rust_language::val_print_struct): ...this.  Update calls to\n\tmember functions.\n\t(rust_print_enum): Rename to...\n\t(rust_language::print_enum): ...this.  Update calls to member\n\tfunctions.\n\t(rust_value_print_inner): Rename to...\n\t(rust_language::value_print_inner): ...this.  Update calls to\n\tmember functions.\n\t(exp_descriptor_rust): Rename to...\n\t(rust_language::exp_descriptor_tab): ...this.\n\t(class rust_language): Move to rust-lang.h.\n\t(rust_language::language_arch_info): Implementation moved to here\n\tfrom class declaration.\n\t(rust_language::print_type): Likewise.\n\t(rust_language::emitchar): Likewise.\n\t(rust_language::is_string_type_p): Likewise.\n\t* rust-lang.h: Add 'demangle.h', 'language.h', 'value.h', and\n\t'c-lang.h' includes.\n\t(rust_parse): Delete declaration.\n\t(class rust_language): Class declaration moved here from\n\trust-lang.c.",
    "tree": {
      "sha": "d041d0dca40c135463bc1c700a66ea8ebcaeced9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d041d0dca40c135463bc1c700a66ea8ebcaeced9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1c4852651c26d88494b6c2988f9bee164f1f3d34",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1c4852651c26d88494b6c2988f9bee164f1f3d34",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1c4852651c26d88494b6c2988f9bee164f1f3d34",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1c4852651c26d88494b6c2988f9bee164f1f3d34/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ed5797ee2c17bae5d15204cbfa9a3918c7e4c1a9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ed5797ee2c17bae5d15204cbfa9a3918c7e4c1a9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ed5797ee2c17bae5d15204cbfa9a3918c7e4c1a9"
    }
  ],
  "stats": {
    "total": 627,
    "additions": 346,
    "deletions": 281
  },
  "files": [
    {
      "sha": "a7224352c3243d71441937edef9e3a73a606fe98",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 30,
      "deletions": 0,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c4852651c26d88494b6c2988f9bee164f1f3d34/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c4852651c26d88494b6c2988f9bee164f1f3d34/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1c4852651c26d88494b6c2988f9bee164f1f3d34",
      "patch": "@@ -1,3 +1,33 @@\n+2020-12-23  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* rust-exp.y (rust_parse): Rename to...\n+\t(rust_language::parser): ...this.\n+\t* rust-lang.c (-rust_printstr): Rename to...\n+\t(rust_language::printstr): ...this.\n+\t(rust_value_print_inner): Delete declaration.\n+\t(val_print_struct): Rename to...\n+\t(rust_language::val_print_struct): ...this.  Update calls to\n+\tmember functions.\n+\t(rust_print_enum): Rename to...\n+\t(rust_language::print_enum): ...this.  Update calls to member\n+\tfunctions.\n+\t(rust_value_print_inner): Rename to...\n+\t(rust_language::value_print_inner): ...this.  Update calls to\n+\tmember functions.\n+\t(exp_descriptor_rust): Rename to...\n+\t(rust_language::exp_descriptor_tab): ...this.\n+\t(class rust_language): Move to rust-lang.h.\n+\t(rust_language::language_arch_info): Implementation moved to here\n+\tfrom class declaration.\n+\t(rust_language::print_type): Likewise.\n+\t(rust_language::emitchar): Likewise.\n+\t(rust_language::is_string_type_p): Likewise.\n+\t* rust-lang.h: Add 'demangle.h', 'language.h', 'value.h', and\n+\t'c-lang.h' includes.\n+\t(rust_parse): Delete declaration.\n+\t(class rust_language): Class declaration moved here from\n+\trust-lang.c.\n+\n 2020-12-23  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* objc-lang.c (objc_language::opcode_print_table): Return"
    },
    {
      "sha": "19d583d71f2d20496648b62ff19e1082f0203b0f",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c4852651c26d88494b6c2988f9bee164f1f3d34/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c4852651c26d88494b6c2988f9bee164f1f3d34/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=1c4852651c26d88494b6c2988f9bee164f1f3d34",
      "patch": "@@ -2540,7 +2540,7 @@ rust_parser::convert_ast_to_expression (const struct rust_op *operation,\n /* The parser as exposed to gdb.  */\n \n int\n-rust_parse (struct parser_state *state)\n+rust_language::parser (struct parser_state *state) const\n {\n   int result;\n "
    },
    {
      "sha": "cda739760c5d6abf7a72cee94a1a78b08aa07e49",
      "filename": "gdb/rust-lang.c",
      "status": "modified",
      "additions": 120,
      "deletions": 277,
      "changes": 397,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c4852651c26d88494b6c2988f9bee164f1f3d34/gdb/rust-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c4852651c26d88494b6c2988f9bee164f1f3d34/gdb/rust-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.c?ref=1c4852651c26d88494b6c2988f9bee164f1f3d34",
      "patch": "@@ -262,13 +262,13 @@ rust_get_trait_object_pointer (struct value *value)\n \n \f\n \n-/* language_defn::printstr implementation for Rust.  */\n+/* See language.h.  */\n \n-static void\n-rust_printstr (struct ui_file *stream, struct type *type,\n-\t       const gdb_byte *string, unsigned int length,\n-\t       const char *user_encoding, int force_ellipses,\n-\t       const struct value_print_options *options)\n+void\n+rust_language::printstr (struct ui_file *stream, struct type *type,\n+\t\t\t const gdb_byte *string, unsigned int length,\n+\t\t\t const char *user_encoding, int force_ellipses,\n+\t\t\t const struct value_print_options *options) const\n {\n   /* Rust always uses UTF-8, but let the caller override this if need\n      be.  */\n@@ -295,10 +295,6 @@ rust_printstr (struct ui_file *stream, struct type *type,\n \n \f\n \n-static void rust_value_print_inner (struct value *val, struct ui_file *stream,\n-\t\t\t\t    int recurse,\n-\t\t\t\t    const struct value_print_options *options);\n-\n /* Helper function to print a string slice.  */\n \n static void\n@@ -314,11 +310,12 @@ rust_val_print_str (struct ui_file *stream, struct value *val,\n \t\t    options);\n }\n \n-/* rust_val_print helper for structs and untagged unions.  */\n+/* See rust-lang.h.  */\n \n-static void\n-val_print_struct (struct value *val, struct ui_file *stream, int recurse,\n-\t\t  const struct value_print_options *options)\n+void\n+rust_language::val_print_struct\n+\t(struct value *val, struct ui_file *stream, int recurse,\n+\t const struct value_print_options *options) const\n {\n   int i;\n   int first_field;\n@@ -388,8 +385,7 @@ val_print_struct (struct value *val, struct ui_file *stream, int recurse,\n \t  fputs_filtered (\": \", stream);\n \t}\n \n-      rust_value_print_inner (value_field (val, i), stream, recurse + 1,\n-\t\t\t      &opts);\n+      value_print_inner (value_field (val, i), stream, recurse + 1, &opts);\n     }\n \n   if (options->prettyformat)\n@@ -404,11 +400,12 @@ val_print_struct (struct value *val, struct ui_file *stream, int recurse,\n     fputs_filtered (\"}\", stream);\n }\n \n-/* rust_val_print helper for discriminated unions (Rust enums).  */\n+/* See rust-lang.h.  */\n \n-static void\n-rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n-\t\t const struct value_print_options *options)\n+void\n+rust_language::print_enum (struct value *val, struct ui_file *stream,\n+\t\t\t   int recurse,\n+\t\t\t   const struct value_print_options *options) const\n {\n   struct value_print_options opts = *options;\n   struct type *type = check_typedef (value_type (val));\n@@ -466,8 +463,7 @@ rust_print_enum (struct value *val, struct ui_file *stream, int recurse,\n \t\t\t  styled_string (variable_name_style.style (),\n \t\t\t\t\t TYPE_FIELD_NAME (variant_type, j)));\n \n-      rust_value_print_inner (value_field (val, j), stream, recurse + 1,\n-\t\t\t      &opts);\n+      value_print_inner (value_field (val, j), stream, recurse + 1, &opts);\n     }\n \n   if (is_tuple)\n@@ -490,11 +486,12 @@ static const struct generic_val_print_decorations rust_decorations =\n   \"]\"\n };\n \n-/* la_value_print_inner implementation for Rust.  */\n-static void\n-rust_value_print_inner (struct value *val, struct ui_file *stream,\n-\t\t\tint recurse,\n-\t\t\tconst struct value_print_options *options)\n+/* See language.h.  */\n+\n+void\n+rust_language::value_print_inner\n+\t(struct value *val, struct ui_file *stream, int recurse,\n+\t const struct value_print_options *options) const\n {\n   struct value_print_options opts = *options;\n   opts.deref_ref = 1;\n@@ -557,9 +554,9 @@ rust_value_print_inner (struct value *val, struct ui_file *stream,\n \t   byte string, hence the choice of \"ASCII\" as the\n \t   encoding.  */\n \tfputs_filtered (\"b\", stream);\n-\trust_printstr (stream, TYPE_TARGET_TYPE (type),\n-\t\t       value_contents_for_printing (val),\n-\t\t       high_bound - low_bound + 1, \"ASCII\", 0, &opts);\n+\tprintstr (stream, TYPE_TARGET_TYPE (type),\n+\t\t  value_contents_for_printing (val),\n+\t\t  high_bound - low_bound + 1, \"ASCII\", 0, &opts);\n       }\n       break;\n \n@@ -586,7 +583,7 @@ rust_value_print_inner (struct value *val, struct ui_file *stream,\n \n     case TYPE_CODE_STRUCT:\n       if (rust_enum_p (type))\n-\trust_print_enum (val, stream, recurse, &opts);\n+\tprint_enum (val, stream, recurse, &opts);\n       else\n \tval_print_struct (val, stream, recurse, &opts);\n       break;\n@@ -1849,7 +1846,7 @@ rust_operator_check (struct expression *exp, int pos,\n \n \f\n \n-static const struct exp_descriptor exp_descriptor_rust = \n+const struct exp_descriptor rust_language::exp_descriptor_tab =\n {\n   rust_print_subexp,\n   rust_operator_length,\n@@ -1858,262 +1855,108 @@ static const struct exp_descriptor exp_descriptor_rust =\n   rust_evaluate_subexp\n };\n \n-/* Class representing the Rust language.  */\n+/* See language.h.  */\n \n-class rust_language : public language_defn\n+void\n+rust_language::language_arch_info (struct gdbarch *gdbarch,\n+\t\t\t\t   struct language_arch_info *lai) const\n {\n-public:\n-  rust_language ()\n-    : language_defn (language_rust)\n-  { /* Nothing.  */ }\n-\n-  /* See language.h.  */\n-\n-  const char *name () const override\n-  { return \"rust\"; }\n-\n-  /* See language.h.  */\n-\n-  const char *natural_name () const override\n-  { return \"Rust\"; }\n-\n-  /* See language.h.  */\n-\n-  const std::vector<const char *> &filename_extensions () const override\n-  {\n-    static const std::vector<const char *> extensions = { \".rs\" };\n-    return extensions;\n-  }\n-\n-  /* See language.h.  */\n-  void language_arch_info (struct gdbarch *gdbarch,\n-\t\t\t   struct language_arch_info *lai) const override\n-  {\n-    const struct builtin_type *builtin = builtin_type (gdbarch);\n-\n-    /* Helper function to allow shorter lines below.  */\n-    auto add  = [&] (struct type * t) -> struct type *\n-    {\n-      lai->add_primitive_type (t);\n-      return t;\n-    };\n-\n-    struct type *bool_type\n-      = add (arch_boolean_type (gdbarch, 8, 1, \"bool\"));\n-    add (arch_character_type (gdbarch, 32, 1, \"char\"));\n-    add (arch_integer_type (gdbarch, 8, 0, \"i8\"));\n-    struct type *u8_type\n-      = add (arch_integer_type (gdbarch, 8, 1, \"u8\"));\n-    add (arch_integer_type (gdbarch, 16, 0, \"i16\"));\n-    add (arch_integer_type (gdbarch, 16, 1, \"u16\"));\n-    add (arch_integer_type (gdbarch, 32, 0, \"i32\"));\n-    add (arch_integer_type (gdbarch, 32, 1, \"u32\"));\n-    add (arch_integer_type (gdbarch, 64, 0, \"i64\"));\n-    add (arch_integer_type (gdbarch, 64, 1, \"u64\"));\n-\n-    unsigned int length = 8 * TYPE_LENGTH (builtin->builtin_data_ptr);\n-    add (arch_integer_type (gdbarch, length, 0, \"isize\"));\n-    struct type *usize_type\n-      = add (arch_integer_type (gdbarch, length, 1, \"usize\"));\n-\n-    add (arch_float_type (gdbarch, 32, \"f32\", floatformats_ieee_single));\n-    add (arch_float_type (gdbarch, 64, \"f64\", floatformats_ieee_double));\n-    add (arch_integer_type (gdbarch, 0, 1, \"()\"));\n-\n-    struct type *tem = make_cv_type (1, 0, u8_type, NULL);\n-    add (rust_slice_type (\"&str\", tem, usize_type));\n-\n-    lai->set_bool_type (bool_type);\n-    lai->set_string_char_type (u8_type);\n-  }\n-\n-  /* See language.h.  */\n-  bool sniff_from_mangled_name (const char *mangled,\n-\t\t\t\tchar **demangled) const override\n-  {\n-    *demangled = gdb_demangle (mangled, DMGL_PARAMS | DMGL_ANSI);\n-    return *demangled != NULL;\n-  }\n-\n-  /* See language.h.  */\n-\n-  char *demangle_symbol (const char *mangled, int options) const override\n-  {\n-    return gdb_demangle (mangled, options);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void print_type (struct type *type, const char *varstring,\n-\t\t   struct ui_file *stream, int show, int level,\n-\t\t   const struct type_print_options *flags) const override\n-  {\n-    print_offset_data podata;\n-    rust_internal_print_type (type, varstring, stream, show, level,\n-\t\t\t      flags, false, &podata);\n-  }\n-\n-  /* See language.h.  */\n-\n-  gdb::unique_xmalloc_ptr<char> watch_location_expression\n-\t(struct type *type, CORE_ADDR addr) const override\n-  {\n-    type = check_typedef (TYPE_TARGET_TYPE (check_typedef (type)));\n-    std::string name = type_to_string (type);\n-    return gdb::unique_xmalloc_ptr<char>\n-      (xstrprintf (\"*(%s as *mut %s)\", core_addr_to_string (addr),\n-\t\t   name.c_str ()));\n-  }\n-\n-  /* See language.h.  */\n-\n-  void value_print_inner\n-\t(struct value *val, struct ui_file *stream, int recurse,\n-\t const struct value_print_options *options) const override\n-  {\n-    return rust_value_print_inner (val, stream, recurse, options);\n-  }\n-\n-  /* See language.h.  */\n-\n-  struct block_symbol lookup_symbol_nonlocal\n-\t(const char *name, const struct block *block,\n-\t const domain_enum domain) const override\n-  {\n-    struct block_symbol result = {};\n-\n-    if (symbol_lookup_debug)\n-      {\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"rust_lookup_symbol_non_local\"\n-\t\t\t    \" (%s, %s (scope %s), %s)\\n\",\n-\t\t\t    name, host_address_to_string (block),\n-\t\t\t    block_scope (block), domain_name (domain));\n-      }\n-\n-    /* Look up bare names in the block's scope.  */\n-    std::string scopedname;\n-    if (name[cp_find_first_component (name)] == '\\0')\n-      {\n-\tconst char *scope = block_scope (block);\n-\n-\tif (scope[0] != '\\0')\n-\t  {\n-\t    scopedname = std::string (scope) + \"::\" + name;\n-\t    name = scopedname.c_str ();\n-\t  }\n-\telse\n-\t  name = NULL;\n-      }\n-\n-    if (name != NULL)\n-      {\n-\tresult = lookup_symbol_in_static_block (name, block, domain);\n-\tif (result.symbol == NULL)\n-\t  result = lookup_global_symbol (name, block, domain);\n-      }\n-    return result;\n-  }\n-\n-  /* See language.h.  */\n+  const struct builtin_type *builtin = builtin_type (gdbarch);\n \n-  int parser (struct parser_state *ps) const override\n+  /* Helper function to allow shorter lines below.  */\n+  auto add  = [&] (struct type * t) -> struct type *\n   {\n-    return rust_parse (ps);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void emitchar (int ch, struct type *chtype,\n-\t\t struct ui_file *stream, int quoter) const override\n-  {\n-    if (!rust_chartype_p (chtype))\n-      generic_emit_char (ch, chtype, stream, quoter,\n-\t\t\t target_charset (get_type_arch (chtype)));\n-    else if (ch == '\\\\' || ch == quoter)\n-      fprintf_filtered (stream, \"\\\\%c\", ch);\n-    else if (ch == '\\n')\n-      fputs_filtered (\"\\\\n\", stream);\n-    else if (ch == '\\r')\n-      fputs_filtered (\"\\\\r\", stream);\n-    else if (ch == '\\t')\n-      fputs_filtered (\"\\\\t\", stream);\n-    else if (ch == '\\0')\n-      fputs_filtered (\"\\\\0\", stream);\n-    else if (ch >= 32 && ch <= 127 && isprint (ch))\n-      fputc_filtered (ch, stream);\n-    else if (ch <= 255)\n-      fprintf_filtered (stream, \"\\\\x%02x\", ch);\n-    else\n-      fprintf_filtered (stream, \"\\\\u{%06x}\", ch);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void printchar (int ch, struct type *chtype,\n-\t\t  struct ui_file *stream) const override\n-  {\n-    fputs_filtered (\"'\", stream);\n-    emitchar (ch, chtype, stream, '\\'');\n-    fputs_filtered (\"'\", stream);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void printstr (struct ui_file *stream, struct type *elttype,\n-\t\t const gdb_byte *string, unsigned int length,\n-\t\t const char *encoding, int force_ellipses,\n-\t\t const struct value_print_options *options) const override\n-  {\n-    rust_printstr (stream, elttype, string, length, encoding,\n-\t\t   force_ellipses, options);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void print_typedef (struct type *type, struct symbol *new_symbol,\n-\t\t      struct ui_file *stream) const override\n-  {\n-    type = check_typedef (type);\n-    fprintf_filtered (stream, \"type %s = \", new_symbol->print_name ());\n-    type_print (type, \"\", stream, 0);\n-    fprintf_filtered (stream, \";\");\n-  }\n-\n-  /* See language.h.  */\n-\n-  bool is_string_type_p (struct type *type) const override\n-  {\n-    LONGEST low_bound, high_bound;\n+    lai->add_primitive_type (t);\n+    return t;\n+  };\n+\n+  struct type *bool_type\n+    = add (arch_boolean_type (gdbarch, 8, 1, \"bool\"));\n+  add (arch_character_type (gdbarch, 32, 1, \"char\"));\n+  add (arch_integer_type (gdbarch, 8, 0, \"i8\"));\n+  struct type *u8_type\n+    = add (arch_integer_type (gdbarch, 8, 1, \"u8\"));\n+  add (arch_integer_type (gdbarch, 16, 0, \"i16\"));\n+  add (arch_integer_type (gdbarch, 16, 1, \"u16\"));\n+  add (arch_integer_type (gdbarch, 32, 0, \"i32\"));\n+  add (arch_integer_type (gdbarch, 32, 1, \"u32\"));\n+  add (arch_integer_type (gdbarch, 64, 0, \"i64\"));\n+  add (arch_integer_type (gdbarch, 64, 1, \"u64\"));\n+\n+  unsigned int length = 8 * TYPE_LENGTH (builtin->builtin_data_ptr);\n+  add (arch_integer_type (gdbarch, length, 0, \"isize\"));\n+  struct type *usize_type\n+    = add (arch_integer_type (gdbarch, length, 1, \"usize\"));\n+\n+  add (arch_float_type (gdbarch, 32, \"f32\", floatformats_ieee_single));\n+  add (arch_float_type (gdbarch, 64, \"f64\", floatformats_ieee_double));\n+  add (arch_integer_type (gdbarch, 0, 1, \"()\"));\n+\n+  struct type *tem = make_cv_type (1, 0, u8_type, NULL);\n+  add (rust_slice_type (\"&str\", tem, usize_type));\n+\n+  lai->set_bool_type (bool_type);\n+  lai->set_string_char_type (u8_type);\n+}\n \n-    type = check_typedef (type);\n-    return ((type->code () == TYPE_CODE_STRING)\n-\t    || (type->code () == TYPE_CODE_PTR\n-\t\t&& (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ARRAY\n-\t\t    && rust_u8_type_p (TYPE_TARGET_TYPE (TYPE_TARGET_TYPE (type)))\n-\t\t    && get_array_bounds (TYPE_TARGET_TYPE (type), &low_bound,\n-\t\t\t\t\t &high_bound)))\n-\t    || (type->code () == TYPE_CODE_STRUCT\n-\t\t&& !rust_enum_p (type)\n-\t\t&& rust_slice_type_p (type)\n-\t\t&& strcmp (type->name (), \"&str\") == 0));\n-  }\n+/* See language.h.  */\n \n-  /* See language.h.  */\n+void\n+rust_language::print_type (struct type *type, const char *varstring,\n+\t\t\t   struct ui_file *stream, int show, int level,\n+\t\t\t   const struct type_print_options *flags) const\n+{\n+  print_offset_data podata;\n+  rust_internal_print_type (type, varstring, stream, show, level,\n+\t\t\t    flags, false, &podata);\n+}\n \n-  bool range_checking_on_by_default () const override\n-  { return true; }\n+/* See language.h.  */\n \n-  /* See language.h.  */\n+void\n+rust_language::emitchar (int ch, struct type *chtype,\n+\t\t\t struct ui_file *stream, int quoter) const\n+{\n+  if (!rust_chartype_p (chtype))\n+    generic_emit_char (ch, chtype, stream, quoter,\n+\t\t       target_charset (get_type_arch (chtype)));\n+  else if (ch == '\\\\' || ch == quoter)\n+    fprintf_filtered (stream, \"\\\\%c\", ch);\n+  else if (ch == '\\n')\n+    fputs_filtered (\"\\\\n\", stream);\n+  else if (ch == '\\r')\n+    fputs_filtered (\"\\\\r\", stream);\n+  else if (ch == '\\t')\n+    fputs_filtered (\"\\\\t\", stream);\n+  else if (ch == '\\0')\n+    fputs_filtered (\"\\\\0\", stream);\n+  else if (ch >= 32 && ch <= 127 && isprint (ch))\n+    fputc_filtered (ch, stream);\n+  else if (ch <= 255)\n+    fprintf_filtered (stream, \"\\\\x%02x\", ch);\n+  else\n+    fprintf_filtered (stream, \"\\\\u{%06x}\", ch);\n+}\n \n-  const struct exp_descriptor *expression_ops () const override\n-  { return &exp_descriptor_rust; }\n+/* See language.h.  */\n \n-  /* See language.h.  */\n+bool\n+rust_language::is_string_type_p (struct type *type) const\n+{\n+  LONGEST low_bound, high_bound;\n \n-  const struct op_print *opcode_print_table () const override\n-  { return c_op_print_tab; }\n-};\n+  type = check_typedef (type);\n+  return ((type->code () == TYPE_CODE_STRING)\n+\t  || (type->code () == TYPE_CODE_PTR\n+\t      && (TYPE_TARGET_TYPE (type)->code () == TYPE_CODE_ARRAY\n+\t\t  && rust_u8_type_p (TYPE_TARGET_TYPE (TYPE_TARGET_TYPE (type)))\n+\t\t  && get_array_bounds (TYPE_TARGET_TYPE (type), &low_bound,\n+\t\t\t\t       &high_bound)))\n+\t  || (type->code () == TYPE_CODE_STRUCT\n+\t      && !rust_enum_p (type)\n+\t      && rust_slice_type_p (type)\n+\t      && strcmp (type->name (), \"&str\") == 0));\n+}\n \n /* Single instance of the Rust language class.  */\n "
    },
    {
      "sha": "df94fc145637ea0ed7985f81acaa72d8db792de0",
      "filename": "gdb/rust-lang.h",
      "status": "modified",
      "additions": 195,
      "deletions": 3,
      "changes": 198,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1c4852651c26d88494b6c2988f9bee164f1f3d34/gdb/rust-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1c4852651c26d88494b6c2988f9bee164f1f3d34/gdb/rust-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.h?ref=1c4852651c26d88494b6c2988f9bee164f1f3d34",
      "patch": "@@ -20,12 +20,14 @@\n #ifndef RUST_LANG_H\n #define RUST_LANG_H\n \n+#include \"demangle.h\"\n+#include \"language.h\"\n+#include \"value.h\"\n+#include \"c-lang.h\"\n+\n struct parser_state;\n struct type;\n \n-/* The la_parser implementation for Rust.  */\n-extern int rust_parse (struct parser_state *);\n-\n /* Return true if TYPE is a tuple type; otherwise false.  */\n extern bool rust_tuple_type_p (struct type *type);\n \n@@ -48,4 +50,194 @@ extern const char *rust_last_path_segment (const char *path);\n extern struct type *rust_slice_type (const char *name, struct type *elt_type,\n \t\t\t\t     struct type *usize_type);\n \n+/* Class representing the Rust language.  */\n+\n+class rust_language : public language_defn\n+{\n+public:\n+  rust_language ()\n+    : language_defn (language_rust)\n+  { /* Nothing.  */ }\n+\n+  /* See language.h.  */\n+\n+  const char *name () const override\n+  { return \"rust\"; }\n+\n+  /* See language.h.  */\n+\n+  const char *natural_name () const override\n+  { return \"Rust\"; }\n+\n+  /* See language.h.  */\n+\n+  const std::vector<const char *> &filename_extensions () const override\n+  {\n+    static const std::vector<const char *> extensions = { \".rs\" };\n+    return extensions;\n+  }\n+\n+  /* See language.h.  */\n+\n+  void language_arch_info (struct gdbarch *gdbarch,\n+\t\t\t   struct language_arch_info *lai) const override;\n+\n+  /* See language.h.  */\n+\n+  bool sniff_from_mangled_name (const char *mangled,\n+\t\t\t\tchar **demangled) const override\n+  {\n+    *demangled = gdb_demangle (mangled, DMGL_PARAMS | DMGL_ANSI);\n+    return *demangled != NULL;\n+  }\n+\n+  /* See language.h.  */\n+\n+  char *demangle_symbol (const char *mangled, int options) const override\n+  {\n+    return gdb_demangle (mangled, options);\n+  }\n+\n+  /* See language.h.  */\n+\n+  void print_type (struct type *type, const char *varstring,\n+\t\t   struct ui_file *stream, int show, int level,\n+\t\t   const struct type_print_options *flags) const override;\n+\n+  /* See language.h.  */\n+\n+  gdb::unique_xmalloc_ptr<char> watch_location_expression\n+\t(struct type *type, CORE_ADDR addr) const override\n+  {\n+    type = check_typedef (TYPE_TARGET_TYPE (check_typedef (type)));\n+    std::string name = type_to_string (type);\n+    return gdb::unique_xmalloc_ptr<char>\n+      (xstrprintf (\"*(%s as *mut %s)\", core_addr_to_string (addr),\n+\t\t   name.c_str ()));\n+  }\n+\n+  /* See language.h.  */\n+\n+  void value_print_inner\n+\t(struct value *val, struct ui_file *stream, int recurse,\n+\t const struct value_print_options *options) const override;\n+\n+  /* See language.h.  */\n+\n+  struct block_symbol lookup_symbol_nonlocal\n+\t(const char *name, const struct block *block,\n+\t const domain_enum domain) const override\n+  {\n+    struct block_symbol result = {};\n+\n+    if (symbol_lookup_debug)\n+      {\n+\tfprintf_unfiltered (gdb_stdlog,\n+\t\t\t    \"rust_lookup_symbol_non_local\"\n+\t\t\t    \" (%s, %s (scope %s), %s)\\n\",\n+\t\t\t    name, host_address_to_string (block),\n+\t\t\t    block_scope (block), domain_name (domain));\n+      }\n+\n+    /* Look up bare names in the block's scope.  */\n+    std::string scopedname;\n+    if (name[cp_find_first_component (name)] == '\\0')\n+      {\n+\tconst char *scope = block_scope (block);\n+\n+\tif (scope[0] != '\\0')\n+\t  {\n+\t    scopedname = std::string (scope) + \"::\" + name;\n+\t    name = scopedname.c_str ();\n+\t  }\n+\telse\n+\t  name = NULL;\n+      }\n+\n+    if (name != NULL)\n+      {\n+\tresult = lookup_symbol_in_static_block (name, block, domain);\n+\tif (result.symbol == NULL)\n+\t  result = lookup_global_symbol (name, block, domain);\n+      }\n+    return result;\n+  }\n+\n+  /* See language.h.  */\n+\n+  int parser (struct parser_state *ps) const override;\n+\n+  /* See language.h.  */\n+\n+  void emitchar (int ch, struct type *chtype,\n+\t\t struct ui_file *stream, int quoter) const override;\n+\n+  /* See language.h.  */\n+\n+  void printchar (int ch, struct type *chtype,\n+\t\t  struct ui_file *stream) const override\n+  {\n+    fputs_filtered (\"'\", stream);\n+    emitchar (ch, chtype, stream, '\\'');\n+    fputs_filtered (\"'\", stream);\n+  }\n+\n+  /* See language.h.  */\n+\n+  void printstr (struct ui_file *stream, struct type *elttype,\n+\t\t const gdb_byte *string, unsigned int length,\n+\t\t const char *encoding, int force_ellipses,\n+\t\t const struct value_print_options *options) const override;\n+\n+  /* See language.h.  */\n+\n+  void print_typedef (struct type *type, struct symbol *new_symbol,\n+\t\t      struct ui_file *stream) const override\n+  {\n+    type = check_typedef (type);\n+    fprintf_filtered (stream, \"type %s = \", new_symbol->print_name ());\n+    type_print (type, \"\", stream, 0);\n+    fprintf_filtered (stream, \";\");\n+  }\n+\n+  /* See language.h.  */\n+\n+  bool is_string_type_p (struct type *type) const override;\n+\n+  /* See language.h.  */\n+\n+  bool range_checking_on_by_default () const override\n+  { return true; }\n+\n+  /* See language.h.  */\n+\n+  const struct exp_descriptor *expression_ops () const override\n+  { return &exp_descriptor_tab; }\n+\n+  /* See language.h.  */\n+\n+  const struct op_print *opcode_print_table () const override\n+  { return c_op_print_tab; }\n+\n+private:\n+\n+  /* Table of expression handling functions for use by EXPRESSION_OPS\n+     member function.  */\n+\n+  static const struct exp_descriptor exp_descriptor_tab;\n+\n+  /* Helper for value_print_inner, arguments are as for that function.\n+     Prints structs and untagged unions.  */\n+\n+  void val_print_struct (struct value *val, struct ui_file *stream,\n+\t\t\t int recurse,\n+\t\t\t const struct value_print_options *options) const;\n+\n+  /* Helper for value_print_inner, arguments are as for that function.\n+     Prints discriminated unions (Rust enums).  */\n+\n+  void print_enum (struct value *val, struct ui_file *stream, int recurse,\n+\t\t   const struct value_print_options *options) const;\n+};\n+\n #endif /* RUST_LANG_H */"
    }
  ]
}