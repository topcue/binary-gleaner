{
  "sha": "294c36eb6ac9eaf761ec300fd400623ed5175203",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Mjk0YzM2ZWI2YWM5ZWFmNzYxZWMzMDBmZDQwMDYyM2VkNTE3NTIwMw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-05-13T19:28:20Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-13T19:29:00Z"
    },
    "message": "gdb: on exec, delegate pushing / unpushing target and adding thread to target_ops::follow_exec\n\nOn \"exec\", some targets need to unpush themselves from the inferior,\nand do some bookkeeping, like forgetting the data associated to the\nexec'ing inferior.\n\nOne such example is the thread-db target.  It does so in\na special case in thread_db_target::wait, just before returning the\nTARGET_WAITKIND_EXECD event to its caller.\n\nWe have another such case in the context of rocm-gdb [1], where the\n\"rocm\" target is pushed on top of the linux-nat target.  When an exec\nhappens, we want to unpush the rocm target from the exec'ing inferior to\nclose some file descriptors that refer to the pre-exec address space and\nforget about that inferior.  We then want to push the target on the\ninferior in which execution continues, to open the file descriptors for\nthe post-exec address space.\n\nI think that a good way to address this cleanly is to do all this in the\ntarget_ops::follow_exec implementations.  Make the\nprocess_stratum_target::follow_exec implementation have the default\nbehavior of pushing itself to the new inferior's target stack (if\nexecution continues in a new inferior) and add the initial thread.\n\nremote_target::follow_exec is an example of process target that wants to\ndo a bit more than the default behavior.  So it calls\nprocess_stratum_target::follow_exec first and does the extra work\nsecond.\n\nlinux-thread-db (a non-process target) implements follow_exec to do some\nbookeeping (forget about that process' data), before handing down the\nevent down to the process target (which hits\nprocess_stratum_target::follow_exec).\n\ngdb/ChangeLog:\n\n\t* target.h (struct target_ops) <follow_exec>: Add ptid_t\n\tparameter.\n\t(target_follow_exec): Likewise.\n\t* target.c (target_follow_exec): Add ptid_t parameter.\n\t* infrun.c (follow_exec): Adjust call to target_follow_exec,\n\tdon't push target nor create thread.\n\t* linux-thread-db.c (class thread_db_target) <follow_exec>: New.\n\t(thread_db_target::wait): Just return on TARGET_WAITKIND_EXECD.\n\t(thread_db_target::follow_exec): New.\n\t* remote.c (class remote_target) <follow_exec>: Add ptid_t parameter.\n\t(remote_target::follow_exec): Call\n\tprocess_stratum_target::follow_exec.\n\t* target-delegates.c: Re-generate.\n\nChange-Id: I3f96d0ba3ea0dde6540b7e1b4d5cdb01635088c8",
    "tree": {
      "sha": "607d3345281a55a1c31d6d273c0e20d56493940d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/607d3345281a55a1c31d6d273c0e20d56493940d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/294c36eb6ac9eaf761ec300fd400623ed5175203",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/294c36eb6ac9eaf761ec300fd400623ed5175203",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/294c36eb6ac9eaf761ec300fd400623ed5175203",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/294c36eb6ac9eaf761ec300fd400623ed5175203/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2af87c859fe450d4a3a841cf19637a91d53c9486",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2af87c859fe450d4a3a841cf19637a91d53c9486",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2af87c859fe450d4a3a841cf19637a91d53c9486"
    }
  ],
  "stats": {
    "total": 154,
    "additions": 107,
    "deletions": 47
  },
  "files": [
    {
      "sha": "ad6f3081285d44d181870e98f46e97046748f7b1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -1,3 +1,19 @@\n+2021-05-13  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* target.h (struct target_ops) <follow_exec>: Add ptid_t\n+\tparameter.\n+\t(target_follow_exec): Likewise.\n+\t* target.c (target_follow_exec): Add ptid_t parameter.\n+\t* infrun.c (follow_exec): Adjust call to target_follow_exec,\n+\tdon't push target nor create thread.\n+\t* linux-thread-db.c (class thread_db_target) <follow_exec>: New.\n+\t(thread_db_target::wait): Just return on TARGET_WAITKIND_EXECD.\n+\t(thread_db_target::follow_exec): New.\n+\t* remote.c (class remote_target) <follow_exec>: Add ptid_t parameter.\n+\t(remote_target::follow_exec): Call\n+\tprocess_stratum_target::follow_exec.\n+\t* target-delegates.c: Re-generate.\n+\n 2021-05-13  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* infrun.c (follow_exec): Call target_follow_fork when"
    },
    {
      "sha": "7fc56dc51f027d09a3b81c7bf55d255876043745",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -1064,7 +1064,6 @@ show_follow_exec_mode_string (struct ui_file *file, int from_tty,\n static void\n follow_exec (ptid_t ptid, const char *exec_file_target)\n {\n-  struct inferior *inf = current_inferior ();\n   int pid = ptid.pid ();\n   ptid_t process_ptid;\n \n@@ -1167,6 +1166,8 @@ follow_exec (ptid_t ptid, const char *exec_file_target)\n      previous incarnation of this process.  */\n   no_shared_libraries (NULL, 0);\n \n+  struct inferior *inf = current_inferior ();\n+\n   if (follow_exec_mode_string == follow_exec_mode_new)\n     {\n       /* The user wants to keep the old inferior and program spaces\n@@ -1176,18 +1177,16 @@ follow_exec (ptid_t ptid, const char *exec_file_target)\n \t inferior's pid.  Having two inferiors with the same pid would confuse\n \t find_inferior_p(t)id.  Transfer the terminal state and info from the\n \t  old to the new inferior.  */\n-      inf = add_inferior_with_spaces ();\n-      swap_terminal_info (inf, current_inferior ());\n-      exit_inferior_silent (current_inferior ());\n+      inferior *new_inferior = add_inferior_with_spaces ();\n \n-      inf->pid = pid;\n-      target_follow_exec (inf, exec_file_target);\n+      swap_terminal_info (new_inferior, inf);\n+      exit_inferior_silent (inf);\n \n-      inferior *org_inferior = current_inferior ();\n-      switch_to_inferior_no_thread (inf);\n-      inf->push_target (org_inferior->process_target ());\n-      thread_info *thr = add_thread (inf->process_target (), ptid);\n-      switch_to_thread (thr);\n+      new_inferior->pid = pid;\n+      target_follow_exec (new_inferior, ptid, exec_file_target);\n+\n+      /* We continue with the new inferior.  */\n+      inf = new_inferior;\n     }\n   else\n     {\n@@ -1198,9 +1197,10 @@ follow_exec (ptid_t ptid, const char *exec_file_target)\n \t around (its description is later cleared/refetched on\n \t restart).  */\n       target_clear_description ();\n-      target_follow_exec (inf, exec_file_target);\n+      target_follow_exec (inf, ptid, exec_file_target);\n     }\n \n+  gdb_assert (current_inferior () == inf);\n   gdb_assert (current_program_space == inf->pspace);\n \n   /* Attempt to open the exec file.  SYMFILE_DEFER_BP_RESET is used"
    },
    {
      "sha": "2c75cd607949208ff1e4a191709888c590016ed2",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 15,
      "deletions": 10,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -95,6 +95,7 @@ class thread_db_target final : public target_ops\n   ptid_t wait (ptid_t, struct target_waitstatus *, target_wait_flags) override;\n   void resume (ptid_t, int, enum gdb_signal) override;\n   void mourn_inferior () override;\n+  void follow_exec (inferior *, ptid_t, const char *) override;\n   void update_thread_list () override;\n   std::string pid_to_str (ptid_t) override;\n   CORE_ADDR get_thread_local_address (ptid_t ptid,\n@@ -1384,6 +1385,7 @@ thread_db_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n     case TARGET_WAITKIND_EXITED:\n     case TARGET_WAITKIND_THREAD_EXITED:\n     case TARGET_WAITKIND_SIGNALLED:\n+    case TARGET_WAITKIND_EXECD:\n       return ptid;\n     }\n \n@@ -1393,16 +1395,6 @@ thread_db_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n   if (info == NULL)\n     return ptid;\n \n-  if (ourstatus->kind == TARGET_WAITKIND_EXECD)\n-    {\n-      /* New image, it may or may not end up using thread_db.  Assume\n-\t not unless we find otherwise.  */\n-      delete_thread_db_info (beneath, ptid.pid ());\n-      current_inferior ()->unpush_target (this);\n-\n-      return ptid;\n-    }\n-\n   /* Fill in the thread's user-level thread id and status.  */\n   thread_from_lwp (find_thread_ptid (beneath, ptid), ptid);\n \n@@ -1423,6 +1415,19 @@ thread_db_target::mourn_inferior ()\n   current_inferior ()->unpush_target (this);\n }\n \n+void\n+thread_db_target::follow_exec (inferior *follow_inf, ptid_t ptid,\n+\t\t\t       const char *execd_pathname)\n+{\n+  process_stratum_target *beneath\n+    = as_process_stratum_target (this->beneath ());\n+\n+  delete_thread_db_info (beneath, ptid.pid ());\n+\n+  current_inferior ()->unpush_target (this);\n+  beneath->follow_exec (follow_inf, ptid, execd_pathname);\n+}\n+\n struct callback_data\n {\n   struct thread_db_info *info;"
    },
    {
      "sha": "c851090a7f2ea23913cb9e9d15360015f73a2a4c",
      "filename": "gdb/process-stratum-target.c",
      "status": "modified",
      "additions": 20,
      "deletions": 0,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/process-stratum-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/process-stratum-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/process-stratum-target.c?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -84,6 +84,26 @@ process_stratum_target::has_execution (inferior *inf)\n   return inf->pid != 0;\n }\n \n+void\n+process_stratum_target::follow_exec (inferior *follow_inf, ptid_t ptid,\n+\t\t\t\t     const char *execd_pathname)\n+{\n+  inferior *orig_inf = current_inferior ();\n+\n+  if (orig_inf != follow_inf)\n+    {\n+      /* Execution continues in a new inferior, push the original inferior's\n+         process target on the new inferior's target stack.  The process target\n+\t may decide to unpush itself from the original inferior's target stack\n+\t after that, at its discretion.  */\n+      follow_inf->push_target (orig_inf->process_target ());\n+      thread_info *t = add_thread (follow_inf->process_target (), ptid);\n+\n+      /* Leave the new inferior / thread as the current inferior / thread.  */\n+      switch_to_thread (t);\n+    }\n+}\n+\n /* See process-stratum-target.h.  */\n \n std::set<process_stratum_target *>"
    },
    {
      "sha": "31a97753db9c01037db197f276780c7ef1d27765",
      "filename": "gdb/process-stratum-target.h",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/process-stratum-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/process-stratum-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/process-stratum-target.h?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -63,6 +63,14 @@ class process_stratum_target : public target_ops\n   bool has_registers () override;\n   bool has_execution (inferior *inf) override;\n \n+  /* Default implementation of follow_exec.\n+\n+     If the current inferior and FOLLOW_INF are different (execution continues\n+     in a new inferior), push this process target to FOLLOW_INF's target stack\n+     and add an initial thread to FOLLOW_INF.  */\n+  void follow_exec (inferior *follow_inf, ptid_t ptid,\n+\t\t    const char *execd_pathname) override;\n+\n   /* True if any thread is, or may be executing.  We need to track\n      this separately because until we fully sync the thread list, we\n      won't know whether the target is fully stopped, even if we see"
    },
    {
      "sha": "4dcc5515cea7b683a414085a4a5b128446a80253",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -683,7 +683,7 @@ class remote_target : public process_stratum_target\n   const struct btrace_config *btrace_conf (const struct btrace_target_info *) override;\n   bool augmented_libraries_svr4_read () override;\n   void follow_fork (bool, bool) override;\n-  void follow_exec (struct inferior *, const char *) override;\n+  void follow_exec (inferior *, ptid_t, const char *) override;\n   int insert_fork_catchpoint (int) override;\n   int remove_fork_catchpoint (int) override;\n   int insert_vfork_catchpoint (int) override;\n@@ -5925,20 +5925,20 @@ remote_target::follow_fork (bool follow_child, bool detach_fork)\n }\n \n /* Target follow-exec function for remote targets.  Save EXECD_PATHNAME\n-   in the program space of the new inferior.  On entry and at return the\n-   current inferior is the exec'ing inferior.  INF is the new exec'd\n-   inferior, which may be the same as the exec'ing inferior unless\n-   follow-exec-mode is \"new\".  */\n+   in the program space of the new inferior.  */\n \n void\n-remote_target::follow_exec (struct inferior *inf, const char *execd_pathname)\n+remote_target::follow_exec (inferior *follow_inf, ptid_t ptid,\n+\t\t\t    const char *execd_pathname)\n {\n+  process_stratum_target::follow_exec (follow_inf, ptid, execd_pathname);\n+\n   /* We know that this is a target file name, so if it has the \"target:\"\n      prefix we strip it off before saving it in the program space.  */\n   if (is_target_filename (execd_pathname))\n     execd_pathname += strlen (TARGET_SYSROOT_PREFIX);\n \n-  set_pspace_remote_exec_file (inf->pspace, execd_pathname);\n+  set_pspace_remote_exec_file (follow_inf->pspace, execd_pathname);\n }\n \n /* Same as remote_detach, but don't send the \"D\" packet; just disconnect.  */"
    },
    {
      "sha": "3e759a2f80ea9948fc11f60ce0d159bcf9520d27",
      "filename": "gdb/target-delegates.c",
      "status": "modified",
      "additions": 11,
      "deletions": 9,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/target-delegates.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/target-delegates.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-delegates.c?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -59,7 +59,7 @@ struct dummy_target : public target_ops\n   void follow_fork (bool arg0, bool arg1) override;\n   int insert_exec_catchpoint (int arg0) override;\n   int remove_exec_catchpoint (int arg0) override;\n-  void follow_exec (struct inferior *arg0, const char *arg1) override;\n+  void follow_exec (inferior *arg0, ptid_t arg1, const char *arg2) override;\n   int set_syscall_catchpoint (int arg0, bool arg1, int arg2, gdb::array_view<const int> arg3) override;\n   void mourn_inferior () override;\n   void pass_signals (gdb::array_view<const unsigned char> arg0) override;\n@@ -234,7 +234,7 @@ struct debug_target : public target_ops\n   void follow_fork (bool arg0, bool arg1) override;\n   int insert_exec_catchpoint (int arg0) override;\n   int remove_exec_catchpoint (int arg0) override;\n-  void follow_exec (struct inferior *arg0, const char *arg1) override;\n+  void follow_exec (inferior *arg0, ptid_t arg1, const char *arg2) override;\n   int set_syscall_catchpoint (int arg0, bool arg1, int arg2, gdb::array_view<const int> arg3) override;\n   void mourn_inferior () override;\n   void pass_signals (gdb::array_view<const unsigned char> arg0) override;\n@@ -1595,25 +1595,27 @@ debug_target::remove_exec_catchpoint (int arg0)\n }\n \n void\n-target_ops::follow_exec (struct inferior *arg0, const char *arg1)\n+target_ops::follow_exec (inferior *arg0, ptid_t arg1, const char *arg2)\n {\n-  this->beneath ()->follow_exec (arg0, arg1);\n+  this->beneath ()->follow_exec (arg0, arg1, arg2);\n }\n \n void\n-dummy_target::follow_exec (struct inferior *arg0, const char *arg1)\n+dummy_target::follow_exec (inferior *arg0, ptid_t arg1, const char *arg2)\n {\n }\n \n void\n-debug_target::follow_exec (struct inferior *arg0, const char *arg1)\n+debug_target::follow_exec (inferior *arg0, ptid_t arg1, const char *arg2)\n {\n   fprintf_unfiltered (gdb_stdlog, \"-> %s->follow_exec (...)\\n\", this->beneath ()->shortname ());\n-  this->beneath ()->follow_exec (arg0, arg1);\n+  this->beneath ()->follow_exec (arg0, arg1, arg2);\n   fprintf_unfiltered (gdb_stdlog, \"<- %s->follow_exec (\", this->beneath ()->shortname ());\n-  target_debug_print_struct_inferior_p (arg0);\n+  target_debug_print_inferior_p (arg0);\n   fputs_unfiltered (\", \", gdb_stdlog);\n-  target_debug_print_const_char_p (arg1);\n+  target_debug_print_ptid_t (arg1);\n+  fputs_unfiltered (\", \", gdb_stdlog);\n+  target_debug_print_const_char_p (arg2);\n   fputs_unfiltered (\")\\n\", gdb_stdlog);\n }\n "
    },
    {
      "sha": "6babfc562563d6d09dddcbb955ecaa11a9171fb6",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 5,
      "deletions": 3,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -2718,12 +2718,14 @@ target_follow_fork (bool follow_child, bool detach_fork)\n   return target->follow_fork (follow_child, detach_fork);\n }\n \n-/* Target wrapper for follow exec hook.  */\n+/* See target.h.  */\n \n void\n-target_follow_exec (struct inferior *inf, const char *execd_pathname)\n+target_follow_exec (inferior *follow_inf, ptid_t ptid,\n+\t\t    const char *execd_pathname)\n {\n-  current_inferior ()->top_target ()->follow_exec (inf, execd_pathname);\n+  current_inferior ()->top_target ()->follow_exec (follow_inf, ptid,\n+\t\t\t\t\t\t   execd_pathname);\n }\n \n static void"
    },
    {
      "sha": "d867a58e2a8b0196d67920934cda3bad6c178484",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 13,
      "deletions": 6,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/294c36eb6ac9eaf761ec300fd400623ed5175203/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=294c36eb6ac9eaf761ec300fd400623ed5175203",
      "patch": "@@ -642,7 +642,7 @@ struct target_ops\n       TARGET_DEFAULT_RETURN (1);\n     virtual int remove_exec_catchpoint (int)\n       TARGET_DEFAULT_RETURN (1);\n-    virtual void follow_exec (struct inferior *, const char *)\n+    virtual void follow_exec (inferior *, ptid_t, const char *)\n       TARGET_DEFAULT_IGNORE ();\n     virtual int set_syscall_catchpoint (int, bool, int,\n \t\t\t\t\tgdb::array_view<const int>)\n@@ -1715,12 +1715,19 @@ extern int target_remove_vfork_catchpoint (int pid);\n void target_follow_fork (bool follow_child, bool detach_fork);\n \n /* Handle the target-specific bookkeeping required when the inferior makes an\n-   exec call.  The current inferior is the inferior that has executed the exec\n-   call.  INF is the inferior in which execution continues post-exec.  It is the\n-   same inferior as the current one if \"follow-exec-mode\" is \"same\" but is a new\n-   one if \"follow-exec-mode\" is \"new\".  */\n+   exec call.\n \n-void target_follow_exec (struct inferior *inf, const char *execd_pathname);\n+   The current inferior at the time of the call is the inferior that did the\n+   exec.  FOLLOW_INF is the inferior in which execution continues post-exec.\n+   If \"follow-exec-mode\" is \"same\", FOLLOW_INF is the same as the current\n+   inferior, meaning that execution continues with the same inferior.  If\n+   \"follow-exec-mode\" is \"new\", FOLLOW_INF is a different inferior, meaning\n+   that execution continues in a new inferior.\n+\n+   On exit, the target must leave FOLLOW_INF as the current inferior.  */\n+\n+void target_follow_exec (inferior *follow_inf, ptid_t ptid,\n+\t\t\t const char *execd_pathname);\n \n /* On some targets, we can catch an inferior exec event when it\n    occurs.  These functions insert/remove an already-created"
    }
  ]
}