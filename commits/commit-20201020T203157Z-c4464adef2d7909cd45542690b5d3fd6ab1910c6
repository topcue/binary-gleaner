{
  "sha": "c4464adef2d7909cd45542690b5d3fd6ab1910c6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzQ0NjRhZGVmMmQ3OTA5Y2Q0NTU0MjY5MGI1ZDNmZDZhYjE5MTBjNg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-10-20T20:31:57Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-10-20T20:31:57Z"
    },
    "message": "gdb: change some int to bool in infrun.c\n\nChange these int-used-as-a-bool to bool.  I searched for \"static int\" in\nthat file and changed what I found.\n\ngdb/ChangeLog:\n\n\t* infrun.c (currently_stepping): Change int to bool\n\t(maybe_software_singlestep): Likewise.\n\t(show_stop_on_solib_events): Likewise.\n\t(stepping_past_nonsteppable_watchpoint): Likewise.\n\t(displaced_step_in_progress_any_inferior): Likewise.\n\t(displaced_step_in_progress_thread): Likewise.\n\t(keep_going_stepped_thread): Likewise.\n\t(thread_still_needs_step_over): Likewise.\n\t(start_step_over): Likewise.\n\t(do_target_resume): Likewise.\n\t(resume_1): Likewise.\n\t(clear_proceed_status): Likewise.\n\t(thread_still_needs_step_over_bp): Likewise.\n\t(proceed): Likewise.\n\t(switch_back_to_stepped_thread): Likewise.\n\t(adjust_pc_after_break): Likewise.\n\t(stepped_in_from): Likewise.\n\t(handle_stop_requested): Likewise.\n\t(handle_syscall_event): Likewise.\n\t(handle_no_resumed): Likewise.\n\t(handle_inferior_event): Likewise.\n\t(finish_step_over): Likewise.\n\t(handle_signal_stop): Likewise.\n\t(process_event_stop_test): Likewise.\n\nChange-Id: I897527c4a3da5e647f9d97f7d4477649985b8b77",
    "tree": {
      "sha": "1f6b44b8537143cbbe94363da8a3ef951429c18c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1f6b44b8537143cbbe94363da8a3ef951429c18c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c4464adef2d7909cd45542690b5d3fd6ab1910c6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c4464adef2d7909cd45542690b5d3fd6ab1910c6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c4464adef2d7909cd45542690b5d3fd6ab1910c6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c4464adef2d7909cd45542690b5d3fd6ab1910c6/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2eb20436fae06676fcffd96fef63ec6e14a2cacf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2eb20436fae06676fcffd96fef63ec6e14a2cacf",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2eb20436fae06676fcffd96fef63ec6e14a2cacf"
    }
  ],
  "stats": {
    "total": 168,
    "additions": 98,
    "deletions": 70
  },
  "files": [
    {
      "sha": "f7dec61d47d62c359beac3730d18dfca612d656a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c4464adef2d7909cd45542690b5d3fd6ab1910c6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c4464adef2d7909cd45542690b5d3fd6ab1910c6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=c4464adef2d7909cd45542690b5d3fd6ab1910c6",
      "patch": "@@ -1,3 +1,30 @@\n+2020-10-20  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* infrun.c (currently_stepping): Change int to bool\n+\t(maybe_software_singlestep): Likewise.\n+\t(show_stop_on_solib_events): Likewise.\n+\t(stepping_past_nonsteppable_watchpoint): Likewise.\n+\t(displaced_step_in_progress_any_inferior): Likewise.\n+\t(displaced_step_in_progress_thread): Likewise.\n+\t(keep_going_stepped_thread): Likewise.\n+\t(thread_still_needs_step_over): Likewise.\n+\t(start_step_over): Likewise.\n+\t(do_target_resume): Likewise.\n+\t(resume_1): Likewise.\n+\t(clear_proceed_status): Likewise.\n+\t(thread_still_needs_step_over_bp): Likewise.\n+\t(proceed): Likewise.\n+\t(switch_back_to_stepped_thread): Likewise.\n+\t(adjust_pc_after_break): Likewise.\n+\t(stepped_in_from): Likewise.\n+\t(handle_stop_requested): Likewise.\n+\t(handle_syscall_event): Likewise.\n+\t(handle_no_resumed): Likewise.\n+\t(handle_inferior_event): Likewise.\n+\t(finish_step_over): Likewise.\n+\t(handle_signal_stop): Likewise.\n+\t(process_event_stop_test): Likewise.\n+\n 2020-10-20  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* infrun.c (get_displaced_stepping_state): Fix comment."
    },
    {
      "sha": "942c3df20e0d6cc0400908cdf9b8b12c389dee7a",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 71,
      "deletions": 70,
      "changes": 141,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c4464adef2d7909cd45542690b5d3fd6ab1910c6/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c4464adef2d7909cd45542690b5d3fd6ab1910c6/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=c4464adef2d7909cd45542690b5d3fd6ab1910c6",
      "patch": "@@ -80,15 +80,15 @@ static void sig_print_header (void);\n \n static void follow_inferior_reset_breakpoints (void);\n \n-static int currently_stepping (struct thread_info *tp);\n+static bool currently_stepping (struct thread_info *tp);\n \n static void insert_hp_step_resume_breakpoint_at_frame (struct frame_info *);\n \n static void insert_step_resume_breakpoint_at_caller (struct frame_info *);\n \n static void insert_longjmp_resume_breakpoint (struct gdbarch *, CORE_ADDR);\n \n-static int maybe_software_singlestep (struct gdbarch *gdbarch, CORE_ADDR pc);\n+static bool maybe_software_singlestep (struct gdbarch *gdbarch, CORE_ADDR pc);\n \n static void resume (gdb_signal sig);\n \n@@ -380,9 +380,9 @@ show_stop_on_solib_events (struct ui_file *file, int from_tty,\n \t\t    value);\n }\n \n-/* Nonzero after stop if current stack frame should be printed.  */\n+/* True after stop if current stack frame should be printed.  */\n \n-static int stop_print_frame;\n+static bool stop_print_frame;\n \n /* This is a cached copy of the target/ptid/waitstatus of the last\n    event returned by target_wait()/deprecated_target_wait_hook().\n@@ -1379,7 +1379,7 @@ stepping_past_nonsteppable_watchpoint (void)\n \n /* Returns true if step-over info is valid.  */\n \n-static int\n+static bool\n step_over_info_valid_p (void)\n {\n   return (step_over_info.aspace != NULL\n@@ -1503,7 +1503,7 @@ displaced_step_in_progress_any_inferior ()\n /* Return true if thread represented by PTID is doing a displaced\n    step.  */\n \n-static int\n+static bool\n displaced_step_in_progress_thread (thread_info *thread)\n {\n   gdb_assert (thread != NULL);\n@@ -1513,7 +1513,7 @@ displaced_step_in_progress_thread (thread_info *thread)\n \n /* Return true if process PID has a thread doing a displaced step.  */\n \n-static int\n+static bool\n displaced_step_in_progress (inferior *inf)\n {\n   return get_displaced_stepping_state (inf)->step_thread != nullptr;\n@@ -1950,21 +1950,21 @@ reset_ecs (struct execution_control_state *ecs, struct thread_info *tp)\n \n static void keep_going_pass_signal (struct execution_control_state *ecs);\n static void prepare_to_wait (struct execution_control_state *ecs);\n-static int keep_going_stepped_thread (struct thread_info *tp);\n+static bool keep_going_stepped_thread (struct thread_info *tp);\n static step_over_what thread_still_needs_step_over (struct thread_info *tp);\n \n /* Are there any pending step-over requests?  If so, run all we can\n    now and return true.  Otherwise, return false.  */\n \n-static int\n+static bool\n start_step_over (void)\n {\n   struct thread_info *tp, *next;\n \n   /* Don't start a new step-over if we already have an in-line\n      step-over operation ongoing.  */\n   if (step_over_info_valid_p ())\n-    return 0;\n+    return false;\n \n   for (tp = step_over_queue_head; tp != NULL; tp = next)\n     {\n@@ -1991,7 +1991,7 @@ start_step_over (void)\n \t in-line.  If we need to start a new in-line step-over, let\n \t any pending displaced steps finish first.  */\n       if (must_be_in_line && displaced_step_in_progress_any_inferior ())\n-\treturn 0;\n+\treturn false;\n \n       thread_step_over_chain_remove (tp);\n \n@@ -2036,7 +2036,7 @@ start_step_over (void)\n       if (step_over_info_valid_p ())\n \t{\n \t  gdb_assert (tp->control.trap_expected);\n-\t  return 1;\n+\t  return true;\n \t}\n \n       if (!target_is_non_stop_p ())\n@@ -2049,7 +2049,7 @@ start_step_over (void)\n \t  /* With remote targets (at least), in all-stop, we can't\n \t     issue any further remote commands until the program stops\n \t     again.  */\n-\t  return 1;\n+\t  return true;\n \t}\n \n       /* Either the thread no longer needed a step-over, or a new\n@@ -2058,7 +2058,7 @@ start_step_over (void)\n \t displaced step on a thread of other process. */\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Update global variables holding ptids to hold NEW_PTID if they were\n@@ -2112,15 +2112,15 @@ set_schedlock_func (const char *args, int from_tty, struct cmd_list_element *c)\n bool sched_multi = false;\n \n /* Try to setup for software single stepping over the specified location.\n-   Return 1 if target_resume() should use hardware single step.\n+   Return true if target_resume() should use hardware single step.\n \n    GDBARCH the current gdbarch.\n    PC the location to step over.  */\n \n-static int\n+static bool\n maybe_software_singlestep (struct gdbarch *gdbarch, CORE_ADDR pc)\n {\n-  int hw_step = 1;\n+  bool hw_step = true;\n \n   if (execution_direction == EXEC_FORWARD\n       && gdbarch_software_single_step_p (gdbarch))\n@@ -2204,7 +2204,7 @@ internal_resume_ptid (int user_step)\n    bookkeeping.  */\n \n static void\n-do_target_resume (ptid_t resume_ptid, int step, enum gdb_signal sig)\n+do_target_resume (ptid_t resume_ptid, bool step, enum gdb_signal sig)\n {\n   struct thread_info *tp = inferior_thread ();\n \n@@ -2270,7 +2270,7 @@ resume_1 (enum gdb_signal sig)\n      This can decay from a step to a continue, if e.g., we need to\n      implement single-stepping with breakpoints (software\n      single-step).  */\n-  int step;\n+  bool step;\n \n   gdb_assert (!tp->stop_requested);\n   gdb_assert (!thread_is_in_step_over_chain (tp));\n@@ -2327,7 +2327,7 @@ resume_1 (enum gdb_signal sig)\n \t the parent, and tell it to `keep_going', which automatically\n \t re-sets it stepping.  */\n       infrun_debug_printf (\"resume : clear step\");\n-      step = 0;\n+      step = false;\n     }\n \n   CORE_ADDR pc = regcache_read_pc (regcache);\n@@ -2406,7 +2406,7 @@ resume_1 (enum gdb_signal sig)\n \t      insert_breakpoints ();\n \n \t      resume_ptid = internal_resume_ptid (user_step);\n-\t      do_target_resume (resume_ptid, 0, GDB_SIGNAL_0);\n+\t      do_target_resume (resume_ptid, false, GDB_SIGNAL_0);\n \t      tp->resumed = true;\n \t      return;\n \t    }\n@@ -2585,7 +2585,7 @@ resume_1 (enum gdb_signal sig)\n \t executing it normally.  But if this one cannot, just\n \t continue and we will hit it anyway.  */\n       if (gdbarch_cannot_step_breakpoint (gdbarch))\n-\tstep = 0;\n+\tstep = false;\n     }\n \n   if (debug_displaced\n@@ -2780,7 +2780,7 @@ clear_proceed_status (int step)\n    stepping-over in order to make progress.  If the breakpoint is gone\n    meanwhile, we can skip the whole step-over dance.  */\n \n-static int\n+static bool\n thread_still_needs_step_over_bp (struct thread_info *tp)\n {\n   if (tp->stepping_over_breakpoint)\n@@ -2790,12 +2790,12 @@ thread_still_needs_step_over_bp (struct thread_info *tp)\n       if (breakpoint_here_p (regcache->aspace (),\n \t\t\t     regcache_read_pc (regcache))\n \t  == ordinary_breakpoint_here)\n-\treturn 1;\n+\treturn true;\n \n       tp->stepping_over_breakpoint = 0;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Check whether thread TP still needs to start a step-over in order\n@@ -2820,7 +2820,7 @@ thread_still_needs_step_over (struct thread_info *tp)\n /* Returns true if scheduler locking applies.  STEP indicates whether\n    we're about to do a step/next-like command to a thread.  */\n \n-static int\n+static bool\n schedlock_applies (struct thread_info *tp)\n {\n   return (scheduler_mode == schedlock_on\n@@ -2927,7 +2927,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n   CORE_ADDR pc;\n   struct execution_control_state ecss;\n   struct execution_control_state *ecs = &ecss;\n-  int started;\n+  bool started;\n \n   /* If we're stopped at a fork/vfork, follow the branch set by the\n      \"set follow-fork-mode\" command; otherwise, we'll just proceed\n@@ -3222,7 +3222,7 @@ static void end_stepping_range (struct execution_control_state *ecs);\n static void stop_waiting (struct execution_control_state *ecs);\n static void keep_going (struct execution_control_state *ecs);\n static void process_event_stop_test (struct execution_control_state *ecs);\n-static int switch_back_to_stepped_thread (struct execution_control_state *ecs);\n+static bool switch_back_to_stepped_thread (struct execution_control_state *ecs);\n \n /* This function is attached as a \"thread_stop_requested\" observer.\n    Cleanup local state that assumed the PTID was to be resumed, and\n@@ -4238,20 +4238,21 @@ adjust_pc_after_break (struct thread_info *thread,\n     }\n }\n \n-static int\n+static bool\n stepped_in_from (struct frame_info *frame, struct frame_id step_frame_id)\n {\n   for (frame = get_prev_frame (frame);\n        frame != NULL;\n        frame = get_prev_frame (frame))\n     {\n       if (frame_id_eq (get_frame_id (frame), step_frame_id))\n-\treturn 1;\n+\treturn true;\n+\n       if (get_frame_type (frame) != INLINE_FRAME)\n \tbreak;\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Look for an inline frame that is marked for skip.\n@@ -4311,11 +4312,11 @@ handle_stop_requested (struct execution_control_state *ecs)\n }\n \n /* Auxiliary function that handles syscall entry/return events.\n-   It returns 1 if the inferior should keep going (and GDB\n-   should ignore the event), or 0 if the event deserves to be\n+   It returns true if the inferior should keep going (and GDB\n+   should ignore the event), or false if the event deserves to be\n    processed.  */\n \n-static int\n+static bool\n handle_syscall_event (struct execution_control_state *ecs)\n {\n   struct regcache *regcache;\n@@ -4338,21 +4339,22 @@ handle_syscall_event (struct execution_control_state *ecs)\n \t\t\t      ecs->event_thread, &ecs->ws);\n \n       if (handle_stop_requested (ecs))\n-\treturn 0;\n+\treturn false;\n \n       if (bpstat_causes_stop (ecs->event_thread->control.stop_bpstat))\n \t{\n \t  /* Catchpoint hit.  */\n-\t  return 0;\n+\t  return false;\n \t}\n     }\n \n   if (handle_stop_requested (ecs))\n-    return 0;\n+    return false;\n \n   /* If no catchpoint triggered for this, then keep going.  */\n   keep_going (ecs);\n-  return 1;\n+\n+  return true;\n }\n \n /* Lazily fill in the execution_control_state's stop_func_* fields.  */\n@@ -4888,18 +4890,18 @@ stop_all_threads (void)\n \n /* Handle a TARGET_WAITKIND_NO_RESUMED event.  */\n \n-static int\n+static bool\n handle_no_resumed (struct execution_control_state *ecs)\n {\n   if (target_can_async_p ())\n     {\n-      int any_sync = 0;\n+      bool any_sync = false;\n \n       for (ui *ui : all_uis ())\n \t{\n \t  if (ui->prompt_state == PROMPT_BLOCKED)\n \t    {\n-\t      any_sync = 1;\n+\t      any_sync = true;\n \t      break;\n \t    }\n \t}\n@@ -4911,7 +4913,7 @@ handle_no_resumed (struct execution_control_state *ecs)\n \n \t  infrun_debug_printf (\"TARGET_WAITKIND_NO_RESUMED (ignoring: bg)\");\n \t  prepare_to_wait (ecs);\n-\t  return 1;\n+\t  return true;\n \t}\n     }\n \n@@ -5014,11 +5016,11 @@ handle_no_resumed (struct execution_control_state *ecs)\n     {\n       switch_to_inferior_no_thread (curr_inf);\n       prepare_to_wait (ecs);\n-      return 1;\n+      return true;\n     }\n \n   /* Go ahead and report the event.  */\n-  return 0;\n+  return false;\n }\n \n /* Given an execution control state that has been freshly filled in by\n@@ -5081,7 +5083,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n     {\n       /* No unwaited-for children left.  IOW, all resumed children\n \t have exited.  */\n-      stop_print_frame = 0;\n+      stop_print_frame = false;\n       stop_waiting (ecs);\n       return;\n     }\n@@ -5178,7 +5180,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t    {\n \t      /* Make sure we print \"Stopped due to solib-event\" in\n \t\t normal_stop.  */\n-\t      stop_print_frame = 1;\n+\t      stop_print_frame = true;\n \n \t      stop_waiting (ecs);\n \t      return;\n@@ -5297,7 +5299,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \n       gdb_flush (gdb_stdout);\n       target_mourn_inferior (inferior_ptid);\n-      stop_print_frame = 0;\n+      stop_print_frame = false;\n       stop_waiting (ecs);\n       return;\n \n@@ -5676,12 +5678,10 @@ resumed_thread_with_pending_status (struct thread_info *tp,\n static int\n finish_step_over (struct execution_control_state *ecs)\n {\n-  int had_step_over_info;\n-\n   displaced_step_fixup (ecs->event_thread,\n \t\t\tecs->event_thread->suspend.stop_signal);\n \n-  had_step_over_info = step_over_info_valid_p ();\n+  bool had_step_over_info = step_over_info_valid_p ();\n \n   if (had_step_over_info)\n     {\n@@ -5843,7 +5843,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n     {\n       context_switch (ecs);\n       infrun_debug_printf (\"quietly stopped\");\n-      stop_print_frame = 1;\n+      stop_print_frame = true;\n       stop_waiting (ecs);\n       return;\n     }\n@@ -5873,7 +5873,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t  || ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n \t  || ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_0))\n     {\n-      stop_print_frame = 1;\n+      stop_print_frame = true;\n       stop_waiting (ecs);\n       ecs->event_thread->suspend.stop_signal = GDB_SIGNAL_0;\n       return;\n@@ -5977,7 +5977,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n   ecs->event_thread->stepping_over_watchpoint = 0;\n   bpstat_clear (&ecs->event_thread->control.stop_bpstat);\n   ecs->event_thread->control.stop_step = 0;\n-  stop_print_frame = 1;\n+  stop_print_frame = true;\n   stopped_by_random_signal = 0;\n   bpstat stop_chain = NULL;\n \n@@ -6071,7 +6071,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \n   /* Following in case break condition called a\n      function.  */\n-  stop_print_frame = 1;\n+  stop_print_frame = true;\n \n   /* This is where we handle \"moribund\" watchpoints.  Unlike\n      software breakpoints traps, hardware watchpoint traps are\n@@ -6486,7 +6486,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \n     case BPSTAT_WHAT_STOP_NOISY:\n       infrun_debug_printf (\"BPSTAT_WHAT_STOP_NOISY\");\n-      stop_print_frame = 1;\n+      stop_print_frame = true;\n \n       /* Assume the thread stopped for a breakpoint.  We'll still check\n \t whether a/the breakpoint is there when the thread is next\n@@ -6498,7 +6498,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \n     case BPSTAT_WHAT_STOP_SILENT:\n       infrun_debug_printf (\"BPSTAT_WHAT_STOP_SILENT\");\n-      stop_print_frame = 0;\n+      stop_print_frame = false;\n \n       /* Assume the thread stopped for a breakpoint.  We'll still check\n \t whether a/the breakpoint is there when the thread is next\n@@ -7129,7 +7129,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n    thread.  Returns true we set the inferior running, false if we left\n    it stopped (and the event needs further processing).  */\n \n-static int\n+static bool\n switch_back_to_stepped_thread (struct execution_control_state *ecs)\n {\n   if (!target_is_non_stop_p ())\n@@ -7145,7 +7145,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t already.  Let the caller check whether the step is finished,\n \t etc., before deciding to move it past a breakpoint.  */\n       if (ecs->event_thread->control.step_range_end != 0)\n-\treturn 0;\n+\treturn false;\n \n       /* Check if the current thread is blocked on an incomplete\n \t step-over, interrupted by a random signal.  */\n@@ -7156,7 +7156,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t    (\"need to finish step-over of [%s]\",\n \t     target_pid_to_str (ecs->event_thread->ptid).c_str ());\n \t  keep_going (ecs);\n-\t  return 1;\n+\t  return true;\n \t}\n \n       /* Check if the current thread is blocked by a single-step\n@@ -7166,7 +7166,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t infrun_debug_printf (\"need to step [%s] over single-step breakpoint\",\n \t\t\t      target_pid_to_str (ecs->ptid).c_str ());\n \t keep_going (ecs);\n-\t return 1;\n+\t return true;\n        }\n \n       /* If this thread needs yet another step-over (e.g., stepping\n@@ -7178,7 +7178,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t    (\"thread [%s] still needs step-over\",\n \t     target_pid_to_str (ecs->event_thread->ptid).c_str ());\n \t  keep_going (ecs);\n-\t  return 1;\n+\t  return true;\n \t}\n \n       /* If scheduler locking applies even if not stepping, there's no\n@@ -7187,7 +7187,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t event thread is stepping, then it must be that scheduler\n \t locking is not in effect.  */\n       if (schedlock_applies (ecs->event_thread))\n-\treturn 0;\n+\treturn false;\n \n       /* Otherwise, we no longer expect a trap in the current thread.\n \t Clear the trap_expected flag before switching back -- this is\n@@ -7203,7 +7203,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n       if (start_step_over ())\n \t{\n \t  prepare_to_wait (ecs);\n-\t  return 1;\n+\t  return true;\n \t}\n \n       /* Look for the stepping/nexting thread.  */\n@@ -7260,21 +7260,21 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t  if (keep_going_stepped_thread (stepping_thread))\n \t    {\n \t      prepare_to_wait (ecs);\n-\t      return 1;\n+\t      return true;\n \t    }\n \t}\n \n       switch_to_thread (ecs->event_thread);\n     }\n \n-  return 0;\n+  return false;\n }\n \n /* Set a previously stepped thread back to stepping.  Returns true on\n    success, false if the resume is not possible (e.g., the thread\n    vanished).  */\n \n-static int\n+static bool\n keep_going_stepped_thread (struct thread_info *tp)\n {\n   struct frame_info *frame;\n@@ -7305,7 +7305,7 @@ keep_going_stepped_thread (struct thread_info *tp)\n \t\t\t   \"vanished\");\n \n       delete_thread (tp);\n-      return 0;\n+      return false;\n     }\n \n   infrun_debug_printf (\"resuming previously stepped thread\");\n@@ -7353,22 +7353,23 @@ keep_going_stepped_thread (struct thread_info *tp)\n \n       tp->resumed = true;\n       resume_ptid = internal_resume_ptid (tp->control.stepping_command);\n-      do_target_resume (resume_ptid, 0, GDB_SIGNAL_0);\n+      do_target_resume (resume_ptid, false, GDB_SIGNAL_0);\n     }\n   else\n     {\n       infrun_debug_printf (\"expected thread still hasn't advanced\");\n \n       keep_going_pass_signal (ecs);\n     }\n-  return 1;\n+\n+  return true;\n }\n \n /* Is thread TP in the middle of (software or hardware)\n    single-stepping?  (Note the result of this function must never be\n    passed directly as target_resume's STEP parameter.)  */\n \n-static int\n+static bool\n currently_stepping (struct thread_info *tp)\n {\n   return ((tp->control.step_range_end"
    }
  ]
}