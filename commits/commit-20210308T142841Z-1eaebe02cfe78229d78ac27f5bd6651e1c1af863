{
  "sha": "1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWVhZWJlMDJjZmU3ODIyOWQ3OGFjMjdmNWJkNjY1MWUxYzFhZjg2Mw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:41Z"
    },
    "message": "Remove union exp_element\n\nThis removes union exp_element functions that either create such\nelements or walk them.  struct expression no longer holds\nexp_elements.  A couple of language_defn methods are also removed, as\nthey are obsolete.\n\nNote that this patch also removes the print_expression code.  The only\nin-tree caller of this was from dump_prefix_expression, which is only\ncalled when expression debugging is enabled.  Implementing this would\ninvolve a fair amount of code, and it seems to me that prefix dumping\nis preferable anyway, as it is unambiguous.  So, I have not\nreimplemented this feature.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* value.h (evaluate_subexp_with_coercion): Don't declare.\n\t* parse.c (exp_descriptor_standard): Remove.\n\t(expr_builder::expr_builder, expr_builder::release): Update.\n\t(expression::expression): Remove size_t parameter.\n\t(expression::~expression): Simplify.\n\t(expression::resize): Remove.\n\t(write_exp_elt, write_exp_elt_opcode, write_exp_elt_sym)\n\t(write_exp_elt_msym, write_exp_elt_block, write_exp_elt_objfile)\n\t(write_exp_elt_longcst, write_exp_elt_floatcst)\n\t(write_exp_elt_type, write_exp_elt_intern, write_exp_string)\n\t(write_exp_string_vector, write_exp_bitstring): Remove.\n\t* p-lang.h (class pascal_language) <opcode_print_table,\n\top_print_tab>: Remove.\n\t* p-lang.c (pascal_language::op_print_tab): Remove.\n\t* opencl-lang.c (class opencl_language) <opcode_print_table>:\n\tRemove.\n\t* objc-lang.c (objc_op_print_tab): Remove.\n\t(class objc_language) <opcode_print_table>: Remove.\n\t* m2-lang.h (class m2_language) <opcode_print_table,\n\top_print_tab>: Remove.\n\t* m2-lang.c (m2_language::op_print_tab): Remove.\n\t* language.h (struct language_defn) <post_parser, expression_ops,\n\topcode_print_table>: Remove.\n\t* language.c (language_defn::expression_ops)\n\t(auto_or_unknown_language::opcode_print_table): Remove.\n\t* go-lang.h (class go_language) <opcode_print_table,\n\top_print_tab>: Remove.\n\t* go-lang.c (go_language::op_print_tab): Remove.\n\t* f-lang.h (class f_language) <opcode_print_table>: Remove\n\t<op_print_tab>: Remove.\n\t* f-lang.c (f_language::op_print_tab): Remove.\n\t* expression.h (union exp_element): Remove.\n\t(struct expression): Remove size_t parameter from constructor.\n\t<resize>: Remove.\n\t<first_opcode>: Update.\n\t<nelts, elts>: Remove.\n\t(EXP_ELEM_TO_BYTES, BYTES_TO_EXP_ELEM): Remove.\n\t(evaluate_subexp_standard, print_expression, op_string)\n\t(dump_raw_expression): Don't declare.\n\t* expprint.c (print_expression, print_subexp)\n\t(print_subexp_funcall, print_subexp_standard, op_string)\n\t(dump_raw_expression, dump_subexp, dump_subexp_body)\n\t(dump_subexp_body_funcall, dump_subexp_body_standard): Remove.\n\t(dump_prefix_expression): Update.\n\t* eval.c (evaluate_subexp): Remove.\n\t(evaluate_expression, evaluate_type): Update.\n\t(evaluate_subexpression_type): Remove.\n\t(fetch_subexp_value): Remove \"pc\" parameter.  Update.\n\t(extract_field_op, evaluate_struct_tuple, evaluate_funcall)\n\t(evaluate_subexp_standard, evaluate_subexp_for_address)\n\t(evaluate_subexp_with_coercion, evaluate_subexp_for_sizeof)\n\t(evaluate_subexp_for_cast): Remove.\n\t(parse_and_eval_type): Update.\n\t* dtrace-probe.c (dtrace_probe::compile_to_ax): Update.\n\t* d-lang.c (d_op_print_tab): Remove.\n\t(class d_language) <opcode_print_table>: Remove.\n\t* c-lang.h (c_op_print_tab): Don't declare.\n\t* c-lang.c (c_op_print_tab): Remove.\n\t(class c_language, class cplus_language, class asm_language, class\n\tminimal_language) <opcode_print_table>: Remove.\n\t* breakpoint.c (update_watchpoint, watchpoint_check)\n\t(watchpoint_exp_is_const, watch_command_1): Update.\n\t* ax-gdb.h (union exp_element): Don't declare.\n\t* ax-gdb.c (const_var_ref, const_expr, maybe_const_expr)\n\t(gen_repeat, gen_sizeof, gen_expr_for_cast, gen_expr)\n\t(gen_expr_binop_rest): Remove.\n\t(gen_trace_for_expr, gen_eval_for_expr, gen_printf): Update.\n\t* ada-lang.c (ada_op_print_tab): Remove.\n\t(class ada_language) <post_parser, opcode_print_table>: Remove.",
    "tree": {
      "sha": "870c2965ac8dada5ed4527853f829c3ddbbaf5a2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/870c2965ac8dada5ed4527853f829c3ddbbaf5a2"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "f2a98603a807101722f12b8d7a1aca9651deb133",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f2a98603a807101722f12b8d7a1aca9651deb133",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/f2a98603a807101722f12b8d7a1aca9651deb133"
    }
  ],
  "stats": {
    "total": 5463,
    "additions": 147,
    "deletions": 5316
  },
  "files": [
    {
      "sha": "c9328defa922f902a8edfbe941ca0362af68f396",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 72,
      "deletions": 0,
      "changes": 72,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -1,3 +1,75 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* value.h (evaluate_subexp_with_coercion): Don't declare.\n+\t* parse.c (exp_descriptor_standard): Remove.\n+\t(expr_builder::expr_builder, expr_builder::release): Update.\n+\t(expression::expression): Remove size_t parameter.\n+\t(expression::~expression): Simplify.\n+\t(expression::resize): Remove.\n+\t(write_exp_elt, write_exp_elt_opcode, write_exp_elt_sym)\n+\t(write_exp_elt_msym, write_exp_elt_block, write_exp_elt_objfile)\n+\t(write_exp_elt_longcst, write_exp_elt_floatcst)\n+\t(write_exp_elt_type, write_exp_elt_intern, write_exp_string)\n+\t(write_exp_string_vector, write_exp_bitstring): Remove.\n+\t* p-lang.h (class pascal_language) <opcode_print_table,\n+\top_print_tab>: Remove.\n+\t* p-lang.c (pascal_language::op_print_tab): Remove.\n+\t* opencl-lang.c (class opencl_language) <opcode_print_table>:\n+\tRemove.\n+\t* objc-lang.c (objc_op_print_tab): Remove.\n+\t(class objc_language) <opcode_print_table>: Remove.\n+\t* m2-lang.h (class m2_language) <opcode_print_table,\n+\top_print_tab>: Remove.\n+\t* m2-lang.c (m2_language::op_print_tab): Remove.\n+\t* language.h (struct language_defn) <post_parser, expression_ops,\n+\topcode_print_table>: Remove.\n+\t* language.c (language_defn::expression_ops)\n+\t(auto_or_unknown_language::opcode_print_table): Remove.\n+\t* go-lang.h (class go_language) <opcode_print_table,\n+\top_print_tab>: Remove.\n+\t* go-lang.c (go_language::op_print_tab): Remove.\n+\t* f-lang.h (class f_language) <opcode_print_table>: Remove\n+\t<op_print_tab>: Remove.\n+\t* f-lang.c (f_language::op_print_tab): Remove.\n+\t* expression.h (union exp_element): Remove.\n+\t(struct expression): Remove size_t parameter from constructor.\n+\t<resize>: Remove.\n+\t<first_opcode>: Update.\n+\t<nelts, elts>: Remove.\n+\t(EXP_ELEM_TO_BYTES, BYTES_TO_EXP_ELEM): Remove.\n+\t(evaluate_subexp_standard, print_expression, op_string)\n+\t(dump_raw_expression): Don't declare.\n+\t* expprint.c (print_expression, print_subexp)\n+\t(print_subexp_funcall, print_subexp_standard, op_string)\n+\t(dump_raw_expression, dump_subexp, dump_subexp_body)\n+\t(dump_subexp_body_funcall, dump_subexp_body_standard): Remove.\n+\t(dump_prefix_expression): Update.\n+\t* eval.c (evaluate_subexp): Remove.\n+\t(evaluate_expression, evaluate_type): Update.\n+\t(evaluate_subexpression_type): Remove.\n+\t(fetch_subexp_value): Remove \"pc\" parameter.  Update.\n+\t(extract_field_op, evaluate_struct_tuple, evaluate_funcall)\n+\t(evaluate_subexp_standard, evaluate_subexp_for_address)\n+\t(evaluate_subexp_with_coercion, evaluate_subexp_for_sizeof)\n+\t(evaluate_subexp_for_cast): Remove.\n+\t(parse_and_eval_type): Update.\n+\t* dtrace-probe.c (dtrace_probe::compile_to_ax): Update.\n+\t* d-lang.c (d_op_print_tab): Remove.\n+\t(class d_language) <opcode_print_table>: Remove.\n+\t* c-lang.h (c_op_print_tab): Don't declare.\n+\t* c-lang.c (c_op_print_tab): Remove.\n+\t(class c_language, class cplus_language, class asm_language, class\n+\tminimal_language) <opcode_print_table>: Remove.\n+\t* breakpoint.c (update_watchpoint, watchpoint_check)\n+\t(watchpoint_exp_is_const, watch_command_1): Update.\n+\t* ax-gdb.h (union exp_element): Don't declare.\n+\t* ax-gdb.c (const_var_ref, const_expr, maybe_const_expr)\n+\t(gen_repeat, gen_sizeof, gen_expr_for_cast, gen_expr)\n+\t(gen_expr_binop_rest): Remove.\n+\t(gen_trace_for_expr, gen_eval_for_expr, gen_printf): Update.\n+\t* ada-lang.c (ada_op_print_tab): Remove.\n+\t(class ada_language) <post_parser, opcode_print_table>: Remove.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* go-lang.c (go_language::expression_ops): Don't declare."
    },
    {
      "sha": "db7eba377cf37a9be1835ae17dfd5f1a525ede09",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 58,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -12652,43 +12652,6 @@ info_exceptions_command (const char *regexp, int from_tty)\n     printf_filtered (\"%s: %s\\n\", info.name, paddress (gdbarch, info.addr));\n }\n \n-/* Table mapping opcodes into strings for printing operators\n-   and precedences of the operators.  */\n-\n-static const struct op_print ada_op_print_tab[] = {\n-  {\":=\", BINOP_ASSIGN, PREC_ASSIGN, 1},\n-  {\"or else\", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},\n-  {\"and then\", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},\n-  {\"or\", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},\n-  {\"xor\", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},\n-  {\"and\", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},\n-  {\"=\", BINOP_EQUAL, PREC_EQUAL, 0},\n-  {\"/=\", BINOP_NOTEQUAL, PREC_EQUAL, 0},\n-  {\"<=\", BINOP_LEQ, PREC_ORDER, 0},\n-  {\">=\", BINOP_GEQ, PREC_ORDER, 0},\n-  {\">\", BINOP_GTR, PREC_ORDER, 0},\n-  {\"<\", BINOP_LESS, PREC_ORDER, 0},\n-  {\">>\", BINOP_RSH, PREC_SHIFT, 0},\n-  {\"<<\", BINOP_LSH, PREC_SHIFT, 0},\n-  {\"+\", BINOP_ADD, PREC_ADD, 0},\n-  {\"-\", BINOP_SUB, PREC_ADD, 0},\n-  {\"&\", BINOP_CONCAT, PREC_ADD, 0},\n-  {\"*\", BINOP_MUL, PREC_MUL, 0},\n-  {\"/\", BINOP_DIV, PREC_MUL, 0},\n-  {\"rem\", BINOP_REM, PREC_MUL, 0},\n-  {\"mod\", BINOP_MOD, PREC_MUL, 0},\n-  {\"**\", BINOP_EXP, PREC_REPEAT, 0},\n-  {\"@\", BINOP_REPEAT, PREC_REPEAT, 0},\n-  {\"-\", UNOP_NEG, PREC_PREFIX, 0},\n-  {\"+\", UNOP_PLUS, PREC_PREFIX, 0},\n-  {\"not \", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},\n-  {\"not \", UNOP_COMPLEMENT, PREC_PREFIX, 0},\n-  {\"abs \", UNOP_ABS, PREC_PREFIX, 0},\n-  {\".all\", UNOP_IND, PREC_SUFFIX, 1},\n-  {\"'access\", UNOP_ADDR, PREC_SUFFIX, 1},\n-  {\"'size\", OP_ATR_SIZE, PREC_SUFFIX, 1},\n-  {NULL, OP_NULL, PREC_SUFFIX, 0}\n-};\n \f\n \t\t\t\t/* Language vector */\n \n@@ -13275,22 +13238,6 @@ class ada_language : public language_defn\n     return ada_parse (ps);\n   }\n \n-  /* See language.h.\n-\n-     Same as evaluate_type (*EXP), but resolves ambiguous symbol references\n-     (marked by OP_VAR_VALUE nodes in which the symbol has an undefined\n-     namespace) and converts operators that are user-defined into\n-     appropriate function calls.  If CONTEXT_TYPE is non-null, it provides\n-     a preferred result type [at the moment, only type void has any\n-     effect---causing procedures to be preferred over functions in calls].\n-     A null CONTEXT_TYPE indicates that a non-void return type is\n-     preferred.  May change (expand) *EXP.  */\n-\n-  void post_parser (expression_up *expp, struct parser_state *ps)\n-    const override\n-  {\n-  }\n-\n   /* See language.h.  */\n \n   void emitchar (int ch, struct type *chtype,\n@@ -13353,11 +13300,6 @@ class ada_language : public language_defn\n   const struct lang_varobj_ops *varobj_ops () const override\n   { return &ada_varobj_ops; }\n \n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return ada_op_print_tab; }\n-\n protected:\n   /* See language.h.  */\n "
    },
    {
      "sha": "788be528d1bb9d9e5d7d9463bba5346b9fbc4929",
      "filename": "gdb/ax-gdb.c",
      "status": "modified",
      "additions": 3,
      "deletions": 732,
      "changes": 735,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ax-gdb.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ax-gdb.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -70,14 +70,9 @@\n /* Prototypes for local functions.  */\n \n /* There's a standard order to the arguments of these functions:\n-   union exp_element ** --- pointer into expression\n    struct agent_expr * --- agent expression buffer to generate code into\n    struct axs_value * --- describes value left on top of stack  */\n \n-static struct value *const_var_ref (struct symbol *var);\n-static struct value *const_expr (union exp_element **pc);\n-static struct value *maybe_const_expr (union exp_element **pc);\n-\n static void gen_traced_pop (struct agent_expr *, struct axs_value *);\n \n static void gen_sign_extend (struct agent_expr *, struct type *);\n@@ -148,123 +143,13 @@ static void gen_struct_ref (struct agent_expr *ax,\n \t\t\t    const char *operand_name);\n static void gen_static_field (struct agent_expr *ax, struct axs_value *value,\n \t\t\t      struct type *type, int fieldno);\n-static void gen_repeat (struct expression *exp, union exp_element **pc,\n-\t\t\tstruct agent_expr *ax, struct axs_value *value);\n-static void gen_sizeof (struct expression *exp, union exp_element **pc,\n-\t\t\tstruct agent_expr *ax, struct axs_value *value,\n-\t\t\tstruct type *size_type);\n-static void gen_expr_binop_rest (struct expression *exp,\n-\t\t\t\t enum exp_opcode op, union exp_element **pc,\n-\t\t\t\t struct agent_expr *ax,\n-\t\t\t\t struct axs_value *value,\n-\t\t\t\t struct axs_value *value1,\n-\t\t\t\t struct axs_value *value2);\n static void gen_expr_binop_rest (struct expression *exp,\n \t\t\t\t enum exp_opcode op,\n \t\t\t\t struct agent_expr *ax,\n \t\t\t\t struct axs_value *value,\n \t\t\t\t struct axs_value *value1,\n \t\t\t\t struct axs_value *value2);\n-\f\n-\n-/* Detecting constant expressions.  */\n-\n-/* If the variable reference at *PC is a constant, return its value.\n-   Otherwise, return zero.\n-\n-   Hey, Wally!  How can a variable reference be a constant?\n-\n-   Well, Beav, this function really handles the OP_VAR_VALUE operator,\n-   not specifically variable references.  GDB uses OP_VAR_VALUE to\n-   refer to any kind of symbolic reference: function names, enum\n-   elements, and goto labels are all handled through the OP_VAR_VALUE\n-   operator, even though they're constants.  It makes sense given the\n-   situation.\n-\n-   Gee, Wally, don'cha wonder sometimes if data representations that\n-   subvert commonly accepted definitions of terms in favor of heavily\n-   context-specific interpretations are really just a tool of the\n-   programming hegemony to preserve their power and exclude the\n-   proletariat?  */\n-\n-static struct value *\n-const_var_ref (struct symbol *var)\n-{\n-  struct type *type = SYMBOL_TYPE (var);\n-\n-  switch (SYMBOL_CLASS (var))\n-    {\n-    case LOC_CONST:\n-      return value_from_longest (type, (LONGEST) SYMBOL_VALUE (var));\n-\n-    case LOC_LABEL:\n-      return value_from_pointer (type, (CORE_ADDR) SYMBOL_VALUE_ADDRESS (var));\n-\n-    default:\n-      return 0;\n-    }\n-}\n-\n-\n-/* If the expression starting at *PC has a constant value, return it.\n-   Otherwise, return zero.  If we return a value, then *PC will be\n-   advanced to the end of it.  If we return zero, *PC could be\n-   anywhere.  */\n-static struct value *\n-const_expr (union exp_element **pc)\n-{\n-  enum exp_opcode op = (*pc)->opcode;\n-  struct value *v1;\n-\n-  switch (op)\n-    {\n-    case OP_LONG:\n-      {\n-\tstruct type *type = (*pc)[1].type;\n-\tLONGEST k = (*pc)[2].longconst;\n-\n-\t(*pc) += 4;\n-\treturn value_from_longest (type, k);\n-      }\n-\n-    case OP_VAR_VALUE:\n-      {\n-\tstruct value *v = const_var_ref ((*pc)[2].symbol);\n-\n-\t(*pc) += 4;\n-\treturn v;\n-      }\n-\n-      /* We could add more operators in here.  */\n-\n-    case UNOP_NEG:\n-      (*pc)++;\n-      v1 = const_expr (pc);\n-      if (v1)\n-\treturn value_neg (v1);\n-      else\n-\treturn 0;\n-\n-    default:\n-      return 0;\n-    }\n-}\n \n-\n-/* Like const_expr, but guarantee also that *PC is undisturbed if the\n-   expression is not constant.  */\n-static struct value *\n-maybe_const_expr (union exp_element **pc)\n-{\n-  union exp_element *tentative_pc = *pc;\n-  struct value *v = const_expr (&tentative_pc);\n-\n-  /* If we got a value, then update the real PC.  */\n-  if (v)\n-    *pc = tentative_pc;\n-\n-  return v;\n-}\n \f\n \n /* Generating bytecode from GDB expressions: general assumptions */\n@@ -1691,592 +1576,8 @@ gen_aggregate_elt_ref (struct agent_expr *ax, struct axs_value *value,\n   return 0;\n }\n \n-/* Generate code for GDB's magical `repeat' operator.\n-   LVALUE @ INT creates an array INT elements long, and whose elements\n-   have the same type as LVALUE, located in memory so that LVALUE is\n-   its first element.  For example, argv[0]@argc gives you the array\n-   of command-line arguments.\n-\n-   Unfortunately, because we have to know the types before we actually\n-   have a value for the expression, we can't implement this perfectly\n-   without changing the type system, having values that occupy two\n-   stack slots, doing weird things with sizeof, etc.  So we require\n-   the right operand to be a constant expression.  */\n-static void\n-gen_repeat (struct expression *exp, union exp_element **pc,\n-\t    struct agent_expr *ax, struct axs_value *value)\n-{\n-  struct axs_value value1;\n-\n-  /* We don't want to turn this into an rvalue, so no conversions\n-     here.  */\n-  gen_expr (exp, pc, ax, &value1);\n-  if (value1.kind != axs_lvalue_memory)\n-    error (_(\"Left operand of `@' must be an object in memory.\"));\n-\n-  /* Evaluate the length; it had better be a constant.  */\n-  {\n-    struct value *v = const_expr (pc);\n-    int length;\n-\n-    if (!v)\n-      error (_(\"Right operand of `@' must be a \"\n-\t       \"constant, in agent expressions.\"));\n-    if (value_type (v)->code () != TYPE_CODE_INT)\n-      error (_(\"Right operand of `@' must be an integer.\"));\n-    length = value_as_long (v);\n-    if (length <= 0)\n-      error (_(\"Right operand of `@' must be positive.\"));\n-\n-    /* The top of the stack is already the address of the object, so\n-       all we need to do is frob the type of the lvalue.  */\n-    {\n-      /* FIXME-type-allocation: need a way to free this type when we are\n-\t done with it.  */\n-      struct type *array\n-\t= lookup_array_range_type (value1.type, 0, length - 1);\n-\n-      value->kind = axs_lvalue_memory;\n-      value->type = array;\n-    }\n-  }\n-}\n-\n-\n-/* Emit code for the `sizeof' operator.\n-   *PC should point at the start of the operand expression; we advance it\n-   to the first instruction after the operand.  */\n-static void\n-gen_sizeof (struct expression *exp, union exp_element **pc,\n-\t    struct agent_expr *ax, struct axs_value *value,\n-\t    struct type *size_type)\n-{\n-  /* We don't care about the value of the operand expression; we only\n-     care about its type.  However, in the current arrangement, the\n-     only way to find an expression's type is to generate code for it.\n-     So we generate code for the operand, and then throw it away,\n-     replacing it with code that simply pushes its size.  */\n-  int start = ax->len;\n-\n-  gen_expr (exp, pc, ax, value);\n-\n-  /* Throw away the code we just generated.  */\n-  ax->len = start;\n-\n-  ax_const_l (ax, TYPE_LENGTH (value->type));\n-  value->kind = axs_rvalue;\n-  value->type = size_type;\n-}\n \f\n \n-/* Generate bytecode for a cast to TO_TYPE.  Advance *PC over the\n-   subexpression.  */\n-\n-static void\n-gen_expr_for_cast (struct expression *exp, union exp_element **pc,\n-\t\t   struct agent_expr *ax, struct axs_value *value,\n-\t\t   struct type *to_type)\n-{\n-  enum exp_opcode op = (*pc)[0].opcode;\n-\n-  /* Don't let symbols be handled with gen_expr because that throws an\n-     \"unknown type\" error for no-debug data symbols.  Instead, we want\n-     the cast to reinterpret such symbols.  */\n-  if (op == OP_VAR_MSYM_VALUE || op == OP_VAR_VALUE)\n-    {\n-      if (op == OP_VAR_VALUE)\n-\t{\n-\t  gen_var_ref (ax, value, (*pc)[2].symbol);\n-\n-\t  if (value->optimized_out)\n-\t    error (_(\"`%s' has been optimized out, cannot use\"),\n-\t\t   (*pc)[2].symbol->print_name ());\n-\t}\n-      else\n-\tgen_msym_var_ref (ax, value, (*pc)[2].msymbol, (*pc)[1].objfile);\n-      if (value->type->code () == TYPE_CODE_ERROR)\n-\tvalue->type = to_type;\n-      (*pc) += 4;\n-    }\n-  else\n-    gen_expr (exp, pc, ax, value);\n-  gen_cast (ax, value, to_type);\n-}\n-\n-/* Generating bytecode from GDB expressions: general recursive thingy  */\n-\n-/* XXX: i18n */\n-/* A gen_expr function written by a Gen-X'er guy.\n-   Append code for the subexpression of EXPR starting at *POS_P to AX.  */\n-void\n-gen_expr (struct expression *exp, union exp_element **pc,\n-\t  struct agent_expr *ax, struct axs_value *value)\n-{\n-  /* Used to hold the descriptions of operand expressions.  */\n-  struct axs_value value1, value2, value3;\n-  enum exp_opcode op = (*pc)[0].opcode, op2;\n-  int if1, go1, if2, go2, end;\n-  struct type *int_type = builtin_type (ax->gdbarch)->builtin_int;\n-\n-  /* If we're looking at a constant expression, just push its value.  */\n-  {\n-    struct value *v = maybe_const_expr (pc);\n-\n-    if (v)\n-      {\n-\tax_const_l (ax, value_as_long (v));\n-\tvalue->kind = axs_rvalue;\n-\tvalue->type = check_typedef (value_type (v));\n-\treturn;\n-      }\n-  }\n-\n-  /* Otherwise, go ahead and generate code for it.  */\n-  switch (op)\n-    {\n-      /* Binary arithmetic operators.  */\n-    case BINOP_ADD:\n-    case BINOP_SUB:\n-    case BINOP_MUL:\n-    case BINOP_DIV:\n-    case BINOP_REM:\n-    case BINOP_LSH:\n-    case BINOP_RSH:\n-    case BINOP_SUBSCRIPT:\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-    case BINOP_LESS:\n-    case BINOP_GTR:\n-    case BINOP_LEQ:\n-    case BINOP_GEQ:\n-      (*pc)++;\n-      gen_expr (exp, pc, ax, &value1);\n-      gen_usual_unary (ax, &value1);\n-      gen_expr_binop_rest (exp, op, pc, ax, value, &value1, &value2);\n-      break;\n-\n-    case BINOP_LOGICAL_AND:\n-      (*pc)++;\n-      /* Generate the obvious sequence of tests and jumps.  */\n-      gen_expr (exp, pc, ax, &value1);\n-      gen_usual_unary (ax, &value1);\n-      if1 = ax_goto (ax, aop_if_goto);\n-      go1 = ax_goto (ax, aop_goto);\n-      ax_label (ax, if1, ax->len);\n-      gen_expr (exp, pc, ax, &value2);\n-      gen_usual_unary (ax, &value2);\n-      if2 = ax_goto (ax, aop_if_goto);\n-      go2 = ax_goto (ax, aop_goto);\n-      ax_label (ax, if2, ax->len);\n-      ax_const_l (ax, 1);\n-      end = ax_goto (ax, aop_goto);\n-      ax_label (ax, go1, ax->len);\n-      ax_label (ax, go2, ax->len);\n-      ax_const_l (ax, 0);\n-      ax_label (ax, end, ax->len);\n-      value->kind = axs_rvalue;\n-      value->type = int_type;\n-      break;\n-\n-    case BINOP_LOGICAL_OR:\n-      (*pc)++;\n-      /* Generate the obvious sequence of tests and jumps.  */\n-      gen_expr (exp, pc, ax, &value1);\n-      gen_usual_unary (ax, &value1);\n-      if1 = ax_goto (ax, aop_if_goto);\n-      gen_expr (exp, pc, ax, &value2);\n-      gen_usual_unary (ax, &value2);\n-      if2 = ax_goto (ax, aop_if_goto);\n-      ax_const_l (ax, 0);\n-      end = ax_goto (ax, aop_goto);\n-      ax_label (ax, if1, ax->len);\n-      ax_label (ax, if2, ax->len);\n-      ax_const_l (ax, 1);\n-      ax_label (ax, end, ax->len);\n-      value->kind = axs_rvalue;\n-      value->type = int_type;\n-      break;\n-\n-    case TERNOP_COND:\n-      (*pc)++;\n-      gen_expr (exp, pc, ax, &value1);\n-      gen_usual_unary (ax, &value1);\n-      /* For (A ? B : C), it's easiest to generate subexpression\n-\t bytecodes in order, but if_goto jumps on true, so we invert\n-\t the sense of A.  Then we can do B by dropping through, and\n-\t jump to do C.  */\n-      gen_logical_not (ax, &value1, int_type);\n-      if1 = ax_goto (ax, aop_if_goto);\n-      gen_expr (exp, pc, ax, &value2);\n-      gen_usual_unary (ax, &value2);\n-      end = ax_goto (ax, aop_goto);\n-      ax_label (ax, if1, ax->len);\n-      gen_expr (exp, pc, ax, &value3);\n-      gen_usual_unary (ax, &value3);\n-      ax_label (ax, end, ax->len);\n-      /* This is arbitrary - what if B and C are incompatible types? */\n-      value->type = value2.type;\n-      value->kind = value2.kind;\n-      break;\n-\n-    case BINOP_ASSIGN:\n-      (*pc)++;\n-      if ((*pc)[0].opcode == OP_INTERNALVAR)\n-\t{\n-\t  const char *name = internalvar_name ((*pc)[1].internalvar);\n-\t  struct trace_state_variable *tsv;\n-\n-\t  (*pc) += 3;\n-\t  gen_expr (exp, pc, ax, value);\n-\t  tsv = find_trace_state_variable (name);\n-\t  if (tsv)\n-\t    {\n-\t      ax_tsv (ax, aop_setv, tsv->number);\n-\t      if (ax->tracing)\n-\t\tax_tsv (ax, aop_tracev, tsv->number);\n-\t    }\n-\t  else\n-\t    error (_(\"$%s is not a trace state variable, \"\n-\t\t     \"may not assign to it\"), name);\n-\t}\n-      else\n-\terror (_(\"May only assign to trace state variables\"));\n-      break;\n-\n-    case BINOP_ASSIGN_MODIFY:\n-      (*pc)++;\n-      op2 = (*pc)[0].opcode;\n-      (*pc)++;\n-      (*pc)++;\n-      if ((*pc)[0].opcode == OP_INTERNALVAR)\n-\t{\n-\t  const char *name = internalvar_name ((*pc)[1].internalvar);\n-\t  struct trace_state_variable *tsv;\n-\n-\t  (*pc) += 3;\n-\t  tsv = find_trace_state_variable (name);\n-\t  if (tsv)\n-\t    {\n-\t      /* The tsv will be the left half of the binary operation.  */\n-\t      ax_tsv (ax, aop_getv, tsv->number);\n-\t      if (ax->tracing)\n-\t\tax_tsv (ax, aop_tracev, tsv->number);\n-\t      /* Trace state variables are always 64-bit integers.  */\n-\t      value1.kind = axs_rvalue;\n-\t      value1.type = builtin_type (ax->gdbarch)->builtin_long_long;\n-\t      /* Now do right half of expression.  */\n-\t      gen_expr_binop_rest (exp, op2, pc, ax, value, &value1, &value2);\n-\t      /* We have a result of the binary op, set the tsv.  */\n-\t      ax_tsv (ax, aop_setv, tsv->number);\n-\t      if (ax->tracing)\n-\t\tax_tsv (ax, aop_tracev, tsv->number);\n-\t    }\n-\t  else\n-\t    error (_(\"$%s is not a trace state variable, \"\n-\t\t     \"may not assign to it\"), name);\n-\t}\n-      else\n-\terror (_(\"May only assign to trace state variables\"));\n-      break;\n-\n-      /* Note that we need to be a little subtle about generating code\n-\t for comma.  In C, we can do some optimizations here because\n-\t we know the left operand is only being evaluated for effect.\n-\t However, if the tracing kludge is in effect, then we always\n-\t need to evaluate the left hand side fully, so that all the\n-\t variables it mentions get traced.  */\n-    case BINOP_COMMA:\n-      (*pc)++;\n-      gen_expr (exp, pc, ax, &value1);\n-      /* Don't just dispose of the left operand.  We might be tracing,\n-\t in which case we want to emit code to trace it if it's an\n-\t lvalue.  */\n-      gen_traced_pop (ax, &value1);\n-      gen_expr (exp, pc, ax, value);\n-      /* It's the consumer's responsibility to trace the right operand.  */\n-      break;\n-\n-    case OP_LONG:\t\t/* some integer constant */\n-      {\n-\tstruct type *type = (*pc)[1].type;\n-\tLONGEST k = (*pc)[2].longconst;\n-\n-\t(*pc) += 4;\n-\tgen_int_literal (ax, value, k, type);\n-      }\n-      break;\n-\n-    case OP_VAR_VALUE:\n-      gen_var_ref (ax, value, (*pc)[2].symbol);\n-\n-      if (value->optimized_out)\n-\terror (_(\"`%s' has been optimized out, cannot use\"),\n-\t       (*pc)[2].symbol->print_name ());\n-\n-      if (value->type->code () == TYPE_CODE_ERROR)\n-\terror_unknown_type ((*pc)[2].symbol->print_name ());\n-\n-      (*pc) += 4;\n-      break;\n-\n-    case OP_VAR_MSYM_VALUE:\n-      gen_msym_var_ref (ax, value, (*pc)[2].msymbol, (*pc)[1].objfile);\n-\n-      if (value->type->code () == TYPE_CODE_ERROR)\n-\terror_unknown_type ((*pc)[2].msymbol->linkage_name ());\n-\n-      (*pc) += 4;\n-      break;\n-\n-    case OP_REGISTER:\n-      {\n-\tconst char *name = &(*pc)[2].string;\n-\tint reg;\n-\n-\t(*pc) += 4 + BYTES_TO_EXP_ELEM ((*pc)[1].longconst + 1);\n-\treg = user_reg_map_name_to_regnum (ax->gdbarch, name, strlen (name));\n-\tif (reg == -1)\n-\t  internal_error (__FILE__, __LINE__,\n-\t\t\t  _(\"Register $%s not available\"), name);\n-\t/* No support for tracing user registers yet.  */\n-\tif (reg >= gdbarch_num_cooked_regs (ax->gdbarch))\n-\t  error (_(\"'%s' is a user-register; \"\n-\t\t   \"GDB cannot yet trace user-register contents.\"),\n-\t\t name);\n-\tvalue->kind = axs_lvalue_register;\n-\tvalue->u.reg = reg;\n-\tvalue->type = register_type (ax->gdbarch, reg);\n-      }\n-      break;\n-\n-    case OP_INTERNALVAR:\n-      {\n-\tstruct internalvar *var = (*pc)[1].internalvar;\n-\tconst char *name = internalvar_name (var);\n-\tstruct trace_state_variable *tsv;\n-\n-\t(*pc) += 3;\n-\ttsv = find_trace_state_variable (name);\n-\tif (tsv)\n-\t  {\n-\t    ax_tsv (ax, aop_getv, tsv->number);\n-\t    if (ax->tracing)\n-\t      ax_tsv (ax, aop_tracev, tsv->number);\n-\t    /* Trace state variables are always 64-bit integers.  */\n-\t    value->kind = axs_rvalue;\n-\t    value->type = builtin_type (ax->gdbarch)->builtin_long_long;\n-\t  }\n-\telse if (! compile_internalvar_to_ax (var, ax, value))\n-\t  error (_(\"$%s is not a trace state variable; GDB agent \"\n-\t\t   \"expressions cannot use convenience variables.\"), name);\n-      }\n-      break;\n-\n-      /* Weirdo operator: see comments for gen_repeat for details.  */\n-    case BINOP_REPEAT:\n-      /* Note that gen_repeat handles its own argument evaluation.  */\n-      (*pc)++;\n-      gen_repeat (exp, pc, ax, value);\n-      break;\n-\n-    case UNOP_CAST:\n-      {\n-\tstruct type *type = (*pc)[1].type;\n-\n-\t(*pc) += 3;\n-\tgen_expr_for_cast (exp, pc, ax, value, type);\n-      }\n-      break;\n-\n-    case UNOP_CAST_TYPE:\n-      {\n-\tint offset;\n-\tstruct value *val;\n-\tstruct type *type;\n-\n-\t++*pc;\n-\toffset = *pc - exp->elts;\n-\tval = evaluate_subexp (NULL, exp, &offset, EVAL_AVOID_SIDE_EFFECTS);\n-\ttype = value_type (val);\n-\t*pc = &exp->elts[offset];\n-\tgen_expr_for_cast (exp, pc, ax, value, type);\n-      }\n-      break;\n-\n-    case UNOP_MEMVAL:\n-      {\n-\tstruct type *type = check_typedef ((*pc)[1].type);\n-\n-\t(*pc) += 3;\n-\tgen_expr (exp, pc, ax, value);\n-\n-\t/* If we have an axs_rvalue or an axs_lvalue_memory, then we\n-\t   already have the right value on the stack.  For\n-\t   axs_lvalue_register, we must convert.  */\n-\tif (value->kind == axs_lvalue_register)\n-\t  require_rvalue (ax, value);\n-\n-\tvalue->type = type;\n-\tvalue->kind = axs_lvalue_memory;\n-      }\n-      break;\n-\n-    case UNOP_MEMVAL_TYPE:\n-      {\n-\tint offset;\n-\tstruct value *val;\n-\tstruct type *type;\n-\n-\t++*pc;\n-\toffset = *pc - exp->elts;\n-\tval = evaluate_subexp (NULL, exp, &offset, EVAL_AVOID_SIDE_EFFECTS);\n-\ttype = value_type (val);\n-\t*pc = &exp->elts[offset];\n-\n-\tgen_expr (exp, pc, ax, value);\n-\n-\t/* If we have an axs_rvalue or an axs_lvalue_memory, then we\n-\t   already have the right value on the stack.  For\n-\t   axs_lvalue_register, we must convert.  */\n-\tif (value->kind == axs_lvalue_register)\n-\t  require_rvalue (ax, value);\n-\n-\tvalue->type = type;\n-\tvalue->kind = axs_lvalue_memory;\n-      }\n-      break;\n-\n-    case UNOP_PLUS:\n-      (*pc)++;\n-      /* + FOO is equivalent to 0 + FOO, which can be optimized.  */\n-      gen_expr (exp, pc, ax, value);\n-      gen_usual_unary (ax, value);\n-      break;\n-      \n-    case UNOP_NEG:\n-      (*pc)++;\n-      /* -FOO is equivalent to 0 - FOO.  */\n-      gen_int_literal (ax, &value1, 0,\n-\t\t       builtin_type (ax->gdbarch)->builtin_int);\n-      gen_usual_unary (ax, &value1);\t/* shouldn't do much */\n-      gen_expr (exp, pc, ax, &value2);\n-      gen_usual_unary (ax, &value2);\n-      gen_usual_arithmetic (ax, &value1, &value2);\n-      gen_binop (ax, value, &value1, &value2, aop_sub, aop_sub, 1, \"negation\");\n-      break;\n-\n-    case UNOP_LOGICAL_NOT:\n-      (*pc)++;\n-      gen_expr (exp, pc, ax, value);\n-      gen_usual_unary (ax, value);\n-      gen_logical_not (ax, value, int_type);\n-      break;\n-\n-    case UNOP_COMPLEMENT:\n-      (*pc)++;\n-      gen_expr (exp, pc, ax, value);\n-      gen_usual_unary (ax, value);\n-      gen_integral_promotions (ax, value);\n-      gen_complement (ax, value);\n-      break;\n-\n-    case UNOP_IND:\n-      (*pc)++;\n-      gen_expr (exp, pc, ax, value);\n-      gen_usual_unary (ax, value);\n-      if (!pointer_type (value->type))\n-\terror (_(\"Argument of unary `*' is not a pointer.\"));\n-      gen_deref (value);\n-      break;\n-\n-    case UNOP_ADDR:\n-      (*pc)++;\n-      gen_expr (exp, pc, ax, value);\n-      gen_address_of (value);\n-      break;\n-\n-    case UNOP_SIZEOF:\n-      (*pc)++;\n-      /* Notice that gen_sizeof handles its own operand, unlike most\n-\t of the other unary operator functions.  This is because we\n-\t have to throw away the code we generate.  */\n-      gen_sizeof (exp, pc, ax, value,\n-\t\t  builtin_type (ax->gdbarch)->builtin_int);\n-      break;\n-\n-    case STRUCTOP_STRUCT:\n-    case STRUCTOP_PTR:\n-      {\n-\tint length = (*pc)[1].longconst;\n-\tconst char *name = &(*pc)[2].string;\n-\n-\t(*pc) += 4 + BYTES_TO_EXP_ELEM (length + 1);\n-\tgen_expr (exp, pc, ax, value);\n-\tif (op == STRUCTOP_STRUCT)\n-\t  gen_struct_ref (ax, value, name, \".\", \"structure or union\");\n-\telse if (op == STRUCTOP_PTR)\n-\t  gen_struct_ref (ax, value, name, \"->\",\n-\t\t\t  \"pointer to a structure or union\");\n-\telse\n-\t  /* If this `if' chain doesn't handle it, then the case list\n-\t     shouldn't mention it, and we shouldn't be here.  */\n-\t  internal_error (__FILE__, __LINE__,\n-\t\t\t  _(\"gen_expr: unhandled struct case\"));\n-      }\n-      break;\n-\n-    case OP_THIS:\n-      {\n-\tstruct symbol *sym, *func;\n-\tconst struct block *b;\n-\tconst struct language_defn *lang;\n-\n-\tb = block_for_pc (ax->scope);\n-\tfunc = block_linkage_function (b);\n-\tlang = language_def (func->language ());\n-\n-\tsym = lookup_language_this (lang, b).symbol;\n-\tif (!sym)\n-\t  error (_(\"no `%s' found\"), lang->name_of_this ());\n-\n-\tgen_var_ref (ax, value, sym);\n-\n-\tif (value->optimized_out)\n-\t  error (_(\"`%s' has been optimized out, cannot use\"),\n-\t\t sym->print_name ());\n-\n-\t(*pc) += 2;\n-      }\n-      break;\n-\n-    case OP_SCOPE:\n-      {\n-\tstruct type *type = (*pc)[1].type;\n-\tint length = longest_to_int ((*pc)[2].longconst);\n-\tconst char *name = &(*pc)[3].string;\n-\tint found;\n-\n-\tfound = gen_aggregate_elt_ref (ax, value, type, name);\n-\tif (!found)\n-\t  error (_(\"There is no field named %s\"), name);\n-\t(*pc) += 5 + BYTES_TO_EXP_ELEM (length + 1);\n-      }\n-      break;\n-\n-    case OP_TYPE:\n-    case OP_TYPEOF:\n-    case OP_DECLTYPE:\n-      error (_(\"Attempt to use a type name as an expression.\"));\n-\n-    default:\n-      error (_(\"Unsupported operator %s (%d) in expression.\"),\n-\t     op_name (op), op);\n-    }\n-}\n-\n namespace expr\n {\n \n@@ -2901,19 +2202,6 @@ gen_expr_binop_rest (struct expression *exp,\n     }\n }\n \n-/* Variant of gen_expr_binop_rest that first generates the\n-   right-hand-side.  */\n-\n-static void\n-gen_expr_binop_rest (struct expression *exp,\n-\t\t     enum exp_opcode op, union exp_element **pc,\n-\t\t     struct agent_expr *ax, struct axs_value *value,\n-\t\t     struct axs_value *value1, struct axs_value *value2)\n-{\n-  gen_expr (exp, pc, ax, value2);\n-  gen_expr_binop_rest (exp, op, ax, value, value1, value2);\n-}\n-\n /* A helper function that emits a binop based on two operations.  */\n \n void\n@@ -3057,17 +2345,12 @@ gen_trace_for_expr (CORE_ADDR scope, struct expression *expr,\n \t\t    int trace_string)\n {\n   agent_expr_up ax (new agent_expr (expr->gdbarch, scope));\n-  union exp_element *pc;\n   struct axs_value value;\n \n-  pc = expr->elts;\n   ax->tracing = 1;\n   ax->trace_string = trace_string;\n   value.optimized_out = 0;\n-  if (expr->op != nullptr)\n-    expr->op->generate_ax (expr, ax.get (), &value);\n-  else\n-    gen_expr (expr, &pc, ax.get (), &value);\n+  expr->op->generate_ax (expr, ax.get (), &value);\n \n   /* Make sure we record the final object, and get rid of it.  */\n   gen_traced_pop (ax.get (), &value);\n@@ -3089,16 +2372,11 @@ agent_expr_up\n gen_eval_for_expr (CORE_ADDR scope, struct expression *expr)\n {\n   agent_expr_up ax (new agent_expr (expr->gdbarch, scope));\n-  union exp_element *pc;\n   struct axs_value value;\n \n-  pc = expr->elts;\n   ax->tracing = 0;\n   value.optimized_out = 0;\n-  if (expr->op != nullptr)\n-    expr->op->generate_ax (expr, ax.get (), &value);\n-  else\n-    gen_expr (expr, &pc, ax.get (), &value);\n+  expr->op->generate_ax (expr, ax.get (), &value);\n \n   require_rvalue (ax.get (), &value);\n \n@@ -3140,7 +2418,6 @@ gen_printf (CORE_ADDR scope, struct gdbarch *gdbarch,\n \t    int nargs, struct expression **exprs)\n {\n   agent_expr_up ax (new agent_expr (gdbarch, scope));\n-  union exp_element *pc;\n   struct axs_value value;\n   int tem;\n \n@@ -3152,13 +2429,7 @@ gen_printf (CORE_ADDR scope, struct gdbarch *gdbarch,\n   for (tem = nargs - 1; tem >= 0; --tem)\n     {\n       value.optimized_out = 0;\n-      if (exprs[tem]->op != nullptr)\n-\texprs[tem]->op->generate_ax (exprs[tem], ax.get (), &value);\n-      else\n-\t{\n-\t  pc = exprs[tem]->elts;\n-\t  gen_expr (exprs[tem], &pc, ax.get (), &value);\n-\t}\n+      exprs[tem]->op->generate_ax (exprs[tem], ax.get (), &value);\n       require_rvalue (ax.get (), &value);\n     }\n "
    },
    {
      "sha": "b143847889ba98de70e9e0f19bf63c70ea2c095b",
      "filename": "gdb/ax-gdb.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ax-gdb.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ax-gdb.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax-gdb.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -22,7 +22,6 @@\n #include \"ax.h\"  /* For agent_expr_up.  */\n \n struct expression;\n-union exp_element;\n \n /* Types and enums */\n "
    },
    {
      "sha": "de1e79ba5d0f1c389554d1a77f0762ea1643dff6",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 5,
      "deletions": 113,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -1898,12 +1898,11 @@ update_watchpoint (struct watchpoint *b, int reparse)\n     }\n   else if (within_current_scope && b->exp)\n     {\n-      int pc = 0;\n       std::vector<value_ref_ptr> val_chain;\n       struct value *v, *result;\n       struct program_space *frame_pspace;\n \n-      fetch_subexp_value (b->exp.get (), &pc, b->exp->op.get (), &v, &result,\n+      fetch_subexp_value (b->exp.get (), b->exp->op.get (), &v, &result,\n \t\t\t  &val_chain, false);\n \n       /* Avoid setting b->val if it's already set.  The meaning of\n@@ -5012,7 +5011,6 @@ watchpoint_check (bpstat bs)\n \t free_all_values.  We can't call free_all_values because we\n \t might be in the middle of evaluating a function call.  */\n \n-      int pc = 0;\n       struct value *mark;\n       struct value *new_val;\n \n@@ -5023,7 +5021,7 @@ watchpoint_check (bpstat bs)\n \treturn WP_VALUE_CHANGED;\n \n       mark = value_mark ();\n-      fetch_subexp_value (b->exp.get (), &pc, b->exp->op.get (), &new_val,\n+      fetch_subexp_value (b->exp.get (), b->exp->op.get (), &new_val,\n \t\t\t  NULL, NULL, false);\n \n       if (b->val_bitsize != 0)\n@@ -10124,112 +10122,7 @@ break_range_command (const char *arg, int from_tty)\n static bool\n watchpoint_exp_is_const (const struct expression *exp)\n {\n-  if (exp->op != nullptr)\n-    return exp->op->constant_p ();\n-\n-  int i = exp->nelts;\n-\n-  while (i > 0)\n-    {\n-      int oplenp, argsp;\n-\n-      /* We are only interested in the descriptor of each element.  */\n-      operator_length (exp, i, &oplenp, &argsp);\n-      i -= oplenp;\n-\n-      switch (exp->elts[i].opcode)\n-\t{\n-\tcase BINOP_ADD:\n-\tcase BINOP_SUB:\n-\tcase BINOP_MUL:\n-\tcase BINOP_DIV:\n-\tcase BINOP_REM:\n-\tcase BINOP_MOD:\n-\tcase BINOP_LSH:\n-\tcase BINOP_RSH:\n-\tcase BINOP_LOGICAL_AND:\n-\tcase BINOP_LOGICAL_OR:\n-\tcase BINOP_BITWISE_AND:\n-\tcase BINOP_BITWISE_IOR:\n-\tcase BINOP_BITWISE_XOR:\n-\tcase BINOP_EQUAL:\n-\tcase BINOP_NOTEQUAL:\n-\tcase BINOP_LESS:\n-\tcase BINOP_GTR:\n-\tcase BINOP_LEQ:\n-\tcase BINOP_GEQ:\n-\tcase BINOP_REPEAT:\n-\tcase BINOP_COMMA:\n-\tcase BINOP_EXP:\n-\tcase BINOP_MIN:\n-\tcase BINOP_MAX:\n-\tcase BINOP_INTDIV:\n-\tcase BINOP_CONCAT:\n-\tcase TERNOP_COND:\n-\tcase TERNOP_SLICE:\n-\n-\tcase OP_LONG:\n-\tcase OP_FLOAT:\n-\tcase OP_LAST:\n-\tcase OP_COMPLEX:\n-\tcase OP_STRING:\n-\tcase OP_ARRAY:\n-\tcase OP_TYPE:\n-\tcase OP_TYPEOF:\n-\tcase OP_DECLTYPE:\n-\tcase OP_TYPEID:\n-\tcase OP_NAME:\n-\tcase OP_OBJC_NSSTRING:\n-\n-\tcase UNOP_NEG:\n-\tcase UNOP_LOGICAL_NOT:\n-\tcase UNOP_COMPLEMENT:\n-\tcase UNOP_ADDR:\n-\tcase UNOP_HIGH:\n-\tcase UNOP_CAST:\n-\n-\tcase UNOP_CAST_TYPE:\n-\tcase UNOP_REINTERPRET_CAST:\n-\tcase UNOP_DYNAMIC_CAST:\n-\t  /* Unary, binary and ternary operators: We have to check\n-\t     their operands.  If they are constant, then so is the\n-\t     result of that operation.  For instance, if A and B are\n-\t     determined to be constants, then so is \"A + B\".\n-\n-\t     UNOP_IND is one exception to the rule above, because the\n-\t     value of *ADDR is not necessarily a constant, even when\n-\t     ADDR is.  */\n-\t  break;\n-\n-\tcase OP_VAR_VALUE:\n-\t  /* Check whether the associated symbol is a constant.\n-\n-\t     We use SYMBOL_CLASS rather than TYPE_CONST because it's\n-\t     possible that a buggy compiler could mark a variable as\n-\t     constant even when it is not, and TYPE_CONST would return\n-\t     true in this case, while SYMBOL_CLASS wouldn't.\n-\n-\t     We also have to check for function symbols because they\n-\t     are always constant.  */\n-\t  {\n-\t    struct symbol *s = exp->elts[i + 2].symbol;\n-\n-\t    if (SYMBOL_CLASS (s) != LOC_BLOCK\n-\t\t&& SYMBOL_CLASS (s) != LOC_CONST\n-\t\t&& SYMBOL_CLASS (s) != LOC_CONST_BYTES)\n-\t      return false;\n-\t    break;\n-\t  }\n-\n-\t/* The default action is to return 0 because we are using\n-\t   the optimistic approach here: If we don't know something,\n-\t   then it is not a constant.  */\n-\tdefault:\n-\t  return false;\n-\t}\n-    }\n-\n-  return true;\n+  return exp->op->constant_p ();\n }\n \n /* Watchpoint destructor.  */\n@@ -10730,7 +10623,6 @@ watch_command_1 (const char *arg, int accessflag, int from_tty,\n   const char *cond_end = NULL;\n   enum bptype bp_type;\n   int thread = -1;\n-  int pc = 0;\n   /* Flag to indicate whether we are going to use masks for\n      the hardware watchpoint.  */\n   bool use_mask = false;\n@@ -10847,8 +10739,8 @@ watch_command_1 (const char *arg, int accessflag, int from_tty,\n   exp_valid_block = tracker.block ();\n   struct value *mark = value_mark ();\n   struct value *val_as_value = nullptr;\n-  fetch_subexp_value (exp.get (), &pc, exp->op.get (), &val_as_value, &result,\n-\t\t      NULL, just_location);\n+  fetch_subexp_value (exp.get (), exp->op.get (), &val_as_value, &result, NULL,\n+\t\t      just_location);\n \n   if (val_as_value != NULL && just_location)\n     {"
    },
    {
      "sha": "1ad7ea221e8a655b6862d43c84311d000571aee5",
      "filename": "gdb/c-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 59,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/c-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/c-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -740,45 +740,6 @@ c_is_string_type_p (struct type *type)\n   return false;\n }\n \n-\f\n-/* Table mapping opcodes into strings for printing operators\n-   and precedences of the operators.  */\n-\n-const struct op_print c_op_print_tab[] =\n-{\n-  {\",\", BINOP_COMMA, PREC_COMMA, 0},\n-  {\"=\", BINOP_ASSIGN, PREC_ASSIGN, 1},\n-  {\"||\", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},\n-  {\"&&\", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},\n-  {\"|\", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},\n-  {\"^\", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},\n-  {\"&\", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},\n-  {\"==\", BINOP_EQUAL, PREC_EQUAL, 0},\n-  {\"!=\", BINOP_NOTEQUAL, PREC_EQUAL, 0},\n-  {\"<=\", BINOP_LEQ, PREC_ORDER, 0},\n-  {\">=\", BINOP_GEQ, PREC_ORDER, 0},\n-  {\">\", BINOP_GTR, PREC_ORDER, 0},\n-  {\"<\", BINOP_LESS, PREC_ORDER, 0},\n-  {\">>\", BINOP_RSH, PREC_SHIFT, 0},\n-  {\"<<\", BINOP_LSH, PREC_SHIFT, 0},\n-  {\"+\", BINOP_ADD, PREC_ADD, 0},\n-  {\"-\", BINOP_SUB, PREC_ADD, 0},\n-  {\"*\", BINOP_MUL, PREC_MUL, 0},\n-  {\"/\", BINOP_DIV, PREC_MUL, 0},\n-  {\"%\", BINOP_REM, PREC_MUL, 0},\n-  {\"@\", BINOP_REPEAT, PREC_REPEAT, 0},\n-  {\"+\", UNOP_PLUS, PREC_PREFIX, 0},\n-  {\"-\", UNOP_NEG, PREC_PREFIX, 0},\n-  {\"!\", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},\n-  {\"~\", UNOP_COMPLEMENT, PREC_PREFIX, 0},\n-  {\"*\", UNOP_IND, PREC_PREFIX, 0},\n-  {\"&\", UNOP_ADDR, PREC_PREFIX, 0},\n-  {\"sizeof \", UNOP_SIZEOF, PREC_PREFIX, 0},\n-  {\"alignof \", UNOP_ALIGNOF, PREC_PREFIX, 0},\n-  {\"++\", UNOP_PREINCREMENT, PREC_PREFIX, 0},\n-  {\"--\", UNOP_PREDECREMENT, PREC_PREFIX, 0},\n-  {NULL, OP_NULL, PREC_PREFIX, 0}\n-};\n \f\n \n void\n@@ -886,11 +847,6 @@ class c_language : public language_defn\n \n   enum macro_expansion macro_expansion () const override\n   { return macro_expansion_c; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return c_op_print_tab; }\n };\n \n /* Single instance of the C language class.  */\n@@ -1065,11 +1021,6 @@ class cplus_language : public language_defn\n   const struct lang_varobj_ops *varobj_ops () const override\n   { return &cplus_varobj_ops; }\n \n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return c_op_print_tab; }\n-\n protected:\n \n   /* See language.h.  */\n@@ -1140,11 +1091,6 @@ class asm_language : public language_defn\n \n   enum macro_expansion macro_expansion () const override\n   { return macro_expansion_c; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return c_op_print_tab; }\n };\n \n /* The single instance of the ASM language class.  */\n@@ -1197,11 +1143,6 @@ class minimal_language : public language_defn\n \n   enum macro_expansion macro_expansion () const override\n   { return macro_expansion_c; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return c_op_print_tab; }\n };\n \n /* The single instance of the minimal language class.  */"
    },
    {
      "sha": "b35e8b102a85e1e41a29e3503ee2924f0b877382",
      "filename": "gdb/c-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/c-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/c-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-lang.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -106,8 +106,6 @@ extern void c_language_arch_info (struct gdbarch *gdbarch,\n extern void c_emit_char (int c, struct type *type,\n \t\t\t struct ui_file *stream, int quoter);\n \n-extern const struct op_print c_op_print_tab[];\n-\n /* These are in c-typeprint.c: */\n \n extern void c_type_print_base (struct type *, struct ui_file *,"
    },
    {
      "sha": "6c9b730cf41bd558d6c02a88c526ab60eff8aa22",
      "filename": "gdb/d-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 43,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/d-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/d-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -57,44 +57,6 @@ d_demangle (const char *symbol, int options)\n   return gdb_demangle (symbol, options | DMGL_DLANG);\n }\n \n-/* Table mapping opcodes into strings for printing operators\n-   and precedences of the operators.  */\n-static const struct op_print d_op_print_tab[] =\n-{\n-  {\",\", BINOP_COMMA, PREC_COMMA, 0},\n-  {\"=\", BINOP_ASSIGN, PREC_ASSIGN, 1},\n-  {\"||\", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},\n-  {\"&&\", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},\n-  {\"|\", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},\n-  {\"^\", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},\n-  {\"&\", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},\n-  {\"==\", BINOP_EQUAL, PREC_ORDER, 0},\n-  {\"!=\", BINOP_NOTEQUAL, PREC_ORDER, 0},\n-  {\"<=\", BINOP_LEQ, PREC_ORDER, 0},\n-  {\">=\", BINOP_GEQ, PREC_ORDER, 0},\n-  {\">\", BINOP_GTR, PREC_ORDER, 0},\n-  {\"<\", BINOP_LESS, PREC_ORDER, 0},\n-  {\">>\", BINOP_RSH, PREC_SHIFT, 0},\n-  {\"<<\", BINOP_LSH, PREC_SHIFT, 0},\n-  {\"+\", BINOP_ADD, PREC_ADD, 0},\n-  {\"-\", BINOP_SUB, PREC_ADD, 0},\n-  {\"~\", BINOP_CONCAT, PREC_ADD, 0},\n-  {\"*\", BINOP_MUL, PREC_MUL, 0},\n-  {\"/\", BINOP_DIV, PREC_MUL, 0},\n-  {\"%\", BINOP_REM, PREC_MUL, 0},\n-  {\"^^\", BINOP_EXP, PREC_REPEAT, 0},\n-  {\"@\", BINOP_REPEAT, PREC_REPEAT, 0},\n-  {\"-\", UNOP_NEG, PREC_PREFIX, 0},\n-  {\"!\", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},\n-  {\"~\", UNOP_COMPLEMENT, PREC_PREFIX, 0},\n-  {\"*\", UNOP_IND, PREC_PREFIX, 0},\n-  {\"&\", UNOP_ADDR, PREC_PREFIX, 0},\n-  {\"sizeof \", UNOP_SIZEOF, PREC_PREFIX, 0},\n-  {\"++\", UNOP_PREINCREMENT, PREC_PREFIX, 0},\n-  {\"--\", UNOP_PREDECREMENT, PREC_PREFIX, 0},\n-  {NULL, OP_NULL, PREC_PREFIX, 0}\n-};\n-\n /* Class representing the D language.  */\n \n class d_language : public language_defn\n@@ -216,11 +178,6 @@ class d_language : public language_defn\n \n   const char *name_of_this () const override\n   { return \"this\"; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return d_op_print_tab; }\n };\n \n /* Single instance of the D language class.  */"
    },
    {
      "sha": "cccd3a8bbbacd00c84ba7bef89a91a5a0fe3a5cf",
      "filename": "gdb/dtrace-probe.c",
      "status": "modified",
      "additions": 1,
      "deletions": 9,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/dtrace-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/dtrace-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dtrace-probe.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -725,17 +725,9 @@ dtrace_probe::compile_to_ax (struct agent_expr *expr, struct axs_value *value,\n \t\t\t     unsigned n)\n {\n   struct dtrace_probe_arg *arg;\n-  union exp_element *pc;\n \n   arg = this->get_arg_by_number (n, expr->gdbarch);\n-\n-  if (arg->expr->op != nullptr)\n-    arg->expr->op->generate_ax (arg->expr.get (), expr, value);\n-  else\n-    {\n-      pc = arg->expr->elts;\n-      gen_expr (arg->expr.get (), &pc, expr, value);\n-    }\n+  arg->expr->op->generate_ax (arg->expr.get (), expr, value);\n \n   require_rvalue (expr, value);\n   value->type = arg->type;"
    },
    {
      "sha": "4c602235862716a6124b599ca969343bc71dda76",
      "filename": "gdb/eval.c",
      "status": "modified",
      "additions": 7,
      "deletions": 1617,
      "changes": 1624,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/eval.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/eval.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/eval.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -43,29 +43,6 @@\n #include \"expop.h\"\n #include \"c-exp.h\"\n \n-/* Prototypes for local functions.  */\n-\n-static struct value *evaluate_subexp_for_sizeof (struct expression *, int *,\n-\t\t\t\t\t\t enum noside);\n-\n-static struct value *evaluate_subexp_for_address (struct expression *,\n-\t\t\t\t\t\t  int *, enum noside);\n-\n-static value *evaluate_subexp_for_cast (expression *exp, int *pos,\n-\t\t\t\t\tenum noside noside,\n-\t\t\t\t\tstruct type *type);\n-\n-static struct value *evaluate_struct_tuple (struct value *,\n-\t\t\t\t\t    struct expression *, int *,\n-\t\t\t\t\t    enum noside, int);\n-\n-struct value *\n-evaluate_subexp (struct type *expect_type, struct expression *exp,\n-\t\t int *pos, enum noside noside)\n-{\n-  return ((*exp->language_defn->expression_ops ()->evaluate_exp)\n-\t  (expect_type, exp, pos, noside));\n-}\n \f\n /* Parse the string EXP as a C expression, evaluate it,\n    and return the result as a number.  */\n@@ -120,14 +97,7 @@ expression::evaluate (struct type *expect_type, enum noside noside)\n       && !thread_stack_temporaries_enabled_p (inferior_thread ()))\n     stack_temporaries.emplace (inferior_thread ());\n \n-  struct value *retval;\n-  if (op != nullptr)\n-    retval = op->evaluate (expect_type, this, noside);\n-  else\n-    {\n-      int pos = 0;\n-      retval = evaluate_subexp (expect_type, this, &pos, noside);\n-    }\n+  struct value *retval = op->evaluate (expect_type, this, noside);\n \n   if (stack_temporaries.has_value ()\n       && value_in_thread_stack_temporaries (retval, inferior_thread ()))\n@@ -153,17 +123,6 @@ evaluate_type (struct expression *exp)\n   return exp->evaluate (nullptr, EVAL_AVOID_SIDE_EFFECTS);\n }\n \n-/* Evaluate a subexpression, avoiding all memory references and\n-   getting a value whose type alone is correct.  */\n-\n-struct value *\n-evaluate_subexpression_type (struct expression *exp, int subexp)\n-{\n-  if (exp->op != nullptr)\n-    return exp->op->evaluate (nullptr, exp, EVAL_AVOID_SIDE_EFFECTS);\n-  return evaluate_subexp (nullptr, exp, &subexp, EVAL_AVOID_SIDE_EFFECTS);\n-}\n-\n /* Find the current value of a watchpoint on EXP.  Return the value in\n    *VALP and *RESULTP and the chain of intermediate and final values\n    in *VAL_CHAIN.  RESULTP and VAL_CHAIN may be NULL if the caller does\n@@ -187,7 +146,7 @@ evaluate_subexpression_type (struct expression *exp, int subexp)\n    values will be left on the value chain.  */\n \n void\n-fetch_subexp_value (struct expression *exp, int *pc,\n+fetch_subexp_value (struct expression *exp,\n \t\t    expr::operation *op,\n \t\t    struct value **valp, struct value **resultp,\n \t\t    std::vector<value_ref_ptr> *val_chain,\n@@ -207,10 +166,7 @@ fetch_subexp_value (struct expression *exp, int *pc,\n \n   try\n     {\n-      if (op == nullptr)\n-\tresult = evaluate_subexp (nullptr, exp, pc, EVAL_NORMAL);\n-      else\n-\tresult = op->evaluate (nullptr, exp, EVAL_NORMAL);\n+      result = op->evaluate (nullptr, exp, EVAL_NORMAL);\n     }\n   catch (const gdb_exception &ex)\n     {\n@@ -263,91 +219,6 @@ fetch_subexp_value (struct expression *exp, int *pc,\n     }\n }\n \n-/* Extract a field operation from an expression.  If the subexpression\n-   of EXP starting at *SUBEXP is not a structure dereference\n-   operation, return NULL.  Otherwise, return the name of the\n-   dereferenced field, and advance *SUBEXP to point to the\n-   subexpression of the left-hand-side of the dereference.  This is\n-   used when completing field names.  */\n-\n-const char *\n-extract_field_op (struct expression *exp, int *subexp)\n-{\n-  int tem;\n-  char *result;\n-\n-  if (exp->elts[*subexp].opcode != STRUCTOP_STRUCT\n-      && exp->elts[*subexp].opcode != STRUCTOP_PTR)\n-    return NULL;\n-  tem = longest_to_int (exp->elts[*subexp + 1].longconst);\n-  result = &exp->elts[*subexp + 2].string;\n-  (*subexp) += 1 + 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-  return result;\n-}\n-\n-/* This function evaluates brace-initializers (in C/C++) for\n-   structure types.  */\n-\n-static struct value *\n-evaluate_struct_tuple (struct value *struct_val,\n-\t\t       struct expression *exp,\n-\t\t       int *pos, enum noside noside, int nargs)\n-{\n-  struct type *struct_type = check_typedef (value_type (struct_val));\n-  struct type *field_type;\n-  int fieldno = -1;\n-\n-  while (--nargs >= 0)\n-    {\n-      struct value *val = NULL;\n-      int bitpos, bitsize;\n-      bfd_byte *addr;\n-\n-      fieldno++;\n-      /* Skip static fields.  */\n-      while (fieldno < struct_type->num_fields ()\n-\t     && field_is_static (&struct_type->field (fieldno)))\n-\tfieldno++;\n-      if (fieldno >= struct_type->num_fields ())\n-\terror (_(\"too many initializers\"));\n-      field_type = struct_type->field (fieldno).type ();\n-      if (field_type->code () == TYPE_CODE_UNION\n-\t  && TYPE_FIELD_NAME (struct_type, fieldno)[0] == '0')\n-\terror (_(\"don't know which variant you want to set\"));\n-\n-      /* Here, struct_type is the type of the inner struct,\n-\t while substruct_type is the type of the inner struct.\n-\t These are the same for normal structures, but a variant struct\n-\t contains anonymous union fields that contain substruct fields.\n-\t The value fieldno is the index of the top-level (normal or\n-\t anonymous union) field in struct_field, while the value\n-\t subfieldno is the index of the actual real (named inner) field\n-\t in substruct_type.  */\n-\n-      field_type = struct_type->field (fieldno).type ();\n-      if (val == 0)\n-\tval = evaluate_subexp (field_type, exp, pos, noside);\n-\n-      /* Now actually set the field in struct_val.  */\n-\n-      /* Assign val to field fieldno.  */\n-      if (value_type (val) != field_type)\n-\tval = value_cast (field_type, val);\n-\n-      bitsize = TYPE_FIELD_BITSIZE (struct_type, fieldno);\n-      bitpos = TYPE_FIELD_BITPOS (struct_type, fieldno);\n-      addr = value_contents_writeable (struct_val) + bitpos / 8;\n-      if (bitsize)\n-\tmodify_field (struct_type, addr,\n-\t\t      value_as_long (val), bitpos % 8, bitsize);\n-      else\n-\tmemcpy (addr, value_contents (val),\n-\t\tTYPE_LENGTH (value_type (val)));\n-\n-    }\n-  return struct_val;\n-}\n-\n /* Promote value ARG1 as appropriate before performing a unary operation\n    on this argument.\n    If the result is not appropriate for any particular language then it\n@@ -811,412 +682,6 @@ evaluate_subexp_do_call (expression *exp, enum noside noside,\n     }\n }\n \n-/* Helper for evaluating an OP_FUNCALL.  */\n-\n-static value *\n-evaluate_funcall (type *expect_type, expression *exp, int *pos,\n-\t\t  enum noside noside)\n-{\n-  int tem;\n-  int pc2 = 0;\n-  value *arg1 = NULL;\n-  value *arg2 = NULL;\n-  int save_pos1;\n-  symbol *function = NULL;\n-  char *function_name = NULL;\n-  const char *var_func_name = NULL;\n-\n-  int pc = (*pos);\n-  (*pos) += 2;\n-\n-  exp_opcode op = exp->elts[*pos].opcode;\n-  int nargs = longest_to_int (exp->elts[pc].longconst);\n-  /* Allocate arg vector, including space for the function to be\n-     called in argvec[0], a potential `this', and a terminating\n-     NULL.  */\n-  value **argvec = (value **) alloca (sizeof (value *) * (nargs + 3));\n-  if (op == STRUCTOP_MEMBER || op == STRUCTOP_MPTR)\n-    {\n-      /* First, evaluate the structure into arg2.  */\n-      pc2 = (*pos)++;\n-\n-      if (op == STRUCTOP_MEMBER)\n-\t{\n-\t  arg2 = evaluate_subexp_for_address (exp, pos, noside);\n-\t}\n-      else\n-\t{\n-\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\t}\n-\n-      /* If the function is a virtual function, then the aggregate\n-\t value (providing the structure) plays its part by providing\n-\t the vtable.  Otherwise, it is just along for the ride: call\n-\t the function directly.  */\n-\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      type *a1_type = check_typedef (value_type (arg1));\n-      if (noside == EVAL_SKIP)\n-\ttem = 1;  /* Set it to the right arg index so that all\n-\t\t     arguments can also be skipped.  */\n-      else if (a1_type->code () == TYPE_CODE_METHODPTR)\n-\t{\n-\t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t    arg1 = value_zero (TYPE_TARGET_TYPE (a1_type), not_lval);\n-\t  else\n-\t    arg1 = cplus_method_ptr_to_value (&arg2, arg1);\n-\n-\t  /* Now, say which argument to start evaluating from.  */\n-\t  nargs++;\n-\t  tem = 2;\n-\t  argvec[1] = arg2;\n-\t}\n-      else if (a1_type->code () == TYPE_CODE_MEMBERPTR)\n-\t{\n-\t  struct type *type_ptr\n-\t    = lookup_pointer_type (TYPE_SELF_TYPE (a1_type));\n-\t  struct type *target_type_ptr\n-\t    = lookup_pointer_type (TYPE_TARGET_TYPE (a1_type));\n-\n-\t  /* Now, convert these values to an address.  */\n-\t  arg2 = value_cast (type_ptr, arg2);\n-\n-\t  long mem_offset = value_as_long (arg1);\n-\n-\t  arg1 = value_from_pointer (target_type_ptr,\n-\t\t\t\t     value_as_long (arg2) + mem_offset);\n-\t  arg1 = value_ind (arg1);\n-\t  tem = 1;\n-\t}\n-      else\n-\terror (_(\"Non-pointer-to-member value used in pointer-to-member \"\n-\t\t \"construct\"));\n-    }\n-  else if (op == STRUCTOP_STRUCT || op == STRUCTOP_PTR)\n-    {\n-      /* Hair for method invocations.  */\n-      int tem2;\n-\n-      nargs++;\n-      /* First, evaluate the structure into arg2.  */\n-      pc2 = (*pos)++;\n-      tem2 = longest_to_int (exp->elts[pc2 + 1].longconst);\n-      *pos += 3 + BYTES_TO_EXP_ELEM (tem2 + 1);\n-\n-      if (op == STRUCTOP_STRUCT)\n-\t{\n-\t  /* If v is a variable in a register, and the user types\n-\t     v.method (), this will produce an error, because v has no\n-\t     address.\n-\n-\t     A possible way around this would be to allocate a copy of\n-\t     the variable on the stack, copy in the contents, call the\n-\t     function, and copy out the contents.  I.e. convert this\n-\t     from call by reference to call by copy-return (or\n-\t     whatever it's called).  However, this does not work\n-\t     because it is not the same: the method being called could\n-\t     stash a copy of the address, and then future uses through\n-\t     that address (after the method returns) would be expected\n-\t     to use the variable itself, not some copy of it.  */\n-\t  arg2 = evaluate_subexp_for_address (exp, pos, noside);\n-\t}\n-      else\n-\t{\n-\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-\t  /* Check to see if the operator '->' has been overloaded.\n-\t     If the operator has been overloaded replace arg2 with the\n-\t     value returned by the custom operator and continue\n-\t     evaluation.  */\n-\t  while (unop_user_defined_p (op, arg2))\n-\t    {\n-\t      struct value *value = NULL;\n-\t      try\n-\t\t{\n-\t\t  value = value_x_unop (arg2, op, noside);\n-\t\t}\n-\n-\t      catch (const gdb_exception_error &except)\n-\t\t{\n-\t\t  if (except.error == NOT_FOUND_ERROR)\n-\t\t    break;\n-\t\t  else\n-\t\t    throw;\n-\t\t}\n-\n-\t\targ2 = value;\n-\t    }\n-\t}\n-      /* Now, say which argument to start evaluating from.  */\n-      tem = 2;\n-    }\n-  else if (op == OP_SCOPE\n-\t   && overload_resolution\n-\t   && (exp->language_defn->la_language == language_cplus))\n-    {\n-      /* Unpack it locally so we can properly handle overload\n-\t resolution.  */\n-      char *name;\n-      int local_tem;\n-\n-      pc2 = (*pos)++;\n-      local_tem = longest_to_int (exp->elts[pc2 + 2].longconst);\n-      (*pos) += 4 + BYTES_TO_EXP_ELEM (local_tem + 1);\n-      struct type *type = exp->elts[pc2 + 1].type;\n-      name = &exp->elts[pc2 + 3].string;\n-\n-      function = NULL;\n-      function_name = NULL;\n-      if (type->code () == TYPE_CODE_NAMESPACE)\n-\t{\n-\t  function = cp_lookup_symbol_namespace (type->name (),\n-\t\t\t\t\t\t name,\n-\t\t\t\t\t\t get_selected_block (0),\n-\t\t\t\t\t\t VAR_DOMAIN).symbol;\n-\t  if (function == NULL)\n-\t    error (_(\"No symbol \\\"%s\\\" in namespace \\\"%s\\\".\"),\n-\t\t   name, type->name ());\n-\n-\t  tem = 1;\n-\t  /* arg2 is left as NULL on purpose.  */\n-\t}\n-      else\n-\t{\n-\t  gdb_assert (type->code () == TYPE_CODE_STRUCT\n-\t\t      || type->code () == TYPE_CODE_UNION);\n-\t  function_name = name;\n-\n-\t  /* We need a properly typed value for method lookup.  For\n-\t     static methods arg2 is otherwise unused.  */\n-\t  arg2 = value_zero (type, lval_memory);\n-\t  ++nargs;\n-\t  tem = 2;\n-\t}\n-    }\n-  else if (op == OP_ADL_FUNC)\n-    {\n-      /* Save the function position and move pos so that the arguments\n-\t can be evaluated.  */\n-      int func_name_len;\n-\n-      save_pos1 = *pos;\n-      tem = 1;\n-\n-      func_name_len = longest_to_int (exp->elts[save_pos1 + 3].longconst);\n-      (*pos) += 6 + BYTES_TO_EXP_ELEM (func_name_len + 1);\n-    }\n-  else\n-    {\n-      /* Non-method function call.  */\n-      save_pos1 = *pos;\n-      tem = 1;\n-\n-      /* If this is a C++ function wait until overload resolution.  */\n-      if (op == OP_VAR_VALUE\n-\t  && overload_resolution\n-\t  && (exp->language_defn->la_language == language_cplus))\n-\t{\n-\t  (*pos) += 4; /* Skip the evaluation of the symbol.  */\n-\t  argvec[0] = NULL;\n-\t}\n-      else\n-\t{\n-\t  if (op == OP_VAR_MSYM_VALUE)\n-\t    {\n-\t      minimal_symbol *msym = exp->elts[*pos + 2].msymbol;\n-\t      var_func_name = msym->print_name ();\n-\t    }\n-\t  else if (op == OP_VAR_VALUE)\n-\t    {\n-\t      symbol *sym = exp->elts[*pos + 2].symbol;\n-\t      var_func_name = sym->print_name ();\n-\t    }\n-\n-\t  argvec[0] = evaluate_subexp_with_coercion (exp, pos, noside);\n-\t  type *type = value_type (argvec[0]);\n-\t  if (type && type->code () == TYPE_CODE_PTR)\n-\t    type = TYPE_TARGET_TYPE (type);\n-\t  if (type && type->code () == TYPE_CODE_FUNC)\n-\t    {\n-\t      for (; tem <= nargs && tem <= type->num_fields (); tem++)\n-\t\t{\n-\t\t  argvec[tem] = evaluate_subexp (type->field (tem - 1).type (),\n-\t\t\t\t\t\t exp, pos, noside);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  /* Evaluate arguments (if not already done, e.g., namespace::func()\n-     and overload-resolution is off).  */\n-  for (; tem <= nargs; tem++)\n-    {\n-      /* Ensure that array expressions are coerced into pointer\n-\t objects.  */\n-      argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);\n-    }\n-\n-  /* Signal end of arglist.  */\n-  argvec[tem] = 0;\n-\n-  if (noside == EVAL_SKIP)\n-    return eval_skip_value (exp);\n-\n-  if (op == OP_ADL_FUNC)\n-    {\n-      struct symbol *symp;\n-      char *func_name;\n-      int  name_len;\n-      int string_pc = save_pos1 + 3;\n-\n-      /* Extract the function name.  */\n-      name_len = longest_to_int (exp->elts[string_pc].longconst);\n-      func_name = (char *) alloca (name_len + 1);\n-      strcpy (func_name, &exp->elts[string_pc + 1].string);\n-\n-      find_overload_match (gdb::make_array_view (&argvec[1], nargs),\n-\t\t\t   func_name,\n-\t\t\t   NON_METHOD, /* not method */\n-\t\t\t   NULL, NULL, /* pass NULL symbol since\n-\t\t\t\t\t  symbol is unknown */\n-\t\t\t   NULL, &symp, NULL, 0, noside);\n-\n-      /* Now fix the expression being evaluated.  */\n-      exp->elts[save_pos1 + 2].symbol = symp;\n-      argvec[0] = evaluate_subexp_with_coercion (exp, &save_pos1, noside);\n-    }\n-\n-  if (op == STRUCTOP_STRUCT || op == STRUCTOP_PTR\n-      || (op == OP_SCOPE && function_name != NULL))\n-    {\n-      int static_memfuncp;\n-      char *tstr;\n-\n-      /* Method invocation: stuff \"this\" as first parameter.  If the\n-\t method turns out to be static we undo this below.  */\n-      argvec[1] = arg2;\n-\n-      if (op != OP_SCOPE)\n-\t{\n-\t  /* Name of method from expression.  */\n-\t  tstr = &exp->elts[pc2 + 2].string;\n-\t}\n-      else\n-\ttstr = function_name;\n-\n-      if (overload_resolution && (exp->language_defn->la_language\n-\t\t\t\t  == language_cplus))\n-\t{\n-\t  /* Language is C++, do some overload resolution before\n-\t     evaluation.  */\n-\t  struct value *valp = NULL;\n-\n-\t  (void) find_overload_match (gdb::make_array_view (&argvec[1], nargs),\n-\t\t\t\t      tstr,\n-\t\t\t\t      METHOD, /* method */\n-\t\t\t\t      &arg2,  /* the object */\n-\t\t\t\t      NULL, &valp, NULL,\n-\t\t\t\t      &static_memfuncp, 0, noside);\n-\n-\t  if (op == OP_SCOPE && !static_memfuncp)\n-\t    {\n-\t      /* For the time being, we don't handle this.  */\n-\t      error (_(\"Call to overloaded function %s requires \"\n-\t\t       \"`this' pointer\"),\n-\t\t     function_name);\n-\t    }\n-\t  argvec[1] = arg2;\t/* the ``this'' pointer */\n-\t  argvec[0] = valp;\t/* Use the method found after overload\n-\t\t\t\t   resolution.  */\n-\t}\n-      else\n-\t/* Non-C++ case -- or no overload resolution.  */\n-\t{\n-\t  struct value *temp = arg2;\n-\n-\t  argvec[0] = value_struct_elt (&temp, argvec + 1, tstr,\n-\t\t\t\t\t&static_memfuncp,\n-\t\t\t\t\top == STRUCTOP_STRUCT\n-\t\t\t\t\t? \"structure\" : \"structure pointer\");\n-\t  /* value_struct_elt updates temp with the correct value of\n-\t     the ``this'' pointer if necessary, so modify argvec[1] to\n-\t     reflect any ``this'' changes.  */\n-\t  arg2\n-\t    = value_from_longest (lookup_pointer_type(value_type (temp)),\n-\t\t\t\t  value_address (temp)\n-\t\t\t\t  + value_embedded_offset (temp));\n-\t  argvec[1] = arg2;\t/* the ``this'' pointer */\n-\t}\n-\n-      /* Take out `this' if needed.  */\n-      if (static_memfuncp)\n-\t{\n-\t  argvec[1] = argvec[0];\n-\t  nargs--;\n-\t  argvec++;\n-\t}\n-    }\n-  else if (op == STRUCTOP_MEMBER || op == STRUCTOP_MPTR)\n-    {\n-      /* Pointer to member.  argvec[1] is already set up.  */\n-      argvec[0] = arg1;\n-    }\n-  else if (op == OP_VAR_VALUE || (op == OP_SCOPE && function != NULL))\n-    {\n-      /* Non-member function being called.  */\n-      /* fn: This can only be done for C++ functions.  A C-style\n-\t function in a C++ program, for instance, does not have the\n-\t fields that are expected here.  */\n-\n-      if (overload_resolution && (exp->language_defn->la_language\n-\t\t\t\t  == language_cplus))\n-\t{\n-\t  /* Language is C++, do some overload resolution before\n-\t     evaluation.  */\n-\t  struct symbol *symp;\n-\t  int no_adl = 0;\n-\n-\t  /* If a scope has been specified disable ADL.  */\n-\t  if (op == OP_SCOPE)\n-\t    no_adl = 1;\n-\n-\t  if (op == OP_VAR_VALUE)\n-\t    function = exp->elts[save_pos1+2].symbol;\n-\n-\t  (void) find_overload_match (gdb::make_array_view (&argvec[1], nargs),\n-\t\t\t\t      NULL,        /* no need for name */\n-\t\t\t\t      NON_METHOD,  /* not method */\n-\t\t\t\t      NULL, function, /* the function */\n-\t\t\t\t      NULL, &symp, NULL, no_adl, noside);\n-\n-\t  if (op == OP_VAR_VALUE)\n-\t    {\n-\t      /* Now fix the expression being evaluated.  */\n-\t      exp->elts[save_pos1+2].symbol = symp;\n-\t      argvec[0] = evaluate_subexp_with_coercion (exp, &save_pos1,\n-\t\t\t\t\t\t\t noside);\n-\t    }\n-\t  else\n-\t    argvec[0] = value_of_variable (symp, get_selected_block (0));\n-\t}\n-      else\n-\t{\n-\t  /* Not C++, or no overload resolution allowed.  */\n-\t  /* Nothing to be done; argvec already correctly set up.  */\n-\t}\n-    }\n-  else\n-    {\n-      /* It is probably a C-style function.  */\n-      /* Nothing to be done; argvec already correctly set up.  */\n-    }\n-\n-  return evaluate_subexp_do_call (exp, noside, argvec[0],\n-\t\t\t\t  gdb::make_array_view (argvec + 1, nargs),\n-\t\t\t\t  var_func_name, expect_type);\n-}\n-\n namespace expr\n {\n \n@@ -3066,738 +2531,6 @@ array_operation::evaluate (struct type *expect_type,\n \n }\n \n-struct value *\n-evaluate_subexp_standard (struct type *expect_type,\n-\t\t\t  struct expression *exp, int *pos,\n-\t\t\t  enum noside noside)\n-{\n-  enum exp_opcode op;\n-  int tem, tem2, tem3;\n-  int pc, oldpos;\n-  struct value *arg1 = NULL;\n-  struct value *arg2 = NULL;\n-  struct type *type;\n-  int nargs;\n-  struct value **argvec;\n-  int ix;\n-  struct type **arg_types;\n-\n-  pc = (*pos)++;\n-  op = exp->elts[pc].opcode;\n-\n-  switch (op)\n-    {\n-    case OP_SCOPE:\n-      tem = longest_to_int (exp->elts[pc + 2].longconst);\n-      (*pos) += 4 + BYTES_TO_EXP_ELEM (tem + 1);\n-      return eval_op_scope (expect_type, exp, noside,\n-\t\t\t    exp->elts[pc + 1].type,\n-\t\t\t    &exp->elts[pc + 3].string);\n-\n-    case OP_LONG:\n-      (*pos) += 3;\n-      return value_from_longest (exp->elts[pc + 1].type,\n-\t\t\t\t exp->elts[pc + 2].longconst);\n-\n-    case OP_FLOAT:\n-      (*pos) += 3;\n-      return value_from_contents (exp->elts[pc + 1].type,\n-\t\t\t\t  exp->elts[pc + 2].floatconst);\n-\n-    case OP_ADL_FUNC:\n-    case OP_VAR_VALUE:\n-      {\n-\t(*pos) += 3;\n-\tsymbol *var = exp->elts[pc + 2].symbol;\n-\tif (SYMBOL_TYPE (var)->code () == TYPE_CODE_ERROR)\n-\t  error_unknown_type (var->print_name ());\n-\tif (noside != EVAL_SKIP)\n-\t    return evaluate_var_value (noside, exp->elts[pc + 1].block, var);\n-\telse\n-\t  {\n-\t    /* Return a dummy value of the correct type when skipping, so\n-\t       that parent functions know what is to be skipped.  */\n-\t    return allocate_value (SYMBOL_TYPE (var));\n-\t  }\n-      }\n-\n-    case OP_VAR_MSYM_VALUE:\n-      {\n-\t(*pos) += 3;\n-\n-\tminimal_symbol *msymbol = exp->elts[pc + 2].msymbol;\n-\treturn eval_op_var_msym_value (expect_type, exp, noside,\n-\t\t\t\t       pc == 0, msymbol,\n-\t\t\t\t       exp->elts[pc + 1].objfile);\n-      }\n-\n-    case OP_VAR_ENTRY_VALUE:\n-      (*pos) += 2;\n-\n-      {\n-\tstruct symbol *sym = exp->elts[pc + 1].symbol;\n-\n-\treturn eval_op_var_entry_value (expect_type, exp, noside, sym);\n-      }\n-\n-    case OP_FUNC_STATIC_VAR:\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      if (noside == EVAL_SKIP)\n-\treturn eval_skip_value (exp);\n-\n-      {\n-\tvalue *func = evaluate_subexp_standard (NULL, exp, pos, noside);\n-\n-\treturn eval_op_func_static_var (expect_type, exp, noside, func,\n-\t\t\t\t\t&exp->elts[pc + 2].string);\n-      }\n-\n-    case OP_LAST:\n-      (*pos) += 2;\n-      return\n-\taccess_value_history (longest_to_int (exp->elts[pc + 1].longconst));\n-\n-    case OP_REGISTER:\n-      {\n-\tconst char *name = &exp->elts[pc + 2].string;\n-\n-\t(*pos) += 3 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);\n-\treturn eval_op_register (expect_type, exp, noside, name);\n-      }\n-    case OP_BOOL:\n-      (*pos) += 2;\n-      type = language_bool_type (exp->language_defn, exp->gdbarch);\n-      return value_from_longest (type, exp->elts[pc + 1].longconst);\n-\n-    case OP_INTERNALVAR:\n-      (*pos) += 2;\n-      return value_of_internalvar (exp->gdbarch,\n-\t\t\t\t   exp->elts[pc + 1].internalvar);\n-\n-    case OP_STRING:\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      return eval_op_string (expect_type, exp, noside, tem,\n-\t\t\t     &exp->elts[pc + 2].string);\n-\n-    case OP_OBJC_NSSTRING:\t\t/* Objective C Foundation Class\n-\t\t\t\t\t   NSString constant.  */\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      if (noside == EVAL_SKIP)\n-\treturn eval_skip_value (exp);\n-      return value_nsstring (exp->gdbarch, &exp->elts[pc + 2].string, tem + 1);\n-\n-    case OP_ARRAY:\n-      (*pos) += 3;\n-      tem2 = longest_to_int (exp->elts[pc + 1].longconst);\n-      tem3 = longest_to_int (exp->elts[pc + 2].longconst);\n-      nargs = tem3 - tem2 + 1;\n-      type = expect_type ? check_typedef (expect_type) : nullptr;\n-\n-      if (expect_type != nullptr && noside != EVAL_SKIP\n-\t  && type->code () == TYPE_CODE_STRUCT)\n-\t{\n-\t  struct value *rec = allocate_value (expect_type);\n-\n-\t  memset (value_contents_raw (rec), '\\0', TYPE_LENGTH (type));\n-\t  return evaluate_struct_tuple (rec, exp, pos, noside, nargs);\n-\t}\n-\n-      if (expect_type != nullptr && noside != EVAL_SKIP\n-\t  && type->code () == TYPE_CODE_ARRAY)\n-\t{\n-\t  struct type *range_type = type->index_type ();\n-\t  struct type *element_type = TYPE_TARGET_TYPE (type);\n-\t  struct value *array = allocate_value (expect_type);\n-\t  int element_size = TYPE_LENGTH (check_typedef (element_type));\n-\t  LONGEST low_bound, high_bound, index;\n-\n-\t  if (!get_discrete_bounds (range_type, &low_bound, &high_bound))\n-\t    {\n-\t      low_bound = 0;\n-\t      high_bound = (TYPE_LENGTH (type) / element_size) - 1;\n-\t    }\n-\t  index = low_bound;\n-\t  memset (value_contents_raw (array), 0, TYPE_LENGTH (expect_type));\n-\t  for (tem = nargs; --nargs >= 0;)\n-\t    {\n-\t      struct value *element;\n-\n-\t      element = evaluate_subexp (element_type, exp, pos, noside);\n-\t      if (value_type (element) != element_type)\n-\t\telement = value_cast (element_type, element);\n-\t      if (index > high_bound)\n-\t\t/* To avoid memory corruption.  */\n-\t\terror (_(\"Too many array elements\"));\n-\t      memcpy (value_contents_raw (array)\n-\t\t      + (index - low_bound) * element_size,\n-\t\t      value_contents (element),\n-\t\t      element_size);\n-\t      index++;\n-\t    }\n-\t  return array;\n-\t}\n-\n-      if (expect_type != nullptr && noside != EVAL_SKIP\n-\t  && type->code () == TYPE_CODE_SET)\n-\t{\n-\t  struct value *set = allocate_value (expect_type);\n-\t  gdb_byte *valaddr = value_contents_raw (set);\n-\t  struct type *element_type = type->index_type ();\n-\t  struct type *check_type = element_type;\n-\t  LONGEST low_bound, high_bound;\n-\n-\t  /* Get targettype of elementtype.  */\n-\t  while (check_type->code () == TYPE_CODE_RANGE\n-\t\t || check_type->code () == TYPE_CODE_TYPEDEF)\n-\t    check_type = TYPE_TARGET_TYPE (check_type);\n-\n-\t  if (!get_discrete_bounds (element_type, &low_bound, &high_bound))\n-\t    error (_(\"(power)set type with unknown size\"));\n-\t  memset (valaddr, '\\0', TYPE_LENGTH (type));\n-\t  for (tem = 0; tem < nargs; tem++)\n-\t    {\n-\t      LONGEST range_low, range_high;\n-\t      struct type *range_low_type, *range_high_type;\n-\t      struct value *elem_val;\n-\n-\t      elem_val = evaluate_subexp (element_type, exp, pos, noside);\n-\t      range_low_type = range_high_type = value_type (elem_val);\n-\t      range_low = range_high = value_as_long (elem_val);\n-\n-\t      /* Check types of elements to avoid mixture of elements from\n-\t\t different types. Also check if type of element is \"compatible\"\n-\t\t with element type of powerset.  */\n-\t      if (range_low_type->code () == TYPE_CODE_RANGE)\n-\t\trange_low_type = TYPE_TARGET_TYPE (range_low_type);\n-\t      if (range_high_type->code () == TYPE_CODE_RANGE)\n-\t\trange_high_type = TYPE_TARGET_TYPE (range_high_type);\n-\t      if ((range_low_type->code () != range_high_type->code ())\n-\t\t  || (range_low_type->code () == TYPE_CODE_ENUM\n-\t\t      && (range_low_type != range_high_type)))\n-\t\t/* different element modes.  */\n-\t\terror (_(\"POWERSET tuple elements of different mode\"));\n-\t      if ((check_type->code () != range_low_type->code ())\n-\t\t  || (check_type->code () == TYPE_CODE_ENUM\n-\t\t      && range_low_type != check_type))\n-\t\terror (_(\"incompatible POWERSET tuple elements\"));\n-\t      if (range_low > range_high)\n-\t\t{\n-\t\t  warning (_(\"empty POWERSET tuple range\"));\n-\t\t  continue;\n-\t\t}\n-\t      if (range_low < low_bound || range_high > high_bound)\n-\t\terror (_(\"POWERSET tuple element out of range\"));\n-\t      range_low -= low_bound;\n-\t      range_high -= low_bound;\n-\t      for (; range_low <= range_high; range_low++)\n-\t\t{\n-\t\t  int bit_index = (unsigned) range_low % TARGET_CHAR_BIT;\n-\n-\t\t  if (gdbarch_byte_order (exp->gdbarch) == BFD_ENDIAN_BIG)\n-\t\t    bit_index = TARGET_CHAR_BIT - 1 - bit_index;\n-\t\t  valaddr[(unsigned) range_low / TARGET_CHAR_BIT]\n-\t\t    |= 1 << bit_index;\n-\t\t}\n-\t    }\n-\t  return set;\n-\t}\n-\n-      argvec = XALLOCAVEC (struct value *, nargs);\n-      for (tem = 0; tem < nargs; tem++)\n-\t{\n-\t  /* Ensure that array expressions are coerced into pointer\n-\t     objects.  */\n-\t  argvec[tem] = evaluate_subexp_with_coercion (exp, pos, noside);\n-\t}\n-      if (noside == EVAL_SKIP)\n-\treturn eval_skip_value (exp);\n-      return value_array (tem2, tem3, argvec);\n-\n-    case TERNOP_SLICE:\n-      {\n-\tstruct value *array = evaluate_subexp (nullptr, exp, pos, noside);\n-\tstruct value *low = evaluate_subexp (nullptr, exp, pos, noside);\n-\tstruct value *upper = evaluate_subexp (nullptr, exp, pos, noside);\n-\treturn eval_op_ternop (expect_type, exp, noside, array, low, upper);\n-      }\n-\n-    case TERNOP_COND:\n-      /* Skip third and second args to evaluate the first one.  */\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (value_logical_not (arg1))\n-\t{\n-\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\t  return evaluate_subexp (nullptr, exp, pos, noside);\n-\t}\n-      else\n-\t{\n-\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\t  return arg2;\n-\t}\n-\n-    case OP_OBJC_SELECTOR:\n-      {\t\t\t\t/* Objective C @selector operator.  */\n-\tchar *sel = &exp->elts[pc + 2].string;\n-\tint len = longest_to_int (exp->elts[pc + 1].longconst);\n-\n-\t(*pos) += 3 + BYTES_TO_EXP_ELEM (len + 1);\n-\tif (sel[len] != 0)\n-\t  sel[len] = 0;\t\t/* Make sure it's terminated.  */\n-\n-\treturn eval_op_objc_selector (expect_type, exp, noside, sel);\n-      }\n-\n-    case OP_OBJC_MSGCALL:\n-      {\t\t\t\t/* Objective C message (method) call.  */\n-\tCORE_ADDR selector = 0;\n-\n-\tenum noside sub_no_side = EVAL_NORMAL;\n-\n-\tstruct value *target = NULL;\n-\n-\tstruct type *selector_type = NULL;\n-\n-\tselector = exp->elts[pc + 1].longconst;\n-\tnargs = exp->elts[pc + 2].longconst;\n-\targvec = XALLOCAVEC (struct value *, nargs + 3);\n-\n-\t(*pos) += 3;\n-\n-\tselector_type = builtin_type (exp->gdbarch)->builtin_data_ptr;\n-\n-\tif (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t  sub_no_side = EVAL_NORMAL;\n-\telse\n-\t  sub_no_side = noside;\n-\n-\ttarget = evaluate_subexp (selector_type, exp, pos, sub_no_side);\n-\n-\tif (value_as_long (target) == 0)\n-\t  sub_no_side = EVAL_SKIP;\n-\telse\n-\t  sub_no_side = noside;\n-\n-\t/* Now depending on whether we found a symbol for the method,\n-\t   we will either call the runtime dispatcher or the method\n-\t   directly.  */\n-\n-\targvec[0] = nullptr;\n-\targvec[1] = nullptr;\n-\t/* User-supplied arguments.  */\n-\tfor (tem = 0; tem < nargs; tem++)\n-\t  argvec[tem + 2] = evaluate_subexp_with_coercion (exp, pos,\n-\t\t\t\t\t\t\t   sub_no_side);\n-\targvec[tem + 3] = 0;\n-\n-\tauto call_args = gdb::make_array_view (argvec, nargs + 3);\n-\n-\treturn eval_op_objc_msgcall (expect_type, exp, noside, selector,\n-\t\t\t\t     target, call_args);\n-      }\n-      break;\n-\n-    case OP_FUNCALL:\n-      return evaluate_funcall (expect_type, exp, pos, noside);\n-\n-    case OP_COMPLEX:\n-      /* We have a complex number, There should be 2 floating \n-\t point numbers that compose it.  */\n-      (*pos) += 2;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      return value_literal_complex (arg1, arg2, exp->elts[pc + 1].type);\n-\n-    case STRUCTOP_STRUCT:\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_structop_struct (expect_type, exp, noside, arg1,\n-\t\t\t\t      &exp->elts[pc + 2].string);\n-\n-    case STRUCTOP_PTR:\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_structop_ptr (expect_type, exp, noside, arg1,\n-\t\t\t\t   &exp->elts[pc + 2].string);\n-\n-    case STRUCTOP_MEMBER:\n-    case STRUCTOP_MPTR:\n-      if (op == STRUCTOP_MEMBER)\n-\targ1 = evaluate_subexp_for_address (exp, pos, noside);\n-      else\n-\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      return eval_op_member (expect_type, exp, noside, arg1, arg2);\n-\n-    case TYPE_INSTANCE:\n-      {\n-\ttype_instance_flags flags\n-\t  = (type_instance_flag_value) longest_to_int (exp->elts[pc + 1].longconst);\n-\tnargs = longest_to_int (exp->elts[pc + 2].longconst);\n-\targ_types = (struct type **) alloca (nargs * sizeof (struct type *));\n-\tfor (ix = 0; ix < nargs; ++ix)\n-\t  arg_types[ix] = exp->elts[pc + 2 + ix + 1].type;\n-\n-\tfake_method fake_expect_type (flags, nargs, arg_types);\n-\t*(pos) += 4 + nargs;\n-\treturn evaluate_subexp_standard (fake_expect_type.type (), exp, pos,\n-\t\t\t\t\t noside);\n-      }\n-\n-    case BINOP_CONCAT:\n-      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      return eval_op_concat (expect_type, exp, noside, arg1, arg2);\n-\n-    case BINOP_ASSIGN:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      /* Special-case assignments where the left-hand-side is a\n-\t convenience variable -- in these, don't bother setting an\n-\t expected type.  This avoids a weird case where re-assigning a\n-\t string or array to an internal variable could error with \"Too\n-\t many array elements\".  */\n-      arg2 = evaluate_subexp (VALUE_LVAL (arg1) == lval_internalvar\n-\t\t\t\t? nullptr\n-\t\t\t\t: value_type (arg1),\n-\t\t\t      exp, pos, noside);\n-\n-      if (noside == EVAL_SKIP || noside == EVAL_AVOID_SIDE_EFFECTS)\n-\treturn arg1;\n-      if (binop_user_defined_p (op, arg1, arg2))\n-\treturn value_x_binop (arg1, arg2, op, OP_NULL, noside);\n-      else\n-\treturn value_assign (arg1, arg2);\n-\n-    case BINOP_ASSIGN_MODIFY:\n-      (*pos) += 2;\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      op = exp->elts[pc + 1].opcode;\n-      return eval_binop_assign_modify (expect_type, exp, noside, op,\n-\t\t\t\t       arg1, arg2);\n-\n-    case BINOP_ADD:\n-      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      return eval_op_add (expect_type, exp, noside, arg1, arg2);\n-\n-    case BINOP_SUB:\n-      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      arg2 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      return eval_op_sub (expect_type, exp, noside, arg1, arg2);\n-\n-    case BINOP_EXP:\n-    case BINOP_MUL:\n-    case BINOP_DIV:\n-    case BINOP_INTDIV:\n-    case BINOP_REM:\n-    case BINOP_MOD:\n-    case BINOP_LSH:\n-    case BINOP_RSH:\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_binary (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case BINOP_SUBSCRIPT:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_subscript (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case MULTI_SUBSCRIPT:\n-      (*pos) += 2;\n-      nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-      arg1 = evaluate_subexp_with_coercion (exp, pos, noside);\n-      argvec = XALLOCAVEC (struct value *, nargs);\n-      for (ix = 0; ix < nargs; ++ix)\n-\targvec[ix] = evaluate_subexp_with_coercion (exp, pos, noside);\n-      return eval_multi_subscript (expect_type, exp, noside, arg1,\n-\t\t\t\t   gdb::make_array_view (argvec, nargs));\n-\n-    case BINOP_LOGICAL_AND:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\t{\n-\t  evaluate_subexp (nullptr, exp, pos, noside);\n-\t  return eval_skip_value (exp);\n-\t}\n-\n-      oldpos = *pos;\n-      arg2 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      *pos = oldpos;\n-\n-      if (binop_user_defined_p (op, arg1, arg2))\n-\t{\n-\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\t  return value_x_binop (arg1, arg2, op, OP_NULL, noside);\n-\t}\n-      else\n-\t{\n-\t  tem = value_logical_not (arg1);\n-\t  arg2\n-\t    = evaluate_subexp (nullptr, exp, pos, (tem ? EVAL_SKIP : noside));\n-\t  type = language_bool_type (exp->language_defn, exp->gdbarch);\n-\t  return value_from_longest (type,\n-\t\t\t     (LONGEST) (!tem && !value_logical_not (arg2)));\n-\t}\n-\n-    case BINOP_LOGICAL_OR:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\t{\n-\t  evaluate_subexp (nullptr, exp, pos, noside);\n-\t  return eval_skip_value (exp);\n-\t}\n-\n-      oldpos = *pos;\n-      arg2 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      *pos = oldpos;\n-\n-      if (binop_user_defined_p (op, arg1, arg2))\n-\t{\n-\t  arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-\t  return value_x_binop (arg1, arg2, op, OP_NULL, noside);\n-\t}\n-      else\n-\t{\n-\t  tem = value_logical_not (arg1);\n-\t  arg2\n-\t    = evaluate_subexp (nullptr, exp, pos, (!tem ? EVAL_SKIP : noside));\n-\t  type = language_bool_type (exp->language_defn, exp->gdbarch);\n-\t  return value_from_longest (type,\n-\t\t\t     (LONGEST) (!tem || !value_logical_not (arg2)));\n-\t}\n-\n-    case BINOP_EQUAL:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_equal (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case BINOP_NOTEQUAL:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_notequal (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case BINOP_LESS:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_less (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case BINOP_GTR:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_gtr (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case BINOP_GEQ:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_geq (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case BINOP_LEQ:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n-      return eval_op_leq (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case BINOP_REPEAT:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      arg2 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_repeat (expect_type, exp, noside, op, arg1, arg2);\n-\n-    case BINOP_COMMA:\n-      evaluate_subexp (nullptr, exp, pos, noside);\n-      return evaluate_subexp (nullptr, exp, pos, noside);\n-\n-    case UNOP_PLUS:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_plus (expect_type, exp, noside, op, arg1);\n-      \n-    case UNOP_NEG:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_neg (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_COMPLEMENT:\n-      /* C++: check for and handle destructor names.  */\n-\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_complement (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_LOGICAL_NOT:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n-      return eval_op_lognot (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_IND:\n-      if (expect_type && expect_type->code () == TYPE_CODE_PTR)\n-\texpect_type = TYPE_TARGET_TYPE (check_typedef (expect_type));\n-      arg1 = evaluate_subexp (expect_type, exp, pos, noside);\n-      return eval_op_ind (expect_type, exp, noside, arg1);\n-\n-    case UNOP_ADDR:\n-      /* C++: check for and handle pointer to members.  */\n-\n-      if (noside == EVAL_SKIP)\n-\t{\n-\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\t  return eval_skip_value (exp);\n-\t}\n-      else\n-\treturn evaluate_subexp_for_address (exp, pos, noside);\n-\n-    case UNOP_SIZEOF:\n-      if (noside == EVAL_SKIP)\n-\t{\n-\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\t  return eval_skip_value (exp);\n-\t}\n-      return evaluate_subexp_for_sizeof (exp, pos, noside);\n-\n-    case UNOP_ALIGNOF:\n-      arg1 = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      return eval_op_alignof (expect_type, exp, noside, arg1);\n-\n-    case UNOP_CAST:\n-      (*pos) += 2;\n-      type = exp->elts[pc + 1].type;\n-      return evaluate_subexp_for_cast (exp, pos, noside, type);\n-\n-    case UNOP_CAST_TYPE:\n-      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      type = value_type (arg1);\n-      return evaluate_subexp_for_cast (exp, pos, noside, type);\n-\n-    case UNOP_DYNAMIC_CAST:\n-      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      type = value_type (arg1);\n-      arg1 = evaluate_subexp (type, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\treturn eval_skip_value (exp);\n-      return value_dynamic_cast (type, arg1);\n-\n-    case UNOP_REINTERPRET_CAST:\n-      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      type = value_type (arg1);\n-      arg1 = evaluate_subexp (type, exp, pos, noside);\n-      if (noside == EVAL_SKIP)\n-\treturn eval_skip_value (exp);\n-      return value_reinterpret_cast (type, arg1);\n-\n-    case UNOP_MEMVAL:\n-      (*pos) += 2;\n-      arg1 = evaluate_subexp (expect_type, exp, pos, noside);\n-      return eval_op_memval (expect_type, exp, noside, arg1,\n-\t\t\t     exp->elts[pc + 1].type);\n-\n-    case UNOP_MEMVAL_TYPE:\n-      arg1 = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      type = value_type (arg1);\n-      arg1 = evaluate_subexp (expect_type, exp, pos, noside);\n-      return eval_op_memval (expect_type, exp, noside, arg1, type);\n-\n-    case UNOP_PREINCREMENT:\n-      arg1 = evaluate_subexp (expect_type, exp, pos, noside);\n-      return eval_op_preinc (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_PREDECREMENT:\n-      arg1 = evaluate_subexp (expect_type, exp, pos, noside);\n-      return eval_op_predec (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_POSTINCREMENT:\n-      arg1 = evaluate_subexp (expect_type, exp, pos, noside);\n-      return eval_op_postinc (expect_type, exp, noside, op, arg1);\n-\n-    case UNOP_POSTDECREMENT:\n-      arg1 = evaluate_subexp (expect_type, exp, pos, noside);\n-      return eval_op_postdec (expect_type, exp, noside, op, arg1);\n-\n-    case OP_THIS:\n-      (*pos) += 1;\n-      return value_of_this (exp->language_defn);\n-\n-    case OP_TYPE:\n-      /* The value is not supposed to be used.  This is here to make it\n-\t easier to accommodate expressions that contain types.  */\n-      (*pos) += 2;\n-      return eval_op_type (expect_type, exp, noside, exp->elts[pc + 1].type);\n-\n-    case OP_TYPEOF:\n-    case OP_DECLTYPE:\n-      if (noside == EVAL_SKIP)\n-\t{\n-\t  evaluate_subexp (nullptr, exp, pos, EVAL_SKIP);\n-\t  return eval_skip_value (exp);\n-\t}\n-      else if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t{\n-\t  enum exp_opcode sub_op = exp->elts[*pos].opcode;\n-\t  struct value *result;\n-\n-\t  result = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-\n-\t  /* 'decltype' has special semantics for lvalues.  */\n-\t  if (op == OP_DECLTYPE\n-\t      && (sub_op == BINOP_SUBSCRIPT\n-\t\t  || sub_op == STRUCTOP_MEMBER\n-\t\t  || sub_op == STRUCTOP_MPTR\n-\t\t  || sub_op == UNOP_IND\n-\t\t  || sub_op == STRUCTOP_STRUCT\n-\t\t  || sub_op == STRUCTOP_PTR\n-\t\t  || sub_op == OP_SCOPE))\n-\t    {\n-\t      type = value_type (result);\n-\n-\t      if (!TYPE_IS_REFERENCE (type))\n-\t\t{\n-\t\t  type = lookup_lvalue_reference_type (type);\n-\t\t  result = allocate_value (type);\n-\t\t}\n-\t    }\n-\n-\t  return result;\n-\t}\n-      else\n-\terror (_(\"Attempt to use a type as an expression\"));\n-\n-    case OP_TYPEID:\n-      {\n-\tstruct value *result;\n-\tenum exp_opcode sub_op = exp->elts[*pos].opcode;\n-\n-\tif (sub_op == OP_TYPE || sub_op == OP_DECLTYPE || sub_op == OP_TYPEOF)\n-\t  result = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-\telse\n-\t  result = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-\tif (noside != EVAL_NORMAL)\n-\t  return allocate_value (cplus_typeid_type (exp->gdbarch));\n-\n-\treturn cplus_typeid (result);\n-      }\n-\n-    default:\n-      /* Removing this case and compiling with gcc -Wall reveals that\n-\t a lot of cases are hitting this case.  Some of these should\n-\t probably be removed from expression.h; others are legitimate\n-\t expressions which are (apparently) not fully implemented.\n-\n-\t If there are any cases landing here which mean a user error,\n-\t then they should be separate cases, with more descriptive\n-\t error messages.  */\n-\n-      error (_(\"GDB does not (yet) know how to \"\n-\t       \"evaluate that kind of expression\"));\n-    }\n-\n-  gdb_assert_not_reached (\"missed return?\");\n-}\n \f\n /* Helper for evaluate_subexp_for_address.  */\n \n@@ -3822,117 +2555,6 @@ evaluate_subexp_for_address_base (struct expression *exp, enum noside noside,\n   return value_addr (x);\n }\n \n-/* Evaluate a subexpression of EXP, at index *POS,\n-   and return the address of that subexpression.\n-   Advance *POS over the subexpression.\n-   If the subexpression isn't an lvalue, get an error.\n-   NOSIDE may be EVAL_AVOID_SIDE_EFFECTS;\n-   then only the type of the result need be correct.  */\n-\n-static struct value *\n-evaluate_subexp_for_address (struct expression *exp, int *pos,\n-\t\t\t     enum noside noside)\n-{\n-  enum exp_opcode op;\n-  int pc;\n-  struct symbol *var;\n-  struct value *x;\n-  int tem;\n-\n-  pc = (*pos);\n-  op = exp->elts[pc].opcode;\n-\n-  switch (op)\n-    {\n-    case UNOP_IND:\n-      (*pos)++;\n-      x = evaluate_subexp (nullptr, exp, pos, noside);\n-\n-      /* We can't optimize out \"&*\" if there's a user-defined operator*.  */\n-      if (unop_user_defined_p (op, x))\n-\t{\n-\t  x = value_x_unop (x, op, noside);\n-\t  goto default_case_after_eval;\n-\t}\n-\n-      return coerce_array (x);\n-\n-    case UNOP_MEMVAL:\n-      (*pos) += 3;\n-      return value_cast (lookup_pointer_type (exp->elts[pc + 1].type),\n-\t\t\t evaluate_subexp (nullptr, exp, pos, noside));\n-\n-    case UNOP_MEMVAL_TYPE:\n-      {\n-\tstruct type *type;\n-\n-\t(*pos) += 1;\n-\tx = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-\ttype = value_type (x);\n-\treturn value_cast (lookup_pointer_type (type),\n-\t\t\t   evaluate_subexp (nullptr, exp, pos, noside));\n-      }\n-\n-    case OP_VAR_VALUE:\n-      var = exp->elts[pc + 2].symbol;\n-\n-      /* C++: The \"address\" of a reference should yield the address\n-       * of the object pointed to.  Let value_addr() deal with it.  */\n-      if (TYPE_IS_REFERENCE (SYMBOL_TYPE (var)))\n-\tgoto default_case;\n-\n-      (*pos) += 4;\n-      if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t{\n-\t  struct type *type =\n-\t    lookup_pointer_type (SYMBOL_TYPE (var));\n-\t  enum address_class sym_class = SYMBOL_CLASS (var);\n-\n-\t  if (sym_class == LOC_CONST\n-\t      || sym_class == LOC_CONST_BYTES\n-\t      || sym_class == LOC_REGISTER)\n-\t    error (_(\"Attempt to take address of register or constant.\"));\n-\n-\t  return\n-\t    value_zero (type, not_lval);\n-\t}\n-      else\n-\treturn address_of_variable (var, exp->elts[pc + 1].block);\n-\n-    case OP_VAR_MSYM_VALUE:\n-      {\n-\t(*pos) += 4;\n-\n-\tvalue *val = evaluate_var_msym_value (noside,\n-\t\t\t\t\t      exp->elts[pc + 1].objfile,\n-\t\t\t\t\t      exp->elts[pc + 2].msymbol);\n-\tif (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t  {\n-\t    struct type *type = lookup_pointer_type (value_type (val));\n-\t    return value_zero (type, not_lval);\n-\t  }\n-\telse\n-\t  return value_addr (val);\n-      }\n-\n-    case OP_SCOPE:\n-      tem = longest_to_int (exp->elts[pc + 2].longconst);\n-      (*pos) += 5 + BYTES_TO_EXP_ELEM (tem + 1);\n-      x = value_aggregate_elt (exp->elts[pc + 1].type,\n-\t\t\t       &exp->elts[pc + 3].string,\n-\t\t\t       NULL, 1, noside);\n-      if (x == NULL)\n-\terror (_(\"There is no field named %s\"), &exp->elts[pc + 3].string);\n-      return x;\n-\n-    default:\n-    default_case:\n-      x = evaluate_subexp (nullptr, exp, pos, noside);\n-    default_case_after_eval:\n-      return evaluate_subexp_for_address_base (exp, noside, x);\n-    }\n-}\n-\n namespace expr\n {\n \n@@ -4019,51 +2641,6 @@ unop_memval_type_operation::evaluate_for_address (struct expression *exp,\n \n }\n \n-/* Evaluate like `evaluate_subexp' except coercing arrays to pointers.\n-   When used in contexts where arrays will be coerced anyway, this is\n-   equivalent to `evaluate_subexp' but much faster because it avoids\n-   actually fetching array contents (perhaps obsolete now that we have\n-   value_lazy()).\n-\n-   Note that we currently only do the coercion for C expressions, where\n-   arrays are zero based and the coercion is correct.  For other languages,\n-   with nonzero based arrays, coercion loses.  Use CAST_IS_CONVERSION\n-   to decide if coercion is appropriate.  */\n-\n-struct value *\n-evaluate_subexp_with_coercion (struct expression *exp,\n-\t\t\t       int *pos, enum noside noside)\n-{\n-  enum exp_opcode op;\n-  int pc;\n-  struct value *val;\n-  struct symbol *var;\n-  struct type *type;\n-\n-  pc = (*pos);\n-  op = exp->elts[pc].opcode;\n-\n-  switch (op)\n-    {\n-    case OP_VAR_VALUE:\n-      var = exp->elts[pc + 2].symbol;\n-      type = check_typedef (SYMBOL_TYPE (var));\n-      if (type->code () == TYPE_CODE_ARRAY\n-\t  && !type->is_vector ()\n-\t  && CAST_IS_CONVERSION (exp->language_defn))\n-\t{\n-\t  (*pos) += 4;\n-\t  val = address_of_variable (var, exp->elts[pc + 1].block);\n-\t  return value_cast (lookup_pointer_type (TYPE_TARGET_TYPE (type)),\n-\t\t\t     val);\n-\t}\n-      /* FALLTHROUGH */\n-\n-    default:\n-      return evaluate_subexp (nullptr, exp, pos, noside);\n-    }\n-}\n-\n namespace expr\n {\n \n@@ -4129,132 +2706,6 @@ evaluate_subexp_for_sizeof_base (struct expression *exp, struct type *type)\n   return value_from_longest (size_type, (LONGEST) TYPE_LENGTH (type));\n }\n \n-/* Evaluate a subexpression of EXP, at index *POS,\n-   and return a value for the size of that subexpression.\n-   Advance *POS over the subexpression.  If NOSIDE is EVAL_NORMAL\n-   we allow side-effects on the operand if its type is a variable\n-   length array.   */\n-\n-static struct value *\n-evaluate_subexp_for_sizeof (struct expression *exp, int *pos,\n-\t\t\t    enum noside noside)\n-{\n-  /* FIXME: This should be size_t.  */\n-  struct type *size_type = builtin_type (exp->gdbarch)->builtin_int;\n-  enum exp_opcode op;\n-  int pc;\n-  struct type *type;\n-  struct value *val;\n-\n-  pc = (*pos);\n-  op = exp->elts[pc].opcode;\n-\n-  switch (op)\n-    {\n-      /* This case is handled specially\n-\t so that we avoid creating a value for the result type.\n-\t If the result type is very big, it's desirable not to\n-\t create a value unnecessarily.  */\n-    case UNOP_IND:\n-      (*pos)++;\n-      val = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      type = check_typedef (value_type (val));\n-      if (type->code () != TYPE_CODE_PTR\n-\t  && !TYPE_IS_REFERENCE (type)\n-\t  && type->code () != TYPE_CODE_ARRAY)\n-\terror (_(\"Attempt to take contents of a non-pointer value.\"));\n-      type = TYPE_TARGET_TYPE (type);\n-      if (is_dynamic_type (type))\n-\ttype = value_type (value_ind (val));\n-      return value_from_longest (size_type, (LONGEST) TYPE_LENGTH (type));\n-\n-    case UNOP_MEMVAL:\n-      (*pos) += 3;\n-      type = exp->elts[pc + 1].type;\n-      break;\n-\n-    case UNOP_MEMVAL_TYPE:\n-      (*pos) += 1;\n-      val = evaluate_subexp (NULL, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      type = value_type (val);\n-      break;\n-\n-    case OP_VAR_VALUE:\n-      type = SYMBOL_TYPE (exp->elts[pc + 2].symbol);\n-      if (is_dynamic_type (type))\n-\t{\n-\t  val = evaluate_subexp (nullptr, exp, pos, EVAL_NORMAL);\n-\t  type = value_type (val);\n-\t  if (type->code () == TYPE_CODE_ARRAY)\n-\t    {\n-\t      if (type_not_allocated (type) || type_not_associated (type))\n-\t\treturn value_zero (size_type, not_lval);\n-\t      else if (is_dynamic_type (type->index_type ())\n-\t\t       && type->bounds ()->high.kind () == PROP_UNDEFINED)\n-\t\treturn allocate_optimized_out_value (size_type);\n-\t    }\n-\t}\n-      else\n-\t(*pos) += 4;\n-      break;\n-\n-    case OP_VAR_MSYM_VALUE:\n-      {\n-\t(*pos) += 4;\n-\n-\tminimal_symbol *msymbol = exp->elts[pc + 2].msymbol;\n-\tvalue *mval = evaluate_var_msym_value (noside,\n-\t\t\t\t\t       exp->elts[pc + 1].objfile,\n-\t\t\t\t\t       msymbol);\n-\n-\ttype = value_type (mval);\n-\tif (type->code () == TYPE_CODE_ERROR)\n-\t  error_unknown_type (msymbol->print_name ());\n-\n-\treturn value_from_longest (size_type, TYPE_LENGTH (type));\n-      }\n-      break;\n-\n-      /* Deal with the special case if NOSIDE is EVAL_NORMAL and the resulting\n-\t type of the subscript is a variable length array type. In this case we\n-\t must re-evaluate the right hand side of the subscription to allow\n-\t side-effects. */\n-    case BINOP_SUBSCRIPT:\n-      if (noside == EVAL_NORMAL)\n-\t{\n-\t  int npc = (*pos) + 1;\n-\n-\t  val = evaluate_subexp (nullptr, exp, &npc, EVAL_AVOID_SIDE_EFFECTS);\n-\t  type = check_typedef (value_type (val));\n-\t  if (type->code () == TYPE_CODE_ARRAY)\n-\t    {\n-\t      type = check_typedef (TYPE_TARGET_TYPE (type));\n-\t      if (type->code () == TYPE_CODE_ARRAY)\n-\t\t{\n-\t\t  type = type->index_type ();\n-\t\t  /* Only re-evaluate the right hand side if the resulting type\n-\t\t     is a variable length type.  */\n-\t\t  if (type->bounds ()->flag_bound_evaluated)\n-\t\t    {\n-\t\t      val = evaluate_subexp (nullptr, exp, pos, EVAL_NORMAL);\n-\t\t      return value_from_longest\n-\t\t\t(size_type, (LONGEST) TYPE_LENGTH (value_type (val)));\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Fall through.  */\n-\n-    default:\n-      val = evaluate_subexp (nullptr, exp, pos, EVAL_AVOID_SIDE_EFFECTS);\n-      type = value_type (val);\n-      break;\n-    }\n-\n-  return evaluate_subexp_for_sizeof_base (exp, type);\n-}\n-\n namespace expr\n {\n \n@@ -4377,61 +2828,6 @@ var_value_operation::evaluate_for_sizeof (struct expression *exp,\n \n }\n \n-/* Evaluate a subexpression of EXP, at index *POS, and return a value\n-   for that subexpression cast to TO_TYPE.  Advance *POS over the\n-   subexpression.  */\n-\n-static value *\n-evaluate_subexp_for_cast (expression *exp, int *pos,\n-\t\t\t  enum noside noside,\n-\t\t\t  struct type *to_type)\n-{\n-  int pc = *pos;\n-\n-  /* Don't let symbols be evaluated with evaluate_subexp because that\n-     throws an \"unknown type\" error for no-debug data symbols.\n-     Instead, we want the cast to reinterpret the symbol.  */\n-  if (exp->elts[pc].opcode == OP_VAR_MSYM_VALUE\n-      || exp->elts[pc].opcode == OP_VAR_VALUE)\n-    {\n-      (*pos) += 4;\n-\n-      value *val;\n-      if (exp->elts[pc].opcode == OP_VAR_MSYM_VALUE)\n-\t{\n-\t  if (noside == EVAL_AVOID_SIDE_EFFECTS)\n-\t    return value_zero (to_type, not_lval);\n-\n-\t  val = evaluate_var_msym_value (noside,\n-\t\t\t\t\t exp->elts[pc + 1].objfile,\n-\t\t\t\t\t exp->elts[pc + 2].msymbol);\n-\t}\n-      else\n-\tval = evaluate_var_value (noside,\n-\t\t\t\t  exp->elts[pc + 1].block,\n-\t\t\t\t  exp->elts[pc + 2].symbol);\n-\n-      if (noside == EVAL_SKIP)\n-\treturn eval_skip_value (exp);\n-\n-      val = value_cast (to_type, val);\n-\n-      /* Don't allow e.g. '&(int)var_with_no_debug_info'.  */\n-      if (VALUE_LVAL (val) == lval_memory)\n-\t{\n-\t  if (value_lazy (val))\n-\t    value_fetch_lazy (val);\n-\t  VALUE_LVAL (val) = not_lval;\n-\t}\n-      return val;\n-    }\n-\n-  value *val = evaluate_subexp (to_type, exp, pos, noside);\n-  if (noside == EVAL_SKIP)\n-    return eval_skip_value (exp);\n-  return value_cast (to_type, val);\n-}\n-\n namespace expr\n {\n \n@@ -4501,15 +2897,9 @@ parse_and_eval_type (const char *p, int length)\n   tmp[length + 2] = '0';\n   tmp[length + 3] = '\\0';\n   expression_up expr = parse_expression (tmp);\n-  if (expr->first_opcode () != UNOP_CAST)\n+  expr::unop_cast_operation *op\n+    = dynamic_cast<expr::unop_cast_operation *> (expr->op.get ());\n+  if (op == nullptr)\n     error (_(\"Internal error in eval_type.\"));\n-\n-  if (expr->op != nullptr)\n-    {\n-      expr::unop_cast_operation *op\n-\t= dynamic_cast<expr::unop_cast_operation *> (expr->op.get ());\n-      return op->get_type ();\n-    }\n-\n-  return expr->elts[1].type;\n+  return op->get_type ();\n }"
    },
    {
      "sha": "49919e815fe235ec27550f9e05f1d2831b701d7a",
      "filename": "gdb/expprint.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1116,
      "changes": 1117,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/expprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/expprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expprint.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -36,661 +36,6 @@\n \n #include <ctype.h>\n \n-void\n-print_expression (struct expression *exp, struct ui_file *stream)\n-{\n-  int pc = 0;\n-\n-  print_subexp (exp, &pc, stream, PREC_NULL);\n-}\n-\n-/* Print the subexpression of EXP that starts in position POS, on STREAM.\n-   PREC is the precedence of the surrounding operator;\n-   if the precedence of the main operator of this subexpression is less,\n-   parentheses are needed here.  */\n-\n-void\n-print_subexp (struct expression *exp, int *pos,\n-\t      struct ui_file *stream, enum precedence prec)\n-{\n-  exp->language_defn->expression_ops ()->print_subexp (exp, pos, stream,\n-\t\t\t\t\t\t       prec);\n-}\n-\n-/* See parser-defs.h.  */\n-\n-void\n-print_subexp_funcall (struct expression *exp, int *pos,\n-\t\t      struct ui_file *stream)\n-{\n-  unsigned nargs = longest_to_int (exp->elts[*pos].longconst);\n-  (*pos) += 2;\n-  print_subexp (exp, pos, stream, PREC_SUFFIX);\n-  fputs_filtered (\" (\", stream);\n-  for (unsigned tem = 0; tem < nargs; tem++)\n-    {\n-      if (tem != 0)\n-\tfputs_filtered (\", \", stream);\n-      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-    }\n-  fputs_filtered (\")\", stream);\n-}\n-\n-/* Standard implementation of print_subexp for use in language_defn\n-   vectors.  */\n-void\n-print_subexp_standard (struct expression *exp, int *pos,\n-\t\t       struct ui_file *stream, enum precedence prec)\n-{\n-  unsigned tem;\n-  const struct op_print *op_print_tab;\n-  int pc;\n-  unsigned nargs;\n-  const char *op_str;\n-  int assign_modify = 0;\n-  enum exp_opcode opcode;\n-  enum precedence myprec = PREC_NULL;\n-  /* Set to 1 for a right-associative operator.  */\n-  int assoc = 0;\n-  struct value *val;\n-  char *tempstr = NULL;\n-\n-  op_print_tab = exp->language_defn->opcode_print_table ();\n-  pc = (*pos)++;\n-  opcode = exp->elts[pc].opcode;\n-  switch (opcode)\n-    {\n-      /* Common ops */\n-\n-    case OP_TYPE:\n-      (*pos) += 2;\n-      type_print (exp->elts[pc + 1].type, \"\", stream, 0);\n-      return;\n-\n-    case OP_SCOPE:\n-      myprec = PREC_PREFIX;\n-      assoc = 0;\n-      fputs_filtered (exp->elts[pc + 1].type->name (), stream);\n-      fputs_filtered (\"::\", stream);\n-      nargs = longest_to_int (exp->elts[pc + 2].longconst);\n-      (*pos) += 4 + BYTES_TO_EXP_ELEM (nargs + 1);\n-      fputs_filtered (&exp->elts[pc + 3].string, stream);\n-      return;\n-\n-    case OP_LONG:\n-      {\n-\tstruct value_print_options opts;\n-\n-\tget_no_prettyformat_print_options (&opts);\n-\t(*pos) += 3;\n-\tvalue_print (value_from_longest (exp->elts[pc + 1].type,\n-\t\t\t\t\t exp->elts[pc + 2].longconst),\n-\t\t     stream, &opts);\n-      }\n-      return;\n-\n-    case OP_FLOAT:\n-      {\n-\tstruct value_print_options opts;\n-\n-\tget_no_prettyformat_print_options (&opts);\n-\t(*pos) += 3;\n-\tvalue_print (value_from_contents (exp->elts[pc + 1].type,\n-\t\t\t\t\t  exp->elts[pc + 2].floatconst),\n-\t\t     stream, &opts);\n-      }\n-      return;\n-\n-    case OP_VAR_VALUE:\n-      {\n-\tconst struct block *b;\n-\n-\t(*pos) += 3;\n-\tb = exp->elts[pc + 1].block;\n-\tif (b != NULL\n-\t    && BLOCK_FUNCTION (b) != NULL\n-\t    && BLOCK_FUNCTION (b)->print_name () != NULL)\n-\t  {\n-\t    fputs_filtered (BLOCK_FUNCTION (b)->print_name (), stream);\n-\t    fputs_filtered (\"::\", stream);\n-\t  }\n-\tfputs_filtered (exp->elts[pc + 2].symbol->print_name (), stream);\n-      }\n-      return;\n-\n-    case OP_VAR_MSYM_VALUE:\n-      {\n-\t(*pos) += 3;\n-\tfputs_filtered (exp->elts[pc + 2].msymbol->print_name (), stream);\n-      }\n-      return;\n-\n-    case OP_FUNC_STATIC_VAR:\n-      {\n-\ttem = longest_to_int (exp->elts[pc + 1].longconst);\n-\t(*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-\tfputs_filtered (&exp->elts[pc + 1].string, stream);\n-      }\n-      return;\n-\n-    case OP_VAR_ENTRY_VALUE:\n-      {\n-\t(*pos) += 2;\n-\tfprintf_filtered (stream, \"%s@entry\",\n-\t\t\t  exp->elts[pc + 1].symbol->print_name ());\n-      }\n-      return;\n-\n-    case OP_LAST:\n-      (*pos) += 2;\n-      fprintf_filtered (stream, \"$%d\",\n-\t\t\tlongest_to_int (exp->elts[pc + 1].longconst));\n-      return;\n-\n-    case OP_REGISTER:\n-      {\n-\tconst char *name = &exp->elts[pc + 2].string;\n-\n-\t(*pos) += 3 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);\n-\tfprintf_filtered (stream, \"$%s\", name);\n-\treturn;\n-      }\n-\n-    case OP_BOOL:\n-      (*pos) += 2;\n-      fprintf_filtered (stream, \"%s\",\n-\t\t\tlongest_to_int (exp->elts[pc + 1].longconst)\n-\t\t\t? \"TRUE\" : \"FALSE\");\n-      return;\n-\n-    case OP_INTERNALVAR:\n-      (*pos) += 2;\n-      fprintf_filtered (stream, \"$%s\",\n-\t\t\tinternalvar_name (exp->elts[pc + 1].internalvar));\n-      return;\n-\n-    case OP_FUNCALL:\n-      print_subexp_funcall (exp, pos, stream);\n-      return;\n-\n-    case OP_NAME:\n-      nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (nargs + 1);\n-      fputs_filtered (&exp->elts[pc + 2].string, stream);\n-      return;\n-\n-    case OP_STRING:\n-      {\n-\tstruct value_print_options opts;\n-\n-\tnargs = longest_to_int (exp->elts[pc + 1].longconst);\n-\t(*pos) += 3 + BYTES_TO_EXP_ELEM (nargs + 1);\n-\t/* LA_PRINT_STRING will print using the current repeat count threshold.\n-\t   If necessary, we can temporarily set it to zero, or pass it as an\n-\t   additional parameter to LA_PRINT_STRING.  -fnf */\n-\tget_user_print_options (&opts);\n-\texp->language_defn\n-\t  ->printstr (stream, builtin_type (exp->gdbarch)->builtin_char,\n-\t\t      (gdb_byte *) &exp->elts[pc + 2].string, nargs,\n-\t\t      NULL, 0, &opts);\n-      }\n-      return;\n-\n-    case OP_OBJC_NSSTRING:\t/* Objective-C Foundation Class\n-\t\t\t\t   NSString constant.  */\n-      {\n-\tstruct value_print_options opts;\n-\n-\tnargs = longest_to_int (exp->elts[pc + 1].longconst);\n-\t(*pos) += 3 + BYTES_TO_EXP_ELEM (nargs + 1);\n-\tfputs_filtered (\"@\\\"\", stream);\n-\tget_user_print_options (&opts);\n-\texp->language_defn\n-\t  ->printstr (stream, builtin_type (exp->gdbarch)->builtin_char,\n-\t\t      (gdb_byte *) &exp->elts[pc + 2].string, nargs,\n-\t\t      NULL, 0, &opts);\n-\tfputs_filtered (\"\\\"\", stream);\n-      }\n-      return;\n-\n-    case OP_OBJC_MSGCALL:\n-      {\t\t\t/* Objective C message (method) call.  */\n-\t(*pos) += 3;\n-\tnargs = longest_to_int (exp->elts[pc + 2].longconst);\n-\tfprintf_unfiltered (stream, \"[\");\n-\tprint_subexp (exp, pos, stream, PREC_SUFFIX);\n-\tgdb::unique_xmalloc_ptr<char> selector\n-\t  = target_read_string (exp->elts[pc + 1].longconst, 1024);\n-\tif (selector == nullptr)\n-\t  error (_(\"bad selector\"));\n-\tif (nargs)\n-\t  {\n-\t    char *s, *nextS;\n-\n-\t    s = selector.get ();\n-\t    for (tem = 0; tem < nargs; tem++)\n-\t      {\n-\t\tnextS = strchr (s, ':');\n-\t\tgdb_assert (nextS);\t/* Make sure we found ':'.  */\n-\t\t*nextS = '\\0';\n-\t\tfprintf_unfiltered (stream, \" %s: \", s);\n-\t\ts = nextS + 1;\n-\t\tprint_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    fprintf_unfiltered (stream, \" %s\", selector.get ());\n-\t  }\n-\tfprintf_unfiltered (stream, \"]\");\n-\treturn;\n-      }\n-\n-    case OP_ARRAY:\n-      (*pos) += 3;\n-      nargs = longest_to_int (exp->elts[pc + 2].longconst);\n-      nargs -= longest_to_int (exp->elts[pc + 1].longconst);\n-      nargs++;\n-      tem = 0;\n-      if (exp->elts[pc + 4].opcode == OP_LONG\n-\t  && exp->elts[pc + 5].type\n-\t     == builtin_type (exp->gdbarch)->builtin_char\n-\t  && exp->language_defn->la_language == language_c)\n-\t{\n-\t  /* Attempt to print C character arrays using string syntax.\n-\t     Walk through the args, picking up one character from each\n-\t     of the OP_LONG expression elements.  If any array element\n-\t     does not match our expection of what we should find for\n-\t     a simple string, revert back to array printing.  Note that\n-\t     the last expression element is an explicit null terminator\n-\t     byte, which doesn't get printed.  */\n-\t  tempstr = (char *) alloca (nargs);\n-\t  pc += 4;\n-\t  while (tem < nargs)\n-\t    {\n-\t      if (exp->elts[pc].opcode != OP_LONG\n-\t\t  || exp->elts[pc + 1].type\n-\t\t     != builtin_type (exp->gdbarch)->builtin_char)\n-\t\t{\n-\t\t  /* Not a simple array of char, use regular array\n-\t\t     printing.  */\n-\t\t  tem = 0;\n-\t\t  break;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  tempstr[tem++] =\n-\t\t    longest_to_int (exp->elts[pc + 2].longconst);\n-\t\t  pc += 4;\n-\t\t}\n-\t    }\n-\t}\n-      if (tem > 0)\n-\t{\n-\t  struct value_print_options opts;\n-\n-\t  get_user_print_options (&opts);\n-\t  exp->language_defn\n-\t    ->printstr (stream, builtin_type (exp->gdbarch)->builtin_char,\n-\t\t\t(gdb_byte *) tempstr, nargs - 1, NULL, 0, &opts);\n-\t  (*pos) = pc;\n-\t}\n-      else\n-\t{\n-\t  fputs_filtered (\" {\", stream);\n-\t  for (tem = 0; tem < nargs; tem++)\n-\t    {\n-\t      if (tem != 0)\n-\t\t{\n-\t\t  fputs_filtered (\", \", stream);\n-\t\t}\n-\t      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-\t    }\n-\t  fputs_filtered (\"}\", stream);\n-\t}\n-      return;\n-\n-    case TERNOP_COND:\n-      if ((int) prec > (int) PREC_COMMA)\n-\tfputs_filtered (\"(\", stream);\n-      /* Print the subexpressions, forcing parentheses\n-\t around any binary operations within them.\n-\t This is more parentheses than are strictly necessary,\n-\t but it looks clearer.  */\n-      print_subexp (exp, pos, stream, PREC_HYPER);\n-      fputs_filtered (\" ? \", stream);\n-      print_subexp (exp, pos, stream, PREC_HYPER);\n-      fputs_filtered (\" : \", stream);\n-      print_subexp (exp, pos, stream, PREC_HYPER);\n-      if ((int) prec > (int) PREC_COMMA)\n-\tfputs_filtered (\")\", stream);\n-      return;\n-\n-    case TERNOP_SLICE:\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\"(\", stream);\n-      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-      fputs_filtered (opcode == TERNOP_SLICE ? \" : \" : \" UP \", stream);\n-      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-      fputs_filtered (\")\", stream);\n-      return;\n-\n-    case STRUCTOP_STRUCT:\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\".\", stream);\n-      fputs_filtered (&exp->elts[pc + 2].string, stream);\n-      return;\n-\n-      /* Will not occur for Modula-2.  */\n-    case STRUCTOP_PTR:\n-      tem = longest_to_int (exp->elts[pc + 1].longconst);\n-      (*pos) += 3 + BYTES_TO_EXP_ELEM (tem + 1);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\"->\", stream);\n-      fputs_filtered (&exp->elts[pc + 2].string, stream);\n-      return;\n-\n-    case STRUCTOP_MEMBER:\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\".*\", stream);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      return;\n-\n-    case STRUCTOP_MPTR:\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\"->*\", stream);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      return;\n-\n-    case BINOP_SUBSCRIPT:\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\"[\", stream);\n-      print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-      fputs_filtered (\"]\", stream);\n-      return;\n-\n-    case UNOP_POSTINCREMENT:\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\"++\", stream);\n-      return;\n-\n-    case UNOP_POSTDECREMENT:\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fputs_filtered (\"--\", stream);\n-      return;\n-\n-    case UNOP_CAST:\n-      (*pos) += 2;\n-      if ((int) prec > (int) PREC_PREFIX)\n-\tfputs_filtered (\"(\", stream);\n-      fputs_filtered (\"(\", stream);\n-      type_print (exp->elts[pc + 1].type, \"\", stream, 0);\n-      fputs_filtered (\") \", stream);\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      if ((int) prec > (int) PREC_PREFIX)\n-\tfputs_filtered (\")\", stream);\n-      return;\n-\n-    case UNOP_CAST_TYPE:\n-      if ((int) prec > (int) PREC_PREFIX)\n-\tfputs_filtered (\"(\", stream);\n-      fputs_filtered (\"(\", stream);\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      fputs_filtered (\") \", stream);\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      if ((int) prec > (int) PREC_PREFIX)\n-\tfputs_filtered (\")\", stream);\n-      return;\n-\n-    case UNOP_DYNAMIC_CAST:\n-    case UNOP_REINTERPRET_CAST:\n-      fputs_filtered (opcode == UNOP_DYNAMIC_CAST ? \"dynamic_cast\"\n-\t\t      : \"reinterpret_cast\", stream);\n-      fputs_filtered (\"<\", stream);\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      fputs_filtered (\"> (\", stream);\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      fputs_filtered (\")\", stream);\n-      return;\n-\n-    case UNOP_MEMVAL:\n-      (*pos) += 2;\n-      if ((int) prec > (int) PREC_PREFIX)\n-\tfputs_filtered (\"(\", stream);\n-      if (exp->elts[pc + 1].type->code () == TYPE_CODE_FUNC\n-\t  && exp->elts[pc + 3].opcode == OP_LONG)\n-\t{\n-\t  struct value_print_options opts;\n-\n-\t  /* We have a minimal symbol fn, probably.  It's encoded\n-\t     as a UNOP_MEMVAL (function-type) of an OP_LONG (int, address).\n-\t     Swallow the OP_LONG (including both its opcodes); ignore\n-\t     its type; print the value in the type of the MEMVAL.  */\n-\t  (*pos) += 4;\n-\t  val = value_at_lazy (exp->elts[pc + 1].type,\n-\t\t\t       (CORE_ADDR) exp->elts[pc + 5].longconst);\n-\t  get_no_prettyformat_print_options (&opts);\n-\t  value_print (val, stream, &opts);\n-\t}\n-      else\n-\t{\n-\t  fputs_filtered (\"{\", stream);\n-\t  type_print (exp->elts[pc + 1].type, \"\", stream, 0);\n-\t  fputs_filtered (\"} \", stream);\n-\t  print_subexp (exp, pos, stream, PREC_PREFIX);\n-\t}\n-      if ((int) prec > (int) PREC_PREFIX)\n-\tfputs_filtered (\")\", stream);\n-      return;\n-\n-    case UNOP_MEMVAL_TYPE:\n-      if ((int) prec > (int) PREC_PREFIX)\n-\tfputs_filtered (\"(\", stream);\n-      fputs_filtered (\"{\", stream);\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      fputs_filtered (\"} \", stream);\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      if ((int) prec > (int) PREC_PREFIX)\n-\tfputs_filtered (\")\", stream);\n-      return;\n-\n-    case BINOP_ASSIGN_MODIFY:\n-      opcode = exp->elts[pc + 1].opcode;\n-      (*pos) += 2;\n-      myprec = PREC_ASSIGN;\n-      assoc = 1;\n-      assign_modify = 1;\n-      op_str = \"???\";\n-      for (tem = 0; op_print_tab[tem].opcode != OP_NULL; tem++)\n-\tif (op_print_tab[tem].opcode == opcode)\n-\t  {\n-\t    op_str = op_print_tab[tem].string;\n-\t    break;\n-\t  }\n-      if (op_print_tab[tem].opcode != opcode)\n-\t/* Not found; don't try to keep going because we don't know how\n-\t   to interpret further elements.  */\n-\terror (_(\"Invalid expression\"));\n-      break;\n-\n-      /* C++ ops */\n-\n-    case OP_THIS:\n-      ++(*pos);\n-      if (exp->language_defn->name_of_this () != NULL)\n-\tfputs_filtered (exp->language_defn->name_of_this (), stream);\n-      else\n-\tfprintf_styled (stream, metadata_style.style (),\n-\t\t\t_(\"<language %s has no 'this'>\"),\n-\t\t\texp->language_defn->name ());\n-      return;\n-\n-      /* Modula-2 ops */\n-\n-    case MULTI_SUBSCRIPT:\n-      (*pos) += 2;\n-      nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-      print_subexp (exp, pos, stream, PREC_SUFFIX);\n-      fprintf_unfiltered (stream, \" [\");\n-      for (tem = 0; tem < nargs; tem++)\n-\t{\n-\t  if (tem != 0)\n-\t    fprintf_unfiltered (stream, \", \");\n-\t  print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-\t}\n-      fprintf_unfiltered (stream, \"]\");\n-      return;\n-\n-    case BINOP_VAL:\n-      (*pos) += 2;\n-      fprintf_unfiltered (stream, \"VAL(\");\n-      type_print (exp->elts[pc + 1].type, \"\", stream, 0);\n-      fprintf_unfiltered (stream, \",\");\n-      print_subexp (exp, pos, stream, PREC_PREFIX);\n-      fprintf_unfiltered (stream, \")\");\n-      return;\n-\n-    case TYPE_INSTANCE:\n-      {\n-\ttype_instance_flags flags\n-\t  = (type_instance_flag_value) longest_to_int (exp->elts[pc + 1].longconst);\n-\tLONGEST count = exp->elts[pc + 2].longconst;\n-\n-\t/* The FLAGS.  */\n-\t(*pos)++;\n-\t/* The COUNT.  */\n-\t(*pos)++;\n-\tfputs_unfiltered (\"TypeInstance(\", stream);\n-\twhile (count-- > 0)\n-\t  {\n-\t    type_print (exp->elts[(*pos)++].type, \"\", stream, 0);\n-\t    if (count > 0)\n-\t      fputs_unfiltered (\",\", stream);\n-\t  }\n-\tfputs_unfiltered (\",\", stream);\n-\t/* Ending COUNT and ending TYPE_INSTANCE.  */\n-\t(*pos) += 2;\n-\tprint_subexp (exp, pos, stream, PREC_PREFIX);\n-\n-\tif (flags & TYPE_INSTANCE_FLAG_CONST)\n-\t  fputs_unfiltered (\",const\", stream);\n-\tif (flags & TYPE_INSTANCE_FLAG_VOLATILE)\n-\t  fputs_unfiltered (\",volatile\", stream);\n-\n-\tfputs_unfiltered (\")\", stream);\n-\treturn;\n-      }\n-\n-    case OP_RANGE:\n-      {\n-\tenum range_flag range_flag;\n-\n-\trange_flag = (enum range_flag)\n-\t  longest_to_int (exp->elts[pc + 1].longconst);\n-\t*pos += 2;\n-\n-\tif (range_flag & RANGE_HIGH_BOUND_EXCLUSIVE)\n-\t  fputs_filtered (\"EXCLUSIVE_\", stream);\n-\tfputs_filtered (\"RANGE(\", stream);\n-\tif (!(range_flag & RANGE_LOW_BOUND_DEFAULT))\n-\t  print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-\tfputs_filtered (\"..\", stream);\n-\tif (!(range_flag & RANGE_HIGH_BOUND_DEFAULT))\n-\t  print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n-\tfputs_filtered (\")\", stream);\n-\treturn;\n-      }\n-\n-      /* Default ops */\n-\n-    default:\n-      op_str = \"???\";\n-      for (tem = 0; op_print_tab[tem].opcode != OP_NULL; tem++)\n-\tif (op_print_tab[tem].opcode == opcode)\n-\t  {\n-\t    op_str = op_print_tab[tem].string;\n-\t    myprec = op_print_tab[tem].precedence;\n-\t    assoc = op_print_tab[tem].right_assoc;\n-\t    break;\n-\t  }\n-      if (op_print_tab[tem].opcode != opcode)\n-\t/* Not found; don't try to keep going because we don't know how\n-\t   to interpret further elements.  For example, this happens\n-\t   if opcode is OP_TYPE.  */\n-\terror (_(\"Invalid expression\"));\n-    }\n-\n-  /* Note that PREC_BUILTIN will always emit parentheses.  */\n-  if ((int) myprec < (int) prec)\n-    fputs_filtered (\"(\", stream);\n-  if ((int) opcode > (int) BINOP_END)\n-    {\n-      if (assoc)\n-\t{\n-\t  /* Unary postfix operator.  */\n-\t  print_subexp (exp, pos, stream, PREC_SUFFIX);\n-\t  fputs_filtered (op_str, stream);\n-\t}\n-      else\n-\t{\n-\t  /* Unary prefix operator.  */\n-\t  fputs_filtered (op_str, stream);\n-\t  if (myprec == PREC_BUILTIN_FUNCTION)\n-\t    fputs_filtered (\"(\", stream);\n-\t  print_subexp (exp, pos, stream, PREC_PREFIX);\n-\t  if (myprec == PREC_BUILTIN_FUNCTION)\n-\t    fputs_filtered (\")\", stream);\n-\t}\n-    }\n-  else\n-    {\n-      /* Binary operator.  */\n-      /* Print left operand.\n-\t If operator is right-associative,\n-\t increment precedence for this operand.  */\n-      print_subexp (exp, pos, stream,\n-\t\t    (enum precedence) ((int) myprec + assoc));\n-      /* Print the operator itself.  */\n-      if (assign_modify)\n-\tfprintf_filtered (stream, \" %s= \", op_str);\n-      else if (op_str[0] == ',')\n-\tfprintf_filtered (stream, \"%s \", op_str);\n-      else\n-\tfprintf_filtered (stream, \" %s \", op_str);\n-      /* Print right operand.\n-\t If operator is left-associative,\n-\t increment precedence for this operand.  */\n-      print_subexp (exp, pos, stream,\n-\t\t    (enum precedence) ((int) myprec + !assoc));\n-    }\n-\n-  if ((int) myprec < (int) prec)\n-    fputs_filtered (\")\", stream);\n-}\n-\n-/* Return the operator corresponding to opcode OP as\n-   a string.   NULL indicates that the opcode was not found in the\n-   current language table.  */\n-const char *\n-op_string (enum exp_opcode op)\n-{\n-  int tem;\n-  const struct op_print *op_print_tab;\n-\n-  op_print_tab = current_language->opcode_print_table ();\n-  for (tem = 0; op_print_tab[tem].opcode != OP_NULL; tem++)\n-    if (op_print_tab[tem].opcode == op)\n-      return op_print_tab[tem].string;\n-  return NULL;\n-}\n-\n-/* Support for dumping the raw data from expressions in a human readable\n-   form.  */\n-\n-static int dump_subexp_body (struct expression *exp, struct ui_file *, int);\n-\n /* Default name for the standard operator OPCODE (i.e., one defined in\n    the definition of enum exp_opcode).  */\n \n@@ -714,470 +59,10 @@ op_name (enum exp_opcode opcode)\n     }\n }\n \n-/* Print a raw dump of expression EXP to STREAM.\n-   NOTE, if non-NULL, is printed as extra explanatory text.  */\n-\n-void\n-dump_raw_expression (struct expression *exp, struct ui_file *stream,\n-\t\t     const char *note)\n-{\n-  int elt;\n-  char *eltscan;\n-  int eltsize;\n-\n-  if (exp->op != nullptr)\n-    return;\n-\n-  fprintf_filtered (stream, \"Dump of expression @ \");\n-  gdb_print_host_address (exp, stream);\n-  if (note)\n-    fprintf_filtered (stream, \", %s:\", note);\n-  fprintf_filtered (stream, \"\\n\\tLanguage %s, %d elements, %ld bytes each.\\n\",\n-\t\t    exp->language_defn->name (), exp->nelts,\n-\t\t    (long) sizeof (union exp_element));\n-  fprintf_filtered (stream, \"\\t%5s  %20s  %16s  %s\\n\", \"Index\", \"Opcode\",\n-\t\t    \"Hex Value\", \"String Value\");\n-  for (elt = 0; elt < exp->nelts; elt++)\n-    {\n-      fprintf_filtered (stream, \"\\t%5d  \", elt);\n-\n-      const char *opcode_name = op_name (exp->elts[elt].opcode);\n-      fprintf_filtered (stream, \"%20s  \", opcode_name);\n-\n-      print_longest (stream, 'd', 0, exp->elts[elt].longconst);\n-      fprintf_filtered (stream, \"  \");\n-\n-      for (eltscan = (char *) &exp->elts[elt],\n-\t   eltsize = sizeof (union exp_element);\n-\t   eltsize-- > 0;\n-\t   eltscan++)\n-\t{\n-\t  fprintf_filtered (stream, \"%c\",\n-\t\t\t    isprint (*eltscan) ? (*eltscan & 0xFF) : '.');\n-\t}\n-      fprintf_filtered (stream, \"\\n\");\n-    }\n-}\n-\n-/* Dump the subexpression of prefix expression EXP whose operator is at\n-   position ELT onto STREAM.  Returns the position of the next \n-   subexpression in EXP.  */\n-\n-int\n-dump_subexp (struct expression *exp, struct ui_file *stream, int elt)\n-{\n-  static int indent = 0;\n-  int i;\n-\n-  fprintf_filtered (stream, \"\\n\");\n-  fprintf_filtered (stream, \"\\t%5d  \", elt);\n-\n-  for (i = 1; i <= indent; i++)\n-    fprintf_filtered (stream, \" \");\n-  indent += 2;\n-\n-  fprintf_filtered (stream, \"%-20s  \", op_name (exp->elts[elt].opcode));\n-\n-  elt = dump_subexp_body (exp, stream, elt);\n-\n-  indent -= 2;\n-\n-  return elt;\n-}\n-\n-/* Dump the operands of prefix expression EXP whose opcode is at\n-   position ELT onto STREAM.  Returns the position of the next \n-   subexpression in EXP.  */\n-\n-static int\n-dump_subexp_body (struct expression *exp, struct ui_file *stream, int elt)\n-{\n-  return exp->language_defn->expression_ops ()->dump_subexp_body (exp, stream,\n-\t\t\t\t\t\t\t\t  elt);\n-}\n-\n-/* See parser-defs.h.  */\n-\n-int\n-dump_subexp_body_funcall (struct expression *exp,\n-\t\t\t  struct ui_file *stream, int elt)\n-{\n-  int nargs = longest_to_int (exp->elts[elt].longconst);\n-  fprintf_filtered (stream, \"Number of args: %d\", nargs);\n-  elt += 2;\n-\n-  for (int i = 1; i <= nargs + 1; i++)\n-    elt = dump_subexp (exp, stream, elt);\n-\n-  return elt;\n-}\n-\n-/* Default value for subexp_body in exp_descriptor vector.  */\n-\n-int\n-dump_subexp_body_standard (struct expression *exp, \n-\t\t\t   struct ui_file *stream, int elt)\n-{\n-  int opcode = exp->elts[elt++].opcode;\n-\n-  switch (opcode)\n-    {\n-    case TERNOP_COND:\n-    case TERNOP_SLICE:\n-      elt = dump_subexp (exp, stream, elt);\n-      /* FALL THROUGH */\n-    case BINOP_ADD:\n-    case BINOP_SUB:\n-    case BINOP_MUL:\n-    case BINOP_DIV:\n-    case BINOP_REM:\n-    case BINOP_MOD:\n-    case BINOP_LSH:\n-    case BINOP_RSH:\n-    case BINOP_LOGICAL_AND:\n-    case BINOP_LOGICAL_OR:\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-    case BINOP_LESS:\n-    case BINOP_GTR:\n-    case BINOP_LEQ:\n-    case BINOP_GEQ:\n-    case BINOP_REPEAT:\n-    case BINOP_ASSIGN:\n-    case BINOP_COMMA:\n-    case BINOP_SUBSCRIPT:\n-    case BINOP_EXP:\n-    case BINOP_MIN:\n-    case BINOP_MAX:\n-    case BINOP_INTDIV:\n-    case BINOP_ASSIGN_MODIFY:\n-    case BINOP_VAL:\n-    case BINOP_CONCAT:\n-    case BINOP_END:\n-    case STRUCTOP_MEMBER:\n-    case STRUCTOP_MPTR:\n-      elt = dump_subexp (exp, stream, elt);\n-      /* FALL THROUGH */\n-    case UNOP_NEG:\n-    case UNOP_LOGICAL_NOT:\n-    case UNOP_COMPLEMENT:\n-    case UNOP_IND:\n-    case UNOP_ADDR:\n-    case UNOP_PREINCREMENT:\n-    case UNOP_POSTINCREMENT:\n-    case UNOP_PREDECREMENT:\n-    case UNOP_POSTDECREMENT:\n-    case UNOP_SIZEOF:\n-    case UNOP_ALIGNOF:\n-    case UNOP_PLUS:\n-    case UNOP_CAP:\n-    case UNOP_CHR:\n-    case UNOP_ORD:\n-    case UNOP_ABS:\n-    case UNOP_FLOAT:\n-    case UNOP_HIGH:\n-    case UNOP_MAX:\n-    case UNOP_MIN:\n-    case UNOP_ODD:\n-    case UNOP_TRUNC:\n-      elt = dump_subexp (exp, stream, elt);\n-      break;\n-    case OP_LONG:\n-      fprintf_filtered (stream, \"Type @\");\n-      gdb_print_host_address (exp->elts[elt].type, stream);\n-      fprintf_filtered (stream, \" (\");\n-      type_print (exp->elts[elt].type, NULL, stream, 0);\n-      fprintf_filtered (stream, \"), value %ld (0x%lx)\",\n-\t\t\t(long) exp->elts[elt + 1].longconst,\n-\t\t\t(long) exp->elts[elt + 1].longconst);\n-      elt += 3;\n-      break;\n-    case OP_FLOAT:\n-      fprintf_filtered (stream, \"Type @\");\n-      gdb_print_host_address (exp->elts[elt].type, stream);\n-      fprintf_filtered (stream, \" (\");\n-      type_print (exp->elts[elt].type, NULL, stream, 0);\n-      fprintf_filtered (stream, \"), value \");\n-      print_floating (exp->elts[elt + 1].floatconst,\n-\t\t      exp->elts[elt].type, stream);\n-      elt += 3;\n-      break;\n-    case OP_VAR_VALUE:\n-      fprintf_filtered (stream, \"Block @\");\n-      gdb_print_host_address (exp->elts[elt].block, stream);\n-      fprintf_filtered (stream, \", symbol @\");\n-      gdb_print_host_address (exp->elts[elt + 1].symbol, stream);\n-      fprintf_filtered (stream, \" (%s)\",\n-\t\t\texp->elts[elt + 1].symbol->print_name ());\n-      elt += 3;\n-      break;\n-    case OP_VAR_MSYM_VALUE:\n-      fprintf_filtered (stream, \"Objfile @\");\n-      gdb_print_host_address (exp->elts[elt].objfile, stream);\n-      fprintf_filtered (stream, \", msymbol @\");\n-      gdb_print_host_address (exp->elts[elt + 1].msymbol, stream);\n-      fprintf_filtered (stream, \" (%s)\",\n-\t\t\texp->elts[elt + 1].msymbol->print_name ());\n-      elt += 3;\n-      break;\n-    case OP_VAR_ENTRY_VALUE:\n-      fprintf_filtered (stream, \"Entry value of symbol @\");\n-      gdb_print_host_address (exp->elts[elt].symbol, stream);\n-      fprintf_filtered (stream, \" (%s)\",\n-\t\t\texp->elts[elt].symbol->print_name ());\n-      elt += 2;\n-      break;\n-    case OP_LAST:\n-      fprintf_filtered (stream, \"History element %ld\",\n-\t\t\t(long) exp->elts[elt].longconst);\n-      elt += 2;\n-      break;\n-    case OP_REGISTER:\n-      fprintf_filtered (stream, \"Register $%s\", &exp->elts[elt + 1].string);\n-      elt += 3 + BYTES_TO_EXP_ELEM (exp->elts[elt].longconst + 1);\n-      break;\n-    case OP_INTERNALVAR:\n-      fprintf_filtered (stream, \"Internal var @\");\n-      gdb_print_host_address (exp->elts[elt].internalvar, stream);\n-      fprintf_filtered (stream, \" (%s)\",\n-\t\t\tinternalvar_name (exp->elts[elt].internalvar));\n-      elt += 2;\n-      break;\n-    case OP_FUNCALL:\n-      elt = dump_subexp_body_funcall (exp, stream, elt);\n-      break;\n-    case OP_ARRAY:\n-      {\n-\tint lower, upper;\n-\tint i;\n-\n-\tlower = longest_to_int (exp->elts[elt].longconst);\n-\tupper = longest_to_int (exp->elts[elt + 1].longconst);\n-\n-\tfprintf_filtered (stream, \"Bounds [%d:%d]\", lower, upper);\n-\telt += 3;\n-\n-\tfor (i = 1; i <= upper - lower + 1; i++)\n-\t  elt = dump_subexp (exp, stream, elt);\n-      }\n-      break;\n-    case UNOP_DYNAMIC_CAST:\n-    case UNOP_REINTERPRET_CAST:\n-    case UNOP_CAST_TYPE:\n-    case UNOP_MEMVAL_TYPE:\n-      fprintf_filtered (stream, \" (\");\n-      elt = dump_subexp (exp, stream, elt);\n-      fprintf_filtered (stream, \")\");\n-      elt = dump_subexp (exp, stream, elt);\n-      break;\n-    case UNOP_MEMVAL:\n-    case UNOP_CAST:\n-      fprintf_filtered (stream, \"Type @\");\n-      gdb_print_host_address (exp->elts[elt].type, stream);\n-      fprintf_filtered (stream, \" (\");\n-      type_print (exp->elts[elt].type, NULL, stream, 0);\n-      fprintf_filtered (stream, \")\");\n-      elt = dump_subexp (exp, stream, elt + 2);\n-      break;\n-    case OP_TYPE:\n-      fprintf_filtered (stream, \"Type @\");\n-      gdb_print_host_address (exp->elts[elt].type, stream);\n-      fprintf_filtered (stream, \" (\");\n-      type_print (exp->elts[elt].type, NULL, stream, 0);\n-      fprintf_filtered (stream, \")\");\n-      elt += 2;\n-      break;\n-    case OP_TYPEOF:\n-    case OP_DECLTYPE:\n-      fprintf_filtered (stream, \"Typeof (\");\n-      elt = dump_subexp (exp, stream, elt);\n-      fprintf_filtered (stream, \")\");\n-      break;\n-    case OP_TYPEID:\n-      fprintf_filtered (stream, \"typeid (\");\n-      elt = dump_subexp (exp, stream, elt);\n-      fprintf_filtered (stream, \")\");\n-      break;\n-    case STRUCTOP_STRUCT:\n-    case STRUCTOP_PTR:\n-      {\n-\tchar *elem_name;\n-\tint len;\n-\n-\tlen = longest_to_int (exp->elts[elt].longconst);\n-\telem_name = &exp->elts[elt + 1].string;\n-\n-\tfprintf_filtered (stream, \"Element name: `%.*s'\", len, elem_name);\n-\telt = dump_subexp (exp, stream, elt + 3 + BYTES_TO_EXP_ELEM (len + 1));\n-      }\n-      break;\n-    case OP_SCOPE:\n-      {\n-\tchar *elem_name;\n-\tint len;\n-\n-\tfprintf_filtered (stream, \"Type @\");\n-\tgdb_print_host_address (exp->elts[elt].type, stream);\n-\tfprintf_filtered (stream, \" (\");\n-\ttype_print (exp->elts[elt].type, NULL, stream, 0);\n-\tfprintf_filtered (stream, \") \");\n-\n-\tlen = longest_to_int (exp->elts[elt + 1].longconst);\n-\telem_name = &exp->elts[elt + 2].string;\n-\n-\tfprintf_filtered (stream, \"Field name: `%.*s'\", len, elem_name);\n-\telt += 4 + BYTES_TO_EXP_ELEM (len + 1);\n-      }\n-      break;\n-\n-    case OP_FUNC_STATIC_VAR:\n-      {\n-\tint len = longest_to_int (exp->elts[elt].longconst);\n-\tconst char *var_name = &exp->elts[elt + 1].string;\n-\tfprintf_filtered (stream, \"Field name: `%.*s'\", len, var_name);\n-\telt += 3 + BYTES_TO_EXP_ELEM (len + 1);\n-      }\n-      break;\n-\n-    case TYPE_INSTANCE:\n-      {\n-\ttype_instance_flags flags\n-\t  = (type_instance_flag_value) longest_to_int (exp->elts[elt++].longconst);\n-\tLONGEST len = exp->elts[elt++].longconst;\n-\tfprintf_filtered (stream, \"%s TypeInstance: \", plongest (len));\n-\twhile (len-- > 0)\n-\t  {\n-\t    fprintf_filtered (stream, \"Type @\");\n-\t    gdb_print_host_address (exp->elts[elt].type, stream);\n-\t    fprintf_filtered (stream, \" (\");\n-\t    type_print (exp->elts[elt].type, NULL, stream, 0);\n-\t    fprintf_filtered (stream, \")\");\n-\t    elt++;\n-\t    if (len > 0)\n-\t      fputs_filtered (\", \", stream);\n-\t  }\n-\n-\tfprintf_filtered (stream, \" Flags: %s (\", hex_string (flags));\n-\tbool space = false;\n-\tauto print_one = [&] (const char *mod)\n-\t  {\n-\t    if (space)\n-\t      fputs_filtered (\" \", stream);\n-\t    space = true;\n-\t    fprintf_filtered (stream, \"%s\", mod);\n-\t  };\n-\tif (flags & TYPE_INSTANCE_FLAG_CONST)\n-\t  print_one (\"const\");\n-\tif (flags & TYPE_INSTANCE_FLAG_VOLATILE)\n-\t  print_one (\"volatile\");\n-\tfprintf_filtered (stream, \")\");\n-\n-\t/* Ending LEN and ending TYPE_INSTANCE.  */\n-\telt += 2;\n-\telt = dump_subexp (exp, stream, elt);\n-      }\n-      break;\n-    case OP_STRING:\n-      {\n-\tLONGEST len = exp->elts[elt].longconst;\n-\tLONGEST type = exp->elts[elt + 1].longconst;\n-\n-\tfprintf_filtered (stream, \"Language-specific string type: %s\",\n-\t\t\t  plongest (type));\n-\n-\t/* Skip length.  */\n-\telt += 1;\n-\n-\t/* Skip string content. */\n-\telt += BYTES_TO_EXP_ELEM (len);\n-\n-\t/* Skip length and ending OP_STRING. */\n-\telt += 2;\n-      }\n-      break;\n-    case OP_RANGE:\n-      {\n-\tenum range_flag range_flag;\n-\n-\trange_flag = (enum range_flag)\n-\t  longest_to_int (exp->elts[elt].longconst);\n-\telt += 2;\n-\n-\tif (range_flag & RANGE_HIGH_BOUND_EXCLUSIVE)\n-\t  fputs_filtered (\"Exclusive\", stream);\n-\tfputs_filtered (\"Range '\", stream);\n-\tif (!(range_flag & RANGE_LOW_BOUND_DEFAULT))\n-\t  fputs_filtered (\"EXP\", stream);\n-\tfputs_filtered (\"..\", stream);\n-\tif (!(range_flag & RANGE_HIGH_BOUND_DEFAULT))\n-\t  fputs_filtered (\"EXP\", stream);\n-\tif (range_flag & RANGE_HAS_STRIDE)\n-\t  fputs_filtered (\":EXP\", stream);\n-\tfputs_filtered (\"'\", stream);\n-\n-\tif (!(range_flag & RANGE_LOW_BOUND_DEFAULT))\n-\t  elt = dump_subexp (exp, stream, elt);\n-\tif (!(range_flag & RANGE_HIGH_BOUND_DEFAULT))\n-\t  elt = dump_subexp (exp, stream, elt);\n-\tif (range_flag & RANGE_HAS_STRIDE)\n-\t  elt = dump_subexp (exp, stream, elt);\n-      }\n-      break;\n-\n-    case OP_BOOL:\n-      {\n-\tbool val = (bool) (exp->elts[elt].longconst);\n-\tfputs_filtered (val ? \"TRUE\" : \"FALSE\", stream);\n-\telt += 2;\n-      }\n-      break;\n-\n-    default:\n-    case OP_NULL:\n-    case MULTI_SUBSCRIPT:\n-    case OP_COMPLEX:\n-    case OP_M2_STRING:\n-    case OP_THIS:\n-    case OP_NAME:\n-      fprintf_filtered (stream, \"Unknown format\");\n-    }\n-\n-  return elt;\n-}\n-\n void\n dump_prefix_expression (struct expression *exp, struct ui_file *stream)\n {\n-  int elt;\n-\n-  if (exp->op != nullptr)\n-    {\n-      exp->op->dump (stream, 0);\n-      return;\n-    }\n-\n-  fprintf_filtered (stream, \"Dump of expression @ \");\n-  gdb_print_host_address (exp, stream);\n-  fputs_filtered (\", after conversion to prefix form:\\nExpression: `\", stream);\n-\n-  if (exp->op != nullptr)\n-    {\n-      exp->op->dump (stream, 0);\n-      return;\n-    }\n-\n-  print_expression (exp, stream);\n-  fprintf_filtered (stream, \"'\\n\\tLanguage %s, %d elements, %ld bytes each.\\n\",\n-\t\t    exp->language_defn->name (), exp->nelts,\n-\t\t    (long) sizeof (union exp_element));\n-  fputs_filtered (\"\\n\", stream);\n-\n-  for (elt = 0; elt < exp->nelts;)\n-    elt = dump_subexp (exp, stream, elt);\n-  fputs_filtered (\"\\n\", stream);\n+  exp->op->dump (stream, 0);\n }\n \n namespace expr"
    },
    {
      "sha": "31482be11c97ea276e299d3739b827c52123417f",
      "filename": "gdb/expression.h",
      "status": "modified",
      "additions": 2,
      "deletions": 56,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/expression.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/expression.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/expression.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -40,21 +40,6 @@ enum innermost_block_tracker_type\n DEF_ENUM_FLAGS_TYPE (enum innermost_block_tracker_type,\n \t\t     innermost_block_tracker_types);\n \n-/* Definitions for saved C expressions.  */\n-\n-/* An expression is represented as a vector of union exp_element's.\n-   Each exp_element is an opcode, except that some opcodes cause\n-   the following exp_element to be treated as a long or double constant\n-   or as a variable.  The opcodes are obeyed, using a stack for temporaries.\n-   The value is left on the temporary stack at the end.  */\n-\n-/* When it is necessary to include a string,\n-   it can occupy as many exp_elements as it needs.\n-   We find the length of the string using strlen,\n-   divide to find out how many exp_elements are used up,\n-   and skip that many.  Strings, like numbers, are indicated\n-   by the preceding opcode.  */\n-\n enum exp_opcode : uint8_t\n   {\n #define OP(name) name ,\n@@ -212,37 +197,17 @@ make_operation (Arg... args)\n \n }\n \n-union exp_element\n-  {\n-    enum exp_opcode opcode;\n-    struct symbol *symbol;\n-    struct minimal_symbol *msymbol;\n-    LONGEST longconst;\n-    gdb_byte floatconst[16];\n-    /* Really sizeof (union exp_element) characters (or less for the last\n-       element of a string).  */\n-    char string;\n-    struct type *type;\n-    struct internalvar *internalvar;\n-    const struct block *block;\n-    struct objfile *objfile;\n-  };\n-\n struct expression\n {\n-  expression (const struct language_defn *, struct gdbarch *, size_t);\n+  expression (const struct language_defn *, struct gdbarch *);\n   ~expression ();\n   DISABLE_COPY_AND_ASSIGN (expression);\n \n-  void resize (size_t);\n-\n   /* Return the opcode for the outermost sub-expression of this\n      expression.  */\n   enum exp_opcode first_opcode () const\n   {\n-    if (op != nullptr)\n-      return op->opcode ();\n-    return elts[0].opcode;\n+    return op->opcode ();\n   }\n \n   /* Evaluate the expression.  EXPECT_TYPE is the context type of the\n@@ -255,20 +220,10 @@ struct expression\n   /* Architecture it was parsed in.  */\n   struct gdbarch *gdbarch;\n   expr::operation_up op;\n-  int nelts = 0;\n-  union exp_element *elts;\n };\n \n typedef std::unique_ptr<expression> expression_up;\n \n-/* Macros for converting between number of expression elements and bytes\n-   to store that many expression elements.  */\n-\n-#define EXP_ELEM_TO_BYTES(elements) \\\n-    ((elements) * sizeof (union exp_element))\n-#define BYTES_TO_EXP_ELEM(bytes) \\\n-    (((bytes) + sizeof (union exp_element) - 1) / sizeof (union exp_element))\n-\n /* From parse.c */\n \n class innermost_block_tracker;\n@@ -289,9 +244,6 @@ extern expression_up parse_exp_1 (const char **, CORE_ADDR pc,\n \n /* From eval.c */\n \n-extern struct value *evaluate_subexp_standard\n-  (struct type *, struct expression *, int *, enum noside);\n-\n /* Evaluate a function call.  The function to be called is in CALLEE and\n    the arguments passed to the function are in ARGVEC.\n    FUNCTION_NAME is the name of the function, if known.\n@@ -307,14 +259,8 @@ extern struct value *evaluate_subexp_do_call (expression *exp,\n \n /* From expprint.c */\n \n-extern void print_expression (struct expression *, struct ui_file *);\n-\n extern const char *op_name (enum exp_opcode opcode);\n \n-extern const char *op_string (enum exp_opcode);\n-\n-extern void dump_raw_expression (struct expression *,\n-\t\t\t\t struct ui_file *, const char *);\n extern void dump_prefix_expression (struct expression *, struct ui_file *);\n \n /* In an OP_RANGE expression, either bound could be empty, indicating"
    },
    {
      "sha": "a4c210e1b58efdea5b5fd7a42e8f720cc0f4b57c",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 28,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -103,34 +103,6 @@ f_language::get_encoding (struct type *type)\n \n \f\n \n-/* Table of operators and their precedences for printing expressions.  */\n-\n-const struct op_print f_language::op_print_tab[] =\n-{\n-  {\"+\", BINOP_ADD, PREC_ADD, 0},\n-  {\"+\", UNOP_PLUS, PREC_PREFIX, 0},\n-  {\"-\", BINOP_SUB, PREC_ADD, 0},\n-  {\"-\", UNOP_NEG, PREC_PREFIX, 0},\n-  {\"*\", BINOP_MUL, PREC_MUL, 0},\n-  {\"/\", BINOP_DIV, PREC_MUL, 0},\n-  {\"DIV\", BINOP_INTDIV, PREC_MUL, 0},\n-  {\"MOD\", BINOP_REM, PREC_MUL, 0},\n-  {\"=\", BINOP_ASSIGN, PREC_ASSIGN, 1},\n-  {\".OR.\", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},\n-  {\".AND.\", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},\n-  {\".NOT.\", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},\n-  {\".EQ.\", BINOP_EQUAL, PREC_EQUAL, 0},\n-  {\".NE.\", BINOP_NOTEQUAL, PREC_EQUAL, 0},\n-  {\".LE.\", BINOP_LEQ, PREC_ORDER, 0},\n-  {\".GE.\", BINOP_GEQ, PREC_ORDER, 0},\n-  {\".GT.\", BINOP_GTR, PREC_ORDER, 0},\n-  {\".LT.\", BINOP_LESS, PREC_ORDER, 0},\n-  {\"**\", UNOP_IND, PREC_PREFIX, 0},\n-  {\"@\", BINOP_REPEAT, PREC_REPEAT, 0},\n-  {NULL, OP_NULL, PREC_REPEAT, 0}\n-};\n-\f\n-\n /* A helper function for the \"bound\" intrinsics that checks that TYPE\n    is an array.  LBOUND_P is true for lower bound; this is used for\n    the error message, if any.  */"
    },
    {
      "sha": "1ccdd3978eadc9df80e632a29bd1c6fc05860725",
      "filename": "gdb/f-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/f-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/f-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -218,11 +218,6 @@ class f_language : public language_defn\n   enum array_ordering array_ordering () const override\n   { return array_column_major; }\n \n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return op_print_tab; }\n-\n protected:\n \n   /* See language.h.  */\n@@ -231,10 +226,6 @@ class f_language : public language_defn\n \t(const lookup_name_info &lookup_name) const override;\n \n private:\n-  /* Table of opcode data for use by OPCODE_PRINT_TABLE member function.  */\n-\n-  static const struct op_print op_print_tab[];\n-\n   /* Return the encoding that should be used for the character type\n      TYPE.  */\n "
    },
    {
      "sha": "2a4fb1a35b09095f86a0eecc7be3e37e0d4db0c7",
      "filename": "gdb/go-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 38,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/go-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/go-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -444,44 +444,6 @@ go_block_package_name (const struct block *block)\n   return NULL;\n }\n \n-/* See go-lang.h.\n-\n-   TODO(dje): &^ ?  */\n-\n-const struct op_print go_language::op_print_tab[] =\n-{\n-  {\",\", BINOP_COMMA, PREC_COMMA, 0},\n-  {\"=\", BINOP_ASSIGN, PREC_ASSIGN, 1},\n-  {\"||\", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},\n-  {\"&&\", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},\n-  {\"|\", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},\n-  {\"^\", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},\n-  {\"&\", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},\n-  {\"==\", BINOP_EQUAL, PREC_EQUAL, 0},\n-  {\"!=\", BINOP_NOTEQUAL, PREC_EQUAL, 0},\n-  {\"<=\", BINOP_LEQ, PREC_ORDER, 0},\n-  {\">=\", BINOP_GEQ, PREC_ORDER, 0},\n-  {\">\", BINOP_GTR, PREC_ORDER, 0},\n-  {\"<\", BINOP_LESS, PREC_ORDER, 0},\n-  {\">>\", BINOP_RSH, PREC_SHIFT, 0},\n-  {\"<<\", BINOP_LSH, PREC_SHIFT, 0},\n-  {\"+\", BINOP_ADD, PREC_ADD, 0},\n-  {\"-\", BINOP_SUB, PREC_ADD, 0},\n-  {\"*\", BINOP_MUL, PREC_MUL, 0},\n-  {\"/\", BINOP_DIV, PREC_MUL, 0},\n-  {\"%\", BINOP_REM, PREC_MUL, 0},\n-  {\"@\", BINOP_REPEAT, PREC_REPEAT, 0},\n-  {\"-\", UNOP_NEG, PREC_PREFIX, 0},\n-  {\"!\", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},\n-  {\"^\", UNOP_COMPLEMENT, PREC_PREFIX, 0},\n-  {\"*\", UNOP_IND, PREC_PREFIX, 0},\n-  {\"&\", UNOP_ADDR, PREC_PREFIX, 0},\n-  {\"unsafe.Sizeof \", UNOP_SIZEOF, PREC_PREFIX, 0},\n-  {\"++\", UNOP_POSTINCREMENT, PREC_SUFFIX, 0},\n-  {\"--\", UNOP_POSTDECREMENT, PREC_SUFFIX, 0},\n-  {NULL, OP_NULL, PREC_SUFFIX, 0}\n-};\n-\n /* See language.h.  */\n \n void"
    },
    {
      "sha": "3495d98d15dbdc24c01f6e29dceadb0e63c8e373",
      "filename": "gdb/go-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 12,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/go-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/go-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go-lang.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -134,18 +134,6 @@ class go_language : public language_defn\n \n   bool store_sym_names_in_linkage_form_p () const override\n   { return true; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return op_print_tab; }\n-\n-private:\n-\n-  /* Table of opcode data for use by OPCODE_PRINT_TABLE member function.  */\n-\n-  static const struct op_print op_print_tab[];\n-\n };\n \n #endif /* !defined (GO_LANG_H) */"
    },
    {
      "sha": "f38d64f28d77279e418fe1ae7608edc6709a4d02",
      "filename": "gdb/language.c",
      "status": "modified",
      "additions": 0,
      "deletions": 20,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/language.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/language.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -774,14 +774,6 @@ language_defn::varobj_ops () const\n   return &c_varobj_ops;\n }\n \n-/* See language.h.  */\n-\n-const struct exp_descriptor *\n-language_defn::expression_ops () const\n-{\n-  return &exp_descriptor_standard;\n-}\n-\n /* Parent class for both the \"auto\" and \"unknown\" languages.  These two\n    pseudo-languages are very similar so merging their implementations like\n    this makes sense.  */\n@@ -901,18 +893,6 @@ class auto_or_unknown_language : public language_defn\n \n   const char *name_of_this () const override\n   { return \"this\"; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  {\n-    static const struct op_print unk_op_print_tab[] =\n-      {\n-\t{NULL, OP_NULL, PREC_NULL, 0}\n-      };\n-\n-    return unk_op_print_tab;\n-  }\n };\n \n /* Class representing the fake \"auto\" language.  */"
    },
    {
      "sha": "5afb83359612a4ea0f6ab8ef77fe458b4f1a415e",
      "filename": "gdb/language.h",
      "status": "modified",
      "additions": 0,
      "deletions": 20,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/language.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/language.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/language.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -515,17 +515,6 @@ struct language_defn\n \n   virtual int parser (struct parser_state *ps) const;\n \n-  /* Given an expression *EXPP created by prefixifying the result of\n-     la_parser, perform any remaining processing necessary to complete its\n-     translation.  *EXPP may change; la_post_parser is responsible for\n-     releasing its previous contents, if necessary.  */\n-\n-  virtual void post_parser (expression_up *expp, struct parser_state *ps)\n-    const\n-  {\n-    /* By default the post-parser does nothing.  */\n-  }\n-\n   /* Print the character CH (of type CHTYPE) on STREAM as part of the\n      contents of a literal string whose delimiter is QUOTER.  */\n \n@@ -642,15 +631,6 @@ struct language_defn\n \n   virtual const struct lang_varobj_ops *varobj_ops () const;\n \n-  /* Definitions related to expression printing, prefixifying, and\n-     dumping.  */\n-\n-  virtual const struct exp_descriptor *expression_ops () const;\n-\n-  /* Table for printing expressions.  */\n-\n-  virtual const struct op_print *opcode_print_table () const = 0;\n-\n protected:\n \n   /* This is the overridable part of the GET_SYMBOL_NAME_MATCHER method."
    },
    {
      "sha": "fb813bd4349f857ae5636c28f386146c8cde99f7",
      "filename": "gdb/m2-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 37,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/m2-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/m2-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -113,43 +113,6 @@ eval_op_m2_subscript (struct type *expect_type, struct expression *exp,\n \n \f\n \n-/* Table of operators and their precedences for printing expressions.  */\n-\n-const struct op_print m2_language::op_print_tab[] =\n-{\n-  {\"+\", BINOP_ADD, PREC_ADD, 0},\n-  {\"+\", UNOP_PLUS, PREC_PREFIX, 0},\n-  {\"-\", BINOP_SUB, PREC_ADD, 0},\n-  {\"-\", UNOP_NEG, PREC_PREFIX, 0},\n-  {\"*\", BINOP_MUL, PREC_MUL, 0},\n-  {\"/\", BINOP_DIV, PREC_MUL, 0},\n-  {\"DIV\", BINOP_INTDIV, PREC_MUL, 0},\n-  {\"MOD\", BINOP_REM, PREC_MUL, 0},\n-  {\":=\", BINOP_ASSIGN, PREC_ASSIGN, 1},\n-  {\"OR\", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},\n-  {\"AND\", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},\n-  {\"NOT\", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},\n-  {\"=\", BINOP_EQUAL, PREC_EQUAL, 0},\n-  {\"<>\", BINOP_NOTEQUAL, PREC_EQUAL, 0},\n-  {\"<=\", BINOP_LEQ, PREC_ORDER, 0},\n-  {\">=\", BINOP_GEQ, PREC_ORDER, 0},\n-  {\">\", BINOP_GTR, PREC_ORDER, 0},\n-  {\"<\", BINOP_LESS, PREC_ORDER, 0},\n-  {\"^\", UNOP_IND, PREC_PREFIX, 0},\n-  {\"@\", BINOP_REPEAT, PREC_REPEAT, 0},\n-  {\"CAP\", UNOP_CAP, PREC_BUILTIN_FUNCTION, 0},\n-  {\"CHR\", UNOP_CHR, PREC_BUILTIN_FUNCTION, 0},\n-  {\"ORD\", UNOP_ORD, PREC_BUILTIN_FUNCTION, 0},\n-  {\"FLOAT\", UNOP_FLOAT, PREC_BUILTIN_FUNCTION, 0},\n-  {\"HIGH\", UNOP_HIGH, PREC_BUILTIN_FUNCTION, 0},\n-  {\"MAX\", UNOP_MAX, PREC_BUILTIN_FUNCTION, 0},\n-  {\"MIN\", UNOP_MIN, PREC_BUILTIN_FUNCTION, 0},\n-  {\"ODD\", UNOP_ODD, PREC_BUILTIN_FUNCTION, 0},\n-  {\"TRUNC\", UNOP_TRUNC, PREC_BUILTIN_FUNCTION, 0},\n-  {NULL, OP_NULL, PREC_BUILTIN_FUNCTION, 0}\n-};\n-\f\n-\n /* Single instance of the M2 language.  */\n \n static m2_language m2_language_defn;"
    },
    {
      "sha": "89b9d185b96c262fcff9174523e6ad3398fa5ef3",
      "filename": "gdb/m2-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/m2-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/m2-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/m2-lang.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -147,15 +147,6 @@ class m2_language : public language_defn\n \n   bool range_checking_on_by_default () const override\n   { return true; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return op_print_tab; }\n-\n-private:\n-  /* Table of opcode data for use by OPCODE_PRINT_TABLE member function.  */\n-  static const struct op_print op_print_tab[];\n };\n \n #endif /* M2_LANG_H */"
    },
    {
      "sha": "8e8cc053531846c0516751fb102a9c086d7006f8",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 43,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -282,44 +282,6 @@ objc_demangle (const char *mangled, int options)\n     return NULL;\t/* Not an objc mangled name.  */\n }\n \n-\n-/* Table mapping opcodes into strings for printing operators\n-   and precedences of the operators.  */\n-\n-static const struct op_print objc_op_print_tab[] =\n-  {\n-    {\",\",  BINOP_COMMA, PREC_COMMA, 0},\n-    {\"=\",  BINOP_ASSIGN, PREC_ASSIGN, 1},\n-    {\"||\", BINOP_LOGICAL_OR, PREC_LOGICAL_OR, 0},\n-    {\"&&\", BINOP_LOGICAL_AND, PREC_LOGICAL_AND, 0},\n-    {\"|\",  BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},\n-    {\"^\",  BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},\n-    {\"&\",  BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},\n-    {\"==\", BINOP_EQUAL, PREC_EQUAL, 0},\n-    {\"!=\", BINOP_NOTEQUAL, PREC_EQUAL, 0},\n-    {\"<=\", BINOP_LEQ, PREC_ORDER, 0},\n-    {\">=\", BINOP_GEQ, PREC_ORDER, 0},\n-    {\">\",  BINOP_GTR, PREC_ORDER, 0},\n-    {\"<\",  BINOP_LESS, PREC_ORDER, 0},\n-    {\">>\", BINOP_RSH, PREC_SHIFT, 0},\n-    {\"<<\", BINOP_LSH, PREC_SHIFT, 0},\n-    {\"+\",  BINOP_ADD, PREC_ADD, 0},\n-    {\"-\",  BINOP_SUB, PREC_ADD, 0},\n-    {\"*\",  BINOP_MUL, PREC_MUL, 0},\n-    {\"/\",  BINOP_DIV, PREC_MUL, 0},\n-    {\"%\",  BINOP_REM, PREC_MUL, 0},\n-    {\"@\",  BINOP_REPEAT, PREC_REPEAT, 0},\n-    {\"-\",  UNOP_NEG, PREC_PREFIX, 0},\n-    {\"!\",  UNOP_LOGICAL_NOT, PREC_PREFIX, 0},\n-    {\"~\",  UNOP_COMPLEMENT, PREC_PREFIX, 0},\n-    {\"*\",  UNOP_IND, PREC_PREFIX, 0},\n-    {\"&\",  UNOP_ADDR, PREC_PREFIX, 0},\n-    {\"sizeof \", UNOP_SIZEOF, PREC_PREFIX, 0},\n-    {\"++\", UNOP_PREINCREMENT, PREC_PREFIX, 0},\n-    {\"--\", UNOP_PREDECREMENT, PREC_PREFIX, 0},\n-    {NULL, OP_NULL, PREC_NULL, 0}\n-};\n-\n /* Class representing the Objective-C language.  */\n \n class objc_language : public language_defn\n@@ -421,11 +383,6 @@ class objc_language : public language_defn\n \n   enum macro_expansion macro_expansion () const override\n   { return macro_expansion_c; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return objc_op_print_tab; }\n };\n \n /* Single instance of the class representing the Objective-C language.  */"
    },
    {
      "sha": "c168cd4934404a7fc46ffee7902cc128e41cca54",
      "filename": "gdb/opencl-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/opencl-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/opencl-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/opencl-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -973,11 +973,6 @@ class opencl_language : public language_defn\n \n   enum macro_expansion macro_expansion () const override\n   { return macro_expansion_c; }\n-\n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return c_op_print_tab; }\n };\n \n /* Single instance of the OpenCL language class.  */"
    },
    {
      "sha": "1d8e9408e54004df4cb30e9009fdf86eed728964",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 34,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -185,40 +185,6 @@ pascal_language::printchar (int c, struct type *type,\n \n \f\n \n-/* Table mapping opcodes into strings for printing operators\n-   and precedences of the operators.  */\n-\n-const struct op_print pascal_language::op_print_tab[] =\n-{\n-  {\",\", BINOP_COMMA, PREC_COMMA, 0},\n-  {\":=\", BINOP_ASSIGN, PREC_ASSIGN, 1},\n-  {\"or\", BINOP_BITWISE_IOR, PREC_BITWISE_IOR, 0},\n-  {\"xor\", BINOP_BITWISE_XOR, PREC_BITWISE_XOR, 0},\n-  {\"and\", BINOP_BITWISE_AND, PREC_BITWISE_AND, 0},\n-  {\"=\", BINOP_EQUAL, PREC_EQUAL, 0},\n-  {\"<>\", BINOP_NOTEQUAL, PREC_EQUAL, 0},\n-  {\"<=\", BINOP_LEQ, PREC_ORDER, 0},\n-  {\">=\", BINOP_GEQ, PREC_ORDER, 0},\n-  {\">\", BINOP_GTR, PREC_ORDER, 0},\n-  {\"<\", BINOP_LESS, PREC_ORDER, 0},\n-  {\"shr\", BINOP_RSH, PREC_SHIFT, 0},\n-  {\"shl\", BINOP_LSH, PREC_SHIFT, 0},\n-  {\"+\", BINOP_ADD, PREC_ADD, 0},\n-  {\"-\", BINOP_SUB, PREC_ADD, 0},\n-  {\"*\", BINOP_MUL, PREC_MUL, 0},\n-  {\"/\", BINOP_DIV, PREC_MUL, 0},\n-  {\"div\", BINOP_INTDIV, PREC_MUL, 0},\n-  {\"mod\", BINOP_REM, PREC_MUL, 0},\n-  {\"@\", BINOP_REPEAT, PREC_REPEAT, 0},\n-  {\"-\", UNOP_NEG, PREC_PREFIX, 0},\n-  {\"not\", UNOP_LOGICAL_NOT, PREC_PREFIX, 0},\n-  {\"^\", UNOP_IND, PREC_SUFFIX, 1},\n-  {\"@\", UNOP_ADDR, PREC_PREFIX, 0},\n-  {\"sizeof\", UNOP_SIZEOF, PREC_PREFIX, 0},\n-  {NULL, OP_NULL, PREC_PREFIX, 0}\n-};\n-\f\n-\n /* See language.h.  */\n \n void pascal_language::language_arch_info"
    },
    {
      "sha": "95dca01f22ea8c074cf461f55bd6f1dfdb7ba3b4",
      "filename": "gdb/p-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 9,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/p-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/p-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -154,17 +154,8 @@ class pascal_language : public language_defn\n   bool range_checking_on_by_default () const override\n   { return true; }\n \n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return op_print_tab; }\n-\n private:\n \n-  /* Table of opcode data for use by OPCODE_PRINT_TABLE member function.  */\n-\n-  static const struct op_print op_print_tab[];\n-\n   /* Print the character C on STREAM as part of the contents of a literal\n      string.  IN_QUOTES is reset to 0 if a char is written with #4 notation.  */\n "
    },
    {
      "sha": "96dd5dbf7a00b6d5bec8c7bdea3d1b664ac4f4d2",
      "filename": "gdb/parse.c",
      "status": "modified",
      "additions": 19,
      "deletions": 959,
      "changes": 978,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parse.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -52,18 +52,6 @@\n #include \"gdbsupport/gdb_optional.h\"\n #include \"c-exp.h\"\n \n-/* Standard set of definitions for printing, dumping, prefixifying,\n- * and evaluating expressions.  */\n-\n-const struct exp_descriptor exp_descriptor_standard = \n-  {\n-    print_subexp_standard,\n-    operator_length_standard,\n-    operator_check_standard,\n-    dump_subexp_body_standard,\n-    evaluate_subexp_standard\n-  };\n-\f\n static unsigned int expressiondebug = 0;\n static void\n show_expressiondebug (struct ui_file *file, int from_tty,\n@@ -84,18 +72,11 @@ show_parserdebug (struct ui_file *file, int from_tty,\n }\n \n \n-static int prefixify_subexp (struct expression *, struct expression *, int,\n-\t\t\t     int, int);\n-\n static expression_up parse_exp_in_context (const char **, CORE_ADDR,\n \t\t\t\t\t   const struct block *, int,\n-\t\t\t\t\t   bool, int *,\n-\t\t\t\t\t   innermost_block_tracker *,\n+\t\t\t\t\t   bool, innermost_block_tracker *,\n \t\t\t\t\t   expr_completion_state *);\n \n-static void increase_expout_size (struct expr_builder *ps, size_t lenelt);\n-\n-\n /* Documented at it's declaration.  */\n \n void\n@@ -114,297 +95,24 @@ innermost_block_tracker::update (const struct block *b,\n \n expr_builder::expr_builder (const struct language_defn *lang,\n \t\t\t    struct gdbarch *gdbarch)\n-  : expout_size (10),\n-    expout (new expression (lang, gdbarch, expout_size)),\n-    expout_ptr (0)\n+  : expout (new expression (lang, gdbarch))\n {\n }\n \n expression_up\n expr_builder::release ()\n {\n-  /* Record the actual number of expression elements, and then\n-     reallocate the expression memory so that we free up any\n-     excess elements.  */\n-\n-  expout->nelts = expout_ptr;\n-  expout->resize (expout_ptr);\n-\n   return std::move (expout);\n }\n \n-expression::expression (const struct language_defn *lang, struct gdbarch *arch,\n-\t\t\tsize_t n)\n+expression::expression (const struct language_defn *lang, struct gdbarch *arch)\n   : language_defn (lang),\n-    gdbarch (arch),\n-    elts (nullptr)\n+    gdbarch (arch)\n {\n-  resize (n);\n }\n \n expression::~expression ()\n {\n-  xfree (elts);\n-}\n-\n-void\n-expression::resize (size_t n)\n-{\n-  elts = XRESIZEVAR (union exp_element, elts, EXP_ELEM_TO_BYTES (n));\n-}\n-\n-/* This page contains the functions for adding data to the struct expression\n-   being constructed.  */\n-\n-/* Add one element to the end of the expression.  */\n-\n-/* To avoid a bug in the Sun 4 compiler, we pass things that can fit into\n-   a register through here.  */\n-\n-static void\n-write_exp_elt (struct expr_builder *ps, const union exp_element *expelt)\n-{\n-  if (ps->expout_ptr >= ps->expout_size)\n-    {\n-      ps->expout_size *= 2;\n-      ps->expout->resize (ps->expout_size);\n-    }\n-  ps->expout->elts[ps->expout_ptr++] = *expelt;\n-}\n-\n-void\n-write_exp_elt_opcode (struct expr_builder *ps, enum exp_opcode expelt)\n-{\n-  union exp_element tmp;\n-\n-  memset (&tmp, 0, sizeof (union exp_element));\n-  tmp.opcode = expelt;\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-void\n-write_exp_elt_sym (struct expr_builder *ps, struct symbol *expelt)\n-{\n-  union exp_element tmp;\n-\n-  memset (&tmp, 0, sizeof (union exp_element));\n-  tmp.symbol = expelt;\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-static void\n-write_exp_elt_msym (struct expr_builder *ps, minimal_symbol *expelt)\n-{\n-  union exp_element tmp;\n-\n-  memset (&tmp, 0, sizeof (union exp_element));\n-  tmp.msymbol = expelt;\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-void\n-write_exp_elt_block (struct expr_builder *ps, const struct block *b)\n-{\n-  union exp_element tmp;\n-\n-  memset (&tmp, 0, sizeof (union exp_element));\n-  tmp.block = b;\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-void\n-write_exp_elt_objfile (struct expr_builder *ps, struct objfile *objfile)\n-{\n-  union exp_element tmp;\n-\n-  memset (&tmp, 0, sizeof (union exp_element));\n-  tmp.objfile = objfile;\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-void\n-write_exp_elt_longcst (struct expr_builder *ps, LONGEST expelt)\n-{\n-  union exp_element tmp;\n-\n-  memset (&tmp, 0, sizeof (union exp_element));\n-  tmp.longconst = expelt;\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-void\n-write_exp_elt_floatcst (struct expr_builder *ps, const gdb_byte expelt[16])\n-{\n-  union exp_element tmp;\n-  int index;\n-\n-  for (index = 0; index < 16; index++)\n-    tmp.floatconst[index] = expelt[index];\n-\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-void\n-write_exp_elt_type (struct expr_builder *ps, struct type *expelt)\n-{\n-  union exp_element tmp;\n-\n-  memset (&tmp, 0, sizeof (union exp_element));\n-  tmp.type = expelt;\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-void\n-write_exp_elt_intern (struct expr_builder *ps, struct internalvar *expelt)\n-{\n-  union exp_element tmp;\n-\n-  memset (&tmp, 0, sizeof (union exp_element));\n-  tmp.internalvar = expelt;\n-  write_exp_elt (ps, &tmp);\n-}\n-\n-/* Add a string constant to the end of the expression.\n-\n-   String constants are stored by first writing an expression element\n-   that contains the length of the string, then stuffing the string\n-   constant itself into however many expression elements are needed\n-   to hold it, and then writing another expression element that contains\n-   the length of the string.  I.e. an expression element at each end of\n-   the string records the string length, so you can skip over the \n-   expression elements containing the actual string bytes from either\n-   end of the string.  Note that this also allows gdb to handle\n-   strings with embedded null bytes, as is required for some languages.\n-\n-   Don't be fooled by the fact that the string is null byte terminated,\n-   this is strictly for the convenience of debugging gdb itself.\n-   Gdb does not depend up the string being null terminated, since the\n-   actual length is recorded in expression elements at each end of the\n-   string.  The null byte is taken into consideration when computing how\n-   many expression elements are required to hold the string constant, of\n-   course.  */\n-\n-\n-void\n-write_exp_string (struct expr_builder *ps, struct stoken str)\n-{\n-  int len = str.length;\n-  size_t lenelt;\n-  char *strdata;\n-\n-  /* Compute the number of expression elements required to hold the string\n-     (including a null byte terminator), along with one expression element\n-     at each end to record the actual string length (not including the\n-     null byte terminator).  */\n-\n-  lenelt = 2 + BYTES_TO_EXP_ELEM (len + 1);\n-\n-  increase_expout_size (ps, lenelt);\n-\n-  /* Write the leading length expression element (which advances the current\n-     expression element index), then write the string constant followed by a\n-     terminating null byte, and then write the trailing length expression\n-     element.  */\n-\n-  write_exp_elt_longcst (ps, (LONGEST) len);\n-  strdata = (char *) &ps->expout->elts[ps->expout_ptr];\n-  memcpy (strdata, str.ptr, len);\n-  *(strdata + len) = '\\0';\n-  ps->expout_ptr += lenelt - 2;\n-  write_exp_elt_longcst (ps, (LONGEST) len);\n-}\n-\n-/* Add a vector of string constants to the end of the expression.\n-\n-   This adds an OP_STRING operation, but encodes the contents\n-   differently from write_exp_string.  The language is expected to\n-   handle evaluation of this expression itself.\n-   \n-   After the usual OP_STRING header, TYPE is written into the\n-   expression as a long constant.  The interpretation of this field is\n-   up to the language evaluator.\n-   \n-   Next, each string in VEC is written.  The length is written as a\n-   long constant, followed by the contents of the string.  */\n-\n-void\n-write_exp_string_vector (struct expr_builder *ps, int type,\n-\t\t\t struct stoken_vector *vec)\n-{\n-  int i, len;\n-  size_t n_slots;\n-\n-  /* Compute the size.  We compute the size in number of slots to\n-     avoid issues with string padding.  */\n-  n_slots = 0;\n-  for (i = 0; i < vec->len; ++i)\n-    {\n-      /* One slot for the length of this element, plus the number of\n-\t slots needed for this string.  */\n-      n_slots += 1 + BYTES_TO_EXP_ELEM (vec->tokens[i].length);\n-    }\n-\n-  /* One more slot for the type of the string.  */\n-  ++n_slots;\n-\n-  /* Now compute a phony string length.  */\n-  len = EXP_ELEM_TO_BYTES (n_slots) - 1;\n-\n-  n_slots += 4;\n-  increase_expout_size (ps, n_slots);\n-\n-  write_exp_elt_opcode (ps, OP_STRING);\n-  write_exp_elt_longcst (ps, len);\n-  write_exp_elt_longcst (ps, type);\n-\n-  for (i = 0; i < vec->len; ++i)\n-    {\n-      write_exp_elt_longcst (ps, vec->tokens[i].length);\n-      memcpy (&ps->expout->elts[ps->expout_ptr], vec->tokens[i].ptr,\n-\t      vec->tokens[i].length);\n-      ps->expout_ptr += BYTES_TO_EXP_ELEM (vec->tokens[i].length);\n-    }\n-\n-  write_exp_elt_longcst (ps, len);\n-  write_exp_elt_opcode (ps, OP_STRING);\n-}\n-\n-/* Add a bitstring constant to the end of the expression.\n-\n-   Bitstring constants are stored by first writing an expression element\n-   that contains the length of the bitstring (in bits), then stuffing the\n-   bitstring constant itself into however many expression elements are\n-   needed to hold it, and then writing another expression element that\n-   contains the length of the bitstring.  I.e. an expression element at\n-   each end of the bitstring records the bitstring length, so you can skip\n-   over the expression elements containing the actual bitstring bytes from\n-   either end of the bitstring.  */\n-\n-void\n-write_exp_bitstring (struct expr_builder *ps, struct stoken str)\n-{\n-  int bits = str.length;\t/* length in bits */\n-  int len = (bits + HOST_CHAR_BIT - 1) / HOST_CHAR_BIT;\n-  size_t lenelt;\n-  char *strdata;\n-\n-  /* Compute the number of expression elements required to hold the bitstring,\n-     along with one expression element at each end to record the actual\n-     bitstring length in bits.  */\n-\n-  lenelt = 2 + BYTES_TO_EXP_ELEM (len);\n-\n-  increase_expout_size (ps, lenelt);\n-\n-  /* Write the leading length expression element (which advances the current\n-     expression element index), then write the bitstring constant, and then\n-     write the trailing length expression element.  */\n-\n-  write_exp_elt_longcst (ps, (LONGEST) bits);\n-  strdata = (char *) &ps->expout->elts[ps->expout_ptr];\n-  memcpy (strdata, str.ptr, len);\n-  ps->expout_ptr += lenelt - 2;\n-  write_exp_elt_longcst (ps, (LONGEST) bits);\n }\n \n /* Return the type of MSYMBOL, a minimal symbol of OBJFILE.  If\n@@ -487,40 +195,14 @@ find_minsym_type_and_address (minimal_symbol *msymbol,\n     }\n }\n \n-/* Add the appropriate elements for a minimal symbol to the end of\n-   the expression.  */\n-\n-void\n-write_exp_msymbol (struct expr_builder *ps,\n-\t\t   struct bound_minimal_symbol bound_msym)\n-{\n-  write_exp_elt_opcode (ps, OP_VAR_MSYM_VALUE);\n-  write_exp_elt_objfile (ps, bound_msym.objfile);\n-  write_exp_elt_msym (ps, bound_msym.minsym);\n-  write_exp_elt_opcode (ps, OP_VAR_MSYM_VALUE);\n-}\n-\n-/* See parser-defs.h.  */\n-\n-void\n-parser_state::mark_struct_expression ()\n-{\n-  gdb_assert (parse_completion\n-\t      && (m_completion_state.expout_tag_completion_type\n-\t\t  == TYPE_CODE_UNDEF)\n-\t      && m_completion_state.expout_last_op == nullptr);\n-  m_completion_state.expout_last_struct = expout_ptr;\n-}\n-\n /* See parser-defs.h.  */\n \n void\n parser_state::mark_struct_expression (expr::structop_base_operation *op)\n {\n   gdb_assert (parse_completion\n \t      && (m_completion_state.expout_tag_completion_type\n-\t\t  == TYPE_CODE_UNDEF)\n-\t      && m_completion_state.expout_last_struct == -1);\n+\t\t  == TYPE_CODE_UNDEF));\n   m_completion_state.expout_last_op = op;\n }\n \n@@ -536,7 +218,6 @@ parser_state::mark_completion_tag (enum type_code tag, const char *ptr,\n \t      && (m_completion_state.expout_tag_completion_type\n \t\t  == TYPE_CODE_UNDEF)\n \t      && m_completion_state.expout_completion_name == NULL\n-\t      && m_completion_state.expout_last_struct == -1\n \t      && m_completion_state.expout_last_op == nullptr);\n   gdb_assert (tag == TYPE_CODE_UNION\n \t      || tag == TYPE_CODE_STRUCT\n@@ -673,151 +354,6 @@ parser_state::push_dollar (struct stoken str)\n }\n \n \f\n-/* Recognize tokens that start with '$'.  These include:\n-\n-   $regname     A native register name or a \"standard\n-   register name\".\n-\n-   $variable    A convenience variable with a name chosen\n-   by the user.\n-\n-   $digits              Value history with index <digits>, starting\n-   from the first value which has index 1.\n-\n-   $$digits     Value history with index <digits> relative\n-   to the last value.  I.e. $$0 is the last\n-   value, $$1 is the one previous to that, $$2\n-   is the one previous to $$1, etc.\n-\n-   $ | $0 | $$0 The last value in the value history.\n-\n-   $$           An abbreviation for the second to the last\n-   value in the value history, I.e. $$1  */\n-\n-void\n-write_dollar_variable (struct parser_state *ps, struct stoken str)\n-{\n-  struct block_symbol sym;\n-  struct bound_minimal_symbol msym;\n-  struct internalvar *isym = NULL;\n-  std::string copy;\n-\n-  /* Handle the tokens $digits; also $ (short for $0) and $$ (short for $$1)\n-     and $$digits (equivalent to $<-digits> if you could type that).  */\n-\n-  int negate = 0;\n-  int i = 1;\n-  /* Double dollar means negate the number and add -1 as well.\n-     Thus $$ alone means -1.  */\n-  if (str.length >= 2 && str.ptr[1] == '$')\n-    {\n-      negate = 1;\n-      i = 2;\n-    }\n-  if (i == str.length)\n-    {\n-      /* Just dollars (one or two).  */\n-      i = -negate;\n-      goto handle_last;\n-    }\n-  /* Is the rest of the token digits?  */\n-  for (; i < str.length; i++)\n-    if (!(str.ptr[i] >= '0' && str.ptr[i] <= '9'))\n-      break;\n-  if (i == str.length)\n-    {\n-      i = atoi (str.ptr + 1 + negate);\n-      if (negate)\n-\ti = -i;\n-      goto handle_last;\n-    }\n-\n-  /* Handle tokens that refer to machine registers:\n-     $ followed by a register name.  */\n-  i = user_reg_map_name_to_regnum (ps->gdbarch (),\n-\t\t\t\t   str.ptr + 1, str.length - 1);\n-  if (i >= 0)\n-    goto handle_register;\n-\n-  /* Any names starting with $ are probably debugger internal variables.  */\n-\n-  copy = copy_name (str);\n-  isym = lookup_only_internalvar (copy.c_str () + 1);\n-  if (isym)\n-    {\n-      write_exp_elt_opcode (ps, OP_INTERNALVAR);\n-      write_exp_elt_intern (ps, isym);\n-      write_exp_elt_opcode (ps, OP_INTERNALVAR);\n-      return;\n-    }\n-\n-  /* On some systems, such as HP-UX and hppa-linux, certain system routines \n-     have names beginning with $ or $$.  Check for those, first.  */\n-\n-  sym = lookup_symbol (copy.c_str (), NULL, VAR_DOMAIN, NULL);\n-  if (sym.symbol)\n-    {\n-      write_exp_elt_opcode (ps, OP_VAR_VALUE);\n-      write_exp_elt_block (ps, sym.block);\n-      write_exp_elt_sym (ps, sym.symbol);\n-      write_exp_elt_opcode (ps, OP_VAR_VALUE);\n-      return;\n-    }\n-  msym = lookup_bound_minimal_symbol (copy.c_str ());\n-  if (msym.minsym)\n-    {\n-      write_exp_msymbol (ps, msym);\n-      return;\n-    }\n-\n-  /* Any other names are assumed to be debugger internal variables.  */\n-\n-  write_exp_elt_opcode (ps, OP_INTERNALVAR);\n-  write_exp_elt_intern (ps, create_internalvar (copy.c_str () + 1));\n-  write_exp_elt_opcode (ps, OP_INTERNALVAR);\n-  return;\n-handle_last:\n-  write_exp_elt_opcode (ps, OP_LAST);\n-  write_exp_elt_longcst (ps, (LONGEST) i);\n-  write_exp_elt_opcode (ps, OP_LAST);\n-  return;\n-handle_register:\n-  write_exp_elt_opcode (ps, OP_REGISTER);\n-  str.length--;\n-  str.ptr++;\n-  write_exp_string (ps, str);\n-  write_exp_elt_opcode (ps, OP_REGISTER);\n-  ps->block_tracker->update (ps->expression_context_block,\n-\t\t\t     INNERMOST_BLOCK_FOR_REGISTERS);\n-  return;\n-}\n-\n-/* See parser-defs.h.  */\n-\n-void\n-write_exp_symbol_reference (struct parser_state *pstate, const char *name,\n-\t\t\t    struct block_symbol sym)\n-{\n-  if (sym.symbol != nullptr)\n-    {\n-      if (symbol_read_needs_frame (sym.symbol))\n-\tpstate->block_tracker->update (sym);\n-      write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-      write_exp_elt_block (pstate, sym.block);\n-      write_exp_elt_sym (pstate, sym.symbol);\n-      write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-    }\n-  else\n-    {\n-      struct bound_minimal_symbol msymbol = lookup_bound_minimal_symbol (name);\n-      if (msymbol.minsym != NULL)\n-\twrite_exp_msymbol (pstate, msymbol);\n-      else if (!have_full_symbols () && !have_partial_symbols ())\n-\terror (_(\"No symbol table is loaded.  Use the \\\"file\\\" command.\"));\n-      else\n-\terror (_(\"No symbol \\\"%s\\\" in current context.\"), name);\n-    }\n-}\n \n const char *\n find_template_name_end (const char *p)\n@@ -895,293 +431,6 @@ copy_name (struct stoken token)\n }\n \f\n \n-/* See comments on parser-defs.h.  */\n-\n-int\n-prefixify_expression (struct expression *expr, int last_struct)\n-{\n-  gdb_assert (expr->nelts > 0);\n-  int len = EXP_ELEM_TO_BYTES (expr->nelts);\n-  struct expression temp (expr->language_defn, expr->gdbarch, expr->nelts);\n-  int inpos = expr->nelts, outpos = 0;\n-\n-  /* Copy the original expression into temp.  */\n-  memcpy (temp.elts, expr->elts, len);\n-\n-  return prefixify_subexp (&temp, expr, inpos, outpos, last_struct);\n-}\n-\n-/* Return the number of exp_elements in the postfix subexpression \n-   of EXPR whose operator is at index ENDPOS - 1 in EXPR.  */\n-\n-static int\n-length_of_subexp (struct expression *expr, int endpos)\n-{\n-  int oplen, args;\n-\n-  operator_length (expr, endpos, &oplen, &args);\n-\n-  while (args > 0)\n-    {\n-      oplen += length_of_subexp (expr, endpos - oplen);\n-      args--;\n-    }\n-\n-  return oplen;\n-}\n-\n-/* Sets *OPLENP to the length of the operator whose (last) index is \n-   ENDPOS - 1 in EXPR, and sets *ARGSP to the number of arguments that\n-   operator takes.  */\n-\n-void\n-operator_length (const struct expression *expr, int endpos, int *oplenp,\n-\t\t int *argsp)\n-{\n-  expr->language_defn->expression_ops ()->operator_length (expr, endpos,\n-\t\t\t\t\t\t\t   oplenp, argsp);\n-}\n-\n-/* Default value for operator_length in exp_descriptor vectors.  */\n-\n-void\n-operator_length_standard (const struct expression *expr, int endpos,\n-\t\t\t  int *oplenp, int *argsp)\n-{\n-  int oplen = 1;\n-  int args = 0;\n-  enum range_flag range_flag;\n-  int i;\n-\n-  if (endpos < 1)\n-    error (_(\"?error in operator_length_standard\"));\n-\n-  i = (int) expr->elts[endpos - 1].opcode;\n-\n-  switch (i)\n-    {\n-      /* C++  */\n-    case OP_SCOPE:\n-      oplen = longest_to_int (expr->elts[endpos - 2].longconst);\n-      oplen = 5 + BYTES_TO_EXP_ELEM (oplen + 1);\n-      break;\n-\n-    case OP_LONG:\n-    case OP_FLOAT:\n-    case OP_VAR_VALUE:\n-    case OP_VAR_MSYM_VALUE:\n-      oplen = 4;\n-      break;\n-\n-    case OP_FUNC_STATIC_VAR:\n-      oplen = longest_to_int (expr->elts[endpos - 2].longconst);\n-      oplen = 4 + BYTES_TO_EXP_ELEM (oplen + 1);\n-      args = 1;\n-      break;\n-\n-    case OP_TYPE:\n-    case OP_BOOL:\n-    case OP_LAST:\n-    case OP_INTERNALVAR:\n-    case OP_VAR_ENTRY_VALUE:\n-      oplen = 3;\n-      break;\n-\n-    case OP_COMPLEX:\n-      oplen = 3;\n-      args = 2;\n-      break;\n-\n-    case OP_FUNCALL:\n-      oplen = 3;\n-      args = 1 + longest_to_int (expr->elts[endpos - 2].longconst);\n-      break;\n-\n-    case TYPE_INSTANCE:\n-      oplen = 5 + longest_to_int (expr->elts[endpos - 2].longconst);\n-      args = 1;\n-      break;\n-\n-    case OP_OBJC_MSGCALL:\t/* Objective C message (method) call.  */\n-      oplen = 4;\n-      args = 1 + longest_to_int (expr->elts[endpos - 2].longconst);\n-      break;\n-\n-    case UNOP_MAX:\n-    case UNOP_MIN:\n-      oplen = 3;\n-      break;\n-\n-    case UNOP_CAST_TYPE:\n-    case UNOP_DYNAMIC_CAST:\n-    case UNOP_REINTERPRET_CAST:\n-    case UNOP_MEMVAL_TYPE:\n-      oplen = 1;\n-      args = 2;\n-      break;\n-\n-    case BINOP_VAL:\n-    case UNOP_CAST:\n-    case UNOP_MEMVAL:\n-      oplen = 3;\n-      args = 1;\n-      break;\n-\n-    case UNOP_ABS:\n-    case UNOP_CAP:\n-    case UNOP_CHR:\n-    case UNOP_FLOAT:\n-    case UNOP_HIGH:\n-    case UNOP_ODD:\n-    case UNOP_ORD:\n-    case UNOP_TRUNC:\n-    case OP_TYPEOF:\n-    case OP_DECLTYPE:\n-    case OP_TYPEID:\n-      oplen = 1;\n-      args = 1;\n-      break;\n-\n-    case OP_ADL_FUNC:\n-      oplen = longest_to_int (expr->elts[endpos - 2].longconst);\n-      oplen = 4 + BYTES_TO_EXP_ELEM (oplen + 1);\n-      oplen++;\n-      oplen++;\n-      break;\n-\n-    case STRUCTOP_STRUCT:\n-    case STRUCTOP_PTR:\n-      args = 1;\n-      /* fall through */\n-    case OP_REGISTER:\n-    case OP_M2_STRING:\n-    case OP_STRING:\n-    case OP_OBJC_NSSTRING:\t/* Objective C Foundation Class\n-\t\t\t\t   NSString constant.  */\n-    case OP_OBJC_SELECTOR:\t/* Objective C \"@selector\" pseudo-op.  */\n-    case OP_NAME:\n-      oplen = longest_to_int (expr->elts[endpos - 2].longconst);\n-      oplen = 4 + BYTES_TO_EXP_ELEM (oplen + 1);\n-      break;\n-\n-    case OP_ARRAY:\n-      oplen = 4;\n-      args = longest_to_int (expr->elts[endpos - 2].longconst);\n-      args -= longest_to_int (expr->elts[endpos - 3].longconst);\n-      args += 1;\n-      break;\n-\n-    case TERNOP_COND:\n-    case TERNOP_SLICE:\n-      args = 3;\n-      break;\n-\n-      /* Modula-2 */\n-    case MULTI_SUBSCRIPT:\n-      oplen = 3;\n-      args = 1 + longest_to_int (expr->elts[endpos - 2].longconst);\n-      break;\n-\n-    case BINOP_ASSIGN_MODIFY:\n-      oplen = 3;\n-      args = 2;\n-      break;\n-\n-      /* C++ */\n-    case OP_THIS:\n-      oplen = 2;\n-      break;\n-\n-    case OP_RANGE:\n-      oplen = 3;\n-      range_flag = (enum range_flag)\n-\tlongest_to_int (expr->elts[endpos - 2].longconst);\n-\n-      /* Assume the range has 2 arguments (low bound and high bound), then\n-\t reduce the argument count if any bounds are set to default.  */\n-      args = 2;\n-      if (range_flag & RANGE_HAS_STRIDE)\n-\t++args;\n-      if (range_flag & RANGE_LOW_BOUND_DEFAULT)\n-\t--args;\n-      if (range_flag & RANGE_HIGH_BOUND_DEFAULT)\n-\t--args;\n-\n-      break;\n-\n-    default:\n-      args = 1 + (i < (int) BINOP_END);\n-    }\n-\n-  *oplenp = oplen;\n-  *argsp = args;\n-}\n-\n-/* Copy the subexpression ending just before index INEND in INEXPR\n-   into OUTEXPR, starting at index OUTBEG.\n-   In the process, convert it from suffix to prefix form.\n-   If LAST_STRUCT is -1, then this function always returns -1.\n-   Otherwise, it returns the index of the subexpression which is the\n-   left-hand-side of the expression at LAST_STRUCT.  */\n-\n-static int\n-prefixify_subexp (struct expression *inexpr,\n-\t\t  struct expression *outexpr, int inend, int outbeg,\n-\t\t  int last_struct)\n-{\n-  int oplen;\n-  int args;\n-  int i;\n-  int *arglens;\n-  int result = -1;\n-\n-  operator_length (inexpr, inend, &oplen, &args);\n-\n-  /* Copy the final operator itself, from the end of the input\n-     to the beginning of the output.  */\n-  inend -= oplen;\n-  memcpy (&outexpr->elts[outbeg], &inexpr->elts[inend],\n-\t  EXP_ELEM_TO_BYTES (oplen));\n-  outbeg += oplen;\n-\n-  if (last_struct == inend)\n-    result = outbeg - oplen;\n-\n-  /* Find the lengths of the arg subexpressions.  */\n-  arglens = (int *) alloca (args * sizeof (int));\n-  for (i = args - 1; i >= 0; i--)\n-    {\n-      oplen = length_of_subexp (inexpr, inend);\n-      arglens[i] = oplen;\n-      inend -= oplen;\n-    }\n-\n-  /* Now copy each subexpression, preserving the order of\n-     the subexpressions, but prefixifying each one.\n-     In this loop, inend starts at the beginning of\n-     the expression this level is working on\n-     and marches forward over the arguments.\n-     outbeg does similarly in the output.  */\n-  for (i = 0; i < args; i++)\n-    {\n-      int r;\n-\n-      oplen = arglens[i];\n-      inend += oplen;\n-      r = prefixify_subexp (inexpr, outexpr, inend, outbeg, last_struct);\n-      if (r != -1)\n-\t{\n-\t  /* Return immediately.  We probably have only parsed a\n-\t     partial expression, so we don't want to try to reverse\n-\t     the other operands.  */\n-\t  return r;\n-\t}\n-      outbeg += oplen;\n-    }\n-\n-  return result;\n-}\n-\f\n /* Read an expression from the string *STRINGPTR points to,\n    parse it, and return a pointer to a struct expression that we malloc.\n    Use block BLOCK as the lexical context for variable names;\n@@ -1196,21 +445,17 @@ expression_up\n parse_exp_1 (const char **stringptr, CORE_ADDR pc, const struct block *block,\n \t     int comma, innermost_block_tracker *tracker)\n {\n-  return parse_exp_in_context (stringptr, pc, block, comma, false, NULL,\n+  return parse_exp_in_context (stringptr, pc, block, comma, false,\n \t\t\t       tracker, nullptr);\n }\n \n /* As for parse_exp_1, except that if VOID_CONTEXT_P, then\n-   no value is expected from the expression.\n-   OUT_SUBEXP is set when attempting to complete a field name; in this\n-   case it is set to the index of the subexpression on the\n-   left-hand-side of the struct op.  If not doing such completion, it\n-   is left untouched.  */\n+   no value is expected from the expression.  */\n \n static expression_up\n parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n \t\t      const struct block *block,\n-\t\t      int comma, bool void_context_p, int *out_subexp,\n+\t\t      int comma, bool void_context_p,\n \t\t      innermost_block_tracker *tracker,\n \t\t      expr_completion_state *cstate)\n {\n@@ -1294,33 +539,12 @@ parse_exp_in_context (const char **stringptr, CORE_ADDR pc,\n       /* If parsing for completion, allow this to succeed; but if no\n \t expression elements have been written, then there's nothing\n \t to do, so fail.  */\n-      if (! ps.parse_completion\n-\t  || (ps.expout->op == nullptr && ps.expout_ptr == 0))\n+      if (! ps.parse_completion || ps.expout->op == nullptr)\n \tthrow;\n     }\n \n-  /* We have to operate on an \"expression *\", due to la_post_parser,\n-     which explains this funny-looking double release.  */\n   expression_up result = ps.release ();\n-\n-  /* Convert expression from postfix form as generated by yacc\n-     parser, to a prefix form.  */\n-\n-  if (expressiondebug)\n-    dump_raw_expression (result.get (), gdb_stdlog,\n-\t\t\t \"before conversion to prefix form\");\n-\n-  if (result->op == nullptr)\n-    {\n-      int subexp = prefixify_expression (result.get (),\n-\t\t\t\t\t ps.m_completion_state.expout_last_struct);\n-      if (out_subexp)\n-\t*out_subexp = subexp;\n-\n-      lang->post_parser (&result, &ps);\n-    }\n-  else\n-    result->op->set_outermost ();\n+  result->op->set_outermost ();\n \n   if (expressiondebug)\n     dump_prefix_expression (result.get (), gdb_stdlog);\n@@ -1343,7 +567,7 @@ parse_expression (const char *string, innermost_block_tracker *tracker,\n \t\t  bool void_context_p)\n {\n   expression_up exp = parse_exp_in_context (&string, 0, nullptr, 0,\n-\t\t\t\t\t    void_context_p, nullptr,\n+\t\t\t\t\t    void_context_p,\n \t\t\t\t\t    tracker, nullptr);\n   if (*string)\n     error (_(\"Junk after end of expression.\"));\n@@ -1379,14 +603,11 @@ parse_expression_for_completion (const char *string,\n \t\t\t\t enum type_code *code)\n {\n   expression_up exp;\n-  struct value *val;\n-  int subexp;\n   expr_completion_state cstate;\n \n   try\n     {\n-      exp = parse_exp_in_context (&string, 0, 0, 0, false, &subexp,\n-\t\t\t\t  nullptr, &cstate);\n+      exp = parse_exp_in_context (&string, 0, 0, 0, false, nullptr, &cstate);\n     }\n   catch (const gdb_exception_error &except)\n     {\n@@ -1403,30 +624,13 @@ parse_expression_for_completion (const char *string,\n       return NULL;\n     }\n \n-  if (cstate.expout_last_op != nullptr)\n-    {\n-      expr::structop_base_operation *op = cstate.expout_last_op;\n-      const std::string &fld = op->get_string ();\n-      *name = make_unique_xstrdup (fld.c_str ());\n-      return value_type (op->evaluate_lhs (exp.get ()));\n-    }\n+  if (cstate.expout_last_op == nullptr)\n+    return nullptr;\n \n-  if (cstate.expout_last_struct == -1)\n-    return NULL;\n-\n-  const char *fieldname = extract_field_op (exp.get (), &subexp);\n-  if (fieldname == NULL)\n-    {\n-      name->reset ();\n-      return NULL;\n-    }\n-\n-  name->reset (xstrdup (fieldname));\n-  /* This might throw an exception.  If so, we want to let it\n-     propagate.  */\n-  val = evaluate_subexpression_type (exp.get (), subexp);\n-\n-  return value_type (val);\n+  expr::structop_base_operation *op = cstate.expout_last_op;\n+  const std::string &fld = op->get_string ();\n+  *name = make_unique_xstrdup (fld.c_str ());\n+  return value_type (op->evaluate_lhs (exp.get ()));\n }\n \n /* Parse floating point value P of length LEN.\n@@ -1461,132 +665,6 @@ parser_fprintf (FILE *x, const char *y, ...)\n   va_end (args);\n }\n \n-/* Implementation of the exp_descriptor method operator_check.  */\n-\n-int\n-operator_check_standard (struct expression *exp, int pos,\n-\t\t\t int (*objfile_func) (struct objfile *objfile,\n-\t\t\t\t\t      void *data),\n-\t\t\t void *data)\n-{\n-  const union exp_element *const elts = exp->elts;\n-  struct type *type = NULL;\n-  struct objfile *objfile = NULL;\n-\n-  /* Extended operators should have been already handled by exp_descriptor\n-     iterate method of its specific language.  */\n-  gdb_assert (elts[pos].opcode < OP_EXTENDED0);\n-\n-  /* Track the callers of write_exp_elt_type for this table.  */\n-\n-  switch (elts[pos].opcode)\n-    {\n-    case BINOP_VAL:\n-    case OP_COMPLEX:\n-    case OP_FLOAT:\n-    case OP_LONG:\n-    case OP_SCOPE:\n-    case OP_TYPE:\n-    case UNOP_CAST:\n-    case UNOP_MAX:\n-    case UNOP_MEMVAL:\n-    case UNOP_MIN:\n-      type = elts[pos + 1].type;\n-      break;\n-\n-    case TYPE_INSTANCE:\n-      {\n-\tLONGEST arg, nargs = elts[pos + 2].longconst;\n-\n-\tfor (arg = 0; arg < nargs; arg++)\n-\t  {\n-\t    struct type *inst_type = elts[pos + 3 + arg].type;\n-\t    struct objfile *inst_objfile = inst_type->objfile_owner ();\n-\n-\t    if (inst_objfile && (*objfile_func) (inst_objfile, data))\n-\t      return 1;\n-\t  }\n-      }\n-      break;\n-\n-    case OP_VAR_VALUE:\n-      {\n-\tconst struct block *const block = elts[pos + 1].block;\n-\tconst struct symbol *const symbol = elts[pos + 2].symbol;\n-\n-\t/* Check objfile where the variable itself is placed.  */\n-\tif ((*objfile_func) (symbol_objfile (symbol), data))\n-\t  return 1;\n-\n-\t/* Check objfile where is placed the code touching the variable.  */\n-\tobjfile = block_objfile (block);\n-\n-\ttype = SYMBOL_TYPE (symbol);\n-      }\n-      break;\n-    case OP_VAR_MSYM_VALUE:\n-      objfile = elts[pos + 1].objfile;\n-      break;\n-    }\n-\n-  /* Invoke callbacks for TYPE and OBJFILE if they were set as non-NULL.  */\n-\n-  if (type != nullptr && type->objfile_owner () != nullptr\n-      && objfile_func (type->objfile_owner (), data))\n-    return 1;\n-\n-  if (objfile && (*objfile_func) (objfile, data))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Call OBJFILE_FUNC for any objfile found being referenced by EXP.\n-   OBJFILE_FUNC is never called with NULL OBJFILE.  OBJFILE_FUNC get\n-   passed an arbitrary caller supplied DATA pointer.  If OBJFILE_FUNC\n-   returns non-zero value then (any other) non-zero value is immediately\n-   returned to the caller.  Otherwise zero is returned after iterating\n-   through whole EXP.  */\n-\n-static int\n-exp_iterate (struct expression *exp,\n-\t     int (*objfile_func) (struct objfile *objfile, void *data),\n-\t     void *data)\n-{\n-  int endpos;\n-\n-  for (endpos = exp->nelts; endpos > 0; )\n-    {\n-      int pos, args, oplen = 0;\n-\n-      operator_length (exp, endpos, &oplen, &args);\n-      gdb_assert (oplen > 0);\n-\n-      pos = endpos - oplen;\n-      if (exp->language_defn->expression_ops ()->operator_check (exp, pos,\n-\t\t\t\t\t\t\t\t objfile_func,\n-\t\t\t\t\t\t\t\t data))\n-\treturn 1;\n-\n-      endpos = pos;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Helper for exp_uses_objfile.  */\n-\n-static int\n-exp_uses_objfile_iter (struct objfile *exp_objfile, void *objfile_voidp)\n-{\n-  struct objfile *objfile = (struct objfile *) objfile_voidp;\n-\n-  if (exp_objfile->separate_debug_objfile_backlink)\n-    exp_objfile = exp_objfile->separate_debug_objfile_backlink;\n-\n-  return exp_objfile == objfile;\n-}\n-\n /* Return 1 if EXP uses OBJFILE (and will become dangling when OBJFILE\n    is unloaded), otherwise return 0.  OBJFILE must not be a separate debug info\n    file.  */\n@@ -1596,25 +674,7 @@ exp_uses_objfile (struct expression *exp, struct objfile *objfile)\n {\n   gdb_assert (objfile->separate_debug_objfile_backlink == NULL);\n \n-  if (exp->op != nullptr)\n-    return exp->op->uses_objfile (objfile);\n-\n-  return exp_iterate (exp, exp_uses_objfile_iter, objfile);\n-}\n-\n-/* Reallocate the `expout' pointer inside PS so that it can accommodate\n-   at least LENELT expression elements.  This function does nothing if\n-   there is enough room for the elements.  */\n-\n-static void\n-increase_expout_size (struct expr_builder *ps, size_t lenelt)\n-{\n-  if ((ps->expout_ptr + lenelt) >= ps->expout_size)\n-    {\n-      ps->expout_size = std::max (ps->expout_size * 2,\n-\t\t\t\t  ps->expout_ptr + lenelt + 10);\n-      ps->expout->resize (ps->expout_size);\n-    }\n+  return exp->op->uses_objfile (objfile);\n }\n \n void _initialize_parse ();"
    },
    {
      "sha": "3e81e0b8b3cdb2ee794b061dd95457b056d7f8c2",
      "filename": "gdb/parser-defs.h",
      "status": "modified",
      "additions": 0,
      "deletions": 179,
      "changes": 179,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/parser-defs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/parser-defs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parser-defs.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -71,29 +71,15 @@ struct expr_builder\n     expout->op = std::move (op);\n   }\n \n-  /* The size of the expression above.  */\n-\n-  size_t expout_size;\n-\n   /* The expression related to this parser state.  */\n \n   expression_up expout;\n-\n-  /* The number of elements already in the expression.  This is used\n-     to know where to put new elements.  */\n-\n-  size_t expout_ptr;\n };\n \n /* This is used for expression completion.  */\n \n struct expr_completion_state\n {\n-  /* The index of the last struct expression directly before a '.' or\n-     '->'.  This is set when parsing and is only used when completing a\n-     field name.  It is -1 if no dereference operation was found.  */\n-  int expout_last_struct = -1;\n-\n   /* The last struct expression directly before a '.' or '->'.  This\n      is set when parsing and is only used when completing a field\n      name.  It is nullptr if no dereference operation was found.  */\n@@ -157,11 +143,6 @@ struct parser_state : public expr_builder\n     return val;\n   }\n \n-  /* Mark the current index as the starting location of a structure\n-     expression.  This is used when completing on field names.  */\n-\n-  void mark_struct_expression ();\n-\n   /* Mark the given operation as the starting location of a structure\n      expression.  This is used when completing on field names.  */\n \n@@ -376,173 +357,13 @@ struct objc_class_str\n     int theclass;\n   };\n \n-/* Reverse an expression from suffix form (in which it is constructed)\n-   to prefix form (in which we can conveniently print or execute it).\n-   Ordinarily this always returns -1.  However, if LAST_STRUCT\n-   is not -1 (i.e., we are trying to complete a field name), it will\n-   return the index of the subexpression which is the left-hand-side\n-   of the struct operation at LAST_STRUCT.  */\n-\n-extern int prefixify_expression (struct expression *expr,\n-\t\t\t\t int last_struct = -1);\n-\n-extern void write_exp_elt_opcode (struct expr_builder *, enum exp_opcode);\n-\n-extern void write_exp_elt_sym (struct expr_builder *, struct symbol *);\n-\n-extern void write_exp_elt_longcst (struct expr_builder *, LONGEST);\n-\n-extern void write_exp_elt_floatcst (struct expr_builder *, const gdb_byte *);\n-\n-extern void write_exp_elt_type (struct expr_builder *, struct type *);\n-\n-extern void write_exp_elt_intern (struct expr_builder *, struct internalvar *);\n-\n-extern void write_exp_string (struct expr_builder *, struct stoken);\n-\n-void write_exp_string_vector (struct expr_builder *, int type,\n-\t\t\t      struct stoken_vector *vec);\n-\n-extern void write_exp_bitstring (struct expr_builder *, struct stoken);\n-\n-extern void write_exp_elt_block (struct expr_builder *, const struct block *);\n-\n-extern void write_exp_elt_objfile (struct expr_builder *,\n-\t\t\t\t   struct objfile *objfile);\n-\n-extern void write_exp_msymbol (struct expr_builder *,\n-\t\t\t       struct bound_minimal_symbol);\n-\n-extern void write_dollar_variable (struct parser_state *, struct stoken str);\n-\n-/* Write a reference to a symbol to the expression being built in PS.\n-   NAME is the name of the symbol to write; SYM is the symbol.  If SYM\n-   is nullptr (meaning the 'symbol' member), a minimal symbol will be\n-   searched for and used if available.  Throws an exception if SYM is\n-   nullptr and no minimal symbol can be found.  */\n-\n-extern void write_exp_symbol_reference (struct parser_state *ps,\n-\t\t\t\t\tconst char *name,\n-\t\t\t\t\tstruct block_symbol sym);\n-\n extern const char *find_template_name_end (const char *);\n \n extern std::string copy_name (struct stoken);\n \n-extern int dump_subexp (struct expression *, struct ui_file *, int);\n-\n-extern int dump_subexp_body_standard (struct expression *, \n-\t\t\t\t      struct ui_file *, int);\n-\n-/* Dump (to STREAM) a function call like expression at position ELT in the\n-   expression array EXP.  Return a new value for ELT just after the\n-   function call expression.  */\n-\n-extern int dump_subexp_body_funcall (struct expression *exp,\n-\t\t\t\t     struct ui_file *stream, int elt);\n-\n-extern void operator_length (const struct expression *, int, int *, int *);\n-\n-extern void operator_length_standard (const struct expression *, int, int *,\n-\t\t\t\t      int *);\n-\n-extern int operator_check_standard (struct expression *exp, int pos,\n-\t\t\t\t    int (*objfile_func)\n-\t\t\t\t      (struct objfile *objfile, void *data),\n-\t\t\t\t    void *data);\n-\n extern bool parse_float (const char *p, int len,\n \t\t\t const struct type *type, gdb_byte *data);\n \f\n-/* These codes indicate operator precedences for expression printing,\n-   least tightly binding first.  */\n-/* Adding 1 to a precedence value is done for binary operators,\n-   on the operand which is more tightly bound, so that operators\n-   of equal precedence within that operand will get parentheses.  */\n-/* PREC_HYPER and PREC_ABOVE_COMMA are not the precedence of any operator;\n-   they are used as the \"surrounding precedence\" to force\n-   various kinds of things to be parenthesized.  */\n-enum precedence\n-  {\n-    PREC_NULL, PREC_COMMA, PREC_ABOVE_COMMA, PREC_ASSIGN, PREC_LOGICAL_OR,\n-    PREC_LOGICAL_AND, PREC_BITWISE_IOR, PREC_BITWISE_AND, PREC_BITWISE_XOR,\n-    PREC_EQUAL, PREC_ORDER, PREC_SHIFT, PREC_ADD, PREC_MUL, PREC_REPEAT,\n-    PREC_HYPER, PREC_PREFIX, PREC_SUFFIX, PREC_BUILTIN_FUNCTION\n-  };\n-\n-/* Table mapping opcodes into strings for printing operators\n-   and precedences of the operators.  */\n-\n-struct op_print\n-  {\n-    const char *string;\n-    enum exp_opcode opcode;\n-    /* Precedence of operator.  These values are used only by comparisons.  */\n-    enum precedence precedence;\n-\n-    /* For a binary operator:  1 iff right associate.\n-       For a unary operator:  1 iff postfix.  */\n-    int right_assoc;\n-  };\n-\n-/* Information needed to print, prefixify, and evaluate expressions for \n-   a given language.  */\n-\n-struct exp_descriptor\n-  {\n-    /* Print subexpression.  */\n-    void (*print_subexp) (struct expression *, int *, struct ui_file *,\n-\t\t\t  enum precedence);\n-\n-    /* Returns number of exp_elements needed to represent an operator and\n-       the number of subexpressions it takes.  */\n-    void (*operator_length) (const struct expression*, int, int*, int *);\n-\n-    /* Call OBJFILE_FUNC for any objfile found being referenced by the\n-       single operator of EXP at position POS.  Operator parameters are\n-       located at positive (POS + number) offsets in EXP.  OBJFILE_FUNC\n-       should never be called with NULL OBJFILE.  OBJFILE_FUNC should\n-       get passed an arbitrary caller supplied DATA pointer.  If it\n-       returns non-zero value then (any other) non-zero value should be\n-       immediately returned to the caller.  Otherwise zero should be\n-       returned.  */\n-    int (*operator_check) (struct expression *exp, int pos,\n-\t\t\t   int (*objfile_func) (struct objfile *objfile,\n-\t\t\t\t\t\tvoid *data),\n-\t\t\t   void *data);\n-\n-    /* Dump the rest of this (prefix) expression after the operator\n-       itself has been printed.  See dump_subexp_body_standard in\n-       (expprint.c).  */\n-    int (*dump_subexp_body) (struct expression *, struct ui_file *, int);\n-\n-    /* Evaluate an expression.  */\n-    struct value *(*evaluate_exp) (struct type *, struct expression *,\n-\t\t\t\t   int *, enum noside);\n-  };\n-\n-\n-/* Default descriptor containing standard definitions of all\n-   elements.  */\n-extern const struct exp_descriptor exp_descriptor_standard;\n-\n-/* Functions used by language-specific extended operators to (recursively)\n-   print/dump subexpressions.  */\n-\n-extern void print_subexp (struct expression *, int *, struct ui_file *,\n-\t\t\t  enum precedence);\n-\n-extern void print_subexp_standard (struct expression *, int *, \n-\t\t\t\t   struct ui_file *, enum precedence);\n-\n-/* Print a function call like expression to STREAM.  This is called as a\n-   helper function by which point the expression node identifying this as a\n-   function call has already been stripped off and POS should point to the\n-   number of function call arguments.  EXP is the object containing the\n-   list of expression elements.  */\n-\n-extern void print_subexp_funcall (struct expression *exp, int *pos,\n-\t\t\t\t  struct ui_file *stream);\n \n /* Function used to avoid direct calls to fprintf\n    in the code generated by the bison parser.  */"
    },
    {
      "sha": "f1ba165d54054eea06e31b6f4ef6c0868f305491",
      "filename": "gdb/ppc-linux-nat.c",
      "status": "modified",
      "additions": 8,
      "deletions": 17,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ppc-linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/ppc-linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-linux-nat.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -2488,33 +2488,24 @@ ppc_linux_nat_target::check_condition (CORE_ADDR watch_addr,\n \t\t\t\t       struct expression *cond,\n \t\t\t\t       CORE_ADDR *data_value, int *len)\n {\n-  int pc = 1, num_accesses_left, num_accesses_right;\n+  int num_accesses_left, num_accesses_right;\n   struct value *left_val, *right_val;\n   std::vector<value_ref_ptr> left_chain, right_chain;\n \n-  if (cond->first_opcode () != BINOP_EQUAL)\n+  expr::equal_operation *eqop\n+    = dynamic_cast<expr::equal_operation *> (cond->op.get ());\n+  if (eqop == nullptr)\n     return 0;\n+  expr::operation *lhs = eqop->get_lhs ();\n+  expr::operation *rhs = eqop->get_rhs ();\n \n-  expr::operation *lhs = nullptr;\n-  expr::operation *rhs = nullptr;\n-  if (cond->op != nullptr)\n-    {\n-      expr::equal_operation *eqop\n-\t= dynamic_cast<expr::equal_operation *> (cond->op.get ());\n-      if (eqop != nullptr)\n-\t{\n-\t  lhs = eqop->get_lhs ();\n-\t  rhs = eqop->get_rhs ();\n-\t}\n-    }\n-\n-  fetch_subexp_value (cond, &pc, lhs, &left_val, NULL, &left_chain, false);\n+  fetch_subexp_value (cond, lhs, &left_val, NULL, &left_chain, false);\n   num_accesses_left = num_memory_accesses (left_chain);\n \n   if (left_val == NULL || num_accesses_left < 0)\n     return 0;\n \n-  fetch_subexp_value (cond, &pc, rhs, &right_val, NULL, &right_chain, false);\n+  fetch_subexp_value (cond, rhs, &right_val, NULL, &right_chain, false);\n   num_accesses_right = num_memory_accesses (right_chain);\n \n   if (right_val == NULL || num_accesses_right < 0)"
    },
    {
      "sha": "2a06aea95adaf30aa8b63953057f9bab4a95482d",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 7,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -1375,14 +1375,8 @@ set_command (const char *exp, int from_tty)\n {\n   expression_up expr = parse_expression (exp);\n \n-  enum exp_opcode opcode = OP_NULL;\n   if (expr->op != nullptr)\n-    opcode = expr->op->opcode ();\n-  else if (expr->nelts >= 1)\n-    opcode = expr->elts[0].opcode;\n-\n-  if (opcode != OP_NULL)\n-    switch (opcode)\n+    switch (expr->op->opcode ())\n       {\n       case UNOP_PREINCREMENT:\n       case UNOP_POSTINCREMENT:"
    },
    {
      "sha": "ea3f974c9794fae252f9d4c9682f684615569bca",
      "filename": "gdb/rust-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/rust-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/rust-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-lang.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -209,11 +209,6 @@ class rust_language : public language_defn\n   bool range_checking_on_by_default () const override\n   { return true; }\n \n-  /* See language.h.  */\n-\n-  const struct op_print *opcode_print_table () const override\n-  { return c_op_print_tab; }\n-\n private:\n \n   /* Helper for value_print_inner, arguments are as for that function."
    },
    {
      "sha": "5995c2824dc2ba2fe198ca4c906c32548aa814a6",
      "filename": "gdb/stap-probe.c",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/stap-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/stap-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stap-probe.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -1441,15 +1441,10 @@ stap_probe::compile_to_ax (struct agent_expr *expr, struct axs_value *value,\n \t\t\t   unsigned n)\n {\n   struct stap_probe_arg *arg;\n-  union exp_element *pc;\n \n   arg = this->get_arg_by_number (n, expr->gdbarch);\n \n-  pc = arg->aexpr->elts;\n-  if (arg->aexpr->op != nullptr)\n-    arg->aexpr->op->generate_ax (arg->aexpr.get (), expr, value);\n-  else\n-    gen_expr (arg->aexpr.get (), &pc, expr, value);\n+  arg->aexpr->op->generate_ax (arg->aexpr.get (), expr, value);\n \n   require_rvalue (expr, value);\n   value->type = arg->atype;"
    },
    {
      "sha": "bf8a63c59669c8315eacb1d94cfea990315ca173",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 16,
      "deletions": 40,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -691,15 +691,10 @@ validate_actionline (const char *line, struct breakpoint *b)\n \t      if (exp->first_opcode () == OP_VAR_VALUE)\n \t\t{\n \t\t  symbol *sym;\n-\t\t  if (exp->op != nullptr)\n-\t\t    {\n-\t\t      expr::var_value_operation *vvop\n-\t\t\t= (dynamic_cast<expr::var_value_operation *>\n-\t\t\t   (exp->op.get ()));\n-\t\t      sym = vvop->get_symbol ();\n-\t\t    }\n-\t\t  else\n-\t\t    sym = exp->elts[2].symbol;\n+\t\t  expr::var_value_operation *vvop\n+\t\t    = (dynamic_cast<expr::var_value_operation *>\n+\t\t       (exp->op.get ()));\n+\t\t  sym = vvop->get_symbol ();\n \n \t\t  if (SYMBOL_CLASS (sym) == LOC_CONST)\n \t\t    {\n@@ -1395,16 +1390,10 @@ encode_actions_1 (struct command_line *action,\n \t\t    {\n \t\t    case OP_REGISTER:\n \t\t      {\n-\t\t\tconst char *name;\n-\t\t\tif (exp->op != nullptr)\n-\t\t\t  {\n-\t\t\t    expr::register_operation *regop\n-\t\t\t      = (dynamic_cast<expr::register_operation *>\n-\t\t\t\t (exp->op.get ()));\n-\t\t\t    name = regop->get_name ();\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  name = &exp->elts[2].string;\n+\t\t\texpr::register_operation *regop\n+\t\t\t  = (dynamic_cast<expr::register_operation *>\n+\t\t\t     (exp->op.get ()));\n+\t\t\tconst char *name = regop->get_name ();\n \n \t\t\ti = user_reg_map_name_to_regnum (target_gdbarch (),\n \t\t\t\t\t\t\t name, strlen (name));\n@@ -1424,16 +1413,10 @@ encode_actions_1 (struct command_line *action,\n \t\t\t/* Safe because we know it's a simple expression.  */\n \t\t\ttempval = evaluate_expression (exp.get ());\n \t\t\taddr = value_address (tempval);\n-\t\t\tstruct type *type;\n-\t\t\tif (exp->op != nullptr)\n-\t\t\t  {\n-\t\t\t    expr::unop_memval_operation *memop\n-\t\t\t      = (dynamic_cast<expr::unop_memval_operation *>\n-\t\t\t\t (exp->op.get ()));\n-\t\t\t    type = memop->get_type ();\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  type = exp->elts[1].type;\n+\t\t\texpr::unop_memval_operation *memop\n+\t\t\t  = (dynamic_cast<expr::unop_memval_operation *>\n+\t\t\t     (exp->op.get ()));\n+\t\t\tstruct type *type = memop->get_type ();\n \t\t\t/* Initialize the TYPE_LENGTH if it is a typedef.  */\n \t\t\tcheck_typedef (type);\n \t\t\tcollect->add_memrange (target_gdbarch (),\n@@ -1447,17 +1430,10 @@ encode_actions_1 (struct command_line *action,\n \n \t\t    case OP_VAR_VALUE:\n \t\t      {\n-\t\t\tstruct symbol *sym;\n-\n-\t\t\tif (exp->op != nullptr)\n-\t\t\t  {\n-\t\t\t    expr::var_value_operation *vvo\n-\t\t\t      = (dynamic_cast<expr::var_value_operation *>\n-\t\t\t\t (exp->op.get ()));\n-\t\t\t    sym = vvo->get_symbol ();\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  sym = exp->elts[2].symbol;\n+\t\t\texpr::var_value_operation *vvo\n+\t\t\t  = (dynamic_cast<expr::var_value_operation *>\n+\t\t\t     (exp->op.get ()));\n+\t\t\tstruct symbol *sym = vvo->get_symbol ();\n \t\t\tconst char *name = sym->natural_name ();\n \n \t\t\tcollect->collect_symbol (sym,"
    },
    {
      "sha": "df0e5c19f8cb054adf11dcdf95ab0c15481c8b92",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 10,
      "deletions": 20,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -2015,29 +2015,19 @@ init_if_undefined_command (const char* args, int from_tty)\n   /* Validate the expression.\n      Was the expression an assignment?\n      Or even an expression at all?  */\n-  if ((expr->nelts == 0 && expr->op == nullptr)\n-      || expr->first_opcode () != BINOP_ASSIGN)\n+  if (expr->op == nullptr || expr->first_opcode () != BINOP_ASSIGN)\n     error (_(\"Init-if-undefined requires an assignment expression.\"));\n \n-  /* Extract the variable from the parsed expression.\n-     In the case of an assign the lvalue will be in elts[1] and elts[2].  */\n-  if (expr->op == nullptr)\n+  /* Extract the variable from the parsed expression.  */\n+  expr::assign_operation *assign\n+    = dynamic_cast<expr::assign_operation *> (expr->op.get ());\n+  if (assign != nullptr)\n     {\n-      if (expr->elts[1].opcode == OP_INTERNALVAR)\n-\tintvar = expr->elts[2].internalvar;\n-    }\n-  else\n-    {\n-      expr::assign_operation *assign\n-\t= dynamic_cast<expr::assign_operation *> (expr->op.get ());\n-      if (assign != nullptr)\n-\t{\n-\t  expr::operation *lhs = assign->get_lhs ();\n-\t  expr::internalvar_operation *ivarop\n-\t    = dynamic_cast<expr::internalvar_operation *> (lhs);\n-\t  if (ivarop != nullptr)\n-\t    intvar = ivarop->get_internalvar ();\n-\t}\n+      expr::operation *lhs = assign->get_lhs ();\n+      expr::internalvar_operation *ivarop\n+\t= dynamic_cast<expr::internalvar_operation *> (lhs);\n+      if (ivarop != nullptr)\n+\tintvar = ivarop->get_internalvar ();\n     }\n \n   if (intvar == nullptr)"
    },
    {
      "sha": "21df6c2a1e1727824ced23dc6cad8b0fecf00b3b",
      "filename": "gdb/value.h",
      "status": "modified",
      "additions": 1,
      "deletions": 13,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/value.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eaebe02cfe78229d78ac27f5bd6651e1c1af863/gdb/value.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.h?ref=1eaebe02cfe78229d78ac27f5bd6651e1c1af863",
      "patch": "@@ -914,13 +914,6 @@ extern struct value *evaluate_expression (struct expression *exp,\n \n extern struct value *evaluate_type (struct expression *exp);\n \n-extern struct value *evaluate_subexp (struct type *expect_type,\n-\t\t\t\t      struct expression *exp,\n-\t\t\t\t      int *pos, enum noside noside);\n-\n-extern struct value *evaluate_subexpression_type (struct expression *exp,\n-\t\t\t\t\t\t  int subexp);\n-\n extern value *evaluate_var_value (enum noside noside, const block *blk,\n \t\t\t\t  symbol *var);\n \n@@ -931,17 +924,12 @@ extern value *evaluate_var_msym_value (enum noside noside,\n extern value *eval_skip_value (expression *exp);\n \n namespace expr { class operation; };\n-extern void fetch_subexp_value (struct expression *exp, int *pc,\n+extern void fetch_subexp_value (struct expression *exp,\n \t\t\t\texpr::operation *op,\n \t\t\t\tstruct value **valp, struct value **resultp,\n \t\t\t\tstd::vector<value_ref_ptr> *val_chain,\n \t\t\t\tbool preserve_errors);\n \n-extern const char *extract_field_op (struct expression *exp, int *subexp);\n-\n-extern struct value *evaluate_subexp_with_coercion (struct expression *,\n-\t\t\t\t\t\t    int *, enum noside);\n-\n extern struct value *parse_and_eval (const char *exp);\n \n extern struct value *parse_to_comma_and_eval (const char **expp);"
    }
  ]
}