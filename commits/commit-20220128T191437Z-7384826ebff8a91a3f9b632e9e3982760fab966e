{
  "sha": "7384826ebff8a91a3f9b632e9e3982760fab966e",
  "node_id": "C_kwDOANOeidoAKDczODQ4MjZlYmZmOGE5MWEzZjliNjMyZTllMzk4Mjc2MGZhYjk2NmU",
  "commit": {
    "author": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-01-28T19:14:37Z"
    },
    "committer": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-01-28T19:14:37Z"
    },
    "message": "FreeBSD x86: Use tramp-frame for signal frames.\n\nUse a register map to describe the registers in mcontext_t as part of\nthe signal frame as is done on several other FreeBSD arches.  This\npermits fetching the fsbase and gsbase register values from the signal\nframe for both amd64 and i386 and permits fetching additional segment\nregisters stored as 16-bit values on amd64.\n\nWhile signal frames on FreeBSD do contain floating point/XSAVE state,\nthese unwinders do not attempt to supply those registers.  The\nexisting x86 signal frame uwinders do not support these registers, and\nthe only existing functions which handle FSAVE/FXSAVE/XSAVE state all\nwork with regcaches.  In the future these unwinders could create a\ntempory regcache, collect floating point registers, and then supply\nvalues out of the regcache into the trad-frame.",
    "tree": {
      "sha": "c1a7e3eff5562eeec53ac44686864a8873fbfb4a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c1a7e3eff5562eeec53ac44686864a8873fbfb4a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7384826ebff8a91a3f9b632e9e3982760fab966e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7384826ebff8a91a3f9b632e9e3982760fab966e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7384826ebff8a91a3f9b632e9e3982760fab966e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7384826ebff8a91a3f9b632e9e3982760fab966e/comments",
  "author": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a423c9f39294b5cc6f658a145f3844d19f3f3cf1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a423c9f39294b5cc6f658a145f3844d19f3f3cf1",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a423c9f39294b5cc6f658a145f3844d19f3f3cf1"
    }
  ],
  "stats": {
    "total": 494,
    "additions": 266,
    "deletions": 228
  },
  "files": [
    {
      "sha": "f9bd45de4554de2248cac4554deccb75d8789676",
      "filename": "gdb/amd64-fbsd-nat.c",
      "status": "modified",
      "additions": 0,
      "deletions": 58,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/amd64-fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/amd64-fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-fbsd-nat.c?ref=7384826ebff8a91a3f9b632e9e3982760fab966e",
      "patch": "@@ -213,69 +213,11 @@ void _initialize_amd64fbsd_nat ();\n void\n _initialize_amd64fbsd_nat ()\n {\n-  int offset;\n-\n   amd64_native_gregset32_reg_offset = amd64fbsd32_r_reg_offset;\n   amd64_native_gregset64_reg_offset = amd64fbsd64_r_reg_offset;\n \n   add_inf_child_target (&the_amd64_fbsd_nat_target);\n \n   /* Support debugging kernel virtual memory images.  */\n   bsd_kvm_add_target (amd64fbsd_supply_pcb);\n-\n-  /* To support the recognition of signal handlers, i386-bsd-tdep.c\n-     hardcodes some constants.  Inclusion of this file means that we\n-     are compiling a native debugger, which means that we can use the\n-     system header files and sysctl(3) to get at the relevant\n-     information.  */\n-\n-#define SC_REG_OFFSET amd64fbsd_sc_reg_offset\n-\n-  /* We only check the program counter, stack pointer and frame\n-     pointer since these members of `struct sigcontext' are essential\n-     for providing backtraces.  */\n-\n-#define SC_RIP_OFFSET SC_REG_OFFSET[AMD64_RIP_REGNUM]\n-#define SC_RSP_OFFSET SC_REG_OFFSET[AMD64_RSP_REGNUM]\n-#define SC_RBP_OFFSET SC_REG_OFFSET[AMD64_RBP_REGNUM]\n-\n-  /* Override the default value for the offset of the program counter\n-     in the sigcontext structure.  */\n-  offset = offsetof (struct sigcontext, sc_rip);\n-\n-  if (SC_RIP_OFFSET != offset)\n-    {\n-      warning (_(\"\\\n-offsetof (struct sigcontext, sc_rip) yields %d instead of %d.\\n\\\n-Please report this to <bug-gdb@gnu.org>.\"),\n-\t       offset, SC_RIP_OFFSET);\n-    }\n-\n-  SC_RIP_OFFSET = offset;\n-\n-  /* Likewise for the stack pointer.  */\n-  offset = offsetof (struct sigcontext, sc_rsp);\n-\n-  if (SC_RSP_OFFSET != offset)\n-    {\n-      warning (_(\"\\\n-offsetof (struct sigcontext, sc_rsp) yields %d instead of %d.\\n\\\n-Please report this to <bug-gdb@gnu.org>.\"),\n-\t       offset, SC_RSP_OFFSET);\n-    }\n-\n-  SC_RSP_OFFSET = offset;\n-\n-  /* And the frame pointer.  */\n-  offset = offsetof (struct sigcontext, sc_rbp);\n-\n-  if (SC_RBP_OFFSET != offset)\n-    {\n-      warning (_(\"\\\n-offsetof (struct sigcontext, sc_rbp) yields %d instead of %d.\\n\\\n-Please report this to <bug-gdb@gnu.org>.\"),\n-\t       offset, SC_RBP_OFFSET);\n-    }\n-\n-  SC_RBP_OFFSET = offset;\n }"
    },
    {
      "sha": "fa363776fc01aa75fd0b5969dcb149c0241627d7",
      "filename": "gdb/amd64-fbsd-tdep.c",
      "status": "modified",
      "additions": 115,
      "deletions": 70,
      "changes": 185,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/amd64-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/amd64-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-fbsd-tdep.c?ref=7384826ebff8a91a3f9b632e9e3982760fab966e",
      "patch": "@@ -18,12 +18,11 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n-#include \"arch-utils.h\"\n-#include \"frame.h\"\n-#include \"gdbcore.h\"\n-#include \"regcache.h\"\n #include \"osabi.h\"\n #include \"regset.h\"\n+#include \"target.h\"\n+#include \"trad-frame.h\"\n+#include \"tramp-frame.h\"\n #include \"i386-fbsd-tdep.h\"\n #include \"gdbsupport/x86-xstate.h\"\n \n@@ -70,6 +69,49 @@ static const struct regcache_map_entry amd64_fbsd_gregmap[] =\n   { 0 }\n };\n \n+/* This layout including fsbase and gsbase was adopted in FreeBSD\n+   8.0.  */\n+\n+static const struct regcache_map_entry amd64_fbsd_mcregmap[] =\n+{\n+  { 1, REGCACHE_MAP_SKIP, 8 },\t/* mc_onstack */\n+  { 1, AMD64_RDI_REGNUM, 0 },\n+  { 1, AMD64_RSI_REGNUM, 0 },\n+  { 1, AMD64_RDX_REGNUM, 0 },\n+  { 1, AMD64_RCX_REGNUM, 0 },\n+  { 1, AMD64_R8_REGNUM, 0 },\n+  { 1, AMD64_R9_REGNUM, 0 },\n+  { 1, AMD64_RAX_REGNUM, 0 },\n+  { 1, AMD64_RBX_REGNUM, 0 },\n+  { 1, AMD64_RBP_REGNUM, 0 },\n+  { 1, AMD64_R10_REGNUM, 0 },\n+  { 1, AMD64_R11_REGNUM, 0 },\n+  { 1, AMD64_R12_REGNUM, 0 },\n+  { 1, AMD64_R13_REGNUM, 0 },\n+  { 1, AMD64_R14_REGNUM, 0 },\n+  { 1, AMD64_R15_REGNUM, 0 },\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_trapno */\n+  { 1, AMD64_FS_REGNUM, 2 },\n+  { 1, AMD64_GS_REGNUM, 2 },\n+  { 1, REGCACHE_MAP_SKIP, 8 },\t/* mc_addr */\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_flags */\n+  { 1, AMD64_ES_REGNUM, 2 },\n+  { 1, AMD64_DS_REGNUM, 2 },\n+  { 1, REGCACHE_MAP_SKIP, 8 },\t/* mc_err */\n+  { 1, AMD64_RIP_REGNUM, 0 },\n+  { 1, AMD64_CS_REGNUM, 8 },\n+  { 1, AMD64_EFLAGS_REGNUM, 8 },\n+  { 1, AMD64_RSP_REGNUM, 0 },\n+  { 1, AMD64_SS_REGNUM, 8 },\n+  { 1, REGCACHE_MAP_SKIP, 8 },\t/* mc_len */\n+  { 1, REGCACHE_MAP_SKIP, 8 },\t/* mc_fpformat */\n+  { 1, REGCACHE_MAP_SKIP, 8 },\t/* mc_ownedfp */\n+  { 64, REGCACHE_MAP_SKIP, 8 },\t/* mc_fpstate */\n+  { 1, AMD64_FSBASE_REGNUM, 0 },\n+  { 1, AMD64_GSBASE_REGNUM, 0 },\n+  { 0 }\n+};\n+\n /* Register set definitions.  */\n \n const struct regset amd64_fbsd_gregset =\n@@ -79,80 +121,86 @@ const struct regset amd64_fbsd_gregset =\n \n /* Support for signal handlers.  */\n \n-/* Return whether THIS_FRAME corresponds to a FreeBSD sigtramp\n-   routine.  */\n+/* In a signal frame, rsp points to a 'struct sigframe' which is\n+   defined as:\n \n-static const gdb_byte amd64fbsd_sigtramp_code[] =\n-{\n-  0x48, 0x8d, 0x7c, 0x24, 0x10, /* lea     SIGF_UC(%rsp),%rdi */\n-  0x6a, 0x00,\t\t\t/* pushq   $0 */\n-  0x48, 0xc7, 0xc0, 0xa1, 0x01, 0x00, 0x00,\n-\t\t\t\t/* movq    $SYS_sigreturn,%rax */\n-  0x0f, 0x05                    /* syscall */\n-};\n+   struct sigframe {\n+\tunion {\n+\t\t__siginfohandler_t\t*sf_action;\n+\t\t__sighandler_t\t\t*sf_handler;\n+\t} sf_ahu;\n+\tucontext_t\tsf_uc;\n+        ...\n+   }\n \n-static int\n-amd64fbsd_sigtramp_p (struct frame_info *this_frame)\n-{\n-  CORE_ADDR pc = get_frame_pc (this_frame);\n-  gdb_byte buf[sizeof amd64fbsd_sigtramp_code];\n+   ucontext_t is defined as:\n \n-  if (!safe_frame_unwind_memory (this_frame, pc, buf))\n-    return 0;\n-  if (memcmp (buf, amd64fbsd_sigtramp_code, sizeof amd64fbsd_sigtramp_code)\n-      != 0)\n-    return 0;\n+   struct __ucontext {\n+\t   sigset_t\tuc_sigmask;\n+\t   mcontext_t\tuc_mcontext;\n+\t   ...\n+   };\n \n-  return 1;\n-}\n+   The mcontext_t contains the general purpose register set as well\n+   as the floating point or XSAVE state.  */\n \n-/* Assuming THIS_FRAME is for a BSD sigtramp routine, return the\n-   address of the associated sigcontext structure.  */\n+/* NB: There is an 8 byte padding hole between sf_ahu and sf_uc. */\n+#define AMD64_SIGFRAME_UCONTEXT_OFFSET \t\t16\n+#define AMD64_UCONTEXT_MCONTEXT_OFFSET\t\t16\n+#define AMD64_SIZEOF_MCONTEXT_T\t\t\t800\n \n-static CORE_ADDR\n-amd64fbsd_sigcontext_addr (struct frame_info *this_frame)\n+/* Implement the \"init\" method of struct tramp_frame.  */\n+\n+static void\n+amd64_fbsd_sigframe_init (const struct tramp_frame *self,\n+\t\t\t  struct frame_info *this_frame,\n+\t\t\t  struct trad_frame_cache *this_cache,\n+\t\t\t  CORE_ADDR func)\n {\n   struct gdbarch *gdbarch = get_frame_arch (this_frame);\n   enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n-  CORE_ADDR sp;\n-  gdb_byte buf[8];\n-\n-  /* The `struct sigcontext' (which really is an `ucontext_t' on\n-     FreeBSD/amd64) lives at a fixed offset in the signal frame.  See\n-     <machine/sigframe.h>.  */\n-  get_frame_register (this_frame, AMD64_RSP_REGNUM, buf);\n-  sp = extract_unsigned_integer (buf, 8, byte_order);\n-  return sp + 16;\n+  CORE_ADDR sp = get_frame_register_unsigned (this_frame, AMD64_RSP_REGNUM);\n+  CORE_ADDR mcontext_addr\n+    = (sp\n+       + AMD64_SIGFRAME_UCONTEXT_OFFSET\n+       + AMD64_UCONTEXT_MCONTEXT_OFFSET);\n+\n+  trad_frame_set_reg_regmap (this_cache, amd64_fbsd_mcregmap, mcontext_addr,\n+\t\t\t     AMD64_SIZEOF_MCONTEXT_T);\n+\n+  /* Don't bother with floating point or XSAVE state for now.  The\n+     current helper routines for parsing FXSAVE and XSAVE state only\n+     work with regcaches.  This could perhaps create a temporary\n+     regcache, collect the register values from mc_fpstate and\n+     mc_xfpustate, and then set register values in the trad_frame.  */\n+\n+  trad_frame_set_id (this_cache, frame_id_build (sp, func));\n }\n-\f\n \n-/* From <machine/signal.h>.  */\n-int amd64fbsd_sc_reg_offset[] =\n+static const struct tramp_frame amd64_fbsd_sigframe =\n {\n-  24 + 6 * 8,\t\t\t/* %rax */\n-  24 + 7 * 8,\t\t\t/* %rbx */\n-  24 + 3 * 8,\t\t\t/* %rcx */\n-  24 + 2 * 8,\t\t\t/* %rdx */\n-  24 + 1 * 8,\t\t\t/* %rsi */\n-  24 + 0 * 8,\t\t\t/* %rdi */\n-  24 + 8 * 8,\t\t\t/* %rbp */\n-  24 + 22 * 8,\t\t\t/* %rsp */\n-  24 + 4 * 8,\t\t\t/* %r8 ...  */\n-  24 + 5 * 8,\n-  24 + 9 * 8,\n-  24 + 10 * 8,\n-  24 + 11 * 8,\n-  24 + 12 * 8,\n-  24 + 13 * 8,\n-  24 + 14 * 8,\t\t\t/* ... %r15 */\n-  24 + 19 * 8,\t\t\t/* %rip */\n-  24 + 21 * 8,\t\t\t/* %eflags */\n-  24 + 20 * 8,\t\t\t/* %cs */\n-  24 + 23 * 8,\t\t\t/* %ss */\n-  -1,\t\t\t\t/* %ds */\n-  -1,\t\t\t\t/* %es */\n-  -1,\t\t\t\t/* %fs */\n-  -1\t\t\t\t/* %gs */\n+  SIGTRAMP_FRAME,\n+  1,\n+  {\n+    {0x48, ULONGEST_MAX},\t\t/* lea\t   SIGF_UC(%rsp),%rdi */\n+    {0x8d, ULONGEST_MAX},\n+    {0x7c, ULONGEST_MAX},\n+    {0x24, ULONGEST_MAX},\n+    {0x10, ULONGEST_MAX},\n+    {0x6a, ULONGEST_MAX},\t\t/* pushq   $0 */\n+    {0x00, ULONGEST_MAX},\n+    {0x48, ULONGEST_MAX},\t\t/* movq\t   $SYS_sigreturn,%rax */\n+    {0xc7, ULONGEST_MAX},\n+    {0xc0, ULONGEST_MAX},\n+    {0xa1, ULONGEST_MAX},\n+    {0x01, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x0f, ULONGEST_MAX},\t\t/* syscall */\n+    {0x05, ULONGEST_MAX},\n+    {TRAMP_SENTINEL_INSN, ULONGEST_MAX}\n+  },\n+  amd64_fbsd_sigframe_init\n };\n \n /* Implement the core_read_description gdbarch method.  */\n@@ -245,10 +293,7 @@ amd64fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   amd64_init_abi (info, gdbarch,\n \t\t  amd64_target_description (X86_XSTATE_SSE_MASK, true));\n \n-  tdep->sigtramp_p = amd64fbsd_sigtramp_p;\n-  tdep->sigcontext_addr = amd64fbsd_sigcontext_addr;\n-  tdep->sc_reg_offset = amd64fbsd_sc_reg_offset;\n-  tdep->sc_num_regs = ARRAY_SIZE (amd64fbsd_sc_reg_offset);\n+  tramp_frame_prepend_unwinder (gdbarch, &amd64_fbsd_sigframe);\n \n   tdep->xsave_xcr0_offset = I386_FBSD_XSAVE_XCR0_OFFSET;\n "
    },
    {
      "sha": "c18766e71c46a5db593d4d20a8939cf98bf3204b",
      "filename": "gdb/amd64-tdep.h",
      "status": "modified",
      "additions": 0,
      "deletions": 3,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/amd64-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/amd64-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-tdep.h?ref=7384826ebff8a91a3f9b632e9e3982760fab966e",
      "patch": "@@ -144,7 +144,4 @@ extern int amd64nbsd_r_reg_offset[];\n /* Variables exported from amd64-obsd-tdep.c.  */\n extern int amd64obsd_r_reg_offset[];\n \n-/* Variables exported from amd64-fbsd-tdep.c.  */\n-extern int amd64fbsd_sc_reg_offset[];\n-\n #endif /* amd64-tdep.h */"
    },
    {
      "sha": "c112b02c2e1ba8418edb47bbd632f871c2c1fdf4",
      "filename": "gdb/i386-bsd-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/i386-bsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/i386-bsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-bsd-nat.c?ref=7384826ebff8a91a3f9b632e9e3982760fab966e",
      "patch": "@@ -350,9 +350,7 @@ _initialize_i386bsd_nat ()\n      system header files and sysctl(3) to get at the relevant\n      information.  */\n \n-#if defined (__FreeBSD_version)\n-#define SC_REG_OFFSET i386fbsd_sc_reg_offset\n-#elif defined (OpenBSD)\n+#if defined (OpenBSD)\n #define SC_REG_OFFSET i386obsd_sc_reg_offset\n #endif\n "
    },
    {
      "sha": "6a656ddf09c2179d9f629c7dd85d57d05f595ed5",
      "filename": "gdb/i386-fbsd-tdep.c",
      "status": "modified",
      "additions": 150,
      "deletions": 93,
      "changes": 243,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/i386-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/i386-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-fbsd-tdep.c?ref=7384826ebff8a91a3f9b632e9e3982760fab966e",
      "patch": "@@ -18,11 +18,11 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n-#include \"arch-utils.h\"\n-#include \"gdbcore.h\"\n #include \"osabi.h\"\n #include \"regcache.h\"\n #include \"regset.h\"\n+#include \"trad-frame.h\"\n+#include \"tramp-frame.h\"\n #include \"i386-fbsd-tdep.h\"\n #include \"gdbsupport/x86-xstate.h\"\n \n@@ -61,6 +61,41 @@ static const struct regcache_map_entry i386_fbsd_gregmap[] =\n   { 0 }\n };\n \n+/* This layout including fsbase and gsbase was adopted in FreeBSD\n+   8.0.  */\n+\n+static const struct regcache_map_entry i386_fbsd_mcregmap[] =\n+{\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_onstack */\n+  { 1, I386_GS_REGNUM, 4 },\n+  { 1, I386_FS_REGNUM, 4 },\n+  { 1, I386_ES_REGNUM, 4 },\n+  { 1, I386_DS_REGNUM, 4 },\n+  { 1, I386_EDI_REGNUM, 0 },\n+  { 1, I386_ESI_REGNUM, 0 },\n+  { 1, I386_EBP_REGNUM, 0 },\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* isp */\n+  { 1, I386_EBX_REGNUM, 0 },\n+  { 1, I386_EDX_REGNUM, 0 },\n+  { 1, I386_ECX_REGNUM, 0 },\n+  { 1, I386_EAX_REGNUM, 0 },\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_trapno */\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_err */\n+  { 1, I386_EIP_REGNUM, 0 },\n+  { 1, I386_CS_REGNUM, 4 },\n+  { 1, I386_EFLAGS_REGNUM, 0 },\n+  { 1, I386_ESP_REGNUM, 0 },\n+  { 1, I386_SS_REGNUM, 4 },\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_len */\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_fpformat */\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_ownedfp */\n+  { 1, REGCACHE_MAP_SKIP, 4 },\t/* mc_flags */\n+  { 128, REGCACHE_MAP_SKIP, 4 },/* mc_fpstate */\n+  { 1, I386_FSBASE_REGNUM, 0 },\n+  { 1, I386_GSBASE_REGNUM, 0 },\n+  { 0 }\n+};\n+\n /* Register set definitions.  */\n \n const struct regset i386_fbsd_gregset =\n@@ -70,102 +105,127 @@ const struct regset i386_fbsd_gregset =\n \n /* Support for signal handlers.  */\n \n-/* Return whether THIS_FRAME corresponds to a FreeBSD sigtramp\n-   routine.  */\n+/* In a signal frame, esp points to a 'struct sigframe' which is\n+   defined as:\n \n-/* FreeBSD/i386 binaries running under an amd64 kernel use a different\n-   trampoline This trampoline differs from the i386 kernel trampoline\n-   in that it omits a middle section that conditionally restores\n-   %gs.  */\n+   struct sigframe {\n+\tregister_t\tsf_signum;\n+\tregister_t\tsf_siginfo;\n+\tregister_t\tsf_ucontext;\n+\tregister_t\tsf_addr;\n+\tunion {\n+\t\t__siginfohandler_t\t*sf_action;\n+\t\t__sighandler_t\t\t*sf_handler;\n+\t} sf_ahu;\n+\tucontext_t\tsf_uc;\n+        ...\n+   }\n \n-static const gdb_byte i386fbsd_sigtramp_start[] =\n-{\n-  0x8d, 0x44, 0x24, 0x20,       /* lea     SIGF_UC(%esp),%eax */\n-  0x50\t\t\t\t/* pushl   %eax */\n-};\n+   ucontext_t is defined as:\n \n-static const gdb_byte i386fbsd_sigtramp_middle[] =\n-{\n-  0xf7, 0x40, 0x54, 0x00, 0x00, 0x02, 0x00,\n-\t\t\t\t/* testl   $PSL_VM,UC_EFLAGS(%eax) */\n-  0x75, 0x03,\t\t\t/* jne\t   +3 */\n-  0x8e, 0x68, 0x14\t\t/* mov\t   UC_GS(%eax),%gs */\n-};\n+   struct __ucontext {\n+\t   sigset_t\tuc_sigmask;\n+\t   mcontext_t\tuc_mcontext;\n+\t   ...\n+   };\n \n-static const gdb_byte i386fbsd_sigtramp_end[] =\n-{\n-  0xb8, 0xa1, 0x01, 0x00, 0x00, /* movl   $SYS_sigreturn,%eax */\n-  0x50,\t\t\t/* pushl   %eax */\n-  0xcd, 0x80\t\t\t/* int\t   $0x80 */\n-};\n+   The mcontext_t contains the general purpose register set as well\n+   as the floating point or XSAVE state.  */\n \n-/* We assume that the middle is the largest chunk below.  */\n-gdb_static_assert (sizeof i386fbsd_sigtramp_middle\n-\t\t   > sizeof i386fbsd_sigtramp_start);\n-gdb_static_assert (sizeof i386fbsd_sigtramp_middle\n-\t\t   > sizeof i386fbsd_sigtramp_end);\n+/* NB: There is a 12 byte padding hole between sf_ahu and sf_uc. */\n+#define I386_SIGFRAME_UCONTEXT_OFFSET \t\t32\n+#define I386_UCONTEXT_MCONTEXT_OFFSET\t\t16\n+#define I386_SIZEOF_MCONTEXT_T\t\t\t640\n \n-static int\n-i386fbsd_sigtramp_p (struct frame_info *this_frame)\n+/* Implement the \"init\" method of struct tramp_frame.  */\n+\n+static void\n+i386_fbsd_sigframe_init (const struct tramp_frame *self,\n+\t\t\t struct frame_info *this_frame,\n+\t\t\t struct trad_frame_cache *this_cache,\n+\t\t\t CORE_ADDR func)\n {\n-  CORE_ADDR pc = get_frame_pc (this_frame);\n-  gdb_byte buf[sizeof i386fbsd_sigtramp_middle];\n-\n-  /* Look for a matching start.  */\n-  if (!safe_frame_unwind_memory (this_frame, pc,\n-\t\t\t\t {buf, sizeof i386fbsd_sigtramp_start}))\n-    return 0;\n-  if (memcmp (buf, i386fbsd_sigtramp_start, sizeof i386fbsd_sigtramp_start)\n-      != 0)\n-    return 0;\n-\n-  /* Since the end is shorter than the middle, check for a matching end\n-     next.  */\n-  pc += sizeof i386fbsd_sigtramp_start;\n-  if (!safe_frame_unwind_memory (this_frame, pc,\n-\t\t\t\t {buf, sizeof i386fbsd_sigtramp_end}))\n-    return 0;\n-  if (memcmp (buf, i386fbsd_sigtramp_end, sizeof i386fbsd_sigtramp_end) == 0)\n-    return 1;\n-\n-  /* If the end didn't match, check for a matching middle.  */\n-  if (!safe_frame_unwind_memory (this_frame, pc,\n-\t\t\t\t {buf, sizeof i386fbsd_sigtramp_middle}))\n-    return 0;\n-  if (memcmp (buf, i386fbsd_sigtramp_middle, sizeof i386fbsd_sigtramp_middle)\n-      != 0)\n-    return 0;\n-\n-  /* The middle matched, check for a matching end.  */\n-  pc += sizeof i386fbsd_sigtramp_middle;\n-  if (!safe_frame_unwind_memory (this_frame, pc,\n-\t\t\t\t {buf, sizeof i386fbsd_sigtramp_end}))\n-    return 0;\n-  if (memcmp (buf, i386fbsd_sigtramp_end, sizeof i386fbsd_sigtramp_end) != 0)\n-    return 0;\n-\n-  return 1;\n+  struct gdbarch *gdbarch = get_frame_arch (this_frame);\n+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+  CORE_ADDR sp = get_frame_register_unsigned (this_frame, I386_ESP_REGNUM);\n+  CORE_ADDR mcontext_addr\n+    = (sp\n+       + I386_SIGFRAME_UCONTEXT_OFFSET\n+       + I386_UCONTEXT_MCONTEXT_OFFSET);\n+\n+  trad_frame_set_reg_regmap (this_cache, i386_fbsd_mcregmap, mcontext_addr,\n+\t\t\t     I386_SIZEOF_MCONTEXT_T);\n+\n+  /* Don't bother with floating point or XSAVE state for now.  The\n+     current helper routines for parsing FXSAVE and XSAVE state only\n+     work with regcaches.  This could perhaps create a temporary\n+     regcache, collect the register values from mc_fpstate and\n+     mc_xfpustate, and then set register values in the trad_frame.  */\n+\n+  trad_frame_set_id (this_cache, frame_id_build (sp, func));\n }\n \n-/* From <machine/signal.h>.  */\n-int i386fbsd_sc_reg_offset[] =\n+static const struct tramp_frame i386_fbsd_sigframe =\n {\n-  20 + 11 * 4,\t\t\t/* %eax */\n-  20 + 10 * 4,\t\t\t/* %ecx */\n-  20 + 9 * 4,\t\t\t/* %edx */\n-  20 + 8 * 4,\t\t\t/* %ebx */\n-  20 + 17 * 4,\t\t\t/* %esp */\n-  20 + 6 * 4,\t\t\t/* %ebp */\n-  20 + 5 * 4,\t\t\t/* %esi */\n-  20 + 4 * 4,\t\t\t/* %edi */\n-  20 + 14 * 4,\t\t\t/* %eip */\n-  20 + 16 * 4,\t\t\t/* %eflags */\n-  20 + 15 * 4,\t\t\t/* %cs */\n-  20 + 18 * 4,\t\t\t/* %ss */\n-  20 + 3 * 4,\t\t\t/* %ds */\n-  20 + 2 * 4,\t\t\t/* %es */\n-  20 + 1 * 4,\t\t\t/* %fs */\n-  20 + 0 * 4\t\t\t/* %gs */\n+  SIGTRAMP_FRAME,\n+  1,\n+  {\n+    {0x8d, ULONGEST_MAX},\t\t/* lea     SIGF_UC(%esp),%eax */\n+    {0x44, ULONGEST_MAX},\n+    {0x24, ULONGEST_MAX},\n+    {0x20, ULONGEST_MAX},\n+    {0x50, ULONGEST_MAX},\t\t/* pushl   %eax */\n+    {0xf7, ULONGEST_MAX},\t\t/* testl   $PSL_VM,UC_EFLAGS(%eax) */\n+    {0x40, ULONGEST_MAX},\n+    {0x54, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x02, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x75, ULONGEST_MAX},\t\t/* jne\t   +3 */\n+    {0x03, ULONGEST_MAX},\n+    {0x8e, ULONGEST_MAX},\t\t/* mov\t   UC_GS(%eax),%gs */\n+    {0x68, ULONGEST_MAX},\n+    {0x14, ULONGEST_MAX},\n+    {0xb8, ULONGEST_MAX},\t\t/* movl   $SYS_sigreturn,%eax */\n+    {0xa1, ULONGEST_MAX},\n+    {0x01, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x50, ULONGEST_MAX},\t\t/* pushl   %eax */\n+    {0xcd, ULONGEST_MAX},\t\t/* int\t   $0x80 */\n+    {0x80, ULONGEST_MAX},\n+    {TRAMP_SENTINEL_INSN, ULONGEST_MAX}\n+  },\n+  i386_fbsd_sigframe_init\n+};\n+\n+/* FreeBSD/i386 binaries running under an amd64 kernel use a different\n+   trampoline.  This trampoline differs from the i386 kernel trampoline\n+   in that it omits a middle section that conditionally restores\n+   %gs.  */\n+\n+static const struct tramp_frame i386_fbsd64_sigframe =\n+{\n+  SIGTRAMP_FRAME,\n+  1,\n+  {\n+    {0x8d, ULONGEST_MAX},\t\t/* lea     SIGF_UC(%esp),%eax */\n+    {0x44, ULONGEST_MAX},\n+    {0x24, ULONGEST_MAX},\n+    {0x20, ULONGEST_MAX},\n+    {0x50, ULONGEST_MAX},\t\t/* pushl   %eax */\n+    {0xb8, ULONGEST_MAX},\t\t/* movl   $SYS_sigreturn,%eax */\n+    {0xa1, ULONGEST_MAX},\n+    {0x01, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x00, ULONGEST_MAX},\n+    {0x50, ULONGEST_MAX},\t\t/* pushl   %eax */\n+    {0xcd, ULONGEST_MAX},\t\t/* int\t   $0x80 */\n+    {0x80, ULONGEST_MAX},\n+    {TRAMP_SENTINEL_INSN, ULONGEST_MAX}\n+  },\n+  i386_fbsd_sigframe_init\n };\n \n /* Get XSAVE extended state xcr0 from core dump.  */\n@@ -308,11 +368,8 @@ i386fbsd_init_abi (struct gdbarch_info info, struct gdbarch *gdbarch)\n   /* FreeBSD uses -freg-struct-return by default.  */\n   tdep->struct_return = reg_struct_return;\n \n-  tdep->sigtramp_p = i386fbsd_sigtramp_p;\n-\n-  /* FreeBSD has a more complete `struct sigcontext'.  */\n-  tdep->sc_reg_offset = i386fbsd_sc_reg_offset;\n-  tdep->sc_num_regs = ARRAY_SIZE (i386fbsd_sc_reg_offset);\n+  tramp_frame_prepend_unwinder (gdbarch, &i386_fbsd_sigframe);\n+  tramp_frame_prepend_unwinder (gdbarch, &i386_fbsd64_sigframe);\n \n   i386_elf_init_abi (info, gdbarch);\n "
    },
    {
      "sha": "eb58dd68e73d19618937602101442b48a1425d9d",
      "filename": "gdb/i386-tdep.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/i386-tdep.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7384826ebff8a91a3f9b632e9e3982760fab966e/gdb/i386-tdep.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.h?ref=7384826ebff8a91a3f9b632e9e3982760fab966e",
      "patch": "@@ -474,7 +474,6 @@ extern int i386_mpx_enabled (void);\n extern void i386bsd_init_abi (struct gdbarch_info, struct gdbarch *);\n extern CORE_ADDR i386obsd_sigtramp_start_addr;\n extern CORE_ADDR i386obsd_sigtramp_end_addr;\n-extern int i386fbsd_sc_reg_offset[];\n extern int i386obsd_sc_reg_offset[];\n extern int i386bsd_sc_reg_offset[];\n "
    }
  ]
}