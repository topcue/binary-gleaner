{
  "sha": "4631503b28f63cfa66a363008d714a94c2c71e06",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDYzMTUwM2IyOGY2M2NmYTY2YTM2MzAwOGQ3MTRhOTRjMmM3MWUwNg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-31T16:33:31Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-31T16:33:31Z"
    },
    "message": "gdb: move dwarf2_per_cu_data and signatured_type up\n\nMove them up before dwarf2_per_bfd, this will allow adding and using\nsignatured_type_up in the next patch.\n\ngdb/ChangeLog:\n\n\t* dwarf2/read.h (signatured_type, dwarf2_per_cu_data): Move up.\n\nChange-Id: I85acad4476c8236930b6f9e53ddb8bbbad009e5e",
    "tree": {
      "sha": "a8488a212283bbbca9ceedaf781f18edde830d88",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a8488a212283bbbca9ceedaf781f18edde830d88"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4631503b28f63cfa66a363008d714a94c2c71e06",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4631503b28f63cfa66a363008d714a94c2c71e06",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4631503b28f63cfa66a363008d714a94c2c71e06",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4631503b28f63cfa66a363008d714a94c2c71e06/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ef9d25656226c46406293a70a81e564640973662",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ef9d25656226c46406293a70a81e564640973662",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ef9d25656226c46406293a70a81e564640973662"
    }
  ],
  "stats": {
    "total": 436,
    "additions": 221,
    "deletions": 215
  },
  "files": [
    {
      "sha": "a570dfef8cbfaae2e37de8a48c229baf10dd63b3",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4631503b28f63cfa66a363008d714a94c2c71e06/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4631503b28f63cfa66a363008d714a94c2c71e06/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=4631503b28f63cfa66a363008d714a94c2c71e06",
      "patch": "@@ -1,3 +1,7 @@\n+2021-05-31  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* dwarf2/read.h (signatured_type, dwarf2_per_cu_data): Move up.\n+\n 2021-05-30  Tom Tromey  <tom@tromey.com>\n \n \t* dwarf2/read.c (dwarf2_per_bfd::allocate_signatured_type): Set"
    },
    {
      "sha": "44ba1a624ccf376ced67aa418af7e55b03f11388",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 217,
      "deletions": 215,
      "changes": 432,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4631503b28f63cfa66a363008d714a94c2c71e06/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4631503b28f63cfa66a363008d714a94c2c71e06/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=4631503b28f63cfa66a363008d714a94c2c71e06",
      "patch": "@@ -47,7 +47,9 @@ struct tu_stats\n \n struct dwarf2_cu;\n struct dwarf2_debug_sections;\n+struct dwarf2_per_bfd;\n struct dwarf2_per_cu_data;\n+struct dwarf2_psymtab;\n struct mapped_index;\n struct mapped_debug_names;\n struct signatured_type;\n@@ -88,6 +90,221 @@ struct dwarf2_per_cu_data_deleter\n typedef std::unique_ptr<dwarf2_per_cu_data, dwarf2_per_cu_data_deleter>\n     dwarf2_per_cu_data_up;\n \n+/* Persistent data held for a compilation unit, even when not\n+   processing it.  We put a pointer to this structure in the\n+   psymtab.  */\n+\n+struct dwarf2_per_cu_data\n+{\n+  dwarf2_per_cu_data ()\n+    : queued (false),\n+      is_debug_types (false),\n+      is_dwz (false),\n+      reading_dwo_directly (false),\n+      tu_read (false),\n+      m_header_read_in (false),\n+      unit_type {},\n+      lang (language_unknown)\n+  {\n+  }\n+\n+  /* The start offset and length of this compilation unit.\n+     NOTE: Unlike comp_unit_head.length, this length includes\n+     initial_length_size.\n+     If the DIE refers to a DWO file, this is always of the original die,\n+     not the DWO file.  */\n+  sect_offset sect_off {};\n+  unsigned int length = 0;\n+\n+  /* DWARF standard version this data has been read from (such as 4 or 5).  */\n+  unsigned char dwarf_version = 0;\n+\n+  /* Flag indicating this compilation unit will be read in before\n+     any of the current compilation units are processed.  */\n+  unsigned int queued : 1;\n+\n+  /* Non-zero if this CU is from .debug_types.\n+     Struct dwarf2_per_cu_data is contained in struct signatured_type iff\n+     this is non-zero.  */\n+  unsigned int is_debug_types : 1;\n+\n+  /* Non-zero if this CU is from the .dwz file.  */\n+  unsigned int is_dwz : 1;\n+\n+  /* Non-zero if reading a TU directly from a DWO file, bypassing the stub.\n+     This flag is only valid if is_debug_types is true.\n+     We can't read a CU directly from a DWO file: There are required\n+     attributes in the stub.  */\n+  unsigned int reading_dwo_directly : 1;\n+\n+  /* Non-zero if the TU has been read.\n+     This is used to assist the \"Stay in DWO Optimization\" for Fission:\n+     When reading a DWO, it's faster to read TUs from the DWO instead of\n+     fetching them from random other DWOs (due to comdat folding).\n+     If the TU has already been read, the optimization is unnecessary\n+     (and unwise - we don't want to change where gdb thinks the TU lives\n+     \"midflight\").\n+     This flag is only valid if is_debug_types is true.  */\n+  unsigned int tu_read : 1;\n+\n+  /* True if HEADER has been read in.\n+\n+     Don't access this field directly.  It should be private, but we can't make\n+     it private at the moment.  */\n+  mutable bool m_header_read_in : 1;\n+\n+  /* The unit type of this CU.  */\n+  ENUM_BITFIELD (dwarf_unit_type) unit_type : 8;\n+\n+  /* The language of this CU.  */\n+  ENUM_BITFIELD (language) lang : LANGUAGE_BITS;\n+\n+  /* Our index in the unshared \"symtabs\" vector.  */\n+  unsigned index = 0;\n+\n+  /* The section this CU/TU lives in.\n+     If the DIE refers to a DWO file, this is always the original die,\n+     not the DWO file.  */\n+  struct dwarf2_section_info *section = nullptr;\n+\n+  /* Backlink to the owner of this.  */\n+  dwarf2_per_bfd *per_bfd = nullptr;\n+\n+  /* DWARF header of this CU.  Note that dwarf2_cu reads its own version of the\n+     header, which may differ from this one, since it may pass rcuh_kind::TYPE\n+     to read_comp_unit_head, whereas for dwarf2_per_cu_data we always pass\n+     rcuh_kind::COMPILE.\n+\n+     Don't access this field directly, use the get_header method instead.  It\n+     should be private, but we can't make it private at the moment.  */\n+  mutable comp_unit_head m_header {};\n+\n+  /* When dwarf2_per_bfd::using_index is true, the 'quick' field\n+     is active.  Otherwise, the 'psymtab' field is active.  */\n+  union\n+  {\n+    /* The partial symbol table associated with this compilation unit,\n+       or NULL for unread partial units.  */\n+    dwarf2_psymtab *psymtab;\n+\n+    /* Data needed by the \"quick\" functions.  */\n+    struct dwarf2_per_cu_quick_data *quick;\n+  } v {};\n+\n+  /* The CUs we import using DW_TAG_imported_unit.  This is filled in\n+     while reading psymtabs, used to compute the psymtab dependencies,\n+     and then cleared.  Then it is filled in again while reading full\n+     symbols, and only deleted when the objfile is destroyed.\n+\n+     This is also used to work around a difference between the way gold\n+     generates .gdb_index version <=7 and the way gdb does.  Arguably this\n+     is a gold bug.  For symbols coming from TUs, gold records in the index\n+     the CU that includes the TU instead of the TU itself.  This breaks\n+     dw2_lookup_symbol: It assumes that if the index says symbol X lives\n+     in CU/TU Y, then one need only expand Y and a subsequent lookup in Y\n+     will find X.  Alas TUs live in their own symtab, so after expanding CU Y\n+     we need to look in TU Z to find X.  Fortunately, this is akin to\n+     DW_TAG_imported_unit, so we just use the same mechanism: For\n+     .gdb_index version <=7 this also records the TUs that the CU referred\n+     to.  Concurrently with this change gdb was modified to emit version 8\n+     indices so we only pay a price for gold generated indices.\n+     http://sourceware.org/bugzilla/show_bug.cgi?id=15021.\n+\n+     This currently needs to be a public member due to how\n+     dwarf2_per_cu_data is allocated and used.  Ideally in future things\n+     could be refactored to make this private.  Until then please try to\n+     avoid direct access to this member, and instead use the helper\n+     functions above.  */\n+  std::vector <dwarf2_per_cu_data *> *imported_symtabs = nullptr;\n+\n+  /* Return true of IMPORTED_SYMTABS is empty or not yet allocated.  */\n+  bool imported_symtabs_empty () const\n+  {\n+    return (imported_symtabs == nullptr || imported_symtabs->empty ());\n+  }\n+\n+  /* Push P to the back of IMPORTED_SYMTABS, allocated IMPORTED_SYMTABS\n+     first if required.  */\n+  void imported_symtabs_push (dwarf2_per_cu_data *p)\n+  {\n+    if (imported_symtabs == nullptr)\n+      imported_symtabs = new std::vector <dwarf2_per_cu_data *>;\n+    imported_symtabs->push_back (p);\n+  }\n+\n+  /* Return the size of IMPORTED_SYMTABS if it is allocated, otherwise\n+     return 0.  */\n+  size_t imported_symtabs_size () const\n+  {\n+    if (imported_symtabs == nullptr)\n+      return 0;\n+    return imported_symtabs->size ();\n+  }\n+\n+  /* Delete IMPORTED_SYMTABS and set the pointer back to nullptr.  */\n+  void imported_symtabs_free ()\n+  {\n+    delete imported_symtabs;\n+    imported_symtabs = nullptr;\n+  }\n+\n+  /* Get the header of this per_cu, reading it if necessary.  */\n+  const comp_unit_head *get_header () const;\n+\n+  /* Return the address size given in the compilation unit header for\n+     this CU.  */\n+  int addr_size () const;\n+\n+  /* Return the offset size given in the compilation unit header for\n+     this CU.  */\n+  int offset_size () const;\n+\n+  /* Return the DW_FORM_ref_addr size given in the compilation unit\n+     header for this CU.  */\n+  int ref_addr_size () const;\n+\n+  /* Return DWARF version number of this CU.  */\n+  short version () const\n+  {\n+    return dwarf_version;\n+  }\n+\n+  /* A type unit group has a per_cu object that is recognized by\n+     having no section.  */\n+  bool type_unit_group_p () const\n+  {\n+    return section == nullptr;\n+  }\n+};\n+\n+/* Entry in the signatured_types hash table.  */\n+\n+struct signatured_type : public dwarf2_per_cu_data\n+{\n+  /* The type's signature.  */\n+  ULONGEST signature = 0;\n+\n+  /* Offset in the TU of the type's DIE, as read from the TU header.\n+     If this TU is a DWO stub and the definition lives in a DWO file\n+     (specified by DW_AT_GNU_dwo_name), this value is unusable.  */\n+  cu_offset type_offset_in_tu {};\n+\n+  /* Offset in the section of the type's DIE.\n+     If the definition lives in a DWO file, this is the offset in the\n+     .debug_types.dwo section.\n+     The value is zero until the actual value is known.\n+     Zero is otherwise not a valid section offset.  */\n+  sect_offset type_offset_in_section {};\n+\n+  /* Type units are grouped by their DW_AT_stmt_list entry so that they\n+     can share them.  This points to the containing symtab.  */\n+  struct type_unit_group *type_unit_group = nullptr;\n+\n+  /* Containing DWO unit.\n+     This field is valid iff per_cu.reading_dwo_directly.  */\n+  struct dwo_unit *dwo_unit = nullptr;\n+};\n+\n /* Some DWARF data can be shared across objfiles who share the same BFD,\n    this data is stored in this object.\n \n@@ -402,221 +619,6 @@ struct dwarf2_psymtab : public partial_symtab\n   struct dwarf2_per_cu_data *per_cu_data;\n };\n \n-/* Persistent data held for a compilation unit, even when not\n-   processing it.  We put a pointer to this structure in the\n-   psymtab.  */\n-\n-struct dwarf2_per_cu_data\n-{\n-  dwarf2_per_cu_data ()\n-    : queued (false),\n-      is_debug_types (false),\n-      is_dwz (false),\n-      reading_dwo_directly (false),\n-      tu_read (false),\n-      m_header_read_in (false),\n-      unit_type {},\n-      lang (language_unknown)\n-  {\n-  }\n-\n-  /* The start offset and length of this compilation unit.\n-     NOTE: Unlike comp_unit_head.length, this length includes\n-     initial_length_size.\n-     If the DIE refers to a DWO file, this is always of the original die,\n-     not the DWO file.  */\n-  sect_offset sect_off {};\n-  unsigned int length = 0;\n-\n-  /* DWARF standard version this data has been read from (such as 4 or 5).  */\n-  unsigned char dwarf_version = 0;\n-\n-  /* Flag indicating this compilation unit will be read in before\n-     any of the current compilation units are processed.  */\n-  unsigned int queued : 1;\n-\n-  /* Non-zero if this CU is from .debug_types.\n-     Struct dwarf2_per_cu_data is contained in struct signatured_type iff\n-     this is non-zero.  */\n-  unsigned int is_debug_types : 1;\n-\n-  /* Non-zero if this CU is from the .dwz file.  */\n-  unsigned int is_dwz : 1;\n-\n-  /* Non-zero if reading a TU directly from a DWO file, bypassing the stub.\n-     This flag is only valid if is_debug_types is true.\n-     We can't read a CU directly from a DWO file: There are required\n-     attributes in the stub.  */\n-  unsigned int reading_dwo_directly : 1;\n-\n-  /* Non-zero if the TU has been read.\n-     This is used to assist the \"Stay in DWO Optimization\" for Fission:\n-     When reading a DWO, it's faster to read TUs from the DWO instead of\n-     fetching them from random other DWOs (due to comdat folding).\n-     If the TU has already been read, the optimization is unnecessary\n-     (and unwise - we don't want to change where gdb thinks the TU lives\n-     \"midflight\").\n-     This flag is only valid if is_debug_types is true.  */\n-  unsigned int tu_read : 1;\n-\n-  /* True if HEADER has been read in.\n-\n-     Don't access this field directly.  It should be private, but we can't make\n-     it private at the moment.  */\n-  mutable bool m_header_read_in : 1;\n-\n-  /* The unit type of this CU.  */\n-  ENUM_BITFIELD (dwarf_unit_type) unit_type : 8;\n-\n-  /* The language of this CU.  */\n-  ENUM_BITFIELD (language) lang : LANGUAGE_BITS;\n-\n-  /* Our index in the unshared \"symtabs\" vector.  */\n-  unsigned index = 0;\n-\n-  /* The section this CU/TU lives in.\n-     If the DIE refers to a DWO file, this is always the original die,\n-     not the DWO file.  */\n-  struct dwarf2_section_info *section = nullptr;\n-\n-  /* Backlink to the owner of this.  */\n-  dwarf2_per_bfd *per_bfd = nullptr;\n-\n-  /* DWARF header of this CU.  Note that dwarf2_cu reads its own version of the\n-     header, which may differ from this one, since it may pass rcuh_kind::TYPE\n-     to read_comp_unit_head, whereas for dwarf2_per_cu_data we always pass\n-     rcuh_kind::COMPILE.\n-\n-     Don't access this field directly, use the get_header method instead.  It\n-     should be private, but we can't make it private at the moment.  */\n-  mutable comp_unit_head m_header {};\n-\n-  /* When dwarf2_per_bfd::using_index is true, the 'quick' field\n-     is active.  Otherwise, the 'psymtab' field is active.  */\n-  union\n-  {\n-    /* The partial symbol table associated with this compilation unit,\n-       or NULL for unread partial units.  */\n-    dwarf2_psymtab *psymtab;\n-\n-    /* Data needed by the \"quick\" functions.  */\n-    struct dwarf2_per_cu_quick_data *quick;\n-  } v {};\n-\n-  /* The CUs we import using DW_TAG_imported_unit.  This is filled in\n-     while reading psymtabs, used to compute the psymtab dependencies,\n-     and then cleared.  Then it is filled in again while reading full\n-     symbols, and only deleted when the objfile is destroyed.\n-\n-     This is also used to work around a difference between the way gold\n-     generates .gdb_index version <=7 and the way gdb does.  Arguably this\n-     is a gold bug.  For symbols coming from TUs, gold records in the index\n-     the CU that includes the TU instead of the TU itself.  This breaks\n-     dw2_lookup_symbol: It assumes that if the index says symbol X lives\n-     in CU/TU Y, then one need only expand Y and a subsequent lookup in Y\n-     will find X.  Alas TUs live in their own symtab, so after expanding CU Y\n-     we need to look in TU Z to find X.  Fortunately, this is akin to\n-     DW_TAG_imported_unit, so we just use the same mechanism: For\n-     .gdb_index version <=7 this also records the TUs that the CU referred\n-     to.  Concurrently with this change gdb was modified to emit version 8\n-     indices so we only pay a price for gold generated indices.\n-     http://sourceware.org/bugzilla/show_bug.cgi?id=15021.\n-\n-     This currently needs to be a public member due to how\n-     dwarf2_per_cu_data is allocated and used.  Ideally in future things\n-     could be refactored to make this private.  Until then please try to\n-     avoid direct access to this member, and instead use the helper\n-     functions above.  */\n-  std::vector <dwarf2_per_cu_data *> *imported_symtabs = nullptr;\n-\n-  /* Return true of IMPORTED_SYMTABS is empty or not yet allocated.  */\n-  bool imported_symtabs_empty () const\n-  {\n-    return (imported_symtabs == nullptr || imported_symtabs->empty ());\n-  }\n-\n-  /* Push P to the back of IMPORTED_SYMTABS, allocated IMPORTED_SYMTABS\n-     first if required.  */\n-  void imported_symtabs_push (dwarf2_per_cu_data *p)\n-  {\n-    if (imported_symtabs == nullptr)\n-      imported_symtabs = new std::vector <dwarf2_per_cu_data *>;\n-    imported_symtabs->push_back (p);\n-  }\n-\n-  /* Return the size of IMPORTED_SYMTABS if it is allocated, otherwise\n-     return 0.  */\n-  size_t imported_symtabs_size () const\n-  {\n-    if (imported_symtabs == nullptr)\n-      return 0;\n-    return imported_symtabs->size ();\n-  }\n-\n-  /* Delete IMPORTED_SYMTABS and set the pointer back to nullptr.  */\n-  void imported_symtabs_free ()\n-  {\n-    delete imported_symtabs;\n-    imported_symtabs = nullptr;\n-  }\n-\n-  /* Get the header of this per_cu, reading it if necessary.  */\n-  const comp_unit_head *get_header () const;\n-\n-  /* Return the address size given in the compilation unit header for\n-     this CU.  */\n-  int addr_size () const;\n-\n-  /* Return the offset size given in the compilation unit header for\n-     this CU.  */\n-  int offset_size () const;\n-\n-  /* Return the DW_FORM_ref_addr size given in the compilation unit\n-     header for this CU.  */\n-  int ref_addr_size () const;\n-\n-  /* Return DWARF version number of this CU.  */\n-  short version () const\n-  {\n-    return dwarf_version;\n-  }\n-\n-  /* A type unit group has a per_cu object that is recognized by\n-     having no section.  */\n-  bool type_unit_group_p () const\n-  {\n-    return section == nullptr;\n-  }\n-};\n-\n-/* Entry in the signatured_types hash table.  */\n-\n-struct signatured_type : public dwarf2_per_cu_data\n-{\n-  /* The type's signature.  */\n-  ULONGEST signature = 0;\n-\n-  /* Offset in the TU of the type's DIE, as read from the TU header.\n-     If this TU is a DWO stub and the definition lives in a DWO file\n-     (specified by DW_AT_GNU_dwo_name), this value is unusable.  */\n-  cu_offset type_offset_in_tu {};\n-\n-  /* Offset in the section of the type's DIE.\n-     If the definition lives in a DWO file, this is the offset in the\n-     .debug_types.dwo section.\n-     The value is zero until the actual value is known.\n-     Zero is otherwise not a valid section offset.  */\n-  sect_offset type_offset_in_section {};\n-\n-  /* Type units are grouped by their DW_AT_stmt_list entry so that they\n-     can share them.  This points to the containing symtab.  */\n-  struct type_unit_group *type_unit_group = nullptr;\n-\n-  /* Containing DWO unit.\n-     This field is valid iff per_cu.reading_dwo_directly.  */\n-  struct dwo_unit *dwo_unit = nullptr;\n-};\n-\n /* Return the type of the DIE at DIE_OFFSET in the CU named by\n    PER_CU.  */\n "
    }
  ]
}