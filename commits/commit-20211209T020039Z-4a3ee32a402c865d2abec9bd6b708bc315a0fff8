{
  "sha": "4a3ee32a402c865d2abec9bd6b708bc315a0fff8",
  "node_id": "C_kwDOANOeidoAKDRhM2VlMzJhNDAyYzg2NWQyYWJlYzliZDZiNzA4YmMzMTVhMGZmZjg",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-01T14:40:02Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-12-09T02:00:39Z"
    },
    "message": "gdb/linux-nat: factor ptrace-detach code to new detach_one_pid function\n\nThe following patch will add some code paths that need to ptrace-detach\na given PID.  Factor out the code that does this and put it in its own\nfunction, so that it can be re-used.\n\nChange-Id: Ie65ca0d89893b41aea0a23d9fc6ffbed042a9705",
    "tree": {
      "sha": "1be2a8cdd12643d297c2c0bc5730f50da0caf7bd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/1be2a8cdd12643d297c2c0bc5730f50da0caf7bd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/4a3ee32a402c865d2abec9bd6b708bc315a0fff8",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a3ee32a402c865d2abec9bd6b708bc315a0fff8",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/4a3ee32a402c865d2abec9bd6b708bc315a0fff8",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a3ee32a402c865d2abec9bd6b708bc315a0fff8/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7b961964f86618773218c067bfff066b2bff8328",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7b961964f86618773218c067bfff066b2bff8328",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7b961964f86618773218c067bfff066b2bff8328"
    }
  ],
  "stats": {
    "total": 76,
    "additions": 40,
    "deletions": 36
  },
  "files": [
    {
      "sha": "2f8cf498b73c29f2b3d930e50fbaf803a27191cc",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 40,
      "deletions": 36,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/4a3ee32a402c865d2abec9bd6b708bc315a0fff8/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/4a3ee32a402c865d2abec9bd6b708bc315a0fff8/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=4a3ee32a402c865d2abec9bd6b708bc315a0fff8",
      "patch": "@@ -1234,6 +1234,45 @@ linux_nat_target::attach (const char *args, int from_tty)\n     target_async (1);\n }\n \n+/* Ptrace-detach the thread with pid PID.  */\n+\n+static void\n+detach_one_pid (int pid, int signo)\n+{\n+  if (ptrace (PTRACE_DETACH, pid, 0, signo) < 0)\n+    {\n+      int save_errno = errno;\n+\n+      /* We know the thread exists, so ESRCH must mean the lwp is\n+\t zombie.  This can happen if one of the already-detached\n+\t threads exits the whole thread group.  In that case we're\n+\t still attached, and must reap the lwp.  */\n+      if (save_errno == ESRCH)\n+\t{\n+\t  int ret, status;\n+\n+\t  ret = my_waitpid (pid, &status, __WALL);\n+\t  if (ret == -1)\n+\t    {\n+\t      warning (_(\"Couldn't reap LWP %d while detaching: %s\"),\n+\t\t       pid, safe_strerror (errno));\n+\t    }\n+\t  else if (!WIFEXITED (status) && !WIFSIGNALED (status))\n+\t    {\n+\t      warning (_(\"Reaping LWP %d while detaching \"\n+\t\t\t \"returned unexpected status 0x%x\"),\n+\t\t       pid, status);\n+\t    }\n+\t}\n+      else\n+\terror (_(\"Can't detach %d: %s\"),\n+\t       pid, safe_strerror (save_errno));\n+    }\n+  else\n+    linux_nat_debug_printf (\"PTRACE_DETACH (%d, %s, 0) (OK)\",\n+\t\t\t    pid, strsignal (signo));\n+}\n+\n /* Get pending signal of THREAD as a host signal number, for detaching\n    purposes.  This is the signal the thread last stopped for, which we\n    need to deliver to the thread when detaching, otherwise, it'd be\n@@ -1364,42 +1403,7 @@ detach_one_lwp (struct lwp_info *lp, int *signo_p)\n \tthrow;\n     }\n \n-  if (ptrace (PTRACE_DETACH, lwpid, 0, signo) < 0)\n-    {\n-      int save_errno = errno;\n-\n-      /* We know the thread exists, so ESRCH must mean the lwp is\n-\t zombie.  This can happen if one of the already-detached\n-\t threads exits the whole thread group.  In that case we're\n-\t still attached, and must reap the lwp.  */\n-      if (save_errno == ESRCH)\n-\t{\n-\t  int ret, status;\n-\n-\t  ret = my_waitpid (lwpid, &status, __WALL);\n-\t  if (ret == -1)\n-\t    {\n-\t      warning (_(\"Couldn't reap LWP %d while detaching: %s\"),\n-\t\t       lwpid, safe_strerror (errno));\n-\t    }\n-\t  else if (!WIFEXITED (status) && !WIFSIGNALED (status))\n-\t    {\n-\t      warning (_(\"Reaping LWP %d while detaching \"\n-\t\t\t \"returned unexpected status 0x%x\"),\n-\t\t       lwpid, status);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  error (_(\"Can't detach %s: %s\"),\n-\t\t target_pid_to_str (lp->ptid).c_str (),\n-\t\t safe_strerror (save_errno));\n-\t}\n-    }\n-  else\n-    linux_nat_debug_printf (\"PTRACE_DETACH (%s, %s, 0) (OK)\",\n-\t\t\t    target_pid_to_str (lp->ptid).c_str (),\n-\t\t\t    strsignal (signo));\n+  detach_one_pid (lwpid, signo);\n \n   delete_lwp (lp->ptid);\n }"
    }
  ]
}