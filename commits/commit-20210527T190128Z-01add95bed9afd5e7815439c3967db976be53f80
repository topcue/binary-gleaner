{
  "sha": "01add95bed9afd5e7815439c3967db976be53f80",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDFhZGQ5NWJlZDlhZmQ1ZTc4MTU0MzljMzk2N2RiOTc2YmU1M2Y4MA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T19:01:28Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-05-27T19:01:28Z"
    },
    "message": "gdb: fix some indentation issues\n\nI wrote a small script to spot a pattern of indentation mistakes I saw\nhappened in breakpoint.c.  And while at it I ran it on all files and\nfixed what I found.  No behavior changes intended, just indentation and\naddition / removal of curly braces.\n\ngdb/ChangeLog:\n\n\t* Fix some indentation mistakes throughout.\n\ngdbserver/ChangeLog:\n\n\t* Fix some indentation mistakes throughout.\n\nChange-Id: Ia01990c26c38e83a243d8f33da1d494f16315c6e",
    "tree": {
      "sha": "a0239dcf29375bf6e4382d419d17117b1665d8ab",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/a0239dcf29375bf6e4382d419d17117b1665d8ab"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/01add95bed9afd5e7815439c3967db976be53f80",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/01add95bed9afd5e7815439c3967db976be53f80",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/01add95bed9afd5e7815439c3967db976be53f80",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/01add95bed9afd5e7815439c3967db976be53f80/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "055c879fcf242e43a6ef8190f83905109922da93",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/055c879fcf242e43a6ef8190f83905109922da93",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/055c879fcf242e43a6ef8190f83905109922da93"
    }
  ],
  "stats": {
    "total": 1402,
    "additions": 704,
    "deletions": 698
  },
  "files": [
    {
      "sha": "fa3940c2c0d7f1e0fda9c0eabc31c99549fdd0ea",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -1,3 +1,7 @@\n+2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* Fix some indentation mistakes throughout.\n+\n 2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* breakpoint.h (iterate_over_bp_locations): Remove.  Update"
    },
    {
      "sha": "202b02108744b13fb93fb46441941740be35fc1f",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -3663,11 +3663,11 @@ When on, AArch64 specific debugging is enabled.\"),\n \t  { \\\n \t    unsigned int mem_len = LENGTH; \\\n \t    if (mem_len) \\\n-\t    { \\\n-\t      MEMS =  XNEWVEC (struct aarch64_mem_r, mem_len);  \\\n-\t      memcpy(&MEMS->len, &RECORD_BUF[0], \\\n-\t\t     sizeof(struct aarch64_mem_r) * LENGTH); \\\n-\t    } \\\n+\t      { \\\n+\t\tMEMS =  XNEWVEC (struct aarch64_mem_r, mem_len);  \\\n+\t\tmemcpy(&MEMS->len, &RECORD_BUF[0], \\\n+\t\t       sizeof(struct aarch64_mem_r) * LENGTH); \\\n+\t      } \\\n \t  } \\\n \t  while (0)\n "
    },
    {
      "sha": "d4147466c00763237112566fc159d3fb72bd97a4",
      "filename": "gdb/aix-thread.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/aix-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/aix-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aix-thread.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -707,14 +707,14 @@ get_signaled_thread (void)\n   tid_t ktid = 0;\n \n   while (1)\n-  {\n-    if (getthrds (inferior_ptid.pid (), &thrinf, \n-\t  \t  sizeof (thrinf), &ktid, 1) != 1)\n-      break;\n+    {\n+      if (getthrds (inferior_ptid.pid (), &thrinf,\n+\t\t    sizeof (thrinf), &ktid, 1) != 1)\n+\tbreak;\n \n-    if (thrinf.ti_cursig == SIGTRAP)\n-      return thrinf.ti_tid;\n-  }\n+      if (thrinf.ti_cursig == SIGTRAP)\n+\treturn thrinf.ti_tid;\n+    }\n \n   /* Didn't find any thread stopped on a SIGTRAP signal.  */\n   return 0;"
    },
    {
      "sha": "3a179184550d18f3bbdc1f7b18c4efc4808fa5b3",
      "filename": "gdb/arm-fbsd-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/arm-fbsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/arm-fbsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-fbsd-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -187,10 +187,10 @@ arm_fbsd_read_description_auxv (struct target_ops *target)\n       if (arm_hwcap & HWCAP_NEON)\n \treturn aarch32_read_description ();\n       else if ((arm_hwcap & (HWCAP_VFPv3 | HWCAP_VFPD32))\n-\t  == (HWCAP_VFPv3 | HWCAP_VFPD32))\n+\t       == (HWCAP_VFPv3 | HWCAP_VFPD32))\n \treturn arm_read_description (ARM_FP_TYPE_VFPV3);\n       else\n-      return arm_read_description (ARM_FP_TYPE_VFPV2);\n+\treturn arm_read_description (ARM_FP_TYPE_VFPV2);\n     }\n \n   return nullptr;"
    },
    {
      "sha": "f8da6388047c527ccbabfc7488f397d11a481d5d",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 21,
      "deletions": 21,
      "changes": 42,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -9697,11 +9697,11 @@ vfp - VFP co-processor.\"),\n \t  { \\\n \t    unsigned int mem_len = LENGTH; \\\n \t    if (mem_len) \\\n-\t    { \\\n-\t      MEMS =  XNEWVEC (struct arm_mem_r, mem_len);  \\\n-\t      memcpy(&MEMS->len, &RECORD_BUF[0], \\\n-\t\t     sizeof(struct arm_mem_r) * LENGTH); \\\n-\t    } \\\n+\t      { \\\n+\t\tMEMS =  XNEWVEC (struct arm_mem_r, mem_len);  \\\n+\t\tmemcpy(&MEMS->len, &RECORD_BUF[0], \\\n+\t\t       sizeof(struct arm_mem_r) * LENGTH); \\\n+\t      } \\\n \t  } \\\n \t  while (0)\n \n@@ -9997,19 +9997,19 @@ arm_record_extension_space (insn_decode_record *arm_insn_r)\n     {\n       /* Handle MLA(S) and MUL(S).  */\n       if (in_inclusive_range (insn_op1, 0U, 3U))\n-      {\n-\trecord_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);\n-\trecord_buf[1] = ARM_PS_REGNUM;\n-\tarm_insn_r->reg_rec_count = 2;\n-      }\n+\t{\n+\t  record_buf[0] = bits (arm_insn_r->arm_insn, 12, 15);\n+\t  record_buf[1] = ARM_PS_REGNUM;\n+\t  arm_insn_r->reg_rec_count = 2;\n+\t}\n       else if (in_inclusive_range (insn_op1, 4U, 15U))\n-      {\n-\t/* Handle SMLAL(S), SMULL(S), UMLAL(S), UMULL(S).  */\n-\trecord_buf[0] = bits (arm_insn_r->arm_insn, 16, 19);\n-\trecord_buf[1] = bits (arm_insn_r->arm_insn, 12, 15);\n-\trecord_buf[2] = ARM_PS_REGNUM;\n-\tarm_insn_r->reg_rec_count = 3;\n-      }\n+\t{\n+\t  /* Handle SMLAL(S), SMULL(S), UMLAL(S), UMULL(S).  */\n+\t  record_buf[0] = bits (arm_insn_r->arm_insn, 16, 19);\n+\t  record_buf[1] = bits (arm_insn_r->arm_insn, 12, 15);\n+\t  record_buf[2] = ARM_PS_REGNUM;\n+\t  arm_insn_r->reg_rec_count = 3;\n+\t}\n     }\n \n   opcode1 = bits (arm_insn_r->arm_insn, 26, 27);\n@@ -11100,10 +11100,10 @@ arm_record_b_bl (insn_decode_record *arm_insn_r)\n   /* Note: BLX(1) doesnt fall here but instead it falls into\n      extension space.  */\n   if (bit (arm_insn_r->arm_insn, 24))\n-  {\n-    record_buf[0] = ARM_LR_REGNUM;\n-    arm_insn_r->reg_rec_count = 1;\n-  }\n+    {\n+      record_buf[0] = ARM_LR_REGNUM;\n+      arm_insn_r->reg_rec_count = 1;\n+    }\n \n   REG_ALLOC (arm_insn_r->arm_regs, arm_insn_r->reg_rec_count, record_buf);\n "
    },
    {
      "sha": "fd98ded8e7575b9523274cc2b96e005d3c6dfbd8",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 374,
      "deletions": 376,
      "changes": 750,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -1605,28 +1605,29 @@ breakpoint_xfer_memory (gdb_byte *readbuf, gdb_byte *writebuf,\n   /* Now do full processing of the found relevant range of elements.  */\n \n   for (bc = bc_l; bc < bp_locations.size (); bc++)\n-  {\n-    struct bp_location *bl = bp_locations[bc];\n+    {\n+      struct bp_location *bl = bp_locations[bc];\n \n-    /* bp_location array has BL->OWNER always non-NULL.  */\n-    if (bl->owner->type == bp_none)\n-      warning (_(\"reading through apparently deleted breakpoint #%d?\"),\n-\t       bl->owner->number);\n+      /* bp_location array has BL->OWNER always non-NULL.  */\n+      if (bl->owner->type == bp_none)\n+\twarning (_(\"reading through apparently deleted breakpoint #%d?\"),\n+\t\t bl->owner->number);\n \n-    /* Performance optimization: any further element can no longer affect BUF\n-       content.  */\n+      /* Performance optimization: any further element can no longer affect BUF\n+\t content.  */\n \n-    if (bl->address >= bp_locations_placed_address_before_address_max\n-\t&& memaddr + len <= (bl->address\n-\t\t\t     - bp_locations_placed_address_before_address_max))\n-      break;\n+      if (bl->address >= bp_locations_placed_address_before_address_max\n+\t  && (memaddr + len\n+\t      <= (bl->address\n+\t\t  - bp_locations_placed_address_before_address_max)))\n+\tbreak;\n \n-    if (!bp_location_has_shadow (bl))\n-      continue;\n+      if (!bp_location_has_shadow (bl))\n+\tcontinue;\n \n-    one_breakpoint_xfer_memory (readbuf, writebuf, writebuf_org,\n-\t\t\t\tmemaddr, len, &bl->target_info, bl->gdbarch);\n-  }\n+      one_breakpoint_xfer_memory (readbuf, writebuf, writebuf_org,\n+\t\t\t\t  memaddr, len, &bl->target_info, bl->gdbarch);\n+    }\n }\n \n /* See breakpoint.h.  */\n@@ -3079,10 +3080,9 @@ remove_breakpoints (void)\n   int val = 0;\n \n   for (bp_location *bl : all_bp_locations ())\n-  {\n     if (bl->inserted && !is_tracepoint (bl->owner))\n       val |= remove_breakpoint (bl);\n-  }\n+\n   return val;\n }\n \n@@ -3116,17 +3116,17 @@ remove_breakpoints_inf (inferior *inf)\n   int val;\n \n   for (bp_location *bl : all_bp_locations ())\n-  {\n-    if (bl->pspace != inf->pspace)\n-      continue;\n+    {\n+      if (bl->pspace != inf->pspace)\n+\tcontinue;\n \n-    if (bl->inserted && !bl->target_info.persist)\n-      {\n-\tval = remove_breakpoint (bl);\n-\tif (val != 0)\n-\t  return;\n-      }\n-  }\n+      if (bl->inserted && !bl->target_info.persist)\n+\t{\n+\t  val = remove_breakpoint (bl);\n+\t  if (val != 0)\n+\t    return;\n+\t}\n+    }\n }\n \n static int internal_breakpoint_number = -1;\n@@ -3612,107 +3612,107 @@ update_breakpoints_after_exec (void)\n       gdb_assert (!bploc->inserted);\n \n   for (breakpoint *b : all_breakpoints_safe ())\n-  {\n-    if (b->pspace != current_program_space)\n-      continue;\n-\n-    /* Solib breakpoints must be explicitly reset after an exec().  */\n-    if (b->type == bp_shlib_event)\n-      {\n-\tdelete_breakpoint (b);\n+    {\n+      if (b->pspace != current_program_space)\n \tcontinue;\n-      }\n \n-    /* JIT breakpoints must be explicitly reset after an exec().  */\n-    if (b->type == bp_jit_event)\n-      {\n-\tdelete_breakpoint (b);\n-\tcontinue;\n-      }\n+      /* Solib breakpoints must be explicitly reset after an exec().  */\n+      if (b->type == bp_shlib_event)\n+\t{\n+\t  delete_breakpoint (b);\n+\t  continue;\n+\t}\n \n-    /* Thread event breakpoints must be set anew after an exec(),\n-       as must overlay event and longjmp master breakpoints.  */\n-    if (b->type == bp_thread_event || b->type == bp_overlay_event\n-\t|| b->type == bp_longjmp_master || b->type == bp_std_terminate_master\n-\t|| b->type == bp_exception_master)\n-      {\n-\tdelete_breakpoint (b);\n-\tcontinue;\n-      }\n+      /* JIT breakpoints must be explicitly reset after an exec().  */\n+      if (b->type == bp_jit_event)\n+\t{\n+\t  delete_breakpoint (b);\n+\t  continue;\n+\t}\n \n-    /* Step-resume breakpoints are meaningless after an exec().  */\n-    if (b->type == bp_step_resume || b->type == bp_hp_step_resume)\n-      {\n-\tdelete_breakpoint (b);\n-\tcontinue;\n-      }\n+      /* Thread event breakpoints must be set anew after an exec(),\n+\t as must overlay event and longjmp master breakpoints.  */\n+      if (b->type == bp_thread_event || b->type == bp_overlay_event\n+\t  || b->type == bp_longjmp_master || b->type == bp_std_terminate_master\n+\t  || b->type == bp_exception_master)\n+\t{\n+\t  delete_breakpoint (b);\n+\t  continue;\n+\t}\n \n-    /* Just like single-step breakpoints.  */\n-    if (b->type == bp_single_step)\n-      {\n-\tdelete_breakpoint (b);\n-\tcontinue;\n-      }\n+      /* Step-resume breakpoints are meaningless after an exec().  */\n+      if (b->type == bp_step_resume || b->type == bp_hp_step_resume)\n+\t{\n+\t  delete_breakpoint (b);\n+\t  continue;\n+\t}\n \n-    /* Longjmp and longjmp-resume breakpoints are also meaningless\n-       after an exec.  */\n-    if (b->type == bp_longjmp || b->type == bp_longjmp_resume\n-\t|| b->type == bp_longjmp_call_dummy\n-\t|| b->type == bp_exception || b->type == bp_exception_resume)\n-      {\n-\tdelete_breakpoint (b);\n-\tcontinue;\n-      }\n+      /* Just like single-step breakpoints.  */\n+      if (b->type == bp_single_step)\n+\t{\n+\t  delete_breakpoint (b);\n+\t  continue;\n+\t}\n \n-    if (b->type == bp_catchpoint)\n-      {\n-\t/* For now, none of the bp_catchpoint breakpoints need to\n-\t   do anything at this point.  In the future, if some of\n-\t   the catchpoints need to something, we will need to add\n-\t   a new method, and call this method from here.  */\n-\tcontinue;\n-      }\n+      /* Longjmp and longjmp-resume breakpoints are also meaningless\n+\t after an exec.  */\n+      if (b->type == bp_longjmp || b->type == bp_longjmp_resume\n+\t  || b->type == bp_longjmp_call_dummy\n+\t  || b->type == bp_exception || b->type == bp_exception_resume)\n+\t{\n+\t  delete_breakpoint (b);\n+\t  continue;\n+\t}\n \n-    /* bp_finish is a special case.  The only way we ought to be able\n-       to see one of these when an exec() has happened, is if the user\n-       caught a vfork, and then said \"finish\".  Ordinarily a finish just\n-       carries them to the call-site of the current callee, by setting\n-       a temporary bp there and resuming.  But in this case, the finish\n-       will carry them entirely through the vfork & exec.\n-\n-       We don't want to allow a bp_finish to remain inserted now.  But\n-       we can't safely delete it, 'cause finish_command has a handle to\n-       the bp on a bpstat, and will later want to delete it.  There's a\n-       chance (and I've seen it happen) that if we delete the bp_finish\n-       here, that its storage will get reused by the time finish_command\n-       gets 'round to deleting the \"use to be a bp_finish\" breakpoint.\n-       We really must allow finish_command to delete a bp_finish.\n-\n-       In the absence of a general solution for the \"how do we know\n-       it's safe to delete something others may have handles to?\"\n-       problem, what we'll do here is just uninsert the bp_finish, and\n-       let finish_command delete it.\n-\n-       (We know the bp_finish is \"doomed\" in the sense that it's\n-       momentary, and will be deleted as soon as finish_command sees\n-       the inferior stopped.  So it doesn't matter that the bp's\n-       address is probably bogus in the new a.out, unlike e.g., the\n-       solib breakpoints.)  */\n-\n-    if (b->type == bp_finish)\n-      {\n-\tcontinue;\n-      }\n+      if (b->type == bp_catchpoint)\n+\t{\n+\t  /* For now, none of the bp_catchpoint breakpoints need to\n+\t     do anything at this point.  In the future, if some of\n+\t     the catchpoints need to something, we will need to add\n+\t     a new method, and call this method from here.  */\n+\t  continue;\n+\t}\n \n-    /* Without a symbolic address, we have little hope of the\n-       pre-exec() address meaning the same thing in the post-exec()\n-       a.out.  */\n-    if (breakpoint_event_location_empty_p (b))\n-      {\n-\tdelete_breakpoint (b);\n-\tcontinue;\n-      }\n-  }\n+      /* bp_finish is a special case.  The only way we ought to be able\n+\t to see one of these when an exec() has happened, is if the user\n+\t caught a vfork, and then said \"finish\".  Ordinarily a finish just\n+\t carries them to the call-site of the current callee, by setting\n+\t a temporary bp there and resuming.  But in this case, the finish\n+\t will carry them entirely through the vfork & exec.\n+\n+\t We don't want to allow a bp_finish to remain inserted now.  But\n+\t we can't safely delete it, 'cause finish_command has a handle to\n+\t the bp on a bpstat, and will later want to delete it.  There's a\n+\t chance (and I've seen it happen) that if we delete the bp_finish\n+\t here, that its storage will get reused by the time finish_command\n+\t gets 'round to deleting the \"use to be a bp_finish\" breakpoint.\n+\t We really must allow finish_command to delete a bp_finish.\n+\n+\t In the absence of a general solution for the \"how do we know\n+\t it's safe to delete something others may have handles to?\"\n+\t problem, what we'll do here is just uninsert the bp_finish, and\n+\t let finish_command delete it.\n+\n+\t (We know the bp_finish is \"doomed\" in the sense that it's\n+\t momentary, and will be deleted as soon as finish_command sees\n+\t the inferior stopped.  So it doesn't matter that the bp's\n+\t address is probably bogus in the new a.out, unlike e.g., the\n+\t solib breakpoints.)  */\n+\n+      if (b->type == bp_finish)\n+\t{\n+\t  continue;\n+\t}\n+\n+      /* Without a symbolic address, we have little hope of the\n+\t pre-exec() address meaning the same thing in the post-exec()\n+\t a.out.  */\n+      if (breakpoint_event_location_empty_p (b))\n+\t{\n+\t  delete_breakpoint (b);\n+\t  continue;\n+\t}\n+    }\n }\n \n int\n@@ -3728,22 +3728,22 @@ detach_breakpoints (ptid_t ptid)\n   /* Set inferior_ptid; remove_breakpoint_1 uses this global.  */\n   inferior_ptid = ptid;\n   for (bp_location *bl : all_bp_locations ())\n-  {\n-    if (bl->pspace != inf->pspace)\n-      continue;\n-\n-    /* This function must physically remove breakpoints locations\n-       from the specified ptid, without modifying the breakpoint\n-       package's state.  Locations of type bp_loc_other are only\n-       maintained at GDB side.  So, there is no need to remove\n-       these bp_loc_other locations.  Moreover, removing these\n-       would modify the breakpoint package's state.  */\n-    if (bl->loc_type == bp_loc_other)\n-      continue;\n-\n-    if (bl->inserted)\n-      val |= remove_breakpoint_1 (bl, DETACH_BREAKPOINT);\n-  }\n+    {\n+      if (bl->pspace != inf->pspace)\n+\tcontinue;\n+\n+      /* This function must physically remove breakpoints locations\n+\t from the specified ptid, without modifying the breakpoint\n+\t package's state.  Locations of type bp_loc_other are only\n+\t maintained at GDB side.  So, there is no need to remove\n+\t these bp_loc_other locations.  Moreover, removing these\n+\t would modify the breakpoint package's state.  */\n+      if (bl->loc_type == bp_loc_other)\n+\tcontinue;\n+\n+      if (bl->inserted)\n+\tval |= remove_breakpoint_1 (bl, DETACH_BREAKPOINT);\n+    }\n \n   return val;\n }\n@@ -3952,83 +3952,83 @@ breakpoint_init_inferior (enum inf_context context)\n   mark_breakpoints_out ();\n \n   for (breakpoint *b : all_breakpoints_safe ())\n-  {\n-    if (b->loc && b->loc->pspace != pspace)\n-      continue;\n+    {\n+      if (b->loc && b->loc->pspace != pspace)\n+\tcontinue;\n \n-    switch (b->type)\n-      {\n-      case bp_call_dummy:\n-      case bp_longjmp_call_dummy:\n+      switch (b->type)\n+\t{\n+\tcase bp_call_dummy:\n+\tcase bp_longjmp_call_dummy:\n \n-\t/* If the call dummy breakpoint is at the entry point it will\n-\t   cause problems when the inferior is rerun, so we better get\n-\t   rid of it.  */\n+\t  /* If the call dummy breakpoint is at the entry point it will\n+\t     cause problems when the inferior is rerun, so we better get\n+\t     rid of it.  */\n \n-      case bp_watchpoint_scope:\n+\tcase bp_watchpoint_scope:\n \n-\t/* Also get rid of scope breakpoints.  */\n+\t  /* Also get rid of scope breakpoints.  */\n \n-      case bp_shlib_event:\n+\tcase bp_shlib_event:\n \n-\t/* Also remove solib event breakpoints.  Their addresses may\n-\t   have changed since the last time we ran the program.\n-\t   Actually we may now be debugging against different target;\n-\t   and so the solib backend that installed this breakpoint may\n-\t   not be used in by the target.  E.g.,\n+\t  /* Also remove solib event breakpoints.  Their addresses may\n+\t     have changed since the last time we ran the program.\n+\t     Actually we may now be debugging against different target;\n+\t     and so the solib backend that installed this breakpoint may\n+\t     not be used in by the target.  E.g.,\n \n-\t   (gdb) file prog-linux\n-\t   (gdb) run               # native linux target\n-\t   ...\n-\t   (gdb) kill\n-\t   (gdb) file prog-win.exe\n-\t   (gdb) tar rem :9999     # remote Windows gdbserver.\n-\t*/\n+\t     (gdb) file prog-linux\n+\t     (gdb) run               # native linux target\n+\t     ...\n+\t     (gdb) kill\n+\t     (gdb) file prog-win.exe\n+\t     (gdb) tar rem :9999     # remote Windows gdbserver.\n+\t  */\n \n-      case bp_step_resume:\n+\tcase bp_step_resume:\n \n-\t/* Also remove step-resume breakpoints.  */\n+\t  /* Also remove step-resume breakpoints.  */\n \n-      case bp_single_step:\n+\tcase bp_single_step:\n \n-\t/* Also remove single-step breakpoints.  */\n+\t  /* Also remove single-step breakpoints.  */\n \n-\tdelete_breakpoint (b);\n-\tbreak;\n+\t  delete_breakpoint (b);\n+\t  break;\n \n-      case bp_watchpoint:\n-      case bp_hardware_watchpoint:\n-      case bp_read_watchpoint:\n-      case bp_access_watchpoint:\n-\t{\n-\t  struct watchpoint *w = (struct watchpoint *) b;\n+\tcase bp_watchpoint:\n+\tcase bp_hardware_watchpoint:\n+\tcase bp_read_watchpoint:\n+\tcase bp_access_watchpoint:\n+\t  {\n+\t    struct watchpoint *w = (struct watchpoint *) b;\n \n-\t  /* Likewise for watchpoints on local expressions.  */\n-\t  if (w->exp_valid_block != NULL)\n-\t    delete_breakpoint (b);\n-\t  else\n-\t    {\n-\t      /* Get rid of existing locations, which are no longer\n-\t\t valid.  New ones will be created in\n-\t\t update_watchpoint, when the inferior is restarted.\n-\t\t The next update_global_location_list call will\n-\t\t garbage collect them.  */\n-\t      b->loc = NULL;\n-\n-\t      if (context == inf_starting)\n-\t\t{\n-\t\t  /* Reset val field to force reread of starting value in\n-\t\t     insert_breakpoints.  */\n-\t\t  w->val.reset (nullptr);\n-\t\t  w->val_valid = false;\n-\t\t}\n-\t    }\n+\t    /* Likewise for watchpoints on local expressions.  */\n+\t    if (w->exp_valid_block != NULL)\n+\t      delete_breakpoint (b);\n+\t    else\n+\t      {\n+\t\t/* Get rid of existing locations, which are no longer\n+\t\t   valid.  New ones will be created in\n+\t\t   update_watchpoint, when the inferior is restarted.\n+\t\t   The next update_global_location_list call will\n+\t\t   garbage collect them.  */\n+\t\tb->loc = NULL;\n+\n+\t\tif (context == inf_starting)\n+\t\t  {\n+\t\t    /* Reset val field to force reread of starting value in\n+\t\t       insert_breakpoints.  */\n+\t\t    w->val.reset (nullptr);\n+\t\t    w->val_valid = false;\n+\t\t  }\n+\t      }\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  break;\n \t}\n-\tbreak;\n-      default:\n-\tbreak;\n-      }\n-  }\n+    }\n \n   /* Get rid of the moribund locations.  */\n   for (bp_location *bl : moribund_locations)\n@@ -7394,23 +7394,23 @@ enable_overlay_breakpoints (void)\n {\n   for (breakpoint *b : all_breakpoints ())\n     if (b->type == bp_overlay_event)\n-    {\n-      b->enable_state = bp_enabled;\n-      update_global_location_list (UGLL_MAY_INSERT);\n-      overlay_events_enabled = 1;\n-    }\n+      {\n+\tb->enable_state = bp_enabled;\n+\tupdate_global_location_list (UGLL_MAY_INSERT);\n+\toverlay_events_enabled = 1;\n+      }\n }\n \n void\n disable_overlay_breakpoints (void)\n {\n   for (breakpoint *b : all_breakpoints ())\n     if (b->type == bp_overlay_event)\n-    {\n-      b->enable_state = bp_disabled;\n-      update_global_location_list (UGLL_DONT_INSERT);\n-      overlay_events_enabled = 0;\n-    }\n+      {\n+\tb->enable_state = bp_disabled;\n+\tupdate_global_location_list (UGLL_DONT_INSERT);\n+\toverlay_events_enabled = 0;\n+      }\n }\n \n /* Set an active std::terminate breakpoint for each std::terminate\n@@ -7546,27 +7546,27 @@ void\n disable_breakpoints_in_shlibs (void)\n {\n   for (bp_location *loc : all_bp_locations ())\n-  {\n-    /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */\n-    struct breakpoint *b = loc->owner;\n-\n-    /* We apply the check to all breakpoints, including disabled for\n-       those with loc->duplicate set.  This is so that when breakpoint\n-       becomes enabled, or the duplicate is removed, gdb will try to\n-       insert all breakpoints.  If we don't set shlib_disabled here,\n-       we'll try to insert those breakpoints and fail.  */\n-    if (((b->type == bp_breakpoint)\n-\t || (b->type == bp_jit_event)\n-\t || (b->type == bp_hardware_breakpoint)\n-\t || (is_tracepoint (b)))\n-\t&& loc->pspace == current_program_space\n-\t&& !loc->shlib_disabled\n-\t&& solib_name_from_address (loc->pspace, loc->address)\n-\t)\n-      {\n-\tloc->shlib_disabled = 1;\n-      }\n-  }\n+    {\n+      /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */\n+      struct breakpoint *b = loc->owner;\n+\n+      /* We apply the check to all breakpoints, including disabled for\n+\t those with loc->duplicate set.  This is so that when breakpoint\n+\t becomes enabled, or the duplicate is removed, gdb will try to\n+\t insert all breakpoints.  If we don't set shlib_disabled here,\n+\t we'll try to insert those breakpoints and fail.  */\n+      if (((b->type == bp_breakpoint)\n+\t   || (b->type == bp_jit_event)\n+\t   || (b->type == bp_hardware_breakpoint)\n+\t   || (is_tracepoint (b)))\n+\t  && loc->pspace == current_program_space\n+\t  && !loc->shlib_disabled\n+\t  && solib_name_from_address (loc->pspace, loc->address)\n+\t  )\n+\t{\n+\t  loc->shlib_disabled = 1;\n+\t}\n+    }\n }\n \n /* Disable any breakpoints and tracepoints that are in SOLIB upon\n@@ -7579,39 +7579,39 @@ disable_breakpoints_in_unloaded_shlib (struct so_list *solib)\n   int disabled_shlib_breaks = 0;\n \n   for (bp_location *loc : all_bp_locations ())\n-  {\n-    /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */\n-    struct breakpoint *b = loc->owner;\n-\n-    if (solib->pspace == loc->pspace\n-\t&& !loc->shlib_disabled\n-\t&& (((b->type == bp_breakpoint\n-\t      || b->type == bp_jit_event\n-\t      || b->type == bp_hardware_breakpoint)\n-\t     && (loc->loc_type == bp_loc_hardware_breakpoint\n-\t\t || loc->loc_type == bp_loc_software_breakpoint))\n-\t    || is_tracepoint (b))\n-\t&& solib_contains_address_p (solib, loc->address))\n-      {\n-\tloc->shlib_disabled = 1;\n-\t/* At this point, we cannot rely on remove_breakpoint\n-\t   succeeding so we must mark the breakpoint as not inserted\n-\t   to prevent future errors occurring in remove_breakpoints.  */\n-\tloc->inserted = 0;\n-\n-\t/* This may cause duplicate notifications for the same breakpoint.  */\n-\tgdb::observers::breakpoint_modified.notify (b);\n-\n-\tif (!disabled_shlib_breaks)\n-\t  {\n-\t    target_terminal::ours_for_output ();\n-\t    warning (_(\"Temporarily disabling breakpoints \"\n-\t\t       \"for unloaded shared library \\\"%s\\\"\"),\n-\t\t     solib->so_name);\n-\t  }\n-\tdisabled_shlib_breaks = 1;\n-      }\n-  }\n+    {\n+      /* ALL_BP_LOCATIONS bp_location has LOC->OWNER always non-NULL.  */\n+      struct breakpoint *b = loc->owner;\n+\n+      if (solib->pspace == loc->pspace\n+\t  && !loc->shlib_disabled\n+\t  && (((b->type == bp_breakpoint\n+\t\t|| b->type == bp_jit_event\n+\t\t|| b->type == bp_hardware_breakpoint)\n+\t       && (loc->loc_type == bp_loc_hardware_breakpoint\n+\t\t   || loc->loc_type == bp_loc_software_breakpoint))\n+\t      || is_tracepoint (b))\n+\t  && solib_contains_address_p (solib, loc->address))\n+\t{\n+\t  loc->shlib_disabled = 1;\n+\t  /* At this point, we cannot rely on remove_breakpoint\n+\t     succeeding so we must mark the breakpoint as not inserted\n+\t     to prevent future errors occurring in remove_breakpoints.  */\n+\t  loc->inserted = 0;\n+\n+\t  /* This may cause duplicate notifications for the same breakpoint.  */\n+\t  gdb::observers::breakpoint_modified.notify (b);\n+\n+\t  if (!disabled_shlib_breaks)\n+\t    {\n+\t      target_terminal::ours_for_output ();\n+\t      warning (_(\"Temporarily disabling breakpoints \"\n+\t\t\t \"for unloaded shared library \\\"%s\\\"\"),\n+\t\t       solib->so_name);\n+\t    }\n+\t  disabled_shlib_breaks = 1;\n+\t}\n+    }\n }\n \n /* Disable any breakpoints and tracepoints in OBJFILE upon\n@@ -7975,22 +7975,22 @@ breakpoint_hit_catch_solib (const struct bp_location *bl,\n     return 1;\n \n   for (breakpoint *other : all_breakpoints ())\n-  {\n-    if (other == bl->owner)\n-      continue;\n+    {\n+      if (other == bl->owner)\n+\tcontinue;\n \n-    if (other->type != bp_shlib_event)\n-      continue;\n+      if (other->type != bp_shlib_event)\n+\tcontinue;\n \n-    if (self->pspace != NULL && other->pspace != self->pspace)\n-      continue;\n+      if (self->pspace != NULL && other->pspace != self->pspace)\n+\tcontinue;\n \n-    for (bp_location *other_bl : other->locations ())\n-      {\n-\tif (other->ops->breakpoint_hit (other_bl, aspace, bp_addr, ws))\n-\t  return 1;\n-      }\n-  }\n+      for (bp_location *other_bl : other->locations ())\n+\t{\n+\t  if (other->ops->breakpoint_hit (other_bl, aspace, bp_addr, ws))\n+\t    return 1;\n+\t}\n+    }\n \n   return 0;\n }\n@@ -13174,10 +13174,10 @@ delete_breakpoint (struct breakpoint *bpt)\n \n   for (breakpoint *b : all_breakpoints ())\n     if (b->next == bpt)\n-    {\n-      b->next = bpt->next;\n-      break;\n-    }\n+      {\n+\tb->next = bpt->next;\n+\tbreak;\n+      }\n \n   /* Be sure no bpstat's are pointing at the breakpoint after it's\n      been freed.  */\n@@ -13913,33 +13913,33 @@ set_ignore_count (int bptnum, int count, int from_tty)\n \n   for (breakpoint *b : all_breakpoints ())\n     if (b->number == bptnum)\n-    {\n-      if (is_tracepoint (b))\n-\t{\n-\t  if (from_tty && count != 0)\n-\t    printf_filtered (_(\"Ignore count ignored for tracepoint %d.\"),\n-\t\t\t     bptnum);\n-\t  return;\n-\t}\n-      \n-      b->ignore_count = count;\n-      if (from_tty)\n-\t{\n-\t  if (count == 0)\n-\t    printf_filtered (_(\"Will stop next time \"\n-\t\t\t       \"breakpoint %d is reached.\"),\n-\t\t\t     bptnum);\n-\t  else if (count == 1)\n-\t    printf_filtered (_(\"Will ignore next crossing of breakpoint %d.\"),\n-\t\t\t     bptnum);\n-\t  else\n-\t    printf_filtered (_(\"Will ignore next %d \"\n-\t\t\t       \"crossings of breakpoint %d.\"),\n-\t\t\t     count, bptnum);\n-\t}\n-      gdb::observers::breakpoint_modified.notify (b);\n-      return;\n-    }\n+      {\n+\tif (is_tracepoint (b))\n+\t  {\n+\t    if (from_tty && count != 0)\n+\t      printf_filtered (_(\"Ignore count ignored for tracepoint %d.\"),\n+\t\t\t       bptnum);\n+\t    return;\n+\t  }\n+\n+\tb->ignore_count = count;\n+\tif (from_tty)\n+\t  {\n+\t    if (count == 0)\n+\t      printf_filtered (_(\"Will stop next time \"\n+\t\t\t\t \"breakpoint %d is reached.\"),\n+\t\t\t       bptnum);\n+\t    else if (count == 1)\n+\t      printf_filtered (_(\"Will ignore next crossing of breakpoint %d.\"),\n+\t\t\t       bptnum);\n+\t    else\n+\t      printf_filtered (_(\"Will ignore next %d \"\n+\t\t\t\t \"crossings of breakpoint %d.\"),\n+\t\t\t       count, bptnum);\n+\t  }\n+\tgdb::observers::breakpoint_modified.notify (b);\n+\treturn;\n+      }\n \n   error (_(\"No breakpoint number %d.\"), bptnum);\n }\n@@ -14846,10 +14846,10 @@ trace_pass_command (const char *args, int from_tty)\n \terror (_(\"Junk at end of arguments.\"));\n \n       for (breakpoint *b : all_tracepoints ())\n-      {\n-\tt1 = (struct tracepoint *) b;\n-\ttrace_pass_set_count (t1, count, from_tty);\n-      }\n+\t{\n+\t  t1 = (struct tracepoint *) b;\n+\t  trace_pass_set_count (t1, count, from_tty);\n+\t}\n     }\n   else if (*args == '\\0')\n     {\n@@ -14931,9 +14931,7 @@ get_tracepoint_by_number (const char **arg,\n \n   for (breakpoint *t : all_tracepoints ())\n     if (t->number == tpnum)\n-    {\n       return (struct tracepoint *) t;\n-    }\n \n   printf_unfiltered (\"No tracepoint number %d.\\n\", tpnum);\n   return NULL;\n@@ -14968,25 +14966,25 @@ save_breakpoints (const char *filename, int from_tty,\n \n   /* See if we have anything to save.  */\n   for (breakpoint *tp : all_breakpoints ())\n-  {\n-    /* Skip internal and momentary breakpoints.  */\n-    if (!user_breakpoint_p (tp))\n-      continue;\n+    {\n+      /* Skip internal and momentary breakpoints.  */\n+      if (!user_breakpoint_p (tp))\n+\tcontinue;\n \n-    /* If we have a filter, only save the breakpoints it accepts.  */\n-    if (filter && !filter (tp))\n-      continue;\n+      /* If we have a filter, only save the breakpoints it accepts.  */\n+      if (filter && !filter (tp))\n+\tcontinue;\n \n-    any = 1;\n+      any = 1;\n \n-    if (is_tracepoint (tp))\n-      {\n-\textra_trace_bits = 1;\n+      if (is_tracepoint (tp))\n+\t{\n+\t  extra_trace_bits = 1;\n \n-\t/* We can stop searching.  */\n-\tbreak;\n-      }\n-  }\n+\t  /* We can stop searching.  */\n+\t  break;\n+\t}\n+    }\n \n   if (!any)\n     {\n@@ -15006,65 +15004,65 @@ save_breakpoints (const char *filename, int from_tty,\n     save_trace_state_variables (&fp);\n \n   for (breakpoint *tp : all_breakpoints ())\n-  {\n-    /* Skip internal and momentary breakpoints.  */\n-    if (!user_breakpoint_p (tp))\n-      continue;\n+    {\n+      /* Skip internal and momentary breakpoints.  */\n+      if (!user_breakpoint_p (tp))\n+\tcontinue;\n \n-    /* If we have a filter, only save the breakpoints it accepts.  */\n-    if (filter && !filter (tp))\n-      continue;\n+      /* If we have a filter, only save the breakpoints it accepts.  */\n+      if (filter && !filter (tp))\n+\tcontinue;\n \n-    tp->ops->print_recreate (tp, &fp);\n+      tp->ops->print_recreate (tp, &fp);\n \n-    /* Note, we can't rely on tp->number for anything, as we can't\n-       assume the recreated breakpoint numbers will match.  Use $bpnum\n-       instead.  */\n+      /* Note, we can't rely on tp->number for anything, as we can't\n+\t assume the recreated breakpoint numbers will match.  Use $bpnum\n+\t instead.  */\n \n-    if (tp->cond_string)\n-      fp.printf (\"  condition $bpnum %s\\n\", tp->cond_string);\n+      if (tp->cond_string)\n+\tfp.printf (\"  condition $bpnum %s\\n\", tp->cond_string);\n \n-    if (tp->ignore_count)\n-      fp.printf (\"  ignore $bpnum %d\\n\", tp->ignore_count);\n+      if (tp->ignore_count)\n+\tfp.printf (\"  ignore $bpnum %d\\n\", tp->ignore_count);\n \n-    if (tp->type != bp_dprintf && tp->commands)\n-      {\n-\tfp.puts (\"  commands\\n\");\n-\t\n-\tcurrent_uiout->redirect (&fp);\n-\ttry\n-\t  {\n-\t    print_command_lines (current_uiout, tp->commands.get (), 2);\n-\t  }\n-\tcatch (const gdb_exception &ex)\n-\t  {\n-\t  current_uiout->redirect (NULL);\n-\t    throw;\n-\t  }\n+      if (tp->type != bp_dprintf && tp->commands)\n+\t{\n+\t  fp.puts (\"  commands\\n\");\n \n-\tcurrent_uiout->redirect (NULL);\n-\tfp.puts (\"  end\\n\");\n-      }\n+\t  current_uiout->redirect (&fp);\n+\t  try\n+\t    {\n+\t      print_command_lines (current_uiout, tp->commands.get (), 2);\n+\t    }\n+\t  catch (const gdb_exception &ex)\n+\t    {\n+\t    current_uiout->redirect (NULL);\n+\t      throw;\n+\t    }\n \n-    if (tp->enable_state == bp_disabled)\n-      fp.puts (\"disable $bpnum\\n\");\n+\t  current_uiout->redirect (NULL);\n+\t  fp.puts (\"  end\\n\");\n+\t}\n \n-    /* If this is a multi-location breakpoint, check if the locations\n-       should be individually disabled.  Watchpoint locations are\n-       special, and not user visible.  */\n-    if (!is_watchpoint (tp) && tp->loc && tp->loc->next)\n-      {\n-\tint n = 1;\n+      if (tp->enable_state == bp_disabled)\n+\tfp.puts (\"disable $bpnum\\n\");\n \n-\tfor (bp_location *loc : tp->locations ())\n-\t  {\n-\t    if (!loc->enabled)\n-\t      fp.printf (\"disable $bpnum.%d\\n\", n);\n+      /* If this is a multi-location breakpoint, check if the locations\n+\t should be individually disabled.  Watchpoint locations are\n+\t special, and not user visible.  */\n+      if (!is_watchpoint (tp) && tp->loc && tp->loc->next)\n+\t{\n+\t  int n = 1;\n \n-\t    n++;\n-\t  }\n-      }\n-  }\n+\t  for (bp_location *loc : tp->locations ())\n+\t    {\n+\t      if (!loc->enabled)\n+\t\tfp.printf (\"disable $bpnum.%d\\n\", n);\n+\n+\t      n++;\n+\t    }\n+\t}\n+    }\n \n   if (extra_trace_bits && *default_collect)\n     fp.printf (\"set default-collect %s\\n\", default_collect);"
    },
    {
      "sha": "ef730df9f0b100e8d243c3c7766cbc539f0954d4",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -1150,10 +1150,10 @@ ctf_add_var_cb (const char *name, ctf_id_t id, void *arg)\n       case CTF_K_UNION:\n       case CTF_K_ENUM:\n \tif (type == nullptr)\n-\t{\n-\t  complaint (_(\"ctf_add_var_cb: %s has NO type (%ld)\"), name, id);\n-\t  type = objfile_type (ccp->of)->builtin_error;\n-\t}\n+\t  {\n+\t    complaint (_(\"ctf_add_var_cb: %s has NO type (%ld)\"), name, id);\n+\t    type = objfile_type (ccp->of)->builtin_error;\n+\t  }\n \tsym = new (&ccp->of->objfile_obstack) symbol;\n \tOBJSTAT (ccp->of, n_syms++);\n \tSYMBOL_TYPE (sym) = type;"
    },
    {
      "sha": "dbc82f0a4ac41a7123e8dd598cd45a0b6016fcdd",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 7,
      "deletions": 5,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -4792,11 +4792,13 @@ rank_one_type (struct type *parm, struct type *arg, struct value *value)\n     return (sum_ranks (rank_one_type (TYPE_TARGET_TYPE (parm), arg, NULL),\n \t\t       REFERENCE_SEE_THROUGH_BADNESS));\n   if (overload_debug)\n-  /* Debugging only.  */\n-    fprintf_filtered (gdb_stderr,\n-\t\t      \"------ Arg is %s [%d], parm is %s [%d]\\n\",\n-\t\t      arg->name (), arg->code (),\n-\t\t      parm->name (), parm->code ());\n+    {\n+      /* Debugging only.  */\n+      fprintf_filtered (gdb_stderr,\n+\t\t\t\"------ Arg is %s [%d], parm is %s [%d]\\n\",\n+\t\t\targ->name (), arg->code (),\n+\t\t\tparm->name (), parm->code ());\n+    }\n \n   /* x -> y means arg of type x being supplied for parameter of type y.  */\n "
    },
    {
      "sha": "093ed9e792ecea07bebacd27032c8f9454674bcd",
      "filename": "gdb/go32-nat.c",
      "status": "modified",
      "additions": 63,
      "deletions": 63,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/go32-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/go32-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go32-nat.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -401,18 +401,18 @@ go32_nat_target::resume (ptid_t ptid, int step, enum gdb_signal siggnal)\n   resume_is_step = step;\n \n   if (siggnal != GDB_SIGNAL_0 && siggnal != GDB_SIGNAL_TRAP)\n-  {\n-    for (i = 0, resume_signal = -1;\n-\t excepn_map[i].gdb_sig != GDB_SIGNAL_LAST; i++)\n-      if (excepn_map[i].gdb_sig == siggnal)\n-      {\n-\tresume_signal = excepn_map[i].djgpp_excepno;\n-\tbreak;\n-      }\n-    if (resume_signal == -1)\n-      printf_unfiltered (\"Cannot deliver signal %s on this platform.\\n\",\n-\t\t\t gdb_signal_to_name (siggnal));\n-  }\n+    {\n+      for (i = 0, resume_signal = -1;\n+\t   excepn_map[i].gdb_sig != GDB_SIGNAL_LAST; i++)\n+\tif (excepn_map[i].gdb_sig == siggnal)\n+\t  {\n+\t    resume_signal = excepn_map[i].djgpp_excepno;\n+\t    break;\n+\t  }\n+      if (resume_signal == -1)\n+\tprintf_unfiltered (\"Cannot deliver signal %s on this platform.\\n\",\n+\t\t\t   gdb_signal_to_name (siggnal));\n+    }\n }\n \n static char child_cwd[FILENAME_MAX];\n@@ -872,14 +872,14 @@ device_mode (int fd, int raw_p)\n     newmode &= ~0x20;\n \n   if (oldmode & 0x80)\t/* Only for character dev.  */\n-  {\n-    regs.x.ax = 0x4401;\n-    regs.x.bx = fd;\n-    regs.x.dx = newmode & 0xff;   /* Force upper byte zero, else it fails.  */\n-    __dpmi_int (0x21, &regs);\n-    if (regs.x.flags & 1)\n-      return -1;\n-  }\n+    {\n+      regs.x.ax = 0x4401;\n+      regs.x.bx = fd;\n+      regs.x.dx = newmode & 0xff;   /* Force upper byte zero, else it fails.  */\n+      __dpmi_int (0x21, &regs);\n+      if (regs.x.flags & 1)\n+\treturn -1;\n+    }\n   return (oldmode & 0x20) == 0x20;\n }\n \n@@ -909,24 +909,24 @@ go32_nat_target::terminal_info (const char *args, int from_tty)\n \n #if __DJGPP_MINOR__ > 2\n   if (child_cmd.redirection)\n-  {\n-    int i;\n-\n-    for (i = 0; i < DBG_HANDLES; i++)\n     {\n-      if (child_cmd.redirection[i]->file_name)\n-\tprintf_unfiltered (\"\\tFile handle %d is redirected to `%s'.\\n\",\n-\t\t\t   i, child_cmd.redirection[i]->file_name);\n-      else if (_get_dev_info (child_cmd.redirection[i]->inf_handle) == -1)\n-\tprintf_unfiltered\n-\t  (\"\\tFile handle %d appears to be closed by inferior.\\n\", i);\n-      /* Mask off the raw/cooked bit when comparing device info words.  */\n-      else if ((_get_dev_info (child_cmd.redirection[i]->inf_handle) & 0xdf)\n-\t       != (_get_dev_info (i) & 0xdf))\n-\tprintf_unfiltered\n-\t  (\"\\tFile handle %d appears to be redirected by inferior.\\n\", i);\n+      int i;\n+\n+      for (i = 0; i < DBG_HANDLES; i++)\n+\t{\n+\t  if (child_cmd.redirection[i]->file_name)\n+\t    printf_unfiltered (\"\\tFile handle %d is redirected to `%s'.\\n\",\n+\t\t\t       i, child_cmd.redirection[i]->file_name);\n+\t  else if (_get_dev_info (child_cmd.redirection[i]->inf_handle) == -1)\n+\t    printf_unfiltered\n+\t      (\"\\tFile handle %d appears to be closed by inferior.\\n\", i);\n+\t  /* Mask off the raw/cooked bit when comparing device info words.  */\n+\t  else if ((_get_dev_info (child_cmd.redirection[i]->inf_handle) & 0xdf)\n+\t\t   != (_get_dev_info (i) & 0xdf))\n+\t    printf_unfiltered\n+\t      (\"\\tFile handle %d appears to be redirected by inferior.\\n\", i);\n+\t}\n     }\n-  }\n #endif\n }\n \n@@ -936,19 +936,19 @@ go32_nat_target::terminal_inferior ()\n   /* Redirect standard handles as child wants them.  */\n   errno = 0;\n   if (redir_to_child (&child_cmd) == -1)\n-  {\n-    redir_to_debugger (&child_cmd);\n-    error (_(\"Cannot redirect standard handles for program: %s.\"),\n-\t   safe_strerror (errno));\n-  }\n+    {\n+      redir_to_debugger (&child_cmd);\n+      error (_(\"Cannot redirect standard handles for program: %s.\"),\n+\t     safe_strerror (errno));\n+    }\n   /* Set the console device of the inferior to whatever mode\n      (raw or cooked) we found it last time.  */\n   if (terminal_is_ours)\n-  {\n-    if (inf_mode_valid)\n-      device_mode (0, inf_terminal_mode);\n-    terminal_is_ours = 0;\n-  }\n+    {\n+      if (inf_mode_valid)\n+\tdevice_mode (0, inf_terminal_mode);\n+      terminal_is_ours = 0;\n+    }\n }\n \n void\n@@ -957,25 +957,25 @@ go32_nat_target::terminal_ours ()\n   /* Switch to cooked mode on the gdb terminal and save the inferior\n      terminal mode to be restored when it is resumed.  */\n   if (!terminal_is_ours)\n-  {\n-    inf_terminal_mode = device_mode (0, 0);\n-    if (inf_terminal_mode != -1)\n-      inf_mode_valid = 1;\n-    else\n-      /* If device_mode returned -1, we don't know what happens with\n-\t handle 0 anymore, so make the info invalid.  */\n-      inf_mode_valid = 0;\n-    terminal_is_ours = 1;\n-\n-    /* Restore debugger's standard handles.  */\n-    errno = 0;\n-    if (redir_to_debugger (&child_cmd) == -1)\n     {\n-      redir_to_child (&child_cmd);\n-      error (_(\"Cannot redirect standard handles for debugger: %s.\"),\n-\t     safe_strerror (errno));\n+      inf_terminal_mode = device_mode (0, 0);\n+      if (inf_terminal_mode != -1)\n+\tinf_mode_valid = 1;\n+      else\n+\t/* If device_mode returned -1, we don't know what happens with\n+\t   handle 0 anymore, so make the info invalid.  */\n+\tinf_mode_valid = 0;\n+      terminal_is_ours = 1;\n+\n+      /* Restore debugger's standard handles.  */\n+      errno = 0;\n+      if (redir_to_debugger (&child_cmd) == -1)\n+\t{\n+\t  redir_to_child (&child_cmd);\n+\t  error (_(\"Cannot redirect standard handles for debugger: %s.\"),\n+\t\t safe_strerror (errno));\n+\t}\n     }\n-  }\n }\n \n void"
    },
    {
      "sha": "96a3ef584c9b2ac09ddc7ed17d8cb6e8a2722158",
      "filename": "gdb/guile/scm-pretty-print.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/guile/scm-pretty-print.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/guile/scm-pretty-print.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-pretty-print.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -824,10 +824,10 @@ ppscm_print_children (SCM printer, enum display_hint hint,\n \t 2. Arrays.  Always print a \",\".\n \t 3. Other.  Always print a \",\".  */\n       if (i == 0)\n-      {\n-\tif (!printed_nothing)\n-\t  fputs_filtered (\" = \", stream);\n-      }\n+\t{\n+\t  if (!printed_nothing)\n+\t    fputs_filtered (\" = \", stream);\n+\t}\n       else if (! is_map || i % 2 == 0)\n \tfputs_filtered (pretty ? \",\" : \", \", stream);\n "
    },
    {
      "sha": "a4d1ceeeeb86d949166b2d07dcece7e77ff822e3",
      "filename": "gdb/hppa-linux-tdep.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/hppa-linux-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/hppa-linux-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-linux-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -174,9 +174,7 @@ hppa_linux_sigtramp_find_sigcontext (struct gdbarch *gdbarch, CORE_ADDR pc)\n \t  sp = pc - pcoffs[attempt];\n \t}\n       else\n-      {\n \treturn 0;\n-      }\n     }\n \n   /* sp + sfoffs[try] points to a struct rt_sigframe, which contains"
    },
    {
      "sha": "7f9405ce3dd46c8dfc1fbca97e0212a03ed60936",
      "filename": "gdb/i386-tdep.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/i386-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/i386-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/i386-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -4967,10 +4967,8 @@ static int i386_record_floats (struct gdbarch *gdbarch,\n   else if (I386_SAVE_FPU_ENV_REG_STACK == iregnum)\n     {\n       for (i = I387_ST0_REGNUM (tdep); i <= I387_FOP_REGNUM (tdep); i++)\n-      {\n \tif (record_full_arch_list_add_reg (ir->regcache, i))\n \t  return -1;\n-      }\n     }\n   else if ((iregnum >= I387_ST0_REGNUM (tdep)) &&\n \t   (iregnum <= I387_FOP_REGNUM (tdep)))"
    },
    {
      "sha": "0d7efbc94131f5a93e1f2d5e6472c4a0536442c7",
      "filename": "gdb/mi/mi-symbol-cmds.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/mi/mi-symbol-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/mi/mi-symbol-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-symbol-cmds.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -55,11 +55,11 @@ mi_cmd_symbol_list_lines (const char *command, char **argv, int argc)\n   ui_out_emit_list list_emitter (uiout, \"lines\");\n   if (SYMTAB_LINETABLE (s) != NULL && SYMTAB_LINETABLE (s)->nitems > 0)\n     for (i = 0; i < SYMTAB_LINETABLE (s)->nitems; i++)\n-    {\n-      ui_out_emit_tuple tuple_emitter (uiout, NULL);\n-      uiout->field_core_addr (\"pc\", gdbarch, SYMTAB_LINETABLE (s)->item[i].pc);\n-      uiout->field_signed (\"line\", SYMTAB_LINETABLE (s)->item[i].line);\n-    }\n+      {\n+\tui_out_emit_tuple tuple_emitter (uiout, NULL);\n+\tuiout->field_core_addr (\"pc\", gdbarch, SYMTAB_LINETABLE (s)->item[i].pc);\n+\tuiout->field_signed (\"line\", SYMTAB_LINETABLE (s)->item[i].line);\n+      }\n }\n \n /* Used by the -symbol-info-* and -symbol-info-module-* commands to print"
    },
    {
      "sha": "8b162cd35a35bff243bec0a6ca41b36413fb09c3",
      "filename": "gdb/nat/aarch64-sve-linux-ptrace.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/nat/aarch64-sve-linux-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/nat/aarch64-sve-linux-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/aarch64-sve-linux-ptrace.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -100,17 +100,17 @@ aarch64_sve_set_vq (int tid, struct reg_buffer_common *reg_buf)\n      inferior function call, and the VG register comes after the Z\n      registers.  */\n   if (reg_buf->get_register_status (AARCH64_SVE_VG_REGNUM) != REG_VALID)\n-  {\n-    /* If vg is not available yet, fetch it from ptrace.  The VG value from\n-       ptrace is likely the correct one.  */\n-    uint64_t vq = aarch64_sve_get_vq (tid);\n+    {\n+      /* If vg is not available yet, fetch it from ptrace.  The VG value from\n+\t ptrace is likely the correct one.  */\n+      uint64_t vq = aarch64_sve_get_vq (tid);\n \n-    /* If something went wrong, just bail out.  */\n-    if (vq == 0)\n-      return false;\n+      /* If something went wrong, just bail out.  */\n+      if (vq == 0)\n+\treturn false;\n \n-    reg_vg = sve_vg_from_vq (vq);\n-  }\n+      reg_vg = sve_vg_from_vq (vq);\n+    }\n   else\n     reg_buf->raw_collect (AARCH64_SVE_VG_REGNUM, &reg_vg);\n "
    },
    {
      "sha": "5d4ab5dc071271c224488f9445b9a1fb396b66dd",
      "filename": "gdb/nios2-tdep.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/nios2-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/nios2-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nios2-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -249,15 +249,15 @@ nios2_setup_default (struct nios2_unwind_cache *cache)\n   int i;\n \n   for (i = 0; i < NIOS2_NUM_REGS; i++)\n-  {\n-    /* All registers start off holding their previous values.  */\n-    cache->reg_value[i].reg    = i;\n-    cache->reg_value[i].offset = 0;\n-\n-    /* All registers start off not saved.  */\n-    cache->reg_saved[i].basereg = -1;\n-    cache->reg_saved[i].addr    = 0;\n-  }\n+    {\n+      /* All registers start off holding their previous values.  */\n+      cache->reg_value[i].reg    = i;\n+      cache->reg_value[i].offset = 0;\n+\n+      /* All registers start off not saved.  */\n+      cache->reg_saved[i].basereg = -1;\n+      cache->reg_saved[i].addr    = 0;\n+    }\n }\n \n /* Initialize the unwind cache.  */\n@@ -1244,16 +1244,16 @@ nios2_analyze_prologue (struct gdbarch *gdbarch, const CORE_ADDR start_pc,\n       enum branch_condition cond;\n \n       if (pc == current_pc)\n-      {\n-\t/* When we reach the current PC we must save the current\n-\t   register state (for the backtrace) but keep analysing\n-\t   because there might be more to find out (eg. is this an\n-\t   exception handler).  */\n-\tmemcpy (temp_value, value, sizeof (temp_value));\n-\tvalue = temp_value;\n-\tif (nios2_debug)\n-\t  fprintf_unfiltered (gdb_stdlog, \"*\");\n-      }\n+\t{\n+\t  /* When we reach the current PC we must save the current\n+\t     register state (for the backtrace) but keep analysing\n+\t     because there might be more to find out (eg. is this an\n+\t     exception handler).  */\n+\t  memcpy (temp_value, value, sizeof (temp_value));\n+\t  value = temp_value;\n+\t  if (nios2_debug)\n+\t    fprintf_unfiltered (gdb_stdlog, \"*\");\n+\t}\n \n       op = nios2_fetch_insn (gdbarch, pc, &insn);\n "
    },
    {
      "sha": "c83d47c258aaf9e3d360e4f668b9ef065f471b39",
      "filename": "gdb/ppc-sysv-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/ppc-sysv-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/ppc-sysv-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ppc-sysv-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -276,10 +276,10 @@ ppc_sysv_abi_push_dummy_call (struct gdbarch *gdbarch, struct value *function,\n \t\t      /* 32-bit decimal floats are right aligned in the\n \t\t\t doubleword.  */\n \t\t      if (TYPE_LENGTH (type) == 4)\n-\t\t      {\n-\t\t\tmemcpy (regval + 4, val, 4);\n-\t\t\tp = regval;\n-\t\t      }\n+\t\t\t{\n+\t\t\t  memcpy (regval + 4, val, 4);\n+\t\t\t  p = regval;\n+\t\t\t}\n \t\t      else\n \t\t\tp = val;\n "
    },
    {
      "sha": "54ac907a83897086ad06fd6cbc70e99a1c3a5bc4",
      "filename": "gdb/python/py-framefilter.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/python/py-framefilter.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/python/py-framefilter.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-framefilter.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -780,16 +780,16 @@ py_print_frame (PyObject *filter, frame_filter_flags flags,\n \n   get_user_print_options (&opts);\n   if (print_frame_info)\n-  {\n-    gdb::optional<enum print_what> user_frame_info_print_what;\n-\n-    get_user_print_what_frame_info (&user_frame_info_print_what);\n-    if (!out->is_mi_like_p () && user_frame_info_print_what.has_value ())\n-      {\n-\t/* Use the specific frame information desired by the user.  */\n-\tprint_what = *user_frame_info_print_what;\n-      }\n-  }\n+    {\n+      gdb::optional<enum print_what> user_frame_info_print_what;\n+\n+      get_user_print_what_frame_info (&user_frame_info_print_what);\n+      if (!out->is_mi_like_p () && user_frame_info_print_what.has_value ())\n+\t{\n+\t  /* Use the specific frame information desired by the user.  */\n+\t  print_what = *user_frame_info_print_what;\n+\t}\n+    }\n \n   /* Get the underlying frame.  This is needed to determine GDB\n   architecture, and also, in the cases of frame variables/arguments to"
    },
    {
      "sha": "fe33747ca2192c0ec0a68bc4016b573c430866cf",
      "filename": "gdb/python/py-prettyprint.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/python/py-prettyprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/python/py-prettyprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-prettyprint.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -437,10 +437,10 @@ print_children (PyObject *printer, const char *hint,\n \t 2. Arrays.  Always print a \",\".\n \t 3. Other.  Always print a \",\".  */\n       if (i == 0)\n-      {\n-\tif (!is_py_none)\n-\t  fputs_filtered (\" = \", stream);\n-      }\n+\t{\n+\t  if (!is_py_none)\n+\t    fputs_filtered (\" = \", stream);\n+\t}\n       else if (! is_map || i % 2 == 0)\n \tfputs_filtered (pretty ? \",\" : \", \", stream);\n "
    },
    {
      "sha": "d45a15c16ca1be6854ea9b829ead0be0bb6e9f6c",
      "filename": "gdb/rs6000-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 3,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/rs6000-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/rs6000-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -1065,9 +1065,12 @@ ppc_displaced_step_fixup (struct gdbarch *gdbarch,\n   else if ((insn & BP_MASK) == BP_INSN)\n     regcache_cooked_write_unsigned (regs, gdbarch_pc_regnum (gdbarch), from);\n   else\n-  /* Handle any other instructions that do not fit in the categories above.  */\n-    regcache_cooked_write_unsigned (regs, gdbarch_pc_regnum (gdbarch),\n-\t\t\t\t    from + offset);\n+    {\n+      /* Handle any other instructions that do not fit in the categories\n+         above.  */\n+      regcache_cooked_write_unsigned (regs, gdbarch_pc_regnum (gdbarch),\n+\t\t\t\t      from + offset);\n+    }\n }\n \n /* Implementation of gdbarch_displaced_step_prepare.  */"
    },
    {
      "sha": "4905bcab36e450e14f1d4e476fb9c7c8e9d7b4ad",
      "filename": "gdb/s390-tdep.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/s390-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/s390-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/s390-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -7143,12 +7143,12 @@ s390_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)\n      cause GDB to crash with an internal error when the user tries to set\n      an unsupported OSABI.  */\n   if (!tdesc_has_registers (tdesc))\n-  {\n-    if (info.bfd_arch_info->mach == bfd_mach_s390_31)\n-      tdesc = tdesc_s390_linux32;\n-    else\n-      tdesc = tdesc_s390x_linux64;\n-  }\n+    {\n+      if (info.bfd_arch_info->mach == bfd_mach_s390_31)\n+\ttdesc = tdesc_s390_linux32;\n+      else\n+\ttdesc = tdesc_s390x_linux64;\n+    }\n   tdep->tdesc = tdesc;\n \n   /* Check any target description for validity.  */"
    },
    {
      "sha": "a38fa4d8082769a5846b9d82922545cfa189360d",
      "filename": "gdb/stack.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/stack.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/stack.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stack.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -1005,11 +1005,11 @@ print_pc (struct ui_out *uiout, struct gdbarch *gdbarch, frame_info *frame,\n \n   std::string flags = gdbarch_get_pc_address_flags (gdbarch, frame, pc);\n   if (!flags.empty ())\n-  {\n-    uiout->text (\" [\");\n-    uiout->field_string (\"addr_flags\", flags);\n-    uiout->text (\"]\");\n-  }\n+    {\n+      uiout->text (\" [\");\n+      uiout->field_string (\"addr_flags\", flags);\n+      uiout->text (\"]\");\n+    }\n }\n \n /* See stack.h.  */\n@@ -1927,7 +1927,7 @@ class frame_command_helper\n     struct frame_info *fid;\n \n     if (args == NULL)\n-    error (_(\"Missing address argument to view a frame\"));\n+      error (_(\"Missing address argument to view a frame\"));\n \n     gdb_argv argv (args);\n "
    },
    {
      "sha": "cacf2d3c5553a7788df13c1c2e0d6a15120959a0",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 87,
      "deletions": 87,
      "changes": 174,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -5637,55 +5637,55 @@ default_collect_symbol_completion_matches_break_on\n   if (mode == complete_symbol_mode::LINESPEC)\n     sym_text = text;\n   else\n-  {\n-    const char *p;\n-    char quote_found;\n-    const char *quote_pos = NULL;\n+    {\n+      const char *p;\n+      char quote_found;\n+      const char *quote_pos = NULL;\n \n-    /* First see if this is a quoted string.  */\n-    quote_found = '\\0';\n-    for (p = text; *p != '\\0'; ++p)\n-      {\n-\tif (quote_found != '\\0')\n-\t  {\n-\t    if (*p == quote_found)\n-\t      /* Found close quote.  */\n-\t      quote_found = '\\0';\n-\t    else if (*p == '\\\\' && p[1] == quote_found)\n-\t      /* A backslash followed by the quote character\n-\t\t doesn't end the string.  */\n-\t      ++p;\n-\t  }\n-\telse if (*p == '\\'' || *p == '\"')\n-\t  {\n-\t    quote_found = *p;\n-\t    quote_pos = p;\n-\t  }\n-      }\n-    if (quote_found == '\\'')\n-      /* A string within single quotes can be a symbol, so complete on it.  */\n-      sym_text = quote_pos + 1;\n-    else if (quote_found == '\"')\n-      /* A double-quoted string is never a symbol, nor does it make sense\n-\t to complete it any other way.  */\n-      {\n-\treturn;\n-      }\n-    else\n-      {\n-\t/* It is not a quoted string.  Break it based on the characters\n-\t   which are in symbols.  */\n-\twhile (p > text)\n-\t  {\n-\t    if (isalnum (p[-1]) || p[-1] == '_' || p[-1] == '\\0'\n-\t\t|| p[-1] == ':' || strchr (break_on, p[-1]) != NULL)\n-\t      --p;\n-\t    else\n-\t      break;\n-\t  }\n-\tsym_text = p;\n-      }\n-  }\n+      /* First see if this is a quoted string.  */\n+      quote_found = '\\0';\n+      for (p = text; *p != '\\0'; ++p)\n+\t{\n+\t  if (quote_found != '\\0')\n+\t    {\n+\t      if (*p == quote_found)\n+\t\t/* Found close quote.  */\n+\t\tquote_found = '\\0';\n+\t      else if (*p == '\\\\' && p[1] == quote_found)\n+\t\t/* A backslash followed by the quote character\n+\t\t   doesn't end the string.  */\n+\t\t++p;\n+\t    }\n+\t  else if (*p == '\\'' || *p == '\"')\n+\t    {\n+\t      quote_found = *p;\n+\t      quote_pos = p;\n+\t    }\n+\t}\n+      if (quote_found == '\\'')\n+\t/* A string within single quotes can be a symbol, so complete on it.  */\n+\tsym_text = quote_pos + 1;\n+      else if (quote_found == '\"')\n+\t/* A double-quoted string is never a symbol, nor does it make sense\n+\t   to complete it any other way.  */\n+\t{\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  /* It is not a quoted string.  Break it based on the characters\n+\t     which are in symbols.  */\n+\t  while (p > text)\n+\t    {\n+\t      if (isalnum (p[-1]) || p[-1] == '_' || p[-1] == '\\0'\n+\t\t  || p[-1] == ':' || strchr (break_on, p[-1]) != NULL)\n+\t\t--p;\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  sym_text = p;\n+\t}\n+    }\n \n   lookup_name_info lookup_name (sym_text, name_match_type, true);\n \n@@ -5874,46 +5874,46 @@ collect_file_symbol_completion_matches (completion_tracker &tracker,\n   if (mode == complete_symbol_mode::LINESPEC)\n     sym_text = text;\n   else\n-  {\n-    const char *p;\n-    char quote_found;\n-    const char *quote_pos = NULL;\n+    {\n+      const char *p;\n+      char quote_found;\n+      const char *quote_pos = NULL;\n \n-    /* First see if this is a quoted string.  */\n-    quote_found = '\\0';\n-    for (p = text; *p != '\\0'; ++p)\n-      {\n-\tif (quote_found != '\\0')\n-\t  {\n-\t    if (*p == quote_found)\n-\t      /* Found close quote.  */\n-\t      quote_found = '\\0';\n-\t    else if (*p == '\\\\' && p[1] == quote_found)\n-\t      /* A backslash followed by the quote character\n-\t\t doesn't end the string.  */\n-\t      ++p;\n-\t  }\n-\telse if (*p == '\\'' || *p == '\"')\n-\t  {\n-\t    quote_found = *p;\n-\t    quote_pos = p;\n-\t  }\n-      }\n-    if (quote_found == '\\'')\n-      /* A string within single quotes can be a symbol, so complete on it.  */\n-      sym_text = quote_pos + 1;\n-    else if (quote_found == '\"')\n-      /* A double-quoted string is never a symbol, nor does it make sense\n-\t to complete it any other way.  */\n-      {\n-\treturn;\n-      }\n-    else\n-      {\n-\t/* Not a quoted string.  */\n-\tsym_text = language_search_unquoted_string (text, p);\n-      }\n-  }\n+      /* First see if this is a quoted string.  */\n+      quote_found = '\\0';\n+      for (p = text; *p != '\\0'; ++p)\n+\t{\n+\t  if (quote_found != '\\0')\n+\t    {\n+\t      if (*p == quote_found)\n+\t\t/* Found close quote.  */\n+\t\tquote_found = '\\0';\n+\t      else if (*p == '\\\\' && p[1] == quote_found)\n+\t\t/* A backslash followed by the quote character\n+\t\t   doesn't end the string.  */\n+\t\t++p;\n+\t    }\n+\t  else if (*p == '\\'' || *p == '\"')\n+\t    {\n+\t      quote_found = *p;\n+\t      quote_pos = p;\n+\t    }\n+\t}\n+      if (quote_found == '\\'')\n+\t/* A string within single quotes can be a symbol, so complete on it.  */\n+\tsym_text = quote_pos + 1;\n+      else if (quote_found == '\"')\n+\t/* A double-quoted string is never a symbol, nor does it make sense\n+\t   to complete it any other way.  */\n+\t{\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  /* Not a quoted string.  */\n+\t  sym_text = language_search_unquoted_string (text, p);\n+\t}\n+    }\n \n   lookup_name_info lookup_name (sym_text, name_match_type, true);\n "
    },
    {
      "sha": "86d40d87b388d6ad78fb00a345c47937da5ced11",
      "filename": "gdb/target-float.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/target-float.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/target-float.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-float.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -2451,11 +2451,11 @@ target_float_convert (const gdb_byte *from, const struct type *from_type,\n \n   /* Convert between two different formats in the same category.  */\n   if (!target_float_same_format_p (from_type, to_type))\n-  {\n-    const target_float_ops *ops = get_target_float_ops (from_type, to_type);\n-    ops->convert (from, from_type, to, to_type);\n-    return;\n-  }\n+    {\n+      const target_float_ops *ops = get_target_float_ops (from_type, to_type);\n+      ops->convert (from, from_type, to, to_type);\n+      return;\n+    }\n \n   /* The floating-point formats match, so we simply copy the data, ensuring\n      possible padding bytes in the target buffer are zeroed out.  */"
    },
    {
      "sha": "f88968afbcfc5d13b43bd3cea8dde9c999fbe1b5",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -2267,7 +2267,7 @@ tfind_command_1 (const char *args, int from_tty)\n     { /* TFIND with no args means find NEXT trace frame.  */\n       if (traceframe_number == -1)\n \tframeno = 0;\t/* \"next\" is first one.  */\n-\telse\n+      else\n \tframeno = traceframe_number + 1;\n     }\n   else if (0 == strcmp (args, \"-\"))\n@@ -2408,11 +2408,13 @@ tfind_line_command (const char *args, int from_tty)\n   \t}\n       }\n     else\n-    /* Is there any case in which we get here, and have an address\n-       which the user would want to see?  If we have debugging\n-       symbols and no line numbers?  */\n-    error (_(\"Line number %d is out of range for \\\"%s\\\".\"),\n-\t   sal.line, symtab_to_filename_for_display (sal.symtab));\n+      {\n+\t/* Is there any case in which we get here, and have an address\n+\t   which the user would want to see?  If we have debugging\n+\t   symbols and no line numbers?  */\n+\terror (_(\"Line number %d is out of range for \\\"%s\\\".\"),\n+\t       sal.line, symtab_to_filename_for_display (sal.symtab));\n+      }\n \n   /* Find within range of stated line.  */\n   if (args && *args)"
    },
    {
      "sha": "5114c1bd2d26c8770107eec170b97a38f43cf4bb",
      "filename": "gdb/v850-tdep.c",
      "status": "modified",
      "additions": 8,
      "deletions": 6,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/v850-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/v850-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/v850-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -1025,12 +1025,14 @@ v850_push_dummy_call (struct gdbarch *gdbarch,\n   if (gdbarch_tdep (gdbarch)->abi == V850_ABI_RH850)\n     stack_offset = 0;\n   else\n-  /* The offset onto the stack at which we will start copying parameters\n-     (after the registers are used up) begins at 16 rather than at zero.\n-     That's how the ABI is defined, though there's no indication that these\n-     16 bytes are used for anything, not even for saving incoming\n-     argument registers.  */\n-  stack_offset = 16;\n+    {\n+      /* The offset onto the stack at which we will start copying parameters\n+\t (after the registers are used up) begins at 16 rather than at zero.\n+\t That's how the ABI is defined, though there's no indication that these\n+\t 16 bytes are used for anything, not even for saving incoming\n+\t argument registers.  */\n+      stack_offset = 16;\n+    }\n \n   /* Now make space on the stack for the args.  */\n   for (argnum = 0; argnum < nargs; argnum++)"
    },
    {
      "sha": "ca854390b7e4835fe1dfaf7f58c133b712a77012",
      "filename": "gdb/windows-tdep.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-tdep.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -761,10 +761,10 @@ create_enum (struct gdbarch *gdbarch, int bit, const char *name,\n   type->set_is_unsigned (true);\n \n   for (i = 0; i < count; i++)\n-  {\n-    TYPE_FIELD_NAME (type, i) = values[i].name;\n-    SET_FIELD_ENUMVAL (type->field (i), values[i].value);\n-  }\n+    {\n+      TYPE_FIELD_NAME (type, i) = values[i].name;\n+      SET_FIELD_ENUMVAL (type->field (i), values[i].value);\n+    }\n \n   return type;\n }"
    },
    {
      "sha": "a854d4daf3740619aee1cdd87b1676e99154fd60",
      "filename": "gdb/xcoffread.c",
      "status": "modified",
      "additions": 13,
      "deletions": 12,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdb/xcoffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdb/xcoffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xcoffread.c?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -482,7 +482,8 @@ arrange_linetable (struct linetable *oldLineTb)\n   newline = 0;\n   if (oldLineTb->item[0].line != 0)\n     for (newline = 0;\n-    newline < oldLineTb->nitems && oldLineTb->item[newline].line; ++newline)\n+\t newline < oldLineTb->nitems && oldLineTb->item[newline].line;\n+\t ++newline)\n       newLineTb->item[newline] = oldLineTb->item[newline];\n \n   /* Now copy function lines one by one.  */\n@@ -1165,20 +1166,20 @@ read_xcoff_symtab (struct objfile *objfile, legacy_psymtab *pst)\n \t     to 32(0x20). So we need to read the first function auxiliary entry\n \t     which contains the size. */\n \t  if (cs->c_naux > 1 && ISFCN (cs->c_type))\n-\t  {\n-\t    /* a function entry point.  */\n+\t    {\n+\t      /* a function entry point.  */\n \n-\t    fcn_start_addr = cs->c_value;\n+\t      fcn_start_addr = cs->c_value;\n \n-\t    /* save the function header info, which will be used\n-\t       when `.bf' is seen.  */\n-\t    fcn_cs_saved = *cs;\n+\t      /* save the function header info, which will be used\n+\t\t when `.bf' is seen.  */\n+\t      fcn_cs_saved = *cs;\n \n-\t    /* Convert the auxent to something we can access.  */\n-\t    bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,\n-\t\t\t\t  0, cs->c_naux, &fcn_aux_saved);\n-\t    continue;\n-\t  }\n+\t      /* Convert the auxent to something we can access.  */\n+\t      bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,\n+\t\t\t\t    0, cs->c_naux, &fcn_aux_saved);\n+\t      continue;\n+\t    }\n \t  /* Read the csect auxiliary header, which is always the last by\n \t     convention. */\n \t  bfd_coff_swap_aux_in (abfd,"
    },
    {
      "sha": "f8d7fd65fb17a84cd9919514fd0348c54c3e4dae",
      "filename": "gdbserver/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/ChangeLog?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -1,3 +1,7 @@\n+2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* Fix some indentation mistakes throughout.\n+\n 2021-05-17  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* .dir-locals.el: Set sentence-end-double-space for all modes, and"
    },
    {
      "sha": "b66808e6b39a948bf6dacfe72aaf06d78be1722d",
      "filename": "gdbserver/linux-s390-low.cc",
      "status": "modified",
      "additions": 15,
      "deletions": 21,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/01add95bed9afd5e7815439c3967db976be53f80/gdbserver/linux-s390-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/01add95bed9afd5e7815439c3967db976be53f80/gdbserver/linux-s390-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-s390-low.cc?ref=01add95bed9afd5e7815439c3967db976be53f80",
      "patch": "@@ -1908,15 +1908,13 @@ s390_emit_const (LONGEST num)\n     0x98, 0x23, 0x10, 0x00,\t/* lm %r2, %r3, 0(%r1) */\n   };\n   if (num < 0x8000 && num >= 0)\n-  {\n     add_insns (buf_s, sizeof buf_s);\n-  }\n   else\n-  {\n-    s390_emit_litpool (8);\n-    add_insns ((unsigned char *) &n, sizeof n);\n-    add_insns (buf_l, sizeof buf_l);\n-  }\n+    {\n+      s390_emit_litpool (8);\n+      add_insns ((unsigned char *) &n, sizeof n);\n+      add_insns (buf_l, sizeof buf_l);\n+    }\n }\n \n /* The \"emit_call\" emit_ops method for s390.  */\n@@ -2027,15 +2025,13 @@ s390_emit_set_r2 (int arg1)\n     0x58, 0x20, 0x10, 0x00,\t/* l %r2, 0(%r1) */\n   };\n   if (arg1 < 0x8000 && arg1 >= -0x8000)\n-  {\n     add_insns (buf_s, sizeof buf_s);\n-  }\n   else\n-  {\n-    s390_emit_litpool (4);\n-    add_insns ((unsigned char *) &arg1, sizeof arg1);\n-    add_insns (buf_l, sizeof buf_l);\n-  }\n+    {\n+      s390_emit_litpool (4);\n+      add_insns ((unsigned char *) &arg1, sizeof arg1);\n+      add_insns (buf_l, sizeof buf_l);\n+    }\n }\n \n /* The \"emit_int_call_1\" emit_ops method for s390.  */\n@@ -2553,15 +2549,13 @@ s390x_emit_const (LONGEST num)\n     0xe3, 0x20, 0x10, 0x00, 0x00, 0x04,\t/* lg %r2, 0(%r1) */\n   };\n   if (num < 0x8000 && num >= -0x8000)\n-  {\n     add_insns (buf_s, sizeof buf_s);\n-  }\n   else\n-  {\n-    s390_emit_litpool (8);\n-    add_insns ((unsigned char *) &n, sizeof n);\n-    add_insns (buf_l, sizeof buf_l);\n-  }\n+    {\n+      s390_emit_litpool (8);\n+      add_insns ((unsigned char *) &n, sizeof n);\n+      add_insns (buf_l, sizeof buf_l);\n+    }\n }\n \n /* The \"emit_call\" emit_ops method for s390x.  */"
    }
  ]
}