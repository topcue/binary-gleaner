{
  "sha": "29d6859f0927bf92fcddb4d519379992399e2ac9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MjlkNjg1OWYwOTI3YmY5MmZjZGRiNGQ1MTkzNzk5OTIzOTllMmFjOQ==",
  "commit": {
    "author": {
      "name": "Laurent Morichetti",
      "email": "Laurent.Morichetti@amd.com",
      "date": "2020-05-14T23:59:16Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-14T23:59:16Z"
    },
    "message": "gdb: infrun: consume multiple events at each pass in stop_all_threads\n\n[Simon: I send this patch on behalf of Laurent Morichetti, I added the\n commit message and performance measurement stuff.\n\n Also, this patch is better viewed with \"git show -w\".]\n\nstop_all_threads, in infrun.c, is used to stop all running threads on\ntargets that are always non-stop.  It's used, for example, when the\nprogram hits a breakpoint while GDB is set to \"non-stop off\".  It sends\na stop request for each running thread, then collects one wait event for\neach.\n\nSince new threads can spawn while we are stopping the threads, it's\nwritten in a way where it makes multiple such \"send stop requests to\nrunning threads & collect wait events\" passes.  The function completes\nwhen it has made two passes where it hasn't seen any running threads.\n\nWith the way it's written right now is, it iterates on the thread list,\nsending a stop request for each running thread.  It then waits for a\nsingle event, after which it iterates through the thread list again.  It\nsends stop requests for any running threads that's been created since\nthe last iteration.  It then consumes another single wait event.\n\nThis makes it so we iterate on O(n^2) threads in total, where n is the\nnumber of threads.  This patch changes the function to reduce it to\nO(n).  This starts to have an impact when dealing with multiple\nthousands of threads (see numbers below).  At each pass, we know the\nnumber of outstanding stop requests we have sent, for which we need to\ncollect a stop event.  We can therefore loop to collect this many stop\nevents before proceeding to the next pass and iterate on the thread list\nagain.\n\nTo check the performance improvements with this patch, I made an\nx86/Linux program with a large number of idle threads (varying from 1000\nto 10000).  The program's main thread hits a breakpoint once all these\nthreads have started, which causes stop_all_threads to be called to stop\nall these threads.  I measured (by patching stop_all_threads):\n\n- the execution time of stop_all_threads\n- the total number of threads we iterate on during the complete\n  execution of the function (the total number of times we execute the\n  \"for (thread_info *t : all_non_exited_threads ())\" loop)\n\nThese are the execution times, in milliseconds:\n\n    # threads  before  after\n         1000     226    106\n         2000     997    919\n         3000    3461   2323\n         4000    4330   3570\n         5000    8642   6600\n         6000    9918   8039\n         7000   12662  10930\n         8000   16652  11222\n         9000   21561  15875\n        10000   26613  20019\n\nNote that I very unscientifically executed each case only once.\n\nThese are the number of loop executions:\n\n    # threads     before  after\n         1000    1003002   3003\n         2000    4006002   6003\n         3000    9009002   9003\n         4000   16012002  12003\n         5000   25015002  15003\n         6000   36018002  18003\n         7000   49021002  21003\n         8000   64024002  24003\n         9000   81027002  27003\n        10000  100030002  30003\n\nThis last table shows pretty well the O(n^2) vs O(n) behaviors.\n\nReg-tested on x86 GNU/Linux (Ubuntu 16.04).\n\ngdb/ChangeLog:\n\nYYYY-MM-DD  Laurent Morichetti  <Laurent.Morichetti@amd.com>\nYYYY-MM-DD  Simon Marchi  <simon.marchi@efficios.com>\n\n\t* infrun.c (stop_all_threads): Collect multiple wait events at\n\teach pass.",
    "tree": {
      "sha": "6188bc6cb156dbdd054a45dedf97498d34fe3131",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/6188bc6cb156dbdd054a45dedf97498d34fe3131"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/29d6859f0927bf92fcddb4d519379992399e2ac9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/29d6859f0927bf92fcddb4d519379992399e2ac9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/29d6859f0927bf92fcddb4d519379992399e2ac9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/29d6859f0927bf92fcddb4d519379992399e2ac9/comments",
  "author": {
    "login": "lmoriche",
    "id": 7151294,
    "node_id": "MDQ6VXNlcjcxNTEyOTQ=",
    "avatar_url": "https://avatars.githubusercontent.com/u/7151294?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/lmoriche",
    "html_url": "https://github.com/lmoriche",
    "followers_url": "https://api.github.com/users/lmoriche/followers",
    "following_url": "https://api.github.com/users/lmoriche/following{/other_user}",
    "gists_url": "https://api.github.com/users/lmoriche/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/lmoriche/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/lmoriche/subscriptions",
    "organizations_url": "https://api.github.com/users/lmoriche/orgs",
    "repos_url": "https://api.github.com/users/lmoriche/repos",
    "events_url": "https://api.github.com/users/lmoriche/events{/privacy}",
    "received_events_url": "https://api.github.com/users/lmoriche/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "6a31512fd4fdd38ee2b1ea78543d352f961ca172",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6a31512fd4fdd38ee2b1ea78543d352f961ca172",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/6a31512fd4fdd38ee2b1ea78543d352f961ca172"
    }
  ],
  "stats": {
    "total": 274,
    "additions": 142,
    "deletions": 132
  },
  "files": [
    {
      "sha": "42118e731f52d961cf4300323265e0ffecde3463",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/29d6859f0927bf92fcddb4d519379992399e2ac9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/29d6859f0927bf92fcddb4d519379992399e2ac9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=29d6859f0927bf92fcddb4d519379992399e2ac9",
      "patch": "@@ -1,3 +1,9 @@\n+2020-05-14  Laurent Morichetti  <Laurent.Morichetti@amd.com>\n+\t    Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* infrun.c (stop_all_threads): Collect multiple wait events at\n+\teach pass.\n+\n 2020-05-14  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* gdbtypes.h (TYPE_CODE): Remove.  Change all call sites to use"
    },
    {
      "sha": "601a2acca429969cf54ca5c3891273dad51ed2e3",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 136,
      "deletions": 132,
      "changes": 268,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/29d6859f0927bf92fcddb4d519379992399e2ac9/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/29d6859f0927bf92fcddb4d519379992399e2ac9/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=29d6859f0927bf92fcddb4d519379992399e2ac9",
      "patch": "@@ -4802,7 +4802,7 @@ stop_all_threads (void)\n \t\t\t    \"iterations=%d\\n\", pass, iterations);\n       while (1)\n \t{\n-\t  int need_wait = 0;\n+\t  int waits_needed = 0;\n \n \t  for (auto *target : all_non_exited_process_targets ())\n \t    {\n@@ -4849,7 +4849,7 @@ stop_all_threads (void)\n \t\t    }\n \n \t\t  if (t->stop_requested)\n-\t\t    need_wait = 1;\n+\t\t    waits_needed++;\n \t\t}\n \t      else\n \t\t{\n@@ -4864,7 +4864,7 @@ stop_all_threads (void)\n \t\t}\n \t    }\n \n-\t  if (!need_wait)\n+\t  if (waits_needed == 0)\n \t    break;\n \n \t  /* If we find new threads on the second iteration, restart\n@@ -4873,160 +4873,164 @@ stop_all_threads (void)\n \t  if (pass > 0)\n \t    pass = -1;\n \n-\t  wait_one_event event = wait_one ();\n-\n-\t  if (debug_infrun)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \"infrun: stop_all_threads %s %s\\n\",\n-\t\t\t\t  target_waitstatus_to_string (&event.ws).c_str (),\n-\t\t\t\t  target_pid_to_str (event.ptid).c_str ());\n-\t    }\n-\n-\t  if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED)\n-\t    {\n-\t      /* All resumed threads exited.  */\n-\t    }\n-\t  else if (event.ws.kind == TARGET_WAITKIND_THREAD_EXITED\n-\t\t   || event.ws.kind == TARGET_WAITKIND_EXITED\n-\t\t   || event.ws.kind == TARGET_WAITKIND_SIGNALLED)\n+\t  for (int i = 0; i < waits_needed; i++)\n \t    {\n-\t      /* One thread/process exited/signalled.  */\n+\t      wait_one_event event = wait_one ();\n \n-\t      thread_info *t = nullptr;\n-\n-\t      /* The target may have reported just a pid.  If so, try\n-\t\t the first non-exited thread.  */\n-\t      if (event.ptid.is_pid ())\n-\t\t{\n-\t\t  int pid  = event.ptid.pid ();\n-\t\t  inferior *inf = find_inferior_pid (event.target, pid);\n-\t\t  for (thread_info *tp : inf->non_exited_threads ())\n-\t\t    {\n-\t\t      t = tp;\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  /* If there is no available thread, the event would\n-\t\t     have to be appended to a per-inferior event list,\n-\t\t     which does not exist (and if it did, we'd have\n-\t\t     to adjust run control command to be able to\n-\t\t     resume such an inferior).  We assert here instead\n-\t\t     of going into an infinite loop.  */\n-\t\t  gdb_assert (t != nullptr);\n-\n-\t\t  if (debug_infrun)\n-\t\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t\"infrun: stop_all_threads, using %s\\n\",\n-\t\t\t\t\ttarget_pid_to_str (t->ptid).c_str ());\n-\t\t}\n-\t      else\n+\t      if (debug_infrun)\n \t\t{\n-\t\t  t = find_thread_ptid (event.target, event.ptid);\n-\t\t  /* Check if this is the first time we see this thread.\n-\t\t     Don't bother adding if it individually exited.  */\n-\t\t  if (t == nullptr\n-\t\t      && event.ws.kind != TARGET_WAITKIND_THREAD_EXITED)\n-\t\t    t = add_thread (event.target, event.ptid);\n+\t\t  fprintf_unfiltered (gdb_stdlog,\n+\t\t\t\t      \"infrun: stop_all_threads %s %s\\n\",\n+\t\t\t\t      target_waitstatus_to_string (&event.ws).c_str (),\n+\t\t\t\t      target_pid_to_str (event.ptid).c_str ());\n \t\t}\n \n-\t      if (t != nullptr)\n+\t      if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED)\n \t\t{\n-\t\t  /* Set the threads as non-executing to avoid\n-\t\t     another stop attempt on them.  */\n-\t\t  switch_to_thread_no_regs (t);\n-\t\t  mark_non_executing_threads (event.target, event.ptid,\n-\t\t\t\t\t      event.ws);\n-\t\t  save_waitstatus (t, &event.ws);\n-\t\t  t->stop_requested = false;\n+\t\t  /* All resumed threads exited.  */\n+\t\t  break;\n \t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      thread_info *t = find_thread_ptid (event.target, event.ptid);\n-\t      if (t == NULL)\n-\t\tt = add_thread (event.target, event.ptid);\n-\n-\t      t->stop_requested = 0;\n-\t      t->executing = 0;\n-\t      t->resumed = false;\n-\t      t->control.may_range_step = 0;\n-\n-\t      /* This may be the first time we see the inferior report\n-\t\t a stop.  */\n-\t      inferior *inf = find_inferior_ptid (event.target, event.ptid);\n-\t      if (inf->needs_setup)\n+\t      else if (event.ws.kind == TARGET_WAITKIND_THREAD_EXITED\n+\t\t       || event.ws.kind == TARGET_WAITKIND_EXITED\n+\t\t       || event.ws.kind == TARGET_WAITKIND_SIGNALLED)\n \t\t{\n-\t\t  switch_to_thread_no_regs (t);\n-\t\t  setup_inferior (0);\n-\t\t}\n+\t\t  /* One thread/process exited/signalled.  */\n \n-\t      if (event.ws.kind == TARGET_WAITKIND_STOPPED\n-\t\t  && event.ws.value.sig == GDB_SIGNAL_0)\n-\t\t{\n-\t\t  /* We caught the event that we intended to catch, so\n-\t\t     there's no event pending.  */\n-\t\t  t->suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n-\t\t  t->suspend.waitstatus_pending_p = 0;\n+\t\t  thread_info *t = nullptr;\n \n-\t\t  if (displaced_step_fixup (t, GDB_SIGNAL_0) < 0)\n+\t\t  /* The target may have reported just a pid.  If so, try\n+\t\t     the first non-exited thread.  */\n+\t\t  if (event.ptid.is_pid ())\n \t\t    {\n-\t\t      /* Add it back to the step-over queue.  */\n-\t\t      if (debug_infrun)\n+\t\t      int pid  = event.ptid.pid ();\n+\t\t      inferior *inf = find_inferior_pid (event.target, pid);\n+\t\t      for (thread_info *tp : inf->non_exited_threads ())\n \t\t\t{\n-\t\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t      \"infrun: displaced-step of %s \"\n-\t\t\t\t\t      \"canceled: adding back to the \"\n-\t\t\t\t\t      \"step-over queue\\n\",\n-\t\t\t\t\t      target_pid_to_str (t->ptid).c_str ());\n+\t\t\t  t = tp;\n+\t\t\t  break;\n \t\t\t}\n-\t\t      t->control.trap_expected = 0;\n-\t\t      thread_step_over_chain_enqueue (t);\n+\n+\t\t      /* If there is no available thread, the event would\n+\t\t\t have to be appended to a per-inferior event list,\n+\t\t\t which does not exist (and if it did, we'd have\n+\t\t\t to adjust run control command to be able to\n+\t\t\t resume such an inferior).  We assert here instead\n+\t\t\t of going into an infinite loop.  */\n+\t\t      gdb_assert (t != nullptr);\n+\n+\t\t      if (debug_infrun)\n+\t\t\tfprintf_unfiltered (gdb_stdlog,\n+\t\t\t\t\t    \"infrun: stop_all_threads, using %s\\n\",\n+\t\t\t\t\t    target_pid_to_str (t->ptid).c_str ());\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      t = find_thread_ptid (event.target, event.ptid);\n+\t\t      /* Check if this is the first time we see this thread.\n+\t\t\t Don't bother adding if it individually exited.  */\n+\t\t      if (t == nullptr\n+\t\t\t  && event.ws.kind != TARGET_WAITKIND_THREAD_EXITED)\n+\t\t\tt = add_thread (event.target, event.ptid);\n+\t\t    }\n+\n+\t\t  if (t != nullptr)\n+\t\t    {\n+\t\t      /* Set the threads as non-executing to avoid\n+\t\t\t another stop attempt on them.  */\n+\t\t      switch_to_thread_no_regs (t);\n+\t\t      mark_non_executing_threads (event.target, event.ptid,\n+\t\t\t\t\t\t  event.ws);\n+\t\t      save_waitstatus (t, &event.ws);\n+\t\t      t->stop_requested = false;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n-\t\t  enum gdb_signal sig;\n-\t\t  struct regcache *regcache;\n+\t\t  thread_info *t = find_thread_ptid (event.target, event.ptid);\n+\t\t  if (t == NULL)\n+\t\t    t = add_thread (event.target, event.ptid);\n \n-\t\t  if (debug_infrun)\n+\t\t  t->stop_requested = 0;\n+\t\t  t->executing = 0;\n+\t\t  t->resumed = false;\n+\t\t  t->control.may_range_step = 0;\n+\n+\t\t  /* This may be the first time we see the inferior report\n+\t\t     a stop.  */\n+\t\t  inferior *inf = find_inferior_ptid (event.target, event.ptid);\n+\t\t  if (inf->needs_setup)\n \t\t    {\n-\t\t      std::string statstr = target_waitstatus_to_string (&event.ws);\n-\n-\t\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t  \"infrun: target_wait %s, saving \"\n-\t\t\t\t\t  \"status for %d.%ld.%ld\\n\",\n-\t\t\t\t\t  statstr.c_str (),\n-\t\t\t\t\t  t->ptid.pid (),\n-\t\t\t\t\t  t->ptid.lwp (),\n-\t\t\t\t\t  t->ptid.tid ());\n+\t\t      switch_to_thread_no_regs (t);\n+\t\t      setup_inferior (0);\n \t\t    }\n \n-\t\t  /* Record for later.  */\n-\t\t  save_waitstatus (t, &event.ws);\n-\n-\t\t  sig = (event.ws.kind == TARGET_WAITKIND_STOPPED\n-\t\t\t ? event.ws.value.sig : GDB_SIGNAL_0);\n-\n-\t\t  if (displaced_step_fixup (t, sig) < 0)\n+\t\t  if (event.ws.kind == TARGET_WAITKIND_STOPPED\n+\t\t      && event.ws.value.sig == GDB_SIGNAL_0)\n \t\t    {\n-\t\t      /* Add it back to the step-over queue.  */\n-\t\t      t->control.trap_expected = 0;\n-\t\t      thread_step_over_chain_enqueue (t);\n+\t\t      /* We caught the event that we intended to catch, so\n+\t\t\t there's no event pending.  */\n+\t\t      t->suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+\t\t      t->suspend.waitstatus_pending_p = 0;\n+\n+\t\t      if (displaced_step_fixup (t, GDB_SIGNAL_0) < 0)\n+\t\t\t{\n+\t\t\t  /* Add it back to the step-over queue.  */\n+\t\t\t  if (debug_infrun)\n+\t\t\t    {\n+\t\t\t      fprintf_unfiltered (gdb_stdlog,\n+\t\t\t\t\t\t  \"infrun: displaced-step of %s \"\n+\t\t\t\t\t\t  \"canceled: adding back to the \"\n+\t\t\t\t\t\t  \"step-over queue\\n\",\n+\t\t\t\t\t\t  target_pid_to_str (t->ptid).c_str ());\n+\t\t\t    }\n+\t\t\t  t->control.trap_expected = 0;\n+\t\t\t  thread_step_over_chain_enqueue (t);\n+\t\t\t}\n \t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      enum gdb_signal sig;\n+\t\t      struct regcache *regcache;\n \n-\t\t  regcache = get_thread_regcache (t);\n-\t\t  t->suspend.stop_pc = regcache_read_pc (regcache);\n+\t\t      if (debug_infrun)\n+\t\t\t{\n+\t\t\t  std::string statstr = target_waitstatus_to_string (&event.ws);\n \n-\t\t  if (debug_infrun)\n-\t\t    {\n-\t\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t  \"infrun: saved stop_pc=%s for %s \"\n-\t\t\t\t\t  \"(currently_stepping=%d)\\n\",\n-\t\t\t\t\t  paddress (target_gdbarch (),\n-\t\t\t\t\t\t    t->suspend.stop_pc),\n-\t\t\t\t\t  target_pid_to_str (t->ptid).c_str (),\n-\t\t\t\t\t  currently_stepping (t));\n+\t\t\t  fprintf_unfiltered (gdb_stdlog,\n+\t\t\t\t\t      \"infrun: target_wait %s, saving \"\n+\t\t\t\t\t      \"status for %d.%ld.%ld\\n\",\n+\t\t\t\t\t      statstr.c_str (),\n+\t\t\t\t\t      t->ptid.pid (),\n+\t\t\t\t\t      t->ptid.lwp (),\n+\t\t\t\t\t      t->ptid.tid ());\n+\t\t\t}\n+\n+\t\t      /* Record for later.  */\n+\t\t      save_waitstatus (t, &event.ws);\n+\n+\t\t      sig = (event.ws.kind == TARGET_WAITKIND_STOPPED\n+\t\t\t     ? event.ws.value.sig : GDB_SIGNAL_0);\n+\n+\t\t      if (displaced_step_fixup (t, sig) < 0)\n+\t\t\t{\n+\t\t\t  /* Add it back to the step-over queue.  */\n+\t\t\t  t->control.trap_expected = 0;\n+\t\t\t  thread_step_over_chain_enqueue (t);\n+\t\t\t}\n+\n+\t\t      regcache = get_thread_regcache (t);\n+\t\t      t->suspend.stop_pc = regcache_read_pc (regcache);\n+\n+\t\t      if (debug_infrun)\n+\t\t\t{\n+\t\t\t  fprintf_unfiltered (gdb_stdlog,\n+\t\t\t\t\t      \"infrun: saved stop_pc=%s for %s \"\n+\t\t\t\t\t      \"(currently_stepping=%d)\\n\",\n+\t\t\t\t\t      paddress (target_gdbarch (),\n+\t\t\t\t\t\t\tt->suspend.stop_pc),\n+\t\t\t\t\t      target_pid_to_str (t->ptid).c_str (),\n+\t\t\t\t\t      currently_stepping (t));\n+\t\t\t}\n \t\t    }\n \t\t}\n \t    }"
    }
  ]
}