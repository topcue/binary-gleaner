{
  "sha": "52429bbd71af5f14f8f3f5a962a2457a93c6d171",
  "node_id": "C_kwDOANOeidoAKDUyNDI5YmJkNzFhZjVmMTRmOGYzZjVhOTYyYTI0NTdhOTNjNmQxNzE",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-10-19T20:42:04Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-10-29T13:33:13Z"
    },
    "message": "Document resolve_dynamic_type oddity\n\nToday I re-learned that resolve_dynamic_type can return a type for\nwhich is_dynamic_type returns true.  This can happen for an array\nwhose elements have dynamic type -- the array is reported as dynamic,\nbut resolving the elements would be incorrect, because each element\nmight have a different type after resolution.\n\nYou can see the special case in resolve_dynamic_array_or_string:\n\n  if (ary_dim != NULL && ary_dim->code () == TYPE_CODE_ARRAY)\n...\n  else\n...\n\nI looked into having the TYPE_CODE_ARRAY case in\nis_dynamic_type_internal follow this same logic, but that breaks down\non the gdb.fortran/dynamic-ptype-whatis.exp test case.  In particular\nthis code in fortran_undetermined::evaluate:\n\n  value *callee = std::get<0> (m_storage)->evaluate (nullptr, exp, noside);\n  if (noside == EVAL_AVOID_SIDE_EFFECTS\n      && is_dynamic_type (value_type (callee)))\n    callee = std::get<0> (m_storage)->evaluate (nullptr, exp, EVAL_NORMAL);\n\n... relies on is_dynamic_type returning true for such an array.\n\nI wasn't really sure of the best way to fix this, so in the meantime I\nwrote this patch, which documents the oddity so that I might have a\nchance of remembering this in the future.",
    "tree": {
      "sha": "54e0b8221ba779cef213accb1b3cd5d2d9cb71e4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/54e0b8221ba779cef213accb1b3cd5d2d9cb71e4"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/52429bbd71af5f14f8f3f5a962a2457a93c6d171",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/52429bbd71af5f14f8f3f5a962a2457a93c6d171",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/52429bbd71af5f14f8f3f5a962a2457a93c6d171",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/52429bbd71af5f14f8f3f5a962a2457a93c6d171/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9e6978753df24726a73667b293ac7f0cc94a2fcb",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9e6978753df24726a73667b293ac7f0cc94a2fcb",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9e6978753df24726a73667b293ac7f0cc94a2fcb"
    }
  ],
  "stats": {
    "total": 13,
    "additions": 11,
    "deletions": 2
  },
  "files": [
    {
      "sha": "f36a7532d676927d7c82e6119d5a660aef85562d",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 11,
      "deletions": 2,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/52429bbd71af5f14f8f3f5a962a2457a93c6d171/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/52429bbd71af5f14f8f3f5a962a2457a93c6d171/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=52429bbd71af5f14f8f3f5a962a2457a93c6d171",
      "patch": "@@ -2666,12 +2666,21 @@ extern CORE_ADDR get_pointer_type_max (struct type *);\n /* * Resolve all dynamic values of a type e.g. array bounds to static values.\n    ADDR specifies the location of the variable the type is bound to.\n    If TYPE has no dynamic properties return TYPE; otherwise a new type with\n-   static properties is returned.  */\n+   static properties is returned.\n+\n+   For an array type, if the element type is dynamic, then that will\n+   not be resolved.  This is done because each individual element may\n+   have a different type when resolved (depending on the contents of\n+   memory).  In this situation, 'is_dynamic_type' will still return\n+   true for the return value of this function.  */\n extern struct type *resolve_dynamic_type\n   (struct type *type, gdb::array_view<const gdb_byte> valaddr,\n    CORE_ADDR addr);\n \n-/* * Predicate if the type has dynamic values, which are not resolved yet.  */\n+/* * Predicate if the type has dynamic values, which are not resolved yet.\n+   See the caveat in 'resolve_dynamic_type' to understand a scenario\n+   where an apparently-resolved type may still be considered\n+   \"dynamic\".  */\n extern int is_dynamic_type (struct type *type);\n \n extern struct type *check_typedef (struct type *);"
    }
  ]
}