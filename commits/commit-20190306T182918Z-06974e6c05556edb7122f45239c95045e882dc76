{
  "sha": "06974e6c05556edb7122f45239c95045e882dc76",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDY5NzRlNmMwNTU1NmVkYjcxMjJmNDUyMzljOTUwNDVlODgyZGM3Ng==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-03-06T18:29:18Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "palves@redhat.com",
      "date": "2019-03-06T18:29:18Z"
    },
    "message": "C++ify fork_info, use std::list\n\n- Convert new_fork and free_fork to fork_info ctor/dtor.\n- Use std::list.\n\ngdb/ChangeLog:\n2019-03-06  Pedro Alves  <palves@redhat.com>\n\n\t* linux-fork.c: Include <list>.\n\t(fork_list): Now a std::list instance.\n\t(fork_info): Add ctor, dtor, and in-class initialize all fields.\n\t(forks_exist_p, find_last_fork): Adjust.\n\t(new_fork): Delete.\n\t(one_fork_p): New.\n\t(add_fork): Adjust.\n\t(free_fork): Delete, folded into fork_info::~fork_info().\n\t(delete_fork, find_fork_ptid, find_fork_id, find_fork_pid):\n\tAdjust.\n\t(init_fork_list): Delete.\n\t(linux_fork_killall, linux_fork_mourn_inferior)\n\t(linux_fork_detach, info_checkpoints_command): Adjust.\n\t(_initialize_linux_fork): No longer call init_fork_list.",
    "tree": {
      "sha": "52c396875ed81d87674e0b081f532d5cceec6534",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/52c396875ed81d87674e0b081f532d5cceec6534"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/06974e6c05556edb7122f45239c95045e882dc76",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/06974e6c05556edb7122f45239c95045e882dc76",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/06974e6c05556edb7122f45239c95045e882dc76",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/06974e6c05556edb7122f45239c95045e882dc76/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "72f31aea9e6c158f442239abedaf351465ebcb41",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/72f31aea9e6c158f442239abedaf351465ebcb41",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/72f31aea9e6c158f442239abedaf351465ebcb41"
    }
  ],
  "stats": {
    "total": 278,
    "additions": 125,
    "deletions": 153
  },
  "files": [
    {
      "sha": "7a7ee5fc807956b10965d94d9652ada5bd3a6848",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 17,
      "deletions": 0,
      "changes": 17,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/06974e6c05556edb7122f45239c95045e882dc76/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/06974e6c05556edb7122f45239c95045e882dc76/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=06974e6c05556edb7122f45239c95045e882dc76",
      "patch": "@@ -1,3 +1,20 @@\n+2019-03-06  Pedro Alves  <palves@redhat.com>\n+\n+\t* linux-fork.c: Include <list>.\n+\t(fork_list): Now a std::list instance.\n+\t(fork_info): Add ctor, dtor, and in-class initialize all fields.\n+\t(forks_exist_p, find_last_fork): Adjust.\n+\t(new_fork): Delete.\n+\t(one_fork_p): New.\n+\t(add_fork): Adjust.\n+\t(free_fork): Delete, folded into fork_info::~fork_info().\n+\t(delete_fork, find_fork_ptid, find_fork_id, find_fork_pid):\n+\tAdjust.\n+\t(init_fork_list): Delete.\n+\t(linux_fork_killall, linux_fork_mourn_inferior)\n+\t(linux_fork_detach, info_checkpoints_command): Adjust.\n+\t(_initialize_linux_fork): No longer call init_fork_list.\n+\n 2019-03-06  Pedro Alves  <palves@redhat.com>\n \n \t* linux-fork.c (new_fork): New, split out of ..."
    },
    {
      "sha": "1c7b7ca123062ebf86fdb729e0dedf13109b095e",
      "filename": "gdb/linux-fork.c",
      "status": "modified",
      "additions": 108,
      "deletions": 153,
      "changes": 261,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/06974e6c05556edb7122f45239c95045e882dc76/gdb/linux-fork.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/06974e6c05556edb7122f45239c95045e882dc76/gdb/linux-fork.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-fork.c?ref=06974e6c05556edb7122f45239c95045e882dc76",
      "patch": "@@ -35,151 +35,133 @@\n #include <dirent.h>\n #include <ctype.h>\n \n-struct fork_info *fork_list;\n-static int highest_fork_num;\n+#include <list>\n \n /* Fork list data structure:  */\n struct fork_info\n {\n-  struct fork_info *next;\n-  ptid_t ptid;\n-  ptid_t parent_ptid;\n-  int num;\t\t\t/* Convenient handle (GDB fork id).  */\n-  readonly_detached_regcache *savedregs;\t/* Convenient for info fork, saves\n-\t\t\t\t   having to actually switch contexts.  */\n-  CORE_ADDR pc;\n-  int clobber_regs;\t\t/* True if we should restore saved regs.  */\n-  off_t *filepos;\t\t/* Set of open file descriptors' offsets.  */\n-  int maxfd;\n+  explicit fork_info (pid_t pid)\n+    : ptid (pid, pid, 0)\n+  {\n+  }\n+\n+  ~fork_info ()\n+  {\n+    /* Notes on step-resume breakpoints: since this is a concern for\n+       threads, let's convince ourselves that it's not a concern for\n+       forks.  There are two ways for a fork_info to be created.\n+       First, by the checkpoint command, in which case we're at a gdb\n+       prompt and there can't be any step-resume breakpoint.  Second,\n+       by a fork in the user program, in which case we *may* have\n+       stepped into the fork call, but regardless of whether we follow\n+       the parent or the child, we will return to the same place and\n+       the step-resume breakpoint, if any, will take care of itself as\n+       usual.  And unlike threads, we do not save a private copy of\n+       the step-resume breakpoint -- so we're OK.  */\n+\n+    if (savedregs)\n+      delete savedregs;\n+    if (filepos)\n+      xfree (filepos);\n+  }\n+\n+  ptid_t ptid = null_ptid;\n+  ptid_t parent_ptid = null_ptid;\n+\n+  /* Convenient handle (GDB fork id).  */\n+  int num = 0;\n+\n+  /* Convenient for info fork, saves having to actually switch\n+     contexts.  */\n+  readonly_detached_regcache *savedregs = nullptr;\n+\n+  CORE_ADDR pc = 0;\n+\n+  /* True if we should restore saved regs.  */\n+  int clobber_regs = 0;\n+\n+  /* Set of open file descriptors' offsets.  */\n+  off_t *filepos = nullptr;\n+\n+  int maxfd = 0;\n };\n \n+static std::list<fork_info> fork_list;\n+static int highest_fork_num;\n+\n /* Fork list methods:  */\n \n int\n forks_exist_p (void)\n {\n-  return (fork_list != NULL);\n+  return !fork_list.empty ();\n }\n \n /* Return the last fork in the list.  */\n \n static struct fork_info *\n find_last_fork (void)\n {\n-  struct fork_info *last;\n-\n-  if (fork_list == NULL)\n+  if (fork_list.empty ())\n     return NULL;\n \n-  for (last = fork_list; last->next != NULL; last = last->next)\n-    ;\n-  return last;\n+  return &fork_list.back ();\n }\n \n-/* Allocate a new fork.  */\n+/* Return true iff there's one fork in the list.  */\n \n-static struct fork_info *\n-new_fork (pid_t pid)\n+static bool\n+one_fork_p ()\n {\n-  struct fork_info *fp;\n-\n-  fp = XCNEW (struct fork_info);\n-  fp->ptid = ptid_t (pid, pid, 0);\n-  return fp;\n+  return (!fork_list.empty ()\n+\t  && &fork_list.front () == &fork_list.back ());\n }\n \n /* Add a new fork to the internal fork list.  */\n \n void\n add_fork (pid_t pid)\n {\n-  struct fork_info *fp = new_fork (pid);\n-\n-  if (fork_list == NULL)\n-    {\n-      fork_list = fp;\n-      highest_fork_num = 0;\n-    }\n-  else\n-    {\n-      struct fork_info *last = find_last_fork ();\n+  fork_list.emplace_back (pid);\n \n-      last->next = fp;\n-    }\n+  if (one_fork_p ())\n+    highest_fork_num = 0;\n \n+  fork_info *fp = &fork_list.back ();\n   fp->num = ++highest_fork_num;\n }\n \n-static void\n-free_fork (struct fork_info *fp)\n-{\n-  /* Notes on step-resume breakpoints: since this is a concern for\n-     threads, let's convince ourselves that it's not a concern for\n-     forks.  There are two ways for a fork_info to be created.  First,\n-     by the checkpoint command, in which case we're at a gdb prompt\n-     and there can't be any step-resume breakpoint.  Second, by a fork\n-     in the user program, in which case we *may* have stepped into the\n-     fork call, but regardless of whether we follow the parent or the\n-     child, we will return to the same place and the step-resume\n-     breakpoint, if any, will take care of itself as usual.  And\n-     unlike threads, we do not save a private copy of the step-resume\n-     breakpoint -- so we're OK.  */\n-\n-  if (fp)\n-    {\n-      if (fp->savedregs)\n-\tdelete fp->savedregs;\n-      if (fp->filepos)\n-\txfree (fp->filepos);\n-      xfree (fp);\n-    }\n-}\n-\n static void\n delete_fork (ptid_t ptid)\n {\n-  struct fork_info *fp, *fpprev;\n-\n-  fpprev = NULL;\n-\n   linux_target->low_forget_process (ptid.pid ());\n \n-  for (fp = fork_list; fp; fpprev = fp, fp = fp->next)\n-    if (fp->ptid == ptid)\n-      break;\n-\n-  if (!fp)\n-    return;\n-\n-  if (fpprev)\n-    fpprev->next = fp->next;\n-  else\n-    fork_list = fp->next;\n-\n-  free_fork (fp);\n+  for (auto it = fork_list.begin (); it != fork_list.end (); ++it)\n+    if (it->ptid == ptid)\n+      {\n+\tfork_list.erase (it);\n \n-  /* Special case: if there is now only one process in the list,\n-     and if it is (hopefully!) the current inferior_ptid, then\n-     remove it, leaving the list empty -- we're now down to the\n-     default case of debugging a single process.  */\n-  if (fork_list != NULL && fork_list->next == NULL &&\n-      fork_list->ptid == inferior_ptid)\n-    {\n-      /* Last fork -- delete from list and handle as solo process\n-\t (should be a safe recursion).  */\n-      delete_fork (inferior_ptid);\n-    }\n+\t/* Special case: if there is now only one process in the list,\n+\t   and if it is (hopefully!) the current inferior_ptid, then\n+\t   remove it, leaving the list empty -- we're now down to the\n+\t   default case of debugging a single process.  */\n+\tif (one_fork_p () && fork_list.front ().ptid == inferior_ptid)\n+\t  {\n+\t    /* Last fork -- delete from list and handle as solo\n+\t       process (should be a safe recursion).  */\n+\t    delete_fork (inferior_ptid);\n+\t  }\n+\treturn;\n+      }\n }\n \n /* Find a fork_info by matching PTID.  */\n static struct fork_info *\n find_fork_ptid (ptid_t ptid)\n {\n-  struct fork_info *fp;\n-\n-  for (fp = fork_list; fp; fp = fp->next)\n-    if (fp->ptid == ptid)\n-      return fp;\n+  for (fork_info &fi : fork_list)\n+    if (fi.ptid == ptid)\n+      return &fi;\n \n   return NULL;\n }\n@@ -188,11 +170,9 @@ find_fork_ptid (ptid_t ptid)\n static struct fork_info *\n find_fork_id (int num)\n {\n-  struct fork_info *fp;\n-\n-  for (fp = fork_list; fp; fp = fp->next)\n-    if (fp->num == num)\n-      return fp;\n+  for (fork_info &fi : fork_list)\n+    if (fi.num == num)\n+      return &fi;\n \n   return NULL;\n }\n@@ -201,11 +181,9 @@ find_fork_id (int num)\n extern struct fork_info *\n find_fork_pid (pid_t pid)\n {\n-  struct fork_info *fp;\n-\n-  for (fp = fork_list; fp; fp = fp->next)\n-    if (pid == fp->ptid.pid ())\n-      return fp;\n+  for (fork_info &fi : fork_list)\n+    if (pid == fi.ptid.pid ())\n+      return &fi;\n \n   return NULL;\n }\n@@ -220,23 +198,6 @@ fork_id_to_ptid (int num)\n     return ptid_t (-1);\n }\n \n-static void\n-init_fork_list (void)\n-{\n-  struct fork_info *fp, *fpnext;\n-\n-  if (!fork_list)\n-    return;\n-\n-  for (fp = fork_list; fp; fp = fpnext)\n-    {\n-      fpnext = fp->next;\n-      free_fork (fp);\n-    }\n-\n-  fork_list = NULL;\n-}\n-\n /* Fork list <-> gdb interface.  */\n \n /* Utility function for fork_load/fork_save.\n@@ -350,13 +311,12 @@ linux_fork_killall (void)\n      status for it) -- however any process may be a child\n      or a parent, so may get a SIGCHLD from a previously\n      killed child.  Wait them all out.  */\n-  struct fork_info *fp;\n-  pid_t pid, ret;\n-  int status;\n \n-  for (fp = fork_list; fp; fp = fp->next)\n+  for (fork_info &fi : fork_list)\n     {\n-      pid = fp->ptid.pid ();\n+      pid_t pid = fi.ptid.pid ();\n+      int status;\n+      pid_t ret;\n       do {\n \t/* Use SIGKILL instead of PTRACE_KILL because the former works even\n \t   if the thread is running, while the later doesn't.  */\n@@ -367,7 +327,9 @@ linux_fork_killall (void)\n \t died.  MVS comment cut-and-pasted from linux-nat.  */\n       } while (ret == pid && WIFSTOPPED (status));\n     }\n-  init_fork_list ();\t/* Clear list, prepare to start fresh.  */\n+\n+  /* Clear list, prepare to start fresh.  */\n+  fork_list.clear ();\n }\n \n /* The current inferior_ptid has exited, but there are other viable\n@@ -394,15 +356,15 @@ linux_fork_mourn_inferior (void)\n   /* There should still be a fork - if there's only one left,\n      delete_fork won't remove it, because we haven't updated\n      inferior_ptid yet.  */\n-  gdb_assert (fork_list);\n+  gdb_assert (!fork_list.empty ());\n \n   last = find_last_fork ();\n   fork_load_infrun_state (last);\n   printf_filtered (_(\"[Switching to %s]\\n\"),\n \t\t   target_pid_to_str (inferior_ptid));\n \n   /* If there's only one fork, switch back to non-fork mode.  */\n-  if (fork_list->next == NULL)\n+  if (one_fork_p ())\n     delete_fork (inferior_ptid);\n }\n \n@@ -425,16 +387,16 @@ linux_fork_detach (int from_tty)\n   /* There should still be a fork - if there's only one left,\n      delete_fork won't remove it, because we haven't updated\n      inferior_ptid yet.  */\n-  gdb_assert (fork_list);\n+  gdb_assert (!fork_list.empty ());\n \n-  fork_load_infrun_state (fork_list);\n+  fork_load_infrun_state (&fork_list.front ());\n \n   if (from_tty)\n     printf_filtered (_(\"[Switching to %s]\\n\"),\n \t\t     target_pid_to_str (inferior_ptid));\n \n   /* If there's only one fork, switch back to non-fork mode.  */\n-  if (fork_list->next == NULL)\n+  if (one_fork_p ())\n     delete_fork (inferior_ptid);\n }\n \n@@ -606,34 +568,31 @@ static void\n info_checkpoints_command (const char *arg, int from_tty)\n {\n   struct gdbarch *gdbarch = get_current_arch ();\n-  struct symtab_and_line sal;\n-  struct fork_info *fp;\n-  ULONGEST pc;\n   int requested = -1;\n-  struct fork_info *printed = NULL;\n+  const fork_info *printed = NULL;\n \n   if (arg && *arg)\n     requested = (int) parse_and_eval_long (arg);\n \n-  for (fp = fork_list; fp; fp = fp->next)\n+  for (const fork_info &fi : fork_list)\n     {\n-      if (requested > 0 && fp->num != requested)\n+      if (requested > 0 && fi.num != requested)\n \tcontinue;\n \n-      printed = fp;\n-      if (fp->ptid == inferior_ptid)\n+      printed = &fi;\n+      if (fi.ptid == inferior_ptid)\n \tprintf_filtered (\"* \");\n       else\n \tprintf_filtered (\"  \");\n \n-      pc = fp->pc;\n-      printf_filtered (\"%d %s\", fp->num, target_pid_to_str (fp->ptid));\n-      if (fp->num == 0)\n+      ULONGEST pc = fi.pc;\n+      printf_filtered (\"%d %s\", fi.num, target_pid_to_str (fi.ptid));\n+      if (fi.num == 0)\n \tprintf_filtered (_(\" (main process)\"));\n       printf_filtered (_(\" at \"));\n       fputs_filtered (paddress (gdbarch, pc), gdb_stdout);\n \n-      sal = find_pc_line (pc, 0);\n+      symtab_and_line sal = find_pc_line (pc, 0);\n       if (sal.symtab)\n \tprintf_filtered (_(\", file %s\"),\n \t\t\t symtab_to_filename_for_display (sal.symtab));\n@@ -762,14 +721,12 @@ checkpoint_command (const char *args, int from_tty)\n   if (!fp)\n     error (_(\"Failed to find new fork\"));\n \n-  if (fork_list->next == NULL)\n+  if (one_fork_p ())\n     {\n       /* Special case -- if this is the first fork in the list (the\n \t list was hitherto empty), then add inferior_ptid first, as a\n \t special zeroeth fork id.  */\n-      fork_info *first = new_fork (inferior_ptid.pid ());\n-      first->next = fork_list;\n-      fork_list = first;\n+      fork_list.emplace_front (inferior_ptid.pid ());\n     }\n \n   fork_save_infrun_state (fp, 1);\n@@ -816,8 +773,6 @@ restart_command (const char *args, int from_tty)\n void\n _initialize_linux_fork (void)\n {\n-  init_fork_list ();\n-\n   /* Checkpoint command: create a fork of the inferior process\n      and set it aside for later debugging.  */\n "
    }
  ]
}