{
  "sha": "65b1aa7501ace4c58fb5062479c710d0bdff6f34",
  "node_id": "C_kwDOANOeidoAKDY1YjFhYTc1MDFhY2U0YzU4ZmI1MDYyNDc5YzcxMGQwYmRmZjZmMzQ",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-15T00:19:03Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-17T22:07:09Z"
    },
    "message": "Generate new gdbarch-components.py from gdbarch.sh\n\nThe new gdbarch.sh approach will be to edit a Python file, rather than\nadding a line to a certain part of gdbarch.sh.  We use the existing sh\ncode, though, to generate the first draft of this .py file.\n\nDocumentation on the format will come in a subsequent patch.\n\nNote that some info (like \"staticdefault\") in the current code is\nactually unused, and so is ignored by this new generator.",
    "tree": {
      "sha": "13b6123bcc8f19e948960ea2c6361b7f82179a1a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/13b6123bcc8f19e948960ea2c6361b7f82179a1a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/65b1aa7501ace4c58fb5062479c710d0bdff6f34",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/65b1aa7501ace4c58fb5062479c710d0bdff6f34",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/65b1aa7501ace4c58fb5062479c710d0bdff6f34",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/65b1aa7501ace4c58fb5062479c710d0bdff6f34/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ce5abab7377ef54fcd44e1e19eb579c8444ac0dd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ce5abab7377ef54fcd44e1e19eb579c8444ac0dd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ce5abab7377ef54fcd44e1e19eb579c8444ac0dd"
    }
  ],
  "stats": {
    "total": 2612,
    "additions": 2612,
    "deletions": 0
  },
  "files": [
    {
      "sha": "dad2fe8cc180418584a55fc1560febf5a21a9c78",
      "filename": "gdb/gdbarch-components.py",
      "status": "added",
      "additions": 2539,
      "deletions": 0,
      "changes": 2539,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/65b1aa7501ace4c58fb5062479c710d0bdff6f34/gdb/gdbarch-components.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/65b1aa7501ace4c58fb5062479c710d0bdff6f34/gdb/gdbarch-components.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch-components.py?ref=65b1aa7501ace4c58fb5062479c710d0bdff6f34",
      "patch": "@@ -0,0 +1,2539 @@\n+# Dynamic architecture support for GDB, the GNU debugger.\n+\n+# Copyright (C) 1998-2021 Free Software Foundation, Inc.\n+\n+# This file is part of GDB.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+\n+Info(\n+    type=\"const struct bfd_arch_info *\",\n+    name=\"bfd_arch_info\",\n+    printer=\"gdbarch_bfd_arch_info (gdbarch)->printable_name\",\n+)\n+\n+Info(\n+    type=\"enum bfd_endian\",\n+    name=\"byte_order\",\n+)\n+\n+Info(\n+    type=\"enum bfd_endian\",\n+    name=\"byte_order_for_code\",\n+)\n+\n+Info(\n+    type=\"enum gdb_osabi\",\n+    name=\"osabi\",\n+)\n+\n+Info(\n+    type=\"const struct target_desc *\",\n+    name=\"target_desc\",\n+    printer=\"host_address_to_string (gdbarch->target_desc)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Number of bits in a short or unsigned short for the target machine.\n+\"\"\",\n+    type=\"int\",\n+    name=\"short_bit\",\n+    predefault=\"2*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Number of bits in an int or unsigned int for the target machine.\n+\"\"\",\n+    type=\"int\",\n+    name=\"int_bit\",\n+    predefault=\"4*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Number of bits in a long or unsigned long for the target machine.\n+\"\"\",\n+    type=\"int\",\n+    name=\"long_bit\",\n+    predefault=\"4*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Number of bits in a long long or unsigned long long for the target\n+machine.\n+\"\"\",\n+    type=\"int\",\n+    name=\"long_long_bit\",\n+    predefault=\"2*gdbarch->long_bit\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+The ABI default bit-size and format for \"bfloat16\", \"half\", \"float\", \"double\", and\n+\"long double\".  These bit/format pairs should eventually be combined\n+into a single object.  For the moment, just initialize them as a pair.\n+Each format describes both the big and little endian layouts (if\n+useful).\n+\"\"\",\n+    type=\"int\",\n+    name=\"bfloat16_bit\",\n+    predefault=\"2*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"const struct floatformat **\",\n+    name=\"bfloat16_format\",\n+    postdefault=\"floatformats_bfloat16\",\n+    invalid=True,\n+    printer=\"pformat (gdbarch->bfloat16_format)\",\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"half_bit\",\n+    predefault=\"2*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"const struct floatformat **\",\n+    name=\"half_format\",\n+    postdefault=\"floatformats_ieee_half\",\n+    invalid=True,\n+    printer=\"pformat (gdbarch->half_format)\",\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"float_bit\",\n+    predefault=\"4*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"const struct floatformat **\",\n+    name=\"float_format\",\n+    postdefault=\"floatformats_ieee_single\",\n+    invalid=True,\n+    printer=\"pformat (gdbarch->float_format)\",\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"double_bit\",\n+    predefault=\"8*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"const struct floatformat **\",\n+    name=\"double_format\",\n+    postdefault=\"floatformats_ieee_double\",\n+    invalid=True,\n+    printer=\"pformat (gdbarch->double_format)\",\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"long_double_bit\",\n+    predefault=\"8*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"const struct floatformat **\",\n+    name=\"long_double_format\",\n+    postdefault=\"floatformats_ieee_double\",\n+    invalid=True,\n+    printer=\"pformat (gdbarch->long_double_format)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+The ABI default bit-size for \"wchar_t\".  wchar_t is a built-in type\n+starting with C++11.\n+\"\"\",\n+    type=\"int\",\n+    name=\"wchar_bit\",\n+    predefault=\"4*TARGET_CHAR_BIT\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+One if `wchar_t' is signed, zero if unsigned.\n+\"\"\",\n+    type=\"int\",\n+    name=\"wchar_signed\",\n+    predefault=\"-1\",\n+    postdefault=\"1\",\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Returns the floating-point format to be used for values of length LENGTH.\n+NAME, if non-NULL, is the type name, which may be used to distinguish\n+different target formats of the same length.\n+\"\"\",\n+    type=\"const struct floatformat **\",\n+    name=\"floatformat_for_type\",\n+    params=[(\"const char *\", \"name\"), (\"int\", \"length\")],\n+    predefault=\"default_floatformat_for_type\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+For most targets, a pointer on the target and its representation as an\n+address in GDB have the same size and \"look the same\".  For such a\n+target, you need only set gdbarch_ptr_bit and gdbarch_addr_bit\n+/ addr_bit will be set from it.\n+\n+If gdbarch_ptr_bit and gdbarch_addr_bit are different, you'll probably\n+also need to set gdbarch_dwarf2_addr_size, gdbarch_pointer_to_address and\n+gdbarch_address_to_pointer as well.\n+\n+ptr_bit is the size of a pointer on the target\n+\"\"\",\n+    type=\"int\",\n+    name=\"ptr_bit\",\n+    predefault=\"gdbarch->int_bit\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+addr_bit is the size of a target address as represented in gdb\n+\"\"\",\n+    type=\"int\",\n+    name=\"addr_bit\",\n+    predefault=\"0\",\n+    postdefault=\"gdbarch_ptr_bit (gdbarch)\",\n+    invalid=True,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+dwarf2_addr_size is the target address size as used in the Dwarf debug\n+info.  For .debug_frame FDEs, this is supposed to be the target address\n+size from the associated CU header, and which is equivalent to the\n+DWARF2_ADDR_SIZE as defined by the target specific GCC back-end.\n+Unfortunately there is no good way to determine this value.  Therefore\n+dwarf2_addr_size simply defaults to the target pointer size.\n+\n+dwarf2_addr_size is not used for .eh_frame FDEs, which are generally\n+defined using the target's pointer size so far.\n+\n+Note that dwarf2_addr_size only needs to be redefined by a target if the\n+GCC back-end defines a DWARF2_ADDR_SIZE other than the target pointer size,\n+and if Dwarf versions < 4 need to be supported.\n+\"\"\",\n+    type=\"int\",\n+    name=\"dwarf2_addr_size\",\n+    predefault=\"0\",\n+    postdefault=\"gdbarch_ptr_bit (gdbarch) / TARGET_CHAR_BIT\",\n+    invalid=True,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+One if `char' acts like `signed char', zero if `unsigned char'.\n+\"\"\",\n+    type=\"int\",\n+    name=\"char_signed\",\n+    predefault=\"-1\",\n+    postdefault=\"1\",\n+    invalid=True,\n+)\n+\n+Function(\n+    type=\"CORE_ADDR\",\n+    name=\"read_pc\",\n+    params=[(\"readable_regcache *\", \"regcache\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Function(\n+    type=\"void\",\n+    name=\"write_pc\",\n+    params=[(\"struct regcache *\", \"regcache\"), (\"CORE_ADDR\", \"val\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Function for getting target's idea of a frame pointer.  FIXME: GDB's\n+whole scheme for dealing with \"frames\" and \"frame pointers\" needs a\n+serious shakedown.\n+\"\"\",\n+    type=\"void\",\n+    name=\"virtual_frame_pointer\",\n+    params=[\n+        (\"CORE_ADDR\", \"pc\"),\n+        (\"int *\", \"frame_regnum\"),\n+        (\"LONGEST *\", \"frame_offset\"),\n+    ],\n+    predefault=\"legacy_virtual_frame_pointer\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"enum register_status\",\n+    name=\"pseudo_register_read\",\n+    params=[\n+        (\"readable_regcache *\", \"regcache\"),\n+        (\"int\", \"cookednum\"),\n+        (\"gdb_byte *\", \"buf\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Read a register into a new struct value.  If the register is wholly\n+or partly unavailable, this should call mark_value_bytes_unavailable\n+as appropriate.  If this is defined, then pseudo_register_read will\n+never be called.\n+\"\"\",\n+    type=\"struct value *\",\n+    name=\"pseudo_register_read_value\",\n+    params=[(\"readable_regcache *\", \"regcache\"), (\"int\", \"cookednum\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"void\",\n+    name=\"pseudo_register_write\",\n+    params=[\n+        (\"struct regcache *\", \"regcache\"),\n+        (\"int\", \"cookednum\"),\n+        (\"const gdb_byte *\", \"buf\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"num_regs\",\n+    predefault=\"-1\",\n+    invalid=True,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+This macro gives the number of pseudo-registers that live in the\n+register namespace but do not get fetched or stored on the target.\n+These pseudo-registers may be aliases for other registers,\n+combinations of other registers, or they may be computed by GDB.\n+\"\"\",\n+    type=\"int\",\n+    name=\"num_pseudo_regs\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Assemble agent expression bytecode to collect pseudo-register REG.\n+Return -1 if something goes wrong, 0 otherwise.\n+\"\"\",\n+    type=\"int\",\n+    name=\"ax_pseudo_register_collect\",\n+    params=[(\"struct agent_expr *\", \"ax\"), (\"int\", \"reg\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Assemble agent expression bytecode to push the value of pseudo-register\n+REG on the interpreter stack.\n+Return -1 if something goes wrong, 0 otherwise.\n+\"\"\",\n+    type=\"int\",\n+    name=\"ax_pseudo_register_push_stack\",\n+    params=[(\"struct agent_expr *\", \"ax\"), (\"int\", \"reg\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Some architectures can display additional information for specific\n+signals.\n+UIOUT is the output stream where the handler will place information.\n+\"\"\",\n+    type=\"void\",\n+    name=\"report_signal_info\",\n+    params=[(\"struct ui_out *\", \"uiout\"), (\"enum gdb_signal\", \"siggnal\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+GDB's standard (or well known) register numbers.  These can map onto\n+a real register or a pseudo (computed) register or not be defined at\n+all (-1).\n+gdbarch_sp_regnum will hopefully be replaced by UNWIND_SP.\n+\"\"\",\n+    type=\"int\",\n+    name=\"sp_regnum\",\n+    predefault=\"-1\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"pc_regnum\",\n+    predefault=\"-1\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"ps_regnum\",\n+    predefault=\"-1\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"fp0_regnum\",\n+    predefault=\"-1\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Convert stab register number (from `r' declaration) to a gdb REGNUM.\n+\"\"\",\n+    type=\"int\",\n+    name=\"stab_reg_to_regnum\",\n+    params=[(\"int\", \"stab_regnr\")],\n+    predefault=\"no_op_reg_to_regnum\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Provide a default mapping from a ecoff register number to a gdb REGNUM.\n+\"\"\",\n+    type=\"int\",\n+    name=\"ecoff_reg_to_regnum\",\n+    params=[(\"int\", \"ecoff_regnr\")],\n+    predefault=\"no_op_reg_to_regnum\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Convert from an sdb register number to an internal gdb register number.\n+\"\"\",\n+    type=\"int\",\n+    name=\"sdb_reg_to_regnum\",\n+    params=[(\"int\", \"sdb_regnr\")],\n+    predefault=\"no_op_reg_to_regnum\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Provide a default mapping from a DWARF2 register number to a gdb REGNUM.\n+Return -1 for bad REGNUM.  Note: Several targets get this wrong.\n+\"\"\",\n+    type=\"int\",\n+    name=\"dwarf2_reg_to_regnum\",\n+    params=[(\"int\", \"dwarf2_regnr\")],\n+    predefault=\"no_op_reg_to_regnum\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"const char *\",\n+    name=\"register_name\",\n+    params=[(\"int\", \"regnr\")],\n+    predefault=\"0\",\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the type of a register specified by the architecture.  Only\n+the register cache should call this function directly; others should\n+use \"register_type\".\n+\"\"\",\n+    type=\"struct type *\",\n+    name=\"register_type\",\n+    params=[(\"int\", \"reg_nr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Generate a dummy frame_id for THIS_FRAME assuming that the frame is\n+a dummy frame.  A dummy frame is created before an inferior call,\n+the frame_id returned here must match the frame_id that was built\n+for the inferior call.  Usually this means the returned frame_id's\n+stack address should match the address returned by\n+gdbarch_push_dummy_call, and the returned frame_id's code address\n+should match the address at which the breakpoint was set in the dummy\n+frame.\n+\"\"\",\n+    type=\"struct frame_id\",\n+    name=\"dummy_id\",\n+    params=[(\"struct frame_info *\", \"this_frame\")],\n+    predefault=\"default_dummy_id\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Implement DUMMY_ID and PUSH_DUMMY_CALL, then delete\n+deprecated_fp_regnum.\n+\"\"\",\n+    type=\"int\",\n+    name=\"deprecated_fp_regnum\",\n+    predefault=\"-1\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"push_dummy_call\",\n+    params=[\n+        (\"struct value *\", \"function\"),\n+        (\"struct regcache *\", \"regcache\"),\n+        (\"CORE_ADDR\", \"bp_addr\"),\n+        (\"int\", \"nargs\"),\n+        (\"struct value **\", \"args\"),\n+        (\"CORE_ADDR\", \"sp\"),\n+        (\"function_call_return_method\", \"return_method\"),\n+        (\"CORE_ADDR\", \"struct_addr\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"call_dummy_location\",\n+    predefault=\"AT_ENTRY_POINT\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"push_dummy_code\",\n+    params=[\n+        (\"CORE_ADDR\", \"sp\"),\n+        (\"CORE_ADDR\", \"funaddr\"),\n+        (\"struct value **\", \"args\"),\n+        (\"int\", \"nargs\"),\n+        (\"struct type *\", \"value_type\"),\n+        (\"CORE_ADDR *\", \"real_pc\"),\n+        (\"CORE_ADDR *\", \"bp_addr\"),\n+        (\"struct regcache *\", \"regcache\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return true if the code of FRAME is writable.\n+\"\"\",\n+    type=\"int\",\n+    name=\"code_of_frame_writable\",\n+    params=[(\"struct frame_info *\", \"frame\")],\n+    predefault=\"default_code_of_frame_writable\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"void\",\n+    name=\"print_registers_info\",\n+    params=[\n+        (\"struct ui_file *\", \"file\"),\n+        (\"struct frame_info *\", \"frame\"),\n+        (\"int\", \"regnum\"),\n+        (\"int\", \"all\"),\n+    ],\n+    predefault=\"default_print_registers_info\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"void\",\n+    name=\"print_float_info\",\n+    params=[\n+        (\"struct ui_file *\", \"file\"),\n+        (\"struct frame_info *\", \"frame\"),\n+        (\"const char *\", \"args\"),\n+    ],\n+    predefault=\"default_print_float_info\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"void\",\n+    name=\"print_vector_info\",\n+    params=[\n+        (\"struct ui_file *\", \"file\"),\n+        (\"struct frame_info *\", \"frame\"),\n+        (\"const char *\", \"args\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+MAP a GDB RAW register number onto a simulator register number.  See\n+also include/...-sim.h.\n+\"\"\",\n+    type=\"int\",\n+    name=\"register_sim_regno\",\n+    params=[(\"int\", \"reg_nr\")],\n+    predefault=\"legacy_register_sim_regno\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"int\",\n+    name=\"cannot_fetch_register\",\n+    params=[(\"int\", \"regnum\")],\n+    predefault=\"cannot_register_not\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"int\",\n+    name=\"cannot_store_register\",\n+    params=[(\"int\", \"regnum\")],\n+    predefault=\"cannot_register_not\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Determine the address where a longjmp will land and save this address\n+in PC.  Return nonzero on success.\n+\n+FRAME corresponds to the longjmp frame.\n+\"\"\",\n+    type=\"int\",\n+    name=\"get_longjmp_target\",\n+    params=[(\"struct frame_info *\", \"frame\"), (\"CORE_ADDR *\", \"pc\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"believe_pcc_promotion\",\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"int\",\n+    name=\"convert_register_p\",\n+    params=[(\"int\", \"regnum\"), (\"struct type *\", \"type\")],\n+    predefault=\"generic_convert_register_p\",\n+    invalid=False,\n+)\n+\n+Function(\n+    type=\"int\",\n+    name=\"register_to_value\",\n+    params=[\n+        (\"struct frame_info *\", \"frame\"),\n+        (\"int\", \"regnum\"),\n+        (\"struct type *\", \"type\"),\n+        (\"gdb_byte *\", \"buf\"),\n+        (\"int *\", \"optimizedp\"),\n+        (\"int *\", \"unavailablep\"),\n+    ],\n+    invalid=True,\n+)\n+\n+Function(\n+    type=\"void\",\n+    name=\"value_to_register\",\n+    params=[\n+        (\"struct frame_info *\", \"frame\"),\n+        (\"int\", \"regnum\"),\n+        (\"struct type *\", \"type\"),\n+        (\"const gdb_byte *\", \"buf\"),\n+    ],\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Construct a value representing the contents of register REGNUM in\n+frame FRAME_ID, interpreted as type TYPE.  The routine needs to\n+allocate and return a struct value with all value attributes\n+(but not the value contents) filled in.\n+\"\"\",\n+    type=\"struct value *\",\n+    name=\"value_from_register\",\n+    params=[\n+        (\"struct type *\", \"type\"),\n+        (\"int\", \"regnum\"),\n+        (\"struct frame_id\", \"frame_id\"),\n+    ],\n+    predefault=\"default_value_from_register\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"pointer_to_address\",\n+    params=[(\"struct type *\", \"type\"), (\"const gdb_byte *\", \"buf\")],\n+    predefault=\"unsigned_pointer_to_address\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"void\",\n+    name=\"address_to_pointer\",\n+    params=[(\"struct type *\", \"type\"), (\"gdb_byte *\", \"buf\"), (\"CORE_ADDR\", \"addr\")],\n+    predefault=\"unsigned_address_to_pointer\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"integer_to_address\",\n+    params=[(\"struct type *\", \"type\"), (\"const gdb_byte *\", \"buf\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the return-value convention that will be used by FUNCTION\n+to return a value of type VALTYPE.  FUNCTION may be NULL in which\n+case the return convention is computed based only on VALTYPE.\n+\n+If READBUF is not NULL, extract the return value and save it in this buffer.\n+\n+If WRITEBUF is not NULL, it contains a return value which will be\n+stored into the appropriate register.  This can be used when we want\n+to force the value returned by a function (see the \"return\" command\n+for instance).\n+\"\"\",\n+    type=\"enum return_value_convention\",\n+    name=\"return_value\",\n+    params=[\n+        (\"struct value *\", \"function\"),\n+        (\"struct type *\", \"valtype\"),\n+        (\"struct regcache *\", \"regcache\"),\n+        (\"gdb_byte *\", \"readbuf\"),\n+        (\"const gdb_byte *\", \"writebuf\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return true if the return value of function is stored in the first hidden\n+parameter.  In theory, this feature should be language-dependent, specified\n+by language and its ABI, such as C++.  Unfortunately, compiler may\n+implement it to a target-dependent feature.  So that we need such hook here\n+to be aware of this in GDB.\n+\"\"\",\n+    type=\"int\",\n+    name=\"return_in_first_hidden_param_p\",\n+    params=[(\"struct type *\", \"type\")],\n+    predefault=\"default_return_in_first_hidden_param_p\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"skip_prologue\",\n+    params=[(\"CORE_ADDR\", \"ip\")],\n+    predefault=\"0\",\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"skip_main_prologue\",\n+    params=[(\"CORE_ADDR\", \"ip\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+On some platforms, a single function may provide multiple entry points,\n+e.g. one that is used for function-pointer calls and a different one\n+that is used for direct function calls.\n+In order to ensure that breakpoints set on the function will trigger\n+no matter via which entry point the function is entered, a platform\n+may provide the skip_entrypoint callback.  It is called with IP set\n+to the main entry point of a function (as determined by the symbol table),\n+and should return the address of the innermost entry point, where the\n+actual breakpoint needs to be set.  Note that skip_entrypoint is used\n+by GDB common code even when debugging optimized code, where skip_prologue\n+is not used.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"skip_entrypoint\",\n+    params=[(\"CORE_ADDR\", \"ip\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Function(\n+    type=\"int\",\n+    name=\"inner_than\",\n+    params=[(\"CORE_ADDR\", \"lhs\"), (\"CORE_ADDR\", \"rhs\")],\n+    predefault=\"0\",\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"const gdb_byte *\",\n+    name=\"breakpoint_from_pc\",\n+    params=[(\"CORE_ADDR *\", \"pcptr\"), (\"int *\", \"lenptr\")],\n+    predefault=\"default_breakpoint_from_pc\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the breakpoint kind for this target based on *PCPTR.\n+\"\"\",\n+    type=\"int\",\n+    name=\"breakpoint_kind_from_pc\",\n+    params=[(\"CORE_ADDR *\", \"pcptr\")],\n+    predefault=\"0\",\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the software breakpoint from KIND.  KIND can have target\n+specific meaning like the Z0 kind parameter.\n+SIZE is set to the software breakpoint's length in memory.\n+\"\"\",\n+    type=\"const gdb_byte *\",\n+    name=\"sw_breakpoint_from_kind\",\n+    params=[(\"int\", \"kind\"), (\"int *\", \"size\")],\n+    predefault=\"NULL\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the breakpoint kind for this target based on the current\n+processor state (e.g. the current instruction mode on ARM) and the\n+*PCPTR.  In default, it is gdbarch->breakpoint_kind_from_pc.\n+\"\"\",\n+    type=\"int\",\n+    name=\"breakpoint_kind_from_current_state\",\n+    params=[(\"struct regcache *\", \"regcache\"), (\"CORE_ADDR *\", \"pcptr\")],\n+    predefault=\"default_breakpoint_kind_from_current_state\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"adjust_breakpoint_address\",\n+    params=[(\"CORE_ADDR\", \"bpaddr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"int\",\n+    name=\"memory_insert_breakpoint\",\n+    params=[(\"struct bp_target_info *\", \"bp_tgt\")],\n+    predefault=\"default_memory_insert_breakpoint\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"int\",\n+    name=\"memory_remove_breakpoint\",\n+    params=[(\"struct bp_target_info *\", \"bp_tgt\")],\n+    predefault=\"default_memory_remove_breakpoint\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"CORE_ADDR\",\n+    name=\"decr_pc_after_break\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+A function can be addressed by either it's \"pointer\" (possibly a\n+descriptor address) or \"entry point\" (first executable instruction).\n+The method \"convert_from_func_ptr_addr\" converting the former to the\n+latter.  gdbarch_deprecated_function_start_offset is being used to implement\n+a simplified subset of that functionality - the function's address\n+corresponds to the \"function pointer\" and the function's start\n+corresponds to the \"function entry point\" - and hence is redundant.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"deprecated_function_start_offset\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the remote protocol register number associated with this\n+register.  Normally the identity mapping.\n+\"\"\",\n+    type=\"int\",\n+    name=\"remote_register_number\",\n+    params=[(\"int\", \"regno\")],\n+    predefault=\"default_remote_register_number\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Fetch the target specific address used to represent a load module.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"fetch_tls_load_module_address\",\n+    params=[(\"struct objfile *\", \"objfile\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the thread-local address at OFFSET in the thread-local\n+storage for the thread PTID and the shared library or executable\n+file given by LM_ADDR.  If that block of thread-local storage hasn't\n+been allocated yet, this function may throw an error.  LM_ADDR may\n+be zero for statically linked multithreaded inferiors.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"get_thread_local_address\",\n+    params=[(\"ptid_t\", \"ptid\"), (\"CORE_ADDR\", \"lm_addr\"), (\"CORE_ADDR\", \"offset\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    type=\"CORE_ADDR\",\n+    name=\"frame_args_skip\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"unwind_pc\",\n+    params=[(\"struct frame_info *\", \"next_frame\")],\n+    predefault=\"default_unwind_pc\",\n+    invalid=False,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"unwind_sp\",\n+    params=[(\"struct frame_info *\", \"next_frame\")],\n+    predefault=\"default_unwind_sp\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+DEPRECATED_FRAME_LOCALS_ADDRESS as been replaced by the per-frame\n+frame-base.  Enable frame-base before frame-unwind.\n+\"\"\",\n+    type=\"int\",\n+    name=\"frame_num_args\",\n+    params=[(\"struct frame_info *\", \"frame\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"frame_align\",\n+    params=[(\"CORE_ADDR\", \"address\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"int\",\n+    name=\"stabs_argument_has_addr\",\n+    params=[(\"struct type *\", \"type\")],\n+    predefault=\"default_stabs_argument_has_addr\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"frame_red_zone_size\",\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"CORE_ADDR\",\n+    name=\"convert_from_func_ptr_addr\",\n+    params=[(\"CORE_ADDR\", \"addr\"), (\"struct target_ops *\", \"targ\")],\n+    predefault=\"convert_from_func_ptr_addr_identity\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+On some machines there are bits in addresses which are not really\n+part of the address, but are used by the kernel, the hardware, etc.\n+for special purposes.  gdbarch_addr_bits_remove takes out any such bits so\n+we get a \"real\" address such as one would find in a symbol table.\n+This is used only for addresses of instructions, and even then I'm\n+not sure it's used in all contexts.  It exists to deal with there\n+being a few stray bits in the PC which would mislead us, not as some\n+sort of generic thing to handle alignment or segmentation (it's\n+possible it should be in TARGET_READ_PC instead).\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"addr_bits_remove\",\n+    params=[(\"CORE_ADDR\", \"addr\")],\n+    predefault=\"core_addr_identity\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+On some machines, not all bits of an address word are significant.\n+For example, on AArch64, the top bits of an address known as the \"tag\"\n+are ignored by the kernel, the hardware, etc. and can be regarded as\n+additional data associated with the address.\n+\"\"\",\n+    type=\"int\",\n+    name=\"significant_addr_bit\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return a string representation of the memory tag TAG.\n+\"\"\",\n+    type=\"std::string\",\n+    name=\"memtag_to_string\",\n+    params=[(\"struct value *\", \"tag\")],\n+    predefault=\"default_memtag_to_string\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return true if ADDRESS contains a tag and false otherwise.  ADDRESS\n+must be either a pointer or a reference type.\n+\"\"\",\n+    type=\"bool\",\n+    name=\"tagged_address_p\",\n+    params=[(\"struct value *\", \"address\")],\n+    predefault=\"default_tagged_address_p\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return true if the tag from ADDRESS matches the memory tag for that\n+particular address.  Return false otherwise.\n+\"\"\",\n+    type=\"bool\",\n+    name=\"memtag_matches_p\",\n+    params=[(\"struct value *\", \"address\")],\n+    predefault=\"default_memtag_matches_p\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Set the tags of type TAG_TYPE, for the memory address range\n+[ADDRESS, ADDRESS + LENGTH) to TAGS.\n+Return true if successful and false otherwise.\n+\"\"\",\n+    type=\"bool\",\n+    name=\"set_memtags\",\n+    params=[\n+        (\"struct value *\", \"address\"),\n+        (\"size_t\", \"length\"),\n+        (\"const gdb::byte_vector &\", \"tags\"),\n+        (\"memtag_type\", \"tag_type\"),\n+    ],\n+    predefault=\"default_set_memtags\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the tag of type TAG_TYPE associated with the memory address ADDRESS,\n+assuming ADDRESS is tagged.\n+\"\"\",\n+    type=\"struct value *\",\n+    name=\"get_memtag\",\n+    params=[(\"struct value *\", \"address\"), (\"memtag_type\", \"tag_type\")],\n+    predefault=\"default_get_memtag\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+memtag_granule_size is the size of the allocation tag granule, for\n+architectures that support memory tagging.\n+This is 0 for architectures that do not support memory tagging.\n+For a non-zero value, this represents the number of bytes of memory per tag.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"memtag_granule_size\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+FIXME/cagney/2001-01-18: This should be split in two.  A target method that\n+indicates if the target needs software single step.  An ISA method to\n+implement it.\n+\n+FIXME/cagney/2001-01-18: The logic is backwards.  It should be asking if the\n+target can single step.  If not, then implement single step using breakpoints.\n+\n+Return a vector of addresses on which the software single step\n+breakpoints should be inserted.  NULL means software single step is\n+not used.\n+Multiple breakpoints may be inserted for some instructions such as\n+conditional branch.  However, each implementation must always evaluate\n+the condition and only put the breakpoint at the branch destination if\n+the condition is true, so that we ensure forward progress when stepping\n+past a conditional branch to self.\n+\"\"\",\n+    type=\"std::vector<CORE_ADDR>\",\n+    name=\"software_single_step\",\n+    params=[(\"struct regcache *\", \"regcache\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return non-zero if the processor is executing a delay slot and a\n+further single-step is needed before the instruction finishes.\n+\"\"\",\n+    type=\"int\",\n+    name=\"single_step_through_delay\",\n+    params=[(\"struct frame_info *\", \"frame\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+FIXME: cagney/2003-08-28: Need to find a better way of selecting the\n+disassembler.  Perhaps objdump can handle it?\n+\"\"\",\n+    type=\"int\",\n+    name=\"print_insn\",\n+    params=[(\"bfd_vma\", \"vma\"), (\"struct disassemble_info *\", \"info\")],\n+    predefault=\"default_print_insn\",\n+    invalid=False,\n+)\n+\n+Function(\n+    type=\"CORE_ADDR\",\n+    name=\"skip_trampoline_code\",\n+    params=[(\"struct frame_info *\", \"frame\"), (\"CORE_ADDR\", \"pc\")],\n+    predefault=\"generic_skip_trampoline_code\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+If in_solib_dynsym_resolve_code() returns true, and SKIP_SOLIB_RESOLVER\n+evaluates non-zero, this is the address where the debugger will place\n+a step-resume breakpoint to get us past the dynamic linker.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"skip_solib_resolver\",\n+    params=[(\"CORE_ADDR\", \"pc\")],\n+    predefault=\"generic_skip_solib_resolver\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Some systems also have trampoline code for returning from shared libs.\n+\"\"\",\n+    type=\"int\",\n+    name=\"in_solib_return_trampoline\",\n+    params=[(\"CORE_ADDR\", \"pc\"), (\"const char *\", \"name\")],\n+    predefault=\"generic_in_solib_return_trampoline\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return true if PC lies inside an indirect branch thunk.\n+\"\"\",\n+    type=\"bool\",\n+    name=\"in_indirect_branch_thunk\",\n+    params=[(\"CORE_ADDR\", \"pc\")],\n+    predefault=\"default_in_indirect_branch_thunk\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+A target might have problems with watchpoints as soon as the stack\n+frame of the current function has been destroyed.  This mostly happens\n+as the first action in a function's epilogue.  stack_frame_destroyed_p()\n+is defined to return a non-zero value if either the given addr is one\n+instruction after the stack destroying instruction up to the trailing\n+return instruction or if we can figure out that the stack frame has\n+already been invalidated regardless of the value of addr.  Targets\n+which don't suffer from that problem could just let this functionality\n+untouched.\n+\"\"\",\n+    type=\"int\",\n+    name=\"stack_frame_destroyed_p\",\n+    params=[(\"CORE_ADDR\", \"addr\")],\n+    predefault=\"generic_stack_frame_destroyed_p\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Process an ELF symbol in the minimal symbol table in a backend-specific\n+way.  Normally this hook is supposed to do nothing, however if required,\n+then this hook can be used to apply tranformations to symbols that are\n+considered special in some way.  For example the MIPS backend uses it\n+to interpret `st_other' information to mark compressed code symbols so\n+that they can be treated in the appropriate manner in the processing of\n+the main symbol table and DWARF-2 records.\n+\"\"\",\n+    type=\"void\",\n+    name=\"elf_make_msymbol_special\",\n+    params=[(\"asymbol *\", \"sym\"), (\"struct minimal_symbol *\", \"msym\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Function(\n+    type=\"void\",\n+    name=\"coff_make_msymbol_special\",\n+    params=[(\"int\", \"val\"), (\"struct minimal_symbol *\", \"msym\")],\n+    predefault=\"default_coff_make_msymbol_special\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Process a symbol in the main symbol table in a backend-specific way.\n+Normally this hook is supposed to do nothing, however if required,\n+then this hook can be used to apply tranformations to symbols that\n+are considered special in some way.  This is currently used by the\n+MIPS backend to make sure compressed code symbols have the ISA bit\n+set.  This in turn is needed for symbol values seen in GDB to match\n+the values used at the runtime by the program itself, for function\n+and label references.\n+\"\"\",\n+    type=\"void\",\n+    name=\"make_symbol_special\",\n+    params=[(\"struct symbol *\", \"sym\"), (\"struct objfile *\", \"objfile\")],\n+    predefault=\"default_make_symbol_special\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Adjust the address retrieved from a DWARF-2 record other than a line\n+entry in a backend-specific way.  Normally this hook is supposed to\n+return the address passed unchanged, however if that is incorrect for\n+any reason, then this hook can be used to fix the address up in the\n+required manner.  This is currently used by the MIPS backend to make\n+sure addresses in FDE, range records, etc. referring to compressed\n+code have the ISA bit set, matching line information and the symbol\n+table.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"adjust_dwarf2_addr\",\n+    params=[(\"CORE_ADDR\", \"pc\")],\n+    predefault=\"default_adjust_dwarf2_addr\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Adjust the address updated by a line entry in a backend-specific way.\n+Normally this hook is supposed to return the address passed unchanged,\n+however in the case of inconsistencies in these records, this hook can\n+be used to fix them up in the required manner.  This is currently used\n+by the MIPS backend to make sure all line addresses in compressed code\n+are presented with the ISA bit set, which is not always the case.  This\n+in turn ensures breakpoint addresses are correctly matched against the\n+stop PC.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"adjust_dwarf2_line\",\n+    params=[(\"CORE_ADDR\", \"addr\"), (\"int\", \"rel\")],\n+    predefault=\"default_adjust_dwarf2_line\",\n+    invalid=False,\n+)\n+\n+Value(\n+    type=\"int\",\n+    name=\"cannot_step_breakpoint\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+See comment in target.h about continuable, steppable and\n+non-steppable watchpoints.\n+\"\"\",\n+    type=\"int\",\n+    name=\"have_nonsteppable_watchpoint\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Function(\n+    type=\"type_instance_flags\",\n+    name=\"address_class_type_flags\",\n+    params=[(\"int\", \"byte_size\"), (\"int\", \"dwarf2_addr_class\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"const char *\",\n+    name=\"address_class_type_flags_to_name\",\n+    params=[(\"type_instance_flags\", \"type_flags\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Execute vendor-specific DWARF Call Frame Instruction.  OP is the instruction.\n+FS are passed from the generic execute_cfa_program function.\n+\"\"\",\n+    type=\"bool\",\n+    name=\"execute_dwarf_cfa_vendor_op\",\n+    params=[(\"gdb_byte\", \"op\"), (\"struct dwarf2_frame_state *\", \"fs\")],\n+    predefault=\"default_execute_dwarf_cfa_vendor_op\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the appropriate type_flags for the supplied address class.\n+This function should return true if the address class was recognized and\n+type_flags was set, false otherwise.\n+\"\"\",\n+    type=\"bool\",\n+    name=\"address_class_name_to_type_flags\",\n+    params=[(\"const char *\", \"name\"), (\"type_instance_flags *\", \"type_flags_ptr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Is a register in a group\n+\"\"\",\n+    type=\"int\",\n+    name=\"register_reggroup_p\",\n+    params=[(\"int\", \"regnum\"), (\"struct reggroup *\", \"reggroup\")],\n+    predefault=\"default_register_reggroup_p\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Fetch the pointer to the ith function argument.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"fetch_pointer_argument\",\n+    params=[\n+        (\"struct frame_info *\", \"frame\"),\n+        (\"int\", \"argi\"),\n+        (\"struct type *\", \"type\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Iterate over all supported register notes in a core file.  For each\n+supported register note section, the iterator must call CB and pass\n+CB_DATA unchanged.  If REGCACHE is not NULL, the iterator can limit\n+the supported register note sections based on the current register\n+values.  Otherwise it should enumerate all supported register note\n+sections.\n+\"\"\",\n+    type=\"void\",\n+    name=\"iterate_over_regset_sections\",\n+    params=[\n+        (\"iterate_over_regset_sections_cb *\", \"cb\"),\n+        (\"void *\", \"cb_data\"),\n+        (\"const struct regcache *\", \"regcache\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Create core file notes\n+\"\"\",\n+    type=\"gdb::unique_xmalloc_ptr<char>\",\n+    name=\"make_corefile_notes\",\n+    params=[(\"bfd *\", \"obfd\"), (\"int *\", \"note_size\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Find core file memory regions\n+\"\"\",\n+    type=\"int\",\n+    name=\"find_memory_regions\",\n+    params=[(\"find_memory_region_ftype\", \"func\"), (\"void *\", \"data\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Read offset OFFSET of TARGET_OBJECT_LIBRARIES formatted shared libraries list from\n+core file into buffer READBUF with length LEN.  Return the number of bytes read\n+(zero indicates failure).\n+failed, otherwise, return the red length of READBUF.\n+\"\"\",\n+    type=\"ULONGEST\",\n+    name=\"core_xfer_shared_libraries\",\n+    params=[(\"gdb_byte *\", \"readbuf\"), (\"ULONGEST\", \"offset\"), (\"ULONGEST\", \"len\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Read offset OFFSET of TARGET_OBJECT_LIBRARIES_AIX formatted shared\n+libraries list from core file into buffer READBUF with length LEN.\n+Return the number of bytes read (zero indicates failure).\n+\"\"\",\n+    type=\"ULONGEST\",\n+    name=\"core_xfer_shared_libraries_aix\",\n+    params=[(\"gdb_byte *\", \"readbuf\"), (\"ULONGEST\", \"offset\"), (\"ULONGEST\", \"len\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+How the core target converts a PTID from a core file to a string.\n+\"\"\",\n+    type=\"std::string\",\n+    name=\"core_pid_to_str\",\n+    params=[(\"ptid_t\", \"ptid\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+How the core target extracts the name of a thread from a core file.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"core_thread_name\",\n+    params=[(\"struct thread_info *\", \"thr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Read offset OFFSET of TARGET_OBJECT_SIGNAL_INFO signal information\n+from core file into buffer READBUF with length LEN.  Return the number\n+of bytes read (zero indicates EOF, a negative value indicates failure).\n+\"\"\",\n+    type=\"LONGEST\",\n+    name=\"core_xfer_siginfo\",\n+    params=[(\"gdb_byte *\", \"readbuf\"), (\"ULONGEST\", \"offset\"), (\"ULONGEST\", \"len\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+BFD target to use when generating a core file.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"gcore_bfd_target\",\n+    predicate=True,\n+    predefault=\"0\",\n+    invalid=True,\n+    printer=\"pstring (gdbarch->gcore_bfd_target)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+If the elements of C++ vtables are in-place function descriptors rather\n+than normal function pointers (which may point to code or a descriptor),\n+set this to one.\n+\"\"\",\n+    type=\"int\",\n+    name=\"vtable_function_descriptors\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Set if the least significant bit of the delta is used instead of the least\n+significant bit of the pfn for pointers to virtual member functions.\n+\"\"\",\n+    type=\"int\",\n+    name=\"vbit_in_delta\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Advance PC to next instruction in order to skip a permanent breakpoint.\n+\"\"\",\n+    type=\"void\",\n+    name=\"skip_permanent_breakpoint\",\n+    params=[(\"struct regcache *\", \"regcache\")],\n+    predefault=\"default_skip_permanent_breakpoint\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+The maximum length of an instruction on this architecture in bytes.\n+\"\"\",\n+    type=\"ULONGEST\",\n+    name=\"max_insn_length\",\n+    predicate=True,\n+    predefault=\"0\",\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Copy the instruction at FROM to TO, and make any adjustments\n+necessary to single-step it at that address.\n+\n+REGS holds the state the thread's registers will have before\n+executing the copied instruction; the PC in REGS will refer to FROM,\n+not the copy at TO.  The caller should update it to point at TO later.\n+\n+Return a pointer to data of the architecture's choice to be passed\n+to gdbarch_displaced_step_fixup.\n+\n+For a general explanation of displaced stepping and how GDB uses it,\n+see the comments in infrun.c.\n+\n+The TO area is only guaranteed to have space for\n+gdbarch_max_insn_length (arch) bytes, so this function must not\n+write more bytes than that to that area.\n+\n+If you do not provide this function, GDB assumes that the\n+architecture does not support displaced stepping.\n+\n+If the instruction cannot execute out of line, return NULL.  The\n+core falls back to stepping past the instruction in-line instead in\n+that case.\n+\"\"\",\n+    type=\"displaced_step_copy_insn_closure_up\",\n+    name=\"displaced_step_copy_insn\",\n+    params=[(\"CORE_ADDR\", \"from\"), (\"CORE_ADDR\", \"to\"), (\"struct regcache *\", \"regs\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return true if GDB should use hardware single-stepping to execute a displaced\n+step instruction.  If false, GDB will simply restart execution at the\n+displaced instruction location, and it is up to the target to ensure GDB will\n+receive control again (e.g. by placing a software breakpoint instruction into\n+the displaced instruction buffer).\n+\n+The default implementation returns false on all targets that provide a\n+gdbarch_software_single_step routine, and true otherwise.\n+\"\"\",\n+    type=\"bool\",\n+    name=\"displaced_step_hw_singlestep\",\n+    params=(),\n+    predefault=\"default_displaced_step_hw_singlestep\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Fix up the state resulting from successfully single-stepping a\n+displaced instruction, to give the result we would have gotten from\n+stepping the instruction in its original location.\n+\n+REGS is the register state resulting from single-stepping the\n+displaced instruction.\n+\n+CLOSURE is the result from the matching call to\n+gdbarch_displaced_step_copy_insn.\n+\n+If you provide gdbarch_displaced_step_copy_insn.but not this\n+function, then GDB assumes that no fixup is needed after\n+single-stepping the instruction.\n+\n+For a general explanation of displaced stepping and how GDB uses it,\n+see the comments in infrun.c.\n+\"\"\",\n+    type=\"void\",\n+    name=\"displaced_step_fixup\",\n+    params=[\n+        (\"struct displaced_step_copy_insn_closure *\", \"closure\"),\n+        (\"CORE_ADDR\", \"from\"),\n+        (\"CORE_ADDR\", \"to\"),\n+        (\"struct regcache *\", \"regs\"),\n+    ],\n+    predicate=True,\n+    predefault=\"NULL\",\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Prepare THREAD for it to displaced step the instruction at its current PC.\n+\n+Throw an exception if any unexpected error happens.\n+\"\"\",\n+    type=\"displaced_step_prepare_status\",\n+    name=\"displaced_step_prepare\",\n+    params=[(\"thread_info *\", \"thread\"), (\"CORE_ADDR &\", \"displaced_pc\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Clean up after a displaced step of THREAD.\n+\"\"\",\n+    type=\"displaced_step_finish_status\",\n+    name=\"displaced_step_finish\",\n+    params=[(\"thread_info *\", \"thread\"), (\"gdb_signal\", \"sig\")],\n+    predefault=\"NULL\",\n+    invalid=\"(! gdbarch->displaced_step_finish) != (! gdbarch->displaced_step_prepare)\",\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Return the closure associated to the displaced step buffer that is at ADDR.\n+\"\"\",\n+    type=\"const displaced_step_copy_insn_closure *\",\n+    name=\"displaced_step_copy_insn_closure_by_addr\",\n+    params=[(\"inferior *\", \"inf\"), (\"CORE_ADDR\", \"addr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+PARENT_INF has forked and CHILD_PTID is the ptid of the child.  Restore the\n+contents of all displaced step buffers in the child's address space.\n+\"\"\",\n+    type=\"void\",\n+    name=\"displaced_step_restore_all_in_ptid\",\n+    params=[(\"inferior *\", \"parent_inf\"), (\"ptid_t\", \"child_ptid\")],\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Relocate an instruction to execute at a different address.  OLDLOC\n+is the address in the inferior memory where the instruction to\n+relocate is currently at.  On input, TO points to the destination\n+where we want the instruction to be copied (and possibly adjusted)\n+to.  On output, it points to one past the end of the resulting\n+instruction(s).  The effect of executing the instruction at TO shall\n+be the same as if executing it at FROM.  For example, call\n+instructions that implicitly push the return address on the stack\n+should be adjusted to return to the instruction after OLDLOC;\n+relative branches, and other PC-relative instructions need the\n+offset adjusted; etc.\n+\"\"\",\n+    type=\"void\",\n+    name=\"relocate_instruction\",\n+    params=[(\"CORE_ADDR *\", \"to\"), (\"CORE_ADDR\", \"from\")],\n+    predicate=True,\n+    predefault=\"NULL\",\n+    invalid=True,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Refresh overlay mapped state for section OSECT.\n+\"\"\",\n+    type=\"void\",\n+    name=\"overlay_update\",\n+    params=[(\"struct obj_section *\", \"osect\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    type=\"const struct target_desc *\",\n+    name=\"core_read_description\",\n+    params=[(\"struct target_ops *\", \"target\"), (\"bfd *\", \"abfd\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Set if the address in N_SO or N_FUN stabs may be zero.\n+\"\"\",\n+    type=\"int\",\n+    name=\"sofun_address_maybe_missing\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Parse the instruction at ADDR storing in the record execution log\n+the registers REGCACHE and memory ranges that will be affected when\n+the instruction executes, along with their current values.\n+Return -1 if something goes wrong, 0 otherwise.\n+\"\"\",\n+    type=\"int\",\n+    name=\"process_record\",\n+    params=[(\"struct regcache *\", \"regcache\"), (\"CORE_ADDR\", \"addr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Save process state after a signal.\n+Return -1 if something goes wrong, 0 otherwise.\n+\"\"\",\n+    type=\"int\",\n+    name=\"process_record_signal\",\n+    params=[(\"struct regcache *\", \"regcache\"), (\"enum gdb_signal\", \"signal\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Signal translation: translate inferior's signal (target's) number\n+into GDB's representation.  The implementation of this method must\n+be host independent.  IOW, don't rely on symbols of the NAT_FILE\n+header (the nm-*.h files), the host <signal.h> header, or similar\n+headers.  This is mainly used when cross-debugging core files ---\n+\"Live\" targets hide the translation behind the target interface\n+(target_wait, target_resume, etc.).\n+\"\"\",\n+    type=\"enum gdb_signal\",\n+    name=\"gdb_signal_from_target\",\n+    params=[(\"int\", \"signo\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Signal translation: translate the GDB's internal signal number into\n+the inferior's signal (target's) representation.  The implementation\n+of this method must be host independent.  IOW, don't rely on symbols\n+of the NAT_FILE header (the nm-*.h files), the host <signal.h>\n+header, or similar headers.\n+Return the target signal number if found, or -1 if the GDB internal\n+signal number is invalid.\n+\"\"\",\n+    type=\"int\",\n+    name=\"gdb_signal_to_target\",\n+    params=[(\"enum gdb_signal\", \"signal\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Extra signal info inspection.\n+\n+Return a type suitable to inspect extra signal information.\n+\"\"\",\n+    type=\"struct type *\",\n+    name=\"get_siginfo_type\",\n+    params=(),\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Record architecture-specific information from the symbol table.\n+\"\"\",\n+    type=\"void\",\n+    name=\"record_special_symbol\",\n+    params=[(\"struct objfile *\", \"objfile\"), (\"asymbol *\", \"sym\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Function for the 'catch syscall' feature.\n+Get architecture-specific system calls information from registers.\n+\"\"\",\n+    type=\"LONGEST\",\n+    name=\"get_syscall_number\",\n+    params=[(\"thread_info *\", \"thread\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+The filename of the XML syscall for this architecture.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"xml_syscall_file\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring (gdbarch->xml_syscall_file)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Information about system calls from this architecture\n+\"\"\",\n+    type=\"struct syscalls_info *\",\n+    name=\"syscalls_info\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"host_address_to_string (gdbarch->syscalls_info)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+SystemTap related fields and functions.\n+A NULL-terminated array of prefixes used to mark an integer constant\n+on the architecture's assembly.\n+For example, on x86 integer constants are written as:\n+\n+$10 ;; integer constant 10\n+\n+in this case, this prefix would be the character `$'.\n+\"\"\",\n+    type=\"const char *const *\",\n+    name=\"stap_integer_prefixes\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring_list (gdbarch->stap_integer_prefixes)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+A NULL-terminated array of suffixes used to mark an integer constant\n+on the architecture's assembly.\n+\"\"\",\n+    type=\"const char *const *\",\n+    name=\"stap_integer_suffixes\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring_list (gdbarch->stap_integer_suffixes)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+A NULL-terminated array of prefixes used to mark a register name on\n+the architecture's assembly.\n+For example, on x86 the register name is written as:\n+\n+%eax ;; register eax\n+\n+in this case, this prefix would be the character `%'.\n+\"\"\",\n+    type=\"const char *const *\",\n+    name=\"stap_register_prefixes\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring_list (gdbarch->stap_register_prefixes)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+A NULL-terminated array of suffixes used to mark a register name on\n+the architecture's assembly.\n+\"\"\",\n+    type=\"const char *const *\",\n+    name=\"stap_register_suffixes\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring_list (gdbarch->stap_register_suffixes)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+A NULL-terminated array of prefixes used to mark a register\n+indirection on the architecture's assembly.\n+For example, on x86 the register indirection is written as:\n+\n+(%eax) ;; indirecting eax\n+\n+in this case, this prefix would be the charater `('.\n+\n+Please note that we use the indirection prefix also for register\n+displacement, e.g., `4(%eax)' on x86.\n+\"\"\",\n+    type=\"const char *const *\",\n+    name=\"stap_register_indirection_prefixes\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring_list (gdbarch->stap_register_indirection_prefixes)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+A NULL-terminated array of suffixes used to mark a register\n+indirection on the architecture's assembly.\n+For example, on x86 the register indirection is written as:\n+\n+(%eax) ;; indirecting eax\n+\n+in this case, this prefix would be the charater `)'.\n+\n+Please note that we use the indirection suffix also for register\n+displacement, e.g., `4(%eax)' on x86.\n+\"\"\",\n+    type=\"const char *const *\",\n+    name=\"stap_register_indirection_suffixes\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring_list (gdbarch->stap_register_indirection_suffixes)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Prefix(es) used to name a register using GDB's nomenclature.\n+\n+For example, on PPC a register is represented by a number in the assembly\n+language (e.g., `10' is the 10th general-purpose register).  However,\n+inside GDB this same register has an `r' appended to its name, so the 10th\n+register would be represented as `r10' internally.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"stap_gdb_register_prefix\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring (gdbarch->stap_gdb_register_prefix)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Suffix used to name a register using GDB's nomenclature.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"stap_gdb_register_suffix\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring (gdbarch->stap_gdb_register_suffix)\",\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Check if S is a single operand.\n+\n+Single operands can be:\n+- Literal integers, e.g. `$10' on x86\n+- Register access, e.g. `%eax' on x86\n+- Register indirection, e.g. `(%eax)' on x86\n+- Register displacement, e.g. `4(%eax)' on x86\n+\n+This function should check for these patterns on the string\n+and return 1 if some were found, or zero otherwise.  Please try to match\n+as much info as you can from the string, i.e., if you have to match\n+something like `(%', do not match just the `('.\n+\"\"\",\n+    type=\"int\",\n+    name=\"stap_is_single_operand\",\n+    params=[(\"const char *\", \"s\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Function used to handle a \"special case\" in the parser.\n+\n+A \"special case\" is considered to be an unknown token, i.e., a token\n+that the parser does not know how to parse.  A good example of special\n+case would be ARM's register displacement syntax:\n+\n+[R0, #4]  ;; displacing R0 by 4\n+\n+Since the parser assumes that a register displacement is of the form:\n+\n+<number> <indirection_prefix> <register_name> <indirection_suffix>\n+\n+it means that it will not be able to recognize and parse this odd syntax.\n+Therefore, we should add a special case function that will handle this token.\n+\n+This function should generate the proper expression form of the expression\n+using GDB's internal expression mechanism (e.g., `write_exp_elt_opcode'\n+and so on).  It should also return 1 if the parsing was successful, or zero\n+if the token was not recognized as a special token (in this case, returning\n+zero means that the special parser is deferring the parsing to the generic\n+parser), and should advance the buffer pointer (p->arg).\n+\"\"\",\n+    type=\"expr::operation_up\",\n+    name=\"stap_parse_special_token\",\n+    params=[(\"struct stap_parse_info *\", \"p\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Perform arch-dependent adjustments to a register name.\n+\n+In very specific situations, it may be necessary for the register\n+name present in a SystemTap probe's argument to be handled in a\n+special way.  For example, on i386, GCC may over-optimize the\n+register allocation and use smaller registers than necessary.  In\n+such cases, the client that is reading and evaluating the SystemTap\n+probe (ourselves) will need to actually fetch values from the wider\n+version of the register in question.\n+\n+To illustrate the example, consider the following probe argument\n+(i386):\n+\n+4@%ax\n+\n+This argument says that its value can be found at the %ax register,\n+which is a 16-bit register.  However, the argument's prefix says\n+that its type is \"uint32_t\", which is 32-bit in size.  Therefore, in\n+this case, GDB should actually fetch the probe's value from register\n+%eax, not %ax.  In this scenario, this function would actually\n+replace the register name from %ax to %eax.\n+\n+The rationale for this can be found at PR breakpoints/24541.\n+\"\"\",\n+    type=\"std::string\",\n+    name=\"stap_adjust_register\",\n+    params=[\n+        (\"struct stap_parse_info *\", \"p\"),\n+        (\"const std::string &\", \"regname\"),\n+        (\"int\", \"regnum\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+DTrace related functions.\n+The expression to compute the NARTGth+1 argument to a DTrace USDT probe.\n+NARG must be >= 0.\n+\"\"\",\n+    type=\"expr::operation_up\",\n+    name=\"dtrace_parse_probe_argument\",\n+    params=[(\"int\", \"narg\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+True if the given ADDR does not contain the instruction sequence\n+corresponding to a disabled DTrace is-enabled probe.\n+\"\"\",\n+    type=\"int\",\n+    name=\"dtrace_probe_is_enabled\",\n+    params=[(\"CORE_ADDR\", \"addr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Enable a DTrace is-enabled probe at ADDR.\n+\"\"\",\n+    type=\"void\",\n+    name=\"dtrace_enable_probe\",\n+    params=[(\"CORE_ADDR\", \"addr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Disable a DTrace is-enabled probe at ADDR.\n+\"\"\",\n+    type=\"void\",\n+    name=\"dtrace_disable_probe\",\n+    params=[(\"CORE_ADDR\", \"addr\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+True if the list of shared libraries is one and only for all\n+processes, as opposed to a list of shared libraries per inferior.\n+This usually means that all processes, although may or may not share\n+an address space, will see the same set of symbols at the same\n+addresses.\n+\"\"\",\n+    type=\"int\",\n+    name=\"has_global_solist\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+On some targets, even though each inferior has its own private\n+address space, the debug interface takes care of making breakpoints\n+visible to all address spaces automatically.  For such cases,\n+this property should be set to true.\n+\"\"\",\n+    type=\"int\",\n+    name=\"has_global_breakpoints\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+True if inferiors share an address space (e.g., uClinux).\n+\"\"\",\n+    type=\"int\",\n+    name=\"has_shared_address_space\",\n+    params=(),\n+    predefault=\"default_has_shared_address_space\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+True if a fast tracepoint can be set at an address.\n+\"\"\",\n+    type=\"int\",\n+    name=\"fast_tracepoint_valid_at\",\n+    params=[(\"CORE_ADDR\", \"addr\"), (\"std::string *\", \"msg\")],\n+    predefault=\"default_fast_tracepoint_valid_at\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Guess register state based on tracepoint location.  Used for tracepoints\n+where no registers have been collected, but there's only one location,\n+allowing us to guess the PC value, and perhaps some other registers.\n+On entry, regcache has all registers marked as unavailable.\n+\"\"\",\n+    type=\"void\",\n+    name=\"guess_tracepoint_registers\",\n+    params=[(\"struct regcache *\", \"regcache\"), (\"CORE_ADDR\", \"addr\")],\n+    predefault=\"default_guess_tracepoint_registers\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Return the \"auto\" target charset.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"auto_charset\",\n+    params=(),\n+    predefault=\"default_auto_charset\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Return the \"auto\" target wide charset.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"auto_wide_charset\",\n+    params=(),\n+    predefault=\"default_auto_wide_charset\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+If non-empty, this is a file extension that will be opened in place\n+of the file extension reported by the shared library list.\n+\n+This is most useful for toolchains that use a post-linker tool,\n+where the names of the files run on the target differ in extension\n+compared to the names of the files GDB should load for debug info.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"solib_symbols_extension\",\n+    invalid=True,\n+    printer=\"pstring (gdbarch->solib_symbols_extension)\",\n+)\n+\n+Value(\n+    comment=\"\"\"\n+If true, the target OS has DOS-based file system semantics.  That\n+is, absolute paths include a drive name, and the backslash is\n+considered a directory separator.\n+\"\"\",\n+    type=\"int\",\n+    name=\"has_dos_based_file_system\",\n+    predefault=\"0\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Generate bytecodes to collect the return address in a frame.\n+Since the bytecodes run on the target, possibly with GDB not even\n+connected, the full unwinding machinery is not available, and\n+typically this function will issue bytecodes for one or more likely\n+places that the return address may be found.\n+\"\"\",\n+    type=\"void\",\n+    name=\"gen_return_address\",\n+    params=[\n+        (\"struct agent_expr *\", \"ax\"),\n+        (\"struct axs_value *\", \"value\"),\n+        (\"CORE_ADDR\", \"scope\"),\n+    ],\n+    predefault=\"default_gen_return_address\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Implement the \"info proc\" command.\n+\"\"\",\n+    type=\"void\",\n+    name=\"info_proc\",\n+    params=[(\"const char *\", \"args\"), (\"enum info_proc_what\", \"what\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Implement the \"info proc\" command for core files.  Noe that there\n+are two \"info_proc\"-like methods on gdbarch -- one for core files,\n+one for live targets.\n+\"\"\",\n+    type=\"void\",\n+    name=\"core_info_proc\",\n+    params=[(\"const char *\", \"args\"), (\"enum info_proc_what\", \"what\")],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Iterate over all objfiles in the order that makes the most sense\n+for the architecture to make global symbol searches.\n+\n+CB is a callback function where OBJFILE is the objfile to be searched,\n+and CB_DATA a pointer to user-defined data (the same data that is passed\n+when calling this gdbarch method).  The iteration stops if this function\n+returns nonzero.\n+\n+CB_DATA is a pointer to some user-defined data to be passed to\n+the callback.\n+\n+If not NULL, CURRENT_OBJFILE corresponds to the objfile being\n+inspected when the symbol search was requested.\n+\"\"\",\n+    type=\"void\",\n+    name=\"iterate_over_objfiles_in_search_order\",\n+    params=[\n+        (\"iterate_over_objfiles_in_search_order_cb_ftype *\", \"cb\"),\n+        (\"void *\", \"cb_data\"),\n+        (\"struct objfile *\", \"current_objfile\"),\n+    ],\n+    predefault=\"default_iterate_over_objfiles_in_search_order\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Ravenscar arch-dependent ops.\n+\"\"\",\n+    type=\"struct ravenscar_arch_ops *\",\n+    name=\"ravenscar_ops\",\n+    predefault=\"NULL\",\n+    invalid=False,\n+    printer=\"host_address_to_string (gdbarch->ravenscar_ops)\",\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return non-zero if the instruction at ADDR is a call; zero otherwise.\n+\"\"\",\n+    type=\"int\",\n+    name=\"insn_is_call\",\n+    params=[(\"CORE_ADDR\", \"addr\")],\n+    predefault=\"default_insn_is_call\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return non-zero if the instruction at ADDR is a return; zero otherwise.\n+\"\"\",\n+    type=\"int\",\n+    name=\"insn_is_ret\",\n+    params=[(\"CORE_ADDR\", \"addr\")],\n+    predefault=\"default_insn_is_ret\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return non-zero if the instruction at ADDR is a jump; zero otherwise.\n+\"\"\",\n+    type=\"int\",\n+    name=\"insn_is_jump\",\n+    params=[(\"CORE_ADDR\", \"addr\")],\n+    predefault=\"default_insn_is_jump\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return true if there's a program/permanent breakpoint planted in\n+memory at ADDRESS, return false otherwise.\n+\"\"\",\n+    type=\"bool\",\n+    name=\"program_breakpoint_here_p\",\n+    params=[(\"CORE_ADDR\", \"address\")],\n+    predefault=\"default_program_breakpoint_here_p\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Read one auxv entry from *READPTR, not reading locations >= ENDPTR.\n+Return 0 if *READPTR is already at the end of the buffer.\n+Return -1 if there is insufficient buffer for a whole entry.\n+Return 1 if an entry was read into *TYPEP and *VALP.\n+\"\"\",\n+    type=\"int\",\n+    name=\"auxv_parse\",\n+    params=[\n+        (\"gdb_byte **\", \"readptr\"),\n+        (\"gdb_byte *\", \"endptr\"),\n+        (\"CORE_ADDR *\", \"typep\"),\n+        (\"CORE_ADDR *\", \"valp\"),\n+    ],\n+    predicate=True,\n+    invalid=True,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Print the description of a single auxv entry described by TYPE and VAL\n+to FILE.\n+\"\"\",\n+    type=\"void\",\n+    name=\"print_auxv_entry\",\n+    params=[(\"struct ui_file *\", \"file\"), (\"CORE_ADDR\", \"type\"), (\"CORE_ADDR\", \"val\")],\n+    predefault=\"default_print_auxv_entry\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Find the address range of the current inferior's vsyscall/vDSO, and\n+write it to *RANGE.  If the vsyscall's length can't be determined, a\n+range with zero length is returned.  Returns true if the vsyscall is\n+found, false otherwise.\n+\"\"\",\n+    type=\"int\",\n+    name=\"vsyscall_range\",\n+    params=[(\"struct mem_range *\", \"range\")],\n+    predefault=\"default_vsyscall_range\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Allocate SIZE bytes of PROT protected page aligned memory in inferior.\n+PROT has GDB_MMAP_PROT_* bitmask format.\n+Throw an error if it is not possible.  Returned address is always valid.\n+\"\"\",\n+    type=\"CORE_ADDR\",\n+    name=\"infcall_mmap\",\n+    params=[(\"CORE_ADDR\", \"size\"), (\"unsigned\", \"prot\")],\n+    predefault=\"default_infcall_mmap\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Deallocate SIZE bytes of memory at ADDR in inferior from gdbarch_infcall_mmap.\n+Print a warning if it is not possible.\n+\"\"\",\n+    type=\"void\",\n+    name=\"infcall_munmap\",\n+    params=[(\"CORE_ADDR\", \"addr\"), (\"CORE_ADDR\", \"size\")],\n+    predefault=\"default_infcall_munmap\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return string (caller has to use xfree for it) with options for GCC\n+to produce code for this target, typically \"-m64\", \"-m32\" or \"-m31\".\n+These options are put before CU's DW_AT_producer compilation options so that\n+they can override it.\n+\"\"\",\n+    type=\"std::string\",\n+    name=\"gcc_target_options\",\n+    params=(),\n+    predefault=\"default_gcc_target_options\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return a regular expression that matches names used by this\n+architecture in GNU configury triplets.  The result is statically\n+allocated and must not be freed.  The default implementation simply\n+returns the BFD architecture name, which is correct in nearly every\n+case.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"gnu_triplet_regexp\",\n+    params=(),\n+    predefault=\"default_gnu_triplet_regexp\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Return the size in 8-bit bytes of an addressable memory unit on this\n+architecture.  This corresponds to the number of 8-bit bytes associated to\n+each address in memory.\n+\"\"\",\n+    type=\"int\",\n+    name=\"addressable_memory_unit_size\",\n+    params=(),\n+    predefault=\"default_addressable_memory_unit_size\",\n+    invalid=False,\n+)\n+\n+Value(\n+    comment=\"\"\"\n+Functions for allowing a target to modify its disassembler options.\n+\"\"\",\n+    type=\"const char *\",\n+    name=\"disassembler_options_implicit\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring (gdbarch->disassembler_options_implicit)\",\n+)\n+\n+Value(\n+    type=\"char **\",\n+    name=\"disassembler_options\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"pstring_ptr (gdbarch->disassembler_options)\",\n+)\n+\n+Value(\n+    type=\"const disasm_options_and_args_t *\",\n+    name=\"valid_disassembler_options\",\n+    predefault=\"0\",\n+    invalid=False,\n+    printer=\"host_address_to_string (gdbarch->valid_disassembler_options)\",\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Type alignment override method.  Return the architecture specific\n+alignment required for TYPE.  If there is no special handling\n+required for TYPE then return the value 0, GDB will then apply the\n+default rules as laid out in gdbtypes.c:type_align.\n+\"\"\",\n+    type=\"ULONGEST\",\n+    name=\"type_align\",\n+    params=[(\"struct type *\", \"type\")],\n+    predefault=\"default_type_align\",\n+    invalid=False,\n+)\n+\n+Function(\n+    comment=\"\"\"\n+Return a string containing any flags for the given PC in the given FRAME.\n+\"\"\",\n+    type=\"std::string\",\n+    name=\"get_pc_address_flags\",\n+    params=[(\"frame_info *\", \"frame\"), (\"CORE_ADDR\", \"pc\")],\n+    predefault=\"default_get_pc_address_flags\",\n+    invalid=False,\n+)\n+\n+Method(\n+    comment=\"\"\"\n+Read core file mappings\n+\"\"\",\n+    type=\"void\",\n+    name=\"read_core_file_mappings\",\n+    params=[\n+        (\"struct bfd *\", \"cbfd\"),\n+        (\"read_core_file_mappings_pre_loop_ftype\", \"pre_loop_cb\"),\n+        (\"read_core_file_mappings_loop_ftype\", \"loop_cb\"),\n+    ],\n+    predefault=\"default_read_core_file_mappings\",\n+    invalid=False,\n+)"
    },
    {
      "sha": "9675ef51228dd05b5f32294e059d67261afd21e1",
      "filename": "gdb/gdbarch.sh",
      "status": "modified",
      "additions": 73,
      "deletions": 0,
      "changes": 73,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/65b1aa7501ace4c58fb5062479c710d0bdff6f34/gdb/gdbarch.sh",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/65b1aa7501ace4c58fb5062479c710d0bdff6f34/gdb/gdbarch.sh",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbarch.sh?ref=65b1aa7501ace4c58fb5062479c710d0bdff6f34",
      "patch": "@@ -1715,3 +1715,76 @@ done\n exec 1>&2\n ../move-if-change new-gdbarch.c gdbarch.c\n rm -f new-gdbarch.c\n+\n+exec > gdbarch-components.py\n+copyright | sed 1,3d | grep -v 'was created' |\n+    sed -e 's,/\\*,  ,' -e 's, *\\*/,,' -e 's/^  /#/'\n+\n+function_list | while do_read\n+do\n+    printf \"\\n\"\n+    if class_is_info_p; then\n+\tprintf Info\n+    elif class_is_variable_p; then\n+\tprintf Value\n+    elif class_is_multiarch_p; then\n+\tprintf Method\n+    elif class_is_function_p; then\n+\tprintf Function\n+    else\n+\techo FAILURE 1>&2\n+\texit 1\n+    fi\n+    printf \"(\\n\"\n+    if [ -n \"${comment}\" ]\n+    then\n+\tprintf \"    comment=\\\"\\\"\\\"\"\n+\techo \"${comment}\" | sed 's/^# *//'\n+\tprintf \"\\\"\\\"\\\",\\n\"\n+    fi\n+\n+    # The order here is picked to be type, name, params -- that way\n+    # it's relatively \"C-like\".\n+    printf \"    type=\\\"%s\\\",\\n\" \"$returntype\"\n+    printf \"    name=\\\"%s\\\",\\n\" \"$function\"\n+    if class_is_function_p; then\n+\tif test -n \"$formal\" && test \"$formal\" != void; then\n+\t    printf \"    params=[\\n\"\n+\t    # Turn TYPE NAME into (\"TYPE\", \"NAME\").\n+\t    echo \"$formal\" | sed -e \"s/, */,\\n/g\" |\n+\t\tsed -e 's/ *\\([a-zA-Z_][a-zA-Z0-9_]*\\)\\(,*\\)$/\", \"\\1\")\\2/' |\n+\t\tsed -e 's/^/        (\"/'\n+\t    printf \"    ],\\n\"\n+\telse\n+\t    printf \"    params=(),\\n\"\n+\tfi\n+    fi\n+    if class_is_predicate_p; then\n+\tprintf \"    predicate=True,\\n\"\n+    fi\n+    if ! class_is_info_p; then\n+\tif test -n \"$predefault\"; then\n+\t    printf \"    predefault=\\\"%s\\\",\\n\" \"$predefault\"\n+\tfi\n+\t# We can ignore 'actual' and 'staticdefault'.\n+\tif test -n \"$postdefault\"; then\n+\t    printf \"    postdefault=\\\"%s\\\",\\n\" \"$postdefault\"\n+\tfi\n+\t# Let's arrange for False to mean suppress checking, and True\n+\t# to mean default checking.\n+\tif test \"$invalid_p\" = \"0\"; then\n+\t    printf \"    invalid=False,\\n\"\n+\telif test \"$invalid_p\" = \"\"; then\n+\t    printf \"    invalid=True,\\n\"\n+\telse\n+\t    printf \"    invalid=\\\"%s\\\",\\n\" \"$invalid_p\"\n+\tfi\n+    fi\n+    if test -n \"$print\"; then\n+\tprintf \"    printer=\\\"%s\\\",\\n\" \"$print\"\n+    fi\n+    printf \")\\n\"\n+done\n+\n+exec 1>&2\n+black gdbarch-components.py"
    }
  ]
}