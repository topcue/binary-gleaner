{
  "sha": "d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDQ5ZTUwNjVlZDQzZWM4ODYyN2ZkOGNjNmFiOWU0NWZjYzBlNTM4YQ==",
  "commit": {
    "author": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-03T14:07:09Z"
    },
    "committer": {
      "name": "H.J. Lu",
      "email": "hjl.tools@gmail.com",
      "date": "2020-06-03T14:07:24Z"
    },
    "message": "ELF: Consolidate maybe_set_textrel\n\nAll maybe_set_textrel implementations are the same.  Consolidate them\nto a single _bfd_elf_maybe_set_textrel.\n\n\t* elf-bfd.h (_bfd_elf_maybe_set_textrel): New\n\t* elf32-arm.c (maybe_set_textrel): Removed.\n\t(elf32_arm_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-csky.c (maybe_set_textrel): Removed.\n\t(csky_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-hppa.c (maybe_set_textrel): Removed.\n\t(elf32_hppa_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-lm32.c (maybe_set_textrel): Removed.\n\t(lm32_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-m32r.c (maybe_set_textrel): Removed.\n\t(m32r_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-metag.c (maybe_set_textrel): Removed.\n\t(elf_metag_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-nds32.c (maybe_set_textrel): Removed.\n\t(nds32_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-or1k.c (maybe_set_textrel): Removed.\n\t(or1k_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-ppc.c (maybe_set_textrel): Removed.\n\t(ppc_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-s390.c (maybe_set_textrel): Removed.\n\t(elf_s390_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-sh.c (maybe_set_textrel): Removed.\n\t(sh_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-tic6x.c (maybe_set_textrel): Removed.\n\t(elf32_tic6x_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf32-tilepro.c (maybe_set_textrel): Removed.\n\t(tilepro_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf64-ppc.c (maybe_set_textrel): Removed.\n\t(ppc64_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elf64-s390.c (maybe_set_textrel): Removed.\n\t(elf_s390_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elfnn-aarch64.c (maybe_set_textrel): Removed.\n\t(elfNN_aarch64_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elfnn-riscv.c (maybe_set_textrel): Removed.\n\t(riscv_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elfxx-sparc.c (maybe_set_textrel): Removed.\n\t(_bfd_sparc_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elfxx-tilegx.c (maybe_set_textrel): Removed.\n\t(tilegx_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elfxx-x86.c (maybe_set_textrel): Removed.\n\t(_bfd_x86_elf_size_dynamic_sections): Replace maybe_set_textrel\n\twith _bfd_elf_maybe_set_textrel.\n\t* elflink.c (_bfd_elf_maybe_set_textrel): New.",
    "tree": {
      "sha": "0be2a8afdd4b29f286a9aa6ccae341a3441f8073",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0be2a8afdd4b29f286a9aa6ccae341a3441f8073"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/comments",
  "author": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "hjl-tools",
    "id": 1072356,
    "node_id": "MDQ6VXNlcjEwNzIzNTY=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/hjl-tools",
    "html_url": "https://github.com/hjl-tools",
    "followers_url": "https://api.github.com/users/hjl-tools/followers",
    "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}",
    "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions",
    "organizations_url": "https://api.github.com/users/hjl-tools/orgs",
    "repos_url": "https://api.github.com/users/hjl-tools/repos",
    "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}",
    "received_events_url": "https://api.github.com/users/hjl-tools/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ad172eaa4f5ff973890a6c37574946cecf0668b0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ad172eaa4f5ff973890a6c37574946cecf0668b0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ad172eaa4f5ff973890a6c37574946cecf0668b0"
    }
  ],
  "stats": {
    "total": 713,
    "additions": 141,
    "deletions": 572
  },
  "files": [
    {
      "sha": "d215113495f33d77a9b1795b2fb734b1507b75ed",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 65,
      "deletions": 0,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -1,3 +1,68 @@\n+2020-06-03  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* elf-bfd.h (_bfd_elf_maybe_set_textrel): New\n+\t* elf32-arm.c (maybe_set_textrel): Removed.\n+\t(elf32_arm_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-csky.c (maybe_set_textrel): Removed.\n+\t(csky_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-hppa.c (maybe_set_textrel): Removed.\n+\t(elf32_hppa_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-lm32.c (maybe_set_textrel): Removed.\n+\t(lm32_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-m32r.c (maybe_set_textrel): Removed.\n+\t(m32r_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-metag.c (maybe_set_textrel): Removed.\n+\t(elf_metag_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-nds32.c (maybe_set_textrel): Removed.\n+\t(nds32_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-or1k.c (maybe_set_textrel): Removed.\n+\t(or1k_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-ppc.c (maybe_set_textrel): Removed.\n+\t(ppc_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-s390.c (maybe_set_textrel): Removed.\n+\t(elf_s390_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-sh.c (maybe_set_textrel): Removed.\n+\t(sh_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-tic6x.c (maybe_set_textrel): Removed.\n+\t(elf32_tic6x_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf32-tilepro.c (maybe_set_textrel): Removed.\n+\t(tilepro_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf64-ppc.c (maybe_set_textrel): Removed.\n+\t(ppc64_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elf64-s390.c (maybe_set_textrel): Removed.\n+\t(elf_s390_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elfnn-aarch64.c (maybe_set_textrel): Removed.\n+\t(elfNN_aarch64_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elfnn-riscv.c (maybe_set_textrel): Removed.\n+\t(riscv_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elfxx-sparc.c (maybe_set_textrel): Removed.\n+\t(_bfd_sparc_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elfxx-tilegx.c (maybe_set_textrel): Removed.\n+\t(tilegx_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elfxx-x86.c (maybe_set_textrel): Removed.\n+\t(_bfd_x86_elf_size_dynamic_sections): Replace maybe_set_textrel\n+\twith _bfd_elf_maybe_set_textrel.\n+\t* elflink.c (_bfd_elf_maybe_set_textrel): New.\n+\n 2020-06-03  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR ld/26067"
    },
    {
      "sha": "fbdd19ba21e35fbbe15da230c3ad5ce7ecb94b6d",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -2876,6 +2876,8 @@ extern unsigned int _bfd_elf_symbol_section_index\n \n extern asection *_bfd_elf_readonly_dynrelocs\n   (struct elf_link_hash_entry *);\n+extern bfd_boolean _bfd_elf_maybe_set_textrel\n+  (struct elf_link_hash_entry *, void *);\n \n /* Large common section.  */\n extern asection _bfd_elf_large_com_section;"
    },
    {
      "sha": "8d184b5a094ddd1f85ecb8b506104bfe3a38526b",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 2,
      "deletions": 29,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -16671,34 +16671,6 @@ allocate_dynrelocs_for_symbol (struct elf_link_hash_entry *h, void * inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-\n-  return TRUE;\n-}\n-\n void\n bfd_elf32_arm_set_byteswap_code (struct bfd_link_info *info,\n \t\t\t\t int byteswap_code)\n@@ -17142,7 +17114,8 @@ elf32_arm_size_dynamic_sections (bfd * output_bfd ATTRIBUTE_UNUSED,\n       /* If any dynamic relocs apply to a read-only section,\n \t then we need a DT_TEXTREL entry.  */\n       if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->root, maybe_set_textrel, info);\n+\telf_link_hash_traverse (&htab->root,\n+\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n \n       if ((info->flags & DF_TEXTREL) != 0)\n \t{"
    },
    {
      "sha": "43828beed03296c5847729a45a2f531a60d612ed",
      "filename": "bfd/elf32-csky.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-csky.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -1893,33 +1893,6 @@ csky_allocate_dynrelocs (struct elf_link_hash_entry *h, PTR inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -2152,7 +2125,8 @@ csky_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->elf,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0\n \t      && !add_dynamic_entry (DT_TEXTREL, 0))"
    },
    {
      "sha": "d131f1a0794a26a752d3aee72a8fb2719911e2b2",
      "filename": "bfd/elf32-hppa.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-hppa.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -2042,33 +2042,6 @@ clobber_millicode_symbols (struct elf_link_hash_entry *eh,\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *eh, void *inf)\n-{\n-  asection *sec;\n-\n-  if (eh->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (eh);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) inf;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, eh->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -2346,7 +2319,8 @@ elf32_hppa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->etab, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->etab,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "3c31dd44c853d91a3cb058c4a7d118f40d9dd8e4",
      "filename": "bfd/elf32-lm32.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-lm32.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -1914,33 +1914,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -2132,7 +2105,8 @@ lm32_elf_size_dynamic_sections (bfd *output_bfd,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->root,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "931e138b37a04ad5ed67b99412f4c59b976a3ad2",
      "filename": "bfd/elf32-m32r.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32r.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -1978,33 +1978,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -2200,7 +2173,8 @@ m32r_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->root,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "7938b24d2a5fd3517b916913a5924693f2731aed",
      "filename": "bfd/elf32-metag.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-metag.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -2715,33 +2715,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *eh, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -2966,7 +2939,8 @@ elf_metag_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->etab, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->etab,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "01ea277426fb345bb5aad237edc899ab86369bfd",
      "filename": "bfd/elf32-nds32.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -4252,33 +4252,6 @@ elf32_nds32_add_dynreloc (bfd *output_bfd,\n   bfd_elf32_swap_reloca_out (output_bfd, rel, loc);\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -4552,7 +4525,8 @@ nds32_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root, maybe_set_textrel,\n+\t    elf_link_hash_traverse (&htab->root,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel,\n \t\t\t\t    (void *) info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)"
    },
    {
      "sha": "ac62d630ab34b2d59a62eee813f0789075c4ca15",
      "filename": "bfd/elf32-or1k.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-or1k.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -2919,33 +2919,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -3150,7 +3123,8 @@ or1k_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t /* If any dynamic relocs apply to a read-only section,\n \t    then we need a DT_TEXTREL entry.  */\n \t if ((info->flags & DF_TEXTREL) == 0)\n-\t   elf_link_hash_traverse (&htab->root, maybe_set_textrel, info);\n+\t   elf_link_hash_traverse (&htab->root,\n+\t\t\t\t   _bfd_elf_maybe_set_textrel, info);\n \n \t if ((info->flags & DF_TEXTREL) != 0)\n \t   {"
    },
    {
      "sha": "0cb7f67504d4d4f56a4272f37d65f4f604a0f12c",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -5423,33 +5423,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n static const unsigned char glink_eh_frame_cie[] =\n {\n   0, 0, 0, 16,\t\t\t\t/* length.  */\n@@ -5900,7 +5873,8 @@ ppc_elf_size_dynamic_sections (bfd *output_bfd,\n       /* If any dynamic relocs apply to a read-only section, then we\n \t need a DT_TEXTREL entry.  */\n       if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (elf_hash_table (info), maybe_set_textrel,\n+\telf_link_hash_traverse (elf_hash_table (info),\n+\t\t\t\t_bfd_elf_maybe_set_textrel,\n \t\t\t\tinfo);\n \n       if ((info->flags & DF_TEXTREL) != 0)"
    },
    {
      "sha": "5bd63fe1c942a7aa48a1c8c514312662d684845d",
      "filename": "bfd/elf32-s390.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-s390.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -1777,33 +1777,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -2027,7 +2000,8 @@ elf_s390_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->elf,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "9ec745be199388b3183f0e67b1b6b06d5989d97d",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -2926,33 +2926,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* This function is called after all the input files have been read,\n    and the input sections have been assigned to output sections.\n    It's a convenient place to determine the PLT style.  */\n@@ -3268,7 +3241,8 @@ sh_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->root,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "d1ba4c2a93f12979e6216b0a0c37adb3d63c0b02",
      "filename": "bfd/elf32-tic6x.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tic6x.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -3170,33 +3170,6 @@ elf32_tic6x_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -3410,7 +3383,8 @@ elf32_tic6x_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->elf,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "2d78f3c9c89c1ef0c0e372af28d40156f2608cab",
      "filename": "bfd/elf32-tilepro.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf32-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tilepro.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -2168,33 +2168,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Return true if the dynamic symbol for a given section should be\n    omitted when creating a shared library.  */\n \n@@ -2441,7 +2414,8 @@ tilepro_elf_size_dynamic_sections (bfd *output_bfd,\n       /* If any dynamic relocs apply to a read-only section,\n \t then we need a DT_TEXTREL entry.  */\n       if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\telf_link_hash_traverse (&htab->elf,\n+\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n \n       if (info->flags & DF_TEXTREL)\n \t{"
    },
    {
      "sha": "5f99d4344b7623c8d29c733a5f5d26a935093f5d",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -9862,33 +9862,6 @@ size_global_entry_stubs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) inf;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo (_(\"%pB: dynamic relocation against `%pT'\"\n-\t\t\t\t\" in read-only section `%pA'\\n\"),\n-\t\t\t      sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -10264,7 +10237,8 @@ ppc64_elf_size_dynamic_sections (bfd *output_bfd,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->elf,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "5b95b5f814ad239752452d9b60fbb1e7dcb15e4d",
      "filename": "bfd/elf64-s390.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf64-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elf64-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-s390.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -1713,33 +1713,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h,\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Set the sizes of the dynamic sections.  */\n \n static bfd_boolean\n@@ -1981,7 +1954,8 @@ elf_s390_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->elf,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "ce6282a9dcfc0691ff05979222adba6e816d1c2f",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -14841,3 +14841,37 @@ _bfd_elf_readonly_dynrelocs (struct elf_link_hash_entry *h)\n     }\n   return NULL;\n }\n+\n+/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n+   read-only sections.  */\n+\n+bfd_boolean\n+_bfd_elf_maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)\n+{\n+  asection *sec;\n+\n+  if (h->root.type == bfd_link_hash_indirect)\n+    return TRUE;\n+\n+  sec = _bfd_elf_readonly_dynrelocs (h);\n+  if (sec != NULL)\n+    {\n+      struct bfd_link_info *info = (struct bfd_link_info *) inf;\n+\n+      info->flags |= DF_TEXTREL;\n+      /* xgettext:c-format */\n+      info->callbacks->minfo (_(\"%pB: dynamic relocation against `%pT' \"\n+\t\t\t\t\"in read-only section `%pA'\\n\"),\n+\t\t\t      sec->owner, h->root.root.string, sec);\n+\n+      if (bfd_link_textrel_check (info))\n+\t/* xgettext:c-format */\n+\tinfo->callbacks->einfo (_(\"%P: %pB: warning: relocation against `%s' \"\n+\t\t\t\t  \"in read-only section `%pA'\\n\"),\n+\t\t\t\tsec->owner, h->root.root.string, sec);\n+\n+      /* Not an error, just cut short the traversal.  */\n+      return FALSE;\n+    }\n+  return TRUE;\n+}"
    },
    {
      "sha": "64215f718500c24eb5df15921d57f086eec23097",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -8856,33 +8856,6 @@ elfNN_aarch64_allocate_local_ifunc_dynrelocs (void **slot, void *inf)\n   return elfNN_aarch64_allocate_ifunc_dynrelocs (h, inf);\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* This is the most important function of all . Innocuosly named\n    though !  */\n \n@@ -9186,7 +9159,8 @@ elfNN_aarch64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->root, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->root,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    },
    {
      "sha": "163c4d9f7450f85d128966ba81668e99c8809095",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -1088,33 +1088,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n static bfd_boolean\n riscv_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n {\n@@ -1321,7 +1294,8 @@ riscv_elf_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)\n       /* If any dynamic relocs apply to a read-only section,\n \t then we need a DT_TEXTREL entry.  */\n       if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\telf_link_hash_traverse (&htab->elf,\n+\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n \n       if (info->flags & DF_TEXTREL)\n \t{"
    },
    {
      "sha": "5ef29eac28382bcd1937800573ab02814125cd71",
      "filename": "bfd/elfxx-sparc.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfxx-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfxx-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -2359,33 +2359,6 @@ allocate_local_dynrelocs (void **slot, void *inf)\n   return allocate_dynrelocs (h, inf);\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Return true if the dynamic symbol for a given section should be\n    omitted when creating a shared library.  */\n \n@@ -2640,7 +2613,8 @@ _bfd_sparc_elf_size_dynamic_sections (bfd *output_bfd,\n       /* If any dynamic relocs apply to a read-only section,\n \t then we need a DT_TEXTREL entry.  */\n       if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\telf_link_hash_traverse (&htab->elf,\n+\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n \n       if (info->flags & DF_TEXTREL)\n \t{"
    },
    {
      "sha": "9d8b42e1de0804fd93c7b33694a90f20438e6a70",
      "filename": "bfd/elfxx-tilegx.c",
      "status": "modified",
      "additions": 2,
      "deletions": 28,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfxx-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfxx-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-tilegx.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -2414,33 +2414,6 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *info_p)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) info_p;\n-\n-      info->flags |= DF_TEXTREL;\n-      info->callbacks->minfo\n-\t(_(\"%pB: dynamic relocation against `%pT' in read-only section `%pA'\\n\"),\n-\t sec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Return true if the dynamic symbol for a given section should be\n    omitted when creating a shared library.  */\n \n@@ -2681,7 +2654,8 @@ tilegx_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,\n       /* If any dynamic relocs apply to a read-only section,\n \t then we need a DT_TEXTREL entry.  */\n       if ((info->flags & DF_TEXTREL) == 0)\n-\telf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\telf_link_hash_traverse (&htab->elf,\n+\t\t\t\t_bfd_elf_maybe_set_textrel, info);\n \n       if (info->flags & DF_TEXTREL)\n \t{"
    },
    {
      "sha": "035b5c5c64c4207018accb279d7957064336700c",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 2,
      "deletions": 39,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=d49e5065ed43ec88627fd8cc6ab9e45fcc0e538a",
      "patch": "@@ -532,44 +532,6 @@ elf_x86_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n   return TRUE;\n }\n \n-/* Set DF_TEXTREL if we find any dynamic relocs that apply to\n-   read-only sections.  */\n-\n-static bfd_boolean\n-maybe_set_textrel (struct elf_link_hash_entry *h, void *inf)\n-{\n-  asection *sec;\n-\n-  if (h->root.type == bfd_link_hash_indirect)\n-    return TRUE;\n-\n-  /* Skip local IFUNC symbols. */\n-  if (h->forced_local && h->type == STT_GNU_IFUNC)\n-    return TRUE;\n-\n-  sec = _bfd_elf_readonly_dynrelocs (h);\n-  if (sec != NULL)\n-    {\n-      struct bfd_link_info *info = (struct bfd_link_info *) inf;\n-\n-      info->flags |= DF_TEXTREL;\n-      /* xgettext:c-format */\n-      info->callbacks->minfo (_(\"%pB: dynamic relocation against `%pT' \"\n-\t\t\t\t\"in read-only section `%pA'\\n\"),\n-\t\t\t      sec->owner, h->root.root.string, sec);\n-\n-      if (bfd_link_textrel_check (info))\n-\t/* xgettext:c-format */\n-\tinfo->callbacks->einfo (_(\"%P: %pB: warning: relocation against `%s' \"\n-\t\t\t\t  \"in read-only section `%pA'\\n\"),\n-\t\t\t\tsec->owner, h->root.root.string, sec);\n-\n-      /* Not an error, just cut short the traversal.  */\n-      return FALSE;\n-    }\n-  return TRUE;\n-}\n-\n /* Allocate space in .plt, .got and associated reloc sections for\n    local dynamic relocs.  */\n \n@@ -1450,7 +1412,8 @@ _bfd_x86_elf_size_dynamic_sections (bfd *output_bfd,\n \t  /* If any dynamic relocs apply to a read-only section,\n \t     then we need a DT_TEXTREL entry.  */\n \t  if ((info->flags & DF_TEXTREL) == 0)\n-\t    elf_link_hash_traverse (&htab->elf, maybe_set_textrel, info);\n+\t    elf_link_hash_traverse (&htab->elf,\n+\t\t\t\t    _bfd_elf_maybe_set_textrel, info);\n \n \t  if ((info->flags & DF_TEXTREL) != 0)\n \t    {"
    }
  ]
}