{
  "sha": "de93309a38afe2a7c0c519c8b69cca7c20d03fbc",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZGU5MzMwOWEzOGFmZTJhN2MwYzUxOWM4YjY5Y2NhN2MyMGQwM2ZiYw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2019-10-29T21:52:24Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2019-10-29T21:52:24Z"
    },
    "message": "Clean up ada-lang.h\n\nThis patch cleans up ada-lang.h:\n\n- Some functions just don't exist anymore, remove their declaration\n- Some functions are implemented in ada-lang.c and only used there, make\n  them static to that file.\n\nI moved some functions higher in the file to avoid having to\nforward-declare them, but the implementations are unchanged.\n\ngdb/ChangeLog:\n\n\t* ada-lang.h (GROW_VECT): Move to ada-lang.c.\n\t(grow_vect): Remove declaration.\n\t(ada_type_of_array): Remove declaration.\n\t(ada_update_initial_language): Remove declaration.\n\t(ada_fold_name): Remove declaration.\n\t(ada_fill_in_ada_prototype): Remove declaration.\n\t(user_select_syms): Remove declaration.\n\t(get_selections): Remove declaration.\n\t(ada_tag_type): Remove declaration.\n\t(ada_value_tag): Remove declaration.\n\t(ada_is_others_clause): Remove declaration.\n\t(ada_in_variant): Remove declaration.\n\t(ada_value_struct_elt): Remove declaration.\n\t(ada_attribute_name): Remove declaration.\n\t(ada_system_address_type): Remove declaration.\n\t* ada-lang.c (ada_watch_location_expression): Make static.\n\t(GROW_VECT): Move here from ada-lang.h.\n\t(grow_vect): Make static.\n\t(ada_update_initial_language): Make static.\n\t(ada_fold_name): Make static.\n\t(ada_type_of_array): Make static.\n\t(encoded_ordered_before): Move up.\n\t(sort_choices): Move up.\n\t(print_signatures): Move up.\n\t(ada_print_symbol_signature): Move up.\n\t(get_selections): Move up and make static.\n\t(user_select_syms): Move up and make static.\n\t(ada_value_struct_elt): Move up and make static.\n\t(ada_tag_type): Make static.\n\t(ada_value_tag): Make static.\n\t(ada_is_others_clause): Make static.\n\t(ada_in_variant): Make static.\n\t(ada_attribute_name): Make static.\n\nChange-Id: If0d46ba87d6585ab674c87244068a19e84718fc9",
    "tree": {
      "sha": "703af5d00ba9f13dc0f5f075b6be519f399a9b7f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/703af5d00ba9f13dc0f5f075b6be519f399a9b7f"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/de93309a38afe2a7c0c519c8b69cca7c20d03fbc",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/de93309a38afe2a7c0c519c8b69cca7c20d03fbc",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/de93309a38afe2a7c0c519c8b69cca7c20d03fbc",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/de93309a38afe2a7c0c519c8b69cca7c20d03fbc/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cdc46a9ff452788a97537114936fad1b142bc747",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cdc46a9ff452788a97537114936fad1b142bc747",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cdc46a9ff452788a97537114936fad1b142bc747"
    }
  ],
  "stats": {
    "total": 1930,
    "additions": 969,
    "deletions": 961
  },
  "files": [
    {
      "sha": "8c12df0ba50548b2d81eefe520bec0eddc49f8b4",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 36,
      "deletions": 0,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/de93309a38afe2a7c0c519c8b69cca7c20d03fbc/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/de93309a38afe2a7c0c519c8b69cca7c20d03fbc/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=de93309a38afe2a7c0c519c8b69cca7c20d03fbc",
      "patch": "@@ -1,3 +1,39 @@\n+2019-10-29  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* ada-lang.h (GROW_VECT): Move to ada-lang.c.\n+\t(grow_vect): Remove declaration.\n+\t(ada_type_of_array): Remove declaration.\n+\t(ada_update_initial_language): Remove declaration.\n+\t(ada_fold_name): Remove declaration.\n+\t(ada_fill_in_ada_prototype): Remove declaration.\n+\t(user_select_syms): Remove declaration.\n+\t(get_selections): Remove declaration.\n+\t(ada_tag_type): Remove declaration.\n+\t(ada_value_tag): Remove declaration.\n+\t(ada_is_others_clause): Remove declaration.\n+\t(ada_in_variant): Remove declaration.\n+\t(ada_value_struct_elt): Remove declaration.\n+\t(ada_attribute_name): Remove declaration.\n+\t(ada_system_address_type): Remove declaration.\n+\t* ada-lang.c (ada_watch_location_expression): Make static.\n+\t(GROW_VECT): Move here from ada-lang.h.\n+\t(grow_vect): Make static.\n+\t(ada_update_initial_language): Make static.\n+\t(ada_fold_name): Make static.\n+\t(ada_type_of_array): Make static.\n+\t(encoded_ordered_before): Move up.\n+\t(sort_choices): Move up.\n+\t(print_signatures): Move up.\n+\t(ada_print_symbol_signature): Move up.\n+\t(get_selections): Move up and make static.\n+\t(user_select_syms): Move up and make static.\n+\t(ada_value_struct_elt): Move up and make static.\n+\t(ada_tag_type): Make static.\n+\t(ada_value_tag): Make static.\n+\t(ada_is_others_clause): Make static.\n+\t(ada_in_variant): Make static.\n+\t(ada_attribute_name): Make static.\n+\n 2019-10-29  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* ada-lang.c: Remove includes."
    },
    {
      "sha": "73704907136766789c575c564c38d365293c2182",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 933,
      "deletions": 927,
      "changes": 1860,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/de93309a38afe2a7c0c519c8b69cca7c20d03fbc/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/de93309a38afe2a7c0c519c8b69cca7c20d03fbc/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=de93309a38afe2a7c0c519c8b69cca7c20d03fbc",
      "patch": "@@ -527,7 +527,7 @@ ada_print_array_index (struct value *index_value, struct ui_file *stream,\n \n /* la_watch_location_expression for Ada.  */\n \n-gdb::unique_xmalloc_ptr<char>\n+static gdb::unique_xmalloc_ptr<char>\n ada_watch_location_expression (struct type *type, CORE_ADDR addr)\n {\n   type = check_typedef (TYPE_TARGET_TYPE (check_typedef (type)));\n@@ -536,11 +536,17 @@ ada_watch_location_expression (struct type *type, CORE_ADDR addr)\n     (xstrprintf (\"{%s} %s\", name.c_str (), core_addr_to_string (addr)));\n }\n \n+/* Assuming V points to an array of S objects,  make sure that it contains at\n+   least M objects, updating V and S as necessary.  */\n+\n+#define GROW_VECT(v, s, m)                                    \\\n+   if ((s) < (m)) (v) = (char *) grow_vect (v, &(s), m, sizeof *(v));\n+\n /* Assuming VECT points to an array of *SIZE objects of size\n    ELEMENT_SIZE, grow it to contain at least MIN_SIZE objects,\n    updating *SIZE as necessary and returning the (new) array.  */\n \n-void *\n+static void *\n grow_vect (void *vect, size_t *size, size_t min_size, int element_size)\n {\n   if (*size < min_size)\n@@ -862,7 +868,7 @@ ada_get_decoded_type (struct type *type)\n /* If the main program is in Ada, return language_ada, otherwise return LANG\n    (the main program is in Ada iif the adainit symbol is found).  */\n \n-enum language\n+static enum language\n ada_update_initial_language (enum language lang)\n {\n   if (lookup_minimal_symbol (\"adainit\", NULL, NULL).minsym != NULL)\n@@ -1009,7 +1015,7 @@ ada_encode (const char *decoded)\n    quotes, unfolded, but with the quotes stripped away.  Result good\n    to next call.  */\n \n-char *\n+static char *\n ada_fold_name (const char *name)\n {\n   static char *fold_buffer = NULL;\n@@ -1910,7 +1916,8 @@ ada_is_bogus_array_descriptor (struct type *type)\n    the ARR denotes a null array descriptor and BOUNDS is non-zero,\n    returns NULL.  The result is simply the type of ARR if ARR is not\n    a descriptor.  */\n-struct type *\n+\n+static struct type *\n ada_type_of_array (struct value *arr, int bounds)\n {\n   if (ada_is_constrained_packed_array_type (value_type (arr)))\n@@ -3140,889 +3147,888 @@ ada_decoded_op_name (enum exp_opcode op)\n   error (_(\"Could not find operator name for opcode\"));\n }\n \n+/* Returns true (non-zero) iff decoded name N0 should appear before N1\n+   in a listing of choices during disambiguation (see sort_choices, below).\n+   The idea is that overloadings of a subprogram name from the\n+   same package should sort in their source order.  We settle for ordering\n+   such symbols by their trailing number (__N  or $N).  */\n \n-/* Same as evaluate_type (*EXP), but resolves ambiguous symbol\n-   references (marked by OP_VAR_VALUE nodes in which the symbol has an\n-   undefined namespace) and converts operators that are\n-   user-defined into appropriate function calls.  If CONTEXT_TYPE is\n-   non-null, it provides a preferred result type [at the moment, only\n-   type void has any effect---causing procedures to be preferred over\n-   functions in calls].  A null CONTEXT_TYPE indicates that a non-void\n-   return type is preferred.  May change (expand) *EXP.  */\n-\n-static void\n-resolve (expression_up *expp, int void_context_p, int parse_completion,\n-\t innermost_block_tracker *tracker)\n+static int\n+encoded_ordered_before (const char *N0, const char *N1)\n {\n-  struct type *context_type = NULL;\n-  int pc = 0;\n+  if (N1 == NULL)\n+    return 0;\n+  else if (N0 == NULL)\n+    return 1;\n+  else\n+    {\n+      int k0, k1;\n \n-  if (void_context_p)\n-    context_type = builtin_type ((*expp)->gdbarch)->builtin_void;\n+      for (k0 = strlen (N0) - 1; k0 > 0 && isdigit (N0[k0]); k0 -= 1)\n+        ;\n+      for (k1 = strlen (N1) - 1; k1 > 0 && isdigit (N1[k1]); k1 -= 1)\n+        ;\n+      if ((N0[k0] == '_' || N0[k0] == '$') && N0[k0 + 1] != '\\000'\n+          && (N1[k1] == '_' || N1[k1] == '$') && N1[k1 + 1] != '\\000')\n+        {\n+          int n0, n1;\n \n-  resolve_subexp (expp, &pc, 1, context_type, parse_completion, tracker);\n+          n0 = k0;\n+          while (N0[n0] == '_' && n0 > 0 && N0[n0 - 1] == '_')\n+            n0 -= 1;\n+          n1 = k1;\n+          while (N1[n1] == '_' && n1 > 0 && N1[n1 - 1] == '_')\n+            n1 -= 1;\n+          if (n0 == n1 && strncmp (N0, N1, n0) == 0)\n+            return (atoi (N0 + k0 + 1) < atoi (N1 + k1 + 1));\n+        }\n+      return (strcmp (N0, N1) < 0);\n+    }\n }\n \n-/* Resolve the operator of the subexpression beginning at\n-   position *POS of *EXPP.  \"Resolving\" consists of replacing\n-   the symbols that have undefined namespaces in OP_VAR_VALUE nodes\n-   with their resolutions, replacing built-in operators with\n-   function calls to user-defined operators, where appropriate, and,\n-   when DEPROCEDURE_P is non-zero, converting function-valued variables\n-   into parameterless calls.  May expand *EXPP.  The CONTEXT_TYPE functions\n-   are as in ada_resolve, above.  */\n+/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by the\n+   encoded names.  */\n \n-static struct value *\n-resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n-                struct type *context_type, int parse_completion,\n-\t\tinnermost_block_tracker *tracker)\n+static void\n+sort_choices (struct block_symbol syms[], int nsyms)\n {\n-  int pc = *pos;\n   int i;\n-  struct expression *exp;       /* Convenience: == *expp.  */\n-  enum exp_opcode op = (*expp)->elts[pc].opcode;\n-  struct value **argvec;        /* Vector of operand types (alloca'ed).  */\n-  int nargs;                    /* Number of operands.  */\n-  int oplen;\n \n-  argvec = NULL;\n-  nargs = 0;\n-  exp = expp->get ();\n-\n-  /* Pass one: resolve operands, saving their types and updating *pos,\n-     if needed.  */\n-  switch (op)\n+  for (i = 1; i < nsyms; i += 1)\n     {\n-    case OP_FUNCALL:\n-      if (exp->elts[pc + 3].opcode == OP_VAR_VALUE\n-          && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n-        *pos += 7;\n-      else\n+      struct block_symbol sym = syms[i];\n+      int j;\n+\n+      for (j = i - 1; j >= 0; j -= 1)\n         {\n-          *pos += 3;\n-          resolve_subexp (expp, pos, 0, NULL, parse_completion, tracker);\n+          if (encoded_ordered_before (SYMBOL_LINKAGE_NAME (syms[j].symbol),\n+                                      SYMBOL_LINKAGE_NAME (sym.symbol)))\n+            break;\n+          syms[j + 1] = syms[j];\n         }\n-      nargs = longest_to_int (exp->elts[pc + 1].longconst);\n-      break;\n+      syms[j + 1] = sym;\n+    }\n+}\n \n-    case UNOP_ADDR:\n-      *pos += 1;\n-      resolve_subexp (expp, pos, 0, NULL, parse_completion, tracker);\n-      break;\n+/* Whether GDB should display formals and return types for functions in the\n+   overloads selection menu.  */\n+static bool print_signatures = true;\n \n-    case UNOP_QUAL:\n-      *pos += 3;\n-      resolve_subexp (expp, pos, 1, check_typedef (exp->elts[pc + 1].type),\n-\t\t      parse_completion, tracker);\n-      break;\n+/* Print the signature for SYM on STREAM according to the FLAGS options.  For\n+   all but functions, the signature is just the name of the symbol.  For\n+   functions, this is the name of the function, the list of types for formals\n+   and the return type (if any).  */\n \n-    case OP_ATR_MODULUS:\n-    case OP_ATR_SIZE:\n-    case OP_ATR_TAG:\n-    case OP_ATR_FIRST:\n-    case OP_ATR_LAST:\n-    case OP_ATR_LENGTH:\n-    case OP_ATR_POS:\n-    case OP_ATR_VAL:\n-    case OP_ATR_MIN:\n-    case OP_ATR_MAX:\n-    case TERNOP_IN_RANGE:\n-    case BINOP_IN_BOUNDS:\n-    case UNOP_IN_RANGE:\n-    case OP_AGGREGATE:\n-    case OP_OTHERS:\n-    case OP_CHOICES:\n-    case OP_POSITIONAL:\n-    case OP_DISCRETE_RANGE:\n-    case OP_NAME:\n-      ada_forward_operator_length (exp, pc, &oplen, &nargs);\n-      *pos += oplen;\n-      break;\n+static void\n+ada_print_symbol_signature (struct ui_file *stream, struct symbol *sym,\n+\t\t\t    const struct type_print_options *flags)\n+{\n+  struct type *type = SYMBOL_TYPE (sym);\n \n-    case BINOP_ASSIGN:\n-      {\n-        struct value *arg1;\n+  fprintf_filtered (stream, \"%s\", SYMBOL_PRINT_NAME (sym));\n+  if (!print_signatures\n+      || type == NULL\n+      || TYPE_CODE (type) != TYPE_CODE_FUNC)\n+    return;\n \n-        *pos += 1;\n-        arg1 = resolve_subexp (expp, pos, 0, NULL, parse_completion, tracker);\n-        if (arg1 == NULL)\n-          resolve_subexp (expp, pos, 1, NULL, parse_completion, tracker);\n-        else\n-          resolve_subexp (expp, pos, 1, value_type (arg1), parse_completion,\n-\t\t\t  tracker);\n-        break;\n-      }\n+  if (TYPE_NFIELDS (type) > 0)\n+    {\n+      int i;\n \n-    case UNOP_CAST:\n-      *pos += 3;\n-      nargs = 1;\n-      break;\n+      fprintf_filtered (stream, \" (\");\n+      for (i = 0; i < TYPE_NFIELDS (type); ++i)\n+\t{\n+\t  if (i > 0)\n+\t    fprintf_filtered (stream, \"; \");\n+\t  ada_print_type (TYPE_FIELD_TYPE (type, i), NULL, stream, -1, 0,\n+\t\t\t  flags);\n+\t}\n+      fprintf_filtered (stream, \")\");\n+    }\n+  if (TYPE_TARGET_TYPE (type) != NULL\n+      && TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n+    {\n+      fprintf_filtered (stream, \" return \");\n+      ada_print_type (TYPE_TARGET_TYPE (type), NULL, stream, -1, 0, flags);\n+    }\n+}\n \n-    case BINOP_ADD:\n-    case BINOP_SUB:\n-    case BINOP_MUL:\n-    case BINOP_DIV:\n-    case BINOP_REM:\n-    case BINOP_MOD:\n-    case BINOP_EXP:\n-    case BINOP_CONCAT:\n-    case BINOP_LOGICAL_AND:\n-    case BINOP_LOGICAL_OR:\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n+/* Read and validate a set of numeric choices from the user in the\n+   range 0 .. N_CHOICES-1.  Place the results in increasing\n+   order in CHOICES[0 .. N-1], and return N.\n \n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-    case BINOP_LESS:\n-    case BINOP_GTR:\n-    case BINOP_LEQ:\n-    case BINOP_GEQ:\n+   The user types choices as a sequence of numbers on one line\n+   separated by blanks, encoding them as follows:\n \n-    case BINOP_REPEAT:\n-    case BINOP_SUBSCRIPT:\n-    case BINOP_COMMA:\n-      *pos += 1;\n-      nargs = 2;\n-      break;\n+     + A choice of 0 means to cancel the selection, throwing an error.\n+     + If IS_ALL_CHOICE, a choice of 1 selects the entire set 0 .. N_CHOICES-1.\n+     + The user chooses k by typing k+IS_ALL_CHOICE+1.\n \n-    case UNOP_NEG:\n-    case UNOP_PLUS:\n-    case UNOP_LOGICAL_NOT:\n-    case UNOP_ABS:\n-    case UNOP_IND:\n-      *pos += 1;\n-      nargs = 1;\n-      break;\n+   The user is not allowed to choose more than MAX_RESULTS values.\n \n-    case OP_LONG:\n-    case OP_FLOAT:\n-    case OP_VAR_VALUE:\n-    case OP_VAR_MSYM_VALUE:\n-      *pos += 4;\n-      break;\n+   ANNOTATION_SUFFIX, if present, is used to annotate the input\n+   prompts (for use with the -f switch).  */\n \n-    case OP_TYPE:\n-    case OP_BOOL:\n-    case OP_LAST:\n-    case OP_INTERNALVAR:\n-      *pos += 3;\n-      break;\n+static int\n+get_selections (int *choices, int n_choices, int max_results,\n+                int is_all_choice, const char *annotation_suffix)\n+{\n+  char *args;\n+  const char *prompt;\n+  int n_chosen;\n+  int first_choice = is_all_choice ? 2 : 1;\n \n-    case UNOP_MEMVAL:\n-      *pos += 3;\n-      nargs = 1;\n-      break;\n-\n-    case OP_REGISTER:\n-      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);\n-      break;\n-\n-    case STRUCTOP_STRUCT:\n-      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);\n-      nargs = 1;\n-      break;\n-\n-    case TERNOP_SLICE:\n-      *pos += 1;\n-      nargs = 3;\n-      break;\n+  prompt = getenv (\"PS2\");\n+  if (prompt == NULL)\n+    prompt = \"> \";\n \n-    case OP_STRING:\n-      break;\n+  args = command_line_input (prompt, annotation_suffix);\n \n-    default:\n-      error (_(\"Unexpected operator during name resolution\"));\n-    }\n+  if (args == NULL)\n+    error_no_arg (_(\"one or more choice numbers\"));\n \n-  argvec = XALLOCAVEC (struct value *, nargs + 1);\n-  for (i = 0; i < nargs; i += 1)\n-    argvec[i] = resolve_subexp (expp, pos, 1, NULL, parse_completion,\n-\t\t\t\ttracker);\n-  argvec[i] = NULL;\n-  exp = expp->get ();\n+  n_chosen = 0;\n \n-  /* Pass two: perform any resolution on principal operator.  */\n-  switch (op)\n+  /* Set choices[0 .. n_chosen-1] to the users' choices in ascending\n+     order, as given in args.  Choices are validated.  */\n+  while (1)\n     {\n-    default:\n-      break;\n-\n-    case OP_VAR_VALUE:\n-      if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)\n-        {\n-          std::vector<struct block_symbol> candidates;\n-          int n_candidates;\n+      char *args2;\n+      int choice, j;\n \n-          n_candidates =\n-            ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME\n-                                    (exp->elts[pc + 2].symbol),\n-                                    exp->elts[pc + 1].block, VAR_DOMAIN,\n-                                    &candidates);\n+      args = skip_spaces (args);\n+      if (*args == '\\0' && n_chosen == 0)\n+        error_no_arg (_(\"one or more choice numbers\"));\n+      else if (*args == '\\0')\n+        break;\n \n-          if (n_candidates > 1)\n-            {\n-              /* Types tend to get re-introduced locally, so if there\n-                 are any local symbols that are not types, first filter\n-                 out all types.  */\n-              int j;\n-              for (j = 0; j < n_candidates; j += 1)\n-                switch (SYMBOL_CLASS (candidates[j].symbol))\n-                  {\n-                  case LOC_REGISTER:\n-                  case LOC_ARG:\n-                  case LOC_REF_ARG:\n-                  case LOC_REGPARM_ADDR:\n-                  case LOC_LOCAL:\n-                  case LOC_COMPUTED:\n-                    goto FoundNonType;\n-                  default:\n-                    break;\n-                  }\n-            FoundNonType:\n-              if (j < n_candidates)\n-                {\n-                  j = 0;\n-                  while (j < n_candidates)\n-                    {\n-                      if (SYMBOL_CLASS (candidates[j].symbol) == LOC_TYPEDEF)\n-                        {\n-                          candidates[j] = candidates[n_candidates - 1];\n-                          n_candidates -= 1;\n-                        }\n-                      else\n-                        j += 1;\n-                    }\n-                }\n-            }\n+      choice = strtol (args, &args2, 10);\n+      if (args == args2 || choice < 0\n+          || choice > n_choices + first_choice - 1)\n+        error (_(\"Argument must be choice number\"));\n+      args = args2;\n \n-          if (n_candidates == 0)\n-            error (_(\"No definition found for %s\"),\n-                   SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n-          else if (n_candidates == 1)\n-            i = 0;\n-          else if (deprocedure_p\n-                   && !is_nonfunction (candidates.data (), n_candidates))\n-            {\n-              i = ada_resolve_function\n-                (candidates.data (), n_candidates, NULL, 0,\n-                 SYMBOL_LINKAGE_NAME (exp->elts[pc + 2].symbol),\n-                 context_type, parse_completion);\n-              if (i < 0)\n-                error (_(\"Could not find a match for %s\"),\n-                       SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n-            }\n-          else\n-            {\n-              printf_filtered (_(\"Multiple matches for %s\\n\"),\n-                               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n-              user_select_syms (candidates.data (), n_candidates, 1);\n-              i = 0;\n-            }\n+      if (choice == 0)\n+        error (_(\"cancelled\"));\n \n-          exp->elts[pc + 1].block = candidates[i].block;\n-          exp->elts[pc + 2].symbol = candidates[i].symbol;\n-\t  tracker->update (candidates[i]);\n+      if (choice < first_choice)\n+        {\n+          n_chosen = n_choices;\n+          for (j = 0; j < n_choices; j += 1)\n+            choices[j] = j;\n+          break;\n         }\n+      choice -= first_choice;\n \n-      if (deprocedure_p\n-          && (TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol))\n-              == TYPE_CODE_FUNC))\n+      for (j = n_chosen - 1; j >= 0 && choice < choices[j]; j -= 1)\n         {\n-          replace_operator_with_call (expp, pc, 0, 4,\n-                                      exp->elts[pc + 2].symbol,\n-                                      exp->elts[pc + 1].block);\n-          exp = expp->get ();\n         }\n-      break;\n-\n-    case OP_FUNCALL:\n-      {\n-        if (exp->elts[pc + 3].opcode == OP_VAR_VALUE\n-            && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n-          {\n-\t    std::vector<struct block_symbol> candidates;\n-            int n_candidates;\n-\n-            n_candidates =\n-              ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME\n-                                      (exp->elts[pc + 5].symbol),\n-                                      exp->elts[pc + 4].block, VAR_DOMAIN,\n-                                      &candidates);\n-\n-            if (n_candidates == 1)\n-              i = 0;\n-            else\n-              {\n-                i = ada_resolve_function\n-                  (candidates.data (), n_candidates,\n-                   argvec, nargs,\n-                   SYMBOL_LINKAGE_NAME (exp->elts[pc + 5].symbol),\n-                   context_type, parse_completion);\n-                if (i < 0)\n-                  error (_(\"Could not find a match for %s\"),\n-                         SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));\n-              }\n \n-            exp->elts[pc + 4].block = candidates[i].block;\n-            exp->elts[pc + 5].symbol = candidates[i].symbol;\n-\t    tracker->update (candidates[i]);\n-          }\n-      }\n-      break;\n-    case BINOP_ADD:\n-    case BINOP_SUB:\n-    case BINOP_MUL:\n-    case BINOP_DIV:\n-    case BINOP_REM:\n-    case BINOP_MOD:\n-    case BINOP_CONCAT:\n-    case BINOP_BITWISE_AND:\n-    case BINOP_BITWISE_IOR:\n-    case BINOP_BITWISE_XOR:\n-    case BINOP_EQUAL:\n-    case BINOP_NOTEQUAL:\n-    case BINOP_LESS:\n-    case BINOP_GTR:\n-    case BINOP_LEQ:\n-    case BINOP_GEQ:\n-    case BINOP_EXP:\n-    case UNOP_NEG:\n-    case UNOP_PLUS:\n-    case UNOP_LOGICAL_NOT:\n-    case UNOP_ABS:\n-      if (possible_user_operator_p (op, argvec))\n+      if (j < 0 || choice != choices[j])\n         {\n-\t  std::vector<struct block_symbol> candidates;\n-          int n_candidates;\n-\n-          n_candidates =\n-            ada_lookup_symbol_list (ada_decoded_op_name (op),\n-\t\t\t\t    NULL, VAR_DOMAIN,\n-                                    &candidates);\n-\n-          i = ada_resolve_function (candidates.data (), n_candidates, argvec,\n-\t\t\t\t    nargs, ada_decoded_op_name (op), NULL,\n-\t\t\t\t    parse_completion);\n-          if (i < 0)\n-            break;\n+          int k;\n \n-\t  replace_operator_with_call (expp, pc, nargs, 1,\n-\t\t\t\t      candidates[i].symbol,\n-\t\t\t\t      candidates[i].block);\n-          exp = expp->get ();\n+          for (k = n_chosen - 1; k > j; k -= 1)\n+            choices[k + 1] = choices[k];\n+          choices[j + 1] = choice;\n+          n_chosen += 1;\n         }\n-      break;\n-\n-    case OP_TYPE:\n-    case OP_REGISTER:\n-      return NULL;\n     }\n \n-  *pos = pc;\n-  if (exp->elts[pc].opcode == OP_VAR_MSYM_VALUE)\n-    return evaluate_var_msym_value (EVAL_AVOID_SIDE_EFFECTS,\n-\t\t\t\t    exp->elts[pc + 1].objfile,\n-\t\t\t\t    exp->elts[pc + 2].msymbol);\n-  else\n-    return evaluate_subexp_type (exp, pos);\n+  if (n_chosen > max_results)\n+    error (_(\"Select no more than %d of the above\"), max_results);\n+\n+  return n_chosen;\n }\n \n-/* Return non-zero if formal type FTYPE matches actual type ATYPE.  If\n-   MAY_DEREF is non-zero, the formal may be a pointer and the actual\n-   a non-pointer.  */\n-/* The term \"match\" here is rather loose.  The match is heuristic and\n-   liberal.  */\n+/* Given a list of NSYMS symbols in SYMS, select up to MAX_RESULTS>0\n+   by asking the user (if necessary), returning the number selected,\n+   and setting the first elements of SYMS items.  Error if no symbols\n+   selected.  */\n+\n+/* NOTE: Adapted from decode_line_2 in symtab.c, with which it ought\n+   to be re-integrated one of these days.  */\n \n static int\n-ada_type_match (struct type *ftype, struct type *atype, int may_deref)\n+user_select_syms (struct block_symbol *syms, int nsyms, int max_results)\n {\n-  ftype = ada_check_typedef (ftype);\n-  atype = ada_check_typedef (atype);\n-\n-  if (TYPE_CODE (ftype) == TYPE_CODE_REF)\n-    ftype = TYPE_TARGET_TYPE (ftype);\n-  if (TYPE_CODE (atype) == TYPE_CODE_REF)\n-    atype = TYPE_TARGET_TYPE (atype);\n-\n-  switch (TYPE_CODE (ftype))\n-    {\n-    default:\n-      return TYPE_CODE (ftype) == TYPE_CODE (atype);\n-    case TYPE_CODE_PTR:\n-      if (TYPE_CODE (atype) == TYPE_CODE_PTR)\n-        return ada_type_match (TYPE_TARGET_TYPE (ftype),\n-                               TYPE_TARGET_TYPE (atype), 0);\n-      else\n-        return (may_deref\n-                && ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));\n-    case TYPE_CODE_INT:\n-    case TYPE_CODE_ENUM:\n-    case TYPE_CODE_RANGE:\n-      switch (TYPE_CODE (atype))\n-        {\n-        case TYPE_CODE_INT:\n-        case TYPE_CODE_ENUM:\n-        case TYPE_CODE_RANGE:\n-          return 1;\n-        default:\n-          return 0;\n-        }\n+  int i;\n+  int *chosen = XALLOCAVEC (int , nsyms);\n+  int n_chosen;\n+  int first_choice = (max_results == 1) ? 1 : 2;\n+  const char *select_mode = multiple_symbols_select_mode ();\n \n-    case TYPE_CODE_ARRAY:\n-      return (TYPE_CODE (atype) == TYPE_CODE_ARRAY\n-              || ada_is_array_descriptor_type (atype));\n+  if (max_results < 1)\n+    error (_(\"Request to select 0 symbols!\"));\n+  if (nsyms <= 1)\n+    return nsyms;\n \n-    case TYPE_CODE_STRUCT:\n-      if (ada_is_array_descriptor_type (ftype))\n-        return (TYPE_CODE (atype) == TYPE_CODE_ARRAY\n-                || ada_is_array_descriptor_type (atype));\n-      else\n-        return (TYPE_CODE (atype) == TYPE_CODE_STRUCT\n-                && !ada_is_array_descriptor_type (atype));\n+  if (select_mode == multiple_symbols_cancel)\n+    error (_(\"\\\n+canceled because the command is ambiguous\\n\\\n+See set/show multiple-symbol.\"));\n \n-    case TYPE_CODE_UNION:\n-    case TYPE_CODE_FLT:\n-      return (TYPE_CODE (atype) == TYPE_CODE (ftype));\n-    }\n-}\n+  /* If select_mode is \"all\", then return all possible symbols.\n+     Only do that if more than one symbol can be selected, of course.\n+     Otherwise, display the menu as usual.  */\n+  if (select_mode == multiple_symbols_all && max_results > 1)\n+    return nsyms;\n \n-/* Return non-zero if the formals of FUNC \"sufficiently match\" the\n-   vector of actual argument types ACTUALS of size N_ACTUALS.  FUNC\n-   may also be an enumeral, in which case it is treated as a 0-\n-   argument function.  */\n+  printf_filtered (_(\"[0] cancel\\n\"));\n+  if (max_results > 1)\n+    printf_filtered (_(\"[1] all\\n\"));\n \n-static int\n-ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)\n-{\n-  int i;\n-  struct type *func_type = SYMBOL_TYPE (func);\n+  sort_choices (syms, nsyms);\n \n-  if (SYMBOL_CLASS (func) == LOC_CONST\n-      && TYPE_CODE (func_type) == TYPE_CODE_ENUM)\n-    return (n_actuals == 0);\n-  else if (func_type == NULL || TYPE_CODE (func_type) != TYPE_CODE_FUNC)\n-    return 0;\n+  for (i = 0; i < nsyms; i += 1)\n+    {\n+      if (syms[i].symbol == NULL)\n+        continue;\n \n-  if (TYPE_NFIELDS (func_type) != n_actuals)\n-    return 0;\n+      if (SYMBOL_CLASS (syms[i].symbol) == LOC_BLOCK)\n+        {\n+          struct symtab_and_line sal =\n+            find_function_start_sal (syms[i].symbol, 1);\n \n-  for (i = 0; i < n_actuals; i += 1)\n-    {\n-      if (actuals[i] == NULL)\n-        return 0;\n+\t  printf_filtered (\"[%d] \", i + first_choice);\n+\t  ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n+\t\t\t\t      &type_print_raw_options);\n+\t  if (sal.symtab == NULL)\n+\t    printf_filtered (_(\" at %p[<no source file available>%p]:%d\\n\"),\n+\t\t\t     metadata_style.style ().ptr (), nullptr, sal.line);\n+\t  else\n+\t    printf_filtered\n+\t      (_(\" at %ps:%d\\n\"),\n+\t       styled_string (file_name_style.style (),\n+\t\t\t      symtab_to_filename_for_display (sal.symtab)),\n+\t       sal.line);\n+          continue;\n+        }\n       else\n         {\n-          struct type *ftype = ada_check_typedef (TYPE_FIELD_TYPE (func_type,\n-\t\t\t\t\t\t\t\t   i));\n-          struct type *atype = ada_check_typedef (value_type (actuals[i]));\n+          int is_enumeral =\n+            (SYMBOL_CLASS (syms[i].symbol) == LOC_CONST\n+             && SYMBOL_TYPE (syms[i].symbol) != NULL\n+             && TYPE_CODE (SYMBOL_TYPE (syms[i].symbol)) == TYPE_CODE_ENUM);\n+\t  struct symtab *symtab = NULL;\n \n-          if (!ada_type_match (ftype, atype, 1))\n-            return 0;\n+\t  if (SYMBOL_OBJFILE_OWNED (syms[i].symbol))\n+\t    symtab = symbol_symtab (syms[i].symbol);\n+\n+          if (SYMBOL_LINE (syms[i].symbol) != 0 && symtab != NULL)\n+\t    {\n+\t      printf_filtered (\"[%d] \", i + first_choice);\n+\t      ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n+\t\t\t\t\t  &type_print_raw_options);\n+\t      printf_filtered (_(\" at %s:%d\\n\"),\n+\t\t\t       symtab_to_filename_for_display (symtab),\n+\t\t\t       SYMBOL_LINE (syms[i].symbol));\n+\t    }\n+          else if (is_enumeral\n+                   && TYPE_NAME (SYMBOL_TYPE (syms[i].symbol)) != NULL)\n+            {\n+              printf_filtered ((\"[%d] \"), i + first_choice);\n+              ada_print_type (SYMBOL_TYPE (syms[i].symbol), NULL,\n+                              gdb_stdout, -1, 0, &type_print_raw_options);\n+              printf_filtered (_(\"'(%s) (enumeral)\\n\"),\n+\t\t\t       SYMBOL_PRINT_NAME (syms[i].symbol));\n+            }\n+\t  else\n+\t    {\n+\t      printf_filtered (\"[%d] \", i + first_choice);\n+\t      ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n+\t\t\t\t\t  &type_print_raw_options);\n+\n+\t      if (symtab != NULL)\n+\t\tprintf_filtered (is_enumeral\n+\t\t\t\t ? _(\" in %s (enumeral)\\n\")\n+\t\t\t\t : _(\" at %s:?\\n\"),\n+\t\t\t\t symtab_to_filename_for_display (symtab));\n+\t      else\n+\t\tprintf_filtered (is_enumeral\n+\t\t\t\t ? _(\" (enumeral)\\n\")\n+\t\t\t\t : _(\" at ?\\n\"));\n+\t    }\n         }\n     }\n-  return 1;\n-}\n-\n-/* False iff function type FUNC_TYPE definitely does not produce a value\n-   compatible with type CONTEXT_TYPE.  Conservatively returns 1 if\n-   FUNC_TYPE is not a valid function type with a non-null return type\n-   or an enumerated type.  A null CONTEXT_TYPE indicates any non-void type.  */\n \n-static int\n-return_match (struct type *func_type, struct type *context_type)\n-{\n-  struct type *return_type;\n+  n_chosen = get_selections (chosen, nsyms, max_results, max_results > 1,\n+                             \"overload-choice\");\n \n-  if (func_type == NULL)\n-    return 1;\n+  for (i = 0; i < n_chosen; i += 1)\n+    syms[i] = syms[chosen[i]];\n \n-  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)\n-    return_type = get_base_type (TYPE_TARGET_TYPE (func_type));\n-  else\n-    return_type = get_base_type (func_type);\n-  if (return_type == NULL)\n-    return 1;\n+  return n_chosen;\n+}\n \n-  context_type = get_base_type (context_type);\n+/* Same as evaluate_type (*EXP), but resolves ambiguous symbol\n+   references (marked by OP_VAR_VALUE nodes in which the symbol has an\n+   undefined namespace) and converts operators that are\n+   user-defined into appropriate function calls.  If CONTEXT_TYPE is\n+   non-null, it provides a preferred result type [at the moment, only\n+   type void has any effect---causing procedures to be preferred over\n+   functions in calls].  A null CONTEXT_TYPE indicates that a non-void\n+   return type is preferred.  May change (expand) *EXP.  */\n \n-  if (TYPE_CODE (return_type) == TYPE_CODE_ENUM)\n-    return context_type == NULL || return_type == context_type;\n-  else if (context_type == NULL)\n-    return TYPE_CODE (return_type) != TYPE_CODE_VOID;\n-  else\n-    return TYPE_CODE (return_type) == TYPE_CODE (context_type);\n-}\n+static void\n+resolve (expression_up *expp, int void_context_p, int parse_completion,\n+\t innermost_block_tracker *tracker)\n+{\n+  struct type *context_type = NULL;\n+  int pc = 0;\n \n+  if (void_context_p)\n+    context_type = builtin_type ((*expp)->gdbarch)->builtin_void;\n \n-/* Returns the index in SYMS[0..NSYMS-1] that contains  the symbol for the\n-   function (if any) that matches the types of the NARGS arguments in\n-   ARGS.  If CONTEXT_TYPE is non-null and there is at least one match\n-   that returns that type, then eliminate matches that don't.  If\n-   CONTEXT_TYPE is void and there is at least one match that does not\n-   return void, eliminate all matches that do.\n+  resolve_subexp (expp, &pc, 1, context_type, parse_completion, tracker);\n+}\n \n-   Asks the user if there is more than one match remaining.  Returns -1\n-   if there is no such symbol or none is selected.  NAME is used\n-   solely for messages.  May re-arrange and modify SYMS in\n-   the process; the index returned is for the modified vector.  */\n+/* Resolve the operator of the subexpression beginning at\n+   position *POS of *EXPP.  \"Resolving\" consists of replacing\n+   the symbols that have undefined namespaces in OP_VAR_VALUE nodes\n+   with their resolutions, replacing built-in operators with\n+   function calls to user-defined operators, where appropriate, and,\n+   when DEPROCEDURE_P is non-zero, converting function-valued variables\n+   into parameterless calls.  May expand *EXPP.  The CONTEXT_TYPE functions\n+   are as in ada_resolve, above.  */\n \n-static int\n-ada_resolve_function (struct block_symbol syms[],\n-                      int nsyms, struct value **args, int nargs,\n-                      const char *name, struct type *context_type,\n-\t\t      int parse_completion)\n+static struct value *\n+resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n+                struct type *context_type, int parse_completion,\n+\t\tinnermost_block_tracker *tracker)\n {\n-  int fallback;\n-  int k;\n-  int m;                        /* Number of hits */\n+  int pc = *pos;\n+  int i;\n+  struct expression *exp;       /* Convenience: == *expp.  */\n+  enum exp_opcode op = (*expp)->elts[pc].opcode;\n+  struct value **argvec;        /* Vector of operand types (alloca'ed).  */\n+  int nargs;                    /* Number of operands.  */\n+  int oplen;\n \n-  m = 0;\n-  /* In the first pass of the loop, we only accept functions matching\n-     context_type.  If none are found, we add a second pass of the loop\n-     where every function is accepted.  */\n-  for (fallback = 0; m == 0 && fallback < 2; fallback++)\n-    {\n-      for (k = 0; k < nsyms; k += 1)\n-        {\n-          struct type *type = ada_check_typedef (SYMBOL_TYPE (syms[k].symbol));\n+  argvec = NULL;\n+  nargs = 0;\n+  exp = expp->get ();\n \n-          if (ada_args_match (syms[k].symbol, args, nargs)\n-              && (fallback || return_match (type, context_type)))\n-            {\n-              syms[m] = syms[k];\n-              m += 1;\n-            }\n+  /* Pass one: resolve operands, saving their types and updating *pos,\n+     if needed.  */\n+  switch (op)\n+    {\n+    case OP_FUNCALL:\n+      if (exp->elts[pc + 3].opcode == OP_VAR_VALUE\n+          && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n+        *pos += 7;\n+      else\n+        {\n+          *pos += 3;\n+          resolve_subexp (expp, pos, 0, NULL, parse_completion, tracker);\n         }\n-    }\n+      nargs = longest_to_int (exp->elts[pc + 1].longconst);\n+      break;\n \n-  /* If we got multiple matches, ask the user which one to use.  Don't do this\n-     interactive thing during completion, though, as the purpose of the\n-     completion is providing a list of all possible matches.  Prompting the\n-     user to filter it down would be completely unexpected in this case.  */\n-  if (m == 0)\n-    return -1;\n-  else if (m > 1 && !parse_completion)\n-    {\n-      printf_filtered (_(\"Multiple matches for %s\\n\"), name);\n-      user_select_syms (syms, m, 1);\n-      return 0;\n+    case UNOP_ADDR:\n+      *pos += 1;\n+      resolve_subexp (expp, pos, 0, NULL, parse_completion, tracker);\n+      break;\n+\n+    case UNOP_QUAL:\n+      *pos += 3;\n+      resolve_subexp (expp, pos, 1, check_typedef (exp->elts[pc + 1].type),\n+\t\t      parse_completion, tracker);\n+      break;\n+\n+    case OP_ATR_MODULUS:\n+    case OP_ATR_SIZE:\n+    case OP_ATR_TAG:\n+    case OP_ATR_FIRST:\n+    case OP_ATR_LAST:\n+    case OP_ATR_LENGTH:\n+    case OP_ATR_POS:\n+    case OP_ATR_VAL:\n+    case OP_ATR_MIN:\n+    case OP_ATR_MAX:\n+    case TERNOP_IN_RANGE:\n+    case BINOP_IN_BOUNDS:\n+    case UNOP_IN_RANGE:\n+    case OP_AGGREGATE:\n+    case OP_OTHERS:\n+    case OP_CHOICES:\n+    case OP_POSITIONAL:\n+    case OP_DISCRETE_RANGE:\n+    case OP_NAME:\n+      ada_forward_operator_length (exp, pc, &oplen, &nargs);\n+      *pos += oplen;\n+      break;\n+\n+    case BINOP_ASSIGN:\n+      {\n+        struct value *arg1;\n+\n+        *pos += 1;\n+        arg1 = resolve_subexp (expp, pos, 0, NULL, parse_completion, tracker);\n+        if (arg1 == NULL)\n+          resolve_subexp (expp, pos, 1, NULL, parse_completion, tracker);\n+        else\n+          resolve_subexp (expp, pos, 1, value_type (arg1), parse_completion,\n+\t\t\t  tracker);\n+        break;\n+      }\n+\n+    case UNOP_CAST:\n+      *pos += 3;\n+      nargs = 1;\n+      break;\n+\n+    case BINOP_ADD:\n+    case BINOP_SUB:\n+    case BINOP_MUL:\n+    case BINOP_DIV:\n+    case BINOP_REM:\n+    case BINOP_MOD:\n+    case BINOP_EXP:\n+    case BINOP_CONCAT:\n+    case BINOP_LOGICAL_AND:\n+    case BINOP_LOGICAL_OR:\n+    case BINOP_BITWISE_AND:\n+    case BINOP_BITWISE_IOR:\n+    case BINOP_BITWISE_XOR:\n+\n+    case BINOP_EQUAL:\n+    case BINOP_NOTEQUAL:\n+    case BINOP_LESS:\n+    case BINOP_GTR:\n+    case BINOP_LEQ:\n+    case BINOP_GEQ:\n+\n+    case BINOP_REPEAT:\n+    case BINOP_SUBSCRIPT:\n+    case BINOP_COMMA:\n+      *pos += 1;\n+      nargs = 2;\n+      break;\n+\n+    case UNOP_NEG:\n+    case UNOP_PLUS:\n+    case UNOP_LOGICAL_NOT:\n+    case UNOP_ABS:\n+    case UNOP_IND:\n+      *pos += 1;\n+      nargs = 1;\n+      break;\n+\n+    case OP_LONG:\n+    case OP_FLOAT:\n+    case OP_VAR_VALUE:\n+    case OP_VAR_MSYM_VALUE:\n+      *pos += 4;\n+      break;\n+\n+    case OP_TYPE:\n+    case OP_BOOL:\n+    case OP_LAST:\n+    case OP_INTERNALVAR:\n+      *pos += 3;\n+      break;\n+\n+    case UNOP_MEMVAL:\n+      *pos += 3;\n+      nargs = 1;\n+      break;\n+\n+    case OP_REGISTER:\n+      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);\n+      break;\n+\n+    case STRUCTOP_STRUCT:\n+      *pos += 4 + BYTES_TO_EXP_ELEM (exp->elts[pc + 1].longconst + 1);\n+      nargs = 1;\n+      break;\n+\n+    case TERNOP_SLICE:\n+      *pos += 1;\n+      nargs = 3;\n+      break;\n+\n+    case OP_STRING:\n+      break;\n+\n+    default:\n+      error (_(\"Unexpected operator during name resolution\"));\n     }\n-  return 0;\n-}\n \n-/* Returns true (non-zero) iff decoded name N0 should appear before N1\n-   in a listing of choices during disambiguation (see sort_choices, below).\n-   The idea is that overloadings of a subprogram name from the\n-   same package should sort in their source order.  We settle for ordering\n-   such symbols by their trailing number (__N  or $N).  */\n+  argvec = XALLOCAVEC (struct value *, nargs + 1);\n+  for (i = 0; i < nargs; i += 1)\n+    argvec[i] = resolve_subexp (expp, pos, 1, NULL, parse_completion,\n+\t\t\t\ttracker);\n+  argvec[i] = NULL;\n+  exp = expp->get ();\n \n-static int\n-encoded_ordered_before (const char *N0, const char *N1)\n-{\n-  if (N1 == NULL)\n-    return 0;\n-  else if (N0 == NULL)\n-    return 1;\n-  else\n+  /* Pass two: perform any resolution on principal operator.  */\n+  switch (op)\n     {\n-      int k0, k1;\n+    default:\n+      break;\n \n-      for (k0 = strlen (N0) - 1; k0 > 0 && isdigit (N0[k0]); k0 -= 1)\n-        ;\n-      for (k1 = strlen (N1) - 1; k1 > 0 && isdigit (N1[k1]); k1 -= 1)\n-        ;\n-      if ((N0[k0] == '_' || N0[k0] == '$') && N0[k0 + 1] != '\\000'\n-          && (N1[k1] == '_' || N1[k1] == '$') && N1[k1 + 1] != '\\000')\n+    case OP_VAR_VALUE:\n+      if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)\n         {\n-          int n0, n1;\n+          std::vector<struct block_symbol> candidates;\n+          int n_candidates;\n \n-          n0 = k0;\n-          while (N0[n0] == '_' && n0 > 0 && N0[n0 - 1] == '_')\n-            n0 -= 1;\n-          n1 = k1;\n-          while (N1[n1] == '_' && n1 > 0 && N1[n1 - 1] == '_')\n-            n1 -= 1;\n-          if (n0 == n1 && strncmp (N0, N1, n0) == 0)\n-            return (atoi (N0 + k0 + 1) < atoi (N1 + k1 + 1));\n-        }\n-      return (strcmp (N0, N1) < 0);\n-    }\n-}\n+          n_candidates =\n+            ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME\n+                                    (exp->elts[pc + 2].symbol),\n+                                    exp->elts[pc + 1].block, VAR_DOMAIN,\n+                                    &candidates);\n \n-/* Sort SYMS[0..NSYMS-1] to put the choices in a canonical order by the\n-   encoded names.  */\n+          if (n_candidates > 1)\n+            {\n+              /* Types tend to get re-introduced locally, so if there\n+                 are any local symbols that are not types, first filter\n+                 out all types.  */\n+              int j;\n+              for (j = 0; j < n_candidates; j += 1)\n+                switch (SYMBOL_CLASS (candidates[j].symbol))\n+                  {\n+                  case LOC_REGISTER:\n+                  case LOC_ARG:\n+                  case LOC_REF_ARG:\n+                  case LOC_REGPARM_ADDR:\n+                  case LOC_LOCAL:\n+                  case LOC_COMPUTED:\n+                    goto FoundNonType;\n+                  default:\n+                    break;\n+                  }\n+            FoundNonType:\n+              if (j < n_candidates)\n+                {\n+                  j = 0;\n+                  while (j < n_candidates)\n+                    {\n+                      if (SYMBOL_CLASS (candidates[j].symbol) == LOC_TYPEDEF)\n+                        {\n+                          candidates[j] = candidates[n_candidates - 1];\n+                          n_candidates -= 1;\n+                        }\n+                      else\n+                        j += 1;\n+                    }\n+                }\n+            }\n \n-static void\n-sort_choices (struct block_symbol syms[], int nsyms)\n-{\n-  int i;\n+          if (n_candidates == 0)\n+            error (_(\"No definition found for %s\"),\n+                   SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n+          else if (n_candidates == 1)\n+            i = 0;\n+          else if (deprocedure_p\n+                   && !is_nonfunction (candidates.data (), n_candidates))\n+            {\n+              i = ada_resolve_function\n+                (candidates.data (), n_candidates, NULL, 0,\n+                 SYMBOL_LINKAGE_NAME (exp->elts[pc + 2].symbol),\n+                 context_type, parse_completion);\n+              if (i < 0)\n+                error (_(\"Could not find a match for %s\"),\n+                       SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n+            }\n+          else\n+            {\n+              printf_filtered (_(\"Multiple matches for %s\\n\"),\n+                               SYMBOL_PRINT_NAME (exp->elts[pc + 2].symbol));\n+              user_select_syms (candidates.data (), n_candidates, 1);\n+              i = 0;\n+            }\n \n-  for (i = 1; i < nsyms; i += 1)\n-    {\n-      struct block_symbol sym = syms[i];\n-      int j;\n+          exp->elts[pc + 1].block = candidates[i].block;\n+          exp->elts[pc + 2].symbol = candidates[i].symbol;\n+\t  tracker->update (candidates[i]);\n+        }\n \n-      for (j = i - 1; j >= 0; j -= 1)\n+      if (deprocedure_p\n+          && (TYPE_CODE (SYMBOL_TYPE (exp->elts[pc + 2].symbol))\n+              == TYPE_CODE_FUNC))\n         {\n-          if (encoded_ordered_before (SYMBOL_LINKAGE_NAME (syms[j].symbol),\n-                                      SYMBOL_LINKAGE_NAME (sym.symbol)))\n-            break;\n-          syms[j + 1] = syms[j];\n+          replace_operator_with_call (expp, pc, 0, 4,\n+                                      exp->elts[pc + 2].symbol,\n+                                      exp->elts[pc + 1].block);\n+          exp = expp->get ();\n         }\n-      syms[j + 1] = sym;\n-    }\n-}\n+      break;\n+\n+    case OP_FUNCALL:\n+      {\n+        if (exp->elts[pc + 3].opcode == OP_VAR_VALUE\n+            && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n+          {\n+\t    std::vector<struct block_symbol> candidates;\n+            int n_candidates;\n+\n+            n_candidates =\n+              ada_lookup_symbol_list (SYMBOL_LINKAGE_NAME\n+                                      (exp->elts[pc + 5].symbol),\n+                                      exp->elts[pc + 4].block, VAR_DOMAIN,\n+                                      &candidates);\n \n-/* Whether GDB should display formals and return types for functions in the\n-   overloads selection menu.  */\n-static bool print_signatures = true;\n+            if (n_candidates == 1)\n+              i = 0;\n+            else\n+              {\n+                i = ada_resolve_function\n+                  (candidates.data (), n_candidates,\n+                   argvec, nargs,\n+                   SYMBOL_LINKAGE_NAME (exp->elts[pc + 5].symbol),\n+                   context_type, parse_completion);\n+                if (i < 0)\n+                  error (_(\"Could not find a match for %s\"),\n+                         SYMBOL_PRINT_NAME (exp->elts[pc + 5].symbol));\n+              }\n \n-/* Print the signature for SYM on STREAM according to the FLAGS options.  For\n-   all but functions, the signature is just the name of the symbol.  For\n-   functions, this is the name of the function, the list of types for formals\n-   and the return type (if any).  */\n+            exp->elts[pc + 4].block = candidates[i].block;\n+            exp->elts[pc + 5].symbol = candidates[i].symbol;\n+\t    tracker->update (candidates[i]);\n+          }\n+      }\n+      break;\n+    case BINOP_ADD:\n+    case BINOP_SUB:\n+    case BINOP_MUL:\n+    case BINOP_DIV:\n+    case BINOP_REM:\n+    case BINOP_MOD:\n+    case BINOP_CONCAT:\n+    case BINOP_BITWISE_AND:\n+    case BINOP_BITWISE_IOR:\n+    case BINOP_BITWISE_XOR:\n+    case BINOP_EQUAL:\n+    case BINOP_NOTEQUAL:\n+    case BINOP_LESS:\n+    case BINOP_GTR:\n+    case BINOP_LEQ:\n+    case BINOP_GEQ:\n+    case BINOP_EXP:\n+    case UNOP_NEG:\n+    case UNOP_PLUS:\n+    case UNOP_LOGICAL_NOT:\n+    case UNOP_ABS:\n+      if (possible_user_operator_p (op, argvec))\n+        {\n+\t  std::vector<struct block_symbol> candidates;\n+          int n_candidates;\n \n-static void\n-ada_print_symbol_signature (struct ui_file *stream, struct symbol *sym,\n-\t\t\t    const struct type_print_options *flags)\n-{\n-  struct type *type = SYMBOL_TYPE (sym);\n+          n_candidates =\n+            ada_lookup_symbol_list (ada_decoded_op_name (op),\n+\t\t\t\t    NULL, VAR_DOMAIN,\n+                                    &candidates);\n \n-  fprintf_filtered (stream, \"%s\", SYMBOL_PRINT_NAME (sym));\n-  if (!print_signatures\n-      || type == NULL\n-      || TYPE_CODE (type) != TYPE_CODE_FUNC)\n-    return;\n+          i = ada_resolve_function (candidates.data (), n_candidates, argvec,\n+\t\t\t\t    nargs, ada_decoded_op_name (op), NULL,\n+\t\t\t\t    parse_completion);\n+          if (i < 0)\n+            break;\n \n-  if (TYPE_NFIELDS (type) > 0)\n-    {\n-      int i;\n+\t  replace_operator_with_call (expp, pc, nargs, 1,\n+\t\t\t\t      candidates[i].symbol,\n+\t\t\t\t      candidates[i].block);\n+          exp = expp->get ();\n+        }\n+      break;\n \n-      fprintf_filtered (stream, \" (\");\n-      for (i = 0; i < TYPE_NFIELDS (type); ++i)\n-\t{\n-\t  if (i > 0)\n-\t    fprintf_filtered (stream, \"; \");\n-\t  ada_print_type (TYPE_FIELD_TYPE (type, i), NULL, stream, -1, 0,\n-\t\t\t  flags);\n-\t}\n-      fprintf_filtered (stream, \")\");\n-    }\n-  if (TYPE_TARGET_TYPE (type) != NULL\n-      && TYPE_CODE (TYPE_TARGET_TYPE (type)) != TYPE_CODE_VOID)\n-    {\n-      fprintf_filtered (stream, \" return \");\n-      ada_print_type (TYPE_TARGET_TYPE (type), NULL, stream, -1, 0, flags);\n+    case OP_TYPE:\n+    case OP_REGISTER:\n+      return NULL;\n     }\n-}\n \n-/* Given a list of NSYMS symbols in SYMS, select up to MAX_RESULTS>0 \n-   by asking the user (if necessary), returning the number selected, \n-   and setting the first elements of SYMS items.  Error if no symbols\n-   selected.  */\n+  *pos = pc;\n+  if (exp->elts[pc].opcode == OP_VAR_MSYM_VALUE)\n+    return evaluate_var_msym_value (EVAL_AVOID_SIDE_EFFECTS,\n+\t\t\t\t    exp->elts[pc + 1].objfile,\n+\t\t\t\t    exp->elts[pc + 2].msymbol);\n+  else\n+    return evaluate_subexp_type (exp, pos);\n+}\n \n-/* NOTE: Adapted from decode_line_2 in symtab.c, with which it ought\n-   to be re-integrated one of these days.  */\n+/* Return non-zero if formal type FTYPE matches actual type ATYPE.  If\n+   MAY_DEREF is non-zero, the formal may be a pointer and the actual\n+   a non-pointer.  */\n+/* The term \"match\" here is rather loose.  The match is heuristic and\n+   liberal.  */\n \n-int\n-user_select_syms (struct block_symbol *syms, int nsyms, int max_results)\n+static int\n+ada_type_match (struct type *ftype, struct type *atype, int may_deref)\n {\n-  int i;\n-  int *chosen = XALLOCAVEC (int , nsyms);\n-  int n_chosen;\n-  int first_choice = (max_results == 1) ? 1 : 2;\n-  const char *select_mode = multiple_symbols_select_mode ();\n-\n-  if (max_results < 1)\n-    error (_(\"Request to select 0 symbols!\"));\n-  if (nsyms <= 1)\n-    return nsyms;\n-\n-  if (select_mode == multiple_symbols_cancel)\n-    error (_(\"\\\n-canceled because the command is ambiguous\\n\\\n-See set/show multiple-symbol.\"));\n-\n-  /* If select_mode is \"all\", then return all possible symbols.\n-     Only do that if more than one symbol can be selected, of course.\n-     Otherwise, display the menu as usual.  */\n-  if (select_mode == multiple_symbols_all && max_results > 1)\n-    return nsyms;\n-\n-  printf_filtered (_(\"[0] cancel\\n\"));\n-  if (max_results > 1)\n-    printf_filtered (_(\"[1] all\\n\"));\n+  ftype = ada_check_typedef (ftype);\n+  atype = ada_check_typedef (atype);\n \n-  sort_choices (syms, nsyms);\n+  if (TYPE_CODE (ftype) == TYPE_CODE_REF)\n+    ftype = TYPE_TARGET_TYPE (ftype);\n+  if (TYPE_CODE (atype) == TYPE_CODE_REF)\n+    atype = TYPE_TARGET_TYPE (atype);\n \n-  for (i = 0; i < nsyms; i += 1)\n+  switch (TYPE_CODE (ftype))\n     {\n-      if (syms[i].symbol == NULL)\n-        continue;\n-\n-      if (SYMBOL_CLASS (syms[i].symbol) == LOC_BLOCK)\n-        {\n-          struct symtab_and_line sal =\n-            find_function_start_sal (syms[i].symbol, 1);\n-\n-\t  printf_filtered (\"[%d] \", i + first_choice);\n-\t  ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n-\t\t\t\t      &type_print_raw_options);\n-\t  if (sal.symtab == NULL)\n-\t    printf_filtered (_(\" at %p[<no source file available>%p]:%d\\n\"),\n-\t\t\t     metadata_style.style ().ptr (), nullptr, sal.line);\n-\t  else\n-\t    printf_filtered\n-\t      (_(\" at %ps:%d\\n\"),\n-\t       styled_string (file_name_style.style (),\n-\t\t\t      symtab_to_filename_for_display (sal.symtab)),\n-\t       sal.line);\n-          continue;\n-        }\n+    default:\n+      return TYPE_CODE (ftype) == TYPE_CODE (atype);\n+    case TYPE_CODE_PTR:\n+      if (TYPE_CODE (atype) == TYPE_CODE_PTR)\n+        return ada_type_match (TYPE_TARGET_TYPE (ftype),\n+                               TYPE_TARGET_TYPE (atype), 0);\n       else\n+        return (may_deref\n+                && ada_type_match (TYPE_TARGET_TYPE (ftype), atype, 0));\n+    case TYPE_CODE_INT:\n+    case TYPE_CODE_ENUM:\n+    case TYPE_CODE_RANGE:\n+      switch (TYPE_CODE (atype))\n         {\n-          int is_enumeral =\n-            (SYMBOL_CLASS (syms[i].symbol) == LOC_CONST\n-             && SYMBOL_TYPE (syms[i].symbol) != NULL\n-             && TYPE_CODE (SYMBOL_TYPE (syms[i].symbol)) == TYPE_CODE_ENUM);\n-\t  struct symtab *symtab = NULL;\n-\n-\t  if (SYMBOL_OBJFILE_OWNED (syms[i].symbol))\n-\t    symtab = symbol_symtab (syms[i].symbol);\n-\n-          if (SYMBOL_LINE (syms[i].symbol) != 0 && symtab != NULL)\n-\t    {\n-\t      printf_filtered (\"[%d] \", i + first_choice);\n-\t      ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n-\t\t\t\t\t  &type_print_raw_options);\n-\t      printf_filtered (_(\" at %s:%d\\n\"),\n-\t\t\t       symtab_to_filename_for_display (symtab),\n-\t\t\t       SYMBOL_LINE (syms[i].symbol));\n-\t    }\n-          else if (is_enumeral\n-                   && TYPE_NAME (SYMBOL_TYPE (syms[i].symbol)) != NULL)\n-            {\n-              printf_filtered ((\"[%d] \"), i + first_choice);\n-              ada_print_type (SYMBOL_TYPE (syms[i].symbol), NULL,\n-                              gdb_stdout, -1, 0, &type_print_raw_options);\n-              printf_filtered (_(\"'(%s) (enumeral)\\n\"),\n-\t\t\t       SYMBOL_PRINT_NAME (syms[i].symbol));\n-            }\n-\t  else\n-\t    {\n-\t      printf_filtered (\"[%d] \", i + first_choice);\n-\t      ada_print_symbol_signature (gdb_stdout, syms[i].symbol,\n-\t\t\t\t\t  &type_print_raw_options);\n-\n-\t      if (symtab != NULL)\n-\t\tprintf_filtered (is_enumeral\n-\t\t\t\t ? _(\" in %s (enumeral)\\n\")\n-\t\t\t\t : _(\" at %s:?\\n\"),\n-\t\t\t\t symtab_to_filename_for_display (symtab));\n-\t      else\n-\t\tprintf_filtered (is_enumeral\n-\t\t\t\t ? _(\" (enumeral)\\n\")\n-\t\t\t\t : _(\" at ?\\n\"));\n-\t    }\n+        case TYPE_CODE_INT:\n+        case TYPE_CODE_ENUM:\n+        case TYPE_CODE_RANGE:\n+          return 1;\n+        default:\n+          return 0;\n         }\n-    }\n \n-  n_chosen = get_selections (chosen, nsyms, max_results, max_results > 1,\n-                             \"overload-choice\");\n+    case TYPE_CODE_ARRAY:\n+      return (TYPE_CODE (atype) == TYPE_CODE_ARRAY\n+              || ada_is_array_descriptor_type (atype));\n \n-  for (i = 0; i < n_chosen; i += 1)\n-    syms[i] = syms[chosen[i]];\n+    case TYPE_CODE_STRUCT:\n+      if (ada_is_array_descriptor_type (ftype))\n+        return (TYPE_CODE (atype) == TYPE_CODE_ARRAY\n+                || ada_is_array_descriptor_type (atype));\n+      else\n+        return (TYPE_CODE (atype) == TYPE_CODE_STRUCT\n+                && !ada_is_array_descriptor_type (atype));\n \n-  return n_chosen;\n+    case TYPE_CODE_UNION:\n+    case TYPE_CODE_FLT:\n+      return (TYPE_CODE (atype) == TYPE_CODE (ftype));\n+    }\n }\n \n-/* Read and validate a set of numeric choices from the user in the\n-   range 0 .. N_CHOICES-1.  Place the results in increasing\n-   order in CHOICES[0 .. N-1], and return N.\n+/* Return non-zero if the formals of FUNC \"sufficiently match\" the\n+   vector of actual argument types ACTUALS of size N_ACTUALS.  FUNC\n+   may also be an enumeral, in which case it is treated as a 0-\n+   argument function.  */\n \n-   The user types choices as a sequence of numbers on one line\n-   separated by blanks, encoding them as follows:\n+static int\n+ada_args_match (struct symbol *func, struct value **actuals, int n_actuals)\n+{\n+  int i;\n+  struct type *func_type = SYMBOL_TYPE (func);\n \n-     + A choice of 0 means to cancel the selection, throwing an error.\n-     + If IS_ALL_CHOICE, a choice of 1 selects the entire set 0 .. N_CHOICES-1.\n-     + The user chooses k by typing k+IS_ALL_CHOICE+1.\n+  if (SYMBOL_CLASS (func) == LOC_CONST\n+      && TYPE_CODE (func_type) == TYPE_CODE_ENUM)\n+    return (n_actuals == 0);\n+  else if (func_type == NULL || TYPE_CODE (func_type) != TYPE_CODE_FUNC)\n+    return 0;\n \n-   The user is not allowed to choose more than MAX_RESULTS values.\n+  if (TYPE_NFIELDS (func_type) != n_actuals)\n+    return 0;\n \n-   ANNOTATION_SUFFIX, if present, is used to annotate the input\n-   prompts (for use with the -f switch).  */\n+  for (i = 0; i < n_actuals; i += 1)\n+    {\n+      if (actuals[i] == NULL)\n+        return 0;\n+      else\n+        {\n+          struct type *ftype = ada_check_typedef (TYPE_FIELD_TYPE (func_type,\n+\t\t\t\t\t\t\t\t   i));\n+          struct type *atype = ada_check_typedef (value_type (actuals[i]));\n \n-int\n-get_selections (int *choices, int n_choices, int max_results,\n-                int is_all_choice, const char *annotation_suffix)\n-{\n-  char *args;\n-  const char *prompt;\n-  int n_chosen;\n-  int first_choice = is_all_choice ? 2 : 1;\n+          if (!ada_type_match (ftype, atype, 1))\n+            return 0;\n+        }\n+    }\n+  return 1;\n+}\n \n-  prompt = getenv (\"PS2\");\n-  if (prompt == NULL)\n-    prompt = \"> \";\n+/* False iff function type FUNC_TYPE definitely does not produce a value\n+   compatible with type CONTEXT_TYPE.  Conservatively returns 1 if\n+   FUNC_TYPE is not a valid function type with a non-null return type\n+   or an enumerated type.  A null CONTEXT_TYPE indicates any non-void type.  */\n \n-  args = command_line_input (prompt, annotation_suffix);\n+static int\n+return_match (struct type *func_type, struct type *context_type)\n+{\n+  struct type *return_type;\n \n-  if (args == NULL)\n-    error_no_arg (_(\"one or more choice numbers\"));\n+  if (func_type == NULL)\n+    return 1;\n \n-  n_chosen = 0;\n+  if (TYPE_CODE (func_type) == TYPE_CODE_FUNC)\n+    return_type = get_base_type (TYPE_TARGET_TYPE (func_type));\n+  else\n+    return_type = get_base_type (func_type);\n+  if (return_type == NULL)\n+    return 1;\n \n-  /* Set choices[0 .. n_chosen-1] to the users' choices in ascending\n-     order, as given in args.  Choices are validated.  */\n-  while (1)\n-    {\n-      char *args2;\n-      int choice, j;\n+  context_type = get_base_type (context_type);\n \n-      args = skip_spaces (args);\n-      if (*args == '\\0' && n_chosen == 0)\n-        error_no_arg (_(\"one or more choice numbers\"));\n-      else if (*args == '\\0')\n-        break;\n+  if (TYPE_CODE (return_type) == TYPE_CODE_ENUM)\n+    return context_type == NULL || return_type == context_type;\n+  else if (context_type == NULL)\n+    return TYPE_CODE (return_type) != TYPE_CODE_VOID;\n+  else\n+    return TYPE_CODE (return_type) == TYPE_CODE (context_type);\n+}\n \n-      choice = strtol (args, &args2, 10);\n-      if (args == args2 || choice < 0\n-          || choice > n_choices + first_choice - 1)\n-        error (_(\"Argument must be choice number\"));\n-      args = args2;\n \n-      if (choice == 0)\n-        error (_(\"cancelled\"));\n+/* Returns the index in SYMS[0..NSYMS-1] that contains  the symbol for the\n+   function (if any) that matches the types of the NARGS arguments in\n+   ARGS.  If CONTEXT_TYPE is non-null and there is at least one match\n+   that returns that type, then eliminate matches that don't.  If\n+   CONTEXT_TYPE is void and there is at least one match that does not\n+   return void, eliminate all matches that do.\n \n-      if (choice < first_choice)\n-        {\n-          n_chosen = n_choices;\n-          for (j = 0; j < n_choices; j += 1)\n-            choices[j] = j;\n-          break;\n-        }\n-      choice -= first_choice;\n+   Asks the user if there is more than one match remaining.  Returns -1\n+   if there is no such symbol or none is selected.  NAME is used\n+   solely for messages.  May re-arrange and modify SYMS in\n+   the process; the index returned is for the modified vector.  */\n \n-      for (j = n_chosen - 1; j >= 0 && choice < choices[j]; j -= 1)\n-        {\n-        }\n+static int\n+ada_resolve_function (struct block_symbol syms[],\n+                      int nsyms, struct value **args, int nargs,\n+                      const char *name, struct type *context_type,\n+\t\t      int parse_completion)\n+{\n+  int fallback;\n+  int k;\n+  int m;                        /* Number of hits */\n \n-      if (j < 0 || choice != choices[j])\n+  m = 0;\n+  /* In the first pass of the loop, we only accept functions matching\n+     context_type.  If none are found, we add a second pass of the loop\n+     where every function is accepted.  */\n+  for (fallback = 0; m == 0 && fallback < 2; fallback++)\n+    {\n+      for (k = 0; k < nsyms; k += 1)\n         {\n-          int k;\n+          struct type *type = ada_check_typedef (SYMBOL_TYPE (syms[k].symbol));\n \n-          for (k = n_chosen - 1; k > j; k -= 1)\n-            choices[k + 1] = choices[k];\n-          choices[j + 1] = choice;\n-          n_chosen += 1;\n+          if (ada_args_match (syms[k].symbol, args, nargs)\n+              && (fallback || return_match (type, context_type)))\n+            {\n+              syms[m] = syms[k];\n+              m += 1;\n+            }\n         }\n     }\n \n-  if (n_chosen > max_results)\n-    error (_(\"Select no more than %d of the above\"), max_results);\n-\n-  return n_chosen;\n+  /* If we got multiple matches, ask the user which one to use.  Don't do this\n+     interactive thing during completion, though, as the purpose of the\n+     completion is providing a list of all possible matches.  Prompting the\n+     user to filter it down would be completely unexpected in this case.  */\n+  if (m == 0)\n+    return -1;\n+  else if (m > 1 && !parse_completion)\n+    {\n+      printf_filtered (_(\"Multiple matches for %s\\n\"), name);\n+      user_select_syms (syms, m, 1);\n+      return 0;\n+    }\n+  return 0;\n }\n \n /* Replace the operator of length OPLEN at position PC in *EXPP with a call\n@@ -4284,57 +4290,182 @@ ada_parse_renaming (struct symbol *sym,\n \t}\n     }\n \n-  if (renamed_entity != NULL)\n-    *renamed_entity = info;\n-  suffix = strstr (info, \"___XE\");\n-  if (suffix == NULL || suffix == info)\n-    return ADA_NOT_RENAMING;\n-  if (len != NULL)\n-    *len = strlen (info) - strlen (suffix);\n-  suffix += 5;\n-  if (renaming_expr != NULL)\n-    *renaming_expr = suffix;\n-  return kind;\n-}\n+  if (renamed_entity != NULL)\n+    *renamed_entity = info;\n+  suffix = strstr (info, \"___XE\");\n+  if (suffix == NULL || suffix == info)\n+    return ADA_NOT_RENAMING;\n+  if (len != NULL)\n+    *len = strlen (info) - strlen (suffix);\n+  suffix += 5;\n+  if (renaming_expr != NULL)\n+    *renaming_expr = suffix;\n+  return kind;\n+}\n+\n+/* Compute the value of the given RENAMING_SYM, which is expected to\n+   be a symbol encoding a renaming expression.  BLOCK is the block\n+   used to evaluate the renaming.  */\n+\n+static struct value *\n+ada_read_renaming_var_value (struct symbol *renaming_sym,\n+\t\t\t     const struct block *block)\n+{\n+  const char *sym_name;\n+\n+  sym_name = SYMBOL_LINKAGE_NAME (renaming_sym);\n+  expression_up expr = parse_exp_1 (&sym_name, 0, block, 0);\n+  return evaluate_expression (expr.get ());\n+}\n+\f\n+\n+                                /* Evaluation: Function Calls */\n+\n+/* Return an lvalue containing the value VAL.  This is the identity on\n+   lvalues, and otherwise has the side-effect of allocating memory\n+   in the inferior where a copy of the value contents is copied.  */\n+\n+static struct value *\n+ensure_lval (struct value *val)\n+{\n+  if (VALUE_LVAL (val) == not_lval\n+      || VALUE_LVAL (val) == lval_internalvar)\n+    {\n+      int len = TYPE_LENGTH (ada_check_typedef (value_type (val)));\n+      const CORE_ADDR addr =\n+        value_as_long (value_allocate_space_in_inferior (len));\n+\n+      VALUE_LVAL (val) = lval_memory;\n+      set_value_address (val, addr);\n+      write_memory (addr, value_contents (val), len);\n+    }\n+\n+  return val;\n+}\n+\n+/* Given ARG, a value of type (pointer or reference to a)*\n+   structure/union, extract the component named NAME from the ultimate\n+   target structure/union and return it as a value with its\n+   appropriate type.\n+\n+   The routine searches for NAME among all members of the structure itself\n+   and (recursively) among all members of any wrapper members\n+   (e.g., '_parent').\n+\n+   If NO_ERR, then simply return NULL in case of error, rather than\n+   calling error.  */\n+\n+static struct value *\n+ada_value_struct_elt (struct value *arg, const char *name, int no_err)\n+{\n+  struct type *t, *t1;\n+  struct value *v;\n+  int check_tag;\n+\n+  v = NULL;\n+  t1 = t = ada_check_typedef (value_type (arg));\n+  if (TYPE_CODE (t) == TYPE_CODE_REF)\n+    {\n+      t1 = TYPE_TARGET_TYPE (t);\n+      if (t1 == NULL)\n+\tgoto BadValue;\n+      t1 = ada_check_typedef (t1);\n+      if (TYPE_CODE (t1) == TYPE_CODE_PTR)\n+        {\n+          arg = coerce_ref (arg);\n+          t = t1;\n+        }\n+    }\n+\n+  while (TYPE_CODE (t) == TYPE_CODE_PTR)\n+    {\n+      t1 = TYPE_TARGET_TYPE (t);\n+      if (t1 == NULL)\n+\tgoto BadValue;\n+      t1 = ada_check_typedef (t1);\n+      if (TYPE_CODE (t1) == TYPE_CODE_PTR)\n+        {\n+          arg = value_ind (arg);\n+          t = t1;\n+        }\n+      else\n+        break;\n+    }\n \n-/* Compute the value of the given RENAMING_SYM, which is expected to\n-   be a symbol encoding a renaming expression.  BLOCK is the block\n-   used to evaluate the renaming.  */\n+  if (TYPE_CODE (t1) != TYPE_CODE_STRUCT && TYPE_CODE (t1) != TYPE_CODE_UNION)\n+    goto BadValue;\n \n-static struct value *\n-ada_read_renaming_var_value (struct symbol *renaming_sym,\n-\t\t\t     const struct block *block)\n-{\n-  const char *sym_name;\n+  if (t1 == t)\n+    v = ada_search_struct_field (name, arg, 0, t);\n+  else\n+    {\n+      int bit_offset, bit_size, byte_offset;\n+      struct type *field_type;\n+      CORE_ADDR address;\n \n-  sym_name = SYMBOL_LINKAGE_NAME (renaming_sym);\n-  expression_up expr = parse_exp_1 (&sym_name, 0, block, 0);\n-  return evaluate_expression (expr.get ());\n-}\n-\f\n+      if (TYPE_CODE (t) == TYPE_CODE_PTR)\n+\taddress = value_address (ada_value_ind (arg));\n+      else\n+\taddress = value_address (ada_coerce_ref (arg));\n \n-                                /* Evaluation: Function Calls */\n+      /* Check to see if this is a tagged type.  We also need to handle\n+         the case where the type is a reference to a tagged type, but\n+         we have to be careful to exclude pointers to tagged types.\n+         The latter should be shown as usual (as a pointer), whereas\n+         a reference should mostly be transparent to the user.  */\n \n-/* Return an lvalue containing the value VAL.  This is the identity on\n-   lvalues, and otherwise has the side-effect of allocating memory\n-   in the inferior where a copy of the value contents is copied.  */\n+      if (ada_is_tagged_type (t1, 0)\n+          || (TYPE_CODE (t1) == TYPE_CODE_REF\n+              && ada_is_tagged_type (TYPE_TARGET_TYPE (t1), 0)))\n+        {\n+          /* We first try to find the searched field in the current type.\n+\t     If not found then let's look in the fixed type.  */\n \n-static struct value *\n-ensure_lval (struct value *val)\n-{\n-  if (VALUE_LVAL (val) == not_lval\n-      || VALUE_LVAL (val) == lval_internalvar)\n-    {\n-      int len = TYPE_LENGTH (ada_check_typedef (value_type (val)));\n-      const CORE_ADDR addr =\n-        value_as_long (value_allocate_space_in_inferior (len));\n+          if (!find_struct_field (name, t1, 0,\n+                                  &field_type, &byte_offset, &bit_offset,\n+                                  &bit_size, NULL))\n+\t    check_tag = 1;\n+\t  else\n+\t    check_tag = 0;\n+        }\n+      else\n+\tcheck_tag = 0;\n \n-      VALUE_LVAL (val) = lval_memory;\n-      set_value_address (val, addr);\n-      write_memory (addr, value_contents (val), len);\n+      /* Convert to fixed type in all cases, so that we have proper\n+\t offsets to each field in unconstrained record types.  */\n+      t1 = ada_to_fixed_type (ada_get_base_type (t1), NULL,\n+\t\t\t      address, NULL, check_tag);\n+\n+      if (find_struct_field (name, t1, 0,\n+                             &field_type, &byte_offset, &bit_offset,\n+                             &bit_size, NULL))\n+        {\n+          if (bit_size != 0)\n+            {\n+              if (TYPE_CODE (t) == TYPE_CODE_REF)\n+                arg = ada_coerce_ref (arg);\n+              else\n+                arg = ada_value_ind (arg);\n+              v = ada_value_primitive_packed_val (arg, NULL, byte_offset,\n+                                                  bit_offset, bit_size,\n+                                                  field_type);\n+            }\n+          else\n+            v = value_at_lazy (field_type, address + byte_offset);\n+        }\n     }\n \n-  return val;\n+  if (v != NULL || no_err)\n+    return v;\n+  else\n+    error (_(\"There is no member named %s.\"), name);\n+\n+ BadValue:\n+  if (no_err)\n+    return NULL;\n+  else\n+    error (_(\"Attempt to extract a component of \"\n+\t     \"a value that is not a record.\"));\n }\n \n /* Return the value ACTUAL, converted to be an appropriate value for a\n@@ -6491,7 +6622,7 @@ ada_is_tag_type (struct type *type)\n \n /* The type of the tag on VAL.  */\n \n-struct type *\n+static struct type *\n ada_tag_type (struct value *val)\n {\n   return ada_lookup_struct_elt_type (value_type (val), \"_tag\", 1, 0);\n@@ -6508,7 +6639,7 @@ is_ada95_tag (struct value *tag)\n \n /* The value of the tag on VAL.  */\n \n-struct value *\n+static struct value *\n ada_value_tag (struct value *val)\n {\n   return ada_value_struct_elt (val, \"_tag\", 0);\n@@ -6860,7 +6991,7 @@ ada_variant_discrim_type (struct type *var_type, struct type *outer_type)\n    valid field number within it, returns 1 iff field FIELD_NUM of TYPE\n    represents a 'when others' clause; otherwise 0.  */\n \n-int\n+static int\n ada_is_others_clause (struct type *type, int field_num)\n {\n   const char *name = TYPE_FIELD_NAME (type, field_num);\n@@ -6968,7 +7099,7 @@ ada_scan_number (const char str[], int k, LONGEST * R, int *new_k)\n    and FIELD_NUM is a valid field number within it, returns 1 iff VAL is\n    in the range encoded by field FIELD_NUM of TYPE; otherwise 0.  */\n \n-int\n+static int\n ada_in_variant (LONGEST val, struct type *type, int field_num)\n {\n   const char *name = TYPE_FIELD_NAME (type, field_num);\n@@ -7369,131 +7500,6 @@ ada_index_struct_field_1 (int *index_p, struct value *arg, int offset,\n   return NULL;\n }\n \n-/* Given ARG, a value of type (pointer or reference to a)*\n-   structure/union, extract the component named NAME from the ultimate\n-   target structure/union and return it as a value with its\n-   appropriate type.\n-\n-   The routine searches for NAME among all members of the structure itself\n-   and (recursively) among all members of any wrapper members\n-   (e.g., '_parent').\n-\n-   If NO_ERR, then simply return NULL in case of error, rather than \n-   calling error.  */\n-\n-struct value *\n-ada_value_struct_elt (struct value *arg, const char *name, int no_err)\n-{\n-  struct type *t, *t1;\n-  struct value *v;\n-  int check_tag;\n-\n-  v = NULL;\n-  t1 = t = ada_check_typedef (value_type (arg));\n-  if (TYPE_CODE (t) == TYPE_CODE_REF)\n-    {\n-      t1 = TYPE_TARGET_TYPE (t);\n-      if (t1 == NULL)\n-\tgoto BadValue;\n-      t1 = ada_check_typedef (t1);\n-      if (TYPE_CODE (t1) == TYPE_CODE_PTR)\n-        {\n-          arg = coerce_ref (arg);\n-          t = t1;\n-        }\n-    }\n-\n-  while (TYPE_CODE (t) == TYPE_CODE_PTR)\n-    {\n-      t1 = TYPE_TARGET_TYPE (t);\n-      if (t1 == NULL)\n-\tgoto BadValue;\n-      t1 = ada_check_typedef (t1);\n-      if (TYPE_CODE (t1) == TYPE_CODE_PTR)\n-        {\n-          arg = value_ind (arg);\n-          t = t1;\n-        }\n-      else\n-        break;\n-    }\n-\n-  if (TYPE_CODE (t1) != TYPE_CODE_STRUCT && TYPE_CODE (t1) != TYPE_CODE_UNION)\n-    goto BadValue;\n-\n-  if (t1 == t)\n-    v = ada_search_struct_field (name, arg, 0, t);\n-  else\n-    {\n-      int bit_offset, bit_size, byte_offset;\n-      struct type *field_type;\n-      CORE_ADDR address;\n-\n-      if (TYPE_CODE (t) == TYPE_CODE_PTR)\n-\taddress = value_address (ada_value_ind (arg));\n-      else\n-\taddress = value_address (ada_coerce_ref (arg));\n-\n-      /* Check to see if this is a tagged type.  We also need to handle\n-         the case where the type is a reference to a tagged type, but\n-         we have to be careful to exclude pointers to tagged types.\n-         The latter should be shown as usual (as a pointer), whereas\n-         a reference should mostly be transparent to the user.  */\n-\n-      if (ada_is_tagged_type (t1, 0)\n-          || (TYPE_CODE (t1) == TYPE_CODE_REF\n-              && ada_is_tagged_type (TYPE_TARGET_TYPE (t1), 0)))\n-        {\n-          /* We first try to find the searched field in the current type.\n-\t     If not found then let's look in the fixed type.  */\n-\n-          if (!find_struct_field (name, t1, 0,\n-                                  &field_type, &byte_offset, &bit_offset,\n-                                  &bit_size, NULL))\n-\t    check_tag = 1;\n-\t  else\n-\t    check_tag = 0;\n-        }\n-      else\n-\tcheck_tag = 0;\n-\n-      /* Convert to fixed type in all cases, so that we have proper\n-\t offsets to each field in unconstrained record types.  */\n-      t1 = ada_to_fixed_type (ada_get_base_type (t1), NULL,\n-\t\t\t      address, NULL, check_tag);\n-\n-      if (find_struct_field (name, t1, 0,\n-                             &field_type, &byte_offset, &bit_offset,\n-                             &bit_size, NULL))\n-        {\n-          if (bit_size != 0)\n-            {\n-              if (TYPE_CODE (t) == TYPE_CODE_REF)\n-                arg = ada_coerce_ref (arg);\n-              else\n-                arg = ada_value_ind (arg);\n-              v = ada_value_primitive_packed_val (arg, NULL, byte_offset,\n-                                                  bit_offset, bit_size,\n-                                                  field_type);\n-            }\n-          else\n-            v = value_at_lazy (field_type, address + byte_offset);\n-        }\n-    }\n-\n-  if (v != NULL || no_err)\n-    return v;\n-  else\n-    error (_(\"There is no member named %s.\"), name);\n-\n- BadValue:\n-  if (no_err)\n-    return NULL;\n-  else\n-    error (_(\"Attempt to extract a component of \"\n-\t     \"a value that is not a record.\"));\n-}\n-\n /* Return a string representation of type TYPE.  */\n \n static std::string\n@@ -9145,7 +9151,7 @@ static const char *attribute_names[] = {\n   0\n };\n \n-const char *\n+static const char *\n ada_attribute_name (enum exp_opcode n)\n {\n   if (n >= OP_ATR_FIRST && n <= (int) OP_ATR_VAL)"
    },
    {
      "sha": "13a917affec886fd37b5da4c3b1035a50b8ffc4a",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 34,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/de93309a38afe2a7c0c519c8b69cca7c20d03fbc/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/de93309a38afe2a7c0c519c8b69cca7c20d03fbc/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=de93309a38afe2a7c0c519c8b69cca7c20d03fbc",
      "patch": "@@ -149,14 +149,6 @@ struct ada_task_info\n   int base_cpu;\n };\n \n-/* Assuming V points to an array of S objects,  make sure that it contains at\n-   least M objects, updating V and S as necessary.  */\n-\n-#define GROW_VECT(v, s, m)                                    \\\n-   if ((s) < (m)) (v) = (char *) grow_vect (v, &(s), m, sizeof *(v));\n-\n-extern void *grow_vect (void *, size_t *, size_t, int);\n-\n extern void ada_ensure_varsize_limit (const struct type *type);\n \n extern int ada_get_field_index (const struct type *type,\n@@ -204,8 +196,6 @@ extern struct type *ada_array_element_type (struct type *, int);\n \n extern int ada_array_arity (struct type *);\n \n-struct type *ada_type_of_array (struct value *, int);\n-\n extern struct value *ada_coerce_to_simple_array_ptr (struct value *);\n \n struct value *ada_coerce_to_simple_array (struct value *);\n@@ -228,14 +218,10 @@ extern const char *ada_decode_symbol (const struct general_symbol_info *);\n \n extern std::string ada_decode (const char*);\n \n-extern enum language ada_update_initial_language (enum language);\n-\n extern int ada_lookup_symbol_list (const char *, const struct block *,\n                                    domain_enum,\n \t\t\t\t   std::vector<struct block_symbol> *);\n \n-extern char *ada_fold_name (const char *);\n-\n extern struct block_symbol ada_lookup_symbol (const char *,\n \t\t\t\t\t      const struct block *,\n \t\t\t\t\t      domain_enum);\n@@ -246,12 +232,6 @@ extern void ada_lookup_encoded_symbol\n \n extern struct bound_minimal_symbol ada_lookup_simple_minsym (const char *);\n \n-extern void ada_fill_in_ada_prototype (struct symbol *);\n-\n-extern int user_select_syms (struct block_symbol *, int, int);\n-\n-extern int get_selections (int *, int, int, int, const char *);\n-\n extern int ada_scan_number (const char *, int, LONGEST *, int *);\n \n extern struct type *ada_parent_type (struct type *);\n@@ -275,10 +255,6 @@ extern int ada_is_tagged_type (struct type *, int);\n \n extern int ada_is_tag_type (struct type *);\n \n-extern struct type *ada_tag_type (struct value *);\n-\n-extern struct value *ada_value_tag (struct value *);\n-\n extern const char *ada_tag_name (struct value *);\n \n extern struct value *ada_tag_value_at_base_address (struct value *obj);\n@@ -291,23 +267,15 @@ extern int ada_is_variant_part (struct type *, int);\n \n extern struct type *ada_variant_discrim_type (struct type *, struct type *);\n \n-extern int ada_is_others_clause (struct type *, int);\n-\n-extern int ada_in_variant (LONGEST, struct type *, int);\n-\n extern const char *ada_variant_discrim_name (struct type *);\n \n-extern struct value *ada_value_struct_elt (struct value *, const char *, int);\n-\n extern int ada_is_aligner_type (struct type *);\n \n extern struct type *ada_aligned_type (struct type *);\n \n extern const gdb_byte *ada_aligned_value_addr (struct type *,\n \t\t\t\t\t       const gdb_byte *);\n \n-extern const char *ada_attribute_name (enum exp_opcode);\n-\n extern int ada_is_fixed_point_type (struct type *);\n \n extern int ada_is_system_address_type (struct type *);\n@@ -316,8 +284,6 @@ extern struct value *ada_delta (struct type *);\n \n extern struct value *ada_scaling_factor (struct type *);\n \n-extern struct type *ada_system_address_type (void);\n-\n extern int ada_which_variant_applies (struct type *, struct type *,\n \t\t\t\t      const gdb_byte *);\n "
    }
  ]
}