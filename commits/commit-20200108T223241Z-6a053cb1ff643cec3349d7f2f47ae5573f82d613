{
  "sha": "6a053cb1ff643cec3349d7f2f47ae5573f82d613",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NmEwNTNjYjFmZjY0M2NlYzMzNDlkN2YyZjQ3YWU1NTczZjgyZDYxMw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-01-06T21:34:52Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-01-08T22:32:41Z"
    },
    "message": "Change section_offsets to a std::vector\n\nThis changes section_offsets to be specialization of a std::vector and\nupdates all the users.  It also removes the ANOFFSET and\nSIZEOF_N_SECTION_OFFSETS macros.\n\nMost of this is just a generic sort of cleanup, that reduces the\nnumber of lines of code.  However, a couple spots were doing weird\nthings.\n\nobjfile_relocate did:\n\n-      std::vector<struct section_offsets>\n-\tnew_debug_offsets (SIZEOF_N_SECTION_OFFSETS (debug_objfile->num_sections));\n\n... which seems to greatly over-estimate the number of elements\nneeded.\n\nThis appeared in set_objfile_default_section_offset:\n\n-  std::vector<struct section_offsets> offsets (objf->num_sections,\n-\t\t\t\t\t       { { offset } });\n\n... which makes sense due to type safety, but is also actively\nconfusing given that section_offsets was previously also a kind of\nvector type.\n\nTested on x86-64 Fedora 30.\n\ngdb/ChangeLog\n2020-01-08  Tom Tromey  <tromey@adacore.com>\n\n\t* xcoffread.c (enter_line_range, read_xcoff_symtab)\n\t(process_xcoff_symbol, xcoff_symfile_offsets): Update.\n\t* symtab.h (MSYMBOL_VALUE_ADDRESS): Update.\n\t(struct section_offsets, ANOFFSET, SIZEOF_N_SECTION_OFFSETS):\n\tRemove.\n\t(section_offsets): New typedef.\n\t* symtab.c (fixup_section, get_msymbol_address): Update.\n\t* symmisc.c (dump_msymbols): Update.\n\t* symfile.h (relative_addr_info_to_section_offsets)\n\t(symfile_map_offsets_to_segments): Update.\n\t* symfile.c (build_section_addr_info_from_objfile)\n\t(init_objfile_sect_indices): Update.\n\t(struct place_section_arg): Change type of \"offsets\".\n\t(place_section): Update.\n\t(relative_addr_info_to_section_offsets): Change type of\n\t\"section_offsets\".  Remove \"num_sections\" parameter.\n\t(default_symfile_offsets, syms_from_objfile_1)\n\t(set_objfile_default_section_offset): Update.\n\t(reread_symbols): No need to preserve section offsets by hand.\n\t(symfile_map_offsets_to_segments): Change type of \"offsets\".\n\t* stap-probe.c (relocate_address): Update.\n\t* stabsread.h (process_one_symbol): Update.\n\t* solib-target.c (struct lm_info_target) <offsets>: Change type.\n\t(solib_target_relocate_section_addresses): Update.\n\t* solib-svr4.c (enable_break, svr4_relocate_main_executable):\n\tUpdate.\n\t* solib-frv.c (frv_relocate_main_executable): Update.\n\t* solib-dsbt.c (dsbt_relocate_main_executable): Update.\n\t* solib-aix.c (solib_aix_get_section_offsets): Change return\n\ttype.\n\t(solib_aix_solib_create_inferior_hook): Update.\n\t* remote.c (remote_target::get_offsets): Update.\n\t* psymtab.c (find_pc_sect_psymtab): Update.\n\t* psympriv.h (struct partial_symbol) <address, text_low,\n\ttext_high>: Update.\n\t* objfiles.h (obj_section_offset): Update.\n\t(struct objfile) <section_offsets>: Change type.\n\t<num_sections>: Remove.\n\t(objfile_relocate): Update.\n\t* objfiles.c (entry_point_address_query): Update\n\t(relocate_one_symbol): Change type of \"section_offsets\".\n\t(objfile_relocate1, objfile_relocate1): Change type of\n\t\"new_offsets\".\n\t(objfile_rebase1): Update.\n\t* mipsread.c (mipscoff_symfile_read): Update.\n\t(read_alphacoff_dynamic_symtab): Remove \"section_offsets\"\n\tparameter.\n\t* mdebugread.c (parse_symbol): Change type of \"section_offsets\".\n\t(parse_external, psymtab_to_symtab_1): Update.\n\t* machoread.c (macho_symfile_offsets): Update.\n\t* ia64-tdep.c (ia64_find_unwind_table): Update.\n\t* hppa-tdep.c (read_unwind_info): Update.\n\t* hppa-bsd-tdep.c (hppabsd_find_global_pointer): Update.\n\t* dwarf2read.c (create_addrmap_from_index)\n\t(create_addrmap_from_aranges, dw2_find_pc_sect_compunit_symtab)\n\t(process_psymtab_comp_unit_reader, add_partial_symbol)\n\t(add_partial_subprogram, process_full_comp_unit)\n\t(read_file_scope, read_func_scope, read_lexical_block_scope)\n\t(read_call_site_scope, dwarf2_rnglists_process)\n\t(dwarf2_ranges_process, dwarf2_ranges_read)\n\t(dwarf_decode_lines_1, var_decode_location, new_symbol)\n\t(dwarf2_fetch_die_loc_sect_off, dwarf2_per_cu_text_offset):\n\tUpdate.\n\t* dwarf2-frame.c (execute_cfa_program, dwarf2_frame_find_fde):\n\tUpdate.\n\t* dtrace-probe.c (dtrace_probe::get_relocated_address): Update.\n\t* dbxread.c (read_dbx_symtab, read_ofile_symtab): Update.\n\t(process_one_symbol): Change type of \"section_offsets\".\n\t* ctfread.c (get_objfile_text_range): Update.\n\t* coffread.c (coff_symtab_read, enter_linenos)\n\t(process_coff_symbol): Update.\n\t* coff-pe-read.c (add_pe_forwarded_sym): Update.\n\t* amd64-windows-tdep.c (amd64_windows_find_unwind_info): Update.\n\nChange-Id: I147eb967e9b44d82f4048039de7bb44b80cd72fb",
    "tree": {
      "sha": "0bbc77013f55e450d489318e6199a06a8e13e06d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/0bbc77013f55e450d489318e6199a06a8e13e06d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/6a053cb1ff643cec3349d7f2f47ae5573f82d613",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6a053cb1ff643cec3349d7f2f47ae5573f82d613",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/6a053cb1ff643cec3349d7f2f47ae5573f82d613",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/6a053cb1ff643cec3349d7f2f47ae5573f82d613/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "456e800a63def18484f69a51f59c2338a5cc4568",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/456e800a63def18484f69a51f59c2338a5cc4568",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/456e800a63def18484f69a51f59c2338a5cc4568"
    }
  ],
  "stats": {
    "total": 569,
    "additions": 255,
    "deletions": 314
  },
  "files": [
    {
      "sha": "b10989a410d877aaf760780db55a7464b0ba0cb7",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 76,
      "deletions": 0,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -1,3 +1,79 @@\n+2020-01-08  Tom Tromey  <tromey@adacore.com>\n+\n+\t* xcoffread.c (enter_line_range, read_xcoff_symtab)\n+\t(process_xcoff_symbol, xcoff_symfile_offsets): Update.\n+\t* symtab.h (MSYMBOL_VALUE_ADDRESS): Update.\n+\t(struct section_offsets, ANOFFSET, SIZEOF_N_SECTION_OFFSETS):\n+\tRemove.\n+\t(section_offsets): New typedef.\n+\t* symtab.c (fixup_section, get_msymbol_address): Update.\n+\t* symmisc.c (dump_msymbols): Update.\n+\t* symfile.h (relative_addr_info_to_section_offsets)\n+\t(symfile_map_offsets_to_segments): Update.\n+\t* symfile.c (build_section_addr_info_from_objfile)\n+\t(init_objfile_sect_indices): Update.\n+\t(struct place_section_arg): Change type of \"offsets\".\n+\t(place_section): Update.\n+\t(relative_addr_info_to_section_offsets): Change type of\n+\t\"section_offsets\".  Remove \"num_sections\" parameter.\n+\t(default_symfile_offsets, syms_from_objfile_1)\n+\t(set_objfile_default_section_offset): Update.\n+\t(reread_symbols): No need to preserve section offsets by hand.\n+\t(symfile_map_offsets_to_segments): Change type of \"offsets\".\n+\t* stap-probe.c (relocate_address): Update.\n+\t* stabsread.h (process_one_symbol): Update.\n+\t* solib-target.c (struct lm_info_target) <offsets>: Change type.\n+\t(solib_target_relocate_section_addresses): Update.\n+\t* solib-svr4.c (enable_break, svr4_relocate_main_executable):\n+\tUpdate.\n+\t* solib-frv.c (frv_relocate_main_executable): Update.\n+\t* solib-dsbt.c (dsbt_relocate_main_executable): Update.\n+\t* solib-aix.c (solib_aix_get_section_offsets): Change return\n+\ttype.\n+\t(solib_aix_solib_create_inferior_hook): Update.\n+\t* remote.c (remote_target::get_offsets): Update.\n+\t* psymtab.c (find_pc_sect_psymtab): Update.\n+\t* psympriv.h (struct partial_symbol) <address, text_low,\n+\ttext_high>: Update.\n+\t* objfiles.h (obj_section_offset): Update.\n+\t(struct objfile) <section_offsets>: Change type.\n+\t<num_sections>: Remove.\n+\t(objfile_relocate): Update.\n+\t* objfiles.c (entry_point_address_query): Update\n+\t(relocate_one_symbol): Change type of \"section_offsets\".\n+\t(objfile_relocate1, objfile_relocate1): Change type of\n+\t\"new_offsets\".\n+\t(objfile_rebase1): Update.\n+\t* mipsread.c (mipscoff_symfile_read): Update.\n+\t(read_alphacoff_dynamic_symtab): Remove \"section_offsets\"\n+\tparameter.\n+\t* mdebugread.c (parse_symbol): Change type of \"section_offsets\".\n+\t(parse_external, psymtab_to_symtab_1): Update.\n+\t* machoread.c (macho_symfile_offsets): Update.\n+\t* ia64-tdep.c (ia64_find_unwind_table): Update.\n+\t* hppa-tdep.c (read_unwind_info): Update.\n+\t* hppa-bsd-tdep.c (hppabsd_find_global_pointer): Update.\n+\t* dwarf2read.c (create_addrmap_from_index)\n+\t(create_addrmap_from_aranges, dw2_find_pc_sect_compunit_symtab)\n+\t(process_psymtab_comp_unit_reader, add_partial_symbol)\n+\t(add_partial_subprogram, process_full_comp_unit)\n+\t(read_file_scope, read_func_scope, read_lexical_block_scope)\n+\t(read_call_site_scope, dwarf2_rnglists_process)\n+\t(dwarf2_ranges_process, dwarf2_ranges_read)\n+\t(dwarf_decode_lines_1, var_decode_location, new_symbol)\n+\t(dwarf2_fetch_die_loc_sect_off, dwarf2_per_cu_text_offset):\n+\tUpdate.\n+\t* dwarf2-frame.c (execute_cfa_program, dwarf2_frame_find_fde):\n+\tUpdate.\n+\t* dtrace-probe.c (dtrace_probe::get_relocated_address): Update.\n+\t* dbxread.c (read_dbx_symtab, read_ofile_symtab): Update.\n+\t(process_one_symbol): Change type of \"section_offsets\".\n+\t* ctfread.c (get_objfile_text_range): Update.\n+\t* coffread.c (coff_symtab_read, enter_linenos)\n+\t(process_coff_symbol): Update.\n+\t* coff-pe-read.c (add_pe_forwarded_sym): Update.\n+\t* amd64-windows-tdep.c (amd64_windows_find_unwind_info): Update.\n+\n 2020-01-08  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf2read.c (parse_macro_definition): Use std::string."
    },
    {
      "sha": "e1e777c4355e74a617527fcebee594fcf182f778",
      "filename": "gdb/amd64-windows-tdep.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/amd64-windows-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/amd64-windows-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/amd64-windows-tdep.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -953,8 +953,8 @@ amd64_windows_find_unwind_info (struct gdbarch *gdbarch, CORE_ADDR pc,\n   pe = pe_data (sec->objfile->obfd);\n   dir = &pe->pe_opthdr.DataDirectory[PE_EXCEPTION_TABLE];\n \n-  base = pe->pe_opthdr.ImageBase\n-    + ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  base = (pe->pe_opthdr.ImageBase\n+\t  + objfile->section_offsets[SECT_OFF_TEXT (objfile)]);\n   *image_base = base;\n \n   /* Find the entry."
    },
    {
      "sha": "b7f7b81ca88251e5b6dce444527b286abe5509f3",
      "filename": "gdb/coff-pe-read.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/coff-pe-read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/coff-pe-read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coff-pe-read.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -266,7 +266,7 @@ add_pe_forwarded_sym (minimal_symbol_reader &reader,\n      really be relocated properly, but nevertheless we make a stab at\n      it, choosing an approach consistent with the history of this\n      code.  */\n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   reader.record_with_info (qualified_name.c_str (), vma - baseaddr, msymtype,\n \t\t\t   section);"
    },
    {
      "sha": "60efb59b1a341a89bae56ffde667aa9669efc1fa",
      "filename": "gdb/coffread.c",
      "status": "modified",
      "additions": 12,
      "deletions": 18,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/coffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/coffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/coffread.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -919,8 +919,8 @@ coff_symtab_read (minimal_symbol_reader &reader,\n \t\t     file with no symbols.  */\n \t\t  if (in_source_file)\n \t\t    complete_symtab (filestring,\n-\t\t    cs->c_value + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t    SECT_OFF_TEXT (objfile)),\n+\t\t\t\t     (cs->c_value\n+\t\t\t\t      + objfile->section_offsets[SECT_OFF_TEXT (objfile)]),\n \t\t\t\t     main_aux.x_scn.x_scnlen);\n \t\t  in_source_file = 0;\n \t\t}\n@@ -986,7 +986,7 @@ coff_symtab_read (minimal_symbol_reader &reader,\n  \t\t    || cs->c_sclass == C_THUMBEXTFUNC\n  \t\t    || cs->c_sclass == C_THUMBEXT\n  \t\t    || (pe_file && (cs->c_sclass == C_STAT)))\n-\t\t  offset = ANOFFSET (objfile->section_offsets, sec);\n+\t\t  offset = objfile->section_offsets[sec];\n \n \t\tif (bfd_section->flags & SEC_CODE)\n \t\t  {\n@@ -1113,8 +1113,7 @@ coff_symtab_read (minimal_symbol_reader &reader,\n \t\t\t    NULL, cstk.start_addr,\n \t\t\t    fcn_cs_saved.c_value\n \t\t\t    + fcn_aux_saved.x_sym.x_misc.x_fsize\n-\t\t\t    + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\tSECT_OFF_TEXT (objfile)));\n+\t\t\t    + objfile->section_offsets[SECT_OFF_TEXT (objfile)]);\n \t      within_function = 0;\n \t    }\n \t  break;\n@@ -1123,8 +1122,7 @@ coff_symtab_read (minimal_symbol_reader &reader,\n \t  if (strcmp (cs->c_name, \".bb\") == 0)\n \t    {\n \t      tmpaddr = cs->c_value;\n-\t      tmpaddr += ANOFFSET (objfile->section_offsets,\n-\t\t\t\t   SECT_OFF_TEXT (objfile));\n+\t      tmpaddr += objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \t      push_context (++depth, tmpaddr);\n \t    }\n \t  else if (strcmp (cs->c_name, \".eb\") == 0)\n@@ -1147,9 +1145,9 @@ coff_symtab_read (minimal_symbol_reader &reader,\n \t\t}\n \t      if (*get_local_symbols () && !outermost_context_p ())\n \t\t{\n-\t\t  tmpaddr =\n-\t\t    cs->c_value + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t    SECT_OFF_TEXT (objfile));\n+\t\t  tmpaddr\n+\t\t    = (cs->c_value\n+\t\t       + objfile->section_offsets[SECT_OFF_TEXT (objfile)]);\n \t\t  /* Make a block for the local symbols within.  */\n \t\t  finish_block (0, cstk.old_blocks, NULL,\n \t\t\t\tcstk.start_addr, tmpaddr);\n@@ -1441,8 +1439,7 @@ enter_linenos (long file_offset, int first_line,\n       if (L_LNNO32 (&lptr) && L_LNNO32 (&lptr) <= last_line)\n \t{\n \t  CORE_ADDR addr = lptr.l_addr.l_paddr;\n-\t  addr += ANOFFSET (objfile->section_offsets,\n-\t\t\t    SECT_OFF_TEXT (objfile));\n+\t  addr += objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \t  record_line (get_current_subfile (),\n \t\t       first_line + L_LNNO32 (&lptr),\n \t\t       gdbarch_addr_bits_remove (gdbarch, addr));\n@@ -1577,8 +1574,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \n   if (ISFCN (cs->c_type))\n     {\n-      SYMBOL_VALUE (sym) += ANOFFSET (objfile->section_offsets,\n-\t\t\t\t      SECT_OFF_TEXT (objfile));\n+      SYMBOL_VALUE (sym) += objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n       SYMBOL_TYPE (sym) =\n \tlookup_function_type (decode_function_type (cs, cs->c_type,\n \t\t\t\t\t\t    aux, objfile));\n@@ -1610,8 +1606,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n \t  SET_SYMBOL_VALUE_ADDRESS (sym,\n \t\t\t\t    (CORE_ADDR) cs->c_value\n-\t\t\t\t    + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t\tSECT_OFF_TEXT (objfile)));\n+\t\t\t\t    + objfile->section_offsets[SECT_OFF_TEXT (objfile)]);\n \t  add_symbol_to_list (sym, get_global_symbols ());\n \t  break;\n \n@@ -1621,8 +1616,7 @@ process_coff_symbol (struct coff_symbol *cs,\n \t  SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n \t  SET_SYMBOL_VALUE_ADDRESS (sym,\n \t\t\t\t    (CORE_ADDR) cs->c_value\n-\t\t\t\t    + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t\tSECT_OFF_TEXT (objfile)));\n+\t\t\t\t    + objfile->section_offsets[SECT_OFF_TEXT (objfile)]);\n \t  if (within_function)\n \t    {\n \t      /* Static symbol of local scope.  */"
    },
    {
      "sha": "ebf1eec6a57658c22e0dd17ca6f4b75a0458336f",
      "filename": "gdb/ctfread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/ctfread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/ctfread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ctfread.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -1165,7 +1165,7 @@ get_objfile_text_range (struct objfile *of, int *tsize)\n \n   codes = bfd_get_section_by_name (abfd, \".text\");\n   *tsize = codes ? bfd_section_size (codes) : 0;\n-  return ANOFFSET (of->section_offsets, SECT_OFF_TEXT (of));\n+  return of->section_offsets[SECT_OFF_TEXT (of)];\n }\n \n /* Start a symtab for OBJFILE in CTF format.  */"
    },
    {
      "sha": "0909c67ccbb4c88b3f640ff4b3e8129222bec4ed",
      "filename": "gdb/dbxread.c",
      "status": "modified",
      "additions": 13,
      "deletions": 17,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/dbxread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/dbxread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dbxread.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -1046,9 +1046,7 @@ read_dbx_symtab (minimal_symbol_reader &reader, struct objfile *objfile)\n \n   /* If data_sect_index is still -1, that's okay.  It's perfectly fine\n      for the file to have no .data, no .bss, and no .text at all, if\n-     it also has no global or static variables.  If it does, we will\n-     get an internal error from an ANOFFSET macro below when we try to\n-     use data_sect_index.  */\n+     it also has no global or static variables.  */\n \n   for (symnum = 0; symnum < DBX_SYMCOUNT (objfile); symnum++)\n     {\n@@ -2179,13 +2177,12 @@ read_ofile_symtab (struct objfile *objfile, struct partial_symtab *pst)\n   int sym_size;\t\t\t/* Size of symbols to read */\n   CORE_ADDR text_offset;\t/* Start of text segment for symbols */\n   int text_size;\t\t/* Size of text segment for symbols */\n-  struct section_offsets *section_offsets;\n \n   sym_offset = LDSYMOFF (pst);\n   sym_size = LDSYMLEN (pst);\n   text_offset = pst->text_low (objfile);\n   text_size = pst->text_high (objfile) - pst->text_low (objfile);\n-  section_offsets = objfile->section_offsets;\n+  const section_offsets &section_offsets = objfile->section_offsets;\n \n   dbxread_objfile = objfile;\n \n@@ -2378,7 +2375,7 @@ cp_set_block_scope (const struct symbol *symbol,\n \n void\n process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n-\t\t    const struct section_offsets *section_offsets,\n+\t\t    const section_offsets &section_offsets,\n \t\t    struct objfile *objfile, enum language language)\n {\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n@@ -2469,7 +2466,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n       sline_found_in_function = 0;\n \n       /* Relocate for dynamic loading.  */\n-      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));\n+      valu += section_offsets[SECT_OFF_TEXT (objfile)];\n       valu = gdbarch_addr_bits_remove (gdbarch, valu);\n       last_function_start = valu;\n \n@@ -2557,15 +2554,15 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n     case N_FN_SEQ:\n       /* This kind of symbol indicates the start of an object file.\n          Relocate for dynamic loading.  */\n-      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));\n+      valu += section_offsets[SECT_OFF_TEXT (objfile)];\n       break;\n \n     case N_SO:\n       /* This type of symbol indicates the start of data for one\n          source file.  Finish the symbol table of the previous source\n          file (if any) and start accumulating a new symbol table.\n          Relocate for dynamic loading.  */\n-      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));\n+      valu += section_offsets[SECT_OFF_TEXT (objfile)];\n \n       n_opt_found = 0;\n \n@@ -2601,7 +2598,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n          sub-source-file, one whose contents were copied or included\n          in the compilation of the main source file (whose name was\n          given in the N_SO symbol).  Relocate for dynamic loading.  */\n-      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));\n+      valu += section_offsets[SECT_OFF_TEXT (objfile)];\n       start_subfile (name);\n       break;\n \n@@ -2701,7 +2698,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \t\t   symbol_file_add as addr (this is known to affect\n \t\t   SunOS 4, and I suspect ELF too).  Since there is no\n \t\t   Ttext.text symbol, we can get addr from the text offset.  */\n-\t\tvalu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));\n+\t\tvalu += section_offsets[SECT_OFF_TEXT (objfile)];\n \t\tgoto define_a_symbol;\n \t      }\n \t  }\n@@ -2723,22 +2720,22 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \n     case_N_STSYM:\t\t/* Static symbol in data segment.  */\n     case N_DSLINE:\t\t/* Source line number, data segment.  */\n-      valu += ANOFFSET (section_offsets, SECT_OFF_DATA (objfile));\n+      valu += section_offsets[SECT_OFF_DATA (objfile)];\n       goto define_a_symbol;\n \n     case_N_LCSYM:\t\t/* Static symbol in BSS segment.  */\n     case N_BSLINE:\t\t/* Source line number, BSS segment.  */\n       /* N_BROWS: overlaps with N_BSLINE.  */\n-      valu += ANOFFSET (section_offsets, SECT_OFF_BSS (objfile));\n+      valu += section_offsets[SECT_OFF_BSS (objfile)];\n       goto define_a_symbol;\n \n     case_N_ROSYM:\t\t/* Static symbol in read-only data segment.  */\n-      valu += ANOFFSET (section_offsets, SECT_OFF_RODATA (objfile));\n+      valu += section_offsets[SECT_OFF_RODATA (objfile)];\n       goto define_a_symbol;\n \n     case N_ENTRY:\t\t/* Alternate entry point.  */\n       /* Relocate for dynamic loading.  */\n-      valu += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));\n+      valu += section_offsets[SECT_OFF_TEXT (objfile)];\n       goto define_a_symbol;\n \n       /* The following symbol types we don't know how to process.\n@@ -2789,8 +2786,7 @@ process_one_symbol (int type, int desc, CORE_ADDR valu, const char *name,\n \t      /* Deal with the SunPRO 3.0 compiler which omits the\n \t         address from N_FUN symbols.  */\n \t      if (type == N_FUN\n-\t\t  && valu == ANOFFSET (section_offsets,\n-\t\t\t\t       SECT_OFF_TEXT (objfile))\n+\t\t  && valu == section_offsets[SECT_OFF_TEXT (objfile)]\n \t\t  && gdbarch_sofun_address_maybe_missing (gdbarch))\n \t\t{\n \t\t  struct bound_minimal_symbol minsym"
    },
    {
      "sha": "85f6c01b6ab09b0fd36a5085968640f6193adfe3",
      "filename": "gdb/dtrace-probe.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/dtrace-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/dtrace-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dtrace-probe.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -685,8 +685,8 @@ dtrace_probe::is_enabled () const\n CORE_ADDR\n dtrace_probe::get_relocated_address (struct objfile *objfile)\n {\n-  return this->get_address () + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t  SECT_OFF_DATA (objfile));\n+  return (this->get_address ()\n+\t  + objfile->section_offsets[SECT_OFF_DATA (objfile)]);\n }\n \n /* Implementation of the get_argument_count method.  */"
    },
    {
      "sha": "baa47c9438980c36c665fc899fc89fd44bf2b06e",
      "filename": "gdb/dwarf2-frame.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/dwarf2-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/dwarf2-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2-frame.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -384,8 +384,7 @@ execute_cfa_program (struct dwarf2_fde *fde, const gdb_byte *insn_ptr,\n \t\t\t\t\t   fde->cie->ptr_size, insn_ptr,\n \t\t\t\t\t   &bytes_read, fde->initial_location);\n \t      /* Apply the objfile offset for relocatable objects.  */\n-\t      fs->pc += ANOFFSET (fde->cie->unit->objfile->section_offsets,\n-\t\t\t\t  SECT_OFF_TEXT (fde->cie->unit->objfile));\n+\t      fs->pc += fde->cie->unit->objfile->section_offsets[SECT_OFF_TEXT (fde->cie->unit->objfile)];\n \t      insn_ptr += bytes_read;\n \t      break;\n \n@@ -1686,8 +1685,8 @@ dwarf2_frame_find_fde (CORE_ADDR *pc, CORE_ADDR *out_offset)\n       if (fde_table->num_entries == 0)\n \tcontinue;\n \n-      gdb_assert (objfile->section_offsets);\n-      offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+      gdb_assert (!objfile->section_offsets.empty ());\n+      offset = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n       gdb_assert (fde_table->num_entries > 0);\n       if (*pc < offset + fde_table->entries[0]->initial_location)"
    },
    {
      "sha": "04979f3d12fa6f8e365abe83290694f30b671125",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 22,
      "deletions": 27,
      "changes": 49,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -3170,7 +3170,7 @@ create_addrmap_from_index (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   iter = index->address_table.data ();\n   end = iter + index->address_table.size ();\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   while (iter < end)\n     {\n@@ -3216,8 +3216,7 @@ create_addrmap_from_aranges (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n   bfd *abfd = objfile->obfd;\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n-  const CORE_ADDR baseaddr = ANOFFSET (objfile->section_offsets,\n-\t\t\t\t       SECT_OFF_TEXT (objfile));\n+  const CORE_ADDR baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   auto_obstack temp_obstack;\n   addrmap *mutable_map = addrmap_create_mutable (&temp_obstack);\n@@ -5237,8 +5236,7 @@ dw2_find_pc_sect_compunit_symtab (struct objfile *objfile,\n   if (!objfile->partial_symtabs->psymtabs_addrmap)\n     return NULL;\n \n-  CORE_ADDR baseaddr = ANOFFSET (objfile->section_offsets,\n-\t\t\t\t SECT_OFF_TEXT (objfile));\n+  CORE_ADDR baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n   data = (struct dwarf2_per_cu_data *) addrmap_find\n     (objfile->partial_symtabs->psymtabs_addrmap, pc - baseaddr);\n   if (!data)\n@@ -8068,7 +8066,7 @@ process_psymtab_comp_unit_reader (const struct die_reader_specs *reader,\n   /* This must be done before calling dwarf2_build_include_psymtabs.  */\n   pst->dirname = dwarf2_string_attr (comp_unit_die, DW_AT_comp_dir, cu);\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   dwarf2_find_base_address (comp_unit_die, cu);\n \n@@ -8947,7 +8945,7 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n   const char *actual_name = NULL;\n   CORE_ADDR baseaddr;\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   gdb::unique_xmalloc_ptr<char> built_actual_name\n     = partial_die_full_name (pdi, cu);\n@@ -9190,8 +9188,7 @@ add_partial_subprogram (struct partial_die_info *pdi,\n \t      CORE_ADDR this_highpc;\n \t      CORE_ADDR this_lowpc;\n \n-\t      baseaddr = ANOFFSET (objfile->section_offsets,\n-\t\t\t\t   SECT_OFF_TEXT (objfile));\n+\t      baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \t      this_lowpc\n \t\t= (gdbarch_adjust_dwarf2_addr (gdbarch,\n \t\t\t\t\t       pdi->lowpc + baseaddr)\n@@ -10400,7 +10397,7 @@ process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,\n   struct block *static_block;\n   CORE_ADDR addr;\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   /* Clear the list here in case something was left over.  */\n   cu->method_list.clear ();\n@@ -11602,7 +11599,7 @@ read_file_scope (struct die_info *die, struct dwarf2_cu *cu)\n   CORE_ADDR baseaddr;\n \n   prepare_one_comp_unit (cu, die, cu->language);\n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   get_scope_pc_bounds (die, &lowpc, &highpc, cu);\n \n@@ -13716,7 +13713,7 @@ read_func_scope (struct die_info *die, struct dwarf2_cu *cu)\n \t}\n     }\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   name = dwarf2_name (die, cu);\n \n@@ -13895,7 +13892,7 @@ read_lexical_block_scope (struct die_info *die, struct dwarf2_cu *cu)\n   struct die_info *child_die;\n   CORE_ADDR baseaddr;\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   /* Ignore blocks with missing or invalid low and high pc attributes.  */\n   /* ??? Perhaps consider discontiguous blocks defined by DW_AT_ranges\n@@ -13969,7 +13966,7 @@ read_call_site_scope (struct die_info *die, struct dwarf2_cu *cu)\n   int nparams;\n   struct die_info *child_die;\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   attr = dwarf2_attr (die, DW_AT_call_return_pc, cu);\n   if (attr == NULL)\n@@ -14366,7 +14363,7 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n     }\n   buffer = dwarf2_per_objfile->rnglists.buffer + offset;\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   while (1)\n     {\n@@ -14534,7 +14531,7 @@ dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu,\n     }\n   buffer = dwarf2_per_objfile->ranges.buffer + offset;\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   while (1)\n     {\n@@ -14612,8 +14609,7 @@ dwarf2_ranges_read (unsigned offset, CORE_ADDR *low_return,\n {\n   struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n-  const CORE_ADDR baseaddr = ANOFFSET (objfile->section_offsets,\n-\t\t\t\t       SECT_OFF_TEXT (objfile));\n+  const CORE_ADDR baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n   int low_set = 0;\n   CORE_ADDR low = 0;\n   CORE_ADDR high = 0;\n@@ -21382,7 +21378,7 @@ dwarf_decode_lines_1 (struct line_header *lh, struct dwarf2_cu *cu,\n      the line number program).  */\n   bool record_lines_p = !decode_for_pst_p;\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   line_ptr = lh->statement_program_start;\n   line_end = lh->statement_program_end;\n@@ -21765,10 +21761,10 @@ var_decode_location (struct attribute *attr, struct symbol *sym,\n \t\t\t\t\t     &dummy));\n       SYMBOL_ACLASS_INDEX (sym) = LOC_STATIC;\n       fixup_symbol_section (sym, objfile);\n-      SET_SYMBOL_VALUE_ADDRESS (sym,\n-\t\t\t\tSYMBOL_VALUE_ADDRESS (sym)\n-\t\t\t\t+ ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t    SYMBOL_SECTION (sym)));\n+      SET_SYMBOL_VALUE_ADDRESS\n+\t(sym,\n+\t SYMBOL_VALUE_ADDRESS (sym)\n+\t + objfile->section_offsets[SYMBOL_SECTION (sym)]);\n       return;\n     }\n \n@@ -21810,7 +21806,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \n   int inlined_func = (die->tag == DW_TAG_inlined_subroutine);\n \n-  baseaddr = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   name = dwarf2_name (die, cu);\n   if (name)\n@@ -23608,8 +23604,7 @@ dwarf2_fetch_die_loc_sect_off (sect_offset sect_off,\n \t  != dwarf2_per_objfile->abstract_to_concrete.end ()))\n     {\n       CORE_ADDR pc = (*get_frame_pc) (baton);\n-      CORE_ADDR baseaddr\n-\t= ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+      CORE_ADDR baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n       struct gdbarch *gdbarch = get_objfile_arch (objfile);\n \n       for (const auto &cand_off\n@@ -25626,7 +25621,7 @@ dwarf2_per_cu_text_offset (struct dwarf2_per_cu_data *per_cu)\n {\n   struct objfile *objfile = per_cu->dwarf2_per_objfile->objfile;\n \n-  return ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  return objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n }\n \n /* Return a type that is a generic pointer type, the size of which matches"
    },
    {
      "sha": "34dec20298fb5217a014c19d2302e9b655247fa5",
      "filename": "gdb/hppa-bsd-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/hppa-bsd-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/hppa-bsd-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-bsd-tdep.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -87,8 +87,7 @@ hppabsd_find_global_pointer (struct gdbarch *gdbarch, struct value *function)\n \t\t     we have to do it ourselves.  */\n \t\t  pltgot = extract_unsigned_integer (buf, sizeof buf,\n \t\t\t\t\t\t     byte_order);\n-\t\t  pltgot += ANOFFSET (sec->objfile->section_offsets,\n-\t\t\t\t      SECT_OFF_TEXT (sec->objfile));\n+\t\t  pltgot += sec->objfile->section_offsets[SECT_OFF_TEXT (sec->objfile)];\n \n \t\t  return pltgot;\n \t\t}"
    },
    {
      "sha": "1ee1b0ba286e29836fa664b8c251448a652537e2",
      "filename": "gdb/hppa-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/hppa-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/hppa-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/hppa-tdep.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -357,7 +357,7 @@ read_unwind_info (struct objfile *objfile)\n   struct hppa_unwind_info *ui;\n   struct hppa_objfile_private *obj_private;\n \n-  text_offset = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  text_offset = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n   ui = (struct hppa_unwind_info *) obstack_alloc (&objfile->objfile_obstack,\n \t\t\t\t\t   sizeof (struct hppa_unwind_info));\n "
    },
    {
      "sha": "40d4fd3c19d3c80147008b5ffcbf64bdd8c28537",
      "filename": "gdb/ia64-tdep.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/ia64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/ia64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ia64-tdep.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -2713,7 +2713,7 @@ ia64_find_unwind_table (struct objfile *objfile, unw_word_t ip,\n   ehdr = elf_tdata (bfd)->elf_header;\n   phdr = elf_tdata (bfd)->phdr;\n \n-  load_base = ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+  load_base = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n   for (i = 0; i < ehdr->e_phnum; ++i)\n     {"
    },
    {
      "sha": "2bb3ab32cb30d21048479b6cd570b849180f16c8",
      "filename": "gdb/machoread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 6,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/machoread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/machoread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/machoread.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -907,12 +907,7 @@ macho_symfile_offsets (struct objfile *objfile,\n   struct obj_section *osect;\n \n   /* Allocate section_offsets.  */\n-  objfile->num_sections = bfd_count_sections (objfile->obfd);\n-  objfile->section_offsets = (struct section_offsets *)\n-    obstack_alloc (&objfile->objfile_obstack,\n-                   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));\n-  memset (objfile->section_offsets, 0,\n-          SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));\n+  objfile->section_offsets.assign (bfd_count_sections (objfile->obfd), 0);\n \n   /* This code is run when we first add the objfile with\n      symfile_add_with_addrs_or_offsets, when \"addrs\" not \"offsets\" are"
    },
    {
      "sha": "ff1d13032210447d0e6a80521cca11e2d6cc90c4",
      "filename": "gdb/mdebugread.c",
      "status": "modified",
      "additions": 9,
      "deletions": 15,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/mdebugread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/mdebugread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mdebugread.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -580,7 +580,7 @@ add_data_symbol (SYMR *sh, union aux_ext *ax, int bigend,\n \n static int\n parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n-\t      struct section_offsets *section_offsets, struct objfile *objfile)\n+\t      const section_offsets &section_offsets, struct objfile *objfile)\n {\n   struct gdbarch *gdbarch = get_objfile_arch (objfile);\n   const bfd_size_type external_sym_size = debug_swap->external_sym_size;\n@@ -610,18 +610,18 @@ parse_symbol (SYMR *sh, union aux_ext *ax, char *ext_sh, int bigend,\n          The value of a stBlock symbol is the displacement from the\n          procedure address.  */\n       if (sh->st != stEnd && sh->st != stBlock)\n-\tsh->value += ANOFFSET (section_offsets, SECT_OFF_TEXT (objfile));\n+\tsh->value += section_offsets[SECT_OFF_TEXT (objfile)];\n       break;\n     case scData:\n     case scSData:\n     case scRData:\n     case scPData:\n     case scXData:\n-      sh->value += ANOFFSET (section_offsets, SECT_OFF_DATA (objfile));\n+      sh->value += section_offsets[SECT_OFF_DATA (objfile)];\n       break;\n     case scBss:\n     case scSBss:\n-      sh->value += ANOFFSET (section_offsets, SECT_OFF_BSS (objfile));\n+      sh->value += section_offsets[SECT_OFF_BSS (objfile)];\n       break;\n     }\n \n@@ -2023,8 +2023,7 @@ parse_procedure (PDR *pr, struct compunit_symtab *search_symtab,\n       /* GDB expects the absolute function start address for the\n          procedure descriptor in e->pdr.adr.\n          As the address in the procedure descriptor is usually relative,\n-         we would have to relocate e->pdr.adr with cur_fdr->adr and\n-         ANOFFSET (pst->section_offsets, SECT_OFF_TEXT (pst->objfile)).\n+         we would have to relocate e->pdr.adr with cur_fdr->adr.\n          Unfortunately cur_fdr->adr and e->pdr.adr are both absolute\n          in shared libraries on some systems, and on other systems\n          e->pdr.adr is sometimes offset by a bogus value.\n@@ -2060,11 +2059,8 @@ parse_procedure (PDR *pr, struct compunit_symtab *search_symtab,\n \n    This routine clobbers top_stack->cur_block and ->cur_st.  */\n \n-static void parse_external (EXTR *, int, struct section_offsets *,\n-\t\t\t    struct objfile *);\n-\n static void\n-parse_external (EXTR *es, int bigend, struct section_offsets *section_offsets,\n+parse_external (EXTR *es, int bigend, const section_offsets &section_offsets,\n \t\tstruct objfile *objfile)\n {\n   union aux_ext *ax;\n@@ -3862,7 +3858,7 @@ psymtab_to_symtab_1 (struct objfile *objfile,\n   struct linetable *lines;\n   CORE_ADDR lowest_pdr_addr = 0;\n   int last_symtab_ended = 0;\n-  struct section_offsets *section_offsets = objfile->section_offsets;\n+  const section_offsets &section_offsets = objfile->section_offsets;\n \n   if (pst->readin)\n     return;\n@@ -3980,8 +3976,7 @@ psymtab_to_symtab_1 (struct objfile *objfile,\n \t\t      && previous_stab_code != (unsigned char) N_SO\n \t\t      && *name == '\\000')\n \t\t    {\n-\t\t      valu += ANOFFSET (section_offsets,\n-\t\t\t\t\tSECT_OFF_TEXT (objfile));\n+\t\t      valu += section_offsets[SECT_OFF_TEXT (objfile)];\n \t\t      previous_stab_code = N_SO;\n \t\t      cust = end_symtab (valu, SECT_OFF_TEXT (objfile));\n \t\t      end_stabs ();\n@@ -4028,8 +4023,7 @@ psymtab_to_symtab_1 (struct objfile *objfile,\n \t      else\n \t\t{\n \t\t  /* Handle encoded stab line number.  */\n-\t\t  valu += ANOFFSET (section_offsets,\n-\t\t\t\t    SECT_OFF_TEXT (objfile));\n+\t\t  valu += section_offsets[SECT_OFF_TEXT (objfile)];\n \t\t  record_line (get_current_subfile (), sh.index,\n \t\t\t       gdbarch_addr_bits_remove (gdbarch, valu));\n \t\t}"
    },
    {
      "sha": "2c11873d4449ce6021335f833779c0f82ecf3355",
      "filename": "gdb/mipsread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/mipsread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/mipsread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mipsread.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -43,7 +43,6 @@\n \n static void\n read_alphacoff_dynamic_symtab (minimal_symbol_reader &,\n-\t\t\t       struct section_offsets *,\n \t\t\t       struct objfile *objfile);\n \n /* Initialize anything that needs initializing when a completely new\n@@ -84,7 +83,7 @@ mipscoff_symfile_read (struct objfile *objfile, symfile_add_flags symfile_flags)\n \n   /* Add alpha coff dynamic symbols.  */\n \n-  read_alphacoff_dynamic_symtab (reader, objfile->section_offsets, objfile);\n+  read_alphacoff_dynamic_symtab (reader, objfile);\n \n   /* Install any minimal symbols that have been collected as the current\n      minimal symbols for this objfile.  */\n@@ -174,7 +173,6 @@ alphacoff_locate_sections (bfd *ignore_abfd, asection *sectp, void *sip)\n \n static void\n read_alphacoff_dynamic_symtab (minimal_symbol_reader &reader,\n-\t\t\t       struct section_offsets *section_offsets,\n \t\t\t       struct objfile *objfile)\n {\n   bfd *abfd = objfile->obfd;"
    },
    {
      "sha": "3138049e6223b3b45e6700d63c69c621e5d34ba4",
      "filename": "gdb/objfiles.c",
      "status": "modified",
      "additions": 24,
      "deletions": 41,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/objfiles.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/objfiles.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -391,9 +391,9 @@ entry_point_address_query (CORE_ADDR *entry_p)\n   if (symfile_objfile == NULL || !symfile_objfile->per_bfd->ei.entry_point_p)\n     return 0;\n \n+  int idx = symfile_objfile->per_bfd->ei.the_bfd_section_index;\n   *entry_p = (symfile_objfile->per_bfd->ei.entry_point\n-\t      + ANOFFSET (symfile_objfile->section_offsets,\n-\t\t\t  symfile_objfile->per_bfd->ei.the_bfd_section_index));\n+\t      + symfile_objfile->section_offsets[idx]);\n \n   return 1;\n }\n@@ -626,7 +626,7 @@ objfile::~objfile ()\n \n static void\n relocate_one_symbol (struct symbol *sym, struct objfile *objfile,\n-\t\t     struct section_offsets *delta)\n+\t\t     const section_offsets &delta)\n {\n   fixup_symbol_section (sym, objfile);\n \n@@ -640,7 +640,7 @@ relocate_one_symbol (struct symbol *sym, struct objfile *objfile,\n     {\n       SET_SYMBOL_VALUE_ADDRESS (sym,\n \t\t\t\tSYMBOL_VALUE_ADDRESS (sym)\n-\t\t\t\t+ ANOFFSET (delta, SYMBOL_SECTION (sym)));\n+\t\t\t\t+ delta[SYMBOL_SECTION (sym)]);\n     }\n }\n \n@@ -650,19 +650,16 @@ relocate_one_symbol (struct symbol *sym, struct objfile *objfile,\n \n static int\n objfile_relocate1 (struct objfile *objfile, \n-\t\t   const struct section_offsets *new_offsets)\n+\t\t   const section_offsets &new_offsets)\n {\n-  struct section_offsets *delta =\n-    ((struct section_offsets *) \n-     alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections)));\n+  section_offsets delta (objfile->section_offsets.size ());\n \n   int something_changed = 0;\n \n-  for (int i = 0; i < objfile->num_sections; ++i)\n+  for (int i = 0; i < objfile->section_offsets.size (); ++i)\n     {\n-      delta->offsets[i] =\n-\tANOFFSET (new_offsets, i) - ANOFFSET (objfile->section_offsets, i);\n-      if (ANOFFSET (delta, i) != 0)\n+      delta[i] = new_offsets[i] - objfile->section_offsets[i];\n+      if (delta[i] != 0)\n \tsomething_changed = 1;\n     }\n   if (!something_changed)\n@@ -681,9 +678,7 @@ objfile_relocate1 (struct objfile *objfile,\n \t    if (l)\n \t      {\n \t\tfor (int i = 0; i < l->nitems; ++i)\n-\t\t  l->item[i].pc += ANOFFSET (delta,\n-\t\t\t\t\t     COMPUNIT_BLOCK_LINE_SECTION\n-\t\t\t\t\t     (cust));\n+\t\t  l->item[i].pc += delta[COMPUNIT_BLOCK_LINE_SECTION (cust)];\n \t      }\n \t  }\n       }\n@@ -694,8 +689,7 @@ objfile_relocate1 (struct objfile *objfile,\n \tint block_line_section = COMPUNIT_BLOCK_LINE_SECTION (cust);\n \n \tif (BLOCKVECTOR_MAP (bv))\n-\t  addrmap_relocate (BLOCKVECTOR_MAP (bv),\n-\t\t\t    ANOFFSET (delta, block_line_section));\n+\t  addrmap_relocate (BLOCKVECTOR_MAP (bv), delta[block_line_section]);\n \n \tfor (int i = 0; i < BLOCKVECTOR_NBLOCKS (bv); ++i)\n \t  {\n@@ -704,16 +698,14 @@ objfile_relocate1 (struct objfile *objfile,\n \t    struct mdict_iterator miter;\n \n \t    b = BLOCKVECTOR_BLOCK (bv, i);\n-\t    BLOCK_START (b) += ANOFFSET (delta, block_line_section);\n-\t    BLOCK_END (b) += ANOFFSET (delta, block_line_section);\n+\t    BLOCK_START (b) += delta[block_line_section];\n+\t    BLOCK_END (b) += delta[block_line_section];\n \n \t    if (BLOCK_RANGES (b) != nullptr)\n \t      for (int j = 0; j < BLOCK_NRANGES (b); j++)\n \t\t{\n-\t\t  BLOCK_RANGE_START (b, j)\n-\t\t    += ANOFFSET (delta, block_line_section);\n-\t\t  BLOCK_RANGE_END (b, j) += ANOFFSET (delta,\n-\t\t\t\t\t\t      block_line_section);\n+\t\t  BLOCK_RANGE_START (b, j) += delta[block_line_section];\n+\t\t  BLOCK_RANGE_END (b, j) += delta[block_line_section];\n \t\t}\n \n \t    /* We only want to iterate over the local symbols, not any\n@@ -741,8 +733,8 @@ objfile_relocate1 (struct objfile *objfile,\n   {\n     int i;\n \n-    for (i = 0; i < objfile->num_sections; ++i)\n-      (objfile->section_offsets)->offsets[i] = ANOFFSET (new_offsets, i);\n+    for (i = 0; i < objfile->section_offsets.size (); ++i)\n+      objfile->section_offsets[i] = new_offsets[i];\n   }\n \n   /* Rebuild section map next time we need it.  */\n@@ -773,7 +765,7 @@ objfile_relocate1 (struct objfile *objfile,\n \n void\n objfile_relocate (struct objfile *objfile,\n-\t\t  const struct section_offsets *new_offsets)\n+\t\t  const section_offsets &new_offsets)\n {\n   int changed = 0;\n \n@@ -792,15 +784,13 @@ objfile_relocate (struct objfile *objfile,\n \n       addr_info_make_relative (&objfile_addrs, debug_objfile->obfd);\n \n-      gdb_assert (debug_objfile->num_sections\n+      gdb_assert (debug_objfile->section_offsets.size ()\n \t\t  == gdb_bfd_count_sections (debug_objfile->obfd));\n-      std::vector<struct section_offsets>\n-\tnew_debug_offsets (SIZEOF_N_SECTION_OFFSETS (debug_objfile->num_sections));\n-      relative_addr_info_to_section_offsets (new_debug_offsets.data (),\n-\t\t\t\t\t     debug_objfile->num_sections,\n-\t\t\t\t\t     objfile_addrs);\n+      section_offsets new_debug_offsets\n+\t(debug_objfile->section_offsets.size ());\n+      relative_addr_info_to_section_offsets (new_debug_offsets, objfile_addrs);\n \n-      changed |= objfile_relocate1 (debug_objfile, new_debug_offsets.data ());\n+      changed |= objfile_relocate1 (debug_objfile, new_debug_offsets);\n     }\n \n   /* Relocate breakpoints as necessary, after things are relocated.  */\n@@ -815,14 +805,7 @@ objfile_relocate (struct objfile *objfile,\n static int\n objfile_rebase1 (struct objfile *objfile, CORE_ADDR slide)\n {\n-  struct section_offsets *new_offsets =\n-    ((struct section_offsets *)\n-     alloca (SIZEOF_N_SECTION_OFFSETS (objfile->num_sections)));\n-  int i;\n-\n-  for (i = 0; i < objfile->num_sections; ++i)\n-    new_offsets->offsets[i] = slide;\n-\n+  section_offsets new_offsets (objfile->section_offsets.size (), slide);\n   return objfile_relocate1 (objfile, new_offsets);\n }\n "
    },
    {
      "sha": "1301f2c23fd215c64bd35bb9a27707d41a02e96c",
      "filename": "gdb/objfiles.h",
      "status": "modified",
      "additions": 3,
      "deletions": 5,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/objfiles.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/objfiles.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objfiles.h?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -141,7 +141,7 @@ struct obj_section\n \n /* Relocation offset applied to S.  */\n #define obj_section_offset(s)\t\t\t\t\t\t\\\n-  (((s)->objfile->section_offsets)->offsets[gdb_bfd_section_index ((s)->objfile->obfd, (s)->the_bfd_section)])\n+  (((s)->objfile->section_offsets)[gdb_bfd_section_index ((s)->objfile->obfd, (s)->the_bfd_section)])\n \n /* The memory address of section S (vma + offset).  */\n #define obj_section_addr(s)\t\t\t\t      \t\t\\\n@@ -560,14 +560,12 @@ struct objfile\n   /* Set of relocation offsets to apply to each section.\n      The table is indexed by the_bfd_section->index, thus it is generally\n      as large as the number of sections in the binary.\n-     The table is stored on the objfile_obstack.\n \n      These offsets indicate that all symbols (including partial and\n      minimal symbols) which have been read have been relocated by this\n      much.  Symbols which are yet to be read need to be relocated by it.  */\n \n-  struct section_offsets *section_offsets = nullptr;\n-  int num_sections = 0;\n+  ::section_offsets section_offsets;\n \n   /* Indexes in the section_offsets array.  These are initialized by the\n      *_symfile_offsets() family of functions (som_symfile_offsets,\n@@ -669,7 +667,7 @@ extern void build_objfile_section_table (struct objfile *);\n \n extern void free_objfile_separate_debug (struct objfile *);\n \n-extern void objfile_relocate (struct objfile *, const struct section_offsets *);\n+extern void objfile_relocate (struct objfile *, const section_offsets &);\n extern void objfile_rebase (struct objfile *, CORE_ADDR);\n \n extern int objfile_has_partial_symbols (struct objfile *objfile);"
    },
    {
      "sha": "e7630050e1803573ca22d4ca0c53bc9be8c30999",
      "filename": "gdb/psympriv.h",
      "status": "modified",
      "additions": 3,
      "deletions": 6,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/psympriv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/psympriv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psympriv.h?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -55,8 +55,7 @@ struct partial_symbol\n      the offsets provided in OBJFILE.  */\n   CORE_ADDR address (const struct objfile *objfile) const\n   {\n-    return (ginfo.value.address\n-\t    + ANOFFSET (objfile->section_offsets, ginfo.section));\n+    return ginfo.value.address + objfile->section_offsets[ginfo.section];\n   }\n \n   /* Set the address of this partial symbol.  The address must be\n@@ -120,15 +119,13 @@ struct partial_symtab\n   /* Return the relocated low text address of this partial_symtab.  */\n   CORE_ADDR text_low (struct objfile *objfile) const\n   {\n-    return m_text_low + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t  SECT_OFF_TEXT (objfile));\n+    return m_text_low + objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n   }\n \n   /* Return the relocated high text address of this partial_symtab.  */\n   CORE_ADDR text_high (struct objfile *objfile) const\n   {\n-    return m_text_high + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t   SECT_OFF_TEXT (objfile));\n+    return m_text_high + objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n   }\n \n   /* Set the low text address of this partial_symtab.  */"
    },
    {
      "sha": "7caf1c6029a993fc693daf1a625ba31bc75fbd62",
      "filename": "gdb/psymtab.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/psymtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/psymtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/psymtab.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -316,8 +316,7 @@ find_pc_sect_psymtab (struct objfile *objfile, CORE_ADDR pc,\n   if (objfile->partial_symtabs->psymtabs != NULL\n       && objfile->partial_symtabs->psymtabs_addrmap != NULL)\n     {\n-      CORE_ADDR baseaddr = ANOFFSET (objfile->section_offsets,\n-\t\t\t\t     SECT_OFF_TEXT (objfile));\n+      CORE_ADDR baseaddr = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n       struct partial_symtab *pst\n \t= ((struct partial_symtab *)"
    },
    {
      "sha": "082499e6e84644aa3c20d34d6b678f7c343186ae",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 4,
      "deletions": 8,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -4049,7 +4049,6 @@ remote_target::get_offsets ()\n   char *ptr;\n   int lose, num_segments = 0, do_sections, do_segments;\n   CORE_ADDR text_addr, data_addr, bss_addr, segments[2];\n-  struct section_offsets *offs;\n   struct symfile_segment_data *data;\n \n   if (symfile_objfile == NULL)\n@@ -4128,10 +4127,7 @@ remote_target::get_offsets ()\n   else if (*ptr != '\\0')\n     warning (_(\"Target reported unsupported offsets: %s\"), buf);\n \n-  offs = ((struct section_offsets *)\n-\t  alloca (SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections)));\n-  memcpy (offs, symfile_objfile->section_offsets,\n-\t  SIZEOF_N_SECTION_OFFSETS (symfile_objfile->num_sections));\n+  section_offsets offs = symfile_objfile->section_offsets;\n \n   data = get_symfile_segment_data (symfile_objfile->obfd);\n   do_segments = (data != NULL);\n@@ -4184,15 +4180,15 @@ remote_target::get_offsets ()\n \n   if (do_sections)\n     {\n-      offs->offsets[SECT_OFF_TEXT (symfile_objfile)] = text_addr;\n+      offs[SECT_OFF_TEXT (symfile_objfile)] = text_addr;\n \n       /* This is a temporary kludge to force data and bss to use the\n \t same offsets because that's what nlmconv does now.  The real\n \t solution requires changes to the stub and remote.c that I\n \t don't have time to do right now.  */\n \n-      offs->offsets[SECT_OFF_DATA (symfile_objfile)] = data_addr;\n-      offs->offsets[SECT_OFF_BSS (symfile_objfile)] = data_addr;\n+      offs[SECT_OFF_DATA (symfile_objfile)] = data_addr;\n+      offs[SECT_OFF_BSS (symfile_objfile)] = data_addr;\n     }\n \n   objfile_relocate (symfile_objfile, offs);"
    },
    {
      "sha": "f44ea937d9479a60380972873df4eaf969c582d6",
      "filename": "gdb/solib-aix.c",
      "status": "modified",
      "additions": 9,
      "deletions": 13,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-aix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-aix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-aix.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -390,19 +390,15 @@ solib_aix_clear_solib (void)\n }\n \n /* Compute and return the OBJFILE's section_offset array, using\n-   the associated loader info (INFO).\n+   the associated loader info (INFO).  */\n \n-   The resulting array is computed on the heap and must be\n-   deallocated after use.  */\n-\n-static gdb::unique_xmalloc_ptr<struct section_offsets>\n+static section_offsets\n solib_aix_get_section_offsets (struct objfile *objfile,\n \t\t\t       lm_info_aix *info)\n {\n   bfd *abfd = objfile->obfd;\n \n-  gdb::unique_xmalloc_ptr<struct section_offsets> offsets\n-    (XCNEWVEC (struct section_offsets, objfile->num_sections));\n+  section_offsets offsets (objfile->section_offsets.size ());\n \n   /* .text */\n \n@@ -411,7 +407,7 @@ solib_aix_get_section_offsets (struct objfile *objfile,\n       struct bfd_section *sect\n \t= objfile->sections[objfile->sect_index_text].the_bfd_section;\n \n-      offsets->offsets[objfile->sect_index_text]\n+      offsets[objfile->sect_index_text]\n \t= info->text_addr + sect->filepos - bfd_section_vma (sect);\n     }\n \n@@ -422,7 +418,7 @@ solib_aix_get_section_offsets (struct objfile *objfile,\n       struct bfd_section *sect\n \t= objfile->sections[objfile->sect_index_data].the_bfd_section;\n \n-      offsets->offsets[objfile->sect_index_data]\n+      offsets[objfile->sect_index_data]\n \t= info->data_addr - bfd_section_vma (sect);\n     }\n \n@@ -435,8 +431,8 @@ solib_aix_get_section_offsets (struct objfile *objfile,\n   if (objfile->sect_index_bss != -1\n       && objfile->sect_index_data != -1)\n     {\n-      offsets->offsets[objfile->sect_index_bss]\n-\t= (offsets->offsets[objfile->sect_index_data]\n+      offsets[objfile->sect_index_bss]\n+\t= (offsets[objfile->sect_index_data]\n \t   + solib_aix_bss_data_overlap (abfd));\n     }\n \n@@ -468,10 +464,10 @@ solib_aix_solib_create_inferior_hook (int from_tty)\n   lm_info_aix &exec_info = (*library_list)[0];\n   if (symfile_objfile != NULL)\n     {\n-      gdb::unique_xmalloc_ptr<struct section_offsets> offsets\n+      section_offsets offsets\n \t= solib_aix_get_section_offsets (symfile_objfile, &exec_info);\n \n-      objfile_relocate (symfile_objfile, offsets.get ());\n+      objfile_relocate (symfile_objfile, offsets);\n     }\n }\n "
    },
    {
      "sha": "52fa0e868aacd7746ddd4e3227d3e28d8bb52fc4",
      "filename": "gdb/solib-dsbt.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-dsbt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-dsbt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-dsbt.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -911,8 +911,7 @@ dsbt_relocate_main_executable (void)\n   info->main_executable_lm_info = new lm_info_dsbt;\n   info->main_executable_lm_info->map = ldm;\n \n-  gdb::unique_xmalloc_ptr<struct section_offsets> new_offsets\n-    (XCNEWVEC (struct section_offsets, symfile_objfile->num_sections));\n+  section_offsets new_offsets (symfile_objfile->section_offsets.size ());\n   changed = 0;\n \n   ALL_OBJFILE_OSECTIONS (symfile_objfile, osect)\n@@ -926,7 +925,7 @@ dsbt_relocate_main_executable (void)\n       /* Current address of section.  */\n       addr = obj_section_addr (osect);\n       /* Offset from where this section started.  */\n-      offset = ANOFFSET (symfile_objfile->section_offsets, osect_idx);\n+      offset = symfile_objfile->section_offsets[osect_idx];\n       /* Original address prior to any past relocations.  */\n       orig_addr = addr - offset;\n \n@@ -935,18 +934,18 @@ dsbt_relocate_main_executable (void)\n \t  if (ldm->segs[seg].p_vaddr <= orig_addr\n \t      && orig_addr < ldm->segs[seg].p_vaddr + ldm->segs[seg].p_memsz)\n \t    {\n-\t      new_offsets->offsets[osect_idx]\n+\t      new_offsets[osect_idx]\n \t\t= ldm->segs[seg].addr - ldm->segs[seg].p_vaddr;\n \n-\t      if (new_offsets->offsets[osect_idx] != offset)\n+\t      if (new_offsets[osect_idx] != offset)\n \t\tchanged = 1;\n \t      break;\n \t    }\n \t}\n     }\n \n   if (changed)\n-    objfile_relocate (symfile_objfile, new_offsets.get ());\n+    objfile_relocate (symfile_objfile, new_offsets);\n \n   /* Now that symfile_objfile has been relocated, we can compute the\n      GOT value and stash it away.  */"
    },
    {
      "sha": "10476f6250c94554c7ca6adef4609b34424fb018",
      "filename": "gdb/solib-frv.c",
      "status": "modified",
      "additions": 5,
      "deletions": 6,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-frv.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -785,8 +785,7 @@ frv_relocate_main_executable (void)\n   main_executable_lm_info = new lm_info_frv;\n   main_executable_lm_info->map = ldm;\n \n-  gdb::unique_xmalloc_ptr<struct section_offsets> new_offsets\n-    (XCNEWVEC (struct section_offsets, symfile_objfile->num_sections));\n+  section_offsets new_offsets (symfile_objfile->section_offsets.size ());\n   changed = 0;\n \n   ALL_OBJFILE_OSECTIONS (symfile_objfile, osect)\n@@ -800,7 +799,7 @@ frv_relocate_main_executable (void)\n       /* Current address of section.  */\n       addr = obj_section_addr (osect);\n       /* Offset from where this section started.  */\n-      offset = ANOFFSET (symfile_objfile->section_offsets, osect_idx);\n+      offset = symfile_objfile->section_offsets[osect_idx];\n       /* Original address prior to any past relocations.  */\n       orig_addr = addr - offset;\n \n@@ -809,18 +808,18 @@ frv_relocate_main_executable (void)\n \t  if (ldm->segs[seg].p_vaddr <= orig_addr\n \t      && orig_addr < ldm->segs[seg].p_vaddr + ldm->segs[seg].p_memsz)\n \t    {\n-\t      new_offsets->offsets[osect_idx]\n+\t      new_offsets[osect_idx]\n \t\t= ldm->segs[seg].addr - ldm->segs[seg].p_vaddr;\n \n-\t      if (new_offsets->offsets[osect_idx] != offset)\n+\t      if (new_offsets[osect_idx] != offset)\n \t\tchanged = 1;\n \t      break;\n \t    }\n \t}\n     }\n \n   if (changed)\n-    objfile_relocate (symfile_objfile, new_offsets.get ());\n+    objfile_relocate (symfile_objfile, new_offsets);\n \n   /* Now that symfile_objfile has been relocated, we can compute the\n      GOT value and stash it away.  */"
    },
    {
      "sha": "2d275f2b9c077d9b4b5242e359e6909e3347af49",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 3,
      "deletions": 11,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -2273,8 +2273,7 @@ enable_break (struct svr4_info *info, int from_tty)\n \t  CORE_ADDR load_addr;\n \n \t  tmp_bfd = os->objfile->obfd;\n-\t  load_addr = ANOFFSET (os->objfile->section_offsets,\n-\t\t\t\tSECT_OFF_TEXT (os->objfile));\n+\t  load_addr = os->objfile->section_offsets[SECT_OFF_TEXT (os->objfile)];\n \n \t  interp_sect = bfd_get_section_by_name (tmp_bfd, \".text\");\n \t  if (interp_sect)\n@@ -2975,15 +2974,8 @@ svr4_relocate_main_executable (void)\n \n   if (symfile_objfile)\n     {\n-      struct section_offsets *new_offsets;\n-      int i;\n-\n-      new_offsets = XALLOCAVEC (struct section_offsets,\n-\t\t\t\tsymfile_objfile->num_sections);\n-\n-      for (i = 0; i < symfile_objfile->num_sections; i++)\n-\tnew_offsets->offsets[i] = displacement;\n-\n+      section_offsets new_offsets (symfile_objfile->section_offsets.size (),\n+\t\t\t\t   displacement);\n       objfile_relocate (symfile_objfile, new_offsets);\n     }\n   else if (exec_bfd)"
    },
    {
      "sha": "625f0990d109e44c8081115970022ad040c086bf",
      "filename": "gdb/solib-target.c",
      "status": "modified",
      "additions": 7,
      "deletions": 9,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/solib-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-target.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -46,7 +46,7 @@ struct lm_info_target : public lm_info_base\n \n   /* The cached offsets for each section of this shared library,\n      determined from SEGMENT_BASES, or SECTION_BASES.  */\n-  gdb::unique_xmalloc_ptr<section_offsets> offsets;\n+  section_offsets offsets;\n };\n \n typedef std::vector<std::unique_ptr<lm_info_target>> lm_info_vector;\n@@ -305,12 +305,11 @@ solib_target_relocate_section_addresses (struct so_list *so,\n \n   /* Build the offset table only once per object file.  We can not do\n      it any earlier, since we need to open the file first.  */\n-  if (li->offsets == NULL)\n+  if (li->offsets.empty ())\n     {\n       int num_sections = gdb_bfd_count_sections (so->abfd);\n \n-      li->offsets.reset ((struct section_offsets *)\n-\t\t\t xzalloc (SIZEOF_N_SECTION_OFFSETS (num_sections)));\n+      li->offsets.assign (num_sections, 0);\n \n       if (!li->section_bases.empty ())\n \t{\n@@ -355,7 +354,7 @@ Could not relocate shared library \\\"%s\\\": wrong number of ALLOC sections\"),\n \t\t      gdb_assert (so->addr_low <= so->addr_high);\n \t\t      found_range = 1;\n \t\t    }\n-\t\t  li->offsets->offsets[i] = li->section_bases[bases_index];\n+\t\t  li->offsets[i] = li->section_bases[bases_index];\n \t\t  bases_index++;\n \t\t}\n \t      if (!found_range)\n@@ -377,7 +376,7 @@ Could not relocate shared library \\\"%s\\\": no segments\"), so->so_name);\n \t      int i;\n \n \t      if (!symfile_map_offsets_to_segments (so->abfd, data,\n-\t\t\t\t\t\t    li->offsets.get (),\n+\t\t\t\t\t\t    li->offsets,\n \t\t\t\t\t\t    li->segment_bases.size (),\n \t\t\t\t\t\t    li->segment_bases.data ()))\n \t\twarning (_(\"\\\n@@ -414,9 +413,8 @@ Could not relocate shared library \\\"%s\\\": bad offsets\"), so->so_name);\n \t}\n     }\n \n-  offset = li->offsets->offsets[gdb_bfd_section_index\n-\t\t\t        (sec->the_bfd_section->owner,\n-\t\t\t\t sec->the_bfd_section)];\n+  offset = li->offsets[gdb_bfd_section_index (sec->the_bfd_section->owner,\n+\t\t\t\t\t      sec->the_bfd_section)];\n   sec->addr += offset;\n   sec->endaddr += offset;\n }"
    },
    {
      "sha": "aa52a98e72d91804047fa2a9d89f221abfa60714",
      "filename": "gdb/stabsread.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/stabsread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/stabsread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stabsread.h?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -178,7 +178,7 @@ extern struct partial_symtab *dbx_end_psymtab\n    int textlow_not_set);\n \n extern void process_one_symbol (int, int, CORE_ADDR, const char *,\n-\t\t\t\tconst struct section_offsets *,\n+\t\t\t\tconst section_offsets &,\n \t\t\t\tstruct objfile *, enum language);\n \n extern void elfstab_build_psymtabs (struct objfile *objfile,"
    },
    {
      "sha": "5e9a043ffebaf9ec933630fdb7c0a2ff84c3bff3",
      "filename": "gdb/stap-probe.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/stap-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/stap-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stap-probe.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -1290,8 +1290,7 @@ stap_probe::parse_arguments (struct gdbarch *gdbarch)\n static CORE_ADDR\n relocate_address (CORE_ADDR address, struct objfile *objfile)\n {\n-  return address + ANOFFSET (objfile->section_offsets,\n-\t\t\t     SECT_OFF_DATA (objfile));\n+  return address + objfile->section_offsets[SECT_OFF_DATA (objfile)];\n }\n \n /* Implementation of the get_relocated_address method.  */"
    },
    {
      "sha": "0285f8fc34c1d4fa47dacf4370c45ef38a54e4cf",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 22,
      "deletions": 54,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -269,7 +269,7 @@ build_section_addr_info_from_objfile (const struct objfile *objfile)\n     {\n       int sectindex = sap[i].sectindex;\n \n-      sap[i].addr += objfile->section_offsets->offsets[sectindex];\n+      sap[i].addr += objfile->section_offsets[sectindex];\n     }\n   return sap;\n }\n@@ -315,14 +315,14 @@ init_objfile_sect_indices (struct objfile *objfile)\n      later, e.g. by the remote qOffsets packet, and then this will\n      be wrong!  That's why we try segments first.  */\n \n-  for (i = 0; i < objfile->num_sections; i++)\n+  for (i = 0; i < objfile->section_offsets.size (); i++)\n     {\n-      if (ANOFFSET (objfile->section_offsets, i) != 0)\n+      if (objfile->section_offsets[i] != 0)\n \t{\n \t  break;\n \t}\n     }\n-  if (i == objfile->num_sections)\n+  if (i == objfile->section_offsets.size ())\n     {\n       if (objfile->sect_index_text == -1)\n \tobjfile->sect_index_text = 0;\n@@ -339,7 +339,7 @@ init_objfile_sect_indices (struct objfile *objfile)\n \n struct place_section_arg\n {\n-  struct section_offsets *offsets;\n+  section_offsets *offsets;\n   CORE_ADDR lowest;\n };\n \n@@ -350,7 +350,8 @@ static void\n place_section (bfd *abfd, asection *sect, void *obj)\n {\n   struct place_section_arg *arg = (struct place_section_arg *) obj;\n-  CORE_ADDR *offsets = arg->offsets->offsets, start_addr;\n+  section_offsets &offsets = *arg->offsets;\n+  CORE_ADDR start_addr;\n   int done;\n   ULONGEST align = ((ULONGEST) 1) << bfd_section_alignment (sect);\n \n@@ -408,17 +409,15 @@ place_section (bfd *abfd, asection *sect, void *obj)\n }\n \n /* Store section_addr_info as prepared (made relative and with SECTINDEX\n-   filled-in) by addr_info_make_relative into SECTION_OFFSETS of NUM_SECTIONS\n-   entries.  */\n+   filled-in) by addr_info_make_relative into SECTION_OFFSETS.  */\n \n void\n-relative_addr_info_to_section_offsets (struct section_offsets *section_offsets,\n-\t\t\t\t       int num_sections,\n+relative_addr_info_to_section_offsets (section_offsets &section_offsets,\n \t\t\t\t       const section_addr_info &addrs)\n {\n   int i;\n \n-  memset (section_offsets, 0, SIZEOF_N_SECTION_OFFSETS (num_sections));\n+  section_offsets.assign (section_offsets.size (), 0);\n \n   /* Now calculate offsets for section that were specified by the caller.  */\n   for (i = 0; i < addrs.size (); i++)\n@@ -432,7 +431,7 @@ relative_addr_info_to_section_offsets (struct section_offsets *section_offsets,\n       /* Record all sections in offsets.  */\n       /* The section_offsets in the objfile are here filled in using\n          the BFD index.  */\n-      section_offsets->offsets[osp->sectindex] = osp->addr;\n+      section_offsets[osp->sectindex] = osp->addr;\n     }\n }\n \n@@ -636,12 +635,8 @@ void\n default_symfile_offsets (struct objfile *objfile,\n \t\t\t const section_addr_info &addrs)\n {\n-  objfile->num_sections = gdb_bfd_count_sections (objfile->obfd);\n-  objfile->section_offsets = (struct section_offsets *)\n-    obstack_alloc (&objfile->objfile_obstack,\n-\t\t   SIZEOF_N_SECTION_OFFSETS (objfile->num_sections));\n-  relative_addr_info_to_section_offsets (objfile->section_offsets,\n-\t\t\t\t\t objfile->num_sections, addrs);\n+  objfile->section_offsets.resize (gdb_bfd_count_sections (objfile->obfd));\n+  relative_addr_info_to_section_offsets (objfile->section_offsets, addrs);\n \n   /* For relocatable files, all loadable sections will start at zero.\n      The zero is meaningless, so try to pick arbitrary addresses such\n@@ -662,11 +657,11 @@ default_symfile_offsets (struct objfile *objfile,\n \n       if (cur_sec == NULL)\n \t{\n-\t  CORE_ADDR *offsets = objfile->section_offsets->offsets;\n+\t  section_offsets &offsets = objfile->section_offsets;\n \n \t  /* Pick non-overlapping offsets for sections the user did not\n \t     place explicitly.  */\n-\t  arg.offsets = objfile->section_offsets;\n+\t  arg.offsets = &objfile->section_offsets;\n \t  arg.lowest = 0;\n \t  bfd_map_over_sections (objfile->obfd, place_section, &arg);\n \n@@ -902,7 +897,7 @@ init_entry_point_info (struct objfile *objfile)\n    (as gleaned by GDB's shared library code).  We convert each address\n    into an offset from the section VMA's as it appears in the object\n    file, and then call the file's sym_offsets function to convert this\n-   into a format-specific offset table --- a `struct section_offsets'.\n+   into a format-specific offset table --- a `section_offsets'.\n    The sectindex field is used to control the ordering of sections\n    with the same name.  Upon return, it is updated to contain the\n    corresponding BFD section index, or -1 if the section was not found.\n@@ -926,13 +921,8 @@ syms_from_objfile_1 (struct objfile *objfile,\n       /* No symbols to load, but we still need to make sure\n \t that the section_offsets table is allocated.  */\n       int num_sections = gdb_bfd_count_sections (objfile->obfd);\n-      size_t size = SIZEOF_N_SECTION_OFFSETS (num_sections);\n \n-      objfile->num_sections = num_sections;\n-      objfile->section_offsets\n-\t= (struct section_offsets *) obstack_alloc (&objfile->objfile_obstack,\n-\t\t\t\t\t\t    size);\n-      memset (objfile->section_offsets, 0, size);\n+      objfile->section_offsets.assign (num_sections, 0);\n       return;\n     }\n \n@@ -2164,8 +2154,7 @@ set_objfile_default_section_offset (struct objfile *objf,\n \t\t\t\t    CORE_ADDR offset)\n {\n   /* Add OFFSET to all sections by default.  */\n-  std::vector<struct section_offsets> offsets (objf->num_sections,\n-\t\t\t\t\t       { { offset } });\n+  section_offsets offsets (objf->section_offsets.size (), offset);\n \n   /* Create sorted lists of all sections in ADDRS as well as all\n      sections in OBJF.  */\n@@ -2203,11 +2192,11 @@ set_objfile_default_section_offset (struct objfile *objf,\n \t}\n \n       if (cmp == 0)\n-\toffsets[objf_sect->sectindex].offsets[0] = 0;\n+\toffsets[objf_sect->sectindex] = 0;\n     }\n \n   /* Apply the new section offsets.  */\n-  objfile_relocate (objf, offsets.data ());\n+  objfile_relocate (objf, offsets);\n }\n \n /* This function allows the addition of incrementally linked object files.\n@@ -2479,9 +2468,6 @@ reread_symbols (void)\n       new_modtime = new_statbuf.st_mtime;\n       if (new_modtime != objfile->mtime)\n \t{\n-\t  struct section_offsets *offsets;\n-\t  int num_offsets;\n-\n \t  printf_filtered (_(\"`%s' has changed; re-reading symbols.\\n\"),\n \t\t\t   objfile_name (objfile));\n \n@@ -2556,14 +2542,6 @@ reread_symbols (void)\n \t    error (_(\"Can't read symbols from %s: %s.\"), objfile_name (objfile),\n \t\t   bfd_errmsg (bfd_get_error ()));\n \n-\t  /* Save the offsets, we will nuke them with the rest of the\n-\t     objfile_obstack.  */\n-\t  num_offsets = objfile->num_sections;\n-\t  offsets = ((struct section_offsets *)\n-\t\t     alloca (SIZEOF_N_SECTION_OFFSETS (num_offsets)));\n-\t  memcpy (offsets, objfile->section_offsets,\n-\t\t  SIZEOF_N_SECTION_OFFSETS (num_offsets));\n-\n \t  objfile->reset_psymtabs ();\n \n \t  /* NB: after this call to obstack_free, objfiles_changed\n@@ -2595,15 +2573,6 @@ reread_symbols (void)\n \n \t  build_objfile_section_table (objfile);\n \n-\t  /* We use the same section offsets as from last time.  I'm not\n-\t     sure whether that is always correct for shared libraries.  */\n-\t  objfile->section_offsets = (struct section_offsets *)\n-\t    obstack_alloc (&objfile->objfile_obstack,\n-\t\t\t   SIZEOF_N_SECTION_OFFSETS (num_offsets));\n-\t  memcpy (objfile->section_offsets, offsets,\n-\t\t  SIZEOF_N_SECTION_OFFSETS (num_offsets));\n-\t  objfile->num_sections = num_offsets;\n-\n \t  /* What the hell is sym_new_init for, anyway?  The concept of\n \t     distinguishing between the main file and additional files\n \t     in this way seems rather dubious.  */\n@@ -3705,7 +3674,7 @@ free_symfile_segment_data (struct symfile_segment_data *data)\n int\n symfile_map_offsets_to_segments (bfd *abfd,\n \t\t\t\t const struct symfile_segment_data *data,\n-\t\t\t\t struct section_offsets *offsets,\n+\t\t\t\t section_offsets &offsets,\n \t\t\t\t int num_segment_bases,\n \t\t\t\t const CORE_ADDR *segment_bases)\n {\n@@ -3737,8 +3706,7 @@ symfile_map_offsets_to_segments (bfd *abfd,\n       if (which > num_segment_bases)\n         which = num_segment_bases;\n \n-      offsets->offsets[i] = (segment_bases[which - 1]\n-                             - data->segment_bases[which - 1]);\n+      offsets[i] = segment_bases[which - 1] - data->segment_bases[which - 1];\n     }\n \n   return 1;"
    },
    {
      "sha": "5b349752d5091a05dd78dda0a53a70c777a474a4",
      "filename": "gdb/symfile.h",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symfile.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symfile.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.h?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -373,8 +373,7 @@ extern section_addr_info\n   build_section_addr_info_from_objfile (const struct objfile *objfile);\n \n extern void relative_addr_info_to_section_offsets\n-  (struct section_offsets *section_offsets, int num_sections,\n-   const section_addr_info &addrs);\n+  (section_offsets &section_offsets, const section_addr_info &addrs);\n \n extern void addr_info_make_relative (section_addr_info *addrs,\n \t\t\t\t     bfd *abfd);\n@@ -515,7 +514,7 @@ extern bfd_byte *symfile_relocate_debug_section (struct objfile *, asection *,\n \n extern int symfile_map_offsets_to_segments (bfd *,\n \t\t\t\t\t    const struct symfile_segment_data *,\n-\t\t\t\t\t    struct section_offsets *,\n+\t\t\t\t\t    section_offsets &,\n \t\t\t\t\t    int, const CORE_ADDR *);\n struct symfile_segment_data *get_symfile_segment_data (bfd *abfd);\n void free_symfile_segment_data (struct symfile_segment_data *data);"
    },
    {
      "sha": "a5b17ffa3810e4c8a6b5440178515b651421e611",
      "filename": "gdb/symmisc.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symmisc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symmisc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symmisc.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -240,8 +240,7 @@ dump_msymbols (struct objfile *objfile, struct ui_file *outfile)\n       /* Use the relocated address as shown in the symbol here -- do\n \t not try to respect copy relocations.  */\n       CORE_ADDR addr = (msymbol->value.address\n-\t\t\t+ ANOFFSET (objfile->section_offsets,\n-\t\t\t\t    msymbol->section));\n+\t\t\t+ objfile->section_offsets[msymbol->section]);\n       fputs_filtered (paddress (gdbarch, addr), outfile);\n       fprintf_filtered (outfile, \" %s\", msymbol->linkage_name ());\n       if (section)"
    },
    {
      "sha": "5274b88f7ab538fe1d918c40b5021d46a94de557",
      "filename": "gdb/symtab.c",
      "status": "modified",
      "additions": 6,
      "deletions": 8,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -1687,11 +1687,10 @@ fixup_section (struct general_symbol_info *ginfo,\n \n \t So, instead, search the section table when lookup by name has\n \t failed.  The ``addr'' and ``endaddr'' fields may have already\n-\t been relocated.  If so, the relocation offset (i.e. the\n-\t ANOFFSET value) needs to be subtracted from these values when\n-\t performing the comparison.  We unconditionally subtract it,\n-\t because, when no relocation has been performed, the ANOFFSET\n-\t value will simply be zero.\n+\t been relocated.  If so, the relocation offset needs to be\n+\t subtracted from these values when performing the comparison.\n+\t We unconditionally subtract it, because, when no relocation\n+\t has been performed, the value will simply be zero.\n \n \t The address of the symbol whose section we're fixing up HAS\n \t NOT BEEN adjusted (relocated) yet.  It can't have been since\n@@ -1717,7 +1716,7 @@ fixup_section (struct general_symbol_info *ginfo,\n       ALL_OBJFILE_OSECTIONS (objfile, s)\n \t{\n \t  int idx = s - objfile->sections;\n-\t  CORE_ADDR offset = ANOFFSET (objfile->section_offsets, idx);\n+\t  CORE_ADDR offset = objfile->section_offsets[idx];\n \n \t  if (fallback == -1)\n \t    fallback = idx;\n@@ -6373,8 +6372,7 @@ get_msymbol_address (struct objfile *objf, const struct minimal_symbol *minsym)\n \t    return BMSYMBOL_VALUE_ADDRESS (found);\n \t}\n     }\n-  return (minsym->value.address\n-\t  + ANOFFSET (objf->section_offsets, minsym->section));\n+  return minsym->value.address + objf->section_offsets[minsym->section];\n }\n \n \f"
    },
    {
      "sha": "5fa067b5f48d921b70e2404ee9643297fe81e25f",
      "filename": "gdb/symtab.h",
      "status": "modified",
      "additions": 3,
      "deletions": 22,
      "changes": 25,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symtab.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/symtab.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symtab.h?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -726,7 +726,7 @@ extern CORE_ADDR get_msymbol_address (struct objfile *objf,\n #define MSYMBOL_VALUE_ADDRESS(objfile, symbol)\t\t\t\t\\\n   (((symbol)->maybe_copied) ? get_msymbol_address (objfile, symbol)\t\\\n    : ((symbol)->value.address\t\t\t\t\t\t\\\n-      + ANOFFSET ((objfile)->section_offsets, ((symbol)->section))))\n+      + (objfile)->section_offsets[(symbol)->section]))\n /* For a bound minsym, we can easily compute the address directly.  */\n #define BMSYMBOL_VALUE_ADDRESS(symbol) \\\n   MSYMBOL_VALUE_ADDRESS ((symbol).objfile, (symbol).minsym)\n@@ -1309,30 +1309,11 @@ struct linetable\n };\n \n /* How to relocate the symbols from each section in a symbol file.\n-   Each struct contains an array of offsets.\n    The ordering and meaning of the offsets is file-type-dependent;\n    typically it is indexed by section numbers or symbol types or\n-   something like that.\n+   something like that.  */\n \n-   To give us flexibility in changing the internal representation\n-   of these offsets, the ANOFFSET macro must be used to insert and\n-   extract offset values in the struct.  */\n-\n-struct section_offsets\n-{\n-  CORE_ADDR offsets[1];\t\t/* As many as needed.  */\n-};\n-\n-#define\tANOFFSET(secoff, whichone) \\\n-  ((whichone == -1)\t\t\t  \\\n-   ? (internal_error (__FILE__, __LINE__, \\\n-\t\t      _(\"Section index is uninitialized\")), -1) \\\n-   : secoff->offsets[whichone])\n-\n-/* The size of a section_offsets table for N sections.  */\n-#define SIZEOF_N_SECTION_OFFSETS(n) \\\n-  (sizeof (struct section_offsets) \\\n-   + sizeof (((struct section_offsets *) 0)->offsets) * ((n)-1))\n+typedef std::vector<CORE_ADDR> section_offsets;\n \n /* Each source file or header is represented by a struct symtab.\n    The name \"symtab\" is historical, another name for it is \"filetab\"."
    },
    {
      "sha": "d0fa90e49fb6b670fd1f49fbc5656a14488c853d",
      "filename": "gdb/xcoffread.c",
      "status": "modified",
      "additions": 9,
      "deletions": 15,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/xcoffread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/6a053cb1ff643cec3349d7f2f47ae5573f82d613/gdb/xcoffread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xcoffread.c?ref=6a053cb1ff643cec3349d7f2f47ae5573f82d613",
      "patch": "@@ -864,7 +864,7 @@ enter_line_range (struct subfile *subfile, unsigned beginoffset,\n       addr = (int_lnno.l_lnno\n \t      ? int_lnno.l_addr.l_paddr\n \t      : read_symbol_nvalue (int_lnno.l_addr.l_symndx));\n-      addr += ANOFFSET (objfile->section_offsets, SECT_OFF_TEXT (objfile));\n+      addr += objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n       if (addr < startaddr || (endaddr && addr >= endaddr))\n \treturn;\n@@ -1232,8 +1232,7 @@ read_xcoff_symtab (struct objfile *objfile, struct partial_symtab *pst)\n \t\t\t}\n \n \t\t      file_start_addr =\n-\t\t\tcs->c_value + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t\tSECT_OFF_TEXT (objfile));\n+\t\t\tcs->c_value + objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \t\t      file_end_addr = file_start_addr + CSECT_LEN (&main_aux);\n \n \t\t      if (cs->c_name && (cs->c_name[0] == '.' || cs->c_name[0] == '@'))\n@@ -1355,8 +1354,7 @@ read_xcoff_symtab (struct objfile *objfile, struct partial_symtab *pst)\n \tcase C_FCN:\n \t  if (strcmp (cs->c_name, \".bf\") == 0)\n \t    {\n-\t      CORE_ADDR off = ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\tSECT_OFF_TEXT (objfile));\n+\t      CORE_ADDR off = objfile->section_offsets[SECT_OFF_TEXT (objfile)];\n \n \t      bfd_coff_swap_aux_in (abfd, raw_auxptr, cs->c_type, cs->c_sclass,\n \t\t\t\t    0, cs->c_naux, &main_aux);\n@@ -1400,8 +1398,7 @@ read_xcoff_symtab (struct objfile *objfile, struct partial_symtab *pst)\n \t\t\t    NULL, cstk.start_addr,\n \t\t\t    (fcn_cs_saved.c_value\n \t\t\t     + fcn_aux_saved.x_sym.x_misc.x_fsize\n-\t\t\t     + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t SECT_OFF_TEXT (objfile))));\n+\t\t\t     + objfile->section_offsets[SECT_OFF_TEXT (objfile)]));\n \t      within_function = 0;\n \t    }\n \t  break;\n@@ -1468,8 +1465,7 @@ read_xcoff_symtab (struct objfile *objfile, struct partial_symtab *pst)\n \t      depth++;\n \t      newobj = push_context (depth,\n \t\t\t\t  (cs->c_value\n-\t\t\t\t   + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t       SECT_OFF_TEXT (objfile))));\n+\t\t\t\t   + objfile->section_offsets[SECT_OFF_TEXT (objfile)]));\n \t    }\n \t  else if (strcmp (cs->c_name, \".eb\") == 0)\n \t    {\n@@ -1491,8 +1487,7 @@ read_xcoff_symtab (struct objfile *objfile, struct partial_symtab *pst)\n \t\t\t\tcstk.old_blocks, NULL,\n \t\t\t\tcstk.start_addr,\n \t\t\t\t(cs->c_value\n-\t\t\t\t + ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t     SECT_OFF_TEXT (objfile))));\n+\t\t\t\t + objfile->section_offsets[SECT_OFF_TEXT (objfile)]));\n \t\t}\n \t      *get_local_symbols () = cstk.locals;\n \t    }\n@@ -1554,7 +1549,7 @@ process_xcoff_symbol (struct coff_symbol *cs, struct objfile *objfile)\n   else\n     {\n       sec = secnum_to_section (cs->c_secnum, objfile);\n-      off = ANOFFSET (objfile->section_offsets, sec);\n+      off = objfile->section_offsets[sec];\n     }\n \n   name = cs->c_name;\n@@ -1657,8 +1652,7 @@ process_xcoff_symbol (struct coff_symbol *cs, struct objfile *objfile)\n \t  if (*pp == 'V' && !within_function)\n \t    *pp = 'S';\n \t  sym = define_symbol ((cs->c_value\n-\t\t\t\t+ ANOFFSET (objfile->section_offsets,\n-\t\t\t\t\t    static_block_section)),\n+\t\t\t\t+ objfile->section_offsets[static_block_section]),\n \t\t\t       cs->c_name, 0, 0, objfile);\n \t  if (sym != NULL)\n \t    {\n@@ -3024,7 +3018,7 @@ xcoff_symfile_offsets (struct objfile *objfile,\n      us to test whether the associated section exists or not, and then\n      access it quickly (without searching it again).  */\n \n-  if (objfile->num_sections == 0)\n+  if (objfile->section_offsets.empty ())\n     return; /* Is that even possible?  Better safe than sorry.  */\n \n   first_section_name = bfd_section_name (objfile->sections[0].the_bfd_section);"
    }
  ]
}