{
  "sha": "c9f279910113d6a10cb64d81aba2c1af9f3c228c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YzlmMjc5OTEwMTEzZDZhMTBjYjY0ZDgxYWJhMmMxYWY5ZjNjMjI4Yw==",
  "commit": {
    "author": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-09-16T06:36:54Z"
    },
    "committer": {
      "name": "Nelson Chu",
      "email": "nelson.chu@sifive.com",
      "date": "2021-09-17T08:33:54Z"
    },
    "message": "RISC-V: Merged extension string tables and their version tables into one.\n\nThere are two main reasons for this patch,\n\n* In the past we had two extension tables, one is used to record all\nsupported extensions in bfd/elfxx-riscv.c, another is used to get the\ndefault extension versions in gas/config/tc-riscv.c.  It is hard to\nmaintain lots of tables in different files, but in fact we can merge\nthem into just one table.  Therefore, we now define many riscv_supported_std*\ntables, which record names and versions for all supported extensions.\nWe not only use these tables to initialize the riscv_ext_order, but\nalso use them to get the default versions of extensions, and decide if\nthe extensions should be enbaled by default.\n\n* We add a new filed `default_enable' for the riscv_supported_std* tables,\nto decide if the extension should be enabled by default.  For now if the\n`default_enable' field of the extension is set to EXT_DEFAULT, then we\nshould enable the extension when the -march and elf architecture attributes\nare not set.  In the future, I suppose the `default_enable' can be set\nto lots of EXT_<VENDOR>, each vendor can decide to open which extensions,\nwhen the target triple of vendor is chosen.\n\nThe elf/linux regression tests of riscv-gnu-toolchain are passed.\n\nbfd/\n\t* elfnn-riscv.c (cpu-riscv.h): Removed sine it is included in\n\tbfd/elfxx-riscv.h.\n\t(riscv_merge_std_ext): Updated since the field of rpe is changed.\n\t* elfxx-riscv.c (cpu-riscv.h): Removed.\n\t(riscv_implicit_subsets): Added implicit extensions for g.\n\t(struct riscv_supported_ext): Used to be riscv_ext_version.  Moved\n\tfrom gas/config/tc-riscv.c, and added new field `default_enable' to\n\tdecide if the extension should be enabled by default.\n\t(EXT_DEFAULT): Defined for `default_enable' field.\n\t(riscv_supported_std_ext): It used to return the supported standard\n\tarchitecture string, but now we move ext_version_table from\n\tgas/config/tc-riscv.c to here, and rename it to riscv_supported_std_ext.\n\tCurrently we not only use the table to initialize riscv_ext_order, but\n\talso get the default versions of extensions, and decide if the extensions\n\tshould be enbaled by default.\n\t(riscv_supported_std_z_ext): Likewise, but is used for z* extensions.\n\t(riscv_supported_std_s_ext): Likewise, but is used for s* extensions.\n\t(riscv_supported_std_h_ext): Likewise, but is used for h* extensions.\n\t(riscv_supported_std_zxm_ext): Likewise, but is used for zxm* extensions.\n\t(riscv_all_supported_ext): Includes all supported extension tables.\n\t(riscv_known_prefixed_ext): Updated.\n\t(riscv_valid_prefixed_ext): Updated.\n\t(riscv_init_ext_order): Init the riscv_ext_order table according to\n\triscv_supported_std_ext.\n\t(riscv_get_default_ext_version): Moved from gas/config/tc-riscv.c.\n\tGet the versions of extensions from riscv_supported_std* tables.\n\t(riscv_parse_add_subset): Updated.\n\t(riscv_parse_std_ext): Updated.\n\t(riscv_set_default_arch): Set the default subset list according to\n\tthe default_enable field of riscv_supported_*ext tables.\n\t(riscv_parse_subset): If the input ARCH is NULL, then we call\n\triscv_set_default_arch to set the default subset list.\n\t* elfxx-riscv.h (cpu-riscv.h): Included.\n\t(riscv_parse_subset_t): Removed get_default_version field, and added\n\tisa_spec field to replace it.\n\t(extern riscv_supported_std_ext): Removed.\ngas/\n\t* (bfd/cpu-riscv.h): Removed.\n\t(struct riscv_ext_version): Renamed and moved to bfd/elfxx-riscv.c.\n\t(ext_version_table): Likewise.\n\t(riscv_get_default_ext_version): Likewise.\n\t(ext_version_hash): Removed.\n\t(init_ext_version_hash): Removed.\n\t(riscv_set_arch): Updated since the field of rps is changed.  Besides,\n\treport error when the architecture string is empty.\n\t(riscv_after_parse_args): Updated.",
    "tree": {
      "sha": "f6c97bc6b142ac2025b70fba59dd491251509310",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f6c97bc6b142ac2025b70fba59dd491251509310"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c9f279910113d6a10cb64d81aba2c1af9f3c228c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c9f279910113d6a10cb64d81aba2c1af9f3c228c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c9f279910113d6a10cb64d81aba2c1af9f3c228c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c9f279910113d6a10cb64d81aba2c1af9f3c228c/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "648d5dc4e6032c66f76638604cd577c529f84bc5",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/648d5dc4e6032c66f76638604cd577c529f84bc5",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/648d5dc4e6032c66f76638604cd577c529f84bc5"
    }
  ],
  "stats": {
    "total": 491,
    "additions": 235,
    "deletions": 256
  },
  "files": [
    {
      "sha": "2e8df72fa2a8121f25bc96d7883ac1416f84483a",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c9f279910113d6a10cb64d81aba2c1af9f3c228c/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c9f279910113d6a10cb64d81aba2c1af9f3c228c/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=c9f279910113d6a10cb64d81aba2c1af9f3c228c",
      "patch": "@@ -32,7 +32,6 @@\n #include \"elf/riscv.h\"\n #include \"opcode/riscv.h\"\n #include \"objalloc.h\"\n-#include \"cpu-riscv.h\"\n \n #include <limits.h>\n #ifndef CHAR_BIT\n@@ -3443,7 +3442,7 @@ riscv_merge_std_ext (bfd *ibfd,\n \t\t     struct riscv_subset_t **pin,\n \t\t     struct riscv_subset_t **pout)\n {\n-  const char *standard_exts = riscv_supported_std_ext ();\n+  const char *standard_exts = \"mafdqlcbjtpvn\";\n   const char *p;\n   struct riscv_subset_t *in = *pin;\n   struct riscv_subset_t *out = *pout;\n@@ -3587,13 +3586,13 @@ riscv_merge_arch_attr_info (bfd *ibfd, char *in_arch, char *out_arch)\n   rpe_in.subset_list = &in_subsets;\n   rpe_in.error_handler = _bfd_error_handler;\n   rpe_in.xlen = &xlen_in;\n-  rpe_in.get_default_version = NULL;\n+  rpe_in.isa_spec = ISA_SPEC_CLASS_NONE;\n   rpe_in.check_unknown_prefixed_ext = false;\n \n   rpe_out.subset_list = &out_subsets;\n   rpe_out.error_handler = _bfd_error_handler;\n   rpe_out.xlen = &xlen_out;\n-  rpe_out.get_default_version = NULL;\n+  rpe_out.isa_spec = ISA_SPEC_CLASS_NONE;\n   rpe_out.check_unknown_prefixed_ext = false;\n \n   if (in_arch == NULL && out_arch == NULL)"
    },
    {
      "sha": "b467bceb919de1236b6b878af81e72146e1bffb7",
      "filename": "bfd/elfxx-riscv.c",
      "status": "modified",
      "additions": 223,
      "deletions": 127,
      "changes": 350,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c9f279910113d6a10cb64d81aba2c1af9f3c228c/bfd/elfxx-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c9f279910113d6a10cb64d81aba2c1af9f3c228c/bfd/elfxx-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-riscv.c?ref=c9f279910113d6a10cb64d81aba2c1af9f3c228c",
      "patch": "@@ -29,7 +29,6 @@\n #include \"libiberty.h\"\n #include \"elfxx-riscv.h\"\n #include \"safe-ctype.h\"\n-#include \"cpu-riscv.h\"\n \n #define MINUS_ONE ((bfd_vma)0 - 1)\n \n@@ -1066,6 +1065,11 @@ static struct riscv_implicit_subset riscv_implicit_subsets[] =\n   {\"e\", \"i\",\t\tcheck_implicit_always},\n   {\"i\", \"zicsr\",\tcheck_implicit_for_i},\n   {\"i\", \"zifencei\",\tcheck_implicit_for_i},\n+  {\"g\", \"i\",\t\tcheck_implicit_always},\n+  {\"g\", \"m\",\t\tcheck_implicit_always},\n+  {\"g\", \"a\",\t\tcheck_implicit_always},\n+  {\"g\", \"f\",\t\tcheck_implicit_always},\n+  {\"g\", \"d\",\t\tcheck_implicit_always},\n   {\"g\", \"zicsr\",\tcheck_implicit_always},\n   {\"g\", \"zifencei\",\tcheck_implicit_always},\n   {\"q\", \"d\",\t\tcheck_implicit_always},\n@@ -1074,31 +1078,98 @@ static struct riscv_implicit_subset riscv_implicit_subsets[] =\n   {NULL, NULL, NULL}\n };\n \n-/* Lists of prefixed class extensions that binutils should know about.\n-   Whether or not a particular entry is in these lists will dictate if\n-   gas/ld will accept its presence in the architecture string.\n+/* For default_enable field, decide if the extension should\n+   be enbaled by default.  */\n \n-   Please add the extensions to the lists in lower case.  However, keep\n-   these subsets in alphabetical order in these tables is recommended,\n-   although there is no impact on the current implementation.  */\n+#define EXT_DEFAULT   0x1\n \n-static const char * const riscv_std_z_ext_strtab[] =\n+/* List all extensions that binutils should know about.  */\n+\n+struct riscv_supported_ext\n {\n-  \"zba\", \"zbb\", \"zbc\", \"zicsr\", \"zifencei\", \"zihintpause\", NULL\n+  const char *name;\n+  enum riscv_spec_class isa_spec_class;\n+  int major_version;\n+  int minor_version;\n+  unsigned long default_enable;\n };\n \n-static const char * const riscv_std_s_ext_strtab[] =\n+/* The standard extensions must be added in canonical order.  */\n+\n+static struct riscv_supported_ext riscv_supported_std_ext[] =\n {\n-  NULL\n+  {\"e\",\t\tISA_SPEC_CLASS_20191213,\t1, 9, 0 },\n+  {\"e\",\t\tISA_SPEC_CLASS_20190608,\t1, 9, 0 },\n+  {\"e\",\t\tISA_SPEC_CLASS_2P2,\t\t1, 9, 0 },\n+  {\"i\",\t\tISA_SPEC_CLASS_20191213,\t2, 1, 0 },\n+  {\"i\",\t\tISA_SPEC_CLASS_20190608,\t2, 1, 0 },\n+  {\"i\",\t\tISA_SPEC_CLASS_2P2,\t\t2, 0, 0 },\n+  /* The g is a special case which we don't want to output it,\n+     but still need it when adding implicit extensions.  */\n+  {\"g\",\t\tISA_SPEC_CLASS_NONE, RISCV_UNKNOWN_VERSION, RISCV_UNKNOWN_VERSION, EXT_DEFAULT },\n+  {\"m\",\t\tISA_SPEC_CLASS_20191213,\t2, 0, 0 },\n+  {\"m\",\t\tISA_SPEC_CLASS_20190608,\t2, 0, 0 },\n+  {\"m\",\t\tISA_SPEC_CLASS_2P2,\t\t2, 0, 0 },\n+  {\"a\",\t\tISA_SPEC_CLASS_20191213,\t2, 1, 0 },\n+  {\"a\",\t\tISA_SPEC_CLASS_20190608,\t2, 0, 0 },\n+  {\"a\",\t\tISA_SPEC_CLASS_2P2,\t\t2, 0, 0 },\n+  {\"f\",\t\tISA_SPEC_CLASS_20191213,\t2, 2, 0 },\n+  {\"f\",\t\tISA_SPEC_CLASS_20190608,\t2, 2, 0 },\n+  {\"f\",\t\tISA_SPEC_CLASS_2P2,\t\t2, 0, 0 },\n+  {\"d\",\t\tISA_SPEC_CLASS_20191213,\t2, 2, 0 },\n+  {\"d\",\t\tISA_SPEC_CLASS_20190608,\t2, 2, 0 },\n+  {\"d\",\t\tISA_SPEC_CLASS_2P2,\t\t2, 0, 0 },\n+  {\"q\",\t\tISA_SPEC_CLASS_20191213,\t2, 2, 0 },\n+  {\"q\",\t\tISA_SPEC_CLASS_20190608,\t2, 2, 0 },\n+  {\"q\",\t\tISA_SPEC_CLASS_2P2,\t\t2, 0, 0 },\n+  {\"l\",\t\tISA_SPEC_CLASS_NONE, RISCV_UNKNOWN_VERSION, RISCV_UNKNOWN_VERSION, 0 },\n+  {\"c\",\t\tISA_SPEC_CLASS_20191213,\t2, 0, 0 },\n+  {\"c\",\t\tISA_SPEC_CLASS_20190608,\t2, 0, 0 },\n+  {\"c\",\t\tISA_SPEC_CLASS_2P2,\t\t2, 0, 0 },\n+  {\"b\",\t\tISA_SPEC_CLASS_NONE, RISCV_UNKNOWN_VERSION, RISCV_UNKNOWN_VERSION, 0 },\n+  {\"j\",\t\tISA_SPEC_CLASS_NONE, RISCV_UNKNOWN_VERSION, RISCV_UNKNOWN_VERSION, 0 },\n+  {\"t\",\t\tISA_SPEC_CLASS_NONE, RISCV_UNKNOWN_VERSION, RISCV_UNKNOWN_VERSION, 0 },\n+  {\"p\",\t\tISA_SPEC_CLASS_NONE, RISCV_UNKNOWN_VERSION, RISCV_UNKNOWN_VERSION, 0 },\n+  {\"v\",\t\tISA_SPEC_CLASS_NONE, RISCV_UNKNOWN_VERSION, RISCV_UNKNOWN_VERSION, 0 },\n+  {\"n\",\t\tISA_SPEC_CLASS_NONE, RISCV_UNKNOWN_VERSION, RISCV_UNKNOWN_VERSION, 0 },\n+  {NULL, 0, 0, 0, 0}\n };\n \n-static const char * const riscv_std_h_ext_strtab[] =\n+static struct riscv_supported_ext riscv_supported_std_z_ext[] =\n {\n-  NULL\n+  {\"zicsr\",\t\tISA_SPEC_CLASS_20191213,\t2, 0,  0 },\n+  {\"zicsr\",\t\tISA_SPEC_CLASS_20190608,\t2, 0,  0 },\n+  {\"zifencei\",\t\tISA_SPEC_CLASS_20191213,\t2, 0,  0 },\n+  {\"zifencei\",\t\tISA_SPEC_CLASS_20190608,\t2, 0,  0 },\n+  {\"zihintpause\",\tISA_SPEC_CLASS_DRAFT,\t\t1, 0,  0 },\n+  {\"zbb\",\t\tISA_SPEC_CLASS_DRAFT,\t\t0, 93, 0 },\n+  {\"zba\",\t\tISA_SPEC_CLASS_DRAFT,\t\t0, 93, 0 },\n+  {\"zbc\",\t\tISA_SPEC_CLASS_DRAFT,\t\t0, 93, 0 },\n+  {NULL, 0, 0, 0, 0}\n+};\n+\n+static struct riscv_supported_ext riscv_supported_std_s_ext[] =\n+{\n+  {NULL, 0, 0, 0, 0}\n+};\n+\n+static struct riscv_supported_ext riscv_supported_std_h_ext[] =\n+{\n+  {NULL, 0, 0, 0, 0}\n };\n \n-static const char * const riscv_std_zxm_ext_strtab[] =\n+static struct riscv_supported_ext riscv_supported_std_zxm_ext[] =\n {\n+  {NULL, 0, 0, 0, 0}\n+};\n+\n+const struct riscv_supported_ext *riscv_all_supported_ext[] =\n+{\n+  riscv_supported_std_ext,\n+  riscv_supported_std_z_ext,\n+  riscv_supported_std_s_ext,\n+  riscv_supported_std_h_ext,\n+  riscv_supported_std_zxm_ext,\n   NULL\n };\n \n@@ -1156,11 +1227,11 @@ riscv_get_prefix_class (const char *arch)\n \n static bool\n riscv_known_prefixed_ext (const char *ext,\n-\t\t\t  const char *const *known_exts)\n+\t\t\t  struct riscv_supported_ext *known_exts)\n {\n   size_t i;\n-  for (i = 0; known_exts[i]; ++i)\n-    if (strcmp (ext, known_exts[i]) == 0)\n+  for (i = 0; known_exts[i].name != NULL; ++i)\n+    if (strcmp (ext, known_exts[i].name) == 0)\n       return true;\n   return false;\n }\n@@ -1175,13 +1246,13 @@ riscv_valid_prefixed_ext (const char *ext)\n   switch (class)\n   {\n   case RV_ISA_CLASS_Z:\n-    return riscv_known_prefixed_ext (ext, riscv_std_z_ext_strtab);\n+    return riscv_known_prefixed_ext (ext, riscv_supported_std_z_ext);\n   case RV_ISA_CLASS_ZXM:\n-    return riscv_known_prefixed_ext (ext, riscv_std_zxm_ext_strtab);\n+    return riscv_known_prefixed_ext (ext, riscv_supported_std_zxm_ext);\n   case RV_ISA_CLASS_S:\n-    return riscv_known_prefixed_ext (ext, riscv_std_s_ext_strtab);\n+    return riscv_known_prefixed_ext (ext, riscv_supported_std_s_ext);\n   case RV_ISA_CLASS_H:\n-    return riscv_known_prefixed_ext (ext, riscv_std_h_ext_strtab);\n+    return riscv_known_prefixed_ext (ext, riscv_supported_std_h_ext);\n   case RV_ISA_CLASS_X:\n     /* Only the single x is invalid.  */\n     if (strcmp (ext, \"x\") != 0)\n@@ -1201,24 +1272,22 @@ static void\n riscv_init_ext_order (void)\n {\n   static bool inited = false;\n-  const char *std_base_exts = \"eig\";\n-  const char *std_remain_exts = riscv_supported_std_ext ();\n-  const char *ext;\n-  int order;\n-\n   if (inited)\n     return;\n \n   /* The orders of all standard extensions are positive.  */\n-  order = 1;\n-\n-  /* Init the standard base extensions first.  */\n-  for (ext = std_base_exts; *ext; ext++)\n-    riscv_ext_order[(*ext - 'a')] = order++;\n+  int order = 1;\n \n-  /* Init the standard remaining extensions.  */\n-  for (ext = std_remain_exts; *ext; ext++)\n-    riscv_ext_order[(*ext - 'a')] = order++;\n+  int i = 0;\n+  while (riscv_supported_std_ext[i].name != NULL)\n+    {\n+      const char *ext = riscv_supported_std_ext[i].name;\n+      riscv_ext_order[(*ext - 'a')] = order++;\n+      i++;\n+      while (riscv_supported_std_ext[i].name\n+\t     && strcmp (ext, riscv_supported_std_ext[i].name) == 0)\n+\ti++;\n+    }\n \n   /* Some of the prefixed keyword are not single letter, so we set\n      their prefixed orders in the riscv_compare_subsets directly,\n@@ -1345,6 +1414,46 @@ riscv_add_subset (riscv_subset_list_t *subset_list,\n     subset_list->tail = new;\n }\n \n+/* Get the default versions from the riscv_supported_*ext tables.  */\n+\n+static void\n+riscv_get_default_ext_version (enum riscv_spec_class default_isa_spec,\n+\t\t\t       const char *name,\n+\t\t\t       int *major_version,\n+\t\t\t       int *minor_version)\n+{\n+  if (name == NULL || default_isa_spec == ISA_SPEC_CLASS_NONE)\n+    return;\n+\n+  struct riscv_supported_ext *table = NULL;\n+  enum riscv_prefix_ext_class class = riscv_get_prefix_class (name);\n+  switch (class)\n+    {\n+    case RV_ISA_CLASS_ZXM: table = riscv_supported_std_zxm_ext; break;\n+    case RV_ISA_CLASS_Z: table = riscv_supported_std_z_ext; break;\n+    case RV_ISA_CLASS_S: table = riscv_supported_std_s_ext; break;\n+    case RV_ISA_CLASS_H: table = riscv_supported_std_h_ext; break;\n+    case RV_ISA_CLASS_X:\n+      break;\n+    default:\n+      table = riscv_supported_std_ext;\n+    }\n+\n+  int i = 0;\n+  while (table != NULL && table[i].name != NULL)\n+    {\n+      if (strcmp (table[i].name, name) == 0\n+\t  && (table[i].isa_spec_class == ISA_SPEC_CLASS_DRAFT\n+\t      || table[i].isa_spec_class == default_isa_spec))\n+\t{\n+\t  *major_version = table[i].major_version;\n+\t  *minor_version = table[i].minor_version;\n+\t  return;\n+\t}\n+      i++;\n+    }\n+}\n+\n /* Find the default versions for the extension before adding them to\n    the subset list, if their versions are RISCV_UNKNOWN_VERSION.\n    Afterwards, report errors if we can not find their default versions.  */\n@@ -1359,10 +1468,10 @@ riscv_parse_add_subset (riscv_parse_subset_t *rps,\n   int major_version = major;\n   int minor_version = minor;\n \n-  if ((major_version == RISCV_UNKNOWN_VERSION\n+  if (major_version == RISCV_UNKNOWN_VERSION\n        || minor_version == RISCV_UNKNOWN_VERSION)\n-      && rps->get_default_version != NULL)\n-    rps->get_default_version (subset, &major_version, &minor_version);\n+    riscv_get_default_ext_version (rps->isa_spec, subset,\n+\t\t\t\t   &major_version, &minor_version);\n \n   /* We don't care the versions of the implicit extensions.  */\n   if (!implicit\n@@ -1476,15 +1585,6 @@ riscv_parsing_subset_version (riscv_parse_subset_t *rps,\n   return p;\n }\n \n-/* Return string which contain all supported standard extensions in\n-   canonical order.  */\n-\n-const char *\n-riscv_supported_std_ext (void)\n-{\n-  return \"mafdqlcbjtpvn\";\n-}\n-\n /* Parsing function for standard extensions.\n \n    Return Value:\n@@ -1500,59 +1600,13 @@ riscv_parse_std_ext (riscv_parse_subset_t *rps,\n \t\t     const char *arch,\n \t\t     const char *p)\n {\n-  const char *all_std_exts = riscv_supported_std_ext ();\n-  const char *std_exts = all_std_exts;\n-  int major_version;\n-  int minor_version;\n-  char subset[2] = {0, 0};\n-\n   /* First letter must start with i, e or g.  */\n-  switch (*p)\n+  if (*p != 'e' && *p != 'i' && *p != 'g')\n     {\n-      case 'i':\n-\tp = riscv_parsing_subset_version (rps, arch, ++p,\n-\t\t\t\t\t  &major_version,\n-\t\t\t\t\t  &minor_version, true);\n-\triscv_parse_add_subset (rps, \"i\",\n-\t\t\t\tmajor_version,\n-\t\t\t\tminor_version, false);\n-\tbreak;\n-\n-      case 'e':\n-\tp = riscv_parsing_subset_version (rps, arch, ++p,\n-\t\t\t\t\t  &major_version,\n-\t\t\t\t\t  &minor_version, true);\n-\triscv_parse_add_subset (rps, \"e\",\n-\t\t\t\tmajor_version,\n-\t\t\t\tminor_version, false);\n-\tbreak;\n-\n-      case 'g':\n-\tp = riscv_parsing_subset_version (rps, arch, ++p,\n-\t\t\t\t\t  &major_version,\n-\t\t\t\t\t  &minor_version, true);\n-\t/* Expand g to imafd.  */\n-\triscv_parse_add_subset (rps, \"i\",\n-\t\t\t\tRISCV_UNKNOWN_VERSION,\n-\t\t\t\tRISCV_UNKNOWN_VERSION, false);\n-\tfor ( ; *std_exts != 'q'; std_exts++)\n-\t  {\n-\t    subset[0] = *std_exts;\n-\t    riscv_parse_add_subset (rps, subset,\n-\t\t\t\t    RISCV_UNKNOWN_VERSION,\n-\t\t\t\t    RISCV_UNKNOWN_VERSION, false);\n-\t  }\n-\t/* Add g as an implicit extension.  */\n-\triscv_parse_add_subset (rps, \"g\",\n-\t\t\t\tRISCV_UNKNOWN_VERSION,\n-\t\t\t\tRISCV_UNKNOWN_VERSION, true);\n-\tbreak;\n-\n-      default:\n-\trps->error_handler\n-\t  (_(\"%s: first ISA extension must be `e', `i' or `g'\"),\n-\t   arch);\n-\treturn NULL;\n+      rps->error_handler\n+\t(_(\"%s: first ISA extension must be `e', `i' or `g'\"),\n+\t arch);\n+      return NULL;\n     }\n \n   while (p != NULL && *p != '\\0')\n@@ -1568,32 +1622,41 @@ riscv_parse_std_ext (riscv_parse_subset_t *rps,\n \t  continue;\n \t}\n \n-      /* Checking canonical order.  */\n-      char std_ext = *p;\n-      while (*std_exts && std_ext != *std_exts)\n-\tstd_exts++;\n+      bool implicit = false;\n+      int major = RISCV_UNKNOWN_VERSION;\n+      int minor = RISCV_UNKNOWN_VERSION;\n+      char subset[2] = {0, 0};\n+\n+      subset[0] = *p;\n \n-      if (std_ext != *std_exts)\n+      /* Check if the standard extension is supported.  */\n+      if (riscv_ext_order[(subset[0] - 'a')] == 0)\n \t{\n-\t  if (riscv_ext_order[(std_ext - 'a')] == 0)\n-\t    rps->error_handler\n-\t      (_(\"%s: unknown standard ISA extension `%c'\"),\n-\t       arch, std_ext);\n-\t  else\n-\t    rps->error_handler\n-\t      (_(\"%s: standard ISA extension `%c' is not \"\n-\t\t \"in canonical order\"), arch, std_ext);\n+\t  rps->error_handler\n+\t    (_(\"%s: unknown standard ISA extension `%c'\"),\n+\t     arch, subset[0]);\n \t  return NULL;\n \t}\n \n-      std_exts++;\n-      subset[0] = std_ext;\n-      p = riscv_parsing_subset_version (rps, arch, ++p,\n-\t\t\t\t\t&major_version,\n-\t\t\t\t\t&minor_version, true);\n-      riscv_parse_add_subset (rps, subset,\n-\t\t\t      major_version,\n-\t\t\t      minor_version, false);\n+      /* Checking canonical order.  */\n+      if (rps->subset_list->tail != NULL\n+\t  && riscv_compare_subsets (rps->subset_list->tail->name, subset) > 0)\n+\t{\n+\t  rps->error_handler\n+\t    (_(\"%s: standard ISA extension `%c' is not \"\n+\t       \"in canonical order\"), arch, subset[0]);\n+\t  return NULL;\n+\t}\n+\n+      p = riscv_parsing_subset_version (rps, arch, ++p, &major, &minor, true);\n+      /* Added g as an implicit extension.  */\n+      if (subset[0] == 'g')\n+\t{\n+\t  implicit = true;\n+\t  major = RISCV_UNKNOWN_VERSION;\n+\t  minor = RISCV_UNKNOWN_VERSION;\n+\t}\n+      riscv_parse_add_subset (rps, subset, major, minor, implicit);\n     }\n \n   return p;\n@@ -1761,6 +1824,30 @@ riscv_parse_check_conflicts (riscv_parse_subset_t *rps)\n   return no_conflict;\n }\n \n+/* Set the default subset list according to the default_enable field\n+   of riscv_supported_*ext tables.  */\n+\n+static void\n+riscv_set_default_arch (riscv_parse_subset_t *rps)\n+{\n+  unsigned long enable = EXT_DEFAULT;\n+  int i, j;\n+  for (i = 0; riscv_all_supported_ext[i] != NULL; i++)\n+    {\n+      const struct riscv_supported_ext *table = riscv_all_supported_ext[i];\n+      for (j = 0; table[j].name != NULL; j++)\n+\t{\n+\t  bool implicit = false;\n+\t  if (strcmp (table[j].name, \"g\") == 0)\n+\t    implicit = true;\n+\t  if (table[j].default_enable & enable)\n+\t    riscv_parse_add_subset (rps, table[j].name,\n+\t\t\t\t    RISCV_UNKNOWN_VERSION,\n+\t\t\t\t    RISCV_UNKNOWN_VERSION, implicit);\n+\t}\n+    }\n+}\n+\n /* Function for parsing ISA string.\n \n    Return Value:\n@@ -1776,6 +1863,17 @@ riscv_parse_subset (riscv_parse_subset_t *rps,\n {\n   const char *p;\n \n+  /* Init the riscv_ext_order array to compare the order of extensions\n+     quickly.  */\n+  riscv_init_ext_order ();\n+\n+  if (arch == NULL)\n+    {\n+      riscv_set_default_arch (rps);\n+      riscv_parse_add_implicit_subsets (rps);\n+      return riscv_parse_check_conflicts (rps);\n+    }\n+\n   for (p = arch; *p != '\\0'; p++)\n     {\n       if (ISUPPER (*p))\n@@ -1800,22 +1898,20 @@ riscv_parse_subset (riscv_parse_subset_t *rps,\n     }\n   else\n     {\n-      /* ISA string shouldn't be NULL or empty here.  However,\n-\t it might be empty only when we failed to merge the ISA\n-\t string in the riscv_merge_attributes.  We have already\n-\t issued the correct error message in another side, so do\n-\t not issue this error when the ISA string is empty.  */\n+      /* ISA string shouldn't be NULL or empty here.  For linker,\n+\t it might be empty when we failed to merge the ISA string\n+\t in the riscv_merge_attributes.  For assembler, we might\n+\t give an empty string by .attribute arch, \"\" or -march=.\n+\t However, We have already issued the correct error message\n+\t in another side, so do not issue this error when the ISA\n+\t string is empty.  */\n       if (strlen (arch))\n \trps->error_handler (\n \t  _(\"%s: ISA string must begin with rv32 or rv64\"),\n \t  arch);\n       return false;\n     }\n \n-  /* Init the riscv_ext_order array to compare the order of extensions\n-     quickly.  */\n-  riscv_init_ext_order ();\n-\n   /* Parsing standard extension.  */\n   p = riscv_parse_std_ext (rps, arch, p);\n "
    },
    {
      "sha": "e691a97ecda8e4b842d654abbfb0acdb2d2d8707",
      "filename": "bfd/elfxx-riscv.h",
      "status": "modified",
      "additions": 2,
      "deletions": 6,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c9f279910113d6a10cb64d81aba2c1af9f3c228c/bfd/elfxx-riscv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c9f279910113d6a10cb64d81aba2c1af9f3c228c/bfd/elfxx-riscv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-riscv.h?ref=c9f279910113d6a10cb64d81aba2c1af9f3c228c",
      "patch": "@@ -23,6 +23,7 @@\n #include \"elf/common.h\"\n #include \"elf/internal.h\"\n #include \"opcode/riscv.h\"\n+#include \"cpu-riscv.h\"\n \n #define RISCV_UNKNOWN_VERSION -1\n \n@@ -71,19 +72,14 @@ typedef struct\n   void (*error_handler) (const char *,\n \t\t\t ...) ATTRIBUTE_PRINTF_1;\n   unsigned *xlen;\n-  void (*get_default_version) (const char *,\n-\t\t\t       int *,\n-\t\t\t       int *);\n+  enum riscv_spec_class isa_spec;\n   bool check_unknown_prefixed_ext;\n } riscv_parse_subset_t;\n \n extern bool\n riscv_parse_subset (riscv_parse_subset_t *,\n \t\t    const char *);\n \n-extern const char *\n-riscv_supported_std_ext (void);\n-\n extern void\n riscv_release_subset_list (riscv_subset_list_t *);\n "
    },
    {
      "sha": "e7b733a4e6dd8b0dac37bf22e277c40063e24e9c",
      "filename": "gas/config/tc-riscv.c",
      "status": "modified",
      "additions": 7,
      "deletions": 119,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c9f279910113d6a10cb64d81aba2c1af9f3c228c/gas/config/tc-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c9f279910113d6a10cb64d81aba2c1af9f3c228c/gas/config/tc-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/config/tc-riscv.c?ref=c9f279910113d6a10cb64d81aba2c1af9f3c228c",
      "patch": "@@ -29,7 +29,6 @@\n #include \"dwarf2dbg.h\"\n #include \"dw2gencfi.h\"\n \n-#include \"bfd/cpu-riscv.h\"\n #include \"bfd/elfxx-riscv.h\"\n #include \"elf/riscv.h\"\n #include \"opcode/riscv.h\"\n@@ -88,65 +87,6 @@ struct riscv_csr_extra\n   struct riscv_csr_extra *next;\n };\n \n-/* All standard/Z* extensions defined in all supported ISA spec.  */\n-struct riscv_ext_version\n-{\n-  const char *name;\n-  enum riscv_spec_class isa_spec_class;\n-  int major_version;\n-  int minor_version;\n-};\n-\n-static const struct riscv_ext_version ext_version_table[] =\n-{\n-  {\"e\", ISA_SPEC_CLASS_20191213, 1, 9},\n-  {\"e\", ISA_SPEC_CLASS_20190608, 1, 9},\n-  {\"e\", ISA_SPEC_CLASS_2P2,      1, 9},\n-\n-  {\"i\", ISA_SPEC_CLASS_20191213, 2, 1},\n-  {\"i\", ISA_SPEC_CLASS_20190608, 2, 1},\n-  {\"i\", ISA_SPEC_CLASS_2P2,      2, 0},\n-\n-  {\"m\", ISA_SPEC_CLASS_20191213, 2, 0},\n-  {\"m\", ISA_SPEC_CLASS_20190608, 2, 0},\n-  {\"m\", ISA_SPEC_CLASS_2P2,      2, 0},\n-\n-  {\"a\", ISA_SPEC_CLASS_20191213, 2, 1},\n-  {\"a\", ISA_SPEC_CLASS_20190608, 2, 0},\n-  {\"a\", ISA_SPEC_CLASS_2P2,      2, 0},\n-\n-  {\"f\", ISA_SPEC_CLASS_20191213, 2, 2},\n-  {\"f\", ISA_SPEC_CLASS_20190608, 2, 2},\n-  {\"f\", ISA_SPEC_CLASS_2P2,      2, 0},\n-\n-  {\"d\", ISA_SPEC_CLASS_20191213, 2, 2},\n-  {\"d\", ISA_SPEC_CLASS_20190608, 2, 2},\n-  {\"d\", ISA_SPEC_CLASS_2P2,      2, 0},\n-\n-  {\"q\", ISA_SPEC_CLASS_20191213, 2, 2},\n-  {\"q\", ISA_SPEC_CLASS_20190608, 2, 2},\n-  {\"q\", ISA_SPEC_CLASS_2P2,      2, 0},\n-\n-  {\"c\", ISA_SPEC_CLASS_20191213, 2, 0},\n-  {\"c\", ISA_SPEC_CLASS_20190608, 2, 0},\n-  {\"c\", ISA_SPEC_CLASS_2P2,      2, 0},\n-\n-  {\"zicsr\", ISA_SPEC_CLASS_20191213, 2, 0},\n-  {\"zicsr\", ISA_SPEC_CLASS_20190608, 2, 0},\n-\n-  {\"zifencei\", ISA_SPEC_CLASS_20191213, 2, 0},\n-  {\"zifencei\", ISA_SPEC_CLASS_20190608, 2, 0},\n-\n-  {\"zihintpause\", ISA_SPEC_CLASS_DRAFT, 1, 0},\n-\n-  {\"zbb\",   ISA_SPEC_CLASS_DRAFT, 0, 93},\n-  {\"zba\",   ISA_SPEC_CLASS_DRAFT, 0, 93},\n-  {\"zbc\",   ISA_SPEC_CLASS_DRAFT, 0, 93},\n-\n-  /* Terminate the list.  */\n-  {NULL, 0, 0, 0}\n-};\n-\n #ifndef DEFAULT_ARCH\n #define DEFAULT_ARCH \"riscv64\"\n #endif\n@@ -349,57 +289,6 @@ riscv_multi_subset_supports (enum riscv_insn_class insn_class)\n     }\n }\n \n-/* Handle of the extension with version hash table.  */\n-static htab_t ext_version_hash = NULL;\n-\n-static htab_t\n-init_ext_version_hash (void)\n-{\n-  const struct riscv_ext_version *table = ext_version_table;\n-  htab_t hash = str_htab_create ();\n-  int i = 0;\n-\n-  while (table[i].name)\n-    {\n-      const char *name = table[i].name;\n-      if (str_hash_insert (hash, name, &table[i], 0) != NULL)\n-\tas_fatal (_(\"internal: duplicate %s\"), name);\n-\n-      i++;\n-      while (table[i].name\n-\t     && strcmp (table[i].name, name) == 0)\n-       i++;\n-    }\n-\n-  return hash;\n-}\n-\n-static void\n-riscv_get_default_ext_version (const char *name,\n-\t\t\t       int *major_version,\n-\t\t\t       int *minor_version)\n-{\n-  struct riscv_ext_version *ext;\n-\n-  if (name == NULL || default_isa_spec == ISA_SPEC_CLASS_NONE)\n-    return;\n-\n-  ext = (struct riscv_ext_version *) str_hash_find (ext_version_hash, name);\n-  while (ext\n-\t && ext->name\n-\t && strcmp (ext->name, name) == 0)\n-    {\n-      if (ext->isa_spec_class == ISA_SPEC_CLASS_DRAFT\n-\t  || ext->isa_spec_class == default_isa_spec)\n-\t{\n-\t  *major_version = ext->major_version;\n-\t  *minor_version = ext->minor_version;\n-\t  return;\n-\t}\n-      ext++;\n-    }\n-}\n-\n /* Set which ISA and extensions are available.  */\n \n static void\n@@ -409,11 +298,15 @@ riscv_set_arch (const char *s)\n   rps.subset_list = &riscv_subsets;\n   rps.error_handler = as_bad;\n   rps.xlen = &xlen;\n-  rps.get_default_version = riscv_get_default_ext_version;\n+  rps.isa_spec = default_isa_spec;\n   rps.check_unknown_prefixed_ext = true;\n \n-  if (s == NULL)\n-    return;\n+  if (s != NULL && strcmp (s, \"\") == 0)\n+    {\n+      as_bad (_(\"the architecture string of -march and elf architecture \"\n+\t\t\"attributes cannot be empty\"));\n+      return;\n+    }\n \n   riscv_release_subset_list (&riscv_subsets);\n   riscv_parse_subset (&rps, s);\n@@ -3137,11 +3030,6 @@ riscv_after_parse_args (void)\n       else\n \tas_bad (\"unknown default architecture `%s'\", default_arch);\n     }\n-  if (default_arch_with_ext == NULL)\n-    default_arch_with_ext = xlen == 64 ? \"rv64g\" : \"rv32g\";\n-\n-  /* Initialize the hash table for extensions with default version.  */\n-  ext_version_hash = init_ext_version_hash ();\n \n   /* Set default specs.  */\n   if (default_isa_spec == ISA_SPEC_CLASS_NONE)"
    }
  ]
}