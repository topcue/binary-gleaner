{
  "sha": "9385df2a5818f08bd13b17e503fdb5e2011093c0",
  "node_id": "C_kwDOANOeidoAKDkzODVkZjJhNTgxOGYwOGJkMTNiMTdlNTAzZmRiNWUyMDExMDkzYzA",
  "commit": {
    "author": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-02-22T19:22:14Z"
    },
    "committer": {
      "name": "John Baldwin",
      "email": "jhb@FreeBSD.org",
      "date": "2022-02-22T19:22:14Z"
    },
    "message": "fbsd-nat: Implement async target support.\n\nThis is a fairly simple version of async target support.\n\nSynchronous mode still uses blocking waitpid() calls in\ninf_ptrace::wait() unlike the Linux native target which always uses\nWNOHANG and uses sigsuspend() for synchronous operation.\n\nAsynchronous mode registers an event pipe with the core as a file\nhandle and writes to the pipe when SIGCHLD is raised.  TARGET_WNOHANG\nis handled by inf_ptrace::wait().",
    "tree": {
      "sha": "ec90061aa64d009a6474b6cfcc8e66cd7694ee62",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ec90061aa64d009a6474b6cfcc8e66cd7694ee62"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9385df2a5818f08bd13b17e503fdb5e2011093c0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9385df2a5818f08bd13b17e503fdb5e2011093c0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9385df2a5818f08bd13b17e503fdb5e2011093c0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9385df2a5818f08bd13b17e503fdb5e2011093c0/comments",
  "author": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "bsdjhb",
    "id": 8976613,
    "node_id": "MDQ6VXNlcjg5NzY2MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/8976613?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/bsdjhb",
    "html_url": "https://github.com/bsdjhb",
    "followers_url": "https://api.github.com/users/bsdjhb/followers",
    "following_url": "https://api.github.com/users/bsdjhb/following{/other_user}",
    "gists_url": "https://api.github.com/users/bsdjhb/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/bsdjhb/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/bsdjhb/subscriptions",
    "organizations_url": "https://api.github.com/users/bsdjhb/orgs",
    "repos_url": "https://api.github.com/users/bsdjhb/repos",
    "events_url": "https://api.github.com/users/bsdjhb/events{/privacy}",
    "received_events_url": "https://api.github.com/users/bsdjhb/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ca81b5334e074e6c00137dba00154ef1b4489388",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ca81b5334e074e6c00137dba00154ef1b4489388",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ca81b5334e074e6c00137dba00154ef1b4489388"
    }
  ],
  "stats": {
    "total": 166,
    "additions": 164,
    "deletions": 2
  },
  "files": [
    {
      "sha": "66bd566573befc3ca6e5914e00def10f9281a164",
      "filename": "gdb/fbsd-nat.c",
      "status": "modified",
      "additions": 152,
      "deletions": 2,
      "changes": 154,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9385df2a5818f08bd13b17e503fdb5e2011093c0/gdb/fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9385df2a5818f08bd13b17e503fdb5e2011093c0/gdb/fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.c?ref=9385df2a5818f08bd13b17e503fdb5e2011093c0",
      "patch": "@@ -18,7 +18,10 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n+#include \"gdbsupport/block-signals.h\"\n #include \"gdbsupport/byte-vector.h\"\n+#include \"gdbsupport/event-loop.h\"\n+#include \"gdbsupport/event-pipe.h\"\n #include \"gdbcore.h\"\n #include \"inferior.h\"\n #include \"regcache.h\"\n@@ -28,6 +31,7 @@\n #include \"gdbthread.h\"\n #include \"gdbsupport/buildargv.h\"\n #include \"gdbsupport/gdb_wait.h\"\n+#include \"inf-loop.h\"\n #include \"inf-ptrace.h\"\n #include <sys/types.h>\n #ifdef HAVE_SYS_PROCCTL_H\n@@ -926,6 +930,114 @@ fbsd_nat_target::update_thread_list ()\n #endif\n }\n \n+/* Async mode support.  */\n+\n+static event_pipe fbsd_nat_event_pipe;\n+\n+/* Implement the \"can_async_p\" target method.  */\n+\n+bool\n+fbsd_nat_target::can_async_p ()\n+{\n+  /* This flag should be checked in the common target.c code.  */\n+  gdb_assert (target_async_permitted);\n+\n+  /* Otherwise, this targets is always able to support async mode.  */\n+  return true;\n+}\n+\n+/* Implement the \"is_async_p\" target method.  */\n+\n+bool\n+fbsd_nat_target::is_async_p ()\n+{\n+  return fbsd_nat_event_pipe.is_open ();\n+}\n+\n+/* Implement the \"async_wait_fd\" target method.  */\n+\n+int\n+fbsd_nat_target::async_wait_fd ()\n+{\n+  return fbsd_nat_event_pipe.event_fd ();\n+}\n+\n+/* SIGCHLD handler notifies the event-loop in async mode.  */\n+\n+static void\n+sigchld_handler (int signo)\n+{\n+  int old_errno = errno;\n+\n+  if (fbsd_nat_event_pipe.is_open ())\n+    fbsd_nat_event_pipe.mark ();\n+\n+  errno = old_errno;\n+}\n+\n+/* Callback registered with the target events file descriptor.  */\n+\n+static void\n+handle_target_event (int error, gdb_client_data client_data)\n+{\n+  inferior_event_handler (INF_REG_EVENT);\n+}\n+\n+/* Implement the \"async\" target method.  */\n+\n+void\n+fbsd_nat_target::async (int enable)\n+{\n+  if ((enable != 0) == is_async_p ())\n+    return;\n+\n+  /* Block SIGCHILD while we create/destroy the pipe, as the handler\n+     writes to it.  */\n+  gdb::block_signals blocker;\n+\n+  if (enable)\n+    {\n+      if (!fbsd_nat_event_pipe.open ())\n+\tinternal_error (__FILE__, __LINE__, \"failed to create event pipe.\");\n+\n+      add_file_handler (fbsd_nat_event_pipe.event_fd (),\n+\t\t\thandle_target_event, NULL, \"fbsd-nat\");\n+\n+      /* Trigger a poll in case there are pending events to\n+\t handle.  */\n+      fbsd_nat_event_pipe.mark ();\n+    }\n+  else\n+    {\n+      delete_file_handler (fbsd_nat_event_pipe.event_fd ());\n+      fbsd_nat_event_pipe.close ();\n+    }\n+}\n+\n+/* Implement the \"close\" target method.  */\n+\n+void\n+fbsd_nat_target::close ()\n+{\n+  if (is_async_p ())\n+    async (0);\n+\n+  inf_ptrace_target::close ();\n+}\n+\n+/* Implement the \"attach\" target method.  */\n+\n+void\n+fbsd_nat_target::attach (const char *args, int from_tty)\n+{\n+  inf_ptrace_target::attach (args, from_tty);\n+\n+  /* Curiously, the core does not do this automatically.  */\n+  if (target_can_async_p ())\n+    target_async (1);\n+}\n+\n+\n #ifdef TDP_RFPPWAIT\n /*\n   To catch fork events, PT_FOLLOW_FORK is set on every traced process\n@@ -997,6 +1109,11 @@ static void\n fbsd_add_vfork_done (ptid_t pid)\n {\n   fbsd_pending_vfork_done.push_front (pid);\n+\n+  /* If we're in async mode, need to tell the event loop there's\n+     something here to process.  */\n+  if (target_is_async_p ())\n+    fbsd_nat_event_pipe.mark ();\n }\n \n /* Check for a pending vfork done event for a specific PID.  */\n@@ -1165,8 +1282,8 @@ fbsd_handle_debug_trap (fbsd_nat_target *target, ptid_t ptid,\n    the status in *OURSTATUS.  */\n \n ptid_t\n-fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n-\t\t       target_wait_flags target_options)\n+fbsd_nat_target::wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n+\t\t\t target_wait_flags target_options)\n {\n   ptid_t wptid;\n \n@@ -1381,6 +1498,36 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n     }\n }\n \n+ptid_t\n+fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n+\t\t       target_wait_flags target_options)\n+{\n+  ptid_t wptid;\n+\n+  fbsd_nat_debug_printf (\"[%s], [%s]\", target_pid_to_str (ptid).c_str (),\n+\t\t\t target_options_to_string (target_options).c_str ());\n+\n+  /* Ensure any subsequent events trigger a new event in the loop.  */\n+  if (is_async_p ())\n+    fbsd_nat_event_pipe.flush ();\n+\n+  wptid = wait_1 (ptid, ourstatus, target_options);\n+\n+  /* If we are in async mode and found an event, there may still be\n+     another event pending.  Trigger the event pipe so that that the\n+     event loop keeps polling until no event is returned.  */\n+  if (is_async_p ()\n+      && ((ourstatus->kind () != TARGET_WAITKIND_IGNORE\n+\t  && ourstatus->kind() != TARGET_WAITKIND_NO_RESUMED)\n+\t  || ptid != minus_one_ptid))\n+    fbsd_nat_event_pipe.mark ();\n+\n+  fbsd_nat_debug_printf (\"returning [%s], [%s]\",\n+\t\t\t target_pid_to_str (wptid).c_str (),\n+\t\t\t ourstatus->to_string ().c_str ());\n+  return wptid;\n+}\n+\n #ifdef USE_SIGTRAP_SIGINFO\n /* Implement the \"stopped_by_sw_breakpoint\" target_ops method.  */\n \n@@ -1679,4 +1826,7 @@ Enables printf debugging output.\"),\n \t\t\t   NULL,\n \t\t\t   &show_fbsd_nat_debug,\n \t\t\t   &setdebuglist, &showdebuglist);\n+\n+  /* Install a SIGCHLD handler.  */\n+  signal (SIGCHLD, sigchld_handler);\n }"
    },
    {
      "sha": "411573b0b64b65f017c735ad9305c596bcc14516",
      "filename": "gdb/fbsd-nat.h",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9385df2a5818f08bd13b17e503fdb5e2011093c0/gdb/fbsd-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9385df2a5818f08bd13b17e503fdb5e2011093c0/gdb/fbsd-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.h?ref=9385df2a5818f08bd13b17e503fdb5e2011093c0",
      "patch": "@@ -66,9 +66,19 @@ class fbsd_nat_target : public inf_ptrace_target\n \n   void update_thread_list () override;\n \n+  bool can_async_p () override;\n+  bool is_async_p () override;\n+\n+  int async_wait_fd () override;\n+  void async (int) override;\n+\n+  void close () override;\n+\n   thread_control_capabilities get_thread_control_capabilities () override\n   { return tc_schedlock; }\n \n+  void attach (const char *, int) override;\n+\n   void create_inferior (const char *, const std::string &,\n \t\t\tchar **, int) override;\n \n@@ -110,6 +120,8 @@ class fbsd_nat_target : public inf_ptrace_target\n   void post_startup_inferior (ptid_t) override;\n \n private:\n+  ptid_t wait_1 (ptid_t, struct target_waitstatus *, target_wait_flags);\n+\n   /* Helper routines for use in fetch_registers and store_registers in\n      subclasses.  These routines fetch and store a single set of\n      registers described by REGSET.  The REGSET's 'regmap' field must"
    }
  ]
}