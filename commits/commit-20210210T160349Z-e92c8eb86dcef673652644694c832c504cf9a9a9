{
  "sha": "e92c8eb86dcef673652644694c832c504cf9a9a9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTkyYzhlYjg2ZGNlZjY3MzY1MjY0NDY5NGM4MzJjNTA0Y2Y5YTlhOQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-09T15:46:13Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-10T16:03:49Z"
    },
    "message": "gdb/fortran: add parser support for lbound and ubound\n\nAdd support for the LBOUND and UBOUND built in functions to the\nFortran expression parser.\n\nBoth support taking one or two arguments.  A single argument, which\nmust be an array, returns an array containing all of the lower or\nupper bound data.\n\nWhen passed two arguments, the second argument is the dimension being\nasked about.  In this case the result is a scalar containing the lower\nor upper bound just for that dimension.\n\nSome examples of usage taken from the new test:\n\n  # Given:\n  #   integer, dimension (-8:-1,-10:-2) :: neg_array\n  #\n  (gdb) p lbound (neg_array)\n  $1 = (-8, -10)\n  (gdb) p lbound (neg_array, 1)\n  $3 = -8\n  (gdb) p lbound (neg_array, 2)\n  $5 = -10\n\ngdb/ChangeLog:\n\n\t* f-exp.y (UNOP_OR_BINOP_INTRINSIC): New token.\n\t(exp): New pattern using UNOP_OR_BINOP_INTRINSIC.\n\t(one_or_two_args): New pattern.\n\t(f77_keywords): Add lbound and ubound.\n\t* f-lang.c (fortran_bounds_all_dims): New function.\n\t(fortran_bounds_for_dimension): New function.\n\t(evaluate_subexp_f): Handle FORTRAN_LBOUND and FORTRAN_UBOUND.\n\t(operator_length_f): Likewise.\n\t(print_subexp_f): Likewise.\n\t(dump_subexp_body_f): Likewise.\n\t(operator_check_f): Likewise.\n\t* std-operator.def (FORTRAN_LBOUND): Define.\n\t(FORTRAN_UBOUND): Define.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.fortran/lbound-ubound.F90: New file.\n\t* gdb.fortran/lbound-ubound.exp: New file.",
    "tree": {
      "sha": "b4fb64a5caf89a02b76743fc7f99558e39df8231",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b4fb64a5caf89a02b76743fc7f99558e39df8231"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e92c8eb86dcef673652644694c832c504cf9a9a9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e92c8eb86dcef673652644694c832c504cf9a9a9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e92c8eb86dcef673652644694c832c504cf9a9a9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e92c8eb86dcef673652644694c832c504cf9a9a9/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "758f590744b1cf8d1049fca3223d1817242cacb8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/758f590744b1cf8d1049fca3223d1817242cacb8",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/758f590744b1cf8d1049fca3223d1817242cacb8"
    }
  ],
  "stats": {
    "total": 524,
    "additions": 524,
    "deletions": 0
  },
  "files": [
    {
      "sha": "0f600fedc725bd5e595dc6fb0ca2d762d0a9585d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 16,
      "deletions": 0,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=e92c8eb86dcef673652644694c832c504cf9a9a9",
      "patch": "@@ -1,3 +1,19 @@\n+2021-02-10  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* f-exp.y (UNOP_OR_BINOP_INTRINSIC): New token.\n+\t(exp): New pattern using UNOP_OR_BINOP_INTRINSIC.\n+\t(one_or_two_args): New pattern.\n+\t(f77_keywords): Add lbound and ubound.\n+\t* f-lang.c (fortran_bounds_all_dims): New function.\n+\t(fortran_bounds_for_dimension): New function.\n+\t(evaluate_subexp_f): Handle FORTRAN_LBOUND and FORTRAN_UBOUND.\n+\t(operator_length_f): Likewise.\n+\t(print_subexp_f): Likewise.\n+\t(dump_subexp_body_f): Likewise.\n+\t(operator_check_f): Likewise.\n+\t* std-operator.def (FORTRAN_LBOUND): Define.\n+\t(FORTRAN_UBOUND): Define.\n+\n 2021-02-10  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* coff-pe-read.c (add_pe_forwarded_sym): Make use of section_index"
    },
    {
      "sha": "00f0df34db4f71b8db78251c3f477600a9142c7c",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 18,
      "deletions": 0,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=e92c8eb86dcef673652644694c832c504cf9a9a9",
      "patch": "@@ -178,6 +178,7 @@ static int parse_number (struct parser_state *, const char *, int,\n \n %token <opcode> ASSIGN_MODIFY\n %token <opcode> UNOP_INTRINSIC BINOP_INTRINSIC\n+%token <opcode> UNOP_OR_BINOP_INTRINSIC\n \n %left ','\n %left ABOVE_COMMA\n@@ -246,6 +247,21 @@ exp\t:\tKIND '(' exp ')'       %prec UNARY\n \t\t\t{ write_exp_elt_opcode (pstate, UNOP_FORTRAN_KIND); }\n \t;\n \n+exp\t:\tUNOP_OR_BINOP_INTRINSIC '('\n+\t\t\t{ pstate->start_arglist (); }\n+\t\tone_or_two_args ')'\n+\t\t\t{ write_exp_elt_opcode (pstate, $1);\n+\t\t\t  write_exp_elt_longcst (pstate, pstate->end_arglist ());\n+\t\t\t  write_exp_elt_opcode (pstate, $1); }\n+\t;\n+\n+one_or_two_args\n+\t:\texp\n+\t\t\t{ pstate->arglist_len = 1; }\n+\t|\texp ',' exp\n+\t\t\t{ pstate->arglist_len = 2; }\n+\t;\n+\n /* No more explicit array operators, we treat everything in F77 as \n    a function call.  The disambiguation as to whether we are \n    doing a subscript operation or a function call is done \n@@ -1028,6 +1044,8 @@ static const struct token f77_keywords[] =\n   { \"ceiling\", UNOP_INTRINSIC, UNOP_FORTRAN_CEILING, false },\n   { \"modulo\", BINOP_INTRINSIC, BINOP_FORTRAN_MODULO, false },\n   { \"cmplx\", BINOP_INTRINSIC, BINOP_FORTRAN_CMPLX, false },\n+  { \"lbound\", UNOP_OR_BINOP_INTRINSIC, FORTRAN_LBOUND, false },\n+  { \"ubound\", UNOP_OR_BINOP_INTRINSIC, FORTRAN_UBOUND, false },\n };\n \n /* Implementation of a dynamically expandable buffer for processing input"
    },
    {
      "sha": "57dd2ed7e3156209c66e2d25764e59eb42f1daa6",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 172,
      "deletions": 0,
      "changes": 172,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=e92c8eb86dcef673652644694c832c504cf9a9a9",
      "patch": "@@ -128,6 +128,107 @@ const struct op_print f_language::op_print_tab[] =\n };\n \f\n \n+/* Create an array containing the lower bounds (when LBOUND_P is true) or\n+   the upper bounds (when LBOUND_P is false) of ARRAY (which must be of\n+   array type).  GDBARCH is the current architecture.  */\n+\n+static struct value *\n+fortran_bounds_all_dims (bool lbound_p,\n+\t\t\t struct gdbarch *gdbarch,\n+\t\t\t struct value *array)\n+{\n+  type *array_type = check_typedef (value_type (array));\n+  int ndimensions = calc_f77_array_dims (array_type);\n+\n+  /* Allocate a result value of the correct type.  */\n+  struct type *range\n+    = create_static_range_type (nullptr,\n+\t\t\t\tbuiltin_type (gdbarch)->builtin_int,\n+\t\t\t\t1, ndimensions);\n+  struct type *elm_type = builtin_type (gdbarch)->builtin_long_long;\n+  struct type *result_type = create_array_type (nullptr, elm_type, range);\n+  struct value *result = allocate_value (result_type);\n+\n+  /* Walk the array dimensions backwards due to the way the array will be\n+     laid out in memory, the first dimension will be the most inner.  */\n+  LONGEST elm_len = TYPE_LENGTH (elm_type);\n+  for (LONGEST dst_offset = elm_len * (ndimensions - 1);\n+       dst_offset >= 0;\n+       dst_offset -= elm_len)\n+    {\n+      LONGEST b;\n+\n+      /* Grab the required bound.  */\n+      if (lbound_p)\n+\tb = f77_get_lowerbound (array_type);\n+      else\n+\tb = f77_get_upperbound (array_type);\n+\n+      /* And copy the value into the result value.  */\n+      struct value *v = value_from_longest (elm_type, b);\n+      gdb_assert (dst_offset + TYPE_LENGTH (value_type (v))\n+\t\t  <= TYPE_LENGTH (value_type (result)));\n+      gdb_assert (TYPE_LENGTH (value_type (v)) == elm_len);\n+      value_contents_copy (result, dst_offset, v, 0, elm_len);\n+\n+      /* Peel another dimension of the array.  */\n+      array_type = TYPE_TARGET_TYPE (array_type);\n+    }\n+\n+  return result;\n+}\n+\n+/* Return the lower bound (when LBOUND_P is true) or the upper bound (when\n+   LBOUND_P is false) for dimension DIM_VAL (which must be an integer) of\n+   ARRAY (which must be an array).  GDBARCH is the current architecture.  */\n+\n+static struct value *\n+fortran_bounds_for_dimension (bool lbound_p,\n+\t\t\t      struct gdbarch *gdbarch,\n+\t\t\t      struct value *array,\n+\t\t\t      struct value *dim_val)\n+{\n+  /* Check the requested dimension is valid for this array.  */\n+  type *array_type = check_typedef (value_type (array));\n+  int ndimensions = calc_f77_array_dims (array_type);\n+  long dim = value_as_long (dim_val);\n+  if (dim < 1 || dim > ndimensions)\n+    {\n+      if (lbound_p)\n+\terror (_(\"LBOUND dimension must be from 1 to %d\"), ndimensions);\n+      else\n+\terror (_(\"UBOUND dimension must be from 1 to %d\"), ndimensions);\n+    }\n+\n+  /* The type for the result.  */\n+  struct type *bound_type = builtin_type (gdbarch)->builtin_long_long;\n+\n+  /* Walk the dimensions backwards, due to the ordering in which arrays are\n+     laid out the first dimension is the most inner.  */\n+  for (int i = ndimensions - 1; i >= 0; --i)\n+    {\n+      /* If this is the requested dimension then we're done.  Grab the\n+\t bounds and return.  */\n+      if (i == dim - 1)\n+\t{\n+\t  LONGEST b;\n+\n+\t  if (lbound_p)\n+\t    b = f77_get_lowerbound (array_type);\n+\t  else\n+\t    b = f77_get_upperbound (array_type);\n+\n+\t  return value_from_longest (bound_type, b);\n+\t}\n+\n+      /* Peel off another dimension of the array.  */\n+      array_type = TYPE_TARGET_TYPE (array_type);\n+    }\n+\n+  gdb_assert_not_reached (\"failed to find matching dimension\");\n+}\n+\f\n+\n /* Return the number of dimensions for a Fortran array or string.  */\n \n int\n@@ -843,6 +944,47 @@ evaluate_subexp_f (struct type *expect_type, struct expression *exp,\n \terror (_(\"MODULO of type %s not supported\"), TYPE_SAFE_NAME (type));\n       }\n \n+    case FORTRAN_LBOUND:\n+    case FORTRAN_UBOUND:\n+      {\n+\tint nargs = longest_to_int (exp->elts[pc + 1].longconst);\n+\t(*pos) += 2;\n+\n+\t/* This assertion should be enforced by the expression parser.  */\n+\tgdb_assert (nargs == 1 || nargs == 2);\n+\n+\tbool lbound_p = op == FORTRAN_LBOUND;\n+\n+\t/* Check that the first argument is array like.  */\n+\targ1 = evaluate_subexp (nullptr, exp, pos, noside);\n+\ttype = check_typedef (value_type (arg1));\n+\tif (type->code () != TYPE_CODE_ARRAY)\n+\t  {\n+\t    if (lbound_p)\n+\t      error (_(\"LBOUND can only be applied to arrays\"));\n+\t    else\n+\t      error (_(\"UBOUND can only be applied to arrays\"));\n+\t  }\n+\n+\tif (nargs == 1)\n+\t  return fortran_bounds_all_dims (lbound_p, exp->gdbarch, arg1);\n+\n+\t/* User asked for the bounds of a specific dimension of the array.  */\n+\targ2 = evaluate_subexp (nullptr, exp, pos, noside);\n+\ttype = check_typedef (value_type (arg2));\n+\tif (type->code () != TYPE_CODE_INT)\n+\t  {\n+\t    if (lbound_p)\n+\t      error (_(\"LBOUND second argument should be an integer\"));\n+\t    else\n+\t      error (_(\"UBOUND second argument should be an integer\"));\n+\t  }\n+\n+\treturn fortran_bounds_for_dimension (lbound_p, exp->gdbarch, arg1,\n+\t\t\t\t\t     arg2);\n+      }\n+      break;\n+\n     case BINOP_FORTRAN_CMPLX:\n       arg1 = evaluate_subexp (nullptr, exp, pos, noside);\n       arg2 = evaluate_subexp (value_type (arg1), exp, pos, noside);\n@@ -986,6 +1128,12 @@ operator_length_f (const struct expression *exp, int pc, int *oplenp,\n       args = 2;\n       break;\n \n+    case FORTRAN_LBOUND:\n+    case FORTRAN_UBOUND:\n+      oplen = 3;\n+      args = longest_to_int (exp->elts[pc - 2].longconst);\n+      break;\n+\n     case OP_F77_UNDETERMINED_ARGLIST:\n       oplen = 3;\n       args = 1 + longest_to_int (exp->elts[pc - 2].longconst);\n@@ -1063,6 +1211,23 @@ print_subexp_f (struct expression *exp, int *pos,\n       print_binop_subexp_f (exp, pos, stream, prec, \"MODULO\");\n       return;\n \n+    case FORTRAN_LBOUND:\n+    case FORTRAN_UBOUND:\n+      {\n+\tunsigned nargs = longest_to_int (exp->elts[*pos + 1].longconst);\n+\t(*pos) += 3;\n+\tfprintf_filtered (stream, \"%s (\",\n+\t\t\t  ((op == FORTRAN_LBOUND) ? \"LBOUND\" : \"UBOUND\"));\n+\tfor (unsigned tem = 0; tem < nargs; tem++)\n+\t  {\n+\t    if (tem != 0)\n+\t      fputs_filtered (\", \", stream);\n+\t    print_subexp (exp, pos, stream, PREC_ABOVE_COMMA);\n+\t  }\n+\tfputs_filtered (\")\", stream);\n+\treturn;\n+      }\n+\n     case OP_F77_UNDETERMINED_ARGLIST:\n       (*pos)++;\n       print_subexp_funcall (exp, pos, stream);\n@@ -1092,6 +1257,11 @@ dump_subexp_body_f (struct expression *exp,\n       operator_length_f (exp, (elt + 1), &oplen, &nargs);\n       break;\n \n+    case FORTRAN_LBOUND:\n+    case FORTRAN_UBOUND:\n+      operator_length_f (exp, (elt + 3), &oplen, &nargs);\n+      break;\n+\n     case OP_F77_UNDETERMINED_ARGLIST:\n       return dump_subexp_body_funcall (exp, stream, elt + 1);\n     }\n@@ -1120,6 +1290,8 @@ operator_check_f (struct expression *exp, int pos,\n     case UNOP_FORTRAN_CEILING:\n     case BINOP_FORTRAN_CMPLX:\n     case BINOP_FORTRAN_MODULO:\n+    case FORTRAN_LBOUND:\n+    case FORTRAN_UBOUND:\n       /* Any references to objfiles are held in the arguments to this\n \t expression, not within the expression itself, so no additional\n \t checking is required here, the outer expression iteration code"
    },
    {
      "sha": "aad89990c5b0f3241627a45556fd3965821508be",
      "filename": "gdb/std-operator.def",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/std-operator.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/std-operator.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/std-operator.def?ref=e92c8eb86dcef673652644694c832c504cf9a9a9",
      "patch": "@@ -442,3 +442,7 @@ OP (UNOP_FORTRAN_CEILING)\n /* Two operand builtins.  */\n OP (BINOP_FORTRAN_CMPLX)\n OP (BINOP_FORTRAN_MODULO)\n+\n+/* Builtins that take one or two operands.  */\n+OP (FORTRAN_LBOUND)\n+OP (FORTRAN_UBOUND)"
    },
    {
      "sha": "6d10953d7058970dacbb251ab7253bf9777cae4e",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=e92c8eb86dcef673652644694c832c504cf9a9a9",
      "patch": "@@ -1,3 +1,8 @@\n+2021-02-10  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.fortran/lbound-ubound.F90: New file.\n+\t* gdb.fortran/lbound-ubound.exp: New file.\n+\n 2021-02-10  Tom de Vries  <tdevries@suse.de>\n \n \t* lib/gdb.exp (gdb_load_no_complaints): Remove unnecessary"
    },
    {
      "sha": "1988760e67083f15993f8168fa7da20ee48cb6b4",
      "filename": "gdb/testsuite/gdb.fortran/lbound-ubound.F90",
      "status": "added",
      "additions": 105,
      "deletions": 0,
      "changes": 105,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/testsuite/gdb.fortran/lbound-ubound.F90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/testsuite/gdb.fortran/lbound-ubound.F90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/lbound-ubound.F90?ref=e92c8eb86dcef673652644694c832c504cf9a9a9",
      "patch": "@@ -0,0 +1,105 @@\n+! Copyright 2021 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+#define DO_TEST(ARRAY)\t\\\n+  call do_test (lbound (ARRAY), ubound (ARRAY))\n+\n+subroutine do_test (lb, ub)\n+  integer, dimension (:) :: lb\n+  integer, dimension (:) :: ub\n+\n+  print *, \"\"\n+  print *, \"Expected GDB Output:\"\n+  print *, \"\"\n+\n+  write(*, fmt=\"(A)\", advance=\"no\") \"LBOUND = (\"\n+  do i=LBOUND (lb, 1), UBOUND (lb, 1), 1\n+     if (i > LBOUND (lb, 1)) then\n+        write(*, fmt=\"(A)\", advance=\"no\") \", \"\n+     end if\n+     write(*, fmt=\"(I0)\", advance=\"no\") lb (i)\n+  end do\n+  write(*, fmt=\"(A)\", advance=\"yes\") \")\"\n+\n+  write(*, fmt=\"(A)\", advance=\"no\") \"UBOUND = (\"\n+  do i=LBOUND (ub, 1), UBOUND (ub, 1), 1\n+     if (i > LBOUND (ub, 1)) then\n+        write(*, fmt=\"(A)\", advance=\"no\") \", \"\n+     end if\n+     write(*, fmt=\"(I0)\", advance=\"no\") ub (i)\n+  end do\n+  write(*, fmt=\"(A)\", advance=\"yes\") \")\"\n+\n+  print *, \"\"\t! Test Breakpoint\n+end subroutine do_test\n+\n+!\n+! Start of test program.\n+!\n+program test\n+  interface\n+     subroutine do_test (lb, ub)\n+       integer, dimension (:) :: lb\n+       integer, dimension (:) :: ub\n+     end subroutine do_test\n+  end interface\n+\n+  ! Declare variables used in this test.\n+  integer, dimension (-8:-1,-10:-2) :: neg_array\n+  integer, dimension (2:10,1:9), target :: array\n+  integer, allocatable :: other (:, :)\n+  character (len=26) :: str_1 = \"abcdefghijklmnopqrstuvwxyz\"\n+  integer, dimension (-2:2,-3:3,-1:5) :: array3d\n+  integer, dimension (-3:3,7:10,-4:2,-10:-7) :: array4d\n+  integer, dimension (10:20) :: array1d\n+  integer, dimension(:,:), pointer :: pointer2d => null()\n+  integer, dimension(-2:6,-1:9), target :: tarray\n+  integer :: an_int\n+\n+  integer, dimension (:), pointer :: pointer1d => null()\n+\n+  ! Allocate or associate any variables as needed.\n+  allocate (other (-5:4, -2:7))\n+  pointer2d => tarray\n+  pointer1d => array (3, 2:5)\n+\n+  DO_TEST (neg_array)\n+  DO_TEST (neg_array (-7:-3,-5:-4))\n+  DO_TEST (array)\n+  ! The following is disabled due to a bug in gfortran:\n+  !   https://gcc.gnu.org/bugzilla/show_bug.cgi?id=99027\n+  ! gfortran generates the incorrect expected results.\n+  ! DO_TEST (array (3, 2:5))\n+  DO_TEST (pointer1d)\n+  DO_TEST (other)\n+  DO_TEST (array3d)\n+  DO_TEST (array4d)\n+  DO_TEST (array1d)\n+  DO_TEST (pointer2d)\n+  DO_TEST (tarray)\n+\n+  ! All done.  Deallocate.\n+  deallocate (other)\n+\n+  ! GDB catches this final breakpoint to indicate the end of the test.\n+  print *, \"\" ! Final Breakpoint.\n+\n+  ! Reference otherwise unused locals in order to keep them around.\n+  ! GDB will make use of these for some tests.\n+  print *, str_1\n+  an_int = 1\n+  print *, an_int\n+\n+end program test"
    },
    {
      "sha": "597851ef454eefefeba013f0cbfeaf4b91e7c502",
      "filename": "gdb/testsuite/gdb.fortran/lbound-ubound.exp",
      "status": "added",
      "additions": 204,
      "deletions": 0,
      "changes": 204,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/testsuite/gdb.fortran/lbound-ubound.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e92c8eb86dcef673652644694c832c504cf9a9a9/gdb/testsuite/gdb.fortran/lbound-ubound.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/lbound-ubound.exp?ref=e92c8eb86dcef673652644694c832c504cf9a9a9",
      "patch": "@@ -0,0 +1,204 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/> .\n+\n+# Print a 2 dimensional assumed shape array.  We pass different slices\n+# of the array to a subroutine and print the array as recieved within\n+# the subroutine.  This should exercise GDB's ability to handle\n+# different strides for the different dimensions.\n+\n+# Testing GDB's implementation of LBOUND and UBOUND.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+\n+standard_testfile \".F90\"\n+load_lib fortran.exp\n+\n+if {[prepare_for_testing ${testfile}.exp ${testfile} ${srcfile} \\\n+\t {debug f90}]} {\n+    return -1\n+}\n+\n+\n+if ![fortran_runto_main] {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+gdb_breakpoint [gdb_get_line_number \"Test Breakpoint\"]\n+gdb_breakpoint [gdb_get_line_number \"Final Breakpoint\"]\n+\n+set found_final_breakpoint false\n+\n+# We place a limit on the number of tests that can be run, just in\n+# case something goes wrong, and GDB gets stuck in an loop here.\n+set test_count 0\n+while { $test_count < 500 } {\n+    with_test_prefix \"test $test_count\" {\n+\tincr test_count\n+\n+\tset expected_lbound \"\"\n+\tset expected_ubound \"\"\n+\tgdb_test_multiple \"continue\" \"continue\" {\n+\t    -re \".*LBOUND = (\\[^\\r\\n\\]+)\\r\\n\" {\n+\t\tset expected_lbound $expect_out(1,string)\n+\t\texp_continue\n+\t    }\n+\t    -re \".*UBOUND = (\\[^\\r\\n\\]+)\\r\\n\" {\n+\t\tset expected_ubound $expect_out(1,string)\n+\t\texp_continue\n+\t    }\n+\t    -re \"! Test Breakpoint\" {\n+\t\tset func_name \"show_elem\"\n+\t\texp_continue\n+\t    }\n+\t    -re \"! Final Breakpoint\" {\n+\t\tset found_final_breakpoint true\n+\t\texp_continue\n+\t    }\n+\t    -re \"$gdb_prompt $\" {\n+\t\t# We're done.\n+\t    }\n+\t}\n+\n+\tif ($found_final_breakpoint) {\n+\t    break\n+\t}\n+\n+\tverbose -log \"APB: Run a test here\"\n+\tverbose -log \"APB: Expected lbound '$expected_lbound'\"\n+\tverbose -log \"APB: Expected ubound '$expected_ubound'\"\n+\n+\t# We want to take a look at the line in the previous frame that\n+\t# called the current function.  I couldn't find a better way of\n+\t# doing this than 'up', which will print the line, then 'down'\n+\t# again.\n+\t#\n+\t# I don't want to fill the log with passes for these up/down\n+\t# commands, so we don't report any.  If something goes wrong then we\n+\t# should get a fail from gdb_test_multiple.\n+\tset array_name \"\"\n+\tset xfail_data \"\"\n+\tgdb_test_multiple \"up\" \"up\" {\n+\t    -re \"\\r\\n\\[0-9\\]+\\[ \\t\\]+DO_TEST \\\\((\\[^\\r\\n\\]+)\\\\)\\r\\n$gdb_prompt $\" {\n+\t\tset array_name $expect_out(1,string)\n+\t    }\n+\t}\n+\n+\t# Check we have all the information we need to successfully run one\n+\t# of these tests.\n+\tif { $expected_lbound == \"\" } {\n+\t    perror \"failed to extract expected results for lbound\"\n+\t    return 0\n+\t}\n+\tif { $expected_ubound == \"\" } {\n+\t    perror \"failed to extract expected results for ubound\"\n+\t    return 0\n+\t}\n+\tif { $array_name == \"\" } {\n+\t    perror \"failed to extract array name\"\n+\t    return 0\n+\t}\n+\n+\t# Check GDB can correctly print complete set of upper and\n+\t# lower bounds for an array.\n+\tset pattern [string_to_regexp \" = $expected_lbound\"]\n+\tgdb_test \"p lbound ($array_name)\" \"$pattern\" \\\n+\t    \"check value of lbound ('$array_name') expression\"\n+\tset pattern [string_to_regexp \" = $expected_ubound\"]\n+\tgdb_test \"p ubound ($array_name)\" \"$pattern\" \\\n+\t    \"check value of ubound ('$array_name') expression\"\n+\n+\t# Now ask for each bound in turn and check it against the\n+\t# expected results.\n+\t#\n+\t# First ask for bound 0.  This should fail, but will also tell\n+\t# us the actual bounds of the array.  Thanks GDB.\n+\tset upper_dim \"\"\n+\tgdb_test_multiple \"p lbound ($array_name, 0)\" \"\" {\n+\t    -re \"\\r\\nLBOUND dimension must be from 1 to (\\[0-9\\]+)\\r\\n$gdb_prompt $\" {\n+\t\tset upper_dim $expect_out(1,string)\n+\t    }\n+\t}\n+\n+\tgdb_assert { ![string eq $upper_dim \"\"] } \\\n+\t    \"extracted the upper dimension value\"\n+\n+\t# Check that asking for the ubound dimension 0 gives the same\n+\t# dimension range as in the lbound case.\n+\tgdb_test_multiple \"p ubound ($array_name, 0)\" \"\" {\n+\t    -re \"\\r\\nUBOUND dimension must be from 1 to (\\[0-9\\]+)\\r\\n$gdb_prompt $\" {\n+\t\tgdb_assert {$upper_dim == $expect_out(1,string)} \\\n+\t\t    \"ubound limit matches lbound limit\"\n+\t    }\n+\t}\n+\n+\t# Now ask for the upper and lower bound for each dimension in\n+\t# turn.  Add these results into a string which, when complete,\n+\t# will look like the expected results seen above.\n+\tset lbound_str \"\"\n+\tset ubound_str \"\"\n+\tset prefix \"(\"\n+\tfor { set i 1 } { $i <= $upper_dim } { incr i } {\n+\t    set v [get_valueof \"/d\" \"lbound ($array_name, $i)\" \"???\"]\n+\t    set lbound_str \"${lbound_str}${prefix}${v}\"\n+\n+\t    set v [get_valueof \"/d\" \"ubound ($array_name, $i)\" \"???\"]\n+\t    set ubound_str \"${ubound_str}${prefix}${v}\"\n+\n+\t    set prefix \", \"\n+\t}\n+\n+\t# Add closing parenthesis.\n+\tset lbound_str \"${lbound_str})\"\n+\tset ubound_str \"${ubound_str})\"\n+\n+\tgdb_assert [string eq ${lbound_str} $expected_lbound] \\\n+\t    \"lbounds match\"\n+\tgdb_assert [string eq ${ubound_str} $expected_ubound] \\\n+\t    \"ubounds match\"\n+\n+\t# Finally, check that asking for a dimension above the valid\n+\t# range gives the expected error.\n+\tset bad_dim [expr $upper_dim + 1]\n+\tgdb_test \"p lbound ($array_name, $bad_dim)\" \\\n+\t    \"LBOUND dimension must be from 1 to $upper_dim\" \\\n+\t    \"check error message for lbound of dim = $bad_dim\"\n+\n+\tgdb_test \"p ubound ($array_name, $bad_dim)\" \\\n+\t    \"UBOUND dimension must be from 1 to $upper_dim\" \\\n+\t    \"check error message for ubound of dim = $bad_dim\"\n+\n+\t# Move back up a frame just so we finish the test in frame 0.\n+\tgdb_test_multiple \"down\" \"down\" {\n+\t    -re \"\\r\\n$gdb_prompt $\" {\n+\t\t# Don't issue a pass here.\n+\t    }\n+\t}\n+    }\n+}\n+\n+# Ensure we reached the final breakpoint.  If more tests have been added\n+# to the test script, and this starts failing, then the safety 'while'\n+# loop above might need to be increased.\n+gdb_assert {$found_final_breakpoint} \"reached final breakpoint\"\n+\n+# Now for some final tests.  This is mostly testing that GDB gives the\n+# correct errors in certain cases.\n+foreach var {str_1 an_int} {\n+    foreach func {lbound ubound} {\n+\tgdb_test \"p ${func} ($var)\" \\\n+\t    \"[string toupper $func] can only be applied to arrays\"\n+    }\n+}"
    }
  ]
}