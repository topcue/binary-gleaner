{
  "sha": "1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWY2ZjZlMjFmYTg2ZGMzNDExYTY0OTg2MDhmMzJlOWViMjRiNzg1MQ==",
  "commit": {
    "author": {
      "name": "Philippe Waroquiers",
      "email": "philippe.waroquiers@skynet.be",
      "date": "2019-06-10T19:41:51Z"
    },
    "committer": {
      "name": "Philippe Waroquiers",
      "email": "philippe.waroquiers@skynet.be",
      "date": "2019-07-08T21:31:54Z"
    },
    "message": "Ensure GDB printf command can print convenience var strings without a target.\n\nWithout this patch, GDB printf command calls malloc on the target,\nwrites the convenience var content to the target,\nre-reads the content from the target, and then locally printf the string.\n\nThis implies inferior calls, and does not work when there is no running\ninferior, or when the inferior is a core dump.\n\nWith this patch, printf command can printf string convenience variables\nwithout inferior function calls.\nAda string convenience variables can also be printed.\n\ngdb/ChangeLog\n2019-07-08  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n\n\t* NEWS: Mention that GDB printf and eval commands can now print\n\tC-style and Ada-style convenience var strings without\n\tcalling the inferior.\n\t* printcmd.c (printf_c_string): Locally print GDB internal var\n\tinstead of transiting via the inferior.\n\t(printf_wide_c_string): Likewise.\n\ngdb/testsuite/ChangeLog\n2019-07-08  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n\n\t* gdb.base/printcmds.exp: Test printing C string and\n\tC wide string convenience vars without transiting via the inferior.\n\tAlso make test names unique.",
    "tree": {
      "sha": "37520dd0294952b805f1358230555b20e89bd4a9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/37520dd0294952b805f1358230555b20e89bd4a9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "ea142fbfc9c1708a83d3532257d6728e1f5c142e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ea142fbfc9c1708a83d3532257d6728e1f5c142e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ea142fbfc9c1708a83d3532257d6728e1f5c142e"
    }
  ],
  "stats": {
    "total": 223,
    "additions": 165,
    "deletions": 58
  },
  "files": [
    {
      "sha": "2f406ae2bd044c2ce19e4c45fa7919b52fb0ee67",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 1,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
      "patch": "@@ -1,4 +1,13 @@\n-2019-08-04  Alan Hayward  <alan.hayward@arm.com>\n+2019-07-08  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n+\n+\t* NEWS: Mention that GDB printf and eval commands can now print\n+\tC-style and Ada-style convenience var strings without\n+\tcalling the inferior.\n+\t* printcmd.c (printf_c_string): Locally print GDB internal var\n+\tinstead of transiting via the inferior.\n+\t(printf_wide_c_string): Likewise.\n+\n+2019-07-04  Alan Hayward  <alan.hayward@arm.com>\n \n \t* symfile.c (symbol_file_command): Call solib_create_inferior_hook.\n "
    },
    {
      "sha": "f7b6b88a220f214b941fb7d9b394adf8d0e6216a",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
      "patch": "@@ -118,6 +118,13 @@ apropos [-v] REGEXP\n   of matching commands and to use the highlight style to mark\n   the documentation parts matching REGEXP.\n \n+printf\n+eval\n+  The GDB printf and eval commands can now print C-style and Ada-style\n+  string convenience variables without calling functions in the program.\n+  This allows to do formatted printing of strings without having\n+  a running inferior, or when debugging a core dump.\n+\n show style\n   The \"show style\" and its subcommands are now styling\n   a style name in their output using its own style, to help"
    },
    {
      "sha": "714a2e981ea705d3508b0a410007d3b67ecf9822",
      "filename": "gdb/printcmd.c",
      "status": "modified",
      "additions": 88,
      "deletions": 52,
      "changes": 140,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/printcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/printcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/printcmd.c?ref=1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
      "patch": "@@ -23,6 +23,7 @@\n #include \"gdbtypes.h\"\n #include \"value.h\"\n #include \"language.h\"\n+#include \"c-lang.h\"\n #include \"expression.h\"\n #include \"gdbcore.h\"\n #include \"gdbcmd.h\"\n@@ -2222,42 +2223,64 @@ print_variable_and_value (const char *name, struct symbol *var,\n \n /* Subroutine of ui_printf to simplify it.\n    Print VALUE to STREAM using FORMAT.\n-   VALUE is a C-style string on the target.  */\n+   VALUE is a C-style string either on the target or\n+   in a GDB internal variable.  */\n \n static void\n printf_c_string (struct ui_file *stream, const char *format,\n \t\t struct value *value)\n {\n-  gdb_byte *str;\n-  CORE_ADDR tem;\n-  int j;\n+  const gdb_byte *str;\n \n-  tem = value_as_address (value);\n-  if (tem == 0)\n+  if (VALUE_LVAL (value) == lval_internalvar\n+      && c_is_string_type_p (value_type (value)))\n     {\n-      DIAGNOSTIC_PUSH\n-      DIAGNOSTIC_IGNORE_FORMAT_NONLITERAL\n-      fprintf_filtered (stream, format, \"(null)\");\n-      DIAGNOSTIC_POP\n-      return;\n-    }\n+      size_t len = TYPE_LENGTH (value_type (value));\n \n-  /* This is a %s argument.  Find the length of the string.  */\n-  for (j = 0;; j++)\n-    {\n-      gdb_byte c;\n+      /* Copy the internal var value to TEM_STR and append a terminating null\n+\t character.  This protects against corrupted C-style strings that lack\n+\t the terminating null char.  It also allows Ada-style strings (not\n+\t null terminated) to be printed without problems.  */\n+      gdb_byte *tem_str = (gdb_byte *) alloca (len + 1);\n \n-      QUIT;\n-      read_memory (tem + j, &c, 1);\n-      if (c == 0)\n-\tbreak;\n+      memcpy (tem_str, value_contents (value), len);\n+      tem_str [len] = 0;\n+      str = tem_str;\n     }\n+  else\n+    {\n+      CORE_ADDR tem = value_as_address (value);;\n+\n+      if (tem == 0)\n+\t{\n+\t  DIAGNOSTIC_PUSH\n+\t  DIAGNOSTIC_IGNORE_FORMAT_NONLITERAL\n+\t  fprintf_filtered (stream, format, \"(null)\");\n+\t  DIAGNOSTIC_POP\n+\t  return;\n+\t}\n+\n+      /* This is a %s argument.  Find the length of the string.  */\n+      size_t len;\n+\n+      for (len = 0;; len++)\n+\t{\n+\t  gdb_byte c;\n \n-  /* Copy the string contents into a string inside GDB.  */\n-  str = (gdb_byte *) alloca (j + 1);\n-  if (j != 0)\n-    read_memory (tem, str, j);\n-  str[j] = 0;\n+\t  QUIT;\n+\t  read_memory (tem + len, &c, 1);\n+\t  if (c == 0)\n+\t    break;\n+\t}\n+\n+      /* Copy the string contents into a string inside GDB.  */\n+      gdb_byte *tem_str = (gdb_byte *) alloca (len + 1);\n+\n+      if (len != 0)\n+\tread_memory (tem, tem_str, len);\n+      tem_str[len] = 0;\n+      str = tem_str;\n+    }\n \n   DIAGNOSTIC_PUSH\n   DIAGNOSTIC_IGNORE_FORMAT_NONLITERAL\n@@ -2267,52 +2290,65 @@ printf_c_string (struct ui_file *stream, const char *format,\n \n /* Subroutine of ui_printf to simplify it.\n    Print VALUE to STREAM using FORMAT.\n-   VALUE is a wide C-style string on the target.  */\n+   VALUE is a wide C-style string on the target or\n+   in a GDB internal variable.  */\n \n static void\n printf_wide_c_string (struct ui_file *stream, const char *format,\n \t\t      struct value *value)\n {\n-  gdb_byte *str;\n-  CORE_ADDR tem;\n-  int j;\n+  const gdb_byte *str;\n+  size_t len;\n   struct gdbarch *gdbarch = get_type_arch (value_type (value));\n-  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n   struct type *wctype = lookup_typename (current_language, gdbarch,\n \t\t\t\t\t \"wchar_t\", NULL, 0);\n   int wcwidth = TYPE_LENGTH (wctype);\n-  gdb_byte *buf = (gdb_byte *) alloca (wcwidth);\n \n-  tem = value_as_address (value);\n-  if (tem == 0)\n+  if (VALUE_LVAL (value) == lval_internalvar\n+      && c_is_string_type_p (value_type (value)))\n     {\n-      DIAGNOSTIC_PUSH\n-      DIAGNOSTIC_IGNORE_FORMAT_NONLITERAL\n-      fprintf_filtered (stream, format, \"(null)\");\n-      DIAGNOSTIC_POP\n-      return;\n+      str = value_contents (value);\n+      len = TYPE_LENGTH (value_type (value));\n     }\n-\n-  /* This is a %s argument.  Find the length of the string.  */\n-  for (j = 0;; j += wcwidth)\n+  else\n     {\n-      QUIT;\n-      read_memory (tem + j, buf, wcwidth);\n-      if (extract_unsigned_integer (buf, wcwidth, byte_order) == 0)\n-\tbreak;\n-    }\n+      CORE_ADDR tem = value_as_address (value);\n \n-  /* Copy the string contents into a string inside GDB.  */\n-  str = (gdb_byte *) alloca (j + wcwidth);\n-  if (j != 0)\n-    read_memory (tem, str, j);\n-  memset (&str[j], 0, wcwidth);\n+      if (tem == 0)\n+\t{\n+\t  DIAGNOSTIC_PUSH\n+\t  DIAGNOSTIC_IGNORE_FORMAT_NONLITERAL\n+\t  fprintf_filtered (stream, format, \"(null)\");\n+\t  DIAGNOSTIC_POP\n+\t  return;\n+\t}\n+\n+      /* This is a %s argument.  Find the length of the string.  */\n+      enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);\n+      gdb_byte *buf = (gdb_byte *) alloca (wcwidth);\n+\n+      for (len = 0;; len += wcwidth)\n+\t{\n+\t  QUIT;\n+\t  read_memory (tem + len, buf, wcwidth);\n+\t  if (extract_unsigned_integer (buf, wcwidth, byte_order) == 0)\n+\t    break;\n+\t}\n+\n+      /* Copy the string contents into a string inside GDB.  */\n+      gdb_byte *tem_str = (gdb_byte *) alloca (len + wcwidth);\n+\n+      if (len != 0)\n+\tread_memory (tem, tem_str, len);\n+      memset (&tem_str[len], 0, wcwidth);\n+      str = tem_str;\n+    }\n \n   auto_obstack output;\n \n   convert_between_encodings (target_wide_charset (gdbarch),\n \t\t\t     host_charset (),\n-\t\t\t     str, j, wcwidth,\n+\t\t\t     str, len, wcwidth,\n \t\t\t     &output, translit_char);\n   obstack_grow_str0 (&output, \"\");\n "
    },
    {
      "sha": "f8ef540b4e6a9e79e0e3c75d0d639b1a2391ce4b",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
      "patch": "@@ -1,3 +1,9 @@\n+2019-07-08  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n+\n+\t* gdb.base/printcmds.exp: Test printing C string and\n+\tC wide string convenience vars without transiting via the inferior.\n+\tAlso make test names unique.\n+\n 2019-07-08  Alan Hayward  <alan.hayward@arm.com>\n \n \t* gdb.base/break-idempotent.exp: Test both PIE and non PIE."
    },
    {
      "sha": "0e3126bcf26071434d088cde8db45236e35aacdd",
      "filename": "gdb/testsuite/gdb.base/printcmds.exp",
      "status": "modified",
      "additions": 54,
      "deletions": 5,
      "changes": 59,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/testsuite/gdb.base/printcmds.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6f6e21fa86dc3411a6498608f32e9eb24b7851/gdb/testsuite/gdb.base/printcmds.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/printcmds.exp?ref=1f6f6e21fa86dc3411a6498608f32e9eb24b7851",
      "patch": "@@ -438,7 +438,7 @@ proc test_print_repeats_10 {} {\n     global gdb_prompt decimal\n \n     for { set x 1 } { $x <= 16 } { incr x } {\n-\tgdb_test_no_output \"set print elements $x\"\n+\tgdb_test_no_output \"set print elements $x\" \"elements $x repeats\"\n \tfor { set e 1 } { $e <= 16 } {incr e } {\n \t    set v [expr $e - 1]\n \t    set command \"p &ctable2\\[${v}*16\\]\"\n@@ -596,7 +596,7 @@ proc test_print_strings {} {\n proc test_print_int_arrays {} {\n     global gdb_prompt\n \n-    gdb_test_no_output \"set print elements 24\"\n+    gdb_test_no_output \"set print elements 24\" \"elements 24 int arrays\"\n \n     gdb_test_escape_braces \"p int1dim\" \\\n \t\" = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}\"\n@@ -621,7 +621,7 @@ proc test_print_int_arrays {} {\n proc test_print_typedef_arrays {} {\n     global gdb_prompt\n \n-    gdb_test_no_output \"set print elements 24\"\n+    gdb_test_no_output \"set print elements 24\" \"elements 24 typedef_arrays\"\n \n     gdb_test_escape_braces \"p a1\" \\\n \t\" = {2, 4, 6, 8, 10, 12, 14, 16, 18, 20}\"\n@@ -666,7 +666,7 @@ proc test_print_char_arrays {} {\n     global gdb_prompt\n     global hex decimal\n \n-    gdb_test_no_output \"set print elements 24\"\n+    gdb_test_no_output \"set print elements 24\" \"elements 24 char_arrays\"\n     gdb_test_no_output \"set print address on\"\n \n     gdb_test \"p arrays\" \\\n@@ -684,7 +684,7 @@ proc test_print_char_arrays {} {\n     gdb_test \"p parrays->array5\"\t\" = \\\"hij\\\"\"\n     gdb_test \"p &parrays->array5\"\t\" = \\\\(unsigned char \\\\(\\\\*\\\\)\\\\\\[4\\\\\\]\\\\) $hex <arrays\\\\+$decimal>\"\n \n-    gdb_test_no_output \"set print address off\"\n+    gdb_test_no_output \"set print address off\" \"address off char arrays\"\n }\n \n proc test_print_string_constants {} {\n@@ -932,6 +932,42 @@ proc test_repeat_bytes {} {\n     }\n }\n \n+# Test printf of convenience variables.\n+# These tests can be done with or without a running inferior.\n+# PREFIX ensures uniqueness of test names.\n+# DO_WSTRING 1 tells to test printf of wide strings.  Wide strings tests\n+# must be skipped (DO_WSTRING 0) if the wchar_t type is not yet known by\n+# GDB, as this type is needed to create wide strings.\n+\n+proc test_printf_convenience_var {prefix do_wstring} {\n+\n+    with_test_prefix \"conv var: $prefix\" {\n+\tgdb_test_no_output \"set var \\$cstr = \\\"abcde\\\"\" \"set \\$cstr\"\n+\tgdb_test \"printf \\\"cstr val = %s\\\\n\\\", \\$cstr\" \"cstr val = abcde\" \\\n+\t    \"printf \\$cstr\"\n+\tgdb_test_no_output \"set var \\$abcde = \\\"ABCDE\\\"\" \"set \\$abcde\"\n+\tgdb_test \"eval \\\"print \\$%s\\\\n\\\", \\$cstr\" \"= \\\"ABCDE\\\"\" \\\n+\t    \"indirect print abcde\"\n+\t# Without a target, the below produces no output\n+\t# but with a target, it gives a warning.\n+\t# So, use gdb_test expecting \".*\" instead of gdb_test_no_output.\n+\tgdb_test \"set language ada\" \".*\" \"set language ada\"\n+\tgdb_test_no_output \"set var \\$astr := \\\"fghij\\\"\" \"set \\$astr\"\n+\tgdb_test \"printf \\\"astr val = %s\\\\n\\\", \\$astr\" \"astr val = fghij\" \\\n+\t    \"printf \\$astr\"\n+\tgdb_test_no_output \"set language auto\" \"set language auto\"\n+\tgdb_test \"printf \\\"astr val = %s\\\\n\\\", \\$astr\" \"astr val = fghij\" \\\n+\t    \"printf \\$astr, auto language\"\n+\tif {$do_wstring} {\n+\t    gdb_test_no_output \"set var \\$wstr = L\\\"facile\\\"\" \\\n+\t\t\"set \\$wstr\"\n+\t    gdb_test \"printf \\\"wstr val = %ls\\\\n\\\", \\$wstr\" \\\n+\t\t\"wstr val = facile\" \"printf \\$wstr\"\n+\t}\n+    }\n+}\n+\n+\n # Start with a fresh gdb.\n \n gdb_exit\n@@ -948,6 +984,11 @@ gdb_test \"ptype \\\"abc\\\"\" \" = char \\\\\\[4\\\\\\]\"\n gdb_test \"print \\$cvar = \\\"abc\\\"\" \" = \\\"abc\\\"\"\n gdb_test \"print sizeof (\\$cvar)\" \" = 4\"\n \n+# Similarly, printf of a string convenience var should work without a target.\n+# At this point, we cannot create a wide string convenience var, as the\n+# wchar_t type is not yet known, so skip the wide string tests.\n+test_printf_convenience_var \"no target\" 0\n+\n # GDB used to complete the explicit location options even when\n # printing expressions.\n gdb_test_no_output \"complete p -function\"\n@@ -977,6 +1018,14 @@ if ![runto_main] then {\n     return 0\n }\n \n+# With a running target, printf convenience vars should of course work.\n+test_printf_convenience_var \"with target\" 1\n+\n+# It should also work when inferior function calls are forbidden.\n+gdb_test_no_output \"set may-call-functions off\"\n+test_printf_convenience_var \"with target, may-call-functions off\" 1\n+gdb_test_no_output \"set may-call-functions on\"\n+\n test_integer_literals_accepted\n test_integer_literals_rejected\n test_float_accepted"
    }
  ]
}