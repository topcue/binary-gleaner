{
  "sha": "b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Yjg2MzUyY2ZjMTdmYjdmMDdkNWRhOWVmY2ZkNTlmOGIyYmQwOGVlZQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-05-07T23:01:14Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-07-12T11:09:53Z"
    },
    "message": "gdb/dwarf: Ensure the target type of ranges is not void\n\nIf a DW_TAG_subrange_type DWARF entry has no DW_AT_type then a default\ntype based on the size of an address on the current target is assumed.\nWe store this type as the target type for GDB's range types.\n\nCurrently GDB can create ranges for which the target type is VOID,\nthis is incorrect but seems to cause no problems. I believe the reason\nthis doesn't cause any issues is because the languages (for example\nAda) that actually make use of a ranges target type also have\ncompilers that generate DWARF that includes a DW_AT_type attribute.\n\nHowever, gfortran does not include a DW_AT_type, its DWARF instead\nrelies on the default target type.  This isn't currently a problem for\nGDB as gfortran doesn't make use of the target type when printing\nsubranges, but it shouldn't hurt to fix this issue now.\n\nI've added an assert into create_range_type that will catch this issue\nif it comes up again.\n\nThis was tested on an x86-64/GNU-Linux machine with both the Ada and\ngfortran compilers available with both '--target_board=unix' and\n'--target_board=unix/-m32'.  There are no user visible changes after\nthis commit.\n\ngdb/ChangeLog:\n\n\t* dwarf2read.c (read_subrange_index_type): New function.\n\t(read_subrange_type): Move code into new function and call it.\n\t* gdbtypes.c (create_range_type): Add some asserts.",
    "tree": {
      "sha": "dc4d45d16d17b894c3864560ceae7afeec01cfce",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/dc4d45d16d17b894c3864560ceae7afeec01cfce"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "603490bf53fe1885ef45f9d0fb783b32f8ef6049",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/603490bf53fe1885ef45f9d0fb783b32f8ef6049",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/603490bf53fe1885ef45f9d0fb783b32f8ef6049"
    }
  ],
  "stats": {
    "total": 103,
    "additions": 63,
    "deletions": 40
  },
  "files": [
    {
      "sha": "c8c2b4014d108af94bd32372105061028732f9e2",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
      "patch": "@@ -1,3 +1,9 @@\n+2019-07-12  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* dwarf2read.c (read_subrange_index_type): New function.\n+\t(read_subrange_type): Move code into new function and call it.\n+\t* gdbtypes.c (create_range_type): Add some asserts.\n+\n 2019-07-12  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* dwarf2loc.c (dwarf2_evaluate_property): Change return type, and"
    },
    {
      "sha": "e918792eabd71a8e5994acffe010140cb941b8e1",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 52,
      "deletions": 40,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
      "patch": "@@ -17752,6 +17752,56 @@ attr_to_dynamic_prop (const struct attribute *attr, struct die_info *die,\n   return 1;\n }\n \n+/* Read the DW_AT_type attribute for a sub-range.  If this attribute is not\n+   present (which is valid) then compute the default type based on the\n+   compilation units address size.  */\n+\n+static struct type *\n+read_subrange_index_type (struct die_info *die, struct dwarf2_cu *cu)\n+{\n+  struct type *index_type = die_type (die, cu);\n+\n+  /* Dwarf-2 specifications explicitly allows to create subrange types\n+     without specifying a base type.\n+     In that case, the base type must be set to the type of\n+     the lower bound, upper bound or count, in that order, if any of these\n+     three attributes references an object that has a type.\n+     If no base type is found, the Dwarf-2 specifications say that\n+     a signed integer type of size equal to the size of an address should\n+     be used.\n+     For the following C code: `extern char gdb_int [];'\n+     GCC produces an empty range DIE.\n+     FIXME: muller/2010-05-28: Possible references to object for low bound,\n+     high bound or count are not yet handled by this code.  */\n+  if (TYPE_CODE (index_type) == TYPE_CODE_VOID)\n+    {\n+      struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n+      struct gdbarch *gdbarch = get_objfile_arch (objfile);\n+      int addr_size = gdbarch_addr_bit (gdbarch) /8;\n+      struct type *int_type = objfile_type (objfile)->builtin_int;\n+\n+      /* Test \"int\", \"long int\", and \"long long int\" objfile types,\n+\t and select the first one having a size above or equal to the\n+\t architecture address size.  */\n+      if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n+\tindex_type = int_type;\n+      else\n+\t{\n+\t  int_type = objfile_type (objfile)->builtin_long;\n+\t  if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n+\t    index_type = int_type;\n+\t  else\n+\t    {\n+\t      int_type = objfile_type (objfile)->builtin_long_long;\n+\t      if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n+\t\tindex_type = int_type;\n+\t    }\n+\t}\n+    }\n+\n+  return index_type;\n+}\n+\n /* Read the given DW_AT_subrange DIE.  */\n \n static struct type *\n@@ -17766,7 +17816,8 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n   const char *name;\n   ULONGEST negative_mask;\n \n-  orig_base_type = die_type (die, cu);\n+  orig_base_type = read_subrange_index_type (die, cu);\n+\n   /* If ORIG_BASE_TYPE is a typedef, it will not be TYPE_UNSIGNED,\n      whereas the real type might be.  So, we use ORIG_BASE_TYPE when\n      creating the range type, but we use the result of check_typedef\n@@ -17848,45 +17899,6 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n \t\t       sect_offset_str (die->sect_off),\n \t\t       objfile_name (cu->per_cu->dwarf2_per_objfile->objfile));\n \t}\n-\t\n-    }\n-\n-  /* Dwarf-2 specifications explicitly allows to create subrange types\n-     without specifying a base type.\n-     In that case, the base type must be set to the type of\n-     the lower bound, upper bound or count, in that order, if any of these\n-     three attributes references an object that has a type.\n-     If no base type is found, the Dwarf-2 specifications say that\n-     a signed integer type of size equal to the size of an address should\n-     be used.\n-     For the following C code: `extern char gdb_int [];'\n-     GCC produces an empty range DIE.\n-     FIXME: muller/2010-05-28: Possible references to object for low bound,\n-     high bound or count are not yet handled by this code.  */\n-  if (TYPE_CODE (base_type) == TYPE_CODE_VOID)\n-    {\n-      struct objfile *objfile = cu->per_cu->dwarf2_per_objfile->objfile;\n-      struct gdbarch *gdbarch = get_objfile_arch (objfile);\n-      int addr_size = gdbarch_addr_bit (gdbarch) /8;\n-      struct type *int_type = objfile_type (objfile)->builtin_int;\n-\n-      /* Test \"int\", \"long int\", and \"long long int\" objfile types,\n-\t and select the first one having a size above or equal to the\n-\t architecture address size.  */\n-      if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n-\tbase_type = int_type;\n-      else\n-\t{\n-\t  int_type = objfile_type (objfile)->builtin_long;\n-\t  if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n-\t    base_type = int_type;\n-\t  else\n-\t    {\n-\t      int_type = objfile_type (objfile)->builtin_long_long;\n-\t      if (int_type && TYPE_LENGTH (int_type) >= addr_size)\n-\t\tbase_type = int_type;\n-\t    }\n-\t}\n     }\n \n   /* Normally, the DWARF producers are expected to use a signed"
    },
    {
      "sha": "177455e6126be7ff84e5706a6f495845c0d5203b",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=b86352cfc17fb7f07d5da9efcfd59f8b2bd08eee",
      "patch": "@@ -914,6 +914,11 @@ create_range_type (struct type *result_type, struct type *index_type,\n \t\t   const struct dynamic_prop *low_bound,\n \t\t   const struct dynamic_prop *high_bound)\n {\n+  /* The INDEX_TYPE should be a type capable of holding the upper and lower\n+     bounds, as such a zero sized, or void type makes no sense.  */\n+  gdb_assert (TYPE_CODE (index_type) != TYPE_CODE_VOID);\n+  gdb_assert (TYPE_LENGTH (index_type) > 0);\n+\n   if (result_type == NULL)\n     result_type = alloc_type_copy (index_type);\n   TYPE_CODE (result_type) = TYPE_CODE_RANGE;"
    }
  ]
}