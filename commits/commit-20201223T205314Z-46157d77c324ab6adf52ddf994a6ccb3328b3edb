{
  "sha": "46157d77c324ab6adf52ddf994a6ccb3328b3edb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NDYxNTdkNzdjMzI0YWI2YWRmNTJkZGY5OTRhNmNjYjMzMjhiM2VkYg==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-10-28T18:10:01Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2020-12-23T20:53:14Z"
    },
    "message": "gdb: move pascal_language into p-lang.h\n\nMove the pascal_language class declaration into the p-lang.h header\nfile.  This allows for the function implementations to be spread over\nthe different p-*.c files without the need for global trampoline\nfunctions.\n\nAs a consequence of this change many of the Pascal value and type\nprinting helper functions have become member functions within the\npascal_language class.\n\nThere should be no user visible changes after this commit.\n\ngdb/ChangeLog:\n\n\t* p-exp.y (exp): Update call to pascal_is_string_type.\n\t(pascal_parse): Rename to...\n\t(pascal_language::parser): ...this.\n\t* p-lang.c (is_pascal_string_type): Rename to...\n\t(pascal_is_string_type): ...this.\n\t(pascal_one_char): Rename to...\n\t(pascal_language::print_one_char): ...this.\n\t(pascal_printchar): Rename to...\n\t(pascal_language::printchar): ...this.  Update call to\n\tprint_one_char member function.\n\t(pascal_op_print_tab): Rename to...\n\t(pascal_language::op_print_tab): ...this.\n\t(class pascal_language): Moved to p-lang.h.\n\t(pascal_language::language_arch_info): Function implementation\n\tmoved out of class declaration.\n\t(pascal_language::printstr): Likewise.\n\t* p-lang.h (pascal_parse): Delete declaration.\n\t(pascal_is_string_type): Declare.\n\t(pascal_print_type): Delete declaration.\n\t(pascal_print_typedef): Delete declaration.\n\t(pascal_value_print_inner): Delete declaration.\n\t(pascal_value_print): Delete declaration.\n\t(pascal_type_print_method_args): Delete declaration.\n\t(is_pascal_string_type): Delete declaration.\n\t(pascal_printchar): Delete declaration.\n\t(pascal_builtin_types): Delete declaration.\n\t(pascal_type_print_base): Delete declaration.\n\t(pascal_type_print_varspec_prefix): Delete declaration.\n\t(class pascal_language): Moved here from p-lang.c.\n\t* p-typeprint.c (pascal_type_print_varspec_suffix): Delete\n\tdeclaration.\n\t(pascal_type_print_derivation_info): Delete declaration.\n\t(pascal_print_type): Rename to...\n\t(pascal_language::print_type): ...this.  Update calls to member\n\tfunctions.\n\t(pascal_print_typedef): Rename to...\n\t(pascal_language::print_typedef): ...this.  Update calls to member\n\tfunctions.\n\t(pascal_type_print_derivation_info): Rename to...\n\t(pascal_language::type_print_derivation_info): ...this.\n\t(pascal_type_print_method_args): Rename to...\n\t(pascal_language::type_print_method_args): ...this.\n\t(pascal_type_print_varspec_prefix): Rename to...\n\t(pascal_language::type_print_varspec_prefix): ...this.  Update\n\tcalls to member functions.\n\t(pascal_print_func_args): Rename to...\n\t(pascal_language::print_func_args): ...this.  Update calls to\n\tmember functions.\n\t(pascal_type_print_func_varspec_suffix): Rename to...\n\t(pascal_language::type_print_func_varspec_suffix): ...this.\n\tUpdate calls to member functions.\n\t(pascal_type_print_varspec_suffix): Rename to...\n\t(pascal_language::type_print_varspec_suffix): ...this.  Update\n\tcalls to member functions.\n\t(pascal_type_print_base): Rename to...\n\t(pascal_language::type_print_base): ...this.  Update calls to\n\tmember functions.\n\t* p-valprint.c (pascal_value_print_inner): Rename to...\n\t(pascal_language::value_print_inner): ...this.  Update calls to\n\tmember functions.\n\t(pascal_value_print): Rename to...\n\t(pascal_language::value_print): ...this.  Update calls to member\n\tfunctions.",
    "tree": {
      "sha": "2e2220e236d5e9456d57fea71f01fac60878a77d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2e2220e236d5e9456d57fea71f01fac60878a77d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/46157d77c324ab6adf52ddf994a6ccb3328b3edb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/46157d77c324ab6adf52ddf994a6ccb3328b3edb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/46157d77c324ab6adf52ddf994a6ccb3328b3edb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/46157d77c324ab6adf52ddf994a6ccb3328b3edb/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "82fc57fd6b0aff85d86c47b5892f91c04fd58f0f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/82fc57fd6b0aff85d86c47b5892f91c04fd58f0f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/82fc57fd6b0aff85d86c47b5892f91c04fd58f0f"
    }
  ],
  "stats": {
    "total": 942,
    "additions": 506,
    "deletions": 436
  },
  "files": [
    {
      "sha": "57d8065bfe3ae041f44515d48778790f740bdd70",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 66,
      "deletions": 0,
      "changes": 66,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=46157d77c324ab6adf52ddf994a6ccb3328b3edb",
      "patch": "@@ -1,3 +1,69 @@\n+2020-12-23  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* p-exp.y (exp): Update call to pascal_is_string_type.\n+\t(pascal_parse): Rename to...\n+\t(pascal_language::parser): ...this.\n+\t* p-lang.c (is_pascal_string_type): Rename to...\n+\t(pascal_is_string_type): ...this.\n+\t(pascal_one_char): Rename to...\n+\t(pascal_language::print_one_char): ...this.\n+\t(pascal_printchar): Rename to...\n+\t(pascal_language::printchar): ...this.  Update call to\n+\tprint_one_char member function.\n+\t(pascal_op_print_tab): Rename to...\n+\t(pascal_language::op_print_tab): ...this.\n+\t(class pascal_language): Moved to p-lang.h.\n+\t(pascal_language::language_arch_info): Function implementation\n+\tmoved out of class declaration.\n+\t(pascal_language::printstr): Likewise.\n+\t* p-lang.h (pascal_parse): Delete declaration.\n+\t(pascal_is_string_type): Declare.\n+\t(pascal_print_type): Delete declaration.\n+\t(pascal_print_typedef): Delete declaration.\n+\t(pascal_value_print_inner): Delete declaration.\n+\t(pascal_value_print): Delete declaration.\n+\t(pascal_type_print_method_args): Delete declaration.\n+\t(is_pascal_string_type): Delete declaration.\n+\t(pascal_printchar): Delete declaration.\n+\t(pascal_builtin_types): Delete declaration.\n+\t(pascal_type_print_base): Delete declaration.\n+\t(pascal_type_print_varspec_prefix): Delete declaration.\n+\t(class pascal_language): Moved here from p-lang.c.\n+\t* p-typeprint.c (pascal_type_print_varspec_suffix): Delete\n+\tdeclaration.\n+\t(pascal_type_print_derivation_info): Delete declaration.\n+\t(pascal_print_type): Rename to...\n+\t(pascal_language::print_type): ...this.  Update calls to member\n+\tfunctions.\n+\t(pascal_print_typedef): Rename to...\n+\t(pascal_language::print_typedef): ...this.  Update calls to member\n+\tfunctions.\n+\t(pascal_type_print_derivation_info): Rename to...\n+\t(pascal_language::type_print_derivation_info): ...this.\n+\t(pascal_type_print_method_args): Rename to...\n+\t(pascal_language::type_print_method_args): ...this.\n+\t(pascal_type_print_varspec_prefix): Rename to...\n+\t(pascal_language::type_print_varspec_prefix): ...this.  Update\n+\tcalls to member functions.\n+\t(pascal_print_func_args): Rename to...\n+\t(pascal_language::print_func_args): ...this.  Update calls to\n+\tmember functions.\n+\t(pascal_type_print_func_varspec_suffix): Rename to...\n+\t(pascal_language::type_print_func_varspec_suffix): ...this.\n+\tUpdate calls to member functions.\n+\t(pascal_type_print_varspec_suffix): Rename to...\n+\t(pascal_language::type_print_varspec_suffix): ...this.  Update\n+\tcalls to member functions.\n+\t(pascal_type_print_base): Rename to...\n+\t(pascal_language::type_print_base): ...this.  Update calls to\n+\tmember functions.\n+\t* p-valprint.c (pascal_value_print_inner): Rename to...\n+\t(pascal_language::value_print_inner): ...this.  Update calls to\n+\tmember functions.\n+\t(pascal_value_print): Rename to...\n+\t(pascal_language::value_print): ...this.  Update calls to member\n+\tfunctions.\n+\n 2020-12-23  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* go-exp.y (go_parse): Rename to..."
    },
    {
      "sha": "469c284a33c901b83d156da85a262a76987161c7",
      "filename": "gdb/p-exp.y",
      "status": "modified",
      "additions": 6,
      "deletions": 5,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-exp.y?ref=46157d77c324ab6adf52ddf994a6ccb3328b3edb",
      "patch": "@@ -301,10 +301,9 @@ exp\t:\tfield_exp COMPLETE\n exp\t:\texp '['\n \t\t\t/* We need to save the current_type value.  */\n \t\t\t{ const char *arrayname;\n-\t\t\t  int arrayfieldindex;\n-\t\t\t  arrayfieldindex = is_pascal_string_type (\n-\t\t\t\tcurrent_type, NULL, NULL,\n-\t\t\t\tNULL, NULL, &arrayname);\n+\t\t\t  int arrayfieldindex\n+\t\t\t    = pascal_is_string_type (current_type, NULL, NULL,\n+\t\t\t\t\t\t     NULL, NULL, &arrayname);\n \t\t\t  if (arrayfieldindex)\n \t\t\t    {\n \t\t\t      struct stoken stringsval;\n@@ -1727,8 +1726,10 @@ yylex (void)\n   }\n }\n \n+/* See language.h.  */\n+\n int\n-pascal_parse (struct parser_state *par_state)\n+pascal_language::parser (struct parser_state *par_state) const\n {\n   /* Setting up the parser state.  */\n   scoped_restore pstate_restore = make_scoped_restore (&pstate);"
    },
    {
      "sha": "3e58cccc0065d5dccd737315c5b36ef2eb8a9f63",
      "filename": "gdb/p-lang.c",
      "status": "modified",
      "additions": 132,
      "deletions": 252,
      "changes": 384,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.c?ref=46157d77c324ab6adf52ddf994a6ccb3328b3edb",
      "patch": "@@ -84,20 +84,11 @@ pascal_main_name (void)\n   return NULL;\n }\n \n-/* Determines if type TYPE is a pascal string type.\n-   Returns a positive value if the type is a known pascal string type.\n-   This function is used by p-valprint.c code to allow better string display.\n-   If it is a pascal string type, then it also sets info needed\n-   to get the length and the data of the string\n-   length_pos, length_size and string_pos are given in bytes.\n-   char_size gives the element size in bytes.\n-   FIXME: if the position or the size of these fields\n-   are not multiple of TARGET_CHAR_BIT then the results are wrong\n-   but this does not happen for Free Pascal nor for GPC.  */\n+/* See p-lang.h.  */\n+\n int\n-is_pascal_string_type (struct type *type,int *length_pos,\n-\t\t       int *length_size, int *string_pos,\n-\t\t       struct type **char_type,\n+pascal_is_string_type (struct type *type,int *length_pos, int *length_size,\n+\t\t       int *string_pos, struct type **char_type,\n \t\t       const char **arrayname)\n {\n   if (type != NULL && type->code () == TYPE_CODE_STRUCT)\n@@ -152,14 +143,11 @@ is_pascal_string_type (struct type *type,int *length_pos,\n   return 0;\n }\n \n-static void pascal_one_char (int, struct ui_file *, int *);\n-\n-/* Print the character C on STREAM as part of the contents of a literal\n-   string.\n-   In_quotes is reset to 0 if a char is written with #4 notation.  */\n+/* See p-lang.h.  */\n \n-static void\n-pascal_one_char (int c, struct ui_file *stream, int *in_quotes)\n+void\n+pascal_language::print_one_char (int c, struct ui_file *stream,\n+\t\t\t\t int *in_quotes) const\n {\n   if (c == '\\'' || ((unsigned int) c <= 0xff && (PRINT_LITERAL_FORM (c))))\n     {\n@@ -182,12 +170,15 @@ pascal_one_char (int c, struct ui_file *stream, int *in_quotes)\n     }\n }\n \n+/* See language.h.  */\n+\n void\n-pascal_printchar (int c, struct type *type, struct ui_file *stream)\n+pascal_language::printchar (int c, struct type *type,\n+\t\t\t    struct ui_file *stream) const\n {\n   int in_quotes = 0;\n \n-  pascal_one_char (c, stream, &in_quotes);\n+  print_one_char (c, stream, &in_quotes);\n   if (in_quotes)\n     fputs_filtered (\"'\", stream);\n }\n@@ -197,7 +188,7 @@ pascal_printchar (int c, struct type *type, struct ui_file *stream)\n /* Table mapping opcodes into strings for printing operators\n    and precedences of the operators.  */\n \n-const struct op_print pascal_op_print_tab[] =\n+const struct op_print pascal_language::op_print_tab[] =\n {\n   {\",\", BINOP_COMMA, PREC_COMMA, 0},\n   {\":=\", BINOP_ASSIGN, PREC_ASSIGN, 1},\n@@ -228,249 +219,138 @@ const struct op_print pascal_op_print_tab[] =\n };\n \f\n \n-/* Class representing the Pascal language.  */\n+/* See language.h.  */\n \n-class pascal_language : public language_defn\n+void pascal_language::language_arch_info\n+\t(struct gdbarch *gdbarch, struct language_arch_info *lai) const\n {\n-public:\n-  pascal_language ()\n-    : language_defn (language_pascal)\n-  { /* Nothing.  */ }\n-\n-  /* See language.h.  */\n-\n-  const char *name () const override\n-  { return \"pascal\"; }\n-\n-  /* See language.h.  */\n-\n-  const char *natural_name () const override\n-  { return \"Pascal\"; }\n-\n-  /* See language.h.  */\n-\n-  const std::vector<const char *> &filename_extensions () const override\n-  {\n-    static const std::vector<const char *> extensions\n-      = { \".pas\", \".p\", \".pp\" };\n-    return extensions;\n-  }\n-\n-  /* See language.h.  */\n-  void language_arch_info (struct gdbarch *gdbarch,\n-\t\t\t   struct language_arch_info *lai) const override\n-  {\n-    const struct builtin_type *builtin = builtin_type (gdbarch);\n-\n-    /* Helper function to allow shorter lines below.  */\n-    auto add  = [&] (struct type * t)\n-    {\n-      lai->add_primitive_type (t);\n-    };\n-\n-    add (builtin->builtin_int);\n-    add (builtin->builtin_long);\n-    add (builtin->builtin_short);\n-    add (builtin->builtin_char);\n-    add (builtin->builtin_float);\n-    add (builtin->builtin_double);\n-    add (builtin->builtin_void);\n-    add (builtin->builtin_long_long);\n-    add (builtin->builtin_signed_char);\n-    add (builtin->builtin_unsigned_char);\n-    add (builtin->builtin_unsigned_short);\n-    add (builtin->builtin_unsigned_int);\n-    add (builtin->builtin_unsigned_long);\n-    add (builtin->builtin_unsigned_long_long);\n-    add (builtin->builtin_long_double);\n-    add (builtin->builtin_complex);\n-    add (builtin->builtin_double_complex);\n-\n-    lai->set_string_char_type (builtin->builtin_char);\n-    lai->set_bool_type (builtin->builtin_bool, \"boolean\");\n-  }\n-\n-  /* See language.h.  */\n-\n-  void print_type (struct type *type, const char *varstring,\n-\t\t   struct ui_file *stream, int show, int level,\n-\t\t   const struct type_print_options *flags) const override\n-  {\n-    pascal_print_type (type, varstring, stream, show, level, flags);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void value_print (struct value *val, struct ui_file *stream,\n-\t\t    const struct value_print_options *options) const override\n-  {\n-    return pascal_value_print (val, stream, options);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void value_print_inner\n-\t(struct value *val, struct ui_file *stream, int recurse,\n-\t const struct value_print_options *options) const override\n-  {\n-    return pascal_value_print_inner (val, stream, recurse, options);\n-  }\n-\n-  /* See language.h.  */\n-\n-  int parser (struct parser_state *ps) const override\n-  {\n-    return pascal_parse (ps);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void emitchar (int ch, struct type *chtype,\n-\t\t struct ui_file *stream, int quoter) const override\n-  {\n-    int in_quotes = 0;\n-\n-    pascal_one_char (ch, stream, &in_quotes);\n-    if (in_quotes)\n-      fputs_filtered (\"'\", stream);\n-  }\n-\n-  /* See language.h.  */\n+  const struct builtin_type *builtin = builtin_type (gdbarch);\n \n-  void printchar (int ch, struct type *chtype,\n-\t\t  struct ui_file *stream) const override\n+  /* Helper function to allow shorter lines below.  */\n+  auto add  = [&] (struct type * t)\n   {\n-    pascal_printchar (ch, chtype, stream);\n-  }\n+    lai->add_primitive_type (t);\n+  };\n+\n+  add (builtin->builtin_int);\n+  add (builtin->builtin_long);\n+  add (builtin->builtin_short);\n+  add (builtin->builtin_char);\n+  add (builtin->builtin_float);\n+  add (builtin->builtin_double);\n+  add (builtin->builtin_void);\n+  add (builtin->builtin_long_long);\n+  add (builtin->builtin_signed_char);\n+  add (builtin->builtin_unsigned_char);\n+  add (builtin->builtin_unsigned_short);\n+  add (builtin->builtin_unsigned_int);\n+  add (builtin->builtin_unsigned_long);\n+  add (builtin->builtin_unsigned_long_long);\n+  add (builtin->builtin_long_double);\n+  add (builtin->builtin_complex);\n+  add (builtin->builtin_double_complex);\n+\n+  lai->set_string_char_type (builtin->builtin_char);\n+  lai->set_bool_type (builtin->builtin_bool, \"boolean\");\n+}\n \n-  /* See language.h.  */\n+/* See language.h.  */\n \n-  void printstr (struct ui_file *stream, struct type *elttype,\n-\t\t const gdb_byte *string, unsigned int length,\n-\t\t const char *encoding, int force_ellipses,\n-\t\t const struct value_print_options *options) const override\n-  {\n-    enum bfd_endian byte_order = type_byte_order (elttype);\n-    unsigned int i;\n-    unsigned int things_printed = 0;\n-    int in_quotes = 0;\n-    int need_comma = 0;\n-    int width;\n-\n-    /* Preserve ELTTYPE's original type, just set its LENGTH.  */\n-    check_typedef (elttype);\n-    width = TYPE_LENGTH (elttype);\n-\n-    /* If the string was not truncated due to `set print elements', and\n-       the last byte of it is a null, we don't print that, in traditional C\n-       style.  */\n-    if ((!force_ellipses) && length > 0\n-\t&& extract_unsigned_integer (string + (length - 1) * width, width,\n-\t\t\t\t     byte_order) == 0)\n-      length--;\n-\n-    if (length == 0)\n-      {\n-\tfputs_filtered (\"''\", stream);\n-\treturn;\n-      }\n-\n-    for (i = 0; i < length && things_printed < options->print_max; ++i)\n-      {\n-\t/* Position of the character we are examining\n-\t   to see whether it is repeated.  */\n-\tunsigned int rep1;\n-\t/* Number of repetitions we have detected so far.  */\n-\tunsigned int reps;\n-\tunsigned long int current_char;\n-\n-\tQUIT;\n-\n-\tif (need_comma)\n-\t  {\n-\t    fputs_filtered (\", \", stream);\n-\t    need_comma = 0;\n-\t  }\n-\n-\tcurrent_char = extract_unsigned_integer (string + i * width, width,\n-\t\t\t\t\t\t byte_order);\n-\n-\trep1 = i + 1;\n-\treps = 1;\n-\twhile (rep1 < length\n-\t       && extract_unsigned_integer (string + rep1 * width, width,\n-\t\t\t\t\t    byte_order) == current_char)\n-\t  {\n-\t    ++rep1;\n-\t    ++reps;\n-\t  }\n-\n-\tif (reps > options->repeat_count_threshold)\n-\t  {\n-\t    if (in_quotes)\n-\t      {\n-\t\tfputs_filtered (\"', \", stream);\n-\t\tin_quotes = 0;\n-\t      }\n-\t    pascal_printchar (current_char, elttype, stream);\n-\t    fprintf_filtered (stream, \" %p[<repeats %u times>%p]\",\n-\t\t\t      metadata_style.style ().ptr (),\n-\t\t\t      reps, nullptr);\n-\t    i = rep1 - 1;\n-\t    things_printed += options->repeat_count_threshold;\n-\t    need_comma = 1;\n-\t  }\n-\telse\n-\t  {\n-\t    if ((!in_quotes) && (PRINT_LITERAL_FORM (current_char)))\n-\t      {\n-\t\tfputs_filtered (\"'\", stream);\n-\t\tin_quotes = 1;\n-\t      }\n-\t    pascal_one_char (current_char, stream, &in_quotes);\n-\t    ++things_printed;\n-\t  }\n-      }\n-\n-    /* Terminate the quotes if necessary.  */\n-    if (in_quotes)\n-      fputs_filtered (\"'\", stream);\n-\n-    if (force_ellipses || i < length)\n-      fputs_filtered (\"...\", stream);\n-  }\n-\n-  /* See language.h.  */\n-\n-  void print_typedef (struct type *type, struct symbol *new_symbol,\n-\t\t      struct ui_file *stream) const override\n-  {\n-    pascal_print_typedef (type, new_symbol, stream);\n-  }\n+void\n+pascal_language::printstr (struct ui_file *stream, struct type *elttype,\n+\t\t\t   const gdb_byte *string, unsigned int length,\n+\t\t\t   const char *encoding, int force_ellipses,\n+\t\t\t   const struct value_print_options *options) const\n+{\n+  enum bfd_endian byte_order = type_byte_order (elttype);\n+  unsigned int i;\n+  unsigned int things_printed = 0;\n+  int in_quotes = 0;\n+  int need_comma = 0;\n+  int width;\n+\n+  /* Preserve ELTTYPE's original type, just set its LENGTH.  */\n+  check_typedef (elttype);\n+  width = TYPE_LENGTH (elttype);\n+\n+  /* If the string was not truncated due to `set print elements', and\n+     the last byte of it is a null, we don't print that, in traditional C\n+     style.  */\n+  if ((!force_ellipses) && length > 0\n+      && extract_unsigned_integer (string + (length - 1) * width, width,\n+\t\t\t\t   byte_order) == 0)\n+    length--;\n+\n+  if (length == 0)\n+    {\n+      fputs_filtered (\"''\", stream);\n+      return;\n+    }\n \n-  /* See language.h.  */\n+  for (i = 0; i < length && things_printed < options->print_max; ++i)\n+    {\n+      /* Position of the character we are examining\n+\t to see whether it is repeated.  */\n+      unsigned int rep1;\n+      /* Number of repetitions we have detected so far.  */\n+      unsigned int reps;\n+      unsigned long int current_char;\n \n-  bool is_string_type_p (struct type *type) const override\n-  {\n-    return is_pascal_string_type (type, nullptr, nullptr, nullptr,\n-\t\t\t\t  nullptr, nullptr) > 0;\n-  }\n+      QUIT;\n \n-  /* See language.h.  */\n+      if (need_comma)\n+\t{\n+\t  fputs_filtered (\", \", stream);\n+\t  need_comma = 0;\n+\t}\n \n-  const char *name_of_this () const override\n-  { return \"this\"; }\n+      current_char = extract_unsigned_integer (string + i * width, width,\n+\t\t\t\t\t       byte_order);\n \n-  /* See language.h.  */\n+      rep1 = i + 1;\n+      reps = 1;\n+      while (rep1 < length\n+\t     && extract_unsigned_integer (string + rep1 * width, width,\n+\t\t\t\t\t  byte_order) == current_char)\n+\t{\n+\t  ++rep1;\n+\t  ++reps;\n+\t}\n \n-  bool range_checking_on_by_default () const override\n-  { return true; }\n+      if (reps > options->repeat_count_threshold)\n+\t{\n+\t  if (in_quotes)\n+\t    {\n+\t      fputs_filtered (\"', \", stream);\n+\t      in_quotes = 0;\n+\t    }\n+\t  printchar (current_char, elttype, stream);\n+\t  fprintf_filtered (stream, \" %p[<repeats %u times>%p]\",\n+\t\t\t    metadata_style.style ().ptr (),\n+\t\t\t    reps, nullptr);\n+\t  i = rep1 - 1;\n+\t  things_printed += options->repeat_count_threshold;\n+\t  need_comma = 1;\n+\t}\n+      else\n+\t{\n+\t  if ((!in_quotes) && (PRINT_LITERAL_FORM (current_char)))\n+\t    {\n+\t      fputs_filtered (\"'\", stream);\n+\t      in_quotes = 1;\n+\t    }\n+\t  print_one_char (current_char, stream, &in_quotes);\n+\t  ++things_printed;\n+\t}\n+    }\n \n-  /* See language.h.  */\n+  /* Terminate the quotes if necessary.  */\n+  if (in_quotes)\n+    fputs_filtered (\"'\", stream);\n \n-  const struct op_print *opcode_print_table () const override\n-  { return pascal_op_print_tab; }\n-};\n+  if (force_ellipses || i < length)\n+    fputs_filtered (\"...\", stream);\n+}\n \n /* Single instance of the Pascal language class.  */\n "
    },
    {
      "sha": "3f08a26d2b30df0e6ded3c1584581132ab223701",
      "filename": "gdb/p-lang.h",
      "status": "modified",
      "additions": 217,
      "deletions": 28,
      "changes": 245,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-lang.h?ref=46157d77c324ab6adf52ddf994a6ccb3328b3edb",
      "patch": "@@ -25,51 +25,240 @@\n struct value;\n struct parser_state;\n \n+/* Determines if type TYPE is a pascal string type.  Returns a positive\n+   value if the type is a known pascal string type.  This function is used\n+   by p-valprint.c code to allow better string display.  If it is a pascal\n+   string type, then it also sets info needed to get the length and the\n+   data of the string length_pos, length_size and string_pos are given in\n+   bytes.  char_size gives the element size in bytes.  FIXME: if the\n+   position or the size of these fields are not multiple of TARGET_CHAR_BIT\n+   then the results are wrong but this does not happen for Free Pascal nor\n+   for GPC.  */\n+\n+extern int pascal_is_string_type (struct type *type,int *length_pos,\n+\t\t\t\t  int *length_size, int *string_pos,\n+\t\t\t\t  struct type **char_type,\n+\t\t\t\t  const char **arrayname);\n+\n /* Defined in p-lang.c */\n+\n extern const char *pascal_main_name (void);\n \n-extern int pascal_parse (struct parser_state *); /* Defined in p-exp.y */\n+/* These are in p-lang.c: */\n \n-/* Defined in p-typeprint.c */\n-extern void pascal_print_type (struct type *, const char *, struct ui_file *,\n-\t\t\t       int, int, const struct type_print_options *);\n+extern int is_pascal_string_type (struct type *, int *, int *, int *,\n+\t\t\t\t  struct type **, const char **);\n \n-extern void pascal_print_typedef (struct type *, struct symbol *,\n-\t\t\t\t  struct ui_file *);\n+extern int pascal_object_is_vtbl_ptr_type (struct type *);\n \n-/* Implement la_value_print_inner for Pascal.  */\n+extern int pascal_object_is_vtbl_member (struct type *);\n \n-extern void pascal_value_print_inner (struct value *, struct ui_file *, int,\n-\t\t\t\t      const struct value_print_options *);\n+/* Class representing the Pascal language.  */\n \n-extern void pascal_value_print (struct value *, struct ui_file *,\n-\t\t\t\tconst struct value_print_options *);\n+class pascal_language : public language_defn\n+{\n+public:\n+  pascal_language ()\n+    : language_defn (language_pascal)\n+  { /* Nothing.  */ }\n \n-extern void pascal_type_print_method_args (const char *, const char *,\n-\t\t\t\t\t   struct ui_file *);\n+  /* See language.h.  */\n \n-/* These are in p-lang.c: */\n+  const char *name () const override\n+  { return \"pascal\"; }\n \n-extern int\n-  is_pascal_string_type (struct type *, int *, int *, int *,\n-\t\t\t struct type **, const char **);\n+  /* See language.h.  */\n \n-extern void pascal_printchar (int, struct type *, struct ui_file *);\n+  const char *natural_name () const override\n+  { return \"Pascal\"; }\n \n-extern struct type **const pascal_builtin_types[];\n+  /* See language.h.  */\n \n-/* These are in p-typeprint.c: */\n+  const std::vector<const char *> &filename_extensions () const override\n+  {\n+    static const std::vector<const char *> extensions\n+      = { \".pas\", \".p\", \".pp\" };\n+    return extensions;\n+  }\n \n-extern void\n-  pascal_type_print_base (struct type *, struct ui_file *, int, int,\n-\t\t\t  const struct type_print_options *);\n+  /* See language.h.  */\n \n-extern void\n-  pascal_type_print_varspec_prefix (struct type *, struct ui_file *, int, int,\n-\t\t\t\t    const struct type_print_options *);\n+  void language_arch_info (struct gdbarch *gdbarch,\n+\t\t\t   struct language_arch_info *lai) const override;\n \n-extern int pascal_object_is_vtbl_ptr_type (struct type *);\n+  /* See language.h.  */\n \n-extern int pascal_object_is_vtbl_member (struct type *);\n+  void print_type (struct type *type, const char *varstring,\n+\t\t   struct ui_file *stream, int show, int level,\n+\t\t   const struct type_print_options *flags) const override;\n+\n+  /* See language.h.  */\n+\n+  void value_print (struct value *val, struct ui_file *stream,\n+\t\t    const struct value_print_options *options) const override;\n+\n+  /* See language.h.  */\n+\n+  void value_print_inner\n+\t(struct value *val, struct ui_file *stream, int recurse,\n+\t const struct value_print_options *options) const override;\n+\n+  /* See language.h.  */\n+\n+  int parser (struct parser_state *ps) const override;\n+\n+  /* See language.h.  */\n+\n+  void emitchar (int ch, struct type *chtype,\n+\t\t struct ui_file *stream, int quoter) const override\n+  {\n+    int in_quotes = 0;\n+\n+    print_one_char (ch, stream, &in_quotes);\n+    if (in_quotes)\n+      fputs_filtered (\"'\", stream);\n+  }\n+\n+  /* See language.h.  */\n+\n+  void printchar (int ch, struct type *chtype,\n+\t\t  struct ui_file *stream) const override;\n+\n+  /* See language.h.  */\n+\n+  void printstr (struct ui_file *stream, struct type *elttype,\n+\t\t const gdb_byte *string, unsigned int length,\n+\t\t const char *encoding, int force_ellipses,\n+\t\t const struct value_print_options *options) const override;\n+\n+  /* See language.h.  */\n+\n+  void print_typedef (struct type *type, struct symbol *new_symbol,\n+\t\t      struct ui_file *stream) const override;\n+\n+  /* See language.h.  */\n+\n+  bool is_string_type_p (struct type *type) const override\n+  {\n+    return pascal_is_string_type(type, nullptr, nullptr, nullptr,\n+\t\t\t\t nullptr, nullptr) > 0;\n+  }\n+\n+  /* See language.h.  */\n+\n+  const char *name_of_this () const override\n+  { return \"this\"; }\n+\n+  /* See language.h.  */\n+\n+  bool range_checking_on_by_default () const override\n+  { return true; }\n+\n+  /* See language.h.  */\n+\n+  const struct op_print *opcode_print_table () const override\n+  { return op_print_tab; }\n+\n+private:\n+\n+  /* Table of opcode data for use by OPCODE_PRINT_TABLE member function.  */\n+\n+  static const struct op_print op_print_tab[];\n+\n+  /* Print the character C on STREAM as part of the contents of a literal\n+     string.  IN_QUOTES is reset to 0 if a char is written with #4 notation.  */\n+\n+  void print_one_char (int c, struct ui_file *stream, int *in_quotes) const;\n+\n+  /* Print the name of the type (or the ultimate pointer target,\n+     function value or array element), or the description of a\n+     structure or union.\n+\n+     SHOW positive means print details about the type (e.g. enum values),\n+     and print structure elements passing SHOW - 1 for show.  SHOW negative\n+     means just print the type name or struct tag if there is one.  If\n+     there is no name, print something sensible but concise like \"struct\n+     {...}\".\n+     SHOW zero means just print the type name or struct tag if there is one.\n+     If there is no name, print something sensible but not as concise like\n+     \"struct {int x; int y;}\".\n+\n+     LEVEL is the number of spaces to indent by.\n+     We increase it for some recursive calls.  */\n+\n+  void type_print_base (struct type *type, struct ui_file *stream, int show,\n+\t\t\tint level,\n+\t\t\tconst struct type_print_options *flags) const;\n+\n+\n+  /* Print any array sizes, function arguments or close parentheses\n+     needed after the variable name (to describe its type).\n+     Args work like pascal_type_print_varspec_prefix.  */\n+\n+  void type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n+\t\t\t\t  int show, int passed_a_ptr,\n+\t\t\t\t  int demangled_args,\n+\t\t\t\t  const struct type_print_options *flags) const;\n+\n+  /* Helper for pascal_language::type_print_varspec_suffix to print the\n+     suffix of a function or method.  */\n+\n+  void type_print_func_varspec_suffix\n+\t(struct type *type, struct ui_file *stream, int show,\n+\t int passed_a_ptr, int demangled_args,\n+\t const struct type_print_options *flags) const;\n+\n+  /* Print any asterisks or open-parentheses needed before the\n+     variable name (to describe its type).\n+\n+     On outermost call, pass 0 for PASSED_A_PTR.\n+     On outermost call, SHOW > 0 means should ignore\n+     any typename for TYPE and show its details.\n+     SHOW is always zero on recursive calls.  */\n+\n+  void type_print_varspec_prefix\n+\t(struct type *type, struct ui_file *stream, int show,\n+\t int passed_a_ptr, const struct type_print_options *flags) const;\n+\n+  /* Print the function args from TYPE (a TYPE_CODE_FUNC) to STREAM taking\n+     FLAGS into account where appropriate.  */\n+\n+  void  print_func_args (struct type *type, struct ui_file *stream,\n+\t\t\t const struct type_print_options *flags) const;\n+\n+  /* Print the Pascal method arguments for PHYSNAME and METHODNAME to the\n+     file STREAM.  */\n+\n+  void type_print_method_args (const char *physname, const char *methodname,\n+\t\t\t       struct ui_file *stream) const;\n+\n+  /* If TYPE is a derived type, then print out derivation information.\n+     Print only the actual base classes of this type, not the base classes\n+     of the base classes.  I.e. for the derivation hierarchy:\n+\n+     class A { int a; };\n+     class B : public A {int b; };\n+     class C : public B {int c; };\n+\n+     Print the type of class C as:\n+\n+     class C : public B {\n+     int c;\n+     }\n+\n+     Not as the following (like gdb used to), which is not legal C++ syntax\n+     for derived types and may be confused with the multiple inheritance\n+     form:\n+\n+     class C : public B : public A {\n+     int c;\n+     }\n+\n+     In general, gdb should try to print the types as closely as possible\n+     to the form that they appear in the source code.  */\n+\n+  void type_print_derivation_info (struct ui_file *stream,\n+\t\t\t\t   struct type *type) const;\n+};\n \n #endif /* P_LANG_H */"
    },
    {
      "sha": "36c337c8f9a8203b970a44aafc95e3d8ddb22b69",
      "filename": "gdb/p-typeprint.c",
      "status": "modified",
      "additions": 75,
      "deletions": 139,
      "changes": 214,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-typeprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-typeprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-typeprint.c?ref=46157d77c324ab6adf52ddf994a6ccb3328b3edb",
      "patch": "@@ -34,21 +34,12 @@\n #include <ctype.h>\n #include \"cli/cli-style.h\"\n \n-static void pascal_type_print_varspec_suffix (struct type *, struct ui_file *,\n-\t\t\t\t\t      int, int, int,\n-\t\t\t\t\t      const struct type_print_options *);\n-\n-static void pascal_type_print_derivation_info (struct ui_file *,\n-\t\t\t\t\t       struct type *);\n-\n-\f\n-\n-/* LEVEL is the depth to indent lines by.  */\n+/* See language.h.  */\n \n void\n-pascal_print_type (struct type *type, const char *varstring,\n-\t\t   struct ui_file *stream, int show, int level,\n-\t\t   const struct type_print_options *flags)\n+pascal_language::print_type (struct type *type, const char *varstring,\n+\t\t\t     struct ui_file *stream, int show, int level,\n+\t\t\t     const struct type_print_options *flags) const\n {\n   enum type_code code;\n   int demangled_args;\n@@ -61,7 +52,7 @@ pascal_print_type (struct type *type, const char *varstring,\n   if ((code == TYPE_CODE_FUNC\n        || code == TYPE_CODE_METHOD))\n     {\n-      pascal_type_print_varspec_prefix (type, stream, show, 0, flags);\n+      type_print_varspec_prefix (type, stream, show, 0, flags);\n     }\n   /* first the name */\n   fputs_filtered (varstring, stream);\n@@ -76,26 +67,24 @@ pascal_print_type (struct type *type, const char *varstring,\n   if (!(code == TYPE_CODE_FUNC\n \t|| code == TYPE_CODE_METHOD))\n     {\n-      pascal_type_print_varspec_prefix (type, stream, show, 0, flags);\n+      type_print_varspec_prefix (type, stream, show, 0, flags);\n     }\n \n-  pascal_type_print_base (type, stream, show, level, flags);\n+  type_print_base (type, stream, show, level, flags);\n   /* For demangled function names, we have the arglist as part of the name,\n      so don't print an additional pair of ()'s.  */\n \n   demangled_args = varstring ? strchr (varstring, '(') != NULL : 0;\n-  pascal_type_print_varspec_suffix (type, stream, show, 0, demangled_args,\n+  type_print_varspec_suffix (type, stream, show, 0, demangled_args,\n \t\t\t\t    flags);\n \n }\n \n-/* Print a typedef using Pascal syntax.  TYPE is the underlying type.\n-   NEW_SYMBOL is the symbol naming the type.  STREAM is the stream on\n-   which to print.  */\n+/* See language.h.  */\n \n void\n-pascal_print_typedef (struct type *type, struct symbol *new_symbol,\n-\t\t      struct ui_file *stream)\n+pascal_language::print_typedef (struct type *type, struct symbol *new_symbol,\n+\t\t\t\tstruct ui_file *stream) const\n {\n   type = check_typedef (type);\n   fprintf_filtered (stream, \"type \");\n@@ -104,32 +93,11 @@ pascal_print_typedef (struct type *type, struct symbol *new_symbol,\n   fprintf_filtered (stream, \";\");\n }\n \n-/* If TYPE is a derived type, then print out derivation information.\n-   Print only the actual base classes of this type, not the base classes\n-   of the base classes.  I.e. for the derivation hierarchy:\n-\n-   class A { int a; };\n-   class B : public A {int b; };\n-   class C : public B {int c; };\n-\n-   Print the type of class C as:\n-\n-   class C : public B {\n-   int c;\n-   }\n-\n-   Not as the following (like gdb used to), which is not legal C++ syntax for\n-   derived types and may be confused with the multiple inheritance form:\n-\n-   class C : public B : public A {\n-   int c;\n-   }\n-\n-   In general, gdb should try to print the types as closely as possible to\n-   the form that they appear in the source code.  */\n+/* See p-lang.h.  */\n \n-static void\n-pascal_type_print_derivation_info (struct ui_file *stream, struct type *type)\n+void\n+pascal_language::type_print_derivation_info (struct ui_file *stream,\n+\t\t\t\t\t     struct type *type) const\n {\n   const char *name;\n   int i;\n@@ -149,11 +117,12 @@ pascal_type_print_derivation_info (struct ui_file *stream, struct type *type)\n     }\n }\n \n-/* Print the Pascal method arguments ARGS to the file STREAM.  */\n+/* See p-lang.h.  */\n \n void\n-pascal_type_print_method_args (const char *physname, const char *methodname,\n-\t\t\t       struct ui_file *stream)\n+pascal_language::type_print_method_args (const char *physname,\n+\t\t\t\t\t const char *methodname,\n+\t\t\t\t\t struct ui_file *stream) const\n {\n   int is_constructor = (startswith (physname, \"__ct__\"));\n   int is_destructor = (startswith (physname, \"__dt__\"));\n@@ -195,18 +164,13 @@ pascal_type_print_method_args (const char *physname, const char *methodname,\n     }\n }\n \n-/* Print any asterisks or open-parentheses needed before the\n-   variable name (to describe its type).\n-\n-   On outermost call, pass 0 for PASSED_A_PTR.\n-   On outermost call, SHOW > 0 means should ignore\n-   any typename for TYPE and show its details.\n-   SHOW is always zero on recursive calls.  */\n+/* See p-lang.h.  */\n \n void\n-pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n-\t\t\t\t  int show, int passed_a_ptr,\n-\t\t\t\t  const struct type_print_options *flags)\n+pascal_language::type_print_varspec_prefix (struct type *type,\n+\t\t\t\t\t    struct ui_file *stream,\n+\t\t\t\t\t    int show, int passed_a_ptr,\n+\t\t\t\t\t    const struct type_print_options *flags) const\n {\n   if (type == 0)\n     return;\n@@ -220,7 +184,7 @@ pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n     {\n     case TYPE_CODE_PTR:\n       fprintf_filtered (stream, \"^\");\n-      pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1,\n+      type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1,\n \t\t\t\t\tflags);\n       break;\t\t\t/* Pointer should be handled normally\n \t\t\t\t   in pascal.  */\n@@ -241,15 +205,15 @@ pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n       if (passed_a_ptr)\n \t{\n \t  fprintf_filtered (stream, \" \");\n-\t  pascal_type_print_base (TYPE_SELF_TYPE (type),\n+\t  type_print_base (TYPE_SELF_TYPE (type),\n \t\t\t\t  stream, 0, passed_a_ptr, flags);\n \t  fprintf_filtered (stream, \"::\");\n \t}\n       break;\n \n     case TYPE_CODE_REF:\n-      pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1,\n-\t\t\t\t\tflags);\n+      type_print_varspec_prefix (TYPE_TARGET_TYPE (type), stream, 0, 1,\n+\t\t\t\t flags);\n       fprintf_filtered (stream, \"&\");\n       break;\n \n@@ -301,14 +265,16 @@ pascal_type_print_varspec_prefix (struct type *type, struct ui_file *stream,\n \t gcc -Wall will reveal any types that haven't been handled.  */\n       break;\n     default:\n-      error (_(\"type not handled in pascal_type_print_varspec_prefix()\"));\n+      gdb_assert_not_reached (\"unexpected type\");\n       break;\n     }\n }\n \n-static void\n-pascal_print_func_args (struct type *type, struct ui_file *stream,\n-\t\t\tconst struct type_print_options *flags)\n+/* See p-lang.h.  */\n+\n+void\n+pascal_language::print_func_args (struct type *type, struct ui_file *stream,\n+\t\t\t\t  const struct type_print_options *flags) const\n {\n   int i, len = type->num_fields ();\n \n@@ -324,12 +290,12 @@ pascal_print_func_args (struct type *type, struct ui_file *stream,\n \t  wrap_here (\"    \");\n \t}\n       /*  Can we find if it is a var parameter ??\n-\t if ( TYPE_FIELD(type, i) == )\n-\t {\n-\t fprintf_filtered (stream, \"var \");\n-\t } */\n-      pascal_print_type (type->field (i).type (), \"\"\t/* TYPE_FIELD_NAME\n-\t\t\t\t\t\t\t   seems invalid!  */\n+\t  if ( TYPE_FIELD(type, i) == )\n+\t  {\n+\t    fprintf_filtered (stream, \"var \");\n+\t  } */\n+      print_type (type->field (i).type (), \"\"\t/* TYPE_FIELD_NAME\n+\t\t\t\t\t\t   seems invalid!  */\n \t\t\t ,stream, -1, 0, flags);\n     }\n   if (len)\n@@ -338,42 +304,41 @@ pascal_print_func_args (struct type *type, struct ui_file *stream,\n     }\n }\n \n-/* Helper for pascal_type_print_varspec_suffix to print the suffix of\n-   a function or method.  */\n+/* See p-lang.h.  */\n \n-static void\n-pascal_type_print_func_varspec_suffix  (struct type *type, struct ui_file *stream,\n-\t\t\t\t\tint show, int passed_a_ptr,\n-\t\t\t\t\tint demangled_args,\n-\t\t\t\t\tconst struct type_print_options *flags)\n+void\n+pascal_language::type_print_func_varspec_suffix  (struct type *type,\n+\t\t\t\t\t\t  struct ui_file *stream,\n+\t\t\t\t\t\t  int show, int passed_a_ptr,\n+\t\t\t\t\t\t  int demangled_args,\n+\t\t\t\t\t\t  const struct type_print_options *flags) const\n {\n   if (TYPE_TARGET_TYPE (type) == NULL\n       || TYPE_TARGET_TYPE (type)->code () != TYPE_CODE_VOID)\n     {\n       fprintf_filtered (stream, \" : \");\n-      pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),\n+      type_print_varspec_prefix (TYPE_TARGET_TYPE (type),\n \t\t\t\t\tstream, 0, 0, flags);\n \n       if (TYPE_TARGET_TYPE (type) == NULL)\n \ttype_print_unknown_return_type (stream);\n       else\n-\tpascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, 0,\n+\ttype_print_base (TYPE_TARGET_TYPE (type), stream, show, 0,\n \t\t\t\tflags);\n \n-      pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0,\n-\t\t\t\t\tpassed_a_ptr, 0, flags);\n+      type_print_varspec_suffix (TYPE_TARGET_TYPE (type), stream, 0,\n+\t\t\t\t passed_a_ptr, 0, flags);\n     }\n }\n \n-/* Print any array sizes, function arguments or close parentheses\n-   needed after the variable name (to describe its type).\n-   Args work like pascal_type_print_varspec_prefix.  */\n+/* See p-lang.h.  */\n \n-static void\n-pascal_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n-\t\t\t\t  int show, int passed_a_ptr,\n-\t\t\t\t  int demangled_args,\n-\t\t\t\t  const struct type_print_options *flags)\n+void\n+pascal_language::type_print_varspec_suffix (struct type *type,\n+\t\t\t\t\t    struct ui_file *stream,\n+\t\t\t\t\t    int show, int passed_a_ptr,\n+\t\t\t\t\t    int demangled_args,\n+\t\t\t\t\t    const struct type_print_options *flags) const\n {\n   if (type == 0)\n     return;\n@@ -393,25 +358,23 @@ pascal_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n     case TYPE_CODE_METHOD:\n       if (passed_a_ptr)\n \tfprintf_filtered (stream, \")\");\n-      pascal_type_print_method_args (\"\",\n-\t\t\t\t     \"\",\n-\t\t\t\t     stream);\n-      pascal_type_print_func_varspec_suffix (type, stream, show,\n+      type_print_method_args (\"\", \"\", stream);\n+      type_print_func_varspec_suffix (type, stream, show,\n \t\t\t\t\t     passed_a_ptr, 0, flags);\n       break;\n \n     case TYPE_CODE_PTR:\n     case TYPE_CODE_REF:\n-      pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type),\n-\t\t\t\t\tstream, 0, 1, 0, flags);\n+      type_print_varspec_suffix (TYPE_TARGET_TYPE (type),\n+\t\t\t\t stream, 0, 1, 0, flags);\n       break;\n \n     case TYPE_CODE_FUNC:\n       if (passed_a_ptr)\n \tfprintf_filtered (stream, \")\");\n       if (!demangled_args)\n-\tpascal_print_func_args (type, stream, flags);\n-      pascal_type_print_func_varspec_suffix (type, stream, show,\n+\tprint_func_args (type, stream, flags);\n+      type_print_func_varspec_suffix (type, stream, show,\n \t\t\t\t\t     passed_a_ptr, 0, flags);\n       break;\n \n@@ -435,30 +398,16 @@ pascal_type_print_varspec_suffix (struct type *type, struct ui_file *stream,\n \t gcc -Wall will report types that may not have been considered.  */\n       break;\n     default:\n-      error (_(\"type not handled in pascal_type_print_varspec_suffix()\"));\n+      gdb_assert_not_reached (\"unexpected type\");\n       break;\n     }\n }\n \n-/* Print the name of the type (or the ultimate pointer target,\n-   function value or array element), or the description of a\n-   structure or union.\n-\n-   SHOW positive means print details about the type (e.g. enum values),\n-   and print structure elements passing SHOW - 1 for show.\n-   SHOW negative means just print the type name or struct tag if there is one.\n-   If there is no name, print something sensible but concise like\n-   \"struct {...}\".\n-   SHOW zero means just print the type name or struct tag if there is one.\n-   If there is no name, print something sensible but not as concise like\n-   \"struct {int x; int y;}\".\n-\n-   LEVEL is the number of spaces to indent by.\n-   We increase it for some recursive calls.  */\n+/* See p-lang.h.  */\n \n void\n-pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n-\t\t\tint level, const struct type_print_options *flags)\n+pascal_language::type_print_base (struct type *type, struct ui_file *stream, int show,\n+\t\t\t\t  int level, const struct type_print_options *flags) const\n {\n   int i;\n   int len;\n@@ -502,27 +451,16 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n     case TYPE_CODE_TYPEDEF:\n     case TYPE_CODE_PTR:\n     case TYPE_CODE_REF:\n-      /* case TYPE_CODE_FUNC:\n-\t case TYPE_CODE_METHOD: */\n-      pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level,\n-\t\t\t      flags);\n+      type_print_base (TYPE_TARGET_TYPE (type), stream, show, level,\n+\t\t       flags);\n       break;\n \n     case TYPE_CODE_ARRAY:\n-      /* pascal_type_print_varspec_prefix (TYPE_TARGET_TYPE (type),\n-\t\t\t\t\t   stream, 0, 0);\n-\t pascal_type_print_base (TYPE_TARGET_TYPE (type),\n-\t\t\t\t stream, show, level);\n-\t pascal_type_print_varspec_suffix (TYPE_TARGET_TYPE (type),\n-\t\t\t\t\t   stream, 0, 0, 0); */\n-      pascal_print_type (TYPE_TARGET_TYPE (type), NULL, stream, 0, 0, flags);\n+      print_type (TYPE_TARGET_TYPE (type), NULL, stream, 0, 0, flags);\n       break;\n \n     case TYPE_CODE_FUNC:\n     case TYPE_CODE_METHOD:\n-      /*\n-\t pascal_type_print_base (TYPE_TARGET_TYPE (type), stream, show, level);\n-\t only after args !!  */\n       break;\n     case TYPE_CODE_STRUCT:\n       if (type->name () != NULL)\n@@ -558,7 +496,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t}\n       else if (show > 0 || type->name () == NULL)\n \t{\n-\t  pascal_type_print_derivation_info (stream, type);\n+\t  type_print_derivation_info (stream, type);\n \n \t  fprintf_filtered (stream, \"\\n\");\n \t  if ((type->num_fields () == 0) && (TYPE_NFN_FIELDS (type) == 0))\n@@ -626,7 +564,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t      print_spaces_filtered (level + 4, stream);\n \t      if (field_is_static (&type->field (i)))\n \t\tfprintf_filtered (stream, \"static \");\n-\t      pascal_print_type (type->field (i).type (),\n+\t      print_type (type->field (i).type (),\n \t\t\t\t TYPE_FIELD_NAME (type, i),\n \t\t\t\t stream, show - 1, level + 4, flags);\n \t      if (!field_is_static (&type->field (i))\n@@ -725,9 +663,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \t\t    }\n \t\t  /* This does not work, no idea why !!  */\n \n-\t\t  pascal_type_print_method_args (physname,\n-\t\t\t\t\t\t method_name,\n-\t\t\t\t\t\t stream);\n+\t\t  type_print_method_args (physname, method_name, stream);\n \n \t\t  if (TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE (f, j)) != 0\n \t\t      && TYPE_TARGET_TYPE (TYPE_FN_FIELD_TYPE(f, j))->code () != TYPE_CODE_VOID)\n@@ -813,7 +749,7 @@ pascal_type_print_base (struct type *type, struct ui_file *stream, int show,\n \n     case TYPE_CODE_SET:\n       fputs_filtered (\"set of \", stream);\n-      pascal_print_type (type->index_type (), \"\", stream,\n+      print_type (type->index_type (), \"\", stream,\n \t\t\t show - 1, level, flags);\n       break;\n "
    },
    {
      "sha": "b748c066fb0990d82a1c80d94589674b57142d12",
      "filename": "gdb/p-valprint.c",
      "status": "modified",
      "additions": 10,
      "deletions": 12,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/46157d77c324ab6adf52ddf994a6ccb3328b3edb/gdb/p-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/p-valprint.c?ref=46157d77c324ab6adf52ddf994a6ccb3328b3edb",
      "patch": "@@ -64,9 +64,9 @@ static const struct generic_val_print_decorations p_decorations =\n /* See p-lang.h.  */\n \n void\n-pascal_value_print_inner (struct value *val, struct ui_file *stream,\n-\t\t\t  int recurse,\n-\t\t\t  const struct value_print_options *options)\n+pascal_language::value_print_inner (struct value *val,\n+\t\t\t\t    struct ui_file *stream, int recurse,\n+\t\t\t\t    const struct value_print_options *options) const\n \n {\n   struct type *type = check_typedef (value_type (val));\n@@ -200,8 +200,8 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n \t as GDB does not recognize stabs pascal strings\n \t Pascal strings are mapped to records\n \t with lowercase names PM.  */\n-      if (is_pascal_string_type (elttype, &length_pos, &length_size,\n-\t\t\t\t &string_pos, &char_type, NULL)\n+      if (pascal_is_string_type (elttype, &length_pos, &length_size,\n+\t\t\t\t &string_pos, &char_type, NULL) > 0\n \t  && addr != 0)\n \t{\n \t  ULONGEST string_length;\n@@ -313,8 +313,8 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n \t}\n       else\n \t{\n-\t  if (is_pascal_string_type (type, &length_pos, &length_size,\n-\t\t\t\t     &string_pos, &char_type, NULL))\n+          if (pascal_is_string_type (type, &length_pos, &length_size,\n+\t\t\t\t     &string_pos, &char_type, NULL) > 0)\n \t    {\n \t      len = extract_unsigned_integer (valaddr + length_pos,\n \t\t\t\t\t      length_size, byte_order);\n@@ -402,8 +402,8 @@ pascal_value_print_inner (struct value *val, struct ui_file *stream,\n \n \f\n void\n-pascal_value_print (struct value *val, struct ui_file *stream,\n-\t\t    const struct value_print_options *options)\n+pascal_language::value_print (struct value *val, struct ui_file *stream,\n+\t\t\t      const struct value_print_options *options) const\n {\n   struct type *type = value_type (val);\n   struct value_print_options opts = *options;\n@@ -499,9 +499,7 @@ pascal_object_is_vtbl_member (struct type *type)\n   return 0;\n }\n \n-/* Mutually recursive subroutines of pascal_object_print_value and\n-   pascal_value_print to print out a structure's fields:\n-   pascal_object_print_value_fields and pascal_object_print_value.\n+/* Helper function for print pascal objects.\n \n    VAL, STREAM, RECURSE, and OPTIONS have the same meanings as in\n    pascal_object_print_value and c_value_print."
    }
  ]
}