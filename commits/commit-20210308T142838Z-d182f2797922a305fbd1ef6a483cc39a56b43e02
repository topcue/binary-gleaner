{
  "sha": "d182f2797922a305fbd1ef6a483cc39a56b43e02",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDE4MmYyNzk3OTIyYTMwNWZiZDFlZjZhNDgzY2MzOWE1NmI0M2UwMg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:38Z"
    },
    "message": "Convert c-exp.y to use operations\n\nThis converts the C parser to generate operations rather than\nexp_elements.\n\nOne test needed a tweak in order to handle the different debugging\noutput.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* objc-lang.c (end_msglist): Create operations.\n\t* c-exp.y: Change parser to create operations.\n\t(write_destructor_name): Remove.\n\t(c_parse): Update.\n\ngdb/testsuite/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* gdb.base/debug-expr.exp: Update expected dump output.",
    "tree": {
      "sha": "7fb8bb5c51031d16dd169180accded548f17041b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7fb8bb5c51031d16dd169180accded548f17041b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d182f2797922a305fbd1ef6a483cc39a56b43e02",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d182f2797922a305fbd1ef6a483cc39a56b43e02",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d182f2797922a305fbd1ef6a483cc39a56b43e02",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d182f2797922a305fbd1ef6a483cc39a56b43e02/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c1299a23448227e9bb57df883aba0118618db9f4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c1299a23448227e9bb57df883aba0118618db9f4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c1299a23448227e9bb57df883aba0118618db9f4"
    }
  ],
  "stats": {
    "total": 681,
    "additions": 371,
    "deletions": 310
  },
  "files": [
    {
      "sha": "2e271e03628515836b8b589d27612855fe1692ad",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d182f2797922a305fbd1ef6a483cc39a56b43e02",
      "patch": "@@ -1,3 +1,10 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* objc-lang.c (end_msglist): Create operations.\n+\t* c-exp.y: Change parser to create operations.\n+\t(write_destructor_name): Remove.\n+\t(c_parse): Update.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* rust-exp.y: Create operations."
    },
    {
      "sha": "ad26a7cd2c5ce92a1b8243cdecaee3f69ff5e8b6",
      "filename": "gdb/c-exp.y",
      "status": "modified",
      "additions": 350,
      "deletions": 306,
      "changes": 656,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/c-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/c-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/c-exp.y?ref=d182f2797922a305fbd1ef6a483cc39a56b43e02",
      "patch": "@@ -55,6 +55,7 @@\n #include \"cp-abi.h\"\n #include \"type-stack.h\"\n #include \"target-float.h\"\n+#include \"c-exp.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n \n@@ -123,6 +124,7 @@ static void yyerror (const char *);\n \n static int type_aggregate_p (struct type *);\n \n+using namespace expr;\n %}\n \n /* Although the yacc \"value\" of an expression is not used,\n@@ -164,8 +166,6 @@ static int parse_number (struct parser_state *par_state,\n static struct stoken operator_stoken (const char *);\n static struct stoken typename_stoken (const char *);\n static void check_parameter_typelist (std::vector<struct type *> *);\n-static void write_destructor_name (struct parser_state *par_state,\n-\t\t\t\t   struct stoken);\n \n #ifdef YYBISON\n static void c_print_token (FILE *file, int type, YYSTYPE value);\n@@ -282,190 +282,213 @@ start   :\texp1\n \t;\n \n type_exp:\ttype\n-\t\t\t{ write_exp_elt_opcode(pstate, OP_TYPE);\n-\t\t\t  write_exp_elt_type(pstate, $1);\n-\t\t\t  write_exp_elt_opcode(pstate, OP_TYPE);}\n+\t\t\t{\n+\t\t\t  pstate->push_new<type_operation> ($1);\n+\t\t\t}\n \t|\tTYPEOF '(' exp ')'\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPEOF);\n+\t\t\t  pstate->wrap<typeof_operation> ();\n \t\t\t}\n \t|\tTYPEOF '(' type ')'\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t\t  write_exp_elt_type (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n+\t\t\t  pstate->push_new<type_operation> ($3);\n \t\t\t}\n \t|\tDECLTYPE '(' exp ')'\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_DECLTYPE);\n+\t\t\t  pstate->wrap<decltype_operation> ();\n \t\t\t}\n \t;\n \n /* Expressions, including the comma operator.  */\n exp1\t:\texp\n \t|\texp1 ',' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_COMMA); }\n+\t\t\t{ pstate->wrap2<comma_operation> (); }\n \t;\n \n /* Expressions, not including the comma operator.  */\n exp\t:\t'*' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_IND); }\n+\t\t\t{ pstate->wrap<unop_ind_operation> (); }\n \t;\n \n exp\t:\t'&' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ADDR); }\n+\t\t\t{ pstate->wrap<unop_addr_operation> (); }\n \t;\n \n exp\t:\t'-' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_NEG); }\n+\t\t\t{ pstate->wrap<unary_neg_operation> (); }\n \t;\n \n exp\t:\t'+' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PLUS); }\n+\t\t\t{ pstate->wrap<unary_plus_operation> (); }\n \t;\n \n exp\t:\t'!' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap<opencl_not_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap<unary_logical_not_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\t'~' exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_COMPLEMENT); }\n+\t\t\t{ pstate->wrap<unary_complement_operation> (); }\n \t;\n \n exp\t:\tINCREMENT exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PREINCREMENT); }\n+\t\t\t{ pstate->wrap<preinc_operation> (); }\n \t;\n \n exp\t:\tDECREMENT exp    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_PREDECREMENT); }\n+\t\t\t{ pstate->wrap<predec_operation> (); }\n \t;\n \n exp\t:\texp INCREMENT    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_POSTINCREMENT); }\n+\t\t\t{ pstate->wrap<postinc_operation> (); }\n \t;\n \n exp\t:\texp DECREMENT    %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_POSTDECREMENT); }\n+\t\t\t{ pstate->wrap<postdec_operation> (); }\n \t;\n \n exp\t:\tTYPEID '(' exp ')' %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_TYPEID); }\n+\t\t\t{ pstate->wrap<typeid_operation> (); }\n \t;\n \n exp\t:\tTYPEID '(' type_exp ')' %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_TYPEID); }\n+\t\t\t{ pstate->wrap<typeid_operation> (); }\n \t;\n \n exp\t:\tSIZEOF exp       %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_SIZEOF); }\n+\t\t\t{ pstate->wrap<unop_sizeof_operation> (); }\n \t;\n \n exp\t:\tALIGNOF '(' type_exp ')'\t%prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_ALIGNOF); }\n+\t\t\t{ pstate->wrap<unop_alignof_operation> (); }\n \t;\n \n exp\t:\texp ARROW field_name\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<structop_ptr_operation>\n+\t\t\t    (pstate->pop (), copy_name ($3));\n+\t\t\t}\n \t;\n \n exp\t:\texp ARROW field_name COMPLETE\n-\t\t\t{ pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_ptr_operation (pstate->pop (),\n+\t\t\t\t\t\t\t  copy_name ($3));\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp ARROW COMPLETE\n-\t\t\t{ struct stoken s;\n-\t\t\t  pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t\t  s.ptr = \"\";\n-\t\t\t  s.length = 0;\n-\t\t\t  write_exp_string (pstate, s);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_ptr_operation (pstate->pop (), \"\");\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp ARROW '~' name\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t\t  write_destructor_name (pstate, $4);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<structop_ptr_operation>\n+\t\t\t    (pstate->pop (), \"~\" + copy_name ($4));\n+\t\t\t}\n \t;\n \n exp\t:\texp ARROW '~' name COMPLETE\n-\t\t\t{ pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t\t  write_destructor_name (pstate, $4);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_PTR); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_ptr_operation (pstate->pop (),\n+\t\t\t\t\t\t\t  \"~\" + copy_name ($4));\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp ARROW qualified_name\n \t\t\t{ /* exp->type::name becomes exp->*(&type::name) */\n \t\t\t  /* Note: this doesn't work if name is a\n \t\t\t     static member!  FIXME */\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_ADDR);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_MPTR); }\n+\t\t\t  pstate->wrap<unop_addr_operation> ();\n+\t\t\t  pstate->wrap2<structop_mptr_operation> (); }\n \t;\n \n exp\t:\texp ARROW_STAR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_MPTR); }\n+\t\t\t{ pstate->wrap2<structop_mptr_operation> (); }\n \t;\n \n exp\t:\texp '.' field_name\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->push_new<opencl_structop_operation>\n+\t\t\t      (pstate->pop (), copy_name ($3));\n+\t\t\t  else\n+\t\t\t    pstate->push_new<structop_operation>\n+\t\t\t      (pstate->pop (), copy_name ($3));\n+\t\t\t}\n \t;\n \n exp\t:\texp '.' field_name COMPLETE\n-\t\t\t{ pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_operation (pstate->pop (),\n+\t\t\t\t\t\t      copy_name ($3));\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp '.' COMPLETE\n-\t\t\t{ struct stoken s;\n-\t\t\t  pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  s.ptr = \"\";\n-\t\t\t  s.length = 0;\n-\t\t\t  write_exp_string (pstate, s);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_operation (pstate->pop (), \"\");\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp '.' '~' name\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_destructor_name (pstate, $4);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<structop_operation>\n+\t\t\t    (pstate->pop (), \"~\" + copy_name ($4));\n+\t\t\t}\n \t;\n \n exp\t:\texp '.' '~' name COMPLETE\n-\t\t\t{ pstate->mark_struct_expression ();\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t\t  write_destructor_name (pstate, $4);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t\t{\n+\t\t\t  structop_base_operation *op\n+\t\t\t    = new structop_operation (pstate->pop (),\n+\t\t\t\t\t\t      \"~\" + copy_name ($4));\n+\t\t\t  pstate->mark_struct_expression (op);\n+\t\t\t  pstate->push (operation_up (op));\n+\t\t\t}\n \t;\n \n exp\t:\texp '.' qualified_name\n \t\t\t{ /* exp.type::name becomes exp.*(&type::name) */\n \t\t\t  /* Note: this doesn't work if name is a\n \t\t\t     static member!  FIXME */\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_ADDR);\n-\t\t\t  write_exp_elt_opcode (pstate, STRUCTOP_MEMBER); }\n+\t\t\t  pstate->wrap<unop_addr_operation> ();\n+\t\t\t  pstate->wrap2<structop_member_operation> (); }\n \t;\n \n exp\t:\texp DOT_STAR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_MEMBER); }\n+\t\t\t{ pstate->wrap2<structop_member_operation> (); }\n \t;\n \n exp\t:\texp '[' exp1 ']'\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUBSCRIPT); }\n+\t\t\t{ pstate->wrap2<subscript_operation> (); }\n \t;\n \n exp\t:\texp OBJC_LBRAC exp1 ']'\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUBSCRIPT); }\n+\t\t\t{ pstate->wrap2<subscript_operation> (); }\n \t;\n \n /*\n@@ -483,43 +506,30 @@ exp\t: \tOBJC_LBRAC TYPENAME\n \t\t\t  if (theclass == 0)\n \t\t\t    error (_(\"%s is not an ObjC Class\"),\n \t\t\t\t   copy.c_str ());\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t      parse_type (pstate)->builtin_int);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) theclass);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (parse_type (pstate)->builtin_int,\n+\t\t\t     (LONGEST) theclass);\n \t\t\t  start_msglist();\n \t\t\t}\n \t\tmsglist ']'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_OBJC_MSGCALL);\n-\t\t\t  end_msglist (pstate);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_OBJC_MSGCALL);\n-\t\t\t}\n+\t\t\t{ end_msglist (pstate); }\n \t;\n \n exp\t:\tOBJC_LBRAC CLASSNAME\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t    parse_type (pstate)->builtin_int);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $2.theclass);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (parse_type (pstate)->builtin_int,\n+\t\t\t     (LONGEST) $2.theclass);\n \t\t\t  start_msglist();\n \t\t\t}\n \t\tmsglist ']'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_OBJC_MSGCALL);\n-\t\t\t  end_msglist (pstate);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_OBJC_MSGCALL);\n-\t\t\t}\n+\t\t\t{ end_msglist (pstate); }\n \t;\n \n exp\t:\tOBJC_LBRAC exp\n \t\t\t{ start_msglist(); }\n \t\tmsglist ']'\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_OBJC_MSGCALL);\n-\t\t\t  end_msglist (pstate);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_OBJC_MSGCALL);\n-\t\t\t}\n+\t\t\t{ end_msglist (pstate); }\n \t;\n \n msglist :\tname\n@@ -544,47 +554,41 @@ exp\t:\texp '('\n \t\t\t   being accumulated by an outer function call.  */\n \t\t\t{ pstate->start_arglist (); }\n \t\targlist ')'\t%prec ARROW\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t pstate->end_arglist ());\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL); }\n+\t\t\t{\n+\t\t\t  std::vector<operation_up> args\n+\t\t\t    = pstate->pop_vector (pstate->end_arglist ());\n+\t\t\t  pstate->push_new<funcall_operation>\n+\t\t\t    (pstate->pop (), std::move (args));\n+\t\t\t}\n \t;\n \n /* This is here to disambiguate with the production for\n    \"func()::static_var\" further below, which uses\n    function_method_void.  */\n exp\t:\texp '(' ')' %prec ARROW\n-\t\t\t{ pstate->start_arglist ();\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t pstate->end_arglist ());\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<funcall_operation>\n+\t\t\t    (pstate->pop (), std::vector<operation_up> ());\n+\t\t\t}\n \t;\n \n \n exp\t:\tUNKNOWN_CPP_NAME '('\n \t\t\t{\n \t\t\t  /* This could potentially be a an argument defined\n \t\t\t     lookup function (Koenig).  */\n-\t\t\t  write_exp_elt_opcode (pstate, OP_ADL_FUNC);\n-\t\t\t  write_exp_elt_block\n-\t\t\t    (pstate, pstate->expression_context_block);\n-\t\t\t  write_exp_elt_sym (pstate,\n-\t\t\t\t\t     NULL); /* Placeholder.  */\n-\t\t\t  write_exp_string (pstate, $1.stoken);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_ADL_FUNC);\n-\n-\t\t\t/* This is to save the value of arglist_len\n-\t\t\t   being accumulated by an outer function call.  */\n-\n+\t\t\t  /* This is to save the value of arglist_len\n+\t\t\t     being accumulated by an outer function call.  */\n \t\t\t  pstate->start_arglist ();\n \t\t\t}\n \t\targlist ')'\t%prec ARROW\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t pstate->end_arglist ());\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL);\n+\t\t\t  std::vector<operation_up> args\n+\t\t\t    = pstate->pop_vector (pstate->end_arglist ());\n+\t\t\t  pstate->push_new<adl_func_operation>\n+\t\t\t    (copy_name ($1.stoken),\n+\t\t\t     pstate->expression_context_block,\n+\t\t\t     std::move (args));\n \t\t\t}\n \t;\n \n@@ -606,33 +610,25 @@ arglist\t:\targlist ',' exp   %prec ABOVE_COMMA\n function_method:       exp '(' parameter_typelist ')' const_or_volatile\n \t\t\t{\n \t\t\t  std::vector<struct type *> *type_list = $3;\n-\t\t\t  LONGEST len = type_list->size ();\n-\n-\t\t\t  write_exp_elt_opcode (pstate, TYPE_INSTANCE);\n \t\t\t  /* Save the const/volatile qualifiers as\n \t\t\t     recorded by the const_or_volatile\n \t\t\t     production's actions.  */\n-\t\t\t  write_exp_elt_longcst\n-\t\t\t    (pstate,\n-\t\t\t     (cpstate->type_stack\n-\t\t\t      .follow_type_instance_flags ()));\n-\t\t\t  write_exp_elt_longcst (pstate, len);\n-\t\t\t  for (type *type_elt : *type_list)\n-\t\t\t    write_exp_elt_type (pstate, type_elt);\n-\t\t\t  write_exp_elt_longcst(pstate, len);\n-\t\t\t  write_exp_elt_opcode (pstate, TYPE_INSTANCE);\n+\t\t\t  type_instance_flags flags\n+\t\t\t    = (cpstate->type_stack\n+\t\t\t       .follow_type_instance_flags ());\n+\t\t\t  pstate->push_new<type_instance_operation>\n+\t\t\t    (flags, std::move (*type_list),\n+\t\t\t     pstate->pop ());\n \t\t\t}\n \t;\n \n function_method_void:\t    exp '(' ')' const_or_volatile\n-\t\t       { write_exp_elt_opcode (pstate, TYPE_INSTANCE);\n-\t\t\t /* See above.  */\n-\t\t\t write_exp_elt_longcst\n-\t\t\t   (pstate,\n-\t\t\t    cpstate->type_stack.follow_type_instance_flags ());\n-\t\t\t write_exp_elt_longcst (pstate, 0);\n-\t\t\t write_exp_elt_longcst (pstate, 0);\n-\t\t\t write_exp_elt_opcode (pstate, TYPE_INSTANCE);\n+\t\t       {\n+\t\t\t  type_instance_flags flags\n+\t\t\t    = (cpstate->type_stack\n+\t\t\t       .follow_type_instance_flags ());\n+\t\t\t  pstate->push_new<type_instance_operation>\n+\t\t\t    (flags, std::vector<type *> (), pstate->pop ());\n \t\t       }\n        ;\n \n@@ -649,28 +645,35 @@ function_method_void_or_typelist: function_method\n \n exp     :       function_method_void_or_typelist COLONCOLON name\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNC_STATIC_VAR);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FUNC_STATIC_VAR);\n+\t\t\t  pstate->push_new<func_static_var_operation>\n+\t\t\t    (pstate->pop (), copy_name ($3));\n \t\t\t}\n \t;\n \n rcurly\t:\t'}'\n \t\t\t{ $$ = pstate->end_arglist () - 1; }\n \t;\n exp\t:\tlcurly arglist rcurly\t%prec ARROW\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_ARRAY);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) 0);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) $3);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_ARRAY); }\n+\t\t\t{\n+\t\t\t  std::vector<operation_up> args\n+\t\t\t    = pstate->pop_vector ($3 + 1);\n+\t\t\t  pstate->push_new<array_operation> (0, $3,\n+\t\t\t\t\t\t\t     std::move (args));\n+\t\t\t}\n \t;\n \n exp\t:\tlcurly type_exp rcurly exp  %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_MEMVAL_TYPE); }\n+\t\t\t{ pstate->wrap2<unop_memval_type_operation> (); }\n \t;\n \n exp\t:\t'(' type_exp ')' exp  %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_CAST_TYPE); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap2<opencl_cast_type_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<unop_cast_type_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\t'(' exp1 ')'\n@@ -680,116 +683,194 @@ exp\t:\t'(' exp1 ')'\n /* Binary operators in order of decreasing precedence.  */\n \n exp\t:\texp '@' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REPEAT); }\n+\t\t\t{ pstate->wrap2<repeat_operation> (); }\n \t;\n \n exp\t:\texp '*' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_MUL); }\n+\t\t\t{ pstate->wrap2<mul_operation> (); }\n \t;\n \n exp\t:\texp '/' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_DIV); }\n+\t\t\t{ pstate->wrap2<div_operation> (); }\n \t;\n \n exp\t:\texp '%' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_REM); }\n+\t\t\t{ pstate->wrap2<rem_operation> (); }\n \t;\n \n exp\t:\texp '+' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ADD); }\n+\t\t\t{ pstate->wrap2<add_operation> (); }\n \t;\n \n exp\t:\texp '-' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_SUB); }\n+\t\t\t{ pstate->wrap2<sub_operation> (); }\n \t;\n \n exp\t:\texp LSH exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LSH); }\n+\t\t\t{ pstate->wrap2<lsh_operation> (); }\n \t;\n \n exp\t:\texp RSH exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_RSH); }\n+\t\t\t{ pstate->wrap2<rsh_operation> (); }\n \t;\n \n exp\t:\texp EQUAL exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap2<opencl_equal_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<equal_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp NOTEQUAL exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap2<opencl_notequal_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<notequal_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp LEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LEQ); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap2<opencl_leq_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<leq_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp GEQ exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GEQ); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap2<opencl_geq_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<geq_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp '<' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LESS); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap2<opencl_less_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<less_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp '>' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_GTR); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap2<opencl_gtr_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<gtr_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp '&' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_AND); }\n+\t\t\t{ pstate->wrap2<bitwise_and_operation> (); }\n \t;\n \n exp\t:\texp '^' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n+\t\t\t{ pstate->wrap2<bitwise_xor_operation> (); }\n \t;\n \n exp\t:\texp '|' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_IOR); }\n+\t\t\t{ pstate->wrap2<bitwise_ior_operation> (); }\n \t;\n \n exp\t:\texp ANDAND exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    {\n+\t\t\t      operation_up rhs = pstate->pop ();\n+\t\t\t      operation_up lhs = pstate->pop ();\n+\t\t\t      pstate->push_new<opencl_logical_binop_operation>\n+\t\t\t\t(BINOP_LOGICAL_AND, std::move (lhs),\n+\t\t\t\t std::move (rhs));\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<logical_and_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp OROR exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    {\n+\t\t\t      operation_up rhs = pstate->pop ();\n+\t\t\t      operation_up lhs = pstate->pop ();\n+\t\t\t      pstate->push_new<opencl_logical_binop_operation>\n+\t\t\t\t(BINOP_LOGICAL_OR, std::move (lhs),\n+\t\t\t\t std::move (rhs));\n+\t\t\t    }\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<logical_or_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp '?' exp ':' exp\t%prec '?'\n-\t\t\t{ write_exp_elt_opcode (pstate, TERNOP_COND); }\n+\t\t\t{\n+\t\t\t  operation_up last = pstate->pop ();\n+\t\t\t  operation_up mid = pstate->pop ();\n+\t\t\t  operation_up first = pstate->pop ();\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->push_new<opencl_ternop_cond_operation>\n+\t\t\t      (std::move (first), std::move (mid),\n+\t\t\t       std::move (last));\n+\t\t\t  else\n+\t\t\t    pstate->push_new<ternop_cond_operation>\n+\t\t\t      (std::move (first), std::move (mid),\n+\t\t\t       std::move (last));\n+\t\t\t}\n \t;\n \n exp\t:\texp '=' exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN); }\n+\t\t\t{\n+\t\t\t  if (pstate->language ()->la_language\n+\t\t\t      == language_opencl)\n+\t\t\t    pstate->wrap2<opencl_assign_operation> ();\n+\t\t\t  else\n+\t\t\t    pstate->wrap2<assign_operation> ();\n+\t\t\t}\n \t;\n \n exp\t:\texp ASSIGN_MODIFY exp\n-\t\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);\n-\t\t\t  write_exp_elt_opcode (pstate, $2);\n-\t\t\t  write_exp_elt_opcode (pstate,\n-\t\t\t\t\t\tBINOP_ASSIGN_MODIFY); }\n+\t\t\t{\n+\t\t\t  operation_up rhs = pstate->pop ();\n+\t\t\t  operation_up lhs = pstate->pop ();\n+\t\t\t  pstate->push_new<assign_modify_operation>\n+\t\t\t    ($2, std::move (lhs), std::move (rhs));\n+\t\t\t}\n \t;\n \n exp\t:\tINT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) ($1.val));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    ($1.type, $1.val);\n+\t\t\t}\n \t;\n \n exp\t:\tCOMPLEX_INT\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, TYPE_TARGET_TYPE ($1.type));\n-\t\t\t  write_exp_elt_longcst (pstate, 0);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, TYPE_TARGET_TYPE ($1.type));\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) ($1.val));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX);\n+\t\t\t  operation_up real\n+\t\t\t    = (make_operation<long_const_operation>\n+\t\t\t       (TYPE_TARGET_TYPE ($1.type), 0));\n+\t\t\t  operation_up imag\n+\t\t\t    = (make_operation<long_const_operation>\n+\t\t\t       (TYPE_TARGET_TYPE ($1.type), $1.val));\n+\t\t\t  pstate->push_new<complex_operation>\n+\t\t\t    (std::move (real), std::move (imag), $1.type);\n \t\t\t}\n \t;\n \n@@ -798,48 +879,51 @@ exp\t:\tCHAR\n \t\t\t  struct stoken_vector vec;\n \t\t\t  vec.len = 1;\n \t\t\t  vec.tokens = &$1;\n-\t\t\t  write_exp_string_vector (pstate, $1.type, &vec);\n+\t\t\t  pstate->push_c_string ($1.type, &vec);\n \t\t\t}\n \t;\n \n exp\t:\tNAME_OR_INT\n \t\t\t{ YYSTYPE val;\n \t\t\t  parse_number (pstate, $1.stoken.ptr,\n \t\t\t\t\t$1.stoken.length, 0, &val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, val.typed_val_int.type);\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t    (LONGEST) val.typed_val_int.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (val.typed_val_int.type,\n+\t\t\t     val.typed_val_int.val);\n \t\t\t}\n \t;\n \n \n exp\t:\tFLOAT\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_floatcst (pstate, $1.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT); }\n+\t\t\t{\n+\t\t\t  float_data data;\n+\t\t\t  std::copy (std::begin ($1.val), std::end ($1.val),\n+\t\t\t\t     std::begin (data));\n+\t\t\t  pstate->push_new<float_const_operation> ($1.type, data);\n+\t\t\t}\n \t;\n \n exp\t:\tCOMPLEX_FLOAT\n \t\t\t{\n \t\t\t  struct type *underlying\n \t\t\t    = TYPE_TARGET_TYPE ($1.type);\n \n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_type (pstate, underlying);\n-\t\t\t  gdb_byte val[16];\n-\t\t\t  target_float_from_host_double (val, underlying, 0);\n-\t\t\t  write_exp_elt_floatcst (pstate, val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_type (pstate, underlying);\n-\t\t\t  write_exp_elt_floatcst (pstate, $1.val);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX);\n-\t\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_COMPLEX);\n+\t\t\t  float_data val;\n+\t\t\t  target_float_from_host_double (val.data (),\n+\t\t\t\t\t\t\t underlying, 0);\n+\t\t\t  operation_up real\n+\t\t\t    = (make_operation<float_const_operation>\n+\t\t\t       (underlying, val));\n+\n+\t\t\t  std::copy (std::begin ($1.val), std::end ($1.val),\n+\t\t\t\t     std::begin (val));\n+\t\t\t  operation_up imag\n+\t\t\t    = (make_operation<float_const_operation>\n+\t\t\t       (underlying, val));\n+\n+\t\t\t  pstate->push_new<complex_operation>\n+\t\t\t    (std::move (real), std::move (imag),\n+\t\t\t     $1.type);\n \t\t\t}\n \t;\n \n@@ -848,23 +932,22 @@ exp\t:\tvariable\n \n exp\t:\tDOLLAR_VARIABLE\n \t\t\t{\n-\t\t\t  write_dollar_variable (pstate, $1);\n+\t\t\t  pstate->push_dollar ($1);\n \t\t\t}\n \t;\n \n exp\t:\tSELECTOR '(' name ')'\n \t\t\t{\n-\t\t\t  write_exp_elt_opcode (pstate, OP_OBJC_SELECTOR);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_OBJC_SELECTOR); }\n+\t\t\t  pstate->push_new<objc_selector_operation>\n+\t\t\t    (copy_name ($3));\n+\t\t\t}\n \t;\n \n exp\t:\tSIZEOF '(' type ')'\t%prec UNARY\n \t\t\t{ struct type *type = $3;\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate, lookup_signed_typename\n-\t\t\t\t\t      (pstate->language (),\n-\t\t\t\t\t       \"int\"));\n+\t\t\t  struct type *int_type\n+\t\t\t    = lookup_signed_typename (pstate->language (),\n+\t\t\t\t\t\t      \"int\");\n \t\t\t  type = check_typedef (type);\n \n \t\t\t    /* $5.3.3/2 of the C++ Standard (n3290 draft)\n@@ -873,28 +956,27 @@ exp\t:\tSIZEOF '(' type ')'\t%prec UNARY\n \t\t\t       the referenced type.\"  */\n \t\t\t  if (TYPE_IS_REFERENCE (type))\n \t\t\t    type = check_typedef (TYPE_TARGET_TYPE (type));\n-\t\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t\t (LONGEST) TYPE_LENGTH (type));\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t  pstate->push_new<long_const_operation>\n+\t\t\t    (int_type, TYPE_LENGTH (type));\n+\t\t\t}\n \t;\n \n exp\t:\tREINTERPRET_CAST '<' type_exp '>' '(' exp ')' %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate,\n-\t\t\t\t\t\tUNOP_REINTERPRET_CAST); }\n+\t\t\t{ pstate->wrap2<reinterpret_cast_operation> (); }\n \t;\n \n exp\t:\tSTATIC_CAST '<' type_exp '>' '(' exp ')' %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_CAST_TYPE); }\n+\t\t\t{ pstate->wrap2<unop_cast_type_operation> (); }\n \t;\n \n exp\t:\tDYNAMIC_CAST '<' type_exp '>' '(' exp ')' %prec UNARY\n-\t\t\t{ write_exp_elt_opcode (pstate, UNOP_DYNAMIC_CAST); }\n+\t\t\t{ pstate->wrap2<dynamic_cast_operation> (); }\n \t;\n \n exp\t:\tCONST_CAST '<' type_exp '>' '(' exp ')' %prec UNARY\n \t\t\t{ /* We could do more error checking here, but\n \t\t\t     it doesn't seem worthwhile.  */\n-\t\t\t  write_exp_elt_opcode (pstate, UNOP_CAST_TYPE); }\n+\t\t\t  pstate->wrap2<unop_cast_type_operation> (); }\n \t;\n \n string_exp:\n@@ -959,7 +1041,7 @@ exp\t:\tstring_exp\n \t\t\t\t}\n \t\t\t    }\n \n-\t\t\t  write_exp_string_vector (pstate, type, &$1);\n+\t\t\t  pstate->push_c_string (type, &$1);\n \t\t\t  for (i = 0; i < $1.len; ++i)\n \t\t\t    free ($1.tokens[i].ptr);\n \t\t\t  free ($1.tokens);\n@@ -969,26 +1051,23 @@ exp\t:\tstring_exp\n exp     :\tNSSTRING\t/* ObjC NextStep NSString constant\n \t\t\t\t * of the form '@' '\"' string '\"'.\n \t\t\t\t */\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_OBJC_NSSTRING);\n-\t\t\t  write_exp_string (pstate, $1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_OBJC_NSSTRING); }\n+\t\t\t{\n+\t\t\t  pstate->push_new<objc_nsstring_operation>\n+\t\t\t    (copy_name ($1));\n+\t\t\t}\n \t;\n \n /* C++.  */\n exp     :       TRUEKEYWORD\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t  parse_type (pstate)->builtin_bool);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) 1);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t{ pstate->push_new<long_const_operation>\n+\t\t\t    (parse_type (pstate)->builtin_bool, 1);\n+\t\t\t}\n \t;\n \n exp     :       FALSEKEYWORD\n-\t\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t\t  write_exp_elt_type (pstate,\n-\t\t\t\t\t  parse_type (pstate)->builtin_bool);\n-\t\t\t  write_exp_elt_longcst (pstate, (LONGEST) 0);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t\t{ pstate->push_new<long_const_operation>\n+\t\t\t    (parse_type (pstate)->builtin_bool, 0);\n+\t\t\t}\n \t;\n \n /* end of C++.  */\n@@ -1029,9 +1108,7 @@ variable:\tname_not_typename ENTRY\n \t\t\t\t     \"parameters, not for \\\"%s\\\"\"),\n \t\t\t\t   copy_name ($1.stoken).c_str ());\n \n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_ENTRY_VALUE);\n-\t\t\t  write_exp_elt_sym (pstate, sym);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_ENTRY_VALUE);\n+\t\t\t  pstate->push_new<var_entry_value_operation> (sym);\n \t\t\t}\n \t;\n \n@@ -1048,10 +1125,9 @@ variable:\tblock COLONCOLON name\n \t\t\t  if (symbol_read_needs_frame (sym.symbol))\n \t\t\t    pstate->block_tracker->update (sym);\n \n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t  write_exp_elt_block (pstate, sym.block);\n-\t\t\t  write_exp_elt_sym (pstate, sym.symbol);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE); }\n+\t\t\t  pstate->push_new<var_value_operation> (sym.symbol,\n+\t\t\t\t\t\t\t\t sym.block);\n+\t\t\t}\n \t;\n \n qualified_name:\tTYPENAME COLONCOLON name\n@@ -1062,34 +1138,24 @@ qualified_name:\tTYPENAME COLONCOLON name\n \t\t\t    error (_(\"`%s' is not defined as an aggregate type.\"),\n \t\t\t\t   TYPE_SAFE_NAME (type));\n \n-\t\t\t  write_exp_elt_opcode (pstate, OP_SCOPE);\n-\t\t\t  write_exp_elt_type (pstate, type);\n-\t\t\t  write_exp_string (pstate, $3);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_SCOPE);\n+\t\t\t  pstate->push_new<scope_operation> (type,\n+\t\t\t\t\t\t\t     copy_name ($3));\n \t\t\t}\n \t|\tTYPENAME COLONCOLON '~' name\n \t\t\t{\n \t\t\t  struct type *type = $1.type;\n-\t\t\t  struct stoken tmp_token;\n-\t\t\t  char *buf;\n \n \t\t\t  type = check_typedef (type);\n \t\t\t  if (!type_aggregate_p (type))\n \t\t\t    error (_(\"`%s' is not defined as an aggregate type.\"),\n \t\t\t\t   TYPE_SAFE_NAME (type));\n-\t\t\t  buf = (char *) alloca ($4.length + 2);\n-\t\t\t  tmp_token.ptr = buf;\n-\t\t\t  tmp_token.length = $4.length + 1;\n-\t\t\t  buf[0] = '~';\n-\t\t\t  memcpy (buf+1, $4.ptr, $4.length);\n-\t\t\t  buf[tmp_token.length] = 0;\n+\t\t\t  std::string name = \"~\" + std::string ($4.ptr,\n+\t\t\t\t\t\t\t\t$4.length);\n \n \t\t\t  /* Check for valid destructor name.  */\n-\t\t\t  destructor_name_p (tmp_token.ptr, $1.type);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_SCOPE);\n-\t\t\t  write_exp_elt_type (pstate, type);\n-\t\t\t  write_exp_string (pstate, tmp_token);\n-\t\t\t  write_exp_elt_opcode (pstate, OP_SCOPE);\n+\t\t\t  destructor_name_p (name.c_str (), $1.type);\n+\t\t\t  pstate->push_new<scope_operation> (type,\n+\t\t\t\t\t\t\t     std::move (name));\n \t\t\t}\n \t|\tTYPENAME COLONCOLON name COLONCOLON name\n \t\t\t{\n@@ -1108,8 +1174,7 @@ variable:\tqualified_name\n \t\t\t    = lookup_symbol (name.c_str (),\n \t\t\t\t\t     (const struct block *) NULL,\n \t\t\t\t\t     VAR_DOMAIN, NULL);\n-\t\t\t  write_exp_symbol_reference (pstate, name.c_str (),\n-\t\t\t\t\t\t      sym);\n+\t\t\t  pstate->push_symbol (name.c_str (), sym);\n \t\t\t}\n \t;\n \n@@ -1129,26 +1194,22 @@ variable:\tname_not_typename\n \t\t\t      bound_minimal_symbol resolver\n \t\t\t\t= find_gnu_ifunc (sym.symbol);\n \t\t\t      if (resolver.minsym != NULL)\n-\t\t\t\twrite_exp_msymbol (pstate, resolver);\n+\t\t\t\tpstate->push_new<var_msym_value_operation>\n+\t\t\t\t  (resolver.minsym, resolver.objfile);\n \t\t\t      else\n-\t\t\t\t{\n-\t\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t\t  write_exp_elt_block (pstate, sym.block);\n-\t\t\t\t  write_exp_elt_sym (pstate, sym.symbol);\n-\t\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t\t}\n+\t\t\t\tpstate->push_new<var_value_operation>\n+\t\t\t\t  (sym.symbol, sym.block);\n \t\t\t    }\n \t\t\t  else if ($1.is_a_field_of_this)\n \t\t\t    {\n \t\t\t      /* C++: it hangs off of `this'.  Must\n \t\t\t\t not inadvertently convert from a method call\n \t\t\t\t to data ref.  */\n \t\t\t      pstate->block_tracker->update (sym);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_THIS);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_THIS);\n-\t\t\t      write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t\t      write_exp_string (pstate, $1.stoken);\n-\t\t\t      write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n+\t\t\t      operation_up thisop\n+\t\t\t\t= make_operation<op_this_operation> ();\n+\t\t\t      pstate->push_new<structop_ptr_operation>\n+\t\t\t\t(std::move (thisop), copy_name ($1.stoken));\n \t\t\t    }\n \t\t\t  else\n \t\t\t    {\n@@ -1178,15 +1239,11 @@ variable:\tname_not_typename\n \t\t\t\t   ? find_function_alias_target (msymbol)\n \t\t\t\t   : NULL);\n \t\t\t      if (alias_target != NULL)\n-\t\t\t\t{\n-\t\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t\t  write_exp_elt_block\n-\t\t\t\t    (pstate, SYMBOL_BLOCK_VALUE (alias_target));\n-\t\t\t\t  write_exp_elt_sym (pstate, alias_target);\n-\t\t\t\t  write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t\t\t}\n+\t\t\t\tpstate->push_new<var_value_operation>\n+\t\t\t\t  (alias_target, SYMBOL_BLOCK_VALUE (alias_target));\n \t\t\t      else\n-\t\t\t\twrite_exp_msymbol (pstate, msymbol);\n+\t\t\t\tpstate->push_new<var_msym_value_operation>\n+\t\t\t\t  (msymbol.minsym, msymbol.objfile);\n \t\t\t    }\n \t\t\t}\n \t;\n@@ -1783,22 +1840,6 @@ name_not_typename :\tNAME\n \n %%\n \n-/* Like write_exp_string, but prepends a '~'.  */\n-\n-static void\n-write_destructor_name (struct parser_state *par_state, struct stoken token)\n-{\n-  char *copy = (char *) alloca (token.length + 1);\n-\n-  copy[0] = '~';\n-  memcpy (&copy[1], token.ptr, token.length);\n-\n-  token.ptr = copy;\n-  ++token.length;\n-\n-  write_exp_string (par_state, token);\n-}\n-\n /* Returns a stoken of the operator name given by OP (which does not\n    include the string \"operator\").  */\n \n@@ -3393,7 +3434,10 @@ c_parse (struct parser_state *par_state)\n   popping = 0;\n   name_obstack.clear ();\n \n-  return yyparse ();\n+  int result = yyparse ();\n+  if (!result)\n+    pstate->set_operation (pstate->pop ());\n+  return result;\n }\n \n #ifdef YYBISON"
    },
    {
      "sha": "788fe0f3353cb9f809365d1cec75a3d4fbc8231a",
      "filename": "gdb/objc-lang.c",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/objc-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/objc-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/objc-lang.c?ref=d182f2797922a305fbd1ef6a483cc39a56b43e02",
      "patch": "@@ -43,6 +43,7 @@\n #include \"infcall.h\"\n #include \"valprint.h\"\n #include \"cli/cli-utils.h\"\n+#include \"c-exp.h\"\n \n #include <ctype.h>\n #include <algorithm>\n@@ -507,15 +508,20 @@ end_msglist (struct parser_state *ps)\n   char *p = msglist_sel;\n   CORE_ADDR selid;\n \n+  std::vector<expr::operation_up> args = ps->pop_vector (val);\n+  expr::operation_up target = ps->pop ();\n+\n   selname_chain = sel->next;\n   msglist_len = sel->msglist_len;\n   msglist_sel = sel->msglist_sel;\n   selid = lookup_child_selector (ps->gdbarch (), p);\n   if (!selid)\n     error (_(\"Can't find selector \\\"%s\\\"\"), p);\n-  write_exp_elt_longcst (ps, selid);\n+\n+  ps->push_new<expr::objc_msgcall_operation> (selid, std::move (target),\n+\t\t\t\t\t      std::move (args));\n+\n   xfree(p);\n-  write_exp_elt_longcst (ps, val);\t/* Number of args */\n   xfree(sel);\n \n   return val;"
    },
    {
      "sha": "5b65aafe2e1059bedd1696e25f7fd5621533db49",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=d182f2797922a305fbd1ef6a483cc39a56b43e02",
      "patch": "@@ -1,3 +1,7 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* gdb.base/debug-expr.exp: Update expected dump output.\n+\n 2021-03-06  Tom Tromey  <tom@tromey.com>\n \n \t* lib/dwarf.exp (_handle_DW_FORM): Treat DW_FORM_GNU_ref_alt and"
    },
    {
      "sha": "77cf030d9064aa0963b49b9447a0f7197efa78da",
      "filename": "gdb/testsuite/gdb.base/debug-expr.exp",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/testsuite/gdb.base/debug-expr.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d182f2797922a305fbd1ef6a483cc39a56b43e02/gdb/testsuite/gdb.base/debug-expr.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/debug-expr.exp?ref=d182f2797922a305fbd1ef6a483cc39a56b43e02",
      "patch": "@@ -45,10 +45,10 @@ gdb_test_debug_expr \"print /x {char\\[4\\]} array\" \\\n \n # This caused gdb to output garbage and possibly segfault\n gdb_test_debug_expr \"print \\\"hello\\\"\" \\\n-    \".*OP_STRING\\[^\\r\\n\\]*Language-specific string type: 0.*\\[\\r\\n\\]\\\\$$decimal = \\\"hello\\\"\" \\\n+    \".*OP_STRING\\[^\\r\\n\\]*.*: ordinary string.*\\[\\r\\n\\]\\\\$$decimal = \\\"hello\\\"\" \\\n     \"string evaluation with debug expr\"\n \n # An expression using a function call.\n gdb_test_debug_expr \"print call_me ( &val )\" \\\n-    \".*OP_FUNCALL\\[^\\r\\n\\]*Number of args: 1.*\\[\\r\\n\\]\\\\$$decimal = 0.*\" \\\n+    \".*OP_FUNCALL\\[^\\r\\n\\]*.*UNOP_ADDR.*\\[\\r\\n\\]\\\\$$decimal = 0.*\" \\\n     \"function call expression\""
    }
  ]
}