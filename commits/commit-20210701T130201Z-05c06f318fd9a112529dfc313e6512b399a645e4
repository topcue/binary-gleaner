{
  "sha": "05c06f318fd9a112529dfc313e6512b399a645e4",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDVjMDZmMzE4ZmQ5YTExMjUyOWRmYzMxM2U2NTEyYjM5OWE2NDVlNA==",
  "commit": {
    "author": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-06-11T16:56:32Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-07-01T13:02:01Z"
    },
    "message": "Linux: Access memory even if threads are running\n\nCurrently, on GNU/Linux, if you try to access memory and you have a\nrunning thread selected, GDB fails the memory accesses, like:\n\n (gdb) c&\n Continuing.\n (gdb) p global_var\n Cannot access memory at address 0x555555558010\n\nOr:\n\n (gdb) b main\n Breakpoint 2 at 0x55555555524d: file access-mem-running.c, line 59.\n Warning:\n Cannot insert breakpoint 2.\n Cannot access memory at address 0x55555555524d\n\nThis patch removes this limitation.  It teaches the native Linux\ntarget to read/write memory even if the target is running.  And it\ndoes this without temporarily stopping threads.  We now get:\n\n (gdb) c&\n Continuing.\n (gdb) p global_var\n $1 = 123\n (gdb) b main\n Breakpoint 2 at 0x555555555259: file access-mem-running.c, line 62.\n\n(The scenarios above work correctly with current GDBserver, because\nGDBserver temporarily stops all threads in the process whenever GDB\nwants to access memory (see prepare_to_access_memory /\ndone_accessing_memory).  Freezing the whole process makes sense when\nwe need to be sure that we have a consistent view of memory and don't\nrace with the inferior changing it at the same time as GDB is\naccessing it.  But I think that's a too-heavy hammer for the default\nbehavior.  I think that ideally, whether to stop all threads or not\nshould be policy decided by gdb core, probably best implemented by\nexposing something like gdbserver's prepare_to_access_memory /\ndone_accessing_memory to gdb core.)\n\nCurrently, if we're accessing (reading/writing) just a few bytes, then\nthe Linux native backend does not try accessing memory via\n/proc/<pid>/mem and goes straight to ptrace\nPTRACE_PEEKTEXT/PTRACE_POKETEXT.  However, ptrace always fails when\nthe ptracee is running.  So the first step is to prefer\n/proc/<pid>/mem even for small accesses.  Without further changes\nhowever, that may cause a performance regression, due to constantly\nopening and closing /proc/<pid>/mem for each memory access.  So the\nnext step is to keep the /proc/<pid>/mem file open across memory\naccesses.  If we have this, then it doesn't make sense anymore to even\nhave the ptrace fallback, so the patch disables it.\n\nI've made it such that GDB only ever has one /proc/<pid>/mem file open\nat any time.  As long as a memory access hits the same inferior\nprocess as the previous access, then we reuse the previously open\nfile.  If however, we access memory of a different process, then we\nclose the previous file and open a new one for the new process.\n\nIf we wanted, we could keep one /proc/<pid>/mem file open per\ninferior, and never close them (unless the inferior exits or execs).\nHowever, having seen bfd patches recently about hitting too many open\nfile descriptors, I kept the logic to have only one file open tops.\nAlso, we need to handle memory accesses for processes for which we\ndon't have an inferior object, for when we need to detach a\nfork-child, and we'd probaly want to handle caching the open file for\nthat scenario (no inferior for process) too, which would probably end\nup meaning caching for last non-inferior process, which is very much\nwhat I'm proposing anyhow.  So always having one file open likely ends\nup a smaller patch.\n\nThe next step is handling the case of GDB reading/writing memory\nthrough a thread that is running and exits.  The access should not\nresult in a user-visible failure if the inferior/process is still\nalive.\n\nOnce we manage to open a /proc/<lwpid>/mem file, then that file is\nusable for memory accesses even if the corresponding lwp exits and is\nreaped.  I double checked that trying to open the same\n/proc/<lwpid>/mem path again fails because the lwp is really gone so\nthere's no /proc/<lwpid>/ entry on the filesystem anymore, but the\npreviously open file remains usable.  It's only when the whole process\nexecs that we need to reopen a new file.\n\nWhen the kernel destroys the whole address space, i.e., when the\nprocess exits or execs, the reads/writes fail with 0 aka EOF, in which\ncase there's nothing else to do than returning a memory access\nfailure.  Note this means that when we get an exec event, we need to\nreopen the file, to access the process's new address space.\n\nIf we need to open (or reopen) the /proc/<pid>/mem file, and the LWP\nwe're opening it for exits before we open it and before we reap the\nLWP (i.e., the LWP is zombie), the open fails with EACCES.  The patch\nhandles this by just looking for another thread until it finds one\nthat we can open a /proc/<pid>/mem successfully for.\n\nIf we need to open (or reopen) the /proc/<pid>/mem file, and the LWP\nwe're opening has exited and we already reaped it, which is the case\nif the selected thread is in THREAD_EXIT state, the open fails with\nENOENT.  The patch handles this the same way as a zombie race\n(EACCES), instead of checking upfront whether we're accessing a\nknown-exited thread, because that would result in more complicated\ncode, because we also need to handle accessing lwps that are not\nlisted in the core thread list, and it's the core thread list that\nrecords the THREAD_EXIT state.\n\nThe patch includes two testcases:\n\n#1 - gdb.base/access-mem-running.exp\n\n  This is the conceptually simplest - it is single-threaded, and has\n  GDB read and write memory while the program is running.  It also\n  tests setting a breakpoint while the program is running, and checks\n  that the breakpoint is hit immediately.\n\n#2 - gdb.threads/access-mem-running-thread-exit.exp\n\n  This one is more elaborate, as it continuously spawns short-lived\n  threads in order to exercise accessing memory just while threads are\n  exiting.  It also spawns two different processes and alternates\n  accessing memory between the two processes to exercise the reopening\n  the /proc file frequently.  This also ends up exercising GDB reading\n  from an exited thread frequently.  I confirmed by putting abort()\n  calls in the EACCES/ENOENT paths added by the patch that we do hit\n  all of them frequently with the testcase.  It also exits the\n  process's main thread (i.e., the main thread becomes zombie), to\n  make sure accessing memory in such a corner-case scenario works now\n  and in the future.\n\nThe tests fail on GNU/Linux native before the code changes, and pass\nafter.  They pass against current GDBserver, again because GDBserver\nsupports memory access even if all threads are running, by\ntransparently pausing the whole process.\n\ngdb/ChangeLog:\nyyyy-mm-dd  Pedro Alves  <pedro@palves.net>\n\n\tPR mi/15729\n\tPR gdb/13463\n\t* linux-nat.c (linux_nat_target::detach): Close the\n\t/proc/<pid>/mem file if it was open for this process.\n\t(linux_handle_extended_wait) <PTRACE_EVENT_EXEC>: Close the\n\t/proc/<pid>/mem file if it was open for this process.\n\t(linux_nat_target::mourn_inferior): Close the /proc/<pid>/mem file\n\tif it was open for this process.\n\t(linux_nat_target::xfer_partial): Adjust.  Do not fall back to\n\tinf_ptrace_target::xfer_partial for memory accesses.\n\t(last_proc_mem_file): New.\n\t(maybe_close_proc_mem_file): New.\n\t(linux_proc_xfer_memory_partial_pid): New, with bits factored out\n\tfrom linux_proc_xfer_partial.\n\t(linux_proc_xfer_partial): Delete.\n\t(linux_proc_xfer_memory_partial): New.\n\ngdb/testsuite/ChangeLog\nyyyy-mm-dd  Pedro Alves  <pedro@palves.net>\n\n\tPR mi/15729\n\tPR gdb/13463\n\t* gdb.base/access-mem-running.c: New.\n\t* gdb.base/access-mem-running.exp: New.\n\t* gdb.threads/access-mem-running-thread-exit.c: New.\n\t* gdb.threads/access-mem-running-thread-exit.exp: New.\n\nChange-Id: Ib3c082528872662a3fc0ca9b31c34d4876c874c9",
    "tree": {
      "sha": "da87499284919464253f5c78b2377353d2cae98e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/da87499284919464253f5c78b2377353d2cae98e"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/05c06f318fd9a112529dfc313e6512b399a645e4",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/05c06f318fd9a112529dfc313e6512b399a645e4",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/05c06f318fd9a112529dfc313e6512b399a645e4",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/05c06f318fd9a112529dfc313e6512b399a645e4/comments",
  "author": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "75a2da57a1bbff8686f56a43aabe1d7e55147894",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/75a2da57a1bbff8686f56a43aabe1d7e55147894",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/75a2da57a1bbff8686f56a43aabe1d7e55147894"
    }
  ],
  "stats": {
    "total": 753,
    "additions": 706,
    "deletions": 47
  },
  "files": [
    {
      "sha": "d1091792b2605415e99361e2b4973c0a9b160bb8",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 19,
      "deletions": 0,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=05c06f318fd9a112529dfc313e6512b399a645e4",
      "patch": "@@ -1,3 +1,22 @@\n+2021-07-01  Pedro Alves  <pedro@palves.net>\n+\n+\tPR mi/15729\n+\tPR gdb/13463\n+\t* linux-nat.c (linux_nat_target::detach): Close the\n+\t/proc/<pid>/mem file if it was open for this process.\n+\t(linux_handle_extended_wait) <PTRACE_EVENT_EXEC>: Close the\n+\t/proc/<pid>/mem file if it was open for this process.\n+\t(linux_nat_target::mourn_inferior): Close the /proc/<pid>/mem file\n+\tif it was open for this process.\n+\t(linux_nat_target::xfer_partial): Adjust.  Do not fall back to\n+\tinf_ptrace_target::xfer_partial for memory accesses.\n+\t(last_proc_mem_file): New.\n+\t(maybe_close_proc_mem_file): New.\n+\t(linux_proc_xfer_memory_partial_pid): New, with bits factored out\n+\tfrom linux_proc_xfer_partial.\n+\t(linux_proc_xfer_partial): Delete.\n+\t(linux_proc_xfer_memory_partial): New.\n+\n 2021-06-29  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* frame.h (FRAME_SCOPED_DEBUG_ENTER_EXIT): New."
    },
    {
      "sha": "f206b8749299f6b1fb041f47b427350335656a58",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 218,
      "deletions": 47,
      "changes": 265,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=05c06f318fd9a112529dfc313e6512b399a645e4",
      "patch": "@@ -280,6 +280,8 @@ static int lwp_status_pending_p (struct lwp_info *lp);\n \n static void save_stop_reason (struct lwp_info *lp);\n \n+static void maybe_close_proc_mem_file (pid_t pid);\n+\n \f\n /* LWP accessors.  */\n \n@@ -1486,6 +1488,8 @@ linux_nat_target::detach (inferior *inf, int from_tty)\n \n       detach_success (inf);\n     }\n+\n+  maybe_close_proc_mem_file (pid);\n }\n \n /* Resume execution of the inferior process.  If STEP is nonzero,\n@@ -2025,6 +2029,10 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n     {\n       linux_nat_debug_printf (\"Got exec event from LWP %ld\", lp->ptid.lwp ());\n \n+      /* Close the /proc/<pid>/mem file if it was open for this\n+\t inferior.  */\n+      maybe_close_proc_mem_file (lp->ptid.pid ());\n+\n       ourstatus->kind = TARGET_WAITKIND_EXECD;\n       ourstatus->value.execd_pathname\n \t= xstrdup (linux_proc_pid_to_exec_file (pid));\n@@ -3589,6 +3597,10 @@ linux_nat_target::mourn_inferior ()\n \n   purge_lwp_list (pid);\n \n+  /* Close the /proc/<pid>/mem file if it was open for this\n+     inferior.  */\n+  maybe_close_proc_mem_file (pid);\n+\n   if (! forks_exist_p ())\n     /* Normal case, no other forks available.  */\n     inf_ptrace_target::mourn_inferior ();\n@@ -3681,19 +3693,15 @@ linux_nat_xfer_osdata (enum target_object object,\n \t\t       ULONGEST *xfered_len);\n \n static enum target_xfer_status\n-linux_proc_xfer_partial (enum target_object object,\n-\t\t\t const char *annex, gdb_byte *readbuf,\n-\t\t\t const gdb_byte *writebuf,\n-\t\t\t ULONGEST offset, LONGEST len, ULONGEST *xfered_len);\n+linux_proc_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n+\t\t\t\tULONGEST offset, LONGEST len, ULONGEST *xfered_len);\n \n enum target_xfer_status\n linux_nat_target::xfer_partial (enum target_object object,\n \t\t\t\tconst char *annex, gdb_byte *readbuf,\n \t\t\t\tconst gdb_byte *writebuf,\n \t\t\t\tULONGEST offset, ULONGEST len, ULONGEST *xfered_len)\n {\n-  enum target_xfer_status xfer;\n-\n   if (object == TARGET_OBJECT_SIGNAL_INFO)\n     return linux_xfer_siginfo (object, annex, readbuf, writebuf,\n \t\t\t       offset, len, xfered_len);\n@@ -3712,25 +3720,21 @@ linux_nat_target::xfer_partial (enum target_object object,\n     return linux_nat_xfer_osdata (object, annex, readbuf, writebuf,\n \t\t\t\t  offset, len, xfered_len);\n \n-  /* GDB calculates all addresses in the largest possible address\n-     width.\n-     The address width must be masked before its final use - either by\n-     linux_proc_xfer_partial or inf_ptrace_target::xfer_partial.\n-\n-     Compare ADDR_BIT first to avoid a compiler warning on shift overflow.  */\n-\n   if (object == TARGET_OBJECT_MEMORY)\n     {\n+      /* GDB calculates all addresses in the largest possible address\n+\t width.  The address width must be masked before its final use\n+\t by linux_proc_xfer_partial.\n+\n+\t Compare ADDR_BIT first to avoid a compiler warning on shift overflow.  */\n       int addr_bit = gdbarch_addr_bit (target_gdbarch ());\n \n       if (addr_bit < (sizeof (ULONGEST) * HOST_CHAR_BIT))\n \toffset &= ((ULONGEST) 1 << addr_bit) - 1;\n-    }\n \n-  xfer = linux_proc_xfer_partial (object, annex, readbuf, writebuf,\n-\t\t\t\t  offset, len, xfered_len);\n-  if (xfer != TARGET_XFER_EOF)\n-    return xfer;\n+      return linux_proc_xfer_memory_partial (readbuf, writebuf,\n+\t\t\t\t\t     offset, len, xfered_len);\n+    }\n \n   return inf_ptrace_target::xfer_partial (object, annex, readbuf, writebuf,\n \t\t\t\t\t  offset, len, xfered_len);\n@@ -3794,35 +3798,91 @@ linux_nat_target::pid_to_exec_file (int pid)\n   return linux_proc_pid_to_exec_file (pid);\n }\n \n-/* Implement the to_xfer_partial target method using /proc/<pid>/mem.\n-   Because we can use a single read/write call, this can be much more\n-   efficient than banging away at PTRACE_PEEKTEXT.  */\n+/* Keep the /proc/<pid>/mem file open between memory accesses, as a\n+   cache to avoid constantly closing/opening the file in the common\n+   case of multiple memory reads/writes from/to the same inferior.\n+   Note we don't keep a file open per inferior to avoid keeping too\n+   many file descriptors open, which can run into resource limits.  */\n+static struct\n+{\n+  /* The LWP this open file is for.  Note that after opening the file,\n+     even if the thread subsequently exits, the open file is still\n+     usable for accessing memory.  It's only when the whole process\n+     exits or execs that the file becomes invalid (at which point\n+     reads/writes return EOF).  */\n+  ptid_t ptid;\n \n-static enum target_xfer_status\n-linux_proc_xfer_partial (enum target_object object,\n-\t\t\t const char *annex, gdb_byte *readbuf,\n-\t\t\t const gdb_byte *writebuf,\n-\t\t\t ULONGEST offset, LONGEST len, ULONGEST *xfered_len)\n+  /* The file descriptor.  -1 if file is not open.  */\n+  int fd = -1;\n+\n+  /* Close FD and clear it to -1.  */\n+  void close ()\n+  {\n+    linux_nat_debug_printf (\"closing fd %d for /proc/%d/task/%ld/mem\\n\",\n+\t\t\t    fd, ptid.pid (), ptid.lwp ());\n+    ::close (fd);\n+    fd = -1;\n+  }\n+} last_proc_mem_file;\n+\n+/* Close the /proc/<pid>/mem file if its LWP matches PTID.  */\n+\n+static void\n+maybe_close_proc_mem_file (pid_t pid)\n {\n-  LONGEST ret;\n-  int fd;\n-  char filename[64];\n+  if (last_proc_mem_file.ptid.pid () == pid)\n+    last_proc_mem_file.close ();\n+}\n \n-  if (object != TARGET_OBJECT_MEMORY)\n-    return TARGET_XFER_EOF;\n+/* Helper for linux_proc_xfer_memory_partial.  Accesses /proc via\n+   PTID.  Returns -1 on error, with errno set.  Returns number of\n+   read/written bytes otherwise.  Returns 0 on EOF, which indicates\n+   the address space is gone (because the process exited or\n+   execed).  */\n \n-  /* Don't bother for one word.  */\n-  if (len < 3 * sizeof (long))\n-    return TARGET_XFER_EOF;\n+static ssize_t\n+linux_proc_xfer_memory_partial_pid (ptid_t ptid,\n+\t\t\t\t    gdb_byte *readbuf, const gdb_byte *writebuf,\n+\t\t\t\t    ULONGEST offset, LONGEST len)\n+{\n+  ssize_t ret;\n \n-  /* We could keep this file open and cache it - possibly one per\n-     thread.  That requires some juggling, but is even faster.  */\n-  xsnprintf (filename, sizeof filename, \"/proc/%ld/mem\",\n-\t     inferior_ptid.lwp ());\n-  fd = gdb_open_cloexec (filename, ((readbuf ? O_RDONLY : O_WRONLY)\n-\t\t\t\t    | O_LARGEFILE), 0);\n-  if (fd == -1)\n-    return TARGET_XFER_EOF;\n+  /* As long as we're hitting the same inferior, the previously open\n+     file is good, even if the thread it was open for exits.  */\n+  if (last_proc_mem_file.fd != -1\n+      && last_proc_mem_file.ptid.pid () != ptid.pid ())\n+    last_proc_mem_file.close ();\n+\n+  if (last_proc_mem_file.fd == -1)\n+    {\n+      /* Actually use /proc/<pid>/task/<lwp>/mem instead of\n+\t /proc/<lwp>/mem to avoid PID-reuse races, as we may be trying\n+\t to read memory via a thread which we've already reaped.\n+\t /proc/<lwp>/mem could open a file for the wrong process.  If\n+\t the LWPID is reused for the same process it's OK, we can read\n+\t memory through it just fine.  If the LWPID is reused for a\n+\t different process, then the open will fail because the path\n+\t won't exist.  */\n+      char filename[64];\n+      xsnprintf (filename, sizeof filename,\n+\t\t \"/proc/%d/task/%ld/mem\", ptid.pid (), ptid.lwp ());\n+\n+      last_proc_mem_file.fd\n+\t= gdb_open_cloexec (filename, O_RDWR | O_LARGEFILE, 0);\n+\n+      if (last_proc_mem_file.fd == -1)\n+\t{\n+\t  linux_nat_debug_printf (\"opening %s failed: %s (%d)\\n\",\n+\t\t\t\t  filename, safe_strerror (errno), errno);\n+\t  return -1;\n+\t}\n+      last_proc_mem_file.ptid = ptid;\n+\n+      linux_nat_debug_printf (\"opened fd %d for %s\\n\",\n+\t\t\t      last_proc_mem_file.fd, filename);\n+    }\n+\n+  int fd = last_proc_mem_file.fd;\n \n   /* Use pread64/pwrite64 if available, since they save a syscall and can\n      handle 64-bit offsets even on 32-bit platforms (for instance, SPARC\n@@ -3837,17 +3897,128 @@ linux_proc_xfer_partial (enum target_object object,\n \t   : write (fd, writebuf, len));\n #endif\n \n-  close (fd);\n+  if (ret == -1)\n+    {\n+      linux_nat_debug_printf (\"accessing fd %d for pid %ld failed: %s (%d)\\n\",\n+\t\t\t      fd, ptid.lwp (),\n+\t\t\t      safe_strerror (errno), errno);\n+    }\n+  else if (ret == 0)\n+    {\n+      linux_nat_debug_printf (\"accessing fd %d for pid %ld got EOF\\n\",\n+\t\t\t      fd, ptid.lwp ());\n+    }\n+\n+  return ret;\n+}\n \n-  if (ret == -1 || ret == 0)\n-    return TARGET_XFER_EOF;\n+/* Implement the to_xfer_partial target method using /proc/<pid>/mem.\n+   Because we can use a single read/write call, this can be much more\n+   efficient than banging away at PTRACE_PEEKTEXT.  Also, unlike\n+   PTRACE_PEEKTEXT/PTRACE_POKETEXT, this works with running\n+   threads.  */\n+\n+static enum target_xfer_status\n+linux_proc_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n+\t\t\t\tULONGEST offset, LONGEST len,\n+\t\t\t\tULONGEST *xfered_len)\n+{\n+  /* Unlike PTRACE_PEEKTEXT/PTRACE_POKETEXT, reading/writing from/to\n+     /proc/<pid>/mem works with running threads, and even exited\n+     threads if the file was already open.  If we need to open or\n+     reopen the /proc file though, we may get an EACCES error\n+     (\"Permission denied\"), meaning the thread is gone but its exit\n+     status isn't reaped yet, or ENOENT if the thread is gone and\n+     already reaped.  In that case, just try opening the file for\n+     another thread in the process.  If all threads fail, then it must\n+     mean the whole process exited, in which case there's nothing else\n+     to do and we just fail the memory access.\n+\n+     Note we don't simply always access via the leader thread because\n+     the leader may exit without exiting the whole process.  See\n+     gdb.threads/leader-exit.exp, for example.  */\n+\n+  /* It's frequently the case that the selected thread is stopped, and\n+     is thus not likely to exit (unless something kills the process\n+     outside our control, with e.g., SIGKILL).  Give that one a try\n+     first.\n+\n+     Also, inferior_ptid may actually point at an LWP not in lwp_list.\n+     This happens when we're detaching from a fork child that we don't\n+     want to debug (\"set detach-on-fork on\"), and the breakpoints\n+     module uninstalls breakpoints from the fork child.  Which process\n+     to access is given by inferior_ptid.  */\n+  int res = linux_proc_xfer_memory_partial_pid (inferior_ptid,\n+\t\t\t\t\t\treadbuf, writebuf,\n+\t\t\t\t\t\toffset, len);\n+  if (res == 0)\n+    {\n+      /* EOF means the address space is gone, the whole\n+\t process exited or execed.  */\n+      return TARGET_XFER_EOF;\n+    }\n+  else if (res != -1)\n+    {\n+      *xfered_len = res;\n+      return TARGET_XFER_OK;\n+    }\n   else\n     {\n-      *xfered_len = ret;\n+      /* If we simply raced with the thread exiting (EACCES), or the\n+\t current thread is THREAD_EXITED (ENOENT), try some other\n+\t thread.  It's easier to handle an ENOENT failure than check\n+\t for THREAD_EXIT upfront because this function is called\n+\t before a thread for inferior_ptid is added to the thread\n+\t list.  */\n+      if (errno != EACCES && errno != ENOENT)\n+\treturn TARGET_XFER_EOF;\n+    }\n+\n+  int cur_pid = current_inferior ()->pid;\n+\n+  if (inferior_ptid.pid () != cur_pid)\n+    {\n+      /* We're accessing a fork child, and the access above failed.\n+\t Don't bother iterating the LWP list, since there's no other\n+\t LWP for this process.  */\n+      return TARGET_XFER_EOF;\n+    }\n+\n+  /* Iterate over LWPs of the current inferior, trying to access\n+     memory through one of them.  */\n+  for (lwp_info *lp = lwp_list; lp != nullptr; lp = lp->next)\n+    {\n+      if (lp->ptid.pid () != cur_pid)\n+\tcontinue;\n+\n+      res = linux_proc_xfer_memory_partial_pid (lp->ptid,\n+\t\t\t\t\t\treadbuf, writebuf,\n+\t\t\t\t\t\toffset, len);\n+\n+      if (res == 0)\n+\t{\n+\t  /* EOF means the address space is gone, the whole process\n+\t     exited or execed.  */\n+\t  return TARGET_XFER_EOF;\n+\t}\n+      else if (res == -1)\n+\t{\n+\t  if (errno == EACCES)\n+\t    {\n+\t      /* This LWP is gone, try another one.  */\n+\t      continue;\n+\t    }\n+\n+\t  return TARGET_XFER_EOF;\n+\t}\n+\n+      *xfered_len = res;\n       return TARGET_XFER_OK;\n     }\n-}\n \n+  /* No luck.  */\n+  return TARGET_XFER_EOF;\n+}\n \n /* Parse LINE as a signal set and add its set bits to SIGS.  */\n "
    },
    {
      "sha": "67fa42cbe3b333977967124ed9f4c791097de5d4",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=05c06f318fd9a112529dfc313e6512b399a645e4",
      "patch": "@@ -1,3 +1,12 @@\n+2021-07-01  Pedro Alves  <pedro@palves.net>\n+\n+\tPR mi/15729\n+\tPR gdb/13463\n+\t* gdb.base/access-mem-running.c: New.\n+\t* gdb.base/access-mem-running.exp: New.\n+\t* gdb.threads/access-mem-running-thread-exit.c: New.\n+\t* gdb.threads/access-mem-running-thread-exit.exp: New.\n+\n 2021-06-29  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* gdb.dwarf2/dw2-reg-undefined.exp: Update regexp."
    },
    {
      "sha": "2bb4f9766b547860373d9451b780f4923dd50619",
      "filename": "gdb/testsuite/gdb.base/access-mem-running.c",
      "status": "added",
      "additions": 47,
      "deletions": 0,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/gdb.base/access-mem-running.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/gdb.base/access-mem-running.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/access-mem-running.c?ref=05c06f318fd9a112529dfc313e6512b399a645e4",
      "patch": "@@ -0,0 +1,47 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <unistd.h>\n+\n+static unsigned int global_counter = 1;\n+\n+static volatile unsigned int global_var = 123;\n+\n+static void\n+maybe_stop_here ()\n+{\n+}\n+\n+int\n+main (void)\n+{\n+  global_counter = 1;\n+\n+  while (global_counter > 0)\n+    {\n+      global_counter++;\n+\n+      /* Less than 1s, so the counter increments at least once while\n+\t the .exp sleep 1s, but slow enough that the counter doesn't\n+\t wrap in 1s.  */\n+      usleep (5000);\n+\n+      maybe_stop_here ();\n+    }\n+\n+  return 0;\n+}"
    },
    {
      "sha": "6990d906da2bbe641fbca853d036e790b2a56dfb",
      "filename": "gdb/testsuite/gdb.base/access-mem-running.exp",
      "status": "added",
      "additions": 124,
      "deletions": 0,
      "changes": 124,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/gdb.base/access-mem-running.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/gdb.base/access-mem-running.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/access-mem-running.exp?ref=05c06f318fd9a112529dfc313e6512b399a645e4",
      "patch": "@@ -0,0 +1,124 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test that we can access memory while the inferior is running.\n+\n+standard_testfile\n+\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug}] == -1} {\n+    return -1\n+}\n+\n+# The test proper.  NON_STOP indicates whether we're testing in\n+# non-stop, or all-stop mode.\n+\n+proc test { non_stop } {\n+    global srcfile binfile\n+    global gdb_prompt\n+    global GDBFLAGS\n+    global decimal\n+\n+    save_vars { GDBFLAGS } {\n+      append GDBFLAGS \" -ex \\\"set non-stop $non_stop\\\"\"\n+      clean_restart ${binfile}\n+    }\n+\n+    if ![runto_main] {\n+\treturn -1\n+    }\n+\n+    # If debugging with target remote, check whether the all-stop variant\n+    # of the RSP is being used.  If so, we can't run the background tests.\n+    if {!$non_stop\n+\t&& [target_info exists gdb_protocol]\n+\t&& ([target_info gdb_protocol] == \"remote\"\n+\t    || [target_info gdb_protocol] == \"extended-remote\")} {\n+\n+\tgdb_test_multiple \"maint show target-non-stop\" \"\" {\n+\t    -wrap -re \"(is|currently) on.*\" {\n+\t    }\n+\t    -wrap -re \"(is|currently) off.*\" {\n+\t\tunsupported \"can't issue commands while target is running\"\n+\t\treturn 0\n+\t    }\n+\t}\n+    }\n+\n+    delete_breakpoints\n+\n+    if {$non_stop == \"off\"} {\n+\tset cmd \"continue &\"\n+    } else {\n+\tset cmd \"continue -a &\"\n+    }\n+    gdb_test_multiple $cmd \"continuing\" {\n+\t-re \"Continuing\\.\\r\\n$gdb_prompt \" {\n+\t    pass $gdb_test_name\n+\t}\n+    }\n+\n+    # Check we can read/write variables.\n+\n+    # Check that we can read the counter variable, and that the\n+    # counter is increasing, meaning the process really is running.\n+\n+    sleep 1\n+    set global_counter1 \\\n+\t[get_integer_valueof \"global_counter\" 0 \\\n+\t     \"get global_counter once\"]\n+\n+    sleep 1\n+    set global_counter2 \\\n+\t[get_integer_valueof \"global_counter\" 0 \\\n+\t     \"get global_counter twice\"]\n+\n+    gdb_assert {$global_counter1 != 0 \\\n+\t\t    && $global_counter2 != 0 \\\n+\t\t    && $global_counter1 != $global_counter2} \\\n+\t\"value changed\"\n+\n+    # Check that we can write variables.\n+\n+    gdb_test \"print global_var\" \" = 123\" \\\n+\t\"print global_var before writing\"\n+    gdb_test \"print global_var = 321\" \" = 321\" \\\n+\t\"write to global_var\"\n+    gdb_test \"print global_var\" \" = 321\" \\\n+\t\"print global_var after writing\"\n+    gdb_test \"print global_var = 123\" \" = 123\" \\\n+\t\"write to global_var again\"\n+\n+    # Check we can set a breakpoint while the process is running.  The\n+    # breakpoint should hit immediately.\n+    set any \"\\[^\\r\\n\\]*\"\n+\n+    gdb_test_multiple \"b maybe_stop_here\" \"\" {\n+\t-re \"Breakpoint $decimal at $any: file $any${srcfile}, line $decimal.\\r\\n$gdb_prompt \" {\n+\t    pass $gdb_test_name\n+\t}\n+    }\n+    gdb_test_multiple \"\" \"breakpoint hits\" {\n+\t-re \"Breakpoint $decimal, maybe_stop_here \\\\(\\\\) at $any${srcfile}:$decimal\\r\\n\" {\n+\t    pass \"$gdb_test_name\"\n+\t}\n+    }\n+}\n+\n+foreach non_stop { \"off\" \"on\" } {\n+    set stop_mode [expr ($non_stop==\"off\")?\"all-stop\":\"non-stop\"]\n+    with_test_prefix \"$stop_mode\" {\n+\ttest $non_stop\n+    }\n+}"
    },
    {
      "sha": "5f89d2230655bbbc2f7de79a967efe1b27a0c6c6",
      "filename": "gdb/testsuite/gdb.threads/access-mem-running-thread-exit.c",
      "status": "added",
      "additions": 123,
      "deletions": 0,
      "changes": 123,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.c?ref=05c06f318fd9a112529dfc313e6512b399a645e4",
      "patch": "@@ -0,0 +1,123 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#define _GNU_SOURCE\n+#include <assert.h>\n+#include <pthread.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <string.h>\n+\n+#define THREADS 20\n+\n+static volatile unsigned int global_var = 123;\n+\n+/* Wrapper around pthread_create.   */\n+\n+static void\n+create_thread (pthread_t *child,\n+\t       void *(*start_routine) (void *), void *arg)\n+{\n+  int rc;\n+\n+  while ((rc = pthread_create (child, NULL, start_routine, arg)) != 0)\n+    {\n+      fprintf (stderr, \"unexpected error from pthread_create: %s (%d)\\n\",\n+\t       strerror (rc), rc);\n+      sleep (1);\n+    }\n+}\n+\n+/* Data passed to threads on creation.  This is allocated on the heap\n+   and ownership transferred from parent to child.  */\n+\n+struct thread_arg\n+{\n+  /* The thread's parent.  */\n+  pthread_t parent;\n+\n+  /* Whether to call pthread_join on the parent.  */\n+  int join_parent;\n+};\n+\n+/* Entry point for threads.  */\n+\n+static void *\n+thread_fn (void *arg)\n+{\n+  struct thread_arg *p = arg;\n+\n+  /* Passing no argument makes the thread exit immediately.  */\n+  if (p == NULL)\n+    return NULL;\n+\n+  if (p->join_parent)\n+    assert (pthread_join (p->parent, NULL) == 0);\n+\n+  /* Spawn a number of threads that exit immediately, and then join\n+     them.  The idea is to maximize the time window when we mostly\n+     have threads exiting.  */\n+  {\n+    pthread_t child[THREADS];\n+    int i;\n+\n+    /* Passing no argument makes the thread exit immediately.  */\n+    for (i = 0; i < THREADS; i++)\n+      create_thread (&child[i], thread_fn, NULL);\n+\n+    for (i = 0; i < THREADS; i++)\n+      pthread_join (child[i], NULL);\n+  }\n+\n+  /* Spawn a new thread that joins us, and exit.  The idea here is to\n+     not have any thread that stays around forever.  */\n+  {\n+    pthread_t child;\n+\n+    p->parent = pthread_self ();\n+    p->join_parent = 1;\n+    create_thread (&child, thread_fn, p);\n+  }\n+\n+  return NULL;\n+}\n+\n+int\n+main (void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      struct thread_arg *p;\n+      pthread_t child;\n+\n+      p = malloc (sizeof *p);\n+      p->parent = pthread_self ();\n+      /* Only join the parent once.  */\n+      if (i == 0)\n+\tp->join_parent = 1;\n+      else\n+\tp->join_parent = 0;\n+      create_thread (&child, thread_fn, p);\n+    }\n+\n+  /* Exit the leader to make sure that we can access memory with the\n+     leader gone.  */\n+  pthread_exit (NULL);\n+}"
    },
    {
      "sha": "ea228e4ba13ef191384b5694a990fb769a919f36",
      "filename": "gdb/testsuite/gdb.threads/access-mem-running-thread-exit.exp",
      "status": "added",
      "additions": 166,
      "deletions": 0,
      "changes": 166,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/05c06f318fd9a112529dfc313e6512b399a645e4/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/access-mem-running-thread-exit.exp?ref=05c06f318fd9a112529dfc313e6512b399a645e4",
      "patch": "@@ -0,0 +1,166 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test that we can access memory while all the threads of the inferior\n+# are running, and even if:\n+#\n+# - the leader thread exits\n+# - the selected thread exits\n+#\n+# This test constantly spawns short lived threads to make sure that on\n+# systems with debug APIs that require passing down a specific thread\n+# to work with (e.g., GNU/Linux ptrace and /proc filesystem), GDB\n+# copes with accessing memory just while the thread it is accessing\n+# memory through exits.\n+#\n+# The test spawns two processes and alternates memory accesses between\n+# them to force flushing per-process caches.  At the time of writing,\n+# the Linux backend accesses inferior memory via /proc/<pid>/mem, and\n+# keeps one such file open, as a cache.  Alternating inferiors forces\n+# opening such file for a different process, which fails if GDB tries\n+# to open the file for a thread that exited.  The test does ensures\n+# those reopen/fail code paths are exercised.\n+\n+standard_testfile\n+\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug pthreads}] == -1} {\n+    return -1\n+}\n+\n+# The test proper.  NON_STOP indicates whether we're testing in\n+# non-stop, or all-stop mode.\n+\n+proc test { non_stop } {\n+    global binfile\n+    global gdb_prompt\n+    global GDBFLAGS\n+\n+    save_vars { GDBFLAGS } {\n+      append GDBFLAGS \" -ex \\\"set non-stop $non_stop\\\"\"\n+      clean_restart ${binfile}\n+    }\n+\n+    if ![runto_main] {\n+\tfail \"cannot run to main\"\n+\treturn -1\n+    }\n+\n+    # If debugging with target remote, check whether the all-stop variant\n+    # of the RSP is being used.  If so, we can't run the background tests.\n+    if {!$non_stop\n+\t&& [target_info exists gdb_protocol]\n+\t&& ([target_info gdb_protocol] == \"remote\"\n+\t    || [target_info gdb_protocol] == \"extended-remote\")} {\n+\n+\tgdb_test_multiple \"maint show target-non-stop\" \"\" {\n+\t    -wrap -re \"(is|currently) on.*\" {\n+\t    }\n+\t    -wrap -re \"(is|currently) off.*\" {\n+\t\tunsupported \"can't issue commands while target is running\"\n+\t\treturn 0\n+\t    }\n+\t}\n+    }\n+\n+    delete_breakpoints\n+\n+    # Start the second inferior.\n+    with_test_prefix \"second inferior\" {\n+\tgdb_test \"add-inferior -no-connection\" \"New inferior 2.*\"\n+\tgdb_test \"inferior 2\" \"Switching to inferior 2 .*\"\n+\n+\tgdb_load $binfile\n+\n+\tif ![runto_main] {\n+\t    fail \"cannot run to main\"\n+\t    return -1\n+\t}\n+    }\n+\n+    delete_breakpoints\n+\n+    # These put too much noise in the logs.\n+    gdb_test_no_output \"set print thread-events off\"\n+\n+    # Continue all threads of both processes.\n+    gdb_test_no_output \"set schedule-multiple on\"\n+    if {$non_stop == \"off\"} {\n+\tset cmd \"continue &\"\n+    } else {\n+\tset cmd \"continue -a &\"\n+    }\n+    gdb_test_multiple $cmd \"continuing\" {\n+\t-re \"Continuing\\.\\r\\n$gdb_prompt \" {\n+\t    pass $gdb_test_name\n+\t}\n+    }\n+\n+    # Like gdb_test, but:\n+    # - don't issue a pass on success.\n+    # - on failure, clear the ok variable in the calling context, and\n+    #   break it.\n+    proc my_gdb_test {cmd pattern message} {\n+\tupvar inf inf\n+\tupvar iter iter\n+\tif {[gdb_test_multiple $cmd \"access mem ($message, inf=$inf, iter=$iter)\" {\n+\t    -wrap -re $pattern {\n+\t    }\n+\t}] != 0} {\n+\t    uplevel 1 {set ok 0}\n+\t    return -code break\n+\t}\n+    }\n+\n+    # Hammer away for 5 seconds, alternating between inferiors.\n+    set ::done 0\n+    after 5000 { set ::done 1 }\n+\n+    set inf 1\n+    set ok 1\n+    set iter 0\n+    while {!$::done && $ok} {\n+\tincr iter\n+\tverbose -log \"xxxxx: iteration $iter\"\n+\tgdb_test \"info threads\" \".*\" \"\"\n+\n+\tif {$inf == 1} {\n+\t    set inf 2\n+\t} else {\n+\t    set inf 1\n+\t}\n+\n+\tmy_gdb_test \"inferior $inf\" \".*\" \"inferior $inf\"\n+\n+\tmy_gdb_test \"print global_var = 555\" \" = 555\" \\\n+\t    \"write to global_var\"\n+\tmy_gdb_test \"print global_var\" \" = 555\" \\\n+\t    \"print global_var after writing\"\n+\tmy_gdb_test \"print global_var = 333\" \" = 333\" \\\n+\t    \"write to global_var again\"\n+\tmy_gdb_test \"print global_var\" \" = 333\" \\\n+\t    \"print global_var after writing again\"\n+    }\n+\n+   if {$ok} {\n+       pass \"access mem\"\n+   }\n+}\n+\n+foreach non_stop { \"off\" \"on\" } {\n+    set stop_mode [expr ($non_stop==\"off\")?\"all-stop\":\"non-stop\"]\n+    with_test_prefix \"$stop_mode\" {\n+\ttest $non_stop\n+    }\n+}"
    }
  ]
}