{
  "sha": "d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDdhNzhlNWM0MWM3N2FkMzJkZTY2OGIwYjJmZGU3NGRlZWI4MTkwZA==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-10-12T21:53:16Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2020-10-13T02:18:48Z"
    },
    "message": "Change target_section_table to std::vector alias\n\nBecause target_section_table only holds a vector, and because it is\nused in an \"open\" way, this patch makes it just be an alias for the\nstd::vector specialization.  This makes the code less wordy.  If we do\never want to add more specialized behavior to this type, it's simple\nenough to convert it back to a struct with the few needed methods\nimplied by this change.\n\ngdb/ChangeLog\n2020-10-12  Tom Tromey  <tom@tromey.com>\n\n\t* target.h (struct target_ops) <get_section_table>: Update.\n\t(target_get_section_table): Update.\n\t* target.c (target_get_section_table, target_section_by_addr)\n\t(memory_xfer_partial_1): Update.\n\t* target-section.h (target_section_table): Now an alias.\n\t* target-delegates.c: Rebuild.\n\t* target-debug.h (target_debug_print_target_section_table_p):\n\tRename from target_debug_print_struct_target_section_table_p.\n\t* symfile.c (build_section_addr_info_from_section_table): Update.\n\t* solib.c (solib_map_sections, solib_contains_address_p): Update.\n\t* solib-svr4.c (scan_dyntag): Update.\n\t* solib-dsbt.c (scan_dyntag): Update.\n\t* remote.c (remote_target::remote_xfer_live_readonly_partial):\n\tUpdate.\n\t* record-full.c (record_full_core_target::xfer_partial): Update.\n\t* progspace.h (struct program_space) <target_sections>: Update.\n\t* exec.h (print_section_info): Update.\n\t* exec.c (exec_target::close, build_section_table)\n\t(add_target_sections, add_target_sections_of_objfile)\n\t(remove_target_sections, exec_on_vfork)\n\t(section_table_available_memory)\n\t(section_table_xfer_memory_partial)\n\t(exec_target::get_section_table, exec_target::xfer_partial)\n\t(print_section_info, set_section_command)\n\t(exec_set_section_address, exec_target::has_memory): Update.\n\t* corelow.c (core_target::build_file_mappings)\n\t(core_target::xfer_partial, core_target::info_proc_mappings)\n\t(core_target::info_proc_mappings): Update.\n\t* bfd-target.c (class target_bfd): Update",
    "tree": {
      "sha": "35ed23038ee62fb12689eeae60b5d45ac682eebd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/35ed23038ee62fb12689eeae60b5d45ac682eebd"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "eda214cec17472e7383b8aaf17f6a065b0be4a1e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/eda214cec17472e7383b8aaf17f6a065b0be4a1e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/eda214cec17472e7383b8aaf17f6a065b0be4a1e"
    }
  ],
  "stats": {
    "total": 169,
    "additions": 94,
    "deletions": 75
  },
  "files": [
    {
      "sha": "7dc3590f14632f8aacf8dfac7398f20f9e00d5cf",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 32,
      "deletions": 0,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -1,3 +1,35 @@\n+2020-10-12  Tom Tromey  <tom@tromey.com>\n+\n+\t* target.h (struct target_ops) <get_section_table>: Update.\n+\t(target_get_section_table): Update.\n+\t* target.c (target_get_section_table, target_section_by_addr)\n+\t(memory_xfer_partial_1): Update.\n+\t* target-section.h (target_section_table): Now an alias.\n+\t* target-delegates.c: Rebuild.\n+\t* target-debug.h (target_debug_print_target_section_table_p):\n+\tRename from target_debug_print_struct_target_section_table_p.\n+\t* symfile.c (build_section_addr_info_from_section_table): Update.\n+\t* solib.c (solib_map_sections, solib_contains_address_p): Update.\n+\t* solib-svr4.c (scan_dyntag): Update.\n+\t* solib-dsbt.c (scan_dyntag): Update.\n+\t* remote.c (remote_target::remote_xfer_live_readonly_partial):\n+\tUpdate.\n+\t* record-full.c (record_full_core_target::xfer_partial): Update.\n+\t* progspace.h (struct program_space) <target_sections>: Update.\n+\t* exec.h (print_section_info): Update.\n+\t* exec.c (exec_target::close, build_section_table)\n+\t(add_target_sections, add_target_sections_of_objfile)\n+\t(remove_target_sections, exec_on_vfork)\n+\t(section_table_available_memory)\n+\t(section_table_xfer_memory_partial)\n+\t(exec_target::get_section_table, exec_target::xfer_partial)\n+\t(print_section_info, set_section_command)\n+\t(exec_set_section_address, exec_target::has_memory): Update.\n+\t* corelow.c (core_target::build_file_mappings)\n+\t(core_target::xfer_partial, core_target::info_proc_mappings)\n+\t(core_target::info_proc_mappings): Update.\n+\t* bfd-target.c (class target_bfd): Update\n+\n 2020-10-12  Tom Tromey  <tom@tromey.com>\n \n \t* progspace.c (program_space::~program_space): Don't call"
    },
    {
      "sha": "bf4a98594bd88fc439b58332fc7903cafbfd6a8f",
      "filename": "gdb/bfd-target.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/bfd-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/bfd-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bfd-target.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -59,7 +59,7 @@ class target_bfd : public target_ops\n   /* The section table build from the ALLOC sections in BFD.  Note\n      that we can't rely on extracting the BFD from a random section in\n      the table, since the table can be legitimately empty.  */\n-  struct target_section_table m_table;\n+  target_section_table m_table;\n };\n \n target_xfer_status"
    },
    {
      "sha": "d557475e06f0fe9a77a9f46028045cfa8e493eb0",
      "filename": "gdb/corelow.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/corelow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/corelow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/corelow.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -266,8 +266,8 @@ core_target::build_file_mappings ()\n \tbfd_set_section_alignment (sec, 2);\n \n \t/* Set target_section fields.  */\n-\tm_core_file_mappings.sections.emplace_back ();\n-\ttarget_section &ts = m_core_file_mappings.sections.back ();\n+\tm_core_file_mappings.emplace_back ();\n+\ttarget_section &ts = m_core_file_mappings.back ();\n \tts.addr = start;\n \tts.endaddr = end;\n \tts.owner = nullptr;\n@@ -814,7 +814,7 @@ core_target::xfer_partial (enum target_object object, const char *annex,\n \t   or the like) as this should provide a more accurate\n \t   result.  If not, check the stratum beneath us, which should\n \t   be the file stratum.  */\n-\tif (!m_core_file_mappings.sections.empty ())\n+\tif (!m_core_file_mappings.empty ())\n \t  xfer_status = xfer_memory_via_mappings (readbuf, writebuf, offset,\n \t\t\t\t\t\t  len, xfered_len);\n \telse\n@@ -1098,7 +1098,7 @@ get_current_core_target ()\n void\n core_target::info_proc_mappings (struct gdbarch *gdbarch)\n {\n-  if (!m_core_file_mappings.sections.empty ())\n+  if (!m_core_file_mappings.empty ())\n     {\n       printf_filtered (_(\"Mapped address spaces:\\n\\n\"));\n       if (gdbarch_addr_bit (gdbarch) == 32)\n@@ -1117,7 +1117,7 @@ core_target::info_proc_mappings (struct gdbarch *gdbarch)\n \t}\n     }\n \n-  for (const target_section &tsp : m_core_file_mappings.sections)\n+  for (const target_section &tsp : m_core_file_mappings)\n     {\n       ULONGEST start = tsp.addr;\n       ULONGEST end = tsp.endaddr;"
    },
    {
      "sha": "dd322129139bf15226195efe6f0380690cf805be",
      "filename": "gdb/exec.c",
      "status": "modified",
      "additions": 29,
      "deletions": 34,
      "changes": 63,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/exec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/exec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -75,7 +75,7 @@ struct exec_target final : public target_ops\n \t\t\t\t\tconst gdb_byte *writebuf,\n \t\t\t\t\tULONGEST offset, ULONGEST len,\n \t\t\t\t\tULONGEST *xfered_len) override;\n-  struct target_section_table *get_section_table () override;\n+  target_section_table *get_section_table () override;\n   void files_info () override;\n \n   bool has_memory () override;\n@@ -183,7 +183,7 @@ exec_target::close ()\n   for (struct program_space *ss : program_spaces)\n     {\n       set_current_program_space (ss);\n-      current_target_sections->sections.clear ();\n+      current_target_sections->clear ();\n       exec_close ();\n     }\n }\n@@ -598,8 +598,8 @@ build_section_table (struct bfd *some_bfd)\n       if (!(aflag & SEC_ALLOC))\n \tcontinue;\n \n-      table.sections.emplace_back ();\n-      target_section &sect = table.sections.back ();\n+      table.emplace_back ();\n+      target_section &sect = table.back ();\n       sect.owner = NULL;\n       sect.the_bfd_section = asect;\n       sect.addr = bfd_section_vma (asect);\n@@ -616,14 +616,14 @@ void\n add_target_sections (void *owner,\n \t\t     const target_section_table &sections)\n {\n-  struct target_section_table *table = current_target_sections;\n+  target_section_table *table = current_target_sections;\n \n-  if (!sections.sections.empty ())\n+  if (!sections.empty ())\n     {\n-      for (const target_section &s : sections.sections)\n+      for (const target_section &s : sections)\n \t{\n-\t  table->sections.push_back (s);\n-\t  table->sections.back ().owner = owner;\n+\t  table->push_back (s);\n+\t  table->back ().owner = owner;\n \t}\n \n       scoped_restore_current_pspace_and_thread restore_pspace_thread;\n@@ -651,7 +651,7 @@ add_target_sections (void *owner,\n void\n add_target_sections_of_objfile (struct objfile *objfile)\n {\n-  struct target_section_table *table = current_target_sections;\n+  target_section_table *table = current_target_sections;\n   struct obj_section *osect;\n \n   gdb_assert (objfile != nullptr);\n@@ -662,8 +662,8 @@ add_target_sections_of_objfile (struct objfile *objfile)\n       if (bfd_section_size (osect->the_bfd_section) == 0)\n \tcontinue;\n \n-      table->sections.emplace_back ();\n-      target_section &ts = table->sections.back ();\n+      table->emplace_back ();\n+      target_section &ts = table->back ();\n       ts.addr = obj_section_addr (osect);\n       ts.endaddr = obj_section_endaddr (osect);\n       ts.the_bfd_section = osect->the_bfd_section;\n@@ -677,22 +677,22 @@ add_target_sections_of_objfile (struct objfile *objfile)\n void\n remove_target_sections (void *owner)\n {\n-  struct target_section_table *table = current_target_sections;\n+  target_section_table *table = current_target_sections;\n \n   gdb_assert (owner != NULL);\n \n-  auto it = std::remove_if (table->sections.begin (),\n-\t\t\t    table->sections.end (),\n+  auto it = std::remove_if (table->begin (),\n+\t\t\t    table->end (),\n \t\t\t    [&] (target_section &sect)\n \t\t\t    {\n \t\t\t      return sect.owner == owner;\n \t\t\t    });\n-  table->sections.erase (it, table->sections.end ());\n+  table->erase (it, table->end ());\n \n   /* If we don't have any more sections to read memory from,\n      remove the file_stratum target from the stack of each\n      inferior sharing the program space.  */\n-  if (table->sections.empty ())\n+  if (table->empty ())\n     {\n       scoped_restore_current_pspace_and_thread restore_pspace_thread;\n       program_space *curr_pspace = current_program_space;\n@@ -702,7 +702,7 @@ remove_target_sections (void *owner)\n \t  if (inf->pspace != curr_pspace)\n \t    continue;\n \n-\t  if (!inf->pspace->target_sections.sections.empty ())\n+\t  if (!inf->pspace->target_sections.empty ())\n \t    continue;\n \n \t  switch_to_inferior_no_thread (inf);\n@@ -716,7 +716,7 @@ remove_target_sections (void *owner)\n void\n exec_on_vfork ()\n {\n-  if (!current_program_space->target_sections.sections.empty ())\n+  if (!current_program_space->target_sections.empty ())\n     push_target (&exec_ops);\n }\n \n@@ -779,7 +779,7 @@ section_table_available_memory (CORE_ADDR memaddr, ULONGEST len,\n {\n   std::vector<mem_range> memory;\n \n-  for (const target_section &p : sections.sections)\n+  for (const target_section &p : sections)\n     {\n       if ((bfd_section_flags (p.the_bfd_section) & SEC_READONLY) == 0)\n \tcontinue;\n@@ -858,7 +858,7 @@ section_table_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n \n   gdb_assert (len != 0);\n \n-  for (const target_section &p : sections.sections)\n+  for (const target_section &p : sections)\n     {\n       struct bfd_section *asect = p.the_bfd_section;\n       bfd *abfd = asect->owner;\n@@ -918,7 +918,7 @@ section_table_xfer_memory_partial (gdb_byte *readbuf, const gdb_byte *writebuf,\n   return TARGET_XFER_EOF;\t\t/* We can't help.  */\n }\n \n-struct target_section_table *\n+target_section_table *\n exec_target::get_section_table ()\n {\n   return current_target_sections;\n@@ -930,7 +930,7 @@ exec_target::xfer_partial (enum target_object object,\n \t\t\t   const gdb_byte *writebuf,\n \t\t\t   ULONGEST offset, ULONGEST len, ULONGEST *xfered_len)\n {\n-  struct target_section_table *table = get_section_table ();\n+  target_section_table *table = get_section_table ();\n \n   if (object == TARGET_OBJECT_MEMORY)\n     return section_table_xfer_memory_partial (readbuf, writebuf,\n@@ -942,7 +942,7 @@ exec_target::xfer_partial (enum target_object object,\n \f\n \n void\n-print_section_info (struct target_section_table *t, bfd *abfd)\n+print_section_info (target_section_table *t, bfd *abfd)\n {\n   struct gdbarch *gdbarch = gdbarch_from_bfd (abfd);\n   /* FIXME: 16 is not wide enough when gdbarch_addr_bit > 64.  */\n@@ -961,7 +961,7 @@ print_section_info (struct target_section_table *t, bfd *abfd)\n       bfd_vma entry_point;\n       bool found = false;\n \n-      for (const target_section &p : t->sections)\n+      for (const target_section &p : *t)\n \t{\n \t  struct bfd_section *psect = p.the_bfd_section;\n \n@@ -989,7 +989,7 @@ print_section_info (struct target_section_table *t, bfd *abfd)\n       printf_filtered (_(\"\\tEntry point: %s\\n\"),\n \t\t       paddress (gdbarch, entry_point));\n     }\n-  for (const target_section &p : t->sections)\n+  for (const target_section &p : *t)\n     {\n       struct bfd_section *psect = p.the_bfd_section;\n       bfd *pbfd = psect->owner;\n@@ -1032,7 +1032,6 @@ set_section_command (const char *args, int from_tty)\n   unsigned long secaddr;\n   char secprint[100];\n   long offset;\n-  struct target_section_table *table;\n \n   if (args == 0)\n     error (_(\"Must specify section name and its virtual address\"));\n@@ -1044,8 +1043,7 @@ set_section_command (const char *args, int from_tty)\n   /* Parse out new virtual address.  */\n   secaddr = parse_and_eval_address (args);\n \n-  table = current_target_sections;\n-  for (target_section &p : table->sections)\n+  for (target_section &p : *current_target_sections)\n     {\n       if (!strncmp (secname, bfd_section_name (p.the_bfd_section), seclen)\n \t  && bfd_section_name (p.the_bfd_section)[seclen] == '\\0')\n@@ -1071,10 +1069,7 @@ set_section_command (const char *args, int from_tty)\n void\n exec_set_section_address (const char *filename, int index, CORE_ADDR address)\n {\n-  struct target_section_table *table;\n-\n-  table = current_target_sections;\n-  for (target_section &p : table->sections)\n+  for (target_section &p : *current_target_sections)\n     {\n       if (filename_cmp (filename,\n \t\t\tbfd_get_filename (p.the_bfd_section->owner)) == 0\n@@ -1091,7 +1086,7 @@ exec_target::has_memory ()\n {\n   /* We can provide memory if we have any file/target sections to read\n      from.  */\n-  return !current_target_sections->sections.empty ();\n+  return !current_target_sections->empty ();\n }\n \n char *"
    },
    {
      "sha": "24489654ddc87ef3e238994311234ad7fc17e230",
      "filename": "gdb/exec.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/exec.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/exec.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/exec.h?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -115,7 +115,7 @@ extern void add_target_sections_of_objfile (struct objfile *objfile);\n    special cased --- it's filename is omitted; if it is the executable\n    file, its entry point is printed.  */\n \n-extern void print_section_info (struct target_section_table *table,\n+extern void print_section_info (target_section_table *table,\n \t\t\t\tbfd *abfd);\n \n extern void exec_close (void);"
    },
    {
      "sha": "6a0e90363995e8c950b0acf6eece9cbea99cba0d",
      "filename": "gdb/progspace.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/progspace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/progspace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/progspace.h?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -325,7 +325,7 @@ struct program_space\n \n   /* The set of target sections matching the sections mapped into\n      this program space.  Managed by both exec_ops and solib.c.  */\n-  struct target_section_table target_sections {};\n+  target_section_table target_sections;\n \n   /* List of shared objects mapped into this space.  Managed by\n      solib.c.  */"
    },
    {
      "sha": "b5447e5a9a6849b8896fcd3454760688271929c0",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -2138,7 +2138,7 @@ record_full_core_target::xfer_partial (enum target_object object,\n     {\n       if (record_full_gdb_operation_disable || !writebuf)\n \t{\n-\t  for (target_section &p : record_full_core_sections.sections)\n+\t  for (target_section &p : record_full_core_sections)\n \t    {\n \t      if (offset >= p.addr)\n \t\t{"
    },
    {
      "sha": "9ee1e8cbcf9e9e1b9e3025d0ed94c23d06f4a2c6",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -8890,17 +8890,15 @@ remote_target::remote_xfer_live_readonly_partial (gdb_byte *readbuf,\n \t\t\t\t\t\t  ULONGEST *xfered_len)\n {\n   struct target_section *secp;\n-  struct target_section_table *table;\n \n   secp = target_section_by_addr (this, memaddr);\n   if (secp != NULL\n       && (bfd_section_flags (secp->the_bfd_section) & SEC_READONLY))\n     {\n       ULONGEST memend = memaddr + len;\n \n-      table = target_get_section_table (this);\n-\n-      for (target_section &p : table->sections)\n+      target_section_table *table = target_get_section_table (this);\n+      for (target_section &p : *table)\n \t{\n \t  if (memaddr >= p.addr)\n \t    {"
    },
    {
      "sha": "57c7ab18430daf6265b862a0ab2a9c1f1335864c",
      "filename": "gdb/solib-dsbt.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/solib-dsbt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/solib-dsbt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-dsbt.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -424,7 +424,7 @@ scan_dyntag (int dyntag, bfd *abfd, CORE_ADDR *ptr)\n     return 0;\n \n   bool found = false;\n-  for (target_section &target_section : current_target_sections->sections)\n+  for (target_section &target_section : *current_target_sections)\n     if (sect == target_section.the_bfd_section)\n       {\n \tdyn_addr = target_section.addr;"
    },
    {
      "sha": "a780f8d34678e5e59ed77d9702062e572626b3e8",
      "filename": "gdb/solib-svr4.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/solib-svr4.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/solib-svr4.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-svr4.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -608,7 +608,7 @@ scan_dyntag (const int desired_dyntag, bfd *abfd, CORE_ADDR *ptr,\n     return 0;\n \n   bool found = false;\n-  for (target_section &target_section : current_target_sections->sections)\n+  for (target_section &target_section : *current_target_sections)\n     if (sect == target_section.the_bfd_section)\n       {\n \tdyn_addr = target_section.addr;"
    },
    {
      "sha": "b4864429e9aa22f604de75530a575334aaa9017c",
      "filename": "gdb/solib.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/solib.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/solib.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -556,7 +556,7 @@ solib_map_sections (struct so_list *so)\n     so->sections = new target_section_table;\n   *so->sections = build_section_table (so->abfd);\n \n-  for (target_section &p : so->sections->sections)\n+  for (target_section &p : *so->sections)\n     {\n       /* Relocate the section binding addresses as recorded in the shared\n          object's file by the base address to which the object was actually\n@@ -1113,7 +1113,7 @@ bool\n solib_contains_address_p (const struct so_list *const solib,\n \t\t\t  CORE_ADDR address)\n {\n-  for (target_section &p : solib->sections->sections)\n+  for (target_section &p : *solib->sections)\n     if (p.addr <= address && address < p.endaddr)\n       return true;\n "
    },
    {
      "sha": "3332e7f69ff8152371a401c8fb351940b308a52e",
      "filename": "gdb/symfile.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/symfile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/symfile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/symfile.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -216,13 +216,13 @@ build_section_addr_info_from_section_table (const target_section_table &table)\n {\n   section_addr_info sap;\n \n-  for (const target_section &stp : table.sections)\n+  for (const target_section &stp : table)\n     {\n       struct bfd_section *asect = stp.the_bfd_section;\n       bfd *abfd = asect->owner;\n \n       if (bfd_section_flags (asect) & (SEC_ALLOC | SEC_LOAD)\n-\t  && sap.size () < table.sections.size ())\n+\t  && sap.size () < table.size ())\n \tsap.emplace_back (stp.addr,\n \t\t\t  bfd_section_name (asect),\n \t\t\t  gdb_bfd_section_index (abfd, asect));"
    },
    {
      "sha": "65a14c41787432e6ece93c5c1b96cef1b064a043",
      "filename": "gdb/target-debug.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target-debug.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target-debug.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-debug.h?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -106,7 +106,7 @@\n   target_debug_do_print (host_address_to_string (X))\n #define target_debug_print_struct_ui_file_p(X)\t\\\n   target_debug_do_print (host_address_to_string (X))\n-#define target_debug_print_struct_target_section_table_p(X)\t\\\n+#define target_debug_print_target_section_table_p(X)\t\\\n   target_debug_do_print (host_address_to_string (X))\n #define target_debug_print_async_callback_ftype_p(X) \\\n   target_debug_do_print (host_address_to_string (X))"
    },
    {
      "sha": "e9c349fb7ba0677559f3a0b4d6d7b2c17132491c",
      "filename": "gdb/target-delegates.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target-delegates.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target-delegates.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-delegates.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -77,7 +77,7 @@ struct dummy_target : public target_ops\n   void rcmd (const char *arg0, struct ui_file *arg1) override;\n   char *pid_to_exec_file (int arg0) override;\n   void log_command (const char *arg0) override;\n-  struct target_section_table *get_section_table () override;\n+  target_section_table *get_section_table () override;\n   thread_control_capabilities get_thread_control_capabilities () override;\n   bool attach_no_wait () override;\n   bool can_async_p () override;\n@@ -248,7 +248,7 @@ struct debug_target : public target_ops\n   void rcmd (const char *arg0, struct ui_file *arg1) override;\n   char *pid_to_exec_file (int arg0) override;\n   void log_command (const char *arg0) override;\n-  struct target_section_table *get_section_table () override;\n+  target_section_table *get_section_table () override;\n   thread_control_capabilities get_thread_control_capabilities () override;\n   bool attach_no_wait () override;\n   bool can_async_p () override;\n@@ -2021,27 +2021,27 @@ debug_target::log_command (const char *arg0)\n   fputs_unfiltered (\")\\n\", gdb_stdlog);\n }\n \n-struct target_section_table *\n+target_section_table *\n target_ops::get_section_table ()\n {\n   return this->beneath ()->get_section_table ();\n }\n \n-struct target_section_table *\n+target_section_table *\n dummy_target::get_section_table ()\n {\n   return NULL;\n }\n \n-struct target_section_table *\n+target_section_table *\n debug_target::get_section_table ()\n {\n-  struct target_section_table * result;\n+  target_section_table * result;\n   fprintf_unfiltered (gdb_stdlog, \"-> %s->get_section_table (...)\\n\", this->beneath ()->shortname ());\n   result = this->beneath ()->get_section_table ();\n   fprintf_unfiltered (gdb_stdlog, \"<- %s->get_section_table (\", this->beneath ()->shortname ());\n   fputs_unfiltered (\") = \", gdb_stdlog);\n-  target_debug_print_struct_target_section_table_p (result);\n+  target_debug_print_target_section_table_p (result);\n   fputs_unfiltered (\"\\n\", gdb_stdlog);\n   return result;\n }"
    },
    {
      "sha": "ec6932da0a6b02b185abec1035b1fe717ffdc1d4",
      "filename": "gdb/target-section.h",
      "status": "modified",
      "additions": 1,
      "deletions": 4,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target-section.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target-section.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-section.h?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -44,9 +44,6 @@ struct target_section\n \n /* Holds an array of target sections.  */\n \n-struct target_section_table\n-{\n-  std::vector<struct target_section> sections;\n-};\n+using target_section_table = std::vector<target_section>;\n \n #endif /* GDB_TARGET_SECTION_H */"
    },
    {
      "sha": "531858a3333f621bb108363424ac6fc91ea82399",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 5,
      "deletions": 7,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -812,7 +812,7 @@ target_read_string (CORE_ADDR memaddr, int len, int *bytes_read)\n   return gdb::unique_xmalloc_ptr<char> ((char *) buffer.release ());\n }\n \n-struct target_section_table *\n+target_section_table *\n target_get_section_table (struct target_ops *target)\n {\n   return target->get_section_table ();\n@@ -823,12 +823,12 @@ target_get_section_table (struct target_ops *target)\n struct target_section *\n target_section_by_addr (struct target_ops *target, CORE_ADDR addr)\n {\n-  struct target_section_table *table = target_get_section_table (target);\n+  target_section_table *table = target_get_section_table (target);\n \n   if (table == NULL)\n     return NULL;\n \n-  for (target_section &secp : table->sections)\n+  for (target_section &secp : *table)\n     {\n       if (addr >= secp.addr && addr < secp.endaddr)\n \treturn &secp;\n@@ -965,8 +965,7 @@ memory_xfer_partial_1 (struct target_ops *ops, enum target_object object,\n \n       if (pc_in_unmapped_range (memaddr, section))\n \t{\n-\t  struct target_section_table *table\n-\t    = target_get_section_table (ops);\n+\t  target_section_table *table = target_get_section_table (ops);\n \t  const char *section_name = section->the_bfd_section->name;\n \n \t  memaddr = overlay_mapped_address (memaddr, section);\n@@ -986,13 +985,12 @@ memory_xfer_partial_1 (struct target_ops *ops, enum target_object object,\n   if (readbuf != NULL && trust_readonly)\n     {\n       struct target_section *secp;\n-      struct target_section_table *table;\n \n       secp = target_section_by_addr (ops, memaddr);\n       if (secp != NULL\n \t  && (bfd_section_flags (secp->the_bfd_section) & SEC_READONLY))\n \t{\n-\t  table = target_get_section_table (ops);\n+\t  target_section_table *table = target_get_section_table (ops);\n \t  return section_table_xfer_memory_partial (readbuf, writebuf,\n \t\t\t\t\t\t    memaddr, len, xfered_len,\n \t\t\t\t\t\t    *table);"
    },
    {
      "sha": "7e152fa6e151eee183b5c5550f507a09c7596926",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d7a78e5c41c77ad32de668b0b2fde74deeb8190d/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=d7a78e5c41c77ad32de668b0b2fde74deeb8190d",
      "patch": "@@ -29,7 +29,6 @@ struct target_ops;\n struct bp_location;\n struct bp_target_info;\n struct regcache;\n-struct target_section_table;\n struct trace_state_variable;\n struct trace_status;\n struct uploaded_tsv;\n@@ -681,7 +680,7 @@ struct target_ops\n       TARGET_DEFAULT_RETURN (NULL);\n     virtual void log_command (const char *)\n       TARGET_DEFAULT_IGNORE ();\n-    virtual struct target_section_table *get_section_table ()\n+    virtual target_section_table *get_section_table ()\n       TARGET_DEFAULT_RETURN (NULL);\n \n     /* Provide default values for all \"must have\" methods.  */\n@@ -2413,7 +2412,7 @@ struct target_section *target_section_by_addr (struct target_ops *target,\n /* Return the target section table this target (or the targets\n    beneath) currently manipulate.  */\n \n-extern struct target_section_table *target_get_section_table\n+extern target_section_table *target_get_section_table\n   (struct target_ops *target);\n \n /* From mem-break.c */"
    }
  ]
}