{
  "sha": "cd9a314824b2b87207a8ba7a8003639989d2406b",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2Q5YTMxNDgyNGIyYjg3MjA3YThiYTdhODAwMzYzOTk4OWQyNDA2Yg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:32Z"
    },
    "message": "Split out some Ada type resolution code\n\nThis splits some Ada type resolution code out of resolve_subexp into\nnew functions that can be reused.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* ada-lang.h (ada_find_operator_symbol, ada_resolve_funcall)\n\t(ada_resolve_variable): Declare.\n\t* ada-lang.c (ada_find_operator_symbol, ada_resolve_funcall)\n\t(ada_resolve_variable): New functions.\n\t(resolve_subexp): Update.",
    "tree": {
      "sha": "8cf783cf73fec36e1d9fb62bca1c9c51395df36a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/8cf783cf73fec36e1d9fb62bca1c9c51395df36a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cd9a314824b2b87207a8ba7a8003639989d2406b",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cd9a314824b2b87207a8ba7a8003639989d2406b",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cd9a314824b2b87207a8ba7a8003639989d2406b",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cd9a314824b2b87207a8ba7a8003639989d2406b/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "cf12b17fd05811e08235fd4aaca5306bd78c7527",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cf12b17fd05811e08235fd4aaca5306bd78c7527",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/cf12b17fd05811e08235fd4aaca5306bd78c7527"
    }
  ],
  "stats": {
    "total": 289,
    "additions": 190,
    "deletions": 99
  },
  "files": [
    {
      "sha": "af13b9af5584c7344c4daa111058ce86301820e1",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd9a314824b2b87207a8ba7a8003639989d2406b/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd9a314824b2b87207a8ba7a8003639989d2406b/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=cd9a314824b2b87207a8ba7a8003639989d2406b",
      "patch": "@@ -1,3 +1,11 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* ada-lang.h (ada_find_operator_symbol, ada_resolve_funcall)\n+\t(ada_resolve_variable): Declare.\n+\t* ada-lang.c (ada_find_operator_symbol, ada_resolve_funcall)\n+\t(ada_resolve_variable): New functions.\n+\t(resolve_subexp): Update.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* opencl-lang.c (opencl_ternop_cond_operation::evaluate): New"
    },
    {
      "sha": "098a5a6858f71cb99a9c3caa3dc237ccf6da436b",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 144,
      "deletions": 99,
      "changes": 243,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd9a314824b2b87207a8ba7a8003639989d2406b/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd9a314824b2b87207a8ba7a8003639989d2406b/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=cd9a314824b2b87207a8ba7a8003639989d2406b",
      "patch": "@@ -3414,6 +3414,126 @@ See set/show multiple-symbol.\"));\n   return n_chosen;\n }\n \n+/* See ada-lang.h.  */\n+\n+block_symbol\n+ada_find_operator_symbol (enum exp_opcode op, int parse_completion,\n+\t\t\t  int nargs, value *argvec[])\n+{\n+  if (possible_user_operator_p (op, argvec))\n+    {\n+      std::vector<struct block_symbol> candidates\n+\t= ada_lookup_symbol_list (ada_decoded_op_name (op),\n+\t\t\t\t  NULL, VAR_DOMAIN);\n+\n+      int i = ada_resolve_function (candidates, argvec,\n+\t\t\t\t    nargs, ada_decoded_op_name (op), NULL,\n+\t\t\t\t    parse_completion);\n+      if (i >= 0)\n+\treturn candidates[i];\n+    }\n+  return {};\n+}\n+\n+/* See ada-lang.h.  */\n+\n+block_symbol\n+ada_resolve_funcall (struct symbol *sym, const struct block *block,\n+\t\t     struct type *context_type,\n+\t\t     int parse_completion,\n+\t\t     int nargs, value *argvec[],\n+\t\t     innermost_block_tracker *tracker)\n+{\n+  std::vector<struct block_symbol> candidates\n+    = ada_lookup_symbol_list (sym->linkage_name (), block, VAR_DOMAIN);\n+\n+  int i;\n+  if (candidates.size () == 1)\n+    i = 0;\n+  else\n+    {\n+      i = ada_resolve_function\n+\t(candidates,\n+\t argvec, nargs,\n+\t sym->linkage_name (),\n+\t context_type, parse_completion);\n+      if (i < 0)\n+\terror (_(\"Could not find a match for %s\"), sym->print_name ());\n+    }\n+\n+  tracker->update (candidates[i]);\n+  return candidates[i];\n+}\n+\n+/* See ada-lang.h.  */\n+\n+block_symbol\n+ada_resolve_variable (struct symbol *sym, const struct block *block,\n+\t\t      struct type *context_type,\n+\t\t      int parse_completion,\n+\t\t      int deprocedure_p,\n+\t\t      innermost_block_tracker *tracker)\n+{\n+  std::vector<struct block_symbol> candidates\n+    = ada_lookup_symbol_list (sym->linkage_name (), block, VAR_DOMAIN);\n+\n+  if (std::any_of (candidates.begin (),\n+\t\t   candidates.end (),\n+\t\t   [] (block_symbol &bsym)\n+\t\t   {\n+\t\t     switch (SYMBOL_CLASS (bsym.symbol))\n+\t\t       {\n+\t\t       case LOC_REGISTER:\n+\t\t       case LOC_ARG:\n+\t\t       case LOC_REF_ARG:\n+\t\t       case LOC_REGPARM_ADDR:\n+\t\t       case LOC_LOCAL:\n+\t\t       case LOC_COMPUTED:\n+\t\t\t return true;\n+\t\t       default:\n+\t\t\t return false;\n+\t\t       }\n+\t\t   }))\n+    {\n+      /* Types tend to get re-introduced locally, so if there\n+\t are any local symbols that are not types, first filter\n+\t out all types.  */\n+      candidates.erase\n+\t(std::remove_if\n+\t (candidates.begin (),\n+\t  candidates.end (),\n+\t  [] (block_symbol &bsym)\n+\t  {\n+\t    return SYMBOL_CLASS (bsym.symbol) == LOC_TYPEDEF;\n+\t  }),\n+\t candidates.end ());\n+    }\n+\n+  int i;\n+  if (candidates.empty ())\n+    error (_(\"No definition found for %s\"), sym->print_name ());\n+  else if (candidates.size () == 1)\n+    i = 0;\n+  else if (deprocedure_p && !is_nonfunction (candidates))\n+    {\n+      i = ada_resolve_function\n+\t(candidates, NULL, 0,\n+\t sym->linkage_name (),\n+\t context_type, parse_completion);\n+      if (i < 0)\n+\terror (_(\"Could not find a match for %s\"), sym->print_name ());\n+    }\n+  else\n+    {\n+      printf_filtered (_(\"Multiple matches for %s\\n\"), sym->print_name ());\n+      user_select_syms (candidates.data (), candidates.size (), 1);\n+      i = 0;\n+    }\n+\n+  tracker->update (candidates[i]);\n+  return candidates[i];\n+}\n+\n /* Resolve the operator of the subexpression beginning at\n    position *POS of *EXPP.  \"Resolving\" consists of replacing\n    the symbols that have undefined namespaces in OP_VAR_VALUE nodes\n@@ -3618,68 +3738,13 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n     case OP_VAR_VALUE:\n       if (SYMBOL_DOMAIN (exp->elts[pc + 2].symbol) == UNDEF_DOMAIN)\n \t{\n-\t  std::vector<struct block_symbol> candidates\n-\t    = ada_lookup_symbol_list (exp->elts[pc + 2].symbol->linkage_name (),\n-\t\t\t\t      exp->elts[pc + 1].block, VAR_DOMAIN);\n-\n-\t  if (std::any_of (candidates.begin (),\n-\t\t\t   candidates.end (),\n-\t\t\t   [] (block_symbol &sym)\n-\t\t\t   {\n-\t\t\t     switch (SYMBOL_CLASS (sym.symbol))\n-\t\t\t       {\n-\t\t\t       case LOC_REGISTER:\n-\t\t\t       case LOC_ARG:\n-\t\t\t       case LOC_REF_ARG:\n-\t\t\t       case LOC_REGPARM_ADDR:\n-\t\t\t       case LOC_LOCAL:\n-\t\t\t       case LOC_COMPUTED:\n-\t\t\t\t return true;\n-\t\t\t       default:\n-\t\t\t\t return false;\n-\t\t\t       }\n-\t\t\t   }))\n-\t    {\n-\t      /* Types tend to get re-introduced locally, so if there\n-\t\t are any local symbols that are not types, first filter\n-\t\t out all types.  */\n-\t      candidates.erase\n-\t\t(std::remove_if\n-\t\t (candidates.begin (),\n-\t\t  candidates.end (),\n-\t\t  [] (block_symbol &sym)\n-\t\t  {\n-\t\t    return SYMBOL_CLASS (sym.symbol) == LOC_TYPEDEF;\n-\t\t  }),\n-\t\t candidates.end ());\n-\t    }\n-\n-\t  if (candidates.empty ())\n-\t    error (_(\"No definition found for %s\"),\n-\t\t   exp->elts[pc + 2].symbol->print_name ());\n-\t  else if (candidates.size () == 1)\n-\t    i = 0;\n-\t  else if (deprocedure_p && !is_nonfunction (candidates))\n-\t    {\n-\t      i = ada_resolve_function\n-\t\t(candidates, NULL, 0,\n-\t\t exp->elts[pc + 2].symbol->linkage_name (),\n-\t\t context_type, parse_completion);\n-\t      if (i < 0)\n-\t\terror (_(\"Could not find a match for %s\"),\n-\t\t       exp->elts[pc + 2].symbol->print_name ());\n-\t    }\n-\t  else\n-\t    {\n-\t      printf_filtered (_(\"Multiple matches for %s\\n\"),\n-\t\t\t       exp->elts[pc + 2].symbol->print_name ());\n-\t      user_select_syms (candidates.data (), candidates.size (), 1);\n-\t      i = 0;\n-\t    }\n-\n-\t  exp->elts[pc + 1].block = candidates[i].block;\n-\t  exp->elts[pc + 2].symbol = candidates[i].symbol;\n-\t  tracker->update (candidates[i]);\n+\t  block_symbol resolved\n+\t    = ada_resolve_variable (exp->elts[pc + 2].symbol,\n+\t\t\t\t    exp->elts[pc + 1].block,\n+\t\t\t\t    context_type, parse_completion,\n+\t\t\t\t    deprocedure_p, tracker);\n+\t  exp->elts[pc + 1].block = resolved.block;\n+\t  exp->elts[pc + 2].symbol = resolved.symbol;\n \t}\n \n       if (deprocedure_p\n@@ -3698,27 +3763,14 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n \tif (exp->elts[pc + 3].opcode == OP_VAR_VALUE\n \t    && SYMBOL_DOMAIN (exp->elts[pc + 5].symbol) == UNDEF_DOMAIN)\n \t  {\n-\t    std::vector<struct block_symbol> candidates\n-\t      = ada_lookup_symbol_list (exp->elts[pc + 5].symbol->linkage_name (),\n-\t\t\t\t\texp->elts[pc + 4].block, VAR_DOMAIN);\n-\n-\t    if (candidates.size () == 1)\n-\t      i = 0;\n-\t    else\n-\t      {\n-\t\ti = ada_resolve_function\n-\t\t  (candidates,\n-\t\t   argvec, nargs,\n-\t\t   exp->elts[pc + 5].symbol->linkage_name (),\n-\t\t   context_type, parse_completion);\n-\t\tif (i < 0)\n-\t\t  error (_(\"Could not find a match for %s\"),\n-\t\t\t exp->elts[pc + 5].symbol->print_name ());\n-\t      }\n-\n-\t    exp->elts[pc + 4].block = candidates[i].block;\n-\t    exp->elts[pc + 5].symbol = candidates[i].symbol;\n-\t    tracker->update (candidates[i]);\n+\t    block_symbol resolved\n+\t      = ada_resolve_funcall (exp->elts[pc + 5].symbol,\n+\t\t\t\t     exp->elts[pc + 4].block,\n+\t\t\t\t     context_type, parse_completion,\n+\t\t\t\t     nargs, argvec,\n+\t\t\t\t     tracker);\n+\t    exp->elts[pc + 4].block = resolved.block;\n+\t    exp->elts[pc + 5].symbol = resolved.symbol;\n \t  }\n       }\n       break;\n@@ -3743,23 +3795,16 @@ resolve_subexp (expression_up *expp, int *pos, int deprocedure_p,\n     case UNOP_PLUS:\n     case UNOP_LOGICAL_NOT:\n     case UNOP_ABS:\n-      if (possible_user_operator_p (op, argvec))\n-\t{\n-\t  std::vector<struct block_symbol> candidates\n-\t    = ada_lookup_symbol_list (ada_decoded_op_name (op),\n-\t\t\t\t      NULL, VAR_DOMAIN);\n-\n-\t  i = ada_resolve_function (candidates, argvec,\n-\t\t\t\t    nargs, ada_decoded_op_name (op), NULL,\n-\t\t\t\t    parse_completion);\n-\t  if (i < 0)\n-\t    break;\n+      {\n+\tblock_symbol found = ada_find_operator_symbol (op, parse_completion,\n+\t\t\t\t\t\t       nargs, argvec);\n+\tif (found.symbol == nullptr)\n+\t  break;\n \n-\t  replace_operator_with_call (expp, pc, nargs, 1,\n-\t\t\t\t      candidates[i].symbol,\n-\t\t\t\t      candidates[i].block);\n-\t  exp = expp->get ();\n-\t}\n+\treplace_operator_with_call (expp, pc, nargs, 1,\n+\t\t\t\t    found.symbol, found.block);\n+\texp = expp->get ();\n+      }\n       break;\n \n     case OP_TYPE:"
    },
    {
      "sha": "679aeb4fa7211d2c8e6c2ac147bbe542963e8e8e",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 38,
      "deletions": 0,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cd9a314824b2b87207a8ba7a8003639989d2406b/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cd9a314824b2b87207a8ba7a8003639989d2406b/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=cd9a314824b2b87207a8ba7a8003639989d2406b",
      "patch": "@@ -379,4 +379,42 @@ extern void print_ada_task_info (struct ui_out *uiout,\n \t\t\t\t const char *taskno_str,\n \t\t\t\t struct inferior *inf);\n \n+/* Look for a symbol for an overloaded operator for the operation OP.\n+   PARSE_COMPLETION is nonzero if currently parsing for completion.\n+   NARGS and ARGVEC describe the arguments to the call.  Returns a\n+   \"null\" block_symbol if no such operator is found.  */\n+\n+extern block_symbol ada_find_operator_symbol (enum exp_opcode op,\n+\t\t\t\t\t      int parse_completion,\n+\t\t\t\t\t      int nargs, value *argvec[]);\n+\n+/* Resolve a function call, selecting among possible function symbols.\n+   SYM and BLOCK are passed to ada_lookup_symbol_list.  CONTEXT_TYPE\n+   describes the calling context.  PARSE_COMPLETION is nonzero if\n+   currently parsing for completion.  NARGS and ARGVEC describe the\n+   arguments to the call.  This returns the chosen symbol and will\n+   update TRACKER accordingly.  */\n+\n+extern block_symbol ada_resolve_funcall (struct symbol *sym,\n+\t\t\t\t\t const struct block *block,\n+\t\t\t\t\t struct type *context_type,\n+\t\t\t\t\t int parse_completion,\n+\t\t\t\t\t int nargs, value *argvec[],\n+\t\t\t\t\t innermost_block_tracker *tracker);\n+\n+/* Resolve a symbol reference, selecting among possible values.  SYM\n+   and BLOCK are passed to ada_lookup_symbol_list.  CONTEXT_TYPE\n+   describes the calling context.  PARSE_COMPLETION is nonzero if\n+   currently parsing for completion.  If DEPROCEDURE_P is nonzero,\n+   then a symbol that names a zero-argument function will be passed\n+   through ada_resolve_function.  This returns the chosen symbol and\n+   will update TRACKER accordingly.  */\n+\n+extern block_symbol ada_resolve_variable (struct symbol *sym,\n+\t\t\t\t\t  const struct block *block,\n+\t\t\t\t\t  struct type *context_type,\n+\t\t\t\t\t  int parse_completion,\n+\t\t\t\t\t  int deprocedure_p,\n+\t\t\t\t\t  innermost_block_tracker *tracker);\n+\n #endif"
    }
  ]
}