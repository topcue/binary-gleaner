{
  "sha": "986e9e3aa03f854bedacef7fac38fe8f009a416c",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTg2ZTllM2FhMDNmODU0YmVkYWNlZjdmYWMzOGZlOGYwMDlhNDE2Yw==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:37:52Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-03-18T12:40:40Z"
    },
    "message": "libctf: do not corrupt strings across ctf_serialize\n\nThe preceding change revealed a new bug: the string table is sorted for\nbetter compression, so repeated serialization with type (or member)\nadditions in the middle can move strings around.  But every\nserialization flushes the set of refs (the memory locations that are\nautomatically updated with a final string offset when the strtab is\nupdated), so if we are not to have string offsets go stale, we must do\nall ref additions within the serialization code (which walks the\ncomplete set of types and symbols anyway). Unfortunately, we were adding\none ref in another place: the type name in the dynamic type definitions,\nwhich has a ref added to it by ctf_add_generic.\n\nSo adding a type, serializing (via, say, one of the ctf_write\nfunctions), adding another type with a name that sorts earlier, and\nserializing again will corrupt the name of the first type because it no\nlonger had a ref pointing to its dtd entry's name when its string offset\nwas shifted later in the strtab to mae way for the other type.\n\nTo ensure that we don't miss strings, we also maintain a set of *pending\nrefs* that will be added later (during serialization), and remove\nentries from that set when the ref is finally added.  We always use\nctf_str_add_pending outside ctf-serialize.c, ensure that ctf_serialize\nadds all strtab offsets as refs (even those in the dtds) on every\nserialization, and mandate that no refs are live on entry to\nctf_serialize and that all pending refs are gone before strtab\nfinalization.  (Of necessity ctf_serialize has to traverse all strtab\noffsets in the dtds in order to serialize them, so adding them as refs\nat the same time is easy.)\n\n(Note that we still can't erase unused atoms when we roll back, though\nwe can erase unused refs: members and enums are still not removed by\nrollbacks and might reference strings added after the snapshot.)\n\nlibctf/ChangeLog\n2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-hash.c (ctf_dynset_elements): New.\n\t* ctf-impl.h (ctf_dynset_elements): Declare it.\n\t(ctf_str_add_pending): Likewise.\n\t(ctf_dict_t) <ctf_str_pending_ref>: New, set of refs that must be\n\tadded during serialization.\n\t* ctf-string.c (ctf_str_create_atoms): Initialize it.\n\t(CTF_STR_ADD_REF): New flag.\n\t(CTF_STR_MAKE_PROVISIONAL): Likewise.\n\t(CTF_STR_PENDING_REF): Likewise.\n\t(ctf_str_add_ref_internal): Take a flags word rather than int\n\tparams.  Populate, and clear out, ctf_str_pending_ref.\n\t(ctf_str_add): Adjust accordingly.\n\t(ctf_str_add_external): Likewise.\n\t(ctf_str_add_pending): New.\n\t(ctf_str_remove_ref): Also remove the potential ref if it is a\n\tpending ref.\n\t* ctf-serialize.c (ctf_serialize): Prohibit addition of strings\n\twith ctf_str_add_ref before serialization.  Ensure that the\n\tctf_str_pending_ref set is empty before strtab finalization.\n\t(ctf_emit_type_sect): Add a ref to the ctt_name.\n\t* ctf-create.c (ctf_add_generic): Add the ctt_name as a pending\n\tref.\n\t* testsuite/libctf-writable/reserialize-strtab-corruption.*: New test.",
    "tree": {
      "sha": "7e553bb8e278ab340513d57d67e37a4c2c503109",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/7e553bb8e278ab340513d57d67e37a4c2c503109"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/986e9e3aa03f854bedacef7fac38fe8f009a416c",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/986e9e3aa03f854bedacef7fac38fe8f009a416c",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/986e9e3aa03f854bedacef7fac38fe8f009a416c",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/986e9e3aa03f854bedacef7fac38fe8f009a416c/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "2a05d50e90c2c8219dd4119788548f64a934190e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/2a05d50e90c2c8219dd4119788548f64a934190e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/2a05d50e90c2c8219dd4119788548f64a934190e"
    }
  ],
  "stats": {
    "total": 221,
    "additions": 209,
    "deletions": 12
  },
  "files": [
    {
      "sha": "b4da0407ca9736263ff0a269efb424fe33b31f4a",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 26,
      "deletions": 0,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=986e9e3aa03f854bedacef7fac38fe8f009a416c",
      "patch": "@@ -1,3 +1,29 @@\n+2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-hash.c (ctf_dynset_elements): New.\n+\t* ctf-impl.h (ctf_dynset_elements): Declare it.\n+\t(ctf_str_add_pending): Likewise.\n+\t(ctf_dict_t) <ctf_str_pending_ref>: New, set of refs that must be\n+\tadded during serialization.\n+\t* ctf-string.c (ctf_str_create_atoms): Initialize it.\n+\t(CTF_STR_ADD_REF): New flag.\n+\t(CTF_STR_MAKE_PROVISIONAL): Likewise.\n+\t(CTF_STR_PENDING_REF): Likewise.\n+\t(ctf_str_add_ref_internal): Take a flags word rather than int\n+\tparams.  Populate, and clear out, ctf_str_pending_ref.\n+\t(ctf_str_add): Adjust accordingly.\n+\t(ctf_str_add_external): Likewise.\n+\t(ctf_str_add_pending): New.\n+\t(ctf_str_remove_ref): Also remove the potential ref if it is a\n+\tpending ref.\n+\t* ctf-serialize.c (ctf_serialize): Prohibit addition of strings\n+\twith ctf_str_add_ref before serialization.  Ensure that the\n+\tctf_str_pending_ref set is empty before strtab finalization.\n+\t(ctf_emit_type_sect): Add a ref to the ctt_name.\n+\t* ctf-create.c (ctf_add_generic): Add the ctt_name as a pending\n+\tref.\n+\t* testsuite/libctf-writable/reserialize-strtab-corruption.*: New test.\n+\n 2021-03-18  Nick Alcock  <nick.alcock@oracle.com>\n \n \t* ctf-serialize.c (ctf_serialize): Preserve ctf_typemax across"
    },
    {
      "sha": "ea2c1481b6c7e37ab104efe43e1ab45c50d1b178",
      "filename": "libctf/ctf-create.c",
      "status": "modified",
      "additions": 2,
      "deletions": 1,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-create.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-create.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-create.c?ref=986e9e3aa03f854bedacef7fac38fe8f009a416c",
      "patch": "@@ -439,7 +439,8 @@ ctf_add_generic (ctf_dict_t *fp, uint32_t flag, const char *name, int kind,\n   type = ++fp->ctf_typemax;\n   type = LCTF_INDEX_TO_TYPE (fp, type, (fp->ctf_flags & LCTF_CHILD));\n \n-  dtd->dtd_data.ctt_name = ctf_str_add_ref (fp, name, &dtd->dtd_data.ctt_name);\n+  dtd->dtd_data.ctt_name = ctf_str_add_pending (fp, name,\n+\t\t\t\t\t\t&dtd->dtd_data.ctt_name);\n   dtd->dtd_type = type;\n \n   if (dtd->dtd_data.ctt_name == 0 && name != NULL && name[0] != '\\0')"
    },
    {
      "sha": "426bd625ffb44fb3bb59c69d0a8c8dcae5d61084",
      "filename": "libctf/ctf-hash.c",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-hash.c?ref=986e9e3aa03f854bedacef7fac38fe8f009a416c",
      "patch": "@@ -672,6 +672,12 @@ ctf_dynset_lookup (ctf_dynset_t *hp, const void *key)\n   return NULL;\n }\n \n+size_t\n+ctf_dynset_elements (ctf_dynset_t *hp)\n+{\n+  return htab_elements ((struct htab *) hp);\n+}\n+\n /* TRUE/FALSE return.  */\n int\n ctf_dynset_exists (ctf_dynset_t *hp, const void *key, const void **orig_key)"
    },
    {
      "sha": "a319d7f74a21916e40ae45bcdf23b4097c301137",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 4,
      "deletions": 1,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=986e9e3aa03f854bedacef7fac38fe8f009a416c",
      "patch": "@@ -398,7 +398,8 @@ struct ctf_dict\n   ctf_names_t ctf_names;\t    /* Hash table of remaining type names.  */\n   ctf_lookup_t ctf_lookups[5];\t    /* Pointers to nametabs for name lookup.  */\n   ctf_strs_t ctf_str[2];\t    /* Array of string table base and bounds.  */\n-  ctf_dynhash_t *ctf_str_atoms;\t  /* Hash table of ctf_str_atoms_t.  */\n+  ctf_dynhash_t *ctf_str_atoms;\t    /* Hash table of ctf_str_atoms_t.  */\n+  ctf_dynset_t *ctf_str_pending_ref; /* Locations awaiting ref addition.  */\n   uint64_t ctf_str_num_refs;\t  /* Number of refs to cts_str_atoms.  */\n   uint32_t ctf_str_prov_offset;\t  /* Latest provisional offset assigned so far.  */\n   unsigned char *ctf_base;\t  /* CTF file pointer.  */\n@@ -673,6 +674,7 @@ extern int ctf_dynset_insert (ctf_dynset_t *, void *);\n extern void ctf_dynset_remove (ctf_dynset_t *, const void *);\n extern void ctf_dynset_destroy (ctf_dynset_t *);\n extern void *ctf_dynset_lookup (ctf_dynset_t *, const void *);\n+extern size_t ctf_dynset_elements (ctf_dynset_t *);\n extern int ctf_dynset_exists (ctf_dynset_t *, const void *key,\n \t\t\t      const void **orig_key);\n extern int ctf_dynset_next (ctf_dynset_t *, ctf_next_t **, void **key);\n@@ -731,6 +733,7 @@ extern int ctf_str_create_atoms (ctf_dict_t *);\n extern void ctf_str_free_atoms (ctf_dict_t *);\n extern uint32_t ctf_str_add (ctf_dict_t *, const char *);\n extern uint32_t ctf_str_add_ref (ctf_dict_t *, const char *, uint32_t *ref);\n+extern uint32_t ctf_str_add_pending (ctf_dict_t *, const char *, uint32_t *);\n extern int ctf_str_add_external (ctf_dict_t *, const char *, uint32_t offset);\n extern void ctf_str_remove_ref (ctf_dict_t *, const char *, uint32_t *ref);\n extern void ctf_str_rollback (ctf_dict_t *, ctf_snapshot_id_t);"
    },
    {
      "sha": "0eff0e197fa248ecfaecf64861ce31b512f24d1d",
      "filename": "libctf/ctf-serialize.c",
      "status": "modified",
      "additions": 23,
      "deletions": 1,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-serialize.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-serialize.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-serialize.c?ref=986e9e3aa03f854bedacef7fac38fe8f009a416c",
      "patch": "@@ -870,7 +870,10 @@ ctf_emit_type_sect (ctf_dict_t *fp, unsigned char **tptr)\n       copied = (ctf_stype_t *) t;  /* name is at the start: constant offset.  */\n       if (copied->ctt_name\n \t  && (name = ctf_strraw (fp, copied->ctt_name)) != NULL)\n-\tctf_str_add_ref (fp, name, &copied->ctt_name);\n+\t{\n+\t  ctf_str_add_ref (fp, name, &copied->ctt_name);\n+\t  ctf_str_add_ref (fp, name, &dtd->dtd_data.ctt_name);\n+\t}\n       t += len;\n \n       switch (kind)\n@@ -955,6 +958,7 @@ ctf_serialize (ctf_dict_t *fp)\n   ctf_varent_t *dvarents;\n   ctf_strs_writable_t strtab;\n   int err;\n+  int num_missed_str_refs;\n \n   unsigned char *t;\n   unsigned long i;\n@@ -973,6 +977,16 @@ ctf_serialize (ctf_dict_t *fp)\n   if (!(fp->ctf_flags & LCTF_DIRTY))\n     return 0;\n \n+  /* The strtab refs table must be empty at this stage.  Any refs already added\n+     will be corrupted by any modifications, including reserialization, after\n+     strtab finalization is complete.  Only this function, and functions it\n+     calls, may add refs, and all memory locations (including in the dtds)\n+     containing strtab offsets must be traversed as part of serialization, and\n+     refs added.  */\n+\n+  if (!ctf_assert (fp, fp->ctf_str_num_refs == 0))\n+    return -1;\t\t\t\t\t/* errno is set for us.  */\n+\n   /* Fill in an initial CTF header.  We will leave the label, object,\n      and function sections empty and only output a header, type section,\n      and string table.  The type section begins at a 4-byte aligned\n@@ -1052,6 +1066,12 @@ ctf_serialize (ctf_dict_t *fp)\n \n   assert (t == (unsigned char *) buf + sizeof (ctf_header_t) + hdr.cth_stroff);\n \n+  /* Every string added outside serialization by ctf_str_add_pending should\n+     now have been added by ctf_add_ref.  */\n+  num_missed_str_refs = ctf_dynset_elements (fp->ctf_str_pending_ref);\n+  if (!ctf_assert (fp, num_missed_str_refs == 0))\n+    goto err;\t\t\t\t\t/* errno is set for us.  */\n+\n   /* Construct the final string table and fill out all the string refs with the\n      final offsets.  Then purge the refs list, because we're about to move this\n      strtab onto the end of the buf, invalidating all the offsets.  */\n@@ -1154,8 +1174,10 @@ ctf_serialize (ctf_dict_t *fp)\n   ctf_str_free_atoms (nfp);\n   nfp->ctf_str_atoms = fp->ctf_str_atoms;\n   nfp->ctf_prov_strtab = fp->ctf_prov_strtab;\n+  nfp->ctf_str_pending_ref = fp->ctf_str_pending_ref;\n   fp->ctf_str_atoms = NULL;\n   fp->ctf_prov_strtab = NULL;\n+  fp->ctf_str_pending_ref = NULL;\n   memset (&fp->ctf_dtdefs, 0, sizeof (ctf_list_t));\n   memset (&fp->ctf_errs_warnings, 0, sizeof (ctf_list_t));\n   fp->ctf_add_processing = NULL;"
    },
    {
      "sha": "9f0e5400141a5cdc68dc0959782a082bf35cfac3",
      "filename": "libctf/ctf-string.c",
      "status": "modified",
      "additions": 52,
      "deletions": 9,
      "changes": 61,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-string.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/ctf-string.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-string.c?ref=986e9e3aa03f854bedacef7fac38fe8f009a416c",
      "patch": "@@ -103,7 +103,7 @@ ctf_str_create_atoms (ctf_dict_t *fp)\n {\n   fp->ctf_str_atoms = ctf_dynhash_create (ctf_hash_string, ctf_hash_eq_string,\n \t\t\t\t\t  free, ctf_str_free_atom);\n-  if (fp->ctf_str_atoms == NULL)\n+  if (!fp->ctf_str_atoms)\n     return -ENOMEM;\n \n   if (!fp->ctf_prov_strtab)\n@@ -113,6 +113,13 @@ ctf_str_create_atoms (ctf_dict_t *fp)\n   if (!fp->ctf_prov_strtab)\n     goto oom_prov_strtab;\n \n+  if (!fp->ctf_str_pending_ref)\n+    fp->ctf_str_pending_ref = ctf_dynset_create (htab_hash_pointer,\n+\t\t\t\t\t\t htab_eq_pointer,\n+\t\t\t\t\t\t NULL);\n+  if (!fp->ctf_str_pending_ref)\n+    goto oom_str_pending_ref;\n+\n   errno = 0;\n   ctf_str_add (fp, \"\");\n   if (errno == ENOMEM)\n@@ -123,6 +130,9 @@ ctf_str_create_atoms (ctf_dict_t *fp)\n  oom_str_add:\n   ctf_dynhash_destroy (fp->ctf_prov_strtab);\n   fp->ctf_prov_strtab = NULL;\n+ oom_str_pending_ref:\n+  ctf_dynset_destroy (fp->ctf_str_pending_ref);\n+  fp->ctf_str_pending_ref = NULL;\n  oom_prov_strtab:\n   ctf_dynhash_destroy (fp->ctf_str_atoms);\n   fp->ctf_str_atoms = NULL;\n@@ -135,24 +145,29 @@ ctf_str_free_atoms (ctf_dict_t *fp)\n {\n   ctf_dynhash_destroy (fp->ctf_prov_strtab);\n   ctf_dynhash_destroy (fp->ctf_str_atoms);\n+  ctf_dynset_destroy (fp->ctf_str_pending_ref);\n }\n \n+#define CTF_STR_ADD_REF 0x1\n+#define CTF_STR_MAKE_PROVISIONAL 0x2\n+#define CTF_STR_PENDING_REF 0x4\n+\n /* Add a string to the atoms table, copying the passed-in string.  Return the\n    atom added. Return NULL only when out of memory (and do not touch the\n    passed-in string in that case).  Possibly augment the ref list with the\n    passed-in ref.  Possibly add a provisional entry for this string to the\n    provisional strtab.   */\n static ctf_str_atom_t *\n ctf_str_add_ref_internal (ctf_dict_t *fp, const char *str,\n-\t\t\t  int add_ref, int make_provisional, uint32_t *ref)\n+\t\t\t  int flags, uint32_t *ref)\n {\n   char *newstr = NULL;\n   ctf_str_atom_t *atom = NULL;\n   ctf_str_atom_ref_t *aref = NULL;\n \n   atom = ctf_dynhash_lookup (fp->ctf_str_atoms, str);\n \n-  if (add_ref)\n+  if (flags & CTF_STR_ADD_REF)\n     {\n       if ((aref = malloc (sizeof (struct ctf_str_atom_ref))) == NULL)\n \treturn NULL;\n@@ -161,8 +176,9 @@ ctf_str_add_ref_internal (ctf_dict_t *fp, const char *str,\n \n   if (atom)\n     {\n-      if (add_ref)\n+      if (flags & CTF_STR_ADD_REF)\n \t{\n+\t  ctf_dynset_remove (fp->ctf_str_pending_ref, (void *) ref);\n \t  ctf_list_append (&atom->csa_refs, aref);\n \t  fp->ctf_str_num_refs++;\n \t}\n@@ -182,7 +198,7 @@ ctf_str_add_ref_internal (ctf_dict_t *fp, const char *str,\n   atom->csa_str = newstr;\n   atom->csa_snapshot_id = fp->ctf_snapshots;\n \n-  if (make_provisional)\n+  if (flags & CTF_STR_MAKE_PROVISIONAL)\n     {\n       atom->csa_offset = fp->ctf_str_prov_offset;\n \n@@ -193,8 +209,14 @@ ctf_str_add_ref_internal (ctf_dict_t *fp, const char *str,\n       fp->ctf_str_prov_offset += strlen (atom->csa_str) + 1;\n     }\n \n-  if (add_ref)\n+  if (flags & CTF_STR_PENDING_REF)\n+    {\n+      if (ctf_dynset_insert (fp->ctf_str_pending_ref, (void *) ref) < 0)\n+\tgoto oom;\n+    }\n+  else if (flags & CTF_STR_ADD_REF)\n     {\n+      ctf_dynset_remove (fp->ctf_str_pending_ref, (void *) ref);\n       ctf_list_append (&atom->csa_refs, aref);\n       fp->ctf_str_num_refs++;\n     }\n@@ -222,7 +244,7 @@ ctf_str_add (ctf_dict_t *fp, const char *str)\n   if (!str)\n     str = \"\";\n \n-  atom = ctf_str_add_ref_internal (fp, str, FALSE, TRUE, 0);\n+  atom = ctf_str_add_ref_internal (fp, str, CTF_STR_MAKE_PROVISIONAL, 0);\n   if (!atom)\n     return 0;\n \n@@ -240,7 +262,26 @@ ctf_str_add_ref (ctf_dict_t *fp, const char *str, uint32_t *ref)\n   if (!str)\n     str = \"\";\n \n-  atom = ctf_str_add_ref_internal (fp, str, TRUE, TRUE, ref);\n+  atom = ctf_str_add_ref_internal (fp, str, CTF_STR_ADD_REF\n+\t\t\t\t   | CTF_STR_MAKE_PROVISIONAL, ref);\n+  if (!atom)\n+    return 0;\n+\n+  return atom->csa_offset;\n+}\n+\n+/* Like ctf_str_add_ref(), but notes that this memory location must be added as\n+   a ref by a later serialization phase, rather than adding it itself.  */\n+uint32_t\n+ctf_str_add_pending (ctf_dict_t *fp, const char *str, uint32_t *ref)\n+{\n+  ctf_str_atom_t *atom;\n+\n+  if (!str)\n+    str = \"\";\n+\n+  atom = ctf_str_add_ref_internal (fp, str, CTF_STR_PENDING_REF\n+\t\t\t\t   | CTF_STR_MAKE_PROVISIONAL, ref);\n   if (!atom)\n     return 0;\n \n@@ -257,7 +298,7 @@ ctf_str_add_external (ctf_dict_t *fp, const char *str, uint32_t offset)\n   if (!str)\n     str = \"\";\n \n-  atom = ctf_str_add_ref_internal (fp, str, FALSE, FALSE, 0);\n+  atom = ctf_str_add_ref_internal (fp, str, 0, 0);\n   if (!atom)\n     return 0;\n \n@@ -307,6 +348,8 @@ ctf_str_remove_ref (ctf_dict_t *fp, const char *str, uint32_t *ref)\n \t  free (aref);\n \t}\n     }\n+\n+  ctf_dynset_remove (fp->ctf_str_pending_ref, (void *) ref);\n }\n \n /* A ctf_dynhash_iter_remove() callback that removes atoms later than a given"
    },
    {
      "sha": "1593325da7771b31dddc97ada88fa159008bae8c",
      "filename": "libctf/testsuite/libctf-writable/reserialize-strtab-corruption.c",
      "status": "added",
      "additions": 91,
      "deletions": 0,
      "changes": 91,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/testsuite/libctf-writable/reserialize-strtab-corruption.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/testsuite/libctf-writable/reserialize-strtab-corruption.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-writable/reserialize-strtab-corruption.c?ref=986e9e3aa03f854bedacef7fac38fe8f009a416c",
      "patch": "@@ -0,0 +1,91 @@\n+/* Make sure serializing a dict (possibly repeatedly) does not corrupt either\n+   type lookup or the string content of the dict.  */\n+\n+#include <ctf-api.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  ctf_dict_t *fp;\n+  ctf_id_t zygal, autoschediastic;\n+  ctf_snapshot_id_t snap;\n+  unsigned char *foo;\n+  size_t foo_size;\n+  const char *bar;\n+  int err;\n+  char name[64];\n+\n+  /* Adding things after serialization should not corrupt names created before\n+     serialization.  */\n+\n+  if ((fp = ctf_create (&err)) == NULL)\n+    goto create_err;\n+\n+  if ((zygal = ctf_add_struct (fp, CTF_ADD_ROOT, \"zygal\")) == CTF_ERR)\n+    goto add_err;\n+\n+  if ((foo = ctf_write_mem (fp, &foo_size, 4096)) == NULL)\n+    goto write_err;\n+  free (foo);\n+\n+  if (ctf_type_name (fp, zygal, name, sizeof (name)) == NULL)\n+    fprintf (stderr, \"Can't get name of zygal: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n+  else\n+    printf (\"zygal's name is %s\\n\", name);\n+\n+  if ((autoschediastic = ctf_add_enum (fp, CTF_ADD_ROOT, \"autoschediastic\")) == CTF_ERR)\n+    goto add_err;\n+\n+  if (ctf_type_name (fp, zygal, name, sizeof (name)) == NULL)\n+    fprintf (stderr, \"Can't get name of zygal: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n+  else\n+    printf (\"zygal's name is %s\\n\", name);\n+\n+  /* Serializing again should not corrupt names either.  */\n+  if ((foo = ctf_write_mem (fp, &foo_size, 4096)) == NULL)\n+    goto write_err;\n+  free (foo);\n+\n+  if (ctf_type_name (fp, zygal, name, sizeof (name)) == NULL)\n+    fprintf (stderr, \"Can't get name of zygal: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n+  else\n+    printf (\"zygal's name is %s\\n\", name);\n+\n+  /* Add another new name, roll back, and make sure the strings are\n+     uncorrupted.  */\n+\n+  snap = ctf_snapshot (fp);\n+  if (ctf_add_enumerator (fp, autoschediastic, \"aichmophobia\", 0) < 0)\n+    goto add_err;\n+\n+  if (ctf_rollback (fp, snap) < 0)\n+    goto roll_err;\n+\n+  if (ctf_type_name (fp, zygal, name, sizeof (name)) == NULL)\n+    fprintf (stderr, \"Can't get name of zygal: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n+  else\n+    printf (\"zygal's name is %s after first rollback\\n\", name);\n+\n+  if (ctf_type_name (fp, autoschediastic, name, sizeof (name)) == NULL)\n+    fprintf (stderr, \"Can't get name of autoschediastic: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n+  else\n+    printf (\"autoschediastic's name is %s after first rollback\\n\", name);\n+\n+  ctf_dict_close (fp);\n+  return 0;\n+\n+ create_err:\n+  fprintf (stderr, \"Cannot create: %s\\n\", ctf_errmsg (err));\n+  return 1;\n+ add_err:\n+  fprintf (stderr, \"Cannot add: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n+  return 1;\n+ write_err:\n+  fprintf (stderr, \"Cannot serialize: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n+  return 1;\n+ roll_err:\n+  fprintf (stderr, \"Cannot roll back: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n+  return 1;\n+}"
    },
    {
      "sha": "58f7a64a33111d3745919b3aa7ab7984aba8e571",
      "filename": "libctf/testsuite/libctf-writable/reserialize-strtab-corruption.lk",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/testsuite/libctf-writable/reserialize-strtab-corruption.lk",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/986e9e3aa03f854bedacef7fac38fe8f009a416c/libctf/testsuite/libctf-writable/reserialize-strtab-corruption.lk",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-writable/reserialize-strtab-corruption.lk?ref=986e9e3aa03f854bedacef7fac38fe8f009a416c",
      "patch": "@@ -0,0 +1,5 @@\n+zygal's name is struct zygal\n+zygal's name is struct zygal\n+zygal's name is struct zygal\n+zygal's name is struct zygal after first rollback\n+autoschediastic's name is enum autoschediastic after first rollback"
    }
  ]
}