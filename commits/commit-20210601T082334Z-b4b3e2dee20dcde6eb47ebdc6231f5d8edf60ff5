{
  "sha": "b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6YjRiM2UyZGVlMjBkY2RlNmViNDdlYmRjNjIzMWY1ZDhlZGY2MGZmNQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-08-29T11:37:00Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-06-01T08:23:34Z"
    },
    "message": "gdb: avoid premature dummy frame garbage collection\n\nConsider the following chain of events:\n\n  * GDB is performing an inferior call, and\n\n  * the inferior calls longjmp, and\n\n  * GDB detects that the longjmp has completed, stops, and enters\n    check_longjmp_breakpoint_for_call_dummy (in breakpoint.c), and\n\n  * GDB tries to unwind the stack in order to check that the dummy\n    frame (setup for the inferior call) is still on the stack, but\n\n  * The unwind fails, possibly due to missing debug information, so\n\n  * GDB incorrectly concludes that the inferior has longjmp'd past the\n    dummy frame, and so deletes the dummy frame, including the dummy\n    frame breakpoint, but then\n\n  * The inferior continues, and eventually returns to the dummy frame,\n    which is usually (always?) on the stack, the inferior starts\n    trying to execute the random contents of the stack, this results\n    in undefined behaviour.\n\nThis situation is already warned about in the comment on the function\ncheck_longjmp_breakpoint_for_call_dummy where we say:\n\n   You should call this function only at places where it is safe to currently\n   unwind the whole stack.  Failed stack unwind would discard live dummy\n   frames.\n\nThe warning here is fine, the problem is that, even though we call the\nfunction from a location within GDB where we hope to be able to\nunwind, sometime the state of the inferior means that the unwind will\nnot succeed.\n\nThis commit tries to improve the situation by adding the following\nadditional check; when GDB fails to find the dummy frame on the stack,\ninstead of just assuming that the dummy frame can be garbage\ncollected, first find the stop_reason for the last frame on the stack.\nIf this stop_reason indicates that the stack unwinding may have failed\nthen we assume that the dummy frame is still in use.  However, if the\nlast frame's stop_reason indicates that the stack unwind completed\nsuccessfully then we can be confident that the dummy frame is no\nlonger in use, and we garbage collect it.\n\nTested on x86-64 GNU/Linux.\n\ngdb/ChangeLog:\n\n\t* breakpoint.c (check_longjmp_breakpoint_for_call_dummy): Add\n\tcheck for why the backtrace stopped.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.base/premature-dummy-frame-removal.c: New file.\n\t* gdb.base/premature-dummy-frame-removal.exp: New file.\n\t* gdb.base/premature-dummy-frame-removal.py: New file.\n\nChange-Id: I8f330cfe0f3f33beb3a52a36994094c4abada07e",
    "tree": {
      "sha": "011709cafd49177bc49f47523f03ef3e772089f8",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/011709cafd49177bc49f47523f03ef3e772089f8"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a2cf3633b33ec21b967f4c7ddfb7f1b80e676d2d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a2cf3633b33ec21b967f4c7ddfb7f1b80e676d2d",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a2cf3633b33ec21b967f4c7ddfb7f1b80e676d2d"
    }
  ],
  "stats": {
    "total": 242,
    "additions": 238,
    "deletions": 4
  },
  "files": [
    {
      "sha": "b6930dff39cd4e8859e41624271b468e347e1aa0",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
      "patch": "@@ -1,3 +1,9 @@\n+2021-06-01  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\t    Richard Bunt  <richard.bunt@arm.com>\n+\n+\t* breakpoint.c (check_longjmp_breakpoint_for_call_dummy): Add\n+\tcheck for why the backtrace stopped.\n+\n 2021-05-31  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* dwarf2/read.h (struct structured_type) <signatured_type>: New."
    },
    {
      "sha": "fb011fc1e0fc6839e8467626b5e2a8fcebc099a9",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 48,
      "deletions": 4,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
      "patch": "@@ -7357,9 +7357,10 @@ set_longjmp_breakpoint_for_call_dummy (void)\n    TP.  Remove those which can no longer be found in the current frame\n    stack.\n \n-   You should call this function only at places where it is safe to currently\n-   unwind the whole stack.  Failed stack unwind would discard live dummy\n-   frames.  */\n+   If the unwind fails then there is not sufficient information to discard\n+   dummy frames.  In this case, elide the clean up and the dummy frames will\n+   be cleaned up next time this function is called from a location where\n+   unwinding is possible.  */\n \n void\n check_longjmp_breakpoint_for_call_dummy (struct thread_info *tp)\n@@ -7371,12 +7372,55 @@ check_longjmp_breakpoint_for_call_dummy (struct thread_info *tp)\n       {\n \tstruct breakpoint *dummy_b = b->related_breakpoint;\n \n+\t/* Find the bp_call_dummy breakpoint in the list of breakpoints\n+\t   chained off b->related_breakpoint.  */\n \twhile (dummy_b != b && dummy_b->type != bp_call_dummy)\n \t  dummy_b = dummy_b->related_breakpoint;\n+\n+\t/* If there was no bp_call_dummy breakpoint then there's nothing\n+\t   more to do.  Or, if the dummy frame associated with the\n+\t   bp_call_dummy is still on the stack then we need to leave this\n+\t   bp_call_dummy in place.  */\n \tif (dummy_b->type != bp_call_dummy\n \t    || frame_find_by_id (dummy_b->frame_id) != NULL)\n \t  continue;\n-\t\n+\n+\t/* We didn't find the dummy frame on the stack, this could be\n+\t   because we have longjmp'd to a stack frame that is previous to\n+\t   the dummy frame, or it could be because the stack unwind is\n+\t   broken at some point between the longjmp frame and the dummy\n+\t   frame.\n+\n+\t   Next we figure out why the stack unwind stopped.  If it looks\n+\t   like the unwind is complete then we assume the dummy frame has\n+\t   been jumped over, however, if the unwind stopped for an\n+\t   unexpected reason then we assume the stack unwind is currently\n+\t   broken, and that we will (eventually) return to the dummy\n+\t   frame.\n+\n+\t   It might be tempting to consider using frame_id_inner here, but\n+\t   that is not safe.   There is no guarantee that the stack frames\n+\t   we are looking at here are even on the same stack as the\n+\t   original dummy frame, hence frame_id_inner can't be used.  See\n+\t   the comments on frame_id_inner for more details.  */\n+\tbool unwind_finished_unexpectedly = false;\n+\tfor (struct frame_info *fi = get_current_frame (); fi != nullptr; )\n+\t  {\n+\t    struct frame_info *prev = get_prev_frame (fi);\n+\t    if (prev == nullptr)\n+\t      {\n+\t\t/* FI is the last stack frame.  Why did this frame not\n+\t\t   unwind further?  */\n+\t\tauto stop_reason = get_frame_unwind_stop_reason (fi);\n+\t\tif (stop_reason != UNWIND_NO_REASON\n+\t\t    && stop_reason != UNWIND_OUTERMOST)\n+\t\t  unwind_finished_unexpectedly = true;\n+\t      }\n+\t    fi = prev;\n+\t  }\n+\tif (unwind_finished_unexpectedly)\n+\t  continue;\n+\n \tdummy_frame_discard (dummy_b->frame_id, tp);\n \n \twhile (b->related_breakpoint != b)"
    },
    {
      "sha": "6c7079325b95d9834f20b9bbdefc72b5c451f6a5",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
      "patch": "@@ -1,3 +1,9 @@\n+2021-06-01  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.base/premature-dummy-frame-removal.c: New file.\n+\t* gdb.base/premature-dummy-frame-removal.exp: New file.\n+\t* gdb.base/premature-dummy-frame-removal.py: New file.\n+\n 2021-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n \n \t* gdb.base/reverse-init-functions.exp: New."
    },
    {
      "sha": "32deefc962f38fa1a3d198b9e589276b05fbad26",
      "filename": "gdb/testsuite/gdb.base/premature-dummy-frame-removal.c",
      "status": "added",
      "additions": 65,
      "deletions": 0,
      "changes": 65,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/testsuite/gdb.base/premature-dummy-frame-removal.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/testsuite/gdb.base/premature-dummy-frame-removal.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/premature-dummy-frame-removal.c?ref=b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
      "patch": "@@ -0,0 +1,65 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <stdlib.h>\n+#include <setjmp.h>\n+\n+jmp_buf env;\n+\n+void\n+worker (void)\n+{\n+  longjmp (env, 1);\n+}\n+\n+void\n+test_inner (void)\n+{\n+  if (setjmp (env) == 0)\n+    {\n+      /* Direct call.  */\n+      worker ();\n+\n+      /* Will never get here.  */\n+      abort ();\n+    }\n+  else\n+    {\n+      /* Called from longjmp.  */\n+    }\n+}\n+\n+void\n+break_bt_here (void)\n+{\n+  test_inner ();\n+}\n+\n+int\n+some_func (void)\n+{\n+  break_bt_here ();\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  some_func ();\n+\n+  return 0;\n+}"
    },
    {
      "sha": "bf2a2a7975665135604bb406fc6e3138313b1a39",
      "filename": "gdb/testsuite/gdb.base/premature-dummy-frame-removal.exp",
      "status": "added",
      "additions": 53,
      "deletions": 0,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/testsuite/gdb.base/premature-dummy-frame-removal.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/testsuite/gdb.base/premature-dummy-frame-removal.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/premature-dummy-frame-removal.exp?ref=b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
      "patch": "@@ -0,0 +1,53 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Make an inferior call to a function which uses longjmp.  However,\n+# the backtrace for the function that is called is broken at the point\n+# where the longjmp is handled.  This test is checking to see if the\n+# inferior call still completes successfully.\n+#\n+# This test forces a broken backtrace using Python, but in real life a\n+# broken backtrace can easily occur when calling through code for\n+# which there is no debug information if the prologue unwinder fails,\n+# which can often happen if the code has been optimized.\n+#\n+# The problem was that, due to the broken backtrace, GDB failed to\n+# find the inferior call's dummy frame.  GDB then concluded that the\n+# inferior had longjmp'd backward past the dummy frame and so garbage\n+# collected the dummy frame, this causes the breakpoint within the\n+# dummy frame to be deleted.\n+#\n+# When the inferior continued, and eventually returned to the dummy\n+# frame, it would try to execute instruction from the dummy frame\n+# (which for most, or even all, targets, is on the stack), and then\n+# experience undefined behaviuor, often a SIGSEGV.\n+\n+standard_testfile .c\n+\n+if { [prepare_for_testing \"failed to prepare\" $testfile $srcfile] } {\n+    return -1\n+}\n+\n+if ![runto_main] then {\n+    return 0\n+}\n+\n+# Skip this test if Python scripting is not enabled.\n+if { [skip_python_tests] } { continue }\n+\n+set pyfile [gdb_remote_download host ${srcdir}/${subdir}/${testfile}.py]\n+gdb_test_no_output \"source ${pyfile}\" \"load python file\"\n+\n+gdb_test \"p some_func ()\" \" = 0\""
    },
    {
      "sha": "31936658788abe6cc3b9617ce2cdad3dcf671ca2",
      "filename": "gdb/testsuite/gdb.base/premature-dummy-frame-removal.py",
      "status": "added",
      "additions": 60,
      "deletions": 0,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/testsuite/gdb.base/premature-dummy-frame-removal.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5/gdb/testsuite/gdb.base/premature-dummy-frame-removal.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/premature-dummy-frame-removal.py?ref=b4b3e2dee20dcde6eb47ebdc6231f5d8edf60ff5",
      "patch": "@@ -0,0 +1,60 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# This dummy unwinder will break GDB's backtrce at the function called\n+# 'break_bt_here'.\n+\n+import gdb\n+from gdb.unwinder import Unwinder\n+\n+\n+class FrameId(object):\n+    def __init__(self, sp, pc):\n+        self._sp = sp\n+        self._pc = pc\n+\n+    @property\n+    def sp(self):\n+        return self._sp\n+\n+    @property\n+    def pc(self):\n+        return self._pc\n+\n+\n+class TestUnwinder(Unwinder):\n+    def __init__(self):\n+        Unwinder.__init__(self, \"break unwinding\")\n+\n+    def __call__(self, pending_frame):\n+        pc_desc = pending_frame.architecture().registers().find(\"pc\")\n+        pc = pending_frame.read_register(pc_desc)\n+\n+        sp_desc = pending_frame.architecture().registers().find(\"sp\")\n+        sp = pending_frame.read_register(sp_desc)\n+\n+        block = gdb.block_for_pc(int(pc))\n+        if block == None:\n+            return None\n+        func = block.function\n+        if func == None:\n+            return None\n+        if str(func) != \"break_bt_here\":\n+            return None\n+        fid = FrameId(pc, sp)\n+        return pending_frame.create_unwind_info(fid)\n+\n+\n+gdb.unwinder.register_unwinder(None, TestUnwinder(), True)"
    }
  ]
}