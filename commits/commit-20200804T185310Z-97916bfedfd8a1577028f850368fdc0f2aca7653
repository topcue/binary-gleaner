{
  "sha": "97916bfedfd8a1577028f850368fdc0f2aca7653",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTc5MTZiZmVkZmQ4YTE1NzcwMjhmODUwMzY4ZmRjMGYyYWNhNzY1Mw==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-08-04T18:53:10Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-04T18:53:10Z"
    },
    "message": "gdb: use bool in frame code\n\nChange instances of int variables and return values used as boolean\nvalues to use the bool type.\n\nShorten the comments of a few functions, because I think they go a bit\ntoo much in implementation details, which appear out of date anyway.\n\nMake other misc changes to the functions that are already being changed,\nsuch as using nullptr instead of NULL, dropping `struct` keywords and\ndeclaring variables when first used.\n\ngdb/ChangeLog:\n\n\t* frame.h (frame_id_p): Return bool.\n\t(frame_id_artificial_p): Return bool.\n\t(frame_id_eq): Return bool.\n\t(has_stack_frames): Return bool.\n\t(get_selected_frame): Fix typo in comment.\n\t(get_frame_pc_if_available): Return bool.\n\t(get_frame_address_in_block_if_available): Return bool.\n\t(get_frame_func_if_available): Return bool.\n\t(read_frame_register_unsigned): Return bool.\n\t(get_frame_register_bytes): Return bool.\n\t(safe_frame_unwind_memory): Return bool.\n\t(deprecated_frame_register_read): Return bool.\n\t(frame_unwinder_is): Return bool.\n\t* frame.c (struct frame_info) <prev_arch::p>: Change type to\n\tbool.\n\t<this_id::p>: Likewise.\n\t<prev_p>: Likewise.\n\t(frame_stash_add): Return bool.\n\t(get_frame_id): Use bool.\n\t(frame_id_build_special) Use bool.\n\t(frame_id_build_unavailable_stack): Use bool.\n\t(frame_id_build): Use bool.\n\t(frame_id_p): Return bool, use true/false instead of 1/0.\n\t(frame_id_artificial_p): Likewise.\n\t(frame_id_eq): Likewise.\n\t(frame_id_inner): Likewise.\n\t(get_frame_func_if_available): Likewise.\n\t(read_frame_register_unsigned): Likewise.\n\t(deprecated_frame_register_read): Likewise.\n\t(get_frame_register_bytes): Likewise.\n\t(has_stack_frames): Likewise.\n\t(inside_main_func): Likewise.\n\t(inside_entry_func): Likewise.\n\t(get_frame_pc_if_available): Likewise.\n\t(get_frame_address_in_block_if_available): Likewise.\n\t(frame_unwinder_is): Likewise.\n\t(safe_frame_unwind_memory): Likewise.\n\t(frame_unwind_arch): Likewise.\n\nChange-Id: I6121fa56739b688be79d73d087d76b268ba5a46a",
    "tree": {
      "sha": "53302ed5e0d1d7f43240131202f55fcb8e878a23",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/53302ed5e0d1d7f43240131202f55fcb8e878a23"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/97916bfedfd8a1577028f850368fdc0f2aca7653",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/97916bfedfd8a1577028f850368fdc0f2aca7653",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/97916bfedfd8a1577028f850368fdc0f2aca7653",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/97916bfedfd8a1577028f850368fdc0f2aca7653/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "fedfee8850a861dd5eba402de7db67f9f01c92c6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/fedfee8850a861dd5eba402de7db67f9f01c92c6",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/fedfee8850a861dd5eba402de7db67f9f01c92c6"
    }
  ],
  "stats": {
    "total": 325,
    "additions": 182,
    "deletions": 143
  },
  "files": [
    {
      "sha": "2cd89b73b7d93e0b363d9669bb407c66f8ce763d",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 41,
      "deletions": 0,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/97916bfedfd8a1577028f850368fdc0f2aca7653/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/97916bfedfd8a1577028f850368fdc0f2aca7653/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=97916bfedfd8a1577028f850368fdc0f2aca7653",
      "patch": "@@ -1,3 +1,44 @@\n+2020-08-04  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* frame.h (frame_id_p): Return bool.\n+\t(frame_id_artificial_p): Return bool.\n+\t(frame_id_eq): Return bool.\n+\t(has_stack_frames): Return bool.\n+\t(get_selected_frame): Fix typo in comment.\n+\t(get_frame_pc_if_available): Return bool.\n+\t(get_frame_address_in_block_if_available): Return bool.\n+\t(get_frame_func_if_available): Return bool.\n+\t(read_frame_register_unsigned): Return bool.\n+\t(get_frame_register_bytes): Return bool.\n+\t(safe_frame_unwind_memory): Return bool.\n+\t(deprecated_frame_register_read): Return bool.\n+\t(frame_unwinder_is): Return bool.\n+\t* frame.c (struct frame_info) <prev_arch::p>: Change type to\n+\tbool.\n+\t<this_id::p>: Likewise.\n+\t<prev_p>: Likewise.\n+\t(frame_stash_add): Return bool.\n+\t(get_frame_id): Use bool.\n+\t(frame_id_build_special) Use bool.\n+\t(frame_id_build_unavailable_stack): Use bool.\n+\t(frame_id_build): Use bool.\n+\t(frame_id_p): Return bool, use true/false instead of 1/0.\n+\t(frame_id_artificial_p): Likewise.\n+\t(frame_id_eq): Likewise.\n+\t(frame_id_inner): Likewise.\n+\t(get_frame_func_if_available): Likewise.\n+\t(read_frame_register_unsigned): Likewise.\n+\t(deprecated_frame_register_read): Likewise.\n+\t(get_frame_register_bytes): Likewise.\n+\t(has_stack_frames): Likewise.\n+\t(inside_main_func): Likewise.\n+\t(inside_entry_func): Likewise.\n+\t(get_frame_pc_if_available): Likewise.\n+\t(get_frame_address_in_block_if_available): Likewise.\n+\t(frame_unwinder_is): Likewise.\n+\t(safe_frame_unwind_memory): Likewise.\n+\t(frame_unwind_arch): Likewise.\n+\n 2020-08-04  Simon Marchi  <simon.marchi@efficios.com>\n \n \t* frame.c (frame_info) <prev_func> <p>: Rename to status, change"
    },
    {
      "sha": "a90056808df7933ba3be69c0718fc9d4985df7f9",
      "filename": "gdb/dwarf2/frame-tailcall.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/97916bfedfd8a1577028f850368fdc0f2aca7653/gdb/dwarf2/frame-tailcall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/97916bfedfd8a1577028f850368fdc0f2aca7653/gdb/dwarf2/frame-tailcall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/frame-tailcall.c?ref=97916bfedfd8a1577028f850368fdc0f2aca7653",
      "patch": "@@ -219,7 +219,7 @@ tailcall_frame_this_id (struct frame_info *this_frame, void **this_cache,\n \n   *this_id = get_frame_id (next_frame);\n   (*this_id).code_addr = get_frame_pc (this_frame);\n-  (*this_id).code_addr_p = 1;\n+  (*this_id).code_addr_p = true;\n   (*this_id).artificial_depth = (cache->chain_levels\n \t\t\t\t - existing_next_levels (this_frame, cache));\n   gdb_assert ((*this_id).artificial_depth > 0);"
    },
    {
      "sha": "f65d43f9fcc0baeb808bb6ce62c2d158f5efa283",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 113,
      "deletions": 109,
      "changes": 222,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/97916bfedfd8a1577028f850368fdc0f2aca7653/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/97916bfedfd8a1577028f850368fdc0f2aca7653/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=97916bfedfd8a1577028f850368fdc0f2aca7653",
      "patch": "@@ -127,7 +127,7 @@ struct frame_info\n   /* Cached copy of the previous frame's architecture.  */\n   struct\n   {\n-    int p;\n+    bool p;\n     struct gdbarch *arch;\n   } prev_arch;\n \n@@ -138,21 +138,21 @@ struct frame_info\n     bool masked;\n     CORE_ADDR value;\n   } prev_pc;\n-  \n+\n   /* Cached copy of the previous frame's function address.  */\n   struct\n   {\n     CORE_ADDR addr;\n     cached_copy_status status;\n   } prev_func;\n-  \n+\n   /* This frame's ID.  */\n   struct\n   {\n-    int p;\n+    bool p;\n     struct frame_id value;\n   } this_id;\n-  \n+\n   /* The frame's high-level base methods, and corresponding cache.\n      The high level base methods are selected based on the frame's\n      debug info.  */\n@@ -162,7 +162,7 @@ struct frame_info\n   /* Pointers to the next (down, inner, younger) and previous (up,\n      outer, older) frame_info's in the frame cache.  */\n   struct frame_info *next; /* down, inner, younger */\n-  int prev_p;\n+  bool prev_p;\n   struct frame_info *prev; /* up, outer, older */\n \n   /* The reason why we could not set PREV, or UNWIND_NO_REASON if we\n@@ -257,27 +257,24 @@ frame_stash_create (void)\n    Returns false if a frame with the same ID was already stashed, true\n    otherwise.  */\n \n-static int\n-frame_stash_add (struct frame_info *frame)\n+static bool\n+frame_stash_add (frame_info *frame)\n {\n-  struct frame_info **slot;\n-\n   /* Do not try to stash the sentinel frame.  */\n   gdb_assert (frame->level >= 0);\n \n-  slot = (struct frame_info **) htab_find_slot (frame_stash,\n-\t\t\t\t\t\tframe,\n-\t\t\t\t\t\tINSERT);\n+  frame_info **slot = (struct frame_info **) htab_find_slot (frame_stash,\n+\t\t\t\t\t\t\t     frame, INSERT);\n \n   /* If we already have a frame in the stack with the same id, we\n      either have a stack cycle (corrupted stack?), or some bug\n      elsewhere in GDB.  In any case, ignore the duplicate and return\n      an indication to the caller.  */\n-  if (*slot != NULL)\n-    return 0;\n+  if (*slot != nullptr)\n+    return false;\n \n   *slot = frame;\n-  return 1;\n+  return true;\n }\n \n /* Internal function to search the frame stash for an entry with the\n@@ -560,7 +557,7 @@ compute_frame_id (struct frame_info *fi)\n   fi->this_id.value = outer_frame_id;\n   fi->unwind->this_id (fi, &fi->prologue_cache, &fi->this_id.value);\n   gdb_assert (frame_id_p (fi->this_id.value));\n-  fi->this_id.p = 1;\n+  fi->this_id.p = true;\n   if (frame_debug)\n     {\n       fprintf_unfiltered (gdb_stdlog, \"-> \");\n@@ -580,8 +577,6 @@ get_frame_id (struct frame_info *fi)\n \n   if (!fi->this_id.p)\n     {\n-      int stashed;\n-\n       /* If we haven't computed the frame id yet, then it must be that\n \t this is the current frame.  Compute it now, and stash the\n \t result.  The IDs of other frames are computed as soon as\n@@ -594,7 +589,7 @@ get_frame_id (struct frame_info *fi)\n \n       /* Since this is the first frame in the chain, this should\n \t always succeed.  */\n-      stashed = frame_stash_add (fi);\n+      bool stashed = frame_stash_add (fi);\n       gdb_assert (stashed);\n     }\n \n@@ -641,9 +636,9 @@ frame_id_build_special (CORE_ADDR stack_addr, CORE_ADDR code_addr,\n   id.stack_addr = stack_addr;\n   id.stack_status = FID_STACK_VALID;\n   id.code_addr = code_addr;\n-  id.code_addr_p = 1;\n+  id.code_addr_p = true;\n   id.special_addr = special_addr;\n-  id.special_addr_p = 1;\n+  id.special_addr_p = true;\n   return id;\n }\n \n@@ -656,7 +651,7 @@ frame_id_build_unavailable_stack (CORE_ADDR code_addr)\n \n   id.stack_status = FID_STACK_UNAVAILABLE;\n   id.code_addr = code_addr;\n-  id.code_addr_p = 1;\n+  id.code_addr_p = true;\n   return id;\n }\n \n@@ -670,9 +665,9 @@ frame_id_build_unavailable_stack_special (CORE_ADDR code_addr,\n \n   id.stack_status = FID_STACK_UNAVAILABLE;\n   id.code_addr = code_addr;\n-  id.code_addr_p = 1;\n+  id.code_addr_p = true;\n   id.special_addr = special_addr;\n-  id.special_addr_p = 1;\n+  id.special_addr_p = true;\n   return id;\n }\n \n@@ -684,7 +679,7 @@ frame_id_build (CORE_ADDR stack_addr, CORE_ADDR code_addr)\n   id.stack_addr = stack_addr;\n   id.stack_status = FID_STACK_VALID;\n   id.code_addr = code_addr;\n-  id.code_addr_p = 1;\n+  id.code_addr_p = true;\n   return id;\n }\n \n@@ -698,38 +693,39 @@ frame_id_build_wild (CORE_ADDR stack_addr)\n   return id;\n }\n \n-int\n-frame_id_p (struct frame_id l)\n+bool\n+frame_id_p (frame_id l)\n {\n-  int p;\n-\n   /* The frame is valid iff it has a valid stack address.  */\n-  p = l.stack_status != FID_STACK_INVALID;\n+  bool p = l.stack_status != FID_STACK_INVALID;\n+\n   /* outer_frame_id is also valid.  */\n   if (!p && memcmp (&l, &outer_frame_id, sizeof (l)) == 0)\n-    p = 1;\n+    p = true;\n+\n   if (frame_debug)\n     {\n       fprintf_unfiltered (gdb_stdlog, \"{ frame_id_p (l=\");\n       fprint_frame_id (gdb_stdlog, l);\n       fprintf_unfiltered (gdb_stdlog, \") -> %d }\\n\", p);\n     }\n+\n   return p;\n }\n \n-int\n-frame_id_artificial_p (struct frame_id l)\n+bool\n+frame_id_artificial_p (frame_id l)\n {\n   if (!frame_id_p (l))\n-    return 0;\n+    return false;\n \n-  return (l.artificial_depth != 0);\n+  return l.artificial_depth != 0;\n }\n \n-int\n-frame_id_eq (struct frame_id l, struct frame_id r)\n+bool\n+frame_id_eq (frame_id l, frame_id r)\n {\n-  int eq;\n+  bool eq;\n \n   if (l.stack_status == FID_STACK_INVALID && l.special_addr_p\n       && r.stack_status == FID_STACK_INVALID && r.special_addr_p)\n@@ -738,30 +734,30 @@ frame_id_eq (struct frame_id l, struct frame_id r)\n        we might step into another function - from which we can't\n        unwind either.  More thought required to get rid of\n        outer_frame_id.  */\n-    eq = 1;\n+    eq = true;\n   else if (l.stack_status == FID_STACK_INVALID\n \t   || r.stack_status == FID_STACK_INVALID)\n     /* Like a NaN, if either ID is invalid, the result is false.\n        Note that a frame ID is invalid iff it is the null frame ID.  */\n-    eq = 0;\n+    eq = false;\n   else if (l.stack_status != r.stack_status || l.stack_addr != r.stack_addr)\n     /* If .stack addresses are different, the frames are different.  */\n-    eq = 0;\n+    eq = false;\n   else if (l.code_addr_p && r.code_addr_p && l.code_addr != r.code_addr)\n     /* An invalid code addr is a wild card.  If .code addresses are\n        different, the frames are different.  */\n-    eq = 0;\n+    eq = false;\n   else if (l.special_addr_p && r.special_addr_p\n \t   && l.special_addr != r.special_addr)\n     /* An invalid special addr is a wild card (or unused).  Otherwise\n        if special addresses are different, the frames are different.  */\n-    eq = 0;\n+    eq = false;\n   else if (l.artificial_depth != r.artificial_depth)\n     /* If artificial depths are different, the frames must be different.  */\n-    eq = 0;\n+    eq = false;\n   else\n     /* Frames are equal.  */\n-    eq = 1;\n+    eq = true;\n \n   if (frame_debug)\n     {\n@@ -771,6 +767,7 @@ frame_id_eq (struct frame_id l, struct frame_id r)\n       fprint_frame_id (gdb_stdlog, r);\n       fprintf_unfiltered (gdb_stdlog, \") -> %d }\\n\", eq);\n     }\n+\n   return eq;\n }\n \n@@ -806,15 +803,15 @@ frame_id_eq (struct frame_id l, struct frame_id r)\n    a stack overflow strategy that cause the handler to be run on a\n    different stack.  */\n \n-static int\n+static bool\n frame_id_inner (struct gdbarch *gdbarch, struct frame_id l, struct frame_id r)\n {\n-  int inner;\n+  bool inner;\n \n   if (l.stack_status != FID_STACK_VALID || r.stack_status != FID_STACK_VALID)\n     /* Like NaN, any operation involving an invalid ID always fails.\n        Likewise if either ID has an unavailable stack address.  */\n-    inner = 0;\n+    inner = false;\n   else if (l.artificial_depth > r.artificial_depth\n \t   && l.stack_addr == r.stack_addr\n \t   && l.code_addr_p == r.code_addr_p\n@@ -831,7 +828,7 @@ frame_id_inner (struct gdbarch *gdbarch, struct frame_id l, struct frame_id r)\n \n       if (lb == NULL || rb == NULL)\n \t/* Something's gone wrong.  */\n-\tinner = 0;\n+\tinner = false;\n       else\n \t/* This will return true if LB and RB are the same block, or\n \t   if the block with the smaller depth lexically encloses the\n@@ -844,6 +841,7 @@ frame_id_inner (struct gdbarch *gdbarch, struct frame_id l, struct frame_id r)\n        functions are not strictly inner than (same .stack but\n        different .code and/or .special address).  */\n     inner = gdbarch_inner_than (gdbarch, l.stack_addr, r.stack_addr);\n+\n   if (frame_debug)\n     {\n       fprintf_unfiltered (gdb_stdlog, \"{ frame_id_inner (l=\");\n@@ -852,6 +850,7 @@ frame_id_inner (struct gdbarch *gdbarch, struct frame_id l, struct frame_id r)\n       fprint_frame_id (gdb_stdlog, r);\n       fprintf_unfiltered (gdb_stdlog, \") -> %d }\\n\", inner);\n     }\n+\n   return inner;\n }\n \n@@ -914,7 +913,7 @@ frame_unwind_pc (struct frame_info *this_frame)\n     {\n       struct gdbarch *prev_gdbarch;\n       CORE_ADDR pc = 0;\n-      int pc_p = 0;\n+      bool pc_p = false;\n \n       /* The right way.  The `pure' way.  The one true way.  This\n \t method depends solely on the register-unwind code to\n@@ -937,7 +936,7 @@ frame_unwind_pc (struct frame_info *this_frame)\n       try\n \t{\n \t  pc = gdbarch_unwind_pc (prev_gdbarch, this_frame);\n-\t  pc_p = 1;\n+\t  pc_p = true;\n \t}\n       catch (const gdb_exception_error &ex)\n \t{\n@@ -1003,8 +1002,8 @@ frame_unwind_caller_pc (struct frame_info *this_frame)\n   return frame_unwind_pc (this_frame);\n }\n \n-int\n-get_frame_func_if_available (struct frame_info *this_frame, CORE_ADDR *pc)\n+bool\n+get_frame_func_if_available (frame_info *this_frame, CORE_ADDR *pc)\n {\n   struct frame_info *next_frame = this_frame->next;\n \n@@ -1038,14 +1037,14 @@ get_frame_func_if_available (struct frame_info *this_frame, CORE_ADDR *pc)\n   if (next_frame->prev_func.status == CC_UNAVAILABLE)\n     {\n       *pc = -1;\n-      return 0;\n+      return false;\n     }\n   else\n     {\n       gdb_assert (next_frame->prev_func.status == CC_VALUE);\n \n       *pc = next_frame->prev_func.addr;\n-      return 1;\n+      return true;\n     }\n }\n \n@@ -1358,8 +1357,8 @@ get_frame_register_unsigned (struct frame_info *frame, int regnum)\n   return frame_unwind_register_unsigned (frame->next, regnum);\n }\n \n-int\n-read_frame_register_unsigned (struct frame_info *frame, int regnum,\n+bool\n+read_frame_register_unsigned (frame_info *frame, int regnum,\n \t\t\t      ULONGEST *val)\n {\n   struct value *regval = get_frame_register_value (frame, regnum);\n@@ -1372,10 +1371,10 @@ read_frame_register_unsigned (struct frame_info *frame, int regnum,\n       int size = register_size (gdbarch, VALUE_REGNUM (regval));\n \n       *val = extract_unsigned_integer (value_contents (regval), size, byte_order);\n-      return 1;\n+      return true;\n     }\n \n-  return 0;\n+  return false;\n }\n \n void\n@@ -1416,9 +1415,9 @@ put_frame_register (struct frame_info *frame, int regnum,\n \n    Returns 0 if the register value could not be found.  */\n \n-int\n-deprecated_frame_register_read (struct frame_info *frame, int regnum,\n-\t\t     gdb_byte *myaddr)\n+bool\n+deprecated_frame_register_read (frame_info *frame, int regnum,\n+\t\t\t\tgdb_byte *myaddr)\n {\n   int optimized;\n   int unavailable;\n@@ -1432,8 +1431,8 @@ deprecated_frame_register_read (struct frame_info *frame, int regnum,\n   return !optimized && !unavailable;\n }\n \n-int\n-get_frame_register_bytes (struct frame_info *frame, int regnum,\n+bool\n+get_frame_register_bytes (frame_info *frame, int regnum,\n \t\t\t  CORE_ADDR offset, int len, gdb_byte *myaddr,\n \t\t\t  int *optimizedp, int *unavailablep)\n {\n@@ -1482,7 +1481,7 @@ get_frame_register_bytes (struct frame_info *frame, int regnum,\n \t  frame_register (frame, regnum, optimizedp, unavailablep,\n \t\t\t  &lval, &addr, &realnum, myaddr);\n \t  if (*optimizedp || *unavailablep)\n-\t    return 0;\n+\t    return false;\n \t}\n       else\n \t{\n@@ -1495,8 +1494,9 @@ get_frame_register_bytes (struct frame_info *frame, int regnum,\n \t  if (*optimizedp || *unavailablep)\n \t    {\n \t      release_value (value);\n-\t      return 0;\n+\t      return false;\n \t    }\n+\n \t  memcpy (myaddr, value_contents_all (value) + offset, curr_len);\n \t  release_value (value);\n \t}\n@@ -1509,7 +1509,8 @@ get_frame_register_bytes (struct frame_info *frame, int regnum,\n \n   *optimizedp = 0;\n   *unavailablep = 0;\n-  return 1;\n+\n+  return true;\n }\n \n void\n@@ -1576,7 +1577,7 @@ create_sentinel_frame (struct program_space *pspace, struct regcache *regcache)\n      (the unwound PC is the same as the pc), so make it so.  */\n   frame->next = frame;\n   /* The sentinel frame has a special ID.  */\n-  frame->this_id.p = 1;\n+  frame->this_id.p = true;\n   frame->this_id.value = sentinel_frame_id;\n   if (frame_debug)\n     {\n@@ -1650,30 +1651,30 @@ get_current_frame (void)\n \n static struct frame_info *selected_frame;\n \n-int\n-has_stack_frames (void)\n+bool\n+has_stack_frames ()\n {\n   if (!target_has_registers || !target_has_stack || !target_has_memory)\n-    return 0;\n+    return false;\n \n   /* Traceframes are effectively a substitute for the live inferior.  */\n   if (get_traceframe_number () < 0)\n     {\n       /* No current inferior, no frame.  */\n       if (inferior_ptid == null_ptid)\n-\treturn 0;\n+\treturn false;\n \n       thread_info *tp = inferior_thread ();\n       /* Don't try to read from a dead thread.  */\n       if (tp->state == THREAD_EXITED)\n-\treturn 0;\n+\treturn false;\n \n       /* ... or from a spinning thread.  */\n       if (tp->executing)\n-\treturn 0;\n+\treturn false;\n     }\n \n-  return 1;\n+  return true;\n }\n \n /* Return the selected frame.  Always non-NULL (unless there isn't an\n@@ -1796,7 +1797,7 @@ create_new_frame (CORE_ADDR addr, CORE_ADDR pc)\n      based on the PC.  */\n   frame_unwind_find_by_frame (fi, &fi->prologue_cache);\n \n-  fi->this_id.p = 1;\n+  fi->this_id.p = true;\n   fi->this_id.value = frame_id_build (addr, pc);\n \n   if (frame_debug)\n@@ -2014,7 +2015,7 @@ get_prev_frame_always_1 (struct frame_info *this_frame)\n   if (this_frame->unwind == NULL)\n     frame_unwind_find_by_frame (this_frame, &this_frame->prologue_cache);\n \n-  this_frame->prev_p = 1;\n+  this_frame->prev_p = true;\n   this_frame->stop_reason = UNWIND_NO_REASON;\n \n   /* If we are unwinding from an inline frame, all of the below tests\n@@ -2249,34 +2250,36 @@ frame_debug_got_null_frame (struct frame_info *this_frame,\n \n /* Is this (non-sentinel) frame in the \"main\"() function?  */\n \n-static int\n-inside_main_func (struct frame_info *this_frame)\n+static bool\n+inside_main_func (frame_info *this_frame)\n {\n-  struct bound_minimal_symbol msymbol;\n-  CORE_ADDR maddr;\n+  if (symfile_objfile == nullptr)\n+    return false;\n+\n+  bound_minimal_symbol msymbol\n+    = lookup_minimal_symbol (main_name (), NULL, symfile_objfile);\n+  if (msymbol.minsym == nullptr)\n+    return false;\n \n-  if (symfile_objfile == 0)\n-    return 0;\n-  msymbol = lookup_minimal_symbol (main_name (), NULL, symfile_objfile);\n-  if (msymbol.minsym == NULL)\n-    return 0;\n   /* Make certain that the code, and not descriptor, address is\n      returned.  */\n-  maddr = gdbarch_convert_from_func_ptr_addr (get_frame_arch (this_frame),\n-\t\t\t\t\t      BMSYMBOL_VALUE_ADDRESS (msymbol),\n-\t\t\t\t\t      current_top_target ());\n+  CORE_ADDR maddr\n+    = gdbarch_convert_from_func_ptr_addr (get_frame_arch (this_frame),\n+\t\t\t\t\t  BMSYMBOL_VALUE_ADDRESS (msymbol),\n+\t\t\t\t\t  current_top_target ());\n+\n   return maddr == get_frame_func (this_frame);\n }\n \n /* Test whether THIS_FRAME is inside the process entry point function.  */\n \n-static int\n-inside_entry_func (struct frame_info *this_frame)\n+static bool\n+inside_entry_func (frame_info *this_frame)\n {\n   CORE_ADDR entry_point;\n \n   if (!entry_point_address_query (&entry_point))\n-    return 0;\n+    return false;\n \n   return get_frame_func (this_frame) == entry_point;\n }\n@@ -2419,8 +2422,8 @@ get_frame_pc (struct frame_info *frame)\n   return frame_unwind_pc (frame->next);\n }\n \n-int\n-get_frame_pc_if_available (struct frame_info *frame, CORE_ADDR *pc)\n+bool\n+get_frame_pc_if_available (frame_info *frame, CORE_ADDR *pc)\n {\n \n   gdb_assert (frame->next != NULL);\n@@ -2432,12 +2435,12 @@ get_frame_pc_if_available (struct frame_info *frame, CORE_ADDR *pc)\n   catch (const gdb_exception_error &ex)\n     {\n       if (ex.error == NOT_AVAILABLE_ERROR)\n-\treturn 0;\n+\treturn false;\n       else\n \tthrow;\n     }\n \n-  return 1;\n+  return true;\n }\n \n /* Return an address that falls within THIS_FRAME's code block.  */\n@@ -2502,8 +2505,8 @@ get_frame_address_in_block (struct frame_info *this_frame)\n   return pc;\n }\n \n-int\n-get_frame_address_in_block_if_available (struct frame_info *this_frame,\n+bool\n+get_frame_address_in_block_if_available (frame_info *this_frame,\n \t\t\t\t\t CORE_ADDR *pc)\n {\n \n@@ -2514,11 +2517,11 @@ get_frame_address_in_block_if_available (struct frame_info *this_frame,\n   catch (const gdb_exception_error &ex)\n     {\n       if (ex.error == NOT_AVAILABLE_ERROR)\n-\treturn 0;\n+\treturn false;\n       throw;\n     }\n \n-  return 1;\n+  return true;\n }\n \n symtab_and_line\n@@ -2634,11 +2637,12 @@ get_frame_args_address (struct frame_info *fi)\n /* Return true if the frame unwinder for frame FI is UNWINDER; false\n    otherwise.  */\n \n-int\n-frame_unwinder_is (struct frame_info *fi, const struct frame_unwind *unwinder)\n+bool\n+frame_unwinder_is (frame_info *fi, const frame_unwind *unwinder)\n {\n-  if (fi->unwind == NULL)\n+  if (fi->unwind == nullptr)\n     frame_unwind_find_by_frame (fi, &fi->prologue_cache);\n+\n   return fi->unwind == unwinder;\n }\n \n@@ -2716,12 +2720,12 @@ get_frame_memory_unsigned (struct frame_info *this_frame, CORE_ADDR addr,\n   return read_memory_unsigned_integer (addr, len, byte_order);\n }\n \n-int\n+bool\n safe_frame_unwind_memory (struct frame_info *this_frame,\n \t\t\t  CORE_ADDR addr, gdb_byte *buf, int len)\n {\n   /* NOTE: target_read_memory returns zero on success!  */\n-  return !target_read_memory (addr, buf, len);\n+  return target_read_memory (addr, buf, len) == 0;\n }\n \n /* Architecture methods.  */\n@@ -2749,7 +2753,7 @@ frame_unwind_arch (struct frame_info *next_frame)\n \tarch = get_frame_arch (next_frame);\n \n       next_frame->prev_arch.arch = arch;\n-      next_frame->prev_arch.p = 1;\n+      next_frame->prev_arch.p = true;\n       if (frame_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n \t\t\t    \"{ frame_unwind_arch (next_frame=%d) -> %s }\\n\",\n@@ -2779,7 +2783,7 @@ enum language\n get_frame_language (struct frame_info *frame)\n {\n   CORE_ADDR pc = 0;\n-  int pc_p = 0;\n+  bool pc_p = false;\n \n   gdb_assert (frame!= NULL);\n \n@@ -2795,7 +2799,7 @@ get_frame_language (struct frame_info *frame)\n   try\n     {\n       pc = get_frame_address_in_block (frame);\n-      pc_p = 1;\n+      pc_p = true;\n     }\n   catch (const gdb_exception_error &ex)\n     {"
    },
    {
      "sha": "1c6afad1ae954e72c50725aeb1f363339eba10cd",
      "filename": "gdb/frame.h",
      "status": "modified",
      "additions": 27,
      "deletions": 33,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/97916bfedfd8a1577028f850368fdc0f2aca7653/gdb/frame.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/97916bfedfd8a1577028f850368fdc0f2aca7653/gdb/frame.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.h?ref=97916bfedfd8a1577028f850368fdc0f2aca7653",
      "patch": "@@ -45,8 +45,8 @@\n    strongly hinting at its unsafeness)\n \n    safe_....(): Safer version of various functions, doesn't throw an\n-   error (leave this for later?).  Returns non-zero / non-NULL if the\n-   request succeeds, zero / NULL otherwize.\n+   error (leave this for later?).  Returns true / non-NULL if the request\n+   succeeds, false / NULL otherwise.\n \n    Suffixes:\n \n@@ -236,19 +236,16 @@ extern struct frame_id\n    as the special identifier address are set to indicate wild cards.  */\n extern struct frame_id frame_id_build_wild (CORE_ADDR stack_addr);\n \n-/* Returns non-zero when L is a valid frame (a valid frame has a\n-   non-zero .base).  The outermost frame is valid even without an\n-   ID.  */\n-extern int frame_id_p (struct frame_id l);\n+/* Returns true when L is a valid frame.  */\n+extern bool frame_id_p (frame_id l);\n \n-/* Returns non-zero when L is a valid frame representing a frame made up by GDB\n+/* Returns true when L is a valid frame representing a frame made up by GDB\n    without stack data representation in inferior, such as INLINE_FRAME or\n    TAILCALL_FRAME.  */\n-extern int frame_id_artificial_p (struct frame_id l);\n+extern bool frame_id_artificial_p (frame_id l);\n \n-/* Returns non-zero when L and R identify the same frame, or, if\n-   either L or R have a zero .func, then the same frame base.  */\n-extern int frame_id_eq (struct frame_id l, struct frame_id r);\n+/* Returns true when L and R identify the same frame.  */\n+extern bool frame_id_eq (frame_id l, frame_id r);\n \n /* Write the internal representation of a frame ID on the specified\n    stream.  */\n@@ -303,7 +300,7 @@ extern struct frame_info *get_current_frame (void);\n /* Does the current target interface have enough state to be able to\n    query the current inferior for frame info, and is the inferior in a\n    state where that is possible?  */\n-extern int has_stack_frames (void);\n+extern bool has_stack_frames ();\n \n /* Invalidates the frame cache (this function should have been called\n    invalidate_cached_frames).\n@@ -317,7 +314,7 @@ extern void reinit_frame_cache (void);\n /* On demand, create the selected frame and then return it.  If the\n    selected frame can not be created, this function prints then throws\n    an error.  When MESSAGE is non-NULL, use it for the error message,\n-   otherwize use a generic error message.  */\n+   otherwise use a generic error message.  */\n /* FIXME: cagney/2002-11-28: At present, when there is no selected\n    frame, this function always returns the current (inner most) frame.\n    It should instead, when a thread has previously had its frame\n@@ -367,8 +364,7 @@ extern CORE_ADDR get_frame_pc (struct frame_info *);\n /* Same as get_frame_pc, but return a boolean indication of whether\n    the PC is actually available, instead of throwing an error.  */\n \n-extern int get_frame_pc_if_available (struct frame_info *frame,\n-\t\t\t\t      CORE_ADDR *pc);\n+extern bool get_frame_pc_if_available (frame_info *frame, CORE_ADDR *pc);\n \n /* An address (not necessarily aligned to an instruction boundary)\n    that falls within THIS frame's code block.\n@@ -390,9 +386,8 @@ extern CORE_ADDR get_frame_address_in_block (struct frame_info *this_frame);\n    PC is unavailable, it will not be), instead of possibly throwing an\n    error trying to read an unavailable PC.  */\n \n-extern int\n-  get_frame_address_in_block_if_available (struct frame_info *this_frame,\n-\t\t\t\t\t   CORE_ADDR *pc);\n+extern bool get_frame_address_in_block_if_available (frame_info *this_frame,\n+\t\t\t\t\t\t     CORE_ADDR *pc);\n \n /* The frame's inner-most bound.  AKA the stack-pointer.  Confusingly\n    known as top-of-stack.  */\n@@ -409,7 +404,7 @@ extern CORE_ADDR get_frame_func (struct frame_info *fi);\n    will not be), instead of possibly throwing an error trying to read\n    an unavailable PC.  */\n \n-extern int get_frame_func_if_available (struct frame_info *fi, CORE_ADDR *);\n+extern bool get_frame_func_if_available (frame_info *fi, CORE_ADDR *);\n \n /* Closely related to the resume address, various symbol table\n    attributes that are determined by the PC.  Note that for a normal\n@@ -597,8 +592,8 @@ extern ULONGEST get_frame_register_unsigned (struct frame_info *frame,\n    get_frame_register_value, that do not throw if the result is\n    optimized out or unavailable.  */\n \n-extern int read_frame_register_unsigned (struct frame_info *frame,\n-\t\t\t\t\t int regnum, ULONGEST *val);\n+extern bool read_frame_register_unsigned (frame_info *frame,\n+\t\t\t\t\t  int regnum, ULONGEST *val);\n \n /* Get the value of the register that belongs to this FRAME.  This\n    function is a wrapper to the call sequence ``frame_register_unwind\n@@ -621,10 +616,10 @@ extern void put_frame_register (struct frame_info *frame, int regnum,\n    in frame FRAME, starting at OFFSET, into BUF.  If the register\n    contents are optimized out or unavailable, set *OPTIMIZEDP,\n    *UNAVAILABLEP accordingly.  */\n-extern int get_frame_register_bytes (struct frame_info *frame, int regnum,\n-\t\t\t\t     CORE_ADDR offset, int len,\n-\t\t\t\t     gdb_byte *myaddr,\n-\t\t\t\t     int *optimizedp, int *unavailablep);\n+extern bool get_frame_register_bytes (frame_info *frame, int regnum,\n+\t\t\t\t      CORE_ADDR offset, int len,\n+\t\t\t\t      gdb_byte *myaddr,\n+\t\t\t\t      int *optimizedp, int *unavailablep);\n \n /* Write LEN bytes to one or multiple registers starting with REGNUM\n    in frame FRAME, starting at OFFSET, into BUF.  */\n@@ -662,10 +657,10 @@ extern LONGEST get_frame_memory_signed (struct frame_info *this_frame,\n extern ULONGEST get_frame_memory_unsigned (struct frame_info *this_frame,\n \t\t\t\t\t   CORE_ADDR memaddr, int len);\n \n-/* Same as above, but return non-zero when the entire memory read\n-   succeeds, zero otherwize.  */\n-extern int safe_frame_unwind_memory (struct frame_info *this_frame,\n-\t\t\t\t     CORE_ADDR addr, gdb_byte *buf, int len);\n+/* Same as above, but return true zero when the entire memory read\n+   succeeds, false otherwise.  */\n+extern bool safe_frame_unwind_memory (frame_info *this_frame, CORE_ADDR addr,\n+\t\t\t\t      gdb_byte *buf, int len);\n \n /* Return this frame's architecture.  */\n extern struct gdbarch *get_frame_arch (struct frame_info *this_frame);\n@@ -772,8 +767,8 @@ extern void print_frame_info (const frame_print_options &fp_opts,\n \n extern struct frame_info *block_innermost_frame (const struct block *);\n \n-extern int deprecated_frame_register_read (struct frame_info *frame, int regnum,\n-\t\t\t\tgdb_byte *buf);\n+extern bool deprecated_frame_register_read (frame_info *frame, int regnum,\n+\t\t\t\t\t    gdb_byte *buf);\n \n /* From stack.c.  */\n \n@@ -907,8 +902,7 @@ extern struct frame_info *create_new_frame (CORE_ADDR base, CORE_ADDR pc);\n /* Return true if the frame unwinder for frame FI is UNWINDER; false\n    otherwise.  */\n \n-extern int frame_unwinder_is (struct frame_info *fi,\n-\t\t\t      const struct frame_unwind *unwinder);\n+extern bool frame_unwinder_is (frame_info *fi, const frame_unwind *unwinder);\n \n /* Return the language of FRAME.  */\n "
    }
  ]
}