{
  "sha": "611841bb1afc689becfab6dd490e1799aabf547d",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NjExODQxYmIxYWZjNjg5YmVjZmFiNmRkNDkwZTE3OTlhYWJmNTQ3ZA==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-08-10T10:20:44Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-09-07T11:44:08Z"
    },
    "message": "gdb: make thread_info::executing private\n\nRename thread_info::executing to thread_info::m_executing, and make it\nprivate.  Add a new get/set member functions, and convert GDB to make\nuse of these.\n\nThe only real change of interest in this patch is in thread.c where I\nhave deleted the helper function set_executing_thread, and now just\nuse the new set function thread_info::set_executing.  However, the old\nhelper function set_executing_thread included some code to reset the\nthread's stop_pc, so I moved this code into the new function\nthread_info::set_executing.  However, I don't believe there is\nanywhere that this results in a change of behaviour, previously the\nexecuting flag was always set true through a call to\nset_executing_thread anyway.",
    "tree": {
      "sha": "9408d2caedec7fd55131479e3bb2964ad7382515",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9408d2caedec7fd55131479e3bb2964ad7382515"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/611841bb1afc689becfab6dd490e1799aabf547d",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/611841bb1afc689becfab6dd490e1799aabf547d",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/611841bb1afc689becfab6dd490e1799aabf547d",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/611841bb1afc689becfab6dd490e1799aabf547d/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "9dc2f26777b07f9e5aa3220f7a680987ef79e75e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9dc2f26777b07f9e5aa3220f7a680987ef79e75e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/9dc2f26777b07f9e5aa3220f7a680987ef79e75e"
    }
  ],
  "stats": {
    "total": 103,
    "additions": 55,
    "deletions": 48
  },
  "files": [
    {
      "sha": "10b28c97be7dcb335e742ca25cf5998f76c5322e",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -1661,7 +1661,7 @@ watchpoint_in_thread_scope (struct watchpoint *b)\n   return (b->pspace == current_program_space\n \t  && (b->watchpoint_thread == null_ptid\n \t      || (inferior_ptid == b->watchpoint_thread\n-\t\t  && !inferior_thread ()->executing)));\n+\t\t  && !inferior_thread ()->executing ())));\n }\n \n /* Set watchpoint B to disp_del_at_next_stop, even including its possible\n@@ -4512,7 +4512,7 @@ get_bpstat_thread ()\n     return NULL;\n \n   thread_info *tp = inferior_thread ();\n-  if (tp->state == THREAD_EXITED || tp->executing)\n+  if (tp->state == THREAD_EXITED || tp->executing ())\n     return NULL;\n   return tp;\n }"
    },
    {
      "sha": "d28944075edc769934aa403fe277622295f296e1",
      "filename": "gdb/frame.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/frame.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -1789,7 +1789,7 @@ has_stack_frames ()\n \treturn false;\n \n       /* ... or from a spinning thread.  */\n-      if (tp->executing)\n+      if (tp->executing ())\n \treturn false;\n     }\n "
    },
    {
      "sha": "e6f383cca610e9afd0e7cc69e2114475d0105663",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 15,
      "deletions": 5,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -287,15 +287,19 @@ class thread_info : public refcounted_object,\n      if the thread does not have a user-given name.  */\n   char *name = NULL;\n \n-  /* True means the thread is executing.  Note: this is different\n-     from saying that there is an active target and we are stopped at\n-     a breakpoint, for instance.  This is a real indicator whether the\n-     thread is off and running.  */\n-  bool executing = false;\n+  bool executing () const\n+  { return m_executing; }\n+\n+  /* Set the thread's 'm_executing' field from EXECUTING, and if EXECUTING\n+     is true also clears the thread's stop_pc.  */\n+  void set_executing (bool executing);\n \n   bool resumed () const\n   { return m_resumed; }\n \n+  /* Set the thread's 'm_resumed' field from RESUMED.  The thread may also\n+     be added to (when RESUMED is true), or removed from (when RESUMED is\n+     false), the list of threads with a pending wait status.  */\n   void set_resumed (bool resumed);\n \n   /* Frontend view of the thread state.  Note that the THREAD_RUNNING/\n@@ -488,6 +492,12 @@ class thread_info : public refcounted_object,\n      the thread run.  */\n   bool m_resumed = false;\n \n+  /* True means the thread is executing.  Note: this is different\n+     from saying that there is an active target and we are stopped at\n+     a breakpoint, for instance.  This is a real indicator whether the\n+     thread is off and running.  */\n+  bool m_executing = false;\n+\n   /* State of inferior thread to restore after GDB is done with an inferior\n      call.  See `struct thread_suspend_state'.  */\n   thread_suspend_state m_suspend;"
    },
    {
      "sha": "e6ee49bc43de9fe98b80e1c241c9e771f971e214",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -2371,7 +2371,7 @@ proceed_after_attach (inferior *inf)\n   scoped_restore_current_thread restore_thread;\n \n   for (thread_info *thread : inf->non_exited_threads ())\n-    if (!thread->executing\n+    if (!thread->executing ()\n \t&& !thread->stop_requested\n \t&& thread->stop_signal () == GDB_SIGNAL_0)\n       {\n@@ -2644,7 +2644,7 @@ notice_new_inferior (thread_info *thr, bool leave_running, int from_tty)\n   /* When we \"notice\" a new inferior we need to do all the things we\n      would normally do if we had just attached to it.  */\n \n-  if (thr->executing)\n+  if (thr->executing ())\n     {\n       struct inferior *inferior = current_inferior ();\n "
    },
    {
      "sha": "bcab66487b09200852738fb94191661cc4d93a7f",
      "filename": "gdb/inflow.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/inflow.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/inflow.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inflow.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -525,7 +525,7 @@ child_interrupt (struct target_ops *self)\n   thread_info *resumed = NULL;\n   for (thread_info *thr : all_non_exited_threads ())\n     {\n-      if (thr->executing)\n+      if (thr->executing ())\n \t{\n \t  resumed = thr;\n \t  break;"
    },
    {
      "sha": "8e778576eabbeca26e934a52fc7cbc80c2bf23d7",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -862,7 +862,7 @@ static void\n proceed_after_vfork_done (thread_info *thread)\n {\n   if (thread->state == THREAD_RUNNING\n-      && !thread->executing\n+      && !thread->executing ()\n       && !thread->stop_requested\n       && thread->stop_signal () == GDB_SIGNAL_0)\n     {\n@@ -1885,15 +1885,15 @@ start_step_over (void)\n \n       if (tp->control.trap_expected\n \t  || tp->resumed ()\n-\t  || tp->executing)\n+\t  || tp->executing ())\n \t{\n \t  internal_error (__FILE__, __LINE__,\n \t\t\t  \"[%s] has inconsistent state: \"\n \t\t\t  \"trap_expected=%d, resumed=%d, executing=%d\\n\",\n \t\t\t  target_pid_to_str (tp->ptid).c_str (),\n \t\t\t  tp->control.trap_expected,\n \t\t\t  tp->resumed (),\n-\t\t\t  tp->executing);\n+\t\t\t  tp->executing ());\n \t}\n \n       infrun_debug_printf (\"resuming [%s] for step-over\",\n@@ -3197,7 +3197,7 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \t      {\n \t\tinfrun_debug_printf (\"[%s] resumed\",\n \t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n-\t\tgdb_assert (tp->executing || tp->has_pending_waitstatus ());\n+\t\tgdb_assert (tp->executing () || tp->has_pending_waitstatus ());\n \t\tcontinue;\n \t      }\n \n@@ -3329,7 +3329,7 @@ infrun_thread_stop_requested (ptid_t ptid)\n     {\n       if (tp->state != THREAD_RUNNING)\n \tcontinue;\n-      if (tp->executing)\n+      if (tp->executing ())\n \tcontinue;\n \n       /* Remove matching threads from the step-over queue, so\n@@ -3778,7 +3778,7 @@ prepare_for_detach (void)\n \t{\n \t  if (thr->displaced_step_state.in_progress ())\n \t    {\n-\t      if (thr->executing)\n+\t      if (thr->executing ())\n \t\t{\n \t\t  if (!thr->stop_requested)\n \t\t    {\n@@ -4806,7 +4806,7 @@ handle_one (const wait_one_event &event)\n \tt = add_thread (event.target, event.ptid);\n \n       t->stop_requested = 0;\n-      t->executing = 0;\n+      t->set_executing (false);\n       t->set_resumed (false);\n       t->control.may_range_step = 0;\n \n@@ -4947,7 +4947,7 @@ stop_all_threads (void)\n \t      if (!target_is_non_stop_p ())\n \t\tcontinue;\n \n-\t      if (t->executing)\n+\t      if (t->executing ())\n \t\t{\n \t\t  /* If already stopping, don't request a stop again.\n \t\t     We just haven't seen the notification yet.  */\n@@ -5091,7 +5091,7 @@ handle_no_resumed (struct execution_control_state *ecs)\n \n   for (thread_info *thread : all_non_exited_threads ())\n     {\n-      if (swap_terminal && thread->executing)\n+      if (swap_terminal && thread->executing ())\n \t{\n \t  if (thread->inf != curr_inf)\n \t    {\n@@ -5104,7 +5104,7 @@ handle_no_resumed (struct execution_control_state *ecs)\n \t}\n \n       if (!ignore_event\n-\t  && (thread->executing || thread->has_pending_waitstatus ()))\n+\t  && (thread->executing () || thread->has_pending_waitstatus ()))\n \t{\n \t  /* Either there were no unwaited-for children left in the\n \t     target at some point, but there are now, or some target\n@@ -5722,7 +5722,7 @@ restart_threads (struct thread_info *event_thread)\n \t{\n \t  infrun_debug_printf (\"restart threads: [%s] resumed\",\n \t\t\t      target_pid_to_str (tp->ptid).c_str ());\n-\t  gdb_assert (tp->executing || tp->has_pending_waitstatus ());\n+\t  gdb_assert (tp->executing () || tp->has_pending_waitstatus ());\n \t  continue;\n \t}\n \n@@ -5869,7 +5869,7 @@ finish_step_over (struct execution_control_state *ecs)\n \t     do_target_wait.  */\n \t  tp->set_resumed (true);\n \n-\t  gdb_assert (!tp->executing);\n+\t  gdb_assert (!tp->executing ());\n \n \t  regcache = get_thread_regcache (tp);\n \t  tp->set_stop_pc (regcache_read_pc (regcache));\n@@ -7419,7 +7419,7 @@ restart_after_all_stop_detach (process_stratum_target *proc_target)\n       /* If we have any thread that is already executing, then we\n \t don't need to resume the target -- it is already been\n \t resumed.  */\n-      if (thr->executing)\n+      if (thr->executing ())\n \treturn;\n \n       /* If we have a pending event to process, skip resuming the"
    },
    {
      "sha": "29ca62d2bc173970185a17ac575409b78e8139fd",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -1280,7 +1280,7 @@ get_detach_signal (struct lwp_info *lp)\n     {\n       struct thread_info *tp = find_thread_ptid (linux_target, lp->ptid);\n \n-      if (target_is_non_stop_p () && !tp->executing)\n+      if (target_is_non_stop_p () && !tp->executing ())\n \t{\n \t  if (tp->has_pending_waitstatus ())\n \t    signo = tp->pending_waitstatus ().value.sig;"
    },
    {
      "sha": "245939b6400754daadf7bd2a4fa50cedda2e6f84",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -1641,7 +1641,7 @@ thread_db_target::update_thread_list ()\n \tcontinue;\n \n       thread_info *thread = any_live_thread_of_inferior (inf);\n-      if (thread == NULL || thread->executing)\n+      if (thread == NULL || thread->executing ())\n \tcontinue;\n \n       /* It's best to avoid td_ta_thr_iter if possible.  That walks"
    },
    {
      "sha": "e2b9866d68ab9db8a3c38d769fe209431b1d5193",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -1998,7 +1998,7 @@ get_thread_current_frame_id (struct thread_info *tp)\n      For the former, EXECUTING is true and we're in wait, about to\n      move the thread.  Since we need to recompute the stack, we temporarily\n      set EXECUTING to false.  */\n-  executing = tp->executing;\n+  executing = tp->executing ();\n   set_executing (proc_target, inferior_ptid, false);\n \n   id = null_frame_id;"
    },
    {
      "sha": "d1c1bf523eda80e61b0e6c261f1b1db2a4e0ddf0",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -3815,7 +3815,7 @@ target_pass_ctrlc (void)\n \t{\n \t  /* A thread can be THREAD_STOPPED and executing, while\n \t     running an infcall.  */\n-\t  if (thr->state == THREAD_RUNNING || thr->executing)\n+\t  if (thr->state == THREAD_RUNNING || thr->executing ())\n \t    {\n \t      /* We can get here quite deep in target layers.  Avoid\n \t\t switching thread context or anything that would"
    },
    {
      "sha": "c95a9186681dfd217e330c4ec9c9b8678bf31abd",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 17,
      "deletions": 20,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/611841bb1afc689becfab6dd490e1799aabf547d/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/611841bb1afc689becfab6dd490e1799aabf547d/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=611841bb1afc689becfab6dd490e1799aabf547d",
      "patch": "@@ -319,6 +319,16 @@ thread_info::deletable () const\n \n /* See gdbthread.h.  */\n \n+void\n+thread_info::set_executing (bool executing)\n+{\n+  m_executing = executing;\n+  if (executing)\n+    this->set_stop_pc (~(CORE_ADDR) 0);\n+}\n+\n+/* See gdbthread.h.  */\n+\n void\n thread_info::set_resumed (bool resumed)\n {\n@@ -625,13 +635,13 @@ any_live_thread_of_inferior (inferior *inf)\n       curr_tp = inferior_thread ();\n       if (curr_tp->state == THREAD_EXITED)\n \tcurr_tp = NULL;\n-      else if (!curr_tp->executing)\n+      else if (!curr_tp->executing ())\n \treturn curr_tp;\n     }\n \n   for (thread_info *tp : inf->non_exited_threads ())\n     {\n-      if (!tp->executing)\n+      if (!tp->executing ())\n \treturn tp;\n \n       tp_executing = tp;\n@@ -841,24 +851,11 @@ set_running (process_stratum_target *targ, ptid_t ptid, bool running)\n     gdb::observers::target_resumed.notify (ptid);\n }\n \n-\n-/* Helper for set_executing.  Set's the thread's 'executing' field\n-   from EXECUTING, and if EXECUTING is true also clears the thread's\n-   stop_pc.  */\n-\n-static void\n-set_executing_thread (thread_info *thr, bool executing)\n-{\n-  thr->executing = executing;\n-  if (executing)\n-    thr->set_stop_pc (~(CORE_ADDR) 0);\n-}\n-\n void\n set_executing (process_stratum_target *targ, ptid_t ptid, bool executing)\n {\n   for (thread_info *tp : all_non_exited_threads (targ, ptid))\n-    set_executing_thread (tp, executing);\n+    tp->set_executing (executing);\n \n   /* It only takes one running thread to spawn more threads.  */\n   if (executing)\n@@ -895,7 +892,7 @@ finish_thread_state (process_stratum_target *targ, ptid_t ptid)\n   bool any_started = false;\n \n   for (thread_info *tp : all_non_exited_threads (targ, ptid))\n-    if (set_running_thread (tp, tp->executing))\n+    if (set_running_thread (tp, tp->executing ()))\n       any_started = true;\n \n   if (any_started)\n@@ -922,7 +919,7 @@ validate_registers_access (void)\n      at the prompt) when a thread is not executing for some internal\n      reason, but is marked running from the user's perspective.  E.g.,\n      the thread is waiting for its turn in the step-over queue.  */\n-  if (tp->executing)\n+  if (tp->executing ())\n     error (_(\"Selected thread is running.\"));\n }\n \n@@ -940,7 +937,7 @@ can_access_registers_thread (thread_info *thread)\n     return false;\n \n   /* ... or from a spinning thread.  FIXME: see validate_registers_access.  */\n-  if (thread->executing)\n+  if (thread->executing ())\n     return false;\n \n   return true;\n@@ -1997,7 +1994,7 @@ update_threads_executing (void)\n \n       for (thread_info *tp : inf->non_exited_threads ())\n \t{\n-\t  if (tp->executing)\n+\t  if (tp->executing ())\n \t    {\n \t      targ->threads_executing = true;\n \t      return;"
    }
  ]
}