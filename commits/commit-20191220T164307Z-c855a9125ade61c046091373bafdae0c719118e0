{
  "sha": "c855a9125ade61c046091373bafdae0c719118e0",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Yzg1NWE5MTI1YWRlNjFjMDQ2MDkxMzczYmFmZGFlMGM3MTkxMThlMA==",
  "commit": {
    "author": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2019-12-20T16:43:07Z"
    },
    "committer": {
      "name": "Tankut Baris Aktemur",
      "email": "tankut.baris.aktemur@intel.com",
      "date": "2019-12-20T16:43:07Z"
    },
    "message": "testsuite, cp: increase the coverage of testing pass-by-ref arguments\n\nExtend testcases for GDB's infcall of call-by-value functions that\ntake aggregate values as parameters.  In particular, existing test has\nbeen substantially extended with class definitions whose definitions\nof copy constructor, destructor, and move constructor functions are a\ncombination of\n\n(1) explicitly defined by the user,\n(2) defaulted inside the class declaration,\n(3) defaulted outside the class declaration,\n(4) deleted\n(5) not defined in the source.\n\nFor each combination, a small and a large class is generated as well\nas a derived class and a container class.  Additionally, the following\nmanually-written cases are provided:\n\n- a dynamic class (i.e. class with a virtual method)\n- classes that contain an array field\n- a class whose copy ctor is inlined\n- a class whose destructor is deleted\n- classes with multiple copy and/or move ctors\n\nTest cases check whether GDB makes the right decision to pass an\nobject by value or implicitly by reference, whether really a copy of\nthe argument is passed, and whether the copy constructor and\ndestructor of the clone of the argument are invoked properly.\n\nThe input program pass-by-ref.cc is generated in the test's output\ndirectory.  The input program pass-by-ref-2.cc is manually-written.\n\nTests have been verified on the X86_64 architecture with\nGCC 7.4.0, 8.2.0, and 9.2.1.\n\ngdb/testsuite/ChangeLog:\n2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n\n\t* gdb.cp/pass-by-ref.cc: Delete.  Generated in the output\n\tdirectory instead.\n\t* gdb.cp/pass-by-ref.exp: Extend with more cases.\n\t* gdb.cp/pass-by-ref-2.cc: New file.\n\t* gdb.cp/pass-by-ref-2.exp: New file.\n\nChange-Id: Ie8ab1f260c6ad5ee4eb34b2c1597ce24af04abb6",
    "tree": {
      "sha": "334b33314162c04803fe504a508c52e0724222e7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/334b33314162c04803fe504a508c52e0724222e7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/c855a9125ade61c046091373bafdae0c719118e0",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c855a9125ade61c046091373bafdae0c719118e0",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/c855a9125ade61c046091373bafdae0c719118e0",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c855a9125ade61c046091373bafdae0c719118e0/comments",
  "author": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "barisaktemur",
    "id": 55686642,
    "node_id": "MDQ6VXNlcjU1Njg2NjQy",
    "avatar_url": "https://avatars.githubusercontent.com/u/55686642?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/barisaktemur",
    "html_url": "https://github.com/barisaktemur",
    "followers_url": "https://api.github.com/users/barisaktemur/followers",
    "following_url": "https://api.github.com/users/barisaktemur/following{/other_user}",
    "gists_url": "https://api.github.com/users/barisaktemur/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/barisaktemur/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/barisaktemur/subscriptions",
    "organizations_url": "https://api.github.com/users/barisaktemur/orgs",
    "repos_url": "https://api.github.com/users/barisaktemur/repos",
    "events_url": "https://api.github.com/users/barisaktemur/events{/privacy}",
    "received_events_url": "https://api.github.com/users/barisaktemur/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "099a6354dab7e74c990501929f383394fc8efd02",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/099a6354dab7e74c990501929f383394fc8efd02",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/099a6354dab7e74c990501929f383394fc8efd02"
    }
  ],
  "stats": {
    "total": 885,
    "additions": 799,
    "deletions": 86
  },
  "files": [
    {
      "sha": "c93edc6fff3f1710020a57ae9aa6b10d207ff15d",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c855a9125ade61c046091373bafdae0c719118e0/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c855a9125ade61c046091373bafdae0c719118e0/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=c855a9125ade61c046091373bafdae0c719118e0",
      "patch": "@@ -1,3 +1,11 @@\n+2019-12-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n+\n+\t* gdb.cp/pass-by-ref.cc: Delete.  Generated in the output\n+\tdirectory instead.\n+\t* gdb.cp/pass-by-ref.exp: Extend with more cases.\n+\t* gdb.cp/pass-by-ref-2.cc: New file.\n+\t* gdb.cp/pass-by-ref-2.exp: New file.\n+\n 2019-12-20  Tom Tromey  <tom@tromey.com>\n \n \t* gdb.tui/list-before.exp: New file."
    },
    {
      "sha": "1cd5a163c91842731342e980227258069c321e45",
      "filename": "gdb/testsuite/gdb.cp/pass-by-ref-2.cc",
      "status": "added",
      "additions": 295,
      "deletions": 0,
      "changes": 295,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c855a9125ade61c046091373bafdae0c719118e0/gdb/testsuite/gdb.cp/pass-by-ref-2.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c855a9125ade61c046091373bafdae0c719118e0/gdb/testsuite/gdb.cp/pass-by-ref-2.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/pass-by-ref-2.cc?ref=c855a9125ade61c046091373bafdae0c719118e0",
      "patch": "@@ -0,0 +1,295 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2019 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+class ByVal {\n+public:\n+  ByVal (void);\n+\n+  int x;\n+};\n+\n+ByVal::ByVal (void)\n+{\n+  x = 2;\n+}\n+\n+class ByRef {\n+public:\n+  ByRef (void);\n+\n+  ByRef (const ByRef &rhs);\n+\n+  int x;\n+};\n+\n+ByRef::ByRef (void)\n+{\n+  x = 2;\n+}\n+\n+ByRef::ByRef (const ByRef &rhs)\n+{\n+  x = 3; /* ByRef-cctor */\n+}\n+\n+class ArrayContainerByVal {\n+public:\n+  ByVal items[2];\n+};\n+\n+int\n+cbvArrayContainerByVal (ArrayContainerByVal arg)\n+{\n+  arg.items[0].x += 4;  // intentionally modify\n+  return arg.items[0].x;\n+}\n+\n+class ArrayContainerByRef {\n+public:\n+  ByRef items[2];\n+};\n+\n+int\n+cbvArrayContainerByRef (ArrayContainerByRef arg)\n+{\n+  arg.items[0].x += 4;  // intentionally modify\n+  return arg.items[0].x;\n+}\n+\n+class DynamicBase {\n+public:\n+  DynamicBase (void);\n+\n+  virtual int get (void);\n+\n+  int x;\n+};\n+\n+DynamicBase::DynamicBase (void)\n+{\n+  x = 2;\n+}\n+\n+int\n+DynamicBase::get (void)\n+{\n+  return 42;\n+}\n+\n+class Dynamic : public DynamicBase {\n+public:\n+  virtual int get (void);\n+};\n+\n+int\n+Dynamic::get (void)\n+{\n+  return 9999;\n+}\n+\n+int\n+cbvDynamic (DynamicBase arg)\n+{\n+  arg.x += 4;  // intentionally modify\n+  return arg.x + arg.get ();\n+}\n+\n+class Inlined {\n+public:\n+  Inlined (void);\n+\n+  __attribute__((always_inline))\n+  Inlined (const Inlined &rhs)\n+  {\n+    x = 3;\n+  }\n+\n+  int x;\n+};\n+\n+Inlined::Inlined (void)\n+{\n+  x = 2;\n+}\n+\n+int\n+cbvInlined (Inlined arg)\n+{\n+  arg.x += 4;  // intentionally modify\n+  return arg.x;\n+}\n+\n+class DtorDel {\n+public:\n+  DtorDel (void);\n+\n+  ~DtorDel (void) = delete;\n+\n+  int x;\n+};\n+\n+DtorDel::DtorDel (void)\n+{\n+  x = 2;\n+}\n+\n+int\n+cbvDtorDel (DtorDel arg)\n+{\n+  // Calling this method should be rejected\n+  return arg.x;\n+}\n+\n+class FourCCtor {\n+public:\n+  FourCCtor (void);\n+\n+  FourCCtor (FourCCtor &rhs);\n+  FourCCtor (const FourCCtor &rhs);\n+  FourCCtor (volatile FourCCtor &rhs);\n+  FourCCtor (const volatile FourCCtor &rhs);\n+\n+  int x;\n+};\n+\n+FourCCtor::FourCCtor (void)\n+{\n+  x = 2;\n+}\n+\n+FourCCtor::FourCCtor (FourCCtor &rhs)\n+{\n+  x = 3;\n+}\n+\n+FourCCtor::FourCCtor (const FourCCtor &rhs)\n+{\n+  x = 4;\n+}\n+\n+FourCCtor::FourCCtor (volatile FourCCtor &rhs)\n+{\n+  x = 5;\n+}\n+\n+FourCCtor::FourCCtor (const volatile FourCCtor &rhs)\n+{\n+  x = 6;\n+}\n+\n+int\n+cbvFourCCtor (FourCCtor arg)\n+{\n+  arg.x += 10;  // intentionally modify\n+  return arg.x;\n+}\n+\n+class TwoMCtor {\n+public:\n+  TwoMCtor (void);\n+\n+  /* Even though one move ctor is defaulted, the other\n+     is explicit.  */\n+  TwoMCtor (const TwoMCtor &&rhs);\n+  TwoMCtor (TwoMCtor &&rhs) = default;\n+\n+  int x;\n+};\n+\n+TwoMCtor::TwoMCtor (void)\n+{\n+  x = 2;\n+}\n+\n+TwoMCtor::TwoMCtor (const TwoMCtor &&rhs)\n+{\n+  x = 3;\n+}\n+\n+int\n+cbvTwoMCtor (TwoMCtor arg)\n+{\n+  arg.x += 10;  // intentionally modify\n+  return arg.x;\n+}\n+\n+class TwoMCtorAndCCtor {\n+public:\n+  TwoMCtorAndCCtor (void);\n+\n+  TwoMCtorAndCCtor (const TwoMCtorAndCCtor &rhs) = default;\n+\n+  /* Even though one move ctor is defaulted, the other\n+     is explicit.  This makes the type pass-by-ref.  */\n+  TwoMCtorAndCCtor (const TwoMCtorAndCCtor &&rhs);\n+  TwoMCtorAndCCtor (TwoMCtorAndCCtor &&rhs) = default;\n+\n+  int x;\n+};\n+\n+TwoMCtorAndCCtor::TwoMCtorAndCCtor (void)\n+{\n+  x = 2;\n+}\n+\n+TwoMCtorAndCCtor::TwoMCtorAndCCtor (const TwoMCtorAndCCtor &&rhs)\n+{\n+  x = 4;\n+}\n+\n+int\n+cbvTwoMCtorAndCCtor (TwoMCtorAndCCtor arg)\n+{\n+  arg.x += 10;  // intentionally modify\n+  return arg.x;\n+}\n+\n+ArrayContainerByVal arrayContainerByVal;\n+ArrayContainerByRef arrayContainerByRef;\n+Dynamic dynamic;\n+Inlined inlined;\n+// Cannot stack-allocate DtorDel\n+DtorDel *dtorDel;\n+FourCCtor fourCctor_c0v0;\n+const FourCCtor fourCctor_c1v0;\n+volatile FourCCtor fourCctor_c0v1;\n+const volatile FourCCtor fourCctor_c1v1;\n+TwoMCtor twoMctor;\n+TwoMCtorAndCCtor twoMctorAndCctor;\n+\n+int\n+main (void)\n+{\n+  int v;\n+  dtorDel = new DtorDel;\n+  /* Explicitly call the cbv function to make sure the compiler\n+     will not omit any code in the binary.  */\n+  v = cbvArrayContainerByVal (arrayContainerByVal);\n+  v = cbvArrayContainerByRef (arrayContainerByRef);\n+  v = cbvDynamic (dynamic);\n+  v = cbvInlined (inlined);\n+  v = cbvFourCCtor (fourCctor_c0v0);\n+  v = cbvFourCCtor (fourCctor_c1v0);\n+  v = cbvFourCCtor (fourCctor_c0v1);\n+  v = cbvFourCCtor (fourCctor_c1v1);\n+  /* v = cbvTwoMCtor (twoMctor); */ // This is illegal, cctor is deleted\n+  v = cbvTwoMCtorAndCCtor (twoMctorAndCctor);\n+\n+  /* stop here */\n+\n+  return 0;\n+}"
    },
    {
      "sha": "7cce88684c66eb098578f873e6c512b8411221a0",
      "filename": "gdb/testsuite/gdb.cp/pass-by-ref-2.exp",
      "status": "added",
      "additions": 114,
      "deletions": 0,
      "changes": 114,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c855a9125ade61c046091373bafdae0c719118e0/gdb/testsuite/gdb.cp/pass-by-ref-2.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c855a9125ade61c046091373bafdae0c719118e0/gdb/testsuite/gdb.cp/pass-by-ref-2.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/pass-by-ref-2.exp?ref=c855a9125ade61c046091373bafdae0c719118e0",
      "patch": "@@ -0,0 +1,114 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Check that GDB can call C++ functions whose parameters have\n+# object type, and are either passed by value or implicitly by reference.\n+#\n+# This is a companion test to pass-by-ref.exp.  In this test, the input\n+# is manually-written.  In pass-by-ref.exp, the test input is generated.\n+#\n+# We include tests for classes that\n+# - contain arrays as fields,\n+# - are dynamic (i.e. have virtual methods)\n+# - have inlined copy ctor\n+# - have deleted destructor\n+\n+if {[skip_cplus_tests]} {\n+    untested \"c++ test skipped\"\n+    continue\n+}\n+\n+standard_testfile .cc\n+\n+set options {debug c++ additional_flags=-std=c++11}\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile $options]} {\n+    return -1\n+}\n+\n+if {![runto_main]} {\n+    untested \"failed to run to main\"\n+    return -1\n+}\n+\n+set bp_location [gdb_get_line_number \"stop here\"]\n+gdb_breakpoint $bp_location\n+gdb_continue_to_breakpoint \"end of main\" \".*return .*;\"\n+\n+gdb_test \"print cbvArrayContainerByVal (arrayContainerByVal)\" \"6\" \\\n+    \"call cbvArrayContainerByVal\"\n+gdb_test \"print arrayContainerByVal.items\\[0\\].x\" \"2\" \\\n+    \"cbv argument 'arrayContainerByVal' should not change\"\n+\n+gdb_test \"print cbvArrayContainerByRef (arrayContainerByRef)\" \"7\" \\\n+    \"call cbvArrayContainerByRef\"\n+gdb_test \"print arrayContainerByRef.items\\[0\\].x\" \"2\" \\\n+    \"cbv argument 'arrayContainerByRef' should not change\"\n+\n+gdb_test \"print cbvDynamic (dynamic)\" \"48\" \\\n+    \"call cbvDynamic\"\n+gdb_test \"print dynamic.x\" \"2\" \\\n+    \"cbv argument 'dynamic' should not change\"\n+\n+set sig \"\\\"Inlined\\:\\:Inlined\\\\(.*Inlined const\\&\\\\)\\\"\"\n+gdb_test \"print cbvInlined (inlined)\" \\\n+    \"expression cannot be evaluated .* \\\\(maybe inlined\\\\?\\\\)\"\n+\n+gdb_test \"print cbvDtorDel (*dtorDel)\" \\\n+    \".* cannot be evaluated .* 'DtorDel' is not destructible\" \\\n+    \"type not destructible\"\n+\n+# Test that GDB calls the correct copy ctor\n+gdb_test \"print cbvFourCCtor (fourCctor_c0v0)\" \"13\" \\\n+    \"call cbvFourCCtor (c0v0)\"\n+gdb_test \"print fourCctor_c0v0.x\" \"2\" \\\n+    \"cbv argument 'twoCctor_c0v0' should not change\"\n+\n+gdb_test \"print cbvFourCCtor (fourCctor_c1v0)\" \"14\" \\\n+    \"call cbvFourCCtor (c1v0)\"\n+gdb_test \"print fourCctor_c1v0.x\" \"2\" \\\n+    \"cbv argument 'twoCctor_c1v0' should not change\"\n+\n+gdb_test \"print cbvFourCCtor (fourCctor_c0v1)\" \"15\" \\\n+    \"call cbvFourCCtor (c0v1)\"\n+gdb_test \"print fourCctor_c0v1.x\" \"2\" \\\n+    \"cbv argument 'twoCctor_c0v1' should not change\"\n+\n+gdb_test \"print cbvFourCCtor (fourCctor_c1v1)\" \"16\" \\\n+    \"call cbvFourCCtor (c1v1)\"\n+gdb_test \"print fourCctor_c1v1.x\" \"2\" \\\n+    \"cbv argument 'twoCctor_c1v1' should not change\"\n+\n+gdb_test \"print cbvTwoMCtor (twoMctor)\" \\\n+    \".* cannot be evaluated .* 'TwoMCtor' is not copy constructible\" \\\n+    \"copy ctor is implicitly deleted\"\n+\n+gdb_test \"print cbvTwoMCtorAndCCtor (twoMctorAndCctor)\" \"12\" \\\n+    \"call cbvTwoMCtorAndCCtor\"\n+gdb_test \"print twoMctorAndCctor.x\" \"2\" \\\n+    \"cbv argument 'twoMctorAndCtor' should not change\"\n+\n+# Test that we get a breakpoint from the cctor during infcall and\n+# we can examine arguments.  This is a test that the dummy frame\n+# of the copy constructor is set up correctly by the infcall mechanism.\n+set bp_location [gdb_get_line_number \"ByRef-cctor\"]\n+gdb_breakpoint $bp_location\n+gdb_test \"print cbvArrayContainerByRef (arrayContainerByRef)\" \\\n+    \".*The program being debugged stopped.*\" \\\n+    \"call cbvArrayContainerByRef with BP\"\n+gdb_test \"backtrace\" [multi_line \\\n+    \"#0  ByRef\\:\\:ByRef .* at .*$srcfile:$bp_location\" \\\n+    \"#1  .* ArrayContainerByRef::ArrayContainerByRef .*\" \\\n+    \"#2  <function called from gdb>\" \\\n+    \"#3  main.*\"]"
    },
    {
      "sha": "bbe450a0f711ca809ad77966d7f247783b26d86c",
      "filename": "gdb/testsuite/gdb.cp/pass-by-ref.cc",
      "status": "removed",
      "additions": 0,
      "deletions": 79,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/099a6354dab7e74c990501929f383394fc8efd02/gdb/testsuite/gdb.cp/pass-by-ref.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/099a6354dab7e74c990501929f383394fc8efd02/gdb/testsuite/gdb.cp/pass-by-ref.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/pass-by-ref.cc?ref=099a6354dab7e74c990501929f383394fc8efd02",
      "patch": "@@ -1,79 +0,0 @@\n-/* This testcase is part of GDB, the GNU debugger.\n-\n-   Copyright 2007-2019 Free Software Foundation, Inc.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-class Obj {\n-public:\n-  Obj ();\n-  Obj (const Obj &);\n-  ~Obj ();\n-  int var[2];\n-};\n-\n-int foo (Obj arg)\n-{\n-  return arg.var[0] + arg.var[1];\n-}\n-\n-Obj::Obj ()\n-{\n-  var[0] = 1;\n-  var[1] = 2;\n-}\n-\n-Obj::Obj (const Obj &obj)\n-{\n-  var[0] = obj.var[0];\n-  var[1] = obj.var[1];\n-}\n-\n-Obj::~Obj ()\n-{\n-\n-}\n-\n-struct Derived : public Obj\n-{\n-  int other;\n-};\n-\n-int blap (Derived arg)\n-{\n-  return foo (arg);\n-}\n-\n-struct Container\n-{\n-  Obj obj;\n-};\n-\n-int blip (Container arg)\n-{\n-  return foo (arg.obj);\n-}\n-\n-Obj global_obj;\n-Derived global_derived;\n-Container global_container;\n-\n-int\n-main ()\n-{\n-  int bar = foo (global_obj);\n-  blap (global_derived);\n-  blip (global_container);\n-  return bar;\n-}"
    },
    {
      "sha": "f44be77f0f32325475b36f9962c4d791a393b121",
      "filename": "gdb/testsuite/gdb.cp/pass-by-ref.exp",
      "status": "modified",
      "additions": 382,
      "deletions": 7,
      "changes": 389,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/c855a9125ade61c046091373bafdae0c719118e0/gdb/testsuite/gdb.cp/pass-by-ref.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/c855a9125ade61c046091373bafdae0c719118e0/gdb/testsuite/gdb.cp/pass-by-ref.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.cp/pass-by-ref.exp?ref=c855a9125ade61c046091373bafdae0c719118e0",
      "patch": "@@ -14,20 +14,395 @@\n # along with this program.  If not, see <http://www.gnu.org/licenses/>.\n \n # Check that GDB can call C++ functions whose parameters have\n-# object type, but are passed by reference.\n+# object type, and are either passed by value or implicitly by reference.\n+#\n+# Suppose F is a function that has a call-by-value parameter whose\n+# type is class C.  When calling F with an argument A, a copy of A should\n+# be created and passed to F.  If C is a trivially-copyable type, A can\n+# be copied by a straightforward memory copy.  However, roughly speaking,\n+# if C has a user-defined copy constructor and/or a user-defined\n+# destructor, the copy ctor should be used to initialize the copy of A\n+# before calling F, and a reference to that copy is passed to F.  After\n+# the function returns, the destructor should be called to destruct the\n+# copy.  In this case, C is said to be a 'pass-by-reference' type.\n+# Determining whether C is pass-by-ref depends on\n+# how the copy ctor, destructor, and the move ctor of C are defined.\n+# First of all, C is not copy constructible if its copy constructor is\n+# explicitly or implicitly deleted.  In this case, it would be illegal\n+# to pass values of type C to a function.  C is pass-by-value, if all of\n+# its copy ctor, dtor, and move ctor are trivially defined.\n+# Otherwise, it is pass-by-ref.\n+#\n+# To cover the many possible combinations, this test generates classes\n+# that contain three special functions:\n+#   (1) a copy constructor,\n+#   (2) a destructor, and\n+#   (3) a move constructor.\n+# A special function is in one of the following states:\n+#  * explicit: The function is explicitly defined by the user.\n+#  * defaultedIn: The function is defaulted inside the class decl,\n+#      using the 'default' keyword.\n+#  * defaultedOut: The function is declared inside the class decl,\n+#      and defaulted outside using the 'default' keyword.\n+#  * deleted: The function is explicitly deleted by the user,\n+#      using the 'delete' keyword.\n+#  * absent: The function is not declared by the user (i.e. it does not\n+#      exist in the source.  The compiler generates (or deletes) the\n+#      definition in this case.\n+#\n+# The C++ ABI decides if a class is pass-by-value or pass-by-ref\n+# (i.e.  trivially copyable or not) first at the language level, based\n+# on the state of the special functions.  Then, at the target level, a\n+# class may be determined to be pass-by-ref because of its size\n+# (e.g.  if it is too large to fit on registers).  For this reason, this\n+# test generates both a small and a large version for the same\n+# combination of special function states.\n+#\n+# A class is not trivially-copyable if a base class or a field is not\n+# trivially-copyable, even though the class definition itself seems\n+# trivial.  To test these cases, we also generate derived classes and\n+# container classes.\n+#\n+# The generated code is placed in the test output directory.\n+#\n+# The companion test file pass-by-ref-2.exp also contains\n+# manually-written cases.\n \n-if { [skip_cplus_tests] } { continue }\n+if {[skip_cplus_tests]} {\n+    untested \"c++ test skipped\"\n+    continue\n+}\n \n+# The program source is generated in the output directory.\n+# We use standard_testfile here to set convenience variables.\n standard_testfile .cc\n \n-if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile {debug c++}]} {\n+# Some constant values used when generating the source\n+\n+set SMALL    2\n+set LARGE    150\n+set ORIGINAL 2\n+set CUSTOM   3\n+set ADDED    4\n+set TRACE    5\n+\n+\n+# Return 1 if the class whose special function states are STATES\n+# is copyable.  Otherwise return 0.\n+\n+proc is_copy_constructible { states } {\n+    set cctor [lindex $states 0]\n+    set dtor  [lindex $states 1]\n+    set mctor [lindex $states 2]\n+\n+    if {$cctor == \"deleted\" || ($cctor == \"absent\" && $mctor != \"absent\")} {\n+\treturn 0\n+    }\n+    return 1\n+}\n+\n+# Generate a declaration and an out-of-class definition for a function\n+# with the provided signature.  The STATE should be one of the following:\n+# - explicit, defaultedIn, defaultedOut, deleted, absent\n+\n+proc generate_member_function { classname signature length state } {\n+    set declaration \"\"\n+    set definition \"\"\n+\n+    global CUSTOM\n+    global TRACE\n+\n+    switch $state {\n+\texplicit {\n+\t    set declaration \"$signature;\\n\"\n+\t    set definition \"$classname\\:\\:$signature\n+                            {\n+                              data\\[0\\] = $CUSTOM;\n+                              data\\[[expr $length - 1]\\] = $CUSTOM;\n+                              tracer = $TRACE;\n+                            }\\n\"\n+\t}\n+\tdefaultedIn {\n+\t    set declaration \"$signature = default;\\n\"\n+\t}\n+\tdefaultedOut {\n+\t    set declaration \"$signature;\\n\"\n+\t    set definition \"$classname\\:\\:$signature = default;\\n\"\n+\t}\n+\tdeleted {\n+\t    set declaration \"$signature = delete;\\n\"\n+\t}\n+\tdefault {\n+\t    # function is not user-defined in this case\n+\t}\n+    }\n+\n+    return [list $declaration $definition]\n+}\n+\n+# Generate a C++ class with the given CLASSNAME and LENGTH-many\n+# integer elements.  The STATES is an array of 3 items\n+# containing the desired state of the special functions\n+# in this order:\n+# copy constructor, destructor, move constructor\n+\n+proc generate_class { classname length states } {\n+    set declarations \"\"\n+    set definitions \"\"\n+    set classname \"${classname}_[join $states _]\"\n+\n+    for {set i 0} {$i < [llength $states]} {incr i} {\n+\tset sig \"\"\n+\tswitch $i {\n+\t    0 {set sig \"$classname (const $classname \\&rhs)\"}\n+\t    1 {set sig \"\\~$classname (void)\"}\n+\t    2 {set sig \"$classname ($classname \\&\\&rhs)\"}\n+\t}\n+\n+\tset state [lindex $states $i]\n+\tset code [generate_member_function $classname $sig $length $state]\n+\tappend declarations [lindex $code 0]\n+\tappend definitions [lindex $code 1]\n+    }\n+\n+    global ORIGINAL\n+\n+    return \"\n+    /*** C++ class $classname ***/\n+    class ${classname} {\n+    public:\n+        $classname (void);\n+        $declarations\n+\n+        int data\\[$length\\];\n+    };\n+\n+    $classname\\:\\:$classname (void)\n+    {\n+        data\\[0\\] = $ORIGINAL;\n+        data\\[[expr $length - 1]\\] = $ORIGINAL;\n+    }\n+\n+    $definitions\n+\n+    $classname ${classname}_var; /* global var */\n+\n+    template int cbv<$classname> ($classname arg);\"\n+}\n+\n+# Generate a small C++ class\n+\n+proc generate_small_class { states } {\n+    global SMALL\n+    return [generate_class Small $SMALL $states];\n+}\n+\n+# Generate a large C++ class\n+\n+proc generate_large_class { states } {\n+    global LARGE\n+    return [generate_class Large $LARGE $states];\n+}\n+\n+# Generate a class that derives from a small class\n+\n+proc generate_derived_class { states } {\n+    set base \"Small_[join $states _]\"\n+    set classname \"Derived_[join $states _]\"\n+\n+    return \"\n+    /*** Class derived from $base ***/\n+    class $classname : public $base {\n+    public:\n+    };\n+\n+    $classname ${classname}_var; /* global var */\n+\n+    template int cbv<$classname> ($classname arg);\"\n+}\n+\n+# Generate a class that contains a small class item\n+\n+proc generate_container_class { states } {\n+    set contained \"Small_[join $states _]\"\n+    set classname \"Container_[join $states _]\"\n+\n+    return \"\n+    /*** Class that contains $contained ***/\n+    class $classname {\n+    public:\n+        $contained item;\n+    };\n+\n+    $classname ${classname}_var; /* global var */\n+\n+    template int cbv_container<$classname> ($classname arg);\"\n+}\n+\n+# Generate useful statements that use a class in the debugee program\n+\n+proc generate_stmts { classprefix states {cbvfun \"cbv\"}} {\n+    set classname \"${classprefix}_[join $states _]\"\n+\n+    # Having an explicit call to the cbv function in the debugee program\n+    # ensures that the compiler will emit necessary function in the binary.\n+    if {[is_copy_constructible $states]} {\n+\tset cbvcall \"$cbvfun<$classname> (${classname}_var);\\n\"\n+    } else {\n+\tset cbvcall \"\"\n+    }\n+\n+    return \"$cbvcall\"\n+}\n+\n+# Generate the complete debugee program\n+\n+proc generate_program { classes stmts } {\n+    global ADDED\n+\n+    return \"\n+    /*** THIS FILE IS GENERATED BY THE TEST.  ***/\n+\n+    static int tracer = 0;\n+\n+    /* The call-by-value function.  */\n+    template <class T>\n+    int\n+    cbv (T arg)\n+    {\n+      arg.data\\[0\\] += $ADDED; // intentionally modify the arg\n+      return arg.data\\[0\\];\n+    }\n+\n+    template <class T>\n+    int\n+    cbv_container (T arg)\n+    {\n+      arg.item.data\\[0\\] += $ADDED;  // intentionally modify\n+      return arg.item.data\\[0\\];\n+    }\n+\n+    $classes\n+\n+    int\n+    main (void)\n+    {\n+      $stmts\n+\n+      /* stop here */\n+\n+      return 0;\n+    }\"\n+}\n+\n+# Compute all the combinations of special function states.\n+# We do not contain the 'deleted' state for the destructor,\n+# because it is illegal to have stack-allocated objects\n+# whose destructor have been deleted.  This case is covered\n+# in pass-by-ref-2 via heap-allocated objects.\n+\n+set options_nodelete [list absent explicit defaultedIn defaultedOut]\n+set options [concat $options_nodelete {deleted}]\n+set all_combinations {}\n+\n+foreach cctor $options {\n+    foreach dtor $options_nodelete {\n+\tforeach mctor $options {\n+\t    lappend all_combinations [list $cctor $dtor $mctor]\n+\t}\n+    }\n+}\n+\n+# Generate the classes.\n+\n+set classes \"\"\n+set stmts \"\"\n+\n+foreach state $all_combinations {\n+    append classes [generate_small_class $state]\n+    append stmts [generate_stmts \"Small\" $state]\n+\n+    append classes [generate_large_class $state]\n+    append stmts [generate_stmts \"Large\" $state]\n+\n+    append classes [generate_derived_class $state]\n+    append stmts [generate_stmts \"Derived\" $state]\n+\n+    append classes [generate_container_class $state]\n+    append stmts [generate_stmts \"Container\" $state \"cbv_container\"]\n+}\n+\n+# Generate the program code and compile\n+set program [generate_program $classes $stmts]\n+set srcfile [standard_output_file ${srcfile}]\n+gdb_produce_source $srcfile $program\n+\n+set options {debug c++ additional_flags=-std=c++11}\n+if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile $options]} {\n     return -1\n }\n \n-if ![runto_main] then {\n+if {![runto_main]} {\n+    untested \"failed to run to main\"\n     return -1\n }\n \n-gdb_test \"print foo (global_obj)\" \" = 3\" \"call function in obj\"\n-gdb_test \"print blap (global_derived)\" \" = 3\" \"call function in derived\"\n-gdb_test \"print blip (global_container)\" \" = 3\" \"call function in container\"\n+set bp_location [gdb_get_line_number \"stop here\"]\n+gdb_breakpoint $bp_location\n+gdb_continue_to_breakpoint \"end of main\" \".*return .*;\"\n+\n+# Do the checks for a given class whose name is prefixed with PREFIX,\n+# and whose special functions have the states given in STATES.\n+# The name of the call-by-value function and the expression to access\n+# the data field can be specified explicitly if the default values\n+# do not work.\n+\n+proc test_for_class { prefix states cbvfun data_field length} {\n+    set name \"${prefix}_[join $states _]\"\n+\n+    set cctor [lindex $states 0]\n+    set dtor  [lindex $states 1]\n+    set mctor [lindex $states 2]\n+\n+    global ORIGINAL\n+    global CUSTOM\n+    global ADDED\n+    global TRACE\n+\n+    with_test_prefix $name {\n+\tif {[is_copy_constructible $states]} {\n+\t    set expected [expr {$ORIGINAL + $ADDED}]\n+\t    if {$cctor == \"explicit\"} {\n+\t\tset expected [expr {$CUSTOM + $ADDED}]\n+\t    }\n+\t    if {$dtor == \"explicit\"} {\n+\t\tgdb_test \"print tracer = 0\" \" = 0\" \"reset the tracer\"\n+\t    }\n+\t    gdb_test \"print ${cbvfun}<$name> (${name}_var)\" \" = $expected\" \\\n+\t\t\"call '$cbvfun'\"\n+\t    gdb_test \"print ${name}_var.${data_field}\\[0\\]\" \" = $ORIGINAL\" \\\n+\t\t\"cbv argument should not change (item 0)\"\n+\t    if {$length > 1} {\n+\t\tset last_index [expr $length - 1]\n+\t\tgdb_test \"print ${name}_var.${data_field}\\[$last_index\\]\" \\\n+\t\t    \" = $ORIGINAL\" \\\n+\t\t    \"cbv argument should not change (item $last_index)\"\n+\t    }\n+\t    if {$dtor == \"explicit\"} {\n+\t\tgdb_test \"print tracer\" \" = $TRACE\" \\\n+\t\t    \"destructor should be called\"\n+\t    }\n+\t} else {\n+\t    gdb_test \"print ${cbvfun}<$name> (${name}_var)\" \\\n+\t\t\".* cannot be evaluated .* '${name}' is not copy constructible\" \\\n+\t\t\"calling '$cbvfun' should be refused\"\n+\t}\n+    }\n+}\n+\n+foreach state $all_combinations {\n+    test_for_class \"Small\"     $state \"cbv\"           \"data\"      $SMALL\n+    test_for_class \"Large\"     $state \"cbv\"           \"data\"      $LARGE\n+    test_for_class \"Derived\"   $state \"cbv\"           \"data\"      1\n+    test_for_class \"Container\" $state \"cbv_container\" \"item.data\" 1\n+}"
    }
  ]
}