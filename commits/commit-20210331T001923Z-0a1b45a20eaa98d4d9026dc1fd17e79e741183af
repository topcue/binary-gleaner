{
  "sha": "0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGExYjQ1YTIwZWFhOThkNGQ5MDI2ZGMxZmQxN2U3OWU3NDExODNhZg==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:00:54Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-03-31T00:19:23Z"
    },
    "message": "Use bool in bfd\n\n\t* sysdep.h: POISON_BFD_BOOLEAN: Define.\n\t* aix5ppc-core.c, * aout-cris.c, * aout-ns32k.c, * aout-target.h,\n\t* aoutx.h, * arc-got.h, * archive.c, * archive64.c, * archures.c,\n\t* bfd-in.h, * bfd.c, * bfdwin.c, * binary.c, * cache.c,\n\t* coff-alpha.c, * coff-arm.c, * coff-arm.h, * coff-bfd.c,\n\t* coff-bfd.h, * coff-go32.c, * coff-i386.c, * coff-ia64.c,\n\t* coff-mcore.c, * coff-mips.c, * coff-rs6000.c, * coff-sh.c,\n\t* coff-stgo32.c, * coff-tic30.c, * coff-tic4x.c, * coff-tic54x.c,\n\t* coff-x86_64.c, * coff-z80.c, * coff-z8k.c, * coff64-rs6000.c,\n\t* coffcode.h, * coffgen.c, * cofflink.c, * compress.c,\n\t* corefile.c, * cpu-aarch64.c, * cpu-aarch64.h, * cpu-alpha.c,\n\t* cpu-arc.c, * cpu-arm.c, * cpu-arm.h, * cpu-avr.c, * cpu-bfin.c,\n\t* cpu-bpf.c, * cpu-cr16.c, * cpu-cris.c, * cpu-crx.c,\n\t* cpu-csky.c, * cpu-d10v.c, * cpu-d30v.c, * cpu-dlx.c,\n\t* cpu-epiphany.c, * cpu-fr30.c, * cpu-frv.c, * cpu-ft32.c,\n\t* cpu-h8300.c, * cpu-hppa.c, * cpu-i386.c, * cpu-ia64.c,\n\t* cpu-iamcu.c, * cpu-ip2k.c, * cpu-iq2000.c, * cpu-k1om.c,\n\t* cpu-l1om.c, * cpu-lm32.c, * cpu-m10200.c, * cpu-m10300.c,\n\t* cpu-m32c.c, * cpu-m32r.c, * cpu-m68hc11.c, * cpu-m68hc12.c,\n\t* cpu-m68k.c, * cpu-m9s12x.c, * cpu-m9s12xg.c, * cpu-mcore.c,\n\t* cpu-mep.c, * cpu-metag.c, * cpu-microblaze.c, * cpu-mips.c,\n\t* cpu-mmix.c, * cpu-moxie.c, * cpu-msp430.c, * cpu-mt.c,\n\t* cpu-nds32.c, * cpu-nfp.c, * cpu-nios2.c, * cpu-ns32k.c,\n\t* cpu-or1k.c, * cpu-pdp11.c, * cpu-pj.c, * cpu-powerpc.c,\n\t* cpu-pru.c, * cpu-riscv.c, * cpu-rl78.c, * cpu-rs6000.c,\n\t* cpu-rx.c, * cpu-s12z.c, * cpu-s390.c, * cpu-score.c,\n\t* cpu-sh.c, * cpu-sparc.c, * cpu-spu.c, * cpu-tic30.c,\n\t* cpu-tic4x.c, * cpu-tic54x.c, * cpu-tic6x.c, * cpu-tilegx.c,\n\t* cpu-tilepro.c, * cpu-v850.c, * cpu-v850_rh850.c, * cpu-vax.c,\n\t* cpu-visium.c, * cpu-wasm32.c, * cpu-xc16x.c, * cpu-xgate.c,\n\t* cpu-xstormy16.c, * cpu-xtensa.c, * cpu-z80.c, * cpu-z8k.c,\n\t* dwarf1.c, * dwarf2.c, * ecoff-bfd.h, * ecoff.c, * ecofflink.c,\n\t* elf-attrs.c, * elf-bfd.h, * elf-eh-frame.c, * elf-hppa.h,\n\t* elf-ifunc.c, * elf-m10200.c, * elf-m10300.c, * elf-nacl.c,\n\t* elf-nacl.h, * elf-properties.c, * elf-s390-common.c,\n\t* elf-s390.h, * elf-strtab.c, * elf-vxworks.c, * elf-vxworks.h,\n\t* elf.c, * elf32-am33lin.c, * elf32-arc.c, * elf32-arm.c,\n\t* elf32-arm.h, * elf32-avr.c, * elf32-avr.h, * elf32-bfin.c,\n\t* elf32-bfin.h, * elf32-cr16.c, * elf32-cr16.h, * elf32-cris.c,\n\t* elf32-crx.c, * elf32-csky.c, * elf32-csky.h, * elf32-d10v.c,\n\t* elf32-d30v.c, * elf32-dlx.c, * elf32-epiphany.c,\n\t* elf32-fr30.c, * elf32-frv.c, * elf32-ft32.c, * elf32-gen.c,\n\t* elf32-h8300.c, * elf32-hppa.c, * elf32-hppa.h, * elf32-i386.c,\n\t* elf32-ip2k.c, * elf32-iq2000.c, * elf32-lm32.c, * elf32-m32c.c,\n\t* elf32-m32r.c, * elf32-m68hc11.c, * elf32-m68hc12.c,\n\t* elf32-m68hc1x.c, * elf32-m68hc1x.h, * elf32-m68k.c,\n\t* elf32-m68k.h, * elf32-mcore.c, * elf32-mep.c, * elf32-metag.c,\n\t* elf32-metag.h, * elf32-microblaze.c, * elf32-mips.c,\n\t* elf32-moxie.c, * elf32-msp430.c, * elf32-mt.c, * elf32-nds32.c,\n\t* elf32-nios2.c, * elf32-nios2.h, * elf32-or1k.c, * elf32-pj.c,\n\t* elf32-ppc.c, * elf32-ppc.h, * elf32-pru.c, * elf32-rl78.c,\n\t* elf32-rx.c, * elf32-s12z.c, * elf32-s390.c, * elf32-score.c,\n\t* elf32-score.h, * elf32-score7.c, * elf32-sh-relocs.h,\n\t* elf32-sh.c, * elf32-sparc.c, * elf32-spu.c, * elf32-spu.h,\n\t* elf32-tic6x.c, * elf32-tic6x.h, * elf32-tilegx.c,\n\t* elf32-tilepro.c, * elf32-v850.c, * elf32-v850.h,\n\t* elf32-vax.c, * elf32-visium.c, * elf32-wasm32.c,\n\t* elf32-xc16x.c, * elf32-xgate.c, * elf32-xstormy16.c,\n\t* elf32-xtensa.c, * elf32-z80.c, * elf64-alpha.c, * elf64-bpf.c,\n\t* elf64-gen.c, * elf64-hppa.c, * elf64-ia64-vms.c,\n\t* elf64-mips.c, * elf64-mmix.c, * elf64-nfp.c, * elf64-ppc.c,\n\t* elf64-ppc.h, * elf64-s390.c, * elf64-sparc.c,\n\t* elf64-tilegx.c, * elf64-x86-64.c, * elfcode.h,\n\t* elfcore.h, * elflink.c, * elfn32-mips.c, * elfnn-aarch64.c,\n\t* elfnn-ia64.c, * elfnn-riscv.c, * elfxx-aarch64.c,\n\t* elfxx-aarch64.h, * elfxx-ia64.c, * elfxx-ia64.h,\n\t* elfxx-mips.c, * elfxx-mips.h, * elfxx-riscv.c, * elfxx-riscv.h,\n\t* elfxx-sparc.c, * elfxx-sparc.h, * elfxx-target.h,\n\t* elfxx-tilegx.c, * elfxx-tilegx.h, * elfxx-x86.c, * elfxx-x86.h,\n\t* format.c, * genlink.h, * hash.c, * i386aout.c, * i386lynx.c,\n\t* i386msdos.c, * ihex.c, * libaout.h, * libbfd-in.h,\n\t* libbfd.c, * libcoff-in.h, * libecoff.h, * libpei.h,\n\t* libxcoff.h, * linker.c, * mach-o-aarch64.c, * mach-o-arm.c,\n\t* mach-o-i386.c, * mach-o-x86-64.c, * mach-o.c, * mach-o.h,\n\t* merge.c, * mmo.c, * netbsd.h, * opncls.c, * pc532-mach.c,\n\t* pdp11.c, * pe-arm.c, * pe-i386.c, * pe-mcore.c, * pe-sh.c,\n\t* pe-x86_64.c, * peXXigen.c, * pef.c, * pei-arm.c, * pei-i386.c,\n\t* pei-ia64.c, * pei-mcore.c, * pei-sh.c, * pei-x86_64.c,\n\t* peicode.h, * plugin.c, * plugin.h, * ppcboot.c, * reloc.c,\n\t* reloc16.c, * rs6000-core.c, * section.c, * simple.c, * som.c,\n\t* som.h, * srec.c, * stabs.c, * syms.c, * targets.c, * tekhex.c,\n\t* verilog.c, * vms-alpha.c, * vms-lib.c, * vms-misc.c, * vms.h,\n\t* wasm-module.c, * xcofflink.c, * xcofflink.h, * xsym.c,\n\t* xsym.h: Replace bfd_boolean with bool, FALSE with false, and\n\tTRUE with true throughout.\n\t* bfd-in2.h: Regenerate.\n\t* libbfd.h: Regenerate.\n\t* libcoff.h: Regenerate.",
    "tree": {
      "sha": "059b2b296b4d60784a82cd6a52dae47dcac4d66a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/059b2b296b4d60784a82cd6a52dae47dcac4d66a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "faa7a26040c617a6d29f601998b99a1da882c672",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/faa7a26040c617a6d29f601998b99a1da882c672",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/faa7a26040c617a6d29f601998b99a1da882c672"
    }
  ],
  "stats": {
    "total": 56617,
    "additions": 28339,
    "deletions": 28278
  },
  "files": [
    {
      "sha": "9a9152609da11c71ca90849b22442eb8d5ca9bd3",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 91,
      "deletions": 0,
      "changes": 91,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -1,3 +1,94 @@\n+2021-03-31  Alan Modra  <amodra@gmail.com>\n+\n+\t* sysdep.h: POISON_BFD_BOOLEAN: Define.\n+\t* aix5ppc-core.c, * aout-cris.c, * aout-ns32k.c, * aout-target.h,\n+\t* aoutx.h, * arc-got.h, * archive.c, * archive64.c, * archures.c,\n+\t* bfd-in.h, * bfd.c, * bfdwin.c, * binary.c, * cache.c,\n+\t* coff-alpha.c, * coff-arm.c, * coff-arm.h, * coff-bfd.c,\n+\t* coff-bfd.h, * coff-go32.c, * coff-i386.c, * coff-ia64.c,\n+\t* coff-mcore.c, * coff-mips.c, * coff-rs6000.c, * coff-sh.c,\n+\t* coff-stgo32.c, * coff-tic30.c, * coff-tic4x.c, * coff-tic54x.c,\n+\t* coff-x86_64.c, * coff-z80.c, * coff-z8k.c, * coff64-rs6000.c,\n+\t* coffcode.h, * coffgen.c, * cofflink.c, * compress.c,\n+\t* corefile.c, * cpu-aarch64.c, * cpu-aarch64.h, * cpu-alpha.c,\n+\t* cpu-arc.c, * cpu-arm.c, * cpu-arm.h, * cpu-avr.c, * cpu-bfin.c,\n+\t* cpu-bpf.c, * cpu-cr16.c, * cpu-cris.c, * cpu-crx.c,\n+\t* cpu-csky.c, * cpu-d10v.c, * cpu-d30v.c, * cpu-dlx.c,\n+\t* cpu-epiphany.c, * cpu-fr30.c, * cpu-frv.c, * cpu-ft32.c,\n+\t* cpu-h8300.c, * cpu-hppa.c, * cpu-i386.c, * cpu-ia64.c,\n+\t* cpu-iamcu.c, * cpu-ip2k.c, * cpu-iq2000.c, * cpu-k1om.c,\n+\t* cpu-l1om.c, * cpu-lm32.c, * cpu-m10200.c, * cpu-m10300.c,\n+\t* cpu-m32c.c, * cpu-m32r.c, * cpu-m68hc11.c, * cpu-m68hc12.c,\n+\t* cpu-m68k.c, * cpu-m9s12x.c, * cpu-m9s12xg.c, * cpu-mcore.c,\n+\t* cpu-mep.c, * cpu-metag.c, * cpu-microblaze.c, * cpu-mips.c,\n+\t* cpu-mmix.c, * cpu-moxie.c, * cpu-msp430.c, * cpu-mt.c,\n+\t* cpu-nds32.c, * cpu-nfp.c, * cpu-nios2.c, * cpu-ns32k.c,\n+\t* cpu-or1k.c, * cpu-pdp11.c, * cpu-pj.c, * cpu-powerpc.c,\n+\t* cpu-pru.c, * cpu-riscv.c, * cpu-rl78.c, * cpu-rs6000.c,\n+\t* cpu-rx.c, * cpu-s12z.c, * cpu-s390.c, * cpu-score.c,\n+\t* cpu-sh.c, * cpu-sparc.c, * cpu-spu.c, * cpu-tic30.c,\n+\t* cpu-tic4x.c, * cpu-tic54x.c, * cpu-tic6x.c, * cpu-tilegx.c,\n+\t* cpu-tilepro.c, * cpu-v850.c, * cpu-v850_rh850.c, * cpu-vax.c,\n+\t* cpu-visium.c, * cpu-wasm32.c, * cpu-xc16x.c, * cpu-xgate.c,\n+\t* cpu-xstormy16.c, * cpu-xtensa.c, * cpu-z80.c, * cpu-z8k.c,\n+\t* dwarf1.c, * dwarf2.c, * ecoff-bfd.h, * ecoff.c, * ecofflink.c,\n+\t* elf-attrs.c, * elf-bfd.h, * elf-eh-frame.c, * elf-hppa.h,\n+\t* elf-ifunc.c, * elf-m10200.c, * elf-m10300.c, * elf-nacl.c,\n+\t* elf-nacl.h, * elf-properties.c, * elf-s390-common.c,\n+\t* elf-s390.h, * elf-strtab.c, * elf-vxworks.c, * elf-vxworks.h,\n+\t* elf.c, * elf32-am33lin.c, * elf32-arc.c, * elf32-arm.c,\n+\t* elf32-arm.h, * elf32-avr.c, * elf32-avr.h, * elf32-bfin.c,\n+\t* elf32-bfin.h, * elf32-cr16.c, * elf32-cr16.h, * elf32-cris.c,\n+\t* elf32-crx.c, * elf32-csky.c, * elf32-csky.h, * elf32-d10v.c,\n+\t* elf32-d30v.c, * elf32-dlx.c, * elf32-epiphany.c,\n+\t* elf32-fr30.c, * elf32-frv.c, * elf32-ft32.c, * elf32-gen.c,\n+\t* elf32-h8300.c, * elf32-hppa.c, * elf32-hppa.h, * elf32-i386.c,\n+\t* elf32-ip2k.c, * elf32-iq2000.c, * elf32-lm32.c, * elf32-m32c.c,\n+\t* elf32-m32r.c, * elf32-m68hc11.c, * elf32-m68hc12.c,\n+\t* elf32-m68hc1x.c, * elf32-m68hc1x.h, * elf32-m68k.c,\n+\t* elf32-m68k.h, * elf32-mcore.c, * elf32-mep.c, * elf32-metag.c,\n+\t* elf32-metag.h, * elf32-microblaze.c, * elf32-mips.c,\n+\t* elf32-moxie.c, * elf32-msp430.c, * elf32-mt.c, * elf32-nds32.c,\n+\t* elf32-nios2.c, * elf32-nios2.h, * elf32-or1k.c, * elf32-pj.c,\n+\t* elf32-ppc.c, * elf32-ppc.h, * elf32-pru.c, * elf32-rl78.c,\n+\t* elf32-rx.c, * elf32-s12z.c, * elf32-s390.c, * elf32-score.c,\n+\t* elf32-score.h, * elf32-score7.c, * elf32-sh-relocs.h,\n+\t* elf32-sh.c, * elf32-sparc.c, * elf32-spu.c, * elf32-spu.h,\n+\t* elf32-tic6x.c, * elf32-tic6x.h, * elf32-tilegx.c,\n+\t* elf32-tilepro.c, * elf32-v850.c, * elf32-v850.h,\n+\t* elf32-vax.c, * elf32-visium.c, * elf32-wasm32.c,\n+\t* elf32-xc16x.c, * elf32-xgate.c, * elf32-xstormy16.c,\n+\t* elf32-xtensa.c, * elf32-z80.c, * elf64-alpha.c, * elf64-bpf.c,\n+\t* elf64-gen.c, * elf64-hppa.c, * elf64-ia64-vms.c,\n+\t* elf64-mips.c, * elf64-mmix.c, * elf64-nfp.c, * elf64-ppc.c,\n+\t* elf64-ppc.h, * elf64-s390.c, * elf64-sparc.c,\n+\t* elf64-tilegx.c, * elf64-x86-64.c, * elfcode.h,\n+\t* elfcore.h, * elflink.c, * elfn32-mips.c, * elfnn-aarch64.c,\n+\t* elfnn-ia64.c, * elfnn-riscv.c, * elfxx-aarch64.c,\n+\t* elfxx-aarch64.h, * elfxx-ia64.c, * elfxx-ia64.h,\n+\t* elfxx-mips.c, * elfxx-mips.h, * elfxx-riscv.c, * elfxx-riscv.h,\n+\t* elfxx-sparc.c, * elfxx-sparc.h, * elfxx-target.h,\n+\t* elfxx-tilegx.c, * elfxx-tilegx.h, * elfxx-x86.c, * elfxx-x86.h,\n+\t* format.c, * genlink.h, * hash.c, * i386aout.c, * i386lynx.c,\n+\t* i386msdos.c, * ihex.c, * libaout.h, * libbfd-in.h,\n+\t* libbfd.c, * libcoff-in.h, * libecoff.h, * libpei.h,\n+\t* libxcoff.h, * linker.c, * mach-o-aarch64.c, * mach-o-arm.c,\n+\t* mach-o-i386.c, * mach-o-x86-64.c, * mach-o.c, * mach-o.h,\n+\t* merge.c, * mmo.c, * netbsd.h, * opncls.c, * pc532-mach.c,\n+\t* pdp11.c, * pe-arm.c, * pe-i386.c, * pe-mcore.c, * pe-sh.c,\n+\t* pe-x86_64.c, * peXXigen.c, * pef.c, * pei-arm.c, * pei-i386.c,\n+\t* pei-ia64.c, * pei-mcore.c, * pei-sh.c, * pei-x86_64.c,\n+\t* peicode.h, * plugin.c, * plugin.h, * ppcboot.c, * reloc.c,\n+\t* reloc16.c, * rs6000-core.c, * section.c, * simple.c, * som.c,\n+\t* som.h, * srec.c, * stabs.c, * syms.c, * targets.c, * tekhex.c,\n+\t* verilog.c, * vms-alpha.c, * vms-lib.c, * vms-misc.c, * vms.h,\n+\t* wasm-module.c, * xcofflink.c, * xcofflink.h, * xsym.c,\n+\t* xsym.h: Replace bfd_boolean with bool, FALSE with false, and\n+\tTRUE with true throughout.\n+\t* bfd-in2.h: Regenerate.\n+\t* libbfd.h: Regenerate.\n+\t* libcoff.h: Regenerate.\n+\n 2021-03-31  Alan Modra  <amodra@gmail.com>\n \n \t* bfd-in.h: Include stdbool.h."
    },
    {
      "sha": "51f2d781fa2997fbed0b04e2e8ccc6209c75784c",
      "filename": "bfd/aix5ppc-core.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aix5ppc-core.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aix5ppc-core.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/aix5ppc-core.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -24,7 +24,7 @@\n #include \"bfd.h\"\n \n bfd_cleanup xcoff64_core_p (bfd *);\n-bfd_boolean xcoff64_core_file_matches_executable_p (bfd *, bfd *);\n+bool xcoff64_core_file_matches_executable_p (bfd *, bfd *);\n char *xcoff64_core_file_failing_command (bfd *);\n int xcoff64_core_file_failing_signal (bfd *);\n \n@@ -238,14 +238,14 @@ xcoff64_core_p (bfd *abfd)\n \n /* Return `TRUE' if given core is from the given executable.  */\n \n-bfd_boolean\n+bool\n xcoff64_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)\n {\n   struct core_dumpxx core;\n   char *path, *s;\n   size_t alloc;\n   const char *str1, *str2;\n-  bfd_boolean return_value = FALSE;\n+  bool return_value = false;\n \n   /* Get the header.  */\n   if (bfd_seek (core_bfd, 0, SEEK_SET) != 0)\n@@ -295,7 +295,7 @@ xcoff64_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)\n   str2 = str2 != NULL ? str2 + 1 : bfd_get_filename (exec_bfd);\n \n   if (strcmp (str1, str2) == 0)\n-    return_value = TRUE;\n+    return_value = true;\n \n  xcoff64_core_file_matches_executable_p_end_1:\n   free (path);\n@@ -335,7 +335,7 @@ xcoff64_core_p (bfd *abfd ATTRIBUTE_UNUSED)\n   return 0;\n }\n \n-bfd_boolean\n+bool\n xcoff64_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)\n {\n   return generic_core_file_matches_executable_p (core_bfd, exec_bfd);"
    },
    {
      "sha": "a650225914d6378b242b4eaadf8fcc89e1a93aad",
      "filename": "bfd/aout-cris.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aout-cris.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aout-cris.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/aout-cris.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -69,7 +69,7 @@\n #define MY_exec_hdr_flags 1\n \n #define MY_write_object_contents MY (write_object_contents)\n-static bfd_boolean MY (write_object_contents) (bfd *);\n+static bool MY (write_object_contents) (bfd *);\n \n /* Forward this, so we can use a pointer to it in PARAMS.  */\n struct reloc_ext_external;\n@@ -82,7 +82,7 @@ static void MY (swap_ext_reloc_in) (bfd *, struct reloc_ext_external *,\n \t\t\t\t    arelent *, asymbol **, bfd_size_type);\n \n #define MY_set_sizes MY (set_sizes)\n-static bfd_boolean MY (set_sizes) (bfd *);\n+static bool MY (set_sizes) (bfd *);\n \n /* To set back reloc_size to ext, we make MY (set_sizes) be called\n    through this construct.  Note that MY_set_arch_mach is only called\n@@ -110,7 +110,7 @@ static bfd_boolean MY (set_sizes) (bfd *);\n \n /* We need our own version to set header flags.  */\n \n-static bfd_boolean\n+static bool\n MY (write_object_contents) (bfd *abfd)\n {\n   struct external_exec exec_bytes;\n@@ -131,7 +131,7 @@ MY (write_object_contents) (bfd *abfd)\n \n   WRITE_HEADERS (abfd, execp);\n \n-  return TRUE;\n+  return true;\n }\n \n /* We need our own for these reasons:\n@@ -269,7 +269,7 @@ MY (swap_ext_reloc_in) (bfd *abfd,\n    \"obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;\", to avoid changing\n    NAME (aout, set_arch_mach) in aoutx.  */\n \n-static bfd_boolean\n+static bool\n MY (set_sizes) (bfd *abfd)\n {\n   /* Just as the default in aout-target.h (with some #ifdefs folded)...  */\n@@ -286,5 +286,5 @@ MY (set_sizes) (bfd *abfd)\n \n   obj_reloc_entry_size (abfd) = RELOC_EXT_SIZE;\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "83fde67cc26932fd4982943b9d8dd7241ee663d1",
      "filename": "bfd/aout-ns32k.c",
      "status": "modified",
      "additions": 37,
      "deletions": 37,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aout-ns32k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aout-ns32k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/aout-ns32k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -31,7 +31,7 @@\n \n reloc_howto_type * MYNS (bfd_reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);\n reloc_howto_type * MYNS (bfd_reloc_name_lookup) (bfd *, const char *);\n-bfd_boolean\t   MYNS (write_object_contents) (bfd *);\n+bool MYNS (write_object_contents) (bfd *);\n \n /* Avoid multiple definitions from aoutx if supporting\n    standard a.out format(s) as well as this one.  */\n@@ -79,58 +79,58 @@ void bfd_ns32k_arch (void);\n reloc_howto_type MY (howto_table)[] =\n {\n   /* ns32k immediate operands.  */\n-  HOWTO (BFD_RELOC_NS32K_IMM_8, 0, 0, 8, FALSE, 0, complain_overflow_signed,\n+  HOWTO (BFD_RELOC_NS32K_IMM_8, 0, 0, 8, false, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_imm, \"NS32K_IMM_8\",\n-\t TRUE, 0x000000ff,0x000000ff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_IMM_16, 0, 1, 16, FALSE, 0, complain_overflow_signed,\n+\t true, 0x000000ff,0x000000ff, false),\n+  HOWTO (BFD_RELOC_NS32K_IMM_16, 0, 1, 16, false, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_imm,  \"NS32K_IMM_16\",\n-\t TRUE, 0x0000ffff,0x0000ffff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_IMM_32, 0, 2, 32, FALSE, 0, complain_overflow_signed,\n+\t true, 0x0000ffff,0x0000ffff, false),\n+  HOWTO (BFD_RELOC_NS32K_IMM_32, 0, 2, 32, false, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_imm, \"NS32K_IMM_32\",\n-\t TRUE, 0xffffffff,0xffffffff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_IMM_8_PCREL, 0, 0, 8, TRUE, 0, complain_overflow_signed,\n+\t true, 0xffffffff,0xffffffff, false),\n+  HOWTO (BFD_RELOC_NS32K_IMM_8_PCREL, 0, 0, 8, true, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_imm, \"PCREL_NS32K_IMM_8\",\n-\t TRUE, 0x000000ff, 0x000000ff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_IMM_16_PCREL, 0, 1, 16, TRUE, 0, complain_overflow_signed,\n+\t true, 0x000000ff, 0x000000ff, false),\n+  HOWTO (BFD_RELOC_NS32K_IMM_16_PCREL, 0, 1, 16, true, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_imm, \"PCREL_NS32K_IMM_16\",\n-\t TRUE, 0x0000ffff,0x0000ffff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_IMM_32_PCREL, 0, 2, 32, TRUE, 0, complain_overflow_signed,\n+\t true, 0x0000ffff,0x0000ffff, false),\n+  HOWTO (BFD_RELOC_NS32K_IMM_32_PCREL, 0, 2, 32, true, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_imm, \"PCREL_NS32K_IMM_32\",\n-\t TRUE, 0xffffffff,0xffffffff, FALSE),\n+\t true, 0xffffffff,0xffffffff, false),\n \n   /* ns32k displacements.  */\n-  HOWTO (BFD_RELOC_NS32K_DISP_8, 0, 0, 7, FALSE, 0, complain_overflow_signed,\n+  HOWTO (BFD_RELOC_NS32K_DISP_8, 0, 0, 7, false, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_disp, \"NS32K_DISP_8\",\n-\t TRUE, 0x000000ff,0x000000ff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_DISP_16, 0, 1, 14, FALSE, 0, complain_overflow_signed,\n+\t true, 0x000000ff,0x000000ff, false),\n+  HOWTO (BFD_RELOC_NS32K_DISP_16, 0, 1, 14, false, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_disp, \"NS32K_DISP_16\",\n-\t TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_DISP_32, 0, 2, 30, FALSE, 0, complain_overflow_signed,\n+\t true, 0x0000ffff, 0x0000ffff, false),\n+  HOWTO (BFD_RELOC_NS32K_DISP_32, 0, 2, 30, false, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_disp, \"NS32K_DISP_32\",\n-\t TRUE, 0xffffffff, 0xffffffff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_DISP_8_PCREL, 0, 0, 7, TRUE, 0, complain_overflow_signed,\n+\t true, 0xffffffff, 0xffffffff, false),\n+  HOWTO (BFD_RELOC_NS32K_DISP_8_PCREL, 0, 0, 7, true, 0, complain_overflow_signed,\n \t   _bfd_ns32k_reloc_disp, \"PCREL_NS32K_DISP_8\",\n-\t TRUE, 0x000000ff,0x000000ff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_DISP_16_PCREL, 0, 1, 14, TRUE, 0, complain_overflow_signed,\n+\t true, 0x000000ff,0x000000ff, false),\n+  HOWTO (BFD_RELOC_NS32K_DISP_16_PCREL, 0, 1, 14, true, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_disp, \"PCREL_NS32K_DISP_16\",\n-\t TRUE, 0x0000ffff,0x0000ffff, FALSE),\n-  HOWTO (BFD_RELOC_NS32K_DISP_32_PCREL, 0, 2, 30, TRUE, 0, complain_overflow_signed,\n+\t true, 0x0000ffff,0x0000ffff, false),\n+  HOWTO (BFD_RELOC_NS32K_DISP_32_PCREL, 0, 2, 30, true, 0, complain_overflow_signed,\n \t _bfd_ns32k_reloc_disp, \"PCREL_NS32K_DISP_32\",\n-\t TRUE, 0xffffffff,0xffffffff, FALSE),\n+\t true, 0xffffffff,0xffffffff, false),\n \n   /* Normal 2's complement.  */\n-  HOWTO (BFD_RELOC_8, 0, 0, 8, FALSE, 0, complain_overflow_bitfield,0,\n-\t \"8\", TRUE, 0x000000ff,0x000000ff, FALSE),\n-  HOWTO (BFD_RELOC_16, 0, 1, 16, FALSE, 0, complain_overflow_bitfield,0,\n-\t \"16\", TRUE, 0x0000ffff,0x0000ffff, FALSE),\n-  HOWTO (BFD_RELOC_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,0,\n-\t \"32\", TRUE, 0xffffffff,0xffffffff, FALSE),\n-  HOWTO (BFD_RELOC_8_PCREL, 0, 0, 8, TRUE, 0, complain_overflow_signed, 0,\n-\t \"PCREL_8\", TRUE, 0x000000ff,0x000000ff, FALSE),\n-  HOWTO (BFD_RELOC_16_PCREL, 0, 1, 16, TRUE, 0, complain_overflow_signed, 0,\n-\t \"PCREL_16\", TRUE, 0x0000ffff,0x0000ffff, FALSE),\n-  HOWTO (BFD_RELOC_32_PCREL, 0, 2, 32, TRUE, 0, complain_overflow_signed, 0,\n-\t \"PCREL_32\", TRUE, 0xffffffff,0xffffffff, FALSE),\n+  HOWTO (BFD_RELOC_8, 0, 0, 8, false, 0, complain_overflow_bitfield,0,\n+\t \"8\", true, 0x000000ff,0x000000ff, false),\n+  HOWTO (BFD_RELOC_16, 0, 1, 16, false, 0, complain_overflow_bitfield,0,\n+\t \"16\", true, 0x0000ffff,0x0000ffff, false),\n+  HOWTO (BFD_RELOC_32, 0, 2, 32, false, 0, complain_overflow_bitfield,0,\n+\t \"32\", true, 0xffffffff,0xffffffff, false),\n+  HOWTO (BFD_RELOC_8_PCREL, 0, 0, 8, true, 0, complain_overflow_signed, 0,\n+\t \"PCREL_8\", true, 0x000000ff,0x000000ff, false),\n+  HOWTO (BFD_RELOC_16_PCREL, 0, 1, 16, true, 0, complain_overflow_signed, 0,\n+\t \"PCREL_16\", true, 0x0000ffff,0x0000ffff, false),\n+  HOWTO (BFD_RELOC_32_PCREL, 0, 2, 32, true, 0, complain_overflow_signed, 0,\n+\t \"PCREL_32\", true, 0xffffffff,0xffffffff, false),\n };\n \n #define CTOR_TABLE_RELOC_HOWTO(BFD) (MY (howto_table) + 14)"
    },
    {
      "sha": "b5155ac36c58c7d416169e6ffc885c23f04572c3",
      "filename": "bfd/aout-target.h",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aout-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aout-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/aout-target.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -193,7 +193,7 @@ MY (object_p) (bfd *abfd)\n \n #ifndef MY_mkobject\n \n-static bfd_boolean\n+static bool\n MY (mkobject) (bfd *abfd)\n {\n   return NAME (aout, mkobject (abfd));\n@@ -210,7 +210,7 @@ MY (mkobject) (bfd *abfd)\n    section contents, and copy_private_bfd_data is not called until\n    after the section contents have been set.  */\n \n-static bfd_boolean\n+static bool\n MY_bfd_copy_private_section_data (bfd *ibfd,\n \t\t\t\t  asection *isec ATTRIBUTE_UNUSED,\n \t\t\t\t  bfd *obfd,\n@@ -219,7 +219,7 @@ MY_bfd_copy_private_section_data (bfd *ibfd,\n   if (bfd_get_flavour (ibfd) == bfd_target_aout_flavour\n       && bfd_get_flavour (obfd) == bfd_target_aout_flavour)\n     obj_aout_subformat (obfd) = obj_aout_subformat (ibfd);\n-  return TRUE;\n+  return true;\n }\n \n #endif\n@@ -230,7 +230,7 @@ MY_bfd_copy_private_section_data (bfd *ibfd,\n \n #ifndef MY_write_object_contents\n \n-static bfd_boolean\n+static bool\n MY (write_object_contents) (bfd *abfd)\n {\n   struct external_exec exec_bytes;\n@@ -240,14 +240,14 @@ MY (write_object_contents) (bfd *abfd)\n \n   WRITE_HEADERS (abfd, execp);\n \n-  return TRUE;\n+  return true;\n }\n #define MY_write_object_contents MY (write_object_contents)\n #endif\n \n #ifndef MY_set_sizes\n \n-static bfd_boolean\n+static bool\n MY (set_sizes) (bfd *abfd)\n {\n   adata(abfd).page_size = TARGET_PAGE_SIZE;\n@@ -260,7 +260,7 @@ MY (set_sizes) (bfd *abfd)\n #endif\n \n   adata(abfd).exec_bytes_size = EXEC_BYTES_SIZE;\n-  return TRUE;\n+  return true;\n }\n #define MY_set_sizes MY (set_sizes)\n #endif\n@@ -345,7 +345,7 @@ MY_final_link_callback (bfd *abfd,\n /* Final link routine.  We need to use a call back to get the correct\n    offsets in the output file.  */\n \n-static bfd_boolean\n+static bool\n MY_bfd_final_link (bfd *abfd, struct bfd_link_info *info)\n {\n   return NAME (aout, final_link) (abfd, info, MY_final_link_callback);\n@@ -598,11 +598,11 @@ MY_bfd_final_link (bfd *abfd, struct bfd_link_info *info)\n \n /* Handle closing of a BFD including the resource-releasing parts.  */\n \n-static bfd_boolean\n+static bool\n MY_close_and_cleanup (bfd *abfd)\n {\n   if (!MY_bfd_free_cached_info (abfd))\n-    return FALSE;\n+    return false;\n \n   return _bfd_generic_close_and_cleanup (abfd);\n }"
    },
    {
      "sha": "76bb13c8e8d989a871d3530352611871e18f8595",
      "filename": "bfd/aoutx.h",
      "status": "modified",
      "additions": 308,
      "deletions": 311,
      "changes": 619,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aoutx.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/aoutx.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/aoutx.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -190,58 +190,58 @@ DESCRIPTION\n reloc_howto_type howto_table_ext[] =\n {\n   /*\t Type\t      rs   size bsz  pcrel bitpos ovrf\t\t\tsf name\t\t part_inpl readmask setmask pcdone.  */\n-  HOWTO (RELOC_8,\t0,  0,\t8,  FALSE, 0, complain_overflow_bitfield, 0, \"8\",\t    FALSE, 0, 0x000000ff, FALSE),\n-  HOWTO (RELOC_16,\t0,  1,\t16, FALSE, 0, complain_overflow_bitfield, 0, \"16\",\t    FALSE, 0, 0x0000ffff, FALSE),\n-  HOWTO (RELOC_32,\t0,  2,\t32, FALSE, 0, complain_overflow_bitfield, 0, \"32\",\t    FALSE, 0, 0xffffffff, FALSE),\n-  HOWTO (RELOC_DISP8,\t0,  0,\t8,  TRUE,  0, complain_overflow_signed,\t  0, \"DISP8\",\t    FALSE, 0, 0x000000ff, FALSE),\n-  HOWTO (RELOC_DISP16,\t0,  1,\t16, TRUE,  0, complain_overflow_signed,\t  0, \"DISP16\",\t    FALSE, 0, 0x0000ffff, FALSE),\n-  HOWTO (RELOC_DISP32,\t0,  2,\t32, TRUE,  0, complain_overflow_signed,\t  0, \"DISP32\",\t    FALSE, 0, 0xffffffff, FALSE),\n-  HOWTO (RELOC_WDISP30, 2,  2,\t30, TRUE,  0, complain_overflow_signed,\t  0, \"WDISP30\",\t    FALSE, 0, 0x3fffffff, FALSE),\n-  HOWTO (RELOC_WDISP22, 2,  2,\t22, TRUE,  0, complain_overflow_signed,\t  0, \"WDISP22\",\t    FALSE, 0, 0x003fffff, FALSE),\n-  HOWTO (RELOC_HI22,   10,  2,\t22, FALSE, 0, complain_overflow_bitfield, 0, \"HI22\",\t    FALSE, 0, 0x003fffff, FALSE),\n-  HOWTO (RELOC_22,\t0,  2,\t22, FALSE, 0, complain_overflow_bitfield, 0, \"22\",\t    FALSE, 0, 0x003fffff, FALSE),\n-  HOWTO (RELOC_13,\t0,  2,\t13, FALSE, 0, complain_overflow_bitfield, 0, \"13\",\t    FALSE, 0, 0x00001fff, FALSE),\n-  HOWTO (RELOC_LO10,\t0,  2,\t10, FALSE, 0, complain_overflow_dont,\t  0, \"LO10\",\t    FALSE, 0, 0x000003ff, FALSE),\n-  HOWTO (RELOC_SFA_BASE,0,  2,\t32, FALSE, 0, complain_overflow_bitfield, 0, \"SFA_BASE\",    FALSE, 0, 0xffffffff, FALSE),\n-  HOWTO (RELOC_SFA_OFF13,0, 2,\t32, FALSE, 0, complain_overflow_bitfield, 0, \"SFA_OFF13\",   FALSE, 0, 0xffffffff, FALSE),\n-  HOWTO (RELOC_BASE10,\t0,  2,\t10, FALSE, 0, complain_overflow_dont,\t  0, \"BASE10\",\t    FALSE, 0, 0x000003ff, FALSE),\n-  HOWTO (RELOC_BASE13,\t0,  2,\t13, FALSE, 0, complain_overflow_signed,\t  0, \"BASE13\",\t    FALSE, 0, 0x00001fff, FALSE),\n-  HOWTO (RELOC_BASE22, 10,  2,\t22, FALSE, 0, complain_overflow_bitfield, 0, \"BASE22\",\t    FALSE, 0, 0x003fffff, FALSE),\n-  HOWTO (RELOC_PC10,\t0,  2,\t10, TRUE,  0, complain_overflow_dont,\t  0, \"PC10\",\t    FALSE, 0, 0x000003ff, TRUE),\n-  HOWTO (RELOC_PC22,   10,  2,\t22, TRUE,  0, complain_overflow_signed,\t  0, \"PC22\",\t    FALSE, 0, 0x003fffff, TRUE),\n-  HOWTO (RELOC_JMP_TBL, 2,  2,\t30, TRUE,  0, complain_overflow_signed,\t  0, \"JMP_TBL\",\t    FALSE, 0, 0x3fffffff, FALSE),\n-  HOWTO (RELOC_SEGOFF16,0,  2,\t0,  FALSE, 0, complain_overflow_bitfield, 0, \"SEGOFF16\",    FALSE, 0, 0x00000000, FALSE),\n-  HOWTO (RELOC_GLOB_DAT,0,  2,\t0,  FALSE, 0, complain_overflow_bitfield, 0, \"GLOB_DAT\",    FALSE, 0, 0x00000000, FALSE),\n-  HOWTO (RELOC_JMP_SLOT,0,  2,\t0,  FALSE, 0, complain_overflow_bitfield, 0, \"JMP_SLOT\",    FALSE, 0, 0x00000000, FALSE),\n-  HOWTO (RELOC_RELATIVE,0,  2,\t0,  FALSE, 0, complain_overflow_bitfield, 0, \"RELATIVE\",    FALSE, 0, 0x00000000, FALSE),\n-  HOWTO (0,\t\t0,  3,\t0,  FALSE, 0, complain_overflow_dont,\t  0, \"R_SPARC_NONE\",FALSE, 0, 0x00000000, TRUE),\n-  HOWTO (0,\t\t0,  3,\t0,  FALSE, 0, complain_overflow_dont,\t  0, \"R_SPARC_NONE\",FALSE, 0, 0x00000000, TRUE),\n+  HOWTO (RELOC_8,\t0,  0,\t8,  false, 0, complain_overflow_bitfield, 0, \"8\",\t    false, 0, 0x000000ff, false),\n+  HOWTO (RELOC_16,\t0,  1,\t16, false, 0, complain_overflow_bitfield, 0, \"16\",\t    false, 0, 0x0000ffff, false),\n+  HOWTO (RELOC_32,\t0,  2,\t32, false, 0, complain_overflow_bitfield, 0, \"32\",\t    false, 0, 0xffffffff, false),\n+  HOWTO (RELOC_DISP8,\t0,  0,\t8,  true,  0, complain_overflow_signed,\t  0, \"DISP8\",\t    false, 0, 0x000000ff, false),\n+  HOWTO (RELOC_DISP16,\t0,  1,\t16, true,  0, complain_overflow_signed,\t  0, \"DISP16\",\t    false, 0, 0x0000ffff, false),\n+  HOWTO (RELOC_DISP32,\t0,  2,\t32, true,  0, complain_overflow_signed,\t  0, \"DISP32\",\t    false, 0, 0xffffffff, false),\n+  HOWTO (RELOC_WDISP30, 2,  2,\t30, true,  0, complain_overflow_signed,\t  0, \"WDISP30\",\t    false, 0, 0x3fffffff, false),\n+  HOWTO (RELOC_WDISP22, 2,  2,\t22, true,  0, complain_overflow_signed,\t  0, \"WDISP22\",\t    false, 0, 0x003fffff, false),\n+  HOWTO (RELOC_HI22,   10,  2,\t22, false, 0, complain_overflow_bitfield, 0, \"HI22\",\t    false, 0, 0x003fffff, false),\n+  HOWTO (RELOC_22,\t0,  2,\t22, false, 0, complain_overflow_bitfield, 0, \"22\",\t    false, 0, 0x003fffff, false),\n+  HOWTO (RELOC_13,\t0,  2,\t13, false, 0, complain_overflow_bitfield, 0, \"13\",\t    false, 0, 0x00001fff, false),\n+  HOWTO (RELOC_LO10,\t0,  2,\t10, false, 0, complain_overflow_dont,\t  0, \"LO10\",\t    false, 0, 0x000003ff, false),\n+  HOWTO (RELOC_SFA_BASE,0,  2,\t32, false, 0, complain_overflow_bitfield, 0, \"SFA_BASE\",    false, 0, 0xffffffff, false),\n+  HOWTO (RELOC_SFA_OFF13,0, 2,\t32, false, 0, complain_overflow_bitfield, 0, \"SFA_OFF13\",   false, 0, 0xffffffff, false),\n+  HOWTO (RELOC_BASE10,\t0,  2,\t10, false, 0, complain_overflow_dont,\t  0, \"BASE10\",\t    false, 0, 0x000003ff, false),\n+  HOWTO (RELOC_BASE13,\t0,  2,\t13, false, 0, complain_overflow_signed,\t  0, \"BASE13\",\t    false, 0, 0x00001fff, false),\n+  HOWTO (RELOC_BASE22, 10,  2,\t22, false, 0, complain_overflow_bitfield, 0, \"BASE22\",\t    false, 0, 0x003fffff, false),\n+  HOWTO (RELOC_PC10,\t0,  2,\t10, true,  0, complain_overflow_dont,\t  0, \"PC10\",\t    false, 0, 0x000003ff, true),\n+  HOWTO (RELOC_PC22,   10,  2,\t22, true,  0, complain_overflow_signed,\t  0, \"PC22\",\t    false, 0, 0x003fffff, true),\n+  HOWTO (RELOC_JMP_TBL, 2,  2,\t30, true,  0, complain_overflow_signed,\t  0, \"JMP_TBL\",\t    false, 0, 0x3fffffff, false),\n+  HOWTO (RELOC_SEGOFF16,0,  2,\t0,  false, 0, complain_overflow_bitfield, 0, \"SEGOFF16\",    false, 0, 0x00000000, false),\n+  HOWTO (RELOC_GLOB_DAT,0,  2,\t0,  false, 0, complain_overflow_bitfield, 0, \"GLOB_DAT\",    false, 0, 0x00000000, false),\n+  HOWTO (RELOC_JMP_SLOT,0,  2,\t0,  false, 0, complain_overflow_bitfield, 0, \"JMP_SLOT\",    false, 0, 0x00000000, false),\n+  HOWTO (RELOC_RELATIVE,0,  2,\t0,  false, 0, complain_overflow_bitfield, 0, \"RELATIVE\",    false, 0, 0x00000000, false),\n+  HOWTO (0,\t\t0,  3,\t0,  false, 0, complain_overflow_dont,\t  0, \"R_SPARC_NONE\",false, 0, 0x00000000, true),\n+  HOWTO (0,\t\t0,  3,\t0,  false, 0, complain_overflow_dont,\t  0, \"R_SPARC_NONE\",false, 0, 0x00000000, true),\n #define RELOC_SPARC_REV32 RELOC_WDISP19\n-  HOWTO (RELOC_SPARC_REV32, 0, 2, 32, FALSE, 0, complain_overflow_dont,\t  0,\"R_SPARC_REV32\",FALSE, 0, 0xffffffff, FALSE),\n+  HOWTO (RELOC_SPARC_REV32, 0, 2, 32, false, 0, complain_overflow_dont,\t  0,\"R_SPARC_REV32\",false, 0, 0xffffffff, false),\n };\n \n /* Convert standard reloc records to \"arelent\" format (incl byte swap).  */\n \n reloc_howto_type howto_table_std[] =\n {\n   /* type\t       rs size bsz  pcrel bitpos ovrf\t\t\t  sf name     part_inpl readmask  setmask    pcdone.  */\n-HOWTO ( 0,\t       0,  0,\t8,  FALSE, 0, complain_overflow_bitfield,0,\"8\",\t\tTRUE, 0x000000ff,0x000000ff, FALSE),\n-HOWTO ( 1,\t       0,  1,\t16, FALSE, 0, complain_overflow_bitfield,0,\"16\",\tTRUE, 0x0000ffff,0x0000ffff, FALSE),\n-HOWTO ( 2,\t       0,  2,\t32, FALSE, 0, complain_overflow_bitfield,0,\"32\",\tTRUE, 0xffffffff,0xffffffff, FALSE),\n-HOWTO ( 3,\t       0,  4,\t64, FALSE, 0, complain_overflow_bitfield,0,\"64\",\tTRUE, 0xdeaddead,0xdeaddead, FALSE),\n-HOWTO ( 4,\t       0,  0,\t8,  TRUE,  0, complain_overflow_signed,\t 0,\"DISP8\",\tTRUE, 0x000000ff,0x000000ff, FALSE),\n-HOWTO ( 5,\t       0,  1,\t16, TRUE,  0, complain_overflow_signed,\t 0,\"DISP16\",\tTRUE, 0x0000ffff,0x0000ffff, FALSE),\n-HOWTO ( 6,\t       0,  2,\t32, TRUE,  0, complain_overflow_signed,\t 0,\"DISP32\",\tTRUE, 0xffffffff,0xffffffff, FALSE),\n-HOWTO ( 7,\t       0,  4,\t64, TRUE,  0, complain_overflow_signed,\t 0,\"DISP64\",\tTRUE, 0xfeedface,0xfeedface, FALSE),\n-HOWTO ( 8,\t       0,  2,\t 0, FALSE, 0, complain_overflow_bitfield,0,\"GOT_REL\",\tFALSE,\t       0,0x00000000, FALSE),\n-HOWTO ( 9,\t       0,  1,\t16, FALSE, 0, complain_overflow_bitfield,0,\"BASE16\",\tFALSE,0xffffffff,0xffffffff, FALSE),\n-HOWTO (10,\t       0,  2,\t32, FALSE, 0, complain_overflow_bitfield,0,\"BASE32\",\tFALSE,0xffffffff,0xffffffff, FALSE),\n+HOWTO ( 0,\t       0,  0,\t8,  false, 0, complain_overflow_bitfield,0,\"8\",\t\ttrue, 0x000000ff,0x000000ff, false),\n+HOWTO ( 1,\t       0,  1,\t16, false, 0, complain_overflow_bitfield,0,\"16\",\ttrue, 0x0000ffff,0x0000ffff, false),\n+HOWTO ( 2,\t       0,  2,\t32, false, 0, complain_overflow_bitfield,0,\"32\",\ttrue, 0xffffffff,0xffffffff, false),\n+HOWTO ( 3,\t       0,  4,\t64, false, 0, complain_overflow_bitfield,0,\"64\",\ttrue, 0xdeaddead,0xdeaddead, false),\n+HOWTO ( 4,\t       0,  0,\t8,  true,  0, complain_overflow_signed,\t 0,\"DISP8\",\ttrue, 0x000000ff,0x000000ff, false),\n+HOWTO ( 5,\t       0,  1,\t16, true,  0, complain_overflow_signed,\t 0,\"DISP16\",\ttrue, 0x0000ffff,0x0000ffff, false),\n+HOWTO ( 6,\t       0,  2,\t32, true,  0, complain_overflow_signed,\t 0,\"DISP32\",\ttrue, 0xffffffff,0xffffffff, false),\n+HOWTO ( 7,\t       0,  4,\t64, true,  0, complain_overflow_signed,\t 0,\"DISP64\",\ttrue, 0xfeedface,0xfeedface, false),\n+HOWTO ( 8,\t       0,  2,\t 0, false, 0, complain_overflow_bitfield,0,\"GOT_REL\",\tfalse,\t       0,0x00000000, false),\n+HOWTO ( 9,\t       0,  1,\t16, false, 0, complain_overflow_bitfield,0,\"BASE16\",\tfalse,0xffffffff,0xffffffff, false),\n+HOWTO (10,\t       0,  2,\t32, false, 0, complain_overflow_bitfield,0,\"BASE32\",\tfalse,0xffffffff,0xffffffff, false),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n-  HOWTO (16,\t       0,  2,\t 0, FALSE, 0, complain_overflow_bitfield,0,\"JMP_TABLE\", FALSE,\t       0,0x00000000, FALSE),\n+  HOWTO (16,\t       0,  2,\t 0, false, 0, complain_overflow_bitfield,0,\"JMP_TABLE\", false,\t       0,0x00000000, false),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n@@ -257,15 +257,15 @@ EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n-  HOWTO (32,\t       0,  2,\t 0, FALSE, 0, complain_overflow_bitfield,0,\"RELATIVE\",\tFALSE,\t       0,0x00000000, FALSE),\n+  HOWTO (32,\t       0,  2,\t 0, false, 0, complain_overflow_bitfield,0,\"RELATIVE\",\tfalse,\t       0,0x00000000, false),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n EMPTY_HOWTO (-1),\n-  HOWTO (40,\t       0,  2,\t 0, FALSE, 0, complain_overflow_bitfield,0,\"BASEREL\",\tFALSE,\t       0,0x00000000, FALSE),\n+  HOWTO (40,\t       0,  2,\t 0, false, 0, complain_overflow_bitfield,0,\"BASEREL\",\tfalse,\t       0,0x00000000, false),\n };\n \n #define TABLE_SIZE(TABLE)\t(sizeof (TABLE) / sizeof (TABLE[0]))\n@@ -434,16 +434,16 @@ NAME (aout, swap_exec_header_out) (bfd *abfd,\n \n /* Make all the section for an a.out file.  */\n \n-bfd_boolean\n+bool\n NAME (aout, make_sections) (bfd *abfd)\n {\n   if (obj_textsec (abfd) == NULL && bfd_make_section (abfd, \".text\") == NULL)\n-    return FALSE;\n+    return false;\n   if (obj_datasec (abfd) == NULL && bfd_make_section (abfd, \".data\") == NULL)\n-    return FALSE;\n+    return false;\n   if (obj_bsssec (abfd) == NULL && bfd_make_section (abfd, \".bss\") == NULL)\n-    return FALSE;\n-  return TRUE;\n+    return false;\n+  return true;\n }\n \n /*\n@@ -672,13 +672,13 @@ FUNCTION\n \taout_@var{size}_mkobject\n \n SYNOPSIS\n-\tbfd_boolean aout_@var{size}_mkobject, (bfd *abfd);\n+\tbool aout_@var{size}_mkobject, (bfd *abfd);\n \n DESCRIPTION\n \tInitialize BFD @var{abfd} for use with a.out files.\n */\n \n-bfd_boolean\n+bool\n NAME (aout, mkobject) (bfd *abfd)\n {\n   struct aout_data_struct *rawptr;\n@@ -688,7 +688,7 @@ NAME (aout, mkobject) (bfd *abfd)\n \n   rawptr = (struct aout_data_struct *) bfd_zalloc (abfd, amt);\n   if (rawptr == NULL)\n-    return FALSE;\n+    return false;\n \n   abfd->tdata.aout_data = rawptr;\n   exec_hdr (abfd) = &(rawptr->e);\n@@ -697,7 +697,7 @@ NAME (aout, mkobject) (bfd *abfd)\n   obj_datasec (abfd) = NULL;\n   obj_bsssec (abfd) = NULL;\n \n-  return TRUE;\n+  return true;\n }\n \n /*\n@@ -708,7 +708,7 @@ SYNOPSIS\n \tenum machine_type  aout_@var{size}_machine_type\n \t (enum bfd_architecture arch,\n \t  unsigned long machine,\n-\t  bfd_boolean *unknown);\n+\t  bool *unknown);\n \n DESCRIPTION\n \tKeep track of machine architecture and machine type for\n@@ -723,12 +723,12 @@ DESCRIPTION\n enum machine_type\n NAME (aout, machine_type) (enum bfd_architecture arch,\n \t\t\t   unsigned long machine,\n-\t\t\t   bfd_boolean *unknown)\n+\t\t\t   bool *unknown)\n {\n   enum machine_type arch_flags;\n \n   arch_flags = M_UNKNOWN;\n-  *unknown = TRUE;\n+  *unknown = true;\n \n   switch (arch)\n     {\n@@ -830,7 +830,7 @@ NAME (aout, machine_type) (enum bfd_architecture arch,\n       break;\n \n     case bfd_arch_vax:\n-      *unknown = FALSE;\n+      *unknown = false;\n       break;\n \n     case bfd_arch_cris:\n@@ -843,7 +843,7 @@ NAME (aout, machine_type) (enum bfd_architecture arch,\n     }\n \n   if (arch_flags != M_UNKNOWN)\n-    *unknown = FALSE;\n+    *unknown = false;\n \n   return arch_flags;\n }\n@@ -853,7 +853,7 @@ FUNCTION\n \taout_@var{size}_set_arch_mach\n \n SYNOPSIS\n-\tbfd_boolean aout_@var{size}_set_arch_mach,\n+\tbool aout_@var{size}_set_arch_mach,\n \t (bfd *,\n \t  enum bfd_architecture arch,\n \t  unsigned long machine);\n@@ -864,21 +864,21 @@ DESCRIPTION\n \tcan support the architecture required.\n */\n \n-bfd_boolean\n+bool\n NAME (aout, set_arch_mach) (bfd *abfd,\n \t\t\t    enum bfd_architecture arch,\n \t\t\t    unsigned long machine)\n {\n   if (! bfd_default_set_arch_mach (abfd, arch, machine))\n-    return FALSE;\n+    return false;\n \n   if (arch != bfd_arch_unknown)\n     {\n-      bfd_boolean unknown;\n+      bool unknown;\n \n       NAME (aout, machine_type) (arch, machine, &unknown);\n       if (unknown)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Determine the size of a relocation entry.  */\n@@ -962,7 +962,7 @@ adjust_z_magic (bfd *abfd, struct internal_exec *execp)\n   file_ptr text_end;\n   const struct aout_backend_data *abdp;\n   /* TRUE if text includes exec header.  */\n-  bfd_boolean ztih;\n+  bool ztih;\n   asection *text = obj_textsec (abfd);\n   asection *data = obj_datasec (abfd);\n   asection *bss = obj_bsssec (abfd);\n@@ -1104,16 +1104,16 @@ adjust_n_magic (bfd *abfd, struct internal_exec *execp)\n   N_SET_MAGIC (execp, NMAGIC);\n }\n \n-bfd_boolean\n+bool\n NAME (aout, adjust_sizes_and_vmas) (bfd *abfd)\n {\n   struct internal_exec *execp = exec_hdr (abfd);\n \n   if (! NAME (aout, make_sections) (abfd))\n-    return FALSE;\n+    return false;\n \n   if (adata (abfd).magic != undecided_magic)\n-    return TRUE;\n+    return true;\n \n   execp->a_text = align_power (obj_textsec (abfd)->size,\n \t\t\t       obj_textsec (abfd)->alignment_power);\n@@ -1188,23 +1188,23 @@ NAME (aout, adjust_sizes_and_vmas) (bfd *abfd)\n \t   obj_bsssec (abfd)->vma, execp->a_bss);\n #endif\n \n-  return TRUE;\n+  return true;\n }\n \n /*\n FUNCTION\n \taout_@var{size}_new_section_hook\n \n SYNOPSIS\n-\tbfd_boolean aout_@var{size}_new_section_hook,\n+\tbool aout_@var{size}_new_section_hook,\n \t   (bfd *abfd,\n \t    asection *newsect);\n \n DESCRIPTION\n \tCalled by the BFD in response to a @code{bfd_make_section}\n \trequest.\n */\n-bfd_boolean\n+bool\n NAME (aout, new_section_hook) (bfd *abfd, asection *newsect)\n {\n   /* Align to double at least.  */\n@@ -1233,7 +1233,7 @@ NAME (aout, new_section_hook) (bfd *abfd, asection *newsect)\n   return _bfd_generic_new_section_hook (abfd, newsect);\n }\n \n-bfd_boolean\n+bool\n NAME (aout, set_section_contents) (bfd *abfd,\n \t\t\t\t   sec_ptr section,\n \t\t\t\t   const void * location,\n@@ -1243,13 +1243,13 @@ NAME (aout, set_section_contents) (bfd *abfd,\n   if (! abfd->output_has_begun)\n     {\n       if (! NAME (aout, adjust_sizes_and_vmas) (abfd))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (section == obj_bsssec (abfd))\n     {\n       bfd_set_error (bfd_error_no_contents);\n-      return FALSE;\n+      return false;\n     }\n \n   if (section != obj_textsec (abfd)\n@@ -1265,23 +1265,23 @@ NAME (aout, set_section_contents) (bfd *abfd,\n \t   (_(\"%pB: can not represent section `%pA' in a.out object file format\"),\n \t     abfd, section);\n \t  bfd_set_error (bfd_error_nonrepresentable_section);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n   if (count != 0)\n     {\n       if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0\n \t  || bfd_bwrite (location, count, abfd) != count)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* Read the external symbols from an a.out file.  */\n \n-static bfd_boolean\n+static bool\n aout_get_external_symbols (bfd *abfd)\n {\n   if (obj_aout_external_syms (abfd) == NULL)\n@@ -1292,22 +1292,22 @@ aout_get_external_symbols (bfd *abfd)\n \n       count = amt / EXTERNAL_NLIST_SIZE;\n       if (count == 0)\n-\treturn TRUE;\t\t/* Nothing to do.  */\n+\treturn true;\t\t/* Nothing to do.  */\n \n #ifdef USE_MMAP\n       if (! bfd_get_file_window (abfd, obj_sym_filepos (abfd), amt,\n-\t\t\t\t &obj_aout_sym_window (abfd), TRUE))\n-\treturn FALSE;\n+\t\t\t\t &obj_aout_sym_window (abfd), true))\n+\treturn false;\n       syms = (struct external_nlist *) obj_aout_sym_window (abfd).data;\n #else\n       /* We allocate using malloc to make the values easy to free\n \t later on.  If we put them on the objalloc it might not be\n \t possible to free them.  */\n       if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)\n-\treturn FALSE;\n+\treturn false;\n       syms = (struct external_nlist *) _bfd_malloc_and_read (abfd, amt, amt);\n       if (syms == NULL)\n-\treturn FALSE;\n+\treturn false;\n #endif\n \n       obj_aout_external_syms (abfd) = syms;\n@@ -1325,31 +1325,31 @@ aout_get_external_symbols (bfd *abfd)\n       /* Get the size of the strings.  */\n       if (bfd_seek (abfd, obj_str_filepos (abfd), SEEK_SET) != 0\n \t  || bfd_bread ((void *) string_chars, amt, abfd) != amt)\n-\treturn FALSE;\n+\treturn false;\n       stringsize = GET_WORD (abfd, string_chars);\n       if (stringsize == 0)\n \tstringsize = 1;\n       else if (stringsize < BYTES_IN_WORD\n \t       || (size_t) stringsize != stringsize)\n \t{\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n #ifdef USE_MMAP\n       if (stringsize >= BYTES_IN_WORD)\n \t{\n \t  if (! bfd_get_file_window (abfd, obj_str_filepos (abfd), stringsize + 1,\n-\t\t\t\t     &obj_aout_string_window (abfd), TRUE))\n-\t    return FALSE;\n+\t\t\t\t     &obj_aout_string_window (abfd), true))\n+\t    return false;\n \t  strings = (char *) obj_aout_string_window (abfd).data;\n \t}\n       else\n #endif\n \t{\n \t  strings = (char *) bfd_malloc (stringsize + 1);\n \t  if (strings == NULL)\n-\t    return FALSE;\n+\t    return false;\n \n \t  if (stringsize >= BYTES_IN_WORD)\n \t    {\n@@ -1359,7 +1359,7 @@ aout_get_external_symbols (bfd *abfd)\n \t      if (bfd_bread (strings + BYTES_IN_WORD, amt, abfd) != amt)\n \t\t{\n \t\t  free (strings);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t    }\n \t}\n@@ -1373,15 +1373,15 @@ aout_get_external_symbols (bfd *abfd)\n       obj_aout_external_string_size (abfd) = stringsize;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Translate an a.out symbol into a BFD symbol.  The desc, other, type\n    and symbol->value fields of CACHE_PTR will be set from the a.out\n    nlist structure.  This function is responsible for setting\n    symbol->flags and symbol->section, and adjusting symbol->value.  */\n \n-static bfd_boolean\n+static bool\n translate_from_native_sym_flags (bfd *abfd, aout_symbol_type *cache_ptr)\n {\n   flagword visible;\n@@ -1416,7 +1416,7 @@ translate_from_native_sym_flags (bfd *abfd, aout_symbol_type *cache_ptr)\n       cache_ptr->symbol.section = sec;\n       cache_ptr->symbol.value -= sec->vma;\n \n-      return TRUE;\n+      return true;\n     }\n \n   /* Get the default visibility.  This does not apply to all types, so\n@@ -1547,12 +1547,12 @@ translate_from_native_sym_flags (bfd *abfd, aout_symbol_type *cache_ptr)\n       break;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Set the fields of SYM_POINTER according to CACHE_PTR.  */\n \n-static bfd_boolean\n+static bool\n translate_to_native_sym_flags (bfd *abfd,\n \t\t\t       asymbol *cache_ptr,\n \t\t\t       struct external_nlist *sym_pointer)\n@@ -1579,7 +1579,7 @@ translate_to_native_sym_flags (bfd *abfd,\n \t abfd,\n \t cache_ptr->name != NULL ? cache_ptr->name : _(\"*unknown*\"));\n       bfd_set_error (bfd_error_nonrepresentable_section);\n-      return FALSE;\n+      return false;\n     }\n \n   if (sec->output_section != NULL)\n@@ -1613,7 +1613,7 @@ translate_to_native_sym_flags (bfd *abfd,\n \t   (_(\"%pB: can not represent section `%pA' in a.out object file format\"),\n \t     abfd, sec);\n \t  bfd_set_error (bfd_error_nonrepresentable_section);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n@@ -1662,7 +1662,7 @@ translate_to_native_sym_flags (bfd *abfd,\n \n   PUT_WORD (abfd, value, sym_pointer->e_value);\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* Native-level interface to symbols.  */\n@@ -1682,14 +1682,14 @@ NAME (aout, make_empty_symbol) (bfd *abfd)\n \n /* Translate a set of external symbols into internal symbols.  */\n \n-bfd_boolean\n+bool\n NAME (aout, translate_symbol_table) (bfd *abfd,\n \t\t\t\t     aout_symbol_type *in,\n \t\t\t\t     struct external_nlist *ext,\n \t\t\t\t     bfd_size_type count,\n \t\t\t\t     char *str,\n \t\t\t\t     bfd_size_type strsize,\n-\t\t\t\t     bfd_boolean dynamic)\n+\t\t\t\t     bool dynamic)\n {\n   struct external_nlist *ext_end;\n \n@@ -1716,7 +1716,7 @@ NAME (aout, translate_symbol_table) (bfd *abfd,\n \t    (_(\"%pB: invalid string offset %\" PRIu64 \" >= %\" PRIu64),\n \t     abfd, (uint64_t) x, (uint64_t) strsize);\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       in->symbol.value = GET_SWORD (abfd,  ext->e_value);\n@@ -1726,20 +1726,20 @@ NAME (aout, translate_symbol_table) (bfd *abfd,\n       in->symbol.udata.p = NULL;\n \n       if (! translate_from_native_sym_flags (abfd, in))\n-\treturn FALSE;\n+\treturn false;\n \n       if (dynamic)\n \tin->symbol.flags |= BSF_DYNAMIC;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* We read the symbols into a buffer, which is discarded when this\n    function exits.  We read the strings into a buffer large enough to\n    hold them all plus all the cached symbol entries.  */\n \n-bfd_boolean\n+bool\n NAME (aout, slurp_symbol_table) (bfd *abfd)\n {\n   struct external_nlist *old_external_syms;\n@@ -1748,21 +1748,21 @@ NAME (aout, slurp_symbol_table) (bfd *abfd)\n \n   /* If there's no work to be done, don't do any.  */\n   if (obj_aout_symbols (abfd) != NULL)\n-    return TRUE;\n+    return true;\n \n   old_external_syms = obj_aout_external_syms (abfd);\n \n   if (! aout_get_external_symbols (abfd))\n-    return FALSE;\n+    return false;\n \n   cached_size = obj_aout_external_sym_count (abfd);\n   if (cached_size == 0)\n-    return TRUE;\t\t/* Nothing to do.  */\n+    return true;\t\t/* Nothing to do.  */\n \n   cached_size *= sizeof (aout_symbol_type);\n   cached = (aout_symbol_type *) bfd_zmalloc (cached_size);\n   if (cached == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Convert from external symbol information to internal.  */\n   if (! (NAME (aout, translate_symbol_table)\n@@ -1771,10 +1771,10 @@ NAME (aout, slurp_symbol_table) (bfd *abfd)\n \t  obj_aout_external_sym_count (abfd),\n \t  obj_aout_external_strings (abfd),\n \t  obj_aout_external_string_size (abfd),\n-\t  FALSE)))\n+\t  false)))\n     {\n       free (cached);\n-      return FALSE;\n+      return false;\n     }\n \n   abfd->symcount = obj_aout_external_sym_count (abfd);\n@@ -1796,7 +1796,7 @@ NAME (aout, slurp_symbol_table) (bfd *abfd)\n       obj_aout_external_syms (abfd) = NULL;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* We use a hash table when writing out symbols so that we only write\n@@ -1815,9 +1815,9 @@ static inline bfd_size_type\n add_to_stringtab (bfd *abfd,\n \t\t  struct bfd_strtab_hash *tab,\n \t\t  const char *str,\n-\t\t  bfd_boolean copy)\n+\t\t  bool copy)\n {\n-  bfd_boolean hash;\n+  bool hash;\n   bfd_size_type str_index;\n \n   /* An index of 0 always means the empty string.  */\n@@ -1826,9 +1826,9 @@ add_to_stringtab (bfd *abfd,\n \n   /* Don't hash if BFD_TRADITIONAL_FORMAT is set, because SunOS dbx\n      doesn't understand a hashed string table.  */\n-  hash = TRUE;\n+  hash = true;\n   if ((abfd->flags & BFD_TRADITIONAL_FORMAT) != 0)\n-    hash = FALSE;\n+    hash = false;\n \n   str_index = _bfd_stringtab_add (tab, str, hash, copy);\n \n@@ -1843,7 +1843,7 @@ add_to_stringtab (bfd *abfd,\n /* Write out a strtab.  ABFD is already at the right location in the\n    file.  */\n \n-static bfd_boolean\n+static bool\n emit_stringtab (bfd *abfd, struct bfd_strtab_hash *tab)\n {\n   bfd_byte buffer[BYTES_IN_WORD];\n@@ -1852,12 +1852,12 @@ emit_stringtab (bfd *abfd, struct bfd_strtab_hash *tab)\n   /* The string table starts with the size.  */\n   PUT_WORD (abfd, _bfd_stringtab_size (tab) + BYTES_IN_WORD, buffer);\n   if (bfd_bwrite ((void *) buffer, amt, abfd) != amt)\n-    return FALSE;\n+    return false;\n \n   return _bfd_stringtab_emit (abfd, tab);\n }\n \f\n-bfd_boolean\n+bool\n NAME (aout, write_syms) (bfd *abfd)\n {\n   unsigned int count ;\n@@ -1866,7 +1866,7 @@ NAME (aout, write_syms) (bfd *abfd)\n \n   strtab = _bfd_stringtab_init ();\n   if (strtab == NULL)\n-    return FALSE;\n+    return false;\n \n   for (count = 0; count < bfd_get_symcount (abfd); count++)\n     {\n@@ -1875,7 +1875,7 @@ NAME (aout, write_syms) (bfd *abfd)\n       struct external_nlist nsp;\n       size_t amt;\n \n-      indx = add_to_stringtab (abfd, strtab, g->name, FALSE);\n+      indx = add_to_stringtab (abfd, strtab, g->name, false);\n       if (indx == (bfd_size_type) -1)\n \tgoto error_return;\n       PUT_WORD (abfd, indx, (bfd_byte *) nsp.e_strx);\n@@ -1910,11 +1910,11 @@ NAME (aout, write_syms) (bfd *abfd)\n \n   _bfd_stringtab_free (strtab);\n \n-  return TRUE;\n+  return true;\n \n  error_return:\n   _bfd_stringtab_free (strtab);\n-  return FALSE;\n+  return false;\n }\n \f\n long\n@@ -2298,7 +2298,7 @@ NAME (aout, swap_std_reloc_in) (bfd *abfd,\n \n /* Read and swap the relocs for a section.  */\n \n-bfd_boolean\n+bool\n NAME (aout, slurp_reloc_table) (bfd *abfd, sec_ptr asect, asymbol **symbols)\n {\n   bfd_size_type count;\n@@ -2311,10 +2311,10 @@ NAME (aout, slurp_reloc_table) (bfd *abfd, sec_ptr asect, asymbol **symbols)\n   bfd_size_type amt;\n \n   if (asect->relocation)\n-    return TRUE;\n+    return true;\n \n   if (asect->flags & SEC_CONSTRUCTOR)\n-    return TRUE;\n+    return true;\n \n   if (asect == obj_datasec (abfd))\n     reloc_size = exec_hdr (abfd)->a_drsize;\n@@ -2325,26 +2325,26 @@ NAME (aout, slurp_reloc_table) (bfd *abfd, sec_ptr asect, asymbol **symbols)\n   else\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n   each_size = obj_reloc_entry_size (abfd);\n   count = reloc_size / each_size;\n   if (count == 0)\n-    return TRUE;\t\t/* Nothing to be done.  */\n+    return true;\t\t/* Nothing to be done.  */\n \n   if (bfd_seek (abfd, asect->rel_filepos, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n   relocs = _bfd_malloc_and_read (abfd, reloc_size, reloc_size);\n   if (relocs == NULL)\n-    return FALSE;\n+    return false;\n \n   amt = count * sizeof (arelent);\n   reloc_cache = (arelent *) bfd_zmalloc (amt);\n   if (reloc_cache == NULL)\n     {\n       free (relocs);\n-      return FALSE;\n+      return false;\n     }\n \n   cache_ptr = reloc_cache;\n@@ -2370,12 +2370,12 @@ NAME (aout, slurp_reloc_table) (bfd *abfd, sec_ptr asect, asymbol **symbols)\n   asect->relocation = reloc_cache;\n   asect->reloc_count = cache_ptr - reloc_cache;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Write out a relocation section into an object file.  */\n \n-bfd_boolean\n+bool\n NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)\n {\n   arelent **generic;\n@@ -2386,13 +2386,13 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)\n   bfd_size_type natsize;\n \n   if (count == 0 || section->orelocation == NULL)\n-    return TRUE;\n+    return true;\n \n   each_size = obj_reloc_entry_size (abfd);\n   natsize = (bfd_size_type) each_size * count;\n   native = (unsigned char *) bfd_zalloc (abfd, natsize);\n   if (!native)\n-    return FALSE;\n+    return false;\n \n   generic = section->orelocation;\n \n@@ -2411,7 +2411,7 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)\n \t      bfd_set_error (bfd_error_invalid_operation);\n \t      _bfd_error_handler (_(\"%pB: attempt to write out \"\n \t\t\t\t    \"unknown reloc type\"), abfd);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  MY_swap_ext_reloc_out (abfd, *generic,\n \t\t\t\t (struct reloc_ext_external *) natptr);\n@@ -2429,7 +2429,7 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)\n \t      bfd_set_error (bfd_error_invalid_operation);\n \t      _bfd_error_handler (_(\"%pB: attempt to write out \"\n \t\t\t\t    \"unknown reloc type\"), abfd);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  MY_swap_std_reloc_out (abfd, *generic,\n \t\t\t\t (struct reloc_std_external *) natptr);\n@@ -2439,11 +2439,11 @@ NAME (aout, squirt_out_relocs) (bfd *abfd, asection *section)\n   if (bfd_bwrite ((void *) native, natsize, abfd) != natsize)\n     {\n       bfd_release (abfd, native);\n-      return FALSE;\n+      return false;\n     }\n   bfd_release (abfd, native);\n \n-  return TRUE;\n+  return true;\n }\n \n /* This is stupid.  This function should be a boolean predicate.  */\n@@ -2613,7 +2613,7 @@ NAME (aout, print_symbol) (bfd *abfd,\n \n long\n NAME (aout, read_minisymbols) (bfd *abfd,\n-\t\t\t       bfd_boolean dynamic,\n+\t\t\t       bool dynamic,\n \t\t\t       void * *minisymsp,\n \t\t\t       unsigned int *sizep)\n {\n@@ -2646,7 +2646,7 @@ NAME (aout, read_minisymbols) (bfd *abfd,\n \n asymbol *\n NAME (aout, minisymbol_to_symbol) (bfd *abfd,\n-\t\t\t\t   bfd_boolean dynamic,\n+\t\t\t\t   bool dynamic,\n \t\t\t\t   const void * minisym,\n \t\t\t\t   asymbol *sym)\n {\n@@ -2664,7 +2664,7 @@ NAME (aout, minisymbol_to_symbol) (bfd *abfd,\n \t  (bfd_size_type) 1,\n \t  obj_aout_external_strings (abfd),\n \t  obj_aout_external_string_size (abfd),\n-\t  FALSE)))\n+\t  false)))\n     return NULL;\n \n   return sym;\n@@ -2674,7 +2674,7 @@ NAME (aout, minisymbol_to_symbol) (bfd *abfd,\n    and return the name of the source file and the line nearest to the\n    wanted location.  */\n \n-bfd_boolean\n+bool\n NAME (aout, find_nearest_line) (bfd *abfd,\n \t\t\t\tasymbol **symbols,\n \t\t\t\tasection *section,\n@@ -2836,7 +2836,7 @@ NAME (aout, find_nearest_line) (bfd *abfd,\n       buf = (char *) bfd_malloc (filelen + funclen + 3);\n       adata (abfd).line_buf = buf;\n       if (buf == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (main_file_name != NULL)\n@@ -2868,7 +2868,7 @@ NAME (aout, find_nearest_line) (bfd *abfd,\n \t{\n \t  /* PR binutils/20892: In a corrupt input file func can be empty.  */\n \t  * functionname_ptr = NULL;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       /* The caller expects a symbol name.  We actually have a\n \t function name, without the leading underscore.  Put the\n@@ -2887,7 +2887,7 @@ NAME (aout, find_nearest_line) (bfd *abfd,\n       *functionname_ptr = buf;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n int\n@@ -2900,14 +2900,14 @@ NAME (aout, sizeof_headers) (bfd *abfd,\n /* Free all information we have cached for this BFD.  We can always\n    read it again later if we need it.  */\n \n-bfd_boolean\n+bool\n NAME (aout, bfd_free_cached_info) (bfd *abfd)\n {\n   asection *o;\n \n   if (bfd_get_format (abfd) != bfd_object\n       || abfd->tdata.aout_data == NULL)\n-    return TRUE;\n+    return true;\n \n #define BFCI_FREE(x) do { free (x); x = NULL; } while (0)\n   BFCI_FREE (obj_aout_symbols (abfd));\n@@ -2924,7 +2924,7 @@ NAME (aout, bfd_free_cached_info) (bfd *abfd)\n     BFCI_FREE (o->relocation);\n #undef BFCI_FREE\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* a.out link code.  */\n@@ -2953,7 +2953,7 @@ NAME (aout, link_hash_newfunc) (struct bfd_hash_entry *entry,\n   if (ret)\n     {\n       /* Set local fields.  */\n-      ret->written = FALSE;\n+      ret->written = false;\n       ret->indx = -1;\n     }\n \n@@ -2962,7 +2962,7 @@ NAME (aout, link_hash_newfunc) (struct bfd_hash_entry *entry,\n \n /* Initialize an a.out link hash table.  */\n \n-bfd_boolean\n+bool\n NAME (aout, link_hash_table_init) (struct aout_link_hash_table *table,\n \t\t\t\t   bfd *abfd,\n \t\t\t\t   struct bfd_hash_entry *(*newfunc)\n@@ -2997,17 +2997,16 @@ NAME (aout, link_hash_table_create) (bfd *abfd)\n \n /* Add all symbols from an object file to the hash table.  */\n \n-static bfd_boolean\n+static bool\n aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n {\n-  bfd_boolean (*add_one_symbol)\n+  bool (*add_one_symbol)\n     (struct bfd_link_info *, bfd *, const char *, flagword, asection *,\n-\t     bfd_vma, const char *, bfd_boolean, bfd_boolean,\n-\t     struct bfd_link_hash_entry **);\n+     bfd_vma, const char *, bool, bool, struct bfd_link_hash_entry **);\n   struct external_nlist *syms;\n   bfd_size_type sym_count;\n   char *strings;\n-  bfd_boolean copy;\n+  bool copy;\n   struct aout_link_hash_entry **sym_hash;\n   struct external_nlist *p;\n   struct external_nlist *pend;\n@@ -3017,19 +3016,19 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n   sym_count = obj_aout_external_sym_count (abfd);\n   strings = obj_aout_external_strings (abfd);\n   if (info->keep_memory)\n-    copy = FALSE;\n+    copy = false;\n   else\n-    copy = TRUE;\n+    copy = true;\n \n   if (aout_backend_info (abfd)->add_dynamic_symbols != NULL)\n     {\n       if (! ((*aout_backend_info (abfd)->add_dynamic_symbols)\n \t     (abfd, info, &syms, &sym_count, &strings)))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (sym_count == 0)\n-    return TRUE;\t\t/* Nothing to do.  */\n+    return true;\t\t/* Nothing to do.  */\n \n   /* We keep a list of the linker hash table entries that correspond\n      to particular symbols.  We could just look them up in the hash\n@@ -3038,7 +3037,7 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n   amt = sym_count * sizeof (struct aout_link_hash_entry *);\n   sym_hash = (struct aout_link_hash_entry **) bfd_alloc (abfd, amt);\n   if (sym_hash == NULL)\n-    return FALSE;\n+    return false;\n   obj_aout_sym_hashes (abfd) = sym_hash;\n \n   add_one_symbol = aout_backend_info (abfd)->add_one_symbol;\n@@ -3066,7 +3065,7 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \n       /* PR 19629: Corrupt binaries can contain illegal string offsets.  */\n       if (GET_WORD (abfd, p->e_strx) >= obj_aout_external_string_size (abfd))\n-\treturn FALSE;\n+\treturn false;\n       name = strings + GET_WORD (abfd, p->e_strx);\n       value = GET_WORD (abfd, p->e_value);\n       flags = BSF_GLOBAL;\n@@ -3125,11 +3124,11 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \t     which this one really is.  */\n \t  /* See PR 20925 for a reproducer.  */\n \t  if (p + 1 >= pend)\n-\t    return FALSE;\n+\t    return false;\n \t  ++p;\n \t  /* PR 19629: Corrupt binaries can contain illegal string offsets.  */\n \t  if (GET_WORD (abfd, p->e_strx) >= obj_aout_external_string_size (abfd))\n-\t    return FALSE;\n+\t    return false;\n \t  string = strings + GET_WORD (abfd, p->e_strx);\n \t  section = bfd_ind_section_ptr;\n \t  flags |= BSF_INDIRECT;\n@@ -3160,12 +3159,12 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \t  /* A warning symbol.  The next symbol is the one to warn\n \t     about.  If there is no next symbol, just look away.  */\n \t  if (p + 1 >= pend)\n-\t    return TRUE;\n+\t    return true;\n \t  ++p;\n \t  string = name;\n \t  /* PR 19629: Corrupt binaries can contain illegal string offsets.  */\n \t  if (GET_WORD (abfd, p->e_strx) >= obj_aout_external_string_size (abfd))\n-\t    return FALSE;\n+\t    return false;\n \t  name = strings + GET_WORD (abfd, p->e_strx);\n \t  section = bfd_und_section_ptr;\n \t  flags |= BSF_WARNING;\n@@ -3196,9 +3195,9 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \t}\n \n       if (! ((*add_one_symbol)\n-\t     (info, abfd, name, flags, section, value, string, copy, FALSE,\n+\t     (info, abfd, name, flags, section, value, string, copy, false,\n \t      (struct bfd_link_hash_entry **) sym_hash)))\n-\treturn FALSE;\n+\treturn false;\n \n       /* Restrict the maximum alignment of a common symbol based on\n \t the architecture, since a.out has no way to represent\n@@ -3224,12 +3223,12 @@ aout_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \t++sym_hash;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Free up the internal symbols read from an a.out file.  */\n \n-static bfd_boolean\n+static bool\n aout_link_free_symbols (bfd *abfd)\n {\n   if (obj_aout_external_syms (abfd) != NULL)\n@@ -3250,24 +3249,24 @@ aout_link_free_symbols (bfd *abfd)\n #endif\n       obj_aout_external_strings (abfd) = NULL;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Add symbols from an a.out object file.  */\n \n-static bfd_boolean\n+static bool\n aout_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n {\n   if (! aout_get_external_symbols (abfd))\n-    return FALSE;\n+    return false;\n   if (! aout_link_add_symbols (abfd, info))\n-    return FALSE;\n+    return false;\n   if (! info->keep_memory)\n     {\n       if (! aout_link_free_symbols (abfd))\n-\treturn FALSE;\n+\treturn false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Look through the internal symbols to see if this object file should\n@@ -3277,17 +3276,17 @@ aout_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n    known symbol but we do not include the object file in the link\n    (unless there is some other reason to include it).  */\n \n-static bfd_boolean\n+static bool\n aout_link_check_ar_symbols (bfd *abfd,\n \t\t\t    struct bfd_link_info *info,\n-\t\t\t    bfd_boolean *pneeded,\n+\t\t\t    bool *pneeded,\n \t\t\t    bfd **subsbfd)\n {\n   struct external_nlist *p;\n   struct external_nlist *pend;\n   char *strings;\n \n-  *pneeded = FALSE;\n+  *pneeded = false;\n \n   /* Look through all the symbols.  */\n   p = obj_aout_external_syms (abfd);\n@@ -3317,7 +3316,7 @@ aout_link_check_ar_symbols (bfd *abfd,\n \t}\n \n       name = strings + GET_WORD (abfd, p->e_strx);\n-      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);\n+      h = bfd_link_hash_lookup (info->hash, name, false, false, true);\n \n       /* We are only interested in symbols that are currently\n \t undefined or common.  */\n@@ -3378,9 +3377,9 @@ aout_link_check_ar_symbols (bfd *abfd,\n \n \t  if (!(*info->callbacks\n \t\t->add_archive_element) (info, abfd, name, subsbfd))\n-\t    return FALSE;\n-\t  *pneeded = TRUE;\n-\t  return TRUE;\n+\t    return false;\n+\t  *pneeded = true;\n+\t  return true;\n \t}\n \n       if (type == (N_UNDF | N_EXT))\n@@ -3406,9 +3405,9 @@ aout_link_check_ar_symbols (bfd *abfd,\n \t\t\t option in the linker.  */\n \t\t      if (!(*info->callbacks\n \t\t\t    ->add_archive_element) (info, abfd, name, subsbfd))\n-\t\t\treturn FALSE;\n-\t\t      *pneeded = TRUE;\n-\t\t      return TRUE;\n+\t\t\treturn false;\n+\t\t      *pneeded = true;\n+\t\t      return true;\n \t\t    }\n \t\t  /* Turn the current link symbol into a common\n \t\t     symbol.  It is already on the undefs list.  */\n@@ -3417,7 +3416,7 @@ aout_link_check_ar_symbols (bfd *abfd,\n \t\t    bfd_hash_allocate (&info->hash->table,\n \t\t\t\t       sizeof (struct bfd_link_hash_common_entry));\n \t\t  if (h->u.c.p == NULL)\n-\t\t    return FALSE;\n+\t\t    return false;\n \n \t\t  h->u.c.size = value;\n \n@@ -3455,37 +3454,37 @@ aout_link_check_ar_symbols (bfd *abfd,\n \t    {\n \t      if (!(*info->callbacks\n \t\t    ->add_archive_element) (info, abfd, name, subsbfd))\n-\t\treturn FALSE;\n-\t      *pneeded = TRUE;\n-\t      return TRUE;\n+\t\treturn false;\n+\t      *pneeded = true;\n+\t      return true;\n \t    }\n \t}\n     }\n \n   /* We do not need this object file.  */\n-  return TRUE;\n+  return true;\n }\n /* Check a single archive element to see if we need to include it in\n    the link.  *PNEEDED is set according to whether this element is\n    needed in the link or not.  This is called from\n    _bfd_generic_link_add_archive_symbols.  */\n \n-static bfd_boolean\n+static bool\n aout_link_check_archive_element (bfd *abfd,\n \t\t\t\t struct bfd_link_info *info,\n \t\t\t\t struct bfd_link_hash_entry *h ATTRIBUTE_UNUSED,\n \t\t\t\t const char *name ATTRIBUTE_UNUSED,\n-\t\t\t\t bfd_boolean *pneeded)\n+\t\t\t\t bool *pneeded)\n {\n   bfd *oldbfd;\n-  bfd_boolean needed;\n+  bool needed;\n \n   if (!aout_get_external_symbols (abfd))\n-    return FALSE;\n+    return false;\n \n   oldbfd = abfd;\n   if (!aout_link_check_ar_symbols (abfd, info, pneeded, &abfd))\n-    return FALSE;\n+    return false;\n \n   needed = *pneeded;\n   if (needed)\n@@ -3496,27 +3495,27 @@ aout_link_check_archive_element (bfd *abfd,\n \t{\n \t  if (!info->keep_memory\n \t      && !aout_link_free_symbols (oldbfd))\n-\t    return FALSE;\n+\t    return false;\n \t  if (!aout_get_external_symbols (abfd))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       if (!aout_link_add_symbols (abfd, info))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (!info->keep_memory || !needed)\n     {\n       if (!aout_link_free_symbols (abfd))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Given an a.out BFD, add symbols to the global hash table as\n    appropriate.  */\n \n-bfd_boolean\n+bool\n NAME (aout, link_add_symbols) (bfd *abfd, struct bfd_link_info *info)\n {\n   switch (bfd_get_format (abfd))\n@@ -3528,7 +3527,7 @@ NAME (aout, link_add_symbols) (bfd *abfd, struct bfd_link_info *info)\n \t(abfd, info, aout_link_check_archive_element);\n     default:\n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n     }\n }\n \f\n@@ -3623,7 +3622,7 @@ aout_link_includes_newfunc (struct bfd_hash_entry *entry,\n /* Write out a symbol that was not associated with an a.out input\n    object.  */\n \n-static bfd_boolean\n+static bool\n aout_link_write_other_symbol (struct bfd_hash_entry *bh, void *data)\n {\n   struct aout_link_hash_entry *h = (struct aout_link_hash_entry *) bh;\n@@ -3639,7 +3638,7 @@ aout_link_write_other_symbol (struct bfd_hash_entry *bh, void *data)\n     {\n       h = (struct aout_link_hash_entry *) h->root.u.i.link;\n       if (h->root.type == bfd_link_hash_new)\n-\treturn TRUE;\n+\treturn true;\n     }\n \n   output_bfd = flaginfo->output_bfd;\n@@ -3655,29 +3654,29 @@ aout_link_write_other_symbol (struct bfd_hash_entry *bh, void *data)\n     }\n \n   if (h->written)\n-    return TRUE;\n+    return true;\n \n-  h->written = TRUE;\n+  h->written = true;\n \n   /* An indx of -2 means the symbol must be written.  */\n   if (h->indx != -2\n       && (flaginfo->info->strip == strip_all\n \t  || (flaginfo->info->strip == strip_some\n \t      && bfd_hash_lookup (flaginfo->info->keep_hash, h->root.root.string,\n-\t\t\t\t  FALSE, FALSE) == NULL)))\n-    return TRUE;\n+\t\t\t\t  false, false) == NULL)))\n+    return true;\n \n   switch (h->root.type)\n     {\n     default:\n     case bfd_link_hash_warning:\n       abort ();\n       /* Avoid variable not initialized warnings.  */\n-      return TRUE;\n+      return true;\n     case bfd_link_hash_new:\n       /* This can happen for set symbols when sets are not being\n \t built.  */\n-      return TRUE;\n+      return true;\n     case bfd_link_hash_undefined:\n       type = N_UNDF | N_EXT;\n       val = 0;\n@@ -3715,14 +3714,14 @@ aout_link_write_other_symbol (struct bfd_hash_entry *bh, void *data)\n     case bfd_link_hash_indirect:\n       /* We ignore these symbols, since the indirected symbol is\n \t already in the hash table.  */\n-      return TRUE;\n+      return true;\n     }\n \n   H_PUT_8 (output_bfd, type, outsym.e_type);\n   H_PUT_8 (output_bfd, 0, outsym.e_other);\n   H_PUT_16 (output_bfd, 0, outsym.e_desc);\n   indx = add_to_stringtab (output_bfd, flaginfo->strtab, h->root.root.string,\n-\t\t\t   FALSE);\n+\t\t\t   false);\n   if (indx == - (bfd_size_type) 1)\n     /* FIXME: No way to handle errors.  */\n     abort ();\n@@ -3740,12 +3739,12 @@ aout_link_write_other_symbol (struct bfd_hash_entry *bh, void *data)\n   h->indx = obj_aout_external_sym_count (output_bfd);\n   ++obj_aout_external_sym_count (output_bfd);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Handle a link order which is supposed to generate a reloc.  */\n \n-static bfd_boolean\n+static bool\n aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n \t\t\t    asection *o,\n \t\t\t    struct bfd_link_order *p)\n@@ -3781,7 +3780,7 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n       r_extern = 1;\n       h = ((struct aout_link_hash_entry *)\n \t   bfd_wrapped_link_hash_lookup (flaginfo->output_bfd, flaginfo->info,\n-\t\t\t\t\t pr->u.name, FALSE, FALSE, TRUE));\n+\t\t\t\t\t pr->u.name, false, false, true));\n       if (h != NULL\n \t  && h->indx >= 0)\n \tr_index = h->indx;\n@@ -3792,9 +3791,9 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n \t     here.  I don't think that will ever matter for a global\n \t     symbol.  */\n \t  h->indx = -2;\n-\t  h->written = FALSE;\n+\t  h->written = false;\n \t  if (!aout_link_write_other_symbol (&h->root.root, flaginfo))\n-\t    return FALSE;\n+\t    return false;\n \t  r_index = h->indx;\n \t}\n       else\n@@ -3809,7 +3808,7 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n   if (howto == 0)\n     {\n       bfd_set_error (bfd_error_bad_value);\n-      return FALSE;\n+      return false;\n     }\n \n   if (o == obj_textsec (flaginfo->output_bfd))\n@@ -3882,12 +3881,12 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n \t  bfd_size_type size;\n \t  bfd_reloc_status_type r;\n \t  bfd_byte *buf;\n-\t  bfd_boolean ok;\n+\t  bool ok;\n \n \t  size = bfd_get_reloc_size (howto);\n \t  buf = (bfd_byte *) bfd_zmalloc (size);\n \t  if (buf == NULL && size != 0)\n-\t    return FALSE;\n+\t    return false;\n \t  r = MY_relocate_contents (howto, flaginfo->output_bfd,\n \t\t\t\t    (bfd_vma) pr->addend, buf);\n \t  switch (r)\n@@ -3910,7 +3909,7 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n \t\t\t\t\t (file_ptr) p->offset, size);\n \t  free (buf);\n \t  if (! ok)\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n   else\n@@ -3949,7 +3948,7 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n   amt = obj_reloc_entry_size (flaginfo->output_bfd);\n   if (bfd_seek (flaginfo->output_bfd, *reloff_ptr, SEEK_SET) != 0\n       || bfd_bwrite (rel_ptr, amt, flaginfo->output_bfd) != amt)\n-    return FALSE;\n+    return false;\n \n   *reloff_ptr += obj_reloc_entry_size (flaginfo->output_bfd);\n \n@@ -3960,7 +3959,7 @@ aout_link_reloc_link_order (struct aout_final_link_info *flaginfo,\n \t\t  || (*reloff_ptr\n \t\t      <= obj_datasec (flaginfo->output_bfd)->rel_filepos)));\n \n-  return TRUE;\n+  return true;\n }\n \n /* Get the section corresponding to a reloc index.  */\n@@ -3982,20 +3981,19 @@ aout_reloc_index_to_section (bfd *abfd, int indx)\n \n /* Relocate an a.out section using standard a.out relocs.  */\n \n-static bfd_boolean\n+static bool\n aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \t\t\t     bfd *input_bfd,\n \t\t\t     asection *input_section,\n \t\t\t     struct reloc_std_external *relocs,\n \t\t\t     bfd_size_type rel_size,\n \t\t\t     bfd_byte *contents)\n {\n-  bfd_boolean (*check_dynamic_reloc)\n+  bool (*check_dynamic_reloc)\n     (struct bfd_link_info *, bfd *, asection *,\n-\t     struct aout_link_hash_entry *, void *, bfd_byte *, bfd_boolean *,\n-\t     bfd_vma *);\n+     struct aout_link_hash_entry *, void *, bfd_byte *, bool *, bfd_vma *);\n   bfd *output_bfd;\n-  bfd_boolean relocatable;\n+  bool relocatable;\n   struct external_nlist *syms;\n   char *strings;\n   struct aout_link_hash_entry **sym_hashes;\n@@ -4087,7 +4085,7 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \t  _bfd_error_handler (_(\"%pB: unsupported relocation type\"),\n \t\t\t      input_bfd);\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (relocatable)\n@@ -4147,10 +4145,10 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \t\t\t  if (h->indx < 0)\n \t\t\t    {\n \t\t\t      h->indx = -2;\n-\t\t\t      h->written = FALSE;\n+\t\t\t      h->written = false;\n \t\t\t      if (!aout_link_write_other_symbol (&h->root.root,\n \t\t\t\t\t\t\t\t flaginfo))\n-\t\t\t\treturn FALSE;\n+\t\t\t\treturn false;\n \t\t\t    }\n \t\t\t  r_index = h->indx;\n \t\t\t}\n@@ -4222,11 +4220,11 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \t}\n       else\n \t{\n-\t  bfd_boolean hundef;\n+\t  bool hundef;\n \n \t  /* We are generating an executable, and must do a full\n \t     relocation.  */\n-\t  hundef = FALSE;\n+\t  hundef = false;\n \n \t  if (r_extern)\n \t    {\n@@ -4245,7 +4243,7 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \t\trelocation = 0;\n \t      else\n \t\t{\n-\t\t  hundef = TRUE;\n+\t\t  hundef = true;\n \t\t  relocation = 0;\n \t\t}\n \t    }\n@@ -4263,12 +4261,12 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \n \t  if (check_dynamic_reloc != NULL)\n \t    {\n-\t      bfd_boolean skip;\n+\t      bool skip;\n \n \t      if (! ((*check_dynamic_reloc)\n \t\t     (flaginfo->info, input_bfd, input_section, h,\n \t\t      (void *) rel, contents, &skip, &relocation)))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      if (skip)\n \t\tcontinue;\n \t    }\n@@ -4285,7 +4283,7 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \t      else\n \t\tname = strings + GET_WORD (input_bfd, syms[r_index].e_strx);\n \t      (*flaginfo->info->callbacks->undefined_symbol)\n-\t\t(flaginfo->info, name, input_bfd, input_section, r_addr, TRUE);\n+\t\t(flaginfo->info, name, input_bfd, input_section, r_addr, true);\n \t    }\n \n \t  r = MY_final_link_relocate (howto,\n@@ -4326,25 +4324,24 @@ aout_link_input_section_std (struct aout_final_link_info *flaginfo,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Relocate an a.out section using extended a.out relocs.  */\n \n-static bfd_boolean\n+static bool\n aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \t\t\t     bfd *input_bfd,\n \t\t\t     asection *input_section,\n \t\t\t     struct reloc_ext_external *relocs,\n \t\t\t     bfd_size_type rel_size,\n \t\t\t     bfd_byte *contents)\n {\n-  bfd_boolean (*check_dynamic_reloc)\n+  bool (*check_dynamic_reloc)\n     (struct bfd_link_info *, bfd *, asection *,\n-\t     struct aout_link_hash_entry *, void *, bfd_byte *, bfd_boolean *,\n-\t     bfd_vma *);\n+     struct aout_link_hash_entry *, void *, bfd_byte *, bool *, bfd_vma *);\n   bfd *output_bfd;\n-  bfd_boolean relocatable;\n+  bool relocatable;\n   struct external_nlist *syms;\n   char *strings;\n   struct aout_link_hash_entry **sym_hashes;\n@@ -4408,7 +4405,7 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \t  _bfd_error_handler (_(\"%pB: unsupported relocation type %#x\"),\n \t\t\t      input_bfd, r_type);\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (relocatable)\n@@ -4484,10 +4481,10 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \t\t\t  if (h->indx < 0)\n \t\t\t    {\n \t\t\t      h->indx = -2;\n-\t\t\t      h->written = FALSE;\n+\t\t\t      h->written = false;\n \t\t\t      if (!aout_link_write_other_symbol (&h->root.root,\n \t\t\t\t\t\t\t\t flaginfo))\n-\t\t\t\treturn FALSE;\n+\t\t\t\treturn false;\n \t\t\t    }\n \t\t\t  r_index = h->indx;\n \t\t\t}\n@@ -4564,12 +4561,12 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \t}\n       else\n \t{\n-\t  bfd_boolean hundef;\n+\t  bool hundef;\n \t  bfd_reloc_status_type r;\n \n \t  /* We are generating an executable, and must do a full\n \t     relocation.  */\n-\t  hundef = FALSE;\n+\t  hundef = false;\n \n \t  if (r_extern)\n \t    {\n@@ -4588,7 +4585,7 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \t\trelocation = 0;\n \t      else\n \t\t{\n-\t\t  hundef = TRUE;\n+\t\t  hundef = true;\n \t\t  relocation = 0;\n \t\t}\n \t    }\n@@ -4661,12 +4658,12 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \n \t  if (check_dynamic_reloc != NULL)\n \t    {\n-\t      bfd_boolean skip;\n+\t      bool skip;\n \n \t      if (! ((*check_dynamic_reloc)\n \t\t     (flaginfo->info, input_bfd, input_section, h,\n \t\t      (void *) rel, contents, &skip, &relocation)))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      if (skip)\n \t\tcontinue;\n \t    }\n@@ -4687,7 +4684,7 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \t      else\n \t\tname = strings + GET_WORD (input_bfd, syms[r_index].e_strx);\n \t      (*flaginfo->info->callbacks->undefined_symbol)\n-\t\t(flaginfo->info, name, input_bfd, input_section, r_addr, TRUE);\n+\t\t(flaginfo->info, name, input_bfd, input_section, r_addr, true);\n \t    }\n \n \t  if (r_type != (unsigned int) RELOC_SPARC_REV32)\n@@ -4742,12 +4739,12 @@ aout_link_input_section_ext (struct aout_final_link_info *flaginfo,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Link an a.out section into the output file.  */\n \n-static bfd_boolean\n+static bool\n aout_link_input_section (struct aout_final_link_info *flaginfo,\n \t\t\t bfd *input_bfd,\n \t\t\t asection *input_section,\n@@ -4762,7 +4759,7 @@ aout_link_input_section (struct aout_final_link_info *flaginfo,\n   if (! bfd_get_section_contents (input_bfd, input_section,\n \t\t\t\t  (void *) flaginfo->contents,\n \t\t\t\t  (file_ptr) 0, input_size))\n-    return FALSE;\n+    return false;\n \n   /* Read in the relocs if we haven't already done it.  */\n   if (aout_section_data (input_section) != NULL\n@@ -4775,7 +4772,7 @@ aout_link_input_section (struct aout_final_link_info *flaginfo,\n \t{\n \t  if (bfd_seek (input_bfd, input_section->rel_filepos, SEEK_SET) != 0\n \t      || bfd_bread (relocs, rel_size, input_bfd) != rel_size)\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n@@ -4785,14 +4782,14 @@ aout_link_input_section (struct aout_final_link_info *flaginfo,\n       if (! aout_link_input_section_std (flaginfo, input_bfd, input_section,\n \t\t\t\t\t (struct reloc_std_external *) relocs,\n \t\t\t\t\t rel_size, flaginfo->contents))\n-\treturn FALSE;\n+\treturn false;\n     }\n   else\n     {\n       if (! aout_link_input_section_ext (flaginfo, input_bfd, input_section,\n \t\t\t\t\t (struct reloc_ext_external *) relocs,\n \t\t\t\t\t rel_size, flaginfo->contents))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Write out the section contents.  */\n@@ -4801,16 +4798,16 @@ aout_link_input_section (struct aout_final_link_info *flaginfo,\n \t\t\t\t  (void *) flaginfo->contents,\n \t\t\t\t  (file_ptr) input_section->output_offset,\n \t\t\t\t  input_size))\n-    return FALSE;\n+    return false;\n \n   /* If we are producing relocatable output, the relocs were\n      modified, and we now write them out.  */\n   if (bfd_link_relocatable (flaginfo->info) && rel_size > 0)\n     {\n       if (bfd_seek (flaginfo->output_bfd, *reloff_ptr, SEEK_SET) != 0)\n-\treturn FALSE;\n+\treturn false;\n       if (bfd_bwrite (relocs, rel_size, flaginfo->output_bfd) != rel_size)\n-\treturn FALSE;\n+\treturn false;\n       *reloff_ptr += rel_size;\n \n       /* Assert that the relocs have not run into the symbols, and\n@@ -4822,13 +4819,13 @@ aout_link_input_section (struct aout_final_link_info *flaginfo,\n \t\t\t  <= obj_datasec (flaginfo->output_bfd)->rel_filepos)));\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Adjust and write out the symbols for an a.out file.  Set the new\n    symbol indices into a symbol_map.  */\n \n-static bfd_boolean\n+static bool\n aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n {\n   bfd *output_bfd;\n@@ -4842,8 +4839,8 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n   struct external_nlist *sym_end;\n   struct aout_link_hash_entry **sym_hash;\n   int *symbol_map;\n-  bfd_boolean pass;\n-  bfd_boolean skip_next;\n+  bool pass;\n+  bool skip_next;\n \n   output_bfd = flaginfo->output_bfd;\n   sym_count = obj_aout_external_sym_count (input_bfd);\n@@ -4858,16 +4855,16 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n       && (strip != strip_some\n \t  || bfd_hash_lookup (flaginfo->info->keep_hash,\n \t\t\t      bfd_get_filename (input_bfd),\n-\t\t\t      FALSE, FALSE) != NULL)\n+\t\t\t      false, false) != NULL)\n       && discard != discard_all)\n     {\n       H_PUT_8 (output_bfd, N_TEXT, outsym->e_type);\n       H_PUT_8 (output_bfd, 0, outsym->e_other);\n       H_PUT_16 (output_bfd, 0, outsym->e_desc);\n       strtab_index = add_to_stringtab (output_bfd, flaginfo->strtab,\n-\t\t\t\t       bfd_get_filename (input_bfd), FALSE);\n+\t\t\t\t       bfd_get_filename (input_bfd), false);\n       if (strtab_index == (bfd_size_type) -1)\n-\treturn FALSE;\n+\treturn false;\n       PUT_WORD (output_bfd, strtab_index, outsym->e_strx);\n       PUT_WORD (output_bfd,\n \t\t(bfd_section_vma (obj_textsec (input_bfd)->output_section)\n@@ -4877,8 +4874,8 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n       ++outsym;\n     }\n \n-  pass = FALSE;\n-  skip_next = FALSE;\n+  pass = false;\n+  skip_next = false;\n   sym = obj_aout_external_syms (input_bfd);\n   sym_end = sym + sym_count;\n   sym_hash = obj_aout_sym_hashes (input_bfd);\n@@ -4889,10 +4886,10 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n       const char *name;\n       int type;\n       struct aout_link_hash_entry *h;\n-      bfd_boolean skip;\n+      bool skip;\n       asection *symsec;\n       bfd_vma val = 0;\n-      bfd_boolean copy;\n+      bool copy;\n \n       /* We set *symbol_map to 0 above for all symbols.  If it has\n \t already been set to -1 for this symbol, it means that we are\n@@ -4916,14 +4913,14 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t  /* Pass this symbol through.  It is the target of an\n \t     indirect or warning symbol.  */\n \t  val = GET_WORD (input_bfd, sym->e_value);\n-\t  pass = FALSE;\n+\t  pass = false;\n \t}\n       else if (skip_next)\n \t{\n \t  /* Skip this symbol, which is the target of an indirect\n \t     symbol that we have changed to no longer be an indirect\n \t     symbol.  */\n-\t  skip_next = FALSE;\n+\t  skip_next = false;\n \t  continue;\n \t}\n       else\n@@ -4965,34 +4962,34 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t    {\n \t      if ((type & N_TYPE) == N_INDR\n \t\t  || type == N_WARNING)\n-\t\tskip_next = TRUE;\n+\t\tskip_next = true;\n \t      *symbol_map = h->indx;\n \t      continue;\n \t    }\n \n \t  /* See if we are stripping this symbol.  */\n-\t  skip = FALSE;\n+\t  skip = false;\n \t  switch (strip)\n \t    {\n \t    case strip_none:\n \t      break;\n \t    case strip_debugger:\n \t      if ((type & N_STAB) != 0)\n-\t\tskip = TRUE;\n+\t\tskip = true;\n \t      break;\n \t    case strip_some:\n-\t      if (bfd_hash_lookup (flaginfo->info->keep_hash, name, FALSE, FALSE)\n+\t      if (bfd_hash_lookup (flaginfo->info->keep_hash, name, false, false)\n \t\t  == NULL)\n-\t\tskip = TRUE;\n+\t\tskip = true;\n \t      break;\n \t    case strip_all:\n-\t      skip = TRUE;\n+\t      skip = true;\n \t      break;\n \t    }\n \t  if (skip)\n \t    {\n \t      if (h != NULL)\n-\t\th->written = TRUE;\n+\t\th->written = true;\n \t      continue;\n \t    }\n \n@@ -5021,7 +5018,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\t the indirect symbol was defined, we output it with\n \t\t the correct definition so the debugger will\n \t\t understand it.  */\n-\t      pass = TRUE;\n+\t      pass = true;\n \t      val = GET_WORD (input_bfd, sym->e_value);\n \t      symsec = NULL;\n \t    }\n@@ -5037,7 +5034,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\t a case we do not want to output the next symbol,\n \t\t which is the target of the indirection.  */\n \t      if ((type & N_TYPE) == N_INDR)\n-\t\tskip_next = TRUE;\n+\t\tskip_next = true;\n \n \t      symsec = NULL;\n \n@@ -5129,7 +5126,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t     it is a local symbol see if we should discard it.  */\n \t  if (h != NULL)\n \t    {\n-\t      h->written = TRUE;\n+\t      h->written = true;\n \t      h->indx = obj_aout_external_sym_count (output_bfd);\n \t    }\n \t  else if ((type & N_TYPE) != N_SETT\n@@ -5145,15 +5142,15 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\tcase discard_l:\n \t\t  if ((type & N_STAB) == 0\n \t\t      && bfd_is_local_label_name (input_bfd, name))\n-\t\t    skip = TRUE;\n+\t\t    skip = true;\n \t\t  break;\n \t\tcase discard_all:\n-\t\t  skip = TRUE;\n+\t\t  skip = true;\n \t\t  break;\n \t\t}\n \t      if (skip)\n \t\t{\n-\t\t  pass = FALSE;\n+\t\t  pass = false;\n \t\t  continue;\n \t\t}\n \t    }\n@@ -5211,9 +5208,9 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\t symbol.  */\n \t      copy = !flaginfo->info->keep_memory;\n \t      incl_entry = aout_link_includes_lookup (&flaginfo->includes,\n-\t\t\t\t\t\t      name, TRUE, copy);\n+\t\t\t\t\t\t      name, true, copy);\n \t      if (incl_entry == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      for (t = incl_entry->totals; t != NULL; t = t->next)\n \t\tif (t->total == val)\n \t\t  break;\n@@ -5225,7 +5222,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\t      bfd_hash_allocate (&flaginfo->includes.root,\n \t\t\t\t\t sizeof *t);\n \t\t  if (t == NULL)\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t  t->total = val;\n \t\t  t->next = incl_entry->totals;\n \t\t  incl_entry->totals = t;\n@@ -5270,7 +5267,7 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n       H_PUT_8 (output_bfd, type, outsym->e_type);\n       H_PUT_8 (output_bfd, H_GET_8 (input_bfd, sym->e_other), outsym->e_other);\n       H_PUT_16 (output_bfd, H_GET_16 (input_bfd, sym->e_desc), outsym->e_desc);\n-      copy = FALSE;\n+      copy = false;\n       if (! flaginfo->info->keep_memory)\n \t{\n \t  /* name points into a string table which we are going to\n@@ -5279,12 +5276,12 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t  if (h != NULL)\n \t    name = h->root.root.string;\n \t  else\n-\t    copy = TRUE;\n+\t    copy = true;\n \t}\n       strtab_index = add_to_stringtab (output_bfd, flaginfo->strtab,\n \t\t\t\t       name, copy);\n       if (strtab_index == (bfd_size_type) -1)\n-\treturn FALSE;\n+\treturn false;\n       PUT_WORD (output_bfd, strtab_index, outsym->e_strx);\n       PUT_WORD (output_bfd, val, outsym->e_value);\n       *symbol_map = obj_aout_external_sym_count (output_bfd);\n@@ -5298,21 +5295,21 @@ aout_link_write_symbols (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n       bfd_size_type outsym_size;\n \n       if (bfd_seek (output_bfd, flaginfo->symoff, SEEK_SET) != 0)\n-\treturn FALSE;\n+\treturn false;\n       outsym_size = outsym - flaginfo->output_syms;\n       outsym_size *= EXTERNAL_NLIST_SIZE;\n       if (bfd_bwrite ((void *) flaginfo->output_syms, outsym_size, output_bfd)\n \t  != outsym_size)\n-\treturn FALSE;\n+\treturn false;\n       flaginfo->symoff += outsym_size;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Link an a.out input BFD into the output file.  */\n \n-static bfd_boolean\n+static bool\n aout_link_input_bfd (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n {\n   BFD_ASSERT (bfd_get_format (input_bfd) == bfd_object);\n@@ -5326,12 +5323,12 @@ aout_link_input_bfd (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n   /* Get the symbols.  We probably have them already, unless\n      flaginfo->info->keep_memory is FALSE.  */\n   if (! aout_get_external_symbols (input_bfd))\n-    return FALSE;\n+    return false;\n \n   /* Write out the symbols and get a map of the new indices.  The map\n      is placed into flaginfo->symbol_map.  */\n   if (! aout_link_write_symbols (flaginfo, input_bfd))\n-    return FALSE;\n+    return false;\n \n   /* Relocate and write out the sections.  These functions use the\n      symbol map created by aout_link_write_symbols.  The linker_mark\n@@ -5343,15 +5340,15 @@ aout_link_input_bfd (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n \t\t\t\t     obj_textsec (input_bfd),\n \t\t\t\t     &flaginfo->treloff,\n \t\t\t\t     exec_hdr (input_bfd)->a_trsize))\n-\treturn FALSE;\n+\treturn false;\n     }\n   if (obj_datasec (input_bfd)->linker_mark)\n     {\n       if (! aout_link_input_section (flaginfo, input_bfd,\n \t\t\t\t     obj_datasec (input_bfd),\n \t\t\t\t     &flaginfo->dreloff,\n \t\t\t\t     exec_hdr (input_bfd)->a_drsize))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* If we are not keeping memory, we don't need the symbols any\n@@ -5360,10 +5357,10 @@ aout_link_input_bfd (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n   if (! flaginfo->info->keep_memory)\n     {\n       if (! aout_link_free_symbols (input_bfd))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Do the final link step.  This is called on the output BFD.  The\n@@ -5373,21 +5370,21 @@ aout_link_input_bfd (struct aout_final_link_info *flaginfo, bfd *input_bfd)\n    of bfd_link_order structures which list all the input sections for\n    the output section.  */\n \n-bfd_boolean\n+bool\n NAME (aout, final_link) (bfd *abfd,\n \t\t\t struct bfd_link_info *info,\n \t\t\t void (*callback) (bfd *, file_ptr *, file_ptr *, file_ptr *))\n {\n   struct aout_final_link_info aout_info;\n-  bfd_boolean includes_hash_initialized = FALSE;\n+  bool includes_hash_initialized = false;\n   bfd *sub;\n   bfd_size_type trsize, drsize;\n   bfd_size_type max_contents_size;\n   bfd_size_type max_relocs_size;\n   bfd_size_type max_sym_count;\n   struct bfd_link_order *p;\n   asection *o;\n-  bfd_boolean have_link_order_relocs;\n+  bool have_link_order_relocs;\n \n   if (bfd_link_pic (info))\n     abfd->flags |= DYNAMIC;\n@@ -5404,7 +5401,7 @@ NAME (aout, final_link) (bfd *abfd,\n \t\t\t      sizeof (struct aout_link_includes_entry),\n \t\t\t      251))\n     goto error_return;\n-  includes_hash_initialized = TRUE;\n+  includes_hash_initialized = true;\n \n   /* Figure out the largest section size.  Also, if generating\n      relocatable output, count the relocs.  */\n@@ -5525,7 +5522,7 @@ NAME (aout, final_link) (bfd *abfd,\n     struct aout_link_hash_entry *h;\n \n     h = aout_link_hash_lookup (aout_hash_table (info), \"__DYNAMIC\",\n-\t\t\t       FALSE, FALSE, FALSE);\n+\t\t\t       false, false, false);\n     if (h != NULL)\n       aout_link_write_other_symbol (&h->root.root, &aout_info);\n   }\n@@ -5552,7 +5549,7 @@ NAME (aout, final_link) (bfd *abfd,\n      We use the output_has_begun field of the input BFDs to see\n      whether we have already handled it.  */\n   for (sub = info->input_bfds; sub != NULL; sub = sub->link.next)\n-    sub->output_has_begun = FALSE;\n+    sub->output_has_begun = false;\n \n   /* Mark all sections which are to be included in the link.  This\n      will normally be every section.  We need to do this so that we\n@@ -5562,10 +5559,10 @@ NAME (aout, final_link) (bfd *abfd,\n     {\n       for (p = o->map_head.link_order; p != NULL; p = p->next)\n \tif (p->type == bfd_indirect_link_order)\n-\t  p->u.indirect.section->linker_mark = TRUE;\n+\t  p->u.indirect.section->linker_mark = true;\n     }\n \n-  have_link_order_relocs = FALSE;\n+  have_link_order_relocs = false;\n   for (o = abfd->sections; o != NULL; o = o->next)\n     {\n       for (p = o->map_head.link_order;\n@@ -5583,14 +5580,14 @@ NAME (aout, final_link) (bfd *abfd,\n \t\t{\n \t\t  if (! aout_link_input_bfd (&aout_info, input_bfd))\n \t\t    goto error_return;\n-\t\t  input_bfd->output_has_begun = TRUE;\n+\t\t  input_bfd->output_has_begun = true;\n \t\t}\n \t    }\n \t  else if (p->type == bfd_section_reloc_link_order\n \t\t   || p->type == bfd_symbol_reloc_link_order)\n \t    {\n \t      /* These are handled below.  */\n-\t      have_link_order_relocs = TRUE;\n+\t      have_link_order_relocs = true;\n \t    }\n \t  else\n \t    {\n@@ -5639,7 +5636,7 @@ NAME (aout, final_link) (bfd *abfd,\n   if (includes_hash_initialized)\n     {\n       bfd_hash_table_free (&aout_info.includes.root);\n-      includes_hash_initialized = FALSE;\n+      includes_hash_initialized = false;\n     }\n \n   /* Finish up any dynamic linking we may be doing.  */\n@@ -5675,7 +5672,7 @@ NAME (aout, final_link) (bfd *abfd,\n \tgoto error_return;\n     }\n \n-  return TRUE;\n+  return true;\n \n  error_return:\n   free (aout_info.contents);\n@@ -5684,5 +5681,5 @@ NAME (aout, final_link) (bfd *abfd,\n   free (aout_info.output_syms);\n   if (includes_hash_initialized)\n     bfd_hash_table_free (&aout_info.includes.root);\n-  return FALSE;\n+  return false;\n }"
    },
    {
      "sha": "76fc761a8cf20c56226ff554a03860793575d616",
      "filename": "bfd/arc-got.h",
      "status": "modified",
      "additions": 16,
      "deletions": 16,
      "changes": 32,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/arc-got.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/arc-got.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/arc-got.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -49,8 +49,8 @@ struct got_entry\n   struct got_entry *next;\n   enum tls_type_e type;\n   bfd_vma offset;\n-  bfd_boolean processed;\n-  bfd_boolean created_dyn_relocation;\n+  bool processed;\n+  bool created_dyn_relocation;\n   enum tls_got_entries existing_entries;\n };\n \n@@ -114,8 +114,8 @@ new_got_entry_to_list (struct got_entry **list,\n   entry->type = type;\n   entry->offset = offset;\n   entry->next = NULL;\n-  entry->processed = FALSE;\n-  entry->created_dyn_relocation = FALSE;\n+  entry->processed = false;\n+  entry->created_dyn_relocation = false;\n   entry->existing_entries = existing_entries;\n \n   ARC_DEBUG (\"New GOT got entry added to list: \"\n@@ -210,11 +210,11 @@ arc_got_entry_type_for_reloc (reloc_howto_type *howto)\n     if (H)\t\t\t\t\t\t\t\t\\\n       if (H->dynindx == -1 && !H->forced_local)\t\t\t\t\\\n \tif (! bfd_elf_link_record_dynamic_symbol (info, H))\t\t\\\n-\t  return FALSE;\t\t\t\t\t\t\t\\\n+\t  return false;\t\t\t\t\t\t\t\\\n      htab->s##SECNAME->size += 4;\t\t\t\t\t\\\n    }\t\t\t\t\t\t\t\t\t\\\n \n-static bfd_boolean\n+static bool\n arc_fill_got_info_for_reloc (enum tls_type_e type,\n \t\t\t     struct got_entry **list,\n \t\t\t     struct bfd_link_info *  info,\n@@ -223,7 +223,7 @@ arc_fill_got_info_for_reloc (enum tls_type_e type,\n   struct elf_link_hash_table *htab = elf_hash_table (info);\n \n   if (got_entry_for_type (list, type) != NULL)\n-    return TRUE;\n+    return true;\n \n   switch (type)\n     {\n@@ -240,26 +240,26 @@ arc_fill_got_info_for_reloc (enum tls_type_e type,\n       case GOT_TLS_GD:\n \t{\n \t  bfd_vma offset\n-\t    = ADD_SYMBOL_REF_SEC_AND_RELOC (got, TRUE, h);\n+\t    = ADD_SYMBOL_REF_SEC_AND_RELOC (got, true, h);\n \t  bfd_vma ATTRIBUTE_UNUSED notneeded\n-\t    = ADD_SYMBOL_REF_SEC_AND_RELOC (got, TRUE, h);\n+\t    = ADD_SYMBOL_REF_SEC_AND_RELOC (got, true, h);\n \t  new_got_entry_to_list (list, type, offset, TLS_GOT_MOD_AND_OFF);\n \t}\n \tbreak;\n       case GOT_TLS_IE:\n       case GOT_TLS_LE:\n \t{\n \t  bfd_vma offset\n-\t    = ADD_SYMBOL_REF_SEC_AND_RELOC (got, TRUE, h);\n+\t    = ADD_SYMBOL_REF_SEC_AND_RELOC (got, true, h);\n \t  new_got_entry_to_list (list, type, offset, TLS_GOT_OFF);\n \t}\n \tbreak;\n \n       default:\n-\treturn FALSE;\n+\treturn false;\n \tbreak;\n     }\n-  return TRUE;\n+  return true;\n }\n \n \n@@ -284,7 +284,7 @@ relocate_fix_got_relocs_for_got_info (struct got_entry **\t   list_p,\n   BFD_ASSERT (entry);\n \n   if (h == NULL\n-      || h->forced_local == TRUE\n+      || h->forced_local == true\n       || (! elf_hash_table (info)->dynamic_sections_created\n \t  || (bfd_link_pic (info)\n \t      && SYMBOL_REFERENCES_LOCAL (info, h))))\n@@ -425,7 +425,7 @@ relocate_fix_got_relocs_for_got_info (struct got_entry **\t   list_p,\n \t      BFD_ASSERT (0);\n \t      break;\n \t    }\n-\t  entry->processed = TRUE;\n+\t  entry->processed = true;\n \t}\n     }\n \n@@ -460,7 +460,7 @@ create_got_dynrelocs_for_single_entry (struct got_entry *list,\n \t{\n \t  ADD_RELA (output_bfd, got, got_offset, h->dynindx, R_ARC_GLOB_DAT, 0);\n \t}\n-      list->created_dyn_relocation = TRUE;\n+      list->created_dyn_relocation = true;\n     }\n   else if (list->existing_entries != TLS_GOT_NONE\n \t   && !list->created_dyn_relocation)\n@@ -515,7 +515,7 @@ GOT_OFFSET = %#lx, GOT_VMA = %#lx, INDEX = %ld, ADDEND = %#lx\\n\",\n \t\t\t     + htab->sgot->output_offset + got_offset),\n \t\t     (long) dynindx, (long) addend);\n \t}\n-      list->created_dyn_relocation = TRUE;\n+      list->created_dyn_relocation = true;\n     }\n }\n "
    },
    {
      "sha": "2f3a1d4194c21fc0b0b6a8813bc00e145b3e6bcf",
      "filename": "bfd/archive.c",
      "status": "modified",
      "additions": 125,
      "deletions": 125,
      "changes": 250,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/archive.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -186,7 +186,7 @@ _bfd_ar_spacepad (char *p, size_t n, const char *fmt, long val)\n     memcpy (p, buf, n);\n }\n \n-bfd_boolean\n+bool\n _bfd_ar_sizepad (char *p, size_t n, bfd_size_type size)\n {\n   char buf[21];\n@@ -197,7 +197,7 @@ _bfd_ar_sizepad (char *p, size_t n, bfd_size_type size)\n   if (len > n)\n     {\n       bfd_set_error (bfd_error_file_too_big);\n-      return FALSE;\n+      return false;\n     }\n   if (len < n)\n     {\n@@ -206,17 +206,17 @@ _bfd_ar_sizepad (char *p, size_t n, bfd_size_type size)\n     }\n   else\n     memcpy (p, buf, n);\n-  return TRUE;\n+  return true;\n }\n \f\n-bfd_boolean\n+bool\n _bfd_generic_mkarchive (bfd *abfd)\n {\n   size_t amt = sizeof (struct artdata);\n \n   abfd->tdata.aout_ar_data = (struct artdata *) bfd_zalloc (abfd, amt);\n   if (bfd_ardata (abfd) == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Already cleared by bfd_zalloc above.\n      bfd_ardata (abfd)->cache = NULL;\n@@ -226,7 +226,7 @@ _bfd_generic_mkarchive (bfd *abfd)\n      bfd_ardata (abfd)->extended_names_size = 0;\n      bfd_ardata (abfd)->tdata = NULL;  */\n \n-  return TRUE;\n+  return true;\n }\n \n /*\n@@ -284,18 +284,18 @@ FUNCTION\n \tbfd_set_archive_head\n \n SYNOPSIS\n-\tbfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);\n+\tbool bfd_set_archive_head (bfd *output, bfd *new_head);\n \n DESCRIPTION\n \tSet the head of the chain of\n \tBFDs contained in the archive @var{output} to @var{new_head}.\n */\n \n-bfd_boolean\n+bool\n bfd_set_archive_head (bfd *output_archive, bfd *new_head)\n {\n   output_archive->archive_head = new_head;\n-  return TRUE;\n+  return true;\n }\n \n bfd *\n@@ -349,7 +349,7 @@ _bfd_calloc_wrapper (size_t a, size_t b)\n \n /* Kind of stupid to call cons for each one, but we don't do too many.  */\n \n-bfd_boolean\n+bool\n _bfd_add_bfd_to_archive_cache (bfd *arch_bfd, file_ptr filepos, bfd *new_elt)\n {\n   struct ar_cache *cache;\n@@ -361,7 +361,7 @@ _bfd_add_bfd_to_archive_cache (bfd *arch_bfd, file_ptr filepos, bfd *new_elt)\n       hash_table = htab_create_alloc (16, hash_file_ptr, eq_file_ptr,\n \t\t\t\t      NULL, _bfd_calloc_wrapper, free);\n       if (hash_table == NULL)\n-\treturn FALSE;\n+\treturn false;\n       bfd_ardata (arch_bfd)->cache = hash_table;\n     }\n \n@@ -375,7 +375,7 @@ _bfd_add_bfd_to_archive_cache (bfd *arch_bfd, file_ptr filepos, bfd *new_elt)\n   arch_eltdata (new_elt)->parent_cache = hash_table;\n   arch_eltdata (new_elt)->key = filepos;\n \n-  return TRUE;\n+  return true;\n }\n \f\n static bfd *\n@@ -924,7 +924,7 @@ bfd_generic_archive_p (bfd *abfd)\n       abfd->no_element_cache = save;\n       if (first != NULL)\n \t{\n-\t  first->target_defaulted = FALSE;\n+\t  first->target_defaulted = false;\n \t  if (bfd_check_format (first, bfd_object)\n \t      && first->xvec != abfd->xvec)\n \t    bfd_set_error (bfd_error_wrong_object_format);\n@@ -955,7 +955,7 @@ bfd_generic_archive_p (bfd *abfd)\n /* Read a BSD-style archive symbol table.  Returns FALSE on error,\n    TRUE otherwise.  */\n \n-static bfd_boolean\n+static bool\n do_slurp_bsd_armap (bfd *abfd)\n {\n   struct areltdata *mapdata;\n@@ -969,20 +969,20 @@ do_slurp_bsd_armap (bfd *abfd)\n \n   mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);\n   if (mapdata == NULL)\n-    return FALSE;\n+    return false;\n   parsed_size = mapdata->parsed_size;\n   free (mapdata);\n   /* PR 17512: file: 883ff754.  */\n   /* PR 17512: file: 0458885f.  */\n   if (parsed_size < BSD_SYMDEF_COUNT_SIZE + BSD_STRING_COUNT_SIZE)\n     {\n       bfd_set_error (bfd_error_malformed_archive);\n-      return FALSE;\n+      return false;\n     }\n \n   raw_armap = (bfd_byte *) _bfd_alloc_and_read (abfd, parsed_size, parsed_size);\n   if (raw_armap == NULL)\n-    return FALSE;\n+    return false;\n \n   parsed_size -= BSD_SYMDEF_COUNT_SIZE + BSD_STRING_COUNT_SIZE;\n   amt = H_GET_32 (abfd, raw_armap);\n@@ -1028,20 +1028,20 @@ do_slurp_bsd_armap (bfd *abfd)\n   /* FIXME, we should provide some way to free raw_ardata when\n      we are done using the strings from it.  For now, it seems\n      to be allocated on an objalloc anyway...  */\n-  abfd->has_armap = TRUE;\n-  return TRUE;\n+  abfd->has_armap = true;\n+  return true;\n \n  release_armap:\n   ardata->symdef_count = 0;\n   ardata->symdefs = NULL;\n   bfd_release (abfd, raw_armap);\n-  return FALSE;\n+  return false;\n }\n \n /* Read a COFF archive symbol table.  Returns FALSE on error, TRUE\n    otherwise.  */\n \n-static bfd_boolean\n+static bool\n do_slurp_coff_armap (bfd *abfd)\n {\n   struct areltdata *mapdata;\n@@ -1060,12 +1060,12 @@ do_slurp_coff_armap (bfd *abfd)\n \n   mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);\n   if (mapdata == NULL)\n-    return FALSE;\n+    return false;\n   parsed_size = mapdata->parsed_size;\n   free (mapdata);\n \n   if (bfd_bread (int_buf, 4, abfd) != 4)\n-    return FALSE;\n+    return false;\n \n   /* It seems that all numeric information in a coff archive is always\n      in big endian format, no matter the host or target.  */\n@@ -1078,7 +1078,7 @@ do_slurp_coff_armap (bfd *abfd)\n   if (_bfd_mul_overflow (nsymz, sizeof (carsym), &carsym_size))\n     {\n       bfd_set_error (bfd_error_no_memory);\n-      return FALSE;\n+      return false;\n     }\n \n   filesize = bfd_get_file_size (abfd);\n@@ -1088,21 +1088,21 @@ do_slurp_coff_armap (bfd *abfd)\n       || parsed_size - 4 < ptrsize)\n     {\n       bfd_set_error (bfd_error_malformed_archive);\n-      return FALSE;\n+      return false;\n     }\n \n   stringsize = parsed_size - ptrsize - 4;\n \n   if (carsym_size + stringsize + 1 <= carsym_size)\n     {\n       bfd_set_error (bfd_error_no_memory);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Allocate and read in the raw offsets.  */\n   raw_armap = (int *) _bfd_malloc_and_read (abfd, ptrsize, ptrsize);\n   if (raw_armap == NULL)\n-    return FALSE;\n+    return false;\n \n   ardata->symdefs = (struct carsym *) bfd_alloc (abfd,\n \t\t\t\t\t\t carsym_size + stringsize + 1);\n@@ -1135,7 +1135,7 @@ do_slurp_coff_armap (bfd *abfd)\n   if (bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET) != 0)\n     goto release_symdefs;\n \n-  abfd->has_armap = TRUE;\n+  abfd->has_armap = true;\n   free (raw_armap);\n \n   /* Check for a second archive header (as used by PE).  */\n@@ -1149,31 +1149,31 @@ do_slurp_coff_armap (bfd *abfd)\n       free (tmp);\n     }\n \n-  return TRUE;\n+  return true;\n \n  release_symdefs:\n   bfd_release (abfd, (ardata)->symdefs);\n  free_armap:\n   free (raw_armap);\n-  return FALSE;\n+  return false;\n }\n \n /* This routine can handle either coff-style or bsd-style armaps\n    (archive symbol table).  Returns FALSE on error, TRUE otherwise */\n \n-bfd_boolean\n+bool\n bfd_slurp_armap (bfd *abfd)\n {\n   char nextname[17];\n   int i = bfd_bread (nextname, 16, abfd);\n \n   if (i == 0)\n-    return TRUE;\n+    return true;\n   if (i != 16)\n-    return FALSE;\n+    return false;\n \n   if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)\n-    return FALSE;\n+    return false;\n \n   if (startswith (nextname, \"__.SYMDEF       \")\n       || startswith (nextname, \"__.SYMDEF/      \")) /* Old Linux archives.  */\n@@ -1187,7 +1187,7 @@ bfd_slurp_armap (bfd *abfd)\n       return _bfd_archive_64_bit_slurp_armap (abfd);\n #else\n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n #endif\n     }\n   else if (startswith (nextname, \"#1/20           \"))\n@@ -1199,20 +1199,20 @@ bfd_slurp_armap (bfd *abfd)\n       char extname[21];\n \n       if (bfd_bread (&hdr, sizeof (hdr), abfd) != sizeof (hdr))\n-\treturn FALSE;\n+\treturn false;\n       /* Read the extended name.  We know its length.  */\n       if (bfd_bread (extname, 20, abfd) != 20)\n-\treturn FALSE;\n+\treturn false;\n       if (bfd_seek (abfd, -(file_ptr) (sizeof (hdr) + 20), SEEK_CUR) != 0)\n-\treturn FALSE;\n+\treturn false;\n       extname[20] = 0;\n       if (startswith (extname, \"__.SYMDEF SORTED\")\n \t  || startswith (extname, \"__.SYMDEF\"))\n \treturn do_slurp_bsd_armap (abfd);\n     }\n \n-  abfd->has_armap = FALSE;\n-  return TRUE;\n+  abfd->has_armap = false;\n+  return true;\n }\n \f\n /** Extended name table.\n@@ -1227,15 +1227,15 @@ bfd_slurp_armap (bfd *abfd)\n \n /* Returns FALSE on error, TRUE otherwise.  */\n \n-bfd_boolean\n+bool\n _bfd_slurp_extended_name_table (bfd *abfd)\n {\n   char nextname[17];\n \n   /* FIXME:  Formatting sucks here, and in case of failure of BFD_READ,\n      we probably don't want to return TRUE.  */\n   if (bfd_seek (abfd, bfd_ardata (abfd)->first_file_filepos, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   if (bfd_bread (nextname, 16, abfd) == 16)\n     {\n@@ -1244,19 +1244,19 @@ _bfd_slurp_extended_name_table (bfd *abfd)\n       ufile_ptr filesize;\n \n       if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n       if (! startswith (nextname, \"ARFILENAMES/    \")\n \t  && ! startswith (nextname, \"//              \"))\n \t{\n \t  bfd_ardata (abfd)->extended_names = NULL;\n \t  bfd_ardata (abfd)->extended_names_size = 0;\n-\t  return TRUE;\n+\t  return true;\n \t}\n \n       namedata = (struct areltdata *) _bfd_read_ar_hdr (abfd);\n       if (namedata == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       filesize = bfd_get_file_size (abfd);\n       amt = namedata->parsed_size;\n@@ -1274,7 +1274,7 @@ _bfd_slurp_extended_name_table (bfd *abfd)\n \t  free (namedata);\n \t  bfd_ardata (abfd)->extended_names = NULL;\n \t  bfd_ardata (abfd)->extended_names_size = 0;\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       if (bfd_bread (bfd_ardata (abfd)->extended_names, amt, abfd) != amt)\n@@ -1314,7 +1314,7 @@ _bfd_slurp_extended_name_table (bfd *abfd)\n \n       free (namedata);\n     }\n-  return TRUE;\n+  return true;\n }\n \n #ifdef VMS\n@@ -1497,35 +1497,35 @@ adjust_relative_path (const char * path, const char * ref_path)\n \n /* Build a BFD style extended name table.  */\n \n-bfd_boolean\n+bool\n _bfd_archive_bsd_construct_extended_name_table (bfd *abfd,\n \t\t\t\t\t\tchar **tabloc,\n \t\t\t\t\t\tbfd_size_type *tablen,\n \t\t\t\t\t\tconst char **name)\n {\n   *name = \"ARFILENAMES/\";\n-  return _bfd_construct_extended_name_table (abfd, FALSE, tabloc, tablen);\n+  return _bfd_construct_extended_name_table (abfd, false, tabloc, tablen);\n }\n \n /* Build an SVR4 style extended name table.  */\n \n-bfd_boolean\n+bool\n _bfd_archive_coff_construct_extended_name_table (bfd *abfd,\n \t\t\t\t\t\t char **tabloc,\n \t\t\t\t\t\t bfd_size_type *tablen,\n \t\t\t\t\t\t const char **name)\n {\n   *name = \"//\";\n-  return _bfd_construct_extended_name_table (abfd, TRUE, tabloc, tablen);\n+  return _bfd_construct_extended_name_table (abfd, true, tabloc, tablen);\n }\n \n-bfd_boolean\n+bool\n _bfd_noarchive_construct_extended_name_table (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t\t      char **tabloc ATTRIBUTE_UNUSED,\n \t\t\t\t\t      bfd_size_type *len ATTRIBUTE_UNUSED,\n \t\t\t\t\t      const char **name ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n /* Follows archive_head and produces an extended name table if\n@@ -1536,9 +1536,9 @@ _bfd_noarchive_construct_extended_name_table (bfd *abfd ATTRIBUTE_UNUSED,\n    something went wrong.  A successful return may still involve a\n    zero-length tablen!  */\n \n-bfd_boolean\n+bool\n _bfd_construct_extended_name_table (bfd *abfd,\n-\t\t\t\t    bfd_boolean trailing_slash,\n+\t\t\t\t    bool trailing_slash,\n \t\t\t\t    char **tabloc,\n \t\t\t\t    bfd_size_type *tablen)\n {\n@@ -1598,7 +1598,7 @@ _bfd_construct_extended_name_table (bfd *abfd,\n \n       normal = normalize (abfd, bfd_get_filename (current));\n       if (normal == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       thislen = strlen (normal);\n \n@@ -1634,11 +1634,11 @@ _bfd_construct_extended_name_table (bfd *abfd,\n     }\n \n   if (total_namelen == 0)\n-    return TRUE;\n+    return true;\n \n   *tabloc = (char *) bfd_alloc (abfd, total_namelen);\n   if (*tabloc == NULL)\n-    return FALSE;\n+    return false;\n \n   *tablen = total_namelen;\n   strptr = *tabloc;\n@@ -1679,7 +1679,7 @@ _bfd_construct_extended_name_table (bfd *abfd,\n \t{\n \t  normal = normalize (abfd, filename);\n \t  if (normal == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n       thislen = strlen (normal);\n@@ -1716,13 +1716,13 @@ _bfd_construct_extended_name_table (bfd *abfd,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Do not construct an extended name table but transforms name field into\n    its extended form.  */\n \n-bfd_boolean\n+bool\n _bfd_archive_bsd44_construct_extended_name_table (bfd *abfd,\n \t\t\t\t\t\t  char **tabloc,\n \t\t\t\t\t\t  bfd_size_type *tablen,\n@@ -1744,7 +1744,7 @@ _bfd_archive_bsd44_construct_extended_name_table (bfd *abfd,\n       unsigned int len;\n \n       if (normal == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       for (len = 0; normal[len]; len++)\n \tif (normal[len] == ' ')\n@@ -1760,24 +1760,24 @@ _bfd_archive_bsd44_construct_extended_name_table (bfd *abfd,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* Write an archive header.  */\n \n-bfd_boolean\n+bool\n _bfd_generic_write_ar_hdr (bfd *archive, bfd *abfd)\n {\n   struct ar_hdr *hdr = arch_hdr (abfd);\n \n   if (bfd_bwrite (hdr, sizeof (*hdr), archive) != sizeof (*hdr))\n-    return FALSE;\n-  return TRUE;\n+    return false;\n+  return true;\n }\n \n /* Write an archive header using BSD4.4 convention.  */\n \n-bfd_boolean\n+bool\n _bfd_bsd44_write_ar_hdr (bfd *archive, bfd *abfd)\n {\n   struct ar_hdr *hdr = arch_hdr (abfd);\n@@ -1793,32 +1793,32 @@ _bfd_bsd44_write_ar_hdr (bfd *archive, bfd *abfd)\n \n       if (!_bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size),\n \t\t\t    arch_eltdata (abfd)->parsed_size + padded_len))\n-\treturn FALSE;\n+\treturn false;\n \n       if (bfd_bwrite (hdr, sizeof (*hdr), archive) != sizeof (*hdr))\n-\treturn FALSE;\n+\treturn false;\n \n       if (bfd_bwrite (fullname, len, archive) != len)\n-\treturn FALSE;\n+\treturn false;\n \n       if (len & 3)\n \t{\n \t  static const char pad[3] = { 0, 0, 0 };\n \n \t  len = 4 - (len & 3);\n \t  if (bfd_bwrite (pad, len, archive) != len)\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n   else\n     {\n       if (bfd_bwrite (hdr, sizeof (*hdr), archive) != sizeof (*hdr))\n-\treturn FALSE;\n+\treturn false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n _bfd_noarchive_write_ar_hdr (bfd *archive, bfd *abfd ATTRIBUTE_UNUSED)\n {\n   return _bfd_bool_bfd_false_error (archive);\n@@ -2095,16 +2095,16 @@ _bfd_noarchive_truncate_arname (bfd *abfd ATTRIBUTE_UNUSED,\n \f\n /* The BFD is open for write and has its format set to bfd_archive.  */\n \n-bfd_boolean\n+bool\n _bfd_write_archive_contents (bfd *arch)\n {\n   bfd *current;\n   char *etable = NULL;\n   bfd_size_type elength = 0;\n   const char *ename = NULL;\n-  bfd_boolean makemap = bfd_has_map (arch);\n+  bool makemap = bfd_has_map (arch);\n   /* If no .o's, don't bother to make a map.  */\n-  bfd_boolean hasobjects = FALSE;\n+  bool hasobjects = false;\n   bfd_size_type wrote;\n   int tries;\n   char *armag;\n@@ -2143,27 +2143,27 @@ _bfd_write_archive_contents (bfd *arch)\n       if (makemap && ! hasobjects)\n \t{\t\t\t/* Don't bother if we won't make a map!  */\n \t  if ((bfd_check_format (current, bfd_object)))\n-\t    hasobjects = TRUE;\n+\t    hasobjects = true;\n \t}\n     }\n \n   if (!BFD_SEND (arch, _bfd_construct_extended_name_table,\n \t\t (arch, &etable, &elength, &ename)))\n-    return FALSE;\n+    return false;\n \n   if (bfd_seek (arch, (file_ptr) 0, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n   armag = ARMAG;\n   if (bfd_is_thin_archive (arch))\n     armag = ARMAGT;\n   wrote = bfd_bwrite (armag, SARMAG, arch);\n   if (wrote != SARMAG)\n-    return FALSE;\n+    return false;\n \n   if (makemap && hasobjects)\n     {\n       if (! _bfd_compute_and_write_armap (arch, (unsigned int) elength))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (elength != 0)\n@@ -2175,16 +2175,16 @@ _bfd_write_archive_contents (bfd *arch)\n       /* Round size up to even number in archive header.  */\n       if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size),\n \t\t\t    (elength + 1) & ~(bfd_size_type) 1))\n-\treturn FALSE;\n+\treturn false;\n       memcpy (hdr.ar_fmag, ARFMAG, 2);\n       if ((bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)\n \t   != sizeof (struct ar_hdr))\n \t  || bfd_bwrite (etable, elength, arch) != elength)\n-\treturn FALSE;\n+\treturn false;\n       if ((elength % 2) == 1)\n \t{\n \t  if (bfd_bwrite (&ARFMAG[1], 1, arch) != 1)\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n@@ -2197,7 +2197,7 @@ _bfd_write_archive_contents (bfd *arch)\n \n       /* Write ar header.  */\n       if (!_bfd_write_ar_hdr (arch, current))\n-\treturn FALSE;\n+\treturn false;\n       if (bfd_is_thin_archive (arch))\n \tcontinue;\n       if (bfd_seek (current, (file_ptr) 0, SEEK_SET) != 0)\n@@ -2213,14 +2213,14 @@ _bfd_write_archive_contents (bfd *arch)\n \t  if (bfd_bread (buffer, amt, current) != amt)\n \t    goto input_err;\n \t  if (bfd_bwrite (buffer, amt, arch) != amt)\n-\t    return FALSE;\n+\t    return false;\n \t  remaining -= amt;\n \t}\n \n       if ((arelt_size (current) % 2) == 1)\n \t{\n \t  if (bfd_bwrite (&ARFMAG[1], 1, arch) != 1)\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n@@ -2243,16 +2243,16 @@ _bfd_write_archive_contents (bfd *arch)\n       while (++tries < 6);\n     }\n \n-  return TRUE;\n+  return true;\n \n  input_err:\n   bfd_set_input_error (current, bfd_get_error ());\n-  return FALSE;\n+  return false;\n }\n \f\n /* Note that the namidx for the first symbol is 0.  */\n \n-bfd_boolean\n+bool\n _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)\n {\n   char *first_name = NULL;\n@@ -2264,9 +2264,9 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)\n   int stridx = 0;\n   asymbol **syms = NULL;\n   long syms_max = 0;\n-  bfd_boolean ret;\n+  bool ret;\n   size_t amt;\n-  static bfd_boolean report_plugin_err = TRUE;\n+  static bool report_plugin_err = true;\n \n   /* Dunno if this is the best place for this info...  */\n   if (elength != 0)\n@@ -2303,7 +2303,7 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)\n \n \t  if (current->lto_slim_object && report_plugin_err)\n \t    {\n-\t      report_plugin_err = FALSE;\n+\t      report_plugin_err = false;\n \t      _bfd_error_handler\n \t\t(_(\"%pB: plugin needed to handle lto object\"),\n \t\t current);\n@@ -2363,7 +2363,7 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)\n \t\t\t\t     \"__gnu_lto_slim\") == 0\n \t\t\t  && report_plugin_err)\n \t\t\t{\n-\t\t\t  report_plugin_err = FALSE;\n+\t\t\t  report_plugin_err = false;\n \t\t\t  _bfd_error_handler\n \t\t\t    (_(\"%pB: plugin needed to handle lto object\"),\n \t\t\t     current);\n@@ -2411,10 +2411,10 @@ _bfd_compute_and_write_armap (bfd *arch, unsigned int elength)\n   if (first_name != NULL)\n     bfd_release (arch, first_name);\n \n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n _bfd_bsd_write_armap (bfd *arch,\n \t\t      unsigned int elength,\n \t\t      struct orl *map,\n@@ -2498,14 +2498,14 @@ _bfd_bsd_write_armap (bfd *arch,\n   _bfd_ar_spacepad (hdr.ar_uid, sizeof (hdr.ar_uid), \"%ld\", uid);\n   _bfd_ar_spacepad (hdr.ar_gid, sizeof (hdr.ar_gid), \"%ld\", gid);\n   if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize))\n-    return FALSE;\n+    return false;\n   memcpy (hdr.ar_fmag, ARFMAG, 2);\n   if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)\n       != sizeof (struct ar_hdr))\n-    return FALSE;\n+    return false;\n   H_PUT_32 (arch, ranlibsize, temp);\n   if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))\n-    return FALSE;\n+    return false;\n \n   firstreal = first;\n   current = arch->archive_head;\n@@ -2536,38 +2536,38 @@ _bfd_bsd_write_armap (bfd *arch,\n       if (firstreal != (file_ptr) offset)\n \t{\n \t  bfd_set_error (bfd_error_file_truncated);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       last_elt = current;\n       H_PUT_32 (arch, map[count].namidx, buf);\n       H_PUT_32 (arch, firstreal, buf + BSD_SYMDEF_OFFSET_SIZE);\n       if (bfd_bwrite (buf, BSD_SYMDEF_SIZE, arch)\n \t  != BSD_SYMDEF_SIZE)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Now write the strings themselves.  */\n   H_PUT_32 (arch, stringsize, temp);\n   if (bfd_bwrite (temp, sizeof (temp), arch) != sizeof (temp))\n-    return FALSE;\n+    return false;\n   for (count = 0; count < orl_count; count++)\n     {\n       size_t len = strlen (*map[count].name) + 1;\n \n       if (bfd_bwrite (*map[count].name, len, arch) != len)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* The spec sez this should be a newline.  But in order to be\n      bug-compatible for sun's ar we use a null.  */\n   if (padit)\n     {\n       if (bfd_bwrite (\"\", 1, arch) != 1)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* At the end of archive file handling, update the timestamp in the\n@@ -2576,15 +2576,15 @@ _bfd_bsd_write_armap (bfd *arch,\n    Return TRUE if the timestamp was OK, or an unusual problem happened.\n    Return FALSE if we updated the timestamp.  */\n \n-bfd_boolean\n+bool\n _bfd_archive_bsd_update_armap_timestamp (bfd *arch)\n {\n   struct stat archstat;\n   struct ar_hdr hdr;\n \n   /* If creating deterministic archives, just leave the timestamp as-is.  */\n   if ((arch->flags & BFD_DETERMINISTIC_OUTPUT) != 0)\n-    return TRUE;\n+    return true;\n \n   /* Flush writes, get last-write timestamp from file, and compare it\n      to the timestamp IN the file.  */\n@@ -2594,11 +2594,11 @@ _bfd_archive_bsd_update_armap_timestamp (bfd *arch)\n       bfd_perror (_(\"Reading archive file mod timestamp\"));\n \n       /* Can't read mod time for some reason.  */\n-      return TRUE;\n+      return true;\n     }\n   if (((long) archstat.st_mtime) <= bfd_ardata (arch)->armap_timestamp)\n     /* OK by the linker's rules.  */\n-    return TRUE;\n+    return true;\n \n   /* Update the timestamp.  */\n   bfd_ardata (arch)->armap_timestamp = archstat.st_mtime + ARMAP_TIME_OFFSET;\n@@ -2618,11 +2618,11 @@ _bfd_archive_bsd_update_armap_timestamp (bfd *arch)\n       bfd_perror (_(\"Writing updated armap timestamp\"));\n \n       /* Some error while writing.  */\n-      return TRUE;\n+      return true;\n     }\n \n   /* We updated the timestamp successfully.  */\n-  return FALSE;\n+  return false;\n }\n \f\n /* A coff armap looks like :\n@@ -2638,7 +2638,7 @@ _bfd_archive_bsd_update_armap_timestamp (bfd *arch)\n \n    symbol name n-1  */\n \n-bfd_boolean\n+bool\n _bfd_coff_write_armap (bfd *arch,\n \t\t       unsigned int elength,\n \t\t       struct orl *map,\n@@ -2701,7 +2701,7 @@ _bfd_coff_write_armap (bfd *arch,\n   memset (&hdr, ' ', sizeof (struct ar_hdr));\n   hdr.ar_name[0] = '/';\n   if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize))\n-    return FALSE;\n+    return false;\n   _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), \"%ld\",\n \t\t    ((arch->flags & BFD_DETERMINISTIC_OUTPUT) == 0\n \t\t     ? time (NULL) : 0));\n@@ -2714,10 +2714,10 @@ _bfd_coff_write_armap (bfd *arch,\n   /* Write the ar header for this item and the number of symbols.  */\n   if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)\n       != sizeof (struct ar_hdr))\n-    return FALSE;\n+    return false;\n \n   if (!bfd_write_bigendian_4byte_int (arch, symbol_count))\n-    return FALSE;\n+    return false;\n \n   /* Two passes, first write the file offsets for each symbol -\n      remembering that each offset is on a two byte boundary.  */\n@@ -2741,10 +2741,10 @@ _bfd_coff_write_armap (bfd *arch,\n \t  if (archive_member_file_ptr != (file_ptr) offset)\n \t    {\n \t      bfd_set_error (bfd_error_file_truncated);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  if (!bfd_write_bigendian_4byte_int (arch, offset))\n-\t    return FALSE;\n+\t    return false;\n \t  count++;\n \t}\n       archive_member_file_ptr += sizeof (struct ar_hdr);\n@@ -2764,29 +2764,29 @@ _bfd_coff_write_armap (bfd *arch,\n       size_t len = strlen (*map[count].name) + 1;\n \n       if (bfd_bwrite (*map[count].name, len, arch) != len)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* The spec sez this should be a newline.  But in order to be\n      bug-compatible for arc960 we use a null.  */\n   if (padit)\n     {\n       if (bfd_bwrite (\"\", 1, arch) != 1)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n _bfd_noarchive_write_armap\n     (bfd *arch ATTRIBUTE_UNUSED,\n      unsigned int elength ATTRIBUTE_UNUSED,\n      struct orl *map ATTRIBUTE_UNUSED,\n      unsigned int orl_count ATTRIBUTE_UNUSED,\n      int stridx ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n static int\n@@ -2822,7 +2822,7 @@ _bfd_unlink_from_archive_parent (bfd *abfd)\n     }\n }\n \n-bfd_boolean\n+bool\n _bfd_archive_close_and_cleanup (bfd *abfd)\n {\n   if (bfd_read_p (abfd) && abfd->format == bfd_archive)\n@@ -2852,5 +2852,5 @@ _bfd_archive_close_and_cleanup (bfd *abfd)\n   if (abfd->is_linker_output)\n     (*abfd->link.hash->hash_table_free) (abfd);\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "3962b745486ccac3e6566dfe44bbf106293f3bc8",
      "filename": "bfd/archive64.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/archive64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/archive64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/archive64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -34,7 +34,7 @@\n \n /* Read an Irix 6 armap.  */\n \n-bfd_boolean\n+bool\n _bfd_archive_64_bit_slurp_armap (bfd *abfd)\n {\n   struct artdata *ardata = bfd_ardata (abfd);\n@@ -54,41 +54,41 @@ _bfd_archive_64_bit_slurp_armap (bfd *abfd)\n   /* Get the name of the first element.  */\n   i = bfd_bread (nextname, 16, abfd);\n   if (i == 0)\n-    return TRUE;\n+    return true;\n   if (i != 16)\n-    return FALSE;\n+    return false;\n \n   if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) != 0)\n-    return FALSE;\n+    return false;\n \n   /* Archives with traditional armaps are still permitted.  */\n   if (startswith (nextname, \"/               \"))\n     return bfd_slurp_armap (abfd);\n \n   if (! startswith (nextname, \"/SYM64/         \"))\n     {\n-      abfd->has_armap = FALSE;\n-      return TRUE;\n+      abfd->has_armap = false;\n+      return true;\n     }\n \n   mapdata = (struct areltdata *) _bfd_read_ar_hdr (abfd);\n   if (mapdata == NULL)\n-    return FALSE;\n+    return false;\n   parsed_size = mapdata->parsed_size;\n   free (mapdata);\n \n   filesize = bfd_get_file_size (abfd);\n   if (filesize != 0 && parsed_size > filesize)\n     {\n       bfd_set_error (bfd_error_malformed_archive);\n-      return FALSE;\n+      return false;\n     }\n \n   if (bfd_bread (int_buf, 8, abfd) != 8)\n     {\n       if (bfd_get_error () != bfd_error_system_call)\n \tbfd_set_error (bfd_error_malformed_archive);\n-      return FALSE;\n+      return false;\n     }\n \n   nsymz = bfd_getb64 (int_buf);\n@@ -108,11 +108,11 @@ _bfd_archive_64_bit_slurp_armap (bfd *abfd)\n       || amt <= stringsize)\n     {\n       bfd_set_error (bfd_error_malformed_archive);\n-      return FALSE;\n+      return false;\n     }\n   ardata->symdefs = (struct carsym *) bfd_alloc (abfd, amt);\n   if (ardata->symdefs == NULL)\n-    return FALSE;\n+    return false;\n   carsyms = ardata->symdefs;\n   stringbase = ((char *) ardata->symdefs) + carsym_size;\n \n@@ -142,21 +142,21 @@ _bfd_archive_64_bit_slurp_armap (bfd *abfd)\n   /* Pad to an even boundary if you have to.  */\n   ardata->first_file_filepos += (ardata->first_file_filepos) % 2;\n \n-  abfd->has_armap = TRUE;\n+  abfd->has_armap = true;\n   bfd_release (abfd, raw_armap);\n \n-  return TRUE;\n+  return true;\n \n  release_symdefs:\n   bfd_release (abfd, ardata->symdefs);\n-  return FALSE;\n+  return false;\n }\n \n /* Write out an Irix 6 armap.  The Irix 6 tools are supposed to be\n    able to handle ordinary ELF armaps, but at least on Irix 6.2 the\n    linker crashes.  */\n \n-bfd_boolean\n+bool\n _bfd_archive_64_bit_write_armap (bfd *arch,\n \t\t\t\t unsigned int elength,\n \t\t\t\t struct orl *map,\n@@ -185,7 +185,7 @@ _bfd_archive_64_bit_write_armap (bfd *arch,\n   memset (&hdr, ' ', sizeof (struct ar_hdr));\n   memcpy (hdr.ar_name, \"/SYM64/\", strlen (\"/SYM64/\"));\n   if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize))\n-    return FALSE;\n+    return false;\n   _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), \"%ld\",\n \t\t    time (NULL));\n   /* This, at least, is what Intel coff sets the values to.: */\n@@ -198,11 +198,11 @@ _bfd_archive_64_bit_write_armap (bfd *arch,\n \n   if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)\n       != sizeof (struct ar_hdr))\n-    return FALSE;\n+    return false;\n \n   bfd_putb64 ((bfd_vma) symbol_count, buf);\n   if (bfd_bwrite (buf, 8, arch) != 8)\n-    return FALSE;\n+    return false;\n \n   /* Two passes, first write the file offsets for each symbol -\n      remembering that each offset is on a two byte boundary.  */\n@@ -223,7 +223,7 @@ _bfd_archive_64_bit_write_armap (bfd *arch,\n \t{\n \t  bfd_putb64 ((bfd_vma) archive_member_file_ptr, buf);\n \t  if (bfd_bwrite (buf, 8, arch) != 8)\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n       /* Add size of this archive entry */\n@@ -240,17 +240,17 @@ _bfd_archive_64_bit_write_armap (bfd *arch,\n       size_t len = strlen (*map[count].name) + 1;\n \n       if (bfd_bwrite (*map[count].name, len, arch) != len)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* The spec says that this should be padded to an 8 byte boundary.\n      However, the Irix 6.2 tools do not appear to do this.  */\n   while (padding != 0)\n     {\n       if (bfd_bwrite (\"\", 1, arch) != 1)\n-\treturn FALSE;\n+\treturn false;\n       --padding;\n     }\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "390691bfba17aa076f4c6e940626e8a5dc614bc9",
      "filename": "bfd/archures.c",
      "status": "modified",
      "additions": 26,
      "deletions": 27,
      "changes": 53,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/archures.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/archures.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/archures.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -581,17 +581,16 @@ DESCRIPTION\n .  {* TRUE if this is the default machine for the architecture.\n .     The default arch should be the first entry for an arch so that\n .     all the entries for that arch can be accessed via <<next>>.  *}\n-.  bfd_boolean the_default;\n+.  bool the_default;\n .  const struct bfd_arch_info * (*compatible) (const struct bfd_arch_info *,\n .\t\t\t\t\t       const struct bfd_arch_info *);\n .\n-.  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);\n+.  bool (*scan) (const struct bfd_arch_info *, const char *);\n .\n .  {* Allocate via bfd_malloc and return a fill buffer of size COUNT.  If\n .     IS_BIGENDIAN is TRUE, the order of bytes is big endian.  If CODE is\n .     TRUE, the buffer contains code.  *}\n-.  void *(*fill) (bfd_size_type count, bfd_boolean is_bigendian,\n-.\t\t  bfd_boolean code);\n+.  void *(*fill) (bfd_size_type count, bool is_bigendian, bool code);\n .\n .  const struct bfd_arch_info *next;\n .\n@@ -892,7 +891,7 @@ FUNCTION\n \n SYNOPSIS\n \tconst bfd_arch_info_type *bfd_arch_get_compatible\n-\t  (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);\n+\t  (const bfd *abfd, const bfd *bbfd, bool accept_unknowns);\n \n DESCRIPTION\n \tDetermine whether two BFDs' architectures and machine types\n@@ -905,7 +904,7 @@ DESCRIPTION\n const bfd_arch_info_type *\n bfd_arch_get_compatible (const bfd *abfd,\n \t\t\t const bfd *bbfd,\n-\t\t\t bfd_boolean accept_unknowns)\n+\t\t\t bool accept_unknowns)\n {\n   const bfd *ubfd, *kbfd;\n \n@@ -946,7 +945,7 @@ DESCRIPTION\n \n const bfd_arch_info_type bfd_default_arch_struct =\n {\n-  32, 32, 8, bfd_arch_unknown, 0, \"unknown\", \"unknown\", 2, TRUE,\n+  32, 32, 8, bfd_arch_unknown, 0, \"unknown\", \"unknown\", 2, true,\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,\n@@ -975,7 +974,7 @@ FUNCTION\n \tbfd_default_set_arch_mach\n \n SYNOPSIS\n-\tbfd_boolean bfd_default_set_arch_mach\n+\tbool bfd_default_set_arch_mach\n \t  (bfd *abfd, enum bfd_architecture arch, unsigned long mach);\n \n DESCRIPTION\n@@ -985,18 +984,18 @@ DESCRIPTION\n \tpointer.\n */\n \n-bfd_boolean\n+bool\n bfd_default_set_arch_mach (bfd *abfd,\n \t\t\t   enum bfd_architecture arch,\n \t\t\t   unsigned long mach)\n {\n   abfd->arch_info = bfd_lookup_arch (arch, mach);\n   if (abfd->arch_info != NULL)\n-    return TRUE;\n+    return true;\n \n   abfd->arch_info = &bfd_default_arch_struct;\n   bfd_set_error (bfd_error_bad_value);\n-  return FALSE;\n+  return false;\n }\n \n /*\n@@ -1107,15 +1106,15 @@ INTERNAL_FUNCTION\n \tbfd_default_scan\n \n SYNOPSIS\n-\tbfd_boolean bfd_default_scan\n+\tbool bfd_default_scan\n \t  (const struct bfd_arch_info *info, const char *string);\n \n DESCRIPTION\n \tThe default function for working out whether this is an\n \tarchitecture hit and a machine hit.\n */\n \n-bfd_boolean\n+bool\n bfd_default_scan (const bfd_arch_info_type *info, const char *string)\n {\n   const char *ptr_src;\n@@ -1128,11 +1127,11 @@ bfd_default_scan (const bfd_arch_info_type *info, const char *string)\n      default architecture?  */\n   if (strcasecmp (string, info->arch_name) == 0\n       && info->the_default)\n-    return TRUE;\n+    return true;\n \n   /* Exact match of the machine name (PRINTABLE_NAME)?  */\n   if (strcasecmp (string, info->printable_name) == 0)\n-    return TRUE;\n+    return true;\n \n   /* Given that printable_name contains no colon, attempt to match:\n      ARCH_NAME [ \":\" ] PRINTABLE_NAME?  */\n@@ -1146,13 +1145,13 @@ bfd_default_scan (const bfd_arch_info_type *info, const char *string)\n \t    {\n \t      if (strcasecmp (string + strlen_arch_name + 1,\n \t\t\t      info->printable_name) == 0)\n-\t\treturn TRUE;\n+\t\treturn true;\n \t    }\n \t  else\n \t    {\n \t      if (strcasecmp (string + strlen_arch_name,\n \t\t\t      info->printable_name) == 0)\n-\t\treturn TRUE;\n+\t\treturn true;\n \t    }\n \t}\n     }\n@@ -1165,7 +1164,7 @@ bfd_default_scan (const bfd_arch_info_type *info, const char *string)\n       if (strncasecmp (string, info->printable_name, colon_index) == 0\n \t  && strcasecmp (string + colon_index,\n \t\t\t info->printable_name + colon_index + 1) == 0)\n-\treturn TRUE;\n+\treturn true;\n     }\n \n   /* Given that PRINTABLE_NAME has the form: <arch> \":\" <mach>; Do not\n@@ -1295,16 +1294,16 @@ bfd_default_scan (const bfd_arch_info_type *info, const char *string)\n       break;\n \n     default:\n-      return FALSE;\n+      return false;\n     }\n \n   if (arch != info->arch)\n-    return FALSE;\n+    return false;\n \n   if (number != info->mach)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /*\n@@ -1441,8 +1440,8 @@ INTERNAL_FUNCTION\n \n SYNOPSIS\n \tvoid *bfd_arch_default_fill (bfd_size_type count,\n-\t\t\t\t     bfd_boolean is_bigendian,\n-\t\t\t\t     bfd_boolean code);\n+\t\t\t\t     bool is_bigendian,\n+\t\t\t\t     bool code);\n \n DESCRIPTION\n \tAllocate via bfd_malloc and return a fill buffer of size COUNT.\n@@ -1452,16 +1451,16 @@ DESCRIPTION\n \n void *\n bfd_arch_default_fill (bfd_size_type count,\n-\t\t       bfd_boolean is_bigendian ATTRIBUTE_UNUSED,\n-\t\t       bfd_boolean code ATTRIBUTE_UNUSED)\n+\t\t       bool is_bigendian ATTRIBUTE_UNUSED,\n+\t\t       bool code ATTRIBUTE_UNUSED)\n {\n   void *fill = bfd_malloc (count);\n   if (fill != NULL)\n     memset (fill, 0, count);\n   return fill;\n }\n \n-bfd_boolean\n+bool\n _bfd_nowrite_set_arch_mach (bfd *abfd,\n \t\t\t    enum bfd_architecture arch ATTRIBUTE_UNUSED,\n \t\t\t    unsigned long mach ATTRIBUTE_UNUSED)"
    },
    {
      "sha": "6f72cc4539bbd5ddcaba824e77b4f57aab163445",
      "filename": "bfd/bfd-in.h",
      "status": "modified",
      "additions": 14,
      "deletions": 15,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/bfd-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/bfd-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -339,15 +339,15 @@ struct bfd_hash_table\n };\n \n /* Initialize a hash table.  */\n-extern bfd_boolean bfd_hash_table_init\n+extern bool bfd_hash_table_init\n   (struct bfd_hash_table *,\n    struct bfd_hash_entry *(*) (struct bfd_hash_entry *,\n \t\t\t       struct bfd_hash_table *,\n \t\t\t       const char *),\n    unsigned int);\n \n /* Initialize a hash table specifying a size.  */\n-extern bfd_boolean bfd_hash_table_init_n\n+extern bool bfd_hash_table_init_n\n   (struct bfd_hash_table *,\n    struct bfd_hash_entry *(*) (struct bfd_hash_entry *,\n \t\t\t       struct bfd_hash_table *,\n@@ -363,8 +363,7 @@ extern void bfd_hash_table_free\n    COPY argument must be TRUE if this routine should copy the string\n    into newly allocated memory when adding an entry.  */\n extern struct bfd_hash_entry *bfd_hash_lookup\n-  (struct bfd_hash_table *, const char *, bfd_boolean create,\n-   bfd_boolean copy);\n+  (struct bfd_hash_table *, const char *, bool create, bool copy);\n \n /* Insert an entry in a hash table.  */\n extern struct bfd_hash_entry *bfd_hash_insert\n@@ -392,7 +391,7 @@ extern void *bfd_hash_allocate\n    INFO argument is passed to the function.  */\n extern void bfd_hash_traverse\n   (struct bfd_hash_table *,\n-   bfd_boolean (*) (struct bfd_hash_entry *, void *),\n+   bool (*) (struct bfd_hash_entry *, void *),\n    void *info);\n \n /* Allows the default size of a hash table to be configured. New hash\n@@ -455,15 +454,15 @@ extern int bfd_stat (bfd *, struct stat *);\n #endif\n extern void _bfd_warn_deprecated (const char *, const char *, int, const char *);\n \n-extern bfd_boolean bfd_cache_close\n+extern bool bfd_cache_close\n   (bfd *abfd);\n /* NB: This declaration should match the autogenerated one in libbfd.h.  */\n \n-extern bfd_boolean bfd_cache_close_all (void);\n+extern bool bfd_cache_close_all (void);\n \n-extern bfd_boolean bfd_record_phdr\n-  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,\n-   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);\n+extern bool bfd_record_phdr\n+  (bfd *, unsigned long, bool, flagword, bool, bfd_vma,\n+   bool, bool, unsigned int, struct bfd_section **);\n \n /* Byte swapping routines.  */\n \n@@ -490,8 +489,8 @@ void bfd_putl16 (bfd_vma, void *);\n \n /* Byte swapping routines which take size and endiannes as arguments.  */\n \n-bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);\n-void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);\n+bfd_uint64_t bfd_get_bits (const void *, int, bool);\n+void bfd_put_bits (bfd_uint64_t, void *, int, bool);\n \n \n /* mmap hacks */\n@@ -518,8 +517,8 @@ extern void bfd_init_window\n   (bfd_window *);\n extern void bfd_free_window\n   (bfd_window *);\n-extern bfd_boolean bfd_get_file_window\n-  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);\n+extern bool bfd_get_file_window\n+  (bfd *, file_ptr, bfd_size_type, bfd_window *, bool);\n \f\n /* Externally visible ELF routines.  */\n \n@@ -551,7 +550,7 @@ struct bfd_link_hash_entry;\n \n /* Return TRUE if the start of STR matches PREFIX, FALSE otherwise.  */\n \n-static inline bfd_boolean\n+static inline bool\n startswith (const char *str, const char *prefix)\n {\n   return strncmp (str, prefix, strlen (prefix)) == 0;"
    },
    {
      "sha": "40d35a1a43925bb446f419265e87ad8ab7a0a654",
      "filename": "bfd/bfd-in2.h",
      "status": "modified",
      "additions": 215,
      "deletions": 220,
      "changes": 435,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/bfd-in2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/bfd-in2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd-in2.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -346,15 +346,15 @@ struct bfd_hash_table\n };\n \n /* Initialize a hash table.  */\n-extern bfd_boolean bfd_hash_table_init\n+extern bool bfd_hash_table_init\n   (struct bfd_hash_table *,\n    struct bfd_hash_entry *(*) (struct bfd_hash_entry *,\n \t\t\t       struct bfd_hash_table *,\n \t\t\t       const char *),\n    unsigned int);\n \n /* Initialize a hash table specifying a size.  */\n-extern bfd_boolean bfd_hash_table_init_n\n+extern bool bfd_hash_table_init_n\n   (struct bfd_hash_table *,\n    struct bfd_hash_entry *(*) (struct bfd_hash_entry *,\n \t\t\t       struct bfd_hash_table *,\n@@ -370,8 +370,7 @@ extern void bfd_hash_table_free\n    COPY argument must be TRUE if this routine should copy the string\n    into newly allocated memory when adding an entry.  */\n extern struct bfd_hash_entry *bfd_hash_lookup\n-  (struct bfd_hash_table *, const char *, bfd_boolean create,\n-   bfd_boolean copy);\n+  (struct bfd_hash_table *, const char *, bool create, bool copy);\n \n /* Insert an entry in a hash table.  */\n extern struct bfd_hash_entry *bfd_hash_insert\n@@ -399,7 +398,7 @@ extern void *bfd_hash_allocate\n    INFO argument is passed to the function.  */\n extern void bfd_hash_traverse\n   (struct bfd_hash_table *,\n-   bfd_boolean (*) (struct bfd_hash_entry *, void *),\n+   bool (*) (struct bfd_hash_entry *, void *),\n    void *info);\n \n /* Allows the default size of a hash table to be configured. New hash\n@@ -462,15 +461,15 @@ extern int bfd_stat (bfd *, struct stat *);\n #endif\n extern void _bfd_warn_deprecated (const char *, const char *, int, const char *);\n \n-extern bfd_boolean bfd_cache_close\n+extern bool bfd_cache_close\n   (bfd *abfd);\n /* NB: This declaration should match the autogenerated one in libbfd.h.  */\n \n-extern bfd_boolean bfd_cache_close_all (void);\n+extern bool bfd_cache_close_all (void);\n \n-extern bfd_boolean bfd_record_phdr\n-  (bfd *, unsigned long, bfd_boolean, flagword, bfd_boolean, bfd_vma,\n-   bfd_boolean, bfd_boolean, unsigned int, struct bfd_section **);\n+extern bool bfd_record_phdr\n+  (bfd *, unsigned long, bool, flagword, bool, bfd_vma,\n+   bool, bool, unsigned int, struct bfd_section **);\n \n /* Byte swapping routines.  */\n \n@@ -497,8 +496,8 @@ void bfd_putl16 (bfd_vma, void *);\n \n /* Byte swapping routines which take size and endiannes as arguments.  */\n \n-bfd_uint64_t bfd_get_bits (const void *, int, bfd_boolean);\n-void bfd_put_bits (bfd_uint64_t, void *, int, bfd_boolean);\n+bfd_uint64_t bfd_get_bits (const void *, int, bool);\n+void bfd_put_bits (bfd_uint64_t, void *, int, bool);\n \n \n /* mmap hacks */\n@@ -525,8 +524,8 @@ extern void bfd_init_window\n   (bfd_window *);\n extern void bfd_free_window\n   (bfd_window *);\n-extern bfd_boolean bfd_get_file_window\n-  (bfd *, file_ptr, bfd_size_type, bfd_window *, bfd_boolean);\n+extern bool bfd_get_file_window\n+  (bfd *, file_ptr, bfd_size_type, bfd_window *, bool);\n \f\n /* Externally visible ELF routines.  */\n \n@@ -558,7 +557,7 @@ struct bfd_link_hash_entry;\n \n /* Return TRUE if the start of STR matches PREFIX, FALSE otherwise.  */\n \n-static inline bfd_boolean\n+static inline bool\n startswith (const char *str, const char *prefix)\n {\n   return strncmp (str, prefix, strlen (prefix)) == 0;\n@@ -602,15 +601,15 @@ bfd *bfd_openr_iovec (const char *filename, const char *target,\n \n bfd *bfd_openw (const char *filename, const char *target);\n \n-bfd_boolean bfd_close (bfd *abfd);\n+bool bfd_close (bfd *abfd);\n \n-bfd_boolean bfd_close_all_done (bfd *);\n+bool bfd_close_all_done (bfd *);\n \n bfd *bfd_create (const char *filename, bfd *templ);\n \n-bfd_boolean bfd_make_writable (bfd *abfd);\n+bool bfd_make_writable (bfd *abfd);\n \n-bfd_boolean bfd_make_readable (bfd *abfd);\n+bool bfd_make_readable (bfd *abfd);\n \n void *bfd_alloc (bfd *abfd, bfd_size_type wanted);\n \n@@ -632,7 +631,7 @@ char *bfd_follow_gnu_debugaltlink (bfd *abfd, const char *dir);\n struct bfd_section *bfd_create_gnu_debuglink_section\n    (bfd *abfd, const char *filename);\n \n-bfd_boolean bfd_fill_in_gnu_debuglink_section\n+bool bfd_fill_in_gnu_debuglink_section\n    (bfd *abfd, struct bfd_section *sect, const char *filename);\n \n char *bfd_follow_build_id_debuglink (bfd *abfd, const char *dir);\n@@ -1244,7 +1243,7 @@ bfd_section_userdata (const asection *sec)\n {\n   return sec->userdata;\n }\n-static inline bfd_boolean\n+static inline bool\n bfd_is_com_section (const asection *sec)\n {\n   return (sec->flags & SEC_IS_COMMON) != 0;\n@@ -1254,33 +1253,33 @@ bfd_is_com_section (const asection *sec)\n    because not all callers use the return value.  A macro implementation\n    would use a comma expression, eg: \"((ptr)->foo = val, TRUE)\" and some\n    compilers will complain about comma expressions that have no effect.  */\n-static inline bfd_boolean\n+static inline bool\n bfd_set_section_userdata (asection *sec, void *val)\n {\n   sec->userdata = val;\n-  return TRUE;\n+  return true;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_set_section_vma (asection *sec, bfd_vma val)\n {\n   sec->vma = sec->lma = val;\n-  sec->user_set_vma = TRUE;\n-  return TRUE;\n+  sec->user_set_vma = true;\n+  return true;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_set_section_lma (asection *sec, bfd_vma val)\n {\n   sec->lma = val;\n-  return TRUE;\n+  return true;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_set_section_alignment (asection *sec, unsigned int val)\n {\n   sec->alignment_power = val;\n-  return TRUE;\n+  return true;\n }\n \n /* These sections are global, and are managed by BFD.  The application\n@@ -1302,25 +1301,25 @@ extern asection _bfd_std_section[4];\n /* Pointer to the indirect section.  */\n #define bfd_ind_section_ptr (&_bfd_std_section[3])\n \n-static inline bfd_boolean\n+static inline bool\n bfd_is_und_section (const asection *sec)\n {\n   return sec == bfd_und_section_ptr;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_is_abs_section (const asection *sec)\n {\n   return sec == bfd_abs_section_ptr;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_is_ind_section (const asection *sec)\n {\n   return sec == bfd_ind_section_ptr;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_is_const_section (const asection *sec)\n {\n   return (sec >= _bfd_std_section\n@@ -1329,7 +1328,7 @@ bfd_is_const_section (const asection *sec)\n }\n \n /* Return TRUE if input section SEC has been discarded.  */\n-static inline bfd_boolean\n+static inline bool\n discarded_section (const asection *sec)\n {\n   return (!bfd_is_abs_section (sec)\n@@ -1400,7 +1399,7 @@ asection *bfd_get_linker_section (bfd *abfd, const char *name);\n asection *bfd_get_section_by_name_if\n    (bfd *abfd,\n     const char *name,\n-    bfd_boolean (*func) (bfd *abfd, asection *sect, void *obj),\n+    bool (*func) (bfd *abfd, asection *sect, void *obj),\n     void *obj);\n \n char *bfd_get_unique_section_name\n@@ -1418,7 +1417,7 @@ asection *bfd_make_section_with_flags\n \n asection *bfd_make_section (bfd *, const char *name);\n \n-bfd_boolean bfd_set_section_flags (asection *sec, flagword flags);\n+bool bfd_set_section_flags (asection *sec, flagword flags);\n \n void bfd_rename_section\n    (asection *sec, const char *newname);\n@@ -1430,33 +1429,33 @@ void bfd_map_over_sections\n \n asection *bfd_sections_find_if\n    (bfd *abfd,\n-    bfd_boolean (*operation) (bfd *abfd, asection *sect, void *obj),\n+    bool (*operation) (bfd *abfd, asection *sect, void *obj),\n     void *obj);\n \n-bfd_boolean bfd_set_section_size (asection *sec, bfd_size_type val);\n+bool bfd_set_section_size (asection *sec, bfd_size_type val);\n \n-bfd_boolean bfd_set_section_contents\n+bool bfd_set_section_contents\n    (bfd *abfd, asection *section, const void *data,\n     file_ptr offset, bfd_size_type count);\n \n-bfd_boolean bfd_get_section_contents\n+bool bfd_get_section_contents\n    (bfd *abfd, asection *section, void *location, file_ptr offset,\n     bfd_size_type count);\n \n-bfd_boolean bfd_malloc_and_get_section\n+bool bfd_malloc_and_get_section\n    (bfd *abfd, asection *section, bfd_byte **buf);\n \n-bfd_boolean bfd_copy_private_section_data\n+bool bfd_copy_private_section_data\n    (bfd *ibfd, asection *isec, bfd *obfd, asection *osec);\n \n #define bfd_copy_private_section_data(ibfd, isection, obfd, osection) \\\n        BFD_SEND (obfd, _bfd_copy_private_section_data, \\\n                  (ibfd, isection, obfd, osection))\n-bfd_boolean bfd_generic_is_group_section (bfd *, const asection *sec);\n+bool bfd_generic_is_group_section (bfd *, const asection *sec);\n \n const char *bfd_generic_group_name (bfd *, const asection *sec);\n \n-bfd_boolean bfd_generic_discard_group (bfd *abfd, asection *group);\n+bool bfd_generic_discard_group (bfd *abfd, asection *group);\n \n /* Extracted from archures.c.  */\n enum bfd_architecture\n@@ -1965,17 +1964,16 @@ typedef struct bfd_arch_info\n   /* TRUE if this is the default machine for the architecture.\n      The default arch should be the first entry for an arch so that\n      all the entries for that arch can be accessed via <<next>>.  */\n-  bfd_boolean the_default;\n+  bool the_default;\n   const struct bfd_arch_info * (*compatible) (const struct bfd_arch_info *,\n                                               const struct bfd_arch_info *);\n \n-  bfd_boolean (*scan) (const struct bfd_arch_info *, const char *);\n+  bool (*scan) (const struct bfd_arch_info *, const char *);\n \n   /* Allocate via bfd_malloc and return a fill buffer of size COUNT.  If\n      IS_BIGENDIAN is TRUE, the order of bytes is big endian.  If CODE is\n      TRUE, the buffer contains code.  */\n-  void *(*fill) (bfd_size_type count, bfd_boolean is_bigendian,\n-                 bfd_boolean code);\n+  void *(*fill) (bfd_size_type count, bool is_bigendian, bool code);\n \n   const struct bfd_arch_info *next;\n \n@@ -1998,11 +1996,11 @@ const bfd_arch_info_type *bfd_scan_arch (const char *string);\n const char **bfd_arch_list (void);\n \n const bfd_arch_info_type *bfd_arch_get_compatible\n-   (const bfd *abfd, const bfd *bbfd, bfd_boolean accept_unknowns);\n+   (const bfd *abfd, const bfd *bbfd, bool accept_unknowns);\n \n void bfd_set_arch_info (bfd *abfd, const bfd_arch_info_type *arg);\n \n-bfd_boolean bfd_default_set_arch_mach\n+bool bfd_default_set_arch_mach\n    (bfd *abfd, enum bfd_architecture arch, unsigned long mach);\n \n enum bfd_architecture bfd_get_arch (const bfd *abfd);\n@@ -2187,8 +2185,8 @@ struct reloc_howto_struct\n   { (unsigned) type, size < 0 ? -size : size, bits, right, left, ovf,  \\\n     size < 0, pcrel, inplace, pcrel_off, src_mask, dst_mask, func, name }\n #define EMPTY_HOWTO(C) \\\n-  HOWTO ((C), 0, 0, 0, FALSE, 0, complain_overflow_dont, NULL, \\\n-         NULL, FALSE, 0, 0, FALSE)\n+  HOWTO ((C), 0, 0, 0, false, 0, complain_overflow_dont, NULL, \\\n+         NULL, false, 0, 0, false)\n \n unsigned int bfd_get_reloc_size (reloc_howto_type *);\n \n@@ -2206,7 +2204,7 @@ bfd_reloc_status_type bfd_check_overflow\n     unsigned int addrsize,\n     bfd_vma relocation);\n \n-bfd_boolean bfd_reloc_offset_in_range\n+bool bfd_reloc_offset_in_range\n    (reloc_howto_type *howto,\n     bfd *abfd,\n     asection *section,\n@@ -6440,22 +6438,22 @@ asymbol;\n #define bfd_get_symtab_upper_bound(abfd) \\\n        BFD_SEND (abfd, _bfd_get_symtab_upper_bound, (abfd))\n \n-bfd_boolean bfd_is_local_label (bfd *abfd, asymbol *sym);\n+bool bfd_is_local_label (bfd *abfd, asymbol *sym);\n \n-bfd_boolean bfd_is_local_label_name (bfd *abfd, const char *name);\n+bool bfd_is_local_label_name (bfd *abfd, const char *name);\n \n #define bfd_is_local_label_name(abfd, name) \\\n        BFD_SEND (abfd, _bfd_is_local_label_name, (abfd, name))\n \n-bfd_boolean bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);\n+bool bfd_is_target_special_symbol (bfd *abfd, asymbol *sym);\n \n #define bfd_is_target_special_symbol(abfd, sym) \\\n        BFD_SEND (abfd, _bfd_is_target_special_symbol, (abfd, sym))\n \n #define bfd_canonicalize_symtab(abfd, location) \\\n        BFD_SEND (abfd, _bfd_canonicalize_symtab, (abfd, location))\n \n-bfd_boolean bfd_set_symtab\n+bool bfd_set_symtab\n    (bfd *abfd, asymbol **location, unsigned int count);\n \n void bfd_print_symbol_vandf (bfd *abfd, void *file, asymbol *symbol);\n@@ -6470,11 +6468,11 @@ asymbol *_bfd_generic_make_empty_symbol (bfd *);\n \n int bfd_decode_symclass (asymbol *symbol);\n \n-bfd_boolean bfd_is_undefined_symclass (int symclass);\n+bool bfd_is_undefined_symclass (int symclass);\n \n void bfd_symbol_info (asymbol *symbol, symbol_info *ret);\n \n-bfd_boolean bfd_copy_private_symbol_data\n+bool bfd_copy_private_symbol_data\n    (bfd *ibfd, asymbol *isym, bfd *obfd, asymbol *osym);\n \n #define bfd_copy_private_symbol_data(ibfd, isymbol, obfd, osymbol) \\\n@@ -6819,7 +6817,7 @@ bfd_get_filename (const bfd *abfd)\n   return abfd->filename;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_get_cacheable (const bfd *abfd)\n {\n   return abfd->cacheable;\n@@ -6867,13 +6865,13 @@ bfd_count_sections (const bfd *abfd)\n   return abfd->section_count;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_has_map (const bfd *abfd)\n {\n   return abfd->has_armap;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_is_thin_archive (const bfd *abfd)\n {\n   return abfd->is_thin_archive;\n@@ -6886,15 +6884,15 @@ bfd_usrdata (const bfd *abfd)\n }\n \n /* See note beside bfd_set_section_userdata.  */\n-static inline bfd_boolean\n-bfd_set_cacheable (bfd * abfd, bfd_boolean val)\n+static inline bool\n+bfd_set_cacheable (bfd * abfd, bool val)\n {\n   abfd->cacheable = val;\n-  return TRUE;\n+  return true;\n }\n \n static inline void\n-bfd_set_thin_archive (bfd *abfd, bfd_boolean val)\n+bfd_set_thin_archive (bfd *abfd, bool val)\n {\n   abfd->is_thin_archive = val;\n }\n@@ -7029,7 +7027,7 @@ bfd_section_list_insert_before (bfd *abfd, asection *b, asection *s)\n     abfd->sections = s;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_section_removed_from_list (const bfd *abfd, const asection *s)\n {\n   return s->next ? s->next->prev != s : abfd->section_last != s;\n@@ -7101,31 +7099,31 @@ void bfd_set_reloc\n \n #define bfd_set_reloc(abfd, asect, location, count) \\\n        BFD_SEND (abfd, _bfd_set_reloc, (abfd, asect, location, count))\n-bfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);\n+bool bfd_set_file_flags (bfd *abfd, flagword flags);\n \n int bfd_get_arch_size (bfd *abfd);\n \n int bfd_get_sign_extend_vma (bfd *abfd);\n \n-bfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);\n+bool bfd_set_start_address (bfd *abfd, bfd_vma vma);\n \n unsigned int bfd_get_gp_size (bfd *abfd);\n \n void bfd_set_gp_size (bfd *abfd, unsigned int i);\n \n bfd_vma bfd_scan_vma (const char *string, const char **end, int base);\n \n-bfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);\n+bool bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);\n \n #define bfd_copy_private_header_data(ibfd, obfd) \\\n        BFD_SEND (obfd, _bfd_copy_private_header_data, \\\n                  (ibfd, obfd))\n-bfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);\n+bool bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);\n \n #define bfd_copy_private_bfd_data(ibfd, obfd) \\\n        BFD_SEND (obfd, _bfd_copy_private_bfd_data, \\\n                  (ibfd, obfd))\n-bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);\n+bool bfd_set_private_flags (bfd *abfd, flagword flags);\n \n #define bfd_set_private_flags(abfd, flags) \\\n        BFD_SEND (abfd, _bfd_set_private_flags, (abfd, flags))\n@@ -7225,20 +7223,20 @@ bfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);\n \n extern bfd_byte *bfd_get_relocated_section_contents\n   (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,\n-   bfd_boolean, asymbol **);\n+   bool, asymbol **);\n \n-bfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);\n+bool bfd_alt_mach_code (bfd *abfd, int alternative);\n \n bfd_vma bfd_emul_get_maxpagesize (const char *);\n \n-bfd_vma bfd_emul_get_commonpagesize (const char *, bfd_boolean);\n+bfd_vma bfd_emul_get_commonpagesize (const char *, bool);\n \n char *bfd_demangle (bfd *, const char *, int);\n \n void bfd_update_compression_header\n    (bfd *abfd, bfd_byte *contents, asection *sec);\n \n-bfd_boolean bfd_check_compression_header\n+bool bfd_check_compression_header\n    (bfd *abfd, bfd_byte *contents, asection *sec,\n     bfd_size_type *uncompressed_size,\n     unsigned int *uncompressed_alignment_power);\n@@ -7248,15 +7246,15 @@ int bfd_get_compression_header_size (bfd *abfd, asection *sec);\n bfd_size_type bfd_convert_section_size\n    (bfd *ibfd, asection *isec, bfd *obfd, bfd_size_type size);\n \n-bfd_boolean bfd_convert_section_contents\n+bool bfd_convert_section_contents\n    (bfd *ibfd, asection *isec, bfd *obfd,\n     bfd_byte **ptr, bfd_size_type *ptr_size);\n \n /* Extracted from archive.c.  */\n symindex bfd_get_next_mapent\n    (bfd *abfd, symindex previous, carsym **sym);\n \n-bfd_boolean bfd_set_archive_head (bfd *output, bfd *new_head);\n+bool bfd_set_archive_head (bfd *output, bfd *new_head);\n \n bfd *bfd_openr_next_archived_file (bfd *archive, bfd *previous);\n \n@@ -7267,10 +7265,10 @@ int bfd_core_file_failing_signal (bfd *abfd);\n \n int bfd_core_file_pid (bfd *abfd);\n \n-bfd_boolean core_file_matches_executable_p\n+bool core_file_matches_executable_p\n    (bfd *core_bfd, bfd *exec_bfd);\n \n-bfd_boolean generic_core_file_matches_executable_p\n+bool generic_core_file_matches_executable_p\n    (bfd *core_bfd, bfd *exec_bfd);\n \n /* Extracted from targets.c.  */\n@@ -7297,7 +7295,7 @@ bfd_boolean generic_core_file_matches_executable_p\n \n /* Defined to TRUE if unused section symbol should be kept.  */\n #ifndef TARGET_KEEP_UNUSED_SECTION_SYMBOLS\n-#define TARGET_KEEP_UNUSED_SECTION_SYMBOLS TRUE\n+#define TARGET_KEEP_UNUSED_SECTION_SYMBOLS true\n #endif\n \n enum bfd_flavour\n@@ -7374,7 +7372,7 @@ typedef struct bfd_target\n   unsigned char match_priority;\n \n  /* TRUE if unused section symbols should be kept.  */\n-  bfd_boolean keep_unused_section_symbols;\n+  bool keep_unused_section_symbols;\n \n   /* Entries for byte swapping for data. These are different from the\n      other entry points, since they don't take a BFD as the first argument.\n@@ -7408,10 +7406,10 @@ typedef struct bfd_target\n   bfd_cleanup (*_bfd_check_format[bfd_type_end]) (bfd *);\n \n   /* Set the format of a file being written.  */\n-  bfd_boolean (*_bfd_set_format[bfd_type_end]) (bfd *);\n+  bool (*_bfd_set_format[bfd_type_end]) (bfd *);\n \n   /* Write cached information into a file being written, at <<bfd_close>>.  */\n-  bfd_boolean (*_bfd_write_contents[bfd_type_end]) (bfd *);\n+  bool (*_bfd_write_contents[bfd_type_end]) (bfd *);\n \n \n   /* Generic entry points.  */\n@@ -7423,17 +7421,16 @@ typedef struct bfd_target\n   NAME##_get_section_contents_in_window\n \n   /* Called when the BFD is being closed to do any necessary cleanup.  */\n-  bfd_boolean (*_close_and_cleanup) (bfd *);\n+  bool (*_close_and_cleanup) (bfd *);\n   /* Ask the BFD to free all cached information.  */\n-  bfd_boolean (*_bfd_free_cached_info) (bfd *);\n+  bool (*_bfd_free_cached_info) (bfd *);\n   /* Called when a new section is created.  */\n-  bfd_boolean (*_new_section_hook) (bfd *, sec_ptr);\n+  bool (*_new_section_hook) (bfd *, sec_ptr);\n   /* Read the contents of a section.  */\n-  bfd_boolean (*_bfd_get_section_contents) (bfd *, sec_ptr, void *, file_ptr,\n-                                            bfd_size_type);\n-  bfd_boolean (*_bfd_get_section_contents_in_window) (bfd *, sec_ptr,\n-                                                      bfd_window *, file_ptr,\n-                                                      bfd_size_type);\n+  bool (*_bfd_get_section_contents) (bfd *, sec_ptr, void *, file_ptr,\n+                                     bfd_size_type);\n+  bool (*_bfd_get_section_contents_in_window) (bfd *, sec_ptr, bfd_window *,\n+                                               file_ptr, bfd_size_type);\n \n   /* Entry points to copy private data.  */\n #define BFD_JUMP_TABLE_COPY(NAME) \\\n@@ -7448,34 +7445,32 @@ typedef struct bfd_target\n \n   /* Called to copy BFD general private data from one object file\n      to another.  */\n-  bfd_boolean (*_bfd_copy_private_bfd_data) (bfd *, bfd *);\n+  bool (*_bfd_copy_private_bfd_data) (bfd *, bfd *);\n   /* Called to merge BFD general private data from one object file\n      to a common output file when linking.  */\n-  bfd_boolean (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);\n+  bool (*_bfd_merge_private_bfd_data) (bfd *, struct bfd_link_info *);\n   /* Called to initialize BFD private section data from one object file\n      to another.  */\n #define bfd_init_private_section_data(ibfd, isec, obfd, osec, link_info) \\\n        BFD_SEND (obfd, _bfd_init_private_section_data, \\\n                  (ibfd, isec, obfd, osec, link_info))\n-  bfd_boolean (*_bfd_init_private_section_data) (bfd *, sec_ptr, bfd *,\n-                                                 sec_ptr,\n-                                                 struct bfd_link_info *);\n+  bool (*_bfd_init_private_section_data) (bfd *, sec_ptr, bfd *, sec_ptr,\n+                                          struct bfd_link_info *);\n   /* Called to copy BFD private section data from one object file\n      to another.  */\n-  bfd_boolean (*_bfd_copy_private_section_data) (bfd *, sec_ptr, bfd *,\n-                                                 sec_ptr);\n+  bool (*_bfd_copy_private_section_data) (bfd *, sec_ptr, bfd *, sec_ptr);\n   /* Called to copy BFD private symbol data from one symbol\n      to another.  */\n-  bfd_boolean (*_bfd_copy_private_symbol_data) (bfd *, asymbol *, bfd *,\n-                                                asymbol *);\n+  bool (*_bfd_copy_private_symbol_data) (bfd *, asymbol *,\n+                                         bfd *, asymbol *);\n   /* Called to copy BFD private header data from one object file\n      to another.  */\n-  bfd_boolean (*_bfd_copy_private_header_data) (bfd *, bfd *);\n+  bool (*_bfd_copy_private_header_data) (bfd *, bfd *);\n   /* Called to set private backend flags.  */\n-  bfd_boolean (*_bfd_set_private_flags) (bfd *, flagword);\n+  bool (*_bfd_set_private_flags) (bfd *, flagword);\n \n   /* Called to print private BFD data.  */\n-  bfd_boolean (*_bfd_print_private_bfd_data) (bfd *, void *);\n+  bool (*_bfd_print_private_bfd_data) (bfd *, void *);\n \n   /* Core file entry points.  */\n #define BFD_JUMP_TABLE_CORE(NAME) \\\n@@ -7484,10 +7479,10 @@ typedef struct bfd_target\n   NAME##_core_file_matches_executable_p, \\\n   NAME##_core_file_pid\n \n-  char *      (*_core_file_failing_command) (bfd *);\n-  int         (*_core_file_failing_signal) (bfd *);\n-  bfd_boolean (*_core_file_matches_executable_p) (bfd *, bfd *);\n-  int         (*_core_file_pid) (bfd *);\n+  char *(*_core_file_failing_command) (bfd *);\n+  int   (*_core_file_failing_signal) (bfd *);\n+  bool  (*_core_file_matches_executable_p) (bfd *, bfd *);\n+  int   (*_core_file_pid) (bfd *);\n \n   /* Archive entry points.  */\n #define BFD_JUMP_TABLE_ARCHIVE(NAME) \\\n@@ -7503,22 +7498,21 @@ typedef struct bfd_target\n   NAME##_generic_stat_arch_elt, \\\n   NAME##_update_armap_timestamp\n \n-  bfd_boolean (*_bfd_slurp_armap) (bfd *);\n-  bfd_boolean (*_bfd_slurp_extended_name_table) (bfd *);\n-  bfd_boolean (*_bfd_construct_extended_name_table) (bfd *, char **,\n-                                                     bfd_size_type *,\n-                                                     const char **);\n-  void        (*_bfd_truncate_arname) (bfd *, const char *, char *);\n-  bfd_boolean (*write_armap) (bfd *, unsigned int, struct orl *,\n-                              unsigned int, int);\n-  void *      (*_bfd_read_ar_hdr_fn) (bfd *);\n-  bfd_boolean (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);\n-  bfd *       (*openr_next_archived_file) (bfd *, bfd *);\n+  bool (*_bfd_slurp_armap) (bfd *);\n+  bool (*_bfd_slurp_extended_name_table) (bfd *);\n+  bool (*_bfd_construct_extended_name_table) (bfd *, char **,\n+                                              bfd_size_type *,\n+                                              const char **);\n+  void (*_bfd_truncate_arname) (bfd *, const char *, char *);\n+  bool (*write_armap) (bfd *, unsigned, struct orl *, unsigned, int);\n+  void *(*_bfd_read_ar_hdr_fn) (bfd *);\n+  bool (*_bfd_write_ar_hdr_fn) (bfd *, bfd *);\n+  bfd *(*openr_next_archived_file) (bfd *, bfd *);\n #define bfd_get_elt_at_index(b,i) \\\n        BFD_SEND (b, _bfd_get_elt_at_index, (b,i))\n-  bfd *       (*_bfd_get_elt_at_index) (bfd *, symindex);\n-  int         (*_bfd_stat_arch_elt) (bfd *, struct stat *);\n-  bfd_boolean (*_bfd_update_armap_timestamp) (bfd *);\n+  bfd *(*_bfd_get_elt_at_index) (bfd *, symindex);\n+  int  (*_bfd_stat_arch_elt) (bfd *, struct stat *);\n+  bool (*_bfd_update_armap_timestamp) (bfd *);\n \n   /* Entry points used for symbols.  */\n #define BFD_JUMP_TABLE_SYMBOLS(NAME) \\\n@@ -7538,47 +7532,47 @@ typedef struct bfd_target\n   NAME##_read_minisymbols, \\\n   NAME##_minisymbol_to_symbol\n \n-  long        (*_bfd_get_symtab_upper_bound) (bfd *);\n-  long        (*_bfd_canonicalize_symtab) (bfd *, struct bfd_symbol **);\n+  long (*_bfd_get_symtab_upper_bound) (bfd *);\n+  long (*_bfd_canonicalize_symtab) (bfd *, struct bfd_symbol **);\n   struct bfd_symbol *\n-              (*_bfd_make_empty_symbol) (bfd *);\n-  void        (*_bfd_print_symbol) (bfd *, void *, struct bfd_symbol *,\n-                                    bfd_print_symbol_type);\n+       (*_bfd_make_empty_symbol) (bfd *);\n+  void (*_bfd_print_symbol) (bfd *, void *, struct bfd_symbol *,\n+                             bfd_print_symbol_type);\n #define bfd_print_symbol(b,p,s,e) \\\n        BFD_SEND (b, _bfd_print_symbol, (b,p,s,e))\n-  void        (*_bfd_get_symbol_info) (bfd *, struct bfd_symbol *,\n-                                       symbol_info *);\n+  void  (*_bfd_get_symbol_info) (bfd *, struct bfd_symbol *, symbol_info *);\n #define bfd_get_symbol_info(b,p,e) \\\n        BFD_SEND (b, _bfd_get_symbol_info, (b,p,e))\n-  const char *(*_bfd_get_symbol_version_string) (bfd *, struct bfd_symbol *,\n-                                                 bfd_boolean,\n-                                                 bfd_boolean *);\n+  const char *\n+       (*_bfd_get_symbol_version_string) (bfd *, struct bfd_symbol *,\n+                                          bool, bool *);\n #define bfd_get_symbol_version_string(b,s,p,h) \\\n        BFD_SEND (b, _bfd_get_symbol_version_string, (b,s,p,h))\n-  bfd_boolean (*_bfd_is_local_label_name) (bfd *, const char *);\n-  bfd_boolean (*_bfd_is_target_special_symbol) (bfd *, asymbol *);\n-  alent *     (*_get_lineno) (bfd *, struct bfd_symbol *);\n-  bfd_boolean (*_bfd_find_nearest_line) (bfd *, struct bfd_symbol **,\n-                                         struct bfd_section *, bfd_vma,\n-                                         const char **, const char **,\n-                                         unsigned int *, unsigned int *);\n-  bfd_boolean (*_bfd_find_line) (bfd *, struct bfd_symbol **,\n-                                 struct bfd_symbol *, const char **,\n-                                 unsigned int *);\n-  bfd_boolean (*_bfd_find_inliner_info)\n+  bool (*_bfd_is_local_label_name) (bfd *, const char *);\n+  bool (*_bfd_is_target_special_symbol) (bfd *, asymbol *);\n+  alent *\n+       (*_get_lineno) (bfd *, struct bfd_symbol *);\n+  bool (*_bfd_find_nearest_line) (bfd *, struct bfd_symbol **,\n+                                  struct bfd_section *, bfd_vma,\n+                                  const char **, const char **,\n+                                  unsigned int *, unsigned int *);\n+  bool (*_bfd_find_line) (bfd *, struct bfd_symbol **,\n+                          struct bfd_symbol *, const char **,\n+                          unsigned int *);\n+  bool (*_bfd_find_inliner_info)\n     (bfd *, const char **, const char **, unsigned int *);\n  /* Back-door to allow format-aware applications to create debug symbols\n     while using BFD for everything else.  Currently used by the assembler\n     when creating COFF files.  */\n-  asymbol *   (*_bfd_make_debug_symbol) (bfd *, void *, unsigned long size);\n+  asymbol *\n+       (*_bfd_make_debug_symbol) (bfd *, void *, unsigned long size);\n #define bfd_read_minisymbols(b, d, m, s) \\\n        BFD_SEND (b, _read_minisymbols, (b, d, m, s))\n-  long        (*_read_minisymbols) (bfd *, bfd_boolean, void **,\n-                                    unsigned int *);\n+  long (*_read_minisymbols) (bfd *, bool, void **, unsigned int *);\n #define bfd_minisymbol_to_symbol(b, d, m, f) \\\n        BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))\n-  asymbol *   (*_minisymbol_to_symbol) (bfd *, bfd_boolean, const void *,\n-                                        asymbol *);\n+  asymbol *\n+       (*_minisymbol_to_symbol) (bfd *, bool, const void *, asymbol *);\n \n   /* Routines for relocs.  */\n #define BFD_JUMP_TABLE_RELOCS(NAME) \\\n@@ -7588,25 +7582,25 @@ typedef struct bfd_target\n   NAME##_bfd_reloc_type_lookup, \\\n   NAME##_bfd_reloc_name_lookup\n \n-  long        (*_get_reloc_upper_bound) (bfd *, sec_ptr);\n-  long        (*_bfd_canonicalize_reloc) (bfd *, sec_ptr, arelent **,\n-                                          struct bfd_symbol **);\n-  void        (*_bfd_set_reloc) (bfd *, sec_ptr, arelent **, unsigned int);\n+  long (*_get_reloc_upper_bound) (bfd *, sec_ptr);\n+  long (*_bfd_canonicalize_reloc) (bfd *, sec_ptr, arelent **,\n+                                   struct bfd_symbol **);\n+  void (*_bfd_set_reloc) (bfd *, sec_ptr, arelent **, unsigned int);\n   /* See documentation on reloc types.  */\n   reloc_howto_type *\n-              (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);\n+       (*reloc_type_lookup) (bfd *, bfd_reloc_code_real_type);\n   reloc_howto_type *\n-              (*reloc_name_lookup) (bfd *, const char *);\n+       (*reloc_name_lookup) (bfd *, const char *);\n \n   /* Routines used when writing an object file.  */\n #define BFD_JUMP_TABLE_WRITE(NAME) \\\n   NAME##_set_arch_mach, \\\n   NAME##_set_section_contents\n \n-  bfd_boolean (*_bfd_set_arch_mach) (bfd *, enum bfd_architecture,\n+  bool (*_bfd_set_arch_mach) (bfd *, enum bfd_architecture,\n                                      unsigned long);\n-  bfd_boolean (*_bfd_set_section_contents) (bfd *, sec_ptr, const void *,\n-                                            file_ptr, bfd_size_type);\n+  bool (*_bfd_set_section_contents) (bfd *, sec_ptr, const void *,\n+                                     file_ptr, bfd_size_type);\n \n   /* Routines used by the linker.  */\n #define BFD_JUMP_TABLE_LINK(NAME) \\\n@@ -7631,81 +7625,82 @@ typedef struct bfd_target\n   NAME##_bfd_link_hide_symbol, \\\n   NAME##_bfd_define_start_stop\n \n-  int         (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);\n-  bfd_byte *  (*_bfd_get_relocated_section_contents) (bfd *,\n-                                                      struct bfd_link_info *,\n-                                                      struct bfd_link_order *,\n-                                                      bfd_byte *, bfd_boolean,\n-                                                      struct bfd_symbol **);\n+  int  (*_bfd_sizeof_headers) (bfd *, struct bfd_link_info *);\n+  bfd_byte *\n+       (*_bfd_get_relocated_section_contents) (bfd *,\n+                                               struct bfd_link_info *,\n+                                               struct bfd_link_order *,\n+                                               bfd_byte *, bool,\n+                                               struct bfd_symbol **);\n \n-  bfd_boolean (*_bfd_relax_section) (bfd *, struct bfd_section *,\n-                                     struct bfd_link_info *, bfd_boolean *);\n+  bool (*_bfd_relax_section) (bfd *, struct bfd_section *,\n+                              struct bfd_link_info *, bool *);\n \n   /* Create a hash table for the linker.  Different backends store\n      different information in this table.  */\n   struct bfd_link_hash_table *\n-              (*_bfd_link_hash_table_create) (bfd *);\n+       (*_bfd_link_hash_table_create) (bfd *);\n \n   /* Add symbols from this object file into the hash table.  */\n-  bfd_boolean (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);\n+  bool (*_bfd_link_add_symbols) (bfd *, struct bfd_link_info *);\n \n   /* Indicate that we are only retrieving symbol values from this section.  */\n-  void        (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);\n+  void (*_bfd_link_just_syms) (asection *, struct bfd_link_info *);\n \n   /* Copy the symbol type and other attributes for a linker script\n      assignment of one symbol to another.  */\n #define bfd_copy_link_hash_symbol_type(b, t, f) \\\n        BFD_SEND (b, _bfd_copy_link_hash_symbol_type, (b, t, f))\n-  void        (*_bfd_copy_link_hash_symbol_type) (bfd *,\n-                                                  struct bfd_link_hash_entry *,\n-                                                  struct bfd_link_hash_entry *);\n+  void (*_bfd_copy_link_hash_symbol_type) (bfd *,\n+                                           struct bfd_link_hash_entry *,\n+                                           struct bfd_link_hash_entry *);\n \n   /* Do a link based on the link_order structures attached to each\n      section of the BFD.  */\n-  bfd_boolean (*_bfd_final_link) (bfd *, struct bfd_link_info *);\n+  bool (*_bfd_final_link) (bfd *, struct bfd_link_info *);\n \n   /* Should this section be split up into smaller pieces during linking.  */\n-  bfd_boolean (*_bfd_link_split_section) (bfd *, struct bfd_section *);\n+  bool (*_bfd_link_split_section) (bfd *, struct bfd_section *);\n \n   /* Check the relocations in the bfd for validity.  */\n-  bfd_boolean (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);\n+  bool (* _bfd_link_check_relocs)(bfd *, struct bfd_link_info *);\n \n   /* Remove sections that are not referenced from the output.  */\n-  bfd_boolean (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);\n+  bool (*_bfd_gc_sections) (bfd *, struct bfd_link_info *);\n \n   /* Sets the bitmask of allowed and disallowed section flags.  */\n-  bfd_boolean (*_bfd_lookup_section_flags) (struct bfd_link_info *,\n-                                            struct flag_info *, asection *);\n+  bool (*_bfd_lookup_section_flags) (struct bfd_link_info *,\n+                                     struct flag_info *, asection *);\n \n   /* Attempt to merge SEC_MERGE sections.  */\n-  bfd_boolean (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);\n+  bool (*_bfd_merge_sections) (bfd *, struct bfd_link_info *);\n \n   /* Is this section a member of a group?  */\n-  bfd_boolean (*_bfd_is_group_section) (bfd *, const struct bfd_section *);\n+  bool (*_bfd_is_group_section) (bfd *, const struct bfd_section *);\n \n   /* The group name, if section is a member of a group.  */\n   const char *(*_bfd_group_name) (bfd *, const struct bfd_section *);\n \n   /* Discard members of a group.  */\n-  bfd_boolean (*_bfd_discard_group) (bfd *, struct bfd_section *);\n+  bool (*_bfd_discard_group) (bfd *, struct bfd_section *);\n \n   /* Check if SEC has been already linked during a reloceatable or\n      final link.  */\n-  bfd_boolean (*_section_already_linked) (bfd *, asection *,\n-                                          struct bfd_link_info *);\n+  bool (*_section_already_linked) (bfd *, asection *,\n+                                   struct bfd_link_info *);\n \n   /* Define a common symbol.  */\n-  bfd_boolean (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,\n-                                            struct bfd_link_hash_entry *);\n+  bool (*_bfd_define_common_symbol) (bfd *, struct bfd_link_info *,\n+                                     struct bfd_link_hash_entry *);\n \n   /* Hide a symbol.  */\n   void (*_bfd_link_hide_symbol) (bfd *, struct bfd_link_info *,\n                                  struct bfd_link_hash_entry *);\n \n   /* Define a __start, __stop, .startof. or .sizeof. symbol.  */\n   struct bfd_link_hash_entry *\n-              (*_bfd_define_start_stop) (struct bfd_link_info *, const char *,\n-                                         asection *);\n+       (*_bfd_define_start_stop) (struct bfd_link_info *, const char *,\n+                                  asection *);\n \n   /* Routines to handle dynamic symbols and relocs.  */\n #define BFD_JUMP_TABLE_DYNAMIC(NAME) \\\n@@ -7716,18 +7711,18 @@ typedef struct bfd_target\n   NAME##_canonicalize_dynamic_reloc\n \n   /* Get the amount of memory required to hold the dynamic symbols.  */\n-  long        (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);\n+  long (*_bfd_get_dynamic_symtab_upper_bound) (bfd *);\n   /* Read in the dynamic symbols.  */\n-  long        (*_bfd_canonicalize_dynamic_symtab) (bfd *, struct bfd_symbol **);\n+  long (*_bfd_canonicalize_dynamic_symtab) (bfd *, struct bfd_symbol **);\n   /* Create synthetized symbols.  */\n-  long        (*_bfd_get_synthetic_symtab) (bfd *, long, struct bfd_symbol **,\n-                                            long, struct bfd_symbol **,\n-                                            struct bfd_symbol **);\n+  long (*_bfd_get_synthetic_symtab) (bfd *, long, struct bfd_symbol **,\n+                                     long, struct bfd_symbol **,\n+                                     struct bfd_symbol **);\n   /* Get the amount of memory required to hold the dynamic relocs.  */\n-  long        (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);\n+  long (*_bfd_get_dynamic_reloc_upper_bound) (bfd *);\n   /* Read in the dynamic relocs.  */\n-  long        (*_bfd_canonicalize_dynamic_reloc) (bfd *, arelent **,\n-                                                  struct bfd_symbol **);\n+  long (*_bfd_canonicalize_dynamic_reloc) (bfd *, arelent **,\n+                                           struct bfd_symbol **);\n \n   /* Opposite endian version of this target.  */\n   const struct bfd_target *alternative_target;\n@@ -7756,31 +7751,31 @@ bfd_applicable_file_flags (const bfd *abfd)\n   return abfd->xvec->object_flags;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_family_coff (const bfd *abfd)\n {\n   return (bfd_get_flavour (abfd) == bfd_target_coff_flavour\n           || bfd_get_flavour (abfd) == bfd_target_xcoff_flavour);\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_big_endian (const bfd *abfd)\n {\n   return abfd->xvec->byteorder == BFD_ENDIAN_BIG;\n }\n-static inline bfd_boolean\n+static inline bool\n bfd_little_endian (const bfd *abfd)\n {\n   return abfd->xvec->byteorder == BFD_ENDIAN_LITTLE;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_header_big_endian (const bfd *abfd)\n {\n   return abfd->xvec->header_byteorder == BFD_ENDIAN_BIG;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_header_little_endian (const bfd *abfd)\n {\n   return abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE;\n@@ -7806,19 +7801,19 @@ bfd_asymbol_flavour (const asymbol *sy)\n   return sy->the_bfd->xvec->flavour;\n }\n \n-static inline bfd_boolean\n+static inline bool\n bfd_keep_unused_section_symbols (const bfd *abfd)\n {\n   return abfd->xvec->keep_unused_section_symbols;\n }\n \n-bfd_boolean bfd_set_default_target (const char *name);\n+bool bfd_set_default_target (const char *name);\n \n const bfd_target *bfd_find_target (const char *target_name, bfd *abfd);\n \n const bfd_target *bfd_get_target_info (const char *target_name,\n     bfd *abfd,\n-    bfd_boolean *is_bigendian,\n+    bool *is_bigendian,\n     int *underscoring,\n     const char **def_target_arch);\n const char ** bfd_target_list (void);\n@@ -7830,12 +7825,12 @@ const bfd_target *bfd_iterate_over_targets\n const char *bfd_flavour_name (enum bfd_flavour flavour);\n \n /* Extracted from format.c.  */\n-bfd_boolean bfd_check_format (bfd *abfd, bfd_format format);\n+bool bfd_check_format (bfd *abfd, bfd_format format);\n \n-bfd_boolean bfd_check_format_matches\n+bool bfd_check_format_matches\n    (bfd *abfd, bfd_format format, char ***matching);\n \n-bfd_boolean bfd_set_format (bfd *abfd, bfd_format format);\n+bool bfd_set_format (bfd *abfd, bfd_format format);\n \n const char *bfd_format_string (bfd_format format);\n \n@@ -7851,19 +7846,19 @@ const char *bfd_format_string (bfd_format format);\n    && bfd_is_abs_section ((H)->u.def.section) \\\n    && !(H)->rel_from_abs)\n \n-bfd_boolean bfd_link_split_section (bfd *abfd, asection *sec);\n+bool bfd_link_split_section (bfd *abfd, asection *sec);\n \n #define bfd_link_split_section(abfd, sec) \\\n        BFD_SEND (abfd, _bfd_link_split_section, (abfd, sec))\n \n-bfd_boolean bfd_section_already_linked (bfd *abfd,\n+bool bfd_section_already_linked (bfd *abfd,\n     asection *sec,\n     struct bfd_link_info *info);\n \n #define bfd_section_already_linked(abfd, sec, info) \\\n        BFD_SEND (abfd, _section_already_linked, (abfd, sec, info))\n \n-bfd_boolean bfd_generic_define_common_symbol\n+bool bfd_generic_define_common_symbol\n    (bfd *output_bfd, struct bfd_link_info *info,\n     struct bfd_link_hash_entry *h);\n \n@@ -7886,18 +7881,18 @@ struct bfd_link_hash_entry *bfd_generic_define_start_stop\n \n struct bfd_elf_version_tree * bfd_find_version_for_sym\n    (struct bfd_elf_version_tree *verdefs,\n-    const char *sym_name, bfd_boolean *hide);\n+    const char *sym_name, bool *hide);\n \n-bfd_boolean bfd_hide_sym_by_version\n+bool bfd_hide_sym_by_version\n    (struct bfd_elf_version_tree *verdefs, const char *sym_name);\n \n-bfd_boolean bfd_link_check_relocs\n+bool bfd_link_check_relocs\n    (bfd *abfd, struct bfd_link_info *info);\n \n-bfd_boolean _bfd_generic_link_check_relocs\n+bool _bfd_generic_link_check_relocs\n    (bfd *abfd, struct bfd_link_info *info);\n \n-bfd_boolean bfd_merge_private_bfd_data\n+bool bfd_merge_private_bfd_data\n    (bfd *ibfd, struct bfd_link_info *info);\n \n #define bfd_merge_private_bfd_data(ibfd, info) \\\n@@ -7908,28 +7903,28 @@ bfd_byte *bfd_simple_get_relocated_section_contents\n    (bfd *abfd, asection *sec, bfd_byte *outbuf, asymbol **symbol_table);\n \n /* Extracted from compress.c.  */\n-bfd_boolean bfd_get_full_section_contents\n+bool bfd_get_full_section_contents\n    (bfd *abfd, asection *section, bfd_byte **ptr);\n \n void bfd_cache_section_contents\n    (asection *sec, void *contents);\n \n-bfd_boolean bfd_is_section_compressed_with_header\n+bool bfd_is_section_compressed_with_header\n    (bfd *abfd, asection *section,\n     int *compression_header_size_p,\n     bfd_size_type *uncompressed_size_p,\n     unsigned int *uncompressed_alignment_power_p);\n \n-bfd_boolean bfd_is_section_compressed\n+bool bfd_is_section_compressed\n    (bfd *abfd, asection *section);\n \n-bfd_boolean bfd_init_section_decompress_status\n+bool bfd_init_section_decompress_status\n    (bfd *abfd, asection *section);\n \n-bfd_boolean bfd_init_section_compress_status\n+bool bfd_init_section_compress_status\n    (bfd *abfd, asection *section);\n \n-bfd_boolean bfd_compress_section\n+bool bfd_compress_section\n    (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer);\n \n #ifdef __cplusplus"
    },
    {
      "sha": "abe50939e2495b280a6ba2b05ad49dd57a63641e",
      "filename": "bfd/bfd.c",
      "status": "modified",
      "additions": 59,
      "deletions": 59,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfd.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -372,7 +372,7 @@ CODE_FRAGMENT\n .  return abfd->filename;\n .}\n .\n-.static inline bfd_boolean\n+.static inline bool\n .bfd_get_cacheable (const bfd *abfd)\n .{\n .  return abfd->cacheable;\n@@ -420,13 +420,13 @@ CODE_FRAGMENT\n .  return abfd->section_count;\n .}\n .\n-.static inline bfd_boolean\n+.static inline bool\n .bfd_has_map (const bfd *abfd)\n .{\n .  return abfd->has_armap;\n .}\n .\n-.static inline bfd_boolean\n+.static inline bool\n .bfd_is_thin_archive (const bfd *abfd)\n .{\n .  return abfd->is_thin_archive;\n@@ -439,15 +439,15 @@ CODE_FRAGMENT\n .}\n .\n .{* See note beside bfd_set_section_userdata.  *}\n-.static inline bfd_boolean\n-.bfd_set_cacheable (bfd * abfd, bfd_boolean val)\n+.static inline bool\n+.bfd_set_cacheable (bfd * abfd, bool val)\n .{\n .  abfd->cacheable = val;\n-.  return TRUE;\n+.  return true;\n .}\n .\n .static inline void\n-.bfd_set_thin_archive (bfd *abfd, bfd_boolean val)\n+.bfd_set_thin_archive (bfd *abfd, bool val)\n .{\n .  abfd->is_thin_archive = val;\n .}\n@@ -582,7 +582,7 @@ CODE_FRAGMENT\n .    abfd->sections = s;\n .}\n .\n-.static inline bfd_boolean\n+.static inline bool\n .bfd_section_removed_from_list (const bfd *abfd, const asection *s)\n .{\n .  return s->next ? s->next->prev != s : abfd->section_last != s;\n@@ -1615,7 +1615,7 @@ FUNCTION\n \tbfd_set_file_flags\n \n SYNOPSIS\n-\tbfd_boolean bfd_set_file_flags (bfd *abfd, flagword flags);\n+\tbool bfd_set_file_flags (bfd *abfd, flagword flags);\n \n DESCRIPTION\n \tSet the flag word in the BFD @var{abfd} to the value @var{flags}.\n@@ -1630,29 +1630,29 @@ DESCRIPTION\n \n */\n \n-bfd_boolean\n+bool\n bfd_set_file_flags (bfd *abfd, flagword flags)\n {\n   if (abfd->format != bfd_object)\n     {\n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n     }\n \n   if (bfd_read_p (abfd))\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n   abfd->flags = flags;\n   if ((flags & bfd_applicable_file_flags (abfd)) != flags)\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n void\n@@ -1769,7 +1769,7 @@ FUNCTION\n \tbfd_set_start_address\n \n SYNOPSIS\n-\tbfd_boolean bfd_set_start_address (bfd *abfd, bfd_vma vma);\n+\tbool bfd_set_start_address (bfd *abfd, bfd_vma vma);\n \n DESCRIPTION\n \tMake @var{vma} the entry point of output BFD @var{abfd}.\n@@ -1778,11 +1778,11 @@ RETURNS\n \tReturns <<TRUE>> on success, <<FALSE>> otherwise.\n */\n \n-bfd_boolean\n+bool\n bfd_set_start_address (bfd *abfd, bfd_vma vma)\n {\n   abfd->start_address = vma;\n-  return TRUE;\n+  return true;\n }\n \n /*\n@@ -1970,7 +1970,7 @@ FUNCTION\n \tbfd_copy_private_header_data\n \n SYNOPSIS\n-\tbfd_boolean bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);\n+\tbool bfd_copy_private_header_data (bfd *ibfd, bfd *obfd);\n \n DESCRIPTION\n \tCopy private BFD header information from the BFD @var{ibfd} to the\n@@ -1993,7 +1993,7 @@ FUNCTION\n \tbfd_copy_private_bfd_data\n \n SYNOPSIS\n-\tbfd_boolean bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);\n+\tbool bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd);\n \n DESCRIPTION\n \tCopy private BFD information from the BFD @var{ibfd} to the\n@@ -2014,7 +2014,7 @@ FUNCTION\n \tbfd_set_private_flags\n \n SYNOPSIS\n-\tbfd_boolean bfd_set_private_flags (bfd *abfd, flagword flags);\n+\tbool bfd_set_private_flags (bfd *abfd, flagword flags);\n \n DESCRIPTION\n \tSet private BFD flag information in the BFD @var{abfd}.\n@@ -2132,7 +2132,7 @@ DESCRIPTION\n .\n .extern bfd_byte *bfd_get_relocated_section_contents\n .  (bfd *, struct bfd_link_info *, struct bfd_link_order *, bfd_byte *,\n-.   bfd_boolean, asymbol **);\n+.   bool, asymbol **);\n .\n \n */\n@@ -2142,12 +2142,12 @@ bfd_get_relocated_section_contents (bfd *abfd,\n \t\t\t\t    struct bfd_link_info *link_info,\n \t\t\t\t    struct bfd_link_order *link_order,\n \t\t\t\t    bfd_byte *data,\n-\t\t\t\t    bfd_boolean relocatable,\n+\t\t\t\t    bool relocatable,\n \t\t\t\t    asymbol **symbols)\n {\n   bfd *abfd2;\n   bfd_byte *(*fn) (bfd *, struct bfd_link_info *, struct bfd_link_order *,\n-\t\t   bfd_byte *, bfd_boolean, asymbol **);\n+\t\t   bfd_byte *, bool, asymbol **);\n \n   if (link_order->type == bfd_indirect_link_order)\n     {\n@@ -2165,15 +2165,15 @@ bfd_get_relocated_section_contents (bfd *abfd,\n \n /* Record information about an ELF program header.  */\n \n-bfd_boolean\n+bool\n bfd_record_phdr (bfd *abfd,\n \t\t unsigned long type,\n-\t\t bfd_boolean flags_valid,\n+\t\t bool flags_valid,\n \t\t flagword flags,\n-\t\t bfd_boolean at_valid,\n+\t\t bool at_valid,\n \t\t bfd_vma at,  /* Bytes.  */\n-\t\t bfd_boolean includes_filehdr,\n-\t\t bfd_boolean includes_phdrs,\n+\t\t bool includes_filehdr,\n+\t\t bool includes_phdrs,\n \t\t unsigned int count,\n \t\t asection **secs)\n {\n@@ -2182,13 +2182,13 @@ bfd_record_phdr (bfd *abfd,\n   unsigned int opb = bfd_octets_per_byte (abfd, NULL);\n \n   if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)\n-    return TRUE;\n+    return true;\n \n   amt = sizeof (struct elf_segment_map);\n   amt += ((bfd_size_type) count - 1) * sizeof (asection *);\n   m = (struct elf_segment_map *) bfd_zalloc (abfd, amt);\n   if (m == NULL)\n-    return FALSE;\n+    return false;\n \n   m->p_type = type;\n   m->p_flags = flags;\n@@ -2205,13 +2205,13 @@ bfd_record_phdr (bfd *abfd,\n     ;\n   *pm = m;\n \n-  return TRUE;\n+  return true;\n }\n \n #ifdef BFD64\n /* Return true iff this target is 32-bit.  */\n \n-static bfd_boolean\n+static bool\n is32bit (bfd *abfd)\n {\n   if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n@@ -2259,7 +2259,7 @@ FUNCTION\n \tbfd_alt_mach_code\n \n SYNOPSIS\n-\tbfd_boolean bfd_alt_mach_code (bfd *abfd, int alternative);\n+\tbool bfd_alt_mach_code (bfd *abfd, int alternative);\n \n DESCRIPTION\n \n@@ -2270,7 +2270,7 @@ DESCRIPTION\n \tmachine codes.\n */\n \n-bfd_boolean\n+bool\n bfd_alt_mach_code (bfd *abfd, int alternative)\n {\n   if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)\n@@ -2286,25 +2286,25 @@ bfd_alt_mach_code (bfd *abfd, int alternative)\n \tcase 1:\n \t  code = get_elf_backend_data (abfd)->elf_machine_alt1;\n \t  if (code == 0)\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \n \tcase 2:\n \t  code = get_elf_backend_data (abfd)->elf_machine_alt2;\n \t  if (code == 0)\n-\t    return FALSE;\n+\t    return false;\n \t  break;\n \n \tdefault:\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       elf_elfheader (abfd)->e_machine = code;\n \n-      return TRUE;\n+      return true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /*\n@@ -2340,7 +2340,7 @@ FUNCTION\n \tbfd_emul_get_commonpagesize\n \n SYNOPSIS\n-\tbfd_vma bfd_emul_get_commonpagesize (const char *, bfd_boolean);\n+\tbfd_vma bfd_emul_get_commonpagesize (const char *, bool);\n \n DESCRIPTION\n \tReturns the common page size, in bytes, as determined by\n@@ -2351,7 +2351,7 @@ RETURNS\n */\n \n bfd_vma\n-bfd_emul_get_commonpagesize (const char *emul, bfd_boolean relro)\n+bfd_emul_get_commonpagesize (const char *emul, bool relro)\n {\n   const bfd_target *target;\n \n@@ -2391,7 +2391,7 @@ bfd_demangle (bfd *abfd, const char *name, int options)\n   char *res, *alloc;\n   const char *pre, *suf;\n   size_t pre_len;\n-  bfd_boolean skip_lead;\n+  bool skip_lead;\n \n   skip_lead = (abfd != NULL\n \t       && *name != '\\0'\n@@ -2542,7 +2542,7 @@ bfd_update_compression_header (bfd *abfd, bfd_byte *contents,\n    bfd_check_compression_header\n \n    SYNOPSIS\n-\tbfd_boolean bfd_check_compression_header\n+\tbool bfd_check_compression_header\n \t  (bfd *abfd, bfd_byte *contents, asection *sec,\n \t  bfd_size_type *uncompressed_size,\n \t  unsigned int *uncompressed_alignment_power);\n@@ -2557,7 +2557,7 @@ RETURNS\n \tReturn TRUE if the compression header is valid.\n */\n \n-bfd_boolean\n+bool\n bfd_check_compression_header (bfd *abfd, bfd_byte *contents,\n \t\t\t      asection *sec,\n \t\t\t      bfd_size_type *uncompressed_size,\n@@ -2587,11 +2587,11 @@ bfd_check_compression_header (bfd *abfd, bfd_byte *contents,\n \t{\n \t  *uncompressed_size = chdr.ch_size;\n \t  *uncompressed_alignment_power = bfd_log2 (chdr.ch_addralign);\n-\t  return TRUE;\n+\t  return true;\n \t}\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n /*\n@@ -2686,7 +2686,7 @@ FUNCTION\n \tbfd_convert_section_contents\n \n SYNOPSIS\n-\tbfd_boolean bfd_convert_section_contents\n+\tbool bfd_convert_section_contents\n \t  (bfd *ibfd, asection *isec, bfd *obfd,\n \t   bfd_byte **ptr, bfd_size_type *ptr_size);\n \n@@ -2698,24 +2698,24 @@ DESCRIPTION\n \tfunction, and the new size written to @var{ptr_size}.\n */\n \n-bfd_boolean\n+bool\n bfd_convert_section_contents (bfd *ibfd, sec_ptr isec, bfd *obfd,\n \t\t\t      bfd_byte **ptr, bfd_size_type *ptr_size)\n {\n   bfd_byte *contents;\n   bfd_size_type ihdr_size, ohdr_size, size;\n   Elf_Internal_Chdr chdr;\n-  bfd_boolean use_memmove;\n+  bool use_memmove;\n \n   /* Do nothing if either input or output aren't ELF.  */\n   if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour\n       || bfd_get_flavour (obfd) != bfd_target_elf_flavour)\n-    return TRUE;\n+    return true;\n \n   /* Do nothing if ELF classes of input and output are the same.  */\n   if (get_elf_backend_data (ibfd)->s->elfclass\n       == get_elf_backend_data (obfd)->s->elfclass)\n-    return TRUE;\n+    return true;\n \n   /* Convert GNU properties.  */\n   if (startswith (isec->name, NOTE_GNU_PROPERTY_SECTION_NAME))\n@@ -2724,18 +2724,18 @@ bfd_convert_section_contents (bfd *ibfd, sec_ptr isec, bfd *obfd,\n \n   /* Do nothing if input file will be decompressed.  */\n   if ((ibfd->flags & BFD_DECOMPRESS))\n-    return TRUE;\n+    return true;\n \n   /* Do nothing if the input section isn't a SHF_COMPRESSED section.  */\n   ihdr_size = bfd_get_compression_header_size (ibfd, isec);\n   if (ihdr_size == 0)\n-    return TRUE;\n+    return true;\n \n   /* PR 25221.  Check for corrupt input sections.  */\n   if (ihdr_size > bfd_get_section_limit (ibfd, isec))\n     /* FIXME: Issue a warning about a corrupt\n        compression header size field ?  */\n-    return FALSE;\n+    return false;\n \n   contents = *ptr;\n \n@@ -2751,13 +2751,13 @@ bfd_convert_section_contents (bfd *ibfd, sec_ptr isec, bfd *obfd,\n \n       ohdr_size = sizeof (Elf64_External_Chdr);\n \n-      use_memmove = FALSE;\n+      use_memmove = false;\n     }\n   else if (ihdr_size != sizeof (Elf64_External_Chdr))\n     {\n       /* FIXME: Issue a warning about a corrupt\n \t compression header size field ?  */\n-      return FALSE;\n+      return false;\n     }\n   else\n     {\n@@ -2767,15 +2767,15 @@ bfd_convert_section_contents (bfd *ibfd, sec_ptr isec, bfd *obfd,\n       chdr.ch_addralign = bfd_get_64 (ibfd, &echdr->ch_addralign);\n \n       ohdr_size = sizeof (Elf32_External_Chdr);\n-      use_memmove = TRUE;\n+      use_memmove = true;\n     }\n \n   size = bfd_section_size (isec) - ihdr_size + ohdr_size;\n   if (!use_memmove)\n     {\n       contents = (bfd_byte *) bfd_malloc (size);\n       if (contents == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Write out the output compression header.  */\n@@ -2806,7 +2806,7 @@ bfd_convert_section_contents (bfd *ibfd, sec_ptr isec, bfd *obfd,\n     }\n \n   *ptr_size = size;\n-  return TRUE;\n+  return true;\n }\n \n /* Get the linker information.  */"
    },
    {
      "sha": "be4682b2f5f572caf0a4c85e0feb1b4eac234e35",
      "filename": "bfd/bfdwin.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/bfdwin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/bfdwin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/bfdwin.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -104,12 +104,12 @@ bfd_free_window (bfd_window *windowp)\n \n static int ok_to_map = 1;\n \n-bfd_boolean\n+bool\n bfd_get_file_window (bfd *abfd,\n \t\t     file_ptr offset,\n \t\t     bfd_size_type size,\n \t\t     bfd_window *windowp,\n-\t\t     bfd_boolean writable)\n+\t\t     bool writable)\n {\n   static size_t pagesize;\n   bfd_window_internal *i = windowp->i;\n@@ -131,7 +131,7 @@ bfd_get_file_window (bfd *abfd,\n     {\n       i = bfd_zmalloc (sizeof (bfd_window_internal));\n       if (i == NULL)\n-\treturn FALSE;\n+\treturn false;\n       i->data = NULL;\n     }\n #ifdef HAVE_MMAP\n@@ -199,7 +199,7 @@ bfd_get_file_window (bfd *abfd,\n       i->mapped = 1;\n       i->refcount = 1;\n       windowp->i = i;\n-      return TRUE;\n+      return true;\n     }\n   else if (debug_windows)\n     {\n@@ -231,7 +231,7 @@ bfd_get_file_window (bfd *abfd,\n       if (size_to_alloc == 0)\n \t{\n \t  windowp->i = i;\n-\t  return TRUE;\n+\t  return true;\n \t}\n       goto free_and_fail;\n     }\n@@ -254,12 +254,12 @@ bfd_get_file_window (bfd *abfd,\n   windowp->data = i->data;\n   windowp->size = i->size;\n   windowp->i = i;\n-  return TRUE;\n+  return true;\n \n  free_and_fail:\n   /* We have a bfd_window_internal, but an error occurred.  Free it. */\n   free (i);\n-  return FALSE;\n+  return false;\n }\n \n #endif /* USE_MMAP */"
    },
    {
      "sha": "0761a0ba8998bb272ec514189f4b42ef80cdacb1",
      "filename": "bfd/binary.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/binary.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/binary.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/binary.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -43,10 +43,10 @@\n \n /* Create a binary object.  Invoked via bfd_set_format.  */\n \n-static bfd_boolean\n+static bool\n binary_mkobject (bfd *abfd ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n /* Any file may be considered to be a binary file, provided the target\n@@ -95,7 +95,7 @@ binary_object_p (bfd *abfd)\n \n /* Get contents of the only section.  */\n \n-static bfd_boolean\n+static bool\n binary_get_section_contents (bfd *abfd,\n \t\t\t     asection *section,\n \t\t\t     void * location,\n@@ -104,8 +104,8 @@ binary_get_section_contents (bfd *abfd,\n {\n   if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0\n       || bfd_bread (location, count, abfd) != count)\n-    return FALSE;\n-  return TRUE;\n+    return false;\n+  return true;\n }\n \n /* Return the amount of memory needed to read the symbol table.  */\n@@ -218,26 +218,26 @@ binary_get_symbol_info (bfd *ignore_abfd ATTRIBUTE_UNUSED,\n \n /* Write section contents of a binary file.  */\n \n-static bfd_boolean\n+static bool\n binary_set_section_contents (bfd *abfd,\n \t\t\t     asection *sec,\n \t\t\t     const void * data,\n \t\t\t     file_ptr offset,\n \t\t\t     bfd_size_type size)\n {\n   if (size == 0)\n-    return TRUE;\n+    return true;\n \n   if (! abfd->output_has_begun)\n     {\n-      bfd_boolean found_low;\n+      bool found_low;\n       bfd_vma low;\n       asection *s;\n \n       /* The lowest section LMA sets the virtual address of the start\n \t of the file.  We use this to set the file position of all the\n \t sections.  */\n-      found_low = FALSE;\n+      found_low = false;\n       low = 0;\n       for (s = abfd->sections; s != NULL; s = s->next)\n \tif (((s->flags\n@@ -247,7 +247,7 @@ binary_set_section_contents (bfd *abfd,\n \t    && (! found_low || s->lma < low))\n \t  {\n \t    low = s->lma;\n-\t    found_low = TRUE;\n+\t    found_low = true;\n \t  }\n \n       for (s = abfd->sections; s != NULL; s = s->next)\n@@ -278,16 +278,16 @@ binary_set_section_contents (bfd *abfd,\n \t       s);\n \t}\n \n-      abfd->output_has_begun = TRUE;\n+      abfd->output_has_begun = true;\n     }\n \n   /* We don't want to output anything for a section that is neither\n      loaded nor allocated.  The contents of such a section are not\n      meaningful in the binary format.  */\n   if ((sec->flags & (SEC_LOAD | SEC_ALLOC)) == 0)\n-    return TRUE;\n+    return true;\n   if ((sec->flags & SEC_NEVER_LOAD) != 0)\n-    return TRUE;\n+    return true;\n \n   return _bfd_generic_set_section_contents (abfd, sec, data, offset, size);\n }"
    },
    {
      "sha": "1935359c6e38de3acb316982cb1e9d55c8916108",
      "filename": "bfd/cache.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cache.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cache.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cache.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -160,16 +160,16 @@ snip (bfd *abfd)\n \n /* Close a BFD and remove it from the cache.  */\n \n-static bfd_boolean\n+static bool\n bfd_cache_delete (bfd *abfd)\n {\n-  bfd_boolean ret;\n+  bool ret;\n \n   if (fclose ((FILE *) abfd->iostream) == 0)\n-    ret = TRUE;\n+    ret = true;\n   else\n     {\n-      ret = FALSE;\n+      ret = false;\n       bfd_set_error (bfd_error_system_call);\n     }\n \n@@ -184,7 +184,7 @@ bfd_cache_delete (bfd *abfd)\n /* We need to open a new file, and the cache is full.  Find the least\n    recently used cacheable BFD and close it.  */\n \n-static bfd_boolean\n+static bool\n close_one (void)\n {\n   register bfd *to_kill;\n@@ -208,7 +208,7 @@ close_one (void)\n   if (to_kill == NULL)\n     {\n       /* There are no open cacheable BFD's.  */\n-      return TRUE;\n+      return true;\n     }\n \n   to_kill->where = _bfd_real_ftell ((FILE *) to_kill->iostream);\n@@ -485,33 +485,33 @@ INTERNAL_FUNCTION\n \tbfd_cache_init\n \n SYNOPSIS\n-\tbfd_boolean bfd_cache_init (bfd *abfd);\n+\tbool bfd_cache_init (bfd *abfd);\n \n DESCRIPTION\n \tAdd a newly opened BFD to the cache.\n */\n \n-bfd_boolean\n+bool\n bfd_cache_init (bfd *abfd)\n {\n   BFD_ASSERT (abfd->iostream != NULL);\n   if (open_files >= bfd_cache_max_open ())\n     {\n       if (! close_one ())\n-\treturn FALSE;\n+\treturn false;\n     }\n   abfd->iovec = &cache_iovec;\n   insert (abfd);\n   ++open_files;\n-  return TRUE;\n+  return true;\n }\n \n /*\n INTERNAL_FUNCTION\n \tbfd_cache_close\n \n SYNOPSIS\n-\tbfd_boolean bfd_cache_close (bfd *abfd);\n+\tbool bfd_cache_close (bfd *abfd);\n \n DESCRIPTION\n \tRemove the BFD @var{abfd} from the cache. If the attached file is open,\n@@ -522,15 +522,15 @@ RETURNS\n \treturned if all is well.\n */\n \n-bfd_boolean\n+bool\n bfd_cache_close (bfd *abfd)\n {\n   if (abfd->iovec != &cache_iovec)\n-    return TRUE;\n+    return true;\n \n   if (abfd->iostream == NULL)\n     /* Previously closed.  */\n-    return TRUE;\n+    return true;\n \n   return bfd_cache_delete (abfd);\n }\n@@ -540,7 +540,7 @@ FUNCTION\n \tbfd_cache_close_all\n \n SYNOPSIS\n-\tbfd_boolean bfd_cache_close_all (void);\n+\tbool bfd_cache_close_all (void);\n \n DESCRIPTION\n \tRemove all BFDs from the cache. If the attached file is open,\n@@ -551,10 +551,10 @@ RETURNS\n \treturned if all is well.\n */\n \n-bfd_boolean\n+bool\n bfd_cache_close_all (void)\n {\n-  bfd_boolean ret = TRUE;\n+  bool ret = true;\n \n   while (bfd_last_cache != NULL)\n     ret &= bfd_cache_close (bfd_last_cache);\n@@ -580,7 +580,7 @@ DESCRIPTION\n FILE *\n bfd_open_file (bfd *abfd)\n {\n-  abfd->cacheable = TRUE;\t/* Allow it to be closed later.  */\n+  abfd->cacheable = true;\t/* Allow it to be closed later.  */\n \n   if (open_files >= bfd_cache_max_open ())\n     {\n@@ -634,7 +634,7 @@ bfd_open_file (bfd *abfd)\n #endif\n \t  abfd->iostream = _bfd_real_fopen (bfd_get_filename (abfd),\n \t\t\t\t\t    FOPEN_WUB);\n-\t  abfd->opened_once = TRUE;\n+\t  abfd->opened_once = true;\n \t}\n       break;\n     }"
    },
    {
      "sha": "15fea1fde34ff7df9d9380ac73fd6118b64bb7fd",
      "filename": "bfd/coff-alpha.c",
      "status": "modified",
      "additions": 92,
      "deletions": 92,
      "changes": 184,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-alpha.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -118,45 +118,45 @@ static reloc_howto_type alpha_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t reloc_nil,\t\t/* special_function */\n \t \"IGNORE\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   /* A 32 bit reference to a symbol.  */\n   HOWTO (ALPHA_R_REFLONG,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"REFLONG\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A 64 bit reference to a symbol.  */\n   HOWTO (ALPHA_R_REFQUAD,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"REFQUAD\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A 32 bit GP relative offset.  This is just like REFLONG except\n      that when the value is used the value of the gp register will be\n@@ -165,15 +165,15 @@ static reloc_howto_type alpha_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"GPREL32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* Used for an instruction that refers to memory off the GP\n      register.  The offset is 16 bits of the 32 bit instruction.  This\n@@ -182,15 +182,15 @@ static reloc_howto_type alpha_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"LITERAL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* This reloc only appears immediately following a LITERAL reloc.\n      It identifies a use of the literal.  It seems that the linker can\n@@ -205,15 +205,15 @@ static reloc_howto_type alpha_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t reloc_nil,\t\t/* special_function */\n \t \"LITUSE\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* Load the gp register.  This is always used for a ldah instruction\n      which loads the upper 16 bits of the gp register.  The next reloc\n@@ -230,15 +230,15 @@ static reloc_howto_type alpha_howto_table[] =\n \t 16,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t reloc_nil,\t\t/* special_function */\n \t \"GPDISP\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   /* A 21 bit branch.  The native assembler generates these for\n      branches within the text segment, and also fills in the PC\n@@ -247,153 +247,153 @@ static reloc_howto_type alpha_howto_table[] =\n \t 2,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 21,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"BRADDR\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x1fffff,\t\t/* src_mask */\n \t 0x1fffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A hint for a jump to a register.  */\n   HOWTO (ALPHA_R_HINT,\t\t/* type */\n \t 2,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 14,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"HINT\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x3fff,\t\t/* src_mask */\n \t 0x3fff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 16 bit PC relative offset.  */\n   HOWTO (ALPHA_R_SREL16,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"SREL16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 32 bit PC relative offset.  */\n   HOWTO (ALPHA_R_SREL32,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"SREL32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A 64 bit PC relative offset.  */\n   HOWTO (ALPHA_R_SREL64,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"SREL64\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* Push a value on the reloc evaluation stack.  */\n   HOWTO (ALPHA_R_OP_PUSH,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 0,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"OP_PUSH\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* Store the value from the stack at the given address.  Store it in\n      a bitfield of size r_size starting at bit position r_offset.  */\n   HOWTO (ALPHA_R_OP_STORE,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"OP_STORE\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* Subtract the reloc address from the value on the top of the\n      relocation stack.  */\n   HOWTO (ALPHA_R_OP_PSUB,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 0,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"OP_PSUB\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* Shift the value on the top of the relocation stack right by the\n      given value.  */\n   HOWTO (ALPHA_R_OP_PRSHIFT,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 0,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"OP_PRSHIFT\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* Adjust the GP value for a new range in the object file.  */\n   HOWTO (ALPHA_R_GPVALUE,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 0,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"GPVALUE\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t FALSE)\t\t\t/* pcrel_offset */\n+\t false)\t\t\t/* pcrel_offset */\n };\n \f\n /* Recognize an Alpha ECOFF file.  */\n@@ -436,22 +436,22 @@ alpha_ecoff_object_p (bfd *abfd)\n \n /* See whether the magic number matches.  */\n \n-static bfd_boolean\n+static bool\n alpha_ecoff_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t     void * filehdr)\n {\n   struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;\n \n   if (! ALPHA_ECOFF_BADMAG (*internal_f))\n-    return TRUE;\n+    return true;\n \n   if (ALPHA_ECOFF_COMPRESSEDMAG (*internal_f))\n     _bfd_error_handler\n       (_(\"%pB: cannot handle compressed Alpha binaries; \"\n \t \"use compiler flags, or objZ, to generate uncompressed binaries\"),\n        abfd);\n \n-  return FALSE;\n+  return false;\n }\n \n /* This is a hook called by coff_real_object_p to create any backend\n@@ -727,7 +727,7 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,\n \t\t\t\t\t    struct bfd_link_info *link_info,\n \t\t\t\t\t    struct bfd_link_order *link_order,\n \t\t\t\t\t    bfd_byte *data,\n-\t\t\t\t\t    bfd_boolean relocatable,\n+\t\t\t\t\t    bool relocatable,\n \t\t\t\t\t    asymbol **symbols)\n {\n   bfd *input_bfd = link_order->u.indirect.section->owner;\n@@ -737,7 +737,7 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,\n   long reloc_count;\n   bfd *output_bfd = relocatable ? abfd : (bfd *) NULL;\n   bfd_vma gp;\n-  bfd_boolean gp_undefined;\n+  bool gp_undefined;\n   bfd_vma stack[RELOC_STACKSIZE];\n   int tos = 0;\n \n@@ -766,7 +766,7 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,\n     goto successful_return;\n \n   /* Get the GP value for the output BFD.  */\n-  gp_undefined = FALSE;\n+  gp_undefined = false;\n   gp = _bfd_get_gp_value (abfd);\n   if (gp == 0)\n     {\n@@ -794,11 +794,11 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,\n \t{\n \t  struct bfd_link_hash_entry *h;\n \n-\t  h = bfd_link_hash_lookup (link_info->hash, \"_gp\", FALSE, FALSE,\n-\t\t\t\t    TRUE);\n+\t  h = bfd_link_hash_lookup (link_info->hash, \"_gp\", false, false,\n+\t\t\t\t    true);\n \t  if (h == (struct bfd_link_hash_entry *) NULL\n \t      || h->type != bfd_link_hash_defined)\n-\t    gp_undefined = TRUE;\n+\t    gp_undefined = true;\n \t  else\n \t    {\n \t      gp = (h->u.def.value\n@@ -1086,7 +1086,7 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,\n \tcase ALPHA_R_GPVALUE:\n \t  /* I really don't know if this does the right thing.  */\n \t  gp = rel->addend;\n-\t  gp_undefined = FALSE;\n+\t  gp_undefined = false;\n \t  break;\n \n \tdefault:\n@@ -1109,7 +1109,7 @@ alpha_ecoff_get_relocated_section_contents (bfd *abfd,\n \t    case bfd_reloc_undefined:\n \t      (*link_info->callbacks->undefined_symbol)\n \t\t(link_info, bfd_asymbol_name (*rel->sym_ptr_ptr),\n-\t\t input_bfd, input_section, rel->address, TRUE);\n+\t\t input_bfd, input_section, rel->address, true);\n \t      break;\n \t    case bfd_reloc_dangerous:\n \t      (*link_info->callbacks->reloc_dangerous)\n@@ -1331,7 +1331,7 @@ alpha_convert_external_reloc (bfd *output_bfd ATTRIBUTE_UNUSED,\n    quite similar to get_relocated_section_contents.  Perhaps they\n    could be combined somehow.  */\n \n-static bfd_boolean\n+static bool\n alpha_relocate_section (bfd *output_bfd,\n \t\t\tstruct bfd_link_info *info,\n \t\t\tbfd *input_bfd,\n@@ -1342,7 +1342,7 @@ alpha_relocate_section (bfd *output_bfd,\n   asection **symndx_to_section, *lita_sec;\n   struct ecoff_link_hash_entry **sym_hashes;\n   bfd_vma gp;\n-  bfd_boolean gp_undefined;\n+  bool gp_undefined;\n   bfd_vma stack[RELOC_STACKSIZE];\n   int tos = 0;\n   struct external_reloc *ext_rel;\n@@ -1358,7 +1358,7 @@ alpha_relocate_section (bfd *output_bfd,\n       amt = NUM_RELOC_SECTIONS * sizeof (asection *);\n       symndx_to_section = (asection **) bfd_alloc (input_bfd, amt);\n       if (!symndx_to_section)\n-\treturn FALSE;\n+\treturn false;\n \n       symndx_to_section[RELOC_SECTION_NONE] = NULL;\n       symndx_to_section[RELOC_SECTION_TEXT] =\n@@ -1447,7 +1447,7 @@ alpha_relocate_section (bfd *output_bfd,\n \t\t\t\t\t       _(\"using multiple gp values\"),\n \t\t\t\t\t       (char *) NULL, output_bfd,\n \t\t\t\t\t       (asection *) NULL, (bfd_vma) 0);\n-\t\t  ecoff_data (output_bfd)->issued_multiple_gp_warning = TRUE;\n+\t\t  ecoff_data (output_bfd)->issued_multiple_gp_warning = true;\n \t\t}\n \t      if (lita_vma < gp - 0x8000)\n \t\tgp = lita_vma + lita_size - 0x8000;\n@@ -1477,9 +1477,9 @@ alpha_relocate_section (bfd *output_bfd,\n       int r_extern;\n       int r_offset;\n       int r_size;\n-      bfd_boolean relocatep;\n-      bfd_boolean adjust_addrp;\n-      bfd_boolean gp_usedp;\n+      bool relocatep;\n+      bool adjust_addrp;\n+      bool gp_usedp;\n       bfd_vma addend;\n \n       r_vaddr = H_GET_64 (input_bfd, ext_rel->r_vaddr);\n@@ -1494,9 +1494,9 @@ alpha_relocate_section (bfd *output_bfd,\n       r_size = ((ext_rel->r_bits[3] & RELOC_BITS3_SIZE_LITTLE)\n \t\t>> RELOC_BITS3_SIZE_SH_LITTLE);\n \n-      relocatep = FALSE;\n-      adjust_addrp = TRUE;\n-      gp_usedp = FALSE;\n+      relocatep = false;\n+      adjust_addrp = true;\n+      gp_usedp = false;\n       addend = 0;\n \n       switch (r_type)\n@@ -1530,13 +1530,13 @@ alpha_relocate_section (bfd *output_bfd,\n \t  if (bfd_link_relocatable (info))\n \t    H_PUT_64 (input_bfd, input_section->output_offset + r_vaddr,\n \t\t      ext_rel->r_vaddr);\n-\t  adjust_addrp = FALSE;\n+\t  adjust_addrp = false;\n \t  break;\n \n \tcase ALPHA_R_REFLONG:\n \tcase ALPHA_R_REFQUAD:\n \tcase ALPHA_R_HINT:\n-\t  relocatep = TRUE;\n+\t  relocatep = true;\n \t  break;\n \n \tcase ALPHA_R_BRADDR:\n@@ -1545,17 +1545,17 @@ alpha_relocate_section (bfd *output_bfd,\n \tcase ALPHA_R_SREL64:\n \t  if (r_extern)\n \t    addend += - (r_vaddr + 4);\n-\t  relocatep = TRUE;\n+\t  relocatep = true;\n \t  break;\n \n \tcase ALPHA_R_GPREL32:\n \t  /* This relocation is used in a switch table.  It is a 32\n \t     bit offset from the current GP value.  We must adjust it\n \t     by the different between the original GP value and the\n \t     current GP value.  */\n-\t  relocatep = TRUE;\n+\t  relocatep = true;\n \t  addend = ecoff_data (input_bfd)->gp - gp;\n-\t  gp_usedp = TRUE;\n+\t  gp_usedp = true;\n \t  break;\n \n \tcase ALPHA_R_LITERAL:\n@@ -1586,9 +1586,9 @@ alpha_relocate_section (bfd *output_bfd,\n \t\t\t|| ((insn >> 26) & 0x3f) == 0x28);\n \t  }\n \n-\t  relocatep = TRUE;\n+\t  relocatep = true;\n \t  addend = ecoff_data (input_bfd)->gp - gp;\n-\t  gp_usedp = TRUE;\n+\t  gp_usedp = true;\n \t  break;\n \n \tcase ALPHA_R_LITUSE:\n@@ -1652,7 +1652,7 @@ alpha_relocate_section (bfd *output_bfd,\n \t    bfd_put_32 (input_bfd, (bfd_vma) insn2,\n \t\t\tcontents + r_vaddr - input_section->vma + r_symndx);\n \n-\t    gp_usedp = TRUE;\n+\t    gp_usedp = true;\n \t  }\n \t  break;\n \n@@ -1695,7 +1695,7 @@ alpha_relocate_section (bfd *output_bfd,\n \t\t\t relocated.  */\n \t\t      (*info->callbacks->undefined_symbol)\n \t\t\t(info, h->root.root.string, input_bfd,\n-\t\t\t input_section, (bfd_vma) 0, TRUE);\n+\t\t\t input_section, (bfd_vma) 0, true);\n \t\t      addend = 0;\n \t\t    }\n \t\t}\n@@ -1750,7 +1750,7 @@ alpha_relocate_section (bfd *output_bfd,\n \t\t}\n \t    }\n \n-\t  adjust_addrp = FALSE;\n+\t  adjust_addrp = false;\n \t  break;\n \n \tcase ALPHA_R_OP_STORE:\n@@ -1787,7 +1787,7 @@ alpha_relocate_section (bfd *output_bfd,\n \tcase ALPHA_R_GPVALUE:\n \t  /* I really don't know if this does the right thing.  */\n \t  gp = ecoff_data (input_bfd)->gp + r_symndx;\n-\t  gp_undefined = FALSE;\n+\t  gp_undefined = false;\n \t  break;\n \t}\n \n@@ -1892,7 +1892,7 @@ alpha_relocate_section (bfd *output_bfd,\n \t\t    {\n \t\t      (*info->callbacks->undefined_symbol)\n \t\t\t(info, h->root.root.string, input_bfd, input_section,\n-\t\t\t r_vaddr - input_section->vma, TRUE);\n+\t\t\t r_vaddr - input_section->vma, true);\n \t\t      relocation = 0;\n \t\t    }\n \t\t}\n@@ -1962,20 +1962,20 @@ alpha_relocate_section (bfd *output_bfd,\n \t  /* Only give the error once per link.  */\n \t  gp = 4;\n \t  _bfd_set_gp_value (output_bfd, gp);\n-\t  gp_undefined = FALSE;\n+\t  gp_undefined = false;\n \t}\n     }\n \n   if (tos != 0)\n     abort ();\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* Do final adjustments to the filehdr and the aouthdr.  This routine\n    sets the dynamic bits in the file header.  */\n \n-static bfd_boolean\n+static bool\n alpha_adjust_headers (bfd *abfd,\n \t\t      struct internal_filehdr *fhdr,\n \t\t      struct internal_aouthdr *ahdr ATTRIBUTE_UNUSED)\n@@ -1984,7 +1984,7 @@ alpha_adjust_headers (bfd *abfd,\n     fhdr->f_flags |= F_ALPHA_CALL_SHARED;\n   else if ((abfd->flags & DYNAMIC) != 0)\n     fhdr->f_flags |= F_ALPHA_SHARABLE;\n-  return TRUE;\n+  return true;\n }\n \f\n /* Archive handling.  In OSF/1 (or Digital Unix) v3.2, Digital\n@@ -2163,7 +2163,7 @@ alpha_ecoff_get_elt_at_filepos (bfd *archive, file_ptr filepos)\n   bim->size = size;\n   bim->buffer = buf;\n \n-  nbfd->mtime_set = TRUE;\n+  nbfd->mtime_set = true;\n   nbfd->mtime = strtol (hdr->ar_date, (char **) NULL, 10);\n \n   nbfd->flags |= BFD_IN_MEMORY;\n@@ -2303,8 +2303,8 @@ static const struct ecoff_backend_data alpha_ecoff_backend_data =\n     alpha_ecoff_swap_coff_reloc_out,\n     alpha_ecoff_swap_filehdr_out, alpha_ecoff_swap_aouthdr_out,\n     alpha_ecoff_swap_scnhdr_out,\n-    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE,\n-    ECOFF_NO_LONG_SECTION_NAMES, 4, FALSE, 2, 32768,\n+    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, true,\n+    ECOFF_NO_LONG_SECTION_NAMES, 4, false, 2, 32768,\n     alpha_ecoff_swap_filehdr_in, alpha_ecoff_swap_aouthdr_in,\n     alpha_ecoff_swap_scnhdr_in, NULL,\n     alpha_ecoff_bad_format_hook, _bfd_ecoff_set_arch_mach_hook,\n@@ -2323,7 +2323,7 @@ static const struct ecoff_backend_data alpha_ecoff_backend_data =\n   /* TRUE if the .rdata section is part of the text segment, as on the\n      Alpha.  FALSE if .rdata is part of the data segment, as on the\n      MIPS.  */\n-  TRUE,\n+  true,\n   /* Bitsize of constructor entries.  */\n   64,\n   /* Reloc to use for constructor entries.  */"
    },
    {
      "sha": "89f6926fd0bb88888736925c6bb1262e7fa7f808",
      "filename": "bfd/coff-arm.c",
      "status": "modified",
      "additions": 122,
      "deletions": 122,
      "changes": 244,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-arm.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -167,7 +167,7 @@ coff_arm_reloc (bfd *abfd,\n #endif\n \n #ifndef PCRELOFFSET\n-#define PCRELOFFSET TRUE\n+#define PCRELOFFSET true\n #endif\n \n /* These most certainly belong somewhere else. Just had to get rid of\n@@ -223,64 +223,64 @@ static reloc_howto_type aoutarm_std_reloc_howto[] =\n \t   2,\n \t   2,\n \t   24,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_dont,\n \t   aoutarm_fix_pcrel_26_done,\n \t   \"ARM_26D\",\n-\t   TRUE,\t/* partial_inplace.  */\n+\t   true,\t/* partial_inplace.  */\n \t   0x00ffffff,\n \t   0x0,\n \t   PCRELOFFSET),\n     HOWTO (ARM_32,\n \t   0,\n \t   2,\n \t   32,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_32\",\n-\t   TRUE,\t/* partial_inplace.  */\n+\t   true,\t/* partial_inplace.  */\n \t   0xffffffff,\n \t   0xffffffff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_RVA32,\n \t   0,\n \t   2,\n \t   32,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_RVA32\",\n-\t   TRUE,\t/* partial_inplace.  */\n+\t   true,\t/* partial_inplace.  */\n \t   0xffffffff,\n \t   0xffffffff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_26,\n \t   2,\n \t   2,\n \t   24,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   aoutarm_fix_pcrel_26 ,\n \t   \"ARM_26\",\n-\t   FALSE,\n+\t   false,\n \t   0x00ffffff,\n \t   0x00ffffff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_THUMB12,\n \t   1,\n \t   1,\n \t   11,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   coff_thumb_pcrel_12 ,\n \t   \"ARM_THUMB12\",\n-\t   FALSE,\n+\t   false,\n \t   0x000007ff,\n \t   0x000007ff,\n \t   PCRELOFFSET),\n@@ -297,25 +297,25 @@ static reloc_howto_type aoutarm_std_reloc_howto[] =\n \t   0,\n \t   1,\n \t   16,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_SECTION\",\n-\t   TRUE,\t/* partial_inplace.  */\n+\t   true,\t/* partial_inplace.  */\n \t   0x0000ffff,\n \t   0x0000ffff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_SECREL,\n \t   0,\n \t   2,\n \t   32,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_SECREL\",\n-\t   TRUE,\t/* partial_inplace.  */\n+\t   true,\t/* partial_inplace.  */\n \t   0xffffffff,\n \t   0xffffffff,\n \t   PCRELOFFSET),\n@@ -324,183 +324,183 @@ static reloc_howto_type aoutarm_std_reloc_howto[] =\n \t   0,\n \t   0,\n \t   8,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_8\",\n-\t   TRUE,\n+\t   true,\n \t   0x000000ff,\n \t   0x000000ff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_16,\n \t   0,\n \t   1,\n \t   16,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_16\",\n-\t   TRUE,\n+\t   true,\n \t   0x0000ffff,\n \t   0x0000ffff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_32,\n \t   0,\n \t   2,\n \t   32,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_32\",\n-\t   TRUE,\n+\t   true,\n \t   0xffffffff,\n \t   0xffffffff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_26,\n \t   2,\n \t   2,\n \t   24,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   aoutarm_fix_pcrel_26 ,\n \t   \"ARM_26\",\n-\t   FALSE,\n+\t   false,\n \t   0x00ffffff,\n \t   0x00ffffff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_DISP8,\n \t   0,\n \t   0,\n \t   8,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   coff_arm_reloc,\n \t   \"ARM_DISP8\",\n-\t   TRUE,\n+\t   true,\n \t   0x000000ff,\n \t   0x000000ff,\n-\t   TRUE),\n+\t   true),\n     HOWTO (ARM_DISP16,\n \t   0,\n \t   1,\n \t   16,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   coff_arm_reloc,\n \t   \"ARM_DISP16\",\n-\t   TRUE,\n+\t   true,\n \t   0x0000ffff,\n \t   0x0000ffff,\n-\t   TRUE),\n+\t   true),\n     HOWTO (ARM_DISP32,\n \t   0,\n \t   2,\n \t   32,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   coff_arm_reloc,\n \t   \"ARM_DISP32\",\n-\t   TRUE,\n+\t   true,\n \t   0xffffffff,\n \t   0xffffffff,\n-\t   TRUE),\n+\t   true),\n     HOWTO (ARM_26D,\n \t   2,\n \t   2,\n \t   24,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_dont,\n \t   aoutarm_fix_pcrel_26_done,\n \t   \"ARM_26D\",\n-\t   TRUE,\n+\t   true,\n \t   0x00ffffff,\n \t   0x0,\n-\t   FALSE),\n+\t   false),\n     /* 8 is unused */\n     EMPTY_HOWTO (-1),\n     HOWTO (ARM_NEG16,\n \t   0,\n \t   -1,\n \t   16,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_NEG16\",\n-\t   TRUE,\n+\t   true,\n \t   0x0000ffff,\n \t   0x0000ffff,\n-\t   FALSE),\n+\t   false),\n     HOWTO (ARM_NEG32,\n \t   0,\n \t   -2,\n \t   32,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_NEG32\",\n-\t   TRUE,\n+\t   true,\n \t   0xffffffff,\n \t   0xffffffff,\n-\t   FALSE),\n+\t   false),\n     HOWTO (ARM_RVA32,\n \t   0,\n \t   2,\n \t   32,\n-\t   FALSE,\n+\t   false,\n \t   0,\n \t   complain_overflow_bitfield,\n \t   coff_arm_reloc,\n \t   \"ARM_RVA32\",\n-\t   TRUE,\n+\t   true,\n \t   0xffffffff,\n \t   0xffffffff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_THUMB9,\n \t   1,\n \t   1,\n \t   8,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   coff_thumb_pcrel_9 ,\n \t   \"ARM_THUMB9\",\n-\t   FALSE,\n+\t   false,\n \t   0x000000ff,\n \t   0x000000ff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_THUMB12,\n \t   1,\n \t   1,\n \t   11,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   coff_thumb_pcrel_12 ,\n \t   \"ARM_THUMB12\",\n-\t   FALSE,\n+\t   false,\n \t   0x000007ff,\n \t   0x000007ff,\n \t   PCRELOFFSET),\n     HOWTO (ARM_THUMB23,\n \t   1,\n \t   2,\n \t   22,\n-\t   TRUE,\n+\t   true,\n \t   0,\n \t   complain_overflow_signed,\n \t   coff_thumb_pcrel_23 ,\n \t   \"ARM_THUMB23\",\n-\t   FALSE,\n+\t   false,\n \t   0x07ff07ff,\n \t   0x07ff07ff,\n \t   PCRELOFFSET)\n@@ -513,7 +513,7 @@ static reloc_howto_type aoutarm_std_reloc_howto[] =\n /* Return TRUE if this relocation should\n    appear in the output .reloc section.  */\n \n-static bfd_boolean\n+static bool\n in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,\n \t    reloc_howto_type * howto)\n {\n@@ -942,7 +942,7 @@ coff_arm_link_hash_table_create (bfd * abfd)\n   return & ret->root.root;\n }\n \n-static bfd_boolean\n+static bool\n arm_emit_base_file_entry (struct bfd_link_info *info,\n \t\t\t  bfd *output_bfd,\n \t\t\t  asection *input_section,\n@@ -956,10 +956,10 @@ arm_emit_base_file_entry (struct bfd_link_info *info,\n   if (coff_data (output_bfd)->pe)\n      addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;\n   if (fwrite (&addr, sizeof (addr), 1, (FILE *) info->base_file) == 1)\n-    return TRUE;\n+    return true;\n \n   bfd_set_error (bfd_error_system_call);\n-  return FALSE;\n+  return false;\n }\n \f\n #ifndef ARM_WINCE\n@@ -1035,7 +1035,7 @@ find_thumb_glue (struct bfd_link_info *info,\n   sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);\n \n   myh = coff_link_hash_lookup\n-    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);\n+    (coff_hash_table (info), tmp_name, false, false, true);\n \n   if (myh == NULL)\n     /* xgettext:c-format */\n@@ -1064,7 +1064,7 @@ find_arm_glue (struct bfd_link_info *info,\n   sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);\n \n   myh = coff_link_hash_lookup\n-    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);\n+    (coff_hash_table (info), tmp_name, false, false, true);\n \n   if (myh == NULL)\n     /* xgettext:c-format */\n@@ -1165,7 +1165,7 @@ static const insn32 t2a6_bx_insn    = 0xe12fff1e;\n    ARM/Thumb builds.  It is only the code marked THUMBEXTENSION that\n    is different from the original.  */\n \n-static bfd_boolean\n+static bool\n coff_arm_relocate_section (bfd *output_bfd,\n \t\t\t   struct bfd_link_info *info,\n \t\t\t   bfd *input_bfd,\n@@ -1222,7 +1222,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n       howto = coff_rtype_to_howto (input_bfd, input_section, rel, h,\n \t\t\t\t       sym, &addend);\n       if (howto == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       /* The relocation_section function will skip pcrel_offset relocs\n \t when doing a relocatable link.  However, we want to convert\n@@ -1243,15 +1243,15 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t       2,\n \t       2,\n \t       24,\n-\t       TRUE,\n+\t       true,\n \t       0,\n \t       complain_overflow_signed,\n \t       aoutarm_fix_pcrel_26 ,\n \t       \"ARM_26\",\n-\t       TRUE,\n+\t       true,\n \t       0x00ffffff,\n \t       0x00ffffff,\n-\t       FALSE);\n+\t       false);\n \n \t  addend -= rel->r_vaddr - input_section->vma;\n #ifdef ARM_WINCE\n@@ -1347,7 +1347,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \n \t\t      myh = find_arm_glue (info, name, input_bfd);\n \t\t      if (myh == NULL)\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \n \t\t      globals = coff_arm_hash_table (info);\n \n@@ -1389,7 +1389,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t\t\t  if (info->base_file\n \t\t\t      && !arm_emit_base_file_entry (info, output_bfd,\n \t\t\t\t\t\t\t    s, my_offset + 8))\n-\t\t\t    return FALSE;\n+\t\t\t    return false;\n \t\t\t}\n \n \t\t      BFD_ASSERT (my_offset <= globals->arm_glue_size);\n@@ -1435,7 +1435,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \n \t\t      myh = find_thumb_glue (info, name, input_bfd);\n \t\t      if (myh == NULL)\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \n \t\t      globals = coff_arm_hash_table (info);\n \n@@ -1496,7 +1496,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t\t\t\t  && !arm_emit_base_file_entry (info,\n \t\t\t\t\t\t\t\toutput_bfd, s,\n \t\t\t\t\t\t\t\tmy_offset + 16))\n-\t\t\t\treturn FALSE;\n+\t\t\t\treturn false;\n \t\t\t    }\n \t\t\t  else\n \t\t\t    {\n@@ -1574,7 +1574,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t  else if (! bfd_link_relocatable (info))\n \t    (*info->callbacks->undefined_symbol)\n \t      (info, h->root.root.string, input_bfd, input_section,\n-\t       rel->r_vaddr - input_section->vma, TRUE);\n+\t       rel->r_vaddr - input_section->vma, true);\n \t}\n \n       /* Emit a reloc if the backend thinks it needs it.  */\n@@ -1583,7 +1583,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t  && pe_data(output_bfd)->in_reloc_p(output_bfd, howto)\n \t  && !arm_emit_base_file_entry (info, output_bfd, input_section,\n \t\t\t\t\trel->r_vaddr))\n-\treturn FALSE;\n+\treturn false;\n \n       if (done)\n \trstat = bfd_reloc_ok;\n@@ -1608,7 +1608,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t    {\n \t      bfd_vma relocation = val + addend;\n \t      int size = bfd_get_reloc_size (howto);\n-\t      bfd_boolean overflow = FALSE;\n+\t      bool overflow = false;\n \t      bfd_byte *location = contents + address;\n \t      bfd_vma x = bfd_get_32 (input_bfd, location);\n \t      bfd_vma src_mask = 0x007FFFFE;\n@@ -1674,7 +1674,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t      /* Assumes two's complement.  */\n \t      if (   signed_check > reloc_signed_max\n \t\t  || signed_check < reloc_signed_min)\n-\t\toverflow = TRUE;\n+\t\toverflow = true;\n \n \t      /* Put the relocation into the correct bits.\n \t\t For a BLX instruction, make sure that the relocation is rounded up\n@@ -1718,21 +1718,21 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t{\n \t  /* Determine if we need to set the bottom bit of a relocated address\n \t     because the address is the address of a Thumb code symbol.  */\n-\t  int patchit = FALSE;\n+\t  int patchit = false;\n \n \t  if (h != NULL\n \t      && (   h->symbol_class == C_THUMBSTATFUNC\n \t\t  || h->symbol_class == C_THUMBEXTFUNC))\n \t    {\n-\t      patchit = TRUE;\n+\t      patchit = true;\n \t    }\n \t  else if (sym != NULL\n \t\t   && sym->n_scnum > N_UNDEF)\n \t    {\n \t      /* No hash entry - use the symbol instead.  */\n \t      if (   sym->n_sclass == C_THUMBSTATFUNC\n \t\t  || sym->n_sclass == C_THUMBEXTFUNC)\n-\t\tpatchit = TRUE;\n+\t\tpatchit = true;\n \t    }\n \n \t  if (patchit)\n@@ -1755,7 +1755,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t    /* xgettext:c-format */\n \t    (_(\"%pB: bad reloc address %#\" PRIx64 \" in section `%pA'\"),\n \t     input_bfd, (uint64_t) rel->r_vaddr, input_section);\n-\t  return FALSE;\n+\t  return false;\n \tcase bfd_reloc_overflow:\n \t  {\n \t    const char *name;\n@@ -1769,7 +1769,7 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t      {\n \t\tname = _bfd_coff_internal_syment_name (input_bfd, sym, buf);\n \t\tif (name == NULL)\n-\t\t  return FALSE;\n+\t\t  return false;\n \t      }\n \n \t    (*info->callbacks->reloc_overflow)\n@@ -1780,12 +1780,12 @@ coff_arm_relocate_section (bfd *output_bfd,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n #ifndef COFF_IMAGE_WITH_PE\n \n-bfd_boolean\n+bool\n bfd_arm_allocate_interworking_sections (struct bfd_link_info * info)\n {\n   asection *\t\t\t    s;\n@@ -1826,7 +1826,7 @@ bfd_arm_allocate_interworking_sections (struct bfd_link_info * info)\n       s->contents = foo;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n static void\n@@ -1860,7 +1860,7 @@ record_arm_to_thumb_glue (struct bfd_link_info *\tinfo,\n   sprintf (tmp_name, ARM2THUMB_GLUE_ENTRY_NAME, name);\n \n   myh = coff_link_hash_lookup\n-    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);\n+    (coff_hash_table (info), tmp_name, false, false, true);\n \n   if (myh != NULL)\n     {\n@@ -1875,7 +1875,7 @@ record_arm_to_thumb_glue (struct bfd_link_info *\tinfo,\n   bh = NULL;\n   val = globals->arm_glue_size + 1;\n   bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,\n-\t\t\t\tBSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);\n+\t\t\t\tBSF_GLOBAL, s, val, NULL, true, false, &bh);\n \n   free (tmp_name);\n \n@@ -1916,7 +1916,7 @@ record_thumb_to_arm_glue (struct bfd_link_info *\tinfo,\n   sprintf (tmp_name, THUMB2ARM_GLUE_ENTRY_NAME, name);\n \n   myh = coff_link_hash_lookup\n-    (coff_hash_table (info), tmp_name, FALSE, FALSE, TRUE);\n+    (coff_hash_table (info), tmp_name, false, false, true);\n \n   if (myh != NULL)\n     {\n@@ -1928,7 +1928,7 @@ record_thumb_to_arm_glue (struct bfd_link_info *\tinfo,\n   bh = NULL;\n   val = globals->thumb_glue_size + 1;\n   bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,\n-\t\t\t\tBSF_GLOBAL, s, val, NULL, TRUE, FALSE, &bh);\n+\t\t\t\tBSF_GLOBAL, s, val, NULL, true, false, &bh);\n \n   /* If we mark it 'thumb', the disassembler will do a better job.  */\n   myh = (struct coff_link_hash_entry *) bh;\n@@ -1951,7 +1951,7 @@ record_thumb_to_arm_glue (struct bfd_link_info *\tinfo,\n   bh = NULL;\n   val = globals->thumb_glue_size + (globals->support_old_code ? 8 : 4);\n   bfd_coff_link_add_one_symbol (info, globals->bfd_of_glue_owner, tmp_name,\n-\t\t\t\tBSF_LOCAL, s, val, NULL, TRUE, FALSE, &bh);\n+\t\t\t\tBSF_LOCAL, s, val, NULL, true, false, &bh);\n \n   free (tmp_name);\n \n@@ -1965,7 +1965,7 @@ record_thumb_to_arm_glue (struct bfd_link_info *\tinfo,\n    This function is called from the linker scripts in ld/emultempl/\n    {armcoff/pe}.em  */\n \n-bfd_boolean\n+bool\n bfd_arm_get_bfd_for_interworking (bfd *\t\t\t abfd,\n \t\t\t\t  struct bfd_link_info * info)\n {\n@@ -1976,14 +1976,14 @@ bfd_arm_get_bfd_for_interworking (bfd *\t\t\t abfd,\n   /* If we are only performing a partial link do not bother\n      getting a bfd to hold the glue.  */\n   if (bfd_link_relocatable (info))\n-    return TRUE;\n+    return true;\n \n   globals = coff_arm_hash_table (info);\n \n   BFD_ASSERT (globals != NULL);\n \n   if (globals->bfd_of_glue_owner != NULL)\n-    return TRUE;\n+    return true;\n \n   sec = bfd_get_section_by_name (abfd, ARM2THUMB_GLUE_SECTION_NAME);\n \n@@ -1995,7 +1995,7 @@ bfd_arm_get_bfd_for_interworking (bfd *\t\t\t abfd,\n \t\t\t\t\t flags);\n       if (sec == NULL\n \t  || !bfd_set_section_alignment (sec, 2))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   sec = bfd_get_section_by_name (abfd, THUMB2ARM_GLUE_SECTION_NAME);\n@@ -2009,16 +2009,16 @@ bfd_arm_get_bfd_for_interworking (bfd *\t\t\t abfd,\n \n       if (sec == NULL\n \t  || !bfd_set_section_alignment (sec, 2))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Save the bfd for later use.  */\n   globals->bfd_of_glue_owner = abfd;\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n bfd_arm_process_before_allocation (bfd *\t\t   abfd,\n \t\t\t\t   struct bfd_link_info *  info,\n \t\t\t\t   int\t\t\t   support_old_code)\n@@ -2029,7 +2029,7 @@ bfd_arm_process_before_allocation (bfd *\t\t   abfd,\n   /* If we are only performing a partial link do not bother\n      to construct any glue.  */\n   if (bfd_link_relocatable (info))\n-    return TRUE;\n+    return true;\n \n   /* Here we have a bfd that is to be included on the link.  We have a hook\n      to do reloc rummaging, before section sizes are nailed down.  */\n@@ -2046,7 +2046,7 @@ bfd_arm_process_before_allocation (bfd *\t\t   abfd,\n   sec = abfd->sections;\n \n   if (sec == NULL)\n-    return TRUE;\n+    return true;\n \n   for (; sec != NULL; sec = sec->next)\n     {\n@@ -2130,7 +2130,7 @@ bfd_arm_process_before_allocation (bfd *\t\t   abfd,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n #endif /* ! defined (COFF_IMAGE_WITH_PE) */\n@@ -2151,13 +2151,13 @@ bfd_arm_process_before_allocation (bfd *\t\t   abfd,\n /* When doing a relocatable link, we want to convert ARM_26 relocs\n    into ARM_26D relocs.  */\n \n-static bfd_boolean\n+static bool\n coff_arm_adjust_symndx (bfd *obfd ATTRIBUTE_UNUSED,\n \t\t\tstruct bfd_link_info *info ATTRIBUTE_UNUSED,\n \t\t\tbfd *ibfd,\n \t\t\tasection *sec,\n \t\t\tstruct internal_reloc *irel,\n-\t\t\tbfd_boolean *adjustedp)\n+\t\t\tbool *adjustedp)\n {\n   if (irel->r_type == ARM_26)\n     {\n@@ -2170,35 +2170,35 @@ coff_arm_adjust_symndx (bfd *obfd ATTRIBUTE_UNUSED,\n \t  && h->root.u.def.section->output_section == sec->output_section)\n \tirel->r_type = ARM_26D;\n     }\n-  *adjustedp = FALSE;\n-  return TRUE;\n+  *adjustedp = false;\n+  return true;\n }\n \n /* Called when merging the private data areas of two BFDs.\n    This is important as it allows us to detect if we are\n    attempting to merge binaries compiled for different ARM\n    targets, eg different CPUs or different APCS's.     */\n \n-static bfd_boolean\n+static bool\n coff_arm_merge_private_bfd_data (bfd * ibfd, struct bfd_link_info *info)\n {\n   bfd *obfd = info->output_bfd;\n   BFD_ASSERT (ibfd != NULL && obfd != NULL);\n \n   if (ibfd == obfd)\n-    return TRUE;\n+    return true;\n \n   /* If the two formats are different we cannot merge anything.\n      This is not an error, since it is permissable to change the\n      input and output formats.  */\n   if (   ibfd->xvec->flavour != bfd_target_coff_flavour\n       || obfd->xvec->flavour != bfd_target_coff_flavour)\n-    return TRUE;\n+    return true;\n \n   /* Determine what should happen if the input ARM architecture\n      does not match the output ARM architecture.  */\n   if (! bfd_arm_merge_machines (ibfd, obfd))\n-    return FALSE;\n+    return false;\n \n   /* Verify that the APCS is the same for the two BFDs.  */\n   if (APCS_SET (ibfd))\n@@ -2217,7 +2217,7 @@ coff_arm_merge_private_bfd_data (bfd * ibfd, struct bfd_link_info *info)\n \t\t );\n \n \t      bfd_set_error (bfd_error_wrong_format);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  if (APCS_FLOAT_FLAG (obfd) != APCS_FLOAT_FLAG (ibfd))\n@@ -2236,7 +2236,7 @@ coff_arm_merge_private_bfd_data (bfd * ibfd, struct bfd_link_info *info)\n \t\t   ibfd, obfd);\n \n \t      bfd_set_error (bfd_error_wrong_format);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  if (PIC_FLAG (obfd) != PIC_FLAG (ibfd))\n@@ -2255,7 +2255,7 @@ coff_arm_merge_private_bfd_data (bfd * ibfd, struct bfd_link_info *info)\n \t\t   ibfd, obfd);\n \n \t      bfd_set_error (bfd_error_wrong_format);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n       else\n@@ -2294,12 +2294,12 @@ coff_arm_merge_private_bfd_data (bfd * ibfd, struct bfd_link_info *info)\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Display the flags field.  */\n \n-static bfd_boolean\n+static bool\n coff_arm_print_private_bfd_data (bfd * abfd, void * ptr)\n {\n   FILE * file = (FILE *) ptr;\n@@ -2333,7 +2333,7 @@ coff_arm_print_private_bfd_data (bfd * abfd, void * ptr)\n \n   fputc ('\\n', file);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Copies the given flags into the coff_tdata.flags field.\n@@ -2343,7 +2343,7 @@ coff_arm_print_private_bfd_data (bfd * abfd, void * ptr)\n    Note: Although this function is static, it is explicitly\n    called from both coffcode.h and peicode.h.  */\n \n-static bfd_boolean\n+static bool\n _bfd_coff_arm_set_private_flags (bfd * abfd, flagword flags)\n {\n   flagword flag;\n@@ -2359,7 +2359,7 @@ _bfd_coff_arm_set_private_flags (bfd * abfd, flagword flags)\n \t  || (APCS_FLOAT_FLAG (abfd) != (flags & F_APCS_FLOAT))\n \t  || (PIC_FLAG\t      (abfd) != (flags & F_PIC))\n \t  ))\n-    return FALSE;\n+    return false;\n \n   flag |= (flags & (F_APCS_FLOAT | F_PIC));\n \n@@ -2384,24 +2384,24 @@ _bfd_coff_arm_set_private_flags (bfd * abfd, flagword flags)\n \n   SET_INTERWORK_FLAG (abfd, flag);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Copy the important parts of the target specific data\n    from one instance of a BFD to another.  */\n \n-static bfd_boolean\n+static bool\n coff_arm_copy_private_bfd_data (bfd * src, bfd * dest)\n {\n   BFD_ASSERT (src != NULL && dest != NULL);\n \n   if (src == dest)\n-    return TRUE;\n+    return true;\n \n   /* If the destination is not in the same format as the source, do not do\n      the copy.  */\n   if (src->xvec != dest->xvec)\n-    return TRUE;\n+    return true;\n \n   /* Copy the flags field.  */\n   if (APCS_SET (src))\n@@ -2410,13 +2410,13 @@ coff_arm_copy_private_bfd_data (bfd * src, bfd * dest)\n \t{\n \t  /* If the src and dest have different APCS flag bits set, fail.  */\n \t  if (APCS_26_FLAG (dest) != APCS_26_FLAG (src))\n-\t    return FALSE;\n+\t    return false;\n \n \t  if (APCS_FLOAT_FLAG (dest) != APCS_FLOAT_FLAG (src))\n-\t    return FALSE;\n+\t    return false;\n \n \t  if (PIC_FLAG (dest) != PIC_FLAG (src))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       else\n \tSET_APCS_FLAGS (dest, APCS_26_FLAG (src) | APCS_FLOAT_FLAG (src)\n@@ -2450,7 +2450,7 @@ coff_arm_copy_private_bfd_data (bfd * src, bfd * dest)\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Note:  the definitions here of LOCAL_LABEL_PREFIX and USER_LABEL_PREIFX\n@@ -2468,7 +2468,7 @@ coff_arm_copy_private_bfd_data (bfd * src, bfd * dest)\n    b) Allow other prefixes than \".\", e.g. an empty prefix would cause all\n       labels of the form Lxxx to be stripped.  */\n \n-static bfd_boolean\n+static bool\n coff_arm_is_local_label_name (bfd *\t   abfd ATTRIBUTE_UNUSED,\n \t\t\t      const char * name)\n {\n@@ -2478,7 +2478,7 @@ coff_arm_is_local_label_name (bfd *\t   abfd ATTRIBUTE_UNUSED,\n       size_t len = strlen (USER_LABEL_PREFIX);\n \n       if (strncmp (name, USER_LABEL_PREFIX, len) == 0)\n-\treturn FALSE;\n+\treturn false;\n     }\n #endif\n \n@@ -2491,7 +2491,7 @@ coff_arm_is_local_label_name (bfd *\t   abfd ATTRIBUTE_UNUSED,\n       size_t len = strlen (LOCAL_LABEL_PREFIX);\n \n       if (strncmp (name, LOCAL_LABEL_PREFIX, len) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n       /* Perform the checks below for the rest of the name.  */\n       name += len;\n@@ -2507,14 +2507,14 @@ coff_arm_is_local_label_name (bfd *\t   abfd ATTRIBUTE_UNUSED,\n    This does depend on bfd_make_section attaching a new section to the\n    end of the section list for the bfd.  */\n \n-static bfd_boolean\n+static bool\n coff_arm_link_output_has_begun (bfd * sub, struct coff_final_link_info * info)\n {\n   return (sub->output_has_begun\n \t  || sub == coff_arm_hash_table (info->info)->bfd_of_glue_owner);\n }\n \n-static bfd_boolean\n+static bool\n coff_arm_final_link_postscript (bfd * abfd ATTRIBUTE_UNUSED,\n \t\t\t\tstruct coff_final_link_info * pfinfo)\n {\n@@ -2527,9 +2527,9 @@ coff_arm_final_link_postscript (bfd * abfd ATTRIBUTE_UNUSED,\n   if (globals->bfd_of_glue_owner != NULL)\n     {\n       if (! _bfd_coff_link_input_bfd (pfinfo, globals->bfd_of_glue_owner))\n-\treturn FALSE;\n+\treturn false;\n \n-      globals->bfd_of_glue_owner->output_has_begun = TRUE;\n+      globals->bfd_of_glue_owner->output_has_begun = true;\n     }\n \n   return bfd_arm_update_notes (abfd, ARM_NOTE_SECTION);"
    },
    {
      "sha": "7260b71a6938dc5a3472452372325ad6604819a8",
      "filename": "bfd/coff-arm.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-arm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-arm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-arm.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -19,11 +19,11 @@\n    MA 02110-1301, USA.  */\n \n /* ARM Interworking support.  Called from linker.  */\n-extern bfd_boolean bfd_arm_allocate_interworking_sections\n+extern bool bfd_arm_allocate_interworking_sections\n   (struct bfd_link_info *);\n \n-extern bfd_boolean bfd_arm_process_before_allocation\n+extern bool bfd_arm_process_before_allocation\n   (bfd *, struct bfd_link_info *, int);\n \n-extern bfd_boolean bfd_arm_get_bfd_for_interworking\n+extern bool bfd_arm_get_bfd_for_interworking\n   (bfd *, struct bfd_link_info *);"
    },
    {
      "sha": "8af084ef293d2142ae0d9b484a50a1295ca82667",
      "filename": "bfd/coff-bfd.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-bfd.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -27,7 +27,7 @@\n \n /* Return the COFF syment for a symbol.  */\n \n-bfd_boolean\n+bool\n bfd_coff_get_syment (bfd *abfd,\n \t\t     asymbol *symbol,\n \t\t     struct internal_syment *psyment)\n@@ -39,7 +39,7 @@ bfd_coff_get_syment (bfd *abfd,\n       || ! csym->native->is_sym)\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n   *psyment = csym->native->u.syment;\n@@ -50,12 +50,12 @@ bfd_coff_get_syment (bfd *abfd,\n \n   /* FIXME: We should handle fix_line here.  */\n \n-  return TRUE;\n+  return true;\n }\n \n /* Return the COFF auxent for a symbol.  */\n \n-bfd_boolean\n+bool\n bfd_coff_get_auxent (bfd *abfd,\n \t\t     asymbol *symbol,\n \t\t     int indx,\n@@ -72,7 +72,7 @@ bfd_coff_get_auxent (bfd *abfd,\n       || indx >= csym->native->u.syment.n_numaux)\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n   ent = csym->native + indx + 1;\n@@ -95,5 +95,5 @@ bfd_coff_get_auxent (bfd *abfd,\n       ((combined_entry_type *) pauxent->x_csect.x_scnlen.p\n        - obj_raw_syments (abfd));\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "e735148ad2cdb959c0b5fe18271a940bb98a9637",
      "filename": "bfd/coff-bfd.h",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-bfd.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -44,13 +44,13 @@ struct coff_section_tdata\n   /* The relocs, swapped into COFF internal form.  This may be NULL.  */\n   struct internal_reloc *relocs;\n   /* If this is TRUE, the relocs entry may not be freed.  */\n-  bfd_boolean keep_relocs;\n+  bool keep_relocs;\n   /* The section contents.  This may be NULL.  */\n   bfd_byte *contents;\n   /* If this is TRUE, the contents entry may not be freed.  */\n-  bfd_boolean keep_contents;\n+  bool keep_contents;\n   /* Information cached by coff_find_nearest_line.  */\n-  bfd_boolean saved_bias;\n+  bool saved_bias;\n   bfd_signed_vma bias;\n   bfd_vma offset;\n   unsigned int i;\n@@ -81,11 +81,11 @@ struct coff_section_tdata\n struct internal_syment;\n union internal_auxent;\n \n-extern bfd_boolean bfd_coff_get_syment\n+extern bool bfd_coff_get_syment\n   (bfd *, struct bfd_symbol *, struct internal_syment *);\n \n-extern bfd_boolean bfd_coff_get_auxent\n+extern bool bfd_coff_get_auxent\n   (bfd *, struct bfd_symbol *, int, union internal_auxent *);\n \n-extern bfd_boolean bfd_coff_set_symbol_class\n+extern bool bfd_coff_set_symbol_class\n   (bfd *, struct bfd_symbol *, unsigned int);"
    },
    {
      "sha": "d73c32b215d2f0247607379b97de0b209249db8a",
      "filename": "bfd/coff-go32.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-go32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-go32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-go32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -51,7 +51,7 @@\n \n /* The following functions are not static, because they are also\n    used for coff-go32-exe (coff-stgo32.c).  */\n-bfd_boolean _bfd_go32_mkobject (bfd *);\n+bool _bfd_go32_mkobject (bfd *);\n void _bfd_go32_swap_scnhdr_in (bfd *, void *, void *);\n unsigned int _bfd_go32_swap_scnhdr_out (bfd *, void *, void *);\n \n@@ -61,18 +61,18 @@ unsigned int _bfd_go32_swap_scnhdr_out (bfd *, void *, void *);\n \n #include \"coff-i386.c\"\n \n-bfd_boolean\n+bool\n _bfd_go32_mkobject (bfd * abfd)\n {\n   const bfd_size_type amt = sizeof (coff_data_type);\n \n   abfd->tdata.coff_obj_data = bfd_zalloc (abfd, amt);\n   if (abfd->tdata.coff_obj_data == NULL)\n-    return FALSE;\n+    return false;\n \n-  coff_data (abfd)->go32 = TRUE;\n+  coff_data (abfd)->go32 = true;\n \n-  return TRUE;\n+  return true;\n }\n \n void"
    },
    {
      "sha": "c6e085f9b63e710af157177dda2180656d17c246",
      "filename": "bfd/coff-i386.c",
      "status": "modified",
      "additions": 28,
      "deletions": 28,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-i386.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -187,16 +187,16 @@ coff_i386_reloc (bfd *abfd,\n /* Return TRUE if this relocation should appear in the output .reloc\n    section.  */\n \n-static bfd_boolean in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,\n-\t\t\t       reloc_howto_type *howto)\n+static bool\n+in_reloc_p (bfd *abfd ATTRIBUTE_UNUSED, reloc_howto_type *howto)\n {\n   return ! howto->pc_relative && howto->type != R_IMAGEBASE\n \t && howto->type != R_SECREL32;\n }\n #endif /* COFF_WITH_PE */\n \n #ifndef PCRELOFFSET\n-#define PCRELOFFSET FALSE\n+#define PCRELOFFSET false\n #endif\n \n static reloc_howto_type howto_table[] =\n@@ -211,29 +211,29 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"dir32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n   /* PE IMAGE_REL_I386_DIR32NB relocation (7).\t*/\n   HOWTO (R_IMAGEBASE,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"rva32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n   EMPTY_HOWTO (010),\n   EMPTY_HOWTO (011),\n   EMPTY_HOWTO (012),\n@@ -243,15 +243,15 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"secrel32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n #else\n   EMPTY_HOWTO (013),\n #endif\n@@ -263,12 +263,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"8\",\t\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x000000ff,\t\t/* src_mask */\n \t 0x000000ff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -277,12 +277,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"16\",\t\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x0000ffff,\t\t/* src_mask */\n \t 0x0000ffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -291,12 +291,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"32\",\t\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -305,12 +305,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"DISP8\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x000000ff,\t\t/* src_mask */\n \t 0x000000ff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -319,12 +319,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"DISP16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x0000ffff,\t\t/* src_mask */\n \t 0x0000ffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -333,12 +333,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_i386_reloc,\t/* special_function */\n \t \"DISP32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET)\t\t/* pcrel_offset */\n@@ -411,7 +411,7 @@ static reloc_howto_type howto_table[] =\n    and the regular routine is that we don't want to do anything for a\n    relocatable link.  */\n \n-static bfd_boolean\n+static bool\n coff_pe_i386_relocate_section (bfd *output_bfd,\n \t\t\t       struct bfd_link_info *info,\n \t\t\t       bfd *input_bfd,\n@@ -422,7 +422,7 @@ coff_pe_i386_relocate_section (bfd *output_bfd,\n \t\t\t       asection **sections)\n {\n   if (bfd_link_relocatable (info))\n-    return TRUE;\n+    return true;\n \n   return _bfd_coff_generic_relocate_section (output_bfd, info, input_bfd,\n \t\t\t\t\t     input_section, contents,\n@@ -602,11 +602,11 @@ coff_i386_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,\n    a leading dot for local labels, so if TARGET_UNDERSCORE is defined\n    we treat all symbols starting with L as local.  */\n \n-static bfd_boolean\n+static bool\n coff_i386_is_local_label_name (bfd *abfd, const char *name)\n {\n   if (name[0] == 'L')\n-    return TRUE;\n+    return true;\n \n   return _bfd_coff_is_local_label_name (abfd, name);\n }"
    },
    {
      "sha": "7aa2984187c729b9f09d570023d907705d50d49b",
      "filename": "bfd/coff-ia64.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-ia64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -53,11 +53,11 @@ static reloc_howto_type howto_table[] =\n /* Return TRUE if this relocation should\n    appear in the output .reloc section.  */\n \n-static bfd_boolean\n+static bool\n in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,\n \t    reloc_howto_type *howto ATTRIBUTE_UNUSED)\n {\n-  return FALSE;\t\t\t/* We don't do relocs for now...  */\n+  return false;\t\t\t/* We don't do relocs for now...  */\n }\n #endif\n "
    },
    {
      "sha": "712cc4d1540aeecc9856f0f4fcc6f57afc5908b0",
      "filename": "bfd/coff-mcore.c",
      "status": "modified",
      "additions": 37,
      "deletions": 37,
      "changes": 74,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-mcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-mcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-mcore.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -37,7 +37,7 @@\n \n /* This file is compiled more than once, but we only compile the\n    final_link routine once.  */\n-extern bfd_boolean mcore_bfd_coff_final_link\n+extern bool mcore_bfd_coff_final_link\n   (bfd *, struct bfd_link_info *);\n static bfd_reloc_status_type mcore_coff_unsupported_reloc\n   (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n@@ -63,45 +63,45 @@ static reloc_howto_type mcore_coff_howto_table[] =\n \t 0,\t\t\t /* rightshift */\n \t 0,\t\t\t /* size (0 = byte, 1 = short, 2 = long) */\n \t 0,\t\t\t /* bitsize */\n-\t FALSE,\t\t\t /* pc_relative */\n+\t false,\t\t\t /* pc_relative */\n \t 0,\t\t\t /* bitpos */\n \t complain_overflow_dont, /* dont complain_on_overflow */\n \t NULL,\t\t\t /* special_function */\n \t \"ABSOLUTE\",\t\t /* name */\n-\t FALSE,\t\t\t /* partial_inplace */\n+\t false,\t\t\t /* partial_inplace */\n \t 0x00,\t\t\t /* src_mask */\n \t 0x00,\t\t\t /* dst_mask */\n-\t FALSE),\t\t /* pcrel_offset */\n+\t false),\t\t /* pcrel_offset */\n \n   HOWTO (IMAGE_REL_MCORE_ADDR32,/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t NULL,\t\t\t/* special_function */\n \t \"ADDR32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 8 bits + 2 zero bits; jmpi/jsri/lrw instructions.\n      Should not appear in object files.  */\n   HOWTO (IMAGE_REL_MCORE_PCREL_IMM8BY4,\t/* type */\n \t 2,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t mcore_coff_unsupported_reloc, /* special_function */\n \t \"IMM8BY4\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   /* bsr/bt/bf/br instructions; 11 bits + 1 zero bit\n      Span 2k instructions == 4k bytes.\n@@ -110,45 +110,45 @@ static reloc_howto_type mcore_coff_howto_table[] =\n \t 1,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 11,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t NULL,\t\t\t/* special_function */\n \t \"IMM11BY2\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0x0,\t\t\t/* src_mask */\n \t 0x7ff,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   /* 4 bits + 1 zero bit; 'loopt' instruction only; unsupported.  */\n   HOWTO (IMAGE_REL_MCORE_PCREL_IMM4BY2,\t/* type */\n \t 1,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 4,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t mcore_coff_unsupported_reloc, /* special_function */\n \t \"IMM4BY2\",\t\t /* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   /* 32-bit pc-relative. Eventually this will help support PIC code.  */\n   HOWTO (IMAGE_REL_MCORE_PCREL_32,/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t NULL,\t\t\t/* special_function */\n \t \"PCREL_32\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0x0,\t\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   /* Like PCREL_IMM11BY2, this relocation indicates that there is a\n      'jsri' at the specified address. There is a separate relocation\n@@ -161,29 +161,29 @@ static reloc_howto_type mcore_coff_howto_table[] =\n \t 1,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 11,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t NULL,\t\t\t/* special_function */\n \t \"JSR_IMM11BY2\",\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0x0,\t\t\t/* src_mask */\n \t 0x7ff,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   HOWTO (IMAGE_REL_MCORE_RVA,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t NULL,\t\t\t/* special_function */\n \t \"MCORE_RVA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t TRUE)\t\t\t/* pcrel_offset */\n+\t true)\t\t\t/* pcrel_offset */\n };\n \f\n /* Extend the coff_link_hash_table structure with a few M*Core specific fields.\n@@ -209,7 +209,7 @@ mcore_hash_table;\n \f\n /* Add an entry to the base file.  */\n \n-static bfd_boolean\n+static bool\n mcore_emit_base_file_entry (struct bfd_link_info *info,\n \t\t\t    bfd *output_bfd,\n \t\t\t    asection *input_section,\n@@ -224,10 +224,10 @@ mcore_emit_base_file_entry (struct bfd_link_info *info,\n      addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;\n \n   if (fwrite (&addr, sizeof (addr), 1, (FILE *) info->base_file) == 1)\n-    return TRUE;\n+    return true;\n \n   bfd_set_error (bfd_error_system_call);\n-  return FALSE;\n+  return false;\n }\n \f\n static bfd_reloc_status_type\n@@ -336,14 +336,14 @@ coff_mcore_rtype_to_howto (bfd * abfd ATTRIBUTE_UNUSED,\n /* Return TRUE if this relocation should appear in the output .reloc section.\n    This function is referenced in pe_mkobject in peicode.h.  */\n \n-static bfd_boolean\n+static bool\n in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED, reloc_howto_type * howto)\n {\n   return ! howto->pc_relative && howto->type != IMAGE_REL_MCORE_RVA;\n }\n \f\n /* The reloc processing routine for the optimized COFF linker.  */\n-static bfd_boolean\n+static bool\n coff_mcore_relocate_section (bfd * output_bfd,\n \t\t\t     struct bfd_link_info * info,\n \t\t\t     bfd * input_bfd,\n@@ -360,7 +360,7 @@ coff_mcore_relocate_section (bfd * output_bfd,\n      thing.  The caller will take care of adjusting the reloc\n      addresses and symbol indices.  */\n   if (bfd_link_relocatable (info))\n-    return TRUE;\n+    return true;\n \n   /* Check if we have the same endianness */\n   if (   input_bfd->xvec->byteorder != output_bfd->xvec->byteorder\n@@ -374,7 +374,7 @@ coff_mcore_relocate_section (bfd * output_bfd,\n \t bfd_big_endian (output_bfd) ? _(\"big endian\") : _(\"little endian\"));\n \n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n     }\n \n   rel = relocs;\n@@ -414,7 +414,7 @@ coff_mcore_relocate_section (bfd * output_bfd,\n       howto = bfd_coff_rtype_to_howto (input_bfd, input_section, rel, h,\n \t\t\t\t       sym, & addend);\n       if (howto == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       val = 0;\n \n@@ -457,7 +457,7 @@ coff_mcore_relocate_section (bfd * output_bfd,\n \t  else\n \t    (*info->callbacks->undefined_symbol)\n \t      (info, h->root.root.string, input_bfd, input_section,\n-\t       rel->r_vaddr - input_section->vma, TRUE);\n+\t       rel->r_vaddr - input_section->vma, true);\n \n \t  my_name = h->root.root.string;\n \t}\n@@ -472,7 +472,7 @@ coff_mcore_relocate_section (bfd * output_bfd,\n \t  _bfd_error_handler (_(\"%pB: unsupported relocation type %#x\"),\n \t\t\t      input_bfd, r_type);\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \n \tcase IMAGE_REL_MCORE_ABSOLUTE:\n \t  _bfd_error_handler\n@@ -508,7 +508,7 @@ coff_mcore_relocate_section (bfd * output_bfd,\n \t  && pe_data (output_bfd)->in_reloc_p (output_bfd, howto)\n \t  && !mcore_emit_base_file_entry (info, output_bfd, input_section,\n \t\t\t\t\t  rel->r_vaddr))\n-\treturn FALSE;\n+\treturn false;\n \n       switch (rstat)\n \t{\n@@ -526,7 +526,7 @@ coff_mcore_relocate_section (bfd * output_bfd,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* Tailor coffcode.h -- macro heaven.  */"
    },
    {
      "sha": "963ab249119620123c5da4d3e904ed1f7c8ecaab",
      "filename": "bfd/coff-mips.c",
      "status": "modified",
      "additions": 50,
      "deletions": 50,
      "changes": 100,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-mips.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -86,126 +86,126 @@ static reloc_howto_type mips_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"IGNORE\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A 16 bit reference to a symbol, normally from a data section.  */\n   HOWTO (MIPS_R_REFHALF,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t mips_generic_reloc,\t/* special_function */\n \t \"REFHALF\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A 32 bit reference to a symbol, normally from a data section.  */\n   HOWTO (MIPS_R_REFWORD,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t mips_generic_reloc,\t/* special_function */\n \t \"REFWORD\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A 26 bit absolute jump address.  */\n   HOWTO (MIPS_R_JMPADDR,\t/* type */\n \t 2,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t\t\t\t/* This needs complex overflow\n \t\t\t\t   detection, because the upper four\n \t\t\t\t   bits must match the PC.  */\n \t mips_generic_reloc,\t/* special_function */\n \t \"JMPADDR\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x3ffffff,\t\t/* src_mask */\n \t 0x3ffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* The high 16 bits of a symbol value.  Handled by the function\n      mips_refhi_reloc.  */\n   HOWTO (MIPS_R_REFHI,\t\t/* type */\n \t 16,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t mips_refhi_reloc,\t/* special_function */\n \t \"REFHI\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* The low 16 bits of a symbol value.  */\n   HOWTO (MIPS_R_REFLO,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t mips_reflo_reloc,\t/* special_function */\n \t \"REFLO\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A reference to an offset from the gp register.  Handled by the\n      function mips_gprel_reloc.  */\n   HOWTO (MIPS_R_GPREL,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t mips_gprel_reloc,\t/* special_function */\n \t \"GPREL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* A reference to a literal using an offset from the gp register.\n      Handled by the function mips_gprel_reloc.  */\n   HOWTO (MIPS_R_LITERAL,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t mips_gprel_reloc,\t/* special_function */\n \t \"LITERAL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (8),\n   EMPTY_HOWTO (9),\n@@ -219,23 +219,23 @@ static reloc_howto_type mips_howto_table[] =\n \t 2,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t mips_generic_reloc,\t/* special_function */\n \t \"PCREL16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n };\n \n #define MIPS_HOWTO_COUNT \\\n   (sizeof mips_howto_table / sizeof mips_howto_table[0])\n \f\n /* See whether the magic number matches.  */\n \n-static bfd_boolean\n+static bool\n mips_ecoff_bad_format_hook (bfd * abfd, void * filehdr)\n {\n   struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;\n@@ -244,7 +244,7 @@ mips_ecoff_bad_format_hook (bfd * abfd, void * filehdr)\n     {\n     case MIPS_MAGIC_1:\n       /* I don't know what endianness this implies.  */\n-      return TRUE;\n+      return true;\n \n     case MIPS_MAGIC_BIG:\n     case MIPS_MAGIC_BIG2:\n@@ -257,7 +257,7 @@ mips_ecoff_bad_format_hook (bfd * abfd, void * filehdr)\n       return bfd_little_endian (abfd);\n \n     default:\n-      return FALSE;\n+      return false;\n     }\n }\n \f\n@@ -562,7 +562,7 @@ mips_gprel_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t  bfd *output_bfd,\n \t\t  char **error_message ATTRIBUTE_UNUSED)\n {\n-  bfd_boolean relocatable;\n+  bool relocatable;\n   bfd_vma gp;\n   bfd_vma relocation;\n   unsigned long val;\n@@ -581,10 +581,10 @@ mips_gprel_reloc (bfd *abfd ATTRIBUTE_UNUSED,\n     }\n \n   if (output_bfd != (bfd *) NULL)\n-    relocatable = TRUE;\n+    relocatable = true;\n   else\n     {\n-      relocatable = FALSE;\n+      relocatable = false;\n       output_bfd = symbol->section->output_section->owner;\n     }\n \n@@ -792,7 +792,7 @@ mips_relocate_hi (struct internal_reloc *refhi,\n \n /* Relocate a section while linking a MIPS ECOFF file.  */\n \n-static bfd_boolean\n+static bool\n mips_relocate_section (bfd *output_bfd,\n \t\t       struct bfd_link_info *info,\n \t\t       bfd *input_bfd,\n@@ -803,11 +803,11 @@ mips_relocate_section (bfd *output_bfd,\n   asection **symndx_to_section;\n   struct ecoff_link_hash_entry **sym_hashes;\n   bfd_vma gp;\n-  bfd_boolean gp_undefined;\n+  bool gp_undefined;\n   struct external_reloc *ext_rel;\n   struct external_reloc *ext_rel_end;\n   unsigned int i;\n-  bfd_boolean got_lo;\n+  bool got_lo;\n   struct internal_reloc lo_int_rel;\n   bfd_size_type amt;\n \n@@ -823,7 +823,7 @@ mips_relocate_section (bfd *output_bfd,\n       amt = NUM_RELOC_SECTIONS * sizeof (asection *);\n       symndx_to_section = (asection **) bfd_alloc (input_bfd, amt);\n       if (!symndx_to_section)\n-\treturn FALSE;\n+\treturn false;\n \n       symndx_to_section[RELOC_SECTION_NONE] = NULL;\n       symndx_to_section[RELOC_SECTION_TEXT] =\n@@ -858,18 +858,18 @@ mips_relocate_section (bfd *output_bfd,\n \n   gp = _bfd_get_gp_value (output_bfd);\n   if (gp == 0)\n-    gp_undefined = TRUE;\n+    gp_undefined = true;\n   else\n-    gp_undefined = FALSE;\n+    gp_undefined = false;\n \n-  got_lo = FALSE;\n+  got_lo = false;\n \n   ext_rel = (struct external_reloc *) external_relocs;\n   ext_rel_end = ext_rel + input_section->reloc_count;\n   for (i = 0; ext_rel < ext_rel_end; ext_rel++, i++)\n     {\n       struct internal_reloc int_rel;\n-      bfd_boolean use_lo = FALSE;\n+      bool use_lo = false;\n       bfd_vma addend;\n       reloc_howto_type *howto;\n       struct ecoff_link_hash_entry *h = NULL;\n@@ -882,7 +882,7 @@ mips_relocate_section (bfd *output_bfd,\n       else\n \t{\n \t  int_rel = lo_int_rel;\n-\t  got_lo = FALSE;\n+\t  got_lo = false;\n \t}\n \n       BFD_ASSERT (int_rel.r_type\n@@ -912,9 +912,9 @@ mips_relocate_section (bfd *output_bfd,\n \t      && int_rel.r_extern == lo_int_rel.r_extern\n \t      && int_rel.r_symndx == lo_int_rel.r_symndx)\n \t    {\n-\t      use_lo = TRUE;\n+\t      use_lo = true;\n \t      if (lo_ext_rel == ext_rel + 1)\n-\t\tgot_lo = TRUE;\n+\t\tgot_lo = true;\n \t    }\n \t}\n \n@@ -956,7 +956,7 @@ mips_relocate_section (bfd *output_bfd,\n \t      /* Only give the error once per link.  */\n \t      gp = 4;\n \t      _bfd_set_gp_value (output_bfd, gp);\n-\t      gp_undefined = FALSE;\n+\t      gp_undefined = false;\n \t    }\n \t  if (! int_rel.r_extern)\n \t    {\n@@ -1158,7 +1158,7 @@ mips_relocate_section (bfd *output_bfd,\n \t\t{\n \t\t  (*info->callbacks->undefined_symbol)\n \t\t    (info, h->root.root.string, input_bfd, input_section,\n-\t\t     int_rel.r_vaddr - input_section->vma, TRUE);\n+\t\t     int_rel.r_vaddr - input_section->vma, true);\n \t\t  relocation = 0;\n \t\t}\n \t    }\n@@ -1236,7 +1236,7 @@ mips_relocate_section (bfd *output_bfd,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n static void\n@@ -1313,8 +1313,8 @@ static const struct ecoff_backend_data mips_ecoff_backend_data =\n     mips_ecoff_swap_coff_reloc_out,\n     mips_ecoff_swap_filehdr_out, mips_ecoff_swap_aouthdr_out,\n     mips_ecoff_swap_scnhdr_out,\n-    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, TRUE,\n-    ECOFF_NO_LONG_SECTION_NAMES, 4, FALSE, 2, 32768,\n+    FILHSZ, AOUTSZ, SCNHSZ, 0, 0, 0, 0, FILNMLEN, true,\n+    ECOFF_NO_LONG_SECTION_NAMES, 4, false, 2, 32768,\n     mips_ecoff_swap_filehdr_in, mips_ecoff_swap_aouthdr_in,\n     mips_ecoff_swap_scnhdr_in, NULL,\n     mips_ecoff_bad_format_hook, _bfd_ecoff_set_arch_mach_hook,\n@@ -1333,7 +1333,7 @@ static const struct ecoff_backend_data mips_ecoff_backend_data =\n   /* TRUE if the .rdata section is part of the text segment, as on the\n      Alpha.  FALSE if .rdata is part of the data segment, as on the\n      MIPS.  */\n-  FALSE,\n+  false,\n   /* Bitsize of constructor entries.  */\n   32,\n   /* Reloc to use for constructor entries.  */"
    },
    {
      "sha": "237c7ed6d66ff10de392ce2fa1dda4a281990fe3",
      "filename": "bfd/coff-rs6000.c",
      "status": "modified",
      "additions": 296,
      "deletions": 296,
      "changes": 592,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-rs6000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-rs6000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-rs6000.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,19 +32,19 @@\n #include \"libcoff.h\"\n #include \"libxcoff.h\"\n \n-extern bfd_boolean _bfd_xcoff_mkobject (bfd *);\n-extern bfd_boolean _bfd_xcoff_copy_private_bfd_data (bfd *, bfd *);\n-extern bfd_boolean _bfd_xcoff_is_local_label_name (bfd *, const char *);\n+extern bool _bfd_xcoff_mkobject (bfd *);\n+extern bool _bfd_xcoff_copy_private_bfd_data (bfd *, bfd *);\n+extern bool _bfd_xcoff_is_local_label_name (bfd *, const char *);\n extern reloc_howto_type *_bfd_xcoff_reloc_type_lookup\n   (bfd *, bfd_reloc_code_real_type);\n-extern bfd_boolean _bfd_xcoff_slurp_armap (bfd *);\n+extern bool _bfd_xcoff_slurp_armap (bfd *);\n extern bfd_cleanup _bfd_xcoff_archive_p (bfd *);\n extern void * _bfd_xcoff_read_ar_hdr (bfd *);\n extern bfd *_bfd_xcoff_openr_next_archived_file (bfd *, bfd *);\n extern int _bfd_xcoff_stat_arch_elt (bfd *, struct stat *);\n-extern bfd_boolean _bfd_xcoff_write_armap\n+extern bool _bfd_xcoff_write_armap\n   (bfd *, unsigned int, struct orl *, unsigned int, int);\n-extern bfd_boolean _bfd_xcoff_write_archive_contents (bfd *);\n+extern bool _bfd_xcoff_write_archive_contents (bfd *);\n extern int _bfd_xcoff_sizeof_headers (bfd *, struct bfd_link_info *);\n extern void _bfd_xcoff_swap_sym_in (bfd *, void *, void *);\n extern unsigned int _bfd_xcoff_swap_sym_out (bfd *, void *, void *);\n@@ -78,7 +78,7 @@ void xcoff_rtype2howto (arelent *, struct internal_reloc *);\n #define coff_bfd_is_local_label_name _bfd_xcoff_is_local_label_name\n #ifdef AIX_CORE\n extern bfd_cleanup rs6000coff_core_p (bfd *abfd);\n-extern bfd_boolean rs6000coff_core_file_matches_executable_p\n+extern bool rs6000coff_core_file_matches_executable_p\n   (bfd *cbfd, bfd *ebfd);\n extern char *rs6000coff_core_file_failing_command (bfd *abfd);\n extern int rs6000coff_core_file_failing_signal (bfd *abfd);\n@@ -119,33 +119,33 @@ extern int rs6000coff_core_file_failing_signal (bfd *abfd);\n /* The main body of code is in coffcode.h.  */\n \n static const char *normalize_filename (bfd *);\n-static bfd_boolean xcoff_write_armap_old\n+static bool xcoff_write_armap_old\n   (bfd *, unsigned int, struct orl *, unsigned int, int);\n-static bfd_boolean xcoff_write_armap_big\n+static bool xcoff_write_armap_big\n   (bfd *, unsigned int, struct orl *, unsigned int, int);\n-static bfd_boolean xcoff_write_archive_contents_old (bfd *);\n-static bfd_boolean xcoff_write_archive_contents_big (bfd *);\n+static bool xcoff_write_archive_contents_old (bfd *);\n+static bool xcoff_write_archive_contents_big (bfd *);\n static void xcoff_swap_ldhdr_in (bfd *, const void *, struct internal_ldhdr *);\n static void xcoff_swap_ldhdr_out (bfd *, const struct internal_ldhdr *, void *);\n static void xcoff_swap_ldsym_in (bfd *, const void *, struct internal_ldsym *);\n static void xcoff_swap_ldsym_out (bfd *, const struct internal_ldsym *, void *);\n static void xcoff_swap_ldrel_in (bfd *, const void *, struct internal_ldrel *);\n static void xcoff_swap_ldrel_out (bfd *, const struct internal_ldrel *, void *);\n-static bfd_boolean xcoff_ppc_relocate_section\n+static bool xcoff_ppc_relocate_section\n   (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,\n    struct internal_reloc *, struct internal_syment *, asection **);\n-static bfd_boolean _bfd_xcoff_put_ldsymbol_name\n+static bool _bfd_xcoff_put_ldsymbol_name\n   (bfd *, struct xcoff_loader_info *, struct internal_ldsym *, const char *);\n static asection *xcoff_create_csect_from_smclas\n   (bfd *, union internal_auxent *, const char *);\n-static bfd_boolean xcoff_is_lineno_count_overflow (bfd *, bfd_vma);\n-static bfd_boolean xcoff_is_reloc_count_overflow (bfd *, bfd_vma);\n+static bool xcoff_is_lineno_count_overflow (bfd *, bfd_vma);\n+static bool xcoff_is_reloc_count_overflow (bfd *, bfd_vma);\n static bfd_vma xcoff_loader_symbol_offset (bfd *, struct internal_ldhdr *);\n static bfd_vma xcoff_loader_reloc_offset (bfd *, struct internal_ldhdr *);\n-static bfd_boolean xcoff_generate_rtinit\n-  (bfd *, const char *, const char *, bfd_boolean);\n-static bfd_boolean do_pad (bfd *, unsigned int);\n-static bfd_boolean do_copy (bfd *, bfd *);\n+static bool xcoff_generate_rtinit\n+  (bfd *, const char *, const char *, bool);\n+static bool do_pad (bfd *, unsigned int);\n+static bool do_copy (bfd *, bfd *);\n \n /* Relocation functions */\n static xcoff_reloc_function xcoff_reloc_type_br;\n@@ -318,11 +318,11 @@ archive_iterator_begin (struct archive_iterator *iterator,\n /* Make ITERATOR visit the first unvisited archive member.  Return true\n    on success; return false if all members have been visited.  */\n \n-static bfd_boolean\n+static bool\n archive_iterator_next (struct archive_iterator *iterator)\n {\n   if (!iterator->next.member)\n-    return FALSE;\n+    return false;\n \n   iterator->current = iterator->next;\n   member_layout_init (&iterator->next, iterator->archive,\n@@ -331,21 +331,21 @@ archive_iterator_next (struct archive_iterator *iterator)\n \t\t      + iterator->current.header_size\n \t\t      + iterator->current.contents_size\n \t\t      + iterator->current.trailing_padding);\n-  return TRUE;\n+  return true;\n }\n \n /* We use our own tdata type.  Its first field is the COFF tdata type,\n    so the COFF routines are compatible.  */\n \n-bfd_boolean\n+bool\n _bfd_xcoff_mkobject (bfd *abfd)\n {\n   coff_data_type *coff;\n   size_t amt = sizeof (struct xcoff_tdata);\n \n   abfd->tdata.xcoff_obj_data = (struct xcoff_tdata *) bfd_zalloc (abfd, amt);\n   if (abfd->tdata.xcoff_obj_data == NULL)\n-    return FALSE;\n+    return false;\n   coff = coff_data (abfd);\n   coff->symbols = (coff_symbol_type *) NULL;\n   coff->conversion_table = (unsigned int *) NULL;\n@@ -364,19 +364,19 @@ _bfd_xcoff_mkobject (bfd *abfd)\n   /* text section alignment is different than the default */\n   bfd_xcoff_text_align_power (abfd) = 2;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Copy XCOFF data from one BFD to another.  */\n \n-bfd_boolean\n+bool\n _bfd_xcoff_copy_private_bfd_data (bfd *ibfd, bfd *obfd)\n {\n   struct xcoff_tdata *ix, *ox;\n   asection *sec;\n \n   if (ibfd->xvec != obfd->xvec)\n-    return TRUE;\n+    return true;\n   ix = xcoff_data (ibfd);\n   ox = xcoff_data (obfd);\n   ox->full_aouthdr = ix->full_aouthdr;\n@@ -407,19 +407,19 @@ _bfd_xcoff_copy_private_bfd_data (bfd *ibfd, bfd *obfd)\n   ox->cputype = ix->cputype;\n   ox->maxdata = ix->maxdata;\n   ox->maxstack = ix->maxstack;\n-  return TRUE;\n+  return true;\n }\n \n /* I don't think XCOFF really has a notion of local labels based on\n    name.  This will mean that ld -X doesn't actually strip anything.\n    The AIX native linker does not have a -X option, and it ignores the\n    -x option.  */\n \n-bfd_boolean\n+bool\n _bfd_xcoff_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\tconst char *name ATTRIBUTE_UNUSED)\n {\n-  return FALSE;\n+  return false;\n }\n \f\n void\n@@ -694,105 +694,105 @@ reloc_howto_type xcoff_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_POS\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x01: 32 bit relocation, but store negative value.  */\n   HOWTO (R_NEG,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t -2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_NEG\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x02: 32 bit PC relative relocation.  */\n   HOWTO (R_REL,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_REL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x03: 16 bit TOC relative relocation.  */\n   HOWTO (R_TOC,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TOC\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x04: Same as R_TOC  */\n   HOWTO (R_TRL,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TRL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x05: External TOC relative symbol.  */\n   HOWTO (R_GL,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_GL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x06: Local TOC relative symbol.\t */\n   HOWTO (R_TCL,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TCL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (7),\n \n@@ -801,15 +801,15 @@ reloc_howto_type xcoff_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_BA_26\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x03fffffc,\t\t/* src_mask */\n \t 0x03fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (9),\n \n@@ -818,15 +818,15 @@ reloc_howto_type xcoff_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_BR\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x03fffffc,\t\t/* src_mask */\n \t 0x03fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (0xb),\n \n@@ -835,30 +835,30 @@ reloc_howto_type xcoff_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x0d: Same as R_POS.  */\n   HOWTO (R_RLA,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RLA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (0xe),\n \n@@ -867,15 +867,15 @@ reloc_howto_type xcoff_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 1,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_REF\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (0x10),\n   EMPTY_HOWTO (0x11),\n@@ -886,180 +886,180 @@ reloc_howto_type xcoff_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TRLA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x14: Modifiable relative branch.  */\n   HOWTO (R_RRTBI,\t\t/* type */\n \t 1,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RRTBI\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x15: Modifiable absolute branch.  */\n   HOWTO (R_RRTBA,\t\t/* type */\n \t 1,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RRTBA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x16: Modifiable call absolute indirect.  */\n   HOWTO (R_CAI,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_CAI\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x17: Modifiable call relative.  */\n   HOWTO (R_CREL,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_CREL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x18: Modifiable branch absolute.  */\n   HOWTO (R_RBA,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x03fffffc,\t\t/* src_mask */\n \t 0x03fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x19: Modifiable branch absolute.  */\n   HOWTO (R_RBAC,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBAC\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1a: Modifiable branch relative.  */\n   HOWTO (R_RBR,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBR_26\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x03fffffc,\t\t/* src_mask */\n \t 0x03fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1b: Modifiable branch absolute.  */\n   HOWTO (R_RBRC,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBRC\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1c: 16 bit Non modifiable absolute branch.  */\n   HOWTO (R_BA,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_BA_16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xfffc,\t\t/* src_mask */\n \t 0xfffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1d: Modifiable branch relative.  */\n   HOWTO (R_RBR,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBR_16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xfffc,\t\t/* src_mask */\n \t 0xfffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1e: Modifiable branch relative.  */\n   HOWTO (R_RBA,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBA_16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (0x1f),\n \n@@ -1068,91 +1068,91 @@ reloc_howto_type xcoff_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLS\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x21: Initial-exec TLS relocation.  */\n   HOWTO (R_TLS_IE,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLS_IE\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x22: Local-dynamic TLS relocation.  */\n   HOWTO (R_TLS_LD,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLS_LD\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x23: Local-exec TLS relocation.  */\n   HOWTO (R_TLS_LE,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLS_LE\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x24: TLS relocation.  */\n   HOWTO (R_TLSM,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLSM\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n \n   /* 0x25: TLS module relocation.  */\n   HOWTO (R_TLSML,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLSM\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO(0x26),\n   EMPTY_HOWTO(0x27),\n@@ -1170,30 +1170,30 @@ reloc_howto_type xcoff_howto_table[] =\n \t 16,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TOCU\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x31: Low-order 16 bit TOC relative relocation.  */\n   HOWTO (R_TOCL,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TOCL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n };\n \n@@ -1375,7 +1375,7 @@ _bfd_strntoll (const char * nptr, int base, unsigned int maxlen)\n \n /* Read in the armap of an XCOFF archive.  */\n \n-bfd_boolean\n+bool\n _bfd_xcoff_slurp_armap (bfd *abfd)\n {\n   file_ptr off;\n@@ -1388,8 +1388,8 @@ _bfd_xcoff_slurp_armap (bfd *abfd)\n \n   if (xcoff_ardata (abfd) == NULL)\n     {\n-      abfd->has_armap = FALSE;\n-      return TRUE;\n+      abfd->has_armap = false;\n+      return true;\n     }\n \n   if (! xcoff_big_format_p (abfd))\n@@ -1400,35 +1400,35 @@ _bfd_xcoff_slurp_armap (bfd *abfd)\n       GET_VALUE_IN_FIELD (off, xcoff_ardata (abfd)->symoff, 10);\n       if (off == 0)\n \t{\n-\t  abfd->has_armap = FALSE;\n-\t  return TRUE;\n+\t  abfd->has_armap = false;\n+\t  return true;\n \t}\n \n       if (bfd_seek (abfd, off, SEEK_SET) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n       /* The symbol table starts with a normal archive header.  */\n       if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR, abfd)\n \t  != SIZEOF_AR_HDR)\n-\treturn FALSE;\n+\treturn false;\n \n       /* Skip the name (normally empty).  */\n       GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n       off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;\n       if (bfd_seek (abfd, off, SEEK_CUR) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n       GET_VALUE_IN_FIELD (sz, hdr.size, 10);\n       if (sz + 1 < 5)\n \t{\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       /* Read in the entire symbol table.  */\n       contents = (bfd_byte *) _bfd_alloc_and_read (abfd, sz + 1, sz);\n       if (contents == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       /* Ensure strings are NULL terminated so we don't wander off the\n \t end of the buffer.  */\n@@ -1440,13 +1440,13 @@ _bfd_xcoff_slurp_armap (bfd *abfd)\n       if (c >= sz / 4)\n \t{\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       bfd_ardata (abfd)->symdefs =\n \t((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));\n       if (bfd_ardata (abfd)->symdefs == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       /* After the count comes a list of four byte file offsets.  */\n       for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 4;\n@@ -1462,35 +1462,35 @@ _bfd_xcoff_slurp_armap (bfd *abfd)\n       GET_VALUE_IN_FIELD (off, xcoff_ardata_big (abfd)->symoff, 10);\n       if (off == 0)\n \t{\n-\t  abfd->has_armap = FALSE;\n-\t  return TRUE;\n+\t  abfd->has_armap = false;\n+\t  return true;\n \t}\n \n       if (bfd_seek (abfd, off, SEEK_SET) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n       /* The symbol table starts with a normal archive header.  */\n       if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)\n \t  != SIZEOF_AR_HDR_BIG)\n-\treturn FALSE;\n+\treturn false;\n \n       /* Skip the name (normally empty).  */\n       GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n       off = ((namlen + 1) & ~ (size_t) 1) + SXCOFFARFMAG;\n       if (bfd_seek (abfd, off, SEEK_CUR) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n       GET_VALUE_IN_FIELD (sz, hdr.size, 10);\n       if (sz + 1 < 9)\n \t{\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       /* Read in the entire symbol table.  */\n       contents = (bfd_byte *) _bfd_alloc_and_read (abfd, sz + 1, sz);\n       if (contents == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       /* Ensure strings are NULL terminated so we don't wander off the\n \t end of the buffer.  */\n@@ -1502,13 +1502,13 @@ _bfd_xcoff_slurp_armap (bfd *abfd)\n       if (c >= sz / 8)\n \t{\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       bfd_ardata (abfd)->symdefs =\n \t((carsym *) bfd_alloc (abfd, c * sizeof (carsym)));\n       if (bfd_ardata (abfd)->symdefs == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       /* After the count comes a list of eight byte file offsets.  */\n       for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;\n@@ -1526,15 +1526,15 @@ _bfd_xcoff_slurp_armap (bfd *abfd)\n       if (p >= cend)\n \t{\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       arsym->name = (char *) p;\n     }\n \n   bfd_ardata (abfd)->symdef_count = c;\n-  abfd->has_armap = TRUE;\n+  abfd->has_armap = true;\n \n-  return TRUE;\n+  return true;\n }\n \n /* See if this is an XCOFF archive.  */\n@@ -1815,7 +1815,7 @@ normalize_filename (bfd *abfd)\n \n /* Write out an XCOFF armap.  */\n \n-static bfd_boolean\n+static bool\n xcoff_write_armap_old (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n \t\t       struct orl *map, unsigned int orl_count, int stridx)\n {\n@@ -1844,11 +1844,11 @@ xcoff_write_armap_old (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n       != SIZEOF_AR_HDR\n       || (bfd_bwrite (XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)\n \t  != SXCOFFARFMAG))\n-    return FALSE;\n+    return false;\n \n   H_PUT_32 (abfd, orl_count, buf);\n   if (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)\n-    return FALSE;\n+    return false;\n \n   i = 0;\n   archive_iterator_begin (&iterator, abfd);\n@@ -1857,7 +1857,7 @@ xcoff_write_armap_old (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n       {\n \tH_PUT_32 (abfd, iterator.current.offset, buf);\n \tif (bfd_bwrite (buf, (bfd_size_type) 4, abfd) != 4)\n-\t  return FALSE;\n+\t  return false;\n \t++i;\n       }\n \n@@ -1869,7 +1869,7 @@ xcoff_write_armap_old (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n       name = *map[i].name;\n       namlen = strlen (name);\n       if (bfd_bwrite (name, (bfd_size_type) (namlen + 1), abfd) != namlen + 1)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if ((stridx & 1) != 0)\n@@ -1878,10 +1878,10 @@ xcoff_write_armap_old (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n \n       b = '\\0';\n       if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n static char buff20[XCOFFARMAGBIG_ELEMENT_SIZE + 1];\n@@ -1916,38 +1916,38 @@ static char buff20[XCOFFARMAGBIG_ELEMENT_SIZE + 1];\n   memcpy (buff20, (d), 20), \\\n   (v) = bfd_scan_vma (buff20, (const char **) NULL, 10)\n \n-static bfd_boolean\n+static bool\n do_pad (bfd *abfd, unsigned int number)\n {\n   bfd_byte b = 0;\n \n   /* Limit pad to <= 4096.  */\n   if (number > 4096)\n-    return FALSE;\n+    return false;\n \n   while (number--)\n     if (bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)\n-      return FALSE;\n+      return false;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n do_copy (bfd *out_bfd, bfd *in_bfd)\n {\n   bfd_size_type remaining;\n   bfd_byte buffer[DEFAULT_BUFFERSIZE];\n \n   if (bfd_seek (in_bfd, (file_ptr) 0, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   remaining = arelt_size (in_bfd);\n \n   while (remaining >= DEFAULT_BUFFERSIZE)\n     {\n       if (bfd_bread (buffer, DEFAULT_BUFFERSIZE, in_bfd) != DEFAULT_BUFFERSIZE\n \t  || bfd_bwrite (buffer, DEFAULT_BUFFERSIZE, out_bfd) != DEFAULT_BUFFERSIZE)\n-\treturn FALSE;\n+\treturn false;\n \n       remaining -= DEFAULT_BUFFERSIZE;\n     }\n@@ -1956,13 +1956,13 @@ do_copy (bfd *out_bfd, bfd *in_bfd)\n     {\n       if (bfd_bread (buffer, remaining, in_bfd) != remaining\n \t  || bfd_bwrite (buffer, remaining, out_bfd) != remaining)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_write_armap_big (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n \t\t       struct orl *map, unsigned int orl_count, int stridx)\n {\n@@ -2050,7 +2050,7 @@ xcoff_write_armap_big (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n \n       symbol_table = bfd_zmalloc (symbol_table_size);\n       if (symbol_table == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       hdr = (struct xcoff_ar_hdr_big *) symbol_table;\n \n@@ -2135,7 +2135,7 @@ xcoff_write_armap_big (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n \n       symbol_table = bfd_zmalloc (symbol_table_size);\n       if (symbol_table == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       hdr = (struct xcoff_ar_hdr_big *) symbol_table;\n \n@@ -2199,10 +2199,10 @@ xcoff_write_armap_big (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n   else\n     PRINT20 (fhdr->symoff64, 0);\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n _bfd_xcoff_write_armap (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n \t\t\tstruct orl *map, unsigned int orl_count, int stridx)\n {\n@@ -2215,16 +2215,16 @@ _bfd_xcoff_write_armap (bfd *abfd, unsigned int elength ATTRIBUTE_UNUSED,\n /* Write out an XCOFF archive.  We always write an entire archive,\n    rather than fussing with the freelist and so forth.  */\n \n-static bfd_boolean\n+static bool\n xcoff_write_archive_contents_old (bfd *abfd)\n {\n   struct archive_iterator iterator;\n   struct xcoff_ar_file_hdr fhdr;\n   bfd_size_type count;\n   bfd_size_type total_namlen;\n   file_ptr *offsets;\n-  bfd_boolean makemap;\n-  bfd_boolean hasobjects;\n+  bool makemap;\n+  bool hasobjects;\n   file_ptr prevoff, nextoff;\n   bfd *sub;\n   size_t i;\n@@ -2248,7 +2248,7 @@ xcoff_write_archive_contents_old (bfd *abfd)\n \t{\n \t  sub->arelt_data = bfd_zmalloc (sizeof (struct areltdata));\n \t  if (sub->arelt_data == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t}\n       if (arch_xhdr (sub) == NULL)\n \t{\n@@ -2269,7 +2269,7 @@ xcoff_write_archive_contents_old (bfd *abfd)\n \t  else if (stat (bfd_get_filename (sub), &s) != 0)\n \t    {\n \t      bfd_set_input_error (sub, bfd_error_system_call);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  if ((abfd->flags & BFD_DETERMINISTIC_OUTPUT) != 0)\n@@ -2282,7 +2282,7 @@ xcoff_write_archive_contents_old (bfd *abfd)\n \n \t  ahdrp = bfd_zalloc (sub, sizeof (*ahdrp));\n \t  if (ahdrp == NULL)\n-\t    return FALSE;\n+\t    return false;\n \n \t  sprintf (ahdrp->size, \"%ld\", (long) s.st_size);\n \t  sprintf (ahdrp->date, \"%ld\", (long) s.st_mtime);\n@@ -2296,13 +2296,13 @@ xcoff_write_archive_contents_old (bfd *abfd)\n     }\n   offsets = (file_ptr *) bfd_alloc (abfd, count * sizeof (file_ptr));\n   if (offsets == NULL)\n-    return FALSE;\n+    return false;\n \n   if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   makemap = bfd_has_map (abfd);\n-  hasobjects = FALSE;\n+  hasobjects = false;\n   prevoff = 0;\n   for (archive_iterator_begin (&iterator, abfd), i = 0;\n        archive_iterator_next (&iterator);\n@@ -2314,7 +2314,7 @@ xcoff_write_archive_contents_old (bfd *abfd)\n       if (makemap && ! hasobjects)\n \t{\n \t  if (bfd_check_format (iterator.current.member, bfd_object))\n-\t    hasobjects = TRUE;\n+\t    hasobjects = true;\n \t}\n \n       ahdrp = arch_xhdr (iterator.current.member);\n@@ -2328,7 +2328,7 @@ xcoff_write_archive_contents_old (bfd *abfd)\n \t  *p = ' ';\n \n       if (!do_pad (abfd, iterator.current.leading_padding))\n-\treturn FALSE;\n+\treturn false;\n \n       BFD_ASSERT (iterator.current.offset == bfd_tell (abfd));\n       namlen = iterator.current.padded_namlen;\n@@ -2338,7 +2338,7 @@ xcoff_write_archive_contents_old (bfd *abfd)\n \t  || bfd_seek (iterator.current.member, 0, SEEK_SET) != 0\n \t  || !do_copy (abfd, iterator.current.member)\n \t  || !do_pad (abfd, iterator.current.trailing_padding))\n-\treturn FALSE;\n+\treturn false;\n \n       offsets[i] = iterator.current.offset;\n       prevoff = iterator.current.offset;\n@@ -2386,18 +2386,18 @@ xcoff_write_archive_contents_old (bfd *abfd)\n        != SIZEOF_AR_HDR)\n       || (bfd_bwrite (XCOFFARFMAG, (bfd_size_type) SXCOFFARFMAG, abfd)\n \t  != SXCOFFARFMAG))\n-    return FALSE;\n+    return false;\n \n   sprintf (decbuf, \"%-12ld\", (long) count);\n   if (bfd_bwrite (decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE, abfd)\n       != XCOFFARMAG_ELEMENT_SIZE)\n-    return FALSE;\n+    return false;\n   for (i = 0; i < (size_t) count; i++)\n     {\n       sprintf (decbuf, \"%-12ld\", (long) offsets[i]);\n       if (bfd_bwrite (decbuf, (bfd_size_type) XCOFFARMAG_ELEMENT_SIZE,\n \t\t      abfd) != XCOFFARMAG_ELEMENT_SIZE)\n-\treturn FALSE;\n+\treturn false;\n     }\n   for (sub = abfd->archive_head; sub != NULL; sub = sub->archive_next)\n     {\n@@ -2407,11 +2407,11 @@ xcoff_write_archive_contents_old (bfd *abfd)\n       name = normalize_filename (sub);\n       namlen = strlen (name);\n       if (bfd_bwrite (name, namlen + 1, abfd) != namlen + 1)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   if (! do_pad (abfd, size & 1))\n-    return FALSE;\n+    return false;\n \n   /* Write out the armap, if appropriate.  */\n   if (! makemap || ! hasobjects)\n@@ -2422,7 +2422,7 @@ xcoff_write_archive_contents_old (bfd *abfd)\n       sprintf (fhdr.symoff, \"%ld\", (long) nextoff);\n       bfd_ardata (abfd)->tdata = &fhdr;\n       if (! _bfd_compute_and_write_armap (abfd, 0))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Write out the archive file header.  */\n@@ -2435,20 +2435,20 @@ xcoff_write_archive_contents_old (bfd *abfd)\n   if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0\n       || (bfd_bwrite (&fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR, abfd)\n \t  != SIZEOF_AR_FILE_HDR))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_write_archive_contents_big (bfd *abfd)\n {\n   struct xcoff_ar_file_hdr_big fhdr;\n   bfd_size_type count;\n   bfd_size_type total_namlen;\n   file_ptr *offsets;\n-  bfd_boolean makemap;\n-  bfd_boolean hasobjects;\n+  bool makemap;\n+  bool hasobjects;\n   file_ptr prevoff, nextoff;\n   bfd *current_bfd;\n   size_t i;\n@@ -2462,11 +2462,11 @@ xcoff_write_archive_contents_big (bfd *abfd)\n   memcpy (fhdr.magic, XCOFFARMAGBIG, SXCOFFARMAG);\n \n   if (bfd_seek (abfd, (file_ptr) SIZEOF_AR_FILE_HDR_BIG, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   /* Calculate count and total_namlen.  */\n   makemap = bfd_has_map (abfd);\n-  hasobjects = FALSE;\n+  hasobjects = false;\n   for (current_bfd = abfd->archive_head, count = 0, total_namlen = 0;\n        current_bfd != NULL;\n        current_bfd = current_bfd->archive_next, count++)\n@@ -2476,14 +2476,14 @@ xcoff_write_archive_contents_big (bfd *abfd)\n       if (makemap\n \t  && ! hasobjects\n \t  && bfd_check_format (current_bfd, bfd_object))\n-\thasobjects = TRUE;\n+\thasobjects = true;\n \n       if (current_bfd->arelt_data == NULL)\n \t{\n \t  size = sizeof (struct areltdata);\n \t  current_bfd->arelt_data = bfd_zmalloc (size);\n \t  if (current_bfd->arelt_data == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n       if (arch_xhdr_big (current_bfd) == NULL)\n@@ -2505,7 +2505,7 @@ xcoff_write_archive_contents_big (bfd *abfd)\n \t  else if (stat (bfd_get_filename (current_bfd), &s) != 0)\n \t    {\n \t      bfd_set_input_error (current_bfd, bfd_error_system_call);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  if ((abfd->flags & BFD_DETERMINISTIC_OUTPUT) != 0)\n@@ -2518,7 +2518,7 @@ xcoff_write_archive_contents_big (bfd *abfd)\n \n \t  ahdrp = bfd_zalloc (current_bfd, sizeof (*ahdrp));\n \t  if (ahdrp == NULL)\n-\t    return FALSE;\n+\t    return false;\n \n \t  PRINT20 (ahdrp->size, s.st_size);\n \t  PRINT12 (ahdrp->date, s.st_mtime);\n@@ -2536,7 +2536,7 @@ xcoff_write_archive_contents_big (bfd *abfd)\n     {\n       offsets = (file_ptr *) bfd_malloc (count * sizeof (file_ptr));\n       if (offsets == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   prevoff = 0;\n@@ -2555,7 +2555,7 @@ xcoff_write_archive_contents_big (bfd *abfd)\n       if (!do_pad (abfd, iterator.current.leading_padding))\n \t{\n \t  free (offsets);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       BFD_ASSERT (iterator.current.offset == bfd_tell (abfd));\n@@ -2568,7 +2568,7 @@ xcoff_write_archive_contents_big (bfd *abfd)\n \t  || !do_pad (abfd, iterator.current.trailing_padding))\n \t{\n \t  free (offsets);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       offsets[i] = iterator.current.offset;\n@@ -2616,7 +2616,7 @@ xcoff_write_archive_contents_big (bfd *abfd)\n   if (member_table == NULL)\n     {\n       free (offsets);\n-      return FALSE;\n+      return false;\n     }\n \n   hdr = (struct xcoff_ar_hdr_big *) member_table;\n@@ -2666,7 +2666,7 @@ xcoff_write_archive_contents_big (bfd *abfd)\n     }\n \n   if (bfd_bwrite (member_table, member_table_size, abfd) != member_table_size)\n-    return FALSE;\n+    return false;\n \n   free (member_table);\n \n@@ -2688,20 +2688,20 @@ xcoff_write_archive_contents_big (bfd *abfd)\n \n       bfd_ardata (abfd)->tdata = &fhdr;\n       if (! _bfd_compute_and_write_armap (abfd, 0))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Write out the archive file header.  */\n \n   if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0\n       || (bfd_bwrite (&fhdr, (bfd_size_type) SIZEOF_AR_FILE_HDR_BIG,\n \t\t      abfd) != SIZEOF_AR_FILE_HDR_BIG))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n _bfd_xcoff_write_archive_contents (bfd *abfd)\n {\n   if (! xcoff_big_format_p (abfd))\n@@ -2922,7 +2922,7 @@ xcoff_swap_ldrel_out (bfd *abfd, const struct internal_ldrel *src, void * d)\n }\n \f\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_noop (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t       asection *input_section ATTRIBUTE_UNUSED,\n \t\t       bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -2934,10 +2934,10 @@ xcoff_reloc_type_noop (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t       bfd_vma *relocation ATTRIBUTE_UNUSED,\n \t\t       bfd_byte *contents ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_fail (bfd *input_bfd,\n \t\t       asection *input_section ATTRIBUTE_UNUSED,\n \t\t       bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -2954,10 +2954,10 @@ xcoff_reloc_type_fail (bfd *input_bfd,\n     (_(\"%pB: unsupported relocation type %#x\"),\n      input_bfd, (unsigned int) rel->r_type);\n   bfd_set_error (bfd_error_bad_value);\n-  return FALSE;\n+  return false;\n }\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_pos (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t      asection *input_section ATTRIBUTE_UNUSED,\n \t\t      bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -2970,10 +2970,10 @@ xcoff_reloc_type_pos (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t      bfd_byte *contents ATTRIBUTE_UNUSED)\n {\n   *relocation = val + addend;\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_neg (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t      asection *input_section ATTRIBUTE_UNUSED,\n \t\t      bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -2986,10 +2986,10 @@ xcoff_reloc_type_neg (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t      bfd_byte *contents ATTRIBUTE_UNUSED)\n {\n   *relocation = addend - val;\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_rel (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t      asection *input_section,\n \t\t      bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -3001,18 +3001,18 @@ xcoff_reloc_type_rel (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t      bfd_vma *relocation,\n \t\t      bfd_byte *contents ATTRIBUTE_UNUSED)\n {\n-  howto->pc_relative = TRUE;\n+  howto->pc_relative = true;\n \n   /* A PC relative reloc includes the section address.  */\n   addend += input_section->vma;\n \n   *relocation = val + addend;\n   *relocation -= (input_section->output_section->vma\n \t\t  + input_section->output_offset);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_toc (bfd *input_bfd,\n \t\t      asection *input_section ATTRIBUTE_UNUSED,\n \t\t      bfd *output_bfd,\n@@ -3027,7 +3027,7 @@ xcoff_reloc_type_toc (bfd *input_bfd,\n   struct xcoff_link_hash_entry *h;\n \n   if (0 > rel->r_symndx)\n-    return FALSE;\n+    return false;\n \n   h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];\n \n@@ -3040,7 +3040,7 @@ xcoff_reloc_type_toc (bfd *input_bfd,\n \t    (_(\"%pB: TOC reloc at %#\" PRIx64 \" to symbol `%s' with no TOC entry\"),\n \t     input_bfd, (uint64_t) rel->r_vaddr, h->root.root.string);\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);\n@@ -3058,10 +3058,10 @@ xcoff_reloc_type_toc (bfd *input_bfd,\n   if (rel->r_type == R_TOCL)\n     *relocation = *relocation & 0x0000ffff;\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_ba (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t     asection *input_section ATTRIBUTE_UNUSED,\n \t\t     bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -3078,10 +3078,10 @@ xcoff_reloc_type_ba (bfd *input_bfd ATTRIBUTE_UNUSED,\n \n   *relocation = val + addend;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_reloc_type_br (bfd *input_bfd,\n \t\t     asection *input_section,\n \t\t     bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -3097,7 +3097,7 @@ xcoff_reloc_type_br (bfd *input_bfd,\n   bfd_vma section_offset;\n \n   if (0 > rel->r_symndx)\n-    return FALSE;\n+    return false;\n \n   h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];\n   section_offset = rel->r_vaddr - input_section->vma;\n@@ -3172,22 +3172,22 @@ xcoff_reloc_type_br (bfd *input_bfd,\n       bfd_put_32 (input_bfd, insn, ptr);\n \n       /* Make the howto absolute too.  */\n-      howto->pc_relative = FALSE;\n+      howto->pc_relative = false;\n       howto->complain_on_overflow = complain_overflow_bitfield;\n     }\n   else\n     {\n       /* Use a PC-relative howto and subtract the instruction's address\n \t from the target address we calculated above.  */\n-      howto->pc_relative = TRUE;\n+      howto->pc_relative = true;\n       *relocation -= (input_section->output_section->vma\n \t\t      + input_section->output_offset\n \t\t      + section_offset);\n     }\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_crel (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t       asection *input_section,\n \t\t       bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -3199,7 +3199,7 @@ xcoff_reloc_type_crel (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t       bfd_vma *relocation,\n \t\t       bfd_byte *contents ATTRIBUTE_UNUSED)\n {\n-  howto->pc_relative = TRUE;\n+  howto->pc_relative = true;\n   howto->src_mask &= ~3;\n   howto->dst_mask = howto->src_mask;\n \n@@ -3209,10 +3209,10 @@ xcoff_reloc_type_crel (bfd *input_bfd ATTRIBUTE_UNUSED,\n   *relocation = val + addend;\n   *relocation -= (input_section->output_section->vma\n \t\t  + input_section->output_offset);\n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n xcoff_reloc_type_tls (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t      asection *input_section ATTRIBUTE_UNUSED,\n \t\t      bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -3227,7 +3227,7 @@ xcoff_reloc_type_tls (bfd *input_bfd ATTRIBUTE_UNUSED,\n   struct xcoff_link_hash_entry *h;\n \n   if (0 > rel->r_symndx)\n-    return FALSE;\n+    return false;\n \n   h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];\n \n@@ -3237,7 +3237,7 @@ xcoff_reloc_type_tls (bfd *input_bfd ATTRIBUTE_UNUSED,\n   if (howto->type == R_TLSML)\n     {\n       *relocation = 0;\n-      return TRUE;\n+      return true;\n     }\n \n   /* FIXME: h is sometimes null, if the TLS symbol is not exported.  */\n@@ -3247,7 +3247,7 @@ xcoff_reloc_type_tls (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t(_(\"%pB: TLS relocation at (0x%\" BFD_VMA_FMT \"x) over \"\n \t   \"internal symbols (C_HIDEXT) not yet possible\\n\"),\n \t input_bfd, rel->r_vaddr);\n-      return FALSE;\n+      return false;\n     }\n \n \n@@ -3258,7 +3258,7 @@ xcoff_reloc_type_tls (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t(_(\"%pB: TLS relocation at (0x%\" BFD_VMA_FMT \"x) over \"\n \t   \"non-TLS symbol %s (0x%x)\\n\"),\n \t input_bfd, rel->r_vaddr, h->root.root.string, h->smclas);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Local TLS relocations must target a local symbol, ie\n@@ -3272,7 +3272,7 @@ xcoff_reloc_type_tls (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t(_(\"%pB: TLS local relocation at (0x%\" BFD_VMA_FMT \"x) over \"\n \t   \"imported symbol %s\\n\"),\n \t input_bfd, rel->r_vaddr, h->root.root.string);\n-      return FALSE;\n+      return false;\n     }\n \n   /* R_TLSM and R_TLSML are relocations used by the loader.\n@@ -3281,7 +3281,7 @@ xcoff_reloc_type_tls (bfd *input_bfd ATTRIBUTE_UNUSED,\n   if (howto->type == R_TLSM)\n     {\n       *relocation = 0;\n-      return TRUE;\n+      return true;\n     }\n \n   /* Other TLS relocations aims to put offsets from TLS pointers\n@@ -3291,20 +3291,20 @@ xcoff_reloc_type_tls (bfd *input_bfd ATTRIBUTE_UNUSED,\n      TODO: implement optimization when tls size is < 62K.  */\n   *relocation = val + addend;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_complain_overflow_dont_func (bfd *input_bfd ATTRIBUTE_UNUSED,\n \t\t\t\t   bfd_vma val ATTRIBUTE_UNUSED,\n \t\t\t\t   bfd_vma relocation ATTRIBUTE_UNUSED,\n \t\t\t\t   struct reloc_howto_struct *\n \t\t\t\t      howto ATTRIBUTE_UNUSED)\n {\n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_complain_overflow_bitfield_func (bfd *input_bfd,\n \t\t\t\t       bfd_vma val,\n \t\t\t\t       bfd_vma relocation,\n@@ -3350,7 +3350,7 @@ xcoff_complain_overflow_bitfield_func (bfd *input_bfd,\n \t ones, we are OK, assuming a signed bitfield.  */\n       ss = (signmask << howto->rightshift) - 1;\n       if ((ss | relocation) != ~ (bfd_vma) 0)\n-\treturn TRUE;\n+\treturn true;\n       a &= fieldmask;\n     }\n \n@@ -3363,7 +3363,7 @@ xcoff_complain_overflow_bitfield_func (bfd *input_bfd,\n      away from the location at which it is linked.  */\n   if ((unsigned) howto->bitsize + howto->rightshift\n       == bfd_arch_bits_per_address (input_bfd))\n-    return FALSE;\n+    return false;\n \n   sum = a + b;\n   if (sum < a || (sum & ~ fieldmask) != 0)\n@@ -3372,13 +3372,13 @@ xcoff_complain_overflow_bitfield_func (bfd *input_bfd,\n \t for signed operands again.  Here is the overflow test\n \t is as for complain_overflow_signed.  */\n       if (((~ (a ^ b)) & (a ^ sum)) & signmask)\n-\treturn TRUE;\n+\treturn true;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_complain_overflow_signed_func (bfd *input_bfd,\n \t\t\t\t     bfd_vma val,\n \t\t\t\t     bfd_vma relocation,\n@@ -3404,7 +3404,7 @@ xcoff_complain_overflow_signed_func (bfd *input_bfd,\n   signmask = ~ (fieldmask >> 1);\n   ss = a & signmask;\n   if (ss != 0 && ss != ((addrmask >> howto->rightshift) & signmask))\n-    return TRUE;\n+    return true;\n \n   /* We only need this next bit of code if the sign bit of B\n      is below the sign bit of A.  This would only happen if\n@@ -3434,12 +3434,12 @@ xcoff_complain_overflow_signed_func (bfd *input_bfd,\n   */\n   signmask = (fieldmask >> 1) + 1;\n   if (((~ (a ^ b)) & (a ^ sum)) & signmask)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_complain_overflow_unsigned_func (bfd *input_bfd,\n \t\t\t\t       bfd_vma val,\n \t\t\t\t       bfd_vma relocation,\n@@ -3472,9 +3472,9 @@ xcoff_complain_overflow_unsigned_func (bfd *input_bfd,\n   b = (b & addrmask) >> howto->bitpos;\n   sum = (a + b) & addrmask;\n   if ((a | b | sum) & ~ fieldmask)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* This is the relocation function for the RS/6000/POWER/PowerPC.\n@@ -3625,7 +3625,7 @@ xcoff_complain_overflow_unsigned_func (bfd *input_bfd,\n    low-order 16 bit of a TOC relative relocation.\n */\n \n-bfd_boolean\n+bool\n xcoff_ppc_relocate_section (bfd *output_bfd,\n \t\t\t    struct bfd_link_info *info,\n \t\t\t    bfd *input_bfd,\n@@ -3680,7 +3680,7 @@ xcoff_ppc_relocate_section (bfd *output_bfd,\n \t\t(_(\"%pB: relocatation (%d) at (0x%\" BFD_VMA_FMT \"x) has wrong\"\n \t\t   \" r_rsize (0x%x)\\n\"),\n \t\t input_bfd, rel->r_type, rel->r_vaddr, rel->r_size);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \n@@ -3758,7 +3758,7 @@ xcoff_ppc_relocate_section (bfd *output_bfd,\n \t  || !((*xcoff_calculate_relocation[rel->r_type])\n \t       (input_bfd, input_section, output_bfd, rel, sym, &howto, val,\n \t\taddend, &relocation, contents)))\n-\treturn FALSE;\n+\treturn false;\n \n       /* address */\n       address = rel->r_vaddr - input_section->vma;\n@@ -3821,7 +3821,7 @@ xcoff_ppc_relocate_section (bfd *output_bfd,\n \tbfd_put_32 (input_bfd, value_to_relocate, location);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* gcc-8 warns (*) on all the strncpy calls in this function about\n@@ -3841,7 +3841,7 @@ xcoff_ppc_relocate_section (bfd *output_bfd,\n # pragma GCC diagnostic push\n # pragma GCC diagnostic ignored \"-Wstringop-truncation\"\n #endif\n-static bfd_boolean\n+static bool\n _bfd_xcoff_put_ldsymbol_name (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t      struct xcoff_loader_info *ldinfo,\n \t\t\t      struct internal_ldsym *ldsym,\n@@ -3868,8 +3868,8 @@ _bfd_xcoff_put_ldsymbol_name (bfd *abfd ATTRIBUTE_UNUSED,\n \t  newstrings = bfd_realloc (ldinfo->strings, newalc);\n \t  if (newstrings == NULL)\n \t    {\n-\t      ldinfo->failed = TRUE;\n-\t      return FALSE;\n+\t      ldinfo->failed = true;\n+\t      return false;\n \t    }\n \t  ldinfo->string_alc = newalc;\n \t  ldinfo->strings = newstrings;\n@@ -3883,10 +3883,10 @@ _bfd_xcoff_put_ldsymbol_name (bfd *abfd ATTRIBUTE_UNUSED,\n       ldinfo->string_size += len + 3;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n _bfd_xcoff_put_symbol_name (struct bfd_link_info *info,\n \t\t\t    struct bfd_strtab_hash *strtab,\n \t\t\t    struct internal_syment *sym,\n@@ -3898,17 +3898,17 @@ _bfd_xcoff_put_symbol_name (struct bfd_link_info *info,\n     }\n   else\n     {\n-      bfd_boolean hash;\n+      bool hash;\n       bfd_size_type indx;\n \n       hash = !info->traditional_format;\n-      indx = _bfd_stringtab_add (strtab, name, hash, FALSE);\n+      indx = _bfd_stringtab_add (strtab, name, hash, false);\n       if (indx == (bfd_size_type) -1)\n-\treturn FALSE;\n+\treturn false;\n       sym->_n._n_n._n_zeroes = 0;\n       sym->_n._n_n._n_offset = STRING_SIZE_SIZE + indx;\n     }\n-  return TRUE;\n+  return true;\n }\n #if GCC_VERSION >= 8000\n # pragma GCC diagnostic pop\n@@ -3948,22 +3948,22 @@ xcoff_create_csect_from_smclas (bfd *abfd,\n   return return_value;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_is_lineno_count_overflow (bfd *abfd ATTRIBUTE_UNUSED, bfd_vma value)\n {\n   if (0xffff <= value)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n xcoff_is_reloc_count_overflow (bfd *abfd ATTRIBUTE_UNUSED, bfd_vma value)\n {\n   if (0xffff <= value)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n static bfd_vma\n@@ -3979,9 +3979,9 @@ xcoff_loader_reloc_offset (bfd *abfd, struct internal_ldhdr *ldhdr)\n   return bfd_xcoff_ldhdrsz (abfd) + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (abfd);\n }\n \n-static bfd_boolean\n+static bool\n xcoff_generate_rtinit  (bfd *abfd, const char *init, const char *fini,\n-\t\t\tbfd_boolean rtld)\n+\t\t\tbool rtld)\n {\n   bfd_byte filehdr_ext[FILHSZ];\n   bfd_byte scnhdr_ext[SCNHSZ];\n@@ -4004,7 +4004,7 @@ xcoff_generate_rtinit  (bfd *abfd, const char *init, const char *fini,\n   char *rtld_name = \"__rtld\";\n \n   if (! bfd_xcoff_rtinit_size (abfd))\n-    return FALSE;\n+    return false;\n \n   initsz = (init == NULL ? 0 : 1 + strlen (init));\n   finisz = (fini == NULL ? 0 : 1 + strlen (fini));\n@@ -4059,7 +4059,7 @@ xcoff_generate_rtinit  (bfd *abfd, const char *init, const char *fini,\n   data_buffer = NULL;\n   data_buffer = (bfd_byte *) bfd_zmalloc (data_buffer_size);\n   if (data_buffer == NULL)\n-    return FALSE;\n+    return false;\n \n   if (initsz)\n     {\n@@ -4095,7 +4095,7 @@ xcoff_generate_rtinit  (bfd *abfd, const char *init, const char *fini,\n       string_table_size += 4;\n       string_table = (bfd_byte *) bfd_zmalloc (string_table_size);\n       if (string_table == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       val = string_table_size;\n       bfd_h_put_32 (abfd, val, &string_table[0]);\n@@ -4256,7 +4256,7 @@ xcoff_generate_rtinit  (bfd *abfd, const char *init, const char *fini,\n   free (data_buffer);\n   data_buffer = NULL;\n \n-  return TRUE;\n+  return true;\n }\n \n \n@@ -4265,15 +4265,15 @@ HOWTO (0,\t\t\t/* type */\n        0,\t\t\t/* rightshift */\n        2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n        32,\t\t\t/* bitsize */\n-       FALSE,\t\t\t/* pc_relative */\n+       false,\t\t\t/* pc_relative */\n        0,\t\t\t/* bitpos */\n        complain_overflow_bitfield, /* complain_on_overflow */\n        0,\t\t\t/* special_function */\n        \"R_POS\",\t\t\t/* name */\n-       TRUE,\t\t\t/* partial_inplace */\n+       true,\t\t\t/* partial_inplace */\n        0xffffffff,\t\t/* src_mask */\n        0xffffffff,\t\t/* dst_mask */\n-       FALSE);\t\t\t/* pcrel_offset */\n+       false);\t\t\t/* pcrel_offset */\n \n /*  glink\n \n@@ -4296,14 +4296,14 @@ static const unsigned long xcoff_glink_code[9] =\n /* Table to convert DWARF flags to section names.  */\n \n const struct xcoff_dwsect_name xcoff_dwsect_names[] = {\n-  { SSUBTYP_DWINFO,  \".dwinfo\",   TRUE },\n-  { SSUBTYP_DWLINE,  \".dwline\",   TRUE },\n-  { SSUBTYP_DWPBNMS, \".dwpbnms\",  TRUE },\n-  { SSUBTYP_DWPBTYP, \".dwpbtyp\",  TRUE },\n-  { SSUBTYP_DWARNGE, \".dwarnge\",  TRUE },\n-  { SSUBTYP_DWABREV, \".dwabrev\",  FALSE },\n-  { SSUBTYP_DWSTR,   \".dwstr\",    TRUE },\n-  { SSUBTYP_DWRNGES, \".dwrnges\",  TRUE }\n+  { SSUBTYP_DWINFO,  \".dwinfo\",   true },\n+  { SSUBTYP_DWLINE,  \".dwline\",   true },\n+  { SSUBTYP_DWPBNMS, \".dwpbnms\",  true },\n+  { SSUBTYP_DWPBTYP, \".dwpbtyp\",  true },\n+  { SSUBTYP_DWARNGE, \".dwarnge\",  true },\n+  { SSUBTYP_DWABREV, \".dwabrev\",  false },\n+  { SSUBTYP_DWSTR,   \".dwstr\",    true },\n+  { SSUBTYP_DWRNGES, \".dwrnges\",  true }\n };\n \n /* For generic entry points.  */\n@@ -4412,10 +4412,10 @@ static const struct xcoff_backend_data_rec bfd_xcoff_backend_data =\n       RELSZ,\n       LINESZ,\n       FILNMLEN,\n-      TRUE,\t\t\t/* _bfd_coff_long_filenames */\n+      true,\t\t\t/* _bfd_coff_long_filenames */\n       XCOFF_NO_LONG_SECTION_NAMES,  /* _bfd_coff_long_section_names */\n       3,\t\t\t/* _bfd_coff_default_section_alignment_power */\n-      FALSE,\t\t\t/* _bfd_coff_force_symnames_in_strings */\n+      false,\t\t\t/* _bfd_coff_force_symnames_in_strings */\n       2,\t\t\t/* _bfd_coff_debug_string_prefix_length */\n       32768,\t\t\t/* _bfd_coff_max_nscns */\n       coff_swap_filehdr_in,\n@@ -4594,10 +4594,10 @@ static const struct xcoff_backend_data_rec bfd_pmac_xcoff_backend_data =\n       RELSZ,\n       LINESZ,\n       FILNMLEN,\n-      TRUE,\t\t\t/* _bfd_coff_long_filenames */\n+      true,\t\t\t/* _bfd_coff_long_filenames */\n       XCOFF_NO_LONG_SECTION_NAMES,  /* _bfd_coff_long_section_names */\n       3,\t\t\t/* _bfd_coff_default_section_alignment_power */\n-      FALSE,\t\t\t/* _bfd_coff_force_symnames_in_strings */\n+      false,\t\t\t/* _bfd_coff_force_symnames_in_strings */\n       2,\t\t\t/* _bfd_coff_debug_string_prefix_length */\n       32768,\t\t\t/* _bfd_coff_max_nscns */\n       coff_swap_filehdr_in,"
    },
    {
      "sha": "10d203f52800ada77b05b89464d88e0232b1f7b7",
      "filename": "bfd/coff-sh.c",
      "status": "modified",
      "additions": 184,
      "deletions": 184,
      "changes": 368,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-sh.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -35,10 +35,10 @@\n #include \"coff/pe.h\"\n \n #ifndef COFF_IMAGE_WITH_PE\n-static bfd_boolean sh_align_load_span\n+static bool sh_align_load_span\n   (bfd *, asection *, bfd_byte *,\n-   bfd_boolean (*) (bfd *, asection *, void *, bfd_byte *, bfd_vma),\n-   void *, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bfd_boolean *);\n+   bool (*) (bfd *, asection *, void *, bfd_byte *, bfd_vma),\n+   void *, bfd_vma **, bfd_vma *, bfd_vma, bfd_vma, bool *);\n \n #define _bfd_sh_align_load_span sh_align_load_span\n #endif\n@@ -75,7 +75,7 @@ static bfd_boolean sh_align_load_span\n /* Return TRUE if this relocation should\n    appear in the output .reloc section.  */\n \n-static bfd_boolean\n+static bool\n in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,\n \t    reloc_howto_type * howto)\n {\n@@ -85,13 +85,13 @@ in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,\n \n static bfd_reloc_status_type\n sh_reloc (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);\n-static bfd_boolean\n+static bool\n sh_relocate_section (bfd *, struct bfd_link_info *, bfd *, asection *,\n \t\t     bfd_byte *, struct internal_reloc *,\n \t\t     struct internal_syment *, asection **);\n-static bfd_boolean\n+static bool\n sh_align_loads (bfd *, asection *, struct internal_reloc *,\n-\t\tbfd_byte *, bfd_boolean *);\n+\t\tbfd_byte *, bool *);\n \n /* The supported relocations.  There are a lot of relocations defined\n    in coff/internal.h which we do not expect to ever see.  */\n@@ -105,15 +105,15 @@ static reloc_howto_type sh_coff_howtos[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_imm32ce\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n #else\n   EMPTY_HOWTO (2),\n #endif\n@@ -129,63 +129,63 @@ static reloc_howto_type sh_coff_howtos[] =\n \t 1,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_pcdisp8by2\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xff,\t\t\t/* src_mask */\n \t 0xff,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (11), /* R_SH_PCDISP8 */\n \n   HOWTO (R_SH_PCDISP,\t\t/* type */\n \t 1,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 12,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_pcdisp12by2\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xfff,\t\t\t/* src_mask */\n \t 0xfff,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (13),\n \n   HOWTO (R_SH_IMM32,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_imm32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (15),\n #ifdef COFF_WITH_PE\n   HOWTO (R_SH_IMAGEBASE,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"rva32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n #else\n   EMPTY_HOWTO (16), /* R_SH_IMM8 */\n #endif\n@@ -199,169 +199,169 @@ static reloc_howto_type sh_coff_howtos[] =\n \t 1,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_unsigned, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_pcrelimm8by2\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xff,\t\t\t/* src_mask */\n \t 0xff,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_PCRELIMM8BY4,\t/* type */\n \t 2,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_unsigned, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_pcrelimm8by4\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xff,\t\t\t/* src_mask */\n \t 0xff,\t\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_IMM16,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_imm16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_SWITCH16,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_switch16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_SWITCH32,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_switch32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_USES,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_uses\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_COUNT,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_count\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_ALIGN,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_align\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_CODE,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_code\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_DATA,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_data\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_LABEL,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_label\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   HOWTO (R_SH_SWITCH8,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t sh_reloc,\t\t/* special_function */\n \t \"r_switch8\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xff,\t\t\t/* src_mask */\n \t 0xff,\t\t\t/* dst_mask */\n-\t FALSE)\t\t\t/* pcrel_offset */\n+\t false)\t\t\t/* pcrel_offset */\n };\n \n #define SH_COFF_HOWTO_COUNT (sizeof sh_coff_howtos / sizeof sh_coff_howtos[0])\n@@ -656,7 +656,7 @@ sh_reloc (bfd *      abfd,\n \n #include \"coffcode.h\"\n \f\n-static bfd_boolean\n+static bool\n sh_relax_delete_bytes (bfd *, asection *, bfd_vma, int);\n \n /* This function handles relaxing on the SH.\n@@ -702,40 +702,40 @@ sh_relax_delete_bytes (bfd *, asection *, bfd_vma, int);\n    align load and store instructions on four byte boundaries if we\n    can, by swapping them with one of the adjacent instructions.  */\n \n-static bfd_boolean\n+static bool\n sh_relax_section (bfd *abfd,\n \t\t  asection *sec,\n \t\t  struct bfd_link_info *link_info,\n-\t\t  bfd_boolean *again)\n+\t\t  bool *again)\n {\n   struct internal_reloc *internal_relocs;\n-  bfd_boolean have_code;\n+  bool have_code;\n   struct internal_reloc *irel, *irelend;\n   bfd_byte *contents = NULL;\n \n-  *again = FALSE;\n+  *again = false;\n \n   if (bfd_link_relocatable (link_info)\n       || (sec->flags & SEC_RELOC) == 0\n       || sec->reloc_count == 0)\n-    return TRUE;\n+    return true;\n \n   if (coff_section_data (abfd, sec) == NULL)\n     {\n       size_t amt = sizeof (struct coff_section_tdata);\n       sec->used_by_bfd = bfd_zalloc (abfd, amt);\n       if (sec->used_by_bfd == NULL)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   internal_relocs = (_bfd_coff_read_internal_relocs\n \t\t     (abfd, sec, link_info->keep_memory,\n-\t\t      (bfd_byte *) NULL, FALSE,\n+\t\t      (bfd_byte *) NULL, false,\n \t\t      (struct internal_reloc *) NULL));\n   if (internal_relocs == NULL)\n     goto error_return;\n \n-  have_code = FALSE;\n+  have_code = false;\n \n   irelend = internal_relocs + sec->reloc_count;\n   for (irel = internal_relocs; irel < irelend; irel++)\n@@ -747,7 +747,7 @@ sh_relax_section (bfd *abfd,\n       bfd_signed_vma foff;\n \n       if (irel->r_type == R_SH_CODE)\n-\thave_code = TRUE;\n+\thave_code = true;\n \n       if (irel->r_type != R_SH_USES)\n \tcontinue;\n@@ -904,12 +904,12 @@ sh_relax_section (bfd *abfd,\n \t the linker is run.  */\n \n       coff_section_data (abfd, sec)->relocs = internal_relocs;\n-      coff_section_data (abfd, sec)->keep_relocs = TRUE;\n+      coff_section_data (abfd, sec)->keep_relocs = true;\n \n       coff_section_data (abfd, sec)->contents = contents;\n-      coff_section_data (abfd, sec)->keep_contents = TRUE;\n+      coff_section_data (abfd, sec)->keep_contents = true;\n \n-      obj_coff_keep_syms (abfd) = TRUE;\n+      obj_coff_keep_syms (abfd) = true;\n \n       /* Replace the jsr with a bsr.  */\n \n@@ -965,7 +965,7 @@ sh_relax_section (bfd *abfd,\n       /* That will change things, so, just in case it permits some\n \t other function call to come within range, we should relax\n \t again.  Note that this is not required, and it may be slow.  */\n-      *again = TRUE;\n+      *again = true;\n \n       /* Now check whether we got a COUNT reloc.  */\n       if (irelcount >= irelend)\n@@ -1006,7 +1006,7 @@ sh_relax_section (bfd *abfd,\n      byte boundaries.  */\n   if (have_code)\n     {\n-      bfd_boolean swapped;\n+      bool swapped;\n \n       /* Get the section contents.  */\n       if (contents == NULL)\n@@ -1026,12 +1026,12 @@ sh_relax_section (bfd *abfd,\n       if (swapped)\n \t{\n \t  coff_section_data (abfd, sec)->relocs = internal_relocs;\n-\t  coff_section_data (abfd, sec)->keep_relocs = TRUE;\n+\t  coff_section_data (abfd, sec)->keep_relocs = true;\n \n \t  coff_section_data (abfd, sec)->contents = contents;\n-\t  coff_section_data (abfd, sec)->keep_contents = TRUE;\n+\t  coff_section_data (abfd, sec)->keep_contents = true;\n \n-\t  obj_coff_keep_syms (abfd) = TRUE;\n+\t  obj_coff_keep_syms (abfd) = true;\n \t}\n     }\n \n@@ -1053,19 +1053,19 @@ sh_relax_section (bfd *abfd,\n \tcoff_section_data (abfd, sec)->contents = contents;\n     }\n \n-  return TRUE;\n+  return true;\n \n  error_return:\n   if (internal_relocs != coff_section_data (abfd, sec)->relocs)\n     free (internal_relocs);\n   if (contents != coff_section_data (abfd, sec)->contents)\n     free (contents);\n-  return FALSE;\n+  return false;\n }\n \n /* Delete some bytes from a section while relaxing.  */\n \n-static bfd_boolean\n+static bool\n sh_relax_delete_bytes (bfd *abfd,\n \t\t       asection *sec,\n \t\t       bfd_vma addr,\n@@ -1127,7 +1127,7 @@ sh_relax_delete_bytes (bfd *abfd,\n       struct internal_syment sym;\n       int off, adjust, oinsn;\n       bfd_signed_vma voff = 0;\n-      bfd_boolean overflow;\n+      bool overflow;\n \n       /* Get the new reloc address.  */\n       nraddr = irel->r_vaddr - sec->vma;\n@@ -1289,7 +1289,7 @@ sh_relax_delete_bytes (bfd *abfd,\n       if (adjust != 0)\n \t{\n \t  oinsn = insn;\n-\t  overflow = FALSE;\n+\t  overflow = false;\n \t  switch (irel->r_type)\n \t    {\n \t    default:\n@@ -1300,14 +1300,14 @@ sh_relax_delete_bytes (bfd *abfd,\n \t    case R_SH_PCRELIMM8BY2:\n \t      insn += adjust / 2;\n \t      if ((oinsn & 0xff00) != (insn & 0xff00))\n-\t\toverflow = TRUE;\n+\t\toverflow = true;\n \t      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);\n \t      break;\n \n \t    case R_SH_PCDISP:\n \t      insn += adjust / 2;\n \t      if ((oinsn & 0xf000) != (insn & 0xf000))\n-\t\toverflow = TRUE;\n+\t\toverflow = true;\n \t      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);\n \t      break;\n \n@@ -1321,21 +1321,21 @@ sh_relax_delete_bytes (bfd *abfd,\n \t\t    ++insn;\n \t\t}\n \t      if ((oinsn & 0xff00) != (insn & 0xff00))\n-\t\toverflow = TRUE;\n+\t\toverflow = true;\n \t      bfd_put_16 (abfd, (bfd_vma) insn, contents + nraddr);\n \t      break;\n \n \t    case R_SH_SWITCH8:\n \t      voff += adjust;\n \t      if (voff < 0 || voff >= 0xff)\n-\t\toverflow = TRUE;\n+\t\toverflow = true;\n \t      bfd_put_8 (abfd, (bfd_vma) voff, contents + nraddr);\n \t      break;\n \n \t    case R_SH_SWITCH16:\n \t      voff += adjust;\n \t      if (voff < - 0x8000 || voff >= 0x8000)\n-\t\toverflow = TRUE;\n+\t\toverflow = true;\n \t      bfd_put_signed_16 (abfd, (bfd_vma) voff, contents + nraddr);\n \t      break;\n \n@@ -1356,7 +1356,7 @@ sh_relax_delete_bytes (bfd *abfd,\n \t\t(_(\"%pB: %#\" PRIx64 \": fatal: reloc overflow while relaxing\"),\n \t\t abfd, (uint64_t) irel->r_vaddr);\n \t      bfd_set_error (bfd_error_bad_value);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \n@@ -1381,10 +1381,10 @@ sh_relax_delete_bytes (bfd *abfd,\n \t FALSE, we should free them, if we are permitted to, when we\n \t leave sh_coff_relax_section.  */\n       internal_relocs = (_bfd_coff_read_internal_relocs\n-\t\t\t (abfd, o, TRUE, (bfd_byte *) NULL, FALSE,\n+\t\t\t (abfd, o, true, (bfd_byte *) NULL, false,\n \t\t\t  (struct internal_reloc *) NULL));\n       if (internal_relocs == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       ocontents = NULL;\n       irelscanend = internal_relocs + o->reloc_count;\n@@ -1420,7 +1420,7 @@ sh_relax_delete_bytes (bfd *abfd,\n \t\t  else\n \t\t    {\n \t\t      if (!bfd_malloc_and_get_section (abfd, o, &ocontents))\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t      /* We always cache the section contents.\n \t\t\t Perhaps, if info->keep_memory is FALSE, we\n \t\t\t should free them, if we are permitted to,\n@@ -1435,7 +1435,7 @@ sh_relax_delete_bytes (bfd *abfd,\n \t\tbfd_put_32 (abfd, val - count,\n \t\t\t    ocontents + irelscan->r_vaddr - o->vma);\n \n-\t      coff_section_data (abfd, o)->keep_contents = TRUE;\n+\t      coff_section_data (abfd, o)->keep_contents = true;\n \t    }\n \t}\n     }\n@@ -1450,7 +1450,7 @@ sh_relax_delete_bytes (bfd *abfd,\n       _bfd_error_handler\n \t(_(\"%pB: fatal: generic symbols retrieved before relaxing\"), abfd);\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Adjust all the symbols.  */\n@@ -1503,7 +1503,7 @@ sh_relax_delete_bytes (bfd *abfd,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \f\n /* This is yet another version of the SH opcode table, used to rapidly\n@@ -2057,7 +2057,7 @@ sh_insn_info (unsigned int insn)\n \n /* See whether an instruction uses a general purpose register.  */\n \n-static bfd_boolean\n+static bool\n sh_insn_uses_reg (unsigned int insn,\n \t\t  const struct sh_opcode *op,\n \t\t  unsigned int reg)\n@@ -2068,24 +2068,24 @@ sh_insn_uses_reg (unsigned int insn,\n \n   if ((f & USES1) != 0\n       && USES1_REG (insn) == reg)\n-    return TRUE;\n+    return true;\n   if ((f & USES2) != 0\n       && USES2_REG (insn) == reg)\n-    return TRUE;\n+    return true;\n   if ((f & USESR0) != 0\n       && reg == 0)\n-    return TRUE;\n+    return true;\n   if ((f & USESAS) && reg == USESAS_REG (insn))\n-    return TRUE;\n+    return true;\n   if ((f & USESR8) && reg == 8)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* See whether an instruction sets a general purpose register.  */\n \n-static bfd_boolean\n+static bool\n sh_insn_sets_reg (unsigned int insn,\n \t\t  const struct sh_opcode *op,\n \t\t  unsigned int reg)\n@@ -2096,35 +2096,35 @@ sh_insn_sets_reg (unsigned int insn,\n \n   if ((f & SETS1) != 0\n       && SETS1_REG (insn) == reg)\n-    return TRUE;\n+    return true;\n   if ((f & SETS2) != 0\n       && SETS2_REG (insn) == reg)\n-    return TRUE;\n+    return true;\n   if ((f & SETSR0) != 0\n       && reg == 0)\n-    return TRUE;\n+    return true;\n   if ((f & SETSAS) && reg == SETSAS_REG (insn))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* See whether an instruction uses or sets a general purpose register */\n \n-static bfd_boolean\n+static bool\n sh_insn_uses_or_sets_reg (unsigned int insn,\n \t\t\t  const struct sh_opcode *op,\n \t\t\t  unsigned int reg)\n {\n   if (sh_insn_uses_reg (insn, op, reg))\n-    return TRUE;\n+    return true;\n \n   return sh_insn_sets_reg (insn, op, reg);\n }\n \n /* See whether an instruction uses a floating point register.  */\n \n-static bfd_boolean\n+static bool\n sh_insn_uses_freg (unsigned int insn,\n \t\t   const struct sh_opcode *op,\n \t\t   unsigned int freg)\n@@ -2144,20 +2144,20 @@ sh_insn_uses_freg (unsigned int insn,\n \n   if ((f & USESF1) != 0\n       && (USESF1_REG (insn) & 0xe) == (freg & 0xe))\n-    return TRUE;\n+    return true;\n   if ((f & USESF2) != 0\n       && (USESF2_REG (insn) & 0xe) == (freg & 0xe))\n-    return TRUE;\n+    return true;\n   if ((f & USESF0) != 0\n       && freg == 0)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* See whether an instruction sets a floating point register.  */\n \n-static bfd_boolean\n+static bool\n sh_insn_sets_freg (unsigned int insn,\n \t\t   const struct sh_opcode *op,\n \t\t   unsigned int freg)\n@@ -2177,20 +2177,20 @@ sh_insn_sets_freg (unsigned int insn,\n \n   if ((f & SETSF1) != 0\n       && (SETSF1_REG (insn) & 0xe) == (freg & 0xe))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* See whether an instruction uses or sets a floating point register */\n \n-static bfd_boolean\n+static bool\n sh_insn_uses_or_sets_freg (unsigned int insn,\n \t\t\t   const struct sh_opcode *op,\n \t\t\t   unsigned int reg)\n {\n   if (sh_insn_uses_freg (insn, op, reg))\n-    return TRUE;\n+    return true;\n \n   return sh_insn_sets_freg (insn, op, reg);\n }\n@@ -2200,7 +2200,7 @@ sh_insn_uses_or_sets_freg (unsigned int insn,\n    This should return TRUE if there is a conflict, or FALSE if the\n    instructions can be swapped safely.  */\n \n-static bfd_boolean\n+static bool\n sh_insns_conflict (unsigned int i1,\n \t\t   const struct sh_opcode *op1,\n \t\t   unsigned int i2,\n@@ -2215,57 +2215,57 @@ sh_insns_conflict (unsigned int i1,\n      FIXME: shouldn't test raw opcodes here.  */\n   if (((i1 & 0xf0ff) == 0x4066 && (i2 & 0xf000) == 0xf000)\n       || ((i2 & 0xf0ff) == 0x4066 && (i1 & 0xf000) == 0xf000))\n-    return TRUE;\n+    return true;\n \n   if ((f1 & (BRANCH | DELAY)) != 0\n       || (f2 & (BRANCH | DELAY)) != 0)\n-    return TRUE;\n+    return true;\n \n   if (((f1 | f2) & SETSSP)\n       && (f1 & (SETSSP | USESSP))\n       && (f2 & (SETSSP | USESSP)))\n-    return TRUE;\n+    return true;\n \n   if ((f1 & SETS1) != 0\n       && sh_insn_uses_or_sets_reg (i2, op2, SETS1_REG (i1)))\n-    return TRUE;\n+    return true;\n   if ((f1 & SETS2) != 0\n       && sh_insn_uses_or_sets_reg (i2, op2, SETS2_REG (i1)))\n-    return TRUE;\n+    return true;\n   if ((f1 & SETSR0) != 0\n       && sh_insn_uses_or_sets_reg (i2, op2, 0))\n-    return TRUE;\n+    return true;\n   if ((f1 & SETSAS)\n       && sh_insn_uses_or_sets_reg (i2, op2, SETSAS_REG (i1)))\n-    return TRUE;\n+    return true;\n   if ((f1 & SETSF1) != 0\n       && sh_insn_uses_or_sets_freg (i2, op2, SETSF1_REG (i1)))\n-    return TRUE;\n+    return true;\n \n   if ((f2 & SETS1) != 0\n       && sh_insn_uses_or_sets_reg (i1, op1, SETS1_REG (i2)))\n-    return TRUE;\n+    return true;\n   if ((f2 & SETS2) != 0\n       && sh_insn_uses_or_sets_reg (i1, op1, SETS2_REG (i2)))\n-    return TRUE;\n+    return true;\n   if ((f2 & SETSR0) != 0\n       && sh_insn_uses_or_sets_reg (i1, op1, 0))\n-    return TRUE;\n+    return true;\n   if ((f2 & SETSAS)\n       && sh_insn_uses_or_sets_reg (i1, op1, SETSAS_REG (i2)))\n-    return TRUE;\n+    return true;\n   if ((f2 & SETSF1) != 0\n       && sh_insn_uses_or_sets_freg (i1, op1, SETSF1_REG (i2)))\n-    return TRUE;\n+    return true;\n \n   /* The instructions do not conflict.  */\n-  return FALSE;\n+  return false;\n }\n \n /* I1 is a load instruction, and I2 is some other instruction.  Return\n    TRUE if I1 loads a register which I2 uses.  */\n \n-static bfd_boolean\n+static bool\n sh_load_use (unsigned int i1,\n \t     const struct sh_opcode *op1,\n \t     unsigned int i2,\n@@ -2276,25 +2276,25 @@ sh_load_use (unsigned int i1,\n   f1 = op1->flags;\n \n   if ((f1 & LOAD) == 0)\n-    return FALSE;\n+    return false;\n \n   /* If both SETS1 and SETSSP are set, that means a load to a special\n      register using postincrement addressing mode, which we don't care\n      about here.  */\n   if ((f1 & SETS1) != 0\n       && (f1 & SETSSP) == 0\n       && sh_insn_uses_reg (i2, op2, (i1 & 0x0f00) >> 8))\n-    return TRUE;\n+    return true;\n \n   if ((f1 & SETSR0) != 0\n       && sh_insn_uses_reg (i2, op2, 0))\n-    return TRUE;\n+    return true;\n \n   if ((f1 & SETSF1) != 0\n       && sh_insn_uses_freg (i2, op2, (i1 & 0x0f00) >> 8))\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n /* Try to align loads and stores within a span of memory.  This is\n@@ -2310,17 +2310,17 @@ sh_load_use (unsigned int i1,\n #ifdef COFF_WITH_PE\n static\n #endif\n-bfd_boolean\n+bool\n _bfd_sh_align_load_span (bfd *abfd,\n \t\t\t asection *sec,\n \t\t\t bfd_byte *contents,\n-\t\t\t bfd_boolean (*swap) (bfd *, asection *, void *, bfd_byte *, bfd_vma),\n+\t\t\t bool (*swap) (bfd *, asection *, void *, bfd_byte *, bfd_vma),\n \t\t\t void * relocs,\n \t\t\t bfd_vma **plabel,\n \t\t\t bfd_vma *label_end,\n \t\t\t bfd_vma start,\n \t\t\t bfd_vma stop,\n-\t\t\t bfd_boolean *pswapped)\n+\t\t\t bool *pswapped)\n {\n   int dsp = (abfd->arch_info->mach == bfd_mach_sh_dsp\n \t     || abfd->arch_info->mach == bfd_mach_sh3_dsp);\n@@ -2330,7 +2330,7 @@ _bfd_sh_align_load_span (bfd *abfd,\n      desirable.  In fact, it is counter-productive, since it interferes\n      with the schedules generated by the compiler.  */\n   if (abfd->arch_info->mach == bfd_mach_sh4)\n-    return TRUE;\n+    return true;\n \n   /* If we are linking sh[3]-dsp code, swap the FPU instructions for DSP\n      instructions.  */\n@@ -2404,14 +2404,14 @@ _bfd_sh_align_load_span (bfd *abfd,\n \t  && (prev_op->flags & (LOAD | STORE)) == 0\n \t  && ! sh_insns_conflict (prev_insn, prev_op, insn, op))\n \t{\n-\t  bfd_boolean ok;\n+\t  bool ok;\n \n \t  /* The load/store instruction does not have a label, and\n \t     there is a previous instruction; PREV_INSN is not\n \t     itself a load/store instruction, and PREV_INSN and\n \t     INSN do not conflict.  */\n \n-\t  ok = TRUE;\n+\t  ok = true;\n \n \t  if (i >= start + 4)\n \t    {\n@@ -2426,7 +2426,7 @@ _bfd_sh_align_load_span (bfd *abfd,\n \t\t can not swap.  */\n \t      if (prev2_op == NULL\n \t\t  || (prev2_op->flags & DELAY) != 0)\n-\t\tok = FALSE;\n+\t\tok = false;\n \n \t      /* If the instruction before PREV_INSN is a load,\n \t\t and it sets a register which INSN uses, then\n@@ -2436,14 +2436,14 @@ _bfd_sh_align_load_span (bfd *abfd,\n \t      if (ok\n \t\t  && (prev2_op->flags & LOAD) != 0\n \t\t  && sh_load_use (prev2_insn, prev2_op, insn, op))\n-\t\tok = FALSE;\n+\t\tok = false;\n \t    }\n \n \t  if (ok)\n \t    {\n \t      if (! (*swap) (abfd, sec, relocs, contents, i - 2))\n-\t\treturn FALSE;\n-\t      *pswapped = TRUE;\n+\t\treturn false;\n+\t      *pswapped = true;\n \t      continue;\n \t    }\n \t}\n@@ -2465,12 +2465,12 @@ _bfd_sh_align_load_span (bfd *abfd,\n \t      && (next_op->flags & (LOAD | STORE)) == 0\n \t      && ! sh_insns_conflict (insn, op, next_insn, next_op))\n \t    {\n-\t      bfd_boolean ok;\n+\t      bool ok;\n \n \t      /* NEXT_INSN is not itself a load/store instruction,\n \t\t and it does not conflict with INSN.  */\n \n-\t      ok = TRUE;\n+\t      ok = true;\n \n \t      /* If PREV_INSN is a load, and it sets a register\n \t\t which NEXT_INSN uses, then putting NEXT_INSN\n@@ -2479,7 +2479,7 @@ _bfd_sh_align_load_span (bfd *abfd,\n \t      if (prev_op != NULL\n \t\t  && (prev_op->flags & LOAD) != 0\n \t\t  && sh_load_use (prev_insn, prev_op, next_insn, next_op))\n-\t\tok = FALSE;\n+\t\tok = false;\n \n \t      /* If INSN is a load, and it sets a register which\n \t\t the insn after NEXT_INSN uses, then doing the\n@@ -2502,27 +2502,27 @@ _bfd_sh_align_load_span (bfd *abfd,\n \t\t  if (next2_op == NULL\n \t\t      || ((next2_op->flags & (LOAD | STORE)) == 0\n \t\t\t  && sh_load_use (insn, op, next2_insn, next2_op)))\n-\t\t    ok = FALSE;\n+\t\t    ok = false;\n \t\t}\n \n \t      if (ok)\n \t\t{\n \t\t  if (! (*swap) (abfd, sec, relocs, contents, i))\n-\t\t    return FALSE;\n-\t\t  *pswapped = TRUE;\n+\t\t    return false;\n+\t\t  *pswapped = true;\n \t\t  continue;\n \t\t}\n \t    }\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n #endif /* not COFF_IMAGE_WITH_PE */\n \n /* Swap two SH instructions.  */\n \n-static bfd_boolean\n+static bool\n sh_swap_insns (bfd *      abfd,\n \t       asection * sec,\n \t       void *     relocs,\n@@ -2589,10 +2589,10 @@ sh_swap_insns (bfd *      abfd,\n \t{\n \t  bfd_byte *loc;\n \t  unsigned short insn, oinsn;\n-\t  bfd_boolean overflow;\n+\t  bool overflow;\n \n \t  loc = contents + irel->r_vaddr - sec->vma;\n-\t  overflow = FALSE;\n+\t  overflow = false;\n \t  switch (type)\n \t    {\n \t    default:\n@@ -2604,7 +2604,7 @@ sh_swap_insns (bfd *      abfd,\n \t      oinsn = insn;\n \t      insn += add / 2;\n \t      if ((oinsn & 0xff00) != (insn & 0xff00))\n-\t\toverflow = TRUE;\n+\t\toverflow = true;\n \t      bfd_put_16 (abfd, (bfd_vma) insn, loc);\n \t      break;\n \n@@ -2613,7 +2613,7 @@ sh_swap_insns (bfd *      abfd,\n \t      oinsn = insn;\n \t      insn += add / 2;\n \t      if ((oinsn & 0xf000) != (insn & 0xf000))\n-\t\toverflow = TRUE;\n+\t\toverflow = true;\n \t      bfd_put_16 (abfd, (bfd_vma) insn, loc);\n \t      break;\n \n@@ -2630,7 +2630,7 @@ sh_swap_insns (bfd *      abfd,\n \t\t  oinsn = insn;\n \t\t  insn += add / 2;\n \t\t  if ((oinsn & 0xff00) != (insn & 0xff00))\n-\t\t    overflow = TRUE;\n+\t\t    overflow = true;\n \t\t  bfd_put_16 (abfd, (bfd_vma) insn, loc);\n \t\t}\n \n@@ -2644,32 +2644,32 @@ sh_swap_insns (bfd *      abfd,\n \t\t(_(\"%pB: %#\" PRIx64 \": fatal: reloc overflow while relaxing\"),\n \t\t abfd, (uint64_t) irel->r_vaddr);\n \t      bfd_set_error (bfd_error_bad_value);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Look for loads and stores which we can align to four byte\n    boundaries.  See the longer comment above sh_relax_section for why\n    this is desirable.  This sets *PSWAPPED if some instruction was\n    swapped.  */\n \n-static bfd_boolean\n+static bool\n sh_align_loads (bfd *abfd,\n \t\tasection *sec,\n \t\tstruct internal_reloc *internal_relocs,\n \t\tbfd_byte *contents,\n-\t\tbfd_boolean *pswapped)\n+\t\tbool *pswapped)\n {\n   struct internal_reloc *irel, *irelend;\n   bfd_vma *labels = NULL;\n   bfd_vma *label, *label_end;\n   bfd_size_type amt;\n \n-  *pswapped = FALSE;\n+  *pswapped = false;\n \n   irelend = internal_relocs + sec->reloc_count;\n \n@@ -2719,17 +2719,17 @@ sh_align_loads (bfd *abfd,\n \n   free (labels);\n \n-  return TRUE;\n+  return true;\n \n  error_return:\n   free (labels);\n-  return FALSE;\n+  return false;\n }\n \f\n /* This is a modification of _bfd_coff_generic_relocate_section, which\n    will handle SH relaxing.  */\n \n-static bfd_boolean\n+static bool\n sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t     struct bfd_link_info *info,\n \t\t     bfd *input_bfd,\n@@ -2781,7 +2781,7 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t\t(_(\"%pB: illegal symbol index %ld in relocs\"),\n \t\t input_bfd, symndx);\n \t      bfd_set_error (bfd_error_bad_value);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  h = obj_coff_sym_hashes (input_bfd)[symndx];\n \t  sym = syms + symndx;\n@@ -2803,7 +2803,7 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n       if (howto == NULL)\n \t{\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n #ifdef COFF_WITH_PE\n@@ -2850,7 +2850,7 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t  else if (! bfd_link_relocatable (info))\n \t    (*info->callbacks->undefined_symbol)\n \t      (info, h->root.root.string, input_bfd, input_section,\n-\t       rel->r_vaddr - input_section->vma, TRUE);\n+\t       rel->r_vaddr - input_section->vma, true);\n \t}\n \n       rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,\n@@ -2891,7 +2891,7 @@ sh_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* This is a version of bfd_generic_get_relocated_section_contents\n@@ -2902,7 +2902,7 @@ sh_coff_get_relocated_section_contents (bfd *output_bfd,\n \t\t\t\t\tstruct bfd_link_info *link_info,\n \t\t\t\t\tstruct bfd_link_order *link_order,\n \t\t\t\t\tbfd_byte *data,\n-\t\t\t\t\tbfd_boolean relocatable,\n+\t\t\t\t\tbool relocatable,\n \t\t\t\t\tasymbol **symbols)\n {\n   asection *input_section = link_order->u.indirect.section;\n@@ -2937,8 +2937,8 @@ sh_coff_get_relocated_section_contents (bfd *output_bfd,\n \tgoto error_return;\n \n       internal_relocs = (_bfd_coff_read_internal_relocs\n-\t\t\t (input_bfd, input_section, FALSE, (bfd_byte *) NULL,\n-\t\t\t  FALSE, (struct internal_reloc *) NULL));\n+\t\t\t (input_bfd, input_section, false, (bfd_byte *) NULL,\n+\t\t\t  false, (struct internal_reloc *) NULL));\n       if (internal_relocs == NULL)\n \tgoto error_return;\n \n@@ -3052,18 +3052,18 @@ coff_small_object_p (bfd *abfd)\n \n /* Set the section alignment for the small versions.  */\n \n-static bfd_boolean\n+static bool\n coff_small_new_section_hook (bfd *abfd, asection *section)\n {\n   if (! coff_new_section_hook (abfd, section))\n-    return FALSE;\n+    return false;\n \n   /* We must align to at least a four byte boundary, because longword\n      accesses must be on a four byte boundary.  */\n   if (section->alignment_power == COFF_DEFAULT_SECTION_ALIGNMENT_POWER)\n     section->alignment_power = 2;\n \n-  return TRUE;\n+  return true;\n }\n \n /* This is copied from bfd_coff_std_swap_table so that we can change\n@@ -3078,16 +3078,16 @@ static bfd_coff_backend_data bfd_coff_small_swap_table =\n   coff_swap_scnhdr_out,\n   FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,\n #ifdef COFF_LONG_FILENAMES\n-  TRUE,\n+  true,\n #else\n-  FALSE,\n+  false,\n #endif\n   COFF_DEFAULT_LONG_SECTION_NAMES,\n   2,\n #ifdef COFF_FORCE_SYMBOLS_IN_STRINGS\n-  TRUE,\n+  true,\n #else\n-  FALSE,\n+  false,\n #endif\n #ifdef COFF_DEBUG_STRING_WIDE_PREFIX\n   4,"
    },
    {
      "sha": "e9fd343ee3c08a20815e20daa7edd106611bcc32",
      "filename": "bfd/coff-stgo32.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-stgo32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-stgo32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-stgo32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -54,12 +54,12 @@\n #include \"coff/msdos.h\"\n \n static bfd_cleanup go32exe_check_format (bfd *);\n-static bfd_boolean go32exe_write_object_contents (bfd *);\n-static bfd_boolean go32exe_mkobject (bfd *);\n-static bfd_boolean go32exe_copy_private_bfd_data (bfd *, bfd *);\n+static bool go32exe_write_object_contents (bfd *);\n+static bool go32exe_mkobject (bfd *);\n+static bool go32exe_copy_private_bfd_data (bfd *, bfd *);\n \n /* Defined in coff-go32.c.  */\n-bfd_boolean _bfd_go32_mkobject (bfd *);\n+bool _bfd_go32_mkobject (bfd *);\n void _bfd_go32_swap_scnhdr_in (bfd *, void *, void *);\n unsigned int _bfd_go32_swap_scnhdr_out (bfd *, void *, void *);\n \n@@ -217,12 +217,12 @@ go32exe_create_stub (bfd *abfd)\n /* If ibfd was a stubbed coff image, copy the stub from that bfd\n    to the new obfd.  */\n \n-static bfd_boolean\n+static bool\n go32exe_copy_private_bfd_data (bfd *ibfd, bfd *obfd)\n {\n   /* Check if both are the same targets.  */\n   if (ibfd->xvec != obfd->xvec)\n-    return TRUE;\n+    return true;\n \n   /* Make sure we have a source stub.  */\n   BFD_ASSERT (coff_data (ibfd)->stub != NULL);\n@@ -231,15 +231,15 @@ go32exe_copy_private_bfd_data (bfd *ibfd, bfd *obfd)\n   if (coff_data (ibfd)->stub_size > coff_data (obfd)->stub_size)\n     coff_data (obfd)->stub = bfd_alloc (obfd, coff_data (ibfd)->stub_size);\n   if (coff_data (obfd)->stub == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Now copy the stub.  */\n   memcpy (coff_data (obfd)->stub, coff_data (ibfd)->stub,\n \t  coff_data (ibfd)->stub_size);\n   coff_data (obfd)->stub_size = coff_data (ibfd)->stub_size;\n   obfd->origin = coff_data (obfd)->stub_size;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Cleanup function, returned from check_format hook.  */\n@@ -332,7 +332,7 @@ go32exe_check_format (bfd *abfd)\n \n /* Write the stub to the output file, then call coff_write_object_contents.  */\n \n-static bfd_boolean\n+static bool\n go32exe_write_object_contents (bfd *abfd)\n {\n   const bfd_size_type pos = bfd_tell (abfd);\n@@ -345,38 +345,38 @@ go32exe_write_object_contents (bfd *abfd)\n   /* Write the stub.  */\n   abfd->origin = 0;\n   if (bfd_seek (abfd, 0, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n   if (bfd_bwrite (coff_data (abfd)->stub, stubsize, abfd) != stubsize)\n-    return FALSE;\n+    return false;\n \n   /* Seek back to where we were.  */\n   abfd->origin = stubsize;\n   if (bfd_seek (abfd, pos, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   return coff_write_object_contents (abfd);\n }\n \n /* mkobject hook.  Called directly through bfd_set_format or via\n    coff_mkobject_hook etc from bfd_check_format.  */\n \n-static bfd_boolean\n+static bool\n go32exe_mkobject (bfd *abfd)\n {\n   /* Don't output to an archive.  */\n   if (abfd->my_archive != NULL)\n-    return FALSE;\n+    return false;\n \n   if (!_bfd_go32_mkobject (abfd))\n-    return FALSE;\n+    return false;\n \n   go32exe_create_stub (abfd);\n   if (coff_data (abfd)->stub == NULL)\n     {\n       bfd_release (abfd, coff_data (abfd));\n-      return FALSE;\n+      return false;\n     }\n   abfd->origin = coff_data (abfd)->stub_size;\n \n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "a3ea69e1a3f819aebb7ed854128deae6a37b3e78",
      "filename": "bfd/coff-tic30.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-tic30.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-tic30.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-tic30.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -31,16 +31,16 @@\n \n reloc_howto_type tic30_coff_howto_table[] =\n   {\n-    HOWTO (R_TIC30_ABS16, 2, 1, 16, FALSE, 0, 0, NULL,\n-\t   \"16\", FALSE, 0x0000FFFF, 0x0000FFFF, FALSE),\n-    HOWTO (R_TIC30_ABS24, 2, 2, 24, FALSE, 8, complain_overflow_bitfield, NULL,\n-\t   \"24\", FALSE, 0xFFFFFF00, 0xFFFFFF00, FALSE),\n-    HOWTO (R_TIC30_LDP, 18, 0, 24, FALSE, 0, complain_overflow_bitfield, NULL,\n-\t   \"LDP\", FALSE, 0x00FF0000, 0x000000FF, FALSE),\n-    HOWTO (R_TIC30_ABS32, 2, 2, 32, FALSE, 0, complain_overflow_bitfield, NULL,\n-\t   \"32\", FALSE, 0xFFFFFFFF, 0xFFFFFFFF, FALSE),\n-    HOWTO (R_TIC30_PC16, 2, 1, 16, TRUE, 0, complain_overflow_signed, NULL,\n-\t   \"PCREL\", FALSE, 0x0000FFFF, 0x0000FFFF, FALSE),\n+    HOWTO (R_TIC30_ABS16, 2, 1, 16, false, 0, 0, NULL,\n+\t   \"16\", false, 0x0000FFFF, 0x0000FFFF, false),\n+    HOWTO (R_TIC30_ABS24, 2, 2, 24, false, 8, complain_overflow_bitfield, NULL,\n+\t   \"24\", false, 0xFFFFFF00, 0xFFFFFF00, false),\n+    HOWTO (R_TIC30_LDP, 18, 0, 24, false, 0, complain_overflow_bitfield, NULL,\n+\t   \"LDP\", false, 0x00FF0000, 0x000000FF, false),\n+    HOWTO (R_TIC30_ABS32, 2, 2, 32, false, 0, complain_overflow_bitfield, NULL,\n+\t   \"32\", false, 0xFFFFFFFF, 0xFFFFFFFF, false),\n+    HOWTO (R_TIC30_PC16, 2, 1, 16, true, 0, complain_overflow_signed, NULL,\n+\t   \"PCREL\", false, 0x0000FFFF, 0x0000FFFF, false),\n     EMPTY_HOWTO (-1)\n   };\n "
    },
    {
      "sha": "8804171ce6a0db37cf28bb8fd239de85d47f81d9",
      "filename": "bfd/coff-tic4x.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-tic4x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-tic4x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-tic4x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,13 +41,13 @@ tic4x_reloc_processing (arelent *, struct internal_reloc *,\n \n /* Replace the stock _bfd_coff_is_local_label_name to recognize TI COFF local\n    labels.  */\n-static bfd_boolean\n+static bool\n ticoff_bfd_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\tconst char *name)\n {\n   if (TICOFF_LOCAL_LABEL_P(name))\n-    return TRUE;\n-  return FALSE;\n+    return true;\n+  return false;\n }\n \n #define coff_bfd_is_local_label_name ticoff_bfd_is_local_label_name\n@@ -92,20 +92,20 @@ tic4x_relocation (bfd *abfd ATTRIBUTE_UNUSED,\n \n reloc_howto_type tic4x_howto_table[] =\n {\n-    HOWTO(R_RELWORD,\t 0,  2, 16, FALSE, 0, complain_overflow_signed,   tic4x_relocation, \"RELWORD\",   TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n-    HOWTO(R_REL24,\t 0,  2, 24, FALSE, 0, complain_overflow_bitfield, tic4x_relocation, \"REL24\",     TRUE, 0x00ffffff, 0x00ffffff, FALSE),\n-    HOWTO(R_RELLONG,\t 0,  2, 32, FALSE, 0, complain_overflow_dont,     tic4x_relocation, \"RELLONG\",   TRUE, 0xffffffff, 0xffffffff, FALSE),\n-    HOWTO(R_PCRWORD,\t 0,  2, 16, TRUE,  0, complain_overflow_signed,   tic4x_relocation, \"PCRWORD\",   TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n-    HOWTO(R_PCR24,\t 0,  2, 24, TRUE,  0, complain_overflow_signed,   tic4x_relocation, \"PCR24\",     TRUE, 0x00ffffff, 0x00ffffff, FALSE),\n-    HOWTO(R_PARTLS16,\t 0,  2, 16, FALSE, 0, complain_overflow_dont,     tic4x_relocation, \"PARTLS16\",  TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n-    HOWTO(R_PARTMS8,\t16,  2, 16, FALSE, 0, complain_overflow_dont,     tic4x_relocation, \"PARTMS8\",   TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n-    HOWTO(R_RELWORD,\t 0,  2, 16, FALSE, 0, complain_overflow_signed,   tic4x_relocation, \"ARELWORD\",  TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n-    HOWTO(R_REL24,\t 0,  2, 24, FALSE, 0, complain_overflow_signed,   tic4x_relocation, \"AREL24\",    TRUE, 0x00ffffff, 0x00ffffff, FALSE),\n-    HOWTO(R_RELLONG,\t 0,  2, 32, FALSE, 0, complain_overflow_signed,   tic4x_relocation, \"ARELLONG\",  TRUE, 0xffffffff, 0xffffffff, FALSE),\n-    HOWTO(R_PCRWORD,\t 0,  2, 16, TRUE,  0, complain_overflow_signed,   tic4x_relocation, \"APCRWORD\",  TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n-    HOWTO(R_PCR24,\t 0,  2, 24, TRUE,  0, complain_overflow_signed,   tic4x_relocation, \"APCR24\",    TRUE, 0x00ffffff, 0x00ffffff, FALSE),\n-    HOWTO(R_PARTLS16,\t 0,  2, 16, FALSE, 0, complain_overflow_dont,     tic4x_relocation, \"APARTLS16\", TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n-    HOWTO(R_PARTMS8,\t16,  2, 16, FALSE, 0, complain_overflow_dont,     tic4x_relocation, \"APARTMS8\",  TRUE, 0x0000ffff, 0x0000ffff, FALSE),\n+    HOWTO(R_RELWORD,\t 0,  2, 16, false, 0, complain_overflow_signed,   tic4x_relocation, \"RELWORD\",   true, 0x0000ffff, 0x0000ffff, false),\n+    HOWTO(R_REL24,\t 0,  2, 24, false, 0, complain_overflow_bitfield, tic4x_relocation, \"REL24\",     true, 0x00ffffff, 0x00ffffff, false),\n+    HOWTO(R_RELLONG,\t 0,  2, 32, false, 0, complain_overflow_dont,     tic4x_relocation, \"RELLONG\",   true, 0xffffffff, 0xffffffff, false),\n+    HOWTO(R_PCRWORD,\t 0,  2, 16, true,  0, complain_overflow_signed,   tic4x_relocation, \"PCRWORD\",   true, 0x0000ffff, 0x0000ffff, false),\n+    HOWTO(R_PCR24,\t 0,  2, 24, true,  0, complain_overflow_signed,   tic4x_relocation, \"PCR24\",     true, 0x00ffffff, 0x00ffffff, false),\n+    HOWTO(R_PARTLS16,\t 0,  2, 16, false, 0, complain_overflow_dont,     tic4x_relocation, \"PARTLS16\",  true, 0x0000ffff, 0x0000ffff, false),\n+    HOWTO(R_PARTMS8,\t16,  2, 16, false, 0, complain_overflow_dont,     tic4x_relocation, \"PARTMS8\",   true, 0x0000ffff, 0x0000ffff, false),\n+    HOWTO(R_RELWORD,\t 0,  2, 16, false, 0, complain_overflow_signed,   tic4x_relocation, \"ARELWORD\",  true, 0x0000ffff, 0x0000ffff, false),\n+    HOWTO(R_REL24,\t 0,  2, 24, false, 0, complain_overflow_signed,   tic4x_relocation, \"AREL24\",    true, 0x00ffffff, 0x00ffffff, false),\n+    HOWTO(R_RELLONG,\t 0,  2, 32, false, 0, complain_overflow_signed,   tic4x_relocation, \"ARELLONG\",  true, 0xffffffff, 0xffffffff, false),\n+    HOWTO(R_PCRWORD,\t 0,  2, 16, true,  0, complain_overflow_signed,   tic4x_relocation, \"APCRWORD\",  true, 0x0000ffff, 0x0000ffff, false),\n+    HOWTO(R_PCR24,\t 0,  2, 24, true,  0, complain_overflow_signed,   tic4x_relocation, \"APCR24\",    true, 0x00ffffff, 0x00ffffff, false),\n+    HOWTO(R_PARTLS16,\t 0,  2, 16, false, 0, complain_overflow_dont,     tic4x_relocation, \"APARTLS16\", true, 0x0000ffff, 0x0000ffff, false),\n+    HOWTO(R_PARTMS8,\t16,  2, 16, false, 0, complain_overflow_dont,     tic4x_relocation, \"APARTMS8\",  true, 0x0000ffff, 0x0000ffff, false),\n };\n #define HOWTO_SIZE (sizeof(tic4x_howto_table) / sizeof(tic4x_howto_table[0]))\n "
    },
    {
      "sha": "63d36ae43753a34f8a306b6d59f3e25b238dcf56",
      "filename": "bfd/coff-tic54x.c",
      "status": "modified",
      "additions": 42,
      "deletions": 42,
      "changes": 84,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-tic54x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-tic54x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-tic54x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -112,7 +112,7 @@ bfd_ticoff_get_section_load_page (asection *sect)\n /* Set the architecture appropriately.  Allow unkown architectures\n    (e.g. binary).  */\n \n-static bfd_boolean\n+static bool\n tic54x_set_arch_mach (bfd *abfd,\n \t\t      enum bfd_architecture arch,\n \t\t      unsigned long machine)\n@@ -121,7 +121,7 @@ tic54x_set_arch_mach (bfd *abfd,\n     arch = bfd_arch_tic54x;\n \n   else if (arch != bfd_arch_tic54x)\n-    return FALSE;\n+    return false;\n \n   return bfd_default_set_arch_mach (abfd, arch, machine);\n }\n@@ -154,59 +154,59 @@ reloc_howto_type tic54x_howto_table[] =\n \n     /* NORMAL BANK */\n     /* 16-bit direct reference to symbol's address.  */\n-    HOWTO (R_RELWORD,0,1,16,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"REL16\",FALSE,0xFFFF,0xFFFF,FALSE),\n+    HOWTO (R_RELWORD,0,1,16,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"REL16\",false,0xFFFF,0xFFFF,false),\n \n     /* 7 LSBs of an address */\n-    HOWTO (R_PARTLS7,0,1,7,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"LS7\",FALSE,0x007F,0x007F,FALSE),\n+    HOWTO (R_PARTLS7,0,1,7,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"LS7\",false,0x007F,0x007F,false),\n \n     /* 9 MSBs of an address */\n     /* TI assembler doesn't shift its encoding, and is thus incompatible */\n-    HOWTO (R_PARTMS9,7,1,9,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"MS9\",FALSE,0x01FF,0x01FF,FALSE),\n+    HOWTO (R_PARTMS9,7,1,9,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"MS9\",false,0x01FF,0x01FF,false),\n \n     /* 23-bit relocation */\n-    HOWTO (R_EXTWORD,0,2,23,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"RELEXT\",FALSE,0x7FFFFF,0x7FFFFF,FALSE),\n+    HOWTO (R_EXTWORD,0,2,23,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"RELEXT\",false,0x7FFFFF,0x7FFFFF,false),\n \n     /* 16 bits of 23-bit extended address */\n-    HOWTO (R_EXTWORD16,0,1,16,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"RELEXT16\",FALSE,0x7FFFFF,0x7FFFFF,FALSE),\n+    HOWTO (R_EXTWORD16,0,1,16,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"RELEXT16\",false,0x7FFFFF,0x7FFFFF,false),\n \n     /* upper 7 bits of 23-bit extended address */\n-    HOWTO (R_EXTWORDMS7,16,1,7,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"RELEXTMS7\",FALSE,0x7F,0x7F,FALSE),\n+    HOWTO (R_EXTWORDMS7,16,1,7,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"RELEXTMS7\",false,0x7F,0x7F,false),\n \n     /* ABSOLUTE BANK */\n     /* 16-bit direct reference to symbol's address, absolute */\n-    HOWTO (R_RELWORD,0,1,16,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"AREL16\",FALSE,0xFFFF,0xFFFF,FALSE),\n+    HOWTO (R_RELWORD,0,1,16,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"AREL16\",false,0xFFFF,0xFFFF,false),\n \n     /* 7 LSBs of an address, absolute */\n-    HOWTO (R_PARTLS7,0,1,7,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"ALS7\",FALSE,0x007F,0x007F,FALSE),\n+    HOWTO (R_PARTLS7,0,1,7,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"ALS7\",false,0x007F,0x007F,false),\n \n     /* 9 MSBs of an address, absolute */\n     /* TI assembler doesn't shift its encoding, and is thus incompatible */\n-    HOWTO (R_PARTMS9,7,1,9,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"AMS9\",FALSE,0x01FF,0x01FF,FALSE),\n+    HOWTO (R_PARTMS9,7,1,9,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"AMS9\",false,0x01FF,0x01FF,false),\n \n     /* 23-bit direct reference, absolute */\n-    HOWTO (R_EXTWORD,0,2,23,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"ARELEXT\",FALSE,0x7FFFFF,0x7FFFFF,FALSE),\n+    HOWTO (R_EXTWORD,0,2,23,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"ARELEXT\",false,0x7FFFFF,0x7FFFFF,false),\n \n     /* 16 bits of 23-bit extended address, absolute */\n-    HOWTO (R_EXTWORD16,0,1,16,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"ARELEXT16\",FALSE,0x7FFFFF,0x7FFFFF,FALSE),\n+    HOWTO (R_EXTWORD16,0,1,16,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"ARELEXT16\",false,0x7FFFFF,0x7FFFFF,false),\n \n     /* upper 7 bits of 23-bit extended address, absolute */\n-    HOWTO (R_EXTWORDMS7,16,1,7,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"ARELEXTMS7\",FALSE,0x7F,0x7F,FALSE),\n+    HOWTO (R_EXTWORDMS7,16,1,7,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"ARELEXTMS7\",false,0x7F,0x7F,false),\n \n     /* 32-bit relocation exclusively for stabs */\n-    HOWTO (R_RELLONG,0,2,32,FALSE,0,complain_overflow_dont,\n-\t   tic54x_relocation,\"STAB\",FALSE,0xFFFFFFFF,0xFFFFFFFF,FALSE),\n+    HOWTO (R_RELLONG,0,2,32,false,0,complain_overflow_dont,\n+\t   tic54x_relocation,\"STAB\",false,0xFFFFFFFF,0xFFFFFFFF,false),\n   };\n \n #define coff_bfd_reloc_type_lookup tic54x_coff_reloc_type_lookup\n@@ -312,13 +312,13 @@ coff_tic54x_rtype_to_howto (bfd *abfd,\n /* Replace the stock _bfd_coff_is_local_label_name to recognize TI COFF local\n    labels.  */\n \n-static bfd_boolean\n+static bool\n ticoff_bfd_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\tconst char *name)\n {\n   if (TICOFF_LOCAL_LABEL_P(name))\n-    return TRUE;\n-  return FALSE;\n+    return true;\n+  return false;\n }\n \n #define coff_bfd_is_local_label_name ticoff_bfd_is_local_label_name\n@@ -335,7 +335,7 @@ ticoff_bfd_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,\n \n #include \"coffcode.h\"\n \n-static bfd_boolean\n+static bool\n tic54x_set_section_contents (bfd *abfd,\n \t\t\t     sec_ptr section,\n \t\t\t     const void * location,\n@@ -474,9 +474,9 @@ const bfd_target tic54x_coff0_beh_vec =\n     15,\t\t\t\t/* ar_max_namelen */\n     0,\t\t\t\t/* match priority.  */\n #ifdef TARGET_KEEP_UNUSED_SECTION_SYMBOLS\n-    TRUE,\t\t\t/* keep unused section symbols.  */\n+    true,\t\t\t/* keep unused section symbols.  */\n #else\n-    FALSE,\t\t\t/* keep unused section symbols.  */\n+    false,\t\t\t/* keep unused section symbols.  */\n #endif\n     bfd_getl64, bfd_getl_signed_64, bfd_putl64,\n     tic54x_getl32, tic54x_getl_signed_32, tic54x_putl32,\n@@ -537,9 +537,9 @@ const bfd_target tic54x_coff1_vec =\n     15,\t\t\t\t/* ar_max_namelen */\n     0,\t\t\t\t/* match priority.  */\n #ifdef TARGET_KEEP_UNUSED_SECTION_SYMBOLS\n-    TRUE,\t\t\t/* keep unused section symbols.  */\n+    true,\t\t\t/* keep unused section symbols.  */\n #else\n-    FALSE,\t\t\t/* keep unused section symbols.  */\n+    false,\t\t\t/* keep unused section symbols.  */\n #endif\n     bfd_getl64, bfd_getl_signed_64, bfd_putl64,\n     tic54x_getl32, tic54x_getl_signed_32, tic54x_putl32,\n@@ -600,9 +600,9 @@ const bfd_target tic54x_coff1_beh_vec =\n     15,\t\t\t\t/* ar_max_namelen */\n     0,\t\t\t\t/* match priority.  */\n #ifdef TARGET_KEEP_UNUSED_SECTION_SYMBOLS\n-    TRUE,\t\t\t/* keep unused section symbols.  */\n+    true,\t\t\t/* keep unused section symbols.  */\n #else\n-    FALSE,\t\t\t/* keep unused section symbols.  */\n+    false,\t\t\t/* keep unused section symbols.  */\n #endif\n     bfd_getl64, bfd_getl_signed_64, bfd_putl64,\n     tic54x_getl32, tic54x_getl_signed_32, tic54x_putl32,\n@@ -663,9 +663,9 @@ const bfd_target tic54x_coff2_vec =\n     15,\t\t\t\t/* ar_max_namelen */\n     0,\t\t\t\t/* match priority.  */\n #ifdef TARGET_KEEP_UNUSED_SECTION_SYMBOLS\n-    TRUE,\t\t\t/* keep unused section symbols.  */\n+    true,\t\t\t/* keep unused section symbols.  */\n #else\n-    FALSE,\t\t\t/* keep unused section symbols.  */\n+    false,\t\t\t/* keep unused section symbols.  */\n #endif\n     bfd_getl64, bfd_getl_signed_64, bfd_putl64,\n     tic54x_getl32, tic54x_getl_signed_32, tic54x_putl32,\n@@ -726,9 +726,9 @@ const bfd_target tic54x_coff2_beh_vec =\n     15,\t\t\t\t/* ar_max_namelen */\n     0,\t\t\t\t/* match priority.  */\n #ifdef TARGET_KEEP_UNUSED_SECTION_SYMBOLS\n-    TRUE,\t\t\t/* keep unused section symbols.  */\n+    true,\t\t\t/* keep unused section symbols.  */\n #else\n-    FALSE,\t\t\t/* keep unused section symbols.  */\n+    false,\t\t\t/* keep unused section symbols.  */\n #endif\n     bfd_getl64, bfd_getl_signed_64, bfd_putl64,\n     tic54x_getl32, tic54x_getl_signed_32, tic54x_putl32,"
    },
    {
      "sha": "67f2ee5e07ab3c52806dfbaabfba221464cdfd0a",
      "filename": "bfd/coff-x86_64.c",
      "status": "modified",
      "additions": 45,
      "deletions": 45,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-x86_64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-x86_64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-x86_64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -148,7 +148,7 @@ coff_amd64_reloc (bfd *abfd,\n \t  if (link_info == NULL)\n \t    return bfd_reloc_dangerous;\n \t  h = bfd_link_hash_lookup (link_info->hash, \"__ImageBase\",\n-\t\t\t\t    FALSE, FALSE, FALSE);\n+\t\t\t\t    false, false, false);\n \t  if (h == NULL)\n \t    return bfd_reloc_dangerous;\n \t  while (h->type == bfd_link_hash_indirect)\n@@ -226,7 +226,7 @@ coff_amd64_reloc (bfd *abfd,\n /* Return TRUE if this relocation should appear in the output .reloc\n    section.  */\n \n-static bfd_boolean\n+static bool\n in_reloc_p (bfd *abfd ATTRIBUTE_UNUSED, reloc_howto_type *howto)\n {\n   return ! howto->pc_relative && howto->type != R_AMD64_IMAGEBASE\n@@ -235,7 +235,7 @@ in_reloc_p (bfd *abfd ATTRIBUTE_UNUSED, reloc_howto_type *howto)\n #endif /* COFF_WITH_PE */\n \n #ifndef PCRELOFFSET\n-#define PCRELOFFSET TRUE\n+#define PCRELOFFSET true\n #endif\n \n static reloc_howto_type howto_table[] =\n@@ -245,53 +245,53 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long, 4 = long long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_ADDR64\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffffffffffffll,\t/* src_mask */\n \t 0xffffffffffffffffll,\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n   HOWTO (R_AMD64_DIR32,\t\t/* type 2 */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_ADDR32\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n   /* PE IMAGE_REL_AMD64_ADDR32NB relocation (3).\t*/\n   HOWTO (R_AMD64_IMAGEBASE,\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_ADDR32NB\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n   /* 32-bit longword PC relative relocation (4).  */\n   HOWTO (R_AMD64_PCRLONG,\t/* type 4 */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_REL32\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -300,64 +300,64 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_REL32_1\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n  HOWTO (R_AMD64_PCRLONG_2,\t/* type 6 */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_REL32_2\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n  HOWTO (R_AMD64_PCRLONG_3,\t/* type 7 */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_REL32_3\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n  HOWTO (R_AMD64_PCRLONG_4,\t/* type 8 */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_REL32_4\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n  HOWTO (R_AMD64_PCRLONG_5,\t/* type 9 */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_REL32_5\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -368,15 +368,15 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"IMAGE_REL_AMD64_SECREL\", /* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t TRUE),\t\t\t/* pcrel_offset */\n+\t true),\t\t\t/* pcrel_offset */\n #else\n   EMPTY_HOWTO (11),\n #endif\n@@ -387,12 +387,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"R_X86_64_PC64\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffffffffffffll,\t/* src_mask */\n \t 0xffffffffffffffffll,\t/* dst_mask */\n \t PCRELOFFSET),\t\t /* pcrel_offset */\n@@ -404,12 +404,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"R_X86_64_8\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x000000ff,\t\t/* src_mask */\n \t 0x000000ff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -418,12 +418,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"R_X86_64_16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x0000ffff,\t\t/* src_mask */\n \t 0x0000ffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -432,12 +432,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"R_X86_64_32S\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -446,12 +446,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 8,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"R_X86_64_PC8\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x000000ff,\t\t/* src_mask */\n \t 0x000000ff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -460,12 +460,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"R_X86_64_PC16\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x0000ffff,\t\t/* src_mask */\n \t 0x0000ffff,\t\t/* dst_mask */\n \t PCRELOFFSET),\t\t/* pcrel_offset */\n@@ -474,12 +474,12 @@ static reloc_howto_type howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t coff_amd64_reloc,\t/* special_function */\n \t \"R_X86_64_PC32\",\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n \t PCRELOFFSET)\t\t/* pcrel_offset */\n@@ -554,7 +554,7 @@ static reloc_howto_type howto_table[] =\n    and the regular routine is that we don't want to do anything for a\n    relocatable link.  */\n \n-static bfd_boolean\n+static bool\n coff_pe_amd64_relocate_section (bfd *output_bfd,\n \t\t\t\tstruct bfd_link_info *info,\n \t\t\t\tbfd *input_bfd,\n@@ -565,7 +565,7 @@ coff_pe_amd64_relocate_section (bfd *output_bfd,\n \t\t\t\tasection **sections)\n {\n   if (bfd_link_relocatable (info))\n-    return TRUE;\n+    return true;\n \n   return _bfd_coff_generic_relocate_section (output_bfd, info, input_bfd,input_section, contents,relocs, syms, sections);\n }\n@@ -750,11 +750,11 @@ coff_amd64_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,\n    a leading dot for local labels, so if TARGET_UNDERSCORE is defined\n    we treat all symbols starting with L as local.  */\n \n-static bfd_boolean\n+static bool\n coff_amd64_is_local_label_name (bfd *abfd, const char *name)\n {\n   if (name[0] == 'L')\n-    return TRUE;\n+    return true;\n \n   return _bfd_coff_is_local_label_name (abfd, name);\n }"
    },
    {
      "sha": "c0f1739dfcb6616f8f2ad4935bae0879558ca985",
      "filename": "bfd/coff-z80.c",
      "status": "modified",
      "additions": 40,
      "deletions": 40,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-z80.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-z80.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-z80.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -47,195 +47,195 @@ static bfd_howto_type howto_table[] =\n      0,\t\t\t/* rightshift */\n      2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      32,\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_bitfield, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_imm32\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0xffffffff,\t/* src_mask */\n      0xffffffff,\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_24,\n      R_IMM24,\t\t/* type */\n      0,\t\t\t/* rightshift */\n      1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      24,\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_bitfield, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_imm24\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0x00ffffff,\t/* src_mask */\n      0x00ffffff,\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_16,\n      R_IMM16,\t\t/* type */\n      0,\t\t\t/* rightshift */\n      1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      16,\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_bitfield, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_imm16\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0x0000ffff,\t/* src_mask */\n      0x0000ffff,\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_8,\n      R_IMM8,\t\t/* type */\n      0,\t\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      8,\t\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_bitfield, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_imm8\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0x000000ff,\t/* src_mask */\n      0x000000ff,\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_8_PCREL,\n      R_JR,\t\t/* type */\n      0,\t\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      8,\t\t\t/* bitsize */\n-     TRUE,\t\t/* pc_relative */\n+     true,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_signed, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_jr\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0,\t\t\t/* src_mask */\n      0xFF,\t\t/* dst_mask */\n-     TRUE),\t\t/* pcrel_offset */\n+     true),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_Z80_DISP8,\n      R_OFF8,\t\t/* type */\n      0,\t\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      8,\t\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_signed, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_off8\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0,\t\t\t/* src_mask */\n      0xff,\t\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_Z80_BYTE0,\n      R_BYTE0,\t\t/* type */\n      0,\t\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      8,\t\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_dont, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_byte0\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0,\t\t\t/* src_mask */\n      0xff,\t\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_Z80_BYTE1,\n      R_BYTE1,\t\t/* type */\n      8,\t\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      8,\t\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_dont, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_byte1\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0,\t\t\t/* src_mask */\n      0xff,\t\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_Z80_BYTE2,\n      R_BYTE2,\t\t/* type */\n      16,\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      8,\t\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_dont, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_byte2\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0,\t\t\t/* src_mask */\n      0xff,\t\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_Z80_BYTE3,\n      R_BYTE3,\t\t/* type */\n      24,\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      8,\t\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_dont, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_byte3\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0,\t\t\t/* src_mask */\n      0xff,\t\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_Z80_WORD0,\n      R_WORD0,\t\t/* type */\n      0,\t\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      16,\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_dont, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_word0\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0,\t\t\t/* src_mask */\n      0xffff,\t\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_Z80_WORD1,\n      R_WORD1,\t\t/* type */\n      16,\t\t/* rightshift */\n      0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      16,\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_dont, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_word1\",\t\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0,\t\t\t/* src_mask */\n      0xffff,\t\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n \n   BFD_HOWTO (BFD_RELOC_Z80_16_BE,\n      R_IMM16BE,\t\t/* type */\n      0,\t\t\t/* rightshift */\n      1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n      16,\t\t/* bitsize */\n-     FALSE,\t\t/* pc_relative */\n+     false,\t\t/* pc_relative */\n      0,\t\t\t/* bitpos */\n      complain_overflow_bitfield, /* complain_on_overflow */\n      0,\t\t\t/* special_function */\n      \"r_imm16be\",\t/* name */\n-     FALSE,\t\t/* partial_inplace */\n+     false,\t\t/* partial_inplace */\n      0x0000ffff,\t/* src_mask */\n      0x0000ffff,\t/* dst_mask */\n-     FALSE),\t\t/* pcrel_offset */\n+     false),\t\t/* pcrel_offset */\n };\n \n #define NUM_HOWTOS ARRAY_SIZE (howto_table)\n@@ -452,7 +452,7 @@ extra_case (bfd *in_abfd,\n     }\n }\n \n-static bfd_boolean\n+static bool\n z80_is_local_label_name (bfd *        abfd ATTRIBUTE_UNUSED,\n                          const char * name)\n {"
    },
    {
      "sha": "6cd5d652adefda6c2cced252f0935ec4ccf3aacb",
      "filename": "bfd/coff-z8k.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-z8k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff-z8k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff-z8k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -31,40 +31,40 @@\n #define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (1)\n \n static reloc_howto_type r_imm32 =\n-HOWTO (R_IMM32, 0, 2, 32, FALSE, 0,\n-       complain_overflow_bitfield, 0, \"r_imm32\", TRUE, 0xffffffff,\n-       0xffffffff, FALSE);\n+HOWTO (R_IMM32, 0, 2, 32, false, 0,\n+       complain_overflow_bitfield, 0, \"r_imm32\", true, 0xffffffff,\n+       0xffffffff, false);\n \n static reloc_howto_type r_imm4l =\n-HOWTO (R_IMM4L, 0, 0, 4, FALSE, 0,\n-       complain_overflow_bitfield, 0, \"r_imm4l\", TRUE, 0xf, 0xf, FALSE);\n+HOWTO (R_IMM4L, 0, 0, 4, false, 0,\n+       complain_overflow_bitfield, 0, \"r_imm4l\", true, 0xf, 0xf, false);\n \n static reloc_howto_type r_da =\n-HOWTO (R_IMM16, 0, 1, 16, FALSE, 0,\n-       complain_overflow_bitfield, 0, \"r_da\", TRUE, 0x0000ffff, 0x0000ffff,\n-       FALSE);\n+HOWTO (R_IMM16, 0, 1, 16, false, 0,\n+       complain_overflow_bitfield, 0, \"r_da\", true, 0x0000ffff, 0x0000ffff,\n+       false);\n \n static reloc_howto_type r_imm8 =\n-HOWTO (R_IMM8, 0, 0, 8, FALSE, 0,\n-       complain_overflow_bitfield, 0, \"r_imm8\", TRUE, 0x000000ff, 0x000000ff,\n-       FALSE);\n+HOWTO (R_IMM8, 0, 0, 8, false, 0,\n+       complain_overflow_bitfield, 0, \"r_imm8\", true, 0x000000ff, 0x000000ff,\n+       false);\n \n static reloc_howto_type r_rel16 =\n-HOWTO (R_REL16, 0, 1, 16, FALSE, 0,\n-       complain_overflow_bitfield, 0, \"r_rel16\", TRUE, 0x0000ffff, 0x0000ffff,\n-       TRUE);\n+HOWTO (R_REL16, 0, 1, 16, false, 0,\n+       complain_overflow_bitfield, 0, \"r_rel16\", true, 0x0000ffff, 0x0000ffff,\n+       true);\n \n static reloc_howto_type r_jr =\n-HOWTO (R_JR, 1, 0, 8, TRUE, 0, complain_overflow_signed, 0,\n-       \"r_jr\", TRUE, 0xff, 0xff, TRUE);\n+HOWTO (R_JR, 1, 0, 8, true, 0, complain_overflow_signed, 0,\n+       \"r_jr\", true, 0xff, 0xff, true);\n \n static reloc_howto_type r_disp7 =\n-HOWTO (R_DISP7, 0, 0, 7, TRUE, 0, complain_overflow_bitfield, 0,\n-       \"r_disp7\", TRUE, 0x7f, 0x7f, TRUE);\n+HOWTO (R_DISP7, 0, 0, 7, true, 0, complain_overflow_bitfield, 0,\n+       \"r_disp7\", true, 0x7f, 0x7f, true);\n \n static reloc_howto_type r_callr =\n-HOWTO (R_CALLR, 1, 1, 12, TRUE, 0, complain_overflow_signed, 0,\n-       \"r_callr\", TRUE, 0xfff, 0xfff, TRUE);\n+HOWTO (R_CALLR, 1, 1, 12, true, 0, complain_overflow_signed, 0,\n+       \"r_callr\", true, 0xfff, 0xfff, true);\n \n #define BADMAG(x) Z8KBADMAG(x)\n #define Z8K 1\t\t\t/* Customize coffcode.h.  */"
    },
    {
      "sha": "cc671b26b6a3b31dd0e5436cc3278db278d5bf8d",
      "filename": "bfd/coff64-rs6000.c",
      "status": "modified",
      "additions": 170,
      "deletions": 170,
      "changes": 340,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff64-rs6000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coff64-rs6000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coff64-rs6000.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -86,10 +86,10 @@ static void _bfd_xcoff64_swap_lineno_in\n   (bfd *, void *, void *);\n static unsigned int _bfd_xcoff64_swap_lineno_out\n   (bfd *, void *, void *);\n-static bfd_boolean _bfd_xcoff64_put_symbol_name\n+static bool _bfd_xcoff64_put_symbol_name\n   (struct bfd_link_info *, struct bfd_strtab_hash *,\n    struct internal_syment *, const char *);\n-static bfd_boolean _bfd_xcoff64_put_ldsymbol_name\n+static bool _bfd_xcoff64_put_ldsymbol_name\n   (bfd *, struct xcoff_loader_info *, struct internal_ldsym *, const char *);\n static void _bfd_xcoff64_swap_sym_in\n   (bfd *, void *, void *);\n@@ -103,27 +103,27 @@ static void xcoff64_swap_reloc_in\n   (bfd *, void *, void *);\n static unsigned int xcoff64_swap_reloc_out\n   (bfd *, void *, void *);\n-extern bfd_boolean _bfd_xcoff_mkobject\n+extern bool _bfd_xcoff_mkobject\n   (bfd *);\n-extern bfd_boolean _bfd_xcoff_copy_private_bfd_data\n+extern bool _bfd_xcoff_copy_private_bfd_data\n   (bfd *, bfd *);\n-extern bfd_boolean _bfd_xcoff_is_local_label_name\n+extern bool _bfd_xcoff_is_local_label_name\n   (bfd *, const char *);\n extern void xcoff64_rtype2howto\n   (arelent *, struct internal_reloc *);\n extern reloc_howto_type * xcoff64_reloc_type_lookup\n   (bfd *, bfd_reloc_code_real_type);\n-extern bfd_boolean _bfd_xcoff_slurp_armap\n+extern bool _bfd_xcoff_slurp_armap\n   (bfd *);\n extern void *_bfd_xcoff_read_ar_hdr\n   (bfd *);\n extern bfd *_bfd_xcoff_openr_next_archived_file\n   (bfd *, bfd *);\n extern int _bfd_xcoff_stat_arch_elt\n   (bfd *, struct stat *);\n-extern bfd_boolean _bfd_xcoff_write_armap\n+extern bool _bfd_xcoff_write_armap\n   (bfd *, unsigned int, struct orl *, unsigned int, int);\n-extern bfd_boolean _bfd_xcoff_write_archive_contents\n+extern bool _bfd_xcoff_write_archive_contents\n   (bfd *);\n extern int _bfd_xcoff_sizeof_headers\n   (bfd *, struct bfd_link_info *);\n@@ -147,11 +147,11 @@ static void xcoff64_swap_ldrel_in\n   (bfd *, const void *, struct internal_ldrel *);\n static void xcoff64_swap_ldrel_out\n   (bfd *, const struct internal_ldrel *, void *d);\n-static bfd_boolean xcoff64_ppc_relocate_section\n+static bool xcoff64_ppc_relocate_section\n   (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,\n    struct internal_reloc *, struct internal_syment *,\n    asection **);\n-static bfd_boolean xcoff64_slurp_armap\n+static bool xcoff64_slurp_armap\n   (bfd *);\n static bfd_cleanup xcoff64_archive_p\n   (bfd *);\n@@ -161,17 +161,17 @@ static int xcoff64_sizeof_headers\n   (bfd *, struct bfd_link_info *);\n static asection *xcoff64_create_csect_from_smclas\n   (bfd *, union internal_auxent *, const char *);\n-static bfd_boolean xcoff64_is_lineno_count_overflow\n+static bool xcoff64_is_lineno_count_overflow\n   (bfd *, bfd_vma);\n-static bfd_boolean xcoff64_is_reloc_count_overflow\n+static bool xcoff64_is_reloc_count_overflow\n   (bfd *, bfd_vma);\n static bfd_vma xcoff64_loader_symbol_offset\n   (bfd *, struct internal_ldhdr *);\n static bfd_vma xcoff64_loader_reloc_offset\n   (bfd *, struct internal_ldhdr *);\n-static bfd_boolean xcoff64_generate_rtinit\n-  (bfd *, const char *, const char *, bfd_boolean);\n-static bfd_boolean xcoff64_bad_format_hook\n+static bool xcoff64_generate_rtinit\n+  (bfd *, const char *, const char *, bool);\n+static bool xcoff64_bad_format_hook\n   (bfd *, void *);\n \n /* Relocation functions */\n@@ -259,7 +259,7 @@ xcoff64_calculate_relocation[XCOFF_MAX_CALCULATE_RELOCATION] =\n #ifdef AIX_CORE\n extern bfd_cleanup rs6000coff_core_p\n   (bfd *abfd);\n-extern bfd_boolean rs6000coff_core_file_matches_executable_p\n+extern bool rs6000coff_core_file_matches_executable_p\n   (bfd *cbfd, bfd *ebfd);\n extern char *rs6000coff_core_file_failing_command\n   (bfd *abfd);\n@@ -536,28 +536,28 @@ _bfd_xcoff64_swap_aux_out (bfd *abfd, void *inp, int type, int in_class,\n   return bfd_coff_auxesz (abfd);\n }\n \n-static bfd_boolean\n+static bool\n _bfd_xcoff64_put_symbol_name (struct bfd_link_info *info,\n \t\t\t      struct bfd_strtab_hash *strtab,\n \t\t\t      struct internal_syment *sym,\n \t\t\t      const char *name)\n {\n-  bfd_boolean hash;\n+  bool hash;\n   bfd_size_type indx;\n \n   hash = !info->traditional_format;\n-  indx = _bfd_stringtab_add (strtab, name, hash, FALSE);\n+  indx = _bfd_stringtab_add (strtab, name, hash, false);\n \n   if (indx == (bfd_size_type) -1)\n-    return FALSE;\n+    return false;\n \n   sym->_n._n_n._n_zeroes = 0;\n   sym->_n._n_n._n_offset = STRING_SIZE_SIZE + indx;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n _bfd_xcoff64_put_ldsymbol_name (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\tstruct xcoff_loader_info *ldinfo,\n \t\t\t\tstruct internal_ldsym *ldsym,\n@@ -580,8 +580,8 @@ _bfd_xcoff64_put_ldsymbol_name (bfd *abfd ATTRIBUTE_UNUSED,\n       newstrings = bfd_realloc (ldinfo->strings, newalc);\n       if (newstrings == NULL)\n \t{\n-\t  ldinfo->failed = TRUE;\n-\t  return FALSE;\n+\t  ldinfo->failed = true;\n+\t  return false;\n \t}\n       ldinfo->string_alc = newalc;\n       ldinfo->strings = newstrings;\n@@ -594,7 +594,7 @@ _bfd_xcoff64_put_ldsymbol_name (bfd *abfd ATTRIBUTE_UNUSED,\n   ldsym->_l._l_l._l_offset = ldinfo->string_size + 2;\n   ldinfo->string_size += len + 3;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Routines to swap information in the XCOFF .loader section.  If we\n@@ -732,7 +732,7 @@ xcoff64_swap_ldrel_out (bfd *abfd, const struct internal_ldrel *src, void *d)\n }\n \n \n-static bfd_boolean\n+static bool\n xcoff64_reloc_type_br (bfd *input_bfd,\n \t\t       asection *input_section,\n \t\t       bfd *output_bfd ATTRIBUTE_UNUSED,\n@@ -748,7 +748,7 @@ xcoff64_reloc_type_br (bfd *input_bfd,\n   bfd_vma section_offset;\n \n   if (0 > rel->r_symndx)\n-    return FALSE;\n+    return false;\n \n   h = obj_xcoff_sym_hashes (input_bfd)[rel->r_symndx];\n   section_offset = rel->r_vaddr - input_section->vma;\n@@ -821,19 +821,19 @@ xcoff64_reloc_type_br (bfd *input_bfd,\n       bfd_put_32 (input_bfd, insn, ptr);\n \n       /* Make the howto absolute too.  */\n-      howto->pc_relative = FALSE;\n+      howto->pc_relative = false;\n       howto->complain_on_overflow = complain_overflow_bitfield;\n     }\n   else\n     {\n       /* Use a PC-relative howto and subtract the instruction's address\n \t from the target address we calculated above.  */\n-      howto->pc_relative = TRUE;\n+      howto->pc_relative = true;\n       *relocation -= (input_section->output_section->vma\n \t\t      + input_section->output_offset\n \t\t      + section_offset);\n     }\n-  return TRUE;\n+  return true;\n }\n \n \n@@ -848,105 +848,105 @@ reloc_howto_type xcoff64_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_POS_64\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x01: 64 bit relocation, but store negative value.  */\n   HOWTO (R_NEG,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t -4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_NEG\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x02: 64 bit PC relative relocation.  */\n   HOWTO (R_REL,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_REL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x03: 16 bit TOC relative relocation.  */\n   HOWTO (R_TOC,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TOC\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x04: Same as R_TOC.  */\n   HOWTO (R_TRL,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TRL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x05: External TOC relative symbol.  */\n   HOWTO (R_GL,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_GL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x06: Local TOC relative symbol.\t */\n   HOWTO (R_TCL,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TCL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (7),\n \n@@ -955,15 +955,15 @@ reloc_howto_type xcoff64_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_BA_26\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x03fffffc,\t\t/* src_mask */\n \t 0x03fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (9),\n \n@@ -972,15 +972,15 @@ reloc_howto_type xcoff64_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_BR\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x03fffffc,\t\t/* src_mask */\n \t 0x03fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (0xb),\n \n@@ -989,30 +989,30 @@ reloc_howto_type xcoff64_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x0d: Same as R_POS.  */\n   HOWTO (R_RLA,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RLA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (0xe),\n \n@@ -1021,15 +1021,15 @@ reloc_howto_type xcoff64_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 0,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 1,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_REF\",\t\t/* name */\n-\t FALSE,\t\t\t/* partial_inplace */\n+\t false,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0,\t\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO (0x10),\n   EMPTY_HOWTO (0x11),\n@@ -1040,285 +1040,285 @@ reloc_howto_type xcoff64_howto_table[] =\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TRLA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x14: Modifiable relative branch.  */\n   HOWTO (R_RRTBI,\t\t/* type */\n \t 1,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RRTBI\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x15: Modifiable absolute branch.  */\n   HOWTO (R_RRTBA,\t\t/* type */\n \t 1,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RRTBA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x16: Modifiable call absolute indirect.  */\n   HOWTO (R_CAI,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_CAI\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x17: Modifiable call relative.  */\n   HOWTO (R_CREL,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_CREL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x18: Modifiable branch absolute.  */\n   HOWTO (R_RBA,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBA\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x03fffffc,\t\t/* src_mask */\n \t 0x03fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x19: Modifiable branch absolute.  */\n   HOWTO (R_RBAC,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBAC\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1a: Modifiable branch relative.  */\n   HOWTO (R_RBR,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 26,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBR_26\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0x03fffffc,\t\t/* src_mask */\n \t 0x03fffffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1b: Modifiable branch absolute.  */\n   HOWTO (R_RBRC,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBRC\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1c: Standard 32 bit relocation.  */\n   HOWTO (R_POS,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 2,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 32,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_POS_32\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffffffff,\t\t/* src_mask */\n \t 0xffffffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1d: 16 bit Non modifiable absolute branch.  */\n   HOWTO (R_BA,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_BA_16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xfffc,\t\t/* src_mask */\n \t 0xfffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1e: Modifiable branch relative.  */\n   HOWTO (R_RBR,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t TRUE,\t\t\t/* pc_relative */\n+\t true,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_signed, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBR_16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xfffc,\t\t/* src_mask */\n \t 0xfffc,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x1f: Modifiable branch absolute.  */\n   HOWTO (R_RBA,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_RBA_16\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0xffff,\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x20: General-dynamic TLS relocation.  */\n   HOWTO (R_TLS,\t\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLS\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x21: Initial-exec TLS relocation.  */\n   HOWTO (R_TLS_IE,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLS_IE\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x22: Local-dynamic TLS relocation.  */\n   HOWTO (R_TLS_LD,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLS_LD\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x23: Local-exec TLS relocation.  */\n   HOWTO (R_TLS_LE,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLS_LE\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x24: TLS relocation.  */\n   HOWTO (R_TLSM,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLSM\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x25: TLS module relocation.  */\n   HOWTO (R_TLSML,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 64,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TLSM\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t MINUS_ONE,\t\t/* src_mask */\n \t MINUS_ONE,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   EMPTY_HOWTO(0x26),\n   EMPTY_HOWTO(0x27),\n@@ -1335,30 +1335,30 @@ reloc_howto_type xcoff64_howto_table[] =\n \t 16,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_bitfield, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TOCU\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n   /* 0x31: Low-order 16 bit TOC relative relocation.  */\n   HOWTO (R_TOCL,\t\t/* type */\n \t 0,\t\t\t/* rightshift */\n \t 1,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n \t 16,\t\t\t/* bitsize */\n-\t FALSE,\t\t\t/* pc_relative */\n+\t false,\t\t\t/* pc_relative */\n \t 0,\t\t\t/* bitpos */\n \t complain_overflow_dont, /* complain_on_overflow */\n \t 0,\t\t\t/* special_function */\n \t \"R_TOCL\",\t\t/* name */\n-\t TRUE,\t\t\t/* partial_inplace */\n+\t true,\t\t\t/* partial_inplace */\n \t 0,\t\t\t/* src_mask */\n \t 0xffff,\t\t/* dst_mask */\n-\t FALSE),\t\t/* pcrel_offset */\n+\t false),\t\t/* pcrel_offset */\n \n };\n \n@@ -1462,7 +1462,7 @@ xcoff64_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,\n /* This is the relocation function for the PowerPC64.\n    See xcoff_ppc_relocation_section for more information. */\n \n-bfd_boolean\n+bool\n xcoff64_ppc_relocate_section (bfd *output_bfd,\n \t\t\t      struct bfd_link_info *info,\n \t\t\t      bfd *input_bfd,\n@@ -1517,7 +1517,7 @@ xcoff64_ppc_relocate_section (bfd *output_bfd,\n \t\t(_(\"%pB: relocatation (%d) at (0x%\" BFD_VMA_FMT \"x) has wrong\"\n \t\t   \" r_rsize (0x%x)\\n\"),\n \t\t input_bfd, rel->r_type, rel->r_vaddr, rel->r_size);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \n@@ -1591,7 +1591,7 @@ xcoff64_ppc_relocate_section (bfd *output_bfd,\n \t  || !((*xcoff64_calculate_relocation[rel->r_type])\n \t      (input_bfd, input_section, output_bfd, rel, sym, &howto, val,\n \t       addend, &relocation, contents)))\n-\treturn FALSE;\n+\treturn false;\n \n       /* address */\n       address = rel->r_vaddr - input_section->vma;\n@@ -1658,7 +1658,7 @@ xcoff64_ppc_relocate_section (bfd *output_bfd,\n \tbfd_put_64 (input_bfd, value_to_relocate, location);\n \n     }\n-  return TRUE;\n+  return true;\n }\n \n \n@@ -1704,7 +1704,7 @@ _bfd_strntoll (const char * nptr, int base, unsigned int maxlen)\n \n /* Read in the armap of an XCOFF archive.  */\n \n-static bfd_boolean\n+static bool\n xcoff64_slurp_armap (bfd *abfd)\n {\n   file_ptr off;\n@@ -1721,43 +1721,43 @@ xcoff64_slurp_armap (bfd *abfd)\n \n   if (xcoff_ardata (abfd) == NULL)\n     {\n-      abfd->has_armap = FALSE;\n-      return TRUE;\n+      abfd->has_armap = false;\n+      return true;\n     }\n \n   off = bfd_scan_vma (xcoff_ardata_big (abfd)->symoff64,\n \t\t      (const char **) NULL, 10);\n   if (off == 0)\n     {\n-      abfd->has_armap = FALSE;\n-      return TRUE;\n+      abfd->has_armap = false;\n+      return true;\n     }\n \n   if (bfd_seek (abfd, off, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   /* The symbol table starts with a normal archive header.  */\n   if (bfd_bread (&hdr, (bfd_size_type) SIZEOF_AR_HDR_BIG, abfd)\n       != SIZEOF_AR_HDR_BIG)\n-    return FALSE;\n+    return false;\n \n   /* Skip the name (normally empty).  */\n   GET_VALUE_IN_FIELD (namlen, hdr.namlen, 10);\n   pos = ((namlen + 1) & ~(size_t) 1) + SXCOFFARFMAG;\n   if (bfd_seek (abfd, pos, SEEK_CUR) != 0)\n-    return FALSE;\n+    return false;\n \n   sz = bfd_scan_vma (hdr.size, (const char **) NULL, 10);\n   if (sz + 1 < 9)\n     {\n       bfd_set_error (bfd_error_bad_value);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Read in the entire symbol table.  */\n   contents = (bfd_byte *) _bfd_alloc_and_read (abfd, sz + 1, sz);\n   if (contents == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Ensure strings are NULL terminated so we don't wander off the end\n      of the buffer.  */\n@@ -1769,13 +1769,13 @@ xcoff64_slurp_armap (bfd *abfd)\n   if (c >= sz / 8)\n     {\n       bfd_set_error (bfd_error_bad_value);\n-      return FALSE;\n+      return false;\n     }\n   amt = c;\n   amt *= sizeof (carsym);\n   bfd_ardata (abfd)->symdefs = (carsym *) bfd_alloc (abfd, amt);\n   if (bfd_ardata (abfd)->symdefs == NULL)\n-    return FALSE;\n+    return false;\n \n   /* After the count comes a list of eight byte file offsets.  */\n   for (i = 0, arsym = bfd_ardata (abfd)->symdefs, p = contents + 8;\n@@ -1792,15 +1792,15 @@ xcoff64_slurp_armap (bfd *abfd)\n       if (p >= cend)\n \t{\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       arsym->name = (char *) p;\n     }\n \n   bfd_ardata (abfd)->symdef_count = c;\n-  abfd->has_armap = TRUE;\n+  abfd->has_armap = true;\n \n-  return TRUE;\n+  return true;\n }\n \n \n@@ -1972,18 +1972,18 @@ xcoff64_create_csect_from_smclas (bfd *abfd, union internal_auxent *aux,\n   return return_value;\n }\n \n-static bfd_boolean\n+static bool\n xcoff64_is_lineno_count_overflow (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t  bfd_vma value ATTRIBUTE_UNUSED)\n {\n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n xcoff64_is_reloc_count_overflow (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t\t bfd_vma value ATTRIBUTE_UNUSED)\n {\n-  return FALSE;\n+  return false;\n }\n \n static bfd_vma\n@@ -2000,24 +2000,24 @@ xcoff64_loader_reloc_offset (bfd *abfd ATTRIBUTE_UNUSED,\n   return (ldhdr->l_rldoff);\n }\n \n-static bfd_boolean\n+static bool\n xcoff64_bad_format_hook (bfd * abfd, void *filehdr)\n {\n   struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;\n \n   /* Check flavor first.  */\n   if (bfd_get_flavour (abfd) != bfd_target_xcoff_flavour)\n-    return FALSE;\n+    return false;\n \n   if (bfd_xcoff_magic_number (abfd) != internal_f->f_magic)\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n xcoff64_generate_rtinit (bfd *abfd, const char *init, const char *fini,\n-\t\t\t bfd_boolean rtld)\n+\t\t\t bool rtld)\n {\n   bfd_byte filehdr_ext[FILHSZ];\n   bfd_byte scnhdr_ext[SCNHSZ * 3];\n@@ -2044,7 +2044,7 @@ xcoff64_generate_rtinit (bfd *abfd, const char *init, const char *fini,\n   char *rtld_name = \"__rtld\";\n \n   if (! bfd_xcoff_rtinit_size (abfd))\n-    return FALSE;\n+    return false;\n \n   initsz = (init == NULL ? 0 : 1 + strlen (init));\n   finisz = (fini == NULL ? 0 : 1 + strlen (fini));\n@@ -2133,7 +2133,7 @@ xcoff64_generate_rtinit (bfd *abfd, const char *init, const char *fini,\n   data_buffer = NULL;\n   data_buffer = (bfd_byte *) bfd_zmalloc (data_buffer_size);\n   if (data_buffer == NULL)\n-    return FALSE;\n+    return false;\n \n   if (initsz)\n     {\n@@ -2169,7 +2169,7 @@ xcoff64_generate_rtinit (bfd *abfd, const char *init, const char *fini,\n \n   string_table = (bfd_byte *) bfd_zmalloc (string_table_size);\n   if (string_table == NULL)\n-    return FALSE;\n+    return false;\n \n   val = string_table_size;\n   bfd_put_32 (abfd, val, &string_table[0]);\n@@ -2333,7 +2333,7 @@ xcoff64_generate_rtinit (bfd *abfd, const char *init, const char *fini,\n   free (data_buffer);\n   data_buffer = NULL;\n \n-  return TRUE;\n+  return true;\n }\n \n /* The typical dynamic reloc.  */\n@@ -2343,15 +2343,15 @@ HOWTO (0,\t\t\t/* type */\n        0,\t\t\t/* rightshift */\n        4,\t\t\t/* size (0 = byte, 1 = short, 2 = long) */\n        64,\t\t\t/* bitsize */\n-       FALSE,\t\t\t/* pc_relative */\n+       false,\t\t\t/* pc_relative */\n        0,\t\t\t/* bitpos */\n        complain_overflow_bitfield, /* complain_on_overflow */\n        0,\t\t\t/* special_function */\n        \"R_POS\",\t\t\t/* name */\n-       TRUE,\t\t\t/* partial_inplace */\n+       true,\t\t\t/* partial_inplace */\n        MINUS_ONE,\t\t/* src_mask */\n        MINUS_ONE,\t\t/* dst_mask */\n-       FALSE);\t\t\t/* pcrel_offset */\n+       false);\t\t\t/* pcrel_offset */\n \n static const unsigned long xcoff64_glink_code[10] =\n {\n@@ -2388,10 +2388,10 @@ static const struct xcoff_backend_data_rec bfd_xcoff_backend_data =\n       RELSZ,\n       LINESZ,\n       FILNMLEN,\n-      TRUE,\t\t\t/* _bfd_coff_long_filenames */\n+      true,\t\t\t/* _bfd_coff_long_filenames */\n       XCOFF_NO_LONG_SECTION_NAMES,  /* _bfd_coff_long_section_names */\n       3,\t\t\t/* _bfd_coff_default_section_alignment_power */\n-      TRUE,\t\t\t/* _bfd_coff_force_symnames_in_strings */\n+      true,\t\t\t/* _bfd_coff_force_symnames_in_strings */\n       4,\t\t\t/* _bfd_coff_debug_string_prefix_length */\n       32768,\t\t\t/* _bfd_coff_max_nscns */\n       coff_swap_filehdr_in,\n@@ -2623,7 +2623,7 @@ const bfd_target rs6000_xcoff64_vec =\n \n extern bfd_cleanup xcoff64_core_p\n   (bfd *);\n-extern bfd_boolean xcoff64_core_file_matches_executable_p\n+extern bool xcoff64_core_file_matches_executable_p\n   (bfd *, bfd *);\n extern char *xcoff64_core_file_failing_command\n   (bfd *);\n@@ -2653,10 +2653,10 @@ static const struct xcoff_backend_data_rec bfd_xcoff_aix5_backend_data =\n       RELSZ,\n       LINESZ,\n       FILNMLEN,\n-      TRUE,\t\t\t/* _bfd_coff_long_filenames */\n+      true,\t\t\t/* _bfd_coff_long_filenames */\n       XCOFF_NO_LONG_SECTION_NAMES,  /* _bfd_coff_long_section_names */\n       3,\t\t\t/* _bfd_coff_default_section_alignment_power */\n-      TRUE,\t\t\t/* _bfd_coff_force_symnames_in_strings */\n+      true,\t\t\t/* _bfd_coff_force_symnames_in_strings */\n       4,\t\t\t/* _bfd_coff_debug_string_prefix_length */\n       32768,\t\t\t/* _bfd_coff_max_nscns */\n       coff_swap_filehdr_in,"
    },
    {
      "sha": "8006baa25952b87c13fd86c9ed8946d3894105a4",
      "filename": "bfd/coffcode.h",
      "status": "modified",
      "additions": 234,
      "deletions": 236,
      "changes": 470,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coffcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coffcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffcode.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -325,7 +325,7 @@ CODE_FRAGMENT\n .  } u;\n .\n . {* Selector for the union above.  *}\n-. bfd_boolean is_sym;\n+. bool is_sym;\n .} combined_entry_type;\n .\n .\n@@ -343,7 +343,7 @@ CODE_FRAGMENT\n .  struct lineno_cache_entry *lineno;\n .\n .  {* Have the line numbers been relocated yet ? *}\n-.  bfd_boolean done_lineno;\n+.  bool done_lineno;\n .} coff_symbol_type;\n \n */\n@@ -390,50 +390,50 @@ CODE_FRAGMENT\n /* Define a macro that can be used to initialise both the fields relating\n    to long section names in the backend data struct simultaneously.  */\n #if COFF_ENABLE_LONG_SECTION_NAMES\n-#define COFF_DEFAULT_LONG_SECTION_NAMES  (TRUE), COFF_LONG_SECTION_NAMES_SETTER\n+#define COFF_DEFAULT_LONG_SECTION_NAMES  (true), COFF_LONG_SECTION_NAMES_SETTER\n #else /* !COFF_ENABLE_LONG_SECTION_NAMES */\n-#define COFF_DEFAULT_LONG_SECTION_NAMES  (FALSE), COFF_LONG_SECTION_NAMES_SETTER\n+#define COFF_DEFAULT_LONG_SECTION_NAMES  (false), COFF_LONG_SECTION_NAMES_SETTER\n #endif /* COFF_ENABLE_LONG_SECTION_NAMES */\n \n #if defined (COFF_LONG_SECTION_NAMES)\n-static bfd_boolean bfd_coff_set_long_section_names_allowed\n+static bool bfd_coff_set_long_section_names_allowed\n   (bfd *, int);\n #else /* !defined (COFF_LONG_SECTION_NAMES) */\n-static bfd_boolean bfd_coff_set_long_section_names_disallowed\n+static bool bfd_coff_set_long_section_names_disallowed\n   (bfd *, int);\n #endif /* defined (COFF_LONG_SECTION_NAMES) */\n static long sec_to_styp_flags\n   (const char *, flagword);\n-static bfd_boolean styp_to_sec_flags\n+static bool styp_to_sec_flags\n   (bfd *, void *, const char *, asection *, flagword *);\n-static bfd_boolean coff_bad_format_hook\n+static bool coff_bad_format_hook\n   (bfd *, void *);\n static void coff_set_custom_section_alignment\n   (bfd *, asection *, const struct coff_section_alignment_entry *,\n    const unsigned int);\n-static bfd_boolean coff_new_section_hook\n+static bool coff_new_section_hook\n   (bfd *, asection *);\n-static bfd_boolean coff_set_arch_mach_hook\n+static bool coff_set_arch_mach_hook\n   (bfd *, void *);\n-static bfd_boolean coff_write_relocs\n+static bool coff_write_relocs\n   (bfd *, int);\n-static bfd_boolean coff_set_flags\n+static bool coff_set_flags\n   (bfd *, unsigned int *, unsigned short *);\n-static bfd_boolean coff_set_arch_mach\n+static bool coff_set_arch_mach\n   (bfd *, enum bfd_architecture, unsigned long) ATTRIBUTE_UNUSED;\n-static bfd_boolean coff_compute_section_file_positions\n+static bool coff_compute_section_file_positions\n   (bfd *);\n-static bfd_boolean coff_write_object_contents\n+static bool coff_write_object_contents\n   (bfd *) ATTRIBUTE_UNUSED;\n-static bfd_boolean coff_set_section_contents\n+static bool coff_set_section_contents\n   (bfd *, asection *, const void *, file_ptr, bfd_size_type);\n-static bfd_boolean coff_slurp_line_table\n+static bool coff_slurp_line_table\n   (bfd *, asection *);\n-static bfd_boolean coff_slurp_symbol_table\n+static bool coff_slurp_symbol_table\n   (bfd *);\n static enum coff_symbol_classification coff_classify_symbol\n   (bfd *, struct internal_syment *);\n-static bfd_boolean coff_slurp_reloc_table\n+static bool coff_slurp_reloc_table\n   (bfd *, asection *, asymbol **);\n static long coff_canonicalize_reloc\n   (bfd *, asection *, arelent **, asymbol **);\n@@ -446,28 +446,28 @@ static flagword handle_COMDAT\n   (bfd *, flagword, void *, const char *, asection *);\n #endif\n #ifdef TICOFF\n-static bfd_boolean ticoff0_bad_format_hook\n+static bool ticoff0_bad_format_hook\n   (bfd *, void * );\n-static bfd_boolean ticoff1_bad_format_hook\n+static bool ticoff1_bad_format_hook\n   (bfd *, void * );\n #endif\n \f\n /* void warning(); */\n \n #if defined (COFF_LONG_SECTION_NAMES)\n-static bfd_boolean\n+static bool\n bfd_coff_set_long_section_names_allowed (bfd *abfd, int enable)\n {\n   coff_backend_info (abfd)->_bfd_coff_long_section_names = enable;\n-  return TRUE;\n+  return true;\n }\n #else /* !defined (COFF_LONG_SECTION_NAMES) */\n-static bfd_boolean\n+static bool\n bfd_coff_set_long_section_names_disallowed (bfd *abfd, int enable)\n {\n   (void) abfd;\n   (void) enable;\n-  return FALSE;\n+  return false;\n }\n #endif /* defined (COFF_LONG_SECTION_NAMES) */\n \n@@ -640,7 +640,7 @@ static long\n sec_to_styp_flags (const char *sec_name, flagword sec_flags)\n {\n   long styp_flags = 0;\n-  bfd_boolean is_dbg = FALSE;\n+  bool is_dbg = false;\n \n   if (startswith (sec_name, DOT_DEBUG)\n       || startswith (sec_name, DOT_ZDEBUG)\n@@ -649,7 +649,7 @@ sec_to_styp_flags (const char *sec_name, flagword sec_flags)\n       || startswith (sec_name, GNU_LINKONCE_WT)\n #endif\n       || startswith (sec_name, \".stab\"))\n-    is_dbg = TRUE;\n+    is_dbg = true;\n \n   /* caution: there are at least three groups of symbols that have\n      very similar bits and meanings: IMAGE_SCN*, SEC_*, and STYP_*.\n@@ -729,7 +729,7 @@ sec_to_styp_flags (const char *sec_name, flagword sec_flags)\n \n #ifndef COFF_WITH_PE\n \n-static bfd_boolean\n+static bool\n styp_to_sec_flags (bfd *abfd,\n \t\t   void * hdr,\n \t\t   const char *name,\n@@ -896,10 +896,10 @@ styp_to_sec_flags (bfd *abfd,\n #endif\n \n   if (flags_ptr == NULL)\n-    return FALSE;\n+    return false;\n \n   * flags_ptr = sec_flags;\n-  return TRUE;\n+  return true;\n }\n \n #else /* COFF_WITH_PE */\n@@ -1190,7 +1190,7 @@ handle_COMDAT (bfd * abfd,\n    required information.  FIXME: Is the COMDAT symbol index used for\n    any purpose other than objdump?  */\n \n-static bfd_boolean\n+static bool\n styp_to_sec_flags (bfd *abfd,\n \t\t   void * hdr,\n \t\t   const char *name,\n@@ -1200,8 +1200,8 @@ styp_to_sec_flags (bfd *abfd,\n   struct internal_scnhdr *internal_s = (struct internal_scnhdr *) hdr;\n   unsigned long styp_flags = internal_s->s_flags;\n   flagword sec_flags;\n-  bfd_boolean result = TRUE;\n-  bfd_boolean is_dbg = FALSE;\n+  bool result = true;\n+  bool is_dbg = false;\n \n   if (startswith (name, DOT_DEBUG)\n       || startswith (name, DOT_ZDEBUG)\n@@ -1215,7 +1215,7 @@ styp_to_sec_flags (bfd *abfd,\n       || startswith (name, GNU_DEBUGALTLINK)\n #endif\n       || startswith (name, \".stab\"))\n-    is_dbg = TRUE;\n+    is_dbg = true;\n   /* Assume read only unless IMAGE_SCN_MEM_WRITE is specified.  */\n   sec_flags = SEC_READONLY;\n \n@@ -1342,7 +1342,7 @@ styp_to_sec_flags (bfd *abfd,\n \t    /* xgettext:c-format */\n \t    (_(\"%pB (%s): section flag %s (%#lx) ignored\"),\n \t     abfd, name, unhandled, flag);\n-\t  result = FALSE;\n+\t  result = false;\n \t}\n     }\n \n@@ -1439,14 +1439,14 @@ Special entry points for gdb to swap in coff symbol table parts:\n .  unsigned int _bfd_relsz;\n .  unsigned int _bfd_linesz;\n .  unsigned int _bfd_filnmlen;\n-.  bfd_boolean _bfd_coff_long_filenames;\n+.  bool _bfd_coff_long_filenames;\n .\n-.  bfd_boolean _bfd_coff_long_section_names;\n-.  bfd_boolean (*_bfd_coff_set_long_section_names)\n+.  bool _bfd_coff_long_section_names;\n+.  bool (*_bfd_coff_set_long_section_names)\n .    (bfd *, int);\n .\n .  unsigned int _bfd_coff_default_section_alignment_power;\n-.  bfd_boolean _bfd_coff_force_symnames_in_strings;\n+.  bool _bfd_coff_force_symnames_in_strings;\n .  unsigned int _bfd_coff_debug_string_prefix_length;\n .  unsigned int _bfd_coff_max_nscns;\n .\n@@ -1462,32 +1462,32 @@ Special entry points for gdb to swap in coff symbol table parts:\n .  void (*_bfd_coff_swap_reloc_in)\n .    (bfd *abfd, void *, void *);\n .\n-.  bfd_boolean (*_bfd_coff_bad_format_hook)\n+.  bool (*_bfd_coff_bad_format_hook)\n .    (bfd *, void *);\n .\n-.  bfd_boolean (*_bfd_coff_set_arch_mach_hook)\n+.  bool (*_bfd_coff_set_arch_mach_hook)\n .    (bfd *, void *);\n .\n .  void * (*_bfd_coff_mkobject_hook)\n .    (bfd *, void *, void *);\n .\n-.  bfd_boolean (*_bfd_styp_to_sec_flags_hook)\n+.  bool (*_bfd_styp_to_sec_flags_hook)\n .    (bfd *, void *, const char *, asection *, flagword *);\n .\n .  void (*_bfd_set_alignment_hook)\n .    (bfd *, asection *, void *);\n .\n-.  bfd_boolean (*_bfd_coff_slurp_symbol_table)\n+.  bool (*_bfd_coff_slurp_symbol_table)\n .    (bfd *);\n .\n-.  bfd_boolean (*_bfd_coff_symname_in_debug)\n+.  bool (*_bfd_coff_symname_in_debug)\n .    (bfd *, struct internal_syment *);\n .\n-.  bfd_boolean (*_bfd_coff_pointerize_aux_hook)\n+.  bool (*_bfd_coff_pointerize_aux_hook)\n .    (bfd *, combined_entry_type *, combined_entry_type *,\n .     unsigned int, combined_entry_type *);\n .\n-.  bfd_boolean (*_bfd_coff_print_aux)\n+.  bool (*_bfd_coff_print_aux)\n .    (bfd *, FILE *, combined_entry_type *, combined_entry_type *,\n .     combined_entry_type *, unsigned int);\n .\n@@ -1502,36 +1502,36 @@ Special entry points for gdb to swap in coff symbol table parts:\n .  enum coff_symbol_classification (*_bfd_coff_classify_symbol)\n .    (bfd *, struct internal_syment *);\n .\n-.  bfd_boolean (*_bfd_coff_compute_section_file_positions)\n+.  bool (*_bfd_coff_compute_section_file_positions)\n .    (bfd *);\n .\n-.  bfd_boolean (*_bfd_coff_start_final_link)\n+.  bool (*_bfd_coff_start_final_link)\n .    (bfd *, struct bfd_link_info *);\n .\n-.  bfd_boolean (*_bfd_coff_relocate_section)\n+.  bool (*_bfd_coff_relocate_section)\n .    (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,\n .     struct internal_reloc *, struct internal_syment *, asection **);\n .\n .  reloc_howto_type *(*_bfd_coff_rtype_to_howto)\n .    (bfd *, asection *, struct internal_reloc *,\n .     struct coff_link_hash_entry *, struct internal_syment *, bfd_vma *);\n .\n-.  bfd_boolean (*_bfd_coff_adjust_symndx)\n+.  bool (*_bfd_coff_adjust_symndx)\n .    (bfd *, struct bfd_link_info *, bfd *, asection *,\n-.     struct internal_reloc *, bfd_boolean *);\n+.     struct internal_reloc *, bool *);\n .\n-.  bfd_boolean (*_bfd_coff_link_add_one_symbol)\n+.  bool (*_bfd_coff_link_add_one_symbol)\n .    (struct bfd_link_info *, bfd *, const char *, flagword,\n-.     asection *, bfd_vma, const char *, bfd_boolean, bfd_boolean,\n+.     asection *, bfd_vma, const char *, bool, bool,\n .     struct bfd_link_hash_entry **);\n .\n-.  bfd_boolean (*_bfd_coff_link_output_has_begun)\n+.  bool (*_bfd_coff_link_output_has_begun)\n .    (bfd *, struct coff_final_link_info *);\n .\n-.  bfd_boolean (*_bfd_coff_final_link_postscript)\n+.  bool (*_bfd_coff_final_link_postscript)\n .    (bfd *, struct coff_final_link_info *);\n .\n-.  bfd_boolean (*_bfd_coff_print_pdata)\n+.  bool (*_bfd_coff_print_pdata)\n .    (bfd *, void *);\n .\n .} bfd_coff_backend_data;\n@@ -1684,40 +1684,40 @@ Special entry points for gdb to swap in coff symbol table parts:\n \n /* See whether the magic number matches.  */\n \n-static bfd_boolean\n+static bool\n coff_bad_format_hook (bfd * abfd ATTRIBUTE_UNUSED, void * filehdr)\n {\n   struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;\n \n   if (BADMAG (*internal_f))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n #ifdef TICOFF\n-static bfd_boolean\n+static bool\n ticoff0_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED, void * filehdr)\n {\n   struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;\n \n   if (COFF0_BADMAG (*internal_f))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n #endif\n \n #ifdef TICOFF\n-static bfd_boolean\n+static bool\n ticoff1_bad_format_hook (bfd *abfd ATTRIBUTE_UNUSED, void * filehdr)\n {\n   struct internal_filehdr *internal_f = (struct internal_filehdr *) filehdr;\n \n   if (COFF1_BADMAG (*internal_f))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n #endif\n \n@@ -1787,7 +1787,7 @@ static const unsigned int coff_section_alignment_table_size =\n /* Initialize a section structure with information peculiar to this\n    particular implementation of COFF.  */\n \n-static bfd_boolean\n+static bool\n coff_new_section_hook (bfd * abfd, asection * section)\n {\n   combined_entry_type *native;\n@@ -1820,7 +1820,7 @@ coff_new_section_hook (bfd * abfd, asection * section)\n \n   /* Set up the section symbol.  */\n   if (!_bfd_generic_new_section_hook (abfd, section))\n-    return FALSE;\n+    return false;\n \n   /* Allocate aux records for section symbols, to store size and\n      related info.\n@@ -1830,15 +1830,15 @@ coff_new_section_hook (bfd * abfd, asection * section)\n   amt = sizeof (combined_entry_type) * 10;\n   native = (combined_entry_type *) bfd_zalloc (abfd, amt);\n   if (native == NULL)\n-    return FALSE;\n+    return false;\n \n   /* We don't need to set up n_name, n_value, or n_scnum in the native\n      symbol information, since they'll be overridden by the BFD symbol\n      anyhow.  However, we do need to set the type and storage class,\n      in case this symbol winds up getting written out.  The value 0\n      for n_numaux is already correct.  */\n \n-  native->is_sym = TRUE;\n+  native->is_sym = true;\n   native->u.syment.n_type = T_NULL;\n   native->u.syment.n_sclass = sclass;\n \n@@ -1848,7 +1848,7 @@ coff_new_section_hook (bfd * abfd, asection * section)\n \t\t\t\t     coff_section_alignment_table,\n \t\t\t\t     coff_section_alignment_table_size);\n \n-  return TRUE;\n+  return true;\n }\n \n #ifdef COFF_ALIGN_IN_SECTION_HEADER\n@@ -2041,15 +2041,15 @@ coff_set_alignment_hook (bfd *abfd ATTRIBUTE_UNUSED,\n \n #ifndef coff_mkobject\n \n-static bfd_boolean\n+static bool\n coff_mkobject (bfd * abfd)\n {\n   coff_data_type *coff;\n   size_t amt = sizeof (coff_data_type);\n \n   abfd->tdata.coff_obj_data = bfd_zalloc (abfd, amt);\n   if (abfd->tdata.coff_obj_data == NULL)\n-    return FALSE;\n+    return false;\n   coff = coff_data (abfd);\n   coff->symbols = NULL;\n   coff->conversion_table = NULL;\n@@ -2059,7 +2059,7 @@ coff_mkobject (bfd * abfd)\n \n /*  make_abs_section(abfd);*/\n \n-  return TRUE;\n+  return true;\n }\n #endif\n \n@@ -2113,7 +2113,7 @@ coff_mkobject_hook (bfd * abfd,\n # else\n       xcoff->xcoff64 = 0;\n # endif\n-      xcoff->full_aouthdr = TRUE;\n+      xcoff->full_aouthdr = true;\n       xcoff->toc = internal_a->o_toc;\n       xcoff->sntoc = internal_a->o_sntoc;\n       xcoff->snentry = internal_a->o_snentry;\n@@ -2150,7 +2150,7 @@ coff_mkobject_hook (bfd * abfd,\n    would be target independent and would also be much more successful\n    at linking together COFF files for different architectures.  */\n \n-static bfd_boolean\n+static bool\n coff_set_arch_mach_hook (bfd *abfd, void * filehdr)\n {\n   unsigned long machine;\n@@ -2232,7 +2232,7 @@ coff_set_arch_mach_hook (bfd *abfd, void * filehdr)\n \t  machine = ((unsigned)internal_f->f_flags & F_MACHMASK) >> 12;\n \t  break;\n \tdefault:\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n #endif\n@@ -2248,7 +2248,7 @@ coff_set_arch_mach_hook (bfd *abfd, void * filehdr)\n \t  machine = bfd_mach_z8002;\n \t  break;\n \tdefault:\n-\t  return FALSE;\n+\t  return false;\n \t}\n       break;\n #endif\n@@ -2282,10 +2282,10 @@ coff_set_arch_mach_hook (bfd *abfd, void * filehdr)\n \t\tbfd_size_type amt = bfd_coff_symesz (abfd);\n \n \t\tif (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\tbuf = _bfd_malloc_and_read (abfd, amt, amt);\n \t\tif (buf == NULL)\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\tbfd_coff_swap_sym_in (abfd, buf, & sym);\n \t\tif (sym.n_sclass == C_FILE)\n \t\t  cputype = sym.n_type & 0xff;\n@@ -2401,17 +2401,17 @@ coff_set_arch_mach_hook (bfd *abfd, void * filehdr)\n     }\n \n   bfd_default_set_arch_mach (abfd, arch, machine);\n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n symname_in_debug_hook (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t       struct internal_syment *sym ATTRIBUTE_UNUSED)\n {\n #ifdef SYMNAME_IN_DEBUG\n   return SYMNAME_IN_DEBUG (sym) != 0;\n #else\n-  return FALSE;\n+  return false;\n #endif\n }\n \n@@ -2423,7 +2423,7 @@ symname_in_debug_hook (bfd *abfd ATTRIBUTE_UNUSED,\n \n /* Handle the csect auxent of a C_EXT, C_AIX_WEAKEXT or C_HIDEXT symbol.  */\n \n-static bfd_boolean\n+static bool\n coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t  combined_entry_type *table_base,\n \t\t\t  combined_entry_type *symbol,\n@@ -2446,12 +2446,12 @@ coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,\n \n       /* Return TRUE to indicate that the caller should not do any\n \t further work on this auxent.  */\n-      return TRUE;\n+      return true;\n     }\n \n   /* Return FALSE to indicate that this auxent should be handled by\n      the caller.  */\n-  return FALSE;\n+  return false;\n }\n \n #else\n@@ -2460,7 +2460,7 @@ coff_pointerize_aux_hook (bfd *abfd ATTRIBUTE_UNUSED,\n \n /* Print an aux entry.  This returns TRUE if it has printed it.  */\n \n-static bfd_boolean\n+static bool\n coff_print_aux (bfd *abfd ATTRIBUTE_UNUSED,\n \t\tFILE *file ATTRIBUTE_UNUSED,\n \t\tcombined_entry_type *table_base ATTRIBUTE_UNUSED,\n@@ -2501,12 +2501,12 @@ coff_print_aux (bfd *abfd ATTRIBUTE_UNUSED,\n \t       (unsigned int) aux->u.auxent.x_csect.x_smclas,\n \t       aux->u.auxent.x_csect.x_stab,\n \t       (unsigned int) aux->u.auxent.x_csect.x_snstab);\n-      return TRUE;\n+      return true;\n     }\n #endif\n \n   /* Return FALSE to indicate that no special action was taken.  */\n-  return FALSE;\n+  return false;\n }\n \n /*\n@@ -2542,7 +2542,7 @@ compare_arelent_ptr (const void * x, const void * y)\n \n #endif /* TARG_AUX */\n \n-static bfd_boolean\n+static bool\n coff_write_relocs (bfd * abfd, int first_undef)\n {\n   asection *s;\n@@ -2566,7 +2566,7 @@ coff_write_relocs (bfd * abfd, int first_undef)\n \tif (p == NULL)\n \t  {\n \t    if (s->reloc_count > 0)\n-\t      return FALSE;\n+\t      return false;\n \t  }\n \telse\n \t  {\n@@ -2577,7 +2577,7 @@ coff_write_relocs (bfd * abfd, int first_undef)\n #endif\n \n       if (bfd_seek (abfd, s->rel_filepos, SEEK_SET) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n #ifdef COFF_WITH_EXTENDED_RELOC_COUNTER\n       if ((obj_pe (abfd) || obj_go32 (abfd)) && s->reloc_count >= 0xffff)\n@@ -2591,7 +2591,7 @@ coff_write_relocs (bfd * abfd, int first_undef)\n \t  coff_swap_reloc_out (abfd, &n, &dst);\n \t  if (bfd_bwrite (& dst, (bfd_size_type) bfd_coff_relsz (abfd),\n \t\t\t  abfd) != bfd_coff_relsz (abfd))\n-\t    return FALSE;\n+\t    return false;\n \t}\n #endif\n \n@@ -2663,7 +2663,7 @@ coff_write_relocs (bfd * abfd, int first_undef)\n \t\t\t_bfd_error_handler (_(\"%pB: reloc against a non-existent\"\n \t\t\t\t\t      \" symbol index: %ld\"),\n \t\t\t\t\t    abfd, n.r_symndx);\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t      }\n \t\t  }\n \t      }\n@@ -2682,21 +2682,21 @@ coff_write_relocs (bfd * abfd, int first_undef)\n \n \t  if (bfd_bwrite (& dst, (bfd_size_type) bfd_coff_relsz (abfd),\n \t\t\t abfd) != bfd_coff_relsz (abfd))\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n #ifdef TARG_AUX\n       free (p);\n #endif\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Set flags and magic number of a coff file from architecture and machine\n    type.  Result is TRUE if we can represent the arch&type, FALSE if not.  */\n \n-static bfd_boolean\n+static bool\n coff_set_flags (bfd * abfd,\n \t\tunsigned int *magicp ATTRIBUTE_UNUSED,\n \t\tunsigned short *flagsp ATTRIBUTE_UNUSED)\n@@ -2720,9 +2720,9 @@ coff_set_flags (bfd * abfd,\n \t  *flagsp = bfd_get_mach (abfd) << 12;\n \t  break;\n \tdefault:\n-\t  return FALSE;\n+\t  return false;\n \t}\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef Z8KMAGIC\n@@ -2733,15 +2733,15 @@ coff_set_flags (bfd * abfd,\n \t{\n \tcase bfd_mach_z8001: *flagsp = F_Z8001;\tbreak;\n \tcase bfd_mach_z8002: *flagsp = F_Z8002;\tbreak;\n-\tdefault:\t     return FALSE;\n+\tdefault:\t     return false;\n \t}\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef TIC30MAGIC\n     case bfd_arch_tic30:\n       *magicp = TIC30MAGIC;\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef TICOFF_DEFAULT_MAGIC\n@@ -2764,11 +2764,11 @@ coff_set_flags (bfd * abfd,\n \t      *magicp = TICOFF2MAGIC;\n \t      break;\n \t    default:\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n       TICOFF_TARGET_MACHINE_SET (flagsp, bfd_get_mach (abfd));\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef ARMMAGIC\n@@ -2807,7 +2807,7 @@ coff_set_flags (bfd * abfd,\n \tcase bfd_mach_arm_5TE: * flagsp |= F_ARM_5; break;\n \tcase bfd_mach_arm_XScale: * flagsp |= F_ARM_5; break;\n \t}\n-      return TRUE;\n+      return true;\n #endif\n \n #if defined(I386MAGIC) || defined(AMD64MAGIC)\n@@ -2822,13 +2822,13 @@ coff_set_flags (bfd * abfd,\n #if defined AMD64MAGIC\n       *magicp = AMD64MAGIC;\n #endif\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef IA64MAGIC\n     case bfd_arch_ia64:\n       *magicp = IA64MAGIC;\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef SH_ARCH_MAGIC_BIG\n@@ -2841,13 +2841,13 @@ coff_set_flags (bfd * abfd,\n       else\n \t*magicp = SH_ARCH_MAGIC_LITTLE;\n #endif\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef MIPS_ARCH_MAGIC_WINCE\n     case bfd_arch_mips:\n       *magicp = MIPS_ARCH_MAGIC_WINCE;\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef SPARCMAGIC\n@@ -2857,33 +2857,31 @@ coff_set_flags (bfd * abfd,\n       /* Just overwrite the usual value if we're doing Lynx.  */\n       *magicp = LYNXCOFFMAGIC;\n #endif\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef RS6000COFF_C\n     case bfd_arch_rs6000:\n     case bfd_arch_powerpc:\n       BFD_ASSERT (bfd_get_flavour (abfd) == bfd_target_xcoff_flavour);\n       *magicp = bfd_xcoff_magic_number (abfd);\n-      return TRUE;\n+      return true;\n #endif\n \n #ifdef MCOREMAGIC\n     case bfd_arch_mcore:\n       * magicp = MCOREMAGIC;\n-      return TRUE;\n+      return true;\n #endif\n \n     default:\t\t\t/* Unknown architecture.  */\n-      /* Fall through to \"return FALSE\" below, to avoid\n-\t \"statement never reached\" errors on the one below.  */\n       break;\n     }\n \n-  return FALSE;\n+  return false;\n }\n \n-static bfd_boolean\n+static bool\n coff_set_arch_mach (bfd * abfd,\n \t\t    enum bfd_architecture arch,\n \t\t    unsigned long machine)\n@@ -2892,13 +2890,13 @@ coff_set_arch_mach (bfd * abfd,\n   unsigned short dummy2;\n \n   if (! bfd_default_set_arch_mach (abfd, arch, machine))\n-    return FALSE;\n+    return false;\n \n   if (arch != bfd_arch_unknown\n       && ! coff_set_flags (abfd, &dummy1, &dummy2))\n-    return FALSE;\t\t/* We can't represent this type.  */\n+    return false;\t\t/* We can't represent this type.  */\n \n-  return TRUE;\t\t\t/* We're easy...  */\n+  return true;\t\t\t/* We're easy...  */\n }\n \n #ifdef COFF_IMAGE_WITH_PE\n@@ -2929,12 +2927,12 @@ sort_by_secaddr (const void * arg1, const void * arg2)\n #undef ALIGN_SECTIONS_IN_FILE\n #endif\n \n-static bfd_boolean\n+static bool\n coff_compute_section_file_positions (bfd * abfd)\n {\n   asection *current;\n   file_ptr sofar = bfd_coff_filhsz (abfd);\n-  bfd_boolean align_adjust;\n+  bool align_adjust;\n   unsigned int target_index;\n #ifdef ALIGN_SECTIONS_IN_FILE\n   asection *previous = NULL;\n@@ -2961,7 +2959,7 @@ coff_compute_section_file_positions (bfd * abfd)\n \t  _bfd_error_handler\n \t    /* xgettext:c-format */\n \t    (_(\"%pB: page size is too large (0x%x)\"), abfd, page_size);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n   else\n@@ -3064,7 +3062,7 @@ coff_compute_section_file_positions (bfd * abfd)\n     amt = sizeof (struct asection *) * (count + 1);\n     section_list = (asection **) bfd_malloc (amt);\n     if (section_list == NULL)\n-      return FALSE;\n+      return false;\n \n     i = 0;\n     for (current = abfd->sections; current != NULL; current = current->next)\n@@ -3121,10 +3119,10 @@ coff_compute_section_file_positions (bfd * abfd)\n       _bfd_error_handler\n \t/* xgettext:c-format */\n \t(_(\"%pB: too many sections (%d)\"), abfd, target_index);\n-      return FALSE;\n+      return false;\n     }\n \n-  align_adjust = FALSE;\n+  align_adjust = false;\n   for (current = abfd->sections;\n        current != NULL;\n        current = current->next)\n@@ -3138,15 +3136,15 @@ coff_compute_section_file_positions (bfd * abfd)\n \n \t  current->used_by_bfd = bfd_zalloc (abfd, amt);\n \t  if (current->used_by_bfd == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t}\n       if (pei_section_data (abfd, current) == NULL)\n \t{\n \t  size_t amt = sizeof (struct pei_section_tdata);\n \n \t  coff_section_data (abfd, current)->tdata = bfd_zalloc (abfd, amt);\n \t  if (coff_section_data (abfd, current)->tdata == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t}\n       if (pei_section_data (abfd, current)->virt_size == 0)\n \tpei_section_data (abfd, current)->virt_size = current->size;\n@@ -3260,7 +3258,7 @@ coff_compute_section_file_positions (bfd * abfd)\n \t size, in case the caller only writes out data to the\n \t unaligned size.  */\n       if (pei_section_data (abfd, current)->virt_size < current->size)\n-\talign_adjust = TRUE;\n+\talign_adjust = true;\n #endif\n \n #ifdef _LIB\n@@ -3288,7 +3286,7 @@ coff_compute_section_file_positions (bfd * abfd)\n       b = 0;\n       if (bfd_seek (abfd, sofar - 1, SEEK_SET) != 0\n \t  || bfd_bwrite (&b, (bfd_size_type) 1, abfd) != 1)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Make sure the relocations are aligned.  We don't need to make\n@@ -3297,14 +3295,14 @@ coff_compute_section_file_positions (bfd * abfd)\n   sofar = BFD_ALIGN (sofar, 1 << COFF_DEFAULT_SECTION_ALIGNMENT_POWER);\n \n   obj_relocbase (abfd) = sofar;\n-  abfd->output_has_begun = TRUE;\n+  abfd->output_has_begun = true;\n \n-  return TRUE;\n+  return true;\n }\n \n #ifdef COFF_IMAGE_WITH_PE\n \n-static bfd_boolean\n+static bool\n coff_read_word (bfd *abfd, unsigned int *value, unsigned int *pelength)\n {\n   unsigned char b[2];\n@@ -3314,7 +3312,7 @@ coff_read_word (bfd *abfd, unsigned int *value, unsigned int *pelength)\n   if (status < 1)\n     {\n       *value = 0;\n-      return FALSE;\n+      return false;\n     }\n \n   if (status == 1)\n@@ -3324,13 +3322,13 @@ coff_read_word (bfd *abfd, unsigned int *value, unsigned int *pelength)\n \n   *pelength += status;\n \n-  return TRUE;\n+  return true;\n }\n \n static unsigned int\n coff_compute_checksum (bfd *abfd, unsigned int *pelength)\n {\n-  bfd_boolean more_data;\n+  bool more_data;\n   file_ptr filepos;\n   unsigned int value;\n   unsigned int total;\n@@ -3354,7 +3352,7 @@ coff_compute_checksum (bfd *abfd, unsigned int *pelength)\n   return (0xffff & (total + (total >> 0x10)));\n }\n \n-static bfd_boolean\n+static bool\n coff_apply_checksum (bfd *abfd)\n {\n   unsigned int computed;\n@@ -3363,50 +3361,50 @@ coff_apply_checksum (bfd *abfd)\n   unsigned int pelength;\n \n   if (bfd_seek (abfd, 0x3c, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   if (!coff_read_word (abfd, &peheader, &pelength))\n-    return FALSE;\n+    return false;\n \n   if (bfd_seek (abfd, peheader + 0x58, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   checksum = 0;\n   bfd_bwrite (&checksum, (bfd_size_type) 4, abfd);\n \n   if (bfd_seek (abfd, peheader, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   computed = coff_compute_checksum (abfd, &pelength);\n \n   checksum = computed + pelength;\n \n   if (bfd_seek (abfd, peheader + 0x58, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   bfd_bwrite (&checksum, (bfd_size_type) 4, abfd);\n \n-  return TRUE;\n+  return true;\n }\n \n #endif /* COFF_IMAGE_WITH_PE */\n \n-static bfd_boolean\n+static bool\n coff_write_object_contents (bfd * abfd)\n {\n   asection *current;\n-  bfd_boolean hasrelocs = FALSE;\n-  bfd_boolean haslinno = FALSE;\n+  bool hasrelocs = false;\n+  bool haslinno = false;\n #ifdef COFF_IMAGE_WITH_PE\n-  bfd_boolean hasdebug = FALSE;\n+  bool hasdebug = false;\n #endif\n   file_ptr scn_base;\n   file_ptr reloc_base;\n   file_ptr lineno_base;\n   file_ptr sym_base;\n   unsigned long reloc_size = 0, reloc_count = 0;\n   unsigned long lnno_size = 0;\n-  bfd_boolean long_section_names;\n+  bool long_section_names;\n   asection *text_sec = NULL;\n   asection *data_sec = NULL;\n   asection *bss_sec = NULL;\n@@ -3429,7 +3427,7 @@ coff_write_object_contents (bfd * abfd)\n   if (! abfd->output_has_begun)\n     {\n       if (! coff_compute_section_file_positions (abfd))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   reloc_base = obj_relocbase (abfd);\n@@ -3498,21 +3496,21 @@ coff_write_object_contents (bfd * abfd)\n     }\n \n   if (bfd_seek (abfd, scn_base, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n-  long_section_names = FALSE;\n+  long_section_names = false;\n   for (current = abfd->sections;\n        current != NULL;\n        current = current->next)\n     {\n       struct internal_scnhdr section;\n #ifdef COFF_IMAGE_WITH_PE\n-      bfd_boolean is_reloc_section = FALSE;\n+      bool is_reloc_section = false;\n \n       if (strcmp (current->name, DOT_RELOC) == 0)\n \t{\n-\t  is_reloc_section = TRUE;\n-\t  hasrelocs = TRUE;\n+\t  is_reloc_section = true;\n+\t  hasrelocs = true;\n \t  pe_data (abfd)->has_reloc_section = 1;\n \t}\n #endif\n@@ -3549,7 +3547,7 @@ coff_write_object_contents (bfd * abfd)\n \t\t    /* xgettext:c-format */\n \t\t    (_(\"%pB: section %pA: string table overflow at offset %ld\"),\n \t\t    abfd, current, (unsigned long) string_size);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \n \t      /* We do not need to use snprintf here as we have already verfied\n@@ -3559,7 +3557,7 @@ coff_write_object_contents (bfd * abfd)\n \t      /* Then strncpy takes care of any padding for us.  */\n \t      strncpy (section.s_name, s_name_buf, SCNNMLEN);\n \t      string_size += len + 1;\n-\t      long_section_names = TRUE;\n+\t      long_section_names = true;\n \t    }\n \t}\n #endif\n@@ -3607,14 +3605,14 @@ coff_write_object_contents (bfd * abfd)\n #ifndef COFF_IMAGE_WITH_PE\n       /* In PEI, relocs come in the .reloc section.  */\n       if (current->reloc_count != 0)\n-\thasrelocs = TRUE;\n+\thasrelocs = true;\n #endif\n       if (current->lineno_count != 0)\n-\thaslinno = TRUE;\n+\thaslinno = true;\n #ifdef COFF_IMAGE_WITH_PE\n       if ((current->flags & SEC_DEBUGGING) != 0\n \t  && ! is_reloc_section)\n-\thasdebug = TRUE;\n+\thasdebug = true;\n #endif\n \n #ifdef RS6000COFF_C\n@@ -3649,7 +3647,7 @@ coff_write_object_contents (bfd * abfd)\n       if ((unsigned int)COFF_DECODE_ALIGNMENT(section.s_flags)\n \t  != current->alignment_power)\n \t{\n-\t  bfd_boolean warn = coff_data (abfd)->link_info\n+\t  bool warn = coff_data (abfd)->link_info\n \t    && !bfd_link_relocatable (coff_data (abfd)->link_info);\n \n \t  _bfd_error_handler\n@@ -3660,7 +3658,7 @@ coff_write_object_contents (bfd * abfd)\n \t  if (!warn)\n \t    {\n \t      bfd_set_error (bfd_error_nonrepresentable_section);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n #endif\n@@ -3681,7 +3679,7 @@ coff_write_object_contents (bfd * abfd)\n \n \t  if (bfd_coff_swap_scnhdr_out (abfd, &section, &buff) == 0\n \t      || bfd_bwrite (& buff, amt, abfd) != amt)\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n #ifdef COFF_WITH_PE\n@@ -3807,7 +3805,7 @@ coff_write_object_contents (bfd * abfd)\n \t  amt = bfd_coff_scnhsz (abfd);\n \t  if (bfd_coff_swap_scnhdr_out (abfd, &scnhdr, &buff) == 0\n \t      || bfd_bwrite (& buff, amt, abfd) != amt)\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n #endif\n@@ -3980,22 +3978,22 @@ coff_write_object_contents (bfd * abfd)\n       int firstundef;\n \n       if (!coff_renumber_symbols (abfd, &firstundef))\n-\treturn FALSE;\n+\treturn false;\n       coff_mangle_symbols (abfd);\n       if (! coff_write_symbols (abfd))\n-\treturn FALSE;\n+\treturn false;\n       if (! coff_write_linenumbers (abfd))\n-\treturn FALSE;\n+\treturn false;\n       if (! coff_write_relocs (abfd, firstundef))\n-\treturn FALSE;\n+\treturn false;\n     }\n #ifdef COFF_LONG_SECTION_NAMES\n   else if (long_section_names && ! obj_coff_strings_written (abfd))\n     {\n       /* If we have long section names we have to write out the string\n \t table even if there are no symbols.  */\n       if (! coff_write_symbols (abfd))\n-\treturn FALSE;\n+\treturn false;\n     }\n #endif\n   /* If bfd_get_symcount (abfd) != 0, then we are not using the COFF\n@@ -4148,23 +4146,23 @@ coff_write_object_contents (bfd * abfd)\n \n   /* Now write header.  */\n   if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   {\n     char * buff;\n     bfd_size_type amount = bfd_coff_filhsz (abfd);\n \n     buff = (char *) bfd_malloc (amount);\n     if (buff == NULL)\n-      return FALSE;\n+      return false;\n \n     bfd_coff_swap_filehdr_out (abfd, & internal_f, buff);\n     amount = bfd_bwrite (buff, amount, abfd);\n \n     free (buff);\n \n     if (amount != bfd_coff_filhsz (abfd))\n-      return FALSE;\n+      return false;\n   }\n \n   if (abfd->flags & EXEC_P)\n@@ -4176,19 +4174,19 @@ coff_write_object_contents (bfd * abfd)\n \n       buff = (char *) bfd_malloc (amount);\n       if (buff == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       coff_swap_aouthdr_out (abfd, & internal_a, buff);\n       amount = bfd_bwrite (buff, amount, abfd);\n \n       free (buff);\n \n       if (amount != bfd_coff_aoutsz (abfd))\n-\treturn FALSE;\n+\treturn false;\n \n #ifdef COFF_IMAGE_WITH_PE\n       if (! coff_apply_checksum (abfd))\n-\treturn FALSE;\n+\treturn false;\n #endif\n     }\n #ifdef RS6000COFF_C\n@@ -4205,15 +4203,15 @@ coff_write_object_contents (bfd * abfd)\n       else\n \tsize = SMALL_AOUTSZ;\n       if (bfd_bwrite (& buff, (bfd_size_type) size, abfd) != size)\n-\treturn FALSE;\n+\treturn false;\n     }\n #endif\n #endif\n \n-  return TRUE;\n+  return true;\n }\n \n-static bfd_boolean\n+static bool\n coff_set_section_contents (bfd * abfd,\n \t\t\t   sec_ptr section,\n \t\t\t   const void * location,\n@@ -4223,7 +4221,7 @@ coff_set_section_contents (bfd * abfd,\n   if (! abfd->output_has_begun)\t/* Set by bfd.c handler.  */\n     {\n       if (! coff_compute_section_file_positions (abfd))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n #if defined(_LIB) && !defined(TARG_AUX)\n@@ -4266,13 +4264,13 @@ coff_set_section_contents (bfd * abfd,\n   /* Don't write out bss sections - one way to do this is to\n        see if the filepos has not been set.  */\n   if (section->filepos == 0)\n-    return TRUE;\n+    return true;\n \n   if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   if (count == 0)\n-    return TRUE;\n+    return true;\n \n   return bfd_bwrite (location, count, abfd) == count;\n }\n@@ -4334,23 +4332,23 @@ coff_sort_func_alent (const void * arg1, const void * arg2)\n   return 0;\n }\n \n-static bfd_boolean\n+static bool\n coff_slurp_line_table (bfd *abfd, asection *asect)\n {\n   LINENO *native_lineno;\n   alent *lineno_cache;\n   unsigned int counter;\n   alent *cache_ptr;\n   bfd_vma prev_offset = 0;\n-  bfd_boolean ordered = TRUE;\n+  bool ordered = true;\n   unsigned int nbr_func;\n   LINENO *src;\n-  bfd_boolean have_func;\n-  bfd_boolean ret = TRUE;\n+  bool have_func;\n+  bool ret = true;\n   size_t amt;\n \n   if (asect->lineno_count == 0)\n-    return TRUE;\n+    return true;\n \n   BFD_ASSERT (asect->lineno == NULL);\n \n@@ -4359,17 +4357,17 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n       _bfd_error_handler\n \t(_(\"%pB: warning: line number count (%#lx) exceeds section size (%#lx)\"),\n \t abfd, (unsigned long) asect->lineno_count, (unsigned long) asect->size);\n-      return FALSE;\n+      return false;\n     }\n \n   if (_bfd_mul_overflow (asect->lineno_count + 1, sizeof (alent), &amt))\n     {\n       bfd_set_error (bfd_error_file_too_big);\n-      return FALSE;\n+      return false;\n     }\n   lineno_cache = (alent *) bfd_alloc (abfd, amt);\n   if (lineno_cache == NULL)\n-    return FALSE;\n+    return false;\n \n   native_lineno = (LINENO *) buy_and_read (abfd, asect->line_filepos,\n \t\t\t\t\t   asect->lineno_count,\n@@ -4379,14 +4377,14 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n       _bfd_error_handler\n \t(_(\"%pB: warning: line number table read failed\"), abfd);\n       bfd_release (abfd, lineno_cache);\n-      return FALSE;\n+      return false;\n     }\n \n   cache_ptr = lineno_cache;\n   asect->lineno = lineno_cache;\n   src = native_lineno;\n   nbr_func = 0;\n-  have_func = FALSE;\n+  have_func = false;\n \n   for (counter = 0; counter < asect->lineno_count; counter++, src++)\n     {\n@@ -4405,7 +4403,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \t  unsigned long symndx;\n \t  coff_symbol_type *sym;\n \n-\t  have_func = FALSE;\n+\t  have_func = false;\n \t  symndx = dst.l_addr.l_symndx;\n \t  if (symndx >= obj_raw_syment_count (abfd))\n \t    {\n@@ -4414,7 +4412,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \t\t(_(\"%pB: warning: illegal symbol index 0x%lx in line number entry %d\"),\n \t\t abfd, symndx, counter);\n \t      cache_ptr->line_number = -1;\n-\t      ret = FALSE;\n+\t      ret = false;\n \t      continue;\n \t    }\n \n@@ -4428,7 +4426,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \t\t(_(\"%pB: warning: illegal symbol index 0x%lx in line number entry %d\"),\n \t\t abfd, symndx, counter);\n \t      cache_ptr->line_number = -1;\n-\t      ret = FALSE;\n+\t      ret = false;\n \t      continue;\n \t    }\n \t  sym = (coff_symbol_type *) (ent->u.syment._n._n_n._n_zeroes);\n@@ -4442,11 +4440,11 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \t\t(_(\"%pB: warning: illegal symbol in line number entry %d\"),\n \t\t abfd, counter);\n \t      cache_ptr->line_number = -1;\n-\t      ret = FALSE;\n+\t      ret = false;\n \t      continue;\n \t    }\n \n-\t  have_func = TRUE;\n+\t  have_func = true;\n \t  nbr_func++;\n \t  cache_ptr->u.sym = (asymbol *) sym;\n \t  if (sym->lineno != NULL)\n@@ -4457,7 +4455,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \n \t  sym->lineno = cache_ptr;\n \t  if (sym->symbol.value < prev_offset)\n-\t    ordered = FALSE;\n+\t    ordered = false;\n \t  prev_offset = sym->symbol.value;\n \t}\n       else if (!have_func)\n@@ -4484,7 +4482,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n       if (_bfd_mul_overflow (nbr_func, sizeof (alent *), &amt))\n \t{\n \t  bfd_set_error (bfd_error_file_too_big);\n-\t  ret = FALSE;\n+\t  ret = false;\n \t}\n       else if ((func_table = (alent **) bfd_alloc (abfd, amt)) != NULL)\n \t{\n@@ -4504,7 +4502,7 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \t  if (_bfd_mul_overflow (asect->lineno_count, sizeof (alent), &amt))\n \t    {\n \t      bfd_set_error (bfd_error_file_too_big);\n-\t      ret = FALSE;\n+\t      ret = false;\n \t    }\n \t  else if ((n_lineno_cache = (alent *) bfd_alloc (abfd, amt)) != NULL)\n \t    {\n@@ -4530,11 +4528,11 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n \t\t      asect->lineno_count * sizeof (alent));\n \t    }\n \t  else\n-\t    ret = FALSE;\n+\t    ret = false;\n \t  bfd_release (abfd, func_table);\n \t}\n       else\n-\tret = FALSE;\n+\tret = false;\n     }\n \n   return ret;\n@@ -4544,43 +4542,43 @@ coff_slurp_line_table (bfd *abfd, asection *asect)\n    that if coff_relocate_section is defined, the linker will read\n    symbols via coff_link_add_symbols, rather than via this routine.  */\n \n-static bfd_boolean\n+static bool\n coff_slurp_symbol_table (bfd * abfd)\n {\n   combined_entry_type *native_symbols;\n   coff_symbol_type *cached_area;\n   unsigned int *table_ptr;\n   unsigned int number_of_symbols = 0;\n-  bfd_boolean ret = TRUE;\n+  bool ret = true;\n   size_t amt;\n \n   if (obj_symbols (abfd))\n-    return TRUE;\n+    return true;\n \n   /* Read in the symbol table.  */\n   if ((native_symbols = coff_get_normalized_symtab (abfd)) == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Allocate enough room for all the symbols in cached form.  */\n   if (_bfd_mul_overflow (obj_raw_syment_count (abfd),\n \t\t\t sizeof (*cached_area), &amt))\n     {\n       bfd_set_error (bfd_error_file_too_big);\n-      return FALSE;\n+      return false;\n     }\n   cached_area = (coff_symbol_type *) bfd_alloc (abfd, amt);\n   if (cached_area == NULL)\n-    return FALSE;\n+    return false;\n \n   if (_bfd_mul_overflow (obj_raw_syment_count (abfd),\n \t\t\t sizeof (*table_ptr), &amt))\n     {\n       bfd_set_error (bfd_error_file_too_big);\n-      return FALSE;\n+      return false;\n     }\n   table_ptr = (unsigned int *) bfd_zalloc (abfd, amt);\n   if (table_ptr == NULL)\n-    return FALSE;\n+    return false;\n   else\n     {\n       coff_symbol_type *dst = cached_area;\n@@ -4602,7 +4600,7 @@ coff_slurp_symbol_table (bfd * abfd)\n \t  dst->symbol.flags = 0;\n \t  /* PR 17512: file: 079-7098-0.001:0.1.  */\n \t  dst->symbol.value = 0;\n-\t  dst->done_lineno = FALSE;\n+\t  dst->done_lineno = false;\n \n \t  switch (src->u.syment.n_sclass)\n \t    {\n@@ -4876,7 +4874,7 @@ coff_slurp_symbol_table (bfd * abfd)\n \t\t(_(\"%pB: unrecognized storage class %d for %s symbol `%s'\"),\n \t\t abfd, src->u.syment.n_sclass,\n \t\t dst->symbol.section->name, dst->symbol.name);\n-\t      ret = FALSE;\n+\t      ret = false;\n \t      /* Fall through.  */\n \t    case C_HIDDEN:\t/* Ext symbol in dmert public lib.  */\n \t      /* PR 20722: These symbols can also be generated by\n@@ -4909,7 +4907,7 @@ coff_slurp_symbol_table (bfd * abfd)\n     while (p)\n       {\n \tif (! coff_slurp_line_table (abfd, p))\n-\t  return FALSE;\n+\t  return false;\n \tp = p->next;\n       }\n   }\n@@ -5068,7 +5066,7 @@ SUBSUBSECTION\n   }\n #endif\n \n-static bfd_boolean\n+static bool\n coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)\n {\n   RELOC *native_relocs;\n@@ -5078,25 +5076,25 @@ coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)\n   size_t amt;\n \n   if (asect->relocation)\n-    return TRUE;\n+    return true;\n   if (asect->reloc_count == 0)\n-    return TRUE;\n+    return true;\n   if (asect->flags & SEC_CONSTRUCTOR)\n-    return TRUE;\n+    return true;\n   if (!coff_slurp_symbol_table (abfd))\n-    return FALSE;\n+    return false;\n \n   native_relocs = (RELOC *) buy_and_read (abfd, asect->rel_filepos,\n \t\t\t\t\t  asect->reloc_count,\n \t\t\t\t\t  bfd_coff_relsz (abfd));\n   if (_bfd_mul_overflow (asect->reloc_count, sizeof (arelent), &amt))\n     {\n       bfd_set_error (bfd_error_file_too_big);\n-      return FALSE;\n+      return false;\n     }\n   reloc_cache = (arelent *) bfd_alloc (abfd, amt);\n   if (reloc_cache == NULL || native_relocs == NULL)\n-    return FALSE;\n+    return false;\n \n   for (idx = 0; idx < asect->reloc_count; idx++)\n     {\n@@ -5166,12 +5164,12 @@ coff_slurp_reloc_table (bfd * abfd, sec_ptr asect, asymbol ** symbols)\n \t    (_(\"%pB: illegal relocation type %d at address %#\" PRIx64),\n \t     abfd, dst.r_type, (uint64_t) dst.r_vaddr);\n \t  bfd_set_error (bfd_error_bad_value);\n-\t  return FALSE;\n+\t  return false;\n \t}\n     }\n \n   asect->relocation = reloc_cache;\n-  return TRUE;\n+  return true;\n }\n \n #ifndef coff_rtype_to_howto\n@@ -5331,7 +5329,7 @@ dummy_reloc16_extra_cases (bfd *abfd ATTRIBUTE_UNUSED,\n \n #ifndef coff_link_output_has_begun\n \n-static bfd_boolean\n+static bool\n coff_link_output_has_begun (bfd * abfd,\n \t\t\t    struct coff_final_link_info * info ATTRIBUTE_UNUSED)\n {\n@@ -5341,11 +5339,11 @@ coff_link_output_has_begun (bfd * abfd,\n \n #ifndef coff_final_link_postscript\n \n-static bfd_boolean\n+static bool\n coff_final_link_postscript (bfd * abfd ATTRIBUTE_UNUSED,\n \t\t\t    struct coff_final_link_info * pfinfo ATTRIBUTE_UNUSED)\n {\n-  return TRUE;\n+  return true;\n }\n #endif\n \n@@ -5401,16 +5399,16 @@ static bfd_coff_backend_data bfd_coff_std_swap_table ATTRIBUTE_UNUSED =\n   coff_SWAP_scnhdr_out,\n   FILHSZ, AOUTSZ, SCNHSZ, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,\n #ifdef COFF_LONG_FILENAMES\n-  TRUE,\n+  true,\n #else\n-  FALSE,\n+  false,\n #endif\n   COFF_DEFAULT_LONG_SECTION_NAMES,\n   COFF_DEFAULT_SECTION_ALIGNMENT_POWER,\n #ifdef COFF_FORCE_SYMBOLS_IN_STRINGS\n-  TRUE,\n+  true,\n #else\n-  FALSE,\n+  false,\n #endif\n #ifdef COFF_DEBUG_STRING_WIDE_PREFIX\n   4,\n@@ -5442,16 +5440,16 @@ static bfd_coff_backend_data ticoff0_swap_table =\n   coff_SWAP_scnhdr_out,\n   FILHSZ_V0, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ_V0, LINESZ, FILNMLEN,\n #ifdef COFF_LONG_FILENAMES\n-  TRUE,\n+  true,\n #else\n-  FALSE,\n+  false,\n #endif\n   COFF_DEFAULT_LONG_SECTION_NAMES,\n   COFF_DEFAULT_SECTION_ALIGNMENT_POWER,\n #ifdef COFF_FORCE_SYMBOLS_IN_STRINGS\n-  TRUE,\n+  true,\n #else\n-  FALSE,\n+  false,\n #endif\n #ifdef COFF_DEBUG_STRING_WIDE_PREFIX\n   4,\n@@ -5484,16 +5482,16 @@ static bfd_coff_backend_data ticoff1_swap_table =\n   coff_SWAP_scnhdr_out,\n   FILHSZ, AOUTSZ, SCNHSZ_V01, SYMESZ, AUXESZ, RELSZ, LINESZ, FILNMLEN,\n #ifdef COFF_LONG_FILENAMES\n-  TRUE,\n+  true,\n #else\n-  FALSE,\n+  false,\n #endif\n   COFF_DEFAULT_LONG_SECTION_NAMES,\n   COFF_DEFAULT_SECTION_ALIGNMENT_POWER,\n #ifdef COFF_FORCE_SYMBOLS_IN_STRINGS\n-  TRUE,\n+  true,\n #else\n-  FALSE,\n+  false,\n #endif\n #ifdef COFF_DEBUG_STRING_WIDE_PREFIX\n   4,\n@@ -5745,10 +5743,10 @@ static bfd_coff_backend_data bigobj_swap_table =\n   coff_SWAP_scnhdr_out,\n   FILHSZ_BIGOBJ, AOUTSZ, SCNHSZ, SYMESZ_BIGOBJ, AUXESZ_BIGOBJ,\n    RELSZ, LINESZ, FILNMLEN_BIGOBJ,\n-  TRUE,\n+  true,\n   COFF_DEFAULT_LONG_SECTION_NAMES,\n   COFF_DEFAULT_SECTION_ALIGNMENT_POWER,\n-  FALSE,\n+  false,\n   2,\n   1U << 31,\n   coff_bigobj_swap_filehdr_in, coff_SWAP_aouthdr_in, coff_SWAP_scnhdr_in,"
    },
    {
      "sha": "4e1424302025c54feb8c68605fb49b8f098c254f",
      "filename": "bfd/coffgen.c",
      "status": "modified",
      "additions": 127,
      "deletions": 126,
      "changes": 253,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coffgen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/coffgen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/coffgen.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -46,14 +46,14 @@\n /* Take a section header read from a coff file (in HOST byte order),\n    and make a BFD \"section\" out of it.  This is used by ECOFF.  */\n \n-static bfd_boolean\n+static bool\n make_a_section_from_file (bfd *abfd,\n \t\t\t  struct internal_scnhdr *hdr,\n \t\t\t  unsigned int target_index)\n {\n   asection *return_section;\n   char *name;\n-  bfd_boolean result = TRUE;\n+  bool result = true;\n   flagword flags;\n \n   name = NULL;\n@@ -76,22 +76,22 @@ make_a_section_from_file (bfd *abfd,\n \t expect them to be off by default.  This won't directly affect the\n \t format of any output BFD created from this one, but the information\n \t can be used to decide what to do.  */\n-      bfd_coff_set_long_section_names (abfd, TRUE);\n+      bfd_coff_set_long_section_names (abfd, true);\n       memcpy (buf, hdr->s_name + 1, SCNNMLEN - 1);\n       buf[SCNNMLEN - 1] = '\\0';\n       strindex = strtol (buf, &p, 10);\n       if (*p == '\\0' && strindex >= 0)\n \t{\n \t  strings = _bfd_coff_read_string_table (abfd);\n \t  if (strings == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t  if ((bfd_size_type)(strindex + 2) >= obj_coff_strings_len (abfd))\n-\t    return FALSE;\n+\t    return false;\n \t  strings += strindex;\n \t  name = (char *) bfd_alloc (abfd,\n \t\t\t\t     (bfd_size_type) strlen (strings) + 1 + 1);\n \t  if (name == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t  strcpy (name, strings);\n \t}\n     }\n@@ -102,14 +102,14 @@ make_a_section_from_file (bfd *abfd,\n       name = (char *) bfd_alloc (abfd,\n \t\t\t\t (bfd_size_type) sizeof (hdr->s_name) + 1 + 1);\n       if (name == NULL)\n-\treturn FALSE;\n+\treturn false;\n       strncpy (name, (char *) &hdr->s_name[0], sizeof (hdr->s_name));\n       name[sizeof (hdr->s_name)] = 0;\n     }\n \n   return_section = bfd_make_section_anyway (abfd, name);\n   if (return_section == NULL)\n-    return FALSE;\n+    return false;\n \n   return_section->vma = hdr->s_vaddr;\n   return_section->lma = hdr->s_paddr;\n@@ -129,7 +129,7 @@ make_a_section_from_file (bfd *abfd,\n \n   if (! bfd_coff_styp_to_sec_flags_hook (abfd, hdr, name, return_section,\n \t\t\t\t\t & flags))\n-    result = FALSE;\n+    result = false;\n \n   return_section->flags = flags;\n \n@@ -178,7 +178,7 @@ make_a_section_from_file (bfd *abfd,\n \t\t/* xgettext: c-format */\n \t\t(_(\"%pB: unable to initialize compress status for section %s\"),\n \t\t abfd, name);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  if (return_section->compress_status == COMPRESS_SECTION_DONE)\n \t    {\n@@ -188,7 +188,7 @@ make_a_section_from_file (bfd *abfd,\n \n \t\t  new_name = bfd_alloc (abfd, len + 2);\n \t\t  if (new_name == NULL)\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t  new_name[0] = '.';\n \t\t  new_name[1] = 'z';\n \t\t  memcpy (new_name + 2, name + 1, len);\n@@ -202,15 +202,15 @@ make_a_section_from_file (bfd *abfd,\n \t\t/* xgettext: c-format */\n \t\t(_(\"%pB: unable to initialize decompress status for section %s\"),\n \t\t abfd, name);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  if (name[1] == 'z')\n \t    {\n \t      unsigned int len = strlen (name);\n \n \t      new_name = bfd_alloc (abfd, len);\n \t      if (new_name == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      new_name[0] = '.';\n \t      memcpy (new_name + 1, name + 2, len - 1);\n \t    }\n@@ -486,9 +486,9 @@ _bfd_coff_internal_syment_name (bfd *abfd,\n struct internal_reloc *\n _bfd_coff_read_internal_relocs (bfd *abfd,\n \t\t\t\tasection *sec,\n-\t\t\t\tbfd_boolean cache,\n+\t\t\t\tbool cache,\n \t\t\t\tbfd_byte *external_relocs,\n-\t\t\t\tbfd_boolean require_internal,\n+\t\t\t\tbool require_internal,\n \t\t\t\tstruct internal_reloc *internal_relocs)\n {\n   bfd_size_type relsz;\n@@ -685,7 +685,7 @@ fixup_symbol_value (bfd *abfd,\n    chain, and that the last one points to the first external symbol. We\n    do that here too.  */\n \n-bfd_boolean\n+bool\n coff_renumber_symbols (bfd *bfd_ptr, int *first_undef)\n {\n   unsigned int symbol_count = bfd_get_symcount (bfd_ptr);\n@@ -712,7 +712,7 @@ coff_renumber_symbols (bfd *bfd_ptr, int *first_undef)\n     amt = sizeof (asymbol *) * ((bfd_size_type) symbol_count + 1);\n     newsyms = (asymbol **) bfd_alloc (bfd_ptr, amt);\n     if (!newsyms)\n-      return FALSE;\n+      return false;\n     bfd_ptr->outsymbols = newsyms;\n     for (i = 0; i < symbol_count; i++)\n       if ((symbol_ptr_ptr[i]->flags & BSF_NOT_AT_END) != 0\n@@ -774,7 +774,7 @@ coff_renumber_symbols (bfd *bfd_ptr, int *first_undef)\n \n   obj_conv_table_size (bfd_ptr) = native_index;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Run thorough the symbol table again, and fix it so that all\n@@ -968,7 +968,7 @@ coff_fix_symbol_name (bfd *abfd,\n \n /* Write a symbol out to a COFF file.  */\n \n-static bfd_boolean\n+static bool\n coff_write_symbol (bfd *abfd,\n \t\t   asymbol *symbol,\n \t\t   combined_entry_type *native,\n@@ -1011,10 +1011,10 @@ coff_write_symbol (bfd *abfd,\n   symesz = bfd_coff_symesz (abfd);\n   buf = bfd_alloc (abfd, symesz);\n   if (!buf)\n-    return FALSE;\n+    return false;\n   bfd_coff_swap_sym_out (abfd, &native->u.syment, buf);\n   if (bfd_bwrite (buf, symesz, abfd) != symesz)\n-    return FALSE;\n+    return false;\n   bfd_release (abfd, buf);\n \n   if (native->u.syment.n_numaux > 0)\n@@ -1025,7 +1025,7 @@ coff_write_symbol (bfd *abfd,\n       auxesz = bfd_coff_auxesz (abfd);\n       buf = bfd_alloc (abfd, auxesz);\n       if (!buf)\n-\treturn FALSE;\n+\treturn false;\n       for (j = 0; j < native->u.syment.n_numaux; j++)\n \t{\n \t  BFD_ASSERT (! (native + j + 1)->is_sym);\n@@ -1035,7 +1035,7 @@ coff_write_symbol (bfd *abfd,\n \t\t\t\t native->u.syment.n_numaux,\n \t\t\t\t buf);\n \t  if (bfd_bwrite (buf, auxesz, abfd) != auxesz)\n-\t    return FALSE;\n+\t    return false;\n \t}\n       bfd_release (abfd, buf);\n     }\n@@ -1044,14 +1044,14 @@ coff_write_symbol (bfd *abfd,\n   set_index (symbol, *written);\n \n   *written += numaux + 1;\n-  return TRUE;\n+  return true;\n }\n \n /* Write out a symbol to a COFF file that does not come from a COFF\n    file originally.  This symbol may have been created by the linker,\n    or we may be linking a non COFF file to a COFF file.  */\n \n-bfd_boolean\n+bool\n coff_write_alien_symbol (bfd *abfd,\n \t\t\t asymbol *symbol,\n \t\t\t struct internal_syment *isym,\n@@ -1067,7 +1067,7 @@ coff_write_alien_symbol (bfd *abfd,\n \t\t\t       ? symbol->section->output_section\n \t\t\t       : symbol->section;\n   struct bfd_link_info *link_info = coff_data (abfd)->link_info;\n-  bfd_boolean ret;\n+  bool ret;\n \n   if ((!link_info || link_info->strip_discarded)\n       && !bfd_is_abs_section (symbol->section)\n@@ -1076,11 +1076,11 @@ coff_write_alien_symbol (bfd *abfd,\n       symbol->name = \"\";\n       if (isym != NULL)\n \tmemset (isym, 0, sizeof (*isym));\n-      return TRUE;\n+      return true;\n     }\n   native = dummy;\n-  native->is_sym = TRUE;\n-  native[1].is_sym = FALSE;\n+  native->is_sym = true;\n+  native[1].is_sym = false;\n   native->u.syment.n_type = T_NULL;\n   native->u.syment.n_flags = 0;\n   native->u.syment.n_numaux = 0;\n@@ -1108,7 +1108,7 @@ coff_write_alien_symbol (bfd *abfd,\n       symbol->name = \"\";\n       if (isym != NULL)\n \tmemset (isym, 0, sizeof (*isym));\n-      return TRUE;\n+      return true;\n     }\n   else\n     {\n@@ -1148,7 +1148,7 @@ coff_write_alien_symbol (bfd *abfd,\n \n /* Write a native symbol to a COFF file.  */\n \n-static bfd_boolean\n+static bool\n coff_write_native_symbol (bfd *abfd,\n \t\t\t  coff_symbol_type *symbol,\n \t\t\t  bfd_vma *written,\n@@ -1165,7 +1165,7 @@ coff_write_native_symbol (bfd *abfd,\n       && symbol->symbol.section->output_section == bfd_abs_section_ptr)\n     {\n       symbol->symbol.name = \"\";\n-      return TRUE;\n+      return true;\n     }\n \n   BFD_ASSERT (native->is_sym);\n@@ -1194,7 +1194,7 @@ coff_write_native_symbol (bfd *abfd,\n \t     + symbol->symbol.section->output_offset);\n \t  count++;\n \t}\n-      symbol->done_lineno = TRUE;\n+      symbol->done_lineno = true;\n \n       if (! bfd_is_const_section (symbol->symbol.section->output_section))\n \tsymbol->symbol.section->output_section->moving_line_filepos +=\n@@ -1214,7 +1214,7 @@ null_error_handler (const char *fmt ATTRIBUTE_UNUSED,\n \n /* Write out the COFF symbols.  */\n \n-bfd_boolean\n+bool\n coff_write_symbols (bfd *abfd)\n {\n   bfd_size_type string_size;\n@@ -1249,7 +1249,7 @@ coff_write_symbols (bfd *abfd)\n \n   /* Seek to the right place.  */\n   if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n \n   /* Output all the symbols we have.  */\n   written = 0;\n@@ -1264,7 +1264,7 @@ coff_write_symbols (bfd *abfd)\n \t  if (!coff_write_alien_symbol (abfd, symbol, NULL, NULL, &written,\n \t\t\t\t\t&string_size, &debug_string_section,\n \t\t\t\t\t&debug_string_size))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       else\n \t{\n@@ -1309,7 +1309,7 @@ coff_write_symbols (bfd *abfd)\n \t  if (!coff_write_native_symbol (abfd, c_symbol, &written,\n \t\t\t\t\t &string_size, &debug_string_section,\n \t\t\t\t\t &debug_string_size))\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n@@ -1328,7 +1328,7 @@ coff_write_symbols (bfd *abfd)\n #endif\n       if (bfd_bwrite ((void *) buffer, (bfd_size_type) sizeof (buffer), abfd)\n \t  != sizeof (buffer))\n-\treturn FALSE;\n+\treturn false;\n \n       /* Handle long section names.  This code must handle section\n \t names just as they are handled in coff_write_object_contents.  */\n@@ -1345,7 +1345,7 @@ coff_write_symbols (bfd *abfd)\n \t\t{\n \t\t  if (bfd_bwrite (o->name, (bfd_size_type) (len + 1), abfd)\n \t\t      != len + 1)\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t}\n \t    }\n \t}\n@@ -1387,7 +1387,7 @@ coff_write_symbols (bfd *abfd)\n \t      if (bfd_coff_force_symnames_in_strings (abfd))\n \t\t{\n \t\t  if (bfd_bwrite (\".file\", (bfd_size_type) 6, abfd) != 6)\n-\t\t    return FALSE;\n+\t\t    return false;\n \t\t}\n \t      maxlen = bfd_coff_filnmlen (abfd);\n \t    }\n@@ -1398,7 +1398,7 @@ coff_write_symbols (bfd *abfd)\n \t    {\n \t      if (bfd_bwrite ((void *) (q->name), (bfd_size_type) name_length + 1,\n \t\t\t     abfd) != name_length + 1)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t}\n     }\n@@ -1417,7 +1417,7 @@ coff_write_symbols (bfd *abfd)\n #endif\n       if (bfd_bwrite ((void *) buffer, (bfd_size_type) STRING_SIZE_SIZE, abfd)\n \t  != STRING_SIZE_SIZE)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Make sure the .debug section was created to be the correct size.\n@@ -1431,10 +1431,10 @@ coff_write_symbols (bfd *abfd)\n \t\t\t\t 1 << debug_string_section->alignment_power)\n \t\t      == debug_string_section->size)));\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n coff_write_linenumbers (bfd *abfd)\n {\n   asection *s;\n@@ -1444,14 +1444,14 @@ coff_write_linenumbers (bfd *abfd)\n   linesz = bfd_coff_linesz (abfd);\n   buff = bfd_alloc (abfd, linesz);\n   if (!buff)\n-    return FALSE;\n+    return false;\n   for (s = abfd->sections; s != (asection *) NULL; s = s->next)\n     {\n       if (s->lineno_count)\n \t{\n \t  asymbol **q = abfd->outsymbols;\n \t  if (bfd_seek (abfd, s->line_filepos, SEEK_SET) != 0)\n-\t    return FALSE;\n+\t    return false;\n \t  /* Find all the linenumbers in this section.  */\n \t  while (*q)\n \t    {\n@@ -1472,7 +1472,7 @@ coff_write_linenumbers (bfd *abfd)\n \t\t      bfd_coff_swap_lineno_out (abfd, &out, buff);\n \t\t      if (bfd_bwrite (buff, (bfd_size_type) linesz, abfd)\n \t\t\t  != linesz)\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t      l++;\n \t\t      while (l->line_number)\n \t\t\t{\n@@ -1481,7 +1481,7 @@ coff_write_linenumbers (bfd *abfd)\n \t\t\t  bfd_coff_swap_lineno_out (abfd, &out, buff);\n \t\t\t  if (bfd_bwrite (buff, (bfd_size_type) linesz, abfd)\n \t\t\t      != linesz)\n-\t\t\t    return FALSE;\n+\t\t\t    return false;\n \t\t\t  l++;\n \t\t\t}\n \t\t    }\n@@ -1491,7 +1491,7 @@ coff_write_linenumbers (bfd *abfd)\n \t}\n     }\n   bfd_release (abfd, buff);\n-  return TRUE;\n+  return true;\n }\n \n alent *\n@@ -1621,28 +1621,28 @@ copy_name (bfd *abfd, char *name, size_t maxlen)\n \n /* Read in the external symbols.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_get_external_symbols (bfd *abfd)\n {\n   size_t symesz;\n   size_t size;\n   void * syms;\n \n   if (obj_coff_external_syms (abfd) != NULL)\n-    return TRUE;\n+    return true;\n \n   symesz = bfd_coff_symesz (abfd);\n   if (_bfd_mul_overflow (obj_raw_syment_count (abfd), symesz, &size))\n     {\n       bfd_set_error (bfd_error_file_truncated);\n-      return FALSE;\n+      return false;\n     }\n \n   if (size == 0)\n-    return TRUE;\n+    return true;\n \n   if (bfd_seek (abfd, obj_sym_filepos (abfd), SEEK_SET) != 0)\n-    return FALSE;\n+    return false;\n   syms = _bfd_malloc_and_read (abfd, size, size);\n   obj_coff_external_syms (abfd) = syms;\n   return syms != NULL;\n@@ -1732,11 +1732,11 @@ _bfd_coff_read_string_table (bfd *abfd)\n \n /* Free up the external symbols and strings read from a COFF file.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_free_symbols (bfd *abfd)\n {\n   if (! bfd_family_coff (abfd))\n-    return FALSE;\n+    return false;\n \n   if (obj_coff_external_syms (abfd) != NULL\n       && ! obj_coff_keep_syms (abfd))\n@@ -1753,7 +1753,7 @@ _bfd_coff_free_symbols (bfd *abfd)\n       obj_coff_strings_len (abfd) = 0;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Read a symbol table into freshly bfd_allocated memory, swap it, and\n@@ -1811,7 +1811,7 @@ coff_get_normalized_symtab (bfd *abfd)\n       bfd_coff_swap_sym_in (abfd, (void *) raw_src,\n \t\t\t    (void *) & internal_ptr->u.syment);\n       symbol_ptr = internal_ptr;\n-      internal_ptr->is_sym = TRUE;\n+      internal_ptr->is_sym = true;\n \n       /* PR 17512: Prevent buffer overrun.  */\n       if (symbol_ptr->u.syment.n_numaux > ((raw_end - 1) - raw_src) / symesz)\n@@ -1833,7 +1833,7 @@ coff_get_normalized_symtab (bfd *abfd)\n \t\t\t\t(int) i, symbol_ptr->u.syment.n_numaux,\n \t\t\t\t&(internal_ptr->u.auxent));\n \n-\t  internal_ptr->is_sym = FALSE;\n+\t  internal_ptr->is_sym = false;\n \t  coff_pointerize_aux (abfd, internal, symbol_ptr, i,\n \t\t\t       internal_ptr, internal_end);\n \t}\n@@ -1999,7 +1999,7 @@ coff_make_empty_symbol (bfd *abfd)\n   new_symbol->symbol.section = 0;\n   new_symbol->native = NULL;\n   new_symbol->lineno = NULL;\n-  new_symbol->done_lineno = FALSE;\n+  new_symbol->done_lineno = false;\n   new_symbol->symbol.the_bfd = abfd;\n \n   return & new_symbol->symbol;\n@@ -2023,11 +2023,11 @@ coff_bfd_make_debug_symbol (bfd *abfd,\n   new_symbol->native = (combined_entry_type *) bfd_zalloc (abfd, amt);\n   if (!new_symbol->native)\n     return NULL;\n-  new_symbol->native->is_sym = TRUE;\n+  new_symbol->native->is_sym = true;\n   new_symbol->symbol.section = bfd_abs_section_ptr;\n   new_symbol->symbol.flags = BSF_DEBUGGING;\n   new_symbol->lineno = NULL;\n-  new_symbol->done_lineno = FALSE;\n+  new_symbol->done_lineno = false;\n   new_symbol->symbol.the_bfd = abfd;\n \n   return & new_symbol->symbol;\n@@ -2207,7 +2207,7 @@ coff_print_symbol (bfd *abfd,\n    function for the is_local_label_name entry point, but some may\n    override it.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,\n \t\t\t       const char *name)\n {\n@@ -2218,7 +2218,7 @@ _bfd_coff_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,\n    section, calculate and return the name of the source file and the line\n    nearest to the wanted location.  */\n \n-bfd_boolean\n+bool\n coff_find_nearest_line_with_names (bfd *abfd,\n \t\t\t\t   asymbol **symbols,\n \t\t\t\t   asection *section,\n@@ -2228,7 +2228,7 @@ coff_find_nearest_line_with_names (bfd *abfd,\n \t\t\t\t   unsigned int *line_ptr,\n \t\t\t\t   const struct dwarf_debug_section *debug_sections)\n {\n-  bfd_boolean found;\n+  bool found;\n   unsigned int i;\n   unsigned int line_base;\n   coff_data_type *cof = coff_data (abfd);\n@@ -2245,17 +2245,17 @@ coff_find_nearest_line_with_names (bfd *abfd,\n \t\t\t\t\t     &found, filename_ptr,\n \t\t\t\t\t     functionname_ptr, line_ptr,\n \t\t\t\t\t     &coff_data(abfd)->line_info))\n-    return FALSE;\n+    return false;\n \n   if (found)\n-    return TRUE;\n+    return true;\n \n   /* Also try examining DWARF2 debugging information.  */\n   if (_bfd_dwarf2_find_nearest_line (abfd, symbols, NULL, section, offset,\n \t\t\t\t     filename_ptr, functionname_ptr,\n \t\t\t\t     line_ptr, NULL, debug_sections,\n \t\t\t\t     &coff_data(abfd)->dwarf2_find_line_info))\n-    return TRUE;\n+    return true;\n \n   sec_data = coff_section_data (abfd, section);\n \n@@ -2284,7 +2284,7 @@ coff_find_nearest_line_with_names (bfd *abfd,\n \n \t  if (sec_data)\n \t    {\n-\t      sec_data->saved_bias = TRUE;\n+\t      sec_data->saved_bias = true;\n \t      sec_data->bias = bias;\n \t    }\n \t}\n@@ -2295,7 +2295,7 @@ coff_find_nearest_line_with_names (bfd *abfd,\n \t\t\t\t\t    filename_ptr, functionname_ptr,\n \t\t\t\t\t    line_ptr, NULL, debug_sections,\n \t\t\t\t\t    &coff_data(abfd)->dwarf2_find_line_info))\n-\treturn TRUE;\n+\treturn true;\n     }\n \n   *filename_ptr = 0;\n@@ -2304,15 +2304,15 @@ coff_find_nearest_line_with_names (bfd *abfd,\n \n   /* Don't try and find line numbers in a non coff file.  */\n   if (!bfd_family_coff (abfd))\n-    return FALSE;\n+    return false;\n \n   if (cof == NULL)\n-    return FALSE;\n+    return false;\n \n   /* Find the first C_FILE symbol.  */\n   p = cof->raw_syments;\n   if (!p)\n-    return FALSE;\n+    return false;\n \n   pend = p + cof->raw_syment_count;\n   while (p < pend)\n@@ -2389,7 +2389,7 @@ coff_find_nearest_line_with_names (bfd *abfd,\n     {\n       *functionname_ptr = NULL;\n       *line_ptr = 0;\n-      return TRUE;\n+      return true;\n     }\n \n   /* Now wander though the raw linenumbers of the section.\n@@ -2493,10 +2493,10 @@ coff_find_nearest_line_with_names (bfd *abfd,\n       sec_data->line_base = line_base;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n coff_find_nearest_line (bfd *abfd,\n \t\t\tasymbol **symbols,\n \t\t\tasection *section,\n@@ -2513,13 +2513,13 @@ coff_find_nearest_line (bfd *abfd,\n \t\t\t\t\t    line_ptr, dwarf_debug_sections);\n }\n \n-bfd_boolean\n+bool\n coff_find_inliner_info (bfd *abfd,\n \t\t\tconst char **filename_ptr,\n \t\t\tconst char **functionname_ptr,\n \t\t\tunsigned int *line_ptr)\n {\n-  bfd_boolean found;\n+  bool found;\n \n   found = _bfd_dwarf2_find_inliner_info (abfd, filename_ptr,\n \t\t\t\t\t functionname_ptr, line_ptr,\n@@ -2543,7 +2543,7 @@ coff_sizeof_headers (bfd *abfd, struct bfd_link_info *info)\n \n /* Change the class of a coff symbol held by BFD.  */\n \n-bfd_boolean\n+bool\n bfd_coff_set_symbol_class (bfd *\t abfd,\n \t\t\t   asymbol *\t symbol,\n \t\t\t   unsigned int\t symbol_class)\n@@ -2554,7 +2554,7 @@ bfd_coff_set_symbol_class (bfd *\t abfd,\n   if (csym == NULL)\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n   else if (csym->native == NULL)\n     {\n@@ -2568,9 +2568,9 @@ bfd_coff_set_symbol_class (bfd *\t abfd,\n \n       native = (combined_entry_type *) bfd_zalloc (abfd, amt);\n       if (native == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n-      native->is_sym = TRUE;\n+      native->is_sym = true;\n       native->u.syment.n_type   = T_NULL;\n       native->u.syment.n_sclass = symbol_class;\n \n@@ -2603,10 +2603,10 @@ bfd_coff_set_symbol_class (bfd *\t abfd,\n   else\n     csym->native->u.syment.n_sclass = symbol_class;\n \n-  return TRUE;\n+  return true;\n }\n \n-bfd_boolean\n+bool\n _bfd_coff_section_already_linked (bfd *abfd,\n \t\t\t\t  asection *sec,\n \t\t\t\t  struct bfd_link_info *info)\n@@ -2618,15 +2618,15 @@ _bfd_coff_section_already_linked (bfd *abfd,\n   struct coff_comdat_info *s_comdat;\n \n   if (sec->output_section == bfd_abs_section_ptr)\n-    return FALSE;\n+    return false;\n \n   flags = sec->flags;\n   if ((flags & SEC_LINK_ONCE) == 0)\n-    return FALSE;\n+    return false;\n \n   /* The COFF backend linker doesn't support group sections.  */\n   if ((flags & SEC_GROUP) != 0)\n-    return FALSE;\n+    return false;\n \n   name = bfd_section_name (sec);\n   s_comdat = bfd_coff_get_comdat_section (abfd, sec);\n@@ -2674,12 +2674,12 @@ _bfd_coff_section_already_linked (bfd *abfd,\n   /* This is the first section with this name.  Record it.  */\n   if (!bfd_section_already_linked_table_insert (already_linked_list, sec))\n     info->callbacks->einfo (_(\"%F%P: already_linked_table: %E\\n\"));\n-  return FALSE;\n+  return false;\n }\n \n /* Initialize COOKIE for input bfd ABFD. */\n \n-static bfd_boolean\n+static bool\n init_reloc_cookie (struct coff_reloc_cookie *cookie,\n \t\t   struct bfd_link_info *info ATTRIBUTE_UNUSED,\n \t\t   bfd *abfd)\n@@ -2692,7 +2692,7 @@ init_reloc_cookie (struct coff_reloc_cookie *cookie,\n \n   cookie->symbols = obj_symbols (abfd);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Free the memory allocated by init_reloc_cookie, if appropriate.  */\n@@ -2707,7 +2707,7 @@ fini_reloc_cookie (struct coff_reloc_cookie *cookie ATTRIBUTE_UNUSED,\n /* Initialize the relocation information in COOKIE for input section SEC\n    of input bfd ABFD.  */\n \n-static bfd_boolean\n+static bool\n init_reloc_cookie_rels (struct coff_reloc_cookie *cookie,\n \t\t\tstruct bfd_link_info *info ATTRIBUTE_UNUSED,\n \t\t\tbfd *abfd,\n@@ -2718,17 +2718,18 @@ init_reloc_cookie_rels (struct coff_reloc_cookie *cookie,\n       cookie->rels = NULL;\n       cookie->relend = NULL;\n       cookie->rel = NULL;\n-      return TRUE;\n+      return true;\n     }\n \n-  cookie->rels = _bfd_coff_read_internal_relocs (abfd, sec, FALSE, NULL, 0, NULL);\n+  cookie->rels = _bfd_coff_read_internal_relocs (abfd, sec, false, NULL,\n+\t\t\t\t\t\t 0, NULL);\n \n   if (cookie->rels == NULL)\n-    return FALSE;\n+    return false;\n \n   cookie->rel = cookie->rels;\n   cookie->relend = (cookie->rels + sec->reloc_count);\n-  return TRUE;\n+  return true;\n }\n \n /* Free the memory allocated by init_reloc_cookie_rels,\n@@ -2750,20 +2751,20 @@ fini_reloc_cookie_rels (struct coff_reloc_cookie *cookie,\n \n /* Initialize the whole of COOKIE for input section SEC.  */\n \n-static bfd_boolean\n+static bool\n init_reloc_cookie_for_section (struct coff_reloc_cookie *cookie,\n \t\t\t       struct bfd_link_info *info,\n \t\t\t       asection *sec)\n {\n   if (!init_reloc_cookie (cookie, info, sec->owner))\n-    return FALSE;\n+    return false;\n \n   if (!init_reloc_cookie_rels (cookie, info, sec->owner, sec))\n     {\n       fini_reloc_cookie (cookie, sec->owner);\n-      return FALSE;\n+      return false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Free the memory allocated by init_reloc_cookie_for_section,\n@@ -2846,14 +2847,14 @@ _bfd_coff_gc_mark_rsec (struct bfd_link_info *info, asection *sec,\n \t\t\t    + obj_convert (sec->owner)[cookie->rel->r_symndx])->native->u.syment);\n }\n \n-static bfd_boolean _bfd_coff_gc_mark\n+static bool _bfd_coff_gc_mark\n   (struct bfd_link_info *, asection *, coff_gc_mark_hook_fn);\n \n /* COOKIE->rel describes a relocation against section SEC, which is\n    a section we've decided to keep.  Mark the section that contains\n    the relocation symbol.  */\n \n-static bfd_boolean\n+static bool\n _bfd_coff_gc_mark_reloc (struct bfd_link_info *info,\n \t\t\t asection *sec,\n \t\t\t coff_gc_mark_hook_fn gc_mark_hook,\n@@ -2867,21 +2868,21 @@ _bfd_coff_gc_mark_reloc (struct bfd_link_info *info,\n       if (bfd_get_flavour (rsec->owner) != bfd_target_coff_flavour)\n \trsec->gc_mark = 1;\n       else if (!_bfd_coff_gc_mark (info, rsec, gc_mark_hook))\n-\treturn FALSE;\n+\treturn false;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* The mark phase of garbage collection.  For a given section, mark\n    it and any sections in this section's group, and all the sections\n    which define symbols to which it refers.  */\n \n-static bfd_boolean\n+static bool\n _bfd_coff_gc_mark (struct bfd_link_info *info,\n \t\t   asection *sec,\n \t\t   coff_gc_mark_hook_fn gc_mark_hook)\n {\n-  bfd_boolean ret = TRUE;\n+  bool ret = true;\n \n   sec->gc_mark = 1;\n \n@@ -2892,14 +2893,14 @@ _bfd_coff_gc_mark (struct bfd_link_info *info,\n       struct coff_reloc_cookie cookie;\n \n       if (!init_reloc_cookie_for_section (&cookie, info, sec))\n-\tret = FALSE;\n+\tret = false;\n       else\n \t{\n \t  for (; cookie.rel < cookie.relend; cookie.rel++)\n \t    {\n \t      if (!_bfd_coff_gc_mark_reloc (info, sec, gc_mark_hook, &cookie))\n \t\t{\n-\t\t  ret = FALSE;\n+\t\t  ret = false;\n \t\t  break;\n \t\t}\n \t    }\n@@ -2910,7 +2911,7 @@ _bfd_coff_gc_mark (struct bfd_link_info *info,\n   return ret;\n }\n \n-static bfd_boolean\n+static bool\n _bfd_coff_gc_mark_extra_sections (struct bfd_link_info *info,\n \t\t\t\t  coff_gc_mark_hook_fn mark_hook ATTRIBUTE_UNUSED)\n {\n@@ -2919,20 +2920,20 @@ _bfd_coff_gc_mark_extra_sections (struct bfd_link_info *info,\n   for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link.next)\n     {\n       asection *isec;\n-      bfd_boolean some_kept;\n+      bool some_kept;\n \n       if (bfd_get_flavour (ibfd) != bfd_target_coff_flavour)\n \tcontinue;\n \n       /* Ensure all linker created sections are kept, and see whether\n \t any other section is already marked.  */\n-      some_kept = FALSE;\n+      some_kept = false;\n       for (isec = ibfd->sections; isec != NULL; isec = isec->next)\n \t{\n \t  if ((isec->flags & SEC_LINKER_CREATED) != 0)\n \t    isec->gc_mark = 1;\n \t  else if (isec->gc_mark)\n-\t    some_kept = TRUE;\n+\t    some_kept = true;\n \t}\n \n       /* If no section in this file will be kept, then we can\n@@ -2947,12 +2948,12 @@ _bfd_coff_gc_mark_extra_sections (struct bfd_link_info *info,\n \t    || (isec->flags & (SEC_ALLOC | SEC_LOAD | SEC_RELOC)) == 0)\n \t  isec->gc_mark = 1;\n     }\n-  return TRUE;\n+  return true;\n }\n \n /* Sweep symbols in swept sections.  Called via coff_link_hash_traverse.  */\n \n-static bfd_boolean\n+static bool\n coff_gc_sweep_symbol (struct coff_link_hash_entry *h,\n \t\t      void *data ATTRIBUTE_UNUSED)\n {\n@@ -2969,15 +2970,15 @@ coff_gc_sweep_symbol (struct coff_link_hash_entry *h,\n       h->symbol_class = C_HIDDEN;\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* The sweep phase of garbage collection.  Remove all garbage sections.  */\n \n-typedef bfd_boolean (*gc_sweep_hook_fn)\n+typedef bool (*gc_sweep_hook_fn)\n   (bfd *, struct bfd_link_info *, asection *, const struct internal_reloc *);\n \n-static bfd_boolean\n+static bool\n coff_gc_sweep (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n {\n   bfd *sub;\n@@ -3026,21 +3027,21 @@ coff_gc_sweep (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n \t      && !bfd_is_abs_section (o->output_section))\n \t    {\n \t      struct internal_reloc *internal_relocs;\n-\t      bfd_boolean r;\n+\t      bool r;\n \n \t      internal_relocs\n \t\t= _bfd_coff_link_read_relocs (o->owner, o, NULL, NULL,\n \t\t\t\t\t     info->keep_memory);\n \t      if (internal_relocs == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \n \t      r = (*gc_sweep_hook) (o->owner, info, o, internal_relocs);\n \n \t      if (coff_section_data (o)->relocs != internal_relocs)\n \t\tfree (internal_relocs);\n \n \t      if (!r)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n #endif\n \t}\n@@ -3051,7 +3052,7 @@ coff_gc_sweep (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n   coff_link_hash_traverse (coff_hash_table (info), coff_gc_sweep_symbol,\n \t\t\t   NULL);\n \n-  return TRUE;\n+  return true;\n }\n \n /* Keep all sections containing symbols undefined on the command-line,\n@@ -3067,7 +3068,7 @@ _bfd_coff_gc_keep (struct bfd_link_info *info)\n       struct coff_link_hash_entry *h;\n \n       h = coff_link_hash_lookup (coff_hash_table (info), sym->name,\n-\t\t\t\tFALSE, FALSE, FALSE);\n+\t\t\t\tfalse, false, false);\n \n       if (h != NULL\n \t  && (h->root.type == bfd_link_hash_defined\n@@ -3079,7 +3080,7 @@ _bfd_coff_gc_keep (struct bfd_link_info *info)\n \n /* Do mark and sweep of unused sections.  */\n \n-bfd_boolean\n+bool\n bfd_coff_gc_sections (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n {\n   bfd *sub;\n@@ -3092,7 +3093,7 @@ bfd_coff_gc_sections (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n       || !is_coff_hash_table (info->hash))\n     {\n       _bfd_error_handler(_(\"warning: gc-sections option ignored\"));\n-      return TRUE;\n+      return true;\n     }\n #endif\n \n@@ -3115,7 +3116,7 @@ bfd_coff_gc_sections (bfd *abfd ATTRIBUTE_UNUSED, struct bfd_link_info *info)\n \t      && !o->gc_mark)\n \t    {\n \t      if (!_bfd_coff_gc_mark (info, o, _bfd_coff_gc_mark_hook))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \t}\n     }\n@@ -3138,7 +3139,7 @@ bfd_coff_group_name (bfd *abfd, const asection *sec)\n   return NULL;\n }\n \n-bfd_boolean\n+bool\n _bfd_coff_close_and_cleanup (bfd *abfd)\n {\n   struct coff_tdata *tdata = coff_data (abfd);\n@@ -3152,7 +3153,7 @@ _bfd_coff_close_and_cleanup (bfd *abfd)\n       if (bfd_get_format (abfd) == bfd_object\n \t  && bfd_family_coff (abfd)\n \t  && !_bfd_coff_free_symbols (abfd))\n-\treturn FALSE;\n+\treturn false;\n \n       if (bfd_get_format (abfd) == bfd_object\n \t  || bfd_get_format (abfd) == bfd_core)"
    },
    {
      "sha": "c6b65c761d780a91ef257bc28381e9c73403d197",
      "filename": "bfd/cofflink.c",
      "status": "modified",
      "additions": 172,
      "deletions": 172,
      "changes": 344,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cofflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cofflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cofflink.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -29,11 +29,11 @@\n #include \"libcoff.h\"\n #include \"safe-ctype.h\"\n \n-static bfd_boolean coff_link_add_object_symbols (bfd *, struct bfd_link_info *);\n-static bfd_boolean coff_link_check_archive_element\n+static bool coff_link_add_object_symbols (bfd *, struct bfd_link_info *);\n+static bool coff_link_check_archive_element\n   (bfd *, struct bfd_link_info *, struct bfd_link_hash_entry *, const char *,\n-   bfd_boolean *);\n-static bfd_boolean coff_link_add_symbols (bfd *, struct bfd_link_info *);\n+   bool *);\n+static bool coff_link_add_symbols (bfd *, struct bfd_link_info *);\n \n /* Return TRUE if SYM is a weak, external symbol.  */\n #define IS_WEAK_EXTERNAL(abfd, sym)\t\t\t\\\n@@ -91,7 +91,7 @@ _bfd_coff_link_hash_newfunc (struct bfd_hash_entry *entry,\n \n /* Initialize a COFF linker hash table.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_link_hash_table_init (struct coff_link_hash_table *table,\n \t\t\t\tbfd *abfd,\n \t\t\t\tstruct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,\n@@ -159,7 +159,7 @@ _bfd_coff_debug_merge_hash_newfunc (struct bfd_hash_entry *entry,\n /* Given a COFF BFD, add symbols to the global hash table as\n    appropriate.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n {\n   switch (bfd_get_format (abfd))\n@@ -171,76 +171,76 @@ _bfd_coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)\n \t(abfd, info, coff_link_check_archive_element);\n     default:\n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n     }\n }\n \n /* Add symbols from a COFF object file.  */\n \n-static bfd_boolean\n+static bool\n coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)\n {\n   if (! _bfd_coff_get_external_symbols (abfd))\n-    return FALSE;\n+    return false;\n   if (! coff_link_add_symbols (abfd, info))\n-    return FALSE;\n+    return false;\n \n   if (! info->keep_memory\n       && ! _bfd_coff_free_symbols (abfd))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Check a single archive element to see if we need to include it in\n    the link.  *PNEEDED is set according to whether this element is\n    needed in the link or not.  This is called via\n    _bfd_generic_link_add_archive_symbols.  */\n \n-static bfd_boolean\n+static bool\n coff_link_check_archive_element (bfd *abfd,\n \t\t\t\t struct bfd_link_info *info,\n \t\t\t\t struct bfd_link_hash_entry *h,\n \t\t\t\t const char *name,\n-\t\t\t\t bfd_boolean *pneeded)\n+\t\t\t\t bool *pneeded)\n {\n-  *pneeded = FALSE;\n+  *pneeded = false;\n \n   /* PR 22369 - Skip non COFF objects in the archive.  */\n   if (! bfd_family_coff (abfd))\n-    return TRUE;\n+    return true;\n \n   /* We are only interested in symbols that are currently undefined.\n      If a symbol is currently known to be common, COFF linkers do not\n      bring in an object file which defines it.  */\n   if (h->type != bfd_link_hash_undefined)\n-    return TRUE;\n+    return true;\n \n   /* If the archive element has already been loaded then one\n      of the symbols defined by that element might have been\n      made undefined due to being in a discarded section.  */\n   if (((struct coff_link_hash_entry *) h)->indx == -3)\n-    return TRUE;\n+    return true;\n \n   /* Include this element?  */\n   if (!(*info->callbacks->add_archive_element) (info, abfd, name, &abfd))\n-    return TRUE;\n-  *pneeded = TRUE;\n+    return true;\n+  *pneeded = true;\n \n   return bfd_link_add_symbols (abfd, info);\n }\n \n /* Add all the symbols from an object file to the hash table.  */\n \n-static bfd_boolean\n+static bool\n coff_link_add_symbols (bfd *abfd,\n \t\t       struct bfd_link_info *info)\n {\n   unsigned int n_tmask = coff_data (abfd)->local_n_tmask;\n   unsigned int n_btshft = coff_data (abfd)->local_n_btshft;\n   unsigned int n_btmask = coff_data (abfd)->local_n_btmask;\n-  bfd_boolean keep_syms;\n-  bfd_boolean default_copy;\n+  bool keep_syms;\n+  bool default_copy;\n   bfd_size_type symcount;\n   struct coff_link_hash_entry **sym_hash;\n   bfd_size_type symesz;\n@@ -251,17 +251,17 @@ coff_link_add_symbols (bfd *abfd,\n   symcount = obj_raw_syment_count (abfd);\n \n   if (symcount == 0)\n-    return TRUE;\t\t/* Nothing to do.  */\n+    return true;\t\t/* Nothing to do.  */\n \n   /* Keep the symbols during this function, in case the linker needs\n      to read the generic symbols in order to report an error message.  */\n   keep_syms = obj_coff_keep_syms (abfd);\n-  obj_coff_keep_syms (abfd) = TRUE;\n+  obj_coff_keep_syms (abfd) = true;\n \n   if (info->keep_memory)\n-    default_copy = FALSE;\n+    default_copy = false;\n   else\n-    default_copy = TRUE;\n+    default_copy = true;\n \n   /* We keep a list of the linker hash table entries that correspond\n      to particular symbols.  */\n@@ -279,7 +279,7 @@ coff_link_add_symbols (bfd *abfd,\n     {\n       struct internal_syment sym;\n       enum coff_symbol_classification classification;\n-      bfd_boolean copy;\n+      bool copy;\n \n       bfd_coff_swap_sym_in (abfd, esym, &sym);\n \n@@ -291,8 +291,8 @@ coff_link_add_symbols (bfd *abfd,\n \t  flagword flags;\n \t  asection *section;\n \t  bfd_vma value;\n-\t  bfd_boolean addit;\n-\t  bfd_boolean discarded = FALSE;\n+\t  bool addit;\n+\t  bool discarded = false;\n \n \t  /* This symbol is externally visible.  */\n \n@@ -305,7 +305,7 @@ coff_link_add_symbols (bfd *abfd,\n \t  copy = default_copy;\n \t  if (sym._n._n_n._n_zeroes != 0\n \t      || sym._n._n_n._n_offset == 0)\n-\t    copy = TRUE;\n+\t    copy = true;\n \n \t  value = sym.n_value;\n \n@@ -319,7 +319,7 @@ coff_link_add_symbols (bfd *abfd,\n \t      section = coff_section_from_bfd_index (abfd, sym.n_scnum);\n \t      if (discarded_section (section))\n \t\t{\n-\t\t  discarded = TRUE;\n+\t\t  discarded = true;\n \t\t  section = bfd_und_section_ptr;\n \t\t}\n \t      else if (! obj_pe (abfd))\n@@ -347,15 +347,15 @@ coff_link_add_symbols (bfd *abfd,\n \t  if (IS_WEAK_EXTERNAL (abfd, sym))\n \t    flags = BSF_WEAK;\n \n-\t  addit = TRUE;\n+\t  addit = true;\n \n \t  /* In the PE format, section symbols actually refer to the\n \t     start of the output section.  We handle them specially\n \t     here.  */\n \t  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)\n \t    {\n \t      *sym_hash = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t\t name, FALSE, copy, FALSE);\n+\t\t\t\t\t\t name, false, copy, false);\n \t      if (*sym_hash != NULL)\n \t\t{\n \t\t  if (((*sym_hash)->coff_link_hash_flags\n@@ -366,7 +366,7 @@ coff_link_add_symbols (bfd *abfd,\n \t\t      (_(\"warning: symbol `%s' is both section and non-section\"),\n \t\t       name);\n \n-\t\t  addit = FALSE;\n+\t\t  addit = false;\n \t\t}\n \t    }\n \n@@ -402,20 +402,20 @@ coff_link_add_symbols (bfd *abfd,\n \t    {\n \t      if (*sym_hash == NULL)\n \t\t*sym_hash = coff_link_hash_lookup (coff_hash_table (info),\n-\t\t\t\t\t\t   name, FALSE, copy, FALSE);\n+\t\t\t\t\t\t   name, false, copy, false);\n \t      if (*sym_hash != NULL\n \t\t  && (*sym_hash)->root.type == bfd_link_hash_defined\n \t\t  && coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat != NULL\n \t\t  && strcmp (coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat->name,\n \t\t\t     coff_section_data (abfd, section)->comdat->name) == 0)\n-\t\taddit = FALSE;\n+\t\taddit = false;\n \t    }\n \n \t  if (addit)\n \t    {\n \t      if (! (bfd_coff_link_add_one_symbol\n \t\t     (info, abfd, name, flags, section, value,\n-\t\t      (const char *) NULL, copy, FALSE,\n+\t\t      (const char *) NULL, copy, false,\n \t\t      (struct bfd_link_hash_entry **) sym_hash)))\n \t\tgoto error_return;\n \n@@ -576,23 +576,23 @@ coff_link_add_symbols (bfd *abfd,\n \n   obj_coff_keep_syms (abfd) = keep_syms;\n \n-  return TRUE;\n+  return true;\n \n  error_return:\n   obj_coff_keep_syms (abfd) = keep_syms;\n-  return FALSE;\n+  return false;\n }\n \f\n /* Do the final link step.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_final_link (bfd *abfd,\n \t\t      struct bfd_link_info *info)\n {\n   bfd_size_type symesz;\n   struct coff_final_link_info flaginfo;\n-  bfd_boolean debug_merge_allocated;\n-  bfd_boolean long_section_names;\n+  bool debug_merge_allocated;\n+  bool long_section_names;\n   asection *o;\n   struct bfd_link_order *p;\n   bfd_size_type max_sym_count;\n@@ -625,8 +625,8 @@ _bfd_coff_final_link (bfd *abfd,\n   flaginfo.contents = NULL;\n   flaginfo.external_relocs = NULL;\n   flaginfo.internal_relocs = NULL;\n-  flaginfo.global_to_static = FALSE;\n-  debug_merge_allocated = FALSE;\n+  flaginfo.global_to_static = false;\n+  debug_merge_allocated = false;\n \n   coff_data (abfd)->link_info = info;\n \n@@ -636,7 +636,7 @@ _bfd_coff_final_link (bfd *abfd,\n \n   if (! coff_debug_merge_hash_table_init (&flaginfo.debug_merge))\n     goto error_return;\n-  debug_merge_allocated = TRUE;\n+  debug_merge_allocated = true;\n \n   /* Compute the file positions for all the sections.  */\n   if (! abfd->output_has_begun)\n@@ -653,7 +653,7 @@ _bfd_coff_final_link (bfd *abfd,\n   max_lineno_count = 0;\n   max_reloc_count = 0;\n \n-  long_section_names = FALSE;\n+  long_section_names = false;\n   for (o = abfd->sections; o != NULL; o = o->next)\n     {\n       o->reloc_count = 0;\n@@ -670,7 +670,7 @@ _bfd_coff_final_link (bfd *abfd,\n \t\t link.  This will normally be every section.  We need\n \t\t to do this so that we can identify any sections which\n \t\t the linker has decided to not include.  */\n-\t      sec->linker_mark = TRUE;\n+\t      sec->linker_mark = true;\n \n \t      if (info->strip == strip_none\n \t\t  || info->strip == strip_some)\n@@ -714,10 +714,10 @@ _bfd_coff_final_link (bfd *abfd,\n \t     coff_write_object_contents which puts the string index\n \t     into the s_name field of the section header.  That is why\n \t     we pass hash as FALSE.  */\n-\t  if (_bfd_stringtab_add (flaginfo.strtab, o->name, FALSE, FALSE)\n+\t  if (_bfd_stringtab_add (flaginfo.strtab, o->name, false, false)\n \t      == (bfd_size_type) -1)\n \t    goto error_return;\n-\t  long_section_names = TRUE;\n+\t  long_section_names = true;\n \t}\n     }\n \n@@ -804,7 +804,7 @@ _bfd_coff_final_link (bfd *abfd,\n     {\n       size_t sz;\n \n-      sub->output_has_begun = FALSE;\n+      sub->output_has_begun = false;\n       sz = bfd_family_coff (sub) ? obj_raw_syment_count (sub) : 2;\n       if (sz > max_sym_count)\n \tmax_sym_count = sz;\n@@ -865,7 +865,7 @@ _bfd_coff_final_link (bfd *abfd,\n \t\t{\n \t\t  if (! _bfd_coff_link_input_bfd (&flaginfo, sub))\n \t\t    goto error_return;\n-\t\t  sub->output_has_begun = TRUE;\n+\t\t  sub->output_has_begun = true;\n \t\t}\n \t    }\n \t  else if (p->type == bfd_section_reloc_link_order\n@@ -899,7 +899,7 @@ _bfd_coff_final_link (bfd *abfd,\n \t      union internal_auxent iaux;\n \t      bfd_size_type string_size = 0, indx;\n \t      bfd_vma written = 0;\n-\t      bfd_boolean rewrite = FALSE, hash;\n+\t      bool rewrite = false, hash;\n \n \t      if (! (sym->flags & BSF_LOCAL)\n \t\t  || (sym->flags & (BSF_SECTION_SYM | BSF_DEBUGGING_RELOC\n@@ -912,7 +912,7 @@ _bfd_coff_final_link (bfd *abfd,\n \t      /* See if we are discarding symbols with this name.  */\n \t      if ((flaginfo.info->strip == strip_some\n \t\t   && (bfd_hash_lookup (flaginfo.info->keep_hash,\n-\t\t\t\t\tbfd_asymbol_name(sym), FALSE, FALSE)\n+\t\t\t\t\tbfd_asymbol_name(sym), false, false)\n \t\t       == NULL))\n \t\t  || (((flaginfo.info->discard == discard_sec_merge\n \t\t\t&& (bfd_asymbol_section (sym)->flags & SEC_MERGE)\n@@ -935,7 +935,7 @@ _bfd_coff_final_link (bfd *abfd,\n \t\t  && ! isym._n._n_n._n_zeroes && isym.n_numaux)\n \t\t{\n \t\t  indx = _bfd_stringtab_add (flaginfo.strtab, \".file\", hash,\n-\t\t\t\t\t     FALSE);\n+\t\t\t\t\t     false);\n \t\t  if (indx == (bfd_size_type) -1)\n \t\t    goto error_return;\n \t\t  isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;\n@@ -951,14 +951,14 @@ _bfd_coff_final_link (bfd *abfd,\n \t\t{\n \t\t  indx = _bfd_stringtab_add (flaginfo.strtab,\n \t\t\t\t\t     bfd_asymbol_name (sym), hash,\n-\t\t\t\t\t     FALSE);\n+\t\t\t\t\t     false);\n \t\t  if (indx == (bfd_size_type) -1)\n \t\t    goto error_return;\n \t\t  if (isym.n_sclass != C_FILE)\n \t\t    {\n \t\t      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;\n \t\t      bfd_coff_swap_sym_out (abfd, &isym, flaginfo.outsyms);\n-\t\t      rewrite = TRUE;\n+\t\t      rewrite = true;\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -982,7 +982,7 @@ _bfd_coff_final_link (bfd *abfd,\n \t\t\t\t\t     flaginfo.outsyms);\n \t\t      pos = obj_sym_filepos (abfd) + flaginfo.last_file_index\n \t\t\t\t\t\t     * symesz;\n-\t\t      rewrite = TRUE;\n+\t\t      rewrite = true;\n \t\t    }\n \t\t  flaginfo.last_file_index = obj_raw_syment_count (abfd);\n \t\t  flaginfo.last_file = isym;\n@@ -1004,7 +1004,7 @@ _bfd_coff_final_link (bfd *abfd,\n   /* Free up the buffers used by _bfd_coff_link_input_bfd.  */\n \n   coff_debug_merge_hash_table_free (&flaginfo.debug_merge);\n-  debug_merge_allocated = FALSE;\n+  debug_merge_allocated = false;\n \n   free (flaginfo.internal_syms);\n   flaginfo.internal_syms = NULL;\n@@ -1036,23 +1036,23 @@ _bfd_coff_final_link (bfd *abfd,\n       pos = obj_sym_filepos (abfd) + flaginfo.last_file_index * symesz;\n       if (bfd_seek (abfd, pos, SEEK_SET) != 0\n \t  || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* If doing task linking (ld --task-link) then make a pass through the\n      global symbols, writing out any that are defined, and making them\n      static.  */\n   if (info->task_link)\n     {\n-      flaginfo.failed = FALSE;\n+      flaginfo.failed = false;\n       coff_link_hash_traverse (coff_hash_table (info),\n \t\t\t       _bfd_coff_write_task_globals, &flaginfo);\n       if (flaginfo.failed)\n \tgoto error_return;\n     }\n \n   /* Write out the global symbols.  */\n-  flaginfo.failed = FALSE;\n+  flaginfo.failed = false;\n   bfd_hash_traverse (&info->hash->table, _bfd_coff_write_global_sym, &flaginfo);\n   if (flaginfo.failed)\n     goto error_return;\n@@ -1141,7 +1141,7 @@ _bfd_coff_final_link (bfd *abfd,\n   if (coff_hash_table (info)->stab_info.stabstr != NULL)\n     {\n       if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Write out the string table.  */\n@@ -1151,7 +1151,7 @@ _bfd_coff_final_link (bfd *abfd,\n \n       pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;\n       if (bfd_seek (abfd, pos, SEEK_SET) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n #if STRING_SIZE_SIZE == 4\n       H_PUT_32 (abfd,\n@@ -1163,12 +1163,12 @@ _bfd_coff_final_link (bfd *abfd,\n \n       if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)\n \t  != STRING_SIZE_SIZE)\n-\treturn FALSE;\n+\treturn false;\n \n       if (! _bfd_stringtab_emit (abfd, flaginfo.strtab))\n-\treturn FALSE;\n+\treturn false;\n \n-      obj_coff_strings_written (abfd) = TRUE;\n+      obj_coff_strings_written (abfd) = true;\n     }\n \n   _bfd_stringtab_free (flaginfo.strtab);\n@@ -1177,7 +1177,7 @@ _bfd_coff_final_link (bfd *abfd,\n      not try to write out the symbols.  */\n   abfd->symcount = 0;\n \n-  return TRUE;\n+  return true;\n \n  error_return:\n   if (debug_merge_allocated)\n@@ -1204,7 +1204,7 @@ _bfd_coff_final_link (bfd *abfd,\n   free (flaginfo.external_relocs);\n   free (flaginfo.internal_relocs);\n   free (external_relocs);\n-  return FALSE;\n+  return false;\n }\n \n /* Parse out a -heap <reserved>,<commit> line.  */\n@@ -1364,7 +1364,7 @@ mark_relocs (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \n       /* Read in the relocs.  */\n       internal_relocs = _bfd_coff_read_internal_relocs\n-\t(input_bfd, a, FALSE,\n+\t(input_bfd, a, false,\n \t flaginfo->external_relocs,\n \t bfd_link_relocatable (flaginfo->info),\n \t (bfd_link_relocatable (flaginfo->info)\n@@ -1391,18 +1391,18 @@ mark_relocs (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n /* Link an input file into the linker output file.  This function\n    handles all the sections and relocations of the input file at once.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n {\n   unsigned int n_tmask = coff_data (input_bfd)->local_n_tmask;\n   unsigned int n_btshft = coff_data (input_bfd)->local_n_btshft;\n-  bfd_boolean (*adjust_symndx)\n+  bool (*adjust_symndx)\n     (bfd *, struct bfd_link_info *, bfd *, asection *,\n-     struct internal_reloc *, bfd_boolean *);\n+     struct internal_reloc *, bool *);\n   bfd *output_bfd;\n   const char *strings;\n   bfd_size_type syment_base;\n-  bfd_boolean copy, hash;\n+  bool copy, hash;\n   bfd_size_type isymesz;\n   bfd_size_type osymesz;\n   bfd_size_type linesz;\n@@ -1426,15 +1426,15 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n   linesz = bfd_coff_linesz (input_bfd);\n   BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));\n \n-  copy = FALSE;\n+  copy = false;\n   if (! flaginfo->info->keep_memory)\n-    copy = TRUE;\n-  hash = TRUE;\n+    copy = true;\n+  hash = true;\n   if (flaginfo->info->traditional_format)\n-    hash = FALSE;\n+    hash = false;\n \n   if (! _bfd_coff_get_external_symbols (input_bfd))\n-    return FALSE;\n+    return false;\n \n   esym = (bfd_byte *) obj_coff_external_syms (input_bfd);\n   esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;\n@@ -1446,7 +1446,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \n   if (coff_data (output_bfd)->pe\n       && ! process_embedded_commands (output_bfd, flaginfo->info, input_bfd))\n-    return FALSE;\n+    return false;\n \n   /* If we are going to perform relocations and also strip/discard some\n      symbols then we must make sure that we do not strip/discard those\n@@ -1465,9 +1465,9 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n     {\n       struct internal_syment isym;\n       enum coff_symbol_classification classification;\n-      bfd_boolean skip;\n-      bfd_boolean global;\n-      bfd_boolean dont_skip_symbol;\n+      bool skip;\n+      bool global;\n+      bool dont_skip_symbol;\n       int add;\n \n       bfd_coff_swap_sym_in (input_bfd, esym, isymp);\n@@ -1503,17 +1503,17 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t  && bfd_link_relocatable (flaginfo->info))\n \tdont_skip_symbol = *indexp;\n       else\n-\tdont_skip_symbol = FALSE;\n+\tdont_skip_symbol = false;\n \n       *indexp = -1;\n \n-      skip = FALSE;\n-      global = FALSE;\n+      skip = false;\n+      global = false;\n       add = 1 + isym.n_numaux;\n \n       /* If we are stripping all symbols, we want to skip this one.  */\n       if (flaginfo->info->strip == strip_all && ! dont_skip_symbol)\n-\tskip = TRUE;\n+\tskip = true;\n \n       if (! skip)\n \t{\n@@ -1528,22 +1528,22 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t end of the symbol table, so skip them for now.\n \t\t Locally defined function symbols, however, are an\n \t\t exception, and are not moved to the end.  */\n-\t      global = TRUE;\n+\t      global = true;\n \t      if (! ISFCN (isym.n_type))\n-\t\tskip = TRUE;\n+\t\tskip = true;\n \t      break;\n \n \t    case COFF_SYMBOL_UNDEFINED:\n \t      /* Undefined symbols are left for the end.  */\n-\t      global = TRUE;\n-\t      skip = TRUE;\n+\t      global = true;\n+\t      skip = true;\n \t      break;\n \n \t    case COFF_SYMBOL_LOCAL:\n \t      /* This is a local symbol.  Skip it if we are discarding\n \t\t local symbols.  */\n \t      if (flaginfo->info->discard == discard_all && ! dont_skip_symbol)\n-\t\tskip = TRUE;\n+\t\tskip = true;\n \t      break;\n \t    }\n \t}\n@@ -1559,7 +1559,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t  && ((*secpp)->output_section == bfd_abs_section_ptr\n \t      || bfd_section_removed_from_list (output_bfd,\n \t\t\t\t\t\t(*secpp)->output_section)))\n-\tskip = TRUE;\n+\tskip = true;\n #endif\n \n       /* If we stripping debugging symbols, and this is a debugging\n@@ -1580,7 +1580,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t      || isym.n_sclass == C_REGPARM\n \t\t      || isym.n_sclass == C_FIELD\n \t\t      || isym.n_sclass == C_EOS))))\n-\tskip = TRUE;\n+\tskip = true;\n \n       /* If some symbols are stripped based on the name, work out the\n \t name and decide whether to skip this symbol.  */\n@@ -1593,16 +1593,16 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \n \t  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);\n \t  if (name == NULL)\n-\t    return FALSE;\n+\t    return false;\n \n \t  if (! dont_skip_symbol\n \t      && ((flaginfo->info->strip == strip_some\n-\t\t   && (bfd_hash_lookup (flaginfo->info->keep_hash, name, FALSE,\n-\t\t\t\t    FALSE) == NULL))\n+\t\t   && (bfd_hash_lookup (flaginfo->info->keep_hash, name, false,\n+\t\t\t\t    false) == NULL))\n \t\t   || (! global\n \t\t       && flaginfo->info->discard == discard_l\n \t\t       && bfd_is_local_label_name (input_bfd, name))))\n-\t    skip = TRUE;\n+\t    skip = true;\n \t}\n \n       /* If this is an enum, struct, or union tag, see if we have\n@@ -1626,7 +1626,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \n \t  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);\n \t  if (name == NULL)\n-\t    return FALSE;\n+\t    return false;\n \n \t  /* Ignore fake names invented by compiler; treat them all as\n \t     the same name.  */\n@@ -1636,17 +1636,17 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t    name = \"\";\n \n \t  mh = coff_debug_merge_hash_lookup (&flaginfo->debug_merge, name,\n-\t\t\t\t\t     TRUE, TRUE);\n+\t\t\t\t\t     true, true);\n \t  if (mh == NULL)\n-\t    return FALSE;\n+\t    return false;\n \n \t  /* Allocate memory to hold type information.  If this turns\n \t     out to be a duplicate, we pass this address to\n \t     bfd_release.  */\n \t  amt = sizeof (struct coff_debug_merge_type);\n \t  mt = (struct coff_debug_merge_type *) bfd_alloc (input_bfd, amt);\n \t  if (mt == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t  mt->type_class = isym.n_sclass;\n \n \t  /* Pick up the aux entry, which points to the end of the tag\n@@ -1674,17 +1674,17 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t      *epp = (struct coff_debug_merge_element *)\n \t\t  bfd_alloc (input_bfd, amt);\n \t      if (*epp == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \n \t      elename = _bfd_coff_internal_syment_name (input_bfd, islp,\n \t\t\t\t\t\t\telebuf);\n \t      if (elename == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \n \t      amt = strlen (elename) + 1;\n \t      name_copy = (char *) bfd_alloc (input_bfd, amt);\n \t      if (name_copy == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      strcpy (name_copy, elename);\n \n \t      (*epp)->name = name_copy;\n@@ -1767,7 +1767,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t  bfd_release (input_bfd, mt);\n \t\t  *indexp = mtl->indx;\n \t\t  add = (eslend - esym) / isymesz;\n-\t\t  skip = TRUE;\n+\t\t  skip = true;\n \t\t}\n \t    }\n \t}\n@@ -1790,10 +1790,10 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t anyhow.  */\n \t      name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);\n \t      if (name == NULL)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      indx = _bfd_stringtab_add (flaginfo->strtab, name, hash, copy);\n \t      if (indx == (bfd_size_type) -1)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;\n \t    }\n \n@@ -1890,7 +1890,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t      pos += flaginfo->last_file_index * osymesz;\n \t\t      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0\n \t\t\t  || bfd_bwrite (outsym, osymesz, output_bfd) != osymesz)\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t    }\n \t\t}\n \n@@ -1922,7 +1922,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t  /* This can happen if there were errors earlier in\n \t\t     the link.  */\n \t\t  bfd_set_error (bfd_error_bad_value);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t      h->indx = output_index;\n \t    }\n@@ -2018,7 +2018,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t\t{\n \t\t\t  strings = _bfd_coff_read_string_table (input_bfd);\n \t\t\t  if (strings == NULL)\n-\t\t\t    return FALSE;\n+\t\t\t    return false;\n \t\t\t}\n \t\t      if ((bfd_size_type) auxp->x_file.x_n.x_offset >= obj_coff_strings_len (input_bfd))\n \t\t\tfilename = _(\"<corrupt>\");\n@@ -2027,7 +2027,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t      indx = _bfd_stringtab_add (flaginfo->strtab, filename,\n \t\t\t\t\t\t hash, copy);\n \t\t      if (indx == (bfd_size_type) -1)\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t      auxp->x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;\n \t\t    }\n \t\t}\n@@ -2133,7 +2133,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t\t      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0\n \t\t\t\t  || (bfd_bwrite (outsym, osymesz, output_bfd)\n \t\t\t\t      != osymesz))\n-\t\t\t\treturn FALSE;\n+\t\t\t\treturn false;\n \t\t\t    }\n \t\t\t}\n \n@@ -2179,7 +2179,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t  bfd_byte *eline;\n \t  bfd_byte *elineend;\n \t  bfd_byte *oeline;\n-\t  bfd_boolean skipping;\n+\t  bool skipping;\n \t  file_ptr pos;\n \t  bfd_size_type amt;\n \n@@ -2199,13 +2199,13 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t  if (bfd_seek (input_bfd, o->line_filepos, SEEK_SET) != 0\n \t      || bfd_bread (flaginfo->linenos, linesz * o->lineno_count,\n \t\t\t   input_bfd) != linesz * o->lineno_count)\n-\t    return FALSE;\n+\t    return false;\n \n \t  offset = o->output_section->vma + o->output_offset - o->vma;\n \t  eline = flaginfo->linenos;\n \t  oeline = flaginfo->linenos;\n \t  elineend = eline + linesz * o->lineno_count;\n-\t  skipping = FALSE;\n+\t  skipping = false;\n \t  for (; eline < elineend; eline += linesz)\n \t    {\n \t      struct internal_lineno iline;\n@@ -2231,7 +2231,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t\t with symbol #0) will fail.  We can't regain\n \t\t\t the space in the output file, but at least\n \t\t\t they're dense.  */\n-\t\t      skipping = TRUE;\n+\t\t      skipping = true;\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -2270,7 +2270,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t\t\t\t\t is.n_numaux, auxptr);\n \t\t\t}\n \n-\t\t      skipping = FALSE;\n+\t\t      skipping = false;\n \t\t    }\n \n \t\t  iline.l_addr.l_symndx = indx;\n@@ -2288,7 +2288,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t  amt = oeline - flaginfo->linenos;\n \t  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0\n \t      || bfd_bwrite (flaginfo->linenos, amt, output_bfd) != amt)\n-\t    return FALSE;\n+\t    return false;\n \n \t  o->output_section->lineno_count += amt / linesz;\n \t}\n@@ -2318,7 +2318,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n       amt = outsym - flaginfo->outsyms;\n       if (bfd_seek (output_bfd, pos, SEEK_SET) != 0\n \t  || bfd_bwrite (flaginfo->outsyms, amt, output_bfd) != amt)\n-\treturn FALSE;\n+\treturn false;\n \n       BFD_ASSERT ((obj_raw_syment_count (output_bfd)\n \t\t   + (outsym - flaginfo->outsyms) / osymesz)\n@@ -2352,7 +2352,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t(_(\"%pB: relocs in section `%pA', but it has no contents\"),\n \t\t input_bfd, o);\n \t      bfd_set_error (bfd_error_no_contents);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \n \t  continue;\n@@ -2365,7 +2365,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t{\n \t  contents = flaginfo->contents;\n \t  if (! bfd_get_full_section_contents (input_bfd, o, &contents))\n-\t    return FALSE;\n+\t    return false;\n \t}\n \n       if ((o->flags & SEC_RELOC) != 0)\n@@ -2377,15 +2377,15 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t  /* Read in the relocs.  */\n \t  target_index = o->output_section->target_index;\n \t  internal_relocs = (_bfd_coff_read_internal_relocs\n-\t\t\t     (input_bfd, o, FALSE, flaginfo->external_relocs,\n+\t\t\t     (input_bfd, o, false, flaginfo->external_relocs,\n \t\t\t      bfd_link_relocatable (flaginfo->info),\n \t\t\t      (bfd_link_relocatable (flaginfo->info)\n \t\t\t       ? (flaginfo->section_info[target_index].relocs\n \t\t\t\t  + o->output_section->reloc_count)\n \t\t\t       : flaginfo->internal_relocs)));\n \t  if (internal_relocs == NULL\n \t      && o->reloc_count > 0)\n-\t    return FALSE;\n+\t    return false;\n \n \t  /* Run through the relocs looking for relocs against symbols\n \t     coming from discarded sections and complain about them.  */\n@@ -2425,7 +2425,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t\t\t\t   internal_relocs,\n \t\t\t\t\t   flaginfo->internal_syms,\n \t\t\t\t\t   flaginfo->sec_ptrs))\n-\t    return FALSE;\n+\t    return false;\n \n \t  if (bfd_link_relocatable (flaginfo->info))\n \t    {\n@@ -2441,7 +2441,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t      for (; irel < irelend; irel++, rel_hash++)\n \t\t{\n \t\t  struct coff_link_hash_entry *h;\n-\t\t  bfd_boolean adjusted;\n+\t\t  bool adjusted;\n \n \t\t  *rel_hash = NULL;\n \n@@ -2456,7 +2456,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t      if (! (*adjust_symndx) (output_bfd, flaginfo->info,\n \t\t\t\t\t      input_bfd, o, irel,\n \t\t\t\t\t      &adjusted))\n-\t\t\treturn FALSE;\n+\t\t\treturn false;\n \t\t      if (adjusted)\n \t\t\tcontinue;\n \t\t    }\n@@ -2501,7 +2501,7 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t\t  name = (_bfd_coff_internal_syment_name\n \t\t\t\t  (input_bfd, is, buf));\n \t\t\t  if (name == NULL)\n-\t\t\t    return FALSE;\n+\t\t\t    return false;\n \n \t\t\t  (*flaginfo->info->callbacks->unattached_reloc)\n \t\t\t    (flaginfo->info, name, input_bfd, o, irel->r_vaddr);\n@@ -2520,27 +2520,27 @@ _bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)\n \t\t\t  * bfd_octets_per_byte (output_bfd, o));\n \t  if (! bfd_set_section_contents (output_bfd, o->output_section,\n \t\t\t\t\t  contents, loc, o->size))\n-\t    return FALSE;\n+\t    return false;\n \t}\n       else\n \t{\n \t  if (! (_bfd_write_section_stabs\n \t\t (output_bfd, &coff_hash_table (flaginfo->info)->stab_info,\n \t\t  o, &secdata->stab_info, contents)))\n-\t    return FALSE;\n+\t    return false;\n \t}\n     }\n \n   if (! flaginfo->info->keep_memory\n       && ! _bfd_coff_free_symbols (input_bfd))\n-    return FALSE;\n+    return false;\n \n-  return TRUE;\n+  return true;\n }\n \n /* Write out a global symbol.  Called via bfd_hash_traverse.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)\n {\n   struct coff_link_hash_entry *h = (struct coff_link_hash_entry *) bh;\n@@ -2557,31 +2557,31 @@ _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)\n     {\n       h = (struct coff_link_hash_entry *) h->root.u.i.link;\n       if (h->root.type == bfd_link_hash_new)\n-\treturn TRUE;\n+\treturn true;\n     }\n \n   if (h->indx >= 0)\n-    return TRUE;\n+    return true;\n \n   if (h->indx != -2\n       && (flaginfo->info->strip == strip_all\n \t  || (flaginfo->info->strip == strip_some\n \t      && (bfd_hash_lookup (flaginfo->info->keep_hash,\n-\t\t\t\t   h->root.root.string, FALSE, FALSE)\n+\t\t\t\t   h->root.root.string, false, false)\n \t\t  == NULL))))\n-    return TRUE;\n+    return true;\n \n   switch (h->root.type)\n     {\n     default:\n     case bfd_link_hash_new:\n     case bfd_link_hash_warning:\n       abort ();\n-      return FALSE;\n+      return false;\n \n     case bfd_link_hash_undefined:\n       if (h->indx == -3)\n-\treturn TRUE;\n+\treturn true;\n       /* Fall through.  */\n     case bfd_link_hash_undefweak:\n       isym.n_scnum = N_UNDEF;\n@@ -2610,7 +2610,7 @@ _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)\n \t        (_(\"%pB: stripping non-representable symbol '%s' (value \"\n                   \"%\" BFD_VMA_FMT \"x)\"),\n \t         output_bfd, h->root.root.string, isym.n_value);\n-\t    return TRUE;\n+\t    return true;\n \t  }\n #endif\n       }\n@@ -2623,25 +2623,25 @@ _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)\n \n     case bfd_link_hash_indirect:\n       /* Just ignore these.  They can't be handled anyhow.  */\n-      return TRUE;\n+      return true;\n     }\n \n   if (strlen (h->root.root.string) <= SYMNMLEN)\n     strncpy (isym._n._n_name, h->root.root.string, SYMNMLEN);\n   else\n     {\n-      bfd_boolean hash;\n+      bool hash;\n       bfd_size_type indx;\n \n-      hash = TRUE;\n+      hash = true;\n       if (flaginfo->info->traditional_format)\n-\thash = FALSE;\n+\thash = false;\n       indx = _bfd_stringtab_add (flaginfo->strtab, h->root.root.string, hash,\n-\t\t\t\t FALSE);\n+\t\t\t\t false);\n       if (indx == (bfd_size_type) -1)\n \t{\n-\t  flaginfo->failed = TRUE;\n-\t  return FALSE;\n+\t  flaginfo->failed = true;\n+\t  return false;\n \t}\n       isym._n._n_n._n_zeroes = 0;\n       isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;\n@@ -2660,7 +2660,7 @@ _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)\n   if (flaginfo->global_to_static)\n     {\n       if (! IS_EXTERNAL (output_bfd, isym))\n-\treturn TRUE;\n+\treturn true;\n \n       isym.n_sclass = C_STAT;\n     }\n@@ -2684,8 +2684,8 @@ _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)\n   if (bfd_seek (output_bfd, pos, SEEK_SET) != 0\n       || bfd_bwrite (flaginfo->outsyms, symesz, output_bfd) != symesz)\n     {\n-      flaginfo->failed = TRUE;\n-      return FALSE;\n+      flaginfo->failed = true;\n+      return false;\n     }\n \n   h->indx = obj_raw_syment_count (output_bfd);\n@@ -2749,25 +2749,25 @@ _bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)\n \t\t\t     flaginfo->outsyms);\n       if (bfd_bwrite (flaginfo->outsyms, symesz, output_bfd) != symesz)\n \t{\n-\t  flaginfo->failed = TRUE;\n-\t  return FALSE;\n+\t  flaginfo->failed = true;\n+\t  return false;\n \t}\n       ++obj_raw_syment_count (output_bfd);\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Write out task global symbols, converting them to statics.  Called\n    via coff_link_hash_traverse.  Calls bfd_coff_write_global_sym to do\n    the dirty work, if the symbol we are processing needs conversion.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)\n {\n   struct coff_final_link_info *flaginfo = (struct coff_final_link_info *) data;\n-  bfd_boolean rtnval = TRUE;\n-  bfd_boolean save_global_to_static;\n+  bool rtnval = true;\n+  bool save_global_to_static;\n \n   if (h->root.type == bfd_link_hash_warning)\n     h = (struct coff_link_hash_entry *) h->root.u.i.link;\n@@ -2779,7 +2779,7 @@ _bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)\n \tcase bfd_link_hash_defined:\n \tcase bfd_link_hash_defweak:\n \t  save_global_to_static = flaginfo->global_to_static;\n-\t  flaginfo->global_to_static = TRUE;\n+\t  flaginfo->global_to_static = true;\n \t  rtnval = _bfd_coff_write_global_sym (&h->root.root, data);\n \t  flaginfo->global_to_static = save_global_to_static;\n \t  break;\n@@ -2792,7 +2792,7 @@ _bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)\n \n /* Handle a link order which is supposed to generate a reloc.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_reloc_link_order (bfd *output_bfd,\n \t\t\t    struct coff_final_link_info *flaginfo,\n \t\t\t    asection *output_section,\n@@ -2806,21 +2806,21 @@ _bfd_coff_reloc_link_order (bfd *output_bfd,\n   if (howto == NULL)\n     {\n       bfd_set_error (bfd_error_bad_value);\n-      return FALSE;\n+      return false;\n     }\n \n   if (link_order->u.reloc.p->addend != 0)\n     {\n       bfd_size_type size;\n       bfd_byte *buf;\n       bfd_reloc_status_type rstat;\n-      bfd_boolean ok;\n+      bool ok;\n       file_ptr loc;\n \n       size = bfd_get_reloc_size (howto);\n       buf = (bfd_byte *) bfd_zmalloc (size);\n       if (buf == NULL && size != 0)\n-\treturn FALSE;\n+\treturn false;\n \n       rstat = _bfd_relocate_contents (howto, output_bfd,\n \t\t\t\t      (bfd_vma) link_order->u.reloc.p->addend,\n@@ -2848,7 +2848,7 @@ _bfd_coff_reloc_link_order (bfd *output_bfd,\n \t\t\t\t     loc, size);\n       free (buf);\n       if (! ok)\n-\treturn FALSE;\n+\treturn false;\n     }\n \n   /* Store the reloc information in the right place.  It will get\n@@ -2880,7 +2880,7 @@ _bfd_coff_reloc_link_order (bfd *output_bfd,\n       h = ((struct coff_link_hash_entry *)\n \t   bfd_wrapped_link_hash_lookup (output_bfd, flaginfo->info,\n \t\t\t\t\t link_order->u.reloc.p->u.name,\n-\t\t\t\t\t FALSE, FALSE, TRUE));\n+\t\t\t\t\t false, false, true));\n       if (h != NULL)\n \t{\n \t  if (h->indx >= 0)\n@@ -2912,13 +2912,13 @@ _bfd_coff_reloc_link_order (bfd *output_bfd,\n   /* FIXME: What is the right value for r_offset?  Is zero OK?  */\n   ++output_section->reloc_count;\n \n-  return TRUE;\n+  return true;\n }\n \n /* A basic reloc handling routine which may be used by processors with\n    simple relocs.  */\n \n-bfd_boolean\n+bool\n _bfd_coff_generic_relocate_section (bfd *output_bfd,\n \t\t\t\t    struct bfd_link_info *info,\n \t\t\t\t    bfd *input_bfd,\n@@ -2957,7 +2957,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,\n \t  _bfd_error_handler\n \t    /* xgettext: c-format */\n \t    (_(\"%pB: illegal symbol index %ld in relocs\"), input_bfd, symndx);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       else\n \t{\n@@ -2977,7 +2977,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,\n       howto = bfd_coff_rtype_to_howto (input_bfd, input_section, rel, h,\n \t\t\t\t       sym, &addend);\n       if (howto == NULL)\n-\treturn FALSE;\n+\treturn false;\n \n       /* If we are doing a relocatable link, then we can just ignore\n \t a PC relative reloc that is pcrel_offset.  It will already\n@@ -3067,7 +3067,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,\n \t    {\n \t      (*info->callbacks->undefined_symbol)\n \t\t(info, h->root.root.string, input_bfd, input_section,\n-\t\t rel->r_vaddr - input_section->vma, TRUE);\n+\t\t rel->r_vaddr - input_section->vma, true);\n \t      /* Stop the linker from issueing errors about truncated relocs\n \t\t referencing this undefined symbol by giving it an address\n \t\t that should be in range.  */\n@@ -3105,7 +3105,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,\n \t\t  != sizeof (bfd_vma))\n \t\t{\n \t\t  bfd_set_error (bfd_error_system_call);\n-\t\t  return FALSE;\n+\t\t  return false;\n \t\t}\n \t    }\n \t}\n@@ -3126,7 +3126,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,\n \t    /* xgettext: c-format */\n \t    (_(\"%pB: bad reloc address %#\" PRIx64 \" in section `%pA'\"),\n \t     input_bfd, (uint64_t) rel->r_vaddr, input_section);\n-\t  return FALSE;\n+\t  return false;\n \tcase bfd_reloc_overflow:\n \t  {\n \t    const char *name;\n@@ -3140,7 +3140,7 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,\n \t      {\n \t\tname = _bfd_coff_internal_syment_name (input_bfd, sym, buf);\n \t\tif (name == NULL)\n-\t\t  return FALSE;\n+\t\t  return false;\n \t      }\n \n \t    (*info->callbacks->reloc_overflow)\n@@ -3150,5 +3150,5 @@ _bfd_coff_generic_relocate_section (bfd *output_bfd,\n \t  }\n \t}\n     }\n-  return TRUE;\n+  return true;\n }"
    },
    {
      "sha": "6d98aec2d45479314179709d79c0cf302a160ef5",
      "filename": "bfd/compress.c",
      "status": "modified",
      "additions": 41,
      "deletions": 41,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/compress.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/compress.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/compress.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -26,7 +26,7 @@\n \n #define MAX_COMPRESSION_HEADER_SIZE 24\n \n-static bfd_boolean\n+static bool\n decompress_contents (bfd_byte *compressed_buffer,\n \t\t     bfd_size_type compressed_size,\n \t\t     bfd_byte *uncompressed_buffer,\n@@ -79,13 +79,13 @@ bfd_compress_section_contents (bfd *abfd, sec_ptr sec,\n   uLong compressed_size;\n   bfd_byte *buffer;\n   bfd_size_type buffer_size;\n-  bfd_boolean decompress;\n+  bool decompress;\n   int zlib_size = 0;\n   int orig_compression_header_size;\n   bfd_size_type orig_uncompressed_size;\n   unsigned int orig_uncompressed_alignment_pow;\n   int header_size = bfd_get_compression_header_size (abfd, NULL);\n-  bfd_boolean compressed\n+  bool compressed\n     = bfd_is_section_compressed_with_header (abfd, sec,\n \t\t\t\t\t     &orig_compression_header_size,\n \t\t\t\t\t     &orig_uncompressed_size,\n@@ -128,12 +128,12 @@ bfd_compress_section_contents (bfd *abfd, sec_ptr sec,\n   /* Uncompress if it leads to smaller size.  */\n   if (compressed && compressed_size > orig_uncompressed_size)\n     {\n-      decompress = TRUE;\n+      decompress = true;\n       buffer_size = orig_uncompressed_size;\n     }\n   else\n     {\n-      decompress = FALSE;\n+      decompress = false;\n       buffer_size = compressed_size;\n     }\n   buffer = (bfd_byte *) bfd_alloc (abfd, buffer_size);\n@@ -209,7 +209,7 @@ FUNCTION\n \tbfd_get_full_section_contents\n \n SYNOPSIS\n-\tbfd_boolean bfd_get_full_section_contents\n+\tbool bfd_get_full_section_contents\n \t  (bfd *abfd, asection *section, bfd_byte **ptr);\n \n DESCRIPTION\n@@ -222,12 +222,12 @@ DESCRIPTION\n \treturns @code{TRUE} but @var{*ptr} is set to NULL.\n */\n \n-bfd_boolean\n+bool\n bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)\n {\n   bfd_size_type sz;\n   bfd_byte *p = *ptr;\n-  bfd_boolean ret;\n+  bool ret;\n   bfd_size_type save_size;\n   bfd_size_type save_rawsize;\n   bfd_byte *compressed_buffer;\n@@ -240,7 +240,7 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)\n   if (sz == 0)\n     {\n       *ptr = NULL;\n-      return TRUE;\n+      return true;\n     }\n \n   switch (sec->compress_status)\n@@ -269,7 +269,7 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)\n \t\t/* xgettext:c-format */\n \t\t(_(\"error: %pB(%pA) section size (%#\" PRIx64 \" bytes) is larger than file size (%#\" PRIx64 \" bytes)\"),\n \t\t abfd, sec, (uint64_t) sz, (uint64_t) filesize);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t  p = (bfd_byte *) bfd_malloc (sz);\n \t  if (p == NULL)\n@@ -280,24 +280,24 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)\n \t\t  /* xgettext:c-format */\n \t\t  (_(\"error: %pB(%pA) is too large (%#\" PRIx64 \" bytes)\"),\n \t\t  abfd, sec, (uint64_t) sz);\n-\t      return FALSE;\n+\t      return false;\n \t    }\n \t}\n \n       if (!bfd_get_section_contents (abfd, sec, p, 0, sz))\n \t{\n \t  if (*ptr != p)\n \t    free (p);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       *ptr = p;\n-      return TRUE;\n+      return true;\n \n     case DECOMPRESS_SECTION_SIZED:\n       /* Read in the full compressed section contents.  */\n       compressed_buffer = (bfd_byte *) bfd_malloc (sec->compressed_size);\n       if (compressed_buffer == NULL)\n-\treturn FALSE;\n+\treturn false;\n       save_rawsize = sec->rawsize;\n       save_size = sec->size;\n       /* Clear rawsize, set size to compressed size and set compress_status\n@@ -333,27 +333,27 @@ bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)\n \t    free (p);\n \tfail_compressed:\n \t  free (compressed_buffer);\n-\t  return FALSE;\n+\t  return false;\n \t}\n \n       free (compressed_buffer);\n       *ptr = p;\n-      return TRUE;\n+      return true;\n \n     case COMPRESS_SECTION_DONE:\n       if (sec->contents == NULL)\n-\treturn FALSE;\n+\treturn false;\n       if (p == NULL)\n \t{\n \t  p = (bfd_byte *) bfd_malloc (sz);\n \t  if (p == NULL)\n-\t    return FALSE;\n+\t    return false;\n \t  *ptr = p;\n \t}\n       /* PR 17512; file: 5bc29788.  */\n       if (p != sec->contents)\n \tmemcpy (p, sec->contents, sz);\n-      return TRUE;\n+      return true;\n \n     default:\n       abort ();\n@@ -387,7 +387,7 @@ FUNCTION\n \tbfd_is_section_compressed_with_header\n \n SYNOPSIS\n-\tbfd_boolean bfd_is_section_compressed_with_header\n+\tbool bfd_is_section_compressed_with_header\n \t  (bfd *abfd, asection *section,\n \t  int *compression_header_size_p,\n \t  bfd_size_type *uncompressed_size_p,\n@@ -403,7 +403,7 @@ DESCRIPTION\n \tand uncompressed size is returned with 0.\n */\n \n-bfd_boolean\n+bool\n bfd_is_section_compressed_with_header (bfd *abfd, sec_ptr sec,\n \t\t\t\t       int *compression_header_size_p,\n \t\t\t\t       bfd_size_type *uncompressed_size_p,\n@@ -413,7 +413,7 @@ bfd_is_section_compressed_with_header (bfd *abfd, sec_ptr sec,\n   int compression_header_size;\n   int header_size;\n   unsigned int saved = sec->compress_status;\n-  bfd_boolean compressed;\n+  bool compressed;\n \n   *uncompressed_align_pow_p = 0;\n \n@@ -433,10 +433,10 @@ bfd_is_section_compressed_with_header (bfd *abfd, sec_ptr sec,\n \t   section size, 8 bytes in big-endian order.  */\n \tcompressed = startswith ((char*) header , \"ZLIB\");\n       else\n-\tcompressed = TRUE;\n+\tcompressed = true;\n     }\n   else\n-    compressed = FALSE;\n+    compressed = false;\n \n   *uncompressed_size_p = sec->size;\n   if (compressed)\n@@ -454,7 +454,7 @@ bfd_is_section_compressed_with_header (bfd *abfd, sec_ptr sec,\n \t have the first byte of its (big-endian) size be non-zero.  */\n       else if (strcmp (sec->name, \".debug_str\") == 0\n \t       && ISPRINT (header[4]))\n-\tcompressed = FALSE;\n+\tcompressed = false;\n       else\n \t*uncompressed_size_p = bfd_getb64 (header + 4);\n     }\n@@ -470,14 +470,14 @@ FUNCTION\n \tbfd_is_section_compressed\n \n SYNOPSIS\n-\tbfd_boolean bfd_is_section_compressed\n+\tbool bfd_is_section_compressed\n \t  (bfd *abfd, asection *section);\n \n DESCRIPTION\n \tReturn @code{TRUE} if @var{section} is compressed.\n */\n \n-bfd_boolean\n+bool\n bfd_is_section_compressed (bfd *abfd, sec_ptr sec)\n {\n   int compression_header_size;\n@@ -496,7 +496,7 @@ FUNCTION\n \tbfd_init_section_decompress_status\n \n SYNOPSIS\n-\tbfd_boolean bfd_init_section_decompress_status\n+\tbool bfd_init_section_decompress_status\n \t  (bfd *abfd, asection *section);\n \n DESCRIPTION\n@@ -508,7 +508,7 @@ DESCRIPTION\n \tsection.  Otherwise, return @code{TRUE}.\n */\n \n-bfd_boolean\n+bool\n bfd_init_section_decompress_status (bfd *abfd, sec_ptr sec)\n {\n   bfd_byte header[MAX_COMPRESSION_HEADER_SIZE];\n@@ -529,7 +529,7 @@ bfd_init_section_decompress_status (bfd *abfd, sec_ptr sec)\n       || !bfd_get_section_contents (abfd, sec, header, 0, header_size))\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n   if (compression_header_size == 0)\n@@ -539,7 +539,7 @@ bfd_init_section_decompress_status (bfd *abfd, sec_ptr sec)\n       if (! startswith ((char*) header, \"ZLIB\"))\n \t{\n \t  bfd_set_error (bfd_error_wrong_format);\n-\t  return FALSE;\n+\t  return false;\n \t}\n       uncompressed_size = bfd_getb64 (header + 4);\n     }\n@@ -548,23 +548,23 @@ bfd_init_section_decompress_status (bfd *abfd, sec_ptr sec)\n \t\t\t\t\t  &uncompressed_alignment_power))\n     {\n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n     }\n \n   sec->compressed_size = sec->size;\n   sec->size = uncompressed_size;\n   bfd_set_section_alignment (sec, uncompressed_alignment_power);\n   sec->compress_status = DECOMPRESS_SECTION_SIZED;\n \n-  return TRUE;\n+  return true;\n }\n \n /*\n FUNCTION\n \tbfd_init_section_compress_status\n \n SYNOPSIS\n-\tbfd_boolean bfd_init_section_compress_status\n+\tbool bfd_init_section_compress_status\n \t  (bfd *abfd, asection *section);\n \n DESCRIPTION\n@@ -575,7 +575,7 @@ DESCRIPTION\n \tsection.  Otherwise, return @code{TRUE}.\n */\n \n-bfd_boolean\n+bool\n bfd_init_section_compress_status (bfd *abfd, sec_ptr sec)\n {\n   bfd_size_type uncompressed_size;\n@@ -589,19 +589,19 @@ bfd_init_section_compress_status (bfd *abfd, sec_ptr sec)\n       || sec->compress_status != COMPRESS_SECTION_NONE)\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Read in the full section contents and compress it.  */\n   uncompressed_size = sec->size;\n   uncompressed_buffer = (bfd_byte *) bfd_malloc (uncompressed_size);\n   /* PR 21431 */\n   if (uncompressed_buffer == NULL)\n-    return FALSE;\n+    return false;\n \n   if (!bfd_get_section_contents (abfd, sec, uncompressed_buffer,\n \t\t\t\t 0, uncompressed_size))\n-    return FALSE;\n+    return false;\n \n   uncompressed_size = bfd_compress_section_contents (abfd, sec,\n \t\t\t\t\t\t     uncompressed_buffer,\n@@ -614,7 +614,7 @@ FUNCTION\n \tbfd_compress_section\n \n SYNOPSIS\n-\tbfd_boolean bfd_compress_section\n+\tbool bfd_compress_section\n \t  (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer);\n \n DESCRIPTION\n@@ -625,7 +625,7 @@ DESCRIPTION\n \t@code{TRUE}.\n */\n \n-bfd_boolean\n+bool\n bfd_compress_section (bfd *abfd, sec_ptr sec, bfd_byte *uncompressed_buffer)\n {\n   bfd_size_type uncompressed_size = sec->size;\n@@ -639,7 +639,7 @@ bfd_compress_section (bfd *abfd, sec_ptr sec, bfd_byte *uncompressed_buffer)\n       || sec->compress_status != COMPRESS_SECTION_NONE)\n     {\n       bfd_set_error (bfd_error_invalid_operation);\n-      return FALSE;\n+      return false;\n     }\n \n   /* Compress it.  */"
    },
    {
      "sha": "6935940ea8b2b81c3119dc1556b375135f6f5070",
      "filename": "bfd/corefile.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/corefile.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/corefile.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/corefile.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -111,7 +111,7 @@ FUNCTION\n \tcore_file_matches_executable_p\n \n SYNOPSIS\n-\tbfd_boolean core_file_matches_executable_p\n+\tbool core_file_matches_executable_p\n \t  (bfd *core_bfd, bfd *exec_bfd);\n \n DESCRIPTION\n@@ -120,13 +120,13 @@ DESCRIPTION\n \t@var{exec_bfd}, <<FALSE>> otherwise.\n */\n \n-bfd_boolean\n+bool\n core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)\n {\n   if (core_bfd->format != bfd_core || exec_bfd->format != bfd_object)\n     {\n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n     }\n \n   return BFD_SEND (core_bfd, _core_file_matches_executable_p,\n@@ -138,7 +138,7 @@ FUNCTION\n \tgeneric_core_file_matches_executable_p\n \n SYNOPSIS\n-\tbfd_boolean generic_core_file_matches_executable_p\n+\tbool generic_core_file_matches_executable_p\n \t  (bfd *core_bfd, bfd *exec_bfd);\n \n DESCRIPTION\n@@ -154,15 +154,15 @@ DESCRIPTION\n \twhere we really don't know whether they match or not.\n */\n \n-bfd_boolean\n+bool\n generic_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)\n {\n   const char *exec;\n   const char *core;\n   const char *last_slash;\n \n   if (exec_bfd == NULL || core_bfd == NULL)\n-    return TRUE;\n+    return true;\n \n   /* The cast below is to avoid a compiler warning due to the assignment\n      of the const char * returned by bfd_core_file_failing_command to a\n@@ -171,11 +171,11 @@ generic_core_file_matches_executable_p (bfd *core_bfd, bfd *exec_bfd)\n \n   core = bfd_core_file_failing_command (core_bfd);\n   if (core == NULL)\n-    return TRUE;\n+    return true;\n \n   exec = bfd_get_filename (exec_bfd);\n   if (exec == NULL)\n-    return TRUE;\n+    return true;\n \n   last_slash = strrchr (core, '/');\n   if (last_slash != NULL)"
    },
    {
      "sha": "d9d6c1b2f897af3ac660a3c6a86c72994bf1881a",
      "filename": "bfd/cpu-aarch64.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-aarch64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -76,14 +76,14 @@ processors[] =\n   { bfd_mach_aarch64,\t  \"cortex-a77\"\t    }\n };\n \n-static bfd_boolean\n+static bool\n scan (const struct bfd_arch_info *info, const char *string)\n {\n   int i;\n \n   /* First test for an exact match.  */\n   if (strcasecmp (string, info->printable_name) == 0)\n-    return TRUE;\n+    return true;\n \n   /* Next check for a processor name instead of an Architecture name.  */\n   for (i = sizeof (processors) / sizeof (processors[0]); i--;)\n@@ -93,13 +93,13 @@ scan (const struct bfd_arch_info *info, const char *string)\n     }\n \n   if (i != -1 && info->mach == processors[i].mach)\n-    return TRUE;\n+    return true;\n \n   /* Finally check for the default architecture.  */\n   if (strcasecmp (string, \"aarch64\") == 0)\n     return info->the_default;\n \n-  return FALSE;\n+  return false;\n }\n \n #define N(NUMBER, PRINT, WORDSIZE, DEFAULT, NEXT)\t\t\\\n@@ -108,26 +108,26 @@ scan (const struct bfd_arch_info *info, const char *string)\n       bfd_arch_default_fill, NEXT, 0 }\n \n static const bfd_arch_info_type bfd_aarch64_arch_v8_r =\n-  N (bfd_mach_aarch64_8R, \"aarch64:armv8-r\", 64, FALSE, NULL);\n+  N (bfd_mach_aarch64_8R, \"aarch64:armv8-r\", 64, false, NULL);\n \n static const bfd_arch_info_type bfd_aarch64_arch_ilp32 =\n-  N (bfd_mach_aarch64_ilp32, \"aarch64:ilp32\", 32, FALSE,\n+  N (bfd_mach_aarch64_ilp32, \"aarch64:ilp32\", 32, false,\n      &bfd_aarch64_arch_v8_r);\n \n const bfd_arch_info_type bfd_aarch64_arch =\n-  N (0, \"aarch64\", 64, TRUE, &bfd_aarch64_arch_ilp32);\n+  N (0, \"aarch64\", 64, true, &bfd_aarch64_arch_ilp32);\n \n-bfd_boolean\n+bool\n bfd_is_aarch64_special_symbol_name (const char *name, int type)\n {\n   if (!name || name[0] != '$')\n-    return FALSE;\n+    return false;\n   if (name[1] == 'x' || name[1] == 'd')\n     type &= BFD_AARCH64_SPECIAL_SYM_TYPE_MAP;\n   else if (name[1] == 'm' || name[1] == 'f' || name[1] == 'p')\n     type &= BFD_AARCH64_SPECIAL_SYM_TYPE_TAG;\n   else\n-    return FALSE;\n+    return false;\n \n   return (type != 0 && (name[2] == 0 || name[2] == '.'));\n }"
    },
    {
      "sha": "136228c6733ad0d3508361d7819b15b9f6907ac4",
      "filename": "bfd/cpu-aarch64.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-aarch64.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-aarch64.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-aarch64.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -21,5 +21,5 @@\n #define BFD_AARCH64_SPECIAL_SYM_TYPE_TAG\t(1 << 1)\n #define BFD_AARCH64_SPECIAL_SYM_TYPE_OTHER\t(1 << 2)\n #define BFD_AARCH64_SPECIAL_SYM_TYPE_ANY\t(~0)\n-extern bfd_boolean bfd_is_aarch64_special_symbol_name\n+extern bool bfd_is_aarch64_special_symbol_name\n   (const char * name, int type);"
    },
    {
      "sha": "6a87a8ea4782ae9e13f6de016cafe2aade4213c6",
      "filename": "bfd/cpu-alpha.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-alpha.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -45,10 +45,10 @@\n /* These exist only so that we can reasonably disassemble PALcode.  */\n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (64, 64, bfd_mach_alpha_ev4, \"alpha:ev4\", FALSE, NN(1)),\n-  N (64, 64, bfd_mach_alpha_ev5, \"alpha:ev5\", FALSE, NN(2)),\n-  N (64, 64, bfd_mach_alpha_ev6, \"alpha:ev6\", FALSE, 0),\n+  N (64, 64, bfd_mach_alpha_ev4, \"alpha:ev4\", false, NN(1)),\n+  N (64, 64, bfd_mach_alpha_ev5, \"alpha:ev5\", false, NN(2)),\n+  N (64, 64, bfd_mach_alpha_ev6, \"alpha:ev6\", false, 0),\n };\n \n const bfd_arch_info_type bfd_alpha_arch =\n-  N (64, 64, 0, \"alpha\", TRUE, NN(0));\n+  N (64, 64, 0, \"alpha\", true, NN(0));"
    },
    {
      "sha": "051e6c3e7919a950189b4568b145371ef9710646",
      "filename": "bfd/cpu-arc.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-arc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -46,17 +46,17 @@ arc_compatible (const bfd_arch_info_type *a, const bfd_arch_info_type *b);\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  ARC (bfd_mach_arc_arc600, \"A6\"    , FALSE, &arch_info_struct[1]),\n-  ARC (bfd_mach_arc_arc601, \"ARC601\", FALSE, &arch_info_struct[2]),\n-  ARC (bfd_mach_arc_arc700, \"ARC700\", FALSE, &arch_info_struct[3]),\n-  ARC (bfd_mach_arc_arc700, \"A7\",     FALSE, &arch_info_struct[4]),\n-  ARC (bfd_mach_arc_arcv2,  \"ARCv2\",  FALSE, &arch_info_struct[5]),\n-  ARC (bfd_mach_arc_arcv2,  \"EM\",     FALSE, &arch_info_struct[6]),\n-  ARC (bfd_mach_arc_arcv2,  \"HS\",     FALSE, NULL),\n+  ARC (bfd_mach_arc_arc600, \"A6\"    , false, &arch_info_struct[1]),\n+  ARC (bfd_mach_arc_arc601, \"ARC601\", false, &arch_info_struct[2]),\n+  ARC (bfd_mach_arc_arc700, \"ARC700\", false, &arch_info_struct[3]),\n+  ARC (bfd_mach_arc_arc700, \"A7\",     false, &arch_info_struct[4]),\n+  ARC (bfd_mach_arc_arcv2,  \"ARCv2\",  false, &arch_info_struct[5]),\n+  ARC (bfd_mach_arc_arcv2,  \"EM\",     false, &arch_info_struct[6]),\n+  ARC (bfd_mach_arc_arcv2,  \"HS\",     false, NULL),\n };\n \n const bfd_arch_info_type bfd_arc_arch =\n-  ARC (bfd_mach_arc_arc600, \"ARC600\", TRUE, &arch_info_struct[0]);\n+  ARC (bfd_mach_arc_arc600, \"ARC600\", true, &arch_info_struct[0]);\n \n /* ARC-specific \"compatible\" function.  The general rule is that if A and B are\n    compatible, then this function should return architecture that is more"
    },
    {
      "sha": "77b5c7dc9ba963a4066fe90a3f3c5327a0c32d1e",
      "filename": "bfd/cpu-arm.c",
      "status": "modified",
      "additions": 52,
      "deletions": 52,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-arm.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -198,14 +198,14 @@ processors[] =\n   { bfd_mach_arm_unknown, \"arm_any\"\t    }\n };\n \n-static bfd_boolean\n+static bool\n scan (const struct bfd_arch_info *info, const char *string)\n {\n   int  i;\n \n   /* First test for an exact match.  */\n   if (strcasecmp (string, info->printable_name) == 0)\n-    return TRUE;\n+    return true;\n \n   /* Next check for a processor name instead of an Architecture name.  */\n   for (i = sizeof (processors) / sizeof (processors[0]); i--;)\n@@ -215,13 +215,13 @@ scan (const struct bfd_arch_info *info, const char *string)\n     }\n \n   if (i != -1 && info->mach == processors [i].mach)\n-    return TRUE;\n+    return true;\n \n   /* Finally check for the default architecture.  */\n   if (strcasecmp (string, \"arm\") == 0)\n     return info->the_default;\n \n-  return FALSE;\n+  return false;\n }\n \n #define N(number, print, default, next)  \\\n@@ -230,38 +230,38 @@ scan (const struct bfd_arch_info *info, const char *string)\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (bfd_mach_arm_2,         \"armv2\",          FALSE, & arch_info_struct[1]),\n-  N (bfd_mach_arm_2a,        \"armv2a\",         FALSE, & arch_info_struct[2]),\n-  N (bfd_mach_arm_3,         \"armv3\",          FALSE, & arch_info_struct[3]),\n-  N (bfd_mach_arm_3M,        \"armv3m\",         FALSE, & arch_info_struct[4]),\n-  N (bfd_mach_arm_4,         \"armv4\",          FALSE, & arch_info_struct[5]),\n-  N (bfd_mach_arm_4T,        \"armv4t\",         FALSE, & arch_info_struct[6]),\n-  N (bfd_mach_arm_5,         \"armv5\",          FALSE, & arch_info_struct[7]),\n-  N (bfd_mach_arm_5T,        \"armv5t\",         FALSE, & arch_info_struct[8]),\n-  N (bfd_mach_arm_5TE,       \"armv5te\",        FALSE, & arch_info_struct[9]),\n-  N (bfd_mach_arm_XScale,    \"xscale\",         FALSE, & arch_info_struct[10]),\n-  N (bfd_mach_arm_ep9312,    \"ep9312\",         FALSE, & arch_info_struct[11]),\n-  N (bfd_mach_arm_iWMMXt,    \"iwmmxt\",         FALSE, & arch_info_struct[12]),\n-  N (bfd_mach_arm_iWMMXt2,   \"iwmmxt2\",        FALSE, & arch_info_struct[13]),\n-  N (bfd_mach_arm_5TEJ,      \"armv5tej\",       FALSE, & arch_info_struct[14]),\n-  N (bfd_mach_arm_6,         \"armv6\",          FALSE, & arch_info_struct[15]),\n-  N (bfd_mach_arm_6KZ,       \"armv6kz\",        FALSE, & arch_info_struct[16]),\n-  N (bfd_mach_arm_6T2,       \"armv6t2\",        FALSE, & arch_info_struct[17]),\n-  N (bfd_mach_arm_6K,        \"armv6k\",         FALSE, & arch_info_struct[18]),\n-  N (bfd_mach_arm_7,         \"armv7\",          FALSE, & arch_info_struct[19]),\n-  N (bfd_mach_arm_6M,        \"armv6-m\",        FALSE, & arch_info_struct[20]),\n-  N (bfd_mach_arm_6SM,       \"armv6s-m\",       FALSE, & arch_info_struct[21]),\n-  N (bfd_mach_arm_7EM,       \"armv7e-m\",       FALSE, & arch_info_struct[22]),\n-  N (bfd_mach_arm_8,         \"armv8-a\",        FALSE, & arch_info_struct[23]),\n-  N (bfd_mach_arm_8R,        \"armv8-r\",        FALSE, & arch_info_struct[24]),\n-  N (bfd_mach_arm_8M_BASE,   \"armv8-m.base\",   FALSE, & arch_info_struct[25]),\n-  N (bfd_mach_arm_8M_MAIN,   \"armv8-m.main\",   FALSE, & arch_info_struct[26]),\n-  N (bfd_mach_arm_8_1M_MAIN, \"armv8.1-m.main\", FALSE, & arch_info_struct[27]),\n-  N (bfd_mach_arm_unknown,   \"arm_any\",        FALSE, NULL)\n+  N (bfd_mach_arm_2,         \"armv2\",          false, & arch_info_struct[1]),\n+  N (bfd_mach_arm_2a,        \"armv2a\",         false, & arch_info_struct[2]),\n+  N (bfd_mach_arm_3,         \"armv3\",          false, & arch_info_struct[3]),\n+  N (bfd_mach_arm_3M,        \"armv3m\",         false, & arch_info_struct[4]),\n+  N (bfd_mach_arm_4,         \"armv4\",          false, & arch_info_struct[5]),\n+  N (bfd_mach_arm_4T,        \"armv4t\",         false, & arch_info_struct[6]),\n+  N (bfd_mach_arm_5,         \"armv5\",          false, & arch_info_struct[7]),\n+  N (bfd_mach_arm_5T,        \"armv5t\",         false, & arch_info_struct[8]),\n+  N (bfd_mach_arm_5TE,       \"armv5te\",        false, & arch_info_struct[9]),\n+  N (bfd_mach_arm_XScale,    \"xscale\",         false, & arch_info_struct[10]),\n+  N (bfd_mach_arm_ep9312,    \"ep9312\",         false, & arch_info_struct[11]),\n+  N (bfd_mach_arm_iWMMXt,    \"iwmmxt\",         false, & arch_info_struct[12]),\n+  N (bfd_mach_arm_iWMMXt2,   \"iwmmxt2\",        false, & arch_info_struct[13]),\n+  N (bfd_mach_arm_5TEJ,      \"armv5tej\",       false, & arch_info_struct[14]),\n+  N (bfd_mach_arm_6,         \"armv6\",          false, & arch_info_struct[15]),\n+  N (bfd_mach_arm_6KZ,       \"armv6kz\",        false, & arch_info_struct[16]),\n+  N (bfd_mach_arm_6T2,       \"armv6t2\",        false, & arch_info_struct[17]),\n+  N (bfd_mach_arm_6K,        \"armv6k\",         false, & arch_info_struct[18]),\n+  N (bfd_mach_arm_7,         \"armv7\",          false, & arch_info_struct[19]),\n+  N (bfd_mach_arm_6M,        \"armv6-m\",        false, & arch_info_struct[20]),\n+  N (bfd_mach_arm_6SM,       \"armv6s-m\",       false, & arch_info_struct[21]),\n+  N (bfd_mach_arm_7EM,       \"armv7e-m\",       false, & arch_info_struct[22]),\n+  N (bfd_mach_arm_8,         \"armv8-a\",        false, & arch_info_struct[23]),\n+  N (bfd_mach_arm_8R,        \"armv8-r\",        false, & arch_info_struct[24]),\n+  N (bfd_mach_arm_8M_BASE,   \"armv8-m.base\",   false, & arch_info_struct[25]),\n+  N (bfd_mach_arm_8M_MAIN,   \"armv8-m.main\",   false, & arch_info_struct[26]),\n+  N (bfd_mach_arm_8_1M_MAIN, \"armv8.1-m.main\", false, & arch_info_struct[27]),\n+  N (bfd_mach_arm_unknown,   \"arm_any\",        false, NULL)\n };\n \n const bfd_arch_info_type bfd_arm_arch =\n-  N (0, \"arm\", TRUE, & arch_info_struct[0]);\n+  N (0, \"arm\", true, & arch_info_struct[0]);\n \n /* Support functions used by both the COFF and ELF versions of the ARM port.  */\n \n@@ -270,7 +270,7 @@ const bfd_arch_info_type bfd_arm_arch =\n    different possible ARM architecture variants.\n    Returns TRUE if they were merged successfully or FALSE otherwise.  */\n \n-bfd_boolean\n+bool\n bfd_arm_merge_machines (bfd *ibfd, bfd *obfd)\n {\n   unsigned int in  = bfd_get_mach (ibfd);\n@@ -308,7 +308,7 @@ bfd_arm_merge_machines (bfd *ibfd, bfd *obfd)\n \t\t\t    \"whereas %pB is compiled for XScale\"),\n \t\t\t  ibfd, obfd);\n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n     }\n   else if (out == bfd_mach_arm_ep9312\n \t   && (in == bfd_mach_arm_XScale\n@@ -320,14 +320,14 @@ bfd_arm_merge_machines (bfd *ibfd, bfd *obfd)\n \t\t\t    \"whereas %pB is compiled for XScale\"),\n \t\t\t  obfd, ibfd);\n       bfd_set_error (bfd_error_wrong_format);\n-      return FALSE;\n+      return false;\n     }\n   else if (in > out)\n     bfd_set_arch_mach (obfd, bfd_arch_arm, in);\n   /* else\n      Nothing to do.  */\n \n-  return TRUE;\n+  return true;\n }\n \n typedef struct\n@@ -338,7 +338,7 @@ typedef struct\n   char\t\tname[1];\t/* Start of the name+desc data.  */\n } arm_Note;\n \n-static bfd_boolean\n+static bool\n arm_check_note (bfd *abfd,\n \t\tbfd_byte *buffer,\n \t\tbfd_size_type buffer_size,\n@@ -351,7 +351,7 @@ arm_check_note (bfd *abfd,\n   char *\tdescr;\n \n   if (buffer_size < offsetof (arm_Note, name))\n-    return FALSE;\n+    return false;\n \n   /* We have to extract the values this way to allow for a\n      host whose endian-ness is different from the target.  */\n@@ -362,20 +362,20 @@ arm_check_note (bfd *abfd,\n \n   /* Check for buffer overflow.  */\n   if (namesz + descsz + offsetof (arm_Note, name) > buffer_size)\n-    return FALSE;\n+    return false;\n \n   if (expected_name == NULL)\n     {\n       if (namesz != 0)\n-\treturn FALSE;\n+\treturn false;\n     }\n   else\n     {\n       if (namesz != ((strlen (expected_name) + 1 + 3) & ~3))\n-\treturn FALSE;\n+\treturn false;\n \n       if (strcmp (descr, expected_name) != 0)\n-\treturn FALSE;\n+\treturn false;\n \n       descr += (namesz + 3) & ~3;\n     }\n@@ -386,12 +386,12 @@ arm_check_note (bfd *abfd,\n   if (description_return != NULL)\n     * description_return = descr;\n \n-  return TRUE;\n+  return true;\n }\n \n #define NOTE_ARCH_STRING\t\"arch: \"\n \n-bfd_boolean\n+bool\n bfd_arm_update_notes (bfd *abfd, const char *note_section)\n {\n   asection *\t arm_arch_section;\n@@ -406,11 +406,11 @@ bfd_arm_update_notes (bfd *abfd, const char *note_section)\n   arm_arch_section = bfd_get_section_by_name (abfd, note_section);\n \n   if (arm_arch_section == NULL)\n-    return TRUE;\n+    return true;\n \n   buffer_size = arm_arch_section->size;\n   if (buffer_size == 0)\n-    return FALSE;\n+    return false;\n \n   if (!bfd_malloc_and_get_section (abfd, arm_arch_section, &buffer))\n     goto FAIL;\n@@ -459,11 +459,11 @@ bfd_arm_update_notes (bfd *abfd, const char *note_section)\n     }\n \n   free (buffer);\n-  return TRUE;\n+  return true;\n \n  FAIL:\n   free (buffer);\n-  return FALSE;\n+  return false;\n }\n \n \n@@ -535,22 +535,22 @@ bfd_arm_get_mach_from_notes (bfd *abfd, const char *note_section)\n   return bfd_mach_arm_unknown;\n }\n \n-bfd_boolean\n+bool\n bfd_is_arm_special_symbol_name (const char * name, int type)\n {\n   /* The ARM compiler outputs several obsolete forms.  Recognize them\n      in addition to the standard $a, $t and $d.  We are somewhat loose\n      in what we accept here, since the full set is not documented.  */\n   if (!name || name[0] != '$')\n-    return FALSE;\n+    return false;\n   if (name[1] == 'a' || name[1] == 't' || name[1] == 'd')\n     type &= BFD_ARM_SPECIAL_SYM_TYPE_MAP;\n   else if (name[1] == 'm' || name[1] == 'f' || name[1] == 'p')\n     type &= BFD_ARM_SPECIAL_SYM_TYPE_TAG;\n   else if (name[1] >= 'a' && name[1] <= 'z')\n     type &= BFD_ARM_SPECIAL_SYM_TYPE_OTHER;\n   else\n-    return FALSE;\n+    return false;\n \n   return (type != 0 && (name[2] == 0 || name[2] == '.'));\n }"
    },
    {
      "sha": "e8c47141c31f90fe57d4092d3649c3f18ec7944b",
      "filename": "bfd/cpu-arm.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-arm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-arm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-arm.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -19,10 +19,10 @@\n    MA 02110-1301, USA.  */\n \n /* ARM Note section processing.  */\n-extern bfd_boolean bfd_arm_merge_machines\n+extern bool bfd_arm_merge_machines\n   (bfd *, bfd *);\n \n-extern bfd_boolean bfd_arm_update_notes\n+extern bool bfd_arm_update_notes\n   (bfd *, const char *);\n \n extern unsigned int bfd_arm_get_mach_from_notes\n@@ -34,6 +34,6 @@ extern unsigned int bfd_arm_get_mach_from_notes\n #define BFD_ARM_SPECIAL_SYM_TYPE_OTHER\t(1 << 2)\n #define BFD_ARM_SPECIAL_SYM_TYPE_ANY\t(~0)\n \n-extern bfd_boolean bfd_is_arm_special_symbol_name\n+extern bool bfd_is_arm_special_symbol_name\n   (const char *, int);\n "
    },
    {
      "sha": "9ca3d0997dc94c46b90762d2c31f6ff95aa1e1ee",
      "filename": "bfd/cpu-avr.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-avr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-avr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-avr.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -101,64 +101,64 @@ compatible (const bfd_arch_info_type * a,\n static const bfd_arch_info_type arch_info_struct[] =\n {\n   /* Assembler only.  */\n-  N (16, bfd_mach_avr1, \"avr:1\", FALSE, & arch_info_struct[1]),\n+  N (16, bfd_mach_avr1, \"avr:1\", false, & arch_info_struct[1]),\n \n   /* Classic, <= 8K.  */\n-  N (16, bfd_mach_avr2, \"avr:2\", FALSE, & arch_info_struct[2]),\n+  N (16, bfd_mach_avr2, \"avr:2\", false, & arch_info_struct[2]),\n \n   /* Classic + MOVW, <= 8K.  */\n-  N (16, bfd_mach_avr25, \"avr:25\", FALSE, & arch_info_struct[3]),\n+  N (16, bfd_mach_avr25, \"avr:25\", false, & arch_info_struct[3]),\n \n   /* Classic, > 8K, <= 64K.  */\n   /* TODO:  addr_bits should be 16, but set to 22 for some following\n      version of GCC (from 4.3) for backward compatibility.  */\n-  N (22, bfd_mach_avr3, \"avr:3\", FALSE, & arch_info_struct[4]),\n+  N (22, bfd_mach_avr3, \"avr:3\", false, & arch_info_struct[4]),\n \n   /* Classic, == 128K.  */\n-  N (22, bfd_mach_avr31, \"avr:31\", FALSE, & arch_info_struct[5]),\n+  N (22, bfd_mach_avr31, \"avr:31\", false, & arch_info_struct[5]),\n \n   /* Classic + MOVW + JMP/CALL, > 8K, <= 64K. */\n-  N (16, bfd_mach_avr35, \"avr:35\", FALSE, & arch_info_struct[6]),\n+  N (16, bfd_mach_avr35, \"avr:35\", false, & arch_info_struct[6]),\n \n   /* Enhanced, <= 8K.  */\n-  N (16, bfd_mach_avr4, \"avr:4\", FALSE, & arch_info_struct[7]),\n+  N (16, bfd_mach_avr4, \"avr:4\", false, & arch_info_struct[7]),\n \n   /* Enhanced, > 8K, <= 64K.  */\n   /* TODO:  addr_bits should be 16, but set to 22 for some following\n      version of GCC (from 4.3) for backward compatibility.  */\n-  N (22, bfd_mach_avr5, \"avr:5\", FALSE, & arch_info_struct[8]),\n+  N (22, bfd_mach_avr5, \"avr:5\", false, & arch_info_struct[8]),\n \n   /* Enhanced, == 128K.  */\n-  N (22, bfd_mach_avr51, \"avr:51\", FALSE, & arch_info_struct[9]),\n+  N (22, bfd_mach_avr51, \"avr:51\", false, & arch_info_struct[9]),\n \n   /* 3-Byte PC.  */\n-  N (22, bfd_mach_avr6, \"avr:6\", FALSE, & arch_info_struct[10]),\n+  N (22, bfd_mach_avr6, \"avr:6\", false, & arch_info_struct[10]),\n \n   /* Tiny core (AVR Tiny).  */\n-  N (16, bfd_mach_avrtiny, \"avr:100\", FALSE, & arch_info_struct[11]),\n+  N (16, bfd_mach_avrtiny, \"avr:100\", false, & arch_info_struct[11]),\n \n   /* Xmega 1.  */\n-  N (24, bfd_mach_avrxmega1, \"avr:101\", FALSE, & arch_info_struct[12]),\n+  N (24, bfd_mach_avrxmega1, \"avr:101\", false, & arch_info_struct[12]),\n \n   /* Xmega 2.  */\n-  N (24, bfd_mach_avrxmega2, \"avr:102\", FALSE, & arch_info_struct[13]),\n+  N (24, bfd_mach_avrxmega2, \"avr:102\", false, & arch_info_struct[13]),\n \n   /* Xmega 3.  */\n-  N (24, bfd_mach_avrxmega3, \"avr:103\", FALSE, & arch_info_struct[14]),\n+  N (24, bfd_mach_avrxmega3, \"avr:103\", false, & arch_info_struct[14]),\n \n   /* Xmega 4.  */\n-  N (24, bfd_mach_avrxmega4, \"avr:104\", FALSE, & arch_info_struct[15]),\n+  N (24, bfd_mach_avrxmega4, \"avr:104\", false, & arch_info_struct[15]),\n \n   /* Xmega 5.  */\n-  N (24, bfd_mach_avrxmega5, \"avr:105\", FALSE, & arch_info_struct[16]),\n+  N (24, bfd_mach_avrxmega5, \"avr:105\", false, & arch_info_struct[16]),\n \n   /* Xmega 6.  */\n-  N (24, bfd_mach_avrxmega6, \"avr:106\", FALSE, & arch_info_struct[17]),\n+  N (24, bfd_mach_avrxmega6, \"avr:106\", false, & arch_info_struct[17]),\n \n   /* Xmega 7.  */\n-  N (24, bfd_mach_avrxmega7, \"avr:107\", FALSE, NULL)\n+  N (24, bfd_mach_avrxmega7, \"avr:107\", false, NULL)\n \n };\n \n const bfd_arch_info_type bfd_avr_arch =\n-  N (16, bfd_mach_avr2, \"avr\", TRUE, & arch_info_struct[0]);\n+  N (16, bfd_mach_avr2, \"avr\", true, & arch_info_struct[0]);"
    },
    {
      "sha": "bf62d50f4d037f2f601ed7b88c49cab4b97f24d2",
      "filename": "bfd/cpu-bfin.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-bfin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-bfin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-bfin.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_bfin_arch =\n     \"bfin\",\t\t/* Arch name.  */\n     \"bfin\",\t\t/* Arch printable name.  */\n     4,\t\t\t/* Section align power.  */\n-    TRUE,\t\t/* The one and only.  */\n+    true,\t\t/* The one and only.  */\n     bfd_default_compatible,\n     bfd_default_scan,\n     bfd_arch_default_fill,"
    },
    {
      "sha": "0b8dd9919608bb1484cf8486cb19447f6306d039",
      "filename": "bfd/cpu-bpf.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-bpf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-bpf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-bpf.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -34,7 +34,7 @@ static const bfd_arch_info_type bfd_xbpf_arch =\n   \"bpf\",\t\t\t/* Architecture name.  */\n   \"xbpf\",\t\t\t/* Machine name.  */\n   3,\t\t\t\t/* Section align power.  */\n-  FALSE,\t\t\t/* The default ?  */\n+  false,\t\t\t/* The default ?  */\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */\n@@ -53,7 +53,7 @@ const bfd_arch_info_type bfd_bpf_arch =\n   \"bpf\",\t\t\t/* Architecture name.  */\n   \"bpf\",\t\t\t/* Machine name.  */\n   3,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* The default ?  */\n+  true,\t\t\t\t/* The default ?  */\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "41d44093d67c1909673d204ac344d0f696ec00b8",
      "filename": "bfd/cpu-cr16.c",
      "status": "modified",
      "additions": 14,
      "deletions": 14,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-cr16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-cr16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-cr16.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -25,18 +25,18 @@\n \n const bfd_arch_info_type bfd_cr16_arch =\n {\n- 16,\t\t      /* Bits in a word.  */\n- 32,\t\t      /* Bits in an address.  */\n- 8,\t\t      /* Bits in a byte.  */\n- bfd_arch_cr16,       /* Architecture number.  */\n- bfd_mach_cr16,\n- \"cr16\",\t      /* Arch name.  */\n- \"cr16\",\t      /* Printable name.  */\n- 1,\t\t      /* Section alignment power.  */\n- TRUE,\t      \t      /* The one and only.  */\n- bfd_default_compatible,\n- bfd_default_scan,\n- bfd_arch_default_fill,\n- NULL,\n- 0 /* Maximum offset of a reloc from the start of an insn.  */\n+  16,\t\t\t/* Bits in a word.  */\n+  32,\t\t\t/* Bits in an address.  */\n+  8,\t\t\t/* Bits in a byte.  */\n+  bfd_arch_cr16,\t/* Architecture number.  */\n+  bfd_mach_cr16,\n+  \"cr16\",\t\t/* Arch name.  */\n+  \"cr16\",\t\t/* Printable name.  */\n+  1,\t\t\t/* Section alignment power.  */\n+  true,\t\t\t/* The one and only.  */\n+  bfd_default_compatible,\n+  bfd_default_scan,\n+  bfd_arch_default_fill,\n+  NULL,\n+  0 /* Maximum offset of a reloc from the start of an insn.  */\n };"
    },
    {
      "sha": "9e8d8636845171578c8755074bd726d2d1857981",
      "filename": "bfd/cpu-cris.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-cris.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-cris.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-cris.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -66,7 +66,7 @@ get_compatible (const bfd_arch_info_type *a,\n }\n \n #define N(NUMBER, PRINT, NEXT)  \\\n- { 32, 32, 8, bfd_arch_cris, NUMBER, \"cris\", PRINT, 1, FALSE, \\\n+ { 32, 32, 8, bfd_arch_cris, NUMBER, \"cris\", PRINT, 1, false, \\\n      get_compatible, bfd_default_scan, bfd_arch_default_fill, NEXT, 0 }\n \n static const bfd_arch_info_type bfd_cris_arch_compat_v10_v32 =\n@@ -90,7 +90,7 @@ const bfd_arch_info_type bfd_cris_arch =\n   \"cris\",\t\t\t/* The printable name is the same.  */\n   1,\t\t\t\t/* Section alignment power; each section\n \t\t\t\t   is aligned to (only) 2^1 bytes.  */\n-  TRUE,\t\t\t\t/* This is the default \"machine\".  */\n+  true,\t\t\t\t/* This is the default \"machine\".  */\n   get_compatible,\t\t/* A function for testing\n \t\t\t\t   \"machine\" compatibility of two\n \t\t\t\t   bfd_arch_info_type.  */"
    },
    {
      "sha": "c110e4ac40f31c5fbce23864c2ed1ecf523c5ecd",
      "filename": "bfd/cpu-crx.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-crx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-crx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-crx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_crx_arch =\n   \"crx\",\t/* Arch name.  */\n   \"crx\",\t/* Printable name.  */\n   1,\t\t/* Section alignment power.  */\n-  TRUE,\t\t/* The one and only.  */\n+  true,\t\t/* The one and only.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "745edfe08530d0fcee4f7812c8c36ae55a05e1eb",
      "filename": "bfd/cpu-csky.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-csky.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -44,18 +44,18 @@\n static const bfd_arch_info_type arch_info_struct[] =\n {\n   /* ABI v1 processors. */\n-  N (bfd_mach_ck510,   \"csky:ck510\",    FALSE, & arch_info_struct[1]),\n-  N (bfd_mach_ck610,   \"csky:ck610\",    FALSE, & arch_info_struct[2]),\n+  N (bfd_mach_ck510,   \"csky:ck510\",    false, & arch_info_struct[1]),\n+  N (bfd_mach_ck610,   \"csky:ck610\",    false, & arch_info_struct[2]),\n \n   /* ABI v2 processors.  */\n-  N (bfd_mach_ck801,   \"csky:ck801\",    FALSE, & arch_info_struct[3]),\n-  N (bfd_mach_ck802,   \"csky:ck802\",    FALSE, & arch_info_struct[4]),\n-  N (bfd_mach_ck803,   \"csky:ck803\",    FALSE, & arch_info_struct[5]),\n-  N (bfd_mach_ck807,   \"csky:ck807\",    FALSE, & arch_info_struct[6]),\n-  N (bfd_mach_ck810,   \"csky:ck810\",    FALSE, & arch_info_struct[7]),\n-  N (bfd_mach_ck860,   \"csky:ck860\",    FALSE, & arch_info_struct[8]),\n-  N (bfd_mach_ck_unknown, \"csky:any\",   FALSE, NULL)\n+  N (bfd_mach_ck801,   \"csky:ck801\",    false, & arch_info_struct[3]),\n+  N (bfd_mach_ck802,   \"csky:ck802\",    false, & arch_info_struct[4]),\n+  N (bfd_mach_ck803,   \"csky:ck803\",    false, & arch_info_struct[5]),\n+  N (bfd_mach_ck807,   \"csky:ck807\",    false, & arch_info_struct[6]),\n+  N (bfd_mach_ck810,   \"csky:ck810\",    false, & arch_info_struct[7]),\n+  N (bfd_mach_ck860,   \"csky:ck860\",    false, & arch_info_struct[8]),\n+  N (bfd_mach_ck_unknown, \"csky:any\",   false, NULL)\n };\n \n const bfd_arch_info_type bfd_csky_arch =\n-  N (0, \"csky\", TRUE, & arch_info_struct[0]);\n+  N (0, \"csky\", true, & arch_info_struct[0]);"
    },
    {
      "sha": "112bab9f94cd392fcd9f5341e77279dba41391a4",
      "filename": "bfd/cpu-d10v.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-d10v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-d10v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-d10v.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -42,10 +42,10 @@\n   }\n \n static const bfd_arch_info_type d10v_ts3_info =\n-  N (bfd_mach_d10v_ts3, \"d10v:ts3\", FALSE, NULL);\n+  N (bfd_mach_d10v_ts3, \"d10v:ts3\", false, NULL);\n \n static const bfd_arch_info_type d10v_ts2_info =\n-  N (bfd_mach_d10v_ts2, \"d10v:ts2\", FALSE, & d10v_ts3_info);\n+  N (bfd_mach_d10v_ts2, \"d10v:ts2\", false, & d10v_ts3_info);\n \n const bfd_arch_info_type bfd_d10v_arch =\n-  N (bfd_mach_d10v, \"d10v\", TRUE, & d10v_ts2_info);\n+  N (bfd_mach_d10v, \"d10v\", true, & d10v_ts2_info);"
    },
    {
      "sha": "0c801f649d9be777e457abe4ab2093020c8bcfd5",
      "filename": "bfd/cpu-d30v.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-d30v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-d30v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-d30v.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_d30v_arch =\n   \"d30v\",\n   \"d30v\",\n   4, /* Section alignment power.  */\n-  TRUE,\n+  true,\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "4cc1562e25d68092c12c71c7bd2a74b76a1345d6",
      "filename": "bfd/cpu-dlx.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-dlx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-dlx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-dlx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_dlx_arch =\n   \"dlx\",\n   \"dlx\",\n   4,\n-  TRUE, /* The one and only.  */\n+  true, /* The one and only.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "39f878b085bdbfd2d9cc8f19bfb88233597adfc5",
      "filename": "bfd/cpu-epiphany.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-epiphany.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-epiphany.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-epiphany.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -42,8 +42,7 @@\n   }\n \n const bfd_arch_info_type bfd_epiphany16_arch =\n-  N (bfd_mach_epiphany16, \"epiphany16\", 1, FALSE, NULL);\n+  N (bfd_mach_epiphany16, \"epiphany16\", 1, false, NULL);\n \n const bfd_arch_info_type bfd_epiphany_arch =\n-  N (bfd_mach_epiphany32, \"epiphany32\", 2, TRUE, & bfd_epiphany16_arch);\n-\n+  N (bfd_mach_epiphany32, \"epiphany32\", 2, true, &bfd_epiphany16_arch);"
    },
    {
      "sha": "f0c57a86dbfb68d78d196f7bd2bd0eeb7edf1bb8",
      "filename": "bfd/cpu-fr30.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-fr30.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-fr30.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-fr30.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_fr30_arch =\n   \"fr30\",\t\t\t/* Architecture name.  */\n   \"fr30\",\t\t\t/* Printable name.  */\n   4,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* The default ?  */\n+  true,\t\t\t\t/* The default ?  */\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "7d98fcc6ecb279cbc04fd6cbfe724de3afe217d8",
      "filename": "bfd/cpu-frv.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-frv.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,26 +41,26 @@\n }\n \n static const bfd_arch_info_type arch_info_300\n-  = FRV_ARCH (bfd_mach_fr300,   \"fr300\",   FALSE, (bfd_arch_info_type *)0);\n+  = FRV_ARCH (bfd_mach_fr300,   \"fr300\",   false, (bfd_arch_info_type *)0);\n \n static const bfd_arch_info_type arch_info_400\n-  = FRV_ARCH (bfd_mach_fr400, \"fr400\", FALSE, &arch_info_300);\n+  = FRV_ARCH (bfd_mach_fr400, \"fr400\", false, &arch_info_300);\n \n static const bfd_arch_info_type arch_info_450\n-  = FRV_ARCH (bfd_mach_fr450, \"fr450\", FALSE, &arch_info_400);\n+  = FRV_ARCH (bfd_mach_fr450, \"fr450\", false, &arch_info_400);\n \n static const bfd_arch_info_type arch_info_500\n-  = FRV_ARCH (bfd_mach_fr500, \"fr500\", FALSE, &arch_info_450);\n+  = FRV_ARCH (bfd_mach_fr500, \"fr500\", false, &arch_info_450);\n \n static const bfd_arch_info_type arch_info_550\n-  = FRV_ARCH (bfd_mach_fr550, \"fr550\", FALSE, &arch_info_500);\n+  = FRV_ARCH (bfd_mach_fr550, \"fr550\", false, &arch_info_500);\n \n static const bfd_arch_info_type arch_info_simple\n-  = FRV_ARCH (bfd_mach_frvsimple, \"simple\", FALSE, &arch_info_550);\n+  = FRV_ARCH (bfd_mach_frvsimple, \"simple\", false, &arch_info_550);\n \n static const bfd_arch_info_type arch_info_tomcat\n-  = FRV_ARCH (bfd_mach_frvtomcat, \"tomcat\", FALSE, &arch_info_simple);\n+  = FRV_ARCH (bfd_mach_frvtomcat, \"tomcat\", false, &arch_info_simple);\n \n const bfd_arch_info_type bfd_frv_arch\n-  = FRV_ARCH (bfd_mach_frv, \"frv\", TRUE, &arch_info_tomcat);\n+  = FRV_ARCH (bfd_mach_frv, \"frv\", true, &arch_info_tomcat);\n "
    },
    {
      "sha": "f7112685e0f5fcdbb345c97f7dcff5b9c819a49c",
      "filename": "bfd/cpu-ft32.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-ft32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-ft32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-ft32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -43,10 +43,10 @@\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (bfd_mach_ft32, \"ft32\", FALSE, &arch_info_struct[1]),\n-  N (bfd_mach_ft32b, \"ft32b\", FALSE, NULL)\n+  N (bfd_mach_ft32, \"ft32\", false, &arch_info_struct[1]),\n+  N (bfd_mach_ft32b, \"ft32b\", false, NULL)\n };\n \n const bfd_arch_info_type bfd_ft32_arch =\n-  N (bfd_mach_ft32, \"ft32\", TRUE, arch_info_struct);\n+  N (bfd_mach_ft32, \"ft32\", true, arch_info_struct);\n "
    },
    {
      "sha": "61cc9882ab450f864a8daf3ecebb657be36c7cbb",
      "filename": "bfd/cpu-h8300.c",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-h8300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-h8300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-h8300.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -24,28 +24,28 @@\n #include \"libbfd.h\"\n #include \"cpu-h8300.h\"\n \n-static bfd_boolean\n+static bool\n h8300_scan (const struct bfd_arch_info *info, const char *string)\n {\n   if (*string != 'h' && *string != 'H')\n-    return FALSE;\n+    return false;\n \n   string++;\n   if (*string != '8')\n-    return FALSE;\n+    return false;\n \n   string++;\n   if (*string == '/')\n     string++;\n \n   if (*string != '3')\n-    return FALSE;\n+    return false;\n   string++;\n   if (*string != '0')\n-    return FALSE;\n+    return false;\n   string++;\n   if (*string != '0')\n-    return FALSE;\n+    return false;\n   string++;\n   if (*string == '-')\n     string++;\n@@ -119,25 +119,25 @@ compatible (const bfd_arch_info_type *in, const bfd_arch_info_type *out)\n     compatible, h8300_scan, bfd_arch_default_fill, next, 0 }\n \n static const bfd_arch_info_type h8300sxn_info_struct =\n-  N (32, 16, bfd_mach_h8300sxn, \"h8300sxn\", \"h8300sxn\", FALSE, NULL);\n+  N (32, 16, bfd_mach_h8300sxn, \"h8300sxn\", \"h8300sxn\", false, NULL);\n \n static const bfd_arch_info_type h8300sx_info_struct =\n-  N (32, 32, bfd_mach_h8300sx, \"h8300sx\", \"h8300sx\", FALSE, &h8300sxn_info_struct);\n+  N (32, 32, bfd_mach_h8300sx, \"h8300sx\", \"h8300sx\", false, &h8300sxn_info_struct);\n \n static const bfd_arch_info_type h8300sn_info_struct =\n-  N (32, 16, bfd_mach_h8300sn, \"h8300sn\", \"h8300sn\", FALSE, &h8300sx_info_struct);\n+  N (32, 16, bfd_mach_h8300sn, \"h8300sn\", \"h8300sn\", false, &h8300sx_info_struct);\n \n static const bfd_arch_info_type h8300hn_info_struct =\n-  N (32, 16, bfd_mach_h8300hn, \"h8300hn\", \"h8300hn\", FALSE, &h8300sn_info_struct);\n+  N (32, 16, bfd_mach_h8300hn, \"h8300hn\", \"h8300hn\", false, &h8300sn_info_struct);\n \n static const bfd_arch_info_type h8300s_info_struct =\n-  N (32, 32, bfd_mach_h8300s, \"h8300s\", \"h8300s\", FALSE, & h8300hn_info_struct);\n+  N (32, 32, bfd_mach_h8300s, \"h8300s\", \"h8300s\", false, & h8300hn_info_struct);\n \n static const bfd_arch_info_type h8300h_info_struct =\n-  N (32, 32, bfd_mach_h8300h, \"h8300h\", \"h8300h\", FALSE, &h8300s_info_struct);\n+  N (32, 32, bfd_mach_h8300h, \"h8300h\", \"h8300h\", false, &h8300s_info_struct);\n \n const bfd_arch_info_type bfd_h8300_arch =\n-  N (16, 16, bfd_mach_h8300, \"h8300\", \"h8300\", TRUE, &h8300h_info_struct);\n+  N (16, 16, bfd_mach_h8300, \"h8300\", \"h8300\", true, &h8300h_info_struct);\n \n /* Pad the given address to 32 bits, converting 16-bit and 24-bit\n    addresses into the values they would have had on a h8s target.  */"
    },
    {
      "sha": "8e29c1100403709814c7065925be97431e67e18d",
      "filename": "bfd/cpu-hppa.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-hppa.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -42,15 +42,15 @@\n \n \n static const bfd_arch_info_type bfd_hppa10_arch =\n-  N (32, bfd_mach_hppa10, \"hppa1.0\", TRUE, NULL);\n+  N (32, bfd_mach_hppa10, \"hppa1.0\", true, NULL);\n \n /* PA2.0 in narrow mode.  */\n static const bfd_arch_info_type bfd_hppa20_arch =\n-  N (32, bfd_mach_hppa20, \"hppa2.0\", FALSE, &bfd_hppa10_arch);\n+  N (32, bfd_mach_hppa20, \"hppa2.0\", false, &bfd_hppa10_arch);\n \n /* PA2.0 in wide mode.  */\n static const bfd_arch_info_type bfd_hppa20w_arch =\n-  N (64, bfd_mach_hppa20w, \"hppa2.0w\", FALSE, &bfd_hppa20_arch);\n+  N (64, bfd_mach_hppa20w, \"hppa2.0w\", false, &bfd_hppa20_arch);\n \n const bfd_arch_info_type bfd_hppa_arch =\n-  N (32, bfd_mach_hppa11, \"hppa1.1\", FALSE, &bfd_hppa20w_arch);\n+  N (32, bfd_mach_hppa11, \"hppa1.1\", false, &bfd_hppa20w_arch);"
    },
    {
      "sha": "dc53f9af4587ef467681641b01e24844646d53eb",
      "filename": "bfd/cpu-i386.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-i386.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -23,8 +23,8 @@\n #include \"libbfd.h\"\n #include \"libiberty.h\"\n \n-extern void * bfd_arch_i386_short_nop_fill (bfd_size_type, bfd_boolean,\n-\t\t\t\t\t    bfd_boolean);\n+extern void * bfd_arch_i386_short_nop_fill (bfd_size_type, bool,\n+\t\t\t\t\t    bool);\n \n static const bfd_arch_info_type *\n bfd_i386_compatible (const bfd_arch_info_type *a,\n@@ -44,8 +44,8 @@ bfd_i386_compatible (const bfd_arch_info_type *a,\n    multi byte nop instructions if LONG_NOP is TRUE.  */\n \n static void *\n-bfd_arch_i386_fill (bfd_size_type count, bfd_boolean code,\n-\t\t    bfd_boolean long_nop)\n+bfd_arch_i386_fill (bfd_size_type count, bool code,\n+\t\t    bool long_nop)\n {\n   /* nop */\n   static const char nop_1[] = { 0x90 };\n@@ -97,24 +97,24 @@ bfd_arch_i386_fill (bfd_size_type count, bfd_boolean code,\n   return fill;\n }\n \n-/* Fill the buffer with zero or short nop instruction if CODE is TRUE.  */\n+/* Fill the buffer with zero or short nop instruction if CODE is true.  */\n \n void *\n bfd_arch_i386_short_nop_fill (bfd_size_type count,\n-\t\t\t      bfd_boolean is_bigendian ATTRIBUTE_UNUSED,\n-\t\t\t      bfd_boolean code)\n+\t\t\t      bool is_bigendian ATTRIBUTE_UNUSED,\n+\t\t\t      bool code)\n {\n-  return bfd_arch_i386_fill (count, code, FALSE);\n+  return bfd_arch_i386_fill (count, code, false);\n }\n \n /* Fill the buffer with zero or long nop instruction if CODE is TRUE.  */\n \n static void *\n bfd_arch_i386_long_nop_fill (bfd_size_type count,\n-\t\t\t     bfd_boolean is_bigendian ATTRIBUTE_UNUSED,\n-\t\t\t     bfd_boolean code)\n+\t\t\t     bool is_bigendian ATTRIBUTE_UNUSED,\n+\t\t\t     bool code)\n {\n-  return bfd_arch_i386_fill (count, code, TRUE);\n+  return bfd_arch_i386_fill (count, code, true);\n }\n \n #define N(BITS, MACH, NAME, PRINT, DEF, FILL, NEXT)\t\\\n@@ -137,29 +137,29 @@ bfd_arch_i386_long_nop_fill (bfd_size_type count,\n \n static const bfd_arch_info_type bfd_x64_32_arch_intel_syntax =\n   N (64, bfd_mach_x64_32_intel_syntax, \"i386:intel\", \"i386:x64-32:intel\",\n-     FALSE, bfd_arch_i386_long_nop_fill, NULL);\n+     false, bfd_arch_i386_long_nop_fill, NULL);\n \n static const bfd_arch_info_type bfd_x86_64_arch_intel_syntax =\n   N (64, bfd_mach_x86_64_intel_syntax, \"i386:intel\", \"i386:x86-64:intel\",\n-     FALSE, bfd_arch_i386_long_nop_fill, &bfd_x64_32_arch_intel_syntax);\n+     false, bfd_arch_i386_long_nop_fill, &bfd_x64_32_arch_intel_syntax);\n \n static const bfd_arch_info_type bfd_i386_arch_intel_syntax =\n   N (32, bfd_mach_i386_i386_intel_syntax, \"i386:intel\", \"i386:intel\",\n-     TRUE, bfd_arch_i386_short_nop_fill, &bfd_x86_64_arch_intel_syntax);\n+     true, bfd_arch_i386_short_nop_fill, &bfd_x86_64_arch_intel_syntax);\n \n \n static const bfd_arch_info_type i8086_arch =\n   N (32, bfd_mach_i386_i8086, \"i8086\", \"i8086\",\n-     FALSE, bfd_arch_i386_short_nop_fill, &bfd_i386_arch_intel_syntax);\n+     false, bfd_arch_i386_short_nop_fill, &bfd_i386_arch_intel_syntax);\n \n static const bfd_arch_info_type bfd_x64_32_arch =\n   N (64, bfd_mach_x64_32, \"i386\", \"i386:x64-32\",\n-     FALSE, bfd_arch_i386_long_nop_fill, &i8086_arch);\n+     false, bfd_arch_i386_long_nop_fill, &i8086_arch);\n \n static const bfd_arch_info_type bfd_x86_64_arch =\n   N (64, bfd_mach_x86_64, \"i386\", \"i386:x86-64\",\n-     FALSE, bfd_arch_i386_long_nop_fill, &bfd_x64_32_arch);\n+     false, bfd_arch_i386_long_nop_fill, &bfd_x64_32_arch);\n \n const bfd_arch_info_type bfd_i386_arch =\n   N (32, bfd_mach_i386_i386, \"i386\", \"i386\",\n-     TRUE, bfd_arch_i386_short_nop_fill, &bfd_x86_64_arch);\n+     true, bfd_arch_i386_short_nop_fill, &bfd_x86_64_arch);"
    },
    {
      "sha": "e4e68183a6f50ee6e9efa538fad94b326a431ea5",
      "filename": "bfd/cpu-ia64.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-ia64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -42,9 +42,9 @@\n   }\n \n const bfd_arch_info_type bfd_ia64_elf32_arch =\n-  N (32, bfd_mach_ia64_elf32, \"ia64-elf32\", FALSE, NULL);\n+  N (32, bfd_mach_ia64_elf32, \"ia64-elf32\", false, NULL);\n \n const bfd_arch_info_type bfd_ia64_arch =\n-  N (64, bfd_mach_ia64_elf64, \"ia64-elf64\", TRUE, &bfd_ia64_elf32_arch);\n+  N (64, bfd_mach_ia64_elf64, \"ia64-elf64\", true, &bfd_ia64_elf32_arch);\n \n #include \"cpu-ia64-opc.c\""
    },
    {
      "sha": "633bd3a571d77b930db2563a6f32e67c3068de20",
      "filename": "bfd/cpu-iamcu.c",
      "status": "modified",
      "additions": 2,
      "deletions": 3,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-iamcu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-iamcu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-iamcu.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -22,11 +22,10 @@\n #include \"bfd.h\"\n #include \"libbfd.h\"\n \n-extern void * bfd_arch_i386_short_nop_fill (bfd_size_type, bfd_boolean,\n-\t\t\t\t\t    bfd_boolean);\n+extern void *bfd_arch_i386_short_nop_fill (bfd_size_type, bool, bool);\n \n #define N(number, name, print, next)\t\t\t     \\\n-  { 32, 32, 8, bfd_arch_iamcu, number, name, print, 3, TRUE, \\\n+  { 32, 32, 8, bfd_arch_iamcu, number, name, print, 3, true, \\\n     bfd_default_compatible, bfd_default_scan,\t\t     \\\n     bfd_arch_i386_short_nop_fill, next, 0 }\n "
    },
    {
      "sha": "3d951d7515653c132ba87adc77ef5e1e1e53dea6",
      "filename": "bfd/cpu-ip2k.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-ip2k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-ip2k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-ip2k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,8 +41,8 @@\n   }\n \n const bfd_arch_info_type bfd_ip2k_nonext_arch =\n-  N (bfd_mach_ip2022, \"ip2022\", FALSE, NULL);\n+  N (bfd_mach_ip2022, \"ip2022\", false, NULL);\n \n const bfd_arch_info_type bfd_ip2k_arch =\n-  N (bfd_mach_ip2022ext, \"ip2022ext\", TRUE, & bfd_ip2k_nonext_arch);\n+  N (bfd_mach_ip2022ext, \"ip2022ext\", true, & bfd_ip2k_nonext_arch);\n "
    },
    {
      "sha": "d8ea353900caad3aacc22fbc3854e9b58145a400",
      "filename": "bfd/cpu-iq2000.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-iq2000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-iq2000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-iq2000.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,8 +41,8 @@\n   }\n \n static const bfd_arch_info_type arch_info_struct =\n-  N (bfd_mach_iq10, \"iq10\", FALSE, NULL);\n+  N (bfd_mach_iq10, \"iq10\", false, NULL);\n \n const bfd_arch_info_type bfd_iq2000_arch =\n-  N (bfd_mach_iq2000, \"iq2000\", TRUE, &arch_info_struct);\n+  N (bfd_mach_iq2000, \"iq2000\", true, &arch_info_struct);\n "
    },
    {
      "sha": "acde0836f1224ba433a89dc203fbeccd0c576c85",
      "filename": "bfd/cpu-k1om.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-k1om.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-k1om.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-k1om.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -22,12 +22,11 @@\n #include \"bfd.h\"\n #include \"libbfd.h\"\n \n-extern void * bfd_arch_i386_short_nop_fill (bfd_size_type, bfd_boolean,\n-\t\t\t\t\t    bfd_boolean);\n+extern void *bfd_arch_i386_short_nop_fill (bfd_size_type, bool, bool);\n \n-#define N(number, name, print, next)\t\t\t     \\\n-  { 64, 64, 8, bfd_arch_k1om, number, name, print, 3, TRUE, \\\n-    bfd_default_compatible, bfd_default_scan,\t\t     \\\n+#define N(number, name, print, next)\t\t\t\t\\\n+  { 64, 64, 8, bfd_arch_k1om, number, name, print, 3, true,\t\\\n+    bfd_default_compatible, bfd_default_scan,\t\t\t\\\n     bfd_arch_i386_short_nop_fill, next, 9 }\n \n static const bfd_arch_info_type bfd_k1om_arch_intel_syntax ="
    },
    {
      "sha": "086e727a64b80fe64d5c2224cfe2a6b26493486e",
      "filename": "bfd/cpu-l1om.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-l1om.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-l1om.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-l1om.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -22,12 +22,11 @@\n #include \"bfd.h\"\n #include \"libbfd.h\"\n \n-extern void * bfd_arch_i386_short_nop_fill (bfd_size_type, bfd_boolean,\n-\t\t\t\t\t    bfd_boolean);\n+extern void *bfd_arch_i386_short_nop_fill (bfd_size_type, bool, bool);\n \n-#define N(number, name, print, next)\t\t\t     \\\n-  { 64, 64, 8, bfd_arch_l1om, number, name, print, 3, TRUE, \\\n-    bfd_default_compatible, bfd_default_scan,\t\t     \\\n+#define N(number, name, print, next)\t\t\t\t\\\n+  { 64, 64, 8, bfd_arch_l1om, number, name, print, 3, true,\t\\\n+    bfd_default_compatible, bfd_default_scan,\t\t\t\\\n     bfd_arch_i386_short_nop_fill, next, 0 }\n \n static const bfd_arch_info_type bfd_l1om_arch_intel_syntax ="
    },
    {
      "sha": "2045ef9a337fe50d3d2bdcf0b60d670aebfdacd7",
      "filename": "bfd/cpu-lm32.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-lm32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_lm32_arch =\n   \"lm32\",\t\t  /* Architecture name.  */\n   \"lm32\",\t\t  /* Printable name.  */\n   4,\t\t\t  /* Alignment.  */\n-  TRUE,\t\t\t  /* Is this the default machine for the target.  */\n+  true,\t\t\t  /* Is this the default machine for the target.  */\n   bfd_default_compatible, /* Function callback to test if two files have compatible machines.  */\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "7b6c8e610bbab36d8eaa8c8a130004845294895a",
      "filename": "bfd/cpu-m10200.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m10200.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m10200.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m10200.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_mn10200_arch =\n   \"mn10200\",\n   \"mn10200\",\n   2,\n-  TRUE,   /* The one and only.  */\n+  true,   /* The one and only.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "e8f0fc9d882bdb628852e93cd53627509a6f9bc3",
      "filename": "bfd/cpu-m10300.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m10300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m10300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m10300.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,10 +41,10 @@\n   }\n \n const bfd_arch_info_type bfd_am33_2_arch =\n-  N (bfd_mach_am33_2, \"am33_2\", \"am33-2\", FALSE, NULL);\n+  N (bfd_mach_am33_2, \"am33_2\", \"am33-2\", false, NULL);\n \n const bfd_arch_info_type bfd_am33_arch =\n-  N (bfd_mach_am33, \"am33\", \"am33\", FALSE, &bfd_am33_2_arch);\n+  N (bfd_mach_am33, \"am33\", \"am33\", false, &bfd_am33_2_arch);\n \n const bfd_arch_info_type bfd_mn10300_arch =\n-  N (bfd_mach_mn10300, \"mn10300\", \"mn10300\", TRUE, &bfd_am33_arch);\n+  N (bfd_mach_mn10300, \"mn10300\", \"mn10300\", true, &bfd_am33_arch);"
    },
    {
      "sha": "85436b822f38af65a2b7d51ae22222554007c75d",
      "filename": "bfd/cpu-m32c.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m32c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m32c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m32c.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -25,12 +25,12 @@\n /* Like bfd_default_scan but if the string is just \"m32c\" then\n    skip the m16c architecture.  */\n \n-static bfd_boolean\n+static bool\n m32c_scan (const bfd_arch_info_type * info, const char * string)\n {\n   if (strcmp (string, \"m32c\") == 0\n       && info->mach == bfd_mach_m16c)\n-    return FALSE;\n+    return false;\n \n   return bfd_default_scan (info, string);\n }\n@@ -40,8 +40,8 @@ m32c_scan (const bfd_arch_info_type * info, const char * string)\n   bfd_default_compatible, m32c_scan, bfd_arch_default_fill, next, 0 }\n \n static const bfd_arch_info_type arch_info_struct =\n-  N (bfd_mach_m32c, \"m32c\", 3, FALSE, NULL);\n+  N (bfd_mach_m32c, \"m32c\", 3, false, NULL);\n \n const bfd_arch_info_type bfd_m32c_arch =\n-  N (bfd_mach_m16c, \"m16c\", 4, TRUE, &arch_info_struct);\n+  N (bfd_mach_m16c, \"m16c\", 4, true, &arch_info_struct);\n "
    },
    {
      "sha": "6647aead71045cf92fdc4a642739a1bbdcda7613",
      "filename": "bfd/cpu-m32r.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m32r.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -31,9 +31,9 @@\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (bfd_mach_m32rx, \"m32rx\", FALSE, M32R2_NEXT) ,\n-  N (bfd_mach_m32r2, \"m32r2\", FALSE, NULL)\n+  N (bfd_mach_m32rx, \"m32rx\", false, M32R2_NEXT) ,\n+  N (bfd_mach_m32r2, \"m32r2\", false, NULL)\n };\n \n const bfd_arch_info_type bfd_m32r_arch =\n-  N (bfd_mach_m32r, \"m32r\", TRUE, NEXT);\n+  N (bfd_mach_m32r, \"m32r\", true, NEXT);"
    },
    {
      "sha": "863294d727651a0f1c88f3d202ff5ec7e8f5ae3f",
      "filename": "bfd/cpu-m68hc11.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m68hc11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m68hc11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m68hc11.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_m68hc11_arch =\n   \"m68hc11\",\n   \"m68hc11\",\n   4, /* Section alignment power.  */\n-  TRUE,\n+  true,\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "e0d138493008bc2e6e625a527b1df8054dbc6b46",
      "filename": "bfd/cpu-m68hc12.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m68hc12.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m68hc12.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m68hc12.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,8 +41,8 @@\n   }\n \n const bfd_arch_info_type bfd_m68hc12s_arch =\n-  N (bfd_mach_m6812s, \"m68hc12:HCS12\", FALSE, NULL);\n+  N (bfd_mach_m6812s, \"m68hc12:HCS12\", false, NULL);\n \n const bfd_arch_info_type bfd_m68hc12_arch =\n-  N (bfd_mach_m6812_default, \"m68hc12\", TRUE, &bfd_m68hc12s_arch);\n+  N (bfd_mach_m6812_default, \"m68hc12\", true, &bfd_m68hc12s_arch);\n "
    },
    {
      "sha": "9c00b5b69f480f830b34fd7a79bb50df9d444088",
      "filename": "bfd/cpu-m68k.c",
      "status": "modified",
      "additions": 42,
      "deletions": 42,
      "changes": 84,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m68k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m68k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m68k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -35,79 +35,79 @@ bfd_m68k_compatible (const bfd_arch_info_type *a,\n \n static const bfd_arch_info_type arch_info_struct[] =\n   {\n-    N(bfd_mach_m68000,  \"m68k:68000\", FALSE, &arch_info_struct[1]),\n-    N(bfd_mach_m68008,  \"m68k:68008\", FALSE, &arch_info_struct[2]),\n-    N(bfd_mach_m68010,  \"m68k:68010\", FALSE, &arch_info_struct[3]),\n-    N(bfd_mach_m68020,  \"m68k:68020\", FALSE, &arch_info_struct[4]),\n-    N(bfd_mach_m68030,  \"m68k:68030\", FALSE, &arch_info_struct[5]),\n-    N(bfd_mach_m68040,  \"m68k:68040\", FALSE, &arch_info_struct[6]),\n-    N(bfd_mach_m68060,  \"m68k:68060\", FALSE, &arch_info_struct[7]),\n-    N(bfd_mach_cpu32,   \"m68k:cpu32\", FALSE, &arch_info_struct[8]),\n-    N(bfd_mach_fido,    \"m68k:fido\",  FALSE, &arch_info_struct[9]),\n+    N(bfd_mach_m68000,  \"m68k:68000\", false, &arch_info_struct[1]),\n+    N(bfd_mach_m68008,  \"m68k:68008\", false, &arch_info_struct[2]),\n+    N(bfd_mach_m68010,  \"m68k:68010\", false, &arch_info_struct[3]),\n+    N(bfd_mach_m68020,  \"m68k:68020\", false, &arch_info_struct[4]),\n+    N(bfd_mach_m68030,  \"m68k:68030\", false, &arch_info_struct[5]),\n+    N(bfd_mach_m68040,  \"m68k:68040\", false, &arch_info_struct[6]),\n+    N(bfd_mach_m68060,  \"m68k:68060\", false, &arch_info_struct[7]),\n+    N(bfd_mach_cpu32,   \"m68k:cpu32\", false, &arch_info_struct[8]),\n+    N(bfd_mach_fido,    \"m68k:fido\",  false, &arch_info_struct[9]),\n \n     /* Various combinations of CF architecture features */\n     N(bfd_mach_mcf_isa_a_nodiv, \"m68k:isa-a:nodiv\",\n-      FALSE, &arch_info_struct[10]),\n+      false, &arch_info_struct[10]),\n     N(bfd_mach_mcf_isa_a, \"m68k:isa-a\",\n-      FALSE, &arch_info_struct[11]),\n+      false, &arch_info_struct[11]),\n     N(bfd_mach_mcf_isa_a_mac, \"m68k:isa-a:mac\",\n-      FALSE, &arch_info_struct[12]),\n+      false, &arch_info_struct[12]),\n     N(bfd_mach_mcf_isa_a_emac, \"m68k:isa-a:emac\",\n-      FALSE, &arch_info_struct[13]),\n+      false, &arch_info_struct[13]),\n     N(bfd_mach_mcf_isa_aplus, \"m68k:isa-aplus\",\n-      FALSE, &arch_info_struct[14]),\n+      false, &arch_info_struct[14]),\n     N(bfd_mach_mcf_isa_aplus_mac, \"m68k:isa-aplus:mac\",\n-      FALSE, &arch_info_struct[15]),\n+      false, &arch_info_struct[15]),\n     N(bfd_mach_mcf_isa_aplus_emac, \"m68k:isa-aplus:emac\",\n-      FALSE, &arch_info_struct[16]),\n+      false, &arch_info_struct[16]),\n     N(bfd_mach_mcf_isa_b_nousp, \"m68k:isa-b:nousp\",\n-      FALSE, &arch_info_struct[17]),\n+      false, &arch_info_struct[17]),\n     N(bfd_mach_mcf_isa_b_nousp_mac, \"m68k:isa-b:nousp:mac\",\n-      FALSE, &arch_info_struct[18]),\n+      false, &arch_info_struct[18]),\n     N(bfd_mach_mcf_isa_b_nousp_emac, \"m68k:isa-b:nousp:emac\",\n-      FALSE, &arch_info_struct[19]),\n+      false, &arch_info_struct[19]),\n     N(bfd_mach_mcf_isa_b, \"m68k:isa-b\",\n-      FALSE, &arch_info_struct[20]),\n+      false, &arch_info_struct[20]),\n     N(bfd_mach_mcf_isa_b_mac, \"m68k:isa-b:mac\",\n-      FALSE, &arch_info_struct[21]),\n+      false, &arch_info_struct[21]),\n     N(bfd_mach_mcf_isa_b_emac, \"m68k:isa-b:emac\",\n-      FALSE, &arch_info_struct[22]),\n+      false, &arch_info_struct[22]),\n     N(bfd_mach_mcf_isa_b_float, \"m68k:isa-b:float\",\n-      FALSE, &arch_info_struct[23]),\n+      false, &arch_info_struct[23]),\n     N(bfd_mach_mcf_isa_b_float_mac, \"m68k:isa-b:float:mac\",\n-      FALSE, &arch_info_struct[24]),\n+      false, &arch_info_struct[24]),\n     N(bfd_mach_mcf_isa_b_float_emac, \"m68k:isa-b:float:emac\",\n-      FALSE, &arch_info_struct[25]),\n+      false, &arch_info_struct[25]),\n     N(bfd_mach_mcf_isa_c, \"m68k:isa-c\",\n-      FALSE, &arch_info_struct[26]),\n+      false, &arch_info_struct[26]),\n     N(bfd_mach_mcf_isa_c_mac, \"m68k:isa-c:mac\",\n-      FALSE, &arch_info_struct[27]),\n+      false, &arch_info_struct[27]),\n     N(bfd_mach_mcf_isa_c_emac, \"m68k:isa-c:emac\",\n-      FALSE, &arch_info_struct[28]),\n+      false, &arch_info_struct[28]),\n     N(bfd_mach_mcf_isa_c_nodiv, \"m68k:isa-c:nodiv\",\n-      FALSE, &arch_info_struct[29]),\n+      false, &arch_info_struct[29]),\n     N(bfd_mach_mcf_isa_c_nodiv_mac, \"m68k:isa-c:nodiv:mac\",\n-      FALSE, &arch_info_struct[30]),\n+      false, &arch_info_struct[30]),\n     N(bfd_mach_mcf_isa_c_nodiv_emac, \"m68k:isa-c:nodiv:emac\",\n-      FALSE, &arch_info_struct[31]),\n+      false, &arch_info_struct[31]),\n \n     /* Legacy names for CF architectures */\n-    N(bfd_mach_mcf_isa_a_nodiv, \"m68k:5200\", FALSE, &arch_info_struct[32]),\n-    N(bfd_mach_mcf_isa_a_mac,\"m68k:5206e\", FALSE, &arch_info_struct[33]),\n-    N(bfd_mach_mcf_isa_a_mac, \"m68k:5307\", FALSE, &arch_info_struct[34]),\n-    N(bfd_mach_mcf_isa_b_nousp_mac, \"m68k:5407\", FALSE, &arch_info_struct[35]),\n-    N(bfd_mach_mcf_isa_aplus_emac, \"m68k:528x\", FALSE, &arch_info_struct[36]),\n-    N(bfd_mach_mcf_isa_aplus_emac, \"m68k:521x\", FALSE, &arch_info_struct[37]),\n-    N(bfd_mach_mcf_isa_a_emac, \"m68k:5249\", FALSE, &arch_info_struct[38]),\n+    N(bfd_mach_mcf_isa_a_nodiv, \"m68k:5200\", false, &arch_info_struct[32]),\n+    N(bfd_mach_mcf_isa_a_mac,\"m68k:5206e\", false, &arch_info_struct[33]),\n+    N(bfd_mach_mcf_isa_a_mac, \"m68k:5307\", false, &arch_info_struct[34]),\n+    N(bfd_mach_mcf_isa_b_nousp_mac, \"m68k:5407\", false, &arch_info_struct[35]),\n+    N(bfd_mach_mcf_isa_aplus_emac, \"m68k:528x\", false, &arch_info_struct[36]),\n+    N(bfd_mach_mcf_isa_aplus_emac, \"m68k:521x\", false, &arch_info_struct[37]),\n+    N(bfd_mach_mcf_isa_a_emac, \"m68k:5249\", false, &arch_info_struct[38]),\n     N(bfd_mach_mcf_isa_b_float_emac, \"m68k:547x\",\n-      FALSE, &arch_info_struct[39]),\n+      false, &arch_info_struct[39]),\n     N(bfd_mach_mcf_isa_b_float_emac, \"m68k:548x\",\n-      FALSE, &arch_info_struct[40]),\n-    N(bfd_mach_mcf_isa_b_float_emac, \"m68k:cfv4e\", FALSE, 0),\n+      false, &arch_info_struct[40]),\n+    N(bfd_mach_mcf_isa_b_float_emac, \"m68k:cfv4e\", false, 0),\n   };\n \n const bfd_arch_info_type bfd_m68k_arch =\n-  N(0, \"m68k\", TRUE, &arch_info_struct[0]);\n+  N(0, \"m68k\", true, &arch_info_struct[0]);\n \n /* Table indexed by bfd_mach_arch number indicating which\n    architectural features are supported.  */"
    },
    {
      "sha": "00d396aa357b60e47114900a53fea0d85c48a996",
      "filename": "bfd/cpu-m9s12x.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m9s12x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m9s12x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m9s12x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_m9s12x_arch =\n   \"m9s12x\",\n   \"m9s12x\",\n   4,    /* Section alignment power.  */\n-  TRUE,\n+  true,\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "89182a657028b267a38cd7aedbdd46c448395149",
      "filename": "bfd/cpu-m9s12xg.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m9s12xg.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-m9s12xg.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-m9s12xg.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_m9s12xg_arch =\n   \"m9s12xg\",\n   \"m9s12xg\",\n   4,    /* Section alignment power.  */\n-  TRUE,\n+  true,\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "b1b4a703048d48db443eaa2e29c71680dcb314a4",
      "filename": "bfd/cpu-mcore.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-mcore.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_mcore_arch =\n   \"MCore\",\t\t\t/* Architecture name.  */\n   \"MCore\",\t\t\t/* Machine name.  */\n   3,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* Is this the default architecture ?  */\n+  true,\t\t\t\t/* Is this the default architecture ?  */\n   bfd_default_compatible,\t/* Architecture comparison function.  */\n   bfd_default_scan,\t\t/* String to architecture conversion.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "cec77e7ab3696f03a88eec3ca0890f7b3f43bfce",
      "filename": "bfd/cpu-mep.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-mep.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -25,6 +25,6 @@\n \t\t\t   2, def, bfd_default_compatible, bfd_default_scan, \\\n \t\t\t   bfd_arch_default_fill, y, 0 }\n \n-static const bfd_arch_info_type bfd_c5_arch = MA (bfd_mach_mep_c5, \"c5\", FALSE, NULL);\n-static const bfd_arch_info_type bfd_h1_arch = MA (bfd_mach_mep_h1, \"h1\", FALSE, & bfd_c5_arch);\n-const bfd_arch_info_type bfd_mep_arch = MA (bfd_mach_mep, \"mep\", TRUE, & bfd_h1_arch);\n+static const bfd_arch_info_type bfd_c5_arch = MA (bfd_mach_mep_c5, \"c5\", false, NULL);\n+static const bfd_arch_info_type bfd_h1_arch = MA (bfd_mach_mep_h1, \"h1\", false, & bfd_c5_arch);\n+const bfd_arch_info_type bfd_mep_arch = MA (bfd_mach_mep, \"mep\", true, & bfd_h1_arch);"
    },
    {
      "sha": "e939384af845fa1c47f46d75cb23a6a4f999ff1d",
      "filename": "bfd/cpu-metag.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-metag.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_metag_arch =\n   \"metag\",\t\t\t/* Architecture name.  */\n   \"metag\",\t\t\t/* Printable name.  */\n   4,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* The default ?  */\n+  true,\t\t\t\t/* The default ?  */\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "d461d01e08f12c404423ee30f9136390c429db84",
      "filename": "bfd/cpu-microblaze.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-microblaze.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_microblaze_arch =\n   \"microblaze\",\t\t\t/* Architecture name.  */\n   \"MicroBlaze\",\t\t\t/* Printable name.  */\n   3,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* Is this the default architecture ?  */\n+  true,\t\t\t\t/* Is this the default architecture ?  */\n   bfd_default_compatible,\t/* Architecture comparison function.  */\n   bfd_default_scan,\t\t/* String to architecture conversion.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "76b507e3c7727ea0e5099a19bf62a89572ec198b",
      "filename": "bfd/cpu-mips.c",
      "status": "modified",
      "additions": 49,
      "deletions": 49,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-mips.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -115,60 +115,60 @@ enum\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (32, 32, bfd_mach_mips3000, \"mips:3000\",\t  FALSE, NN(I_mips3000)),\n-  N (32, 32, bfd_mach_mips3900, \"mips:3900\",\t  FALSE, NN(I_mips3900)),\n-  N (64, 64, bfd_mach_mips4000, \"mips:4000\",\t  FALSE, NN(I_mips4000)),\n-  N (32, 32, bfd_mach_mips4010, \"mips:4010\",\t  FALSE, NN(I_mips4010)),\n-  N (64, 64, bfd_mach_mips4100, \"mips:4100\",\t  FALSE, NN(I_mips4100)),\n-  N (64, 64, bfd_mach_mips4111, \"mips:4111\",\t  FALSE, NN(I_mips4111)),\n-  N (64, 64, bfd_mach_mips4120, \"mips:4120\",\t  FALSE, NN(I_mips4120)),\n-  N (64, 64, bfd_mach_mips4300, \"mips:4300\",\t  FALSE, NN(I_mips4300)),\n-  N (64, 64, bfd_mach_mips4400, \"mips:4400\",\t  FALSE, NN(I_mips4400)),\n-  N (64, 64, bfd_mach_mips4600, \"mips:4600\",\t  FALSE, NN(I_mips4600)),\n-  N (64, 64, bfd_mach_mips4650, \"mips:4650\",\t  FALSE, NN(I_mips4650)),\n-  N (64, 64, bfd_mach_mips5000, \"mips:5000\",\t  FALSE, NN(I_mips5000)),\n-  N (64, 64, bfd_mach_mips5400, \"mips:5400\",\t  FALSE, NN(I_mips5400)),\n-  N (64, 64, bfd_mach_mips5500, \"mips:5500\",\t  FALSE, NN(I_mips5500)),\n-  N (64, 32, bfd_mach_mips5900, \"mips:5900\",\t  FALSE, NN(I_mips5900)),\n-  N (32, 32, bfd_mach_mips6000, \"mips:6000\",\t  FALSE, NN(I_mips6000)),\n-  N (64, 64, bfd_mach_mips7000, \"mips:7000\",\t  FALSE, NN(I_mips7000)),\n-  N (64, 64, bfd_mach_mips8000, \"mips:8000\",\t  FALSE, NN(I_mips8000)),\n-  N (64, 64, bfd_mach_mips9000, \"mips:9000\",\t  FALSE, NN(I_mips9000)),\n-  N (64, 64, bfd_mach_mips10000,\"mips:10000\",\t  FALSE, NN(I_mips10000)),\n-  N (64, 64, bfd_mach_mips12000,\"mips:12000\",\t  FALSE, NN(I_mips12000)),\n-  N (64, 64, bfd_mach_mips14000,\"mips:14000\",\t  FALSE, NN(I_mips14000)),\n-  N (64, 64, bfd_mach_mips16000,\"mips:16000\",\t  FALSE, NN(I_mips16000)),\n-  N (64, 64, bfd_mach_mips16,\t\"mips:16\",\t  FALSE, NN(I_mips16)),\n-  N (64, 64, bfd_mach_mips5,\t\"mips:mips5\",\t  FALSE, NN(I_mips5)),\n-  N (32, 32, bfd_mach_mipsisa32,  \"mips:isa32\",\t  FALSE, NN(I_mipsisa32)),\n-  N (32, 32, bfd_mach_mipsisa32r2,\"mips:isa32r2\", FALSE, NN(I_mipsisa32r2)),\n-  N (32, 32, bfd_mach_mipsisa32r3,\"mips:isa32r3\", FALSE, NN(I_mipsisa32r3)),\n-  N (32, 32, bfd_mach_mipsisa32r5,\"mips:isa32r5\", FALSE, NN(I_mipsisa32r5)),\n-  N (32, 32, bfd_mach_mipsisa32r6,\"mips:isa32r6\", FALSE, NN(I_mipsisa32r6)),\n-  N (64, 64, bfd_mach_mipsisa64,  \"mips:isa64\",\t  FALSE, NN(I_mipsisa64)),\n-  N (64, 64, bfd_mach_mipsisa64r2,\"mips:isa64r2\", FALSE, NN(I_mipsisa64r2)),\n-  N (64, 64, bfd_mach_mipsisa64r3,\"mips:isa64r3\", FALSE, NN(I_mipsisa64r3)),\n-  N (64, 64, bfd_mach_mipsisa64r5,\"mips:isa64r5\", FALSE, NN(I_mipsisa64r5)),\n-  N (64, 64, bfd_mach_mipsisa64r6,\"mips:isa64r6\", FALSE, NN(I_mipsisa64r6)),\n-  N (64, 64, bfd_mach_mips_sb1, \"mips:sb1\",\t  FALSE, NN(I_sb1)),\n-  N (64, 64, bfd_mach_mips_loongson_2e, \"mips:loongson_2e\", FALSE, NN(I_loongson_2e)),\n-  N (64, 64, bfd_mach_mips_loongson_2f, \"mips:loongson_2f\", FALSE, NN(I_loongson_2f)),\n-  N (64, 64, bfd_mach_mips_gs464, \"mips:gs464\",\t  FALSE, NN(I_gs464)),\n-  N (64, 64, bfd_mach_mips_gs464e, \"mips:gs464e\", FALSE, NN(I_gs464e)),\n-  N (64, 64, bfd_mach_mips_gs264e, \"mips:gs264e\", FALSE, NN(I_gs264e)),\n-  N (64, 64, bfd_mach_mips_octeon,\"mips:octeon\",  FALSE, NN(I_mipsocteon)),\n-  N (64, 64, bfd_mach_mips_octeonp,\"mips:octeon+\", FALSE, NN(I_mipsocteonp)),\n-  N (64, 64, bfd_mach_mips_octeon2,\"mips:octeon2\", FALSE, NN(I_mipsocteon2)),\n-  N (64, 64, bfd_mach_mips_octeon3, \"mips:octeon3\", FALSE, NN(I_mipsocteon3)),\n-  N (64, 64, bfd_mach_mips_xlr, \"mips:xlr\",\t   FALSE, NN(I_xlr)),\n-  N (32, 32, bfd_mach_mips_interaptiv_mr2, \"mips:interaptiv-mr2\", FALSE,\n+  N (32, 32, bfd_mach_mips3000, \"mips:3000\",\t  false, NN(I_mips3000)),\n+  N (32, 32, bfd_mach_mips3900, \"mips:3900\",\t  false, NN(I_mips3900)),\n+  N (64, 64, bfd_mach_mips4000, \"mips:4000\",\t  false, NN(I_mips4000)),\n+  N (32, 32, bfd_mach_mips4010, \"mips:4010\",\t  false, NN(I_mips4010)),\n+  N (64, 64, bfd_mach_mips4100, \"mips:4100\",\t  false, NN(I_mips4100)),\n+  N (64, 64, bfd_mach_mips4111, \"mips:4111\",\t  false, NN(I_mips4111)),\n+  N (64, 64, bfd_mach_mips4120, \"mips:4120\",\t  false, NN(I_mips4120)),\n+  N (64, 64, bfd_mach_mips4300, \"mips:4300\",\t  false, NN(I_mips4300)),\n+  N (64, 64, bfd_mach_mips4400, \"mips:4400\",\t  false, NN(I_mips4400)),\n+  N (64, 64, bfd_mach_mips4600, \"mips:4600\",\t  false, NN(I_mips4600)),\n+  N (64, 64, bfd_mach_mips4650, \"mips:4650\",\t  false, NN(I_mips4650)),\n+  N (64, 64, bfd_mach_mips5000, \"mips:5000\",\t  false, NN(I_mips5000)),\n+  N (64, 64, bfd_mach_mips5400, \"mips:5400\",\t  false, NN(I_mips5400)),\n+  N (64, 64, bfd_mach_mips5500, \"mips:5500\",\t  false, NN(I_mips5500)),\n+  N (64, 32, bfd_mach_mips5900, \"mips:5900\",\t  false, NN(I_mips5900)),\n+  N (32, 32, bfd_mach_mips6000, \"mips:6000\",\t  false, NN(I_mips6000)),\n+  N (64, 64, bfd_mach_mips7000, \"mips:7000\",\t  false, NN(I_mips7000)),\n+  N (64, 64, bfd_mach_mips8000, \"mips:8000\",\t  false, NN(I_mips8000)),\n+  N (64, 64, bfd_mach_mips9000, \"mips:9000\",\t  false, NN(I_mips9000)),\n+  N (64, 64, bfd_mach_mips10000,\"mips:10000\",\t  false, NN(I_mips10000)),\n+  N (64, 64, bfd_mach_mips12000,\"mips:12000\",\t  false, NN(I_mips12000)),\n+  N (64, 64, bfd_mach_mips14000,\"mips:14000\",\t  false, NN(I_mips14000)),\n+  N (64, 64, bfd_mach_mips16000,\"mips:16000\",\t  false, NN(I_mips16000)),\n+  N (64, 64, bfd_mach_mips16,\t\"mips:16\",\t  false, NN(I_mips16)),\n+  N (64, 64, bfd_mach_mips5,\t\"mips:mips5\",\t  false, NN(I_mips5)),\n+  N (32, 32, bfd_mach_mipsisa32,  \"mips:isa32\",\t  false, NN(I_mipsisa32)),\n+  N (32, 32, bfd_mach_mipsisa32r2,\"mips:isa32r2\", false, NN(I_mipsisa32r2)),\n+  N (32, 32, bfd_mach_mipsisa32r3,\"mips:isa32r3\", false, NN(I_mipsisa32r3)),\n+  N (32, 32, bfd_mach_mipsisa32r5,\"mips:isa32r5\", false, NN(I_mipsisa32r5)),\n+  N (32, 32, bfd_mach_mipsisa32r6,\"mips:isa32r6\", false, NN(I_mipsisa32r6)),\n+  N (64, 64, bfd_mach_mipsisa64,  \"mips:isa64\",\t  false, NN(I_mipsisa64)),\n+  N (64, 64, bfd_mach_mipsisa64r2,\"mips:isa64r2\", false, NN(I_mipsisa64r2)),\n+  N (64, 64, bfd_mach_mipsisa64r3,\"mips:isa64r3\", false, NN(I_mipsisa64r3)),\n+  N (64, 64, bfd_mach_mipsisa64r5,\"mips:isa64r5\", false, NN(I_mipsisa64r5)),\n+  N (64, 64, bfd_mach_mipsisa64r6,\"mips:isa64r6\", false, NN(I_mipsisa64r6)),\n+  N (64, 64, bfd_mach_mips_sb1, \"mips:sb1\",\t  false, NN(I_sb1)),\n+  N (64, 64, bfd_mach_mips_loongson_2e, \"mips:loongson_2e\", false, NN(I_loongson_2e)),\n+  N (64, 64, bfd_mach_mips_loongson_2f, \"mips:loongson_2f\", false, NN(I_loongson_2f)),\n+  N (64, 64, bfd_mach_mips_gs464, \"mips:gs464\",\t  false, NN(I_gs464)),\n+  N (64, 64, bfd_mach_mips_gs464e, \"mips:gs464e\", false, NN(I_gs464e)),\n+  N (64, 64, bfd_mach_mips_gs264e, \"mips:gs264e\", false, NN(I_gs264e)),\n+  N (64, 64, bfd_mach_mips_octeon,\"mips:octeon\",  false, NN(I_mipsocteon)),\n+  N (64, 64, bfd_mach_mips_octeonp,\"mips:octeon+\", false, NN(I_mipsocteonp)),\n+  N (64, 64, bfd_mach_mips_octeon2,\"mips:octeon2\", false, NN(I_mipsocteon2)),\n+  N (64, 64, bfd_mach_mips_octeon3, \"mips:octeon3\", false, NN(I_mipsocteon3)),\n+  N (64, 64, bfd_mach_mips_xlr, \"mips:xlr\",\t   false, NN(I_xlr)),\n+  N (32, 32, bfd_mach_mips_interaptiv_mr2, \"mips:interaptiv-mr2\", false,\n      NN(I_interaptiv_mr2)),\n-  N (64, 64, bfd_mach_mips_micromips, \"mips:micromips\", FALSE, NULL)\n+  N (64, 64, bfd_mach_mips_micromips, \"mips:micromips\", false, NULL)\n };\n \n /* The default architecture is mips:3000, but with a machine number of\n    zero.  This lets the linker distinguish between a default setting\n    of mips, and an explicit setting of mips:3000.  */\n \n const bfd_arch_info_type bfd_mips_arch =\n-N (32, 32, 0, \"mips\", TRUE, &arch_info_struct[0]);\n+N (32, 32, 0, \"mips\", true, &arch_info_struct[0]);"
    },
    {
      "sha": "a8e7c0674fb108f566bf3845cce44f705e9fbe5a",
      "filename": "bfd/cpu-mmix.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mmix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mmix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-mmix.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -35,7 +35,7 @@ bfd_mmix_arch =\n   \"mmix\",\t\t\t/* Architecture name.  */\n   \"mmix\",\t\t\t/* Printable name.  */\n   3,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t/* This is the default architecture.  */\n+  true,\t\t\t\t/* This is the default architecture.  */\n   bfd_default_compatible,\t/* Architecture comparison function.  */\n   bfd_default_scan,\t\t/* String to architecture conversion.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "f596bbdc8d8ce26d2e299d5267637b84c0bd539d",
      "filename": "bfd/cpu-moxie.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-moxie.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-moxie.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-moxie.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_moxie_arch =\n   \"moxie\",\t      /* Arch name.  */\n   \"moxie\",\t      /* Printable name.  */\n   2,\t\t      /* Section alignment power.  */\n-  TRUE,\t              /* The one and only.  */\n+  true,\t              /* The one and only.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "19b6d6b608cb07bcc0d6e95e43e4853a6942abc7",
      "filename": "bfd/cpu-msp430.c",
      "status": "modified",
      "additions": 25,
      "deletions": 25,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-msp430.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-msp430.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-msp430.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -62,78 +62,78 @@ compatible (const bfd_arch_info_type * a,\n static const bfd_arch_info_type arch_info_struct[] =\n {\n   /* msp430x11x.  */\n-  N (16, bfd_mach_msp11, \"MSP430\", FALSE, & arch_info_struct[1]),\n+  N (16, bfd_mach_msp11, \"MSP430\", false, & arch_info_struct[1]),\n \n   /* msp430x11x1.  */\n-  N (16, bfd_mach_msp110, \"MSP430x11x1\", FALSE, & arch_info_struct[2]),\n+  N (16, bfd_mach_msp110, \"MSP430x11x1\", false, & arch_info_struct[2]),\n \n   /* msp430x12x.  */\n-  N (16, bfd_mach_msp12, \"MSP430x12\", FALSE, & arch_info_struct[3]),\n+  N (16, bfd_mach_msp12, \"MSP430x12\", false, & arch_info_struct[3]),\n \n   /* msp430x13x.  */\n-  N (16, bfd_mach_msp13, \"MSP430x13\", FALSE, & arch_info_struct[4]),\n+  N (16, bfd_mach_msp13, \"MSP430x13\", false, & arch_info_struct[4]),\n \n   /* msp430x14x.  */\n-  N (16, bfd_mach_msp14, \"MSP430x14\", FALSE, & arch_info_struct[5]),\n+  N (16, bfd_mach_msp14, \"MSP430x14\", false, & arch_info_struct[5]),\n \n   /* msp430x15x.  */\n-  N (16, bfd_mach_msp15, \"MSP430x15\", FALSE, & arch_info_struct[6]),\n+  N (16, bfd_mach_msp15, \"MSP430x15\", false, & arch_info_struct[6]),\n \n   /* msp430x16x.  */\n-  N (16, bfd_mach_msp16, \"MSP430x16\", FALSE, & arch_info_struct[7]),\n+  N (16, bfd_mach_msp16, \"MSP430x16\", false, & arch_info_struct[7]),\n \n   /* msp430x20x.  */\n-  N (16, bfd_mach_msp20, \"MSP430x20\", FALSE, & arch_info_struct[8]),\n+  N (16, bfd_mach_msp20, \"MSP430x20\", false, & arch_info_struct[8]),\n \n   /* msp430x21x.  */\n-  N (16, bfd_mach_msp21, \"MSP430x21\", FALSE, & arch_info_struct[9]),\n+  N (16, bfd_mach_msp21, \"MSP430x21\", false, & arch_info_struct[9]),\n \n   /* msp430x22x.  */\n-  N (16, bfd_mach_msp22, \"MSP430x22\", FALSE, & arch_info_struct[10]),\n+  N (16, bfd_mach_msp22, \"MSP430x22\", false, & arch_info_struct[10]),\n \n   /* msp430x23x.  */\n-  N (16, bfd_mach_msp23, \"MSP430x23\", FALSE, & arch_info_struct[11]),\n+  N (16, bfd_mach_msp23, \"MSP430x23\", false, & arch_info_struct[11]),\n \n   /* msp430x24x.  */\n-  N (16, bfd_mach_msp24, \"MSP430x24\", FALSE, & arch_info_struct[12]),\n+  N (16, bfd_mach_msp24, \"MSP430x24\", false, & arch_info_struct[12]),\n \n   /* msp430x26x.  */\n-  N (16, bfd_mach_msp26, \"MSP430x26\", FALSE, & arch_info_struct[13]),\n+  N (16, bfd_mach_msp26, \"MSP430x26\", false, & arch_info_struct[13]),\n \n   /* msp430x31x.  */\n-  N (16, bfd_mach_msp31, \"MSP430x31\", FALSE, & arch_info_struct[14]),\n+  N (16, bfd_mach_msp31, \"MSP430x31\", false, & arch_info_struct[14]),\n \n   /* msp430x32x.  */\n-  N (16, bfd_mach_msp32, \"MSP430x32\", FALSE, & arch_info_struct[15]),\n+  N (16, bfd_mach_msp32, \"MSP430x32\", false, & arch_info_struct[15]),\n \n   /* msp430x33x.  */\n-  N (16, bfd_mach_msp33, \"MSP430x33\", FALSE, & arch_info_struct[16]),\n+  N (16, bfd_mach_msp33, \"MSP430x33\", false, & arch_info_struct[16]),\n \n   /* msp430x41x.  */\n-  N (16, bfd_mach_msp41, \"MSP430x41\", FALSE, & arch_info_struct[17]),\n+  N (16, bfd_mach_msp41, \"MSP430x41\", false, & arch_info_struct[17]),\n \n   /* msp430x42x.  */\n-  N (16, bfd_mach_msp42, \"MSP430x42\", FALSE, & arch_info_struct[18]),\n+  N (16, bfd_mach_msp42, \"MSP430x42\", false, & arch_info_struct[18]),\n \n   /* msp430x43x.  */\n-  N (16, bfd_mach_msp43, \"MSP430x43\", FALSE, & arch_info_struct[19]),\n+  N (16, bfd_mach_msp43, \"MSP430x43\", false, & arch_info_struct[19]),\n \n   /* msp430x44x.  */\n-  N (16, bfd_mach_msp43, \"MSP430x44\", FALSE, & arch_info_struct[20]),\n+  N (16, bfd_mach_msp43, \"MSP430x44\", false, & arch_info_struct[20]),\n \n   /* msp430x46x.  */\n-  N (16, bfd_mach_msp46, \"MSP430x46\", FALSE, & arch_info_struct[21]),\n+  N (16, bfd_mach_msp46, \"MSP430x46\", false, & arch_info_struct[21]),\n \n   /* msp430x47x.  */\n-  N (16, bfd_mach_msp47, \"MSP430x47\", FALSE, & arch_info_struct[22]),\n+  N (16, bfd_mach_msp47, \"MSP430x47\", false, & arch_info_struct[22]),\n \n   /* msp430x54x.  */\n-  N (16, bfd_mach_msp54, \"MSP430x54\", FALSE, & arch_info_struct[23]),\n+  N (16, bfd_mach_msp54, \"MSP430x54\", false, & arch_info_struct[23]),\n \n-  N (32, bfd_mach_msp430x, \"MSP430X\", FALSE, NULL)\n+  N (32, bfd_mach_msp430x, \"MSP430X\", false, NULL)\n \n };\n \n const bfd_arch_info_type bfd_msp430_arch =\n-  N (16, bfd_mach_msp14, \"msp:14\", TRUE, & arch_info_struct[0]);\n+  N (16, bfd_mach_msp14, \"msp:14\", true, & arch_info_struct[0]);\n "
    },
    {
      "sha": "508742c4c20f29801d87b3212e0f4c0020d96b44",
      "filename": "bfd/cpu-mt.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-mt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-mt.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -42,11 +42,11 @@\n \n const bfd_arch_info_type arch_info_struct[2] =\n {\n-  N (bfd_mach_mrisc2, \"ms1-003\", FALSE, arch_info_struct + 1),\n-  N (bfd_mach_ms2,    \"ms2\",     FALSE, NULL)\n+  N (bfd_mach_mrisc2, \"ms1-003\", false, arch_info_struct + 1),\n+  N (bfd_mach_ms2,    \"ms2\",     false, NULL)\n };\n \n const bfd_arch_info_type bfd_mt_arch =\n-  N (bfd_mach_ms1,    \"ms1\",     TRUE, arch_info_struct);\n+  N (bfd_mach_ms1,    \"ms1\",     true, arch_info_struct);\n \n "
    },
    {
      "sha": "3473a56908584bd38169ca2775c315bf735f7804",
      "filename": "bfd/cpu-nds32.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-nds32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -35,11 +35,11 @@\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (bfd_mach_n1h, \"n1h\", FALSE, NDS32V2_NEXT),\n-  N (bfd_mach_n1h_v2, \"n1h_v2\", FALSE, NDS32V3_NEXT),\n-  N (bfd_mach_n1h_v3, \"n1h_v3\", FALSE, NDS32V3M_NEXT),\n-  N (bfd_mach_n1h_v3m, \"n1h_v3m\", FALSE, NULL),\n+  N (bfd_mach_n1h, \"n1h\", false, NDS32V2_NEXT),\n+  N (bfd_mach_n1h_v2, \"n1h_v2\", false, NDS32V3_NEXT),\n+  N (bfd_mach_n1h_v3, \"n1h_v3\", false, NDS32V3M_NEXT),\n+  N (bfd_mach_n1h_v3m, \"n1h_v3m\", false, NULL),\n };\n \n const bfd_arch_info_type bfd_nds32_arch =\n-  N (bfd_mach_n1, \"n1h\", TRUE, NEXT);\n+  N (bfd_mach_n1, \"n1h\", true, NEXT);"
    },
    {
      "sha": "88c95932960878ff02e60bc51543bf8e79305280",
      "filename": "bfd/cpu-nfp.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-nfp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-nfp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-nfp.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -55,7 +55,7 @@ bfd_nfp_compatible (const bfd_arch_info_type * a,\n }\n \n static const bfd_arch_info_type arch_info_struct =\n-  N (bfd_mach_nfp3200, \"NFP-32xx\", FALSE, NULL);\n+  N (bfd_mach_nfp3200, \"NFP-32xx\", false, NULL);\n \n const bfd_arch_info_type bfd_nfp_arch =\n-  N (bfd_mach_nfp6000, \"NFP-6xxx\", TRUE, &arch_info_struct);\n+  N (bfd_mach_nfp6000, \"NFP-6xxx\", true, &arch_info_struct);"
    },
    {
      "sha": "da7bb82fe6b869291f12c2ac348af657b6496172",
      "filename": "bfd/cpu-nios2.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-nios2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-nios2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-nios2.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -67,9 +67,9 @@ nios2_compatible (const bfd_arch_info_type *a,\n \n static const bfd_arch_info_type arch_info_struct[2] =\n {\n-  N (bfd_mach_nios2r1, \"nios2:r1\", FALSE, NIOS2R2_NEXT),\n-  N (bfd_mach_nios2r2, \"nios2:r2\", FALSE, NULL),\n+  N (bfd_mach_nios2r1, \"nios2:r1\", false, NIOS2R2_NEXT),\n+  N (bfd_mach_nios2r2, \"nios2:r2\", false, NULL),\n };\n \n const bfd_arch_info_type bfd_nios2_arch =\n-  N (bfd_mach_nios2, \"nios2\", TRUE, NIOS2R1_NEXT);\n+  N (bfd_mach_nios2, \"nios2\", true, NIOS2R1_NEXT);"
    },
    {
      "sha": "12f989e704fe80ef1f46512657aa49df02e30299",
      "filename": "bfd/cpu-ns32k.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-ns32k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-ns32k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-ns32k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -31,11 +31,11 @@\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (32532, \"ns32k:32532\", TRUE, 0), /* The word ns32k will match this too.  */\n+  N (32532, \"ns32k:32532\", true, 0), /* The word ns32k will match this too.  */\n };\n \n const bfd_arch_info_type bfd_ns32k_arch =\n-  N (32032, \"ns32k:32032\", FALSE, &arch_info_struct[0]);\n+  N (32032, \"ns32k:32032\", false, &arch_info_struct[0]);\n \n bfd_vma\n _bfd_ns32k_get_displacement (bfd_byte *buffer, int size)\n@@ -572,7 +572,7 @@ _bfd_do_ns32k_reloc_contents (reloc_howto_type *howto,\n {\n   int size;\n   bfd_vma x;\n-  bfd_boolean overflow;\n+  bool overflow;\n \n   if (howto->negate)\n     relocation = -relocation;\n@@ -599,7 +599,7 @@ _bfd_do_ns32k_reloc_contents (reloc_howto_type *howto,\n      which we don't check for.  We must either check at every single\n      operation, which would be tedious, or we must do the computations\n      in a type larger than bfd_vma, which would be inefficient.  */\n-  overflow = FALSE;\n+  overflow = false;\n   if (howto->complain_on_overflow != complain_overflow_dont)\n     {\n       bfd_vma check;\n@@ -674,7 +674,7 @@ _bfd_do_ns32k_reloc_contents (reloc_howto_type *howto,\n \n \t    if (signed_check > reloc_signed_max\n \t\t|| signed_check < reloc_signed_min)\n-\t      overflow = TRUE;\n+\t      overflow = true;\n \t  }\n \t  break;\n \tcase complain_overflow_unsigned:\n@@ -686,7 +686,7 @@ _bfd_do_ns32k_reloc_contents (reloc_howto_type *howto,\n \t    (((1 << (howto->bitsize - 1)) - 1) << 1) | 1;\n \n \t    if (check > reloc_unsigned_max)\n-\t      overflow = TRUE;\n+\t      overflow = true;\n \t  }\n \t  break;\n \tcase complain_overflow_bitfield:\n@@ -699,7 +699,7 @@ _bfd_do_ns32k_reloc_contents (reloc_howto_type *howto,\n \t    if ((check & ~reloc_bits) != 0\n \t\t&& (((bfd_vma) signed_check & ~reloc_bits)\n \t\t    != (-(bfd_vma) 1 & ~reloc_bits)))\n-\t      overflow = TRUE;\n+\t      overflow = true;\n \t  }\n \t  break;\n \tdefault:"
    },
    {
      "sha": "395fb2ee577e210fdafd43fd245b6bc354c74a08",
      "filename": "bfd/cpu-or1k.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-or1k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,7 +41,7 @@\n \n \n const bfd_arch_info_type bfd_or1knd_arch =\n-  N (bfd_mach_or1knd, \"or1knd\", FALSE, NULL);\n+  N (bfd_mach_or1knd, \"or1knd\", false, NULL);\n \n const bfd_arch_info_type bfd_or1k_arch =\n-  N (bfd_mach_or1k, \"or1k\", TRUE, &bfd_or1knd_arch);\n+  N (bfd_mach_or1k, \"or1k\", true, &bfd_or1knd_arch);"
    },
    {
      "sha": "a903555251ac2f72162360ba01844fa8180a7657",
      "filename": "bfd/cpu-pdp11.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-pdp11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-pdp11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-pdp11.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_pdp11_arch =\n   \"pdp11\",\n   \"pdp11\",\n   1,\t/* Alignment = 16 bit.  */\n-  TRUE, /* The one and only.  */\n+  true, /* The one and only.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "1cef7b9297de2d87505bdee2680a0afd0f063263",
      "filename": "bfd/cpu-pj.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-pj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-pj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-pj.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_pj_arch =\n   \"pj\",\t\t\t\t/* Arch_name.  */\n   \"pj\",\t\t\t\t/* Printable name.  */\n   1,\n-  TRUE,\t\t\t\t/* The default machine.  */\n+  true,\t\t\t\t/* The default machine.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "c16f1dc58d7c5e27ea36d9a064337fc804398258",
      "filename": "bfd/cpu-powerpc.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-powerpc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-powerpc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-powerpc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -54,8 +54,8 @@ powerpc_compatible (const bfd_arch_info_type *a,\n \n static void *\n bfd_arch_ppc_nop_fill (bfd_size_type count,\n-\t\t       bfd_boolean is_bigendian,\n-\t\t       bfd_boolean code)\n+\t\t       bool is_bigendian,\n+\t\t       bool code)\n {\n   bfd_byte *fill;\n \n@@ -107,34 +107,34 @@ const bfd_arch_info_type bfd_powerpc_archs[] =\n {\n #if BFD_DEFAULT_TARGET_SIZE == 64\n   /* Default for 64 bit target.  */\n-  N (64, bfd_mach_ppc64, \"powerpc:common64\", TRUE, bfd_powerpc_archs + 1),\n+  N (64, bfd_mach_ppc64, \"powerpc:common64\", true, bfd_powerpc_archs + 1),\n   /* elf32-ppc:ppc_elf_object_p relies on the default 32 bit arch\n      being immediately after the 64 bit default.  */\n-  N (32, bfd_mach_ppc, \"powerpc:common\", FALSE, bfd_powerpc_archs + 2),\n+  N (32, bfd_mach_ppc, \"powerpc:common\", false, bfd_powerpc_archs + 2),\n #else\n   /* Default arch must come first.  */\n-  N (32, bfd_mach_ppc, \"powerpc:common\", TRUE, bfd_powerpc_archs + 1),\n+  N (32, bfd_mach_ppc, \"powerpc:common\", true, bfd_powerpc_archs + 1),\n   /* elf64-ppc:ppc64_elf_object_p relies on the default 64 bit arch\n      being immediately after the 32 bit default.  */\n-  N (64, bfd_mach_ppc64, \"powerpc:common64\", FALSE, bfd_powerpc_archs + 2),\n+  N (64, bfd_mach_ppc64, \"powerpc:common64\", false, bfd_powerpc_archs + 2),\n #endif\n-  N (32, bfd_mach_ppc_603,      \"powerpc:603\",     FALSE, bfd_powerpc_archs + 3),\n-  N (32, bfd_mach_ppc_ec603e,   \"powerpc:EC603e\",  FALSE, bfd_powerpc_archs + 4),\n-  N (32, bfd_mach_ppc_604,      \"powerpc:604\",     FALSE, bfd_powerpc_archs + 5),\n-  N (32, bfd_mach_ppc_403,      \"powerpc:403\",     FALSE, bfd_powerpc_archs + 6),\n-  N (32, bfd_mach_ppc_601,      \"powerpc:601\",     FALSE, bfd_powerpc_archs + 7),\n-  N (64, bfd_mach_ppc_620,      \"powerpc:620\",     FALSE, bfd_powerpc_archs + 8),\n-  N (64, bfd_mach_ppc_630,      \"powerpc:630\",     FALSE, bfd_powerpc_archs + 9),\n-  N (64, bfd_mach_ppc_a35,      \"powerpc:a35\",     FALSE, bfd_powerpc_archs + 10),\n-  N (64, bfd_mach_ppc_rs64ii,   \"powerpc:rs64ii\",  FALSE, bfd_powerpc_archs + 11),\n-  N (64, bfd_mach_ppc_rs64iii,  \"powerpc:rs64iii\", FALSE, bfd_powerpc_archs + 12),\n-  N (32, bfd_mach_ppc_7400,     \"powerpc:7400\",    FALSE, bfd_powerpc_archs + 13),\n-  N (32, bfd_mach_ppc_e500,     \"powerpc:e500\",    FALSE, bfd_powerpc_archs + 14),\n-  N (32, bfd_mach_ppc_e500mc,   \"powerpc:e500mc\",  FALSE, bfd_powerpc_archs + 15),\n-  N (64, bfd_mach_ppc_e500mc64, \"powerpc:e500mc64\",FALSE, bfd_powerpc_archs + 16),\n-  N (32, bfd_mach_ppc_860,      \"powerpc:MPC8XX\",  FALSE, bfd_powerpc_archs + 17),\n-  N (32, bfd_mach_ppc_750,      \"powerpc:750\",     FALSE, bfd_powerpc_archs + 18),\n-  N (32, bfd_mach_ppc_titan,    \"powerpc:titan\",   FALSE, bfd_powerpc_archs + 19),\n+  N (32, bfd_mach_ppc_603,      \"powerpc:603\",     false, bfd_powerpc_archs + 3),\n+  N (32, bfd_mach_ppc_ec603e,   \"powerpc:EC603e\",  false, bfd_powerpc_archs + 4),\n+  N (32, bfd_mach_ppc_604,      \"powerpc:604\",     false, bfd_powerpc_archs + 5),\n+  N (32, bfd_mach_ppc_403,      \"powerpc:403\",     false, bfd_powerpc_archs + 6),\n+  N (32, bfd_mach_ppc_601,      \"powerpc:601\",     false, bfd_powerpc_archs + 7),\n+  N (64, bfd_mach_ppc_620,      \"powerpc:620\",     false, bfd_powerpc_archs + 8),\n+  N (64, bfd_mach_ppc_630,      \"powerpc:630\",     false, bfd_powerpc_archs + 9),\n+  N (64, bfd_mach_ppc_a35,      \"powerpc:a35\",     false, bfd_powerpc_archs + 10),\n+  N (64, bfd_mach_ppc_rs64ii,   \"powerpc:rs64ii\",  false, bfd_powerpc_archs + 11),\n+  N (64, bfd_mach_ppc_rs64iii,  \"powerpc:rs64iii\", false, bfd_powerpc_archs + 12),\n+  N (32, bfd_mach_ppc_7400,     \"powerpc:7400\",    false, bfd_powerpc_archs + 13),\n+  N (32, bfd_mach_ppc_e500,     \"powerpc:e500\",    false, bfd_powerpc_archs + 14),\n+  N (32, bfd_mach_ppc_e500mc,   \"powerpc:e500mc\",  false, bfd_powerpc_archs + 15),\n+  N (64, bfd_mach_ppc_e500mc64, \"powerpc:e500mc64\",false, bfd_powerpc_archs + 16),\n+  N (32, bfd_mach_ppc_860,      \"powerpc:MPC8XX\",  false, bfd_powerpc_archs + 17),\n+  N (32, bfd_mach_ppc_750,      \"powerpc:750\",     false, bfd_powerpc_archs + 18),\n+  N (32, bfd_mach_ppc_titan,    \"powerpc:titan\",   false, bfd_powerpc_archs + 19),\n \n   {\n     16,\t/* Bits in a word.  */\n@@ -145,14 +145,14 @@ const bfd_arch_info_type bfd_powerpc_archs[] =\n     \"powerpc\",\n     \"powerpc:vle\",\n     3,\n-    FALSE, /* Not the default.  */\n+    false, /* Not the default.  */\n     powerpc_compatible,\n     bfd_default_scan,\n     bfd_arch_default_fill,\n     bfd_powerpc_archs + 20,\n     0 /* Maximum offset of a reloc from the start of an insn.  */\n   },\n \n-  N (64, bfd_mach_ppc_e5500, \"powerpc:e5500\", FALSE, bfd_powerpc_archs + 21),\n-  N (64, bfd_mach_ppc_e6500, \"powerpc:e6500\", FALSE, NULL)\n+  N (64, bfd_mach_ppc_e5500, \"powerpc:e5500\", false, bfd_powerpc_archs + 21),\n+  N (64, bfd_mach_ppc_e6500, \"powerpc:e6500\", false, NULL)\n };"
    },
    {
      "sha": "bb6eb6acea56cc9f015ec82de962fdb95e2a551b",
      "filename": "bfd/cpu-pru.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-pru.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-pru.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-pru.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,4 +41,4 @@\n     0 /* Maximum offset of a reloc from the start of an insn.  */ \\\n   }\n \n-const bfd_arch_info_type bfd_pru_arch = N (32, 32, 0, \"pru\", TRUE, NULL);\n+const bfd_arch_info_type bfd_pru_arch = N (32, 32, 0, \"pru\", true, NULL);"
    },
    {
      "sha": "025e94afd34dcaac3f4205c263ea107dd350448e",
      "filename": "bfd/cpu-riscv.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-riscv.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -39,11 +39,11 @@ riscv_compatible (const bfd_arch_info_type *a, const bfd_arch_info_type *b)\n \n /* Return TRUE if STRING matches the architecture described by INFO.  */\n \n-static bfd_boolean\n+static bool\n riscv_scan (const struct bfd_arch_info *info, const char *string)\n {\n   if (bfd_default_scan (info, string))\n-    return TRUE;\n+    return true;\n \n   /* The incoming STRING might take the form of riscv:rvXXzzz, where XX is\n      32 or 64, and zzz are one or more extension characters.  As we\n@@ -59,9 +59,9 @@ riscv_scan (const struct bfd_arch_info *info, const char *string)\n   if (!info->the_default\n       && strncasecmp (string, info->printable_name,\n                       strlen (info->printable_name)) == 0)\n-    return TRUE;\n+    return true;\n \n-  return FALSE;\n+  return false;\n }\n \n #define N(BITS, NUMBER, PRINT, DEFAULT, NEXT)\t\t\t\\\n@@ -95,13 +95,13 @@ enum\n    and each entry except the last should end with NN (my enum value).  */\n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (64, bfd_mach_riscv64, \"riscv:rv64\", FALSE, NN (I_riscv64)),\n-  N (32, bfd_mach_riscv32, \"riscv:rv32\", FALSE, NULL)\n+  N (64, bfd_mach_riscv64, \"riscv:rv64\", false, NN (I_riscv64)),\n+  N (32, bfd_mach_riscv32, \"riscv:rv32\", false, NULL)\n };\n \n /* The default architecture is riscv:rv64.  */\n const bfd_arch_info_type bfd_riscv_arch =\n-  N (64, 0, \"riscv\", TRUE, &arch_info_struct[0]);\n+  N (64, 0, \"riscv\", true, &arch_info_struct[0]);\n \n /* List for all supported ISA spec versions.  */\n const struct riscv_spec riscv_isa_specs[] ="
    },
    {
      "sha": "70a2a5c0bb9993a10d21d23308c6ed92205c265a",
      "filename": "bfd/cpu-rl78.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-rl78.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-rl78.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-rl78.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_rl78_arch =\n   \"rl78\",\t\t\t/* Architecture name.  */\n   \"rl78\",\t\t\t/* Printable name.  */\n   4,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* The default ?  */\n+  true,\t\t\t\t/* The default ?  */\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "821608a1b3cee4411b81eb90e3f47611d28e4ec1",
      "filename": "bfd/cpu-rs6000.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-rs6000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-rs6000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-rs6000.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -66,10 +66,10 @@ rs6000_compatible (const bfd_arch_info_type *a,\n \n static const bfd_arch_info_type arch_info_struct[3] =\n {\n-  N (bfd_mach_rs6k_rs1, \"rs6000:rs1\", FALSE, arch_info_struct + 1),\n-  N (bfd_mach_rs6k_rsc, \"rs6000:rsc\", FALSE, arch_info_struct + 2),\n-  N (bfd_mach_rs6k_rs2, \"rs6000:rs2\", FALSE, NULL)\n+  N (bfd_mach_rs6k_rs1, \"rs6000:rs1\", false, arch_info_struct + 1),\n+  N (bfd_mach_rs6k_rsc, \"rs6000:rsc\", false, arch_info_struct + 2),\n+  N (bfd_mach_rs6k_rs2, \"rs6000:rs2\", false, NULL)\n };\n \n const bfd_arch_info_type bfd_rs6000_arch =\n-  N (bfd_mach_rs6k, \"rs6000:6000\", TRUE, arch_info_struct + 0);\n+  N (bfd_mach_rs6k, \"rs6000:6000\", true, arch_info_struct + 0);"
    },
    {
      "sha": "601523691bf6c401b306052da0eeb3d63956647c",
      "filename": "bfd/cpu-rx.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-rx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-rx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-rx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -29,11 +29,11 @@\n \n static const bfd_arch_info_type arch_info_struct[3] =\n {\n-  N (bfd_mach_rx,    \"rx\",    3, FALSE, arch_info_struct + 1),\n-  N (bfd_mach_rx_v2, \"rx:v2\", 3, FALSE, arch_info_struct + 2),\n-  N (bfd_mach_rx_v3, \"rx:v3\", 3, FALSE, NULL)\n+  N (bfd_mach_rx,    \"rx\",    3, false, arch_info_struct + 1),\n+  N (bfd_mach_rx_v2, \"rx:v2\", 3, false, arch_info_struct + 2),\n+  N (bfd_mach_rx_v3, \"rx:v3\", 3, false, NULL)\n };\n \n const bfd_arch_info_type bfd_rx_arch =\n-  N (bfd_mach_rx,    \"rx\",    4, TRUE, arch_info_struct + 0);\n+  N (bfd_mach_rx,    \"rx\",    4, true, arch_info_struct + 0);\n "
    },
    {
      "sha": "1b72e588246ad2d4cd63ab56ff1ce5f7e67a7eec",
      "filename": "bfd/cpu-s12z.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-s12z.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-s12z.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-s12z.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_s12z_arch =\n   \"s12z\",\n   \"s12z\",\n   4,    /* Section alignment power.  */\n-  TRUE,\n+  true,\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "e71779c0554b8835fde9063656cecf9ecdfd9976",
      "filename": "bfd/cpu-s390.c",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-s390.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -43,12 +43,12 @@\n \n #if BFD_DEFAULT_TARGET_SIZE == 64\n static const bfd_arch_info_type bfd_s390_31_arch =\n-  N (32, bfd_mach_s390_31, \"s390:31-bit\", FALSE, NULL);\n+  N (32, bfd_mach_s390_31, \"s390:31-bit\", false, NULL);\n const bfd_arch_info_type bfd_s390_arch =\n-  N (64, bfd_mach_s390_64, \"s390:64-bit\", TRUE, &bfd_s390_31_arch);\n+  N (64, bfd_mach_s390_64, \"s390:64-bit\", true, &bfd_s390_31_arch);\n #else\n static const bfd_arch_info_type bfd_s390_64_arch =\n-  N (64, bfd_mach_s390_64, \"s390:64-bit\", FALSE, NULL);\n+  N (64, bfd_mach_s390_64, \"s390:64-bit\", false, NULL);\n const bfd_arch_info_type bfd_s390_arch =\n-  N (32, bfd_mach_s390_31, \"s390:31-bit\", TRUE, &bfd_s390_64_arch);\n+  N (32, bfd_mach_s390_31, \"s390:31-bit\", true, &bfd_s390_64_arch);\n #endif"
    },
    {
      "sha": "52545c1e07eff712a06bc826250fa6d3db5a17d9",
      "filename": "bfd/cpu-score.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-score.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-score.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-score.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -63,8 +63,8 @@ compatible (const bfd_arch_info_type * a, const bfd_arch_info_type * b)\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (bfd_mach_score3, \"score3\", FALSE, NULL),\n+  N (bfd_mach_score3, \"score3\", false, NULL),\n };\n \n const bfd_arch_info_type bfd_score_arch =\n-  N (bfd_mach_score7, \"score7\", TRUE, & arch_info_struct[0]);\n+  N (bfd_mach_score7, \"score7\", true, & arch_info_struct[0]);"
    },
    {
      "sha": "2ee7d12296a28c8a8f0582c235607ae9b3b15297",
      "filename": "bfd/cpu-sh.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-sh.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -45,29 +45,29 @@\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (bfd_mach_sh2,          \"sh2\",       FALSE, arch_info_struct + 1),\n-  N (bfd_mach_sh2e,         \"sh2e\",      FALSE, arch_info_struct + 2),\n-  N (bfd_mach_sh_dsp,       \"sh-dsp\",    FALSE, arch_info_struct + 3),\n-  N (bfd_mach_sh3,          \"sh3\",       FALSE, arch_info_struct + 4),\n-  N (bfd_mach_sh3_nommu,    \"sh3-nommu\", FALSE, arch_info_struct + 5),\n-  N (bfd_mach_sh3_dsp,      \"sh3-dsp\",   FALSE, arch_info_struct + 6),\n-  N (bfd_mach_sh3e,         \"sh3e\",      FALSE, arch_info_struct + 7),\n-  N (bfd_mach_sh4,          \"sh4\",       FALSE, arch_info_struct + 8),\n-  N (bfd_mach_sh4a,         \"sh4a\",      FALSE, arch_info_struct + 9),\n-  N (bfd_mach_sh4al_dsp,    \"sh4al-dsp\", FALSE, arch_info_struct + 10),\n-  N (bfd_mach_sh4_nofpu,    \"sh4-nofpu\", FALSE, arch_info_struct + 11),\n-  N (bfd_mach_sh4_nommu_nofpu, \"sh4-nommu-nofpu\", FALSE, arch_info_struct + 12),\n-  N (bfd_mach_sh4a_nofpu,   \"sh4a-nofpu\", FALSE, arch_info_struct + 13),\n-  N (bfd_mach_sh2a,         \"sh2a\",       FALSE, arch_info_struct + 14),\n-  N (bfd_mach_sh2a_nofpu,   \"sh2a-nofpu\", FALSE, arch_info_struct + 15),\n-  N (bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu, \"sh2a-nofpu-or-sh4-nommu-nofpu\", FALSE, arch_info_struct + 16),\n-  N (bfd_mach_sh2a_nofpu_or_sh3_nommu, \"sh2a-nofpu-or-sh3-nommu\", FALSE, arch_info_struct + 17),\n-  N (bfd_mach_sh2a_or_sh4,  \"sh2a-or-sh4\",  FALSE, arch_info_struct + 18),\n-  N (bfd_mach_sh2a_or_sh3e, \"sh2a-or-sh3e\", FALSE, NULL)\n+  N (bfd_mach_sh2,          \"sh2\",       false, arch_info_struct + 1),\n+  N (bfd_mach_sh2e,         \"sh2e\",      false, arch_info_struct + 2),\n+  N (bfd_mach_sh_dsp,       \"sh-dsp\",    false, arch_info_struct + 3),\n+  N (bfd_mach_sh3,          \"sh3\",       false, arch_info_struct + 4),\n+  N (bfd_mach_sh3_nommu,    \"sh3-nommu\", false, arch_info_struct + 5),\n+  N (bfd_mach_sh3_dsp,      \"sh3-dsp\",   false, arch_info_struct + 6),\n+  N (bfd_mach_sh3e,         \"sh3e\",      false, arch_info_struct + 7),\n+  N (bfd_mach_sh4,          \"sh4\",       false, arch_info_struct + 8),\n+  N (bfd_mach_sh4a,         \"sh4a\",      false, arch_info_struct + 9),\n+  N (bfd_mach_sh4al_dsp,    \"sh4al-dsp\", false, arch_info_struct + 10),\n+  N (bfd_mach_sh4_nofpu,    \"sh4-nofpu\", false, arch_info_struct + 11),\n+  N (bfd_mach_sh4_nommu_nofpu, \"sh4-nommu-nofpu\", false, arch_info_struct + 12),\n+  N (bfd_mach_sh4a_nofpu,   \"sh4a-nofpu\", false, arch_info_struct + 13),\n+  N (bfd_mach_sh2a,         \"sh2a\",       false, arch_info_struct + 14),\n+  N (bfd_mach_sh2a_nofpu,   \"sh2a-nofpu\", false, arch_info_struct + 15),\n+  N (bfd_mach_sh2a_nofpu_or_sh4_nommu_nofpu, \"sh2a-nofpu-or-sh4-nommu-nofpu\", false, arch_info_struct + 16),\n+  N (bfd_mach_sh2a_nofpu_or_sh3_nommu, \"sh2a-nofpu-or-sh3-nommu\", false, arch_info_struct + 17),\n+  N (bfd_mach_sh2a_or_sh4,  \"sh2a-or-sh4\",  false, arch_info_struct + 18),\n+  N (bfd_mach_sh2a_or_sh3e, \"sh2a-or-sh3e\", false, NULL)\n };\n \n const bfd_arch_info_type bfd_sh_arch =\n-  N (bfd_mach_sh, \"sh\", TRUE, arch_info_struct + 0);\n+  N (bfd_mach_sh, \"sh\", true, arch_info_struct + 0);\n \n /* This table defines the mappings from the BFD internal numbering\n    system to the opcodes internal flags system."
    },
    {
      "sha": "836c6a9ab369648e63ea367a038311142d38edc8",
      "filename": "bfd/cpu-sparc.c",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-sparc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -42,28 +42,28 @@\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (32, bfd_mach_sparc_sparclet,     \"sparc:sparclet\",     FALSE, arch_info_struct + 1),\n-  N (32, bfd_mach_sparc_sparclite,    \"sparc:sparclite\",    FALSE, arch_info_struct + 2),\n-  N (32, bfd_mach_sparc_v8plus,       \"sparc:v8plus\",       FALSE, arch_info_struct + 3),\n-  N (32, bfd_mach_sparc_v8plusa,      \"sparc:v8plusa\",      FALSE, arch_info_struct + 4),\n-  N (32, bfd_mach_sparc_sparclite_le, \"sparc:sparclite_le\", FALSE, arch_info_struct + 5),\n-  N (64, bfd_mach_sparc_v9,           \"sparc:v9\",           FALSE, arch_info_struct + 6),\n-  N (64, bfd_mach_sparc_v9a,          \"sparc:v9a\",          FALSE, arch_info_struct + 7),\n-  N (32, bfd_mach_sparc_v8plusb,      \"sparc:v8plusb\",      FALSE, arch_info_struct + 8),\n-  N (64, bfd_mach_sparc_v9b,          \"sparc:v9b\",          FALSE, arch_info_struct + 9),\n-  N (32, bfd_mach_sparc_v8plusc,      \"sparc:v8plusc\",      FALSE, arch_info_struct + 10),\n-  N (64, bfd_mach_sparc_v9c,          \"sparc:v9c\",          FALSE, arch_info_struct + 11),\n-  N (32, bfd_mach_sparc_v8plusd,      \"sparc:v8plusd\",      FALSE, arch_info_struct + 12),\n-  N (64, bfd_mach_sparc_v9d,          \"sparc:v9d\",          FALSE, arch_info_struct + 13),\n-  N (32, bfd_mach_sparc_v8pluse,      \"sparc:v8pluse\",      FALSE, arch_info_struct + 14),\n-  N (64, bfd_mach_sparc_v9e,          \"sparc:v9e\",          FALSE, arch_info_struct + 15),\n-  N (32, bfd_mach_sparc_v8plusv,      \"sparc:v8plusv\",      FALSE, arch_info_struct + 16),\n-  N (64, bfd_mach_sparc_v9v,          \"sparc:v9v\",          FALSE, arch_info_struct + 17),\n-  N (32, bfd_mach_sparc_v8plusm,      \"sparc:v8plusm\",      FALSE, arch_info_struct + 18),\n-  N (64, bfd_mach_sparc_v9m,          \"sparc:v9m\",          FALSE, arch_info_struct + 19),\n-  N (32, bfd_mach_sparc_v8plusm8,     \"sparc:v8plusm8\",     FALSE, arch_info_struct + 20),\n-  N (64, bfd_mach_sparc_v9m8,         \"sparc:v9m8\",         FALSE, NULL)\n+  N (32, bfd_mach_sparc_sparclet,     \"sparc:sparclet\",     false, arch_info_struct + 1),\n+  N (32, bfd_mach_sparc_sparclite,    \"sparc:sparclite\",    false, arch_info_struct + 2),\n+  N (32, bfd_mach_sparc_v8plus,       \"sparc:v8plus\",       false, arch_info_struct + 3),\n+  N (32, bfd_mach_sparc_v8plusa,      \"sparc:v8plusa\",      false, arch_info_struct + 4),\n+  N (32, bfd_mach_sparc_sparclite_le, \"sparc:sparclite_le\", false, arch_info_struct + 5),\n+  N (64, bfd_mach_sparc_v9,           \"sparc:v9\",           false, arch_info_struct + 6),\n+  N (64, bfd_mach_sparc_v9a,          \"sparc:v9a\",          false, arch_info_struct + 7),\n+  N (32, bfd_mach_sparc_v8plusb,      \"sparc:v8plusb\",      false, arch_info_struct + 8),\n+  N (64, bfd_mach_sparc_v9b,          \"sparc:v9b\",          false, arch_info_struct + 9),\n+  N (32, bfd_mach_sparc_v8plusc,      \"sparc:v8plusc\",      false, arch_info_struct + 10),\n+  N (64, bfd_mach_sparc_v9c,          \"sparc:v9c\",          false, arch_info_struct + 11),\n+  N (32, bfd_mach_sparc_v8plusd,      \"sparc:v8plusd\",      false, arch_info_struct + 12),\n+  N (64, bfd_mach_sparc_v9d,          \"sparc:v9d\",          false, arch_info_struct + 13),\n+  N (32, bfd_mach_sparc_v8pluse,      \"sparc:v8pluse\",      false, arch_info_struct + 14),\n+  N (64, bfd_mach_sparc_v9e,          \"sparc:v9e\",          false, arch_info_struct + 15),\n+  N (32, bfd_mach_sparc_v8plusv,      \"sparc:v8plusv\",      false, arch_info_struct + 16),\n+  N (64, bfd_mach_sparc_v9v,          \"sparc:v9v\",          false, arch_info_struct + 17),\n+  N (32, bfd_mach_sparc_v8plusm,      \"sparc:v8plusm\",      false, arch_info_struct + 18),\n+  N (64, bfd_mach_sparc_v9m,          \"sparc:v9m\",          false, arch_info_struct + 19),\n+  N (32, bfd_mach_sparc_v8plusm8,     \"sparc:v8plusm8\",     false, arch_info_struct + 20),\n+  N (64, bfd_mach_sparc_v9m8,         \"sparc:v9m8\",         false, NULL)\n };\n \n const bfd_arch_info_type bfd_sparc_arch =\n-  N (32, bfd_mach_sparc, \"sparc\", TRUE, arch_info_struct);\n+  N (32, bfd_mach_sparc, \"sparc\", true, arch_info_struct);"
    },
    {
      "sha": "f8aba7c7a6929df1fb10be8f9b3cd2aa0815ea77",
      "filename": "bfd/cpu-spu.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-spu.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -44,7 +44,7 @@ const bfd_arch_info_type bfd_spu_arch =\n   \"spu\",\t\t/* Architecture name.  */\n   \"spu:256K\",\t\t/* Printable name.  */\n   3,\t\t\t/* Section alignment power.  */\n-  TRUE,\t\t\t/* Default machine.  */\n+  true,\t\t\t/* Default machine.  */\n   spu_compatible,\t/* The spu is only compatible with itself, see above.  */\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "f954dd1efe0f33773167184c73ff71f12b918b51",
      "filename": "bfd/cpu-tic30.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tic30.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tic30.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-tic30.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_tic30_arch =\n   \"tic30\",\n   \"tms320c30\",\n   2,\n-  TRUE,\t\t\t\t/* The one and only.  */\n+  true,\t\t\t\t/* The one and only.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "9143754dce33b0d9f7eb8088a1d46adf2f1bfc70",
      "filename": "bfd/cpu-tic4x.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tic4x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tic4x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-tic4x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -24,7 +24,7 @@\n #include \"bfd.h\"\n #include \"libbfd.h\"\n \n-static bfd_boolean\n+static bool\n tic4x_scan (const struct bfd_arch_info *info,\n \t    const char *string)\n {\n@@ -35,14 +35,14 @@ tic4x_scan (const struct bfd_arch_info *info,\n   if (*string == 'C' || *string == 'c')\n     string++;\n   if (string[1] < '0' && string[1] > '9')\n-    return FALSE;\n+    return false;\n \n   if (*string == '3')\n     return (info->mach == bfd_mach_tic3x);\n   else if (*string == '4')\n     return info->mach == bfd_mach_tic4x;\n \n-  return FALSE;\n+  return false;\n }\n \n #define N(NUMBER, NAME, PRINT, DEFAULT, NEXT)\t\t\\\n@@ -64,7 +64,7 @@ tic4x_scan (const struct bfd_arch_info *info,\n   }\n \n const bfd_arch_info_type bfd_tic3x_arch =\n-  N (bfd_mach_tic3x, \"tic3x\", \"tms320c3x\", FALSE, NULL);\n+  N (bfd_mach_tic3x, \"tic3x\", \"tms320c3x\", false, NULL);\n \n const bfd_arch_info_type bfd_tic4x_arch =\n-  N (bfd_mach_tic4x, \"tic4x\", \"tms320c4x\", TRUE, &bfd_tic3x_arch);\n+  N (bfd_mach_tic4x, \"tic4x\", \"tms320c4x\", true, &bfd_tic3x_arch);"
    },
    {
      "sha": "f2decc2499063c0d10e06c01b1e567c717e0e08d",
      "filename": "bfd/cpu-tic54x.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tic54x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tic54x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-tic54x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_tic54x_arch =\n   \"tic54x\",\n   \"tms320c54x\",\n   1,\n-  TRUE,\t\t\t\t/* The one and only.  */\n+  true,\t\t\t\t/* The one and only.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "4440a3f951857758d0443ca9fcc3d4f3c5439ae2",
      "filename": "bfd/cpu-tic6x.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-tic6x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_tic6x_arch =\n   \"tic6x\", /* Architecture name.  */\n   \"tic6x\", /* Printable name.  */\n   2, /* Section alignment power.  */\n-  TRUE, /* Default machine for this architecture.  */\n+  true, /* Default machine for this architecture.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "c71591557cd31a2e766c4b81f55c67a7259243d3",
      "filename": "bfd/cpu-tilegx.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-tilegx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -41,8 +41,8 @@\n   }\n \n const bfd_arch_info_type bfd_tilegx32_arch =\n-  N (32, bfd_mach_tilegx32, \"tilegx32\", FALSE, NULL);\n+  N (32, bfd_mach_tilegx32, \"tilegx32\", false, NULL);\n \n const bfd_arch_info_type bfd_tilegx_arch =\n-  N (64, bfd_mach_tilegx, \"tilegx\", TRUE, &bfd_tilegx32_arch);\n+  N (64, bfd_mach_tilegx, \"tilegx\", true, &bfd_tilegx32_arch);\n "
    },
    {
      "sha": "37a1271a05a80071de50db4860479b5bcbdd40c7",
      "filename": "bfd/cpu-tilepro.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-tilepro.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_tilepro_arch =\n   \"tilepro\",\n   \"tilepro\",\n   3,\n-  TRUE,\n+  true,\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "c80a44eb29d641647ae16766e9ac025eec0eaf6f",
      "filename": "bfd/cpu-v850.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-v850.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-v850.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-v850.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -29,13 +29,13 @@\n \n static const bfd_arch_info_type arch_info_struct[6] =\n {\n-  N (bfd_mach_v850e3v5, \"v850e3v5\", FALSE, arch_info_struct + 1),\n-  N (bfd_mach_v850e3v5, \"v850e2v4\", FALSE, arch_info_struct + 2),\n-  N (bfd_mach_v850e2v3, \"v850e2v3\", FALSE, arch_info_struct + 3),\n-  N (bfd_mach_v850e2,\t\"v850e2\",   FALSE, arch_info_struct + 4),\n-  N (bfd_mach_v850e1,\t\"v850e1\",   FALSE, arch_info_struct + 5),\n-  N (bfd_mach_v850e,\t\"v850e\",    FALSE, NULL)\n+  N (bfd_mach_v850e3v5, \"v850e3v5\", false, arch_info_struct + 1),\n+  N (bfd_mach_v850e3v5, \"v850e2v4\", false, arch_info_struct + 2),\n+  N (bfd_mach_v850e2v3, \"v850e2v3\", false, arch_info_struct + 3),\n+  N (bfd_mach_v850e2,\t\"v850e2\",   false, arch_info_struct + 4),\n+  N (bfd_mach_v850e1,\t\"v850e1\",   false, arch_info_struct + 5),\n+  N (bfd_mach_v850e,\t\"v850e\",    false, NULL)\n };\n \n const bfd_arch_info_type bfd_v850_arch =\n-  N (bfd_mach_v850,     \"v850\",     TRUE,  arch_info_struct + 0);\n+  N (bfd_mach_v850,     \"v850\",     true,  arch_info_struct + 0);"
    },
    {
      "sha": "c31e9208c3454b8d5d2c6709f41f9bdb93de8dad",
      "filename": "bfd/cpu-v850_rh850.c",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-v850_rh850.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-v850_rh850.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-v850_rh850.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -29,14 +29,14 @@\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  R (bfd_mach_v850e3v5, \"v850e3v5\",\tFALSE, & arch_info_struct[1]),\n-  R (bfd_mach_v850e3v5, \"v850e2v4\",\tFALSE, & arch_info_struct[2]),\n-  R (bfd_mach_v850e2v3, \"v850e2v3\",\tFALSE, & arch_info_struct[3]),\n-  R (bfd_mach_v850e2,\t\"v850e2\",\tFALSE, & arch_info_struct[4]),\n-  R (bfd_mach_v850e1,\t\"v850e1\",\tFALSE, & arch_info_struct[5]),\n-  R (bfd_mach_v850e,\t\"v850e\",\tFALSE, & arch_info_struct[6]),\n-  R (bfd_mach_v850,\t\"v850-rh850\",\tFALSE, NULL) /* For backwards compatibility.  */\n+  R (bfd_mach_v850e3v5, \"v850e3v5\",\tfalse, & arch_info_struct[1]),\n+  R (bfd_mach_v850e3v5, \"v850e2v4\",\tfalse, & arch_info_struct[2]),\n+  R (bfd_mach_v850e2v3, \"v850e2v3\",\tfalse, & arch_info_struct[3]),\n+  R (bfd_mach_v850e2,\t\"v850e2\",\tfalse, & arch_info_struct[4]),\n+  R (bfd_mach_v850e1,\t\"v850e1\",\tfalse, & arch_info_struct[5]),\n+  R (bfd_mach_v850e,\t\"v850e\",\tfalse, & arch_info_struct[6]),\n+  R (bfd_mach_v850,\t\"v850-rh850\",\tfalse, NULL) /* For backwards compatibility.  */\n };\n \n const bfd_arch_info_type bfd_v850_rh850_arch =\n-  R (bfd_mach_v850,\t\"v850:rh850\",\tTRUE,  & arch_info_struct[0]);\n+  R (bfd_mach_v850,\t\"v850:rh850\",\ttrue,  & arch_info_struct[0]);"
    },
    {
      "sha": "71c5b676579008ab216c279846aed20e30d3787a",
      "filename": "bfd/cpu-vax.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-vax.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-vax.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-vax.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_vax_arch =\n   \"vax\",\n   \"vax\",\n   3,\n-  TRUE, /* The one and only.  */\n+  true, /* The one and only.  */\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "11135305de92d3e2988c679faa07aa2736a2961f",
      "filename": "bfd/cpu-visium.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-visium.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-visium.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-visium.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -33,7 +33,7 @@ const bfd_arch_info_type bfd_visium_arch =\n   \"visium\",\t\t\t/* Architecture name.  */\n   \"visium\",\t\t\t/* Machine name.  */\n   2,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* The default ?  */\n+  true,\t\t\t\t/* The default ?  */\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "d698654248f24e9594482af436f83ab5bb7b01d7",
      "filename": "bfd/cpu-wasm32.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-wasm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-wasm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-wasm32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -29,8 +29,8 @@\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (bfd_mach_wasm32, \"wasm32\", TRUE, NULL)\n+  N (bfd_mach_wasm32, \"wasm32\", true, NULL)\n };\n \n const bfd_arch_info_type bfd_wasm32_arch =\n-  N (bfd_mach_wasm32, \"wasm32\", TRUE, & arch_info_struct[0]);\n+  N (bfd_mach_wasm32, \"wasm32\", true, & arch_info_struct[0]);"
    },
    {
      "sha": "6e0243373605384c361dca732897dfbe76de6422",
      "filename": "bfd/cpu-xc16x.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-xc16x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-xc16x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-xc16x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -43,11 +43,11 @@\n   }\n \n const bfd_arch_info_type xc16xs_info_struct =\n-  N (16, bfd_mach_xc16xs, \"xc16xs\", FALSE, NULL);\n+  N (16, bfd_mach_xc16xs, \"xc16xs\", false, NULL);\n \n const bfd_arch_info_type xc16xl_info_struct =\n-  N (32, bfd_mach_xc16xl, \"xc16xl\", FALSE, & xc16xs_info_struct);\n+  N (32, bfd_mach_xc16xl, \"xc16xl\", false, & xc16xs_info_struct);\n \n const bfd_arch_info_type bfd_xc16x_arch =\n-  N (16, bfd_mach_xc16x, \"xc16x\", TRUE, & xc16xl_info_struct);\n+  N (16, bfd_mach_xc16x, \"xc16x\", true, & xc16xl_info_struct);\n "
    },
    {
      "sha": "379bb30b8061226700ff9b55ec232b0a8e809d53",
      "filename": "bfd/cpu-xgate.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-xgate.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-xgate.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-xgate.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_xgate_arch =\n   \"xgate\",\n   \"xgate\",\n   4,\t/* Section alignment power.  */\n-  TRUE,\n+  true,\n   bfd_default_compatible,\n   bfd_default_scan,\n   bfd_arch_default_fill,"
    },
    {
      "sha": "eed7d4bba542a48349796d4c90f30678d7745d1c",
      "filename": "bfd/cpu-xstormy16.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-xstormy16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-xstormy16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-xstormy16.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_xstormy16_arch =\n   \"xstormy16\",\t\t\t/* Architecture name.  */\n   \"xstormy16\",\t\t\t/* Printable name.  */\n   2,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* The default ?  */\n+  true,\t\t\t\t/* The default ?  */\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "4307c6b7ccd736c409d033dda55b8a4268596403",
      "filename": "bfd/cpu-xtensa.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-xtensa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-xtensa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-xtensa.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -32,7 +32,7 @@ const bfd_arch_info_type bfd_xtensa_arch =\n   \"xtensa\",\t\t\t/* Architecture name.  */\n   \"xtensa\",\t\t\t/* Printable name.  */\n   4,\t\t\t\t/* Section align power.  */\n-  TRUE,\t\t\t\t/* The default?  */\n+  true,\t\t\t\t/* The default?  */\n   bfd_default_compatible,\t/* Architecture comparison fn.  */\n   bfd_default_scan,\t\t/* String to architecture convert fn.  */\n   bfd_arch_default_fill,\t/* Default fill.  */"
    },
    {
      "sha": "a9a44352f8e3a81d0e749e3a74615f2169c718e7",
      "filename": "bfd/cpu-z80.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-z80.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-z80.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-z80.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -106,16 +106,16 @@ compatible (const bfd_arch_info_type *a, const bfd_arch_info_type *b)\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  N (bfd_mach_z80,\t \"z80\",        16, TRUE,  M(1)),\n-  N (bfd_mach_z80strict, \"z80-strict\", 16, FALSE, M(2)),\n-  N (bfd_mach_z80full,\t \"z80-full\",   16, FALSE, M(3)),\n-  N (bfd_mach_r800,\t \"r800\",       16, FALSE, M(4)),\n-  N (bfd_mach_gbz80,\t \"gbz80\",      16, FALSE, M(5)),\n-  N (bfd_mach_z180,\t \"z180\",       16, FALSE, M(6)),\n-  N (bfd_mach_z80n,\t \"z80n\",       16, FALSE, M(7)),\n-  N (bfd_mach_ez80_z80,\t \"ez80-z80\",   16, FALSE, M(8)),\n-  N (bfd_mach_ez80_adl,\t \"ez80-adl\",   24, FALSE, NULL)\n+  N (bfd_mach_z80,\t \"z80\",        16, true,  M(1)),\n+  N (bfd_mach_z80strict, \"z80-strict\", 16, false, M(2)),\n+  N (bfd_mach_z80full,\t \"z80-full\",   16, false, M(3)),\n+  N (bfd_mach_r800,\t \"r800\",       16, false, M(4)),\n+  N (bfd_mach_gbz80,\t \"gbz80\",      16, false, M(5)),\n+  N (bfd_mach_z180,\t \"z180\",       16, false, M(6)),\n+  N (bfd_mach_z80n,\t \"z80n\",       16, false, M(7)),\n+  N (bfd_mach_ez80_z80,\t \"ez80-z80\",   16, false, M(8)),\n+  N (bfd_mach_ez80_adl,\t \"ez80-adl\",   24, false, NULL)\n };\n \n const bfd_arch_info_type bfd_z80_arch =\n-  N (bfd_mach_z80,   \"z80\",   16, TRUE,  M(1));\n+  N (bfd_mach_z80,   \"z80\",   16, true,  M(1));"
    },
    {
      "sha": "8090a3023e842d517772806db1131e6a717c74f9",
      "filename": "bfd/cpu-z8k.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-z8k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/cpu-z8k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/cpu-z8k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -36,13 +36,13 @@ compatible (const bfd_arch_info_type *a, const bfd_arch_info_type *b)\n \n static const bfd_arch_info_type arch_info_struct[] =\n {\n-  { 32, 16, 8, bfd_arch_z8k, bfd_mach_z8002, \"z8k\", \"z8002\", 1, FALSE,\n+  { 32, 16, 8, bfd_arch_z8k, bfd_mach_z8002, \"z8k\", \"z8002\", 1, false,\n     compatible, bfd_default_scan, bfd_arch_default_fill, NULL, 0 }\n };\n \n const bfd_arch_info_type bfd_z8k_arch =\n {\n-  32, 32, 8, bfd_arch_z8k, bfd_mach_z8001, \"z8k\", \"z8001\", 1, TRUE,\n+  32, 32, 8, bfd_arch_z8k, bfd_mach_z8001, \"z8k\", \"z8001\", 1, true,\n   compatible, bfd_default_scan, bfd_arch_default_fill,\n   &arch_info_struct[0], 0\n };"
    },
    {
      "sha": "f1c4e7ec48cb3cdd0b9fa28690e931ebe10f1154",
      "filename": "bfd/dwarf1.c",
      "status": "modified",
      "additions": 32,
      "deletions": 32,
      "changes": 64,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/dwarf1.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/dwarf1.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf1.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af",
      "patch": "@@ -177,7 +177,7 @@ alloc_dwarf1_func (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n \n    Return FALSE if the die is invalidly formatted; TRUE otherwise.  */\n \n-static bfd_boolean\n+static bool\n parse_die (bfd *\t     abfd,\n \t   struct die_info * aDieInfo,\n \t   bfd_byte *\t     aDiePtr,\n@@ -190,23 +190,23 @@ parse_die (bfd *\t     abfd,\n \n   /* First comes the length.  */\n   if (xptr + 4 > aDiePtrEnd)\n-    return FALSE;\n+    return false;\n   aDieInfo->length = bfd_get_32 (abfd, xptr);\n   xptr += 4;\n   if (aDieInfo->length == 0\n       || this_die + aDieInfo->length > aDiePtrEnd)\n-    return FALSE;\n+    return false;\n   aDiePtrEnd = this_die + aDieInfo->length;\n   if (aDieInfo->length < 6)\n     {\n       /* Just padding bytes.  */\n       aDieInfo->tag = TAG_padding;\n-      return TRUE;\n+      return true;\n     }\n \n   /* Then the tag.  */\n   if (xptr + 2 > aDiePtrEnd)\n-    return FALSE;\n+    return false;\n   aDieInfo->tag = bfd_get_16 (abfd, xptr);\n   xptr += 2;\n \n@@ -260,7 +260,7 @@ parse_die (bfd *\t     abfd,\n \t      block_len = bfd_get_16 (abfd, xptr);\n \t      if (xptr + block_len > aDiePtrEnd\n \t\t  || xptr + block_len < xptr)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      xptr += block_len;\n \t    }\n \t  xptr += 2;\n@@ -271,7 +271,7 @@ parse_die (bfd *\t     abfd,\n \t      block_len = bfd_get_32 (abfd, xptr);\n \t      if (xptr + block_len > aDiePtrEnd\n \t\t  || xptr + block_len < xptr)\n-\t\treturn FALSE;\n+\t\treturn false;\n \t      xptr += block_len;\n \t    }\n \t  xptr += 4;\n@@ -284,14 +284,14 @@ parse_die (bfd *\t     abfd,\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Parse a dwarf1 line number table for 'aUnit->stmt_list_offset'\n    into 'aUnit->linenumber_table'.  Return FALSE if an error\n    occurs; TRUE otherwise.  */\n \n-static bfd_boolean\n+static bool\n parse_line_table (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n {\n   bfd_byte *xptr;\n@@ -304,15 +304,15 @@ parse_line_table (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n \n       msec = bfd_get_section_by_name (stash->abfd, \".line\");\n       if (! msec)\n-\treturn FALSE;\n+\treturn false;\n \n       size = msec->rawsize ? msec->rawsize : msec->size;\n       stash->line_section\n \t= bfd_simple_get_relocated_section_contents\n \t(stash->abfd, msec, NULL, stash->syms);\n \n       if (! stash->line_section)\n-\treturn FALSE;\n+\treturn false;\n \n       stash->line_section_end = stash->line_section + size;\n     }\n@@ -342,7 +342,7 @@ parse_line_table (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n       aUnit->linenumber_table = (struct linenumber *) bfd_alloc (stash->abfd,\n \t\t\t\t\t\t\t\t amt);\n       if (!aUnit->linenumber_table)\n-\treturn FALSE;\n+\treturn false;\n \n       for (eachLine = 0; eachLine < aUnit->line_count; eachLine++)\n \t{\n@@ -366,15 +366,15 @@ parse_line_table (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n \t}\n     }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Parse each function die in a compilation unit 'aUnit'.\n    The first child die of 'aUnit' should be in 'aUnit->first_child',\n    the result is placed in 'aUnit->func_list'.\n    Return FALSE if error; TRUE otherwise.  */\n \n-static bfd_boolean\n+static bool\n parse_functions_in_unit (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n {\n   bfd_byte *eachDie;\n@@ -388,7 +388,7 @@ parse_functions_in_unit (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n \n \tif (! parse_die (stash->abfd, &eachDieInfo, eachDie,\n \t\t\t stash->debug_section_end))\n-\t  return FALSE;\n+\t  return false;\n \n \tif (eachDieInfo.tag == TAG_global_subroutine\n \t    || eachDieInfo.tag == TAG_subroutine\n@@ -397,7 +397,7 @@ parse_functions_in_unit (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n \t  {\n \t    struct dwarf1_func* aFunc = alloc_dwarf1_func (stash,aUnit);\n \t    if (!aFunc)\n-\t      return FALSE;\n+\t      return false;\n \n \t    aFunc->name = eachDieInfo.name;\n \t    aFunc->low_pc = eachDieInfo.low_pc;\n@@ -411,22 +411,22 @@ parse_functions_in_unit (struct dwarf1_debug* stash, struct dwarf1_unit* aUnit)\n \t  break;\n       }\n \n-  return TRUE;\n+  return true;\n }\n \n /* Find the nearest line to 'addr' in 'aUnit'.\n    Return whether we found the line (or a function) without error.  */\n \n-static bfd_boolean\n+static bool\n dwarf1_unit_find_nearest_line (struct dwarf1_debug* stash,\n \t\t\t       struct dwarf1_unit* aUnit,\n \t\t\t       unsigned long addr,\n \t\t\t       const char **filename_ptr,\n \t\t\t       const char **functionname_ptr,\n \t\t\t       unsigned int *linenumber_ptr)\n {\n-  int line_p = FALSE;\n-  int func_p = FALSE;\n+  int line_p = false;\n+  int func_p = false;\n \n   if (aUnit->low_pc <= addr && addr < aUnit->high_pc)\n     {\n@@ -438,13 +438,13 @@ dwarf1_unit_find_nearest_line (struct dwarf1_debug* stash,\n \t  if (! aUnit->linenumber_table)\n \t    {\n \t      if (! parse_line_table (stash, aUnit))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \n \t  if (! aUnit->func_list)\n \t    {\n \t      if (! parse_functions_in_unit (stash, aUnit))\n-\t\treturn FALSE;\n+\t\treturn false;\n \t    }\n \n \t  for (i = 0; i < aUnit->line_count; i++)\n@@ -454,7 +454,7 @@ dwarf1_unit_find_nearest_line (struct dwarf1_debug* stash,\n \t\t{\n \t\t  *filename_ptr = aUnit->name;\n \t\t  *linenumber_ptr = aUnit->linenumber_table[i].linenumber;\n-\t\t  line_p = TRUE;\n+\t\t  line_p = true;\n \t\t  break;\n \t\t}\n \t    }\n@@ -467,7 +467,7 @@ dwarf1_unit_find_nearest_line (struct dwarf1_debug* stash,\n \t\t  && addr < eachFunc->high_pc)\n \t\t{\n \t\t  *functionname_ptr = eachFunc->name;\n-\t\t  func_p = TRUE;\n+\t\t  func_p = true;\n \t\t  break;\n \t\t}\n \t    }\n@@ -480,7 +480,7 @@ dwarf1_unit_find_nearest_line (struct dwarf1_debug* stash,\n /* The DWARF 1 version of find_nearest line.\n    Return TRUE if the line is found without error.  */\n \n-bfd_boolean\n+bool\n _bfd_dwarf1_find_nearest_line (bfd *abfd,\n \t\t\t       asymbol **symbols,\n \t\t\t       asection *section,\n@@ -509,22 +509,22 @@ _bfd_dwarf1_find_nearest_line (bfd *abfd,\n \t= (struct dwarf1_debug *) bfd_zalloc (abfd, size);\n \n       if (! stash)\n-\treturn FALSE;\n+\treturn false;\n \n       msec = bfd_get_section_by_name (abfd, \".debug\");\n       if (! msec)\n \t/* No dwarf1 info.  Note that at this point the stash\n \t   has been allocated, but contains zeros, this lets\n \t   future calls to this function fail quicker.  */\n-\treturn FALSE;\n+\treturn false;\n \n       size = msec->rawsize ? msec->rawsize : msec->size;\n       stash->debug_section\n \t= bfd_simple_get_relocated_section_contents (abfd, msec, NULL,\n \t\t\t\t\t\t     symbols);\n \n       if (! stash->debug_section)\n-\treturn FALSE;\n+\treturn false;\n \n       stash->debug_section_end = stash->debug_section + size;\n       stash->currentDie = stash->debug_section;\n@@ -536,7 +536,7 @@ _bfd_dwarf1_find_nearest_line (bfd *abfd,\n      or that an error occured while setting up the stash.  */\n \n   if (! stash->debug_section)\n-    return FALSE;\n+    return false;\n \n   /* Look at the previously parsed units to see if any contain\n      the addr.  */\n@@ -553,14 +553,14 @@ _bfd_dwarf1_find_nearest_line (bfd *abfd,\n \n       if (! parse_die (stash->abfd, &aDieInfo, stash->currentDie,\n \t\t       stash->debug_section_end))\n-\treturn FALSE;\n+\treturn false;\n \n       if (aDieInfo.tag == TAG_compile_unit)\n \t{\n \t  struct dwarf1_unit* aUnit\n \t    = alloc_dwarf1_unit (stash);\n \t  if (!aUnit)\n-\t    return FALSE;\n+\t    return false;\n \n \t  aUnit->name = aDieInfo.name;\n \t  aUnit->low_pc = aDieInfo.low_pc;\n@@ -592,5 +592,5 @@ _bfd_dwarf1_find_nearest_line (bfd *abfd,\n \tstash->currentDie += aDieInfo.length;\n     }\n \n-  return FALSE;\n+  return false;\n }"
    },
    {
      "sha": "0a8a5578da8b64d306a0393b1b86cd86fc71af12",
      "filename": "bfd/dwarf2.c",
      "status": "modified",
      "additions": 0,
      "deletions": 0,
      "changes": 0,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/dwarf2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/dwarf2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/dwarf2.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e7ee52174712875d3a72976f35dadcbcb00f5d39",
      "filename": "bfd/ecoff-bfd.h",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ecoff-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ecoff-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ecoff-bfd.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "f09fc1dd0a6b46e49af16e3033daa7ca0bd7aa23",
      "filename": "bfd/ecoff.c",
      "status": "modified",
      "additions": 191,
      "deletions": 191,
      "changes": 382,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ecoff.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ecoff.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ecoff.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "9f72409d6b16ab175ba0af3579cc962f067ab513",
      "filename": "bfd/ecofflink.c",
      "status": "modified",
      "additions": 109,
      "deletions": 109,
      "changes": 218,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ecofflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ecofflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ecofflink.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "a7a76a2fd0e0a9fe68ba6bc41b97f14047d8421a",
      "filename": "bfd/elf-attrs.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-attrs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-attrs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-attrs.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "101c2fdf50d040eb95db841254e0b5794a8e541e",
      "filename": "bfd/elf-bfd.h",
      "status": "modified",
      "additions": 241,
      "deletions": 243,
      "changes": 484,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-bfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-bfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-bfd.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "6ce6d225cff3a7e198d0655ac3aabcd964fffe7a",
      "filename": "bfd/elf-eh-frame.c",
      "status": "modified",
      "additions": 102,
      "deletions": 102,
      "changes": 204,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-eh-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-eh-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-eh-frame.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "1e15b174da0d6d15eb30484ae387fa05c61434c7",
      "filename": "bfd/elf-hppa.h",
      "status": "modified",
      "additions": 262,
      "deletions": 262,
      "changes": 524,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-hppa.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-hppa.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-hppa.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "7f7d31d3ff96b83d5ebae992ea94b9ab3f3a5af8",
      "filename": "bfd/elf-ifunc.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-ifunc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-ifunc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-ifunc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "9c1e4eb70fc5d4ddceccf00d71d1c7da3823709f",
      "filename": "bfd/elf-m10200.c",
      "status": "modified",
      "additions": 52,
      "deletions": 52,
      "changes": 104,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-m10200.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-m10200.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-m10200.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "fadd9ab0e82c0a9fd9a3486c2f3d24091e5f58e8",
      "filename": "bfd/elf-m10300.c",
      "status": "modified",
      "additions": 224,
      "deletions": 224,
      "changes": 448,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-m10300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-m10300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-m10300.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "481f9a94b3f0b4af43b952acac04031fa5ab9f86",
      "filename": "bfd/elf-nacl.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-nacl.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-nacl.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-nacl.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "774f51c58a8b9c29438d7ea38fa572c19a2c25da",
      "filename": "bfd/elf-nacl.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-nacl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-nacl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-nacl.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "25b9a40f63002091f56750b53474583e771191e0",
      "filename": "bfd/elf-properties.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-properties.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-properties.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-properties.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "78a886cb8d7c7636c09f5c85a7b599b5cba32914",
      "filename": "bfd/elf-s390-common.c",
      "status": "modified",
      "additions": 24,
      "deletions": 24,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-s390-common.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-s390-common.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-s390-common.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "4cc6c108e7b72de7686bc9a6a08ffb02ebba26ae",
      "filename": "bfd/elf-s390.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-s390.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-s390.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-s390.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "39eab6be42ea951e0b1472074403bdbb37a53ca9",
      "filename": "bfd/elf-strtab.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-strtab.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-strtab.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-strtab.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "6ecce6d927eb0c33143d65534cdcb23a4eb457bd",
      "filename": "bfd/elf-vxworks.c",
      "status": "modified",
      "additions": 19,
      "deletions": 19,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-vxworks.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-vxworks.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-vxworks.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e9fbe5e0d1e97ad9f16dabaebcf9450d8d018bc6",
      "filename": "bfd/elf-vxworks.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-vxworks.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf-vxworks.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf-vxworks.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "697d1ee72820b21c1d586d3fac3bf04fa9ac1643",
      "filename": "bfd/elf.c",
      "status": "modified",
      "additions": 627,
      "deletions": 627,
      "changes": 1254,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "d260768b3b299bfb43b2fd84aa73fd2dbe90217b",
      "filename": "bfd/elf32-am33lin.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-am33lin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-am33lin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-am33lin.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "d201d5a8c46a8ce3bf6c7c62da4ee4f5c66b9502",
      "filename": "bfd/elf32-arc.c",
      "status": "modified",
      "additions": 153,
      "deletions": 153,
      "changes": 306,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-arc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-arc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "51a65d89a846da67561ee0827aa11d4b8873260c",
      "filename": "bfd/elf32-arm.c",
      "status": "modified",
      "additions": 966,
      "deletions": 966,
      "changes": 1932,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c8f43223e474edfaae1d57cf6327abb5c1d76296",
      "filename": "bfd/elf32-arm.h",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-arm.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-arm.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-arm.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "4d1ab54778a0fbe391ee95c59144bde1b80b0bc7",
      "filename": "bfd/elf32-avr.c",
      "status": "modified",
      "additions": 217,
      "deletions": 220,
      "changes": 437,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-avr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-avr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-avr.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "3942adf448b68ed627d912685dae80c38a61238e",
      "filename": "bfd/elf32-avr.h",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-avr.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-avr.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-avr.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "931041227837312e17abd4f30727d170d1fbc137",
      "filename": "bfd/elf32-bfin.c",
      "status": "modified",
      "additions": 274,
      "deletions": 274,
      "changes": 548,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-bfin.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-bfin.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-bfin.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "4938cae4d5b68d1f8745e8581bb30f51a62e6169",
      "filename": "bfd/elf32-bfin.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-bfin.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-bfin.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-bfin.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "2a1c8be624e4ee2902df81caab209633d7761da0",
      "filename": "bfd/elf32-cr16.c",
      "status": "modified",
      "additions": 162,
      "deletions": 162,
      "changes": 324,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-cr16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-cr16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-cr16.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5a22d3acb1bcb202881e23945c4d8597b738e352",
      "filename": "bfd/elf32-cr16.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-cr16.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-cr16.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-cr16.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "7381c77c5958136931a77e6cbf8f2ae32c3fe83e",
      "filename": "bfd/elf32-cris.c",
      "status": "modified",
      "additions": 179,
      "deletions": 179,
      "changes": 358,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-cris.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-cris.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-cris.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "44c21df71b7c4918b1838c220222dfed7ff082bb",
      "filename": "bfd/elf32-crx.c",
      "status": "modified",
      "additions": 88,
      "deletions": 88,
      "changes": 176,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-crx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-crx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-crx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "1dee29a7b4a3ef4e924085485777f63e1cb91a75",
      "filename": "bfd/elf32-csky.c",
      "status": "modified",
      "additions": 318,
      "deletions": 318,
      "changes": 636,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-csky.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-csky.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-csky.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "7f7e2c8384ad13f96a7da7afba319484b27ef96a",
      "filename": "bfd/elf32-csky.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-csky.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-csky.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-csky.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "50fdeeb2294504b8de67262723782b7f0defff59",
      "filename": "bfd/elf32-d10v.c",
      "status": "modified",
      "additions": 38,
      "deletions": 38,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-d10v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-d10v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-d10v.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ede07b9ce57e0622bf2003288b76c64cafe32a6b",
      "filename": "bfd/elf32-d30v.c",
      "status": "modified",
      "additions": 45,
      "deletions": 45,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-d30v.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-d30v.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-d30v.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "2d7114b74830685806fae3f518606e0bdf689e75",
      "filename": "bfd/elf32-dlx.c",
      "status": "modified",
      "additions": 38,
      "deletions": 38,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-dlx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-dlx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-dlx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "6de4211546be8fccc39b842b62c6f46ab989f44b",
      "filename": "bfd/elf32-epiphany.c",
      "status": "modified",
      "additions": 41,
      "deletions": 41,
      "changes": 82,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-epiphany.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-epiphany.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-epiphany.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "7ee83cab9b6e84ac5c93487139b15f63410f5614",
      "filename": "bfd/elf32-fr30.c",
      "status": "modified",
      "additions": 50,
      "deletions": 50,
      "changes": 100,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-fr30.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-fr30.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-fr30.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "cf0980cd261eb16c119fb656f3c4581745bc78c9",
      "filename": "bfd/elf32-frv.c",
      "status": "modified",
      "additions": 320,
      "deletions": 321,
      "changes": 641,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-frv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-frv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-frv.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c3c393e34805478ce61ccd497385c6f7e86ac59a",
      "filename": "bfd/elf32-ft32.c",
      "status": "modified",
      "additions": 99,
      "deletions": 100,
      "changes": 199,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-ft32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-ft32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ft32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "27635059dffc6e0cc398dc756cd0571e0146fb4a",
      "filename": "bfd/elf32-gen.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-gen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-gen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-gen.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "a69ac0cbdbbded3de98b9e8d141f7635212446e6",
      "filename": "bfd/elf32-h8300.c",
      "status": "modified",
      "additions": 81,
      "deletions": 81,
      "changes": 162,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-h8300.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-h8300.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-h8300.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "22a4625b842ea3a2d804aad0649f092ff5eb2c12",
      "filename": "bfd/elf32-hppa.c",
      "status": "modified",
      "additions": 139,
      "deletions": 139,
      "changes": 278,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-hppa.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "79327e845e9decaad7c1cefd0fff8fd6bf8daf49",
      "filename": "bfd/elf32-hppa.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-hppa.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-hppa.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-hppa.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "377e76d0f3dc1327295c3f1339cffdaa8e79ae81",
      "filename": "bfd/elf32-i386.c",
      "status": "modified",
      "additions": 219,
      "deletions": 219,
      "changes": 438,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-i386.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "fb72756b1cd7d1be95c9efcc21adb8af5223995d",
      "filename": "bfd/elf32-ip2k.c",
      "status": "modified",
      "additions": 82,
      "deletions": 82,
      "changes": 164,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-ip2k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-ip2k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ip2k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5291a5469284e115665f0c99e70d1587d6e42489",
      "filename": "bfd/elf32-iq2000.c",
      "status": "modified",
      "additions": 65,
      "deletions": 65,
      "changes": 130,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-iq2000.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-iq2000.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-iq2000.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "be8d41632c170223c3e35878578de73725a81194",
      "filename": "bfd/elf32-lm32.c",
      "status": "modified",
      "additions": 149,
      "deletions": 149,
      "changes": 298,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-lm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-lm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-lm32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "6f7be5461011c228f166f56fe05eebf3ffa01d8a",
      "filename": "bfd/elf32-m32c.c",
      "status": "modified",
      "additions": 105,
      "deletions": 107,
      "changes": 212,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m32c.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m32c.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32c.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "783632b65186dcd5f1d8b8988075d8954520c8eb",
      "filename": "bfd/elf32-m32r.c",
      "status": "modified",
      "additions": 238,
      "deletions": 238,
      "changes": 476,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m32r.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m32r.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m32r.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "52da17427faf21f62aa723158ab2673e458749f5",
      "filename": "bfd/elf32-m68hc11.c",
      "status": "modified",
      "additions": 71,
      "deletions": 71,
      "changes": 142,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68hc11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68hc11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68hc11.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c6e40d27dd9958daf8d6fffbe190535c9d3d658e",
      "filename": "bfd/elf32-m68hc12.c",
      "status": "modified",
      "additions": 74,
      "deletions": 74,
      "changes": 148,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68hc12.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68hc12.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68hc12.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "d000404e26fe9cfe09c2969e14a32ff663129439",
      "filename": "bfd/elf32-m68hc1x.c",
      "status": "modified",
      "additions": 79,
      "deletions": 79,
      "changes": 158,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68hc1x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68hc1x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68hc1x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ee6987f128ad930e018064a4134fbfabd04e3d34",
      "filename": "bfd/elf32-m68hc1x.h",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68hc1x.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68hc1x.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68hc1x.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "3b4565c5b2047464cbd338bb44462d0914900ad2",
      "filename": "bfd/elf32-m68k.c",
      "status": "modified",
      "additions": 227,
      "deletions": 227,
      "changes": 454,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "1c42f5b38024d52fd69a51b4d4a9b9ce392eb176",
      "filename": "bfd/elf32-m68k.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68k.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-m68k.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-m68k.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "286e2fdbfa6b5f2113d6432f6b853371204566f2",
      "filename": "bfd/elf32-mcore.c",
      "status": "modified",
      "additions": 51,
      "deletions": 51,
      "changes": 102,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-mcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-mcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-mcore.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e8240e8cf18c59f5cf22647efca82839101efd2f",
      "filename": "bfd/elf32-mep.c",
      "status": "modified",
      "additions": 28,
      "deletions": 28,
      "changes": 56,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-mep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-mep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-mep.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "82e67eac99a752f8dd6ad51ae253e4a7b4d199b8",
      "filename": "bfd/elf32-metag.c",
      "status": "modified",
      "additions": 210,
      "deletions": 210,
      "changes": 420,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-metag.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-metag.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-metag.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ade56d4f3b00cadc2d739ba09a013b54818a1e08",
      "filename": "bfd/elf32-metag.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-metag.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-metag.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-metag.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "b5868580967483fee78d1157f0159d5a4e2085ac",
      "filename": "bfd/elf32-microblaze.c",
      "status": "modified",
      "additions": 190,
      "deletions": 190,
      "changes": 380,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-microblaze.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-microblaze.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-microblaze.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "1e645c66787651bdb35a8ac42c5b9d92ff59f3bd",
      "filename": "bfd/elf32-mips.c",
      "status": "modified",
      "additions": 352,
      "deletions": 352,
      "changes": 704,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-mips.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "2b00b2614b3687e874a733d09f091629d59858f6",
      "filename": "bfd/elf32-moxie.c",
      "status": "modified",
      "additions": 18,
      "deletions": 18,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-moxie.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-moxie.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-moxie.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c2560b16d48ebbf371e7fc0b5c72003d6a4cdf99",
      "filename": "bfd/elf32-msp430.c",
      "status": "modified",
      "additions": 168,
      "deletions": 168,
      "changes": 336,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-msp430.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-msp430.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-msp430.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "f5b08194bdd0888b406dc8353a17527ea22eb44a",
      "filename": "bfd/elf32-mt.c",
      "status": "modified",
      "additions": 62,
      "deletions": 64,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-mt.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-mt.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-mt.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "31a3ca02925a04fd64c3f0f909a0052c8aa539d0",
      "filename": "bfd/elf32-nds32.c",
      "status": "modified",
      "additions": 805,
      "deletions": 805,
      "changes": 1610,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-nds32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-nds32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nds32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5fb2e5dddf6d5eb2cf7b01fc2de8285a7495403b",
      "filename": "bfd/elf32-nios2.c",
      "status": "modified",
      "additions": 446,
      "deletions": 446,
      "changes": 892,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-nios2.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-nios2.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nios2.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "4961e87cf996f53992316f583dcf455a1b9d3b6b",
      "filename": "bfd/elf32-nios2.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-nios2.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-nios2.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-nios2.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "cd4398da86246e264d69dae89f6369fecefe3ac5",
      "filename": "bfd/elf32-or1k.c",
      "status": "modified",
      "additions": 255,
      "deletions": 255,
      "changes": 510,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-or1k.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-or1k.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-or1k.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "165b61329b75a11236a1fae8fed4f0c609d41e38",
      "filename": "bfd/elf32-pj.c",
      "status": "modified",
      "additions": 31,
      "deletions": 31,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-pj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-pj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-pj.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "0ae7e0bcf6495423059add314000b44d0703ac41",
      "filename": "bfd/elf32-ppc.c",
      "status": "modified",
      "additions": 405,
      "deletions": 405,
      "changes": 810,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5e2ce2ac3ed3c1702b187418112c360efc6cf16a",
      "filename": "bfd/elf32-ppc.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-ppc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-ppc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-ppc.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e3001d5755862fb07172e7df3111a0d9ec836517",
      "filename": "bfd/elf32-pru.c",
      "status": "modified",
      "additions": 73,
      "deletions": 73,
      "changes": 146,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-pru.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-pru.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-pru.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "163966f1d6988e6e004b191368276b770f87f9f4",
      "filename": "bfd/elf32-rl78.c",
      "status": "modified",
      "additions": 158,
      "deletions": 159,
      "changes": 317,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-rl78.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-rl78.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rl78.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "95684d4d328b6357caebc69a532941390815d810",
      "filename": "bfd/elf32-rx.c",
      "status": "modified",
      "additions": 256,
      "deletions": 256,
      "changes": 512,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-rx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-rx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "22a23c50d241f1646f2f66a1c02600b1ef920e50",
      "filename": "bfd/elf32-s12z.c",
      "status": "modified",
      "additions": 30,
      "deletions": 30,
      "changes": 60,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-s12z.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-s12z.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-s12z.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "b79e283ce3864f448c1ac4962794b1051712f09a",
      "filename": "bfd/elf32-s390.c",
      "status": "modified",
      "additions": 204,
      "deletions": 204,
      "changes": 408,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-s390.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e8a7e6388afbc7188a0746138e1d940a4d1ec18a",
      "filename": "bfd/elf32-score.c",
      "status": "modified",
      "additions": 288,
      "deletions": 288,
      "changes": 576,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-score.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-score.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-score.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "156781ec068256ef1150344b6caddf80953dc4b9",
      "filename": "bfd/elf32-score.h",
      "status": "modified",
      "additions": 22,
      "deletions": 22,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-score.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-score.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-score.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "a6960c02c50afb304b35703b09e161adc97928d6",
      "filename": "bfd/elf32-score7.c",
      "status": "modified",
      "additions": 256,
      "deletions": 256,
      "changes": 512,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-score7.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-score7.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-score7.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "bf551bc7a6f7e28997a76dfcb59a60a4cb57baf6",
      "filename": "bfd/elf32-sh-relocs.h",
      "status": "modified",
      "additions": 165,
      "deletions": 165,
      "changes": 330,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-sh-relocs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-sh-relocs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh-relocs.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "dae248f50e65ba20d07bc50c9a8b96000a82b442",
      "filename": "bfd/elf32-sh.c",
      "status": "modified",
      "additions": 230,
      "deletions": 231,
      "changes": 461,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sh.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "33eee5446b5b616efbecc44b35eefce1cd1d4978",
      "filename": "bfd/elf32-sparc.c",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-sparc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5bffc1d8ada43b3f62255a417d0a0ca9ba4b83f5",
      "filename": "bfd/elf32-spu.c",
      "status": "modified",
      "additions": 318,
      "deletions": 318,
      "changes": 636,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-spu.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-spu.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-spu.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "321f46d47c9fb04fc9641bf7e816025d186b9d54",
      "filename": "bfd/elf32-spu.h",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-spu.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-spu.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-spu.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5754f3cb860145a27c79c7f3ae24bd36e47eb5e4",
      "filename": "bfd/elf32-tic6x.c",
      "status": "modified",
      "additions": 324,
      "deletions": 324,
      "changes": 648,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-tic6x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-tic6x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tic6x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c28923320afbef209638171d6c9222c23aabe052",
      "filename": "bfd/elf32-tic6x.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-tic6x.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-tic6x.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tic6x.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "d6da01a7739c628aae031bfbe5114cc113af15d8",
      "filename": "bfd/elf32-tilegx.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tilegx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "cf288b3052befdb8fade478b9e609b693f7e81eb",
      "filename": "bfd/elf32-tilepro.c",
      "status": "modified",
      "additions": 193,
      "deletions": 193,
      "changes": 386,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-tilepro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-tilepro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-tilepro.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "a74d713c228d69e014c68be1a21959c480f65e3f",
      "filename": "bfd/elf32-v850.c",
      "status": "modified",
      "additions": 317,
      "deletions": 317,
      "changes": 634,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-v850.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-v850.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-v850.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "34fa76eb79853a28787d01fe666b8793e2d35e1d",
      "filename": "bfd/elf32-v850.h",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-v850.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-v850.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-v850.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "406c02ac7c56b5f7cb61eaed102291b031eeef20",
      "filename": "bfd/elf32-vax.c",
      "status": "modified",
      "additions": 123,
      "deletions": 124,
      "changes": 247,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-vax.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-vax.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-vax.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "fd45dad4359a5db64439ddc232b29a71988354e6",
      "filename": "bfd/elf32-visium.c",
      "status": "modified",
      "additions": 75,
      "deletions": 75,
      "changes": 150,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-visium.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-visium.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-visium.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "641b52939589a6ccb7334f470c2f6f10be039c78",
      "filename": "bfd/elf32-wasm32.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-wasm32.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-wasm32.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-wasm32.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "98a8a1325d75ea3c4ad5294a2e87beb87afc5821",
      "filename": "bfd/elf32-xc16x.c",
      "status": "modified",
      "additions": 35,
      "deletions": 35,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-xc16x.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-xc16x.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-xc16x.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5156eb330282ad303ddf6538be980da3ae14f22f",
      "filename": "bfd/elf32-xgate.c",
      "status": "modified",
      "additions": 65,
      "deletions": 65,
      "changes": 130,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-xgate.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-xgate.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-xgate.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "f995b55a28108bda33b799ee9afa6ae957da7289",
      "filename": "bfd/elf32-xstormy16.c",
      "status": "modified",
      "additions": 80,
      "deletions": 80,
      "changes": 160,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-xstormy16.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-xstormy16.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-xstormy16.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "21894d171aca1c818465e0909781d6dfa08778c8",
      "filename": "bfd/elf32-xtensa.c",
      "status": "modified",
      "additions": 685,
      "deletions": 685,
      "changes": 1370,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-xtensa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-xtensa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-xtensa.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "1820d991651a159f107aec7abfcb6be8f43170cf",
      "filename": "bfd/elf32-z80.c",
      "status": "modified",
      "additions": 51,
      "deletions": 51,
      "changes": 102,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-z80.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf32-z80.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-z80.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "1f68f822f790846713dfd4fdf2bd132d17ee0737",
      "filename": "bfd/elf64-alpha.c",
      "status": "modified",
      "additions": 333,
      "deletions": 333,
      "changes": 666,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-alpha.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-alpha.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-alpha.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "28c1543c0b696bf2be83575cbd8e4750640075e2",
      "filename": "bfd/elf64-bpf.c",
      "status": "modified",
      "additions": 53,
      "deletions": 53,
      "changes": 106,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-bpf.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-bpf.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-bpf.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "342737d1b235346cdd9acf7c3c959f6034312484",
      "filename": "bfd/elf64-gen.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-gen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-gen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-gen.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "7d9ebf8ffe25b6c42aaf8d54648b50ff1c231b97",
      "filename": "bfd/elf64-hppa.c",
      "status": "modified",
      "additions": 181,
      "deletions": 181,
      "changes": 362,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-hppa.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-hppa.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-hppa.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "3353f511546a369729bdd3bb723fc32c333deb06",
      "filename": "bfd/elf64-ia64-vms.c",
      "status": "modified",
      "additions": 280,
      "deletions": 280,
      "changes": 560,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-ia64-vms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-ia64-vms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ia64-vms.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "876e4f867c291e309581f16f0b8f0c6b82f630cc",
      "filename": "bfd/elf64-mips.c",
      "status": "modified",
      "additions": 663,
      "deletions": 663,
      "changes": 1326,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-mips.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c72e18261ef9b7e75c0d8a9590526c0b4796380b",
      "filename": "bfd/elf64-mmix.c",
      "status": "modified",
      "additions": 187,
      "deletions": 187,
      "changes": 374,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-mmix.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-mmix.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-mmix.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "b596df9f95252edb03b8c4fd94da1b78d7ebf137",
      "filename": "bfd/elf64-nfp.c",
      "status": "modified",
      "additions": 63,
      "deletions": 63,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-nfp.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-nfp.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-nfp.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "bc8dc4df1a5a3c9e5a43af14e054d5bbc2ddf4b3",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 713,
      "deletions": 713,
      "changes": 1426,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ce056e1b688d3dea9dfd258f89d04609915177a9",
      "filename": "bfd/elf64-ppc.h",
      "status": "modified",
      "additions": 13,
      "deletions": 13,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-ppc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-ppc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ff7ea7c35f403087024aafd830d910d297b03f2c",
      "filename": "bfd/elf64-s390.c",
      "status": "modified",
      "additions": 232,
      "deletions": 232,
      "changes": 464,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-s390.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-s390.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-s390.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "035ebdd45ce6139820d95c3e4dbbc352eaf4c912",
      "filename": "bfd/elf64-sparc.c",
      "status": "modified",
      "additions": 47,
      "deletions": 47,
      "changes": 94,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-sparc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "42811046c5774ba4eb89c1591e78e5ebbdf63e7c",
      "filename": "bfd/elf64-tilegx.c",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-tilegx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "3ac6159f3f0dd9eaf0c7b0c66cea21904ea706b8",
      "filename": "bfd/elf64-x86-64.c",
      "status": "modified",
      "additions": 316,
      "deletions": 316,
      "changes": 632,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elf64-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-x86-64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "7eb27c2e16dcba32da8e0b0396fdd25c7be313d6",
      "filename": "bfd/elfcode.h",
      "status": "modified",
      "additions": 40,
      "deletions": 40,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfcode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfcode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfcode.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c0cdceba42a4f7d03514bebb210190b18ada2a74",
      "filename": "bfd/elfcore.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfcore.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfcore.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfcore.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ce1407fa2dcc1b2192b383d1fa322fe60ec2c8ad",
      "filename": "bfd/elflink.c",
      "status": "modified",
      "additions": 887,
      "deletions": 887,
      "changes": 1774,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elflink.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elflink.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elflink.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "dc607e776d1293fd855ff5854d45c3ccb94ee39f",
      "filename": "bfd/elfn32-mips.c",
      "status": "modified",
      "additions": 647,
      "deletions": 647,
      "changes": 1294,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfn32-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfn32-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfn32-mips.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e2b1de78789b42e685322b95f31891b6837db0d9",
      "filename": "bfd/elfnn-aarch64.c",
      "status": "modified",
      "additions": 632,
      "deletions": 632,
      "changes": 1264,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfnn-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfnn-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-aarch64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ceebe554a56037829150fba09526d3aecf9aca2d",
      "filename": "bfd/elfnn-ia64.c",
      "status": "modified",
      "additions": 241,
      "deletions": 240,
      "changes": 481,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfnn-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfnn-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-ia64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "51f9d756cd183ce5831d196f67f353564302e97c",
      "filename": "bfd/elfnn-riscv.c",
      "status": "modified",
      "additions": 260,
      "deletions": 260,
      "changes": 520,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfnn-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfnn-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfnn-riscv.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "70385a0ebda9b4888ba458a226dac140e1e3c9e6",
      "filename": "bfd/elfxx-aarch64.c",
      "status": "modified",
      "additions": 12,
      "deletions": 12,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-aarch64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c3a3a55190d848ba025f1764c7c24b98461305be",
      "filename": "bfd/elfxx-aarch64.h",
      "status": "modified",
      "additions": 8,
      "deletions": 8,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-aarch64.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-aarch64.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-aarch64.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "0ac92b41b8a6ab3ae80952163191a89d3fd7bfe6",
      "filename": "bfd/elfxx-ia64.c",
      "status": "modified",
      "additions": 105,
      "deletions": 105,
      "changes": 210,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-ia64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-ia64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-ia64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "d4092e461a084dfebf5c04ca3cd82d0c85752a50",
      "filename": "bfd/elfxx-ia64.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-ia64.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-ia64.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-ia64.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "426f432d9d00198e4eb9f53d238e4e4003e8f689",
      "filename": "bfd/elfxx-mips.c",
      "status": "modified",
      "additions": 737,
      "deletions": 737,
      "changes": 1474,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-mips.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-mips.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-mips.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "1841729e93bde587af11642e42a6fe05daf96764",
      "filename": "bfd/elfxx-mips.h",
      "status": "modified",
      "additions": 49,
      "deletions": 49,
      "changes": 98,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-mips.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-mips.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-mips.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "a81ebd4d6beb6b8371e38be0bb516a3cec56106d",
      "filename": "bfd/elfxx-riscv.c",
      "status": "modified",
      "additions": 219,
      "deletions": 219,
      "changes": 438,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-riscv.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-riscv.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-riscv.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "10b78ee4916ef04ac96b7bf33cc633da3e45d984",
      "filename": "bfd/elfxx-riscv.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-riscv.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-riscv.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-riscv.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "83f6ced09862bac1bf04493cd99e01cb27db1891",
      "filename": "bfd/elfxx-sparc.c",
      "status": "modified",
      "additions": 228,
      "deletions": 228,
      "changes": 456,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-sparc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-sparc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "17fa8688cf813213733add4cc13d761d69fc8501",
      "filename": "bfd/elfxx-sparc.h",
      "status": "modified",
      "additions": 15,
      "deletions": 15,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-sparc.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-sparc.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-sparc.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "4c6b1f203407ed33483b111dd399a454b406e792",
      "filename": "bfd/elfxx-target.h",
      "status": "modified",
      "additions": 5,
      "deletions": 5,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-target.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "28a1a43a96cbcd9ffa3d9e113c66cdbb22a41190",
      "filename": "bfd/elfxx-tilegx.c",
      "status": "modified",
      "additions": 206,
      "deletions": 206,
      "changes": 412,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-tilegx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-tilegx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-tilegx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5d3648b309a226f5e7b71d987b27459bf5ec9e5e",
      "filename": "bfd/elfxx-tilegx.h",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-tilegx.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-tilegx.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-tilegx.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "62d516aab8d3bba2aec7f436c99705ea6d4ea740",
      "filename": "bfd/elfxx-x86.c",
      "status": "modified",
      "additions": 89,
      "deletions": 89,
      "changes": 178,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-x86.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-x86.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "db11327e96f403bed1d4f582117fc04493c9735d",
      "filename": "bfd/elfxx-x86.h",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-x86.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/elfxx-x86.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elfxx-x86.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5d08d1d642c876de8707e819836e8ce4f68fbae2",
      "filename": "bfd/format.c",
      "status": "modified",
      "additions": 17,
      "deletions": 17,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/format.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/format.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/format.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "92ee8b61a98282d721a0a0d526350787ec9c6e92",
      "filename": "bfd/genlink.h",
      "status": "modified",
      "additions": 4,
      "deletions": 4,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/genlink.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/genlink.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/genlink.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "0093d63fd9a6ca0a18617258a35b561489b09e9f",
      "filename": "bfd/hash.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/hash.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/hash.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/hash.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5a38cad8f0864b12c52e7152ba25774215498455",
      "filename": "bfd/i386aout.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/i386aout.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/i386aout.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/i386aout.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c477e661c81d542e8b53de511cd6af87616fdb70",
      "filename": "bfd/i386lynx.c",
      "status": "modified",
      "additions": 20,
      "deletions": 20,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/i386lynx.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/i386lynx.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/i386lynx.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "349e8d2bd55d13e5a958bf4f45b065fcd190a091",
      "filename": "bfd/i386msdos.c",
      "status": "modified",
      "additions": 9,
      "deletions": 9,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/i386msdos.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/i386msdos.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/i386msdos.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "93a703a1756306746a45e67a815d14ca66fb40c0",
      "filename": "bfd/ihex.c",
      "status": "modified",
      "additions": 46,
      "deletions": 46,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ihex.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/ihex.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ihex.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "0c379160b91208efba7fc08271c0b464b8c83a09",
      "filename": "bfd/libaout.h",
      "status": "modified",
      "additions": 38,
      "deletions": 38,
      "changes": 76,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libaout.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libaout.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libaout.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ebcc27dcbdf1f5e65a9fabe3c67622e6deb96b1d",
      "filename": "bfd/libbfd-in.h",
      "status": "modified",
      "additions": 104,
      "deletions": 104,
      "changes": 208,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libbfd-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libbfd-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd-in.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "9db14c3c22fd071c03edb451a8052b47ace20f7f",
      "filename": "bfd/libbfd.c",
      "status": "modified",
      "additions": 48,
      "deletions": 48,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libbfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libbfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "f1d25d0ab1feb136d3e016d66ff006383a107b22",
      "filename": "bfd/libbfd.h",
      "status": "modified",
      "additions": 118,
      "deletions": 118,
      "changes": 236,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libbfd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libbfd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libbfd.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ae24b012da1175fc80c6cc0b8fcf905e8eddfb14",
      "filename": "bfd/libcoff-in.h",
      "status": "modified",
      "additions": 40,
      "deletions": 40,
      "changes": 80,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libcoff-in.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libcoff-in.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libcoff-in.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "6dc68d1a39876be3003073c185e4523815e34446",
      "filename": "bfd/libcoff.h",
      "status": "modified",
      "additions": 63,
      "deletions": 63,
      "changes": 126,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libcoff.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libcoff.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libcoff.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c7eaba533b943c4320c27ffbaf9077e022810490",
      "filename": "bfd/libecoff.h",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libecoff.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libecoff.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libecoff.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "4de0c9fd048ac1dc9cf6e4ce0075bc95e610cbd6",
      "filename": "bfd/libpei.h",
      "status": "modified",
      "additions": 26,
      "deletions": 24,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libpei.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libpei.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libpei.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "cca9c21803347a9aaeeee8a40a8548edd46ea448",
      "filename": "bfd/libxcoff.h",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libxcoff.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/libxcoff.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/libxcoff.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "c350cd3fd15e607d181e19cde05f0348a2bbe10f",
      "filename": "bfd/linker.c",
      "status": "modified",
      "additions": 216,
      "deletions": 218,
      "changes": 434,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/linker.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/linker.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/linker.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "36c1f984bf8cf44a661462f51644ff186066e92f",
      "filename": "bfd/mach-o-aarch64.c",
      "status": "modified",
      "additions": 59,
      "deletions": 59,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o-aarch64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o-aarch64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o-aarch64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "094eac6bacc36b694b4855dbf6c2ef99cfcccf3f",
      "filename": "bfd/mach-o-arm.c",
      "status": "modified",
      "additions": 65,
      "deletions": 65,
      "changes": 130,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o-arm.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "99acdf4dea262fb830415ca1fe50a8efcb173d81",
      "filename": "bfd/mach-o-i386.c",
      "status": "modified",
      "additions": 55,
      "deletions": 55,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o-i386.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "84a6c063421d7c1c1c9ba66ba9bb5f2ae937e0d2",
      "filename": "bfd/mach-o-x86-64.c",
      "status": "modified",
      "additions": 58,
      "deletions": 58,
      "changes": 116,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o-x86-64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o-x86-64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o-x86-64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "60121c4ef4798024bb097dffc573a8db3ccec8ce",
      "filename": "bfd/mach-o.c",
      "status": "modified",
      "additions": 392,
      "deletions": 392,
      "changes": 784,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "104e705410ab7fb41d54c2924f26efda50184ec5",
      "filename": "bfd/mach-o.h",
      "status": "modified",
      "additions": 31,
      "deletions": 31,
      "changes": 62,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mach-o.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mach-o.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "b7a895d30b0d4c4b1a1e18d6525fcc7792c6e55c",
      "filename": "bfd/merge.c",
      "status": "modified",
      "additions": 34,
      "deletions": 34,
      "changes": 68,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/merge.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/merge.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/merge.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "40aff3159140902be7d1f946e230cff4a0879c6f",
      "filename": "bfd/mmo.c",
      "status": "modified",
      "additions": 113,
      "deletions": 114,
      "changes": 227,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mmo.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/mmo.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/mmo.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "adaa91a36aaa724ad8a6d60a8ae0c262f220eaa1",
      "filename": "bfd/netbsd.h",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/netbsd.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/netbsd.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/netbsd.h?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "26faaa6c9a95a901427ab74e81adfbddc0d6978c",
      "filename": "bfd/opncls.c",
      "status": "modified",
      "additions": 59,
      "deletions": 59,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/opncls.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/opncls.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/opncls.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "ff149709e6d8aba59f68a16dc79c16f7e0afe9c7",
      "filename": "bfd/pc532-mach.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pc532-mach.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pc532-mach.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pc532-mach.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "75ddf2038c294e51335ca79e495345ad85e2bb4e",
      "filename": "bfd/pdp11.c",
      "status": "modified",
      "additions": 256,
      "deletions": 256,
      "changes": 512,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pdp11.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pdp11.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pdp11.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "0e1199dc120abc83d4b32b079e8d2b8f8df979f8",
      "filename": "bfd/pe-arm.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pe-arm.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "b6164a04c5e1bf0bb7a1829e49332b60645132eb",
      "filename": "bfd/pe-i386.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pe-i386.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e3492bf0376655f60d36bc1a4a94f4a471f1e1e2",
      "filename": "bfd/pe-mcore.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-mcore.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-mcore.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pe-mcore.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "d99b2472a7d973124add511e5d0d2fdb7165ce25",
      "filename": "bfd/pe-sh.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-sh.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-sh.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pe-sh.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "5a777bbf4c87af12eaf7e548a1736670a68fe136",
      "filename": "bfd/pe-x86_64.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-x86_64.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pe-x86_64.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pe-x86_64.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e7f1311b91a6db6057468c0466c31fadb644f6eb",
      "filename": "bfd/peXXigen.c",
      "status": "modified",
      "additions": 142,
      "deletions": 142,
      "changes": 284,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/peXXigen.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/peXXigen.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/peXXigen.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "f55e532b6fd79597c13ac3a65cf8fe1f294c3892",
      "filename": "bfd/pef.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pef.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pef.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pef.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "216b94509ad43516062118916a9ece66c3553fed",
      "filename": "bfd/pei-arm.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pei-arm.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pei-arm.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pei-arm.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    },
    {
      "sha": "e2c52911e53bdcc0d7ddc27d463a291c2f7c44cb",
      "filename": "bfd/pei-i386.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pei-i386.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0a1b45a20eaa98d4d9026dc1fd17e79e741183af/bfd/pei-i386.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/pei-i386.c?ref=0a1b45a20eaa98d4d9026dc1fd17e79e741183af"
    }
  ]
}