{
  "sha": "d0c99a23b21aff9107a4cf49ee626b7db0824a04",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZDBjOTlhMjNiMjFhZmY5MTA3YTRjZjQ5ZWU2MjZiN2RiMDgyNGEwNA==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-01-25T04:57:28Z"
    },
    "committer": {
      "name": "Pedro Alves",
      "email": "pedro@palves.net",
      "date": "2021-03-17T12:51:06Z"
    },
    "message": "gdb/testsuite: add test for run/attach while program is running\n\nA WIP patch series broke the use case of doing \"run\" or \"attach\" while\nthe program is running, but it wasn't caught by the testsuite, which\nmeans it's not covered.  Add a test for that.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.base/run-attach-while-running.exp: New.\n\t* gdb.base/run-attach-while-running.c: New.\n\nChange-Id: I77f098ec0b28dc2d4575ea80e941f6a75273e431",
    "tree": {
      "sha": "b96586068ba65c3d366596b55fb89b0fec381f45",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/b96586068ba65c3d366596b55fb89b0fec381f45"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/d0c99a23b21aff9107a4cf49ee626b7db0824a04",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d0c99a23b21aff9107a4cf49ee626b7db0824a04",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/d0c99a23b21aff9107a4cf49ee626b7db0824a04",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d0c99a23b21aff9107a4cf49ee626b7db0824a04/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "palves",
    "id": 1202913,
    "node_id": "MDQ6VXNlcjEyMDI5MTM=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1202913?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/palves",
    "html_url": "https://github.com/palves",
    "followers_url": "https://api.github.com/users/palves/followers",
    "following_url": "https://api.github.com/users/palves/following{/other_user}",
    "gists_url": "https://api.github.com/users/palves/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/palves/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/palves/subscriptions",
    "organizations_url": "https://api.github.com/users/palves/orgs",
    "repos_url": "https://api.github.com/users/palves/repos",
    "events_url": "https://api.github.com/users/palves/events{/privacy}",
    "received_events_url": "https://api.github.com/users/palves/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "95557f1e09b765e50a3575725c798bd877e40fc0",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/95557f1e09b765e50a3575725c798bd877e40fc0",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/95557f1e09b765e50a3575725c798bd877e40fc0"
    }
  ],
  "stats": {
    "total": 195,
    "additions": 195,
    "deletions": 0
  },
  "files": [
    {
      "sha": "c1d7fec6cc4598a80ee0bd2811202f16699f5dda",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d0c99a23b21aff9107a4cf49ee626b7db0824a04/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d0c99a23b21aff9107a4cf49ee626b7db0824a04/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=d0c99a23b21aff9107a4cf49ee626b7db0824a04",
      "patch": "@@ -1,3 +1,9 @@\n+2021-03-17  Simon Marchi  <simon.marchi@polymtl.ca>\n+\t    Pedro Alves  <pedro@palves.net>\n+\n+\t* gdb.base/run-attach-while-running.exp: New.\n+\t* gdb.base/run-attach-while-running.c: New.\n+\n 2021-03-16  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.python/py-framefilter-addr.c: New file."
    },
    {
      "sha": "57bebbe6456eb36b28d1168060091f9d3a729c7c",
      "filename": "gdb/testsuite/gdb.base/run-attach-while-running.c",
      "status": "added",
      "additions": 69,
      "deletions": 0,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d0c99a23b21aff9107a4cf49ee626b7db0824a04/gdb/testsuite/gdb.base/run-attach-while-running.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d0c99a23b21aff9107a4cf49ee626b7db0824a04/gdb/testsuite/gdb.base/run-attach-while-running.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/run-attach-while-running.c?ref=d0c99a23b21aff9107a4cf49ee626b7db0824a04",
      "patch": "@@ -0,0 +1,69 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#include <unistd.h>\n+#include <assert.h>\n+\n+#ifndef WITH_THREADS\n+# error \"WITH_THREADS must be defined.\"\n+#endif\n+\n+#if WITH_THREADS\n+# include <pthread.h>\n+\n+static pthread_barrier_t barrier;\n+\n+static void *\n+thread_func (void *p)\n+{\n+  pthread_barrier_wait (&barrier);\n+\n+  for (int i = 0; i < 30; i++)\n+    sleep (1);\n+\n+  return NULL;\n+}\n+\n+#endif /* WITH_THREADS */\n+\n+static void\n+all_started (void)\n+{}\n+\n+int\n+main (void)\n+{\n+  alarm (30);\n+\n+#if WITH_THREADS\n+  int ret = pthread_barrier_init (&barrier, NULL, 2);\n+  assert (ret == 0);\n+\n+  pthread_t thread;\n+  ret = pthread_create (&thread, NULL, thread_func, NULL);\n+  assert (ret == 0);\n+\n+  pthread_barrier_wait (&barrier);\n+#endif /* WITH_THREADS */\n+\n+  all_started ();\n+\n+  for (int i = 0; i < 30; i++)\n+    sleep (1);\n+\n+  return 0;\n+}"
    },
    {
      "sha": "7c16aa6f5c40d4654265316db775d7094663e44e",
      "filename": "gdb/testsuite/gdb.base/run-attach-while-running.exp",
      "status": "added",
      "additions": 120,
      "deletions": 0,
      "changes": 120,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/d0c99a23b21aff9107a4cf49ee626b7db0824a04/gdb/testsuite/gdb.base/run-attach-while-running.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/d0c99a23b21aff9107a4cf49ee626b7db0824a04/gdb/testsuite/gdb.base/run-attach-while-running.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/run-attach-while-running.exp?ref=d0c99a23b21aff9107a4cf49ee626b7db0824a04",
      "patch": "@@ -0,0 +1,120 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test doing a \"run\" or an \"attach\" while the program is running.\n+#\n+# We test a non-threaded and a threaded configuration, so that targets\n+# that don't support threads get some testing, but we also test with\n+# threads when possible in case that triggers some\n+# multi-thread-specific bugs.\n+\n+standard_testfile\n+\n+set binfile_threads ${binfile}-threads\n+set binfile_nothreads ${binfile}-nothreads\n+unset binfile\n+\n+# Valid parameter / axis values:\n+#\n+#   - non-stop: \"off\" of \"on\"\n+#   - threaded: 0 or 1\n+#   - run-or-attach: \"run\" or \"attach\"\n+\n+proc_with_prefix test { non-stop threaded run-or-attach } {\n+    if { ${run-or-attach} == \"attach\" && ![can_spawn_for_attach] } {\n+\tunsupported \"attach not supported\"\n+\treturn\n+    }\n+\n+    save_vars ::GDBFLAGS {\n+\tset ::GDBFLAGS \"$::GDBFLAGS -ex \\\"set non-stop ${non-stop}\\\"\"\n+\n+\t# The test doesn't work when the remote target uses the\n+\t# synchronous remote protocol, because GDB can't kill the\n+\t# remote inferior while it is running, when we \"run\" or\n+\t# \"attach\" again.  When aswering \"yes\" to the \"Start it from\n+\t# the beginning?\" question, we otherwise get:\n+\t#\n+\t#   Cannot execute this command while the target is running.  Use the\n+\t#   \"interrupt\" command to stop the target and then try again.\n+\t#\n+\t# Interrupting the target would defeat the purpose of the\n+\t# test.  So when non-stop is off and using the remote target,\n+\t# force the target to use the async / non-stop version of the\n+\t# protocol.\n+\tif { [target_info exists gdb_protocol] && ${non-stop} == \"off\" } {\n+\t    set ::GDBFLAGS \"$::GDBFLAGS -ex \\\"maint set target-non-stop on\\\"\"\n+\t}\n+\n+\tclean_restart $::binfile\n+    }\n+\n+    if { ![runto_main] } {\n+\tuntested \"could not run to main\"\n+\treturn\n+    }\n+\n+    gdb_breakpoint \"all_started\" \"temporary\"\n+    gdb_continue_to_breakpoint \"continue to all_started\"\n+\n+    # If all-stop, everything stopped when we hit the all_started\n+    # breakpoint, so resume execution in background.  If running the\n+    # non-threaded version, our only thread is stopped in any case, so\n+    # resume as well.  But if we are in non-stop with two threads, we\n+    # have one running and one stopped, leave it like this, it makes\n+    # an interesting test case.\n+    if { ${non-stop} == \"off\" || !${threaded} } {\n+\tgdb_test \"continue &\" \"Continuing.\"\n+    }\n+\n+    gdb_test_no_output \"set confirm off\"\n+\n+    # Run again (or, connect to a new stub if using a stub), take\n+    # advantage of the fact that runto_main leaves the breakpoint on\n+    # main in place.\n+    if { ${run-or-attach} == \"run\" } {\n+\tgdb_run_cmd\n+\tgdb_test \"\" \"Breakpoint $::decimal, .*main.*\" \"hit main breakpoint after re-run\"\n+    } elseif { ${run-or-attach} == \"attach\" } {\n+\tset test_spawn_id [spawn_wait_for_attach $::binfile]\n+\tset test_pid [spawn_id_get_pid $test_spawn_id]\n+\n+\tgdb_test \"attach $test_pid\" \"Attaching to program: .*\" \"attach to process\"\n+\n+\tgdb_exit\n+\tkill_wait_spawned_process $test_spawn_id\n+    } else {\n+\terror \"Invalid value for run-or-attach\"\n+    }\n+}\n+\n+foreach_with_prefix threaded {0 1} {\n+    set options [list debug additional_flags=-DWITH_THREADS=$threaded]\n+    if { $threaded } {\n+\tset binfile $binfile_threads\n+\tlappend options pthreads\n+    } else {\n+\tset binfile $binfile_nothreads\n+    }\n+    if { [build_executable \"failed to prepare\" ${binfile} ${srcfile} $options] } {\n+\tcontinue\n+    }\n+\n+    foreach_with_prefix run-or-attach {run attach} {\n+\tforeach_with_prefix non-stop {off on} {\n+\t    test ${non-stop} ${threaded} ${run-or-attach}\n+\t}\n+    }\n+}"
    }
  ]
}