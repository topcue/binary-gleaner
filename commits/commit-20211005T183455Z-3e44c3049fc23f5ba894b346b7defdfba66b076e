{
  "sha": "3e44c3049fc23f5ba894b346b7defdfba66b076e",
  "node_id": "C_kwDOANOeidoAKDNlNDRjMzA0OWZjMjNmNWJhODk0YjM0NmI3ZGVmZGZiYTY2YjA3NmU",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-09-13T18:31:20Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2021-10-05T18:34:55Z"
    },
    "message": "Allow lazy 'zero' value\n\nThis changes value_zero to create a lazy value.  In many cases,\nvalue_zero is called in expression evaluation to wrap a type in a\nnon-eval context.  It seems senseless to allocate a buffer in these\ncases.\n\nA new 'is_zero' flag is added so we can preserve the existing\nassertions in value_fetch_lazy.\n\nA subsequent patch will add a test where creating a zero value would\nfail, due to the variable size check.  However, the contents of this\nvalue are never needed, and so creating a lazy value avoids the error\ncase.",
    "tree": {
      "sha": "5486581f3787291c83ff78c0506f63dce9711136",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5486581f3787291c83ff78c0506f63dce9711136"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/3e44c3049fc23f5ba894b346b7defdfba66b076e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3e44c3049fc23f5ba894b346b7defdfba66b076e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/3e44c3049fc23f5ba894b346b7defdfba66b076e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3e44c3049fc23f5ba894b346b7defdfba66b076e/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a519e8ffe2b0f008deaef1517562090d9eaadccc",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a519e8ffe2b0f008deaef1517562090d9eaadccc",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a519e8ffe2b0f008deaef1517562090d9eaadccc"
    }
  ],
  "stats": {
    "total": 35,
    "additions": 23,
    "deletions": 12
  },
  "files": [
    {
      "sha": "f65479b8117d71b993d27e13d277aecc74ffde53",
      "filename": "gdb/valops.c",
      "status": "modified",
      "additions": 0,
      "deletions": 11,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3e44c3049fc23f5ba894b346b7defdfba66b076e/gdb/valops.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3e44c3049fc23f5ba894b346b7defdfba66b076e/gdb/valops.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valops.c?ref=3e44c3049fc23f5ba894b346b7defdfba66b076e",
      "patch": "@@ -935,17 +935,6 @@ value_dynamic_cast (struct type *type, struct value *arg)\n   error (_(\"dynamic_cast failed\"));\n }\n \n-/* Create a value of type TYPE that is zero, and return it.  */\n-\n-struct value *\n-value_zero (struct type *type, enum lval_type lv)\n-{\n-  struct value *val = allocate_value (type);\n-\n-  VALUE_LVAL (val) = (lv == lval_computed ? not_lval : lv);\n-  return val;\n-}\n-\n /* Create a not_lval value of numeric type TYPE that is one, and return it.  */\n \n struct value *"
    },
    {
      "sha": "19d81fd6e357ab669edb25226873bc42f4529a6c",
      "filename": "gdb/value.c",
      "status": "modified",
      "additions": 23,
      "deletions": 1,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/3e44c3049fc23f5ba894b346b7defdfba66b076e/gdb/value.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/3e44c3049fc23f5ba894b346b7defdfba66b076e/gdb/value.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/value.c?ref=3e44c3049fc23f5ba894b346b7defdfba66b076e",
      "patch": "@@ -180,6 +180,7 @@ struct value\n       lazy (1),\n       initialized (1),\n       stack (0),\n+      is_zero (false),\n       type (type_),\n       enclosing_type (type_)\n   {\n@@ -230,6 +231,10 @@ struct value\n      used instead of read_memory to enable extra caching.  */\n   unsigned int stack : 1;\n \n+  /* True if this is a zero value, created by 'value_zero'; false\n+     otherwise.  */\n+  bool is_zero : 1;\n+\n   /* Location of value (if lval).  */\n   union\n   {\n@@ -1704,6 +1709,7 @@ value_copy (struct value *arg)\n   val->pointed_to_offset = arg->pointed_to_offset;\n   val->modifiable = arg->modifiable;\n   val->stack = arg->stack;\n+  val->is_zero = arg->is_zero;\n   val->initialized = arg->initialized;\n   if (!value_lazy (val))\n     {\n@@ -3507,6 +3513,18 @@ pack_unsigned_long (gdb_byte *buf, struct type *type, ULONGEST num)\n }\n \n \n+/* Create a value of type TYPE that is zero, and return it.  */\n+\n+struct value *\n+value_zero (struct type *type, enum lval_type lv)\n+{\n+  struct value *val = allocate_value_lazy (type);\n+\n+  VALUE_LVAL (val) = (lv == lval_computed ? not_lval : lv);\n+  val->is_zero = true;\n+  return val;\n+}\n+\n /* Convert C numbers into newly allocated values.  */\n \n struct value *\n@@ -4026,7 +4044,11 @@ value_fetch_lazy (struct value *val)\n      value.  */\n   gdb_assert (val->optimized_out.empty ());\n   gdb_assert (val->unavailable.empty ());\n-  if (value_bitsize (val))\n+  if (val->is_zero)\n+    {\n+      /* Nothing.  */\n+    }\n+  else if (value_bitsize (val))\n     value_fetch_lazy_bitfield (val);\n   else if (VALUE_LVAL (val) == lval_memory)\n     value_fetch_lazy_memory (val);"
    }
  ]
}