{
  "sha": "5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NWJiZDgyNjlmYThkMTM4ZThlYTFkZDNjOGNkZjQyNDEyYzFkZmE0MQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-10-24T10:12:11Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-12-01T22:31:30Z"
    },
    "message": "gdb/fortran: array stride support\n\nCurrently GDB supports a byte or bit stride on arrays, in DWARF this\nwould be DW_AT_bit_stride or DW_AT_byte_stride on DW_TAG_array_type.\nHowever, DWARF can also support DW_AT_byte_stride or DW_AT_bit_stride\non DW_TAG_subrange_type, the tag used to describe each dimension of an\narray.\n\nStrides on subranges are used by gFortran to represent Fortran arrays,\nand this commit adds support for this to GDB.\n\nI've extended the range_bounds struct to include the stride\ninformation.  The name is possibly a little inaccurate now, but this\nstill sort of makes sense, the structure represents information about\nthe bounds of the range, and also how to move from the lower to the\nupper bound (the stride).\n\nI've added initial support for bit strides, but I've never actually\nseen an example of this being generated.  Further, I don't really see\nright now how GDB would currently handle a bit stride that was not a\nmultiple of the byte size as the code in, for example,\nvalarith.c:value_subscripted_rvalue seems geared around byte\naddressing.  As a consequence if we see a bit stride that is not a\nmultiple of 8 then GDB will give an error.\n\ngdb/ChangeLog:\n\n\t* dwarf2read.c (read_subrange_type): Read bit and byte stride and\n\tcreate a range with stride where appropriate.\n\t* f-valprint.c: Include 'gdbarch.h'.\n\t(f77_print_array_1): Take the stride into account when walking the\n\tarray.  Also convert the stride into addressable units.\n\t* gdbtypes.c (create_range_type): Initialise the stride to\n\tconstant zero.\n\t(create_range_type_with_stride): New function, initialise the\n\trange as normal, and then setup the stride.\n\t(has_static_range): Include the stride here.  Also change the\n\treturn type to bool.\n\t(create_array_type_with_stride): Consider the range stride if the\n\tarray isn't given its own stride.\n\t(resolve_dynamic_range): Resolve the stride if needed.\n\t* gdbtypes.h (struct range_bounds) <stride>: New member variable.\n\t(struct range_bounds) <flag_is_byte_stride>: New member variable.\n\t(TYPE_BIT_STRIDE): Define.\n\t(TYPE_ARRAY_BIT_STRIDE): Define.\n\t(create_range_type_with_stride): Declare.\n\t* valarith.c (value_subscripted_rvalue): Take range stride into\n\taccount when walking the array.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.fortran/derived-type-striding.exp: New file.\n\t* gdb.fortran/derived-type-striding.f90: New file.\n\t* gdb.fortran/array-slices.exp: New file.\n\t* gdb.fortran/array-slices.f90: New file.\n\nChange-Id: I9af2bcd1f2d4c56f76f5f3f9f89d8f06bef10d9a",
    "tree": {
      "sha": "424045e6cff4208f62566e5ab727aafe23cfca7c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/424045e6cff4208f62566e5ab727aafe23cfca7c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "82e3b5645f9c4edc1d84e57c32665d0e76bbbd77",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/82e3b5645f9c4edc1d84e57c32665d0e76bbbd77",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/82e3b5645f9c4edc1d84e57c32665d0e76bbbd77"
    }
  ],
  "stats": {
    "total": 414,
    "additions": 403,
    "deletions": 11
  },
  "files": [
    {
      "sha": "5da07259fc415ff1e7b154fa116b76156dc7bc0b",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 24,
      "deletions": 0,
      "changes": 24,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -1,3 +1,27 @@\n+2019-12-01  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* dwarf2read.c (read_subrange_type): Read bit and byte stride and\n+\tcreate a range with stride where appropriate.\n+\t* f-valprint.c: Include 'gdbarch.h'.\n+\t(f77_print_array_1): Take the stride into account when walking the\n+\tarray.  Also convert the stride into addressable units.\n+\t* gdbtypes.c (create_range_type): Initialise the stride to\n+\tconstant zero.\n+\t(create_range_type_with_stride): New function, initialise the\n+\trange as normal, and then setup the stride.\n+\t(has_static_range): Include the stride here.  Also change the\n+\treturn type to bool.\n+\t(create_array_type_with_stride): Consider the range stride if the\n+\tarray isn't given its own stride.\n+\t(resolve_dynamic_range): Resolve the stride if needed.\n+\t* gdbtypes.h (struct range_bounds) <stride>: New member variable.\n+\t(struct range_bounds) <flag_is_byte_stride>: New member variable.\n+\t(TYPE_BIT_STRIDE): Define.\n+\t(TYPE_ARRAY_BIT_STRIDE): Define.\n+\t(create_range_type_with_stride): Declare.\n+\t* valarith.c (value_subscripted_rvalue): Take range stride into\n+\taccount when walking the array.\n+\n 2019-12-01  Tom Tromey  <tom@tromey.com>\n \n \t* tui/tui-win.c (tui_all_windows_info): Treat inactive TUI"
    },
    {
      "sha": "12a9773302e41b0fd351cc3537099068f0adc32f",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 46,
      "deletions": 1,
      "changes": 47,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -18065,7 +18065,52 @@ read_subrange_type (struct die_info *die, struct dwarf2_cu *cu)\n       && !TYPE_UNSIGNED (base_type) && (high.data.const_val & negative_mask))\n     high.data.const_val |= negative_mask;\n \n-  range_type = create_range_type (NULL, orig_base_type, &low, &high, bias);\n+  /* Check for bit and byte strides.  */\n+  struct dynamic_prop byte_stride_prop;\n+  attribute *attr_byte_stride = dwarf2_attr (die, DW_AT_byte_stride, cu);\n+  if (attr_byte_stride != nullptr)\n+    {\n+      struct type *prop_type\n+\t= dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+      attr_to_dynamic_prop (attr_byte_stride, die, cu, &byte_stride_prop,\n+\t\t\t    prop_type);\n+    }\n+\n+  struct dynamic_prop bit_stride_prop;\n+  attribute *attr_bit_stride = dwarf2_attr (die, DW_AT_bit_stride, cu);\n+  if (attr_bit_stride != nullptr)\n+    {\n+      /* It only makes sense to have either a bit or byte stride.  */\n+      if (attr_byte_stride != nullptr)\n+\t{\n+\t  complaint (_(\"Found DW_AT_bit_stride and DW_AT_byte_stride \"\n+\t\t       \"- DIE at %s [in module %s]\"),\n+\t\t     sect_offset_str (die->sect_off),\n+\t\t     objfile_name (cu->per_cu->dwarf2_per_objfile->objfile));\n+\t  attr_bit_stride = nullptr;\n+\t}\n+      else\n+\t{\n+\t  struct type *prop_type\n+\t    = dwarf2_per_cu_addr_sized_int_type (cu->per_cu, false);\n+\t  attr_to_dynamic_prop (attr_bit_stride, die, cu, &bit_stride_prop,\n+\t\t\t\tprop_type);\n+\t}\n+    }\n+\n+  if (attr_byte_stride != nullptr\n+      || attr_bit_stride != nullptr)\n+    {\n+      bool byte_stride_p = (attr_byte_stride != nullptr);\n+      struct dynamic_prop *stride\n+\t= byte_stride_p ? &byte_stride_prop : &bit_stride_prop;\n+\n+      range_type\n+\t= create_range_type_with_stride (NULL, orig_base_type, &low,\n+\t\t\t\t\t &high, bias, stride, byte_stride_p);\n+    }\n+  else\n+    range_type = create_range_type (NULL, orig_base_type, &low, &high, bias);\n \n   if (high_bound_is_count)\n     TYPE_RANGE_DATA (range_type)->flag_upper_bound_is_count = 1;"
    },
    {
      "sha": "35dc90dcb0f6471dc1013ea74edea3bc0889e067",
      "filename": "gdb/f-valprint.c",
      "status": "modified",
      "additions": 8,
      "deletions": 2,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/f-valprint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/f-valprint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-valprint.c?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -34,6 +34,7 @@\n #include \"block.h\"\n #include \"dictionary.h\"\n #include \"cli/cli-style.h\"\n+#include \"gdbarch.h\"\n \n static void f77_get_dynamic_length_of_aggregate (struct type *);\n \n@@ -120,7 +121,12 @@ f77_print_array_1 (int nss, int ndimensions, struct type *type,\n \n   if (nss != ndimensions)\n     {\n-      size_t dim_size = TYPE_LENGTH (TYPE_TARGET_TYPE (type));\n+      struct gdbarch *gdbarch = get_type_arch (type);\n+      size_t dim_size = type_length_units (TYPE_TARGET_TYPE (type));\n+      int unit_size = gdbarch_addressable_memory_unit_size (gdbarch);\n+      size_t byte_stride = TYPE_ARRAY_BIT_STRIDE (type) / (unit_size * 8);\n+      if (byte_stride == 0)\n+\tbyte_stride = dim_size;\n       size_t offs = 0;\n \n       for (i = lowerbound;\n@@ -137,7 +143,7 @@ f77_print_array_1 (int nss, int ndimensions, struct type *type,\n \t\t\t     value_embedded_offset (subarray),\n \t\t\t     value_address (subarray),\n \t\t\t     stream, recurse, subarray, options, elts);\n-\t  offs += dim_size;\n+\t  offs += byte_stride;\n \t  fprintf_filtered (stream, \") \");\n \t}\n       if (*elts >= options->print_max && i < upperbound)"
    },
    {
      "sha": "b1e03d1643c512c2d65404286cf4b1534259d498",
      "filename": "gdb/gdbtypes.c",
      "status": "modified",
      "additions": 71,
      "deletions": 8,
      "changes": 79,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/gdbtypes.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/gdbtypes.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.c?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -935,6 +935,10 @@ create_range_type (struct type *result_type, struct type *index_type,\n   TYPE_RANGE_DATA (result_type)->high = *high_bound;\n   TYPE_RANGE_DATA (result_type)->bias = bias;\n \n+  /* Initialize the stride to be a constant, the value will already be zero\n+     thanks to the use of TYPE_ZALLOC above.  */\n+  TYPE_RANGE_DATA (result_type)->stride.kind = PROP_CONST;\n+\n   if (low_bound->kind == PROP_CONST && low_bound->data.const_val >= 0)\n     TYPE_UNSIGNED (result_type) = 1;\n \n@@ -948,6 +952,29 @@ create_range_type (struct type *result_type, struct type *index_type,\n   return result_type;\n }\n \n+/* See gdbtypes.h.  */\n+\n+struct type *\n+create_range_type_with_stride (struct type *result_type,\n+\t\t\t       struct type *index_type,\n+\t\t\t       const struct dynamic_prop *low_bound,\n+\t\t\t       const struct dynamic_prop *high_bound,\n+\t\t\t       LONGEST bias,\n+\t\t\t       const struct dynamic_prop *stride,\n+\t\t\t       bool byte_stride_p)\n+{\n+  result_type = create_range_type (result_type, index_type, low_bound,\n+\t\t\t\t   high_bound, bias);\n+\n+  gdb_assert (stride != nullptr);\n+  TYPE_RANGE_DATA (result_type)->stride = *stride;\n+  TYPE_RANGE_DATA (result_type)->flag_is_byte_stride = byte_stride_p;\n+\n+  return result_type;\n+}\n+\n+\n+\n /* Create a range type using either a blank type supplied in\n    RESULT_TYPE, or creating a new type, inheriting the objfile from\n    INDEX_TYPE.\n@@ -978,11 +1005,14 @@ create_static_range_type (struct type *result_type, struct type *index_type,\n /* Predicate tests whether BOUNDS are static.  Returns 1 if all bounds values\n    are static, otherwise returns 0.  */\n \n-static int\n+static bool\n has_static_range (const struct range_bounds *bounds)\n {\n+  /* If the range doesn't have a defined stride then its stride field will\n+     be initialized to the constant 0.  */\n   return (bounds->low.kind == PROP_CONST\n-\t  && bounds->high.kind == PROP_CONST);\n+\t  && bounds->high.kind == PROP_CONST\n+\t  && bounds->stride.kind == PROP_CONST);\n }\n \n \n@@ -1189,6 +1219,15 @@ create_array_type_with_stride (struct type *result_type,\n \t  && !type_not_allocated (result_type)))\n     {\n       LONGEST low_bound, high_bound;\n+      unsigned int stride;\n+\n+      /* If the array itself doesn't provide a stride value then take\n+\t whatever stride the range provides.  Don't update BIT_STRIDE as\n+\t we don't want to place the stride value from the range into this\n+\t arrays bit size field.  */\n+      stride = bit_stride;\n+      if (stride == 0)\n+\tstride = TYPE_BIT_STRIDE (range_type);\n \n       if (get_discrete_bounds (range_type, &low_bound, &high_bound) < 0)\n \tlow_bound = high_bound = 0;\n@@ -1198,9 +1237,9 @@ create_array_type_with_stride (struct type *result_type,\n \t In such cases, the array length should be zero.  */\n       if (high_bound < low_bound)\n \tTYPE_LENGTH (result_type) = 0;\n-      else if (bit_stride > 0)\n+      else if (stride > 0)\n \tTYPE_LENGTH (result_type) =\n-\t  (bit_stride * (high_bound - low_bound + 1) + 7) / 8;\n+\t  (stride * (high_bound - low_bound + 1) + 7) / 8;\n       else\n \tTYPE_LENGTH (result_type) =\n \t  TYPE_LENGTH (element_type) * (high_bound - low_bound + 1);\n@@ -1982,7 +2021,7 @@ resolve_dynamic_range (struct type *dyn_range_type,\n   CORE_ADDR value;\n   struct type *static_range_type, *static_target_type;\n   const struct dynamic_prop *prop;\n-  struct dynamic_prop low_bound, high_bound;\n+  struct dynamic_prop low_bound, high_bound, stride;\n \n   gdb_assert (TYPE_CODE (dyn_range_type) == TYPE_CODE_RANGE);\n \n@@ -2014,13 +2053,37 @@ resolve_dynamic_range (struct type *dyn_range_type,\n       high_bound.data.const_val = 0;\n     }\n \n+  bool byte_stride_p = TYPE_RANGE_DATA (dyn_range_type)->flag_is_byte_stride;\n+  prop = &TYPE_RANGE_DATA (dyn_range_type)->stride;\n+  if (dwarf2_evaluate_property (prop, NULL, addr_stack, &value))\n+    {\n+      stride.kind = PROP_CONST;\n+      stride.data.const_val = value;\n+\n+      /* If we have a bit stride that is not an exact number of bytes then\n+\t I really don't think this is going to work with current GDB, the\n+\t array indexing code in GDB seems to be pretty heavily tied to byte\n+\t offsets right now.  Assuming 8 bits in a byte.  */\n+      struct gdbarch *gdbarch = get_type_arch (dyn_range_type);\n+      int unit_size = gdbarch_addressable_memory_unit_size (gdbarch);\n+      if (!byte_stride_p && (value % (unit_size * 8)) != 0)\n+\terror (_(\"bit strides that are not a multiple of the byte size \"\n+\t\t \"are currently not supported\"));\n+    }\n+  else\n+    {\n+      stride.kind = PROP_UNDEFINED;\n+      stride.data.const_val = 0;\n+      byte_stride_p = true;\n+    }\n+\n   static_target_type\n     = resolve_dynamic_type_internal (TYPE_TARGET_TYPE (dyn_range_type),\n \t\t\t\t     addr_stack, 0);\n   LONGEST bias = TYPE_RANGE_DATA (dyn_range_type)->bias;\n-  static_range_type = create_range_type (copy_type (dyn_range_type),\n-\t\t\t\t\t static_target_type,\n-\t\t\t\t\t &low_bound, &high_bound, bias);\n+  static_range_type = create_range_type_with_stride\n+    (copy_type (dyn_range_type), static_target_type,\n+     &low_bound, &high_bound, bias, &stride, byte_stride_p);\n   TYPE_RANGE_DATA (static_range_type)->flag_bound_evaluated = 1;\n   return static_range_type;\n }"
    },
    {
      "sha": "963314dcc81932b674b7aa4c7ef877b14c5566e3",
      "filename": "gdb/gdbtypes.h",
      "status": "modified",
      "additions": 27,
      "deletions": 0,
      "changes": 27,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/gdbtypes.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/gdbtypes.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbtypes.h?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -623,6 +623,13 @@ struct range_bounds\n \n   struct dynamic_prop high;\n \n+  /* The stride value for this range.  This can be stored in bits or bytes\n+     based on the value of BYTE_STRIDE_P.  It is optional to have a stride\n+     value, if this range has no stride value defined then this will be set\n+     to the constant zero.  */\n+\n+  struct dynamic_prop stride;\n+\n   /* * The bias.  Sometimes a range value is biased before storage.\n      The bias is added to the stored bits to form the true value.  */\n \n@@ -637,6 +644,10 @@ struct range_bounds\n      a dynamic one.  */\n \n   unsigned int flag_bound_evaluated : 1;\n+\n+  /* If this is true this STRIDE is in bytes, otherwise STRIDE is in bits.  */\n+\n+  unsigned int flag_is_byte_stride : 1;\n };\n \n /* Compare two range_bounds objects for equality.  Simply does\n@@ -1352,6 +1363,9 @@ extern bool set_type_align (struct type *, ULONGEST);\n   TYPE_RANGE_DATA(range_type)->high.kind\n #define TYPE_LOW_BOUND_KIND(range_type) \\\n   TYPE_RANGE_DATA(range_type)->low.kind\n+#define TYPE_BIT_STRIDE(range_type) \\\n+  (TYPE_RANGE_DATA(range_type)->stride.data.const_val \\\n+   * (TYPE_RANGE_DATA(range_type)->flag_is_byte_stride ? 8 : 1))\n \n /* Property accessors for the type data location.  */\n #define TYPE_DATA_LOCATION(thistype) \\\n@@ -1394,6 +1408,9 @@ extern bool set_type_align (struct type *, ULONGEST);\n #define TYPE_ARRAY_LOWER_BOUND_VALUE(arraytype) \\\n    (TYPE_LOW_BOUND(TYPE_INDEX_TYPE((arraytype))))\n \n+#define TYPE_ARRAY_BIT_STRIDE(arraytype) \\\n+  (TYPE_BIT_STRIDE(TYPE_INDEX_TYPE((arraytype))))\n+\n /* C++ */\n \n #define TYPE_SELF_TYPE(thistype) internal_type_self_type (thistype)\n@@ -1966,6 +1983,16 @@ extern struct type *create_range_type (struct type *, struct type *,\n \t\t\t\t       const struct dynamic_prop *,\n \t\t\t\t       LONGEST);\n \n+/* Like CREATE_RANGE_TYPE but also sets up a stride.  When BYTE_STRIDE_P\n+   is true the value in STRIDE is a byte stride, otherwise STRIDE is a bit\n+   stride.  */\n+\n+extern struct type * create_range_type_with_stride\n+  (struct type *result_type, struct type *index_type,\n+   const struct dynamic_prop *low_bound,\n+   const struct dynamic_prop *high_bound, LONGEST bias,\n+   const struct dynamic_prop *stride, bool byte_stride_p);\n+\n extern struct type *create_array_type (struct type *, struct type *,\n \t\t\t\t       struct type *);\n "
    },
    {
      "sha": "f3bffa5dbe6b091d67a2ace7b2f3f1678c697fc8",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -1,3 +1,11 @@\n+2019-12-01  Richard Bunt  <richard.bunt@arm.com>\n+\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.fortran/derived-type-striding.exp: New file.\n+\t* gdb.fortran/derived-type-striding.f90: New file.\n+\t* gdb.fortran/array-slices.exp: New file.\n+\t* gdb.fortran/array-slices.f90: New file.\n+\n 2019-11-30  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n \n \t* gdb.base/define.exp: Test . in command names."
    },
    {
      "sha": "db07ace0b38b07353248c6ad4c1f3cf0f139f0e6",
      "filename": "gdb/testsuite/gdb.fortran/array-slices.exp",
      "status": "added",
      "additions": 58,
      "deletions": 0,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/gdb.fortran/array-slices.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/gdb.fortran/array-slices.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/array-slices.exp?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -0,0 +1,58 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/> .\n+\n+# Print a 2 dimensional assumed shape array.  We pass different slices\n+# of the array to a subroutine and print the array as recieved within\n+# the subroutine.  This should exercise GDB's ability to handle\n+# different strides for the different dimensions.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+\n+standard_testfile \".f90\"\n+\n+if {[prepare_for_testing ${testfile}.exp ${testfile} ${srcfile} \\\n+\t {debug f90}]} {\n+    return -1\n+}\n+\n+if ![runto_main] {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+gdb_breakpoint \"show\"\n+gdb_breakpoint [gdb_get_line_number \"Final Breakpoint\"]\n+\n+set array_contents \\\n+    [list \\\n+\t \" = \\\\(\\\\( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\\\\) \\\\( 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\\\\) \\\\( 21, 22, 23, 24, 25, 26, 27, 28, 29, 30\\\\) \\\\( 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\\\\) \\\\( 41, 42, 43, 44, 45, 46, 47, 48, 49, 50\\\\) \\\\( 51, 52, 53, 54, 55, 56, 57, 58, 59, 60\\\\) \\\\( 61, 62, 63, 64, 65, 66, 67, 68, 69, 70\\\\) \\\\( 71, 72, 73, 74, 75, 76, 77, 78, 79, 80\\\\) \\\\( 81, 82, 83, 84, 85, 86, 87, 88, 89, 90\\\\) \\\\( 91, 92, 93, 94, 95, 96, 97, 98, 99, 100\\\\) \\\\)\" \\\n+\t \" = \\\\(\\\\( 1, 2, 3, 4, 5\\\\) \\\\( 11, 12, 13, 14, 15\\\\) \\\\( 21, 22, 23, 24, 25\\\\) \\\\( 31, 32, 33, 34, 35\\\\) \\\\( 41, 42, 43, 44, 45\\\\) \\\\)\" \\\n+\t \" = \\\\(\\\\( 1, 3, 5, 7, 9\\\\) \\\\( 21, 23, 25, 27, 29\\\\) \\\\( 41, 43, 45, 47, 49\\\\) \\\\( 61, 63, 65, 67, 69\\\\) \\\\( 81, 83, 85, 87, 89\\\\) \\\\)\" \\\n+\t \" = \\\\(\\\\( 1, 4, 7, 10\\\\) \\\\( 21, 24, 27, 30\\\\) \\\\( 41, 44, 47, 50\\\\) \\\\( 61, 64, 67, 70\\\\) \\\\( 81, 84, 87, 90\\\\) \\\\)\" \\\n+\t \" = \\\\(\\\\( 1, 5, 9\\\\) \\\\( 31, 35, 39\\\\) \\\\( 61, 65, 69\\\\) \\\\( 91, 95, 99\\\\) \\\\)\" \\\n+\t \" = \\\\(\\\\( -26, -25, -24, -23, -22, -21, -20, -19, -18, -17\\\\) \\\\( -19, -18, -17, -16, -15, -14, -13, -12, -11, -10\\\\) \\\\( -12, -11, -10, -9, -8, -7, -6, -5, -4, -3\\\\) \\\\( -5, -4, -3, -2, -1, 0, 1, 2, 3, 4\\\\) \\\\( 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\\\\) \\\\( 9, 10, 11, 12, 13, 14, 15, 16, 17, 18\\\\) \\\\( 16, 17, 18, 19, 20, 21, 22, 23, 24, 25\\\\) \\\\( 23, 24, 25, 26, 27, 28, 29, 30, 31, 32\\\\) \\\\( 30, 31, 32, 33, 34, 35, 36, 37, 38, 39\\\\) \\\\( 37, 38, 39, 40, 41, 42, 43, 44, 45, 46\\\\) \\\\)\" \\\n+\t \" = \\\\(\\\\( -26, -25, -24, -23, -22, -21\\\\) \\\\( -19, -18, -17, -16, -15, -14\\\\) \\\\( -12, -11, -10, -9, -8, -7\\\\) \\\\)\" \\\n+\t \" = \\\\(\\\\( -26, -24, -22, -20, -18\\\\) \\\\( -5, -3, -1, 1, 3\\\\) \\\\( 16, 18, 20, 22, 24\\\\) \\\\( 37, 39, 41, 43, 45\\\\) \\\\)\" ]\n+\n+set i 0\n+foreach result $array_contents {\n+    incr i\n+    with_test_prefix \"test $i\" {\n+\tgdb_continue_to_breakpoint \"show\"\n+\tgdb_test \"p array\" $result\n+    }\n+}\n+\n+gdb_continue_to_breakpoint \"continue to Final Breakpoint\""
    },
    {
      "sha": "ec4e1eb3d7714a526131f0eaaa067857b0d051d6",
      "filename": "gdb/testsuite/gdb.fortran/array-slices.f90",
      "status": "added",
      "additions": 70,
      "deletions": 0,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/gdb.fortran/array-slices.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/gdb.fortran/array-slices.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/array-slices.f90?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -0,0 +1,70 @@\n+! Copyright 2019 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+subroutine show (message, array)\n+  character (len=*) :: message\n+  integer, dimension (:,:) :: array\n+\n+  print *, message\n+  do i=LBOUND (array, 2), UBOUND (array, 2), 1\n+     do j=LBOUND (array, 1), UBOUND (array, 1), 1\n+        write(*, fmt=\"(i4)\", advance=\"no\") array (j, i)\n+     end do\n+     print *, \"\"\n+ end do\n+ print *, array\n+ print *, \"\"\n+\n+end subroutine show\n+\n+program test\n+\n+  interface\n+     subroutine show (message, array)\n+       character (len=*) :: message\n+       integer, dimension(:,:) :: array\n+     end subroutine show\n+  end interface\n+\n+  integer, dimension (1:10,1:10) :: array\n+  integer, allocatable :: other (:, :)\n+\n+  allocate (other (-5:4, -2:7))\n+\n+  do i=LBOUND (array, 2), UBOUND (array, 2), 1\n+     do j=LBOUND (array, 1), UBOUND (array, 1), 1\n+        array (j,i) = ((i - 1) * UBOUND (array, 2)) + j\n+     end do\n+  end do\n+\n+  do i=LBOUND (other, 2), UBOUND (other, 2), 1\n+     do j=LBOUND (other, 1), UBOUND (other, 1), 1\n+        other (j,i) = ((i - 1) * UBOUND (other, 2)) + j\n+     end do\n+  end do\n+\n+  call show (\"array\", array)\n+  call show (\"array (1:5,1:5)\", array (1:5,1:5))\n+  call show (\"array (1:10:2,1:10:2)\", array (1:10:2,1:10:2))\n+  call show (\"array (1:10:3,1:10:2)\", array (1:10:3,1:10:2))\n+  call show (\"array (1:10:5,1:10:3)\", array (1:10:4,1:10:3))\n+\n+  call show (\"other\", other)\n+  call show (\"other (-5:0, -2:0)\", other (-5:0, -2:0))\n+  call show (\"other (-5:4:2, -2:7:3)\", other (-5:4:2, -2:7:3))\n+\n+  deallocate (other)\n+  print *, \"\" ! Final Breakpoint.\n+end program test"
    },
    {
      "sha": "a2590a9ab2f007e3cd30622ac0ba3058ccdf37e3",
      "filename": "gdb/testsuite/gdb.fortran/derived-type-striding.exp",
      "status": "added",
      "additions": 37,
      "deletions": 0,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/gdb.fortran/derived-type-striding.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/gdb.fortran/derived-type-striding.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/derived-type-striding.exp?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -0,0 +1,37 @@\n+# Copyright 2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/> .\n+\n+# Print some single dimensional integer arrays that will have a byte\n+# stride in the debug information.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+\n+standard_testfile \".f90\"\n+\n+if {[prepare_for_testing ${testfile}.exp ${testfile} ${srcfile} \\\n+\t {debug f90}]} {\n+    return -1\n+}\n+\n+if {![runto [gdb_get_line_number \"post_init\"]]} then {\n+    perror \"couldn't run to breakpoint post_init\"\n+    continue\n+}\n+\n+# Test homogeneous derived type.\n+gdb_test \"p point_dimension\" \"= \\\\\\(2, 2, 2, 2, 2, 2, 2, 2, 2\\\\\\)\"\n+\n+# Test mixed type derived type.\n+gdb_test \"p point_mixed_dimension\" \"= \\\\\\(3, 3, 3, 3\\\\\\)\""
    },
    {
      "sha": "8189ad3fdb8b79f9586cf279d7c2169f270a3c54",
      "filename": "gdb/testsuite/gdb.fortran/derived-type-striding.f90",
      "status": "added",
      "additions": 43,
      "deletions": 0,
      "changes": 43,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/gdb.fortran/derived-type-striding.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/testsuite/gdb.fortran/derived-type-striding.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/derived-type-striding.f90?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -0,0 +1,43 @@\n+! Copyright 2019 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+program derived_type_member_stride\n+    type cartesian\n+        integer(kind=8) :: x\n+        integer(kind=8) :: y\n+        integer(kind=8) :: z\n+    end type\n+    type mixed_cartesian\n+        integer(kind=8) :: x\n+        integer(kind=4) :: y\n+        integer(kind=8) :: z\n+    end type\n+    type(cartesian), dimension(10), target :: cloud\n+    type(mixed_cartesian), dimension(10), target :: mixed_cloud\n+    integer(kind=8), dimension(:), pointer :: point_dimension => null()\n+    integer(kind=8), dimension(:), pointer :: point_mixed_dimension => null()\n+    cloud(:)%x = 1\n+    cloud(:)%y = 2\n+    cloud(:)%z = 3\n+    point_dimension => cloud(1:9)%y\n+    mixed_cloud(:)%x = 1\n+    mixed_cloud(:)%y = 2\n+    mixed_cloud(:)%z = 3\n+    point_mixed_dimension => mixed_cloud(1:4)%z\n+    ! Prevent the compiler from optimising the work out.\n+    print *, cloud(:)%x ! post_init\n+    print *, point_dimension\n+    print *, point_mixed_dimension\n+end program"
    },
    {
      "sha": "4920cfc18a606bce21ddea4890b1845bc55c4022",
      "filename": "gdb/valarith.c",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/valarith.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41/gdb/valarith.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/valarith.c?ref=5bbd8269fa8d138e8ea1dd3c8cdf42412c1dfa41",
      "patch": "@@ -188,6 +188,17 @@ value_subscripted_rvalue (struct value *array, LONGEST index, LONGEST lowerbound\n   struct type *array_type = check_typedef (value_type (array));\n   struct type *elt_type = check_typedef (TYPE_TARGET_TYPE (array_type));\n   ULONGEST elt_size = type_length_units (elt_type);\n+\n+  /* Fetch the bit stride and convert it to a byte stride, assuming 8 bits\n+     in a byte.  */\n+  LONGEST stride = TYPE_ARRAY_BIT_STRIDE (array_type);\n+  if (stride != 0)\n+    {\n+      struct gdbarch *arch = get_type_arch (elt_type);\n+      int unit_size = gdbarch_addressable_memory_unit_size (arch);\n+      elt_size = stride / (unit_size * 8);\n+    }\n+\n   ULONGEST elt_offs = elt_size * (index - lowerbound);\n \n   if (index < lowerbound"
    }
  ]
}