{
  "sha": "832a580781060f54731fcf654d76ac1332037a47",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ODMyYTU4MDc4MTA2MGY1NDczMWZjZjY1NGQ3NmFjMTMzMjAzN2E0Nw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-26T05:56:16Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-03-26T09:32:42Z"
    },
    "message": "Re: H8300 use of uninitialised value\n\nThis patch also had some problems.  Calculation of maxlen was wrong,\nand the insn arg loop needed rearranging to work with a correct length.\n\n\t* disassemble.h (opcodes_assert): Declare.\n\t(OPCODES_ASSERT): Define.\n\t* disassemble.c: Don't include assert.h.  Include opintl.h.\n\t(opcodes_assert): New function.\n\t* h8300-dis.c (bfd_h8_disassemble_init): Use OPCODES_ASSERT.\n\t(bfd_h8_disassemble): Reduce size of data array.  Correctly\n\tcalculate maxlen.  Omit insn decoding when insn length exceeds\n\tmaxlen.  Exit from nibble loop when looking for E, before\n\taccessing next data byte.  Move processing of E outside loop.\n\tReplace tests of maxlen in loop with assertions.",
    "tree": {
      "sha": "c1bcb32db186241befa7a78ceec2d2b2cc31e457",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c1bcb32db186241befa7a78ceec2d2b2cc31e457"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/832a580781060f54731fcf654d76ac1332037a47",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/832a580781060f54731fcf654d76ac1332037a47",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/832a580781060f54731fcf654d76ac1332037a47",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/832a580781060f54731fcf654d76ac1332037a47/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ff7685105468702de87b75599b1ea88cc309541c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ff7685105468702de87b75599b1ea88cc309541c",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ff7685105468702de87b75599b1ea88cc309541c"
    }
  ],
  "stats": {
    "total": 278,
    "additions": 152,
    "deletions": 126
  },
  "files": [
    {
      "sha": "17e34174516434677fcd492c31880d8065e59475",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/832a580781060f54731fcf654d76ac1332037a47/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/832a580781060f54731fcf654d76ac1332037a47/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=832a580781060f54731fcf654d76ac1332037a47",
      "patch": "@@ -1,3 +1,16 @@\n+2020-03-26  Alan Modra  <amodra@gmail.com>\n+\n+\t* disassemble.h (opcodes_assert): Declare.\n+\t(OPCODES_ASSERT): Define.\n+\t* disassemble.c: Don't include assert.h.  Include opintl.h.\n+\t(opcodes_assert): New function.\n+\t* h8300-dis.c (bfd_h8_disassemble_init): Use OPCODES_ASSERT.\n+\t(bfd_h8_disassemble): Reduce size of data array.  Correctly\n+\tcalculate maxlen.  Omit insn decoding when insn length exceeds\n+\tmaxlen.  Exit from nibble loop when looking for E, before\n+\taccessing next data byte.  Move processing of E outside loop.\n+\tReplace tests of maxlen in loop with assertions.\n+\n 2020-03-26  Alan Modra  <amodra@gmail.com>\n \n \t* arc-dis.c (find_format): Init needs_limm.  Simplify use of limm."
    },
    {
      "sha": "25816efb56cc823f2a10c70daa5bc48ada1b6209",
      "filename": "opcodes/disassemble.c",
      "status": "modified",
      "additions": 9,
      "deletions": 1,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/832a580781060f54731fcf654d76ac1332037a47/opcodes/disassemble.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/832a580781060f54731fcf654d76ac1332037a47/opcodes/disassemble.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/disassemble.c?ref=832a580781060f54731fcf654d76ac1332037a47",
      "patch": "@@ -21,7 +21,7 @@\n #include \"sysdep.h\"\n #include \"disassemble.h\"\n #include \"safe-ctype.h\"\n-#include <assert.h>\n+#include \"opintl.h\"\n \n #ifdef ARCH_all\n #define ARCH_aarch64\n@@ -832,3 +832,11 @@ disassembler_options_cmp (const char *s1, const char *s2)\n \n   return c1 - c2;\n }\n+\n+void\n+opcodes_assert (const char *file, int line)\n+{\n+  opcodes_error_handler (_(\"assertion fail %s:%d\"), file, line);\n+  opcodes_error_handler (_(\"Please report this bug\"));\n+  abort ();\n+}"
    },
    {
      "sha": "89db88640572c20e48d89a450d546973f3623f8b",
      "filename": "opcodes/disassemble.h",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/832a580781060f54731fcf654d76ac1332037a47/opcodes/disassemble.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/832a580781060f54731fcf654d76ac1332037a47/opcodes/disassemble.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/disassemble.h?ref=832a580781060f54731fcf654d76ac1332037a47",
      "patch": "@@ -103,4 +103,10 @@ extern int print_insn_z8002\t\t(bfd_vma, disassemble_info *);\n \n extern disassembler_ftype csky_get_disassembler (bfd *);\n extern disassembler_ftype rl78_get_disassembler (bfd *);\n+\n+extern void ATTRIBUTE_NORETURN opcodes_assert (const char *, int);\n+\n+#define OPCODES_ASSERT(x) \\\n+  do { if (!(x)) opcodes_assert (__FILE__, __LINE__); } while (0)\n+\n #endif /* DISASSEMBLE_H */"
    },
    {
      "sha": "f56ad86771dd892d6bb66f579b35d48c53579dff",
      "filename": "opcodes/h8300-dis.c",
      "status": "modified",
      "additions": 124,
      "deletions": 125,
      "changes": 249,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/832a580781060f54731fcf654d76ac1332037a47/opcodes/h8300-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/832a580781060f54731fcf654d76ac1332037a47/opcodes/h8300-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/h8300-dis.c?ref=832a580781060f54731fcf654d76ac1332037a47",
      "patch": "@@ -29,7 +29,7 @@\n \n struct h8_instruction\n {\n-  int length;\n+  unsigned int length;\n   const struct h8_opcode *opcode;\n };\n \n@@ -56,13 +56,7 @@ bfd_h8_disassemble_init (void)\n \t that the count is the same as the length.  */\n       for (i = 0; p->data.nib[i] != (op_type) E; i++)\n \t;\n-\n-      if (i & 1)\n-\t{\n-\t  /* xgettext:c-format */\n-\t  opcodes_error_handler (_(\"internal error, h8_disassemble_init\"));\n-\t  abort ();\n-\t}\n+      OPCODES_ASSERT (!(i & 1));\n \n       pi->length = i / 2;\n       pi->opcode = p;\n@@ -328,7 +322,7 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n   char const **pregnames = mach != 0 ? lregnames : wregnames;\n   int status;\n   unsigned int maxlen;\n-  unsigned char data[MAX_CODE_NIBBLES];\n+  unsigned char data[MAX_CODE_NIBBLES / 2];\n   void *stream = info->stream;\n   fprintf_ftype outfn = info->fprintf_func;\n \n@@ -345,22 +339,34 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n       return -1;\n     }\n \n-  for (maxlen = 2; status == 0 && maxlen < sizeof (data) / 2; maxlen += 2)\n-    status = info->read_memory_func (addr + maxlen, data + maxlen, 2, info);\n+  for (maxlen = 2; maxlen < sizeof (data); maxlen += 2)\n+    {\n+      status = info->read_memory_func (addr + maxlen, data + maxlen, 2, info);\n+      if (status != 0)\n+\tbreak;\n+    }\n \n   /* Find the exact opcode/arg combo.  */\n   for (qi = h8_instructions; qi->opcode->name; qi++)\n     {\n-      const struct h8_opcode *q = qi->opcode;\n-      const op_type *nib = q->data.nib;\n-      unsigned int len = 0;\n-\n-      while (len / 2 < maxlen)\n+      const struct h8_opcode *q;\n+      const op_type *nib;\n+      unsigned int len;\n+      op_type looking_for;\n+\n+      if (qi->length > maxlen)\n+\tcontinue;\n+\n+      q = qi->opcode;\n+      nib = q->data.nib;\n+      len = 0;\n+      while ((looking_for = *nib) != (op_type) E)\n \t{\n-\t  op_type looking_for = *nib;\n-\t  int thisnib = data[len / 2];\n+\t  int thisnib;\n \t  int opnr;\n \n+\t  OPCODES_ASSERT (len / 2 < maxlen);\n+\t  thisnib = data[len / 2];\n \t  thisnib = (len & 1) ? (thisnib & 0xf) : ((thisnib / 16) & 0xf);\n \t  opnr = ((looking_for & OP3) == OP3 ? 2\n \t\t  : (looking_for & DST) == DST ? 1 : 0);\n@@ -476,8 +482,7 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n \t\t      extra = 0;\n \t\t      break;\n \t\t    }\n-\t\t  if (len / 2 + extra >= maxlen)\n-\t\t    break;\n+\t\t  OPCODES_ASSERT (len / 2 + extra < maxlen);\n \t\t  extract_immediate (stream, looking_for, thisnib,\n \t\t\t\t     data + len / 2, cst + opnr,\n \t\t\t\t     cstlen + opnr, q);\n@@ -532,8 +537,7 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n \t      else if ((looking_for & SIZE) == L_16\n \t\t       || (looking_for & SIZE) == L_16U)\n \t\t{\n-\t\t  if (len / 2 + 1 >= maxlen)\n-\t\t    break;\n+\t\t  OPCODES_ASSERT (len / 2 + 1 < maxlen);\n \t\t  cst[opnr] = (data[len / 2]) * 256 + data[(len + 2) / 2];\n \t\t  cstlen[opnr] = 16;\n \t\t}\n@@ -549,8 +553,7 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n \t\t{\n \t\t  unsigned int i = len / 2;\n \n-\t\t  if (i + 3 >= maxlen)\n-\t\t    break;\n+\t\t  OPCODES_ASSERT (i + 3 < maxlen);\n \t\t  cst[opnr] = (((unsigned) data[i] << 24)\n \t\t\t       | (data[i + 1] << 16)\n \t\t\t       | (data[i + 2] << 8)\n@@ -562,8 +565,7 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n \t\t{\n \t\t  unsigned int i = len / 2;\n \n-\t\t  if (i + 2 >= maxlen)\n-\t\t    break;\n+\t\t  OPCODES_ASSERT (i + 2 < maxlen);\n \t\t  cst[opnr] =\n \t\t    (data[i] << 16) | (data[i + 1] << 8) | (data[i + 2]);\n \t\t  cstlen[opnr] = 24;\n@@ -610,105 +612,6 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n \t\t{\n \t\t  cst[opnr] = (thisnib == 3);\n \t\t}\n-\t      else if (looking_for == (op_type) E)\n-\t\t{\n-\t\t  outfn (stream, \"%s\\t\", q->name);\n-\n-\t\t  /* Gross.  Disgusting.  */\n-\t\t  if (strcmp (q->name, \"ldm.l\") == 0)\n-\t\t    {\n-\t\t      int count, high;\n-\n-\t\t      count = (data[1] / 16) & 0x3;\n-\t\t      high = regno[1];\n-\n-\t\t      outfn (stream, \"@sp+,er%d-er%d\", high - count, high);\n-\t\t      return qi->length;\n-\t\t    }\n-\n-\t\t  if (strcmp (q->name, \"stm.l\") == 0)\n-\t\t    {\n-\t\t      int count, low;\n-\n-\t\t      count = (data[1] / 16) & 0x3;\n-\t\t      low = regno[0];\n-\n-\t\t      outfn (stream, \"er%d-er%d,@-sp\", low, low + count);\n-\t\t      return qi->length;\n-\t\t    }\n-\t\t  if (strcmp (q->name, \"rte/l\") == 0\n-\t\t      || strcmp (q->name, \"rts/l\") == 0)\n-\t\t    {\n-\t\t      if (regno[0] == 0)\n-\t\t\toutfn (stream, \"er%d\", regno[1]);\n-\t\t      else\n-\t\t\toutfn (stream, \"er%d-er%d\", regno[1] - regno[0],\n-\t\t\t       regno[1]);\n-\t\t      return qi->length;\n-\t\t    }\n-\t\t  if (CONST_STRNEQ (q->name, \"mova\"))\n-\t\t    {\n-\t\t      const op_type *args = q->args.nib;\n-\n-\t\t      if (args[1] == (op_type) E)\n-\t\t\t{\n-\t\t\t  /* Short form.  */\n-\t\t\t  print_one_arg (info, addr, args[0], cst[0],\n-\t\t\t\t\t cstlen[0], dispregno[0], regno[0],\n-\t\t\t\t\t pregnames, qi->length);\n-\t\t\t  outfn (stream, \",er%d\", dispregno[0]);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  outfn (stream, \"@(0x%x:%d,\", cst[0], cstlen[0]);\n-\t\t\t  print_one_arg (info, addr, args[1], cst[1],\n-\t\t\t\t\t cstlen[1], dispregno[1], regno[1],\n-\t\t\t\t\t pregnames, qi->length);\n-\t\t\t  outfn (stream, \".%c),\",\n-\t\t\t\t (args[0] & MODE) == INDEXB ? 'b' : 'w');\n-\t\t\t  print_one_arg (info, addr, args[2], cst[2],\n-\t\t\t\t\t cstlen[2], dispregno[2], regno[2],\n-\t\t\t\t\t pregnames, qi->length);\n-\t\t\t}\n-\t\t      return qi->length;\n-\t\t    }\n-\t\t  /* Fill in the args.  */\n-\t\t  {\n-\t\t    const op_type *args = q->args.nib;\n-\t\t    int hadone = 0;\n-\t\t    int nargs;\n-\n-\t\t    /* Special case handling for the adds and subs instructions\n-\t\t       since in H8 mode thay can only take the r0-r7 registers\n-\t\t       but in other (higher) modes they can take the er0-er7\n-\t\t       registers as well.  */\n-\t\t    if (strcmp (qi->opcode->name, \"adds\") == 0\n-\t\t\t|| strcmp (qi->opcode->name, \"subs\") == 0)\n-\t\t      {\n-\t\t\toutfn (stream, \"#%d,%s\", cst[0], pregnames[regno[1] & 0x7]);\n-\t\t\treturn qi->length;\n-\t\t      }\n-\n-\t\t    for (nargs = 0;\n-\t\t\t nargs < 3 && args[nargs] != (op_type) E;\n-\t\t\t nargs++)\n-\t\t      {\n-\t\t\tint x = args[nargs];\n-\n-\t\t\tif (hadone)\n-\t\t\t  outfn (stream, \",\");\n-\n-\t\t\tprint_one_arg (info, addr, x,\n-\t\t\t\t       cst[nargs], cstlen[nargs],\n-\t\t\t\t       dispregno[nargs], regno[nargs],\n-\t\t\t\t       pregnames, qi->length);\n-\n-\t\t\thadone = 1;\n-\t\t      }\n-\t\t  }\n-\n-\t\t  return qi->length;\n-\t\t}\n \t      else\n \t\t/* xgettext:c-format */\n \t\toutfn (stream, _(\"Don't understand 0x%x \\n\"), looking_for);\n@@ -718,6 +621,102 @@ bfd_h8_disassemble (bfd_vma addr, disassemble_info *info, int mach)\n \t  nib++;\n \t}\n \n+      outfn (stream, \"%s\\t\", q->name);\n+\n+      /* Gross.  Disgusting.  */\n+      if (strcmp (q->name, \"ldm.l\") == 0)\n+\t{\n+\t  int count, high;\n+\n+\t  count = (data[1] / 16) & 0x3;\n+\t  high = regno[1];\n+\n+\t  outfn (stream, \"@sp+,er%d-er%d\", high - count, high);\n+\t  return qi->length;\n+\t}\n+\n+      if (strcmp (q->name, \"stm.l\") == 0)\n+\t{\n+\t  int count, low;\n+\n+\t  count = (data[1] / 16) & 0x3;\n+\t  low = regno[0];\n+\n+\t  outfn (stream, \"er%d-er%d,@-sp\", low, low + count);\n+\t  return qi->length;\n+\t}\n+      if (strcmp (q->name, \"rte/l\") == 0\n+\t  || strcmp (q->name, \"rts/l\") == 0)\n+\t{\n+\t  if (regno[0] == 0)\n+\t    outfn (stream, \"er%d\", regno[1]);\n+\t  else\n+\t    outfn (stream, \"er%d-er%d\", regno[1] - regno[0],\n+\t\t   regno[1]);\n+\t  return qi->length;\n+\t}\n+      if (CONST_STRNEQ (q->name, \"mova\"))\n+\t{\n+\t  const op_type *args = q->args.nib;\n+\n+\t  if (args[1] == (op_type) E)\n+\t    {\n+\t      /* Short form.  */\n+\t      print_one_arg (info, addr, args[0], cst[0],\n+\t\t\t     cstlen[0], dispregno[0], regno[0],\n+\t\t\t     pregnames, qi->length);\n+\t      outfn (stream, \",er%d\", dispregno[0]);\n+\t    }\n+\t  else\n+\t    {\n+\t      outfn (stream, \"@(0x%x:%d,\", cst[0], cstlen[0]);\n+\t      print_one_arg (info, addr, args[1], cst[1],\n+\t\t\t     cstlen[1], dispregno[1], regno[1],\n+\t\t\t     pregnames, qi->length);\n+\t      outfn (stream, \".%c),\",\n+\t\t     (args[0] & MODE) == INDEXB ? 'b' : 'w');\n+\t      print_one_arg (info, addr, args[2], cst[2],\n+\t\t\t     cstlen[2], dispregno[2], regno[2],\n+\t\t\t     pregnames, qi->length);\n+\t    }\n+\t  return qi->length;\n+\t}\n+      /* Fill in the args.  */\n+      {\n+\tconst op_type *args = q->args.nib;\n+\tint hadone = 0;\n+\tint nargs;\n+\n+\t/* Special case handling for the adds and subs instructions\n+\t   since in H8 mode thay can only take the r0-r7 registers\n+\t   but in other (higher) modes they can take the er0-er7\n+\t   registers as well.  */\n+\tif (strcmp (qi->opcode->name, \"adds\") == 0\n+\t    || strcmp (qi->opcode->name, \"subs\") == 0)\n+\t  {\n+\t    outfn (stream, \"#%d,%s\", cst[0], pregnames[regno[1] & 0x7]);\n+\t    return qi->length;\n+\t  }\n+\n+\tfor (nargs = 0;\n+\t     nargs < 3 && args[nargs] != (op_type) E;\n+\t     nargs++)\n+\t  {\n+\t    int x = args[nargs];\n+\n+\t    if (hadone)\n+\t      outfn (stream, \",\");\n+\n+\t    print_one_arg (info, addr, x,\n+\t\t\t   cst[nargs], cstlen[nargs],\n+\t\t\t   dispregno[nargs], regno[nargs],\n+\t\t\t   pregnames, qi->length);\n+\n+\t    hadone = 1;\n+\t  }\n+      }\n+      return qi->length;\n+\n     fail:\n       ;\n     }"
    }
  ]
}