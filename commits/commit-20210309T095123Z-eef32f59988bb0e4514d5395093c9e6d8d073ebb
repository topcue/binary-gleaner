{
  "sha": "eef32f59988bb0e4514d5395093c9e6d8d073ebb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZWVmMzJmNTk5ODhiYjBlNDUxNGQ1Mzk1MDkzYzllNmQ4ZDA3M2ViYg==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-02-26T11:14:24Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2021-03-09T09:51:23Z"
    },
    "message": "gdb/fotran: add support for the 'shape' keyword\n\nAdd support for the SHAPE keyword to GDB's Fortran expression parser.\n\ngdb/ChangeLog:\n\n\t* f-exp.h (eval_op_f_array_shape): Declare.\n\t(fortran_array_shape_operation): New type.\n\t* f-exp.y (exp): Handle UNOP_FORTRAN_SHAPE after parsing\n\tUNOP_INTRINSIC.\n\t(f77_keywords): Add \"shape\" keyword.\n\t* f-lang.c (fortran_array_shape): New function.\n\t(eval_op_f_array_shape): New function.\n\t* std-operator.def (UNOP_FORTRAN_SHAPE): New operator.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.fortran/shape.exp: New file.\n\t* gdb.fortran/shape.f90: New file.",
    "tree": {
      "sha": "df32c5ce71179b0e9d405c10b6c0704443ee1cb1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/df32c5ce71179b0e9d405c10b6c0704443ee1cb1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/eef32f59988bb0e4514d5395093c9e6d8d073ebb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/eef32f59988bb0e4514d5395093c9e6d8d073ebb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/eef32f59988bb0e4514d5395093c9e6d8d073ebb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/eef32f59988bb0e4514d5395093c9e6d8d073ebb/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "7ba155b37073a3512c85f1d7f12dbaed9a6db3e2",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7ba155b37073a3512c85f1d7f12dbaed9a6db3e2",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/7ba155b37073a3512c85f1d7f12dbaed9a6db3e2"
    }
  ],
  "stats": {
    "total": 277,
    "additions": 277,
    "deletions": 0
  },
  "files": [
    {
      "sha": "6ed71c2724b35a020ae38df99390d28ee8ae3f7a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=eef32f59988bb0e4514d5395093c9e6d8d073ebb",
      "patch": "@@ -1,3 +1,14 @@\n+2021-03-09  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* f-exp.h (eval_op_f_array_shape): Declare.\n+\t(fortran_array_shape_operation): New type.\n+\t* f-exp.y (exp): Handle UNOP_FORTRAN_SHAPE after parsing\n+\tUNOP_INTRINSIC.\n+\t(f77_keywords): Add \"shape\" keyword.\n+\t* f-lang.c (fortran_array_shape): New function.\n+\t(eval_op_f_array_shape): New function.\n+\t* std-operator.def (UNOP_FORTRAN_SHAPE): New operator.\n+\n 2021-03-09  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* f-exp.y (eval_op_f_array_size): Declare 1 and 2 argument forms"
    },
    {
      "sha": "11f19af979f76de332fa9c21f61d895529e19e05",
      "filename": "gdb/f-exp.h",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/f-exp.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/f-exp.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.h?ref=eef32f59988bb0e4514d5395093c9e6d8d073ebb",
      "patch": "@@ -108,6 +108,16 @@ extern struct value *eval_op_f_array_size (struct type *expect_type,\n \t\t\t\t\t   struct value *arg1,\n \t\t\t\t\t   struct value *arg2);\n \n+/* Implement the evaluation of Fortran's SHAPE keyword.  EXPECTED_TYPE,\n+   EXP, and NOSIDE are as for expression::evaluate (see expression.h).  OP\n+   will always be UNOP_FORTRAN_SHAPE, and ARG1 is the argument being passed\n+   to the expression.  */\n+\n+extern struct value *eval_op_f_array_shape (struct type *expect_type,\n+\t\t\t\t\t    struct expression *exp,\n+\t\t\t\t\t    enum noside noside,\n+\t\t\t\t\t    enum exp_opcode op,\n+\t\t\t\t\t    struct value *arg1);\n \n namespace expr\n {\n@@ -135,6 +145,8 @@ using fortran_array_size_1arg = unop_operation<FORTRAN_ARRAY_SIZE,\n \t\t\t\t\t       eval_op_f_array_size>;\n using fortran_array_size_2arg = binop_operation<FORTRAN_ARRAY_SIZE,\n \t\t\t\t\t\teval_op_f_array_size>;\n+using fortran_array_shape_operation = unop_operation<UNOP_FORTRAN_SHAPE,\n+\t\t\t\t\t\t     eval_op_f_array_shape>;\n \n /* The Fortran \"complex\" operation.  */\n class fortran_cmplx_operation"
    },
    {
      "sha": "dcc28b8e600567803c38c37db92dedcd2e98af50",
      "filename": "gdb/f-exp.y",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/f-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/f-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-exp.y?ref=eef32f59988bb0e4514d5395093c9e6d8d073ebb",
      "patch": "@@ -330,6 +330,9 @@ exp\t:\tUNOP_INTRINSIC '(' exp ')'\n \t\t\t    case UNOP_FORTRAN_RANK:\n \t\t\t      pstate->wrap<fortran_rank_operation> ();\n \t\t\t      break;\n+\t\t\t    case UNOP_FORTRAN_SHAPE:\n+\t\t\t      pstate->wrap<fortran_array_shape_operation> ();\n+\t\t\t      break;\n \t\t\t    default:\n \t\t\t      gdb_assert_not_reached (\"unhandled intrinsic\");\n \t\t\t    }\n@@ -1151,6 +1154,7 @@ static const struct token f77_keywords[] =\n   { \"associated\", UNOP_OR_BINOP_INTRINSIC, FORTRAN_ASSOCIATED, false },\n   { \"rank\", UNOP_INTRINSIC, UNOP_FORTRAN_RANK, false },\n   { \"size\", UNOP_OR_BINOP_INTRINSIC, FORTRAN_ARRAY_SIZE, false },\n+  { \"shape\", UNOP_INTRINSIC, UNOP_FORTRAN_SHAPE, false },\n };\n \n /* Implementation of a dynamically expandable buffer for processing input"
    },
    {
      "sha": "d79c458c5e0be14f8f0955c213a79f73a72f1dc5",
      "filename": "gdb/f-lang.c",
      "status": "modified",
      "additions": 81,
      "deletions": 0,
      "changes": 81,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/f-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/f-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/f-lang.c?ref=eef32f59988bb0e4514d5395093c9e6d8d073ebb",
      "patch": "@@ -675,6 +675,87 @@ eval_op_f_array_size (struct type *expect_type,\n   return fortran_array_size (exp->gdbarch, exp->language_defn, arg1, arg2);\n }\n \n+/* Implement UNOP_FORTRAN_SHAPE expression.  Both GDBARCH and LANG are\n+   extracted from the expression being evaluated.  VAL is the value on\n+   which 'shape' was used, this can be any type.\n+\n+   Return an array of integers.  If VAL is not an array then the returned\n+   array should have zero elements.  If VAL is an array then the returned\n+   array should have one element per dimension, with the element\n+   containing the extent of that dimension from VAL.  */\n+\n+static struct value *\n+fortran_array_shape (struct gdbarch *gdbarch, const language_defn *lang,\n+\t\t     struct value *val)\n+{\n+  struct type *val_type = check_typedef (value_type (val));\n+\n+  /* If we are passed an array that is either not allocated, or not\n+     associated, then this is explicitly not allowed according to the\n+     Fortran specification.  */\n+  if (val_type->code () == TYPE_CODE_ARRAY\n+      && (type_not_associated (val_type) || type_not_allocated (val_type)))\n+    error (_(\"The array passed to SHAPE must be allocated or associated\"));\n+\n+  /* The Fortran specification allows non-array types to be passed to this\n+     function, in which case we get back an empty array.\n+\n+     Calculate the number of dimensions for the resulting array.  */\n+  int ndimensions = 0;\n+  if (val_type->code () == TYPE_CODE_ARRAY)\n+    ndimensions = calc_f77_array_dims (val_type);\n+\n+  /* Allocate a result value of the correct type.  */\n+  struct type *range\n+    = create_static_range_type (nullptr,\n+\t\t\t\tbuiltin_type (gdbarch)->builtin_int,\n+\t\t\t\t1, ndimensions);\n+  struct type *elm_type = builtin_f_type (gdbarch)->builtin_integer;\n+  struct type *result_type = create_array_type (nullptr, elm_type, range);\n+  struct value *result = allocate_value (result_type);\n+  LONGEST elm_len = TYPE_LENGTH (elm_type);\n+\n+  /* Walk the array dimensions backwards due to the way the array will be\n+     laid out in memory, the first dimension will be the most inner.\n+\n+     If VAL was not an array then ndimensions will be 0, in which case we\n+     will never go around this loop.  */\n+  for (LONGEST dst_offset = elm_len * (ndimensions - 1);\n+       dst_offset >= 0;\n+       dst_offset -= elm_len)\n+    {\n+      LONGEST lbound, ubound;\n+\n+      if (!get_discrete_bounds (val_type->index_type (), &lbound, &ubound))\n+\terror (_(\"failed to find array bounds\"));\n+\n+      LONGEST dim_size = (ubound - lbound + 1);\n+\n+      /* And copy the value into the result value.  */\n+      struct value *v = value_from_longest (elm_type, dim_size);\n+      gdb_assert (dst_offset + TYPE_LENGTH (value_type (v))\n+\t\t  <= TYPE_LENGTH (value_type (result)));\n+      gdb_assert (TYPE_LENGTH (value_type (v)) == elm_len);\n+      value_contents_copy (result, dst_offset, v, 0, elm_len);\n+\n+      /* Peel another dimension of the array.  */\n+      val_type = TYPE_TARGET_TYPE (val_type);\n+    }\n+\n+  return result;\n+}\n+\n+/* See f-exp.h.  */\n+\n+struct value *\n+eval_op_f_array_shape (struct type *expect_type, struct expression *exp,\n+\t\t       enum noside noside, enum exp_opcode opcode,\n+\t\t       struct value *arg1)\n+{\n+  gdb_assert (opcode == UNOP_FORTRAN_SHAPE);\n+  return fortran_array_shape (exp->gdbarch, exp->language_defn, arg1);\n+}\n+\n /* A helper function for UNOP_ABS.  */\n \n struct value *"
    },
    {
      "sha": "1b8581f319e583943684d2620b47ee957d769a9d",
      "filename": "gdb/std-operator.def",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/std-operator.def",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/std-operator.def",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/std-operator.def?ref=eef32f59988bb0e4514d5395093c9e6d8d073ebb",
      "patch": "@@ -379,6 +379,7 @@ OP (UNOP_FORTRAN_FLOOR)\n OP (UNOP_FORTRAN_CEILING)\n OP (UNOP_FORTRAN_ALLOCATED)\n OP (UNOP_FORTRAN_RANK)\n+OP (UNOP_FORTRAN_SHAPE)\n \n /* Two operand builtins.  */\n OP (BINOP_FORTRAN_CMPLX)"
    },
    {
      "sha": "ea1401c52c31bc7f606783925b7648ce61045aec",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=eef32f59988bb0e4514d5395093c9e6d8d073ebb",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-09  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gdb.fortran/shape.exp: New file.\n+\t* gdb.fortran/shape.f90: New file.\n+\n 2021-03-09  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb.fortran/size.exp: New file."
    },
    {
      "sha": "0c41b7b23260acc495e681fe0802f33a4c9d9b0d",
      "filename": "gdb/testsuite/gdb.fortran/shape.exp",
      "status": "added",
      "additions": 86,
      "deletions": 0,
      "changes": 86,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/testsuite/gdb.fortran/shape.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/testsuite/gdb.fortran/shape.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/shape.exp?ref=eef32f59988bb0e4514d5395093c9e6d8d073ebb",
      "patch": "@@ -0,0 +1,86 @@\n+# Copyright 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/> .\n+\n+# Testing GDB's implementation of SHAPE keyword.\n+\n+if {[skip_fortran_tests]} { return -1 }\n+\n+standard_testfile \".f90\"\n+load_lib fortran.exp\n+\n+if {[prepare_for_testing ${testfile}.exp ${testfile} ${srcfile} \\\n+\t {debug f90}]} {\n+    return -1\n+}\n+\n+if ![fortran_runto_main] {\n+    untested \"could not run to main\"\n+    return -1\n+}\n+\n+gdb_breakpoint [gdb_get_line_number \"Test Breakpoint\"]\n+gdb_breakpoint [gdb_get_line_number \"Final Breakpoint\"]\n+\n+# We place a limit on the number of tests that can be run, just in\n+# case something goes wrong, and GDB gets stuck in an loop here.\n+set found_final_breakpoint false\n+set test_count 0\n+while { $test_count < 500 } {\n+    with_test_prefix \"test $test_count\" {\n+\tincr test_count\n+\n+\tgdb_test_multiple \"continue\" \"continue\" {\n+\t    -re -wrap \"! Test Breakpoint\" {\n+\t\t# We can run a test from here.\n+\t    }\n+\t    -re -wrap \"! Final Breakpoint\" {\n+\t\t# We're done with the tests.\n+\t\tset found_final_breakpoint true\n+\t    }\n+\t}\n+\n+\tif ($found_final_breakpoint) {\n+\t    break\n+\t}\n+\n+\t# First grab the expected answer.\n+\tset answer [get_valueof \"\" \"answer\" \"**unknown**\"]\n+\n+\t# Now move up a frame and figure out a command for us to run\n+\t# as a test.\n+\tset command \"\"\n+\tgdb_test_multiple \"up\" \"up\" {\n+\t    -re -wrap \"\\r\\n\\[0-9\\]+\\[ \\t\\]+call test_shape \\\\((\\[^\\r\\n\\]+)\\\\)\" {\n+\t\tset command $expect_out(1,string)\n+\t    }\n+\t}\n+\n+\tgdb_assert { ![string equal $command \"\"] } \"found a command to run\"\n+\n+\tset answer [string_to_regexp $answer]\n+\tgdb_test \"p $command\" \" = $answer\"\n+    }\n+}\n+\n+# Ensure we reached the final breakpoint.  If more tests have been added\n+# to the test script, and this starts failing, then the safety 'while'\n+# loop above might need to be increased.\n+gdb_assert {$found_final_breakpoint} \"ran all compiled in tests\"\n+\n+foreach var {array_1d_p array_2d_p allocatable_array_1d \\\n+\t\t allocatable_array_2d} {\n+    gdb_test \"p shape ($var)\" \\\n+\t\"The array passed to SHAPE must be allocated or associated\"\n+}"
    },
    {
      "sha": "1a1b3f06505785fff57e59291b7a4cbe777468ec",
      "filename": "gdb/testsuite/gdb.fortran/shape.f90",
      "status": "added",
      "additions": 77,
      "deletions": 0,
      "changes": 77,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/testsuite/gdb.fortran/shape.f90",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/eef32f59988bb0e4514d5395093c9e6d8d073ebb/gdb/testsuite/gdb.fortran/shape.f90",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.fortran/shape.f90?ref=eef32f59988bb0e4514d5395093c9e6d8d073ebb",
      "patch": "@@ -0,0 +1,77 @@\n+! Copyright 2021 Free Software Foundation, Inc.\n+!\n+! This program is free software; you can redistribute it and/or modify\n+! it under the terms of the GNU General Public License as published by\n+! the Free Software Foundation; either version 3 of the License, or\n+! (at your option) any later version.\n+!\n+! This program is distributed in the hope that it will be useful,\n+! but WITHOUT ANY WARRANTY; without even the implied warranty of\n+! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+! GNU General Public License for more details.\n+!\n+! You should have received a copy of the GNU General Public License\n+! along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+!\n+! Start of test program.\n+!\n+program test\n+\n+  ! Things to perform tests on.\n+  integer, target :: array_1d (1:10) = 0\n+  integer, target :: array_2d (1:4, 1:3) = 0\n+  integer :: an_integer = 0\n+  real :: a_real = 0.0\n+  integer, pointer :: array_1d_p (:) => null ()\n+  integer, pointer :: array_2d_p (:,:) => null ()\n+  integer, allocatable :: allocatable_array_1d (:)\n+  integer, allocatable :: allocatable_array_2d (:,:)\n+\n+  call test_shape (shape (array_1d))\n+  call test_shape (shape (array_2d))\n+  call test_shape (shape (an_integer))\n+  call test_shape (shape (a_real))\n+\n+  call test_shape (shape (array_1d (1:10:2)))\n+  call test_shape (shape (array_1d (1:10:3)))\n+\n+  call test_shape (shape (array_2d (4:1:-1, 3:1:-1)))\n+  call test_shape (shape (array_2d (4:1:-1, 1:3:2)))\n+\n+  allocate (allocatable_array_1d (-10:-5))\n+  allocate (allocatable_array_2d (-3:3, 8:12))\n+\n+  call test_shape (shape (allocatable_array_1d))\n+  call test_shape (shape (allocatable_array_2d))\n+\n+  call test_shape (shape (allocatable_array_2d (-2, 10:12)))\n+\n+  array_1d_p => array_1d\n+  array_2d_p => array_2d\n+\n+  call test_shape (shape (array_1d_p))\n+  call test_shape (shape (array_2d_p))\n+\n+  deallocate (allocatable_array_1d)\n+  deallocate (allocatable_array_2d)\n+  array_1d_p => null ()\n+  array_2d_p => null ()\n+\n+  print *, \"\" ! Final Breakpoint\n+  print *, an_integer\n+  print *, a_real\n+  print *, associated (array_1d_p)\n+  print *, associated (array_2d_p)\n+  print *, allocated (allocatable_array_1d)\n+  print *, allocated (allocatable_array_2d)\n+\n+contains\n+\n+  subroutine test_shape (answer)\n+    integer, dimension (:) :: answer\n+\n+    print *,answer\t! Test Breakpoint\n+  end subroutine test_shape\n+\n+end program test"
    }
  ]
}