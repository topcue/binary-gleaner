{
  "sha": "bb3f8ae2902a9878a25fad21efd23fe0f888c232",
  "node_id": "C_kwDOANOeidoAKGJiM2Y4YWUyOTAyYTk4NzhhMjVmYWQyMWVmZDIzZmUwZjg4OGMyMzI",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-11-28T17:48:53Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-12-04T18:16:02Z"
    },
    "message": "Move file_and_directory to new file and C++-ize\n\nThis moves file_and_directory to a new file, and then C++-izes it --\nreplacing direct assignments with methods, and arranging for it to own\nany string that must be computed.  Finally, the CU's objfile will only\nbe used on demand; this is an important property for the new DWARF\nindexer's parallel mode.",
    "tree": {
      "sha": "c5b7e5aacc2c1c8be350051fc782c85f0890ab63",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c5b7e5aacc2c1c8be350051fc782c85f0890ab63"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/bb3f8ae2902a9878a25fad21efd23fe0f888c232",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb3f8ae2902a9878a25fad21efd23fe0f888c232",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/bb3f8ae2902a9878a25fad21efd23fe0f888c232",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb3f8ae2902a9878a25fad21efd23fe0f888c232/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "17f60345f0cfff8faf6f4f734cf2f7e56094e977",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/17f60345f0cfff8faf6f4f734cf2f7e56094e977",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/17f60345f0cfff8faf6f4f734cf2f7e56094e977"
    }
  ],
  "stats": {
    "total": 174,
    "additions": 129,
    "deletions": 45
  },
  "files": [
    {
      "sha": "1a9ccf358294c7487fbaece13adcd08e4dbb62e5",
      "filename": "gdb/dwarf2/file-and-dir.h",
      "status": "added",
      "additions": 107,
      "deletions": 0,
      "changes": 107,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb3f8ae2902a9878a25fad21efd23fe0f888c232/gdb/dwarf2/file-and-dir.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb3f8ae2902a9878a25fad21efd23fe0f888c232/gdb/dwarf2/file-and-dir.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/file-and-dir.h?ref=bb3f8ae2902a9878a25fad21efd23fe0f888c232",
      "patch": "@@ -0,0 +1,107 @@\n+/* DWARF file and directory\n+\n+   Copyright (C) 1994-2021 Free Software Foundation, Inc.\n+\n+   Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,\n+   Inc.  with support from Florida State University (under contract\n+   with the Ada Joint Program Office), and Silicon Graphics, Inc.\n+   Initial contribution by Brent Benson, Harris Computer Systems, Inc.,\n+   based on Fred Fish's (Cygnus Support) implementation of DWARF 1\n+   support.\n+\n+   This file is part of GDB.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GDB_DWARF2_FILE_AND_DIR_H\n+#define GDB_DWARF2_FILE_AND_DIR_H\n+\n+#include \"objfiles.h\"\n+#include <string>\n+\n+/* The return type of find_file_and_directory.  Note, the enclosed\n+   string pointers are only valid while this object is valid.  */\n+\n+struct file_and_directory\n+{\n+  file_and_directory (const char *name, const char *dir)\n+    : m_name (name),\n+      m_comp_dir (dir)\n+  {\n+  }\n+\n+  /* Return true if the file name is unknown.  */\n+  bool is_unknown () const\n+  {\n+    return m_name == nullptr;\n+  }\n+\n+  /* Set the compilation directory.  */\n+  void set_comp_dir (std::string &&dir)\n+  {\n+    m_comp_dir_storage = std::move (dir);\n+    m_comp_dir = nullptr;\n+  }\n+\n+  /* Fetch the compilation directory.  This may return NULL in some\n+     circumstances.  Note that the return value here is not stable --\n+     it may change if this object is moved.  To get a stable pointer,\n+     you should call intern_comp_dir.  */\n+  const char *get_comp_dir () const\n+  {\n+    if (!m_comp_dir_storage.empty ())\n+      return m_comp_dir_storage.c_str ();\n+    return m_comp_dir;\n+  }\n+\n+  /* If necessary, intern the compilation directory using OBJFILE's\n+     string cache.  Returns the compilation directory.  */\n+  const char *intern_comp_dir (struct objfile *objfile)\n+  {\n+    if (!m_comp_dir_storage.empty ())\n+      {\n+\tm_comp_dir = objfile->intern (m_comp_dir_storage);\n+\tm_comp_dir_storage.clear ();\n+      }\n+    return m_comp_dir;\n+  }\n+\n+  /* Fetch the filename.  This never returns NULL.  */\n+  const char *get_name () const\n+  {\n+    return m_name == nullptr ? \"<unknown>\" : m_name;\n+  }\n+\n+  /* Set the filename.  */\n+  void set_name (const char *name)\n+  {\n+    m_name = name;\n+  }\n+\n+private:\n+\n+  /* The filename.  */\n+  const char *m_name;\n+\n+  /* The compilation directory.  NULL if not known.  If we needed to\n+     compute a new string, it will be stored in the comp_dir_storage\n+     member, and this will be NULL.  Otherwise, points directly to the\n+     DW_AT_comp_dir string attribute.  */\n+  const char *m_comp_dir;\n+\n+  /* The compilation directory, if it needed to be allocated.  */\n+  std::string m_comp_dir_storage;\n+};\n+\n+#endif /* GDB_DWARF2_FILE_AND_DIR_H */"
    },
    {
      "sha": "a2ed2cdc16d0b3188f1d00c8744ebb76382f3f3f",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 22,
      "deletions": 45,
      "changes": 67,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/bb3f8ae2902a9878a25fad21efd23fe0f888c232/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/bb3f8ae2902a9878a25fad21efd23fe0f888c232/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=bb3f8ae2902a9878a25fad21efd23fe0f888c232",
      "patch": "@@ -34,6 +34,7 @@\n #include \"dwarf2/attribute.h\"\n #include \"dwarf2/comp-unit-head.h\"\n #include \"dwarf2/cu.h\"\n+#include \"dwarf2/file-and-dir.h\"\n #include \"dwarf2/index-cache.h\"\n #include \"dwarf2/index-common.h\"\n #include \"dwarf2/leb.h\"\n@@ -1206,7 +1207,6 @@ static struct die_info *die_specification (struct die_info *die,\n static line_header_up dwarf_decode_line_header (sect_offset sect_off,\n \t\t\t\t\t\tstruct dwarf2_cu *cu);\n \n-struct file_and_directory;\n static void dwarf_decode_lines (struct line_header *,\n \t\t\t\tconst file_and_directory &,\n \t\t\t\tstruct dwarf2_cu *, dwarf2_psymtab *,\n@@ -1538,21 +1538,6 @@ dwarf2_per_cu_data_deleter::operator() (dwarf2_per_cu_data *data)\n     delete data;\n }\n \n-/* The return type of find_file_and_directory.  Note, the enclosed\n-   string pointers are only valid while this object is valid.  */\n-\n-struct file_and_directory\n-{\n-  /* The filename.  This is never NULL.  */\n-  const char *name;\n-\n-  /* The compilation directory.  NULL if not known.  If we needed to\n-     compute a new string, it will be stored in the per-BFD string\n-     bcache; otherwise, points directly to the DW_AT_comp_dir string\n-     attribute owned by the obstack that owns the DIE.  */\n-  const char *comp_dir;\n-};\n-\n static file_and_directory find_file_and_directory (struct die_info *die,\n \t\t\t\t\t\t   struct dwarf2_cu *cu);\n \n@@ -3024,7 +3009,7 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n   file_and_directory fnd = find_file_and_directory (comp_unit_die, cu);\n \n   int offset = 0;\n-  if (strcmp (fnd.name, \"<unknown>\") != 0)\n+  if (fnd.is_unknown ())\n     ++offset;\n   else if (lh == nullptr)\n     return;\n@@ -3053,12 +3038,12 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n     }\n \n   qfn->num_file_names = offset + include_names.size ();\n-  qfn->comp_dir = fnd.comp_dir;\n+  qfn->comp_dir = fnd.intern_comp_dir (per_objfile->objfile);\n   qfn->file_names =\n     XOBNEWVEC (&per_objfile->per_bfd->obstack, const char *,\n \t       qfn->num_file_names);\n   if (offset != 0)\n-    qfn->file_names[0] = xstrdup (fnd.name);\n+    qfn->file_names[0] = xstrdup (fnd.get_name ());\n \n   if (!include_names.empty ())\n     memcpy (&qfn->file_names[offset], include_names.data (),\n@@ -7005,15 +6990,15 @@ process_psymtab_comp_unit_reader (const struct die_reader_specs *reader,\n   gdb::unique_xmalloc_ptr<char> debug_filename;\n   static const char artificial[] = \"<artificial>\";\n   file_and_directory fnd = find_file_and_directory (comp_unit_die, cu);\n-  if (strcmp (fnd.name, artificial) == 0)\n+  if (strcmp (fnd.get_name (), artificial) == 0)\n     {\n       debug_filename.reset (concat (artificial, \"@\",\n \t\t\t\t    sect_offset_str (per_cu->sect_off),\n \t\t\t\t    (char *) NULL));\n-      fnd.name = debug_filename.get ();\n+      fnd.set_name (debug_filename.get ());\n     }\n \n-  pst = create_partial_symtab (per_cu, per_objfile, fnd.name);\n+  pst = create_partial_symtab (per_cu, per_objfile, fnd.get_name ());\n \n   /* This must be done before calling dwarf2_build_include_psymtabs.  */\n   pst->dirname = dwarf2_string_attr (comp_unit_die, DW_AT_comp_dir, cu);\n@@ -10493,25 +10478,16 @@ producer_is_gcc_lt_4_3 (struct dwarf2_cu *cu)\n static file_and_directory\n find_file_and_directory (struct die_info *die, struct dwarf2_cu *cu)\n {\n-  file_and_directory res;\n-\n   /* Find the filename.  Do not use dwarf2_name here, since the filename\n      is not a source language identifier.  */\n-  res.name = dwarf2_string_attr (die, DW_AT_name, cu);\n-  res.comp_dir = dwarf2_string_attr (die, DW_AT_comp_dir, cu);\n-\n-  if (res.comp_dir == NULL\n-      && producer_is_gcc_lt_4_3 (cu) && res.name != NULL\n-      && IS_ABSOLUTE_PATH (res.name))\n-    {\n-      std::string comp_dir_storage = ldirname (res.name);\n-      if (!comp_dir_storage.empty ())\n-\tres.comp_dir\n-\t  = cu->per_objfile->objfile->intern (comp_dir_storage.c_str ());\n-    }\n+  file_and_directory res (dwarf2_string_attr (die, DW_AT_name, cu),\n+\t\t\t  dwarf2_string_attr (die, DW_AT_comp_dir, cu));\n \n-  if (res.name == NULL)\n-    res.name = \"<unknown>\";\n+  if (res.get_comp_dir () == nullptr\n+      && producer_is_gcc_lt_4_3 (cu)\n+      && res.get_name () != nullptr\n+      && IS_ABSOLUTE_PATH (res.get_name ()))\n+    res.set_comp_dir (ldirname (res.get_name ()));\n \n   return res;\n }\n@@ -10643,7 +10619,7 @@ read_file_scope (struct die_info *die, struct dwarf2_cu *cu)\n \n   file_and_directory fnd = find_file_and_directory (die, cu);\n \n-  cu->start_symtab (fnd.name, fnd.comp_dir, lowpc);\n+  cu->start_symtab (fnd.get_name (), fnd.intern_comp_dir (objfile), lowpc);\n \n   gdb_assert (per_objfile->sym_cu == nullptr);\n   scoped_restore restore_sym_cu\n@@ -20752,7 +20728,7 @@ compute_include_file_name (const struct line_header *lh, const file_entry &fe,\n \n   gdb::unique_xmalloc_ptr<char> hold_compare;\n   if (!IS_ABSOLUTE_PATH (include_name)\n-      && (dir_name != NULL || cu_info.comp_dir != NULL))\n+      && (dir_name != nullptr || cu_info.get_comp_dir () != nullptr))\n     {\n       /* Avoid creating a duplicate name for CU_INFO.\n \t We do this by comparing INCLUDE_NAME and CU_INFO.\n@@ -20782,19 +20758,20 @@ compute_include_file_name (const struct line_header *lh, const file_entry &fe,\n \t  include_name = name_holder->get ();\n \t  include_name_to_compare = include_name;\n \t}\n-      if (!IS_ABSOLUTE_PATH (include_name) && cu_info.comp_dir != nullptr)\n+      if (!IS_ABSOLUTE_PATH (include_name)\n+\t  && cu_info.get_comp_dir () != nullptr)\n \t{\n-\t  hold_compare.reset (concat (cu_info.comp_dir, SLASH_STRING,\n+\t  hold_compare.reset (concat (cu_info.get_comp_dir (), SLASH_STRING,\n \t\t\t\t      include_name, (char *) NULL));\n \t  include_name_to_compare = hold_compare.get ();\n \t}\n     }\n \n   gdb::unique_xmalloc_ptr<char> copied_name;\n-  const char *cu_filename = cu_info.name;\n-  if (!IS_ABSOLUTE_PATH (cu_filename) && cu_info.comp_dir != nullptr)\n+  const char *cu_filename = cu_info.get_name ();\n+  if (!IS_ABSOLUTE_PATH (cu_filename) && cu_info.get_comp_dir () != nullptr)\n     {\n-      copied_name.reset (concat (cu_info.comp_dir, SLASH_STRING,\n+      copied_name.reset (concat (cu_info.get_comp_dir (), SLASH_STRING,\n \t\t\t\t cu_filename, (char *) NULL));\n       cu_filename = copied_name.get ();\n     }"
    }
  ]
}