{
  "sha": "983cdaecc134a5f9adefd052a97bc72321bf0ca3",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTgzY2RhZWNjMTM0YTVmOWFkZWZkMDUyYTk3YmM3MjMyMWJmMGNhMw==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-08-07T04:43:11Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2021-08-07T05:26:53Z"
    },
    "message": "PR28176, rl78 complex reloc divide by zero\n\nThis is a bit more than just preventing the divide by zero.  Most of\nthe patch is tidying up error reporting, so that for example, linking\nan object file with a reloc stack underflow produces a linker error\nrather than just displaying a message that might be ignored.\n\n\tPR 28176\n\t* elf32-rl78.c (RL78_STACK_PUSH, RL78_STACK_POP): Delete.\n\t(rl78_stack_push, rl78_stack_pop): New inline functions.\n\t(rl78_compute_complex_reloc): Add status and error message params.\n\tUse new inline stack handling functions.  Report stack overflow\n\tor underflow, and divide by zero.\n\t(rl78_special_reloc): Return status and error message from\n\trl78_compute_complex_reloc.\n\t(rl78_elf_relocate_section): Similarly.  Modernise reloc error\n\treporting.  Delete unused bfd_reloc_other case.  Don't assume\n\tDIR24S_PCREL overflow is due to undefined function.\n\t(rl78_offset_for_reloc): Adjust to suit rl78_compute_complex_reloc.",
    "tree": {
      "sha": "eedafc8128f1c26d1a0dc623f7c7a58eb5342396",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/eedafc8128f1c26d1a0dc623f7c7a58eb5342396"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/983cdaecc134a5f9adefd052a97bc72321bf0ca3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/983cdaecc134a5f9adefd052a97bc72321bf0ca3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/983cdaecc134a5f9adefd052a97bc72321bf0ca3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/983cdaecc134a5f9adefd052a97bc72321bf0ca3/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0175375faa416282d2587ca8bf599867dca5fc9e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0175375faa416282d2587ca8bf599867dca5fc9e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0175375faa416282d2587ca8bf599867dca5fc9e"
    }
  ],
  "stats": {
    "total": 283,
    "additions": 154,
    "deletions": 129
  },
  "files": [
    {
      "sha": "ccccb76d1bac61222126b3234eaeec68fc49a496",
      "filename": "bfd/elf32-rl78.c",
      "status": "modified",
      "additions": 154,
      "deletions": 129,
      "changes": 283,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/983cdaecc134a5f9adefd052a97bc72321bf0ca3/bfd/elf32-rl78.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/983cdaecc134a5f9adefd052a97bc72321bf0ca3/bfd/elf32-rl78.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-rl78.c?ref=983cdaecc134a5f9adefd052a97bc72321bf0ca3",
      "patch": "@@ -363,28 +363,24 @@ get_ramstart (struct bfd_link_info *  info,\n static int32_t rl78_stack [ NUM_STACK_ENTRIES ];\n static unsigned int rl78_stack_top;\n \n-#define RL78_STACK_PUSH(val)\t\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (rl78_stack_top < NUM_STACK_ENTRIES)\t\\\n-\trl78_stack [rl78_stack_top ++] = (val);\t\\\n-      else\t\t\t\t\t\\\n-\t_bfd_error_handler (_(\"internal error: RL78 reloc stack overflow\")); \\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n-\n-#define RL78_STACK_POP(dest)\t\t\t\\\n-  do\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\\\n-      if (rl78_stack_top > 0)\t\t\t\\\n-\t(dest) = rl78_stack [-- rl78_stack_top];\\\n-      else\t\t\t\t\t\\\n-\t{\t\t\t\t\t\\\n-\t  _bfd_error_handler (_(\"internal error: RL78 reloc stack underflow\")); \\\n-\t  (dest) = 0;\t\t\t\t\\\n-\t}\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-  while (0)\n+static inline void\n+rl78_stack_push (bfd_vma val, bfd_reloc_status_type *r)\n+{\n+  if (rl78_stack_top < NUM_STACK_ENTRIES)\n+    rl78_stack[rl78_stack_top++] = val;\n+  else\n+    *r = bfd_reloc_dangerous;\n+}\n+\n+static inline bfd_vma\n+rl78_stack_pop (bfd_reloc_status_type *r)\n+{\n+  if (rl78_stack_top > 0)\n+    return rl78_stack[-- rl78_stack_top];\n+  else\n+    *r = bfd_reloc_dangerous;\n+  return 0;\n+}\n \n /* Special handling for RL78 complex relocs.  Returns the\n    value of the reloc, or 0 for relocs which do not generate\n@@ -393,23 +389,27 @@ static unsigned int rl78_stack_top;\n \n static bfd_vma\n rl78_compute_complex_reloc (unsigned long  r_type,\n-\t\t\t    bfd_vma\t   symval,\n-\t\t\t    asection *\t   input_section)\n+\t\t\t    bfd_vma symval,\n+\t\t\t    asection *input_section,\n+\t\t\t    bfd_reloc_status_type *r,\n+\t\t\t    char **error_message)\n {\n   int32_t tmp1, tmp2;\n-  bfd_vma relocation;\n+  bfd_vma relocation = 0;\n+  bfd_reloc_status_type stat = bfd_reloc_ok;\n \n   switch (r_type)\n     {\n     default:\n-      return 0;\n+      stat = bfd_reloc_notsupported;\n+      break;\n \n     case R_RL78_ABS24S_PCREL:\n     case R_RL78_ABS16S_PCREL:\n     case R_RL78_ABS8S_PCREL:\n-      RL78_STACK_POP (relocation);\n+      relocation = rl78_stack_pop (&stat);\n       relocation -= input_section->output_section->vma + input_section->output_offset;\n-      return relocation;\n+      break;\n \n     case R_RL78_ABS32:\n     case R_RL78_ABS32_REV:\n@@ -420,122 +420,144 @@ rl78_compute_complex_reloc (unsigned long  r_type,\n     case R_RL78_ABS8:\n     case R_RL78_ABS8U:\n     case R_RL78_ABS8S:\n-      RL78_STACK_POP (relocation);\n-      return relocation;\n+      relocation = rl78_stack_pop (&stat);\n+      break;\n \n     case R_RL78_ABS16UL:\n     case R_RL78_ABS8UL:\n-      RL78_STACK_POP (relocation);\n-      return relocation >> 2;\n+      relocation = rl78_stack_pop (&stat) >> 2;\n+      break;;\n \n     case R_RL78_ABS16UW:\n     case R_RL78_ABS8UW:\n-      RL78_STACK_POP (relocation);\n-      return relocation >> 1;\n+      relocation = rl78_stack_pop (&stat) >> 1;\n+      break;\n \n       /* The rest of the relocs compute values and then push them onto the stack.  */\n     case R_RL78_OPramtop:\n     case R_RL78_OPromtop:\n     case R_RL78_SYM:\n-      RL78_STACK_PUSH (symval);\n-      return 0;\n+      rl78_stack_push (symval, &stat);\n+      break;\n \n     case R_RL78_OPneg:\n-      RL78_STACK_POP (tmp1);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 = - tmp1;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPadd:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 += tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPsub:\n       /* For the expression \"A - B\", the assembler pushes A,\n \t then B, then OPSUB.  So the first op we pop is B, not A.  */\n-      RL78_STACK_POP (tmp2);\t/* B */\n-      RL78_STACK_POP (tmp1);\t/* A */\n+      tmp2 = rl78_stack_pop (&stat);\t/* B */\n+      tmp1 = rl78_stack_pop (&stat);\t/* A */\n       tmp1 -= tmp2;\t\t/* A - B */\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPmul:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 *= tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPdiv:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n-      tmp1 /= tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n+      if (tmp2 != 0)\n+\ttmp1 /= tmp2;\n+      else\n+\t{\n+\t  tmp1 = 0;\n+\t  stat = bfd_reloc_overflow;\n+\t}\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPshla:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 <<= tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPshra:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 >>= tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPsctsize:\n-      RL78_STACK_PUSH (input_section->size);\n-      return 0;\n+      rl78_stack_push (input_section->size, &stat);\n+      break;\n \n     case R_RL78_OPscttop:\n-      RL78_STACK_PUSH (input_section->output_section->vma);\n-      return 0;\n+      rl78_stack_push (input_section->output_section->vma, &stat);\n+      break;\n \n     case R_RL78_OPand:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 &= tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPor:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 |= tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPxor:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 ^= tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPnot:\n-      RL78_STACK_POP (tmp1);\n+      tmp1 = rl78_stack_pop (&stat);\n       tmp1 = ~ tmp1;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n \n     case R_RL78_OPmod:\n-      RL78_STACK_POP (tmp2);\n-      RL78_STACK_POP (tmp1);\n-      tmp1 %= tmp2;\n-      RL78_STACK_PUSH (tmp1);\n-      return 0;\n+      tmp2 = rl78_stack_pop (&stat);\n+      tmp1 = rl78_stack_pop (&stat);\n+      if (tmp2 != 0)\n+\ttmp1 %= tmp2;\n+      else\n+\t{\n+\t  tmp1 = 0;\n+\t  stat = bfd_reloc_overflow;\n+\t}\n+      rl78_stack_push (tmp1, &stat);\n+      break;\n     }\n-}\n \n-#undef RL78_STACK_PUSH\n-#undef RL78_STACK_POP\n+  if (r)\n+    {\n+      if (stat == bfd_reloc_dangerous)\n+\t*error_message = (_(\"RL78 reloc stack overflow/underflow\"));\n+      else if (stat == bfd_reloc_overflow)\n+\t{\n+\t  stat = bfd_reloc_dangerous;\n+\t  *error_message = (_(\"RL78 reloc divide by zero\"));\n+\t}\n+      *r = stat;\n+    }\n+  return relocation;\n+}\n \n #define OP(i)      (contents[reloc->address + (i)])\n \n@@ -546,7 +568,7 @@ rl78_special_reloc (bfd *      input_bfd,\n \t\t    void *     data,\n \t\t    asection * input_section,\n \t\t    bfd *      output_bfd ATTRIBUTE_UNUSED,\n-\t\t    char **    error_message ATTRIBUTE_UNUSED)\n+\t\t    char **    error_message)\n {\n   bfd_reloc_status_type\t r = bfd_reloc_ok;\n   bfd_vma\t\t relocation = 0;\n@@ -575,7 +597,8 @@ rl78_special_reloc (bfd *      input_bfd,\n     }\n \n   /* Get the value of the relocation.  */\n-  relocation = rl78_compute_complex_reloc (r_type, relocation, input_section);\n+  relocation = rl78_compute_complex_reloc (r_type, relocation, input_section,\n+\t\t\t\t\t   &r, error_message);\n \n   /* If the relocation alters the contents of the section then apply it now.\n      Note - since this function is called from\n@@ -689,13 +712,14 @@ rl78_elf_relocate_section\n   Elf_Internal_Rela *\t\trel;\n   Elf_Internal_Rela *\t\trelend;\n   asection *splt;\n+  bool ret;\n \n   symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;\n   sym_hashes = elf_sym_hashes (input_bfd);\n   relend     = relocs + input_section->reloc_count;\n \n   splt = elf_hash_table (info)->splt;\n-\n+  ret = true;\n   for (rel = relocs; rel < relend; rel ++)\n     {\n       reloc_howto_type *howto;\n@@ -708,6 +732,7 @@ rl78_elf_relocate_section\n       const char *name = NULL;\n       bool unresolved_reloc = true;\n       int r_type;\n+      char *error_message;\n \n       r_type = ELF32_R_TYPE (rel->r_info);\n       r_symndx = ELF32_R_SYM (rel->r_info);\n@@ -958,7 +983,8 @@ rl78_elf_relocate_section\n \tcase R_RL78_OPxor:\n \tcase R_RL78_OPnot:\n \tcase R_RL78_OPmod:\n-\t  relocation = rl78_compute_complex_reloc (r_type, 0, input_section);\n+\t  relocation = rl78_compute_complex_reloc (r_type, 0, input_section,\n+\t\t\t\t\t\t   &r, &error_message);\n \n \t  switch (r_type)\n \t    {\n@@ -1052,17 +1078,20 @@ rl78_elf_relocate_section\n \t\t_bfd_error_handler\n \t\t  (_(\"warning: RL78_SYM reloc with an unknown symbol\"));\n \t    }\n-\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section);\n+\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n+\t\t\t\t\t     &r, &error_message);\n \t  break;\n \n \tcase R_RL78_OPromtop:\n \t  relocation = get_romstart (info, input_bfd, input_section, rel->r_offset);\n-\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section);\n+\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n+\t\t\t\t\t     &r, &error_message);\n \t  break;\n \n \tcase R_RL78_OPramtop:\n \t  relocation = get_ramstart (info, input_bfd, input_section, rel->r_offset);\n-\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section);\n+\t  (void) rl78_compute_complex_reloc (r_type, relocation, input_section,\n+\t\t\t\t\t     &r, &error_message);\n \t  break;\n \n \tdefault:\n@@ -1072,59 +1101,50 @@ rl78_elf_relocate_section\n \n       if (r != bfd_reloc_ok)\n \t{\n-\t  const char * msg = NULL;\n-\n \t  switch (r)\n \t    {\n \t    case bfd_reloc_overflow:\n-\t      /* Catch the case of a missing function declaration\n-\t\t and emit a more helpful error message.  */\n-\t      if (r_type == R_RL78_DIR24S_PCREL)\n-\t\t/* xgettext:c-format */\n-\t\tmsg = _(\"%pB(%pA): error: call to undefined function '%s'\");\n-\t      else\n-\t\t(*info->callbacks->reloc_overflow)\n-\t\t  (info, (h ? &h->root : NULL), name, howto->name, (bfd_vma) 0,\n-\t\t   input_bfd, input_section, rel->r_offset);\n+\t      (*info->callbacks->reloc_overflow)\n+\t\t(info, (h ? &h->root : NULL), name, howto->name, (bfd_vma) 0,\n+\t\t input_bfd, input_section, rel->r_offset);\n \t      break;\n \n \t    case bfd_reloc_undefined:\n \t      (*info->callbacks->undefined_symbol)\n \t\t(info, name, input_bfd, input_section, rel->r_offset, true);\n \t      break;\n \n-\t    case bfd_reloc_other:\n-\t      /* xgettext:c-format */\n-\t      msg = _(\"%pB(%pA): warning: unaligned access to symbol '%s' in the small data area\");\n-\t      break;\n-\n \t    case bfd_reloc_outofrange:\n-\t      /* xgettext:c-format */\n-\t      msg = _(\"%pB(%pA): internal error: out of range error\");\n+\t       /* xgettext:c-format */\n+\t      (*info->callbacks->einfo)\n+\t\t(_(\"%H: %s out of range\\n\"),\n+\t\t input_bfd, input_section, rel->r_offset, howto->name);\n \t      break;\n \n \t    case bfd_reloc_notsupported:\n \t      /* xgettext:c-format */\n-\t      msg = _(\"%pB(%pA): internal error: unsupported relocation error\");\n+\t      (*info->callbacks->einfo)\n+\t\t(_(\"%H: relocation type %u is not supported\\n\"),\n+\t\t input_bfd, input_section, rel->r_offset, r_type);\n \t      break;\n \n \t    case bfd_reloc_dangerous:\n-\t      /* xgettext:c-format */\n-\t      msg = _(\"%pB(%pA): internal error: dangerous relocation\");\n+\t      (*info->callbacks->reloc_dangerous)\n+\t\t(info, error_message, input_bfd, input_section, rel->r_offset);\n \t      break;\n \n \t    default:\n \t      /* xgettext:c-format */\n-\t      msg = _(\"%pB(%pA): internal error: unknown error\");\n+\t      (*info->callbacks->einfo)\n+\t\t(_(\"%H: relocation %s returns an unrecognized value %x\\n\"),\n+\t\t input_bfd, input_section, rel->r_offset, howto->name, r);\n \t      break;\n \t    }\n-\n-\t  if (msg)\n-\t    _bfd_error_handler (msg, input_bfd, input_section, name);\n+\t  ret = false;\n \t}\n     }\n \n-  return true;\n+  return ret;\n }\n \f\n /* Function to set the ELF flag bits.  */\n@@ -1917,17 +1937,20 @@ rl78_offset_for_reloc (bfd *\t\t\tabfd,\n       switch (r_type)\n \t{\n \tcase R_RL78_SYM:\n-\t  (void) rl78_compute_complex_reloc (r_type, symval, input_section);\n+\t  (void) rl78_compute_complex_reloc (r_type, symval, input_section,\n+\t\t\t\t\t     NULL, NULL);\n \t  break;\n \n \tcase R_RL78_OPromtop:\n \t  symval = get_romstart (info, input_bfd, input_section, rel->r_offset);\n-\t  (void) rl78_compute_complex_reloc (r_type, symval, input_section);\n+\t  (void) rl78_compute_complex_reloc (r_type, symval, input_section,\n+\t\t\t\t\t     NULL, NULL);\n \t  break;\n \n \tcase R_RL78_OPramtop:\n \t  symval = get_ramstart (info, input_bfd, input_section, rel->r_offset);\n-\t  (void) rl78_compute_complex_reloc (r_type, symval, input_section);\n+\t  (void) rl78_compute_complex_reloc (r_type, symval, input_section,\n+\t\t\t\t\t     NULL, NULL);\n \t  break;\n \n \tcase R_RL78_OPneg:\n@@ -1944,7 +1967,8 @@ rl78_offset_for_reloc (bfd *\t\t\tabfd,\n \tcase R_RL78_OPxor:\n \tcase R_RL78_OPnot:\n \tcase R_RL78_OPmod:\n-\t  (void) rl78_compute_complex_reloc (r_type, 0, input_section);\n+\t  (void) rl78_compute_complex_reloc (r_type, 0, input_section,\n+\t\t\t\t\t     NULL, NULL);\n \t  break;\n \n \tcase R_RL78_DIR16UL:\n@@ -1963,7 +1987,8 @@ rl78_offset_for_reloc (bfd *\t\t\tabfd,\n \n \tdefault:\n \treloc_computes_value:\n-\t  symval = rl78_compute_complex_reloc (r_type, symval, input_section);\n+\t  symval = rl78_compute_complex_reloc (r_type, symval, input_section,\n+\t\t\t\t\t       NULL, NULL);\n \t  /* Fall through.  */\n \tcase R_RL78_DIR32:\n \tcase R_RL78_DIR24S:"
    }
  ]
}