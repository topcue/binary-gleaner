{
  "sha": "e20773049fde7b9a123fda4485259fc06249b22f",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZTIwNzczMDQ5ZmRlN2I5YTEyM2ZkYTQ0ODUyNTlmYzA2MjQ5YjIyZg==",
  "commit": {
    "author": {
      "name": "tromey",
      "email": "tromey@138bc75d-0d04-0410-961f-82ee72b054a4",
      "date": "2019-02-12T13:02:48Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2019-02-12T13:06:19Z"
    },
    "message": "Fix splay tree KEY leak detected in GDB test gdb.base/macscp.exp\n\nWhen a node is removed from a splay tree, the splay tree was\nnot using the function splay_tree_delete_key_fn to release the key.\nThis was causing a leak, fixed by Tom Tromey.\n\nThis patch fixes another key leak, that happens when a key equal to\na key already present is inserted.  In such a case, we have to release\nthe old KEY.\nNote that this is based on the assumption that the caller always\nallocates a new KEY when doing an insert.\n\nAlso, clarify the documentation about when the release functions are\ncalled.\n\n2019-02-11  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n\n\t* splay-tree.h (splay_tree_delete_key_fn): Update comment.\n\t(splay_tree_delete_value_fn): Likewise.\n\nlibiberty/ChangeLog\n2019-02-11  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n\n\t* splay-tree.c (splay_tree_insert): Also release old KEY in case\n\tof insertion of a key equal to an already present key.\n\t(splay_tree_new_typed_alloc): Update comment.\n\ngit-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/trunk@268793 138bc75d-0d04-0410-961f-82ee72b054a4",
    "tree": {
      "sha": "c5c01da0056ac3e64cabcdd96b44744e791c4278",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/c5c01da0056ac3e64cabcdd96b44744e791c4278"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/e20773049fde7b9a123fda4485259fc06249b22f",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e20773049fde7b9a123fda4485259fc06249b22f",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/e20773049fde7b9a123fda4485259fc06249b22f",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e20773049fde7b9a123fda4485259fc06249b22f/comments",
  "author": null,
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "04d7fa2132c05b962d85e2047646e15b8a490f4e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/04d7fa2132c05b962d85e2047646e15b8a490f4e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/04d7fa2132c05b962d85e2047646e15b8a490f4e"
    }
  ],
  "stats": {
    "total": 35,
    "additions": 30,
    "deletions": 5
  },
  "files": [
    {
      "sha": "2a71eee451a76afabb6f9f9f873f416c788aeeef",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e20773049fde7b9a123fda4485259fc06249b22f/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e20773049fde7b9a123fda4485259fc06249b22f/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=e20773049fde7b9a123fda4485259fc06249b22f",
      "patch": "@@ -1,3 +1,8 @@\n+2019-02-11  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n+\n+\t* splay-tree.h (splay_tree_delete_key_fn): Update comment.\n+\t(splay_tree_delete_value_fn): Likewise.\n+\n 2019-01-31  Andreas Krebbel  <krebbel@linux.ibm.com>\n \n \t* opcode/s390.h (enum s390_opcode_cpu_val): Add"
    },
    {
      "sha": "da533dec183ffa15ebfe0a87e42635090fdfc522",
      "filename": "include/splay-tree.h",
      "status": "modified",
      "additions": 9,
      "deletions": 2,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e20773049fde7b9a123fda4485259fc06249b22f/include/splay-tree.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e20773049fde7b9a123fda4485259fc06249b22f/include/splay-tree.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/splay-tree.h?ref=e20773049fde7b9a123fda4485259fc06249b22f",
      "patch": "@@ -58,11 +58,18 @@ typedef struct splay_tree_node_s *splay_tree_node;\n typedef int (*splay_tree_compare_fn) (splay_tree_key, splay_tree_key);\n \n /* The type of a function used to deallocate any resources associated\n-   with the key.  */\n+   with the key.  If you provide this function, the splay tree\n+   will take the ownership of the memory of the splay_tree_key arg\n+   of splay_tree_insert.  This function is called to release the keys\n+   present in the tree when calling splay_tree_delete or splay_tree_remove.\n+   If splay_tree_insert is called with a key equal to a key already\n+   present in the tree, the old key and old value will be released.  */\n typedef void (*splay_tree_delete_key_fn) (splay_tree_key);\n \n /* The type of a function used to deallocate any resources associated\n-   with the value.  */\n+   with the value.  If you provide this function, the memory of the\n+   splay_tree_value arg of splay_tree_insert is managed similarly to\n+   the splay_tree_key memory: see splay_tree_delete_key_fn.  */\n typedef void (*splay_tree_delete_value_fn) (splay_tree_value);\n \n /* The type of a function used to iterate over the tree.  */"
    },
    {
      "sha": "c9ff317b6fd2edece4e5ced6291434ab63e624f6",
      "filename": "libiberty/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e20773049fde7b9a123fda4485259fc06249b22f/libiberty/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e20773049fde7b9a123fda4485259fc06249b22f/libiberty/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/ChangeLog?ref=e20773049fde7b9a123fda4485259fc06249b22f",
      "patch": "@@ -1,3 +1,9 @@\n+2019-02-11  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n+\n+\t* splay-tree.c (splay_tree_insert): Also release old KEY in case\n+\tof insertion of a key equal to an already present key.\n+\t(splay_tree_new_typed_alloc): Update comment.\n+\n 2019-01-21  Tom Tromey  <tom@tromey.com>\n \n \t* splay-tree.c (splay_tree_remove): Delete the key if necessary."
    },
    {
      "sha": "4bbb39a62ca476de7dd63b5ee592373e7a9a51a2",
      "filename": "libiberty/splay-tree.c",
      "status": "modified",
      "additions": 10,
      "deletions": 3,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/e20773049fde7b9a123fda4485259fc06249b22f/libiberty/splay-tree.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/e20773049fde7b9a123fda4485259fc06249b22f/libiberty/splay-tree.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libiberty/splay-tree.c?ref=e20773049fde7b9a123fda4485259fc06249b22f",
      "patch": "@@ -318,7 +318,11 @@ different types need to be allocated with different allocators.\n \n The splay tree will use @var{compare_fn} to compare nodes,\n @var{delete_key_fn} to deallocate keys, and @var{delete_value_fn} to\n-deallocate values.\n+deallocate values.  Keys and values will be deallocated when the\n+tree is deleted using splay_tree_delete or when a node is removed\n+using splay_tree_remove.  splay_tree_insert will release the previously\n+inserted key and value using @var{delete_key_fn} and @var{delete_value_fn}\n+if the inserted key is already found in the tree.\n \n @end deftypefn\n \n@@ -372,10 +376,13 @@ splay_tree_insert (splay_tree sp, splay_tree_key key, splay_tree_value value)\n \n   if (sp->root && comparison == 0)\n     {\n-      /* If the root of the tree already has the indicated KEY, just\n-\t replace the value with VALUE.  */\n+      /* If the root of the tree already has the indicated KEY, delete\n+         the old key and old value, and replace them with KEY and  VALUE.  */\n+      if (sp->delete_key)\n+\t(*sp->delete_key) (sp->root->key);\n       if (sp->delete_value)\n \t(*sp->delete_value)(sp->root->value);\n+      sp->root->key = key;\n       sp->root->value = value;\n     } \n   else "
    }
  ]
}