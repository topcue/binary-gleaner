{
  "sha": "1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MWViODU1NmY1YThiNTcxMmU3NjViOTYxNWY3YzE4ZmZiNTAyNTNiNg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-08-24T19:49:46Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-08-24T19:49:47Z"
    },
    "message": "gdb: add infrun_debug_printf macro\n\nIntroduce this macro to print debug statements in the infrun.c file,\nsame idea as what was done in 9327494e0eeb (\"gdb: add\nlinux_nat_debug_printf macro\").\n\nAlthough in this case, there are places outside infrun.c that print\ndebug statements if debug_infrun is set.  So the macro has to be\ndeclared in the header file, so that it can be used in these other\nfiles.\n\nNote one special case.  In stop_all_threads, I've used an explicit\n\n    if (debug_infrun)\n      infrun_debug_printf_1 (\"stop_all_threads\", \"done\");\n\nfor the message in the SCOPE_EXIT.  Otherwise, the message appears like\nthis:\n\n  [infrun] operator(): done\n\nUntil we find a better solution for extracting a meaningful function\nname for lambda functions, I think it's fine to handle these special\ncases manually, they are quite rare.\n\nSome tests need to be updated, because they rely on some infrun debug\nstatements.\n\ngdb/ChangeLog:\n\n\t* infrun.h (infrun_debug_printf_1): New function declaration.\n\t(infrun_debug_printf): New macro.\n\t* infrun.c (infrun_debug_printf_1): Use infrun_debug_printf\n\tthroughout.\n\t(infrun_debug_printf): New function.\n\t* breakpoint.c (should_be_inserted): Use infrun_debug_printf.\n\t(handle_jit_event): Likewise.\n\ngdb/testsuite/ChangeLog:\n\n\t* gdb.base/gdb-sigterm.exp (do_test): Update expected regexp.\n\t* gdb.threads/signal-while-stepping-over-bp-other-thread.exp:\n\tLikewise.\n\t* gdb.threads/stepi-random-signal.exp: Likewise.\n\nChange-Id: I66433c8a9caa64c8525ab57c593022b9d1956d5c",
    "tree": {
      "sha": "d6e4f5f9ad743e848f7bcd4bf1e144fbf3bb72c9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d6e4f5f9ad743e848f7bcd4bf1e144fbf3bb72c9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "0f55320bc46869b87c54d3432fb344f785f07b33",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0f55320bc46869b87c54d3432fb344f785f07b33",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/0f55320bc46869b87c54d3432fb344f785f07b33"
    }
  ],
  "stats": {
    "total": 831,
    "additions": 298,
    "deletions": 533
  },
  "files": [
    {
      "sha": "b95045b039d95bb8bb91a3767ee677047e64b679",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 10,
      "deletions": 0,
      "changes": 10,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
      "patch": "@@ -1,3 +1,13 @@\n+2020-08-24  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* infrun.h (infrun_debug_printf_1): New function declaration.\n+\t(infrun_debug_printf): New macro.\n+\t* infrun.c (infrun_debug_printf_1): Use infrun_debug_printf\n+\tthroughout.\n+\t(infrun_debug_printf): New function.\n+\t* breakpoint.c (should_be_inserted): Use infrun_debug_printf.\n+\t(handle_jit_event): Likewise.\n+\n 2020-08-21  Mark Wielaard  <mark@klomp.org>\n \n \t* ada-lex.l: Extend register warnings diagnostics comment for g++."
    },
    {
      "sha": "ef8e54f634465b5e9f2cd4a6a63aa00da7944f6c",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 6,
      "deletions": 17,
      "changes": 23,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
      "patch": "@@ -2035,13 +2035,8 @@ should_be_inserted (struct bp_location *bl)\n       && !(bl->owner->type == bp_single_step\n \t   && thread_is_stepping_over_breakpoint (bl->owner->thread)))\n     {\n-      if (debug_infrun)\n-\t{\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"infrun: skipping breakpoint: \"\n-\t\t\t      \"stepping past insn at: %s\\n\",\n-\t\t\t      paddress (bl->gdbarch, bl->address));\n-\t}\n+      infrun_debug_printf (\"skipping breakpoint: stepping past insn at: %s\",\n+\t\t\t   paddress (bl->gdbarch, bl->address));\n       return 0;\n     }\n \n@@ -2050,14 +2045,9 @@ should_be_inserted (struct bp_location *bl)\n   if ((bl->loc_type == bp_loc_hardware_watchpoint)\n       && stepping_past_nonsteppable_watchpoint ())\n     {\n-      if (debug_infrun)\n-\t{\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"infrun: stepping past non-steppable watchpoint. \"\n-\t\t\t      \"skipping watchpoint at %s:%d\\n\",\n-\t\t\t      paddress (bl->gdbarch, bl->address),\n-\t\t\t      bl->length);\n-\t}\n+      infrun_debug_printf (\"stepping past non-steppable watchpoint. \"\n+\t\t\t   \"skipping watchpoint at %s:%d\\n\",\n+\t\t\t   paddress (bl->gdbarch, bl->address), bl->length);\n       return 0;\n     }\n \n@@ -5446,8 +5436,7 @@ handle_jit_event (void)\n   struct frame_info *frame;\n   struct gdbarch *gdbarch;\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog, \"handling bp_jit_event\\n\");\n+  infrun_debug_printf (\"handling bp_jit_event\");\n \n   /* Switch terminal for any messages produced by\n      breakpoint_re_set.  */"
    },
    {
      "sha": "0f2a1bcd4a670825e21c7bb2bed94a28517ca302",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 260,
      "deletions": 512,
      "changes": 772,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
      "patch": "@@ -103,17 +103,29 @@ static int infrun_is_async = -1;\n \n /* See infrun.h.  */\n \n+void\n+infrun_debug_printf_1 (const char *func_name, const char *fmt, ...)\n+{\n+  debug_printf (\"[infrun] %s: \", func_name);\n+\n+  va_list ap;\n+  va_start (ap, fmt);\n+  debug_vprintf (fmt, ap);\n+  va_end (ap);\n+\n+  debug_printf (\"\\n\");\n+}\n+\n+/* See infrun.h.  */\n+\n void\n infrun_async (int enable)\n {\n   if (infrun_is_async != enable)\n     {\n       infrun_is_async = enable;\n \n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: infrun_async(%d)\\n\",\n-\t\t\t    enable);\n+      infrun_debug_printf (\"enable=%d\", enable);\n \n       if (enable)\n \tmark_async_event_handler (infrun_async_inferior_event_token);\n@@ -904,10 +916,8 @@ proceed_after_vfork_done (struct thread_info *thread,\n       && !thread->stop_requested\n       && thread->suspend.stop_signal == GDB_SIGNAL_0)\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: resuming vfork parent thread %s\\n\",\n-\t\t\t    target_pid_to_str (thread->ptid).c_str ());\n+      infrun_debug_printf (\"resuming vfork parent thread %s\",\n+\t\t\t   target_pid_to_str (thread->ptid).c_str ());\n \n       switch_to_thread (thread);\n       clear_proceed_status (0);\n@@ -1042,10 +1052,8 @@ handle_vfork_child_exec_or_exit (int exec)\n \t     free now.  */\n \t  scoped_restore_current_thread restore_thread;\n \n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: resuming vfork parent process %d\\n\",\n-\t\t\t\tresume_parent);\n+\t  infrun_debug_printf (\"resuming vfork parent process %d\",\n+\t\t\t       resume_parent);\n \n \t  iterate_over_threads (proceed_after_vfork_done, &resume_parent);\n \t}\n@@ -1336,9 +1344,7 @@ set_step_over_info (const address_space *aspace, CORE_ADDR address,\n static void\n clear_step_over_info (void)\n {\n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: clear_step_over_info\\n\");\n+  infrun_debug_printf (\"clearing step over info\");\n   step_over_info.aspace = NULL;\n   step_over_info.address = 0;\n   step_over_info.nonsteppable_watchpoint_p = 0;\n@@ -1808,12 +1814,8 @@ displaced_step_prepare (thread_info *thread)\n \t  && ex.error != NOT_SUPPORTED_ERROR)\n \tthrow;\n \n-      if (debug_infrun)\n-\t{\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"infrun: disabling displaced stepping: %s\\n\",\n-\t\t\t      ex.what ());\n-\t}\n+      infrun_debug_printf (\"caught exception, disabling displaced stepping: %s\",\n+\t\t\t   ex.what ());\n \n       /* Be verbose if \"set displaced-stepping\" is \"on\", silent if\n \t \"auto\".  */\n@@ -1997,11 +1999,7 @@ start_step_over (void)\n       thread_step_over_chain_remove (tp);\n \n       if (step_over_queue_head == NULL)\n-\t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: step-over queue now empty\\n\");\n-\t}\n+\tinfrun_debug_printf (\"step-over queue now empty\");\n \n       if (tp->control.trap_expected\n \t  || tp->resumed\n@@ -2016,10 +2014,8 @@ start_step_over (void)\n \t\t\t  tp->executing);\n \t}\n \n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: resuming [%s] for step-over\\n\",\n-\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n+      infrun_debug_printf (\"resuming [%s] for step-over\",\n+\t\t\t   target_pid_to_str (tp->ptid).c_str ());\n \n       /* keep_going_pass_signal skips the step-over if the breakpoint\n \t is no longer inserted.  In all-stop, we want to keep looking\n@@ -2284,18 +2280,12 @@ resume_1 (enum gdb_signal sig)\n \n   if (tp->suspend.waitstatus_pending_p)\n     {\n-      if (debug_infrun)\n-\t{\n-\t  std::string statstr\n-\t    = target_waitstatus_to_string (&tp->suspend.waitstatus);\n-\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"infrun: resume: thread %s has pending wait \"\n-\t\t\t      \"status %s (currently_stepping=%d).\\n\",\n-\t\t\t      target_pid_to_str (tp->ptid).c_str (),\n-\t\t\t      statstr.c_str (),\n-\t\t\t      currently_stepping (tp));\n-\t}\n+      infrun_debug_printf\n+\t(\"thread %s has pending wait \"\n+\t \"status %s (currently_stepping=%d).\",\n+\t target_pid_to_str (tp->ptid).c_str (),\n+\t target_waitstatus_to_string (&tp->suspend.waitstatus).c_str (),\n+\t currently_stepping (tp));\n \n       tp->inf->process_target ()->threads_executing = true;\n       tp->resumed = true;\n@@ -2339,22 +2329,18 @@ resume_1 (enum gdb_signal sig)\n \t Eventually, we'll see a TARGET_WAITKIND_VFORK_DONE event for\n \t the parent, and tell it to `keep_going', which automatically\n \t re-sets it stepping.  */\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: resume : clear step\\n\");\n+      infrun_debug_printf (\"resume : clear step\");\n       step = 0;\n     }\n \n   CORE_ADDR pc = regcache_read_pc (regcache);\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: resume (step=%d, signal=%s), \"\n-\t\t\t\"trap_expected=%d, current thread [%s] at %s\\n\",\n-\t\t\tstep, gdb_signal_to_symbol_string (sig),\n-\t\t\ttp->control.trap_expected,\n-\t\t\ttarget_pid_to_str (inferior_ptid).c_str (),\n-\t\t\tpaddress (gdbarch, pc));\n+  infrun_debug_printf (\"step=%d, signal=%s, trap_expected=%d, \"\n+\t\t       \"current thread [%s] at %s\",\n+\t\t       step, gdb_signal_to_symbol_string (sig),\n+\t\t       tp->control.trap_expected,\n+\t\t       target_pid_to_str (inferior_ptid).c_str (),\n+\t\t       paddress (gdbarch, pc));\n \n   /* Normally, by the time we reach `resume', the breakpoints are either\n      removed or inserted, as appropriate.  The exception is if we're sitting\n@@ -2378,10 +2364,8 @@ resume_1 (enum gdb_signal sig)\n \t     signal handler (or hit some other event).  We'll delete\n \t     the step-resume breakpoint then.  */\n \n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: resume: skipping permanent breakpoint, \"\n-\t\t\t\t\"deliver signal first\\n\");\n+\t  infrun_debug_printf (\"resume: skipping permanent breakpoint, \"\n+\t\t\t       \"deliver signal first\");\n \n \t  clear_step_over_info ();\n \t  tp->control.trap_expected = 0;\n@@ -2403,9 +2387,7 @@ resume_1 (enum gdb_signal sig)\n \t{\n \t  /* There's no signal to pass, we can go ahead and skip the\n \t     permanent breakpoint manually.  */\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: resume: skipping permanent breakpoint\\n\");\n+\t  infrun_debug_printf (\"skipping permanent breakpoint\");\n \t  gdbarch_skip_permanent_breakpoint (gdbarch, regcache);\n \t  /* Update pc to reflect the new address from which we will\n \t     execute instructions.  */\n@@ -2460,9 +2442,7 @@ resume_1 (enum gdb_signal sig)\n \n       if (prepared == 0)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"Got placed in step-over queue\\n\");\n+\t  infrun_debug_printf (\"Got placed in step-over queue\");\n \n \t  tp->control.trap_expected = 0;\n \t  return;\n@@ -2599,10 +2579,8 @@ resume_1 (enum gdb_signal sig)\n \t gdb.threads/non-stop-fair-events.exp, on targets that don't\n \t do displaced stepping.  */\n \n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: resume: [%s] stepped breakpoint\\n\",\n-\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n+      infrun_debug_printf (\"resume: [%s] stepped breakpoint\",\n+\t\t\t   target_pid_to_str (tp->ptid).c_str ());\n \n       tp->stepped_breakpoint = 1;\n \n@@ -2703,39 +2681,28 @@ new_stop_id (void)\n static void\n clear_proceed_status_thread (struct thread_info *tp)\n {\n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: clear_proceed_status_thread (%s)\\n\",\n-\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+  infrun_debug_printf (\"%s\", target_pid_to_str (tp->ptid).c_str ());\n \n   /* If we're starting a new sequence, then the previous finished\n      single-step is no longer relevant.  */\n   if (tp->suspend.waitstatus_pending_p)\n     {\n       if (tp->suspend.stop_reason == TARGET_STOPPED_BY_SINGLE_STEP)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: clear_proceed_status: pending \"\n-\t\t\t\t\"event of %s was a finished step. \"\n-\t\t\t\t\"Discarding.\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"pending event of %s was a finished step. \"\n+\t\t\t       \"Discarding.\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \n \t  tp->suspend.waitstatus_pending_p = 0;\n \t  tp->suspend.stop_reason = TARGET_STOPPED_BY_NO_REASON;\n \t}\n-      else if (debug_infrun)\n+      else\n \t{\n-\t  std::string statstr\n-\t    = target_waitstatus_to_string (&tp->suspend.waitstatus);\n-\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"infrun: clear_proceed_status_thread: thread %s \"\n-\t\t\t      \"has pending wait status %s \"\n-\t\t\t      \"(currently_stepping=%d).\\n\",\n-\t\t\t      target_pid_to_str (tp->ptid).c_str (),\n-\t\t\t      statstr.c_str (),\n-\t\t\t      currently_stepping (tp));\n+\t  infrun_debug_printf\n+\t    (\"thread %s has pending wait status %s (currently_stepping=%d).\",\n+\t     target_pid_to_str (tp->ptid).c_str (),\n+\t     target_waitstatus_to_string (&tp->suspend.waitstatus).c_str (),\n+\t     currently_stepping (tp));\n \t}\n     }\n \n@@ -3043,11 +3010,8 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n   if (!cur_thr->control.in_infcall)\n     set_running (resume_target, resume_ptid, true);\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: proceed (addr=%s, signal=%s)\\n\",\n-\t\t\tpaddress (gdbarch, addr),\n-\t\t\tgdb_signal_to_symbol_string (siggnal));\n+  infrun_debug_printf (\"addr=%s, signal=%s\", paddress (gdbarch, addr),\n+\t\t       gdb_signal_to_symbol_string (siggnal));\n \n   annotate_starting ();\n \n@@ -3091,10 +3055,8 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \n \t  gdb_assert (!thread_is_in_step_over_chain (tp));\n \n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: need to step-over [%s] first\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"need to step-over [%s] first\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \n \t  thread_step_over_chain_enqueue (tp);\n \t}\n@@ -3141,37 +3103,28 @@ proceed (CORE_ADDR addr, enum gdb_signal siggnal)\n \n \t    if (!tp->inf->has_execution ())\n \t      {\n-\t\tif (debug_infrun)\n-\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t      \"infrun: proceed: [%s] target has \"\n-\t\t\t\t      \"no execution\\n\",\n-\t\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n+\t\tinfrun_debug_printf (\"[%s] target has no execution\",\n+\t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n \t\tcontinue;\n \t      }\n \n \t    if (tp->resumed)\n \t      {\n-\t\tif (debug_infrun)\n-\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t      \"infrun: proceed: [%s] resumed\\n\",\n-\t\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n+\t\tinfrun_debug_printf (\"[%s] resumed\",\n+\t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n \t\tgdb_assert (tp->executing || tp->suspend.waitstatus_pending_p);\n \t\tcontinue;\n \t      }\n \n \t    if (thread_is_in_step_over_chain (tp))\n \t      {\n-\t\tif (debug_infrun)\n-\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t      \"infrun: proceed: [%s] needs step-over\\n\",\n-\t\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n+\t\tinfrun_debug_printf (\"[%s] needs step-over\",\n+\t\t\t\t     target_pid_to_str (tp->ptid).c_str ());\n \t\tcontinue;\n \t      }\n \n-\t    if (debug_infrun)\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \"infrun: proceed: resuming %s\\n\",\n-\t\t\t\t  target_pid_to_str (tp->ptid).c_str ());\n+\t    infrun_debug_printf (\"resuming %s\",\n+\t\t\t         target_pid_to_str (tp->ptid).c_str ());\n \n \t    reset_ecs (ecs, tp);\n \t    switch_to_thread (tp);\n@@ -3406,19 +3359,19 @@ print_target_wait_results (ptid_t waiton_ptid, ptid_t result_ptid,\n      output as a unit; we want only one timestamp printed if debug_timestamp\n      is set.  */\n \n-  stb.printf (\"infrun: target_wait (%d.%ld.%ld\",\n+  stb.printf (\"[infrun] target_wait (%d.%ld.%ld\",\n \t      waiton_ptid.pid (),\n \t      waiton_ptid.lwp (),\n \t      waiton_ptid.tid ());\n   if (waiton_ptid.pid () != -1)\n     stb.printf (\" [%s]\", target_pid_to_str (waiton_ptid).c_str ());\n   stb.printf (\", status) =\\n\");\n-  stb.printf (\"infrun:   %d.%ld.%ld [%s],\\n\",\n+  stb.printf (\"[infrun]   %d.%ld.%ld [%s],\\n\",\n \t      result_ptid.pid (),\n \t      result_ptid.lwp (),\n \t      result_ptid.tid (),\n \t      target_pid_to_str (result_ptid).c_str ());\n-  stb.printf (\"infrun:   %s\\n\", status_string.c_str ());\n+  stb.printf (\"[infrun]   %s\\n\", status_string.c_str ());\n \n   /* This uses %s in part to handle %'s in the text, but also to avoid\n      a gcc error: the format attribute requires a string literal.  */\n@@ -3453,10 +3406,9 @@ random_pending_event_thread (inferior *inf, ptid_t waiton_ptid)\n   int random_selector = (int) ((num_events * (double) rand ())\n \t\t\t       / (RAND_MAX + 1.0));\n \n-  if (debug_infrun && num_events > 1)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: Found %d events, selecting #%d\\n\",\n-\t\t\tnum_events, random_selector);\n+  if (num_events > 1)\n+    infrun_debug_printf (\"Found %d events, selecting #%d\",\n+\t\t\t num_events, random_selector);\n \n   /* Select the Nth thread that has had an event.  */\n   for (thread_info *tp : inf->non_exited_threads ())\n@@ -3493,10 +3445,8 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n     }\n   else\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: Waiting for specific thread %s.\\n\",\n-\t\t\t    target_pid_to_str (ptid).c_str ());\n+      infrun_debug_printf (\"Waiting for specific thread %s.\",\n+\t\t\t   target_pid_to_str (ptid).c_str ());\n \n       /* We have a specific thread to check.  */\n       tp = find_thread_ptid (inf, ptid);\n@@ -3518,31 +3468,25 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n \n       if (pc != tp->suspend.stop_pc)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: PC of %s changed.  was=%s, now=%s\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str (),\n-\t\t\t\tpaddress (gdbarch, tp->suspend.stop_pc),\n-\t\t\t\tpaddress (gdbarch, pc));\n+\t  infrun_debug_printf (\"PC of %s changed.  was=%s, now=%s\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t       paddress (gdbarch, tp->suspend.stop_pc),\n+\t\t\t       paddress (gdbarch, pc));\n \t  discard = 1;\n \t}\n       else if (!breakpoint_inserted_here_p (regcache->aspace (), pc))\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: previous breakpoint of %s, at %s gone\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str (),\n-\t\t\t\tpaddress (gdbarch, pc));\n+\t  infrun_debug_printf (\"previous breakpoint of %s, at %s gone\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t       paddress (gdbarch, pc));\n \n \t  discard = 1;\n \t}\n \n       if (discard)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: pending event of %s cancelled.\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"pending event of %s cancelled.\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \n \t  tp->suspend.waitstatus.kind = TARGET_WAITKIND_SPURIOUS;\n \t  tp->suspend.stop_reason = TARGET_STOPPED_BY_NO_REASON;\n@@ -3551,16 +3495,10 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n \n   if (tp != NULL)\n     {\n-      if (debug_infrun)\n-\t{\n-\t  std::string statstr\n-\t    = target_waitstatus_to_string (&tp->suspend.waitstatus);\n-\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"infrun: Using pending wait status %s for %s.\\n\",\n-\t\t\t      statstr.c_str (),\n-\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n-\t}\n+      infrun_debug_printf (\"Using pending wait status %s for %s.\",\n+\t\t\t   target_waitstatus_to_string\n+\t\t\t     (&tp->suspend.waitstatus).c_str (),\n+\t\t\t   target_pid_to_str (tp->ptid).c_str ());\n \n       /* Now that we've selected our final event LWP, un-adjust its PC\n \t if it was a software breakpoint (and the target doesn't\n@@ -3642,10 +3580,9 @@ do_target_wait (ptid_t wait_ptid, execution_control_state *ecs, int options)\n   random_selector = (int)\n     ((num_inferiors * (double) rand ()) / (RAND_MAX + 1.0));\n \n-  if (debug_infrun && num_inferiors > 1)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: Found %d inferiors, starting at #%d\\n\",\n-\t\t\tnum_inferiors, random_selector);\n+  if (num_inferiors > 1)\n+    infrun_debug_printf (\"Found %d inferiors, starting at #%d\",\n+\t\t\t num_inferiors, random_selector);\n \n   /* Select the Nth inferior that matched.  */\n \n@@ -3709,9 +3646,7 @@ prepare_for_detach (void)\n   if (displaced->step_thread == nullptr)\n     return;\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"displaced-stepping in-process while detaching\");\n+  infrun_debug_printf (\"displaced-stepping in-process while detaching\");\n \n   scoped_restore restore_detaching = make_scoped_restore (&inf->detaching, true);\n \n@@ -3770,9 +3705,7 @@ prepare_for_detach (void)\n static void\n wait_for_inferior (inferior *inf)\n {\n-  if (debug_infrun)\n-    fprintf_unfiltered\n-      (gdb_stdlog, \"infrun: wait_for_inferior ()\\n\");\n+  infrun_debug_printf (\"wait_for_inferior ()\");\n \n   SCOPE_EXIT { delete_just_stopped_threads_infrun_breakpoints (); };\n \n@@ -4148,15 +4081,13 @@ nullify_last_target_wait_ptid (void)\n static void\n context_switch (execution_control_state *ecs)\n {\n-  if (debug_infrun\n-      && ecs->ptid != inferior_ptid\n+  if (ecs->ptid != inferior_ptid\n       && (inferior_ptid == null_ptid\n \t  || ecs->event_thread != inferior_thread ()))\n     {\n-      fprintf_unfiltered (gdb_stdlog, \"infrun: Switching context from %s \",\n-\t\t\t  target_pid_to_str (inferior_ptid).c_str ());\n-      fprintf_unfiltered (gdb_stdlog, \"to %s\\n\",\n-\t\t\t  target_pid_to_str (ecs->ptid).c_str ());\n+      infrun_debug_printf (\"Switching context from %s to %s\",\n+\t\t\t   target_pid_to_str (inferior_ptid).c_str (),\n+\t\t\t   target_pid_to_str (ecs->ptid).c_str ());\n     }\n \n   switch_to_thread (ecs->event_thread);\n@@ -4401,9 +4332,7 @@ handle_syscall_event (struct execution_control_state *ecs)\n   if (catch_syscall_enabled () > 0\n       && catching_syscall_number (syscall_number) > 0)\n     {\n-      if (debug_infrun)\n-        fprintf_unfiltered (gdb_stdlog, \"infrun: syscall number = '%d'\\n\",\n-                            syscall_number);\n+      infrun_debug_printf (\"syscall number=%d\", syscall_number);\n \n       ecs->event_thread->control.stop_bpstat\n \t= bpstat_stop_status (regcache->aspace (),\n@@ -4599,17 +4528,11 @@ wait_one ()\n static void\n save_waitstatus (struct thread_info *tp, const target_waitstatus *ws)\n {\n-  if (debug_infrun)\n-    {\n-      std::string statstr = target_waitstatus_to_string (ws);\n-\n-      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t  \"infrun: saving status %s for %d.%ld.%ld\\n\",\n-\t\t\t  statstr.c_str (),\n-\t\t\t  tp->ptid.pid (),\n-\t\t\t  tp->ptid.lwp (),\n-\t\t\t  tp->ptid.tid ());\n-    }\n+  infrun_debug_printf (\"saving status %s for %d.%ld.%ld\",\n+\t\t       target_waitstatus_to_string (ws).c_str (),\n+\t\t       tp->ptid.pid (),\n+\t\t       tp->ptid.lwp (),\n+\t\t       tp->ptid.tid ());\n \n   /* Record for later.  */\n   tp->suspend.waitstatus = *ws;\n@@ -4720,8 +4643,7 @@ stop_all_threads (void)\n \n   gdb_assert (exists_non_stop_target ());\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog, \"infrun: stop_all_threads\\n\");\n+  infrun_debug_printf (\"starting\");\n \n   scoped_restore_current_thread restore_thread;\n \n@@ -4741,8 +4663,10 @@ stop_all_threads (void)\n \t  target_thread_events (false);\n \t}\n \n+      /* Use infrun_debug_printf_1 directly to get a meaningful function\n+         name.  */\n       if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: stop_all_threads done\\n\");\n+\tinfrun_debug_printf_1 (\"stop_all_threads\", \"done\");\n     };\n \n   /* Request threads to stop, and then wait for the stops.  Because\n@@ -4752,10 +4676,7 @@ stop_all_threads (void)\n      until two passes find no threads that need to be stopped.  */\n   for (pass = 0; pass < 2; pass++, iterations++)\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: stop_all_threads, pass=%d, \"\n-\t\t\t    \"iterations=%d\\n\", pass, iterations);\n+      infrun_debug_printf (\"pass=%d, iterations=%d\", pass, iterations);\n       while (1)\n \t{\n \t  int waits_needed = 0;\n@@ -4787,32 +4708,24 @@ stop_all_threads (void)\n \t\t     We just haven't seen the notification yet.  */\n \t\t  if (!t->stop_requested)\n \t\t    {\n-\t\t      if (debug_infrun)\n-\t\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t    \"infrun:   %s executing, \"\n-\t\t\t\t\t    \"need stop\\n\",\n-\t\t\t\t\t    target_pid_to_str (t->ptid).c_str ());\n+\t\t      infrun_debug_printf (\"  %s executing, need stop\",\n+\t\t\t\t\t   target_pid_to_str (t->ptid).c_str ());\n \t\t      target_stop (t->ptid);\n \t\t      t->stop_requested = 1;\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      if (debug_infrun)\n-\t\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t    \"infrun:   %s executing, \"\n-\t\t\t\t\t    \"already stopping\\n\",\n-\t\t\t\t\t    target_pid_to_str (t->ptid).c_str ());\n+\t\t      infrun_debug_printf (\"  %s executing, already stopping\",\n+\t\t\t\t\t   target_pid_to_str (t->ptid).c_str ());\n \t\t    }\n \n \t\t  if (t->stop_requested)\n \t\t    waits_needed++;\n \t\t}\n \t      else\n \t\t{\n-\t\t  if (debug_infrun)\n-\t\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t\"infrun:   %s not executing\\n\",\n-\t\t\t\t\ttarget_pid_to_str (t->ptid).c_str ());\n+\t\t  infrun_debug_printf (\"  %s not executing\",\n+\t\t\t\t       target_pid_to_str (t->ptid).c_str ());\n \n \t\t  /* The thread may be not executing, but still be\n \t\t     resumed with a pending status to process.  */\n@@ -4833,13 +4746,9 @@ stop_all_threads (void)\n \t    {\n \t      wait_one_event event = wait_one ();\n \n-\t      if (debug_infrun)\n-\t\t{\n-\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t      \"infrun: stop_all_threads %s %s\\n\",\n-\t\t\t\t      target_waitstatus_to_string (&event.ws).c_str (),\n-\t\t\t\t      target_pid_to_str (event.ptid).c_str ());\n-\t\t}\n+\t      infrun_debug_printf\n+\t\t(\"%s %s\", target_waitstatus_to_string (&event.ws).c_str (),\n+\t\t target_pid_to_str (event.ptid).c_str ());\n \n \t      if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED)\n \t\t{\n@@ -4874,10 +4783,8 @@ stop_all_threads (void)\n \t\t\t of going into an infinite loop.  */\n \t\t      gdb_assert (t != nullptr);\n \n-\t\t      if (debug_infrun)\n-\t\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t    \"infrun: stop_all_threads, using %s\\n\",\n-\t\t\t\t\t    target_pid_to_str (t->ptid).c_str ());\n+\t\t      infrun_debug_printf\n+\t\t\t(\"using %s\", target_pid_to_str (t->ptid).c_str ());\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -4931,14 +4838,11 @@ stop_all_threads (void)\n \t\t      if (displaced_step_fixup (t, GDB_SIGNAL_0) < 0)\n \t\t\t{\n \t\t\t  /* Add it back to the step-over queue.  */\n-\t\t\t  if (debug_infrun)\n-\t\t\t    {\n-\t\t\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t\t  \"infrun: displaced-step of %s \"\n-\t\t\t\t\t\t  \"canceled: adding back to the \"\n-\t\t\t\t\t\t  \"step-over queue\\n\",\n-\t\t\t\t\t\t  target_pid_to_str (t->ptid).c_str ());\n-\t\t\t    }\n+\t\t\t  infrun_debug_printf\n+\t\t\t    (\"displaced-step of %s canceled: adding back to \"\n+\t\t\t     \"the step-over queue\",\n+\t\t\t      target_pid_to_str (t->ptid).c_str ());\n+\n \t\t\t  t->control.trap_expected = 0;\n \t\t\t  thread_step_over_chain_enqueue (t);\n \t\t\t}\n@@ -4948,18 +4852,10 @@ stop_all_threads (void)\n \t\t      enum gdb_signal sig;\n \t\t      struct regcache *regcache;\n \n-\t\t      if (debug_infrun)\n-\t\t\t{\n-\t\t\t  std::string statstr = target_waitstatus_to_string (&event.ws);\n-\n-\t\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t      \"infrun: target_wait %s, saving \"\n-\t\t\t\t\t      \"status for %d.%ld.%ld\\n\",\n-\t\t\t\t\t      statstr.c_str (),\n-\t\t\t\t\t      t->ptid.pid (),\n-\t\t\t\t\t      t->ptid.lwp (),\n-\t\t\t\t\t      t->ptid.tid ());\n-\t\t\t}\n+\t\t      infrun_debug_printf\n+\t\t\t(\"target_wait %s, saving status for %d.%ld.%ld\",\n+\t\t\t target_waitstatus_to_string (&event.ws).c_str (),\n+\t\t\t t->ptid.pid (), t->ptid.lwp (), t->ptid.tid ());\n \n \t\t      /* Record for later.  */\n \t\t      save_waitstatus (t, &event.ws);\n@@ -4977,16 +4873,12 @@ stop_all_threads (void)\n \t\t      regcache = get_thread_regcache (t);\n \t\t      t->suspend.stop_pc = regcache_read_pc (regcache);\n \n-\t\t      if (debug_infrun)\n-\t\t\t{\n-\t\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\t      \"infrun: saved stop_pc=%s for %s \"\n-\t\t\t\t\t      \"(currently_stepping=%d)\\n\",\n-\t\t\t\t\t      paddress (target_gdbarch (),\n-\t\t\t\t\t\t\tt->suspend.stop_pc),\n-\t\t\t\t\t      target_pid_to_str (t->ptid).c_str (),\n-\t\t\t\t\t      currently_stepping (t));\n-\t\t\t}\n+\t\t      infrun_debug_printf (\"saved stop_pc=%s for %s \"\n+\t\t\t\t\t   \"(currently_stepping=%d)\",\n+\t\t\t\t\t   paddress (target_gdbarch (),\n+\t\t\t\t\t\t     t->suspend.stop_pc),\n+\t\t\t\t\t   target_pid_to_str (t->ptid).c_str (),\n+\t\t\t\t\t   currently_stepping (t));\n \t\t    }\n \t\t}\n \t    }\n@@ -5017,10 +4909,7 @@ handle_no_resumed (struct execution_control_state *ecs)\n \t     we're not synchronously waiting for events either.  Just\n \t     ignore.  */\n \n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: TARGET_WAITKIND_NO_RESUMED \"\n-\t\t\t\t\"(ignoring: bg)\\n\");\n+\t  infrun_debug_printf (\"TARGET_WAITKIND_NO_RESUMED (ignoring: bg)\");\n \t  prepare_to_wait (ecs);\n \t  return 1;\n \t}\n@@ -5111,10 +5000,8 @@ handle_no_resumed (struct execution_control_state *ecs)\n \t     target at some point, but there are now, or some target\n \t     other than the eventing one has unwaited-for children\n \t     left.  Just ignore.  */\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: TARGET_WAITKIND_NO_RESUMED \"\n-\t\t\t\t\"(ignoring: found resumed)\\n\");\n+\t  infrun_debug_printf (\"TARGET_WAITKIND_NO_RESUMED \"\n+\t\t\t       \"(ignoring: found resumed)\");\n \n \t  ignore_event = true;\n \t}\n@@ -5157,9 +5044,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \n   enum stop_kind stop_soon;\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog, \"infrun: handle_inferior_event %s\\n\",\n-\t\t\ttarget_waitstatus_to_string (&ecs->ws).c_str ());\n+  infrun_debug_printf (\"%s\", target_waitstatus_to_string (&ecs->ws).c_str ());\n \n   if (ecs->ws.kind == TARGET_WAITKIND_IGNORE)\n     {\n@@ -5242,9 +5127,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n       if (breakpoint_inserted_here_p (regcache->aspace (),\n \t\t\t\t      regcache_read_pc (regcache)))\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: Treating signal as SIGTRAP\\n\");\n+\t  infrun_debug_printf (\"Treating signal as SIGTRAP\");\n \t  ecs->ws.value.sig = GDB_SIGNAL_TRAP;\n \t}\n     }\n@@ -5321,8 +5204,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n       if (stop_soon == STOP_QUIETLY_NO_SIGSTOP\n \t  || stop_soon == STOP_QUIETLY_REMOTE)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog, \"infrun: quietly stopped\\n\");\n+\t  infrun_debug_printf (\"quietly stopped\");\n \t  stop_waiting (ecs);\n \t  return;\n \t}\n@@ -5406,9 +5288,8 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t\t information to the user.  It's better to just warn\n \t\t her about it (if infrun debugging is enabled), and\n \t\t give up.  */\n-\t      if (debug_infrun)\n-\t\tfprintf_filtered (gdb_stdlog, _(\"\\\n-Cannot fill $_exitsignal with the correct signal number.\\n\"));\n+\t      infrun_debug_printf (\"Cannot fill $_exitsignal with the correct \"\n+\t\t\t\t   \"signal number.\");\n \t    }\n \n \t  gdb::observers::signal_exited.notify (ecs->ws.value.sig);\n@@ -5674,8 +5555,7 @@ Cannot fill $_exitsignal with the correct signal number.\\n\"));\n \n       /* Switch to the stopped thread.  */\n       context_switch (ecs);\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: stopped\\n\");\n+      infrun_debug_printf (\"stopped\");\n \n       delete_just_stopped_threads_single_step_breakpoints ();\n       ecs->event_thread->suspend.stop_pc\n@@ -5706,53 +5586,39 @@ restart_threads (struct thread_info *event_thread)\n \n       if (tp == event_thread)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: restart threads: \"\n-\t\t\t\t\"[%s] is event thread\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"restart threads: [%s] is event thread\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \t  continue;\n \t}\n \n       if (!(tp->state == THREAD_RUNNING || tp->control.in_infcall))\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: restart threads: \"\n-\t\t\t\t\"[%s] not meant to be running\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"restart threads: [%s] not meant to be running\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \t  continue;\n \t}\n \n       if (tp->resumed)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: restart threads: [%s] resumed\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"restart threads: [%s] resumed\",\n+\t\t\t      target_pid_to_str (tp->ptid).c_str ());\n \t  gdb_assert (tp->executing || tp->suspend.waitstatus_pending_p);\n \t  continue;\n \t}\n \n       if (thread_is_in_step_over_chain (tp))\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: restart threads: \"\n-\t\t\t\t\"[%s] needs step-over\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"restart threads: [%s] needs step-over\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \t  gdb_assert (!tp->resumed);\n \t  continue;\n \t}\n \n \n       if (tp->suspend.waitstatus_pending_p)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: restart threads: \"\n-\t\t\t\t\"[%s] has pending status\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"restart threads: [%s] has pending status\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \t  tp->resumed = true;\n \t  continue;\n \t}\n@@ -5772,21 +5638,17 @@ restart_threads (struct thread_info *event_thread)\n \n       if (currently_stepping (tp))\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: restart threads: [%s] was stepping\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"restart threads: [%s] was stepping\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \t  keep_going_stepped_thread (tp);\n \t}\n       else\n \t{\n \t  struct execution_control_state ecss;\n \t  struct execution_control_state *ecs = &ecss;\n \n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: restart threads: [%s] continuing\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"restart threads: [%s] continuing\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \t  reset_ecs (ecs, tp);\n \t  switch_to_thread (tp);\n \t  keep_going_pass_signal (ecs);\n@@ -5879,12 +5741,8 @@ finish_step_over (struct execution_control_state *ecs)\n \t  struct thread_info *tp = ecs->event_thread;\n \t  struct regcache *regcache;\n \n-\t  if (debug_infrun)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \"infrun: found resumed threads with \"\n-\t\t\t\t  \"pending events, saving status\\n\");\n-\t    }\n+\t  infrun_debug_printf (\"found resumed threads with \"\n+\t\t\t       \"pending events, saving status\");\n \n \t  gdb_assert (pending != tp);\n \n@@ -5900,16 +5758,12 @@ finish_step_over (struct execution_control_state *ecs)\n \t  regcache = get_thread_regcache (tp);\n \t  tp->suspend.stop_pc = regcache_read_pc (regcache);\n \n-\t  if (debug_infrun)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \"infrun: saved stop_pc=%s for %s \"\n-\t\t\t\t  \"(currently_stepping=%d)\\n\",\n-\t\t\t\t  paddress (target_gdbarch (),\n-\t\t\t\t\t    tp->suspend.stop_pc),\n-\t\t\t\t  target_pid_to_str (tp->ptid).c_str (),\n-\t\t\t\t  currently_stepping (tp));\n-\t    }\n+\t  infrun_debug_printf (\"saved stop_pc=%s for %s \"\n+\t\t\t       \"(currently_stepping=%d)\",\n+\t\t\t       paddress (target_gdbarch (),\n+\t\t\t\t         tp->suspend.stop_pc),\n+\t\t\t       target_pid_to_str (tp->ptid).c_str (),\n+\t\t\t       currently_stepping (tp));\n \n \t  /* This in-line step-over finished; clear this so we won't\n \t     start a new one.  This is what handle_signal_stop would\n@@ -5965,22 +5819,20 @@ handle_signal_stop (struct execution_control_state *ecs)\n \n       switch_to_thread (ecs->event_thread);\n \n-      fprintf_unfiltered (gdb_stdlog, \"infrun: stop_pc = %s\\n\",\n-\t\t\t  paddress (reg_gdbarch,\n-\t\t\t\t    ecs->event_thread->suspend.stop_pc));\n+      infrun_debug_printf (\"stop_pc=%s\",\n+\t\t\t   paddress (reg_gdbarch,\n+\t\t\t\t     ecs->event_thread->suspend.stop_pc));\n       if (target_stopped_by_watchpoint ())\n \t{\n           CORE_ADDR addr;\n \n-\t  fprintf_unfiltered (gdb_stdlog, \"infrun: stopped by watchpoint\\n\");\n+\t  infrun_debug_printf (\"stopped by watchpoint\");\n \n \t  if (target_stopped_data_address (current_top_target (), &addr))\n-            fprintf_unfiltered (gdb_stdlog,\n-                                \"infrun: stopped data address = %s\\n\",\n-                                paddress (reg_gdbarch, addr));\n+\t    infrun_debug_printf (\"stopped data address=%s\",\n+\t\t\t         paddress (reg_gdbarch, addr));\n           else\n-            fprintf_unfiltered (gdb_stdlog,\n-                                \"infrun: (no data address available)\\n\");\n+\t    infrun_debug_printf (\"(no data address available)\");\n \t}\n     }\n \n@@ -5990,8 +5842,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n   if (stop_soon == STOP_QUIETLY || stop_soon == STOP_QUIETLY_REMOTE)\n     {\n       context_switch (ecs);\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: quietly stopped\\n\");\n+      infrun_debug_printf (\"quietly stopped\");\n       stop_print_frame = 1;\n       stop_waiting (ecs);\n       return;\n@@ -6032,8 +5883,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n      so, then switch to that thread.  */\n   if (ecs->ptid != inferior_ptid)\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: context switch\\n\");\n+      infrun_debug_printf (\"context switch\");\n \n       context_switch (ecs);\n \n@@ -6064,25 +5914,16 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t{\n \t  if (single_step_breakpoint_inserted_here_p (aspace, pc))\n \t    {\n-\t      if (debug_infrun)\n-\t\t{\n-\t\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t      \"infrun: [%s] hit another thread's \"\n-\t\t\t\t      \"single-step breakpoint\\n\",\n-\t\t\t\t      target_pid_to_str (ecs->ptid).c_str ());\n-\t\t}\n+\t      infrun_debug_printf (\"[%s] hit another thread's single-step \"\n+\t\t\t\t   \"breakpoint\",\n+\t\t\t\t   target_pid_to_str (ecs->ptid).c_str ());\n \t      ecs->hit_singlestep_breakpoint = 1;\n \t    }\n \t}\n       else\n \t{\n-\t  if (debug_infrun)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \"infrun: [%s] hit its \"\n-\t\t\t\t  \"single-step breakpoint\\n\",\n-\t\t\t\t  target_pid_to_str (ecs->ptid).c_str ());\n-\t    }\n+\t  infrun_debug_printf (\"[%s] hit its single-step breakpoint\",\n+\t\t\t       target_pid_to_str (ecs->ptid).c_str ());\n \t}\n     }\n   delete_just_stopped_threads_single_step_breakpoints ();\n@@ -6197,8 +6038,9 @@ handle_signal_stop (struct execution_control_state *ecs)\n       int step_through_delay\n \t= gdbarch_single_step_through_delay (gdbarch, frame);\n \n-      if (debug_infrun && step_through_delay)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: step through delay\\n\");\n+      if (step_through_delay)\n+\tinfrun_debug_printf (\"step through delay\");\n+\n       if (ecs->event_thread->control.step_range_end == 0\n \t  && step_through_delay)\n \t{\n@@ -6239,14 +6081,14 @@ handle_signal_stop (struct execution_control_state *ecs)\n      simply make sure to ignore it if `stopped_by_watchpoint' is\n      set.  */\n \n-  if (debug_infrun\n-      && ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n+  if (ecs->event_thread->suspend.stop_signal == GDB_SIGNAL_TRAP\n       && !bpstat_explains_signal (ecs->event_thread->control.stop_bpstat,\n \t\t\t\t  GDB_SIGNAL_TRAP)\n       && stopped_by_watchpoint)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: no user watchpoint explains \"\n-\t\t\t\"watchpoint SIGTRAP, ignoring\\n\");\n+    {\n+      infrun_debug_printf (\"no user watchpoint explains watchpoint SIGTRAP, \"\n+\t\t\t   \"ignoring\");\n+    }\n \n   /* NOTE: cagney/2003-03-29: These checks for a random signal\n      at one stage in the past included checks for an inferior\n@@ -6303,10 +6145,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n       else\n \t{\n \t  /* A delayed software breakpoint event.  Ignore the trap.  */\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: delayed software breakpoint \"\n-\t\t\t\t\"trap, ignoring\\n\");\n+\t  infrun_debug_printf (\"delayed software breakpoint trap, ignoring\");\n \t  random_signal = 0;\n \t}\n     }\n@@ -6316,10 +6155,8 @@ handle_signal_stop (struct execution_control_state *ecs)\n   if (random_signal && target_stopped_by_hw_breakpoint ())\n     {\n       /* A delayed hardware breakpoint event.  Ignore the trap.  */\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: delayed hardware breakpoint/watchpoint \"\n-\t\t\t    \"trap, ignoring\\n\");\n+      infrun_debug_printf (\"delayed hardware breakpoint/watchpoint \"\n+\t\t\t   \"trap, ignoring\");\n       random_signal = 0;\n     }\n \n@@ -6343,8 +6180,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n   if (ecs->event_thread->stop_requested)\n     {\n       random_signal = 1;\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: user-requested stop\\n\");\n+      infrun_debug_printf (\"user-requested stop\");\n     }\n \n   /* For the program's own signals, act according to\n@@ -6356,9 +6192,8 @@ handle_signal_stop (struct execution_control_state *ecs)\n       struct inferior *inf = find_inferior_ptid (ecs->target, ecs->ptid);\n       enum gdb_signal stop_signal = ecs->event_thread->suspend.stop_signal;\n \n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog, \"infrun: random signal (%s)\\n\",\n-\t\t\t     gdb_signal_to_symbol_string (stop_signal));\n+      infrun_debug_printf (\"random signal (%s)\",\n+\t\t\t   gdb_signal_to_symbol_string (stop_signal));\n \n       stopped_by_random_signal = 1;\n \n@@ -6403,10 +6238,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t     code paths as single-step - set a breakpoint at the\n \t     signal return address and then, once hit, step off that\n \t     breakpoint.  */\n-          if (debug_infrun)\n-            fprintf_unfiltered (gdb_stdlog,\n-                                \"infrun: signal arrived while stepping over \"\n-                                \"breakpoint\\n\");\n+\t  infrun_debug_printf (\"signal arrived while stepping over breakpoint\");\n \n \t  insert_hp_step_resume_breakpoint_at_frame (frame);\n \t  ecs->event_thread->step_after_step_resume_breakpoint = 1;\n@@ -6437,10 +6269,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \t     Note that this is only needed for a signal delivered\n \t     while in the single-step range.  Nested signals aren't a\n \t     problem as they eventually all return.  */\n-          if (debug_infrun)\n-            fprintf_unfiltered (gdb_stdlog,\n-                                \"infrun: signal may take us out of \"\n-                                \"single-step range\\n\");\n+\t  infrun_debug_printf (\"signal may take us out of single-step range\");\n \n \t  clear_step_over_info ();\n \t  insert_hp_step_resume_breakpoint_at_frame (frame);\n@@ -6460,9 +6289,7 @@ handle_signal_stop (struct execution_control_state *ecs)\n \n       if (!switch_back_to_stepped_thread (ecs))\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: random signal, keep going\\n\");\n+\t  infrun_debug_printf (\"random signal, keep going\");\n \n \t  keep_going (ecs);\n \t}\n@@ -6516,9 +6343,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t install a momentary breakpoint at the target of the\n \t jmp_buf.  */\n \n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME\\n\");\n+      infrun_debug_printf (\"BPSTAT_WHAT_SET_LONGJMP_RESUME\");\n \n       ecs->event_thread->stepping_over_breakpoint = 1;\n \n@@ -6539,10 +6364,8 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t\t   || !gdbarch_get_longjmp_target (gdbarch,\n \t\t\t\t\t\t   frame, &jmp_buf_pc))\n \t    {\n-\t      if (debug_infrun)\n-\t\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t    \"infrun: BPSTAT_WHAT_SET_LONGJMP_RESUME \"\n-\t\t\t\t    \"(!gdbarch_get_longjmp_target)\\n\");\n+\t      infrun_debug_printf (\"BPSTAT_WHAT_SET_LONGJMP_RESUME \"\n+\t\t\t\t   \"(!gdbarch_get_longjmp_target)\");\n \t      keep_going (ecs);\n \t      return;\n \t    }\n@@ -6577,9 +6400,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t   against stale dummy frames and user is not interested in\n \t   stopping around longjmps.  */\n \n-\tif (debug_infrun)\n-\t  fprintf_unfiltered (gdb_stdlog,\n-\t\t\t      \"infrun: BPSTAT_WHAT_CLEAR_LONGJMP_RESUME\\n\");\n+\tinfrun_debug_printf (\"BPSTAT_WHAT_CLEAR_LONGJMP_RESUME\");\n \n \tgdb_assert (ecs->event_thread->control.exception_resume_breakpoint\n \t\t    != NULL);\n@@ -6625,16 +6446,14 @@ process_event_stop_test (struct execution_control_state *ecs)\n       return;\n \n     case BPSTAT_WHAT_SINGLE:\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: BPSTAT_WHAT_SINGLE\\n\");\n+      infrun_debug_printf (\"BPSTAT_WHAT_SINGLE\");\n       ecs->event_thread->stepping_over_breakpoint = 1;\n       /* Still need to check other stuff, at least the case where we\n \t are stepping and step out of the right range.  */\n       break;\n \n     case BPSTAT_WHAT_STEP_RESUME:\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: BPSTAT_WHAT_STEP_RESUME\\n\");\n+      infrun_debug_printf (\"BPSTAT_WHAT_STEP_RESUME\");\n \n       delete_step_resume_breakpoint (ecs->event_thread);\n       if (ecs->event_thread->control.proceed_to_finish\n@@ -6666,8 +6485,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       break;\n \n     case BPSTAT_WHAT_STOP_NOISY:\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: BPSTAT_WHAT_STOP_NOISY\\n\");\n+      infrun_debug_printf (\"BPSTAT_WHAT_STOP_NOISY\");\n       stop_print_frame = 1;\n \n       /* Assume the thread stopped for a breakpoint.  We'll still check\n@@ -6679,8 +6497,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       return;\n \n     case BPSTAT_WHAT_STOP_SILENT:\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: BPSTAT_WHAT_STOP_SILENT\\n\");\n+      infrun_debug_printf (\"BPSTAT_WHAT_STOP_SILENT\");\n       stop_print_frame = 0;\n \n       /* Assume the thread stopped for a breakpoint.  We'll still check\n@@ -6691,8 +6508,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       return;\n \n     case BPSTAT_WHAT_HP_STEP_RESUME:\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog, \"infrun: BPSTAT_WHAT_HP_STEP_RESUME\\n\");\n+      infrun_debug_printf (\"BPSTAT_WHAT_HP_STEP_RESUME\");\n \n       delete_step_resume_breakpoint (ecs->event_thread);\n       if (ecs->event_thread->step_after_step_resume_breakpoint)\n@@ -6727,10 +6543,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t  && sr_bp->type == bp_hp_step_resume\n \t  && sr_bp->loc->address == ecs->event_thread->prev_pc)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: stepped permanent breakpoint, stopped in \"\n-\t\t\t\t\"handler\\n\");\n+\t  infrun_debug_printf (\"stepped permanent breakpoint, stopped in handler\");\n \t  delete_step_resume_breakpoint (ecs->event_thread);\n \t  ecs->event_thread->step_after_step_resume_breakpoint = 0;\n \t}\n@@ -6748,9 +6561,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \n   if (ecs->event_thread->control.step_resume_breakpoint)\n     {\n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog,\n-\t\t\t     \"infrun: step-resume breakpoint is inserted\\n\");\n+      infrun_debug_printf (\"step-resume breakpoint is inserted\");\n \n       /* Having a step-resume breakpoint overrides anything\n          else having to do with stepping commands until\n@@ -6761,8 +6572,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \n   if (ecs->event_thread->control.step_range_end == 0)\n     {\n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog, \"infrun: no stepping, continue\\n\");\n+      infrun_debug_printf (\"no stepping, continue\");\n       /* Likewise if we aren't even stepping.  */\n       keep_going (ecs);\n       return;\n@@ -6791,11 +6601,10 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t  || frame_id_eq (get_frame_id (frame),\n \t\t\t  ecs->event_thread->control.step_frame_id)))\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered\n-\t  (gdb_stdlog, \"infrun: stepping inside range [%s-%s]\\n\",\n-\t   paddress (gdbarch, ecs->event_thread->control.step_range_start),\n-\t   paddress (gdbarch, ecs->event_thread->control.step_range_end));\n+      infrun_debug_printf\n+\t(\"stepping inside range [%s-%s]\",\n+\t paddress (gdbarch, ecs->event_thread->control.step_range_start),\n+\t paddress (gdbarch, ecs->event_thread->control.step_range_end));\n \n       /* Tentatively re-enable range stepping; `resume' disables it if\n \t necessary (e.g., if we're stepping over a breakpoint or we\n@@ -6838,9 +6647,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \tgdbarch_skip_solib_resolver (gdbarch,\n \t\t\t\t     ecs->event_thread->suspend.stop_pc);\n \n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog,\n-\t\t\t     \"infrun: stepped into dynsym resolve code\\n\");\n+      infrun_debug_printf (\"stepped into dynsym resolve code\");\n \n       if (pc_after_resolver)\n \t{\n@@ -6863,9 +6670,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       && gdbarch_in_indirect_branch_thunk (gdbarch,\n \t\t\t\t\t   ecs->event_thread->suspend.stop_pc))\n     {\n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog,\n-\t\t\t     \"infrun: stepped into indirect branch thunk\\n\");\n+      infrun_debug_printf (\"stepped into indirect branch thunk\");\n       keep_going (ecs);\n       return;\n     }\n@@ -6875,9 +6680,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t  || ecs->event_thread->control.step_over_calls == STEP_OVER_ALL)\n       && get_frame_type (frame) == SIGTRAMP_FRAME)\n     {\n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog,\n-\t\t\t     \"infrun: stepped into signal trampoline\\n\");\n+      infrun_debug_printf (\"stepped into signal trampoline\");\n       /* The inferior, while doing a \"step\" or \"next\", has ended up in\n          a signal trampoline (either by a signal being delivered or by\n          the signal handler returning).  Just single-step until the\n@@ -6902,9 +6705,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       CORE_ADDR real_stop_pc\n \t= gdbarch_skip_trampoline_code (gdbarch, frame, stop_pc);\n \n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog,\n-\t\t\t     \"infrun: stepped into solib return tramp\\n\");\n+      infrun_debug_printf (\"stepped into solib return tramp\");\n \n       /* Only proceed through if we know where it's going.  */\n       if (real_stop_pc)\n@@ -6957,8 +6758,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       CORE_ADDR stop_pc = ecs->event_thread->suspend.stop_pc;\n       CORE_ADDR real_stop_pc;\n \n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog, \"infrun: stepped into subroutine\\n\");\n+      infrun_debug_printf (\"stepped into subroutine\");\n \n       if (ecs->event_thread->control.step_over_calls == STEP_OVER_NONE)\n \t{\n@@ -7155,9 +6955,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       && ecs->stop_func_name == NULL\n       && stop_pc_sal.line == 0)\n     {\n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog,\n-\t\t\t     \"infrun: stepped into undebuggable function\\n\");\n+      infrun_debug_printf (\"stepped into undebuggable function\");\n \n       /* The inferior just stepped into, or returned to, an\n          undebuggable function (where there is no debugging information\n@@ -7190,8 +6988,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n     {\n       /* It is stepi or nexti.  We always want to stop stepping after\n          one instruction.  */\n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog, \"infrun: stepi/nexti\\n\");\n+      infrun_debug_printf (\"stepi/nexti\");\n       end_stepping_range (ecs);\n       return;\n     }\n@@ -7202,8 +6999,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n          stepping (does this always happen right after one instruction,\n          when we do \"s\" in a function with no line numbers,\n          or can this happen as a result of a return or longjmp?).  */\n-      if (debug_infrun)\n-\t fprintf_unfiltered (gdb_stdlog, \"infrun: no line number info\\n\");\n+      infrun_debug_printf (\"line number info\");\n       end_stepping_range (ecs);\n       return;\n     }\n@@ -7216,9 +7012,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t\t   ecs->event_thread->control.step_frame_id)\n       && inline_skipped_frames (ecs->event_thread))\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: stepped into inlined function\\n\");\n+      infrun_debug_printf (\"stepped into inlined function\");\n \n       symtab_and_line call_sal = find_frame_sal (get_current_frame ());\n \n@@ -7268,9 +7062,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n       && stepped_in_from (get_current_frame (),\n \t\t\t  ecs->event_thread->control.step_frame_id))\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: stepping through inlined function\\n\");\n+      infrun_debug_printf (\"stepping through inlined function\");\n \n       if (ecs->event_thread->control.step_over_calls == STEP_OVER_ALL\n \t  || inline_frame_is_marked_for_skip (false, ecs->event_thread))\n@@ -7291,9 +7083,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t     we don't stop if we step into the middle of a different line.\n \t     That is said to make things like for (;;) statements work\n \t     better.  */\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: stepped to a different line\\n\");\n+\t  infrun_debug_printf (\"stepped to a different line\");\n \t  end_stepping_range (ecs);\n \t  return;\n \t}\n@@ -7305,10 +7095,8 @@ process_event_stop_test (struct execution_control_state *ecs)\n \t     ignore this line table entry, and continue stepping forward,\n \t     looking for a better place to stop.  */\n \t  refresh_step_info = false;\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: stepped to a different line, but \"\n-\t\t\t\t\"it's not the start of a statement\\n\");\n+\t  infrun_debug_printf (\"stepped to a different line, but \"\n+\t\t\t       \"it's not the start of a statement\");\n \t}\n     }\n \n@@ -7332,8 +7120,7 @@ process_event_stop_test (struct execution_control_state *ecs)\n   if (refresh_step_info)\n     set_step_info (ecs->event_thread, frame, stop_pc_sal);\n \n-  if (debug_infrun)\n-     fprintf_unfiltered (gdb_stdlog, \"infrun: keep going\\n\");\n+  infrun_debug_printf (\"keep going\");\n   keep_going (ecs);\n }\n \n@@ -7365,12 +7152,9 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n       if (ecs->event_thread->control.trap_expected\n \t  && ecs->event_thread->suspend.stop_signal != GDB_SIGNAL_TRAP)\n \t{\n-\t  if (debug_infrun)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \"infrun: need to finish step-over of [%s]\\n\",\n-\t\t\t\t  target_pid_to_str (ecs->event_thread->ptid).c_str ());\n-\t    }\n+\t  infrun_debug_printf\n+\t    (\"need to finish step-over of [%s]\",\n+\t     target_pid_to_str (ecs->event_thread->ptid).c_str ());\n \t  keep_going (ecs);\n \t  return 1;\n \t}\n@@ -7379,13 +7163,8 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t breakpoint of another thread.  */\n       if (ecs->hit_singlestep_breakpoint)\n        {\n-\t if (debug_infrun)\n-\t   {\n-\t     fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t \"infrun: need to step [%s] over single-step \"\n-\t\t\t\t \"breakpoint\\n\",\n-\t\t\t\t target_pid_to_str (ecs->ptid).c_str ());\n-\t   }\n+\t infrun_debug_printf (\"need to step [%s] over single-step breakpoint\",\n+\t\t\t      target_pid_to_str (ecs->ptid).c_str ());\n \t keep_going (ecs);\n \t return 1;\n        }\n@@ -7395,12 +7174,9 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \t another thread.  */\n       if (thread_still_needs_step_over (ecs->event_thread))\n \t{\n-\t  if (debug_infrun)\n-\t    {\n-\t      fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t  \"infrun: thread [%s] still needs step-over\\n\",\n-\t\t\t\t  target_pid_to_str (ecs->event_thread->ptid).c_str ());\n-\t    }\n+\t  infrun_debug_printf\n+\t    (\"thread [%s] still needs step-over\",\n+\t     target_pid_to_str (ecs->event_thread->ptid).c_str ());\n \t  keep_going (ecs);\n \t  return 1;\n \t}\n@@ -7479,9 +7255,7 @@ switch_back_to_stepped_thread (struct execution_control_state *ecs)\n \n       if (stepping_thread != NULL)\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: switching back to stepped thread\\n\");\n+\t  infrun_debug_printf (\"switching back to stepped thread\");\n \n \t  if (keep_going_stepped_thread (stepping_thread))\n \t    {\n@@ -7527,18 +7301,14 @@ keep_going_stepped_thread (struct thread_info *tp)\n \n   if (tp->state == THREAD_EXITED || !target_thread_alive (tp->ptid))\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: not resuming previously  \"\n-\t\t\t    \"stepped thread, it has vanished\\n\");\n+      infrun_debug_printf (\"not resuming previously stepped thread, it has \"\n+\t\t\t   \"vanished\");\n \n       delete_thread (tp);\n       return 0;\n     }\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: resuming previously stepped thread\\n\");\n+  infrun_debug_printf (\"resuming previously stepped thread\");\n \n   reset_ecs (ecs, tp);\n   switch_to_thread (tp);\n@@ -7563,11 +7333,9 @@ keep_going_stepped_thread (struct thread_info *tp)\n     {\n       ptid_t resume_ptid;\n \n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: expected thread advanced also (%s -> %s)\\n\",\n-\t\t\t    paddress (target_gdbarch (), tp->prev_pc),\n-\t\t\t    paddress (target_gdbarch (), tp->suspend.stop_pc));\n+      infrun_debug_printf (\"expected thread advanced also (%s -> %s)\",\n+\t\t\t   paddress (target_gdbarch (), tp->prev_pc),\n+\t\t\t   paddress (target_gdbarch (), tp->suspend.stop_pc));\n \n       /* Clear the info of the previous step-over, as it's no longer\n \t valid (if the thread was trying to step over a breakpoint, it\n@@ -7589,9 +7357,7 @@ keep_going_stepped_thread (struct thread_info *tp)\n     }\n   else\n     {\n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: expected thread still hasn't advanced\\n\");\n+      infrun_debug_printf (\"expected thread still hasn't advanced\");\n \n       keep_going_pass_signal (ecs);\n     }\n@@ -7742,10 +7508,8 @@ insert_step_resume_breakpoint_at_sal_1 (struct gdbarch *gdbarch,\n   gdb_assert (inferior_thread ()->control.step_resume_breakpoint == NULL);\n   gdb_assert (sr_type == bp_step_resume || sr_type == bp_hp_step_resume);\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: inserting step-resume breakpoint at %s\\n\",\n-\t\t\tpaddress (gdbarch, sr_sal.pc));\n+  infrun_debug_printf (\"inserting step-resume breakpoint at %s\",\n+\t\t       paddress (gdbarch, sr_sal.pc));\n \n   inferior_thread ()->control.step_resume_breakpoint\n     = set_momentary_breakpoint (gdbarch, sr_sal, sr_id, sr_type).release ();\n@@ -7831,10 +7595,8 @@ insert_longjmp_resume_breakpoint (struct gdbarch *gdbarch, CORE_ADDR pc)\n      longjmp_resume_breakpoint when one is already active.  */\n   gdb_assert (inferior_thread ()->control.exception_resume_breakpoint == NULL);\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: inserting longjmp-resume breakpoint at %s\\n\",\n-\t\t\tpaddress (gdbarch, pc));\n+  infrun_debug_printf (\"inserting longjmp-resume breakpoint at %s\",\n+\t\t       paddress (gdbarch, pc));\n \n   inferior_thread ()->control.exception_resume_breakpoint =\n     set_momentary_breakpoint_at_pc (gdbarch, pc, bp_longjmp_resume).release ();\n@@ -7867,10 +7629,8 @@ insert_exception_resume_breakpoint (struct thread_info *tp,\n \t{\n \t  handler = value_as_address (value);\n \n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: exception resume at %lx\\n\",\n-\t\t\t\t(unsigned long) handler);\n+\t  infrun_debug_printf (\"exception resume at %lx\",\n+\t\t\t       (unsigned long) handler);\n \n \t  bp = set_momentary_breakpoint_at_pc (get_frame_arch (frame),\n \t\t\t\t\t       handler,\n@@ -7907,11 +7667,8 @@ insert_exception_resume_from_probe (struct thread_info *tp,\n \n   handler = value_as_address (arg_value);\n \n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\"infrun: exception resume at %s\\n\",\n-\t\t\tpaddress (probe->objfile->arch (),\n-\t\t\t\t  handler));\n+  infrun_debug_printf (\"exception resume at %s\",\n+\t\t       paddress (probe->objfile->arch (), handler));\n \n   bp = set_momentary_breakpoint_at_pc (get_frame_arch (frame),\n \t\t\t\t       handler, bp_exception_resume).release ();\n@@ -7990,8 +7747,7 @@ check_exception_resume (struct execution_control_state *ecs,\n static void\n stop_waiting (struct execution_control_state *ecs)\n {\n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog, \"infrun: stop_waiting\\n\");\n+  infrun_debug_printf (\"stop_waiting\");\n \n   /* Let callers know we don't want to wait for the inferior anymore.  */\n   ecs->wait_some_more = 0;\n@@ -8019,11 +7775,9 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n     {\n       struct thread_info *tp = ecs->event_thread;\n \n-      if (debug_infrun)\n-\tfprintf_unfiltered (gdb_stdlog,\n-\t\t\t    \"infrun: %s has trap_expected set, \"\n-\t\t\t    \"resuming to collect trap\\n\",\n-\t\t\t    target_pid_to_str (tp->ptid).c_str ());\n+      infrun_debug_printf (\"%s has trap_expected set, \"\n+\t\t\t   \"resuming to collect trap\",\n+\t\t\t   target_pid_to_str (tp->ptid).c_str ());\n \n       /* We haven't yet gotten our trap, and either: intercepted a\n \t non-signal event (e.g., a fork); or took a signal which we\n@@ -8041,20 +7795,15 @@ keep_going_pass_signal (struct execution_control_state *ecs)\n       if (ecs->hit_singlestep_breakpoint\n \t  || thread_still_needs_step_over (tp))\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: step-over already in progress: \"\n-\t\t\t\t\"step-over for %s deferred\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"step-over already in progress: \"\n+\t\t\t       \"step-over for %s deferred\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \t  thread_step_over_chain_enqueue (tp);\n \t}\n       else\n \t{\n-\t  if (debug_infrun)\n-\t    fprintf_unfiltered (gdb_stdlog,\n-\t\t\t\t\"infrun: step-over in progress: \"\n-\t\t\t\t\"resume of %s deferred\\n\",\n-\t\t\t\ttarget_pid_to_str (tp->ptid).c_str ());\n+\t  infrun_debug_printf (\"step-over in progress: resume of %s deferred\",\n+\t\t\t       target_pid_to_str (tp->ptid).c_str ());\n \t}\n     }\n   else\n@@ -8154,8 +7903,7 @@ keep_going (struct execution_control_state *ecs)\n static void\n prepare_to_wait (struct execution_control_state *ecs)\n {\n-  if (debug_infrun)\n-    fprintf_unfiltered (gdb_stdlog, \"infrun: prepare_to_wait\\n\");\n+  infrun_debug_printf (\"prepare_to_wait\");\n \n   ecs->wait_some_more = 1;\n "
    },
    {
      "sha": "daf62a137cc89d1b6ecae932d4ad0b91d97699d6",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 11,
      "deletions": 0,
      "changes": 11,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
      "patch": "@@ -31,6 +31,17 @@ struct thread_info;\n /* True if we are debugging run control.  */\n extern unsigned int debug_infrun;\n \n+/* Print an \"infrun\" debug statement.  Should be used through\n+   infrun_debug_printf.  */\n+void ATTRIBUTE_PRINTF (2, 3) infrun_debug_printf_1\n+  (const char *func_name, const char *fmt, ...);\n+\n+#define infrun_debug_printf(fmt, ...) \\\n+  do { \\\n+    if (debug_infrun) \\\n+      infrun_debug_printf_1 (__func__, fmt, ##__VA_ARGS__); \\\n+  } while (0)\n+\n /* True if we are debugging displaced stepping.  */\n extern bool debug_displaced;\n "
    },
    {
      "sha": "61a37abb109fdd3d7b733cfe8f160b7363e69603",
      "filename": "gdb/testsuite/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/testsuite/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/testsuite/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/ChangeLog?ref=1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
      "patch": "@@ -1,3 +1,10 @@\n+2020-08-24  Simon Marchi  <simon.marchi@efficios.com>\n+\n+\t* gdb.base/gdb-sigterm.exp (do_test): Update expected regexp.\n+\t* gdb.threads/signal-while-stepping-over-bp-other-thread.exp:\n+\tLikewise.\n+\t* gdb.threads/stepi-random-signal.exp: Likewise.\n+\n 2020-08-20  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* gdb.base/print-file-var.exp: Fix typo \"breapoint\"."
    },
    {
      "sha": "d4c31dfd9801b94925a54effdd279c6367f83667",
      "filename": "gdb/testsuite/gdb.base/gdb-sigterm.exp",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/testsuite/gdb.base/gdb-sigterm.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/testsuite/gdb.base/gdb-sigterm.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/gdb-sigterm.exp?ref=1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
      "patch": "@@ -53,7 +53,7 @@ proc do_test { pass } {\n     set test \"run a bit #$pass\"\n     set abort 1\n     gdb_test_multiple \"step\" $test {\n-\t-re \"infrun: stepping inside range\" {\n+\t-re {\\[infrun\\] process_event_stop_test: stepping inside range} {\n \t    # Suppress pass $test\n \t    verbose -log \"$pf_prefix $test: ran\"\n \t    set abort 0\n@@ -78,7 +78,7 @@ proc do_test { pass } {\n \t    verbose -log \"$pf_prefix $test: got eof\"\n \t    set abort 0\n \t}\n-\t-re \"infrun: stepping inside range\" {\n+\t-re \"infrun: process_event_stop_test: stepping inside range\" {\n \t    incr stepping\n \t    exp_continue\n \t}"
    },
    {
      "sha": "6a95081b609888900723749c57858aa2a8ec9763",
      "filename": "gdb/testsuite/gdb.threads/signal-while-stepping-over-bp-other-thread.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/testsuite/gdb.threads/signal-while-stepping-over-bp-other-thread.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/testsuite/gdb.threads/signal-while-stepping-over-bp-other-thread.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/signal-while-stepping-over-bp-other-thread.exp?ref=1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
      "patch": "@@ -104,7 +104,7 @@ gdb_test \"set debug infrun 1\"\n set test \"step\"\n gdb_test_sequence $test $test {\n     \"need to step-over\"\n-    \"resume \\\\(step=1\"\n+    \"resume_1: step=1,\"\n     \"signal arrived while stepping over breakpoint\"\n     \"stepped to a different line\"\n     \"callme\""
    },
    {
      "sha": "fa20f38ba61efe57d3696465b65b9ec0d6db0d66",
      "filename": "gdb/testsuite/gdb.threads/stepi-random-signal.exp",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/testsuite/gdb.threads/stepi-random-signal.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1eb8556f5a8b5712e765b9615f7c18ffb50253b6/gdb/testsuite/gdb.threads/stepi-random-signal.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.threads/stepi-random-signal.exp?ref=1eb8556f5a8b5712e765b9615f7c18ffb50253b6",
      "patch": "@@ -87,7 +87,7 @@ set seen 0\n \n set test \"stepi\"\n if {[gdb_test_multiple \"stepi\" \"$test\" {\n-    -re \"infrun: random signal\" {\n+    -re \"infrun: handle_signal_stop: random signal\" {\n \tset seen 1\n \texp_continue\n     }"
    }
  ]
}