{
  "sha": "cf00cd6faf31c208bbfe107140c26895412214bb",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6Y2YwMGNkNmZhZjMxYzIwOGJiZmUxMDcxNDBjMjY4OTU0MTIyMTRiYg==",
  "commit": {
    "author": {
      "name": "Philippe Waroquiers",
      "email": "philippe.waroquiers@skynet.be",
      "date": "2019-06-19T10:49:55Z"
    },
    "committer": {
      "name": "Philippe Waroquiers",
      "email": "philippe.waroquiers@skynet.be",
      "date": "2020-06-22T19:14:13Z"
    },
    "message": "default-args: allow to define default arguments for aliases\n\nCurrently, a user can define an alias, but cannot have default\narguments for this alias.\n\nThis patch modifies the 'alias' command so that default args can\nbe provided.\n    (gdb) h alias\n    Define a new command that is an alias of an existing command.\n    Usage: alias [-a] [--] ALIAS = COMMAND [DEFAULT-ARGS...]\n    ALIAS is the name of the alias command to create.\n    COMMAND is the command being aliased to.\n\n    Options:\n      -a\n        Specify that ALIAS is an abbreviation of COMMAND.\n        Abbreviations are not used in command completion..\n\n    GDB will automatically prepend the provided DEFAULT-ARGS to the list\n    of arguments explicitly provided when using ALIAS.\n    Use \"help aliases\" to list all user defined aliases and their default args.\n\n    Examples:\n    Make \"spe\" an alias of \"set print elements\":\n      alias spe set print elements\n    Make \"elms\" an alias of \"elements\" in the \"set print\" command:\n      alias -a set print elms set print elements\n    Make \"btf\" an alias of \"backtrace -full -past-entry -past-main\" :\n      alias btf = backtrace -full -past-entry -past-main\n    Make \"wLapPeu\" an alias of 2 nested \"with\":\n      alias wLapPeu = with language pascal -- with print elements unlimited --\n    (gdb)\n\nThe way 'default-args' is implemented makes it trivial to set default\nargs also for GDB commands (such as \"backtrace\") and for GDB pre-defined\naliases (such as \"bt\").  It was however deemed better to not allow to\ndefine default arguments for pre-defined commands and aliases, to avoid\nusers believing that e.g. default args for \"backtrace\" would apply to \"bt\".\n\nIf needed, default-args could be allowed for GDB predefined commands\nand aliases by adding a command\n'set default-args GDB_COMMAND_OR_PREDEFINED_ALIAS [DEFAULT-ARGS...]'.\n\n* 'alias' command now has a completer that helps to complete:\n     - ALIAS (if the user defines an alias after a prefix),\n     - the aliased COMMAND\n     - the possible options for the aliased COMMAND.\n\n* Help and apropos commands show the definitions of the aliases\n  that have default arguments, e.g.\n        (gdb) help backtrace\n        backtrace, btf, where, bt\n          alias btf = backtrace -full -past-entry -past-main\n        Print backtrace of all stack frames, or innermost COUNT frames.\n        Usage: backtrace [OPTION]... [QUALIFIER]... [COUNT | -COUNT]\n\n        Options:\n          -entry-values no|only|preferred|if-needed|both|compact|default\n            Set printing of function arguments at function entry.\n        ...\n\ngdb/ChangeLog\n2020-06-22  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n\n\t* cli/cli-cmds.c (lookup_cmd_for_default_args)\n\t(alias_command_completer)\n\t(make_alias_options_def_group): New functions.\n\t(alias_opts, alias_option_defs): New struct and array.\n\t(alias_usage_error): Update usage.\n\t(alias_command): Handles optional DEFAULT-ARGS... arguments.\n\tUse option framework.\n\t(_initialize_cli_cmds): Update alias command help.\n\tUpdate aliases command help.\n\t(show_user):\n\tAdd NULL for new default_args lookup_cmd argument.\n\t(valid_command_p): Rename to validate_aliased_command.\n\tAdd NULL for new default_args lookup_cmd argument.  Verify that the\n\taliased_command has no default args.\n\t* cli/cli-decode.c (help_cmd): Show aliases definitions.\n\t(lookup_cmd_1, lookup_cmd): New argument default_args.\n\t(add_alias_cmd):\n\tAdd NULL for new default_args lookup_cmd argument.\n\t(print_help_for_command): Show default args under the layout\n\t alias some_alias = some_aliased_cmd some_alias_default_arg.\n\t* cli/cli-decode.h (struct cmd_list_element): New member default_args.\n\txfree default_args in destructor.\n\t* cli/cli-script.c (process_next_line, do_define_command):\n\tAdd NULL for new default_args lookup_cmd argument.\n\t* command.h: Declare new default_args argument in lookup_cmd\n\tand lookup_cmd_1.\n\t* completer.c (complete_line_internal_1):\n\tAdd NULL for new default_args lookup_cmd or lookup_cmd_1 argument.\n\t* guile/scm-cmd.c (gdbscm_parse_command_name): Likewise.\n\t* guile/scm-param.c (add_setshow_generic, pascm_parameter_defined_p):\n\tLikewise.\n\t* infcmd.c (_initialize_infcmd): Likewise.\n\t* python/py-auto-load.c (gdbpy_initialize_auto_load): Likewise.\n\t* python/py-cmd.c (gdbpy_parse_command_name): Likewise.\n\t* python/py-param.c (add_setshow_generic): Likewise.\n\t* remote.c (_initialize_remote): Likewise.\n\t* top.c (execute_command): Prepend default_args if command has some.\n\t(set_verbose):\n\tAdd NULL for new default_args lookup_cmd or lookup_cmd_1 argument.\n\t* tracepoint.c (validate_actionline, encode_actions_1):\n\tAdd NULL for new default_args lookup_cmd or lookup_cmd_1 argument.",
    "tree": {
      "sha": "f4fc3fb4986a0c6eb48cd3f6ee380429a5f8301c",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/f4fc3fb4986a0c6eb48cd3f6ee380429a5f8301c"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/cf00cd6faf31c208bbfe107140c26895412214bb",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cf00cd6faf31c208bbfe107140c26895412214bb",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/cf00cd6faf31c208bbfe107140c26895412214bb",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/cf00cd6faf31c208bbfe107140c26895412214bb/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "e822f2cda9bc484adb5f8860050640a5c6f1ced9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e822f2cda9bc484adb5f8860050640a5c6f1ced9",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e822f2cda9bc484adb5f8860050640a5c6f1ced9"
    }
  ],
  "stats": {
    "total": 476,
    "additions": 380,
    "deletions": 96
  },
  "files": [
    {
      "sha": "675a9e4ce82fe318e15f4f111934ddd8a0b4c7cf",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 44,
      "deletions": 0,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -1,3 +1,47 @@\n+2020-06-22  Philippe Waroquiers  <philippe.waroquiers@skynet.be>\n+\n+\t* cli/cli-cmds.c (lookup_cmd_for_default_args)\n+\t(alias_command_completer)\n+\t(make_alias_options_def_group): New functions.\n+\t(alias_opts, alias_option_defs): New struct and array.\n+\t(alias_usage_error): Update usage.\n+\t(alias_command): Handles optional DEFAULT-ARGS... arguments.\n+\tUse option framework.\n+\t(_initialize_cli_cmds): Update alias command help.\n+\tUpdate aliases command help.\n+\t(show_user):\n+\tAdd NULL for new default_args lookup_cmd argument.\n+\t(valid_command_p): Rename to validate_aliased_command.\n+\tAdd NULL for new default_args lookup_cmd argument.  Verify that the\n+\taliased_command has no default args.\n+\t* cli/cli-decode.c (help_cmd): Show aliases definitions.\n+\t(lookup_cmd_1, lookup_cmd): New argument default_args.\n+\t(add_alias_cmd):\n+\tAdd NULL for new default_args lookup_cmd argument.\n+\t(print_help_for_command): Show default args under the layout\n+\t alias some_alias = some_aliased_cmd some_alias_default_arg.\n+\t* cli/cli-decode.h (struct cmd_list_element): New member default_args.\n+\txfree default_args in destructor.\n+\t* cli/cli-script.c (process_next_line, do_define_command):\n+\tAdd NULL for new default_args lookup_cmd argument.\n+\t* command.h: Declare new default_args argument in lookup_cmd\n+\tand lookup_cmd_1.\n+\t* completer.c (complete_line_internal_1):\n+\tAdd NULL for new default_args lookup_cmd or lookup_cmd_1 argument.\n+\t* guile/scm-cmd.c (gdbscm_parse_command_name): Likewise.\n+\t* guile/scm-param.c (add_setshow_generic, pascm_parameter_defined_p):\n+\tLikewise.\n+\t* infcmd.c (_initialize_infcmd): Likewise.\n+\t* python/py-auto-load.c (gdbpy_initialize_auto_load): Likewise.\n+\t* python/py-cmd.c (gdbpy_parse_command_name): Likewise.\n+\t* python/py-param.c (add_setshow_generic): Likewise.\n+\t* remote.c (_initialize_remote): Likewise.\n+\t* top.c (execute_command): Prepend default_args if command has some.\n+\t(set_verbose):\n+\tAdd NULL for new default_args lookup_cmd or lookup_cmd_1 argument.\n+\t* tracepoint.c (validate_actionline, encode_actions_1):\n+\tAdd NULL for new default_args lookup_cmd or lookup_cmd_1 argument.\n+\n 2020-06-22  Tankut Baris Aktemur  <tankut.baris.aktemur@intel.com>\n \n \t* jit.c (jit_read_descriptor): Use bool as the return type."
    },
    {
      "sha": "2ff515ace7d1fe3601520d9946b197c3f543b674",
      "filename": "gdb/cli/cli-cmds.c",
      "status": "modified",
      "additions": 197,
      "deletions": 50,
      "changes": 247,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/cli/cli-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/cli/cli-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-cmds.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -50,6 +50,7 @@\n #include \"cli/cli-cmds.h\"\n #include \"cli/cli-style.h\"\n #include \"cli/cli-utils.h\"\n+#include \"cli/cli-style.h\"\n \n #include \"extension.h\"\n #include \"gdbsupport/pathstuff.h\"\n@@ -221,6 +222,7 @@ with_command_1 (const char *set_cmd_prefix,\n     nested_cmd = repeat_previous ();\n \n   cmd_list_element *set_cmd = lookup_cmd (&args, setlist, set_cmd_prefix,\n+\t\t\t\t\t  nullptr,\n \t\t\t\t\t  /*allow_unknown=*/ 0,\n \t\t\t\t\t  /*ignore_help_classes=*/ 1);\n   gdb_assert (set_cmd != nullptr);\n@@ -315,7 +317,54 @@ with_command_completer (struct cmd_list_element *ignore,\n   with_command_completer_1 (\"set \", tracker,  text);\n }\n \n-\f\n+/* Look up the contents of TEXT as a command usable with default args.\n+   Throws an error if no such command is found.\n+   Return the found command and advances TEXT past the found command.\n+   If the found command is a postfix command, set *PREFIX_CMD to its\n+   prefix command.  */\n+\n+static struct cmd_list_element *\n+lookup_cmd_for_default_args (const char **text,\n+\t\t\t     struct cmd_list_element **prefix_cmd)\n+{\n+  const char *orig_text = *text;\n+  struct cmd_list_element *lcmd;\n+\n+  if (*text == nullptr || skip_spaces (*text) == nullptr)\n+    error (_(\"ALIAS missing.\"));\n+\n+  /* We first use lookup_cmd to verify TEXT unambiguously identifies\n+     a command.  */\n+  lcmd = lookup_cmd (text, cmdlist, \"\", NULL,\n+\t\t     /*allow_unknown=*/ 0,\n+\t\t     /*ignore_help_classes=*/ 1);\n+\n+  /* Note that we accept default args for prefix commands,\n+     as a prefix command can also be a valid usable\n+     command accepting some arguments.\n+     For example, \"thread apply\" applies a command to a\n+     list of thread ids, and is also the prefix command for\n+     thread apply all.  */\n+\n+  /* We have an unambiguous command for which default args\n+     can be specified.  What remains after having found LCMD\n+     is either spaces, or the default args character.  */\n+\n+  /* We then use lookup_cmd_composition to detect if the user\n+     has specified an alias, and find the possible prefix_cmd\n+     of cmd.  */\n+  struct cmd_list_element *alias, *cmd;\n+  lookup_cmd_composition\n+    (std::string (orig_text, *text - orig_text).c_str (),\n+     &alias, prefix_cmd, &cmd);\n+  gdb_assert (cmd != nullptr);\n+  gdb_assert (cmd == lcmd);\n+  if (alias != nullptr)\n+    cmd = alias;\n+\n+  return cmd;\n+}\n+\n /* Provide documentation on command or list given by COMMAND.  FROM_TTY\n    is ignored.  */\n \n@@ -1541,7 +1590,7 @@ show_user (const char *args, int from_tty)\n     {\n       const char *comname = args;\n \n-      c = lookup_cmd (&comname, cmdlist, \"\", 0, 1);\n+      c = lookup_cmd (&comname, cmdlist, \"\", NULL, 0, 1);\n       if (!cli_user_command_p (c))\n \terror (_(\"Not a user command.\"));\n       show_user_1 (c, \"\", args, gdb_stdout);\n@@ -1573,6 +1622,71 @@ apropos_command (const char *arg, int from_tty)\n   apropos_cmd (gdb_stdout, cmdlist, verbose, pattern, \"\");\n }\n \n+/* The options for the \"alias\" command.  */\n+\n+struct alias_opts\n+{\n+  /* For \"-a\".  */\n+  bool abbrev_flag = false;\n+};\n+\n+static const gdb::option::option_def alias_option_defs[] = {\n+\n+  gdb::option::flag_option_def<alias_opts> {\n+    \"a\",\n+    [] (alias_opts *opts) { return &opts->abbrev_flag; },\n+    N_(\"Specify that ALIAS is an abbreviation of COMMAND.\\n\\\n+Abbreviations are not used in command completion.\"),\n+  },\n+\n+};\n+\n+/* Create an option_def_group for the \"alias\" options, with\n+   A_OPTS as context.  */\n+\n+static gdb::option::option_def_group\n+make_alias_options_def_group (alias_opts *a_opts)\n+{\n+  return {{alias_option_defs}, a_opts};\n+}\n+\n+/* Completer for the \"alias_command\".  */\n+\n+static void\n+alias_command_completer (struct cmd_list_element *ignore,\n+\t\t\t completion_tracker &tracker,\n+\t\t\t const char *text, const char *word)\n+{\n+  const auto grp = make_alias_options_def_group (nullptr);\n+\n+  tracker.set_use_custom_word_point (true);\n+\n+  if (gdb::option::complete_options\n+      (tracker, &text, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_ERROR, grp))\n+    return;\n+\n+  const char *delim = strchr (text, '=');\n+\n+  /* If we're past the \"=\" delimiter, complete the\n+     \"alias ALIAS = COMMAND [DEFAULT-ARGS...]\" as if the user is\n+     typing COMMAND DEFAULT-ARGS...  */\n+  if (delim != text\n+      && delim != nullptr\n+      && isspace (delim[-1])\n+      && (isspace (delim[1]) || delim[1] == '\\0'))\n+    {\n+      std::string new_text = std::string (delim + 1);\n+\n+      tracker.advance_custom_word_point_by (delim + 1 - text);\n+      complete_nested_command_line (tracker, new_text.c_str ());\n+      return;\n+    }\n+\n+  /* We're not yet past the \"=\" delimiter.  Complete a command, as\n+     the user might type an alias following a prefix command.  */\n+  complete_nested_command_line (tracker, text);\n+}\n+\n /* Subroutine of alias_command to simplify it.\n    Return the first N elements of ARGV flattened back to a string\n    with a space separating each element.\n@@ -1600,41 +1714,51 @@ argv_to_string (char **argv, int n)\n }\n \n /* Subroutine of alias_command to simplify it.\n-   Return true if COMMAND exists, unambiguously.  Otherwise false.  */\n+   Verifies that COMMAND can have an alias:\n+      COMMAND must exist.\n+      COMMAND must not have default args.\n+   This last condition is to avoid the following:\n+     alias aaa = backtrace -full\n+     alias bbb = aaa -past-main\n+   as (at least currently), alias default args are not cumulative\n+   and the user would expect bbb to execute 'backtrace -full -past-main'\n+   while it will execute 'backtrace -past-main'.  */\n \n-static bool\n-valid_command_p (const char *command)\n+static void\n+validate_aliased_command (const char *command)\n {\n   struct cmd_list_element *c;\n+  std::string default_args;\n \n-  c = lookup_cmd_1 (& command, cmdlist, NULL, 1);\n+  c = lookup_cmd_1 (& command, cmdlist, NULL, &default_args, 1);\n \n   if (c == NULL || c == (struct cmd_list_element *) -1)\n-    return false;\n-\n-  /* This is the slightly tricky part.\n-     lookup_cmd_1 will return a pointer to the last part of COMMAND\n-     to match, leaving COMMAND pointing at the remainder.  */\n-  while (*command == ' ' || *command == '\\t')\n-    ++command;\n-  return *command == '\\0';\n+    error (_(\"Invalid command to alias to: %s\"), command);\n+\n+  if (!default_args.empty ())\n+    error (_(\"Cannot define an alias of an alias that has default args\"));\n }\n \n /* Called when \"alias\" was incorrectly used.  */\n \n static void\n alias_usage_error (void)\n {\n-  error (_(\"Usage: alias [-a] [--] ALIAS = COMMAND\"));\n+  error (_(\"Usage: alias [-a] [--] ALIAS = COMMAND [DEFAULT-ARGS...]\"));\n }\n \n /* Make an alias of an existing command.  */\n \n static void\n alias_command (const char *args, int from_tty)\n {\n+  alias_opts a_opts;\n+\n+  auto grp = make_alias_options_def_group (&a_opts);\n+  gdb::option::process_options\n+    (&args, gdb::option::PROCESS_OPTIONS_UNKNOWN_IS_ERROR, grp);\n+\n   int i, alias_argc, command_argc;\n-  int abbrev_flag = 0;\n   const char *equals;\n   const char *alias, *command;\n \n@@ -1645,24 +1769,18 @@ alias_command (const char *args, int from_tty)\n   std::string args2 (args, equals - args);\n \n   gdb_argv built_alias_argv (args2.c_str ());\n-  gdb_argv command_argv (equals + 1);\n+\n+  const char *default_args = equals + 1;\n+  struct cmd_list_element *c_command_prefix;\n+\n+  lookup_cmd_for_default_args (&default_args, &c_command_prefix);\n+  std::string command_argv_str (equals + 1,\n+\t\t\t\tdefault_args == nullptr\n+\t\t\t\t? strlen (equals + 1)\n+\t\t\t\t: default_args - equals - 1);\n+  gdb_argv command_argv (command_argv_str.c_str ());\n \n   char **alias_argv = built_alias_argv.get ();\n-  while (alias_argv[0] != NULL)\n-    {\n-      if (strcmp (alias_argv[0], \"-a\") == 0)\n-\t{\n-\t  ++alias_argv;\n-\t  abbrev_flag = 1;\n-\t}\n-      else if (strcmp (alias_argv[0], \"--\") == 0)\n-\t{\n-\t  ++alias_argv;\n-\t  break;\n-\t}\n-      else\n-\tbreak;\n-    }\n \n   if (alias_argv[0] == NULL || command_argv[0] == NULL\n       || *alias_argv[0] == '\\0' || *command_argv[0] == '\\0')\n@@ -1682,14 +1800,13 @@ alias_command (const char *args, int from_tty)\n   alias_argc = countargv (alias_argv);\n   command_argc = command_argv.count ();\n \n-  /* COMMAND must exist.\n+  /* COMMAND must exist, and cannot have default args.\n      Reconstruct the command to remove any extraneous spaces,\n      for better error messages.  */\n   std::string command_string (argv_to_string (command_argv.get (),\n \t\t\t\t\t      command_argc));\n   command = command_string.c_str ();\n-  if (! valid_command_p (command))\n-    error (_(\"Invalid command to alias to: %s\"), command);\n+  validate_aliased_command (command);\n \n   /* ALIAS must not exist.  */\n   std::string alias_string (argv_to_string (alias_argv, alias_argc));\n@@ -1718,6 +1835,8 @@ alias_command (const char *args, int from_tty)\n   }\n \n \n+  struct cmd_list_element *alias_cmd;\n+\n   /* If ALIAS is one word, it is an alias for the entire COMMAND.\n      Example: alias spe = set print elements\n \n@@ -1730,8 +1849,8 @@ alias_command (const char *args, int from_tty)\n   if (alias_argc == 1)\n     {\n       /* add_cmd requires *we* allocate space for name, hence the xstrdup.  */\n-      add_com_alias (xstrdup (alias_argv[0]), command, class_alias,\n-\t\t     abbrev_flag);\n+      alias_cmd = add_com_alias (xstrdup (alias_argv[0]), command, class_alias,\n+\t\t\t\t a_opts.abbrev_flag);\n     }\n   else\n     {\n@@ -1751,19 +1870,29 @@ alias_command (const char *args, int from_tty)\n       alias_prefix = alias_prefix_string.c_str ();\n       command_prefix = command_prefix_string.c_str ();\n \n-      c_command = lookup_cmd_1 (& command_prefix, cmdlist, NULL, 1);\n+      c_command = lookup_cmd_1 (& command_prefix, cmdlist, NULL, NULL, 1);\n       /* We've already tried to look up COMMAND.  */\n       gdb_assert (c_command != NULL\n \t\t  && c_command != (struct cmd_list_element *) -1);\n       gdb_assert (c_command->prefixlist != NULL);\n-      c_alias = lookup_cmd_1 (& alias_prefix, cmdlist, NULL, 1);\n+      c_alias = lookup_cmd_1 (& alias_prefix, cmdlist, NULL, NULL, 1);\n       if (c_alias != c_command)\n \terror (_(\"ALIAS and COMMAND prefixes do not match.\"));\n \n       /* add_cmd requires *we* allocate space for name, hence the xstrdup.  */\n-      add_alias_cmd (xstrdup (alias_argv[alias_argc - 1]),\n-\t\t     command_argv[command_argc - 1],\n-\t\t     class_alias, abbrev_flag, c_command->prefixlist);\n+      alias_cmd = add_alias_cmd (xstrdup (alias_argv[alias_argc - 1]),\n+\t\t\t\t command_argv[command_argc - 1],\n+\t\t\t\t class_alias, a_opts.abbrev_flag,\n+\t\t\t\t c_command->prefixlist);\n+    }\n+\n+  gdb_assert (alias_cmd != nullptr);\n+  gdb_assert (alias_cmd->default_args.empty ());\n+  if (default_args != nullptr)\n+    {\n+      default_args = skip_spaces (default_args);\n+\n+      alias_cmd->default_args = default_args;\n     }\n }\n \f\n@@ -1938,7 +2067,7 @@ setting_cmd (const char *fnname, struct cmd_list_element *showlist,\n     error (_(\"First argument of %s must be a string.\"), fnname);\n \n   const char *a0 = (const char *) value_contents (argv[0]);\n-  cmd_list_element *cmd = lookup_cmd (&a0, showlist, \"\", -1, 0);\n+  cmd_list_element *cmd = lookup_cmd (&a0, showlist, \"\", NULL, -1, 0);\n \n   if (cmd == nullptr || cmd_type (cmd) != show_cmd)\n     error (_(\"First argument of %s must be a \"\n@@ -2128,7 +2257,7 @@ well documented as user commands.\"),\n \t   &cmdlist);\n   add_cmd (\"obscure\", class_obscure, _(\"Obscure features.\"), &cmdlist);\n   add_cmd (\"aliases\", class_alias,\n-\t   _(\"Aliases of other commands.\"), &cmdlist);\n+\t   _(\"User-defined aliases of other commands.\"), &cmdlist);\n   add_cmd (\"user-defined\", class_user, _(\"\\\n User-defined commands.\\n\\\n The commands in this class are those defined by the user.\\n\\\n@@ -2454,19 +2583,37 @@ When 'on', each command is displayed as it is executed.\"),\n \t\t\t   NULL,\n \t\t\t   &setlist, &showlist);\n \n-  c = add_com (\"alias\", class_support, alias_command, _(\"\\\n+  const auto alias_opts = make_alias_options_def_group (nullptr);\n+\n+  static std::string alias_help\n+    = gdb::option::build_help (_(\"\\\n Define a new command that is an alias of an existing command.\\n\\\n-Usage: alias [-a] [--] ALIAS = COMMAND\\n\\\n+Usage: alias [-a] [--] ALIAS = COMMAND [DEFAULT-ARGS...]\\n\\\n ALIAS is the name of the alias command to create.\\n\\\n COMMAND is the command being aliased to.\\n\\\n-If \\\"-a\\\" is specified, the command is an abbreviation,\\n\\\n-and will not be used in command completion.\\n\\\n+\\n\\\n+Options:\\n\\\n+%OPTIONS%\\n\\\n+\\n\\\n+GDB will automatically prepend the provided DEFAULT-ARGS to the list\\n\\\n+of arguments explicitly provided when using ALIAS.\\n\\\n+Use \\\"help aliases\\\" to list all user defined aliases and their default args.\\n\\\n \\n\\\n Examples:\\n\\\n Make \\\"spe\\\" an alias of \\\"set print elements\\\":\\n\\\n-  alias spe = set print elements\\n\\\n+  alias spe set print elements\\n\\\n Make \\\"elms\\\" an alias of \\\"elements\\\" in the \\\"set print\\\" command:\\n\\\n-  alias -a set print elms = set print elements\"));\n+  alias -a set print elms set print elements\\n\\\n+Make \\\"btf\\\" an alias of \\\"backtrace -full -past-entry -past-main\\\" :\\n\\\n+  alias btf = backtrace -full -past-entry -past-main\\n\\\n+Make \\\"wLapPeu\\\" an alias of 2 nested \\\"with\\\":\\n\\\n+  alias wLapPeu = with language pascal -- with print elements unlimited --\"),\n+\t\t\t       alias_opts);\n+\n+  c = add_com (\"alias\", class_support, alias_command,\n+\t       alias_help.c_str ());\n+\n+  set_cmd_completer_handle_brkchars (c, alias_command_completer);\n \n   const char *source_help_text = xstrprintf (_(\"\\\n Read commands from a file named FILE.\\n\\"
    },
    {
      "sha": "85f50aa8e48214907fa921668967bf25776909f4",
      "filename": "gdb/cli/cli-decode.c",
      "status": "modified",
      "additions": 92,
      "deletions": 18,
      "changes": 110,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/cli/cli-decode.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/cli/cli-decode.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -337,7 +337,7 @@ add_alias_cmd (const char *name, const char *oldname,\n   struct cmd_list_element *old;\n \n   tmp = oldname;\n-  old = lookup_cmd (&tmp, *list, \"\", 1, 1);\n+  old = lookup_cmd (&tmp, *list, \"\", NULL, 1, 1);\n \n   return add_alias_cmd (name, old, theclass, abbrev_flag, list);\n }\n@@ -1040,6 +1040,40 @@ fput_command_name_styled (struct cmd_list_element *c, struct ui_file *stream)\n   fprintf_styled (stream, title_style.style (), \"%s%s\", prefixname, c->name);\n }\n \n+/* Print the definition of alias C using title style for alias\n+   and aliased command.  */\n+\n+static void\n+fput_alias_definition_styled (struct cmd_list_element *c,\n+\t\t\t      struct ui_file *stream)\n+{\n+  gdb_assert (c->cmd_pointer != nullptr);\n+  fputs_filtered (\"  alias \", stream);\n+  fput_command_name_styled (c, stream);\n+  fprintf_filtered (stream, \" = \");\n+  fput_command_name_styled (c->cmd_pointer, stream);\n+  fprintf_filtered (stream, \" %s\\n\", c->default_args.c_str ());\n+}\n+\n+/* Print the definition of the aliases of CMD that have default args.  */\n+\n+static void\n+fput_aliases_definition_styled (struct cmd_list_element *cmd,\n+\t\t\t\tstruct ui_file *stream)\n+{\n+  if (cmd->aliases != nullptr)\n+    {\n+      for (cmd_list_element *iter = cmd->aliases;\n+\t   iter;\n+\t   iter = iter->alias_chain)\n+\t{\n+\t  if (!iter->default_args.empty ())\n+\t    fput_alias_definition_styled (iter, stream);\n+\t}\n+    }\n+}\n+\n+\n /* If C has one or more aliases, style print the name of C and\n    the name of its aliases, separated by commas.\n    If ALWAYS_FPUT_C_NAME, print the name of C even if it has no aliases.\n@@ -1081,12 +1115,21 @@ print_doc_of_command (struct cmd_list_element *c, const char *prefix,\n   if (verbose)\n     fputs_filtered (\"\\n\", stream);\n \n-  fput_command_names_styled (c, true, \" -- \", stream);\n+  fput_command_names_styled (c, true,\n+\t\t\t     verbose ? \"\" : \" -- \", stream);\n   if (verbose)\n-    fputs_highlighted (c->doc, highlight, stream);\n+    {\n+      fputs_filtered (\"\\n\", stream);\n+      fput_aliases_definition_styled (c, stream);\n+      fputs_highlighted (c->doc, highlight, stream);\n+      fputs_filtered (\"\\n\", stream);\n+    }\n   else\n-    print_doc_line (stream, c->doc, false);\n-  fputs_filtered (\"\\n\", stream);\n+    {\n+      print_doc_line (stream, c->doc, false);\n+      fputs_filtered (\"\\n\", stream);\n+      fput_aliases_definition_styled (c, stream);\n+    }\n }\n \n /* Recursively walk the commandlist structures, and print out the\n@@ -1183,7 +1226,7 @@ help_cmd (const char *command, struct ui_file *stream)\n     }\n \n   const char *orig_command = command;\n-  c = lookup_cmd (&command, cmdlist, \"\", 0, 0);\n+  c = lookup_cmd (&command, cmdlist, \"\", NULL, 0, 0);\n \n   if (c == 0)\n     return;\n@@ -1205,6 +1248,7 @@ help_cmd (const char *command, struct ui_file *stream)\n   /* If the user asked 'help somecommand' and there is no alias,\n      the false indicates to not output the (single) command name.  */\n   fput_command_names_styled (c, false, \"\\n\", stream);\n+  fput_aliases_definition_styled (c, stream);\n   fputs_filtered (c->doc, stream);\n   fputs_filtered (\"\\n\", stream);\n \n@@ -1341,7 +1385,7 @@ help_all (struct ui_file *stream)\n \t      fprintf_filtered (stream, \"\\nUnclassified commands\\n\\n\");\n \t      seen_unclassified = 1;\n \t    }\n-\t  print_help_for_command (c, 1, stream);\n+\t  print_help_for_command (c, true, stream);\n \t}\n     }\n \n@@ -1399,6 +1443,9 @@ print_help_for_command (struct cmd_list_element *c,\n   fput_command_names_styled (c, true, \" -- \", stream);\n   print_doc_line (stream, c->doc, false);\n   fputs_filtered (\"\\n\", stream);\n+  if (!c->default_args.empty ())\n+    fput_alias_definition_styled (c, stream);\n+  fput_aliases_definition_styled (c, stream);\n \n   if (recurse\n       && c->prefixlist != 0\n@@ -1582,8 +1629,12 @@ valid_user_defined_cmd_name_p (const char *name)\n    the list in which there are ambiguous choices (and *TEXT will be set to\n    the ambiguous text string).\n \n+   if DEFAULT_ARGS is not null, *DEFAULT_ARGS is set to the found command\n+   default args (possibly empty).\n+\n    If the located command was an abbreviation, this routine returns the base\n-   command of the abbreviation.\n+   command of the abbreviation.  Note that *DEFAULT_ARGS will contain the\n+   default args defined for the alias.\n \n    It does no error reporting whatsoever; control will always return\n    to the superior routine.\n@@ -1610,11 +1661,13 @@ valid_user_defined_cmd_name_p (const char *name)\n \n struct cmd_list_element *\n lookup_cmd_1 (const char **text, struct cmd_list_element *clist,\n-\t      struct cmd_list_element **result_list, int ignore_help_classes)\n+\t      struct cmd_list_element **result_list, std::string *default_args,\n+\t      int ignore_help_classes)\n {\n   char *command;\n   int len, nfound;\n   struct cmd_list_element *found, *c;\n+  bool found_alias = false;\n   const char *line = *text;\n \n   while (**text == ' ' || **text == '\\t')\n@@ -1646,10 +1699,12 @@ lookup_cmd_1 (const char **text, struct cmd_list_element *clist,\n \n   if (nfound > 1)\n     {\n-      if (result_list != NULL)\n+      if (result_list != nullptr)\n \t/* Will be modified in calling routine\n \t   if we know what the prefix command is.  */\n \t*result_list = 0;\n+      if (default_args != nullptr)\n+\t*default_args = std::string ();\n       return CMD_LIST_AMBIGUOUS;\t/* Ambiguous.  */\n     }\n \n@@ -1665,36 +1720,47 @@ lookup_cmd_1 (const char **text, struct cmd_list_element *clist,\n        are warning about the alias, we may also warn about the command\n        itself and we will adjust the appropriate DEPRECATED_WARN_USER\n        flags.  */\n-      \n+\n       if (found->deprecated_warn_user)\n \tdeprecated_cmd_warning (line);\n+\n+      /* Return the default_args of the alias, not the default_args\n+\t of the command it is pointing to.  */\n+      if (default_args != nullptr)\n+\t*default_args = found->default_args;\n       found = found->cmd_pointer;\n+      found_alias = true;\n     }\n   /* If we found a prefix command, keep looking.  */\n \n   if (found->prefixlist)\n     {\n       c = lookup_cmd_1 (text, *found->prefixlist, result_list,\n-\t\t\tignore_help_classes);\n+\t\t\tdefault_args, ignore_help_classes);\n       if (!c)\n \t{\n \t  /* Didn't find anything; this is as far as we got.  */\n-\t  if (result_list != NULL)\n+\t  if (result_list != nullptr)\n \t    *result_list = clist;\n+\t  if (!found_alias && default_args != nullptr)\n+\t    *default_args = found->default_args;\n \t  return found;\n \t}\n       else if (c == CMD_LIST_AMBIGUOUS)\n \t{\n \t  /* We've gotten this far properly, but the next step is\n \t     ambiguous.  We need to set the result list to the best\n \t     we've found (if an inferior hasn't already set it).  */\n-\t  if (result_list != NULL)\n+\t  if (result_list != nullptr)\n \t    if (!*result_list)\n \t      /* This used to say *result_list = *found->prefixlist.\n \t         If that was correct, need to modify the documentation\n \t         at the top of this function to clarify what is\n \t         supposed to be going on.  */\n \t      *result_list = found;\n+\t  /* For ambiguous commands, do not return any default_args args.  */\n+\t  if (default_args != nullptr)\n+\t    *default_args = std::string ();\n \t  return c;\n \t}\n       else\n@@ -1705,8 +1771,10 @@ lookup_cmd_1 (const char **text, struct cmd_list_element *clist,\n     }\n   else\n     {\n-      if (result_list != NULL)\n+      if (result_list != nullptr)\n \t*result_list = clist;\n+      if (!found_alias && default_args != nullptr)\n+\t*default_args = found->default_args;\n       return found;\n     }\n }\n@@ -1726,8 +1794,13 @@ undef_cmd_error (const char *cmdtype, const char *q)\n \n /* Look up the contents of *LINE as a command in the command list LIST.\n    LIST is a chain of struct cmd_list_element's.\n-   If it is found, return the struct cmd_list_element for that command\n-   and update *LINE to point after the command name, at the first argument.\n+   If it is found, return the struct cmd_list_element for that command,\n+   update *LINE to point after the command name, at the first argument\n+   and update *DEFAULT_ARGS (if DEFAULT_ARGS is not null) to the default\n+   args to prepend to the user provided args when running the command.\n+   Note that if the found cmd_list_element is found via an alias,\n+   the default args of the alias are returned.\n+\n    If not found, call error if ALLOW_UNKNOWN is zero\n    otherwise (or if error returns) return zero.\n    Call error if specified command is ambiguous,\n@@ -1741,6 +1814,7 @@ undef_cmd_error (const char *cmdtype, const char *q)\n struct cmd_list_element *\n lookup_cmd (const char **line, struct cmd_list_element *list,\n \t    const char *cmdtype,\n+\t    std::string *default_args,\n \t    int allow_unknown, int ignore_help_classes)\n {\n   struct cmd_list_element *last_list = 0;\n@@ -1752,7 +1826,7 @@ lookup_cmd (const char **line, struct cmd_list_element *list,\n   if (!*line)\n     error (_(\"Lack of needed %scommand\"), cmdtype);\n \n-  c = lookup_cmd_1 (line, list, &last_list, ignore_help_classes);\n+  c = lookup_cmd_1 (line, list, &last_list, default_args, ignore_help_classes);\n \n   if (!c)\n     {"
    },
    {
      "sha": "f855ee5724fda1a3c0d9dde527fe9ca1876f2e49",
      "filename": "gdb/cli/cli-decode.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/cli/cli-decode.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/cli/cli-decode.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-decode.h?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -183,6 +183,10 @@ struct cmd_list_element\n     /* Hook for another command to be executed after this command.  */\n     struct cmd_list_element *hook_post = nullptr;\n \n+    /* Default arguments to automatically prepend to the user\n+       provided arguments when running this command or alias.  */\n+    std::string default_args;\n+\n     /* Nonzero identifies a prefix command.  For them, the address\n        of the variable containing the list of subcommands.  */\n     struct cmd_list_element **prefixlist = nullptr;"
    },
    {
      "sha": "da4a41023ad28554218e0649ca5ca611541200fa",
      "filename": "gdb/cli/cli-script.c",
      "status": "modified",
      "additions": 6,
      "deletions": 6,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/cli/cli-script.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/cli/cli-script.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cli/cli-script.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -974,7 +974,7 @@ process_next_line (const char *p, struct command_line **command,\n       /* Resolve command abbreviations (e.g. 'ws' for 'while-stepping').  */\n       const char *cmd_name = p;\n       struct cmd_list_element *cmd\n-\t= lookup_cmd_1 (&cmd_name, cmdlist, NULL, 1);\n+\t= lookup_cmd_1 (&cmd_name, cmdlist, NULL, NULL, 1);\n       cmd_name = skip_spaces (cmd_name);\n       bool inline_cmd = *cmd_name != '\\0';\n \n@@ -1331,7 +1331,7 @@ validate_comname (const char **comname)\n       std::string prefix (*comname, last_word - 1);\n       const char *tem = prefix.c_str ();\n \n-      c = lookup_cmd (&tem, cmdlist, \"\", 0, 1);\n+      c = lookup_cmd (&tem, cmdlist, \"\", NULL, 0, 1);\n       if (c->prefixlist == NULL)\n \terror (_(\"\\\"%s\\\" is not a prefix command.\"), prefix.c_str ());\n \n@@ -1387,7 +1387,7 @@ do_define_command (const char *comname, int from_tty,\n \n   /* Look it up, and verify that we got an exact match.  */\n   tem = comname;\n-  c = lookup_cmd (&tem, *list, \"\", -1, 1);\n+  c = lookup_cmd (&tem, *list, \"\", NULL, -1, 1);\n   if (c && strcmp (comname, c->name) != 0)\n     c = 0;\n \n@@ -1432,7 +1432,7 @@ do_define_command (const char *comname, int from_tty,\n     {\n       /* Look up cmd it hooks, and verify that we got an exact match.  */\n       tem = comname + hook_name_size;\n-      hookc = lookup_cmd (&tem, *list, \"\", -1, 0);\n+      hookc = lookup_cmd (&tem, *list, \"\", NULL, -1, 0);\n       if (hookc && strcmp (comname + hook_name_size, hookc->name) != 0)\n \thookc = 0;\n       if (!hookc && commands == nullptr)\n@@ -1518,7 +1518,7 @@ document_command (const char *comname, int from_tty)\n   list = validate_comname (&comname);\n \n   tem = comname;\n-  c = lookup_cmd (&tem, *list, \"\", 0, 1);\n+  c = lookup_cmd (&tem, *list, \"\", NULL, 0, 1);\n \n   if (c->theclass != class_user)\n     error (_(\"Command \\\"%s\\\" is built-in.\"), comfull);\n@@ -1566,7 +1566,7 @@ define_prefix_command (const char *comname, int from_tty)\n \n   /* Look it up, and verify that we got an exact match.  */\n   tem = comname;\n-  c = lookup_cmd (&tem, *list, \"\", -1, 1);\n+  c = lookup_cmd (&tem, *list, \"\", NULL, -1, 1);\n   if (c != nullptr && strcmp (comname, c->name) != 0)\n     c = nullptr;\n "
    },
    {
      "sha": "2cac5c8ced0c87f732ef66ad290b89985d39795b",
      "filename": "gdb/command.h",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/command.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/command.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/command.h?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -291,11 +291,13 @@ extern enum cmd_types cmd_type (struct cmd_list_element *cmd);\n extern struct cmd_list_element *lookup_cmd (const char **,\n \t\t\t\t\t    struct cmd_list_element *,\n \t\t\t\t\t    const char *,\n+\t\t\t\t\t    std::string *,\n \t\t\t\t\t    int, int);\n \n extern struct cmd_list_element *lookup_cmd_1 (const char **,\n \t\t\t\t\t      struct cmd_list_element *,\n \t\t\t\t\t      struct cmd_list_element **,\n+\t\t\t\t\t      std::string *,\n \t\t\t\t\t      int);\n \n extern struct cmd_list_element *deprecate_cmd (struct cmd_list_element *,"
    },
    {
      "sha": "7d26774e851f95a573018f7b4d418ad894a48d89",
      "filename": "gdb/completer.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/completer.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/completer.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/completer.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -1385,7 +1385,7 @@ complete_line_internal_1 (completion_tracker &tracker,\n     }\n   else\n     {\n-      c = lookup_cmd_1 (&p, cmdlist, &result_list, ignore_help_classes);\n+      c = lookup_cmd_1 (&p, cmdlist, &result_list, NULL, ignore_help_classes);\n     }\n \n   /* Move p up to the next interesting thing.  */"
    },
    {
      "sha": "8fd2772df482d04d51341ca993d5cad8b2f82429",
      "filename": "gdb/guile/scm-cmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/guile/scm-cmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/guile/scm-cmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-cmd.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -512,7 +512,7 @@ gdbscm_parse_command_name (const char *name,\n   prefix_text[i + 1] = '\\0';\n \n   prefix_text2 = prefix_text;\n-  elt = lookup_cmd_1 (&prefix_text2, *start_list, NULL, 1);\n+  elt = lookup_cmd_1 (&prefix_text2, *start_list, NULL, NULL, 1);\n   if (elt == NULL || elt == CMD_LIST_AMBIGUOUS)\n     {\n       msg = xstrprintf (_(\"could not find command prefix '%s'\"), prefix_text);"
    },
    {
      "sha": "62e21087403c1ca4f4ebe6f8edf2756fb0d4c5ab",
      "filename": "gdb/guile/scm-param.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/guile/scm-param.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/guile/scm-param.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-param.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -466,13 +466,13 @@ add_setshow_generic (enum var_types param_type, enum command_class cmd_class,\n   /* Lookup created parameter, and register Scheme object against the\n      parameter context.  Perform this task against both lists.  */\n   tmp_name = cmd_name;\n-  param = lookup_cmd (&tmp_name, *show_list, \"\", 0, 1);\n+  param = lookup_cmd (&tmp_name, *show_list, \"\", NULL, 0, 1);\n   gdb_assert (param != NULL);\n   set_cmd_context (param, self);\n   *set_cmd = param;\n \n   tmp_name = cmd_name;\n-  param = lookup_cmd (&tmp_name, *set_list, \"\", 0, 1);\n+  param = lookup_cmd (&tmp_name, *set_list, \"\", NULL, 0, 1);\n   gdb_assert (param != NULL);\n   set_cmd_context (param, self);\n   *show_cmd = param;\n@@ -969,7 +969,7 @@ pascm_parameter_defined_p (const char *name, struct cmd_list_element *list)\n {\n   struct cmd_list_element *c;\n \n-  c = lookup_cmd_1 (&name, list, NULL, 1);\n+  c = lookup_cmd_1 (&name, list, NULL, NULL, 1);\n \n   /* If the name is ambiguous that's ok, it's a new parameter still.  */\n   return c != NULL && c != CMD_LIST_AMBIGUOUS;"
    },
    {
      "sha": "42b050d3c4e94836a9014b36fa84e3c5808ff5ef",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -3052,7 +3052,7 @@ is restored.\"),\n \t\t\t\t     show_inferior_tty_command,\n \t\t\t\t     &setlist, &showlist);\n   cmd_name = \"inferior-tty\";\n-  c = lookup_cmd (&cmd_name, setlist, \"\", -1, 1);\n+  c = lookup_cmd (&cmd_name, setlist, \"\", NULL, -1, 1);\n   gdb_assert (c != NULL);\n   add_alias_cmd (\"tty\", c, class_run, 0, &cmdlist);\n \n@@ -3065,7 +3065,7 @@ Follow this command with any number of args, to be passed to the program.\"),\n \t\t\t\t   set_args_command,\n \t\t\t\t   show_args_command,\n \t\t\t\t   &setlist, &showlist);\n-  c = lookup_cmd (&cmd_name, setlist, \"\", -1, 1);\n+  c = lookup_cmd (&cmd_name, setlist, \"\", NULL, -1, 1);\n   gdb_assert (c != NULL);\n   set_cmd_completer (c, filename_completer);\n \n@@ -3084,7 +3084,7 @@ working directory.\"),\n \t\t\t\t   set_cwd_command,\n \t\t\t\t   show_cwd_command,\n \t\t\t\t   &setlist, &showlist);\n-  c = lookup_cmd (&cmd_name, setlist, \"\", -1, 1);\n+  c = lookup_cmd (&cmd_name, setlist, \"\", NULL, -1, 1);\n   gdb_assert (c != NULL);\n   set_cmd_completer (c, filename_completer);\n "
    },
    {
      "sha": "56db946463a0e278a10ebaffe67cb9235376fb68",
      "filename": "gdb/python/py-auto-load.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/python/py-auto-load.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/python/py-auto-load.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-auto-load.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -84,12 +84,12 @@ Show the debugger's behaviour regarding auto-loaded Python scripts, \"\n \t\t\t   NULL, NULL, show_auto_load_python_scripts,\n \t\t\t   &setlist, &showlist);\n   cmd_name = \"auto-load-scripts\";\n-  cmd = lookup_cmd (&cmd_name, setlist, \"\", -1, 1);\n+  cmd = lookup_cmd (&cmd_name, setlist, \"\", NULL, -1, 1);\n   deprecate_cmd (cmd, \"set auto-load python-scripts\");\n \n   /* It is needed because lookup_cmd updates the CMD_NAME pointer.  */\n   cmd_name = \"auto-load-scripts\";\n-  cmd = lookup_cmd (&cmd_name, showlist, \"\", -1, 1);\n+  cmd = lookup_cmd (&cmd_name, showlist, \"\", NULL, -1, 1);\n   deprecate_cmd (cmd, \"show auto-load python-scripts\");\n \n   add_cmd (\"python-scripts\", class_info, info_auto_load_python_scripts,"
    },
    {
      "sha": "760208f52b9bacb9b40d73e785d29d740ccf5545",
      "filename": "gdb/python/py-cmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/python/py-cmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/python/py-cmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-cmd.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -390,7 +390,7 @@ gdbpy_parse_command_name (const char *name,\n   std::string prefix_text (name, i + 1);\n \n   prefix_text2 = prefix_text.c_str ();\n-  elt = lookup_cmd_1 (&prefix_text2, *start_list, NULL, 1);\n+  elt = lookup_cmd_1 (&prefix_text2, *start_list, NULL, NULL, 1);\n   if (elt == NULL || elt == CMD_LIST_AMBIGUOUS)\n     {\n       PyErr_Format (PyExc_RuntimeError, _(\"Could not find command prefix %s.\"),"
    },
    {
      "sha": "fb39187b18443bb5e1a5669e5008198553108fe2",
      "filename": "gdb/python/py-param.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/python/py-param.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/python/py-param.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-param.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -569,12 +569,12 @@ add_setshow_generic (int parmclass, enum command_class cmdclass,\n   /* Lookup created parameter, and register Python object against the\n      parameter context.  Perform this task against both lists.  */\n   tmp_name = cmd_name;\n-  param = lookup_cmd (&tmp_name, *show_list, \"\", 0, 1);\n+  param = lookup_cmd (&tmp_name, *show_list, \"\", NULL, 0, 1);\n   if (param)\n     set_cmd_context (param, self);\n \n   tmp_name = cmd_name;\n-  param = lookup_cmd (&tmp_name, *set_list, \"\", 0, 1);\n+  param = lookup_cmd (&tmp_name, *set_list, \"\", NULL, 0, 1);\n   if (param)\n     set_cmd_context (param, self);\n }"
    },
    {
      "sha": "d560c69eca41412904004c4911ae8816e21d973a",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -14424,10 +14424,10 @@ If set, a break, instead of a cntrl-c, is sent to the remote target.\"),\n \t\t\t   set_remotebreak, show_remotebreak,\n \t\t\t   &setlist, &showlist);\n   cmd_name = \"remotebreak\";\n-  cmd = lookup_cmd (&cmd_name, setlist, \"\", -1, 1);\n+  cmd = lookup_cmd (&cmd_name, setlist, \"\", NULL, -1, 1);\n   deprecate_cmd (cmd, \"set remote interrupt-sequence\");\n   cmd_name = \"remotebreak\"; /* needed because lookup_cmd updates the pointer */\n-  cmd = lookup_cmd (&cmd_name, showlist, \"\", -1, 1);\n+  cmd = lookup_cmd (&cmd_name, showlist, \"\", NULL, -1, 1);\n   deprecate_cmd (cmd, \"show remote interrupt-sequence\");\n \n   add_setshow_enum_cmd (\"interrupt-sequence\", class_support,"
    },
    {
      "sha": "da9b805b47907198069428af69585eb8c2461cc2",
      "filename": "gdb/top.c",
      "status": "modified",
      "additions": 17,
      "deletions": 4,
      "changes": 21,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/top.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/top.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/top.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -579,22 +579,35 @@ execute_command (const char *p, int from_tty)\n     {\n       const char *cmd = p;\n       const char *arg;\n+      std::string default_args;\n+      std::string default_args_and_arg;\n       int was_sync = current_ui->prompt_state == PROMPT_BLOCKED;\n \n       line = p;\n \n       /* If trace-commands is set then this will print this command.  */\n       print_command_trace (\"%s\", p);\n \n-      c = lookup_cmd (&cmd, cmdlist, \"\", 0, 1);\n+      c = lookup_cmd (&cmd, cmdlist, \"\", &default_args, 0, 1);\n       p = cmd;\n \n       scoped_restore save_repeat_args\n \t= make_scoped_restore (&repeat_arguments, nullptr);\n       const char *args_pointer = p;\n \n-      /* Pass null arg rather than an empty one.  */\n-      arg = *p ? p : 0;\n+      if (!default_args.empty ())\n+\t{\n+\t  if (*p != '\\0')\n+\t    default_args_and_arg = default_args + ' ' + p;\n+\t  else\n+\t    default_args_and_arg = default_args;\n+\t  arg = default_args_and_arg.c_str ();\n+\t}\n+      else\n+\t{\n+\t  /* Pass null arg rather than an empty one.  */\n+\t  arg = *p == '\\0' ? nullptr : p;\n+\t}\n \n       /* FIXME: cagney/2002-02-02: The c->type test is pretty dodgy\n          while the is_complete_command(cfunc) test is just plain\n@@ -1957,7 +1970,7 @@ set_verbose (const char *args, int from_tty, struct cmd_list_element *c)\n   const char *cmdname = \"verbose\";\n   struct cmd_list_element *showcmd;\n \n-  showcmd = lookup_cmd_1 (&cmdname, showlist, NULL, 1);\n+  showcmd = lookup_cmd_1 (&cmdname, showlist, NULL, NULL, 1);\n   gdb_assert (showcmd != NULL && showcmd != CMD_LIST_AMBIGUOUS);\n \n   if (c->doc && c->doc_allocated)"
    },
    {
      "sha": "00b7059be58f83cd8530eeabcd7ca914ab5642c9",
      "filename": "gdb/tracepoint.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/tracepoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/cf00cd6faf31c208bbfe107140c26895412214bb/gdb/tracepoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/tracepoint.c?ref=cf00cd6faf31c208bbfe107140c26895412214bb",
      "patch": "@@ -651,7 +651,7 @@ validate_actionline (const char *line, struct breakpoint *b)\n   if (*p == '#')\t\t/* comment line */\n     return;\n \n-  c = lookup_cmd (&p, cmdlist, \"\", -1, 1);\n+  c = lookup_cmd (&p, cmdlist, \"\", NULL, -1, 1);\n   if (c == 0)\n     error (_(\"`%s' is not a tracepoint action, or is ambiguous.\"), p);\n \n@@ -1303,7 +1303,7 @@ encode_actions_1 (struct command_line *action,\n       action_exp = action->line;\n       action_exp = skip_spaces (action_exp);\n \n-      cmd = lookup_cmd (&action_exp, cmdlist, \"\", -1, 1);\n+      cmd = lookup_cmd (&action_exp, cmdlist, \"\", NULL, -1, 1);\n       if (cmd == 0)\n \terror (_(\"Bad action list item: %s\"), action_exp);\n \n@@ -2673,7 +2673,7 @@ trace_dump_actions (struct command_line *action,\n       if (*action_exp == '#')\t/* comment line */\n \tcontinue;\n \n-      cmd = lookup_cmd (&action_exp, cmdlist, \"\", -1, 1);\n+      cmd = lookup_cmd (&action_exp, cmdlist, \"\", NULL, -1, 1);\n       if (cmd == 0)\n \terror (_(\"Bad action list item: %s\"), action_exp);\n "
    }
  ]
}