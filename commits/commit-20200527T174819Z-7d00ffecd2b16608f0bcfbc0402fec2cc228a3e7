{
  "sha": "7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6N2QwMGZmZWNkMmIxNjYwOGYwYmNmYmMwNDAyZmVjMmNjMjI4YTNlNw==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-05-27T17:48:18Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tromey@adacore.com",
      "date": "2020-05-27T17:48:19Z"
    },
    "message": "Lazily compute partial DIE name\n\nCurrently the name of a partial DIE is computed eagerly.  However, the\nname is not always needed.  This patch changes partial DIEs to compute\ntheir name lazily, improving performance by avoiding unnecessary name\ncomputations.\n\nThe run previous to this had times of (see the first patch in the\nseries for an explanation):\n\ngdb    1.88\nlibxul 2.11\nAda    2.60\n\nThis patch improves the times to:\n\ngdb    1.69\nlibxul 2.02\nAda    2.52\n\ngdb/ChangeLog\n2020-05-27  Tom Tromey  <tromey@adacore.com>\n\n\t* dwarf2/read.c (struct partial_die_info) <name>: Declare new\n\tmethod.\n\t<canonical_name>: New member.\n\t<raw_name>: Rename from \"name\".\n\t(partial_die_info): Initialize canonical_name.\n\t(scan_partial_symbols): Check raw_name.\n\t(partial_die_parent_scope, partial_die_full_name)\n\t(add_partial_symbol, add_partial_subprogram)\n\t(add_partial_enumeration, load_partial_dies): Use \"name\" method.\n\t(partial_die_info::name): New method.\n\t(partial_die_info::read, guess_partial_die_structure_name)\n\t(partial_die_info::fixup): Update.",
    "tree": {
      "sha": "fa02f48991601aa968c933d16525645bc165520b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/fa02f48991601aa968c933d16525645bc165520b"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "697bba18273d3a03f9093a94cf3e1d75012905f3",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/697bba18273d3a03f9093a94cf3e1d75012905f3",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/697bba18273d3a03f9093a94cf3e1d75012905f3"
    }
  ],
  "stats": {
    "total": 107,
    "additions": 74,
    "deletions": 33
  },
  "files": [
    {
      "sha": "74b329b8b626903b3c7b620932dba878e148ceed",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7",
      "patch": "@@ -1,3 +1,18 @@\n+2020-05-27  Tom Tromey  <tromey@adacore.com>\n+\n+\t* dwarf2/read.c (struct partial_die_info) <name>: Declare new\n+\tmethod.\n+\t<canonical_name>: New member.\n+\t<raw_name>: Rename from \"name\".\n+\t(partial_die_info): Initialize canonical_name.\n+\t(scan_partial_symbols): Check raw_name.\n+\t(partial_die_parent_scope, partial_die_full_name)\n+\t(add_partial_symbol, add_partial_subprogram)\n+\t(add_partial_enumeration, load_partial_dies): Use \"name\" method.\n+\t(partial_die_info::name): New method.\n+\t(partial_die_info::read, guess_partial_die_structure_name)\n+\t(partial_die_info::fixup): Update.\n+\n 2020-05-27  Tom Tromey  <tromey@adacore.com>\n \n \t* dwarf2/attribute.h (struct attribute) <form_is_ref>: Inline."
    },
    {
      "sha": "655338d2ef8ad55d6053f80d10e5320e6f9e5081",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 59,
      "deletions": 33,
      "changes": 92,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=7d00ffecd2b16608f0bcfbc0402fec2cc228a3e7",
      "patch": "@@ -971,6 +971,10 @@ struct partial_die_info : public allocate_on_obstack\n \t\t\t  const struct abbrev_info &abbrev,\n \t\t\t  const gdb_byte *info_ptr);\n \n+    /* Compute the name of this partial DIE.  This memoizes the\n+       result, so it is safe to call multiple times.  */\n+    const char *name (dwarf2_cu *cu);\n+\n     /* Offset of this DIE.  */\n     const sect_offset sect_off;\n \n@@ -1012,9 +1016,11 @@ struct partial_die_info : public allocate_on_obstack\n     /* Flag set if spec_offset uses DW_FORM_GNU_ref_alt.  */\n     unsigned int spec_is_dwz : 1;\n \n+    unsigned int canonical_name : 1;\n+\n     /* The name of this DIE.  Normally the value of DW_AT_name, but\n        sometimes a default name for unnamed DIEs.  */\n-    const char *name = nullptr;\n+    const char *raw_name = nullptr;\n \n     /* The linkage name, if present.  */\n     const char *linkage_name = nullptr;\n@@ -1083,6 +1089,7 @@ struct partial_die_info : public allocate_on_obstack\n       fixup_called = 0;\n       is_dwz = 0;\n       spec_is_dwz = 0;\n+      canonical_name = 0;\n     }\n   };\n \n@@ -8172,7 +8179,7 @@ scan_partial_symbols (struct partial_die_info *first_die, CORE_ADDR *lowpc,\n \t children, so we need to look at them.  Ditto for anonymous\n \t enums.  */\n \n-      if (pdi->name != NULL || pdi->tag == DW_TAG_namespace\n+      if (pdi->raw_name != NULL || pdi->tag == DW_TAG_namespace\n \t  || pdi->tag == DW_TAG_module || pdi->tag == DW_TAG_enumeration_type\n \t  || pdi->tag == DW_TAG_imported_unit\n \t  || pdi->tag == DW_TAG_inlined_subroutine)\n@@ -8317,7 +8324,7 @@ partial_die_parent_scope (struct partial_die_info *pdi,\n      Work around this problem here.  */\n   if (cu->language == language_cplus\n       && parent->tag == DW_TAG_namespace\n-      && strcmp (parent->name, \"::\") == 0\n+      && strcmp (parent->name (cu), \"::\") == 0\n       && grandparent_scope == NULL)\n     {\n       parent->scope = NULL;\n@@ -8341,11 +8348,11 @@ partial_die_parent_scope (struct partial_die_info *pdi,\n \t  && pdi->tag == DW_TAG_subprogram))\n     {\n       if (grandparent_scope == NULL)\n-\tparent->scope = parent->name;\n+\tparent->scope = parent->name (cu);\n       else\n \tparent->scope = typename_concat (&cu->comp_unit_obstack,\n \t\t\t\t\t grandparent_scope,\n-\t\t\t\t\t parent->name, 0, cu);\n+\t\t\t\t\t parent->name (cu), 0, cu);\n     }\n   else\n     {\n@@ -8379,7 +8386,7 @@ partial_die_full_name (struct partial_die_info *pdi,\n     {\n       pdi->fixup (cu);\n \n-      if (pdi->name != NULL && strchr (pdi->name, '<') == NULL)\n+      if (pdi->name (cu) != NULL && strchr (pdi->name (cu), '<') == NULL)\n \t{\n \t  struct die_info *die;\n \t  struct attribute attr;\n@@ -8400,7 +8407,8 @@ partial_die_full_name (struct partial_die_info *pdi,\n     return NULL;\n   else\n     return gdb::unique_xmalloc_ptr<char> (typename_concat (NULL, parent_scope,\n-\t\t\t\t\t\t\t   pdi->name, 0, cu));\n+\t\t\t\t\t\t\t   pdi->name (cu),\n+\t\t\t\t\t\t\t   0, cu));\n }\n \n static void\n@@ -8421,7 +8429,7 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n     actual_name = built_actual_name.get ();\n \n   if (actual_name == NULL)\n-    actual_name = pdi->name;\n+    actual_name = pdi->name (cu);\n \n   partial_symbol psymbol;\n   memset (&psymbol, 0, sizeof (psymbol));\n@@ -8683,7 +8691,7 @@ add_partial_subprogram (struct partial_die_info *pdi,\n \t    /* Ignore subprogram DIEs that do not have a name, they are\n \t       illegal.  Do not emit a complaint at this point, we will\n \t       do so when we convert this psymtab into a symtab.  */\n-\t    if (pdi->name)\n+\t    if (pdi->name (cu))\n \t      add_partial_symbol (pdi, cu);\n         }\n     }\n@@ -8714,13 +8722,13 @@ add_partial_enumeration (struct partial_die_info *enum_pdi,\n {\n   struct partial_die_info *pdi;\n \n-  if (enum_pdi->name != NULL)\n+  if (enum_pdi->name (cu) != NULL)\n     add_partial_symbol (enum_pdi, cu);\n \n   pdi = enum_pdi->die_child;\n   while (pdi)\n     {\n-      if (pdi->tag != DW_TAG_enumerator || pdi->name == NULL)\n+      if (pdi->tag != DW_TAG_enumerator || pdi->raw_name == NULL)\n \tcomplaint (_(\"malformed enumerator DIE ignored\"));\n       else\n \tadd_partial_symbol (pdi, cu);\n@@ -18349,8 +18357,8 @@ load_partial_dies (const struct die_reader_specs *reader,\n \t      || pdi.tag == DW_TAG_base_type\n \t      || pdi.tag == DW_TAG_subrange_type))\n \t{\n-\t  if (building_psymtab && pdi.name != NULL)\n-\t    add_psymbol_to_list (pdi.name, false,\n+\t  if (building_psymtab && pdi.raw_name != NULL)\n+\t    add_psymbol_to_list (pdi.name (cu), false,\n \t\t\t\t VAR_DOMAIN, LOC_TYPEDEF, -1,\n \t\t\t\t psymbol_placement::STATIC,\n \t\t\t\t 0, cu->language, objfile);\n@@ -18381,10 +18389,10 @@ load_partial_dies (const struct die_reader_specs *reader,\n \t  && parent_die->tag == DW_TAG_enumeration_type\n \t  && parent_die->has_specification == 0)\n \t{\n-\t  if (pdi.name == NULL)\n+\t  if (pdi.raw_name == NULL)\n \t    complaint (_(\"malformed enumerator DIE ignored\"));\n \t  else if (building_psymtab)\n-\t    add_psymbol_to_list (pdi.name, false,\n+\t    add_psymbol_to_list (pdi.name (cu), false,\n \t\t\t\t VAR_DOMAIN, LOC_CONST, -1,\n \t\t\t\t cu->language == language_cplus\n \t\t\t\t ? psymbol_placement::GLOBAL\n@@ -18468,8 +18476,8 @@ load_partial_dies (const struct die_reader_specs *reader,\n \t      || last_die->tag == DW_TAG_enumeration_type\n \t      || (cu->language == language_cplus\n \t\t  && last_die->tag == DW_TAG_subprogram\n-\t\t  && (last_die->name == NULL\n-\t\t      || strchr (last_die->name, '<') == NULL))\n+\t\t  && (last_die->raw_name == NULL\n+\t\t      || strchr (last_die->raw_name, '<') == NULL))\n \t      || (cu->language != language_c\n \t\t  && (last_die->tag == DW_TAG_class_type\n \t\t      || last_die->tag == DW_TAG_interface_type\n@@ -18498,6 +18506,21 @@ partial_die_info::partial_die_info (sect_offset sect_off_,\n {\n }\n \n+/* See class definition.  */\n+\n+const char *\n+partial_die_info::name (dwarf2_cu *cu)\n+{\n+  if (!canonical_name && raw_name != nullptr)\n+    {\n+      struct objfile *objfile = cu->per_objfile->objfile;\n+      raw_name = dwarf2_canonicalize_name (raw_name, cu, objfile);\n+      canonical_name = 1;\n+    }\n+\n+  return raw_name;\n+}\n+\n /* Read a minimal amount of information into the minimal die structure.\n    INFO_PTR should point just after the initial uleb128 of a DIE.  */\n \n@@ -18539,15 +18562,12 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t    case DW_TAG_enumerator:\n \t      /* These tags always have simple identifiers already; no need\n \t\t to canonicalize them.  */\n-\t      name = DW_STRING (&attr);\n+\t      canonical_name = 1;\n+\t      raw_name = DW_STRING (&attr);\n \t      break;\n \t    default:\n-\t      {\n-\t\tstruct objfile *objfile = dwarf2_per_objfile->objfile;\n-\n-\t\tname\n-\t\t  = dwarf2_canonicalize_name (DW_STRING (&attr), cu, objfile);\n-\t      }\n+\t      canonical_name = 0;\n+\t      raw_name = DW_STRING (&attr);\n \t      break;\n \t    }\n \t  break;\n@@ -18699,7 +18719,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n      Really, though, this is just a workaround for the fact that gdb\n      doesn't store both the name and the linkage name.  */\n   if (cu->language == language_ada && linkage_name != nullptr)\n-    name = linkage_name;\n+    raw_name = linkage_name;\n \n   if (high_pc_relative)\n     highpc += lowpc;\n@@ -18877,7 +18897,8 @@ guess_partial_die_structure_name (struct partial_die_info *struct_pdi,\n \t  if (actual_class_name != NULL)\n \t    {\n \t      struct objfile *objfile = cu->per_objfile->objfile;\n-\t      struct_pdi->name = objfile->intern (actual_class_name.get ());\n+\t      struct_pdi->raw_name = objfile->intern (actual_class_name.get ());\n+\t      struct_pdi->canonical_name = 1;\n \t    }\n \t  break;\n \t}\n@@ -18915,7 +18936,7 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n   /* If we found a reference attribute and the DIE has no name, try\n      to find a name in the referred to DIE.  */\n \n-  if (name == NULL && has_specification)\n+  if (raw_name == NULL && has_specification)\n     {\n       struct partial_die_info *spec_die;\n \n@@ -18925,9 +18946,10 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n \n       spec_die->fixup (cu);\n \n-      if (spec_die->name)\n+      if (spec_die->raw_name)\n \t{\n-\t  name = spec_die->name;\n+\t  raw_name = spec_die->raw_name;\n+\t  canonical_name = spec_die->canonical_name;\n \n \t  /* Copy DW_AT_external attribute if it is set.  */\n \t  if (spec_die->is_external)\n@@ -18955,8 +18977,11 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n \n   /* Set default names for some unnamed DIEs.  */\n \n-  if (name == NULL && tag == DW_TAG_namespace)\n-    name = CP_ANONYMOUS_NAMESPACE_STR;\n+  if (raw_name == NULL && tag == DW_TAG_namespace)\n+    {\n+      raw_name = CP_ANONYMOUS_NAMESPACE_STR;\n+      canonical_name = 1;\n+    }\n \n   /* If there is no parent die to provide a namespace, and there are\n      children, see if we can determine the namespace from their linkage\n@@ -18972,7 +18997,7 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n \n   /* GCC might emit a nameless struct or union that has a linkage\n      name.  See http://gcc.gnu.org/bugzilla/show_bug.cgi?id=47510.  */\n-  if (name == NULL\n+  if (raw_name == NULL\n       && (tag == DW_TAG_class_type\n \t  || tag == DW_TAG_interface_type\n \t  || tag == DW_TAG_structure_type\n@@ -18994,7 +19019,8 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n \t    base = demangled.get ();\n \n \t  struct objfile *objfile = cu->per_objfile->objfile;\n-\t  name = objfile->intern (base);\n+\t  raw_name = objfile->intern (base);\n+\t  canonical_name = 1;\n \t}\n     }\n "
    }
  ]
}