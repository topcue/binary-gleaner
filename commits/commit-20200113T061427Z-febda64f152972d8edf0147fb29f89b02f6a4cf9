{
  "sha": "febda64f152972d8edf0147fb29f89b02f6a4cf9",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZmViZGE2NGYxNTI5NzJkOGVkZjAxNDdmYjI5Zjg5YjAyZjZhNGNmOQ==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-13T03:57:19Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2020-01-13T06:14:27Z"
    },
    "message": "ubsan: wasm32: signed integer overflow\n\nThe signed integer overflow occurred when adding one to target_count\n  for (i = 0; i < target_count + 1; i++)\nbut that's the least of the worries here.  target_count was long and i\nint, leading to the possibility of a loop that never ended.\n\nSo to avoid this type of vulnerability, this patch uses what I believe\nto be the proper types for arguments of various wasm32 opcodes, rather\nthan using \"long\" which may change in size.\n\ngas/\n\t* testsuite/gas/wasm32/allinsn.d: Update expected output.\nopcodes/\n\t* wasm32-dis.c (print_insn_wasm32): Localise variables.  Store\n\tresult of wasm_read_leb128 in a uint64_t and check that bits\n\tare not lost when copying to other locals.  Use uint32_t for\n\tmost locals.  Use PRId64 when printing int64_t.",
    "tree": {
      "sha": "530633bd36c29a3fd0715e8658777f665385aa9a",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/530633bd36c29a3fd0715e8658777f665385aa9a"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/febda64f152972d8edf0147fb29f89b02f6a4cf9",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/febda64f152972d8edf0147fb29f89b02f6a4cf9",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/febda64f152972d8edf0147fb29f89b02f6a4cf9",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/febda64f152972d8edf0147fb29f89b02f6a4cf9/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "df08b5881b4972d78f9a2069955dad5b12bc972e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/df08b5881b4972d78f9a2069955dad5b12bc972e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/df08b5881b4972d78f9a2069955dad5b12bc972e"
    }
  ],
  "stats": {
    "total": 460,
    "additions": 249,
    "deletions": 211
  },
  "files": [
    {
      "sha": "c6f93cc8d2e6e3fd8faf4ba37af52edd3d77e0d5",
      "filename": "gas/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/febda64f152972d8edf0147fb29f89b02f6a4cf9/gas/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/febda64f152972d8edf0147fb29f89b02f6a4cf9/gas/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/ChangeLog?ref=febda64f152972d8edf0147fb29f89b02f6a4cf9",
      "patch": "@@ -1,3 +1,7 @@\n+2020-01-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* testsuite/gas/wasm32/allinsn.d: Update expected output.\n+\n 2020-01-13  Alan Modra  <amodra@gmail.com>\n \n \t* config/tc-tic4x.c (tic4x_operands_match): Correct tic3x trap"
    },
    {
      "sha": "44293853869835ba759ab6d28fc55ab2630f961c",
      "filename": "gas/testsuite/gas/wasm32/allinsn.d",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/febda64f152972d8edf0147fb29f89b02f6a4cf9/gas/testsuite/gas/wasm32/allinsn.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/febda64f152972d8edf0147fb29f89b02f6a4cf9/gas/testsuite/gas/wasm32/allinsn.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gas/testsuite/gas/wasm32/allinsn.d?ref=febda64f152972d8edf0147fb29f89b02f6a4cf9",
      "patch": "@@ -20,7 +20,7 @@ Disassembly of section .text:\n   12:\t8b          \t\tf32.abs\n   13:\t92          \t\tf32.add\n   14:\t8d          \t\tf32.ceil\n-  15:\t43 d0 0f 49 \t\tf32.const 3.141590118408203125\n+  15:\t43 d0 0f 49 \t\tf32.const 3.14159012\n   19:\t40 \n   1a:\tb2          \t\tf32.convert_s/i32\n   1b:\tb4          \t\tf32.convert_s/i64\n@@ -50,7 +50,7 @@ Disassembly of section .text:\n   37:\t99          \t\tf64.abs\n   38:\ta0          \t\tf64.add\n   39:\t9b          \t\tf64.ceil\n-  3a:\t44 97 5f 4f \t\tf64.const 3.14158999999999976088e\\+200\n+  3a:\t44 97 5f 4f \t\tf64.const 3.1415899999999998e\\+200\n   3e:\tfd bc 6a 90 \n   42:\t69 \n   43:\tb7          \t\tf64.convert_s/i32"
    },
    {
      "sha": "458433164f100cc595c32e42e3fbab16d481c1fc",
      "filename": "opcodes/ChangeLog",
      "status": "modified",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/febda64f152972d8edf0147fb29f89b02f6a4cf9/opcodes/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/febda64f152972d8edf0147fb29f89b02f6a4cf9/opcodes/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/ChangeLog?ref=febda64f152972d8edf0147fb29f89b02f6a4cf9",
      "patch": "@@ -1,3 +1,10 @@\n+2020-01-13  Alan Modra  <amodra@gmail.com>\n+\n+\t* wasm32-dis.c (print_insn_wasm32): Localise variables.  Store\n+\tresult of wasm_read_leb128 in a uint64_t and check that bits\n+\tare not lost when copying to other locals.  Use uint32_t for\n+\tmost locals.  Use PRId64 when printing int64_t.\n+\n 2020-01-13  Alan Modra  <amodra@gmail.com>\n \n \t* score-dis.c: Formatting."
    },
    {
      "sha": "946ce5fb68bcb13057c42d6872c11fae6ad16fc2",
      "filename": "opcodes/wasm32-dis.c",
      "status": "modified",
      "additions": 236,
      "deletions": 209,
      "changes": 445,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/febda64f152972d8edf0147fb29f89b02f6a4cf9/opcodes/wasm32-dis.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/febda64f152972d8edf0147fb29f89b02f6a4cf9/opcodes/wasm32-dis.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/opcodes/wasm32-dis.c?ref=febda64f152972d8edf0147fb29f89b02f6a4cf9",
      "patch": "@@ -271,33 +271,10 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n   void *stream = info->stream;\n   fprintf_ftype prin = info->fprintf_func;\n   struct wasm32_private_data *private_data = info->private_data;\n-  long long constant = 0;\n-  double fconstant = 0.0;\n-  long flags = 0;\n-  long offset = 0;\n-  long depth = 0;\n-  long function_index = 0;\n-  long target_count = 0;\n-  long block_type = 0;\n-  int len = 1;\n-  int ret = 0;\n-  unsigned int bytes_read = 0;\n-  int i;\n-  const char *locals[] =\n-    {\n-      \"$dpc\", \"$sp1\", \"$r0\", \"$r1\", \"$rpc\", \"$pc0\",\n-      \"$rp\", \"$fp\", \"$sp\",\n-      \"$r2\", \"$r3\", \"$r4\", \"$r5\", \"$r6\", \"$r7\",\n-      \"$i0\", \"$i1\", \"$i2\", \"$i3\", \"$i4\", \"$i5\", \"$i6\", \"$i7\",\n-      \"$f0\", \"$f1\", \"$f2\", \"$f3\", \"$f4\", \"$f5\", \"$f6\", \"$f7\",\n-    };\n-  int nlocals = ARRAY_SIZE (locals);\n-  const char *globals[] =\n-    {\n-      \"$got\", \"$plt\", \"$gpo\"\n-    };\n-  int nglobals = ARRAY_SIZE (globals);\n-  bfd_boolean error = FALSE;\n+  uint64_t val;\n+  int len;\n+  unsigned int bytes_read;\n+  bfd_boolean error;\n \n   if (info->read_memory_func (pc, buffer, 1, info))\n     return -1;\n@@ -313,189 +290,239 @@ print_insn_wasm32 (bfd_vma pc, struct disassemble_info *info)\n       prin (stream, \"\\t.byte 0x%02x\\n\", buffer[0]);\n       return 1;\n     }\n-  else\n+\n+  len = 1;\n+\n+  prin (stream, \"\\t\");\n+  prin (stream, \"%s\", op->name);\n+\n+  if (op->clas == wasm_typed)\n     {\n-      len = 1;\n-\n-      prin (stream, \"\\t\");\n-      prin (stream, \"%s\", op->name);\n-\n-      if (op->clas == wasm_typed)\n-        {\n-          block_type = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          switch (block_type)\n-            {\n-            case BLOCK_TYPE_NONE:\n-              prin (stream, \"[]\");\n-              break;\n-            case BLOCK_TYPE_I32:\n-              prin (stream, \"[i]\");\n-              break;\n-            case BLOCK_TYPE_I64:\n-              prin (stream, \"[l]\");\n-              break;\n-            case BLOCK_TYPE_F32:\n-              prin (stream, \"[f]\");\n-              break;\n-            case BLOCK_TYPE_F64:\n-              prin (stream, \"[d]\");\n-              break;\n-            }\n-        }\n-\n-      switch (op->clas)\n-        {\n-        case wasm_special:\n-        case wasm_eqz:\n-        case wasm_binary:\n-        case wasm_unary:\n-        case wasm_conv:\n-        case wasm_relational:\n-        case wasm_drop:\n-        case wasm_signature:\n-        case wasm_call_import:\n-        case wasm_typed:\n-        case wasm_select:\n-          break;\n-\n-        case wasm_break_table:\n-          target_count = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" %ld\", target_count);\n-          for (i = 0; i < target_count + 1; i++)\n-            {\n-              long target = 0;\n-              target = wasm_read_leb128\n-                (pc + len, info, &error, &bytes_read, FALSE);\n-              if (error)\n-                return -1;\n-              len += bytes_read;\n-              prin (stream, \" %ld\", target);\n-            }\n-          break;\n-\n-        case wasm_break:\n-        case wasm_break_if:\n-          depth = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" %ld\", depth);\n-          break;\n-\n-        case wasm_return:\n-          break;\n-\n-        case wasm_constant_i32:\n-        case wasm_constant_i64:\n-          constant = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, TRUE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" %lld\", constant);\n-          break;\n-\n-        case wasm_constant_f32:\n-          /* This appears to be the best we can do, even though we're\n-             using host doubles for WebAssembly floats.  */\n-          ret = read_f32 (&fconstant, pc + len, info);\n-          if (ret < 0)\n-            return -1;\n-          len += ret;\n-\t  prin (stream, \" %.9g\", fconstant);\n-          break;\n-\n-        case wasm_constant_f64:\n-          ret = read_f64 (&fconstant, pc + len, info);\n-          if (ret < 0)\n-            return -1;\n-          len += ret;\n-\t  prin (stream, \" %.17g\", fconstant);\n-          break;\n-\n-        case wasm_call:\n-          function_index = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" \");\n-          private_data->section_prefix = \".space.function_index\";\n-          (*info->print_address_func) ((bfd_vma) function_index, info);\n-          private_data->section_prefix = NULL;\n-          break;\n-\n-        case wasm_call_indirect:\n-          constant = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" %lld\", constant);\n-          constant = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" %lld\", constant);\n-          break;\n-\n-        case wasm_get_local:\n-        case wasm_set_local:\n-        case wasm_tee_local:\n-          constant = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" %lld\", constant);\n-          if (strcmp (op->name + 4, \"local\") == 0)\n-            {\n-              if (private_data->print_registers\n-                  && constant >= 0 && constant < nlocals)\n-                prin (stream, \" <%s>\", locals[constant]);\n-            }\n-          else\n-            {\n-              if (private_data->print_well_known_globals\n-                  && constant >= 0 && constant < nglobals)\n-                prin (stream, \" <%s>\", globals[constant]);\n-            }\n-          break;\n-\n-        case wasm_grow_memory:\n-        case wasm_current_memory:\n-          constant = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" %lld\", constant);\n-          break;\n-\n-        case wasm_load:\n-        case wasm_store:\n-          flags = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          offset = wasm_read_leb128\n-            (pc + len, info, &error, &bytes_read, FALSE);\n-          if (error)\n-            return -1;\n-          len += bytes_read;\n-          prin (stream, \" a=%ld %ld\", flags, offset);\n-        }\n+      val = wasm_read_leb128 (pc + len, info, &error, &bytes_read, FALSE);\n+      if (error)\n+\treturn -1;\n+      len += bytes_read;\n+      switch (val)\n+\t{\n+\tcase BLOCK_TYPE_NONE:\n+\t  prin (stream, \"[]\");\n+\t  break;\n+\tcase BLOCK_TYPE_I32:\n+\t  prin (stream, \"[i]\");\n+\t  break;\n+\tcase BLOCK_TYPE_I64:\n+\t  prin (stream, \"[l]\");\n+\t  break;\n+\tcase BLOCK_TYPE_F32:\n+\t  prin (stream, \"[f]\");\n+\t  break;\n+\tcase BLOCK_TYPE_F64:\n+\t  prin (stream, \"[d]\");\n+\t  break;\n+\tdefault:\n+\t  return -1;\n+\t}\n+    }\n+\n+  switch (op->clas)\n+    {\n+    case wasm_special:\n+    case wasm_eqz:\n+    case wasm_binary:\n+    case wasm_unary:\n+    case wasm_conv:\n+    case wasm_relational:\n+    case wasm_drop:\n+    case wasm_signature:\n+    case wasm_call_import:\n+    case wasm_typed:\n+    case wasm_select:\n+      break;\n+\n+    case wasm_break_table:\n+      {\n+\tuint32_t target_count, i;\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\ttarget_count = val;\n+\tif (error || target_count != val || target_count == (uint32_t) -1)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tprin (stream, \" %u\", target_count);\n+\tfor (i = 0; i < target_count + 1; i++)\n+\t  {\n+\t    uint32_t target;\n+\t    val = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\t    FALSE);\n+\t    target = val;\n+\t    if (error || target != val)\n+\t      return -1;\n+\t    len += bytes_read;\n+\t    prin (stream, \" %u\", target);\n+\t  }\n+      }\n+      break;\n+\n+    case wasm_break:\n+    case wasm_break_if:\n+      {\n+\tuint32_t depth;\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\tdepth = val;\n+\tif (error || depth != val)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tprin (stream, \" %u\", depth);\n+      }\n+      break;\n+\n+    case wasm_return:\n+      break;\n+\n+    case wasm_constant_i32:\n+    case wasm_constant_i64:\n+      val = wasm_read_leb128 (pc + len, info, &error, &bytes_read, TRUE);\n+      if (error)\n+\treturn -1;\n+      len += bytes_read;\n+      prin (stream, \" %\" PRId64, val);\n+      break;\n+\n+    case wasm_constant_f32:\n+      {\n+\tdouble fconstant;\n+\tint ret;\n+\t/* This appears to be the best we can do, even though we're\n+\t   using host doubles for WebAssembly floats.  */\n+\tret = read_f32 (&fconstant, pc + len, info);\n+\tif (ret < 0)\n+\t  return -1;\n+\tlen += ret;\n+\tprin (stream, \" %.9g\", fconstant);\n+      }\n+      break;\n+\n+    case wasm_constant_f64:\n+      {\n+\tdouble fconstant;\n+\tint ret;\n+\tret = read_f64 (&fconstant, pc + len, info);\n+\tif (ret < 0)\n+\t  return -1;\n+\tlen += ret;\n+\tprin (stream, \" %.17g\", fconstant);\n+      }\n+      break;\n+\n+    case wasm_call:\n+      {\n+\tuint32_t function_index;\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\tfunction_index = val;\n+\tif (error || function_index != val)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tprin (stream, \" \");\n+\tprivate_data->section_prefix = \".space.function_index\";\n+\t(*info->print_address_func) ((bfd_vma) function_index, info);\n+\tprivate_data->section_prefix = NULL;\n+      }\n+      break;\n+\n+    case wasm_call_indirect:\n+      {\n+\tuint32_t type_index, xtra_index;\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\ttype_index = val;\n+\tif (error || type_index != val)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tprin (stream, \" %u\", type_index);\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\txtra_index = val;\n+\tif (error || xtra_index != val)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tprin (stream, \" %u\", xtra_index);\n+      }\n+      break;\n+\n+    case wasm_get_local:\n+    case wasm_set_local:\n+    case wasm_tee_local:\n+      {\n+\tuint32_t local_index;\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\tlocal_index = val;\n+\tif (error || local_index != val)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tprin (stream, \" %u\", local_index);\n+\tif (strcmp (op->name + 4, \"local\") == 0)\n+\t  {\n+\t    static const char *locals[] =\n+\t      {\n+\t\t\"$dpc\", \"$sp1\", \"$r0\", \"$r1\", \"$rpc\", \"$pc0\",\n+\t\t\"$rp\", \"$fp\", \"$sp\",\n+\t\t\"$r2\", \"$r3\", \"$r4\", \"$r5\", \"$r6\", \"$r7\",\n+\t\t\"$i0\", \"$i1\", \"$i2\", \"$i3\", \"$i4\", \"$i5\", \"$i6\", \"$i7\",\n+\t\t\"$f0\", \"$f1\", \"$f2\", \"$f3\", \"$f4\", \"$f5\", \"$f6\", \"$f7\",\n+\t      };\n+\t    if (private_data->print_registers\n+\t\t&& local_index < ARRAY_SIZE (locals))\n+\t      prin (stream, \" <%s>\", locals[local_index]);\n+\t  }\n+\telse\n+\t  {\n+\t    static const char *globals[] =\n+\t      {\n+\t\t\"$got\", \"$plt\", \"$gpo\"\n+\t      };\n+\t    if (private_data->print_well_known_globals\n+\t\t&& local_index < ARRAY_SIZE (globals))\n+\t      prin (stream, \" <%s>\", globals[local_index]);\n+\t  }\n+      }\n+      break;\n+\n+    case wasm_grow_memory:\n+    case wasm_current_memory:\n+      {\n+\tuint32_t reserved_size;\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\treserved_size = val;\n+\tif (error || reserved_size != val)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tprin (stream, \" %u\", reserved_size);\n+      }\n+      break;\n+\n+    case wasm_load:\n+    case wasm_store:\n+      {\n+\tuint32_t flags, offset;\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\tflags = val;\n+\tif (error || flags != val)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tval = wasm_read_leb128 (pc + len, info, &error, &bytes_read,\n+\t\t\t\tFALSE);\n+\toffset = val;\n+\tif (error || offset != val)\n+\t  return -1;\n+\tlen += bytes_read;\n+\tprin (stream, \" a=%u %u\", flags, offset);\n+      }\n+      break;\n     }\n   return len;\n }"
    }
  ]
}