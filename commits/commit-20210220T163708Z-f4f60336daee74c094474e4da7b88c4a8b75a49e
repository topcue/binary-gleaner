{
  "sha": "f4f60336daee74c094474e4da7b88c4a8b75a49e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6ZjRmNjAzMzZkYWVlNzRjMDk0NDc0ZTRkYTdiODhjNGE4Yjc1YTQ5ZQ==",
  "commit": {
    "author": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-02-17T15:21:12Z"
    },
    "committer": {
      "name": "Nick Alcock",
      "email": "nick.alcock@oracle.com",
      "date": "2021-02-20T16:37:08Z"
    },
    "message": "libctf, include: find types of symbols by name\n\nThe existing ctf_lookup_by_symbol and ctf_arc_lookup_symbol functions\nsuffice to look up the types of symbols if the caller already has a\nsymbol number.  But the caller often doesn't have one of those and only\nknows the name of the symbol: also, in object files, the caller might\nnot have a useful symbol number in any sense (and neither does libctf:\nthe 'symbol number' we use in that case literally starts at 0 for the\nlexicographically first-sorted symbol in the symtypetab and counts those\nsymbols, so it corresponds to nothing useful).\n\nThis means that even though object files have a symtypetab (generated by\nthe compiler or by ld -r), the only way we can look up anything in it is\nto iterate over all symbols in turn with ctf_symbol_next until we find\nthe one we want.\n\nThis is unhelpful and pointlessly inefficient.\n\nSo add a pair of functions to look up symbols by name in a dict and in a\nwhole archive: ctf_lookup_by_symbol_name and ctf_arc_lookup_symbol_name.\nThese are identical to the existing functions except that they take\nsymbol names rather than symbol numbers.\n\nTo avoid insane repetition, we do some refactoring in the process, so\nthat both ctf_lookup_by_symbol and ctf_arc_lookup_symbol turn into thin\nwrappers around internal functions that do both lookup by symbol index\nand lookup by name.  This massively reduces code duplication because\neven the existing lookup-by-index stuff wants to use a name sometimes\n(when looking up in indexed sections), and the new lookup-by-name stuff\nhas to turn it into an index sometimes (when looking up in non-indexed\nsections): doing it this way lets us share most of that.\n\nThe actual name->index lookup is done by ctf_lookup_symbol_idx.  We do\nnot anticipate this lookup to be as heavily used as ld.so symbol lookup\nby many orders of magnitude, so using the ELF symbol hashes would\nprobably take more time to read them than is saved by using the hashes,\nand it adds a lot of complexity.  Instead, do a linear search for the\nsymbol name, caching all the name -> index mappings as we go, so that\nfuture searches are likely to hit in the cache.  To avoid having to\nrepeat this search over and over in a CTF archive when\nctf_arc_lookup_symbol_name is used, have cached archive lookups (the\nsort done by ctf_arc_lookup_symbol* and the ctf_archive_next iterator)\npick out the first dict they cache in a given archive and store it in a\nnew ctf_archive field, ctfi_crossdict_cache.  This can be used to store\ncross-dictionary cached state that depends on things like the ELF symbol\ntable rather than the contents of any one dict.  ctf_lookup_symbol_idx\nthen caches its name->index mappings in the dictionary named in the\ncrossdict cache, if any, so that ctf_lookup_symbol_idx in other dicts\nin the same archive benefit from the previous linear search, and the\nsymtab only needs to be scanned at most once.\n\n(Note that if you call ctf_lookup_by_symbol_name in one specific dict,\nand then follow it with a ctf_arc_lookup_symbol_name, the former will\nnot use the crossdict cache because it's only populated by the dict\nopens in ctf_arc_lookup_symbol_name. This is harmless except for a small\none-off waste of memory and time: it's only a cache, after all.  We can\nfix this later by using the archive caching machinery more\naggressively.)\n\nIn ctf-archive, we do similar things, turning ctf_arc_lookup_symbol into\na wrapper around a new function that does both index -> ID and name ->\nID lookups across all dicts in an archive.  We add a new\nctfi_symnamedicts cache that maps symbol names to the ctf_dict_t * that\nit was found in (so that linear searches for symbols don't need to be\nrepeated): but we also *remove* a cache, the ctfi_syms cache that was\nmemoizing the actual ctf_id_t returned from every call to\nctf_arc_lookup_symbol.  This is pointless: all it saves is one call to\nctf_lookup_by_symbol, and that's basically an array lookup and nothing\nmore so isn't worth caching.  (Equally, given that symbol -> index\nmappings are cached by ctf_lookup_by_symbol_name, those calls are nearly\nfree after the first call, so there's no point caching the ctf_id_t in\nthat case either.)\n\nWe fix up one test that was doing manual symbol lookup to use\nctf_arc_lookup_symbol instead, and enhance it to check that the caching\nlayer is not totally broken: we also add a new test to do lookups in a\n.o file, and another to do lookups in an archive with conflicted types\nand make sure that sort of multi-dict lookup is actually working.\n\ninclude/ChangeLog\n2021-02-17  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-api.h (ctf_arc_lookup_symbol_name): New.\n\t(ctf_lookup_by_symbol_name): Likewise.\n\nlibctf/ChangeLog\n2021-02-17  Nick Alcock  <nick.alcock@oracle.com>\n\n\t* ctf-impl.h (ctf_dict_t) <ctf_symhash>: New.\n\t<ctf_symhash_latest>: Likewise.\n\t(struct ctf_archive_internal) <ctfi_crossdict_cache>: New.\n\t<ctfi_symnamedicts>: New.\n\t<ctfi_syms>: Remove.\n\t(ctf_lookup_symbol_name): Remove.\n\t* ctf-lookup.c (ctf_lookup_symbol_name): Propagate errors from\n\tparent properly.  Make static.\n\t(ctf_lookup_symbol_idx): New, linear search for the symbol name,\n\tcached in the crossdict cache's ctf_symhash (if available), or\n\tthis dict's (otherwise).\n\t(ctf_try_lookup_indexed): Allow the symname to be passed in.\n\t(ctf_lookup_by_symbol): Turn into a wrapper around...\n\t(ctf_lookup_by_sym_or_name): ... this, supporting name lookup too,\n\tusing ctf_lookup_symbol_idx in non-writable dicts.  Special-case\n\tname lookup in dynamic dicts without reported symbols, which have\n\tno symtab or dynsymidx but where name lookup should still work.\n\t(ctf_lookup_by_symbol_name): New, another wrapper.\n\t* ctf-archive.c (enosym): Note that this is present in\n\tctfi_symnamedicts too.\n\t(ctf_arc_close): Adjust for removal of ctfi_syms.  Free the\n\tctfi_symnamedicts.\n\t(ctf_arc_flush_caches): Likewise.\n\t(ctf_dict_open_cached): Memoize the first cached dict in the\n\tcrossdict cache.\n\t(ctf_arc_lookup_symbol): Turn into a wrapper around...\n\t(ctf_arc_lookup_sym_or_name): ... this.  No longer cache\n\tctf_id_t lookups: just call ctf_lookup_by_symbol as needed (but\n\tstill cache the dicts those lookups succeed in).  Add\n\tlookup-by-name support, with dicts of successful lookups cached in\n\tctfi_symnamedicts.  Refactor the caching code a bit.\n\t(ctf_arc_lookup_symbol_name): New, another wrapper.\n\t* ctf-open.c (ctf_dict_close): Free the ctf_symhash.\n\t* libctf.ver (LIBCTF_1.2): New version.  Add\n\tctf_lookup_by_symbol_name, ctf_arc_lookup_symbol_name.\n\t* testsuite/libctf-lookup/enum-symbol.c (main): Use\n\tctf_arc_lookup_symbol rather than looking up the name ourselves.\n\tFish it out repeatedly, to make sure that symbol caching isn't\n\tbroken.\n\t(symidx_64): Remove.\n\t(symidx_32): Remove.\n\t* testsuite/libctf-lookup/enum-symbol-obj.lk: Test symbol lookup\n\tin an unlinked object file (indexed symtypetab sections only).\n\t* testsuite/libctf-writable/symtypetab-nonlinker-writeout.c\n\t(try_maybe_reporting): Check symbol types via\n\tctf_lookup_by_symbol_name as well as ctf_symbol_next.\n\t* testsuite/libctf-lookup/conflicting-type-syms.*: New test of\n\tlookups in a multi-dict archive.",
    "tree": {
      "sha": "ec1686cf04ffff399ba01717cfc14cd83b9fae57",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ec1686cf04ffff399ba01717cfc14cd83b9fae57"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/f4f60336daee74c094474e4da7b88c4a8b75a49e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f4f60336daee74c094474e4da7b88c4a8b75a49e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/f4f60336daee74c094474e4da7b88c4a8b75a49e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/f4f60336daee74c094474e4da7b88c4a8b75a49e/comments",
  "author": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "nickalcock",
    "id": 6503005,
    "node_id": "MDQ6VXNlcjY1MDMwMDU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6503005?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/nickalcock",
    "html_url": "https://github.com/nickalcock",
    "followers_url": "https://api.github.com/users/nickalcock/followers",
    "following_url": "https://api.github.com/users/nickalcock/following{/other_user}",
    "gists_url": "https://api.github.com/users/nickalcock/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/nickalcock/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/nickalcock/subscriptions",
    "organizations_url": "https://api.github.com/users/nickalcock/orgs",
    "repos_url": "https://api.github.com/users/nickalcock/repos",
    "events_url": "https://api.github.com/users/nickalcock/events{/privacy}",
    "received_events_url": "https://api.github.com/users/nickalcock/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "3e8bb3e934bf6eb24e7914880a30bda3f175583b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3e8bb3e934bf6eb24e7914880a30bda3f175583b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3e8bb3e934bf6eb24e7914880a30bda3f175583b"
    }
  ],
  "stats": {
    "total": 755,
    "additions": 576,
    "deletions": 179
  },
  "files": [
    {
      "sha": "71f0beb13b08db004163b3559a837ed2c73c2adb",
      "filename": "include/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/include/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/include/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ChangeLog?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -1,3 +1,8 @@\n+2021-02-17  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-api.h (ctf_arc_lookup_symbol_name): New.\n+\t(ctf_lookup_by_symbol_name): Likewise.\n+\n 2021-02-19  Nelson Chu  <nelson.chu@sifive.com>\n \n \tPR 27158"
    },
    {
      "sha": "ce764dff5e3e6997aa42b54d336a40ebfe187cd7",
      "filename": "include/ctf-api.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/include/ctf-api.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/include/ctf-api.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/include/ctf-api.h?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -338,6 +338,9 @@ extern void ctf_arc_close (ctf_archive_t *);\n extern ctf_dict_t *ctf_arc_lookup_symbol (ctf_archive_t *,\n \t\t\t\t\t  unsigned long symidx,\n \t\t\t\t\t  ctf_id_t *, int *errp);\n+extern ctf_dict_t *ctf_arc_lookup_symbol_name (ctf_archive_t *,\n+\t\t\t\t\t       const char *name,\n+\t\t\t\t\t       ctf_id_t *, int *errp);\n extern void ctf_arc_flush_caches (ctf_archive_t *);\n extern ctf_dict_t *ctf_dict_open (const ctf_archive_t *,\n \t\t\t\t  const char *, int *);\n@@ -388,6 +391,7 @@ extern int ctf_func_type_args (ctf_dict_t *, ctf_id_t, uint32_t, ctf_id_t *);\n \n extern ctf_id_t ctf_lookup_by_name (ctf_dict_t *, const char *);\n extern ctf_id_t ctf_lookup_by_symbol (ctf_dict_t *, unsigned long);\n+extern ctf_id_t ctf_lookup_by_symbol_name (ctf_dict_t *, const char *);\n extern ctf_id_t ctf_symbol_next (ctf_dict_t *, ctf_next_t **,\n \t\t\t\t const char **name, int functions);\n extern ctf_id_t ctf_lookup_variable (ctf_dict_t *, const char *);"
    },
    {
      "sha": "acf3c4653f7f43c8fc7d3df7b0246c169e24c5c1",
      "filename": "libctf/ChangeLog",
      "status": "modified",
      "additions": 51,
      "deletions": 0,
      "changes": 51,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ChangeLog?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -1,3 +1,54 @@\n+2021-02-17  Nick Alcock  <nick.alcock@oracle.com>\n+\n+\t* ctf-impl.h (ctf_dict_t) <ctf_symhash>: New.\n+\t<ctf_symhash_latest>: Likewise.\n+\t(struct ctf_archive_internal) <ctfi_crossdict_cache>: New.\n+\t<ctfi_symnamedicts>: New.\n+\t<ctfi_syms>: Remove.\n+\t(ctf_lookup_symbol_name): Remove.\n+\t* ctf-lookup.c (ctf_lookup_symbol_name): Propagate errors from\n+\tparent properly.  Make static.\n+\t(ctf_lookup_symbol_idx): New, linear search for the symbol name,\n+\tcached in the crossdict cache's ctf_symhash (if available), or\n+\tthis dict's (otherwise).\n+\t(ctf_try_lookup_indexed): Allow the symname to be passed in.\n+\t(ctf_lookup_by_symbol): Turn into a wrapper around...\n+\t(ctf_lookup_by_sym_or_name): ... this, supporting name lookup too,\n+\tusing ctf_lookup_symbol_idx in non-writable dicts.  Special-case\n+\tname lookup in dynamic dicts without reported symbols, which have\n+\tno symtab or dynsymidx but where name lookup should still work.\n+\t(ctf_lookup_by_symbol_name): New, another wrapper.\n+\t* ctf-archive.c (enosym): Note that this is present in\n+\tctfi_symnamedicts too.\n+\t(ctf_arc_close): Adjust for removal of ctfi_syms.  Free the\n+\tctfi_symnamedicts.\n+\t(ctf_arc_flush_caches): Likewise.\n+\t(ctf_dict_open_cached): Memoize the first cached dict in the\n+\tcrossdict cache.\n+\t(ctf_arc_lookup_symbol): Turn into a wrapper around...\n+\t(ctf_arc_lookup_sym_or_name): ... this.  No longer cache\n+\tctf_id_t lookups: just call ctf_lookup_by_symbol as needed (but\n+\tstill cache the dicts those lookups succeed in).  Add\n+\tlookup-by-name support, with dicts of successful lookups cached in\n+\tctfi_symnamedicts.  Refactor the caching code a bit.\n+\t(ctf_arc_lookup_symbol_name): New, another wrapper.\n+\t* ctf-open.c (ctf_dict_close): Free the ctf_symhash.\n+\t* libctf.ver (LIBCTF_1.2): New version.  Add\n+\tctf_lookup_by_symbol_name, ctf_arc_lookup_symbol_name.\n+\t* testsuite/libctf-lookup/enum-symbol.c (main): Use\n+\tctf_arc_lookup_symbol rather than looking up the name ourselves.\n+\tFish it out repeatedly, to make sure that symbol caching isn't\n+\tbroken.\n+\t(symidx_64): Remove.\n+\t(symidx_32): Remove.\n+\t* testsuite/libctf-lookup/enum-symbol-obj.lk: Test symbol lookup\n+\tin an unlinked object file (indexed symtypetab sections only).\n+\t* testsuite/libctf-writable/symtypetab-nonlinker-writeout.c\n+\t(try_maybe_reporting): Check symbol types via\n+\tctf_lookup_by_symbol_name as well as ctf_symbol_next.\n+\t* testsuite/libctf-lookup/conflicting-type-syms.*: New test of\n+\tlookups in a multi-dict archive.\n+\n 2021-02-20  Alan Modra  <amodra@gmail.com>\n \n \t* testsuite/config/default.exp (ld_L_opt): Define."
    },
    {
      "sha": "6d9c75c9013248dd6a3ff3957c8f81e87a078505",
      "filename": "libctf/ctf-archive.c",
      "status": "modified",
      "additions": 134,
      "deletions": 46,
      "changes": 180,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ctf-archive.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ctf-archive.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-archive.c?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -46,8 +46,8 @@ static int arc_mmap_writeout (int fd, void *header, size_t headersz,\n static int arc_mmap_unmap (void *header, size_t headersz, const char **errmsg);\n static void ctf_arc_import_parent (const ctf_archive_t *arc, ctf_dict_t *fp);\n \n-/* Flag to indicate \"symbol not present\" in\n-   ctf_archive_internal.ctfi_symdicts.  Never initialized.  */\n+/* Flag to indicate \"symbol not present\" in ctf_archive_internal.ctfi_symdicts\n+   and ctfi_symnamedicts.  Never initialized.  */\n static ctf_dict_t enosym;\n \n /* Write out a CTF archive to the start of the file referenced by the passed-in\n@@ -529,8 +529,8 @@ ctf_arc_close (ctf_archive_t *arc)\n     }\n   else\n     ctf_dict_close (arc->ctfi_dict);\n-  free (arc->ctfi_syms);\n   free (arc->ctfi_symdicts);\n+  free (arc->ctfi_symnamedicts);\n   ctf_dynhash_destroy (arc->ctfi_dicts);\n   if (arc->ctfi_free_symsect)\n     free ((void *) arc->ctfi_symsect.cts_data);\n@@ -645,8 +645,9 @@ ctf_cached_dict_close (void *fp)\n   ctf_dict_close ((ctf_dict_t *) fp);\n }\n \n-/* Return the ctf_dict_t with the given name and cache it in the\n-   archive's ctfi_dicts.  */\n+/* Return the ctf_dict_t with the given name and cache it in the archive's\n+   ctfi_dicts.  If this is the first cached dict, designate it the\n+   crossdict_cache.  */\n static ctf_dict_t *\n ctf_dict_open_cached (ctf_archive_t *arc, const char *name, int *errp)\n {\n@@ -678,6 +679,9 @@ ctf_dict_open_cached (ctf_archive_t *arc, const char *name, int *errp)\n     goto oom;\n   fp->ctf_refcnt++;\n \n+  if (arc->ctfi_crossdict_cache == NULL)\n+    arc->ctfi_crossdict_cache = fp;\n+\n   return fp;\n \n  oom:\n@@ -693,11 +697,12 @@ void\n ctf_arc_flush_caches (ctf_archive_t *wrapper)\n {\n   free (wrapper->ctfi_symdicts);\n-  free (wrapper->ctfi_syms);\n+  free (wrapper->ctfi_symnamedicts);\n   ctf_dynhash_destroy (wrapper->ctfi_dicts);\n   wrapper->ctfi_symdicts = NULL;\n-  wrapper->ctfi_syms = NULL;\n+  wrapper->ctfi_symnamedicts = NULL;\n   wrapper->ctfi_dicts = NULL;\n+  wrapper->ctfi_crossdict_cache = NULL;\n }\n \n /* Return the ctf_dict_t at the given ctfa_ctfs-relative offset, or NULL if\n@@ -778,31 +783,46 @@ ctf_archive_count (const ctf_archive_t *wrapper)\n   return wrapper->ctfi_archive->ctfa_ndicts;\n }\n \n-/* Look up a symbol in an archive.  Return the dict in the archive that the\n-   symbol is found in, and (optionally) the ctf_id_t of the symbol in that dict\n-   (so you don't have to look it up yourself).  The dict and mapping are both\n-   cached, so repeated lookups are nearly free.\n+/* Look up a symbol in an archive by name or index (if the name is set, a lookup\n+   by name is done).  Return the dict in the archive that the symbol is found\n+   in, and (optionally) the ctf_id_t of the symbol in that dict (so you don't\n+   have to look it up yourself).  The dict is cached, so repeated lookups are\n+   nearly free.\n \n    As usual, you should ctf_dict_close() the returned dict once you are done\n    with it.\n \n    Returns NULL on error, and an error in errp (if set).  */\n \n-ctf_dict_t *\n-ctf_arc_lookup_symbol (ctf_archive_t *wrapper, unsigned long symidx,\n-\t\t       ctf_id_t *typep, int *errp)\n+static ctf_dict_t *\n+ctf_arc_lookup_sym_or_name (ctf_archive_t *wrapper, unsigned long symidx,\n+\t\t\t    const char *symname, ctf_id_t *typep, int *errp)\n {\n   ctf_dict_t *fp;\n+  void *fpkey;\n   ctf_id_t type;\n \n   /* The usual non-archive-transparent-wrapper special case.  */\n   if (!wrapper->ctfi_is_archive)\n     {\n-      if ((type = ctf_lookup_by_symbol (wrapper->ctfi_dict, symidx)) == CTF_ERR)\n+      if (!symname)\n \t{\n-\t  if (errp)\n-\t    *errp = ctf_errno (wrapper->ctfi_dict);\n-\t  return NULL;\n+\t  if ((type = ctf_lookup_by_symbol (wrapper->ctfi_dict, symidx)) == CTF_ERR)\n+\t    {\n+\t      if (errp)\n+\t\t*errp = ctf_errno (wrapper->ctfi_dict);\n+\t      return NULL;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if ((type = ctf_lookup_by_symbol_name (wrapper->ctfi_dict,\n+\t\t\t\t\t\t symname)) == CTF_ERR)\n+\t    {\n+\t      if (errp)\n+\t\t*errp = ctf_errno (wrapper->ctfi_dict);\n+\t      return NULL;\n+\t    }\n \t}\n       if (typep)\n \t*typep = type;\n@@ -820,50 +840,67 @@ ctf_arc_lookup_symbol (ctf_archive_t *wrapper, unsigned long symidx,\n       return NULL;\n     }\n \n-  /* Make enough space for all possible symbols, if not already done.\n-     We cache both the ctf_id_t and the originating dictionary of all symbols.\n-     The dict links are weak, to the dictionaries cached in ctfi_dicts: their\n-     refcnts are *not* bumped.  */\n+  /* Make enough space for all possible symbol indexes, if not already done.  We\n+     cache the originating dictionary of all symbols.  The dict links are weak,\n+     to the dictionaries cached in ctfi_dicts: their refcnts are *not* bumped.\n+     We also cache similar mappings for symbol names: these are ordinary\n+     dynhashes, with weak links to dicts.  */\n \n-  if (!wrapper->ctfi_syms)\n+  if (!wrapper->ctfi_symdicts)\n     {\n-      if ((wrapper->ctfi_syms = calloc (wrapper->ctfi_symsect.cts_size\n-\t\t\t\t\t/ wrapper->ctfi_symsect.cts_entsize,\n-\t\t\t\t\tsizeof (ctf_id_t))) == NULL)\n+      if ((wrapper->ctfi_symdicts = calloc (wrapper->ctfi_symsect.cts_size\n+\t\t\t\t\t    / wrapper->ctfi_symsect.cts_entsize,\n+\t\t\t\t\t    sizeof (ctf_dict_t *))) == NULL)\n \t{\n \t  if (errp)\n \t    *errp = ENOMEM;\n \t  return NULL;\n \t}\n     }\n-  if (!wrapper->ctfi_symdicts)\n+  if (!wrapper->ctfi_symnamedicts)\n     {\n-      if ((wrapper->ctfi_symdicts = calloc (wrapper->ctfi_symsect.cts_size\n-\t\t\t\t\t    / wrapper->ctfi_symsect.cts_entsize,\n-\t\t\t\t\t    sizeof (ctf_dict_t *))) == NULL)\n+      if ((wrapper->ctfi_symnamedicts = ctf_dynhash_create (ctf_hash_string,\n+\t\t\t\t\t\t\t    ctf_hash_eq_string,\n+\t\t\t\t\t\t\t    free, NULL)) == NULL)\n \t{\n \t  if (errp)\n \t    *errp = ENOMEM;\n \t  return NULL;\n \t}\n     }\n \n-  /* Perhaps it's cached.  */\n-  if (wrapper->ctfi_symdicts[symidx] != NULL)\n+  /* Perhaps the dict in which we found a previous lookup is cached.  If it's\n+     supposed to be cached but we don't find it, pretend it was always not\n+     found: this should never happen, but shouldn't be allowed to cause trouble\n+     if it does.  */\n+\n+  if ((symname && ctf_dynhash_lookup_kv (wrapper->ctfi_symnamedicts,\n+\t\t\t\t\t symname, NULL, &fpkey))\n+      || (!symname && wrapper->ctfi_symdicts[symidx] != NULL))\n     {\n-      if (wrapper->ctfi_symdicts[symidx] == &enosym)\n+      if (symname)\n+\tfp = (ctf_dict_t *) fpkey;\n+      else\n+\tfp = wrapper->ctfi_symdicts[symidx];\n+\n+      if (fp == &enosym)\n+\tgoto no_sym;\n+\n+      if (symname)\n \t{\n-\t  if (errp)\n-\t    *errp = ECTF_NOTYPEDAT;\n-\t  if (typep)\n-\t    *typep = CTF_ERR;\n-\t  return NULL;\n+\t  if ((type = ctf_lookup_by_symbol_name (fp, symname)) == CTF_ERR)\n+\t    goto cache_no_sym;\n+\t}\n+      else\n+\t{\n+\t  if ((type = ctf_lookup_by_symbol (fp, symidx)) == CTF_ERR)\n+\t    goto cache_no_sym;\n \t}\n \n       if (typep)\n-\t*typep = wrapper->ctfi_syms[symidx];\n-      wrapper->ctfi_symdicts[symidx]->ctf_refcnt++;\n-      return wrapper->ctfi_symdicts[symidx];\n+\t*typep = type;\n+      fp->ctf_refcnt++;\n+      return fp;\n     }\n \n   /* Not cached: find it and cache it.  We must track open errors ourselves even\n@@ -882,35 +919,86 @@ ctf_arc_lookup_symbol (ctf_archive_t *wrapper, unsigned long symidx,\n \n   while ((fp = ctf_archive_next (wrapper, &i, &name, 0, local_errp)) != NULL)\n     {\n-      if ((type = ctf_lookup_by_symbol (fp, symidx)) != CTF_ERR)\n+      if (!symname)\n \t{\n-\t  wrapper->ctfi_syms[symidx] = type;\n-\t  wrapper->ctfi_symdicts[symidx] = fp;\n-\t  ctf_next_destroy (i);\n+\t  if ((type = ctf_lookup_by_symbol (fp, symidx)) != CTF_ERR)\n+\t    wrapper->ctfi_symdicts[symidx] = fp;\n+\t}\n+      else\n+\t{\n+\t  if ((type = ctf_lookup_by_symbol_name (fp, symname)) != CTF_ERR)\n+\t    {\n+\t      char *tmp;\n+\t      /* No error checking, as above.  */\n+\t      if ((tmp = strdup (symname)) != NULL)\n+\t\tctf_dynhash_insert (wrapper->ctfi_symnamedicts, tmp, fp);\n+\t    }\n+\t}\n \n+      if (type != CTF_ERR)\n+\t{\n \t  if (typep)\n \t    *typep = type;\n+\t  ctf_next_destroy (i);\n \t  return fp;\n \t}\n+      if (ctf_errno (fp) != ECTF_NOTYPEDAT)\n+\t{\n+\t  if (errp)\n+\t    *errp = ctf_errno (fp);\n+\t  ctf_next_destroy (i);\n+\t  return NULL;\t\t\t\t/* errno is set for us.  */\n+\t}\n       ctf_dict_close (fp);\n     }\n   if (*local_errp != ECTF_NEXT_END)\n     {\n       ctf_next_destroy (i);\n       return NULL;\n     }\n+\n   /* Don't leak end-of-iteration to the caller.  */\n   *local_errp = 0;\n \n-  wrapper->ctfi_symdicts[symidx] = &enosym;\n+ cache_no_sym:\n+  if (!symname)\n+    wrapper->ctfi_symdicts[symidx] = &enosym;\n+  else\n+    {\n+      char *tmp;\n+\n+      /* No error checking: if caching fails, there is only a slight performance\n+\t impact.  */\n+      if ((tmp = strdup (symname)) != NULL)\n+\tif (ctf_dynhash_insert (wrapper->ctfi_symnamedicts, tmp, &enosym) < 0)\n+\t  free (tmp);\n+    }\n \n+ no_sym:\n   if (errp)\n     *errp = ECTF_NOTYPEDAT;\n   if (typep)\n     *typep = CTF_ERR;\n   return NULL;\n }\n \n+/* The public API for looking up a symbol by index.  */\n+ctf_dict_t *\n+ctf_arc_lookup_symbol (ctf_archive_t *wrapper, unsigned long symidx,\n+\t\t       ctf_id_t *typep, int *errp)\n+{\n+  return ctf_arc_lookup_sym_or_name (wrapper, symidx, NULL, typep, errp);\n+}\n+\n+/* The public API for looking up a symbol by name. */\n+\n+ctf_dict_t *\n+ctf_arc_lookup_symbol_name (ctf_archive_t *wrapper, const char *symname,\n+\t\t\t    ctf_id_t *typep, int *errp)\n+{\n+  return ctf_arc_lookup_sym_or_name (wrapper, 0, symname, typep, errp);\n+}\n+\n /* Raw iteration over all CTF files in an archive.  We pass the raw data for all\n    CTF files in turn to the specified callback function.  */\n static int"
    },
    {
      "sha": "a6e1da58930ed232e1e080ae4682527b706b8bf4",
      "filename": "libctf/ctf-impl.h",
      "status": "modified",
      "additions": 4,
      "deletions": 2,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ctf-impl.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ctf-impl.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-impl.h?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -382,6 +382,8 @@ struct ctf_dict\n   ctf_sect_t ctf_symtab;\t    /* Symbol table from object file.  */\n   ctf_sect_t ctf_strtab;\t    /* String table from object file.  */\n   int ctf_symsect_little_endian;    /* Endianness of the ctf_symtab.  */\n+  ctf_dynhash_t *ctf_symhash;       /* (partial) hash, symsect name -> idx. */\n+  size_t ctf_symhash_latest;\t    /* Amount of symsect scanned so far.  */\n   ctf_dynhash_t *ctf_prov_strtab;   /* Maps provisional-strtab offsets\n \t\t\t\t       to names.  */\n   ctf_dynhash_t *ctf_syn_ext_strtab; /* Maps ext-strtab offsets to names.  */\n@@ -508,8 +510,9 @@ struct ctf_archive_internal\n   ctf_dict_t *ctfi_dict;\n   struct ctf_archive *ctfi_archive;\n   ctf_dynhash_t *ctfi_dicts;\t  /* Dicts we have opened and cached.  */\n+  ctf_dict_t *ctfi_crossdict_cache; /* Cross-dict caching.  */\n   ctf_dict_t **ctfi_symdicts;\t  /* Array of index -> ctf_dict_t *.  */\n-  ctf_id_t *ctfi_syms;\t\t  /* Array of index -> ctf_id_t.  */\n+  ctf_dynhash_t *ctfi_symnamedicts; /* Hash of name -> ctf_dict_t *.  */\n   ctf_sect_t ctfi_symsect;\n   int ctfi_symsect_little_endian; /* -1 for unknown / do not set.  */\n   ctf_sect_t ctfi_strsect;\n@@ -784,7 +787,6 @@ extern ctf_link_sym_t *ctf_elf32_to_link_sym (ctf_dict_t *fp, ctf_link_sym_t *ds\n \t\t\t\t\t      const Elf32_Sym *src, uint32_t symidx);\n extern ctf_link_sym_t *ctf_elf64_to_link_sym (ctf_dict_t *fp, ctf_link_sym_t *dst,\n \t\t\t\t\t      const Elf64_Sym *src, uint32_t symidx);\n-extern const char *ctf_lookup_symbol_name (ctf_dict_t *fp, unsigned long symidx);\n \n /* Variables, all underscore-prepended. */\n "
    },
    {
      "sha": "6e17e5f4c54e6e7c5658e61dfce8cc48f75a5a4c",
      "filename": "libctf/ctf-lookup.c",
      "status": "modified",
      "additions": 202,
      "deletions": 30,
      "changes": 232,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ctf-lookup.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ctf-lookup.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-lookup.c?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -459,7 +459,7 @@ ctf_symidx_sort (ctf_dict_t *fp, uint32_t *idx, size_t *nidx,\n /* Given a symbol index, return the name of that symbol from the table provided\n    by ctf_link_shuffle_syms, or failing that from the secondary string table, or\n    the null string.  */\n-const char *\n+static const char *\n ctf_lookup_symbol_name (ctf_dict_t *fp, unsigned long symidx)\n {\n   const ctf_sect_t *sp = &fp->ctf_symtab;\n@@ -512,14 +512,130 @@ ctf_lookup_symbol_name (ctf_dict_t *fp, unsigned long symidx)\n \n  try_parent:\n   if (fp->ctf_parent)\n-    return ctf_lookup_symbol_name (fp->ctf_parent, symidx);\n+    {\n+      const char *ret;\n+      ret = ctf_lookup_symbol_name (fp->ctf_parent, symidx);\n+      if (ret == NULL)\n+\tctf_set_errno (fp, ctf_errno (fp->ctf_parent));\n+      return ret;\n+    }\n   else\n     {\n       ctf_set_errno (fp, err);\n       return _CTF_NULLSTR;\n     }\n }\n \n+/* Given a symbol name, return the index of that symbol, or -1 on error or if\n+   not found.  */\n+static unsigned long\n+ctf_lookup_symbol_idx (ctf_dict_t *fp, const char *symname)\n+{\n+  const ctf_sect_t *sp = &fp->ctf_symtab;\n+  ctf_link_sym_t sym;\n+  void *known_idx;\n+  int err;\n+  ctf_dict_t *cache = fp;\n+\n+  if (fp->ctf_dynsyms)\n+    {\n+      err = EINVAL;\n+\n+      ctf_link_sym_t *symp;\n+\n+      if ((symp = ctf_dynhash_lookup (fp->ctf_dynsyms, symname)) == NULL)\n+\tgoto try_parent;\n+\n+      return symp->st_symidx;\n+    }\n+\n+  err = ECTF_NOSYMTAB;\n+  if (sp->cts_data == NULL)\n+    goto try_parent;\n+\n+  /* First, try a hash lookup to see if we have already spotted this symbol\n+     during a past iteration: create the hash first if need be.  The lifespan\n+     of the strings is equal to the lifespan of the cts_data, so we don't\n+     need to strdup them.  If this dict was opened as part of an archive,\n+     and this archive has designed a crossdict_cache to cache results that\n+     are the same across all dicts in an archive, use it.  */\n+\n+  if (fp->ctf_archive && fp->ctf_archive->ctfi_crossdict_cache)\n+    cache = fp->ctf_archive->ctfi_crossdict_cache;\n+\n+  if (!cache->ctf_symhash)\n+    if ((cache->ctf_symhash = ctf_dynhash_create (ctf_hash_string,\n+\t\t\t\t\t\t  ctf_hash_eq_string,\n+\t\t\t\t\t\t  NULL, NULL)) == NULL)\n+      goto oom;\n+\n+  if (ctf_dynhash_lookup_kv (cache->ctf_symhash, symname, NULL, &known_idx))\n+    return (unsigned long) (uintptr_t) known_idx;\n+\n+  /* Hash lookup unsuccessful: linear search, populating the hashtab for later\n+     lookups as we go.  */\n+\n+  for (; cache->ctf_symhash_latest < sp->cts_size / sp->cts_entsize;\n+       cache->ctf_symhash_latest++)\n+    {\n+      switch (sp->cts_entsize)\n+\t{\n+\tcase sizeof (Elf64_Sym):\n+\t  {\n+\t    Elf64_Sym *symp = (Elf64_Sym *) sp->cts_data;\n+\t    ctf_elf64_to_link_sym (fp, &sym, &symp[cache->ctf_symhash_latest],\n+\t\t\t\t   cache->ctf_symhash_latest);\n+\t    if (!ctf_dynhash_lookup_kv (cache->ctf_symhash, sym.st_name,\n+\t\t\t\t\tNULL, NULL))\n+\t      if (ctf_dynhash_cinsert (cache->ctf_symhash, sym.st_name,\n+\t\t\t\t       (const void *) (uintptr_t)\n+\t\t\t\t       cache->ctf_symhash_latest) < 0)\n+\t\tgoto oom;\n+\t    if (strcmp (sym.st_name, symname) == 0)\n+              return cache->ctf_symhash_latest++;\n+          }\n+          break;\n+\tcase sizeof (Elf32_Sym):\n+\t  {\n+\t    Elf32_Sym *symp = (Elf32_Sym *) sp->cts_data;\n+\t    ctf_elf32_to_link_sym (fp, &sym, &symp[cache->ctf_symhash_latest],\n+\t\t\t\t   cache->ctf_symhash_latest);\n+\t    if (!ctf_dynhash_lookup_kv (cache->ctf_symhash, sym.st_name,\n+\t\t\t\t\tNULL, NULL))\n+\t      if (ctf_dynhash_cinsert (cache->ctf_symhash, sym.st_name,\n+\t\t\t\t       (const void *) (uintptr_t)\n+\t\t\t\t       cache->ctf_symhash_latest) < 0)\n+\t\tgoto oom;\n+\t    if (strcmp (sym.st_name, symname) == 0)\n+              return cache->ctf_symhash_latest++;\n+          }\n+\t  break;\n+\tdefault:\n+\t  ctf_set_errno (fp, ECTF_SYMTAB);\n+\t  return (unsigned long) -1;\n+\t}\n+    }\n+\n+  /* Searched everything, still not found.  */\n+\n+  return (unsigned long) -1;\n+\n+ try_parent:\n+  if (fp->ctf_parent)\n+    return ctf_lookup_symbol_idx (fp->ctf_parent, symname);\n+  else\n+    {\n+      ctf_set_errno (fp, err);\n+      return (unsigned long) -1;\n+    }\n+oom:\n+  ctf_set_errno (fp, ENOMEM);\n+  ctf_err_warn (fp, 0, ENOMEM, _(\"cannot allocate memory for symbol \"\n+\t\t\t\t \"lookup hashtab\"));\n+  return (unsigned long) -1;\n+\n+}\n+\n /* Iterate over all symbols with types: if FUNC, function symbols, otherwise,\n    data symbols.  The name argument is not optional.  The return order is\n    arbitrary, though is likely to be in symbol index or name order.  You can\n@@ -664,20 +780,24 @@ ctf_lookup_idx_name (const void *key_, const void *idx_)\n   return (strcmp (key->clik_name, ctf_strptr (key->clik_fp, key->clik_names[*idx])));\n }\n \n-/* Given a symbol number, look up that symbol in the function or object\n-   index table (which must exist).  Return 0 if not found there (or pad).  */\n+/* Given a symbol name or (failing that) number, look up that symbol in the\n+   function or object index table (which must exist).  Return 0 if not found\n+   there (or pad).  */\n \n static ctf_id_t\n-ctf_try_lookup_indexed (ctf_dict_t *fp, unsigned long symidx, int is_function)\n+ctf_try_lookup_indexed (ctf_dict_t *fp, unsigned long symidx,\n+\t\t\tconst char *symname, int is_function)\n {\n-  const char *symname = ctf_lookup_symbol_name (fp, symidx);\n   struct ctf_header *hp = fp->ctf_header;\n   uint32_t *symtypetab;\n   uint32_t *names;\n   uint32_t *sxlate;\n   size_t nidx;\n \n-  ctf_dprintf (\"Looking up type of object with symtab idx %lx (%s) in \"\n+  if (symname == NULL)\n+    symname = ctf_lookup_symbol_name (fp, symidx);\n+\n+  ctf_dprintf (\"Looking up type of object with symtab idx %lx or name %s in \"\n \t       \"indexed symtypetab\\n\", symidx, symname);\n \n   if (symname[0] == '\\0')\n@@ -745,13 +865,15 @@ ctf_try_lookup_indexed (ctf_dict_t *fp, unsigned long symidx, int is_function)\n   return symtypetab[*idx];\n }\n \n-/* Given a symbol table index, return the type of the function or data object\n-   described by the corresponding entry in the symbol table.  We can only return\n-   symbols in read-only dicts and in dicts for which ctf_link_shuffle_syms has\n-   been called to assign symbol indexes to symbol names.  */\n+/* Given a symbol name or (if NULL) symbol index, return the type of the\n+   function or data object described by the corresponding entry in the symbol\n+   table.  We can only return symbols in read-only dicts and in dicts for which\n+   ctf_link_shuffle_syms has been called to assign symbol indexes to symbol\n+   names.  */\n \n-ctf_id_t\n-ctf_lookup_by_symbol (ctf_dict_t *fp, unsigned long symidx)\n+static ctf_id_t\n+ctf_lookup_by_sym_or_name (ctf_dict_t *fp, unsigned long symidx,\n+\t\t\t   const char *symname)\n {\n   const ctf_sect_t *sp = &fp->ctf_symtab;\n   ctf_id_t type = 0;\n@@ -762,56 +884,80 @@ ctf_lookup_by_symbol (ctf_dict_t *fp, unsigned long symidx)\n     {\n       const ctf_link_sym_t *sym;\n \n-      ctf_dprintf (\"Looking up type of object with symtab idx %lx in \"\n-\t\t   \"writable dict symtypetab\\n\", symidx);\n+      if (symname)\n+\tctf_dprintf (\"Looking up type of object with symname %s in \"\n+\t\t     \"writable dict symtypetab\\n\", symname);\n+      else\n+\tctf_dprintf (\"Looking up type of object with symtab idx %lx in \"\n+\t\t     \"writable dict symtypetab\\n\", symidx);\n \n       /* The dict must be dynamic.  */\n       if (!ctf_assert (fp, fp->ctf_flags & LCTF_RDWR))\n \treturn CTF_ERR;\n \n-      err = EINVAL;\n-      if (symidx > fp->ctf_dynsymmax)\n-\tgoto try_parent;\n+      /* No name? Need to look it up.  */\n+      if (!symname)\n+\t{\n+\t  err = EINVAL;\n+\t  if (symidx > fp->ctf_dynsymmax)\n+\t    goto try_parent;\n \n-      sym = fp->ctf_dynsymidx[symidx];\n-      err = ECTF_NOTYPEDAT;\n-      if (!sym || (sym->st_shndx != STT_OBJECT && sym->st_shndx != STT_FUNC))\n-\tgoto try_parent;\n+          sym = fp->ctf_dynsymidx[symidx];\n+\t  err = ECTF_NOTYPEDAT;\n+\t  if (!sym || (sym->st_shndx != STT_OBJECT && sym->st_shndx != STT_FUNC))\n+\t    goto try_parent;\n \n-      if (!ctf_assert (fp, !sym->st_nameidx_set))\n-\treturn CTF_ERR;\n+\t  if (!ctf_assert (fp, !sym->st_nameidx_set))\n+\t    return CTF_ERR;\n+\t  symname = sym->st_name;\n+     }\n \n       if (fp->ctf_objthash == NULL\n \t  || ((type = (ctf_id_t) (uintptr_t)\n-\t       ctf_dynhash_lookup (fp->ctf_objthash, sym->st_name)) == 0))\n+\t       ctf_dynhash_lookup (fp->ctf_objthash, symname)) == 0))\n \t{\n \t  if (fp->ctf_funchash == NULL\n \t      || ((type = (ctf_id_t) (uintptr_t)\n-\t\t   ctf_dynhash_lookup (fp->ctf_funchash, sym->st_name)) == 0))\n+\t\t   ctf_dynhash_lookup (fp->ctf_funchash, symname)) == 0))\n \t    goto try_parent;\n \t}\n \n       return type;\n     }\n \n+  /* Lookup by name in a dynamic dict: just do it directly.  */\n+  if (symname && fp->ctf_flags & LCTF_RDWR)\n+    {\n+      if (fp->ctf_objthash == NULL\n+\t  || ((type = (ctf_id_t) (uintptr_t)\n+\t       ctf_dynhash_lookup (fp->ctf_objthash, symname)) == 0))\n+\t{\n+\t  if (fp->ctf_funchash == NULL\n+\t      || ((type = (ctf_id_t) (uintptr_t)\n+\t\t   ctf_dynhash_lookup (fp->ctf_funchash, symname)) == 0))\n+\t    goto try_parent;\n+\t}\n+      return type;\n+    }\n+\n   err = ECTF_NOSYMTAB;\n   if (sp->cts_data == NULL)\n     goto try_parent;\n \n   /* This covers both out-of-range lookups and a dynamic dict which hasn't been\n      shuffled yet.  */\n   err = EINVAL;\n-  if (symidx >= fp->ctf_nsyms)\n+  if (symname == NULL && symidx >= fp->ctf_nsyms)\n     goto try_parent;\n \n   if (fp->ctf_objtidx_names)\n     {\n-      if ((type = ctf_try_lookup_indexed (fp, symidx, 0)) == CTF_ERR)\n+      if ((type = ctf_try_lookup_indexed (fp, symidx, symname, 0)) == CTF_ERR)\n \treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n     }\n   if (type == 0 && fp->ctf_funcidx_names)\n     {\n-      if ((type = ctf_try_lookup_indexed (fp, symidx, 1)) == CTF_ERR)\n+      if ((type = ctf_try_lookup_indexed (fp, symidx, symname, 1)) == CTF_ERR)\n \treturn CTF_ERR;\t\t\t\t/* errno is set for us.  */\n     }\n   if (type != 0)\n@@ -825,6 +971,10 @@ ctf_lookup_by_symbol (ctf_dict_t *fp, unsigned long symidx)\n \n   ctf_dprintf (\"Looking up object type %lx in 1:1 dict symtypetab\\n\", symidx);\n \n+  if (symname != NULL)\n+    if ((symidx = ctf_lookup_symbol_idx (fp, symname)) == (unsigned long) -1)\n+      goto try_parent;\n+\n   if (fp->ctf_sxlate[symidx] == -1u)\n     goto try_parent;\n \n@@ -836,11 +986,33 @@ ctf_lookup_by_symbol (ctf_dict_t *fp, unsigned long symidx)\n   return type;\n  try_parent:\n   if (fp->ctf_parent)\n-    return ctf_lookup_by_symbol (fp->ctf_parent, symidx);\n+    {\n+      ctf_id_t ret = ctf_lookup_by_sym_or_name (fp->ctf_parent, symidx,\n+\t\t\t\t\t\tsymname);\n+      if (ret == CTF_ERR)\n+\tctf_set_errno (fp, ctf_errno (fp->ctf_parent));\n+      return ret;\n+    }\n   else\n     return (ctf_set_errno (fp, err));\n }\n \n+/* Given a symbol table index, return the type of the function or data object\n+   described by the corresponding entry in the symbol table.  */\n+ctf_id_t\n+ctf_lookup_by_symbol (ctf_dict_t *fp, unsigned long symidx)\n+{\n+  return ctf_lookup_by_sym_or_name (fp, symidx, NULL);\n+}\n+\n+/* Given a symbol name, return the type of the function or data object described\n+   by the corresponding entry in the symbol table.  */\n+ctf_id_t\n+ctf_lookup_by_symbol_name (ctf_dict_t *fp, const char *symname)\n+{\n+  return ctf_lookup_by_sym_or_name (fp, 0, symname);\n+}\n+\n /* Given a symbol table index, return the info for the function described\n    by the corresponding entry in the symbol table, which may be a function\n    symbol or may be a data symbol that happens to be a function pointer.  */"
    },
    {
      "sha": "c2d9a33555a8e5847eca0e3f5e77a9bf6a59e1fe",
      "filename": "libctf/ctf-open.c",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ctf-open.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/ctf-open.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/ctf-open.c?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -1737,6 +1737,7 @@ ctf_dict_close (ctf_dict_t *fp)\n     }\n   ctf_dynhash_destroy (fp->ctf_dvhash);\n \n+  ctf_dynhash_destroy (fp->ctf_symhash);\n   free (fp->ctf_funcidx_sxlate);\n   free (fp->ctf_objtidx_sxlate);\n   ctf_dynhash_destroy (fp->ctf_objthash);"
    },
    {
      "sha": "8c362f3c39e07725524cc0110e88538eb503ffcc",
      "filename": "libctf/libctf.ver",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/libctf.ver",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/libctf.ver",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/libctf.ver?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -196,3 +196,9 @@ LIBCTF_1.1 {\n \tctf_symsect_endianness;\n \tctf_arc_symsect_endianness;\n } LIBCTF_1.0;\n+\n+LIBCTF_1.2 {\n+    global:\n+\tctf_lookup_by_symbol_name;\n+\tctf_arc_lookup_symbol_name;\n+} LIBCTF_1.1;"
    },
    {
      "sha": "654148771149bae5a4160255feee21306c03934d",
      "filename": "libctf/testsuite/libctf-lookup/conflicting-type-syms-a.c",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/conflicting-type-syms-a.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/conflicting-type-syms-a.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-lookup/conflicting-type-syms-a.c?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -0,0 +1,5 @@\n+typedef long a_t;\n+typedef long b_t;\n+\n+a_t *a;\n+b_t ignore2;"
    },
    {
      "sha": "e458021efb13b4b2bff65e9fe30b258030a6dd9d",
      "filename": "libctf/testsuite/libctf-lookup/conflicting-type-syms-b.c",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/conflicting-type-syms-b.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/conflicting-type-syms-b.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-lookup/conflicting-type-syms-b.c?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -0,0 +1,5 @@\n+typedef long a_t;\n+typedef long b_t;\n+\n+a_t b;\n+b_t ignore1;"
    },
    {
      "sha": "ffe6983e250598defb5b8ff9cecb10bed86236e8",
      "filename": "libctf/testsuite/libctf-lookup/conflicting-type-syms.c",
      "status": "added",
      "additions": 99,
      "deletions": 0,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/conflicting-type-syms.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/conflicting-type-syms.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-lookup/conflicting-type-syms.c?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -0,0 +1,99 @@\n+#include \"config.h\"\n+#include <ctf-api.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  ctf_archive_t *ctf;\n+  ctf_dict_t *a_fp, *ignore1_fp, *b_fp, *ignore2_fp, *tmp_fp;\n+  int err;\n+  ctf_id_t a, b, ignore1, ignore2, tmp;\n+  char *foo;\n+  ctf_next_t *i = NULL;\n+  const char *name;\n+  int val;\n+\n+  if (argc != 2)\n+    {\n+      fprintf (stderr, \"Syntax: %s PROGRAM\\n\", argv[0]);\n+      exit(1);\n+    }\n+\n+  if ((ctf = ctf_open (argv[1], NULL, &err)) == NULL)\n+    goto open_err;\n+\n+  /* Fish out each symbol in turn: also try to fish out a nonexistent one.  */\n+\n+  if ((a_fp = ctf_arc_lookup_symbol_name (ctf, \"a\", &a, &err)) == NULL)\n+    goto sym_err;\n+  printf (\"Type of a is %s\\n\", foo = ctf_type_aname (a_fp, a));\n+\n+  if ((b_fp = ctf_arc_lookup_symbol_name (ctf, \"b\", &b, &err)) == NULL)\n+    goto sym_err;\n+  printf (\"Type of b is %s\\n\", foo = ctf_type_aname (b_fp, b));\n+\n+  if ((ignore1_fp = ctf_arc_lookup_symbol_name (ctf, \"ignore1\", &ignore1, &err)) == NULL)\n+    goto sym_err;\n+  printf (\"Type of ignore1 is %s\\n\", foo = ctf_type_aname (ignore1_fp, ignore1));\n+\n+  if ((ignore2_fp = ctf_arc_lookup_symbol_name (ctf, \"ignore2\", &ignore2, &err)) == NULL)\n+    goto sym_err;\n+  printf (\"Type of ignore2 is %s\\n\", foo = ctf_type_aname (ignore2_fp, ignore1));\n+\n+  /* Try a call in just-get-the-dict mode and make sure it doesn't fail.  */\n+  if ((tmp_fp = ctf_arc_lookup_symbol_name (ctf, \"ignore2\", NULL, &err)) == NULL)\n+    goto sym_err;\n+  ctf_dict_close (tmp_fp);\n+\n+  /* Make sure failures fail.  */\n+  if  ((ctf_arc_lookup_symbol_name (ctf, \"nonexistent\", NULL, &err) != NULL)\n+       || err != ECTF_NOTYPEDAT)\n+    goto nosym_err;\n+\n+  /* Fish them out again to check the caching layer.  */\n+  if (((tmp_fp = ctf_arc_lookup_symbol_name (ctf, \"a\", &tmp, &err)) != a_fp)\n+      || (tmp != a))\n+    goto sym_cache_err;\n+  ctf_dict_close (tmp_fp);\n+\n+  if (((tmp_fp = ctf_arc_lookup_symbol_name (ctf, \"b\", &tmp, &err)) != b_fp)\n+      || (tmp != b))\n+    goto sym_cache_err;\n+  ctf_dict_close (tmp_fp);\n+\n+  if (((tmp_fp = ctf_arc_lookup_symbol_name (ctf, \"ignore1\", &tmp, &err)) != ignore1_fp)\n+      || (tmp != ignore1))\n+    goto sym_cache_err;\n+  ctf_dict_close (tmp_fp);\n+\n+  if (((tmp_fp = ctf_arc_lookup_symbol_name (ctf, \"ignore2\", &tmp, &err)) != ignore2_fp)\n+      || (tmp != ignore2))\n+    goto sym_cache_err;\n+  ctf_dict_close (tmp_fp);\n+\n+  ctf_dict_close (a_fp);\n+  ctf_dict_close (b_fp);\n+  ctf_dict_close (ignore1_fp);\n+  ctf_dict_close (ignore2_fp);\n+  ctf_close (ctf);\n+\n+  return 0;\n+\n+ open_err:\n+  fprintf (stderr, \"%s: cannot open: %s\\n\", argv[0], ctf_errmsg (err));\n+  return 1;\n+ sym_err:\n+  fprintf (stderr, \"%s: Symbol lookup error: %s\\n\", argv[0], ctf_errmsg (err));\n+  return 1;\n+ nosym_err:\n+  fprintf (stderr, \"%s: Nonexistent symbol lookup unexpected error: %s\\n\", argv[0],\n+\t   ctf_errmsg (err));\n+  return 1;\n+ sym_cache_err:\n+  fprintf (stderr, \"%s: Symbol re-lookup error (caching bug): %s\\n\", argv[0],\n+\t   ctf_errmsg (err));\n+  return 1;\n+}"
    },
    {
      "sha": "09b41dfd623034d685d9529cb2cd9c1060d7c0f2",
      "filename": "libctf/testsuite/libctf-lookup/conflicting-type-syms.lk",
      "status": "added",
      "additions": 7,
      "deletions": 0,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/conflicting-type-syms.lk",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/conflicting-type-syms.lk",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-lookup/conflicting-type-syms.lk?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -0,0 +1,7 @@\n+# lookup: conflicting-type-syms.c\n+# source: conflicting-type-syms-a.c\n+# source: conflicting-type-syms-b.c\n+Type of a is a_t \\*\n+Type of b is a_t\n+Type of ignore1 is b_t\n+Type of ignore2 is b_t"
    },
    {
      "sha": "548d67b70c63e028ba58cf350f026b3449b0d66d",
      "filename": "libctf/testsuite/libctf-lookup/enum-symbol-obj.lk",
      "status": "added",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/enum-symbol-obj.lk",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/enum-symbol-obj.lk",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-lookup/enum-symbol-obj.lk?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -0,0 +1,5 @@\n+# lookup: enum-symbol.c\n+# source: enum-symbol-ctf.c\n+red1 has value 0\n+green1 has value 1\n+blue1 has value 2"
    },
    {
      "sha": "c67478fe780f3d2b2082089da80e5aca40526ba0",
      "filename": "libctf/testsuite/libctf-lookup/enum-symbol.c",
      "status": "modified",
      "additions": 14,
      "deletions": 101,
      "changes": 115,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/enum-symbol.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-lookup/enum-symbol.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-lookup/enum-symbol.c?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -1,125 +1,32 @@\n #include \"config.h\"\n-#include <bfd.h>\n-#include <elf.h>\n #include <ctf-api.h>\n-#include <swap.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <string.h>\n \n-ssize_t symidx_64 (ctf_sect_t *s, ctf_sect_t *strsect, int little_endian, const char *name)\n-{\n-  const char *strs = (const char *) strsect->cts_data;\n-  size_t i;\n-  Elf64_Sym *sym = (Elf64_Sym *) s->cts_data;\n-  for (i = 0; i < s->cts_size / s->cts_entsize; i++, sym++)\n-    {\n-      Elf64_Word nameoff = sym->st_name;\n-#ifdef WORDS_BIGENDIAN\n-      if (little_endian)\n-\tswap_thing (nameoff);\n-#else\n-      if (!little_endian)\n-\tswap_thing (nameoff);\n-#endif\n-      if (strcmp (strs + nameoff, name) == 0)\n-\treturn i;\n-    }\n-  return -1;\n-}\n-\n-ssize_t symidx_32 (ctf_sect_t *s, ctf_sect_t *strsect, int little_endian, const char *name)\n-{\n-  const char *strs = (const char *) strsect->cts_data;\n-  size_t i;\n-  Elf32_Sym *sym = (Elf32_Sym *) s->cts_data;\n-  for (i = 0; i < s->cts_size / s->cts_entsize; i++, sym++)\n-    {\n-      Elf32_Word nameoff = sym->st_name;\n-#ifdef WORDS_BIGENDIAN\n-      if (little_endian)\n-\tswap_thing (nameoff);\n-#else\n-      if (!little_endian)\n-\tswap_thing (nameoff);\n-#endif\n-      if (strcmp (strs + nameoff, name) == 0)\n-\treturn i;\n-    }\n-  return -1;\n-}\n-\n int\n main (int argc, char *argv[])\n {\n-  ctf_dict_t *fp;\n-  bfd *abfd;\n   ctf_archive_t *ctf;\n-  ctf_sect_t symsect;\n-  ctf_sect_t strsect;\n-  ssize_t symidx;\n+  ctf_dict_t *fp, *tmp_fp;\n   int err;\n-  ctf_id_t type;\n+  ctf_id_t type, tmp;\n   ctf_next_t *i = NULL;\n   const char *name;\n   int val;\n-  int little_endian;\n-\n-  ssize_t (*get_sym) (ctf_sect_t *s, ctf_sect_t *strsect, int little_endian, const char *name);\n \n   if (argc != 2)\n     {\n       fprintf (stderr, \"Syntax: %s PROGRAM\\n\", argv[0]);\n       exit(1);\n     }\n \n-  /* Figure out the endianness of the symtab(s).  */\n-  if ((abfd = bfd_openr (argv[1], NULL)) == NULL\n-      || !bfd_check_format (abfd, bfd_object))\n-    goto bfd_open_err;\n-  little_endian = bfd_little_endian (abfd);\n-  bfd_close_all_done (abfd);\n-\n   if ((ctf = ctf_open (argv[1], NULL, &err)) == NULL)\n     goto open_err;\n \n-  if ((fp = ctf_dict_open (ctf, NULL, &err)) == NULL)\n-    goto open_err;\n-\n-  symsect = ctf_getsymsect (fp);\n-  strsect = ctf_getstrsect (fp);\n-  if (symsect.cts_data == NULL\n-      || strsect.cts_data == NULL)\n-    {\n-      fprintf (stderr, \"%s: no symtab or strtab\\n\", argv[0]);\n-      return 1;\n-    }\n-\n-  ctf_dict_close (fp);\n-\n-  if (symsect.cts_entsize != sizeof (Elf64_Sym) &&\n-      symsect.cts_entsize != sizeof (Elf32_Sym))\n-    {\n-      fprintf (stderr, \"%s: unknown symsize: %lx\\n\", argv[0],\n-\t       symsect.cts_size);\n-      return 1;\n-    }\n-\n-  switch (symsect.cts_entsize)\n-    {\n-    case sizeof (Elf64_Sym): get_sym = symidx_64; break;\n-    case sizeof (Elf32_Sym): get_sym = symidx_32; break;\n-    }\n-\n-  if ((symidx = get_sym (&symsect, &strsect, little_endian, \"primary1\")) < 0)\n-    {\n-      fprintf (stderr, \"%s: symbol not found: primary1\\n\", argv[0]);\n-      return 1;\n-    }\n-\n-  /* Fish it out, then fish out all its enumerand/value pairs.  */\n+  /* Fish out the enumerator, then fish out all its enumerand/value pairs.  */\n \n-  if ((fp = ctf_arc_lookup_symbol (ctf, symidx, &type, &err)) == NULL)\n+  if ((fp = ctf_arc_lookup_symbol_name (ctf, \"primary1\", &type, &err)) == NULL)\n     goto sym_err;\n \n   while ((name = ctf_enum_next (fp, type, &i, &val)) != NULL)\n@@ -129,21 +36,27 @@ main (int argc, char *argv[])\n   if (ctf_errno (fp) != ECTF_NEXT_END)\n     goto nerr;\n \n+  /* Fish it out again to check the caching layer.  */\n+  if (((tmp_fp = ctf_arc_lookup_symbol_name (ctf, \"primary1\", &tmp, &err)) != fp)\n+      || (tmp != type))\n+    goto sym_cache_err;\n+\n+  ctf_dict_close (tmp_fp);\n   ctf_dict_close (fp);\n   ctf_close (ctf);\n \n   return 0;\n \n- bfd_open_err:\n-  fprintf (stderr, \"%s: cannot open: %s\\n\", argv[0], bfd_errmsg (bfd_get_error ()));\n-  return 1;\n-\n  open_err:\n   fprintf (stderr, \"%s: cannot open: %s\\n\", argv[0], ctf_errmsg (err));\n   return 1;\n  sym_err:\n   fprintf (stderr, \"%s: Symbol lookup error: %s\\n\", argv[0], ctf_errmsg (err));\n   return 1;\n+ sym_cache_err:\n+  fprintf (stderr, \"%s: Symbol re-lookup error (caching bug): %s\\n\", argv[0],\n+\t   ctf_errmsg (err));\n+  return 1;\n  err:\n   fprintf (stderr, \"Lookup failed: %s\\n\", ctf_errmsg (ctf_errno (fp)));\n   return 1;"
    },
    {
      "sha": "98144de639130584a5208846bf2d198c21d7ecc9",
      "filename": "libctf/testsuite/libctf-writable/symtypetab-nonlinker-writeout.c",
      "status": "modified",
      "additions": 34,
      "deletions": 0,
      "changes": 34,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-writable/symtypetab-nonlinker-writeout.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/f4f60336daee74c094474e4da7b88c4a8b75a49e/libctf/testsuite/libctf-writable/symtypetab-nonlinker-writeout.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/libctf/testsuite/libctf-writable/symtypetab-nonlinker-writeout.c?ref=f4f60336daee74c094474e4da7b88c4a8b75a49e",
      "patch": "@@ -98,6 +98,21 @@ try_maybe_reporting (int report)\n   if (ctf_errno (fp) != ECTF_NEXT_END)\n     goto iter_err;\n \n+  /* Look up all the symbols by name and make sure that works.  */\n+\n+  if (ctf_lookup_by_symbol_name (fp, \"data_a\") != base2)\n+    goto lookup_syms_err;\n+  if (ctf_lookup_by_symbol_name (fp, \"data_b\") != base3)\n+    goto lookup_syms_err;\n+  if (ctf_lookup_by_symbol_name (fp, \"data_c\") != base)\n+    goto lookup_syms_err;\n+  if (ctf_lookup_by_symbol_name (fp, \"func_a\") != func2)\n+    goto lookup_syms_err;\n+  if (ctf_lookup_by_symbol_name (fp, \"func_b\") != func3)\n+    goto lookup_syms_err;\n+  if (ctf_lookup_by_symbol_name (fp, \"func_c\") != func)\n+    goto lookup_syms_err;\n+\n   /* Possibly report some but not all of the symbols, as if we are a linker (no\n      real program would do this without using the ctf_link APIs, but it's not\n      *prohibited*, just useless, and if they do we don't want things to\n@@ -121,6 +136,21 @@ try_maybe_reporting (int report)\n       if (report_sym (fp, &sym, \"func_c\", 4, 2) < 0 ||\n \t  report_sym (fp, &sym, \"func_a\", 5, 2) < 0)\n \tgoto report_err;\n+\n+      /* Look up all the symbols by name now we have reported symbols.  */\n+\n+      if (ctf_lookup_by_symbol_name (fp, \"data_a\") != base2)\n+\tgoto lookup_syms_err;\n+      if (ctf_lookup_by_symbol_name (fp, \"data_b\") != base3)\n+\tgoto lookup_syms_err;\n+      if (ctf_lookup_by_symbol_name (fp, \"data_c\") != base)\n+\tgoto lookup_syms_err;\n+      if (ctf_lookup_by_symbol_name (fp, \"func_a\") != func2)\n+\tgoto lookup_syms_err;\n+      if (ctf_lookup_by_symbol_name (fp, \"func_b\") != func3)\n+\tgoto lookup_syms_err;\n+      if (ctf_lookup_by_symbol_name (fp, \"func_c\") != func)\n+\tgoto lookup_syms_err;\n     }\n \n   /* Write out, to memory.  */\n@@ -203,6 +233,10 @@ try_maybe_reporting (int report)\n  expected_overshoot_err:\n   fprintf (stderr, \"Too many symbols in post-writeout comparison\\n\");\n   exit (1);\n+ lookup_syms_err:\n+  fprintf (stderr, \"Explicit lookup of symbols by name failed: %s\\n\",\n+\t   ctf_errmsg (ctf_errno (fp)));\n+  exit (1);\n  expected_compar_err:\n   fprintf (stderr, \"Non-dynamic iteration comparison failure: %s \"\n \t   \"(type %lx): expected %s (type %lx)\\n\", symname, symtype,"
    }
  ]
}