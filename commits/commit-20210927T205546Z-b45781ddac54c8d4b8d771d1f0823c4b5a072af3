{
  "sha": "b45781ddac54c8d4b8d771d1f0823c4b5a072af3",
  "node_id": "C_kwDOANOeidoAKGI0NTc4MWRkYWM1NGM4ZDRiOGQ3NzFkMWYwODIzYzRiNWEwNzJhZjM",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-09-10T20:42:52Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2021-09-27T20:55:46Z"
    },
    "message": "gdb.base/foll-fork.exp: refactor to restart GDB between each portion of the test\n\nThis test is difficult to follow and modify because the state of GDB is\npreserved some tests.  Add a setup proc, which starts a new GDB and runs\nto main, and use it in all test procs.  Use proc_with_prefix to avoid\nduplicates.\n\nThe check_fork_catchpoints proc also seems used to check for follow-fork\nsupport by checking if catchpoints are supported.  If they are not, it\nuses \"return -code return\", which makes its caller return.  I find this\nunnecessary complex, versus just returning a boolean.  Modify it to do\nso.\n\nChange-Id: I23e62b204286c5e9c5c86d2727f7d33fb126ed08",
    "tree": {
      "sha": "44cb58fae7453853d54f20e3d781ee4f10ffebf1",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/44cb58fae7453853d54f20e3d781ee4f10ffebf1"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/b45781ddac54c8d4b8d771d1f0823c4b5a072af3",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b45781ddac54c8d4b8d771d1f0823c4b5a072af3",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/b45781ddac54c8d4b8d771d1f0823c4b5a072af3",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/b45781ddac54c8d4b8d771d1f0823c4b5a072af3/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "09c0623ade7dcff1c5291a644397fdf714949edf",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/09c0623ade7dcff1c5291a644397fdf714949edf",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/09c0623ade7dcff1c5291a644397fdf714949edf"
    }
  ],
  "stats": {
    "total": 144,
    "additions": 81,
    "deletions": 63
  },
  "files": [
    {
      "sha": "4661bf56a52de72a970035ff8c80fa514dc45eba",
      "filename": "gdb/testsuite/gdb.base/foll-fork.exp",
      "status": "modified",
      "additions": 81,
      "deletions": 63,
      "changes": 144,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/b45781ddac54c8d4b8d771d1f0823c4b5a072af3/gdb/testsuite/gdb.base/foll-fork.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/b45781ddac54c8d4b8d771d1f0823c4b5a072af3/gdb/testsuite/gdb.base/foll-fork.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.base/foll-fork.exp?ref=b45781ddac54c8d4b8d771d1f0823c4b5a072af3",
      "patch": "@@ -22,13 +22,33 @@ if [gdb_debug_enabled] {\n \n standard_testfile\n \n-if {[prepare_for_testing \"failed to prepare\" $testfile $srcfile debug]} {\n+if {[build_executable \"failed to prepare\" $testfile $srcfile debug]} {\n     return -1\n }\n \n-proc check_fork_catchpoints {} {\n+# Restart GDB and run the inferior to main.  Return 1 on success, 0 on failure.\n+\n+proc setup {} {\n+    clean_restart $::testfile\n+\n+    if { ![runto_main] } {\n+\tfail \"could not run to main\"\n+\treturn 0\n+    }\n+\n+    return 1\n+}\n+\n+# Check that fork catchpoints are supported, as an indicator for whether\n+# fork-following is supported.  Return 1 if they are, else 0.\n+\n+proc_with_prefix check_fork_catchpoints {} {\n   global gdb_prompt\n \n+  if { ![setup] } {\n+      return\n+  }\n+\n   # Verify that the system supports \"catch fork\".\n   gdb_test \"catch fork\" \"Catchpoint \\[0-9\\]* \\\\(fork\\\\)\" \"insert first fork catchpoint\"\n   set has_fork_catchpoints 0\n@@ -42,10 +62,7 @@ proc check_fork_catchpoints {} {\n     }\n   }\n \n-  if {$has_fork_catchpoints == 0} {\n-    unsupported \"fork catchpoints\"\n-    return -code return\n-  }\n+  return $has_fork_catchpoints\n }\n \n # Test follow-fork to ensure that the correct process is followed, that\n@@ -57,19 +74,16 @@ proc check_fork_catchpoints {} {\n # execute the program past the fork.  If the value of WHO or DETACH is\n # 'default', the corresponding GDB command is skipped for that test.\n # The value of CMD must be either 'next 2' or 'continue'.\n-proc test_follow_fork { who detach cmd } {\n+proc_with_prefix test_follow_fork { who detach cmd } {\n     global gdb_prompt\n     global srcfile\n     global testfile\n \n     with_test_prefix \"follow $who, detach $detach, command \\\"$cmd\\\"\" {\n \n \t# Start a new debugger session each time so defaults are legitimate.\n-\tclean_restart $testfile\n-\n-\tif ![runto_main] {\n-\t    untested \"could not run to main\"\n-\t    return -1\n+\tif { ![setup] } {\n+\t    return\n \t}\n \n \t# The \"Detaching...\" and \"Attaching...\" messages may be hidden by\n@@ -174,11 +188,18 @@ proc test_follow_fork { who detach cmd } {\n \n set reading_in_symbols_re {(?:\\r\\nReading in symbols for [^\\r\\n]*)?}\n \n-proc catch_fork_child_follow {} {\n+# Test the ability to catch a fork, specify that the child be\n+# followed, and continue.  Make the catchpoint permanent.\n+\n+proc_with_prefix catch_fork_child_follow {} {\n     global gdb_prompt\n     global srcfile\n     global reading_in_symbols_re\n \n+    if { ![setup] } {\n+\treturn\n+    }\n+\n     set bp_after_fork [gdb_get_line_number \"set breakpoint here\"]\n \n     gdb_test \"catch fork\" \\\n@@ -224,10 +245,18 @@ proc catch_fork_child_follow {} {\n \t\"y\"\n }\n \n-proc catch_fork_unpatch_child {} {\n+# Test that parent breakpoints are successfully detached from the\n+# child at fork time, even if the user removes them from the\n+# breakpoints list after stopping at a fork catchpoint.\n+\n+proc_with_prefix catch_fork_unpatch_child {} {\n     global gdb_prompt\n     global srcfile\n \n+    if { ![setup] } {\n+\treturn\n+    }\n+\n     set bp_exit [gdb_get_line_number \"at exit\"]\n \n     gdb_test \"break callee\" \"file .*$srcfile, line .*\" \\\n@@ -271,11 +300,18 @@ proc catch_fork_unpatch_child {} {\n     }\n }\n \n-proc tcatch_fork_parent_follow {} {\n+# Test the ability to catch a fork, specify via a -do clause that\n+# the parent be followed, and continue.  Make the catchpoint temporary.\n+\n+proc_with_prefix tcatch_fork_parent_follow {} {\n     global gdb_prompt\n     global srcfile\n     global reading_in_symbols_re\n \n+    if { ![setup] } {\n+\treturn\n+    }\n+\n     set bp_after_fork [gdb_get_line_number \"set breakpoint here\"]\n \n     gdb_test \"catch fork\" \\\n@@ -313,9 +349,10 @@ proc tcatch_fork_parent_follow {} {\n \t\"y\"\n }\n \n-proc do_fork_tests {} {\n-    global gdb_prompt\n-    global testfile\n+# Test simple things about the \"set follow-fork-mode\" command.\n+\n+proc_with_prefix test_set_follow_fork_command {} {\n+    clean_restart\n \n     # Verify that help is available for \"set follow-fork-mode\".\n     #\n@@ -342,56 +379,37 @@ By default, the debugger will follow the parent process..*\"\n \t\"set follow-fork to nonsense is prohibited\"\n \n     gdb_test_no_output \"set follow-fork parent\" \"reset parent\"\n+}\n \n-    # Check that fork catchpoints are supported, as an indicator for whether\n-    # fork-following is supported.\n-    if [runto_main] then { check_fork_catchpoints }\n+test_set_follow_fork_command\n \n-    # Test the basic follow-fork functionality using all combinations of\n-    # values for follow-fork-mode and detach-on-fork, using either a\n-    # breakpoint or single-step to execute past the fork.\n-    #\n-    # The first loop should be sufficient to test the defaults.  There\n-    # is no need to test using the defaults in other permutations (e.g.\n-    # \"default\" \"on\", \"parent\" \"default\", etc.).\n-    foreach cmd {\"next 2\" \"continue\"} {\n-        test_follow_fork \"default\" \"default\" $cmd\n-    }\n+if { ![check_fork_catchpoints] } {\n+    untested \"follow-fork not supported\"\n+    return\n+}\n \n-    # Now test all explicit permutations.\n-    foreach who {\"parent\" \"child\"} {\n-\tforeach detach {\"on\" \"off\"} {\n-\t    foreach cmd {\"next 2\" \"continue\"} {\n-\t\ttest_follow_fork $who $detach $cmd\n-\t    }\n+# Test the basic follow-fork functionality using all combinations of\n+# values for follow-fork-mode and detach-on-fork, using either a\n+# breakpoint or single-step to execute past the fork.\n+#\n+# The first loop should be sufficient to test the defaults.  There\n+# is no need to test using the defaults in other permutations (e.g.\n+# \"default\" \"on\", \"parent\" \"default\", etc.).\n+foreach cmd {\"next 2\" \"continue\"} {\n+    test_follow_fork \"default\" \"default\" $cmd\n+}\n+\n+# Now test all explicit permutations.\n+foreach who {\"parent\" \"child\"} {\n+    foreach detach {\"on\" \"off\"} {\n+\tforeach cmd {\"next 2\" \"continue\"} {\n+\t    test_follow_fork $who $detach $cmd\n \t}\n     }\n-\n-    # Catchpoint tests.\n-\n-    # Restart to eliminate any effects of the follow-fork tests.\n-    clean_restart $testfile\n-    gdb_test_no_output \"set verbose\"\n-\n-    # Test the ability to catch a fork, specify that the child be\n-    # followed, and continue.  Make the catchpoint permanent.\n-    #\n-    if [runto_main] then { catch_fork_child_follow }\n-\n-    # Test that parent breakpoints are successfully detached from the\n-    # child at fork time, even if the user removes them from the\n-    # breakpoints list after stopping at a fork catchpoint.\n-    if [runto_main] then { catch_fork_unpatch_child }\n-\n-    # Test the ability to catch a fork, specify via a -do clause that\n-    # the parent be followed, and continue.  Make the catchpoint temporary.\n-    #\n-    if [runto_main] then { tcatch_fork_parent_follow }\n }\n \n-# This is a test of gdb's ability to follow the parent, child or both\n-# parent and child of a Unix fork() system call.\n-#\n-do_fork_tests\n+# Catchpoint tests.\n \n-return 0\n+catch_fork_child_follow\n+catch_fork_unpatch_child\n+tcatch_fork_parent_follow"
    }
  ]
}