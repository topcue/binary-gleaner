{
  "sha": "183be222907a6f419bd71f70ee650989026f0188",
  "node_id": "C_kwDOANOeidoAKDE4M2JlMjIyOTA3YTZmNDE5YmQ3MWY3MGVlNjUwOTg5MDI2ZjAxODg",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-10-21T20:12:04Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2021-10-21T20:13:56Z"
    },
    "message": "gdb, gdbserver: make target_waitstatus safe\n\nI stumbled on a bug caused by the fact that a code path read\ntarget_waitstatus::value::sig (expecting it to contain a gdb_signal\nvalue) while target_waitstatus::kind was TARGET_WAITKIND_FORKED.  This\nmeant that the active union field was in fact\ntarget_waitstatus::value::related_pid, and contained a ptid.  The read\nsignal value was therefore garbage, and that caused GDB to crash soon\nafter.  Or, since that GDB was built with ubsan, this nice error\nmessage:\n\n    /home/simark/src/binutils-gdb/gdb/linux-nat.c:1271:12: runtime error: load of value 2686365, which is not a valid value for type 'gdb_signal'\n\nDespite being a large-ish change, I think it would be nice to make\ntarget_waitstatus safe against that kind of bug.  As already done\nelsewhere (e.g. dynamic_prop), validate that the type of value read from\nthe union matches what is supposed to be the active field.\n\n - Make the kind and value of target_waitstatus private.\n - Make the kind initialized to TARGET_WAITKIND_IGNORE on\n   target_waitstatus construction.  This is what most users appear to do\n   explicitly.\n - Add setters, one for each kind.  Each setter takes as a parameter the\n   data associated to that kind, if any.  This makes it impossible to\n   forget to attach the associated data.\n - Add getters, one for each associated data type.  Each getter\n   validates that the data type fetched by the user matches the wait\n   status kind.\n - Change \"integer\" to \"exit_status\", \"related_pid\" to \"child_ptid\",\n   just because that's more precise terminology.\n - Fix all users.\n\nThat last point is semi-mechanical.  There are a lot of obvious changes,\nbut some less obvious ones.  For example, it's not possible to set the\nkind at some point and the associated data later, as some users did.\nBut in any case, the intent of the code should not change in this patch.\n\nThis was tested on x86-64 Linux (unix, native-gdbserver and\nnative-extended-gdbserver boards).  It was built-tested on x86-64\nFreeBSD, NetBSD, MinGW and macOS.  The rest of the changes to native\nfiles was done as a best effort.  If I forgot any place to update in\nthese files, it should be easy to fix (unless the change happens to\nreveal an actual bug).\n\nChange-Id: I0ae967df1ff6e28de78abbe3ac9b4b2ff4ad03b7",
    "tree": {
      "sha": "ddce1e1b3a84b877e6989acb8bbd424dfff0f3b6",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/ddce1e1b3a84b877e6989acb8bbd424dfff0f3b6"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/183be222907a6f419bd71f70ee650989026f0188",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/183be222907a6f419bd71f70ee650989026f0188",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/183be222907a6f419bd71f70ee650989026f0188",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/183be222907a6f419bd71f70ee650989026f0188/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "c360a4732bd7999767616e5f211314510ea677f4",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/c360a4732bd7999767616e5f211314510ea677f4",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/c360a4732bd7999767616e5f211314510ea677f4"
    }
  ],
  "stats": {
    "total": 1531,
    "additions": 826,
    "deletions": 705
  },
  "files": [
    {
      "sha": "a604320d666dc49b6298c1113e55dbd8197069c9",
      "filename": "gdb/aix-thread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/aix-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/aix-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aix-thread.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -1092,8 +1092,8 @@ aix_thread_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     return ptid_t (-1);\n \n   /* Check whether libpthdebug might be ready to be initialized.  */\n-  if (!pd_active && status->kind == TARGET_WAITKIND_STOPPED\n-      && status->value.sig == GDB_SIGNAL_TRAP)\n+  if (!pd_active && status->kind () == TARGET_WAITKIND_STOPPED\n+      && status->sig () == GDB_SIGNAL_TRAP)\n     {\n       process_stratum_target *proc_target\n \t= current_inferior ()->process_target ();"
    },
    {
      "sha": "9c5db9016146a5b073c4f5a9a4820814e26dc972",
      "filename": "gdb/break-catch-sig.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/break-catch-sig.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/break-catch-sig.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-sig.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -155,10 +155,10 @@ signal_catchpoint_breakpoint_hit (const struct bp_location *bl,\n     = (const struct signal_catchpoint *) bl->owner;\n   gdb_signal signal_number;\n \n-  if (ws->kind != TARGET_WAITKIND_STOPPED)\n+  if (ws->kind () != TARGET_WAITKIND_STOPPED)\n     return 0;\n \n-  signal_number = ws->value.sig;\n+  signal_number = ws->sig ();\n \n   /* If we are catching specific signals in this breakpoint, then we\n      must guarantee that the called signal is the same signal we are\n@@ -188,7 +188,7 @@ signal_catchpoint_print_it (bpstat bs)\n \n   get_last_target_status (nullptr, nullptr, &last);\n \n-  signal_name = signal_to_name_or_int (last.value.sig);\n+  signal_name = signal_to_name_or_int (last.sig ());\n \n   annotate_catchpoint (b->number);\n   maybe_print_thread_hit_breakpoint (uiout);"
    },
    {
      "sha": "633985d51f456cd0000509667ddd1ba82bdf6336",
      "filename": "gdb/break-catch-syscall.c",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/break-catch-syscall.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/break-catch-syscall.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/break-catch-syscall.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -152,11 +152,11 @@ breakpoint_hit_catch_syscall (const struct bp_location *bl,\n   const struct syscall_catchpoint *c\n     = (const struct syscall_catchpoint *) bl->owner;\n \n-  if (ws->kind != TARGET_WAITKIND_SYSCALL_ENTRY\n-      && ws->kind != TARGET_WAITKIND_SYSCALL_RETURN)\n+  if (ws->kind () != TARGET_WAITKIND_SYSCALL_ENTRY\n+      && ws->kind () != TARGET_WAITKIND_SYSCALL_RETURN)\n     return 0;\n \n-  syscall_number = ws->value.syscall_number;\n+  syscall_number = ws->syscall_number ();\n \n   /* Now, checking if the syscall is the same.  */\n   if (!c->syscalls_to_be_caught.empty ())\n@@ -189,7 +189,7 @@ print_it_catch_syscall (bpstat bs)\n \n   get_last_target_status (nullptr, nullptr, &last);\n \n-  get_syscall_by_number (gdbarch, last.value.syscall_number, &s);\n+  get_syscall_by_number (gdbarch, last.syscall_number (), &s);\n \n   annotate_catchpoint (b->number);\n   maybe_print_thread_hit_breakpoint (uiout);\n@@ -201,20 +201,20 @@ print_it_catch_syscall (bpstat bs)\n   if (uiout->is_mi_like_p ())\n     {\n       uiout->field_string (\"reason\",\n-\t\t\t   async_reason_lookup (last.kind == TARGET_WAITKIND_SYSCALL_ENTRY\n+\t\t\t   async_reason_lookup (last.kind () == TARGET_WAITKIND_SYSCALL_ENTRY\n \t\t\t\t\t\t? EXEC_ASYNC_SYSCALL_ENTRY\n \t\t\t\t\t\t: EXEC_ASYNC_SYSCALL_RETURN));\n       uiout->field_string (\"disp\", bpdisp_text (b->disposition));\n     }\n   uiout->field_signed (\"bkptno\", b->number);\n \n-  if (last.kind == TARGET_WAITKIND_SYSCALL_ENTRY)\n+  if (last.kind () == TARGET_WAITKIND_SYSCALL_ENTRY)\n     uiout->text (\" (call to syscall \");\n   else\n     uiout->text (\" (returned from syscall \");\n \n   if (s.name == NULL || uiout->is_mi_like_p ())\n-    uiout->field_signed (\"syscall-number\", last.value.syscall_number);\n+    uiout->field_signed (\"syscall-number\", last.syscall_number ());\n   if (s.name != NULL)\n     uiout->field_string (\"syscall-name\", s.name);\n "
    },
    {
      "sha": "e5f44be65de105efaec7cf1993717fc71ef0d994",
      "filename": "gdb/breakpoint.c",
      "status": "modified",
      "additions": 11,
      "deletions": 11,
      "changes": 22,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/breakpoint.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/breakpoint.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -7764,10 +7764,10 @@ breakpoint_hit_catch_fork (const struct bp_location *bl,\n {\n   struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n \n-  if (ws->kind != TARGET_WAITKIND_FORKED)\n+  if (ws->kind () != TARGET_WAITKIND_FORKED)\n     return 0;\n \n-  c->forked_inferior_pid = ws->value.related_pid;\n+  c->forked_inferior_pid = ws->child_ptid ();\n   return 1;\n }\n \n@@ -7880,10 +7880,10 @@ breakpoint_hit_catch_vfork (const struct bp_location *bl,\n {\n   struct fork_catchpoint *c = (struct fork_catchpoint *) bl->owner;\n \n-  if (ws->kind != TARGET_WAITKIND_VFORKED)\n+  if (ws->kind () != TARGET_WAITKIND_VFORKED)\n     return 0;\n \n-  c->forked_inferior_pid = ws->value.related_pid;\n+  c->forked_inferior_pid = ws->child_ptid ();\n   return 1;\n }\n \n@@ -8002,7 +8002,7 @@ breakpoint_hit_catch_solib (const struct bp_location *bl,\n {\n   struct solib_catchpoint *self = (struct solib_catchpoint *) bl->owner;\n \n-  if (ws->kind == TARGET_WAITKIND_LOADED)\n+  if (ws->kind () == TARGET_WAITKIND_LOADED)\n     return 1;\n \n   for (breakpoint *other : all_breakpoints ())\n@@ -8278,10 +8278,10 @@ breakpoint_hit_catch_exec (const struct bp_location *bl,\n {\n   struct exec_catchpoint *c = (struct exec_catchpoint *) bl->owner;\n \n-  if (ws->kind != TARGET_WAITKIND_EXECD)\n+  if (ws->kind () != TARGET_WAITKIND_EXECD)\n     return 0;\n \n-  c->exec_pathname = make_unique_xstrdup (ws->value.execd_pathname);\n+  c->exec_pathname = make_unique_xstrdup (ws->execd_pathname ());\n   return 1;\n }\n \n@@ -9783,8 +9783,8 @@ breakpoint_hit_ranged_breakpoint (const struct bp_location *bl,\n \t\t\t\t  CORE_ADDR bp_addr,\n \t\t\t\t  const struct target_waitstatus *ws)\n {\n-  if (ws->kind != TARGET_WAITKIND_STOPPED\n-      || ws->value.sig != GDB_SIGNAL_TRAP)\n+  if (ws->kind () != TARGET_WAITKIND_STOPPED\n+      || ws->sig () != GDB_SIGNAL_TRAP)\n     return 0;\n \n   return breakpoint_address_match_range (bl->pspace->aspace, bl->address,\n@@ -12450,8 +12450,8 @@ bkpt_breakpoint_hit (const struct bp_location *bl,\n \t\t     const address_space *aspace, CORE_ADDR bp_addr,\n \t\t     const struct target_waitstatus *ws)\n {\n-  if (ws->kind != TARGET_WAITKIND_STOPPED\n-      || ws->value.sig != GDB_SIGNAL_TRAP)\n+  if (ws->kind () != TARGET_WAITKIND_STOPPED\n+      || ws->sig () != GDB_SIGNAL_TRAP)\n     return 0;\n \n   if (!breakpoint_address_match (bl->pspace->aspace, bl->address,"
    },
    {
      "sha": "7709a81b3cede7793e1537ea6d714fcb02acd53c",
      "filename": "gdb/bsd-uthread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/bsd-uthread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/bsd-uthread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/bsd-uthread.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -389,8 +389,8 @@ bsd_uthread_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n   /* If the process is no longer alive, there's no point in figuring\n      out the thread ID.  It will fail anyway.  */\n-  if (status->kind == TARGET_WAITKIND_SIGNALLED\n-      || status->kind == TARGET_WAITKIND_EXITED)\n+  if (status->kind () == TARGET_WAITKIND_SIGNALLED\n+      || status->kind () == TARGET_WAITKIND_EXITED)\n     return ptid;\n \n   /* Fetch the corresponding thread ID, and augment the returned"
    },
    {
      "sha": "e1aeb69e404de9ce0efc79ffbc1e492f1ff911b0",
      "filename": "gdb/darwin-nat.c",
      "status": "modified",
      "additions": 26,
      "deletions": 32,
      "changes": 58,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/darwin-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/darwin-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/darwin-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -980,12 +980,12 @@ darwin_nat_target::decode_message (mach_msg_header_t *hdr,\n \t  printf_unfiltered\n \t    (_(\"darwin_wait: ill-formatted message (id=0x%x)\\n\"), hdr->msgh_id);\n \t  /* FIXME: send a failure reply?  */\n-\t  status->kind = TARGET_WAITKIND_IGNORE;\n+\t  status->set_ignore ();\n \t  return minus_one_ptid;\n \t}\n       if (inf == NULL)\n \t{\n-\t  status->kind = TARGET_WAITKIND_IGNORE;\n+\t  status->set_ignore ();\n \t  return minus_one_ptid;\n \t}\n       *pinf = inf;\n@@ -995,7 +995,6 @@ darwin_nat_target::decode_message (mach_msg_header_t *hdr,\n \n       priv->pending_messages++;\n \n-      status->kind = TARGET_WAITKIND_STOPPED;\n       thread->msg_state = DARWIN_MESSAGE;\n \n       inferior_debug (4, _(\"darwin_wait: thread=0x%x, got %s\\n\"),\n@@ -1005,25 +1004,25 @@ darwin_nat_target::decode_message (mach_msg_header_t *hdr,\n       switch (thread->event.ex_type)\n \t{\n \tcase EXC_BAD_ACCESS:\n-\t  status->value.sig = GDB_EXC_BAD_ACCESS;\n+\t  status->set_stopped (GDB_EXC_BAD_ACCESS);\n \t  break;\n \tcase EXC_BAD_INSTRUCTION:\n-\t  status->value.sig = GDB_EXC_BAD_INSTRUCTION;\n+\t  status->set_stopped (GDB_EXC_BAD_INSTRUCTION);\n \t  break;\n \tcase EXC_ARITHMETIC:\n-\t  status->value.sig = GDB_EXC_ARITHMETIC;\n+\t  status->set_stopped (GDB_EXC_ARITHMETIC);\n \t  break;\n \tcase EXC_EMULATION:\n-\t  status->value.sig = GDB_EXC_EMULATION;\n+\t  status->set_stopped (GDB_EXC_EMULATION);\n \t  break;\n \tcase EXC_SOFTWARE:\n \t  if (thread->event.ex_data[0] == EXC_SOFT_SIGNAL)\n \t    {\n-\t      status->value.sig =\n-\t\tgdb_signal_from_host (thread->event.ex_data[1]);\n+\t      status->set_stopped\n+\t\t(gdb_signal_from_host (thread->event.ex_data[1]));\n \t      inferior_debug (5, _(\"  (signal %d: %s)\\n\"),\n \t\t\t      thread->event.ex_data[1],\n-\t\t\t      gdb_signal_to_name (status->value.sig));\n+\t\t\t      gdb_signal_to_name (status->sig ()));\n \n \t      /* If the thread is stopped because it has received a signal\n \t\t that gdb has just sent, continue.  */\n@@ -1032,20 +1031,20 @@ darwin_nat_target::decode_message (mach_msg_header_t *hdr,\n \t\t  thread->signaled = 0;\n \t\t  darwin_send_reply (inf, thread);\n \t\t  thread->msg_state = DARWIN_RUNNING;\n-\t\t  status->kind = TARGET_WAITKIND_IGNORE;\n+\t\t  status->set_ignore ();\n \t\t}\n \t    }\n \t  else\n-\t    status->value.sig = GDB_EXC_SOFTWARE;\n+\t    status->set_stopped (GDB_EXC_SOFTWARE);\n \t  break;\n \tcase EXC_BREAKPOINT:\n \t  /* Many internal GDB routines expect breakpoints to be reported\n \t     as GDB_SIGNAL_TRAP, and will report GDB_EXC_BREAKPOINT\n \t     as a spurious signal.  */\n-\t  status->value.sig = GDB_SIGNAL_TRAP;\n+\t  status->set_stopped (GDB_SIGNAL_TRAP);\n \t  break;\n \tdefault:\n-\t  status->value.sig = GDB_SIGNAL_UNKNOWN;\n+\t  status->set_stopped (GDB_SIGNAL_UNKNOWN);\n \t  break;\n \t}\n \n@@ -1071,7 +1070,7 @@ darwin_nat_target::decode_message (mach_msg_header_t *hdr,\n \n       if (res < 0 || inf == NULL)\n \t{\n-\t  status->kind = TARGET_WAITKIND_IGNORE;\n+\t  status->set_ignore ();\n \t  return minus_one_ptid;\n \t}\n \n@@ -1089,18 +1088,15 @@ darwin_nat_target::decode_message (mach_msg_header_t *hdr,\n \t\t{\n \t\t  printf_unfiltered (_(\"wait4: res=%d: %s\\n\"),\n \t\t\t\t     res_pid, safe_strerror (errno));\n-\t\t  status->kind = TARGET_WAITKIND_IGNORE;\n+\t\t  status->set_ignore ();\n \t\t  return minus_one_ptid;\n \t\t}\n \t      if (WIFEXITED (wstatus))\n-\t\t{\n-\t\t  status->kind = TARGET_WAITKIND_EXITED;\n-\t\t  status->value.integer = WEXITSTATUS (wstatus);\n-\t\t}\n+\t\tstatus->set_exited (WEXITSTATUS (wstatus));\n \t      else\n \t\t{\n-\t\t  status->kind = TARGET_WAITKIND_SIGNALLED;\n-\t\t  status->value.sig = gdb_signal_from_host (WTERMSIG (wstatus));\n+\t\t  status->set_signalled\n+\t\t    (gdb_signal_from_host (WTERMSIG (wstatus)));\n \t\t}\n \n \t      inferior_debug (4, _(\"darwin_wait: pid=%d exit, status=0x%x\\n\"),\n@@ -1114,16 +1110,15 @@ darwin_nat_target::decode_message (mach_msg_header_t *hdr,\n \t  else\n \t    {\n \t      inferior_debug (4, _(\"darwin_wait: pid=%d\\n\"), inf->pid);\n-\t      status->kind = TARGET_WAITKIND_EXITED;\n-\t      status->value.integer = 0; /* Don't know.  */\n+\t      status->set_exited (0 /* Don't know.  */);\n \t      return ptid_t (inf->pid, 0, 0);\n \t    }\n \t}\n     }\n \n   /* Unknown message.  */\n   warning (_(\"darwin: got unknown message, id: 0x%x\"), hdr->msgh_id);\n-  status->kind = TARGET_WAITKIND_IGNORE;\n+  status->set_ignore ();\n   return minus_one_ptid;\n }\n \n@@ -1182,8 +1177,7 @@ darwin_nat_target::wait_1 (ptid_t ptid, struct target_waitstatus *status)\n \n       darwin_inferior *priv = get_darwin_inferior (inf);\n \n-      status->kind = TARGET_WAITKIND_STOPPED;\n-      status->value.sig = GDB_SIGNAL_TRAP;\n+      status->set_stopped (GDB_SIGNAL_TRAP);\n       thread = priv->threads[0];\n       thread->msg_state = DARWIN_STOPPED;\n       return ptid_t (inf->pid, 0, thread->gdb_port);\n@@ -1201,14 +1195,14 @@ darwin_nat_target::wait_1 (ptid_t ptid, struct target_waitstatus *status)\n \n       if (kret == MACH_RCV_INTERRUPTED)\n \t{\n-\t  status->kind = TARGET_WAITKIND_IGNORE;\n+\t  status->set_ignore ();\n \t  return minus_one_ptid;\n \t}\n \n       if (kret != MACH_MSG_SUCCESS)\n \t{\n \t  inferior_debug (5, _(\"mach_msg: ret=0x%x\\n\"), kret);\n-\t  status->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  status->set_spurious ();\n \t  return minus_one_ptid;\n \t}\n \n@@ -1225,7 +1219,7 @@ darwin_nat_target::wait_1 (ptid_t ptid, struct target_waitstatus *status)\n       if (inf == NULL)\n \treturn res;\n     }\n-  while (status->kind == TARGET_WAITKIND_IGNORE);\n+  while (status->kind () == TARGET_WAITKIND_IGNORE);\n \n   /* Stop all tasks.  */\n   for (inferior *inf : all_inferiors (this))\n@@ -1400,8 +1394,8 @@ darwin_nat_target::stop_inferior (inferior *inf)\n   while (1)\n     {\n       ptid = wait_1 (ptid_t (inf->pid), &wstatus);\n-      if (wstatus.kind == TARGET_WAITKIND_STOPPED\n-\t  && wstatus.value.sig == GDB_SIGNAL_STOP)\n+      if (wstatus.kind () == TARGET_WAITKIND_STOPPED\n+\t  && wstatus.sig () == GDB_SIGNAL_STOP)\n \tbreak;\n     }\n }"
    },
    {
      "sha": "e90aa12e4425a20ed640ed8db845a5306c1581a1",
      "filename": "gdb/fbsd-nat.c",
      "status": "modified",
      "additions": 18,
      "deletions": 15,
      "changes": 33,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/fbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/fbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/fbsd-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -1181,7 +1181,7 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t}\n #endif\n       wptid = inf_ptrace_target::wait (ptid, ourstatus, target_options);\n-      if (ourstatus->kind == TARGET_WAITKIND_STOPPED)\n+      if (ourstatus->kind () == TARGET_WAITKIND_STOPPED)\n \t{\n \t  struct ptrace_lwpinfo pl;\n \t  pid_t pid;\n@@ -1252,7 +1252,7 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t\t\t\t\t pl.pl_lwpid);\n \t\t  add_thread (this, wptid);\n \t\t}\n-\t      ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t      ourstatus->set_spurious ();\n \t      return wptid;\n \t    }\n #endif\n@@ -1263,14 +1263,14 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n #ifndef PTRACE_VFORK\n \t      struct kinfo_proc kp;\n #endif\n+\t      bool is_vfork = false;\n \t      ptid_t child_ptid;\n \t      pid_t child;\n \n \t      child = pl.pl_child_pid;\n-\t      ourstatus->kind = TARGET_WAITKIND_FORKED;\n #ifdef PTRACE_VFORK\n \t      if (pl.pl_flags & PL_FLAG_VFORKED)\n-\t\tourstatus->kind = TARGET_WAITKIND_VFORKED;\n+\t\tis_vfork = true;\n #endif\n \n \t      /* Make sure the other end of the fork is stopped too.  */\n@@ -1299,12 +1299,16 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t      if (fbsd_fetch_kinfo_proc (child, &kp))\n \t\t{\n \t\t  if (kp.ki_flag & P_PPWAIT)\n-\t\t    ourstatus->kind = TARGET_WAITKIND_VFORKED;\n+\t\t    is_vfork = true;\n \t\t}\n \t      else\n \t\twarning (_(\"Failed to fetch process information\"));\n #endif\n-\t      ourstatus->value.related_pid = child_ptid;\n+\n+\t      if (is_vfork)\n+\t\tourstatus->set_vforked (child_ptid);\n+\t      else\n+\t\tourstatus->set_forked (child_ptid);\n \n \t      return wptid;\n \t    }\n@@ -1321,17 +1325,16 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n #ifdef PTRACE_VFORK\n \t  if (pl.pl_flags & PL_FLAG_VFORK_DONE)\n \t    {\n-\t      ourstatus->kind = TARGET_WAITKIND_VFORK_DONE;\n+\t      ourstatus->set_vfork_done ();\n \t      return wptid;\n \t    }\n #endif\n #endif\n \n \t  if (pl.pl_flags & PL_FLAG_EXEC)\n \t    {\n-\t      ourstatus->kind = TARGET_WAITKIND_EXECD;\n-\t      ourstatus->value.execd_pathname\n-\t\t= xstrdup (pid_to_exec_file (pid));\n+\t      ourstatus->set_execd\n+\t\t(make_unique_xstrdup (pid_to_exec_file (pid)));\n \t      return wptid;\n \t    }\n \n@@ -1348,18 +1351,18 @@ fbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t     SIGTRAP, so only treat SIGTRAP events as system call\n \t     entry/exit events.  */\n \t  if (pl.pl_flags & (PL_FLAG_SCE | PL_FLAG_SCX)\n-\t      && ourstatus->value.sig == SIGTRAP)\n+\t      && ourstatus->sig () == SIGTRAP)\n \t    {\n #ifdef HAVE_STRUCT_PTRACE_LWPINFO_PL_SYSCALL_CODE\n \t      if (catch_syscall_enabled ())\n \t\t{\n \t\t  if (catching_syscall_number (pl.pl_syscall_code))\n \t\t    {\n \t\t      if (pl.pl_flags & PL_FLAG_SCE)\n-\t\t\tourstatus->kind = TARGET_WAITKIND_SYSCALL_ENTRY;\n+\t\t\tourstatus->set_syscall_entry (pl.pl_syscall_code);\n \t\t      else\n-\t\t\tourstatus->kind = TARGET_WAITKIND_SYSCALL_RETURN;\n-\t\t      ourstatus->value.syscall_number = pl.pl_syscall_code;\n+\t\t\tourstatus->set_syscall_return (pl.pl_syscall_code);\n+\n \t\t      return wptid;\n \t\t    }\n \t\t}\n@@ -1490,7 +1493,7 @@ fbsd_nat_target::follow_fork (inferior *child_inf, ptid_t child_ptid,\n \tperror_with_name ((\"ptrace\"));\n \n #ifndef PTRACE_VFORK\n-      if (fork_kind == TARGET_WAITKIND_VFORKED)\n+      if (fork_kind () == TARGET_WAITKIND_VFORKED)\n \t{\n \t  /* We can't insert breakpoints until the child process has\n \t     finished with the shared memory region.  The parent"
    },
    {
      "sha": "bd8d1a2952f838328757cc7b6ce8bc8a17f700da",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -180,7 +180,7 @@ struct thread_suspend_state\n   enum target_stop_reason stop_reason = TARGET_STOPPED_BY_NO_REASON;\n \n   /* The waitstatus for this thread's last event.  */\n-  struct target_waitstatus waitstatus {};\n+  struct target_waitstatus waitstatus;\n   /* If true WAITSTATUS hasn't been handled yet.  */\n   int waitstatus_pending_p = 0;\n "
    },
    {
      "sha": "54838347f947e8b1b26cd9fa5c67481c27ca703d",
      "filename": "gdb/gnu-nat.c",
      "status": "modified",
      "additions": 16,
      "deletions": 22,
      "changes": 38,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/gnu-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/gnu-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gnu-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -626,13 +626,13 @@ gnu_nat_target::_proc_free (struct proc *proc)\n static struct inf *\n make_inf (void)\n {\n-  struct inf *inf = XNEW (struct inf);\n+  struct inf *inf = new struct inf;\n \n   inf->task = 0;\n   inf->threads = 0;\n   inf->threads_up_to_date = 0;\n   inf->pid = 0;\n-  inf->wait.status.kind = TARGET_WAITKIND_SPURIOUS;\n+  inf->wait.status.set_spurious ();\n   inf->wait.thread = 0;\n   inf->wait.exc.handler = MACH_PORT_NULL;\n   inf->wait.exc.reply = MACH_PORT_NULL;\n@@ -661,7 +661,7 @@ void\n gnu_nat_target::inf_clear_wait (struct inf *inf)\n {\n   inf_debug (inf, \"clearing wait\");\n-  inf->wait.status.kind = TARGET_WAITKIND_SPURIOUS;\n+  inf->wait.status.set_spurious ();\n   inf->wait.thread = 0;\n   inf->wait.suppress = 0;\n   if (inf->wait.exc.handler != MACH_PORT_NULL)\n@@ -1326,8 +1326,8 @@ gnu_nat_target::inf_signal (struct inf *inf, enum gdb_signal sig)\n     {\n       struct inf_wait *w = &inf->wait;\n \n-      if (w->status.kind == TARGET_WAITKIND_STOPPED\n-\t  && w->status.value.sig == sig\n+      if (w->status.kind () == TARGET_WAITKIND_STOPPED\n+\t  && w->status.sig () == sig\n \t  && w->thread && !w->thread->aborted)\n \t/* We're passing through the last exception we received.  This is\n \t   kind of bogus, because exceptions are per-thread whereas gdb\n@@ -1549,7 +1549,7 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     /* We're waiting for the inferior to finish execing.  */\n     {\n       struct inf_wait *w = &inf->wait;\n-      enum target_waitkind kind = w->status.kind;\n+      enum target_waitkind kind = w->status.kind ();\n \n       if (kind == TARGET_WAITKIND_SPURIOUS)\n \t/* Since gdb is actually counting the number of times the inferior\n@@ -1560,7 +1560,7 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t  inf_debug (inf, \"pending_execs, ignoring minor event\");\n \t}\n       else if (kind == TARGET_WAITKIND_STOPPED\n-\t       && w->status.value.sig == GDB_SIGNAL_TRAP)\n+\t       && w->status.sig () == GDB_SIGNAL_TRAP)\n \t/* Ah hah!  A SIGTRAP from the inferior while starting up probably\n \t   means we've succesfully completed an exec!  */\n \t{\n@@ -1585,7 +1585,7 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     }\n \n   /* Pass back out our results.  */\n-  memcpy (status, &inf->wait.status, sizeof (*status));\n+  *status = inf->wait.status;\n \n   thread = inf->wait.thread;\n   if (thread)\n@@ -1608,7 +1608,7 @@ gnu_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n   if (thread\n       && ptid != minus_one_ptid\n-      && status->kind != TARGET_WAITKIND_SPURIOUS\n+      && status->kind () != TARGET_WAITKIND_SPURIOUS\n       && inf->pause_sc == 0 && thread->pause_sc == 0)\n     /* If something actually happened to THREAD, make sure we\n        suspend it.  */\n@@ -1658,12 +1658,10 @@ S_exception_raise_request (mach_port_t port, mach_port_t reply_port,\n       /* Store away the details; this will destroy any previous info.  */\n       inf->wait.thread = thread;\n \n-      inf->wait.status.kind = TARGET_WAITKIND_STOPPED;\n-\n       if (exception == EXC_BREAKPOINT)\n \t/* GDB likes to get SIGTRAP for breakpoints.  */\n \t{\n-\t  inf->wait.status.value.sig = GDB_SIGNAL_TRAP;\n+\t  inf->wait.status.set_stopped (GDB_SIGNAL_TRAP);\n \t  mach_port_deallocate (mach_task_self (), reply_port);\n \t}\n       else\n@@ -1696,8 +1694,8 @@ S_exception_raise_request (mach_port_t port, mach_port_t reply_port,\n \t  /* Exceptions are encoded in the signal space by putting\n \t     them after _NSIG; this assumes they're positive (and not\n \t     extremely large)!  */\n-\t  inf->wait.status.value.sig =\n-\t    gdb_signal_from_host (_NSIG + exception);\n+\t  inf->wait.status.set_stopped\n+\t    (gdb_signal_from_host (_NSIG + exception));\n \t}\n     }\n   else\n@@ -1718,8 +1716,7 @@ inf_task_died_status (struct inf *inf)\n {\n   warning (_(\"Pid %d died with unknown exit status, using SIGKILL.\"),\n \t   inf->pid);\n-  inf->wait.status.kind = TARGET_WAITKIND_SIGNALLED;\n-  inf->wait.status.value.sig = GDB_SIGNAL_KILL;\n+  inf->wait.status.set_signalled (GDB_SIGNAL_KILL);\n }\n \n /* Notify server routines.  The only real one is dead name notification.  */\n@@ -1825,7 +1822,7 @@ S_proc_wait_reply (mach_port_t reply, kern_return_t err,\n   else if (pid == inf->pid)\n     {\n       store_waitstatus (&inf->wait.status, status);\n-      if (inf->wait.status.kind == TARGET_WAITKIND_STOPPED)\n+      if (inf->wait.status.kind () == TARGET_WAITKIND_STOPPED)\n \t/* The process has sent us a signal, and stopped itself in a sane\n \t   state pending our actions.  */\n \t{\n@@ -1915,10 +1912,7 @@ S_msg_sig_post_untraced_reply (mach_port_t reply, kern_return_t err)\n        like the process stopped (using a signal of 0 should mean that the\n        *next* time the user continues, it will pass signal 0, which the crash\n        server should like).  */\n-    {\n-      inf->wait.status.kind = TARGET_WAITKIND_STOPPED;\n-      inf->wait.status.value.sig = GDB_SIGNAL_0;\n-    }\n+    inf->wait.status.set_stopped (GDB_SIGNAL_0);\n   else if (err)\n     warning (_(\"Signal delivery failed: %s\"), safe_strerror (err));\n \n@@ -1994,7 +1988,7 @@ gnu_nat_target::resume (ptid_t ptid, int step, enum gdb_signal sig)\n       proc_abort (inf->wait.thread, 1);\n       warning (_(\"Aborting %s with unforwarded exception %s.\"),\n \t       proc_string (inf->wait.thread),\n-\t       gdb_signal_to_name (inf->wait.status.value.sig));\n+\t       gdb_signal_to_name (inf->wait.status.sig ()));\n     }\n \n   if (port_msgs_queued (inf->event_port))"
    },
    {
      "sha": "528cb761c819f1f3e9f4bc7ebf19a90a27ddedb2",
      "filename": "gdb/go32-nat.c",
      "status": "modified",
      "additions": 6,
      "deletions": 10,
      "changes": 16,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/go32-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/go32-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/go32-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -511,24 +511,20 @@ go32_nat_target::wait (ptid_t ptid, struct target_waitstatus *status,\n     chdir (current_directory);\n \n   if (a_tss.tss_irqn == 0x21)\n-    {\n-      status->kind = TARGET_WAITKIND_EXITED;\n-      status->value.integer = a_tss.tss_eax & 0xff;\n-    }\n+    status->set_exited (a_tss.tss_eax & 0xff);\n   else\n     {\n-      status->value.sig = GDB_SIGNAL_UNKNOWN;\n-      status->kind = TARGET_WAITKIND_STOPPED;\n+      status->set_stopped (GDB_SIGNAL_UNKNOWN);\n       for (i = 0; sig_map[i].go32_sig != -1; i++)\n \t{\n \t  if (a_tss.tss_irqn == sig_map[i].go32_sig)\n \t    {\n #if __DJGPP_MINOR__ < 3\n-\t      if ((status->value.sig = sig_map[i].gdb_sig) !=\n-\t\t  GDB_SIGNAL_TRAP)\n-\t\tstatus->kind = TARGET_WAITKIND_SIGNALLED;\n+\t      status->set_stopped (sig_map[i].gdb_sig);\n+\t      if (status->sig () != GDB_SIGNAL_TRAP)\n+\t\tstatus->set_signalled (status->sig ());\n #else\n-\t      status->value.sig = sig_map[i].gdb_sig;\n+\t      status->set_stopped (sig_map[i].gdb_sig);\n #endif\n \t      break;\n \t    }"
    },
    {
      "sha": "5e821f4559825030db9f3376e970181b84ad5ff3",
      "filename": "gdb/inf-child.c",
      "status": "modified",
      "additions": 3,
      "deletions": 12,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/inf-child.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/inf-child.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-child.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -58,20 +58,11 @@ void\n store_waitstatus (struct target_waitstatus *ourstatus, int hoststatus)\n {\n   if (WIFEXITED (hoststatus))\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_EXITED;\n-      ourstatus->value.integer = WEXITSTATUS (hoststatus);\n-    }\n+    ourstatus->set_exited (WEXITSTATUS (hoststatus));\n   else if (!WIFSTOPPED (hoststatus))\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-      ourstatus->value.sig = gdb_signal_from_host (WTERMSIG (hoststatus));\n-    }\n+    ourstatus->set_signalled (gdb_signal_from_host (WTERMSIG (hoststatus)));\n   else\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-      ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (hoststatus));\n-    }\n+    ourstatus->set_stopped (gdb_signal_from_host (WSTOPSIG (hoststatus)));\n }\n \n inf_child_target::~inf_child_target ()"
    },
    {
      "sha": "852636ba646f5249f0f666c5e493f86e4ae85628",
      "filename": "gdb/inf-ptrace.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/inf-ptrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/inf-ptrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inf-ptrace.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -324,8 +324,7 @@ inf_ptrace_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t\t\t      safe_strerror (save_errno));\n \n \t  /* Claim it exited with unknown signal.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-\t  ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;\n+\t  ourstatus->set_signalled (GDB_SIGNAL_UNKNOWN);\n \t  return inferior_ptid;\n \t}\n "
    },
    {
      "sha": "6d3a8b09bebfba8969090c3cff464da25f6e6191",
      "filename": "gdb/infcmd.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/infcmd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/infcmd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infcmd.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -482,8 +482,7 @@ run_command_1 (const char *args, int from_tty, enum run_how run_how)\n     {\n       thread_info *thr = inferior_thread ();\n       target_waitstatus ws;\n-      ws.kind = TARGET_WAITKIND_STOPPED;\n-      ws.value.sig = GDB_SIGNAL_0;\n+      ws.set_stopped (GDB_SIGNAL_0);\n       thr->set_pending_waitstatus (ws);\n     }\n "
    },
    {
      "sha": "d97d469e112909ff89ac6249da41508f8cbb8fed",
      "filename": "gdb/infrun.c",
      "status": "modified",
      "additions": 99,
      "deletions": 90,
      "changes": 189,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/infrun.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/infrun.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -404,12 +404,12 @@ show_follow_fork_mode_string (struct ui_file *file, int from_tty,\n static bool\n follow_fork_inferior (bool follow_child, bool detach_fork)\n {\n-  target_waitkind fork_kind = inferior_thread ()->pending_follow.kind;\n+  target_waitkind fork_kind = inferior_thread ()->pending_follow.kind ();\n   gdb_assert (fork_kind == TARGET_WAITKIND_FORKED\n \t      || fork_kind == TARGET_WAITKIND_VFORKED);\n   bool has_vforked = fork_kind == TARGET_WAITKIND_VFORKED;\n   ptid_t parent_ptid = inferior_ptid;\n-  ptid_t child_ptid = inferior_thread ()->pending_follow.value.related_pid;\n+  ptid_t child_ptid = inferior_thread ()->pending_follow.child_ptid ();\n \n   if (has_vforked\n       && !non_stop /* Non-stop always resumes both branches.  */\n@@ -697,8 +697,8 @@ follow_fork ()\n \n       /* If not stopped at a fork event, then there's nothing else to\n \t do.  */\n-      if (wait_status.kind != TARGET_WAITKIND_FORKED\n-\t  && wait_status.kind != TARGET_WAITKIND_VFORKED)\n+      if (wait_status.kind () != TARGET_WAITKIND_FORKED\n+\t  && wait_status.kind () != TARGET_WAITKIND_VFORKED)\n \treturn 1;\n \n       /* Check if we switched over from WAIT_PTID, since the event was\n@@ -721,7 +721,7 @@ follow_fork ()\n \n   /* If there were any forks/vforks that were caught and are now to be\n      followed, then do so now.  */\n-  switch (tp->pending_follow.kind)\n+  switch (tp->pending_follow.kind ())\n     {\n     case TARGET_WAITKIND_FORKED:\n     case TARGET_WAITKIND_VFORKED:\n@@ -757,7 +757,7 @@ follow_fork ()\n \t  }\n \n \tparent = inferior_ptid;\n-\tchild = tp->pending_follow.value.related_pid;\n+\tchild = tp->pending_follow.child_ptid ();\n \n \tprocess_stratum_target *parent_targ = tp->inf->process_target ();\n \t/* Set up inferior(s) as specified by the caller, and tell the\n@@ -777,7 +777,7 @@ follow_fork ()\n \t       to clear the pending follow request.  */\n \t    tp = find_thread_ptid (parent_targ, parent);\n \t    if (tp)\n-\t      tp->pending_follow.kind = TARGET_WAITKIND_SPURIOUS;\n+\t      tp->pending_follow.set_spurious ();\n \n \t    /* This makes sure we don't try to apply the \"Switched\n \t       over from WAIT_PID\" logic above.  */\n@@ -829,7 +829,7 @@ follow_fork ()\n     default:\n       internal_error (__FILE__, __LINE__,\n \t\t      \"Unexpected pending_follow.kind %d\\n\",\n-\t\t      tp->pending_follow.kind);\n+\t\t      tp->pending_follow.kind ());\n       break;\n     }\n \n@@ -1785,6 +1785,25 @@ displaced_step_finish (thread_info *event_thread, enum gdb_signal signal)\n    discarded between events.  */\n struct execution_control_state\n {\n+  execution_control_state ()\n+  {\n+    this->reset ();\n+  }\n+\n+  void reset ()\n+  {\n+    this->target = nullptr;\n+    this->ptid = null_ptid;\n+    this->event_thread = nullptr;\n+    ws = target_waitstatus ();\n+    stop_func_filled_in = 0;\n+    stop_func_start = 0;\n+    stop_func_end = 0;\n+    stop_func_name = nullptr;\n+    wait_some_more = 0;\n+    hit_singlestep_breakpoint = 0;\n+  }\n+\n   process_stratum_target *target;\n   ptid_t ptid;\n   /* The thread that got the event, if this was a thread event; NULL\n@@ -1810,7 +1829,7 @@ struct execution_control_state\n static void\n reset_ecs (struct execution_control_state *ecs, struct thread_info *tp)\n {\n-  memset (ecs, 0, sizeof (*ecs));\n+  ecs->reset ();\n   ecs->event_thread = tp;\n   ecs->ptid = tp->ptid;\n }\n@@ -3367,8 +3386,7 @@ infrun_thread_stop_requested (ptid_t ptid)\n       if (!tp->has_pending_waitstatus ())\n \t{\n \t  target_waitstatus ws;\n-\t  ws.kind = TARGET_WAITKIND_STOPPED;\n-\t  ws.value.sig = GDB_SIGNAL_0;\n+\t  ws.set_stopped (GDB_SIGNAL_0);\n \t  tp->set_pending_waitstatus (ws);\n \t}\n \n@@ -3562,7 +3580,7 @@ do_target_wait_1 (inferior *inf, ptid_t ptid,\n \n \t  tp->clear_pending_waitstatus ();\n \t  target_waitstatus ws;\n-\t  ws.kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ws.set_spurious ();\n \t  tp->set_pending_waitstatus (ws);\n \t  tp->set_stop_reason (TARGET_STOPPED_BY_NO_REASON);\n \t}\n@@ -3651,7 +3669,7 @@ do_target_wait (execution_control_state *ecs, target_wait_flags options)\n \n   if (num_inferiors == 0)\n     {\n-      ecs->ws.kind = TARGET_WAITKIND_IGNORE;\n+      ecs->ws.set_ignore ();\n       return false;\n     }\n \n@@ -3682,7 +3700,7 @@ do_target_wait (execution_control_state *ecs, target_wait_flags options)\n   {\n     ecs->ptid = do_target_wait_1 (inf, minus_one_ptid, &ecs->ws, options);\n     ecs->target = inf->process_target ();\n-    return (ecs->ws.kind != TARGET_WAITKIND_IGNORE);\n+    return (ecs->ws.kind () != TARGET_WAITKIND_IGNORE);\n   };\n \n   /* Needed in 'all-stop + target-non-stop' mode, because we end up\n@@ -3713,7 +3731,7 @@ do_target_wait (execution_control_state *ecs, target_wait_flags options)\n \treturn true;\n     }\n \n-  ecs->ws.kind = TARGET_WAITKIND_IGNORE;\n+  ecs->ws.set_ignore ();\n   return false;\n }\n \n@@ -3856,8 +3874,6 @@ wait_for_inferior (inferior *inf)\n       struct execution_control_state ecss;\n       struct execution_control_state *ecs = &ecss;\n \n-      memset (ecs, 0, sizeof (*ecs));\n-\n       overlay_cache_invalid = 1;\n \n       /* Flush target cache before starting to handle each event.\n@@ -3999,8 +4015,6 @@ fetch_inferior_event ()\n   struct execution_control_state *ecs = &ecss;\n   int cmd_done = 0;\n \n-  memset (ecs, 0, sizeof (*ecs));\n-\n   /* Events are always processed with the main UI as current UI.  This\n      way, warnings, debug output, etc. are always consistently sent to\n      the main console.  */\n@@ -4055,7 +4069,7 @@ fetch_inferior_event ()\n \treturn;\n       }\n \n-    gdb_assert (ecs->ws.kind != TARGET_WAITKIND_IGNORE);\n+    gdb_assert (ecs->ws.kind () != TARGET_WAITKIND_IGNORE);\n \n     /* Switch to the target that generated the event, so we can do\n        target calls.  */\n@@ -4133,7 +4147,7 @@ fetch_inferior_event ()\n \t       selected.\".  */\n \t    if (!non_stop\n \t\t&& cmd_done\n-\t\t&& ecs->ws.kind != TARGET_WAITKIND_NO_RESUMED)\n+\t\t&& ecs->ws.kind () != TARGET_WAITKIND_NO_RESUMED)\n \t      restore_thread.dont_restore ();\n \t  }\n       }\n@@ -4194,7 +4208,7 @@ init_thread_stepping_state (struct thread_info *tss)\n \n void\n set_last_target_status (process_stratum_target *target, ptid_t ptid,\n-\t\t\ttarget_waitstatus status)\n+\t\t\tconst target_waitstatus &status)\n {\n   target_last_proc_target = target;\n   target_last_wait_ptid = ptid;\n@@ -4276,10 +4290,10 @@ adjust_pc_after_break (struct thread_info *thread,\n      target with both of these set in GDB history, and it seems unlikely to be\n      correct, so gdbarch_have_nonsteppable_watchpoint is not checked here.  */\n \n-  if (ws->kind != TARGET_WAITKIND_STOPPED)\n+  if (ws->kind () != TARGET_WAITKIND_STOPPED)\n     return;\n \n-  if (ws->value.sig != GDB_SIGNAL_TRAP)\n+  if (ws->sig () != GDB_SIGNAL_TRAP)\n     return;\n \n   /* In reverse execution, when a breakpoint is hit, the instruction\n@@ -4454,8 +4468,7 @@ handle_stop_requested (struct execution_control_state *ecs)\n {\n   if (ecs->event_thread->stop_requested)\n     {\n-      ecs->ws.kind = TARGET_WAITKIND_STOPPED;\n-      ecs->ws.value.sig = GDB_SIGNAL_0;\n+      ecs->ws.set_stopped (GDB_SIGNAL_0);\n       handle_signal_stop (ecs);\n       return true;\n     }\n@@ -4476,7 +4489,7 @@ handle_syscall_event (struct execution_control_state *ecs)\n   context_switch (ecs);\n \n   regcache = get_thread_regcache (ecs->event_thread);\n-  syscall_number = ecs->ws.value.syscall_number;\n+  syscall_number = ecs->ws.syscall_number ();\n   ecs->event_thread->set_stop_pc (regcache_read_pc (regcache));\n \n   if (catch_syscall_enabled () > 0\n@@ -4612,13 +4625,13 @@ wait_one ()\n \t  event.target = target;\n \t  event.ptid = poll_one_curr_target (&event.ws);\n \n-\t  if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED)\n+\t  if (event.ws.kind () == TARGET_WAITKIND_NO_RESUMED)\n \t    {\n \t      /* If nothing is resumed, remove the target from the\n \t\t event loop.  */\n \t      target_async (0);\n \t    }\n-\t  else if (event.ws.kind != TARGET_WAITKIND_IGNORE)\n+\t  else if (event.ws.kind () != TARGET_WAITKIND_IGNORE)\n \t    return event;\n \t}\n \n@@ -4646,7 +4659,9 @@ wait_one ()\n       if (nfds == 0)\n \t{\n \t  /* No waitable targets left.  All must be stopped.  */\n-\t  return {NULL, minus_one_ptid, {TARGET_WAITKIND_NO_RESUMED}};\n+\t  target_waitstatus ws;\n+\t  ws.set_no_resumed ();\n+\t  return {NULL, minus_one_ptid, std::move (ws)};\n \t}\n \n       QUIT;\n@@ -4674,8 +4689,8 @@ save_waitstatus (struct thread_info *tp, const target_waitstatus *ws)\n   /* Record for later.  */\n   tp->set_pending_waitstatus (*ws);\n \n-  if (ws->kind == TARGET_WAITKIND_STOPPED\n-      && ws->value.sig == GDB_SIGNAL_TRAP)\n+  if (ws->kind () == TARGET_WAITKIND_STOPPED\n+      && ws->sig () == GDB_SIGNAL_TRAP)\n     {\n       struct regcache *regcache = get_thread_regcache (tp);\n       const address_space *aspace = regcache->aspace ();\n@@ -4713,14 +4728,14 @@ save_waitstatus (struct thread_info *tp, const target_waitstatus *ws)\n static void\n mark_non_executing_threads (process_stratum_target *target,\n \t\t\t    ptid_t event_ptid,\n-\t\t\t    struct target_waitstatus ws)\n+\t\t\t    const target_waitstatus &ws)\n {\n   ptid_t mark_ptid;\n \n   if (!target_is_non_stop_p ())\n     mark_ptid = minus_one_ptid;\n-  else if (ws.kind == TARGET_WAITKIND_SIGNALLED\n-\t   || ws.kind == TARGET_WAITKIND_EXITED)\n+  else if (ws.kind () == TARGET_WAITKIND_SIGNALLED\n+\t   || ws.kind () == TARGET_WAITKIND_EXITED)\n     {\n       /* If we're handling a process exit in non-stop mode, even\n \t though threads haven't been deleted yet, one would think\n@@ -4762,14 +4777,14 @@ handle_one (const wait_one_event &event)\n     (\"%s %s\", target_waitstatus_to_string (&event.ws).c_str (),\n      target_pid_to_str (event.ptid).c_str ());\n \n-  if (event.ws.kind == TARGET_WAITKIND_NO_RESUMED)\n+  if (event.ws.kind () == TARGET_WAITKIND_NO_RESUMED)\n     {\n       /* All resumed threads exited.  */\n       return true;\n     }\n-  else if (event.ws.kind == TARGET_WAITKIND_THREAD_EXITED\n-\t   || event.ws.kind == TARGET_WAITKIND_EXITED\n-\t   || event.ws.kind == TARGET_WAITKIND_SIGNALLED)\n+  else if (event.ws.kind () == TARGET_WAITKIND_THREAD_EXITED\n+\t   || event.ws.kind () == TARGET_WAITKIND_EXITED\n+\t   || event.ws.kind () == TARGET_WAITKIND_SIGNALLED)\n     {\n       /* One thread/process exited/signalled.  */\n \n@@ -4804,7 +4819,7 @@ handle_one (const wait_one_event &event)\n \t  /* Check if this is the first time we see this thread.\n \t     Don't bother adding if it individually exited.  */\n \t  if (t == nullptr\n-\t      && event.ws.kind != TARGET_WAITKIND_THREAD_EXITED)\n+\t      && event.ws.kind () != TARGET_WAITKIND_THREAD_EXITED)\n \t    t = add_thread (event.target, event.ptid);\n \t}\n \n@@ -4839,8 +4854,8 @@ handle_one (const wait_one_event &event)\n \t  setup_inferior (0);\n \t}\n \n-      if (event.ws.kind == TARGET_WAITKIND_STOPPED\n-\t  && event.ws.value.sig == GDB_SIGNAL_0)\n+      if (event.ws.kind () == TARGET_WAITKIND_STOPPED\n+\t  && event.ws.sig () == GDB_SIGNAL_0)\n \t{\n \t  /* We caught the event that we intended to catch, so\n \t     there's no event to save as pending.  */\n@@ -4871,8 +4886,8 @@ handle_one (const wait_one_event &event)\n \t  /* Record for later.  */\n \t  save_waitstatus (t, &event.ws);\n \n-\t  sig = (event.ws.kind == TARGET_WAITKIND_STOPPED\n-\t\t ? event.ws.value.sig : GDB_SIGNAL_0);\n+\t  sig = (event.ws.kind () == TARGET_WAITKIND_STOPPED\n+\t\t ? event.ws.sig () : GDB_SIGNAL_0);\n \n \t  if (displaced_step_finish (t, sig)\n \t      == DISPLACED_STEP_FINISH_STATUS_NOT_EXECUTED)\n@@ -5174,7 +5189,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \n   infrun_debug_printf (\"%s\", target_waitstatus_to_string (&ecs->ws).c_str ());\n \n-  if (ecs->ws.kind == TARGET_WAITKIND_IGNORE)\n+  if (ecs->ws.kind () == TARGET_WAITKIND_IGNORE)\n     {\n       /* We had an event in the inferior, but we are not interested in\n \t handling it at this level.  The lower layers have already\n@@ -5189,13 +5204,13 @@ handle_inferior_event (struct execution_control_state *ecs)\n       return;\n     }\n \n-  if (ecs->ws.kind == TARGET_WAITKIND_THREAD_EXITED)\n+  if (ecs->ws.kind () == TARGET_WAITKIND_THREAD_EXITED)\n     {\n       prepare_to_wait (ecs);\n       return;\n     }\n \n-  if (ecs->ws.kind == TARGET_WAITKIND_NO_RESUMED\n+  if (ecs->ws.kind () == TARGET_WAITKIND_NO_RESUMED\n       && handle_no_resumed (ecs))\n     return;\n \n@@ -5205,7 +5220,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n   /* Always clear state belonging to the previous time we stopped.  */\n   stop_stack_dummy = STOP_NONE;\n \n-  if (ecs->ws.kind == TARGET_WAITKIND_NO_RESUMED)\n+  if (ecs->ws.kind () == TARGET_WAITKIND_NO_RESUMED)\n     {\n       /* No unwaited-for children left.  IOW, all resumed children\n \t have exited.  */\n@@ -5214,8 +5229,8 @@ handle_inferior_event (struct execution_control_state *ecs)\n       return;\n     }\n \n-  if (ecs->ws.kind != TARGET_WAITKIND_EXITED\n-      && ecs->ws.kind != TARGET_WAITKIND_SIGNALLED)\n+  if (ecs->ws.kind () != TARGET_WAITKIND_EXITED\n+      && ecs->ws.kind () != TARGET_WAITKIND_SIGNALLED)\n     {\n       ecs->event_thread = find_thread_ptid (ecs->target, ecs->ptid);\n       /* If it's a new thread, add it to the thread database.  */\n@@ -5245,24 +5260,24 @@ handle_inferior_event (struct execution_control_state *ecs)\n      non-executable stack.  This happens for call dummy breakpoints\n      for architectures like SPARC that place call dummies on the\n      stack.  */\n-  if (ecs->ws.kind == TARGET_WAITKIND_STOPPED\n-      && (ecs->ws.value.sig == GDB_SIGNAL_ILL\n-\t  || ecs->ws.value.sig == GDB_SIGNAL_SEGV\n-\t  || ecs->ws.value.sig == GDB_SIGNAL_EMT))\n+  if (ecs->ws.kind () == TARGET_WAITKIND_STOPPED\n+      && (ecs->ws.sig () == GDB_SIGNAL_ILL\n+\t  || ecs->ws.sig () == GDB_SIGNAL_SEGV\n+\t  || ecs->ws.sig () == GDB_SIGNAL_EMT))\n     {\n       struct regcache *regcache = get_thread_regcache (ecs->event_thread);\n \n       if (breakpoint_inserted_here_p (regcache->aspace (),\n \t\t\t\t      regcache_read_pc (regcache)))\n \t{\n \t  infrun_debug_printf (\"Treating signal as SIGTRAP\");\n-\t  ecs->ws.value.sig = GDB_SIGNAL_TRAP;\n+\t  ecs->ws.set_stopped (GDB_SIGNAL_TRAP);\n \t}\n     }\n \n   mark_non_executing_threads (ecs->target, ecs->ptid, ecs->ws);\n \n-  switch (ecs->ws.kind)\n+  switch (ecs->ws.kind ())\n     {\n     case TARGET_WAITKIND_LOADED:\n       {\n@@ -5382,21 +5397,21 @@ handle_inferior_event (struct execution_control_state *ecs)\n       /* Clearing any previous state of convenience variables.  */\n       clear_exit_convenience_vars ();\n \n-      if (ecs->ws.kind == TARGET_WAITKIND_EXITED)\n+      if (ecs->ws.kind () == TARGET_WAITKIND_EXITED)\n \t{\n \t  /* Record the exit code in the convenience variable $_exitcode, so\n \t     that the user can inspect this again later.  */\n \t  set_internalvar_integer (lookup_internalvar (\"_exitcode\"),\n-\t\t\t\t   (LONGEST) ecs->ws.value.integer);\n+\t\t\t\t   (LONGEST) ecs->ws.exit_status ());\n \n \t  /* Also record this in the inferior itself.  */\n \t  current_inferior ()->has_exit_code = 1;\n-\t  current_inferior ()->exit_code = (LONGEST) ecs->ws.value.integer;\n+\t  current_inferior ()->exit_code = (LONGEST) ecs->ws.exit_status ();\n \n \t  /* Support the --return-child-result option.  */\n-\t  return_child_result_value = ecs->ws.value.integer;\n+\t  return_child_result_value = ecs->ws.exit_status ();\n \n-\t  gdb::observers::exited.notify (ecs->ws.value.integer);\n+\t  gdb::observers::exited.notify (ecs->ws.exit_status ());\n \t}\n       else\n \t{\n@@ -5408,7 +5423,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t\t which holds the signal uncaught by the inferior.  */\n \t      set_internalvar_integer (lookup_internalvar (\"_exitsignal\"),\n \t\t\t\t       gdbarch_gdb_signal_to_target (gdbarch,\n-\t\t\t\t\t\t\t  ecs->ws.value.sig));\n+\t\t\t\t\t\t\t  ecs->ws.sig ()));\n \t    }\n \t  else\n \t    {\n@@ -5423,7 +5438,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t\t\t\t   \"signal number.\");\n \t    }\n \n-\t  gdb::observers::signal_exited.notify (ecs->ws.value.sig);\n+\t  gdb::observers::signal_exited.notify (ecs->ws.sig ());\n \t}\n \n       gdb_flush (gdb_stdout);\n@@ -5450,10 +5465,10 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t   gdbarch_displaced_step_restore_all_in_ptid.  This is not\n \t   enforced during gdbarch validation to support architectures\n \t   which support displaced stepping but not forks.  */\n-\tif (ecs->ws.kind == TARGET_WAITKIND_FORKED\n+\tif (ecs->ws.kind () == TARGET_WAITKIND_FORKED\n \t    && gdbarch_supports_displaced_stepping (gdbarch))\n \t  gdbarch_displaced_step_restore_all_in_ptid\n-\t    (gdbarch, parent_inf, ecs->ws.value.related_pid);\n+\t    (gdbarch, parent_inf, ecs->ws.child_ptid ());\n \n \t/* If displaced stepping is supported, and thread ecs->ptid is\n \t   displaced stepping.  */\n@@ -5481,7 +5496,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \n \t    child_regcache\n \t      = get_thread_arch_aspace_regcache (parent_inf->process_target (),\n-\t\t\t\t\t\t ecs->ws.value.related_pid,\n+\t\t\t\t\t\t ecs->ws.child_ptid (),\n \t\t\t\t\t\t gdbarch,\n \t\t\t\t\t\t parent_inf->aspace);\n \t    /* Read PC value of parent process.  */\n@@ -5510,11 +5525,11 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t need to unpatch at follow/detach time instead to be certain\n \t that new breakpoints added between catchpoint hit time and\n \t vfork follow are detached.  */\n-      if (ecs->ws.kind != TARGET_WAITKIND_VFORKED)\n+      if (ecs->ws.kind () != TARGET_WAITKIND_VFORKED)\n \t{\n \t  /* This won't actually modify the breakpoint list, but will\n \t     physically remove the breakpoints from the child.  */\n-\t  detach_breakpoints (ecs->ws.value.related_pid);\n+\t  detach_breakpoints (ecs->ws.child_ptid ());\n \t}\n \n       delete_just_stopped_threads_single_step_breakpoints ();\n@@ -5554,8 +5569,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t  /* Note that one of these may be an invalid pointer,\n \t     depending on detach_fork.  */\n \t  thread_info *parent = ecs->event_thread;\n-\t  thread_info *child\n-\t    = find_thread_ptid (targ, ecs->ws.value.related_pid);\n+\t  thread_info *child = find_thread_ptid (targ, ecs->ws.child_ptid ());\n \n \t  /* At this point, the parent is marked running, and the\n \t     child is marked stopped.  */\n@@ -5629,7 +5643,7 @@ handle_inferior_event (struct execution_control_state *ecs)\n       /* This causes the eventpoints and symbol table to be reset.\n \t Must do this now, before trying to determine whether to\n \t stop.  */\n-      follow_exec (inferior_ptid, ecs->ws.value.execd_pathname);\n+      follow_exec (inferior_ptid, ecs->ws.execd_pathname ());\n \n       /* In follow_exec we may have deleted the original thread and\n \t created a new one.  Make sure that the event thread is the\n@@ -5644,11 +5658,6 @@ handle_inferior_event (struct execution_control_state *ecs)\n \t\t\t      ecs->event_thread->stop_pc (),\n \t\t\t      ecs->event_thread, &ecs->ws);\n \n-      /* Note that this may be referenced from inside\n-\t bpstat_stop_status above, through inferior_has_execd.  */\n-      xfree (ecs->ws.value.execd_pathname);\n-      ecs->ws.value.execd_pathname = NULL;\n-\n       if (handle_stop_requested (ecs))\n \treturn;\n \n@@ -5928,9 +5937,9 @@ handle_signal_stop (struct execution_control_state *ecs)\n   enum stop_kind stop_soon;\n   int random_signal;\n \n-  gdb_assert (ecs->ws.kind == TARGET_WAITKIND_STOPPED);\n+  gdb_assert (ecs->ws.kind () == TARGET_WAITKIND_STOPPED);\n \n-  ecs->event_thread->set_stop_signal (ecs->ws.value.sig);\n+  ecs->event_thread->set_stop_signal (ecs->ws.sig ());\n \n   /* Do we need to clean up the state of a thread that has\n      completed a displaced single-step?  (Doing so usually affects\n@@ -8265,7 +8274,7 @@ print_stop_location (struct target_waitstatus *ws)\n   int do_frame_printing = 1;\n   struct thread_info *tp = inferior_thread ();\n \n-  bpstat_ret = bpstat_print (tp->control.stop_bpstat, ws->kind);\n+  bpstat_ret = bpstat_print (tp->control.stop_bpstat, ws->kind ());\n   switch (bpstat_ret)\n     {\n     case PRINT_UNKNOWN:\n@@ -8440,8 +8449,8 @@ normal_stop (void)\n \n   if (!non_stop)\n     finish_ptid = minus_one_ptid;\n-  else if (last.kind == TARGET_WAITKIND_SIGNALLED\n-\t   || last.kind == TARGET_WAITKIND_EXITED)\n+  else if (last.kind () == TARGET_WAITKIND_SIGNALLED\n+\t   || last.kind () == TARGET_WAITKIND_EXITED)\n     {\n       /* On some targets, we may still have live threads in the\n \t inferior when we get a process exit event.  E.g., for\n@@ -8451,7 +8460,7 @@ normal_stop (void)\n       if (inferior_ptid != null_ptid)\n \tfinish_ptid = ptid_t (inferior_ptid.pid ());\n     }\n-  else if (last.kind != TARGET_WAITKIND_NO_RESUMED)\n+  else if (last.kind () != TARGET_WAITKIND_NO_RESUMED)\n     finish_ptid = inferior_ptid;\n \n   gdb::optional<scoped_finish_thread_state> maybe_finish_thread_state;\n@@ -8471,7 +8480,7 @@ normal_stop (void)\n      instead of after.  */\n   update_thread_list ();\n \n-  if (last.kind == TARGET_WAITKIND_STOPPED && stopped_by_random_signal)\n+  if (last.kind () == TARGET_WAITKIND_STOPPED && stopped_by_random_signal)\n     gdb::observers::signal_received.notify (inferior_thread ()->stop_signal ());\n \n   /* As with the notification of thread events, we want to delay\n@@ -8493,9 +8502,9 @@ normal_stop (void)\n   if (!non_stop\n       && previous_inferior_ptid != inferior_ptid\n       && target_has_execution ()\n-      && last.kind != TARGET_WAITKIND_SIGNALLED\n-      && last.kind != TARGET_WAITKIND_EXITED\n-      && last.kind != TARGET_WAITKIND_NO_RESUMED)\n+      && last.kind () != TARGET_WAITKIND_SIGNALLED\n+      && last.kind () != TARGET_WAITKIND_EXITED\n+      && last.kind () != TARGET_WAITKIND_NO_RESUMED)\n     {\n       SWITCH_THRU_ALL_UIS ()\n \t{\n@@ -8507,7 +8516,7 @@ normal_stop (void)\n       previous_inferior_ptid = inferior_ptid;\n     }\n \n-  if (last.kind == TARGET_WAITKIND_NO_RESUMED)\n+  if (last.kind () == TARGET_WAITKIND_NO_RESUMED)\n     {\n       SWITCH_THRU_ALL_UIS ()\n \tif (current_ui->prompt_state == PROMPT_BLOCKED)\n@@ -8599,9 +8608,9 @@ normal_stop (void)\n \n   if (target_has_execution ())\n     {\n-      if (last.kind != TARGET_WAITKIND_SIGNALLED\n-\t  && last.kind != TARGET_WAITKIND_EXITED\n-\t  && last.kind != TARGET_WAITKIND_NO_RESUMED)\n+      if (last.kind () != TARGET_WAITKIND_SIGNALLED\n+\t  && last.kind () != TARGET_WAITKIND_EXITED\n+\t  && last.kind () != TARGET_WAITKIND_NO_RESUMED)\n \t/* Delete the breakpoint we stopped at, if it wants to be deleted.\n \t   Delete any breakpoint that is to be deleted at the next stop.  */\n \tbreakpoint_auto_delete (inferior_thread ()->control.stop_bpstat);"
    },
    {
      "sha": "c5f98d9d305a43f4a366b3918817f7f3ae2bae89",
      "filename": "gdb/infrun.h",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/infrun.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/infrun.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/infrun.h?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -133,7 +133,7 @@ extern void get_last_target_status (process_stratum_target **target,\n \n /* Set the cached copy of the last target/ptid/waitstatus.  */\n extern void set_last_target_status (process_stratum_target *target, ptid_t ptid,\n-\t\t\t\t    struct target_waitstatus status);\n+\t\t\t\t    const target_waitstatus &status);\n \n /* Clear the cached copy of the last ptid/waitstatus returned by\n    target_wait().  */"
    },
    {
      "sha": "cada889c5348eb5c8841aee8f2d2438d61b58ec1",
      "filename": "gdb/linux-nat.c",
      "status": "modified",
      "additions": 36,
      "deletions": 33,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/linux-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/linux-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -575,7 +575,7 @@ linux_nat_target::follow_fork (inferior *child_inf, ptid_t child_ptid,\n \t\t will notice a pending event, and bypasses actually\n \t\t resuming the inferior.  */\n \t      parent_lp->status = 0;\n-\t      parent_lp->waitstatus.kind = TARGET_WAITKIND_VFORK_DONE;\n+\t      parent_lp->waitstatus.set_vfork_done ();\n \t      parent_lp->stopped = 1;\n \n \t      /* If we're in async mode, need to tell the event loop\n@@ -1257,7 +1257,7 @@ get_detach_signal (struct lwp_info *lp)\n      signal pass state).  Normally SIGTRAP isn't set to pass state, so\n      this is really a corner case.  */\n \n-  if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)\n+  if (lp->waitstatus.kind () != TARGET_WAITKIND_IGNORE)\n     signo = GDB_SIGNAL_0; /* a pending ptrace event, not a real signal.  */\n   else if (lp->status)\n     signo = gdb_signal_from_host (WSTOPSIG (lp->status));\n@@ -1268,7 +1268,7 @@ get_detach_signal (struct lwp_info *lp)\n       if (target_is_non_stop_p () && !tp->executing ())\n \t{\n \t  if (tp->has_pending_waitstatus ())\n-\t    signo = tp->pending_waitstatus ().value.sig;\n+\t    signo = tp->pending_waitstatus ().sig ();\n \t  else\n \t    signo = tp->stop_signal ();\n \t}\n@@ -1520,7 +1520,7 @@ check_ptrace_stopped_lwp_gone (struct lwp_info *lp)\n     {\n       lp->stop_reason = TARGET_STOPPED_BY_NO_REASON;\n       lp->status = 0;\n-      lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+      lp->waitstatus.set_ignore ();\n       return 1;\n     }\n   return 0;\n@@ -1793,8 +1793,12 @@ linux_handle_syscall_trap (struct lwp_info *lp, int stopping)\n       if (catching_syscall_number (syscall_number))\n \t{\n \t  /* Alright, an event to report.  */\n-\t  ourstatus->kind = lp->syscall_state;\n-\t  ourstatus->value.syscall_number = syscall_number;\n+\t  if (lp->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY)\n+\t    ourstatus->set_syscall_entry (syscall_number);\n+\t  else if (lp->syscall_state == TARGET_WAITKIND_SYSCALL_RETURN)\n+\t    ourstatus->set_syscall_return (syscall_number);\n+\t  else\n+\t    gdb_assert_not_reached (\"unexpected syscall state\");\n \n \t  linux_nat_debug_printf\n \t    (\"stopping for %s of syscall %d for LWP %ld\",\n@@ -1886,7 +1890,7 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \t\t\t    _(\"wait returned unexpected status 0x%x\"), status);\n \t}\n \n-      ourstatus->value.related_pid = ptid_t (new_pid, new_pid);\n+      ptid_t child_ptid (new_pid, new_pid);\n \n       if (event == PTRACE_EVENT_FORK || event == PTRACE_EVENT_VFORK)\n \t{\n@@ -1918,21 +1922,21 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \t  /* Report as spurious, so that infrun doesn't want to follow\n \t     this fork.  We're actually doing an infcall in\n \t     linux-fork.c.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ourstatus->set_spurious ();\n \n \t  /* Report the stop to the core.  */\n \t  return 0;\n \t}\n \n       if (event == PTRACE_EVENT_FORK)\n-\tourstatus->kind = TARGET_WAITKIND_FORKED;\n+\tourstatus->set_forked (child_ptid);\n       else if (event == PTRACE_EVENT_VFORK)\n-\tourstatus->kind = TARGET_WAITKIND_VFORKED;\n+\tourstatus->set_vforked (child_ptid);\n       else if (event == PTRACE_EVENT_CLONE)\n \t{\n \t  struct lwp_info *new_lp;\n \n-\t  ourstatus->kind = TARGET_WAITKIND_IGNORE;\n+\t  ourstatus->set_ignore ();\n \n \t  linux_nat_debug_printf\n \t    (\"Got clone event from LWP %d, new child is LWP %ld\", pid, new_pid);\n@@ -1981,7 +1985,7 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \t    }\n \t  else if (report_thread_events)\n \t    {\n-\t      new_lp->waitstatus.kind = TARGET_WAITKIND_THREAD_CREATED;\n+\t      new_lp->waitstatus.set_thread_created ();\n \t      new_lp->status = status;\n \t    }\n \n@@ -1999,9 +2003,8 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \t inferior.  */\n       maybe_close_proc_mem_file (lp->ptid.pid ());\n \n-      ourstatus->kind = TARGET_WAITKIND_EXECD;\n-      ourstatus->value.execd_pathname\n-\t= xstrdup (linux_proc_pid_to_exec_file (pid));\n+      ourstatus->set_execd\n+\t(make_unique_xstrdup (linux_proc_pid_to_exec_file (pid)));\n \n       /* The thread that execed must have been resumed, but, when a\n \t thread execs, it changes its tid to the tgid, and the old\n@@ -2018,7 +2021,7 @@ linux_handle_extended_wait (struct lwp_info *lp, int status)\n \t    (\"Got expected PTRACE_EVENT_VFORK_DONE from LWP %ld: stopping\",\n \t     lp->ptid.lwp ());\n \n-\t  ourstatus->kind = TARGET_WAITKIND_VFORK_DONE;\n+\t  ourstatus->set_vfork_done ();\n \t  return 0;\n \t}\n \n@@ -2538,7 +2541,7 @@ lwp_status_pending_p (struct lwp_info *lp)\n   /* We check for lp->waitstatus in addition to lp->status, because we\n      can have pending process exits recorded in lp->status and\n      W_EXITCODE(0,0) happens to be 0.  */\n-  return lp->status != 0 || lp->waitstatus.kind != TARGET_WAITKIND_IGNORE;\n+  return lp->status != 0 || lp->waitstatus.kind () != TARGET_WAITKIND_IGNORE;\n }\n \n /* Select the Nth LWP that has had an event.  */\n@@ -3085,9 +3088,9 @@ filter_exit_event (struct lwp_info *event_child,\n   if (num_lwps (ptid.pid ()) > 1)\n     {\n       if (report_thread_events)\n-\tourstatus->kind = TARGET_WAITKIND_THREAD_EXITED;\n+\tourstatus->set_thread_exited (0);\n       else\n-\tourstatus->kind = TARGET_WAITKIND_IGNORE;\n+\tourstatus->set_ignore ();\n \n       exit_lwp (event_child);\n     }\n@@ -3195,7 +3198,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t{\n \t  linux_nat_debug_printf (\"exit (no resumed LWP)\");\n \n-\t  ourstatus->kind = TARGET_WAITKIND_NO_RESUMED;\n+\t  ourstatus->set_no_resumed ();\n \n \t  restore_child_signals_mask (&prev_mask);\n \t  return minus_one_ptid;\n@@ -3207,7 +3210,7 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t{\n \t  linux_nat_debug_printf (\"exit (ignore)\");\n \n-\t  ourstatus->kind = TARGET_WAITKIND_IGNORE;\n+\t  ourstatus->set_ignore ();\n \t  restore_child_signals_mask (&prev_mask);\n \t  return minus_one_ptid;\n \t}\n@@ -3283,10 +3286,10 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t\t\t      target_pid_to_str (lp->ptid).c_str ());\n     }\n \n-  if (lp->waitstatus.kind != TARGET_WAITKIND_IGNORE)\n+  if (lp->waitstatus.kind () != TARGET_WAITKIND_IGNORE)\n     {\n       *ourstatus = lp->waitstatus;\n-      lp->waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+      lp->waitstatus.set_ignore ();\n     }\n   else\n     store_waitstatus (ourstatus, status);\n@@ -3296,22 +3299,22 @@ linux_nat_wait_1 (ptid_t ptid, struct target_waitstatus *ourstatus,\n   restore_child_signals_mask (&prev_mask);\n \n   if (last_resume_kind == resume_stop\n-      && ourstatus->kind == TARGET_WAITKIND_STOPPED\n+      && ourstatus->kind () == TARGET_WAITKIND_STOPPED\n       && WSTOPSIG (status) == SIGSTOP)\n     {\n       /* A thread that has been requested to stop by GDB with\n \t target_stop, and it stopped cleanly, so report as SIG0.  The\n \t use of SIGSTOP is an implementation detail.  */\n-      ourstatus->value.sig = GDB_SIGNAL_0;\n+      ourstatus->set_stopped (GDB_SIGNAL_0);\n     }\n \n-  if (ourstatus->kind == TARGET_WAITKIND_EXITED\n-      || ourstatus->kind == TARGET_WAITKIND_SIGNALLED)\n+  if (ourstatus->kind () == TARGET_WAITKIND_EXITED\n+      || ourstatus->kind () == TARGET_WAITKIND_SIGNALLED)\n     lp->core = -1;\n   else\n     lp->core = linux_common_core_of_thread (lp->ptid);\n \n-  if (ourstatus->kind == TARGET_WAITKIND_EXITED)\n+  if (ourstatus->kind () == TARGET_WAITKIND_EXITED)\n     return filter_exit_event (lp, ourstatus);\n \n   return lp->ptid;\n@@ -3409,8 +3412,8 @@ linux_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n      may be more.  If we requested a specific lwp or process, also\n      assume there may be more.  */\n   if (target_is_async_p ()\n-      && ((ourstatus->kind != TARGET_WAITKIND_IGNORE\n-\t   && ourstatus->kind != TARGET_WAITKIND_NO_RESUMED)\n+      && ((ourstatus->kind () != TARGET_WAITKIND_IGNORE\n+\t   && ourstatus->kind () != TARGET_WAITKIND_NO_RESUMED)\n \t  || ptid != minus_one_ptid))\n     async_file_mark ();\n \n@@ -3508,10 +3511,10 @@ kill_unfollowed_fork_children (struct inferior *inf)\n     {\n       struct target_waitstatus *ws = &thread->pending_follow;\n \n-      if (ws->kind == TARGET_WAITKIND_FORKED\n-\t  || ws->kind == TARGET_WAITKIND_VFORKED)\n+      if (ws->kind () == TARGET_WAITKIND_FORKED\n+\t  || ws->kind () == TARGET_WAITKIND_VFORKED)\n \t{\n-\t  ptid_t child_ptid = ws->value.related_pid;\n+\t  ptid_t child_ptid = ws->child_ptid ();\n \t  int child_pid = child_ptid.pid ();\n \t  int child_lwp = child_ptid.lwp ();\n "
    },
    {
      "sha": "95e26b7ee4607ad71ff29890b0f72126e843ca34",
      "filename": "gdb/linux-nat.h",
      "status": "modified",
      "additions": 2,
      "deletions": 4,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/linux-nat.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/linux-nat.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-nat.h?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -202,17 +202,15 @@ struct lwp_info : intrusive_list_node<lwp_info>\n {\n   lwp_info (ptid_t ptid)\n     : ptid (ptid)\n-  {\n-    waitstatus.kind = TARGET_WAITKIND_IGNORE;\n-  }\n+  {}\n \n   ~lwp_info ();\n \n   DISABLE_COPY_AND_ASSIGN (lwp_info);\n \n   /* The process id of the LWP.  This is a combination of the LWP id\n      and overall process id.  */\n-  ptid_t ptid;\n+  ptid_t ptid = null_ptid;\n \n   /* If this flag is set, we need to set the event request flags the\n      next time we see this LWP stop.  */"
    },
    {
      "sha": "c2a3f54d43c499ef0e8dde5ae2079ecf97344555",
      "filename": "gdb/linux-thread-db.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/linux-thread-db.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/linux-thread-db.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/linux-thread-db.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -1407,7 +1407,7 @@ thread_db_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n   ptid = beneath->wait (ptid, ourstatus, options);\n \n-  switch (ourstatus->kind)\n+  switch (ourstatus->kind ())\n     {\n     case TARGET_WAITKIND_IGNORE:\n     case TARGET_WAITKIND_EXITED:"
    },
    {
      "sha": "fc19f17a4f6e5c59c9c47bd98837ee85b885a25a",
      "filename": "gdb/nat/fork-inferior.c",
      "status": "modified",
      "additions": 7,
      "deletions": 12,
      "changes": 19,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/nat/fork-inferior.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/nat/fork-inferior.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/fork-inferior.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -479,19 +479,18 @@ startup_inferior (process_stratum_target *proc_target, pid_t pid, int ntraps,\n       ptid_t event_ptid;\n \n       struct target_waitstatus ws;\n-      memset (&ws, 0, sizeof (ws));\n       event_ptid = target_wait (resume_ptid, &ws, 0);\n \n       if (last_waitstatus != NULL)\n \t*last_waitstatus = ws;\n       if (last_ptid != NULL)\n \t*last_ptid = event_ptid;\n \n-      if (ws.kind == TARGET_WAITKIND_IGNORE)\n+      if (ws.kind () == TARGET_WAITKIND_IGNORE)\n \t/* The inferior didn't really stop, keep waiting.  */\n \tcontinue;\n \n-      switch (ws.kind)\n+      switch (ws.kind ())\n \t{\n \t  case TARGET_WAITKIND_SPURIOUS:\n \t  case TARGET_WAITKIND_LOADED:\n@@ -507,32 +506,28 @@ startup_inferior (process_stratum_target *proc_target, pid_t pid, int ntraps,\n \t    target_terminal::ours ();\n \t    target_mourn_inferior (event_ptid);\n \t    error (_(\"During startup program terminated with signal %s, %s.\"),\n-\t\t   gdb_signal_to_name (ws.value.sig),\n-\t\t   gdb_signal_to_string (ws.value.sig));\n+\t\t   gdb_signal_to_name (ws.sig ()),\n+\t\t   gdb_signal_to_string (ws.sig ()));\n \t    return resume_ptid;\n \n \t  case TARGET_WAITKIND_EXITED:\n \t    target_terminal::ours ();\n \t    target_mourn_inferior (event_ptid);\n-\t    if (ws.value.integer)\n+\t    if (ws.exit_status ())\n \t      error (_(\"During startup program exited with code %d.\"),\n-\t\t     ws.value.integer);\n+\t\t     ws.exit_status ());\n \t    else\n \t      error (_(\"During startup program exited normally.\"));\n \t    return resume_ptid;\n \n \t  case TARGET_WAITKIND_EXECD:\n \t    /* Handle EXEC signals as if they were SIGTRAP signals.  */\n-\t    /* Free the exec'ed pathname, but only if this isn't the\n-\t       waitstatus we are returning to the caller.  */\n-\t    if (pending_execs != 1)\n-\t      xfree (ws.value.execd_pathname);\n \t    resume_signal = GDB_SIGNAL_TRAP;\n \t    switch_to_thread (proc_target, event_ptid);\n \t    break;\n \n \t  case TARGET_WAITKIND_STOPPED:\n-\t    resume_signal = ws.value.sig;\n+\t    resume_signal = ws.sig ();\n \t    switch_to_thread (proc_target, event_ptid);\n \t    break;\n \t}"
    },
    {
      "sha": "fa0ed56175aec06ee1fee8a0a96f32bf58542108",
      "filename": "gdb/nat/windows-nat.c",
      "status": "modified",
      "additions": 26,
      "deletions": 26,
      "changes": 52,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/nat/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/nat/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/windows-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -197,8 +197,6 @@ handle_exception (struct target_waitstatus *ourstatus, bool debug_exceptions)\n \n   memcpy (&siginfo_er, rec, sizeof siginfo_er);\n \n-  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\n   /* Record the context of the current thread.  */\n   thread_rec (ptid_t (current_event.dwProcessId, current_event.dwThreadId, 0),\n \t      DONT_SUSPEND);\n@@ -207,53 +205,53 @@ handle_exception (struct target_waitstatus *ourstatus, bool debug_exceptions)\n     {\n     case EXCEPTION_ACCESS_VIOLATION:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ACCESS_VIOLATION\");\n-      ourstatus->value.sig = GDB_SIGNAL_SEGV;\n+      ourstatus->set_stopped (GDB_SIGNAL_SEGV);\n       if (handle_access_violation (rec))\n \treturn HANDLE_EXCEPTION_UNHANDLED;\n       break;\n     case STATUS_STACK_OVERFLOW:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_STACK_OVERFLOW\");\n-      ourstatus->value.sig = GDB_SIGNAL_SEGV;\n+      ourstatus->set_stopped (GDB_SIGNAL_SEGV);\n       break;\n     case STATUS_FLOAT_DENORMAL_OPERAND:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_DENORMAL_OPERAND\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case EXCEPTION_ARRAY_BOUNDS_EXCEEDED:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ARRAY_BOUNDS_EXCEEDED\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case STATUS_FLOAT_INEXACT_RESULT:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_INEXACT_RESULT\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case STATUS_FLOAT_INVALID_OPERATION:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_INVALID_OPERATION\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case STATUS_FLOAT_OVERFLOW:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_OVERFLOW\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case STATUS_FLOAT_STACK_CHECK:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_STACK_CHECK\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case STATUS_FLOAT_UNDERFLOW:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_UNDERFLOW\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case STATUS_FLOAT_DIVIDE_BY_ZERO:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_FLOAT_DIVIDE_BY_ZERO\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case STATUS_INTEGER_DIVIDE_BY_ZERO:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_INTEGER_DIVIDE_BY_ZERO\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case STATUS_INTEGER_OVERFLOW:\n       DEBUG_EXCEPTION_SIMPLE (\"STATUS_INTEGER_OVERFLOW\");\n-      ourstatus->value.sig = GDB_SIGNAL_FPE;\n+      ourstatus->set_stopped (GDB_SIGNAL_FPE);\n       break;\n     case EXCEPTION_BREAKPOINT:\n #ifdef __x86_64__\n@@ -263,7 +261,7 @@ handle_exception (struct target_waitstatus *ourstatus, bool debug_exceptions)\n \t     on startup, first a BREAKPOINT for the 64bit ntdll.dll,\n \t     then a WX86_BREAKPOINT for the 32bit ntdll.dll.\n \t     Here we only care about the WX86_BREAKPOINT's.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ourstatus->set_spurious ();\n \t  ignore_first_breakpoint = false;\n \t}\n       else if (wow64_process)\n@@ -277,45 +275,45 @@ handle_exception (struct target_waitstatus *ourstatus, bool debug_exceptions)\n \t     unconditionally.  */\n \t  DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_BREAKPOINT\");\n \t  rec->ExceptionCode = DBG_CONTROL_C;\n-\t  ourstatus->value.sig = GDB_SIGNAL_INT;\n+\t  ourstatus->set_stopped (GDB_SIGNAL_INT);\n \t  break;\n \t}\n #endif\n       /* FALLTHROUGH */\n     case STATUS_WX86_BREAKPOINT:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_BREAKPOINT\");\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n+      ourstatus->set_stopped (GDB_SIGNAL_TRAP);\n       break;\n     case DBG_CONTROL_C:\n       DEBUG_EXCEPTION_SIMPLE (\"DBG_CONTROL_C\");\n-      ourstatus->value.sig = GDB_SIGNAL_INT;\n+      ourstatus->set_stopped (GDB_SIGNAL_INT);\n       break;\n     case DBG_CONTROL_BREAK:\n       DEBUG_EXCEPTION_SIMPLE (\"DBG_CONTROL_BREAK\");\n-      ourstatus->value.sig = GDB_SIGNAL_INT;\n+      ourstatus->set_stopped (GDB_SIGNAL_INT);\n       break;\n     case EXCEPTION_SINGLE_STEP:\n     case STATUS_WX86_SINGLE_STEP:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_SINGLE_STEP\");\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n+      ourstatus->set_stopped (GDB_SIGNAL_TRAP);\n       break;\n     case EXCEPTION_ILLEGAL_INSTRUCTION:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_ILLEGAL_INSTRUCTION\");\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n+      ourstatus->set_stopped (GDB_SIGNAL_ILL);\n       break;\n     case EXCEPTION_PRIV_INSTRUCTION:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_PRIV_INSTRUCTION\");\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n+      ourstatus->set_stopped (GDB_SIGNAL_ILL);\n       break;\n     case EXCEPTION_NONCONTINUABLE_EXCEPTION:\n       DEBUG_EXCEPTION_SIMPLE (\"EXCEPTION_NONCONTINUABLE_EXCEPTION\");\n-      ourstatus->value.sig = GDB_SIGNAL_ILL;\n+      ourstatus->set_stopped (GDB_SIGNAL_ILL);\n       break;\n     case MS_VC_EXCEPTION:\n       DEBUG_EXCEPTION_SIMPLE (\"MS_VC_EXCEPTION\");\n       if (handle_ms_vc_exception (rec))\n \t{\n-\t  ourstatus->value.sig = GDB_SIGNAL_TRAP;\n+\t  ourstatus->set_stopped (GDB_SIGNAL_TRAP);\n \t  result = HANDLE_EXCEPTION_IGNORED;\n \t  break;\n \t}\n@@ -329,11 +327,13 @@ handle_exception (struct target_waitstatus *ourstatus, bool debug_exceptions)\n \t(unsigned) current_event.u.Exception.ExceptionRecord.ExceptionCode,\n \thost_address_to_string (\n \t  current_event.u.Exception.ExceptionRecord.ExceptionAddress));\n-      ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;\n+      ourstatus->set_stopped (GDB_SIGNAL_UNKNOWN);\n       break;\n     }\n \n-  last_sig = ourstatus->value.sig;\n+  if (ourstatus->kind () == TARGET_WAITKIND_STOPPED)\n+    last_sig = ourstatus->sig ();\n+\n   return result;\n \n #undef DEBUG_EXCEPTION_SIMPLE"
    },
    {
      "sha": "e06c036fcdd3b8515931726ae416cd05785a7bdd",
      "filename": "gdb/netbsd-nat.c",
      "status": "modified",
      "additions": 12,
      "deletions": 14,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/netbsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/netbsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/netbsd-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -576,7 +576,7 @@ nbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n   ptid_t wptid = ptid_t (pid);\n \n   /* If the child stopped, keep investigating its status.  */\n-  if (ourstatus->kind != TARGET_WAITKIND_STOPPED)\n+  if (ourstatus->kind () != TARGET_WAITKIND_STOPPED)\n     return wptid;\n \n   /* Extract the event and thread that received a signal.  */\n@@ -620,12 +620,11 @@ nbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t Ignore exited events for an unknown LWP.  */\n       thread_info *thr = find_thread_ptid (this, wptid);\n       if (thr == nullptr)\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ourstatus->set_spurious ();\n       else\n \t{\n-\t  ourstatus->kind = TARGET_WAITKIND_THREAD_EXITED;\n \t  /* NetBSD does not store an LWP exit status.  */\n-\t  ourstatus->value.integer = 0;\n+\t  ourstatus->set_thread_exited (0);\n \n \t  if (print_thread_events)\n \t    printf_unfiltered (_(\"[%s exited]\\n\"),\n@@ -650,19 +649,18 @@ nbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t not yet reported their PTRACE_LWP_CREATE event.  Ignore\n \t born events for an already-known LWP.  */\n       if (in_thread_list (this, wptid))\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ourstatus->set_spurious ();\n       else\n \t{\n \t  add_thread (this, wptid);\n-\t  ourstatus->kind = TARGET_WAITKIND_THREAD_CREATED;\n+\t  ourstatus->set_thread_created ();\n \t}\n       return wptid;\n     }\n \n   if (code == TRAP_EXEC)\n     {\n-      ourstatus->kind = TARGET_WAITKIND_EXECD;\n-      ourstatus->value.execd_pathname = xstrdup (pid_to_exec_file (pid));\n+      ourstatus->set_execd (make_unique_xstrdup (pid_to_exec_file (pid)));\n       return wptid;\n     }\n \n@@ -679,14 +677,14 @@ nbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n       if (!catch_syscall_enabled () || !catching_syscall_number (sysnum))\n \t{\n \t  /* If the core isn't interested in this event, ignore it.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ourstatus->set_spurious ();\n \t  return wptid;\n \t}\n \n-      ourstatus->kind =\n-\t(code == TRAP_SCE) ? TARGET_WAITKIND_SYSCALL_ENTRY :\n-\tTARGET_WAITKIND_SYSCALL_RETURN;\n-      ourstatus->value.syscall_number = sysnum;\n+      if (code == TRAP_SCE)\n+\tourstatus->set_syscall_entry (sysnum);\n+      else\n+\tourstatus->set_syscall_return (sysnum);\n       return wptid;\n     }\n \n@@ -697,7 +695,7 @@ nbsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n     }\n \n   /* Unclassified SIGTRAP event.  */\n-  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+  ourstatus->set_spurious ();\n   return wptid;\n }\n "
    },
    {
      "sha": "365610360a96d477ad965ca2befdf3ea1dae7fe9",
      "filename": "gdb/nto-procfs.c",
      "status": "modified",
      "additions": 12,
      "deletions": 25,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/nto-procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/nto-procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nto-procfs.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -802,12 +802,11 @@ nto_procfs_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n   procfs_status status;\n   static int exit_signo = 0;\t/* To track signals that cause termination.  */\n \n-  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+  ourstatus->set_spurious ();\n \n   if (inferior_ptid == null_ptid)\n     {\n-      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-      ourstatus->value.sig = GDB_SIGNAL_0;\n+      ourstatus->set_stopped (GDB_SIGNAL_0);\n       exit_signo = 0;\n       return null_ptid;\n     }\n@@ -828,38 +827,29 @@ nto_procfs_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n   nto_inferior_data (NULL)->stopped_pc = status.ip;\n \n   if (status.flags & _DEBUG_FLAG_SSTEP)\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-    }\n+    ourstatus->set_stopped (GDB_SIGNAL_TRAP);\n   /* Was it a breakpoint?  */\n   else if (status.flags & _DEBUG_FLAG_TRACE)\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n-    }\n+    ourstatus->set_stopped (GDB_SIGNAL_TRAP);\n   else if (status.flags & _DEBUG_FLAG_ISTOP)\n     {\n       switch (status.why)\n \t{\n \tcase _DEBUG_WHY_SIGNALLED:\n-\t  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\t  ourstatus->value.sig =\n-\t    gdb_signal_from_host (status.info.si_signo);\n+\t  ourstatus->set_stopped (gdb_signal_from_host (status.info.si_signo));\n \t  exit_signo = 0;\n \t  break;\n \tcase _DEBUG_WHY_FAULTED:\n-\t  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n \t  if (status.info.si_signo == SIGTRAP)\n \t    {\n-\t      ourstatus->value.sig = 0;\n+\t      ourstatus->set_stopped (0);\n \t      exit_signo = 0;\n \t    }\n \t  else\n \t    {\n-\t      ourstatus->value.sig =\n-\t\tgdb_signal_from_host (status.info.si_signo);\n-\t      exit_signo = ourstatus->value.sig;\n+\t      ourstatus->set_stopped\n+\t\t(gdb_signal_from_host (status.info.si_signo));\n+\t      exit_signo = ourstatus->sig ();\n \t    }\n \t  break;\n \n@@ -871,23 +861,20 @@ nto_procfs_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t    if (exit_signo)\n \t      {\n \t\t/* Abnormal death.  */\n-\t\tourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-\t\tourstatus->value.sig = exit_signo;\n+\t\tourstatus->set_signalled (exit_signo);\n \t      }\n \t    else\n \t      {\n \t\t/* Normal death.  */\n-\t\tourstatus->kind = TARGET_WAITKIND_EXITED;\n-\t\tourstatus->value.integer = WEXITSTATUS (waitval);\n+\t\tourstatus->set_exited (WEXITSTATUS (waitval));\n \t      }\n \t    exit_signo = 0;\n \t    break;\n \t  }\n \n \tcase _DEBUG_WHY_REQUESTED:\n \t  /* We are assuming a requested stop is due to a SIGINT.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\t  ourstatus->value.sig = GDB_SIGNAL_INT;\n+\t  ourstatus->set_stopped (GDB_SIGNAL_INT);\n \t  exit_signo = 0;\n \t  break;\n \t}"
    },
    {
      "sha": "c70820d60d022b2fdec94cab010de7920d23d116",
      "filename": "gdb/obsd-nat.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/obsd-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/obsd-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/obsd-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -90,7 +90,7 @@ obsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t\t       target_wait_flags options)\n {\n   ptid_t wptid = inf_ptrace_target::wait (ptid, ourstatus, options);\n-  if (ourstatus->kind == TARGET_WAITKIND_STOPPED)\n+  if (ourstatus->kind () == TARGET_WAITKIND_STOPPED)\n     {\n       ptrace_state_t pe;\n \n@@ -103,8 +103,7 @@ obsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n       switch (pe.pe_report_event)\n \t{\n \tcase PTRACE_FORK:\n-\t  ourstatus->kind = TARGET_WAITKIND_FORKED;\n-\t  ourstatus->value.related_pid = ptid_t (pe.pe_other_pid);\n+\t  ourstatus->set_forked (ptid_t (pe.pe_other_pid));\n \n \t  /* Make sure the other end of the fork is stopped too.  */\n \t  pid_t fpid = waitpid (pe.pe_other_pid, nullptr, 0);\n@@ -119,11 +118,11 @@ obsd_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t  gdb_assert (pe.pe_other_pid == pid);\n \t  if (find_inferior_pid (this, fpid) != nullptr)\n \t    {\n-\t      ourstatus->value.related_pid = ptid_t (pe.pe_other_pid);\n+\t      ourstatus->set_forked (ptid_t (pe.pe_other_pid));\n \t      wptid = ptid_t (fpid, pe.pe_tid, 0);\n \t    }\n \n-\t  obsd_enable_proc_events (ourstatus->value.related_pid.pid ());\n+\t  obsd_enable_proc_events (ourstatus->child_ptid ().pid ());\n \t  break;\n \t}\n "
    },
    {
      "sha": "2c96919dcebd47aa9dcfc44f38b145ab8acea485",
      "filename": "gdb/procfs.c",
      "status": "modified",
      "additions": 4,
      "deletions": 5,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/procfs.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/procfs.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/procfs.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -1311,8 +1311,8 @@ proc_set_current_signal (procinfo *pi, int signo)\n   get_last_target_status (&wait_target, &wait_ptid, &wait_status);\n   if (wait_target == &the_procfs_target\n       && wait_ptid == inferior_ptid\n-      && wait_status.kind == TARGET_WAITKIND_STOPPED\n-      && wait_status.value.sig == gdb_signal_from_host (signo)\n+      && wait_status.kind () == TARGET_WAITKIND_STOPPED\n+      && wait_status.sig () == gdb_signal_from_host (signo)\n       && proc_get_status (pi)\n       && pi->prstatus.pr_lwp.pr_info.si_signo == signo\n       )\n@@ -2256,7 +2256,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t      printf_unfiltered (_(\"[%s exited]\\n\"),\n \t\t\t\t\t target_pid_to_str (retval).c_str ());\n \t\t    delete_thread (find_thread_ptid (this, retval));\n-\t\t    status->kind = TARGET_WAITKIND_SPURIOUS;\n+\t\t    status->set_spurious ();\n \t\t    return retval;\n \t\t  }\n \t\telse\n@@ -2306,8 +2306,7 @@ procfs_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \t\t    if (!in_thread_list (this, temp_ptid))\n \t\t      add_thread (this, temp_ptid);\n \n-\t\t    status->kind = TARGET_WAITKIND_STOPPED;\n-\t\t    status->value.sig = GDB_SIGNAL_0;\n+\t\t    status->set_stopped (GDB_SIGNAL_0);\n \t\t    return retval;\n \t\t  }\n #endif"
    },
    {
      "sha": "4afe95cb96b538ecf9fd6057ed22f6b184b04d9c",
      "filename": "gdb/ravenscar-thread.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/ravenscar-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/ravenscar-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ravenscar-thread.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -401,8 +401,8 @@ ravenscar_thread_target::wait (ptid_t ptid,\n      this causes problems when debugging through the remote protocol,\n      because we might try switching threads (and thus sending packets)\n      after the remote has disconnected.  */\n-  if (status->kind != TARGET_WAITKIND_EXITED\n-      && status->kind != TARGET_WAITKIND_SIGNALLED\n+  if (status->kind () != TARGET_WAITKIND_EXITED\n+      && status->kind () != TARGET_WAITKIND_SIGNALLED\n       && runtime_initialized ())\n     {\n       m_base_ptid = event_ptid;"
    },
    {
      "sha": "e2538ee8edae484201427ade04db5b5f25160c3e",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 12,
      "deletions": 14,
      "changes": 26,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -2235,7 +2235,7 @@ btrace_step_no_history (void)\n {\n   struct target_waitstatus status;\n \n-  status.kind = TARGET_WAITKIND_NO_HISTORY;\n+  status.set_no_history ();\n \n   return status;\n }\n@@ -2247,8 +2247,7 @@ btrace_step_stopped (void)\n {\n   struct target_waitstatus status;\n \n-  status.kind = TARGET_WAITKIND_STOPPED;\n-  status.value.sig = GDB_SIGNAL_TRAP;\n+  status.set_stopped (GDB_SIGNAL_TRAP);\n \n   return status;\n }\n@@ -2261,8 +2260,7 @@ btrace_step_stopped_on_request (void)\n {\n   struct target_waitstatus status;\n \n-  status.kind = TARGET_WAITKIND_STOPPED;\n-  status.value.sig = GDB_SIGNAL_0;\n+  status.set_stopped (GDB_SIGNAL_0);\n \n   return status;\n }\n@@ -2274,7 +2272,7 @@ btrace_step_spurious (void)\n {\n   struct target_waitstatus status;\n \n-  status.kind = TARGET_WAITKIND_SPURIOUS;\n+  status.set_spurious ();\n \n   return status;\n }\n@@ -2286,7 +2284,7 @@ btrace_step_no_resumed (void)\n {\n   struct target_waitstatus status;\n \n-  status.kind = TARGET_WAITKIND_NO_RESUMED;\n+  status.set_no_resumed ();\n \n   return status;\n }\n@@ -2298,7 +2296,7 @@ btrace_step_again (void)\n {\n   struct target_waitstatus status;\n \n-  status.kind = TARGET_WAITKIND_IGNORE;\n+  status.set_ignore ();\n \n   return status;\n }\n@@ -2466,29 +2464,29 @@ record_btrace_step_thread (struct thread_info *tp)\n \n     case BTHR_STEP:\n       status = record_btrace_single_step_forward (tp);\n-      if (status.kind != TARGET_WAITKIND_SPURIOUS)\n+      if (status.kind () != TARGET_WAITKIND_SPURIOUS)\n \tbreak;\n \n       return btrace_step_stopped ();\n \n     case BTHR_RSTEP:\n       status = record_btrace_single_step_backward (tp);\n-      if (status.kind != TARGET_WAITKIND_SPURIOUS)\n+      if (status.kind () != TARGET_WAITKIND_SPURIOUS)\n \tbreak;\n \n       return btrace_step_stopped ();\n \n     case BTHR_CONT:\n       status = record_btrace_single_step_forward (tp);\n-      if (status.kind != TARGET_WAITKIND_SPURIOUS)\n+      if (status.kind () != TARGET_WAITKIND_SPURIOUS)\n \tbreak;\n \n       btinfo->flags |= flags;\n       return btrace_step_again ();\n \n     case BTHR_RCONT:\n       status = record_btrace_single_step_backward (tp);\n-      if (status.kind != TARGET_WAITKIND_SPURIOUS)\n+      if (status.kind () != TARGET_WAITKIND_SPURIOUS)\n \tbreak;\n \n       btinfo->flags |= flags;\n@@ -2497,7 +2495,7 @@ record_btrace_step_thread (struct thread_info *tp)\n \n   /* We keep threads moving at the end of their execution history.  The wait\n      method will stop the thread for whom the event is reported.  */\n-  if (status.kind == TARGET_WAITKIND_NO_HISTORY)\n+  if (status.kind () == TARGET_WAITKIND_NO_HISTORY)\n     btinfo->flags |= flags;\n \n   return status;\n@@ -2589,7 +2587,7 @@ record_btrace_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \n \t  *status = record_btrace_step_thread (tp);\n \n-\t  switch (status->kind)\n+\t  switch (status->kind ())\n \t    {\n \t    case TARGET_WAITKIND_IGNORE:\n \t      ix++;"
    },
    {
      "sha": "bb02e766748d3dc6168b90fe9319be6e30f7ad16",
      "filename": "gdb/record-full.c",
      "status": "modified",
      "additions": 19,
      "deletions": 17,
      "changes": 36,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/record-full.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/record-full.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-full.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -1155,7 +1155,7 @@ record_full_wait_1 (struct target_ops *ops,\n       gdb_assert ((options & TARGET_WNOHANG) != 0);\n \n       /* No interesting event.  */\n-      status->kind = TARGET_WAITKIND_IGNORE;\n+      status->set_ignore ();\n       return minus_one_ptid;\n     }\n \n@@ -1182,7 +1182,7 @@ record_full_wait_1 (struct target_ops *ops,\n \t  while (1)\n \t    {\n \t      ret = ops->beneath ()->wait (ptid, status, options);\n-\t      if (status->kind == TARGET_WAITKIND_IGNORE)\n+\t      if (status->kind () == TARGET_WAITKIND_IGNORE)\n \t\t{\n \t\t  if (record_debug)\n \t\t    fprintf_unfiltered (gdb_stdlog,\n@@ -1198,8 +1198,8 @@ record_full_wait_1 (struct target_ops *ops,\n \t\treturn ret;\n \n \t      /* Is this a SIGTRAP?  */\n-\t      if (status->kind == TARGET_WAITKIND_STOPPED\n-\t\t  && status->value.sig == GDB_SIGNAL_TRAP)\n+\t      if (status->kind () == TARGET_WAITKIND_STOPPED\n+\t\t  && status->sig () == GDB_SIGNAL_TRAP)\n \t\t{\n \t\t  struct regcache *regcache;\n \t\t  enum target_stop_reason *stop_reason_p\n@@ -1237,8 +1237,7 @@ record_full_wait_1 (struct target_ops *ops,\n \t\t      if (!record_full_message_wrapper_safe (regcache,\n \t\t\t\t\t\t\t     GDB_SIGNAL_0))\n \t\t\t{\n-\t\t\t   status->kind = TARGET_WAITKIND_STOPPED;\n-\t\t\t   status->value.sig = GDB_SIGNAL_0;\n+\t\t\t   status->set_stopped (GDB_SIGNAL_0);\n \t\t\t   break;\n \t\t\t}\n \n@@ -1292,7 +1291,7 @@ record_full_wait_1 (struct target_ops *ops,\n \t  CORE_ADDR tmp_pc;\n \n \t  record_full_stop_reason = TARGET_STOPPED_BY_NO_REASON;\n-\t  status->kind = TARGET_WAITKIND_STOPPED;\n+\t  status->set_stopped (GDB_SIGNAL_0);\n \n \t  /* Check breakpoint when forward execute.  */\n \t  if (execution_direction == EXEC_FORWARD)\n@@ -1330,14 +1329,14 @@ record_full_wait_1 (struct target_ops *ops,\n \t\t  && record_full_list == &record_full_first)\n \t\t{\n \t\t  /* Hit beginning of record log in reverse.  */\n-\t\t  status->kind = TARGET_WAITKIND_NO_HISTORY;\n+\t\t  status->set_no_history ();\n \t\t  break;\n \t\t}\n \t      if (execution_direction != EXEC_REVERSE\n \t\t  && !record_full_list->next)\n \t\t{\n \t\t  /* Hit end of record log going forward.  */\n-\t\t  status->kind = TARGET_WAITKIND_NO_HISTORY;\n+\t\t  status->set_no_history ();\n \t\t  break;\n \t\t}\n \n@@ -1422,13 +1421,16 @@ record_full_wait_1 (struct target_ops *ops,\n \t  while (continue_flag);\n \n \treplay_out:\n-\t  if (record_full_get_sig)\n-\t    status->value.sig = GDB_SIGNAL_INT;\n-\t  else if (record_full_list->u.end.sigval != GDB_SIGNAL_0)\n-\t    /* FIXME: better way to check */\n-\t    status->value.sig = record_full_list->u.end.sigval;\n-\t  else\n-\t    status->value.sig = GDB_SIGNAL_TRAP;\n+\t  if (status->kind () == TARGET_WAITKIND_STOPPED)\n+\t    {\n+\t      if (record_full_get_sig)\n+\t\tstatus->set_stopped (GDB_SIGNAL_INT);\n+\t      else if (record_full_list->u.end.sigval != GDB_SIGNAL_0)\n+\t\t/* FIXME: better way to check */\n+\t\tstatus->set_stopped (record_full_list->u.end.sigval);\n+\t      else\n+\t\tstatus->set_stopped (GDB_SIGNAL_TRAP);\n+\t    }\n \t}\n       catch (const gdb_exception &ex)\n \t{\n@@ -1458,7 +1460,7 @@ record_full_base_target::wait (ptid_t ptid, struct target_waitstatus *status,\n   clear_async_event_handler (record_full_async_inferior_event_token);\n \n   return_ptid = record_full_wait_1 (this, ptid, status, options);\n-  if (status->kind != TARGET_WAITKIND_IGNORE)\n+  if (status->kind () != TARGET_WAITKIND_IGNORE)\n     {\n       /* We're reporting a stop.  Make sure any spurious\n \t target_wait(WNOHANG) doesn't advance the target until the"
    },
    {
      "sha": "55d674fc4d3b61835b3fbd8b8127a714976edfa1",
      "filename": "gdb/remote-sim.c",
      "status": "modified",
      "additions": 2,
      "deletions": 2,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/remote-sim.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/remote-sim.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote-sim.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -993,13 +993,13 @@ gdbsim_target::wait (ptid_t ptid, struct target_waitstatus *status,\n \tcase GDB_SIGNAL_TRAP:\n \tdefault:\n \t  status->kind = TARGET_WAITKIND_STOPPED;\n-\t  status->value.sig = (enum gdb_signal) sigrc;\n+\t  status->sig () = (enum gdb_signal) sigrc;\n \t  break;\n \t}\n       break;\n     case sim_signalled:\n       status->kind = TARGET_WAITKIND_SIGNALLED;\n-      status->value.sig = (enum gdb_signal) sigrc;\n+      status->sig () = (enum gdb_signal) sigrc;\n       break;\n     case sim_running:\n     case sim_polling:"
    },
    {
      "sha": "0fb427535960903b828a83e8e23011719c7a66c7",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 60,
      "deletions": 82,
      "changes": 142,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -4497,8 +4497,7 @@ remote_target::print_one_stopped_thread (thread_info *thread)\n     }\n   else\n     {\n-      ws.kind = TARGET_WAITKIND_STOPPED;\n-      ws.value.sig = GDB_SIGNAL_0;\n+      ws.set_stopped (GDB_SIGNAL_0);\n     }\n \n   switch_to_thread (thread);\n@@ -4508,9 +4507,9 @@ remote_target::print_one_stopped_thread (thread_info *thread)\n   /* For \"info program\".  */\n   set_last_target_status (this, thread->ptid, ws);\n \n-  if (ws.kind == TARGET_WAITKIND_STOPPED)\n+  if (ws.kind () == TARGET_WAITKIND_STOPPED)\n     {\n-      enum gdb_signal sig = ws.value.sig;\n+      enum gdb_signal sig = ws.sig ();\n \n       if (signal_print_state (sig))\n \tgdb::observers::signal_received.notify (sig);\n@@ -4542,12 +4541,11 @@ remote_target::process_initial_stop_replies (int from_tty)\n       struct target_waitstatus ws;\n       int ignore_event = 0;\n \n-      memset (&ws, 0, sizeof (ws));\n       event_ptid = target_wait (waiton_ptid, &ws, TARGET_WNOHANG);\n       if (remote_debug)\n \tprint_target_wait_results (waiton_ptid, event_ptid, &ws);\n \n-      switch (ws.kind)\n+      switch (ws.kind ())\n \t{\n \tcase TARGET_WAITKIND_IGNORE:\n \tcase TARGET_WAITKIND_NO_RESUMED:\n@@ -4558,9 +4556,6 @@ remote_target::process_initial_stop_replies (int from_tty)\n \t  ignore_event = 1;\n \t  break;\n \n-\tcase TARGET_WAITKIND_EXECD:\n-\t  xfree (ws.value.execd_pathname);\n-\t  break;\n \tdefault:\n \t  break;\n \t}\n@@ -4570,20 +4565,20 @@ remote_target::process_initial_stop_replies (int from_tty)\n \n       thread_info *evthread = find_thread_ptid (this, event_ptid);\n \n-      if (ws.kind == TARGET_WAITKIND_STOPPED)\n+      if (ws.kind () == TARGET_WAITKIND_STOPPED)\n \t{\n-\t  enum gdb_signal sig = ws.value.sig;\n+\t  enum gdb_signal sig = ws.sig ();\n \n \t  /* Stubs traditionally report SIGTRAP as initial signal,\n \t     instead of signal 0.  Suppress it.  */\n \t  if (sig == GDB_SIGNAL_TRAP)\n \t    sig = GDB_SIGNAL_0;\n \t  evthread->set_stop_signal (sig);\n-\t  ws.value.sig = sig;\n+\t  ws.set_stopped (sig);\n \t}\n \n-      if (ws.kind != TARGET_WAITKIND_STOPPED\n-\t  || ws.value.sig != GDB_SIGNAL_0)\n+      if (ws.kind () != TARGET_WAITKIND_STOPPED\n+\t  || ws.sig () != GDB_SIGNAL_0)\n \tevthread->set_pending_waitstatus (ws);\n \n       set_executing (this, event_ptid, false);\n@@ -5887,7 +5882,7 @@ remote_target::remote_detach_1 (inferior *inf, int from_tty)\n   /* Check to see if we are detaching a fork parent.  Note that if we\n      are detaching a fork child, tp == NULL.  */\n   is_fork_parent = (tp != NULL\n-\t\t    && tp->pending_follow.kind == TARGET_WAITKIND_FORKED);\n+\t\t    && tp->pending_follow.kind () == TARGET_WAITKIND_FORKED);\n \n   /* If doing detach-on-fork, we don't mourn, because that will delete\n      breakpoints that should be available for the followed inferior.  */\n@@ -6930,8 +6925,7 @@ remote_target::remote_stop_ns (ptid_t ptid)\n \t    stop_reply *sr = new stop_reply ();\n \t    sr->ptid = tp->ptid;\n \t    sr->rs = rs;\n-\t    sr->ws.kind = TARGET_WAITKIND_STOPPED;\n-\t    sr->ws.value.sig = GDB_SIGNAL_0;\n+\t    sr->ws.set_stopped (GDB_SIGNAL_0);\n \t    sr->arch = tp->inf->gdbarch;\n \t    sr->stop_reason = TARGET_STOPPED_BY_NO_REASON;\n \t    sr->watch_data_address = 0;\n@@ -7183,7 +7177,7 @@ remote_notif_stop_ack (remote_target *remote,\n   /* Kind can be TARGET_WAITKIND_IGNORE if we have meanwhile discarded\n      the notification.  It was left in the queue because we need to\n      acknowledge it and pull the rest of the notifications out.  */\n-  if (stop_reply->ws.kind != TARGET_WAITKIND_IGNORE)\n+  if (stop_reply->ws.kind () != TARGET_WAITKIND_IGNORE)\n     remote->push_stop_reply (stop_reply);\n }\n \n@@ -7234,8 +7228,8 @@ static int\n is_pending_fork_parent (const target_waitstatus *ws, int event_pid,\n \t\t\tptid_t thread_ptid)\n {\n-  if (ws->kind == TARGET_WAITKIND_FORKED\n-      || ws->kind == TARGET_WAITKIND_VFORKED)\n+  if (ws->kind () == TARGET_WAITKIND_FORKED\n+      || ws->kind () == TARGET_WAITKIND_VFORKED)\n     {\n       if (event_pid == -1 || event_pid == thread_ptid.pid ())\n \treturn 1;\n@@ -7286,18 +7280,18 @@ remote_target::remove_new_fork_children (threads_listing_context *context)\n       const target_waitstatus *ws = thread_pending_fork_status (thread);\n \n       if (is_pending_fork_parent (ws, pid, thread->ptid))\n-\tcontext->remove_thread (ws->value.related_pid);\n+\tcontext->remove_thread (ws->child_ptid ());\n     }\n \n   /* Check for any pending fork events (not reported or processed yet)\n      in process PID and remove those fork child threads from the\n      CONTEXT list as well.  */\n   remote_notif_get_pending_events (notif);\n   for (auto &event : get_remote_state ()->stop_reply_queue)\n-    if (event->ws.kind == TARGET_WAITKIND_FORKED\n-\t|| event->ws.kind == TARGET_WAITKIND_VFORKED\n-\t|| event->ws.kind == TARGET_WAITKIND_THREAD_EXITED)\n-      context->remove_thread (event->ws.value.related_pid);\n+    if (event->ws.kind () == TARGET_WAITKIND_FORKED\n+\t|| event->ws.kind () == TARGET_WAITKIND_VFORKED\n+\t|| event->ws.kind () == TARGET_WAITKIND_THREAD_EXITED)\n+      context->remove_thread (event->ws.child_ptid ());\n }\n \n /* Check whether any event pending in the vStopped queue would prevent a\n@@ -7315,12 +7309,12 @@ remote_target::check_pending_events_prevent_wildcard_vcont\n   remote_notif_get_pending_events (notif);\n   for (auto &event : get_remote_state ()->stop_reply_queue)\n     {\n-      if (event->ws.kind == TARGET_WAITKIND_NO_RESUMED\n-\t  || event->ws.kind == TARGET_WAITKIND_NO_HISTORY)\n+      if (event->ws.kind () == TARGET_WAITKIND_NO_RESUMED\n+\t  || event->ws.kind () == TARGET_WAITKIND_NO_HISTORY)\n \tcontinue;\n \n-      if (event->ws.kind == TARGET_WAITKIND_FORKED\n-\t  || event->ws.kind == TARGET_WAITKIND_VFORKED)\n+      if (event->ws.kind () == TARGET_WAITKIND_FORKED\n+\t  || event->ws.kind () == TARGET_WAITKIND_VFORKED)\n \t*may_global_wildcard = false;\n \n       /* This may be the first time we heard about this process.\n@@ -7358,7 +7352,7 @@ remote_target::discard_pending_stop_replies (struct inferior *inf)\n       /* Leave the notification pending, since the server expects that\n \t we acknowledge it with vStopped.  But clear its contents, so\n \t that later on when we acknowledge it, we also discard it.  */\n-      reply->ws.kind = TARGET_WAITKIND_IGNORE;\n+      reply->ws.set_ignore ();\n \n       if (remote_debug)\n \tfprintf_unfiltered (gdb_stdlog,\n@@ -7472,7 +7466,7 @@ remote_target::peek_stop_reply (ptid_t ptid)\n   remote_state *rs = get_remote_state ();\n   for (auto &event : rs->stop_reply_queue)\n     if (ptid == event->ptid\n-\t&& event->ws.kind == TARGET_WAITKIND_STOPPED)\n+\t&& event->ws.kind () == TARGET_WAITKIND_STOPPED)\n       return 1;\n   return 0;\n }\n@@ -7502,8 +7496,7 @@ remote_target::remote_parse_stop_reply (const char *buf, stop_reply *event)\n \n   event->ptid = null_ptid;\n   event->rs = get_remote_state ();\n-  event->ws.kind = TARGET_WAITKIND_IGNORE;\n-  event->ws.value.integer = 0;\n+  event->ws.set_ignore ();\n   event->stop_reason = TARGET_STOPPED_BY_NO_REASON;\n   event->regcache.clear ();\n   event->core = -1;\n@@ -7547,17 +7540,15 @@ Packet: '%s'\\n\"),\n \t    {\n \t      ULONGEST sysno;\n \n-\t      event->ws.kind = TARGET_WAITKIND_SYSCALL_ENTRY;\n \t      p = unpack_varlen_hex (++p1, &sysno);\n-\t      event->ws.value.syscall_number = (int) sysno;\n+\t      event->ws.set_syscall_entry ((int) sysno);\n \t    }\n \t  else if (strprefix (p, p1, \"syscall_return\"))\n \t    {\n \t      ULONGEST sysno;\n \n-\t      event->ws.kind = TARGET_WAITKIND_SYSCALL_RETURN;\n \t      p = unpack_varlen_hex (++p1, &sysno);\n-\t      event->ws.value.syscall_number = (int) sysno;\n+\t      event->ws.set_syscall_return ((int) sysno);\n \t    }\n \t  else if (strprefix (p, p1, \"watch\")\n \t\t   || strprefix (p, p1, \"rwatch\")\n@@ -7595,12 +7586,12 @@ Packet: '%s'\\n\"),\n \t    }\n \t  else if (strprefix (p, p1, \"library\"))\n \t    {\n-\t      event->ws.kind = TARGET_WAITKIND_LOADED;\n+\t      event->ws.set_loaded ();\n \t      p = strchrnul (p1 + 1, ';');\n \t    }\n \t  else if (strprefix (p, p1, \"replaylog\"))\n \t    {\n-\t      event->ws.kind = TARGET_WAITKIND_NO_HISTORY;\n+\t      event->ws.set_no_history ();\n \t      /* p1 will indicate \"begin\" or \"end\", but it makes\n \t\t no difference for now, so ignore it.  */\n \t      p = strchrnul (p1 + 1, ';');\n@@ -7613,18 +7604,12 @@ Packet: '%s'\\n\"),\n \t      event->core = c;\n \t    }\n \t  else if (strprefix (p, p1, \"fork\"))\n-\t    {\n-\t      event->ws.value.related_pid = read_ptid (++p1, &p);\n-\t      event->ws.kind = TARGET_WAITKIND_FORKED;\n-\t    }\n+\t    event->ws.set_forked (read_ptid (++p1, &p));\n \t  else if (strprefix (p, p1, \"vfork\"))\n-\t    {\n-\t      event->ws.value.related_pid = read_ptid (++p1, &p);\n-\t      event->ws.kind = TARGET_WAITKIND_VFORKED;\n-\t    }\n+\t    event->ws.set_vforked (read_ptid (++p1, &p));\n \t  else if (strprefix (p, p1, \"vforkdone\"))\n \t    {\n-\t      event->ws.kind = TARGET_WAITKIND_VFORK_DONE;\n+\t      event->ws.set_vfork_done ();\n \t      p = strchrnul (p1 + 1, ';');\n \t    }\n \t  else if (strprefix (p, p1, \"exec\"))\n@@ -7638,14 +7623,13 @@ Packet: '%s'\\n\"),\n \n \t      /* Save the pathname for event reporting and for\n \t\t the next run command.  */\n-\t      gdb::unique_xmalloc_ptr<char[]> pathname\n+\t      gdb::unique_xmalloc_ptr<char> pathname\n \t\t((char *) xmalloc (pathlen + 1));\n \t      hex2bin (p1, (gdb_byte *) pathname.get (), pathlen);\n-\t      pathname[pathlen] = '\\0';\n+\t      pathname.get ()[pathlen] = '\\0';\n \n \t      /* This is freed during event handling.  */\n-\t      event->ws.value.execd_pathname = pathname.release ();\n-\t      event->ws.kind = TARGET_WAITKIND_EXECD;\n+\t      event->ws.set_execd (std::move (pathname));\n \n \t      /* Skip the registers included in this packet, since\n \t\t they may be for an architecture different from the\n@@ -7654,7 +7638,7 @@ Packet: '%s'\\n\"),\n \t    }\n \t  else if (strprefix (p, p1, \"create\"))\n \t    {\n-\t      event->ws.kind = TARGET_WAITKIND_THREAD_CREATED;\n+\t      event->ws.set_thread_created ();\n \t      p = strchrnul (p1 + 1, ';');\n \t    }\n \t  else\n@@ -7753,29 +7737,27 @@ Packet: '%s'\\n\"),\n \t  ++p;\n \t}\n \n-      if (event->ws.kind != TARGET_WAITKIND_IGNORE)\n+      if (event->ws.kind () != TARGET_WAITKIND_IGNORE)\n \tbreak;\n \n       /* fall through */\n     case 'S':\t\t/* Old style status, just signal only.  */\n       {\n \tint sig;\n \n-\tevent->ws.kind = TARGET_WAITKIND_STOPPED;\n \tsig = (fromhex (buf[1]) << 4) + fromhex (buf[2]);\n \tif (GDB_SIGNAL_FIRST <= sig && sig < GDB_SIGNAL_LAST)\n-\t  event->ws.value.sig = (enum gdb_signal) sig;\n+\t  event->ws.set_stopped ((enum gdb_signal) sig);\n \telse\n-\t  event->ws.value.sig = GDB_SIGNAL_UNKNOWN;\n+\t  event->ws.set_stopped (GDB_SIGNAL_UNKNOWN);\n       }\n       break;\n     case 'w':\t\t/* Thread exited.  */\n       {\n \tULONGEST value;\n \n-\tevent->ws.kind = TARGET_WAITKIND_THREAD_EXITED;\n \tp = unpack_varlen_hex (&buf[1], &value);\n-\tevent->ws.value.integer = value;\n+\tevent->ws.set_thread_exited (value);\n \tif (*p != ';')\n \t  error (_(\"stop reply packet badly formatted: %s\"), buf);\n \tevent->ptid = read_ptid (++p, NULL);\n@@ -7794,17 +7776,15 @@ Packet: '%s'\\n\"),\n \tif (buf[0] == 'W')\n \t  {\n \t    /* The remote process exited.  */\n-\t    event->ws.kind = TARGET_WAITKIND_EXITED;\n-\t    event->ws.value.integer = value;\n+\t    event->ws.set_exited (value);\n \t  }\n \telse\n \t  {\n \t    /* The remote process exited with a signal.  */\n-\t    event->ws.kind = TARGET_WAITKIND_SIGNALLED;\n \t    if (GDB_SIGNAL_FIRST <= value && value < GDB_SIGNAL_LAST)\n-\t      event->ws.value.sig = (enum gdb_signal) value;\n+\t      event->ws.set_signalled ((enum gdb_signal) value);\n \t    else\n-\t      event->ws.value.sig = GDB_SIGNAL_UNKNOWN;\n+\t      event->ws.set_signalled (GDB_SIGNAL_UNKNOWN);\n \t  }\n \n \t/* If no process is specified, return null_ptid, and let the\n@@ -7835,7 +7815,7 @@ Packet: '%s'\\n\"),\n       }\n       break;\n     case 'N':\n-      event->ws.kind = TARGET_WAITKIND_NO_RESUMED;\n+      event->ws.set_no_resumed ();\n       event->ptid = minus_one_ptid;\n       break;\n     }\n@@ -7968,8 +7948,8 @@ remote_target::select_thread_for_ambiguous_stop_reply\n   /* Some stop events apply to all threads in an inferior, while others\n      only apply to a single thread.  */\n   bool process_wide_stop\n-    = (status->kind == TARGET_WAITKIND_EXITED\n-       || status->kind == TARGET_WAITKIND_SIGNALLED);\n+    = (status->kind () == TARGET_WAITKIND_EXITED\n+       || status->kind () == TARGET_WAITKIND_SIGNALLED);\n \n   remote_debug_printf (\"process_wide_stop = %d\", process_wide_stop);\n \n@@ -8054,9 +8034,9 @@ remote_target::process_stop_reply (struct stop_reply *stop_reply,\n     ptid = select_thread_for_ambiguous_stop_reply (status);\n   gdb_assert (ptid != null_ptid);\n \n-  if (status->kind != TARGET_WAITKIND_EXITED\n-      && status->kind != TARGET_WAITKIND_SIGNALLED\n-      && status->kind != TARGET_WAITKIND_NO_RESUMED)\n+  if (status->kind () != TARGET_WAITKIND_EXITED\n+      && status->kind () != TARGET_WAITKIND_SIGNALLED\n+      && status->kind () != TARGET_WAITKIND_NO_RESUMED)\n     {\n       /* Expedited registers.  */\n       if (!stop_reply->regcache.empty ())\n@@ -8146,7 +8126,7 @@ remote_target::wait_ns (ptid_t ptid, struct target_waitstatus *status,\n \t return to the event loop.  */\n       if (options & TARGET_WNOHANG)\n \t{\n-\t  status->kind = TARGET_WAITKIND_IGNORE;\n+\t  status->set_ignore ();\n \t  return minus_one_ptid;\n \t}\n \n@@ -8180,8 +8160,7 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status,\n \n  again:\n \n-  status->kind = TARGET_WAITKIND_IGNORE;\n-  status->value.integer = 0;\n+  status->set_ignore ();\n \n   stop_reply = queued_stop_reply (ptid);\n   if (stop_reply != NULL)\n@@ -8199,7 +8178,7 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status,\n \n       if (!rs->waiting_for_stop_reply)\n \t{\n-\t  status->kind = TARGET_WAITKIND_NO_RESUMED;\n+\t  status->set_no_resumed ();\n \t  return minus_one_ptid;\n \t}\n \n@@ -8233,8 +8212,7 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status,\n       rs->waiting_for_stop_reply = 0;\n \n       warning (_(\"Remote failure reply: %s\"), buf);\n-      status->kind = TARGET_WAITKIND_STOPPED;\n-      status->value.sig = GDB_SIGNAL_0;\n+      status->set_stopped (GDB_SIGNAL_0);\n       break;\n     case 'F':\t\t/* File-I/O request.  */\n       /* GDB may access the inferior memory while handling the File-I/O\n@@ -8286,9 +8264,9 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status,\n       break;\n     }\n \n-  if (status->kind == TARGET_WAITKIND_NO_RESUMED)\n+  if (status->kind () == TARGET_WAITKIND_NO_RESUMED)\n     return minus_one_ptid;\n-  else if (status->kind == TARGET_WAITKIND_IGNORE)\n+  else if (status->kind () == TARGET_WAITKIND_IGNORE)\n     {\n       /* Nothing interesting happened.  If we're doing a non-blocking\n \t poll, we're done.  Otherwise, go back to waiting.  */\n@@ -8297,8 +8275,8 @@ remote_target::wait_as (ptid_t ptid, target_waitstatus *status,\n       else\n \tgoto again;\n     }\n-  else if (status->kind != TARGET_WAITKIND_EXITED\n-\t   && status->kind != TARGET_WAITKIND_SIGNALLED)\n+  else if (status->kind () != TARGET_WAITKIND_EXITED\n+\t   && status->kind () != TARGET_WAITKIND_SIGNALLED)\n     {\n       if (event_ptid != null_ptid)\n \trecord_currthread (rs, event_ptid);\n@@ -10083,7 +10061,7 @@ remote_target::kill_new_fork_children (int pid)\n \n       if (is_pending_fork_parent (ws, pid, thread->ptid))\n \t{\n-\t  int child_pid = ws->value.related_pid.pid ();\n+\t  int child_pid = ws->child_ptid ().pid ();\n \t  int res;\n \n \t  res = remote_vkill (child_pid);\n@@ -10098,7 +10076,7 @@ remote_target::kill_new_fork_children (int pid)\n   for (auto &event : rs->stop_reply_queue)\n     if (is_pending_fork_parent (&event->ws, pid, event->ptid))\n       {\n-\tint child_pid = event->ws.value.related_pid.pid ();\n+\tint child_pid = event->ws.child_ptid ().pid ();\n \tint res;\n \n \tres = remote_vkill (child_pid);"
    },
    {
      "sha": "6d5996c2011d8fc5ed455b5ea75ecab1f8f4e4c4",
      "filename": "gdb/rs6000-nat.c",
      "status": "modified",
      "additions": 3,
      "deletions": 4,
      "changes": 7,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/rs6000-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/rs6000-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rs6000-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -520,8 +520,7 @@ rs6000_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t\t\t      safe_strerror (save_errno));\n \n \t  /* Claim it exited with unknown signal.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-\t  ourstatus->value.sig = GDB_SIGNAL_UNKNOWN;\n+\t  ourstatus->set_signalled (GDB_SIGNAL_UNKNOWN);\n \t  return inferior_ptid;\n \t}\n \n@@ -535,10 +534,10 @@ rs6000_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n   /* stop after load\" status.  */\n   if (status == 0x57c)\n-    ourstatus->kind = TARGET_WAITKIND_LOADED;\n+    ourstatus->set_loaded ();\n   /* signal 0.  I have no idea why wait(2) returns with this status word.  */\n   else if (status == 0x7f)\n-    ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+    ourstatus->set_spurious ();\n   /* A normal waitstatus.  Let the usual macros deal with it.  */\n   else\n     store_waitstatus (ourstatus, status);"
    },
    {
      "sha": "47246092fc47eee730905fca361090377afae608",
      "filename": "gdb/sol-thread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 1,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/sol-thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/sol-thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/sol-thread.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -441,7 +441,7 @@ sol_thread_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n   ptid_t rtnval = beneath ()->wait (ptid, ourstatus, options);\n \n-  if (ourstatus->kind != TARGET_WAITKIND_EXITED)\n+  if (ourstatus->kind () != TARGET_WAITKIND_EXITED)\n     {\n       /* Map the LWP of interest back to the appropriate thread ID.  */\n       ptid_t thr_ptid = lwp_to_thread (rtnval);"
    },
    {
      "sha": "6219393987e8f3b9d02569d1346f8039f2925da3",
      "filename": "gdb/target.c",
      "status": "modified",
      "additions": 1,
      "deletions": 2,
      "changes": 3,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -2615,7 +2615,7 @@ default_target_wait (struct target_ops *ops,\n \t\t     ptid_t ptid, struct target_waitstatus *status,\n \t\t     target_wait_flags options)\n {\n-  status->kind = TARGET_WAITKIND_IGNORE;\n+  status->set_ignore ();\n   return minus_one_ptid;\n }\n \n@@ -3851,7 +3851,6 @@ target_stop_and_wait (ptid_t ptid)\n   non_stop = true;\n   target_stop (ptid);\n \n-  memset (&status, 0, sizeof (status));\n   target_wait (ptid, &status, 0);\n \n   non_stop = was_non_stop;"
    },
    {
      "sha": "dc3d75eef6e5837f7b21cd127e554c560df5f4ce",
      "filename": "gdb/target/waitstatus.c",
      "status": "modified",
      "additions": 10,
      "deletions": 10,
      "changes": 20,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/target/waitstatus.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/target/waitstatus.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target/waitstatus.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -27,36 +27,36 @@ target_waitstatus_to_string (const struct target_waitstatus *ws)\n {\n   const char *kind_str = \"status->kind = \";\n \n-  switch (ws->kind)\n+  switch (ws->kind ())\n     {\n     case TARGET_WAITKIND_EXITED:\n       return string_printf (\"%sexited, status = %d\",\n-\t\t\t    kind_str, ws->value.integer);\n+\t\t\t    kind_str, ws->exit_status ());\n \n     case TARGET_WAITKIND_STOPPED:\n       return string_printf (\"%sstopped, signal = %s\",\n \t\t\t    kind_str,\n-\t\t\t    gdb_signal_to_symbol_string (ws->value.sig));\n+\t\t\t    gdb_signal_to_symbol_string (ws->sig ()));\n \n     case TARGET_WAITKIND_SIGNALLED:\n       return string_printf (\"%ssignalled, signal = %s\",\n \t\t\t    kind_str,\n-\t\t\t    gdb_signal_to_symbol_string (ws->value.sig));\n+\t\t\t    gdb_signal_to_symbol_string (ws->sig ()));\n \n     case TARGET_WAITKIND_LOADED:\n       return string_printf (\"%sloaded\", kind_str);\n \n     case TARGET_WAITKIND_FORKED:\n-      return string_printf (\"%sforked, related_pid = %s\", kind_str,\n-\t\t\t    ws->value.related_pid.to_string ().c_str ());\n+      return string_printf (\"%sforked, child_ptid = %s\", kind_str,\n+\t\t\t    ws->child_ptid ().to_string ().c_str ());\n \n     case TARGET_WAITKIND_VFORKED:\n-      return string_printf (\"%svforked, related_pid = %s\", kind_str,\n-\t\t\t    ws->value.related_pid.to_string ().c_str ());\n+      return string_printf (\"%svforked, child_ptid = %s\", kind_str,\n+\t\t\t    ws->child_ptid ().to_string ().c_str ());\n \n     case TARGET_WAITKIND_EXECD:\n       return string_printf (\"%sexecd, execd_pathname = %s\", kind_str,\n-\t\t\t    ws->value.execd_pathname);\n+\t\t\t    ws->execd_pathname ());\n \n     case TARGET_WAITKIND_VFORK_DONE:\n       return string_printf (\"%svfork-done\", kind_str);\n@@ -84,7 +84,7 @@ target_waitstatus_to_string (const struct target_waitstatus *ws)\n \n     case TARGET_WAITKIND_THREAD_EXITED:\n       return string_printf (\"%sthread exited, status = %d\",\n-\t\t\t    kind_str, ws->value.integer);\n+\t\t\t    kind_str, ws->exit_status ());\n \n     default:\n       return string_printf (\"%sunknown???\", kind_str);"
    },
    {
      "sha": "333863e6d6e5599626d74ea21ee0936642fe5764",
      "filename": "gdb/target/waitstatus.h",
      "status": "modified",
      "additions": 232,
      "deletions": 4,
      "changes": 236,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/target/waitstatus.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/target/waitstatus.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target/waitstatus.h?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -103,22 +103,250 @@ enum target_waitkind\n \n struct target_waitstatus\n {\n-  enum target_waitkind kind;\n+  /* Default constructor.  */\n+  target_waitstatus () = default;\n+\n+  /* Copy constructor.  */\n+\n+  target_waitstatus (const target_waitstatus &other)\n+  {\n+    m_kind = other.m_kind;\n+    m_value = other.m_value;\n+\n+    if (m_kind == TARGET_WAITKIND_EXECD)\n+      m_value.execd_pathname = xstrdup (m_value.execd_pathname);\n+  }\n+\n+  /* Move constructor.  */\n+\n+  target_waitstatus (target_waitstatus &&other)\n+  {\n+    m_kind = other.m_kind;\n+    m_value = other.m_value;\n+\n+    if (m_kind == TARGET_WAITKIND_EXECD)\n+      other.m_value.execd_pathname = nullptr;\n+\n+    other.reset ();\n+  }\n+\n+  /* Copy assignment operator.  */\n+\n+  target_waitstatus &operator= (const target_waitstatus &rhs)\n+  {\n+    this->reset ();\n+    m_kind = rhs.m_kind;\n+    m_value = rhs.m_value;\n+\n+    if (m_kind == TARGET_WAITKIND_EXECD)\n+      m_value.execd_pathname = xstrdup (m_value.execd_pathname);\n+\n+    return *this;\n+  }\n+\n+  /* Move assignment operator.  */\n+\n+  target_waitstatus &operator= (target_waitstatus &&rhs)\n+  {\n+    this->reset ();\n+    m_kind = rhs.m_kind;\n+    m_value = rhs.m_value;\n+\n+    if (m_kind == TARGET_WAITKIND_EXECD)\n+      rhs.m_value.execd_pathname = nullptr;\n+\n+    rhs.reset ();\n+\n+    return *this;\n+  }\n+\n+  /* Destructor.  */\n+\n+  ~target_waitstatus ()\n+  {\n+    this->reset ();\n+  }\n+\n+  /* Setters: set the wait status kind plus any associated data.  */\n+\n+  void set_exited (int exit_status)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_EXITED;\n+    m_value.exit_status = exit_status;\n+  }\n+\n+  void set_stopped (gdb_signal sig)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_STOPPED;\n+    m_value.sig = sig;\n+  }\n+\n+  void set_signalled (gdb_signal sig)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_SIGNALLED;\n+    m_value.sig = sig;\n+  }\n+\n+  void set_loaded ()\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_LOADED;\n+  }\n+\n+  void set_forked (ptid_t child_ptid)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_FORKED;\n+    m_value.child_ptid = child_ptid;\n+  }\n+\n+  void set_vforked (ptid_t child_ptid)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_VFORKED;\n+    m_value.child_ptid = child_ptid;\n+  }\n+\n+  void set_execd (gdb::unique_xmalloc_ptr<char> execd_pathname)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_EXECD;\n+    m_value.execd_pathname = execd_pathname.release ();\n+  }\n+\n+  void set_vfork_done ()\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_VFORK_DONE;\n+  }\n+\n+  void set_syscall_entry (int syscall_number)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_SYSCALL_ENTRY;\n+    m_value.syscall_number = syscall_number;\n+  }\n+\n+  void set_syscall_return (int syscall_number)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_SYSCALL_RETURN;\n+    m_value.syscall_number = syscall_number;\n+  }\n+\n+  void set_spurious ()\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_SPURIOUS;\n+  }\n+\n+  void set_ignore ()\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_IGNORE;\n+  }\n+\n+  void set_no_history ()\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_NO_HISTORY;\n+  }\n+\n+  void set_no_resumed ()\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_NO_RESUMED;\n+  }\n+\n+  void set_thread_created ()\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_THREAD_CREATED;\n+  }\n+\n+  void set_thread_exited (int exit_status)\n+  {\n+    this->reset ();\n+    m_kind = TARGET_WAITKIND_THREAD_EXITED;\n+    m_value.exit_status = exit_status;\n+  }\n+\n+  /* Get the kind of this wait status.  */\n+\n+  target_waitkind kind () const\n+  {\n+    return m_kind;\n+  }\n+\n+  /* Getters for the associated data.\n+\n+     Getters can only be used if the wait status is of the appropriate kind.\n+     See the setters above or the assertions below to know which data is\n+     associated to which kind.  */\n+\n+  int exit_status () const\n+  {\n+    gdb_assert (m_kind == TARGET_WAITKIND_EXITED\n+\t\t|| m_kind == TARGET_WAITKIND_THREAD_EXITED);\n+    return m_value.exit_status;\n+  }\n+\n+  gdb_signal sig () const\n+  {\n+    gdb_assert (m_kind == TARGET_WAITKIND_STOPPED\n+\t\t|| m_kind == TARGET_WAITKIND_SIGNALLED);\n+    return m_value.sig;\n+  }\n+\n+  ptid_t child_ptid () const\n+  {\n+    gdb_assert (m_kind == TARGET_WAITKIND_FORKED\n+\t\t|| m_kind == TARGET_WAITKIND_VFORKED);\n+    return m_value.child_ptid;\n+  }\n+\n+  const char *execd_pathname () const\n+  {\n+    gdb_assert (m_kind == TARGET_WAITKIND_EXECD);\n+    return m_value.execd_pathname;\n+  }\n+\n+  int syscall_number () const\n+  {\n+    gdb_assert (m_kind == TARGET_WAITKIND_SYSCALL_ENTRY\n+\t\t|| m_kind == TARGET_WAITKIND_SYSCALL_RETURN);\n+    return m_value.syscall_number;\n+  }\n+\n+private:\n+  /* Reset the wait status to its original state.  */\n+  void reset ()\n+  {\n+    if (m_kind == TARGET_WAITKIND_EXECD)\n+      xfree (m_value.execd_pathname);\n+\n+    m_kind = TARGET_WAITKIND_IGNORE;\n+  }\n+\n+  target_waitkind m_kind = TARGET_WAITKIND_IGNORE;\n \n   /* Additional information about the event.  */\n   union\n     {\n       /* Exit status */\n-      int integer;\n+      int exit_status;\n       /* Signal number */\n       enum gdb_signal sig;\n       /* Forked child pid */\n-      ptid_t related_pid;\n+      ptid_t child_ptid;\n       /* execd pathname */\n       char *execd_pathname;\n       /* Syscall number */\n       int syscall_number;\n-    } value;\n+    } m_value;\n };\n \n /* Extended reasons that can explain why a target/thread stopped for a"
    },
    {
      "sha": "ee9f05325cd4cbde636a3aed65688041c7890920",
      "filename": "gdb/thread.c",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/thread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/thread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/thread.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -297,9 +297,7 @@ thread_info::thread_info (struct inferior *inf_, ptid_t ptid_)\n   this->per_inf_num = ++inf_->highest_thread_num;\n \n   /* Nothing to follow yet.  */\n-  memset (&this->pending_follow, 0, sizeof (this->pending_follow));\n-  this->pending_follow.kind = TARGET_WAITKIND_SPURIOUS;\n-  this->m_suspend.waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+  this->pending_follow.set_spurious ();\n }\n \n /* See gdbthread.h.  */"
    },
    {
      "sha": "a26d6eac816721f9b85b23cc69f272297e05d6a0",
      "filename": "gdb/windows-nat.c",
      "status": "modified",
      "additions": 11,
      "deletions": 19,
      "changes": 30,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdb/windows-nat.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdb/windows-nat.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/windows-nat.c?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -937,13 +937,12 @@ windows_nat::handle_output_debug_string (struct target_waitstatus *ourstatus)\n       int sig = strtol (s.get () + sizeof (_CYGWIN_SIGNAL_STRING) - 1, &p, 0);\n       gdb_signal gotasig = gdb_signal_from_host (sig);\n \n-      ourstatus->value.sig = gotasig;\n       if (gotasig)\n \t{\n \t  LPCVOID x;\n \t  SIZE_T n;\n \n-\t  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n+\t  ourstatus->set_stopped (gotasig);\n \t  retval = strtoul (p, &p, 0);\n \t  if (!retval)\n \t    retval = current_event.dwThreadId;\n@@ -1505,7 +1504,7 @@ windows_nat_target::get_windows_debug_event (int pid,\n   continue_status = DBG_CONTINUE;\n \n   event_code = current_event.dwDebugEventCode;\n-  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+  ourstatus->set_spurious ();\n   have_saved_context = 0;\n \n   switch (event_code)\n@@ -1595,15 +1594,10 @@ windows_nat_target::get_windows_debug_event (int pid,\n \t  int exit_signal\n \t    = WIFSIGNALED (exit_status) ? WTERMSIG (exit_status) : -1;\n \t  if (exit_signal == -1)\n-\t    {\n-\t      ourstatus->kind = TARGET_WAITKIND_EXITED;\n-\t      ourstatus->value.integer = exit_status;\n-\t    }\n+\t    ourstatus->set_exited (exit_status);\n \t  else\n-\t    {\n-\t      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-\t      ourstatus->value.sig = gdb_signal_from_host (exit_signal);\n-\t    }\n+\t    ourstatus->set_signalled (gdb_signal_from_host (exit_signal));\n+\n \t  thread_id = current_event.dwThreadId;\n \t}\n       break;\n@@ -1617,8 +1611,7 @@ windows_nat_target::get_windows_debug_event (int pid,\n       if (saw_create != 1 || ! windows_initialization_done)\n \tbreak;\n       catch_errors (dll_loaded_event);\n-      ourstatus->kind = TARGET_WAITKIND_LOADED;\n-      ourstatus->value.integer = 0;\n+      ourstatus->set_loaded ();\n       thread_id = current_event.dwThreadId;\n       break;\n \n@@ -1630,8 +1623,7 @@ windows_nat_target::get_windows_debug_event (int pid,\n       if (saw_create != 1 || ! windows_initialization_done)\n \tbreak;\n       catch_errors (handle_unload_dll);\n-      ourstatus->kind = TARGET_WAITKIND_LOADED;\n-      ourstatus->value.integer = 0;\n+      ourstatus->set_loaded ();\n       thread_id = current_event.dwThreadId;\n       break;\n \n@@ -1762,8 +1754,8 @@ windows_nat_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t{\n \t  ptid_t result = ptid_t (current_event.dwProcessId, retval, 0);\n \n-\t  if (ourstatus->kind != TARGET_WAITKIND_EXITED\n-\t      && ourstatus->kind !=  TARGET_WAITKIND_SIGNALLED)\n+\t  if (ourstatus->kind () != TARGET_WAITKIND_EXITED\n+\t      && ourstatus->kind () !=  TARGET_WAITKIND_SIGNALLED)\n \t    {\n \t      windows_thread_info *th = thread_rec (result, INVALIDATE_CONTEXT);\n \n@@ -1856,8 +1848,8 @@ windows_nat_target::do_initial_windows_stuff (DWORD pid, bool attaching)\n \n       /* Note windows_wait returns TARGET_WAITKIND_SPURIOUS for thread\n \t events.  */\n-      if (status.kind != TARGET_WAITKIND_LOADED\n-\t  && status.kind != TARGET_WAITKIND_SPURIOUS)\n+      if (status.kind () != TARGET_WAITKIND_LOADED\n+\t  && status.kind () != TARGET_WAITKIND_SPURIOUS)\n \tbreak;\n \n       this->resume (minus_one_ptid, 0, GDB_SIGNAL_0);"
    },
    {
      "sha": "7c293b1f89d23ddde934339f5e24156fdb5d01c5",
      "filename": "gdbserver/gdbthread.h",
      "status": "modified",
      "additions": 1,
      "deletions": 3,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdbserver/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdbserver/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/gdbthread.h?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -31,9 +31,7 @@ struct thread_info\n {\n   thread_info (ptid_t id, void *target_data)\n     : id (id), target_data (target_data)\n-  {\n-    this->last_status.kind = TARGET_WAITKIND_IGNORE;\n-  }\n+  {}\n \n   ~thread_info ()\n   {"
    },
    {
      "sha": "b6820adbd5656399c977623f8c2caaece5473c09",
      "filename": "gdbserver/linux-low.cc",
      "status": "modified",
      "additions": 64,
      "deletions": 68,
      "changes": 132,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdbserver/linux-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdbserver/linux-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.cc?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -450,7 +450,7 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n   struct thread_info *event_thr = get_lwp_thread (event_lwp);\n   struct lwp_info *new_lwp;\n \n-  gdb_assert (event_lwp->waitstatus.kind == TARGET_WAITKIND_IGNORE);\n+  gdb_assert (event_lwp->waitstatus.kind () == TARGET_WAITKIND_IGNORE);\n \n   /* All extended events we currently use are mid-syscall.  Only\n      PTRACE_EVENT_STOP is delivered more like a signal-stop, but\n@@ -515,7 +515,7 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n \t  child_lwp->status_pending_p = 0;\n \t  child_thr = get_lwp_thread (child_lwp);\n \t  child_thr->last_resume_kind = resume_stop;\n-\t  child_thr->last_status.kind = TARGET_WAITKIND_STOPPED;\n+\t  child_thr->last_status.set_stopped (GDB_SIGNAL_0);\n \n \t  /* If we're suspending all threads, leave this one suspended\n \t     too.  If the fork/clone parent is stepping over a breakpoint,\n@@ -554,11 +554,9 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n \n \t  /* Save fork info in the parent thread.  */\n \t  if (event == PTRACE_EVENT_FORK)\n-\t    event_lwp->waitstatus.kind = TARGET_WAITKIND_FORKED;\n+\t    event_lwp->waitstatus.set_forked (ptid);\n \t  else if (event == PTRACE_EVENT_VFORK)\n-\t    event_lwp->waitstatus.kind = TARGET_WAITKIND_VFORKED;\n-\n-\t  event_lwp->waitstatus.value.related_pid = ptid;\n+\t    event_lwp->waitstatus.set_vforked (ptid);\n \n \t  /* The status_pending field contains bits denoting the\n \t     extended event, so when the pending event is handled,\n@@ -625,7 +623,7 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n \t}\n       else if (cs.report_thread_events)\n \t{\n-\t  new_lwp->waitstatus.kind = TARGET_WAITKIND_THREAD_CREATED;\n+\t  new_lwp->waitstatus.set_thread_created ();\n \t  new_lwp->status_pending_p = 1;\n \t  new_lwp->status_pending = status;\n \t}\n@@ -639,7 +637,7 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n     }\n   else if (event == PTRACE_EVENT_VFORK_DONE)\n     {\n-      event_lwp->waitstatus.kind = TARGET_WAITKIND_VFORK_DONE;\n+      event_lwp->waitstatus.set_vfork_done ();\n \n       if (event_lwp->bp_reinsert != 0 && supports_software_single_step ())\n \t{\n@@ -684,16 +682,16 @@ linux_process_target::handle_extended_wait (lwp_info **orig_event_lwp,\n       arch_setup_thread (event_thr);\n \n       /* Set the event status.  */\n-      event_lwp->waitstatus.kind = TARGET_WAITKIND_EXECD;\n-      event_lwp->waitstatus.value.execd_pathname\n-\t= xstrdup (linux_proc_pid_to_exec_file (lwpid_of (event_thr)));\n+      event_lwp->waitstatus.set_execd\n+\t(make_unique_xstrdup\n+\t   (linux_proc_pid_to_exec_file (lwpid_of (event_thr))));\n \n       /* Mark the exec status as pending.  */\n       event_lwp->stopped = 1;\n       event_lwp->status_pending_p = 1;\n       event_lwp->status_pending = wstat;\n       event_thr->last_resume_kind = resume_continue;\n-      event_thr->last_status.kind = TARGET_WAITKIND_IGNORE;\n+      event_thr->last_status.set_ignore ();\n \n       /* Update syscall state in the new lwp, effectively mid-syscall too.  */\n       event_lwp->syscall_state = TARGET_WAITKIND_SYSCALL_ENTRY;\n@@ -1388,8 +1386,8 @@ get_detach_signal (struct thread_info *thread)\n       /* If the thread had been suspended by gdbserver, and it stopped\n \t cleanly, then it'll have stopped with SIGSTOP.  But we don't\n \t want to deliver that SIGSTOP.  */\n-      if (thread->last_status.kind != TARGET_WAITKIND_STOPPED\n-\t  || thread->last_status.value.sig == GDB_SIGNAL_0)\n+      if (thread->last_status.kind () != TARGET_WAITKIND_STOPPED\n+\t  || thread->last_status.sig () == GDB_SIGNAL_0)\n \treturn 0;\n \n       /* Otherwise, we may need to deliver the signal we\n@@ -1712,7 +1710,7 @@ lwp_resumed (struct lwp_info *lwp)\n      corresponding stop to gdb yet?  If so, the thread is still\n      resumed/running from gdb's perspective.  */\n   if (thread->last_resume_kind == resume_stop\n-      && thread->last_status.kind == TARGET_WAITKIND_IGNORE)\n+      && thread->last_status.kind () == TARGET_WAITKIND_IGNORE)\n     return 1;\n \n   return 0;\n@@ -2464,7 +2462,7 @@ linux_process_target::resume_stopped_resumed_lwps (thread_info *thread)\n   if (lp->stopped\n       && !lp->suspended\n       && !lp->status_pending_p\n-      && thread->last_status.kind == TARGET_WAITKIND_IGNORE)\n+      && thread->last_status.kind () == TARGET_WAITKIND_IGNORE)\n     {\n       int step = 0;\n \n@@ -2710,7 +2708,7 @@ select_event_lwp (struct lwp_info **orig_lp)\n \t{\n \t  lwp_info *lp = get_thread_lwp (thread);\n \n-\t  return (thread->last_status.kind == TARGET_WAITKIND_IGNORE\n+\t  return (thread->last_status.kind () == TARGET_WAITKIND_IGNORE\n \t\t  && thread->last_resume_kind == resume_step\n \t\t  && lp->status_pending_p);\n \t});\n@@ -2732,7 +2730,7 @@ select_event_lwp (struct lwp_info **orig_lp)\n \t  lwp_info *lp = get_thread_lwp (thread);\n \n \t  /* Only resumed LWPs that have an event pending. */\n-\t  return (thread->last_status.kind == TARGET_WAITKIND_IGNORE\n+\t  return (thread->last_status.kind () == TARGET_WAITKIND_IGNORE\n \t\t  && lp->status_pending_p);\n \t});\n     }\n@@ -2831,17 +2829,17 @@ linux_process_target::stabilize_threads ()\n \t over internal breakpoints and such.  */\n       wait_1 (minus_one_ptid, &ourstatus, 0);\n \n-      if (ourstatus.kind == TARGET_WAITKIND_STOPPED)\n+      if (ourstatus.kind () == TARGET_WAITKIND_STOPPED)\n \t{\n \t  lwp = get_thread_lwp (current_thread);\n \n \t  /* Lock it.  */\n \t  lwp_suspended_inc (lwp);\n \n-\t  if (ourstatus.value.sig != GDB_SIGNAL_0\n+\t  if (ourstatus.sig () != GDB_SIGNAL_0\n \t      || current_thread->last_resume_kind == resume_stop)\n \t    {\n-\t      wstat = W_STOPCODE (gdb_signal_to_host (ourstatus.value.sig));\n+\t      wstat = W_STOPCODE (gdb_signal_to_host (ourstatus.sig ()));\n \t      enqueue_one_deferred_signal (lwp, &wstat);\n \t    }\n \t}\n@@ -2877,7 +2875,7 @@ ignore_event (struct target_waitstatus *ourstatus)\n      another target_wait call.  */\n   async_file_mark ();\n \n-  ourstatus->kind = TARGET_WAITKIND_IGNORE;\n+  ourstatus->set_ignore ();\n   return null_ptid;\n }\n \n@@ -2892,9 +2890,9 @@ linux_process_target::filter_exit_event (lwp_info *event_child,\n   if (!last_thread_of_process_p (pid_of (thread)))\n     {\n       if (cs.report_thread_events)\n-\tourstatus->kind = TARGET_WAITKIND_THREAD_EXITED;\n+\tourstatus->set_thread_exited (0);\n       else\n-\tourstatus->kind = TARGET_WAITKIND_IGNORE;\n+\tourstatus->set_ignore ();\n \n       delete_lwp (event_child);\n     }\n@@ -2965,7 +2963,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n   bp_explains_trap = 0;\n   trace_event = 0;\n   in_step_range = 0;\n-  ourstatus->kind = TARGET_WAITKIND_IGNORE;\n+  ourstatus->set_ignore ();\n \n   auto status_pending_p_any = [&] (thread_info *thread)\n     {\n@@ -3006,7 +3004,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t  debug_exit ();\n \t}\n \n-      ourstatus->kind = TARGET_WAITKIND_IGNORE;\n+      ourstatus->set_ignore ();\n       return null_ptid;\n     }\n   else if (pid == -1)\n@@ -3018,7 +3016,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t  debug_exit ();\n \t}\n \n-      ourstatus->kind = TARGET_WAITKIND_NO_RESUMED;\n+      ourstatus->set_no_resumed ();\n       return null_ptid;\n     }\n \n@@ -3030,8 +3028,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n     {\n       if (WIFEXITED (w))\n \t{\n-\t  ourstatus->kind = TARGET_WAITKIND_EXITED;\n-\t  ourstatus->value.integer = WEXITSTATUS (w);\n+\t  ourstatus->set_exited (WEXITSTATUS (w));\n \n \t  if (debug_threads)\n \t    {\n@@ -3044,8 +3041,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t}\n       else\n \t{\n-\t  ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-\t  ourstatus->value.sig = gdb_signal_from_host (WTERMSIG (w));\n+\t  ourstatus->set_signalled (gdb_signal_from_host (WTERMSIG (w)));\n \n \t  if (debug_threads)\n \t    {\n@@ -3057,7 +3053,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t    }\n \t}\n \n-      if (ourstatus->kind == TARGET_WAITKIND_EXITED)\n+      if (ourstatus->kind () == TARGET_WAITKIND_EXITED)\n \treturn filter_exit_event (event_child, ourstatus);\n \n       return ptid_of (current_thread);\n@@ -3252,8 +3248,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \n \t      if (stabilizing_threads)\n \t\t{\n-\t\t  ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-\t\t  ourstatus->value.sig = GDB_SIGNAL_0;\n+\t\t  ourstatus->set_stopped (GDB_SIGNAL_0);\n \n \t\t  if (debug_threads)\n \t\t    {\n@@ -3378,7 +3373,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \t\t   || (gdb_breakpoint_here (event_child->stop_pc)\n \t\t       && gdb_condition_true_at_breakpoint (event_child->stop_pc)\n \t\t       && gdb_no_commands_at_breakpoint (event_child->stop_pc))\n-\t\t   || event_child->waitstatus.kind != TARGET_WAITKIND_IGNORE);\n+\t\t   || event_child->waitstatus.kind () != TARGET_WAITKIND_IGNORE);\n \n   run_breakpoint_commands (event_child->stop_pc);\n \n@@ -3448,7 +3443,7 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \n   if (debug_threads)\n     {\n-      if (event_child->waitstatus.kind != TARGET_WAITKIND_IGNORE)\n+      if (event_child->waitstatus.kind () != TARGET_WAITKIND_IGNORE)\n \t{\n \t  std::string str\n \t    = target_waitstatus_to_string (&event_child->waitstatus);\n@@ -3589,25 +3584,28 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \tunstop_all_lwps (1, event_child);\n     }\n \n-  if (event_child->waitstatus.kind != TARGET_WAITKIND_IGNORE)\n+  if (event_child->waitstatus.kind () != TARGET_WAITKIND_IGNORE)\n     {\n       /* If the reported event is an exit, fork, vfork or exec, let\n \t GDB know.  */\n \n       /* Break the unreported fork relationship chain.  */\n-      if (event_child->waitstatus.kind == TARGET_WAITKIND_FORKED\n-\t  || event_child->waitstatus.kind == TARGET_WAITKIND_VFORKED)\n+      if (event_child->waitstatus.kind () == TARGET_WAITKIND_FORKED\n+\t  || event_child->waitstatus.kind () == TARGET_WAITKIND_VFORKED)\n \t{\n \t  event_child->fork_relative->fork_relative = NULL;\n \t  event_child->fork_relative = NULL;\n \t}\n \n       *ourstatus = event_child->waitstatus;\n       /* Clear the event lwp's waitstatus since we handled it already.  */\n-      event_child->waitstatus.kind = TARGET_WAITKIND_IGNORE;\n+      event_child->waitstatus.set_ignore ();\n     }\n   else\n-    ourstatus->kind = TARGET_WAITKIND_STOPPED;\n+    {\n+      /* The actual stop signal is overwritten below.  */\n+      ourstatus->set_stopped (GDB_SIGNAL_0);\n+    }\n \n   /* Now that we've selected our final event LWP, un-adjust its PC if\n      it was a software breakpoint, and the client doesn't know we can\n@@ -3627,41 +3625,45 @@ linux_process_target::wait_1 (ptid_t ptid, target_waitstatus *ourstatus,\n \n   if (WSTOPSIG (w) == SYSCALL_SIGTRAP)\n     {\n-      get_syscall_trapinfo (event_child,\n-\t\t\t    &ourstatus->value.syscall_number);\n-      ourstatus->kind = event_child->syscall_state;\n+      int syscall_number;\n+\n+      get_syscall_trapinfo (event_child, &syscall_number);\n+      if (event_child->syscall_state == TARGET_WAITKIND_SYSCALL_ENTRY)\n+\tourstatus->set_syscall_entry (syscall_number);\n+      else if (event_child->syscall_state == TARGET_WAITKIND_SYSCALL_RETURN)\n+\tourstatus->set_syscall_return (syscall_number);\n+      else\n+\tgdb_assert_not_reached (\"unexpected syscall state\");\n     }\n   else if (current_thread->last_resume_kind == resume_stop\n \t   && WSTOPSIG (w) == SIGSTOP)\n     {\n       /* A thread that has been requested to stop by GDB with vCont;t,\n \t and it stopped cleanly, so report as SIG0.  The use of\n \t SIGSTOP is an implementation detail.  */\n-      ourstatus->value.sig = GDB_SIGNAL_0;\n+      ourstatus->set_stopped (GDB_SIGNAL_0);\n     }\n   else if (current_thread->last_resume_kind == resume_stop\n \t   && WSTOPSIG (w) != SIGSTOP)\n     {\n       /* A thread that has been requested to stop by GDB with vCont;t,\n \t but, it stopped for other reasons.  */\n-      ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (w));\n-    }\n-  else if (ourstatus->kind == TARGET_WAITKIND_STOPPED)\n-    {\n-      ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (w));\n+      ourstatus->set_stopped (gdb_signal_from_host (WSTOPSIG (w)));\n     }\n+  else if (ourstatus->kind () == TARGET_WAITKIND_STOPPED)\n+    ourstatus->set_stopped (gdb_signal_from_host (WSTOPSIG (w)));\n \n   gdb_assert (step_over_bkpt == null_ptid);\n \n   if (debug_threads)\n     {\n       debug_printf (\"wait_1 ret = %s, %d, %d\\n\",\n \t\t    target_pid_to_str (ptid_of (current_thread)),\n-\t\t    ourstatus->kind, ourstatus->value.sig);\n+\t\t    ourstatus->kind (), ourstatus->sig ());\n       debug_exit ();\n     }\n \n-  if (ourstatus->kind == TARGET_WAITKIND_EXITED)\n+  if (ourstatus->kind () == TARGET_WAITKIND_EXITED)\n     return filter_exit_event (event_child, ourstatus);\n \n   return ptid_of (current_thread);\n@@ -3712,7 +3714,7 @@ linux_process_target::wait (ptid_t ptid,\n     }\n   while ((target_options & TARGET_WNOHANG) == 0\n \t && event_ptid == null_ptid\n-\t && ourstatus->kind == TARGET_WAITKIND_IGNORE);\n+\t && ourstatus->kind () == TARGET_WAITKIND_IGNORE);\n \n   /* If at least one stop was reported, there may be more.  A single\n      SIGCHLD can signal more than one child stop.  */\n@@ -3813,15 +3815,9 @@ mark_lwp_dead (struct lwp_info *lwp, int wstat)\n   /* Store in waitstatus as well, as there's nothing else to process\n      for this event.  */\n   if (WIFEXITED (wstat))\n-    {\n-      lwp->waitstatus.kind = TARGET_WAITKIND_EXITED;\n-      lwp->waitstatus.value.integer = WEXITSTATUS (wstat);\n-    }\n+    lwp->waitstatus.set_exited (WEXITSTATUS (wstat));\n   else if (WIFSIGNALED (wstat))\n-    {\n-      lwp->waitstatus.kind = TARGET_WAITKIND_SIGNALLED;\n-      lwp->waitstatus.value.sig = gdb_signal_from_host (WTERMSIG (wstat));\n-    }\n+    lwp->waitstatus.set_signalled (gdb_signal_from_host (WTERMSIG (wstat)));\n \n   /* Prevent trying to stop it.  */\n   lwp->stopped = 1;\n@@ -4087,7 +4083,7 @@ linux_process_target::resume_one_lwp_throw (lwp_info *lwp, int step,\n   if (lwp->stopped == 0)\n     return;\n \n-  gdb_assert (lwp->waitstatus.kind == TARGET_WAITKIND_IGNORE);\n+  gdb_assert (lwp->waitstatus.kind () == TARGET_WAITKIND_IGNORE);\n \n   fast_tpoint_collect_result fast_tp_collecting\n     = lwp->collecting_fast_tracepoint;\n@@ -4351,7 +4347,7 @@ linux_set_resume_request (thread_info *thread, thread_resume *resume, size_t n)\n \t    {\n \t      if (debug_threads)\n \t\tdebug_printf (\"already %s LWP %ld at GDB's request\\n\",\n-\t\t\t      (thread->last_status.kind\n+\t\t\t      (thread->last_status.kind ()\n \t\t\t       == TARGET_WAITKIND_STOPPED)\n \t\t\t      ? \"stopped\"\n \t\t\t      : \"stopping\",\n@@ -4382,8 +4378,8 @@ linux_set_resume_request (thread_info *thread, thread_resume *resume, size_t n)\n \t      struct lwp_info *rel = lwp->fork_relative;\n \n \t      if (rel->status_pending_p\n-\t\t  && (rel->waitstatus.kind == TARGET_WAITKIND_FORKED\n-\t\t      || rel->waitstatus.kind == TARGET_WAITKIND_VFORKED))\n+\t\t  && (rel->waitstatus.kind () == TARGET_WAITKIND_FORKED\n+\t\t      || rel->waitstatus.kind () == TARGET_WAITKIND_VFORKED))\n \t\t{\n \t\t  if (debug_threads)\n \t\t    debug_printf (\"not resuming LWP %ld: has queued stop reply\\n\",\n@@ -4771,7 +4767,7 @@ linux_process_target::resume_one_thread (thread_info *thread,\n \n       /* For stop requests, we're done.  */\n       lwp->resume = NULL;\n-      thread->last_status.kind = TARGET_WAITKIND_IGNORE;\n+      thread->last_status.set_ignore ();\n       return;\n     }\n \n@@ -4818,7 +4814,7 @@ linux_process_target::resume_one_thread (thread_info *thread,\n \tdebug_printf (\"leaving LWP %ld stopped\\n\", lwpid_of (thread));\n     }\n \n-  thread->last_status.kind = TARGET_WAITKIND_IGNORE;\n+  thread->last_status.set_ignore ();\n   lwp->resume = NULL;\n }\n \n@@ -4918,7 +4914,7 @@ linux_process_target::proceed_one_lwp (thread_info *thread, lwp_info *except)\n     }\n \n   if (thread->last_resume_kind == resume_stop\n-      && thread->last_status.kind != TARGET_WAITKIND_IGNORE)\n+      && thread->last_status.kind () != TARGET_WAITKIND_IGNORE)\n     {\n       if (debug_threads)\n \tdebug_printf (\"   client wants LWP to remain %ld stopped\\n\","
    },
    {
      "sha": "05067ffc6e6fa3c7d50277b94245118ecaa57a49",
      "filename": "gdbserver/linux-low.h",
      "status": "modified",
      "additions": 0,
      "deletions": 5,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdbserver/linux-low.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdbserver/linux-low.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/linux-low.h?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -721,11 +721,6 @@ struct pending_signal\n \n struct lwp_info\n {\n-  lwp_info ()\n-  {\n-    this->waitstatus.kind = TARGET_WAITKIND_IGNORE;\n-  }\n-\n   /* Backlink to the parent object.  */\n   struct thread_info *thread = nullptr;\n "
    },
    {
      "sha": "ada92c1fd60deee16165cbe27981058bcc7845a9",
      "filename": "gdbserver/netbsd-low.cc",
      "status": "modified",
      "additions": 20,
      "deletions": 30,
      "changes": 50,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdbserver/netbsd-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdbserver/netbsd-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/netbsd-low.cc?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -206,20 +206,11 @@ static void\n netbsd_store_waitstatus (struct target_waitstatus *ourstatus, int hoststatus)\n {\n   if (WIFEXITED (hoststatus))\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_EXITED;\n-      ourstatus->value.integer = WEXITSTATUS (hoststatus);\n-    }\n+    ourstatus->set_exited (WEXITSTATUS (hoststatus));\n   else if (!WIFSTOPPED (hoststatus))\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-      ourstatus->value.sig = gdb_signal_from_host (WTERMSIG (hoststatus));\n-    }\n+    ourstatus->set_signalled (gdb_signal_from_host (WTERMSIG (hoststatus)));\n   else\n-    {\n-      ourstatus->kind = TARGET_WAITKIND_STOPPED;\n-      ourstatus->value.sig = gdb_signal_from_host (WSTOPSIG (hoststatus));\n-    }\n+    ourstatus->set_stopped (gdb_signal_from_host (WSTOPSIG (hoststatus)));\n }\n \n /* Implement a safe wrapper around waitpid().  */\n@@ -258,14 +249,14 @@ netbsd_wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n   if (pid == 0)\n     {\n       gdb_assert (target_options & TARGET_WNOHANG);\n-      ourstatus->kind = TARGET_WAITKIND_IGNORE;\n+      ourstatus->set_ignore ();\n       return null_ptid;\n     }\n \n   gdb_assert (pid != -1);\n \n   /* If the child stopped, keep investigating its status.  */\n-  if (ourstatus->kind != TARGET_WAITKIND_STOPPED)\n+  if (ourstatus->kind () != TARGET_WAITKIND_STOPPED)\n     return wptid;\n \n   /* Extract the event and thread that received a signal.  */\n@@ -307,12 +298,11 @@ netbsd_wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t Ignore exited events for an unknown LWP.  */\n       thread_info *thr = find_thread_ptid (wptid);\n       if (thr == nullptr)\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ourstatus->set_spurious ();\n       else\n \t{\n-\t  ourstatus->kind = TARGET_WAITKIND_THREAD_EXITED;\n \t  /* NetBSD does not store an LWP exit status.  */\n-\t  ourstatus->value.integer = 0;\n+\t  ourstatus->set_thread_exited (0);\n \n \t  remove_thread (thr);\n \t}\n@@ -329,20 +319,19 @@ netbsd_wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t not yet reported their PTRACE_LWP_CREATE event.  Ignore\n \t born events for an already-known LWP.  */\n       if (find_thread_ptid (wptid))\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\tourstatus->set_spurious ();\n       else\n \t{\n \t  add_thread (wptid, NULL);\n-\t  ourstatus->kind = TARGET_WAITKIND_THREAD_CREATED;\n+\t  ourstatus->set_thread_created ();\n \t}\n       return wptid;\n     }\n \n   if (code == TRAP_EXEC)\n     {\n-      ourstatus->kind = TARGET_WAITKIND_EXECD;\n-      ourstatus->value.execd_pathname\n-\t= xstrdup (netbsd_nat::pid_to_exec_file (pid));\n+      ourstatus->set_execd\n+\t(make_unique_xstrdup (netbsd_nat::pid_to_exec_file (pid)));\n       return wptid;\n     }\n \n@@ -356,14 +345,15 @@ netbsd_wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n       if (!netbsd_catch_this_syscall(sysnum))\n \t{\n \t  /* If the core isn't interested in this event, ignore it.  */\n-\t  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+\t  ourstatus->set_spurious ();\n \t  return wptid;\n \t}\n \n-      ourstatus->kind\n-\t= ((code == TRAP_SCE) ? TARGET_WAITKIND_SYSCALL_ENTRY :\n-\t   TARGET_WAITKIND_SYSCALL_RETURN);\n-      ourstatus->value.syscall_number = sysnum;\n+      if (code == TRAP_SCE)\n+\tourstatus->set_syscall_entry (sysnum);\n+      else\n+\tourstatus->set_syscall_return (sysnum);\n+\n       return wptid;\n     }\n \n@@ -381,7 +371,7 @@ netbsd_wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n     }\n \n   /* Unclassified SIGTRAP event.  */\n-  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+  ourstatus->set_spurious ();\n   return wptid;\n }\n \n@@ -401,10 +391,10 @@ netbsd_process_target::wait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \t This may also happen on attach, when an event is registered on a thread\n \t that was not fully initialized during the attach stage.  */\n       if (wptid.lwp () != 0 && !find_thread_ptid (wptid)\n-\t  && ourstatus->kind != TARGET_WAITKIND_THREAD_EXITED)\n+\t  && ourstatus->kind () != TARGET_WAITKIND_THREAD_EXITED)\n \tadd_thread (wptid, nullptr);\n \n-      switch (ourstatus->kind)\n+      switch (ourstatus->kind ())\n \t{\n \tcase TARGET_WAITKIND_EXITED:\n \tcase TARGET_WAITKIND_STOPPED:"
    },
    {
      "sha": "a4cc3267996ec390a042114e572e6bfd7902a50c",
      "filename": "gdbserver/remote-utils.cc",
      "status": "modified",
      "additions": 21,
      "deletions": 23,
      "changes": 44,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdbserver/remote-utils.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdbserver/remote-utils.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/remote-utils.cc?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -1087,9 +1087,9 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n   client_state &cs = get_client_state ();\n   if (debug_threads)\n     debug_printf (\"Writing resume reply for %s:%d\\n\",\n-\t\t  target_pid_to_str (ptid), status->kind);\n+\t\t  target_pid_to_str (ptid), status->kind ());\n \n-  switch (status->kind)\n+  switch (status->kind ())\n     {\n     case TARGET_WAITKIND_STOPPED:\n     case TARGET_WAITKIND_FORKED:\n@@ -1104,27 +1104,27 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n \tconst char **regp;\n \tstruct regcache *regcache;\n \n-\tif ((status->kind == TARGET_WAITKIND_FORKED && cs.report_fork_events)\n-\t    || (status->kind == TARGET_WAITKIND_VFORKED \n+\tif ((status->kind () == TARGET_WAITKIND_FORKED && cs.report_fork_events)\n+\t    || (status->kind () == TARGET_WAITKIND_VFORKED\n \t\t&& cs.report_vfork_events))\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n-\t    const char *event = (status->kind == TARGET_WAITKIND_FORKED\n+\t    const char *event = (status->kind () == TARGET_WAITKIND_FORKED\n \t\t\t\t ? \"fork\" : \"vfork\");\n \n \t    sprintf (buf, \"T%02x%s:\", signal, event);\n \t    buf += strlen (buf);\n-\t    buf = write_ptid (buf, status->value.related_pid);\n+\t    buf = write_ptid (buf, status->child_ptid ());\n \t    strcat (buf, \";\");\n \t  }\n-\telse if (status->kind == TARGET_WAITKIND_VFORK_DONE \n+\telse if (status->kind () == TARGET_WAITKIND_VFORK_DONE\n \t\t && cs.report_vfork_events)\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n \n \t    sprintf (buf, \"T%02xvforkdone:;\", signal);\n \t  }\n-\telse if (status->kind == TARGET_WAITKIND_EXECD && cs.report_exec_events)\n+\telse if (status->kind () == TARGET_WAITKIND_EXECD && cs.report_exec_events)\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n \t    const char *event = \"exec\";\n@@ -1134,34 +1134,32 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n \t    buf += strlen (buf);\n \n \t    /* Encode pathname to hexified format.  */\n-\t    bin2hex ((const gdb_byte *) status->value.execd_pathname,\n+\t    bin2hex ((const gdb_byte *) status->execd_pathname (),\n \t\t     hexified_pathname,\n-\t\t     strlen (status->value.execd_pathname));\n+\t\t     strlen (status->execd_pathname ()));\n \n \t    sprintf (buf, \"%s;\", hexified_pathname);\n-\t    xfree (status->value.execd_pathname);\n-\t    status->value.execd_pathname = NULL;\n \t    buf += strlen (buf);\n \t  }\n-\telse if (status->kind == TARGET_WAITKIND_THREAD_CREATED\n+\telse if (status->kind () == TARGET_WAITKIND_THREAD_CREATED\n \t\t && cs.report_thread_events)\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n \n \t    sprintf (buf, \"T%02xcreate:;\", signal);\n \t  }\n-\telse if (status->kind == TARGET_WAITKIND_SYSCALL_ENTRY\n-\t\t || status->kind == TARGET_WAITKIND_SYSCALL_RETURN)\n+\telse if (status->kind () == TARGET_WAITKIND_SYSCALL_ENTRY\n+\t\t || status->kind () == TARGET_WAITKIND_SYSCALL_RETURN)\n \t  {\n \t    enum gdb_signal signal = GDB_SIGNAL_TRAP;\n-\t    const char *event = (status->kind == TARGET_WAITKIND_SYSCALL_ENTRY\n+\t    const char *event = (status->kind () == TARGET_WAITKIND_SYSCALL_ENTRY\n \t\t\t\t ? \"syscall_entry\" : \"syscall_return\");\n \n \t    sprintf (buf, \"T%02x%s:%x;\", signal, event,\n-\t\t     status->value.syscall_number);\n+\t\t     status->syscall_number ());\n \t  }\n \telse\n-\t  sprintf (buf, \"T%02x\", status->value.sig);\n+\t  sprintf (buf, \"T%02x\", status->sig ());\n \n \tif (disable_packet_T)\n \t  {\n@@ -1283,19 +1281,19 @@ prepare_resume_reply (char *buf, ptid_t ptid,\n     case TARGET_WAITKIND_EXITED:\n       if (cs.multi_process)\n \tsprintf (buf, \"W%x;process:%x\",\n-\t\t status->value.integer, ptid.pid ());\n+\t\t status->exit_status (), ptid.pid ());\n       else\n-\tsprintf (buf, \"W%02x\", status->value.integer);\n+\tsprintf (buf, \"W%02x\", status->exit_status ());\n       break;\n     case TARGET_WAITKIND_SIGNALLED:\n       if (cs.multi_process)\n \tsprintf (buf, \"X%x;process:%x\",\n-\t\t status->value.sig, ptid.pid ());\n+\t\t status->sig (), ptid.pid ());\n       else\n-\tsprintf (buf, \"X%02x\", status->value.sig);\n+\tsprintf (buf, \"X%02x\", status->sig ());\n       break;\n     case TARGET_WAITKIND_THREAD_EXITED:\n-      sprintf (buf, \"w%x;\", status->value.integer);\n+      sprintf (buf, \"w%x;\", status->exit_status ());\n       buf += strlen (buf);\n       buf = write_ptid (buf, ptid);\n       break;"
    },
    {
      "sha": "2cb378ce9c911d714ed56697044f2b68dd277d78",
      "filename": "gdbserver/server.cc",
      "status": "modified",
      "additions": 42,
      "deletions": 48,
      "changes": 90,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdbserver/server.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdbserver/server.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/server.cc?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -239,9 +239,9 @@ in_queued_stop_replies_ptid (struct notif_event *event, ptid_t filter_ptid)\n     return true;\n \n   /* Don't resume fork children that GDB does not know about yet.  */\n-  if ((vstop_event->status.kind == TARGET_WAITKIND_FORKED\n-       || vstop_event->status.kind == TARGET_WAITKIND_VFORKED)\n-      && vstop_event->status.value.related_pid.matches (filter_ptid))\n+  if ((vstop_event->status.kind () == TARGET_WAITKIND_FORKED\n+       || vstop_event->status.kind () == TARGET_WAITKIND_VFORKED)\n+      && vstop_event->status.child_ptid ().matches (filter_ptid))\n     return true;\n \n   return false;\n@@ -327,9 +327,9 @@ attach_inferior (int pid)\n       /* GDB knows to ignore the first SIGSTOP after attaching to a running\n \t process using the \"attach\" command, but this is different; it's\n \t just using \"target remote\".  Pretend it's just starting up.  */\n-      if (cs.last_status.kind == TARGET_WAITKIND_STOPPED\n-\t  && cs.last_status.value.sig == GDB_SIGNAL_STOP)\n-\tcs.last_status.value.sig = GDB_SIGNAL_TRAP;\n+      if (cs.last_status.kind () == TARGET_WAITKIND_STOPPED\n+\t  && cs.last_status.sig () == GDB_SIGNAL_STOP)\n+\tcs.last_status.set_stopped (GDB_SIGNAL_TRAP);\n \n       current_thread->last_resume_kind = resume_stop;\n       current_thread->last_status = cs.last_status;\n@@ -1262,8 +1262,7 @@ handle_detach (char *own_buf)\n \t  /* There is still at least one inferior remaining or\n \t     we are in extended mode, so don't terminate gdbserver,\n \t     and instead treat this like a normal program exit.  */\n-\t  cs.last_status.kind = TARGET_WAITKIND_EXITED;\n-\t  cs.last_status.value.integer = 0;\n+\t  cs.last_status.set_exited (0);\n \t  cs.last_ptid = ptid_t (pid);\n \n \t  current_thread = NULL;\n@@ -2944,7 +2943,7 @@ resume (struct thread_resume *actions, size_t num_actions)\n     {\n       cs.last_ptid = mywait (minus_one_ptid, &cs.last_status, 0, 1);\n \n-      if (cs.last_status.kind == TARGET_WAITKIND_NO_RESUMED\n+      if (cs.last_status.kind () == TARGET_WAITKIND_NO_RESUMED\n \t  && !report_no_resumed)\n \t{\n \t  /* The client does not support this stop reply.  At least\n@@ -2954,9 +2953,9 @@ resume (struct thread_resume *actions, size_t num_actions)\n \t  return;\n \t}\n \n-      if (cs.last_status.kind != TARGET_WAITKIND_EXITED\n-\t  && cs.last_status.kind != TARGET_WAITKIND_SIGNALLED\n-\t  && cs.last_status.kind != TARGET_WAITKIND_NO_RESUMED)\n+      if (cs.last_status.kind () != TARGET_WAITKIND_EXITED\n+\t  && cs.last_status.kind () != TARGET_WAITKIND_SIGNALLED\n+\t  && cs.last_status.kind () != TARGET_WAITKIND_NO_RESUMED)\n \tcurrent_thread->last_status = cs.last_status;\n \n       /* From the client's perspective, all-stop mode always stops all\n@@ -2967,8 +2966,8 @@ resume (struct thread_resume *actions, size_t num_actions)\n       prepare_resume_reply (cs.own_buf, cs.last_ptid, &cs.last_status);\n       disable_async_io ();\n \n-      if (cs.last_status.kind == TARGET_WAITKIND_EXITED\n-\t  || cs.last_status.kind == TARGET_WAITKIND_SIGNALLED)\n+      if (cs.last_status.kind () == TARGET_WAITKIND_EXITED\n+\t  || cs.last_status.kind () == TARGET_WAITKIND_SIGNALLED)\n \ttarget_mourn_inferior (cs.last_ptid);\n     }\n }\n@@ -3113,7 +3112,7 @@ handle_v_run (char *own_buf)\n \n   target_create_inferior (program_path.get (), program_args);\n \n-  if (cs.last_status.kind == TARGET_WAITKIND_STOPPED)\n+  if (cs.last_status.kind () == TARGET_WAITKIND_STOPPED)\n     {\n       prepare_resume_reply (own_buf, cs.last_ptid, &cs.last_status);\n \n@@ -3143,8 +3142,7 @@ handle_v_kill (char *own_buf)\n \n   if (proc != nullptr && kill_inferior (proc) == 0)\n     {\n-      cs.last_status.kind = TARGET_WAITKIND_SIGNALLED;\n-      cs.last_status.value.sig = GDB_SIGNAL_KILL;\n+      cs.last_status.set_signalled (GDB_SIGNAL_KILL);\n       cs.last_ptid = ptid_t (pid);\n       discard_queued_stop_replies (cs.last_ptid);\n       write_ok (own_buf);\n@@ -3316,7 +3314,7 @@ queue_stop_reply_callback (thread_info *thread)\n \t\t\t    status_string.c_str ());\n \t    }\n \n-\t  gdb_assert (thread->last_status.kind != TARGET_WAITKIND_IGNORE);\n+\t  gdb_assert (thread->last_status.kind () != TARGET_WAITKIND_IGNORE);\n \n \t  /* Pass the last stop reply back to GDB, but don't notify\n \t     yet.  */\n@@ -3334,12 +3332,11 @@ gdb_wants_thread_stopped (thread_info *thread)\n {\n   thread->last_resume_kind = resume_stop;\n \n-  if (thread->last_status.kind == TARGET_WAITKIND_IGNORE)\n+  if (thread->last_status.kind () == TARGET_WAITKIND_IGNORE)\n     {\n       /* Most threads are stopped implicitly (all-stop); tag that with\n \t signal 0.  */\n-      thread->last_status.kind = TARGET_WAITKIND_STOPPED;\n-      thread->last_status.value.sig = GDB_SIGNAL_0;\n+      thread->last_status.set_stopped (GDB_SIGNAL_0);\n     }\n }\n \n@@ -3357,15 +3354,15 @@ gdb_wants_all_threads_stopped (void)\n static void\n set_pending_status_callback (thread_info *thread)\n {\n-  if (thread->last_status.kind != TARGET_WAITKIND_STOPPED\n-      || (thread->last_status.value.sig != GDB_SIGNAL_0\n+  if (thread->last_status.kind () != TARGET_WAITKIND_STOPPED\n+      || (thread->last_status.sig () != GDB_SIGNAL_0\n \t  /* A breakpoint, watchpoint or finished step from a previous\n \t     GDB run isn't considered interesting for a new GDB run.\n \t     If we left those pending, the new GDB could consider them\n \t     random SIGTRAPs.  This leaves out real async traps.  We'd\n \t     have to peek into the (target-specific) siginfo to\n \t     distinguish those.  */\n-\t  && thread->last_status.value.sig != GDB_SIGNAL_TRAP))\n+\t  && thread->last_status.sig () != GDB_SIGNAL_TRAP))\n     thread->status_pending_p = 1;\n }\n \n@@ -3412,9 +3409,9 @@ handle_status (char *own_buf)\n \n       /* Prefer the last thread that reported an event to GDB (even if\n \t that was a GDB_SIGNAL_TRAP).  */\n-      if (cs.last_status.kind != TARGET_WAITKIND_IGNORE\n-\t  && cs.last_status.kind != TARGET_WAITKIND_EXITED\n-\t  && cs.last_status.kind != TARGET_WAITKIND_SIGNALLED)\n+      if (cs.last_status.kind () != TARGET_WAITKIND_IGNORE\n+\t  && cs.last_status.kind () != TARGET_WAITKIND_EXITED\n+\t  && cs.last_status.kind () != TARGET_WAITKIND_SIGNALLED)\n \tthread = find_thread_ptid (cs.last_ptid);\n \n       /* If the last event thread is not found for some reason, look\n@@ -3443,7 +3440,7 @@ handle_status (char *own_buf)\n \t  cs.general_thread = thread->id;\n \t  set_desired_thread ();\n \n-\t  gdb_assert (tp->last_status.kind != TARGET_WAITKIND_IGNORE);\n+\t  gdb_assert (tp->last_status.kind () != TARGET_WAITKIND_IGNORE);\n \t  prepare_resume_reply (own_buf, tp->id, &tp->last_status);\n \t}\n       else\n@@ -3989,8 +3986,7 @@ captured_main (int argc, char *argv[])\n     }\n   else\n     {\n-      cs.last_status.kind = TARGET_WAITKIND_EXITED;\n-      cs.last_status.value.integer = 0;\n+      cs.last_status.set_exited (0);\n       cs.last_ptid = minus_one_ptid;\n     }\n \n@@ -4002,8 +3998,8 @@ captured_main (int argc, char *argv[])\n   if (current_thread != nullptr)\n     current_process ()->dlls_changed = false;\n \n-  if (cs.last_status.kind == TARGET_WAITKIND_EXITED\n-      || cs.last_status.kind == TARGET_WAITKIND_SIGNALLED)\n+  if (cs.last_status.kind () == TARGET_WAITKIND_EXITED\n+      || cs.last_status.kind () == TARGET_WAITKIND_SIGNALLED)\n     was_running = 0;\n   else\n     was_running = 1;\n@@ -4456,8 +4452,7 @@ process_serial_event (void)\n \t running.  The traditional protocol will exit instead.  */\n       if (extended_protocol)\n \t{\n-\t  cs.last_status.kind = TARGET_WAITKIND_EXITED;\n-\t  cs.last_status.value.sig = GDB_SIGNAL_KILL;\n+\t  cs.last_status.set_exited (GDB_SIGNAL_KILL);\n \t  return 0;\n \t}\n       else\n@@ -4497,7 +4492,7 @@ process_serial_event (void)\n \t    {\n \t      target_create_inferior (program_path.get (), program_args);\n \n-\t      if (cs.last_status.kind == TARGET_WAITKIND_STOPPED)\n+\t      if (cs.last_status.kind () == TARGET_WAITKIND_STOPPED)\n \t\t{\n \t\t  /* Stopped at the first instruction of the target\n \t\t     process.  */\n@@ -4511,8 +4506,7 @@ process_serial_event (void)\n \t    }\n \t  else\n \t    {\n-\t      cs.last_status.kind = TARGET_WAITKIND_EXITED;\n-\t      cs.last_status.value.sig = GDB_SIGNAL_KILL;\n+\t      cs.last_status.set_exited (GDB_SIGNAL_KILL);\n \t    }\n \t  return 0;\n \t}\n@@ -4595,24 +4589,24 @@ handle_target_event (int err, gdb_client_data client_data)\n   cs.last_ptid = mywait (minus_one_ptid, &cs.last_status,\n \t\t      TARGET_WNOHANG, 1);\n \n-  if (cs.last_status.kind == TARGET_WAITKIND_NO_RESUMED)\n+  if (cs.last_status.kind () == TARGET_WAITKIND_NO_RESUMED)\n     {\n       if (gdb_connected () && report_no_resumed)\n \tpush_stop_notification (null_ptid, &cs.last_status);\n     }\n-  else if (cs.last_status.kind != TARGET_WAITKIND_IGNORE)\n+  else if (cs.last_status.kind () != TARGET_WAITKIND_IGNORE)\n     {\n       int pid = cs.last_ptid.pid ();\n       struct process_info *process = find_process_pid (pid);\n       int forward_event = !gdb_connected () || process->gdb_detached;\n \n-      if (cs.last_status.kind == TARGET_WAITKIND_EXITED\n-\t  || cs.last_status.kind == TARGET_WAITKIND_SIGNALLED)\n+      if (cs.last_status.kind () == TARGET_WAITKIND_EXITED\n+\t  || cs.last_status.kind () == TARGET_WAITKIND_SIGNALLED)\n \t{\n \t  mark_breakpoints_out (process);\n \t  target_mourn_inferior (cs.last_ptid);\n \t}\n-      else if (cs.last_status.kind == TARGET_WAITKIND_THREAD_EXITED)\n+      else if (cs.last_status.kind () == TARGET_WAITKIND_THREAD_EXITED)\n \t;\n       else\n \t{\n@@ -4631,9 +4625,9 @@ handle_target_event (int err, gdb_client_data client_data)\n \t      exit (0);\n \t    }\n \n-\t  if (cs.last_status.kind == TARGET_WAITKIND_EXITED\n-\t      || cs.last_status.kind == TARGET_WAITKIND_SIGNALLED\n-\t      || cs.last_status.kind == TARGET_WAITKIND_THREAD_EXITED)\n+\t  if (cs.last_status.kind () == TARGET_WAITKIND_EXITED\n+\t      || cs.last_status.kind () == TARGET_WAITKIND_SIGNALLED\n+\t      || cs.last_status.kind () == TARGET_WAITKIND_THREAD_EXITED)\n \t    ;\n \t  else\n \t    {\n@@ -4645,11 +4639,11 @@ handle_target_event (int err, gdb_client_data client_data)\n \t      if (debug_threads)\n \t\tdebug_printf (\"GDB not connected; forwarding event %d for\"\n \t\t\t      \" [%s]\\n\",\n-\t\t\t      (int) cs.last_status.kind,\n+\t\t\t      (int) cs.last_status.kind (),\n \t\t\t      target_pid_to_str (cs.last_ptid));\n \n-\t      if (cs.last_status.kind == TARGET_WAITKIND_STOPPED)\n-\t\tsignal = cs.last_status.value.sig;\n+\t      if (cs.last_status.kind () == TARGET_WAITKIND_STOPPED)\n+\t\tsignal = cs.last_status.sig ();\n \t      else\n \t\tsignal = GDB_SIGNAL_0;\n \t      target_continue (cs.last_ptid, signal);"
    },
    {
      "sha": "b6a1cb24025d0e3fdd1ca3ba3a6e5934e1e008c5",
      "filename": "gdbserver/target.cc",
      "status": "modified",
      "additions": 7,
      "deletions": 7,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdbserver/target.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdbserver/target.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/target.cc?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -172,8 +172,8 @@ mywait (ptid_t ptid, struct target_waitstatus *ourstatus,\n \n   /* We don't expose _LOADED events to gdbserver core.  See the\n      `dlls_changed' global.  */\n-  if (ourstatus->kind == TARGET_WAITKIND_LOADED)\n-    ourstatus->kind = TARGET_WAITKIND_STOPPED;\n+  if (ourstatus->kind () == TARGET_WAITKIND_LOADED)\n+    ourstatus->set_stopped (GDB_SIGNAL_0);\n \n   /* If GDB is connected through TCP/serial, then GDBserver will most\n      probably be running on its own terminal/console, so it's nice to\n@@ -183,13 +183,13 @@ mywait (ptid_t ptid, struct target_waitstatus *ourstatus,\n      regular GDB output, in that same terminal.  */\n   if (!remote_connection_is_stdio ())\n     {\n-      if (ourstatus->kind == TARGET_WAITKIND_EXITED)\n+      if (ourstatus->kind () == TARGET_WAITKIND_EXITED)\n \tfprintf (stderr,\n-\t\t \"\\nChild exited with status %d\\n\", ourstatus->value.integer);\n-      else if (ourstatus->kind == TARGET_WAITKIND_SIGNALLED)\n+\t\t \"\\nChild exited with status %d\\n\", ourstatus->exit_status ());\n+      else if (ourstatus->kind () == TARGET_WAITKIND_SIGNALLED)\n \tfprintf (stderr, \"\\nChild terminated with signal = 0x%x (%s)\\n\",\n-\t\t gdb_signal_to_host (ourstatus->value.sig),\n-\t\t gdb_signal_to_name (ourstatus->value.sig));\n+\t\t gdb_signal_to_host (ourstatus->sig ()),\n+\t\t gdb_signal_to_name (ourstatus->sig ()));\n     }\n \n   if (connected_wait)"
    },
    {
      "sha": "cc981d3988e7c77b835dd223adbf306f542469ff",
      "filename": "gdbserver/win32-low.cc",
      "status": "modified",
      "additions": 16,
      "deletions": 24,
      "changes": 40,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/183be222907a6f419bd71f70ee650989026f0188/gdbserver/win32-low.cc",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/183be222907a6f419bd71f70ee650989026f0188/gdbserver/win32-low.cc",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdbserver/win32-low.cc?ref=183be222907a6f419bd71f70ee650989026f0188",
      "patch": "@@ -374,7 +374,7 @@ do_initial_child_stuff (HANDLE proch, DWORD pid, int attached)\n   if (the_low_target.initial_stuff != NULL)\n     (*the_low_target.initial_stuff) ();\n \n-  cached_status.kind = TARGET_WAITKIND_IGNORE;\n+  cached_status.set_ignore ();\n \n   /* Flush all currently pending debug events (thread and dll list) up\n      to the initial breakpoint.  */\n@@ -385,7 +385,7 @@ do_initial_child_stuff (HANDLE proch, DWORD pid, int attached)\n       the_target->wait (minus_one_ptid, &status, 0);\n \n       /* Note win32_wait doesn't return thread events.  */\n-      if (status.kind != TARGET_WAITKIND_LOADED)\n+      if (status.kind () != TARGET_WAITKIND_LOADED)\n \t{\n \t  cached_status = status;\n \t  break;\n@@ -1081,7 +1081,7 @@ get_child_debug_event (DWORD *continue_status,\n   ptid_t ptid;\n \n   last_sig = GDB_SIGNAL_0;\n-  ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+  ourstatus->set_spurious ();\n   *continue_status = DBG_CONTINUE;\n \n   /* Check if GDB sent us an interrupt request.  */\n@@ -1119,8 +1119,7 @@ get_child_debug_event (DWORD *continue_status,\n \t       load the application, e.g., if the main executable\n \t       tries to pull in a non-existing export from a\n \t       DLL.  */\n-\t    ourstatus->kind = TARGET_WAITKIND_EXITED;\n-\t    ourstatus->value.integer = 1;\n+\t    ourstatus->set_exited (1);\n \t    return 1;\n \t  }\n \n@@ -1192,15 +1191,9 @@ get_child_debug_event (DWORD *continue_status,\n \tint exit_signal\n \t  = WIFSIGNALED (exit_status) ? WTERMSIG (exit_status) : -1;\n \tif (exit_signal == -1)\n-\t  {\n-\t    ourstatus->kind = TARGET_WAITKIND_EXITED;\n-\t    ourstatus->value.integer = exit_status;\n-\t  }\n+\t  ourstatus->set_exited (exit_status);\n \telse\n-\t  {\n-\t    ourstatus->kind = TARGET_WAITKIND_SIGNALLED;\n-\t    ourstatus->value.sig = gdb_signal_from_host (exit_signal);\n-\t  }\n+\t  ourstatus->set_signalled (gdb_signal_from_host (exit_signal));\n       }\n       child_continue (DBG_CONTINUE, desired_stop_thread_id);\n       break;\n@@ -1215,8 +1208,7 @@ get_child_debug_event (DWORD *continue_status,\n \tbreak;\n       dll_loaded_event ();\n \n-      ourstatus->kind = TARGET_WAITKIND_LOADED;\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n+      ourstatus->set_loaded ();\n       break;\n \n     case UNLOAD_DLL_DEBUG_EVENT:\n@@ -1227,8 +1219,7 @@ get_child_debug_event (DWORD *continue_status,\n       if (! child_initialization_done)\n \tbreak;\n       handle_unload_dll ();\n-      ourstatus->kind = TARGET_WAITKIND_LOADED;\n-      ourstatus->value.sig = GDB_SIGNAL_TRAP;\n+      ourstatus->set_loaded ();\n       break;\n \n     case EXCEPTION_DEBUG_EVENT:\n@@ -1270,7 +1261,7 @@ get_child_debug_event (DWORD *continue_status,\n \t\tptid.lwp (), desired_stop_thread_id));\n       maybe_adjust_pc ();\n       pending_stops.push_back ({(DWORD) ptid.lwp (), *ourstatus, current_event});\n-      ourstatus->kind = TARGET_WAITKIND_SPURIOUS;\n+      ourstatus->set_spurious ();\n     }\n   else\n     current_thread = find_thread_ptid (ptid);\n@@ -1285,14 +1276,14 @@ ptid_t\n win32_process_target::wait (ptid_t ptid, target_waitstatus *ourstatus,\n \t\t\t    target_wait_flags options)\n {\n-  if (cached_status.kind != TARGET_WAITKIND_IGNORE)\n+  if (cached_status.kind () != TARGET_WAITKIND_IGNORE)\n     {\n       /* The core always does a wait after creating the inferior, and\n \t do_initial_child_stuff already ran the inferior to the\n \t initial breakpoint (or an exit, if creating the process\n \t fails).  Report it now.  */\n       *ourstatus = cached_status;\n-      cached_status.kind = TARGET_WAITKIND_IGNORE;\n+      cached_status.set_ignore ();\n       return debug_event_ptid (&current_event);\n     }\n \n@@ -1302,24 +1293,25 @@ win32_process_target::wait (ptid_t ptid, target_waitstatus *ourstatus,\n       if (!get_child_debug_event (&continue_status, ourstatus))\n \tcontinue;\n \n-      switch (ourstatus->kind)\n+      switch (ourstatus->kind ())\n \t{\n \tcase TARGET_WAITKIND_EXITED:\n \t  OUTMSG2 ((\"Child exited with retcode = %x\\n\",\n-\t\t    ourstatus->value.integer));\n+\t\t    ourstatus->exit_status ()));\n \t  win32_clear_inferiors ();\n \t  return ptid_t (current_event.dwProcessId);\n \tcase TARGET_WAITKIND_STOPPED:\n \tcase TARGET_WAITKIND_SIGNALLED:\n \tcase TARGET_WAITKIND_LOADED:\n \t  {\n \t    OUTMSG2 ((\"Child Stopped with signal = %d \\n\",\n-\t\t      ourstatus->value.sig));\n+\t\t      ourstatus->sig ()));\n \t    maybe_adjust_pc ();\n \t    return debug_event_ptid (&current_event);\n \t  }\n \tdefault:\n-\t  OUTMSG ((\"Ignoring unknown internal event, %d\\n\", ourstatus->kind));\n+\t  OUTMSG ((\"Ignoring unknown internal event, %d\\n\",\n+\t\t  ourstatus->kind ()));\n \t  /* fall-through */\n \tcase TARGET_WAITKIND_SPURIOUS:\n \t  /* do nothing, just continue */"
    }
  ]
}