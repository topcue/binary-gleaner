{
  "sha": "04bdff6a76b863e61ee46375dd7cdc9adfb75540",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MDRiZGZmNmE3NmI4NjNlNjFlZTQ2Mzc1ZGQ3Y2RjOWFkZmI3NTU0MA==",
  "commit": {
    "author": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2018-08-09T13:23:00Z"
    },
    "committer": {
      "name": "Alan Modra",
      "email": "amodra@gmail.com",
      "date": "2019-05-24T00:58:07Z"
    },
    "message": "PowerPC notoc linkage stubs\n\nUse pcrel addressing instructions in linkage stubs.\n\nbfd/\n\t* elf64-ppc.c: Comment on powerxx _notoc stub variants.\n\t(LI_R11_0, LIS_R11, ORI_R11_R11_0, SLDI_R11_R11_34): Define.\n\t(PADDI_R12_PC, PLD_R12_PC, D34, HA34): Define.\n\t(struct ppc_link_hash_table): Add powerxx_stubs.\n\t(ppc64_elf_check_relocs): Set powerxx_stubs.\n\t(build_powerxx_offset, size_powerxx_offset),\n\t(num_relocs_for_powerxx_offset),\n\t(emit_relocs_for_powerxx_offset): New functions.\n\t(plt_stub_size): Size powerxx stubs.\n\t(ppc_build_one_stub): Emit powerxx stubs.\n\t(ppc_size_one_stub): Size powerxx stubs.  Omit .eh_frame for\n\tpowerxx stubs.\nld/\n\t* testsuite/ld-powerpc/notoc2.d,\n\t* testsuite/ld-powerpc/notoc2.s: New test.\n\t* testsuite/ld-powerpc/powerpc.exp: Run it.",
    "tree": {
      "sha": "2eca194aaa66a6a9b01295e073bfbb0b4a55a9e7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2eca194aaa66a6a9b01295e073bfbb0b4a55a9e7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/04bdff6a76b863e61ee46375dd7cdc9adfb75540",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/04bdff6a76b863e61ee46375dd7cdc9adfb75540",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/04bdff6a76b863e61ee46375dd7cdc9adfb75540",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/04bdff6a76b863e61ee46375dd7cdc9adfb75540/comments",
  "author": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "amodra",
    "id": 6006325,
    "node_id": "MDQ6VXNlcjYwMDYzMjU=",
    "avatar_url": "https://avatars.githubusercontent.com/u/6006325?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/amodra",
    "html_url": "https://github.com/amodra",
    "followers_url": "https://api.github.com/users/amodra/followers",
    "following_url": "https://api.github.com/users/amodra/following{/other_user}",
    "gists_url": "https://api.github.com/users/amodra/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/amodra/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/amodra/subscriptions",
    "organizations_url": "https://api.github.com/users/amodra/orgs",
    "repos_url": "https://api.github.com/users/amodra/repos",
    "events_url": "https://api.github.com/users/amodra/events{/privacy}",
    "received_events_url": "https://api.github.com/users/amodra/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "4a421c53cf609d68fe956c2e7270d34c0ab8500f",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/4a421c53cf609d68fe956c2e7270d34c0ab8500f",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/4a421c53cf609d68fe956c2e7270d34c0ab8500f"
    }
  ],
  "stats": {
    "total": 389,
    "additions": 346,
    "deletions": 43
  },
  "files": [
    {
      "sha": "a21805f705783cc3fb869857e3d8ac64d67084a7",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 15,
      "deletions": 0,
      "changes": 15,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04bdff6a76b863e61ee46375dd7cdc9adfb75540/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04bdff6a76b863e61ee46375dd7cdc9adfb75540/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=04bdff6a76b863e61ee46375dd7cdc9adfb75540",
      "patch": "@@ -1,3 +1,18 @@\n+2019-05-24  Alan Modra  <amodra@gmail.com>\n+\n+\t* elf64-ppc.c: Comment on powerxx _notoc stub variants.\n+\t(LI_R11_0, LIS_R11, ORI_R11_R11_0, SLDI_R11_R11_34): Define.\n+\t(PADDI_R12_PC, PLD_R12_PC, D34, HA34): Define.\n+\t(struct ppc_link_hash_table): Add powerxx_stubs.\n+\t(ppc64_elf_check_relocs): Set powerxx_stubs.\n+\t(build_powerxx_offset, size_powerxx_offset),\n+\t(num_relocs_for_powerxx_offset),\n+\t(emit_relocs_for_powerxx_offset): New functions.\n+\t(plt_stub_size): Size powerxx stubs.\n+\t(ppc_build_one_stub): Emit powerxx stubs.\n+\t(ppc_size_one_stub): Size powerxx stubs.  Omit .eh_frame for\n+\tpowerxx stubs.\n+\n 2019-05-24  Alan Modra  <amodra@gmail.com>\n \n \t* elf64-ppc.c (ppc64_elf_check_relocs): Set has_gotrel for"
    },
    {
      "sha": "f795e3f90b67298de9730cceda4d994bfddae3e5",
      "filename": "bfd/elf64-ppc.c",
      "status": "modified",
      "additions": 281,
      "deletions": 43,
      "changes": 324,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04bdff6a76b863e61ee46375dd7cdc9adfb75540/bfd/elf64-ppc.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04bdff6a76b863e61ee46375dd7cdc9adfb75540/bfd/elf64-ppc.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf64-ppc.c?ref=04bdff6a76b863e61ee46375dd7cdc9adfb75540",
      "patch": "@@ -187,18 +187,24 @@ static bfd_vma opd_entry_value\n #define LD_R2_0R12\t0xe84c0000\t/* ld\t %r2,0(%r12)\t */\n #define ADD_R2_R2_R12\t0x7c426214\t/* add\t %r2,%r2,%r12\t */\n \n+#define LI_R11_0\t0x39600000\t/* li    %r11,0\t\t*/\n #define LIS_R2\t\t0x3c400000\t/* lis %r2,xxx@ha\t  */\n+#define LIS_R11\t\t0x3d600000\t/* lis %r11,xxx@ha\t  */\n #define LIS_R12\t\t0x3d800000\t/* lis %r12,xxx@ha\t  */\n #define ADDIS_R2_R12\t0x3c4c0000\t/* addis %r2,%r12,xxx@ha  */\n #define ADDIS_R12_R2\t0x3d820000\t/* addis %r12,%r2,xxx@ha  */\n #define ADDIS_R12_R11\t0x3d8b0000\t/* addis %r12,%r11,xxx@ha */\n #define ADDIS_R12_R12\t0x3d8c0000\t/* addis %r12,%r12,xxx@ha */\n #define ORIS_R12_R12_0\t0x658c0000\t/* oris  %r12,%r12,xxx@hi */\n+#define ORI_R11_R11_0\t0x616b0000\t/* ori   %r11,%r11,xxx@l  */\n #define ORI_R12_R12_0\t0x618c0000\t/* ori   %r12,%r12,xxx@l  */\n #define LD_R12_0R12\t0xe98c0000\t/* ld\t %r12,xxx@l(%r12) */\n+#define SLDI_R11_R11_34\t0x796b1746\t/* sldi  %r11,%r11,34     */\n #define SLDI_R12_R12_32\t0x799c07c6\t/* sldi  %r12,%r12,32     */\n #define LDX_R12_R11_R12 0x7d8b602a\t/* ldx   %r12,%r11,%r12   */\n #define ADD_R12_R11_R12 0x7d8b6214\t/* add   %r12,%r11,%r12   */\n+#define PADDI_R12_PC\t0x0610000039800000ULL\n+#define PLD_R12_PC\t0x04100000e5800000ULL\n #define PNOP\t\t0x0700000000000000ULL\n \n /* __glink_PLTresolve stub instructions.  We enter with the index in R0.  */\n@@ -2841,8 +2847,34 @@ must_be_dyn_reloc (struct bfd_link_info *info,\n    .\tmtctr\t%r12\n    .\tbctr\n \n+   There are also ELFv1 powerxx variants of these stubs.\n+   ppc_stub_long_branch_notoc:\n+   .\tpaddi\t%r12,dest@pcrel\n+   .\tb\tdest\n+   ppc_stub_plt_branch_notoc:\n+   .\tlis\t%r11,(dest-1f)@highesta34\n+   .\tori\t%r11,%r11,(dest-1f)@highera34\n+   .\tsldi\t%r11,%r11,34\n+   . 1: paddi\t%r12,dest@pcrel\n+   .\tadd\t%r12,%r11,%r12\n+   .\tmtctr\t%r12\n+   .\tbctr\n+   ppc_stub_plt_call_notoc:\n+   .\tlis\t%r11,(xxx-1f)@highesta34\n+   .\tori\t%r11,%r11,(xxx-1f)@highera34\n+   .\tsldi\t%r11,%r11,34\n+   . 1: paddi\t%r12,xxx@pcrel\n+   .\tldx\t%r12,%r11,%r12\n+   .\tmtctr\t%r12\n+   .\tbctr\n+\n    In cases where the high instructions would add zero, they are\n    omitted and following instructions modified in some cases.\n+   For example, a powerxx ppc_stub_plt_call_notoc might simplify down\n+   to\n+   .\tpld\t%r12,xxx@pcrel\n+   .\tmtctr\t%r12\n+   .\tbctr\n \n    For a given stub group (a set of sections all using the same toc\n    pointer value) there will be just one stub type used for any\n@@ -3132,6 +3164,9 @@ struct ppc_link_hash_table\n   /* Whether calls are made via the PLT from NOTOC functions.  */\n   unsigned int notoc_plt:1;\n \n+  /* Whether to use powerxx instructions in linkage stubs.  */\n+  unsigned int powerxx_stubs:1;\n+\n   /* Incremented every time we size stubs.  */\n   unsigned int stub_iteration;\n \n@@ -4476,6 +4511,13 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n       r_type = ELF64_R_TYPE (rel->r_info);\n       switch (r_type)\n \t{\n+\tcase R_PPC64_D34:\n+\tcase R_PPC64_D34_LO:\n+\tcase R_PPC64_D34_HI30:\n+\tcase R_PPC64_D34_HA30:\n+\tcase R_PPC64_D28:\n+\t  htab->powerxx_stubs = 1;\n+\t  /* Fall through.  */\n \tdefault:\n \t  /* Somewhat foolishly, because the ABIs don't specifically\n \t     allow it, ppc64 gas and ld support GOT and PLT relocs\n@@ -4485,9 +4527,13 @@ ppc64_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,\n \t     used to specify the pcrel offset.  */\n \t  sym_addend = rel->r_addend;\n \t  break;\n+\n+\tcase R_PPC64_PCREL34:\n \tcase R_PPC64_GOT_PCREL34:\n \tcase R_PPC64_PLT_PCREL34:\n \tcase R_PPC64_PLT_PCREL34_NOTOC:\n+\tcase R_PPC64_PCREL28:\n+\t  htab->powerxx_stubs = 1;\n \t  sym_addend = 0;\n \t  break;\n \t}\n@@ -9427,6 +9473,9 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)\n #define PPC_LO(v) ((v) & 0xffff)\n #define PPC_HI(v) (((v) >> 16) & 0xffff)\n #define PPC_HA(v) PPC_HI ((v) + 0x8000)\n+#define D34(v) \\\n+  ((((v) & 0x3ffff0000ULL) << 16) | (v & 0xffff))\n+#define HA34(v) ((v + (1ULL << 33)) >> 34)\n \n /* Called via elf_link_hash_traverse from ppc64_elf_size_dynamic_sections\n    to set up space for global entry stubs.  These are put in glink,\n@@ -10208,6 +10257,146 @@ emit_relocs_for_offset (struct bfd_link_info *info, Elf_Internal_Rela *r,\n   return r;\n }\n \n+static bfd_byte *\n+build_powerxx_offset (bfd *abfd, bfd_byte *p, bfd_vma off, int odd,\n+\t\t      bfd_boolean load)\n+{\n+  uint64_t insn;\n+  if (off - odd + (1ULL << 33) < 1ULL << 34)\n+    {\n+      off -= odd;\n+      if (odd)\n+\t{\n+\t  bfd_put_32 (abfd, NOP, p);\n+\t  p += 4;\n+\t}\n+      if (load)\n+\tinsn = PLD_R12_PC;\n+      else\n+\tinsn = PADDI_R12_PC;\n+      insn |= D34 (off);\n+      bfd_put_32 (abfd, insn >> 32, p);\n+      p += 4;\n+      bfd_put_32 (abfd, insn, p);\n+    }\n+  /* The minimum value for paddi is -0x200000000.  The minimum value\n+     for li is -0x8000, which when shifted by 34 and added gives a\n+     minimum value of -0x2000200000000.  The maximum value is\n+     0x1ffffffff+0x7fff<<34 which is 0x2000200000000-1.  */\n+  else if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n+    {\n+      off -= 8 - odd;\n+      bfd_put_32 (abfd, LI_R11_0 | (HA34 (off) & 0xffff), p);\n+      p += 4;\n+      if (!odd)\n+\t{\n+\t  bfd_put_32 (abfd, SLDI_R11_R11_34, p);\n+\t  p += 4;\n+\t}\n+      insn = PADDI_R12_PC | D34 (off);\n+      bfd_put_32 (abfd, insn >> 32, p);\n+      p += 4;\n+      bfd_put_32 (abfd, insn, p);\n+      p += 4;\n+      if (odd)\n+\t{\n+\t  bfd_put_32 (abfd, SLDI_R11_R11_34, p);\n+\t  p += 4;\n+\t}\n+      if (load)\n+\tbfd_put_32 (abfd, LDX_R12_R11_R12, p);\n+      else\n+\tbfd_put_32 (abfd, ADD_R12_R11_R12, p);\n+    }\n+  else\n+    {\n+      off -= odd + 8;\n+      bfd_put_32 (abfd, LIS_R11 | ((HA34 (off) >> 16) & 0x3fff), p);\n+      p += 4;\n+      bfd_put_32 (abfd, ORI_R11_R11_0 | (HA34 (off) & 0xffff), p);\n+      p += 4;\n+      if (odd)\n+\t{\n+\t  bfd_put_32 (abfd, SLDI_R11_R11_34, p);\n+\t  p += 4;\n+\t}\n+      insn = PADDI_R12_PC | D34 (off);\n+      bfd_put_32 (abfd, insn >> 32, p);\n+      p += 4;\n+      bfd_put_32 (abfd, insn, p);\n+      p += 4;\n+      if (!odd)\n+\t{\n+\t  bfd_put_32 (abfd, SLDI_R11_R11_34, p);\n+\t  p += 4;\n+\t}\n+      if (load)\n+\tbfd_put_32 (abfd, LDX_R12_R11_R12, p);\n+      else\n+\tbfd_put_32 (abfd, ADD_R12_R11_R12, p);\n+    }\n+  p += 4;\n+  return p;\n+}\n+\n+static unsigned int\n+size_powerxx_offset (bfd_vma off, int odd)\n+{\n+  if (off - odd + (1ULL << 33) < 1ULL << 34)\n+    return odd + 8;\n+  else if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n+    return 20;\n+  else\n+    return 24;\n+}\n+\n+static unsigned int\n+num_relocs_for_powerxx_offset (bfd_vma off, int odd)\n+{\n+  if (off - odd + (1ULL << 33) < 1ULL << 34)\n+    return 1;\n+  else if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n+    return 2;\n+  else\n+    return 3;\n+}\n+\n+static Elf_Internal_Rela *\n+emit_relocs_for_powerxx_offset (struct bfd_link_info *info,\n+\t\t\t\tElf_Internal_Rela *r, bfd_vma roff,\n+\t\t\t\tbfd_vma targ, bfd_vma off, int odd)\n+{\n+  if (off - odd + (1ULL << 33) < 1ULL << 34)\n+    roff += odd;\n+  else if (off - (8 - odd) + (0x20002ULL << 32) < 0x40004ULL << 32)\n+    {\n+      int d_offset = bfd_big_endian (info->output_bfd) ? 2 : 0;\n+      r->r_offset = roff + d_offset;\n+      r->r_addend = targ + 8 - odd - d_offset;\n+      r->r_info = ELF64_R_INFO (0, R_PPC64_REL16_HIGHERA34);\n+      ++r;\n+      roff += 8 - odd;\n+    }\n+  else\n+    {\n+      int d_offset = bfd_big_endian (info->output_bfd) ? 2 : 0;\n+      r->r_offset = roff + d_offset;\n+      r->r_addend = targ + 8 + odd - d_offset;\n+      r->r_info = ELF64_R_INFO (0, R_PPC64_REL16_HIGHESTA34);\n+      ++r;\n+      roff += 4;\n+      r->r_offset = roff + d_offset;\n+      r->r_addend = targ + 4 + odd - d_offset;\n+      r->r_info = ELF64_R_INFO (0, R_PPC64_REL16_HIGHERA34);\n+      ++r;\n+      roff += 4 + odd;\n+    }\n+  r->r_offset = roff;\n+  r->r_addend = targ;\n+  r->r_info = ELF64_R_INFO (0, R_PPC64_PCREL34);\n+  return r;\n+}\n+\n /* Emit .eh_frame opcode to advance pc by DELTA.  */\n \n static bfd_byte *\n@@ -10285,7 +10474,17 @@ plt_stub_size (struct ppc_link_hash_table *htab,\n \n   if (stub_entry->stub_type >= ppc_stub_plt_call_notoc)\n     {\n-      size = 8 + size_offset (off - 8);\n+      if (htab->powerxx_stubs)\n+\t{\n+\t  bfd_vma start = (stub_entry->stub_offset\n+\t\t\t   + stub_entry->group->stub_sec->output_offset\n+\t\t\t   + stub_entry->group->stub_sec->output_section->vma);\n+\t  if (stub_entry->stub_type > ppc_stub_plt_call_notoc)\n+\t    start += 4;\n+\t  size = 8 + size_powerxx_offset (off, start & 4);\n+\t}\n+      else\n+\tsize = 8 + size_offset (off - 8);\n       if (stub_entry->stub_type > ppc_stub_plt_call_notoc)\n \tsize += 4;\n       return size;\n@@ -10738,6 +10937,7 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n   Elf_Internal_Rela *r;\n   asection *plt;\n   int num_rel;\n+  int odd;\n \n   /* Massage our args to the form they really have.  */\n   stub_entry = (struct ppc_stub_hash_entry *) gen_entry;\n@@ -11016,18 +11216,28 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \ttarg = (stub_entry->target_value\n \t\t+ stub_entry->target_section->output_offset\n \t\t+ stub_entry->target_section->output_section->vma);\n+      odd = off & 4;\n       off = targ - off;\n \n       relp = p;\n       num_rel = 0;\n-      /* The notoc stubs calculate their target (either a PLT entry or\n-\t the global entry point of a function) relative to the PC\n-\t returned by the \"bcl\" two instructions past the start of the\n-\t sequence emitted by build_offset.  The offset is therefore 8\n-\t less than calculated from the start of the sequence.  */\n-      off -= 8;\n-      p = build_offset (htab->params->stub_bfd, p, off,\n-\t\t\tstub_entry->stub_type >= ppc_stub_plt_call_notoc);\n+      if (htab->powerxx_stubs)\n+\t{\n+\t  bfd_boolean load = stub_entry->stub_type >= ppc_stub_plt_call_notoc;\n+\t  p = build_powerxx_offset (htab->params->stub_bfd, p, off, odd, load);\n+\t}\n+      else\n+\t{\n+\t  /* The notoc stubs calculate their target (either a PLT entry or\n+\t     the global entry point of a function) relative to the PC\n+\t     returned by the \"bcl\" two instructions past the start of the\n+\t     sequence emitted by build_offset.  The offset is therefore 8\n+\t     less than calculated from the start of the sequence.  */\n+\t  off -= 8;\n+\t  p = build_offset (htab->params->stub_bfd, p, off,\n+\t\t\t    stub_entry->stub_type >= ppc_stub_plt_call_notoc);\n+\t}\n+\n       if (stub_entry->stub_type <= ppc_stub_long_branch_both)\n \t{\n \t  bfd_vma from;\n@@ -11049,13 +11259,21 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       if (info->emitrelocations)\n \t{\n-\t  bfd_vma roff;\n-\t  num_rel += num_relocs_for_offset (off);\n+\t  bfd_vma roff = relp - stub_entry->group->stub_sec->contents;\n+\t  if (htab->powerxx_stubs)\n+\t    num_rel += num_relocs_for_powerxx_offset (off, odd);\n+\t  else\n+\t    {\n+\t      num_rel += num_relocs_for_offset (off);\n+\t      roff += 16;\n+\t    }\n \t  r = get_relocs (stub_entry->group->stub_sec, num_rel);\n \t  if (r == NULL)\n \t    return FALSE;\n-\t  roff = relp + 16 - stub_entry->group->stub_sec->contents;\n-\t  r = emit_relocs_for_offset (info, r, roff, targ, off);\n+\t  if (htab->powerxx_stubs)\n+\t    r = emit_relocs_for_powerxx_offset (info, r, roff, targ, off, odd);\n+\t  else\n+\t    r = emit_relocs_for_offset (info, r, roff, targ, off);\n \t  if (stub_entry->stub_type == ppc_stub_long_branch_notoc\n \t      || stub_entry->stub_type == ppc_stub_long_branch_both)\n \t    {\n@@ -11070,8 +11288,9 @@ ppc_build_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t    }\n \t}\n \n-      if (htab->glink_eh_frame != NULL\n-\t&& htab->glink_eh_frame->size != 0)\n+      if (!htab->powerxx_stubs\n+\t  && htab->glink_eh_frame != NULL\n+\t  && htab->glink_eh_frame->size != 0)\n \t{\n \t  bfd_byte *base, *eh;\n \t  unsigned int lr_used, delta;\n@@ -11240,7 +11459,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n   struct ppc_link_hash_table *htab;\n   asection *plt;\n   bfd_vma targ, off, r2off;\n-  unsigned int size, extra, lr_used, delta;\n+  unsigned int size, extra, lr_used, delta, odd;\n \n   /* Massage our args to the form they really have.  */\n   stub_entry = (struct ppc_stub_hash_entry *) gen_entry;\n@@ -11393,34 +11612,45 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n       targ = (stub_entry->target_value\n \t      + stub_entry->target_section->output_offset\n \t      + stub_entry->target_section->output_section->vma);\n+      odd = off & 4;\n       off = targ - off;\n \n       if (info->emitrelocations)\n \t{\n-\t  stub_entry->group->stub_sec->reloc_count\n-\t    += num_relocs_for_offset (off);\n+\t  unsigned int num_rel;\n+\t  if (htab->powerxx_stubs)\n+\t    num_rel = num_relocs_for_powerxx_offset (off, odd);\n+\t  else\n+\t    num_rel = num_relocs_for_offset (off - 8);\n+\t  stub_entry->group->stub_sec->reloc_count += num_rel;\n \t  stub_entry->group->stub_sec->flags |= SEC_RELOC;\n \t}\n \n-      extra = size_offset (off - 8);\n+      if (htab->powerxx_stubs)\n+\textra = size_powerxx_offset (off, odd);\n+      else\n+\textra = size_offset (off - 8);\n       /* Include branch insn plus those in the offset sequence.  */\n       size += 4 + extra;\n       /* The branch insn is at the end, or \"extra\" bytes along.  So\n \t its offset will be \"extra\" bytes less that that already\n \t calculated.  */\n       off -= extra;\n \n-      /* After the bcl, lr has been modified so we need to emit\n-\t .eh_frame info saying the return address is in r12.  */\n-      lr_used = stub_entry->stub_offset + 8;\n-      if (stub_entry->stub_type == ppc_stub_long_branch_both)\n-\tlr_used += 4;\n-      /* The eh_frame info will consist of a DW_CFA_advance_loc or\n-\t variant, DW_CFA_register, 65, 12, DW_CFA_advance_loc+2,\n-\t DW_CFA_restore_extended 65.  */\n-      delta = lr_used - stub_entry->group->lr_restore;\n-      stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n-      stub_entry->group->lr_restore = lr_used + 8;\n+      if (!htab->powerxx_stubs)\n+\t{\n+\t  /* After the bcl, lr has been modified so we need to emit\n+\t     .eh_frame info saying the return address is in r12.  */\n+\t  lr_used = stub_entry->stub_offset + 8;\n+\t  if (stub_entry->stub_type == ppc_stub_long_branch_both)\n+\t    lr_used += 4;\n+\t  /* The eh_frame info will consist of a DW_CFA_advance_loc or\n+\t     variant, DW_CFA_register, 65, 12, DW_CFA_advance_loc+2,\n+\t     DW_CFA_restore_extended 65.  */\n+\t  delta = lr_used - stub_entry->group->lr_restore;\n+\t  stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n+\t  stub_entry->group->lr_restore = lr_used + 8;\n+\t}\n \n       /* If the branch can't reach, use a plt_branch.  */\n       if (off + (1 << 25) >= (bfd_vma) (1 << 26))\n@@ -11455,6 +11685,7 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \t    plt = htab->pltlocal;\n \t}\n       targ += plt->output_offset + plt->output_section->vma;\n+      odd = off & 4;\n       off = targ - off;\n \n       if (htab->params->plt_stub_align != 0)\n@@ -11468,24 +11699,31 @@ ppc_size_one_stub (struct bfd_hash_entry *gen_entry, void *in_arg)\n \n       if (info->emitrelocations)\n \t{\n-\t  stub_entry->group->stub_sec->reloc_count\n-\t    += num_relocs_for_offset (off - 8);\n+\t  unsigned int num_rel;\n+\t  if (htab->powerxx_stubs)\n+\t    num_rel = num_relocs_for_powerxx_offset (off, odd);\n+\t  else\n+\t    num_rel = num_relocs_for_offset (off - 8);\n+\t  stub_entry->group->stub_sec->reloc_count += num_rel;\n \t  stub_entry->group->stub_sec->flags |= SEC_RELOC;\n \t}\n \n       size = plt_stub_size (htab, stub_entry, off);\n \n-      /* After the bcl, lr has been modified so we need to emit\n-\t .eh_frame info saying the return address is in r12.  */\n-      lr_used = stub_entry->stub_offset + 8;\n-      if (stub_entry->stub_type == ppc_stub_plt_call_both)\n-\tlr_used += 4;\n-      /* The eh_frame info will consist of a DW_CFA_advance_loc or\n-\t variant, DW_CFA_register, 65, 12, DW_CFA_advance_loc+2,\n-\t DW_CFA_restore_extended 65.  */\n-      delta = lr_used - stub_entry->group->lr_restore;\n-      stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n-      stub_entry->group->lr_restore = lr_used + 8;\n+      if (!htab->powerxx_stubs)\n+\t{\n+\t  /* After the bcl, lr has been modified so we need to emit\n+\t     .eh_frame info saying the return address is in r12.  */\n+\t  lr_used = stub_entry->stub_offset + 8;\n+\t  if (stub_entry->stub_type == ppc_stub_plt_call_both)\n+\t    lr_used += 4;\n+\t  /* The eh_frame info will consist of a DW_CFA_advance_loc or\n+\t     variant, DW_CFA_register, 65, 12, DW_CFA_advance_loc+2,\n+\t     DW_CFA_restore_extended 65.  */\n+\t  delta = lr_used - stub_entry->group->lr_restore;\n+\t  stub_entry->group->eh_size += eh_advance_size (delta) + 6;\n+\t  stub_entry->group->lr_restore = lr_used + 8;\n+\t}\n       break;\n \n     case ppc_stub_plt_call:"
    },
    {
      "sha": "dd71da5a73368cdd757dc0f34c06fe44ce4fdf48",
      "filename": "ld/ChangeLog",
      "status": "modified",
      "additions": 6,
      "deletions": 0,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04bdff6a76b863e61ee46375dd7cdc9adfb75540/ld/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04bdff6a76b863e61ee46375dd7cdc9adfb75540/ld/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/ChangeLog?ref=04bdff6a76b863e61ee46375dd7cdc9adfb75540",
      "patch": "@@ -1,3 +1,9 @@\n+2019-05-24  Alan Modra  <amodra@gmail.com>\n+\n+\t* testsuite/ld-powerpc/notoc2.d,\n+\t* testsuite/ld-powerpc/notoc2.s: New test.\n+\t* testsuite/ld-powerpc/powerpc.exp: Run it.\n+\n 2019-05-24  Alan Modra  <amodra@gmail.com>\n \n \t* testsuite/ld-powerpc/pcrelopt.s,"
    },
    {
      "sha": "172835fee4e8684c88e3591c8e2d0d8e53d28c5a",
      "filename": "ld/testsuite/ld-powerpc/notoc2.d",
      "status": "added",
      "additions": 29,
      "deletions": 0,
      "changes": 29,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04bdff6a76b863e61ee46375dd7cdc9adfb75540/ld/testsuite/ld-powerpc/notoc2.d",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04bdff6a76b863e61ee46375dd7cdc9adfb75540/ld/testsuite/ld-powerpc/notoc2.d",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-powerpc/notoc2.d?ref=04bdff6a76b863e61ee46375dd7cdc9adfb75540",
      "patch": "@@ -0,0 +1,29 @@\n+#source: notoc2.s\n+#as: -a64 -mfuture\n+#ld: -shared -z norelro\n+#objdump: -d -Mfuture\n+#target: powerpc64*-*-*\n+\n+.*\n+\n+Disassembly of section \\.text:\n+\n+.* <.*\\.plt_call\\.puts>:\n+.*:\t(04 10 00 01|01 00 10 04) \tpld     r12,66200\n+.*:\t(e5 80 02 98|98 02 80 e5) \n+.*:\t(7d 89 03 a6|a6 03 89 7d) \tmtctr   r12\n+.*:\t(4e 80 04 20|20 04 80 4e) \tbctr\n+#...\n+.*:\t(04 13 ff ff|ff ff 13 04) \tpld     r12,-1\n+.*:\t(e5 80 ff ff|ff ff 80 e5) \n+.*:\t(04 10 00 00|00 00 10 04) \tpld     r12,0\n+.*:\t(e5 80 00 00|00 00 80 e5) \n+.*:\t(06 13 ff ff|ff ff 13 06) \tpla     r12,-1\n+.*:\t(39 80 ff ff|ff ff 80 39) \n+.*:\t(06 10 00 00|00 00 10 06) \tpla     r12,0\n+.*:\t(39 80 00 00|00 00 80 39) \n+.*:\t(06 10 00 00|00 00 10 06) \tpla     r3,92\n+.*:\t(38 60 00 5c|5c 00 60 38) \n+.*:\t(4b ff ff 99|99 ff ff 4b) \tbl      .* <.*\\.plt_call\\.puts>\n+.*:\t(60 00 00 00|00 00 00 60) \tnop\n+#pass"
    },
    {
      "sha": "3a4274c7c0fb69ae7885a514c905b2e3ef198ec3",
      "filename": "ld/testsuite/ld-powerpc/notoc2.s",
      "status": "added",
      "additions": 13,
      "deletions": 0,
      "changes": 13,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04bdff6a76b863e61ee46375dd7cdc9adfb75540/ld/testsuite/ld-powerpc/notoc2.s",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04bdff6a76b863e61ee46375dd7cdc9adfb75540/ld/testsuite/ld-powerpc/notoc2.s",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-powerpc/notoc2.s?ref=04bdff6a76b863e61ee46375dd7cdc9adfb75540",
      "patch": "@@ -0,0 +1,13 @@\n+ .text\n+ .weak puts\n+ pld 12,-1(0),1\n+ pld 12,0(0),1\n+ paddi 12,0,-1,1\n+ paddi 12,0,0,1\n+0:\n+ paddi 3,0,hello-.,1\n+ bl puts@notoc\n+ nop\n+ b 0b\n+ .section .rodata\n+hello:\t.asciz \"Hello!\""
    },
    {
      "sha": "af4d13e5ceaa8bbbea768a9e57b3168bcec9dbd6",
      "filename": "ld/testsuite/ld-powerpc/powerpc.exp",
      "status": "modified",
      "additions": 2,
      "deletions": 0,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/04bdff6a76b863e61ee46375dd7cdc9adfb75540/ld/testsuite/ld-powerpc/powerpc.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/04bdff6a76b863e61ee46375dd7cdc9adfb75540/ld/testsuite/ld-powerpc/powerpc.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/ld/testsuite/ld-powerpc/powerpc.exp?ref=04bdff6a76b863e61ee46375dd7cdc9adfb75540",
      "patch": "@@ -260,6 +260,8 @@ set ppc64elftests {\n     {\"notoc ext\" \"\" \"\" \"-a64\" {ext.s} {} \"\"}\n     {\"notoc\" \"-melf64ppc --no-plt-localentry -T ext.lnk\" \"\" \"-a64\" {notoc.s}\n \t{{objdump -d notoc.d} {readelf {-wf -W} notoc.wf}} \"notoc\"}\n+    {\"notoc2\" \"-melf64ppc -shared\" \"\" \"-a64 -mfuture\" {notoc2.s}\n+\t{{objdump {-d -Mfuture} notoc2.d}} \"notoc2\"}\n     {\"pcrelopt\" \"-melf64ppc --hash-style=gnu\" \"tmpdir/symtocbase.so\"\n \t\"-a64 -mfuture\" {pcrelopt.s}\n \t{{objdump {-d -Mfuture} pcrelopt.d}"
    }
  ]
}