{
  "sha": "8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OGQ2Y2IxMTZmNDdiNWVkYjJhN2MyZmE1NDBmY2I5ZGJjZDNlZmZjMg==",
  "commit": {
    "author": {
      "name": "Jozef Lawrynowicz",
      "email": "jozef.l@mittosystems.com",
      "date": "2020-02-10T20:33:21Z"
    },
    "committer": {
      "name": "Jozef Lawrynowicz",
      "email": "jozef.l@mittosystems.com",
      "date": "2020-02-10T20:35:52Z"
    },
    "message": "MSP430: Enable relaxation of relocs in JMP instructions\n\nThis patch fixes relocation overflows caused by an inability to relax\nunconditional JMP instructions to BR instructions.\n\nbfd/ChangeLog:\n\n2020-02-10  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n\n\t* elf32-msp430.c (msp430_elf_relax_add_two_words): Rename to\n\tmsp430_elf_relax_add_words. Support insertion of either one or two\n\twords.\n\t(msp430_elf_relax_section): Catch opcode of 0x3c00 when relocation\n\tneeds to be grown. Handle insertion of branch instruction to replace\n\tjump.",
    "tree": {
      "sha": "d2a49f50c1a879aad09dee29a966b3970a67ae78",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/d2a49f50c1a879aad09dee29a966b3970a67ae78"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2/comments",
  "author": {
    "login": "jozefl-mitto",
    "id": 36524004,
    "node_id": "MDQ6VXNlcjM2NTI0MDA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jozefl-mitto",
    "html_url": "https://github.com/jozefl-mitto",
    "followers_url": "https://api.github.com/users/jozefl-mitto/followers",
    "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}",
    "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions",
    "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs",
    "repos_url": "https://api.github.com/users/jozefl-mitto/repos",
    "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "jozefl-mitto",
    "id": 36524004,
    "node_id": "MDQ6VXNlcjM2NTI0MDA0",
    "avatar_url": "https://avatars.githubusercontent.com/u/36524004?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/jozefl-mitto",
    "html_url": "https://github.com/jozefl-mitto",
    "followers_url": "https://api.github.com/users/jozefl-mitto/followers",
    "following_url": "https://api.github.com/users/jozefl-mitto/following{/other_user}",
    "gists_url": "https://api.github.com/users/jozefl-mitto/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/jozefl-mitto/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/jozefl-mitto/subscriptions",
    "organizations_url": "https://api.github.com/users/jozefl-mitto/orgs",
    "repos_url": "https://api.github.com/users/jozefl-mitto/repos",
    "events_url": "https://api.github.com/users/jozefl-mitto/events{/privacy}",
    "received_events_url": "https://api.github.com/users/jozefl-mitto/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "d60f54486a99e6b702cccdb16b3429f3524021fd",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/d60f54486a99e6b702cccdb16b3429f3524021fd",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/d60f54486a99e6b702cccdb16b3429f3524021fd"
    }
  ],
  "stats": {
    "total": 105,
    "additions": 75,
    "deletions": 30
  },
  "files": [
    {
      "sha": "7f6be6295ba40e73dce1084bda54e50a8114979e",
      "filename": "bfd/ChangeLog",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2/bfd/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2/bfd/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/ChangeLog?ref=8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2",
      "patch": "@@ -1,3 +1,12 @@\n+2020-02-10  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n+\n+\t* elf32-msp430.c (msp430_elf_relax_add_two_words): Rename to\n+\tmsp430_elf_relax_add_words. Support insertion of either one or two\n+\twords.\n+\t(msp430_elf_relax_section): Catch opcode of 0x3c00 when relocation\n+\tneeds to be grown. Handle insertion of branch instruction to replace\n+\tjump.\n+\n 2020-02-10  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* elf32-msp430.c (msp430_final_link_relocate): Add printf statements for"
    },
    {
      "sha": "67ad9584cebf329f3377303f2a42ebb54dfac5cc",
      "filename": "bfd/elf32-msp430.c",
      "status": "modified",
      "additions": 66,
      "deletions": 30,
      "changes": 96,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2/bfd/elf32-msp430.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2/bfd/elf32-msp430.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/bfd/elf32-msp430.c?ref=8d6cb116f47b5edb2a7c2fa540fcb9dbcd3effc2",
      "patch": "@@ -1768,11 +1768,11 @@ msp430_elf_relax_delete_bytes (bfd * abfd, asection * sec, bfd_vma addr,\n   return TRUE;\n }\n \n-/* Insert two words into a section whilst relaxing.  */\n+/* Insert one or two words into a section whilst relaxing.  */\n \n static bfd_byte *\n-msp430_elf_relax_add_two_words (bfd * abfd, asection * sec, bfd_vma addr,\n-\t\t\t\tint word1, int word2)\n+msp430_elf_relax_add_words (bfd * abfd, asection * sec, bfd_vma addr,\n+\t\t\t    int num_words, int word1, int word2)\n {\n   Elf_Internal_Shdr *symtab_hdr;\n   unsigned int sec_shndx;\n@@ -1787,22 +1787,24 @@ msp430_elf_relax_add_two_words (bfd * abfd, asection * sec, bfd_vma addr,\n   bfd_vma sec_end;\n   asection *p;\n   if (debug_relocs)\n-    printf (\"      adding two words at 0x%lx\\n\",\n+    printf (\"      adding %d words at 0x%lx\\n\", num_words,\n \t    sec->output_section->vma + sec->output_offset + addr);\n \n   contents = elf_section_data (sec)->this_hdr.contents;\n   sec_end = sec->size;\n+  int num_bytes = num_words * 2;\n \n   /* Make space for the new words.  */\n-  contents = bfd_realloc (contents, sec_end + 4);\n-  memmove (contents + addr + 4, contents + addr, sec_end - addr);\n+  contents = bfd_realloc (contents, sec_end + num_bytes);\n+  memmove (contents + addr + num_bytes, contents + addr, sec_end - addr);\n \n   /* Insert the new words.  */\n   bfd_put_16 (abfd, word1, contents + addr);\n-  bfd_put_16 (abfd, word2, contents + addr + 2);\n+  if (num_words == 2)\n+    bfd_put_16 (abfd, word2, contents + addr + 2);\n \n   /* Update the section information.  */\n-  sec->size += 4;\n+  sec->size += num_bytes;\n   elf_section_data (sec)->this_hdr.contents = contents;\n \n   /* Adjust all the relocs.  */\n@@ -1811,12 +1813,12 @@ msp430_elf_relax_add_two_words (bfd * abfd, asection * sec, bfd_vma addr,\n \n   for (; irel < irelend; irel++)\n     if ((irel->r_offset >= addr && irel->r_offset < sec_end))\n-      irel->r_offset += 4;\n+      irel->r_offset += num_bytes;\n \n   /* Adjust the local symbols defined in this section.  */\n   sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);\n   for (p = abfd->sections; p != NULL; p = p->next)\n-    msp430_elf_relax_adjust_locals (abfd, p, addr, -4,\n+    msp430_elf_relax_adjust_locals (abfd, p, addr, -num_bytes,\n \t\t\t\t    sec_shndx, sec_end);\n \n   /* Adjust the global symbols affected by the move.  */\n@@ -1830,8 +1832,8 @@ msp430_elf_relax_add_two_words (bfd * abfd, asection * sec, bfd_vma addr,\n \t  printf (\"      adjusting value of local symbol %s from 0x%lx to \"\n \t\t  \"0x%lx\\n\", bfd_elf_string_from_elf_section\n \t\t  (abfd, symtab_hdr->sh_link, isym->st_name),\n-\t\t  isym->st_value, isym->st_value + 4);\n-\tisym->st_value += 4;\n+\t\t  isym->st_value, isym->st_value + num_bytes);\n+\tisym->st_value += num_bytes;\n       }\n \n   /* Now adjust the global symbols defined in this section.  */\n@@ -1848,7 +1850,7 @@ msp430_elf_relax_add_two_words (bfd * abfd, asection * sec, bfd_vma addr,\n \t  && sym_hash->root.u.def.section == sec\n \t  && sym_hash->root.u.def.value >= addr\n \t  && sym_hash->root.u.def.value < sec_end)\n-\tsym_hash->root.u.def.value += 4;\n+\tsym_hash->root.u.def.value += num_bytes;\n     }\n \n   return contents;\n@@ -2015,8 +2017,12 @@ msp430_elf_relax_section (bfd * abfd, asection * sec,\n       opcode = bfd_get_16 (abfd, contents + irel->r_offset);\n \n       /* Compute the new opcode.  We are going to convert:\n+\t JMP label\n+\t   into:\n+\t BR[A] label\n+\t   or\n \t J<cond> label\n-\t into:\n+\t   into:\n \t J<inv-cond> 1f\n \t BR[A] #label\n \t 1:\t\t\t*/\n@@ -2036,8 +2042,14 @@ msp430_elf_relax_section (bfd * abfd, asection * sec,\n \t     1: br label\n \t     2:\t\t       */\n \t  continue;\n+\tcase 0x3c00:\n+\t  if (uses_msp430x_relocs (abfd))\n+\t    opcode = 0x0080;\t/* JMP -> BRA  */\n+\t  else\n+\t    opcode = 0x4030;\t/* JMP -> BR  */\n+\t  break;\n \tdefault:\n-\t  /* Not a conditional branch instruction.  */\n+\t  /* Unhandled branch instruction.  */\n \t  /* fprintf (stderr, \"unrecog: %x\\n\", opcode); */\n \t  continue;\n \t}\n@@ -2057,16 +2069,29 @@ msp430_elf_relax_section (bfd * abfd, asection * sec,\n \t    printf (\"      R_MSP430X_10_PCREL -> R_MSP430X_ABS20_ADR_SRC \"\n \t\t    \"(growing with new opcode 0x%x)\\n\", opcode);\n \n-\t  /* Insert an absolute branch (aka MOVA) instruction.  */\n-\t  contents = msp430_elf_relax_add_two_words\n-\t    (abfd, sec, irel->r_offset + 2, 0x0080, 0x0000);\n+\t  /* Insert an absolute branch (aka MOVA) instruction.\n+\t     Note that bits 19:16 of the address are stored in the first word\n+\t     of the insn, so this is where r_offset will point to.  */\n+\t  if (opcode == 0x0080)\n+\t    {\n+\t      /* If we're inserting a BRA because we are converting from a JMP,\n+\t\t then only add one word for destination address; the BRA opcode\n+\t\t has already been written.  */\n+\t      contents = msp430_elf_relax_add_words\n+\t\t(abfd, sec, irel->r_offset + 2, 1, 0x0000, 0);\n+\t    }\n+\t  else\n+\t    {\n+\t      contents = msp430_elf_relax_add_words\n+\t\t(abfd, sec, irel->r_offset + 2, 2, 0x0080, 0x0000);\n+\t      /* Update the relocation to point to the inserted branch\n+\t\t instruction.  Note - we are changing a PC-relative reloc\n+\t\t into an absolute reloc, but this is OK because we have\n+\t\t arranged with the assembler to have the reloc's value be\n+\t\t a (local) symbol, not a section+offset value.  */\n+\t      irel->r_offset += 2;\n+\t    }\n \n-\t  /* Update the relocation to point to the inserted branch\n-\t     instruction.  Note - we are changing a PC-relative reloc\n-\t     into an absolute reloc, but this is OK because we have\n-\t     arranged with the assembler to have the reloc's value be\n-\t     a (local) symbol, not a section+offset value.  */\n-\t  irel->r_offset += 2;\n \t  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),\n \t\t\t\t       R_MSP430X_ABS20_ADR_SRC);\n \t}\n@@ -2075,12 +2100,23 @@ msp430_elf_relax_section (bfd * abfd, asection * sec,\n \t  if (debug_relocs)\n \t    printf (\"      R_MSP430_10_PCREL -> R_MSP430_16 \"\n \t\t    \"(growing with new opcode 0x%x)\\n\", opcode);\n-\t  contents = msp430_elf_relax_add_two_words\n-\t    (abfd, sec, irel->r_offset + 2, 0x4030, 0x0000);\n-\n-\t  /* See comment above about converting a 10-bit PC-rel\n-\t     relocation into a 16-bit absolute relocation.  */\n-\t  irel->r_offset += 4;\n+\t  if (opcode == 0x4030)\n+\t    {\n+\t      /* If we're inserting a BR because we are converting from a JMP,\n+\t\t then only add one word for destination address; the BR opcode\n+\t\t has already been written.  */\n+\t      contents = msp430_elf_relax_add_words\n+\t\t(abfd, sec, irel->r_offset + 2, 1, 0x0000, 0);\n+\t      irel->r_offset += 2;\n+\t    }\n+\t  else\n+\t    {\n+\t      contents = msp430_elf_relax_add_words\n+\t\t(abfd, sec, irel->r_offset + 2, 2, 0x4030, 0x0000);\n+\t      /* See comment above about converting a 10-bit PC-rel\n+\t\t relocation into a 16-bit absolute relocation.  */\n+\t      irel->r_offset += 4;\n+\t    }\n \t  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),\n \t\t\t\t       R_MSP430_16);\n \t}"
    }
  ]
}