{
  "sha": "0d305d5c67e38a65f227e6604c0812797471ace6",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGQzMDVkNWM2N2UzOGE2NWYyMjdlNjYwNGMwODEyNzk3NDcxYWNlNg==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-04-30T20:07:58Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-04-30T20:07:58Z"
    },
    "message": "Allocate dwarf2_per_cu_data with 'new'\n\nIn a patch series I am working on, I'd like to have a non-POD member\nin dwarf2_per_cu_data.  This currently can't be done because\ndwarf2_per_cu_data is allocated on an obstack and initialized with\nmemset.\n\nThis patch changes the DWARF reader to allocate objects of this type\nwith 'new'.  The various \"subclasses\" of this type (signatured_type in\nparticular) are now changed to derive from dwarf2_per_cu_data, and\nalso use 'new' for allocation.\n\nRegression tested on x86-64 Fedora 32.\n\ngdb/ChangeLog\n2021-04-30  Tom Tromey  <tom@tromey.com>\n\n\t* dwarf2/read.h (struct dwarf2_per_bfd) <allocate_per_cu,\n\tallocate_signatured_type>: Change return type.\n\t<all_comp_units, all_type_units>: Hold unique pointers.\n\t(struct dwarf2_per_cu_data): Add constructor and initializers.\n\t(struct signatured_type): Derive from dwarf2_per_cu_data.\n\t* dwarf2/read.c (type_unit_group): Derive from\n\tdwarf2_per_cu_data.\n\t(dwarf2_per_bfd::get_cutu, dwarf2_per_bfd::get_cu)\n\t(dwarf2_per_bfd::get_tu)\n\t(dwarf2_per_bfd::allocate_signatured_type)\n\t(dwarf2_per_bfd::allocate_signatured_type)\n\t(create_cu_from_index_list, create_cus_from_index_list)\n\t(create_signatured_type_table_from_index)\n\t(create_signatured_type_table_from_debug_names)\n\t(create_addrmap_from_aranges)\n\t(dwarf2_base_index_functions::find_last_source_symtab)\n\t(dw_expand_symtabs_matching_file_matcher)\n\t(dwarf2_gdb_index::expand_symtabs_matching)\n\t(dwarf2_base_index_functions::map_symbol_filenames)\n\t(create_cus_from_debug_names_list)\n\t(dw2_debug_names_iterator::next)\n\t(dwarf2_debug_names_index::expand_symtabs_matching)\n\t(create_debug_type_hash_table, add_type_unit)\n\t(fill_in_sig_entry_from_dwo_entry, lookup_dwo_signatured_type):\n\tUpdate.\n\t(allocate_type_unit_groups_table): Use delete.\n\t(create_type_unit_group): Change return type.  Use new.\n\t(get_type_unit_group, build_type_psymtabs_1)\n\t(build_type_psymtab_dependencies)\n\t(process_skeletonless_type_unit, set_partial_user)\n\t(dwarf2_build_psymtabs_hard, read_comp_units_from_section)\n\t(create_cus_hash_table, queue_and_load_dwo_tu, follow_die_sig_1)\n\t(read_signatured_type): Update.\n\t(dwarf2_find_containing_comp_unit): Change type of\n\t'all_comp_units'.\n\t(run_test): Update.\n\t(dwarf2_per_bfd::allocate_per_cu)\n\t(dwarf2_per_bfd::allocate_signatured_type): Change return type.\n\tUse new.\n\t(add_signatured_type_cu_to_table): Update.\n\t* dwarf2/index-write.c (write_one_signatured_type)\n\t(check_dwarf64_offsets, psyms_seen_size, write_gdbindex)\n\t(write_debug_names): Update.",
    "tree": {
      "sha": "bd53b1efb9f8e574727615b75c0b4c885bda059d",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bd53b1efb9f8e574727615b75c0b4c885bda059d"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0d305d5c67e38a65f227e6604c0812797471ace6",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0d305d5c67e38a65f227e6604c0812797471ace6",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0d305d5c67e38a65f227e6604c0812797471ace6",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0d305d5c67e38a65f227e6604c0812797471ace6/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "1bee48c7ad5b75896ef8d84fedc774e181fb09a7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1bee48c7ad5b75896ef8d84fedc774e181fb09a7",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/1bee48c7ad5b75896ef8d84fedc774e181fb09a7"
    }
  ],
  "stats": {
    "total": 473,
    "additions": 265,
    "deletions": 208
  },
  "files": [
    {
      "sha": "e51ef3dcbaceec0a4d18a336b83f393c3a95582e",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 46,
      "deletions": 0,
      "changes": 46,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0d305d5c67e38a65f227e6604c0812797471ace6/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0d305d5c67e38a65f227e6604c0812797471ace6/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=0d305d5c67e38a65f227e6604c0812797471ace6",
      "patch": "@@ -1,3 +1,49 @@\n+2021-04-30  Tom Tromey  <tom@tromey.com>\n+\n+\t* dwarf2/read.h (struct dwarf2_per_bfd) <allocate_per_cu,\n+\tallocate_signatured_type>: Change return type.\n+\t<all_comp_units, all_type_units>: Hold unique pointers.\n+\t(struct dwarf2_per_cu_data): Add constructor and initializers.\n+\t(struct signatured_type): Derive from dwarf2_per_cu_data.\n+\t* dwarf2/read.c (type_unit_group): Derive from\n+\tdwarf2_per_cu_data.\n+\t(dwarf2_per_bfd::get_cutu, dwarf2_per_bfd::get_cu)\n+\t(dwarf2_per_bfd::get_tu)\n+\t(dwarf2_per_bfd::allocate_signatured_type)\n+\t(dwarf2_per_bfd::allocate_signatured_type)\n+\t(create_cu_from_index_list, create_cus_from_index_list)\n+\t(create_signatured_type_table_from_index)\n+\t(create_signatured_type_table_from_debug_names)\n+\t(create_addrmap_from_aranges)\n+\t(dwarf2_base_index_functions::find_last_source_symtab)\n+\t(dw_expand_symtabs_matching_file_matcher)\n+\t(dwarf2_gdb_index::expand_symtabs_matching)\n+\t(dwarf2_base_index_functions::map_symbol_filenames)\n+\t(create_cus_from_debug_names_list)\n+\t(dw2_debug_names_iterator::next)\n+\t(dwarf2_debug_names_index::expand_symtabs_matching)\n+\t(create_debug_type_hash_table, add_type_unit)\n+\t(fill_in_sig_entry_from_dwo_entry, lookup_dwo_signatured_type):\n+\tUpdate.\n+\t(allocate_type_unit_groups_table): Use delete.\n+\t(create_type_unit_group): Change return type.  Use new.\n+\t(get_type_unit_group, build_type_psymtabs_1)\n+\t(build_type_psymtab_dependencies)\n+\t(process_skeletonless_type_unit, set_partial_user)\n+\t(dwarf2_build_psymtabs_hard, read_comp_units_from_section)\n+\t(create_cus_hash_table, queue_and_load_dwo_tu, follow_die_sig_1)\n+\t(read_signatured_type): Update.\n+\t(dwarf2_find_containing_comp_unit): Change type of\n+\t'all_comp_units'.\n+\t(run_test): Update.\n+\t(dwarf2_per_bfd::allocate_per_cu)\n+\t(dwarf2_per_bfd::allocate_signatured_type): Change return type.\n+\tUse new.\n+\t(add_signatured_type_cu_to_table): Update.\n+\t* dwarf2/index-write.c (write_one_signatured_type)\n+\t(check_dwarf64_offsets, psyms_seen_size, write_gdbindex)\n+\t(write_debug_names): Update.\n+\n 2021-04-30  Tom Tromey  <tromey@adacore.com>\n \n \t* nat/windows-nat.h (get_image_name): Don't declare."
    },
    {
      "sha": "b000cd5b8fddc34a9684a328f2a7424e39d89c74",
      "filename": "gdb/dwarf2/index-write.c",
      "status": "modified",
      "additions": 15,
      "deletions": 13,
      "changes": 28,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0d305d5c67e38a65f227e6604c0812797471ace6/gdb/dwarf2/index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0d305d5c67e38a65f227e6604c0812797471ace6/gdb/dwarf2/index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-write.c?ref=0d305d5c67e38a65f227e6604c0812797471ace6",
      "patch": "@@ -615,7 +615,7 @@ write_one_signatured_type (void **slot, void *d)\n   struct signatured_type_index_data *info\n     = (struct signatured_type_index_data *) d;\n   struct signatured_type *entry = (struct signatured_type *) *slot;\n-  partial_symtab *psymtab = entry->per_cu.v.psymtab;\n+  partial_symtab *psymtab = entry->v.psymtab;\n \n   if (psymtab == nullptr)\n     {\n@@ -633,7 +633,7 @@ write_one_signatured_type (void **slot, void *d)\n \t\t  1);\n \n   info->types_list.append_uint (8, BFD_ENDIAN_LITTLE,\n-\t\t\t\tto_underlying (entry->per_cu.sect_off));\n+\t\t\t\tto_underlying (entry->sect_off));\n   info->types_list.append_uint (8, BFD_ENDIAN_LITTLE,\n \t\t\t\tto_underlying (entry->type_offset_in_tu));\n   info->types_list.append_uint (8, BFD_ENDIAN_LITTLE, entry->signature);\n@@ -1259,15 +1259,15 @@ class debug_names\n   write_one_signatured_type (struct signatured_type *entry,\n \t\t\t     struct signatured_type_index_data *info)\n   {\n-    partial_symtab *psymtab = entry->per_cu.v.psymtab;\n+    partial_symtab *psymtab = entry->v.psymtab;\n \n     write_psymbols (info->psyms_seen, psymtab->global_psymbols,\n \t\t    info->cu_index, false, unit_kind::tu);\n     write_psymbols (info->psyms_seen, psymtab->static_psymbols,\n \t\t    info->cu_index, true, unit_kind::tu);\n \n     info->types_list.append_uint (dwarf5_offset_size (), m_dwarf5_byte_order,\n-\t\t\t\t  to_underlying (entry->per_cu.sect_off));\n+\t\t\t\t  to_underlying (entry->sect_off));\n \n     ++info->cu_index;\n   }\n@@ -1312,16 +1312,16 @@ class debug_names\n static bool\n check_dwarf64_offsets (dwarf2_per_objfile *per_objfile)\n {\n-  for (dwarf2_per_cu_data *per_cu : per_objfile->per_bfd->all_comp_units)\n+  for (const auto &per_cu : per_objfile->per_bfd->all_comp_units)\n     {\n-      if (to_underlying (per_cu->sect_off) >= (static_cast<uint64_t> (1) << 32))\n+      if (to_underlying (per_cu->sect_off)\n+\t  >= (static_cast<uint64_t> (1) << 32))\n \treturn true;\n     }\n-  for (const signatured_type *sigtype : per_objfile->per_bfd->all_type_units)\n+  for (const auto &sigtype : per_objfile->per_bfd->all_type_units)\n     {\n-      const dwarf2_per_cu_data &per_cu = sigtype->per_cu;\n-\n-      if (to_underlying (per_cu.sect_off) >= (static_cast<uint64_t> (1) << 32))\n+      if (to_underlying (sigtype->sect_off)\n+\t  >= (static_cast<uint64_t> (1) << 32))\n \treturn true;\n     }\n   return false;\n@@ -1337,7 +1337,7 @@ static size_t\n psyms_seen_size (dwarf2_per_objfile *per_objfile)\n {\n   size_t psyms_count = 0;\n-  for (dwarf2_per_cu_data *per_cu : per_objfile->per_bfd->all_comp_units)\n+  for (const auto &per_cu : per_objfile->per_bfd->all_comp_units)\n     {\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n@@ -1440,7 +1440,8 @@ write_gdbindex (dwarf2_per_objfile *per_objfile, FILE *out_file,\n     (psyms_seen_size (per_objfile));\n   for (int i = 0; i < per_objfile->per_bfd->all_comp_units.size (); ++i)\n     {\n-      dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->all_comp_units[i];\n+      dwarf2_per_cu_data *per_cu\n+\t= per_objfile->per_bfd->all_comp_units[i].get ();\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n       if (psymtab != NULL)\n@@ -1521,7 +1522,8 @@ write_debug_names (dwarf2_per_objfile *per_objfile,\n     psyms_seen (psyms_seen_size (per_objfile));\n   for (int i = 0; i < per_objfile->per_bfd->all_comp_units.size (); ++i)\n     {\n-      const dwarf2_per_cu_data *per_cu = per_objfile->per_bfd->all_comp_units[i];\n+      const dwarf2_per_cu_data *per_cu\n+\t= per_objfile->per_bfd->all_comp_units[i].get ();\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n       /* CU of a shared file from 'dwz -m' may be unused by this main"
    },
    {
      "sha": "6eb6caf10576f3ee347702b82bfeb11fd928162a",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 172,
      "deletions": 170,
      "changes": 342,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0d305d5c67e38a65f227e6604c0812797471ace6/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0d305d5c67e38a65f227e6604c0812797471ace6/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=0d305d5c67e38a65f227e6604c0812797471ace6",
      "patch": "@@ -720,21 +720,15 @@ struct stmt_list_hash\n    that can be shared across objfiles.  The non-shareable parts are in\n    type_unit_group_unshareable.  */\n \n-struct type_unit_group\n+struct type_unit_group : public dwarf2_per_cu_data\n {\n-  /* dwarf2read.c's main \"handle\" on a TU symtab.\n-     To simplify things we create an artificial CU that \"includes\" all the\n-     type units using this stmt_list so that the rest of the code still has\n-     a \"per_cu\" handle on the symtab.  */\n-  struct dwarf2_per_cu_data per_cu;\n-\n   /* The TUs that share this DW_AT_stmt_list entry.\n      This is added to while parsing type units to build partial symtabs,\n      and is deleted afterwards and not used again.  */\n-  std::vector<signatured_type *> *tus;\n+  std::vector<signatured_type *> *tus = nullptr;\n \n   /* The data used to construct the hash key.  */\n-  struct stmt_list_hash hash;\n+  struct stmt_list_hash hash {};\n };\n \n /* These sections are what may appear in a (real or virtual) DWO file.  */\n@@ -1903,11 +1897,11 @@ dwarf2_per_bfd::dwarf2_per_bfd (bfd *obfd, const dwarf2_debug_sections *names,\n \n dwarf2_per_bfd::~dwarf2_per_bfd ()\n {\n-  for (dwarf2_per_cu_data *per_cu : all_comp_units)\n+  for (auto &per_cu : all_comp_units)\n     per_cu->imported_symtabs_free ();\n \n-  for (signatured_type *sig_type : all_type_units)\n-    sig_type->per_cu.imported_symtabs_free ();\n+  for (auto &sig_type : all_type_units)\n+    sig_type->imported_symtabs_free ();\n \n   /* Everything else should be on this->obstack.  */\n }\n@@ -2540,10 +2534,10 @@ dwarf2_per_bfd::get_cutu (int index)\n     {\n       index -= this->all_comp_units.size ();\n       gdb_assert (index < this->all_type_units.size ());\n-      return &this->all_type_units[index]->per_cu;\n+      return this->all_type_units[index].get ();\n     }\n \n-  return this->all_comp_units[index];\n+  return this->all_comp_units[index].get ();\n }\n \n /* See declaration.  */\n@@ -2553,7 +2547,7 @@ dwarf2_per_bfd::get_cu (int index)\n {\n   gdb_assert (index >= 0 && index < this->all_comp_units.size ());\n \n-  return this->all_comp_units[index];\n+  return this->all_comp_units[index].get ();\n }\n \n /* See declaration.  */\n@@ -2563,41 +2557,41 @@ dwarf2_per_bfd::get_tu (int index)\n {\n   gdb_assert (index >= 0 && index < this->all_type_units.size ());\n \n-  return this->all_type_units[index];\n+  return this->all_type_units[index].get ();\n }\n \n /* See read.h.  */\n \n-dwarf2_per_cu_data *\n+std::unique_ptr<dwarf2_per_cu_data>\n dwarf2_per_bfd::allocate_per_cu ()\n {\n-  dwarf2_per_cu_data *result = OBSTACK_ZALLOC (&obstack, dwarf2_per_cu_data);\n+  std::unique_ptr<dwarf2_per_cu_data> result (new dwarf2_per_cu_data);\n   result->per_bfd = this;\n   result->index = m_num_psymtabs++;\n   return result;\n }\n \n /* See read.h.  */\n \n-signatured_type *\n+std::unique_ptr<signatured_type>\n dwarf2_per_bfd::allocate_signatured_type ()\n {\n-  signatured_type *result = OBSTACK_ZALLOC (&obstack, signatured_type);\n-  result->per_cu.per_bfd = this;\n-  result->per_cu.index = m_num_psymtabs++;\n+  std::unique_ptr<signatured_type> result (new signatured_type);\n+  result->per_bfd = this;\n+  result->index = m_num_psymtabs++;\n   return result;\n }\n \n /* Return a new dwarf2_per_cu_data allocated on the per-bfd\n    obstack, and constructed with the specified field values.  */\n \n-static dwarf2_per_cu_data *\n+static std::unique_ptr<dwarf2_per_cu_data>\n create_cu_from_index_list (dwarf2_per_bfd *per_bfd,\n \t\t\t   struct dwarf2_section_info *section,\n \t\t\t   int is_dwz,\n \t\t\t   sect_offset sect_off, ULONGEST length)\n {\n-  dwarf2_per_cu_data *the_cu = per_bfd->allocate_per_cu ();\n+  std::unique_ptr<dwarf2_per_cu_data> the_cu = per_bfd->allocate_per_cu ();\n   the_cu->sect_off = sect_off;\n   the_cu->length = length;\n   the_cu->section = section;\n@@ -2625,10 +2619,10 @@ create_cus_from_index_list (dwarf2_per_bfd *per_bfd,\n       ULONGEST length = extract_unsigned_integer (cu_list + 8, 8, BFD_ENDIAN_LITTLE);\n       cu_list += 2 * 8;\n \n-      dwarf2_per_cu_data *per_cu\n+      std::unique_ptr<dwarf2_per_cu_data> per_cu\n \t= create_cu_from_index_list (per_bfd, section, is_dwz, sect_off,\n \t\t\t\t     length);\n-      per_bfd->all_comp_units.push_back (per_cu);\n+      per_bfd->all_comp_units.push_back (std::move (per_cu));\n     }\n }\n \n@@ -2668,7 +2662,7 @@ create_signatured_type_table_from_index\n \n   for (offset_type i = 0; i < elements; i += 3)\n     {\n-      struct signatured_type *sig_type;\n+      std::unique_ptr<signatured_type> sig_type;\n       ULONGEST signature;\n       void **slot;\n       cu_offset type_offset_in_tu;\n@@ -2685,17 +2679,17 @@ create_signatured_type_table_from_index\n       sig_type = per_bfd->allocate_signatured_type ();\n       sig_type->signature = signature;\n       sig_type->type_offset_in_tu = type_offset_in_tu;\n-      sig_type->per_cu.is_debug_types = 1;\n-      sig_type->per_cu.section = section;\n-      sig_type->per_cu.sect_off = sect_off;\n-      sig_type->per_cu.v.quick\n+      sig_type->is_debug_types = 1;\n+      sig_type->section = section;\n+      sig_type->sect_off = sect_off;\n+      sig_type->v.quick\n \t= OBSTACK_ZALLOC (&per_bfd->obstack,\n \t\t\t  struct dwarf2_per_cu_quick_data);\n \n-      slot = htab_find_slot (sig_types_hash.get (), sig_type, INSERT);\n-      *slot = sig_type;\n+      slot = htab_find_slot (sig_types_hash.get (), sig_type.get (), INSERT);\n+      *slot = sig_type.get ();\n \n-      per_bfd->all_type_units.push_back (sig_type);\n+      per_bfd->all_type_units.push_back (std::move (sig_type));\n     }\n \n   per_bfd->signatured_types = std::move (sig_types_hash);\n@@ -2722,7 +2716,7 @@ create_signatured_type_table_from_debug_names\n \n   for (uint32_t i = 0; i < map.tu_count; ++i)\n     {\n-      struct signatured_type *sig_type;\n+      std::unique_ptr<signatured_type> sig_type;\n       void **slot;\n \n       sect_offset sect_off\n@@ -2740,17 +2734,17 @@ create_signatured_type_table_from_debug_names\n       sig_type = per_objfile->per_bfd->allocate_signatured_type ();\n       sig_type->signature = cu_header.signature;\n       sig_type->type_offset_in_tu = cu_header.type_cu_offset_in_tu;\n-      sig_type->per_cu.is_debug_types = 1;\n-      sig_type->per_cu.section = section;\n-      sig_type->per_cu.sect_off = sect_off;\n-      sig_type->per_cu.v.quick\n+      sig_type->is_debug_types = 1;\n+      sig_type->section = section;\n+      sig_type->sect_off = sect_off;\n+      sig_type->v.quick\n \t= OBSTACK_ZALLOC (&per_objfile->per_bfd->obstack,\n \t\t\t  struct dwarf2_per_cu_quick_data);\n \n-      slot = htab_find_slot (sig_types_hash.get (), sig_type, INSERT);\n-      *slot = sig_type;\n+      slot = htab_find_slot (sig_types_hash.get (), sig_type.get (), INSERT);\n+      *slot = sig_type.get ();\n \n-      per_objfile->per_bfd->all_type_units.push_back (sig_type);\n+      per_objfile->per_bfd->all_type_units.push_back (std::move (sig_type));\n     }\n \n   per_objfile->per_bfd->signatured_types = std::move (sig_types_hash);\n@@ -2833,10 +2827,11 @@ create_addrmap_from_aranges (dwarf2_per_objfile *per_objfile,\n \t\t     dwarf2_per_cu_data *,\n \t\t     gdb::hash_enum<sect_offset>>\n     debug_info_offset_to_per_cu;\n-  for (dwarf2_per_cu_data *per_cu : per_bfd->all_comp_units)\n+  for (const auto &per_cu : per_bfd->all_comp_units)\n     {\n       const auto insertpair\n-\t= debug_info_offset_to_per_cu.emplace (per_cu->sect_off, per_cu);\n+\t= debug_info_offset_to_per_cu.emplace (per_cu->sect_off,\n+\t\t\t\t\t       per_cu.get ());\n       if (!insertpair.second)\n \t{\n \t  warning (_(\"Section .debug_aranges in %s has duplicate \"\n@@ -3310,7 +3305,8 @@ struct symtab *\n dwarf2_base_index_functions::find_last_source_symtab (struct objfile *objfile)\n {\n   dwarf2_per_objfile *per_objfile = get_dwarf2_per_objfile (objfile);\n-  dwarf2_per_cu_data *dwarf_cu = per_objfile->per_bfd->all_comp_units.back ();\n+  dwarf2_per_cu_data *dwarf_cu\n+    = per_objfile->per_bfd->all_comp_units.back ().get ();\n   compunit_symtab *cust = dw2_instantiate_symtab (dwarf_cu, per_objfile, false);\n \n   if (cust == NULL)\n@@ -4541,17 +4537,18 @@ dw_expand_symtabs_matching_file_matcher\n   /* The rule is CUs specify all the files, including those used by\n      any TU, so there's no need to scan TUs here.  */\n \n-  for (dwarf2_per_cu_data *per_cu : per_objfile->per_bfd->all_comp_units)\n+  for (const auto &per_cu : per_objfile->per_bfd->all_comp_units)\n     {\n       QUIT;\n \n       per_cu->v.quick->mark = 0;\n \n       /* We only need to look at symtabs not already expanded.  */\n-      if (per_objfile->symtab_set_p (per_cu))\n+      if (per_objfile->symtab_set_p (per_cu.get ()))\n \tcontinue;\n \n-      quick_file_names *file_data = dw2_get_file_names (per_cu, per_objfile);\n+      quick_file_names *file_data = dw2_get_file_names (per_cu.get (),\n+\t\t\t\t\t\t\tper_objfile);\n       if (file_data == NULL)\n \tcontinue;\n \n@@ -4617,11 +4614,11 @@ dwarf2_gdb_index::expand_symtabs_matching\n \n   if (symbol_matcher == NULL && lookup_name == NULL)\n     {\n-      for (dwarf2_per_cu_data *per_cu : per_objfile->per_bfd->all_comp_units)\n+      for (const auto &per_cu : per_objfile->per_bfd->all_comp_units)\n \t{\n \t  QUIT;\n \n-\t  if (!dw2_expand_symtabs_matching_one (per_cu, per_objfile,\n+\t  if (!dw2_expand_symtabs_matching_one (per_cu.get (), per_objfile,\n \t\t\t\t\t\tfile_matcher,\n \t\t\t\t\t\texpansion_notify))\n \t    return false;\n@@ -4724,22 +4721,23 @@ dwarf2_base_index_functions::map_symbol_filenames\n      reuse the file names data from a currently unexpanded CU, in this\n      case we don't want to report the files from the unexpanded CU.  */\n \n-  for (dwarf2_per_cu_data *per_cu : per_objfile->per_bfd->all_comp_units)\n+  for (const auto &per_cu : per_objfile->per_bfd->all_comp_units)\n     {\n-      if (per_objfile->symtab_set_p (per_cu))\n+      if (per_objfile->symtab_set_p (per_cu.get ()))\n \t{\n \t  if (per_cu->v.quick->file_names != nullptr)\n \t    qfn_cache.insert (per_cu->v.quick->file_names);\n \t}\n     }\n \n-  for (dwarf2_per_cu_data *per_cu : per_objfile->per_bfd->all_comp_units)\n+  for (const auto &per_cu : per_objfile->per_bfd->all_comp_units)\n     {\n       /* We only need to look at symtabs not already expanded.  */\n-      if (per_objfile->symtab_set_p (per_cu))\n+      if (per_objfile->symtab_set_p (per_cu.get ()))\n \tcontinue;\n \n-      quick_file_names *file_data = dw2_get_file_names (per_cu, per_objfile);\n+      quick_file_names *file_data = dw2_get_file_names (per_cu.get (),\n+\t\t\t\t\t\t\tper_objfile);\n       if (file_data == nullptr\n \t  || qfn_cache.find (file_data) != qfn_cache.end ())\n \tcontinue;\n@@ -4979,10 +4977,10 @@ create_cus_from_debug_names_list (dwarf2_per_bfd *per_bfd,\n \t     of the next CU as end of this CU.  We create the CUs here with\n \t     length 0, and in cutu_reader::cutu_reader we'll fill in the\n \t     actual length.  */\n-\t  dwarf2_per_cu_data *per_cu\n+\t  std::unique_ptr<dwarf2_per_cu_data> per_cu\n \t    = create_cu_from_index_list (per_bfd, &section, is_dwz,\n \t\t\t\t\t sect_off, 0);\n-\t  per_bfd->all_comp_units.push_back (per_cu);\n+\t  per_bfd->all_comp_units.push_back (std::move (per_cu));\n \t}\n       return;\n     }\n@@ -5004,10 +5002,10 @@ create_cus_from_debug_names_list (dwarf2_per_bfd *per_bfd,\n       if (i >= 1)\n \t{\n \t  const ULONGEST length = sect_off_next - sect_off_prev;\n-\t  dwarf2_per_cu_data *per_cu\n+\t  std::unique_ptr<dwarf2_per_cu_data> per_cu\n \t    = create_cu_from_index_list (per_bfd, &section, is_dwz,\n \t\t\t\t\t sect_off_prev, length);\n-\t  per_bfd->all_comp_units.push_back (per_cu);\n+\t  per_bfd->all_comp_units.push_back (std::move (per_cu));\n \t}\n       sect_off_prev = sect_off_next;\n     }\n@@ -5367,7 +5365,7 @@ dw2_debug_names_iterator::next ()\n \t\t\t objfile_name (objfile));\n \t      continue;\n \t    }\n-\t  per_cu = &per_bfd->get_tu (ull)->per_cu;\n+\t  per_cu = per_bfd->get_tu (ull);\n \t  break;\n \tcase DW_IDX_die_offset:\n \t  /* In a per-CU index (as opposed to a per-module index), index\n@@ -5584,11 +5582,11 @@ dwarf2_debug_names_index::expand_symtabs_matching\n \n   if (symbol_matcher == NULL && lookup_name == NULL)\n     {\n-      for (dwarf2_per_cu_data *per_cu : per_objfile->per_bfd->all_comp_units)\n+      for (const auto &per_cu : per_objfile->per_bfd->all_comp_units)\n \t{\n \t  QUIT;\n \n-\t  if (!dw2_expand_symtabs_matching_one (per_cu, per_objfile,\n+\t  if (!dw2_expand_symtabs_matching_one (per_cu.get (), per_objfile,\n \t\t\t\t\t\tfile_matcher,\n \t\t\t\t\t\texpansion_notify))\n \t    return false;\n@@ -6056,10 +6054,10 @@ static int\n add_signatured_type_cu_to_table (void **slot, void *datum)\n {\n   struct signatured_type *sigt = (struct signatured_type *) *slot;\n-  std::vector<signatured_type *> *all_type_units\n-    = (std::vector<signatured_type *> *) datum;\n+  std::vector<std::unique_ptr<signatured_type>> *all_type_units\n+    = (std::vector<std::unique_ptr<signatured_type>> *) datum;\n \n-  all_type_units->push_back (sigt);\n+  all_type_units->emplace_back (sigt);\n \n   return 1;\n }\n@@ -6103,7 +6101,7 @@ create_debug_type_hash_table (dwarf2_per_objfile *per_objfile,\n   end_ptr = info_ptr + section->size;\n   while (info_ptr < end_ptr)\n     {\n-      struct signatured_type *sig_type;\n+      std::unique_ptr<signatured_type> sig_type;\n       struct dwo_unit *dwo_tu;\n       void **slot;\n       const gdb_byte *ptr = info_ptr;\n@@ -6144,7 +6142,6 @@ create_debug_type_hash_table (dwarf2_per_objfile *per_objfile,\n \n       if (dwo_file)\n \t{\n-\t  sig_type = NULL;\n \t  dwo_tu = OBSTACK_ZALLOC (&per_objfile->per_bfd->obstack, dwo_unit);\n \t  dwo_tu->dwo_file = dwo_file;\n \t  dwo_tu->signature = header.signature;\n@@ -6161,14 +6158,16 @@ create_debug_type_hash_table (dwarf2_per_objfile *per_objfile,\n \t  sig_type = per_objfile->per_bfd->allocate_signatured_type ();\n \t  sig_type->signature = header.signature;\n \t  sig_type->type_offset_in_tu = header.type_cu_offset_in_tu;\n-\t  sig_type->per_cu.is_debug_types = 1;\n-\t  sig_type->per_cu.section = section;\n-\t  sig_type->per_cu.sect_off = sect_off;\n-\t  sig_type->per_cu.length = length;\n+\t  sig_type->is_debug_types = 1;\n+\t  sig_type->section = section;\n+\t  sig_type->sect_off = sect_off;\n+\t  sig_type->length = length;\n \t}\n \n       slot = htab_find_slot (types_htab.get (),\n-\t\t\t     dwo_file ? (void*) dwo_tu : (void *) sig_type,\n+\t\t\t     (dwo_file\n+\t\t\t      ? (void *) dwo_tu\n+\t\t\t      : (void *) sig_type.get ()),\n \t\t\t     INSERT);\n       gdb_assert (slot != NULL);\n       if (*slot != NULL)\n@@ -6187,15 +6186,15 @@ create_debug_type_hash_table (dwarf2_per_objfile *per_objfile,\n \t      const struct signatured_type *dup_tu\n \t\t= (const struct signatured_type *) *slot;\n \n-\t      dup_sect_off = dup_tu->per_cu.sect_off;\n+\t      dup_sect_off = dup_tu->sect_off;\n \t    }\n \n \t  complaint (_(\"debug type entry at offset %s is duplicate to\"\n \t\t       \" the entry at offset %s, signature %s\"),\n \t\t     sect_offset_str (sect_off), sect_offset_str (dup_sect_off),\n \t\t     hex_string (header.signature));\n \t}\n-      *slot = dwo_file ? (void *) dwo_tu : (void *) sig_type;\n+      *slot = dwo_file ? (void *) dwo_tu : (void *) sig_type.release ();\n \n       dwarf_read_debug_printf_v (\"  offset %s, signature %s\",\n \t\t\t\t sect_offset_str (sect_off),\n@@ -6269,16 +6268,18 @@ add_type_unit (dwarf2_per_objfile *per_objfile, ULONGEST sig, void **slot)\n       == per_objfile->per_bfd->all_type_units.capacity ())\n     ++per_objfile->per_bfd->tu_stats.nr_all_type_units_reallocs;\n \n-  signatured_type *sig_type = per_objfile->per_bfd->allocate_signatured_type ();\n+  std::unique_ptr<signatured_type> sig_type_holder\n+    = per_objfile->per_bfd->allocate_signatured_type ();\n+  signatured_type *sig_type = sig_type_holder.get ();\n \n   per_objfile->resize_symtabs ();\n \n-  per_objfile->per_bfd->all_type_units.push_back (sig_type);\n+  per_objfile->per_bfd->all_type_units.push_back (std::move (sig_type_holder));\n   sig_type->signature = sig;\n-  sig_type->per_cu.is_debug_types = 1;\n+  sig_type->is_debug_types = 1;\n   if (per_objfile->per_bfd->using_index)\n     {\n-      sig_type->per_cu.v.quick =\n+      sig_type->v.quick =\n \tOBSTACK_ZALLOC (&per_objfile->per_bfd->obstack,\n \t\t\tstruct dwarf2_per_cu_quick_data);\n     }\n@@ -6305,25 +6306,25 @@ fill_in_sig_entry_from_dwo_entry (dwarf2_per_objfile *per_objfile,\n   dwarf2_per_bfd *per_bfd = per_objfile->per_bfd;\n \n   /* Make sure we're not clobbering something we don't expect to.  */\n-  gdb_assert (! sig_entry->per_cu.queued);\n-  gdb_assert (per_objfile->get_cu (&sig_entry->per_cu) == NULL);\n+  gdb_assert (! sig_entry->queued);\n+  gdb_assert (per_objfile->get_cu (sig_entry) == NULL);\n   if (per_bfd->using_index)\n     {\n-      gdb_assert (sig_entry->per_cu.v.quick != NULL);\n-      gdb_assert (!per_objfile->symtab_set_p (&sig_entry->per_cu));\n+      gdb_assert (sig_entry->v.quick != NULL);\n+      gdb_assert (!per_objfile->symtab_set_p (sig_entry));\n     }\n   else\n-      gdb_assert (sig_entry->per_cu.v.psymtab == NULL);\n+      gdb_assert (sig_entry->v.psymtab == NULL);\n   gdb_assert (sig_entry->signature == dwo_entry->signature);\n   gdb_assert (to_underlying (sig_entry->type_offset_in_section) == 0);\n   gdb_assert (sig_entry->type_unit_group == NULL);\n   gdb_assert (sig_entry->dwo_unit == NULL);\n \n-  sig_entry->per_cu.section = dwo_entry->section;\n-  sig_entry->per_cu.sect_off = dwo_entry->sect_off;\n-  sig_entry->per_cu.length = dwo_entry->length;\n-  sig_entry->per_cu.reading_dwo_directly = 1;\n-  sig_entry->per_cu.per_bfd = per_bfd;\n+  sig_entry->section = dwo_entry->section;\n+  sig_entry->sect_off = dwo_entry->sect_off;\n+  sig_entry->length = dwo_entry->length;\n+  sig_entry->reading_dwo_directly = 1;\n+  sig_entry->per_bfd = per_bfd;\n   sig_entry->type_offset_in_tu = dwo_entry->type_offset_in_tu;\n   sig_entry->dwo_unit = dwo_entry;\n }\n@@ -6376,7 +6377,7 @@ lookup_dwo_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n   /* Have we already tried to read this TU?\n      Note: sig_entry can be NULL if the skeleton TU was removed (thus it\n      needn't exist in the global table yet).  */\n-  if (sig_entry != NULL && sig_entry->per_cu.tu_read)\n+  if (sig_entry != NULL && sig_entry->tu_read)\n     return sig_entry;\n \n   /* Note: cu->dwo_unit is the dwo_unit that references this TU, not the\n@@ -6397,7 +6398,7 @@ lookup_dwo_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n     sig_entry = add_type_unit (per_objfile, sig, slot);\n \n   fill_in_sig_entry_from_dwo_entry (per_objfile, sig_entry, dwo_entry);\n-  sig_entry->per_cu.tu_read = 1;\n+  sig_entry->tu_read = 1;\n   return sig_entry;\n }\n \n@@ -7116,7 +7117,13 @@ allocate_type_unit_groups_table ()\n   return htab_up (htab_create_alloc (3,\n \t\t\t\t     hash_type_unit_group,\n \t\t\t\t     eq_type_unit_group,\n-\t\t\t\t     NULL, xcalloc, xfree));\n+\t\t\t\t     [] (void *arg)\n+\t\t\t\t     {\n+\t\t\t\t       type_unit_group *grp\n+\t\t\t\t\t = (type_unit_group *) arg;\n+\t\t\t\t       delete grp;\n+\t\t\t\t     },\n+\t\t\t\t     xcalloc, xfree));\n }\n \n /* Type units that don't have DW_AT_stmt_list are grouped into their own\n@@ -7128,22 +7135,19 @@ allocate_type_unit_groups_table ()\n /* Helper routine for get_type_unit_group.\n    Create the type_unit_group object used to hold one or more TUs.  */\n \n-static struct type_unit_group *\n+static std::unique_ptr<type_unit_group>\n create_type_unit_group (struct dwarf2_cu *cu, sect_offset line_offset_struct)\n {\n   dwarf2_per_objfile *per_objfile = cu->per_objfile;\n   dwarf2_per_bfd *per_bfd = per_objfile->per_bfd;\n-  struct dwarf2_per_cu_data *per_cu;\n-  struct type_unit_group *tu_group;\n \n-  tu_group = OBSTACK_ZALLOC (&per_bfd->obstack, type_unit_group);\n-  per_cu = &tu_group->per_cu;\n-  per_cu->per_bfd = per_bfd;\n+  std::unique_ptr<type_unit_group> tu_group (new type_unit_group);\n+  tu_group->per_bfd = per_bfd;\n \n   if (per_bfd->using_index)\n     {\n-      per_cu->v.quick = OBSTACK_ZALLOC (&per_bfd->obstack,\n-\t\t\t\t\tstruct dwarf2_per_cu_quick_data);\n+      tu_group->v.quick = OBSTACK_ZALLOC (&per_bfd->obstack,\n+\t\t\t\t\t  struct dwarf2_per_cu_quick_data);\n     }\n   else\n     {\n@@ -7158,7 +7162,8 @@ create_type_unit_group (struct dwarf2_cu *cu, sect_offset line_offset_struct)\n       else\n \tname = string_printf (\"<type_units_at_0x%x>\", line_offset);\n \n-      pst = create_partial_symtab (per_cu, per_objfile, name.c_str ());\n+      pst = create_partial_symtab (tu_group.get (), per_objfile,\n+\t\t\t\t   name.c_str ());\n       pst->anonymous = true;\n     }\n \n@@ -7208,19 +7213,17 @@ get_type_unit_group (struct dwarf2_cu *cu, const struct attribute *stmt_list)\n   type_unit_group_for_lookup.hash.line_sect_off = (sect_offset) line_offset;\n   slot = htab_find_slot (per_objfile->per_bfd->type_unit_groups.get (),\n \t\t\t &type_unit_group_for_lookup, INSERT);\n-  if (*slot != NULL)\n-    {\n-      tu_group = (struct type_unit_group *) *slot;\n-      gdb_assert (tu_group != NULL);\n-    }\n-  else\n+  if (*slot == nullptr)\n     {\n       sect_offset line_offset_struct = (sect_offset) line_offset;\n-      tu_group = create_type_unit_group (cu, line_offset_struct);\n-      *slot = tu_group;\n+      std::unique_ptr<type_unit_group> grp\n+\t= create_type_unit_group (cu, line_offset_struct);\n+      *slot = grp.release ();\n       ++tu_stats->nr_symtabs;\n     }\n \n+  tu_group = (struct type_unit_group *) *slot;\n+  gdb_assert (tu_group != nullptr);\n   return tu_group;\n }\n \f\n@@ -7560,10 +7563,10 @@ build_type_psymtabs_1 (dwarf2_per_objfile *per_objfile)\n   std::vector<tu_abbrev_offset> sorted_by_abbrev;\n   sorted_by_abbrev.reserve (per_objfile->per_bfd->all_type_units.size ());\n \n-  for (signatured_type *sig_type : per_objfile->per_bfd->all_type_units)\n+  for (const auto &sig_type : per_objfile->per_bfd->all_type_units)\n     sorted_by_abbrev.emplace_back\n-      (sig_type, read_abbrev_offset (per_objfile, sig_type->per_cu.section,\n-\t\t\t\t     sig_type->per_cu.sect_off));\n+      (sig_type.get (), read_abbrev_offset (per_objfile, sig_type->section,\n+\t\t\t\t\t    sig_type->sect_off));\n \n   std::sort (sorted_by_abbrev.begin (), sorted_by_abbrev.end (),\n \t     sort_tu_by_abbrev_offset);\n@@ -7583,7 +7586,7 @@ build_type_psymtabs_1 (dwarf2_per_objfile *per_objfile)\n \t  ++tu_stats->nr_uniq_abbrev_tables;\n \t}\n \n-      cutu_reader reader (&tu.sig_type->per_cu, per_objfile,\n+      cutu_reader reader (tu.sig_type, per_objfile,\n \t\t\t  abbrev_table.get (), nullptr, false);\n       if (!reader.dummy_p)\n \tbuild_type_psymtabs_reader (&reader, reader.info_ptr,\n@@ -7621,21 +7624,20 @@ build_type_psymtab_dependencies (void **slot, void *info)\n   dwarf2_per_objfile *per_objfile = (dwarf2_per_objfile *) info;\n   dwarf2_per_bfd *per_bfd = per_objfile->per_bfd;\n   struct type_unit_group *tu_group = (struct type_unit_group *) *slot;\n-  struct dwarf2_per_cu_data *per_cu = &tu_group->per_cu;\n-  dwarf2_psymtab *pst = per_cu->v.psymtab;\n+  dwarf2_psymtab *pst = tu_group->v.psymtab;\n   int len = (tu_group->tus == nullptr) ? 0 : tu_group->tus->size ();\n   int i;\n \n   gdb_assert (len > 0);\n-  gdb_assert (per_cu->type_unit_group_p ());\n+  gdb_assert (tu_group->type_unit_group_p ());\n \n   pst->number_of_dependencies = len;\n   pst->dependencies = per_bfd->partial_symtabs->allocate_dependencies (len);\n   for (i = 0; i < len; ++i)\n     {\n       struct signatured_type *iter = tu_group->tus->at (i);\n-      gdb_assert (iter->per_cu.is_debug_types);\n-      pst->dependencies[i] = iter->per_cu.v.psymtab;\n+      gdb_assert (iter->is_debug_types);\n+      pst->dependencies[i] = iter->v.psymtab;\n       iter->type_unit_group = tu_group;\n     }\n \n@@ -7687,7 +7689,7 @@ process_skeletonless_type_unit (void **slot, void *info)\n   *slot = entry;\n \n   /* This does the job that build_type_psymtabs_1 would have done.  */\n-  cutu_reader reader (&entry->per_cu, per_objfile, nullptr, nullptr, false);\n+  cutu_reader reader (entry, per_objfile, nullptr, nullptr, false);\n   if (!reader.dummy_p)\n     build_type_psymtabs_reader (&reader, reader.info_ptr,\n \t\t\t\treader.comp_unit_die);\n@@ -7731,7 +7733,7 @@ process_skeletonless_type_units (dwarf2_per_objfile *per_objfile)\n static void\n set_partial_user (dwarf2_per_objfile *per_objfile)\n {\n-  for (dwarf2_per_cu_data *per_cu : per_objfile->per_bfd->all_comp_units)\n+  for (const auto &per_cu : per_objfile->per_bfd->all_comp_units)\n     {\n       dwarf2_psymtab *pst = per_cu->v.psymtab;\n \n@@ -7780,12 +7782,12 @@ dwarf2_build_psymtabs_hard (dwarf2_per_objfile *per_objfile)\n     = make_scoped_restore (&per_bfd->partial_symtabs->psymtabs_addrmap,\n \t\t\t   addrmap_create_mutable (&temp_obstack));\n \n-  for (dwarf2_per_cu_data *per_cu : per_bfd->all_comp_units)\n+  for (const auto &per_cu : per_bfd->all_comp_units)\n     {\n       if (per_cu->v.psymtab != NULL)\n \t/* In case a forward DW_TAG_imported_unit has read the CU already.  */\n \tcontinue;\n-      process_psymtab_comp_unit (per_cu, per_objfile, false,\n+      process_psymtab_comp_unit (per_cu.get (), per_objfile, false,\n \t\t\t\t language_minimal);\n     }\n \n@@ -7858,7 +7860,7 @@ read_comp_units_from_section (dwarf2_per_objfile *per_objfile,\n \n   while (info_ptr < section->buffer + section->size)\n     {\n-      struct dwarf2_per_cu_data *this_cu;\n+      std::unique_ptr<dwarf2_per_cu_data> this_cu;\n \n       sect_offset sect_off = (sect_offset) (info_ptr - section->buffer);\n \n@@ -7875,17 +7877,16 @@ read_comp_units_from_section (dwarf2_per_objfile *per_objfile,\n \t  auto sig_type = per_objfile->per_bfd->allocate_signatured_type ();\n \t  sig_type->signature = cu_header.signature;\n \t  sig_type->type_offset_in_tu = cu_header.type_cu_offset_in_tu;\n-\t  this_cu = &sig_type->per_cu;\n+\t  this_cu = std::move (sig_type);\n \t}\n       this_cu->is_debug_types = (cu_header.unit_type == DW_UT_type);\n       this_cu->sect_off = sect_off;\n       this_cu->length = cu_header.length + cu_header.initial_length_size;\n       this_cu->is_dwz = is_dwz;\n       this_cu->section = section;\n \n-      per_objfile->per_bfd->all_comp_units.push_back (this_cu);\n-\n       info_ptr = info_ptr + this_cu->length;\n+      per_objfile->per_bfd->all_comp_units.push_back (std::move (this_cu));\n     }\n }\n \n@@ -11262,7 +11263,6 @@ create_cus_hash_table (dwarf2_per_objfile *per_objfile,\n       void **slot;\n       sect_offset sect_off = (sect_offset) (info_ptr - section.buffer);\n \n-      memset (&per_cu, 0, sizeof (per_cu));\n       per_cu.per_bfd = per_bfd;\n       per_cu.is_debug_types = 0;\n       per_cu.sect_off = sect_offset (info_ptr - section.buffer);\n@@ -13090,14 +13090,13 @@ queue_and_load_dwo_tu (void **slot, void *info)\n \n   if (sig_type != NULL)\n     {\n-      struct dwarf2_per_cu_data *sig_cu = &sig_type->per_cu;\n-\n       /* We pass NULL for DEPENDENT_CU because we don't yet know if there's\n \t a real dependency of PER_CU on SIG_TYPE.  That is detected later\n \t while processing PER_CU.  */\n-      if (maybe_queue_comp_unit (NULL, sig_cu, cu->per_objfile, cu->language))\n-\tload_full_type_unit (sig_cu, cu->per_objfile);\n-      cu->per_cu->imported_symtabs_push (sig_cu);\n+      if (maybe_queue_comp_unit (NULL, sig_type, cu->per_objfile,\n+\t\t\t\t cu->language))\n+\tload_full_type_unit (sig_type, cu->per_objfile);\n+      cu->per_cu->imported_symtabs_push (sig_type);\n     }\n \n   return 1;\n@@ -23882,12 +23881,12 @@ follow_die_sig_1 (struct die_info *src_die, struct signatured_type *sig_type,\n      Even if maybe_queue_comp_unit doesn't require us to load the CU's DIEs,\n      it doesn't mean they are currently loaded.  Since we require them\n      to be loaded, we must check for ourselves.  */\n-  if (maybe_queue_comp_unit (*ref_cu, &sig_type->per_cu, per_objfile,\n+  if (maybe_queue_comp_unit (*ref_cu, sig_type, per_objfile,\n \t\t\t     language_minimal)\n-      || per_objfile->get_cu (&sig_type->per_cu) == nullptr)\n+      || per_objfile->get_cu (sig_type) == nullptr)\n     read_signatured_type (sig_type, per_objfile);\n \n-  sig_cu = per_objfile->get_cu (&sig_type->per_cu);\n+  sig_cu = per_objfile->get_cu (sig_type);\n   gdb_assert (sig_cu != NULL);\n   gdb_assert (to_underlying (sig_type->type_offset_in_section) != 0);\n   temp_die.sect_off = sig_type->type_offset_in_section;\n@@ -24076,12 +24075,10 @@ static void\n read_signatured_type (signatured_type *sig_type,\n \t\t      dwarf2_per_objfile *per_objfile)\n {\n-  struct dwarf2_per_cu_data *per_cu = &sig_type->per_cu;\n-\n-  gdb_assert (per_cu->is_debug_types);\n-  gdb_assert (per_objfile->get_cu (per_cu) == nullptr);\n+  gdb_assert (sig_type->is_debug_types);\n+  gdb_assert (per_objfile->get_cu (sig_type) == nullptr);\n \n-  cutu_reader reader (per_cu, per_objfile, nullptr, nullptr, false);\n+  cutu_reader reader (sig_type, per_objfile, nullptr, nullptr, false);\n \n   if (!reader.dummy_p)\n     {\n@@ -24116,7 +24113,7 @@ read_signatured_type (signatured_type *sig_type,\n       reader.keep ();\n     }\n \n-  sig_type->per_cu.tu_read = 1;\n+  sig_type->tu_read = 1;\n }\n \n /* Decode simple location descriptions.\n@@ -24710,7 +24707,7 @@ static int\n dwarf2_find_containing_comp_unit\n   (sect_offset sect_off,\n    unsigned int offset_in_dwz,\n-   const std::vector<dwarf2_per_cu_data *> &all_comp_units)\n+   const std::vector<std::unique_ptr<dwarf2_per_cu_data>> &all_comp_units)\n {\n   int low, high;\n \n@@ -24721,7 +24718,7 @@ dwarf2_find_containing_comp_unit\n       struct dwarf2_per_cu_data *mid_cu;\n       int mid = low + (high - low) / 2;\n \n-      mid_cu = all_comp_units[mid];\n+      mid_cu = all_comp_units[mid].get ();\n       if (mid_cu->is_dwz > offset_in_dwz\n \t  || (mid_cu->is_dwz == offset_in_dwz\n \t      && mid_cu->sect_off + mid_cu->length > sect_off))\n@@ -24743,7 +24740,8 @@ dwarf2_find_containing_comp_unit (sect_offset sect_off,\n {\n   int low = dwarf2_find_containing_comp_unit\n     (sect_off, offset_in_dwz, per_objfile->per_bfd->all_comp_units);\n-  dwarf2_per_cu_data *this_cu = per_objfile->per_bfd->all_comp_units[low];\n+  dwarf2_per_cu_data *this_cu\n+    = per_objfile->per_bfd->all_comp_units[low].get ();\n \n   if (this_cu->is_dwz != offset_in_dwz || this_cu->sect_off > sect_off)\n     {\n@@ -24755,7 +24753,7 @@ dwarf2_find_containing_comp_unit (sect_offset sect_off,\n \n       gdb_assert (per_objfile->per_bfd->all_comp_units[low-1]->sect_off\n \t\t  <= sect_off);\n-      return per_objfile->per_bfd->all_comp_units[low-1];\n+      return per_objfile->per_bfd->all_comp_units[low - 1].get ();\n     }\n   else\n     {\n@@ -24775,42 +24773,46 @@ namespace find_containing_comp_unit {\n static void\n run_test ()\n {\n-  struct dwarf2_per_cu_data one {};\n-  struct dwarf2_per_cu_data two {};\n-  struct dwarf2_per_cu_data three {};\n-  struct dwarf2_per_cu_data four {};\n-\n-  one.length = 5;\n-  two.sect_off = sect_offset (one.length);\n-  two.length = 7;\n-\n-  three.length = 5;\n-  three.is_dwz = 1;\n-  four.sect_off = sect_offset (three.length);\n-  four.length = 7;\n-  four.is_dwz = 1;\n-\n-  std::vector<dwarf2_per_cu_data *> units;\n-  units.push_back (&one);\n-  units.push_back (&two);\n-  units.push_back (&three);\n-  units.push_back (&four);\n+  std::unique_ptr<dwarf2_per_cu_data> one (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data *one_ptr = one.get ();\n+  std::unique_ptr<dwarf2_per_cu_data> two (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data *two_ptr = two.get ();\n+  std::unique_ptr<dwarf2_per_cu_data> three (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data *three_ptr = three.get ();\n+  std::unique_ptr<dwarf2_per_cu_data> four (new dwarf2_per_cu_data);\n+  dwarf2_per_cu_data *four_ptr = four.get ();\n+\n+  one->length = 5;\n+  two->sect_off = sect_offset (one->length);\n+  two->length = 7;\n+\n+  three->length = 5;\n+  three->is_dwz = 1;\n+  four->sect_off = sect_offset (three->length);\n+  four->length = 7;\n+  four->is_dwz = 1;\n+\n+  std::vector<std::unique_ptr<dwarf2_per_cu_data>> units;\n+  units.push_back (std::move (one));\n+  units.push_back (std::move (two));\n+  units.push_back (std::move (three));\n+  units.push_back (std::move (four));\n \n   int result;\n \n   result = dwarf2_find_containing_comp_unit (sect_offset (0), 0, units);\n-  SELF_CHECK (units[result] == &one);\n+  SELF_CHECK (units[result].get () == one_ptr);\n   result = dwarf2_find_containing_comp_unit (sect_offset (3), 0, units);\n-  SELF_CHECK (units[result] == &one);\n+  SELF_CHECK (units[result].get () == one_ptr);\n   result = dwarf2_find_containing_comp_unit (sect_offset (5), 0, units);\n-  SELF_CHECK (units[result] == &two);\n+  SELF_CHECK (units[result].get () == two_ptr);\n \n   result = dwarf2_find_containing_comp_unit (sect_offset (0), 1, units);\n-  SELF_CHECK (units[result] == &three);\n+  SELF_CHECK (units[result].get () == three_ptr);\n   result = dwarf2_find_containing_comp_unit (sect_offset (3), 1, units);\n-  SELF_CHECK (units[result] == &three);\n+  SELF_CHECK (units[result].get () == three_ptr);\n   result = dwarf2_find_containing_comp_unit (sect_offset (5), 1, units);\n-  SELF_CHECK (units[result] == &four);\n+  SELF_CHECK (units[result].get () == four_ptr);\n }\n \n }"
    },
    {
      "sha": "98ace89644f217e4ee9282dcc02cbcd82ab04200",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 32,
      "deletions": 25,
      "changes": 57,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0d305d5c67e38a65f227e6604c0812797471ace6/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0d305d5c67e38a65f227e6604c0812797471ace6/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=0d305d5c67e38a65f227e6604c0812797471ace6",
      "patch": "@@ -120,12 +120,12 @@ struct dwarf2_per_bfd\n   /* A convenience function to allocate a dwarf2_per_cu_data.  The\n      returned object has its \"index\" field set properly.  The object\n      is allocated on the dwarf2_per_bfd obstack.  */\n-  dwarf2_per_cu_data *allocate_per_cu ();\n+  std::unique_ptr<dwarf2_per_cu_data> allocate_per_cu ();\n \n   /* A convenience function to allocate a signatured_type.  The\n      returned object has its \"index\" field set properly.  The object\n      is allocated on the dwarf2_per_bfd obstack.  */\n-  signatured_type *allocate_signatured_type ();\n+  std::unique_ptr<signatured_type> allocate_signatured_type ();\n \n   /* Return the number of partial symtabs allocated with allocate_per_cu\n      and allocate_signatured_type so far.  */\n@@ -171,10 +171,10 @@ struct dwarf2_per_bfd\n \n   /* Table of all the compilation units.  This is used to locate\n      the target compilation unit of a particular reference.  */\n-  std::vector<dwarf2_per_cu_data *> all_comp_units;\n+  std::vector<std::unique_ptr<dwarf2_per_cu_data>> all_comp_units;\n \n   /* The .debug_types-related CUs (TUs).  */\n-  std::vector<signatured_type *> all_type_units;\n+  std::vector<std::unique_ptr<signatured_type>> all_type_units;\n \n   /* Table of struct type_unit_group objects.\n      The hash key is the DW_AT_stmt_list value.  */\n@@ -425,16 +425,29 @@ struct dwarf2_psymtab : public partial_symtab\n \n struct dwarf2_per_cu_data\n {\n+  dwarf2_per_cu_data ()\n+    : queued (false),\n+      load_all_dies (false),\n+      is_debug_types (false),\n+      is_dwz (false),\n+      reading_dwo_directly (false),\n+      tu_read (false),\n+      m_header_read_in (false),\n+      unit_type {},\n+      lang (language_unknown)\n+  {\n+  }\n+\n   /* The start offset and length of this compilation unit.\n      NOTE: Unlike comp_unit_head.length, this length includes\n      initial_length_size.\n      If the DIE refers to a DWO file, this is always of the original die,\n      not the DWO file.  */\n-  sect_offset sect_off;\n-  unsigned int length;\n+  sect_offset sect_off {};\n+  unsigned int length = 0;\n \n   /* DWARF standard version this data has been read from (such as 4 or 5).  */\n-  unsigned char dwarf_version;\n+  unsigned char dwarf_version = 0;\n \n   /* Flag indicating this compilation unit will be read in before\n      any of the current compilation units are processed.  */\n@@ -483,15 +496,15 @@ struct dwarf2_per_cu_data\n   ENUM_BITFIELD (language) lang : LANGUAGE_BITS;\n \n   /* Our index in the unshared \"symtabs\" vector.  */\n-  unsigned index;\n+  unsigned index = 0;\n \n   /* The section this CU/TU lives in.\n      If the DIE refers to a DWO file, this is always the original die,\n      not the DWO file.  */\n-  struct dwarf2_section_info *section;\n+  struct dwarf2_section_info *section = nullptr;\n \n   /* Backlink to the owner of this.  */\n-  dwarf2_per_bfd *per_bfd;\n+  dwarf2_per_bfd *per_bfd = nullptr;\n \n   /* DWARF header of this CU.  Note that dwarf2_cu reads its own version of the\n      header, which may differ from this one, since it may pass rcuh_kind::TYPE\n@@ -500,7 +513,7 @@ struct dwarf2_per_cu_data\n \n      Don't access this field directly, use the get_header method instead.  It\n      should be private, but we can't make it private at the moment.  */\n-  mutable comp_unit_head m_header;\n+  mutable comp_unit_head m_header {};\n \n   /* When dwarf2_per_bfd::using_index is true, the 'quick' field\n      is active.  Otherwise, the 'psymtab' field is active.  */\n@@ -512,7 +525,7 @@ struct dwarf2_per_cu_data\n \n     /* Data needed by the \"quick\" functions.  */\n     struct dwarf2_per_cu_quick_data *quick;\n-  } v;\n+  } v {};\n \n   /* The CUs we import using DW_TAG_imported_unit.  This is filled in\n      while reading psymtabs, used to compute the psymtab dependencies,\n@@ -538,7 +551,7 @@ struct dwarf2_per_cu_data\n      could be refactored to make this private.  Until then please try to\n      avoid direct access to this member, and instead use the helper\n      functions above.  */\n-  std::vector <dwarf2_per_cu_data *> *imported_symtabs;\n+  std::vector <dwarf2_per_cu_data *> *imported_symtabs = nullptr;\n \n   /* Return true of IMPORTED_SYMTABS is empty or not yet allocated.  */\n   bool imported_symtabs_empty () const\n@@ -602,36 +615,30 @@ struct dwarf2_per_cu_data\n \n /* Entry in the signatured_types hash table.  */\n \n-struct signatured_type\n+struct signatured_type : public dwarf2_per_cu_data\n {\n-  /* The \"per_cu\" object of this type.\n-     This struct is used iff per_cu.is_debug_types.\n-     N.B.: This is the first member so that it's easy to convert pointers\n-     between them.  */\n-  struct dwarf2_per_cu_data per_cu;\n-\n   /* The type's signature.  */\n-  ULONGEST signature;\n+  ULONGEST signature = 0;\n \n   /* Offset in the TU of the type's DIE, as read from the TU header.\n      If this TU is a DWO stub and the definition lives in a DWO file\n      (specified by DW_AT_GNU_dwo_name), this value is unusable.  */\n-  cu_offset type_offset_in_tu;\n+  cu_offset type_offset_in_tu {};\n \n   /* Offset in the section of the type's DIE.\n      If the definition lives in a DWO file, this is the offset in the\n      .debug_types.dwo section.\n      The value is zero until the actual value is known.\n      Zero is otherwise not a valid section offset.  */\n-  sect_offset type_offset_in_section;\n+  sect_offset type_offset_in_section {};\n \n   /* Type units are grouped by their DW_AT_stmt_list entry so that they\n      can share them.  This points to the containing symtab.  */\n-  struct type_unit_group *type_unit_group;\n+  struct type_unit_group *type_unit_group = nullptr;\n \n   /* Containing DWO unit.\n      This field is valid iff per_cu.reading_dwo_directly.  */\n-  struct dwo_unit *dwo_unit;\n+  struct dwo_unit *dwo_unit = nullptr;\n };\n \n /* Return the type of the DIE at DIE_OFFSET in the CU named by"
    }
  ]
}