{
  "sha": "5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6NTk4OWE2NGVkNWVlN2E3ZjljMGZjMjg0ZjY2ZWY0YmQ0MTRhZDZjMg==",
  "commit": {
    "author": {
      "name": "Simon Marchi",
      "email": "simon.marchi@polymtl.ca",
      "date": "2020-05-27T15:13:50Z"
    },
    "committer": {
      "name": "Simon Marchi",
      "email": "simon.marchi@efficios.com",
      "date": "2020-05-27T15:13:50Z"
    },
    "message": "Split dwarf2_per_objfile into dwarf2_per_objfile and dwarf2_per_bfd\n\nThis is the first step of splitting dwarf2_per_objfile in two, one\nstructure for objfile-independent data (dwarf2_per_bfd) and one for\nobjfile-dependent data (dwarf2_per_objfile).\n\nThe existing dwarf2_per_objfile is renamed dwarf2_per_bfd, and a new\ndwarf2_per_objfile type is introduced, which sits \"in between\" the\nobjfile and dwarf2_per_bfd.\n\nSo where we had this before:\n\n  objfile -> dwarf2_per_objfile (*)\n\nwe now have this:\n\n  objfile -> dwarf2_per_objfile -> dwarf2_per_bfd (*)\n\n(*) Note that the dwarf2_per_objfile in the former corresponds to\nthe dwarf2_per_bfd in the latter.\n\nI've done the minimal amount of changes in this patch: following patches\nwill incrementally move things that are not actually shareable between\nobjfiles from dwarf2_per_bfd to dwarf2_per_objfile.\n\nMost references to dwarf2_per_objfile objects are changed to\ndwarf2_per_objfile->per_bfd.  To avoid many of these replacements, which\nwould have to be reverted later anyway, I've moved right away the\nobjfile backlink to the new dwarf2_per_objfile structure in this patch.\nI've also moved the read_line_string method, since it references the\nobjfile backlink, and it's actually not difficult to move.\n\nOnce the moves are completed, multiple dwarf2_per_objfile sharing the\nsame BFD will point to the same single instance of dwarf2_per_bfd (as\nlong as they don't require relocation).\n\ndwarf2_has_info, where we create these objects, is updated to the new\narchitecture.\n\nI've had to change the get_gdb_index_contents_ftype typedef and related\nfunctions.  The parameter type was changed from dwarf2_per_objfile to\ndwarf2_per_bfd, otherwise the template wouldn't work.\n\nPlease excuse the terse ChangeLog entry, I have not listed all the\nfunctions where dwarf2_per_objfile has been changed to\ndwarf2_per_objfile->per_bfd.  It would take a considerable amount of\ntime and would not really be useful in the end.\n\ngdb/ChangeLog:\n\n\t* dwarf2/read.h (dwarf2_per_objfile): Rename to dwarf2_per_bfd,\n\tthen introduce a new dwarf2_per_objfile type.\n\t<read_line_string>: Move to the new dwarf2_per_objfile type.\n\t<objfile>: Likewise.\n\t(dwarf2_per_bfd): Rename dwarf2_per_objfile to this.\n\t* dwarf2/read.c: Replace references to dwarf2_per_objfile with\n\tdwarf2_per_objfile->per_bfd.\n\t(dwarf2_per_objfile::dwarf2_per_objfile): Rename to...\n\t(dwarf2_per_bfd::dwarf2_per_bfd): ... this.\n\t(dwarf2_per_objfile::free_cached_comp_units): Rename to...\n\t(dwarf2_per_bfd::free_cached_comp_units): ... this.\n\t(dwarf2_has_info): Allocate dwarf2_per_bfd.\n\t(dwarf2_per_objfile::locate_sections): Rename to...\n\t(dwarf2_per_bfd::locate_sections): ... this.\n\t(dwarf2_per_objfile::get_cutu): Rename to...\n\t(dwarf2_per_bfd::get_cutu): ... this.\n\t(dwarf2_per_objfile::get_cu): Rename to...\n\t(dwarf2_per_bfd::get_cu): ... this.\n\t(dwarf2_per_objfile::get_tu): Rename to...\n\t(dwarf2_per_bfd::get_tu): ... this.\n\t(dwarf2_per_objfile::allocate_per_cu): Rename to...\n\t(dwarf2_per_bfd::allocate_per_cu): ... this.\n\t(dwarf2_per_objfile::allocate_signatured_type): Rename to...\n\t(dwarf2_per_bfd::allocate_signatured_type): ... this.\n\t(get_gdb_index_contents_ftype): Change parameter from\n\tdwarf2_per_objfile to dwarf2_per_bfd.\n\t* dwarf2/macro.c, dwarf2/index-write.c: Replace references to\n\tdwarf2_per_objfile with dwarf2_per_objfile->per_bfd.\n\nChange-Id: I7de7b5d1ce7494aa73bfcf15f719d3c5c46e138c",
    "tree": {
      "sha": "05eb62aa376ad62ee07e410364b8bfdc4caf96de",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/05eb62aa376ad62ee07e410364b8bfdc4caf96de"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/comments",
  "author": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "simark",
    "id": 1758287,
    "node_id": "MDQ6VXNlcjE3NTgyODc=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1758287?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/simark",
    "html_url": "https://github.com/simark",
    "followers_url": "https://api.github.com/users/simark/followers",
    "following_url": "https://api.github.com/users/simark/following{/other_user}",
    "gists_url": "https://api.github.com/users/simark/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/simark/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/simark/subscriptions",
    "organizations_url": "https://api.github.com/users/simark/orgs",
    "repos_url": "https://api.github.com/users/simark/repos",
    "events_url": "https://api.github.com/users/simark/events{/privacy}",
    "received_events_url": "https://api.github.com/users/simark/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "a50264baf57716993e701096fa6e466fb63e0301",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/a50264baf57716993e701096fa6e466fb63e0301",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/a50264baf57716993e701096fa6e466fb63e0301"
    }
  ],
  "stats": {
    "total": 774,
    "additions": 412,
    "deletions": 362
  },
  "files": [
    {
      "sha": "bb51c6d2f930dbb13dc8fb23c1342c5d58ade12c",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
      "patch": "@@ -1,3 +1,34 @@\n+2020-05-27  Simon Marchi  <simon.marchi@polymtl.ca>\n+\n+\t* dwarf2/read.h (dwarf2_per_objfile): Rename to dwarf2_per_bfd,\n+\tthen introduce a new dwarf2_per_objfile type.\n+\t<read_line_string>: Move to the new dwarf2_per_objfile type.\n+\t<objfile>: Likewise.\n+\t(dwarf2_per_bfd): Rename dwarf2_per_objfile to this.\n+\t* dwarf2/read.c: Replace references to dwarf2_per_objfile with\n+\tdwarf2_per_objfile->per_bfd.\n+\t(dwarf2_per_objfile::dwarf2_per_objfile): Rename to...\n+\t(dwarf2_per_bfd::dwarf2_per_bfd): ... this.\n+\t(dwarf2_per_objfile::free_cached_comp_units): Rename to...\n+\t(dwarf2_per_bfd::free_cached_comp_units): ... this.\n+\t(dwarf2_has_info): Allocate dwarf2_per_bfd.\n+\t(dwarf2_per_objfile::locate_sections): Rename to...\n+\t(dwarf2_per_bfd::locate_sections): ... this.\n+\t(dwarf2_per_objfile::get_cutu): Rename to...\n+\t(dwarf2_per_bfd::get_cutu): ... this.\n+\t(dwarf2_per_objfile::get_cu): Rename to...\n+\t(dwarf2_per_bfd::get_cu): ... this.\n+\t(dwarf2_per_objfile::get_tu): Rename to...\n+\t(dwarf2_per_bfd::get_tu): ... this.\n+\t(dwarf2_per_objfile::allocate_per_cu): Rename to...\n+\t(dwarf2_per_bfd::allocate_per_cu): ... this.\n+\t(dwarf2_per_objfile::allocate_signatured_type): Rename to...\n+\t(dwarf2_per_bfd::allocate_signatured_type): ... this.\n+\t(get_gdb_index_contents_ftype): Change parameter from\n+\tdwarf2_per_objfile to dwarf2_per_bfd.\n+\t* dwarf2/macro.c, dwarf2/index-write.c: Replace references to\n+\tdwarf2_per_objfile with dwarf2_per_objfile->per_bfd.\n+\n 2020-05-27  Tom Tromey  <tom@tromey.com>\n \t    Simon Marchi  <simon.marchi@efficios.com>\n "
    },
    {
      "sha": "a9c665165c7c2822570db6a59cbc31dc99f9456d",
      "filename": "gdb/dwarf2/index-write.c",
      "status": "modified",
      "additions": 24,
      "deletions": 24,
      "changes": 48,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/dwarf2/index-write.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/dwarf2/index-write.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/index-write.c?ref=5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
      "patch": "@@ -961,17 +961,17 @@ class debug_names\n       : m_abfd (dwarf2_per_objfile->objfile->obfd),\n \tm_dwarf2_per_objfile (dwarf2_per_objfile)\n     {\n-      dwarf2_per_objfile->str.read (dwarf2_per_objfile->objfile);\n-      if (dwarf2_per_objfile->str.buffer == NULL)\n+      dwarf2_per_objfile->per_bfd->str.read (dwarf2_per_objfile->objfile);\n+      if (dwarf2_per_objfile->per_bfd->str.buffer == NULL)\n \treturn;\n-      for (const gdb_byte *data = dwarf2_per_objfile->str.buffer;\n-\t   data < (dwarf2_per_objfile->str.buffer\n-\t\t   + dwarf2_per_objfile->str.size);)\n+      for (const gdb_byte *data = dwarf2_per_objfile->per_bfd->str.buffer;\n+\t   data < (dwarf2_per_objfile->per_bfd->str.buffer\n+\t\t   + dwarf2_per_objfile->per_bfd->str.size);)\n \t{\n \t  const char *const s = reinterpret_cast<const char *> (data);\n \t  const auto insertpair\n \t    = m_str_table.emplace (c_str_view (s),\n-\t\t\t\t   data - dwarf2_per_objfile->str.buffer);\n+\t\t\t\t   data - dwarf2_per_objfile->per_bfd->str.buffer);\n \t  if (!insertpair.second)\n \t    complaint (_(\"Duplicate string \\\"%s\\\" in \"\n \t\t\t \".debug_str section [in module %s]\"),\n@@ -988,7 +988,7 @@ class debug_names\n       const auto it = m_str_table.find (c_str_view (s));\n       if (it != m_str_table.end ())\n \treturn it->second;\n-      const size_t offset = (m_dwarf2_per_objfile->str.size\n+      const size_t offset = (m_dwarf2_per_objfile->per_bfd->str.size\n \t\t\t     + m_str_add_buf.size ());\n       m_str_table.emplace (c_str_view (s), offset);\n       m_str_add_buf.append_cstr0 (s);\n@@ -1296,12 +1296,12 @@ class debug_names\n static bool\n check_dwarf64_offsets (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       if (to_underlying (per_cu->sect_off) >= (static_cast<uint64_t> (1) << 32))\n \treturn true;\n     }\n-  for (const signatured_type *sigtype : dwarf2_per_objfile->all_type_units)\n+  for (const signatured_type *sigtype : dwarf2_per_objfile->per_bfd->all_type_units)\n     {\n       const dwarf2_per_cu_data &per_cu = sigtype->per_cu;\n \n@@ -1321,7 +1321,7 @@ static size_t\n psyms_seen_size (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n   size_t psyms_count = 0;\n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n@@ -1414,18 +1414,18 @@ write_gdbindex (struct dwarf2_per_objfile *dwarf2_per_objfile, FILE *out_file,\n      in the index file).  This will later be needed to write the address\n      table.  */\n   psym_index_map cu_index_htab;\n-  cu_index_htab.reserve (dwarf2_per_objfile->all_comp_units.size ());\n+  cu_index_htab.reserve (dwarf2_per_objfile->per_bfd->all_comp_units.size ());\n \n   /* The CU list is already sorted, so we don't need to do additional\n      work here.  Also, the debug_types entries do not appear in\n      all_comp_units, but only in their own hash table.  */\n \n   std::unordered_set<partial_symbol *> psyms_seen\n     (psyms_seen_size (dwarf2_per_objfile));\n-  for (int i = 0; i < dwarf2_per_objfile->all_comp_units.size (); ++i)\n+  for (int i = 0; i < dwarf2_per_objfile->per_bfd->all_comp_units.size (); ++i)\n     {\n       struct dwarf2_per_cu_data *per_cu\n-\t= dwarf2_per_objfile->all_comp_units[i];\n+\t= dwarf2_per_objfile->per_bfd->all_comp_units[i];\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n       if (psymtab != NULL)\n@@ -1453,15 +1453,15 @@ write_gdbindex (struct dwarf2_per_objfile *dwarf2_per_objfile, FILE *out_file,\n \n   /* Write out the .debug_type entries, if any.  */\n   data_buf types_cu_list;\n-  if (dwarf2_per_objfile->signatured_types)\n+  if (dwarf2_per_objfile->per_bfd->signatured_types)\n     {\n       signatured_type_index_data sig_data (types_cu_list,\n \t\t\t\t\t   psyms_seen);\n \n       sig_data.objfile = objfile;\n       sig_data.symtab = &symtab;\n-      sig_data.cu_index = dwarf2_per_objfile->all_comp_units.size ();\n-      htab_traverse_noresize (dwarf2_per_objfile->signatured_types.get (),\n+      sig_data.cu_index = dwarf2_per_objfile->per_bfd->all_comp_units.size ();\n+      htab_traverse_noresize (dwarf2_per_objfile->per_bfd->signatured_types.get (),\n \t\t\t      write_one_signatured_type, &sig_data);\n     }\n \n@@ -1505,9 +1505,9 @@ write_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\t dwarf5_byte_order);\n   std::unordered_set<partial_symbol *>\n     psyms_seen (psyms_seen_size (dwarf2_per_objfile));\n-  for (int i = 0; i < dwarf2_per_objfile->all_comp_units.size (); ++i)\n+  for (int i = 0; i < dwarf2_per_objfile->per_bfd->all_comp_units.size (); ++i)\n     {\n-      const dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->all_comp_units[i];\n+      const dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->per_bfd->all_comp_units[i];\n       partial_symtab *psymtab = per_cu->v.psymtab;\n \n       /* CU of a shared file from 'dwz -m' may be unused by this main\n@@ -1525,7 +1525,7 @@ write_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   /* Write out the .debug_type entries, if any.  */\n   data_buf types_cu_list;\n-  if (dwarf2_per_objfile->signatured_types)\n+  if (dwarf2_per_objfile->per_bfd->signatured_types)\n     {\n       debug_names::write_one_signatured_type_data sig_data (nametable,\n \t\t\tsignatured_type_index_data (types_cu_list, psyms_seen));\n@@ -1534,7 +1534,7 @@ write_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       /* It is used only for gdb_index.  */\n       sig_data.info.symtab = nullptr;\n       sig_data.info.cu_index = 0;\n-      htab_traverse_noresize (dwarf2_per_objfile->signatured_types.get (),\n+      htab_traverse_noresize (dwarf2_per_objfile->per_bfd->signatured_types.get (),\n \t\t\t      debug_names::write_one_signatured_type,\n \t\t\t      &sig_data);\n     }\n@@ -1574,12 +1574,12 @@ write_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   /* comp_unit_count - The number of CUs in the CU list.  */\n   header.append_uint (4, dwarf5_byte_order,\n-\t\t      dwarf2_per_objfile->all_comp_units.size ());\n+\t\t      dwarf2_per_objfile->per_bfd->all_comp_units.size ());\n \n   /* local_type_unit_count - The number of TUs in the local TU\n      list.  */\n   header.append_uint (4, dwarf5_byte_order,\n-\t\t      dwarf2_per_objfile->all_type_units.size ());\n+\t\t      dwarf2_per_objfile->per_bfd->all_type_units.size ());\n \n   /* foreign_type_unit_count - The number of TUs in the foreign TU\n      list.  */\n@@ -1676,10 +1676,10 @@ write_psymtabs_to_index (struct dwarf2_per_objfile *dwarf2_per_objfile,\n {\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n \n-  if (dwarf2_per_objfile->using_index)\n+  if (dwarf2_per_objfile->per_bfd->using_index)\n     error (_(\"Cannot use an index to create the index\"));\n \n-  if (dwarf2_per_objfile->types.size () > 1)\n+  if (dwarf2_per_objfile->per_bfd->types.size () > 1)\n     error (_(\"Cannot make an index when the file has multiple .debug_types sections\"));\n \n   if (!objfile->partial_symtabs->psymtabs"
    },
    {
      "sha": "c2580193205cebcf4ee2e346a23d5aa6633fb367",
      "filename": "gdb/dwarf2/macro.c",
      "status": "modified",
      "additions": 3,
      "deletions": 3,
      "changes": 6,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/dwarf2/macro.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/dwarf2/macro.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/macro.c?ref=5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
      "patch": "@@ -512,9 +512,9 @@ dwarf_decode_macro_bytes (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t    body = dwz->read_string (objfile, str_offset);\n \t\t  }\n \t\telse\n-\t\t  body = dwarf2_per_objfile->str.read_string (objfile,\n-\t\t\t\t\t\t\t      str_offset,\n-\t\t\t\t\t\t\t      \"DW_FORM_strp\");\n+\t\t  body = dwarf2_per_objfile->per_bfd->str.read_string (objfile,\n+\t\t\t\t\t\t\t\t       str_offset,\n+\t\t\t\t\t\t\t\t       \"DW_FORM_strp\");\n \t      }\n \n \t    is_define = (macinfo_type == DW_MACRO_define"
    },
    {
      "sha": "b2734dbee93f47e965b777406784a645e5964828",
      "filename": "gdb/dwarf2/read.c",
      "status": "modified",
      "additions": 310,
      "deletions": 310,
      "changes": 620,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/dwarf2/read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/dwarf2/read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.c?ref=5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
      "patch": "@@ -484,7 +484,7 @@ struct dwarf2_cu\n   /* Header data from the line table, during full symbol processing.  */\n   struct line_header *line_header = nullptr;\n   /* Non-NULL if LINE_HEADER is owned by this DWARF_CU.  Otherwise,\n-     it's owned by dwarf2_per_objfile::line_header_hash.  If non-NULL,\n+     it's owned by dwarf2_per_bfd::line_header_hash.  If non-NULL,\n      this is the DW_TAG_compile_unit die for this CU.  We'll hold on\n      to the line header as long as this DIE is being processed.  See\n      process_die_scope.  */\n@@ -599,7 +599,7 @@ struct stmt_list_hash\n   sect_offset line_sect_off;\n };\n \n-/* Each element of dwarf2_per_objfile->type_unit_groups is a pointer to\n+/* Each element of dwarf2_per_bfd->type_unit_groups is a pointer to\n    an object of this type.  */\n \n struct type_unit_group\n@@ -1602,7 +1602,7 @@ class dwarf2_queue_guard\n   {\n     /* Ensure that no memory is allocated by the queue.  */\n     std::queue<dwarf2_queue_item> empty;\n-    std::swap (m_per_objfile->queue, empty);\n+    std::swap (m_per_objfile->per_bfd->queue, empty);\n   }\n \n   DISABLE_COPY_AND_ASSIGN (dwarf2_queue_guard);\n@@ -1745,22 +1745,18 @@ line_header_eq_voidp (const void *item_lhs, const void *item_rhs)\n \n /* See declaration.  */\n \n-dwarf2_per_objfile::dwarf2_per_objfile (struct objfile *objfile_,\n-\t\t\t\t\tconst dwarf2_debug_sections *names,\n-\t\t\t\t\tbool can_copy_)\n-  : objfile (objfile_),\n-    can_copy (can_copy_)\n+dwarf2_per_bfd::dwarf2_per_bfd (bfd *obfd, const dwarf2_debug_sections *names,\n+\t\t\t\tbool can_copy_)\n+  : can_copy (can_copy_)\n {\n   if (names == NULL)\n     names = &dwarf2_elf_names;\n \n-  bfd *obfd = objfile->obfd;\n-\n   for (asection *sec = obfd->sections; sec != NULL; sec = sec->next)\n     locate_sections (obfd, sec, *names);\n }\n \n-dwarf2_per_objfile::~dwarf2_per_objfile ()\n+dwarf2_per_bfd::~dwarf2_per_bfd ()\n {\n   /* Cached DIE trees use xmalloc and the comp_unit_obstack.  */\n   free_cached_comp_units ();\n@@ -1771,13 +1767,13 @@ dwarf2_per_objfile::~dwarf2_per_objfile ()\n   for (signatured_type *sig_type : all_type_units)\n     sig_type->per_cu.imported_symtabs_free ();\n \n-  /* Everything else should be on the objfile obstack.  */\n+  /* Everything else should be on this->obstack.  */\n }\n \n /* See declaration.  */\n \n void\n-dwarf2_per_objfile::free_cached_comp_units ()\n+dwarf2_per_bfd::free_cached_comp_units ()\n {\n   dwarf2_per_cu_data *per_cu = read_in_chain;\n   dwarf2_per_cu_data **last_chain = &read_in_chain;\n@@ -1805,7 +1801,7 @@ class free_cached_comp_units\n \n   ~free_cached_comp_units ()\n   {\n-    m_per_objfile->free_cached_comp_units ();\n+    m_per_objfile->per_bfd->free_cached_comp_units ();\n   }\n \n   DISABLE_COPY_AND_ASSIGN (free_cached_comp_units);\n@@ -1834,14 +1830,18 @@ dwarf2_has_info (struct objfile *objfile,\n     = get_dwarf2_per_objfile (objfile);\n \n   if (dwarf2_per_objfile == NULL)\n-    dwarf2_per_objfile = dwarf2_objfile_data_key.emplace (objfile, objfile,\n-\t\t\t\t\t\t\t  names,\n-\t\t\t\t\t\t\t  can_copy);\n+    {\n+      /* For now, each dwarf2_per_objfile owns its own dwarf2_per_bfd (no\n+         sharing yet).  */\n+      dwarf2_per_bfd *per_bfd = new dwarf2_per_bfd (objfile->obfd, names, can_copy);\n+\n+      dwarf2_per_objfile = dwarf2_objfile_data_key.emplace (objfile, objfile, per_bfd);\n+    }\n \n-  return (!dwarf2_per_objfile->info.is_virtual\n-\t  && dwarf2_per_objfile->info.s.section != NULL\n-\t  && !dwarf2_per_objfile->abbrev.is_virtual\n-\t  && dwarf2_per_objfile->abbrev.s.section != NULL);\n+  return (!dwarf2_per_objfile->per_bfd->info.is_virtual\n+\t  && dwarf2_per_objfile->per_bfd->info.s.section != NULL\n+\t  && !dwarf2_per_objfile->per_bfd->abbrev.is_virtual\n+\t  && dwarf2_per_objfile->per_bfd->abbrev.s.section != NULL);\n }\n \n /* When loading sections, we look either for uncompressed section or for\n@@ -1863,8 +1863,8 @@ section_is_p (const char *section_name,\n /* See declaration.  */\n \n void\n-dwarf2_per_objfile::locate_sections (bfd *abfd, asection *sectp,\n-\t\t\t\t     const dwarf2_debug_sections &names)\n+dwarf2_per_bfd::locate_sections (bfd *abfd, asection *sectp,\n+\t\t\t\t const dwarf2_debug_sections &names)\n {\n   flagword aflag = bfd_section_flags (sectp);\n \n@@ -2010,10 +2010,10 @@ dwarf2_get_section_info (struct objfile *objfile,\n   switch (sect)\n     {\n     case DWARF2_DEBUG_FRAME:\n-      info = &data->frame;\n+      info = &data->per_bfd->frame;\n       break;\n     case DWARF2_EH_FRAME:\n-      info = &data->eh_frame;\n+      info = &data->per_bfd->eh_frame;\n       break;\n     default:\n       gdb_assert_not_reached (\"unexpected section\");\n@@ -2082,8 +2082,8 @@ dwarf2_get_dwz_file (struct dwarf2_per_objfile *dwarf2_per_objfile)\n   size_t buildid_len;\n   bfd_byte *buildid;\n \n-  if (dwarf2_per_objfile->dwz_file != NULL)\n-    return dwarf2_per_objfile->dwz_file.get ();\n+  if (dwarf2_per_objfile->per_bfd->dwz_file != NULL)\n+    return dwarf2_per_objfile->per_bfd->dwz_file.get ();\n \n   bfd_set_error (bfd_error_no_error);\n   gdb::unique_xmalloc_ptr<char> data\n@@ -2160,8 +2160,8 @@ dwarf2_get_dwz_file (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \n   gdb_bfd_record_inclusion (dwarf2_per_objfile->objfile->obfd,\n \t\t\t    result->dwz_bfd.get ());\n-  dwarf2_per_objfile->dwz_file = std::move (result);\n-  return dwarf2_per_objfile->dwz_file.get ();\n+  dwarf2_per_objfile->per_bfd->dwz_file = std::move (result);\n+  return dwarf2_per_objfile->per_bfd->dwz_file.get ();\n }\n \f\n /* DWARF quick_symbols_functions support.  */\n@@ -2195,7 +2195,7 @@ struct dwarf2_per_cu_quick_data\n {\n   /* The file table.  This can be NULL if there was no file table\n      or it's currently not read in.\n-     NOTE: This points into dwarf2_per_objfile->quick_file_names_table.  */\n+     NOTE: This points into dwarf2_per_objfile->per_bfd->quick_file_names_table.  */\n   struct quick_file_names *file_names;\n \n   /* The corresponding symbol table.  This is NULL if symbols for this\n@@ -2325,7 +2325,7 @@ dw2_do_instantiate_symtab (struct dwarf2_per_cu_data *per_cu, bool skip_partial)\n      with the dwarf queue empty.  */\n   dwarf2_queue_guard q_guard (dwarf2_per_objfile);\n \n-  if (dwarf2_per_objfile->using_index\n+  if (dwarf2_per_objfile->per_bfd->using_index\n       ? per_cu->v.quick->compunit_symtab == NULL\n       : (per_cu->v.psymtab == NULL || !per_cu->v.psymtab->readin))\n     {\n@@ -2338,8 +2338,8 @@ dw2_do_instantiate_symtab (struct dwarf2_per_cu_data *per_cu, bool skip_partial)\n       if (!per_cu->is_debug_types\n \t  && per_cu->cu != NULL\n \t  && per_cu->cu->dwo_unit != NULL\n-\t  && dwarf2_per_objfile->index_table != NULL\n-\t  && dwarf2_per_objfile->index_table->version <= 7\n+\t  && dwarf2_per_objfile->per_bfd->index_table != NULL\n+\t  && dwarf2_per_objfile->per_bfd->index_table->version <= 7\n \t  /* DWP files aren't supported yet.  */\n \t  && get_dwp_file (dwarf2_per_objfile) == NULL)\n \tqueue_and_load_all_dwo_tus (per_cu);\n@@ -2361,7 +2361,7 @@ dw2_instantiate_symtab (struct dwarf2_per_cu_data *per_cu, bool skip_partial)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile = per_cu->dwarf2_per_objfile;\n \n-  gdb_assert (dwarf2_per_objfile->using_index);\n+  gdb_assert (dwarf2_per_objfile->per_bfd->using_index);\n   if (!per_cu->v.quick->compunit_symtab)\n     {\n       free_cached_comp_units freer (dwarf2_per_objfile);\n@@ -2376,7 +2376,7 @@ dw2_instantiate_symtab (struct dwarf2_per_cu_data *per_cu, bool skip_partial)\n /* See declaration.  */\n \n dwarf2_per_cu_data *\n-dwarf2_per_objfile::get_cutu (int index)\n+dwarf2_per_bfd::get_cutu (int index)\n {\n   if (index >= this->all_comp_units.size ())\n     {\n@@ -2391,7 +2391,7 @@ dwarf2_per_objfile::get_cutu (int index)\n /* See declaration.  */\n \n dwarf2_per_cu_data *\n-dwarf2_per_objfile::get_cu (int index)\n+dwarf2_per_bfd::get_cu (int index)\n {\n   gdb_assert (index >= 0 && index < this->all_comp_units.size ());\n \n@@ -2401,7 +2401,7 @@ dwarf2_per_objfile::get_cu (int index)\n /* See declaration.  */\n \n signatured_type *\n-dwarf2_per_objfile::get_tu (int index)\n+dwarf2_per_bfd::get_tu (int index)\n {\n   gdb_assert (index >= 0 && index < this->all_type_units.size ());\n \n@@ -2411,7 +2411,7 @@ dwarf2_per_objfile::get_tu (int index)\n /* See read.h.  */\n \n dwarf2_per_cu_data *\n-dwarf2_per_objfile::allocate_per_cu ()\n+dwarf2_per_bfd::allocate_per_cu ()\n {\n   dwarf2_per_cu_data *result = OBSTACK_ZALLOC (&obstack, dwarf2_per_cu_data);\n   result->index = m_num_psymtabs++;\n@@ -2421,7 +2421,7 @@ dwarf2_per_objfile::allocate_per_cu ()\n /* See read.h.  */\n \n signatured_type *\n-dwarf2_per_objfile::allocate_signatured_type ()\n+dwarf2_per_bfd::allocate_signatured_type ()\n {\n   signatured_type *result = OBSTACK_ZALLOC (&obstack, signatured_type);\n   result->per_cu.index = m_num_psymtabs++;\n@@ -2437,12 +2437,12 @@ create_cu_from_index_list (struct dwarf2_per_objfile *dwarf2_per_objfile,\n                           int is_dwz,\n                           sect_offset sect_off, ULONGEST length)\n {\n-  dwarf2_per_cu_data *the_cu = dwarf2_per_objfile->allocate_per_cu ();\n+  dwarf2_per_cu_data *the_cu = dwarf2_per_objfile->per_bfd->allocate_per_cu ();\n   the_cu->sect_off = sect_off;\n   the_cu->length = length;\n   the_cu->dwarf2_per_objfile = dwarf2_per_objfile;\n   the_cu->section = section;\n-  the_cu->v.quick = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+  the_cu->v.quick = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t\t    struct dwarf2_per_cu_quick_data);\n   the_cu->is_dwz = is_dwz;\n   return the_cu;\n@@ -2469,7 +2469,7 @@ create_cus_from_index_list (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       dwarf2_per_cu_data *per_cu\n \t= create_cu_from_index_list (dwarf2_per_objfile, section, is_dwz,\n \t\t\t\t     sect_off, length);\n-      dwarf2_per_objfile->all_comp_units.push_back (per_cu);\n+      dwarf2_per_objfile->per_bfd->all_comp_units.push_back (per_cu);\n     }\n }\n \n@@ -2481,12 +2481,12 @@ create_cus_from_index (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t       const gdb_byte *cu_list, offset_type cu_list_elements,\n \t\t       const gdb_byte *dwz_list, offset_type dwz_elements)\n {\n-  gdb_assert (dwarf2_per_objfile->all_comp_units.empty ());\n-  dwarf2_per_objfile->all_comp_units.reserve\n+  gdb_assert (dwarf2_per_objfile->per_bfd->all_comp_units.empty ());\n+  dwarf2_per_objfile->per_bfd->all_comp_units.reserve\n     ((cu_list_elements + dwz_elements) / 2);\n \n   create_cus_from_index_list (dwarf2_per_objfile, cu_list, cu_list_elements,\n-\t\t\t      &dwarf2_per_objfile->info, 0);\n+\t\t\t      &dwarf2_per_objfile->per_bfd->info, 0);\n \n   if (dwz_elements == 0)\n     return;\n@@ -2505,8 +2505,8 @@ create_signatured_type_table_from_index\n    const gdb_byte *bytes,\n    offset_type elements)\n {\n-  gdb_assert (dwarf2_per_objfile->all_type_units.empty ());\n-  dwarf2_per_objfile->all_type_units.reserve (elements / 3);\n+  gdb_assert (dwarf2_per_objfile->per_bfd->all_type_units.empty ());\n+  dwarf2_per_objfile->per_bfd->all_type_units.reserve (elements / 3);\n \n   htab_up sig_types_hash = allocate_signatured_type_table ();\n \n@@ -2526,24 +2526,24 @@ create_signatured_type_table_from_index\n       signature = extract_unsigned_integer (bytes + 16, 8, BFD_ENDIAN_LITTLE);\n       bytes += 3 * 8;\n \n-      sig_type = dwarf2_per_objfile->allocate_signatured_type ();\n+      sig_type = dwarf2_per_objfile->per_bfd->allocate_signatured_type ();\n       sig_type->signature = signature;\n       sig_type->type_offset_in_tu = type_offset_in_tu;\n       sig_type->per_cu.is_debug_types = 1;\n       sig_type->per_cu.section = section;\n       sig_type->per_cu.sect_off = sect_off;\n       sig_type->per_cu.dwarf2_per_objfile = dwarf2_per_objfile;\n       sig_type->per_cu.v.quick\n-\t= OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+\t= OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t  struct dwarf2_per_cu_quick_data);\n \n       slot = htab_find_slot (sig_types_hash.get (), sig_type, INSERT);\n       *slot = sig_type;\n \n-      dwarf2_per_objfile->all_type_units.push_back (sig_type);\n+      dwarf2_per_objfile->per_bfd->all_type_units.push_back (sig_type);\n     }\n \n-  dwarf2_per_objfile->signatured_types = std::move (sig_types_hash);\n+  dwarf2_per_objfile->per_bfd->signatured_types = std::move (sig_types_hash);\n }\n \n /* Create the signatured type hash table from .debug_names.  */\n@@ -2560,8 +2560,8 @@ create_signatured_type_table_from_debug_names\n   section->read (objfile);\n   abbrev_section->read (objfile);\n \n-  gdb_assert (dwarf2_per_objfile->all_type_units.empty ());\n-  dwarf2_per_objfile->all_type_units.reserve (map.tu_count);\n+  gdb_assert (dwarf2_per_objfile->per_bfd->all_type_units.empty ());\n+  dwarf2_per_objfile->per_bfd->all_type_units.reserve (map.tu_count);\n \n   htab_up sig_types_hash = allocate_signatured_type_table ();\n \n@@ -2582,24 +2582,24 @@ create_signatured_type_table_from_debug_names\n \t\t\t\t     section->buffer + to_underlying (sect_off),\n \t\t\t\t     rcuh_kind::TYPE);\n \n-      sig_type = dwarf2_per_objfile->allocate_signatured_type ();\n+      sig_type = dwarf2_per_objfile->per_bfd->allocate_signatured_type ();\n       sig_type->signature = cu_header.signature;\n       sig_type->type_offset_in_tu = cu_header.type_cu_offset_in_tu;\n       sig_type->per_cu.is_debug_types = 1;\n       sig_type->per_cu.section = section;\n       sig_type->per_cu.sect_off = sect_off;\n       sig_type->per_cu.dwarf2_per_objfile = dwarf2_per_objfile;\n       sig_type->per_cu.v.quick\n-\t= OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+\t= OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t  struct dwarf2_per_cu_quick_data);\n \n       slot = htab_find_slot (sig_types_hash.get (), sig_type, INSERT);\n       *slot = sig_type;\n \n-      dwarf2_per_objfile->all_type_units.push_back (sig_type);\n+      dwarf2_per_objfile->per_bfd->all_type_units.push_back (sig_type);\n     }\n \n-  dwarf2_per_objfile->signatured_types = std::move (sig_types_hash);\n+  dwarf2_per_objfile->per_bfd->signatured_types = std::move (sig_types_hash);\n }\n \n /* Read the address map data from the mapped index, and use it to\n@@ -2641,7 +2641,7 @@ create_addrmap_from_index (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t  continue;\n \t}\n \n-      if (cu_index >= dwarf2_per_objfile->all_comp_units.size ())\n+      if (cu_index >= dwarf2_per_objfile->per_bfd->all_comp_units.size ())\n \t{\n \t  complaint (_(\".gdb_index address table has invalid CU number %u\"),\n \t\t     (unsigned) cu_index);\n@@ -2651,7 +2651,7 @@ create_addrmap_from_index (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       lo = gdbarch_adjust_dwarf2_addr (gdbarch, lo + baseaddr) - baseaddr;\n       hi = gdbarch_adjust_dwarf2_addr (gdbarch, hi + baseaddr) - baseaddr;\n       addrmap_set_empty (mutable_map, lo, hi - 1,\n-\t\t\t dwarf2_per_objfile->get_cu (cu_index));\n+\t\t\t dwarf2_per_objfile->per_bfd->get_cu (cu_index));\n     }\n \n   objfile->partial_symtabs->psymtabs_addrmap\n@@ -2677,7 +2677,7 @@ create_addrmap_from_aranges (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t     dwarf2_per_cu_data *,\n \t\t     gdb::hash_enum<sect_offset>>\n     debug_info_offset_to_per_cu;\n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       const auto insertpair\n \t= debug_info_offset_to_per_cu.emplace (per_cu->sect_off, per_cu);\n@@ -2805,7 +2805,7 @@ create_addrmap_from_aranges (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t  addr += address_size;\n \t  if (start == 0 && length == 0)\n \t    break;\n-\t  if (start == 0 && !dwarf2_per_objfile->has_section_at_zero)\n+\t  if (start == 0 && !dwarf2_per_objfile->per_bfd->has_section_at_zero)\n \t    {\n \t      /* Symbol was eliminated due to a COMDAT group.  */\n \t      continue;\n@@ -2998,7 +2998,7 @@ to use the section anyway.\"),\n /* Callback types for dwarf2_read_gdb_index.  */\n \n typedef gdb::function_view\n-    <gdb::array_view<const gdb_byte>(objfile *, dwarf2_per_objfile *)>\n+    <gdb::array_view<const gdb_byte>(objfile *, dwarf2_per_bfd *)>\n     get_gdb_index_contents_ftype;\n typedef gdb::function_view\n     <gdb::array_view<const gdb_byte>(objfile *, dwz_file *)>\n@@ -3019,7 +3019,7 @@ dwarf2_read_gdb_index\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n \n   gdb::array_view<const gdb_byte> main_index_contents\n-    = get_gdb_index_contents (objfile, dwarf2_per_objfile);\n+    = get_gdb_index_contents (objfile, dwarf2_per_objfile->per_bfd);\n \n   if (main_index_contents.empty ())\n     return 0;\n@@ -3070,21 +3070,21 @@ dwarf2_read_gdb_index\n     {\n       /* We can only handle a single .debug_types when we have an\n \t index.  */\n-      if (dwarf2_per_objfile->types.size () != 1)\n+      if (dwarf2_per_objfile->per_bfd->types.size () != 1)\n \treturn 0;\n \n-      dwarf2_section_info *section = &dwarf2_per_objfile->types[0];\n+      dwarf2_section_info *section = &dwarf2_per_objfile->per_bfd->types[0];\n \n       create_signatured_type_table_from_index (dwarf2_per_objfile, section,\n \t\t\t\t\t       types_list, types_list_elements);\n     }\n \n   create_addrmap_from_index (dwarf2_per_objfile, map.get ());\n \n-  dwarf2_per_objfile->index_table = std::move (map);\n-  dwarf2_per_objfile->using_index = 1;\n-  dwarf2_per_objfile->quick_file_names_table =\n-    create_quick_file_names_table (dwarf2_per_objfile->all_comp_units.size ());\n+  dwarf2_per_objfile->per_bfd->index_table = std::move (map);\n+  dwarf2_per_objfile->per_bfd->using_index = 1;\n+  dwarf2_per_objfile->per_bfd->quick_file_names_table =\n+    create_quick_file_names_table (dwarf2_per_objfile->per_bfd->all_comp_units.size ());\n \n   return 1;\n }\n@@ -3132,7 +3132,7 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n \t If we have we're done.  */\n       find_entry.hash.dwo_unit = cu->dwo_unit;\n       find_entry.hash.line_sect_off = line_offset;\n-      slot = htab_find_slot (dwarf2_per_objfile->quick_file_names_table.get (),\n+      slot = htab_find_slot (dwarf2_per_objfile->per_bfd->quick_file_names_table.get (),\n \t\t\t     &find_entry, INSERT);\n       if (*slot != NULL)\n \t{\n@@ -3148,7 +3148,7 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n       return;\n     }\n \n-  qfn = XOBNEW (&dwarf2_per_objfile->obstack, struct quick_file_names);\n+  qfn = XOBNEW (&dwarf2_per_objfile->per_bfd->obstack, struct quick_file_names);\n   qfn->hash.dwo_unit = cu->dwo_unit;\n   qfn->hash.line_sect_off = line_offset;\n   gdb_assert (slot != NULL);\n@@ -3162,7 +3162,7 @@ dw2_get_file_names_reader (const struct die_reader_specs *reader,\n \n   qfn->num_file_names = offset + lh->file_names_size ();\n   qfn->file_names =\n-    XOBNEWVEC (&dwarf2_per_objfile->obstack, const char *,\n+    XOBNEWVEC (&dwarf2_per_objfile->per_bfd->obstack, const char *,\n \t       qfn->num_file_names);\n   if (offset != 0)\n     qfn->file_names[0] = xstrdup (fnd.name);\n@@ -3208,7 +3208,7 @@ dw2_get_real_path (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t   struct quick_file_names *qfn, int index)\n {\n   if (qfn->real_names == NULL)\n-    qfn->real_names = OBSTACK_CALLOC (&dwarf2_per_objfile->obstack,\n+    qfn->real_names = OBSTACK_CALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t\t      qfn->num_file_names, const char *);\n \n   if (qfn->real_names[index] == NULL)\n@@ -3222,7 +3222,7 @@ dw2_find_last_source_symtab (struct objfile *objfile)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n-  dwarf2_per_cu_data *dwarf_cu = dwarf2_per_objfile->all_comp_units.back ();\n+  dwarf2_per_cu_data *dwarf_cu = dwarf2_per_objfile->per_bfd->all_comp_units.back ();\n   compunit_symtab *cust = dw2_instantiate_symtab (dwarf_cu, false);\n \n   if (cust == NULL)\n@@ -3258,7 +3258,7 @@ dw2_forget_cached_source_info (struct objfile *objfile)\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n \n-  htab_traverse_noresize (dwarf2_per_objfile->quick_file_names_table.get (),\n+  htab_traverse_noresize (dwarf2_per_objfile->per_bfd->quick_file_names_table.get (),\n \t\t\t  dw2_free_cached_file_names, NULL);\n }\n \n@@ -3299,7 +3299,7 @@ dw2_map_symtabs_matching_filename\n   /* The rule is CUs specify all the files, including those used by\n      any TU, so there's no need to scan TUs here.  */\n \n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       /* We only need to look at symtabs not already expanded.  */\n       if (per_cu->v.quick->compunit_symtab)\n@@ -3397,7 +3397,7 @@ dw2_symtab_iter_init (struct dw2_symtab_iterator *iter,\n   iter->next = 0;\n   iter->global_seen = 0;\n \n-  mapped_index *index = dwarf2_per_objfile->index_table.get ();\n+  mapped_index *index = dwarf2_per_objfile->per_bfd->index_table.get ();\n \n   /* index is NULL if OBJF_READNOW.  */\n   if (index != NULL && find_slot_in_mapped_hash (index, name, &iter->vec))\n@@ -3428,20 +3428,20 @@ dw2_symtab_iter_next (struct dw2_symtab_iterator *iter)\n \t and indices >= 7 may elide them for certain symbols\n \t (gold does this).  */\n       int attrs_valid =\n-\t(dwarf2_per_objfile->index_table->version >= 7\n+\t(dwarf2_per_objfile->per_bfd->index_table->version >= 7\n \t && symbol_kind != GDB_INDEX_SYMBOL_KIND_NONE);\n \n       /* Don't crash on bad data.  */\n-      if (cu_index >= (dwarf2_per_objfile->all_comp_units.size ()\n-\t\t       + dwarf2_per_objfile->all_type_units.size ()))\n+      if (cu_index >= (dwarf2_per_objfile->per_bfd->all_comp_units.size ()\n+\t\t       + dwarf2_per_objfile->per_bfd->all_type_units.size ()))\n \t{\n \t  complaint (_(\".gdb_index entry has bad CU index\"\n \t\t       \" [in module %s]\"),\n \t\t     objfile_name (dwarf2_per_objfile->objfile));\n \t  continue;\n \t}\n \n-      dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->get_cutu (cu_index);\n+      dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->per_bfd->get_cutu (cu_index);\n \n       /* Skip if already read in.  */\n       if (per_cu->v.quick->compunit_symtab)\n@@ -3551,13 +3551,13 @@ dw2_print_stats (struct objfile *objfile)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n-  int total = (dwarf2_per_objfile->all_comp_units.size ()\n-\t       + dwarf2_per_objfile->all_type_units.size ());\n+  int total = (dwarf2_per_objfile->per_bfd->all_comp_units.size ()\n+\t       + dwarf2_per_objfile->per_bfd->all_type_units.size ());\n   int count = 0;\n \n   for (int i = 0; i < total; ++i)\n     {\n-      dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->get_cutu (i);\n+      dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->per_bfd->get_cutu (i);\n \n       if (!per_cu->v.quick->compunit_symtab)\n \t++count;\n@@ -3577,12 +3577,12 @@ dw2_dump (struct objfile *objfile)\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n \n-  gdb_assert (dwarf2_per_objfile->using_index);\n+  gdb_assert (dwarf2_per_objfile->per_bfd->using_index);\n   printf_filtered (\".gdb_index:\");\n-  if (dwarf2_per_objfile->index_table != NULL)\n+  if (dwarf2_per_objfile->per_bfd->index_table != NULL)\n     {\n       printf_filtered (\" version %d\\n\",\n-\t\t       dwarf2_per_objfile->index_table->version);\n+\t\t       dwarf2_per_objfile->per_bfd->index_table->version);\n     }\n   else\n     printf_filtered (\" faked for \\\"readnow\\\"\\n\");\n@@ -3611,12 +3611,12 @@ dw2_expand_all_symtabs (struct objfile *objfile)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n-  int total_units = (dwarf2_per_objfile->all_comp_units.size ()\n-\t\t     + dwarf2_per_objfile->all_type_units.size ());\n+  int total_units = (dwarf2_per_objfile->per_bfd->all_comp_units.size ()\n+\t\t     + dwarf2_per_objfile->per_bfd->all_type_units.size ());\n \n   for (int i = 0; i < total_units; ++i)\n     {\n-      dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->get_cutu (i);\n+      dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->per_bfd->get_cutu (i);\n \n       /* We don't want to directly expand a partial CU, because if we\n \t read it with the wrong language, then assertion failures can\n@@ -3639,7 +3639,7 @@ dw2_expand_symtabs_with_fullname (struct objfile *objfile,\n      There can be an order of magnitude (or more) more type units\n      than comp units, and we avoid them if we can.  */\n \n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       /* We only need to look at symtabs not already expanded.  */\n       if (per_cu->v.quick->compunit_symtab)\n@@ -3690,12 +3690,12 @@ dw2_map_matching_symbols\n \n   const block_enum block_kind = global ? GLOBAL_BLOCK : STATIC_BLOCK;\n \n-  if (dwarf2_per_objfile->index_table != nullptr)\n+  if (dwarf2_per_objfile->per_bfd->index_table != nullptr)\n     {\n       /* Ada currently doesn't support .gdb_index (see PR24713).  We can get\n \t here though if the current language is Ada for a non-Ada objfile\n \t using GNU index.  */\n-      mapped_index &index = *dwarf2_per_objfile->index_table;\n+      mapped_index &index = *dwarf2_per_objfile->per_bfd->index_table;\n \n       const char *match_name = name.ada ().lookup_name ().c_str ();\n       auto matcher = [&] (const char *symname)\n@@ -4528,7 +4528,7 @@ dw2_expand_marked_cus\n {\n   offset_type *vec, vec_len, vec_idx;\n   bool global_seen = false;\n-  mapped_index &index = *dwarf2_per_objfile->index_table;\n+  mapped_index &index = *dwarf2_per_objfile->per_bfd->index_table;\n \n   vec = (offset_type *) (index.constant_pool\n \t\t\t + MAYBE_SWAP (index.symbol_table[idx].vec));\n@@ -4585,16 +4585,16 @@ dw2_expand_marked_cus\n \t}\n \n       /* Don't crash on bad data.  */\n-      if (cu_index >= (dwarf2_per_objfile->all_comp_units.size ()\n-\t\t       + dwarf2_per_objfile->all_type_units.size ()))\n+      if (cu_index >= (dwarf2_per_objfile->per_bfd->all_comp_units.size ()\n+\t\t       + dwarf2_per_objfile->per_bfd->all_type_units.size ()))\n \t{\n \t  complaint (_(\".gdb_index entry has bad CU index\"\n \t\t       \" [in module %s]\"),\n \t\t       objfile_name (dwarf2_per_objfile->objfile));\n \t  continue;\n \t}\n \n-      dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->get_cutu (cu_index);\n+      dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->per_bfd->get_cutu (cu_index);\n       dw2_expand_symtabs_matching_one (per_cu, file_matcher,\n \t\t\t\t       expansion_notify);\n     }\n@@ -4622,7 +4622,7 @@ dw_expand_symtabs_matching_file_matcher\n   /* The rule is CUs specify all the files, including those used by\n      any TU, so there's no need to scan TUs here.  */\n \n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       QUIT;\n \n@@ -4691,14 +4691,14 @@ dw2_expand_symtabs_matching\n     = get_dwarf2_per_objfile (objfile);\n \n   /* index_table is NULL if OBJF_READNOW.  */\n-  if (!dwarf2_per_objfile->index_table)\n+  if (!dwarf2_per_objfile->per_bfd->index_table)\n     return;\n \n   dw_expand_symtabs_matching_file_matcher (dwarf2_per_objfile, file_matcher);\n \n   if (symbol_matcher == NULL && lookup_name == NULL)\n     {\n-      for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+      for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n \t{\n \t  QUIT;\n \n@@ -4708,7 +4708,7 @@ dw2_expand_symtabs_matching\n       return;\n     }\n \n-  mapped_index &index = *dwarf2_per_objfile->index_table;\n+  mapped_index &index = *dwarf2_per_objfile->per_bfd->index_table;\n \n   dw2_expand_symtabs_matching_symbol (index, *lookup_name,\n \t\t\t\t      symbol_matcher,\n@@ -4786,9 +4786,9 @@ dw2_map_symbol_filenames (struct objfile *objfile, symbol_filename_ftype *fun,\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n \n-  if (!dwarf2_per_objfile->filenames_cache)\n+  if (!dwarf2_per_objfile->per_bfd->filenames_cache)\n     {\n-      dwarf2_per_objfile->filenames_cache.emplace ();\n+      dwarf2_per_objfile->per_bfd->filenames_cache.emplace ();\n \n       htab_up visited (htab_create_alloc (10,\n \t\t\t\t\t  htab_hash_pointer, htab_eq_pointer,\n@@ -4798,7 +4798,7 @@ dw2_map_symbol_filenames (struct objfile *objfile, symbol_filename_ftype *fun,\n \t by any TU, so there's no need to scan TUs here.  We can\n \t ignore file names coming from already-expanded CUs.  */\n \n-      for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+      for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n \t{\n \t  if (per_cu->v.quick->compunit_symtab)\n \t    {\n@@ -4810,7 +4810,7 @@ dw2_map_symbol_filenames (struct objfile *objfile, symbol_filename_ftype *fun,\n \t    }\n \t}\n \n-      for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+      for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n \t{\n \t  /* We only need to look at symtabs not already expanded.  */\n \t  if (per_cu->v.quick->compunit_symtab)\n@@ -4831,12 +4831,12 @@ dw2_map_symbol_filenames (struct objfile *objfile, symbol_filename_ftype *fun,\n \t  for (int j = 0; j < file_data->num_file_names; ++j)\n \t    {\n \t      const char *filename = file_data->file_names[j];\n-\t      dwarf2_per_objfile->filenames_cache->seen (filename);\n+\t      dwarf2_per_objfile->per_bfd->filenames_cache->seen (filename);\n \t    }\n \t}\n     }\n \n-  dwarf2_per_objfile->filenames_cache->traverse ([&] (const char *filename)\n+  dwarf2_per_objfile->per_bfd->filenames_cache->traverse ([&] (const char *filename)\n     {\n       gdb::unique_xmalloc_ptr<char> this_real_name;\n \n@@ -5086,7 +5086,7 @@ create_cus_from_debug_names_list (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \tdwarf2_per_cu_data *per_cu\n \t  = create_cu_from_index_list (dwarf2_per_objfile, &section, is_dwz,\n \t\t\t\t       sect_off, 0);\n-\tdwarf2_per_objfile->all_comp_units.push_back (per_cu);\n+\tdwarf2_per_objfile->per_bfd->all_comp_units.push_back (per_cu);\n       }\n     }\n \n@@ -5110,7 +5110,7 @@ create_cus_from_debug_names_list (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t  dwarf2_per_cu_data *per_cu\n \t    = create_cu_from_index_list (dwarf2_per_objfile, &section, is_dwz,\n \t\t\t\t\t sect_off_prev, length);\n-\t  dwarf2_per_objfile->all_comp_units.push_back (per_cu);\n+\t  dwarf2_per_objfile->per_bfd->all_comp_units.push_back (per_cu);\n \t}\n       sect_off_prev = sect_off_next;\n     }\n@@ -5124,11 +5124,11 @@ create_cus_from_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\t     const mapped_debug_names &map,\n \t\t\t     const mapped_debug_names &dwz_map)\n {\n-  gdb_assert (dwarf2_per_objfile->all_comp_units.empty ());\n-  dwarf2_per_objfile->all_comp_units.reserve (map.cu_count + dwz_map.cu_count);\n+  gdb_assert (dwarf2_per_objfile->per_bfd->all_comp_units.empty ());\n+  dwarf2_per_objfile->per_bfd->all_comp_units.reserve (map.cu_count + dwz_map.cu_count);\n \n   create_cus_from_debug_names_list (dwarf2_per_objfile, map,\n-\t\t\t\t    dwarf2_per_objfile->info,\n+\t\t\t\t    dwarf2_per_objfile->per_bfd->info,\n \t\t\t\t    false /* is_dwz */);\n \n   if (dwz_map.cu_count == 0)\n@@ -5151,7 +5151,7 @@ dwarf2_read_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile)\n   struct objfile *objfile = dwarf2_per_objfile->objfile;\n \n   if (!read_debug_names_from_section (objfile, objfile_name (objfile),\n-\t\t\t\t      &dwarf2_per_objfile->debug_names,\n+\t\t\t\t      &dwarf2_per_objfile->per_bfd->debug_names,\n \t\t\t\t      *map))\n     return false;\n \n@@ -5180,22 +5180,22 @@ dwarf2_read_debug_names (struct dwarf2_per_objfile *dwarf2_per_objfile)\n     {\n       /* We can only handle a single .debug_types when we have an\n \t index.  */\n-      if (dwarf2_per_objfile->types.size () != 1)\n+      if (dwarf2_per_objfile->per_bfd->types.size () != 1)\n \treturn false;\n \n-      dwarf2_section_info *section = &dwarf2_per_objfile->types[0];\n+      dwarf2_section_info *section = &dwarf2_per_objfile->per_bfd->types[0];\n \n       create_signatured_type_table_from_debug_names\n-\t(dwarf2_per_objfile, *map, section, &dwarf2_per_objfile->abbrev);\n+\t(dwarf2_per_objfile, *map, section, &dwarf2_per_objfile->per_bfd->abbrev);\n     }\n \n   create_addrmap_from_aranges (dwarf2_per_objfile,\n-\t\t\t       &dwarf2_per_objfile->debug_aranges);\n+\t\t\t       &dwarf2_per_objfile->per_bfd->debug_aranges);\n \n-  dwarf2_per_objfile->debug_names_table = std::move (map);\n-  dwarf2_per_objfile->using_index = 1;\n-  dwarf2_per_objfile->quick_file_names_table =\n-    create_quick_file_names_table (dwarf2_per_objfile->all_comp_units.size ());\n+  dwarf2_per_objfile->per_bfd->debug_names_table = std::move (map);\n+  dwarf2_per_objfile->per_bfd->using_index = 1;\n+  dwarf2_per_objfile->per_bfd->quick_file_names_table =\n+    create_quick_file_names_table (dwarf2_per_objfile->per_bfd->all_comp_units.size ());\n \n   return true;\n }\n@@ -5442,33 +5442,33 @@ dw2_debug_names_iterator::next ()\n \t{\n \tcase DW_IDX_compile_unit:\n \t  /* Don't crash on bad data.  */\n-\t  if (ull >= dwarf2_per_objfile->all_comp_units.size ())\n+\t  if (ull >= dwarf2_per_objfile->per_bfd->all_comp_units.size ())\n \t    {\n \t      complaint (_(\".debug_names entry has bad CU index %s\"\n \t\t\t   \" [in module %s]\"),\n \t\t\t pulongest (ull),\n \t\t\t objfile_name (dwarf2_per_objfile->objfile));\n \t      continue;\n \t    }\n-\t  per_cu = dwarf2_per_objfile->get_cutu (ull);\n+\t  per_cu = dwarf2_per_objfile->per_bfd->get_cutu (ull);\n \t  break;\n \tcase DW_IDX_type_unit:\n \t  /* Don't crash on bad data.  */\n-\t  if (ull >= dwarf2_per_objfile->all_type_units.size ())\n+\t  if (ull >= dwarf2_per_objfile->per_bfd->all_type_units.size ())\n \t    {\n \t      complaint (_(\".debug_names entry has bad TU index %s\"\n \t\t\t   \" [in module %s]\"),\n \t\t\t pulongest (ull),\n \t\t\t objfile_name (dwarf2_per_objfile->objfile));\n \t      continue;\n \t    }\n-\t  per_cu = &dwarf2_per_objfile->get_tu (ull)->per_cu;\n+\t  per_cu = &dwarf2_per_objfile->per_bfd->get_tu (ull)->per_cu;\n \t  break;\n \tcase DW_IDX_die_offset:\n \t  /* In a per-CU index (as opposed to a per-module index), index\n \t     entries without CU attribute implicitly refer to the single CU.  */\n \t  if (per_cu == NULL)\n-\t    per_cu = dwarf2_per_objfile->get_cu (0);\n+\t    per_cu = dwarf2_per_objfile->per_bfd->get_cu (0);\n \t  break;\n \tcase DW_IDX_GNU_internal:\n \t  if (!m_map.augmentation_is_gdb)\n@@ -5601,7 +5601,7 @@ dw2_debug_names_lookup_symbol (struct objfile *objfile, block_enum block_index,\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n \n-  const auto &mapp = dwarf2_per_objfile->debug_names_table;\n+  const auto &mapp = dwarf2_per_objfile->per_bfd->debug_names_table;\n   if (!mapp)\n     {\n       /* index is NULL if OBJF_READNOW.  */\n@@ -5651,9 +5651,9 @@ dw2_debug_names_dump (struct objfile *objfile)\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n \n-  gdb_assert (dwarf2_per_objfile->using_index);\n+  gdb_assert (dwarf2_per_objfile->per_bfd->using_index);\n   printf_filtered (\".debug_names:\");\n-  if (dwarf2_per_objfile->debug_names_table)\n+  if (dwarf2_per_objfile->per_bfd->debug_names_table)\n     printf_filtered (\" exists\\n\");\n   else\n     printf_filtered (\" faked for \\\"readnow\\\"\\n\");\n@@ -5667,10 +5667,10 @@ dw2_debug_names_expand_symtabs_for_function (struct objfile *objfile,\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = get_dwarf2_per_objfile (objfile);\n \n-  /* dwarf2_per_objfile->debug_names_table is NULL if OBJF_READNOW.  */\n-  if (dwarf2_per_objfile->debug_names_table)\n+  /* dwarf2_per_objfile->per_bfd->debug_names_table is NULL if OBJF_READNOW.  */\n+  if (dwarf2_per_objfile->per_bfd->debug_names_table)\n     {\n-      const mapped_debug_names &map = *dwarf2_per_objfile->debug_names_table;\n+      const mapped_debug_names &map = *dwarf2_per_objfile->per_bfd->debug_names_table;\n \n       dw2_debug_names_iterator iter (map, {}, VAR_DOMAIN, func_name);\n \n@@ -5692,10 +5692,10 @@ dw2_debug_names_map_matching_symbols\n     = get_dwarf2_per_objfile (objfile);\n \n   /* debug_names_table is NULL if OBJF_READNOW.  */\n-  if (!dwarf2_per_objfile->debug_names_table)\n+  if (!dwarf2_per_objfile->per_bfd->debug_names_table)\n     return;\n \n-  mapped_debug_names &map = *dwarf2_per_objfile->debug_names_table;\n+  mapped_debug_names &map = *dwarf2_per_objfile->per_bfd->debug_names_table;\n   const block_enum block_kind = global ? GLOBAL_BLOCK : STATIC_BLOCK;\n \n   const char *match_name = name.ada ().lookup_name ().c_str ();\n@@ -5723,7 +5723,7 @@ dw2_debug_names_map_matching_symbols\n      dw2_expand_symtabs_matching_symbol callback, but that skips CUs\n      that have already been expanded.  Instead, this loop matches what\n      the psymtab code does.  */\n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       struct compunit_symtab *cust = per_cu->v.quick->compunit_symtab;\n       if (cust != nullptr)\n@@ -5750,14 +5750,14 @@ dw2_debug_names_expand_symtabs_matching\n     = get_dwarf2_per_objfile (objfile);\n \n   /* debug_names_table is NULL if OBJF_READNOW.  */\n-  if (!dwarf2_per_objfile->debug_names_table)\n+  if (!dwarf2_per_objfile->per_bfd->debug_names_table)\n     return;\n \n   dw_expand_symtabs_matching_file_matcher (dwarf2_per_objfile, file_matcher);\n \n   if (symbol_matcher == NULL && lookup_name == NULL)\n     {\n-      for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+      for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n \t{\n \t  QUIT;\n \n@@ -5767,7 +5767,7 @@ dw2_debug_names_expand_symtabs_matching\n       return;\n     }\n \n-  mapped_debug_names &map = *dwarf2_per_objfile->debug_names_table;\n+  mapped_debug_names &map = *dwarf2_per_objfile->per_bfd->debug_names_table;\n \n   dw2_expand_symtabs_matching_symbol (map, *lookup_name,\n \t\t\t\t      symbol_matcher,\n@@ -5806,7 +5806,7 @@ const struct quick_symbol_functions dwarf2_debug_names_functions =\n };\n \n /* Get the content of the .gdb_index section of OBJ.  SECTION_OWNER should point\n-   to either a dwarf2_per_objfile or dwz_file object.  */\n+   to either a dwarf2_per_bfd or dwz_file object.  */\n \n template <typename T>\n static gdb::array_view<const gdb_byte>\n@@ -5837,14 +5837,14 @@ get_gdb_index_contents_from_section (objfile *obj, T *section_owner)\n    DWARF2_OBJ.  */\n \n static gdb::array_view<const gdb_byte>\n-get_gdb_index_contents_from_cache (objfile *obj, dwarf2_per_objfile *dwarf2_obj)\n+get_gdb_index_contents_from_cache (objfile *obj, dwarf2_per_bfd *dwarf2_per_bfd)\n {\n   const bfd_build_id *build_id = build_id_bfd_get (obj->obfd);\n   if (build_id == nullptr)\n     return {};\n \n   return global_index_cache.lookup_gdb_index (build_id,\n-\t\t\t\t\t      &dwarf2_obj->index_cache_res);\n+\t\t\t\t\t      &dwarf2_per_bfd->index_cache_res);\n }\n \n /* Same as the above, but for DWZ.  */\n@@ -5873,19 +5873,19 @@ dwarf2_initialize_objfile (struct objfile *objfile, dw_index_kind *index_kind)\n      expanded anyway.  */\n   if ((objfile->flags & OBJF_READNOW))\n     {\n-      dwarf2_per_objfile->using_index = 1;\n+      dwarf2_per_objfile->per_bfd->using_index = 1;\n       create_all_comp_units (dwarf2_per_objfile);\n       create_all_type_units (dwarf2_per_objfile);\n-      dwarf2_per_objfile->quick_file_names_table\n+      dwarf2_per_objfile->per_bfd->quick_file_names_table\n \t= create_quick_file_names_table\n-\t    (dwarf2_per_objfile->all_comp_units.size ());\n+\t    (dwarf2_per_objfile->per_bfd->all_comp_units.size ());\n \n-      for (int i = 0; i < (dwarf2_per_objfile->all_comp_units.size ()\n-\t\t\t   + dwarf2_per_objfile->all_type_units.size ()); ++i)\n+      for (int i = 0; i < (dwarf2_per_objfile->per_bfd->all_comp_units.size ()\n+\t\t\t   + dwarf2_per_objfile->per_bfd->all_type_units.size ()); ++i)\n \t{\n-\t  dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->get_cutu (i);\n+\t  dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->per_bfd->get_cutu (i);\n \n-\t  per_cu->v.quick = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+\t  per_cu->v.quick = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t\t\t    struct dwarf2_per_cu_quick_data);\n \t}\n \n@@ -5903,7 +5903,7 @@ dwarf2_initialize_objfile (struct objfile *objfile, dw_index_kind *index_kind)\n     }\n \n   if (dwarf2_read_gdb_index (dwarf2_per_objfile,\n-\t\t\t     get_gdb_index_contents_from_section<struct dwarf2_per_objfile>,\n+\t\t\t     get_gdb_index_contents_from_section<struct dwarf2_per_bfd>,\n \t\t\t     get_gdb_index_contents_from_section<dwz_file>))\n     {\n       *index_kind = dw_index_kind::GDB_INDEX;\n@@ -5990,7 +5990,7 @@ get_abbrev_section_for_cu (struct dwarf2_per_cu_data *this_cu)\n   if (this_cu->is_dwz)\n     abbrev = &dwarf2_get_dwz_file (dwarf2_per_objfile)->abbrev;\n   else\n-    abbrev = &dwarf2_per_objfile->abbrev;\n+    abbrev = &dwarf2_per_objfile->per_bfd->abbrev;\n \n   return abbrev;\n }\n@@ -6180,7 +6180,7 @@ create_debug_type_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n   abbrev_section = (dwo_file != NULL\n \t\t    ? &dwo_file->sections.abbrev\n-\t\t    : &dwarf2_per_objfile->abbrev);\n+\t\t    : &dwarf2_per_objfile->per_bfd->abbrev);\n \n   if (dwarf_read_debug)\n     fprintf_unfiltered (gdb_stdlog, \"Reading %s for %s:\\n\",\n@@ -6244,7 +6244,7 @@ create_debug_type_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       if (dwo_file)\n \t{\n \t  sig_type = NULL;\n-\t  dwo_tu = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+\t  dwo_tu = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t\t   struct dwo_unit);\n \t  dwo_tu->dwo_file = dwo_file;\n \t  dwo_tu->signature = header.signature;\n@@ -6258,7 +6258,7 @@ create_debug_type_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t  /* N.B.: type_offset is not usable if this type uses a DWO file.\n \t     The real type_offset is in the DWO file.  */\n \t  dwo_tu = NULL;\n-\t  sig_type = dwarf2_per_objfile->allocate_signatured_type ();\n+\t  sig_type = dwarf2_per_objfile->per_bfd->allocate_signatured_type ();\n \t  sig_type->signature = header.signature;\n \t  sig_type->type_offset_in_tu = header.type_cu_offset_in_tu;\n \t  sig_type->per_cu.dwarf2_per_objfile = dwarf2_per_objfile;\n@@ -6338,56 +6338,56 @@ create_all_type_units (struct dwarf2_per_objfile *dwarf2_per_objfile)\n   htab_up types_htab;\n \n   create_debug_type_hash_table (dwarf2_per_objfile, NULL,\n-\t\t\t\t&dwarf2_per_objfile->info, types_htab,\n+\t\t\t\t&dwarf2_per_objfile->per_bfd->info, types_htab,\n \t\t\t\trcuh_kind::COMPILE);\n   create_debug_types_hash_table (dwarf2_per_objfile, NULL,\n-\t\t\t\t dwarf2_per_objfile->types, types_htab);\n+\t\t\t\t dwarf2_per_objfile->per_bfd->types, types_htab);\n   if (types_htab == NULL)\n     {\n-      dwarf2_per_objfile->signatured_types = NULL;\n+      dwarf2_per_objfile->per_bfd->signatured_types = NULL;\n       return 0;\n     }\n \n-  dwarf2_per_objfile->signatured_types = std::move (types_htab);\n+  dwarf2_per_objfile->per_bfd->signatured_types = std::move (types_htab);\n \n-  gdb_assert (dwarf2_per_objfile->all_type_units.empty ());\n-  dwarf2_per_objfile->all_type_units.reserve\n-    (htab_elements (dwarf2_per_objfile->signatured_types.get ()));\n+  gdb_assert (dwarf2_per_objfile->per_bfd->all_type_units.empty ());\n+  dwarf2_per_objfile->per_bfd->all_type_units.reserve\n+    (htab_elements (dwarf2_per_objfile->per_bfd->signatured_types.get ()));\n \n-  htab_traverse_noresize (dwarf2_per_objfile->signatured_types.get (),\n+  htab_traverse_noresize (dwarf2_per_objfile->per_bfd->signatured_types.get (),\n \t\t\t  add_signatured_type_cu_to_table,\n-\t\t\t  &dwarf2_per_objfile->all_type_units);\n+\t\t\t  &dwarf2_per_objfile->per_bfd->all_type_units);\n \n   return 1;\n }\n \n-/* Add an entry for signature SIG to dwarf2_per_objfile->signatured_types.\n+/* Add an entry for signature SIG to dwarf2_per_objfile->per_bfd->signatured_types.\n    If SLOT is non-NULL, it is the entry to use in the hash table.\n    Otherwise we find one.  */\n \n static struct signatured_type *\n add_type_unit (struct dwarf2_per_objfile *dwarf2_per_objfile, ULONGEST sig,\n \t       void **slot)\n {\n-  if (dwarf2_per_objfile->all_type_units.size ()\n-      == dwarf2_per_objfile->all_type_units.capacity ())\n-    ++dwarf2_per_objfile->tu_stats.nr_all_type_units_reallocs;\n+  if (dwarf2_per_objfile->per_bfd->all_type_units.size ()\n+      == dwarf2_per_objfile->per_bfd->all_type_units.capacity ())\n+    ++dwarf2_per_objfile->per_bfd->tu_stats.nr_all_type_units_reallocs;\n \n-  signatured_type *sig_type = dwarf2_per_objfile->allocate_signatured_type ();\n+  signatured_type *sig_type = dwarf2_per_objfile->per_bfd->allocate_signatured_type ();\n \n-  dwarf2_per_objfile->all_type_units.push_back (sig_type);\n+  dwarf2_per_objfile->per_bfd->all_type_units.push_back (sig_type);\n   sig_type->signature = sig;\n   sig_type->per_cu.is_debug_types = 1;\n-  if (dwarf2_per_objfile->using_index)\n+  if (dwarf2_per_objfile->per_bfd->using_index)\n     {\n       sig_type->per_cu.v.quick =\n-\tOBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+\tOBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\tstruct dwarf2_per_cu_quick_data);\n     }\n \n   if (slot == NULL)\n     {\n-      slot = htab_find_slot (dwarf2_per_objfile->signatured_types.get (),\n+      slot = htab_find_slot (dwarf2_per_objfile->per_bfd->signatured_types.get (),\n \t\t\t     sig_type, INSERT);\n     }\n   gdb_assert (*slot == NULL);\n@@ -6407,7 +6407,7 @@ fill_in_sig_entry_from_dwo_entry (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   /* Make sure we're not clobbering something we don't expect to.  */\n   gdb_assert (! sig_entry->per_cu.queued);\n   gdb_assert (sig_entry->per_cu.cu == NULL);\n-  if (dwarf2_per_objfile->using_index)\n+  if (dwarf2_per_objfile->per_bfd->using_index)\n     {\n       gdb_assert (sig_entry->per_cu.v.quick != NULL);\n       gdb_assert (sig_entry->per_cu.v.quick->compunit_symtab == NULL);\n@@ -6450,12 +6450,12 @@ lookup_dwo_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n   struct signatured_type find_sig_entry, *sig_entry;\n   void **slot;\n \n-  gdb_assert (cu->dwo_unit && dwarf2_per_objfile->using_index);\n+  gdb_assert (cu->dwo_unit && dwarf2_per_objfile->per_bfd->using_index);\n \n   /* If TU skeletons have been removed then we may not have read in any\n      TUs yet.  */\n-  if (dwarf2_per_objfile->signatured_types == NULL)\n-    dwarf2_per_objfile->signatured_types = allocate_signatured_type_table ();\n+  if (dwarf2_per_objfile->per_bfd->signatured_types == NULL)\n+    dwarf2_per_objfile->per_bfd->signatured_types = allocate_signatured_type_table ();\n \n   /* We only ever need to read in one copy of a signatured type.\n      Use the global signatured_types array to do our own comdat-folding\n@@ -6464,7 +6464,7 @@ lookup_dwo_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n      .gdb_index with this TU.  */\n \n   find_sig_entry.signature = sig;\n-  slot = htab_find_slot (dwarf2_per_objfile->signatured_types.get (),\n+  slot = htab_find_slot (dwarf2_per_objfile->per_bfd->signatured_types.get (),\n \t\t\t &find_sig_entry, INSERT);\n   sig_entry = (struct signatured_type *) *slot;\n \n@@ -6517,16 +6517,16 @@ lookup_dwp_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n   struct signatured_type find_sig_entry, *sig_entry;\n   void **slot;\n \n-  gdb_assert (cu->dwo_unit && dwarf2_per_objfile->using_index);\n+  gdb_assert (cu->dwo_unit && dwarf2_per_objfile->per_bfd->using_index);\n   gdb_assert (dwp_file != NULL);\n \n   /* If TU skeletons have been removed then we may not have read in any\n      TUs yet.  */\n-  if (dwarf2_per_objfile->signatured_types == NULL)\n-    dwarf2_per_objfile->signatured_types = allocate_signatured_type_table ();\n+  if (dwarf2_per_objfile->per_bfd->signatured_types == NULL)\n+    dwarf2_per_objfile->per_bfd->signatured_types = allocate_signatured_type_table ();\n \n   find_sig_entry.signature = sig;\n-  slot = htab_find_slot (dwarf2_per_objfile->signatured_types.get (),\n+  slot = htab_find_slot (dwarf2_per_objfile->per_bfd->signatured_types.get (),\n \t\t\t &find_sig_entry, INSERT);\n   sig_entry = (struct signatured_type *) *slot;\n \n@@ -6560,7 +6560,7 @@ lookup_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n     = cu->per_cu->dwarf2_per_objfile;\n \n   if (cu->dwo_unit\n-      && dwarf2_per_objfile->using_index)\n+      && dwarf2_per_objfile->per_bfd->using_index)\n     {\n       /* We're in a DWO/DWP file, and we're using .gdb_index.\n \t These cases require special processing.  */\n@@ -6573,11 +6573,11 @@ lookup_signatured_type (struct dwarf2_cu *cu, ULONGEST sig)\n     {\n       struct signatured_type find_entry, *entry;\n \n-      if (dwarf2_per_objfile->signatured_types == NULL)\n+      if (dwarf2_per_objfile->per_bfd->signatured_types == NULL)\n \treturn NULL;\n       find_entry.signature = sig;\n       entry = ((struct signatured_type *)\n-\t       htab_find (dwarf2_per_objfile->signatured_types.get (),\n+\t       htab_find (dwarf2_per_objfile->per_bfd->signatured_types.get (),\n \t\t\t  &find_entry));\n       return entry;\n     }\n@@ -7103,8 +7103,8 @@ cutu_reader::keep ()\n       struct dwarf2_per_objfile *dwarf2_per_objfile\n \t= m_this_cu->dwarf2_per_objfile;\n       /* Link this CU into read_in_chain.  */\n-      m_this_cu->cu->read_in_chain = dwarf2_per_objfile->read_in_chain;\n-      dwarf2_per_objfile->read_in_chain = m_this_cu;\n+      m_this_cu->cu->read_in_chain = dwarf2_per_objfile->per_bfd->read_in_chain;\n+      dwarf2_per_objfile->per_bfd->read_in_chain = m_this_cu;\n       /* The chain owns it now.  */\n       m_new_cu.release ();\n     }\n@@ -7242,14 +7242,14 @@ create_type_unit_group (struct dwarf2_cu *cu, sect_offset line_offset_struct)\n   struct dwarf2_per_cu_data *per_cu;\n   struct type_unit_group *tu_group;\n \n-  tu_group = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+  tu_group = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t     struct type_unit_group);\n   per_cu = &tu_group->per_cu;\n   per_cu->dwarf2_per_objfile = dwarf2_per_objfile;\n \n-  if (dwarf2_per_objfile->using_index)\n+  if (dwarf2_per_objfile->per_bfd->using_index)\n     {\n-      per_cu->v.quick = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+      per_cu->v.quick = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t\t\tstruct dwarf2_per_cu_quick_data);\n     }\n   else\n@@ -7283,14 +7283,14 @@ get_type_unit_group (struct dwarf2_cu *cu, const struct attribute *stmt_list)\n {\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = cu->per_cu->dwarf2_per_objfile;\n-  struct tu_stats *tu_stats = &dwarf2_per_objfile->tu_stats;\n+  struct tu_stats *tu_stats = &dwarf2_per_objfile->per_bfd->tu_stats;\n   struct type_unit_group *tu_group;\n   void **slot;\n   unsigned int line_offset;\n   struct type_unit_group type_unit_group_for_lookup;\n \n-  if (dwarf2_per_objfile->type_unit_groups == NULL)\n-    dwarf2_per_objfile->type_unit_groups = allocate_type_unit_groups_table ();\n+  if (dwarf2_per_objfile->per_bfd->type_unit_groups == NULL)\n+    dwarf2_per_objfile->per_bfd->type_unit_groups = allocate_type_unit_groups_table ();\n \n   /* Do we need to create a new group, or can we use an existing one?  */\n \n@@ -7314,7 +7314,7 @@ get_type_unit_group (struct dwarf2_cu *cu, const struct attribute *stmt_list)\n \n   type_unit_group_for_lookup.hash.dwo_unit = cu->dwo_unit;\n   type_unit_group_for_lookup.hash.line_sect_off = (sect_offset) line_offset;\n-  slot = htab_find_slot (dwarf2_per_objfile->type_unit_groups.get (),\n+  slot = htab_find_slot (dwarf2_per_objfile->per_bfd->type_unit_groups.get (),\n \t\t\t &type_unit_group_for_lookup, INSERT);\n   if (*slot != NULL)\n     {\n@@ -7613,27 +7613,27 @@ sort_tu_by_abbrev_offset (const struct tu_abbrev_offset &a,\n    sharing 8K abbrev tables.\n \n    The main purpose of this function is to support building the\n-   dwarf2_per_objfile->type_unit_groups table.\n+   dwarf2_per_objfile->per_bfd->type_unit_groups table.\n    TUs typically share the DW_AT_stmt_list of the CU they came from, so we\n    can collapse the search space by grouping them by stmt_list.\n    The savings can be significant, in the same program from above the 200K TUs\n    share 8K stmt_list tables.\n \n    FUNC is expected to call get_type_unit_group, which will create the\n    struct type_unit_group if necessary and add it to\n-   dwarf2_per_objfile->type_unit_groups.  */\n+   dwarf2_per_objfile->per_bfd->type_unit_groups.  */\n \n static void\n build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n-  struct tu_stats *tu_stats = &dwarf2_per_objfile->tu_stats;\n+  struct tu_stats *tu_stats = &dwarf2_per_objfile->per_bfd->tu_stats;\n   abbrev_table_up abbrev_table;\n   sect_offset abbrev_offset;\n \n   /* It's up to the caller to not call us multiple times.  */\n-  gdb_assert (dwarf2_per_objfile->type_unit_groups == NULL);\n+  gdb_assert (dwarf2_per_objfile->per_bfd->type_unit_groups == NULL);\n \n-  if (dwarf2_per_objfile->all_type_units.empty ())\n+  if (dwarf2_per_objfile->per_bfd->all_type_units.empty ())\n     return;\n \n   /* TUs typically share abbrev tables, and there can be way more TUs than\n@@ -7661,9 +7661,9 @@ build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n   /* Sort in a separate table to maintain the order of all_type_units\n      for .gdb_index: TU indices directly index all_type_units.  */\n   std::vector<tu_abbrev_offset> sorted_by_abbrev;\n-  sorted_by_abbrev.reserve (dwarf2_per_objfile->all_type_units.size ());\n+  sorted_by_abbrev.reserve (dwarf2_per_objfile->per_bfd->all_type_units.size ());\n \n-  for (signatured_type *sig_type : dwarf2_per_objfile->all_type_units)\n+  for (signatured_type *sig_type : dwarf2_per_objfile->per_bfd->all_type_units)\n     sorted_by_abbrev.emplace_back\n       (sig_type, read_abbrev_offset (dwarf2_per_objfile,\n \t\t\t\t     sig_type->per_cu.section,\n@@ -7683,7 +7683,7 @@ build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \t  abbrev_offset = tu.abbrev_offset;\n \t  abbrev_table =\n \t    abbrev_table::read (dwarf2_per_objfile->objfile,\n-\t\t\t\t&dwarf2_per_objfile->abbrev,\n+\t\t\t\t&dwarf2_per_objfile->per_bfd->abbrev,\n \t\t\t\tabbrev_offset);\n \t  ++tu_stats->nr_uniq_abbrev_tables;\n \t}\n@@ -7701,11 +7701,11 @@ build_type_psymtabs_1 (struct dwarf2_per_objfile *dwarf2_per_objfile)\n static void\n print_tu_stats (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n-  struct tu_stats *tu_stats = &dwarf2_per_objfile->tu_stats;\n+  struct tu_stats *tu_stats = &dwarf2_per_objfile->per_bfd->tu_stats;\n \n   fprintf_unfiltered (gdb_stdlog, \"Type unit statistics:\\n\");\n   fprintf_unfiltered (gdb_stdlog, \"  %zu TUs\\n\",\n-\t\t      dwarf2_per_objfile->all_type_units.size ());\n+\t\t      dwarf2_per_objfile->per_bfd->all_type_units.size ());\n   fprintf_unfiltered (gdb_stdlog, \"  %d uniq abbrev tables\\n\",\n \t\t      tu_stats->nr_uniq_abbrev_tables);\n   fprintf_unfiltered (gdb_stdlog, \"  %d symtabs from stmt_list entries\\n\",\n@@ -7776,11 +7776,11 @@ process_skeletonless_type_unit (void **slot, void *info)\n \n   /* If this TU doesn't exist in the global table, add it and read it in.  */\n \n-  if (dwarf2_per_objfile->signatured_types == NULL)\n-    dwarf2_per_objfile->signatured_types = allocate_signatured_type_table ();\n+  if (dwarf2_per_objfile->per_bfd->signatured_types == NULL)\n+    dwarf2_per_objfile->per_bfd->signatured_types = allocate_signatured_type_table ();\n \n   find_entry.signature = dwo_unit->signature;\n-  slot = htab_find_slot (dwarf2_per_objfile->signatured_types.get (),\n+  slot = htab_find_slot (dwarf2_per_objfile->per_bfd->signatured_types.get (),\n \t\t\t &find_entry, INSERT);\n   /* If we've already seen this type there's nothing to do.  What's happening\n      is we're doing our own version of comdat-folding here.  */\n@@ -7825,9 +7825,9 @@ process_skeletonless_type_units (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n   /* Skeletonless TUs in DWP files without .gdb_index is not supported yet.  */\n   if (get_dwp_file (dwarf2_per_objfile) == NULL\n-      && dwarf2_per_objfile->dwo_files != NULL)\n+      && dwarf2_per_objfile->per_bfd->dwo_files != NULL)\n     {\n-      htab_traverse_noresize (dwarf2_per_objfile->dwo_files.get (),\n+      htab_traverse_noresize (dwarf2_per_objfile->per_bfd->dwo_files.get (),\n \t\t\t      process_dwo_file_for_skeletonless_type_units,\n \t\t\t      dwarf2_per_objfile);\n     }\n@@ -7838,7 +7838,7 @@ process_skeletonless_type_units (struct dwarf2_per_objfile *dwarf2_per_objfile)\n static void\n set_partial_user (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       dwarf2_psymtab *pst = per_cu->v.psymtab;\n \n@@ -7869,10 +7869,10 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n     }\n \n   scoped_restore restore_reading_psyms\n-    = make_scoped_restore (&dwarf2_per_objfile->reading_partial_symbols,\n+    = make_scoped_restore (&dwarf2_per_objfile->per_bfd->reading_partial_symbols,\n \t\t\t   true);\n \n-  dwarf2_per_objfile->info.read (objfile);\n+  dwarf2_per_objfile->per_bfd->info.read (objfile);\n \n   /* Any cached compilation units will be linked by the per-objfile\n      read_in_chain.  Make sure to free them when we're done.  */\n@@ -7890,7 +7890,7 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n     = make_scoped_restore (&objfile->partial_symtabs->psymtabs_addrmap,\n \t\t\t   addrmap_create_mutable (&temp_obstack));\n \n-  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->all_comp_units)\n+  for (dwarf2_per_cu_data *per_cu : dwarf2_per_objfile->per_bfd->all_comp_units)\n     {\n       if (per_cu->v.psymtab != NULL)\n \t/* In case a forward DW_TAG_imported_unit has read the CU already.  */\n@@ -7902,9 +7902,9 @@ dwarf2_build_psymtabs_hard (struct dwarf2_per_objfile *dwarf2_per_objfile)\n   process_skeletonless_type_units (dwarf2_per_objfile);\n \n   /* Now that all TUs have been processed we can fill in the dependencies.  */\n-  if (dwarf2_per_objfile->type_unit_groups != NULL)\n+  if (dwarf2_per_objfile->per_bfd->type_unit_groups != NULL)\n     {\n-      htab_traverse_noresize (dwarf2_per_objfile->type_unit_groups.get (),\n+      htab_traverse_noresize (dwarf2_per_objfile->per_bfd->type_unit_groups.get (),\n \t\t\t      build_type_psymtab_dependencies, dwarf2_per_objfile);\n     }\n \n@@ -7978,10 +7978,10 @@ read_comp_units_from_section (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \n       /* Save the compilation unit for later lookup.  */\n       if (cu_header.unit_type != DW_UT_type)\n-\tthis_cu = dwarf2_per_objfile->allocate_per_cu ();\n+\tthis_cu = dwarf2_per_objfile->per_bfd->allocate_per_cu ();\n       else\n \t{\n-\t  auto sig_type = dwarf2_per_objfile->allocate_signatured_type ();\n+\t  auto sig_type = dwarf2_per_objfile->per_bfd->allocate_signatured_type ();\n \t  sig_type->signature = cu_header.signature;\n \t  sig_type->type_offset_in_tu = cu_header.type_cu_offset_in_tu;\n \t  this_cu = &sig_type->per_cu;\n@@ -7993,7 +7993,7 @@ read_comp_units_from_section (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       this_cu->dwarf2_per_objfile = dwarf2_per_objfile;\n       this_cu->section = section;\n \n-      dwarf2_per_objfile->all_comp_units.push_back (this_cu);\n+      dwarf2_per_objfile->per_bfd->all_comp_units.push_back (this_cu);\n \n       info_ptr = info_ptr + this_cu->length;\n     }\n@@ -8005,9 +8005,9 @@ read_comp_units_from_section (struct dwarf2_per_objfile *dwarf2_per_objfile,\n static void\n create_all_comp_units (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n-  gdb_assert (dwarf2_per_objfile->all_comp_units.empty ());\n-  read_comp_units_from_section (dwarf2_per_objfile, &dwarf2_per_objfile->info,\n-\t\t\t\t&dwarf2_per_objfile->abbrev, 0);\n+  gdb_assert (dwarf2_per_objfile->per_bfd->all_comp_units.empty ());\n+  read_comp_units_from_section (dwarf2_per_objfile, &dwarf2_per_objfile->per_bfd->info,\n+\t\t\t\t&dwarf2_per_objfile->per_bfd->abbrev, 0);\n \n   dwz_file *dwz = dwarf2_get_dwz_file (dwarf2_per_objfile);\n   if (dwz != NULL)\n@@ -8345,7 +8345,7 @@ add_partial_symbol (struct partial_die_info *pdi, struct dwarf2_cu *cu)\n \n       if (pdi->d.locdesc\n \t  && addr == 0\n-\t  && !dwarf2_per_objfile->has_section_at_zero)\n+\t  && !dwarf2_per_objfile->per_bfd->has_section_at_zero)\n \t{\n \t  /* A global or static variable may also have been stripped\n \t     out by the linker if unused, in which case its address\n@@ -8847,8 +8847,8 @@ dwarf2_psymtab::read_symtab (struct objfile *objfile)\n       struct dwarf2_per_objfile *dpo_backlink\n \t= get_dwarf2_per_objfile (objfile->separate_debug_objfile_backlink);\n \n-      dwarf2_per_objfile->has_section_at_zero\n-\t= dpo_backlink->has_section_at_zero;\n+      dwarf2_per_objfile->per_bfd->has_section_at_zero\n+\t= dpo_backlink->per_bfd->has_section_at_zero;\n     }\n \n   expand_psymtab (objfile);\n@@ -8865,7 +8865,7 @@ queue_comp_unit (struct dwarf2_per_cu_data *per_cu,\n \t\t enum language pretend_language)\n {\n   per_cu->queued = 1;\n-  per_cu->dwarf2_per_objfile->queue.emplace (per_cu, pretend_language);\n+  per_cu->dwarf2_per_objfile->per_bfd->queue.emplace (per_cu, pretend_language);\n }\n \n /* If PER_CU is not yet queued, add it to the queue.\n@@ -8885,7 +8885,7 @@ maybe_queue_comp_unit (struct dwarf2_cu *dependent_cu,\n   /* We may arrive here during partial symbol reading, if we need full\n      DIEs to process an unusual case (e.g. template arguments).  Do\n      not queue PER_CU, just tell our caller to load its DIEs.  */\n-  if (per_cu->dwarf2_per_objfile->reading_partial_symbols)\n+  if (per_cu->dwarf2_per_objfile->per_bfd->reading_partial_symbols)\n     {\n       if (per_cu->cu == NULL || per_cu->cu->dies == NULL)\n \treturn 1;\n@@ -8929,11 +8929,11 @@ process_queue (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \n   /* The queue starts out with one item, but following a DIE reference\n      may load a new CU, adding it to the end of the queue.  */\n-  while (!dwarf2_per_objfile->queue.empty ())\n+  while (!dwarf2_per_objfile->per_bfd->queue.empty ())\n     {\n-      dwarf2_queue_item &item = dwarf2_per_objfile->queue.front ();\n+      dwarf2_queue_item &item = dwarf2_per_objfile->per_bfd->queue.front ();\n \n-      if ((dwarf2_per_objfile->using_index\n+      if ((dwarf2_per_objfile->per_bfd->using_index\n \t   ? !item.per_cu->v.quick->compunit_symtab\n \t   : (item.per_cu->v.psymtab && !item.per_cu->v.psymtab->readin))\n \t  /* Skip dummy CUs.  */\n@@ -8975,7 +8975,7 @@ process_queue (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \t}\n \n       item.per_cu->queued = 0;\n-      dwarf2_per_objfile->queue.pop ();\n+      dwarf2_per_objfile->per_bfd->queue.pop ();\n     }\n \n   if (dwarf_read_debug)\n@@ -9541,7 +9541,7 @@ rust_union_quirks (struct dwarf2_cu *cu)\n static struct compunit_symtab *\n get_compunit_symtab (struct dwarf2_per_cu_data *per_cu)\n {\n-  return (per_cu->dwarf2_per_objfile->using_index\n+  return (per_cu->dwarf2_per_objfile->per_bfd->using_index\n \t  ? per_cu->v.quick->compunit_symtab\n \t  : per_cu->v.psymtab->compunit_symtab);\n }\n@@ -9649,13 +9649,13 @@ compute_compunit_symtab_includes (struct dwarf2_per_cu_data *per_cu)\n static void\n process_cu_includes (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n-  for (dwarf2_per_cu_data *iter : dwarf2_per_objfile->just_read_cus)\n+  for (dwarf2_per_cu_data *iter : dwarf2_per_objfile->per_bfd->just_read_cus)\n     {\n       if (! iter->is_debug_types)\n \tcompute_compunit_symtab_includes (iter);\n     }\n \n-  dwarf2_per_objfile->just_read_cus.clear ();\n+  dwarf2_per_objfile->per_bfd->just_read_cus.clear ();\n }\n \n /* Generate full symbol information for PER_CU, whose DIEs have\n@@ -9749,7 +9749,7 @@ process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,\n       cust->call_site_htab = cu->call_site_htab;\n     }\n \n-  if (dwarf2_per_objfile->using_index)\n+  if (dwarf2_per_objfile->per_bfd->using_index)\n     per_cu->v.quick->compunit_symtab = cust;\n   else\n     {\n@@ -9759,7 +9759,7 @@ process_full_comp_unit (struct dwarf2_per_cu_data *per_cu,\n     }\n \n   /* Push it for inclusion processing later.  */\n-  dwarf2_per_objfile->just_read_cus.push_back (per_cu);\n+  dwarf2_per_objfile->per_bfd->just_read_cus.push_back (per_cu);\n \n   /* Not needed any more.  */\n   cu->reset_builder ();\n@@ -9829,7 +9829,7 @@ process_full_type_unit (struct dwarf2_per_cu_data *per_cu,\n       cust = sig_type->type_unit_group->compunit_symtab;\n     }\n \n-  if (dwarf2_per_objfile->using_index)\n+  if (dwarf2_per_objfile->per_bfd->using_index)\n     per_cu->v.quick->compunit_symtab = cust;\n   else\n     {\n@@ -10134,7 +10134,7 @@ dw2_linkage_name (struct die_info *die, struct dwarf2_cu *cu)\n    For Ada, return the DIE's linkage name rather than the fully qualified\n    name.  PHYSNAME is ignored..\n \n-   The result is allocated on the dwarf2_per_objfile obstack and\n+   The result is allocated on the objfile->per_bfd's obstack and\n    canonicalized.  */\n \n static const char *\n@@ -10797,10 +10797,10 @@ handle_DW_AT_stmt_list (struct die_info *die, struct dwarf2_cu *cu,\n      compile_unit, then use the line header hash table if it's already\n      created, but don't create one just yet.  */\n \n-  if (dwarf2_per_objfile->line_header_hash == NULL\n+  if (dwarf2_per_objfile->per_bfd->line_header_hash == NULL\n       && die->tag == DW_TAG_partial_unit)\n     {\n-      dwarf2_per_objfile->line_header_hash\n+      dwarf2_per_objfile->per_bfd->line_header_hash\n \t.reset (htab_create_alloc (127, line_header_hash_voidp,\n \t\t\t\t   line_header_eq_voidp,\n \t\t\t\t   free_line_header_voidp,\n@@ -10810,9 +10810,9 @@ handle_DW_AT_stmt_list (struct die_info *die, struct dwarf2_cu *cu,\n   line_header_local.sect_off = line_offset;\n   line_header_local.offset_in_dwz = cu->per_cu->is_dwz;\n   line_header_local_hash = line_header_hash (&line_header_local);\n-  if (dwarf2_per_objfile->line_header_hash != NULL)\n+  if (dwarf2_per_objfile->per_bfd->line_header_hash != NULL)\n     {\n-      slot = htab_find_slot_with_hash (dwarf2_per_objfile->line_header_hash.get (),\n+      slot = htab_find_slot_with_hash (dwarf2_per_objfile->per_bfd->line_header_hash.get (),\n \t\t\t\t       &line_header_local,\n \t\t\t\t       line_header_local_hash, NO_INSERT);\n \n@@ -10836,11 +10836,11 @@ handle_DW_AT_stmt_list (struct die_info *die, struct dwarf2_cu *cu,\n   cu->line_header = lh.release ();\n   cu->line_header_die_owner = die;\n \n-  if (dwarf2_per_objfile->line_header_hash == NULL)\n+  if (dwarf2_per_objfile->per_bfd->line_header_hash == NULL)\n     slot = NULL;\n   else\n     {\n-      slot = htab_find_slot_with_hash (dwarf2_per_objfile->line_header_hash.get (),\n+      slot = htab_find_slot_with_hash (dwarf2_per_objfile->per_bfd->line_header_hash.get (),\n \t\t\t\t       &line_header_local,\n \t\t\t\t       line_header_local_hash, INSERT);\n       gdb_assert (slot != NULL);\n@@ -11157,12 +11157,12 @@ lookup_dwo_file_slot (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   struct dwo_file find_entry;\n   void **slot;\n \n-  if (dwarf2_per_objfile->dwo_files == NULL)\n-    dwarf2_per_objfile->dwo_files = allocate_dwo_file_hash_table ();\n+  if (dwarf2_per_objfile->per_bfd->dwo_files == NULL)\n+    dwarf2_per_objfile->per_bfd->dwo_files = allocate_dwo_file_hash_table ();\n \n   find_entry.dwo_name = dwo_name;\n   find_entry.comp_dir = comp_dir;\n-  slot = htab_find_slot (dwarf2_per_objfile->dwo_files.get (), &find_entry,\n+  slot = htab_find_slot (dwarf2_per_objfile->per_bfd->dwo_files.get (), &find_entry,\n \t\t\t INSERT);\n \n   return slot;\n@@ -11290,7 +11290,7 @@ create_cus_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       if (cus_htab == NULL)\n \tcus_htab = allocate_dwo_unit_table ();\n \n-      dwo_unit = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack,\n+      dwo_unit = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t\t\t struct dwo_unit);\n       *dwo_unit = read_unit;\n       slot = htab_find_slot (cus_htab.get (), dwo_unit, INSERT);\n@@ -11494,7 +11494,7 @@ create_dwp_hash_table (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t     pulongest (nr_slots), dwp_file->name);\n     }\n \n-  htab = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack, struct dwp_hash_table);\n+  htab = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack, struct dwp_hash_table);\n   htab->version = version;\n   htab->nr_columns = nr_columns;\n   htab->nr_units = nr_units;\n@@ -11824,11 +11824,11 @@ create_dwo_unit_in_dwp_v1 (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       dwo_file = (struct dwo_file *) *dwo_file_slot;\n     }\n \n-  dwo_unit = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack, struct dwo_unit);\n+  dwo_unit = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack, struct dwo_unit);\n   dwo_unit->dwo_file = dwo_file;\n   dwo_unit->signature = signature;\n   dwo_unit->section =\n-    XOBNEW (&dwarf2_per_objfile->obstack, struct dwarf2_section_info);\n+    XOBNEW (&dwarf2_per_objfile->per_bfd->obstack, struct dwarf2_section_info);\n   *dwo_unit->section = sections.info_or_types;\n   /* dwo_unit->{offset,length,type_offset_in_tu} are set later.  */\n \n@@ -12032,11 +12032,11 @@ create_dwo_unit_in_dwp_v2 (struct dwarf2_per_objfile *dwarf2_per_objfile,\n       dwo_file = (struct dwo_file *) *dwo_file_slot;\n     }\n \n-  dwo_unit = OBSTACK_ZALLOC (&dwarf2_per_objfile->obstack, struct dwo_unit);\n+  dwo_unit = OBSTACK_ZALLOC (&dwarf2_per_objfile->per_bfd->obstack, struct dwo_unit);\n   dwo_unit->dwo_file = dwo_file;\n   dwo_unit->signature = signature;\n   dwo_unit->section =\n-    XOBNEW (&dwarf2_per_objfile->obstack, struct dwarf2_section_info);\n+    XOBNEW (&dwarf2_per_objfile->per_bfd->obstack, struct dwarf2_section_info);\n   *dwo_unit->section = create_dwp_v2_section (dwarf2_per_objfile,\n \t\t\t\t\t      is_debug_types\n \t\t\t\t\t      ? &dwp_file->sections.types\n@@ -12542,7 +12542,7 @@ open_and_init_dwp_file (struct dwarf2_per_objfile *dwarf2_per_objfile)\n \n   dwp_file->num_sections = elf_numsections (dwp_file->dbfd);\n   dwp_file->elf_sections =\n-    OBSTACK_CALLOC (&dwarf2_per_objfile->obstack,\n+    OBSTACK_CALLOC (&dwarf2_per_objfile->per_bfd->obstack,\n \t\t    dwp_file->num_sections, asection *);\n \n   bfd_map_over_sections (dwp_file->dbfd.get (),\n@@ -12600,13 +12600,13 @@ open_and_init_dwp_file (struct dwarf2_per_objfile *dwarf2_per_objfile)\n static struct dwp_file *\n get_dwp_file (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n-  if (! dwarf2_per_objfile->dwp_checked)\n+  if (! dwarf2_per_objfile->per_bfd->dwp_checked)\n     {\n-      dwarf2_per_objfile->dwp_file\n+      dwarf2_per_objfile->per_bfd->dwp_file\n \t= open_and_init_dwp_file (dwarf2_per_objfile);\n-      dwarf2_per_objfile->dwp_checked = 1;\n+      dwarf2_per_objfile->per_bfd->dwp_checked = 1;\n     }\n-  return dwarf2_per_objfile->dwp_file.get ();\n+  return dwarf2_per_objfile->per_bfd->dwp_file.get ();\n }\n \n /* Subroutine of lookup_dwo_comp_unit, lookup_dwo_type_unit.\n@@ -13602,7 +13602,7 @@ read_variable (struct die_info *die, struct dwarf2_cu *cu)\n       struct die_info *origin_die\n \t= follow_die_ref (die, abstract_origin, &origin_cu);\n       dwarf2_per_objfile *dpo = cu->per_cu->dwarf2_per_objfile;\n-      dpo->abstract_to_concrete[origin_die->sect_off].push_back (die->sect_off);\n+      dpo->per_bfd->abstract_to_concrete[origin_die->sect_off].push_back (die->sect_off);\n     }\n }\n \n@@ -13630,23 +13630,23 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n \n   base = cu->base_address;\n \n-  dwarf2_per_objfile->rnglists.read (objfile);\n-  if (offset >= dwarf2_per_objfile->rnglists.size)\n+  dwarf2_per_objfile->per_bfd->rnglists.read (objfile);\n+  if (offset >= dwarf2_per_objfile->per_bfd->rnglists.size)\n     {\n       complaint (_(\"Offset %d out of bounds for DW_AT_ranges attribute\"),\n \t\t offset);\n       return false;\n     }\n-  buffer = dwarf2_per_objfile->rnglists.buffer + offset;\n+  buffer = dwarf2_per_objfile->per_bfd->rnglists.buffer + offset;\n \n   baseaddr = objfile->text_section_offset ();\n \n   while (1)\n     {\n       /* Initialize it due to a false compiler warning.  */\n       CORE_ADDR range_beginning = 0, range_end = 0;\n-      const gdb_byte *buf_end = (dwarf2_per_objfile->rnglists.buffer\n-\t\t\t\t + dwarf2_per_objfile->rnglists.size);\n+      const gdb_byte *buf_end = (dwarf2_per_objfile->per_bfd->rnglists.buffer\n+\t\t\t\t + dwarf2_per_objfile->per_bfd->rnglists.size);\n       unsigned int bytes_read;\n \n       if (buffer == buf_end)\n@@ -13748,7 +13748,7 @@ dwarf2_rnglists_process (unsigned offset, struct dwarf2_cu *cu,\n       /* A not-uncommon case of bad debug info.\n \t Don't pollute the addrmap with bad data.  */\n       if (range_beginning + baseaddr == 0\n-\t  && !dwarf2_per_objfile->has_section_at_zero)\n+\t  && !dwarf2_per_objfile->per_bfd->has_section_at_zero)\n \t{\n \t  complaint (_(\".debug_rnglists entry has start address of zero\"\n \t\t       \" [in module %s]\"), objfile_name (objfile));\n@@ -13797,14 +13797,14 @@ dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu,\n \n   base = cu->base_address;\n \n-  dwarf2_per_objfile->ranges.read (objfile);\n-  if (offset >= dwarf2_per_objfile->ranges.size)\n+  dwarf2_per_objfile->per_bfd->ranges.read (objfile);\n+  if (offset >= dwarf2_per_objfile->per_bfd->ranges.size)\n     {\n       complaint (_(\"Offset %d out of bounds for DW_AT_ranges attribute\"),\n \t\t offset);\n       return 0;\n     }\n-  buffer = dwarf2_per_objfile->ranges.buffer + offset;\n+  buffer = dwarf2_per_objfile->per_bfd->ranges.buffer + offset;\n \n   baseaddr = objfile->text_section_offset ();\n \n@@ -13859,7 +13859,7 @@ dwarf2_ranges_process (unsigned offset, struct dwarf2_cu *cu,\n       /* A not-uncommon case of bad debug info.\n \t Don't pollute the addrmap with bad data.  */\n       if (range_beginning + baseaddr == 0\n-\t  && !dwarf2_per_objfile->has_section_at_zero)\n+\t  && !dwarf2_per_objfile->per_bfd->has_section_at_zero)\n \t{\n \t  complaint (_(\".debug_ranges entry has start address of zero\"\n \t\t       \" [in module %s]\"), objfile_name (objfile));\n@@ -14012,7 +14012,7 @@ dwarf2_get_pc_bounds (struct die_info *die, CORE_ADDR *lowpc,\n      labels are not in the output, so the relocs get a value of 0.\n      If this is a discarded function, mark the pc bounds as invalid,\n      so that GDB will ignore it.  */\n-  if (low == 0 && !dwarf2_per_objfile->has_section_at_zero)\n+  if (low == 0 && !dwarf2_per_objfile->per_bfd->has_section_at_zero)\n     return PC_BOUNDS_INVALID;\n \n   *lowpc = low;\n@@ -18552,7 +18552,7 @@ partial_die_info::read (const struct die_reader_specs *reader,\n \t labels are not in the output, so the relocs get a value of 0.\n \t If this is a discarded function, mark the pc bounds as invalid,\n \t so that GDB will ignore it.  */\n-      if (lowpc == 0 && !dwarf2_per_objfile->has_section_at_zero)\n+      if (lowpc == 0 && !dwarf2_per_objfile->per_bfd->has_section_at_zero)\n \t{\n \t  struct objfile *objfile = dwarf2_per_objfile->objfile;\n \t  struct gdbarch *gdbarch = objfile->arch ();\n@@ -18799,7 +18799,7 @@ partial_die_info::fixup (struct dwarf2_cu *cu)\n      children, see if we can determine the namespace from their linkage\n      name.  */\n   if (cu->language == language_cplus\n-      && !cu->per_cu->dwarf2_per_objfile->types.empty ()\n+      && !cu->per_cu->dwarf2_per_objfile->per_bfd->types.empty ()\n       && die_parent == NULL\n       && has_children\n       && (tag == DW_TAG_class_type\n@@ -19256,8 +19256,8 @@ static const char *\n read_indirect_string_at_offset (struct dwarf2_per_objfile *dwarf2_per_objfile,\n \t\t\t\tLONGEST str_offset)\n {\n-  return dwarf2_per_objfile->str.read_string (dwarf2_per_objfile->objfile,\n-\t\t\t\t\t      str_offset, \"DW_FORM_strp\");\n+  return dwarf2_per_objfile->per_bfd->str.read_string\n+    (dwarf2_per_objfile->objfile, str_offset, \"DW_FORM_strp\");\n }\n \n /* Return pointer to string at .debug_str offset as read from BUF.\n@@ -19279,13 +19279,13 @@ read_indirect_string (struct dwarf2_per_objfile *dwarf2_per_objfile, bfd *abfd,\n \n const char *\n dwarf2_per_objfile::read_line_string (const gdb_byte *buf,\n-\t\t\t   const struct comp_unit_head *cu_header,\n-\t\t\t   unsigned int *bytes_read_ptr)\n+\t\t\t\t      const struct comp_unit_head *cu_header,\n+\t\t\t\t      unsigned int *bytes_read_ptr)\n {\n   bfd *abfd = objfile->obfd;\n   LONGEST str_offset = cu_header->read_offset (abfd, buf, bytes_read_ptr);\n \n-  return line_str.read_string (objfile, str_offset, \"DW_FORM_line_strp\");\n+  return per_bfd->line_str.read_string (objfile, str_offset, \"DW_FORM_line_strp\");\n }\n \n /* Given index ADDR_INDEX in .debug_addr, fetch the value.\n@@ -19302,16 +19302,16 @@ read_addr_index_1 (struct dwarf2_per_objfile *dwarf2_per_objfile,\n   const gdb_byte *info_ptr;\n   ULONGEST addr_base_or_zero = addr_base.has_value () ? *addr_base : 0;\n \n-  dwarf2_per_objfile->addr.read (objfile);\n-  if (dwarf2_per_objfile->addr.buffer == NULL)\n+  dwarf2_per_objfile->per_bfd->addr.read (objfile);\n+  if (dwarf2_per_objfile->per_bfd->addr.buffer == NULL)\n     error (_(\"DW_FORM_addr_index used without .debug_addr section [in module %s]\"),\n \t   objfile_name (objfile));\n   if (addr_base_or_zero + addr_index * addr_size\n-      >= dwarf2_per_objfile->addr.size)\n+      >= dwarf2_per_objfile->per_bfd->addr.size)\n     error (_(\"DW_FORM_addr_index pointing outside of \"\n \t     \".debug_addr section [in module %s]\"),\n \t   objfile_name (objfile));\n-  info_ptr = (dwarf2_per_objfile->addr.buffer\n+  info_ptr = (dwarf2_per_objfile->per_bfd->addr.buffer\n \t      + addr_base_or_zero + addr_index * addr_size);\n   if (addr_size == 4)\n     return bfd_get_32 (abfd, info_ptr);\n@@ -19457,8 +19457,8 @@ read_stub_str_index (struct dwarf2_cu *cu, ULONGEST str_index)\n \t   (long) cu->header.offset_size, objf_name);\n \n   return read_str_index (cu,\n-\t\t\t &cu->per_cu->dwarf2_per_objfile->str,\n-\t\t\t &cu->per_cu->dwarf2_per_objfile->str_offsets,\n+\t\t\t &cu->per_cu->dwarf2_per_objfile->per_bfd->str,\n+\t\t\t &cu->per_cu->dwarf2_per_objfile->per_bfd->str_offsets,\n \t\t\t *cu->str_offsets_base, str_index);\n }\n \n@@ -19678,7 +19678,7 @@ get_debug_line_section (struct dwarf2_cu *cu)\n       section = &dwz->line;\n     }\n   else\n-    section = &dwarf2_per_objfile->line;\n+    section = &dwarf2_per_objfile->per_bfd->line;\n \n   return section;\n }\n@@ -20797,7 +20797,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \n \t      if (SYMBOL_CLASS (sym) == LOC_STATIC\n \t\t  && SYMBOL_VALUE_ADDRESS (sym) == 0\n-\t\t  && !dwarf2_per_objfile->has_section_at_zero)\n+\t\t  && !dwarf2_per_objfile->per_bfd->has_section_at_zero)\n \t\t{\n \t\t  /* When a static variable is eliminated by the linker,\n \t\t     the corresponding debug information is not stripped\n@@ -20808,7 +20808,7 @@ new_symbol (struct die_info *die, struct type *type, struct dwarf2_cu *cu,\n \t\t{\n \t\t  if (SYMBOL_CLASS (sym) == LOC_STATIC\n \t\t      && (objfile->flags & OBJF_MAINLINE) == 0\n-\t\t      && dwarf2_per_objfile->can_copy)\n+\t\t      && dwarf2_per_objfile->per_bfd->can_copy)\n \t\t    {\n \t\t      /* A global static variable might be subject to\n \t\t\t copy relocation.  We first check for a local\n@@ -21720,7 +21720,7 @@ determine_prefix (struct die_info *die, struct dwarf2_cu *cu)\n       case DW_TAG_partial_unit:\n \t/* gcc-4.5 -gdwarf-4 can drop the enclosing namespace.  Cope.  */\n \tif (cu->language == language_cplus\n-\t    && !dwarf2_per_objfile->types.empty ()\n+\t    && !dwarf2_per_objfile->per_bfd->types.empty ()\n \t    && die->child != NULL\n \t    && (die->tag == DW_TAG_class_type\n \t\t|| die->tag == DW_TAG_structure_type\n@@ -22199,7 +22199,7 @@ follow_die_offset (sect_offset sect_off, int offset_in_dwz,\n   else if (cu->dies == NULL)\n     {\n       /* We're loading full DIEs during partial symbol reading.  */\n-      gdb_assert (dwarf2_per_objfile->reading_partial_symbols);\n+      gdb_assert (dwarf2_per_objfile->per_bfd->reading_partial_symbols);\n       load_full_comp_unit (cu->per_cu, false, language_minimal);\n     }\n \n@@ -22272,15 +22272,15 @@ dwarf2_fetch_die_loc_sect_off (sect_offset sect_off,\n \n   attr = dwarf2_attr (die, DW_AT_location, cu);\n   if (!attr && resolve_abstract_p\n-      && (dwarf2_per_objfile->abstract_to_concrete.find (die->sect_off)\n-\t  != dwarf2_per_objfile->abstract_to_concrete.end ()))\n+      && (dwarf2_per_objfile->per_bfd->abstract_to_concrete.find (die->sect_off)\n+\t  != dwarf2_per_objfile->per_bfd->abstract_to_concrete.end ()))\n     {\n       CORE_ADDR pc = (*get_frame_pc) (baton);\n       CORE_ADDR baseaddr = objfile->text_section_offset ();\n       struct gdbarch *gdbarch = objfile->arch ();\n \n       for (const auto &cand_off\n-\t     : dwarf2_per_objfile->abstract_to_concrete[die->sect_off])\n+\t     : dwarf2_per_objfile->per_bfd->abstract_to_concrete[die->sect_off])\n \t{\n \t  struct dwarf2_cu *cand_cu = cu;\n \t  struct die_info *cand\n@@ -22572,8 +22572,8 @@ follow_die_sig_1 (struct die_info *src_die, struct signatured_type *sig_type,\n \n       /* For .gdb_index version 7 keep track of included TUs.\n \t http://sourceware.org/bugzilla/show_bug.cgi?id=15021.  */\n-      if (dwarf2_per_objfile->index_table != NULL\n-\t  && dwarf2_per_objfile->index_table->version <= 7)\n+      if (dwarf2_per_objfile->per_bfd->index_table != NULL\n+\t  && dwarf2_per_objfile->per_bfd->index_table->version <= 7)\n \t{\n \t  (*ref_cu)->per_cu->imported_symtabs_push (sig_cu->per_cu);\n \t}\n@@ -23130,12 +23130,12 @@ dwarf_decode_macros (struct dwarf2_cu *cu, unsigned int offset,\n     {\n       if (section_is_gnu)\n \t{\n-\t  section = &dwarf2_per_objfile->macro;\n+\t  section = &dwarf2_per_objfile->per_bfd->macro;\n \t  section_name = \".debug_macro\";\n \t}\n       else\n \t{\n-\t  section = &dwarf2_per_objfile->macinfo;\n+\t  section = &dwarf2_per_objfile->per_bfd->macinfo;\n \t  section_name = \".debug_macinfo\";\n \t}\n     }\n@@ -23168,8 +23168,8 @@ cu_debug_loc_section (struct dwarf2_cu *cu)\n \n       return cu->header.version >= 5 ? &sections->loclists : &sections->loc;\n     }\n-  return (cu->header.version >= 5 ? &dwarf2_per_objfile->loclists\n-\t\t\t\t  : &dwarf2_per_objfile->loc);\n+  return (cu->header.version >= 5 ? &dwarf2_per_objfile->per_bfd->loclists\n+\t\t\t\t  : &dwarf2_per_objfile->per_bfd->loc);\n }\n \n /* A helper function that fills in a dwarf2_loclist_baton.  */\n@@ -23411,9 +23411,9 @@ dwarf2_find_containing_comp_unit (sect_offset sect_off,\n {\n   int low\n     = dwarf2_find_containing_comp_unit (sect_off, offset_in_dwz,\n-\t\t\t\t\tdwarf2_per_objfile->all_comp_units);\n+\t\t\t\t\tdwarf2_per_objfile->per_bfd->all_comp_units);\n   struct dwarf2_per_cu_data *this_cu\n-    = dwarf2_per_objfile->all_comp_units[low];\n+    = dwarf2_per_objfile->per_bfd->all_comp_units[low];\n \n   if (this_cu->is_dwz != offset_in_dwz || this_cu->sect_off > sect_off)\n     {\n@@ -23423,13 +23423,13 @@ dwarf2_find_containing_comp_unit (sect_offset sect_off,\n \t       sect_offset_str (sect_off),\n \t       bfd_get_filename (dwarf2_per_objfile->objfile->obfd));\n \n-      gdb_assert (dwarf2_per_objfile->all_comp_units[low-1]->sect_off\n+      gdb_assert (dwarf2_per_objfile->per_bfd->all_comp_units[low-1]->sect_off\n \t\t  <= sect_off);\n-      return dwarf2_per_objfile->all_comp_units[low-1];\n+      return dwarf2_per_objfile->per_bfd->all_comp_units[low-1];\n     }\n   else\n     {\n-      if (low == dwarf2_per_objfile->all_comp_units.size () - 1\n+      if (low == dwarf2_per_objfile->per_bfd->all_comp_units.size () - 1\n \t  && sect_off >= this_cu->sect_off + this_cu->length)\n \terror (_(\"invalid dwarf2 offset %s\"), sect_offset_str (sect_off));\n       gdb_assert (sect_off < this_cu->sect_off + this_cu->length);\n@@ -23541,8 +23541,8 @@ age_cached_comp_units (struct dwarf2_per_objfile *dwarf2_per_objfile)\n {\n   struct dwarf2_per_cu_data *per_cu, **last_chain;\n \n-  dwarf2_clear_marks (dwarf2_per_objfile->read_in_chain);\n-  per_cu = dwarf2_per_objfile->read_in_chain;\n+  dwarf2_clear_marks (dwarf2_per_objfile->per_bfd->read_in_chain);\n+  per_cu = dwarf2_per_objfile->per_bfd->read_in_chain;\n   while (per_cu != NULL)\n     {\n       per_cu->cu->last_used ++;\n@@ -23551,8 +23551,8 @@ age_cached_comp_units (struct dwarf2_per_objfile *dwarf2_per_objfile)\n       per_cu = per_cu->cu->read_in_chain;\n     }\n \n-  per_cu = dwarf2_per_objfile->read_in_chain;\n-  last_chain = &dwarf2_per_objfile->read_in_chain;\n+  per_cu = dwarf2_per_objfile->per_bfd->read_in_chain;\n+  last_chain = &dwarf2_per_objfile->per_bfd->read_in_chain;\n   while (per_cu != NULL)\n     {\n       struct dwarf2_per_cu_data *next_cu;\n@@ -23580,8 +23580,8 @@ free_one_cached_comp_unit (struct dwarf2_per_cu_data *target_per_cu)\n   struct dwarf2_per_objfile *dwarf2_per_objfile\n     = target_per_cu->dwarf2_per_objfile;\n \n-  per_cu = dwarf2_per_objfile->read_in_chain;\n-  last_chain = &dwarf2_per_objfile->read_in_chain;\n+  per_cu = dwarf2_per_objfile->per_bfd->read_in_chain;\n+  last_chain = &dwarf2_per_objfile->per_bfd->read_in_chain;\n   while (per_cu != NULL)\n     {\n       struct dwarf2_per_cu_data *next_cu;\n@@ -23728,8 +23728,8 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n \t\t\t    cu->per_cu->addr_type ()))\n     type->add_dyn_prop (DYN_PROP_DATA_LOCATION, prop);\n \n-  if (dwarf2_per_objfile->die_type_hash == NULL)\n-    dwarf2_per_objfile->die_type_hash\n+  if (dwarf2_per_objfile->per_bfd->die_type_hash == NULL)\n+    dwarf2_per_objfile->per_bfd->die_type_hash\n       = htab_up (htab_create_alloc (127,\n \t\t\t\t    per_cu_offset_and_type_hash,\n \t\t\t\t    per_cu_offset_and_type_eq,\n@@ -23739,7 +23739,7 @@ set_die_type (struct die_info *die, struct type *type, struct dwarf2_cu *cu)\n   ofs.sect_off = die->sect_off;\n   ofs.type = type;\n   slot = (struct dwarf2_per_cu_offset_and_type **)\n-    htab_find_slot (dwarf2_per_objfile->die_type_hash.get (), &ofs, INSERT);\n+    htab_find_slot (dwarf2_per_objfile->per_bfd->die_type_hash.get (), &ofs, INSERT);\n   if (*slot)\n     complaint (_(\"A problem internal to GDB: DIE %s has type already set\"),\n \t       sect_offset_str (die->sect_off));\n@@ -23759,13 +23759,13 @@ get_die_type_at_offset (sect_offset sect_off,\n   struct dwarf2_per_cu_offset_and_type *slot, ofs;\n   struct dwarf2_per_objfile *dwarf2_per_objfile = per_cu->dwarf2_per_objfile;\n \n-  if (dwarf2_per_objfile->die_type_hash == NULL)\n+  if (dwarf2_per_objfile->per_bfd->die_type_hash == NULL)\n     return NULL;\n \n   ofs.per_cu = per_cu;\n   ofs.sect_off = sect_off;\n   slot = ((struct dwarf2_per_cu_offset_and_type *)\n-\t  htab_find (dwarf2_per_objfile->die_type_hash.get (), &ofs));\n+\t  htab_find (dwarf2_per_objfile->per_bfd->die_type_hash.get (), &ofs));\n   if (slot)\n     return slot->type;\n   else"
    },
    {
      "sha": "4dc9496046f8590efb0acb66eb219ac89923aafe",
      "filename": "gdb/dwarf2/read.h",
      "status": "modified",
      "additions": 44,
      "deletions": 25,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/dwarf2/read.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2/gdb/dwarf2/read.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2/read.h?ref=5989a64ed5ee7a7f9c0fc284f66ef4bd414ad6c2",
      "patch": "@@ -66,32 +66,34 @@ struct dwarf2_queue_item\n   enum language pretend_language;\n };\n \n-/* Collection of data recorded per objfile.\n-   This hangs off of dwarf2_objfile_data_key.  */\n+/* Some DWARF data can be shared across objfiles who share the same BFD,\n+   this data is stored in this object.\n \n-struct dwarf2_per_objfile\n+   Two dwarf2_per_objfile objects representing objfiles sharing the same BFD\n+   will point to the same instance of dwarf2_per_bfd, unless the BFD requires\n+   relocation.  */\n+\n+struct dwarf2_per_bfd\n {\n-  /* Construct a dwarf2_per_objfile for OBJFILE.  NAMES points to the\n+  /* Construct a dwarf2_per_bfd for OBFD.  NAMES points to the\n      dwarf2 section names, or is NULL if the standard ELF names are\n      used.  CAN_COPY is true for formats where symbol\n      interposition is possible and so symbol values must follow copy\n      relocation rules.  */\n-  dwarf2_per_objfile (struct objfile *objfile,\n-\t\t      const dwarf2_debug_sections *names,\n-\t\t      bool can_copy);\n+  dwarf2_per_bfd (bfd *obfd, const dwarf2_debug_sections *names, bool can_copy);\n \n-  ~dwarf2_per_objfile ();\n+  ~dwarf2_per_bfd ();\n \n-  DISABLE_COPY_AND_ASSIGN (dwarf2_per_objfile);\n+  DISABLE_COPY_AND_ASSIGN (dwarf2_per_bfd);\n \n   /* Return the CU/TU given its index.\n \n      This is intended for loops like:\n \n-     for (i = 0; i < (dwarf2_per_objfile->n_comp_units\n-\t\t      + dwarf2_per_objfile->n_type_units); ++i)\n+     for (i = 0; i < (dwarf2_per_bfd->n_comp_units\n+\t\t      + dwarf2_per_bfd->n_type_units); ++i)\n        {\n-         dwarf2_per_cu_data *per_cu = dwarf2_per_objfile->get_cutu (i);\n+         dwarf2_per_cu_data *per_cu = dwarf2_per_bfd->get_cutu (i);\n \n          ...;\n        }\n@@ -113,21 +115,14 @@ struct dwarf2_per_objfile\n \n   /* A convenience function to allocate a dwarf2_per_cu_data.  The\n      returned object has its \"index\" field set properly.  The object\n-     is allocated on the dwarf2_per_objfile obstack.  */\n+     is allocated on the dwarf2_per_bfd obstack.  */\n   dwarf2_per_cu_data *allocate_per_cu ();\n \n   /* A convenience function to allocate a signatured_type.  The\n      returned object has its \"index\" field set properly.  The object\n-     is allocated on the dwarf2_per_objfile obstack.  */\n+     is allocated on the dwarf2_per_bfd obstack.  */\n   signatured_type *allocate_signatured_type ();\n \n-  /* Return pointer to string at .debug_line_str offset as read from BUF.\n-     BUF is assumed to be in a compilation unit described by CU_HEADER.\n-     Return *BYTES_READ_PTR count of bytes read from BUF.  */\n-  const char *read_line_string (const gdb_byte *buf,\n-\t\t\t\tconst struct comp_unit_head *cu_header,\n-\t\t\t\tunsigned int *bytes_read_ptr);\n-\n private:\n   /* This function is mapped across the sections and remembers the\n      offset and size of each of the debugging sections we are\n@@ -162,9 +157,6 @@ struct dwarf2_per_objfile\n \n   std::vector<dwarf2_section_info> types;\n \n-  /* Back link.  */\n-  struct objfile *objfile = NULL;\n-\n   /* Table of all the compilation units.  This is used to locate\n      the target compilation unit of a particular reference.  */\n   std::vector<dwarf2_per_cu_data *> all_comp_units;\n@@ -267,6 +259,33 @@ struct dwarf2_per_objfile\n   size_t m_num_psymtabs = 0;\n };\n \n+/* Collection of data recorded per objfile.\n+   This hangs off of dwarf2_objfile_data_key.\n+\n+   Some DWARF data cannot (currently) be shared across objfiles.  Such\n+   data is stored in this object.  */\n+\n+struct dwarf2_per_objfile\n+{\n+  dwarf2_per_objfile (struct objfile *objfile, dwarf2_per_bfd *per_bfd)\n+    : objfile (objfile), per_bfd (per_bfd)\n+  {}\n+\n+  /* Return pointer to string at .debug_line_str offset as read from BUF.\n+     BUF is assumed to be in a compilation unit described by CU_HEADER.\n+     Return *BYTES_READ_PTR count of bytes read from BUF.  */\n+  const char *read_line_string (const gdb_byte *buf,\n+\t\t\t\tconst struct comp_unit_head *cu_header,\n+\t\t\t\tunsigned int *bytes_read_ptr);\n+\n+  /* Back link.  */\n+  struct objfile *objfile;\n+\n+  /* Pointer to the data that is (possibly) shared between this objfile and\n+     other objfiles backed by the same BFD.  */\n+  struct dwarf2_per_bfd *per_bfd;\n+};\n+\n /* Get the dwarf2_per_objfile associated to OBJFILE.  */\n \n dwarf2_per_objfile *get_dwarf2_per_objfile (struct objfile *objfile);\n@@ -360,7 +379,7 @@ struct dwarf2_per_cu_data\n   /* The corresponding dwarf2_per_objfile.  */\n   struct dwarf2_per_objfile *dwarf2_per_objfile;\n \n-  /* When dwarf2_per_objfile->using_index is true, the 'quick' field\n+  /* When dwarf2_per_bfd::using_index is true, the 'quick' field\n      is active.  Otherwise, the 'psymtab' field is active.  */\n   union\n   {"
    }
  ]
}