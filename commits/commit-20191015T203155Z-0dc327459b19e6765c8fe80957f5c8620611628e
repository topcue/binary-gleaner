{
  "sha": "0dc327459b19e6765c8fe80957f5c8620611628e",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6MGRjMzI3NDU5YjE5ZTY3NjVjOGZlODA5NTdmNWM4NjIwNjExNjI4ZQ==",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-10-07T15:38:53Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "andrew.burgess@embecosm.com",
      "date": "2019-10-15T20:31:55Z"
    },
    "message": "gdb: Remove vec.{c,h} and update code to not include vec.h\n\nRemoves vec.c and vec.h from the source tree, and remove all the\nremaining includes of vec.h.  There should be no user visible changes\nafter this commit.\n\nI did have a few issues rebuilding GDB after applying this patch due\nto cached dependencies, I found that running this command in the build\ndirectory resolved my build issues without requiring a 'make clean':\n\n    rm -fr gdb/gdbserver/gdbsupport/.deps/\n\ngdb/ChangeLog:\n\n\t* Makefile.in: Remove references to vec.h and vec.c.\n\t* aarch64-tdep.c: No longer include vec.h.\n\t* ada-lang.c: Likewise.\n\t* ada-lang.h: Likewise.\n\t* arm-tdep.c: Likewise.\n\t* ax.h: Likewise.\n\t* breakpoint.h: Likewise.\n\t* charset.c: Likewise.\n\t* cp-support.h: Likewise.\n\t* dtrace-probe.c: Likewise.\n\t* dwarf2read.c: Likewise.\n\t* extension.h: Likewise.\n\t* gdb_bfd.c: Likewise.\n\t* gdbsupport/gdb_vecs.h: Likewise.\n\t* gdbsupport/vec.c: Remove.\n\t* gdbsupport/vec.h: Remove.\n\t* gdbthread.h: Likewise.\n\t* guile/scm-type.c: Likewise.\n\t* inline-frame.c: Likewise.\n\t* machoread.c: Likewise.\n\t* memattr.c: Likewise.\n\t* memrange.h: Likewise.\n\t* namespace.h: Likewise.\n\t* nat/linux-btrace.h: Likewise.\n\t* osdata.c: Likewise.\n\t* parser-defs.h: Likewise.\n\t* progspace.h: Likewise.\n\t* python/py-type.c: Likewise.\n\t* record-btrace.c: Likewise.\n\t* rust-exp.y: Likewise.\n\t* solib-target.c: Likewise.\n\t* stap-probe.c: Likewise.\n\t* target-descriptions.c: Likewise.\n\t* target-memory.c: Likewise.\n\t* target.h: Likewise.\n\t* varobj.c: Likewise.\n\t* varobj.h: Likewise.\n\t* xml-support.h: Likewise.\n\ngdb/gdbserver/ChangeLog:\n\n\t* Makefile.in: Remove references to vec.c.\n\nChange-Id: I0c91d7170bf1b5e992a387fcd9fe4f2abe343bb5",
    "tree": {
      "sha": "5ba10c0740be182a742dc68727f70c861815c003",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/5ba10c0740be182a742dc68727f70c861815c003"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/0dc327459b19e6765c8fe80957f5c8620611628e",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0dc327459b19e6765c8fe80957f5c8620611628e",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/0dc327459b19e6765c8fe80957f5c8620611628e",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/0dc327459b19e6765c8fe80957f5c8620611628e/comments",
  "author": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "T-J-Teru",
    "id": 475372,
    "node_id": "MDQ6VXNlcjQ3NTM3Mg==",
    "avatar_url": "https://avatars.githubusercontent.com/u/475372?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/T-J-Teru",
    "html_url": "https://github.com/T-J-Teru",
    "followers_url": "https://api.github.com/users/T-J-Teru/followers",
    "following_url": "https://api.github.com/users/T-J-Teru/following{/other_user}",
    "gists_url": "https://api.github.com/users/T-J-Teru/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/T-J-Teru/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/T-J-Teru/subscriptions",
    "organizations_url": "https://api.github.com/users/T-J-Teru/orgs",
    "repos_url": "https://api.github.com/users/T-J-Teru/repos",
    "events_url": "https://api.github.com/users/T-J-Teru/events{/privacy}",
    "received_events_url": "https://api.github.com/users/T-J-Teru/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "ae6400219c19f165692254740531b2a7ad74945e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/ae6400219c19f165692254740531b2a7ad74945e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/ae6400219c19f165692254740531b2a7ad74945e"
    }
  ],
  "stats": {
    "total": 1357,
    "additions": 45,
    "deletions": 1312
  },
  "files": [
    {
      "sha": "8328a9b3c875aefddfd074f56ceb58cb6ef68e5a",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 41,
      "deletions": 0,
      "changes": 41,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -1,3 +1,44 @@\n+2019-10-15  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* Makefile.in: Remove references to vec.h and vec.c.\n+\t* aarch64-tdep.c: No longer include vec.h.\n+\t* ada-lang.c: Likewise.\n+\t* ada-lang.h: Likewise.\n+\t* arm-tdep.c: Likewise.\n+\t* ax.h: Likewise.\n+\t* breakpoint.h: Likewise.\n+\t* charset.c: Likewise.\n+\t* cp-support.h: Likewise.\n+\t* dtrace-probe.c: Likewise.\n+\t* dwarf2read.c: Likewise.\n+\t* extension.h: Likewise.\n+\t* gdb_bfd.c: Likewise.\n+\t* gdbsupport/gdb_vecs.h: Likewise.\n+\t* gdbsupport/vec.c: Remove.\n+\t* gdbsupport/vec.h: Remove.\n+\t* gdbthread.h: Likewise.\n+\t* guile/scm-type.c: Likewise.\n+\t* inline-frame.c: Likewise.\n+\t* machoread.c: Likewise.\n+\t* memattr.c: Likewise.\n+\t* memrange.h: Likewise.\n+\t* namespace.h: Likewise.\n+\t* nat/linux-btrace.h: Likewise.\n+\t* osdata.c: Likewise.\n+\t* parser-defs.h: Likewise.\n+\t* progspace.h: Likewise.\n+\t* python/py-type.c: Likewise.\n+\t* record-btrace.c: Likewise.\n+\t* rust-exp.y: Likewise.\n+\t* solib-target.c: Likewise.\n+\t* stap-probe.c: Likewise.\n+\t* target-descriptions.c: Likewise.\n+\t* target-memory.c: Likewise.\n+\t* target.h: Likewise.\n+\t* varobj.c: Likewise.\n+\t* varobj.h: Likewise.\n+\t* xml-support.h: Likewise.\n+\n 2019-10-15  Andrew Burgess  <andrew.burgess@embecosm.com>\n \n \t* gdb/dwarf2read.c (dwarf2_per_objfile::~dwarf2_per_objfile):"
    },
    {
      "sha": "af4b14d6e6ca228e1eac5906e56ba9a0d13e5fbb",
      "filename": "gdb/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/Makefile.in?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -980,7 +980,6 @@ COMMON_SFILES = \\\n \tgdbsupport/signals.c \\\n \tgdbsupport/signals-state-save-restore.c \\\n \tgdbsupport/tdesc.c \\\n-\tgdbsupport/vec.c \\\n \tgdbsupport/xml-utils.c \\\n \tcomplaints.c \\\n \tcompleter.c \\\n@@ -1480,7 +1479,6 @@ HFILES_NO_SRCDIR = \\\n \tgdbsupport/signals-state-save-restore.h \\\n \tgdbsupport/symbol.h \\\n \tgdbsupport/tdesc.h \\\n-\tgdbsupport/vec.h \\\n \tgdbsupport/version.h \\\n \tgdbsupport/x86-xstate.h \\\n \tgdbsupport/xml-utils.h \\"
    },
    {
      "sha": "d1ee78de094a6475442b0d194999b913b9763dec",
      "filename": "gdb/aarch64-tdep.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/aarch64-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/aarch64-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/aarch64-tdep.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -52,8 +52,6 @@\n #include \"elf-bfd.h\"\n #include \"elf/aarch64.h\"\n \n-#include \"gdbsupport/vec.h\"\n-\n #include \"record.h\"\n #include \"record-full.h\"\n #include \"arch/aarch64-insn.h\""
    },
    {
      "sha": "a2ae89dd98c8c4b2b22a9efc8eef0117e12347ee",
      "filename": "gdb/ada-lang.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/ada-lang.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/ada-lang.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -49,7 +49,6 @@\n #include \"valprint.h\"\n #include \"source.h\"\n #include \"observable.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"stack.h\"\n #include \"gdbsupport/gdb_vecs.h\"\n #include \"typeprint.h\""
    },
    {
      "sha": "b68dd4e97d0c542b29b5a04e6ffee716bd22c8eb",
      "filename": "gdb/ada-lang.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/ada-lang.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/ada-lang.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ada-lang.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -28,7 +28,6 @@ struct parser_state;\n #include \"value.h\"\n #include \"gdbtypes.h\"\n #include \"breakpoint.h\"\n-#include \"gdbsupport/vec.h\"\n \n /* Names of specific files known to be part of the runtime\n    system and that might consider (confusing) debugging information."
    },
    {
      "sha": "5c1476af48b17f8a8d4d31169353ecf2b2a3b55b",
      "filename": "gdb/arm-tdep.c",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/arm-tdep.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/arm-tdep.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/arm-tdep.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -55,8 +55,6 @@\n #include \"coff/internal.h\"\n #include \"elf/arm.h\"\n \n-#include \"gdbsupport/vec.h\"\n-\n #include \"record.h\"\n #include \"record-full.h\"\n #include <algorithm>"
    },
    {
      "sha": "e5bdbf621934bee71607106811840cf8dc1c27f1",
      "filename": "gdb/ax.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/ax.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/ax.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ax.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -19,8 +19,6 @@\n #ifndef AX_H\n #define AX_H\n \n-#include \"gdbsupport/vec.h\"\n-\n /* It's sometimes useful to be able to debug programs that you can't\n    really stop for more than a fraction of a second.  To this end, the\n    user can specify a tracepoint (like a breakpoint, but you don't"
    },
    {
      "sha": "da26f643a2d68a448f16869d8b2aa8f01728a5c6",
      "filename": "gdb/breakpoint.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/breakpoint.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/breakpoint.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/breakpoint.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -21,7 +21,6 @@\n \n #include \"frame.h\"\n #include \"value.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"ax.h\"\n #include \"command.h\"\n #include \"gdbsupport/break-common.h\""
    },
    {
      "sha": "7568e47cf9ab436bf2c28bbaecfd7a99ed393801",
      "filename": "gdb/charset.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/charset.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/charset.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/charset.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -23,7 +23,6 @@\n #include \"gdb_obstack.h\"\n #include \"gdbsupport/gdb_wait.h\"\n #include \"charset-list.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"gdbsupport/environ.h\"\n #include \"arch-utils.h\"\n #include \"gdbsupport/gdb_vecs.h\""
    },
    {
      "sha": "a2be977a8fdee9adcd70c33682e3491d358b1b75",
      "filename": "gdb/cp-support.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/cp-support.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/cp-support.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/cp-support.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -25,7 +25,6 @@\n /* We need this for 'domain_enum', alas...  */\n \n #include \"symtab.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"gdbsupport/gdb_vecs.h\"\n #include \"gdb_obstack.h\"\n #include \"gdbsupport/array-view.h\""
    },
    {
      "sha": "9eaed2b9fc4508594cb65d158619bd507a28c212",
      "filename": "gdb/dtrace-probe.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/dtrace-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/dtrace-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dtrace-probe.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -21,7 +21,6 @@\n \n #include \"defs.h\"\n #include \"probe.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"elf-bfd.h\"\n #include \"gdbtypes.h\"\n #include \"obstack.h\""
    },
    {
      "sha": "0443b55d8915a15df6ab7b9758c175b7db9fe0da",
      "filename": "gdb/dwarf2read.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/dwarf2read.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/dwarf2read.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/dwarf2read.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -55,7 +55,6 @@\n #include \"addrmap.h\"\n #include \"typeprint.h\"\n #include \"psympriv.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"c-lang.h\"\n #include \"go-lang.h\"\n #include \"valprint.h\""
    },
    {
      "sha": "fc8e3e2c0ba877f56e07ba555b7074d5398605aa",
      "filename": "gdb/extension.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/extension.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/extension.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/extension.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -21,7 +21,6 @@\n #define EXTENSION_H\n \n #include \"mi/mi-cmds.h\" /* For PRINT_NO_VALUES, etc.  */\n-#include \"gdbsupport/vec.h\"\n #include \"gdbsupport/array-view.h\"\n \n struct breakpoint;"
    },
    {
      "sha": "2a070d7b929f2ce5fa4457a194e30fba2f432f19",
      "filename": "gdb/gdb_bfd.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdb_bfd.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdb_bfd.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdb_bfd.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -23,7 +23,6 @@\n #include \"gdbcmd.h\"\n #include \"hashtab.h\"\n #include \"gdbsupport/filestuff.h\"\n-#include \"gdbsupport/vec.h\"\n #ifdef HAVE_MMAP\n #include <sys/mman.h>\n #ifndef MAP_FAILED"
    },
    {
      "sha": "402546b57ced202ad6981b4b679e3a0340a8f7cd",
      "filename": "gdb/gdbserver/ChangeLog",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdbserver/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdbserver/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/ChangeLog?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -1,3 +1,7 @@\n+2019-10-15  Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* Makefile.in: Remove references to vec.c.\n+\n 2019-10-02  Christian Biesinger  <cbiesinger@google.com>\n \n \t* server.c (server_waiting): Change to bool."
    },
    {
      "sha": "c83cb3d3631997065a59626caf49dc3cca380965",
      "filename": "gdb/gdbserver/Makefile.in",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdbserver/Makefile.in",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdbserver/Makefile.in",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbserver/Makefile.in?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -221,7 +221,6 @@ SFILES = \\\n \t$(srcdir)/gdbsupport/ptid.c \\\n \t$(srcdir)/gdbsupport/rsp-low.c \\\n \t$(srcdir)/gdbsupport/tdesc.c \\\n-\t$(srcdir)/gdbsupport/vec.c \\\n \t$(srcdir)/gdbsupport/xml-utils.c \\\n \t$(srcdir)/nat/aarch64-sve-linux-ptrace.c \\\n \t$(srcdir)/nat/linux-btrace.c \\\n@@ -270,7 +269,6 @@ OBS = \\\n \tgdbsupport/signals.o \\\n \tgdbsupport/signals-state-save-restore.o \\\n \tgdbsupport/tdesc.o \\\n-\tgdbsupport/vec.o \\\n \tgdbsupport/xml-utils.o \\\n \tdebug.o \\\n \tdll.o \\"
    },
    {
      "sha": "e87ebe26e993bbc472b9c16d8c7fd5481415f685",
      "filename": "gdb/gdbsupport/gdb_vecs.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdbsupport/gdb_vecs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdbsupport/gdb_vecs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbsupport/gdb_vecs.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -20,8 +20,6 @@\n #ifndef COMMON_GDB_VECS_H\n #define COMMON_GDB_VECS_H\n \n-#include \"vec.h\"\n-\n /* Split STR, a list of DELIMITER-separated fields, into a char pointer vector.\n \n    You may modify the returned strings.  */"
    },
    {
      "sha": "a88954494955d29287f673647280cb6099343be6",
      "filename": "gdb/gdbsupport/vec.c",
      "status": "removed",
      "additions": 0,
      "deletions": 118,
      "changes": 118,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ae6400219c19f165692254740531b2a7ad74945e/gdb/gdbsupport/vec.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ae6400219c19f165692254740531b2a7ad74945e/gdb/gdbsupport/vec.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbsupport/vec.c?ref=ae6400219c19f165692254740531b2a7ad74945e",
      "patch": "@@ -1,118 +0,0 @@\n-/* Vector API for GDB.\n-   Copyright (C) 2004-2019 Free Software Foundation, Inc.\n-   Contributed by Nathan Sidwell <nathan@codesourcery.com>\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#include \"common-defs.h\"\n-#include \"vec.h\"\n-\n-struct vec_prefix\n-{\n-  unsigned num;\n-  unsigned alloc;\n-  void *vec[1];\n-};\n-\n-/* Calculate the new ALLOC value, making sure that abs(RESERVE) slots\n-   are free.  If RESERVE < 0 grow exactly, otherwise grow\n-   exponentially.  */\n-\n-static inline unsigned\n-calculate_allocation (const struct vec_prefix *pfx, int reserve)\n-{\n-  unsigned alloc = 0;\n-  unsigned num = 0;\n-\n-  if (pfx)\n-    {\n-      alloc = pfx->alloc;\n-      num = pfx->num;\n-    }\n-  else if (!reserve)\n-    /* If there's no prefix, and we've not requested anything, then we\n-       will create a NULL vector.  */\n-    return 0;\n-\n-  /* We must have run out of room.  */\n-  gdb_assert (alloc - num < (unsigned)(reserve < 0 ? -reserve : reserve));\n-\n-  if (reserve < 0)\n-    /* Exact size.  */\n-    alloc = num + -reserve;\n-  else\n-    {\n-      /* Exponential growth.  */\n-      if (!alloc)\n-\talloc = 4;\n-      else if (alloc < 16)\n-\t/* Double when small.  */\n-\talloc = alloc * 2;\n-      else\n-\t/* Grow slower when large.  */\n-\talloc = (alloc * 3 / 2);\n-\n-      /* If this is still too small, set it to the right size.  */\n-      if (alloc < num + reserve)\n-\talloc = num + reserve;\n-    }\n-  return alloc;\n-}\n-\n-/* Ensure there are at least abs(RESERVE) free slots in VEC.  If\n-   RESERVE < 0 grow exactly, else grow exponentially.  As a special\n-   case, if VEC is NULL, and RESERVE is 0, no vector will be created.  */\n-\n-void *\n-vec_p_reserve (void *vec, int reserve)\n-{\n-  return vec_o_reserve (vec, reserve,\n-\t\t\toffsetof (struct vec_prefix, vec), sizeof (void *));\n-}\n-\n-/* As vec_p_reserve, but for object vectors.  The vector's trailing\n-   array is at VEC_OFFSET offset and consists of ELT_SIZE sized\n-   elements.  */\n-\n-void *\n-vec_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size)\n-{\n-  struct vec_prefix *pfx = (struct vec_prefix *) vec;\n-  unsigned alloc = calculate_allocation (pfx, reserve);\n-\n-  if (!alloc)\n-    return NULL;\n-\n-  vec = xrealloc (vec, vec_offset + alloc * elt_size);\n-  ((struct vec_prefix *)vec)->alloc = alloc;\n-  if (!pfx)\n-    ((struct vec_prefix *)vec)->num = 0;\n-\n-  return vec;\n-}\n-\n-#if 0\n-/* Example uses.  */\n-DEF_VEC_I (int);\n-typedef struct X\n-{\n-  int i;\n-} obj_t;\n-typedef obj_t *ptr_t;\n-\n-DEF_VEC_P (ptr_t);\n-DEF_VEC_O (obj_t);\n-#endif"
    },
    {
      "sha": "8ac146d4903e21ab69087c8ae953605486593b2b",
      "filename": "gdb/gdbsupport/vec.h",
      "status": "removed",
      "additions": 0,
      "deletions": 1150,
      "changes": 1150,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/ae6400219c19f165692254740531b2a7ad74945e/gdb/gdbsupport/vec.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/ae6400219c19f165692254740531b2a7ad74945e/gdb/gdbsupport/vec.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbsupport/vec.h?ref=ae6400219c19f165692254740531b2a7ad74945e",
      "patch": "@@ -1,1150 +0,0 @@\n-/* Vector API for GDB.\n-   Copyright (C) 2004-2019 Free Software Foundation, Inc.\n-   Contributed by Nathan Sidwell <nathan@codesourcery.com>\n-\n-   This file is part of GDB.\n-\n-   This program is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3 of the License, or\n-   (at your option) any later version.\n-\n-   This program is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n-\n-#ifndef COMMON_VEC_H\n-#define COMMON_VEC_H\n-\n-#include \"diagnostics.h\"\n-\n-/* clang has a bug that makes it warn (-Wunused-function) about unused functions\n-   that are the result of the DEF_VEC_* macro expansion.  See:\n-\n-     https://bugs.llvm.org/show_bug.cgi?id=22712\n-\n-   We specifically ignore this warning for the vec functions when the compiler\n-   is clang.  */\n-#ifdef __clang__\n-# define DIAGNOSTIC_IGNORE_UNUSED_VEC_FUNCTION \\\n-    DIAGNOSTIC_IGNORE_UNUSED_FUNCTION\n-#else\n-# define DIAGNOSTIC_IGNORE_UNUSED_VEC_FUNCTION\n-#endif\n-\n-/* The macros here implement a set of templated vector types and\n-   associated interfaces.  These templates are implemented with\n-   macros, as we're not in C++ land.  The interface functions are\n-   typesafe and use static inline functions, sometimes backed by\n-   out-of-line generic functions.\n-\n-   Because of the different behavior of structure objects, scalar\n-   objects and of pointers, there are three flavors, one for each of\n-   these variants.  Both the structure object and pointer variants\n-   pass pointers to objects around -- in the former case the pointers\n-   are stored into the vector and in the latter case the pointers are\n-   dereferenced and the objects copied into the vector.  The scalar\n-   object variant is suitable for int-like objects, and the vector\n-   elements are returned by value.\n-\n-   There are both 'index' and 'iterate' accessors.  The iterator\n-   returns a boolean iteration condition and updates the iteration\n-   variable passed by reference.  Because the iterator will be\n-   inlined, the address-of can be optimized away.\n-\n-   The vectors are implemented using the trailing array idiom, thus\n-   they are not resizeable without changing the address of the vector\n-   object itself.  This means you cannot have variables or fields of\n-   vector type -- always use a pointer to a vector.  The one exception\n-   is the final field of a structure, which could be a vector type.\n-   You will have to use the embedded_size & embedded_init calls to\n-   create such objects, and they will probably not be resizeable (so\n-   don't use the 'safe' allocation variants).  The trailing array\n-   idiom is used (rather than a pointer to an array of data), because,\n-   if we allow NULL to also represent an empty vector, empty vectors\n-   occupy minimal space in the structure containing them.\n-\n-   Each operation that increases the number of active elements is\n-   available in 'quick' and 'safe' variants.  The former presumes that\n-   there is sufficient allocated space for the operation to succeed\n-   (it dies if there is not).  The latter will reallocate the\n-   vector, if needed.  Reallocation causes an exponential increase in\n-   vector size.  If you know you will be adding N elements, it would\n-   be more efficient to use the reserve operation before adding the\n-   elements with the 'quick' operation.  This will ensure there are at\n-   least as many elements as you ask for, it will exponentially\n-   increase if there are too few spare slots.  If you want reserve a\n-   specific number of slots, but do not want the exponential increase\n-   (for instance, you know this is the last allocation), use a\n-   negative number for reservation.  You can also create a vector of a\n-   specific size from the get go.\n-\n-   You should prefer the push and pop operations, as they append and\n-   remove from the end of the vector.  If you need to remove several\n-   items in one go, use the truncate operation.  The insert and remove\n-   operations allow you to change elements in the middle of the\n-   vector.  There are two remove operations, one which preserves the\n-   element ordering 'ordered_remove', and one which does not\n-   'unordered_remove'.  The latter function copies the end element\n-   into the removed slot, rather than invoke a memmove operation.  The\n-   'lower_bound' function will determine where to place an item in the\n-   array using insert that will maintain sorted order.\n-\n-   If you need to directly manipulate a vector, then the 'address'\n-   accessor will return the address of the start of the vector.  Also\n-   the 'space' predicate will tell you whether there is spare capacity\n-   in the vector.  You will not normally need to use these two functions.\n-\n-   Vector types are defined using a DEF_VEC_{O,P,I}(TYPEDEF) macro.\n-   Variables of vector type are declared using a VEC(TYPEDEF) macro.\n-   The characters O, P and I indicate whether TYPEDEF is a pointer\n-   (P), object (O) or integral (I) type.  Be careful to pick the\n-   correct one, as you'll get an awkward and inefficient API if you\n-   use the wrong one.  There is a check, which results in a\n-   compile-time warning, for the P and I versions, but there is no\n-   check for the O versions, as that is not possible in plain C.\n-\n-   An example of their use would be,\n-\n-   DEF_VEC_P(tree);   // non-managed tree vector.\n-\n-   struct my_struct {\n-     VEC(tree) *v;      // A (pointer to) a vector of tree pointers.\n-   };\n-\n-   struct my_struct *s;\n-\n-   if (VEC_length(tree, s->v)) { we have some contents }\n-   VEC_safe_push(tree, s->v, decl); // append some decl onto the end\n-   for (ix = 0; VEC_iterate(tree, s->v, ix, elt); ix++)\n-     { do something with elt }\n-\n-*/\n-\n-/* Macros to invoke API calls.  A single macro works for both pointer\n-   and object vectors, but the argument and return types might well be\n-   different.  In each macro, T is the typedef of the vector elements.\n-   Some of these macros pass the vector, V, by reference (by taking\n-   its address), this is noted in the descriptions.  */\n-\n-/* Length of vector\n-   unsigned VEC_T_length(const VEC(T) *v);\n-\n-   Return the number of active elements in V.  V can be NULL, in which\n-   case zero is returned.  */\n-\n-#define VEC_length(T,V)\t(VEC_OP(T,length)(V))\n-\n-\n-/* Check if vector is empty\n-   int VEC_T_empty(const VEC(T) *v);\n-\n-   Return nonzero if V is an empty vector (or V is NULL), zero otherwise.  */\n-\n-#define VEC_empty(T,V)\t(VEC_length (T,V) == 0)\n-\n-\n-/* Get the final element of the vector.\n-   T VEC_T_last(VEC(T) *v); // Integer\n-   T VEC_T_last(VEC(T) *v); // Pointer\n-   T *VEC_T_last(VEC(T) *v); // Object\n-\n-   Return the final element.  V must not be empty.  */\n-\n-#define VEC_last(T,V)\t(VEC_OP(T,last)(V VEC_ASSERT_INFO))\n-\n-/* Index into vector\n-   T VEC_T_index(VEC(T) *v, unsigned ix); // Integer\n-   T VEC_T_index(VEC(T) *v, unsigned ix); // Pointer\n-   T *VEC_T_index(VEC(T) *v, unsigned ix); // Object\n-\n-   Return the IX'th element.  If IX must be in the domain of V.  */\n-\n-#define VEC_index(T,V,I) (VEC_OP(T,index)(V,I VEC_ASSERT_INFO))\n-\n-/* Iterate over vector\n-   int VEC_T_iterate(VEC(T) *v, unsigned ix, T &ptr); // Integer\n-   int VEC_T_iterate(VEC(T) *v, unsigned ix, T &ptr); // Pointer\n-   int VEC_T_iterate(VEC(T) *v, unsigned ix, T *&ptr); // Object\n-\n-   Return iteration condition and update PTR to point to the IX'th\n-   element.  At the end of iteration, sets PTR to NULL.  Use this to\n-   iterate over the elements of a vector as follows,\n-\n-     for (ix = 0; VEC_iterate(T,v,ix,ptr); ix++)\n-       continue;  */\n-\n-#define VEC_iterate(T,V,I,P)\t(VEC_OP(T,iterate)(V,I,&(P)))\n-\n-/* Allocate new vector.\n-   VEC(T,A) *VEC_T_alloc(int reserve);\n-\n-   Allocate a new vector with space for RESERVE objects.  If RESERVE\n-   is zero, NO vector is created.  */\n-\n-#define VEC_alloc(T,N)\t(VEC_OP(T,alloc)(N))\n-\n-/* Free a vector.\n-   void VEC_T_free(VEC(T,A) *&);\n-\n-   Free a vector and set it to NULL.  */\n-\n-#define VEC_free(T,V)\t(VEC_OP(T,free)(&V))\n-\n-/* A cleanup function for a vector.\n-   void VEC_T_cleanup(void *);\n-   \n-   Clean up a vector.  */\n-\n-#define VEC_cleanup(T)\t(VEC_OP(T,cleanup))\n-\n-/* Use these to determine the required size and initialization of a\n-   vector embedded within another structure (as the final member).\n-\n-   size_t VEC_T_embedded_size(int reserve);\n-   void VEC_T_embedded_init(VEC(T) *v, int reserve);\n-\n-   These allow the caller to perform the memory allocation.  */\n-\n-#define VEC_embedded_size(T,N)\t (VEC_OP(T,embedded_size)(N))\n-#define VEC_embedded_init(T,O,N) (VEC_OP(T,embedded_init)(VEC_BASE(O),N))\n-\n-/* Copy a vector.\n-   VEC(T,A) *VEC_T_copy(VEC(T) *);\n-\n-   Copy the live elements of a vector into a new vector.  The new and\n-   old vectors need not be allocated by the same mechanism.  */\n-\n-#define VEC_copy(T,V) (VEC_OP(T,copy)(V))\n-\n-/* Merge two vectors.\n-   VEC(T,A) *VEC_T_merge(VEC(T) *, VEC(T) *);\n-\n-   Copy the live elements of both vectors into a new vector.  The new\n-   and old vectors need not be allocated by the same mechanism.  */\n-#define VEC_merge(T,V1,V2) (VEC_OP(T,merge)(V1, V2))\n-\n-/* Determine if a vector has additional capacity.\n-\n-   int VEC_T_space (VEC(T) *v,int reserve)\n-\n-   If V has space for RESERVE additional entries, return nonzero.  You\n-   usually only need to use this if you are doing your own vector\n-   reallocation, for instance on an embedded vector.  This returns\n-   nonzero in exactly the same circumstances that VEC_T_reserve\n-   will.  */\n-\n-#define VEC_space(T,V,R) (VEC_OP(T,space)(V,R VEC_ASSERT_INFO))\n-\n-/* Reserve space.\n-   int VEC_T_reserve(VEC(T,A) *&v, int reserve);\n-\n-   Ensure that V has at least abs(RESERVE) slots available.  The\n-   signedness of RESERVE determines the reallocation behavior.  A\n-   negative value will not create additional headroom beyond that\n-   requested.  A positive value will create additional headroom.  Note\n-   this can cause V to be reallocated.  Returns nonzero iff\n-   reallocation actually occurred.  */\n-\n-#define VEC_reserve(T,V,R) (VEC_OP(T,reserve)(&(V),R VEC_ASSERT_INFO))\n-\n-/* Push object with no reallocation\n-   T *VEC_T_quick_push (VEC(T) *v, T obj); // Integer\n-   T *VEC_T_quick_push (VEC(T) *v, T obj); // Pointer\n-   T *VEC_T_quick_push (VEC(T) *v, T *obj); // Object\n-\n-   Push a new element onto the end, returns a pointer to the slot\n-   filled in.  For object vectors, the new value can be NULL, in which\n-   case NO initialization is performed.  There must\n-   be sufficient space in the vector.  */\n-\n-#define VEC_quick_push(T,V,O) (VEC_OP(T,quick_push)(V,O VEC_ASSERT_INFO))\n-\n-/* Push object with reallocation\n-   T *VEC_T_safe_push (VEC(T,A) *&v, T obj); // Integer\n-   T *VEC_T_safe_push (VEC(T,A) *&v, T obj); // Pointer\n-   T *VEC_T_safe_push (VEC(T,A) *&v, T *obj); // Object\n-\n-   Push a new element onto the end, returns a pointer to the slot\n-   filled in.  For object vectors, the new value can be NULL, in which\n-   case NO initialization is performed.  Reallocates V, if needed.  */\n-\n-#define VEC_safe_push(T,V,O) (VEC_OP(T,safe_push)(&(V),O VEC_ASSERT_INFO))\n-\n-/* Pop element off end\n-   T VEC_T_pop (VEC(T) *v);\t\t// Integer\n-   T VEC_T_pop (VEC(T) *v);\t\t// Pointer\n-   void VEC_T_pop (VEC(T) *v);\t\t// Object\n-\n-   Pop the last element off the end.  Returns the element popped, for\n-   pointer vectors.  */\n-\n-#define VEC_pop(T,V)\t(VEC_OP(T,pop)(V VEC_ASSERT_INFO))\n-\n-/* Truncate to specific length\n-   void VEC_T_truncate (VEC(T) *v, unsigned len);\n-\n-   Set the length as specified.  The new length must be less than or\n-   equal to the current length.  This is an O(1) operation.  */\n-\n-#define VEC_truncate(T,V,I)\t\t\\\n-\t(VEC_OP(T,truncate)(V,I VEC_ASSERT_INFO))\n-\n-/* Grow to a specific length.\n-   void VEC_T_safe_grow (VEC(T,A) *&v, int len);\n-\n-   Grow the vector to a specific length.  The LEN must be as\n-   long or longer than the current length.  The new elements are\n-   uninitialized.  */\n-\n-#define VEC_safe_grow(T,V,I)\t\t\\\n-\t(VEC_OP(T,safe_grow)(&(V),I VEC_ASSERT_INFO))\n-\n-/* Replace element\n-   T VEC_T_replace (VEC(T) *v, unsigned ix, T val); // Integer\n-   T VEC_T_replace (VEC(T) *v, unsigned ix, T val); // Pointer\n-   T *VEC_T_replace (VEC(T) *v, unsigned ix, T *val);  // Object\n-\n-   Replace the IXth element of V with a new value, VAL.  For pointer\n-   vectors returns the original value.  For object vectors returns a\n-   pointer to the new value.  For object vectors the new value can be\n-   NULL, in which case no overwriting of the slot is actually\n-   performed.  */\n-\n-#define VEC_replace(T,V,I,O) (VEC_OP(T,replace)(V,I,O VEC_ASSERT_INFO))\n-\n-/* Insert object with no reallocation\n-   T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Integer\n-   T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T val); // Pointer\n-   T *VEC_T_quick_insert (VEC(T) *v, unsigned ix, T *val); // Object\n-\n-   Insert an element, VAL, at the IXth position of V.  Return a pointer\n-   to the slot created.  For vectors of object, the new value can be\n-   NULL, in which case no initialization of the inserted slot takes\n-   place.  There must be sufficient space.  */\n-\n-#define VEC_quick_insert(T,V,I,O) \\\n-\t(VEC_OP(T,quick_insert)(V,I,O VEC_ASSERT_INFO))\n-\n-/* Insert object with reallocation\n-   T *VEC_T_safe_insert (VEC(T,A) *&v, unsigned ix, T val); // Integer\n-   T *VEC_T_safe_insert (VEC(T,A) *&v, unsigned ix, T val); // Pointer\n-   T *VEC_T_safe_insert (VEC(T,A) *&v, unsigned ix, T *val); // Object\n-\n-   Insert an element, VAL, at the IXth position of V.  Return a pointer\n-   to the slot created.  For vectors of object, the new value can be\n-   NULL, in which case no initialization of the inserted slot takes\n-   place.  Reallocate V, if necessary.  */\n-\n-#define VEC_safe_insert(T,V,I,O)\t\\\n-\t(VEC_OP(T,safe_insert)(&(V),I,O VEC_ASSERT_INFO))\n-\n-/* Remove element retaining order\n-   T VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Integer\n-   T VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Pointer\n-   void VEC_T_ordered_remove (VEC(T) *v, unsigned ix); // Object\n-\n-   Remove an element from the IXth position of V.  Ordering of\n-   remaining elements is preserved.  For pointer vectors returns the\n-   removed object.  This is an O(N) operation due to a memmove.  */\n-\n-#define VEC_ordered_remove(T,V,I)\t\\\n-\t(VEC_OP(T,ordered_remove)(V,I VEC_ASSERT_INFO))\n-\n-/* Remove element destroying order\n-   T VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Integer\n-   T VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Pointer\n-   void VEC_T_unordered_remove (VEC(T) *v, unsigned ix); // Object\n-\n-   Remove an element from the IXth position of V.  Ordering of\n-   remaining elements is destroyed.  For pointer vectors returns the\n-   removed object.  This is an O(1) operation.  */\n-\n-#define VEC_unordered_remove(T,V,I)\t\\\n-\t(VEC_OP(T,unordered_remove)(V,I VEC_ASSERT_INFO))\n-\n-/* Remove a block of elements\n-   void VEC_T_block_remove (VEC(T) *v, unsigned ix, unsigned len);\n-\n-   Remove LEN elements starting at the IXth.  Ordering is retained.\n-   This is an O(N) operation due to memmove.  */\n-\n-#define VEC_block_remove(T,V,I,L)\t\\\n-\t(VEC_OP(T,block_remove)(V,I,L VEC_ASSERT_INFO))\n-\n-/* Get the address of the array of elements\n-   T *VEC_T_address (VEC(T) v)\n-\n-   If you need to directly manipulate the array (for instance, you\n-   want to feed it to qsort), use this accessor.  */\n-\n-#define VEC_address(T,V)\t\t(VEC_OP(T,address)(V))\n-\n-/* Find the first index in the vector not less than the object.\n-   unsigned VEC_T_lower_bound (VEC(T) *v, const T val,\n-                               int (*lessthan) (const T, const T)); // Integer\n-   unsigned VEC_T_lower_bound (VEC(T) *v, const T val,\n-                               int (*lessthan) (const T, const T)); // Pointer\n-   unsigned VEC_T_lower_bound (VEC(T) *v, const T *val,\n-                               int (*lessthan) (const T*, const T*)); // Object\n-\n-   Find the first position in which VAL could be inserted without\n-   changing the ordering of V.  LESSTHAN is a function that returns\n-   true if the first argument is strictly less than the second.  */\n-\n-#define VEC_lower_bound(T,V,O,LT)    \\\n-       (VEC_OP(T,lower_bound)(V,O,LT VEC_ASSERT_INFO))\n-\n-/* Reallocate an array of elements with prefix.  */\n-extern void *vec_p_reserve (void *, int);\n-extern void *vec_o_reserve (void *, int, size_t, size_t);\n-#define vec_free_(V) xfree (V)\n-\n-#define VEC_ASSERT_INFO ,__FILE__,__LINE__\n-#define VEC_ASSERT_DECL ,const char *file_,unsigned line_\n-#define VEC_ASSERT_PASS ,file_,line_\n-#define vec_assert(expr, op) \\\n-  ((void)((expr) ? 0 : (gdb_assert_fail (op, file_, line_, \\\n-\t\t\t\t\t FUNCTION_NAME), 0)))\n-\n-#define VEC(T) VEC_##T\n-#define VEC_OP(T,OP) VEC_##T##_##OP\n-\n-#define VEC_T(T)\t\t\t\t\t\t\t  \\\n-typedef struct VEC(T)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  unsigned num;\t\t\t\t\t\t\t\t  \\\n-  unsigned alloc;\t\t\t\t\t\t\t  \\\n-  T vec[1];\t\t\t\t\t\t\t\t  \\\n-} VEC(T)\n-\n-/* Vector of integer-like object.  */\n-#define DEF_VEC_I(T)\t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_PUSH \t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_IGNORE_UNUSED_VEC_FUNCTION\t\t\t\t\t  \\\n-static inline void VEC_OP (T,must_be_integral_type) (void)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  (void)~(T)0;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-VEC_T(T);\t\t\t\t\t\t\t\t  \\\n-DEF_VEC_FUNC_P(T)\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_I(T)\t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_POP\t\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-\n-/* Vector of pointer to object.  */\n-#define DEF_VEC_P(T)\t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_PUSH \t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_IGNORE_UNUSED_VEC_FUNCTION\t\t\t\t\t  \\\n-static inline void VEC_OP (T,must_be_pointer_type) (void)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  (void)((T)1 == (void *)1);\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-VEC_T(T);\t\t\t\t\t\t\t\t  \\\n-DEF_VEC_FUNC_P(T)\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_P(T)\t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_POP\t\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-\n-/* Vector of object.  */\n-#define DEF_VEC_O(T)\t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_PUSH \t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_IGNORE_UNUSED_VEC_FUNCTION\t\t\t\t\t  \\\n-VEC_T(T);\t\t\t\t\t\t\t\t  \\\n-DEF_VEC_FUNC_O(T)\t\t\t\t\t\t\t  \\\n-DEF_VEC_ALLOC_FUNC_O(T)\t\t\t\t\t\t\t  \\\n-DIAGNOSTIC_POP\t\t\t\t\t\t\t\t  \\\n-struct vec_swallow_trailing_semi\n-\n-/* Avoid offsetof (or its usual C implementation) as it triggers\n-   -Winvalid-offsetof warnings with enum_flags types with G++ <= 4.4,\n-   even though those types are memcpyable.  This requires allocating a\n-   dummy local VEC in all routines that use this, but that has the\n-   advantage that it only works if T is default constructible, which\n-   is exactly a check we want, to keep C compatibility.  */\n-#define vec_offset(T, VPTR) ((size_t) ((char *) &(VPTR)->vec - (char *) VPTR))\n-\n-#define DEF_VEC_ALLOC_FUNC_I(T)\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,alloc)\t\t\t\t\t  \\\n-     (int alloc_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) dummy;\t\t\t\t\t\t\t  \t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  /* We must request exact size allocation, hence the negation.  */\t  \\\n-  return (VEC(T) *) vec_o_reserve (NULL, -alloc_,\t\t\t  \\\n-                                   vec_offset (T, &dummy), sizeof (T));\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,copy) (VEC(T) *vec_)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n-  VEC (T) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (len_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      VEC(T) dummy;\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation.  */\t  \\\n-      new_vec_ = (VEC (T) *)\t\t\t\t\t\t  \\\n-\tvec_o_reserve (NULL, -len_, vec_offset (T, &dummy), sizeof (T));\t\\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->num = len_;\t\t\t\t\t\t  \\\n-      memcpy (new_vec_->vec, vec_->vec, sizeof (T) * len_);\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  return new_vec_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,merge) (VEC(T) *vec1_, VEC(T) *vec2_)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (vec1_ && vec2_)\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      VEC(T) dummy;\t\t\t\t\t\t\t  \\\n-      size_t len_ = vec1_->num + vec2_->num;\t\t\t\t  \\\n-      VEC (T) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation.  */\t  \\\n-      new_vec_ = (VEC (T) *)\t\t\t\t\t\t  \\\n-\tvec_o_reserve (NULL, -len_, vec_offset (T, &dummy), sizeof (T));\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->num = len_;\t\t\t\t\t\t  \\\n-      memcpy (new_vec_->vec, vec1_->vec, sizeof (T) * vec1_->num);\t  \\\n-      memcpy (new_vec_->vec + vec1_->num, vec2_->vec,\t\t\t  \\\n-\t      sizeof (T) * vec2_->num);\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      return new_vec_;\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    return VEC_copy (T, vec1_ ? vec1_ : vec2_);\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,free)\t\t\t\t\t  \\\n-     (VEC(T) **vec_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_free_ (*vec_);\t\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,cleanup)\t\t\t\t\t  \\\n-     (void *arg_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) **vec_ = (VEC(T) **) arg_;\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_free_ (*vec_);\t\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,reserve)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, int alloc_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) dummy;\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,space)\t\t\t\t\t  \\\n-\t(*vec_, alloc_ < 0 ? -alloc_ : alloc_ VEC_ASSERT_PASS);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T) *) vec_o_reserve (*vec_, alloc_,\t\t\t  \\\n-\t\t\t\t      vec_offset (T, &dummy), sizeof (T)); \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,safe_grow)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, int size_ VEC_ASSERT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (size_ >= 0 && VEC_OP(T,length) (*vec_) <= (unsigned)size_,  \\\n-\t\"safe_grow\");\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve) (vec_, (int)(*vec_ ? (*vec_)->num : 0) - size_\t  \\\n-\t\t\tVEC_ASSERT_PASS);\t\t\t\t  \\\n-  (*vec_)->num = size_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,safe_push)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, const T obj_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve) (vec_, 1 VEC_ASSERT_PASS);\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,quick_push) (*vec_, obj_ VEC_ASSERT_PASS);\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,safe_insert)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, unsigned ix_, const T obj_ VEC_ASSERT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve) (vec_, 1 VEC_ASSERT_PASS);\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,quick_insert) (*vec_, ix_, obj_ VEC_ASSERT_PASS);\t  \\\n-}\n-\n-#define DEF_VEC_FUNC_P(T)\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (T,length) (const VEC(T) *vec_)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,last)\t\t\t\t\t\t  \\\n-\t(const VEC(T) *vec_ VEC_ASSERT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_ && vec_->num, \"last\");\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,index)\t\t\t\t\t  \\\n-     (const VEC(T) *vec_, unsigned ix_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_ && ix_ < vec_->num, \"index\");\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return vec_->vec[ix_];\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,iterate)\t\t\t\t\t  \\\n-     (const VEC(T) *vec_, unsigned ix_, T *ptr)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (vec_ && ix_ < vec_->num)\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      *ptr = vec_->vec[ix_];\t\t\t\t\t\t  \\\n-      return 1;\t\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      *ptr = (T) 0;\t\t\t\t\t\t\t  \\\n-      return 0;\t\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline size_t VEC_OP (T,embedded_size)\t\t\t\t  \\\n-     (int alloc_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) dummy;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return vec_offset (T, &dummy) + alloc_ * sizeof(T);\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,embedded_init)\t\t\t\t  \\\n-     (VEC(T) *vec_, int alloc_)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_->num = 0;\t\t\t\t\t\t\t  \\\n-  vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,space)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, int alloc_ VEC_ASSERT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (alloc_ >= 0, \"space\");\t\t\t\t\t  \\\n-  return vec_ ? vec_->alloc - vec_->num >= (unsigned)alloc_ : !alloc_;\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,quick_push)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, T obj_ VEC_ASSERT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_->num < vec_->alloc, \"quick_push\");\t\t\t  \\\n-  slot_ = &vec_->vec[vec_->num++];\t\t\t\t\t  \\\n-  *slot_ = obj_;\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,pop) (VEC(T) *vec_ VEC_ASSERT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_->num, \"pop\");\t\t\t\t\t  \\\n-  obj_ = vec_->vec[--vec_->num];\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return obj_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,truncate)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned size_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_ ? vec_->num >= size_ : !size_, \"truncate\");\t\t  \\\n-  if (vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_->num = size_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,replace)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_, T obj_ VEC_ASSERT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T old_obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (ix_ < vec_->num, \"replace\");\t\t\t\t  \\\n-  old_obj_ = vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  vec_->vec[ix_] = obj_;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return old_obj_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,quick_insert)\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_, T obj_ VEC_ASSERT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_->num < vec_->alloc && ix_ <= vec_->num, \"quick_insert\"); \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_ + 1, slot_, (vec_->num++ - ix_) * sizeof (T));\t\t  \\\n-  *slot_ = obj_;\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,ordered_remove)\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-  T obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (ix_ < vec_->num, \"ordered_remove\");\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  obj_ = *slot_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + 1, (--vec_->num - ix_) * sizeof (T));\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return obj_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T VEC_OP (T,unordered_remove)\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-  T obj_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (ix_ < vec_->num, \"unordered_remove\");\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  obj_ = *slot_;\t\t\t\t\t\t\t  \\\n-  *slot_ = vec_->vec[--vec_->num];\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return obj_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,block_remove)\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_, unsigned len_ VEC_ASSERT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (ix_ + len_ <= vec_->num, \"block_remove\");\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  vec_->num -= len_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + len_, (vec_->num - ix_) * sizeof (T));\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,address)\t\t\t\t\t  \\\n-     (VEC(T) *vec_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (T,lower_bound)\t\t\t\t  \\\n-     (VEC(T) *vec_, const T obj_,\t\t\t\t\t  \\\n-      int (*lessthan_)(const T, const T) VEC_ASSERT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-   unsigned int len_ = VEC_OP (T, length) (vec_);\t\t\t  \\\n-   unsigned int half_, middle_;\t\t\t\t\t\t  \\\n-   unsigned int first_ = 0;\t\t\t\t\t\t  \\\n-   while (len_ > 0)\t\t\t\t\t\t\t  \\\n-     {\t\t\t\t\t\t\t\t\t  \\\n-        T middle_elem_;\t\t\t\t\t\t\t  \\\n-        half_ = len_ >> 1;\t\t\t\t\t\t  \\\n-        middle_ = first_;\t\t\t\t\t\t  \\\n-        middle_ += half_;\t\t\t\t\t\t  \\\n-        middle_elem_ = VEC_OP (T,index) (vec_, middle_ VEC_ASSERT_PASS);  \\\n-        if (lessthan_ (middle_elem_, obj_))\t\t\t\t  \\\n-          {\t\t\t\t\t\t\t\t  \\\n-             first_ = middle_;\t\t\t\t\t\t  \\\n-             ++first_;\t\t\t\t\t\t\t  \\\n-             len_ = len_ - half_ - 1;\t\t\t\t\t  \\\n-          }\t\t\t\t\t\t\t\t  \\\n-        else\t\t\t\t\t\t\t\t  \\\n-          len_ = half_;\t\t\t\t\t\t\t  \\\n-     }\t\t\t\t\t\t\t\t\t  \\\n-   return first_;\t\t\t\t\t\t\t  \\\n-}\n-\n-#define DEF_VEC_ALLOC_FUNC_P(T)\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,alloc)\t\t\t\t\t  \\\n-     (int alloc_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  /* We must request exact size allocation, hence the negation.  */\t  \\\n-  return (VEC(T) *) vec_p_reserve (NULL, -alloc_);\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,free)\t\t\t\t\t  \\\n-     (VEC(T) **vec_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_free_ (*vec_);\t\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,cleanup)\t\t\t\t\t  \\\n-     (void *arg_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) **vec_ = (VEC(T) **) arg_;\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_free_ (*vec_);\t\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,copy) (VEC(T) *vec_)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n-  VEC (T) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (len_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation.  */\t  \\\n-      new_vec_ = (VEC (T) *)(vec_p_reserve (NULL, -len_));\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->num = len_;\t\t\t\t\t\t  \\\n-      memcpy (new_vec_->vec, vec_->vec, sizeof (T) * len_);\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  return new_vec_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,merge) (VEC(T) *vec1_, VEC(T) *vec2_)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (vec1_ && vec2_)\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      size_t len_ = vec1_->num + vec2_->num;\t\t\t\t  \\\n-      VEC (T) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation.  */\t  \\\n-      new_vec_ = (VEC (T) *)(vec_p_reserve (NULL, -len_));\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->num = len_;\t\t\t\t\t\t  \\\n-      memcpy (new_vec_->vec, vec1_->vec, sizeof (T) * vec1_->num);\t  \\\n-      memcpy (new_vec_->vec + vec1_->num, vec2_->vec,\t\t\t  \\\n-\t      sizeof (T) * vec2_->num);\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      return new_vec_;\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    return VEC_copy (T, vec1_ ? vec1_ : vec2_);\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,reserve)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, int alloc_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,space)\t\t\t\t\t  \\\n-\t(*vec_, alloc_ < 0 ? -alloc_ : alloc_ VEC_ASSERT_PASS);\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T) *) vec_p_reserve (*vec_, alloc_);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,safe_grow)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, int size_ VEC_ASSERT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (size_ >= 0 && VEC_OP(T,length) (*vec_) <= (unsigned)size_,  \\\n-\t\"safe_grow\");\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve)\t\t\t\t\t\t\t  \\\n-\t(vec_, (int)(*vec_ ? (*vec_)->num : 0) - size_ VEC_ASSERT_PASS);  \\\n-  (*vec_)->num = size_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,safe_push)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, T obj_ VEC_ASSERT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve) (vec_, 1 VEC_ASSERT_PASS);\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,quick_push) (*vec_, obj_ VEC_ASSERT_PASS);\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,safe_insert)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, unsigned ix_, T obj_ VEC_ASSERT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve) (vec_, 1 VEC_ASSERT_PASS);\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,quick_insert) (*vec_, ix_, obj_ VEC_ASSERT_PASS);\t  \\\n-}\n-\n-#define DEF_VEC_FUNC_O(T)\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (T,length) (const VEC(T) *vec_)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->num : 0;\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,last) (VEC(T) *vec_ VEC_ASSERT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_ && vec_->num, \"last\");\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return &vec_->vec[vec_->num - 1];\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,index)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_ && ix_ < vec_->num, \"index\");\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,iterate)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_, T **ptr)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (vec_ && ix_ < vec_->num)\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      *ptr = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-      return 1;\t\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      *ptr = 0;\t\t\t\t\t\t\t\t  \\\n-      return 0;\t\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline size_t VEC_OP (T,embedded_size)\t\t\t\t  \\\n-     (int alloc_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) dummy;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return vec_offset (T, &dummy) + alloc_ * sizeof(T);\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,embedded_init)\t\t\t\t  \\\n-     (VEC(T) *vec_, int alloc_)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_->num = 0;\t\t\t\t\t\t\t  \\\n-  vec_->alloc = alloc_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,space)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, int alloc_ VEC_ASSERT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (alloc_ >= 0, \"space\");\t\t\t\t\t  \\\n-  return vec_ ? vec_->alloc - vec_->num >= (unsigned)alloc_ : !alloc_;\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,quick_push)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, const T *obj_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_->num < vec_->alloc, \"quick_push\");\t\t\t  \\\n-  slot_ = &vec_->vec[vec_->num++];\t\t\t\t\t  \\\n-  if (obj_)\t\t\t\t\t\t\t\t  \\\n-    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,pop) (VEC(T) *vec_ VEC_ASSERT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_->num, \"pop\");\t\t\t\t\t  \\\n-  --vec_->num;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,truncate)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned size_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_ ? vec_->num >= size_ : !size_, \"truncate\");\t\t  \\\n-  if (vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_->num = size_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,replace)\t\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_, const T *obj_ VEC_ASSERT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (ix_ < vec_->num, \"replace\");\t\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  if (obj_)\t\t\t\t\t\t\t\t  \\\n-    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,quick_insert)\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_, const T *obj_ VEC_ASSERT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (vec_->num < vec_->alloc && ix_ <= vec_->num, \"quick_insert\"); \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_ + 1, slot_, (vec_->num++ - ix_) * sizeof (T));\t\t  \\\n-  if (obj_)\t\t\t\t\t\t\t\t  \\\n-    *slot_ = *obj_;\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return slot_;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,ordered_remove)\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (ix_ < vec_->num, \"ordered_remove\");\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + 1, (--vec_->num - ix_) * sizeof (T));\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,unordered_remove)\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (ix_ < vec_->num, \"unordered_remove\");\t\t\t  \\\n-  vec_->vec[ix_] = vec_->vec[--vec_->num];\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,block_remove)\t\t\t\t  \\\n-     (VEC(T) *vec_, unsigned ix_, unsigned len_ VEC_ASSERT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  T *slot_;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (ix_ + len_ <= vec_->num, \"block_remove\");\t\t\t  \\\n-  slot_ = &vec_->vec[ix_];\t\t\t\t\t\t  \\\n-  vec_->num -= len_;\t\t\t\t\t\t\t  \\\n-  memmove (slot_, slot_ + len_, (vec_->num - ix_) * sizeof (T));\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,address)\t\t\t\t\t  \\\n-     (VEC(T) *vec_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  return vec_ ? vec_->vec : 0;\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline unsigned VEC_OP (T,lower_bound)\t\t\t\t  \\\n-     (VEC(T) *vec_, const T *obj_,\t\t\t\t\t  \\\n-      int (*lessthan_)(const T *, const T *) VEC_ASSERT_DECL)\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-   unsigned int len_ = VEC_OP (T, length) (vec_);\t\t\t  \\\n-   unsigned int half_, middle_;\t\t\t\t\t\t  \\\n-   unsigned int first_ = 0;\t\t\t\t\t\t  \\\n-   while (len_ > 0)\t\t\t\t\t\t\t  \\\n-     {\t\t\t\t\t\t\t\t\t  \\\n-        T *middle_elem_;\t\t\t\t\t\t  \\\n-        half_ = len_ >> 1;\t\t\t\t\t\t  \\\n-        middle_ = first_;\t\t\t\t\t\t  \\\n-        middle_ += half_;\t\t\t\t\t\t  \\\n-        middle_elem_ = VEC_OP (T,index) (vec_, middle_ VEC_ASSERT_PASS);  \\\n-        if (lessthan_ (middle_elem_, obj_))\t\t\t\t  \\\n-          {\t\t\t\t\t\t\t\t  \\\n-             first_ = middle_;\t\t\t\t\t\t  \\\n-             ++first_;\t\t\t\t\t\t\t  \\\n-             len_ = len_ - half_ - 1;\t\t\t\t\t  \\\n-          }\t\t\t\t\t\t\t\t  \\\n-        else\t\t\t\t\t\t\t\t  \\\n-          len_ = half_;\t\t\t\t\t\t\t  \\\n-     }\t\t\t\t\t\t\t\t\t  \\\n-   return first_;\t\t\t\t\t\t\t  \\\n-}\n-\n-#define DEF_VEC_ALLOC_FUNC_O(T)\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,alloc)\t\t\t\t\t  \\\n-     (int alloc_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) dummy;\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  /* We must request exact size allocation, hence the negation.  */\t  \\\n-  return (VEC(T) *) vec_o_reserve (NULL, -alloc_,\t\t\t  \\\n-                                   vec_offset (T, &dummy), sizeof (T));\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,copy) (VEC(T) *vec_)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  size_t len_ = vec_ ? vec_->num : 0;\t\t\t\t\t  \\\n-  VEC (T) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (len_)\t\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      VEC(T) dummy;\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation.  */\t  \\\n-      new_vec_ = (VEC (T) *)\t\t\t\t\t\t  \\\n-\tvec_o_reserve  (NULL, -len_, vec_offset (T, &dummy), sizeof (T)); \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->num = len_;\t\t\t\t\t\t  \\\n-      memcpy (new_vec_->vec, vec_->vec, sizeof (T) * len_);\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  return new_vec_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline VEC(T) *VEC_OP (T,merge) (VEC(T) *vec1_, VEC(T) *vec2_)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (vec1_ && vec2_)\t\t\t\t\t\t\t  \\\n-    {\t\t\t\t\t\t\t\t\t  \\\n-      VEC(T) dummy;\t\t\t\t\t\t\t  \\\n-      size_t len_ = vec1_->num + vec2_->num;\t\t\t\t  \\\n-      VEC (T) *new_vec_ = NULL;\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      /* We must request exact size allocation, hence the negation.  */\t  \\\n-      new_vec_ = (VEC (T) *)\t\t\t\t\t\t  \\\n-\tvec_o_reserve (NULL, -len_, vec_offset (T, &dummy), sizeof (T));  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      new_vec_->num = len_;\t\t\t\t\t\t  \\\n-      memcpy (new_vec_->vec, vec1_->vec, sizeof (T) * vec1_->num);\t  \\\n-      memcpy (new_vec_->vec + vec1_->num, vec2_->vec,\t\t\t  \\\n-\t      sizeof (T) * vec2_->num);\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-      return new_vec_;\t\t\t\t\t\t\t  \\\n-    }\t\t\t\t\t\t\t\t\t  \\\n-  else\t\t\t\t\t\t\t\t\t  \\\n-    return VEC_copy (T, vec1_ ? vec1_ : vec2_);\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,free)\t\t\t\t\t  \\\n-     (VEC(T) **vec_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_free_ (*vec_);\t\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,cleanup)\t\t\t\t\t  \\\n-     (void *arg_)\t\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) **vec_ = (VEC(T) **) arg_;\t\t\t\t\t  \\\n-  if (*vec_)\t\t\t\t\t\t\t\t  \\\n-    vec_free_ (*vec_);\t\t\t\t\t\t\t  \\\n-  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline int VEC_OP (T,reserve)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, int alloc_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC(T) dummy;\t\t\t\t\t\t\t\t  \\\n-  int extend = !VEC_OP (T,space) (*vec_, alloc_ < 0 ? -alloc_ : alloc_\t  \\\n-\t\t\t\t  VEC_ASSERT_PASS);\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC(T) *)\t\t\t\t\t\t\t  \\\n-      vec_o_reserve (*vec_, alloc_, vec_offset (T, &dummy), sizeof (T));  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return extend;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline void VEC_OP (T,safe_grow)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, int size_ VEC_ASSERT_DECL)\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  vec_assert (size_ >= 0 && VEC_OP(T,length) (*vec_) <= (unsigned)size_,  \\\n-\t\"safe_grow\");\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve)\t\t\t\t\t\t\t  \\\n-\t(vec_, (int)(*vec_ ? (*vec_)->num : 0) - size_ VEC_ASSERT_PASS);  \\\n-  (*vec_)->num = size_;\t\t\t\t\t\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,safe_push)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, const T *obj_ VEC_ASSERT_DECL)\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve) (vec_, 1 VEC_ASSERT_PASS);\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,quick_push) (*vec_, obj_ VEC_ASSERT_PASS);\t\t  \\\n-}\t\t\t\t\t\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-static inline T *VEC_OP (T,safe_insert)\t\t\t\t\t  \\\n-     (VEC(T) **vec_, unsigned ix_, const T *obj_ VEC_ASSERT_DECL)\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  VEC_OP (T,reserve) (vec_, 1 VEC_ASSERT_PASS);\t\t\t\t  \\\n-\t\t\t\t\t\t\t\t\t  \\\n-  return VEC_OP (T,quick_insert) (*vec_, ix_, obj_ VEC_ASSERT_PASS);\t  \\\n-}\n-\n-#endif /* COMMON_VEC_H */"
    },
    {
      "sha": "370141e68885370af7099a1e329763eabbbf0d79",
      "filename": "gdb/gdbthread.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdbthread.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/gdbthread.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/gdbthread.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -27,7 +27,6 @@ struct symtab;\n #include \"frame.h\"\n #include \"ui-out.h\"\n #include \"btrace.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"target/waitstatus.h\"\n #include \"cli/cli-utils.h\"\n #include \"gdbsupport/refcounted-object.h\""
    },
    {
      "sha": "953e17bf0e413b2a93d8fa078fe5ccd160e73c2c",
      "filename": "gdb/guile/scm-type.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/guile/scm-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/guile/scm-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/guile/scm-type.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -26,7 +26,6 @@\n #include \"gdbtypes.h\"\n #include \"objfiles.h\"\n #include \"language.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"bcache.h\"\n #include \"dwarf2loc.h\"\n #include \"typeprint.h\""
    },
    {
      "sha": "5840e3ee3198e6869a0cfc508e56890d8cb5ba95",
      "filename": "gdb/inline-frame.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/inline-frame.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/inline-frame.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/inline-frame.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -27,7 +27,6 @@\n #include \"gdbthread.h\"\n #include \"regcache.h\"\n #include \"symtab.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"frame.h\"\n #include <algorithm>\n "
    },
    {
      "sha": "db884b0790d354c7089a073e3f80304ab07f5bb1",
      "filename": "gdb/machoread.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/machoread.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/machoread.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/machoread.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -28,7 +28,6 @@\n #include \"gdbcore.h\"\n #include \"mach-o.h\"\n #include \"aout/stab_gnu.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"psympriv.h\"\n #include \"complaints.h\"\n #include \"gdb_bfd.h\""
    },
    {
      "sha": "7a961af481d0a172ee8bd982acd16a5659da7b48",
      "filename": "gdb/memattr.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/memattr.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/memattr.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/memattr.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -25,7 +25,6 @@\n #include \"target-dcache.h\"\n #include \"value.h\"\n #include \"language.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"breakpoint.h\"\n #include \"cli/cli-utils.h\"\n #include <algorithm>"
    },
    {
      "sha": "4f84e20cd73061809095c74de113731d153397a7",
      "filename": "gdb/memrange.h",
      "status": "modified",
      "additions": 0,
      "deletions": 2,
      "changes": 2,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/memrange.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/memrange.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/memrange.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -20,8 +20,6 @@\n #ifndef MEMRANGE_H\n #define MEMRANGE_H\n \n-#include \"gdbsupport/vec.h\"\n-\n /* Defines a [START, START + LENGTH) memory range.  */\n \n struct mem_range"
    },
    {
      "sha": "980b1ebfb899041cec53ce514aa3c8b5cce2221b",
      "filename": "gdb/namespace.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/namespace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/namespace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/namespace.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -19,7 +19,6 @@\n #ifndef NAMESPACE_H\n #define NAMESPACE_H\n \n-#include \"gdbsupport/vec.h\"\n #include \"gdbsupport/gdb_vecs.h\"\n #include \"gdb_obstack.h\"\n "
    },
    {
      "sha": "0520ae4d0ad8139ea846e9fb3d7d37fc942628f1",
      "filename": "gdb/nat/linux-btrace.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/nat/linux-btrace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/nat/linux-btrace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/nat/linux-btrace.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -23,7 +23,6 @@\n #define NAT_LINUX_BTRACE_H\n \n #include \"gdbsupport/btrace-common.h\"\n-#include \"gdbsupport/vec.h\"\n #if HAVE_LINUX_PERF_EVENT_H\n #  include <linux/perf_event.h>\n #endif"
    },
    {
      "sha": "4bd1a0b9b28e99ca0f424f8fa74e567bab8fbda6",
      "filename": "gdb/osdata.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/osdata.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/osdata.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/osdata.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -19,7 +19,6 @@\n \n #include \"defs.h\"\n #include \"target.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"xml-support.h\"\n #include \"osdata.h\"\n #include \"ui-out.h\""
    },
    {
      "sha": "b6c77534f699e5e9b0a3015a54c2843550811c9b",
      "filename": "gdb/parser-defs.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/parser-defs.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/parser-defs.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/parser-defs.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -23,7 +23,6 @@\n #if !defined (PARSER_DEFS_H)\n #define PARSER_DEFS_H 1\n \n-#include \"gdbsupport/vec.h\"\n #include \"expression.h\"\n #include \"symtab.h\"\n "
    },
    {
      "sha": "5a053b99d098249656be35677727d79b05686990",
      "filename": "gdb/progspace.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/progspace.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/progspace.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/progspace.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -22,7 +22,6 @@\n #define PROGSPACE_H\n \n #include \"target.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"gdb_bfd.h\"\n #include \"gdbsupport/gdb_vecs.h\"\n #include \"registry.h\""
    },
    {
      "sha": "a2fca97a327eee7d09e4a2afc642b17d7f6e1f78",
      "filename": "gdb/python/py-type.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/python/py-type.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/python/py-type.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-type.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -26,7 +26,6 @@\n #include \"demangle.h\"\n #include \"objfiles.h\"\n #include \"language.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"typeprint.h\"\n \n typedef struct pyty_type_object"
    },
    {
      "sha": "65dfe70dc16d11ddb9c65bfca949119c929a0bc6",
      "filename": "gdb/record-btrace.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/record-btrace.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/record-btrace.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/record-btrace.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -38,7 +38,6 @@\n #include \"infrun.h\"\n #include \"event-loop.h\"\n #include \"inf-loop.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"inferior.h\"\n #include <algorithm>\n #include \"gdbarch.h\""
    },
    {
      "sha": "a15e0de12fd2439e87123ed1d1677c5b1730d1ec",
      "filename": "gdb/rust-exp.y",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/rust-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/rust-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/rust-exp.y?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -40,7 +40,6 @@\n #include \"parser-defs.h\"\n #include \"gdbsupport/selftest.h\"\n #include \"value.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"gdbarch.h\"\n \n #define GDB_YY_REMAP_PREFIX rust"
    },
    {
      "sha": "2b473d606660087eaa96335e718e0aa5c8b2c56d",
      "filename": "gdb/solib-target.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/solib-target.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/solib-target.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/solib-target.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -23,7 +23,6 @@\n #include \"symtab.h\"\n #include \"symfile.h\"\n #include \"target.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"solib-target.h\"\n #include <vector>\n "
    },
    {
      "sha": "ea206cbb80f3016db7e30e65db751892b7cd7415",
      "filename": "gdb/stap-probe.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/stap-probe.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/stap-probe.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/stap-probe.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -20,7 +20,6 @@\n #include \"defs.h\"\n #include \"stap-probe.h\"\n #include \"probe.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"ui-out.h\"\n #include \"objfiles.h\"\n #include \"arch-utils.h\""
    },
    {
      "sha": "f4368bbc05573f5348d49bb25191d0a232b9fa96",
      "filename": "gdb/target-descriptions.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/target-descriptions.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/target-descriptions.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-descriptions.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -26,7 +26,6 @@\n #include \"reggroups.h\"\n #include \"target.h\"\n #include \"target-descriptions.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"xml-support.h\"\n #include \"xml-tdesc.h\"\n #include \"osabi.h\""
    },
    {
      "sha": "4b84431aab783dc24f4c393e548cd2b81095e4d4",
      "filename": "gdb/target-memory.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/target-memory.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/target-memory.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target-memory.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -19,7 +19,6 @@\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n \n #include \"defs.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"target.h\"\n #include \"memory-map.h\"\n "
    },
    {
      "sha": "91e8a837ab27e4dd056876c484c3814564d122f4",
      "filename": "gdb/target.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/target.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/target.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/target.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -74,7 +74,6 @@ struct inferior;\n #include \"bfd.h\"\n #include \"symtab.h\"\n #include \"memattr.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"gdbsupport/gdb_signals.h\"\n #include \"btrace.h\"\n #include \"record.h\""
    },
    {
      "sha": "6265b2fa1722b883bc8e21ee15b603b5ec7315b4",
      "filename": "gdb/varobj.c",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/varobj.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/varobj.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/varobj.c?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -26,7 +26,6 @@\n #include \"gdb_regex.h\"\n \n #include \"varobj.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"gdbthread.h\"\n #include \"inferior.h\"\n #include \"varobj-iter.h\""
    },
    {
      "sha": "eb01da10e2d9b169f8b02612af9e2c0cebbcdc93",
      "filename": "gdb/varobj.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/varobj.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/varobj.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/varobj.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -19,7 +19,6 @@\n \n #include \"symtab.h\"\n #include \"gdbtypes.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"value.h\"\n \n /* Enumeration for the format types */"
    },
    {
      "sha": "5012767568f4643f36bbf1b76767d744381af7bf",
      "filename": "gdb/xml-support.h",
      "status": "modified",
      "additions": 0,
      "deletions": 1,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/xml-support.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/0dc327459b19e6765c8fe80957f5c8620611628e/gdb/xml-support.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/xml-support.h?ref=0dc327459b19e6765c8fe80957f5c8620611628e",
      "patch": "@@ -22,7 +22,6 @@\n #define XML_SUPPORT_H\n \n #include \"gdb_obstack.h\"\n-#include \"gdbsupport/vec.h\"\n #include \"gdbsupport/xml-utils.h\"\n #include \"gdbsupport/byte-vector.h\"\n #include \"gdbsupport/gdb_optional.h\""
    }
  ]
}