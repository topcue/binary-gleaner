{
  "sha": "24b2de7b776f8f23788d855b1eec290c6e208821",
  "node_id": "C_kwDOANOeidoAKDI0YjJkZTdiNzc2ZjhmMjM3ODhkODU1YjFlZWMyOTBjNmUyMDg4MjE",
  "commit": {
    "author": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-08-31T13:04:36Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-11-30T12:10:40Z"
    },
    "message": "gdb/python: add gdb.RemoteTargetConnection.send_packet\n\nThis commits adds a new sub-class of gdb.TargetConnection,\ngdb.RemoteTargetConnection.  This sub-class is created for all\n'remote' and 'extended-remote' targets.\n\nThis new sub-class has one additional method over its base class,\n'send_packet'.  This new method is equivalent to the 'maint\npacket' CLI command, it allows a custom packet to be sent to a remote\ntarget.\n\nThe outgoing packet can either be a bytes object, or a Unicode string,\nso long as the Unicode string contains only ASCII characters.\n\nThe result of calling RemoteTargetConnection.send_packet is a bytes\nobject containing the reply that came from the remote.",
    "tree": {
      "sha": "9a2d7b705087364d8e4ce6585bf6f7ad39664004",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/9a2d7b705087364d8e4ce6585bf6f7ad39664004"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/24b2de7b776f8f23788d855b1eec290c6e208821",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24b2de7b776f8f23788d855b1eec290c6e208821",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/24b2de7b776f8f23788d855b1eec290c6e208821",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/24b2de7b776f8f23788d855b1eec290c6e208821/comments",
  "author": null,
  "committer": null,
  "parents": [
    {
      "sha": "e5b176f25ff51f6811b82f549b7524618d5c2f6b",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/e5b176f25ff51f6811b82f549b7524618d5c2f6b",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/e5b176f25ff51f6811b82f549b7524618d5c2f6b"
    }
  ],
  "stats": {
    "total": 626,
    "additions": 615,
    "deletions": 11
  },
  "files": [
    {
      "sha": "eeca1d39b107bd1b66caf2dcfa78096ea8ec316b",
      "filename": "gdb/NEWS",
      "status": "modified",
      "additions": 7,
      "deletions": 1,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/NEWS",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/NEWS",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/NEWS?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -68,7 +68,9 @@ maint packet\n      integer type given a size and a signed-ness.\n \n   ** New gdb.TargetConnection object type that represents a connection\n-     (as displayed by the 'info connections' command).\n+     (as displayed by the 'info connections' command).  A sub-class,\n+     gdb.RemoteTargetConnection, is used to represent 'remote' and\n+     'extended-remote' connections.\n \n   ** The gdb.Inferior type now has a 'connection' property which is an\n      instance of gdb.TargetConnection, the connection used by this\n@@ -82,6 +84,10 @@ maint packet\n   ** New gdb.connections() function that returns a list of all\n      currently active connections.\n \n+  ** New gdb.RemoteTargetConnection.send_packet(PACKET) method.  This\n+     is equivalent to the existing 'maint packet' CLI command; it\n+     allows a user specified packet to be sent to the remote target.\n+\n * New features in the GDB remote stub, GDBserver\n \n   ** GDBserver is now supported on OpenRISC GNU/Linux."
    },
    {
      "sha": "9d507795993c1bc0e1cc468cbab540f93a40d5a6",
      "filename": "gdb/doc/gdb.texinfo",
      "status": "modified",
      "additions": 1,
      "deletions": 0,
      "changes": 1,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/doc/gdb.texinfo",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/doc/gdb.texinfo",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/gdb.texinfo?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -39278,6 +39278,7 @@ possible to have a backtrace of @value{GDBN} printed to the standard\n error stream.  This is @samp{on} by default for @code{internal-error}\n and @samp{off} by default for @code{internal-warning}.\n \n+@anchor{maint packet}\n @kindex maint packet\n @item maint packet @var{text}\n If @value{GDBN} is talking to an inferior via the serial protocol,"
    },
    {
      "sha": "4a66c11c19d57b26e09fca4c93d6c6c5a90ef941",
      "filename": "gdb/doc/python.texi",
      "status": "modified",
      "additions": 67,
      "deletions": 3,
      "changes": 70,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/doc/python.texi",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/doc/python.texi",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/doc/python.texi?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -6007,15 +6007,36 @@ describes how @value{GDBN} controls the program being debugged.\n Examples of different connection types are @samp{native} and\n @samp{remote}.  @xref{Inferiors Connections and Programs}.\n \n-@value{GDBN} uses the @code{gdb.TargetConnection} object type to\n-represent a connection in Python code.  To get a list of all\n-connections use @code{gdb.connections}\n+Connections in @value{GDBN} are represented as instances of\n+@code{gdb.TargetConnection}, or as one of its sub-classes.  To get a\n+list of all connections use @code{gdb.connections}\n (@pxref{gdbpy_connections,,gdb.connections}).\n \n To get the connection for a single @code{gdb.Inferior} read its\n @code{gdb.Inferior.connection} attribute\n (@pxref{gdbpy_inferior_connection,,gdb.Inferior.connection}).\n \n+Currently there is only a single sub-class of\n+@code{gdb.TargetConnection}, @code{gdb.RemoteTargetConnection},\n+however, additional sub-classes may be added in future releases of\n+@value{GDBN}.  As a result you should avoid writing code like:\n+\n+@smallexample\n+conn = gdb.selected_inferior().connection\n+if type(conn) is gdb.RemoteTargetConnection:\n+  print(\"This is a remote target connection\")\n+@end smallexample\n+\n+@noindent\n+as this may fail when more connection types are added.  Instead, you\n+should write:\n+\n+@smallexample\n+conn = gdb.selected_inferior().connection\n+if isinstance(conn, gdb.RemoteTargetConnection):\n+  print(\"This is a remote target connection\")\n+@end smallexample\n+\n A @code{gdb.TargetConnection} has the following method:\n \n @defun TargetConnection.is_valid ()\n@@ -6062,6 +6083,49 @@ contain the @samp{@var{hostname}:@var{port}} that was used to connect\n to the remote target.\n @end defvar\n \n+The @code{gdb.RemoteTargetConnection} class is a sub-class of\n+@code{gdb.TargetConnection}, and is used to represent @samp{remote}\n+and @samp{extended-remote} connections.  In addition to the attributes\n+and methods available from the @code{gdb.TargetConnection} base class,\n+a @code{gdb.RemoteTargetConnection} has the following method:\n+\n+@kindex maint packet\n+@defun RemoteTargetConnection.send_packet (@var{packet})\n+This method sends @var{packet} to the remote target and returns the\n+response.  The @var{packet} should either be a @code{bytes} object, or\n+a @code{Unicode} string.\n+\n+If @var{packet} is a @code{Unicode} string, then the string is encoded\n+to a @code{bytes} object using the @sc{ascii} codec.  If the string\n+can't be encoded then an @code{UnicodeError} is raised.\n+\n+If @var{packet} is not a @code{bytes} object, or a @code{Unicode}\n+string, then a @code{TypeError} is raised.  If @var{packet} is empty\n+then a @code{ValueError} is raised.\n+\n+The response is returned as a @code{bytes} object.  For Python 3 if it\n+is known that the response can be represented as a string then this\n+can be decoded from the buffer.  For example, if it is known that the\n+response is an @sc{ascii} string:\n+\n+@smallexample\n+remote_connection.send_packet(\"some_packet\").decode(\"ascii\")\n+@end smallexample\n+\n+In Python 2 @code{bytes} and @code{str} are aliases, so the result is\n+already a string, if the response includes non-printable characters,\n+or null characters, then these will be present in the result, care\n+should be taken when processing the result to handle this case.\n+\n+The prefix, suffix, and checksum (as required by the remote serial\n+protocol) are automatically added to the outgoing packet, and removed\n+from the incoming packet before the contents of the reply are\n+returned.\n+\n+This is equivalent to the @code{maintenance packet} command\n+(@pxref{maint packet}).\n+@end defun\n+\n @node TUI Windows In Python\n @subsubsection Implementing new TUI windows\n @cindex Python TUI Windows"
    },
    {
      "sha": "48e14fed4ad9885b27951d28dc59b2a448fc12c3",
      "filename": "gdb/python/py-connection.c",
      "status": "modified",
      "additions": 207,
      "deletions": 3,
      "changes": 210,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/python/py-connection.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/python/py-connection.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/python/py-connection.c?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -26,6 +26,8 @@\n #include \"py-events.h\"\n #include \"py-event.h\"\n #include \"arch-utils.h\"\n+#include \"remote.h\"\n+#include \"charset.h\"\n \n #include <map>\n \n@@ -47,6 +49,9 @@ struct connection_object\n extern PyTypeObject connection_object_type\n   CPYCHECKER_TYPE_OBJECT_FOR_TYPEDEF (\"connection_object\");\n \n+extern PyTypeObject remote_connection_object_type\n+  CPYCHECKER_TYPE_OBJECT_FOR_TYPEDEF (\"remote_connection_object\");\n+\n /* Require that CONNECTION be valid.  */\n #define CONNPY_REQUIRE_VALID(connection)\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n@@ -81,8 +86,14 @@ target_to_connection_object (process_stratum_target *target)\n   auto conn_obj_iter = all_connection_objects.find (target);\n   if (conn_obj_iter == all_connection_objects.end ())\n     {\n-      conn_obj.reset (PyObject_New (connection_object,\n-\t\t\t\t    &connection_object_type));\n+      PyTypeObject *type;\n+\n+      if (is_remote_target (target))\n+\ttype = &remote_connection_object_type;\n+      else\n+\ttype = &connection_object_type;\n+\n+      conn_obj.reset (PyObject_New (connection_object, type));\n       if (conn_obj == nullptr)\n \treturn nullptr;\n       conn_obj->target = target;\n@@ -284,9 +295,148 @@ gdbpy_initialize_connection (void)\n \t\t\t      (PyObject *) &connection_object_type) < 0)\n     return -1;\n \n+  if (PyType_Ready (&remote_connection_object_type) < 0)\n+    return -1;\n+\n+  if (gdb_pymodule_addobject (gdb_module, \"RemoteTargetConnection\",\n+\t\t\t      (PyObject *) &remote_connection_object_type) < 0)\n+    return -1;\n+\n   return 0;\n }\n \n+/* Set of callbacks used to implement gdb.send_packet.  */\n+\n+struct py_send_packet_callbacks : public send_remote_packet_callbacks\n+{\n+  /* Constructor, initialise the result to nullptr.  It is invalid to try\n+     and read the result before sending a packet and processing the\n+     reply.  */\n+\n+  py_send_packet_callbacks ()\n+    : m_result (nullptr)\n+  { /* Nothing.  */ }\n+\n+  /* There's nothing to do when the packet is sent.  */\n+\n+  void sending (gdb::array_view<const char> &buf) override\n+  { /* Nothing.  */ }\n+\n+  /* When the result is returned create a Python object and assign this\n+     into M_RESULT.  If for any reason we can't create a Python object to\n+     represent the result then M_RESULT is set to nullptr, and Python's\n+     internal error flags will be set.  If the result we got back from the\n+     remote is empty then set the result to None.  */\n+\n+  void received (gdb::array_view<const char> &buf) override\n+  {\n+    if (buf.size () > 0 && buf.data ()[0] != '\\0')\n+      m_result.reset (PyBytes_FromStringAndSize (buf.data (), buf.size ()));\n+    else\n+      {\n+\t/* We didn't get back any result data; set the result to None.  */\n+\tPy_INCREF (Py_None);\n+\tm_result.reset (Py_None);\n+      }\n+  }\n+\n+  /* Get a reference to the result as a Python object.  It is invalid to\n+     call this before sending a packet to the remote and processing the\n+     reply.\n+\n+     The result value is setup in the RECEIVED call above.  If the RECEIVED\n+     call causes an error then the result value will be set to nullptr,\n+     and the error reason is left stored in Python's global error state.\n+\n+     It is important that the result is inspected immediately after sending\n+     a packet to the remote, and any error fetched,  calling any other\n+     Python functions that might clear the error state, or rely on an error\n+     not being set will cause undefined behaviour.  */\n+\n+  gdbpy_ref<> result () const\n+  {\n+    return m_result;\n+  }\n+\n+private:\n+\n+  /* A reference to the result value.  */\n+\n+  gdbpy_ref<> m_result;\n+};\n+\n+/* Implement RemoteTargetConnection.send_packet function.  Send a packet to\n+   the target identified by SELF.  The connection must still be valid, and\n+   the packet to be sent must be non-empty, otherwise an exception will be\n+   thrown.  */\n+\n+static PyObject *\n+connpy_send_packet (PyObject *self, PyObject *args, PyObject *kw)\n+{\n+  connection_object *conn = (connection_object *) self;\n+\n+  CONNPY_REQUIRE_VALID (conn);\n+\n+  static const char *keywords[] = {\"packet\", nullptr};\n+  PyObject *packet_obj;\n+\n+  if (!gdb_PyArg_ParseTupleAndKeywords (args, kw, \"O\", keywords,\n+\t\t\t\t\t&packet_obj))\n+    return nullptr;\n+\n+  /* If the packet is a unicode string then convert it to a bytes object.  */\n+  if (PyUnicode_Check (packet_obj))\n+    {\n+      /* We encode the string to bytes using the ascii codec, if this fails\n+\t then a suitable error will have been set.  */\n+      packet_obj = PyUnicode_AsASCIIString (packet_obj);\n+      if (packet_obj == nullptr)\n+\treturn nullptr;\n+    }\n+\n+  /* Check the packet is now a bytes object.  */\n+  if (!PyBytes_Check (packet_obj))\n+    {\n+      PyErr_SetString (PyExc_TypeError, _(\"Packet is not a bytes object\"));\n+      return nullptr;\n+    }\n+\n+  Py_ssize_t packet_len = 0;\n+  char *packet_str_nonconst = nullptr;\n+  if (PyBytes_AsStringAndSize (packet_obj, &packet_str_nonconst,\n+\t\t\t       &packet_len) < 0)\n+    return nullptr;\n+  const char *packet_str = packet_str_nonconst;\n+  gdb_assert (packet_str != nullptr);\n+\n+  if (packet_len == 0)\n+    {\n+      PyErr_SetString (PyExc_ValueError, _(\"Packet must not be empty\"));\n+      return nullptr;\n+    }\n+\n+  try\n+    {\n+      scoped_restore_current_thread restore_thread;\n+      switch_to_target_no_thread (conn->target);\n+\n+      gdb::array_view<const char> view (packet_str, packet_len);\n+      py_send_packet_callbacks callbacks;\n+      send_remote_packet (view, &callbacks);\n+      PyObject *result = callbacks.result ().release ();\n+      /* If we encountered an error converting the reply to a Python\n+\t object, then the result here can be nullptr.  In that case, Python\n+\t should be aware that an error occurred.  */\n+      gdb_assert ((result == nullptr) == (PyErr_Occurred () != nullptr));\n+      return result;\n+    }\n+  catch (const gdb_exception &except)\n+    {\n+      gdbpy_convert_exception (except);\n+      return nullptr;\n+    }\n+}\n+\n /* Global initialization for this file.  */\n \n void _initialize_py_connection ();\n@@ -307,6 +457,17 @@ Return true if this TargetConnection is valid, false if not.\" },\n   { NULL }\n };\n \n+/* Methods for the gdb.RemoteTargetConnection object type.  */\n+\n+static PyMethodDef remote_connection_object_methods[] =\n+{\n+  { \"send_packet\", (PyCFunction) connpy_send_packet,\n+    METH_VARARGS | METH_KEYWORDS,\n+    \"send_packet (PACKET) -> Bytes\\n\\\n+Send PACKET to a remote target, return the reply as a bytes array.\" },\n+  { NULL }\n+};\n+\n /* Attributes for the gdb.TargetConnection object type.  */\n \n static gdb_PyGetSetDef connection_object_getset[] =\n@@ -345,7 +506,7 @@ PyTypeObject connection_object_type =\n   0,\t\t\t\t  /* tp_getattro */\n   0,\t\t\t\t  /* tp_setattro */\n   0,\t\t\t\t  /* tp_as_buffer */\n-  Py_TPFLAGS_DEFAULT,\t\t  /* tp_flags */\n+  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,\t/* tp_flags */\n   \"GDB target connection object\", /* tp_doc */\n   0,\t\t\t\t  /* tp_traverse */\n   0,\t\t\t\t  /* tp_clear */\n@@ -364,3 +525,46 @@ PyTypeObject connection_object_type =\n   0,\t\t\t\t  /* tp_init */\n   0\t\t\t\t  /* tp_alloc */\n };\n+\n+/* Define the gdb.RemoteTargetConnection object type.  */\n+\n+PyTypeObject remote_connection_object_type =\n+{\n+  PyVarObject_HEAD_INIT (NULL, 0)\n+  \"gdb.RemoteTargetConnection\",\t  /* tp_name */\n+  sizeof (connection_object),\t  /* tp_basicsize */\n+  0,\t\t\t\t  /* tp_itemsize */\n+  connpy_connection_dealloc,\t  /* tp_dealloc */\n+  0,\t\t\t\t  /* tp_print */\n+  0,\t\t\t\t  /* tp_getattr */\n+  0,\t\t\t\t  /* tp_setattr */\n+  0,\t\t\t\t  /* tp_compare */\n+  connpy_repr,\t\t\t  /* tp_repr */\n+  0,\t\t\t\t  /* tp_as_number */\n+  0,\t\t\t\t  /* tp_as_sequence */\n+  0,\t\t\t\t  /* tp_as_mapping */\n+  0,\t\t\t\t  /* tp_hash  */\n+  0,\t\t\t\t  /* tp_call */\n+  0,\t\t\t\t  /* tp_str */\n+  0,\t\t\t\t  /* tp_getattro */\n+  0,\t\t\t\t  /* tp_setattro */\n+  0,\t\t\t\t  /* tp_as_buffer */\n+  Py_TPFLAGS_DEFAULT,\t\t  /* tp_flags */\n+  \"GDB remote target connection object\",\t  /* tp_doc */\n+  0,\t\t\t\t  /* tp_traverse */\n+  0,\t\t\t\t  /* tp_clear */\n+  0,\t\t\t\t  /* tp_richcompare */\n+  0,\t\t\t\t  /* tp_weaklistoffset */\n+  0,\t\t\t\t  /* tp_iter */\n+  0,\t\t\t\t  /* tp_iternext */\n+  remote_connection_object_methods,\t  /* tp_methods */\n+  0,\t\t\t\t  /* tp_members */\n+  0,\t\t\t\t  /* tp_getset */\n+  &connection_object_type,\t  /* tp_base */\n+  0,\t\t\t\t  /* tp_dict */\n+  0,\t\t\t\t  /* tp_descr_get */\n+  0,\t\t\t\t  /* tp_descr_set */\n+  0,\t\t\t\t  /* tp_dictoffset */\n+  0,\t\t\t\t  /* tp_init */\n+  0\t\t\t\t  /* tp_alloc */\n+};"
    },
    {
      "sha": "7df904bf10b049b65cfab89a3097ddd7cab81555",
      "filename": "gdb/remote.c",
      "status": "modified",
      "additions": 9,
      "deletions": 0,
      "changes": 9,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/remote.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/remote.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.c?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -994,6 +994,15 @@ class extended_remote_target final : public remote_target\n   bool supports_disable_randomization () override;\n };\n \n+/* See remote.h.  */\n+\n+bool\n+is_remote_target (process_stratum_target *target)\n+{\n+  remote_target *rt = dynamic_cast<remote_target *> (target);\n+  return rt != nullptr;\n+}\n+\n /* Per-program-space data key.  */\n static const struct program_space_key<char, gdb::xfree_deleter<char>>\n   remote_pspace_data;"
    },
    {
      "sha": "0ddf55d19d3e65d4cf33ff2500f3f536383d1ee6",
      "filename": "gdb/remote.h",
      "status": "modified",
      "additions": 8,
      "deletions": 0,
      "changes": 8,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/remote.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/remote.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/remote.h?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -24,6 +24,8 @@\n struct target_desc;\n struct remote_target;\n \n+class process_stratum_target;\n+\n /* True when printing \"remote\" debug statements is enabled.  */\n \n extern bool remote_debug;\n@@ -113,4 +115,10 @@ struct send_remote_packet_callbacks\n extern void send_remote_packet (gdb::array_view<const char> &buf,\n \t\t\t\tsend_remote_packet_callbacks *callbacks);\n \n+\n+/* Return true if TARGET is a remote, or extended-remote target, otherwise,\n+   return false.  */\n+\n+extern bool is_remote_target (process_stratum_target *target);\n+\n #endif"
    },
    {
      "sha": "96c83781839bd15bddf7a39e31499cf3bc4a82b5",
      "filename": "gdb/testsuite/gdb.python/py-connection.exp",
      "status": "modified",
      "additions": 10,
      "deletions": 4,
      "changes": 14,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/testsuite/gdb.python/py-connection.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/testsuite/gdb.python/py-connection.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-connection.exp?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -33,12 +33,18 @@ if ![runto_main] then {\n     return 0\n }\n \n+if { [target_info exists gdb_protocol] } {\n+    set connection_type \"RemoteTargetConnection\"\n+} else {\n+    set connection_type \"TargetConnection\"\n+}\n+\n # Create a gdb.TargetConnection object and check it is initially\n # valid.\n gdb_test_no_output \"python conn = gdb.selected_inferior().connection\"\n gdb_test \"python print(conn)\" \\\n-    \"<gdb.TargetConnection num=1, what=\\\"\\[^\\\"\\]+\\\">\" \\\n-    \"print gdb.TargetConnection while it is still valid\"\n+    \"<gdb.${connection_type} num=1, what=\\\"\\[^\\\"\\]+\\\">\" \\\n+    \"print gdb.${connection_type} while it is still valid\"\n gdb_test \"python print(conn.is_valid())\" \"True\" \"is_valid returns True\"\n \n # Get the connection again, and ensure we get the exact same object.\n@@ -53,8 +59,8 @@ gdb_test \"disconnect\" \"\" \"kill the inferior\" \\\n     \"A program is being debugged already\\\\.  Kill it\\\\? .*y or n. $\" \"y\"\n gdb_test \"info connections\" \"No connections\\\\.\" \\\n     \"info connections now all the connections have gone\"\n-gdb_test \"python print(conn)\" \"<gdb.TargetConnection \\\\(invalid\\\\)>\" \\\n-    \"print gdb.TargetConnection now its invalid\"\n+gdb_test \"python print(conn)\" \"<gdb.${connection_type} \\\\(invalid\\\\)>\" \\\n+    \"print gdb.${connection_type} now its invalid\"\n gdb_test \"python print(conn.is_valid())\" \"False\" \"is_valid returns False\"\n \n # Now check that accessing properties of the invalid connection cases"
    },
    {
      "sha": "49fbd79e11b5d8c82d54fe13032fe57bc3327560",
      "filename": "gdb/testsuite/gdb.python/py-send-packet.c",
      "status": "added",
      "additions": 31,
      "deletions": 0,
      "changes": 31,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/testsuite/gdb.python/py-send-packet.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/testsuite/gdb.python/py-send-packet.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-send-packet.c?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -0,0 +1,31 @@\n+/* This testcase is part of GDB, the GNU debugger.\n+\n+   Copyright 2021 Free Software Foundation, Inc.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+volatile int global_var = 0;\n+\n+void\n+breakpt ()\n+{\n+  /* Nothing.  */\n+}\n+\n+int\n+main (void)\n+{\n+  breakpt ();\n+  return 0;\n+}"
    },
    {
      "sha": "59035757414c5275342061320a2bbe33e3e6cc07",
      "filename": "gdb/testsuite/gdb.python/py-send-packet.exp",
      "status": "added",
      "additions": 99,
      "deletions": 0,
      "changes": 99,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/testsuite/gdb.python/py-send-packet.exp",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/testsuite/gdb.python/py-send-packet.exp",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-send-packet.exp?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -0,0 +1,99 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+# Test the gdb.RemoteTargetConnection.send_packet API.  This is done\n+# by connecting to a remote target and fetching the thread list in two\n+# ways, first, we manually send the packets required to read the\n+# thread list using gdb.TargetConnection.send_packet, then we compare\n+# the results to the thread list using the standard API calls.\n+\n+load_lib gdb-python.exp\n+load_lib gdbserver-support.exp\n+\n+standard_testfile\n+\n+if {[skip_gdbserver_tests]} {\n+    return 0\n+}\n+\n+if { [prepare_for_testing \"failed to prepare\" ${testfile} ${srcfile}] } {\n+    return -1\n+}\n+\n+if { [skip_python_tests] } {\n+    return 0\n+}\n+\n+# Make sure we're disconnected, in case we're testing with an\n+# extended-remote board, therefore already connected.\n+gdb_test \"disconnect\" \".*\"\n+\n+gdbserver_run \"\"\n+\n+gdb_breakpoint \"breakpt\"\n+gdb_continue_to_breakpoint \"breakpt\"\n+\n+# Source the python script.\n+set remote_python_file [gdb_remote_download host \\\n+\t\t\t    ${srcdir}/${subdir}/${testfile}.py]\n+gdb_test \"source $remote_python_file\" \"Sourcing complete\\\\.\" \\\n+    \"source ${testfile}.py script\"\n+\n+# The test is actually written in the Python script.  Run it now.\n+gdb_test \"python run_send_packet_test()\" \"Send packet test passed\"\n+\n+# Check the string representation of a remote target connection.\n+gdb_test \"python print(gdb.selected_inferior().connection)\" \\\n+    \"<gdb.RemoteTargetConnection num=$decimal, what=\\\".*\\\">\"\n+\n+# Check to see if there's any auxv data for this target.\n+gdb_test_multiple \"info auxv\" \"\" {\n+    -re -wrap \"The program has no auxiliary information now\\\\. \" {\n+\tset skip_auxv_test true\n+    }\n+    -re -wrap \"0\\\\s+AT_NULL\\\\s+End of vector\\\\s+0x0\" {\n+\tset skip_auxv_test false\n+    }\n+}\n+\n+if { ! $skip_auxv_test } {\n+    # Use 'maint packet' to fetch the auxv data.\n+    set reply_data \"\"\n+    gdb_test_multiple \"maint packet qXfer:auxv:read::0,1000\" \"\" {\n+\t-re \"sending: \\\"qXfer:auxv:read::0,1000\\\"\\r\\n\" {\n+\t    exp_continue\n+\t}\n+\t-re -wrap \"received: \\\"(.*)\\\"\" {\n+\t    set reply_data $expect_out(1,string)\n+\t}\n+    }\n+\n+    # Expand the '\\x' in the output, so we can pass a string through\n+    # to Python.\n+    set reply_data [string map {\\x \\\\x} $reply_data]\n+    gdb_assert { ![string equal \"$reply_data\" \"\"] }\n+\n+    # Run the test, fetches the auxv data in Python and confirm it\n+    # matches the expected results.\n+    gdb_test \"python run_auxv_send_packet_test(\\\"$reply_data\\\")\" \\\n+\t\"auxv send packet test passed\"\n+}\n+\n+set sizeof_global_var [get_valueof \"/d\" \"sizeof(global_var)\" \"UNKNOWN\"]\n+if { $sizeof_global_var == 4 } {\n+    gdb_test_no_output \"set debug remote 1\"\n+    gdb_test \"python run_set_global_var_test()\" \\\n+\t\"set global_var test passed\"\n+}"
    },
    {
      "sha": "23abc42101ce20acec02d6d0d2ecd86cce6cf65f",
      "filename": "gdb/testsuite/gdb.python/py-send-packet.py",
      "status": "added",
      "additions": 176,
      "deletions": 0,
      "changes": 176,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/testsuite/gdb.python/py-send-packet.py",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/24b2de7b776f8f23788d855b1eec290c6e208821/gdb/testsuite/gdb.python/py-send-packet.py",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/testsuite/gdb.python/py-send-packet.py?ref=24b2de7b776f8f23788d855b1eec290c6e208821",
      "patch": "@@ -0,0 +1,176 @@\n+# Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with this program.  If not, see <http://www.gnu.org/licenses/>.\n+\n+import xml.etree.ElementTree as ET\n+import gdb\n+\n+# Make use of gdb.RemoteTargetConnection.send_packet to fetch the\n+# thread list from the remote target.\n+#\n+# Sending existing serial protocol packets like this is not a good\n+# idea, there should be better ways to get this information using an\n+# official API, this is just being used as a test case.\n+#\n+# Really, the send_packet API would be used to send target\n+# specific packets to the target, but these are, by definition, target\n+# specific, so hard to test in a general testsuite.\n+def get_thread_list_str():\n+    start_pos = 0\n+    thread_desc = \"\"\n+    conn = gdb.selected_inferior().connection\n+    if not isinstance(conn, gdb.RemoteTargetConnection):\n+        raise gdb.GdbError(\"connection is the wrong type\")\n+    while True:\n+        str = conn.send_packet(\"qXfer:threads:read::%d,200\" % start_pos).decode(\"ascii\")\n+        start_pos += 200\n+        c = str[0]\n+        str = str[1:]\n+        thread_desc += str\n+        if c == \"l\":\n+            break\n+    return thread_desc\n+\n+\n+# Use gdb.RemoteTargetConnection.send_packet to manually fetch the\n+# thread list, then extract the thread list using the gdb.Inferior and\n+# gdb.InferiorThread API.  Compare the two results to ensure we\n+# managed to successfully read the thread list from the remote.\n+def run_send_packet_test():\n+    # Find the IDs of all current threads.\n+    all_threads = {}\n+    for inf in gdb.inferiors():\n+        for thr in inf.threads():\n+            id = \"p%x.%x\" % (thr.ptid[0], thr.ptid[1])\n+            all_threads[id] = False\n+\n+    # Now fetch the thread list from the remote, and parse the XML.\n+    str = get_thread_list_str()\n+    threads_xml = ET.fromstring(str)\n+\n+    # Look over all threads in the XML list and check we expected to\n+    # find them, mark the ones we do find.\n+    for thr in threads_xml:\n+        id = thr.get(\"id\")\n+        if not id in all_threads:\n+            raise \"found unexpected thread in remote thread list\"\n+        else:\n+            all_threads[id] = True\n+\n+    # Check that all the threads were found in the XML list.\n+    for id in all_threads:\n+        if not all_threads[id]:\n+            raise \"thread missingt from remote thread list\"\n+\n+    # Test complete.\n+    print(\"Send packet test passed\")\n+\n+\n+# Convert a bytes object to a string.  This follows the same rules as\n+# the 'maint packet' command so that the output from the two sources\n+# can be compared.\n+def bytes_to_string(byte_array):\n+\n+    # Python 2/3 compatibility.  We need a function that can give us\n+    # the value of a single element in BYTE_ARRAY as an integer.\n+    if sys.version_info[0] > 2:\n+        value_of_single_byte = int\n+    else:\n+        value_of_single_byte = ord\n+\n+    res = \"\"\n+    for b in byte_array:\n+        b = value_of_single_byte(b)\n+        if b >= 32 and b <= 126:\n+            res = res + (\"%c\" % b)\n+        else:\n+            res = res + (\"\\\\x%02x\" % b)\n+    return res\n+\n+\n+# A very simple test for sending the packet that reads the auxv data.\n+# We convert the result to a string and expect to find some\n+# hex-encoded bytes in the output.  This test will only work on\n+# targets that actually supply auxv data.\n+def run_auxv_send_packet_test(expected_result):\n+    inf = gdb.selected_inferior()\n+    conn = inf.connection\n+    assert isinstance(conn, gdb.RemoteTargetConnection)\n+    res = conn.send_packet(\"qXfer:auxv:read::0,1000\")\n+    assert isinstance(res, bytes)\n+    string = bytes_to_string(res)\n+    assert string.count(\"\\\\x\") > 0\n+    assert string == expected_result\n+    print(\"auxv send packet test passed\")\n+\n+\n+# Check that the value of 'global_var' is EXPECTED_VAL.\n+def check_global_var(expected_val):\n+    val = int(gdb.parse_and_eval(\"global_var\"))\n+    val = val & 0xFFFFFFFF\n+    if val != expected_val:\n+        raise gdb.GdbError(\"global_var is 0x%x, expected 0x%x\" % (val, expected_val))\n+\n+\n+# Set the 'X' packet to the remote target to set a global variable.\n+# Checks that we can send byte values.\n+def run_set_global_var_test():\n+    inf = gdb.selected_inferior()\n+    conn = inf.connection\n+    assert isinstance(conn, gdb.RemoteTargetConnection)\n+    addr = gdb.parse_and_eval(\"&global_var\")\n+    res = conn.send_packet(\"X%x,4:\\x01\\x01\\x01\\x01\" % addr)\n+    assert isinstance(res, bytes)\n+    check_global_var(0x01010101)\n+    res = conn.send_packet(b\"X%x,4:\\x02\\x02\\x02\\x02\" % addr)\n+    assert isinstance(res, bytes)\n+    check_global_var(0x02020202)\n+    if sys.version_info[0] > 2:\n+        # On Python 3 this first attempt will not work as we're\n+        # passing a Unicode string containing non-ascii characters.\n+        saw_error = False\n+        try:\n+            res = conn.send_packet(\"X%x,4:\\xff\\xff\\xff\\xff\" % addr)\n+        except UnicodeError:\n+            saw_error = True\n+        except:\n+            assert False\n+        assert saw_error\n+        check_global_var(0x02020202)\n+        # Now we pass a bytes object, which will work.\n+        res = conn.send_packet(b\"X%x,4:\\xff\\xff\\xff\\xff\" % addr)\n+        check_global_var(0xFFFFFFFF)\n+    else:\n+        # On Python 2 we need to force the creation of a Unicode\n+        # string, but, with that done, we expect to see the same error\n+        # as on Python 3; the unicode string contains non-ascii\n+        # characters.\n+        saw_error = False\n+        try:\n+            res = conn.send_packet(unicode(\"X%x,4:\\xff\\xff\\xff\\xff\") % addr)\n+        except UnicodeError:\n+            saw_error = True\n+        except:\n+            assert False\n+        assert saw_error\n+        check_global_var(0x02020202)\n+        # Now we pass a plain string, which, on Python 2, is the same\n+        # as a bytes object, this, we expect to work.\n+        res = conn.send_packet(\"X%x,4:\\xff\\xff\\xff\\xff\" % addr)\n+        check_global_var(0xFFFFFFFF)\n+    print(\"set global_var test passed\")\n+\n+\n+# Just to indicate the file was sourced correctly.\n+print(\"Sourcing complete.\")"
    }
  ]
}