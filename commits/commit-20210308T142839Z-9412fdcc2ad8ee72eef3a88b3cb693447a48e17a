{
  "sha": "9412fdcc2ad8ee72eef3a88b3cb693447a48e17a",
  "node_id": "MDY6Q29tbWl0MTM4Njg2ODE6OTQxMmZkY2MyYWQ4ZWU3MmVlZjNhODhiM2NiNjkzNDQ3YTQ4ZTE3YQ==",
  "commit": {
    "author": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:27:57Z"
    },
    "committer": {
      "name": "Tom Tromey",
      "email": "tom@tromey.com",
      "date": "2021-03-08T14:28:39Z"
    },
    "message": "Convert d-exp.y to use operations\n\nThis converts the D parser to generate operations rather than\nexp_elements.\n\ngdb/ChangeLog\n2021-03-08  Tom Tromey  <tom@tromey.com>\n\n\t* d-exp.y: Create operations.\n\t(d_parse): Update.",
    "tree": {
      "sha": "2d0dfc2c6695a75b5113e628fd60a90260abb3d7",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/2d0dfc2c6695a75b5113e628fd60a90260abb3d7"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a/comments",
  "author": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": {
    "login": "tromey",
    "id": 1557670,
    "node_id": "MDQ6VXNlcjE1NTc2NzA=",
    "avatar_url": "https://avatars.githubusercontent.com/u/1557670?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/tromey",
    "html_url": "https://github.com/tromey",
    "followers_url": "https://api.github.com/users/tromey/followers",
    "following_url": "https://api.github.com/users/tromey/following{/other_user}",
    "gists_url": "https://api.github.com/users/tromey/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/tromey/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/tromey/subscriptions",
    "organizations_url": "https://api.github.com/users/tromey/orgs",
    "repos_url": "https://api.github.com/users/tromey/repos",
    "events_url": "https://api.github.com/users/tromey/events{/privacy}",
    "received_events_url": "https://api.github.com/users/tromey/received_events",
    "type": "User",
    "site_admin": false
  },
  "parents": [
    {
      "sha": "bb4e0574881009bea97136968f92003e9a4aa46e",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/bb4e0574881009bea97136968f92003e9a4aa46e",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/bb4e0574881009bea97136968f92003e9a4aa46e"
    }
  ],
  "stats": {
    "total": 254,
    "additions": 134,
    "deletions": 120
  },
  "files": [
    {
      "sha": "124eaafda97ea003f71d0604cb92f95b2ab0e4af",
      "filename": "gdb/ChangeLog",
      "status": "modified",
      "additions": 5,
      "deletions": 0,
      "changes": 5,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a/gdb/ChangeLog",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a/gdb/ChangeLog",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/ChangeLog?ref=9412fdcc2ad8ee72eef3a88b3cb693447a48e17a",
      "patch": "@@ -1,3 +1,8 @@\n+2021-03-08  Tom Tromey  <tom@tromey.com>\n+\n+\t* d-exp.y: Create operations.\n+\t(d_parse): Update.\n+\n 2021-03-08  Tom Tromey  <tom@tromey.com>\n \n \t* go-exp.y: Create operations."
    },
    {
      "sha": "1a75431ea2763371212e7a97486c82588271cfd2",
      "filename": "gdb/d-exp.y",
      "status": "modified",
      "additions": 129,
      "deletions": 120,
      "changes": 249,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a/gdb/d-exp.y",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/9412fdcc2ad8ee72eef3a88b3cb693447a48e17a/gdb/d-exp.y",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/d-exp.y?ref=9412fdcc2ad8ee72eef3a88b3cb693447a48e17a",
      "patch": "@@ -52,6 +52,7 @@\n #include \"charset.h\"\n #include \"block.h\"\n #include \"type-stack.h\"\n+#include \"expop.h\"\n \n #define parse_type(ps) builtin_type (ps->gdbarch ())\n #define parse_d_type(ps) builtin_d_type (ps->gdbarch ())\n@@ -77,6 +78,8 @@ static void yyerror (const char *);\n \n static int type_aggregate_p (struct type *);\n \n+using namespace expr;\n+\n %}\n \n /* Although the yacc \"value\" of an expression is not used,\n@@ -191,53 +194,63 @@ Expression:\n CommaExpression:\n \tAssignExpression\n |\tAssignExpression ',' CommaExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_COMMA); }\n+\t\t{ pstate->wrap2<comma_operation> (); }\n ;\n \n AssignExpression:\n \tConditionalExpression\n |\tConditionalExpression '=' AssignExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN); }\n+\t\t{ pstate->wrap2<assign_operation> (); }\n |\tConditionalExpression ASSIGN_MODIFY AssignExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY);\n-\t\t  write_exp_elt_opcode (pstate, $2);\n-\t\t  write_exp_elt_opcode (pstate, BINOP_ASSIGN_MODIFY); }\n+\t\t{\n+\t\t  operation_up rhs = pstate->pop ();\n+\t\t  operation_up lhs = pstate->pop ();\n+\t\t  pstate->push_new<assign_modify_operation>\n+\t\t    ($2, std::move (lhs), std::move (rhs));\n+\t\t}\n ;\n \n ConditionalExpression:\n \tOrOrExpression\n |\tOrOrExpression '?' Expression ':' ConditionalExpression\n-\t\t{ write_exp_elt_opcode (pstate, TERNOP_COND); }\n+\t\t{\n+\t\t  operation_up last = pstate->pop ();\n+\t\t  operation_up mid = pstate->pop ();\n+\t\t  operation_up first = pstate->pop ();\n+\t\t  pstate->push_new<ternop_cond_operation>\n+\t\t    (std::move (first), std::move (mid),\n+\t\t     std::move (last));\n+\t\t}\n ;\n \n OrOrExpression:\n \tAndAndExpression\n |\tOrOrExpression OROR AndAndExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_OR); }\n+\t\t{ pstate->wrap2<logical_or_operation> (); }\n ;\n \n AndAndExpression:\n \tOrExpression\n |\tAndAndExpression ANDAND OrExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_LOGICAL_AND); }\n+\t\t{ pstate->wrap2<logical_and_operation> (); }\n ;\n \n OrExpression:\n \tXorExpression\n |\tOrExpression '|' XorExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_IOR); }\n+\t\t{ pstate->wrap2<bitwise_ior_operation> (); }\n ;\n \n XorExpression:\n \tAndExpression\n |\tXorExpression '^' AndExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_XOR); }\n+\t\t{ pstate->wrap2<bitwise_xor_operation> (); }\n ;\n \n AndExpression:\n \tCmpExpression\n |\tAndExpression '&' CmpExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_BITWISE_AND); }\n+\t\t{ pstate->wrap2<bitwise_and_operation> (); }\n ;\n \n CmpExpression:\n@@ -249,120 +262,121 @@ CmpExpression:\n \n EqualExpression:\n \tShiftExpression EQUAL ShiftExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }\n+\t\t{ pstate->wrap2<equal_operation> (); }\n |\tShiftExpression NOTEQUAL ShiftExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }\n+\t\t{ pstate->wrap2<notequal_operation> (); }\n ;\n \n IdentityExpression:\n \tShiftExpression IDENTITY ShiftExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_EQUAL); }\n+\t\t{ pstate->wrap2<equal_operation> (); }\n |\tShiftExpression NOTIDENTITY ShiftExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_NOTEQUAL); }\n+\t\t{ pstate->wrap2<notequal_operation> (); }\n ;\n \n RelExpression:\n \tShiftExpression '<' ShiftExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_LESS); }\n+\t\t{ pstate->wrap2<less_operation> (); }\n |\tShiftExpression LEQ ShiftExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_LEQ); }\n+\t\t{ pstate->wrap2<leq_operation> (); }\n |\tShiftExpression '>' ShiftExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_GTR); }\n+\t\t{ pstate->wrap2<gtr_operation> (); }\n |\tShiftExpression GEQ ShiftExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_GEQ); }\n+\t\t{ pstate->wrap2<geq_operation> (); }\n ;\n \n ShiftExpression:\n \tAddExpression\n |\tShiftExpression LSH AddExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_LSH); }\n+\t\t{ pstate->wrap2<lsh_operation> (); }\n |\tShiftExpression RSH AddExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_RSH); }\n+\t\t{ pstate->wrap2<rsh_operation> (); }\n ;\n \n AddExpression:\n \tMulExpression\n |\tAddExpression '+' MulExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_ADD); }\n+\t\t{ pstate->wrap2<add_operation> (); }\n |\tAddExpression '-' MulExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_SUB); }\n+\t\t{ pstate->wrap2<sub_operation> (); }\n |\tAddExpression '~' MulExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_CONCAT); }\n+\t\t{ pstate->wrap2<concat_operation> (); }\n ;\n \n MulExpression:\n \tUnaryExpression\n |\tMulExpression '*' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_MUL); }\n+\t\t{ pstate->wrap2<mul_operation> (); }\n |\tMulExpression '/' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_DIV); }\n+\t\t{ pstate->wrap2<div_operation> (); }\n |\tMulExpression '%' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_REM); }\n+\t\t{ pstate->wrap2<rem_operation> (); }\n \n UnaryExpression:\n \t'&' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_ADDR); }\n+\t\t{ pstate->wrap<unop_addr_operation> (); }\n |\tINCREMENT UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_PREINCREMENT); }\n+\t\t{ pstate->wrap<preinc_operation> (); }\n |\tDECREMENT UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_PREDECREMENT); }\n+\t\t{ pstate->wrap<predec_operation> (); }\n |\t'*' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_IND); }\n+\t\t{ pstate->wrap<unop_ind_operation> (); }\n |\t'-' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_NEG); }\n+\t\t{ pstate->wrap<unary_neg_operation> (); }\n |\t'+' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_PLUS); }\n+\t\t{ pstate->wrap<unary_plus_operation> (); }\n |\t'!' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_LOGICAL_NOT); }\n+\t\t{ pstate->wrap<unary_logical_not_operation> (); }\n |\t'~' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_COMPLEMENT); }\n+\t\t{ pstate->wrap<unary_complement_operation> (); }\n |\tTypeExp '.' SIZEOF_KEYWORD\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_SIZEOF); }\n+\t\t{ pstate->wrap<unop_sizeof_operation> (); }\n |\tCastExpression\n |\tPowExpression\n ;\n \n CastExpression:\n \tCAST_KEYWORD '(' TypeExp ')' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_CAST_TYPE); }\n+\t\t{ pstate->wrap2<unop_cast_type_operation> (); }\n \t/* C style cast is illegal D, but is still recognised in\n \t   the grammar, so we keep this around for convenience.  */\n |\t'(' TypeExp ')' UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_CAST_TYPE); }\n-\n+\t\t{ pstate->wrap2<unop_cast_type_operation> (); }\n ;\n \n PowExpression:\n \tPostfixExpression\n |\tPostfixExpression HATHAT UnaryExpression\n-\t\t{ write_exp_elt_opcode (pstate, BINOP_EXP); }\n+\t\t{ pstate->wrap2<exp_operation> (); }\n ;\n \n PostfixExpression:\n \tPrimaryExpression\n |\tPostfixExpression '.' COMPLETE\n-\t\t{ struct stoken s;\n-\t\t  pstate->mark_struct_expression ();\n-\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t  s.ptr = \"\";\n-\t\t  s.length = 0;\n-\t\t  write_exp_string (pstate, s);\n-\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t{\n+\t\t  structop_base_operation *op\n+\t\t    = new structop_ptr_operation (pstate->pop (), \"\");\n+\t\t  pstate->mark_struct_expression (op);\n+\t\t  pstate->push (operation_up (op));\n+\t\t}\n |\tPostfixExpression '.' IDENTIFIER\n-\t\t{ write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t  write_exp_string (pstate, $3);\n-\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t{\n+\t\t  pstate->push_new<structop_operation>\n+\t\t    (pstate->pop (), copy_name ($3));\n+\t\t}\n |\tPostfixExpression '.' IDENTIFIER COMPLETE\n-\t\t{ pstate->mark_struct_expression ();\n-\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT);\n-\t\t  write_exp_string (pstate, $3);\n-\t\t  write_exp_elt_opcode (pstate, STRUCTOP_STRUCT); }\n+\t\t{\n+\t\t  structop_base_operation *op\n+\t\t    = new structop_operation (pstate->pop (), copy_name ($3));\n+\t\t  pstate->mark_struct_expression (op);\n+\t\t  pstate->push (operation_up (op));\n+\t\t}\n |\tPostfixExpression '.' SIZEOF_KEYWORD\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_SIZEOF); }\n+\t\t{ pstate->wrap<unop_sizeof_operation> (); }\n |\tPostfixExpression INCREMENT\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_POSTINCREMENT); }\n+\t\t{ pstate->wrap<postinc_operation> (); }\n |\tPostfixExpression DECREMENT\n-\t\t{ write_exp_elt_opcode (pstate, UNOP_POSTDECREMENT); }\n+\t\t{ pstate->wrap<postdec_operation> (); }\n |\tCallExpression\n |\tIndexExpression\n |\tSliceExpression\n@@ -385,29 +399,40 @@ CallExpression:\n \tPostfixExpression '('\n \t\t{ pstate->start_arglist (); }\n \tArgumentList_opt ')'\n-\t\t{ write_exp_elt_opcode (pstate, OP_FUNCALL);\n-\t\t  write_exp_elt_longcst (pstate, pstate->end_arglist ());\n-\t\t  write_exp_elt_opcode (pstate, OP_FUNCALL); }\n+\t\t{\n+\t\t  std::vector<operation_up> args\n+\t\t    = pstate->pop_vector (pstate->end_arglist ());\n+\t\t  pstate->push_new<funcall_operation>\n+\t\t    (pstate->pop (), std::move (args));\n+\t\t}\n ;\n \n IndexExpression:\n \tPostfixExpression '[' ArgumentList ']'\n \t\t{ if (pstate->arglist_len > 0)\n \t\t    {\n-\t\t      write_exp_elt_opcode (pstate, MULTI_SUBSCRIPT);\n-\t\t      write_exp_elt_longcst (pstate, pstate->arglist_len);\n-\t\t      write_exp_elt_opcode (pstate, MULTI_SUBSCRIPT);\n+\t\t      std::vector<operation_up> args\n+\t\t\t= pstate->pop_vector (pstate->arglist_len);\n+\t\t      pstate->push_new<multi_subscript_operation>\n+\t\t\t(pstate->pop (), std::move (args));\n \t\t    }\n \t\t  else\n-\t\t    write_exp_elt_opcode (pstate, BINOP_SUBSCRIPT);\n+\t\t    pstate->wrap2<subscript_operation> ();\n \t\t}\n ;\n \n SliceExpression:\n \tPostfixExpression '[' ']'\n \t\t{ /* Do nothing.  */ }\n |\tPostfixExpression '[' AssignExpression DOTDOT AssignExpression ']'\n-\t\t{ write_exp_elt_opcode (pstate, TERNOP_SLICE); }\n+\t\t{\n+\t\t  operation_up last = pstate->pop ();\n+\t\t  operation_up mid = pstate->pop ();\n+\t\t  operation_up first = pstate->pop ();\n+\t\t  pstate->push_new<ternop_slice_operation>\n+\t\t    (std::move (first), std::move (mid),\n+\t\t     std::move (last));\n+\t\t}\n ;\n \n PrimaryExpression:\n@@ -427,28 +452,26 @@ PrimaryExpression:\n \t\t    {\n \t\t      if (symbol_read_needs_frame (sym.symbol))\n \t\t\tpstate->block_tracker->update (sym);\n-\t\t      write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n-\t\t      write_exp_elt_block (pstate, sym.block);\n-\t\t      write_exp_elt_sym (pstate, sym.symbol);\n-\t\t      write_exp_elt_opcode (pstate, OP_VAR_VALUE);\n+\t\t      pstate->push_new<var_value_operation> (sym.symbol,\n+\t\t\t\t\t\t\t     sym.block);\n \t\t    }\n \t\t  else if (is_a_field_of_this.type != NULL)\n \t\t     {\n \t\t      /* It hangs off of `this'.  Must not inadvertently convert from a\n \t\t\t method call to data ref.  */\n \t\t      pstate->block_tracker->update (sym);\n-\t\t      write_exp_elt_opcode (pstate, OP_THIS);\n-\t\t      write_exp_elt_opcode (pstate, OP_THIS);\n-\t\t      write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n-\t\t      write_exp_string (pstate, $1);\n-\t\t      write_exp_elt_opcode (pstate, STRUCTOP_PTR);\n+\t\t      operation_up thisop\n+\t\t\t= make_operation<op_this_operation> ();\n+\t\t      pstate->push_new<structop_ptr_operation>\n+\t\t\t(std::move (thisop), std::move (copy));\n \t\t    }\n \t\t  else\n \t\t    {\n \t\t      /* Lookup foreign name in global static symbols.  */\n \t\t      msymbol = lookup_bound_minimal_symbol (copy.c_str ());\n \t\t      if (msymbol.minsym != NULL)\n-\t\t\twrite_exp_msymbol (pstate, msymbol);\n+\t\t\tpstate->push_new<var_msym_value_operation>\n+\t\t\t  (msymbol.minsym, msymbol.objfile);\n \t\t      else if (!have_full_symbols () && !have_partial_symbols ())\n \t\t\terror (_(\"No symbol table is loaded.  Use the \\\"file\\\" command\"));\n \t\t      else\n@@ -476,9 +499,7 @@ PrimaryExpression:\n \t\t\t\tlookup_symbol (name.c_str (),\n \t\t\t\t\t       (const struct block *) NULL,\n \t\t\t\t\t       VAR_DOMAIN, NULL);\n-\t\t\t      write_exp_symbol_reference (pstate,\n-\t\t\t\t\t\t\t  name.c_str (),\n-\t\t\t\t\t\t\t  sym);\n+\t\t\t      pstate->push_symbol (name.c_str (), sym);\n \t\t\t    }\n \t\t\t  else\n \t\t\t    {\n@@ -488,65 +509,54 @@ PrimaryExpression:\n \t\t\t\terror (_(\"`%s' is not defined as an aggregate type.\"),\n \t\t\t\t       TYPE_SAFE_NAME (type));\n \n-\t\t\t      write_exp_elt_opcode (pstate, OP_SCOPE);\n-\t\t\t      write_exp_elt_type (pstate, type);\n-\t\t\t      write_exp_string (pstate, $3);\n-\t\t\t      write_exp_elt_opcode (pstate, OP_SCOPE);\n+\t\t\t      pstate->push_new<scope_operation>\n+\t\t\t\t(type, copy_name ($3));\n \t\t\t    }\n \t\t\t}\n |\tDOLLAR_VARIABLE\n-\t\t{ write_dollar_variable (pstate, $1); }\n+\t\t{ pstate->push_dollar ($1); }\n |\tNAME_OR_INT\n \t\t{ YYSTYPE val;\n \t\t  parse_number (pstate, $1.ptr, $1.length, 0, &val);\n-\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t  write_exp_elt_type (pstate, val.typed_val_int.type);\n-\t\t  write_exp_elt_longcst (pstate,\n-\t\t\t\t\t (LONGEST) val.typed_val_int.val);\n-\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t  pstate->push_new<long_const_operation>\n+\t\t    (val.typed_val_int.type, val.typed_val_int.val); }\n |\tNULL_KEYWORD\n \t\t{ struct type *type = parse_d_type (pstate)->builtin_void;\n \t\t  type = lookup_pointer_type (type);\n-\t\t  write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t  write_exp_elt_type (pstate, type);\n-\t\t  write_exp_elt_longcst (pstate, (LONGEST) 0);\n-\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t  pstate->push_new<long_const_operation> (type, 0); }\n |\tTRUE_KEYWORD\n-\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t  write_exp_elt_longcst (pstate, (LONGEST) 1);\n-\t\t  write_exp_elt_opcode (pstate, OP_BOOL); }\n+\t\t{ pstate->push_new<bool_operation> (true); }\n |\tFALSE_KEYWORD\n-\t\t{ write_exp_elt_opcode (pstate, OP_BOOL);\n-\t\t  write_exp_elt_longcst (pstate, (LONGEST) 0);\n-\t\t  write_exp_elt_opcode (pstate, OP_BOOL); }\n+\t\t{ pstate->push_new<bool_operation> (false); }\n |\tINTEGER_LITERAL\n-\t\t{ write_exp_elt_opcode (pstate, OP_LONG);\n-\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t  write_exp_elt_longcst (pstate, (LONGEST)($1.val));\n-\t\t  write_exp_elt_opcode (pstate, OP_LONG); }\n+\t\t{ pstate->push_new<long_const_operation> ($1.type, $1.val); }\n |\tFLOAT_LITERAL\n-\t\t{ write_exp_elt_opcode (pstate, OP_FLOAT);\n-\t\t  write_exp_elt_type (pstate, $1.type);\n-\t\t  write_exp_elt_floatcst (pstate, $1.val);\n-\t\t  write_exp_elt_opcode (pstate, OP_FLOAT); }\n+\t\t{\n+\t\t  float_data data;\n+\t\t  std::copy (std::begin ($1.val), std::end ($1.val),\n+\t\t\t     std::begin (data));\n+\t\t  pstate->push_new<float_const_operation> ($1.type, data);\n+\t\t}\n |\tCHARACTER_LITERAL\n \t\t{ struct stoken_vector vec;\n \t\t  vec.len = 1;\n \t\t  vec.tokens = &$1;\n-\t\t  write_exp_string_vector (pstate, $1.type, &vec); }\n+\t\t  pstate->push_c_string (0, &vec); }\n |\tStringExp\n \t\t{ int i;\n-\t\t  write_exp_string_vector (pstate, 0, &$1);\n+\t\t  pstate->push_c_string (0, &$1);\n \t\t  for (i = 0; i < $1.len; ++i)\n \t\t    free ($1.tokens[i].ptr);\n \t\t  free ($1.tokens); }\n |\tArrayLiteral\n-\t\t{ write_exp_elt_opcode (pstate, OP_ARRAY);\n-\t\t  write_exp_elt_longcst (pstate, (LONGEST) 0);\n-\t\t  write_exp_elt_longcst (pstate, (LONGEST) $1 - 1);\n-\t\t  write_exp_elt_opcode (pstate, OP_ARRAY); }\n+\t\t{\n+\t\t  std::vector<operation_up> args\n+\t\t    = pstate->pop_vector ($1);\n+\t\t  pstate->push_new<array_operation>\n+\t\t    (0, $1 - 1, std::move (args));\n+\t\t}\n |\tTYPEOF_KEYWORD '(' Expression ')'\n-\t\t{ write_exp_elt_opcode (pstate, OP_TYPEOF); }\n+\t\t{ pstate->wrap<typeof_operation> (); }\n ;\n \n ArrayLiteral:\n@@ -595,14 +605,10 @@ TypeExp:\n \t'(' TypeExp ')'\n \t\t{ /* Do nothing.  */ }\n |\tBasicType\n-\t\t{ write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t  write_exp_elt_type (pstate, $1);\n-\t\t  write_exp_elt_opcode (pstate, OP_TYPE); }\n+\t\t{ pstate->push_new<type_operation> ($1); }\n |\tBasicType BasicType2\n \t\t{ $$ = type_stack->follow_types ($1);\n-\t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n-\t\t  write_exp_elt_type (pstate, $$);\n-\t\t  write_exp_elt_opcode (pstate, OP_TYPE);\n+\t\t  pstate->push_new<type_operation> ($$);\n \t\t}\n ;\n \n@@ -1622,7 +1628,10 @@ d_parse (struct parser_state *par_state)\n   popping = 0;\n   name_obstack.clear ();\n \n-  return yyparse ();\n+  int result = yyparse ();\n+  if (!result)\n+    pstate->set_operation (pstate->pop ());\n+  return result;\n }\n \n static void"
    }
  ]
}