{
  "sha": "1f6c8c3317e5692e9994c18f427b45093863d572",
  "node_id": "C_kwDOANOeidoAKDFmNmM4YzMzMTdlNTY5MmU5OTk0YzE4ZjQyN2I0NTA5Mzg2M2Q1NzI",
  "commit": {
    "author": {
      "name": "Jan Vrany",
      "email": "jan.vrany@labware.com",
      "date": "2020-06-23T13:45:38Z"
    },
    "committer": {
      "name": "Andrew Burgess",
      "email": "aburgess@redhat.com",
      "date": "2021-12-14T11:28:00Z"
    },
    "message": "gdb/mi: use separate classes for different types of MI command\n\nThis commit changes the infrastructure in mi-cmds.{c,h} to add new\nsub-classes for the different types of MI command.  Instances of these\nsub-classes are then created and added into mi_cmd_table.\n\nThe existing mi_cmd class becomes the abstract base class, this has an\ninvoke method and takes care of the suppress notifications handling,\nbefore calling a do_invoke virtual method which is implemented by all\nof the sub-classes.\n\nThere's currently two different sub-classes, one of pure MI commands,\nand a second for MI commands that delegate to CLI commands.\n\nThere should be no user visible changes after this commit.",
    "tree": {
      "sha": "bec5656e39509e778ead182d9fff1388945b4ef9",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/git/trees/bec5656e39509e778ead182d9fff1388945b4ef9"
    },
    "url": "https://api.github.com/repos/bminor/binutils-gdb/git/commits/1f6c8c3317e5692e9994c18f427b45093863d572",
    "comment_count": 0,
    "verification": {
      "verified": false,
      "reason": "unsigned",
      "signature": null,
      "payload": null
    }
  },
  "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f6c8c3317e5692e9994c18f427b45093863d572",
  "html_url": "https://github.com/bminor/binutils-gdb/commit/1f6c8c3317e5692e9994c18f427b45093863d572",
  "comments_url": "https://api.github.com/repos/bminor/binutils-gdb/commits/1f6c8c3317e5692e9994c18f427b45093863d572/comments",
  "author": {
    "login": "janvrany",
    "id": 82951,
    "node_id": "MDQ6VXNlcjgyOTUx",
    "avatar_url": "https://avatars.githubusercontent.com/u/82951?v=4",
    "gravatar_id": "",
    "url": "https://api.github.com/users/janvrany",
    "html_url": "https://github.com/janvrany",
    "followers_url": "https://api.github.com/users/janvrany/followers",
    "following_url": "https://api.github.com/users/janvrany/following{/other_user}",
    "gists_url": "https://api.github.com/users/janvrany/gists{/gist_id}",
    "starred_url": "https://api.github.com/users/janvrany/starred{/owner}{/repo}",
    "subscriptions_url": "https://api.github.com/users/janvrany/subscriptions",
    "organizations_url": "https://api.github.com/users/janvrany/orgs",
    "repos_url": "https://api.github.com/users/janvrany/repos",
    "events_url": "https://api.github.com/users/janvrany/events{/privacy}",
    "received_events_url": "https://api.github.com/users/janvrany/received_events",
    "type": "User",
    "site_admin": false
  },
  "committer": null,
  "parents": [
    {
      "sha": "3be0fed62e0dfb36d674944fe85eaebbf70b9029",
      "url": "https://api.github.com/repos/bminor/binutils-gdb/commits/3be0fed62e0dfb36d674944fe85eaebbf70b9029",
      "html_url": "https://github.com/bminor/binutils-gdb/commit/3be0fed62e0dfb36d674944fe85eaebbf70b9029"
    }
  ],
  "stats": {
    "total": 280,
    "additions": 181,
    "deletions": 99
  },
  "files": [
    {
      "sha": "58892fe58ffb711bb43dc7b152119f2c93587328",
      "filename": "gdb/mi/mi-cmds.c",
      "status": "modified",
      "additions": 113,
      "deletions": 27,
      "changes": 140,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-cmds.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-cmds.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmds.c?ref=1f6c8c3317e5692e9994c18f427b45093863d572",
      "patch": "@@ -22,6 +22,7 @@\n #include \"top.h\"\n #include \"mi-cmds.h\"\n #include \"mi-main.h\"\n+#include \"mi-parse.h\"\n #include <map>\n #include <string>\n \n@@ -33,6 +34,80 @@ using mi_cmd_up = std::unique_ptr<struct mi_cmd>;\n \n static std::map<std::string, mi_cmd_up> mi_cmd_table;\n \n+/* MI command with a pure MI implementation.  */\n+\n+struct mi_command_mi : public mi_cmd\n+{\n+  /* Constructor.  For NAME and SUPPRESS_NOTIFICATION see mi_cmd\n+     constructor, FUNC is the function called from do_invoke, which\n+     implements this MI command.  */\n+  mi_command_mi (const char *name, mi_cmd_argv_ftype func,\n+                 int *suppress_notification)\n+    : mi_cmd (name, suppress_notification),\n+      m_argv_function (func)\n+  {\n+    gdb_assert (func != nullptr);\n+  }\n+\n+protected:\n+\n+  /* Called when this MI command has been invoked, calls m_argv_function\n+     with arguments contained within PARSE.  */\n+  void do_invoke (struct mi_parse *parse) const override\n+  {\n+    mi_parse_argv (parse->args, parse);\n+\n+    if (parse->argv == nullptr)\n+      error (_(\"Problem parsing arguments: %s %s\"), parse->command,\n+\t     parse->args);\n+\n+    this->m_argv_function (parse->command, parse->argv, parse->argc);\n+  }\n+\n+private:\n+\n+  /* The function that implements this MI command.  */\n+  mi_cmd_argv_ftype *m_argv_function;\n+};\n+\n+/* MI command implemented on top of a CLI command.  */\n+\n+struct mi_command_cli : public mi_cmd\n+{\n+  /* Constructor.  For NAME and SUPPRESS_NOTIFICATION see mi_cmd\n+     constructor, CLI_NAME is the name of a CLI command that should be\n+     invoked to implement this MI command.  If ARGS_P is true then any\n+     arguments from entered by the user as part of the MI command line are\n+     forwarded to CLI_NAME as its argument string, otherwise, if ARGS_P is\n+     false, nullptr is send to CLI_NAME as its argument string.  */\n+  mi_command_cli (const char *name, const char *cli_name, bool args_p,\n+                  int *suppress_notification)\n+    : mi_cmd (name, suppress_notification),\n+      m_cli_name (cli_name),\n+      m_args_p (args_p)\n+  { /* Nothing.  */ }\n+\n+protected:\n+\n+  /* Called when this MI command has been invoked, calls the m_cli_name\n+     CLI function.  In m_args_p is true then the argument string from\n+     within PARSE is passed through to the CLI function, otherwise nullptr\n+     is passed through to the CLI function as its argument string.  */\n+  void do_invoke (struct mi_parse *parse) const override\n+  {\n+    const char *args = m_args_p ? parse->args : nullptr;\n+    mi_execute_cli_command (m_cli_name, m_args_p, args);\n+  }\n+\n+private:\n+\n+  /* The name of the CLI command to execute.  */\n+  const char *m_cli_name;\n+\n+  /* Should we be passing an argument string to the m_cli_name function?  */\n+  bool m_args_p;\n+};\n+\n /* Insert COMMAND into the global mi_cmd_table.  Return false if\n    COMMAND->name already exists in mi_cmd_table, in which case COMMAND will\n    not have been added to mi_cmd_table.  Otherwise, return true, and\n@@ -42,9 +117,8 @@ static bool\n insert_mi_cmd_entry (mi_cmd_up command)\n {\n   gdb_assert (command != nullptr);\n-  gdb_assert (command->name != nullptr);\n \n-  std::string name (command->name);\n+  const std::string &name = command->name ();\n \n   if (mi_cmd_table.find (name) != mi_cmd_table.end ())\n     return false;\n@@ -53,16 +127,6 @@ insert_mi_cmd_entry (mi_cmd_up command)\n   return true;\n }\n \n-/* Create an mi_cmd structure with name NAME.  */\n-\n-static mi_cmd_up\n-create_mi_cmd (const char *name)\n-{\n-  mi_cmd_up cmd (new mi_cmd ());\n-  cmd->name = name;\n-  return cmd;\n-}\n-\n /* Create and register a new MI command with an MI specific implementation.\n    NAME must name an MI command that does not already exist, otherwise an\n    assertion will trigger.  */\n@@ -71,14 +135,10 @@ static void\n add_mi_cmd_mi (const char *name, mi_cmd_argv_ftype function,\n \t       int *suppress_notification = nullptr)\n {\n-  mi_cmd_up cmd_up = create_mi_cmd (name);\n-\n-  cmd_up->cli.cmd = nullptr;\n-  cmd_up->cli.args_p = 0;\n-  cmd_up->argv_func = function;\n-  cmd_up->suppress_notification = suppress_notification;\n+  mi_cmd_up command (new mi_command_mi (name, function,\n+                                        suppress_notification));\n \n-  bool success = insert_mi_cmd_entry (std::move (cmd_up));\n+  bool success = insert_mi_cmd_entry (std::move (command));\n   gdb_assert (success);\n }\n \n@@ -90,18 +150,44 @@ static void\n add_mi_cmd_cli (const char *name, const char *cli_name, int args_p,\n \t\tint *suppress_notification = nullptr)\n {\n-  mi_cmd_up cmd_up = create_mi_cmd (name);\n-\n-  cmd_up->cli.cmd = cli_name;\n-  cmd_up->cli.args_p = args_p;\n-  cmd_up->argv_func = nullptr;\n-  cmd_up->suppress_notification = suppress_notification;\n+  mi_cmd_up command (new mi_command_cli (name, cli_name, args_p != 0,\n+                                         suppress_notification));\n \n-  bool success = insert_mi_cmd_entry (std::move (cmd_up));\n+  bool success = insert_mi_cmd_entry (std::move (command));\n   gdb_assert (success);\n }\n \n-/* Initialize MI_CMD_TABLE, the global map of MI commands.  */\n+/* See mi-cmds.h.  */\n+\n+mi_cmd::mi_cmd (const char *name, int *suppress_notification)\n+  : m_name (name),\n+    m_suppress_notification (suppress_notification)\n+{\n+  gdb_assert (m_name != nullptr && m_name[0] != '\\0');\n+}\n+\n+/* See mi-cmds.h.  */\n+\n+void\n+mi_cmd::invoke (struct mi_parse *parse) const\n+{\n+  gdb::optional<scoped_restore_tmpl<int>> restore\n+    = do_suppress_notification ();\n+  this->do_invoke (parse);\n+}\n+\n+/* See mi-cmds.h.  */\n+\n+gdb::optional<scoped_restore_tmpl<int>>\n+mi_cmd::do_suppress_notification () const\n+{\n+  if (m_suppress_notification != nullptr)\n+    return scoped_restore_tmpl<int> (m_suppress_notification, 1);\n+  else\n+    return {};\n+}\n+\n+/* Initialize the available MI commands.  */\n \n static void\n build_table ()"
    },
    {
      "sha": "d405f877e1d417a7be655c93a055d2650c13f7a2",
      "filename": "gdb/mi/mi-cmds.h",
      "status": "modified",
      "additions": 46,
      "deletions": 23,
      "changes": 69,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-cmds.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-cmds.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-cmds.h?ref=1f6c8c3317e5692e9994c18f427b45093863d572",
      "patch": "@@ -22,6 +22,8 @@\n #ifndef MI_MI_CMDS_H\n #define MI_MI_CMDS_H\n \n+#include \"gdbsupport/gdb_optional.h\"\n+\n enum print_values {\n    PRINT_NO_VALUES,\n    PRINT_ALL_VALUES,\n@@ -137,37 +139,58 @@ extern mi_cmd_argv_ftype mi_cmd_enable_frame_filters;\n extern mi_cmd_argv_ftype mi_cmd_var_set_update_range;\n extern mi_cmd_argv_ftype mi_cmd_complete;\n \n-/* Description of a single command.  */\n-\n-struct mi_cli\n-{\n-  /* Corresponding CLI command.  If ARGS_P is non-zero, the MI\n-     command's argument list is appended to the CLI command.  */\n-  const char *cmd;\n-  int args_p;\n-};\n+/* The abstract base class for all MI command types.  */\n \n struct mi_cmd\n {\n-  /* Official name of the command.  */\n-  const char *name;\n-  /* The corresponding CLI command that can be used to implement this\n-     MI command (if cli.lhs is non NULL).  */\n-  struct mi_cli cli;\n-  /* If non-null, the function implementing the MI command.  */\n-  mi_cmd_argv_ftype *argv_func;\n-  /* If non-null, the pointer to a field in\n-     'struct mi_suppress_notification', which will be set to true by MI\n-     command processor (mi-main.c:mi_cmd_execute) when this command is\n-     being executed.  It will be set back to false when command has been\n-     executed.  */\n-  int *suppress_notification;\n+  /* Constructor.  NAME is the name of this MI command, excluding any\n+     leading dash, that is the initial string the user will enter to run\n+     this command.  The SUPPRESS_NOTIFICATION pointer is a flag which will\n+     be set to 1 when this command is invoked, and reset to its previous\n+     value once the command invocation has completed.  */\n+  mi_cmd (const char *name, int *suppress_notification);\n+\n+  /* Destructor.  */\n+  virtual ~mi_cmd () = default;\n+\n+  /* Return the name of this command.  This is the command that the user\n+     will actually type in, without any arguments, and without the leading\n+     dash.  */\n+  const char *name () const\n+  { return m_name; }\n+\n+  /* Execute the MI command.  Can throw an exception if something goes\n+     wrong.  */\n+  void invoke (struct mi_parse *parse) const;\n+\n+protected:\n+\n+  /* The core of command invocation, this needs to be overridden in each\n+     base class.  PARSE is the parsed command line from the user.  */\n+  virtual void do_invoke (struct mi_parse *parse) const = 0;\n+\n+private:\n+\n+  /* If this command was created with a suppress notifications pointer,\n+     then this function will set the suppress flag and return a\n+     gdb::optional with its value set to an object that will restore the\n+     previous value of the suppress notifications flag.\n+\n+     If this command was created without a suppress notifications points,\n+     then this function returns an empty gdb::optional.  */\n+  gdb::optional<scoped_restore_tmpl<int>> do_suppress_notification () const;\n+\n+  /* The name of the command.  */\n+  const char *m_name;\n+\n+  /* Pointer to integer to set during command's invocation.  */\n+  int *m_suppress_notification;\n };\n \n /* Lookup a command in the MI command table, returns nullptr if COMMAND is\n    not found.  */\n \n-extern struct mi_cmd *mi_cmd_lookup (const char *command);\n+extern mi_cmd *mi_cmd_lookup (const char *command);\n \n /* Debug flag */\n extern int mi_debug_p;"
    },
    {
      "sha": "710eef7e725069bab1f81a13126c17a2c32a1020",
      "filename": "gdb/mi/mi-main.c",
      "status": "modified",
      "additions": 3,
      "deletions": 34,
      "changes": 37,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-main.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-main.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.c?ref=1f6c8c3317e5692e9994c18f427b45093863d572",
      "patch": "@@ -90,8 +90,6 @@ int mi_proceeded;\n \n static void mi_cmd_execute (struct mi_parse *parse);\n \n-static void mi_execute_cli_command (const char *cmd, bool args_p,\n-\t\t\t\t    const char *args);\n static void mi_execute_async_cli_command (const char *cli_command,\n \t\t\t\t\t  char **argv, int argc);\n static bool register_changed_p (int regnum, readonly_detached_regcache *,\n@@ -1936,11 +1934,6 @@ mi_execute_command (const char *cmd, int from_tty)\n     {\n       ptid_t previous_ptid = inferior_ptid;\n \n-      gdb::optional<scoped_restore_tmpl<int>> restore_suppress;\n-\n-      if (command->cmd != NULL && command->cmd->suppress_notification != NULL)\n-\trestore_suppress.emplace (command->cmd->suppress_notification, 1);\n-\n       command->token = token;\n \n       if (do_timings)\n@@ -2079,35 +2072,11 @@ mi_cmd_execute (struct mi_parse *parse)\n \n   current_context = parse;\n \n-  if (parse->cmd->argv_func != NULL)\n-    {\n-      parse->cmd->argv_func (parse->command, parse->argv, parse->argc);\n-    }\n-  else if (parse->cmd->cli.cmd != 0)\n-    {\n-      /* FIXME: DELETE THIS. */\n-      /* The operation is still implemented by a cli command.  */\n-      /* Must be a synchronous one.  */\n-      bool args_p = parse->cmd->cli.args_p != 0;\n-      const char *args = args_p ? parse->args : nullptr;\n-      mi_execute_cli_command (parse->cmd->cli.cmd, args_p, args);\n-    }\n-  else\n-    {\n-      /* FIXME: DELETE THIS.  */\n-      string_file stb;\n-\n-      stb.puts (\"Undefined mi command: \");\n-      stb.putstr (parse->command, '\"');\n-      stb.puts (\" (missing implementation)\");\n-\n-      error_stream (stb);\n-    }\n+  gdb_assert (parse->cmd != nullptr);\n+  parse->cmd->invoke (parse);\n }\n \n-/* FIXME: This is just a hack so we can get some extra commands going.\n-   We don't want to channel things through the CLI, but call libgdb directly.\n-   Use only for synchronous commands.  */\n+/* See mi-main.h.  */\n \n void\n mi_execute_cli_command (const char *cmd, bool args_p, const char *args)"
    },
    {
      "sha": "064f1d587f223574cbe82026ba5c9102562d5c8d",
      "filename": "gdb/mi/mi-main.h",
      "status": "modified",
      "additions": 12,
      "deletions": 0,
      "changes": 12,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-main.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-main.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-main.h?ref=1f6c8c3317e5692e9994c18f427b45093863d572",
      "patch": "@@ -54,6 +54,18 @@ struct mi_suppress_notification\n };\n extern struct mi_suppress_notification mi_suppress_notification;\n \n+/* This is a hack so we can get some extra commands going, but has existed\n+   within GDB for many years now.  Ideally we don't want to channel things\n+   through the CLI, but implement all commands as pure MI commands with\n+   their own implementation.\n+\n+   Execute the CLI command CMD, if ARGS_P is true then ARGS should be a\n+   non-nullptr string containing arguments to add after CMD.  If ARGS_P is\n+   false then ARGS must be nullptr.  */\n+\n+extern void mi_execute_cli_command (const char *cmd, bool args_p,\n+\t\t\t\t    const char *args);\n+\n /* Implementation of -fix-multi-location-breakpoint-output.  */\n \n extern void mi_cmd_fix_multi_location_breakpoint_output (const char *command,"
    },
    {
      "sha": "203024fb01c1d2fcb3cd944d260b737390e75500",
      "filename": "gdb/mi/mi-parse.c",
      "status": "modified",
      "additions": 3,
      "deletions": 15,
      "changes": 18,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-parse.c",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-parse.c",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-parse.c?ref=1f6c8c3317e5692e9994c18f427b45093863d572",
      "patch": "@@ -106,7 +106,7 @@ mi_parse_escape (const char **string_ptr)\n   return c;\n }\n \n-static void\n+void\n mi_parse_argv (const char *args, struct mi_parse *parse)\n {\n   const char *chp = args;\n@@ -363,20 +363,8 @@ mi_parse (const char *cmd, char **token)\n       chp = skip_spaces (chp);\n     }\n \n-  /* For new argv commands, attempt to return the parsed argument\n-     list.  */\n-  if (parse->cmd->argv_func != NULL)\n-    {\n-      mi_parse_argv (chp, parse.get ());\n-      if (parse->argv == NULL)\n-\terror (_(\"Problem parsing arguments: %s %s\"), parse->command, chp);\n-    }\n-\n-  /* FIXME: DELETE THIS */\n-  /* For CLI commands, also return the remainder of the\n-     command line as a single string. */\n-  if (parse->cmd->cli.cmd != NULL)\n-    parse->args = xstrdup (chp);\n+  /* Save the rest of the arguments for the command.  */\n+  parse->args = xstrdup (chp);\n \n   /* Fully parsed, flag as an MI command.  */\n   parse->op = MI_COMMAND;"
    },
    {
      "sha": "ceaac72e867c28f58787b8fbee5f4f829d4d7dcf",
      "filename": "gdb/mi/mi-parse.h",
      "status": "modified",
      "additions": 4,
      "deletions": 0,
      "changes": 4,
      "blob_url": "https://github.com/bminor/binutils-gdb/blob/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-parse.h",
      "raw_url": "https://github.com/bminor/binutils-gdb/raw/1f6c8c3317e5692e9994c18f427b45093863d572/gdb/mi/mi-parse.h",
      "contents_url": "https://api.github.com/repos/bminor/binutils-gdb/contents/gdb/mi/mi-parse.h?ref=1f6c8c3317e5692e9994c18f427b45093863d572",
      "patch": "@@ -79,4 +79,8 @@ extern std::unique_ptr<struct mi_parse> mi_parse (const char *cmd,\n \n enum print_values mi_parse_print_values (const char *name);\n \n+/* Split ARGS into argc/argv and store the result in PARSE.  */\n+\n+extern void mi_parse_argv (const char *args, struct mi_parse *parse);\n+\n #endif /* MI_MI_PARSE_H */"
    }
  ]
}